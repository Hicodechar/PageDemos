
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.9.22 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.9.22</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>April 12, 2017, 11:07 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170412110707.GB28787@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9677155/mbox/"
   >mbox</a>
|
   <a href="/patch/9677155/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9677155/">/patch/9677155/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	6DD0C601C3 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 12 Apr 2017 11:07:49 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 4D1D928619
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 12 Apr 2017 11:07:49 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 3FF7A28621; Wed, 12 Apr 2017 11:07:49 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9483F28619
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 12 Apr 2017 11:07:39 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753668AbdDLLHe (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 12 Apr 2017 07:07:34 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:44424 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752697AbdDLLHT (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 12 Apr 2017 07:07:19 -0400
Received: from localhost (084035110146.static.ipv4.infopact.nl
	[84.35.110.146])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id EB5B371F;
	Wed, 12 Apr 2017 11:07:16 +0000 (UTC)
Date: Wed, 12 Apr 2017 13:07:07 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.9.22
Message-ID: &lt;20170412110707.GB28787@kroah.com&gt;
References: &lt;20170412110702.GA28787@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170412110702.GA28787@kroah.com&gt;
User-Agent: Mutt/1.8.0 (2017-02-23)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - April 12, 2017, 11:07 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/arm/arch_timer.txt b/Documentation/devicetree/bindings/arm/arch_timer.txt</span>
<span class="p_header">index ef5fbe9a77c7..ad440a2b8051 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/arm/arch_timer.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/arm/arch_timer.txt</span>
<span class="p_chunk">@@ -38,6 +38,11 @@</span> <span class="p_context"> to deliver its interrupts via SPIs.</span>
   architecturally-defined reset values. Only supported for 32-bit
   systems which follow the ARMv7 architected reset values.
 
<span class="p_add">+- arm,no-tick-in-suspend : The main counter does not tick when the system is in</span>
<span class="p_add">+  low-power system suspend on some SoCs. This behavior does not match the</span>
<span class="p_add">+  Architecture Reference Manual&#39;s specification that the system counter &quot;must</span>
<span class="p_add">+  be implemented in an always-on power domain.&quot;</span>
<span class="p_add">+</span>
 
 Example:
 
<span class="p_header">diff --git a/Documentation/devicetree/bindings/display/sunxi/sun4i-drm.txt b/Documentation/devicetree/bindings/display/sunxi/sun4i-drm.txt</span>
<span class="p_header">index b95696d748c7..4f7ae7555758 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/display/sunxi/sun4i-drm.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/display/sunxi/sun4i-drm.txt</span>
<span class="p_chunk">@@ -28,6 +28,8 @@</span> <span class="p_context"> The TCON acts as a timing controller for RGB, LVDS and TV interfaces.</span>
 Required properties:
  - compatible: value must be either:
    * allwinner,sun5i-a13-tcon
<span class="p_add">+   * allwinner,sun6i-a31-tcon</span>
<span class="p_add">+   * allwinner,sun6i-a31s-tcon</span>
    * allwinner,sun8i-a33-tcon
  - reg: base address and size of memory-mapped region
  - interrupts: interrupt associated to this IP
<span class="p_chunk">@@ -50,7 +52,7 @@</span> <span class="p_context"> Required properties:</span>
   second the block connected to the TCON channel 1 (usually the TV
   encoder)
 
<span class="p_del">-On the A13, there is one more clock required:</span>
<span class="p_add">+On SoCs other than the A33, there is one more clock required:</span>
    - &#39;tcon-ch1&#39;: The clock driving the TCON channel 1
 
 DRC
<span class="p_chunk">@@ -87,6 +89,7 @@</span> <span class="p_context"> system.</span>
 Required properties:
   - compatible: value must be one of:
     * allwinner,sun5i-a13-display-backend
<span class="p_add">+    * allwinner,sun6i-a31-display-backend</span>
     * allwinner,sun8i-a33-display-backend
   - reg: base address and size of the memory-mapped region.
   - clocks: phandles to the clocks feeding the frontend and backend
<span class="p_chunk">@@ -117,6 +120,7 @@</span> <span class="p_context"> deinterlacing and color space conversion.</span>
 Required properties:
   - compatible: value must be one of:
     * allwinner,sun5i-a13-display-frontend
<span class="p_add">+    * allwinner,sun6i-a31-display-frontend</span>
     * allwinner,sun8i-a33-display-frontend
   - reg: base address and size of the memory-mapped region.
   - interrupts: interrupt associated to this IP
<span class="p_chunk">@@ -142,6 +146,8 @@</span> <span class="p_context"> extra node.</span>
 Required properties:
   - compatible: value must be one of:
     * allwinner,sun5i-a13-display-engine
<span class="p_add">+    * allwinner,sun6i-a31-display-engine</span>
<span class="p_add">+    * allwinner,sun6i-a31s-display-engine</span>
     * allwinner,sun8i-a33-display-engine
 
   - allwinner,pipelines: list of phandle to the display engine
<span class="p_header">diff --git a/Documentation/devicetree/bindings/usb/usb-xhci.txt b/Documentation/devicetree/bindings/usb/usb-xhci.txt</span>
<span class="p_header">index 966885c636d0..7790c819859a 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/usb/usb-xhci.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/usb/usb-xhci.txt</span>
<span class="p_chunk">@@ -26,6 +26,7 @@</span> <span class="p_context"> Required properties:</span>
 Optional properties:
   - clocks: reference to a clock
   - usb3-lpm-capable: determines if platform is USB3 LPM capable
<span class="p_add">+  - quirk-broken-port-ped: set if the controller has broken port disable mechanism</span>
 
 Example:
 	usb@f0931000 {
<span class="p_header">diff --git a/Documentation/devicetree/bindings/watchdog/samsung-wdt.txt b/Documentation/devicetree/bindings/watchdog/samsung-wdt.txt</span>
<span class="p_header">index 8f3d96af81d7..1f6e101e299a 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/watchdog/samsung-wdt.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/watchdog/samsung-wdt.txt</span>
<span class="p_chunk">@@ -6,10 +6,11 @@</span> <span class="p_context"> occurred.</span>
 
 Required properties:
 - compatible : should be one among the following
<span class="p_del">-	(a) &quot;samsung,s3c2410-wdt&quot; for Exynos4 and previous SoCs</span>
<span class="p_del">-	(b) &quot;samsung,exynos5250-wdt&quot; for Exynos5250</span>
<span class="p_del">-	(c) &quot;samsung,exynos5420-wdt&quot; for Exynos5420</span>
<span class="p_del">-	(c) &quot;samsung,exynos7-wdt&quot; for Exynos7</span>
<span class="p_add">+	- &quot;samsung,s3c2410-wdt&quot; for S3C2410</span>
<span class="p_add">+	- &quot;samsung,s3c6410-wdt&quot; for S3C6410, S5PV210 and Exynos4</span>
<span class="p_add">+	- &quot;samsung,exynos5250-wdt&quot; for Exynos5250</span>
<span class="p_add">+	- &quot;samsung,exynos5420-wdt&quot; for Exynos5420</span>
<span class="p_add">+	- &quot;samsung,exynos7-wdt&quot; for Exynos7</span>
 
 - reg : base physical address of the controller and length of memory mapped
 	region.
<span class="p_header">diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt</span>
<span class="p_header">index 65b05ba6ef98..a6fadef92d6d 100644</span>
<span class="p_header">--- a/Documentation/kernel-parameters.txt</span>
<span class="p_header">+++ b/Documentation/kernel-parameters.txt</span>
<span class="p_chunk">@@ -305,6 +305,16 @@</span> <span class="p_context"> bytes respectively. Such letter suffixes can also be entirely omitted.</span>
 			use by PCI
 			Format: &lt;irq&gt;,&lt;irq&gt;...
 
<span class="p_add">+	acpi_mask_gpe=  [HW,ACPI]</span>
<span class="p_add">+			Due to the existence of _Lxx/_Exx, some GPEs triggered</span>
<span class="p_add">+			by unsupported hardware/firmware features can result in</span>
<span class="p_add">+                        GPE floodings that cannot be automatically disabled by</span>
<span class="p_add">+                        the GPE dispatcher.</span>
<span class="p_add">+			This facility can be used to prevent such uncontrolled</span>
<span class="p_add">+			GPE floodings.</span>
<span class="p_add">+			Format: &lt;int&gt;</span>
<span class="p_add">+			Support masking of GPEs numbered from 0x00 to 0x7f.</span>
<span class="p_add">+</span>
 	acpi_no_auto_serialize	[HW,ACPI]
 			Disable auto-serialization of AML methods
 			AML control methods that contain the opcodes to create
<span class="p_header">diff --git a/Documentation/stable_kernel_rules.txt b/Documentation/stable_kernel_rules.txt</span>
<span class="p_header">index 4d82e31b7958..501af5d5feba 100644</span>
<span class="p_header">--- a/Documentation/stable_kernel_rules.txt</span>
<span class="p_header">+++ b/Documentation/stable_kernel_rules.txt</span>
<span class="p_chunk">@@ -124,7 +124,7 @@</span> <span class="p_context"> specified in the following format in the sign-off area:</span>
 
 .. code-block:: none
 
<span class="p_del">-     Cc: &lt;stable@vger.kernel.org&gt; # 3.3.x-</span>
<span class="p_add">+     Cc: &lt;stable@vger.kernel.org&gt; # 3.3.x</span>
 
 The tag has the meaning of:
 
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 1523557bd61f..4bf4648d97db 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 9
<span class="p_del">-SUBLEVEL = 21</span>
<span class="p_add">+SUBLEVEL = 22</span>
 EXTRAVERSION =
 NAME = Roaring Lionus
 
<span class="p_chunk">@@ -370,7 +370,7 @@</span> <span class="p_context"> LDFLAGS_MODULE  =</span>
 CFLAGS_KERNEL	=
 AFLAGS_KERNEL	=
 LDFLAGS_vmlinux =
<span class="p_del">-CFLAGS_GCOV	= -fprofile-arcs -ftest-coverage -fno-tree-loop-im -Wno-maybe-uninitialized</span>
<span class="p_add">+CFLAGS_GCOV	:= -fprofile-arcs -ftest-coverage -fno-tree-loop-im $(call cc-disable-warning,maybe-uninitialized,)</span>
 CFLAGS_KCOV	:= $(call cc-option,-fsanitize-coverage=trace-pc,)
 
 
<span class="p_header">diff --git a/arch/arm/boot/dts/stih407-family.dtsi b/arch/arm/boot/dts/stih407-family.dtsi</span>
<span class="p_header">index 8f79b4147bba..acdcbf99a22f 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/stih407-family.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/stih407-family.dtsi</span>
<span class="p_chunk">@@ -680,6 +680,7 @@</span> <span class="p_context"></span>
 				phy-names	= &quot;usb2-phy&quot;, &quot;usb3-phy&quot;;
 				phys		= &lt;&amp;usb2_picophy0&gt;,
 						  &lt;&amp;phy_port2 PHY_TYPE_USB3&gt;;
<span class="p_add">+				snps,dis_u3_susphy_quirk;</span>
 			};
 		};
 
<span class="p_header">diff --git a/arch/arm/kernel/armksyms.c b/arch/arm/kernel/armksyms.c</span>
<span class="p_header">index 7e45f69a0ddc..8e8d20cdbce7 100644</span>
<span class="p_header">--- a/arch/arm/kernel/armksyms.c</span>
<span class="p_header">+++ b/arch/arm/kernel/armksyms.c</span>
<span class="p_chunk">@@ -178,6 +178,6 @@</span> <span class="p_context"> EXPORT_SYMBOL(__pv_offset);</span>
 #endif
 
 #ifdef CONFIG_HAVE_ARM_SMCCC
<span class="p_del">-EXPORT_SYMBOL(arm_smccc_smc);</span>
<span class="p_del">-EXPORT_SYMBOL(arm_smccc_hvc);</span>
<span class="p_add">+EXPORT_SYMBOL(__arm_smccc_smc);</span>
<span class="p_add">+EXPORT_SYMBOL(__arm_smccc_hvc);</span>
 #endif
<span class="p_header">diff --git a/arch/arm/kernel/smccc-call.S b/arch/arm/kernel/smccc-call.S</span>
<span class="p_header">index 2e48b674aab1..e5d43066b889 100644</span>
<span class="p_header">--- a/arch/arm/kernel/smccc-call.S</span>
<span class="p_header">+++ b/arch/arm/kernel/smccc-call.S</span>
<span class="p_chunk">@@ -46,17 +46,19 @@</span> <span class="p_context"> UNWIND(	.fnend)</span>
 /*
  * void smccc_smc(unsigned long a0, unsigned long a1, unsigned long a2,
  *		  unsigned long a3, unsigned long a4, unsigned long a5,
<span class="p_del">- *		  unsigned long a6, unsigned long a7, struct arm_smccc_res *res)</span>
<span class="p_add">+ *		  unsigned long a6, unsigned long a7, struct arm_smccc_res *res,</span>
<span class="p_add">+ *		  struct arm_smccc_quirk *quirk)</span>
  */
<span class="p_del">-ENTRY(arm_smccc_smc)</span>
<span class="p_add">+ENTRY(__arm_smccc_smc)</span>
 	SMCCC SMCCC_SMC
<span class="p_del">-ENDPROC(arm_smccc_smc)</span>
<span class="p_add">+ENDPROC(__arm_smccc_smc)</span>
 
 /*
  * void smccc_hvc(unsigned long a0, unsigned long a1, unsigned long a2,
  *		  unsigned long a3, unsigned long a4, unsigned long a5,
<span class="p_del">- *		  unsigned long a6, unsigned long a7, struct arm_smccc_res *res)</span>
<span class="p_add">+ *		  unsigned long a6, unsigned long a7, struct arm_smccc_res *res,</span>
<span class="p_add">+ *		  struct arm_smccc_quirk *quirk)</span>
  */
<span class="p_del">-ENTRY(arm_smccc_hvc)</span>
<span class="p_add">+ENTRY(__arm_smccc_hvc)</span>
 	SMCCC SMCCC_HVC
<span class="p_del">-ENDPROC(arm_smccc_hvc)</span>
<span class="p_add">+ENDPROC(__arm_smccc_hvc)</span>
<span class="p_header">diff --git a/arch/arm/kvm/mmu.c b/arch/arm/kvm/mmu.c</span>
<span class="p_header">index a5265edbeeab..2fd5c135e8a4 100644</span>
<span class="p_header">--- a/arch/arm/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/kvm/mmu.c</span>
<span class="p_chunk">@@ -292,11 +292,18 @@</span> <span class="p_context"> static void unmap_stage2_range(struct kvm *kvm, phys_addr_t start, u64 size)</span>
 	phys_addr_t addr = start, end = start + size;
 	phys_addr_t next;
 
<span class="p_add">+	assert_spin_locked(&amp;kvm-&gt;mmu_lock);</span>
 	pgd = kvm-&gt;arch.pgd + stage2_pgd_index(addr);
 	do {
 		next = stage2_pgd_addr_end(addr, end);
 		if (!stage2_pgd_none(*pgd))
 			unmap_stage2_puds(kvm, pgd, addr, next);
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If the range is too large, release the kvm-&gt;mmu_lock</span>
<span class="p_add">+		 * to prevent starvation and lockup detector warnings.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (next != end)</span>
<span class="p_add">+			cond_resched_lock(&amp;kvm-&gt;mmu_lock);</span>
 	} while (pgd++, addr = next, addr != end);
 }
 
<span class="p_chunk">@@ -803,6 +810,7 @@</span> <span class="p_context"> void stage2_unmap_vm(struct kvm *kvm)</span>
 	int idx;
 
 	idx = srcu_read_lock(&amp;kvm-&gt;srcu);
<span class="p_add">+	down_read(&amp;current-&gt;mm-&gt;mmap_sem);</span>
 	spin_lock(&amp;kvm-&gt;mmu_lock);
 
 	slots = kvm_memslots(kvm);
<span class="p_chunk">@@ -810,6 +818,7 @@</span> <span class="p_context"> void stage2_unmap_vm(struct kvm *kvm)</span>
 		stage2_unmap_memslot(kvm, memslot);
 
 	spin_unlock(&amp;kvm-&gt;mmu_lock);
<span class="p_add">+	up_read(&amp;current-&gt;mm-&gt;mmap_sem);</span>
 	srcu_read_unlock(&amp;kvm-&gt;srcu, idx);
 }
 
<span class="p_chunk">@@ -829,7 +838,10 @@</span> <span class="p_context"> void kvm_free_stage2_pgd(struct kvm *kvm)</span>
 	if (kvm-&gt;arch.pgd == NULL)
 		return;
 
<span class="p_add">+	spin_lock(&amp;kvm-&gt;mmu_lock);</span>
 	unmap_stage2_range(kvm, 0, KVM_PHYS_SIZE);
<span class="p_add">+	spin_unlock(&amp;kvm-&gt;mmu_lock);</span>
<span class="p_add">+</span>
 	/* Free the HW pgd, one page at a time */
 	free_pages_exact(kvm-&gt;arch.pgd, S2_PGD_SIZE);
 	kvm-&gt;arch.pgd = NULL;
<span class="p_chunk">@@ -1804,6 +1816,7 @@</span> <span class="p_context"> int kvm_arch_prepare_memory_region(struct kvm *kvm,</span>
 	    (KVM_PHYS_SIZE &gt;&gt; PAGE_SHIFT))
 		return -EFAULT;
 
<span class="p_add">+	down_read(&amp;current-&gt;mm-&gt;mmap_sem);</span>
 	/*
 	 * A memory region could potentially cover multiple VMAs, and any holes
 	 * between them, so iterate over all of them to find out if we can map
<span class="p_chunk">@@ -1847,8 +1860,10 @@</span> <span class="p_context"> int kvm_arch_prepare_memory_region(struct kvm *kvm,</span>
 			pa += vm_start - vma-&gt;vm_start;
 
 			/* IO region dirty page logging not allowed */
<span class="p_del">-			if (memslot-&gt;flags &amp; KVM_MEM_LOG_DIRTY_PAGES)</span>
<span class="p_del">-				return -EINVAL;</span>
<span class="p_add">+			if (memslot-&gt;flags &amp; KVM_MEM_LOG_DIRTY_PAGES) {</span>
<span class="p_add">+				ret = -EINVAL;</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+			}</span>
 
 			ret = kvm_phys_addr_ioremap(kvm, gpa, pa,
 						    vm_end - vm_start,
<span class="p_chunk">@@ -1860,7 +1875,7 @@</span> <span class="p_context"> int kvm_arch_prepare_memory_region(struct kvm *kvm,</span>
 	} while (hva &lt; reg_end);
 
 	if (change == KVM_MR_FLAGS_ONLY)
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto out;</span>
 
 	spin_lock(&amp;kvm-&gt;mmu_lock);
 	if (ret)
<span class="p_chunk">@@ -1868,6 +1883,8 @@</span> <span class="p_context"> int kvm_arch_prepare_memory_region(struct kvm *kvm,</span>
 	else
 		stage2_flush_memslot(kvm, memslot);
 	spin_unlock(&amp;kvm-&gt;mmu_lock);
<span class="p_add">+out:</span>
<span class="p_add">+	up_read(&amp;current-&gt;mm-&gt;mmap_sem);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/arch/arm/mach-davinci/da8xx-dt.c b/arch/arm/mach-davinci/da8xx-dt.c</span>
<span class="p_header">index c9f7e9274aa8..aed44dcdfd30 100644</span>
<span class="p_header">--- a/arch/arm/mach-davinci/da8xx-dt.c</span>
<span class="p_header">+++ b/arch/arm/mach-davinci/da8xx-dt.c</span>
<span class="p_chunk">@@ -46,6 +46,7 @@</span> <span class="p_context"> static struct of_dev_auxdata da850_auxdata_lookup[] __initdata = {</span>
 static void __init da850_init_machine(void)
 {
 	of_platform_default_populate(NULL, da850_auxdata_lookup, NULL);
<span class="p_add">+	davinci_pm_init();</span>
 }
 
 static const char *const da850_boards_compat[] __initconst = {
<span class="p_header">diff --git a/arch/arm64/boot/dts/hisilicon/hip06.dtsi b/arch/arm64/boot/dts/hisilicon/hip06.dtsi</span>
<span class="p_header">index af450413b9dd..f2eb12c6ed83 100644</span>
<span class="p_header">--- a/arch/arm64/boot/dts/hisilicon/hip06.dtsi</span>
<span class="p_header">+++ b/arch/arm64/boot/dts/hisilicon/hip06.dtsi</span>
<span class="p_chunk">@@ -590,7 +590,7 @@</span> <span class="p_context"></span>
 			reg = &lt;0 0xa2000000 0 0x10000&gt;;
 			sas-addr = [50 01 88 20 16 00 00 00];
 			hisilicon,sas-syscon = &lt;&amp;pcie_subctl&gt;;
<span class="p_del">-			am-max-trans;</span>
<span class="p_add">+			hip06-sas-v2-quirk-amt;</span>
 			ctrl-reset-reg = &lt;0xa18&gt;;
 			ctrl-reset-sts-reg = &lt;0x5a0c&gt;;
 			ctrl-clock-ena-reg = &lt;0x318&gt;;
<span class="p_header">diff --git a/arch/arm64/kernel/arm64ksyms.c b/arch/arm64/kernel/arm64ksyms.c</span>
<span class="p_header">index 78f368039c79..e9c4dc9e0ada 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/arm64ksyms.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/arm64ksyms.c</span>
<span class="p_chunk">@@ -73,5 +73,5 @@</span> <span class="p_context"> NOKPROBE_SYMBOL(_mcount);</span>
 #endif
 
 	/* arm-smccc */
<span class="p_del">-EXPORT_SYMBOL(arm_smccc_smc);</span>
<span class="p_del">-EXPORT_SYMBOL(arm_smccc_hvc);</span>
<span class="p_add">+EXPORT_SYMBOL(__arm_smccc_smc);</span>
<span class="p_add">+EXPORT_SYMBOL(__arm_smccc_hvc);</span>
<span class="p_header">diff --git a/arch/arm64/kernel/asm-offsets.c b/arch/arm64/kernel/asm-offsets.c</span>
<span class="p_header">index 4a2f0f0fef32..c58ddf8c4062 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/asm-offsets.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/asm-offsets.c</span>
<span class="p_chunk">@@ -140,8 +140,11 @@</span> <span class="p_context"> int main(void)</span>
   DEFINE(SLEEP_STACK_DATA_SYSTEM_REGS,	offsetof(struct sleep_stack_data, system_regs));
   DEFINE(SLEEP_STACK_DATA_CALLEE_REGS,	offsetof(struct sleep_stack_data, callee_saved_regs));
 #endif
<span class="p_del">-  DEFINE(ARM_SMCCC_RES_X0_OFFS,	offsetof(struct arm_smccc_res, a0));</span>
<span class="p_del">-  DEFINE(ARM_SMCCC_RES_X2_OFFS,	offsetof(struct arm_smccc_res, a2));</span>
<span class="p_add">+  DEFINE(ARM_SMCCC_RES_X0_OFFS,		offsetof(struct arm_smccc_res, a0));</span>
<span class="p_add">+  DEFINE(ARM_SMCCC_RES_X2_OFFS,		offsetof(struct arm_smccc_res, a2));</span>
<span class="p_add">+  DEFINE(ARM_SMCCC_QUIRK_ID_OFFS,	offsetof(struct arm_smccc_quirk, id));</span>
<span class="p_add">+  DEFINE(ARM_SMCCC_QUIRK_STATE_OFFS,	offsetof(struct arm_smccc_quirk, state));</span>
<span class="p_add">+</span>
   BLANK();
   DEFINE(HIBERN_PBE_ORIG,	offsetof(struct pbe, orig_address));
   DEFINE(HIBERN_PBE_ADDR,	offsetof(struct pbe, address));
<span class="p_header">diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c</span>
<span class="p_header">index acf38722457b..409abc45bdb6 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/pci.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/pci.c</span>
<span class="p_chunk">@@ -121,6 +121,7 @@</span> <span class="p_context"> int pcibios_root_bridge_prepare(struct pci_host_bridge *bridge)</span>
 static struct pci_config_window *
 pci_acpi_setup_ecam_mapping(struct acpi_pci_root *root)
 {
<span class="p_add">+	struct device *dev = &amp;root-&gt;device-&gt;dev;</span>
 	struct resource *bus_res = &amp;root-&gt;secondary;
 	u16 seg = root-&gt;segment;
 	struct pci_config_window *cfg;
<span class="p_chunk">@@ -132,8 +133,7 @@</span> <span class="p_context"> pci_acpi_setup_ecam_mapping(struct acpi_pci_root *root)</span>
 		root-&gt;mcfg_addr = pci_mcfg_lookup(seg, bus_res);
 
 	if (!root-&gt;mcfg_addr) {
<span class="p_del">-		dev_err(&amp;root-&gt;device-&gt;dev, &quot;%04x:%pR ECAM region not found\n&quot;,</span>
<span class="p_del">-			seg, bus_res);</span>
<span class="p_add">+		dev_err(dev, &quot;%04x:%pR ECAM region not found\n&quot;, seg, bus_res);</span>
 		return NULL;
 	}
 
<span class="p_chunk">@@ -141,11 +141,10 @@</span> <span class="p_context"> pci_acpi_setup_ecam_mapping(struct acpi_pci_root *root)</span>
 	cfgres.start = root-&gt;mcfg_addr + bus_res-&gt;start * bsz;
 	cfgres.end = cfgres.start + resource_size(bus_res) * bsz - 1;
 	cfgres.flags = IORESOURCE_MEM;
<span class="p_del">-	cfg = pci_ecam_create(&amp;root-&gt;device-&gt;dev, &amp;cfgres, bus_res,</span>
<span class="p_del">-			      &amp;pci_generic_ecam_ops);</span>
<span class="p_add">+	cfg = pci_ecam_create(dev, &amp;cfgres, bus_res, &amp;pci_generic_ecam_ops);</span>
 	if (IS_ERR(cfg)) {
<span class="p_del">-		dev_err(&amp;root-&gt;device-&gt;dev, &quot;%04x:%pR error %ld mapping ECAM\n&quot;,</span>
<span class="p_del">-			seg, bus_res, PTR_ERR(cfg));</span>
<span class="p_add">+		dev_err(dev, &quot;%04x:%pR error %ld mapping ECAM\n&quot;, seg, bus_res,</span>
<span class="p_add">+			PTR_ERR(cfg));</span>
 		return NULL;
 	}
 
<span class="p_chunk">@@ -159,33 +158,36 @@</span> <span class="p_context"> static void pci_acpi_generic_release_info(struct acpi_pci_root_info *ci)</span>
 
 	ri = container_of(ci, struct acpi_pci_generic_root_info, common);
 	pci_ecam_free(ri-&gt;cfg);
<span class="p_add">+	kfree(ci-&gt;ops);</span>
 	kfree(ri);
 }
 
<span class="p_del">-static struct acpi_pci_root_ops acpi_pci_root_ops = {</span>
<span class="p_del">-	.release_info = pci_acpi_generic_release_info,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 /* Interface called from ACPI code to setup PCI host controller */
 struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 {
 	int node = acpi_get_node(root-&gt;device-&gt;handle);
 	struct acpi_pci_generic_root_info *ri;
 	struct pci_bus *bus, *child;
<span class="p_add">+	struct acpi_pci_root_ops *root_ops;</span>
 
 	ri = kzalloc_node(sizeof(*ri), GFP_KERNEL, node);
 	if (!ri)
 		return NULL;
 
<span class="p_add">+	root_ops = kzalloc_node(sizeof(*root_ops), GFP_KERNEL, node);</span>
<span class="p_add">+	if (!root_ops)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
 	ri-&gt;cfg = pci_acpi_setup_ecam_mapping(root);
 	if (!ri-&gt;cfg) {
 		kfree(ri);
<span class="p_add">+		kfree(root_ops);</span>
 		return NULL;
 	}
 
<span class="p_del">-	acpi_pci_root_ops.pci_ops = &amp;ri-&gt;cfg-&gt;ops-&gt;pci_ops;</span>
<span class="p_del">-	bus = acpi_pci_root_create(root, &amp;acpi_pci_root_ops, &amp;ri-&gt;common,</span>
<span class="p_del">-				   ri-&gt;cfg);</span>
<span class="p_add">+	root_ops-&gt;release_info = pci_acpi_generic_release_info;</span>
<span class="p_add">+	root_ops-&gt;pci_ops = &amp;ri-&gt;cfg-&gt;ops-&gt;pci_ops;</span>
<span class="p_add">+	bus = acpi_pci_root_create(root, root_ops, &amp;ri-&gt;common, ri-&gt;cfg);</span>
 	if (!bus)
 		return NULL;
 
<span class="p_header">diff --git a/arch/arm64/kernel/smccc-call.S b/arch/arm64/kernel/smccc-call.S</span>
<span class="p_header">index ae0496fa4235..62522342e1e4 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/smccc-call.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/smccc-call.S</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"></span>
  *
  */
 #include &lt;linux/linkage.h&gt;
<span class="p_add">+#include &lt;linux/arm-smccc.h&gt;</span>
 #include &lt;asm/asm-offsets.h&gt;
 
 	.macro SMCCC instr
<span class="p_chunk">@@ -20,24 +21,32 @@</span> <span class="p_context"></span>
 	ldr	x4, [sp]
 	stp	x0, x1, [x4, #ARM_SMCCC_RES_X0_OFFS]
 	stp	x2, x3, [x4, #ARM_SMCCC_RES_X2_OFFS]
<span class="p_del">-	ret</span>
<span class="p_add">+	ldr	x4, [sp, #8]</span>
<span class="p_add">+	cbz	x4, 1f /* no quirk structure */</span>
<span class="p_add">+	ldr	x9, [x4, #ARM_SMCCC_QUIRK_ID_OFFS]</span>
<span class="p_add">+	cmp	x9, #ARM_SMCCC_QUIRK_QCOM_A6</span>
<span class="p_add">+	b.ne	1f</span>
<span class="p_add">+	str	x6, [x4, ARM_SMCCC_QUIRK_STATE_OFFS]</span>
<span class="p_add">+1:	ret</span>
 	.cfi_endproc
 	.endm
 
 /*
  * void arm_smccc_smc(unsigned long a0, unsigned long a1, unsigned long a2,
  *		  unsigned long a3, unsigned long a4, unsigned long a5,
<span class="p_del">- *		  unsigned long a6, unsigned long a7, struct arm_smccc_res *res)</span>
<span class="p_add">+ *		  unsigned long a6, unsigned long a7, struct arm_smccc_res *res,</span>
<span class="p_add">+ *		  struct arm_smccc_quirk *quirk)</span>
  */
<span class="p_del">-ENTRY(arm_smccc_smc)</span>
<span class="p_add">+ENTRY(__arm_smccc_smc)</span>
 	SMCCC	smc
<span class="p_del">-ENDPROC(arm_smccc_smc)</span>
<span class="p_add">+ENDPROC(__arm_smccc_smc)</span>
 
 /*
  * void arm_smccc_hvc(unsigned long a0, unsigned long a1, unsigned long a2,
  *		  unsigned long a3, unsigned long a4, unsigned long a5,
<span class="p_del">- *		  unsigned long a6, unsigned long a7, struct arm_smccc_res *res)</span>
<span class="p_add">+ *		  unsigned long a6, unsigned long a7, struct arm_smccc_res *res,</span>
<span class="p_add">+ *		  struct arm_smccc_quirk *quirk)</span>
  */
<span class="p_del">-ENTRY(arm_smccc_hvc)</span>
<span class="p_add">+ENTRY(__arm_smccc_hvc)</span>
 	SMCCC	hvc
<span class="p_del">-ENDPROC(arm_smccc_hvc)</span>
<span class="p_add">+ENDPROC(__arm_smccc_hvc)</span>
<span class="p_header">diff --git a/arch/arm64/mm/fault.c b/arch/arm64/mm/fault.c</span>
<span class="p_header">index 0f8788374815..8b8ac3db4092 100644</span>
<span class="p_header">--- a/arch/arm64/mm/fault.c</span>
<span class="p_header">+++ b/arch/arm64/mm/fault.c</span>
<span class="p_chunk">@@ -41,7 +41,20 @@</span> <span class="p_context"></span>
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/tlbflush.h&gt;
 
<span class="p_del">-static const char *fault_name(unsigned int esr);</span>
<span class="p_add">+struct fault_info {</span>
<span class="p_add">+	int	(*fn)(unsigned long addr, unsigned int esr,</span>
<span class="p_add">+		      struct pt_regs *regs);</span>
<span class="p_add">+	int	sig;</span>
<span class="p_add">+	int	code;</span>
<span class="p_add">+	const char *name;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct fault_info fault_info[];</span>
<span class="p_add">+</span>
<span class="p_add">+static inline const struct fault_info *esr_to_fault_info(unsigned int esr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return fault_info + (esr &amp; 63);</span>
<span class="p_add">+}</span>
 
 #ifdef CONFIG_KPROBES
 static inline int notify_page_fault(struct pt_regs *regs, unsigned int esr)
<span class="p_chunk">@@ -196,10 +209,12 @@</span> <span class="p_context"> static void __do_user_fault(struct task_struct *tsk, unsigned long addr,</span>
 			    struct pt_regs *regs)
 {
 	struct siginfo si;
<span class="p_add">+	const struct fault_info *inf;</span>
 
 	if (unhandled_signal(tsk, sig) &amp;&amp; show_unhandled_signals_ratelimited()) {
<span class="p_add">+		inf = esr_to_fault_info(esr);</span>
 		pr_info(&quot;%s[%d]: unhandled %s (%d) at 0x%08lx, esr 0x%03x\n&quot;,
<span class="p_del">-			tsk-&gt;comm, task_pid_nr(tsk), fault_name(esr), sig,</span>
<span class="p_add">+			tsk-&gt;comm, task_pid_nr(tsk), inf-&gt;name, sig,</span>
 			addr, esr);
 		show_pte(tsk-&gt;mm, addr);
 		show_regs(regs);
<span class="p_chunk">@@ -218,14 +233,16 @@</span> <span class="p_context"> static void do_bad_area(unsigned long addr, unsigned int esr, struct pt_regs *re</span>
 {
 	struct task_struct *tsk = current;
 	struct mm_struct *mm = tsk-&gt;active_mm;
<span class="p_add">+	const struct fault_info *inf;</span>
 
 	/*
 	 * If we are in kernel mode at this point, we have no context to
 	 * handle this fault with.
 	 */
<span class="p_del">-	if (user_mode(regs))</span>
<span class="p_del">-		__do_user_fault(tsk, addr, esr, SIGSEGV, SEGV_MAPERR, regs);</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (user_mode(regs)) {</span>
<span class="p_add">+		inf = esr_to_fault_info(esr);</span>
<span class="p_add">+		__do_user_fault(tsk, addr, esr, inf-&gt;sig, inf-&gt;code, regs);</span>
<span class="p_add">+	} else</span>
 		__do_kernel_fault(mm, addr, esr, regs);
 }
 
<span class="p_chunk">@@ -481,12 +498,7 @@</span> <span class="p_context"> static int do_bad(unsigned long addr, unsigned int esr, struct pt_regs *regs)</span>
 	return 1;
 }
 
<span class="p_del">-static const struct fault_info {</span>
<span class="p_del">-	int	(*fn)(unsigned long addr, unsigned int esr, struct pt_regs *regs);</span>
<span class="p_del">-	int	sig;</span>
<span class="p_del">-	int	code;</span>
<span class="p_del">-	const char *name;</span>
<span class="p_del">-} fault_info[] = {</span>
<span class="p_add">+static const struct fault_info fault_info[] = {</span>
 	{ do_bad,		SIGBUS,  0,		&quot;ttbr address size fault&quot;	},
 	{ do_bad,		SIGBUS,  0,		&quot;level 1 address size fault&quot;	},
 	{ do_bad,		SIGBUS,  0,		&quot;level 2 address size fault&quot;	},
<span class="p_chunk">@@ -553,19 +565,13 @@</span> <span class="p_context"> static const struct fault_info {</span>
 	{ do_bad,		SIGBUS,  0,		&quot;unknown 63&quot;			},
 };
 
<span class="p_del">-static const char *fault_name(unsigned int esr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	const struct fault_info *inf = fault_info + (esr &amp; 63);</span>
<span class="p_del">-	return inf-&gt;name;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * Dispatch a data abort to the relevant handler.
  */
 asmlinkage void __exception do_mem_abort(unsigned long addr, unsigned int esr,
 					 struct pt_regs *regs)
 {
<span class="p_del">-	const struct fault_info *inf = fault_info + (esr &amp; 63);</span>
<span class="p_add">+	const struct fault_info *inf = esr_to_fault_info(esr);</span>
 	struct siginfo info;
 
 	if (!inf-&gt;fn(addr, esr, regs))
<span class="p_header">diff --git a/arch/metag/include/asm/uaccess.h b/arch/metag/include/asm/uaccess.h</span>
<span class="p_header">index 273e61225c27..07238b39638c 100644</span>
<span class="p_header">--- a/arch/metag/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/metag/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -197,20 +197,21 @@</span> <span class="p_context"> extern long __must_check strnlen_user(const char __user *src, long count);</span>
 
 #define strlen_user(str) strnlen_user(str, 32767)
 
<span class="p_del">-extern unsigned long __must_check __copy_user_zeroing(void *to,</span>
<span class="p_del">-						      const void __user *from,</span>
<span class="p_del">-						      unsigned long n);</span>
<span class="p_add">+extern unsigned long raw_copy_from_user(void *to, const void __user *from,</span>
<span class="p_add">+					unsigned long n);</span>
 
 static inline unsigned long
 copy_from_user(void *to, const void __user *from, unsigned long n)
 {
<span class="p_add">+	unsigned long res = n;</span>
 	if (likely(access_ok(VERIFY_READ, from, n)))
<span class="p_del">-		return __copy_user_zeroing(to, from, n);</span>
<span class="p_del">-	memset(to, 0, n);</span>
<span class="p_del">-	return n;</span>
<span class="p_add">+		res = raw_copy_from_user(to, from, n);</span>
<span class="p_add">+	if (unlikely(res))</span>
<span class="p_add">+		memset(to + (n - res), 0, res);</span>
<span class="p_add">+	return res;</span>
 }
 
<span class="p_del">-#define __copy_from_user(to, from, n) __copy_user_zeroing(to, from, n)</span>
<span class="p_add">+#define __copy_from_user(to, from, n) raw_copy_from_user(to, from, n)</span>
 #define __copy_from_user_inatomic __copy_from_user
 
 extern unsigned long __must_check __copy_user(void __user *to,
<span class="p_header">diff --git a/arch/metag/lib/usercopy.c b/arch/metag/lib/usercopy.c</span>
<span class="p_header">index b3ebfe9c8e88..2792fc621088 100644</span>
<span class="p_header">--- a/arch/metag/lib/usercopy.c</span>
<span class="p_header">+++ b/arch/metag/lib/usercopy.c</span>
<span class="p_chunk">@@ -29,7 +29,6 @@</span> <span class="p_context"></span>
 		COPY						 \
 		&quot;1:\n&quot;						 \
 		&quot;	.section .fixup,\&quot;ax\&quot;\n&quot;		 \
<span class="p_del">-		&quot;	MOV D1Ar1,#0\n&quot;				 \</span>
 		FIXUP						 \
 		&quot;	MOVT    D1Ar1,#HI(1b)\n&quot;		 \
 		&quot;	JUMP    D1Ar1,#LO(1b)\n&quot;		 \
<span class="p_chunk">@@ -260,27 +259,31 @@</span> <span class="p_context"></span>
 		&quot;MGETL	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\
 		&quot;22:\n&quot;							\
 		&quot;MSETL	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\
<span class="p_del">-		&quot;SUB	%3, %3, #32\n&quot;					\</span>
 		&quot;23:\n&quot;							\
<span class="p_del">-		&quot;MGETL	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\</span>
<span class="p_add">+		&quot;SUB	%3, %3, #32\n&quot;					\</span>
 		&quot;24:\n&quot;							\
<span class="p_add">+		&quot;MGETL	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\</span>
<span class="p_add">+		&quot;25:\n&quot;							\</span>
 		&quot;MSETL	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\
<span class="p_add">+		&quot;26:\n&quot;							\</span>
 		&quot;SUB	%3, %3, #32\n&quot;					\
 		&quot;DCACHE	[%1+#-64], D0Ar6\n&quot;				\
 		&quot;BR	$Lloop&quot;id&quot;\n&quot;					\
 									\
 		&quot;MOV	RAPF, %1\n&quot;					\
<span class="p_del">-		&quot;25:\n&quot;							\</span>
<span class="p_add">+		&quot;27:\n&quot;							\</span>
 		&quot;MGETL	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\
<span class="p_del">-		&quot;26:\n&quot;							\</span>
<span class="p_add">+		&quot;28:\n&quot;							\</span>
 		&quot;MSETL	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\
<span class="p_add">+		&quot;29:\n&quot;							\</span>
 		&quot;SUB	%3, %3, #32\n&quot;					\
<span class="p_del">-		&quot;27:\n&quot;							\</span>
<span class="p_add">+		&quot;30:\n&quot;							\</span>
 		&quot;MGETL	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\
<span class="p_del">-		&quot;28:\n&quot;							\</span>
<span class="p_add">+		&quot;31:\n&quot;							\</span>
 		&quot;MSETL	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\
<span class="p_add">+		&quot;32:\n&quot;							\</span>
 		&quot;SUB	%0, %0, #8\n&quot;					\
<span class="p_del">-		&quot;29:\n&quot;							\</span>
<span class="p_add">+		&quot;33:\n&quot;							\</span>
 		&quot;SETL	[%0++], D0.7, D1.7\n&quot;				\
 		&quot;SUB	%3, %3, #32\n&quot;					\
 		&quot;1:&quot;							\
<span class="p_chunk">@@ -312,11 +315,15 @@</span> <span class="p_context"></span>
 		&quot;	.long 26b,3b\n&quot;					\
 		&quot;	.long 27b,3b\n&quot;					\
 		&quot;	.long 28b,3b\n&quot;					\
<span class="p_del">-		&quot;	.long 29b,4b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 29b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 30b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 31b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 32b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 33b,4b\n&quot;					\</span>
 		&quot;	.previous\n&quot;					\
 		: &quot;=r&quot; (to), &quot;=r&quot; (from), &quot;=r&quot; (ret), &quot;=d&quot; (n)		\
 		: &quot;0&quot; (to), &quot;1&quot; (from), &quot;2&quot; (ret), &quot;3&quot; (n)		\
<span class="p_del">-		: &quot;D1Ar1&quot;, &quot;D0Ar2&quot;, &quot;memory&quot;)</span>
<span class="p_add">+		: &quot;D1Ar1&quot;, &quot;D0Ar2&quot;, &quot;cc&quot;, &quot;memory&quot;)</span>
 
 /*	rewind &#39;to&#39; and &#39;from&#39;  pointers when a fault occurs
  *
<span class="p_chunk">@@ -342,7 +349,7 @@</span> <span class="p_context"></span>
 #define __asm_copy_to_user_64bit_rapf_loop(to,	from, ret, n, id)\
 	__asm_copy_user_64bit_rapf_loop(to, from, ret, n, id,		\
 		&quot;LSR	D0Ar2, D0Ar2, #8\n&quot;				\
<span class="p_del">-		&quot;AND	D0Ar2, D0Ar2, #0x7\n&quot;				\</span>
<span class="p_add">+		&quot;ANDS	D0Ar2, D0Ar2, #0x7\n&quot;				\</span>
 		&quot;ADDZ	D0Ar2, D0Ar2, #4\n&quot;				\
 		&quot;SUB	D0Ar2, D0Ar2, #1\n&quot;				\
 		&quot;MOV	D1Ar1, #4\n&quot;					\
<span class="p_chunk">@@ -403,47 +410,55 @@</span> <span class="p_context"></span>
 		&quot;MGETD	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\
 		&quot;22:\n&quot;							\
 		&quot;MSETD	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\
<span class="p_del">-		&quot;SUB	%3, %3, #16\n&quot;					\</span>
 		&quot;23:\n&quot;							\
<span class="p_del">-		&quot;MGETD	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;24:\n&quot;							\</span>
<span class="p_del">-		&quot;MSETD	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\</span>
 		&quot;SUB	%3, %3, #16\n&quot;					\
<span class="p_del">-		&quot;25:\n&quot;							\</span>
<span class="p_add">+		&quot;24:\n&quot;							\</span>
 		&quot;MGETD	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\
<span class="p_del">-		&quot;26:\n&quot;							\</span>
<span class="p_add">+		&quot;25:\n&quot;							\</span>
 		&quot;MSETD	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\
<span class="p_add">+		&quot;26:\n&quot;							\</span>
 		&quot;SUB	%3, %3, #16\n&quot;					\
 		&quot;27:\n&quot;							\
 		&quot;MGETD	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\
 		&quot;28:\n&quot;							\
 		&quot;MSETD	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\
<span class="p_add">+		&quot;29:\n&quot;							\</span>
<span class="p_add">+		&quot;SUB	%3, %3, #16\n&quot;					\</span>
<span class="p_add">+		&quot;30:\n&quot;							\</span>
<span class="p_add">+		&quot;MGETD	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\</span>
<span class="p_add">+		&quot;31:\n&quot;							\</span>
<span class="p_add">+		&quot;MSETD	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\</span>
<span class="p_add">+		&quot;32:\n&quot;							\</span>
 		&quot;SUB	%3, %3, #16\n&quot;					\
 		&quot;DCACHE	[%1+#-64], D0Ar6\n&quot;				\
 		&quot;BR	$Lloop&quot;id&quot;\n&quot;					\
 									\
 		&quot;MOV	RAPF, %1\n&quot;					\
<span class="p_del">-		&quot;29:\n&quot;							\</span>
<span class="p_add">+		&quot;33:\n&quot;							\</span>
 		&quot;MGETD	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\
<span class="p_del">-		&quot;30:\n&quot;							\</span>
<span class="p_add">+		&quot;34:\n&quot;							\</span>
 		&quot;MSETD	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\
<span class="p_add">+		&quot;35:\n&quot;							\</span>
 		&quot;SUB	%3, %3, #16\n&quot;					\
<span class="p_del">-		&quot;31:\n&quot;							\</span>
<span class="p_add">+		&quot;36:\n&quot;							\</span>
 		&quot;MGETD	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\
<span class="p_del">-		&quot;32:\n&quot;							\</span>
<span class="p_add">+		&quot;37:\n&quot;							\</span>
 		&quot;MSETD	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\
<span class="p_add">+		&quot;38:\n&quot;							\</span>
 		&quot;SUB	%3, %3, #16\n&quot;					\
<span class="p_del">-		&quot;33:\n&quot;							\</span>
<span class="p_add">+		&quot;39:\n&quot;							\</span>
 		&quot;MGETD	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\
<span class="p_del">-		&quot;34:\n&quot;							\</span>
<span class="p_add">+		&quot;40:\n&quot;							\</span>
 		&quot;MSETD	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\
<span class="p_add">+		&quot;41:\n&quot;							\</span>
 		&quot;SUB	%3, %3, #16\n&quot;					\
<span class="p_del">-		&quot;35:\n&quot;							\</span>
<span class="p_add">+		&quot;42:\n&quot;							\</span>
 		&quot;MGETD	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\
<span class="p_del">-		&quot;36:\n&quot;							\</span>
<span class="p_add">+		&quot;43:\n&quot;							\</span>
 		&quot;MSETD	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\
<span class="p_add">+		&quot;44:\n&quot;							\</span>
 		&quot;SUB	%0, %0, #4\n&quot;					\
<span class="p_del">-		&quot;37:\n&quot;							\</span>
<span class="p_add">+		&quot;45:\n&quot;							\</span>
 		&quot;SETD	[%0++], D0.7\n&quot;					\
 		&quot;SUB	%3, %3, #16\n&quot;					\
 		&quot;1:&quot;							\
<span class="p_chunk">@@ -483,11 +498,19 @@</span> <span class="p_context"></span>
 		&quot;	.long 34b,3b\n&quot;					\
 		&quot;	.long 35b,3b\n&quot;					\
 		&quot;	.long 36b,3b\n&quot;					\
<span class="p_del">-		&quot;	.long 37b,4b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 37b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 38b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 39b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 40b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 41b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 42b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 43b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 44b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 45b,4b\n&quot;					\</span>
 		&quot;	.previous\n&quot;					\
 		: &quot;=r&quot; (to), &quot;=r&quot; (from), &quot;=r&quot; (ret), &quot;=d&quot; (n)		\
 		: &quot;0&quot; (to), &quot;1&quot; (from), &quot;2&quot; (ret), &quot;3&quot; (n)		\
<span class="p_del">-		: &quot;D1Ar1&quot;, &quot;D0Ar2&quot;, &quot;memory&quot;)</span>
<span class="p_add">+		: &quot;D1Ar1&quot;, &quot;D0Ar2&quot;, &quot;cc&quot;, &quot;memory&quot;)</span>
 
 /*	rewind &#39;to&#39; and &#39;from&#39;  pointers when a fault occurs
  *
<span class="p_chunk">@@ -513,7 +536,7 @@</span> <span class="p_context"></span>
 #define __asm_copy_to_user_32bit_rapf_loop(to, from, ret, n, id)\
 	__asm_copy_user_32bit_rapf_loop(to, from, ret, n, id,		\
 		&quot;LSR	D0Ar2, D0Ar2, #8\n&quot;				\
<span class="p_del">-		&quot;AND	D0Ar2, D0Ar2, #0x7\n&quot;				\</span>
<span class="p_add">+		&quot;ANDS	D0Ar2, D0Ar2, #0x7\n&quot;				\</span>
 		&quot;ADDZ	D0Ar2, D0Ar2, #4\n&quot;				\
 		&quot;SUB	D0Ar2, D0Ar2, #1\n&quot;				\
 		&quot;MOV	D1Ar1, #4\n&quot;					\
<span class="p_chunk">@@ -538,23 +561,31 @@</span> <span class="p_context"> unsigned long __copy_user(void __user *pdst, const void *psrc,</span>
 	if ((unsigned long) src &amp; 1) {
 		__asm_copy_to_user_1(dst, src, retn);
 		n--;
<span class="p_add">+		if (retn)</span>
<span class="p_add">+			return retn + n;</span>
 	}
 	if ((unsigned long) dst &amp; 1) {
 		/* Worst case - byte copy */
 		while (n &gt; 0) {
 			__asm_copy_to_user_1(dst, src, retn);
 			n--;
<span class="p_add">+			if (retn)</span>
<span class="p_add">+				return retn + n;</span>
 		}
 	}
 	if (((unsigned long) src &amp; 2) &amp;&amp; n &gt;= 2) {
 		__asm_copy_to_user_2(dst, src, retn);
 		n -= 2;
<span class="p_add">+		if (retn)</span>
<span class="p_add">+			return retn + n;</span>
 	}
 	if ((unsigned long) dst &amp; 2) {
 		/* Second worst case - word copy */
 		while (n &gt;= 2) {
 			__asm_copy_to_user_2(dst, src, retn);
 			n -= 2;
<span class="p_add">+			if (retn)</span>
<span class="p_add">+				return retn + n;</span>
 		}
 	}
 
<span class="p_chunk">@@ -569,6 +600,8 @@</span> <span class="p_context"> unsigned long __copy_user(void __user *pdst, const void *psrc,</span>
 		while (n &gt;= 8) {
 			__asm_copy_to_user_8x64(dst, src, retn);
 			n -= 8;
<span class="p_add">+			if (retn)</span>
<span class="p_add">+				return retn + n;</span>
 		}
 	}
 	if (n &gt;= RAPF_MIN_BUF_SIZE) {
<span class="p_chunk">@@ -581,6 +614,8 @@</span> <span class="p_context"> unsigned long __copy_user(void __user *pdst, const void *psrc,</span>
 		while (n &gt;= 8) {
 			__asm_copy_to_user_8x64(dst, src, retn);
 			n -= 8;
<span class="p_add">+			if (retn)</span>
<span class="p_add">+				return retn + n;</span>
 		}
 	}
 #endif
<span class="p_chunk">@@ -588,11 +623,15 @@</span> <span class="p_context"> unsigned long __copy_user(void __user *pdst, const void *psrc,</span>
 	while (n &gt;= 16) {
 		__asm_copy_to_user_16(dst, src, retn);
 		n -= 16;
<span class="p_add">+		if (retn)</span>
<span class="p_add">+			return retn + n;</span>
 	}
 
 	while (n &gt;= 4) {
 		__asm_copy_to_user_4(dst, src, retn);
 		n -= 4;
<span class="p_add">+		if (retn)</span>
<span class="p_add">+			return retn + n;</span>
 	}
 
 	switch (n) {
<span class="p_chunk">@@ -609,6 +648,10 @@</span> <span class="p_context"> unsigned long __copy_user(void __user *pdst, const void *psrc,</span>
 		break;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we get here, retn correctly reflects the number of failing</span>
<span class="p_add">+	 * bytes.</span>
<span class="p_add">+	 */</span>
 	return retn;
 }
 EXPORT_SYMBOL(__copy_user);
<span class="p_chunk">@@ -617,16 +660,14 @@</span> <span class="p_context"> EXPORT_SYMBOL(__copy_user);</span>
 	__asm_copy_user_cont(to, from, ret,	\
 		&quot;	GETB D1Ar1,[%1++]\n&quot;	\
 		&quot;2:	SETB [%0++],D1Ar1\n&quot;,	\
<span class="p_del">-		&quot;3:	ADD  %2,%2,#1\n&quot;	\</span>
<span class="p_del">-		&quot;	SETB [%0++],D1Ar1\n&quot;,	\</span>
<span class="p_add">+		&quot;3:	ADD  %2,%2,#1\n&quot;,	\</span>
 		&quot;	.long 2b,3b\n&quot;)
 
 #define __asm_copy_from_user_2x_cont(to, from, ret, COPY, FIXUP, TENTRY) \
 	__asm_copy_user_cont(to, from, ret,		\
 		&quot;	GETW D1Ar1,[%1++]\n&quot;		\
 		&quot;2:	SETW [%0++],D1Ar1\n&quot; COPY,	\
<span class="p_del">-		&quot;3:	ADD  %2,%2,#2\n&quot;		\</span>
<span class="p_del">-		&quot;	SETW [%0++],D1Ar1\n&quot; FIXUP,	\</span>
<span class="p_add">+		&quot;3:	ADD  %2,%2,#2\n&quot; FIXUP,		\</span>
 		&quot;	.long 2b,3b\n&quot; TENTRY)
 
 #define __asm_copy_from_user_2(to, from, ret) \
<span class="p_chunk">@@ -636,145 +677,26 @@</span> <span class="p_context"> EXPORT_SYMBOL(__copy_user);</span>
 	__asm_copy_from_user_2x_cont(to, from, ret,	\
 		&quot;	GETB D1Ar1,[%1++]\n&quot;		\
 		&quot;4:	SETB [%0++],D1Ar1\n&quot;,		\
<span class="p_del">-		&quot;5:	ADD  %2,%2,#1\n&quot;		\</span>
<span class="p_del">-		&quot;	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_add">+		&quot;5:	ADD  %2,%2,#1\n&quot;,		\</span>
 		&quot;	.long 4b,5b\n&quot;)
 
 #define __asm_copy_from_user_4x_cont(to, from, ret, COPY, FIXUP, TENTRY) \
 	__asm_copy_user_cont(to, from, ret,		\
 		&quot;	GETD D1Ar1,[%1++]\n&quot;		\
 		&quot;2:	SETD [%0++],D1Ar1\n&quot; COPY,	\
<span class="p_del">-		&quot;3:	ADD  %2,%2,#4\n&quot;		\</span>
<span class="p_del">-		&quot;	SETD [%0++],D1Ar1\n&quot; FIXUP,	\</span>
<span class="p_add">+		&quot;3:	ADD  %2,%2,#4\n&quot; FIXUP,		\</span>
 		&quot;	.long 2b,3b\n&quot; TENTRY)
 
 #define __asm_copy_from_user_4(to, from, ret) \
 	__asm_copy_from_user_4x_cont(to, from, ret, &quot;&quot;, &quot;&quot;, &quot;&quot;)
 
<span class="p_del">-#define __asm_copy_from_user_5(to, from, ret) \</span>
<span class="p_del">-	__asm_copy_from_user_4x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETB D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;4:	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;5:	ADD  %2,%2,#1\n&quot;		\</span>
<span class="p_del">-		&quot;	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;	.long 4b,5b\n&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_6x_cont(to, from, ret, COPY, FIXUP, TENTRY) \</span>
<span class="p_del">-	__asm_copy_from_user_4x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETW D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;4:	SETW [%0++],D1Ar1\n&quot; COPY,	\</span>
<span class="p_del">-		&quot;5:	ADD  %2,%2,#2\n&quot;		\</span>
<span class="p_del">-		&quot;	SETW [%0++],D1Ar1\n&quot; FIXUP,	\</span>
<span class="p_del">-		&quot;	.long 4b,5b\n&quot; TENTRY)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_6(to, from, ret) \</span>
<span class="p_del">-	__asm_copy_from_user_6x_cont(to, from, ret, &quot;&quot;, &quot;&quot;, &quot;&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_7(to, from, ret) \</span>
<span class="p_del">-	__asm_copy_from_user_6x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETB D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;6:	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;7:	ADD  %2,%2,#1\n&quot;		\</span>
<span class="p_del">-		&quot;	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;	.long 6b,7b\n&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_8x_cont(to, from, ret, COPY, FIXUP, TENTRY) \</span>
<span class="p_del">-	__asm_copy_from_user_4x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETD D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;4:	SETD [%0++],D1Ar1\n&quot; COPY,	\</span>
<span class="p_del">-		&quot;5:	ADD  %2,%2,#4\n&quot;			\</span>
<span class="p_del">-		&quot;	SETD [%0++],D1Ar1\n&quot; FIXUP,		\</span>
<span class="p_del">-		&quot;	.long 4b,5b\n&quot; TENTRY)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_8(to, from, ret) \</span>
<span class="p_del">-	__asm_copy_from_user_8x_cont(to, from, ret, &quot;&quot;, &quot;&quot;, &quot;&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_9(to, from, ret) \</span>
<span class="p_del">-	__asm_copy_from_user_8x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETB D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;6:	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;7:	ADD  %2,%2,#1\n&quot;		\</span>
<span class="p_del">-		&quot;	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;	.long 6b,7b\n&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_10x_cont(to, from, ret, COPY, FIXUP, TENTRY) \</span>
<span class="p_del">-	__asm_copy_from_user_8x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETW D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;6:	SETW [%0++],D1Ar1\n&quot; COPY,	\</span>
<span class="p_del">-		&quot;7:	ADD  %2,%2,#2\n&quot;		\</span>
<span class="p_del">-		&quot;	SETW [%0++],D1Ar1\n&quot; FIXUP,	\</span>
<span class="p_del">-		&quot;	.long 6b,7b\n&quot; TENTRY)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_10(to, from, ret) \</span>
<span class="p_del">-	__asm_copy_from_user_10x_cont(to, from, ret, &quot;&quot;, &quot;&quot;, &quot;&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_11(to, from, ret)		\</span>
<span class="p_del">-	__asm_copy_from_user_10x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETB D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;8:	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;9:	ADD  %2,%2,#1\n&quot;		\</span>
<span class="p_del">-		&quot;	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;	.long 8b,9b\n&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_12x_cont(to, from, ret, COPY, FIXUP, TENTRY) \</span>
<span class="p_del">-	__asm_copy_from_user_8x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETD D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;6:	SETD [%0++],D1Ar1\n&quot; COPY,	\</span>
<span class="p_del">-		&quot;7:	ADD  %2,%2,#4\n&quot;		\</span>
<span class="p_del">-		&quot;	SETD [%0++],D1Ar1\n&quot; FIXUP,	\</span>
<span class="p_del">-		&quot;	.long 6b,7b\n&quot; TENTRY)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_12(to, from, ret) \</span>
<span class="p_del">-	__asm_copy_from_user_12x_cont(to, from, ret, &quot;&quot;, &quot;&quot;, &quot;&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_13(to, from, ret) \</span>
<span class="p_del">-	__asm_copy_from_user_12x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETB D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;8:	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;9:	ADD  %2,%2,#1\n&quot;		\</span>
<span class="p_del">-		&quot;	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;	.long 8b,9b\n&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_14x_cont(to, from, ret, COPY, FIXUP, TENTRY) \</span>
<span class="p_del">-	__asm_copy_from_user_12x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETW D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;8:	SETW [%0++],D1Ar1\n&quot; COPY,	\</span>
<span class="p_del">-		&quot;9:	ADD  %2,%2,#2\n&quot;		\</span>
<span class="p_del">-		&quot;	SETW [%0++],D1Ar1\n&quot; FIXUP,	\</span>
<span class="p_del">-		&quot;	.long 8b,9b\n&quot; TENTRY)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_14(to, from, ret) \</span>
<span class="p_del">-	__asm_copy_from_user_14x_cont(to, from, ret, &quot;&quot;, &quot;&quot;, &quot;&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_15(to, from, ret) \</span>
<span class="p_del">-	__asm_copy_from_user_14x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETB D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;10:	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;11:	ADD  %2,%2,#1\n&quot;		\</span>
<span class="p_del">-		&quot;	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;	.long 10b,11b\n&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_16x_cont(to, from, ret, COPY, FIXUP, TENTRY) \</span>
<span class="p_del">-	__asm_copy_from_user_12x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETD D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;8:	SETD [%0++],D1Ar1\n&quot; COPY,	\</span>
<span class="p_del">-		&quot;9:	ADD  %2,%2,#4\n&quot;		\</span>
<span class="p_del">-		&quot;	SETD [%0++],D1Ar1\n&quot; FIXUP,	\</span>
<span class="p_del">-		&quot;	.long 8b,9b\n&quot; TENTRY)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_16(to, from, ret) \</span>
<span class="p_del">-	__asm_copy_from_user_16x_cont(to, from, ret, &quot;&quot;, &quot;&quot;, &quot;&quot;)</span>
<span class="p_del">-</span>
 #define __asm_copy_from_user_8x64(to, from, ret) \
 	asm volatile (				\
 		&quot;	GETL D0Ar2,D1Ar1,[%1++]\n&quot;	\
 		&quot;2:	SETL [%0++],D0Ar2,D1Ar1\n&quot;	\
 		&quot;1:\n&quot;					\
 		&quot;	.section .fixup,\&quot;ax\&quot;\n&quot;	\
<span class="p_del">-		&quot;	MOV D1Ar1,#0\n&quot;			\</span>
<span class="p_del">-		&quot;	MOV D0Ar2,#0\n&quot;			\</span>
 		&quot;3:	ADD  %2,%2,#8\n&quot;		\
<span class="p_del">-		&quot;	SETL [%0++],D0Ar2,D1Ar1\n&quot;	\</span>
 		&quot;	MOVT    D0Ar2,#HI(1b)\n&quot;	\
 		&quot;	JUMP    D0Ar2,#LO(1b)\n&quot;	\
 		&quot;	.previous\n&quot;			\
<span class="p_chunk">@@ -789,36 +711,57 @@</span> <span class="p_context"> EXPORT_SYMBOL(__copy_user);</span>
  *
  *	Rationale:
  *		A fault occurs while reading from user buffer, which is the
<span class="p_del">- *		source. Since the fault is at a single address, we only</span>
<span class="p_del">- *		need to rewind by 8 bytes.</span>
<span class="p_add">+ *		source.</span>
  *		Since we don&#39;t write to kernel buffer until we read first,
  *		the kernel buffer is at the right state and needn&#39;t be
<span class="p_del">- *		corrected.</span>
<span class="p_add">+ *		corrected, but the source must be rewound to the beginning of</span>
<span class="p_add">+ *		the block, which is LSM_STEP*8 bytes.</span>
<span class="p_add">+ *		LSM_STEP is bits 10:8 in TXSTATUS which is already read</span>
<span class="p_add">+ *		and stored in D0Ar2</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *		NOTE: If a fault occurs at the last operation in M{G,S}ETL</span>
<span class="p_add">+ *			LSM_STEP will be 0. ie: we do 4 writes in our case, if</span>
<span class="p_add">+ *			a fault happens at the 4th write, LSM_STEP will be 0</span>
<span class="p_add">+ *			instead of 4. The code copes with that.</span>
  */
 #define __asm_copy_from_user_64bit_rapf_loop(to, from, ret, n, id)	\
 	__asm_copy_user_64bit_rapf_loop(to, from, ret, n, id,		\
<span class="p_del">-		&quot;SUB	%1, %1, #8\n&quot;)</span>
<span class="p_add">+		&quot;LSR	D0Ar2, D0Ar2, #5\n&quot;				\</span>
<span class="p_add">+		&quot;ANDS	D0Ar2, D0Ar2, #0x38\n&quot;				\</span>
<span class="p_add">+		&quot;ADDZ	D0Ar2, D0Ar2, #32\n&quot;				\</span>
<span class="p_add">+		&quot;SUB	%1, %1, D0Ar2\n&quot;)</span>
 
 /*	rewind &#39;from&#39; pointer when a fault occurs
  *
  *	Rationale:
  *		A fault occurs while reading from user buffer, which is the
<span class="p_del">- *		source. Since the fault is at a single address, we only</span>
<span class="p_del">- *		need to rewind by 4 bytes.</span>
<span class="p_add">+ *		source.</span>
  *		Since we don&#39;t write to kernel buffer until we read first,
  *		the kernel buffer is at the right state and needn&#39;t be
<span class="p_del">- *		corrected.</span>
<span class="p_add">+ *		corrected, but the source must be rewound to the beginning of</span>
<span class="p_add">+ *		the block, which is LSM_STEP*4 bytes.</span>
<span class="p_add">+ *		LSM_STEP is bits 10:8 in TXSTATUS which is already read</span>
<span class="p_add">+ *		and stored in D0Ar2</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *		NOTE: If a fault occurs at the last operation in M{G,S}ETL</span>
<span class="p_add">+ *			LSM_STEP will be 0. ie: we do 4 writes in our case, if</span>
<span class="p_add">+ *			a fault happens at the 4th write, LSM_STEP will be 0</span>
<span class="p_add">+ *			instead of 4. The code copes with that.</span>
  */
 #define __asm_copy_from_user_32bit_rapf_loop(to, from, ret, n, id)	\
 	__asm_copy_user_32bit_rapf_loop(to, from, ret, n, id,		\
<span class="p_del">-		&quot;SUB	%1, %1, #4\n&quot;)</span>
<span class="p_add">+		&quot;LSR	D0Ar2, D0Ar2, #6\n&quot;				\</span>
<span class="p_add">+		&quot;ANDS	D0Ar2, D0Ar2, #0x1c\n&quot;				\</span>
<span class="p_add">+		&quot;ADDZ	D0Ar2, D0Ar2, #16\n&quot;				\</span>
<span class="p_add">+		&quot;SUB	%1, %1, D0Ar2\n&quot;)</span>
 
 
<span class="p_del">-/* Copy from user to kernel, zeroing the bytes that were inaccessible in</span>
<span class="p_del">-   userland.  The return-value is the number of bytes that were</span>
<span class="p_del">-   inaccessible.  */</span>
<span class="p_del">-unsigned long __copy_user_zeroing(void *pdst, const void __user *psrc,</span>
<span class="p_del">-				  unsigned long n)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copy from user to kernel. The return-value is the number of bytes that were</span>
<span class="p_add">+ * inaccessible.</span>
<span class="p_add">+ */</span>
<span class="p_add">+unsigned long raw_copy_from_user(void *pdst, const void __user *psrc,</span>
<span class="p_add">+				 unsigned long n)</span>
 {
 	register char *dst asm (&quot;A0.2&quot;) = pdst;
 	register const char __user *src asm (&quot;A1.2&quot;) = psrc;
<span class="p_chunk">@@ -830,6 +773,8 @@</span> <span class="p_context"> unsigned long __copy_user_zeroing(void *pdst, const void __user *psrc,</span>
 	if ((unsigned long) src &amp; 1) {
 		__asm_copy_from_user_1(dst, src, retn);
 		n--;
<span class="p_add">+		if (retn)</span>
<span class="p_add">+			return retn + n;</span>
 	}
 	if ((unsigned long) dst &amp; 1) {
 		/* Worst case - byte copy */
<span class="p_chunk">@@ -837,12 +782,14 @@</span> <span class="p_context"> unsigned long __copy_user_zeroing(void *pdst, const void __user *psrc,</span>
 			__asm_copy_from_user_1(dst, src, retn);
 			n--;
 			if (retn)
<span class="p_del">-				goto copy_exception_bytes;</span>
<span class="p_add">+				return retn + n;</span>
 		}
 	}
 	if (((unsigned long) src &amp; 2) &amp;&amp; n &gt;= 2) {
 		__asm_copy_from_user_2(dst, src, retn);
 		n -= 2;
<span class="p_add">+		if (retn)</span>
<span class="p_add">+			return retn + n;</span>
 	}
 	if ((unsigned long) dst &amp; 2) {
 		/* Second worst case - word copy */
<span class="p_chunk">@@ -850,16 +797,10 @@</span> <span class="p_context"> unsigned long __copy_user_zeroing(void *pdst, const void __user *psrc,</span>
 			__asm_copy_from_user_2(dst, src, retn);
 			n -= 2;
 			if (retn)
<span class="p_del">-				goto copy_exception_bytes;</span>
<span class="p_add">+				return retn + n;</span>
 		}
 	}
 
<span class="p_del">-	/* We only need one check after the unalignment-adjustments,</span>
<span class="p_del">-	   because if both adjustments were done, either both or</span>
<span class="p_del">-	   neither reference had an exception.  */</span>
<span class="p_del">-	if (retn != 0)</span>
<span class="p_del">-		goto copy_exception_bytes;</span>
<span class="p_del">-</span>
 #ifdef USE_RAPF
 	/* 64 bit copy loop */
 	if (!(((unsigned long) src | (unsigned long) dst) &amp; 7)) {
<span class="p_chunk">@@ -872,7 +813,7 @@</span> <span class="p_context"> unsigned long __copy_user_zeroing(void *pdst, const void __user *psrc,</span>
 			__asm_copy_from_user_8x64(dst, src, retn);
 			n -= 8;
 			if (retn)
<span class="p_del">-				goto copy_exception_bytes;</span>
<span class="p_add">+				return retn + n;</span>
 		}
 	}
 
<span class="p_chunk">@@ -888,7 +829,7 @@</span> <span class="p_context"> unsigned long __copy_user_zeroing(void *pdst, const void __user *psrc,</span>
 			__asm_copy_from_user_8x64(dst, src, retn);
 			n -= 8;
 			if (retn)
<span class="p_del">-				goto copy_exception_bytes;</span>
<span class="p_add">+				return retn + n;</span>
 		}
 	}
 #endif
<span class="p_chunk">@@ -898,7 +839,7 @@</span> <span class="p_context"> unsigned long __copy_user_zeroing(void *pdst, const void __user *psrc,</span>
 		n -= 4;
 
 		if (retn)
<span class="p_del">-			goto copy_exception_bytes;</span>
<span class="p_add">+			return retn + n;</span>
 	}
 
 	/* If we get here, there were no memory read faults.  */
<span class="p_chunk">@@ -924,21 +865,8 @@</span> <span class="p_context"> unsigned long __copy_user_zeroing(void *pdst, const void __user *psrc,</span>
 	/* If we get here, retn correctly reflects the number of failing
 	   bytes.  */
 	return retn;
<span class="p_del">-</span>
<span class="p_del">- copy_exception_bytes:</span>
<span class="p_del">-	/* We already have &quot;retn&quot; bytes cleared, and need to clear the</span>
<span class="p_del">-	   remaining &quot;n&quot; bytes.  A non-optimized simple byte-for-byte in-line</span>
<span class="p_del">-	   memset is preferred here, since this isn&#39;t speed-critical code and</span>
<span class="p_del">-	   we&#39;d rather have this a leaf-function than calling memset.  */</span>
<span class="p_del">-	{</span>
<span class="p_del">-		char *endp;</span>
<span class="p_del">-		for (endp = dst + n; dst &lt; endp; dst++)</span>
<span class="p_del">-			*dst = 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return retn + n;</span>
 }
<span class="p_del">-EXPORT_SYMBOL(__copy_user_zeroing);</span>
<span class="p_add">+EXPORT_SYMBOL(raw_copy_from_user);</span>
 
 #define __asm_clear_8x64(to, ret) \
 	asm volatile (					\
<span class="p_header">diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig</span>
<span class="p_header">index b3c5bde43d34..9a6e11b6f457 100644</span>
<span class="p_header">--- a/arch/mips/Kconfig</span>
<span class="p_header">+++ b/arch/mips/Kconfig</span>
<span class="p_chunk">@@ -1526,7 +1526,7 @@</span> <span class="p_context"> config CPU_MIPS64_R6</span>
 	select CPU_SUPPORTS_HIGHMEM
 	select CPU_SUPPORTS_MSA
 	select GENERIC_CSUM
<span class="p_del">-	select MIPS_O32_FP64_SUPPORT if MIPS32_O32</span>
<span class="p_add">+	select MIPS_O32_FP64_SUPPORT if 32BIT || MIPS32_O32</span>
 	select HAVE_KVM
 	help
 	  Choose this option to build a kernel for release 6 or later of the
<span class="p_header">diff --git a/arch/mips/include/asm/spinlock.h b/arch/mips/include/asm/spinlock.h</span>
<span class="p_header">index f485afe51514..a8df44d60607 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/spinlock.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/spinlock.h</span>
<span class="p_chunk">@@ -127,7 +127,7 @@</span> <span class="p_context"> static inline void arch_spin_lock(arch_spinlock_t *lock)</span>
 		&quot;	andi	%[ticket], %[ticket], 0xffff		\n&quot;
 		&quot;	bne	%[ticket], %[my_ticket], 4f		\n&quot;
 		&quot;	 subu	%[ticket], %[my_ticket], %[ticket]	\n&quot;
<span class="p_del">-		&quot;2:							\n&quot;</span>
<span class="p_add">+		&quot;2:	.insn						\n&quot;</span>
 		&quot;	.subsection 2					\n&quot;
 		&quot;4:	andi	%[ticket], %[ticket], 0xffff		\n&quot;
 		&quot;	sll	%[ticket], 5				\n&quot;
<span class="p_chunk">@@ -202,7 +202,7 @@</span> <span class="p_context"> static inline unsigned int arch_spin_trylock(arch_spinlock_t *lock)</span>
 		&quot;	sc	%[ticket], %[ticket_ptr]		\n&quot;
 		&quot;	beqz	%[ticket], 1b				\n&quot;
 		&quot;	 li	%[ticket], 1				\n&quot;
<span class="p_del">-		&quot;2:							\n&quot;</span>
<span class="p_add">+		&quot;2:	.insn						\n&quot;</span>
 		&quot;	.subsection 2					\n&quot;
 		&quot;3:	b	2b					\n&quot;
 		&quot;	 li	%[ticket], 0				\n&quot;
<span class="p_chunk">@@ -382,7 +382,7 @@</span> <span class="p_context"> static inline int arch_read_trylock(arch_rwlock_t *rw)</span>
 		&quot;	.set	reorder					\n&quot;
 		__WEAK_LLSC_MB
 		&quot;	li	%2, 1					\n&quot;
<span class="p_del">-		&quot;2:							\n&quot;</span>
<span class="p_add">+		&quot;2:	.insn						\n&quot;</span>
 		: &quot;=&quot; GCC_OFF_SMALL_ASM() (rw-&gt;lock), &quot;=&amp;r&quot; (tmp), &quot;=&amp;r&quot; (ret)
 		: GCC_OFF_SMALL_ASM() (rw-&gt;lock)
 		: &quot;memory&quot;);
<span class="p_chunk">@@ -422,7 +422,7 @@</span> <span class="p_context"> static inline int arch_write_trylock(arch_rwlock_t *rw)</span>
 			&quot;	lui	%1, 0x8000			\n&quot;
 			&quot;	sc	%1, %0				\n&quot;
 			&quot;	li	%2, 1				\n&quot;
<span class="p_del">-			&quot;2:						\n&quot;</span>
<span class="p_add">+			&quot;2:	.insn					\n&quot;</span>
 			: &quot;=&quot; GCC_OFF_SMALL_ASM() (rw-&gt;lock), &quot;=&amp;r&quot; (tmp),
 			  &quot;=&amp;r&quot; (ret)
 			: GCC_OFF_SMALL_ASM() (rw-&gt;lock)
<span class="p_header">diff --git a/arch/mips/kernel/cpu-probe.c b/arch/mips/kernel/cpu-probe.c</span>
<span class="p_header">index dd3175442c9e..921211bcd2ba 100644</span>
<span class="p_header">--- a/arch/mips/kernel/cpu-probe.c</span>
<span class="p_header">+++ b/arch/mips/kernel/cpu-probe.c</span>
<span class="p_chunk">@@ -1824,7 +1824,7 @@</span> <span class="p_context"> static inline void cpu_probe_loongson(struct cpuinfo_mips *c, unsigned int cpu)</span>
 		}
 
 		decode_configs(c);
<span class="p_del">-		c-&gt;options |= MIPS_CPU_TLBINV | MIPS_CPU_LDPTE;</span>
<span class="p_add">+		c-&gt;options |= MIPS_CPU_FTLB | MIPS_CPU_TLBINV | MIPS_CPU_LDPTE;</span>
 		c-&gt;writecombine = _CACHE_UNCACHED_ACCELERATED;
 		break;
 	default:
<span class="p_header">diff --git a/arch/mips/kernel/genex.S b/arch/mips/kernel/genex.S</span>
<span class="p_header">index dc0b29612891..52a4fdfc8513 100644</span>
<span class="p_header">--- a/arch/mips/kernel/genex.S</span>
<span class="p_header">+++ b/arch/mips/kernel/genex.S</span>
<span class="p_chunk">@@ -448,7 +448,7 @@</span> <span class="p_context"> NESTED(nmi_handler, PT_SIZE, sp)</span>
 	BUILD_HANDLER reserved reserved sti verbose	/* others */
 
 	.align	5
<span class="p_del">-	LEAF(handle_ri_rdhwr_vivt)</span>
<span class="p_add">+	LEAF(handle_ri_rdhwr_tlbp)</span>
 	.set	push
 	.set	noat
 	.set	noreorder
<span class="p_chunk">@@ -467,7 +467,7 @@</span> <span class="p_context"> NESTED(nmi_handler, PT_SIZE, sp)</span>
 	.set	pop
 	bltz	k1, handle_ri	/* slow path */
 	/* fall thru */
<span class="p_del">-	END(handle_ri_rdhwr_vivt)</span>
<span class="p_add">+	END(handle_ri_rdhwr_tlbp)</span>
 
 	LEAF(handle_ri_rdhwr)
 	.set	push
<span class="p_header">diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c</span>
<span class="p_header">index 3905003dfe2b..ec87ef93267b 100644</span>
<span class="p_header">--- a/arch/mips/kernel/traps.c</span>
<span class="p_header">+++ b/arch/mips/kernel/traps.c</span>
<span class="p_chunk">@@ -81,7 +81,7 @@</span> <span class="p_context"> extern asmlinkage void handle_dbe(void);</span>
 extern asmlinkage void handle_sys(void);
 extern asmlinkage void handle_bp(void);
 extern asmlinkage void handle_ri(void);
<span class="p_del">-extern asmlinkage void handle_ri_rdhwr_vivt(void);</span>
<span class="p_add">+extern asmlinkage void handle_ri_rdhwr_tlbp(void);</span>
 extern asmlinkage void handle_ri_rdhwr(void);
 extern asmlinkage void handle_cpu(void);
 extern asmlinkage void handle_ov(void);
<span class="p_chunk">@@ -2352,9 +2352,18 @@</span> <span class="p_context"> void __init trap_init(void)</span>
 
 	set_except_vector(EXCCODE_SYS, handle_sys);
 	set_except_vector(EXCCODE_BP, handle_bp);
<span class="p_del">-	set_except_vector(EXCCODE_RI, rdhwr_noopt ? handle_ri :</span>
<span class="p_del">-			  (cpu_has_vtag_icache ?</span>
<span class="p_del">-			   handle_ri_rdhwr_vivt : handle_ri_rdhwr));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rdhwr_noopt)</span>
<span class="p_add">+		set_except_vector(EXCCODE_RI, handle_ri);</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		if (cpu_has_vtag_icache)</span>
<span class="p_add">+			set_except_vector(EXCCODE_RI, handle_ri_rdhwr_tlbp);</span>
<span class="p_add">+		else if (current_cpu_type() == CPU_LOONGSON3)</span>
<span class="p_add">+			set_except_vector(EXCCODE_RI, handle_ri_rdhwr_tlbp);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			set_except_vector(EXCCODE_RI, handle_ri_rdhwr);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	set_except_vector(EXCCODE_CPU, handle_cpu);
 	set_except_vector(EXCCODE_OV, handle_ov);
 	set_except_vector(EXCCODE_TR, handle_tr);
<span class="p_header">diff --git a/arch/mips/lantiq/xway/sysctrl.c b/arch/mips/lantiq/xway/sysctrl.c</span>
<span class="p_header">index 9a61671c00a7..90565477dfbd 100644</span>
<span class="p_header">--- a/arch/mips/lantiq/xway/sysctrl.c</span>
<span class="p_header">+++ b/arch/mips/lantiq/xway/sysctrl.c</span>
<span class="p_chunk">@@ -467,7 +467,7 @@</span> <span class="p_context"> void __init ltq_soc_init(void)</span>
 
 		if (!np_xbar)
 			panic(&quot;Failed to load xbar nodes from devicetree&quot;);
<span class="p_del">-		if (of_address_to_resource(np_pmu, 0, &amp;res_xbar))</span>
<span class="p_add">+		if (of_address_to_resource(np_xbar, 0, &amp;res_xbar))</span>
 			panic(&quot;Failed to get xbar resources&quot;);
 		if (request_mem_region(res_xbar.start, resource_size(&amp;res_xbar),
 			res_xbar.name) &lt; 0)
<span class="p_header">diff --git a/arch/mips/mm/c-r4k.c b/arch/mips/mm/c-r4k.c</span>
<span class="p_header">index 88cfaf81c958..9d0107fbb169 100644</span>
<span class="p_header">--- a/arch/mips/mm/c-r4k.c</span>
<span class="p_header">+++ b/arch/mips/mm/c-r4k.c</span>
<span class="p_chunk">@@ -1558,6 +1558,7 @@</span> <span class="p_context"> static void probe_vcache(void)</span>
 	vcache_size = c-&gt;vcache.sets * c-&gt;vcache.ways * c-&gt;vcache.linesz;
 
 	c-&gt;vcache.waybit = 0;
<span class="p_add">+	c-&gt;vcache.waysize = vcache_size / c-&gt;vcache.ways;</span>
 
 	pr_info(&quot;Unified victim cache %ldkB %s, linesize %d bytes.\n&quot;,
 		vcache_size &gt;&gt; 10, way_string[c-&gt;vcache.ways], c-&gt;vcache.linesz);
<span class="p_chunk">@@ -1660,6 +1661,7 @@</span> <span class="p_context"> static void __init loongson3_sc_init(void)</span>
 	/* Loongson-3 has 4 cores, 1MB scache for each. scaches are shared */
 	scache_size *= 4;
 	c-&gt;scache.waybit = 0;
<span class="p_add">+	c-&gt;scache.waysize = scache_size / c-&gt;scache.ways;</span>
 	pr_info(&quot;Unified secondary cache %ldkB %s, linesize %d bytes.\n&quot;,
 	       scache_size &gt;&gt; 10, way_string[c-&gt;scache.ways], c-&gt;scache.linesz);
 	if (scache_size)
<span class="p_header">diff --git a/arch/mips/mm/tlbex.c b/arch/mips/mm/tlbex.c</span>
<span class="p_header">index 55ce39606cb8..2da5649fc545 100644</span>
<span class="p_header">--- a/arch/mips/mm/tlbex.c</span>
<span class="p_header">+++ b/arch/mips/mm/tlbex.c</span>
<span class="p_chunk">@@ -762,7 +762,8 @@</span> <span class="p_context"> static void build_huge_update_entries(u32 **p, unsigned int pte,</span>
 static void build_huge_handler_tail(u32 **p, struct uasm_reloc **r,
 				    struct uasm_label **l,
 				    unsigned int pte,
<span class="p_del">-				    unsigned int ptr)</span>
<span class="p_add">+				    unsigned int ptr,</span>
<span class="p_add">+				    unsigned int flush)</span>
 {
 #ifdef CONFIG_SMP
 	UASM_i_SC(p, pte, 0, ptr);
<span class="p_chunk">@@ -771,6 +772,22 @@</span> <span class="p_context"> static void build_huge_handler_tail(u32 **p, struct uasm_reloc **r,</span>
 #else
 	UASM_i_SW(p, pte, 0, ptr);
 #endif
<span class="p_add">+	if (cpu_has_ftlb &amp;&amp; flush) {</span>
<span class="p_add">+		BUG_ON(!cpu_has_tlbinv);</span>
<span class="p_add">+</span>
<span class="p_add">+		UASM_i_MFC0(p, ptr, C0_ENTRYHI);</span>
<span class="p_add">+		uasm_i_ori(p, ptr, ptr, MIPS_ENTRYHI_EHINV);</span>
<span class="p_add">+		UASM_i_MTC0(p, ptr, C0_ENTRYHI);</span>
<span class="p_add">+		build_tlb_write_entry(p, l, r, tlb_indexed);</span>
<span class="p_add">+</span>
<span class="p_add">+		uasm_i_xori(p, ptr, ptr, MIPS_ENTRYHI_EHINV);</span>
<span class="p_add">+		UASM_i_MTC0(p, ptr, C0_ENTRYHI);</span>
<span class="p_add">+		build_huge_update_entries(p, pte, ptr);</span>
<span class="p_add">+		build_huge_tlb_write_entry(p, l, r, pte, tlb_random, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	build_huge_update_entries(p, pte, ptr);
 	build_huge_tlb_write_entry(p, l, r, pte, tlb_indexed, 0);
 }
<span class="p_chunk">@@ -2197,7 +2214,7 @@</span> <span class="p_context"> static void build_r4000_tlb_load_handler(void)</span>
 		uasm_l_tlbl_goaround2(&amp;l, p);
 	}
 	uasm_i_ori(&amp;p, wr.r1, wr.r1, (_PAGE_ACCESSED | _PAGE_VALID));
<span class="p_del">-	build_huge_handler_tail(&amp;p, &amp;r, &amp;l, wr.r1, wr.r2);</span>
<span class="p_add">+	build_huge_handler_tail(&amp;p, &amp;r, &amp;l, wr.r1, wr.r2, 1);</span>
 #endif
 
 	uasm_l_nopage_tlbl(&amp;l, p);
<span class="p_chunk">@@ -2252,7 +2269,7 @@</span> <span class="p_context"> static void build_r4000_tlb_store_handler(void)</span>
 	build_tlb_probe_entry(&amp;p);
 	uasm_i_ori(&amp;p, wr.r1, wr.r1,
 		   _PAGE_ACCESSED | _PAGE_MODIFIED | _PAGE_VALID | _PAGE_DIRTY);
<span class="p_del">-	build_huge_handler_tail(&amp;p, &amp;r, &amp;l, wr.r1, wr.r2);</span>
<span class="p_add">+	build_huge_handler_tail(&amp;p, &amp;r, &amp;l, wr.r1, wr.r2, 1);</span>
 #endif
 
 	uasm_l_nopage_tlbs(&amp;l, p);
<span class="p_chunk">@@ -2308,7 +2325,7 @@</span> <span class="p_context"> static void build_r4000_tlb_modify_handler(void)</span>
 	build_tlb_probe_entry(&amp;p);
 	uasm_i_ori(&amp;p, wr.r1, wr.r1,
 		   _PAGE_ACCESSED | _PAGE_MODIFIED | _PAGE_VALID | _PAGE_DIRTY);
<span class="p_del">-	build_huge_handler_tail(&amp;p, &amp;r, &amp;l, wr.r1, wr.r2);</span>
<span class="p_add">+	build_huge_handler_tail(&amp;p, &amp;r, &amp;l, wr.r1, wr.r2, 0);</span>
 #endif
 
 	uasm_l_nopage_tlbm(&amp;l, p);
<span class="p_header">diff --git a/arch/mips/ralink/rt3883.c b/arch/mips/ralink/rt3883.c</span>
<span class="p_header">index 3e0aa09c6b55..9e4631acfcb5 100644</span>
<span class="p_header">--- a/arch/mips/ralink/rt3883.c</span>
<span class="p_header">+++ b/arch/mips/ralink/rt3883.c</span>
<span class="p_chunk">@@ -36,7 +36,7 @@</span> <span class="p_context"> static struct rt2880_pmx_func uartlite_func[] = { FUNC(&quot;uartlite&quot;, 0, 15, 2) };</span>
 static struct rt2880_pmx_func jtag_func[] = { FUNC(&quot;jtag&quot;, 0, 17, 5) };
 static struct rt2880_pmx_func mdio_func[] = { FUNC(&quot;mdio&quot;, 0, 22, 2) };
 static struct rt2880_pmx_func lna_a_func[] = { FUNC(&quot;lna a&quot;, 0, 32, 3) };
<span class="p_del">-static struct rt2880_pmx_func lna_g_func[] = { FUNC(&quot;lna a&quot;, 0, 35, 3) };</span>
<span class="p_add">+static struct rt2880_pmx_func lna_g_func[] = { FUNC(&quot;lna g&quot;, 0, 35, 3) };</span>
 static struct rt2880_pmx_func pci_func[] = {
 	FUNC(&quot;pci-dev&quot;, 0, 40, 32),
 	FUNC(&quot;pci-host2&quot;, 1, 40, 32),
<span class="p_chunk">@@ -44,7 +44,7 @@</span> <span class="p_context"> static struct rt2880_pmx_func pci_func[] = {</span>
 	FUNC(&quot;pci-fnc&quot;, 3, 40, 32)
 };
 static struct rt2880_pmx_func ge1_func[] = { FUNC(&quot;ge1&quot;, 0, 72, 12) };
<span class="p_del">-static struct rt2880_pmx_func ge2_func[] = { FUNC(&quot;ge1&quot;, 0, 84, 12) };</span>
<span class="p_add">+static struct rt2880_pmx_func ge2_func[] = { FUNC(&quot;ge2&quot;, 0, 84, 12) };</span>
 
 static struct rt2880_pmx_group rt3883_pinmux_data[] = {
 	GRP(&quot;i2c&quot;, i2c_func, 1, RT3883_GPIO_MODE_I2C),
<span class="p_header">diff --git a/arch/nios2/kernel/prom.c b/arch/nios2/kernel/prom.c</span>
<span class="p_header">index 367c5426157b..3901b80d4420 100644</span>
<span class="p_header">--- a/arch/nios2/kernel/prom.c</span>
<span class="p_header">+++ b/arch/nios2/kernel/prom.c</span>
<span class="p_chunk">@@ -48,6 +48,13 @@</span> <span class="p_context"> void * __init early_init_dt_alloc_memory_arch(u64 size, u64 align)</span>
 	return alloc_bootmem_align(size, align);
 }
 
<span class="p_add">+int __init early_init_dt_reserve_memory_arch(phys_addr_t base, phys_addr_t size,</span>
<span class="p_add">+					     bool nomap)</span>
<span class="p_add">+{</span>
<span class="p_add">+	reserve_bootmem(base, size, BOOTMEM_DEFAULT);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void __init early_init_devtree(void *params)
 {
 	__be32 *dtb = (u32 *)__dtb_start;
<span class="p_header">diff --git a/arch/nios2/kernel/setup.c b/arch/nios2/kernel/setup.c</span>
<span class="p_header">index a4ff86d58d5c..6c4e351a7930 100644</span>
<span class="p_header">--- a/arch/nios2/kernel/setup.c</span>
<span class="p_header">+++ b/arch/nios2/kernel/setup.c</span>
<span class="p_chunk">@@ -195,6 +195,9 @@</span> <span class="p_context"> void __init setup_arch(char **cmdline_p)</span>
 	}
 #endif /* CONFIG_BLK_DEV_INITRD */
 
<span class="p_add">+	early_init_fdt_reserve_self();</span>
<span class="p_add">+	early_init_fdt_scan_reserved_mem();</span>
<span class="p_add">+</span>
 	unflatten_and_copy_device_tree();
 
 	setup_cpuinfo();
<span class="p_header">diff --git a/arch/powerpc/crypto/crc32c-vpmsum_glue.c b/arch/powerpc/crypto/crc32c-vpmsum_glue.c</span>
<span class="p_header">index 411994551afc..f058e0c3e4d4 100644</span>
<span class="p_header">--- a/arch/powerpc/crypto/crc32c-vpmsum_glue.c</span>
<span class="p_header">+++ b/arch/powerpc/crypto/crc32c-vpmsum_glue.c</span>
<span class="p_chunk">@@ -33,10 +33,13 @@</span> <span class="p_context"> static u32 crc32c_vpmsum(u32 crc, unsigned char const *p, size_t len)</span>
 	}
 
 	if (len &amp; ~VMX_ALIGN_MASK) {
<span class="p_add">+		preempt_disable();</span>
 		pagefault_disable();
 		enable_kernel_altivec();
 		crc = __crc32c_vpmsum(crc, p, len &amp; ~VMX_ALIGN_MASK);
<span class="p_add">+		disable_kernel_altivec();</span>
 		pagefault_enable();
<span class="p_add">+		preempt_enable();</span>
 	}
 
 	tail = len &amp; VMX_ALIGN_MASK;
<span class="p_header">diff --git a/arch/powerpc/kernel/align.c b/arch/powerpc/kernel/align.c</span>
<span class="p_header">index 033f3385fa49..b2da7c8baed7 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/align.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/align.c</span>
<span class="p_chunk">@@ -807,14 +807,25 @@</span> <span class="p_context"> int fix_alignment(struct pt_regs *regs)</span>
 	nb = aligninfo[instr].len;
 	flags = aligninfo[instr].flags;
 
<span class="p_del">-	/* ldbrx/stdbrx overlap lfs/stfs in the DSISR unfortunately */</span>
<span class="p_del">-	if (IS_XFORM(instruction) &amp;&amp; ((instruction &gt;&gt; 1) &amp; 0x3ff) == 532) {</span>
<span class="p_del">-		nb = 8;</span>
<span class="p_del">-		flags = LD+SW;</span>
<span class="p_del">-	} else if (IS_XFORM(instruction) &amp;&amp;</span>
<span class="p_del">-		   ((instruction &gt;&gt; 1) &amp; 0x3ff) == 660) {</span>
<span class="p_del">-		nb = 8;</span>
<span class="p_del">-		flags = ST+SW;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Handle some cases which give overlaps in the DSISR values.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (IS_XFORM(instruction)) {</span>
<span class="p_add">+		switch (get_xop(instruction)) {</span>
<span class="p_add">+		case 532:	/* ldbrx */</span>
<span class="p_add">+			nb = 8;</span>
<span class="p_add">+			flags = LD+SW;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 660:	/* stdbrx */</span>
<span class="p_add">+			nb = 8;</span>
<span class="p_add">+			flags = ST+SW;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 20:	/* lwarx */</span>
<span class="p_add">+		case 84:	/* ldarx */</span>
<span class="p_add">+		case 116:	/* lharx */</span>
<span class="p_add">+		case 276:	/* lqarx */</span>
<span class="p_add">+			return 0;	/* not emulated ever */</span>
<span class="p_add">+		}</span>
 	}
 
 	/* Byteswap little endian loads and stores */
<span class="p_header">diff --git a/arch/powerpc/kernel/misc_64.S b/arch/powerpc/kernel/misc_64.S</span>
<span class="p_header">index 4f178671f230..4cefe6888b18 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/misc_64.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/misc_64.S</span>
<span class="p_chunk">@@ -67,7 +67,7 @@</span> <span class="p_context"> PPC64_CACHES:</span>
  *   flush all bytes from start through stop-1 inclusive
  */
 
<span class="p_del">-_GLOBAL(flush_icache_range)</span>
<span class="p_add">+_GLOBAL_TOC(flush_icache_range)</span>
 BEGIN_FTR_SECTION
 	PURGE_PREFETCHED_INS
 	blr
<span class="p_chunk">@@ -120,7 +120,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(flush_icache_range)</span>
  *
  *    flush all bytes from start to stop-1 inclusive
  */
<span class="p_del">-_GLOBAL(flush_dcache_range)</span>
<span class="p_add">+_GLOBAL_TOC(flush_dcache_range)</span>
 
 /*
  * Flush the data cache to memory 
<span class="p_header">diff --git a/arch/powerpc/kernel/setup_64.c b/arch/powerpc/kernel/setup_64.c</span>
<span class="p_header">index 8d586cff8a41..a12be60181bf 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/setup_64.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/setup_64.c</span>
<span class="p_chunk">@@ -245,6 +245,15 @@</span> <span class="p_context"> static void cpu_ready_for_interrupts(void)</span>
 		mtspr(SPRN_LPCR, lpcr | LPCR_AIL_3);
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Fixup HFSCR:TM based on CPU features. The bit is set by our</span>
<span class="p_add">+	 * early asm init because at that point we haven&#39;t updated our</span>
<span class="p_add">+	 * CPU features from firmware and device-tree. Here we have,</span>
<span class="p_add">+	 * so let&#39;s do it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (cpu_has_feature(CPU_FTR_HVMODE) &amp;&amp; !cpu_has_feature(CPU_FTR_TM_COMP))</span>
<span class="p_add">+		mtspr(SPRN_HFSCR, mfspr(SPRN_HFSCR) &amp; ~HFSCR_TM);</span>
<span class="p_add">+</span>
 	/* Set IR and DR in PACA MSR */
 	get_paca()-&gt;kernel_msr = MSR_KERNEL;
 }
<span class="p_header">diff --git a/arch/powerpc/mm/hash_native_64.c b/arch/powerpc/mm/hash_native_64.c</span>
<span class="p_header">index ad9fd5245be2..197f0a60334a 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/hash_native_64.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/hash_native_64.c</span>
<span class="p_chunk">@@ -636,6 +636,10 @@</span> <span class="p_context"> static void native_flush_hash_range(unsigned long number, int local)</span>
 	unsigned long psize = batch-&gt;psize;
 	int ssize = batch-&gt;ssize;
 	int i;
<span class="p_add">+	unsigned int use_local;</span>
<span class="p_add">+</span>
<span class="p_add">+	use_local = local &amp;&amp; mmu_has_feature(MMU_FTR_TLBIEL) &amp;&amp;</span>
<span class="p_add">+		mmu_psize_defs[psize].tlbiel &amp;&amp; !cxl_ctx_in_use();</span>
 
 	local_irq_save(flags);
 
<span class="p_chunk">@@ -665,8 +669,7 @@</span> <span class="p_context"> static void native_flush_hash_range(unsigned long number, int local)</span>
 		} pte_iterate_hashed_end();
 	}
 
<span class="p_del">-	if (mmu_has_feature(MMU_FTR_TLBIEL) &amp;&amp;</span>
<span class="p_del">-	    mmu_psize_defs[psize].tlbiel &amp;&amp; local) {</span>
<span class="p_add">+	if (use_local) {</span>
 		asm volatile(&quot;ptesync&quot;:::&quot;memory&quot;);
 		for (i = 0; i &lt; number; i++) {
 			vpn = batch-&gt;vpn[i];
<span class="p_header">diff --git a/arch/s390/boot/compressed/misc.c b/arch/s390/boot/compressed/misc.c</span>
<span class="p_header">index 4da604ebf6fd..ca15613eaaa4 100644</span>
<span class="p_header">--- a/arch/s390/boot/compressed/misc.c</span>
<span class="p_header">+++ b/arch/s390/boot/compressed/misc.c</span>
<span class="p_chunk">@@ -141,31 +141,34 @@</span> <span class="p_context"> static void check_ipl_parmblock(void *start, unsigned long size)</span>
 
 unsigned long decompress_kernel(void)
 {
<span class="p_del">-	unsigned long output_addr;</span>
<span class="p_del">-	unsigned char *output;</span>
<span class="p_add">+	void *output, *kernel_end;</span>
 
<span class="p_del">-	output_addr = ((unsigned long) &amp;_end + HEAP_SIZE + 4095UL) &amp; -4096UL;</span>
<span class="p_del">-	check_ipl_parmblock((void *) 0, output_addr + SZ__bss_start);</span>
<span class="p_del">-	memset(&amp;_bss, 0, &amp;_ebss - &amp;_bss);</span>
<span class="p_del">-	free_mem_ptr = (unsigned long)&amp;_end;</span>
<span class="p_del">-	free_mem_end_ptr = free_mem_ptr + HEAP_SIZE;</span>
<span class="p_del">-	output = (unsigned char *) output_addr;</span>
<span class="p_add">+	output = (void *) ALIGN((unsigned long) &amp;_end + HEAP_SIZE, PAGE_SIZE);</span>
<span class="p_add">+	kernel_end = output + SZ__bss_start;</span>
<span class="p_add">+	check_ipl_parmblock((void *) 0, (unsigned long) kernel_end);</span>
 
 #ifdef CONFIG_BLK_DEV_INITRD
 	/*
 	 * Move the initrd right behind the end of the decompressed
<span class="p_del">-	 * kernel image.</span>
<span class="p_add">+	 * kernel image. This also prevents initrd corruption caused by</span>
<span class="p_add">+	 * bss clearing since kernel_end will always be located behind the</span>
<span class="p_add">+	 * current bss section..</span>
 	 */
<span class="p_del">-	if (INITRD_START &amp;&amp; INITRD_SIZE &amp;&amp;</span>
<span class="p_del">-	    INITRD_START &lt; (unsigned long) output + SZ__bss_start) {</span>
<span class="p_del">-		check_ipl_parmblock(output + SZ__bss_start,</span>
<span class="p_del">-				    INITRD_START + INITRD_SIZE);</span>
<span class="p_del">-		memmove(output + SZ__bss_start,</span>
<span class="p_del">-			(void *) INITRD_START, INITRD_SIZE);</span>
<span class="p_del">-		INITRD_START = (unsigned long) output + SZ__bss_start;</span>
<span class="p_add">+	if (INITRD_START &amp;&amp; INITRD_SIZE &amp;&amp; kernel_end &gt; (void *) INITRD_START) {</span>
<span class="p_add">+		check_ipl_parmblock(kernel_end, INITRD_SIZE);</span>
<span class="p_add">+		memmove(kernel_end, (void *) INITRD_START, INITRD_SIZE);</span>
<span class="p_add">+		INITRD_START = (unsigned long) kernel_end;</span>
 	}
 #endif
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Clear bss section. free_mem_ptr and free_mem_end_ptr need to be</span>
<span class="p_add">+	 * initialized afterwards since they reside in bss.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	memset(&amp;_bss, 0, &amp;_ebss - &amp;_bss);</span>
<span class="p_add">+	free_mem_ptr = (unsigned long) &amp;_end;</span>
<span class="p_add">+	free_mem_end_ptr = free_mem_ptr + HEAP_SIZE;</span>
<span class="p_add">+</span>
 	puts(&quot;Uncompressing Linux... &quot;);
 	__decompress(input_data, input_len, NULL, NULL, output, 0, NULL, error);
 	puts(&quot;Ok, booting the kernel.\n&quot;);
<span class="p_header">diff --git a/arch/s390/include/asm/uaccess.h b/arch/s390/include/asm/uaccess.h</span>
<span class="p_header">index 52d7c8709279..a7ef70220126 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -144,7 +144,7 @@</span> <span class="p_context"> unsigned long __must_check __copy_to_user(void __user *to, const void *from,</span>
 		&quot;	jg	2b\n&quot;				\
 		&quot;.popsection\n&quot;					\
 		EX_TABLE(0b,3b) EX_TABLE(1b,3b)			\
<span class="p_del">-		: &quot;=d&quot; (__rc), &quot;=Q&quot; (*(to))			\</span>
<span class="p_add">+		: &quot;=d&quot; (__rc), &quot;+Q&quot; (*(to))			\</span>
 		: &quot;d&quot; (size), &quot;Q&quot; (*(from)),			\
 		  &quot;d&quot; (__reg0), &quot;K&quot; (-EFAULT)			\
 		: &quot;cc&quot;);					\
<span class="p_header">diff --git a/arch/x86/kernel/reboot.c b/arch/x86/kernel/reboot.c</span>
<span class="p_header">index e244c19a2451..067f9813fd2c 100644</span>
<span class="p_header">--- a/arch/x86/kernel/reboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/reboot.c</span>
<span class="p_chunk">@@ -223,6 +223,22 @@</span> <span class="p_context"> static struct dmi_system_id __initdata reboot_dmi_table[] = {</span>
 			DMI_MATCH(DMI_BOARD_NAME, &quot;P4S800&quot;),
 		},
 	},
<span class="p_add">+	{	/* Handle problems with rebooting on ASUS EeeBook X205TA */</span>
<span class="p_add">+		.callback = set_acpi_reboot,</span>
<span class="p_add">+		.ident = &quot;ASUS EeeBook X205TA&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;X205TA&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{	/* Handle problems with rebooting on ASUS EeeBook X205TAW */</span>
<span class="p_add">+		.callback = set_acpi_reboot,</span>
<span class="p_add">+		.ident = &quot;ASUS EeeBook X205TAW&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;X205TAW&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 
 	/* Certec */
 	{       /* Handle problems with rebooting on Certec BPC600 */
<span class="p_header">diff --git a/arch/xtensa/include/asm/page.h b/arch/xtensa/include/asm/page.h</span>
<span class="p_header">index 976b1d70edbc..4ddbfd57a7c8 100644</span>
<span class="p_header">--- a/arch/xtensa/include/asm/page.h</span>
<span class="p_header">+++ b/arch/xtensa/include/asm/page.h</span>
<span class="p_chunk">@@ -164,8 +164,21 @@</span> <span class="p_context"> void copy_user_highpage(struct page *to, struct page *from,</span>
 
 #define ARCH_PFN_OFFSET		(PHYS_OFFSET &gt;&gt; PAGE_SHIFT)
 
<span class="p_add">+#ifdef CONFIG_MMU</span>
<span class="p_add">+static inline unsigned long ___pa(unsigned long va)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long off = va - PAGE_OFFSET;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (off &gt;= XCHAL_KSEG_SIZE)</span>
<span class="p_add">+		off -= XCHAL_KSEG_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	return off + PHYS_OFFSET;</span>
<span class="p_add">+}</span>
<span class="p_add">+#define __pa(x)	___pa((unsigned long)(x))</span>
<span class="p_add">+#else</span>
 #define __pa(x)	\
 	((unsigned long) (x) - PAGE_OFFSET + PHYS_OFFSET)
<span class="p_add">+#endif</span>
 #define __va(x)	\
 	((void *)((unsigned long) (x) - PHYS_OFFSET + PAGE_OFFSET))
 #define pfn_valid(pfn) \
<span class="p_header">diff --git a/drivers/acpi/button.c b/drivers/acpi/button.c</span>
<span class="p_header">index e19f530f1083..6d5a8c1d3132 100644</span>
<span class="p_header">--- a/drivers/acpi/button.c</span>
<span class="p_header">+++ b/drivers/acpi/button.c</span>
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> struct acpi_button {</span>
 
 static BLOCKING_NOTIFIER_HEAD(acpi_lid_notifier);
 static struct acpi_device *lid_device;
<span class="p_del">-static u8 lid_init_state = ACPI_BUTTON_LID_INIT_METHOD;</span>
<span class="p_add">+static u8 lid_init_state = ACPI_BUTTON_LID_INIT_OPEN;</span>
 
 static unsigned long lid_report_interval __read_mostly = 500;
 module_param(lid_report_interval, ulong, 0644);
<span class="p_header">diff --git a/drivers/acpi/internal.h b/drivers/acpi/internal.h</span>
<span class="p_header">index 1b41a2739dac..0c452265c111 100644</span>
<span class="p_header">--- a/drivers/acpi/internal.h</span>
<span class="p_header">+++ b/drivers/acpi/internal.h</span>
<span class="p_chunk">@@ -37,6 +37,7 @@</span> <span class="p_context"> void acpi_amba_init(void);</span>
 static inline void acpi_amba_init(void) {}
 #endif
 int acpi_sysfs_init(void);
<span class="p_add">+void acpi_gpe_apply_masked_gpes(void);</span>
 void acpi_container_init(void);
 void acpi_memory_hotplug_init(void);
 #ifdef	CONFIG_ACPI_HOTPLUG_IOAPIC
<span class="p_header">diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c</span>
<span class="p_header">index 3d1856f1f4d0..5a2fdf156ec9 100644</span>
<span class="p_header">--- a/drivers/acpi/scan.c</span>
<span class="p_header">+++ b/drivers/acpi/scan.c</span>
<span class="p_chunk">@@ -2044,6 +2044,7 @@</span> <span class="p_context"> int __init acpi_scan_init(void)</span>
 		}
 	}
 
<span class="p_add">+	acpi_gpe_apply_masked_gpes();</span>
 	acpi_update_all_gpes();
 	acpi_ec_ecdt_start();
 
<span class="p_header">diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c</span>
<span class="p_header">index 54abb26b7366..a4327af676fe 100644</span>
<span class="p_header">--- a/drivers/acpi/sleep.c</span>
<span class="p_header">+++ b/drivers/acpi/sleep.c</span>
<span class="p_chunk">@@ -130,6 +130,12 @@</span> <span class="p_context"> void __init acpi_nvs_nosave_s3(void)</span>
 	nvs_nosave_s3 = true;
 }
 
<span class="p_add">+static int __init init_nvs_save_s3(const struct dmi_system_id *d)</span>
<span class="p_add">+{</span>
<span class="p_add">+	nvs_nosave_s3 = false;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * ACPI 1.0 wants us to execute _PTS before suspending devices, so we allow the
  * user to request that behavior by using the &#39;acpi_old_suspend_ordering&#39;
<span class="p_chunk">@@ -324,6 +330,19 @@</span> <span class="p_context"> static struct dmi_system_id acpisleep_dmi_table[] __initdata = {</span>
 		DMI_MATCH(DMI_PRODUCT_NAME, &quot;K54HR&quot;),
 		},
 	},
<span class="p_add">+	/*</span>
<span class="p_add">+	 * https://bugzilla.kernel.org/show_bug.cgi?id=189431</span>
<span class="p_add">+	 * Lenovo G50-45 is a platform later than 2012, but needs nvs memory</span>
<span class="p_add">+	 * saving during S3.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+	.callback = init_nvs_save_s3,</span>
<span class="p_add">+	.ident = &quot;Lenovo G50-45&quot;,</span>
<span class="p_add">+	.matches = {</span>
<span class="p_add">+		DMI_MATCH(DMI_SYS_VENDOR, &quot;LENOVO&quot;),</span>
<span class="p_add">+		DMI_MATCH(DMI_PRODUCT_NAME, &quot;80E3&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 	{},
 };
 
<span class="p_header">diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c</span>
<span class="p_header">index 703c26e7022c..cf05ae973381 100644</span>
<span class="p_header">--- a/drivers/acpi/sysfs.c</span>
<span class="p_header">+++ b/drivers/acpi/sysfs.c</span>
<span class="p_chunk">@@ -708,6 +708,62 @@</span> <span class="p_context"> static ssize_t counter_set(struct kobject *kobj,</span>
 	return result ? result : size;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * A Quirk Mechanism for GPE Flooding Prevention:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Quirks may be needed to prevent GPE flooding on a specific GPE. The</span>
<span class="p_add">+ * flooding typically cannot be detected and automatically prevented by</span>
<span class="p_add">+ * ACPI_GPE_DISPATCH_NONE check because there is a _Lxx/_Exx prepared in</span>
<span class="p_add">+ * the AML tables. This normally indicates a feature gap in Linux, thus</span>
<span class="p_add">+ * instead of providing endless quirk tables, we provide a boot parameter</span>
<span class="p_add">+ * for those who want this quirk. For example, if the users want to prevent</span>
<span class="p_add">+ * the GPE flooding for GPE 00, they need to specify the following boot</span>
<span class="p_add">+ * parameter:</span>
<span class="p_add">+ *   acpi_mask_gpe=0x00</span>
<span class="p_add">+ * The masking status can be modified by the following runtime controlling</span>
<span class="p_add">+ * interface:</span>
<span class="p_add">+ *   echo unmask &gt; /sys/firmware/acpi/interrupts/gpe00</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Currently, the GPE flooding prevention only supports to mask the GPEs</span>
<span class="p_add">+ * numbered from 00 to 7f.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define ACPI_MASKABLE_GPE_MAX	0x80</span>
<span class="p_add">+</span>
<span class="p_add">+static u64 __initdata acpi_masked_gpes;</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init acpi_gpe_set_masked_gpes(char *val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 gpe;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (kstrtou8(val, 0, &amp;gpe) || gpe &gt; ACPI_MASKABLE_GPE_MAX)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	acpi_masked_gpes |= ((u64)1&lt;&lt;gpe);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+__setup(&quot;acpi_mask_gpe=&quot;, acpi_gpe_set_masked_gpes);</span>
<span class="p_add">+</span>
<span class="p_add">+void __init acpi_gpe_apply_masked_gpes(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	acpi_handle handle;</span>
<span class="p_add">+	acpi_status status;</span>
<span class="p_add">+	u8 gpe;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (gpe = 0;</span>
<span class="p_add">+	     gpe &lt; min_t(u8, ACPI_MASKABLE_GPE_MAX, acpi_current_gpe_count);</span>
<span class="p_add">+	     gpe++) {</span>
<span class="p_add">+		if (acpi_masked_gpes &amp; ((u64)1&lt;&lt;gpe)) {</span>
<span class="p_add">+			status = acpi_get_gpe_device(gpe, &amp;handle);</span>
<span class="p_add">+			if (ACPI_SUCCESS(status)) {</span>
<span class="p_add">+				pr_info(&quot;Masking GPE 0x%x.\n&quot;, gpe);</span>
<span class="p_add">+				(void)acpi_mask_gpe(handle, gpe, TRUE);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void acpi_irq_stats_init(void)
 {
 	acpi_status status;
<span class="p_header">diff --git a/drivers/ata/ahci_da850.c b/drivers/ata/ahci_da850.c</span>
<span class="p_header">index 267a3d3e79f4..52f2674d5e89 100644</span>
<span class="p_header">--- a/drivers/ata/ahci_da850.c</span>
<span class="p_header">+++ b/drivers/ata/ahci_da850.c</span>
<span class="p_chunk">@@ -54,11 +54,42 @@</span> <span class="p_context"> static void da850_sata_init(struct device *dev, void __iomem *pwrdn_reg,</span>
 	writel(val, ahci_base + SATA_P0PHYCR_REG);
 }
 
<span class="p_add">+static int ahci_da850_softreset(struct ata_link *link,</span>
<span class="p_add">+				unsigned int *class, unsigned long deadline)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int pmp, ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	pmp = sata_srst_pmp(link);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * There&#39;s an issue with the SATA controller on da850 SoCs: if we</span>
<span class="p_add">+	 * enable Port Multiplier support, but the drive is connected directly</span>
<span class="p_add">+	 * to the board, it can&#39;t be detected. As a workaround: if PMP is</span>
<span class="p_add">+	 * enabled, we first call ahci_do_softreset() and pass it the result of</span>
<span class="p_add">+	 * sata_srst_pmp(). If this call fails, we retry with pmp = 0.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ret = ahci_do_softreset(link, class, pmp, deadline, ahci_check_ready);</span>
<span class="p_add">+	if (pmp &amp;&amp; ret == -EBUSY)</span>
<span class="p_add">+		return ahci_do_softreset(link, class, 0,</span>
<span class="p_add">+					 deadline, ahci_check_ready);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct ata_port_operations ahci_da850_port_ops = {</span>
<span class="p_add">+	.inherits = &amp;ahci_platform_ops,</span>
<span class="p_add">+	.softreset = ahci_da850_softreset,</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * No need to override .pmp_softreset - it&#39;s only used for actual</span>
<span class="p_add">+	 * PMP-enabled ports.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct ata_port_info ahci_da850_port_info = {
 	.flags		= AHCI_FLAG_COMMON,
 	.pio_mask	= ATA_PIO4,
 	.udma_mask	= ATA_UDMA6,
<span class="p_del">-	.port_ops	= &amp;ahci_platform_ops,</span>
<span class="p_add">+	.port_ops	= &amp;ahci_da850_port_ops,</span>
 };
 
 static struct scsi_host_template ahci_platform_sht = {
<span class="p_header">diff --git a/drivers/char/ppdev.c b/drivers/char/ppdev.c</span>
<span class="p_header">index 6af1ce04b3da..336d02a488cc 100644</span>
<span class="p_header">--- a/drivers/char/ppdev.c</span>
<span class="p_header">+++ b/drivers/char/ppdev.c</span>
<span class="p_chunk">@@ -84,8 +84,14 @@</span> <span class="p_context"> struct pp_struct {</span>
 	struct ieee1284_info state;
 	struct ieee1284_info saved_state;
 	long default_inactivity;
<span class="p_add">+	int index;</span>
 };
 
<span class="p_add">+/* should we use PARDEVICE_MAX here? */</span>
<span class="p_add">+static struct device *devices[PARPORT_MAX];</span>
<span class="p_add">+</span>
<span class="p_add">+static DEFINE_IDA(ida_index);</span>
<span class="p_add">+</span>
 /* pp_struct.flags bitfields */
 #define PP_CLAIMED    (1&lt;&lt;0)
 #define PP_EXCL       (1&lt;&lt;1)
<span class="p_chunk">@@ -287,6 +293,7 @@</span> <span class="p_context"> static int register_device(int minor, struct pp_struct *pp)</span>
 	struct pardevice *pdev = NULL;
 	char *name;
 	struct pardev_cb ppdev_cb;
<span class="p_add">+	int index;</span>
 
 	name = kasprintf(GFP_KERNEL, CHRDEV &quot;%x&quot;, minor);
 	if (name == NULL)
<span class="p_chunk">@@ -299,20 +306,23 @@</span> <span class="p_context"> static int register_device(int minor, struct pp_struct *pp)</span>
 		return -ENXIO;
 	}
 
<span class="p_add">+	index = ida_simple_get(&amp;ida_index, 0, 0, GFP_KERNEL);</span>
 	memset(&amp;ppdev_cb, 0, sizeof(ppdev_cb));
 	ppdev_cb.irq_func = pp_irq;
 	ppdev_cb.flags = (pp-&gt;flags &amp; PP_EXCL) ? PARPORT_FLAG_EXCL : 0;
 	ppdev_cb.private = pp;
<span class="p_del">-	pdev = parport_register_dev_model(port, name, &amp;ppdev_cb, minor);</span>
<span class="p_add">+	pdev = parport_register_dev_model(port, name, &amp;ppdev_cb, index);</span>
 	parport_put_port(port);
 
 	if (!pdev) {
 		printk(KERN_WARNING &quot;%s: failed to register device!\n&quot;, name);
<span class="p_add">+		ida_simple_remove(&amp;ida_index, index);</span>
 		kfree(name);
 		return -ENXIO;
 	}
 
 	pp-&gt;pdev = pdev;
<span class="p_add">+	pp-&gt;index = index;</span>
 	dev_dbg(&amp;pdev-&gt;dev, &quot;registered pardevice\n&quot;);
 	return 0;
 }
<span class="p_chunk">@@ -749,6 +759,7 @@</span> <span class="p_context"> static int pp_release(struct inode *inode, struct file *file)</span>
 
 	if (pp-&gt;pdev) {
 		parport_unregister_device(pp-&gt;pdev);
<span class="p_add">+		ida_simple_remove(&amp;ida_index, pp-&gt;index);</span>
 		pp-&gt;pdev = NULL;
 		pr_debug(CHRDEV &quot;%x: unregistered pardevice\n&quot;, minor);
 	}
<span class="p_chunk">@@ -789,13 +800,29 @@</span> <span class="p_context"> static const struct file_operations pp_fops = {</span>
 
 static void pp_attach(struct parport *port)
 {
<span class="p_del">-	device_create(ppdev_class, port-&gt;dev, MKDEV(PP_MAJOR, port-&gt;number),</span>
<span class="p_del">-		      NULL, &quot;parport%d&quot;, port-&gt;number);</span>
<span class="p_add">+	struct device *ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (devices[port-&gt;number])</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = device_create(ppdev_class, port-&gt;dev,</span>
<span class="p_add">+			    MKDEV(PP_MAJOR, port-&gt;number), NULL,</span>
<span class="p_add">+			    &quot;parport%d&quot;, port-&gt;number);</span>
<span class="p_add">+	if (IS_ERR(ret)) {</span>
<span class="p_add">+		pr_err(&quot;Failed to create device parport%d\n&quot;,</span>
<span class="p_add">+		       port-&gt;number);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	devices[port-&gt;number] = ret;</span>
 }
 
 static void pp_detach(struct parport *port)
 {
<span class="p_add">+	if (!devices[port-&gt;number])</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	device_destroy(ppdev_class, MKDEV(PP_MAJOR, port-&gt;number));
<span class="p_add">+	devices[port-&gt;number] = NULL;</span>
 }
 
 static int pp_probe(struct pardevice *par_dev)
<span class="p_header">diff --git a/drivers/char/random.c b/drivers/char/random.c</span>
<span class="p_header">index d6876d506220..08d1dd58c0d2 100644</span>
<span class="p_header">--- a/drivers/char/random.c</span>
<span class="p_header">+++ b/drivers/char/random.c</span>
<span class="p_chunk">@@ -2042,63 +2042,65 @@</span> <span class="p_context"> struct ctl_table random_table[] = {</span>
 };
 #endif 	/* CONFIG_SYSCTL */
 
<span class="p_del">-static u32 random_int_secret[MD5_MESSAGE_BYTES / 4] ____cacheline_aligned;</span>
<span class="p_del">-</span>
<span class="p_del">-int random_int_secret_init(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	get_random_bytes(random_int_secret, sizeof(random_int_secret));</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static DEFINE_PER_CPU(__u32 [MD5_DIGEST_WORDS], get_random_int_hash)</span>
<span class="p_del">-		__aligned(sizeof(unsigned long));</span>
<span class="p_add">+struct batched_entropy {</span>
<span class="p_add">+	union {</span>
<span class="p_add">+		unsigned long entropy_long[CHACHA20_BLOCK_SIZE / sizeof(unsigned long)];</span>
<span class="p_add">+		unsigned int entropy_int[CHACHA20_BLOCK_SIZE / sizeof(unsigned int)];</span>
<span class="p_add">+	};</span>
<span class="p_add">+	unsigned int position;</span>
<span class="p_add">+};</span>
 
 /*
<span class="p_del">- * Get a random word for internal kernel use only. Similar to urandom but</span>
<span class="p_del">- * with the goal of minimal entropy pool depletion. As a result, the random</span>
<span class="p_del">- * value is not cryptographically secure but for several uses the cost of</span>
<span class="p_del">- * depleting entropy is too high</span>
<span class="p_add">+ * Get a random word for internal kernel use only. The quality of the random</span>
<span class="p_add">+ * number is either as good as RDRAND or as good as /dev/urandom, with the</span>
<span class="p_add">+ * goal of being quite fast and not depleting entropy.</span>
  */
<span class="p_del">-unsigned int get_random_int(void)</span>
<span class="p_add">+static DEFINE_PER_CPU(struct batched_entropy, batched_entropy_long);</span>
<span class="p_add">+unsigned long get_random_long(void)</span>
 {
<span class="p_del">-	__u32 *hash;</span>
<span class="p_del">-	unsigned int ret;</span>
<span class="p_add">+	unsigned long ret;</span>
<span class="p_add">+	struct batched_entropy *batch;</span>
 
<span class="p_del">-	if (arch_get_random_int(&amp;ret))</span>
<span class="p_add">+	if (arch_get_random_long(&amp;ret))</span>
 		return ret;
 
<span class="p_del">-	hash = get_cpu_var(get_random_int_hash);</span>
<span class="p_del">-</span>
<span class="p_del">-	hash[0] += current-&gt;pid + jiffies + random_get_entropy();</span>
<span class="p_del">-	md5_transform(hash, random_int_secret);</span>
<span class="p_del">-	ret = hash[0];</span>
<span class="p_del">-	put_cpu_var(get_random_int_hash);</span>
<span class="p_del">-</span>
<span class="p_add">+	batch = &amp;get_cpu_var(batched_entropy_long);</span>
<span class="p_add">+	if (batch-&gt;position % ARRAY_SIZE(batch-&gt;entropy_long) == 0) {</span>
<span class="p_add">+		extract_crng((u8 *)batch-&gt;entropy_long);</span>
<span class="p_add">+		batch-&gt;position = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	ret = batch-&gt;entropy_long[batch-&gt;position++];</span>
<span class="p_add">+	put_cpu_var(batched_entropy_long);</span>
 	return ret;
 }
<span class="p_del">-EXPORT_SYMBOL(get_random_int);</span>
<span class="p_add">+EXPORT_SYMBOL(get_random_long);</span>
 
<span class="p_del">-/*</span>
<span class="p_del">- * Same as get_random_int(), but returns unsigned long.</span>
<span class="p_del">- */</span>
<span class="p_del">-unsigned long get_random_long(void)</span>
<span class="p_add">+#if BITS_PER_LONG == 32</span>
<span class="p_add">+unsigned int get_random_int(void)</span>
 {
<span class="p_del">-	__u32 *hash;</span>
<span class="p_del">-	unsigned long ret;</span>
<span class="p_add">+	return get_random_long();</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+static DEFINE_PER_CPU(struct batched_entropy, batched_entropy_int);</span>
<span class="p_add">+unsigned int get_random_int(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int ret;</span>
<span class="p_add">+	struct batched_entropy *batch;</span>
 
<span class="p_del">-	if (arch_get_random_long(&amp;ret))</span>
<span class="p_add">+	if (arch_get_random_int(&amp;ret))</span>
 		return ret;
 
<span class="p_del">-	hash = get_cpu_var(get_random_int_hash);</span>
<span class="p_del">-</span>
<span class="p_del">-	hash[0] += current-&gt;pid + jiffies + random_get_entropy();</span>
<span class="p_del">-	md5_transform(hash, random_int_secret);</span>
<span class="p_del">-	ret = *(unsigned long *)hash;</span>
<span class="p_del">-	put_cpu_var(get_random_int_hash);</span>
<span class="p_del">-</span>
<span class="p_add">+	batch = &amp;get_cpu_var(batched_entropy_int);</span>
<span class="p_add">+	if (batch-&gt;position % ARRAY_SIZE(batch-&gt;entropy_int) == 0) {</span>
<span class="p_add">+		extract_crng((u8 *)batch-&gt;entropy_int);</span>
<span class="p_add">+		batch-&gt;position = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	ret = batch-&gt;entropy_int[batch-&gt;position++];</span>
<span class="p_add">+	put_cpu_var(batched_entropy_int);</span>
 	return ret;
 }
<span class="p_del">-EXPORT_SYMBOL(get_random_long);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+EXPORT_SYMBOL(get_random_int);</span>
 
 /**
  * randomize_page - Generate a random, page aligned address
<span class="p_header">diff --git a/drivers/clk/nxp/clk-lpc32xx.c b/drivers/clk/nxp/clk-lpc32xx.c</span>
<span class="p_header">index 34c97353cdeb..5b98ff9076f3 100644</span>
<span class="p_header">--- a/drivers/clk/nxp/clk-lpc32xx.c</span>
<span class="p_header">+++ b/drivers/clk/nxp/clk-lpc32xx.c</span>
<span class="p_chunk">@@ -1282,13 +1282,13 @@</span> <span class="p_context"> static struct clk_hw_proto clk_hw_proto[LPC32XX_CLK_HW_MAX] = {</span>
 
 	LPC32XX_DEFINE_MUX(PWM1_MUX, PWMCLK_CTRL, 1, 0x1, NULL, 0),
 	LPC32XX_DEFINE_DIV(PWM1_DIV, PWMCLK_CTRL, 4, 4, NULL,
<span class="p_del">-			   CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO),</span>
<span class="p_add">+			   CLK_DIVIDER_ONE_BASED),</span>
 	LPC32XX_DEFINE_GATE(PWM1_GATE, PWMCLK_CTRL, 0, 0),
 	LPC32XX_DEFINE_COMPOSITE(PWM1, PWM1_MUX, PWM1_DIV, PWM1_GATE),
 
 	LPC32XX_DEFINE_MUX(PWM2_MUX, PWMCLK_CTRL, 3, 0x1, NULL, 0),
 	LPC32XX_DEFINE_DIV(PWM2_DIV, PWMCLK_CTRL, 8, 4, NULL,
<span class="p_del">-			   CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO),</span>
<span class="p_add">+			   CLK_DIVIDER_ONE_BASED),</span>
 	LPC32XX_DEFINE_GATE(PWM2_GATE, PWMCLK_CTRL, 2, 0),
 	LPC32XX_DEFINE_COMPOSITE(PWM2, PWM2_MUX, PWM2_DIV, PWM2_GATE),
 
<span class="p_chunk">@@ -1335,8 +1335,7 @@</span> <span class="p_context"> static struct clk_hw_proto clk_hw_proto[LPC32XX_CLK_HW_MAX] = {</span>
 	LPC32XX_DEFINE_GATE(USB_DIV_GATE, USB_CTRL, 17, 0),
 	LPC32XX_DEFINE_COMPOSITE(USB_DIV, _NULL, USB_DIV_DIV, USB_DIV_GATE),
 
<span class="p_del">-	LPC32XX_DEFINE_DIV(SD_DIV, MS_CTRL, 0, 4, NULL,</span>
<span class="p_del">-			   CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO),</span>
<span class="p_add">+	LPC32XX_DEFINE_DIV(SD_DIV, MS_CTRL, 0, 4, NULL, CLK_DIVIDER_ONE_BASED),</span>
 	LPC32XX_DEFINE_CLK(SD_GATE, MS_CTRL, BIT(5) | BIT(9), BIT(5) | BIT(9),
 			   0x0, BIT(5) | BIT(9), 0x0, 0x0, clk_mask_ops),
 	LPC32XX_DEFINE_COMPOSITE(SD, _NULL, SD_DIV, SD_GATE),
<span class="p_chunk">@@ -1478,6 +1477,20 @@</span> <span class="p_context"> static struct clk * __init lpc32xx_clk_register(u32 id)</span>
 	return clk;
 }
 
<span class="p_add">+static void __init lpc32xx_clk_div_quirk(u32 reg, u32 div_mask, u32 gate)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	regmap_read(clk_regmap, reg, &amp;val);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(val &amp; div_mask)) {</span>
<span class="p_add">+		val &amp;= ~gate;</span>
<span class="p_add">+		val |= BIT(__ffs(div_mask));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	regmap_update_bits(clk_regmap, reg, gate | div_mask, val);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void __init lpc32xx_clk_init(struct device_node *np)
 {
 	unsigned int i;
<span class="p_chunk">@@ -1517,6 +1530,17 @@</span> <span class="p_context"> static void __init lpc32xx_clk_init(struct device_node *np)</span>
 		return;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Divider part of PWM and MS clocks requires a quirk to avoid</span>
<span class="p_add">+	 * a misinterpretation of formally valid zero value in register</span>
<span class="p_add">+	 * bitfield, which indicates another clock gate. Instead of</span>
<span class="p_add">+	 * adding complexity to a gate clock ensure that zero value in</span>
<span class="p_add">+	 * divider clock is never met in runtime.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	lpc32xx_clk_div_quirk(LPC32XX_CLKPWR_PWMCLK_CTRL, 0xf0, BIT(0));</span>
<span class="p_add">+	lpc32xx_clk_div_quirk(LPC32XX_CLKPWR_PWMCLK_CTRL, 0xf00, BIT(2));</span>
<span class="p_add">+	lpc32xx_clk_div_quirk(LPC32XX_CLKPWR_MS_CTRL, 0xf, BIT(5) | BIT(9));</span>
<span class="p_add">+</span>
 	for (i = 1; i &lt; LPC32XX_CLK_MAX; i++) {
 		clk[i] = lpc32xx_clk_register(i);
 		if (IS_ERR(clk[i])) {
<span class="p_header">diff --git a/drivers/clocksource/arm_arch_timer.c b/drivers/clocksource/arm_arch_timer.c</span>
<span class="p_header">index 73c487da6d2a..a2503db7e533 100644</span>
<span class="p_header">--- a/drivers/clocksource/arm_arch_timer.c</span>
<span class="p_header">+++ b/drivers/clocksource/arm_arch_timer.c</span>
<span class="p_chunk">@@ -81,6 +81,7 @@</span> <span class="p_context"> static struct clock_event_device __percpu *arch_timer_evt;</span>
 static enum ppi_nr arch_timer_uses_ppi = VIRT_PPI;
 static bool arch_timer_c3stop;
 static bool arch_timer_mem_use_virtual;
<span class="p_add">+static bool arch_counter_suspend_stop;</span>
 
 static bool evtstrm_enable = IS_ENABLED(CONFIG_ARM_ARCH_TIMER_EVTSTREAM);
 
<span class="p_chunk">@@ -576,7 +577,7 @@</span> <span class="p_context"> static struct clocksource clocksource_counter = {</span>
 	.rating	= 400,
 	.read	= arch_counter_read,
 	.mask	= CLOCKSOURCE_MASK(56),
<span class="p_del">-	.flags	= CLOCK_SOURCE_IS_CONTINUOUS | CLOCK_SOURCE_SUSPEND_NONSTOP,</span>
<span class="p_add">+	.flags	= CLOCK_SOURCE_IS_CONTINUOUS,</span>
 };
 
 static struct cyclecounter cyclecounter = {
<span class="p_chunk">@@ -616,6 +617,8 @@</span> <span class="p_context"> static void __init arch_counter_register(unsigned type)</span>
 		arch_timer_read_counter = arch_counter_get_cntvct_mem;
 	}
 
<span class="p_add">+	if (!arch_counter_suspend_stop)</span>
<span class="p_add">+		clocksource_counter.flags |= CLOCK_SOURCE_SUSPEND_NONSTOP;</span>
 	start_count = arch_timer_read_counter();
 	clocksource_register_hz(&amp;clocksource_counter, arch_timer_rate);
 	cyclecounter.mult = clocksource_counter.mult;
<span class="p_chunk">@@ -907,6 +910,10 @@</span> <span class="p_context"> static int __init arch_timer_of_init(struct device_node *np)</span>
 	    of_property_read_bool(np, &quot;arm,cpu-registers-not-fw-configured&quot;))
 		arch_timer_uses_ppi = PHYS_SECURE_PPI;
 
<span class="p_add">+	/* On some systems, the counter stops ticking when in suspend. */</span>
<span class="p_add">+	arch_counter_suspend_stop = of_property_read_bool(np,</span>
<span class="p_add">+							 &quot;arm,no-tick-in-suspend&quot;);</span>
<span class="p_add">+</span>
 	return arch_timer_init();
 }
 CLOCKSOURCE_OF_DECLARE(armv7_arch_timer, &quot;arm,armv7-timer&quot;, arch_timer_of_init);
<span class="p_header">diff --git a/drivers/firmware/qcom_scm-64.c b/drivers/firmware/qcom_scm-64.c</span>
<span class="p_header">index 4a0f5ead4fb5..1e2e5198db53 100644</span>
<span class="p_header">--- a/drivers/firmware/qcom_scm-64.c</span>
<span class="p_header">+++ b/drivers/firmware/qcom_scm-64.c</span>
<span class="p_chunk">@@ -91,6 +91,7 @@</span> <span class="p_context"> static int qcom_scm_call(struct device *dev, u32 svc_id, u32 cmd_id,</span>
 	dma_addr_t args_phys = 0;
 	void *args_virt = NULL;
 	size_t alloc_len;
<span class="p_add">+	struct arm_smccc_quirk quirk = {.id = ARM_SMCCC_QUIRK_QCOM_A6};</span>
 
 	if (unlikely(arglen &gt; N_REGISTER_ARGS)) {
 		alloc_len = N_EXT_QCOM_SCM_ARGS * sizeof(u64);
<span class="p_chunk">@@ -131,10 +132,16 @@</span> <span class="p_context"> static int qcom_scm_call(struct device *dev, u32 svc_id, u32 cmd_id,</span>
 					 qcom_smccc_convention,
 					 ARM_SMCCC_OWNER_SIP, fn_id);
 
<span class="p_add">+		quirk.state.a6 = 0;</span>
<span class="p_add">+</span>
 		do {
<span class="p_del">-			arm_smccc_smc(cmd, desc-&gt;arginfo, desc-&gt;args[0],</span>
<span class="p_del">-				      desc-&gt;args[1], desc-&gt;args[2], x5, 0, 0,</span>
<span class="p_del">-				      res);</span>
<span class="p_add">+			arm_smccc_smc_quirk(cmd, desc-&gt;arginfo, desc-&gt;args[0],</span>
<span class="p_add">+				      desc-&gt;args[1], desc-&gt;args[2], x5,</span>
<span class="p_add">+				      quirk.state.a6, 0, res, &amp;quirk);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (res-&gt;a0 == QCOM_SCM_INTERRUPTED)</span>
<span class="p_add">+				cmd = res-&gt;a0;</span>
<span class="p_add">+</span>
 		} while (res-&gt;a0 == QCOM_SCM_INTERRUPTED);
 
 		mutex_unlock(&amp;qcom_scm_lock);
<span class="p_header">diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c</span>
<span class="p_header">index 72a4b326fd0d..986248f7011a 100644</span>
<span class="p_header">--- a/drivers/gpio/gpiolib-acpi.c</span>
<span class="p_header">+++ b/drivers/gpio/gpiolib-acpi.c</span>
<span class="p_chunk">@@ -571,8 +571,10 @@</span> <span class="p_context"> struct gpio_desc *acpi_find_gpio(struct device *dev,</span>
 		}
 
 		desc = acpi_get_gpiod_by_index(adev, propname, idx, &amp;info);
<span class="p_del">-		if (!IS_ERR(desc) || (PTR_ERR(desc) == -EPROBE_DEFER))</span>
<span class="p_add">+		if (!IS_ERR(desc))</span>
 			break;
<span class="p_add">+		if (PTR_ERR(desc) == -EPROBE_DEFER)</span>
<span class="p_add">+			return ERR_CAST(desc);</span>
 	}
 
 	/* Then from plain _CRS GPIOs */
<span class="p_header">diff --git a/drivers/gpu/drm/drm_edid.c b/drivers/gpu/drm/drm_edid.c</span>
<span class="p_header">index 7491180698d1..0bc0afb6321e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_edid.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_edid.c</span>
<span class="p_chunk">@@ -90,7 +90,7 @@</span> <span class="p_context"> struct detailed_mode_closure {</span>
 #define LEVEL_GTF2	2
 #define LEVEL_CVT	3
 
<span class="p_del">-static struct edid_quirk {</span>
<span class="p_add">+static const struct edid_quirk {</span>
 	char vendor[4];
 	int product_id;
 	u32 quirks;
<span class="p_chunk">@@ -1449,7 +1449,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(drm_edid_duplicate);</span>
  *
  * Returns true if @vendor is in @edid, false otherwise
  */
<span class="p_del">-static bool edid_vendor(struct edid *edid, char *vendor)</span>
<span class="p_add">+static bool edid_vendor(struct edid *edid, const char *vendor)</span>
 {
 	char edid_vendor[3];
 
<span class="p_chunk">@@ -1469,7 +1469,7 @@</span> <span class="p_context"> static bool edid_vendor(struct edid *edid, char *vendor)</span>
  */
 static u32 edid_get_quirks(struct edid *edid)
 {
<span class="p_del">-	struct edid_quirk *quirk;</span>
<span class="p_add">+	const struct edid_quirk *quirk;</span>
 	int i;
 
 	for (i = 0; i &lt; ARRAY_SIZE(edid_quirk_list); i++) {
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_pci.c b/drivers/gpu/drm/i915/i915_pci.c</span>
<span class="p_header">index 31e6edd08dd0..9e9488639af5 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_pci.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_pci.c</span>
<span class="p_chunk">@@ -417,6 +417,7 @@</span> <span class="p_context"> static const struct pci_device_id pciidlist[] = {</span>
 	INTEL_VLV_IDS(&amp;intel_valleyview_info),
 	INTEL_BDW_GT12_IDS(&amp;intel_broadwell_info),
 	INTEL_BDW_GT3_IDS(&amp;intel_broadwell_gt3_info),
<span class="p_add">+	INTEL_BDW_RSVD_IDS(&amp;intel_broadwell_info),</span>
 	INTEL_CHV_IDS(&amp;intel_cherryview_info),
 	INTEL_SKL_GT1_IDS(&amp;intel_skylake_info),
 	INTEL_SKL_GT2_IDS(&amp;intel_skylake_info),
<span class="p_header">diff --git a/drivers/gpu/drm/mga/mga_dma.c b/drivers/gpu/drm/mga/mga_dma.c</span>
<span class="p_header">index 1f2f9ca25901..4556e2b13ac5 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/mga/mga_dma.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/mga/mga_dma.c</span>
<span class="p_chunk">@@ -392,6 +392,24 @@</span> <span class="p_context"> int mga_driver_load(struct drm_device *dev, unsigned long flags)</span>
 	drm_mga_private_t *dev_priv;
 	int ret;
 
<span class="p_add">+	/* There are PCI versions of the G450.  These cards have the</span>
<span class="p_add">+	 * same PCI ID as the AGP G450, but have an additional PCI-to-PCI</span>
<span class="p_add">+	 * bridge chip.  We detect these cards, which are not currently</span>
<span class="p_add">+	 * supported by this driver, by looking at the device ID of the</span>
<span class="p_add">+	 * bus the &quot;card&quot; is on.  If vendor is 0x3388 (Hint Corp) and the</span>
<span class="p_add">+	 * device is 0x0021 (HB6 Universal PCI-PCI bridge), we reject the</span>
<span class="p_add">+	 * device.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((dev-&gt;pdev-&gt;device == 0x0525) &amp;&amp; dev-&gt;pdev-&gt;bus-&gt;self</span>
<span class="p_add">+	    &amp;&amp; (dev-&gt;pdev-&gt;bus-&gt;self-&gt;vendor == 0x3388)</span>
<span class="p_add">+	    &amp;&amp; (dev-&gt;pdev-&gt;bus-&gt;self-&gt;device == 0x0021)</span>
<span class="p_add">+	    &amp;&amp; dev-&gt;agp) {</span>
<span class="p_add">+		/* FIXME: This should be quirked in the pci core, but oh well</span>
<span class="p_add">+		 * the hw probably stopped existing. */</span>
<span class="p_add">+		arch_phys_wc_del(dev-&gt;agp-&gt;agp_mtrr);</span>
<span class="p_add">+		kfree(dev-&gt;agp);</span>
<span class="p_add">+		dev-&gt;agp = NULL;</span>
<span class="p_add">+	}</span>
 	dev_priv = kzalloc(sizeof(drm_mga_private_t), GFP_KERNEL);
 	if (!dev_priv)
 		return -ENOMEM;
<span class="p_chunk">@@ -698,7 +716,7 @@</span> <span class="p_context"> static int mga_do_pci_dma_bootstrap(struct drm_device *dev,</span>
 static int mga_do_dma_bootstrap(struct drm_device *dev,
 				drm_mga_dma_bootstrap_t *dma_bs)
 {
<span class="p_del">-	const int is_agp = (dma_bs-&gt;agp_mode != 0) &amp;&amp; drm_pci_device_is_agp(dev);</span>
<span class="p_add">+	const int is_agp = (dma_bs-&gt;agp_mode != 0) &amp;&amp; dev-&gt;agp;</span>
 	int err;
 	drm_mga_private_t *const dev_priv =
 	    (drm_mga_private_t *) dev-&gt;dev_private;
<span class="p_header">diff --git a/drivers/gpu/drm/mga/mga_drv.c b/drivers/gpu/drm/mga/mga_drv.c</span>
<span class="p_header">index 25b2a1a424e6..63ba0699d107 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/mga/mga_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/mga/mga_drv.c</span>
<span class="p_chunk">@@ -37,8 +37,6 @@</span> <span class="p_context"></span>
 
 #include &lt;drm/drm_pciids.h&gt;
 
<span class="p_del">-static int mga_driver_device_is_agp(struct drm_device *dev);</span>
<span class="p_del">-</span>
 static struct pci_device_id pciidlist[] = {
 	mga_PCI_IDS
 };
<span class="p_chunk">@@ -66,7 +64,6 @@</span> <span class="p_context"> static struct drm_driver driver = {</span>
 	.lastclose = mga_driver_lastclose,
 	.set_busid = drm_pci_set_busid,
 	.dma_quiescent = mga_driver_dma_quiescent,
<span class="p_del">-	.device_is_agp = mga_driver_device_is_agp,</span>
 	.get_vblank_counter = mga_get_vblank_counter,
 	.enable_vblank = mga_enable_vblank,
 	.disable_vblank = mga_disable_vblank,
<span class="p_chunk">@@ -107,37 +104,3 @@</span> <span class="p_context"> module_exit(mga_exit);</span>
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE(&quot;GPL and additional rights&quot;);
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * Determine if the device really is AGP or not.</span>
<span class="p_del">- *</span>
<span class="p_del">- * In addition to the usual tests performed by \c drm_device_is_agp, this</span>
<span class="p_del">- * function detects PCI G450 cards that appear to the system exactly like</span>
<span class="p_del">- * AGP G450 cards.</span>
<span class="p_del">- *</span>
<span class="p_del">- * \param dev   The device to be tested.</span>
<span class="p_del">- *</span>
<span class="p_del">- * \returns</span>
<span class="p_del">- * If the device is a PCI G450, zero is returned.  Otherwise 2 is returned.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int mga_driver_device_is_agp(struct drm_device *dev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	const struct pci_dev *const pdev = dev-&gt;pdev;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* There are PCI versions of the G450.  These cards have the</span>
<span class="p_del">-	 * same PCI ID as the AGP G450, but have an additional PCI-to-PCI</span>
<span class="p_del">-	 * bridge chip.  We detect these cards, which are not currently</span>
<span class="p_del">-	 * supported by this driver, by looking at the device ID of the</span>
<span class="p_del">-	 * bus the &quot;card&quot; is on.  If vendor is 0x3388 (Hint Corp) and the</span>
<span class="p_del">-	 * device is 0x0021 (HB6 Universal PCI-PCI bridge), we reject the</span>
<span class="p_del">-	 * device.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-</span>
<span class="p_del">-	if ((pdev-&gt;device == 0x0525) &amp;&amp; pdev-&gt;bus-&gt;self</span>
<span class="p_del">-	    &amp;&amp; (pdev-&gt;bus-&gt;self-&gt;vendor == 0x3388)</span>
<span class="p_del">-	    &amp;&amp; (pdev-&gt;bus-&gt;self-&gt;device == 0x0021)) {</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return 2;</span>
<span class="p_del">-}</span>
<span class="p_header">diff --git a/drivers/gpu/drm/msm/adreno/adreno_device.c b/drivers/gpu/drm/msm/adreno/adreno_device.c</span>
<span class="p_header">index 5127b75dbf40..7250ffc6322f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/msm/adreno/adreno_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/msm/adreno/adreno_device.c</span>
<span class="p_chunk">@@ -25,9 +25,6 @@</span> <span class="p_context"> bool hang_debug = false;</span>
 MODULE_PARM_DESC(hang_debug, &quot;Dump registers when hang is detected (can be slow!)&quot;);
 module_param_named(hang_debug, hang_debug, bool, 0600);
 
<span class="p_del">-struct msm_gpu *a3xx_gpu_init(struct drm_device *dev);</span>
<span class="p_del">-struct msm_gpu *a4xx_gpu_init(struct drm_device *dev);</span>
<span class="p_del">-</span>
 static const struct adreno_info gpulist[] = {
 	{
 		.rev   = ADRENO_REV(3, 0, 5, ANY_ID),
<span class="p_header">diff --git a/drivers/gpu/drm/msm/adreno/adreno_gpu.h b/drivers/gpu/drm/msm/adreno/adreno_gpu.h</span>
<span class="p_header">index a54f6e036b4a..07d99bdf7c99 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/msm/adreno/adreno_gpu.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/msm/adreno/adreno_gpu.h</span>
<span class="p_chunk">@@ -311,4 +311,7 @@</span> <span class="p_context"> static inline void adreno_gpu_write(struct adreno_gpu *gpu,</span>
 		gpu_write(&amp;gpu-&gt;base, reg - 1, data);
 }
 
<span class="p_add">+struct msm_gpu *a3xx_gpu_init(struct drm_device *dev);</span>
<span class="p_add">+struct msm_gpu *a4xx_gpu_init(struct drm_device *dev);</span>
<span class="p_add">+</span>
 #endif /* __ADRENO_GPU_H__ */
<span class="p_header">diff --git a/drivers/gpu/drm/sun4i/sun4i_backend.c b/drivers/gpu/drm/sun4i/sun4i_backend.c</span>
<span class="p_header">index 32c0584e3c35..6e6c59a661b6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/sun4i/sun4i_backend.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/sun4i/sun4i_backend.c</span>
<span class="p_chunk">@@ -408,6 +408,7 @@</span> <span class="p_context"> static int sun4i_backend_remove(struct platform_device *pdev)</span>
 
 static const struct of_device_id sun4i_backend_of_table[] = {
 	{ .compatible = &quot;allwinner,sun5i-a13-display-backend&quot; },
<span class="p_add">+	{ .compatible = &quot;allwinner,sun6i-a31-display-backend&quot; },</span>
 	{ .compatible = &quot;allwinner,sun8i-a33-display-backend&quot; },
 	{ }
 };
<span class="p_header">diff --git a/drivers/gpu/drm/sun4i/sun4i_drv.c b/drivers/gpu/drm/sun4i/sun4i_drv.c</span>
<span class="p_header">index 70e9fd59c5a2..c3b21865443e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/sun4i/sun4i_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/sun4i/sun4i_drv.c</span>
<span class="p_chunk">@@ -201,12 +201,15 @@</span> <span class="p_context"> static const struct component_master_ops sun4i_drv_master_ops = {</span>
 static bool sun4i_drv_node_is_frontend(struct device_node *node)
 {
 	return of_device_is_compatible(node, &quot;allwinner,sun5i-a13-display-frontend&quot;) ||
<span class="p_add">+		of_device_is_compatible(node, &quot;allwinner,sun6i-a31-display-frontend&quot;) ||</span>
 		of_device_is_compatible(node, &quot;allwinner,sun8i-a33-display-frontend&quot;);
 }
 
 static bool sun4i_drv_node_is_tcon(struct device_node *node)
 {
 	return of_device_is_compatible(node, &quot;allwinner,sun5i-a13-tcon&quot;) ||
<span class="p_add">+		of_device_is_compatible(node, &quot;allwinner,sun6i-a31-tcon&quot;) ||</span>
<span class="p_add">+		of_device_is_compatible(node, &quot;allwinner,sun6i-a31s-tcon&quot;) ||</span>
 		of_device_is_compatible(node, &quot;allwinner,sun8i-a33-tcon&quot;);
 }
 
<span class="p_chunk">@@ -322,6 +325,8 @@</span> <span class="p_context"> static int sun4i_drv_remove(struct platform_device *pdev)</span>
 
 static const struct of_device_id sun4i_drv_of_table[] = {
 	{ .compatible = &quot;allwinner,sun5i-a13-display-engine&quot; },
<span class="p_add">+	{ .compatible = &quot;allwinner,sun6i-a31-display-engine&quot; },</span>
<span class="p_add">+	{ .compatible = &quot;allwinner,sun6i-a31s-display-engine&quot; },</span>
 	{ .compatible = &quot;allwinner,sun8i-a33-display-engine&quot; },
 	{ }
 };
<span class="p_header">diff --git a/drivers/gpu/drm/sun4i/sun4i_tcon.c b/drivers/gpu/drm/sun4i/sun4i_tcon.c</span>
<span class="p_header">index cadacb517f95..c6afb2448655 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/sun4i/sun4i_tcon.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/sun4i/sun4i_tcon.c</span>
<span class="p_chunk">@@ -20,6 +20,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/component.h&gt;
 #include &lt;linux/ioport.h&gt;
 #include &lt;linux/of_address.h&gt;
<span class="p_add">+#include &lt;linux/of_device.h&gt;</span>
 #include &lt;linux/of_graph.h&gt;
 #include &lt;linux/of_irq.h&gt;
 #include &lt;linux/regmap.h&gt;
<span class="p_chunk">@@ -62,7 +63,7 @@</span> <span class="p_context"> void sun4i_tcon_channel_disable(struct sun4i_tcon *tcon, int channel)</span>
 		return;
 	}
 
<span class="p_del">-	WARN_ON(!tcon-&gt;has_channel_1);</span>
<span class="p_add">+	WARN_ON(!tcon-&gt;quirks-&gt;has_channel_1);</span>
 	regmap_update_bits(tcon-&gt;regs, SUN4I_TCON1_CTL_REG,
 			   SUN4I_TCON1_CTL_TCON_ENABLE, 0);
 	clk_disable_unprepare(tcon-&gt;sclk1);
<span class="p_chunk">@@ -80,7 +81,7 @@</span> <span class="p_context"> void sun4i_tcon_channel_enable(struct sun4i_tcon *tcon, int channel)</span>
 		return;
 	}
 
<span class="p_del">-	WARN_ON(!tcon-&gt;has_channel_1);</span>
<span class="p_add">+	WARN_ON(!tcon-&gt;quirks-&gt;has_channel_1);</span>
 	regmap_update_bits(tcon-&gt;regs, SUN4I_TCON1_CTL_REG,
 			   SUN4I_TCON1_CTL_TCON_ENABLE,
 			   SUN4I_TCON1_CTL_TCON_ENABLE);
<span class="p_chunk">@@ -202,7 +203,7 @@</span> <span class="p_context"> void sun4i_tcon1_mode_set(struct sun4i_tcon *tcon,</span>
 	u8 clk_delay;
 	u32 val;
 
<span class="p_del">-	WARN_ON(!tcon-&gt;has_channel_1);</span>
<span class="p_add">+	WARN_ON(!tcon-&gt;quirks-&gt;has_channel_1);</span>
 
 	/* Adjust clock delay */
 	clk_delay = sun4i_tcon_get_clk_delay(mode, 1);
<span class="p_chunk">@@ -266,7 +267,7 @@</span> <span class="p_context"> void sun4i_tcon1_mode_set(struct sun4i_tcon *tcon,</span>
 	/*
 	 * FIXME: Undocumented bits
 	 */
<span class="p_del">-	if (tcon-&gt;has_mux)</span>
<span class="p_add">+	if (tcon-&gt;quirks-&gt;has_unknown_mux)</span>
 		regmap_write(tcon-&gt;regs, SUN4I_TCON_MUX_CTRL_REG, 1);
 }
 EXPORT_SYMBOL(sun4i_tcon1_mode_set);
<span class="p_chunk">@@ -327,7 +328,7 @@</span> <span class="p_context"> static int sun4i_tcon_init_clocks(struct device *dev,</span>
 		return PTR_ERR(tcon-&gt;sclk0);
 	}
 
<span class="p_del">-	if (tcon-&gt;has_channel_1) {</span>
<span class="p_add">+	if (tcon-&gt;quirks-&gt;has_channel_1) {</span>
 		tcon-&gt;sclk1 = devm_clk_get(dev, &quot;tcon-ch1&quot;);
 		if (IS_ERR(tcon-&gt;sclk1)) {
 			dev_err(dev, &quot;Couldn&#39;t get the TCON channel 1 clock\n&quot;);
<span class="p_chunk">@@ -487,14 +488,7 @@</span> <span class="p_context"> static int sun4i_tcon_bind(struct device *dev, struct device *master,</span>
 	drv-&gt;tcon = tcon;
 	tcon-&gt;drm = drm;
 	tcon-&gt;dev = dev;
<span class="p_del">-</span>
<span class="p_del">-	if (of_device_is_compatible(dev-&gt;of_node, &quot;allwinner,sun5i-a13-tcon&quot;)) {</span>
<span class="p_del">-		tcon-&gt;has_mux = true;</span>
<span class="p_del">-		tcon-&gt;has_channel_1 = true;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		tcon-&gt;has_mux = false;</span>
<span class="p_del">-		tcon-&gt;has_channel_1 = false;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	tcon-&gt;quirks = of_device_get_match_data(dev);</span>
 
 	tcon-&gt;lcd_rst = devm_reset_control_get(dev, &quot;lcd&quot;);
 	if (IS_ERR(tcon-&gt;lcd_rst)) {
<span class="p_chunk">@@ -588,9 +582,28 @@</span> <span class="p_context"> static int sun4i_tcon_remove(struct platform_device *pdev)</span>
 	return 0;
 }
 
<span class="p_add">+static const struct sun4i_tcon_quirks sun5i_a13_quirks = {</span>
<span class="p_add">+	.has_unknown_mux = true,</span>
<span class="p_add">+	.has_channel_1	= true,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct sun4i_tcon_quirks sun6i_a31_quirks = {</span>
<span class="p_add">+	.has_channel_1	= true,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct sun4i_tcon_quirks sun6i_a31s_quirks = {</span>
<span class="p_add">+	.has_channel_1	= true,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct sun4i_tcon_quirks sun8i_a33_quirks = {</span>
<span class="p_add">+	/* nothing is supported */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct of_device_id sun4i_tcon_of_table[] = {
<span class="p_del">-	{ .compatible = &quot;allwinner,sun5i-a13-tcon&quot; },</span>
<span class="p_del">-	{ .compatible = &quot;allwinner,sun8i-a33-tcon&quot; },</span>
<span class="p_add">+	{ .compatible = &quot;allwinner,sun5i-a13-tcon&quot;, .data = &amp;sun5i_a13_quirks },</span>
<span class="p_add">+	{ .compatible = &quot;allwinner,sun6i-a31-tcon&quot;, .data = &amp;sun6i_a31_quirks },</span>
<span class="p_add">+	{ .compatible = &quot;allwinner,sun6i-a31s-tcon&quot;, .data = &amp;sun6i_a31s_quirks },</span>
<span class="p_add">+	{ .compatible = &quot;allwinner,sun8i-a33-tcon&quot;, .data = &amp;sun8i_a33_quirks },</span>
 	{ }
 };
 MODULE_DEVICE_TABLE(of, sun4i_tcon_of_table);
<span class="p_header">diff --git a/drivers/gpu/drm/sun4i/sun4i_tcon.h b/drivers/gpu/drm/sun4i/sun4i_tcon.h</span>
<span class="p_header">index 12bd48925f4d..166064bafe2e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/sun4i/sun4i_tcon.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/sun4i/sun4i_tcon.h</span>
<span class="p_chunk">@@ -142,6 +142,11 @@</span> <span class="p_context"></span>
 
 #define SUN4I_TCON_MAX_CHANNELS		2
 
<span class="p_add">+struct sun4i_tcon_quirks {</span>
<span class="p_add">+	bool	has_unknown_mux; /* sun5i has undocumented mux */</span>
<span class="p_add">+	bool	has_channel_1;	/* a33 does not have channel 1 */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 struct sun4i_tcon {
 	struct device			*dev;
 	struct drm_device		*drm;
<span class="p_chunk">@@ -160,12 +165,10 @@</span> <span class="p_context"> struct sun4i_tcon {</span>
 	/* Reset control */
 	struct reset_control		*lcd_rst;
 
<span class="p_del">-	/* Platform adjustments */</span>
<span class="p_del">-	bool				has_mux;</span>
<span class="p_del">-</span>
 	struct drm_panel		*panel;
 
<span class="p_del">-	bool				has_channel_1;</span>
<span class="p_add">+	/* Platform adjustments */</span>
<span class="p_add">+	const struct sun4i_tcon_quirks	*quirks;</span>
 };
 
 struct drm_bridge *sun4i_tcon_find_bridge(struct device_node *node);
<span class="p_header">diff --git a/drivers/gpu/drm/ttm/ttm_object.c b/drivers/gpu/drm/ttm/ttm_object.c</span>
<span class="p_header">index 4f5fa8d65fe9..144367c0c28f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ttm/ttm_object.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ttm/ttm_object.c</span>
<span class="p_chunk">@@ -179,7 +179,7 @@</span> <span class="p_context"> int ttm_base_object_init(struct ttm_object_file *tfile,</span>
 	if (unlikely(ret != 0))
 		goto out_err0;
 
<span class="p_del">-	ret = ttm_ref_object_add(tfile, base, TTM_REF_USAGE, NULL);</span>
<span class="p_add">+	ret = ttm_ref_object_add(tfile, base, TTM_REF_USAGE, NULL, false);</span>
 	if (unlikely(ret != 0))
 		goto out_err1;
 
<span class="p_chunk">@@ -318,7 +318,8 @@</span> <span class="p_context"> EXPORT_SYMBOL(ttm_ref_object_exists);</span>
 
 int ttm_ref_object_add(struct ttm_object_file *tfile,
 		       struct ttm_base_object *base,
<span class="p_del">-		       enum ttm_ref_type ref_type, bool *existed)</span>
<span class="p_add">+		       enum ttm_ref_type ref_type, bool *existed,</span>
<span class="p_add">+		       bool require_existed)</span>
 {
 	struct drm_open_hash *ht = &amp;tfile-&gt;ref_hash[ref_type];
 	struct ttm_ref_object *ref;
<span class="p_chunk">@@ -345,6 +346,9 @@</span> <span class="p_context"> int ttm_ref_object_add(struct ttm_object_file *tfile,</span>
 		}
 
 		rcu_read_unlock();
<span class="p_add">+		if (require_existed)</span>
<span class="p_add">+			return -EPERM;</span>
<span class="p_add">+</span>
 		ret = ttm_mem_global_alloc(mem_glob, sizeof(*ref),
 					   false, false);
 		if (unlikely(ret != 0))
<span class="p_chunk">@@ -635,7 +639,7 @@</span> <span class="p_context"> int ttm_prime_fd_to_handle(struct ttm_object_file *tfile,</span>
 	prime = (struct ttm_prime_object *) dma_buf-&gt;priv;
 	base = &amp;prime-&gt;base;
 	*handle = base-&gt;hash.key;
<span class="p_del">-	ret = ttm_ref_object_add(tfile, base, TTM_REF_USAGE, NULL);</span>
<span class="p_add">+	ret = ttm_ref_object_add(tfile, base, TTM_REF_USAGE, NULL, false);</span>
 
 	dma_buf_put(dma_buf);
 
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c b/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c</span>
<span class="p_header">index 26ac8e80a478..967450da9742 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c</span>
<span class="p_chunk">@@ -538,7 +538,7 @@</span> <span class="p_context"> int vmw_fence_create(struct vmw_fence_manager *fman,</span>
 		     struct vmw_fence_obj **p_fence)
 {
 	struct vmw_fence_obj *fence;
<span class="p_del">-	int ret;</span>
<span class="p_add">+ 	int ret;</span>
 
 	fence = kzalloc(sizeof(*fence), GFP_KERNEL);
 	if (unlikely(fence == NULL))
<span class="p_chunk">@@ -701,6 +701,41 @@</span> <span class="p_context"> void vmw_fence_fifo_up(struct vmw_fence_manager *fman)</span>
 }
 
 
<span class="p_add">+/**</span>
<span class="p_add">+ * vmw_fence_obj_lookup - Look up a user-space fence object</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @tfile: A struct ttm_object_file identifying the caller.</span>
<span class="p_add">+ * @handle: A handle identifying the fence object.</span>
<span class="p_add">+ * @return: A struct vmw_user_fence base ttm object on success or</span>
<span class="p_add">+ * an error pointer on failure.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The fence object is looked up and type-checked. The caller needs</span>
<span class="p_add">+ * to have opened the fence object first, but since that happens on</span>
<span class="p_add">+ * creation and fence objects aren&#39;t shareable, that&#39;s not an</span>
<span class="p_add">+ * issue currently.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct ttm_base_object *</span>
<span class="p_add">+vmw_fence_obj_lookup(struct ttm_object_file *tfile, u32 handle)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ttm_base_object *base = ttm_base_object_lookup(tfile, handle);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!base) {</span>
<span class="p_add">+		pr_err(&quot;Invalid fence object handle 0x%08lx.\n&quot;,</span>
<span class="p_add">+		       (unsigned long)handle);</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (base-&gt;refcount_release != vmw_user_fence_base_release) {</span>
<span class="p_add">+		pr_err(&quot;Invalid fence object handle 0x%08lx.\n&quot;,</span>
<span class="p_add">+		       (unsigned long)handle);</span>
<span class="p_add">+		ttm_base_object_unref(&amp;base);</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return base;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 int vmw_fence_obj_wait_ioctl(struct drm_device *dev, void *data,
 			     struct drm_file *file_priv)
 {
<span class="p_chunk">@@ -726,13 +761,9 @@</span> <span class="p_context"> int vmw_fence_obj_wait_ioctl(struct drm_device *dev, void *data,</span>
 		arg-&gt;kernel_cookie = jiffies + wait_timeout;
 	}
 
<span class="p_del">-	base = ttm_base_object_lookup(tfile, arg-&gt;handle);</span>
<span class="p_del">-	if (unlikely(base == NULL)) {</span>
<span class="p_del">-		printk(KERN_ERR &quot;Wait invalid fence object handle &quot;</span>
<span class="p_del">-		       &quot;0x%08lx.\n&quot;,</span>
<span class="p_del">-		       (unsigned long)arg-&gt;handle);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	base = vmw_fence_obj_lookup(tfile, arg-&gt;handle);</span>
<span class="p_add">+	if (IS_ERR(base))</span>
<span class="p_add">+		return PTR_ERR(base);</span>
 
 	fence = &amp;(container_of(base, struct vmw_user_fence, base)-&gt;fence);
 
<span class="p_chunk">@@ -771,13 +802,9 @@</span> <span class="p_context"> int vmw_fence_obj_signaled_ioctl(struct drm_device *dev, void *data,</span>
 	struct ttm_object_file *tfile = vmw_fpriv(file_priv)-&gt;tfile;
 	struct vmw_private *dev_priv = vmw_priv(dev);
 
<span class="p_del">-	base = ttm_base_object_lookup(tfile, arg-&gt;handle);</span>
<span class="p_del">-	if (unlikely(base == NULL)) {</span>
<span class="p_del">-		printk(KERN_ERR &quot;Fence signaled invalid fence object handle &quot;</span>
<span class="p_del">-		       &quot;0x%08lx.\n&quot;,</span>
<span class="p_del">-		       (unsigned long)arg-&gt;handle);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	base = vmw_fence_obj_lookup(tfile, arg-&gt;handle);</span>
<span class="p_add">+	if (IS_ERR(base))</span>
<span class="p_add">+		return PTR_ERR(base);</span>
 
 	fence = &amp;(container_of(base, struct vmw_user_fence, base)-&gt;fence);
 	fman = fman_from_fence(fence);
<span class="p_chunk">@@ -1024,6 +1051,7 @@</span> <span class="p_context"> int vmw_fence_event_ioctl(struct drm_device *dev, void *data,</span>
 		(struct drm_vmw_fence_event_arg *) data;
 	struct vmw_fence_obj *fence = NULL;
 	struct vmw_fpriv *vmw_fp = vmw_fpriv(file_priv);
<span class="p_add">+	struct ttm_object_file *tfile = vmw_fp-&gt;tfile;</span>
 	struct drm_vmw_fence_rep __user *user_fence_rep =
 		(struct drm_vmw_fence_rep __user *)(unsigned long)
 		arg-&gt;fence_rep;
<span class="p_chunk">@@ -1037,24 +1065,18 @@</span> <span class="p_context"> int vmw_fence_event_ioctl(struct drm_device *dev, void *data,</span>
 	 */
 	if (arg-&gt;handle) {
 		struct ttm_base_object *base =
<span class="p_del">-			ttm_base_object_lookup_for_ref(dev_priv-&gt;tdev,</span>
<span class="p_del">-						       arg-&gt;handle);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (unlikely(base == NULL)) {</span>
<span class="p_del">-			DRM_ERROR(&quot;Fence event invalid fence object handle &quot;</span>
<span class="p_del">-				  &quot;0x%08lx.\n&quot;,</span>
<span class="p_del">-				  (unsigned long)arg-&gt;handle);</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_del">-		}</span>
<span class="p_add">+			vmw_fence_obj_lookup(tfile, arg-&gt;handle);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (IS_ERR(base))</span>
<span class="p_add">+			return PTR_ERR(base);</span>
<span class="p_add">+</span>
 		fence = &amp;(container_of(base, struct vmw_user_fence,
 				       base)-&gt;fence);
 		(void) vmw_fence_obj_reference(fence);
 
 		if (user_fence_rep != NULL) {
<span class="p_del">-			bool existed;</span>
<span class="p_del">-</span>
 			ret = ttm_ref_object_add(vmw_fp-&gt;tfile, base,
<span class="p_del">-						 TTM_REF_USAGE, &amp;existed);</span>
<span class="p_add">+						 TTM_REF_USAGE, NULL, false);</span>
 			if (unlikely(ret != 0)) {
 				DRM_ERROR(&quot;Failed to reference a fence &quot;
 					  &quot;object.\n&quot;);
<span class="p_chunk">@@ -1097,8 +1119,7 @@</span> <span class="p_context"> int vmw_fence_event_ioctl(struct drm_device *dev, void *data,</span>
 	return 0;
 out_no_create:
 	if (user_fence_rep != NULL)
<span class="p_del">-		ttm_ref_object_base_unref(vmw_fpriv(file_priv)-&gt;tfile,</span>
<span class="p_del">-					  handle, TTM_REF_USAGE);</span>
<span class="p_add">+		ttm_ref_object_base_unref(tfile, handle, TTM_REF_USAGE);</span>
 out_no_ref_obj:
 	vmw_fence_obj_unreference(&amp;fence);
 	return ret;
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c b/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c</span>
<span class="p_header">index b8c6a03c8c54..5ec24fd801cd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c</span>
<span class="p_chunk">@@ -114,8 +114,6 @@</span> <span class="p_context"> int vmw_getparam_ioctl(struct drm_device *dev, void *data,</span>
 		param-&gt;value = dev_priv-&gt;has_dx;
 		break;
 	default:
<span class="p_del">-		DRM_ERROR(&quot;Illegal vmwgfx get param request: %d\n&quot;,</span>
<span class="p_del">-			  param-&gt;param);</span>
 		return -EINVAL;
 	}
 
<span class="p_chunk">@@ -186,7 +184,7 @@</span> <span class="p_context"> int vmw_get_cap_3d_ioctl(struct drm_device *dev, void *data,</span>
 	bool gb_objects = !!(dev_priv-&gt;capabilities &amp; SVGA_CAP_GBOBJECTS);
 	struct vmw_fpriv *vmw_fp = vmw_fpriv(file_priv);
 
<span class="p_del">-	if (unlikely(arg-&gt;pad64 != 0)) {</span>
<span class="p_add">+	if (unlikely(arg-&gt;pad64 != 0 || arg-&gt;max_size == 0)) {</span>
 		DRM_ERROR(&quot;Illegal GET_3D_CAP argument.\n&quot;);
 		return -EINVAL;
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c b/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c</span>
<span class="p_header">index 52ca1c9d070e..bc354f7cf5d6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c</span>
<span class="p_chunk">@@ -589,7 +589,7 @@</span> <span class="p_context"> static int vmw_user_dmabuf_synccpu_grab(struct vmw_user_dma_buffer *user_bo,</span>
 		return ret;
 
 	ret = ttm_ref_object_add(tfile, &amp;user_bo-&gt;prime.base,
<span class="p_del">-				 TTM_REF_SYNCCPU_WRITE, &amp;existed);</span>
<span class="p_add">+				 TTM_REF_SYNCCPU_WRITE, &amp;existed, false);</span>
 	if (ret != 0 || existed)
 		ttm_bo_synccpu_write_release(&amp;user_bo-&gt;dma.base);
 
<span class="p_chunk">@@ -773,7 +773,7 @@</span> <span class="p_context"> int vmw_user_dmabuf_reference(struct ttm_object_file *tfile,</span>
 
 	*handle = user_bo-&gt;prime.base.hash.key;
 	return ttm_ref_object_add(tfile, &amp;user_bo-&gt;prime.base,
<span class="p_del">-				  TTM_REF_USAGE, NULL);</span>
<span class="p_add">+				  TTM_REF_USAGE, NULL, false);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c b/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c</span>
<span class="p_header">index b445ce9b9757..05fa092c942b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c</span>
<span class="p_chunk">@@ -713,11 +713,14 @@</span> <span class="p_context"> int vmw_surface_define_ioctl(struct drm_device *dev, void *data,</span>
 			128;
 
 	num_sizes = 0;
<span class="p_del">-	for (i = 0; i &lt; DRM_VMW_MAX_SURFACE_FACES; ++i)</span>
<span class="p_add">+	for (i = 0; i &lt; DRM_VMW_MAX_SURFACE_FACES; ++i) {</span>
<span class="p_add">+		if (req-&gt;mip_levels[i] &gt; DRM_VMW_MAX_MIP_LEVELS)</span>
<span class="p_add">+			return -EINVAL;</span>
 		num_sizes += req-&gt;mip_levels[i];
<span class="p_add">+	}</span>
 
<span class="p_del">-	if (num_sizes &gt; DRM_VMW_MAX_SURFACE_FACES *</span>
<span class="p_del">-	    DRM_VMW_MAX_MIP_LEVELS)</span>
<span class="p_add">+	if (num_sizes &gt; DRM_VMW_MAX_SURFACE_FACES * DRM_VMW_MAX_MIP_LEVELS ||</span>
<span class="p_add">+	    num_sizes == 0)</span>
 		return -EINVAL;
 
 	size = vmw_user_surface_size + 128 +
<span class="p_chunk">@@ -891,17 +894,16 @@</span> <span class="p_context"> vmw_surface_handle_reference(struct vmw_private *dev_priv,</span>
 	uint32_t handle;
 	struct ttm_base_object *base;
 	int ret;
<span class="p_add">+	bool require_exist = false;</span>
 
 	if (handle_type == DRM_VMW_HANDLE_PRIME) {
 		ret = ttm_prime_fd_to_handle(tfile, u_handle, &amp;handle);
 		if (unlikely(ret != 0))
 			return ret;
 	} else {
<span class="p_del">-		if (unlikely(drm_is_render_client(file_priv))) {</span>
<span class="p_del">-			DRM_ERROR(&quot;Render client refused legacy &quot;</span>
<span class="p_del">-				  &quot;surface reference.\n&quot;);</span>
<span class="p_del">-			return -EACCES;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (unlikely(drm_is_render_client(file_priv)))</span>
<span class="p_add">+			require_exist = true;</span>
<span class="p_add">+</span>
 		if (ACCESS_ONCE(vmw_fpriv(file_priv)-&gt;locked_master)) {
 			DRM_ERROR(&quot;Locked master refused legacy &quot;
 				  &quot;surface reference.\n&quot;);
<span class="p_chunk">@@ -929,17 +931,14 @@</span> <span class="p_context"> vmw_surface_handle_reference(struct vmw_private *dev_priv,</span>
 
 		/*
 		 * Make sure the surface creator has the same
<span class="p_del">-		 * authenticating master.</span>
<span class="p_add">+		 * authenticating master, or is already registered with us.</span>
 		 */
 		if (drm_is_primary_client(file_priv) &amp;&amp;
<span class="p_del">-		    user_srf-&gt;master != file_priv-&gt;master) {</span>
<span class="p_del">-			DRM_ERROR(&quot;Trying to reference surface outside of&quot;</span>
<span class="p_del">-				  &quot; master domain.\n&quot;);</span>
<span class="p_del">-			ret = -EACCES;</span>
<span class="p_del">-			goto out_bad_resource;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		    user_srf-&gt;master != file_priv-&gt;master)</span>
<span class="p_add">+			require_exist = true;</span>
 
<span class="p_del">-		ret = ttm_ref_object_add(tfile, base, TTM_REF_USAGE, NULL);</span>
<span class="p_add">+		ret = ttm_ref_object_add(tfile, base, TTM_REF_USAGE, NULL,</span>
<span class="p_add">+					 require_exist);</span>
 		if (unlikely(ret != 0)) {
 			DRM_ERROR(&quot;Could not add a reference to a surface.\n&quot;);
 			goto out_bad_resource;
<span class="p_header">diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c</span>
<span class="p_header">index 2b89c701076f..a5dd7e63ada3 100644</span>
<span class="p_header">--- a/drivers/hid/hid-core.c</span>
<span class="p_header">+++ b/drivers/hid/hid-core.c</span>
<span class="p_chunk">@@ -728,7 +728,6 @@</span> <span class="p_context"> static void hid_scan_collection(struct hid_parser *parser, unsigned type)</span>
 	     hid-&gt;product == USB_DEVICE_ID_MS_TYPE_COVER_PRO_3_2 ||
 	     hid-&gt;product == USB_DEVICE_ID_MS_TYPE_COVER_PRO_3_JP ||
 	     hid-&gt;product == USB_DEVICE_ID_MS_TYPE_COVER_PRO_4_JP ||
<span class="p_del">-	     hid-&gt;product == USB_DEVICE_ID_MS_TYPE_COVER_3 ||</span>
 	     hid-&gt;product == USB_DEVICE_ID_MS_POWER_COVER) &amp;&amp;
 	    hid-&gt;group == HID_GROUP_MULTITOUCH)
 		hid-&gt;group = HID_GROUP_GENERIC;
<span class="p_chunk">@@ -1984,7 +1983,6 @@</span> <span class="p_context"> static const struct hid_device_id hid_have_special_driver[] = {</span>
 	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_PRO_3_2) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_PRO_3_JP) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_PRO_4_JP) },
<span class="p_del">-	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_3) },</span>
 	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_DIGITAL_MEDIA_7K) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_DIGITAL_MEDIA_600) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_DIGITAL_MEDIA_3KV1) },
<span class="p_header">diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h</span>
<span class="p_header">index 9845189fae92..da9307701abe 100644</span>
<span class="p_header">--- a/drivers/hid/hid-ids.h</span>
<span class="p_header">+++ b/drivers/hid/hid-ids.h</span>
<span class="p_chunk">@@ -318,8 +318,11 @@</span> <span class="p_context"></span>
 #define USB_VENDOR_ID_DMI		0x0c0b
 #define USB_DEVICE_ID_DMI_ENC		0x5fab
 
<span class="p_del">-#define USB_VENDOR_ID_DRAGONRISE	0x0079</span>
<span class="p_del">-#define USB_DEVICE_ID_DRAGONRISE_WIIU	0x1800</span>
<span class="p_add">+#define USB_VENDOR_ID_DRAGONRISE		0x0079</span>
<span class="p_add">+#define USB_DEVICE_ID_DRAGONRISE_WIIU		0x1800</span>
<span class="p_add">+#define USB_DEVICE_ID_DRAGONRISE_PS3		0x1801</span>
<span class="p_add">+#define USB_DEVICE_ID_DRAGONRISE_DOLPHINBAR	0x1803</span>
<span class="p_add">+#define USB_DEVICE_ID_DRAGONRISE_GAMECUBE	0x1843</span>
 
 #define USB_VENDOR_ID_DWAV		0x0eef
 #define USB_DEVICE_ID_EGALAX_TOUCHCONTROLLER	0x0001
<span class="p_chunk">@@ -365,6 +368,9 @@</span> <span class="p_context"></span>
 #define USB_VENDOR_ID_FLATFROG		0x25b5
 #define USB_DEVICE_ID_MULTITOUCH_3200	0x0002
 
<span class="p_add">+#define USB_VENDOR_ID_FUTABA            0x0547</span>
<span class="p_add">+#define USB_DEVICE_ID_LED_DISPLAY       0x7000</span>
<span class="p_add">+</span>
 #define USB_VENDOR_ID_ESSENTIAL_REALITY	0x0d7f
 #define USB_DEVICE_ID_ESSENTIAL_REALITY_P5 0x0100
 
<span class="p_chunk">@@ -722,7 +728,6 @@</span> <span class="p_context"></span>
 #define USB_DEVICE_ID_MS_TYPE_COVER_PRO_3_2  0x07e2
 #define USB_DEVICE_ID_MS_TYPE_COVER_PRO_3_JP 0x07dd
 #define USB_DEVICE_ID_MS_TYPE_COVER_PRO_4_JP 0x07e9
<span class="p_del">-#define USB_DEVICE_ID_MS_TYPE_COVER_3    0x07de</span>
 #define USB_DEVICE_ID_MS_POWER_COVER     0x07da
 
 #define USB_VENDOR_ID_MOJO		0x8282
<span class="p_chunk">@@ -1037,6 +1042,10 @@</span> <span class="p_context"></span>
 #define USB_DEVICE_ID_WALTOP_MEDIA_TABLET_14_1_INCH	0x0500
 #define USB_DEVICE_ID_WALTOP_SIRIUS_BATTERY_FREE_TABLET	0x0502
 
<span class="p_add">+#define	USB_VENDOR_ID_WEIDA		0x2575</span>
<span class="p_add">+#define	USB_DEVICE_ID_WEIDA_8752	0xC300</span>
<span class="p_add">+#define	USB_DEVICE_ID_WEIDA_8755	0xC301</span>
<span class="p_add">+</span>
 #define USB_VENDOR_ID_WISEGROUP		0x0925
 #define USB_DEVICE_ID_SMARTJOY_PLUS	0x0005
 #define USB_DEVICE_ID_SUPER_JOY_BOX_3	0x8888
<span class="p_header">diff --git a/drivers/hid/hid-microsoft.c b/drivers/hid/hid-microsoft.c</span>
<span class="p_header">index c6cd392e9f99..ba02667beb80 100644</span>
<span class="p_header">--- a/drivers/hid/hid-microsoft.c</span>
<span class="p_header">+++ b/drivers/hid/hid-microsoft.c</span>
<span class="p_chunk">@@ -282,8 +282,6 @@</span> <span class="p_context"> static const struct hid_device_id ms_devices[] = {</span>
 		.driver_data = MS_HIDINPUT },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_PRO_4_JP),
 		.driver_data = MS_HIDINPUT },
<span class="p_del">-	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_3),</span>
<span class="p_del">-		.driver_data = MS_HIDINPUT },</span>
 	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_POWER_COVER),
 		.driver_data = MS_HIDINPUT },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_COMFORT_KEYBOARD),
<span class="p_header">diff --git a/drivers/hid/hid-multitouch.c b/drivers/hid/hid-multitouch.c</span>
<span class="p_header">index fb6f1f447279..89e9032ab1e7 100644</span>
<span class="p_header">--- a/drivers/hid/hid-multitouch.c</span>
<span class="p_header">+++ b/drivers/hid/hid-multitouch.c</span>
<span class="p_chunk">@@ -108,6 +108,7 @@</span> <span class="p_context"> struct mt_device {</span>
 	int cc_value_index;	/* contact count value index in the field */
 	unsigned last_slot_field;	/* the last field of a slot */
 	unsigned mt_report_id;	/* the report ID of the multitouch device */
<span class="p_add">+	unsigned long initial_quirks;	/* initial quirks state */</span>
 	__s16 inputmode;	/* InputMode HID feature, -1 if non-existent */
 	__s16 inputmode_index;	/* InputMode HID feature index in the report */
 	__s16 maxcontact_report_id;	/* Maximum Contact Number HID feature,
<span class="p_chunk">@@ -318,13 +319,10 @@</span> <span class="p_context"> static void mt_get_feature(struct hid_device *hdev, struct hid_report *report)</span>
 	u8 *buf;
 
 	/*
<span class="p_del">-	 * Only fetch the feature report if initial reports are not already</span>
<span class="p_del">-	 * been retrieved. Currently this is only done for Windows 8 touch</span>
<span class="p_del">-	 * devices.</span>
<span class="p_add">+	 * Do not fetch the feature report if the device has been explicitly</span>
<span class="p_add">+	 * marked as non-capable.</span>
 	 */
<span class="p_del">-	if (!(hdev-&gt;quirks &amp; HID_QUIRK_NO_INIT_REPORTS))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	if (td-&gt;mtclass.name != MT_CLS_WIN_8)</span>
<span class="p_add">+	if (td-&gt;initial_quirks &amp; HID_QUIRK_NO_INIT_REPORTS)</span>
 		return;
 
 	buf = hid_alloc_report_buf(report, GFP_KERNEL);
<span class="p_chunk">@@ -842,7 +840,9 @@</span> <span class="p_context"> static int mt_input_mapping(struct hid_device *hdev, struct hid_input *hi,</span>
 	if (!td-&gt;mtclass.export_all_inputs &amp;&amp;
 	    field-&gt;application != HID_DG_TOUCHSCREEN &amp;&amp;
 	    field-&gt;application != HID_DG_PEN &amp;&amp;
<span class="p_del">-	    field-&gt;application != HID_DG_TOUCHPAD)</span>
<span class="p_add">+	    field-&gt;application != HID_DG_TOUCHPAD &amp;&amp;</span>
<span class="p_add">+	    field-&gt;application != HID_GD_KEYBOARD &amp;&amp;</span>
<span class="p_add">+	    field-&gt;application != HID_CP_CONSUMER_CONTROL)</span>
 		return -1;
 
 	/*
<span class="p_chunk">@@ -1083,36 +1083,6 @@</span> <span class="p_context"> static int mt_probe(struct hid_device *hdev, const struct hid_device_id *id)</span>
 		}
 	}
 
<span class="p_del">-	/* This allows the driver to correctly support devices</span>
<span class="p_del">-	 * that emit events over several HID messages.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	hdev-&gt;quirks |= HID_QUIRK_NO_INPUT_SYNC;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * This allows the driver to handle different input sensors</span>
<span class="p_del">-	 * that emits events through different reports on the same HID</span>
<span class="p_del">-	 * device.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	hdev-&gt;quirks |= HID_QUIRK_MULTI_INPUT;</span>
<span class="p_del">-	hdev-&gt;quirks |= HID_QUIRK_NO_EMPTY_INPUT;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Handle special quirks for Windows 8 certified devices.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (id-&gt;group == HID_GROUP_MULTITOUCH_WIN_8)</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Some multitouch screens do not like to be polled for input</span>
<span class="p_del">-		 * reports. Fortunately, the Win8 spec says that all touches</span>
<span class="p_del">-		 * should be sent during each report, making the initialization</span>
<span class="p_del">-		 * of input reports unnecessary.</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * In addition some touchpads do not behave well if we read</span>
<span class="p_del">-		 * all feature reports from them. Instead we prevent</span>
<span class="p_del">-		 * initial report fetching and then selectively fetch each</span>
<span class="p_del">-		 * report we are interested in.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		hdev-&gt;quirks |= HID_QUIRK_NO_INIT_REPORTS;</span>
<span class="p_del">-</span>
 	td = devm_kzalloc(&amp;hdev-&gt;dev, sizeof(struct mt_device), GFP_KERNEL);
 	if (!td) {
 		dev_err(&amp;hdev-&gt;dev, &quot;cannot allocate multitouch data\n&quot;);
<span class="p_chunk">@@ -1136,6 +1106,39 @@</span> <span class="p_context"> static int mt_probe(struct hid_device *hdev, const struct hid_device_id *id)</span>
 	if (id-&gt;vendor == HID_ANY_ID &amp;&amp; id-&gt;product == HID_ANY_ID)
 		td-&gt;serial_maybe = true;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Store the initial quirk state</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	td-&gt;initial_quirks = hdev-&gt;quirks;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* This allows the driver to correctly support devices</span>
<span class="p_add">+	 * that emit events over several HID messages.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	hdev-&gt;quirks |= HID_QUIRK_NO_INPUT_SYNC;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This allows the driver to handle different input sensors</span>
<span class="p_add">+	 * that emits events through different reports on the same HID</span>
<span class="p_add">+	 * device.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	hdev-&gt;quirks |= HID_QUIRK_MULTI_INPUT;</span>
<span class="p_add">+	hdev-&gt;quirks |= HID_QUIRK_NO_EMPTY_INPUT;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Some multitouch screens do not like to be polled for input</span>
<span class="p_add">+	 * reports. Fortunately, the Win8 spec says that all touches</span>
<span class="p_add">+	 * should be sent during each report, making the initialization</span>
<span class="p_add">+	 * of input reports unnecessary. For Win7 devices, well, let&#39;s hope</span>
<span class="p_add">+	 * they will still be happy (this is only be a problem if a touch</span>
<span class="p_add">+	 * was already there while probing the device).</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * In addition some touchpads do not behave well if we read</span>
<span class="p_add">+	 * all feature reports from them. Instead we prevent</span>
<span class="p_add">+	 * initial report fetching and then selectively fetch each</span>
<span class="p_add">+	 * report we are interested in.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	hdev-&gt;quirks |= HID_QUIRK_NO_INIT_REPORTS;</span>
<span class="p_add">+</span>
 	ret = hid_parse(hdev);
 	if (ret != 0)
 		return ret;
<span class="p_chunk">@@ -1204,8 +1207,11 @@</span> <span class="p_context"> static int mt_resume(struct hid_device *hdev)</span>
 
 static void mt_remove(struct hid_device *hdev)
 {
<span class="p_add">+	struct mt_device *td = hid_get_drvdata(hdev);</span>
<span class="p_add">+</span>
 	sysfs_remove_group(&amp;hdev-&gt;dev.kobj, &amp;mt_attribute_group);
 	hid_hw_stop(hdev);
<span class="p_add">+	hdev-&gt;quirks = td-&gt;initial_quirks;</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/hid/hid-sensor-hub.c b/drivers/hid/hid-sensor-hub.c</span>
<span class="p_header">index 8f6c35370f66..4ef73374a8f9 100644</span>
<span class="p_header">--- a/drivers/hid/hid-sensor-hub.c</span>
<span class="p_header">+++ b/drivers/hid/hid-sensor-hub.c</span>
<span class="p_chunk">@@ -796,6 +796,12 @@</span> <span class="p_context"> static const struct hid_device_id sensor_hub_devices[] = {</span>
 	{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_SENSOR_HUB, USB_VENDOR_ID_MICROSOFT,
 			USB_DEVICE_ID_MS_TYPE_COVER_2),
 			.driver_data = HID_SENSOR_HUB_ENUM_QUIRK},
<span class="p_add">+	{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_SENSOR_HUB, USB_VENDOR_ID_MICROSOFT,</span>
<span class="p_add">+			0x07bd), /* Microsoft Surface 3 */</span>
<span class="p_add">+			.driver_data = HID_SENSOR_HUB_ENUM_QUIRK},</span>
<span class="p_add">+	{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_SENSOR_HUB, USB_VENDOR_ID_MICROCHIP,</span>
<span class="p_add">+			0x0f01), /* MM7150 */</span>
<span class="p_add">+			.driver_data = HID_SENSOR_HUB_ENUM_QUIRK},</span>
 	{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_SENSOR_HUB, USB_VENDOR_ID_STM_0,
 			USB_DEVICE_ID_STM_HID_SENSOR),
 			.driver_data = HID_SENSOR_HUB_ENUM_QUIRK},
<span class="p_header">diff --git a/drivers/hid/i2c-hid/i2c-hid.c b/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_header">index b3ec4f2de875..b1bce804fe97 100644</span>
<span class="p_header">--- a/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_header">+++ b/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_chunk">@@ -41,6 +41,11 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/i2c/i2c-hid.h&gt;
 
<span class="p_add">+#include &quot;../hid-ids.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+/* quirks to control the device */</span>
<span class="p_add">+#define I2C_HID_QUIRK_SET_PWR_WAKEUP_DEV	BIT(0)</span>
<span class="p_add">+</span>
 /* flags */
 #define I2C_HID_STARTED		0
 #define I2C_HID_RESET_PENDING	1
<span class="p_chunk">@@ -143,6 +148,7 @@</span> <span class="p_context"> struct i2c_hid {</span>
 	char			*argsbuf;	/* Command arguments buffer */
 
 	unsigned long		flags;		/* device flags */
<span class="p_add">+	unsigned long		quirks;		/* Various quirks */</span>
 
 	wait_queue_head_t	wait;		/* For waiting the interrupt */
 	struct gpio_desc	*desc;
<span class="p_chunk">@@ -154,6 +160,39 @@</span> <span class="p_context"> struct i2c_hid {</span>
 	struct mutex		reset_lock;
 };
 
<span class="p_add">+static const struct i2c_hid_quirks {</span>
<span class="p_add">+	__u16 idVendor;</span>
<span class="p_add">+	__u16 idProduct;</span>
<span class="p_add">+	__u32 quirks;</span>
<span class="p_add">+} i2c_hid_quirks[] = {</span>
<span class="p_add">+	{ USB_VENDOR_ID_WEIDA, USB_DEVICE_ID_WEIDA_8752,</span>
<span class="p_add">+		I2C_HID_QUIRK_SET_PWR_WAKEUP_DEV },</span>
<span class="p_add">+	{ USB_VENDOR_ID_WEIDA, USB_DEVICE_ID_WEIDA_8755,</span>
<span class="p_add">+		I2C_HID_QUIRK_SET_PWR_WAKEUP_DEV },</span>
<span class="p_add">+	{ 0, 0 }</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * i2c_hid_lookup_quirk: return any quirks associated with a I2C HID device</span>
<span class="p_add">+ * @idVendor: the 16-bit vendor ID</span>
<span class="p_add">+ * @idProduct: the 16-bit product ID</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns: a u32 quirks value.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static u32 i2c_hid_lookup_quirk(const u16 idVendor, const u16 idProduct)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 quirks = 0;</span>
<span class="p_add">+	int n;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (n = 0; i2c_hid_quirks[n].idVendor; n++)</span>
<span class="p_add">+		if (i2c_hid_quirks[n].idVendor == idVendor &amp;&amp;</span>
<span class="p_add">+		    (i2c_hid_quirks[n].idProduct == (__u16)HID_ANY_ID ||</span>
<span class="p_add">+		     i2c_hid_quirks[n].idProduct == idProduct))</span>
<span class="p_add">+			quirks = i2c_hid_quirks[n].quirks;</span>
<span class="p_add">+</span>
<span class="p_add">+	return quirks;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int __i2c_hid_command(struct i2c_client *client,
 		const struct i2c_hid_cmd *command, u8 reportID,
 		u8 reportType, u8 *args, int args_len,
<span class="p_chunk">@@ -346,11 +385,27 @@</span> <span class="p_context"> static int i2c_hid_set_power(struct i2c_client *client, int power_state)</span>
 
 	i2c_hid_dbg(ihid, &quot;%s\n&quot;, __func__);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Some devices require to send a command to wakeup before power on.</span>
<span class="p_add">+	 * The call will get a return value (EREMOTEIO) but device will be</span>
<span class="p_add">+	 * triggered and activated. After that, it goes like a normal device.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (power_state == I2C_HID_PWR_ON &amp;&amp;</span>
<span class="p_add">+	    ihid-&gt;quirks &amp; I2C_HID_QUIRK_SET_PWR_WAKEUP_DEV) {</span>
<span class="p_add">+		ret = i2c_hid_command(client, &amp;hid_set_power_cmd, NULL, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Device was already activated */</span>
<span class="p_add">+		if (!ret)</span>
<span class="p_add">+			goto set_pwr_exit;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ret = __i2c_hid_command(client, &amp;hid_set_power_cmd, power_state,
 		0, NULL, 0, NULL, 0);
<span class="p_add">+</span>
 	if (ret)
 		dev_err(&amp;client-&gt;dev, &quot;failed to change power setting.\n&quot;);
 
<span class="p_add">+set_pwr_exit:</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -1050,6 +1105,8 @@</span> <span class="p_context"> static int i2c_hid_probe(struct i2c_client *client,</span>
 		 client-&gt;name, hid-&gt;vendor, hid-&gt;product);
 	strlcpy(hid-&gt;phys, dev_name(&amp;client-&gt;dev), sizeof(hid-&gt;phys));
 
<span class="p_add">+	ihid-&gt;quirks = i2c_hid_lookup_quirk(hid-&gt;vendor, hid-&gt;product);</span>
<span class="p_add">+</span>
 	ret = hid_add_device(hid);
 	if (ret) {
 		if (ret != -ENODEV)
<span class="p_header">diff --git a/drivers/hid/usbhid/hid-quirks.c b/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_header">index cde060fefa91..97dbb2562ace 100644</span>
<span class="p_header">--- a/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_header">+++ b/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_chunk">@@ -83,10 +83,14 @@</span> <span class="p_context"> static const struct hid_blacklist {</span>
 	{ USB_VENDOR_ID_CREATIVELABS, USB_DEVICE_ID_CREATIVE_SB_OMNI_SURROUND_51, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_DMI, USB_DEVICE_ID_DMI_ENC, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_DRAGONRISE, USB_DEVICE_ID_DRAGONRISE_WIIU, HID_QUIRK_MULTI_INPUT },
<span class="p_add">+	{ USB_VENDOR_ID_DRAGONRISE, USB_DEVICE_ID_DRAGONRISE_PS3, HID_QUIRK_MULTI_INPUT },</span>
<span class="p_add">+	{ USB_VENDOR_ID_DRAGONRISE, USB_DEVICE_ID_DRAGONRISE_DOLPHINBAR, HID_QUIRK_MULTI_INPUT },</span>
<span class="p_add">+	{ USB_VENDOR_ID_DRAGONRISE, USB_DEVICE_ID_DRAGONRISE_GAMECUBE, HID_QUIRK_MULTI_INPUT },</span>
 	{ USB_VENDOR_ID_ELAN, HID_ANY_ID, HID_QUIRK_ALWAYS_POLL },
 	{ USB_VENDOR_ID_ELO, USB_DEVICE_ID_ELO_TS2700, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_FORMOSA, USB_DEVICE_ID_FORMOSA_IR_RECEIVER, HID_QUIRK_NO_INIT_REPORTS },
 	{ USB_VENDOR_ID_FREESCALE, USB_DEVICE_ID_FREESCALE_MX28, HID_QUIRK_NOGET },
<span class="p_add">+	{ USB_VENDOR_ID_FUTABA, USB_DEVICE_ID_LED_DISPLAY, HID_QUIRK_NO_INIT_REPORTS },</span>
 	{ USB_VENDOR_ID_HP, USB_PRODUCT_ID_HP_LOGITECH_OEM_USB_OPTICAL_MOUSE_0A4A, HID_QUIRK_ALWAYS_POLL },
 	{ USB_VENDOR_ID_HP, USB_PRODUCT_ID_HP_LOGITECH_OEM_USB_OPTICAL_MOUSE_0B4A, HID_QUIRK_ALWAYS_POLL },
 	{ USB_VENDOR_ID_HP, USB_PRODUCT_ID_HP_PIXART_OEM_USB_OPTICAL_MOUSE, HID_QUIRK_ALWAYS_POLL },
<span class="p_chunk">@@ -103,7 +107,6 @@</span> <span class="p_context"> static const struct hid_blacklist {</span>
 	{ USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_PRO_3_2, HID_QUIRK_NO_INIT_REPORTS },
 	{ USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_PRO_3_JP, HID_QUIRK_NO_INIT_REPORTS },
 	{ USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_PRO_4_JP, HID_QUIRK_NO_INIT_REPORTS },
<span class="p_del">-	{ USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_3, HID_QUIRK_NO_INIT_REPORTS },</span>
 	{ USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_POWER_COVER, HID_QUIRK_NO_INIT_REPORTS },
 	{ USB_VENDOR_ID_MSI, USB_DEVICE_ID_MSI_GT683R_LED_PANEL, HID_QUIRK_NO_INIT_REPORTS },
 	{ USB_VENDOR_ID_NEXIO, USB_DEVICE_ID_NEXIO_MULTITOUCH_PTI0750, HID_QUIRK_NO_INIT_REPORTS },
<span class="p_header">diff --git a/drivers/hid/wacom_wac.c b/drivers/hid/wacom_wac.c</span>
<span class="p_header">index 623be90704ab..0e07a769df7c 100644</span>
<span class="p_header">--- a/drivers/hid/wacom_wac.c</span>
<span class="p_header">+++ b/drivers/hid/wacom_wac.c</span>
<span class="p_chunk">@@ -2896,6 +2896,9 @@</span> <span class="p_context"> int wacom_setup_pad_input_capabilities(struct input_dev *input_dev,</span>
 {
 	struct wacom_features *features = &amp;wacom_wac-&gt;features;
 
<span class="p_add">+	if ((features-&gt;type == HID_GENERIC) &amp;&amp; features-&gt;numbered_buttons &gt; 0)</span>
<span class="p_add">+		features-&gt;device_type |= WACOM_DEVICETYPE_PAD;</span>
<span class="p_add">+</span>
 	if (!(features-&gt;device_type &amp; WACOM_DEVICETYPE_PAD))
 		return -ENODEV;
 
<span class="p_header">diff --git a/drivers/idle/intel_idle.c b/drivers/idle/intel_idle.c</span>
<span class="p_header">index 4466a2f969d7..5ded9b22b015 100644</span>
<span class="p_header">--- a/drivers/idle/intel_idle.c</span>
<span class="p_header">+++ b/drivers/idle/intel_idle.c</span>
<span class="p_chunk">@@ -724,6 +724,50 @@</span> <span class="p_context"> static struct cpuidle_state atom_cstates[] = {</span>
 	{
 		.enter = NULL }
 };
<span class="p_add">+static struct cpuidle_state tangier_cstates[] = {</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.name = &quot;C1-TNG&quot;,</span>
<span class="p_add">+		.desc = &quot;MWAIT 0x00&quot;,</span>
<span class="p_add">+		.flags = MWAIT2flg(0x00),</span>
<span class="p_add">+		.exit_latency = 1,</span>
<span class="p_add">+		.target_residency = 4,</span>
<span class="p_add">+		.enter = &amp;intel_idle,</span>
<span class="p_add">+		.enter_freeze = intel_idle_freeze, },</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.name = &quot;C4-TNG&quot;,</span>
<span class="p_add">+		.desc = &quot;MWAIT 0x30&quot;,</span>
<span class="p_add">+		.flags = MWAIT2flg(0x30) | CPUIDLE_FLAG_TLB_FLUSHED,</span>
<span class="p_add">+		.exit_latency = 100,</span>
<span class="p_add">+		.target_residency = 400,</span>
<span class="p_add">+		.enter = &amp;intel_idle,</span>
<span class="p_add">+		.enter_freeze = intel_idle_freeze, },</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.name = &quot;C6-TNG&quot;,</span>
<span class="p_add">+		.desc = &quot;MWAIT 0x52&quot;,</span>
<span class="p_add">+		.flags = MWAIT2flg(0x52) | CPUIDLE_FLAG_TLB_FLUSHED,</span>
<span class="p_add">+		.exit_latency = 140,</span>
<span class="p_add">+		.target_residency = 560,</span>
<span class="p_add">+		.enter = &amp;intel_idle,</span>
<span class="p_add">+		.enter_freeze = intel_idle_freeze, },</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.name = &quot;C7-TNG&quot;,</span>
<span class="p_add">+		.desc = &quot;MWAIT 0x60&quot;,</span>
<span class="p_add">+		.flags = MWAIT2flg(0x60) | CPUIDLE_FLAG_TLB_FLUSHED,</span>
<span class="p_add">+		.exit_latency = 1200,</span>
<span class="p_add">+		.target_residency = 4000,</span>
<span class="p_add">+		.enter = &amp;intel_idle,</span>
<span class="p_add">+		.enter_freeze = intel_idle_freeze, },</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.name = &quot;C9-TNG&quot;,</span>
<span class="p_add">+		.desc = &quot;MWAIT 0x64&quot;,</span>
<span class="p_add">+		.flags = MWAIT2flg(0x64) | CPUIDLE_FLAG_TLB_FLUSHED,</span>
<span class="p_add">+		.exit_latency = 10000,</span>
<span class="p_add">+		.target_residency = 20000,</span>
<span class="p_add">+		.enter = &amp;intel_idle,</span>
<span class="p_add">+		.enter_freeze = intel_idle_freeze, },</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.enter = NULL }</span>
<span class="p_add">+};</span>
 static struct cpuidle_state avn_cstates[] = {
 	{
 		.name = &quot;C1-AVN&quot;,
<span class="p_chunk">@@ -978,6 +1022,10 @@</span> <span class="p_context"> static const struct idle_cpu idle_cpu_atom = {</span>
 	.state_table = atom_cstates,
 };
 
<span class="p_add">+static const struct idle_cpu idle_cpu_tangier = {</span>
<span class="p_add">+	.state_table = tangier_cstates,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct idle_cpu idle_cpu_lincroft = {
 	.state_table = atom_cstates,
 	.auto_demotion_disable_flags = ATM_LNC_C6_AUTO_DEMOTE,
<span class="p_chunk">@@ -1066,6 +1114,7 @@</span> <span class="p_context"> static const struct x86_cpu_id intel_idle_ids[] __initconst = {</span>
 	ICPU(INTEL_FAM6_SANDYBRIDGE_X,		idle_cpu_snb),
 	ICPU(INTEL_FAM6_ATOM_CEDARVIEW,		idle_cpu_atom),
 	ICPU(INTEL_FAM6_ATOM_SILVERMONT1,	idle_cpu_byt),
<span class="p_add">+	ICPU(INTEL_FAM6_ATOM_MERRIFIELD,	idle_cpu_tangier),</span>
 	ICPU(INTEL_FAM6_ATOM_AIRMONT,		idle_cpu_cht),
 	ICPU(INTEL_FAM6_IVYBRIDGE,		idle_cpu_ivb),
 	ICPU(INTEL_FAM6_IVYBRIDGE_X,		idle_cpu_ivt),
<span class="p_header">diff --git a/drivers/iio/gyro/bmg160_core.c b/drivers/iio/gyro/bmg160_core.c</span>
<span class="p_header">index f7fcfa886f72..821919dd245b 100644</span>
<span class="p_header">--- a/drivers/iio/gyro/bmg160_core.c</span>
<span class="p_header">+++ b/drivers/iio/gyro/bmg160_core.c</span>
<span class="p_chunk">@@ -27,6 +27,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/iio/trigger_consumer.h&gt;
 #include &lt;linux/iio/triggered_buffer.h&gt;
 #include &lt;linux/regmap.h&gt;
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
 #include &quot;bmg160.h&quot;
 
 #define BMG160_IRQ_NAME		&quot;bmg160_event&quot;
<span class="p_chunk">@@ -52,6 +53,9 @@</span> <span class="p_context"></span>
 #define BMG160_DEF_BW			100
 #define BMG160_REG_PMU_BW_RES		BIT(7)
 
<span class="p_add">+#define BMG160_GYRO_REG_RESET		0x14</span>
<span class="p_add">+#define BMG160_GYRO_RESET_VAL		0xb6</span>
<span class="p_add">+</span>
 #define BMG160_REG_INT_MAP_0		0x17
 #define BMG160_INT_MAP_0_BIT_ANY	BIT(1)
 
<span class="p_chunk">@@ -236,6 +240,14 @@</span> <span class="p_context"> static int bmg160_chip_init(struct bmg160_data *data)</span>
 	int ret;
 	unsigned int val;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Reset chip to get it in a known good state. A delay of 30ms after</span>
<span class="p_add">+	 * reset is required according to the datasheet.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	regmap_write(data-&gt;regmap, BMG160_GYRO_REG_RESET,</span>
<span class="p_add">+		     BMG160_GYRO_RESET_VAL);</span>
<span class="p_add">+	usleep_range(30000, 30700);</span>
<span class="p_add">+</span>
 	ret = regmap_read(data-&gt;regmap, BMG160_REG_CHIP_ID, &amp;val);
 	if (ret &lt; 0) {
 		dev_err(dev, &quot;Error reading reg_chip_id\n&quot;);
<span class="p_header">diff --git a/drivers/input/keyboard/gpio_keys.c b/drivers/input/keyboard/gpio_keys.c</span>
<span class="p_header">index 29093657f2ef..9b8079ca0fb4 100644</span>
<span class="p_header">--- a/drivers/input/keyboard/gpio_keys.c</span>
<span class="p_header">+++ b/drivers/input/keyboard/gpio_keys.c</span>
<span class="p_chunk">@@ -26,6 +26,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/gpio_keys.h&gt;
 #include &lt;linux/workqueue.h&gt;
 #include &lt;linux/gpio.h&gt;
<span class="p_add">+#include &lt;linux/gpio/consumer.h&gt;</span>
 #include &lt;linux/of.h&gt;
 #include &lt;linux/of_platform.h&gt;
 #include &lt;linux/of_gpio.h&gt;
<span class="p_chunk">@@ -35,6 +36,7 @@</span> <span class="p_context"></span>
 struct gpio_button_data {
 	const struct gpio_keys_button *button;
 	struct input_dev *input;
<span class="p_add">+	struct gpio_desc *gpiod;</span>
 
 	struct timer_list release_timer;
 	unsigned int release_delay;	/* in msecs, for IRQ-only buttons */
<span class="p_chunk">@@ -140,7 +142,7 @@</span> <span class="p_context"> static void gpio_keys_disable_button(struct gpio_button_data *bdata)</span>
 		 */
 		disable_irq(bdata-&gt;irq);
 
<span class="p_del">-		if (gpio_is_valid(bdata-&gt;button-&gt;gpio))</span>
<span class="p_add">+		if (bdata-&gt;gpiod)</span>
 			cancel_delayed_work_sync(&amp;bdata-&gt;work);
 		else
 			del_timer_sync(&amp;bdata-&gt;release_timer);
<span class="p_chunk">@@ -358,19 +360,20 @@</span> <span class="p_context"> static void gpio_keys_gpio_report_event(struct gpio_button_data *bdata)</span>
 	const struct gpio_keys_button *button = bdata-&gt;button;
 	struct input_dev *input = bdata-&gt;input;
 	unsigned int type = button-&gt;type ?: EV_KEY;
<span class="p_del">-	int state = gpio_get_value_cansleep(button-&gt;gpio);</span>
<span class="p_add">+	int state;</span>
 
<span class="p_add">+	state = gpiod_get_value_cansleep(bdata-&gt;gpiod);</span>
 	if (state &lt; 0) {
<span class="p_del">-		dev_err(input-&gt;dev.parent, &quot;failed to get gpio state\n&quot;);</span>
<span class="p_add">+		dev_err(input-&gt;dev.parent,</span>
<span class="p_add">+			&quot;failed to get gpio state: %d\n&quot;, state);</span>
 		return;
 	}
 
<span class="p_del">-	state = (state ? 1 : 0) ^ button-&gt;active_low;</span>
 	if (type == EV_ABS) {
 		if (state)
 			input_event(input, type, button-&gt;code, button-&gt;value);
 	} else {
<span class="p_del">-		input_event(input, type, button-&gt;code, !!state);</span>
<span class="p_add">+		input_event(input, type, button-&gt;code, state);</span>
 	}
 	input_sync(input);
 }
<span class="p_chunk">@@ -456,7 +459,7 @@</span> <span class="p_context"> static void gpio_keys_quiesce_key(void *data)</span>
 {
 	struct gpio_button_data *bdata = data;
 
<span class="p_del">-	if (gpio_is_valid(bdata-&gt;button-&gt;gpio))</span>
<span class="p_add">+	if (bdata-&gt;gpiod)</span>
 		cancel_delayed_work_sync(&amp;bdata-&gt;work);
 	else
 		del_timer_sync(&amp;bdata-&gt;release_timer);
<span class="p_chunk">@@ -478,18 +481,30 @@</span> <span class="p_context"> static int gpio_keys_setup_key(struct platform_device *pdev,</span>
 	bdata-&gt;button = button;
 	spin_lock_init(&amp;bdata-&gt;lock);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Legacy GPIO number, so request the GPIO here and</span>
<span class="p_add">+	 * convert it to descriptor.</span>
<span class="p_add">+	 */</span>
 	if (gpio_is_valid(button-&gt;gpio)) {
<span class="p_add">+		unsigned flags = GPIOF_IN;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (button-&gt;active_low)</span>
<span class="p_add">+			flags |= GPIOF_ACTIVE_LOW;</span>
 
<span class="p_del">-		error = devm_gpio_request_one(&amp;pdev-&gt;dev, button-&gt;gpio,</span>
<span class="p_del">-					      GPIOF_IN, desc);</span>
<span class="p_add">+		error = devm_gpio_request_one(&amp;pdev-&gt;dev, button-&gt;gpio, flags,</span>
<span class="p_add">+					      desc);</span>
 		if (error &lt; 0) {
 			dev_err(dev, &quot;Failed to request GPIO %d, error %d\n&quot;,
 				button-&gt;gpio, error);
 			return error;
 		}
 
<span class="p_add">+		bdata-&gt;gpiod = gpio_to_desc(button-&gt;gpio);</span>
<span class="p_add">+		if (!bdata-&gt;gpiod)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
 		if (button-&gt;debounce_interval) {
<span class="p_del">-			error = gpio_set_debounce(button-&gt;gpio,</span>
<span class="p_add">+			error = gpiod_set_debounce(bdata-&gt;gpiod,</span>
 					button-&gt;debounce_interval * 1000);
 			/* use timer if gpiolib doesn&#39;t provide debounce */
 			if (error &lt; 0)
<span class="p_chunk">@@ -500,7 +515,7 @@</span> <span class="p_context"> static int gpio_keys_setup_key(struct platform_device *pdev,</span>
 		if (button-&gt;irq) {
 			bdata-&gt;irq = button-&gt;irq;
 		} else {
<span class="p_del">-			irq = gpio_to_irq(button-&gt;gpio);</span>
<span class="p_add">+			irq = gpiod_to_irq(bdata-&gt;gpiod);</span>
 			if (irq &lt; 0) {
 				error = irq;
 				dev_err(dev,
<span class="p_chunk">@@ -575,7 +590,7 @@</span> <span class="p_context"> static void gpio_keys_report_state(struct gpio_keys_drvdata *ddata)</span>
 
 	for (i = 0; i &lt; ddata-&gt;pdata-&gt;nbuttons; i++) {
 		struct gpio_button_data *bdata = &amp;ddata-&gt;data[i];
<span class="p_del">-		if (gpio_is_valid(bdata-&gt;button-&gt;gpio))</span>
<span class="p_add">+		if (bdata-&gt;gpiod)</span>
 			gpio_keys_gpio_report_event(bdata);
 	}
 	input_sync(input);
<span class="p_header">diff --git a/drivers/md/dm-raid.c b/drivers/md/dm-raid.c</span>
<span class="p_header">index 15daa36fcea6..ee75e3510be6 100644</span>
<span class="p_header">--- a/drivers/md/dm-raid.c</span>
<span class="p_header">+++ b/drivers/md/dm-raid.c</span>
<span class="p_chunk">@@ -3589,7 +3589,7 @@</span> <span class="p_context"> static int raid_preresume(struct dm_target *ti)</span>
 		return r;
 
 	/* Resize bitmap to adjust to changed region size (aka MD bitmap chunksize) */
<span class="p_del">-	if (test_bit(RT_FLAG_RS_BITMAP_LOADED, &amp;rs-&gt;runtime_flags) &amp;&amp;</span>
<span class="p_add">+	if (test_bit(RT_FLAG_RS_BITMAP_LOADED, &amp;rs-&gt;runtime_flags) &amp;&amp; mddev-&gt;bitmap &amp;&amp;</span>
 	    mddev-&gt;bitmap_info.chunksize != to_bytes(rs-&gt;requested_bitmap_chunk_sectors)) {
 		r = bitmap_resize(mddev-&gt;bitmap, mddev-&gt;dev_sectors,
 				  to_bytes(rs-&gt;requested_bitmap_chunk_sectors), 0);
<span class="p_header">diff --git a/drivers/md/dm-verity-fec.c b/drivers/md/dm-verity-fec.c</span>
<span class="p_header">index 0f0eb8a3d922..78f36012eaca 100644</span>
<span class="p_header">--- a/drivers/md/dm-verity-fec.c</span>
<span class="p_header">+++ b/drivers/md/dm-verity-fec.c</span>
<span class="p_chunk">@@ -146,8 +146,6 @@</span> <span class="p_context"> static int fec_decode_bufs(struct dm_verity *v, struct dm_verity_fec_io *fio,</span>
 		block = fec_buffer_rs_block(v, fio, n, i);
 		res = fec_decode_rs8(v, fio, block, &amp;par[offset], neras);
 		if (res &lt; 0) {
<span class="p_del">-			dm_bufio_release(buf);</span>
<span class="p_del">-</span>
 			r = res;
 			goto error;
 		}
<span class="p_chunk">@@ -172,6 +170,8 @@</span> <span class="p_context"> static int fec_decode_bufs(struct dm_verity *v, struct dm_verity_fec_io *fio,</span>
 done:
 	r = corrected;
 error:
<span class="p_add">+	dm_bufio_release(buf);</span>
<span class="p_add">+</span>
 	if (r &lt; 0 &amp;&amp; neras)
 		DMERR_LIMIT(&quot;%s: FEC %llu: failed to correct: %d&quot;,
 			    v-&gt;data_dev-&gt;name, (unsigned long long)rsb, r);
<span class="p_chunk">@@ -269,7 +269,7 @@</span> <span class="p_context"> static int fec_read_bufs(struct dm_verity *v, struct dm_verity_io *io,</span>
 					  &amp;is_zero) == 0) {
 			/* skip known zero blocks entirely */
 			if (is_zero)
<span class="p_del">-				continue;</span>
<span class="p_add">+				goto done;</span>
 
 			/*
 			 * skip if we have already found the theoretical
<span class="p_chunk">@@ -439,6 +439,13 @@</span> <span class="p_context"> int verity_fec_decode(struct dm_verity *v, struct dm_verity_io *io,</span>
 	if (!verity_fec_is_enabled(v))
 		return -EOPNOTSUPP;
 
<span class="p_add">+	if (fio-&gt;level &gt;= DM_VERITY_FEC_MAX_RECURSION) {</span>
<span class="p_add">+		DMWARN_LIMIT(&quot;%s: FEC: recursion too deep&quot;, v-&gt;data_dev-&gt;name);</span>
<span class="p_add">+		return -EIO;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	fio-&gt;level++;</span>
<span class="p_add">+</span>
 	if (type == DM_VERITY_BLOCK_TYPE_METADATA)
 		block += v-&gt;data_blocks;
 
<span class="p_chunk">@@ -470,7 +477,7 @@</span> <span class="p_context"> int verity_fec_decode(struct dm_verity *v, struct dm_verity_io *io,</span>
 	if (r &lt; 0) {
 		r = fec_decode_rsb(v, io, fio, rsb, offset, true);
 		if (r &lt; 0)
<span class="p_del">-			return r;</span>
<span class="p_add">+			goto done;</span>
 	}
 
 	if (dest)
<span class="p_chunk">@@ -480,6 +487,8 @@</span> <span class="p_context"> int verity_fec_decode(struct dm_verity *v, struct dm_verity_io *io,</span>
 		r = verity_for_bv_block(v, io, iter, fec_bv_copy);
 	}
 
<span class="p_add">+done:</span>
<span class="p_add">+	fio-&gt;level--;</span>
 	return r;
 }
 
<span class="p_chunk">@@ -520,6 +529,7 @@</span> <span class="p_context"> void verity_fec_init_io(struct dm_verity_io *io)</span>
 	memset(fio-&gt;bufs, 0, sizeof(fio-&gt;bufs));
 	fio-&gt;nbufs = 0;
 	fio-&gt;output = NULL;
<span class="p_add">+	fio-&gt;level = 0;</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/md/dm-verity-fec.h b/drivers/md/dm-verity-fec.h</span>
<span class="p_header">index 7fa0298b995e..bb31ce87a933 100644</span>
<span class="p_header">--- a/drivers/md/dm-verity-fec.h</span>
<span class="p_header">+++ b/drivers/md/dm-verity-fec.h</span>
<span class="p_chunk">@@ -27,6 +27,9 @@</span> <span class="p_context"></span>
 #define DM_VERITY_FEC_BUF_MAX \
 	(1 &lt;&lt; (PAGE_SHIFT - DM_VERITY_FEC_BUF_RS_BITS))
 
<span class="p_add">+/* maximum recursion level for verity_fec_decode */</span>
<span class="p_add">+#define DM_VERITY_FEC_MAX_RECURSION	4</span>
<span class="p_add">+</span>
 #define DM_VERITY_OPT_FEC_DEV		&quot;use_fec_from_device&quot;
 #define DM_VERITY_OPT_FEC_BLOCKS	&quot;fec_blocks&quot;
 #define DM_VERITY_OPT_FEC_START		&quot;fec_start&quot;
<span class="p_chunk">@@ -58,6 +61,7 @@</span> <span class="p_context"> struct dm_verity_fec_io {</span>
 	unsigned nbufs;		/* number of buffers allocated */
 	u8 *output;		/* buffer for corrected output */
 	size_t output_pos;
<span class="p_add">+	unsigned level;		/* recursion level */</span>
 };
 
 #ifdef CONFIG_DM_VERITY_FEC
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-msm.c b/drivers/mmc/host/sdhci-msm.c</span>
<span class="p_header">index 90ed2e12d345..437e4807727d 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-msm.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-msm.c</span>
<span class="p_chunk">@@ -524,7 +524,9 @@</span> <span class="p_context"> static const struct sdhci_ops sdhci_msm_ops = {</span>
 static const struct sdhci_pltfm_data sdhci_msm_pdata = {
 	.quirks = SDHCI_QUIRK_BROKEN_CARD_DETECTION |
 		  SDHCI_QUIRK_NO_CARD_NO_RESET |
<span class="p_del">-		  SDHCI_QUIRK_SINGLE_POWER_WRITE,</span>
<span class="p_add">+		  SDHCI_QUIRK_SINGLE_POWER_WRITE |</span>
<span class="p_add">+		  SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,</span>
<span class="p_add">+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,</span>
 	.ops = &amp;sdhci_msm_ops,
 };
 
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-of-esdhc.c b/drivers/mmc/host/sdhci-of-esdhc.c</span>
<span class="p_header">index 1bb11e4a9fe5..3c27401cf7fe 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-of-esdhc.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-of-esdhc.c</span>
<span class="p_chunk">@@ -559,16 +559,19 @@</span> <span class="p_context"> static const struct sdhci_ops sdhci_esdhc_le_ops = {</span>
 };
 
 static const struct sdhci_pltfm_data sdhci_esdhc_be_pdata = {
<span class="p_del">-	.quirks = ESDHC_DEFAULT_QUIRKS | SDHCI_QUIRK_BROKEN_CARD_DETECTION</span>
<span class="p_del">-		| SDHCI_QUIRK_NO_CARD_NO_RESET</span>
<span class="p_del">-		| SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,</span>
<span class="p_add">+	.quirks = ESDHC_DEFAULT_QUIRKS |</span>
<span class="p_add">+#ifdef CONFIG_PPC</span>
<span class="p_add">+		  SDHCI_QUIRK_BROKEN_CARD_DETECTION |</span>
<span class="p_add">+#endif</span>
<span class="p_add">+		  SDHCI_QUIRK_NO_CARD_NO_RESET |</span>
<span class="p_add">+		  SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,</span>
 	.ops = &amp;sdhci_esdhc_be_ops,
 };
 
 static const struct sdhci_pltfm_data sdhci_esdhc_le_pdata = {
<span class="p_del">-	.quirks = ESDHC_DEFAULT_QUIRKS | SDHCI_QUIRK_BROKEN_CARD_DETECTION</span>
<span class="p_del">-		| SDHCI_QUIRK_NO_CARD_NO_RESET</span>
<span class="p_del">-		| SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,</span>
<span class="p_add">+	.quirks = ESDHC_DEFAULT_QUIRKS |</span>
<span class="p_add">+		  SDHCI_QUIRK_NO_CARD_NO_RESET |</span>
<span class="p_add">+		  SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,</span>
 	.ops = &amp;sdhci_esdhc_le_ops,
 };
 
<span class="p_chunk">@@ -623,8 +626,7 @@</span> <span class="p_context"> static int sdhci_esdhc_probe(struct platform_device *pdev)</span>
 	    of_device_is_compatible(np, &quot;fsl,p5020-esdhc&quot;) ||
 	    of_device_is_compatible(np, &quot;fsl,p4080-esdhc&quot;) ||
 	    of_device_is_compatible(np, &quot;fsl,p1020-esdhc&quot;) ||
<span class="p_del">-	    of_device_is_compatible(np, &quot;fsl,t1040-esdhc&quot;) ||</span>
<span class="p_del">-	    of_device_is_compatible(np, &quot;fsl,ls1021a-esdhc&quot;))</span>
<span class="p_add">+	    of_device_is_compatible(np, &quot;fsl,t1040-esdhc&quot;))</span>
 		host-&gt;quirks &amp;= ~SDHCI_QUIRK_BROKEN_CARD_DETECTION;
 
 	if (of_device_is_compatible(np, &quot;fsl,ls1021a-esdhc&quot;))
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/main.c b/drivers/net/ethernet/mellanox/mlx4/main.c</span>
<span class="p_header">index 75d07fa9d0b1..b2ca8a635b2e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/main.c</span>
<span class="p_chunk">@@ -4020,49 +4020,51 @@</span> <span class="p_context"> int mlx4_restart_one(struct pci_dev *pdev)</span>
 	return err;
 }
 
<span class="p_add">+#define MLX_SP(id) { PCI_VDEVICE(MELLANOX, id), MLX4_PCI_DEV_FORCE_SENSE_PORT }</span>
<span class="p_add">+#define MLX_VF(id) { PCI_VDEVICE(MELLANOX, id), MLX4_PCI_DEV_IS_VF }</span>
<span class="p_add">+#define MLX_GN(id) { PCI_VDEVICE(MELLANOX, id), 0 }</span>
<span class="p_add">+</span>
 static const struct pci_device_id mlx4_pci_table[] = {
<span class="p_del">-	/* MT25408 &quot;Hermon&quot; SDR */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x6340), MLX4_PCI_DEV_FORCE_SENSE_PORT },</span>
<span class="p_del">-	/* MT25408 &quot;Hermon&quot; DDR */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x634a), MLX4_PCI_DEV_FORCE_SENSE_PORT },</span>
<span class="p_del">-	/* MT25408 &quot;Hermon&quot; QDR */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x6354), MLX4_PCI_DEV_FORCE_SENSE_PORT },</span>
<span class="p_del">-	/* MT25408 &quot;Hermon&quot; DDR PCIe gen2 */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x6732), MLX4_PCI_DEV_FORCE_SENSE_PORT },</span>
<span class="p_del">-	/* MT25408 &quot;Hermon&quot; QDR PCIe gen2 */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x673c), MLX4_PCI_DEV_FORCE_SENSE_PORT },</span>
<span class="p_del">-	/* MT25408 &quot;Hermon&quot; EN 10GigE */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x6368), MLX4_PCI_DEV_FORCE_SENSE_PORT },</span>
<span class="p_del">-	/* MT25408 &quot;Hermon&quot; EN 10GigE PCIe gen2 */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x6750), MLX4_PCI_DEV_FORCE_SENSE_PORT },</span>
<span class="p_del">-	/* MT25458 ConnectX EN 10GBASE-T 10GigE */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x6372), MLX4_PCI_DEV_FORCE_SENSE_PORT },</span>
<span class="p_del">-	/* MT25458 ConnectX EN 10GBASE-T+Gen2 10GigE */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x675a), MLX4_PCI_DEV_FORCE_SENSE_PORT },</span>
<span class="p_del">-	/* MT26468 ConnectX EN 10GigE PCIe gen2*/</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x6764), MLX4_PCI_DEV_FORCE_SENSE_PORT },</span>
<span class="p_del">-	/* MT26438 ConnectX EN 40GigE PCIe gen2 5GT/s */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x6746), MLX4_PCI_DEV_FORCE_SENSE_PORT },</span>
<span class="p_del">-	/* MT26478 ConnectX2 40GigE PCIe gen2 */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x676e), MLX4_PCI_DEV_FORCE_SENSE_PORT },</span>
<span class="p_del">-	/* MT25400 Family [ConnectX-2 Virtual Function] */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x1002), MLX4_PCI_DEV_IS_VF },</span>
<span class="p_add">+	/* MT25408 &quot;Hermon&quot; */</span>
<span class="p_add">+	MLX_SP(PCI_DEVICE_ID_MELLANOX_HERMON_SDR),	/* SDR */</span>
<span class="p_add">+	MLX_SP(PCI_DEVICE_ID_MELLANOX_HERMON_DDR),	/* DDR */</span>
<span class="p_add">+	MLX_SP(PCI_DEVICE_ID_MELLANOX_HERMON_QDR),	/* QDR */</span>
<span class="p_add">+	MLX_SP(PCI_DEVICE_ID_MELLANOX_HERMON_DDR_GEN2), /* DDR Gen2 */</span>
<span class="p_add">+	MLX_SP(PCI_DEVICE_ID_MELLANOX_HERMON_QDR_GEN2),	/* QDR Gen2 */</span>
<span class="p_add">+	MLX_SP(PCI_DEVICE_ID_MELLANOX_HERMON_EN),	/* EN 10GigE */</span>
<span class="p_add">+	MLX_SP(PCI_DEVICE_ID_MELLANOX_HERMON_EN_GEN2),  /* EN 10GigE Gen2 */</span>
<span class="p_add">+	/* MT25458 ConnectX EN 10GBASE-T */</span>
<span class="p_add">+	MLX_SP(PCI_DEVICE_ID_MELLANOX_CONNECTX_EN),</span>
<span class="p_add">+	MLX_SP(PCI_DEVICE_ID_MELLANOX_CONNECTX_EN_T_GEN2),	/* Gen2 */</span>
<span class="p_add">+	/* MT26468 ConnectX EN 10GigE PCIe Gen2*/</span>
<span class="p_add">+	MLX_SP(PCI_DEVICE_ID_MELLANOX_CONNECTX_EN_GEN2),</span>
<span class="p_add">+	/* MT26438 ConnectX EN 40GigE PCIe Gen2 5GT/s */</span>
<span class="p_add">+	MLX_SP(PCI_DEVICE_ID_MELLANOX_CONNECTX_EN_5_GEN2),</span>
<span class="p_add">+	/* MT26478 ConnectX2 40GigE PCIe Gen2 */</span>
<span class="p_add">+	MLX_SP(PCI_DEVICE_ID_MELLANOX_CONNECTX2),</span>
<span class="p_add">+	/* MT25400 Family [ConnectX-2] */</span>
<span class="p_add">+	MLX_VF(0x1002),					/* Virtual Function */</span>
 	/* MT27500 Family [ConnectX-3] */
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x1003), 0 },</span>
<span class="p_del">-	/* MT27500 Family [ConnectX-3 Virtual Function] */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x1004), MLX4_PCI_DEV_IS_VF },</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x1005), 0 }, /* MT27510 Family */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x1006), 0 }, /* MT27511 Family */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x1007), 0 }, /* MT27520 Family */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x1008), 0 }, /* MT27521 Family */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x1009), 0 }, /* MT27530 Family */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x100a), 0 }, /* MT27531 Family */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x100b), 0 }, /* MT27540 Family */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x100c), 0 }, /* MT27541 Family */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x100d), 0 }, /* MT27550 Family */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x100e), 0 }, /* MT27551 Family */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x100f), 0 }, /* MT27560 Family */</span>
<span class="p_del">-	{ PCI_VDEVICE(MELLANOX, 0x1010), 0 }, /* MT27561 Family */</span>
<span class="p_add">+	MLX_GN(PCI_DEVICE_ID_MELLANOX_CONNECTX3),</span>
<span class="p_add">+	MLX_VF(0x1004),					/* Virtual Function */</span>
<span class="p_add">+	MLX_GN(0x1005),					/* MT27510 Family */</span>
<span class="p_add">+	MLX_GN(0x1006),					/* MT27511 Family */</span>
<span class="p_add">+	MLX_GN(PCI_DEVICE_ID_MELLANOX_CONNECTX3_PRO),	/* MT27520 Family */</span>
<span class="p_add">+	MLX_GN(0x1008),					/* MT27521 Family */</span>
<span class="p_add">+	MLX_GN(0x1009),					/* MT27530 Family */</span>
<span class="p_add">+	MLX_GN(0x100a),					/* MT27531 Family */</span>
<span class="p_add">+	MLX_GN(0x100b),					/* MT27540 Family */</span>
<span class="p_add">+	MLX_GN(0x100c),					/* MT27541 Family */</span>
<span class="p_add">+	MLX_GN(0x100d),					/* MT27550 Family */</span>
<span class="p_add">+	MLX_GN(0x100e),					/* MT27551 Family */</span>
<span class="p_add">+	MLX_GN(0x100f),					/* MT27560 Family */</span>
<span class="p_add">+	MLX_GN(0x1010),					/* MT27561 Family */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * See the mellanox_check_broken_intx_masking() quirk when</span>
<span class="p_add">+	 * adding devices</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
 	{ 0, }
 };
 
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c</span>
<span class="p_header">index de19c7c92bc6..85d949e03f79 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c</span>
<span class="p_chunk">@@ -2238,14 +2238,16 @@</span> <span class="p_context"> int brcmf_p2p_del_vif(struct wiphy *wiphy, struct wireless_dev *wdev)</span>
 	struct brcmf_cfg80211_info *cfg = wiphy_priv(wiphy);
 	struct brcmf_p2p_info *p2p = &amp;cfg-&gt;p2p;
 	struct brcmf_cfg80211_vif *vif;
<span class="p_add">+	enum nl80211_iftype iftype;</span>
 	bool wait_for_disable = false;
 	int err;
 
 	brcmf_dbg(TRACE, &quot;delete P2P vif\n&quot;);
 	vif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);
 
<span class="p_add">+	iftype = vif-&gt;wdev.iftype;</span>
 	brcmf_cfg80211_arm_vif_event(cfg, vif);
<span class="p_del">-	switch (vif-&gt;wdev.iftype) {</span>
<span class="p_add">+	switch (iftype) {</span>
 	case NL80211_IFTYPE_P2P_CLIENT:
 		if (test_bit(BRCMF_VIF_STATUS_DISCONNECTING, &amp;vif-&gt;sme_state))
 			wait_for_disable = true;
<span class="p_chunk">@@ -2275,7 +2277,7 @@</span> <span class="p_context"> int brcmf_p2p_del_vif(struct wiphy *wiphy, struct wireless_dev *wdev)</span>
 					    BRCMF_P2P_DISABLE_TIMEOUT);
 
 	err = 0;
<span class="p_del">-	if (vif-&gt;wdev.iftype != NL80211_IFTYPE_P2P_DEVICE) {</span>
<span class="p_add">+	if (iftype != NL80211_IFTYPE_P2P_DEVICE) {</span>
 		brcmf_vif_clear_mgmt_ies(vif);
 		err = brcmf_p2p_release_p2p_if(vif);
 	}
<span class="p_chunk">@@ -2291,7 +2293,7 @@</span> <span class="p_context"> int brcmf_p2p_del_vif(struct wiphy *wiphy, struct wireless_dev *wdev)</span>
 	brcmf_remove_interface(vif-&gt;ifp, true);
 
 	brcmf_cfg80211_arm_vif_event(cfg, NULL);
<span class="p_del">-	if (vif-&gt;wdev.iftype != NL80211_IFTYPE_P2P_DEVICE)</span>
<span class="p_add">+	if (iftype != NL80211_IFTYPE_P2P_DEVICE)</span>
 		p2p-&gt;bss_idx[P2PAPI_BSSCFG_CONNECTION].vif = NULL;
 
 	return err;
<span class="p_header">diff --git a/drivers/nvme/host/core.c b/drivers/nvme/host/core.c</span>
<span class="p_header">index bde769b11e3b..5f2feeef8905 100644</span>
<span class="p_header">--- a/drivers/nvme/host/core.c</span>
<span class="p_header">+++ b/drivers/nvme/host/core.c</span>
<span class="p_chunk">@@ -1204,8 +1204,8 @@</span> <span class="p_context"> static void nvme_set_queue_limits(struct nvme_ctrl *ctrl,</span>
 		blk_queue_max_hw_sectors(q, ctrl-&gt;max_hw_sectors);
 		blk_queue_max_segments(q, min_t(u32, max_segments, USHRT_MAX));
 	}
<span class="p_del">-	if (ctrl-&gt;stripe_size)</span>
<span class="p_del">-		blk_queue_chunk_sectors(q, ctrl-&gt;stripe_size &gt;&gt; 9);</span>
<span class="p_add">+	if (ctrl-&gt;quirks &amp; NVME_QUIRK_STRIPE_SIZE)</span>
<span class="p_add">+		blk_queue_chunk_sectors(q, ctrl-&gt;max_hw_sectors);</span>
 	blk_queue_virt_boundary(q, ctrl-&gt;page_size - 1);
 	if (ctrl-&gt;vwc &amp; NVME_CTRL_VWC_PRESENT)
 		vwc = true;
<span class="p_chunk">@@ -1261,19 +1261,6 @@</span> <span class="p_context"> int nvme_init_identify(struct nvme_ctrl *ctrl)</span>
 	ctrl-&gt;max_hw_sectors =
 		min_not_zero(ctrl-&gt;max_hw_sectors, max_hw_sectors);
 
<span class="p_del">-	if ((ctrl-&gt;quirks &amp; NVME_QUIRK_STRIPE_SIZE) &amp;&amp; id-&gt;vs[3]) {</span>
<span class="p_del">-		unsigned int max_hw_sectors;</span>
<span class="p_del">-</span>
<span class="p_del">-		ctrl-&gt;stripe_size = 1 &lt;&lt; (id-&gt;vs[3] + page_shift);</span>
<span class="p_del">-		max_hw_sectors = ctrl-&gt;stripe_size &gt;&gt; (page_shift - 9);</span>
<span class="p_del">-		if (ctrl-&gt;max_hw_sectors) {</span>
<span class="p_del">-			ctrl-&gt;max_hw_sectors = min(max_hw_sectors,</span>
<span class="p_del">-							ctrl-&gt;max_hw_sectors);</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			ctrl-&gt;max_hw_sectors = max_hw_sectors;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	nvme_set_queue_limits(ctrl, ctrl-&gt;admin_q);
 	ctrl-&gt;sgls = le32_to_cpu(id-&gt;sgls);
 	ctrl-&gt;kas = le16_to_cpu(id-&gt;kas);
<span class="p_header">diff --git a/drivers/nvme/host/nvme.h b/drivers/nvme/host/nvme.h</span>
<span class="p_header">index d47f5a5d18c7..8edafd8cb8ce 100644</span>
<span class="p_header">--- a/drivers/nvme/host/nvme.h</span>
<span class="p_header">+++ b/drivers/nvme/host/nvme.h</span>
<span class="p_chunk">@@ -121,7 +121,6 @@</span> <span class="p_context"> struct nvme_ctrl {</span>
 
 	u32 page_size;
 	u32 max_hw_sectors;
<span class="p_del">-	u32 stripe_size;</span>
 	u16 oncs;
 	u16 vid;
 	atomic_t abort_limit;
<span class="p_header">diff --git a/drivers/pci/host/pci-thunder-pem.c b/drivers/pci/host/pci-thunder-pem.c</span>
<span class="p_header">index 6abaf80ffb39..c3276eede82a 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-thunder-pem.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-thunder-pem.c</span>
<span class="p_chunk">@@ -284,35 +284,16 @@</span> <span class="p_context"> static int thunder_pem_config_write(struct pci_bus *bus, unsigned int devfn,</span>
 	return pci_generic_config_write(bus, devfn, where, size, val);
 }
 
<span class="p_del">-static int thunder_pem_init(struct pci_config_window *cfg)</span>
<span class="p_add">+static int thunder_pem_init(struct device *dev, struct pci_config_window *cfg,</span>
<span class="p_add">+			    struct resource *res_pem)</span>
 {
<span class="p_del">-	struct device *dev = cfg-&gt;parent;</span>
<span class="p_del">-	resource_size_t bar4_start;</span>
<span class="p_del">-	struct resource *res_pem;</span>
 	struct thunder_pem_pci *pem_pci;
<span class="p_del">-	struct platform_device *pdev;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Only OF support for now */</span>
<span class="p_del">-	if (!dev-&gt;of_node)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	resource_size_t bar4_start;</span>
 
 	pem_pci = devm_kzalloc(dev, sizeof(*pem_pci), GFP_KERNEL);
 	if (!pem_pci)
 		return -ENOMEM;
 
<span class="p_del">-	pdev = to_platform_device(dev);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The second register range is the PEM bridge to the PCIe</span>
<span class="p_del">-	 * bus.  It has a different config access method than those</span>
<span class="p_del">-	 * devices behind the bridge.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	res_pem = platform_get_resource(pdev, IORESOURCE_MEM, 1);</span>
<span class="p_del">-	if (!res_pem) {</span>
<span class="p_del">-		dev_err(dev, &quot;missing \&quot;reg[1]\&quot;property\n&quot;);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	pem_pci-&gt;pem_reg_base = devm_ioremap(dev, res_pem-&gt;start, 0x10000);
 	if (!pem_pci-&gt;pem_reg_base)
 		return -ENOMEM;
<span class="p_chunk">@@ -332,9 +313,32 @@</span> <span class="p_context"> static int thunder_pem_init(struct pci_config_window *cfg)</span>
 	return 0;
 }
 
<span class="p_add">+static int thunder_pem_platform_init(struct pci_config_window *cfg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device *dev = cfg-&gt;parent;</span>
<span class="p_add">+	struct platform_device *pdev = to_platform_device(dev);</span>
<span class="p_add">+	struct resource *res_pem;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!dev-&gt;of_node)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The second register range is the PEM bridge to the PCIe</span>
<span class="p_add">+	 * bus.  It has a different config access method than those</span>
<span class="p_add">+	 * devices behind the bridge.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	res_pem = platform_get_resource(pdev, IORESOURCE_MEM, 1);</span>
<span class="p_add">+	if (!res_pem) {</span>
<span class="p_add">+		dev_err(dev, &quot;missing \&quot;reg[1]\&quot;property\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return thunder_pem_init(dev, cfg, res_pem);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct pci_ecam_ops pci_thunder_pem_ops = {
 	.bus_shift	= 24,
<span class="p_del">-	.init		= thunder_pem_init,</span>
<span class="p_add">+	.init		= thunder_pem_platform_init,</span>
 	.pci_ops	= {
 		.map_bus	= pci_ecam_map_bus,
 		.read		= thunder_pem_config_read,
<span class="p_header">diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c</span>
<span class="p_header">index 087a218a875f..5d8151b43fbb 100644</span>
<span class="p_header">--- a/drivers/pci/quirks.c</span>
<span class="p_header">+++ b/drivers/pci/quirks.c</span>
<span class="p_chunk">@@ -1634,6 +1634,7 @@</span> <span class="p_context"> static void quirk_pcie_mch(struct pci_dev *pdev)</span>
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_E7520_MCH,	quirk_pcie_mch);
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_E7320_MCH,	quirk_pcie_mch);
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_E7525_MCH,	quirk_pcie_mch);
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_HUAWEI,	0x1610,	quirk_pcie_mch);</span>
 
 
 /*
<span class="p_chunk">@@ -2156,7 +2157,7 @@</span> <span class="p_context"> static void quirk_blacklist_vpd(struct pci_dev *dev)</span>
 {
 	if (dev-&gt;vpd) {
 		dev-&gt;vpd-&gt;len = 0;
<span class="p_del">-		dev_warn(&amp;dev-&gt;dev, FW_BUG &quot;VPD access disabled\n&quot;);</span>
<span class="p_add">+		dev_warn(&amp;dev-&gt;dev, FW_BUG &quot;disabling VPD access (can&#39;t determine size of non-standard VPD format)\n&quot;);</span>
 	}
 }
 
<span class="p_chunk">@@ -2240,6 +2241,27 @@</span> <span class="p_context"> DECLARE_PCI_FIXUP_ENABLE(PCI_VENDOR_ID_BROADCOM,</span>
 			 PCI_DEVICE_ID_TIGON3_5719,
 			 quirk_brcm_5719_limit_mrrs);
 
<span class="p_add">+#ifdef CONFIG_PCIE_IPROC_PLATFORM</span>
<span class="p_add">+static void quirk_paxc_bridge(struct pci_dev *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* The PCI config space is shared with the PAXC root port and the first</span>
<span class="p_add">+	 * Ethernet device.  So, we need to workaround this by telling the PCI</span>
<span class="p_add">+	 * code that the bridge is not an Ethernet device.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (pdev-&gt;hdr_type == PCI_HEADER_TYPE_BRIDGE)</span>
<span class="p_add">+		pdev-&gt;class = PCI_CLASS_BRIDGE_PCI &lt;&lt; 8;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* MPSS is not being set properly (as it is currently 0).  This is</span>
<span class="p_add">+	 * because that area of the PCI config space is hard coded to zero, and</span>
<span class="p_add">+	 * is not modifiable by firmware.  Set this to 2 (e.g., 512 byte MPS)</span>
<span class="p_add">+	 * so that the MPS can be set to the real max value.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pdev-&gt;pcie_mpss = 2;</span>
<span class="p_add">+}</span>
<span class="p_add">+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_BROADCOM, 0x16cd, quirk_paxc_bridge);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_BROADCOM, 0x16f0, quirk_paxc_bridge);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /* Originally in EDAC sources for i82875P:
  * Intel tells BIOS developers to hide device 6 which
  * configures the overflow device access containing
<span class="p_chunk">@@ -3114,30 +3136,32 @@</span> <span class="p_context"> static void quirk_remove_d3_delay(struct pci_dev *dev)</span>
 {
 	dev-&gt;d3_delay = 0;
 }
<span class="p_del">-DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0c00, quirk_remove_d3_delay);</span>
<span class="p_add">+/* C600 Series devices do not need 10ms d3_delay */</span>
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0412, quirk_remove_d3_delay);
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0c00, quirk_remove_d3_delay);</span>
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0c0c, quirk_remove_d3_delay);
<span class="p_del">-DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c31, quirk_remove_d3_delay);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c3a, quirk_remove_d3_delay);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c3d, quirk_remove_d3_delay);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c2d, quirk_remove_d3_delay);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c20, quirk_remove_d3_delay);</span>
<span class="p_add">+/* Lynxpoint-H PCH devices do not need 10ms d3_delay */</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c02, quirk_remove_d3_delay);</span>
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c18, quirk_remove_d3_delay);
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c1c, quirk_remove_d3_delay);
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c20, quirk_remove_d3_delay);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c22, quirk_remove_d3_delay);</span>
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c26, quirk_remove_d3_delay);
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c2d, quirk_remove_d3_delay);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c31, quirk_remove_d3_delay);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c3a, quirk_remove_d3_delay);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c3d, quirk_remove_d3_delay);</span>
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c4e, quirk_remove_d3_delay);
<span class="p_del">-DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c02, quirk_remove_d3_delay);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c22, quirk_remove_d3_delay);</span>
 /* Intel Cherrytrail devices do not need 10ms d3_delay */
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x2280, quirk_remove_d3_delay);
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x2298, quirk_remove_d3_delay);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x229c, quirk_remove_d3_delay);</span>
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x22b0, quirk_remove_d3_delay);
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x22b5, quirk_remove_d3_delay);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x22b7, quirk_remove_d3_delay);</span>
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x22b8, quirk_remove_d3_delay);
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x22d8, quirk_remove_d3_delay);
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x22dc, quirk_remove_d3_delay);
<span class="p_del">-DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x22b5, quirk_remove_d3_delay);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x22b7, quirk_remove_d3_delay);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x2298, quirk_remove_d3_delay);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x229c, quirk_remove_d3_delay);</span>
 
 /*
  * Some devices may pass our check in pci_intx_mask_supported() if
<span class="p_chunk">@@ -4137,6 +4161,26 @@</span> <span class="p_context"> static int pci_quirk_intel_pch_acs(struct pci_dev *dev, u16 acs_flags)</span>
 }
 
 /*
<span class="p_add">+ * These QCOM root ports do provide ACS-like features to disable peer</span>
<span class="p_add">+ * transactions and validate bus numbers in requests, but do not provide an</span>
<span class="p_add">+ * actual PCIe ACS capability.  Hardware supports source validation but it</span>
<span class="p_add">+ * will report the issue as Completer Abort instead of ACS Violation.</span>
<span class="p_add">+ * Hardware doesn&#39;t support peer-to-peer and each root port is a root</span>
<span class="p_add">+ * complex with unique segment numbers.  It is not possible for one root</span>
<span class="p_add">+ * port to pass traffic to another root port.  All PCIe transactions are</span>
<span class="p_add">+ * terminated inside the root port.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int pci_quirk_qcom_rp_acs(struct pci_dev *dev, u16 acs_flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u16 flags = (PCI_ACS_RR | PCI_ACS_CR | PCI_ACS_UF | PCI_ACS_SV);</span>
<span class="p_add">+	int ret = acs_flags &amp; ~flags ? 0 : 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_info(&amp;dev-&gt;dev, &quot;Using QCOM ACS Quirk (%d)\n&quot;, ret);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Sunrise Point PCH root ports implement ACS, but unfortunately as shown in
  * the datasheet (Intel 100 Series Chipset Family PCH Datasheet, Vol. 2,
  * 12.1.46, 12.1.47)[1] this chipset uses dwords for the ACS capability and
<span class="p_chunk">@@ -4151,15 +4195,35 @@</span> <span class="p_context"> static int pci_quirk_intel_pch_acs(struct pci_dev *dev, u16 acs_flags)</span>
  *
  * N.B. This doesn&#39;t fix what lspci shows.
  *
<span class="p_add">+ * The 100 series chipset specification update includes this as errata #23[3].</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The 200 series chipset (Union Point) has the same bug according to the</span>
<span class="p_add">+ * specification update (Intel 200 Series Chipset Family Platform Controller</span>
<span class="p_add">+ * Hub, Specification Update, January 2017, Revision 001, Document# 335194-001,</span>
<span class="p_add">+ * Errata 22)[4].  Per the datasheet[5], root port PCI Device IDs for this</span>
<span class="p_add">+ * chipset include:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * 0xa290-0xa29f PCI Express Root port #{0-16}</span>
<span class="p_add">+ * 0xa2e7-0xa2ee PCI Express Root port #{17-24}</span>
<span class="p_add">+ *</span>
  * [1] http://www.intel.com/content/www/us/en/chipsets/100-series-chipset-datasheet-vol-2.html
  * [2] http://www.intel.com/content/www/us/en/chipsets/100-series-chipset-datasheet-vol-1.html
<span class="p_add">+ * [3] http://www.intel.com/content/www/us/en/chipsets/100-series-chipset-spec-update.html</span>
<span class="p_add">+ * [4] http://www.intel.com/content/www/us/en/chipsets/200-series-chipset-pch-spec-update.html</span>
<span class="p_add">+ * [5] http://www.intel.com/content/www/us/en/chipsets/200-series-chipset-pch-datasheet-vol-1.html</span>
  */
 static bool pci_quirk_intel_spt_pch_acs_match(struct pci_dev *dev)
 {
<span class="p_del">-	return pci_is_pcie(dev) &amp;&amp;</span>
<span class="p_del">-		pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT &amp;&amp;</span>
<span class="p_del">-		((dev-&gt;device &amp; ~0xf) == 0xa110 ||</span>
<span class="p_del">-		 (dev-&gt;device &gt;= 0xa167 &amp;&amp; dev-&gt;device &lt;= 0xa16a));</span>
<span class="p_add">+	if (!pci_is_pcie(dev) || pci_pcie_type(dev) != PCI_EXP_TYPE_ROOT_PORT)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (dev-&gt;device) {</span>
<span class="p_add">+	case 0xa110 ... 0xa11f: case 0xa167 ... 0xa16a: /* Sunrise Point */</span>
<span class="p_add">+	case 0xa290 ... 0xa29f: case 0xa2e7 ... 0xa2ee: /* Union Point */</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
 }
 
 #define INTEL_SPT_ACS_CTRL (PCI_ACS_CAP + 4)
<span class="p_chunk">@@ -4272,6 +4336,9 @@</span> <span class="p_context"> static const struct pci_dev_acs_enabled {</span>
 	/* I219 */
 	{ PCI_VENDOR_ID_INTEL, 0x15b7, pci_quirk_mf_endpoint_acs },
 	{ PCI_VENDOR_ID_INTEL, 0x15b8, pci_quirk_mf_endpoint_acs },
<span class="p_add">+	/* QCOM QDF2xxx root ports */</span>
<span class="p_add">+	{ 0x17cb, 0x400, pci_quirk_qcom_rp_acs },</span>
<span class="p_add">+	{ 0x17cb, 0x401, pci_quirk_qcom_rp_acs },</span>
 	/* Intel PCH root ports */
 	{ PCI_VENDOR_ID_INTEL, PCI_ANY_ID, pci_quirk_intel_pch_acs },
 	{ PCI_VENDOR_ID_INTEL, PCI_ANY_ID, pci_quirk_intel_spt_pch_acs },
<span class="p_header">diff --git a/drivers/platform/x86/acer-wmi.c b/drivers/platform/x86/acer-wmi.c</span>
<span class="p_header">index 79d64ea00bfb..a66192f692e3 100644</span>
<span class="p_header">--- a/drivers/platform/x86/acer-wmi.c</span>
<span class="p_header">+++ b/drivers/platform/x86/acer-wmi.c</span>
<span class="p_chunk">@@ -355,6 +355,32 @@</span> <span class="p_context"> static const struct dmi_system_id acer_blacklist[] __initconst = {</span>
 	{}
 };
 
<span class="p_add">+static const struct dmi_system_id amw0_whitelist[] __initconst = {</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.ident = &quot;Acer&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Acer&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.ident = &quot;Gateway&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Gateway&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.ident = &quot;Packard Bell&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Packard Bell&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This quirk table is only for Acer/Gateway/Packard Bell family</span>
<span class="p_add">+ * that those machines are supported by acer-wmi driver.</span>
<span class="p_add">+ */</span>
 static const struct dmi_system_id acer_quirks[] __initconst = {
 	{
 		.callback = dmi_matched,
<span class="p_chunk">@@ -464,6 +490,17 @@</span> <span class="p_context"> static const struct dmi_system_id acer_quirks[] __initconst = {</span>
 		},
 		.driver_data = &amp;quirk_acer_travelmate_2490,
 	},
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This quirk list is for those non-acer machines that have AMW0_GUID1</span>
<span class="p_add">+ * but supported by acer-wmi in past days. Keeping this quirk list here</span>
<span class="p_add">+ * is only for backward compatible. Please do not add new machine to</span>
<span class="p_add">+ * here anymore. Those non-acer machines should be supported by</span>
<span class="p_add">+ * appropriate wmi drivers.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static const struct dmi_system_id non_acer_quirks[] __initconst = {</span>
 	{
 		.callback = dmi_matched,
 		.ident = &quot;Fujitsu Siemens Amilo Li 1718&quot;,
<span class="p_chunk">@@ -598,6 +635,7 @@</span> <span class="p_context"> static void __init find_quirks(void)</span>
 {
 	if (!force_series) {
 		dmi_check_system(acer_quirks);
<span class="p_add">+		dmi_check_system(non_acer_quirks);</span>
 	} else if (force_series == 2490) {
 		quirks = &amp;quirk_acer_travelmate_2490;
 	}
<span class="p_chunk">@@ -2108,6 +2146,24 @@</span> <span class="p_context"> static int __init acer_wmi_init(void)</span>
 	find_quirks();
 
 	/*
<span class="p_add">+	 * The AMW0_GUID1 wmi is not only found on Acer family but also other</span>
<span class="p_add">+	 * machines like Lenovo, Fujitsu and Medion. In the past days,</span>
<span class="p_add">+	 * acer-wmi driver handled those non-Acer machines by quirks list.</span>
<span class="p_add">+	 * But actually acer-wmi driver was loaded on any machines that have</span>
<span class="p_add">+	 * AMW0_GUID1. This behavior is strange because those machines should</span>
<span class="p_add">+	 * be supported by appropriate wmi drivers. e.g. fujitsu-laptop,</span>
<span class="p_add">+	 * ideapad-laptop. So, here checks the machine that has AMW0_GUID1</span>
<span class="p_add">+	 * should be in Acer/Gateway/Packard Bell white list, or it&#39;s already</span>
<span class="p_add">+	 * in the past quirk list.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (wmi_has_guid(AMW0_GUID1) &amp;&amp;</span>
<span class="p_add">+	    !dmi_check_system(amw0_whitelist) &amp;&amp;</span>
<span class="p_add">+	    quirks == &amp;quirk_unknown) {</span>
<span class="p_add">+		pr_err(&quot;Unsupported machine has AMW0_GUID1, unable to load\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * Detect which ACPI-WMI interface we&#39;re using.
 	 */
 	if (wmi_has_guid(AMW0_GUID1) &amp;&amp; wmi_has_guid(WMID_GUID1))
<span class="p_header">diff --git a/drivers/platform/x86/asus-nb-wmi.c b/drivers/platform/x86/asus-nb-wmi.c</span>
<span class="p_header">index 6032b7085582..6eb2837f6b89 100644</span>
<span class="p_header">--- a/drivers/platform/x86/asus-nb-wmi.c</span>
<span class="p_header">+++ b/drivers/platform/x86/asus-nb-wmi.c</span>
<span class="p_chunk">@@ -116,6 +116,10 @@</span> <span class="p_context"> static struct quirk_entry quirk_asus_ux303ub = {</span>
 	.wmi_backlight_native = true,
 };
 
<span class="p_add">+static struct quirk_entry quirk_asus_x550lb = {</span>
<span class="p_add">+	.xusb2pr = 0x01D9,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int dmi_matched(const struct dmi_system_id *dmi)
 {
 	quirks = dmi-&gt;driver_data;
<span class="p_chunk">@@ -407,6 +411,15 @@</span> <span class="p_context"> static const struct dmi_system_id asus_quirks[] = {</span>
 		},
 		.driver_data = &amp;quirk_asus_ux303ub,
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = dmi_matched,</span>
<span class="p_add">+		.ident = &quot;ASUSTeK COMPUTER INC. X550LB&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;X550LB&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+		.driver_data = &amp;quirk_asus_x550lb,</span>
<span class="p_add">+	},</span>
 	{},
 };
 
<span class="p_header">diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c</span>
<span class="p_header">index ce6ca31a2d09..8499d3ae4257 100644</span>
<span class="p_header">--- a/drivers/platform/x86/asus-wmi.c</span>
<span class="p_header">+++ b/drivers/platform/x86/asus-wmi.c</span>
<span class="p_chunk">@@ -156,6 +156,11 @@</span> <span class="p_context"> MODULE_LICENSE(&quot;GPL&quot;);</span>
 #define ASUS_FAN_CTRL_MANUAL		1
 #define ASUS_FAN_CTRL_AUTO		2
 
<span class="p_add">+#define USB_INTEL_XUSB2PR		0xD0</span>
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI	0x9c31</span>
<span class="p_add">+</span>
<span class="p_add">+static const char * const ashs_ids[] = { &quot;ATK4001&quot;, &quot;ATK4002&quot;, NULL };</span>
<span class="p_add">+</span>
 struct bios_args {
 	u32 arg0;
 	u32 arg1;
<span class="p_chunk">@@ -1080,6 +1085,29 @@</span> <span class="p_context"> static int asus_wmi_rfkill_init(struct asus_wmi *asus)</span>
 	return result;
 }
 
<span class="p_add">+static void asus_wmi_set_xusb2pr(struct asus_wmi *asus)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *xhci_pdev;</span>
<span class="p_add">+	u32 orig_ports_available;</span>
<span class="p_add">+	u32 ports_available = asus-&gt;driver-&gt;quirks-&gt;xusb2pr;</span>
<span class="p_add">+</span>
<span class="p_add">+	xhci_pdev = pci_get_device(PCI_VENDOR_ID_INTEL,</span>
<span class="p_add">+			PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI,</span>
<span class="p_add">+			NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!xhci_pdev)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	pci_read_config_dword(xhci_pdev, USB_INTEL_XUSB2PR,</span>
<span class="p_add">+				&amp;orig_ports_available);</span>
<span class="p_add">+</span>
<span class="p_add">+	pci_write_config_dword(xhci_pdev, USB_INTEL_XUSB2PR,</span>
<span class="p_add">+				cpu_to_le32(ports_available));</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_info(&quot;set USB_INTEL_XUSB2PR old: 0x%04x, new: 0x%04x\n&quot;,</span>
<span class="p_add">+			orig_ports_available, ports_available);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Hwmon device
  */
<span class="p_chunk">@@ -2025,6 +2053,16 @@</span> <span class="p_context"> static int asus_wmi_fan_init(struct asus_wmi *asus)</span>
 	return 0;
 }
 
<span class="p_add">+static bool ashs_present(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+	while (ashs_ids[i]) {</span>
<span class="p_add">+		if (acpi_dev_found(ashs_ids[i++]))</span>
<span class="p_add">+			return true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * WMI Driver
  */
<span class="p_chunk">@@ -2069,6 +2107,13 @@</span> <span class="p_context"> static int asus_wmi_add(struct platform_device *pdev)</span>
 	if (err)
 		goto fail_leds;
 
<span class="p_add">+	asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_WLAN, &amp;result);</span>
<span class="p_add">+	if (result &amp; (ASUS_WMI_DSTS_PRESENCE_BIT | ASUS_WMI_DSTS_USER_BIT))</span>
<span class="p_add">+		asus-&gt;driver-&gt;wlan_ctrl_by_user = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (asus-&gt;driver-&gt;wlan_ctrl_by_user &amp;&amp; ashs_present())</span>
<span class="p_add">+		asus-&gt;driver-&gt;quirks-&gt;no_rfkill = 1;</span>
<span class="p_add">+</span>
 	if (!asus-&gt;driver-&gt;quirks-&gt;no_rfkill) {
 		err = asus_wmi_rfkill_init(asus);
 		if (err)
<span class="p_chunk">@@ -2087,6 +2132,9 @@</span> <span class="p_context"> static int asus_wmi_add(struct platform_device *pdev)</span>
 	if (asus-&gt;driver-&gt;quirks-&gt;wmi_backlight_native)
 		acpi_video_set_dmi_backlight_type(acpi_backlight_native);
 
<span class="p_add">+	if (asus-&gt;driver-&gt;quirks-&gt;xusb2pr)</span>
<span class="p_add">+		asus_wmi_set_xusb2pr(asus);</span>
<span class="p_add">+</span>
 	if (acpi_video_get_backlight_type() == acpi_backlight_vendor) {
 		err = asus_wmi_backlight_init(asus);
 		if (err &amp;&amp; err != -ENODEV)
<span class="p_chunk">@@ -2105,10 +2153,6 @@</span> <span class="p_context"> static int asus_wmi_add(struct platform_device *pdev)</span>
 	if (err)
 		goto fail_debugfs;
 
<span class="p_del">-	asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_WLAN, &amp;result);</span>
<span class="p_del">-	if (result &amp; (ASUS_WMI_DSTS_PRESENCE_BIT | ASUS_WMI_DSTS_USER_BIT))</span>
<span class="p_del">-		asus-&gt;driver-&gt;wlan_ctrl_by_user = 1;</span>
<span class="p_del">-</span>
 	return 0;
 
 fail_debugfs:
<span class="p_header">diff --git a/drivers/platform/x86/asus-wmi.h b/drivers/platform/x86/asus-wmi.h</span>
<span class="p_header">index 0e19014e9f54..fdff626c3b51 100644</span>
<span class="p_header">--- a/drivers/platform/x86/asus-wmi.h</span>
<span class="p_header">+++ b/drivers/platform/x86/asus-wmi.h</span>
<span class="p_chunk">@@ -53,6 +53,7 @@</span> <span class="p_context"> struct quirk_entry {</span>
 	 * and let the ACPI interrupt to send out the key event.
 	 */
 	int no_display_toggle;
<span class="p_add">+	u32 xusb2pr;</span>
 
 	bool (*i8042_filter)(unsigned char data, unsigned char str,
 			     struct serio *serio);
<span class="p_header">diff --git a/drivers/scsi/ufs/ufs-qcom.c b/drivers/scsi/ufs/ufs-qcom.c</span>
<span class="p_header">index 3aedf73f1131..462bf42dd19c 100644</span>
<span class="p_header">--- a/drivers/scsi/ufs/ufs-qcom.c</span>
<span class="p_header">+++ b/drivers/scsi/ufs/ufs-qcom.c</span>
<span class="p_chunk">@@ -23,6 +23,7 @@</span> <span class="p_context"></span>
 #include &quot;unipro.h&quot;
 #include &quot;ufs-qcom.h&quot;
 #include &quot;ufshci.h&quot;
<span class="p_add">+#include &quot;ufs_quirks.h&quot;</span>
 #define UFS_QCOM_DEFAULT_DBG_PRINT_EN	\
 	(UFS_QCOM_DBG_PRINT_REGS_EN | UFS_QCOM_DBG_PRINT_TEST_BUS_EN)
 
<span class="p_chunk">@@ -1031,6 +1032,34 @@</span> <span class="p_context"> static int ufs_qcom_pwr_change_notify(struct ufs_hba *hba,</span>
 	return ret;
 }
 
<span class="p_add">+static int ufs_qcom_quirk_host_pa_saveconfigtime(struct ufs_hba *hba)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+	u32 pa_vs_config_reg1;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = ufshcd_dme_get(hba, UIC_ARG_MIB(PA_VS_CONFIG_REG1),</span>
<span class="p_add">+			     &amp;pa_vs_config_reg1);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Allow extension of MSB bits of PA_SaveConfigTime attribute */</span>
<span class="p_add">+	err = ufshcd_dme_set(hba, UIC_ARG_MIB(PA_VS_CONFIG_REG1),</span>
<span class="p_add">+			    (pa_vs_config_reg1 | (1 &lt;&lt; 12)));</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int ufs_qcom_apply_dev_quirks(struct ufs_hba *hba)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hba-&gt;dev_quirks &amp; UFS_DEVICE_QUIRK_HOST_PA_SAVECONFIGTIME)</span>
<span class="p_add">+		err = ufs_qcom_quirk_host_pa_saveconfigtime(hba);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static u32 ufs_qcom_get_ufs_hci_version(struct ufs_hba *hba)
 {
 	struct ufs_qcom_host *host = ufshcd_get_variant(hba);
<span class="p_chunk">@@ -1616,6 +1645,7 @@</span> <span class="p_context"> static struct ufs_hba_variant_ops ufs_hba_qcom_vops = {</span>
 	.hce_enable_notify      = ufs_qcom_hce_enable_notify,
 	.link_startup_notify    = ufs_qcom_link_startup_notify,
 	.pwr_change_notify	= ufs_qcom_pwr_change_notify,
<span class="p_add">+	.apply_dev_quirks	= ufs_qcom_apply_dev_quirks,</span>
 	.suspend		= ufs_qcom_suspend,
 	.resume			= ufs_qcom_resume,
 	.dbg_register_dump	= ufs_qcom_dump_dbg_regs,
<span class="p_header">diff --git a/drivers/scsi/ufs/ufs-qcom.h b/drivers/scsi/ufs/ufs-qcom.h</span>
<span class="p_header">index a19307a57ce2..fe517cd7dac3 100644</span>
<span class="p_header">--- a/drivers/scsi/ufs/ufs-qcom.h</span>
<span class="p_header">+++ b/drivers/scsi/ufs/ufs-qcom.h</span>
<span class="p_chunk">@@ -142,6 +142,7 @@</span> <span class="p_context"> enum ufs_qcom_phy_init_type {</span>
 	 UFS_QCOM_DBG_PRINT_TEST_BUS_EN)
 
 /* QUniPro Vendor specific attributes */
<span class="p_add">+#define PA_VS_CONFIG_REG1	0x9000</span>
 #define DME_VS_CORE_CLK_CTRL	0xD002
 /* bit and mask definitions for DME_VS_CORE_CLK_CTRL attribute */
 #define DME_VS_CORE_CLK_CTRL_CORE_CLK_DIV_EN_BIT		BIT(8)
<span class="p_header">diff --git a/drivers/scsi/ufs/ufs_quirks.h b/drivers/scsi/ufs/ufs_quirks.h</span>
<span class="p_header">index 22f881e9253a..08b799d4efcc 100644</span>
<span class="p_header">--- a/drivers/scsi/ufs/ufs_quirks.h</span>
<span class="p_header">+++ b/drivers/scsi/ufs/ufs_quirks.h</span>
<span class="p_chunk">@@ -128,26 +128,23 @@</span> <span class="p_context"> struct ufs_dev_fix {</span>
  */
 #define UFS_DEVICE_QUIRK_DELAY_BEFORE_LPM	(1 &lt;&lt; 6)
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Some UFS devices require host PA_TACTIVATE to be lower than device</span>
<span class="p_add">+ * PA_TACTIVATE, enabling this quirk ensure this.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define UFS_DEVICE_QUIRK_HOST_PA_TACTIVATE	(1 &lt;&lt; 7)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * The max. value PA_SaveConfigTime is 250 (10us) but this is not enough for</span>
<span class="p_add">+ * some vendors.</span>
<span class="p_add">+ * Gear switch from PWM to HS may fail even with this max. PA_SaveConfigTime.</span>
<span class="p_add">+ * Gear switch can be issued by host controller as an error recovery and any</span>
<span class="p_add">+ * software delay will not help on this case so we need to increase</span>
<span class="p_add">+ * PA_SaveConfigTime to &gt;32us as per vendor recommendation.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define UFS_DEVICE_QUIRK_HOST_PA_SAVECONFIGTIME	(1 &lt;&lt; 8)</span>
<span class="p_add">+</span>
 struct ufs_hba;
 void ufs_advertise_fixup_device(struct ufs_hba *hba);
 
<span class="p_del">-static struct ufs_dev_fix ufs_fixups[] = {</span>
<span class="p_del">-	/* UFS cards deviations table */</span>
<span class="p_del">-	UFS_FIX(UFS_VENDOR_SAMSUNG, UFS_ANY_MODEL,</span>
<span class="p_del">-		UFS_DEVICE_QUIRK_DELAY_BEFORE_LPM),</span>
<span class="p_del">-	UFS_FIX(UFS_VENDOR_SAMSUNG, UFS_ANY_MODEL, UFS_DEVICE_NO_VCCQ),</span>
<span class="p_del">-	UFS_FIX(UFS_VENDOR_SAMSUNG, UFS_ANY_MODEL,</span>
<span class="p_del">-		UFS_DEVICE_QUIRK_RECOVERY_FROM_DL_NAC_ERRORS),</span>
<span class="p_del">-	UFS_FIX(UFS_VENDOR_SAMSUNG, UFS_ANY_MODEL,</span>
<span class="p_del">-		UFS_DEVICE_NO_FASTAUTO),</span>
<span class="p_del">-	UFS_FIX(UFS_VENDOR_TOSHIBA, UFS_ANY_MODEL,</span>
<span class="p_del">-		UFS_DEVICE_QUIRK_DELAY_BEFORE_LPM),</span>
<span class="p_del">-	UFS_FIX(UFS_VENDOR_TOSHIBA, &quot;THGLF2G9C8KBADG&quot;,</span>
<span class="p_del">-		UFS_DEVICE_QUIRK_PA_TACTIVATE),</span>
<span class="p_del">-	UFS_FIX(UFS_VENDOR_TOSHIBA, &quot;THGLF2G9D8KBADG&quot;,</span>
<span class="p_del">-		UFS_DEVICE_QUIRK_PA_TACTIVATE),</span>
<span class="p_del">-	UFS_FIX(UFS_VENDOR_SKHYNIX, UFS_ANY_MODEL, UFS_DEVICE_NO_VCCQ),</span>
<span class="p_del">-</span>
<span class="p_del">-	END_FIX</span>
<span class="p_del">-};</span>
 #endif /* UFS_QUIRKS_H_ */
<span class="p_header">diff --git a/drivers/scsi/ufs/ufshcd.c b/drivers/scsi/ufs/ufshcd.c</span>
<span class="p_header">index 05c745663c10..edb06e466224 100644</span>
<span class="p_header">--- a/drivers/scsi/ufs/ufshcd.c</span>
<span class="p_header">+++ b/drivers/scsi/ufs/ufshcd.c</span>
<span class="p_chunk">@@ -123,6 +123,7 @@</span> <span class="p_context"> enum {</span>
 	UFSHCD_STATE_RESET,
 	UFSHCD_STATE_ERROR,
 	UFSHCD_STATE_OPERATIONAL,
<span class="p_add">+	UFSHCD_STATE_EH_SCHEDULED,</span>
 };
 
 /* UFSHCD error handling flags */
<span class="p_chunk">@@ -188,6 +189,30 @@</span> <span class="p_context"> ufs_get_pm_lvl_to_link_pwr_state(enum ufs_pm_level lvl)</span>
 	return ufs_pm_lvl_states[lvl].link_state;
 }
 
<span class="p_add">+static struct ufs_dev_fix ufs_fixups[] = {</span>
<span class="p_add">+	/* UFS cards deviations table */</span>
<span class="p_add">+	UFS_FIX(UFS_VENDOR_SAMSUNG, UFS_ANY_MODEL,</span>
<span class="p_add">+		UFS_DEVICE_QUIRK_DELAY_BEFORE_LPM),</span>
<span class="p_add">+	UFS_FIX(UFS_VENDOR_SAMSUNG, UFS_ANY_MODEL, UFS_DEVICE_NO_VCCQ),</span>
<span class="p_add">+	UFS_FIX(UFS_VENDOR_SAMSUNG, UFS_ANY_MODEL,</span>
<span class="p_add">+		UFS_DEVICE_QUIRK_RECOVERY_FROM_DL_NAC_ERRORS),</span>
<span class="p_add">+	UFS_FIX(UFS_VENDOR_SAMSUNG, UFS_ANY_MODEL,</span>
<span class="p_add">+		UFS_DEVICE_NO_FASTAUTO),</span>
<span class="p_add">+	UFS_FIX(UFS_VENDOR_SAMSUNG, UFS_ANY_MODEL,</span>
<span class="p_add">+		UFS_DEVICE_QUIRK_HOST_PA_TACTIVATE),</span>
<span class="p_add">+	UFS_FIX(UFS_VENDOR_TOSHIBA, UFS_ANY_MODEL,</span>
<span class="p_add">+		UFS_DEVICE_QUIRK_DELAY_BEFORE_LPM),</span>
<span class="p_add">+	UFS_FIX(UFS_VENDOR_TOSHIBA, &quot;THGLF2G9C8KBADG&quot;,</span>
<span class="p_add">+		UFS_DEVICE_QUIRK_PA_TACTIVATE),</span>
<span class="p_add">+	UFS_FIX(UFS_VENDOR_TOSHIBA, &quot;THGLF2G9D8KBADG&quot;,</span>
<span class="p_add">+		UFS_DEVICE_QUIRK_PA_TACTIVATE),</span>
<span class="p_add">+	UFS_FIX(UFS_VENDOR_SKHYNIX, UFS_ANY_MODEL, UFS_DEVICE_NO_VCCQ),</span>
<span class="p_add">+	UFS_FIX(UFS_VENDOR_SKHYNIX, UFS_ANY_MODEL,</span>
<span class="p_add">+		UFS_DEVICE_QUIRK_HOST_PA_SAVECONFIGTIME),</span>
<span class="p_add">+</span>
<span class="p_add">+	END_FIX</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static void ufshcd_tmc_handler(struct ufs_hba *hba);
 static void ufshcd_async_scan(void *data, async_cookie_t cookie);
 static int ufshcd_reset_and_restore(struct ufs_hba *hba);
<span class="p_chunk">@@ -1088,7 +1113,7 @@</span> <span class="p_context"> ufshcd_send_uic_cmd(struct ufs_hba *hba, struct uic_command *uic_cmd)</span>
  *
  * Returns 0 in case of success, non-zero value in case of failure
  */
<span class="p_del">-static int ufshcd_map_sg(struct ufshcd_lrb *lrbp)</span>
<span class="p_add">+static int ufshcd_map_sg(struct ufs_hba *hba, struct ufshcd_lrb *lrbp)</span>
 {
 	struct ufshcd_sg_entry *prd_table;
 	struct scatterlist *sg;
<span class="p_chunk">@@ -1102,8 +1127,13 @@</span> <span class="p_context"> static int ufshcd_map_sg(struct ufshcd_lrb *lrbp)</span>
 		return sg_segments;
 
 	if (sg_segments) {
<span class="p_del">-		lrbp-&gt;utr_descriptor_ptr-&gt;prd_table_length =</span>
<span class="p_del">-					cpu_to_le16((u16) (sg_segments));</span>
<span class="p_add">+		if (hba-&gt;quirks &amp; UFSHCD_QUIRK_PRDT_BYTE_GRAN)</span>
<span class="p_add">+			lrbp-&gt;utr_descriptor_ptr-&gt;prd_table_length =</span>
<span class="p_add">+				cpu_to_le16((u16)(sg_segments *</span>
<span class="p_add">+					sizeof(struct ufshcd_sg_entry)));</span>
<span class="p_add">+		else</span>
<span class="p_add">+			lrbp-&gt;utr_descriptor_ptr-&gt;prd_table_length =</span>
<span class="p_add">+				cpu_to_le16((u16) (sg_segments));</span>
 
 		prd_table = (struct ufshcd_sg_entry *)lrbp-&gt;ucd_prdt_ptr;
 
<span class="p_chunk">@@ -1410,6 +1440,7 @@</span> <span class="p_context"> static int ufshcd_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmd)</span>
 	switch (hba-&gt;ufshcd_state) {
 	case UFSHCD_STATE_OPERATIONAL:
 		break;
<span class="p_add">+	case UFSHCD_STATE_EH_SCHEDULED:</span>
 	case UFSHCD_STATE_RESET:
 		err = SCSI_MLQUEUE_HOST_BUSY;
 		goto out_unlock;
<span class="p_chunk">@@ -1465,7 +1496,7 @@</span> <span class="p_context"> static int ufshcd_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmd)</span>
 
 	ufshcd_comp_scsi_upiu(hba, lrbp);
 
<span class="p_del">-	err = ufshcd_map_sg(lrbp);</span>
<span class="p_add">+	err = ufshcd_map_sg(hba, lrbp);</span>
 	if (err) {
 		lrbp-&gt;cmd = NULL;
 		clear_bit_unlock(tag, &amp;hba-&gt;lrb_in_use);
<span class="p_chunk">@@ -2320,12 +2351,21 @@</span> <span class="p_context"> static void ufshcd_host_memory_configure(struct ufs_hba *hba)</span>
 				cpu_to_le32(upper_32_bits(cmd_desc_element_addr));
 
 		/* Response upiu and prdt offset should be in double words */
<span class="p_del">-		utrdlp[i].response_upiu_offset =</span>
<span class="p_add">+		if (hba-&gt;quirks &amp; UFSHCD_QUIRK_PRDT_BYTE_GRAN) {</span>
<span class="p_add">+			utrdlp[i].response_upiu_offset =</span>
<span class="p_add">+				cpu_to_le16(response_offset);</span>
<span class="p_add">+			utrdlp[i].prd_table_offset =</span>
<span class="p_add">+				cpu_to_le16(prdt_offset);</span>
<span class="p_add">+			utrdlp[i].response_upiu_length =</span>
<span class="p_add">+				cpu_to_le16(ALIGNED_UPIU_SIZE);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			utrdlp[i].response_upiu_offset =</span>
 				cpu_to_le16((response_offset &gt;&gt; 2));
<span class="p_del">-		utrdlp[i].prd_table_offset =</span>
<span class="p_add">+			utrdlp[i].prd_table_offset =</span>
 				cpu_to_le16((prdt_offset &gt;&gt; 2));
<span class="p_del">-		utrdlp[i].response_upiu_length =</span>
<span class="p_add">+			utrdlp[i].response_upiu_length =</span>
 				cpu_to_le16(ALIGNED_UPIU_SIZE &gt;&gt; 2);
<span class="p_add">+		}</span>
 
 		hba-&gt;lrb[i].utr_descriptor_ptr = (utrdlp + i);
 		hba-&gt;lrb[i].ucd_req_ptr =
<span class="p_chunk">@@ -3090,7 +3130,16 @@</span> <span class="p_context"> static int ufshcd_link_startup(struct ufs_hba *hba)</span>
 {
 	int ret;
 	int retries = DME_LINKSTARTUP_RETRIES;
<span class="p_add">+	bool link_startup_again = false;</span>
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If UFS device isn&#39;t active then we will have to issue link startup</span>
<span class="p_add">+	 * 2 times to make sure the device state move to active.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!ufshcd_is_ufs_dev_active(hba))</span>
<span class="p_add">+		link_startup_again = true;</span>
<span class="p_add">+</span>
<span class="p_add">+link_startup:</span>
 	do {
 		ufshcd_vops_link_startup_notify(hba, PRE_CHANGE);
 
<span class="p_chunk">@@ -3116,6 +3165,12 @@</span> <span class="p_context"> static int ufshcd_link_startup(struct ufs_hba *hba)</span>
 		/* failed to get the link up... retire */
 		goto out;
 
<span class="p_add">+	if (link_startup_again) {</span>
<span class="p_add">+		link_startup_again = false;</span>
<span class="p_add">+		retries = DME_LINKSTARTUP_RETRIES;</span>
<span class="p_add">+		goto link_startup;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (hba-&gt;quirks &amp; UFSHCD_QUIRK_BROKEN_LCC) {
 		ret = ufshcd_disable_device_tx_lcc(hba);
 		if (ret)
<span class="p_chunk">@@ -4158,7 +4213,7 @@</span> <span class="p_context"> static void ufshcd_check_errors(struct ufs_hba *hba)</span>
 			/* block commands from scsi mid-layer */
 			scsi_block_requests(hba-&gt;host);
 
<span class="p_del">-			hba-&gt;ufshcd_state = UFSHCD_STATE_ERROR;</span>
<span class="p_add">+			hba-&gt;ufshcd_state = UFSHCD_STATE_EH_SCHEDULED;</span>
 			schedule_work(&amp;hba-&gt;eh_work);
 		}
 	}
<span class="p_chunk">@@ -4965,6 +5020,76 @@</span> <span class="p_context"> static int ufshcd_tune_pa_hibern8time(struct ufs_hba *hba)</span>
 	return ret;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * ufshcd_quirk_tune_host_pa_tactivate - Ensures that host PA_TACTIVATE is</span>
<span class="p_add">+ * less than device PA_TACTIVATE time.</span>
<span class="p_add">+ * @hba: per-adapter instance</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Some UFS devices require host PA_TACTIVATE to be lower than device</span>
<span class="p_add">+ * PA_TACTIVATE, we need to enable UFS_DEVICE_QUIRK_HOST_PA_TACTIVATE quirk</span>
<span class="p_add">+ * for such devices.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns zero on success, non-zero error value on failure.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int ufshcd_quirk_tune_host_pa_tactivate(struct ufs_hba *hba)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	u32 granularity, peer_granularity;</span>
<span class="p_add">+	u32 pa_tactivate, peer_pa_tactivate;</span>
<span class="p_add">+	u32 pa_tactivate_us, peer_pa_tactivate_us;</span>
<span class="p_add">+	u8 gran_to_us_table[] = {1, 4, 8, 16, 32, 100};</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = ufshcd_dme_get(hba, UIC_ARG_MIB(PA_GRANULARITY),</span>
<span class="p_add">+				  &amp;granularity);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = ufshcd_dme_peer_get(hba, UIC_ARG_MIB(PA_GRANULARITY),</span>
<span class="p_add">+				  &amp;peer_granularity);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((granularity &lt; PA_GRANULARITY_MIN_VAL) ||</span>
<span class="p_add">+	    (granularity &gt; PA_GRANULARITY_MAX_VAL)) {</span>
<span class="p_add">+		dev_err(hba-&gt;dev, &quot;%s: invalid host PA_GRANULARITY %d&quot;,</span>
<span class="p_add">+			__func__, granularity);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((peer_granularity &lt; PA_GRANULARITY_MIN_VAL) ||</span>
<span class="p_add">+	    (peer_granularity &gt; PA_GRANULARITY_MAX_VAL)) {</span>
<span class="p_add">+		dev_err(hba-&gt;dev, &quot;%s: invalid device PA_GRANULARITY %d&quot;,</span>
<span class="p_add">+			__func__, peer_granularity);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = ufshcd_dme_get(hba, UIC_ARG_MIB(PA_TACTIVATE), &amp;pa_tactivate);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = ufshcd_dme_peer_get(hba, UIC_ARG_MIB(PA_TACTIVATE),</span>
<span class="p_add">+				  &amp;peer_pa_tactivate);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	pa_tactivate_us = pa_tactivate * gran_to_us_table[granularity - 1];</span>
<span class="p_add">+	peer_pa_tactivate_us = peer_pa_tactivate *</span>
<span class="p_add">+			     gran_to_us_table[peer_granularity - 1];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pa_tactivate_us &gt; peer_pa_tactivate_us) {</span>
<span class="p_add">+		u32 new_peer_pa_tactivate;</span>
<span class="p_add">+</span>
<span class="p_add">+		new_peer_pa_tactivate = pa_tactivate_us /</span>
<span class="p_add">+				      gran_to_us_table[peer_granularity - 1];</span>
<span class="p_add">+		new_peer_pa_tactivate++;</span>
<span class="p_add">+		ret = ufshcd_dme_peer_set(hba, UIC_ARG_MIB(PA_TACTIVATE),</span>
<span class="p_add">+					  new_peer_pa_tactivate);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void ufshcd_tune_unipro_params(struct ufs_hba *hba)
 {
 	if (ufshcd_is_unipro_pa_params_tuning_req(hba)) {
<span class="p_chunk">@@ -4975,6 +5100,11 @@</span> <span class="p_context"> static void ufshcd_tune_unipro_params(struct ufs_hba *hba)</span>
 	if (hba-&gt;dev_quirks &amp; UFS_DEVICE_QUIRK_PA_TACTIVATE)
 		/* set 1ms timeout for PA_TACTIVATE */
 		ufshcd_dme_set(hba, UIC_ARG_MIB(PA_TACTIVATE), 10);
<span class="p_add">+</span>
<span class="p_add">+	if (hba-&gt;dev_quirks &amp; UFS_DEVICE_QUIRK_HOST_PA_TACTIVATE)</span>
<span class="p_add">+		ufshcd_quirk_tune_host_pa_tactivate(hba);</span>
<span class="p_add">+</span>
<span class="p_add">+	ufshcd_vops_apply_dev_quirks(hba);</span>
 }
 
 /**
<span class="p_chunk">@@ -6515,10 +6645,12 @@</span> <span class="p_context"> int ufshcd_init(struct ufs_hba *hba, void __iomem *mmio_base, unsigned int irq)</span>
 	pm_runtime_get_sync(dev);
 
 	/*
<span class="p_del">-	 * The device-initialize-sequence hasn&#39;t been invoked yet.</span>
<span class="p_del">-	 * Set the device to power-off state</span>
<span class="p_add">+	 * We are assuming that device wasn&#39;t put in sleep/power-down</span>
<span class="p_add">+	 * state exclusively during the boot stage before kernel.</span>
<span class="p_add">+	 * This assumption helps avoid doing link startup twice during</span>
<span class="p_add">+	 * ufshcd_probe_hba().</span>
 	 */
<span class="p_del">-	ufshcd_set_ufs_dev_poweroff(hba);</span>
<span class="p_add">+	ufshcd_set_ufs_dev_active(hba);</span>
 
 	async_schedule(ufshcd_async_scan, hba);
 
<span class="p_header">diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h</span>
<span class="p_header">index 430bef111293..04509827fe64 100644</span>
<span class="p_header">--- a/drivers/scsi/ufs/ufshcd.h</span>
<span class="p_header">+++ b/drivers/scsi/ufs/ufshcd.h</span>
<span class="p_chunk">@@ -261,6 +261,7 @@</span> <span class="p_context"> struct ufs_pwr_mode_info {</span>
  * @pwr_change_notify: called before and after a power mode change
  *			is carried out to allow vendor spesific capabilities
  *			to be set.
<span class="p_add">+ * @apply_dev_quirks: called to apply device specific quirks</span>
  * @suspend: called during host controller PM callback
  * @resume: called during host controller PM callback
  * @dbg_register_dump: used to dump controller debug information
<span class="p_chunk">@@ -283,6 +284,7 @@</span> <span class="p_context"> struct ufs_hba_variant_ops {</span>
 					enum ufs_notify_change_status status,
 					struct ufs_pa_layer_attr *,
 					struct ufs_pa_layer_attr *);
<span class="p_add">+	int	(*apply_dev_quirks)(struct ufs_hba *);</span>
 	int     (*suspend)(struct ufs_hba *, enum ufs_pm_op);
 	int     (*resume)(struct ufs_hba *, enum ufs_pm_op);
 	void	(*dbg_register_dump)(struct ufs_hba *hba);
<span class="p_chunk">@@ -474,6 +476,12 @@</span> <span class="p_context"> struct ufs_hba {</span>
 	 */
 	#define UFSHCD_QUIRK_BROKEN_UFS_HCI_VERSION		UFS_BIT(5)
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This quirk needs to be enabled if the host contoller regards</span>
<span class="p_add">+	 * resolution of the values of PRDTO and PRDTL in UTRD as byte.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	#define UFSHCD_QUIRK_PRDT_BYTE_GRAN			UFS_BIT(7)</span>
<span class="p_add">+</span>
 	unsigned int quirks;	/* Deviations from standard UFSHCI spec. */
 
 	/* Device deviations from standard UFS device spec. */
<span class="p_chunk">@@ -799,6 +807,13 @@</span> <span class="p_context"> static inline int ufshcd_vops_pwr_change_notify(struct ufs_hba *hba,</span>
 	return -ENOTSUPP;
 }
 
<span class="p_add">+static inline int ufshcd_vops_apply_dev_quirks(struct ufs_hba *hba)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (hba-&gt;vops &amp;&amp; hba-&gt;vops-&gt;apply_dev_quirks)</span>
<span class="p_add">+		return hba-&gt;vops-&gt;apply_dev_quirks(hba);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline int ufshcd_vops_suspend(struct ufs_hba *hba, enum ufs_pm_op op)
 {
 	if (hba-&gt;vops &amp;&amp; hba-&gt;vops-&gt;suspend)
<span class="p_header">diff --git a/drivers/scsi/ufs/unipro.h b/drivers/scsi/ufs/unipro.h</span>
<span class="p_header">index eff8b5675575..23129d7b2678 100644</span>
<span class="p_header">--- a/drivers/scsi/ufs/unipro.h</span>
<span class="p_header">+++ b/drivers/scsi/ufs/unipro.h</span>
<span class="p_chunk">@@ -123,6 +123,7 @@</span> <span class="p_context"></span>
 #define PA_MAXRXHSGEAR		0x1587
 #define PA_RXHSUNTERMCAP	0x15A5
 #define PA_RXLSTERMCAP		0x15A6
<span class="p_add">+#define PA_GRANULARITY		0x15AA</span>
 #define PA_PACPREQTIMEOUT	0x1590
 #define PA_PACPREQEOBTIMEOUT	0x1591
 #define PA_HIBERN8TIME		0x15A7
<span class="p_chunk">@@ -158,6 +159,9 @@</span> <span class="p_context"></span>
 #define VS_DEBUGOMC		0xD09E
 #define VS_POWERSTATE		0xD083
 
<span class="p_add">+#define PA_GRANULARITY_MIN_VAL	1</span>
<span class="p_add">+#define PA_GRANULARITY_MAX_VAL	6</span>
<span class="p_add">+</span>
 /* PHY Adapter Protocol Constants */
 #define PA_MAXDATALANES	4
 
<span class="p_header">diff --git a/drivers/staging/android/ashmem.c b/drivers/staging/android/ashmem.c</span>
<span class="p_header">index ca9a53c03f0f..2b770cb0c488 100644</span>
<span class="p_header">--- a/drivers/staging/android/ashmem.c</span>
<span class="p_header">+++ b/drivers/staging/android/ashmem.c</span>
<span class="p_chunk">@@ -405,6 +405,7 @@</span> <span class="p_context"> static int ashmem_mmap(struct file *file, struct vm_area_struct *vma)</span>
 			ret = PTR_ERR(vmfile);
 			goto out;
 		}
<span class="p_add">+		vmfile-&gt;f_mode |= FMODE_LSEEK;</span>
 		asma-&gt;file = vmfile;
 	}
 	get_file(asma-&gt;file);
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_omap.c b/drivers/tty/serial/8250/8250_omap.c</span>
<span class="p_header">index 61ad6c3b20a0..f4eb807a2616 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_omap.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_omap.c</span>
<span class="p_chunk">@@ -1075,15 +1075,15 @@</span> <span class="p_context"> static int omap8250_no_handle_irq(struct uart_port *port)</span>
 }
 
 static const u8 am3352_habit = OMAP_DMA_TX_KICK | UART_ERRATA_CLOCK_DISABLE;
<span class="p_del">-static const u8 am4372_habit = UART_ERRATA_CLOCK_DISABLE;</span>
<span class="p_add">+static const u8 dra742_habit = UART_ERRATA_CLOCK_DISABLE;</span>
 
 static const struct of_device_id omap8250_dt_ids[] = {
 	{ .compatible = &quot;ti,omap2-uart&quot; },
 	{ .compatible = &quot;ti,omap3-uart&quot; },
 	{ .compatible = &quot;ti,omap4-uart&quot; },
 	{ .compatible = &quot;ti,am3352-uart&quot;, .data = &amp;am3352_habit, },
<span class="p_del">-	{ .compatible = &quot;ti,am4372-uart&quot;, .data = &amp;am4372_habit, },</span>
<span class="p_del">-	{ .compatible = &quot;ti,dra742-uart&quot;, .data = &amp;am4372_habit, },</span>
<span class="p_add">+	{ .compatible = &quot;ti,am4372-uart&quot;, .data = &amp;am3352_habit, },</span>
<span class="p_add">+	{ .compatible = &quot;ti,dra742-uart&quot;, .data = &amp;dra742_habit, },</span>
 	{},
 };
 MODULE_DEVICE_TABLE(of, omap8250_dt_ids);
<span class="p_chunk">@@ -1218,9 +1218,6 @@</span> <span class="p_context"> static int omap8250_probe(struct platform_device *pdev)</span>
 			priv-&gt;omap8250_dma.rx_size = RX_TRIGGER;
 			priv-&gt;omap8250_dma.rxconf.src_maxburst = RX_TRIGGER;
 			priv-&gt;omap8250_dma.txconf.dst_maxburst = TX_TRIGGER;
<span class="p_del">-</span>
<span class="p_del">-			if (of_machine_is_compatible(&quot;ti,am33xx&quot;))</span>
<span class="p_del">-				priv-&gt;habit |= OMAP_DMA_TX_KICK;</span>
 			/*
 			 * pause is currently not supported atleast on omap-sdma
 			 * and edma on most earlier kernels.
<span class="p_header">diff --git a/drivers/usb/chipidea/ci_hdrc_msm.c b/drivers/usb/chipidea/ci_hdrc_msm.c</span>
<span class="p_header">index 3889809fd0c4..37591a4b1346 100644</span>
<span class="p_header">--- a/drivers/usb/chipidea/ci_hdrc_msm.c</span>
<span class="p_header">+++ b/drivers/usb/chipidea/ci_hdrc_msm.c</span>
<span class="p_chunk">@@ -24,7 +24,6 @@</span> <span class="p_context"> static void ci_hdrc_msm_notify_event(struct ci_hdrc *ci, unsigned event)</span>
 	switch (event) {
 	case CI_HDRC_CONTROLLER_RESET_EVENT:
 		dev_dbg(dev, &quot;CI_HDRC_CONTROLLER_RESET_EVENT received\n&quot;);
<span class="p_del">-		writel(0, USB_AHBBURST);</span>
 		/* use AHB transactor, allow posted data writes */
 		writel(0x8, USB_AHBMODE);
 		usb_phy_init(ci-&gt;usb_phy);
<span class="p_chunk">@@ -47,7 +46,8 @@</span> <span class="p_context"> static struct ci_hdrc_platform_data ci_hdrc_msm_platdata = {</span>
 	.name			= &quot;ci_hdrc_msm&quot;,
 	.capoffset		= DEF_CAPOFFSET,
 	.flags			= CI_HDRC_REGS_SHARED |
<span class="p_del">-				  CI_HDRC_DISABLE_STREAMING,</span>
<span class="p_add">+				  CI_HDRC_DISABLE_STREAMING |</span>
<span class="p_add">+				  CI_HDRC_OVERRIDE_AHB_BURST,</span>
 
 	.notify_event		= ci_hdrc_msm_notify_event,
 };
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index 5dc6bfc91f4b..ce603dcbd493 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -174,6 +174,7 @@</span> <span class="p_context"> void dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,</span>
 		int status)
 {
 	struct dwc3			*dwc = dep-&gt;dwc;
<span class="p_add">+	unsigned int			unmap_after_complete = false;</span>
 
 	req-&gt;started = false;
 	list_del(&amp;req-&gt;list);
<span class="p_chunk">@@ -182,11 +183,19 @@</span> <span class="p_context"> void dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,</span>
 	if (req-&gt;request.status == -EINPROGRESS)
 		req-&gt;request.status = status;
 
<span class="p_del">-	if (dwc-&gt;ep0_bounced &amp;&amp; dep-&gt;number &lt;= 1)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * NOTICE we don&#39;t want to unmap before calling -&gt;complete() if we&#39;re</span>
<span class="p_add">+	 * dealing with a bounced ep0 request. If we unmap it here, we would end</span>
<span class="p_add">+	 * up overwritting the contents of req-&gt;buf and this could confuse the</span>
<span class="p_add">+	 * gadget driver.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (dwc-&gt;ep0_bounced &amp;&amp; dep-&gt;number &lt;= 1) {</span>
 		dwc-&gt;ep0_bounced = false;
<span class="p_del">-</span>
<span class="p_del">-	usb_gadget_unmap_request(&amp;dwc-&gt;gadget, &amp;req-&gt;request,</span>
<span class="p_del">-			req-&gt;direction);</span>
<span class="p_add">+		unmap_after_complete = true;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		usb_gadget_unmap_request(&amp;dwc-&gt;gadget,</span>
<span class="p_add">+				&amp;req-&gt;request, req-&gt;direction);</span>
<span class="p_add">+	}</span>
 
 	trace_dwc3_gadget_giveback(req);
 
<span class="p_chunk">@@ -194,6 +203,10 @@</span> <span class="p_context"> void dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,</span>
 	usb_gadget_giveback_request(&amp;dep-&gt;endpoint, &amp;req-&gt;request);
 	spin_lock(&amp;dwc-&gt;lock);
 
<span class="p_add">+	if (unmap_after_complete)</span>
<span class="p_add">+		usb_gadget_unmap_request(&amp;dwc-&gt;gadget,</span>
<span class="p_add">+				&amp;req-&gt;request, req-&gt;direction);</span>
<span class="p_add">+</span>
 	if (dep-&gt;number &gt; 1)
 		pm_runtime_put(dwc-&gt;dev);
 }
<span class="p_header">diff --git a/drivers/usb/dwc3/host.c b/drivers/usb/dwc3/host.c</span>
<span class="p_header">index f6533c68fed1..626d87d545fc 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/host.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/host.c</span>
<span class="p_chunk">@@ -21,11 +21,12 @@</span> <span class="p_context"></span>
 
 int dwc3_host_init(struct dwc3 *dwc)
 {
<span class="p_del">-	struct property_entry	props[2];</span>
<span class="p_add">+	struct property_entry	props[3];</span>
 	struct platform_device	*xhci;
 	int			ret, irq;
 	struct resource		*res;
 	struct platform_device	*dwc3_pdev = to_platform_device(dwc-&gt;dev);
<span class="p_add">+	int			prop_idx = 0;</span>
 
 	irq = platform_get_irq_byname(dwc3_pdev, &quot;host&quot;);
 	if (irq == -EPROBE_DEFER)
<span class="p_chunk">@@ -89,8 +90,22 @@</span> <span class="p_context"> int dwc3_host_init(struct dwc3 *dwc)</span>
 
 	memset(props, 0, sizeof(struct property_entry) * ARRAY_SIZE(props));
 
<span class="p_del">-	if (dwc-&gt;usb3_lpm_capable) {</span>
<span class="p_del">-		props[0].name = &quot;usb3-lpm-capable&quot;;</span>
<span class="p_add">+	if (dwc-&gt;usb3_lpm_capable)</span>
<span class="p_add">+		props[prop_idx++].name = &quot;usb3-lpm-capable&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+	/**</span>
<span class="p_add">+	 * WORKAROUND: dwc3 revisions &lt;=3.00a have a limitation</span>
<span class="p_add">+	 * where Port Disable command doesn&#39;t work.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * The suggested workaround is that we avoid Port Disable</span>
<span class="p_add">+	 * completely.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * This following flag tells XHCI to do just that.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (dwc-&gt;revision &lt;= DWC3_REVISION_300A)</span>
<span class="p_add">+		props[prop_idx++].name = &quot;quirk-broken-port-ped&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (prop_idx) {</span>
 		ret = platform_device_add_properties(xhci, props);
 		if (ret) {
 			dev_err(dwc-&gt;dev, &quot;failed to add properties to xHCI\n&quot;);
<span class="p_header">diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">index 0ef16900efed..1d41637a53e5 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-hub.c</span>
<span class="p_chunk">@@ -458,6 +458,12 @@</span> <span class="p_context"> static void xhci_disable_port(struct usb_hcd *hcd, struct xhci_hcd *xhci,</span>
 		return;
 	}
 
<span class="p_add">+	if (xhci-&gt;quirks &amp; XHCI_BROKEN_PORT_PED) {</span>
<span class="p_add">+		xhci_dbg(xhci,</span>
<span class="p_add">+			 &quot;Broken Port Enabled/Disabled, ignoring port disable request.\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* Write 1 to disable the port */
 	writel(port_status | PORT_PE, addr);
 	port_status = readl(addr);
<span class="p_header">diff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c</span>
<span class="p_header">index 5895e84f9dcc..be1572331a64 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-plat.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-plat.c</span>
<span class="p_chunk">@@ -223,6 +223,9 @@</span> <span class="p_context"> static int xhci_plat_probe(struct platform_device *pdev)</span>
 	if (device_property_read_bool(&amp;pdev-&gt;dev, &quot;usb3-lpm-capable&quot;))
 		xhci-&gt;quirks |= XHCI_LPM_SUPPORT;
 
<span class="p_add">+	if (device_property_read_bool(&amp;pdev-&gt;dev, &quot;quirk-broken-port-ped&quot;))</span>
<span class="p_add">+		xhci-&gt;quirks |= XHCI_BROKEN_PORT_PED;</span>
<span class="p_add">+</span>
 	hcd-&gt;usb_phy = devm_usb_get_phy_by_phandle(&amp;pdev-&gt;dev, &quot;usb-phy&quot;, 0);
 	if (IS_ERR(hcd-&gt;usb_phy)) {
 		ret = PTR_ERR(hcd-&gt;usb_phy);
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index c525722aa934..f97b009ffc40 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -1657,6 +1657,9 @@</span> <span class="p_context"> struct xhci_hcd {</span>
 #define XHCI_SSIC_PORT_UNUSED	(1 &lt;&lt; 22)
 #define XHCI_NO_64BIT_SUPPORT	(1 &lt;&lt; 23)
 #define XHCI_MISSING_CAS	(1 &lt;&lt; 24)
<span class="p_add">+/* For controller with a broken Port Disable implementation */</span>
<span class="p_add">+#define XHCI_BROKEN_PORT_PED	(1 &lt;&lt; 25)</span>
<span class="p_add">+</span>
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */
<span class="p_header">diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">index 16cc18369111..9129f6cb8230 100644</span>
<span class="p_header">--- a/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">+++ b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_chunk">@@ -2071,6 +2071,20 @@</span> <span class="p_context"> UNUSUAL_DEV(  0x1370, 0x6828, 0x0110, 0x0110,</span>
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_IGNORE_RESIDUE ),
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Reported by Tobias Jakobi &lt;tjakobi@math.uni-bielefeld.de&gt;</span>
<span class="p_add">+ * The INIC-3619 bridge is used in the StarTech SLSODDU33B</span>
<span class="p_add">+ * SATA-USB enclosure for slimline optical drives.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The quirk enables MakeMKV to properly exchange keys with</span>
<span class="p_add">+ * an installed BD drive.</span>
<span class="p_add">+ */</span>
<span class="p_add">+UNUSUAL_DEV(  0x13fd, 0x3609, 0x0209, 0x0209,</span>
<span class="p_add">+		&quot;Initio Corporation&quot;,</span>
<span class="p_add">+		&quot;INIC-3619&quot;,</span>
<span class="p_add">+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,</span>
<span class="p_add">+		US_FL_IGNORE_RESIDUE ),</span>
<span class="p_add">+</span>
 /* Reported by Qinglin Ye &lt;yestyle@gmail.com&gt; */
 UNUSUAL_DEV(  0x13fe, 0x3600, 0x0100, 0x0100,
 		&quot;Kingston&quot;,
<span class="p_header">diff --git a/drivers/watchdog/s3c2410_wdt.c b/drivers/watchdog/s3c2410_wdt.c</span>
<span class="p_header">index 59e95762a6de..c5a567a73f59 100644</span>
<span class="p_header">--- a/drivers/watchdog/s3c2410_wdt.c</span>
<span class="p_header">+++ b/drivers/watchdog/s3c2410_wdt.c</span>
<span class="p_chunk">@@ -46,6 +46,7 @@</span> <span class="p_context"></span>
 #define S3C2410_WTCON		0x00
 #define S3C2410_WTDAT		0x04
 #define S3C2410_WTCNT		0x08
<span class="p_add">+#define S3C2410_WTCLRINT	0x0c</span>
 
 #define S3C2410_WTCNT_MAXCNT	0xffff
 
<span class="p_chunk">@@ -72,6 +73,7 @@</span> <span class="p_context"></span>
 #define EXYNOS5_WDT_MASK_RESET_REG_OFFSET	0x040c
 #define QUIRK_HAS_PMU_CONFIG			(1 &lt;&lt; 0)
 #define QUIRK_HAS_RST_STAT			(1 &lt;&lt; 1)
<span class="p_add">+#define QUIRK_HAS_WTCLRINT_REG			(1 &lt;&lt; 2)</span>
 
 /* These quirks require that we have a PMU register map */
 #define QUIRKS_HAVE_PMUREG			(QUIRK_HAS_PMU_CONFIG | \
<span class="p_chunk">@@ -143,13 +145,18 @@</span> <span class="p_context"> static const struct s3c2410_wdt_variant drv_data_s3c2410 = {</span>
 };
 
 #ifdef CONFIG_OF
<span class="p_add">+static const struct s3c2410_wdt_variant drv_data_s3c6410 = {</span>
<span class="p_add">+	.quirks = QUIRK_HAS_WTCLRINT_REG,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct s3c2410_wdt_variant drv_data_exynos5250  = {
 	.disable_reg = EXYNOS5_WDT_DISABLE_REG_OFFSET,
 	.mask_reset_reg = EXYNOS5_WDT_MASK_RESET_REG_OFFSET,
 	.mask_bit = 20,
 	.rst_stat_reg = EXYNOS5_RST_STAT_REG_OFFSET,
 	.rst_stat_bit = 20,
<span class="p_del">-	.quirks = QUIRK_HAS_PMU_CONFIG | QUIRK_HAS_RST_STAT,</span>
<span class="p_add">+	.quirks = QUIRK_HAS_PMU_CONFIG | QUIRK_HAS_RST_STAT \</span>
<span class="p_add">+		  | QUIRK_HAS_WTCLRINT_REG,</span>
 };
 
 static const struct s3c2410_wdt_variant drv_data_exynos5420 = {
<span class="p_chunk">@@ -158,7 +165,8 @@</span> <span class="p_context"> static const struct s3c2410_wdt_variant drv_data_exynos5420 = {</span>
 	.mask_bit = 0,
 	.rst_stat_reg = EXYNOS5_RST_STAT_REG_OFFSET,
 	.rst_stat_bit = 9,
<span class="p_del">-	.quirks = QUIRK_HAS_PMU_CONFIG | QUIRK_HAS_RST_STAT,</span>
<span class="p_add">+	.quirks = QUIRK_HAS_PMU_CONFIG | QUIRK_HAS_RST_STAT \</span>
<span class="p_add">+		  | QUIRK_HAS_WTCLRINT_REG,</span>
 };
 
 static const struct s3c2410_wdt_variant drv_data_exynos7 = {
<span class="p_chunk">@@ -167,12 +175,15 @@</span> <span class="p_context"> static const struct s3c2410_wdt_variant drv_data_exynos7 = {</span>
 	.mask_bit = 23,
 	.rst_stat_reg = EXYNOS5_RST_STAT_REG_OFFSET,
 	.rst_stat_bit = 23,	/* A57 WDTRESET */
<span class="p_del">-	.quirks = QUIRK_HAS_PMU_CONFIG | QUIRK_HAS_RST_STAT,</span>
<span class="p_add">+	.quirks = QUIRK_HAS_PMU_CONFIG | QUIRK_HAS_RST_STAT \</span>
<span class="p_add">+		  | QUIRK_HAS_WTCLRINT_REG,</span>
 };
 
 static const struct of_device_id s3c2410_wdt_match[] = {
 	{ .compatible = &quot;samsung,s3c2410-wdt&quot;,
 	  .data = &amp;drv_data_s3c2410 },
<span class="p_add">+	{ .compatible = &quot;samsung,s3c6410-wdt&quot;,</span>
<span class="p_add">+	  .data = &amp;drv_data_s3c6410 },</span>
 	{ .compatible = &quot;samsung,exynos5250-wdt&quot;,
 	  .data = &amp;drv_data_exynos5250 },
 	{ .compatible = &quot;samsung,exynos5420-wdt&quot;,
<span class="p_chunk">@@ -418,6 +429,10 @@</span> <span class="p_context"> static irqreturn_t s3c2410wdt_irq(int irqno, void *param)</span>
 	dev_info(wdt-&gt;dev, &quot;watchdog timer expired (irq)\n&quot;);
 
 	s3c2410wdt_keepalive(&amp;wdt-&gt;wdt_device);
<span class="p_add">+</span>
<span class="p_add">+	if (wdt-&gt;drv_data-&gt;quirks &amp; QUIRK_HAS_WTCLRINT_REG)</span>
<span class="p_add">+		writel(0x1, wdt-&gt;reg_base + S3C2410_WTCLRINT);</span>
<span class="p_add">+</span>
 	return IRQ_HANDLED;
 }
 
<span class="p_header">diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c</span>
<span class="p_header">index 87457227812c..bdd32925a15e 100644</span>
<span class="p_header">--- a/fs/cifs/smb2pdu.c</span>
<span class="p_header">+++ b/fs/cifs/smb2pdu.c</span>
<span class="p_chunk">@@ -1104,6 +1104,10 @@</span> <span class="p_context"> SMB2_tcon(const unsigned int xid, struct cifs_ses *ses, const char *tree,</span>
 		return -EINVAL;
 	}
 
<span class="p_add">+	/* SMB2 TREE_CONNECT request must be called with TreeId == 0 */</span>
<span class="p_add">+	if (tcon)</span>
<span class="p_add">+		tcon-&gt;tid = 0;</span>
<span class="p_add">+</span>
 	rc = small_smb2_init(SMB2_TREE_CONNECT, tcon, (void **) &amp;req);
 	if (rc) {
 		kfree(unc_path);
<span class="p_header">diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c</span>
<span class="p_header">index 67c24351a67f..cd261c8de53a 100644</span>
<span class="p_header">--- a/fs/orangefs/super.c</span>
<span class="p_header">+++ b/fs/orangefs/super.c</span>
<span class="p_chunk">@@ -263,8 +263,13 @@</span> <span class="p_context"> int orangefs_remount(struct orangefs_sb_info_s *orangefs_sb)</span>
 		if (!new_op)
 			return -ENOMEM;
 		new_op-&gt;upcall.req.features.features = 0;
<span class="p_del">-		ret = service_operation(new_op, &quot;orangefs_features&quot;, 0);</span>
<span class="p_del">-		orangefs_features = new_op-&gt;downcall.resp.features.features;</span>
<span class="p_add">+		ret = service_operation(new_op, &quot;orangefs_features&quot;,</span>
<span class="p_add">+		    ORANGEFS_OP_PRIORITY | ORANGEFS_OP_NO_MUTEX);</span>
<span class="p_add">+		if (!ret)</span>
<span class="p_add">+			orangefs_features =</span>
<span class="p_add">+			    new_op-&gt;downcall.resp.features.features;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			orangefs_features = 0;</span>
 		op_release(new_op);
 	} else {
 		orangefs_features = 0;
<span class="p_header">diff --git a/fs/sysfs/file.c b/fs/sysfs/file.c</span>
<span class="p_header">index b803213d1307..39c75a86c67f 100644</span>
<span class="p_header">--- a/fs/sysfs/file.c</span>
<span class="p_header">+++ b/fs/sysfs/file.c</span>
<span class="p_chunk">@@ -108,7 +108,7 @@</span> <span class="p_context"> static ssize_t sysfs_kf_read(struct kernfs_open_file *of, char *buf,</span>
 {
 	const struct sysfs_ops *ops = sysfs_file_ops(of-&gt;kn);
 	struct kobject *kobj = of-&gt;kn-&gt;parent-&gt;priv;
<span class="p_del">-	size_t len;</span>
<span class="p_add">+	ssize_t len;</span>
 
 	/*
 	 * If buf != of-&gt;prealloc_buf, we don&#39;t know how
<span class="p_chunk">@@ -117,13 +117,15 @@</span> <span class="p_context"> static ssize_t sysfs_kf_read(struct kernfs_open_file *of, char *buf,</span>
 	if (WARN_ON_ONCE(buf != of-&gt;prealloc_buf))
 		return 0;
 	len = ops-&gt;show(kobj, of-&gt;kn-&gt;priv, buf);
<span class="p_add">+	if (len &lt; 0)</span>
<span class="p_add">+		return len;</span>
 	if (pos) {
 		if (len &lt;= pos)
 			return 0;
 		len -= pos;
 		memmove(buf, buf + pos, len);
 	}
<span class="p_del">-	return min(count, len);</span>
<span class="p_add">+	return min_t(ssize_t, count, len);</span>
 }
 
 /* kernfs write callback for regular sysfs files */
<span class="p_header">diff --git a/fs/xfs/xfs_bmap_util.c b/fs/xfs/xfs_bmap_util.c</span>
<span class="p_header">index 5c395e485170..5328ecdd03d4 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_bmap_util.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_bmap_util.c</span>
<span class="p_chunk">@@ -1318,8 +1318,16 @@</span> <span class="p_context"> xfs_free_file_space(</span>
 	/*
 	 * Now that we&#39;ve unmap all full blocks we&#39;ll have to zero out any
 	 * partial block at the beginning and/or end.  xfs_zero_range is
<span class="p_del">-	 * smart enough to skip any holes, including those we just created.</span>
<span class="p_add">+	 * smart enough to skip any holes, including those we just created,</span>
<span class="p_add">+	 * but we must take care not to zero beyond EOF and enlarge i_size.</span>
 	 */
<span class="p_add">+</span>
<span class="p_add">+	if (offset &gt;= XFS_ISIZE(ip))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (offset + len &gt; XFS_ISIZE(ip))</span>
<span class="p_add">+		len = XFS_ISIZE(ip) - offset;</span>
<span class="p_add">+</span>
 	return xfs_zero_range(ip, offset, len, NULL);
 }
 
<span class="p_header">diff --git a/include/drm/i915_pciids.h b/include/drm/i915_pciids.h</span>
<span class="p_header">index 0d5f4268d75f..61766a420f6b 100644</span>
<span class="p_header">--- a/include/drm/i915_pciids.h</span>
<span class="p_header">+++ b/include/drm/i915_pciids.h</span>
<span class="p_chunk">@@ -226,23 +226,18 @@</span> <span class="p_context"></span>
 	INTEL_VGA_DEVICE(0x162A, info), /* Server */ \
 	INTEL_VGA_DEVICE(0x162D, info)  /* Workstation */
 
<span class="p_del">-#define INTEL_BDW_RSVDM_IDS(info) \</span>
<span class="p_add">+#define INTEL_BDW_RSVD_IDS(info) \</span>
 	INTEL_VGA_DEVICE(0x1632, info), /* ULT */ \
 	INTEL_VGA_DEVICE(0x1636, info), /* ULT */ \
 	INTEL_VGA_DEVICE(0x163B, info), /* Iris */ \
<span class="p_del">-	INTEL_VGA_DEVICE(0x163E, info)  /* ULX */</span>
<span class="p_del">-</span>
<span class="p_del">-#define INTEL_BDW_RSVDD_IDS(info) \</span>
<span class="p_add">+	INTEL_VGA_DEVICE(0x163E, info), /* ULX */ \</span>
 	INTEL_VGA_DEVICE(0x163A, info), /* Server */ \
 	INTEL_VGA_DEVICE(0x163D, info)  /* Workstation */
 
 #define INTEL_BDW_IDS(info) \
 	INTEL_BDW_GT12_IDS(info), \
 	INTEL_BDW_GT3_IDS(info), \
<span class="p_del">-	INTEL_BDW_RSVDM_IDS(info), \</span>
<span class="p_del">-	INTEL_BDW_GT12_IDS(info), \</span>
<span class="p_del">-	INTEL_BDW_GT3_IDS(info), \</span>
<span class="p_del">-	INTEL_BDW_RSVDD_IDS(info)</span>
<span class="p_add">+	INTEL_BDW_RSVD_IDS(info)</span>
 
 #define INTEL_CHV_IDS(info) \
 	INTEL_VGA_DEVICE(0x22b0, info), \
<span class="p_header">diff --git a/include/drm/ttm/ttm_object.h b/include/drm/ttm/ttm_object.h</span>
<span class="p_header">index ed953f98f0e1..1487011fe057 100644</span>
<span class="p_header">--- a/include/drm/ttm/ttm_object.h</span>
<span class="p_header">+++ b/include/drm/ttm/ttm_object.h</span>
<span class="p_chunk">@@ -229,6 +229,8 @@</span> <span class="p_context"> extern void ttm_base_object_unref(struct ttm_base_object **p_base);</span>
  * @ref_type: The type of reference.
  * @existed: Upon completion, indicates that an identical reference object
  * already existed, and the refcount was upped on that object instead.
<span class="p_add">+ * @require_existed: Fail with -EPERM if an identical ref object didn&#39;t</span>
<span class="p_add">+ * already exist.</span>
  *
  * Checks that the base object is shareable and adds a ref object to it.
  *
<span class="p_chunk">@@ -243,7 +245,8 @@</span> <span class="p_context"> extern void ttm_base_object_unref(struct ttm_base_object **p_base);</span>
  */
 extern int ttm_ref_object_add(struct ttm_object_file *tfile,
 			      struct ttm_base_object *base,
<span class="p_del">-			      enum ttm_ref_type ref_type, bool *existed);</span>
<span class="p_add">+			      enum ttm_ref_type ref_type, bool *existed,</span>
<span class="p_add">+			      bool require_existed);</span>
 
 extern bool ttm_ref_object_exists(struct ttm_object_file *tfile,
 				  struct ttm_base_object *base);
<span class="p_header">diff --git a/include/linux/arm-smccc.h b/include/linux/arm-smccc.h</span>
<span class="p_header">index b5abfda80465..4c5bca38c653 100644</span>
<span class="p_header">--- a/include/linux/arm-smccc.h</span>
<span class="p_header">+++ b/include/linux/arm-smccc.h</span>
<span class="p_chunk">@@ -14,9 +14,6 @@</span> <span class="p_context"></span>
 #ifndef __LINUX_ARM_SMCCC_H
 #define __LINUX_ARM_SMCCC_H
 
<span class="p_del">-#include &lt;linux/linkage.h&gt;</span>
<span class="p_del">-#include &lt;linux/types.h&gt;</span>
<span class="p_del">-</span>
 /*
  * This file provides common defines for ARM SMC Calling Convention as
  * specified in
<span class="p_chunk">@@ -60,6 +57,13 @@</span> <span class="p_context"></span>
 #define ARM_SMCCC_OWNER_TRUSTED_OS	50
 #define ARM_SMCCC_OWNER_TRUSTED_OS_END	63
 
<span class="p_add">+#define ARM_SMCCC_QUIRK_NONE		0</span>
<span class="p_add">+#define ARM_SMCCC_QUIRK_QCOM_A6		1 /* Save/restore register a6 */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASSEMBLY__</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
 /**
  * struct arm_smccc_res - Result from SMC/HVC call
  * @a0-a3 result values from registers 0 to 3
<span class="p_chunk">@@ -72,33 +76,59 @@</span> <span class="p_context"> struct arm_smccc_res {</span>
 };
 
 /**
<span class="p_del">- * arm_smccc_smc() - make SMC calls</span>
<span class="p_add">+ * struct arm_smccc_quirk - Contains quirk information</span>
<span class="p_add">+ * @id: quirk identification</span>
<span class="p_add">+ * @state: quirk specific information</span>
<span class="p_add">+ * @a6: Qualcomm quirk entry for returning post-smc call contents of a6</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct arm_smccc_quirk {</span>
<span class="p_add">+	int	id;</span>
<span class="p_add">+	union {</span>
<span class="p_add">+		unsigned long a6;</span>
<span class="p_add">+	} state;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * __arm_smccc_smc() - make SMC calls</span>
  * @a0-a7: arguments passed in registers 0 to 7
  * @res: result values from registers 0 to 3
<span class="p_add">+ * @quirk: points to an arm_smccc_quirk, or NULL when no quirks are required.</span>
  *
  * This function is used to make SMC calls following SMC Calling Convention.
  * The content of the supplied param are copied to registers 0 to 7 prior
  * to the SMC instruction. The return values are updated with the content
<span class="p_del">- * from register 0 to 3 on return from the SMC instruction.</span>
<span class="p_add">+ * from register 0 to 3 on return from the SMC instruction.  An optional</span>
<span class="p_add">+ * quirk structure provides vendor specific behavior.</span>
  */
<span class="p_del">-asmlinkage void arm_smccc_smc(unsigned long a0, unsigned long a1,</span>
<span class="p_add">+asmlinkage void __arm_smccc_smc(unsigned long a0, unsigned long a1,</span>
 			unsigned long a2, unsigned long a3, unsigned long a4,
 			unsigned long a5, unsigned long a6, unsigned long a7,
<span class="p_del">-			struct arm_smccc_res *res);</span>
<span class="p_add">+			struct arm_smccc_res *res, struct arm_smccc_quirk *quirk);</span>
 
 /**
<span class="p_del">- * arm_smccc_hvc() - make HVC calls</span>
<span class="p_add">+ * __arm_smccc_hvc() - make HVC calls</span>
  * @a0-a7: arguments passed in registers 0 to 7
  * @res: result values from registers 0 to 3
<span class="p_add">+ * @quirk: points to an arm_smccc_quirk, or NULL when no quirks are required.</span>
  *
  * This function is used to make HVC calls following SMC Calling
  * Convention.  The content of the supplied param are copied to registers 0
  * to 7 prior to the HVC instruction. The return values are updated with
<span class="p_del">- * the content from register 0 to 3 on return from the HVC instruction.</span>
<span class="p_add">+ * the content from register 0 to 3 on return from the HVC instruction.  An</span>
<span class="p_add">+ * optional quirk structure provides vendor specific behavior.</span>
  */
<span class="p_del">-asmlinkage void arm_smccc_hvc(unsigned long a0, unsigned long a1,</span>
<span class="p_add">+asmlinkage void __arm_smccc_hvc(unsigned long a0, unsigned long a1,</span>
 			unsigned long a2, unsigned long a3, unsigned long a4,
 			unsigned long a5, unsigned long a6, unsigned long a7,
<span class="p_del">-			struct arm_smccc_res *res);</span>
<span class="p_add">+			struct arm_smccc_res *res, struct arm_smccc_quirk *quirk);</span>
<span class="p_add">+</span>
<span class="p_add">+#define arm_smccc_smc(...) __arm_smccc_smc(__VA_ARGS__, NULL)</span>
<span class="p_add">+</span>
<span class="p_add">+#define arm_smccc_smc_quirk(...) __arm_smccc_smc(__VA_ARGS__)</span>
<span class="p_add">+</span>
<span class="p_add">+#define arm_smccc_hvc(...) __arm_smccc_hvc(__VA_ARGS__, NULL)</span>
<span class="p_add">+</span>
<span class="p_add">+#define arm_smccc_hvc_quirk(...) __arm_smccc_hvc(__VA_ARGS__)</span>
 
<span class="p_add">+#endif /*__ASSEMBLY__*/</span>
 #endif /*__LINUX_ARM_SMCCC_H*/
<span class="p_header">diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h</span>
<span class="p_header">index f020ab4079d3..3e5dbbe75f70 100644</span>
<span class="p_header">--- a/include/linux/pci_ids.h</span>
<span class="p_header">+++ b/include/linux/pci_ids.h</span>
<span class="p_chunk">@@ -2513,6 +2513,8 @@</span> <span class="p_context"></span>
 #define PCI_DEVICE_ID_KORENIX_JETCARDF2	0x1700
 #define PCI_DEVICE_ID_KORENIX_JETCARDF3	0x17ff
 
<span class="p_add">+#define PCI_VENDOR_ID_HUAWEI         	0x19e5</span>
<span class="p_add">+</span>
 #define PCI_VENDOR_ID_NETRONOME		0x19ee
 #define PCI_DEVICE_ID_NETRONOME_NFP3200	0x3200
 #define PCI_DEVICE_ID_NETRONOME_NFP3240	0x3240
<span class="p_header">diff --git a/include/linux/random.h b/include/linux/random.h</span>
<span class="p_header">index 7bd2403e4fef..16ab429735a7 100644</span>
<span class="p_header">--- a/include/linux/random.h</span>
<span class="p_header">+++ b/include/linux/random.h</span>
<span class="p_chunk">@@ -37,7 +37,6 @@</span> <span class="p_context"> extern void get_random_bytes(void *buf, int nbytes);</span>
 extern int add_random_ready_callback(struct random_ready_callback *rdy);
 extern void del_random_ready_callback(struct random_ready_callback *rdy);
 extern void get_random_bytes_arch(void *buf, int nbytes);
<span class="p_del">-extern int random_int_secret_init(void);</span>
 
 #ifndef MODULE
 extern const struct file_operations random_fops, urandom_fops;
<span class="p_header">diff --git a/init/main.c b/init/main.c</span>
<span class="p_header">index 2858be732f6d..ae3996ae9bac 100644</span>
<span class="p_header">--- a/init/main.c</span>
<span class="p_header">+++ b/init/main.c</span>
<span class="p_chunk">@@ -868,7 +868,6 @@</span> <span class="p_context"> static void __init do_basic_setup(void)</span>
 	do_ctors();
 	usermodehelper_enable();
 	do_initcalls();
<span class="p_del">-	random_int_secret_init();</span>
 }
 
 static void __init do_pre_smp_initcalls(void)
<span class="p_header">diff --git a/kernel/ptrace.c b/kernel/ptrace.c</span>
<span class="p_header">index 49ba7c1ade9d..a5caecef88be 100644</span>
<span class="p_header">--- a/kernel/ptrace.c</span>
<span class="p_header">+++ b/kernel/ptrace.c</span>
<span class="p_chunk">@@ -181,11 +181,17 @@</span> <span class="p_context"> static void ptrace_unfreeze_traced(struct task_struct *task)</span>
 
 	WARN_ON(!task-&gt;ptrace || task-&gt;parent != current);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * PTRACE_LISTEN can allow ptrace_trap_notify to wake us up remotely.</span>
<span class="p_add">+	 * Recheck state under the lock to close this race.</span>
<span class="p_add">+	 */</span>
 	spin_lock_irq(&amp;task-&gt;sighand-&gt;siglock);
<span class="p_del">-	if (__fatal_signal_pending(task))</span>
<span class="p_del">-		wake_up_state(task, __TASK_TRACED);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		task-&gt;state = TASK_TRACED;</span>
<span class="p_add">+	if (task-&gt;state == __TASK_TRACED) {</span>
<span class="p_add">+		if (__fatal_signal_pending(task))</span>
<span class="p_add">+			wake_up_state(task, __TASK_TRACED);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			task-&gt;state = TASK_TRACED;</span>
<span class="p_add">+	}</span>
 	spin_unlock_irq(&amp;task-&gt;sighand-&gt;siglock);
 }
 
<span class="p_header">diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c</span>
<span class="p_header">index 9c143739b8d7..f30847af7310 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer.c</span>
<span class="p_chunk">@@ -4870,9 +4870,9 @@</span> <span class="p_context"> static __init int test_ringbuffer(void)</span>
 		rb_data[cpu].cnt = cpu;
 		rb_threads[cpu] = kthread_create(rb_test, &amp;rb_data[cpu],
 						 &quot;rbtester/%d&quot;, cpu);
<span class="p_del">-		if (WARN_ON(!rb_threads[cpu])) {</span>
<span class="p_add">+		if (WARN_ON(IS_ERR(rb_threads[cpu]))) {</span>
 			pr_cont(&quot;FAILED\n&quot;);
<span class="p_del">-			ret = -1;</span>
<span class="p_add">+			ret = PTR_ERR(rb_threads[cpu]);</span>
 			goto out_free;
 		}
 
<span class="p_chunk">@@ -4882,9 +4882,9 @@</span> <span class="p_context"> static __init int test_ringbuffer(void)</span>
 
 	/* Now create the rb hammer! */
 	rb_hammer = kthread_run(rb_hammer_test, NULL, &quot;rbhammer&quot;);
<span class="p_del">-	if (WARN_ON(!rb_hammer)) {</span>
<span class="p_add">+	if (WARN_ON(IS_ERR(rb_hammer))) {</span>
 		pr_cont(&quot;FAILED\n&quot;);
<span class="p_del">-		ret = -1;</span>
<span class="p_add">+		ret = PTR_ERR(rb_hammer);</span>
 		goto out_free;
 	}
 
<span class="p_header">diff --git a/mm/mempolicy.c b/mm/mempolicy.c</span>
<span class="p_header">index f75704717e47..23471526d424 100644</span>
<span class="p_header">--- a/mm/mempolicy.c</span>
<span class="p_header">+++ b/mm/mempolicy.c</span>
<span class="p_chunk">@@ -1524,7 +1524,6 @@</span> <span class="p_context"> COMPAT_SYSCALL_DEFINE5(get_mempolicy, int __user *, policy,</span>
 COMPAT_SYSCALL_DEFINE3(set_mempolicy, int, mode, compat_ulong_t __user *, nmask,
 		       compat_ulong_t, maxnode)
 {
<span class="p_del">-	long err = 0;</span>
 	unsigned long __user *nm = NULL;
 	unsigned long nr_bits, alloc_size;
 	DECLARE_BITMAP(bm, MAX_NUMNODES);
<span class="p_chunk">@@ -1533,14 +1532,13 @@</span> <span class="p_context"> COMPAT_SYSCALL_DEFINE3(set_mempolicy, int, mode, compat_ulong_t __user *, nmask,</span>
 	alloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;
 
 	if (nmask) {
<span class="p_del">-		err = compat_get_bitmap(bm, nmask, nr_bits);</span>
<span class="p_add">+		if (compat_get_bitmap(bm, nmask, nr_bits))</span>
<span class="p_add">+			return -EFAULT;</span>
 		nm = compat_alloc_user_space(alloc_size);
<span class="p_del">-		err |= copy_to_user(nm, bm, alloc_size);</span>
<span class="p_add">+		if (copy_to_user(nm, bm, alloc_size))</span>
<span class="p_add">+			return -EFAULT;</span>
 	}
 
<span class="p_del">-	if (err)</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-</span>
 	return sys_set_mempolicy(mode, nm, nr_bits+1);
 }
 
<span class="p_chunk">@@ -1548,7 +1546,6 @@</span> <span class="p_context"> COMPAT_SYSCALL_DEFINE6(mbind, compat_ulong_t, start, compat_ulong_t, len,</span>
 		       compat_ulong_t, mode, compat_ulong_t __user *, nmask,
 		       compat_ulong_t, maxnode, compat_ulong_t, flags)
 {
<span class="p_del">-	long err = 0;</span>
 	unsigned long __user *nm = NULL;
 	unsigned long nr_bits, alloc_size;
 	nodemask_t bm;
<span class="p_chunk">@@ -1557,14 +1554,13 @@</span> <span class="p_context"> COMPAT_SYSCALL_DEFINE6(mbind, compat_ulong_t, start, compat_ulong_t, len,</span>
 	alloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;
 
 	if (nmask) {
<span class="p_del">-		err = compat_get_bitmap(nodes_addr(bm), nmask, nr_bits);</span>
<span class="p_add">+		if (compat_get_bitmap(nodes_addr(bm), nmask, nr_bits))</span>
<span class="p_add">+			return -EFAULT;</span>
 		nm = compat_alloc_user_space(alloc_size);
<span class="p_del">-		err |= copy_to_user(nm, nodes_addr(bm), alloc_size);</span>
<span class="p_add">+		if (copy_to_user(nm, nodes_addr(bm), alloc_size))</span>
<span class="p_add">+			return -EFAULT;</span>
 	}
 
<span class="p_del">-	if (err)</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-</span>
 	return sys_mbind(start, len, mode, nm, nr_bits+1, flags);
 }
 
<span class="p_header">diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="p_header">index 1460e6ad5e14..e5b159b88e39 100644</span>
<span class="p_header">--- a/mm/page_alloc.c</span>
<span class="p_header">+++ b/mm/page_alloc.c</span>
<span class="p_chunk">@@ -4345,13 +4345,13 @@</span> <span class="p_context"> void show_free_areas(unsigned int filter)</span>
 			K(node_page_state(pgdat, NR_FILE_MAPPED)),
 			K(node_page_state(pgdat, NR_FILE_DIRTY)),
 			K(node_page_state(pgdat, NR_WRITEBACK)),
<span class="p_add">+			K(node_page_state(pgdat, NR_SHMEM)),</span>
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
 			K(node_page_state(pgdat, NR_SHMEM_THPS) * HPAGE_PMD_NR),
 			K(node_page_state(pgdat, NR_SHMEM_PMDMAPPED)
 					* HPAGE_PMD_NR),
 			K(node_page_state(pgdat, NR_ANON_THPS) * HPAGE_PMD_NR),
 #endif
<span class="p_del">-			K(node_page_state(pgdat, NR_SHMEM)),</span>
 			K(node_page_state(pgdat, NR_WRITEBACK_TEMP)),
 			K(node_page_state(pgdat, NR_UNSTABLE_NFS)),
 			node_page_state(pgdat, NR_PAGES_SCANNED),
<span class="p_header">diff --git a/net/mac80211/iface.c b/net/mac80211/iface.c</span>
<span class="p_header">index 638ec0759078..8d7747e98fdb 100644</span>
<span class="p_header">--- a/net/mac80211/iface.c</span>
<span class="p_header">+++ b/net/mac80211/iface.c</span>
<span class="p_chunk">@@ -726,7 +726,8 @@</span> <span class="p_context"> int ieee80211_do_open(struct wireless_dev *wdev, bool coming_up)</span>
 	ieee80211_recalc_ps(local);
 
 	if (sdata-&gt;vif.type == NL80211_IFTYPE_MONITOR ||
<span class="p_del">-	    sdata-&gt;vif.type == NL80211_IFTYPE_AP_VLAN) {</span>
<span class="p_add">+	    sdata-&gt;vif.type == NL80211_IFTYPE_AP_VLAN ||</span>
<span class="p_add">+	    local-&gt;ops-&gt;wake_tx_queue) {</span>
 		/* XXX: for AP_VLAN, actually track AP queues */
 		netif_tx_start_all_queues(dev);
 	} else if (dev) {
<span class="p_header">diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_header">index 6fdffde28733..153082598522 100644</span>
<span class="p_header">--- a/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_header">+++ b/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_chunk">@@ -1548,7 +1548,7 @@</span> <span class="p_context"> svcauth_gss_accept(struct svc_rqst *rqstp, __be32 *authp)</span>
 	ret = SVC_COMPLETE;
 	goto out;
 drop:
<span class="p_del">-	ret = SVC_DROP;</span>
<span class="p_add">+	ret = SVC_CLOSE;</span>
 out:
 	if (rsci)
 		cache_put(&amp;rsci-&gt;h, sn-&gt;rsc_cache);
<span class="p_header">diff --git a/net/sunrpc/svc.c b/net/sunrpc/svc.c</span>
<span class="p_header">index 7c8070ec93c8..75f290bddca1 100644</span>
<span class="p_header">--- a/net/sunrpc/svc.c</span>
<span class="p_header">+++ b/net/sunrpc/svc.c</span>
<span class="p_chunk">@@ -1155,8 +1155,7 @@</span> <span class="p_context"> svc_process_common(struct svc_rqst *rqstp, struct kvec *argv, struct kvec *resv)</span>
 	case SVC_DENIED:
 		goto err_bad_auth;
 	case SVC_CLOSE:
<span class="p_del">-		if (test_bit(XPT_TEMP, &amp;rqstp-&gt;rq_xprt-&gt;xpt_flags))</span>
<span class="p_del">-			svc_close_xprt(rqstp-&gt;rq_xprt);</span>
<span class="p_add">+		goto close;</span>
 	case SVC_DROP:
 		goto dropit;
 	case SVC_COMPLETE:
<span class="p_chunk">@@ -1246,7 +1245,7 @@</span> <span class="p_context"> svc_process_common(struct svc_rqst *rqstp, struct kvec *argv, struct kvec *resv)</span>
 
  sendit:
 	if (svc_authorise(rqstp))
<span class="p_del">-		goto dropit;</span>
<span class="p_add">+		goto close;</span>
 	return 1;		/* Caller can now send it */
 
  dropit:
<span class="p_chunk">@@ -1254,11 +1253,16 @@</span> <span class="p_context"> svc_process_common(struct svc_rqst *rqstp, struct kvec *argv, struct kvec *resv)</span>
 	dprintk(&quot;svc: svc_process dropit\n&quot;);
 	return 0;
 
<span class="p_add">+ close:</span>
<span class="p_add">+	if (test_bit(XPT_TEMP, &amp;rqstp-&gt;rq_xprt-&gt;xpt_flags))</span>
<span class="p_add">+		svc_close_xprt(rqstp-&gt;rq_xprt);</span>
<span class="p_add">+	dprintk(&quot;svc: svc_process close\n&quot;);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
 err_short_len:
 	svc_printk(rqstp, &quot;short len %Zd, dropping request\n&quot;,
 			argv-&gt;iov_len);
<span class="p_del">-</span>
<span class="p_del">-	goto dropit;			/* drop request */</span>
<span class="p_add">+	goto close;</span>
 
 err_bad_rpc:
 	serv-&gt;sv_stats-&gt;rpcbadfmt++;
<span class="p_header">diff --git a/net/wireless/sysfs.c b/net/wireless/sysfs.c</span>
<span class="p_header">index 14b3f007826d..2927d06faa6e 100644</span>
<span class="p_header">--- a/net/wireless/sysfs.c</span>
<span class="p_header">+++ b/net/wireless/sysfs.c</span>
<span class="p_chunk">@@ -130,12 +130,10 @@</span> <span class="p_context"> static int wiphy_resume(struct device *dev)</span>
 	/* Age scan results with time spent in suspend */
 	cfg80211_bss_age(rdev, get_seconds() - rdev-&gt;suspend_at);
 
<span class="p_del">-	if (rdev-&gt;ops-&gt;resume) {</span>
<span class="p_del">-		rtnl_lock();</span>
<span class="p_del">-		if (rdev-&gt;wiphy.registered)</span>
<span class="p_del">-			ret = rdev_resume(rdev);</span>
<span class="p_del">-		rtnl_unlock();</span>
<span class="p_del">-	}</span>
<span class="p_add">+	rtnl_lock();</span>
<span class="p_add">+	if (rdev-&gt;wiphy.registered &amp;&amp; rdev-&gt;ops-&gt;resume)</span>
<span class="p_add">+		ret = rdev_resume(rdev);</span>
<span class="p_add">+	rtnl_unlock();</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/sound/soc/codecs/rt5670.c b/sound/soc/codecs/rt5670.c</span>
<span class="p_header">index 49caf1393aeb..fdc14e50d3b9 100644</span>
<span class="p_header">--- a/sound/soc/codecs/rt5670.c</span>
<span class="p_header">+++ b/sound/soc/codecs/rt5670.c</span>
<span class="p_chunk">@@ -2813,6 +2813,8 @@</span> <span class="p_context"> MODULE_DEVICE_TABLE(i2c, rt5670_i2c_id);</span>
 #ifdef CONFIG_ACPI
 static const struct acpi_device_id rt5670_acpi_match[] = {
 	{ &quot;10EC5670&quot;, 0},
<span class="p_add">+	{ &quot;10EC5672&quot;, 0},</span>
<span class="p_add">+	{ &quot;10EC5640&quot;, 0}, /* quirk */</span>
 	{ },
 };
 MODULE_DEVICE_TABLE(acpi, rt5670_acpi_match);
<span class="p_header">diff --git a/sound/soc/intel/atom/sst/sst_acpi.c b/sound/soc/intel/atom/sst/sst_acpi.c</span>
<span class="p_header">index 0a88537ca58a..0bfa68862460 100644</span>
<span class="p_header">--- a/sound/soc/intel/atom/sst/sst_acpi.c</span>
<span class="p_header">+++ b/sound/soc/intel/atom/sst/sst_acpi.c</span>
<span class="p_chunk">@@ -400,6 +400,7 @@</span> <span class="p_context"> static int sst_acpi_remove(struct platform_device *pdev)</span>
 static unsigned long cht_machine_id;
 
 #define CHT_SURFACE_MACH 1
<span class="p_add">+#define BYT_THINKPAD_10  2</span>
 
 static int cht_surface_quirk_cb(const struct dmi_system_id *id)
 {
<span class="p_chunk">@@ -407,6 +408,23 @@</span> <span class="p_context"> static int cht_surface_quirk_cb(const struct dmi_system_id *id)</span>
 	return 1;
 }
 
<span class="p_add">+static int byt_thinkpad10_quirk_cb(const struct dmi_system_id *id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	cht_machine_id = BYT_THINKPAD_10;</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct dmi_system_id byt_table[] = {</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = byt_thinkpad10_quirk_cb,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;LENOVO&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;20C3001VHH&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{ }</span>
<span class="p_add">+};</span>
 
 static const struct dmi_system_id cht_table[] = {
 	{
<span class="p_chunk">@@ -424,6 +442,10 @@</span> <span class="p_context"> static struct sst_acpi_mach cht_surface_mach = {</span>
 	&quot;10EC5640&quot;, &quot;cht-bsw-rt5645&quot;, &quot;intel/fw_sst_22a8.bin&quot;, &quot;cht-bsw&quot;, NULL,
 								&amp;chv_platform_data };
 
<span class="p_add">+static struct sst_acpi_mach byt_thinkpad_10 = {</span>
<span class="p_add">+	&quot;10EC5640&quot;, &quot;cht-bsw-rt5672&quot;, &quot;intel/fw_sst_0f28.bin&quot;, &quot;cht-bsw&quot;, NULL,</span>
<span class="p_add">+	                                                        &amp;byt_rvp_platform_data };</span>
<span class="p_add">+</span>
 static struct sst_acpi_mach *cht_quirk(void *arg)
 {
 	struct sst_acpi_mach *mach = arg;
<span class="p_chunk">@@ -436,8 +458,21 @@</span> <span class="p_context"> static struct sst_acpi_mach *cht_quirk(void *arg)</span>
 		return mach;
 }
 
<span class="p_add">+static struct sst_acpi_mach *byt_quirk(void *arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sst_acpi_mach *mach = arg;</span>
<span class="p_add">+</span>
<span class="p_add">+	dmi_check_system(byt_table);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cht_machine_id == BYT_THINKPAD_10)</span>
<span class="p_add">+		return &amp;byt_thinkpad_10;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return mach;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 static struct sst_acpi_mach sst_acpi_bytcr[] = {
<span class="p_del">-	{&quot;10EC5640&quot;, &quot;bytcr_rt5640&quot;, &quot;intel/fw_sst_0f28.bin&quot;, &quot;bytcr_rt5640&quot;, NULL,</span>
<span class="p_add">+	{&quot;10EC5640&quot;, &quot;bytcr_rt5640&quot;, &quot;intel/fw_sst_0f28.bin&quot;, &quot;bytcr_rt5640&quot;, byt_quirk,</span>
 						&amp;byt_rvp_platform_data },
 	{&quot;10EC5642&quot;, &quot;bytcr_rt5640&quot;, &quot;intel/fw_sst_0f28.bin&quot;, &quot;bytcr_rt5640&quot;, NULL,
 						&amp;byt_rvp_platform_data },
<span class="p_header">diff --git a/sound/soc/intel/boards/bytcr_rt5640.c b/sound/soc/intel/boards/bytcr_rt5640.c</span>
<span class="p_header">index bff77a1f27fc..4c8ff298ad26 100644</span>
<span class="p_header">--- a/sound/soc/intel/boards/bytcr_rt5640.c</span>
<span class="p_header">+++ b/sound/soc/intel/boards/bytcr_rt5640.c</span>
<span class="p_chunk">@@ -57,9 +57,7 @@</span> <span class="p_context"> struct byt_rt5640_private {</span>
 	struct clk *mclk;
 };
 
<span class="p_del">-static unsigned long byt_rt5640_quirk = BYT_RT5640_DMIC1_MAP |</span>
<span class="p_del">-					BYT_RT5640_DMIC_EN |</span>
<span class="p_del">-					BYT_RT5640_MCLK_EN;</span>
<span class="p_add">+static unsigned long byt_rt5640_quirk = BYT_RT5640_MCLK_EN;</span>
 
 static void log_quirks(struct device *dev)
 {
<span class="p_chunk">@@ -389,6 +387,16 @@</span> <span class="p_context"> static const struct dmi_system_id byt_rt5640_quirk_table[] = {</span>
 						 BYT_RT5640_SSP0_AIF1),
 
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = byt_rt5640_quirk_cb,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Insyde&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+		.driver_data = (unsigned long *)(BYT_RT5640_IN3_MAP |</span>
<span class="p_add">+						 BYT_RT5640_MCLK_EN |</span>
<span class="p_add">+						 BYT_RT5640_SSP0_AIF1),</span>
<span class="p_add">+</span>
<span class="p_add">+	},</span>
 	{}
 };
 
<span class="p_chunk">@@ -738,6 +746,13 @@</span> <span class="p_context"> static int snd_byt_rt5640_mc_probe(struct platform_device *pdev)</span>
 		if (res_info-&gt;acpi_ipc_irq_index == 0) {
 			byt_rt5640_quirk |= BYT_RT5640_SSP0_AIF2;
 		}
<span class="p_add">+</span>
<span class="p_add">+		/* change defaults for Baytrail-CR capture */</span>
<span class="p_add">+		byt_rt5640_quirk |= BYT_RT5640_IN1_MAP;</span>
<span class="p_add">+		byt_rt5640_quirk |= BYT_RT5640_DIFF_MIC;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		byt_rt5640_quirk |= (BYT_RT5640_DMIC1_MAP |</span>
<span class="p_add">+				BYT_RT5640_DMIC_EN);</span>
 	}
 
 	/* check quirks before creating card */
<span class="p_header">diff --git a/sound/soc/intel/boards/cht_bsw_rt5645.c b/sound/soc/intel/boards/cht_bsw_rt5645.c</span>
<span class="p_header">index 16c94c45ce50..90525614c20a 100644</span>
<span class="p_header">--- a/sound/soc/intel/boards/cht_bsw_rt5645.c</span>
<span class="p_header">+++ b/sound/soc/intel/boards/cht_bsw_rt5645.c</span>
<span class="p_chunk">@@ -24,6 +24,9 @@</span> <span class="p_context"></span>
 #include &lt;linux/acpi.h&gt;
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/slab.h&gt;
<span class="p_add">+#include &lt;asm/cpu_device_id.h&gt;</span>
<span class="p_add">+#include &lt;asm/platform_sst_audio.h&gt;</span>
<span class="p_add">+#include &lt;linux/clk.h&gt;</span>
 #include &lt;sound/pcm.h&gt;
 #include &lt;sound/pcm_params.h&gt;
 #include &lt;sound/soc.h&gt;
<span class="p_chunk">@@ -45,6 +48,7 @@</span> <span class="p_context"> struct cht_mc_private {</span>
 	struct snd_soc_jack jack;
 	struct cht_acpi_card *acpi_card;
 	char codec_name[16];
<span class="p_add">+	struct clk *mclk;</span>
 };
 
 static inline struct snd_soc_dai *cht_get_codec_dai(struct snd_soc_card *card)
<span class="p_chunk">@@ -65,6 +69,7 @@</span> <span class="p_context"> static int platform_clock_control(struct snd_soc_dapm_widget *w,</span>
 	struct snd_soc_dapm_context *dapm = w-&gt;dapm;
 	struct snd_soc_card *card = dapm-&gt;card;
 	struct snd_soc_dai *codec_dai;
<span class="p_add">+	struct cht_mc_private *ctx = snd_soc_card_get_drvdata(card);</span>
 	int ret;
 
 	codec_dai = cht_get_codec_dai(card);
<span class="p_chunk">@@ -73,19 +78,30 @@</span> <span class="p_context"> static int platform_clock_control(struct snd_soc_dapm_widget *w,</span>
 		return -EIO;
 	}
 
<span class="p_del">-	if (!SND_SOC_DAPM_EVENT_OFF(event))</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+	if (SND_SOC_DAPM_EVENT_ON(event)) {</span>
<span class="p_add">+		if (ctx-&gt;mclk) {</span>
<span class="p_add">+			ret = clk_prepare_enable(ctx-&gt;mclk);</span>
<span class="p_add">+			if (ret &lt; 0) {</span>
<span class="p_add">+				dev_err(card-&gt;dev,</span>
<span class="p_add">+					&quot;could not configure MCLK state&quot;);</span>
<span class="p_add">+				return ret;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* Set codec sysclk source to its internal clock because codec PLL will</span>
<span class="p_add">+		 * be off when idle and MCLK will also be off when codec is</span>
<span class="p_add">+		 * runtime suspended. Codec needs clock for jack detection and button</span>
<span class="p_add">+		 * press. MCLK is turned off with clock framework or ACPI.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		ret = snd_soc_dai_set_sysclk(codec_dai, RT5645_SCLK_S_RCCLK,</span>
<span class="p_add">+					48000 * 512, SND_SOC_CLOCK_IN);</span>
<span class="p_add">+		if (ret &lt; 0) {</span>
<span class="p_add">+			dev_err(card-&gt;dev, &quot;can&#39;t set codec sysclk: %d\n&quot;, ret);</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-	/* Set codec sysclk source to its internal clock because codec PLL will</span>
<span class="p_del">-	 * be off when idle and MCLK will also be off by ACPI when codec is</span>
<span class="p_del">-	 * runtime suspended. Codec needs clock for jack detection and button</span>
<span class="p_del">-	 * press.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ret = snd_soc_dai_set_sysclk(codec_dai, RT5645_SCLK_S_RCCLK,</span>
<span class="p_del">-			0, SND_SOC_CLOCK_IN);</span>
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		dev_err(card-&gt;dev, &quot;can&#39;t set codec sysclk: %d\n&quot;, ret);</span>
<span class="p_del">-		return ret;</span>
<span class="p_add">+		if (ctx-&gt;mclk)</span>
<span class="p_add">+			clk_disable_unprepare(ctx-&gt;mclk);</span>
 	}
 
 	return 0;
<span class="p_chunk">@@ -97,7 +113,7 @@</span> <span class="p_context"> static const struct snd_soc_dapm_widget cht_dapm_widgets[] = {</span>
 	SND_SOC_DAPM_MIC(&quot;Int Mic&quot;, NULL),
 	SND_SOC_DAPM_SPK(&quot;Ext Spk&quot;, NULL),
 	SND_SOC_DAPM_SUPPLY(&quot;Platform Clock&quot;, SND_SOC_NOPM, 0, 0,
<span class="p_del">-			platform_clock_control, SND_SOC_DAPM_POST_PMD),</span>
<span class="p_add">+			platform_clock_control, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),</span>
 };
 
 static const struct snd_soc_dapm_route cht_rt5645_audio_map[] = {
<span class="p_chunk">@@ -225,6 +241,26 @@</span> <span class="p_context"> static int cht_codec_init(struct snd_soc_pcm_runtime *runtime)</span>
 
 	rt5645_set_jack_detect(codec, &amp;ctx-&gt;jack, &amp;ctx-&gt;jack, &amp;ctx-&gt;jack);
 
<span class="p_add">+	if (ctx-&gt;mclk) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The firmware might enable the clock at</span>
<span class="p_add">+		 * boot (this information may or may not</span>
<span class="p_add">+		 * be reflected in the enable clock register).</span>
<span class="p_add">+		 * To change the rate we must disable the clock</span>
<span class="p_add">+		 * first to cover these cases. Due to common</span>
<span class="p_add">+		 * clock framework restrictions that do not allow</span>
<span class="p_add">+		 * to disable a clock that has not been enabled,</span>
<span class="p_add">+		 * we need to enable the clock first.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		ret = clk_prepare_enable(ctx-&gt;mclk);</span>
<span class="p_add">+		if (!ret)</span>
<span class="p_add">+			clk_disable_unprepare(ctx-&gt;mclk);</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = clk_set_rate(ctx-&gt;mclk, CHT_PLAT_CLK_3_HZ);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			dev_err(runtime-&gt;dev, &quot;unable to set MCLK rate\n&quot;);</span>
<span class="p_add">+	}</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -349,6 +385,18 @@</span> <span class="p_context"> static struct cht_acpi_card snd_soc_cards[] = {</span>
 
 static char cht_rt5640_codec_name[16]; /* i2c-&lt;HID&gt;:00 with HID being 8 chars */
 
<span class="p_add">+static bool is_valleyview(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static const struct x86_cpu_id cpu_ids[] = {</span>
<span class="p_add">+		{ X86_VENDOR_INTEL, 6, 55 }, /* Valleyview, Bay Trail */</span>
<span class="p_add">+		{}</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!x86_match_cpu(cpu_ids))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int snd_cht_mc_probe(struct platform_device *pdev)
 {
 	int ret_val = 0;
<span class="p_chunk">@@ -358,22 +406,32 @@</span> <span class="p_context"> static int snd_cht_mc_probe(struct platform_device *pdev)</span>
 	struct sst_acpi_mach *mach;
 	const char *i2c_name = NULL;
 	int dai_index = 0;
<span class="p_add">+	bool found = false;</span>
 
 	drv = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*drv), GFP_ATOMIC);
 	if (!drv)
 		return -ENOMEM;
 
<span class="p_add">+	mach = (&amp;pdev-&gt;dev)-&gt;platform_data;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; ARRAY_SIZE(snd_soc_cards); i++) {
<span class="p_del">-		if (acpi_dev_found(snd_soc_cards[i].codec_id)) {</span>
<span class="p_add">+		if (acpi_dev_found(snd_soc_cards[i].codec_id) &amp;&amp;</span>
<span class="p_add">+			(!strncmp(snd_soc_cards[i].codec_id, mach-&gt;id, 8))) {</span>
 			dev_dbg(&amp;pdev-&gt;dev,
 				&quot;found codec %s\n&quot;, snd_soc_cards[i].codec_id);
 			card = snd_soc_cards[i].soc_card;
 			drv-&gt;acpi_card = &amp;snd_soc_cards[i];
<span class="p_add">+			found = true;</span>
 			break;
 		}
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (!found) {</span>
<span class="p_add">+		dev_err(&amp;pdev-&gt;dev, &quot;No matching HID found in supported list\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	card-&gt;dev = &amp;pdev-&gt;dev;
<span class="p_del">-	mach = card-&gt;dev-&gt;platform_data;</span>
 	sprintf(drv-&gt;codec_name, &quot;i2c-%s:00&quot;, drv-&gt;acpi_card-&gt;codec_id);
 
 	/* set correct codec name */
<span class="p_chunk">@@ -391,6 +449,16 @@</span> <span class="p_context"> static int snd_cht_mc_probe(struct platform_device *pdev)</span>
 		cht_dailink[dai_index].codec_name = cht_rt5640_codec_name;
 	}
 
<span class="p_add">+	if (is_valleyview()) {</span>
<span class="p_add">+		drv-&gt;mclk = devm_clk_get(&amp;pdev-&gt;dev, &quot;pmc_plt_clk_3&quot;);</span>
<span class="p_add">+		if (IS_ERR(drv-&gt;mclk)) {</span>
<span class="p_add">+			dev_err(&amp;pdev-&gt;dev,</span>
<span class="p_add">+				&quot;Failed to get MCLK from pmc_plt_clk_3: %ld\n&quot;,</span>
<span class="p_add">+				PTR_ERR(drv-&gt;mclk));</span>
<span class="p_add">+			return PTR_ERR(drv-&gt;mclk);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	snd_soc_card_set_drvdata(card, drv);
 	ret_val = devm_snd_soc_register_card(&amp;pdev-&gt;dev, card);
 	if (ret_val) {
<span class="p_header">diff --git a/sound/soc/sunxi/sun4i-i2s.c b/sound/soc/sunxi/sun4i-i2s.c</span>
<span class="p_header">index 687a8f83dbe5..15c92400cea4 100644</span>
<span class="p_header">--- a/sound/soc/sunxi/sun4i-i2s.c</span>
<span class="p_header">+++ b/sound/soc/sunxi/sun4i-i2s.c</span>
<span class="p_chunk">@@ -14,9 +14,11 @@</span> <span class="p_context"></span>
 #include &lt;linux/clk.h&gt;
 #include &lt;linux/dmaengine.h&gt;
 #include &lt;linux/module.h&gt;
<span class="p_add">+#include &lt;linux/of_device.h&gt;</span>
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/pm_runtime.h&gt;
 #include &lt;linux/regmap.h&gt;
<span class="p_add">+#include &lt;linux/reset.h&gt;</span>
 
 #include &lt;sound/dmaengine_pcm.h&gt;
 #include &lt;sound/pcm_params.h&gt;
<span class="p_chunk">@@ -92,6 +94,7 @@</span> <span class="p_context"> struct sun4i_i2s {</span>
 	struct clk	*bus_clk;
 	struct clk	*mod_clk;
 	struct regmap	*regmap;
<span class="p_add">+	struct reset_control *rst;</span>
 
 	struct snd_dmaengine_dai_dma_data	playback_dma_data;
 };
<span class="p_chunk">@@ -585,9 +588,22 @@</span> <span class="p_context"> static int sun4i_i2s_runtime_suspend(struct device *dev)</span>
 	return 0;
 }
 
<span class="p_add">+struct sun4i_i2s_quirks {</span>
<span class="p_add">+	bool has_reset;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct sun4i_i2s_quirks sun4i_a10_i2s_quirks = {</span>
<span class="p_add">+	.has_reset	= false,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct sun4i_i2s_quirks sun6i_a31_i2s_quirks = {</span>
<span class="p_add">+	.has_reset	= true,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int sun4i_i2s_probe(struct platform_device *pdev)
 {
 	struct sun4i_i2s *i2s;
<span class="p_add">+	const struct sun4i_i2s_quirks *quirks;</span>
 	struct resource *res;
 	void __iomem *regs;
 	int irq, ret;
<span class="p_chunk">@@ -608,6 +624,12 @@</span> <span class="p_context"> static int sun4i_i2s_probe(struct platform_device *pdev)</span>
 		return irq;
 	}
 
<span class="p_add">+	quirks = of_device_get_match_data(&amp;pdev-&gt;dev);</span>
<span class="p_add">+	if (!quirks) {</span>
<span class="p_add">+		dev_err(&amp;pdev-&gt;dev, &quot;Failed to determine the quirks to use\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	i2s-&gt;bus_clk = devm_clk_get(&amp;pdev-&gt;dev, &quot;apb&quot;);
 	if (IS_ERR(i2s-&gt;bus_clk)) {
 		dev_err(&amp;pdev-&gt;dev, &quot;Can&#39;t get our bus clock\n&quot;);
<span class="p_chunk">@@ -626,7 +648,24 @@</span> <span class="p_context"> static int sun4i_i2s_probe(struct platform_device *pdev)</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;Can&#39;t get our mod clock\n&quot;);
 		return PTR_ERR(i2s-&gt;mod_clk);
 	}
<span class="p_del">-	</span>
<span class="p_add">+</span>
<span class="p_add">+	if (quirks-&gt;has_reset) {</span>
<span class="p_add">+		i2s-&gt;rst = devm_reset_control_get(&amp;pdev-&gt;dev, NULL);</span>
<span class="p_add">+		if (IS_ERR(i2s-&gt;rst)) {</span>
<span class="p_add">+			dev_err(&amp;pdev-&gt;dev, &quot;Failed to get reset control\n&quot;);</span>
<span class="p_add">+			return PTR_ERR(i2s-&gt;rst);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!IS_ERR(i2s-&gt;rst)) {</span>
<span class="p_add">+		ret = reset_control_deassert(i2s-&gt;rst);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			dev_err(&amp;pdev-&gt;dev,</span>
<span class="p_add">+				&quot;Failed to deassert the reset control\n&quot;);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	i2s-&gt;playback_dma_data.addr = res-&gt;start + SUN4I_I2S_FIFO_TX_REG;
 	i2s-&gt;playback_dma_data.maxburst = 4;
 
<span class="p_chunk">@@ -658,23 +697,37 @@</span> <span class="p_context"> static int sun4i_i2s_probe(struct platform_device *pdev)</span>
 		sun4i_i2s_runtime_suspend(&amp;pdev-&gt;dev);
 err_pm_disable:
 	pm_runtime_disable(&amp;pdev-&gt;dev);
<span class="p_add">+	if (!IS_ERR(i2s-&gt;rst))</span>
<span class="p_add">+		reset_control_assert(i2s-&gt;rst);</span>
 
 	return ret;
 }
 
 static int sun4i_i2s_remove(struct platform_device *pdev)
 {
<span class="p_add">+	struct sun4i_i2s *i2s = dev_get_drvdata(&amp;pdev-&gt;dev);</span>
<span class="p_add">+</span>
 	snd_dmaengine_pcm_unregister(&amp;pdev-&gt;dev);
 
 	pm_runtime_disable(&amp;pdev-&gt;dev);
 	if (!pm_runtime_status_suspended(&amp;pdev-&gt;dev))
 		sun4i_i2s_runtime_suspend(&amp;pdev-&gt;dev);
 
<span class="p_add">+	if (!IS_ERR(i2s-&gt;rst))</span>
<span class="p_add">+		reset_control_assert(i2s-&gt;rst);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
 static const struct of_device_id sun4i_i2s_match[] = {
<span class="p_del">-	{ .compatible = &quot;allwinner,sun4i-a10-i2s&quot;, },</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.compatible = &quot;allwinner,sun4i-a10-i2s&quot;,</span>
<span class="p_add">+		.data = &amp;sun4i_a10_i2s_quirks,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.compatible = &quot;allwinner,sun6i-a31-i2s&quot;,</span>
<span class="p_add">+		.data = &amp;sun6i_a31_i2s_quirks,</span>
<span class="p_add">+	},</span>
 	{}
 };
 MODULE_DEVICE_TABLE(of, sun4i_i2s_match);
<span class="p_header">diff --git a/sound/usb/pcm.c b/sound/usb/pcm.c</span>
<span class="p_header">index 48afae053c56..cf8459a6fad8 100644</span>
<span class="p_header">--- a/sound/usb/pcm.c</span>
<span class="p_header">+++ b/sound/usb/pcm.c</span>
<span class="p_chunk">@@ -348,6 +348,16 @@</span> <span class="p_context"> static int set_sync_ep_implicit_fb_quirk(struct snd_usb_substream *subs,</span>
 
 		alts = &amp;iface-&gt;altsetting[1];
 		goto add_sync_ep;
<span class="p_add">+	case USB_ID(0x2466, 0x8003):</span>
<span class="p_add">+		ep = 0x86;</span>
<span class="p_add">+		iface = usb_ifnum_to_if(dev, 2);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!iface || iface-&gt;num_altsetting == 0)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		alts = &amp;iface-&gt;altsetting[1];</span>
<span class="p_add">+		goto add_sync_ep;</span>
<span class="p_add">+</span>
 	}
 	if (attr == USB_ENDPOINT_SYNC_ASYNC &amp;&amp;
 	    altsd-&gt;bInterfaceClass == USB_CLASS_VENDOR_SPEC &amp;&amp;
<span class="p_header">diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c</span>
<span class="p_header">index 93bb14e7e0f7..eb4b9f7a571e 100644</span>
<span class="p_header">--- a/sound/usb/quirks.c</span>
<span class="p_header">+++ b/sound/usb/quirks.c</span>
<span class="p_chunk">@@ -1166,6 +1166,18 @@</span> <span class="p_context"> static bool is_marantz_denon_dac(unsigned int id)</span>
 	return false;
 }
 
<span class="p_add">+/* TEAC UD-501/UD-503/NT-503 USB DACs need a vendor cmd to switch</span>
<span class="p_add">+ * between PCM/DOP and native DSD mode</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool is_teac_50X_dac(unsigned int id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (id) {</span>
<span class="p_add">+	case USB_ID(0x0644, 0x8043): /* TEAC UD-501/UD-503/NT-503 */</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int snd_usb_select_mode_quirk(struct snd_usb_substream *subs,
 			      struct audioformat *fmt)
 {
<span class="p_chunk">@@ -1193,6 +1205,26 @@</span> <span class="p_context"> int snd_usb_select_mode_quirk(struct snd_usb_substream *subs,</span>
 			break;
 		}
 		mdelay(20);
<span class="p_add">+	} else if (is_teac_50X_dac(subs-&gt;stream-&gt;chip-&gt;usb_id)) {</span>
<span class="p_add">+		/* Vendor mode switch cmd is required. */</span>
<span class="p_add">+		switch (fmt-&gt;altsetting) {</span>
<span class="p_add">+		case 3: /* DSD mode (DSD_U32) requested */</span>
<span class="p_add">+			err = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), 0,</span>
<span class="p_add">+					      USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,</span>
<span class="p_add">+					      1, 1, NULL, 0);</span>
<span class="p_add">+			if (err &lt; 0)</span>
<span class="p_add">+				return err;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		case 2: /* PCM or DOP mode (S32) requested */</span>
<span class="p_add">+		case 1: /* PCM mode (S16) requested */</span>
<span class="p_add">+			err = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), 0,</span>
<span class="p_add">+					      USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,</span>
<span class="p_add">+					      0, 1, NULL, 0);</span>
<span class="p_add">+			if (err &lt; 0)</span>
<span class="p_add">+				return err;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 	}
 	return 0;
 }
<span class="p_chunk">@@ -1338,5 +1370,11 @@</span> <span class="p_context"> u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,</span>
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 	}
 
<span class="p_add">+	/* TEAC devices with USB DAC functionality */</span>
<span class="p_add">+	if (is_teac_50X_dac(chip-&gt;usb_id)) {</span>
<span class="p_add">+		if (fp-&gt;altsetting == 3)</span>
<span class="p_add">+			return SNDRV_PCM_FMTBIT_DSD_U32_BE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



