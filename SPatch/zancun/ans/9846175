
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v10,35/38] x86/mm: Add support to encrypt the kernel in-place - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v10,35/38] x86/mm: Add support to encrypt the kernel in-place</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=80801">Tom Lendacky</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>July 17, 2017, 9:10 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;c039bf9412ef95e1e6bf4fdf8facab95e00c717b.1500319216.git.thomas.lendacky@amd.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9846175/mbox/"
   >mbox</a>
|
   <a href="/patch/9846175/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9846175/">/patch/9846175/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	9B9D360386 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 17 Jul 2017 21:15:13 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id D214A27480
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 17 Jul 2017 21:15:13 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id C60C927F7F; Mon, 17 Jul 2017 21:15:13 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9EEA827480
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 17 Jul 2017 21:15:12 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752530AbdGQVOs (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 17 Jul 2017 17:14:48 -0400
Received: from mail-bn3nam01on0058.outbound.protection.outlook.com
	([104.47.33.58]:39086
	&quot;EHLO NAM01-BN3-obe.outbound.protection.outlook.com&quot;
	rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
	id S1752262AbdGQVNR (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 17 Jul 2017 17:13:17 -0400
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=amdcloud.onmicrosoft.com; s=selector1-amd-com;
	h=From:Date:Subject:Message-ID:Content-Type:MIME-Version;
	bh=M86HOsEXL+0HwTqZny5QP7sKDPFDmiB1cu9QMFyy5t4=;
	b=BuAR42MKBd6FdbKypEOfBHnd7VVZmXqeEXlQlR7trzymShnPpFbzvpVuMNqfnxihXi3Wg8DZbHQ0zeGCQYyIRpu8rdNRRotB5TjtMe9/MO+AhKyv4Vd68C/8eo33dhKmNqueJgSY3NLO0bTxbChz9iZ2e7fBaPoKtJjgtiZWZ5I=
Authentication-Results: kernel.org; dkim=none (message not signed)
	header.d=none; kernel.org; dmarc=none action=none header.from=amd.com;
Received: from tlendack-t1.amdoffice.net (165.204.77.1) by
	MWHPR12MB1151.namprd12.prod.outlook.com (10.169.204.15) with
	Microsoft SMTP Server (version=TLS1_2,
	cipher=TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P256) id
	15.1.1261.13; Mon, 17 Jul 2017 21:13:06 +0000
From: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;
To: x86@kernel.org, linux-kernel@vger.kernel.org,
	linux-arch@vger.kernel.org, linux-efi@vger.kernel.org,
	linux-doc@vger.kernel.org, linux-mm@kvack.org, kvm@vger.kernel.org,
	kasan-dev@googlegroups.com
Cc: =?UTF-8?q?Radim=20Kr=C4=8Dm=C3=A1=C5=99?= &lt;rkrcmar@redhat.com&gt;,
	Arnd Bergmann &lt;arnd@arndb.de&gt;, Jonathan Corbet &lt;corbet@lwn.net&gt;,
	Matt Fleming &lt;matt@codeblueprint.co.uk&gt;,
	Konrad Rzeszutek Wilk &lt;konrad.wilk@oracle.com&gt;,
	Andrey Ryabinin &lt;aryabinin@virtuozzo.com&gt;,
	Ingo Molnar &lt;mingo@redhat.com&gt;, Borislav Petkov &lt;bp@alien8.de&gt;,
	Andy Lutomirski &lt;luto@kernel.org&gt;, &quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;,
	Paolo Bonzini &lt;pbonzini@redhat.com&gt;,
	Alexander Potapenko &lt;glider@google.com&gt;,
	Thomas Gleixner &lt;tglx@linutronix.de&gt;, Dmitry Vyukov &lt;dvyukov@google.com&gt;,
	Rik van Riel &lt;riel@redhat.com&gt;, Larry Woodman &lt;lwoodman@redhat.com&gt;,
	Dave Young &lt;dyoung@redhat.com&gt;, Toshimitsu Kani &lt;toshi.kani@hpe.com&gt;,
	&quot;Michael S. Tsirkin&quot; &lt;mst@redhat.com&gt;,
	Brijesh Singh &lt;brijesh.singh@amd.com&gt;
Subject: [PATCH v10 35/38] x86/mm: Add support to encrypt the kernel in-place
Date: Mon, 17 Jul 2017 16:10:32 -0500
Message-Id: &lt;c039bf9412ef95e1e6bf4fdf8facab95e00c717b.1500319216.git.thomas.lendacky@amd.com&gt;
X-Mailer: git-send-email 1.9.1
In-Reply-To: &lt;cover.1500319216.git.thomas.lendacky@amd.com&gt;
References: &lt;cover.1500319216.git.thomas.lendacky@amd.com&gt;
MIME-Version: 1.0
Content-Type: text/plain
X-Originating-IP: [165.204.77.1]
X-ClientProxiedBy: BN6PR03CA0008.namprd03.prod.outlook.com (10.168.230.146)
	To MWHPR12MB1151.namprd12.prod.outlook.com (10.169.204.15)
X-MS-PublicTrafficType: Email
X-MS-Office365-Filtering-Correlation-Id: b93b8034-7c0e-4154-fbc7-08d4cd58a04b
X-MS-Office365-Filtering-HT: Tenant
X-Microsoft-Antispam: UriScan:; BCL:0; PCL:0;
	RULEID:(300000500095)(300135000095)(300000501095)(300135300095)(22001)(300000502095)(300135100095)(48565401081)(300000503095)(300135400095)(201703131423075)(201703031133081)(300000504095)(300135200095)(300000505095)(300135600095)(300000506095)(300135500095);
	SRVR:MWHPR12MB1151; 
X-Microsoft-Exchange-Diagnostics: 1; MWHPR12MB1151;
	3:9lEudC4eoSt2XphXKu3M8INv/9dPiOGdHJzU12D3kjLZw7fWEVXON7h5jrwsYpIJl2XXl6pAvkglvq2Mp+EBkH0nsDH3Dcb5DfHq+OXPVzj6NMA8nmhaE/WRAhtfMYKdR4tmEqKFnzn7/TzA4DSsm6MkH2lLKlWaBuiidMdQLcNtA7v7fMvNKuXF5HXvLrw9EH3OmygUIRHcpU0AP2IHxBynOYYk0LecOtxgvZ+JS05zVv+MOkX8jtTn15KYwrux+tIaVD84+BkBWGXzf9vYJwbxIm1IUxNm/WsQPkuQu8rzIsYR9EKFW4X2FuwlN9dZUBq1lfH/u+3LKcQ8TyLL9JcdPO0LkG0fHeyvVu8lnzJEOdACS3I0jaiLnYHWwgE6BMPSFIRi/1S8tFQ3cgBoGjjxPeTS657ROwLlZjPyu75edQ0KZA/V/IhjVlPnMCz5jHQ93RCtiiMbALLV4KCstQ8SrFQPCZ6aJzbv81Z4LciEtmzdQrQ+mlP6WE6xLg4p5PcvKEcjFcBygTytAxfsYgcQ+ofW0rxJ62IIOcMni7gBWKBte2iomiygJBG3sHt2/rcKWthQmYi6IHZKDjcAOvfk2EkbG2EHxx9j8Omv+lIcxQzFt55Ktla63QgSIYKH0j1gC8294RPb4b+GGb32jZxiQPJk3gM9LIad3FKnUNPf7QNRnq3yt/w9/5sJfOSBsdXeiLdGwrXeqRMT9uMnH+o0bq1qiCvO7ebbIXY5+uk4v872S37aXgZjt4DwEo24gfiWC3xQgnPtYneyD68JGg==
X-MS-TrafficTypeDiagnostic: MWHPR12MB1151:
X-Microsoft-Exchange-Diagnostics: 1; MWHPR12MB1151;
	25:Nm+svgiDVgO9y6tk76ubrKMeagHIKX6caV4Tz8DWjPmwcNNQSgllXv8txUQm/X5Z4mlPGHYg9Zz+oWxgTEUVKDyFOAMbhM34Ww8Kng2YIS6+gyHYN4i3oVDYuq06/tMwLoJvam4rDanwmmtewuCLx+zy5XRhN8Fr9ZqJJhq7JpQYCU2nh1wYCqzpC9ALfigw8h0Ut5+HzU2cluuktnKvVb2gh92xTCBluzlKA2civHi32CUpcgglFnvh9TSTsizt4kzkAonVDPoF0H7A613NmVt1qJkW03+9WEBNIVfyOZ2f21wztCZbRuZHHgg50y7k7QnXXDjPK1i2PbE2hN8z9VvLQbvsMWhoVGJu9XORiwrrGhPx3TqlGE9WTGmM6JeoGh7gb+FP1Yb9ppb3ItFiUnkqFV17J7t4uHwL25BUiPQvB0nSZAVMiUJD4844NXxnaNLV9SIL8dXe0pVMj2Yld965ct9zSQqsZZq8bHz13lIRyMmLAegc7yCvkPNBCXnD3UpC5aR6jKxT05NRFmzaBsumG9cgv+285IKgXz9mC5EZns0AWeFvM8EHNxPpoJlhVeb1XPZBb+Y5wqDPVMT6ojc2bPP8i0Sae72SrAnDxy8fSc0soiETgqWmbBd8UvxjOPlcwVg8Ya4KouYbcNckvKvzTd139lqMV0TvUnRgGZIeF7Lh3lW3Dy2gW1ag+Gk/WpACFEsnlaVtuqjAB+Ac1ChLRfSgjbjXc2LT+Soimf1e+Mm/VOvajMzNGikxrn6Z03gPS6ZZxwop/Pa0rztWf73OSVYBo8qK84HAWrapap0Z4IYNgQfRBedhmPwHDxLEi8peZ+hfxYEev0tnmWKpVv8LzM5nOOknVr4cfSXIdbVu/Q6Antu1lYunMSQOSXi/MThE9LEkgvM+l4Kuu8Idpc+aOMDDZrAIp5QmBji28
	7Y=
X-Microsoft-Exchange-Diagnostics: 1; MWHPR12MB1151;
	31:pysi5IjJHA9sr2eh2QTxhTGkhzwPW/XjJC8H75wL5vzxbpgZkJzN5aTELpodG4Abh2upS16Y44bJRLcOpO+1bFZqNa6KKIIqcl7GFlt9NVOBPMBHFviwphSDw+sQ+jrztJ4MGmopf5xWsJPBBlQwtIYcuFKRlJLIcOxvB4kCnAr+ADrJbWu2ctQBxUKQIWt8le8eXyz0I0vAcU+29nWYidO0dGXlNkD8bU8BbrSg6iv0Z4MCG06pSN6EiYeKmIHtXZDldmQ+aing7zmDqqef7N9qJ+6i8drjZQf1p7LPE6/HCQO8K5ltkxDxfXH+EyrZHciShj7R4Atcs0hknvHWPVgx3tpP2Nn6Nus7cYstgh7cK3ciP27dScBPjg1cz7p7hnYztnV/fePPGUJqL8H+Jxbjvfr92EZISPaUkHB4eZ8qo2sdwrvZQB/Mk3Qtuq0NV9/uJOmxuiLDMPaOFmdSSJpMABoCmVaNCY+s9s8FA2caRa0xmGPLK1aljELZirjOVsipsHt6s50vYTTvRi6dOW1kuh+T3Ukfc1ehTPue0yGC/u/tyRMwaAAzc65SzwVyDQOAbpZzWWOOGi7GAI+vMm9yFJp8uYc5vs7K4kBFT+ODXqINKgbbfkal8RzYwDnqPwq28acw+2ZBggZIPoJKULjEIWYgCKYJ2u1tvQAiUEE=
X-Microsoft-Exchange-Diagnostics: 1; MWHPR12MB1151;
	20:ZD6G64dCEcFTiGdvNnbhx9O6p/nBsLebyPh6N8deYxGnKENzk6KpJW44CJHKvUkMF3sxxJcpwqxBFzDNM68XYwfl2qFntLGeFxc1lXNJZKzfnEiVscB7zfz39Qow+oG0kzSxcE4Che7PoV80LuOeWl98gca9uuQLX+t7r4l1dCKlTDqHNPKo77jZ7rgZLuvdEao5SWjxs7nyM8eBP1+y18nRSDKZtaPXFAD2hZ8hYhguonOXEnm99hJrdQClY6/LLZdZ546Pn2f+3BVg4u5ELKzooFMt82E+p/gzmbwdd35/4vNaAq0cUIb2kTG9/VNRCKnBW0K9kHX8vrppsbCWlXFxvURHgDC3gryXXM3kWhqVtYexYv2soIe0Hhh1YxcWiTad315KSOGYZCs2YkSPlnRGcYnheZ3Veau1Eekjpy3xky5Y28vT6AT7XSzdxpp+Y+VtJQHc85t2AKlYofLG2rNo/A569HcmzwORV42UTyLTDNOA6BJqRaNwEoBdD+b/
X-Exchange-Antispam-Report-Test: UriScan:(133145235818549)(236129657087228)(767451399110)(148574349560750)(247924648384137);
X-Microsoft-Antispam-PRVS: &lt;MWHPR12MB1151FFD0D348740039415DCEECA00@MWHPR12MB1151.namprd12.prod.outlook.com&gt;
X-Exchange-Antispam-Report-CFA-Test: BCL:0; PCL:0;
	RULEID:(100000700101)(100105000095)(100000701101)(100105300095)(100000702101)(100105100095)(6040450)(601004)(2401047)(2017060910075)(5005006)(8121501046)(100000703101)(100105400095)(3002001)(10201501046)(93006095)(93001095)(6055026)(6041248)(20161123558100)(20161123555025)(20161123562025)(20161123560025)(201703131423075)(201702281528075)(201703061421075)(201703061406153)(20161123564025)(6072148)(100000704101)(100105200095)(100000705101)(100105500095);
	SRVR:MWHPR12MB1151; BCL:0; PCL:0;
	RULEID:(100000800101)(100110000095)(100000801101)(100110300095)(100000802101)(100110100095)(100000803101)(100110400095)(100000804101)(100110200095)(100000805101)(100110500095);
	SRVR:MWHPR12MB1151; 
X-Microsoft-Exchange-Diagnostics: =?us-ascii?Q?1; MWHPR12MB1151;
	4:IGphoP6tHOsoEDyaYQztiI2iwMYfl5NkloVaA/SJhF?=
	=?us-ascii?Q?Dk0PGs3bH+4nfMv4wvjsxIR/S/q2/HEb1yhJ/GIPGQFghYMIWjQzci6n7MMq?=
	=?us-ascii?Q?uoi7Eto42kE7gP4wfUflsihAu3v9johHUd6RaaNXVaikIzjn3fOx16ZrvPkN?=
	=?us-ascii?Q?N8WeS4We8y8W+a8Fy4xBy0xI0I2Xpq3T0JCYRAnRwM7HOmqdpcV5fFnxCUWc?=
	=?us-ascii?Q?KnMwkWcnU+qWBzca7zValND1IS+ORT+cjj/kmhEDGNMKp9UsJDSez4PwzhDg?=
	=?us-ascii?Q?A4e1kyBquDpcxzOdSBWVq9Az8epYykFceH/aNg+RHnXxGt+nY1QIzoh6CcoN?=
	=?us-ascii?Q?3kNeneeP2CzrcLUB7/qc51XOZ+pQt4oZnGLMQCOVsJ4FORBgtFzZ1XscjdWy?=
	=?us-ascii?Q?8r/5rqSgN5vQFs4DHwICpzdaTXwivuiUI3ajcDQUZvxHsDoE2cNhW35N5HoV?=
	=?us-ascii?Q?Mpa5LTwOID0K9rysFxvMoGxaPuO4B1Vppm3LdKefXRMY5RGLxXGTU8KPe2n0?=
	=?us-ascii?Q?4Lt3J6UnNUIQ5gak2yWJh3Ciny6u7yaSOSVutKWYDJ0or9usw79E5QZc26oc?=
	=?us-ascii?Q?gcpcBoM1owkIuoBw5RTOGvFT5Mb48klUY4vlhRz7yPY5Ht1672pEcwkvsIe9?=
	=?us-ascii?Q?R4xQ3G8mha0D6e0nBLBvHir8L8ggO4cTb7YKoKk/YwxjBnzhWLXSyoTJcFiT?=
	=?us-ascii?Q?ns6t5SYQoQXJQhxM+nhOH3i7A4CM2OoA2sL0GJdSWoDdG6UMNPBYEHnbd3K6?=
	=?us-ascii?Q?WR+zMj7pghmqEBmq3CawzXibhHG7EW+g+pmmgAB2/H0yGDLoBOQcdftXtqcg?=
	=?us-ascii?Q?Pk2kGwiPmef17wZljrgkZgJsoCDeDBockuDNVvBp/YUgfHQYTP+D/Tu0drdJ?=
	=?us-ascii?Q?2dtMrU1X7uEbqSa0J+grJ3oQlaOtSR9LoJ0CVcRbVf1kzzbI7WcxIdW2DuYW?=
	=?us-ascii?Q?EuunDJXAZmsCgj8YrSRg7RdsdmaSapkdvT6lpG7Q+TXqVqGnMdt5TKj68rUd?=
	=?us-ascii?Q?Pw5nUUkvwYq/t6re1qd9UnytVR0pHNtMLcWYqnCYmuA/FlXOrDI75YW9RU2g?=
	=?us-ascii?Q?rmmeqqdErgg0JIrnwEwq5HTzj0QT0ChwEUDR0UhT/T17HW343+8c9theeWJH?=
	=?us-ascii?Q?471iwldXB6rGDJSoXKss2fnnX7JEITxG6b+BylThFe6p8xuWys7zNndBVuLK?=
	=?us-ascii?Q?U2CSvLHPznzwrnGq8NpqpA/h3m2+ZzmPhfpq5663BdXXtMe4PvtgbVqegu/l?=
	=?us-ascii?Q?okyta0sdX2SKEH2cps6sJSWFZ5jBGtUu6FUbVg3GXk9x2MVPChrRoNvNz6ZK?=
	=?us-ascii?Q?Oha/VBC+hqS3c8g7E6qJA23oFDnNH+uH1d486syGQxNxBB8bcS60Blj+x8qJ?=
	=?us-ascii?Q?l57TJODbsptQ3SoCPo2IXkqaY=3D?=
X-Forefront-PRVS: 0371762FE7
X-Forefront-Antispam-Report: SFV:NSPM;
	SFS:(10009020)(4630300001)(7370300001)(6009001)(39410400002)(39850400002)(39840400002)(39860400002)(39400400002)(39450400003)(25786009)(6506006)(33646002)(54906002)(7416002)(76176999)(478600001)(8676002)(50986999)(6486002)(47776003)(5660300001)(189998001)(42186005)(38730400002)(305945005)(72206003)(53416004)(66066001)(50466002)(48376002)(110136004)(118296001)(2950100002)(81166006)(5003940100001)(3846002)(6666003)(36756003)(53936002)(7350300001)(6512007)(2906002)(7736002)(6116002)(86362001)(4326008)(50226002)(2004002);
	DIR:OUT; SFP:1101; SCL:1; SRVR:MWHPR12MB1151;
	H:tlendack-t1.amdoffice.net; FPR:; SPF:None; MLV:sfv; LANG:en;
X-Microsoft-Exchange-Diagnostics: =?us-ascii?Q?1; MWHPR12MB1151;
	23:KZOosGdCUt27PX6W/U4At7JWfdw/qCHA+6yUASMnM?=
	=?us-ascii?Q?+E3Fi9JPmQMtUyBVxc3lQ09gbCycKRlRKHg/tmINWcIji/LNZwe9fvy8BOOI?=
	=?us-ascii?Q?ByBrXIui8VfuFRY8BqbKOUVi5ZqY9VtMUSy1RvqWwZgZHo4JH9fYPVgHUnKR?=
	=?us-ascii?Q?taf+jL1Y92rYt4VwyOQXYoKIor+SF+80pZdXlZqjYmmmtB9G7rjDyQrxUFKj?=
	=?us-ascii?Q?OSDnMKHTfRCAHxiMcbDNNxkiWHytXcVFIULKW6K5uBN8b60S0XSq9J62j+jP?=
	=?us-ascii?Q?YNOhP6zDN6XO3g9e6xg0uOhTJzwhZMdQ8SHOC+rmwYtCj22qM6I9KALCb8Gd?=
	=?us-ascii?Q?gHz5eV5gBMFonzlPE9EaIeo5QaTObJ68hmoYlVDsEDn6PUbwLlfSakDwSHXz?=
	=?us-ascii?Q?Kx5TLlTK+YFITYgZAYb3bunD3QIviIsgSo+Te3oYqOuYzSj4/yiZDvMCMwy+?=
	=?us-ascii?Q?TZEfGycj73pS5WLzszPfR3PjbCXvzvellGvFMEoLuqqjku91NlZExCgfXSzx?=
	=?us-ascii?Q?ff+m0y/GrmvcC923VeprDku9XPd75nNQq28zbpPtD1lfG77k7xy6l2h6MgAb?=
	=?us-ascii?Q?jzC6QrDPBZ2EEWUDwGQMPxhCA7KbvjwbTkSEm5DN2Xk6QkKiEKU//TzSMEEu?=
	=?us-ascii?Q?wU+zS13ItlPrfwPQ21ErQVjzWC+5+Vyl8f1da7vtFRYNsPLojH9N49UGigi/?=
	=?us-ascii?Q?c7po7upVbzfHTWhpsWzgAvJ29mEPOT8Bx7aqGBmJsfO6KrQ/G4p3G00/oYt5?=
	=?us-ascii?Q?r2dkaJesWVkP6O8lnZMlk+ShbLn6riCnurTJpiKVQjGULEtZM1UT7OJs7Meu?=
	=?us-ascii?Q?EiSc9ebw185Vmw4k069Kr+qqDU22jQENjwaQO6I5VocLlbu5+9ldskyy1m3q?=
	=?us-ascii?Q?KfBStzoQF2+RcjBDV8l8BO14Oa72n9+Ijxj5kqKdsHAsDePicQJpmOycyNQV?=
	=?us-ascii?Q?hVfa9H4tHzIOfzVJOgVmL+6Vn7rrTp7sWrAGhpCX4p0kdOHlAhij9dj6E3Yz?=
	=?us-ascii?Q?g5CScrk9vqyZkkcrQDq1hZ4MWaSttS+SoWF9bR+kQQFhUt5v3dfmj2LtHXfc?=
	=?us-ascii?Q?6uu7fVasLJY/q68jp5ONYLhEzKbdVxE1HDauVR6eHoM+lNORgTZ4rNRBnTwF?=
	=?us-ascii?Q?F96+FWn89K2y+ADVxcTHDwroGp9I2zjYCeb6KHA751UnoQF209kgAub13BvO?=
	=?us-ascii?Q?BsDaQppCmoM9KO/+2hr7I65y1x5WfSZ6Gfs?=
X-Microsoft-Exchange-Diagnostics: =?us-ascii?Q?1; MWHPR12MB1151;
	6:k0rrQ8oK8QUBKoKtZmy54j4jA8NGgRk0tk2xj+Zw3l?=
	=?us-ascii?Q?ug0v/n+xTlSLVknftWEj03DYt5SqlfBVCWVLijpZzl8tdmyTOGkgJyc4INvu?=
	=?us-ascii?Q?9m0VFSgb9mSZ9fQRbUJ0C+kdMO/5PqeAIXTYz73CUDixKv0JziQ8n9kCW6wH?=
	=?us-ascii?Q?KQ8ta0dWNXjkxci7SESbAyrQR4D/tA2782ZAx0+8MRU5FYpSioGnyqtiNlEA?=
	=?us-ascii?Q?u8lSUqt2348oz02ONtoOomL8ZIuPn+bcaZDBoV6y7rtq5KUpHDtahOZMYvW2?=
	=?us-ascii?Q?IWoAJ0EKtCOwc+rmmKvugq6NSInLrB4kq9kMsrPlPocnv3isIDysglZf8Jjx?=
	=?us-ascii?Q?Zr9t7oGHXxPYo4BLEzbO7dl4kFQY7YLsuRusZZM1EGEVhUny6tHGSIs7iIUA?=
	=?us-ascii?Q?guPC+4HDGyndruYurc00bpyf8COICTtwmCm4zXP0LTz4NQngE6oFImFJCY2w?=
	=?us-ascii?Q?xsRqXaBVi19SY1qgxIvYF8Me7FYRkipyUxWUJsxP2aYVD+gay5/Dhr4tU9Ns?=
	=?us-ascii?Q?gUWH8ACZRJwTtc/HTDQ1WEhoegvLauugCwL648UJSuQeyNByWEV1RdY+5V62?=
	=?us-ascii?Q?EuPvGUmrLJ/9Z75GmKk0SZsAZtyMXOWhrYrfYFR+AMa+bL2kbnvi9N1NnWfi?=
	=?us-ascii?Q?k/3EDtKGiNDEh/yt2YUAFCSk//vcL2YpwtHBtMG28u7k3l4UnwtzVWaOGrNP?=
	=?us-ascii?Q?hb8ErBUJvlKK9Eapoqq6o19TF4ysIn/V7MWH3RLkJuA3JccgdAa2lCur1IdL?=
	=?us-ascii?Q?mRtUNkI8r8RiXJFdP0DWJd0o2N4r8OcpSVyvTJYQow4LD1IZ35PkGy1v34rB?=
	=?us-ascii?Q?5NLxj6X3AORAtpAMBdBCRx2G/S1r9jgKoXmJwBV5keZpNmqkAq+jDZVfI3QU?=
	=?us-ascii?Q?PS2w14wwNfGIiZxRmjmRanmhHI06dMtkM3bViscsTDn5IhPpfhWamCYfMLAH?=
	=?us-ascii?Q?pbKtNlUOltJf8Er5fcHj6HYRLk1HTkVv9omdKGlIjKTtb9pLFxIZZVpWyS0R?=
	=?us-ascii?Q?n5739C80/diZb+JVoEmIjq?=
X-Microsoft-Exchange-Diagnostics: 1; MWHPR12MB1151;
	5:upg/aWxtB07ykAshHaBp7ivbyiTamgyhXeO/4GVU50rJ9myLILPh07NwAP+/3l5da6ABX/nc+yrdsf5x/blW7PCfuLFu50r9Yz/StaLLE85urNqvPeiDo7VrjwQ7QwdzGEqjQnoZt1DURJMuDv0tGvuEM2lC1HuU+Mn6Wld3a42JgAgzE86DhYQMbKvCoCx2E3LnK12tHlyeNOwJb/Aqqzh8NnI6W+dMA56pp6EIcw9W/RN9cJCkSKrnnidEmLjFJcI601kKdeDHSBAT1UTwBnxHjdOCsKLAD9EGIqtxD/sIm1PRocKuXwz2o+cAXk8126PGLZnWHak2Z+G+KbSK3HR7LMLcKr7S3CezsunGYMSoOOS+UXCbsuw9QILaoJV3uf4cU584e9dKZiBccV/vm6R5BRklv/q/53GbgSPfJOGPpzEOYvU1kQQ4VWxlKVwIvdL9brF9B8A8qRaTEOGybaf/aDyN3DmTG781r5Uc9abhiIFXNFJhNBumoxwH0pso;
	24:WN/qwyNcbkuo53sI9MLZIqyBLKfV+cj4b6IlcR2Jz8YZJ+aoQQPe9Bjnb38SOC8hm1+XTmniYiaVqJLGIgMYZQTxs4T6Xm8z81Sj6KTNyZg=
SpamDiagnosticOutput: 1:99
SpamDiagnosticMetadata: NSPM
X-Microsoft-Exchange-Diagnostics: 1; MWHPR12MB1151;
	7:LdQGm9f3gMLvzNvWV30DImcXh1IIVHvK8H7cGd63GHW51yq8ec9I2mFADd3eAqrgOqjzyIyzHWuYGP4SbWk8Izda2TnkDntjM1KeoMC5klHU4uU1WTUTApefOmAmLlSkpa+4WCKuPQoRLTxbsZKWaAuorS2YJMab91gvPEQ7xoEuYW7UWzBW6FtwstBfFP7ZqG/ML8b5/LrRVugVdklovQA//SUhEtVETEWsMt1nR5bado4PW9WFQ7bqp41nUg2yuWHFo+vHvRyA68WL0vYQhsgIvvpsu+w9lLwltQ9+kabfq0jjCITBirEOdQULqfbvQ0ej2OXLcxWq3p3VnvFIYxBGNg0Wj8zzVXSgGbMUKt5643ghoP4jAoudDuRe9rS2rd1b7FI7EK9b/1GJp3iceC0yObCjck1M7ySiwgwHaYgEilioU08zxC24bDcSo+mbQeg+6pm/MdihakoJ8twLgXhNvQcaMrM5iJuA1Z1UlYYJe0uPwaPYnBUN7aaA+tZFvwD0ti2BX0ZT9U9YOO2dHMj1TKSCKhkVTY3Rj7C15awxqMgWeVnhPUoAGSABCsQlN9xAPQ/4Se1eBzchF/EHfn3oQOaHC2yBsGoK697FRESaQXeHdR/DlKHsVY/GQWlqnakL9hV+nK+xX2A7mCTsoao0VOdXiXfwu63twf2ajlH1LwbxiB8U1s7gVmA44SZjmv28EdBoG9ZxE4/qlrXLHLNJA8NybRlJXXbfH7vBZ1ZbdK1PrY52EGtd5tLAZJk/WS/59+mK61jpZGhmijwu9qROV16Ac4Wb8hC8blfMO4I=
X-Microsoft-Exchange-Diagnostics: 1; MWHPR12MB1151;
	20:+BD9aEfhXQ+6PLi629KxTG7AKCDH8hk3eUmZplJWmnusUjPQeFQvk0EfMaT7YEzy7yKCSmfmb4dlc4jDxjVA0AwzvQfcbDet8xbx+/2G3Ak/Gn7Sah5J7vPNh1pU0+8nu9ZlrO49d7r/2Q4h8vyKgjREW9gRBu9YmEdWwqvOWt+GdB9C9KJYyd7dfq+UiVbJV++0qWQsvBkinATIN/k0Hi9qslvxbBcWc9YjAwkbAfxEiBVpsE7/KUjObfQXHwEt
X-OriginatorOrg: amd.com
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 17 Jul 2017 21:13:06.1253
	(UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-Transport-CrossTenantHeadersStamped: MWHPR12MB1151
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=80801">Tom Lendacky</a> - July 17, 2017, 9:10 p.m.</div>
<pre class="content">
Add the support to encrypt the kernel in-place. This is done by creating
new page mappings for the kernel - a decrypted write-protected mapping
and an encrypted mapping. The kernel is encrypted by copying it through
a temporary buffer.
<span class="signed-off-by">
Signed-off-by: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
---
 arch/x86/include/asm/mem_encrypt.h |   6 +
 arch/x86/mm/Makefile               |   1 +
 arch/x86/mm/mem_encrypt.c          | 310 +++++++++++++++++++++++++++++++++++++
 arch/x86/mm/mem_encrypt_boot.S     | 149 ++++++++++++++++++
 4 files changed, 466 insertions(+)
 create mode 100644 arch/x86/mm/mem_encrypt_boot.S
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/include/asm/mem_encrypt.h b/arch/x86/include/asm/mem_encrypt.h</span>
<span class="p_header">index 70e55f6..7122c36 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mem_encrypt.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mem_encrypt.h</span>
<span class="p_chunk">@@ -21,6 +21,12 @@</span> <span class="p_context"></span>
 
 extern unsigned long sme_me_mask;
 
<span class="p_add">+void sme_encrypt_execute(unsigned long encrypted_kernel_vaddr,</span>
<span class="p_add">+			 unsigned long decrypted_kernel_vaddr,</span>
<span class="p_add">+			 unsigned long kernel_len,</span>
<span class="p_add">+			 unsigned long encryption_wa,</span>
<span class="p_add">+			 unsigned long encryption_pgd);</span>
<span class="p_add">+</span>
 void __init sme_early_encrypt(resource_size_t paddr,
 			      unsigned long size);
 void __init sme_early_decrypt(resource_size_t paddr,
<span class="p_header">diff --git a/arch/x86/mm/Makefile b/arch/x86/mm/Makefile</span>
<span class="p_header">index a94a7b6..72bf8c0 100644</span>
<span class="p_header">--- a/arch/x86/mm/Makefile</span>
<span class="p_header">+++ b/arch/x86/mm/Makefile</span>
<span class="p_chunk">@@ -40,3 +40,4 @@</span> <span class="p_context"> obj-$(CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS) += pkeys.o</span>
 obj-$(CONFIG_RANDOMIZE_MEMORY) += kaslr.o
 
 obj-$(CONFIG_AMD_MEM_ENCRYPT)	+= mem_encrypt.o
<span class="p_add">+obj-$(CONFIG_AMD_MEM_ENCRYPT)	+= mem_encrypt_boot.o</span>
<span class="p_header">diff --git a/arch/x86/mm/mem_encrypt.c b/arch/x86/mm/mem_encrypt.c</span>
<span class="p_header">index a7400ec..e5d5439 100644</span>
<span class="p_header">--- a/arch/x86/mm/mem_encrypt.c</span>
<span class="p_header">+++ b/arch/x86/mm/mem_encrypt.c</span>
<span class="p_chunk">@@ -21,6 +21,8 @@</span> <span class="p_context"></span>
 #include &lt;asm/setup.h&gt;
 #include &lt;asm/bootparam.h&gt;
 #include &lt;asm/set_memory.h&gt;
<span class="p_add">+#include &lt;asm/cacheflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 
 /*
  * Since SME related variables are set early in the boot process they must
<span class="p_chunk">@@ -199,8 +201,316 @@</span> <span class="p_context"> void swiotlb_set_mem_attributes(void *vaddr, unsigned long size)</span>
 	set_memory_decrypted((unsigned long)vaddr, size &gt;&gt; PAGE_SHIFT);
 }
 
<span class="p_add">+static void __init sme_clear_pgd(pgd_t *pgd_base, unsigned long start,</span>
<span class="p_add">+				 unsigned long end)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long pgd_start, pgd_end, pgd_size;</span>
<span class="p_add">+	pgd_t *pgd_p;</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd_start = start &amp; PGDIR_MASK;</span>
<span class="p_add">+	pgd_end = end &amp; PGDIR_MASK;</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd_size = (((pgd_end - pgd_start) / PGDIR_SIZE) + 1);</span>
<span class="p_add">+	pgd_size *= sizeof(pgd_t);</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd_p = pgd_base + pgd_index(start);</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(pgd_p, 0, pgd_size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define PGD_FLAGS	_KERNPG_TABLE_NOENC</span>
<span class="p_add">+#define P4D_FLAGS	_KERNPG_TABLE_NOENC</span>
<span class="p_add">+#define PUD_FLAGS	_KERNPG_TABLE_NOENC</span>
<span class="p_add">+#define PMD_FLAGS	(__PAGE_KERNEL_LARGE_EXEC &amp; ~_PAGE_GLOBAL)</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init *sme_populate_pgd(pgd_t *pgd_base, void *pgtable_area,</span>
<span class="p_add">+				     unsigned long vaddr, pmdval_t pmd_val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pgd_t *pgd_p;</span>
<span class="p_add">+	p4d_t *p4d_p;</span>
<span class="p_add">+	pud_t *pud_p;</span>
<span class="p_add">+	pmd_t *pmd_p;</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd_p = pgd_base + pgd_index(vaddr);</span>
<span class="p_add">+	if (native_pgd_val(*pgd_p)) {</span>
<span class="p_add">+		if (IS_ENABLED(CONFIG_X86_5LEVEL))</span>
<span class="p_add">+			p4d_p = (p4d_t *)(native_pgd_val(*pgd_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			pud_p = (pud_t *)(native_pgd_val(*pgd_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		pgd_t pgd;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (IS_ENABLED(CONFIG_X86_5LEVEL)) {</span>
<span class="p_add">+			p4d_p = pgtable_area;</span>
<span class="p_add">+			memset(p4d_p, 0, sizeof(*p4d_p) * PTRS_PER_P4D);</span>
<span class="p_add">+			pgtable_area += sizeof(*p4d_p) * PTRS_PER_P4D;</span>
<span class="p_add">+</span>
<span class="p_add">+			pgd = native_make_pgd((pgdval_t)p4d_p + PGD_FLAGS);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			pud_p = pgtable_area;</span>
<span class="p_add">+			memset(pud_p, 0, sizeof(*pud_p) * PTRS_PER_PUD);</span>
<span class="p_add">+			pgtable_area += sizeof(*pud_p) * PTRS_PER_PUD;</span>
<span class="p_add">+</span>
<span class="p_add">+			pgd = native_make_pgd((pgdval_t)pud_p + PGD_FLAGS);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		native_set_pgd(pgd_p, pgd);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_X86_5LEVEL)) {</span>
<span class="p_add">+		p4d_p += p4d_index(vaddr);</span>
<span class="p_add">+		if (native_p4d_val(*p4d_p)) {</span>
<span class="p_add">+			pud_p = (pud_t *)(native_p4d_val(*p4d_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			p4d_t p4d;</span>
<span class="p_add">+</span>
<span class="p_add">+			pud_p = pgtable_area;</span>
<span class="p_add">+			memset(pud_p, 0, sizeof(*pud_p) * PTRS_PER_PUD);</span>
<span class="p_add">+			pgtable_area += sizeof(*pud_p) * PTRS_PER_PUD;</span>
<span class="p_add">+</span>
<span class="p_add">+			p4d = native_make_p4d((pudval_t)pud_p + P4D_FLAGS);</span>
<span class="p_add">+			native_set_p4d(p4d_p, p4d);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pud_p += pud_index(vaddr);</span>
<span class="p_add">+	if (native_pud_val(*pud_p)) {</span>
<span class="p_add">+		if (native_pud_val(*pud_p) &amp; _PAGE_PSE)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+		pmd_p = (pmd_t *)(native_pud_val(*pud_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		pud_t pud;</span>
<span class="p_add">+</span>
<span class="p_add">+		pmd_p = pgtable_area;</span>
<span class="p_add">+		memset(pmd_p, 0, sizeof(*pmd_p) * PTRS_PER_PMD);</span>
<span class="p_add">+		pgtable_area += sizeof(*pmd_p) * PTRS_PER_PMD;</span>
<span class="p_add">+</span>
<span class="p_add">+		pud = native_make_pud((pmdval_t)pmd_p + PUD_FLAGS);</span>
<span class="p_add">+		native_set_pud(pud_p, pud);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pmd_p += pmd_index(vaddr);</span>
<span class="p_add">+	if (!native_pmd_val(*pmd_p) || !(native_pmd_val(*pmd_p) &amp; _PAGE_PSE))</span>
<span class="p_add">+		native_set_pmd(pmd_p, native_make_pmd(pmd_val));</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return pgtable_area;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned long __init sme_pgtable_calc(unsigned long len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long p4d_size, pud_size, pmd_size;</span>
<span class="p_add">+	unsigned long total;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Perform a relatively simplistic calculation of the pagetable</span>
<span class="p_add">+	 * entries that are needed. That mappings will be covered by 2MB</span>
<span class="p_add">+	 * PMD entries so we can conservatively calculate the required</span>
<span class="p_add">+	 * number of P4D, PUD and PMD structures needed to perform the</span>
<span class="p_add">+	 * mappings. Incrementing the count for each covers the case where</span>
<span class="p_add">+	 * the addresses cross entries.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_X86_5LEVEL)) {</span>
<span class="p_add">+		p4d_size = (ALIGN(len, PGDIR_SIZE) / PGDIR_SIZE) + 1;</span>
<span class="p_add">+		p4d_size *= sizeof(p4d_t) * PTRS_PER_P4D;</span>
<span class="p_add">+		pud_size = (ALIGN(len, P4D_SIZE) / P4D_SIZE) + 1;</span>
<span class="p_add">+		pud_size *= sizeof(pud_t) * PTRS_PER_PUD;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		p4d_size = 0;</span>
<span class="p_add">+		pud_size = (ALIGN(len, PGDIR_SIZE) / PGDIR_SIZE) + 1;</span>
<span class="p_add">+		pud_size *= sizeof(pud_t) * PTRS_PER_PUD;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	pmd_size = (ALIGN(len, PUD_SIZE) / PUD_SIZE) + 1;</span>
<span class="p_add">+	pmd_size *= sizeof(pmd_t) * PTRS_PER_PMD;</span>
<span class="p_add">+</span>
<span class="p_add">+	total = p4d_size + pud_size + pmd_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Now calculate the added pagetable structures needed to populate</span>
<span class="p_add">+	 * the new pagetables.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_X86_5LEVEL)) {</span>
<span class="p_add">+		p4d_size = ALIGN(total, PGDIR_SIZE) / PGDIR_SIZE;</span>
<span class="p_add">+		p4d_size *= sizeof(p4d_t) * PTRS_PER_P4D;</span>
<span class="p_add">+		pud_size = ALIGN(total, P4D_SIZE) / P4D_SIZE;</span>
<span class="p_add">+		pud_size *= sizeof(pud_t) * PTRS_PER_PUD;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		p4d_size = 0;</span>
<span class="p_add">+		pud_size = ALIGN(total, PGDIR_SIZE) / PGDIR_SIZE;</span>
<span class="p_add">+		pud_size *= sizeof(pud_t) * PTRS_PER_PUD;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	pmd_size = ALIGN(total, PUD_SIZE) / PUD_SIZE;</span>
<span class="p_add">+	pmd_size *= sizeof(pmd_t) * PTRS_PER_PMD;</span>
<span class="p_add">+</span>
<span class="p_add">+	total += p4d_size + pud_size + pmd_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	return total;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void __init sme_encrypt_kernel(void)
 {
<span class="p_add">+	unsigned long workarea_start, workarea_end, workarea_len;</span>
<span class="p_add">+	unsigned long execute_start, execute_end, execute_len;</span>
<span class="p_add">+	unsigned long kernel_start, kernel_end, kernel_len;</span>
<span class="p_add">+	unsigned long pgtable_area_len;</span>
<span class="p_add">+	unsigned long paddr, pmd_flags;</span>
<span class="p_add">+	unsigned long decrypted_base;</span>
<span class="p_add">+	void *pgtable_area;</span>
<span class="p_add">+	pgd_t *pgd;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!sme_active())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Prepare for encrypting the kernel by building new pagetables with</span>
<span class="p_add">+	 * the necessary attributes needed to encrypt the kernel in place.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *   One range of virtual addresses will map the memory occupied</span>
<span class="p_add">+	 *   by the kernel as encrypted.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *   Another range of virtual addresses will map the memory occupied</span>
<span class="p_add">+	 *   by the kernel as decrypted and write-protected.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *     The use of write-protect attribute will prevent any of the</span>
<span class="p_add">+	 *     memory from being cached.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Physical addresses gives us the identity mapped virtual addresses */</span>
<span class="p_add">+	kernel_start = __pa_symbol(_text);</span>
<span class="p_add">+	kernel_end = ALIGN(__pa_symbol(_end), PMD_PAGE_SIZE);</span>
<span class="p_add">+	kernel_len = kernel_end - kernel_start;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set the encryption workarea to be immediately after the kernel */</span>
<span class="p_add">+	workarea_start = kernel_end;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Calculate required number of workarea bytes needed:</span>
<span class="p_add">+	 *   executable encryption area size:</span>
<span class="p_add">+	 *     stack page (PAGE_SIZE)</span>
<span class="p_add">+	 *     encryption routine page (PAGE_SIZE)</span>
<span class="p_add">+	 *     intermediate copy buffer (PMD_PAGE_SIZE)</span>
<span class="p_add">+	 *   pagetable structures for the encryption of the kernel</span>
<span class="p_add">+	 *   pagetable structures for workarea (in case not currently mapped)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	execute_start = workarea_start;</span>
<span class="p_add">+	execute_end = execute_start + (PAGE_SIZE * 2) + PMD_PAGE_SIZE;</span>
<span class="p_add">+	execute_len = execute_end - execute_start;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * One PGD for both encrypted and decrypted mappings and a set of</span>
<span class="p_add">+	 * PUDs and PMDs for each of the encrypted and decrypted mappings.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pgtable_area_len = sizeof(pgd_t) * PTRS_PER_PGD;</span>
<span class="p_add">+	pgtable_area_len += sme_pgtable_calc(execute_end - kernel_start) * 2;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* PUDs and PMDs needed in the current pagetables for the workarea */</span>
<span class="p_add">+	pgtable_area_len += sme_pgtable_calc(execute_len + pgtable_area_len);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The total workarea includes the executable encryption area and</span>
<span class="p_add">+	 * the pagetable area.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	workarea_len = execute_len + pgtable_area_len;</span>
<span class="p_add">+	workarea_end = workarea_start + workarea_len;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Set the address to the start of where newly created pagetable</span>
<span class="p_add">+	 * structures (PGDs, PUDs and PMDs) will be allocated. New pagetable</span>
<span class="p_add">+	 * structures are created when the workarea is added to the current</span>
<span class="p_add">+	 * pagetables and when the new encrypted and decrypted kernel</span>
<span class="p_add">+	 * mappings are populated.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pgtable_area = (void *)execute_end;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Make sure the current pagetable structure has entries for</span>
<span class="p_add">+	 * addressing the workarea.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pgd = (pgd_t *)native_read_cr3_pa();</span>
<span class="p_add">+	paddr = workarea_start;</span>
<span class="p_add">+	while (paddr &lt; workarea_end) {</span>
<span class="p_add">+		pgtable_area = sme_populate_pgd(pgd, pgtable_area,</span>
<span class="p_add">+						paddr,</span>
<span class="p_add">+						paddr + PMD_FLAGS);</span>
<span class="p_add">+</span>
<span class="p_add">+		paddr += PMD_PAGE_SIZE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Flush the TLB - no globals so cr3 is enough */</span>
<span class="p_add">+	native_write_cr3(__native_read_cr3());</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * A new pagetable structure is being built to allow for the kernel</span>
<span class="p_add">+	 * to be encrypted. It starts with an empty PGD that will then be</span>
<span class="p_add">+	 * populated with new PUDs and PMDs as the encrypted and decrypted</span>
<span class="p_add">+	 * kernel mappings are created.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pgd = pgtable_area;</span>
<span class="p_add">+	memset(pgd, 0, sizeof(*pgd) * PTRS_PER_PGD);</span>
<span class="p_add">+	pgtable_area += sizeof(*pgd) * PTRS_PER_PGD;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Add encrypted kernel (identity) mappings */</span>
<span class="p_add">+	pmd_flags = PMD_FLAGS | _PAGE_ENC;</span>
<span class="p_add">+	paddr = kernel_start;</span>
<span class="p_add">+	while (paddr &lt; kernel_end) {</span>
<span class="p_add">+		pgtable_area = sme_populate_pgd(pgd, pgtable_area,</span>
<span class="p_add">+						paddr,</span>
<span class="p_add">+						paddr + pmd_flags);</span>
<span class="p_add">+</span>
<span class="p_add">+		paddr += PMD_PAGE_SIZE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * A different PGD index/entry must be used to get different</span>
<span class="p_add">+	 * pagetable entries for the decrypted mapping. Choose the next</span>
<span class="p_add">+	 * PGD index and convert it to a virtual address to be used as</span>
<span class="p_add">+	 * the base of the mapping.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	decrypted_base = (pgd_index(workarea_end) + 1) &amp; (PTRS_PER_PGD - 1);</span>
<span class="p_add">+	decrypted_base &lt;&lt;= PGDIR_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Add decrypted, write-protected kernel (non-identity) mappings */</span>
<span class="p_add">+	pmd_flags = (PMD_FLAGS &amp; ~_PAGE_CACHE_MASK) | (_PAGE_PAT | _PAGE_PWT);</span>
<span class="p_add">+	paddr = kernel_start;</span>
<span class="p_add">+	while (paddr &lt; kernel_end) {</span>
<span class="p_add">+		pgtable_area = sme_populate_pgd(pgd, pgtable_area,</span>
<span class="p_add">+						paddr + decrypted_base,</span>
<span class="p_add">+						paddr + pmd_flags);</span>
<span class="p_add">+</span>
<span class="p_add">+		paddr += PMD_PAGE_SIZE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Add decrypted workarea mappings to both kernel mappings */</span>
<span class="p_add">+	paddr = workarea_start;</span>
<span class="p_add">+	while (paddr &lt; workarea_end) {</span>
<span class="p_add">+		pgtable_area = sme_populate_pgd(pgd, pgtable_area,</span>
<span class="p_add">+						paddr,</span>
<span class="p_add">+						paddr + PMD_FLAGS);</span>
<span class="p_add">+</span>
<span class="p_add">+		pgtable_area = sme_populate_pgd(pgd, pgtable_area,</span>
<span class="p_add">+						paddr + decrypted_base,</span>
<span class="p_add">+						paddr + PMD_FLAGS);</span>
<span class="p_add">+</span>
<span class="p_add">+		paddr += PMD_PAGE_SIZE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Perform the encryption */</span>
<span class="p_add">+	sme_encrypt_execute(kernel_start, kernel_start + decrypted_base,</span>
<span class="p_add">+			    kernel_len, workarea_start, (unsigned long)pgd);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * At this point we are running encrypted.  Remove the mappings for</span>
<span class="p_add">+	 * the decrypted areas - all that is needed for this is to remove</span>
<span class="p_add">+	 * the PGD entry/entries.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	sme_clear_pgd(pgd, kernel_start + decrypted_base,</span>
<span class="p_add">+		      kernel_end + decrypted_base);</span>
<span class="p_add">+</span>
<span class="p_add">+	sme_clear_pgd(pgd, workarea_start + decrypted_base,</span>
<span class="p_add">+		      workarea_end + decrypted_base);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Flush the TLB - no globals so cr3 is enough */</span>
<span class="p_add">+	native_write_cr3(__native_read_cr3());</span>
 }
 
 void __init sme_enable(void)
<span class="p_header">diff --git a/arch/x86/mm/mem_encrypt_boot.S b/arch/x86/mm/mem_encrypt_boot.S</span>
new file mode 100644
<span class="p_header">index 0000000..b327e04</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/mm/mem_encrypt_boot.S</span>
<span class="p_chunk">@@ -0,0 +1,149 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * AMD Memory Encryption Support</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2016 Advanced Micro Devices, Inc.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Author: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;asm/pgtable.h&gt;</span>
<span class="p_add">+#include &lt;asm/page.h&gt;</span>
<span class="p_add">+#include &lt;asm/processor-flags.h&gt;</span>
<span class="p_add">+#include &lt;asm/msr-index.h&gt;</span>
<span class="p_add">+#include &lt;asm/frame.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+	.text</span>
<span class="p_add">+	.code64</span>
<span class="p_add">+ENTRY(sme_encrypt_execute)</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Entry parameters:</span>
<span class="p_add">+	 *   RDI - virtual address for the encrypted kernel mapping</span>
<span class="p_add">+	 *   RSI - virtual address for the decrypted kernel mapping</span>
<span class="p_add">+	 *   RDX - length of kernel</span>
<span class="p_add">+	 *   RCX - virtual address of the encryption workarea, including:</span>
<span class="p_add">+	 *     - stack page (PAGE_SIZE)</span>
<span class="p_add">+	 *     - encryption routine page (PAGE_SIZE)</span>
<span class="p_add">+	 *     - intermediate copy buffer (PMD_PAGE_SIZE)</span>
<span class="p_add">+	 *    R8 - physcial address of the pagetables to use for encryption</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	FRAME_BEGIN			/* RBP now has original stack pointer */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set up a one page stack in the non-encrypted memory area */</span>
<span class="p_add">+	movq	%rcx, %rax		/* Workarea stack page */</span>
<span class="p_add">+	leaq	PAGE_SIZE(%rax), %rsp	/* Set new stack pointer */</span>
<span class="p_add">+	addq	$PAGE_SIZE, %rax	/* Workarea encryption routine */</span>
<span class="p_add">+</span>
<span class="p_add">+	push	%r12</span>
<span class="p_add">+	movq	%rdi, %r10		/* Encrypted kernel */</span>
<span class="p_add">+	movq	%rsi, %r11		/* Decrypted kernel */</span>
<span class="p_add">+	movq	%rdx, %r12		/* Kernel length */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Copy encryption routine into the workarea */</span>
<span class="p_add">+	movq	%rax, %rdi				/* Workarea encryption routine */</span>
<span class="p_add">+	leaq	__enc_copy(%rip), %rsi			/* Encryption routine */</span>
<span class="p_add">+	movq	$(.L__enc_copy_end - __enc_copy), %rcx	/* Encryption routine length */</span>
<span class="p_add">+	rep	movsb</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Setup registers for call */</span>
<span class="p_add">+	movq	%r10, %rdi		/* Encrypted kernel */</span>
<span class="p_add">+	movq	%r11, %rsi		/* Decrypted kernel */</span>
<span class="p_add">+	movq	%r8, %rdx		/* Pagetables used for encryption */</span>
<span class="p_add">+	movq	%r12, %rcx		/* Kernel length */</span>
<span class="p_add">+	movq	%rax, %r8		/* Workarea encryption routine */</span>
<span class="p_add">+	addq	$PAGE_SIZE, %r8		/* Workarea intermediate copy buffer */</span>
<span class="p_add">+</span>
<span class="p_add">+	call	*%rax			/* Call the encryption routine */</span>
<span class="p_add">+</span>
<span class="p_add">+	pop	%r12</span>
<span class="p_add">+</span>
<span class="p_add">+	movq	%rbp, %rsp		/* Restore original stack pointer */</span>
<span class="p_add">+	FRAME_END</span>
<span class="p_add">+</span>
<span class="p_add">+	ret</span>
<span class="p_add">+ENDPROC(sme_encrypt_execute)</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(__enc_copy)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Routine used to encrypt kernel.</span>
<span class="p_add">+ *   This routine must be run outside of the kernel proper since</span>
<span class="p_add">+ *   the kernel will be encrypted during the process. So this</span>
<span class="p_add">+ *   routine is defined here and then copied to an area outside</span>
<span class="p_add">+ *   of the kernel where it will remain and run decrypted</span>
<span class="p_add">+ *   during execution.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   On entry the registers must be:</span>
<span class="p_add">+ *     RDI - virtual address for the encrypted kernel mapping</span>
<span class="p_add">+ *     RSI - virtual address for the decrypted kernel mapping</span>
<span class="p_add">+ *     RDX - address of the pagetables to use for encryption</span>
<span class="p_add">+ *     RCX - length of kernel</span>
<span class="p_add">+ *      R8 - intermediate copy buffer</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *     RAX - points to this routine</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The kernel will be encrypted by copying from the non-encrypted</span>
<span class="p_add">+ * kernel space to an intermediate buffer and then copying from the</span>
<span class="p_add">+ * intermediate buffer back to the encrypted kernel space. The physical</span>
<span class="p_add">+ * addresses of the two kernel space mappings are the same which</span>
<span class="p_add">+ * results in the kernel being encrypted &quot;in place&quot;.</span>
<span class="p_add">+ */</span>
<span class="p_add">+	/* Enable the new page tables */</span>
<span class="p_add">+	mov	%rdx, %cr3</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Flush any global TLBs */</span>
<span class="p_add">+	mov	%cr4, %rdx</span>
<span class="p_add">+	andq	$~X86_CR4_PGE, %rdx</span>
<span class="p_add">+	mov	%rdx, %cr4</span>
<span class="p_add">+	orq	$X86_CR4_PGE, %rdx</span>
<span class="p_add">+	mov	%rdx, %cr4</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set the PAT register PA5 entry to write-protect */</span>
<span class="p_add">+	push	%rcx</span>
<span class="p_add">+	movl	$MSR_IA32_CR_PAT, %ecx</span>
<span class="p_add">+	rdmsr</span>
<span class="p_add">+	push	%rdx			/* Save original PAT value */</span>
<span class="p_add">+	andl	$0xffff00ff, %edx	/* Clear PA5 */</span>
<span class="p_add">+	orl	$0x00000500, %edx	/* Set PA5 to WP */</span>
<span class="p_add">+	wrmsr</span>
<span class="p_add">+	pop	%rdx			/* RDX contains original PAT value */</span>
<span class="p_add">+	pop	%rcx</span>
<span class="p_add">+</span>
<span class="p_add">+	movq	%rcx, %r9		/* Save kernel length */</span>
<span class="p_add">+	movq	%rdi, %r10		/* Save encrypted kernel address */</span>
<span class="p_add">+	movq	%rsi, %r11		/* Save decrypted kernel address */</span>
<span class="p_add">+</span>
<span class="p_add">+	wbinvd				/* Invalidate any cache entries */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Copy/encrypt 2MB at a time */</span>
<span class="p_add">+1:</span>
<span class="p_add">+	movq	%r11, %rsi		/* Source - decrypted kernel */</span>
<span class="p_add">+	movq	%r8, %rdi		/* Dest   - intermediate copy buffer */</span>
<span class="p_add">+	movq	$PMD_PAGE_SIZE, %rcx	/* 2MB length */</span>
<span class="p_add">+	rep	movsb</span>
<span class="p_add">+</span>
<span class="p_add">+	movq	%r8, %rsi		/* Source - intermediate copy buffer */</span>
<span class="p_add">+	movq	%r10, %rdi		/* Dest   - encrypted kernel */</span>
<span class="p_add">+	movq	$PMD_PAGE_SIZE, %rcx	/* 2MB length */</span>
<span class="p_add">+	rep	movsb</span>
<span class="p_add">+</span>
<span class="p_add">+	addq	$PMD_PAGE_SIZE, %r11</span>
<span class="p_add">+	addq	$PMD_PAGE_SIZE, %r10</span>
<span class="p_add">+	subq	$PMD_PAGE_SIZE, %r9	/* Kernel length decrement */</span>
<span class="p_add">+	jnz	1b			/* Kernel length not zero? */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Restore PAT register */</span>
<span class="p_add">+	push	%rdx			/* Save original PAT value */</span>
<span class="p_add">+	movl	$MSR_IA32_CR_PAT, %ecx</span>
<span class="p_add">+	rdmsr</span>
<span class="p_add">+	pop	%rdx			/* Restore original PAT value */</span>
<span class="p_add">+	wrmsr</span>
<span class="p_add">+</span>
<span class="p_add">+	ret</span>
<span class="p_add">+.L__enc_copy_end:</span>
<span class="p_add">+ENDPROC(__enc_copy)</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



