
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>mm,hugetlb,migration: don&#39;t migrate kernelcore hugepages - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    mm,hugetlb,migration: don&#39;t migrate kernelcore hugepages</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=140631">Alexandru Moise</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 1, 2017, 10:51 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171001225111.GA16432@gmail.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9979903/mbox/"
   >mbox</a>
|
   <a href="/patch/9979903/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9979903/">/patch/9979903/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	7A5B560365 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun,  1 Oct 2017 22:51:26 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 67D5C28956
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun,  1 Oct 2017 22:51:26 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 5B98E289CD; Sun,  1 Oct 2017 22:51:26 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.5 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID, DKIM_VALID_AU, FREEMAIL_FROM, RCVD_IN_DNSWL_HI,
	RCVD_IN_SORBS_SPAM autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id CDAA128956
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun,  1 Oct 2017 22:51:25 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752245AbdJAWvX (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 1 Oct 2017 18:51:23 -0400
Received: from mail-wr0-f193.google.com ([209.85.128.193]:35824 &quot;EHLO
	mail-wr0-f193.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751773AbdJAWvV (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 1 Oct 2017 18:51:21 -0400
Received: by mail-wr0-f193.google.com with SMTP id r74so1461887wrb.2;
	Sun, 01 Oct 2017 15:51:20 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20161025;
	h=date:from:to:subject:message-id:mime-version:content-disposition
	:user-agent; bh=YMwM6e1E4QDAAgy1YSxMGBABsGPfcgmWmrqiZzy7gH0=;
	b=aTxdacEk3qOTm9L5s9OwZc7I6bGi7gPA/UIUFCOHo2WVjLoa7g+wXQHPIpvL+6VucN
	tC1mfQUTzy6OoFEGFX1Noa1FpJpsQ8Lz5O7rGPj9ZESl8Z4TUZzCyRWRAXxmGyr/TuwO
	wqYVK8ddNklXRaQolsxRM9mF9ISSJ/PWkCLcbsrtojRjZWwukWzHfevqqGTUHeptHNvH
	jVuiuhjx9JhKqqW0qkAc93e6+1JgwkCDZG8yipmOZa8g+nzA9y1mTNOWO2dmiF9jBHua
	CDlVihYIBFBPWdExxJ+wkYtzGQ4kzVhLs+6HJsvewXhouFuPuvNJ31Xj2eNF4NaCng1J
	aFUw==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:date:from:to:subject:message-id:mime-version
	:content-disposition:user-agent;
	bh=YMwM6e1E4QDAAgy1YSxMGBABsGPfcgmWmrqiZzy7gH0=;
	b=k7KXIAXDZ2Hq4vBmT3fgdropi5OQrau54Okd3EgDo4y7MKDVZR0HXbEts+mEwlPeur
	2GzY4Um/IpWS2OJAKYtGj3SNpVbWuF641TSnYd3Yhn+3VyuKSoNFvkSuKFmqmFutFkD4
	y0RBHUQiefgT22aZgD3zxIWQ4oNbad3TMQkPAuUP9tflnoP/4EAIKOkMjRajR2CSOamS
	dD7f7YUJ1h4Mm7ybSdHsG5A/ayPRJv9G+mpg307CTTPcbOWQ5diCeE513kvXzGUDfPMJ
	vaw5wHBV2pvMpuTZQjZKZ8ys/j9FCureKnz6Tyf5hdB3yVOVaV0h7vky3PPtxyS+ATbX
	6mdA==
X-Gm-Message-State: AMCzsaVgPA0r6HGTAPjgv6jZ+7h34S9o9A/E5+sb9eq9n17vtERmYxno
	30UelRPS1YGGCIClRavMMv0=
X-Google-Smtp-Source: AOwi7QCIT6rsnBl+uHXgswjaaV9VcFPpcxK7igWjezQ14YJSbJ/jN2hHojd4owrgKEoGHbIrClyN+w==
X-Received: by 10.223.130.20 with SMTP id 20mr170878wrb.216.1506898279670;
	Sun, 01 Oct 2017 15:51:19 -0700 (PDT)
Received: from gmail.com (51B691AA.dsl.pool.telekom.hu. [81.182.145.170])
	by smtp.gmail.com with ESMTPSA id
	2sm3943866wrg.58.2017.10.01.15.51.16
	(version=TLS1_2 cipher=ECDHE-RSA-CHACHA20-POLY1305 bits=256/256);
	Sun, 01 Oct 2017 15:51:18 -0700 (PDT)
Date: Mon, 2 Oct 2017 00:51:11 +0200
From: Alexandru Moise &lt;00moses.alexander00@gmail.com&gt;
To: corbet@lwn.net, paulmck@linux.vnet.ibm.com,
	akpm@linux-foundation.org, tglx@linutronix.de, mingo@kernel.org,
	cdall@linaro.org, mchehab@kernel.org, zohar@linux.vnet.ibm.com,
	marc.zyngier@arm.com, mhocko@suse.com, rientjes@google.com,
	hannes@cmpxchg.org, mike.kravetz@oracle.com,
	n-horiguchi@ah.jp.nec.com, aneesh.kumar@linux.vnet.ibm.com,
	punit.agrawal@arm.com, aarcange@redhat.com,
	gerald.schaefer@de.ibm.com, jglisse@redhat.com,
	kirill.shutemov@linux.intel.com, will.deacon@arm.com,
	linux-doc@vger.kernel.org, linux-kernel@vger.kernel.org,
	linux-mm@kvack.org
Subject: [PATCH] mm,hugetlb,migration: don&#39;t migrate kernelcore hugepages
Message-ID: &lt;20171001225111.GA16432@gmail.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.9.1 (2017-09-22)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=140631">Alexandru Moise</a> - Oct. 1, 2017, 10:51 p.m.</div>
<pre class="content">
This attempts to bring more flexibility to how hugepages are allocated
by making it possible to decide whether we want the hugepages to be
allocated from ZONE_MOVABLE or to the zone allocated by the &quot;kernelcore=&quot;
boot parameter for non-movable allocations.

A new boot parameter is introduced, &quot;hugepages_movable=&quot;, this sets the
default value for the &quot;hugepages_treat_as_movable&quot; sysctl. This allows
us to determine the zone for hugepages allocated at boot time. It only
affects 2M hugepages allocated at boot time for now because 1G
hugepages are allocated much earlier in the boot process and ignore
this sysctl completely.

The &quot;hugepages_treat_as_movable&quot; sysctl is also turned into a mandatory
setting that all hugepage allocations at runtime must respect (both
2M and 1G sized hugepages). The default value is changed to &quot;1&quot; to
preserve the existing behavior that if hugepage migration is supported,
then the pages will be allocated from ZONE_MOVABLE.

Note however if not enough contiguous memory is present in ZONE_MOVABLE
then the allocation will fallback to the non-movable zone and those
pages will not be migratable.

The implementation is a bit dirty so obviously I&#39;m open to suggestions
for a better way to implement this behavior, or comments whether the whole
idea is fundamentally __wrong__.
<span class="signed-off-by">
Signed-off-by: Alexandru Moise &lt;00moses.alexander00@gmail.com&gt;</span>
---
 Documentation/admin-guide/kernel-parameters.txt |  8 ++++++++
 Documentation/sysctl/vm.txt                     |  3 +++
 mm/hugetlb.c                                    | 15 +++++++++++++--
 mm/migrate.c                                    |  8 +++++++-
 4 files changed, 31 insertions(+), 3 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137061">Michal Hocko</a> - Oct. 2, 2017, 12:54 p.m.</div>
<pre class="content">
On Mon 02-10-17 00:51:11, Alexandru Moise wrote:
<span class="quote">&gt; This attempts to bring more flexibility to how hugepages are allocated</span>
<span class="quote">&gt; by making it possible to decide whether we want the hugepages to be</span>
<span class="quote">&gt; allocated from ZONE_MOVABLE or to the zone allocated by the &quot;kernelcore=&quot;</span>
<span class="quote">&gt; boot parameter for non-movable allocations.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; A new boot parameter is introduced, &quot;hugepages_movable=&quot;, this sets the</span>
<span class="quote">&gt; default value for the &quot;hugepages_treat_as_movable&quot; sysctl. This allows</span>
<span class="quote">&gt; us to determine the zone for hugepages allocated at boot time. It only</span>
<span class="quote">&gt; affects 2M hugepages allocated at boot time for now because 1G</span>
<span class="quote">&gt; hugepages are allocated much earlier in the boot process and ignore</span>
<span class="quote">&gt; this sysctl completely.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The &quot;hugepages_treat_as_movable&quot; sysctl is also turned into a mandatory</span>
<span class="quote">&gt; setting that all hugepage allocations at runtime must respect (both</span>
<span class="quote">&gt; 2M and 1G sized hugepages). The default value is changed to &quot;1&quot; to</span>
<span class="quote">&gt; preserve the existing behavior that if hugepage migration is supported,</span>
<span class="quote">&gt; then the pages will be allocated from ZONE_MOVABLE.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Note however if not enough contiguous memory is present in ZONE_MOVABLE</span>
<span class="quote">&gt; then the allocation will fallback to the non-movable zone and those</span>
<span class="quote">&gt; pages will not be migratable.</span>

This changelog doesn&#39;t explain _why_ we would need something like that.
<span class="quote">
&gt; The implementation is a bit dirty so obviously I&#39;m open to suggestions</span>
<span class="quote">&gt; for a better way to implement this behavior, or comments whether the whole</span>
<span class="quote">&gt; idea is fundamentally __wrong__.</span>

To be honest I think this is just a wrong approach. hugepages_treat_as_movable
is quite questionable to be honest because it breaks the basic semantic
of the movable zone if the hugetlb pages are not really migratable which
should be the only criterion. Hugetlb pages are no different from other
migratable pages in that regards.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=140631">Alexandru Moise</a> - Oct. 2, 2017, 2:06 p.m.</div>
<pre class="content">
On Mon, Oct 02, 2017 at 02:54:32PM +0200, Michal Hocko wrote:
<span class="quote">&gt; On Mon 02-10-17 00:51:11, Alexandru Moise wrote:</span>
<span class="quote">&gt; &gt; This attempts to bring more flexibility to how hugepages are allocated</span>
<span class="quote">&gt; &gt; by making it possible to decide whether we want the hugepages to be</span>
<span class="quote">&gt; &gt; allocated from ZONE_MOVABLE or to the zone allocated by the &quot;kernelcore=&quot;</span>
<span class="quote">&gt; &gt; boot parameter for non-movable allocations.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; A new boot parameter is introduced, &quot;hugepages_movable=&quot;, this sets the</span>
<span class="quote">&gt; &gt; default value for the &quot;hugepages_treat_as_movable&quot; sysctl. This allows</span>
<span class="quote">&gt; &gt; us to determine the zone for hugepages allocated at boot time. It only</span>
<span class="quote">&gt; &gt; affects 2M hugepages allocated at boot time for now because 1G</span>
<span class="quote">&gt; &gt; hugepages are allocated much earlier in the boot process and ignore</span>
<span class="quote">&gt; &gt; this sysctl completely.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; The &quot;hugepages_treat_as_movable&quot; sysctl is also turned into a mandatory</span>
<span class="quote">&gt; &gt; setting that all hugepage allocations at runtime must respect (both</span>
<span class="quote">&gt; &gt; 2M and 1G sized hugepages). The default value is changed to &quot;1&quot; to</span>
<span class="quote">&gt; &gt; preserve the existing behavior that if hugepage migration is supported,</span>
<span class="quote">&gt; &gt; then the pages will be allocated from ZONE_MOVABLE.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Note however if not enough contiguous memory is present in ZONE_MOVABLE</span>
<span class="quote">&gt; &gt; then the allocation will fallback to the non-movable zone and those</span>
<span class="quote">&gt; &gt; pages will not be migratable.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This changelog doesn&#39;t explain _why_ we would need something like that.</span>
<span class="quote">&gt; </span>

So people shouldn&#39;t be able to choose whether their hugepages should be
migratable or not? Maybe they consider some of their applications more
important than others.

Say:
You have a large number of correctable errors on a subpage of a compound
page. So you copy the contents of the page to another hugepage, break the
original page and offline the subpage. But maybe you&#39;d rather that some of
your hugepages not be broken and moved because you&#39;re not that worried about
memory corruption, but more about availability.

Without this patch even if hugepages are in the non-movable zone, they move.
<span class="quote">
&gt; &gt; The implementation is a bit dirty so obviously I&#39;m open to suggestions</span>
<span class="quote">&gt; &gt; for a better way to implement this behavior, or comments whether the whole</span>
<span class="quote">&gt; &gt; idea is fundamentally __wrong__.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; To be honest I think this is just a wrong approach. hugepages_treat_as_movable</span>
<span class="quote">&gt; is quite questionable to be honest because it breaks the basic semantic</span>
<span class="quote">&gt; of the movable zone if the hugetlb pages are not really migratable which</span>
<span class="quote">&gt; should be the only criterion. Hugetlb pages are no different from other</span>
<span class="quote">&gt; migratable pages in that regards.</span>

Shouldn&#39;t hugepages allocated to unmovable zone, by definition, not be able
to be migrated? With this patch, hugepages in the movable zone do move, but
hugepages in the non-movable zone don&#39;t. Or am I misunderstanding the semantics
completely?

../Alex
<span class="quote">&gt; -- </span>
<span class="quote">&gt; Michal Hocko</span>
<span class="quote">&gt; SUSE Labs</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137061">Michal Hocko</a> - Oct. 2, 2017, 2:27 p.m.</div>
<pre class="content">
On Mon 02-10-17 16:06:33, Alexandru Moise wrote:
<span class="quote">&gt; On Mon, Oct 02, 2017 at 02:54:32PM +0200, Michal Hocko wrote:</span>
<span class="quote">&gt; &gt; On Mon 02-10-17 00:51:11, Alexandru Moise wrote:</span>
<span class="quote">&gt; &gt; &gt; This attempts to bring more flexibility to how hugepages are allocated</span>
<span class="quote">&gt; &gt; &gt; by making it possible to decide whether we want the hugepages to be</span>
<span class="quote">&gt; &gt; &gt; allocated from ZONE_MOVABLE or to the zone allocated by the &quot;kernelcore=&quot;</span>
<span class="quote">&gt; &gt; &gt; boot parameter for non-movable allocations.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; A new boot parameter is introduced, &quot;hugepages_movable=&quot;, this sets the</span>
<span class="quote">&gt; &gt; &gt; default value for the &quot;hugepages_treat_as_movable&quot; sysctl. This allows</span>
<span class="quote">&gt; &gt; &gt; us to determine the zone for hugepages allocated at boot time. It only</span>
<span class="quote">&gt; &gt; &gt; affects 2M hugepages allocated at boot time for now because 1G</span>
<span class="quote">&gt; &gt; &gt; hugepages are allocated much earlier in the boot process and ignore</span>
<span class="quote">&gt; &gt; &gt; this sysctl completely.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; The &quot;hugepages_treat_as_movable&quot; sysctl is also turned into a mandatory</span>
<span class="quote">&gt; &gt; &gt; setting that all hugepage allocations at runtime must respect (both</span>
<span class="quote">&gt; &gt; &gt; 2M and 1G sized hugepages). The default value is changed to &quot;1&quot; to</span>
<span class="quote">&gt; &gt; &gt; preserve the existing behavior that if hugepage migration is supported,</span>
<span class="quote">&gt; &gt; &gt; then the pages will be allocated from ZONE_MOVABLE.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Note however if not enough contiguous memory is present in ZONE_MOVABLE</span>
<span class="quote">&gt; &gt; &gt; then the allocation will fallback to the non-movable zone and those</span>
<span class="quote">&gt; &gt; &gt; pages will not be migratable.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; This changelog doesn&#39;t explain _why_ we would need something like that.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So people shouldn&#39;t be able to choose whether their hugepages should be</span>
<span class="quote">&gt; migratable or not?</span>

How are hugetlb pages any different from THP wrt. migrateability POV? Or
any other mapped memory to the userspace in general?
<span class="quote">
&gt; Maybe they consider some of their applications more important than</span>
<span class="quote">&gt; others.</span>

I do not understand this part.
<span class="quote">
&gt; Say:</span>
<span class="quote">&gt; You have a large number of correctable errors on a subpage of a compound</span>
<span class="quote">&gt; page. So you copy the contents of the page to another hugepage, break the</span>
<span class="quote">&gt; original page and offline the subpage. </span>

I suspect you have HWPoisoning in mind right?
<span class="quote">
&gt; But maybe you&#39;d rather that some of</span>
<span class="quote">&gt; your hugepages not be broken and moved because you&#39;re not that worried about</span>
<span class="quote">&gt; memory corruption, but more about availability.</span>

Could you be more specific please?
<span class="quote">
&gt; Without this patch even if hugepages are in the non-movable zone, they move.</span>

which is ok. This is very same with any other movable allocations.
<span class="quote"> 
&gt; &gt; &gt; The implementation is a bit dirty so obviously I&#39;m open to suggestions</span>
<span class="quote">&gt; &gt; &gt; for a better way to implement this behavior, or comments whether the whole</span>
<span class="quote">&gt; &gt; &gt; idea is fundamentally __wrong__.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; To be honest I think this is just a wrong approach. hugepages_treat_as_movable</span>
<span class="quote">&gt; &gt; is quite questionable to be honest because it breaks the basic semantic</span>
<span class="quote">&gt; &gt; of the movable zone if the hugetlb pages are not really migratable which</span>
<span class="quote">&gt; &gt; should be the only criterion. Hugetlb pages are no different from other</span>
<span class="quote">&gt; &gt; migratable pages in that regards.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Shouldn&#39;t hugepages allocated to unmovable zone, by definition, not be able</span>
<span class="quote">&gt; to be migrated? With this patch, hugepages in the movable zone do move, but</span>
<span class="quote">&gt; hugepages in the non-movable zone don&#39;t. Or am I misunderstanding the semantics</span>
<span class="quote">&gt; completely?</span>

yes. movable zone is only about a guarantee to move memory around.
Movable allocations are still allowed to use kernel zones (aka
non-movable). The main reason for the movable zone these days is memory
hotplug which needs a semi-guarantee that the memory used can be
migrated elsewhere to free up the offlined memory.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=140631">Alexandru Moise</a> - Oct. 2, 2017, 3:06 p.m.</div>
<pre class="content">
On Mon, Oct 02, 2017 at 04:27:17PM +0200, Michal Hocko wrote:
<span class="quote">&gt; On Mon 02-10-17 16:06:33, Alexandru Moise wrote:</span>
<span class="quote">&gt; &gt; On Mon, Oct 02, 2017 at 02:54:32PM +0200, Michal Hocko wrote:</span>
<span class="quote">&gt; &gt; &gt; On Mon 02-10-17 00:51:11, Alexandru Moise wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; This attempts to bring more flexibility to how hugepages are allocated</span>
<span class="quote">&gt; &gt; &gt; &gt; by making it possible to decide whether we want the hugepages to be</span>
<span class="quote">&gt; &gt; &gt; &gt; allocated from ZONE_MOVABLE or to the zone allocated by the &quot;kernelcore=&quot;</span>
<span class="quote">&gt; &gt; &gt; &gt; boot parameter for non-movable allocations.</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; A new boot parameter is introduced, &quot;hugepages_movable=&quot;, this sets the</span>
<span class="quote">&gt; &gt; &gt; &gt; default value for the &quot;hugepages_treat_as_movable&quot; sysctl. This allows</span>
<span class="quote">&gt; &gt; &gt; &gt; us to determine the zone for hugepages allocated at boot time. It only</span>
<span class="quote">&gt; &gt; &gt; &gt; affects 2M hugepages allocated at boot time for now because 1G</span>
<span class="quote">&gt; &gt; &gt; &gt; hugepages are allocated much earlier in the boot process and ignore</span>
<span class="quote">&gt; &gt; &gt; &gt; this sysctl completely.</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; The &quot;hugepages_treat_as_movable&quot; sysctl is also turned into a mandatory</span>
<span class="quote">&gt; &gt; &gt; &gt; setting that all hugepage allocations at runtime must respect (both</span>
<span class="quote">&gt; &gt; &gt; &gt; 2M and 1G sized hugepages). The default value is changed to &quot;1&quot; to</span>
<span class="quote">&gt; &gt; &gt; &gt; preserve the existing behavior that if hugepage migration is supported,</span>
<span class="quote">&gt; &gt; &gt; &gt; then the pages will be allocated from ZONE_MOVABLE.</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; Note however if not enough contiguous memory is present in ZONE_MOVABLE</span>
<span class="quote">&gt; &gt; &gt; &gt; then the allocation will fallback to the non-movable zone and those</span>
<span class="quote">&gt; &gt; &gt; &gt; pages will not be migratable.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; This changelog doesn&#39;t explain _why_ we would need something like that.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; So people shouldn&#39;t be able to choose whether their hugepages should be</span>
<span class="quote">&gt; &gt; migratable or not?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; How are hugetlb pages any different from THP wrt. migrateability POV? Or</span>
<span class="quote">&gt; any other mapped memory to the userspace in general?</span>

THP shares more with regular userspace mapped memory than with hugetlbfs pages.
They have separate codepaths in migrate_pages(). And no one ever sets the movable
flag on a hugetlbfs mapping, so even though __PageMovable(hpage) on a hugetlbfs
page returns false, it will still move.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; Maybe they consider some of their applications more important than</span>
<span class="quote">&gt; &gt; others.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I do not understand this part.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; Say:</span>
<span class="quote">&gt; &gt; You have a large number of correctable errors on a subpage of a compound</span>
<span class="quote">&gt; &gt; page. So you copy the contents of the page to another hugepage, break the</span>
<span class="quote">&gt; &gt; original page and offline the subpage. </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I suspect you have HWPoisoning in mind right?</span>

No, rather soft offlining. 
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; But maybe you&#39;d rather that some of</span>
<span class="quote">&gt; &gt; your hugepages not be broken and moved because you&#39;re not that worried about</span>
<span class="quote">&gt; &gt; memory corruption, but more about availability.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Could you be more specific please?</span>

You can have a platform with reliable DIMM modules and a platform with less reliable
DIMM modules. So you would prefer to inhibit hugepage migration on the platform with
reliable DIMM modules that you know will behave ok even under a high number of 
correctable memory errors. tools like mcelog however are not hugepage aware and
cannot be told &quot;if this PFN is part of a hugepage, don&#39;t try to soft offline it&quot;,
rather deciding which PFNs should be unmovable should be done in the kernel,
but it should still be controllable by the administrator.

For hugetlbfs pages in particular, this behavior is not present, without this patch.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; Without this patch even if hugepages are in the non-movable zone, they move.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; which is ok. This is very same with any other movable allocations.</span>

So you can have movable pages in the non-movable kernel zone?
<span class="quote">
&gt;  </span>
<span class="quote">&gt; &gt; &gt; &gt; The implementation is a bit dirty so obviously I&#39;m open to suggestions</span>
<span class="quote">&gt; &gt; &gt; &gt; for a better way to implement this behavior, or comments whether the whole</span>
<span class="quote">&gt; &gt; &gt; &gt; idea is fundamentally __wrong__.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; To be honest I think this is just a wrong approach. hugepages_treat_as_movable</span>
<span class="quote">&gt; &gt; &gt; is quite questionable to be honest because it breaks the basic semantic</span>
<span class="quote">&gt; &gt; &gt; of the movable zone if the hugetlb pages are not really migratable which</span>
<span class="quote">&gt; &gt; &gt; should be the only criterion. Hugetlb pages are no different from other</span>
<span class="quote">&gt; &gt; &gt; migratable pages in that regards.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Shouldn&#39;t hugepages allocated to unmovable zone, by definition, not be able</span>
<span class="quote">&gt; &gt; to be migrated? With this patch, hugepages in the movable zone do move, but</span>
<span class="quote">&gt; &gt; hugepages in the non-movable zone don&#39;t. Or am I misunderstanding the semantics</span>
<span class="quote">&gt; &gt; completely?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; yes. movable zone is only about a guarantee to move memory around.</span>
<span class="quote">&gt; Movable allocations are still allowed to use kernel zones (aka</span>
<span class="quote">&gt; non-movable). The main reason for the movable zone these days is memory</span>
<span class="quote">&gt; hotplug which needs a semi-guarantee that the memory used can be</span>
<span class="quote">&gt; migrated elsewhere to free up the offlined memory.</span>

But isn&#39;t kernel-zone memory guaranteed not to migrate?

I agree that movable allocations are allowed to fallback to kernel zones.
i.e. This is behavior is correct:
Page A is in ZONE_MOVABLE, page B is in kernel zone.
Page A gets soft-offlined, the contents are moved to page B.

This behavior is not correct:
Page C is in kernel zone, page D is also in kernel zone.
Page C gets soft offlined, contents of page C get moved to page D.

With hugepages, there is no check for whereto the migration goes because
the pages are pre-allocated and simply dequeued from the hstate freelist.

Thus hugepages will end up being unreserved and moved to a different
reserved hugepage, and the administrator has no control over this behavior,
even if they&#39;re kernel zone pages.
<span class="quote">
&gt; </span>
<span class="quote">&gt; -- </span>
<span class="quote">&gt; Michal Hocko</span>
<span class="quote">&gt; SUSE Labs</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137061">Michal Hocko</a> - Oct. 2, 2017, 4:15 p.m.</div>
<pre class="content">
On Mon 02-10-17 17:06:38, Alexandru Moise wrote:
<span class="quote">&gt; On Mon, Oct 02, 2017 at 04:27:17PM +0200, Michal Hocko wrote:</span>
<span class="quote">&gt; &gt; On Mon 02-10-17 16:06:33, Alexandru Moise wrote:</span>
<span class="quote">&gt; &gt; &gt; On Mon, Oct 02, 2017 at 02:54:32PM +0200, Michal Hocko wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; On Mon 02-10-17 00:51:11, Alexandru Moise wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; This attempts to bring more flexibility to how hugepages are allocated</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; by making it possible to decide whether we want the hugepages to be</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; allocated from ZONE_MOVABLE or to the zone allocated by the &quot;kernelcore=&quot;</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; boot parameter for non-movable allocations.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; A new boot parameter is introduced, &quot;hugepages_movable=&quot;, this sets the</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; default value for the &quot;hugepages_treat_as_movable&quot; sysctl. This allows</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; us to determine the zone for hugepages allocated at boot time. It only</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; affects 2M hugepages allocated at boot time for now because 1G</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; hugepages are allocated much earlier in the boot process and ignore</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; this sysctl completely.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; The &quot;hugepages_treat_as_movable&quot; sysctl is also turned into a mandatory</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; setting that all hugepage allocations at runtime must respect (both</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; 2M and 1G sized hugepages). The default value is changed to &quot;1&quot; to</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; preserve the existing behavior that if hugepage migration is supported,</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; then the pages will be allocated from ZONE_MOVABLE.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; Note however if not enough contiguous memory is present in ZONE_MOVABLE</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; then the allocation will fallback to the non-movable zone and those</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; pages will not be migratable.</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; This changelog doesn&#39;t explain _why_ we would need something like that.</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; So people shouldn&#39;t be able to choose whether their hugepages should be</span>
<span class="quote">&gt; &gt; &gt; migratable or not?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; How are hugetlb pages any different from THP wrt. migrateability POV? Or</span>
<span class="quote">&gt; &gt; any other mapped memory to the userspace in general?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; THP shares more with regular userspace mapped memory than with hugetlbfs pages.</span>
<span class="quote">&gt; They have separate codepaths in migrate_pages().</span>

That is a mere implementation detail. You are right that THP shares more
with regular userspace memory because it is transparent from the
configuration POV but that has nothing to do with page migration AFAICS.
<span class="quote">
&gt; And no one ever sets the movable</span>
<span class="quote">&gt; flag on a hugetlbfs mapping, so even though __PageMovable(hpage) on a hugetlbfs</span>
<span class="quote">&gt; page returns false, it will still move.</span>

__PageMovable is a completely unrelated thing. It is for pages which are
!LRU but still movable.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Maybe they consider some of their applications more important than</span>
<span class="quote">&gt; &gt; &gt; others.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; I do not understand this part.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Say:</span>
<span class="quote">&gt; &gt; &gt; You have a large number of correctable errors on a subpage of a compound</span>
<span class="quote">&gt; &gt; &gt; page. So you copy the contents of the page to another hugepage, break the</span>
<span class="quote">&gt; &gt; &gt; original page and offline the subpage. </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; I suspect you have HWPoisoning in mind right?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; No, rather soft offlining. </span>

I thought this is the same thing.
<span class="quote">
&gt; &gt; &gt; But maybe you&#39;d rather that some of</span>
<span class="quote">&gt; &gt; &gt; your hugepages not be broken and moved because you&#39;re not that worried about</span>
<span class="quote">&gt; &gt; &gt; memory corruption, but more about availability.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Could you be more specific please?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; You can have a platform with reliable DIMM modules and a platform with less reliable</span>
<span class="quote">&gt; DIMM modules. So you would prefer to inhibit hugepage migration on the platform with</span>
<span class="quote">&gt; reliable DIMM modules that you know will behave ok even under a high number of </span>
<span class="quote">&gt; correctable memory errors. tools like mcelog however are not hugepage aware and</span>
<span class="quote">&gt; cannot be told &quot;if this PFN is part of a hugepage, don&#39;t try to soft offline it&quot;,</span>
<span class="quote">&gt; rather deciding which PFNs should be unmovable should be done in the kernel,</span>
<span class="quote">&gt; but it should still be controllable by the administrator.</span>

This sounds like a userspace policy that should be handled outside of
the kernel.
<span class="quote">
&gt; For hugetlbfs pages in particular, this behavior is not present, without this patch.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Without this patch even if hugepages are in the non-movable zone, they move.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; which is ok. This is very same with any other movable allocations.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So you can have movable pages in the non-movable kernel zone?</span>

yes. Most configuration even do not have any movable zone unless
explicitly configured.
<span class="quote">
&gt; &gt; &gt; &gt; &gt; The implementation is a bit dirty so obviously I&#39;m open to suggestions</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; for a better way to implement this behavior, or comments whether the whole</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; idea is fundamentally __wrong__.</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; To be honest I think this is just a wrong approach. hugepages_treat_as_movable</span>
<span class="quote">&gt; &gt; &gt; &gt; is quite questionable to be honest because it breaks the basic semantic</span>
<span class="quote">&gt; &gt; &gt; &gt; of the movable zone if the hugetlb pages are not really migratable which</span>
<span class="quote">&gt; &gt; &gt; &gt; should be the only criterion. Hugetlb pages are no different from other</span>
<span class="quote">&gt; &gt; &gt; &gt; migratable pages in that regards.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Shouldn&#39;t hugepages allocated to unmovable zone, by definition, not be able</span>
<span class="quote">&gt; &gt; &gt; to be migrated? With this patch, hugepages in the movable zone do move, but</span>
<span class="quote">&gt; &gt; &gt; hugepages in the non-movable zone don&#39;t. Or am I misunderstanding the semantics</span>
<span class="quote">&gt; &gt; &gt; completely?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; yes. movable zone is only about a guarantee to move memory around.</span>
<span class="quote">&gt; &gt; Movable allocations are still allowed to use kernel zones (aka</span>
<span class="quote">&gt; &gt; non-movable). The main reason for the movable zone these days is memory</span>
<span class="quote">&gt; &gt; hotplug which needs a semi-guarantee that the memory used can be</span>
<span class="quote">&gt; &gt; migrated elsewhere to free up the offlined memory.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; But isn&#39;t kernel-zone memory guaranteed not to migrate?</span>

No.
<span class="quote">
&gt; I agree that movable allocations are allowed to fallback to kernel zones.</span>
<span class="quote">&gt; i.e. This is behavior is correct:</span>
<span class="quote">&gt; Page A is in ZONE_MOVABLE, page B is in kernel zone.</span>
<span class="quote">&gt; Page A gets soft-offlined, the contents are moved to page B.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This behavior is not correct:</span>
<span class="quote">&gt; Page C is in kernel zone, page D is also in kernel zone.</span>
<span class="quote">&gt; Page C gets soft offlined, contents of page C get moved to page D.</span>

Why is this incorrect?
<span class="quote">
&gt; With hugepages, there is no check for whereto the migration goes because</span>
<span class="quote">&gt; the pages are pre-allocated and simply dequeued from the hstate freelist.</span>

true
<span class="quote">
&gt; Thus hugepages will end up being unreserved and moved to a different</span>
<span class="quote">&gt; reserved hugepage, and the administrator has no control over this behavior,</span>
<span class="quote">&gt; even if they&#39;re kernel zone pages.</span>

I really fail to see why kernel vs. movable zones play any role here.
Zones should be mostly an implementation detail which userspace
shouldn&#39;t really care about.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=140631">Alexandru Moise</a> - Oct. 3, 2017, 5:42 a.m.</div>
<pre class="content">
On Mon, Oct 02, 2017 at 06:15:00PM +0200, Michal Hocko wrote:
<span class="quote">&gt; On Mon 02-10-17 17:06:38, Alexandru Moise wrote:</span>
<span class="quote">&gt; &gt; On Mon, Oct 02, 2017 at 04:27:17PM +0200, Michal Hocko wrote:</span>
<span class="quote">&gt; &gt; &gt; On Mon 02-10-17 16:06:33, Alexandru Moise wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; On Mon, Oct 02, 2017 at 02:54:32PM +0200, Michal Hocko wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; On Mon 02-10-17 00:51:11, Alexandru Moise wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; This attempts to bring more flexibility to how hugepages are allocated</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; by making it possible to decide whether we want the hugepages to be</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; allocated from ZONE_MOVABLE or to the zone allocated by the &quot;kernelcore=&quot;</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; boot parameter for non-movable allocations.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; A new boot parameter is introduced, &quot;hugepages_movable=&quot;, this sets the</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; default value for the &quot;hugepages_treat_as_movable&quot; sysctl. This allows</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; us to determine the zone for hugepages allocated at boot time. It only</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; affects 2M hugepages allocated at boot time for now because 1G</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; hugepages are allocated much earlier in the boot process and ignore</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; this sysctl completely.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; The &quot;hugepages_treat_as_movable&quot; sysctl is also turned into a mandatory</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; setting that all hugepage allocations at runtime must respect (both</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; 2M and 1G sized hugepages). The default value is changed to &quot;1&quot; to</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; preserve the existing behavior that if hugepage migration is supported,</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; then the pages will be allocated from ZONE_MOVABLE.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; Note however if not enough contiguous memory is present in ZONE_MOVABLE</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; then the allocation will fallback to the non-movable zone and those</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; pages will not be migratable.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; This changelog doesn&#39;t explain _why_ we would need something like that.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; So people shouldn&#39;t be able to choose whether their hugepages should be</span>
<span class="quote">&gt; &gt; &gt; &gt; migratable or not?</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; How are hugetlb pages any different from THP wrt. migrateability POV? Or</span>
<span class="quote">&gt; &gt; &gt; any other mapped memory to the userspace in general?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; THP shares more with regular userspace mapped memory than with hugetlbfs pages.</span>
<span class="quote">&gt; &gt; They have separate codepaths in migrate_pages().</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; That is a mere implementation detail. You are right that THP shares more</span>
<span class="quote">&gt; with regular userspace memory because it is transparent from the</span>
<span class="quote">&gt; configuration POV but that has nothing to do with page migration AFAICS.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; And no one ever sets the movable</span>
<span class="quote">&gt; &gt; flag on a hugetlbfs mapping, so even though __PageMovable(hpage) on a hugetlbfs</span>
<span class="quote">&gt; &gt; page returns false, it will still move.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; __PageMovable is a completely unrelated thing. It is for pages which are</span>
<span class="quote">&gt; !LRU but still movable.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; Maybe they consider some of their applications more important than</span>
<span class="quote">&gt; &gt; &gt; &gt; others.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; I do not understand this part.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; Say:</span>
<span class="quote">&gt; &gt; &gt; &gt; You have a large number of correctable errors on a subpage of a compound</span>
<span class="quote">&gt; &gt; &gt; &gt; page. So you copy the contents of the page to another hugepage, break the</span>
<span class="quote">&gt; &gt; &gt; &gt; original page and offline the subpage. </span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; I suspect you have HWPoisoning in mind right?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; No, rather soft offlining. </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I thought this is the same thing.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; But maybe you&#39;d rather that some of</span>
<span class="quote">&gt; &gt; &gt; &gt; your hugepages not be broken and moved because you&#39;re not that worried about</span>
<span class="quote">&gt; &gt; &gt; &gt; memory corruption, but more about availability.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Could you be more specific please?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; You can have a platform with reliable DIMM modules and a platform with less reliable</span>
<span class="quote">&gt; &gt; DIMM modules. So you would prefer to inhibit hugepage migration on the platform with</span>
<span class="quote">&gt; &gt; reliable DIMM modules that you know will behave ok even under a high number of </span>
<span class="quote">&gt; &gt; correctable memory errors. tools like mcelog however are not hugepage aware and</span>
<span class="quote">&gt; &gt; cannot be told &quot;if this PFN is part of a hugepage, don&#39;t try to soft offline it&quot;,</span>
<span class="quote">&gt; &gt; rather deciding which PFNs should be unmovable should be done in the kernel,</span>
<span class="quote">&gt; &gt; but it should still be controllable by the administrator.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This sounds like a userspace policy that should be handled outside of</span>
<span class="quote">&gt; the kernel.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; For hugetlbfs pages in particular, this behavior is not present, without this patch.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; Without this patch even if hugepages are in the non-movable zone, they move.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; which is ok. This is very same with any other movable allocations.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; So you can have movable pages in the non-movable kernel zone?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; yes. Most configuration even do not have any movable zone unless</span>
<span class="quote">&gt; explicitly configured.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; The implementation is a bit dirty so obviously I&#39;m open to suggestions</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; for a better way to implement this behavior, or comments whether the whole</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; idea is fundamentally __wrong__.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; To be honest I think this is just a wrong approach. hugepages_treat_as_movable</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; is quite questionable to be honest because it breaks the basic semantic</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; of the movable zone if the hugetlb pages are not really migratable which</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; should be the only criterion. Hugetlb pages are no different from other</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; migratable pages in that regards.</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; Shouldn&#39;t hugepages allocated to unmovable zone, by definition, not be able</span>
<span class="quote">&gt; &gt; &gt; &gt; to be migrated? With this patch, hugepages in the movable zone do move, but</span>
<span class="quote">&gt; &gt; &gt; &gt; hugepages in the non-movable zone don&#39;t. Or am I misunderstanding the semantics</span>
<span class="quote">&gt; &gt; &gt; &gt; completely?</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; yes. movable zone is only about a guarantee to move memory around.</span>
<span class="quote">&gt; &gt; &gt; Movable allocations are still allowed to use kernel zones (aka</span>
<span class="quote">&gt; &gt; &gt; non-movable). The main reason for the movable zone these days is memory</span>
<span class="quote">&gt; &gt; &gt; hotplug which needs a semi-guarantee that the memory used can be</span>
<span class="quote">&gt; &gt; &gt; migrated elsewhere to free up the offlined memory.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; But isn&#39;t kernel-zone memory guaranteed not to migrate?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; No.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; I agree that movable allocations are allowed to fallback to kernel zones.</span>
<span class="quote">&gt; &gt; i.e. This is behavior is correct:</span>
<span class="quote">&gt; &gt; Page A is in ZONE_MOVABLE, page B is in kernel zone.</span>
<span class="quote">&gt; &gt; Page A gets soft-offlined, the contents are moved to page B.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; This behavior is not correct:</span>
<span class="quote">&gt; &gt; Page C is in kernel zone, page D is also in kernel zone.</span>
<span class="quote">&gt; &gt; Page C gets soft offlined, contents of page C get moved to page D.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Why is this incorrect?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; With hugepages, there is no check for whereto the migration goes because</span>
<span class="quote">&gt; &gt; the pages are pre-allocated and simply dequeued from the hstate freelist.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; true</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; Thus hugepages will end up being unreserved and moved to a different</span>
<span class="quote">&gt; &gt; reserved hugepage, and the administrator has no control over this behavior,</span>
<span class="quote">&gt; &gt; even if they&#39;re kernel zone pages.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I really fail to see why kernel vs. movable zones play any role here.</span>
<span class="quote">&gt; Zones should be mostly an implementation detail which userspace</span>
<span class="quote">&gt; shouldn&#39;t really care about.</span>

Ok, the whole zone approach is a bad idea. Do you think that there&#39;s
any value at all to trying to make hugepages un-movable at all? Should
the hugepages_treat_as_movable sysctl die and just make hugepages movable
by default?

../Alex
<span class="quote">
&gt; </span>
<span class="quote">&gt; -- </span>
<span class="quote">&gt; Michal Hocko</span>
<span class="quote">&gt; SUSE Labs</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137061">Michal Hocko</a> - Oct. 3, 2017, 7:10 a.m.</div>
<pre class="content">
On Tue 03-10-17 07:42:25, Alexandru Moise wrote:
<span class="quote">&gt; On Mon, Oct 02, 2017 at 06:15:00PM +0200, Michal Hocko wrote:</span>
[...]
<span class="quote">&gt; &gt; I really fail to see why kernel vs. movable zones play any role here.</span>
<span class="quote">&gt; &gt; Zones should be mostly an implementation detail which userspace</span>
<span class="quote">&gt; &gt; shouldn&#39;t really care about.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Ok, the whole zone approach is a bad idea. Do you think that there&#39;s</span>
<span class="quote">&gt; any value at all to trying to make hugepages un-movable at all?</span>

I am not aware of any usecase, to be honest.
<span class="quote">
&gt; Should</span>
<span class="quote">&gt; the hugepages_treat_as_movable sysctl die and just make hugepages movable</span>
<span class="quote">&gt; by default?</span>

I think that hugepages_treat_as_movable is just a historical relict from
the time when hugetlb pages were not movable but the main purpose of
the movable zone was different back at the time. Just to clarifiy, the
original intention of the zone was to prevent memory fragmentation and
as hugetlb pages are not fragmenting memory because they are long lived
and contiguous, it was acceptable to use the zone. The purpose of the
zone has changed towards a migratability guarantee since then but the
knob has stayed behind. I think we should just remove it.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/admin-guide/kernel-parameters.txt b/Documentation/admin-guide/kernel-parameters.txt</span>
<span class="p_header">index 05496622b4ef..25116d32d59e 100644</span>
<span class="p_header">--- a/Documentation/admin-guide/kernel-parameters.txt</span>
<span class="p_header">+++ b/Documentation/admin-guide/kernel-parameters.txt</span>
<span class="p_chunk">@@ -1318,6 +1318,14 @@</span> <span class="p_context"></span>
 			x86-64 are 2M (when the CPU supports &quot;pse&quot;) and 1G
 			(when the CPU supports the &quot;pdpe1gb&quot; cpuinfo flag).
 
<span class="p_add">+	hugepages_movable=</span>
<span class="p_add">+			[HW,IA-64,PPC,X86-64] Default value for the</span>
<span class="p_add">+			hugepages_treat_as_movable sysctl (default is 1).</span>
<span class="p_add">+			When 1 this will attempt to allocate hugepages from</span>
<span class="p_add">+			ZONE_MOVABLE, if 0 it will attempt to allocate hugepages</span>
<span class="p_add">+			from the non-movable zone created with the &quot;kernelcore=&quot;</span>
<span class="p_add">+			kernel parameter.</span>
<span class="p_add">+</span>
 	hvc_iucv=	[S390] Number of z/VM IUCV hypervisor console (HVC)
 			       terminal devices. Valid values: 0..8
 	hvc_iucv_allow=	[S390] Comma-separated list of z/VM user IDs.
<span class="p_header">diff --git a/Documentation/sysctl/vm.txt b/Documentation/sysctl/vm.txt</span>
<span class="p_header">index 9baf66a9ef4e..4c5755a1cf9f 100644</span>
<span class="p_header">--- a/Documentation/sysctl/vm.txt</span>
<span class="p_header">+++ b/Documentation/sysctl/vm.txt</span>
<span class="p_chunk">@@ -267,6 +267,9 @@</span> <span class="p_context"> or not. If set to non-zero, hugepages can be allocated from ZONE_MOVABLE.</span>
 ZONE_MOVABLE is created when kernel boot parameter kernelcore= is specified,
 so this parameter has no effect if used without kernelcore=.
 
<span class="p_add">+The default value for this sysctl can also be set via the hugepages_movable=</span>
<span class="p_add">+kernel boot parameter (to 0 or 1), default is 1.</span>
<span class="p_add">+</span>
 Hugepage migration is now available in some situations which depend on the
 architecture and/or the hugepage size. If a hugepage supports migration,
 allocation from ZONE_MOVABLE is always enabled for the hugepage regardless
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 424b0ef08a60..5d4efdadbd56 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -36,7 +36,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/userfaultfd_k.h&gt;
 #include &quot;internal.h&quot;
 
<span class="p_del">-int hugepages_treat_as_movable;</span>
<span class="p_add">+int hugepages_treat_as_movable = 1;</span>
 
 int hugetlb_max_hstate __read_mostly;
 unsigned int default_hstate_idx;
<span class="p_chunk">@@ -926,7 +926,7 @@</span> <span class="p_context"> static struct page *dequeue_huge_page_nodemask(struct hstate *h, gfp_t gfp_mask,</span>
 /* Movability of hugepages depends on migration support. */
 static inline gfp_t htlb_alloc_mask(struct hstate *h)
 {
<span class="p_del">-	if (hugepages_treat_as_movable || hugepage_migration_supported(h))</span>
<span class="p_add">+	if (hugepages_treat_as_movable &amp;&amp; hugepage_migration_supported(h))</span>
 		return GFP_HIGHUSER_MOVABLE;
 	else
 		return GFP_HIGHUSER;
<span class="p_chunk">@@ -2805,6 +2805,17 @@</span> <span class="p_context"> static int __init hugetlb_init(void)</span>
 }
 subsys_initcall(hugetlb_init);
 
<span class="p_add">+static int __init hugepages_movable(char *str)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!strncmp(str, &quot;0&quot;, 1))</span>
<span class="p_add">+		hugepages_treat_as_movable = 0;</span>
<span class="p_add">+	else if (!strncmp(str, &quot;1&quot;, 1))</span>
<span class="p_add">+		hugepages_treat_as_movable = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+__setup(&quot;hugepages_movable=&quot;, hugepages_movable);</span>
<span class="p_add">+</span>
 /* Should be called on processing a hugepagesz=... option */
 void __init hugetlb_bad_size(void)
 {
<span class="p_header">diff --git a/mm/migrate.c b/mm/migrate.c</span>
<span class="p_header">index 6954c1435833..23946d88e533 100644</span>
<span class="p_header">--- a/mm/migrate.c</span>
<span class="p_header">+++ b/mm/migrate.c</span>
<span class="p_chunk">@@ -1266,6 +1266,7 @@</span> <span class="p_context"> static int unmap_and_move_huge_page(new_page_t get_new_page,</span>
 	int page_was_mapped = 0;
 	struct page *new_hpage;
 	struct anon_vma *anon_vma = NULL;
<span class="p_add">+	bool zone_movable_present;</span>
 
 	/*
 	 * Movability of hugepages depends on architectures and hugepage size.
<span class="p_chunk">@@ -1274,7 +1275,12 @@</span> <span class="p_context"> static int unmap_and_move_huge_page(new_page_t get_new_page,</span>
 	 * tables or check whether the hugepage is pmd-based or not before
 	 * kicking migration.
 	 */
<span class="p_del">-	if (!hugepage_migration_supported(page_hstate(hpage))) {</span>
<span class="p_add">+	zone_movable_present = (NODE_DATA(page_to_nid(hpage))-&gt;node_zones[ZONE_MOVABLE].spanned_pages &gt; 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!hugepage_migration_supported(page_hstate(hpage)) ||</span>
<span class="p_add">+		zone_movable_present ?</span>
<span class="p_add">+		!(zone_idx(page_zone(hpage)) == ZONE_MOVABLE) :</span>
<span class="p_add">+			false) {</span>
 		putback_active_hugepage(hpage);
 		return -ENOSYS;
 	}

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



