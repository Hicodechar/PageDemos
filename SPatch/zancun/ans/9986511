
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.18.73 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.18.73</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 5, 2017, 8:05 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171005080555.GB28294@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9986511/mbox/"
   >mbox</a>
|
   <a href="/patch/9986511/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9986511/">/patch/9986511/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	A204360247 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  5 Oct 2017 08:06:19 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 8FE0F2857E
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  5 Oct 2017 08:06:19 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 84C3028C44; Thu,  5 Oct 2017 08:06:19 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 216B82857E
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  5 Oct 2017 08:06:18 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751560AbdJEIGL (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 5 Oct 2017 04:06:11 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:37494 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751330AbdJEIFr (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 5 Oct 2017 04:05:47 -0400
Received: from localhost (LFbn-1-12253-150.w90-92.abo.wanadoo.fr
	[90.92.67.150])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 8BD30258;
	Thu,  5 Oct 2017 08:05:46 +0000 (UTC)
Date: Thu, 5 Oct 2017 10:05:55 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 3.18.73
Message-ID: &lt;20171005080555.GB28294@kroah.com&gt;
References: &lt;20171005080548.GA28294@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20171005080548.GA28294@kroah.com&gt;
User-Agent: Mutt/1.9.1 (2017-09-22)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Oct. 5, 2017, 8:05 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 9b82f279ef1d..f5e683464cd4 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 18
<span class="p_del">-SUBLEVEL = 72</span>
<span class="p_add">+SUBLEVEL = 73</span>
 EXTRAVERSION =
 NAME = Diseased Newt
 
<span class="p_header">diff --git a/arch/arm/xen/mm.c b/arch/arm/xen/mm.c</span>
<span class="p_header">index f8a576b1d9bb..5409d70ffe6f 100644</span>
<span class="p_header">--- a/arch/arm/xen/mm.c</span>
<span class="p_header">+++ b/arch/arm/xen/mm.c</span>
<span class="p_chunk">@@ -59,6 +59,7 @@</span> <span class="p_context"> static struct dma_map_ops xen_swiotlb_dma_ops = {</span>
 	.unmap_page = xen_swiotlb_unmap_page,
 	.dma_supported = xen_swiotlb_dma_supported,
 	.set_dma_mask = xen_swiotlb_set_dma_mask,
<span class="p_add">+	.mmap = xen_swiotlb_dma_mmap,</span>
 };
 
 int __init xen_mm_init(void)
<span class="p_header">diff --git a/arch/arm64/kernel/head.S b/arch/arm64/kernel/head.S</span>
<span class="p_header">index 2877dd818977..5c4b8d6e8ba0 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/head.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/head.S</span>
<span class="p_chunk">@@ -264,6 +264,7 @@</span> <span class="p_context"> ENDPROC(stext)</span>
  * booted in EL1 or EL2 respectively.
  */
 ENTRY(el2_setup)
<span class="p_add">+	msr	SPsel, #1			// We want to use SP_EL{1,2}</span>
 	mrs	x0, CurrentEL
 	cmp	x0, #CurrentEL_EL2
 	b.ne	1f
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_64_vio.c b/arch/powerpc/kvm/book3s_64_vio.c</span>
<span class="p_header">index 54cf9bc94dad..3a095670b0c4 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_64_vio.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_64_vio.c</span>
<span class="p_chunk">@@ -101,22 +101,17 @@</span> <span class="p_context"> long kvm_vm_ioctl_create_spapr_tce(struct kvm *kvm,</span>
 				   struct kvm_create_spapr_tce *args)
 {
 	struct kvmppc_spapr_tce_table *stt = NULL;
<span class="p_add">+	struct kvmppc_spapr_tce_table *siter;</span>
 	long npages;
 	int ret = -ENOMEM;
 	int i;
 
<span class="p_del">-	/* Check this LIOBN hasn&#39;t been previously allocated */</span>
<span class="p_del">-	list_for_each_entry(stt, &amp;kvm-&gt;arch.spapr_tce_tables, list) {</span>
<span class="p_del">-		if (stt-&gt;liobn == args-&gt;liobn)</span>
<span class="p_del">-			return -EBUSY;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	npages = kvmppc_stt_npages(args-&gt;window_size);
 
 	stt = kzalloc(sizeof(*stt) + npages * sizeof(struct page *),
 		      GFP_KERNEL);
 	if (!stt)
<span class="p_del">-		goto fail;</span>
<span class="p_add">+		return ret;</span>
 
 	stt-&gt;liobn = args-&gt;liobn;
 	stt-&gt;window_size = args-&gt;window_size;
<span class="p_chunk">@@ -128,23 +123,36 @@</span> <span class="p_context"> long kvm_vm_ioctl_create_spapr_tce(struct kvm *kvm,</span>
 			goto fail;
 	}
 
<span class="p_del">-	kvm_get_kvm(kvm);</span>
<span class="p_del">-</span>
 	mutex_lock(&amp;kvm-&gt;lock);
<span class="p_del">-	list_add(&amp;stt-&gt;list, &amp;kvm-&gt;arch.spapr_tce_tables);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check this LIOBN hasn&#39;t been previously allocated */</span>
<span class="p_add">+	ret = 0;</span>
<span class="p_add">+	list_for_each_entry(siter, &amp;kvm-&gt;arch.spapr_tce_tables, list) {</span>
<span class="p_add">+		if (siter-&gt;liobn == args-&gt;liobn) {</span>
<span class="p_add">+			ret = -EBUSY;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		ret = anon_inode_getfd(&quot;kvm-spapr-tce&quot;, &amp;kvm_spapr_tce_fops,</span>
<span class="p_add">+				       stt, O_RDWR | O_CLOEXEC);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret &gt;= 0) {</span>
<span class="p_add">+		list_add(&amp;stt-&gt;list, &amp;kvm-&gt;arch.spapr_tce_tables);</span>
<span class="p_add">+		kvm_get_kvm(kvm);</span>
<span class="p_add">+	}</span>
 
 	mutex_unlock(&amp;kvm-&gt;lock);
 
<span class="p_del">-	return anon_inode_getfd(&quot;kvm-spapr-tce&quot;, &amp;kvm_spapr_tce_fops,</span>
<span class="p_del">-				stt, O_RDWR | O_CLOEXEC);</span>
<span class="p_add">+	if (ret &gt;= 0)</span>
<span class="p_add">+		return ret;</span>
 
<span class="p_del">-fail:</span>
<span class="p_del">-	if (stt) {</span>
<span class="p_del">-		for (i = 0; i &lt; npages; i++)</span>
<span class="p_del">-			if (stt-&gt;pages[i])</span>
<span class="p_del">-				__free_page(stt-&gt;pages[i]);</span>
<span class="p_add">+ fail:</span>
<span class="p_add">+	for (i = 0; i &lt; npages; i++)</span>
<span class="p_add">+		if (stt-&gt;pages[i])</span>
<span class="p_add">+			__free_page(stt-&gt;pages[i]);</span>
 
<span class="p_del">-		kfree(stt);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	kfree(stt);</span>
 	return ret;
 }
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/mobility.c b/arch/powerpc/platforms/pseries/mobility.c</span>
<span class="p_header">index f8c9ff7886e1..b86408e91e8b 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/mobility.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/mobility.c</span>
<span class="p_chunk">@@ -225,8 +225,10 @@</span> <span class="p_context"> static int add_dt_node(__be32 parent_phandle, __be32 drc_index)</span>
 		return -ENOENT;
 
 	dn = dlpar_configure_connector(drc_index, parent_dn);
<span class="p_del">-	if (!dn)</span>
<span class="p_add">+	if (!dn) {</span>
<span class="p_add">+		of_node_put(parent_dn);</span>
 		return -ENOENT;
<span class="p_add">+	}</span>
 
 	rc = dlpar_attach_node(dn);
 	if (rc)
<span class="p_header">diff --git a/arch/x86/kernel/i387.c b/arch/x86/kernel/i387.c</span>
<span class="p_header">index 8d6e954db2a7..9c9f4c0b0106 100644</span>
<span class="p_header">--- a/arch/x86/kernel/i387.c</span>
<span class="p_header">+++ b/arch/x86/kernel/i387.c</span>
<span class="p_chunk">@@ -388,11 +388,22 @@</span> <span class="p_context"> int xstateregs_set(struct task_struct *target, const struct user_regset *regset,</span>
 	xsave_hdr = &amp;target-&gt;thread.fpu.state-&gt;xsave.xsave_hdr;
 
 	xsave_hdr-&gt;xstate_bv &amp;= pcntxt_mask;
<span class="p_add">+</span>
<span class="p_add">+	/* xcomp_bv must be 0 when using uncompacted format */</span>
<span class="p_add">+	if (!ret &amp;&amp; xsave_hdr-&gt;xcomp_bv)</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+</span>
 	/*
 	 * These bits must be zero.
 	 */
 	memset(xsave_hdr-&gt;reserved, 0, 48);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In case of failure, mark all states as init:</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		fpu_finit(&amp;target-&gt;thread.fpu);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/arch/x86/kernel/xsave.c b/arch/x86/kernel/xsave.c</span>
<span class="p_header">index cdc6cf903078..460e72155f51 100644</span>
<span class="p_header">--- a/arch/x86/kernel/xsave.c</span>
<span class="p_header">+++ b/arch/x86/kernel/xsave.c</span>
<span class="p_chunk">@@ -394,7 +394,9 @@</span> <span class="p_context"> int __restore_xstate_sig(void __user *buf, void __user *buf_fx, int size)</span>
 		drop_fpu(tsk);
 
 		if (__copy_from_user(&amp;fpu-&gt;state-&gt;xsave, buf_fx, state_size) ||
<span class="p_del">-		    __copy_from_user(&amp;env, buf, sizeof(env))) {</span>
<span class="p_add">+		    __copy_from_user(&amp;env, buf, sizeof(env)) ||</span>
<span class="p_add">+		    (state_size &gt; offsetof(struct xsave_struct, xsave_hdr) &amp;&amp;</span>
<span class="p_add">+		     fpu-&gt;state-&gt;xsave.xsave_hdr.xcomp_bv)) {</span>
 			fpu_finit(fpu);
 			err = -1;
 		} else {
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 99c004ddefd8..dd3ca375bfdf 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -8275,6 +8275,11 @@</span> <span class="p_context"> static void prepare_vmcs02(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)</span>
 		vmcs_write64(VIRTUAL_APIC_PAGE_ADDR,
 				page_to_phys(vmx-&gt;nested.virtual_apic_page));
 		vmcs_write32(TPR_THRESHOLD, vmcs12-&gt;tpr_threshold);
<span class="p_add">+	} else {</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+		exec_control |= CPU_BASED_CR8_LOAD_EXITING |</span>
<span class="p_add">+				CPU_BASED_CR8_STORE_EXITING;</span>
<span class="p_add">+#endif</span>
 	}
 
 	/*
<span class="p_header">diff --git a/block/bsg-lib.c b/block/bsg-lib.c</span>
<span class="p_header">index 650f427d915b..341b8d858e67 100644</span>
<span class="p_header">--- a/block/bsg-lib.c</span>
<span class="p_header">+++ b/block/bsg-lib.c</span>
<span class="p_chunk">@@ -147,7 +147,6 @@</span> <span class="p_context"> static int bsg_create_job(struct device *dev, struct request *req)</span>
 failjob_rls_rqst_payload:
 	kfree(job-&gt;request_payload.sg_list);
 failjob_rls_job:
<span class="p_del">-	kfree(job);</span>
 	return -ENOMEM;
 }
 
<span class="p_header">diff --git a/drivers/crypto/talitos.c b/drivers/crypto/talitos.c</span>
<span class="p_header">index 00410b319b26..9fa17913941c 100644</span>
<span class="p_header">--- a/drivers/crypto/talitos.c</span>
<span class="p_header">+++ b/drivers/crypto/talitos.c</span>
<span class="p_chunk">@@ -1581,9 +1581,9 @@</span> <span class="p_context"> static int common_nonsnoop_hash(struct talitos_edesc *edesc,</span>
 		req_ctx-&gt;swinit = 0;
 	} else {
 		desc-&gt;ptr[1] = zero_entry;
<span class="p_del">-		/* Indicate next op is not the first. */</span>
<span class="p_del">-		req_ctx-&gt;first = 0;</span>
 	}
<span class="p_add">+	/* Indicate next op is not the first. */</span>
<span class="p_add">+	req_ctx-&gt;first = 0;</span>
 
 	/* HMAC key */
 	if (ctx-&gt;keylen)
<span class="p_header">diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c</span>
<span class="p_header">index 66ba1ee09a6c..318707870cb2 100644</span>
<span class="p_header">--- a/drivers/pci/pci-sysfs.c</span>
<span class="p_header">+++ b/drivers/pci/pci-sysfs.c</span>
<span class="p_chunk">@@ -513,7 +513,7 @@</span> <span class="p_context"> static ssize_t driver_override_store(struct device *dev,</span>
 				     const char *buf, size_t count)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
<span class="p_del">-	char *driver_override, *old = pdev-&gt;driver_override, *cp;</span>
<span class="p_add">+	char *driver_override, *old, *cp;</span>
 
 	/* We need to keep extra room for a newline */
 	if (count &gt;= (PAGE_SIZE - 1))
<span class="p_chunk">@@ -527,12 +527,15 @@</span> <span class="p_context"> static ssize_t driver_override_store(struct device *dev,</span>
 	if (cp)
 		*cp = &#39;\0&#39;;
 
<span class="p_add">+	device_lock(dev);</span>
<span class="p_add">+	old = pdev-&gt;driver_override;</span>
 	if (strlen(driver_override)) {
 		pdev-&gt;driver_override = driver_override;
 	} else {
 		kfree(driver_override);
 		pdev-&gt;driver_override = NULL;
 	}
<span class="p_add">+	device_unlock(dev);</span>
 
 	kfree(old);
 
<span class="p_chunk">@@ -543,8 +546,12 @@</span> <span class="p_context"> static ssize_t driver_override_show(struct device *dev,</span>
 				    struct device_attribute *attr, char *buf)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
<span class="p_add">+	ssize_t len;</span>
 
<span class="p_del">-	return snprintf(buf, PAGE_SIZE, &quot;%s\n&quot;, pdev-&gt;driver_override);</span>
<span class="p_add">+	device_lock(dev);</span>
<span class="p_add">+	len = snprintf(buf, PAGE_SIZE, &quot;%s\n&quot;, pdev-&gt;driver_override);</span>
<span class="p_add">+	device_unlock(dev);</span>
<span class="p_add">+	return len;</span>
 }
 static DEVICE_ATTR_RW(driver_override);
 
<span class="p_header">diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c</span>
<span class="p_header">index 67d43e35693d..b5a653aed5a4 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_transport_iscsi.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_transport_iscsi.c</span>
<span class="p_chunk">@@ -3693,7 +3693,7 @@</span> <span class="p_context"> iscsi_if_rx(struct sk_buff *skb)</span>
 		uint32_t group;
 
 		nlh = nlmsg_hdr(skb);
<span class="p_del">-		if (nlh-&gt;nlmsg_len &lt; sizeof(*nlh) ||</span>
<span class="p_add">+		if (nlh-&gt;nlmsg_len &lt; sizeof(*nlh) + sizeof(*ev) ||</span>
 		    skb-&gt;len &lt; nlh-&gt;nlmsg_len) {
 			break;
 		}
<span class="p_header">diff --git a/drivers/video/fbdev/aty/atyfb_base.c b/drivers/video/fbdev/aty/atyfb_base.c</span>
<span class="p_header">index 37ec09b3fffd..fd38ee820da6 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/aty/atyfb_base.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/aty/atyfb_base.c</span>
<span class="p_chunk">@@ -1852,7 +1852,7 @@</span> <span class="p_context"> static int atyfb_ioctl(struct fb_info *info, u_int cmd, u_long arg)</span>
 #if defined(DEBUG) &amp;&amp; defined(CONFIG_FB_ATY_CT)
 	case ATYIO_CLKR:
 		if (M64_HAS(INTEGRATED)) {
<span class="p_del">-			struct atyclk clk;</span>
<span class="p_add">+			struct atyclk clk = { 0 };</span>
 			union aty_pll *pll = &amp;par-&gt;pll;
 			u32 dsp_config = pll-&gt;ct.dsp_config;
 			u32 dsp_on_off = pll-&gt;ct.dsp_on_off;
<span class="p_header">diff --git a/drivers/xen/swiotlb-xen.c b/drivers/xen/swiotlb-xen.c</span>
<span class="p_header">index c9d0d5a0e662..c6d47e558488 100644</span>
<span class="p_header">--- a/drivers/xen/swiotlb-xen.c</span>
<span class="p_header">+++ b/drivers/xen/swiotlb-xen.c</span>
<span class="p_chunk">@@ -684,3 +684,22 @@</span> <span class="p_context"> xen_swiotlb_set_dma_mask(struct device *dev, u64 dma_mask)</span>
 	return 0;
 }
 EXPORT_SYMBOL_GPL(xen_swiotlb_set_dma_mask);
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Create userspace mapping for the DMA-coherent memory.</span>
<span class="p_add">+ * This function should be called with the pages from the current domain only,</span>
<span class="p_add">+ * passing pages mapped from other domains would lead to memory corruption.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int</span>
<span class="p_add">+xen_swiotlb_dma_mmap(struct device *dev, struct vm_area_struct *vma,</span>
<span class="p_add">+		     void *cpu_addr, dma_addr_t dma_addr, size_t size,</span>
<span class="p_add">+		     struct dma_attrs *attrs)</span>
<span class="p_add">+{</span>
<span class="p_add">+#if defined(CONFIG_ARM) || defined(CONFIG_ARM64)</span>
<span class="p_add">+	if (__generic_dma_ops(dev)-&gt;mmap)</span>
<span class="p_add">+		return __generic_dma_ops(dev)-&gt;mmap(dev, vma, cpu_addr,</span>
<span class="p_add">+						    dma_addr, size, attrs);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	return dma_common_mmap(dev, vma, cpu_addr, dma_addr, size);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(xen_swiotlb_dma_mmap);</span>
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index dd8526a659f8..a877e6279b10 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -3963,6 +3963,10 @@</span> <span class="p_context"> static long btrfs_ioctl_default_subvol(struct file *file, void __user *argp)</span>
 		ret = PTR_ERR(new_root);
 		goto out;
 	}
<span class="p_add">+	if (!is_fstree(new_root-&gt;objectid)) {</span>
<span class="p_add">+		ret = -ENOENT;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 	path = btrfs_alloc_path();
 	if (!path) {
<span class="p_header">diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c</span>
<span class="p_header">index 103e8b6604b1..b8158006e0ff 100644</span>
<span class="p_header">--- a/fs/cifs/cifsfs.c</span>
<span class="p_header">+++ b/fs/cifs/cifsfs.c</span>
<span class="p_chunk">@@ -1311,7 +1311,7 @@</span> <span class="p_context"> exit_cifs(void)</span>
 	exit_cifs_idmap();
 #endif
 #ifdef CONFIG_CIFS_UPCALL
<span class="p_del">-	unregister_key_type(&amp;cifs_spnego_key_type);</span>
<span class="p_add">+	exit_cifs_spnego();</span>
 #endif
 	cifs_destroy_request_bufs();
 	cifs_destroy_mids();
<span class="p_header">diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c</span>
<span class="p_header">index 32c46a5c489e..43df8c3e026c 100644</span>
<span class="p_header">--- a/fs/cifs/connect.c</span>
<span class="p_header">+++ b/fs/cifs/connect.c</span>
<span class="p_chunk">@@ -3958,6 +3958,14 @@</span> <span class="p_context"> cifs_setup_session(const unsigned int xid, struct cifs_ses *ses,</span>
 	cifs_dbg(FYI, &quot;Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\n&quot;,
 		 server-&gt;sec_mode, server-&gt;capabilities, server-&gt;timeAdj);
 
<span class="p_add">+	if (ses-&gt;auth_key.response) {</span>
<span class="p_add">+		cifs_dbg(VFS, &quot;Free previous auth_key.response = %p\n&quot;,</span>
<span class="p_add">+			 ses-&gt;auth_key.response);</span>
<span class="p_add">+		kfree(ses-&gt;auth_key.response);</span>
<span class="p_add">+		ses-&gt;auth_key.response = NULL;</span>
<span class="p_add">+		ses-&gt;auth_key.len = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (server-&gt;ops-&gt;sess_setup)
 		rc = server-&gt;ops-&gt;sess_setup(xid, ses, nls_info);
 
<span class="p_header">diff --git a/fs/cifs/file.c b/fs/cifs/file.c</span>
<span class="p_header">index a3badede1b32..237c201d6d3e 100644</span>
<span class="p_header">--- a/fs/cifs/file.c</span>
<span class="p_header">+++ b/fs/cifs/file.c</span>
<span class="p_chunk">@@ -225,6 +225,13 @@</span> <span class="p_context"> cifs_nt_open(char *full_path, struct inode *inode, struct cifs_sb_info *cifs_sb,</span>
 	if (backup_cred(cifs_sb))
 		create_options |= CREATE_OPEN_BACKUP_INTENT;
 
<span class="p_add">+	/* O_SYNC also has bit for O_DSYNC so following check picks up either */</span>
<span class="p_add">+	if (f_flags &amp; O_SYNC)</span>
<span class="p_add">+		create_options |= CREATE_WRITE_THROUGH;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (f_flags &amp; O_DIRECT)</span>
<span class="p_add">+		create_options |= CREATE_NO_BUFFER;</span>
<span class="p_add">+</span>
 	oparms.tcon = tcon;
 	oparms.cifs_sb = cifs_sb;
 	oparms.desired_access = desired_access;
<span class="p_header">diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c</span>
<span class="p_header">index 2c3047636d4e..fc5809d494ed 100644</span>
<span class="p_header">--- a/fs/cifs/smb2pdu.c</span>
<span class="p_header">+++ b/fs/cifs/smb2pdu.c</span>
<span class="p_chunk">@@ -453,15 +453,22 @@</span> <span class="p_context"> int smb3_validate_negotiate(const unsigned int xid, struct cifs_tcon *tcon)</span>
 
 	/*
 	 * validation ioctl must be signed, so no point sending this if we
<span class="p_del">-	 * can not sign it.  We could eventually change this to selectively</span>
<span class="p_add">+	 * can not sign it (ie are not known user).  Even if signing is not</span>
<span class="p_add">+	 * required (enabled but not negotiated), in those cases we selectively</span>
 	 * sign just this, the first and only signed request on a connection.
<span class="p_del">-	 * This is good enough for now since a user who wants better security</span>
<span class="p_del">-	 * would also enable signing on the mount. Having validation of</span>
<span class="p_del">-	 * negotiate info for signed connections helps reduce attack vectors</span>
<span class="p_add">+	 * Having validation of negotiate info  helps reduce attack vectors.</span>
 	 */
<span class="p_del">-	if (tcon-&gt;ses-&gt;server-&gt;sign == false)</span>
<span class="p_add">+	if (tcon-&gt;ses-&gt;session_flags &amp; SMB2_SESSION_FLAG_IS_GUEST)</span>
 		return 0; /* validation requires signing */
 
<span class="p_add">+	if (tcon-&gt;ses-&gt;user_name == NULL) {</span>
<span class="p_add">+		cifs_dbg(FYI, &quot;Can&#39;t validate negotiate: null user mount\n&quot;);</span>
<span class="p_add">+		return 0; /* validation requires signing */</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tcon-&gt;ses-&gt;session_flags &amp; SMB2_SESSION_FLAG_IS_NULL)</span>
<span class="p_add">+		cifs_dbg(VFS, &quot;Unexpected null user (anonymous) auth flag sent by server\n&quot;);</span>
<span class="p_add">+</span>
 	vneg_inbuf.Capabilities =
 			cpu_to_le32(tcon-&gt;ses-&gt;server-&gt;vals-&gt;req_capabilities);
 	memcpy(vneg_inbuf.Guid, tcon-&gt;ses-&gt;server-&gt;client_guid,
<span class="p_header">diff --git a/fs/read_write.c b/fs/read_write.c</span>
<span class="p_header">index 7d9318c3d43c..1afb99c33c63 100644</span>
<span class="p_header">--- a/fs/read_write.c</span>
<span class="p_header">+++ b/fs/read_write.c</span>
<span class="p_chunk">@@ -116,7 +116,7 @@</span> <span class="p_context"> generic_file_llseek_size(struct file *file, loff_t offset, int whence,</span>
 		 * In the generic case the entire file is data, so as long as
 		 * offset isn&#39;t at the end of the file then the offset is data.
 		 */
<span class="p_del">-		if (offset &gt;= eof)</span>
<span class="p_add">+		if ((unsigned long long)offset &gt;= eof)</span>
 			return -ENXIO;
 		break;
 	case SEEK_HOLE:
<span class="p_chunk">@@ -124,7 +124,7 @@</span> <span class="p_context"> generic_file_llseek_size(struct file *file, loff_t offset, int whence,</span>
 		 * There is a virtual hole at the end of the file, so as long as
 		 * offset isn&#39;t i_size or larger, return i_size.
 		 */
<span class="p_del">-		if (offset &gt;= eof)</span>
<span class="p_add">+		if ((unsigned long long)offset &gt;= eof)</span>
 			return -ENXIO;
 		offset = eof;
 		break;
<span class="p_header">diff --git a/include/linux/key.h b/include/linux/key.h</span>
<span class="p_header">index e1d4715f3222..dcc00a7a5b8d 100644</span>
<span class="p_header">--- a/include/linux/key.h</span>
<span class="p_header">+++ b/include/linux/key.h</span>
<span class="p_chunk">@@ -172,6 +172,7 @@</span> <span class="p_context"> struct key {</span>
 #define KEY_FLAG_TRUSTED_ONLY	9	/* set if keyring only accepts links to trusted keys */
 #define KEY_FLAG_BUILTIN	10	/* set if key is builtin */
 #define KEY_FLAG_ROOT_CAN_INVAL	11	/* set if key can be invalidated by root without permission */
<span class="p_add">+#define KEY_FLAG_UID_KEYRING	12	/* set if key is a user or user session keyring */</span>
 
 	/* the key type and key description string
 	 * - the desc is used to match a key against search criteria
<span class="p_chunk">@@ -223,6 +224,7 @@</span> <span class="p_context"> extern struct key *key_alloc(struct key_type *type,</span>
 #define KEY_ALLOC_QUOTA_OVERRUN	0x0001	/* add to quota, permit even if overrun */
 #define KEY_ALLOC_NOT_IN_QUOTA	0x0002	/* not in quota */
 #define KEY_ALLOC_TRUSTED	0x0004	/* Key should be flagged as trusted */
<span class="p_add">+#define KEY_ALLOC_UID_KEYRING	0x0010	/* allocating a user or user session keyring */</span>
 
 extern void key_revoke(struct key *key);
 extern void key_invalidate(struct key *key);
<span class="p_header">diff --git a/include/xen/swiotlb-xen.h b/include/xen/swiotlb-xen.h</span>
<span class="p_header">index 8b2eb93ae8ba..4d7fdbf20eff 100644</span>
<span class="p_header">--- a/include/xen/swiotlb-xen.h</span>
<span class="p_header">+++ b/include/xen/swiotlb-xen.h</span>
<span class="p_chunk">@@ -58,4 +58,9 @@</span> <span class="p_context"> xen_swiotlb_dma_supported(struct device *hwdev, u64 mask);</span>
 
 extern int
 xen_swiotlb_set_dma_mask(struct device *dev, u64 dma_mask);
<span class="p_add">+</span>
<span class="p_add">+extern int</span>
<span class="p_add">+xen_swiotlb_dma_mmap(struct device *dev, struct vm_area_struct *vma,</span>
<span class="p_add">+		     void *cpu_addr, dma_addr_t dma_addr, size_t size,</span>
<span class="p_add">+		     struct dma_attrs *attrs);</span>
 #endif /* __LINUX_SWIOTLB_XEN_H */
<span class="p_header">diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c</span>
<span class="p_header">index 941b21f7c8a4..e61b862309af 100644</span>
<span class="p_header">--- a/kernel/trace/trace.c</span>
<span class="p_header">+++ b/kernel/trace/trace.c</span>
<span class="p_chunk">@@ -3168,11 +3168,17 @@</span> <span class="p_context"> static int tracing_open(struct inode *inode, struct file *file)</span>
 	/* If this file was open for write, then erase contents */
 	if ((file-&gt;f_mode &amp; FMODE_WRITE) &amp;&amp; (file-&gt;f_flags &amp; O_TRUNC)) {
 		int cpu = tracing_get_cpu(inode);
<span class="p_add">+		struct trace_buffer *trace_buf = &amp;tr-&gt;trace_buffer;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_TRACER_MAX_TRACE</span>
<span class="p_add">+		if (tr-&gt;current_trace-&gt;print_max)</span>
<span class="p_add">+			trace_buf = &amp;tr-&gt;max_buffer;</span>
<span class="p_add">+#endif</span>
 
 		if (cpu == RING_BUFFER_ALL_CPUS)
<span class="p_del">-			tracing_reset_online_cpus(&amp;tr-&gt;trace_buffer);</span>
<span class="p_add">+			tracing_reset_online_cpus(trace_buf);</span>
 		else
<span class="p_del">-			tracing_reset(&amp;tr-&gt;trace_buffer, cpu);</span>
<span class="p_add">+			tracing_reset(trace_buf, cpu);</span>
 	}
 
 	if (file-&gt;f_mode &amp; FMODE_READ) {
<span class="p_chunk">@@ -4430,7 +4436,7 @@</span> <span class="p_context"> static int tracing_wait_pipe(struct file *filp)</span>
 		 *
 		 * iter-&gt;pos will be 0 if we haven&#39;t read anything.
 		 */
<span class="p_del">-		if (!tracing_is_on() &amp;&amp; iter-&gt;pos)</span>
<span class="p_add">+		if (!tracer_tracing_is_on(iter-&gt;tr) &amp;&amp; iter-&gt;pos)</span>
 			break;
 
 		mutex_unlock(&amp;iter-&gt;mutex);
<span class="p_header">diff --git a/net/mac80211/offchannel.c b/net/mac80211/offchannel.c</span>
<span class="p_header">index ff20b2ebdb30..a914eaa7ff06 100644</span>
<span class="p_header">--- a/net/mac80211/offchannel.c</span>
<span class="p_header">+++ b/net/mac80211/offchannel.c</span>
<span class="p_chunk">@@ -469,6 +469,8 @@</span> <span class="p_context"> void ieee80211_roc_purge(struct ieee80211_local *local,</span>
 	struct ieee80211_roc_work *roc, *tmp;
 	LIST_HEAD(tmp_list);
 
<span class="p_add">+	flush_work(&amp;local-&gt;hw_roc_start);</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;local-&gt;mtx);
 	list_for_each_entry_safe(roc, tmp, &amp;local-&gt;roc_list, list) {
 		if (sdata &amp;&amp; roc-&gt;sdata != sdata)
<span class="p_header">diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c</span>
<span class="p_header">index 9fb1dd399788..f843f704c17c 100644</span>
<span class="p_header">--- a/net/wireless/nl80211.c</span>
<span class="p_header">+++ b/net/wireless/nl80211.c</span>
<span class="p_chunk">@@ -9006,6 +9006,9 @@</span> <span class="p_context"> static int nl80211_set_rekey_data(struct sk_buff *skb, struct genl_info *info)</span>
 	if (err)
 		return err;
 
<span class="p_add">+	if (!tb[NL80211_REKEY_DATA_REPLAY_CTR] || !tb[NL80211_REKEY_DATA_KEK] ||</span>
<span class="p_add">+	    !tb[NL80211_REKEY_DATA_KCK])</span>
<span class="p_add">+		return -EINVAL;</span>
 	if (nla_len(tb[NL80211_REKEY_DATA_REPLAY_CTR]) != NL80211_REPLAY_CTR_LEN)
 		return -ERANGE;
 	if (nla_len(tb[NL80211_REKEY_DATA_KEK]) != NL80211_KEK_LEN)
<span class="p_header">diff --git a/security/keys/internal.h b/security/keys/internal.h</span>
<span class="p_header">index 200e37867336..b87c92ffae68 100644</span>
<span class="p_header">--- a/security/keys/internal.h</span>
<span class="p_header">+++ b/security/keys/internal.h</span>
<span class="p_chunk">@@ -136,7 +136,7 @@</span> <span class="p_context"> extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,</span>
 extern key_ref_t search_my_process_keyrings(struct keyring_search_context *ctx);
 extern key_ref_t search_process_keyrings(struct keyring_search_context *ctx);
 
<span class="p_del">-extern struct key *find_keyring_by_name(const char *name, bool skip_perm_check);</span>
<span class="p_add">+extern struct key *find_keyring_by_name(const char *name, bool uid_keyring);</span>
 
 extern int install_user_keyrings(void);
 extern int install_thread_keyring_to_cred(struct cred *);
<span class="p_header">diff --git a/security/keys/key.c b/security/keys/key.c</span>
<span class="p_header">index 37c268fb5c81..8f67cd3bb999 100644</span>
<span class="p_header">--- a/security/keys/key.c</span>
<span class="p_header">+++ b/security/keys/key.c</span>
<span class="p_chunk">@@ -298,6 +298,8 @@</span> <span class="p_context"> struct key *key_alloc(struct key_type *type, const char *desc,</span>
 		key-&gt;flags |= 1 &lt;&lt; KEY_FLAG_IN_QUOTA;
 	if (flags &amp; KEY_ALLOC_TRUSTED)
 		key-&gt;flags |= 1 &lt;&lt; KEY_FLAG_TRUSTED;
<span class="p_add">+	if (flags &amp; KEY_ALLOC_UID_KEYRING)</span>
<span class="p_add">+		key-&gt;flags |= 1 &lt;&lt; KEY_FLAG_UID_KEYRING;</span>
 
 #ifdef KEY_DEBUGGING
 	key-&gt;magic = KEY_DEBUG_MAGIC;
<span class="p_header">diff --git a/security/keys/keyctl.c b/security/keys/keyctl.c</span>
<span class="p_header">index 98c5ebc6dad6..9fc289ec0159 100644</span>
<span class="p_header">--- a/security/keys/keyctl.c</span>
<span class="p_header">+++ b/security/keys/keyctl.c</span>
<span class="p_chunk">@@ -744,6 +744,11 @@</span> <span class="p_context"> long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)</span>
 
 	key = key_ref_to_ptr(key_ref);
 
<span class="p_add">+	if (test_bit(KEY_FLAG_NEGATIVE, &amp;key-&gt;flags)) {</span>
<span class="p_add">+		ret = -ENOKEY;</span>
<span class="p_add">+		goto error2;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* see if we can read it directly */
 	ret = key_permission(key_ref, KEY_NEED_READ);
 	if (ret == 0)
<span class="p_header">diff --git a/security/keys/keyring.c b/security/keys/keyring.c</span>
<span class="p_header">index d33437007ad2..6d913f40b6f0 100644</span>
<span class="p_header">--- a/security/keys/keyring.c</span>
<span class="p_header">+++ b/security/keys/keyring.c</span>
<span class="p_chunk">@@ -416,7 +416,7 @@</span> <span class="p_context"> static void keyring_describe(const struct key *keyring, struct seq_file *m)</span>
 }
 
 struct keyring_read_iterator_context {
<span class="p_del">-	size_t			qty;</span>
<span class="p_add">+	size_t			buflen;</span>
 	size_t			count;
 	key_serial_t __user	*buffer;
 };
<span class="p_chunk">@@ -428,9 +428,9 @@</span> <span class="p_context"> static int keyring_read_iterator(const void *object, void *data)</span>
 	int ret;
 
 	kenter(&quot;{%s,%d},,{%zu/%zu}&quot;,
<span class="p_del">-	       key-&gt;type-&gt;name, key-&gt;serial, ctx-&gt;count, ctx-&gt;qty);</span>
<span class="p_add">+	       key-&gt;type-&gt;name, key-&gt;serial, ctx-&gt;count, ctx-&gt;buflen);</span>
 
<span class="p_del">-	if (ctx-&gt;count &gt;= ctx-&gt;qty)</span>
<span class="p_add">+	if (ctx-&gt;count &gt;= ctx-&gt;buflen)</span>
 		return 1;
 
 	ret = put_user(key-&gt;serial, ctx-&gt;buffer);
<span class="p_chunk">@@ -465,16 +465,12 @@</span> <span class="p_context"> static long keyring_read(const struct key *keyring,</span>
 		return 0;
 
 	/* Calculate how much data we could return */
<span class="p_del">-	ctx.qty = nr_keys * sizeof(key_serial_t);</span>
<span class="p_del">-</span>
 	if (!buffer || !buflen)
<span class="p_del">-		return ctx.qty;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (buflen &gt; ctx.qty)</span>
<span class="p_del">-		ctx.qty = buflen;</span>
<span class="p_add">+		return nr_keys * sizeof(key_serial_t);</span>
 
 	/* Copy the IDs of the subscribed keys into the buffer */
 	ctx.buffer = (key_serial_t __user *)buffer;
<span class="p_add">+	ctx.buflen = buflen;</span>
 	ctx.count = 0;
 	ret = assoc_array_iterate(&amp;keyring-&gt;keys, keyring_read_iterator, &amp;ctx);
 	if (ret &lt; 0) {
<span class="p_chunk">@@ -965,15 +961,15 @@</span> <span class="p_context"> found:</span>
 /*
  * Find a keyring with the specified name.
  *
<span class="p_del">- * All named keyrings in the current user namespace are searched, provided they</span>
<span class="p_del">- * grant Search permission directly to the caller (unless this check is</span>
<span class="p_del">- * skipped).  Keyrings whose usage points have reached zero or who have been</span>
<span class="p_del">- * revoked are skipped.</span>
<span class="p_add">+ * Only keyrings that have nonzero refcount, are not revoked, and are owned by a</span>
<span class="p_add">+ * user in the current user namespace are considered.  If @uid_keyring is %true,</span>
<span class="p_add">+ * the keyring additionally must have been allocated as a user or user session</span>
<span class="p_add">+ * keyring; otherwise, it must grant Search permission directly to the caller.</span>
  *
  * Returns a pointer to the keyring with the keyring&#39;s refcount having being
  * incremented on success.  -ENOKEY is returned if a key could not be found.
  */
<span class="p_del">-struct key *find_keyring_by_name(const char *name, bool skip_perm_check)</span>
<span class="p_add">+struct key *find_keyring_by_name(const char *name, bool uid_keyring)</span>
 {
 	struct key *keyring;
 	int bucket;
<span class="p_chunk">@@ -1001,10 +997,15 @@</span> <span class="p_context"> struct key *find_keyring_by_name(const char *name, bool skip_perm_check)</span>
 			if (strcmp(keyring-&gt;description, name) != 0)
 				continue;
 
<span class="p_del">-			if (!skip_perm_check &amp;&amp;</span>
<span class="p_del">-			    key_permission(make_key_ref(keyring, 0),</span>
<span class="p_del">-					   KEY_NEED_SEARCH) &lt; 0)</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+			if (uid_keyring) {</span>
<span class="p_add">+				if (!test_bit(KEY_FLAG_UID_KEYRING,</span>
<span class="p_add">+					      &amp;keyring-&gt;flags))</span>
<span class="p_add">+					continue;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				if (key_permission(make_key_ref(keyring, 0),</span>
<span class="p_add">+						   KEY_NEED_SEARCH) &lt; 0)</span>
<span class="p_add">+					continue;</span>
<span class="p_add">+			}</span>
 
 			/* we&#39;ve got a match but we might end up racing with
 			 * key_cleanup() if the keyring is currently &#39;dead&#39;
<span class="p_header">diff --git a/security/keys/process_keys.c b/security/keys/process_keys.c</span>
<span class="p_header">index 162077db5f81..85b61a3ac981 100644</span>
<span class="p_header">--- a/security/keys/process_keys.c</span>
<span class="p_header">+++ b/security/keys/process_keys.c</span>
<span class="p_chunk">@@ -76,7 +76,9 @@</span> <span class="p_context"> int install_user_keyrings(void)</span>
 		if (IS_ERR(uid_keyring)) {
 			uid_keyring = keyring_alloc(buf, user-&gt;uid, INVALID_GID,
 						    cred, user_keyring_perm,
<span class="p_del">-						    KEY_ALLOC_IN_QUOTA, NULL);</span>
<span class="p_add">+						    KEY_ALLOC_UID_KEYRING |</span>
<span class="p_add">+							KEY_ALLOC_IN_QUOTA,</span>
<span class="p_add">+						    NULL);</span>
 			if (IS_ERR(uid_keyring)) {
 				ret = PTR_ERR(uid_keyring);
 				goto error;
<span class="p_chunk">@@ -92,7 +94,9 @@</span> <span class="p_context"> int install_user_keyrings(void)</span>
 			session_keyring =
 				keyring_alloc(buf, user-&gt;uid, INVALID_GID,
 					      cred, user_keyring_perm,
<span class="p_del">-					      KEY_ALLOC_IN_QUOTA, NULL);</span>
<span class="p_add">+					      KEY_ALLOC_UID_KEYRING |</span>
<span class="p_add">+						  KEY_ALLOC_IN_QUOTA,</span>
<span class="p_add">+					      NULL);</span>
 			if (IS_ERR(session_keyring)) {
 				ret = PTR_ERR(session_keyring);
 				goto error_release;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



