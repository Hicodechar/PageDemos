
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[tip:x86/pti] x86/speculation: Use IBRS if available before calling into firmware - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [tip:x86/pti] x86/speculation: Use IBRS if available before calling into firmware</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=60001">tip-bot for Jacob Shin</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Feb. 11, 2018, 7:19 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;tip-670c3e8da87fa4046a55077b1409cf250865a203@git.kernel.org&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10211659/mbox/"
   >mbox</a>
|
   <a href="/patch/10211659/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10211659/">/patch/10211659/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	9AB69602B3 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 12 Feb 2018 01:15:57 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 8843F28942
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 12 Feb 2018 01:15:57 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 79900289D4; Mon, 12 Feb 2018 01:15:57 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 5650028942
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 12 Feb 2018 01:15:56 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932408AbeBLBPx (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 11 Feb 2018 20:15:53 -0500
Received: from [198.137.202.136] ([198.137.202.136]:45075 &quot;EHLO
	mail.zytor.com&quot;
	rhost-flags-FAIL-FAIL-OK-OK) by vger.kernel.org with ESMTP
	id S932311AbeBLBPv (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 11 Feb 2018 20:15:51 -0500
X-Greylist: delayed 2474 seconds by postgrey-1.27 at vger.kernel.org;
	Sun, 11 Feb 2018 20:15:51 EST
Received: from terminus.zytor.com (localhost [127.0.0.1])
	by terminus.zytor.com (8.15.2/8.15.2) with ESMTP id w1BJJBWs022872;
	Sun, 11 Feb 2018 11:19:11 -0800
Received: (from tipbot@localhost)
	by terminus.zytor.com (8.15.2/8.15.2/Submit) id w1BJJAXU022869;
	Sun, 11 Feb 2018 11:19:10 -0800
Date: Sun, 11 Feb 2018 11:19:10 -0800
X-Authentication-Warning: terminus.zytor.com: tipbot set sender to
	tipbot@zytor.com using -f
From: tip-bot for David Woodhouse &lt;tipbot@zytor.com&gt;
Message-ID: &lt;tip-670c3e8da87fa4046a55077b1409cf250865a203@git.kernel.org&gt;
Cc: mingo@kernel.org, hpa@zytor.com, tglx@linutronix.de,
	linux-kernel@vger.kernel.org, dwmw@amazon.co.uk,
	torvalds@linux-foundation.org, peterz@infradead.org
Reply-To: mingo@kernel.org, hpa@zytor.com, tglx@linutronix.de,
	torvalds@linux-foundation.org, linux-kernel@vger.kernel.org,
	dwmw@amazon.co.uk, peterz@infradead.org
In-Reply-To: &lt;1518362359-1005-1-git-send-email-dwmw@amazon.co.uk&gt;
References: &lt;1518362359-1005-1-git-send-email-dwmw@amazon.co.uk&gt;
To: linux-tip-commits@vger.kernel.org
Subject: [tip:x86/pti] x86/speculation: Use IBRS if available before calling
	into firmware
Git-Commit-ID: 670c3e8da87fa4046a55077b1409cf250865a203
X-Mailer: tip-git-log-daemon
Robot-ID: &lt;tip-bot.git.kernel.org&gt;
Robot-Unsubscribe: Contact &lt;mailto:hpa@kernel.org&gt; to get blacklisted from
	these emails
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Content-Type: text/plain; charset=UTF-8
Content-Disposition: inline
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=60001">tip-bot for Jacob Shin</a> - Feb. 11, 2018, 7:19 p.m.</div>
<pre class="content">
Commit-ID:  670c3e8da87fa4046a55077b1409cf250865a203
Gitweb:     https://git.kernel.org/tip/670c3e8da87fa4046a55077b1409cf250865a203
Author:     David Woodhouse &lt;dwmw@amazon.co.uk&gt;
AuthorDate: Sun, 11 Feb 2018 15:19:19 +0000
Committer:  Ingo Molnar &lt;mingo@kernel.org&gt;
CommitDate: Sun, 11 Feb 2018 19:44:46 +0100

x86/speculation: Use IBRS if available before calling into firmware

Retpoline means the kernel is safe because it has no indirect branches.
But firmware isn&#39;t, so use IBRS for firmware calls if it&#39;s available.
<span class="signed-off-by">
Signed-off-by: David Woodhouse &lt;dwmw@amazon.co.uk&gt;</span>
Cc: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Cc: Peter Zijlstra &lt;peterz@infradead.org&gt;
Cc: Thomas Gleixner &lt;tglx@linutronix.de&gt;
Link: http://lkml.kernel.org/r/1518362359-1005-1-git-send-email-dwmw@amazon.co.uk
<span class="signed-off-by">Signed-off-by: Ingo Molnar &lt;mingo@kernel.org&gt;</span>
---
 arch/x86/include/asm/apm.h           |  6 ++++++
 arch/x86/include/asm/cpufeatures.h   |  1 +
 arch/x86/include/asm/efi.h           | 17 +++++++++++++++--
 arch/x86/include/asm/nospec-branch.h | 37 +++++++++++++++++++++++++++---------
 arch/x86/kernel/cpu/bugs.c           | 12 +++++++++++-
 drivers/watchdog/hpwdt.c             |  3 +++
 6 files changed, 64 insertions(+), 12 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=73781">Afzal Mohammed</a> - Feb. 12, 2018, 5:59 a.m.</div>
<pre class="content">
Hi,

On Sun, Feb 11, 2018 at 11:19:10AM -0800, tip-bot for David Woodhouse wrote:
<span class="quote">
&gt; x86/speculation: Use IBRS if available before calling into firmware</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Retpoline means the kernel is safe because it has no indirect branches.</span>
<span class="quote">&gt; But firmware isn&#39;t, so use IBRS for firmware calls if it&#39;s available.</span>

afaui, so only retpoline means still mitigation not enough.

Also David W has mentioned [1] that even with retpoline, IBPB is also
required (except Sky Lake).

If IBPB &amp; IBRS is not supported by ucode, shouldn&#39;t the below indicate
some thing on the lines of Mitigation not enough ?
<span class="quote">
&gt; -	return sprintf(buf, &quot;%s%s%s\n&quot;, spectre_v2_strings[spectre_v2_enabled],</span>
<span class="quote">&gt; +	return sprintf(buf, &quot;%s%s%s%s\n&quot;, spectre_v2_strings[spectre_v2_enabled],</span>
<span class="quote">&gt;  		       boot_cpu_has(X86_FEATURE_USE_IBPB) ? &quot;, IBPB&quot; : &quot;&quot;,</span>
<span class="quote">&gt; +		       boot_cpu_has(X86_FEATURE_USE_IBRS_FW) ? &quot;, IBRS_FW&quot; : &quot;&quot;,</span>
<span class="quote">&gt;  		       spectre_v2_module_string());</span>

On 4.16-rc1, w/ GCC 7.3.0,

/sys/devices/system/cpu/vulnerabilities/meltdown:Mitigation: PTI
/sys/devices/system/cpu/vulnerabilities/spectre_v1:Mitigation: __user pointer sanitization
/sys/devices/system/cpu/vulnerabilities/spectre_v2:Mitigation: Full generic retpoline

Here for the user (at least for me), it is not clear whether the
mitigation is enough. In the present system (Ivy Bridge), as ucode
update is not available, IBPB is not printed along with
&quot;spectre_v2:Mitigation&quot;, so unless i am missing something, till then
this system should be considered vulnerable, but for a user not
familiar with details of the issue, it cannot be deduced.

Perhaps an additional status field [OKAY,PARTIAL] to Mitigation in
sysfs might be helpful. All these changes are in the air for me, this
is from a user perspective, sorry if my feedback seems idiotic.

afzal


[1] lkml.kernel.org/r/1516638426.9521.20.camel@infradead.org
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a> - Feb. 12, 2018, 10:22 a.m.</div>
<pre class="content">
* tip-bot for David Woodhouse &lt;tipbot@zytor.com&gt; wrote:
<span class="quote">
&gt; Commit-ID:  670c3e8da87fa4046a55077b1409cf250865a203</span>
<span class="quote">&gt; Gitweb:     https://git.kernel.org/tip/670c3e8da87fa4046a55077b1409cf250865a203</span>
<span class="quote">&gt; Author:     David Woodhouse &lt;dwmw@amazon.co.uk&gt;</span>
<span class="quote">&gt; AuthorDate: Sun, 11 Feb 2018 15:19:19 +0000</span>
<span class="quote">&gt; Committer:  Ingo Molnar &lt;mingo@kernel.org&gt;</span>
<span class="quote">&gt; CommitDate: Sun, 11 Feb 2018 19:44:46 +0100</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; x86/speculation: Use IBRS if available before calling into firmware</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Retpoline means the kernel is safe because it has no indirect branches.</span>
<span class="quote">&gt; But firmware isn&#39;t, so use IBRS for firmware calls if it&#39;s available.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: David Woodhouse &lt;dwmw@amazon.co.uk&gt;</span>
<span class="quote">&gt; Cc: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;</span>
<span class="quote">&gt; Cc: Peter Zijlstra &lt;peterz@infradead.org&gt;</span>
<span class="quote">&gt; Cc: Thomas Gleixner &lt;tglx@linutronix.de&gt;</span>
<span class="quote">&gt; Link: http://lkml.kernel.org/r/1518362359-1005-1-git-send-email-dwmw@amazon.co.uk</span>
<span class="quote">&gt; Signed-off-by: Ingo Molnar &lt;mingo@kernel.org&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/x86/include/asm/apm.h           |  6 ++++++</span>
<span class="quote">&gt;  arch/x86/include/asm/cpufeatures.h   |  1 +</span>
<span class="quote">&gt;  arch/x86/include/asm/efi.h           | 17 +++++++++++++++--</span>
<span class="quote">&gt;  arch/x86/include/asm/nospec-branch.h | 37 +++++++++++++++++++++++++++---------</span>
<span class="quote">&gt;  arch/x86/kernel/cpu/bugs.c           | 12 +++++++++++-</span>
<span class="quote">&gt;  drivers/watchdog/hpwdt.c             |  3 +++</span>
<span class="quote">&gt;  6 files changed, 64 insertions(+), 12 deletions(-)</span>
<span class="quote">
&gt; --- a/arch/x86/include/asm/nospec-branch.h</span>
<span class="quote">&gt; +++ b/arch/x86/include/asm/nospec-branch.h</span>
<span class="quote">
&gt; +/*</span>
<span class="quote">&gt; + * With retpoline, we must use IBRS to restrict branch prediction</span>
<span class="quote">&gt; + * before calling into firmware.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +static inline void firmware_restrict_branch_speculation_start(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	alternative_msr_write(MSR_IA32_SPEC_CTRL, SPEC_CTRL_IBRS,</span>
<span class="quote">&gt; +			      X86_FEATURE_USE_IBRS_FW);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static inline void firmware_restrict_branch_speculation_end(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	alternative_msr_write(MSR_IA32_SPEC_CTRL, 0,</span>
<span class="quote">&gt; +			      X86_FEATURE_USE_IBRS_FW);</span>

BTW., there&#39;s a detail that only occurred to me today, this enabling/disabling 
sequence is not NMI safe, and it might be called from NMI context:
<span class="quote">
&gt; --- a/drivers/watchdog/hpwdt.c</span>
<span class="quote">&gt; +++ b/drivers/watchdog/hpwdt.c</span>
<span class="quote">&gt; @@ -38,6 +38,7 @@</span>
<span class="quote">&gt;  #endif /* CONFIG_HPWDT_NMI_DECODING */</span>
<span class="quote">&gt;  #include &lt;asm/nmi.h&gt;</span>
<span class="quote">&gt;  #include &lt;asm/frame.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/nospec-branch.h&gt;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #define HPWDT_VERSION			&quot;1.4.0&quot;</span>
<span class="quote">&gt;  #define SECS_TO_TICKS(secs)		((secs) * 1000 / 128)</span>
<span class="quote">&gt; @@ -486,11 +487,13 @@ static int hpwdt_pretimeout(unsigned int ulReason, struct pt_regs *regs)</span>
<span class="quote">&gt;  	if (!hpwdt_nmi_decoding)</span>
<span class="quote">&gt;  		return NMI_DONE;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +	firmware_restrict_branch_speculation_start();</span>
<span class="quote">&gt;  	spin_lock_irqsave(&amp;rom_lock, rom_pl);</span>
<span class="quote">&gt;  	if (!die_nmi_called &amp;&amp; !is_icru &amp;&amp; !is_uefi)</span>
<span class="quote">&gt;  		asminline_call(&amp;cmn_regs, cru_rom_addr);</span>
<span class="quote">&gt;  	die_nmi_called = 1;</span>
<span class="quote">&gt;  	spin_unlock_irqrestore(&amp;rom_lock, rom_pl);</span>
<span class="quote">&gt; +	firmware_restrict_branch_speculation_end();</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	if (allow_kdump)</span>
<span class="quote">&gt;  		hpwdt_stop();</span>

But ... this is a (comparatively rare) hardware-watchdog tick function, and the 
chance of racing with say an EFI call seems minuscule. The race will result in an 
EFI call being performed with speculation enabled, sporadically.

Is this something we should worry about?

Thanks,

	Ingo
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137">Peter Zijlstra</a> - Feb. 12, 2018, 11:50 a.m.</div>
<pre class="content">
On Mon, Feb 12, 2018 at 11:22:11AM +0100, Ingo Molnar wrote:
<span class="quote">&gt; &gt; +static inline void firmware_restrict_branch_speculation_start(void)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	alternative_msr_write(MSR_IA32_SPEC_CTRL, SPEC_CTRL_IBRS,</span>
<span class="quote">&gt; &gt; +			      X86_FEATURE_USE_IBRS_FW);</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static inline void firmware_restrict_branch_speculation_end(void)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	alternative_msr_write(MSR_IA32_SPEC_CTRL, 0,</span>
<span class="quote">&gt; &gt; +			      X86_FEATURE_USE_IBRS_FW);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; BTW., there&#39;s a detail that only occurred to me today, this enabling/disabling </span>
<span class="quote">&gt; sequence is not NMI safe, and it might be called from NMI context:</span>

Wait, we&#39;re doing firmware from NMI? That sounds like a _REALLY_ bad
idea.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=308">David Woodhouse</a> - Feb. 12, 2018, 12:27 p.m.</div>
<pre class="content">
On Mon, 2018-02-12 at 12:50 +0100, Peter Zijlstra wrote:
<span class="quote">&gt; On Mon, Feb 12, 2018 at 11:22:11AM +0100, Ingo Molnar wrote:</span>
<span class="quote">&gt; &gt; &gt; +static inline void firmware_restrict_branch_speculation_start(void)</span>
<span class="quote">&gt; &gt; &gt; +{</span>
<span class="quote">&gt; &gt; &gt; +   alternative_msr_write(MSR_IA32_SPEC_CTRL, SPEC_CTRL_IBRS,</span>
<span class="quote">&gt; &gt; &gt; +                         X86_FEATURE_USE_IBRS_FW);</span>
<span class="quote">&gt; &gt; &gt; +}</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +static inline void firmware_restrict_branch_speculation_end(void)</span>
<span class="quote">&gt; &gt; &gt; +{</span>
<span class="quote">&gt; &gt; &gt; +   alternative_msr_write(MSR_IA32_SPEC_CTRL, 0,</span>
<span class="quote">&gt; &gt; &gt; +                         X86_FEATURE_USE_IBRS_FW);</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; BTW., there&#39;s a detail that only occurred to me today, this enabling/disabling </span>
<span class="quote">&gt; &gt; sequence is not NMI safe, and it might be called from NMI context:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Wait, we&#39;re doing firmware from NMI? That sounds like a _REALLY_ bad</span>
<span class="quote">&gt; idea.</span>

And spin_lock_irqsave() too. Which is probably why I missed the fact
that this was being called in NMI context.

Yay for HP and their persistent attempts to &quot;value subtract&quot; in their
firmware offerings.

I&#39;m tempted to drop that part of the patch and declare that if you&#39;re
using this driver, the potential for stray branch prediction when you
call into the firmware from the NMI handler is the *least* of your
problems.

I *will* go back over the other parts of the patch and audit them for
preempt safety though; there could potentially be a similar issue
there. I think I put them close enough to the actual firmware calls
that if we aren&#39;t already preempt-safe then we were screwed anyway, but
*maybe* there&#39;s merit in making the macros explicitly bump the preempt
count anyway.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137">Peter Zijlstra</a> - Feb. 12, 2018, 12:28 p.m.</div>
<pre class="content">
On Mon, Feb 12, 2018 at 12:50:02PM +0100, Peter Zijlstra wrote:
<span class="quote">&gt; On Mon, Feb 12, 2018 at 11:22:11AM +0100, Ingo Molnar wrote:</span>
<span class="quote">&gt; &gt; &gt; +static inline void firmware_restrict_branch_speculation_start(void)</span>
<span class="quote">&gt; &gt; &gt; +{</span>
<span class="quote">&gt; &gt; &gt; +	alternative_msr_write(MSR_IA32_SPEC_CTRL, SPEC_CTRL_IBRS,</span>
<span class="quote">&gt; &gt; &gt; +			      X86_FEATURE_USE_IBRS_FW);</span>
<span class="quote">&gt; &gt; &gt; +}</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +static inline void firmware_restrict_branch_speculation_end(void)</span>
<span class="quote">&gt; &gt; &gt; +{</span>
<span class="quote">&gt; &gt; &gt; +	alternative_msr_write(MSR_IA32_SPEC_CTRL, 0,</span>
<span class="quote">&gt; &gt; &gt; +			      X86_FEATURE_USE_IBRS_FW);</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; BTW., there&#39;s a detail that only occurred to me today, this enabling/disabling </span>
<span class="quote">&gt; &gt; sequence is not NMI safe, and it might be called from NMI context:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Wait, we&#39;re doing firmware from NMI? That sounds like a _REALLY_ bad</span>
<span class="quote">&gt; idea.</span>

Argh, its that stupid watchdog driver again.. Not only does it call
firmware, it also uses (!raw) spinlock.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137">Peter Zijlstra</a> - Feb. 12, 2018, 1:06 p.m.</div>
<pre class="content">
On Mon, Feb 12, 2018 at 12:27:19PM +0000, David Woodhouse wrote:
<span class="quote">&gt; On Mon, 2018-02-12 at 12:50 +0100, Peter Zijlstra wrote:</span>
<span class="quote">
&gt; &gt; Wait, we&#39;re doing firmware from NMI? That sounds like a _REALLY_ bad</span>
<span class="quote">&gt; &gt; idea.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; And spin_lock_irqsave() too. Which is probably why I missed the fact</span>
<span class="quote">&gt; that this was being called in NMI context.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Yay for HP and their persistent attempts to &quot;value subtract&quot; in their</span>
<span class="quote">&gt; firmware offerings.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I&#39;m tempted to drop that part of the patch and declare that if you&#39;re</span>
<span class="quote">&gt; using this driver, the potential for stray branch prediction when you</span>
<span class="quote">&gt; call into the firmware from the NMI handler is the *least* of your</span>
<span class="quote">&gt; problems.</span>

We should probably mark it BROKEN or something, or move it into staging.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=2302">Dave Hansen</a> - Feb. 12, 2018, 4:13 p.m.</div>
<pre class="content">
On 02/12/2018 02:22 AM, Ingo Molnar wrote:
<span class="quote">&gt;&gt; +static inline void firmware_restrict_branch_speculation_end(void)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	alternative_msr_write(MSR_IA32_SPEC_CTRL, 0,</span>
<span class="quote">&gt;&gt; +			      X86_FEATURE_USE_IBRS_FW);</span>
<span class="quote">&gt; BTW., there&#39;s a detail that only occurred to me today, this enabling/disabling </span>
<span class="quote">&gt; sequence is not NMI safe, and it might be called from NMI context:</span>

FWIW, Tim Chen and I talked about this a bunch.  We ended up just
saving/restoring the MSR verbatim in the NMI handler the same way we do
CR3, stashing it in a high general-purpose-register (r%12?).  That costs
a RDMSR (at least) and an WRMSR (which you can optimize out).  We have a
patch for that somewhere if anybody wants it.

We also came to the same conclusion that it&#39;s a rather challenging thing
to exploit these cases, especially when you consider that we can easily
do RSB stuffing on NMI exit just before going back to the firmware.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=308">David Woodhouse</a> - Feb. 12, 2018, 4:30 p.m.</div>
<pre class="content">
On Mon, 2018-02-12 at 11:29 +0530, afzal mohammed wrote:
<span class="quote">&gt; Hi,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On Sun, Feb 11, 2018 at 11:19:10AM -0800, tip-bot for David Woodhouse wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; x86/speculation: Use IBRS if available before calling into firmware</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Retpoline means the kernel is safe because it has no indirect branches.</span>
<span class="quote">&gt; &gt; But firmware isn&#39;t, so use IBRS for firmware calls if it&#39;s available.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; afaui, so only retpoline means still mitigation not enough.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Also David W has mentioned [1] that even with retpoline, IBPB is also</span>
<span class="quote">&gt; required (except Sky Lake).</span>

Retpoline is sufficient to protect the *kernel*, which is the biggest
target. (Except on Skylake, where IBRS is the only full mitigation and
people are still working trying to come up with a &quot;good enough&quot;
mitigation that isn&#39;t IBRS.)

On all CPUs, you need IBPB to protect userspace processes from each
other, although since it&#39;s slow we don&#39;t actually *do* that for every
context switch; only when switching to non-dumpable processes.

That IBPB requirement for protecting userspace is true even on the next
generation of CPUs with the &quot;Enhanced IBRS&quot; (IBRS_ALL) feature. It only
goes away in CPUs which are even *further* in the future, when Intel
manage to fix it completely in hardware. They haven&#39;t even documented
the feature bit they&#39;re going to advertise to indicate that fix yet!
<span class="quote">

&gt; If IBPB &amp; IBRS is not supported by ucode, shouldn&#39;t the below indicate</span>
<span class="quote">&gt; some thing on the lines of Mitigation not enough ?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; -	return sprintf(buf, &quot;%s%s%s\n&quot;, spectre_v2_strings[spectre_v2_enabled],</span>
<span class="quote">&gt; &gt; +	return sprintf(buf, &quot;%s%s%s%s\n&quot;, spectre_v2_strings[spectre_v2_enabled],</span>
<span class="quote">&gt; &gt;  		       boot_cpu_has(X86_FEATURE_USE_IBPB) ? &quot;, IBPB&quot; : &quot;&quot;,</span>
<span class="quote">&gt; &gt; +		       boot_cpu_has(X86_FEATURE_USE_IBRS_FW) ? &quot;, IBRS_FW&quot; : &quot;&quot;,</span>
<span class="quote">&gt; &gt;  		       spectre_v2_module_string());</span>
<span class="quote">&gt; On 4.16-rc1, w/ GCC 7.3.0,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; /sys/devices/system/cpu/vulnerabilities/meltdown:Mitigation: PTI</span>
<span class="quote">&gt; /sys/devices/system/cpu/vulnerabilities/spectre_v1:Mitigation: __user pointer sanitization</span>
<span class="quote">&gt; /sys/devices/system/cpu/vulnerabilities/spectre_v2:Mitigation: Full generic retpoline</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Here for the user (at least for me), it is not clear whether the</span>
<span class="quote">&gt; mitigation is enough. In the present system (Ivy Bridge), as ucode</span>
<span class="quote">&gt; update is not available, IBPB is not printed along with</span>
<span class="quote">&gt; &quot;spectre_v2:Mitigation&quot;, so unless i am missing something, till then</span>
<span class="quote">&gt; this system should be considered vulnerable, but for a user not</span>
<span class="quote">&gt; familiar with details of the issue, it cannot be deduced.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Perhaps an additional status field [OKAY,PARTIAL] to Mitigation in</span>
<span class="quote">&gt; sysfs might be helpful. All these changes are in the air for me, this</span>
<span class="quote">&gt; is from a user perspective, sorry if my feedback seems idiotic.</span>

Given that we only do it for non-dumpable processes, it&#39;s *always*
going to be only partial. (Although I think Thomas was looking at a
command line option to  make that happen on every context switch?)

And on Skylake the current plan is that strictly speaking it would also
be partial.

I understand the concern, but I&#39;m not sure that there&#39;s much we can do
to improve it. If it says &quot;Mitigation:&quot; that&#39;s generally OK, and if it
says anything else, it&#39;s not.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137">Peter Zijlstra</a> - Feb. 12, 2018, 4:58 p.m.</div>
<pre class="content">
On Mon, Feb 12, 2018 at 08:13:31AM -0800, Dave Hansen wrote:
<span class="quote">&gt; On 02/12/2018 02:22 AM, Ingo Molnar wrote:</span>
<span class="quote">&gt; &gt;&gt; +static inline void firmware_restrict_branch_speculation_end(void)</span>
<span class="quote">&gt; &gt;&gt; +{</span>
<span class="quote">&gt; &gt;&gt; +	alternative_msr_write(MSR_IA32_SPEC_CTRL, 0,</span>
<span class="quote">&gt; &gt;&gt; +			      X86_FEATURE_USE_IBRS_FW);</span>
<span class="quote">&gt; &gt; BTW., there&#39;s a detail that only occurred to me today, this enabling/disabling </span>
<span class="quote">&gt; &gt; sequence is not NMI safe, and it might be called from NMI context:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; FWIW, Tim Chen and I talked about this a bunch.  We ended up just</span>
<span class="quote">&gt; saving/restoring the MSR verbatim in the NMI handler the same way we do</span>
<span class="quote">&gt; CR3, stashing it in a high general-purpose-register (r%12?).  That costs</span>
<span class="quote">&gt; a RDMSR (at least) and an WRMSR (which you can optimize out).  We have a</span>
<span class="quote">&gt; patch for that somewhere if anybody wants it.</span>

I would really rather not do that on the NMI path.. And if we _have_ to,
please keep a software shadow of that MSR state, such that we can avoid
touching that MSR 99% of the time.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a> - Feb. 13, 2018, 7:55 a.m.</div>
<pre class="content">
* Peter Zijlstra &lt;peterz@infradead.org&gt; wrote:
<span class="quote">
&gt; On Mon, Feb 12, 2018 at 08:13:31AM -0800, Dave Hansen wrote:</span>
<span class="quote">&gt; &gt; On 02/12/2018 02:22 AM, Ingo Molnar wrote:</span>
<span class="quote">&gt; &gt; &gt;&gt; +static inline void firmware_restrict_branch_speculation_end(void)</span>
<span class="quote">&gt; &gt; &gt;&gt; +{</span>
<span class="quote">&gt; &gt; &gt;&gt; +	alternative_msr_write(MSR_IA32_SPEC_CTRL, 0,</span>
<span class="quote">&gt; &gt; &gt;&gt; +			      X86_FEATURE_USE_IBRS_FW);</span>
<span class="quote">&gt; &gt; &gt; BTW., there&#39;s a detail that only occurred to me today, this enabling/disabling </span>
<span class="quote">&gt; &gt; &gt; sequence is not NMI safe, and it might be called from NMI context:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; FWIW, Tim Chen and I talked about this a bunch.  We ended up just</span>
<span class="quote">&gt; &gt; saving/restoring the MSR verbatim in the NMI handler the same way we do</span>
<span class="quote">&gt; &gt; CR3, stashing it in a high general-purpose-register (r%12?).  That costs</span>
<span class="quote">&gt; &gt; a RDMSR (at least) and an WRMSR (which you can optimize out).  We have a</span>
<span class="quote">&gt; &gt; patch for that somewhere if anybody wants it.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I would really rather not do that on the NMI path.. And if we _have_ to,</span>
<span class="quote">&gt; please keep a software shadow of that MSR state, such that we can avoid</span>
<span class="quote">&gt; touching that MSR 99% of the time.</span>

Yeah, I&#39;d rather avoid doing firmware calls from NMI context altogether.

Thanks,

	Ingo
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a> - Feb. 13, 2018, 7:58 a.m.</div>
<pre class="content">
* David Woodhouse &lt;dwmw2@infradead.org&gt; wrote:
<span class="quote">
&gt; On Mon, 2018-02-12 at 12:50 +0100, Peter Zijlstra wrote:</span>
<span class="quote">&gt; &gt; On Mon, Feb 12, 2018 at 11:22:11AM +0100, Ingo Molnar wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; +static inline void firmware_restrict_branch_speculation_start(void)</span>
<span class="quote">&gt; &gt; &gt; &gt; +{</span>
<span class="quote">&gt; &gt; &gt; &gt; +   alternative_msr_write(MSR_IA32_SPEC_CTRL, SPEC_CTRL_IBRS,</span>
<span class="quote">&gt; &gt; &gt; &gt; +                         X86_FEATURE_USE_IBRS_FW);</span>
<span class="quote">&gt; &gt; &gt; &gt; +}</span>
<span class="quote">&gt; &gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; &gt; +static inline void firmware_restrict_branch_speculation_end(void)</span>
<span class="quote">&gt; &gt; &gt; &gt; +{</span>
<span class="quote">&gt; &gt; &gt; &gt; +   alternative_msr_write(MSR_IA32_SPEC_CTRL, 0,</span>
<span class="quote">&gt; &gt; &gt; &gt; +                         X86_FEATURE_USE_IBRS_FW);</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; BTW., there&#39;s a detail that only occurred to me today, this enabling/disabling </span>
<span class="quote">&gt; &gt; &gt; sequence is not NMI safe, and it might be called from NMI context:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Wait, we&#39;re doing firmware from NMI? That sounds like a _REALLY_ bad</span>
<span class="quote">&gt; &gt; idea.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; And spin_lock_irqsave() too. Which is probably why I missed the fact</span>
<span class="quote">&gt; that this was being called in NMI context.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Yay for HP and their persistent attempts to &quot;value subtract&quot; in their</span>
<span class="quote">&gt; firmware offerings.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I&#39;m tempted to drop that part of the patch and declare that if you&#39;re</span>
<span class="quote">&gt; using this driver, the potential for stray branch prediction when you</span>
<span class="quote">&gt; call into the firmware from the NMI handler is the *least* of your</span>
<span class="quote">&gt; problems.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I *will* go back over the other parts of the patch and audit them for</span>
<span class="quote">&gt; preempt safety though; there could potentially be a similar issue</span>
<span class="quote">&gt; there. I think I put them close enough to the actual firmware calls</span>
<span class="quote">&gt; that if we aren&#39;t already preempt-safe then we were screwed anyway, but</span>
<span class="quote">&gt; *maybe* there&#39;s merit in making the macros explicitly bump the preempt</span>
<span class="quote">&gt; count anyway.</span>

Ok, meanwhile I&#39;m removing this patch from the x86/pti branch, and since the 
branch has to be rebased anyway, I&#39;ll merge these into a single patch:

85d8426e0720: x86/speculation: Correct Speculation Control microcode blacklist again
1751342095f0: x86/speculation: Update Speculation Control microcode blacklist

Thanks,

	Ingo
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/include/asm/apm.h b/arch/x86/include/asm/apm.h</span>
<span class="p_header">index 4d4015d..c356098 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/apm.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/apm.h</span>
<span class="p_chunk">@@ -7,6 +7,8 @@</span> <span class="p_context"></span>
 #ifndef _ASM_X86_MACH_DEFAULT_APM_H
 #define _ASM_X86_MACH_DEFAULT_APM_H
 
<span class="p_add">+#include &lt;asm/nospec-branch.h&gt;</span>
<span class="p_add">+</span>
 #ifdef APM_ZERO_SEGS
 #	define APM_DO_ZERO_SEGS \
 		&quot;pushl %%ds\n\t&quot; \
<span class="p_chunk">@@ -32,6 +34,7 @@</span> <span class="p_context"> static inline void apm_bios_call_asm(u32 func, u32 ebx_in, u32 ecx_in,</span>
 	 * N.B. We do NOT need a cld after the BIOS call
 	 * because we always save and restore the flags.
 	 */
<span class="p_add">+	firmware_restrict_branch_speculation_start();</span>
 	__asm__ __volatile__(APM_DO_ZERO_SEGS
 		&quot;pushl %%edi\n\t&quot;
 		&quot;pushl %%ebp\n\t&quot;
<span class="p_chunk">@@ -44,6 +47,7 @@</span> <span class="p_context"> static inline void apm_bios_call_asm(u32 func, u32 ebx_in, u32 ecx_in,</span>
 		  &quot;=S&quot; (*esi)
 		: &quot;a&quot; (func), &quot;b&quot; (ebx_in), &quot;c&quot; (ecx_in)
 		: &quot;memory&quot;, &quot;cc&quot;);
<span class="p_add">+	firmware_restrict_branch_speculation_end();</span>
 }
 
 static inline bool apm_bios_call_simple_asm(u32 func, u32 ebx_in,
<span class="p_chunk">@@ -56,6 +60,7 @@</span> <span class="p_context"> static inline bool apm_bios_call_simple_asm(u32 func, u32 ebx_in,</span>
 	 * N.B. We do NOT need a cld after the BIOS call
 	 * because we always save and restore the flags.
 	 */
<span class="p_add">+	firmware_restrict_branch_speculation_start();</span>
 	__asm__ __volatile__(APM_DO_ZERO_SEGS
 		&quot;pushl %%edi\n\t&quot;
 		&quot;pushl %%ebp\n\t&quot;
<span class="p_chunk">@@ -68,6 +73,7 @@</span> <span class="p_context"> static inline bool apm_bios_call_simple_asm(u32 func, u32 ebx_in,</span>
 		  &quot;=S&quot; (si)
 		: &quot;a&quot; (func), &quot;b&quot; (ebx_in), &quot;c&quot; (ecx_in)
 		: &quot;memory&quot;, &quot;cc&quot;);
<span class="p_add">+	firmware_restrict_branch_speculation_end();</span>
 	return error;
 }
 
<span class="p_header">diff --git a/arch/x86/include/asm/cpufeatures.h b/arch/x86/include/asm/cpufeatures.h</span>
<span class="p_header">index 73b5fff..66c1434 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/cpufeatures.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/cpufeatures.h</span>
<span class="p_chunk">@@ -211,6 +211,7 @@</span> <span class="p_context"></span>
 #define X86_FEATURE_RSB_CTXSW		( 7*32+19) /* &quot;&quot; Fill RSB on context switches */
 
 #define X86_FEATURE_USE_IBPB		( 7*32+21) /* &quot;&quot; Indirect Branch Prediction Barrier enabled */
<span class="p_add">+#define X86_FEATURE_USE_IBRS_FW		( 7*32+22) /* &quot;&quot; Use IBRS during runtime firmware calls */</span>
 
 /* Virtualization flags: Linux defined, word 8 */
 #define X86_FEATURE_TPR_SHADOW		( 8*32+ 0) /* Intel TPR Shadow */
<span class="p_header">diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h</span>
<span class="p_header">index 85f6ccb..a399c1e 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/efi.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/efi.h</span>
<span class="p_chunk">@@ -6,6 +6,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/processor-flags.h&gt;
 #include &lt;asm/tlb.h&gt;
<span class="p_add">+#include &lt;asm/nospec-branch.h&gt;</span>
 
 /*
  * We map the EFI regions needed for runtime services non-contiguously,
<span class="p_chunk">@@ -36,8 +37,18 @@</span> <span class="p_context"></span>
 
 extern asmlinkage unsigned long efi_call_phys(void *, ...);
 
<span class="p_del">-#define arch_efi_call_virt_setup()	kernel_fpu_begin()</span>
<span class="p_del">-#define arch_efi_call_virt_teardown()	kernel_fpu_end()</span>
<span class="p_add">+#define arch_efi_call_virt_setup()					\</span>
<span class="p_add">+({									\</span>
<span class="p_add">+	kernel_fpu_begin();						\</span>
<span class="p_add">+	firmware_restrict_branch_speculation_start();			\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
<span class="p_add">+#define arch_efi_call_virt_teardown()					\</span>
<span class="p_add">+({									\</span>
<span class="p_add">+	firmware_restrict_branch_speculation_end();			\</span>
<span class="p_add">+	kernel_fpu_end();						\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
 
 /*
  * Wrap all the virtual calls in a way that forces the parameters on the stack.
<span class="p_chunk">@@ -73,6 +84,7 @@</span> <span class="p_context"> struct efi_scratch {</span>
 	efi_sync_low_kernel_mappings();					\
 	preempt_disable();						\
 	__kernel_fpu_begin();						\
<span class="p_add">+	firmware_restrict_branch_speculation_start();			\</span>
 									\
 	if (efi_scratch.use_pgd) {					\
 		efi_scratch.prev_cr3 = __read_cr3();			\
<span class="p_chunk">@@ -91,6 +103,7 @@</span> <span class="p_context"> struct efi_scratch {</span>
 		__flush_tlb_all();					\
 	}								\
 									\
<span class="p_add">+	firmware_restrict_branch_speculation_end();			\</span>
 	__kernel_fpu_end();						\
 	preempt_enable();						\
 })
<span class="p_header">diff --git a/arch/x86/include/asm/nospec-branch.h b/arch/x86/include/asm/nospec-branch.h</span>
<span class="p_header">index 300cc15..788c4da 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/nospec-branch.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/nospec-branch.h</span>
<span class="p_chunk">@@ -162,17 +162,36 @@</span> <span class="p_context"> static inline void vmexit_fill_RSB(void)</span>
 #endif
 }
 
<span class="p_add">+#define alternative_msr_write(_msr, _val, _feature)		\</span>
<span class="p_add">+	asm volatile(ALTERNATIVE(&quot;&quot;,				\</span>
<span class="p_add">+				 &quot;movl %[msr], %%ecx\n\t&quot;	\</span>
<span class="p_add">+				 &quot;movl %[val], %%eax\n\t&quot;	\</span>
<span class="p_add">+				 &quot;movl $0, %%edx\n\t&quot;		\</span>
<span class="p_add">+				 &quot;wrmsr&quot;,			\</span>
<span class="p_add">+				 _feature)			\</span>
<span class="p_add">+		     : : [msr] &quot;i&quot; (_msr), [val] &quot;i&quot; (_val)	\</span>
<span class="p_add">+		     : &quot;eax&quot;, &quot;ecx&quot;, &quot;edx&quot;, &quot;memory&quot;)</span>
<span class="p_add">+</span>
 static inline void indirect_branch_prediction_barrier(void)
 {
<span class="p_del">-	asm volatile(ALTERNATIVE(&quot;&quot;,</span>
<span class="p_del">-				 &quot;movl %[msr], %%ecx\n\t&quot;</span>
<span class="p_del">-				 &quot;movl %[val], %%eax\n\t&quot;</span>
<span class="p_del">-				 &quot;movl $0, %%edx\n\t&quot;</span>
<span class="p_del">-				 &quot;wrmsr&quot;,</span>
<span class="p_del">-				 X86_FEATURE_USE_IBPB)</span>
<span class="p_del">-		     : : [msr] &quot;i&quot; (MSR_IA32_PRED_CMD),</span>
<span class="p_del">-			 [val] &quot;i&quot; (PRED_CMD_IBPB)</span>
<span class="p_del">-		     : &quot;eax&quot;, &quot;ecx&quot;, &quot;edx&quot;, &quot;memory&quot;);</span>
<span class="p_add">+	alternative_msr_write(MSR_IA32_PRED_CMD, PRED_CMD_IBPB,</span>
<span class="p_add">+			      X86_FEATURE_USE_IBPB);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * With retpoline, we must use IBRS to restrict branch prediction</span>
<span class="p_add">+ * before calling into firmware.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void firmware_restrict_branch_speculation_start(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	alternative_msr_write(MSR_IA32_SPEC_CTRL, SPEC_CTRL_IBRS,</span>
<span class="p_add">+			      X86_FEATURE_USE_IBRS_FW);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void firmware_restrict_branch_speculation_end(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	alternative_msr_write(MSR_IA32_SPEC_CTRL, 0,</span>
<span class="p_add">+			      X86_FEATURE_USE_IBRS_FW);</span>
 }
 
 #endif /* __ASSEMBLY__ */
<span class="p_header">diff --git a/arch/x86/kernel/cpu/bugs.c b/arch/x86/kernel/cpu/bugs.c</span>
<span class="p_header">index 61152aa..6f6d763 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/bugs.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/bugs.c</span>
<span class="p_chunk">@@ -303,6 +303,15 @@</span> <span class="p_context"> retpoline_auto:</span>
 		setup_force_cpu_cap(X86_FEATURE_USE_IBPB);
 		pr_info(&quot;Enabling Indirect Branch Prediction Barrier\n&quot;);
 	}
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Retpoline means the kernel is safe because it has no indirect</span>
<span class="p_add">+	 * branches. But firmware isn&#39;t, so use IBRS to protect that.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (boot_cpu_has(X86_FEATURE_IBRS)) {</span>
<span class="p_add">+		setup_force_cpu_cap(X86_FEATURE_USE_IBRS_FW);</span>
<span class="p_add">+		pr_info(&quot;Enabling Restricted Speculation for firmware calls\n&quot;);</span>
<span class="p_add">+	}</span>
 }
 
 #undef pr_fmt
<span class="p_chunk">@@ -332,8 +341,9 @@</span> <span class="p_context"> ssize_t cpu_show_spectre_v2(struct device *dev,</span>
 	if (!boot_cpu_has_bug(X86_BUG_SPECTRE_V2))
 		return sprintf(buf, &quot;Not affected\n&quot;);
 
<span class="p_del">-	return sprintf(buf, &quot;%s%s%s\n&quot;, spectre_v2_strings[spectre_v2_enabled],</span>
<span class="p_add">+	return sprintf(buf, &quot;%s%s%s%s\n&quot;, spectre_v2_strings[spectre_v2_enabled],</span>
 		       boot_cpu_has(X86_FEATURE_USE_IBPB) ? &quot;, IBPB&quot; : &quot;&quot;,
<span class="p_add">+		       boot_cpu_has(X86_FEATURE_USE_IBRS_FW) ? &quot;, IBRS_FW&quot; : &quot;&quot;,</span>
 		       spectre_v2_module_string());
 }
 #endif
<span class="p_header">diff --git a/drivers/watchdog/hpwdt.c b/drivers/watchdog/hpwdt.c</span>
<span class="p_header">index 67fbe35..bab3721 100644</span>
<span class="p_header">--- a/drivers/watchdog/hpwdt.c</span>
<span class="p_header">+++ b/drivers/watchdog/hpwdt.c</span>
<span class="p_chunk">@@ -38,6 +38,7 @@</span> <span class="p_context"></span>
 #endif /* CONFIG_HPWDT_NMI_DECODING */
 #include &lt;asm/nmi.h&gt;
 #include &lt;asm/frame.h&gt;
<span class="p_add">+#include &lt;asm/nospec-branch.h&gt;</span>
 
 #define HPWDT_VERSION			&quot;1.4.0&quot;
 #define SECS_TO_TICKS(secs)		((secs) * 1000 / 128)
<span class="p_chunk">@@ -486,11 +487,13 @@</span> <span class="p_context"> static int hpwdt_pretimeout(unsigned int ulReason, struct pt_regs *regs)</span>
 	if (!hpwdt_nmi_decoding)
 		return NMI_DONE;
 
<span class="p_add">+	firmware_restrict_branch_speculation_start();</span>
 	spin_lock_irqsave(&amp;rom_lock, rom_pl);
 	if (!die_nmi_called &amp;&amp; !is_icru &amp;&amp; !is_uefi)
 		asminline_call(&amp;cmn_regs, cru_rom_addr);
 	die_nmi_called = 1;
 	spin_unlock_irqrestore(&amp;rom_lock, rom_pl);
<span class="p_add">+	firmware_restrict_branch_speculation_end();</span>
 
 	if (allow_kdump)
 		hpwdt_stop();

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



