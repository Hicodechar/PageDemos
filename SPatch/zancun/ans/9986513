
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.90 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.90</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 5, 2017, 8:06 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171005080627.GB28457@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9986513/mbox/"
   >mbox</a>
|
   <a href="/patch/9986513/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9986513/">/patch/9986513/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	5F38A60247 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  5 Oct 2017 08:06:38 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 4669F2857E
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  5 Oct 2017 08:06:38 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 3AC8D28C44; Thu,  5 Oct 2017 08:06:38 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 0A88F2857E
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  5 Oct 2017 08:06:36 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751817AbdJEIGd (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 5 Oct 2017 04:06:33 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:37514 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751702AbdJEIGT (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 5 Oct 2017 04:06:19 -0400
Received: from localhost (LFbn-1-12253-150.w90-92.abo.wanadoo.fr
	[90.92.67.150])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 75F38491;
	Thu,  5 Oct 2017 08:06:18 +0000 (UTC)
Date: Thu, 5 Oct 2017 10:06:27 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.90
Message-ID: &lt;20171005080627.GB28457@kroah.com&gt;
References: &lt;20171005080619.GA28457@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20171005080619.GA28457@kroah.com&gt;
User-Agent: Mutt/1.9.1 (2017-09-22)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Oct. 5, 2017, 8:06 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 7e4c46b375b3..ca5aaaf4aef7 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 89</span>
<span class="p_add">+SUBLEVEL = 90</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arm/boot/dts/pxa27x.dtsi b/arch/arm/boot/dts/pxa27x.dtsi</span>
<span class="p_header">index 7f68a1ee7073..210192c38df3 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/pxa27x.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/pxa27x.dtsi</span>
<span class="p_chunk">@@ -13,6 +13,7 @@</span> <span class="p_context"></span>
 			interrupts = &lt;25&gt;;
 			#dma-channels = &lt;32&gt;;
 			#dma-cells = &lt;2&gt;;
<span class="p_add">+			#dma-requests = &lt;75&gt;;</span>
 			status = &quot;okay&quot;;
 		};
 
<span class="p_header">diff --git a/arch/arm/boot/dts/pxa3xx.dtsi b/arch/arm/boot/dts/pxa3xx.dtsi</span>
<span class="p_header">index 564341af7e97..fec47bcd8292 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/pxa3xx.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/pxa3xx.dtsi</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"></span>
 			interrupts = &lt;25&gt;;
 			#dma-channels = &lt;32&gt;;
 			#dma-cells = &lt;2&gt;;
<span class="p_add">+			#dma-requests = &lt;100&gt;;</span>
 			status = &quot;okay&quot;;
 		};
 
<span class="p_header">diff --git a/arch/arm/mach-pxa/devices.c b/arch/arm/mach-pxa/devices.c</span>
<span class="p_header">index 2a6e0ae2b920..614e9d8f0a54 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/devices.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/devices.c</span>
<span class="p_chunk">@@ -1203,6 +1203,7 @@</span> <span class="p_context"> void __init pxa2xx_set_spi_info(unsigned id, struct pxa2xx_spi_master *info)</span>
 
 static struct mmp_dma_platdata pxa_dma_pdata = {
 	.dma_channels	= 0,
<span class="p_add">+	.nb_requestors	= 0,</span>
 };
 
 static struct resource pxa_dma_resource[] = {
<span class="p_chunk">@@ -1231,8 +1232,9 @@</span> <span class="p_context"> static struct platform_device pxa2xx_pxa_dma = {</span>
 	.resource	= pxa_dma_resource,
 };
 
<span class="p_del">-void __init pxa2xx_set_dmac_info(int nb_channels)</span>
<span class="p_add">+void __init pxa2xx_set_dmac_info(int nb_channels, int nb_requestors)</span>
 {
 	pxa_dma_pdata.dma_channels = nb_channels;
<span class="p_add">+	pxa_dma_pdata.nb_requestors = nb_requestors;</span>
 	pxa_register_device(&amp;pxa2xx_pxa_dma, &amp;pxa_dma_pdata);
 }
<span class="p_header">diff --git a/arch/arm/mach-pxa/pxa25x.c b/arch/arm/mach-pxa/pxa25x.c</span>
<span class="p_header">index 1dc85ffc3e20..049b9cc22720 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/pxa25x.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/pxa25x.c</span>
<span class="p_chunk">@@ -206,7 +206,7 @@</span> <span class="p_context"> static int __init pxa25x_init(void)</span>
 		register_syscore_ops(&amp;pxa_irq_syscore_ops);
 		register_syscore_ops(&amp;pxa2xx_mfp_syscore_ops);
 
<span class="p_del">-		pxa2xx_set_dmac_info(16);</span>
<span class="p_add">+		pxa2xx_set_dmac_info(16, 40);</span>
 		pxa_register_device(&amp;pxa25x_device_gpio, &amp;pxa25x_gpio_info);
 		ret = platform_add_devices(pxa25x_devices,
 					   ARRAY_SIZE(pxa25x_devices));
<span class="p_header">diff --git a/arch/arm/mach-pxa/pxa27x.c b/arch/arm/mach-pxa/pxa27x.c</span>
<span class="p_header">index ffc424028557..2fb6430b7a34 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/pxa27x.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/pxa27x.c</span>
<span class="p_chunk">@@ -309,7 +309,7 @@</span> <span class="p_context"> static int __init pxa27x_init(void)</span>
 		if (!of_have_populated_dt()) {
 			pxa_register_device(&amp;pxa27x_device_gpio,
 					    &amp;pxa27x_gpio_info);
<span class="p_del">-			pxa2xx_set_dmac_info(32);</span>
<span class="p_add">+			pxa2xx_set_dmac_info(32, 75);</span>
 			ret = platform_add_devices(devices,
 						   ARRAY_SIZE(devices));
 		}
<span class="p_header">diff --git a/arch/arm/mach-pxa/pxa3xx.c b/arch/arm/mach-pxa/pxa3xx.c</span>
<span class="p_header">index 20ce2d386f17..ca06f082497c 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/pxa3xx.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/pxa3xx.c</span>
<span class="p_chunk">@@ -450,7 +450,7 @@</span> <span class="p_context"> static int __init pxa3xx_init(void)</span>
 		if (of_have_populated_dt())
 			return 0;
 
<span class="p_del">-		pxa2xx_set_dmac_info(32);</span>
<span class="p_add">+		pxa2xx_set_dmac_info(32, 100);</span>
 		ret = platform_add_devices(devices, ARRAY_SIZE(devices));
 		if (ret)
 			return ret;
<span class="p_header">diff --git a/arch/arm/plat-pxa/include/plat/dma.h b/arch/arm/plat-pxa/include/plat/dma.h</span>
<span class="p_header">index 28848b344e2d..ceba3e4184fc 100644</span>
<span class="p_header">--- a/arch/arm/plat-pxa/include/plat/dma.h</span>
<span class="p_header">+++ b/arch/arm/plat-pxa/include/plat/dma.h</span>
<span class="p_chunk">@@ -95,6 +95,6 @@</span> <span class="p_context"> static inline int pxad_toggle_reserved_channel(int legacy_channel)</span>
 }
 #endif
 
<span class="p_del">-extern void __init pxa2xx_set_dmac_info(int nb_channels);</span>
<span class="p_add">+extern void __init pxa2xx_set_dmac_info(int nb_channels, int nb_requestors);</span>
 
 #endif /* __PLAT_DMA_H */
<span class="p_header">diff --git a/arch/arm/xen/mm.c b/arch/arm/xen/mm.c</span>
<span class="p_header">index c5f9a9e3d1f3..28d83f536e93 100644</span>
<span class="p_header">--- a/arch/arm/xen/mm.c</span>
<span class="p_header">+++ b/arch/arm/xen/mm.c</span>
<span class="p_chunk">@@ -199,6 +199,7 @@</span> <span class="p_context"> static struct dma_map_ops xen_swiotlb_dma_ops = {</span>
 	.unmap_page = xen_swiotlb_unmap_page,
 	.dma_supported = xen_swiotlb_dma_supported,
 	.set_dma_mask = xen_swiotlb_set_dma_mask,
<span class="p_add">+	.mmap = xen_swiotlb_dma_mmap,</span>
 };
 
 int __init xen_mm_init(void)
<span class="p_header">diff --git a/arch/arm64/kernel/head.S b/arch/arm64/kernel/head.S</span>
<span class="p_header">index 20ceb5edf7b8..d019c3a58cc2 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/head.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/head.S</span>
<span class="p_chunk">@@ -446,6 +446,7 @@</span> <span class="p_context"> ENDPROC(__mmap_switched)</span>
  * booted in EL1 or EL2 respectively.
  */
 ENTRY(el2_setup)
<span class="p_add">+	msr	SPsel, #1			// We want to use SP_EL{1,2}</span>
 	mrs	x0, CurrentEL
 	cmp	x0, #CurrentEL_EL2
 	b.ne	1f
<span class="p_header">diff --git a/arch/arm64/mm/fault.c b/arch/arm64/mm/fault.c</span>
<span class="p_header">index 7fabf49f2aeb..86485415c5f0 100644</span>
<span class="p_header">--- a/arch/arm64/mm/fault.c</span>
<span class="p_header">+++ b/arch/arm64/mm/fault.c</span>
<span class="p_chunk">@@ -447,7 +447,7 @@</span> <span class="p_context"> static struct fault_info {</span>
 	{ do_translation_fault,	SIGSEGV, SEGV_MAPERR,	&quot;level 0 translation fault&quot;	},
 	{ do_translation_fault,	SIGSEGV, SEGV_MAPERR,	&quot;level 1 translation fault&quot;	},
 	{ do_translation_fault,	SIGSEGV, SEGV_MAPERR,	&quot;level 2 translation fault&quot;	},
<span class="p_del">-	{ do_page_fault,	SIGSEGV, SEGV_MAPERR,	&quot;level 3 translation fault&quot;	},</span>
<span class="p_add">+	{ do_translation_fault,	SIGSEGV, SEGV_MAPERR,	&quot;level 3 translation fault&quot;	},</span>
 	{ do_bad,		SIGBUS,  0,		&quot;unknown 8&quot;			},
 	{ do_page_fault,	SIGSEGV, SEGV_ACCERR,	&quot;level 1 access flag fault&quot;	},
 	{ do_page_fault,	SIGSEGV, SEGV_ACCERR,	&quot;level 2 access flag fault&quot;	},
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_64_vio.c b/arch/powerpc/kvm/book3s_64_vio.c</span>
<span class="p_header">index 54cf9bc94dad..3a095670b0c4 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_64_vio.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_64_vio.c</span>
<span class="p_chunk">@@ -101,22 +101,17 @@</span> <span class="p_context"> long kvm_vm_ioctl_create_spapr_tce(struct kvm *kvm,</span>
 				   struct kvm_create_spapr_tce *args)
 {
 	struct kvmppc_spapr_tce_table *stt = NULL;
<span class="p_add">+	struct kvmppc_spapr_tce_table *siter;</span>
 	long npages;
 	int ret = -ENOMEM;
 	int i;
 
<span class="p_del">-	/* Check this LIOBN hasn&#39;t been previously allocated */</span>
<span class="p_del">-	list_for_each_entry(stt, &amp;kvm-&gt;arch.spapr_tce_tables, list) {</span>
<span class="p_del">-		if (stt-&gt;liobn == args-&gt;liobn)</span>
<span class="p_del">-			return -EBUSY;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	npages = kvmppc_stt_npages(args-&gt;window_size);
 
 	stt = kzalloc(sizeof(*stt) + npages * sizeof(struct page *),
 		      GFP_KERNEL);
 	if (!stt)
<span class="p_del">-		goto fail;</span>
<span class="p_add">+		return ret;</span>
 
 	stt-&gt;liobn = args-&gt;liobn;
 	stt-&gt;window_size = args-&gt;window_size;
<span class="p_chunk">@@ -128,23 +123,36 @@</span> <span class="p_context"> long kvm_vm_ioctl_create_spapr_tce(struct kvm *kvm,</span>
 			goto fail;
 	}
 
<span class="p_del">-	kvm_get_kvm(kvm);</span>
<span class="p_del">-</span>
 	mutex_lock(&amp;kvm-&gt;lock);
<span class="p_del">-	list_add(&amp;stt-&gt;list, &amp;kvm-&gt;arch.spapr_tce_tables);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check this LIOBN hasn&#39;t been previously allocated */</span>
<span class="p_add">+	ret = 0;</span>
<span class="p_add">+	list_for_each_entry(siter, &amp;kvm-&gt;arch.spapr_tce_tables, list) {</span>
<span class="p_add">+		if (siter-&gt;liobn == args-&gt;liobn) {</span>
<span class="p_add">+			ret = -EBUSY;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		ret = anon_inode_getfd(&quot;kvm-spapr-tce&quot;, &amp;kvm_spapr_tce_fops,</span>
<span class="p_add">+				       stt, O_RDWR | O_CLOEXEC);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret &gt;= 0) {</span>
<span class="p_add">+		list_add(&amp;stt-&gt;list, &amp;kvm-&gt;arch.spapr_tce_tables);</span>
<span class="p_add">+		kvm_get_kvm(kvm);</span>
<span class="p_add">+	}</span>
 
 	mutex_unlock(&amp;kvm-&gt;lock);
 
<span class="p_del">-	return anon_inode_getfd(&quot;kvm-spapr-tce&quot;, &amp;kvm_spapr_tce_fops,</span>
<span class="p_del">-				stt, O_RDWR | O_CLOEXEC);</span>
<span class="p_add">+	if (ret &gt;= 0)</span>
<span class="p_add">+		return ret;</span>
 
<span class="p_del">-fail:</span>
<span class="p_del">-	if (stt) {</span>
<span class="p_del">-		for (i = 0; i &lt; npages; i++)</span>
<span class="p_del">-			if (stt-&gt;pages[i])</span>
<span class="p_del">-				__free_page(stt-&gt;pages[i]);</span>
<span class="p_add">+ fail:</span>
<span class="p_add">+	for (i = 0; i &lt; npages; i++)</span>
<span class="p_add">+		if (stt-&gt;pages[i])</span>
<span class="p_add">+			__free_page(stt-&gt;pages[i]);</span>
 
<span class="p_del">-		kfree(stt);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	kfree(stt);</span>
 	return ret;
 }
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/mobility.c b/arch/powerpc/platforms/pseries/mobility.c</span>
<span class="p_header">index ceb18d349459..8dd0c8edefd6 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/mobility.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/mobility.c</span>
<span class="p_chunk">@@ -225,8 +225,10 @@</span> <span class="p_context"> static int add_dt_node(__be32 parent_phandle, __be32 drc_index)</span>
 		return -ENOENT;
 
 	dn = dlpar_configure_connector(drc_index, parent_dn);
<span class="p_del">-	if (!dn)</span>
<span class="p_add">+	if (!dn) {</span>
<span class="p_add">+		of_node_put(parent_dn);</span>
 		return -ENOENT;
<span class="p_add">+	}</span>
 
 	rc = dlpar_attach_node(dn);
 	if (rc)
<span class="p_header">diff --git a/arch/x86/kernel/fpu/regset.c b/arch/x86/kernel/fpu/regset.c</span>
<span class="p_header">index 0bc3490420c5..72a483c295f2 100644</span>
<span class="p_header">--- a/arch/x86/kernel/fpu/regset.c</span>
<span class="p_header">+++ b/arch/x86/kernel/fpu/regset.c</span>
<span class="p_chunk">@@ -116,6 +116,11 @@</span> <span class="p_context"> int xstateregs_set(struct task_struct *target, const struct user_regset *regset,</span>
 	xsave = &amp;fpu-&gt;state.xsave;
 
 	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, xsave, 0, -1);
<span class="p_add">+</span>
<span class="p_add">+	/* xcomp_bv must be 0 when using uncompacted format */</span>
<span class="p_add">+	if (!ret &amp;&amp; xsave-&gt;header.xcomp_bv)</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+</span>
 	/*
 	 * mxcsr reserved bits must be masked to zero for security reasons.
 	 */
<span class="p_chunk">@@ -126,6 +131,12 @@</span> <span class="p_context"> int xstateregs_set(struct task_struct *target, const struct user_regset *regset,</span>
 	 */
 	memset(&amp;xsave-&gt;header.reserved, 0, 48);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In case of failure, mark all states as init:</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		fpstate_init(&amp;fpu-&gt;state);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/arch/x86/kernel/fpu/signal.c b/arch/x86/kernel/fpu/signal.c</span>
<span class="p_header">index 31c6a60505e6..3de077116218 100644</span>
<span class="p_header">--- a/arch/x86/kernel/fpu/signal.c</span>
<span class="p_header">+++ b/arch/x86/kernel/fpu/signal.c</span>
<span class="p_chunk">@@ -309,7 +309,9 @@</span> <span class="p_context"> static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)</span>
 		fpu__drop(fpu);
 
 		if (__copy_from_user(&amp;fpu-&gt;state.xsave, buf_fx, state_size) ||
<span class="p_del">-		    __copy_from_user(&amp;env, buf, sizeof(env))) {</span>
<span class="p_add">+		    __copy_from_user(&amp;env, buf, sizeof(env)) ||</span>
<span class="p_add">+		    (state_size &gt; offsetof(struct xregs_state, header) &amp;&amp;</span>
<span class="p_add">+		     fpu-&gt;state.xsave.header.xcomp_bv)) {</span>
 			fpstate_init(&amp;fpu-&gt;state);
 			err = -1;
 		} else {
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index b12391119ce8..a018dff00808 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -2029,8 +2029,8 @@</span> <span class="p_context"> static void vmx_vcpu_pi_load(struct kvm_vcpu *vcpu, int cpu)</span>
 
 		/* Allow posting non-urgent interrupts */
 		new.sn = 0;
<span class="p_del">-	} while (cmpxchg(&amp;pi_desc-&gt;control, old.control,</span>
<span class="p_del">-			new.control) != old.control);</span>
<span class="p_add">+	} while (cmpxchg64(&amp;pi_desc-&gt;control, old.control,</span>
<span class="p_add">+			   new.control) != old.control);</span>
 }
 /*
  * Switches to specified vcpu, until a matching vcpu_put(), but assumes
<span class="p_chunk">@@ -4541,21 +4541,30 @@</span> <span class="p_context"> static inline bool kvm_vcpu_trigger_posted_interrupt(struct kvm_vcpu *vcpu)</span>
 {
 #ifdef CONFIG_SMP
 	if (vcpu-&gt;mode == IN_GUEST_MODE) {
<span class="p_del">-		struct vcpu_vmx *vmx = to_vmx(vcpu);</span>
<span class="p_del">-</span>
 		/*
<span class="p_del">-		 * Currently, we don&#39;t support urgent interrupt,</span>
<span class="p_del">-		 * all interrupts are recognized as non-urgent</span>
<span class="p_del">-		 * interrupt, so we cannot post interrupts when</span>
<span class="p_del">-		 * &#39;SN&#39; is set.</span>
<span class="p_add">+		 * The vector of interrupt to be delivered to vcpu had</span>
<span class="p_add">+		 * been set in PIR before this function.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Following cases will be reached in this block, and</span>
<span class="p_add">+		 * we always send a notification event in all cases as</span>
<span class="p_add">+		 * explained below.</span>
 		 *
<span class="p_del">-		 * If the vcpu is in guest mode, it means it is</span>
<span class="p_del">-		 * running instead of being scheduled out and</span>
<span class="p_del">-		 * waiting in the run queue, and that&#39;s the only</span>
<span class="p_del">-		 * case when &#39;SN&#39; is set currently, warning if</span>
<span class="p_del">-		 * &#39;SN&#39; is set.</span>
<span class="p_add">+		 * Case 1: vcpu keeps in non-root mode. Sending a</span>
<span class="p_add">+		 * notification event posts the interrupt to vcpu.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Case 2: vcpu exits to root mode and is still</span>
<span class="p_add">+		 * runnable. PIR will be synced to vIRR before the</span>
<span class="p_add">+		 * next vcpu entry. Sending a notification event in</span>
<span class="p_add">+		 * this case has no effect, as vcpu is not in root</span>
<span class="p_add">+		 * mode.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Case 3: vcpu exits to root mode and is blocked.</span>
<span class="p_add">+		 * vcpu_block() has already synced PIR to vIRR and</span>
<span class="p_add">+		 * never blocks vcpu if vIRR is not cleared. Therefore,</span>
<span class="p_add">+		 * a blocked vcpu here does not wait for any requested</span>
<span class="p_add">+		 * interrupts in PIR, and sending a notification event</span>
<span class="p_add">+		 * which has no effect is safe here.</span>
 		 */
<span class="p_del">-		WARN_ON_ONCE(pi_test_sn(&amp;vmx-&gt;pi_desc));</span>
 
 		apic-&gt;send_IPI_mask(get_cpu_mask(vcpu-&gt;cpu),
 				POSTED_INTR_VECTOR);
<span class="p_chunk">@@ -9683,6 +9692,11 @@</span> <span class="p_context"> static void prepare_vmcs02(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)</span>
 		vmcs_write64(VIRTUAL_APIC_PAGE_ADDR,
 				page_to_phys(vmx-&gt;nested.virtual_apic_page));
 		vmcs_write32(TPR_THRESHOLD, vmcs12-&gt;tpr_threshold);
<span class="p_add">+	} else {</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+		exec_control |= CPU_BASED_CR8_LOAD_EXITING |</span>
<span class="p_add">+				CPU_BASED_CR8_STORE_EXITING;</span>
<span class="p_add">+#endif</span>
 	}
 
 	if (cpu_has_vmx_msr_bitmap() &amp;&amp;
<span class="p_chunk">@@ -10691,8 +10705,8 @@</span> <span class="p_context"> static int vmx_pre_block(struct kvm_vcpu *vcpu)</span>
 
 		/* set &#39;NV&#39; to &#39;wakeup vector&#39; */
 		new.nv = POSTED_INTR_WAKEUP_VECTOR;
<span class="p_del">-	} while (cmpxchg(&amp;pi_desc-&gt;control, old.control,</span>
<span class="p_del">-			new.control) != old.control);</span>
<span class="p_add">+	} while (cmpxchg64(&amp;pi_desc-&gt;control, old.control,</span>
<span class="p_add">+			   new.control) != old.control);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -10723,8 +10737,8 @@</span> <span class="p_context"> static void vmx_post_block(struct kvm_vcpu *vcpu)</span>
 
 		/* set &#39;NV&#39; to &#39;notification vector&#39; */
 		new.nv = POSTED_INTR_VECTOR;
<span class="p_del">-	} while (cmpxchg(&amp;pi_desc-&gt;control, old.control,</span>
<span class="p_del">-			new.control) != old.control);</span>
<span class="p_add">+	} while (cmpxchg64(&amp;pi_desc-&gt;control, old.control,</span>
<span class="p_add">+			   new.control) != old.control);</span>
 
 	if(vcpu-&gt;pre_pcpu != -1) {
 		spin_lock_irqsave(
<span class="p_chunk">@@ -10755,7 +10769,7 @@</span> <span class="p_context"> static int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq,</span>
 	struct kvm_lapic_irq irq;
 	struct kvm_vcpu *vcpu;
 	struct vcpu_data vcpu_info;
<span class="p_del">-	int idx, ret = -EINVAL;</span>
<span class="p_add">+	int idx, ret = 0;</span>
 
 	if (!kvm_arch_has_assigned_device(kvm) ||
 		!irq_remapping_cap(IRQ_POSTING_CAP))
<span class="p_chunk">@@ -10763,7 +10777,12 @@</span> <span class="p_context"> static int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq,</span>
 
 	idx = srcu_read_lock(&amp;kvm-&gt;irq_srcu);
 	irq_rt = srcu_dereference(kvm-&gt;irq_routing, &amp;kvm-&gt;irq_srcu);
<span class="p_del">-	BUG_ON(guest_irq &gt;= irq_rt-&gt;nr_rt_entries);</span>
<span class="p_add">+	if (guest_irq &gt;= irq_rt-&gt;nr_rt_entries ||</span>
<span class="p_add">+	    hlist_empty(&amp;irq_rt-&gt;map[guest_irq])) {</span>
<span class="p_add">+		pr_warn_once(&quot;no route for guest_irq %u/%u (broken user space?)\n&quot;,</span>
<span class="p_add">+			     guest_irq, irq_rt-&gt;nr_rt_entries);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 	hlist_for_each_entry(e, &amp;irq_rt-&gt;map[guest_irq], link) {
 		if (e-&gt;type != KVM_IRQ_ROUTING_MSI)
<span class="p_chunk">@@ -10793,12 +10812,8 @@</span> <span class="p_context"> static int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq,</span>
 
 		if (set)
 			ret = irq_set_vcpu_affinity(host_irq, &amp;vcpu_info);
<span class="p_del">-		else {</span>
<span class="p_del">-			/* suppress notification event before unposting */</span>
<span class="p_del">-			pi_set_sn(vcpu_to_pi_desc(vcpu));</span>
<span class="p_add">+		else</span>
 			ret = irq_set_vcpu_affinity(host_irq, NULL);
<span class="p_del">-			pi_clear_sn(vcpu_to_pi_desc(vcpu));</span>
<span class="p_del">-		}</span>
 
 		if (ret &lt; 0) {
 			printk(KERN_INFO &quot;%s: failed to update PI IRTE\n&quot;,
<span class="p_header">diff --git a/block/bsg-lib.c b/block/bsg-lib.c</span>
<span class="p_header">index 650f427d915b..341b8d858e67 100644</span>
<span class="p_header">--- a/block/bsg-lib.c</span>
<span class="p_header">+++ b/block/bsg-lib.c</span>
<span class="p_chunk">@@ -147,7 +147,6 @@</span> <span class="p_context"> static int bsg_create_job(struct device *dev, struct request *req)</span>
 failjob_rls_rqst_payload:
 	kfree(job-&gt;request_payload.sg_list);
 failjob_rls_job:
<span class="p_del">-	kfree(job);</span>
 	return -ENOMEM;
 }
 
<span class="p_header">diff --git a/drivers/crypto/talitos.c b/drivers/crypto/talitos.c</span>
<span class="p_header">index 6a60936b46e0..62ce93568e11 100644</span>
<span class="p_header">--- a/drivers/crypto/talitos.c</span>
<span class="p_header">+++ b/drivers/crypto/talitos.c</span>
<span class="p_chunk">@@ -1749,9 +1749,9 @@</span> <span class="p_context"> static int common_nonsnoop_hash(struct talitos_edesc *edesc,</span>
 		req_ctx-&gt;swinit = 0;
 	} else {
 		desc-&gt;ptr[1] = zero_entry;
<span class="p_del">-		/* Indicate next op is not the first. */</span>
<span class="p_del">-		req_ctx-&gt;first = 0;</span>
 	}
<span class="p_add">+	/* Indicate next op is not the first. */</span>
<span class="p_add">+	req_ctx-&gt;first = 0;</span>
 
 	/* HMAC key */
 	if (ctx-&gt;keylen)
<span class="p_chunk">@@ -2770,7 +2770,8 @@</span> <span class="p_context"> static struct talitos_crypto_alg *talitos_alg_alloc(struct device *dev,</span>
 		t_alg-&gt;algt.alg.hash.final = ahash_final;
 		t_alg-&gt;algt.alg.hash.finup = ahash_finup;
 		t_alg-&gt;algt.alg.hash.digest = ahash_digest;
<span class="p_del">-		t_alg-&gt;algt.alg.hash.setkey = ahash_setkey;</span>
<span class="p_add">+		if (!strncmp(alg-&gt;cra_name, &quot;hmac&quot;, 4))</span>
<span class="p_add">+			t_alg-&gt;algt.alg.hash.setkey = ahash_setkey;</span>
 		t_alg-&gt;algt.alg.hash.import = ahash_import;
 		t_alg-&gt;algt.alg.hash.export = ahash_export;
 
<span class="p_header">diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c</span>
<span class="p_header">index 5eac08ffc697..d55bf85b76ce 100644</span>
<span class="p_header">--- a/drivers/md/raid5.c</span>
<span class="p_header">+++ b/drivers/md/raid5.c</span>
<span class="p_chunk">@@ -818,6 +818,14 @@</span> <span class="p_context"> static void stripe_add_to_batch_list(struct r5conf *conf, struct stripe_head *sh</span>
 			spin_unlock(&amp;head-&gt;batch_head-&gt;batch_lock);
 			goto unlock_out;
 		}
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We must assign batch_head of this stripe within the</span>
<span class="p_add">+		 * batch_lock, otherwise clear_batch_ready of batch head</span>
<span class="p_add">+		 * stripe could clear BATCH_READY bit of this stripe and</span>
<span class="p_add">+		 * this stripe-&gt;batch_head doesn&#39;t get assigned, which</span>
<span class="p_add">+		 * could confuse clear_batch_ready for this stripe</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		sh-&gt;batch_head = head-&gt;batch_head;</span>
 
 		/*
 		 * at this point, head&#39;s BATCH_READY could be cleared, but we
<span class="p_chunk">@@ -825,8 +833,6 @@</span> <span class="p_context"> static void stripe_add_to_batch_list(struct r5conf *conf, struct stripe_head *sh</span>
 		 */
 		list_add(&amp;sh-&gt;batch_list, &amp;head-&gt;batch_list);
 		spin_unlock(&amp;head-&gt;batch_head-&gt;batch_lock);
<span class="p_del">-</span>
<span class="p_del">-		sh-&gt;batch_head = head-&gt;batch_head;</span>
 	} else {
 		head-&gt;batch_head = head;
 		sh-&gt;batch_head = head-&gt;batch_head;
<span class="p_chunk">@@ -4258,7 +4264,8 @@</span> <span class="p_context"> static void break_stripe_batch_list(struct stripe_head *head_sh,</span>
 
 		set_mask_bits(&amp;sh-&gt;state, ~(STRIPE_EXPAND_SYNC_FLAGS |
 					    (1 &lt;&lt; STRIPE_PREREAD_ACTIVE) |
<span class="p_del">-					    (1 &lt;&lt; STRIPE_DEGRADED)),</span>
<span class="p_add">+					    (1 &lt;&lt; STRIPE_DEGRADED) |</span>
<span class="p_add">+					    (1 &lt;&lt; STRIPE_ON_UNPLUG_LIST)),</span>
 			      head_sh-&gt;state &amp; (1 &lt;&lt; STRIPE_INSYNC));
 
 		sh-&gt;check_state = head_sh-&gt;check_state;
<span class="p_header">diff --git a/drivers/misc/cxl/api.c b/drivers/misc/cxl/api.c</span>
<span class="p_header">index ea3eeb7011e1..690eb1a18caf 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/api.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/api.c</span>
<span class="p_chunk">@@ -176,6 +176,10 @@</span> <span class="p_context"> int cxl_start_context(struct cxl_context *ctx, u64 wed,</span>
 		kernel = false;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Increment driver use count. Enables global TLBIs for hash</span>
<span class="p_add">+	 * and callbacks to handle the segment table</span>
<span class="p_add">+	 */</span>
 	cxl_ctx_get();
 
 	if ((rc = cxl_attach_process(ctx, kernel, wed , 0))) {
<span class="p_header">diff --git a/drivers/misc/cxl/file.c b/drivers/misc/cxl/file.c</span>
<span class="p_header">index 10a02934bfc0..013558f4da4f 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/file.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/file.c</span>
<span class="p_chunk">@@ -94,7 +94,6 @@</span> <span class="p_context"> static int __afu_open(struct inode *inode, struct file *file, bool master)</span>
 
 	pr_devel(&quot;afu_open pe: %i\n&quot;, ctx-&gt;pe);
 	file-&gt;private_data = ctx;
<span class="p_del">-	cxl_ctx_get();</span>
 
 	/* indicate success */
 	rc = 0;
<span class="p_chunk">@@ -205,11 +204,18 @@</span> <span class="p_context"> static long afu_ioctl_start_work(struct cxl_context *ctx,</span>
 	ctx-&gt;pid = get_task_pid(current, PIDTYPE_PID);
 	ctx-&gt;glpid = get_task_pid(current-&gt;group_leader, PIDTYPE_PID);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Increment driver use count. Enables global TLBIs for hash</span>
<span class="p_add">+	 * and callbacks to handle the segment table</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	cxl_ctx_get();</span>
<span class="p_add">+</span>
 	trace_cxl_attach(ctx, work.work_element_descriptor, work.num_interrupts, amr);
 
 	if ((rc = cxl_attach_process(ctx, false, work.work_element_descriptor,
 				     amr))) {
 		afu_release_irqs(ctx, ctx);
<span class="p_add">+		cxl_ctx_put();</span>
 		goto out;
 	}
 
<span class="p_header">diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c</span>
<span class="p_header">index f8b2b5987ea9..ec91cd17bf34 100644</span>
<span class="p_header">--- a/drivers/pci/pci-sysfs.c</span>
<span class="p_header">+++ b/drivers/pci/pci-sysfs.c</span>
<span class="p_chunk">@@ -522,7 +522,7 @@</span> <span class="p_context"> static ssize_t driver_override_store(struct device *dev,</span>
 				     const char *buf, size_t count)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
<span class="p_del">-	char *driver_override, *old = pdev-&gt;driver_override, *cp;</span>
<span class="p_add">+	char *driver_override, *old, *cp;</span>
 
 	/* We need to keep extra room for a newline */
 	if (count &gt;= (PAGE_SIZE - 1))
<span class="p_chunk">@@ -536,12 +536,15 @@</span> <span class="p_context"> static ssize_t driver_override_store(struct device *dev,</span>
 	if (cp)
 		*cp = &#39;\0&#39;;
 
<span class="p_add">+	device_lock(dev);</span>
<span class="p_add">+	old = pdev-&gt;driver_override;</span>
 	if (strlen(driver_override)) {
 		pdev-&gt;driver_override = driver_override;
 	} else {
 		kfree(driver_override);
 		pdev-&gt;driver_override = NULL;
 	}
<span class="p_add">+	device_unlock(dev);</span>
 
 	kfree(old);
 
<span class="p_chunk">@@ -552,8 +555,12 @@</span> <span class="p_context"> static ssize_t driver_override_show(struct device *dev,</span>
 				    struct device_attribute *attr, char *buf)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
<span class="p_add">+	ssize_t len;</span>
 
<span class="p_del">-	return snprintf(buf, PAGE_SIZE, &quot;%s\n&quot;, pdev-&gt;driver_override);</span>
<span class="p_add">+	device_lock(dev);</span>
<span class="p_add">+	len = snprintf(buf, PAGE_SIZE, &quot;%s\n&quot;, pdev-&gt;driver_override);</span>
<span class="p_add">+	device_unlock(dev);</span>
<span class="p_add">+	return len;</span>
 }
 static DEVICE_ATTR_RW(driver_override);
 
<span class="p_header">diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c</span>
<span class="p_header">index e4b3d8f4fd85..bb4ed7b1f5df 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_transport_iscsi.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_transport_iscsi.c</span>
<span class="p_chunk">@@ -3697,7 +3697,7 @@</span> <span class="p_context"> iscsi_if_rx(struct sk_buff *skb)</span>
 		uint32_t group;
 
 		nlh = nlmsg_hdr(skb);
<span class="p_del">-		if (nlh-&gt;nlmsg_len &lt; sizeof(*nlh) ||</span>
<span class="p_add">+		if (nlh-&gt;nlmsg_len &lt; sizeof(*nlh) + sizeof(*ev) ||</span>
 		    skb-&gt;len &lt; nlh-&gt;nlmsg_len) {
 			break;
 		}
<span class="p_header">diff --git a/drivers/video/fbdev/aty/atyfb_base.c b/drivers/video/fbdev/aty/atyfb_base.c</span>
<span class="p_header">index f34ed47fcaf8..7f658fa4d22a 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/aty/atyfb_base.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/aty/atyfb_base.c</span>
<span class="p_chunk">@@ -1861,7 +1861,7 @@</span> <span class="p_context"> static int atyfb_ioctl(struct fb_info *info, u_int cmd, u_long arg)</span>
 #if defined(DEBUG) &amp;&amp; defined(CONFIG_FB_ATY_CT)
 	case ATYIO_CLKR:
 		if (M64_HAS(INTEGRATED)) {
<span class="p_del">-			struct atyclk clk;</span>
<span class="p_add">+			struct atyclk clk = { 0 };</span>
 			union aty_pll *pll = &amp;par-&gt;pll;
 			u32 dsp_config = pll-&gt;ct.dsp_config;
 			u32 dsp_on_off = pll-&gt;ct.dsp_on_off;
<span class="p_header">diff --git a/drivers/xen/swiotlb-xen.c b/drivers/xen/swiotlb-xen.c</span>
<span class="p_header">index 8a58bbc14de2..f7b19c25c3a4 100644</span>
<span class="p_header">--- a/drivers/xen/swiotlb-xen.c</span>
<span class="p_header">+++ b/drivers/xen/swiotlb-xen.c</span>
<span class="p_chunk">@@ -680,3 +680,22 @@</span> <span class="p_context"> xen_swiotlb_set_dma_mask(struct device *dev, u64 dma_mask)</span>
 	return 0;
 }
 EXPORT_SYMBOL_GPL(xen_swiotlb_set_dma_mask);
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Create userspace mapping for the DMA-coherent memory.</span>
<span class="p_add">+ * This function should be called with the pages from the current domain only,</span>
<span class="p_add">+ * passing pages mapped from other domains would lead to memory corruption.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int</span>
<span class="p_add">+xen_swiotlb_dma_mmap(struct device *dev, struct vm_area_struct *vma,</span>
<span class="p_add">+		     void *cpu_addr, dma_addr_t dma_addr, size_t size,</span>
<span class="p_add">+		     struct dma_attrs *attrs)</span>
<span class="p_add">+{</span>
<span class="p_add">+#if defined(CONFIG_ARM) || defined(CONFIG_ARM64)</span>
<span class="p_add">+	if (__generic_dma_ops(dev)-&gt;mmap)</span>
<span class="p_add">+		return __generic_dma_ops(dev)-&gt;mmap(dev, vma, cpu_addr,</span>
<span class="p_add">+						    dma_addr, size, attrs);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	return dma_common_mmap(dev, vma, cpu_addr, dma_addr, size);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(xen_swiotlb_dma_mmap);</span>
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index 317b99acdf4b..9c3b9d07f341 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -2984,7 +2984,7 @@</span> <span class="p_context"> static int btrfs_cmp_data_prepare(struct inode *src, u64 loff,</span>
 out:
 	if (ret)
 		btrfs_cmp_data_free(cmp);
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int btrfs_cmp_data(struct inode *src, u64 loff, struct inode *dst,
<span class="p_chunk">@@ -4118,6 +4118,10 @@</span> <span class="p_context"> static long btrfs_ioctl_default_subvol(struct file *file, void __user *argp)</span>
 		ret = PTR_ERR(new_root);
 		goto out;
 	}
<span class="p_add">+	if (!is_fstree(new_root-&gt;objectid)) {</span>
<span class="p_add">+		ret = -ENOENT;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 	path = btrfs_alloc_path();
 	if (!path) {
<span class="p_header">diff --git a/fs/btrfs/relocation.c b/fs/btrfs/relocation.c</span>
<span class="p_header">index 8ca9aa92972d..9ebe027cc4b7 100644</span>
<span class="p_header">--- a/fs/btrfs/relocation.c</span>
<span class="p_header">+++ b/fs/btrfs/relocation.c</span>
<span class="p_chunk">@@ -2350,11 +2350,11 @@</span> <span class="p_context"> void free_reloc_roots(struct list_head *list)</span>
 	while (!list_empty(list)) {
 		reloc_root = list_entry(list-&gt;next, struct btrfs_root,
 					root_list);
<span class="p_add">+		__del_reloc_root(reloc_root);</span>
 		free_extent_buffer(reloc_root-&gt;node);
 		free_extent_buffer(reloc_root-&gt;commit_root);
 		reloc_root-&gt;node = NULL;
 		reloc_root-&gt;commit_root = NULL;
<span class="p_del">-		__del_reloc_root(reloc_root);</span>
 	}
 }
 
<span class="p_header">diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c</span>
<span class="p_header">index 53a827c6d8b1..b377aa8f266f 100644</span>
<span class="p_header">--- a/fs/cifs/connect.c</span>
<span class="p_header">+++ b/fs/cifs/connect.c</span>
<span class="p_chunk">@@ -4060,6 +4060,14 @@</span> <span class="p_context"> cifs_setup_session(const unsigned int xid, struct cifs_ses *ses,</span>
 	cifs_dbg(FYI, &quot;Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\n&quot;,
 		 server-&gt;sec_mode, server-&gt;capabilities, server-&gt;timeAdj);
 
<span class="p_add">+	if (ses-&gt;auth_key.response) {</span>
<span class="p_add">+		cifs_dbg(VFS, &quot;Free previous auth_key.response = %p\n&quot;,</span>
<span class="p_add">+			 ses-&gt;auth_key.response);</span>
<span class="p_add">+		kfree(ses-&gt;auth_key.response);</span>
<span class="p_add">+		ses-&gt;auth_key.response = NULL;</span>
<span class="p_add">+		ses-&gt;auth_key.len = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (server-&gt;ops-&gt;sess_setup)
 		rc = server-&gt;ops-&gt;sess_setup(xid, ses, nls_info);
 
<span class="p_header">diff --git a/fs/cifs/file.c b/fs/cifs/file.c</span>
<span class="p_header">index a0c0a49b6620..ec2d07bb9beb 100644</span>
<span class="p_header">--- a/fs/cifs/file.c</span>
<span class="p_header">+++ b/fs/cifs/file.c</span>
<span class="p_chunk">@@ -224,6 +224,13 @@</span> <span class="p_context"> cifs_nt_open(char *full_path, struct inode *inode, struct cifs_sb_info *cifs_sb,</span>
 	if (backup_cred(cifs_sb))
 		create_options |= CREATE_OPEN_BACKUP_INTENT;
 
<span class="p_add">+	/* O_SYNC also has bit for O_DSYNC so following check picks up either */</span>
<span class="p_add">+	if (f_flags &amp; O_SYNC)</span>
<span class="p_add">+		create_options |= CREATE_WRITE_THROUGH;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (f_flags &amp; O_DIRECT)</span>
<span class="p_add">+		create_options |= CREATE_NO_BUFFER;</span>
<span class="p_add">+</span>
 	oparms.tcon = tcon;
 	oparms.cifs_sb = cifs_sb;
 	oparms.desired_access = desired_access;
<span class="p_header">diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c</span>
<span class="p_header">index 6c484ddf26a9..f2ff60e58ec8 100644</span>
<span class="p_header">--- a/fs/cifs/smb2pdu.c</span>
<span class="p_header">+++ b/fs/cifs/smb2pdu.c</span>
<span class="p_chunk">@@ -361,7 +361,7 @@</span> <span class="p_context"> assemble_neg_contexts(struct smb2_negotiate_req *req)</span>
 	build_encrypt_ctxt((struct smb2_encryption_neg_context *)pneg_ctxt);
 	req-&gt;NegotiateContextOffset = cpu_to_le32(OFFSET_OF_NEG_CONTEXT);
 	req-&gt;NegotiateContextCount = cpu_to_le16(2);
<span class="p_del">-	inc_rfc1001_len(req, 4 + sizeof(struct smb2_preauth_neg_context) + 2</span>
<span class="p_add">+	inc_rfc1001_len(req, 4 + sizeof(struct smb2_preauth_neg_context)</span>
 			+ sizeof(struct smb2_encryption_neg_context)); /* calculate hash */
 }
 #else
<span class="p_chunk">@@ -526,15 +526,22 @@</span> <span class="p_context"> int smb3_validate_negotiate(const unsigned int xid, struct cifs_tcon *tcon)</span>
 
 	/*
 	 * validation ioctl must be signed, so no point sending this if we
<span class="p_del">-	 * can not sign it.  We could eventually change this to selectively</span>
<span class="p_add">+	 * can not sign it (ie are not known user).  Even if signing is not</span>
<span class="p_add">+	 * required (enabled but not negotiated), in those cases we selectively</span>
 	 * sign just this, the first and only signed request on a connection.
<span class="p_del">-	 * This is good enough for now since a user who wants better security</span>
<span class="p_del">-	 * would also enable signing on the mount. Having validation of</span>
<span class="p_del">-	 * negotiate info for signed connections helps reduce attack vectors</span>
<span class="p_add">+	 * Having validation of negotiate info  helps reduce attack vectors.</span>
 	 */
<span class="p_del">-	if (tcon-&gt;ses-&gt;server-&gt;sign == false)</span>
<span class="p_add">+	if (tcon-&gt;ses-&gt;session_flags &amp; SMB2_SESSION_FLAG_IS_GUEST)</span>
 		return 0; /* validation requires signing */
 
<span class="p_add">+	if (tcon-&gt;ses-&gt;user_name == NULL) {</span>
<span class="p_add">+		cifs_dbg(FYI, &quot;Can&#39;t validate negotiate: null user mount\n&quot;);</span>
<span class="p_add">+		return 0; /* validation requires signing */</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tcon-&gt;ses-&gt;session_flags &amp; SMB2_SESSION_FLAG_IS_NULL)</span>
<span class="p_add">+		cifs_dbg(VFS, &quot;Unexpected null user (anonymous) auth flag sent by server\n&quot;);</span>
<span class="p_add">+</span>
 	vneg_inbuf.Capabilities =
 			cpu_to_le32(tcon-&gt;ses-&gt;server-&gt;vals-&gt;req_capabilities);
 	memcpy(vneg_inbuf.Guid, tcon-&gt;ses-&gt;server-&gt;client_guid,
<span class="p_header">diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.c</span>
<span class="p_header">index 070901e76653..ff36f5475d7e 100644</span>
<span class="p_header">--- a/fs/gfs2/glock.c</span>
<span class="p_header">+++ b/fs/gfs2/glock.c</span>
<span class="p_chunk">@@ -1814,13 +1814,10 @@</span> <span class="p_context"> static void *gfs2_glock_seq_start(struct seq_file *seq, loff_t *pos)</span>
 {
 	struct gfs2_glock_iter *gi = seq-&gt;private;
 	loff_t n = *pos;
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (gi-&gt;last_pos &lt;= *pos)</span>
<span class="p_del">-		n = (*pos - gi-&gt;last_pos);</span>
 
<span class="p_del">-	ret = rhashtable_walk_start(&amp;gi-&gt;hti);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (rhashtable_walk_init(&amp;gl_hash_table, &amp;gi-&gt;hti) != 0)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	if (rhashtable_walk_start(&amp;gi-&gt;hti) != 0)</span>
 		return NULL;
 
 	do {
<span class="p_chunk">@@ -1828,6 +1825,7 @@</span> <span class="p_context"> static void *gfs2_glock_seq_start(struct seq_file *seq, loff_t *pos)</span>
 	} while (gi-&gt;gl &amp;&amp; n--);
 
 	gi-&gt;last_pos = *pos;
<span class="p_add">+</span>
 	return gi-&gt;gl;
 }
 
<span class="p_chunk">@@ -1839,6 +1837,7 @@</span> <span class="p_context"> static void *gfs2_glock_seq_next(struct seq_file *seq, void *iter_ptr,</span>
 	(*pos)++;
 	gi-&gt;last_pos = *pos;
 	gfs2_glock_iter_next(gi);
<span class="p_add">+</span>
 	return gi-&gt;gl;
 }
 
<span class="p_chunk">@@ -1847,7 +1846,10 @@</span> <span class="p_context"> static void gfs2_glock_seq_stop(struct seq_file *seq, void *iter_ptr)</span>
 	struct gfs2_glock_iter *gi = seq-&gt;private;
 
 	gi-&gt;gl = NULL;
<span class="p_del">-	rhashtable_walk_stop(&amp;gi-&gt;hti);</span>
<span class="p_add">+	if (gi-&gt;hti.walker) {</span>
<span class="p_add">+		rhashtable_walk_stop(&amp;gi-&gt;hti);</span>
<span class="p_add">+		rhashtable_walk_exit(&amp;gi-&gt;hti);</span>
<span class="p_add">+	}</span>
 }
 
 static int gfs2_glock_seq_show(struct seq_file *seq, void *iter_ptr)
<span class="p_chunk">@@ -1910,12 +1912,10 @@</span> <span class="p_context"> static int gfs2_glocks_open(struct inode *inode, struct file *file)</span>
 		struct gfs2_glock_iter *gi = seq-&gt;private;
 
 		gi-&gt;sdp = inode-&gt;i_private;
<span class="p_del">-		gi-&gt;last_pos = 0;</span>
 		seq-&gt;buf = kmalloc(GFS2_SEQ_GOODSIZE, GFP_KERNEL | __GFP_NOWARN);
 		if (seq-&gt;buf)
 			seq-&gt;size = GFS2_SEQ_GOODSIZE;
 		gi-&gt;gl = NULL;
<span class="p_del">-		ret = rhashtable_walk_init(&amp;gl_hash_table, &amp;gi-&gt;hti);</span>
 	}
 	return ret;
 }
<span class="p_chunk">@@ -1926,7 +1926,6 @@</span> <span class="p_context"> static int gfs2_glocks_release(struct inode *inode, struct file *file)</span>
 	struct gfs2_glock_iter *gi = seq-&gt;private;
 
 	gi-&gt;gl = NULL;
<span class="p_del">-	rhashtable_walk_exit(&amp;gi-&gt;hti);</span>
 	return seq_release_private(inode, file);
 }
 
<span class="p_chunk">@@ -1938,12 +1937,10 @@</span> <span class="p_context"> static int gfs2_glstats_open(struct inode *inode, struct file *file)</span>
 		struct seq_file *seq = file-&gt;private_data;
 		struct gfs2_glock_iter *gi = seq-&gt;private;
 		gi-&gt;sdp = inode-&gt;i_private;
<span class="p_del">-		gi-&gt;last_pos = 0;</span>
 		seq-&gt;buf = kmalloc(GFS2_SEQ_GOODSIZE, GFP_KERNEL | __GFP_NOWARN);
 		if (seq-&gt;buf)
 			seq-&gt;size = GFS2_SEQ_GOODSIZE;
 		gi-&gt;gl = NULL;
<span class="p_del">-		ret = rhashtable_walk_init(&amp;gl_hash_table, &amp;gi-&gt;hti);</span>
 	}
 	return ret;
 }
<span class="p_header">diff --git a/fs/read_write.c b/fs/read_write.c</span>
<span class="p_header">index 819ef3faf1bb..bfd1a5dddf6e 100644</span>
<span class="p_header">--- a/fs/read_write.c</span>
<span class="p_header">+++ b/fs/read_write.c</span>
<span class="p_chunk">@@ -112,7 +112,7 @@</span> <span class="p_context"> generic_file_llseek_size(struct file *file, loff_t offset, int whence,</span>
 		 * In the generic case the entire file is data, so as long as
 		 * offset isn&#39;t at the end of the file then the offset is data.
 		 */
<span class="p_del">-		if (offset &gt;= eof)</span>
<span class="p_add">+		if ((unsigned long long)offset &gt;= eof)</span>
 			return -ENXIO;
 		break;
 	case SEEK_HOLE:
<span class="p_chunk">@@ -120,7 +120,7 @@</span> <span class="p_context"> generic_file_llseek_size(struct file *file, loff_t offset, int whence,</span>
 		 * There is a virtual hole at the end of the file, so as long as
 		 * offset isn&#39;t i_size or larger, return i_size.
 		 */
<span class="p_del">-		if (offset &gt;= eof)</span>
<span class="p_add">+		if ((unsigned long long)offset &gt;= eof)</span>
 			return -ENXIO;
 		offset = eof;
 		break;
<span class="p_header">diff --git a/include/linux/key.h b/include/linux/key.h</span>
<span class="p_header">index 66f705243985..dcc115e8dd03 100644</span>
<span class="p_header">--- a/include/linux/key.h</span>
<span class="p_header">+++ b/include/linux/key.h</span>
<span class="p_chunk">@@ -177,6 +177,7 @@</span> <span class="p_context"> struct key {</span>
 #define KEY_FLAG_TRUSTED_ONLY	9	/* set if keyring only accepts links to trusted keys */
 #define KEY_FLAG_BUILTIN	10	/* set if key is builtin */
 #define KEY_FLAG_ROOT_CAN_INVAL	11	/* set if key can be invalidated by root without permission */
<span class="p_add">+#define KEY_FLAG_UID_KEYRING	12	/* set if key is a user or user session keyring */</span>
 
 	/* the key type and key description string
 	 * - the desc is used to match a key against search criteria
<span class="p_chunk">@@ -218,6 +219,7 @@</span> <span class="p_context"> extern struct key *key_alloc(struct key_type *type,</span>
 #define KEY_ALLOC_QUOTA_OVERRUN	0x0001	/* add to quota, permit even if overrun */
 #define KEY_ALLOC_NOT_IN_QUOTA	0x0002	/* not in quota */
 #define KEY_ALLOC_TRUSTED	0x0004	/* Key should be flagged as trusted */
<span class="p_add">+#define KEY_ALLOC_UID_KEYRING	0x0010	/* allocating a user or user session keyring */</span>
 
 extern void key_revoke(struct key *key);
 extern void key_invalidate(struct key *key);
<span class="p_header">diff --git a/include/linux/platform_data/mmp_dma.h b/include/linux/platform_data/mmp_dma.h</span>
<span class="p_header">index 2a330ec9e2af..d1397c8ed94e 100644</span>
<span class="p_header">--- a/include/linux/platform_data/mmp_dma.h</span>
<span class="p_header">+++ b/include/linux/platform_data/mmp_dma.h</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"></span>
 
 struct mmp_dma_platdata {
 	int dma_channels;
<span class="p_add">+	int nb_requestors;</span>
 };
 
 #endif /* MMP_DMA_H */
<span class="p_header">diff --git a/include/xen/swiotlb-xen.h b/include/xen/swiotlb-xen.h</span>
<span class="p_header">index 8b2eb93ae8ba..4d7fdbf20eff 100644</span>
<span class="p_header">--- a/include/xen/swiotlb-xen.h</span>
<span class="p_header">+++ b/include/xen/swiotlb-xen.h</span>
<span class="p_chunk">@@ -58,4 +58,9 @@</span> <span class="p_context"> xen_swiotlb_dma_supported(struct device *hwdev, u64 mask);</span>
 
 extern int
 xen_swiotlb_set_dma_mask(struct device *dev, u64 dma_mask);
<span class="p_add">+</span>
<span class="p_add">+extern int</span>
<span class="p_add">+xen_swiotlb_dma_mmap(struct device *dev, struct vm_area_struct *vma,</span>
<span class="p_add">+		     void *cpu_addr, dma_addr_t dma_addr, size_t size,</span>
<span class="p_add">+		     struct dma_attrs *attrs);</span>
 #endif /* __LINUX_SWIOTLB_XEN_H */
<span class="p_header">diff --git a/kernel/seccomp.c b/kernel/seccomp.c</span>
<span class="p_header">index 15a1795bbba1..efd384f3f852 100644</span>
<span class="p_header">--- a/kernel/seccomp.c</span>
<span class="p_header">+++ b/kernel/seccomp.c</span>
<span class="p_chunk">@@ -457,14 +457,19 @@</span> <span class="p_context"> static long seccomp_attach_filter(unsigned int flags,</span>
 	return 0;
 }
 
<span class="p_add">+void __get_seccomp_filter(struct seccomp_filter *filter)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Reference count is bounded by the number of total processes. */</span>
<span class="p_add">+	atomic_inc(&amp;filter-&gt;usage);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* get_seccomp_filter - increments the reference count of the filter on @tsk */
 void get_seccomp_filter(struct task_struct *tsk)
 {
 	struct seccomp_filter *orig = tsk-&gt;seccomp.filter;
 	if (!orig)
 		return;
<span class="p_del">-	/* Reference count is bounded by the number of total processes. */</span>
<span class="p_del">-	atomic_inc(&amp;orig-&gt;usage);</span>
<span class="p_add">+	__get_seccomp_filter(orig);</span>
 }
 
 static inline void seccomp_filter_free(struct seccomp_filter *filter)
<span class="p_chunk">@@ -475,10 +480,8 @@</span> <span class="p_context"> static inline void seccomp_filter_free(struct seccomp_filter *filter)</span>
 	}
 }
 
<span class="p_del">-/* put_seccomp_filter - decrements the ref count of tsk-&gt;seccomp.filter */</span>
<span class="p_del">-void put_seccomp_filter(struct task_struct *tsk)</span>
<span class="p_add">+static void __put_seccomp_filter(struct seccomp_filter *orig)</span>
 {
<span class="p_del">-	struct seccomp_filter *orig = tsk-&gt;seccomp.filter;</span>
 	/* Clean up single-reference branches iteratively. */
 	while (orig &amp;&amp; atomic_dec_and_test(&amp;orig-&gt;usage)) {
 		struct seccomp_filter *freeme = orig;
<span class="p_chunk">@@ -487,6 +490,12 @@</span> <span class="p_context"> void put_seccomp_filter(struct task_struct *tsk)</span>
 	}
 }
 
<span class="p_add">+/* put_seccomp_filter - decrements the ref count of tsk-&gt;seccomp.filter */</span>
<span class="p_add">+void put_seccomp_filter(struct task_struct *tsk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__put_seccomp_filter(tsk-&gt;seccomp.filter);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * seccomp_send_sigsys - signals the task to allow in-process syscall emulation
  * @syscall: syscall number to send to userland
<span class="p_chunk">@@ -927,13 +936,13 @@</span> <span class="p_context"> long seccomp_get_filter(struct task_struct *task, unsigned long filter_off,</span>
 	if (!data)
 		goto out;
 
<span class="p_del">-	get_seccomp_filter(task);</span>
<span class="p_add">+	__get_seccomp_filter(filter);</span>
 	spin_unlock_irq(&amp;task-&gt;sighand-&gt;siglock);
 
 	if (copy_to_user(data, fprog-&gt;filter, bpf_classic_proglen(fprog)))
 		ret = -EFAULT;
 
<span class="p_del">-	put_seccomp_filter(task);</span>
<span class="p_add">+	__put_seccomp_filter(filter);</span>
 	return ret;
 
 out:
<span class="p_header">diff --git a/kernel/sysctl.c b/kernel/sysctl.c</span>
<span class="p_header">index 002ec084124b..17c59e78661b 100644</span>
<span class="p_header">--- a/kernel/sysctl.c</span>
<span class="p_header">+++ b/kernel/sysctl.c</span>
<span class="p_chunk">@@ -1159,6 +1159,8 @@</span> <span class="p_context"> static struct ctl_table kern_table[] = {</span>
 		.maxlen		= sizeof(unsigned int),
 		.mode		= 0644,
 		.proc_handler	= timer_migration_handler,
<span class="p_add">+		.extra1		= &amp;zero,</span>
<span class="p_add">+		.extra2		= &amp;one,</span>
 	},
 #endif
 #ifdef CONFIG_BPF_SYSCALL
<span class="p_header">diff --git a/kernel/time/timer.c b/kernel/time/timer.c</span>
<span class="p_header">index bbc5d1114583..125407144c01 100644</span>
<span class="p_header">--- a/kernel/time/timer.c</span>
<span class="p_header">+++ b/kernel/time/timer.c</span>
<span class="p_chunk">@@ -127,7 +127,7 @@</span> <span class="p_context"> int timer_migration_handler(struct ctl_table *table, int write,</span>
 	int ret;
 
 	mutex_lock(&amp;mutex);
<span class="p_del">-	ret = proc_dointvec(table, write, buffer, lenp, ppos);</span>
<span class="p_add">+	ret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);</span>
 	if (!ret &amp;&amp; write)
 		timers_update_migration(false);
 	mutex_unlock(&amp;mutex);
<span class="p_header">diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c</span>
<span class="p_header">index 4743066010c4..b64f35afee4e 100644</span>
<span class="p_header">--- a/kernel/trace/trace.c</span>
<span class="p_header">+++ b/kernel/trace/trace.c</span>
<span class="p_chunk">@@ -3226,11 +3226,17 @@</span> <span class="p_context"> static int tracing_open(struct inode *inode, struct file *file)</span>
 	/* If this file was open for write, then erase contents */
 	if ((file-&gt;f_mode &amp; FMODE_WRITE) &amp;&amp; (file-&gt;f_flags &amp; O_TRUNC)) {
 		int cpu = tracing_get_cpu(inode);
<span class="p_add">+		struct trace_buffer *trace_buf = &amp;tr-&gt;trace_buffer;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_TRACER_MAX_TRACE</span>
<span class="p_add">+		if (tr-&gt;current_trace-&gt;print_max)</span>
<span class="p_add">+			trace_buf = &amp;tr-&gt;max_buffer;</span>
<span class="p_add">+#endif</span>
 
 		if (cpu == RING_BUFFER_ALL_CPUS)
<span class="p_del">-			tracing_reset_online_cpus(&amp;tr-&gt;trace_buffer);</span>
<span class="p_add">+			tracing_reset_online_cpus(trace_buf);</span>
 		else
<span class="p_del">-			tracing_reset(&amp;tr-&gt;trace_buffer, cpu);</span>
<span class="p_add">+			tracing_reset(trace_buf, cpu);</span>
 	}
 
 	if (file-&gt;f_mode &amp; FMODE_READ) {
<span class="p_chunk">@@ -4701,7 +4707,7 @@</span> <span class="p_context"> static int tracing_wait_pipe(struct file *filp)</span>
 		 *
 		 * iter-&gt;pos will be 0 if we haven&#39;t read anything.
 		 */
<span class="p_del">-		if (!tracing_is_on() &amp;&amp; iter-&gt;pos)</span>
<span class="p_add">+		if (!tracer_tracing_is_on(iter-&gt;tr) &amp;&amp; iter-&gt;pos)</span>
 			break;
 
 		mutex_unlock(&amp;iter-&gt;mutex);
<span class="p_header">diff --git a/net/mac80211/offchannel.c b/net/mac80211/offchannel.c</span>
<span class="p_header">index 04401037140e..b6be51940ead 100644</span>
<span class="p_header">--- a/net/mac80211/offchannel.c</span>
<span class="p_header">+++ b/net/mac80211/offchannel.c</span>
<span class="p_chunk">@@ -469,6 +469,8 @@</span> <span class="p_context"> void ieee80211_roc_purge(struct ieee80211_local *local,</span>
 	struct ieee80211_roc_work *roc, *tmp;
 	LIST_HEAD(tmp_list);
 
<span class="p_add">+	flush_work(&amp;local-&gt;hw_roc_start);</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;local-&gt;mtx);
 	list_for_each_entry_safe(roc, tmp, &amp;local-&gt;roc_list, list) {
 		if (sdata &amp;&amp; roc-&gt;sdata != sdata)
<span class="p_header">diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c</span>
<span class="p_header">index de10e3c0e2a4..8ece212aa3d2 100644</span>
<span class="p_header">--- a/net/wireless/nl80211.c</span>
<span class="p_header">+++ b/net/wireless/nl80211.c</span>
<span class="p_chunk">@@ -9786,6 +9786,9 @@</span> <span class="p_context"> static int nl80211_set_rekey_data(struct sk_buff *skb, struct genl_info *info)</span>
 	if (err)
 		return err;
 
<span class="p_add">+	if (!tb[NL80211_REKEY_DATA_REPLAY_CTR] || !tb[NL80211_REKEY_DATA_KEK] ||</span>
<span class="p_add">+	    !tb[NL80211_REKEY_DATA_KCK])</span>
<span class="p_add">+		return -EINVAL;</span>
 	if (nla_len(tb[NL80211_REKEY_DATA_REPLAY_CTR]) != NL80211_REPLAY_CTR_LEN)
 		return -ERANGE;
 	if (nla_len(tb[NL80211_REKEY_DATA_KEK]) != NL80211_KEK_LEN)
<span class="p_header">diff --git a/security/keys/internal.h b/security/keys/internal.h</span>
<span class="p_header">index 5105c2c2da75..51ffb9cde073 100644</span>
<span class="p_header">--- a/security/keys/internal.h</span>
<span class="p_header">+++ b/security/keys/internal.h</span>
<span class="p_chunk">@@ -136,7 +136,7 @@</span> <span class="p_context"> extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,</span>
 extern key_ref_t search_my_process_keyrings(struct keyring_search_context *ctx);
 extern key_ref_t search_process_keyrings(struct keyring_search_context *ctx);
 
<span class="p_del">-extern struct key *find_keyring_by_name(const char *name, bool skip_perm_check);</span>
<span class="p_add">+extern struct key *find_keyring_by_name(const char *name, bool uid_keyring);</span>
 
 extern int install_user_keyrings(void);
 extern int install_thread_keyring_to_cred(struct cred *);
<span class="p_header">diff --git a/security/keys/key.c b/security/keys/key.c</span>
<span class="p_header">index 09c10b181881..51d23c623424 100644</span>
<span class="p_header">--- a/security/keys/key.c</span>
<span class="p_header">+++ b/security/keys/key.c</span>
<span class="p_chunk">@@ -296,6 +296,8 @@</span> <span class="p_context"> struct key *key_alloc(struct key_type *type, const char *desc,</span>
 		key-&gt;flags |= 1 &lt;&lt; KEY_FLAG_IN_QUOTA;
 	if (flags &amp; KEY_ALLOC_TRUSTED)
 		key-&gt;flags |= 1 &lt;&lt; KEY_FLAG_TRUSTED;
<span class="p_add">+	if (flags &amp; KEY_ALLOC_UID_KEYRING)</span>
<span class="p_add">+		key-&gt;flags |= 1 &lt;&lt; KEY_FLAG_UID_KEYRING;</span>
 
 #ifdef KEY_DEBUGGING
 	key-&gt;magic = KEY_DEBUG_MAGIC;
<span class="p_header">diff --git a/security/keys/keyctl.c b/security/keys/keyctl.c</span>
<span class="p_header">index 671709d8610d..a009dc66eb8f 100644</span>
<span class="p_header">--- a/security/keys/keyctl.c</span>
<span class="p_header">+++ b/security/keys/keyctl.c</span>
<span class="p_chunk">@@ -738,6 +738,11 @@</span> <span class="p_context"> long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)</span>
 
 	key = key_ref_to_ptr(key_ref);
 
<span class="p_add">+	if (test_bit(KEY_FLAG_NEGATIVE, &amp;key-&gt;flags)) {</span>
<span class="p_add">+		ret = -ENOKEY;</span>
<span class="p_add">+		goto error2;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* see if we can read it directly */
 	ret = key_permission(key_ref, KEY_NEED_READ);
 	if (ret == 0)
<span class="p_header">diff --git a/security/keys/keyring.c b/security/keys/keyring.c</span>
<span class="p_header">index f931ccfeefb0..0c8dd4fbe130 100644</span>
<span class="p_header">--- a/security/keys/keyring.c</span>
<span class="p_header">+++ b/security/keys/keyring.c</span>
<span class="p_chunk">@@ -416,7 +416,7 @@</span> <span class="p_context"> static void keyring_describe(const struct key *keyring, struct seq_file *m)</span>
 }
 
 struct keyring_read_iterator_context {
<span class="p_del">-	size_t			qty;</span>
<span class="p_add">+	size_t			buflen;</span>
 	size_t			count;
 	key_serial_t __user	*buffer;
 };
<span class="p_chunk">@@ -428,9 +428,9 @@</span> <span class="p_context"> static int keyring_read_iterator(const void *object, void *data)</span>
 	int ret;
 
 	kenter(&quot;{%s,%d},,{%zu/%zu}&quot;,
<span class="p_del">-	       key-&gt;type-&gt;name, key-&gt;serial, ctx-&gt;count, ctx-&gt;qty);</span>
<span class="p_add">+	       key-&gt;type-&gt;name, key-&gt;serial, ctx-&gt;count, ctx-&gt;buflen);</span>
 
<span class="p_del">-	if (ctx-&gt;count &gt;= ctx-&gt;qty)</span>
<span class="p_add">+	if (ctx-&gt;count &gt;= ctx-&gt;buflen)</span>
 		return 1;
 
 	ret = put_user(key-&gt;serial, ctx-&gt;buffer);
<span class="p_chunk">@@ -465,16 +465,12 @@</span> <span class="p_context"> static long keyring_read(const struct key *keyring,</span>
 		return 0;
 
 	/* Calculate how much data we could return */
<span class="p_del">-	ctx.qty = nr_keys * sizeof(key_serial_t);</span>
<span class="p_del">-</span>
 	if (!buffer || !buflen)
<span class="p_del">-		return ctx.qty;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (buflen &gt; ctx.qty)</span>
<span class="p_del">-		ctx.qty = buflen;</span>
<span class="p_add">+		return nr_keys * sizeof(key_serial_t);</span>
 
 	/* Copy the IDs of the subscribed keys into the buffer */
 	ctx.buffer = (key_serial_t __user *)buffer;
<span class="p_add">+	ctx.buflen = buflen;</span>
 	ctx.count = 0;
 	ret = assoc_array_iterate(&amp;keyring-&gt;keys, keyring_read_iterator, &amp;ctx);
 	if (ret &lt; 0) {
<span class="p_chunk">@@ -965,15 +961,15 @@</span> <span class="p_context"> found:</span>
 /*
  * Find a keyring with the specified name.
  *
<span class="p_del">- * All named keyrings in the current user namespace are searched, provided they</span>
<span class="p_del">- * grant Search permission directly to the caller (unless this check is</span>
<span class="p_del">- * skipped).  Keyrings whose usage points have reached zero or who have been</span>
<span class="p_del">- * revoked are skipped.</span>
<span class="p_add">+ * Only keyrings that have nonzero refcount, are not revoked, and are owned by a</span>
<span class="p_add">+ * user in the current user namespace are considered.  If @uid_keyring is %true,</span>
<span class="p_add">+ * the keyring additionally must have been allocated as a user or user session</span>
<span class="p_add">+ * keyring; otherwise, it must grant Search permission directly to the caller.</span>
  *
  * Returns a pointer to the keyring with the keyring&#39;s refcount having being
  * incremented on success.  -ENOKEY is returned if a key could not be found.
  */
<span class="p_del">-struct key *find_keyring_by_name(const char *name, bool skip_perm_check)</span>
<span class="p_add">+struct key *find_keyring_by_name(const char *name, bool uid_keyring)</span>
 {
 	struct key *keyring;
 	int bucket;
<span class="p_chunk">@@ -1001,10 +997,15 @@</span> <span class="p_context"> struct key *find_keyring_by_name(const char *name, bool skip_perm_check)</span>
 			if (strcmp(keyring-&gt;description, name) != 0)
 				continue;
 
<span class="p_del">-			if (!skip_perm_check &amp;&amp;</span>
<span class="p_del">-			    key_permission(make_key_ref(keyring, 0),</span>
<span class="p_del">-					   KEY_NEED_SEARCH) &lt; 0)</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+			if (uid_keyring) {</span>
<span class="p_add">+				if (!test_bit(KEY_FLAG_UID_KEYRING,</span>
<span class="p_add">+					      &amp;keyring-&gt;flags))</span>
<span class="p_add">+					continue;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				if (key_permission(make_key_ref(keyring, 0),</span>
<span class="p_add">+						   KEY_NEED_SEARCH) &lt; 0)</span>
<span class="p_add">+					continue;</span>
<span class="p_add">+			}</span>
 
 			/* we&#39;ve got a match but we might end up racing with
 			 * key_cleanup() if the keyring is currently &#39;dead&#39;
<span class="p_header">diff --git a/security/keys/process_keys.c b/security/keys/process_keys.c</span>
<span class="p_header">index 4ed909142956..7dd050f24261 100644</span>
<span class="p_header">--- a/security/keys/process_keys.c</span>
<span class="p_header">+++ b/security/keys/process_keys.c</span>
<span class="p_chunk">@@ -76,7 +76,9 @@</span> <span class="p_context"> int install_user_keyrings(void)</span>
 		if (IS_ERR(uid_keyring)) {
 			uid_keyring = keyring_alloc(buf, user-&gt;uid, INVALID_GID,
 						    cred, user_keyring_perm,
<span class="p_del">-						    KEY_ALLOC_IN_QUOTA, NULL);</span>
<span class="p_add">+						    KEY_ALLOC_UID_KEYRING |</span>
<span class="p_add">+							KEY_ALLOC_IN_QUOTA,</span>
<span class="p_add">+						    NULL);</span>
 			if (IS_ERR(uid_keyring)) {
 				ret = PTR_ERR(uid_keyring);
 				goto error;
<span class="p_chunk">@@ -92,7 +94,9 @@</span> <span class="p_context"> int install_user_keyrings(void)</span>
 			session_keyring =
 				keyring_alloc(buf, user-&gt;uid, INVALID_GID,
 					      cred, user_keyring_perm,
<span class="p_del">-					      KEY_ALLOC_IN_QUOTA, NULL);</span>
<span class="p_add">+					      KEY_ALLOC_UID_KEYRING |</span>
<span class="p_add">+						  KEY_ALLOC_IN_QUOTA,</span>
<span class="p_add">+					      NULL);</span>
 			if (IS_ERR(session_keyring)) {
 				ret = PTR_ERR(session_keyring);
 				goto error_release;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



