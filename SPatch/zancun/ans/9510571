
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v4,4/4] sparc64: Add support for ADI (Application Data Integrity) - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v4,4/4] sparc64: Add support for ADI (Application Data Integrity)</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 11, 2017, 4:12 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;0c08eb00e5a9735d7d0bcbeaadeacaa761011aab.1483999591.git.khalid.aziz@oracle.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9510571/mbox/"
   >mbox</a>
|
   <a href="/patch/9510571/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9510571/">/patch/9510571/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	411516075C for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 11 Jan 2017 16:15:59 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 414482842F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 11 Jan 2017 16:15:59 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 357AD285CA; Wed, 11 Jan 2017 16:15:59 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-1.9 required=2.0 tests=BAYES_00, UNPARSEABLE_RELAY
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 080762842F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 11 Jan 2017 16:15:45 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1765416AbdAKQPi (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 11 Jan 2017 11:15:38 -0500
Received: from aserp1040.oracle.com ([141.146.126.69]:41928 &quot;EHLO
	aserp1040.oracle.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1758056AbdAKQPd (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 11 Jan 2017 11:15:33 -0500
Received: from userv0021.oracle.com (userv0021.oracle.com [156.151.31.71])
	by aserp1040.oracle.com (Sentrion-MTA-4.3.2/Sentrion-MTA-4.3.2) with
	ESMTP id v0BGEKYc028821
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
	verify=OK); Wed, 11 Jan 2017 16:14:21 GMT
Received: from userv0121.oracle.com (userv0121.oracle.com [156.151.31.72])
	by userv0021.oracle.com (8.14.4/8.14.4) with ESMTP id v0BGEKA7010804
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-GCM-SHA384 bits=256
	verify=OK); Wed, 11 Jan 2017 16:14:20 GMT
Received: from abhmp0015.oracle.com (abhmp0015.oracle.com [141.146.116.21])
	by userv0121.oracle.com (8.14.4/8.13.8) with ESMTP id
	v0BGEG0D006385; Wed, 11 Jan 2017 16:14:17 GMT
Received: from concerto.us.oracle.com (/10.159.92.74)
	by default (Oracle Beehive Gateway v4.0)
	with ESMTP ; Wed, 11 Jan 2017 08:14:16 -0800
From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;
To: davem@davemloft.net, corbet@lwn.net
Cc: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;, viro@zeniv.linux.org.uk,
	nitin.m.gupta@oracle.com, mike.kravetz@oracle.com,
	akpm@linux-foundation.org, mingo@kernel.org,
	kirill.shutemov@linux.intel.com, adam.buchbinder@gmail.com,
	hughd@google.com, minchan@kernel.org, keescook@chromium.org,
	chris.hyser@oracle.com, atish.patra@oracle.com,
	cmetcalf@mellanox.com, atomlin@redhat.com, jslaby@suse.cz,
	joe@perches.com, paul.gortmaker@windriver.com, mhocko@suse.com,
	lstoakes@gmail.com, jack@suse.cz, dave.hansen@linux.intel.com,
	vbabka@suse.cz, dan.j.williams@intel.com, iamjoonsoo.kim@lge.com,
	linux-doc@vger.kernel.org, linux-kernel@vger.kernel.org,
	sparclinux@vger.kernel.org, linux-mm@kvack.org,
	Khalid Aziz &lt;khalid@gonehiking.org&gt;
Subject: [PATCH v4 4/4] sparc64: Add support for ADI (Application Data
	Integrity)
Date: Wed, 11 Jan 2017 09:12:54 -0700
Message-Id: &lt;0c08eb00e5a9735d7d0bcbeaadeacaa761011aab.1483999591.git.khalid.aziz@oracle.com&gt;
X-Mailer: git-send-email 2.7.4
In-Reply-To: &lt;cover.1483999591.git.khalid.aziz@oracle.com&gt;
References: &lt;cover.1483999591.git.khalid.aziz@oracle.com&gt;
In-Reply-To: &lt;cover.1483999591.git.khalid.aziz@oracle.com&gt;
References: &lt;cover.1483999591.git.khalid.aziz@oracle.com&gt;
X-Source-IP: userv0021.oracle.com [156.151.31.71]
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - Jan. 11, 2017, 4:12 p.m.</div>
<pre class="content">
ADI is a new feature supported on SPARC M7 and newer processors to allow
hardware to catch rogue accesses to memory. ADI is supported for data
fetches only and not instruction fetches. An app can enable ADI on its
data pages, set version tags on them and use versioned addresses to
access the data pages. Upper bits of the address contain the version
tag. On M7 processors, upper four bits (bits 63-60) contain the version
tag. If a rogue app attempts to access ADI enabled data pages, its
access is blocked and processor generates an exception. Please see
Documentation/sparc/adi.txt for further details.

This patch extends mprotect to enable ADI (TSTATE.mcde), enable/disable
MCD (Memory Corruption Detection) on selected memory ranges, enable
TTE.mcd in PTEs, return ADI parameters to userspace and save/restore ADI
version tags on page swap out/in or migration. It also adds handlers for
traps related to MCD. ADI is not enabled by default for any task. A task
must explicitly enable ADI on a memory range and set version tag for ADI
to be effective for the task.

This initial implementation supports saving and restoring one tag per
page. A page must use same version tag across the entire page for the
tag to survive swap and migration. Swap swupport infrastructure in this
patch allows for this capability to be expanded to store/restore more
than one tag per page in future.
<span class="signed-off-by">
Signed-off-by: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
Cc: Khalid Aziz &lt;khalid@gonehiking.org&gt;
---
v2:
	- Fixed a build error

v3:
	- Removed CONFIG_SPARC_ADI
	- Replaced prctl commands with mprotect
	- Added auxiliary vectors for ADI parameters
	- Enabled ADI for swappable pages

 Documentation/sparc/adi.txt             | 288 ++++++++++++++++++++++++++++++++
 arch/sparc/include/asm/adi.h            |   6 +
 arch/sparc/include/asm/adi_64.h         |  46 +++++
 arch/sparc/include/asm/elf_64.h         |   8 +
 arch/sparc/include/asm/hugetlb.h        |  13 ++
 arch/sparc/include/asm/mman.h           |  40 ++++-
 arch/sparc/include/asm/mmu_64.h         |   2 +
 arch/sparc/include/asm/mmu_context_64.h |  32 ++++
 arch/sparc/include/asm/pgtable_64.h     |  94 ++++++++++-
 arch/sparc/include/asm/uaccess_64.h     | 120 ++++++++++++-
 arch/sparc/include/uapi/asm/auxvec.h    |   8 +
 arch/sparc/include/uapi/asm/mman.h      |   2 +
 arch/sparc/kernel/Makefile              |   1 +
 arch/sparc/kernel/adi_64.c              |  93 +++++++++++
 arch/sparc/kernel/mdesc.c               |   4 +
 arch/sparc/kernel/process_64.c          |  21 +++
 arch/sparc/kernel/traps_64.c            |  88 +++++++++-
 arch/sparc/mm/gup.c                     |  37 ++++
 arch/sparc/mm/tlb.c                     |  28 ++++
 include/linux/mm.h                      |   2 +
 20 files changed, 921 insertions(+), 12 deletions(-)
 create mode 100644 Documentation/sparc/adi.txt
 create mode 100644 arch/sparc/include/asm/adi.h
 create mode 100644 arch/sparc/include/asm/adi_64.h
 create mode 100644 arch/sparc/kernel/adi_64.c
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=129">David Miller</a> - Jan. 17, 2017, 4:39 a.m.</div>
<pre class="content">
<span class="from">From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
Date: Wed, 11 Jan 2017 09:12:54 -0700
<span class="quote">
&gt; +		__asm__ __volatile__(</span>
<span class="quote">&gt; +			&quot;.word 0xa1438000\n\t&quot;	/* rd  %mcdper, %l0 */</span>

Just use &quot;rd %%asr14, %0&quot; this way you don&#39;t have to play all of these
fixed register games which kill the code generated by gcc.  If you
forcefully clobber a windowed register like %l0 it means the function
being emitted can never be a leaf function, tail calls are no longer
allowed, etc.
<span class="quote">
&gt; +			&quot;.word 0x9d800011\n\t&quot;	/* wr  %g0, %l1, %mcdper */</span>

Likewise use &quot;wr %%g0, %0, %%asr14&quot;
<span class="quote">
&gt; +		&quot;.word 0xaf900001\n\t&quot;	/* wrpr  %g0, %g1, %pmcdper */</span>

Hmmm, which %asr encodes %pmcdper?
<span class="quote">
&gt; diff --git a/arch/sparc/kernel/mdesc.c b/arch/sparc/kernel/mdesc.c</span>
<span class="quote">&gt; index 8a6982d..68b03bf 100644</span>
<span class="quote">&gt; --- a/arch/sparc/kernel/mdesc.c</span>
<span class="quote">&gt; +++ b/arch/sparc/kernel/mdesc.c</span>
<span class="quote">&gt; @@ -20,6 +20,7 @@</span>
<span class="quote">&gt;  #include &lt;asm/uaccess.h&gt;</span>
<span class="quote">&gt;  #include &lt;asm/oplib.h&gt;</span>
<span class="quote">&gt;  #include &lt;asm/smp.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/adi.h&gt;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  /* Unlike the OBP device tree, the machine description is a full-on</span>
<span class="quote">&gt;   * DAG.  An arbitrary number of ARCs are possible from one</span>
<span class="quote">&gt; @@ -1104,5 +1105,8 @@ void __init sun4v_mdesc_init(void)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	cur_mdesc = hp;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +#ifdef CONFIG_SPARC64</span>

mdesc.c is only built on sparc64, this ifdef is superfluous.
<span class="quote">
&gt; +/* Update the state of MCDPER register in current task&#39;s mm context before</span>
<span class="quote">&gt; + * dup so the dup&#39;d task will inherit flags in this register correctly.</span>
<span class="quote">&gt; + * Current task may have updated flags since it started running.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	if (adi_capable() &amp;&amp; src-&gt;mm) {</span>
<span class="quote">&gt; +		register unsigned long tmp_mcdper;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		__asm__ __volatile__(</span>
<span class="quote">&gt; +			&quot;.word 0x83438000\n\t&quot;	/* rd %mcdper, %g1 */</span>
<span class="quote">&gt; +			&quot;mov %%g1, %0\n\t&quot;</span>
<span class="quote">&gt; +			: &quot;=r&quot; (tmp_mcdper)</span>
<span class="quote">&gt; +			:</span>
<span class="quote">&gt; +			: &quot;g1&quot;);</span>
<span class="quote">&gt; +		src-&gt;mm-&gt;context.mcdper = tmp_mcdper;</span>

I don&#39;t like the idea of duplicating &#39;mm&#39; state using the task struct
copy.  Why do not the MM handling interfaces handle this properly?

Maybe it means you&#39;ve abstracted the ADI register handling in the
wrong place.  Maybe it&#39;s a thread property which is &quot;pushed&quot; from
the MM context.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - Jan. 17, 2017, 7:32 p.m.</div>
<pre class="content">
On 01/16/2017 09:39 PM, David Miller wrote:
<span class="quote">&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt; Date: Wed, 11 Jan 2017 09:12:54 -0700</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; +		__asm__ __volatile__(</span>
<span class="quote">&gt;&gt; +			&quot;.word 0xa1438000\n\t&quot;	/* rd  %mcdper, %l0 */</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Just use &quot;rd %%asr14, %0&quot; this way you don&#39;t have to play all of these</span>
<span class="quote">&gt; fixed register games which kill the code generated by gcc.  If you</span>
<span class="quote">&gt; forcefully clobber a windowed register like %l0 it means the function</span>
<span class="quote">&gt; being emitted can never be a leaf function, tail calls are no longer</span>
<span class="quote">&gt; allowed, etc.</span>

Hi David,

&quot;rd %%asr14, %0&quot; should work but does not due to bugs in assembler - 
&lt;https://sourceware.org/ml/binutils/2016-03/msg00302.html&gt;, and 
&lt;https://sourceware.org/ml/binutils/2016-03/msg00303.html&gt;. These bugs 
were fixed in binutils 2.27 but older assemblers will cause kernel build 
to fail. Using byte coded equivalent is the safest option.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +			&quot;.word 0x9d800011\n\t&quot;	/* wr  %g0, %l1, %mcdper */</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Likewise use &quot;wr %%g0, %0, %%asr14&quot;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; +		&quot;.word 0xaf900001\n\t&quot;	/* wrpr  %g0, %g1, %pmcdper */</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Hmmm, which %asr encodes %pmcdper?</span>

%pmcdper is not an asr, rather a privileged register (pr23).

Thanks,
Khalid
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; diff --git a/arch/sparc/kernel/mdesc.c b/arch/sparc/kernel/mdesc.c</span>
<span class="quote">&gt;&gt; index 8a6982d..68b03bf 100644</span>
<span class="quote">&gt;&gt; --- a/arch/sparc/kernel/mdesc.c</span>
<span class="quote">&gt;&gt; +++ b/arch/sparc/kernel/mdesc.c</span>
<span class="quote">&gt;&gt; @@ -20,6 +20,7 @@</span>
<span class="quote">&gt;&gt;  #include &lt;asm/uaccess.h&gt;</span>
<span class="quote">&gt;&gt;  #include &lt;asm/oplib.h&gt;</span>
<span class="quote">&gt;&gt;  #include &lt;asm/smp.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;asm/adi.h&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  /* Unlike the OBP device tree, the machine description is a full-on</span>
<span class="quote">&gt;&gt;   * DAG.  An arbitrary number of ARCs are possible from one</span>
<span class="quote">&gt;&gt; @@ -1104,5 +1105,8 @@ void __init sun4v_mdesc_init(void)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  	cur_mdesc = hp;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +#ifdef CONFIG_SPARC64</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; mdesc.c is only built on sparc64, this ifdef is superfluous.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; +/* Update the state of MCDPER register in current task&#39;s mm context before</span>
<span class="quote">&gt;&gt; + * dup so the dup&#39;d task will inherit flags in this register correctly.</span>
<span class="quote">&gt;&gt; + * Current task may have updated flags since it started running.</span>
<span class="quote">&gt;&gt; + */</span>
<span class="quote">&gt;&gt; +int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	if (adi_capable() &amp;&amp; src-&gt;mm) {</span>
<span class="quote">&gt;&gt; +		register unsigned long tmp_mcdper;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		__asm__ __volatile__(</span>
<span class="quote">&gt;&gt; +			&quot;.word 0x83438000\n\t&quot;	/* rd %mcdper, %g1 */</span>
<span class="quote">&gt;&gt; +			&quot;mov %%g1, %0\n\t&quot;</span>
<span class="quote">&gt;&gt; +			: &quot;=r&quot; (tmp_mcdper)</span>
<span class="quote">&gt;&gt; +			:</span>
<span class="quote">&gt;&gt; +			: &quot;g1&quot;);</span>
<span class="quote">&gt;&gt; +		src-&gt;mm-&gt;context.mcdper = tmp_mcdper;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I don&#39;t like the idea of duplicating &#39;mm&#39; state using the task struct</span>
<span class="quote">&gt; copy.  Why do not the MM handling interfaces handle this properly?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Maybe it means you&#39;ve abstracted the ADI register handling in the</span>
<span class="quote">&gt; wrong place.  Maybe it&#39;s a thread property which is &quot;pushed&quot; from</span>
<span class="quote">&gt; the MM context.</span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; To unsubscribe from this list: send the line &quot;unsubscribe sparclinux&quot; in</span>
<span class="quote">&gt; the body of a message to majordomo@vger.kernel.org</span>
<span class="quote">&gt; More majordomo info at  http://vger.kernel.org/majordomo-info.html</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=129">David Miller</a> - Jan. 17, 2017, 7:42 p.m.</div>
<pre class="content">
<span class="from">From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
Date: Tue, 17 Jan 2017 12:32:46 -0700
<span class="quote">
&gt; On 01/16/2017 09:39 PM, David Miller wrote:</span>
<span class="quote">&gt;&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt; Date: Wed, 11 Jan 2017 09:12:54 -0700</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; +		__asm__ __volatile__(</span>
<span class="quote">&gt;&gt;&gt; +			&quot;.word 0xa1438000\n\t&quot;	/* rd  %mcdper, %l0 */</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Just use &quot;rd %%asr14, %0&quot; this way you don&#39;t have to play all of these</span>
<span class="quote">&gt;&gt; fixed register games which kill the code generated by gcc.  If you</span>
<span class="quote">&gt;&gt; forcefully clobber a windowed register like %l0 it means the function</span>
<span class="quote">&gt;&gt; being emitted can never be a leaf function, tail calls are no longer</span>
<span class="quote">&gt;&gt; allowed, etc.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hi David,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &quot;rd %%asr14, %0&quot; should work but does not due to bugs in assembler -</span>
<span class="quote">&gt; &lt;https://sourceware.org/ml/binutils/2016-03/msg00302.html&gt;, and</span>
<span class="quote">&gt; &lt;https://sourceware.org/ml/binutils/2016-03/msg00303.html&gt;. These bugs</span>
<span class="quote">&gt; were fixed in binutils 2.27 but older assemblers will cause kernel</span>
<span class="quote">&gt; build to fail. Using byte coded equivalent is the safest option.</span>

Fair enough.

Then please at least use %g1 or another usable global register to
avoid at least some of the problems I mentioned.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - Jan. 17, 2017, 8:12 p.m.</div>
<pre class="content">
On 01/17/2017 12:42 PM, David Miller wrote:
<span class="quote">&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt; Date: Tue, 17 Jan 2017 12:32:46 -0700</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; On 01/16/2017 09:39 PM, David Miller wrote:</span>
<span class="quote">&gt;&gt;&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt;&gt; Date: Wed, 11 Jan 2017 09:12:54 -0700</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; +		__asm__ __volatile__(</span>
<span class="quote">&gt;&gt;&gt;&gt; +			&quot;.word 0xa1438000\n\t&quot;	/* rd  %mcdper, %l0 */</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Just use &quot;rd %%asr14, %0&quot; this way you don&#39;t have to play all of these</span>
<span class="quote">&gt;&gt;&gt; fixed register games which kill the code generated by gcc.  If you</span>
<span class="quote">&gt;&gt;&gt; forcefully clobber a windowed register like %l0 it means the function</span>
<span class="quote">&gt;&gt;&gt; being emitted can never be a leaf function, tail calls are no longer</span>
<span class="quote">&gt;&gt;&gt; allowed, etc.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Hi David,</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; &quot;rd %%asr14, %0&quot; should work but does not due to bugs in assembler -</span>
<span class="quote">&gt;&gt; &lt;https://sourceware.org/ml/binutils/2016-03/msg00302.html&gt;, and</span>
<span class="quote">&gt;&gt; &lt;https://sourceware.org/ml/binutils/2016-03/msg00303.html&gt;. These bugs</span>
<span class="quote">&gt;&gt; were fixed in binutils 2.27 but older assemblers will cause kernel</span>
<span class="quote">&gt;&gt; build to fail. Using byte coded equivalent is the safest option.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Fair enough.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Then please at least use %g1 or another usable global register to</span>
<span class="quote">&gt; avoid at least some of the problems I mentioned.</span>
<span class="quote">&gt;</span>

Sure, I will do that. Thanks for the review and feedback.

--
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - Jan. 18, 2017, 12:14 a.m.</div>
<pre class="content">
On 01/16/2017 09:39 PM, David Miller wrote:
<span class="quote">&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt; Date: Wed, 11 Jan 2017 09:12:54 -0700</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; diff --git a/arch/sparc/kernel/mdesc.c b/arch/sparc/kernel/mdesc.c</span>
<span class="quote">&gt;&gt; index 8a6982d..68b03bf 100644</span>
<span class="quote">&gt;&gt; --- a/arch/sparc/kernel/mdesc.c</span>
<span class="quote">&gt;&gt; +++ b/arch/sparc/kernel/mdesc.c</span>
<span class="quote">&gt;&gt; @@ -20,6 +20,7 @@</span>
<span class="quote">&gt;&gt;  #include &lt;asm/uaccess.h&gt;</span>
<span class="quote">&gt;&gt;  #include &lt;asm/oplib.h&gt;</span>
<span class="quote">&gt;&gt;  #include &lt;asm/smp.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;asm/adi.h&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  /* Unlike the OBP device tree, the machine description is a full-on</span>
<span class="quote">&gt;&gt;   * DAG.  An arbitrary number of ARCs are possible from one</span>
<span class="quote">&gt;&gt; @@ -1104,5 +1105,8 @@ void __init sun4v_mdesc_init(void)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  	cur_mdesc = hp;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +#ifdef CONFIG_SPARC64</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; mdesc.c is only built on sparc64, this ifdef is superfluous.</span>

Good point. I will fix it.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +/* Update the state of MCDPER register in current task&#39;s mm context before</span>
<span class="quote">&gt;&gt; + * dup so the dup&#39;d task will inherit flags in this register correctly.</span>
<span class="quote">&gt;&gt; + * Current task may have updated flags since it started running.</span>
<span class="quote">&gt;&gt; + */</span>
<span class="quote">&gt;&gt; +int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	if (adi_capable() &amp;&amp; src-&gt;mm) {</span>
<span class="quote">&gt;&gt; +		register unsigned long tmp_mcdper;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		__asm__ __volatile__(</span>
<span class="quote">&gt;&gt; +			&quot;.word 0x83438000\n\t&quot;	/* rd %mcdper, %g1 */</span>
<span class="quote">&gt;&gt; +			&quot;mov %%g1, %0\n\t&quot;</span>
<span class="quote">&gt;&gt; +			: &quot;=r&quot; (tmp_mcdper)</span>
<span class="quote">&gt;&gt; +			:</span>
<span class="quote">&gt;&gt; +			: &quot;g1&quot;);</span>
<span class="quote">&gt;&gt; +		src-&gt;mm-&gt;context.mcdper = tmp_mcdper;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I don&#39;t like the idea of duplicating &#39;mm&#39; state using the task struct</span>
<span class="quote">&gt; copy.  Why do not the MM handling interfaces handle this properly?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Maybe it means you&#39;ve abstracted the ADI register handling in the</span>
<span class="quote">&gt; wrong place.  Maybe it&#39;s a thread property which is &quot;pushed&quot; from</span>
<span class="quote">&gt; the MM context.</span>

I see what you are saying. This code updates mm-&gt;context.mcdper for the 
source thread with the current state of MCDPER since MCDPER can be 
changed by a userspace process any time. When userspace changes MCDPER, 
it is not saved into mm-&gt;context.mcdper until a context switch happens. 
This means during the timeslice for a thread, its mm-&gt;context.mcdper may 
not reflect the current value of MCDPER. Updating it ensures dup_mm() 
will copy the real current value of MCDPER into the newly forked thread. 
arch_dup_mmap() looks like a more appropriate place to do this. Do you 
agree?

Thanks,
Khalid
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/sparc/adi.txt b/Documentation/sparc/adi.txt</span>
new file mode 100644
<span class="p_header">index 0000000..ab3cd7f</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/Documentation/sparc/adi.txt</span>
<span class="p_chunk">@@ -0,0 +1,288 @@</span> <span class="p_context"></span>
<span class="p_add">+Application Data Integrity (ADI)</span>
<span class="p_add">+================================</span>
<span class="p_add">+</span>
<span class="p_add">+SPARC M7 processor adds the Application Data Integrity (ADI) feature.</span>
<span class="p_add">+ADI allows a task to set version tags on any subset of its address</span>
<span class="p_add">+space. Once ADI is enabled and version tags are set for ranges of</span>
<span class="p_add">+address space of a task, the processor will compare the tag in pointers</span>
<span class="p_add">+to memory in these ranges to the version set by the application</span>
<span class="p_add">+previously. Access to memory is granted only if the tag in given</span>
<span class="p_add">+pointer matches the tag set by the application. In case of mismatch,</span>
<span class="p_add">+processor raises an exception.</span>
<span class="p_add">+</span>
<span class="p_add">+Following steps must be taken by a task to enable ADI fully:</span>
<span class="p_add">+</span>
<span class="p_add">+1. Set the user mode PSTATE.mcde bit. This acts as master switch for</span>
<span class="p_add">+   the task&#39;s entire address space to enable/disable ADI for the task.</span>
<span class="p_add">+</span>
<span class="p_add">+2. Set TTE.mcd bit on any TLB entries that correspond to the range of</span>
<span class="p_add">+   addresses ADI is being enabled on. MMU checks the version tag only</span>
<span class="p_add">+   on the pages that have TTE.mcd bit set.</span>
<span class="p_add">+</span>
<span class="p_add">+3. Set the version tag for virtual addresses using stxa instruction</span>
<span class="p_add">+   and one of the MCD specific ASIs. Each stxa instruction sets the</span>
<span class="p_add">+   given tag for one ADI block size number of bytes. This step must</span>
<span class="p_add">+   be repeated for entire page to set tags for entire page.</span>
<span class="p_add">+</span>
<span class="p_add">+ADI block size for the platform is provided by the hypervisor to the</span>
<span class="p_add">+kernel in machine description tables. Hypervisor also provides the</span>
<span class="p_add">+number of top bits in the virtual address that specify the version tag.</span>
<span class="p_add">+Once version tag has been set for a memory location, the tag is stored</span>
<span class="p_add">+in the physical memory and the same tag must be present in the ADI</span>
<span class="p_add">+version tag bits of the virtual address being presented to the MMU. For</span>
<span class="p_add">+example on SPARC M7 processor, MMU uses bits 63-60 for version tags and</span>
<span class="p_add">+ADI block size is same as cacheline size which is 64 bytes. A task that</span>
<span class="p_add">+sets ADI version to say 10 on a range of memory, must access that memory</span>
<span class="p_add">+using virtual addresses that contain 0xa in bits 63-60.</span>
<span class="p_add">+</span>
<span class="p_add">+ADI is enabled on a set of pages using mprotect() with PROT_ADI flag.</span>
<span class="p_add">+When ADI is enabled on a set of pages by a task for the first time,</span>
<span class="p_add">+kernel sets the PSTATE.mcde bit fot the task. Version tags for memory</span>
<span class="p_add">+addresses are set with an stxa instruction on the addresses using</span>
<span class="p_add">+ASI_MCD_PRIMARY or ASI_MCD_ST_BLKINIT_PRIMARY. ADI block size is</span>
<span class="p_add">+provided by the hypervisor to the kernel.  Kernel returns the value of</span>
<span class="p_add">+ADI block size to userspace using auxiliary vector along with other ADI</span>
<span class="p_add">+info. Following auxiliary vectors are provided by the kernel:</span>
<span class="p_add">+</span>
<span class="p_add">+	AT_ADI_BLKSZ	ADI block size. This is the granularity and</span>
<span class="p_add">+			alignment, in bytes, of ADI versioning.</span>
<span class="p_add">+	AT_ADI_NBITS	Number of ADI version bits in the VA</span>
<span class="p_add">+	AT_ADI_UEONADI	ADI version of memory containing uncorrectable</span>
<span class="p_add">+			errors will be set to this value</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+IMPORTANT NOTES:</span>
<span class="p_add">+</span>
<span class="p_add">+- Version tag values of 0x0 and 0xf are reserved.</span>
<span class="p_add">+</span>
<span class="p_add">+- Version tags are set on virtual addresses from userspace even though</span>
<span class="p_add">+  tags are stored in physical memory. Tags are set on a physical page</span>
<span class="p_add">+  after it has been allocated to a task and a pte has been created for</span>
<span class="p_add">+  it.</span>
<span class="p_add">+</span>
<span class="p_add">+- When a task frees a memory page it had set version tags on, the page</span>
<span class="p_add">+  goes back to free page pool. When this page is re-allocated to a task,</span>
<span class="p_add">+  kernel clears the page using block initialization ASI which clears the</span>
<span class="p_add">+  version tags as well for the page. If a page allocated to a task is</span>
<span class="p_add">+  freed and allocated back to the same task, old version tags set by the</span>
<span class="p_add">+  task on that page will no longer be present.</span>
<span class="p_add">+</span>
<span class="p_add">+- Kernel does not set any tags for user pages and it is entirely a</span>
<span class="p_add">+  task&#39;s responsibility to set any version tags. Kernel does ensure the</span>
<span class="p_add">+  version tags are preserved if a page is swapped out to the disk and</span>
<span class="p_add">+  swapped back in. It also preserves that version tags if a page is</span>
<span class="p_add">+  migrated.</span>
<span class="p_add">+</span>
<span class="p_add">+- Initial implementation assumes a single page uses exact same version</span>
<span class="p_add">+  tag for the entire page. Kernel saves the version tag for only the</span>
<span class="p_add">+  first byte when swapping or migrating a page and restores that tag to</span>
<span class="p_add">+  the entire page after swapping in or migrating the page. Future</span>
<span class="p_add">+  implementations may expand kernel&#39;s capability to store/restore more</span>
<span class="p_add">+  than one tag per page.</span>
<span class="p_add">+</span>
<span class="p_add">+- ADI works for any size pages. A userspace task need not be aware of</span>
<span class="p_add">+  page size when using ADI. It can simply select a virtual address</span>
<span class="p_add">+  range, enable ADI on the range using mprotect() and set version tags</span>
<span class="p_add">+  for the entire range. mprotect() ensures range is aligned to page size</span>
<span class="p_add">+  and is a multiple of page size.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+ADI related traps</span>
<span class="p_add">+-----------------</span>
<span class="p_add">+</span>
<span class="p_add">+With ADI enabled, following new traps may occur:</span>
<span class="p_add">+</span>
<span class="p_add">+Disrupting memory corruption</span>
<span class="p_add">+</span>
<span class="p_add">+	When a store accesses a memory localtion that has TTE.mcd=1,</span>
<span class="p_add">+	the task is running with ADI enabled (PSTATE.mcde=1), and the ADI</span>
<span class="p_add">+	tag in the address used (bits 63:60) does not match the tag set on</span>
<span class="p_add">+	the corresponding cacheline, a memory corruption trap occurs. By</span>
<span class="p_add">+	default, it is a disrupting trap and is sent to the hypervisor</span>
<span class="p_add">+	first. Hypervisor creates a sun4v error report and sends a</span>
<span class="p_add">+	resumable error (TT=0x7e) trap to the kernel. The kernel sends</span>
<span class="p_add">+	a SIGSEGV to the task that resulted in this trap with the following</span>
<span class="p_add">+	info:</span>
<span class="p_add">+</span>
<span class="p_add">+		siginfo.si_signo = SIGSEGV;</span>
<span class="p_add">+		siginfo.errno = 0;</span>
<span class="p_add">+		siginfo.si_code = SEGV_ADIDERR;</span>
<span class="p_add">+		siginfo.si_addr = addr; /* PC where first mismatch occurred */</span>
<span class="p_add">+		siginfo.si_trapno = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+Precise memory corruption</span>
<span class="p_add">+</span>
<span class="p_add">+	When a store accesses a memory location that has TTE.mcd=1,</span>
<span class="p_add">+	the task is running with ADI enabled (PSTATE.mcde=1), and the ADI</span>
<span class="p_add">+	tag in the address used (bits 63:60) does not match the tag set on</span>
<span class="p_add">+	the corresponding cacheline, a memory corruption trap occurs. If</span>
<span class="p_add">+	MCD precise exception is enabled (MCDPERR=1), a precise</span>
<span class="p_add">+	exception is sent to the kernel with TT=0x1a. The kernel sends</span>
<span class="p_add">+	a SIGSEGV to the task that resulted in this trap with the following</span>
<span class="p_add">+	info:</span>
<span class="p_add">+</span>
<span class="p_add">+		siginfo.si_signo = SIGSEGV;</span>
<span class="p_add">+		siginfo.errno = 0;</span>
<span class="p_add">+		siginfo.si_code = SEGV_ADIPERR;</span>
<span class="p_add">+		siginfo.si_addr = addr;	/* address that caused trap */</span>
<span class="p_add">+		siginfo.si_trapno = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	NOTE: ADI tag mismatch on a load always results in precise trap.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+MCD disabled</span>
<span class="p_add">+</span>
<span class="p_add">+	When a task has not enabled ADI and attempts to set ADI version</span>
<span class="p_add">+	on a memory address, processor sends an MCD disabled trap. This</span>
<span class="p_add">+	trap is handled by hypervisor first and the hypervisor vectors this</span>
<span class="p_add">+	trap through to the kernel as Data Access Exception trap with</span>
<span class="p_add">+	fault type set to 0xa (invalid ASI). When this occurs, the kernel</span>
<span class="p_add">+	sends the task SIGSEGV signal with following info:</span>
<span class="p_add">+</span>
<span class="p_add">+		siginfo.si_signo = SIGSEGV;</span>
<span class="p_add">+		siginfo.errno = 0;</span>
<span class="p_add">+		siginfo.si_code = SEGV_ACCADI;</span>
<span class="p_add">+		siginfo.si_addr = addr;	/* address that caused trap */</span>
<span class="p_add">+		siginfo.si_trapno = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+Sample program to use ADI</span>
<span class="p_add">+-------------------------</span>
<span class="p_add">+</span>
<span class="p_add">+Following sample program is meant to illustrate how to use the ADI</span>
<span class="p_add">+functionality.</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;unistd.h&gt;</span>
<span class="p_add">+#include &lt;stdio.h&gt;</span>
<span class="p_add">+#include &lt;stdlib.h&gt;</span>
<span class="p_add">+#include &lt;elf.h&gt;</span>
<span class="p_add">+#include &lt;sys/ipc.h&gt;</span>
<span class="p_add">+#include &lt;sys/shm.h&gt;</span>
<span class="p_add">+#include &lt;sys/mman.h&gt;</span>
<span class="p_add">+#include &lt;asm/asi.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef AT_ADI_BLKSZ</span>
<span class="p_add">+#define AT_ADI_BLKSZ	34</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifndef AT_ADI_NBITS</span>
<span class="p_add">+#define AT_ADI_NBITS	35</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifndef AT_ADI_UEONADI</span>
<span class="p_add">+#define AT_ADI_UEONADI	36</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef PROT_ADI</span>
<span class="p_add">+#define PROT_ADI	0x10</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#define BUFFER_SIZE     32*1024*1024UL</span>
<span class="p_add">+</span>
<span class="p_add">+main(int argc, char* argv[], char* envp[])</span>
<span class="p_add">+{</span>
<span class="p_add">+        unsigned long i, mcde, adi_blksz, adi_nbits, adi_ueonadi;</span>
<span class="p_add">+        char *shmaddr, *tmp_addr, *end, *veraddr, *clraddr;</span>
<span class="p_add">+        int shmid, version;</span>
<span class="p_add">+	Elf64_auxv_t *auxv;</span>
<span class="p_add">+</span>
<span class="p_add">+	adi_blksz = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	while(*envp++ != NULL);</span>
<span class="p_add">+	for (auxv = (Elf64_auxv_t *)envp; auxv-&gt;a_type != AT_NULL; auxv++) {</span>
<span class="p_add">+		switch (auxv-&gt;a_type) {</span>
<span class="p_add">+		case AT_ADI_BLKSZ:</span>
<span class="p_add">+			adi_blksz = auxv-&gt;a_un.a_val;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case AT_ADI_NBITS:</span>
<span class="p_add">+			adi_nbits = auxv-&gt;a_un.a_val;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case AT_ADI_UEONADI:</span>
<span class="p_add">+			adi_ueonadi = auxv-&gt;a_un.a_val;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (adi_blksz == 0) {</span>
<span class="p_add">+		fprintf(stderr, &quot;Oops! ADI is not supported\n&quot;);</span>
<span class="p_add">+		exit(1);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	printf(&quot;ADI capabilities:\n&quot;);</span>
<span class="p_add">+	printf(&quot;\tBlock size = %ld\n&quot;, adi_blksz);</span>
<span class="p_add">+	printf(&quot;\tNumber of bits = %ld\n&quot;, adi_nbits);</span>
<span class="p_add">+	printf(&quot;\tUE on ADI error = %ld\n&quot;, adi_ueonadi);</span>
<span class="p_add">+</span>
<span class="p_add">+        if ((shmid = shmget(2, BUFFER_SIZE,</span>
<span class="p_add">+                                IPC_CREAT | SHM_R | SHM_W)) &lt; 0) {</span>
<span class="p_add">+                perror(&quot;shmget failed&quot;);</span>
<span class="p_add">+                exit(1);</span>
<span class="p_add">+        }</span>
<span class="p_add">+</span>
<span class="p_add">+        shmaddr = shmat(shmid, NULL, 0);</span>
<span class="p_add">+        if (shmaddr == (char *)-1) {</span>
<span class="p_add">+                perror(&quot;shm attach failed&quot;);</span>
<span class="p_add">+                shmctl(shmid, IPC_RMID, NULL);</span>
<span class="p_add">+                exit(1);</span>
<span class="p_add">+        }</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mprotect(shmaddr, BUFFER_SIZE, PROT_READ|PROT_WRITE|PROT_ADI)) {</span>
<span class="p_add">+		perror(&quot;mprotect failed&quot;);</span>
<span class="p_add">+		goto err_out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+        /* Set the ADI version tag on the shm segment</span>
<span class="p_add">+         */</span>
<span class="p_add">+        version = 10;</span>
<span class="p_add">+        tmp_addr = shmaddr;</span>
<span class="p_add">+        end = shmaddr + BUFFER_SIZE;</span>
<span class="p_add">+        while (tmp_addr &lt; end) {</span>
<span class="p_add">+                asm volatile(</span>
<span class="p_add">+                        &quot;stxa %1, [%0]0x90\n\t&quot;</span>
<span class="p_add">+                        :</span>
<span class="p_add">+                        : &quot;r&quot; (tmp_addr), &quot;r&quot; (version));</span>
<span class="p_add">+                tmp_addr += adi_blksz;</span>
<span class="p_add">+        }</span>
<span class="p_add">+	asm volatile(&quot;membar #Sync\n\t&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+        /* Create a versioned address from the normal address by placing</span>
<span class="p_add">+	 * version tag in the upper adi_nbits bits</span>
<span class="p_add">+         */</span>
<span class="p_add">+        tmp_addr = (void *) ((unsigned long)shmaddr &lt;&lt; adi_nbits);</span>
<span class="p_add">+        tmp_addr = (void *) ((unsigned long)tmp_addr &gt;&gt; adi_nbits);</span>
<span class="p_add">+        veraddr = (void *) (((unsigned long)version &lt;&lt; (64-adi_nbits))</span>
<span class="p_add">+                        | (unsigned long)tmp_addr);</span>
<span class="p_add">+</span>
<span class="p_add">+        printf(&quot;Starting the writes:\n&quot;);</span>
<span class="p_add">+        for (i = 0; i &lt; BUFFER_SIZE; i++) {</span>
<span class="p_add">+                veraddr[i] = (char)(i);</span>
<span class="p_add">+                if (!(i % (1024 * 1024)))</span>
<span class="p_add">+                        printf(&quot;.&quot;);</span>
<span class="p_add">+        }</span>
<span class="p_add">+        printf(&quot;\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+        printf(&quot;Verifying data...&quot;);</span>
<span class="p_add">+	fflush(stdout);</span>
<span class="p_add">+        for (i = 0; i &lt; BUFFER_SIZE; i++)</span>
<span class="p_add">+                if (veraddr[i] != (char)i)</span>
<span class="p_add">+                        printf(&quot;\nIndex %lu mismatched\n&quot;, i);</span>
<span class="p_add">+        printf(&quot;Done.\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+        /* Disable ADI and clean up</span>
<span class="p_add">+         */</span>
<span class="p_add">+	if (mprotect(shmaddr, BUFFER_SIZE, PROT_READ|PROT_WRITE)) {</span>
<span class="p_add">+		perror(&quot;mprotect failed&quot;);</span>
<span class="p_add">+		goto err_out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+        if (shmdt((const void *)shmaddr) != 0)</span>
<span class="p_add">+                perror(&quot;Detach failure&quot;);</span>
<span class="p_add">+        shmctl(shmid, IPC_RMID, NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+        exit(0);</span>
<span class="p_add">+</span>
<span class="p_add">+err_out:</span>
<span class="p_add">+        if (shmdt((const void *)shmaddr) != 0)</span>
<span class="p_add">+                perror(&quot;Detach failure&quot;);</span>
<span class="p_add">+        shmctl(shmid, IPC_RMID, NULL);</span>
<span class="p_add">+        exit(1);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/sparc/include/asm/adi.h b/arch/sparc/include/asm/adi.h</span>
new file mode 100644
<span class="p_header">index 0000000..acad0d0</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/sparc/include/asm/adi.h</span>
<span class="p_chunk">@@ -0,0 +1,6 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef ___ASM_SPARC_ADI_H</span>
<span class="p_add">+#define ___ASM_SPARC_ADI_H</span>
<span class="p_add">+#if defined(__sparc__) &amp;&amp; defined(__arch64__)</span>
<span class="p_add">+#include &lt;asm/adi_64.h&gt;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/arch/sparc/include/asm/adi_64.h b/arch/sparc/include/asm/adi_64.h</span>
new file mode 100644
<span class="p_header">index 0000000..24fe52f</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/sparc/include/asm/adi_64.h</span>
<span class="p_chunk">@@ -0,0 +1,46 @@</span> <span class="p_context"></span>
<span class="p_add">+/* adi_64.h: ADI related data structures</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2016 Khalid Aziz (khalid.aziz@oracle.com)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This work is licensed under the terms of the GNU GPL, version 2.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#ifndef __ASM_SPARC64_ADI_H</span>
<span class="p_add">+#define __ASM_SPARC64_ADI_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASSEMBLY__</span>
<span class="p_add">+</span>
<span class="p_add">+struct adi_caps {</span>
<span class="p_add">+	__u64 blksz;</span>
<span class="p_add">+	__u64 nbits;</span>
<span class="p_add">+	__u64 ue_on_adi;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct adi_config {</span>
<span class="p_add">+	bool enabled;</span>
<span class="p_add">+	struct adi_caps caps;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+extern struct adi_config adi_state;</span>
<span class="p_add">+</span>
<span class="p_add">+extern void mdesc_adi_init(void);</span>
<span class="p_add">+</span>
<span class="p_add">+static inline bool adi_capable(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return adi_state.enabled;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long adi_blksize(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return adi_state.caps.blksz;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long adi_nbits(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return adi_state.caps.nbits;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#endif	/* __ASSEMBLY__ */</span>
<span class="p_add">+</span>
<span class="p_add">+#endif	/* !(__ASM_SPARC64_ADI_H) */</span>
<span class="p_header">diff --git a/arch/sparc/include/asm/elf_64.h b/arch/sparc/include/asm/elf_64.h</span>
<span class="p_header">index 3f2d403..cf00fbc 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/elf_64.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/elf_64.h</span>
<span class="p_chunk">@@ -210,4 +210,12 @@</span> <span class="p_context"> do {	if ((ex).e_ident[EI_CLASS] == ELFCLASS32)	\</span>
 			(current-&gt;personality &amp; (~PER_MASK)));	\
 } while (0)
 
<span class="p_add">+#define ARCH_DLINFO						\</span>
<span class="p_add">+do {								\</span>
<span class="p_add">+	extern struct adi_config adi_state;			\</span>
<span class="p_add">+	NEW_AUX_ENT(AT_ADI_BLKSZ, adi_state.caps.blksz);	\</span>
<span class="p_add">+	NEW_AUX_ENT(AT_ADI_NBITS, adi_state.caps.nbits);	\</span>
<span class="p_add">+	NEW_AUX_ENT(AT_ADI_UEONADI, adi_state.caps.ue_on_adi);	\</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+</span>
 #endif /* !(__ASM_SPARC64_ELF_H) */
<span class="p_header">diff --git a/arch/sparc/include/asm/hugetlb.h b/arch/sparc/include/asm/hugetlb.h</span>
<span class="p_header">index dcbf985..ac2fe18 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/hugetlb.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/hugetlb.h</span>
<span class="p_chunk">@@ -77,5 +77,18 @@</span> <span class="p_context"> static inline void arch_clear_hugepage_flags(struct page *page)</span>
 void hugetlb_free_pgd_range(struct mmu_gather *tlb, unsigned long addr,
 			    unsigned long end, unsigned long floor,
 			    unsigned long ceiling);
<span class="p_add">+#ifdef CONFIG_SPARC64</span>
<span class="p_add">+static inline pte_t arch_make_huge_pte(pte_t entry, struct vm_area_struct *vma,</span>
<span class="p_add">+			 struct page *page, int writeable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* If this vma has ADI enabled on it, turn on TTE.mcd</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_SPARC_ADI)</span>
<span class="p_add">+		return pte_mkmcd(entry);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return pte_mknotmcd(entry);</span>
<span class="p_add">+}</span>
<span class="p_add">+#define arch_make_huge_pte arch_make_huge_pte</span>
<span class="p_add">+#endif</span>
 
 #endif /* _ASM_SPARC64_HUGETLB_H */
<span class="p_header">diff --git a/arch/sparc/include/asm/mman.h b/arch/sparc/include/asm/mman.h</span>
<span class="p_header">index 59bb593..95d3abc 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/mman.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/mman.h</span>
<span class="p_chunk">@@ -6,5 +6,43 @@</span> <span class="p_context"></span>
 #ifndef __ASSEMBLY__
 #define arch_mmap_check(addr,len,flags)	sparc_mmap_check(addr,len)
 int sparc_mmap_check(unsigned long addr, unsigned long len);
<span class="p_del">-#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_SPARC64</span>
<span class="p_add">+#include &lt;asm/adi_64.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define arch_calc_vm_prot_bits(prot, pkey) sparc_calc_vm_prot_bits(prot)</span>
<span class="p_add">+static inline unsigned long sparc_calc_vm_prot_bits(unsigned long prot)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (prot &amp; PROT_ADI) {</span>
<span class="p_add">+		struct pt_regs *regs;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!current-&gt;mm-&gt;context.adi) {</span>
<span class="p_add">+			regs = task_pt_regs(current);</span>
<span class="p_add">+			regs-&gt;tstate |= TSTATE_MCDE;</span>
<span class="p_add">+			current-&gt;mm-&gt;context.adi = true;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		return VM_SPARC_ADI;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define arch_vm_get_page_prot(vm_flags) sparc_vm_get_page_prot(vm_flags)</span>
<span class="p_add">+static inline pgprot_t sparc_vm_get_page_prot(unsigned long vm_flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (vm_flags &amp; VM_SPARC_ADI) ? __pgprot(_PAGE_MCD_4V) : __pgprot(0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define arch_validate_prot(prot) sparc_validate_prot(prot)</span>
<span class="p_add">+static inline int sparc_validate_prot(unsigned long prot)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (prot &amp; ~(PROT_READ | PROT_WRITE | PROT_EXEC | PROT_SEM | PROT_ADI))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	if ((prot &amp; PROT_ADI) &amp;&amp; !adi_capable())</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_SPARC64 */</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __ASSEMBLY__ */</span>
 #endif /* __SPARC_MMAN_H__ */
<span class="p_header">diff --git a/arch/sparc/include/asm/mmu_64.h b/arch/sparc/include/asm/mmu_64.h</span>
<span class="p_header">index f7de0db..85adfd8 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/mmu_64.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/mmu_64.h</span>
<span class="p_chunk">@@ -96,6 +96,8 @@</span> <span class="p_context"> typedef struct {</span>
 	unsigned long		thp_pte_count;
 	struct tsb_config	tsb_block[MM_NUM_TSBS];
 	struct hv_tsb_descr	tsb_descr[MM_NUM_TSBS];
<span class="p_add">+	bool			adi;</span>
<span class="p_add">+	unsigned long		mcdper;</span>
 } mm_context_t;
 
 #endif /* !__ASSEMBLY__ */
<span class="p_header">diff --git a/arch/sparc/include/asm/mmu_context_64.h b/arch/sparc/include/asm/mmu_context_64.h</span>
<span class="p_header">index b84be67..79f3c7a 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/mmu_context_64.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/mmu_context_64.h</span>
<span class="p_chunk">@@ -7,6 +7,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/spinlock.h&gt;
 #include &lt;asm/spitfire.h&gt;
<span class="p_add">+#include &lt;asm/adi_64.h&gt;</span>
 #include &lt;asm-generic/mm_hooks.h&gt;
 
 static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
<span class="p_chunk">@@ -79,6 +80,21 @@</span> <span class="p_context"> static inline void switch_mm(struct mm_struct *old_mm, struct mm_struct *mm, str</span>
 	if (unlikely(mm == &amp;init_mm))
 		return;
 
<span class="p_add">+	/* Save the current state of MCDPER register for the process we are</span>
<span class="p_add">+	 * switching from</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (adi_capable()) {</span>
<span class="p_add">+		register unsigned long tmp_mcdper;</span>
<span class="p_add">+</span>
<span class="p_add">+		__asm__ __volatile__(</span>
<span class="p_add">+			&quot;.word 0xa1438000\n\t&quot;	/* rd  %mcdper, %l0 */</span>
<span class="p_add">+			&quot;mov %%l0, %0\n\t&quot;</span>
<span class="p_add">+			: &quot;=r&quot; (tmp_mcdper)</span>
<span class="p_add">+			:</span>
<span class="p_add">+			: &quot;l0&quot;);</span>
<span class="p_add">+		old_mm-&gt;context.mcdper = tmp_mcdper;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;mm-&gt;context.lock, flags);
 	ctx_valid = CTX_VALID(mm-&gt;context);
 	if (!ctx_valid)
<span class="p_chunk">@@ -127,6 +143,22 @@</span> <span class="p_context"> static inline void switch_mm(struct mm_struct *old_mm, struct mm_struct *mm, str</span>
 		__flush_tlb_mm(CTX_HWBITS(mm-&gt;context),
 			       SECONDARY_CONTEXT);
 	}
<span class="p_add">+</span>
<span class="p_add">+	/* Restore the state of MCDPER register for the process we are</span>
<span class="p_add">+	 * switching to</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (adi_capable()) {</span>
<span class="p_add">+		register unsigned long tmp_mcdper;</span>
<span class="p_add">+</span>
<span class="p_add">+		tmp_mcdper = mm-&gt;context.mcdper;</span>
<span class="p_add">+		__asm__ __volatile__(</span>
<span class="p_add">+			&quot;mov %0, %%l1\n\t&quot;</span>
<span class="p_add">+			&quot;.word 0x9d800011\n\t&quot;	/* wr  %g0, %l1, %mcdper */</span>
<span class="p_add">+			:</span>
<span class="p_add">+			: &quot;ir&quot; (tmp_mcdper)</span>
<span class="p_add">+			: &quot;l1&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	spin_unlock_irqrestore(&amp;mm-&gt;context.lock, flags);
 }
 
<span class="p_header">diff --git a/arch/sparc/include/asm/pgtable_64.h b/arch/sparc/include/asm/pgtable_64.h</span>
<span class="p_header">index f4e4834..e8d64c8 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/pgtable_64.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/pgtable_64.h</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/types.h&gt;
 #include &lt;asm/spitfire.h&gt;
 #include &lt;asm/asi.h&gt;
<span class="p_add">+#include &lt;asm/adi.h&gt;</span>
 #include &lt;asm/page.h&gt;
 #include &lt;asm/processor.h&gt;
 
<span class="p_chunk">@@ -564,6 +565,18 @@</span> <span class="p_context"> static inline pte_t pte_mkspecial(pte_t pte)</span>
 	return pte;
 }
 
<span class="p_add">+static inline pte_t pte_mkmcd(pte_t pte)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pte_val(pte) |= _PAGE_MCD_4V;</span>
<span class="p_add">+	return pte;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline pte_t pte_mknotmcd(pte_t pte)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pte_val(pte) &amp;= ~_PAGE_MCD_4V;</span>
<span class="p_add">+	return pte;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline unsigned long pte_young(pte_t pte)
 {
 	unsigned long mask;
<span class="p_chunk">@@ -921,6 +934,10 @@</span> <span class="p_context"> static inline void __set_pte_at(struct mm_struct *mm, unsigned long addr,</span>
 #define pte_clear_not_present_full(mm,addr,ptep,fullmm)	\
 	__set_pte_at((mm), (addr), (ptep), __pte(0UL), (fullmm))
 
<span class="p_add">+#define __HAVE_ARCH_PTEP_CLEAR_FLUSH</span>
<span class="p_add">+pte_t ptep_clear_flush(struct vm_area_struct *vma, unsigned long addr,</span>
<span class="p_add">+		       pte_t *ptep);</span>
<span class="p_add">+</span>
 #ifdef DCACHE_ALIASING_POSSIBLE
 #define __HAVE_ARCH_MOVE_PTE
 #define move_pte(pte, prot, old_addr, new_addr)				\
<span class="p_chunk">@@ -964,9 +981,14 @@</span> <span class="p_context"> void pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,</span>
 pgtable_t pgtable_trans_huge_withdraw(struct mm_struct *mm, pmd_t *pmdp);
 #endif
 
<span class="p_del">-/* Encode and de-code a swap entry */</span>
<span class="p_add">+/* Encode and de-code a swap entry. Upper bits of offset are used to</span>
<span class="p_add">+ * store the ADI version tag for pages that have ADI enabled and tags set</span>
<span class="p_add">+ */</span>
 #define __swp_type(entry)	(((entry).val &gt;&gt; PAGE_SHIFT) &amp; 0xffUL)
<span class="p_del">-#define __swp_offset(entry)	((entry).val &gt;&gt; (PAGE_SHIFT + 8UL))</span>
<span class="p_add">+#define __swp_offset(entry)		\</span>
<span class="p_add">+	((((entry).val &lt;&lt; adi_nbits()) &gt;&gt; adi_nbits()) &gt;&gt; (PAGE_SHIFT + 8UL))</span>
<span class="p_add">+#define __swp_aditag(entry)		\</span>
<span class="p_add">+	((entry).val &gt;&gt; (sizeof(unsigned long)-adi_nbits()))</span>
 #define __swp_entry(type, offset)	\
 	( (swp_entry_t) \
 	  { \
<span class="p_chunk">@@ -989,6 +1011,74 @@</span> <span class="p_context"> int page_in_phys_avail(unsigned long paddr);</span>
 int remap_pfn_range(struct vm_area_struct *, unsigned long, unsigned long,
 		    unsigned long, pgprot_t);
 
<span class="p_add">+static inline void set_swp_pte_at(struct mm_struct *mm, unsigned long addr,</span>
<span class="p_add">+			     pte_t *ptep, pte_t pte, pte_t oldpte)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pte_t orig = *ptep;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pte_none(pte) &amp;&amp; !pte_present(pte)) {</span>
<span class="p_add">+		if (pte_val(oldpte) &amp; _PAGE_MCD_4V) {</span>
<span class="p_add">+			unsigned long version, paddr;</span>
<span class="p_add">+</span>
<span class="p_add">+			paddr = pte_val(oldpte) &amp; _PAGE_PADDR_4V;</span>
<span class="p_add">+			asm volatile(&quot;ldxa [%1] %2, %0\n\t&quot;</span>
<span class="p_add">+				     : &quot;=r&quot; (version)</span>
<span class="p_add">+				     : &quot;r&quot; (paddr), &quot;i&quot; (ASI_MCD_REAL));</span>
<span class="p_add">+			if (version) {</span>
<span class="p_add">+				swp_entry_t tmp;</span>
<span class="p_add">+				pgoff_t swap_off;</span>
<span class="p_add">+				unsigned long swap_type, shift_size;</span>
<span class="p_add">+</span>
<span class="p_add">+				/* Save ADI version tag in the top bits</span>
<span class="p_add">+				 * of swap offset</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				tmp = __pte_to_swp_entry(pte);</span>
<span class="p_add">+				swap_off = __swp_offset(tmp);</span>
<span class="p_add">+				swap_type = __swp_type(tmp);</span>
<span class="p_add">+				shift_size = PAGE_SHIFT + 8UL + adi_nbits();</span>
<span class="p_add">+				swap_off = (swap_off &lt;&lt; shift_size)&gt;&gt;shift_size;</span>
<span class="p_add">+				swap_off = (version &lt;&lt; (sizeof(unsigned long) -</span>
<span class="p_add">+						        shift_size)) | swap_off;</span>
<span class="p_add">+				tmp = __swp_entry(swap_type, swap_off);</span>
<span class="p_add">+				pte = __swp_entry_to_pte(tmp);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+		*ptep = pte;</span>
<span class="p_add">+		maybe_tlb_batch_add(mm, addr, ptep, orig, 0);</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		if (pte_val(pte) &amp; _PAGE_MCD_4V) {</span>
<span class="p_add">+			swp_entry_t tmp;</span>
<span class="p_add">+			pgoff_t swap_off;</span>
<span class="p_add">+			unsigned long swap_type, version;</span>
<span class="p_add">+</span>
<span class="p_add">+			*ptep = pte;</span>
<span class="p_add">+			maybe_tlb_batch_add(mm, addr, ptep, orig, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* Check if the swapped out page has an ADI version</span>
<span class="p_add">+			 * saved in the swap offset. If yes, restore</span>
<span class="p_add">+			 * version tag to the newly allocated page</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			tmp = __pte_to_swp_entry(oldpte);</span>
<span class="p_add">+			swap_off = __swp_offset(tmp);</span>
<span class="p_add">+			swap_type = __swp_type(tmp);</span>
<span class="p_add">+			version = __swp_aditag(tmp);</span>
<span class="p_add">+			if (version) {</span>
<span class="p_add">+				unsigned long i, paddr;</span>
<span class="p_add">+</span>
<span class="p_add">+				paddr = pte_val(pte) &amp; _PAGE_PADDR_4V;</span>
<span class="p_add">+				for (i = paddr; i &lt; (paddr+PAGE_SIZE);</span>
<span class="p_add">+						i += adi_blksize())</span>
<span class="p_add">+					asm volatile(&quot;stxa %0, [%1] %2\n\t&quot;</span>
<span class="p_add">+						:</span>
<span class="p_add">+						: &quot;r&quot; (version), &quot;r&quot; (i),</span>
<span class="p_add">+						  &quot;i&quot; (ASI_MCD_REAL));</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			*ptep = pte;</span>
<span class="p_add">+			maybe_tlb_batch_add(mm, addr, ptep, orig, 0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline int io_remap_pfn_range(struct vm_area_struct *vma,
 				     unsigned long from, unsigned long pfn,
 				     unsigned long size, pgprot_t prot)
<span class="p_header">diff --git a/arch/sparc/include/asm/uaccess_64.h b/arch/sparc/include/asm/uaccess_64.h</span>
<span class="p_header">index 5373136..6bfe818 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/uaccess_64.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/uaccess_64.h</span>
<span class="p_chunk">@@ -10,8 +10,10 @@</span> <span class="p_context"></span>
 #include &lt;linux/compiler.h&gt;
 #include &lt;linux/string.h&gt;
 #include &lt;linux/thread_info.h&gt;
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
 #include &lt;asm/asi.h&gt;
 #include &lt;asm/spitfire.h&gt;
<span class="p_add">+#include &lt;asm/adi_64.h&gt;</span>
 #include &lt;asm-generic/uaccess-unaligned.h&gt;
 #include &lt;asm/extable_64.h&gt;
 #endif
<span class="p_chunk">@@ -72,6 +74,31 @@</span> <span class="p_context"> static inline bool __chk_range_not_ok(unsigned long addr, unsigned long size, un</span>
 	__chk_range_not_ok((unsigned long __force)(addr), size, limit); \
 })
 
<span class="p_add">+static inline void enable_adi(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If userspace is using ADI, it could potentially pass a pointer</span>
<span class="p_add">+	 * with version tag embedded in it. To maintain the ADI security,</span>
<span class="p_add">+	 * we must enable PSTATE.mcde. Userspace would have already set</span>
<span class="p_add">+	 * TTE.mcd in an earlier call to kernel and set the version tag</span>
<span class="p_add">+	 * for the address being dereferenced. Setting PSTATE.mcde would</span>
<span class="p_add">+	 * ensure any access to userspace data through a system call</span>
<span class="p_add">+	 * honors ADI and does not allow a rogue app to bypass ADI by</span>
<span class="p_add">+	 * using system calls. Also to ensure the right exception,</span>
<span class="p_add">+	 * precise or disrupting, is delivered to the userspace, update</span>
<span class="p_add">+	 * PMCDPER to match MCDPER</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	__asm__ __volatile__(</span>
<span class="p_add">+		&quot;rdpr %%pstate, %%g1\n\t&quot;</span>
<span class="p_add">+		&quot;or %%g1, %0, %%g1\n\t&quot;</span>
<span class="p_add">+		&quot;wrpr %%g1, %%g0, %%pstate\n\t&quot;</span>
<span class="p_add">+		&quot;.word 0x83438000\n\t&quot;	/* rd %mcdper, %g1 */</span>
<span class="p_add">+		&quot;.word 0xaf900001\n\t&quot;	/* wrpr  %g0, %g1, %pmcdper */</span>
<span class="p_add">+		:</span>
<span class="p_add">+		: &quot;i&quot; (PSTATE_MCDE)</span>
<span class="p_add">+		: &quot;g1&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline int __access_ok(const void __user * addr, unsigned long size)
 {
 	return 1;
<span class="p_chunk">@@ -112,7 +139,9 @@</span> <span class="p_context"> struct __large_struct { unsigned long buf[100]; };</span>
 #define __m(x) ((struct __large_struct *)(x))
 
 #define __put_user_nocheck(data, addr, size) ({			\
<span class="p_del">-	register int __pu_ret;					\</span>
<span class="p_add">+	register int __pu_ret, __adi_status;				\</span>
<span class="p_add">+	if ((__adi_status = (current-&gt;mm &amp;&amp; current-&gt;mm-&gt;context.adi)))	\</span>
<span class="p_add">+		enable_adi();					\</span>
 	switch (size) {						\
 	case 1: __put_user_asm(data, b, addr, __pu_ret); break;	\
 	case 2: __put_user_asm(data, h, addr, __pu_ret); break;	\
<span class="p_chunk">@@ -120,6 +149,9 @@</span> <span class="p_context"> struct __large_struct { unsigned long buf[100]; };</span>
 	case 8: __put_user_asm(data, x, addr, __pu_ret); break;	\
 	default: __pu_ret = __put_user_bad(); break;		\
 	}							\
<span class="p_add">+	if (__adi_status)					\</span>
<span class="p_add">+		/* wrpr  %g0, %pmcdper */			\</span>
<span class="p_add">+		__asm__ __volatile__(&quot;.word 0xaf900000&quot;::);	\</span>
 	__pu_ret;						\
 })
 
<span class="p_chunk">@@ -146,8 +178,10 @@</span> <span class="p_context"> __asm__ __volatile__(							\</span>
 int __put_user_bad(void);
 
 #define __get_user_nocheck(data, addr, size, type) ({			     \
<span class="p_del">-	register int __gu_ret;						     \</span>
<span class="p_add">+	register int __gu_ret, __adi_status;				     \</span>
 	register unsigned long __gu_val;				     \
<span class="p_add">+	if ((__adi_status = (current-&gt;mm &amp;&amp; current-&gt;mm-&gt;context.adi)))	     \</span>
<span class="p_add">+		enable_adi();						     \</span>
 	switch (size) {							     \
 		case 1: __get_user_asm(__gu_val, ub, addr, __gu_ret); break; \
 		case 2: __get_user_asm(__gu_val, uh, addr, __gu_ret); break; \
<span class="p_chunk">@@ -159,6 +193,9 @@</span> <span class="p_context"> int __put_user_bad(void);</span>
 			break;						     \
 	} 								     \
 	data = (__force type) __gu_val;					     \
<span class="p_add">+	if (__adi_status)						     \</span>
<span class="p_add">+		/* wrpr  %g0, %pmcdper */				     \</span>
<span class="p_add">+		__asm__ __volatile__(&quot;.word 0xaf900000&quot;::);		     \</span>
 	 __gu_ret;							     \
 })
 
<span class="p_chunk">@@ -185,15 +222,53 @@</span> <span class="p_context"> __asm__ __volatile__(							\</span>
 
 int __get_user_bad(void);
 
<span class="p_add">+/* When kernel access userspace memory, it must honor ADI setting</span>
<span class="p_add">+ * to ensure ADI protection continues across system calls. Kernel</span>
<span class="p_add">+ * must set PSTATE.mcde bit. It must also update PMCDPER register</span>
<span class="p_add">+ * to reflect MCDPER register so the kind of exception generated</span>
<span class="p_add">+ * in case of ADI version tag mismatch, is what the userspace is</span>
<span class="p_add">+ * expecting. PMCDPER exists only on the processors that support</span>
<span class="p_add">+ * ADI and must be accessed conditionally to avoid illegal</span>
<span class="p_add">+ * instruction trap.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define user_access_begin()						\</span>
<span class="p_add">+	do {								\</span>
<span class="p_add">+		if (current-&gt;mm &amp;&amp; current-&gt;mm-&gt;context.adi)		\</span>
<span class="p_add">+			enable_adi();					\</span>
<span class="p_add">+	} while (0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define user_access_end()						\</span>
<span class="p_add">+	do {								\</span>
<span class="p_add">+		if (adi_capable())					\</span>
<span class="p_add">+			/* wrpr  %g0, %pmcdper */			\</span>
<span class="p_add">+			__asm__ __volatile__(&quot;.word 0xaf900000&quot;::);	\</span>
<span class="p_add">+	} while (0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define unsafe_get_user(x, ptr, err)		\</span>
<span class="p_add">+		do { if (unlikely(__get_user(x, ptr))) goto err; } while (0)</span>
<span class="p_add">+#define unsafe_put_user(x, ptr, err)		\</span>
<span class="p_add">+		do { if (unlikely(__put_user(x, ptr))) goto err; } while (0)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 unsigned long __must_check ___copy_from_user(void *to,
 					     const void __user *from,
 					     unsigned long size);
 static inline unsigned long __must_check
 copy_from_user(void *to, const void __user *from, unsigned long size)
 {
<span class="p_add">+	unsigned long ret, adi_status;</span>
<span class="p_add">+</span>
 	check_object_size(to, size, false);
 
<span class="p_del">-	return ___copy_from_user(to, from, size);</span>
<span class="p_add">+	if ((adi_status = (current-&gt;mm &amp;&amp; current-&gt;mm-&gt;context.adi)))</span>
<span class="p_add">+		enable_adi();</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = ___copy_from_user(to, from, size);</span>
<span class="p_add">+	if (adi_status)</span>
<span class="p_add">+		/* wrpr  %g0, %pmcdper */</span>
<span class="p_add">+		__asm__ __volatile__(&quot;.word 0xaf900000&quot;::);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 #define __copy_from_user copy_from_user
 
<span class="p_chunk">@@ -203,9 +278,18 @@</span> <span class="p_context"> unsigned long __must_check ___copy_to_user(void __user *to,</span>
 static inline unsigned long __must_check
 copy_to_user(void __user *to, const void *from, unsigned long size)
 {
<span class="p_add">+	unsigned long ret, adi_status;</span>
<span class="p_add">+</span>
 	check_object_size(from, size, true);
 
<span class="p_del">-	return ___copy_to_user(to, from, size);</span>
<span class="p_add">+	if ((adi_status = (current-&gt;mm &amp;&amp; current-&gt;mm-&gt;context.adi)))</span>
<span class="p_add">+		enable_adi();</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = ___copy_to_user(to, from, size);</span>
<span class="p_add">+	if (adi_status)</span>
<span class="p_add">+		/* wrpr  %g0, %pmcdper */</span>
<span class="p_add">+		__asm__ __volatile__(&quot;.word 0xaf900000&quot;::);</span>
<span class="p_add">+	return ret;</span>
 }
 #define __copy_to_user copy_to_user
 
<span class="p_chunk">@@ -215,13 +299,37 @@</span> <span class="p_context"> unsigned long __must_check ___copy_in_user(void __user *to,</span>
 static inline unsigned long __must_check
 copy_in_user(void __user *to, void __user *from, unsigned long size)
 {
<span class="p_del">-	return ___copy_in_user(to, from, size);</span>
<span class="p_add">+	unsigned long ret, adi_status;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((adi_status = (current-&gt;mm &amp;&amp; current-&gt;mm-&gt;context.adi)))</span>
<span class="p_add">+		enable_adi();</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = ___copy_in_user(to, from, size);</span>
<span class="p_add">+	if (adi_status)</span>
<span class="p_add">+		/* wrpr  %g0, %pmcdper */</span>
<span class="p_add">+		__asm__ __volatile__(&quot;.word 0xaf900000&quot;::);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 #define __copy_in_user copy_in_user
 
 unsigned long __must_check __clear_user(void __user *, unsigned long);
 
<span class="p_del">-#define clear_user __clear_user</span>
<span class="p_add">+static inline unsigned long __must_check</span>
<span class="p_add">+___clear_user(void __user *uaddr, unsigned long size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long ret, adi_status;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((adi_status = (current-&gt;mm &amp;&amp; current-&gt;mm-&gt;context.adi)))</span>
<span class="p_add">+		enable_adi();</span>
<span class="p_add">+	ret = __clear_user(uaddr, size);</span>
<span class="p_add">+	if (adi_status)</span>
<span class="p_add">+		/* wrpr  %g0, %pmcdper */</span>
<span class="p_add">+		__asm__ __volatile__(&quot;.word 0xaf900000&quot;::);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define clear_user ___clear_user</span>
 
 __must_check long strlen_user(const char __user *str);
 __must_check long strnlen_user(const char __user *str, long n);
<span class="p_header">diff --git a/arch/sparc/include/uapi/asm/auxvec.h b/arch/sparc/include/uapi/asm/auxvec.h</span>
<span class="p_header">index ad6f360..6fe1249 100644</span>
<span class="p_header">--- a/arch/sparc/include/uapi/asm/auxvec.h</span>
<span class="p_header">+++ b/arch/sparc/include/uapi/asm/auxvec.h</span>
<span class="p_chunk">@@ -1,4 +1,12 @@</span> <span class="p_context"></span>
 #ifndef __ASMSPARC_AUXVEC_H
 #define __ASMSPARC_AUXVEC_H
 
<span class="p_add">+#ifdef CONFIG_SPARC64</span>
<span class="p_add">+#define AT_ADI_BLKSZ	34</span>
<span class="p_add">+#define AT_ADI_NBITS	35</span>
<span class="p_add">+#define AT_ADI_UEONADI	36</span>
<span class="p_add">+</span>
<span class="p_add">+#define AT_VECTOR_SIZE_ARCH	3</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #endif /* !(__ASMSPARC_AUXVEC_H) */
<span class="p_header">diff --git a/arch/sparc/include/uapi/asm/mman.h b/arch/sparc/include/uapi/asm/mman.h</span>
<span class="p_header">index 9765896..a72c033 100644</span>
<span class="p_header">--- a/arch/sparc/include/uapi/asm/mman.h</span>
<span class="p_header">+++ b/arch/sparc/include/uapi/asm/mman.h</span>
<span class="p_chunk">@@ -5,6 +5,8 @@</span> <span class="p_context"></span>
 
 /* SunOS&#39;ified... */
 
<span class="p_add">+#define PROT_ADI	0x10		/* ADI enabled */</span>
<span class="p_add">+</span>
 #define MAP_RENAME      MAP_ANONYMOUS   /* In SunOS terminology */
 #define MAP_NORESERVE   0x40            /* don&#39;t reserve swap pages */
 #define MAP_INHERIT     0x80            /* SunOS doesn&#39;t do this, but... */
<span class="p_header">diff --git a/arch/sparc/kernel/Makefile b/arch/sparc/kernel/Makefile</span>
<span class="p_header">index fa3c02d..c9c4e76 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/Makefile</span>
<span class="p_header">+++ b/arch/sparc/kernel/Makefile</span>
<span class="p_chunk">@@ -67,6 +67,7 @@</span> <span class="p_context"> obj-$(CONFIG_SPARC64)   += visemul.o</span>
 obj-$(CONFIG_SPARC64)   += hvapi.o
 obj-$(CONFIG_SPARC64)   += sstate.o
 obj-$(CONFIG_SPARC64)   += mdesc.o
<span class="p_add">+obj-$(CONFIG_SPARC64)   += adi_64.o</span>
 obj-$(CONFIG_SPARC64)	+= pcr.o
 obj-$(CONFIG_SPARC64)	+= nmi.o
 obj-$(CONFIG_SPARC64_SMP) += cpumap.o
<span class="p_header">diff --git a/arch/sparc/kernel/adi_64.c b/arch/sparc/kernel/adi_64.c</span>
new file mode 100644
<span class="p_header">index 0000000..aba1960</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/sparc/kernel/adi_64.c</span>
<span class="p_chunk">@@ -0,0 +1,93 @@</span> <span class="p_context"></span>
<span class="p_add">+/* adi_64.c: support for ADI (Application Data Integrity) feature on</span>
<span class="p_add">+ * sparc m7 and newer processors. This feature is also known as</span>
<span class="p_add">+ * SSM (Silicon Secured Memory).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2016 Khalid Aziz (khalid.aziz@oracle.com)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This work is licensed under the terms of the GNU GPL, version 2.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;asm/mdesc.h&gt;</span>
<span class="p_add">+#include &lt;asm/adi_64.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+struct adi_config adi_state;</span>
<span class="p_add">+</span>
<span class="p_add">+/* mdesc_adi_init() : Parse machine description provided by the</span>
<span class="p_add">+ *	hypervisor to detect ADI capabilities</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Hypervisor reports ADI capabilities of platform in &quot;hwcap-list&quot; property</span>
<span class="p_add">+ * for &quot;cpu&quot; node. If the platform supports ADI, &quot;hwcap-list&quot; property</span>
<span class="p_add">+ * contains the keyword &quot;adp&quot;. If the platform supports ADI, &quot;platform&quot;</span>
<span class="p_add">+ * node will contain &quot;adp-blksz&quot;, &quot;adp-nbits&quot; and &quot;ue-on-adp&quot; properties</span>
<span class="p_add">+ * to describe the ADI capabilities.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void __init mdesc_adi_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mdesc_handle *hp = mdesc_grab();</span>
<span class="p_add">+	const char *prop;</span>
<span class="p_add">+	u64 pn, *val;</span>
<span class="p_add">+	int len;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!hp)</span>
<span class="p_add">+		goto adi_not_found;</span>
<span class="p_add">+</span>
<span class="p_add">+	pn = mdesc_node_by_name(hp, MDESC_NODE_NULL, &quot;cpu&quot;);</span>
<span class="p_add">+	if (pn == MDESC_NODE_NULL)</span>
<span class="p_add">+		goto adi_not_found;</span>
<span class="p_add">+</span>
<span class="p_add">+	prop = mdesc_get_property(hp, pn, &quot;hwcap-list&quot;, &amp;len);</span>
<span class="p_add">+	if (!prop)</span>
<span class="p_add">+		goto adi_not_found;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Look for &quot;adp&quot; keyword in hwcap-list which would indicate</span>
<span class="p_add">+	 * ADI support</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	adi_state.enabled = false;</span>
<span class="p_add">+	while (len) {</span>
<span class="p_add">+		int plen;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!strcmp(prop, &quot;adp&quot;)) {</span>
<span class="p_add">+			adi_state.enabled = true;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		plen = strlen(prop) + 1;</span>
<span class="p_add">+		prop += plen;</span>
<span class="p_add">+		len -= plen;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!adi_state.enabled)</span>
<span class="p_add">+		goto adi_not_found;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Find the ADI properties in &quot;platform&quot; node. If all ADI</span>
<span class="p_add">+	 * properties are not found, ADI support is incomplete and</span>
<span class="p_add">+	 * do not enable ADI in the kernel.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pn = mdesc_node_by_name(hp, MDESC_NODE_NULL, &quot;platform&quot;);</span>
<span class="p_add">+	if (pn == MDESC_NODE_NULL)</span>
<span class="p_add">+		goto adi_not_found;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = (u64 *) mdesc_get_property(hp, pn, &quot;adp-blksz&quot;, &amp;len);</span>
<span class="p_add">+	if (!val)</span>
<span class="p_add">+		goto adi_not_found;</span>
<span class="p_add">+	adi_state.caps.blksz = *val;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = (u64 *) mdesc_get_property(hp, pn, &quot;adp-nbits&quot;, &amp;len);</span>
<span class="p_add">+	if (!val)</span>
<span class="p_add">+		goto adi_not_found;</span>
<span class="p_add">+	adi_state.caps.nbits = *val;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = (u64 *) mdesc_get_property(hp, pn, &quot;ue-on-adp&quot;, &amp;len);</span>
<span class="p_add">+	if (!val)</span>
<span class="p_add">+		goto adi_not_found;</span>
<span class="p_add">+	adi_state.caps.ue_on_adi = *val;</span>
<span class="p_add">+</span>
<span class="p_add">+	mdesc_release(hp);</span>
<span class="p_add">+	return;</span>
<span class="p_add">+</span>
<span class="p_add">+adi_not_found:</span>
<span class="p_add">+	adi_state.enabled = false;</span>
<span class="p_add">+	if (hp)</span>
<span class="p_add">+		mdesc_release(hp);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/sparc/kernel/mdesc.c b/arch/sparc/kernel/mdesc.c</span>
<span class="p_header">index 8a6982d..68b03bf 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/mdesc.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/mdesc.c</span>
<span class="p_chunk">@@ -20,6 +20,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/uaccess.h&gt;
 #include &lt;asm/oplib.h&gt;
 #include &lt;asm/smp.h&gt;
<span class="p_add">+#include &lt;asm/adi.h&gt;</span>
 
 /* Unlike the OBP device tree, the machine description is a full-on
  * DAG.  An arbitrary number of ARCs are possible from one
<span class="p_chunk">@@ -1104,5 +1105,8 @@</span> <span class="p_context"> void __init sun4v_mdesc_init(void)</span>
 
 	cur_mdesc = hp;
 
<span class="p_add">+#ifdef CONFIG_SPARC64</span>
<span class="p_add">+	mdesc_adi_init();</span>
<span class="p_add">+#endif</span>
 	report_platform_properties();
 }
<span class="p_header">diff --git a/arch/sparc/kernel/process_64.c b/arch/sparc/kernel/process_64.c</span>
<span class="p_header">index 47ff558..740cecb 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/process_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/process_64.c</span>
<span class="p_chunk">@@ -680,6 +680,27 @@</span> <span class="p_context"> int copy_thread(unsigned long clone_flags, unsigned long sp,</span>
 	return 0;
 }
 
<span class="p_add">+/* Update the state of MCDPER register in current task&#39;s mm context before</span>
<span class="p_add">+ * dup so the dup&#39;d task will inherit flags in this register correctly.</span>
<span class="p_add">+ * Current task may have updated flags since it started running.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (adi_capable() &amp;&amp; src-&gt;mm) {</span>
<span class="p_add">+		register unsigned long tmp_mcdper;</span>
<span class="p_add">+</span>
<span class="p_add">+		__asm__ __volatile__(</span>
<span class="p_add">+			&quot;.word 0x83438000\n\t&quot;	/* rd %mcdper, %g1 */</span>
<span class="p_add">+			&quot;mov %%g1, %0\n\t&quot;</span>
<span class="p_add">+			: &quot;=r&quot; (tmp_mcdper)</span>
<span class="p_add">+			:</span>
<span class="p_add">+			: &quot;g1&quot;);</span>
<span class="p_add">+		src-&gt;mm-&gt;context.mcdper = tmp_mcdper;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	*dst = *src;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 typedef struct {
 	union {
 		unsigned int	pr_regs[32];
<span class="p_header">diff --git a/arch/sparc/kernel/traps_64.c b/arch/sparc/kernel/traps_64.c</span>
<span class="p_header">index 500c9c6..576937c 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/traps_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/traps_64.c</span>
<span class="p_chunk">@@ -44,6 +44,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/memctrl.h&gt;
 #include &lt;asm/cacheflush.h&gt;
 #include &lt;asm/setup.h&gt;
<span class="p_add">+#include &lt;asm/adi_64.h&gt;</span>
 
 #include &quot;entry.h&quot;
 #include &quot;kernel.h&quot;
<span class="p_chunk">@@ -351,12 +352,31 @@</span> <span class="p_context"> void sun4v_data_access_exception(struct pt_regs *regs, unsigned long addr, unsig</span>
 		regs-&gt;tpc &amp;= 0xffffffff;
 		regs-&gt;tnpc &amp;= 0xffffffff;
 	}
<span class="p_del">-	info.si_signo = SIGSEGV;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* MCD (Memory Corruption Detection) disabled trap (TT=0x19) in HV</span>
<span class="p_add">+	 * is vectored thorugh data access exception trap with fault type</span>
<span class="p_add">+	 * set to HV_FAULT_TYPE_MCD_DIS. Check for MCD disabled trap</span>
<span class="p_add">+	 */</span>
 	info.si_errno = 0;
<span class="p_del">-	info.si_code = SEGV_MAPERR;</span>
 	info.si_addr = (void __user *) addr;
 	info.si_trapno = 0;
<span class="p_del">-	force_sig_info(SIGSEGV, &amp;info, current);</span>
<span class="p_add">+	switch (type) {</span>
<span class="p_add">+	case HV_FAULT_TYPE_INV_ASI:</span>
<span class="p_add">+		info.si_signo = SIGILL;</span>
<span class="p_add">+		info.si_code = ILL_ILLADR;</span>
<span class="p_add">+		force_sig_info(SIGILL, &amp;info, current);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HV_FAULT_TYPE_MCD_DIS:</span>
<span class="p_add">+		info.si_signo = SIGSEGV;</span>
<span class="p_add">+		info.si_code = SEGV_ACCADI;</span>
<span class="p_add">+		force_sig_info(SIGSEGV, &amp;info, current);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		info.si_signo = SIGSEGV;</span>
<span class="p_add">+		info.si_code = SEGV_MAPERR;</span>
<span class="p_add">+		force_sig_info(SIGSEGV, &amp;info, current);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 }
 
 void sun4v_data_access_exception_tl1(struct pt_regs *regs, unsigned long addr, unsigned long type_ctx)
<span class="p_chunk">@@ -1801,6 +1821,7 @@</span> <span class="p_context"> struct sun4v_error_entry {</span>
 #define SUN4V_ERR_ATTRS_ASI		0x00000080
 #define SUN4V_ERR_ATTRS_PRIV_REG	0x00000100
 #define SUN4V_ERR_ATTRS_SPSTATE_MSK	0x00000600
<span class="p_add">+#define SUN4V_ERR_ATTRS_MCD		0x00000800</span>
 #define SUN4V_ERR_ATTRS_SPSTATE_SHFT	9
 #define SUN4V_ERR_ATTRS_MODE_MSK	0x03000000
 #define SUN4V_ERR_ATTRS_MODE_SHFT	24
<span class="p_chunk">@@ -1998,6 +2019,54 @@</span> <span class="p_context"> static void sun4v_log_error(struct pt_regs *regs, struct sun4v_error_entry *ent,</span>
 	}
 }
 
<span class="p_add">+/* Handle memory corruption detected error which is vectored in</span>
<span class="p_add">+ * through resumable error trap.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void do_mcd_err(struct pt_regs *regs, struct sun4v_error_entry ent)</span>
<span class="p_add">+{</span>
<span class="p_add">+	siginfo_t info;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (notify_die(DIE_TRAP, &quot;MCD error&quot;, regs,</span>
<span class="p_add">+		       0, 0x34, SIGSEGV) == NOTIFY_STOP)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (regs-&gt;tstate &amp; TSTATE_PRIV) {</span>
<span class="p_add">+		/* MCD exception could happen because the task was running</span>
<span class="p_add">+		 * a system call with MCD enabled and passed a non-versioned</span>
<span class="p_add">+		 * pointer or pointer with bad version tag to  the system</span>
<span class="p_add">+		 * call. In such cases, hypervisor places the address of</span>
<span class="p_add">+		 * offending instruction in the resumable error report. This</span>
<span class="p_add">+		 * is a deferred error, so the read/write that caused the trap</span>
<span class="p_add">+		 * was potentially retired long time back and we may have</span>
<span class="p_add">+		 * no choice but to send SIGSEGV to the process.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		const struct exception_table_entry *entry;</span>
<span class="p_add">+</span>
<span class="p_add">+		entry = search_exception_tables(regs-&gt;tpc);</span>
<span class="p_add">+		if (entry) {</span>
<span class="p_add">+			/* Looks like a bad syscall parameter */</span>
<span class="p_add">+#ifdef DEBUG_EXCEPTIONS</span>
<span class="p_add">+			pr_emerg(&quot;Exception: PC&lt;%016lx&gt; faddr&lt;UNKNOWN&gt;\n&quot;,</span>
<span class="p_add">+				 regs-&gt;tpc);</span>
<span class="p_add">+			pr_emerg(&quot;EX_TABLE: insn&lt;%016lx&gt; fixup&lt;%016lx&gt;\n&quot;,</span>
<span class="p_add">+				 ent.err_raddr, entry-&gt;fixup);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+			regs-&gt;tpc = entry-&gt;fixup;</span>
<span class="p_add">+			regs-&gt;tnpc = regs-&gt;tpc + 4;</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Send SIGSEGV to the userspace process with the right code</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	info.si_signo = SIGSEGV;</span>
<span class="p_add">+	info.si_errno = 0;</span>
<span class="p_add">+	info.si_code = SEGV_ADIDERR;</span>
<span class="p_add">+	info.si_addr = (void __user *)ent.err_raddr;</span>
<span class="p_add">+	info.si_trapno = 0;</span>
<span class="p_add">+	force_sig_info(SIGSEGV, &amp;info, current);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* We run with %pil set to PIL_NORMAL_MAX and PSTATE_IE enabled in %pstate.
  * Log the event and clear the first word of the entry.
  */
<span class="p_chunk">@@ -2035,6 +2104,14 @@</span> <span class="p_context"> void sun4v_resum_error(struct pt_regs *regs, unsigned long offset)</span>
 		goto out;
 	}
 
<span class="p_add">+	/* If this is a memory corruption detected error, call the</span>
<span class="p_add">+	 * handler</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (local_copy.err_attrs &amp; SUN4V_ERR_ATTRS_MCD) {</span>
<span class="p_add">+		do_mcd_err(regs, local_copy);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	sun4v_log_error(regs, &amp;local_copy, cpu,
 			KERN_ERR &quot;RESUMABLE ERROR&quot;,
 			&amp;sun4v_resum_oflow_cnt);
<span class="p_chunk">@@ -2543,6 +2620,11 @@</span> <span class="p_context"> void sun4v_mem_corrupt_detect_precise(struct pt_regs *regs, unsigned long addr,</span>
 {
 	siginfo_t info;
 
<span class="p_add">+	if (!adi_capable()) {</span>
<span class="p_add">+		bad_trap(regs, 0x1a);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (notify_die(DIE_TRAP, &quot;memory corruption precise exception&quot;, regs,
 		       0, 0x8, SIGSEGV) == NOTIFY_STOP)
 		return;
<span class="p_header">diff --git a/arch/sparc/mm/gup.c b/arch/sparc/mm/gup.c</span>
<span class="p_header">index cd0e32b..579f7ae 100644</span>
<span class="p_header">--- a/arch/sparc/mm/gup.c</span>
<span class="p_header">+++ b/arch/sparc/mm/gup.c</span>
<span class="p_chunk">@@ -11,6 +11,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/pagemap.h&gt;
 #include &lt;linux/rwsem.h&gt;
 #include &lt;asm/pgtable.h&gt;
<span class="p_add">+#include &lt;asm/adi.h&gt;</span>
 
 /*
  * The performance critical leaf functions are made noinline otherwise gcc
<span class="p_chunk">@@ -157,6 +158,24 @@</span> <span class="p_context"> int __get_user_pages_fast(unsigned long start, int nr_pages, int write,</span>
 	pgd_t *pgdp;
 	int nr = 0;
 
<span class="p_add">+#ifdef CONFIG_SPARC64</span>
<span class="p_add">+	if (adi_capable()) {</span>
<span class="p_add">+		long addr = start;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* If userspace has passed a versioned address, kernel</span>
<span class="p_add">+		 * will not find it in the VMAs since it does not store</span>
<span class="p_add">+		 * the version tags in the list of VMAs. Storing version</span>
<span class="p_add">+		 * tags in list of VMAs is impractical since they can be</span>
<span class="p_add">+		 * changed any time from userspace without dropping into</span>
<span class="p_add">+		 * kernel. Any address search in VMAs will be done with</span>
<span class="p_add">+		 * non-versioned addresses. Ensure the ADI version bits</span>
<span class="p_add">+		 * are dropped here by sign extending the last bit before</span>
<span class="p_add">+		 * ADI bits. IOMMU does not implement version tags.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		addr = (addr &lt;&lt; (long)adi_nbits()) &gt;&gt; (long)adi_nbits();</span>
<span class="p_add">+		start = addr;</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
 	start &amp;= PAGE_MASK;
 	addr = start;
 	len = (unsigned long) nr_pages &lt;&lt; PAGE_SHIFT;
<span class="p_chunk">@@ -187,6 +206,24 @@</span> <span class="p_context"> int get_user_pages_fast(unsigned long start, int nr_pages, int write,</span>
 	pgd_t *pgdp;
 	int nr = 0;
 
<span class="p_add">+#ifdef CONFIG_SPARC64</span>
<span class="p_add">+	if (adi_capable()) {</span>
<span class="p_add">+		long addr = start;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* If userspace has passed a versioned address, kernel</span>
<span class="p_add">+		 * will not find it in the VMAs since it does not store</span>
<span class="p_add">+		 * the version tags in the list of VMAs. Storing version</span>
<span class="p_add">+		 * tags in list of VMAs is impractical since they can be</span>
<span class="p_add">+		 * changed any time from userspace without dropping into</span>
<span class="p_add">+		 * kernel. Any address search in VMAs will be done with</span>
<span class="p_add">+		 * non-versioned addresses. Ensure the ADI version bits</span>
<span class="p_add">+		 * are dropped here by sign extending the last bit before</span>
<span class="p_add">+		 * ADI bits. IOMMU does not implements version tags,</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		addr = (addr &lt;&lt; (long)adi_nbits()) &gt;&gt; (long)adi_nbits();</span>
<span class="p_add">+		start = addr;</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
 	start &amp;= PAGE_MASK;
 	addr = start;
 	len = (unsigned long) nr_pages &lt;&lt; PAGE_SHIFT;
<span class="p_header">diff --git a/arch/sparc/mm/tlb.c b/arch/sparc/mm/tlb.c</span>
<span class="p_header">index c56a195..557f2c38 100644</span>
<span class="p_header">--- a/arch/sparc/mm/tlb.c</span>
<span class="p_header">+++ b/arch/sparc/mm/tlb.c</span>
<span class="p_chunk">@@ -15,6 +15,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/cacheflush.h&gt;
 #include &lt;asm/mmu_context.h&gt;
 #include &lt;asm/tlb.h&gt;
<span class="p_add">+#include &lt;asm/asi.h&gt;</span>
 
 /* Heavily inspired by the ppc64 code.  */
 
<span class="p_chunk">@@ -142,6 +143,33 @@</span> <span class="p_context"> void tlb_batch_add(struct mm_struct *mm, unsigned long vaddr,</span>
 		tlb_batch_add_one(mm, vaddr, pte_exec(orig), huge);
 }
 
<span class="p_add">+pte_t ptep_clear_flush(struct vm_area_struct *vma, unsigned long address,</span>
<span class="p_add">+		       pte_t *ptep)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mm_struct *mm = (vma)-&gt;vm_mm;</span>
<span class="p_add">+	pte_t pte;</span>
<span class="p_add">+</span>
<span class="p_add">+	pte = *ptep;</span>
<span class="p_add">+	/* If we are getting ready to swap out a page with ADI enabled</span>
<span class="p_add">+	 * and version tags set, save the version tags so we can restore</span>
<span class="p_add">+	 * them when page is swapped back in.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (pte_val(pte) &amp; _PAGE_MCD_4V) {</span>
<span class="p_add">+		unsigned long version, paddr;</span>
<span class="p_add">+</span>
<span class="p_add">+		paddr = pte_val(pte) &amp; _PAGE_PADDR_4V;</span>
<span class="p_add">+		asm volatile(</span>
<span class="p_add">+			&quot;ldxa [%1] %2, %0\n\t&quot;</span>
<span class="p_add">+			: &quot;=r&quot; (version)</span>
<span class="p_add">+			: &quot;r&quot; (paddr), &quot;i&quot; (ASI_MCD_REAL));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pte = ptep_get_and_clear(mm, address, ptep);</span>
<span class="p_add">+	if (pte_accessible(mm, pte))</span>
<span class="p_add">+		flush_tlb_page(vma, address);</span>
<span class="p_add">+	return pte;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
 static void tlb_batch_pmd_scan(struct mm_struct *mm, unsigned long vaddr,
 			       pmd_t pmd)
<span class="p_header">diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="p_header">index a92c8d7..5c894a5 100644</span>
<span class="p_header">--- a/include/linux/mm.h</span>
<span class="p_header">+++ b/include/linux/mm.h</span>
<span class="p_chunk">@@ -225,6 +225,8 @@</span> <span class="p_context"> extern unsigned int kobjsize(const void *objp);</span>
 # define VM_GROWSUP	VM_ARCH_1
 #elif defined(CONFIG_IA64)
 # define VM_GROWSUP	VM_ARCH_1
<span class="p_add">+#elif defined(CONFIG_SPARC64)</span>
<span class="p_add">+# define VM_SPARC_ADI	VM_ARCH_1	/* Uses ADI tag for access control */</span>
 #elif !defined(CONFIG_MMU)
 # define VM_MAPPED_COPY	VM_ARCH_1	/* T if mapped copy of data (nommu mmap) */
 #endif

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



