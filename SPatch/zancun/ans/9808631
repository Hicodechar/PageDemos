
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.18.58 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.18.58</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 26, 2017, 5:28 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170626052822.GB16149@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9808631/mbox/"
   >mbox</a>
|
   <a href="/patch/9808631/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9808631/">/patch/9808631/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	5D72460209 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 26 Jun 2017 05:29:46 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 57BEF27FAD
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 26 Jun 2017 05:29:46 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 4B9C228414; Mon, 26 Jun 2017 05:29:46 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 46D6227FAD
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 26 Jun 2017 05:29:43 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751426AbdFZF3h (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 26 Jun 2017 01:29:37 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:60908 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1750788AbdFZF32 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 26 Jun 2017 01:29:28 -0400
Received: from localhost (mobile-166-170-37-177.mycingular.net
	[166.170.37.177])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id D7E9F486;
	Mon, 26 Jun 2017 05:29:22 +0000 (UTC)
Date: Mon, 26 Jun 2017 07:28:22 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 3.18.58
Message-ID: &lt;20170626052822.GB16149@kroah.com&gt;
References: &lt;20170626052816.GA16149@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170626052816.GA16149@kroah.com&gt;
User-Agent: Mutt/1.8.3 (2017-05-23)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - June 26, 2017, 5:28 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt</span>
<span class="p_header">index b2bdea1953e6..9abe55280cf6 100644</span>
<span class="p_header">--- a/Documentation/kernel-parameters.txt</span>
<span class="p_header">+++ b/Documentation/kernel-parameters.txt</span>
<span class="p_chunk">@@ -3324,6 +3324,13 @@</span> <span class="p_context"> bytes respectively. Such letter suffixes can also be entirely omitted.</span>
 	spia_pedr=
 	spia_peddr=
 
<span class="p_add">+	stack_guard_gap=	[MM]</span>
<span class="p_add">+			override the default stack gap protection. The value</span>
<span class="p_add">+			is in page units and it defines how many pages prior</span>
<span class="p_add">+			to (for stacks growing down) resp. after (for stacks</span>
<span class="p_add">+			growing up) the main stack are reserved for no other</span>
<span class="p_add">+			mapping. Default value is 256 pages.</span>
<span class="p_add">+</span>
 	stacktrace	[FTRACE]
 			Enabled the stack tracer on boot up.
 
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 8ad497f954d7..e44d3f45b72a 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 18
<span class="p_del">-SUBLEVEL = 57</span>
<span class="p_add">+SUBLEVEL = 58</span>
 EXTRAVERSION =
 NAME = Diseased Newt
 
<span class="p_header">diff --git a/arch/arc/mm/mmap.c b/arch/arc/mm/mmap.c</span>
<span class="p_header">index 2e06d56e987b..cf4ae6958240 100644</span>
<span class="p_header">--- a/arch/arc/mm/mmap.c</span>
<span class="p_header">+++ b/arch/arc/mm/mmap.c</span>
<span class="p_chunk">@@ -64,7 +64,7 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/arm/mm/mmap.c b/arch/arm/mm/mmap.c</span>
<span class="p_header">index 5e85ed371364..8f9d1cf505dd 100644</span>
<span class="p_header">--- a/arch/arm/mm/mmap.c</span>
<span class="p_header">+++ b/arch/arm/mm/mmap.c</span>
<span class="p_chunk">@@ -89,7 +89,7 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -140,7 +140,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 			addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-				(!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+				(!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/frv/mm/elf-fdpic.c b/arch/frv/mm/elf-fdpic.c</span>
<span class="p_header">index 836f14707a62..efa59f1f8022 100644</span>
<span class="p_header">--- a/arch/frv/mm/elf-fdpic.c</span>
<span class="p_header">+++ b/arch/frv/mm/elf-fdpic.c</span>
<span class="p_chunk">@@ -74,7 +74,7 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr, unsi</span>
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(current-&gt;mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			goto success;
 	}
 
<span class="p_header">diff --git a/arch/mips/mm/mmap.c b/arch/mips/mm/mmap.c</span>
<span class="p_header">index f1baadd56e82..9be924f08f34 100644</span>
<span class="p_header">--- a/arch/mips/mm/mmap.c</span>
<span class="p_header">+++ b/arch/mips/mm/mmap.c</span>
<span class="p_chunk">@@ -92,7 +92,7 @@</span> <span class="p_context"> static unsigned long arch_get_unmapped_area_common(struct file *filp,</span>
 
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/parisc/kernel/sys_parisc.c b/arch/parisc/kernel/sys_parisc.c</span>
<span class="p_header">index 5aba01ac457f..4dda73c44fee 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/sys_parisc.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/sys_parisc.c</span>
<span class="p_chunk">@@ -88,7 +88,7 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		unsigned long len, unsigned long pgoff, unsigned long flags)
 {
 	struct mm_struct *mm = current-&gt;mm;
<span class="p_del">-	struct vm_area_struct *vma;</span>
<span class="p_add">+	struct vm_area_struct *vma, *prev;</span>
 	unsigned long task_size = TASK_SIZE;
 	int do_color_align, last_mmap;
 	struct vm_unmapped_area_info info;
<span class="p_chunk">@@ -115,9 +115,10 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		else
 			addr = PAGE_ALIGN(addr);
 
<span class="p_del">-		vma = find_vma(mm, addr);</span>
<span class="p_add">+		vma = find_vma_prev(mm, addr, &amp;prev);</span>
 		if (task_size - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)) &amp;&amp;</span>
<span class="p_add">+		    (!prev || addr &gt;= vm_end_gap(prev)))</span>
 			goto found_addr;
 	}
 
<span class="p_chunk">@@ -141,7 +142,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 			  const unsigned long len, const unsigned long pgoff,
 			  const unsigned long flags)
 {
<span class="p_del">-	struct vm_area_struct *vma;</span>
<span class="p_add">+	struct vm_area_struct *vma, *prev;</span>
 	struct mm_struct *mm = current-&gt;mm;
 	unsigned long addr = addr0;
 	int do_color_align, last_mmap;
<span class="p_chunk">@@ -175,9 +176,11 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 			addr = COLOR_ALIGN(addr, last_mmap, pgoff);
 		else
 			addr = PAGE_ALIGN(addr);
<span class="p_del">-		vma = find_vma(mm, addr);</span>
<span class="p_add">+</span>
<span class="p_add">+		vma = find_vma_prev(mm, addr, &amp;prev);</span>
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)) &amp;&amp;</span>
<span class="p_add">+		    (!prev || addr &gt;= vm_end_gap(prev)))</span>
 			goto found_addr;
 	}
 
<span class="p_header">diff --git a/arch/powerpc/mm/slice.c b/arch/powerpc/mm/slice.c</span>
<span class="p_header">index ded0ea1afde4..4c1462611576 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/slice.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/slice.c</span>
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> static int slice_area_is_free(struct mm_struct *mm, unsigned long addr,</span>
 	if ((mm-&gt;task_size - len) &lt; addr)
 		return 0;
 	vma = find_vma(mm, addr);
<span class="p_del">-	return (!vma || (addr + len) &lt;= vma-&gt;vm_start);</span>
<span class="p_add">+	return (!vma || (addr + len) &lt;= vm_start_gap(vma));</span>
 }
 
 static int slice_low_has_vma(struct mm_struct *mm, unsigned long slice)
<span class="p_header">diff --git a/arch/s390/mm/vmem.c b/arch/s390/mm/vmem.c</span>
<span class="p_header">index b1593c2f751a..9dcb55f8afc0 100644</span>
<span class="p_header">--- a/arch/s390/mm/vmem.c</span>
<span class="p_header">+++ b/arch/s390/mm/vmem.c</span>
<span class="p_chunk">@@ -378,7 +378,7 @@</span> <span class="p_context"> void __init vmem_map_init(void)</span>
 	ro_end = (unsigned long)&amp;_eshared &amp; PAGE_MASK;
 	for_each_memblock(memory, reg) {
 		start = reg-&gt;base;
<span class="p_del">-		end = reg-&gt;base + reg-&gt;size - 1;</span>
<span class="p_add">+		end = reg-&gt;base + reg-&gt;size;</span>
 		if (start &gt;= ro_end || end &lt;= ro_start)
 			vmem_add_mem(start, end - start, 0);
 		else if (start &gt;= ro_start &amp;&amp; end &lt;= ro_end)
<span class="p_header">diff --git a/arch/sh/mm/mmap.c b/arch/sh/mm/mmap.c</span>
<span class="p_header">index 6777177807c2..7df7d5944188 100644</span>
<span class="p_header">--- a/arch/sh/mm/mmap.c</span>
<span class="p_header">+++ b/arch/sh/mm/mmap.c</span>
<span class="p_chunk">@@ -63,7 +63,7 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/sparc/kernel/sys_sparc_64.c b/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_header">index c690c8e16a96..7f0f7c01b297 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_chunk">@@ -118,7 +118,7 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr, unsi</span>
 
 		vma = find_vma(mm, addr);
 		if (task_size - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -181,7 +181,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 
 		vma = find_vma(mm, addr);
 		if (task_size - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/sparc/kernel/traps_64.c b/arch/sparc/kernel/traps_64.c</span>
<span class="p_header">index 981a769b9558..21fc668a19a8 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/traps_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/traps_64.c</span>
<span class="p_chunk">@@ -85,7 +85,7 @@</span> <span class="p_context"> static void dump_tl1_traplog(struct tl1_traplog *p)</span>
 
 void bad_trap(struct pt_regs *regs, long lvl)
 {
<span class="p_del">-	char buffer[32];</span>
<span class="p_add">+	char buffer[36];</span>
 	siginfo_t info;
 
 	if (notify_die(DIE_TRAP, &quot;bad trap&quot;, regs,
<span class="p_chunk">@@ -116,7 +116,7 @@</span> <span class="p_context"> void bad_trap(struct pt_regs *regs, long lvl)</span>
 
 void bad_trap_tl1(struct pt_regs *regs, long lvl)
 {
<span class="p_del">-	char buffer[32];</span>
<span class="p_add">+	char buffer[36];</span>
 	
 	if (notify_die(DIE_TRAP_TL1, &quot;bad trap tl1&quot;, regs,
 		       0, lvl, SIGTRAP) == NOTIFY_STOP)
<span class="p_header">diff --git a/arch/sparc/mm/hugetlbpage.c b/arch/sparc/mm/hugetlbpage.c</span>
<span class="p_header">index 4242eab12e10..2b6fae615fb1 100644</span>
<span class="p_header">--- a/arch/sparc/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/sparc/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -115,7 +115,7 @@</span> <span class="p_context"> hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 		addr = ALIGN(addr, HPAGE_SIZE);
 		vma = find_vma(mm, addr);
 		if (task_size - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 	if (mm-&gt;get_unmapped_area == arch_get_unmapped_area)
<span class="p_header">diff --git a/arch/tile/mm/hugetlbpage.c b/arch/tile/mm/hugetlbpage.c</span>
<span class="p_header">index 8a00c7b7b862..52deac203eac 100644</span>
<span class="p_header">--- a/arch/tile/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/tile/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -237,7 +237,7 @@</span> <span class="p_context"> unsigned long hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 		addr = ALIGN(addr, huge_page_size(h));
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 	if (current-&gt;mm-&gt;get_unmapped_area == arch_get_unmapped_area)
<span class="p_header">diff --git a/arch/x86/kernel/sys_x86_64.c b/arch/x86/kernel/sys_x86_64.c</span>
<span class="p_header">index 30277e27431a..d050393d3be2 100644</span>
<span class="p_header">--- a/arch/x86/kernel/sys_x86_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/sys_x86_64.c</span>
<span class="p_chunk">@@ -127,7 +127,7 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (end - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -166,7 +166,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-				(!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+				(!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/x86/mm/hugetlbpage.c b/arch/x86/mm/hugetlbpage.c</span>
<span class="p_header">index 9161f764121e..c504866dc807 100644</span>
<span class="p_header">--- a/arch/x86/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/x86/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -144,7 +144,7 @@</span> <span class="p_context"> hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 		addr = ALIGN(addr, huge_page_size(h));
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 	if (mm-&gt;get_unmapped_area == arch_get_unmapped_area)
<span class="p_header">diff --git a/arch/x86/mm/numa_32.c b/arch/x86/mm/numa_32.c</span>
<span class="p_header">index 47b6436e41c2..3686a1db25b2 100644</span>
<span class="p_header">--- a/arch/x86/mm/numa_32.c</span>
<span class="p_header">+++ b/arch/x86/mm/numa_32.c</span>
<span class="p_chunk">@@ -100,5 +100,6 @@</span> <span class="p_context"> void __init initmem_init(void)</span>
 	printk(KERN_DEBUG &quot;High memory starts at vaddr %08lx\n&quot;,
 			(ulong) pfn_to_kaddr(highstart_pfn));
 
<span class="p_add">+	__vmalloc_start_set = true;</span>
 	setup_bootmem_allocator();
 }
<span class="p_header">diff --git a/arch/xtensa/kernel/syscall.c b/arch/xtensa/kernel/syscall.c</span>
<span class="p_header">index 5d3f7a119ed1..1ff0b92eeae7 100644</span>
<span class="p_header">--- a/arch/xtensa/kernel/syscall.c</span>
<span class="p_header">+++ b/arch/xtensa/kernel/syscall.c</span>
<span class="p_chunk">@@ -86,7 +86,7 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		/* At this point:  (!vmm || addr &lt; vmm-&gt;vm_end). */
 		if (TASK_SIZE - len &lt; addr)
 			return -ENOMEM;
<span class="p_del">-		if (!vmm || addr + len &lt;= vmm-&gt;vm_start)</span>
<span class="p_add">+		if (!vmm || addr + len &lt;= vm_start_gap(vmm))</span>
 			return addr;
 		addr = vmm-&gt;vm_end;
 		if (flags &amp; MAP_SHARED)
<span class="p_header">diff --git a/block/partitions/msdos.c b/block/partitions/msdos.c</span>
<span class="p_header">index 93e7c1b32edd..5610cd537da7 100644</span>
<span class="p_header">--- a/block/partitions/msdos.c</span>
<span class="p_header">+++ b/block/partitions/msdos.c</span>
<span class="p_chunk">@@ -300,6 +300,8 @@</span> <span class="p_context"> static void parse_bsd(struct parsed_partitions *state,</span>
 			continue;
 		bsd_start = le32_to_cpu(p-&gt;p_offset);
 		bsd_size = le32_to_cpu(p-&gt;p_size);
<span class="p_add">+		if (memcmp(flavour, &quot;bsd\0&quot;, 4) == 0)</span>
<span class="p_add">+			bsd_start += offset;</span>
 		if (offset == bsd_start &amp;&amp; size == bsd_size)
 			/* full parent partition, we have it already */
 			continue;
<span class="p_header">diff --git a/drivers/cpufreq/cpufreq_conservative.c b/drivers/cpufreq/cpufreq_conservative.c</span>
<span class="p_header">index 25a70d06c5bf..55836a538a68 100644</span>
<span class="p_header">--- a/drivers/cpufreq/cpufreq_conservative.c</span>
<span class="p_header">+++ b/drivers/cpufreq/cpufreq_conservative.c</span>
<span class="p_chunk">@@ -204,8 +204,8 @@</span> <span class="p_context"> static ssize_t store_down_threshold(struct dbs_data *dbs_data, const char *buf,</span>
 	int ret;
 	ret = sscanf(buf, &quot;%u&quot;, &amp;input);
 
<span class="p_del">-	/* cannot be lower than 11 otherwise freq will not fall */</span>
<span class="p_del">-	if (ret != 1 || input &lt; 11 || input &gt; 100 ||</span>
<span class="p_add">+	/* cannot be lower than 1 otherwise freq will not fall */</span>
<span class="p_add">+	if (ret != 1 || input &lt; 1 || input &gt; 100 ||</span>
 			input &gt;= cs_tuners-&gt;up_threshold)
 		return -EINVAL;
 
<span class="p_header">diff --git a/drivers/iio/proximity/as3935.c b/drivers/iio/proximity/as3935.c</span>
<span class="p_header">index f056767d95a5..4158d7e431b4 100644</span>
<span class="p_header">--- a/drivers/iio/proximity/as3935.c</span>
<span class="p_header">+++ b/drivers/iio/proximity/as3935.c</span>
<span class="p_chunk">@@ -256,8 +256,6 @@</span> <span class="p_context"> static irqreturn_t as3935_interrupt_handler(int irq, void *private)</span>
 
 static void calibrate_as3935(struct as3935_state *st)
 {
<span class="p_del">-	mutex_lock(&amp;st-&gt;lock);</span>
<span class="p_del">-</span>
 	/* mask disturber interrupt bit */
 	as3935_write(st, AS3935_INT, BIT(5));
 
<span class="p_chunk">@@ -267,8 +265,6 @@</span> <span class="p_context"> static void calibrate_as3935(struct as3935_state *st)</span>
 
 	mdelay(2);
 	as3935_write(st, AS3935_TUNE_CAP, (st-&gt;tune_cap / TUNE_CAP_DIV));
<span class="p_del">-</span>
<span class="p_del">-	mutex_unlock(&amp;st-&gt;lock);</span>
 }
 
 #ifdef CONFIG_PM_SLEEP
<span class="p_chunk">@@ -305,6 +301,8 @@</span> <span class="p_context"> static int as3935_resume(struct spi_device *spi)</span>
 	val &amp;= ~AS3935_AFE_PWR_BIT;
 	ret = as3935_write(st, AS3935_AFE_GAIN, val);
 
<span class="p_add">+	calibrate_as3935(st);</span>
<span class="p_add">+</span>
 err_resume:
 	mutex_unlock(&amp;st-&gt;lock);
 
<span class="p_header">diff --git a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.c b/drivers/media/usb/pvrusb2/pvrusb2-eeprom.c</span>
<span class="p_header">index 9515f3a68f8f..122815e1cb65 100644</span>
<span class="p_header">--- a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.c</span>
<span class="p_header">+++ b/drivers/media/usb/pvrusb2/pvrusb2-eeprom.c</span>
<span class="p_chunk">@@ -123,15 +123,10 @@</span> <span class="p_context"> int pvr2_eeprom_analyze(struct pvr2_hdw *hdw)</span>
 	memset(&amp;tvdata,0,sizeof(tvdata));
 
 	eeprom = pvr2_eeprom_fetch(hdw);
<span class="p_del">-	if (!eeprom) return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	{</span>
<span class="p_del">-		struct i2c_client fake_client;</span>
<span class="p_del">-		/* Newer version expects a useless client interface */</span>
<span class="p_del">-		fake_client.addr = hdw-&gt;eeprom_addr;</span>
<span class="p_del">-		fake_client.adapter = &amp;hdw-&gt;i2c_adap;</span>
<span class="p_del">-		tveeprom_hauppauge_analog(&amp;fake_client,&amp;tvdata,eeprom);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (!eeprom)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	tveeprom_hauppauge_analog(NULL, &amp;tvdata, eeprom);</span>
 
 	trace_eeprom(&quot;eeprom assumed v4l tveeprom module&quot;);
 	trace_eeprom(&quot;eeprom direct call results:&quot;);
<span class="p_header">diff --git a/drivers/media/v4l2-core/videobuf2-core.c b/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_header">index 1c2cc6fee351..d5c300150cf4 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_chunk">@@ -1120,7 +1120,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(vb2_create_bufs);</span>
  */
 void *vb2_plane_vaddr(struct vb2_buffer *vb, unsigned int plane_no)
 {
<span class="p_del">-	if (plane_no &gt; vb-&gt;num_planes || !vb-&gt;planes[plane_no].mem_priv)</span>
<span class="p_add">+	if (plane_no &gt;= vb-&gt;num_planes || !vb-&gt;planes[plane_no].mem_priv)</span>
 		return NULL;
 
 	return call_ptr_memop(vb, vaddr, vb-&gt;planes[plane_no].mem_priv);
<span class="p_header">diff --git a/drivers/mfd/omap-usb-tll.c b/drivers/mfd/omap-usb-tll.c</span>
<span class="p_header">index 0f8cd6bbe914..1224921217f2 100644</span>
<span class="p_header">--- a/drivers/mfd/omap-usb-tll.c</span>
<span class="p_header">+++ b/drivers/mfd/omap-usb-tll.c</span>
<span class="p_chunk">@@ -376,8 +376,8 @@</span> <span class="p_context"> int omap_tll_init(struct usbhs_omap_platform_data *pdata)</span>
 				 * and use SDR Mode
 				 */
 				reg &amp;= ~(OMAP_TLL_CHANNEL_CONF_UTMIAUTOIDLE
<span class="p_del">-					| OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF</span>
 					| OMAP_TLL_CHANNEL_CONF_ULPIDDRMODE);
<span class="p_add">+				reg |= OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF;</span>
 			} else if (pdata-&gt;port_mode[i] ==
 					OMAP_EHCI_PORT_MODE_HSIC) {
 				/*
<span class="p_header">diff --git a/drivers/misc/c2port/c2port-duramar2150.c b/drivers/misc/c2port/c2port-duramar2150.c</span>
<span class="p_header">index 5484301d57d9..3dc61ea7dc64 100644</span>
<span class="p_header">--- a/drivers/misc/c2port/c2port-duramar2150.c</span>
<span class="p_header">+++ b/drivers/misc/c2port/c2port-duramar2150.c</span>
<span class="p_chunk">@@ -129,8 +129,8 @@</span> <span class="p_context"> static int __init duramar2150_c2port_init(void)</span>
 
 	duramar2150_c2port_dev = c2port_device_register(&quot;uc&quot;,
 					&amp;duramar2150_c2port_ops, NULL);
<span class="p_del">-	if (!duramar2150_c2port_dev) {</span>
<span class="p_del">-		ret = -ENODEV;</span>
<span class="p_add">+	if (IS_ERR(duramar2150_c2port_dev)) {</span>
<span class="p_add">+		ret = PTR_ERR(duramar2150_c2port_dev);</span>
 		goto free_region;
 	}
 
<span class="p_header">diff --git a/drivers/net/can/usb/gs_usb.c b/drivers/net/can/usb/gs_usb.c</span>
<span class="p_header">index 09c23a5ba1d4..991aff587f63 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/gs_usb.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/gs_usb.c</span>
<span class="p_chunk">@@ -246,6 +246,8 @@</span> <span class="p_context"> static int gs_cmd_reset(struct gs_usb *gsusb, struct gs_can *gsdev)</span>
 			     sizeof(*dm),
 			     1000);
 
<span class="p_add">+	kfree(dm);</span>
<span class="p_add">+</span>
 	return rc;
 }
 
<span class="p_header">diff --git a/drivers/net/ethernet/xilinx/xilinx_emaclite.c b/drivers/net/ethernet/xilinx/xilinx_emaclite.c</span>
<span class="p_header">index 28dbbdc393eb..d4e610b94dd8 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/xilinx/xilinx_emaclite.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/xilinx/xilinx_emaclite.c</span>
<span class="p_chunk">@@ -100,6 +100,14 @@</span> <span class="p_context"></span>
 /* BUFFER_ALIGN(adr) calculates the number of bytes to the next alignment. */
 #define BUFFER_ALIGN(adr) ((ALIGNMENT - ((u32) adr)) % ALIGNMENT)
 
<span class="p_add">+#ifdef __BIG_ENDIAN</span>
<span class="p_add">+#define xemaclite_readl		ioread32be</span>
<span class="p_add">+#define xemaclite_writel	iowrite32be</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define xemaclite_readl		ioread32</span>
<span class="p_add">+#define xemaclite_writel	iowrite32</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /**
  * struct net_local - Our private per device data
  * @ndev:		instance of the network device
<span class="p_chunk">@@ -158,15 +166,15 @@</span> <span class="p_context"> static void xemaclite_enable_interrupts(struct net_local *drvdata)</span>
 	u32 reg_data;
 
 	/* Enable the Tx interrupts for the first Buffer */
<span class="p_del">-	reg_data = __raw_readl(drvdata-&gt;base_addr + XEL_TSR_OFFSET);</span>
<span class="p_del">-	__raw_writel(reg_data | XEL_TSR_XMIT_IE_MASK,</span>
<span class="p_del">-		     drvdata-&gt;base_addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+	reg_data = xemaclite_readl(drvdata-&gt;base_addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(reg_data | XEL_TSR_XMIT_IE_MASK,</span>
<span class="p_add">+			 drvdata-&gt;base_addr + XEL_TSR_OFFSET);</span>
 
 	/* Enable the Rx interrupts for the first buffer */
<span class="p_del">-	__raw_writel(XEL_RSR_RECV_IE_MASK, drvdata-&gt;base_addr + XEL_RSR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(XEL_RSR_RECV_IE_MASK, drvdata-&gt;base_addr + XEL_RSR_OFFSET);</span>
 
 	/* Enable the Global Interrupt Enable */
<span class="p_del">-	__raw_writel(XEL_GIER_GIE_MASK, drvdata-&gt;base_addr + XEL_GIER_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(XEL_GIER_GIE_MASK, drvdata-&gt;base_addr + XEL_GIER_OFFSET);</span>
 }
 
 /**
<span class="p_chunk">@@ -181,17 +189,17 @@</span> <span class="p_context"> static void xemaclite_disable_interrupts(struct net_local *drvdata)</span>
 	u32 reg_data;
 
 	/* Disable the Global Interrupt Enable */
<span class="p_del">-	__raw_writel(XEL_GIER_GIE_MASK, drvdata-&gt;base_addr + XEL_GIER_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(XEL_GIER_GIE_MASK, drvdata-&gt;base_addr + XEL_GIER_OFFSET);</span>
 
 	/* Disable the Tx interrupts for the first buffer */
<span class="p_del">-	reg_data = __raw_readl(drvdata-&gt;base_addr + XEL_TSR_OFFSET);</span>
<span class="p_del">-	__raw_writel(reg_data &amp; (~XEL_TSR_XMIT_IE_MASK),</span>
<span class="p_del">-		     drvdata-&gt;base_addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+	reg_data = xemaclite_readl(drvdata-&gt;base_addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(reg_data &amp; (~XEL_TSR_XMIT_IE_MASK),</span>
<span class="p_add">+			 drvdata-&gt;base_addr + XEL_TSR_OFFSET);</span>
 
 	/* Disable the Rx interrupts for the first buffer */
<span class="p_del">-	reg_data = __raw_readl(drvdata-&gt;base_addr + XEL_RSR_OFFSET);</span>
<span class="p_del">-	__raw_writel(reg_data &amp; (~XEL_RSR_RECV_IE_MASK),</span>
<span class="p_del">-		     drvdata-&gt;base_addr + XEL_RSR_OFFSET);</span>
<span class="p_add">+	reg_data = xemaclite_readl(drvdata-&gt;base_addr + XEL_RSR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(reg_data &amp; (~XEL_RSR_RECV_IE_MASK),</span>
<span class="p_add">+			 drvdata-&gt;base_addr + XEL_RSR_OFFSET);</span>
 }
 
 /**
<span class="p_chunk">@@ -323,7 +331,7 @@</span> <span class="p_context"> static int xemaclite_send_data(struct net_local *drvdata, u8 *data,</span>
 		byte_count = ETH_FRAME_LEN;
 
 	/* Check if the expected buffer is available */
<span class="p_del">-	reg_data = __raw_readl(addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+	reg_data = xemaclite_readl(addr + XEL_TSR_OFFSET);</span>
 	if ((reg_data &amp; (XEL_TSR_XMIT_BUSY_MASK |
 	     XEL_TSR_XMIT_ACTIVE_MASK)) == 0) {
 
<span class="p_chunk">@@ -336,7 +344,7 @@</span> <span class="p_context"> static int xemaclite_send_data(struct net_local *drvdata, u8 *data,</span>
 
 		addr = (void __iomem __force *)((u32 __force)addr ^
 						 XEL_BUFFER_OFFSET);
<span class="p_del">-		reg_data = __raw_readl(addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+		reg_data = xemaclite_readl(addr + XEL_TSR_OFFSET);</span>
 
 		if ((reg_data &amp; (XEL_TSR_XMIT_BUSY_MASK |
 		     XEL_TSR_XMIT_ACTIVE_MASK)) != 0)
<span class="p_chunk">@@ -347,16 +355,16 @@</span> <span class="p_context"> static int xemaclite_send_data(struct net_local *drvdata, u8 *data,</span>
 	/* Write the frame to the buffer */
 	xemaclite_aligned_write(data, (u32 __force *) addr, byte_count);
 
<span class="p_del">-	__raw_writel((byte_count &amp; XEL_TPLR_LENGTH_MASK),</span>
<span class="p_del">-		     addr + XEL_TPLR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel((byte_count &amp; XEL_TPLR_LENGTH_MASK),</span>
<span class="p_add">+			 addr + XEL_TPLR_OFFSET);</span>
 
 	/* Update the Tx Status Register to indicate that there is a
 	 * frame to send. Set the XEL_TSR_XMIT_ACTIVE_MASK flag which
 	 * is used by the interrupt handler to check whether a frame
 	 * has been transmitted */
<span class="p_del">-	reg_data = __raw_readl(addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+	reg_data = xemaclite_readl(addr + XEL_TSR_OFFSET);</span>
 	reg_data |= (XEL_TSR_XMIT_BUSY_MASK | XEL_TSR_XMIT_ACTIVE_MASK);
<span class="p_del">-	__raw_writel(reg_data, addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(reg_data, addr + XEL_TSR_OFFSET);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -371,7 +379,7 @@</span> <span class="p_context"> static int xemaclite_send_data(struct net_local *drvdata, u8 *data,</span>
  *
  * Return:	Total number of bytes received
  */
<span class="p_del">-static u16 xemaclite_recv_data(struct net_local *drvdata, u8 *data)</span>
<span class="p_add">+static u16 xemaclite_recv_data(struct net_local *drvdata, u8 *data, int maxlen)</span>
 {
 	void __iomem *addr;
 	u16 length, proto_type;
<span class="p_chunk">@@ -381,7 +389,7 @@</span> <span class="p_context"> static u16 xemaclite_recv_data(struct net_local *drvdata, u8 *data)</span>
 	addr = (drvdata-&gt;base_addr + drvdata-&gt;next_rx_buf_to_use);
 
 	/* Verify which buffer has valid data */
<span class="p_del">-	reg_data = __raw_readl(addr + XEL_RSR_OFFSET);</span>
<span class="p_add">+	reg_data = xemaclite_readl(addr + XEL_RSR_OFFSET);</span>
 
 	if ((reg_data &amp; XEL_RSR_RECV_DONE_MASK) == XEL_RSR_RECV_DONE_MASK) {
 		if (drvdata-&gt;rx_ping_pong != 0)
<span class="p_chunk">@@ -398,27 +406,28 @@</span> <span class="p_context"> static u16 xemaclite_recv_data(struct net_local *drvdata, u8 *data)</span>
 			return 0;	/* No data was available */
 
 		/* Verify that buffer has valid data */
<span class="p_del">-		reg_data = __raw_readl(addr + XEL_RSR_OFFSET);</span>
<span class="p_add">+		reg_data = xemaclite_readl(addr + XEL_RSR_OFFSET);</span>
 		if ((reg_data &amp; XEL_RSR_RECV_DONE_MASK) !=
 		     XEL_RSR_RECV_DONE_MASK)
 			return 0;	/* No data was available */
 	}
 
 	/* Get the protocol type of the ethernet frame that arrived */
<span class="p_del">-	proto_type = ((ntohl(__raw_readl(addr + XEL_HEADER_OFFSET +</span>
<span class="p_add">+	proto_type = ((ntohl(xemaclite_readl(addr + XEL_HEADER_OFFSET +</span>
 			XEL_RXBUFF_OFFSET)) &gt;&gt; XEL_HEADER_SHIFT) &amp;
 			XEL_RPLR_LENGTH_MASK);
 
 	/* Check if received ethernet frame is a raw ethernet frame
 	 * or an IP packet or an ARP packet */
<span class="p_del">-	if (proto_type &gt; (ETH_FRAME_LEN + ETH_FCS_LEN)) {</span>
<span class="p_add">+	if (proto_type &gt; ETH_DATA_LEN) {</span>
 
 		if (proto_type == ETH_P_IP) {
<span class="p_del">-			length = ((ntohl(__raw_readl(addr +</span>
<span class="p_add">+			length = ((ntohl(xemaclite_readl(addr +</span>
 					XEL_HEADER_IP_LENGTH_OFFSET +
 					XEL_RXBUFF_OFFSET)) &gt;&gt;
 					XEL_HEADER_SHIFT) &amp;
 					XEL_RPLR_LENGTH_MASK);
<span class="p_add">+			length = min_t(u16, length, ETH_DATA_LEN);</span>
 			length += ETH_HLEN + ETH_FCS_LEN;
 
 		} else if (proto_type == ETH_P_ARP)
<span class="p_chunk">@@ -431,14 +440,17 @@</span> <span class="p_context"> static u16 xemaclite_recv_data(struct net_local *drvdata, u8 *data)</span>
 		/* Use the length in the frame, plus the header and trailer */
 		length = proto_type + ETH_HLEN + ETH_FCS_LEN;
 
<span class="p_add">+	if (WARN_ON(length &gt; maxlen))</span>
<span class="p_add">+		length = maxlen;</span>
<span class="p_add">+</span>
 	/* Read from the EmacLite device */
 	xemaclite_aligned_read((u32 __force *) (addr + XEL_RXBUFF_OFFSET),
 				data, length);
 
 	/* Acknowledge the frame */
<span class="p_del">-	reg_data = __raw_readl(addr + XEL_RSR_OFFSET);</span>
<span class="p_add">+	reg_data = xemaclite_readl(addr + XEL_RSR_OFFSET);</span>
 	reg_data &amp;= ~XEL_RSR_RECV_DONE_MASK;
<span class="p_del">-	__raw_writel(reg_data, addr + XEL_RSR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(reg_data, addr + XEL_RSR_OFFSET);</span>
 
 	return length;
 }
<span class="p_chunk">@@ -465,14 +477,14 @@</span> <span class="p_context"> static void xemaclite_update_address(struct net_local *drvdata,</span>
 
 	xemaclite_aligned_write(address_ptr, (u32 __force *) addr, ETH_ALEN);
 
<span class="p_del">-	__raw_writel(ETH_ALEN, addr + XEL_TPLR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(ETH_ALEN, addr + XEL_TPLR_OFFSET);</span>
 
 	/* Update the MAC address in the EmacLite */
<span class="p_del">-	reg_data = __raw_readl(addr + XEL_TSR_OFFSET);</span>
<span class="p_del">-	__raw_writel(reg_data | XEL_TSR_PROG_MAC_ADDR, addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+	reg_data = xemaclite_readl(addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(reg_data | XEL_TSR_PROG_MAC_ADDR, addr + XEL_TSR_OFFSET);</span>
 
 	/* Wait for EmacLite to finish with the MAC address update */
<span class="p_del">-	while ((__raw_readl(addr + XEL_TSR_OFFSET) &amp;</span>
<span class="p_add">+	while ((xemaclite_readl(addr + XEL_TSR_OFFSET) &amp;</span>
 		XEL_TSR_PROG_MAC_ADDR) != 0)
 		;
 }
<span class="p_chunk">@@ -605,7 +617,7 @@</span> <span class="p_context"> static void xemaclite_rx_handler(struct net_device *dev)</span>
 
 	skb_reserve(skb, 2);
 
<span class="p_del">-	len = xemaclite_recv_data(lp, (u8 *) skb-&gt;data);</span>
<span class="p_add">+	len = xemaclite_recv_data(lp, (u8 *) skb-&gt;data, len);</span>
 
 	if (!len) {
 		dev-&gt;stats.rx_errors++;
<span class="p_chunk">@@ -642,32 +654,32 @@</span> <span class="p_context"> static irqreturn_t xemaclite_interrupt(int irq, void *dev_id)</span>
 	u32 tx_status;
 
 	/* Check if there is Rx Data available */
<span class="p_del">-	if ((__raw_readl(base_addr + XEL_RSR_OFFSET) &amp;</span>
<span class="p_add">+	if ((xemaclite_readl(base_addr + XEL_RSR_OFFSET) &amp;</span>
 			 XEL_RSR_RECV_DONE_MASK) ||
<span class="p_del">-	    (__raw_readl(base_addr + XEL_BUFFER_OFFSET + XEL_RSR_OFFSET)</span>
<span class="p_add">+	    (xemaclite_readl(base_addr + XEL_BUFFER_OFFSET + XEL_RSR_OFFSET)</span>
 			 &amp; XEL_RSR_RECV_DONE_MASK))
 
 		xemaclite_rx_handler(dev);
 
 	/* Check if the Transmission for the first buffer is completed */
<span class="p_del">-	tx_status = __raw_readl(base_addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+	tx_status = xemaclite_readl(base_addr + XEL_TSR_OFFSET);</span>
 	if (((tx_status &amp; XEL_TSR_XMIT_BUSY_MASK) == 0) &amp;&amp;
 		(tx_status &amp; XEL_TSR_XMIT_ACTIVE_MASK) != 0) {
 
 		tx_status &amp;= ~XEL_TSR_XMIT_ACTIVE_MASK;
<span class="p_del">-		__raw_writel(tx_status, base_addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+		xemaclite_writel(tx_status, base_addr + XEL_TSR_OFFSET);</span>
 
 		tx_complete = true;
 	}
 
 	/* Check if the Transmission for the second buffer is completed */
<span class="p_del">-	tx_status = __raw_readl(base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);</span>
<span class="p_add">+	tx_status = xemaclite_readl(base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);</span>
 	if (((tx_status &amp; XEL_TSR_XMIT_BUSY_MASK) == 0) &amp;&amp;
 		(tx_status &amp; XEL_TSR_XMIT_ACTIVE_MASK) != 0) {
 
 		tx_status &amp;= ~XEL_TSR_XMIT_ACTIVE_MASK;
<span class="p_del">-		__raw_writel(tx_status, base_addr + XEL_BUFFER_OFFSET +</span>
<span class="p_del">-			     XEL_TSR_OFFSET);</span>
<span class="p_add">+		xemaclite_writel(tx_status, base_addr + XEL_BUFFER_OFFSET +</span>
<span class="p_add">+				 XEL_TSR_OFFSET);</span>
 
 		tx_complete = true;
 	}
<span class="p_chunk">@@ -700,7 +712,7 @@</span> <span class="p_context"> static int xemaclite_mdio_wait(struct net_local *lp)</span>
 	/* wait for the MDIO interface to not be busy or timeout
 	   after some time.
 	*/
<span class="p_del">-	while (__raw_readl(lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET) &amp;</span>
<span class="p_add">+	while (xemaclite_readl(lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET) &amp;</span>
 			XEL_MDIOCTRL_MDIOSTS_MASK) {
 		if (time_before_eq(end, jiffies)) {
 			WARN_ON(1);
<span class="p_chunk">@@ -736,17 +748,17 @@</span> <span class="p_context"> static int xemaclite_mdio_read(struct mii_bus *bus, int phy_id, int reg)</span>
 	 * MDIO Address register. Set the Status bit in the MDIO Control
 	 * register to start a MDIO read transaction.
 	 */
<span class="p_del">-	ctrl_reg = __raw_readl(lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET);</span>
<span class="p_del">-	__raw_writel(XEL_MDIOADDR_OP_MASK |</span>
<span class="p_del">-		     ((phy_id &lt;&lt; XEL_MDIOADDR_PHYADR_SHIFT) | reg),</span>
<span class="p_del">-		     lp-&gt;base_addr + XEL_MDIOADDR_OFFSET);</span>
<span class="p_del">-	__raw_writel(ctrl_reg | XEL_MDIOCTRL_MDIOSTS_MASK,</span>
<span class="p_del">-		     lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET);</span>
<span class="p_add">+	ctrl_reg = xemaclite_readl(lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(XEL_MDIOADDR_OP_MASK |</span>
<span class="p_add">+			 ((phy_id &lt;&lt; XEL_MDIOADDR_PHYADR_SHIFT) | reg),</span>
<span class="p_add">+			 lp-&gt;base_addr + XEL_MDIOADDR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(ctrl_reg | XEL_MDIOCTRL_MDIOSTS_MASK,</span>
<span class="p_add">+			 lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET);</span>
 
 	if (xemaclite_mdio_wait(lp))
 		return -ETIMEDOUT;
 
<span class="p_del">-	rc = __raw_readl(lp-&gt;base_addr + XEL_MDIORD_OFFSET);</span>
<span class="p_add">+	rc = xemaclite_readl(lp-&gt;base_addr + XEL_MDIORD_OFFSET);</span>
 
 	dev_dbg(&amp;lp-&gt;ndev-&gt;dev,
 		&quot;xemaclite_mdio_read(phy_id=%i, reg=%x) == %x\n&quot;,
<span class="p_chunk">@@ -783,13 +795,13 @@</span> <span class="p_context"> static int xemaclite_mdio_write(struct mii_bus *bus, int phy_id, int reg,</span>
 	 * Data register. Finally, set the Status bit in the MDIO Control
 	 * register to start a MDIO write transaction.
 	 */
<span class="p_del">-	ctrl_reg = __raw_readl(lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET);</span>
<span class="p_del">-	__raw_writel(~XEL_MDIOADDR_OP_MASK &amp;</span>
<span class="p_del">-		     ((phy_id &lt;&lt; XEL_MDIOADDR_PHYADR_SHIFT) | reg),</span>
<span class="p_del">-		     lp-&gt;base_addr + XEL_MDIOADDR_OFFSET);</span>
<span class="p_del">-	__raw_writel(val, lp-&gt;base_addr + XEL_MDIOWR_OFFSET);</span>
<span class="p_del">-	__raw_writel(ctrl_reg | XEL_MDIOCTRL_MDIOSTS_MASK,</span>
<span class="p_del">-		     lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET);</span>
<span class="p_add">+	ctrl_reg = xemaclite_readl(lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(~XEL_MDIOADDR_OP_MASK &amp;</span>
<span class="p_add">+			 ((phy_id &lt;&lt; XEL_MDIOADDR_PHYADR_SHIFT) | reg),</span>
<span class="p_add">+			 lp-&gt;base_addr + XEL_MDIOADDR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(val, lp-&gt;base_addr + XEL_MDIOWR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(ctrl_reg | XEL_MDIOCTRL_MDIOSTS_MASK,</span>
<span class="p_add">+			 lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -834,8 +846,8 @@</span> <span class="p_context"> static int xemaclite_mdio_setup(struct net_local *lp, struct device *dev)</span>
 	/* Enable the MDIO bus by asserting the enable bit in MDIO Control
 	 * register.
 	 */
<span class="p_del">-	__raw_writel(XEL_MDIOCTRL_MDIOEN_MASK,</span>
<span class="p_del">-		     lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(XEL_MDIOCTRL_MDIOEN_MASK,</span>
<span class="p_add">+			 lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET);</span>
 
 	bus = mdiobus_alloc();
 	if (!bus) {
<span class="p_chunk">@@ -1138,8 +1150,8 @@</span> <span class="p_context"> static int xemaclite_of_probe(struct platform_device *ofdev)</span>
 		dev_warn(dev, &quot;No MAC address found\n&quot;);
 
 	/* Clear the Tx CSR&#39;s in case this is a restart */
<span class="p_del">-	__raw_writel(0, lp-&gt;base_addr + XEL_TSR_OFFSET);</span>
<span class="p_del">-	__raw_writel(0, lp-&gt;base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(0, lp-&gt;base_addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(0, lp-&gt;base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);</span>
 
 	/* Set the MAC address in the EmacLite device */
 	xemaclite_update_address(lp, ndev-&gt;dev_addr);
<span class="p_header">diff --git a/drivers/staging/rtl8188eu/core/rtw_ap.c b/drivers/staging/rtl8188eu/core/rtw_ap.c</span>
<span class="p_header">index 9224e029ef2b..70c233f2ea19 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8188eu/core/rtw_ap.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8188eu/core/rtw_ap.c</span>
<span class="p_chunk">@@ -873,7 +873,7 @@</span> <span class="p_context"> int rtw_check_beacon_data(struct adapter *padapter, u8 *pbuf,  int len)</span>
 		return _FAIL;
 
 
<span class="p_del">-	if (len &gt; MAX_IE_SZ)</span>
<span class="p_add">+	if (len &lt; 0 || len &gt; MAX_IE_SZ)</span>
 		return _FAIL;
 
 	pbss_network-&gt;IELength = len;
<span class="p_header">diff --git a/drivers/tty/serial/efm32-uart.c b/drivers/tty/serial/efm32-uart.c</span>
<span class="p_header">index 55d9c00112cc..871860810334 100644</span>
<span class="p_header">--- a/drivers/tty/serial/efm32-uart.c</span>
<span class="p_header">+++ b/drivers/tty/serial/efm32-uart.c</span>
<span class="p_chunk">@@ -27,6 +27,7 @@</span> <span class="p_context"></span>
 #define UARTn_FRAME		0x04
 #define UARTn_FRAME_DATABITS__MASK	0x000f
 #define UARTn_FRAME_DATABITS(n)		((n) - 3)
<span class="p_add">+#define UARTn_FRAME_PARITY__MASK	0x0300</span>
 #define UARTn_FRAME_PARITY_NONE		0x0000
 #define UARTn_FRAME_PARITY_EVEN		0x0200
 #define UARTn_FRAME_PARITY_ODD		0x0300
<span class="p_chunk">@@ -572,12 +573,16 @@</span> <span class="p_context"> static void efm32_uart_console_get_options(struct efm32_uart_port *efm_port,</span>
 			16 * (4 + (clkdiv &gt;&gt; 6)));
 
 	frame = efm32_uart_read32(efm_port, UARTn_FRAME);
<span class="p_del">-	if (frame &amp; UARTn_FRAME_PARITY_ODD)</span>
<span class="p_add">+	switch (frame &amp; UARTn_FRAME_PARITY__MASK) {</span>
<span class="p_add">+	case UARTn_FRAME_PARITY_ODD:</span>
 		*parity = &#39;o&#39;;
<span class="p_del">-	else if (frame &amp; UARTn_FRAME_PARITY_EVEN)</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case UARTn_FRAME_PARITY_EVEN:</span>
 		*parity = &#39;e&#39;;
<span class="p_del">-	else</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
 		*parity = &#39;n&#39;;
<span class="p_add">+	}</span>
 
 	*bits = (frame &amp; UARTn_FRAME_DATABITS__MASK) -
 			UARTn_FRAME_DATABITS(4) + 4;
<span class="p_header">diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c</span>
<span class="p_header">index 122bd73c48e8..58a444f243cc 100644</span>
<span class="p_header">--- a/drivers/usb/core/hcd.c</span>
<span class="p_header">+++ b/drivers/usb/core/hcd.c</span>
<span class="p_chunk">@@ -2461,6 +2461,7 @@</span> <span class="p_context"> struct usb_hcd *usb_create_shared_hcd(const struct hc_driver *driver,</span>
 		hcd-&gt;bandwidth_mutex = kmalloc(sizeof(*hcd-&gt;bandwidth_mutex),
 				GFP_KERNEL);
 		if (!hcd-&gt;bandwidth_mutex) {
<span class="p_add">+			kfree(hcd-&gt;address0_mutex);</span>
 			kfree(hcd);
 			dev_dbg(dev, &quot;hcd bandwidth mutex alloc failed\n&quot;);
 			return NULL;
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 8de05cf013ed..d2c941b03302 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -1346,7 +1346,13 @@</span> <span class="p_context"> static int hub_configure(struct usb_hub *hub,</span>
 	if (ret &lt; 0) {
 		message = &quot;can&#39;t read hub descriptor&quot;;
 		goto fail;
<span class="p_del">-	} else if (hub-&gt;descriptor-&gt;bNbrPorts &gt; USB_MAXCHILDREN) {</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	maxchild = USB_MAXCHILDREN;</span>
<span class="p_add">+	if (hub_is_superspeed(hdev))</span>
<span class="p_add">+		maxchild = min_t(unsigned, maxchild, USB_SS_MAXPORTS);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hub-&gt;descriptor-&gt;bNbrPorts &gt; maxchild) {</span>
 		message = &quot;hub has too many ports!&quot;;
 		ret = -ENODEV;
 		goto fail;
<span class="p_header">diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_header">index 53c747fed9d7..a2bf16b6b930 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_chunk">@@ -1935,7 +1935,7 @@</span> <span class="p_context"> ss_hub_descriptor(struct usb_hub_descriptor *desc)</span>
 	desc-&gt;wHubCharacteristics = cpu_to_le16(0x0001);
 	desc-&gt;bNbrPorts = 1;
 	desc-&gt;u.ss.bHubHdrDecLat = 0x04; /* Worst case: 0.4 micro sec*/
<span class="p_del">-	desc-&gt;u.ss.DeviceRemovable = 0xffff;</span>
<span class="p_add">+	desc-&gt;u.ss.DeviceRemovable = 0;</span>
 }
 
 static inline void hub_descriptor(struct usb_hub_descriptor *desc)
<span class="p_chunk">@@ -1945,8 +1945,8 @@</span> <span class="p_context"> static inline void hub_descriptor(struct usb_hub_descriptor *desc)</span>
 	desc-&gt;bDescLength = 9;
 	desc-&gt;wHubCharacteristics = cpu_to_le16(0x0001);
 	desc-&gt;bNbrPorts = 1;
<span class="p_del">-	desc-&gt;u.hs.DeviceRemovable[0] = 0xff;</span>
<span class="p_del">-	desc-&gt;u.hs.DeviceRemovable[1] = 0xff;</span>
<span class="p_add">+	desc-&gt;u.hs.DeviceRemovable[0] = 0;</span>
<span class="p_add">+	desc-&gt;u.hs.DeviceRemovable[1] = 0xff;	/* PortPwrCtrlMask */</span>
 }
 
 static int dummy_hub_control(
<span class="p_header">diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_header">index f130bb2f7bbe..a9f12e382f2a 100644</span>
<span class="p_header">--- a/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_chunk">@@ -1269,7 +1269,7 @@</span> <span class="p_context"> static void set_td_timer(struct r8a66597 *r8a66597, struct r8a66597_td *td)</span>
 			time = 30;
 			break;
 		default:
<span class="p_del">-			time = 300;</span>
<span class="p_add">+			time = 50;</span>
 			break;
 		}
 
<span class="p_chunk">@@ -1785,6 +1785,7 @@</span> <span class="p_context"> static void r8a66597_td_timer(unsigned long _r8a66597)</span>
 		pipe = td-&gt;pipe;
 		pipe_stop(r8a66597, pipe);
 
<span class="p_add">+		/* Select a different address or endpoint */</span>
 		new_td = td;
 		do {
 			list_move_tail(&amp;new_td-&gt;queue,
<span class="p_chunk">@@ -1794,7 +1795,8 @@</span> <span class="p_context"> static void r8a66597_td_timer(unsigned long _r8a66597)</span>
 				new_td = td;
 				break;
 			}
<span class="p_del">-		} while (td != new_td &amp;&amp; td-&gt;address == new_td-&gt;address);</span>
<span class="p_add">+		} while (td != new_td &amp;&amp; td-&gt;address == new_td-&gt;address &amp;&amp;</span>
<span class="p_add">+			td-&gt;pipe-&gt;info.epnum == new_td-&gt;pipe-&gt;info.epnum);</span>
 
 		start_transfer(r8a66597, new_td);
 
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index 575582e807d3..6bc448701a9c 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -185,6 +185,9 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_ASMEDIA &amp;&amp;
 			pdev-&gt;device == 0x1042)
 		xhci-&gt;quirks |= XHCI_BROKEN_STREAMS;
<span class="p_add">+	if (pdev-&gt;vendor == PCI_VENDOR_ID_ASMEDIA &amp;&amp;</span>
<span class="p_add">+			pdev-&gt;device == 0x1142)</span>
<span class="p_add">+		xhci-&gt;quirks |= XHCI_TRUST_TX_LENGTH;</span>
 
 	if (xhci-&gt;quirks &amp; XHCI_RESET_ON_RESUME)
 		xhci_dbg_trace(xhci, trace_xhci_dbg_quirks,
<span class="p_header">diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c</span>
<span class="p_header">index f78d13ba7d19..32c46a5c489e 100644</span>
<span class="p_header">--- a/fs/cifs/connect.c</span>
<span class="p_header">+++ b/fs/cifs/connect.c</span>
<span class="p_chunk">@@ -400,6 +400,9 @@</span> <span class="p_context"> cifs_reconnect(struct TCP_Server_Info *server)</span>
 		mutex_unlock(&amp;server-&gt;srv_mutex);
 	} while (server-&gt;tcpStatus == CifsNeedReconnect);
 
<span class="p_add">+	if (server-&gt;tcpStatus == CifsNeedNegotiate)</span>
<span class="p_add">+		mod_delayed_work(cifsiod_wq, &amp;server-&gt;echo, 0);</span>
<span class="p_add">+</span>
 	return rc;
 }
 
<span class="p_chunk">@@ -409,18 +412,27 @@</span> <span class="p_context"> cifs_echo_request(struct work_struct *work)</span>
 	int rc;
 	struct TCP_Server_Info *server = container_of(work,
 					struct TCP_Server_Info, echo.work);
<span class="p_add">+	unsigned long echo_interval;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we need to renegotiate, set echo interval to zero to</span>
<span class="p_add">+	 * immediately call echo service where we can renegotiate.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (server-&gt;tcpStatus == CifsNeedNegotiate)</span>
<span class="p_add">+		echo_interval = 0;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		echo_interval = SMB_ECHO_INTERVAL;</span>
 
 	/*
<span class="p_del">-	 * We cannot send an echo if it is disabled or until the</span>
<span class="p_del">-	 * NEGOTIATE_PROTOCOL request is done, which is indicated by</span>
<span class="p_del">-	 * server-&gt;ops-&gt;need_neg() == true. Also, no need to ping if</span>
<span class="p_del">-	 * we got a response recently.</span>
<span class="p_add">+	 * We cannot send an echo if it is disabled.</span>
<span class="p_add">+	 * Also, no need to ping if we got a response recently.</span>
 	 */
 
 	if (server-&gt;tcpStatus == CifsNeedReconnect ||
<span class="p_del">-	    server-&gt;tcpStatus == CifsExiting || server-&gt;tcpStatus == CifsNew ||</span>
<span class="p_add">+	    server-&gt;tcpStatus == CifsExiting ||</span>
<span class="p_add">+	    server-&gt;tcpStatus == CifsNew ||</span>
 	    (server-&gt;ops-&gt;can_echo &amp;&amp; !server-&gt;ops-&gt;can_echo(server)) ||
<span class="p_del">-	    time_before(jiffies, server-&gt;lstrp + SMB_ECHO_INTERVAL - HZ))</span>
<span class="p_add">+	    time_before(jiffies, server-&gt;lstrp + echo_interval - HZ))</span>
 		goto requeue_echo;
 
 	rc = server-&gt;ops-&gt;echo ? server-&gt;ops-&gt;echo(server) : -ENOSYS;
<span class="p_header">diff --git a/fs/configfs/symlink.c b/fs/configfs/symlink.c</span>
<span class="p_header">index cc9f2546ea4a..52fc4e25a7cb 100644</span>
<span class="p_header">--- a/fs/configfs/symlink.c</span>
<span class="p_header">+++ b/fs/configfs/symlink.c</span>
<span class="p_chunk">@@ -83,14 +83,13 @@</span> <span class="p_context"> static int create_link(struct config_item *parent_item,</span>
 	ret = -ENOMEM;
 	sl = kmalloc(sizeof(struct configfs_symlink), GFP_KERNEL);
 	if (sl) {
<span class="p_del">-		sl-&gt;sl_target = config_item_get(item);</span>
 		spin_lock(&amp;configfs_dirent_lock);
 		if (target_sd-&gt;s_type &amp; CONFIGFS_USET_DROPPING) {
 			spin_unlock(&amp;configfs_dirent_lock);
<span class="p_del">-			config_item_put(item);</span>
 			kfree(sl);
 			return -ENOENT;
 		}
<span class="p_add">+		sl-&gt;sl_target = config_item_get(item);</span>
 		list_add(&amp;sl-&gt;sl_list, &amp;target_sd-&gt;s_links);
 		spin_unlock(&amp;configfs_dirent_lock);
 		ret = configfs_create_link(sl, parent_item-&gt;ci_dentry,
<span class="p_header">diff --git a/fs/hugetlbfs/inode.c b/fs/hugetlbfs/inode.c</span>
<span class="p_header">index 1e2872b25343..148c4e9cf22f 100644</span>
<span class="p_header">--- a/fs/hugetlbfs/inode.c</span>
<span class="p_header">+++ b/fs/hugetlbfs/inode.c</span>
<span class="p_chunk">@@ -171,7 +171,7 @@</span> <span class="p_context"> hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 		addr = ALIGN(addr, huge_page_size(h));
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c</span>
<span class="p_header">index af33fb77196f..aea2d0bf7174 100644</span>
<span class="p_header">--- a/fs/proc/task_mmu.c</span>
<span class="p_header">+++ b/fs/proc/task_mmu.c</span>
<span class="p_chunk">@@ -284,11 +284,7 @@</span> <span class="p_context"> show_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)</span>
 
 	/* We don&#39;t show the stack guard page in /proc/maps */
 	start = vma-&gt;vm_start;
<span class="p_del">-	if (stack_guard_page_start(vma, start))</span>
<span class="p_del">-		start += PAGE_SIZE;</span>
 	end = vma-&gt;vm_end;
<span class="p_del">-	if (stack_guard_page_end(vma, end))</span>
<span class="p_del">-		end -= PAGE_SIZE;</span>
 
 	seq_setwidth(m, 25 + sizeof(void *) * 6 - 1);
 	seq_printf(m, &quot;%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu &quot;,
<span class="p_header">diff --git a/include/linux/log2.h b/include/linux/log2.h</span>
<span class="p_header">index f38fae23bdac..c373295f359f 100644</span>
<span class="p_header">--- a/include/linux/log2.h</span>
<span class="p_header">+++ b/include/linux/log2.h</span>
<span class="p_chunk">@@ -194,6 +194,17 @@</span> <span class="p_context"> unsigned long __rounddown_pow_of_two(unsigned long n)</span>
  *  ... and so on.
  */
 
<span class="p_del">-#define order_base_2(n) ilog2(roundup_pow_of_two(n))</span>
<span class="p_add">+static inline __attribute_const__</span>
<span class="p_add">+int __order_base_2(unsigned long n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return n &gt; 1 ? ilog2(n - 1) + 1 : 0;</span>
<span class="p_add">+}</span>
 
<span class="p_add">+#define order_base_2(n)				\</span>
<span class="p_add">+(						\</span>
<span class="p_add">+	__builtin_constant_p(n) ? (		\</span>
<span class="p_add">+		((n) == 0 || (n) == 1) ? 0 :	\</span>
<span class="p_add">+		ilog2((n) - 1) + 1) :		\</span>
<span class="p_add">+	__order_base_2(n)			\</span>
<span class="p_add">+)</span>
 #endif /* _LINUX_LOG2_H */
<span class="p_header">diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="p_header">index db853dee1ec5..54ad2e45bc6b 100644</span>
<span class="p_header">--- a/include/linux/mm.h</span>
<span class="p_header">+++ b/include/linux/mm.h</span>
<span class="p_chunk">@@ -1242,34 +1242,6 @@</span> <span class="p_context"> int set_page_dirty_lock(struct page *page);</span>
 int clear_page_dirty_for_io(struct page *page);
 int get_cmdline(struct task_struct *task, char *buffer, int buflen);
 
<span class="p_del">-/* Is the vma a continuation of the stack vma above it? */</span>
<span class="p_del">-static inline int vma_growsdown(struct vm_area_struct *vma, unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return vma &amp;&amp; (vma-&gt;vm_end == addr) &amp;&amp; (vma-&gt;vm_flags &amp; VM_GROWSDOWN);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int stack_guard_page_start(struct vm_area_struct *vma,</span>
<span class="p_del">-					     unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (vma-&gt;vm_flags &amp; VM_GROWSDOWN) &amp;&amp;</span>
<span class="p_del">-		(vma-&gt;vm_start == addr) &amp;&amp;</span>
<span class="p_del">-		!vma_growsdown(vma-&gt;vm_prev, addr);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Is the vma a continuation of the stack vma below it? */</span>
<span class="p_del">-static inline int vma_growsup(struct vm_area_struct *vma, unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return vma &amp;&amp; (vma-&gt;vm_start == addr) &amp;&amp; (vma-&gt;vm_flags &amp; VM_GROWSUP);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int stack_guard_page_end(struct vm_area_struct *vma,</span>
<span class="p_del">-					   unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (vma-&gt;vm_flags &amp; VM_GROWSUP) &amp;&amp;</span>
<span class="p_del">-		(vma-&gt;vm_end == addr) &amp;&amp;</span>
<span class="p_del">-		!vma_growsup(vma-&gt;vm_next, addr);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 extern struct task_struct *task_of_stack(struct task_struct *task,
 				struct vm_area_struct *vma, bool in_group);
 
<span class="p_chunk">@@ -1930,6 +1902,7 @@</span> <span class="p_context"> void page_cache_async_readahead(struct address_space *mapping,</span>
 
 unsigned long max_sane_readahead(unsigned long nr);
 
<span class="p_add">+extern unsigned long stack_guard_gap;</span>
 /* Generic expand stack which grows the stack according to GROWS{UP,DOWN} */
 extern int expand_stack(struct vm_area_struct *vma, unsigned long address);
 
<span class="p_chunk">@@ -1958,6 +1931,30 @@</span> <span class="p_context"> static inline struct vm_area_struct * find_vma_intersection(struct mm_struct * m</span>
 	return vma;
 }
 
<span class="p_add">+static inline unsigned long vm_start_gap(struct vm_area_struct *vma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long vm_start = vma-&gt;vm_start;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_GROWSDOWN) {</span>
<span class="p_add">+		vm_start -= stack_guard_gap;</span>
<span class="p_add">+		if (vm_start &gt; vma-&gt;vm_start)</span>
<span class="p_add">+			vm_start = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return vm_start;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long vm_end_gap(struct vm_area_struct *vma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long vm_end = vma-&gt;vm_end;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_GROWSUP) {</span>
<span class="p_add">+		vm_end += stack_guard_gap;</span>
<span class="p_add">+		if (vm_end &lt; vma-&gt;vm_end)</span>
<span class="p_add">+			vm_end = -PAGE_SIZE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return vm_end;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline unsigned long vma_pages(struct vm_area_struct *vma)
 {
 	return (vma-&gt;vm_end - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT;
<span class="p_header">diff --git a/include/uapi/linux/usb/ch11.h b/include/uapi/linux/usb/ch11.h</span>
<span class="p_header">index 331499d597fa..9ce10d4a0245 100644</span>
<span class="p_header">--- a/include/uapi/linux/usb/ch11.h</span>
<span class="p_header">+++ b/include/uapi/linux/usb/ch11.h</span>
<span class="p_chunk">@@ -22,6 +22,9 @@</span> <span class="p_context"></span>
  */
 #define USB_MAXCHILDREN		31
 
<span class="p_add">+/* See USB 3.1 spec Table 10-5 */</span>
<span class="p_add">+#define USB_SS_MAXPORTS		15</span>
<span class="p_add">+</span>
 /*
  * Hub request types
  */
<span class="p_header">diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c</span>
<span class="p_header">index 0a9104b4608b..e7ef539c56d9 100644</span>
<span class="p_header">--- a/kernel/irq/manage.c</span>
<span class="p_header">+++ b/kernel/irq/manage.c</span>
<span class="p_chunk">@@ -1156,8 +1156,10 @@</span> <span class="p_context"> __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)</span>
 			ret = __irq_set_trigger(desc, irq,
 					new-&gt;flags &amp; IRQF_TRIGGER_MASK);
 
<span class="p_del">-			if (ret)</span>
<span class="p_add">+			if (ret) {</span>
<span class="p_add">+				irq_release_resources(desc);</span>
 				goto out_mask;
<span class="p_add">+			}</span>
 		}
 
 		desc-&gt;istate &amp;= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \
<span class="p_header">diff --git a/kernel/time/alarmtimer.c b/kernel/time/alarmtimer.c</span>
<span class="p_header">index a7077d3ae52f..3d7fb75354b7 100644</span>
<span class="p_header">--- a/kernel/time/alarmtimer.c</span>
<span class="p_header">+++ b/kernel/time/alarmtimer.c</span>
<span class="p_chunk">@@ -614,6 +614,14 @@</span> <span class="p_context"> static int alarm_timer_set(struct k_itimer *timr, int flags,</span>
 
 	/* start the timer */
 	timr-&gt;it.alarm.interval = timespec_to_ktime(new_setting-&gt;it_interval);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Rate limit to the tick as a hot fix to prevent DOS. Will be</span>
<span class="p_add">+	 * mopped up later.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ktime_to_ns(timr-&gt;it.alarm.interval) &lt; TICK_NSEC)</span>
<span class="p_add">+		timr-&gt;it.alarm.interval = ktime_set(0, TICK_NSEC);</span>
<span class="p_add">+</span>
 	exp = timespec_to_ktime(new_setting-&gt;it_value);
 	/* Convert (if necessary) to absolute time */
 	if (flags != TIMER_ABSTIME) {
<span class="p_header">diff --git a/mm/gup.c b/mm/gup.c</span>
<span class="p_header">index 3cec4df06e6b..ce1630bf0b95 100644</span>
<span class="p_header">--- a/mm/gup.c</span>
<span class="p_header">+++ b/mm/gup.c</span>
<span class="p_chunk">@@ -275,11 +275,6 @@</span> <span class="p_context"> static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,</span>
 	unsigned int fault_flags = 0;
 	int ret;
 
<span class="p_del">-	/* For mlock, just skip the stack guard page. */</span>
<span class="p_del">-	if ((*flags &amp; FOLL_MLOCK) &amp;&amp;</span>
<span class="p_del">-			(stack_guard_page_start(vma, address) ||</span>
<span class="p_del">-			 stack_guard_page_end(vma, address + PAGE_SIZE)))</span>
<span class="p_del">-		return -ENOENT;</span>
 	if (*flags &amp; FOLL_WRITE)
 		fault_flags |= FAULT_FLAG_WRITE;
 	if (nonblocking)
<span class="p_header">diff --git a/mm/memory-failure.c b/mm/memory-failure.c</span>
<span class="p_header">index 185099e55cfb..e14e75754154 100644</span>
<span class="p_header">--- a/mm/memory-failure.c</span>
<span class="p_header">+++ b/mm/memory-failure.c</span>
<span class="p_chunk">@@ -1189,7 +1189,10 @@</span> <span class="p_context"> int memory_failure(unsigned long pfn, int trapno, int flags)</span>
 	 * page_remove_rmap() in try_to_unmap_one(). So to determine page status
 	 * correctly, we save a copy of the page flags at this time.
 	 */
<span class="p_del">-	page_flags = p-&gt;flags;</span>
<span class="p_add">+	if (PageHuge(p))</span>
<span class="p_add">+		page_flags = hpage-&gt;flags;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		page_flags = p-&gt;flags;</span>
 
 	/*
 	 * unpoison always clear PG_hwpoison inside page lock
<span class="p_header">diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="p_header">index 6ca26c332712..0c4f5e36b155 100644</span>
<span class="p_header">--- a/mm/memory.c</span>
<span class="p_header">+++ b/mm/memory.c</span>
<span class="p_chunk">@@ -2580,40 +2580,6 @@</span> <span class="p_context"> out_release:</span>
 }
 
 /*
<span class="p_del">- * This is like a special single-page &quot;expand_{down|up}wards()&quot;,</span>
<span class="p_del">- * except we must first make sure that &#39;address{-|+}PAGE_SIZE&#39;</span>
<span class="p_del">- * doesn&#39;t hit another vma.</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline int check_stack_guard_page(struct vm_area_struct *vma, unsigned long address)</span>
<span class="p_del">-{</span>
<span class="p_del">-	address &amp;= PAGE_MASK;</span>
<span class="p_del">-	if ((vma-&gt;vm_flags &amp; VM_GROWSDOWN) &amp;&amp; address == vma-&gt;vm_start) {</span>
<span class="p_del">-		struct vm_area_struct *prev = vma-&gt;vm_prev;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Is there a mapping abutting this one below?</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * That&#39;s only ok if it&#39;s the same stack mapping</span>
<span class="p_del">-		 * that has gotten split..</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (prev &amp;&amp; prev-&gt;vm_end == address)</span>
<span class="p_del">-			return prev-&gt;vm_flags &amp; VM_GROWSDOWN ? 0 : -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-		return expand_downwards(vma, address - PAGE_SIZE);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if ((vma-&gt;vm_flags &amp; VM_GROWSUP) &amp;&amp; address + PAGE_SIZE == vma-&gt;vm_end) {</span>
<span class="p_del">-		struct vm_area_struct *next = vma-&gt;vm_next;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* As VM_GROWSDOWN but s/below/above/ */</span>
<span class="p_del">-		if (next &amp;&amp; next-&gt;vm_start == address + PAGE_SIZE)</span>
<span class="p_del">-			return next-&gt;vm_flags &amp; VM_GROWSUP ? 0 : -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-		return expand_upwards(vma, address + PAGE_SIZE);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
  * We enter with non-exclusive mmap_sem (to exclude vma changes,
  * but allow concurrent faults), and pte mapped but not yet locked.
  * We return with mmap_sem still held, but pte unmapped and unlocked.
<span class="p_chunk">@@ -2633,10 +2599,6 @@</span> <span class="p_context"> static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 	if (vma-&gt;vm_flags &amp; VM_SHARED)
 		return VM_FAULT_SIGBUS;
 
<span class="p_del">-	/* Check if we need to add a guard page to the stack */</span>
<span class="p_del">-	if (check_stack_guard_page(vma, address) &lt; 0)</span>
<span class="p_del">-		return VM_FAULT_SIGSEGV;</span>
<span class="p_del">-</span>
 	/* Use the zero-page for reads */
 	if (!(flags &amp; FAULT_FLAG_WRITE)) {
 		entry = pte_mkspecial(pfn_pte(my_zero_pfn(address),
<span class="p_header">diff --git a/mm/mmap.c b/mm/mmap.c</span>
<span class="p_header">index f03267136fb7..f975ec90f710 100644</span>
<span class="p_header">--- a/mm/mmap.c</span>
<span class="p_header">+++ b/mm/mmap.c</span>
<span class="p_chunk">@@ -290,6 +290,7 @@</span> <span class="p_context"> SYSCALL_DEFINE1(brk, unsigned long, brk)</span>
 	unsigned long retval;
 	unsigned long newbrk, oldbrk;
 	struct mm_struct *mm = current-&gt;mm;
<span class="p_add">+	struct vm_area_struct *next;</span>
 	unsigned long min_brk;
 	bool populate;
 
<span class="p_chunk">@@ -334,7 +335,8 @@</span> <span class="p_context"> SYSCALL_DEFINE1(brk, unsigned long, brk)</span>
 	}
 
 	/* Check against existing mmap mappings. */
<span class="p_del">-	if (find_vma_intersection(mm, oldbrk, newbrk+PAGE_SIZE))</span>
<span class="p_add">+	next = find_vma(mm, oldbrk);</span>
<span class="p_add">+	if (next &amp;&amp; newbrk + PAGE_SIZE &gt; vm_start_gap(next))</span>
 		goto out;
 
 	/* Ok, looks good - let it rip. */
<span class="p_chunk">@@ -357,10 +359,22 @@</span> <span class="p_context"> out:</span>
 
 static long vma_compute_subtree_gap(struct vm_area_struct *vma)
 {
<span class="p_del">-	unsigned long max, subtree_gap;</span>
<span class="p_del">-	max = vma-&gt;vm_start;</span>
<span class="p_del">-	if (vma-&gt;vm_prev)</span>
<span class="p_del">-		max -= vma-&gt;vm_prev-&gt;vm_end;</span>
<span class="p_add">+	unsigned long max, prev_end, subtree_gap;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Note: in the rare case of a VM_GROWSDOWN above a VM_GROWSUP, we</span>
<span class="p_add">+	 * allow two stack_guard_gaps between them here, and when choosing</span>
<span class="p_add">+	 * an unmapped area; whereas when expanding we only require one.</span>
<span class="p_add">+	 * That&#39;s a little inconsistent, but keeps the code here simpler.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	max = vm_start_gap(vma);</span>
<span class="p_add">+	if (vma-&gt;vm_prev) {</span>
<span class="p_add">+		prev_end = vm_end_gap(vma-&gt;vm_prev);</span>
<span class="p_add">+		if (max &gt; prev_end)</span>
<span class="p_add">+			max -= prev_end;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			max = 0;</span>
<span class="p_add">+	}</span>
 	if (vma-&gt;vm_rb.rb_left) {
 		subtree_gap = rb_entry(vma-&gt;vm_rb.rb_left,
 				struct vm_area_struct, vm_rb)-&gt;rb_subtree_gap;
<span class="p_chunk">@@ -453,7 +467,7 @@</span> <span class="p_context"> static void validate_mm(struct mm_struct *mm)</span>
 			anon_vma_unlock_read(anon_vma);
 		}
 
<span class="p_del">-		highest_address = vma-&gt;vm_end;</span>
<span class="p_add">+		highest_address = vm_end_gap(vma);</span>
 		vma = vma-&gt;vm_next;
 		i++;
 	}
<span class="p_chunk">@@ -622,7 +636,7 @@</span> <span class="p_context"> void __vma_link_rb(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 	if (vma-&gt;vm_next)
 		vma_gap_update(vma-&gt;vm_next);
 	else
<span class="p_del">-		mm-&gt;highest_vm_end = vma-&gt;vm_end;</span>
<span class="p_add">+		mm-&gt;highest_vm_end = vm_end_gap(vma);</span>
 
 	/*
 	 * vma-&gt;vm_prev wasn&#39;t known when we followed the rbtree to find the
<span class="p_chunk">@@ -874,7 +888,7 @@</span> <span class="p_context"> again:			remove_next = 1 + (end &gt; next-&gt;vm_end);</span>
 			vma_gap_update(vma);
 		if (end_changed) {
 			if (!next)
<span class="p_del">-				mm-&gt;highest_vm_end = end;</span>
<span class="p_add">+				mm-&gt;highest_vm_end = vm_end_gap(vma);</span>
 			else if (!adjust_next)
 				vma_gap_update(next);
 		}
<span class="p_chunk">@@ -917,7 +931,7 @@</span> <span class="p_context"> again:			remove_next = 1 + (end &gt; next-&gt;vm_end);</span>
 		else if (next)
 			vma_gap_update(next);
 		else
<span class="p_del">-			mm-&gt;highest_vm_end = end;</span>
<span class="p_add">+			VM_WARN_ON(mm-&gt;highest_vm_end != vm_end_gap(vma));</span>
 	}
 	if (insert &amp;&amp; file)
 		uprobe_mmap(insert);
<span class="p_chunk">@@ -1740,7 +1754,7 @@</span> <span class="p_context"> unsigned long unmapped_area(struct vm_unmapped_area_info *info)</span>
 
 	while (true) {
 		/* Visit left subtree if it looks promising */
<span class="p_del">-		gap_end = vma-&gt;vm_start;</span>
<span class="p_add">+		gap_end = vm_start_gap(vma);</span>
 		if (gap_end &gt;= low_limit &amp;&amp; vma-&gt;vm_rb.rb_left) {
 			struct vm_area_struct *left =
 				rb_entry(vma-&gt;vm_rb.rb_left,
<span class="p_chunk">@@ -1751,12 +1765,13 @@</span> <span class="p_context"> unsigned long unmapped_area(struct vm_unmapped_area_info *info)</span>
 			}
 		}
 
<span class="p_del">-		gap_start = vma-&gt;vm_prev ? vma-&gt;vm_prev-&gt;vm_end : 0;</span>
<span class="p_add">+		gap_start = vma-&gt;vm_prev ? vm_end_gap(vma-&gt;vm_prev) : 0;</span>
 check_current:
 		/* Check if current node has a suitable gap */
 		if (gap_start &gt; high_limit)
 			return -ENOMEM;
<span class="p_del">-		if (gap_end &gt;= low_limit &amp;&amp; gap_end - gap_start &gt;= length)</span>
<span class="p_add">+		if (gap_end &gt;= low_limit &amp;&amp;</span>
<span class="p_add">+		    gap_end &gt; gap_start &amp;&amp; gap_end - gap_start &gt;= length)</span>
 			goto found;
 
 		/* Visit right subtree if it looks promising */
<span class="p_chunk">@@ -1778,8 +1793,8 @@</span> <span class="p_context"> check_current:</span>
 			vma = rb_entry(rb_parent(prev),
 				       struct vm_area_struct, vm_rb);
 			if (prev == vma-&gt;vm_rb.rb_left) {
<span class="p_del">-				gap_start = vma-&gt;vm_prev-&gt;vm_end;</span>
<span class="p_del">-				gap_end = vma-&gt;vm_start;</span>
<span class="p_add">+				gap_start = vm_end_gap(vma-&gt;vm_prev);</span>
<span class="p_add">+				gap_end = vm_start_gap(vma);</span>
 				goto check_current;
 			}
 		}
<span class="p_chunk">@@ -1843,7 +1858,7 @@</span> <span class="p_context"> unsigned long unmapped_area_topdown(struct vm_unmapped_area_info *info)</span>
 
 	while (true) {
 		/* Visit right subtree if it looks promising */
<span class="p_del">-		gap_start = vma-&gt;vm_prev ? vma-&gt;vm_prev-&gt;vm_end : 0;</span>
<span class="p_add">+		gap_start = vma-&gt;vm_prev ? vm_end_gap(vma-&gt;vm_prev) : 0;</span>
 		if (gap_start &lt;= high_limit &amp;&amp; vma-&gt;vm_rb.rb_right) {
 			struct vm_area_struct *right =
 				rb_entry(vma-&gt;vm_rb.rb_right,
<span class="p_chunk">@@ -1856,10 +1871,11 @@</span> <span class="p_context"> unsigned long unmapped_area_topdown(struct vm_unmapped_area_info *info)</span>
 
 check_current:
 		/* Check if current node has a suitable gap */
<span class="p_del">-		gap_end = vma-&gt;vm_start;</span>
<span class="p_add">+		gap_end = vm_start_gap(vma);</span>
 		if (gap_end &lt; low_limit)
 			return -ENOMEM;
<span class="p_del">-		if (gap_start &lt;= high_limit &amp;&amp; gap_end - gap_start &gt;= length)</span>
<span class="p_add">+		if (gap_start &lt;= high_limit &amp;&amp;</span>
<span class="p_add">+		    gap_end &gt; gap_start &amp;&amp; gap_end - gap_start &gt;= length)</span>
 			goto found;
 
 		/* Visit left subtree if it looks promising */
<span class="p_chunk">@@ -1882,7 +1898,7 @@</span> <span class="p_context"> check_current:</span>
 				       struct vm_area_struct, vm_rb);
 			if (prev == vma-&gt;vm_rb.rb_right) {
 				gap_start = vma-&gt;vm_prev ?
<span class="p_del">-					vma-&gt;vm_prev-&gt;vm_end : 0;</span>
<span class="p_add">+					vm_end_gap(vma-&gt;vm_prev) : 0;</span>
 				goto check_current;
 			}
 		}
<span class="p_chunk">@@ -1920,7 +1936,7 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		unsigned long len, unsigned long pgoff, unsigned long flags)
 {
 	struct mm_struct *mm = current-&gt;mm;
<span class="p_del">-	struct vm_area_struct *vma;</span>
<span class="p_add">+	struct vm_area_struct *vma, *prev;</span>
 	struct vm_unmapped_area_info info;
 
 	if (len &gt; TASK_SIZE - mmap_min_addr)
<span class="p_chunk">@@ -1931,9 +1947,10 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
<span class="p_del">-		vma = find_vma(mm, addr);</span>
<span class="p_add">+		vma = find_vma_prev(mm, addr, &amp;prev);</span>
 		if (TASK_SIZE - len &gt;= addr &amp;&amp; addr &gt;= mmap_min_addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)) &amp;&amp;</span>
<span class="p_add">+		    (!prev || addr &gt;= vm_end_gap(prev)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -1956,7 +1973,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 			  const unsigned long len, const unsigned long pgoff,
 			  const unsigned long flags)
 {
<span class="p_del">-	struct vm_area_struct *vma;</span>
<span class="p_add">+	struct vm_area_struct *vma, *prev;</span>
 	struct mm_struct *mm = current-&gt;mm;
 	unsigned long addr = addr0;
 	struct vm_unmapped_area_info info;
<span class="p_chunk">@@ -1971,9 +1988,10 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 	/* requesting a specific address */
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
<span class="p_del">-		vma = find_vma(mm, addr);</span>
<span class="p_add">+		vma = find_vma_prev(mm, addr, &amp;prev);</span>
 		if (TASK_SIZE - len &gt;= addr &amp;&amp; addr &gt;= mmap_min_addr &amp;&amp;
<span class="p_del">-				(!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+				(!vma || addr + len &lt;= vm_start_gap(vma)) &amp;&amp;</span>
<span class="p_add">+				(!prev || addr &gt;= vm_end_gap(prev)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -2099,21 +2117,19 @@</span> <span class="p_context"> find_vma_prev(struct mm_struct *mm, unsigned long addr,</span>
  * update accounting. This is shared with both the
  * grow-up and grow-down cases.
  */
<span class="p_del">-static int acct_stack_growth(struct vm_area_struct *vma, unsigned long size, unsigned long grow)</span>
<span class="p_add">+static int acct_stack_growth(struct vm_area_struct *vma,</span>
<span class="p_add">+			     unsigned long size, unsigned long grow)</span>
 {
 	struct mm_struct *mm = vma-&gt;vm_mm;
 	struct rlimit *rlim = current-&gt;signal-&gt;rlim;
<span class="p_del">-	unsigned long new_start, actual_size;</span>
<span class="p_add">+	unsigned long new_start;</span>
 
 	/* address space limit tests */
 	if (!may_expand_vm(mm, grow))
 		return -ENOMEM;
 
 	/* Stack limit test */
<span class="p_del">-	actual_size = size;</span>
<span class="p_del">-	if (size &amp;&amp; (vma-&gt;vm_flags &amp; (VM_GROWSUP | VM_GROWSDOWN)))</span>
<span class="p_del">-		actual_size -= PAGE_SIZE;</span>
<span class="p_del">-	if (actual_size &gt; ACCESS_ONCE(rlim[RLIMIT_STACK].rlim_cur))</span>
<span class="p_add">+	if (size &gt; ACCESS_ONCE(rlim[RLIMIT_STACK].rlim_cur))</span>
 		return -ENOMEM;
 
 	/* mlock limit tests */
<span class="p_chunk">@@ -2154,16 +2170,32 @@</span> <span class="p_context"> static int acct_stack_growth(struct vm_area_struct *vma, unsigned long size, uns</span>
  */
 int expand_upwards(struct vm_area_struct *vma, unsigned long address)
 {
<span class="p_add">+	struct vm_area_struct *next;</span>
<span class="p_add">+	unsigned long gap_addr;</span>
 	int error = 0;
 
 	if (!(vma-&gt;vm_flags &amp; VM_GROWSUP))
 		return -EFAULT;
 
<span class="p_del">-	/* Guard against wrapping around to address 0. */</span>
<span class="p_del">-	if (address &lt; PAGE_ALIGN(address+4))</span>
<span class="p_del">-		address = PAGE_ALIGN(address+4);</span>
<span class="p_del">-	else</span>
<span class="p_add">+	/* Guard against exceeding limits of the address space. */</span>
<span class="p_add">+	address &amp;= PAGE_MASK;</span>
<span class="p_add">+	if (address &gt;= TASK_SIZE)</span>
 		return -ENOMEM;
<span class="p_add">+	address += PAGE_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enforce stack_guard_gap */</span>
<span class="p_add">+	gap_addr = address + stack_guard_gap;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Guard against overflow */</span>
<span class="p_add">+	if (gap_addr &lt; address || gap_addr &gt; TASK_SIZE)</span>
<span class="p_add">+		gap_addr = TASK_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	next = vma-&gt;vm_next;</span>
<span class="p_add">+	if (next &amp;&amp; next-&gt;vm_start &lt; gap_addr) {</span>
<span class="p_add">+		if (!(next-&gt;vm_flags &amp; VM_GROWSUP))</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+		/* Check that both stack segments have the same anon_vma? */</span>
<span class="p_add">+	}</span>
 
 	/* We must make sure the anon_vma is allocated. */
 	if (unlikely(anon_vma_prepare(vma)))
<span class="p_chunk">@@ -2205,7 +2237,7 @@</span> <span class="p_context"> int expand_upwards(struct vm_area_struct *vma, unsigned long address)</span>
 				if (vma-&gt;vm_next)
 					vma_gap_update(vma-&gt;vm_next);
 				else
<span class="p_del">-					vma-&gt;vm_mm-&gt;highest_vm_end = address;</span>
<span class="p_add">+					vma-&gt;vm_mm-&gt;highest_vm_end = vm_end_gap(vma);</span>
 				spin_unlock(&amp;vma-&gt;vm_mm-&gt;page_table_lock);
 
 				perf_event_mmap(vma);
<span class="p_chunk">@@ -2225,6 +2257,8 @@</span> <span class="p_context"> int expand_upwards(struct vm_area_struct *vma, unsigned long address)</span>
 int expand_downwards(struct vm_area_struct *vma,
 				   unsigned long address)
 {
<span class="p_add">+	struct vm_area_struct *prev;</span>
<span class="p_add">+	unsigned long gap_addr;</span>
 	int error;
 
 	address &amp;= PAGE_MASK;
<span class="p_chunk">@@ -2232,6 +2266,17 @@</span> <span class="p_context"> int expand_downwards(struct vm_area_struct *vma,</span>
 	if (error)
 		return error;
 
<span class="p_add">+	/* Enforce stack_guard_gap */</span>
<span class="p_add">+	gap_addr = address - stack_guard_gap;</span>
<span class="p_add">+	if (gap_addr &gt; address)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	prev = vma-&gt;vm_prev;</span>
<span class="p_add">+	if (prev &amp;&amp; prev-&gt;vm_end &gt; gap_addr) {</span>
<span class="p_add">+		if (!(prev-&gt;vm_flags &amp; VM_GROWSDOWN))</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+		/* Check that both stack segments have the same anon_vma? */</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* We must make sure the anon_vma is allocated. */
 	if (unlikely(anon_vma_prepare(vma)))
 		return -ENOMEM;
<span class="p_chunk">@@ -2283,28 +2328,25 @@</span> <span class="p_context"> int expand_downwards(struct vm_area_struct *vma,</span>
 	return error;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * Note how expand_stack() refuses to expand the stack all the way to</span>
<span class="p_del">- * abut the next virtual mapping, *unless* that mapping itself is also</span>
<span class="p_del">- * a stack mapping. We want to leave room for a guard page, after all</span>
<span class="p_del">- * (the guard page itself is not added here, that is done by the</span>
<span class="p_del">- * actual page faulting logic)</span>
<span class="p_del">- *</span>
<span class="p_del">- * This matches the behavior of the guard page logic (see mm/memory.c:</span>
<span class="p_del">- * check_stack_guard_page()), which only allows the guard page to be</span>
<span class="p_del">- * removed under these circumstances.</span>
<span class="p_del">- */</span>
<span class="p_add">+/* enforced gap between the expanding stack and other mappings. */</span>
<span class="p_add">+unsigned long stack_guard_gap = 256UL&lt;&lt;PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init cmdline_parse_stack_guard_gap(char *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long val;</span>
<span class="p_add">+	char *endptr;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = simple_strtoul(p, &amp;endptr, 10);</span>
<span class="p_add">+	if (!*endptr)</span>
<span class="p_add">+		stack_guard_gap = val &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+__setup(&quot;stack_guard_gap=&quot;, cmdline_parse_stack_guard_gap);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_STACK_GROWSUP
 int expand_stack(struct vm_area_struct *vma, unsigned long address)
 {
<span class="p_del">-	struct vm_area_struct *next;</span>
<span class="p_del">-</span>
<span class="p_del">-	address &amp;= PAGE_MASK;</span>
<span class="p_del">-	next = vma-&gt;vm_next;</span>
<span class="p_del">-	if (next &amp;&amp; next-&gt;vm_start == address + PAGE_SIZE) {</span>
<span class="p_del">-		if (!(next-&gt;vm_flags &amp; VM_GROWSUP))</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_del">-	}</span>
 	return expand_upwards(vma, address);
 }
 
<span class="p_chunk">@@ -2326,14 +2368,6 @@</span> <span class="p_context"> find_extend_vma(struct mm_struct *mm, unsigned long addr)</span>
 #else
 int expand_stack(struct vm_area_struct *vma, unsigned long address)
 {
<span class="p_del">-	struct vm_area_struct *prev;</span>
<span class="p_del">-</span>
<span class="p_del">-	address &amp;= PAGE_MASK;</span>
<span class="p_del">-	prev = vma-&gt;vm_prev;</span>
<span class="p_del">-	if (prev &amp;&amp; prev-&gt;vm_end == address) {</span>
<span class="p_del">-		if (!(prev-&gt;vm_flags &amp; VM_GROWSDOWN))</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_del">-	}</span>
 	return expand_downwards(vma, address);
 }
 
<span class="p_chunk">@@ -2429,7 +2463,7 @@</span> <span class="p_context"> detach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 		vma-&gt;vm_prev = prev;
 		vma_gap_update(vma);
 	} else
<span class="p_del">-		mm-&gt;highest_vm_end = prev ? prev-&gt;vm_end : 0;</span>
<span class="p_add">+		mm-&gt;highest_vm_end = prev ? vm_end_gap(prev) : 0;</span>
 	tail_vma-&gt;vm_next = NULL;
 
 	/* Kill the cache */
<span class="p_header">diff --git a/mm/page_cgroup.c b/mm/page_cgroup.c</span>
<span class="p_header">index 5331c2bd85a2..29fd07ba57bd 100644</span>
<span class="p_header">--- a/mm/page_cgroup.c</span>
<span class="p_header">+++ b/mm/page_cgroup.c</span>
<span class="p_chunk">@@ -368,6 +368,9 @@</span> <span class="p_context"> static int swap_cgroup_prepare(int type)</span>
 		if (!page)
 			goto not_enough_page;
 		ctrl-&gt;map[idx] = page;
<span class="p_add">+</span>
<span class="p_add">+		if (!(idx % SWAP_CLUSTER_MAX))</span>
<span class="p_add">+			cond_resched();</span>
 	}
 	return 0;
 not_enough_page:
<span class="p_header">diff --git a/net/ipv6/datagram.c b/net/ipv6/datagram.c</span>
<span class="p_header">index 9e3b0b66a4f3..ee7a8983b173 100644</span>
<span class="p_header">--- a/net/ipv6/datagram.c</span>
<span class="p_header">+++ b/net/ipv6/datagram.c</span>
<span class="p_chunk">@@ -76,18 +76,22 @@</span> <span class="p_context"> static int __ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int a</span>
 		}
 	}
 
<span class="p_del">-	addr_type = ipv6_addr_type(&amp;usin-&gt;sin6_addr);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (addr_type == IPV6_ADDR_ANY) {</span>
<span class="p_add">+	if (ipv6_addr_any(&amp;usin-&gt;sin6_addr)) {</span>
 		/*
 		 *	connect to self
 		 */
<span class="p_del">-		usin-&gt;sin6_addr.s6_addr[15] = 0x01;</span>
<span class="p_add">+		if (ipv6_addr_v4mapped(&amp;sk-&gt;sk_v6_rcv_saddr))</span>
<span class="p_add">+			ipv6_addr_set_v4mapped(htonl(INADDR_LOOPBACK),</span>
<span class="p_add">+					       &amp;usin-&gt;sin6_addr);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			usin-&gt;sin6_addr = in6addr_loopback;</span>
 	}
 
<span class="p_add">+	addr_type = ipv6_addr_type(&amp;usin-&gt;sin6_addr);</span>
<span class="p_add">+</span>
 	daddr = &amp;usin-&gt;sin6_addr;
 
<span class="p_del">-	if (addr_type == IPV6_ADDR_MAPPED) {</span>
<span class="p_add">+	if (addr_type &amp; IPV6_ADDR_MAPPED) {</span>
 		struct sockaddr_in sin;
 
 		if (__ipv6_only_sock(sk)) {
<span class="p_header">diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c</span>
<span class="p_header">index 49a589a4454b..34b26db32c74 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_output.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_output.c</span>
<span class="p_chunk">@@ -960,6 +960,9 @@</span> <span class="p_context"> static int ip6_dst_lookup_tail(struct sock *sk,</span>
 		}
 	}
 #endif
<span class="p_add">+	if (ipv6_addr_v4mapped(&amp;fl6-&gt;saddr) &amp;&amp;</span>
<span class="p_add">+	    !(ipv6_addr_v4mapped(&amp;fl6-&gt;daddr) || ipv6_addr_any(&amp;fl6-&gt;daddr)))</span>
<span class="p_add">+		return -EAFNOSUPPORT;</span>
 
 	return 0;
 
<span class="p_header">diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">index 0ade453839c4..19fe7b789a72 100644</span>
<span class="p_header">--- a/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">+++ b/net/ipv6/tcp_ipv6.c</span>
<span class="p_chunk">@@ -164,8 +164,13 @@</span> <span class="p_context"> static int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,</span>
 	 *	connect() to INADDR_ANY means loopback (BSD&#39;ism).
 	 */
 
<span class="p_del">-	if (ipv6_addr_any(&amp;usin-&gt;sin6_addr))</span>
<span class="p_del">-		usin-&gt;sin6_addr.s6_addr[15] = 0x1;</span>
<span class="p_add">+	if (ipv6_addr_any(&amp;usin-&gt;sin6_addr)) {</span>
<span class="p_add">+		if (ipv6_addr_v4mapped(&amp;sk-&gt;sk_v6_rcv_saddr))</span>
<span class="p_add">+			ipv6_addr_set_v4mapped(htonl(INADDR_LOOPBACK),</span>
<span class="p_add">+					       &amp;usin-&gt;sin6_addr);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			usin-&gt;sin6_addr = in6addr_loopback;</span>
<span class="p_add">+	}</span>
 
 	addr_type = ipv6_addr_type(&amp;usin-&gt;sin6_addr);
 
<span class="p_chunk">@@ -204,7 +209,7 @@</span> <span class="p_context"> static int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,</span>
 	 *	TCP over IPv4
 	 */
 
<span class="p_del">-	if (addr_type == IPV6_ADDR_MAPPED) {</span>
<span class="p_add">+	if (addr_type &amp; IPV6_ADDR_MAPPED) {</span>
 		u32 exthdrlen = icsk-&gt;icsk_ext_hdr_len;
 		struct sockaddr_in sin;
 
<span class="p_header">diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c</span>
<span class="p_header">index 143e6c758b18..a774afa4ce52 100644</span>
<span class="p_header">--- a/net/ipv6/udp.c</span>
<span class="p_header">+++ b/net/ipv6/udp.c</span>
<span class="p_chunk">@@ -1107,6 +1107,10 @@</span> <span class="p_context"> int udpv6_sendmsg(struct kiocb *iocb, struct sock *sk,</span>
 			if (addr_len &lt; SIN6_LEN_RFC2133)
 				return -EINVAL;
 			daddr = &amp;sin6-&gt;sin6_addr;
<span class="p_add">+			if (ipv6_addr_any(daddr) &amp;&amp;</span>
<span class="p_add">+			    ipv6_addr_v4mapped(&amp;np-&gt;saddr))</span>
<span class="p_add">+				ipv6_addr_set_v4mapped(htonl(INADDR_LOOPBACK),</span>
<span class="p_add">+						       daddr);</span>
 			break;
 		case AF_INET:
 			goto do_udp_sendmsg;
<span class="p_header">diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c</span>
<span class="p_header">index bb6f6ef07566..ea3b13987521 100644</span>
<span class="p_header">--- a/net/mac80211/rx.c</span>
<span class="p_header">+++ b/net/mac80211/rx.c</span>
<span class="p_chunk">@@ -1319,12 +1319,16 @@</span> <span class="p_context"> ieee80211_rx_h_sta_process(struct ieee80211_rx_data *rx)</span>
 	 */
 	if (!(sta-&gt;local-&gt;hw.flags &amp; IEEE80211_HW_AP_LINK_PS) &amp;&amp;
 	    !ieee80211_has_morefrags(hdr-&gt;frame_control) &amp;&amp;
<span class="p_add">+	    !ieee80211_is_back_req(hdr-&gt;frame_control) &amp;&amp;</span>
 	    !(status-&gt;rx_flags &amp; IEEE80211_RX_DEFERRED_RELEASE) &amp;&amp;
 	    (rx-&gt;sdata-&gt;vif.type == NL80211_IFTYPE_AP ||
 	     rx-&gt;sdata-&gt;vif.type == NL80211_IFTYPE_AP_VLAN) &amp;&amp;
<span class="p_del">-	    /* PM bit is only checked in frames where it isn&#39;t reserved,</span>
<span class="p_add">+	    /*</span>
<span class="p_add">+	     * PM bit is only checked in frames where it isn&#39;t reserved,</span>
 	     * in AP mode it&#39;s reserved in non-bufferable management frames
 	     * (cf. IEEE 802.11-2012 8.2.4.1.7 Power Management field)
<span class="p_add">+	     * BAR frames should be ignored as specified in</span>
<span class="p_add">+	     * IEEE 802.11-2012 10.2.1.2.</span>
 	     */
 	    (!ieee80211_is_mgmt(hdr-&gt;frame_control) ||
 	     ieee80211_is_bufferable_mmpdu(hdr-&gt;frame_control))) {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



