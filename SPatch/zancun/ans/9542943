
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[10/10] perf, tools, stat: Output JSON MetricExpr metric - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [10/10] perf, tools, stat: Output JSON MetricExpr metric</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=104">Andi Kleen</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 28, 2017, 2:03 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170128020345.19007-11-andi@firstfloor.org&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9542943/mbox/"
   >mbox</a>
|
   <a href="/patch/9542943/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9542943/">/patch/9542943/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	11DFA602A7 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 28 Jan 2017 02:10:46 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 00B7527F54
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 28 Jan 2017 02:10:46 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id E5F0627F9C; Sat, 28 Jan 2017 02:10:45 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id D9DC727F54
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 28 Jan 2017 02:10:44 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751359AbdA1CKh (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 27 Jan 2017 21:10:37 -0500
Received: from mga06.intel.com ([134.134.136.31]:33328 &quot;EHLO mga06.intel.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1750710AbdA1CK2 (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 27 Jan 2017 21:10:28 -0500
Received: from orsmga005.jf.intel.com ([10.7.209.41])
	by orsmga104.jf.intel.com with ESMTP; 27 Jan 2017 18:03:53 -0800
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i=&quot;5.33,298,1477983600&quot;; d=&quot;scan&#39;208&quot;;a=&quot;58158870&quot;
Received: from tassilo.jf.intel.com (HELO tassilo.localdomain)
	([10.7.201.35])
	by orsmga005.jf.intel.com with ESMTP; 27 Jan 2017 18:03:53 -0800
Received: by tassilo.localdomain (Postfix, from userid 1000)
	id 67DD4300884; Fri, 27 Jan 2017 18:03:53 -0800 (PST)
From: Andi Kleen &lt;andi@firstfloor.org&gt;
To: acme@kernel.org
Cc: jolsa@kernel.org, linux-kernel@vger.kernel.org,
	Andi Kleen &lt;ak@linux.intel.com&gt;
Subject: [PATCH 10/10] perf, tools, stat: Output JSON MetricExpr metric
Date: Fri, 27 Jan 2017 18:03:45 -0800
Message-Id: &lt;20170128020345.19007-11-andi@firstfloor.org&gt;
X-Mailer: git-send-email 2.9.3
In-Reply-To: &lt;20170128020345.19007-1-andi@firstfloor.org&gt;
References: &lt;20170128020345.19007-1-andi@firstfloor.org&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=104">Andi Kleen</a> - Jan. 28, 2017, 2:03 a.m.</div>
<pre class="content">
<span class="from">From: Andi Kleen &lt;ak@linux.intel.com&gt;</span>

Add generic infrastructure to perf stat to output ratios for &quot;MetricExpr&quot;
entries in the event lists. Many events are more useful as ratios
than in raw form, typically some count in relation to total ticks.

Transfer the MetricExpr information from the alias to the evsel.

We mark the events that need to be collected for MetricExpr, and also
link the events using them with a pointer. The code is careful
to always prefer the right event in the same group to minimize
multiplexing errors. At the moment only a single relation is supported.

Then add a rblist to the stat shadow code that remembers stats based
on the cpu and context.

Then finally update and retrieve and print these values similarly to the
existing hardcoded perf metrics. We use the simple expression parser
added earlier to evaluate the expression.

Normally we just output the result without further commentary,
but for --metric-only this would lead to empty columns. So for this
case use the original event as description.

So far there is no attempt to automatically add the MetricExpr event,
if it is missing, however we suggest it to the user.

$ perf stat -a -I 1000 -e &#39;{unc_p_clockticks,unc_p_freq_max_os_cycles}&#39;
     1.000228813        800,139,950      unc_p_clockticks
     1.000228813        789,833,783      unc_p_freq_max_os_cycles  #     98.7
     2.000654229        800,308,990      unc_p_clockticks
     2.000654229        396,214,238      unc_p_freq_max_os_cycles  #     49.5

$ perf stat -a -I 1000 -e &#39;{unc_p_clockticks,unc_p_freq_max_os_cycles}&#39; --metric-only
     1.000206740     48.0
     2.000451543     48.1

v2: Change from DivideBy to MetricExpr
<span class="signed-off-by">Signed-off-by: Andi Kleen &lt;ak@linux.intel.com&gt;</span>
---
 tools/perf/builtin-stat.c      |   3 +
 tools/perf/util/evsel.c        |   3 +
 tools/perf/util/evsel.h        |   3 +
 tools/perf/util/parse-events.c |   1 +
 tools/perf/util/pmu.c          |   8 ++-
 tools/perf/util/pmu.h          |   3 +-
 tools/perf/util/stat-shadow.c  | 152 +++++++++++++++++++++++++++++++++++++++++
 tools/perf/util/stat.h         |   2 +
 8 files changed, 171 insertions(+), 4 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=2522">Jiri Olsa</a> - Feb. 8, 2017, 11:31 a.m.</div>
<pre class="content">
On Fri, Jan 27, 2017 at 06:03:45PM -0800, Andi Kleen wrote:
<span class="quote">&gt; From: Andi Kleen &lt;ak@linux.intel.com&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Add generic infrastructure to perf stat to output ratios for &quot;MetricExpr&quot;</span>
<span class="quote">&gt; entries in the event lists. Many events are more useful as ratios</span>
<span class="quote">&gt; than in raw form, typically some count in relation to total ticks.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Transfer the MetricExpr information from the alias to the evsel.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; We mark the events that need to be collected for MetricExpr, and also</span>
<span class="quote">&gt; link the events using them with a pointer. The code is careful</span>
<span class="quote">&gt; to always prefer the right event in the same group to minimize</span>
<span class="quote">&gt; multiplexing errors. At the moment only a single relation is supported.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Then add a rblist to the stat shadow code that remembers stats based</span>
<span class="quote">&gt; on the cpu and context.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Then finally update and retrieve and print these values similarly to the</span>
<span class="quote">&gt; existing hardcoded perf metrics. We use the simple expression parser</span>
<span class="quote">&gt; added earlier to evaluate the expression.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Normally we just output the result without further commentary,</span>
<span class="quote">&gt; but for --metric-only this would lead to empty columns. So for this</span>
<span class="quote">&gt; case use the original event as description.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So far there is no attempt to automatically add the MetricExpr event,</span>
<span class="quote">&gt; if it is missing, however we suggest it to the user.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; $ perf stat -a -I 1000 -e &#39;{unc_p_clockticks,unc_p_freq_max_os_cycles}&#39;</span>
<span class="quote">&gt;      1.000228813        800,139,950      unc_p_clockticks</span>
<span class="quote">&gt;      1.000228813        789,833,783      unc_p_freq_max_os_cycles  #     98.7</span>
<span class="quote">&gt;      2.000654229        800,308,990      unc_p_clockticks</span>
<span class="quote">&gt;      2.000654229        396,214,238      unc_p_freq_max_os_cycles  #     49.5</span>

[jolsa@krava perf]$ ./perf stat -a -I 1000 -e &#39;{unc_p_clockticks,unc_p_freq_max_os_cycles}&#39;
invalid or unsupported event: &#39;{unc_p_clockticks,unc_p_freq_max_os_cycles}&#39;
Run &#39;perf list&#39; for a list of valid events

could you show an example of the MetricExpr?

it&#39;s part of the event record, what if you wanted to have 2 or more metrics defined for event?

who defines those expressions?

what if you dont provide the necessary events needed for the expression?

shouldnt we do it the other way around? like pick an expression
we are interested in and perf will configure the needful..
<span class="quote">
&gt; </span>
<span class="quote">&gt; $ perf stat -a -I 1000 -e &#39;{unc_p_clockticks,unc_p_freq_max_os_cycles}&#39; --metric-only</span>
<span class="quote">&gt;      1.000206740     48.0</span>
<span class="quote">&gt;      2.000451543     48.1</span>

how does user know what those number stand for?

is there a way for user to display the metric expression?

it&#39;s still feels to me like a hack without much concept behind

jirka
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=104">Andi Kleen</a> - Feb. 8, 2017, 9:51 p.m.</div>
<pre class="content">
On Wed, Feb 08, 2017 at 12:31:34PM +0100, Jiri Olsa wrote:
<span class="quote">&gt; On Fri, Jan 27, 2017 at 06:03:45PM -0800, Andi Kleen wrote:</span>
<span class="quote">&gt; &gt; From: Andi Kleen &lt;ak@linux.intel.com&gt;</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Add generic infrastructure to perf stat to output ratios for &quot;MetricExpr&quot;</span>
<span class="quote">&gt; &gt; entries in the event lists. Many events are more useful as ratios</span>
<span class="quote">&gt; &gt; than in raw form, typically some count in relation to total ticks.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Transfer the MetricExpr information from the alias to the evsel.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; We mark the events that need to be collected for MetricExpr, and also</span>
<span class="quote">&gt; &gt; link the events using them with a pointer. The code is careful</span>
<span class="quote">&gt; &gt; to always prefer the right event in the same group to minimize</span>
<span class="quote">&gt; &gt; multiplexing errors. At the moment only a single relation is supported.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Then add a rblist to the stat shadow code that remembers stats based</span>
<span class="quote">&gt; &gt; on the cpu and context.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Then finally update and retrieve and print these values similarly to the</span>
<span class="quote">&gt; &gt; existing hardcoded perf metrics. We use the simple expression parser</span>
<span class="quote">&gt; &gt; added earlier to evaluate the expression.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Normally we just output the result without further commentary,</span>
<span class="quote">&gt; &gt; but for --metric-only this would lead to empty columns. So for this</span>
<span class="quote">&gt; &gt; case use the original event as description.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; So far there is no attempt to automatically add the MetricExpr event,</span>
<span class="quote">&gt; &gt; if it is missing, however we suggest it to the user.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; $ perf stat -a -I 1000 -e &#39;{unc_p_clockticks,unc_p_freq_max_os_cycles}&#39;</span>
<span class="quote">&gt; &gt;      1.000228813        800,139,950      unc_p_clockticks</span>
<span class="quote">&gt; &gt;      1.000228813        789,833,783      unc_p_freq_max_os_cycles  #     98.7</span>
<span class="quote">&gt; &gt;      2.000654229        800,308,990      unc_p_clockticks</span>
<span class="quote">&gt; &gt;      2.000654229        396,214,238      unc_p_freq_max_os_cycles  #     49.5</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [jolsa@krava perf]$ ./perf stat -a -I 1000 -e &#39;{unc_p_clockticks,unc_p_freq_max_os_cycles}&#39;</span>
<span class="quote">&gt; invalid or unsupported event: &#39;{unc_p_clockticks,unc_p_freq_max_os_cycles}&#39;</span>
<span class="quote">&gt; Run &#39;perf list&#39; for a list of valid events</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; could you show an example of the MetricExpr?</span>

It&#39;s in the event list branch

https://git.kernel.org/cgit/linux/kernel/git/ak/linux-misc.git/log/?h=perf/intel-uncore-json-files-3

All the metrics currently do is just the same as DividedBy earlier:
generate a percentage out of a count, typically based on clock ticks.

+        &quot;MetricExpr&quot;: &quot;(UNC_M_POWER_CHANNEL_PPD / UNC_M_CLOCKTICKS) *
100.&quot;,
<span class="quote">


&gt; </span>
<span class="quote">&gt; it&#39;s part of the event record, what if you wanted to have 2 or more metrics defined for event?</span>

Would need multiple copies of the event.
<span class="quote">
&gt; </span>
<span class="quote">&gt; who defines those expressions?</span>

It&#39;s metrics used internally by Intel.
<span class="quote">
&gt; </span>
<span class="quote">&gt; what if you dont provide the necessary events needed for the expression?</span>

Then perf prints a warning suggesting the events.

It&#39;s currently a TODO to add them automatically. Could be added,
but the patch was already complex, so I didn&#39;t add it.

It&#39;s somewhat complicated because you would need to avoid
duplicates and have to handle groups correctly. perf stat
doesn&#39;t have the necessarily knowledge to fully understand
the constraints on groups. 

Then the extra event may not fit into the group, and it seemed
saner to let the user decide what to do then, instead of
generating a possible unschedulable group.

So it&#39;s not that easy to do it automatically.
<span class="quote">
&gt; &gt; </span>
<span class="quote">&gt; &gt; $ perf stat -a -I 1000 -e &#39;{unc_p_clockticks,unc_p_freq_max_os_cycles}&#39; --metric-only</span>
<span class="quote">&gt; &gt;      1.000206740     48.0</span>
<span class="quote">&gt; &gt;      2.000451543     48.1</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; how does user know what those number stand for?</span>

I assume it was obvious enough that it is the percentage. Could
add something more to the event description.
<span class="quote">
&gt; </span>
<span class="quote">&gt; is there a way for user to display the metric expression?</span>

Only in the source, but could be added to perf list -v

For most users metrics are much more useful than raw numbers.
I think they would rather consider raw numbers to be a &quot;hack
with no concept&quot;

-Andi
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=2522">Jiri Olsa</a> - Feb. 9, 2017, 11:39 a.m.</div>
<pre class="content">
On Wed, Feb 08, 2017 at 01:51:05PM -0800, Andi Kleen wrote:

SNIP
<span class="quote">
&gt; &gt; </span>
<span class="quote">&gt; &gt; could you show an example of the MetricExpr?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It&#39;s in the event list branch</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; https://git.kernel.org/cgit/linux/kernel/git/ak/linux-misc.git/log/?h=perf/intel-uncore-json-files-3</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; All the metrics currently do is just the same as DividedBy earlier:</span>
<span class="quote">&gt; generate a percentage out of a count, typically based on clock ticks.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; +        &quot;MetricExpr&quot;: &quot;(UNC_M_POWER_CHANNEL_PPD / UNC_M_CLOCKTICKS) *</span>
<span class="quote">&gt; 100.&quot;,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; it&#39;s part of the event record, what if you wanted to have 2 or more metrics defined for event?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Would need multiple copies of the event.</span>

this ...
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; who defines those expressions?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It&#39;s metrics used internally by Intel.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; what if you dont provide the necessary events needed for the expression?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Then perf prints a warning suggesting the events.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It&#39;s currently a TODO to add them automatically. Could be added,</span>
<span class="quote">&gt; but the patch was already complex, so I didn&#39;t add it.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It&#39;s somewhat complicated because you would need to avoid</span>
<span class="quote">&gt; duplicates and have to handle groups correctly. perf stat</span>
<span class="quote">&gt; doesn&#39;t have the necessarily knowledge to fully understand</span>
<span class="quote">&gt; the constraints on groups. </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Then the extra event may not fit into the group, and it seemed</span>
<span class="quote">&gt; saner to let the user decide what to do then, instead of</span>
<span class="quote">&gt; generating a possible unschedulable group.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So it&#39;s not that easy to do it automatically.</span>

and this makes me think, that this is not the right approach

adding extra copy of an event when you want to add new expression?

why can&#39;t we have another list/file of those expressions
from which point we could point and configure events we need

jirka
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=2522">Jiri Olsa</a> - Feb. 9, 2017, 11:42 a.m.</div>
<pre class="content">
On Wed, Feb 08, 2017 at 01:51:05PM -0800, Andi Kleen wrote:

SNIP
<span class="quote">
&gt; Only in the source, but could be added to perf list -v</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; For most users metrics are much more useful than raw numbers.</span>
<span class="quote">&gt; I think they would rather consider raw numbers to be a &quot;hack</span>
<span class="quote">&gt; with no concept&quot;</span>

well, we can always fix that by showing the column header,
but that&#39;s not what I meant

jirka
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123">Andi Kleen</a> - Feb. 9, 2017, 5 p.m.</div>
<pre class="content">
On Thu, Feb 09, 2017 at 12:39:37PM +0100, Jiri Olsa wrote:
<span class="quote">&gt; and this makes me think, that this is not the right approach</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; adding extra copy of an event when you want to add new expression?</span>

I don&#39;t want to add new expressions.

I don&#39;t even need arbitrary expressions, just DividedBy
to get percentages, you just forced me to do the expressions.
<span class="quote">

&gt; why can&#39;t we have another list/file of those expressions</span>

The last time I proposed separate files Ingo vetoed it.
He wanted everything built in.
<span class="quote">
&gt; from which point we could point and configure events we need</span>

If you want full flexibility you can use your perf stat report
approach, or what most people do is to just run a script/spreadsheet
over the the -x; output. This all continues to work.

This is just a minimum approach to provide some convenience
integrated with the event list to provide something similar
as the built in expressions in stat-shadow. 

It&#39;s not trying to build the great perf scripting language.

-Andi
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=2522">Jiri Olsa</a> - Feb. 9, 2017, 6:37 p.m.</div>
<pre class="content">
On Thu, Feb 09, 2017 at 09:00:35AM -0800, Andi Kleen wrote:
<span class="quote">&gt; On Thu, Feb 09, 2017 at 12:39:37PM +0100, Jiri Olsa wrote:</span>
<span class="quote">&gt; &gt; and this makes me think, that this is not the right approach</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; adding extra copy of an event when you want to add new expression?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I don&#39;t want to add new expressions.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I don&#39;t even need arbitrary expressions, just DividedBy</span>
<span class="quote">&gt; to get percentages, you just forced me to do the expressions.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; why can&#39;t we have another list/file of those expressions</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The last time I proposed separate files Ingo vetoed it.</span>
<span class="quote">&gt; He wanted everything built in.</span>

sure, he veto it for event files.. expressions could be built
in same way as we have events now
<span class="quote">
&gt; &gt; from which point we could point and configure events we need</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; If you want full flexibility you can use your perf stat report</span>
<span class="quote">&gt; approach, or what most people do is to just run a script/spreadsheet</span>
<span class="quote">&gt; over the the -x; output. This all continues to work.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This is just a minimum approach to provide some convenience</span>
<span class="quote">&gt; integrated with the event list to provide something similar</span>
<span class="quote">&gt; as the built in expressions in stat-shadow. </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It&#39;s not trying to build the great perf scripting language.</span>

yea I understand that but can&#39;t ack that based on the points
I descibed in my other email

jirka
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=104">Andi Kleen</a> - Feb. 9, 2017, 6:59 p.m.</div>
<pre class="content">
On Thu, Feb 09, 2017 at 07:37:55PM +0100, Jiri Olsa wrote:
<span class="quote">&gt; &gt; The last time I proposed separate files Ingo vetoed it.</span>
<span class="quote">&gt; &gt; He wanted everything built in.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; sure, he veto it for event files.. expressions could be built</span>
<span class="quote">&gt; in same way as we have events now</span>

That&#39;s exactly what I implemented. The expression is part
of the JSON file, which seems like the logical place.

You just want it in a separate file in the source?
<span class="quote">

&gt; </span>
<span class="quote">&gt; &gt; &gt; from which point we could point and configure events we need</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; If you want full flexibility you can use your perf stat report</span>
<span class="quote">&gt; &gt; approach, or what most people do is to just run a script/spreadsheet</span>
<span class="quote">&gt; &gt; over the the -x; output. This all continues to work.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; This is just a minimum approach to provide some convenience</span>
<span class="quote">&gt; &gt; integrated with the event list to provide something similar</span>
<span class="quote">&gt; &gt; as the built in expressions in stat-shadow. </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; It&#39;s not trying to build the great perf scripting language.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; yea I understand that but can&#39;t ack that based on the points</span>
<span class="quote">&gt; I descibed in my other email</span>

So what are the crucial points that prevent you?

- You want better column descriptions? 

I suppose could add another field for this.

- You want multiple expressions per event 
(even though they are not needed today)?

It could be implemented, but seems like unnecessary
complexity and overengineering to me at this point.
If nobody ever uses it would it be time spent well?
If someone really uses it they could add the support at that
time.

- You want automatic group creation?

It has nasty corner cases.
It would be possible to build something that works
for simple cases.

Anything I missed?

-Andi
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=2522">Jiri Olsa</a> - Feb. 10, 2017, 8:22 a.m.</div>
<pre class="content">
On Thu, Feb 09, 2017 at 10:59:43AM -0800, Andi Kleen wrote:
<span class="quote">&gt; On Thu, Feb 09, 2017 at 07:37:55PM +0100, Jiri Olsa wrote:</span>
<span class="quote">&gt; &gt; &gt; The last time I proposed separate files Ingo vetoed it.</span>
<span class="quote">&gt; &gt; &gt; He wanted everything built in.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; sure, he veto it for event files.. expressions could be built</span>
<span class="quote">&gt; &gt; in same way as we have events now</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; That&#39;s exactly what I implemented. The expression is part</span>
<span class="quote">&gt; of the JSON file, which seems like the logical place.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; You just want it in a separate file in the source?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; from which point we could point and configure events we need</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; If you want full flexibility you can use your perf stat report</span>
<span class="quote">&gt; &gt; &gt; approach, or what most people do is to just run a script/spreadsheet</span>
<span class="quote">&gt; &gt; &gt; over the the -x; output. This all continues to work.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; This is just a minimum approach to provide some convenience</span>
<span class="quote">&gt; &gt; &gt; integrated with the event list to provide something similar</span>
<span class="quote">&gt; &gt; &gt; as the built in expressions in stat-shadow. </span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; It&#39;s not trying to build the great perf scripting language.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; yea I understand that but can&#39;t ack that based on the points</span>
<span class="quote">&gt; &gt; I descibed in my other email</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So what are the crucial points that prevent you?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; - You want better column descriptions? </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I suppose could add another field for this.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; - You want multiple expressions per event </span>
<span class="quote">&gt; (even though they are not needed today)?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It could be implemented, but seems like unnecessary</span>
<span class="quote">&gt; complexity and overengineering to me at this point.</span>
<span class="quote">&gt; If nobody ever uses it would it be time spent well?</span>
<span class="quote">&gt; If someone really uses it they could add the support at that</span>
<span class="quote">&gt; time.</span>

ok, I checked optimization doc and you might be right about this one,
I couldn&#39;t find an example that&#39;d prove you wrong ;-)

however I dont think expression should be annonymous number
tied to an event. For example there&#39;s this one:

  B.7.9.2  
  Fast Synchronization Penalty
  50. Locked Operations Impact: (L1D_CACHE_LOCK_DURATION + 20 * L1D_CACHE_LOCK.MESI) / CPU_CLK_UNHALTED.CORE * 100

  Fast synchronization is frequently implemented usin
  g locked memory accesses. A high value for Locked 
  Operations Impact indicates that locked operations us
  ed in the workload have high penalty. The latency 
  of a locked operation depends on the location of the 
  data: L1 data cache, L2 cache, other core cache or 
  memory.

There&#39;s a name and description.

which event will pick this expression?  L1D_CACHE_LOCK_DURATION or L1D_CACHE_LOCK?

How about we add:

&quot;MetricExpr&quot;:      &quot;(L1D_CACHE_LOCK_DURATION + 20 * L1D_CACHE_LOCK.MESI) / CPU_CLK_UNHALTED.CORE * 100&quot;
&quot;MetricExprName&quot;:  &quot;Fast Synchronization Penalty&quot;
&quot;MetricExprDoc&quot;:   &quot;Fast synchronization is frequently implemented... &quot;

then it could be part of the event record and we can display it
like use the name in column and doc in the perf list

We could append number or something (MetricExpr2..) if there&#39;ll
be multiple expressions in some case.. or something like that
<span class="quote">
&gt; </span>
<span class="quote">&gt; - You want automatic group creation?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It has nasty corner cases.</span>
<span class="quote">&gt; It would be possible to build something that works</span>
<span class="quote">&gt; for simple cases.</span>

that would be nice.. when user says perf stat -e &#39;Fast Synchronization Penalty&#39; ...
it&#39;d create necessary events for him.. or some shorted name probably

jirka
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/tools/perf/builtin-stat.c b/tools/perf/builtin-stat.c</span>
<span class="p_header">index 765346a581b3..806d957bbe6a 100644</span>
<span class="p_header">--- a/tools/perf/builtin-stat.c</span>
<span class="p_header">+++ b/tools/perf/builtin-stat.c</span>
<span class="p_chunk">@@ -1141,6 +1141,7 @@</span> <span class="p_context"> static void printout(int id, int nr, struct perf_evsel *counter, double uval,</span>
 	out.print_metric = pm;
 	out.new_line = nl;
 	out.ctx = &amp;os;
<span class="p_add">+	out.force_header = false;</span>
 
 	if (csv_output &amp;&amp; !metric_only) {
 		print_noise(counter, noise);
<span class="p_chunk">@@ -1478,6 +1479,7 @@</span> <span class="p_context"> static void print_metric_headers(const char *prefix, bool no_indent)</span>
 		out.ctx = &amp;os;
 		out.print_metric = print_metric_header;
 		out.new_line = new_line_metric;
<span class="p_add">+		out.force_header = true;</span>
 		os.evsel = counter;
 		perf_stat__print_shadow_stats(counter, 0,
 					      0,
<span class="p_chunk">@@ -2460,6 +2462,7 @@</span> <span class="p_context"> int cmd_stat(int argc, const char **argv, const char *prefix __maybe_unused)</span>
 	argc = parse_options_subcommand(argc, argv, stat_options, stat_subcommands,
 					(const char **) stat_usage,
 					PARSE_OPT_STOP_AT_NON_OPTION);
<span class="p_add">+	perf_stat__collect_metric_expr(evsel_list);</span>
 	perf_stat__init_shadow_stats();
 
 	if (csv_sep) {
<span class="p_header">diff --git a/tools/perf/util/evsel.c b/tools/perf/util/evsel.c</span>
<span class="p_header">index 04e536ae4d88..8db6c375487f 100644</span>
<span class="p_header">--- a/tools/perf/util/evsel.c</span>
<span class="p_header">+++ b/tools/perf/util/evsel.c</span>
<span class="p_chunk">@@ -236,6 +236,9 @@</span> <span class="p_context"> void perf_evsel__init(struct perf_evsel *evsel,</span>
 	evsel-&gt;sample_size = __perf_evsel__sample_size(attr-&gt;sample_type);
 	perf_evsel__calc_id_pos(evsel);
 	evsel-&gt;cmdline_group_boundary = false;
<span class="p_add">+	evsel-&gt;metric_expr   = NULL;</span>
<span class="p_add">+	evsel-&gt;metric_event   = NULL;</span>
<span class="p_add">+	evsel-&gt;collect_stat = false;</span>
 }
 
 struct perf_evsel *perf_evsel__new_idx(struct perf_event_attr *attr, int idx)
<span class="p_header">diff --git a/tools/perf/util/evsel.h b/tools/perf/util/evsel.h</span>
<span class="p_header">index bd2e9b112d49..92b0a9a3535d 100644</span>
<span class="p_header">--- a/tools/perf/util/evsel.h</span>
<span class="p_header">+++ b/tools/perf/util/evsel.h</span>
<span class="p_chunk">@@ -132,6 +132,9 @@</span> <span class="p_context"> struct perf_evsel {</span>
 	struct list_head	config_terms;
 	int			bpf_fd;
 	bool			merged_stat;
<span class="p_add">+	const char *		metric_expr;</span>
<span class="p_add">+	struct perf_evsel	*metric_event;</span>
<span class="p_add">+	bool			collect_stat;</span>
 };
 
 union u64_swap {
<span class="p_header">diff --git a/tools/perf/util/parse-events.c b/tools/perf/util/parse-events.c</span>
<span class="p_header">index fba53ba22431..6adc284ff434 100644</span>
<span class="p_header">--- a/tools/perf/util/parse-events.c</span>
<span class="p_header">+++ b/tools/perf/util/parse-events.c</span>
<span class="p_chunk">@@ -1252,6 +1252,7 @@</span> <span class="p_context"> int parse_events_add_pmu(struct parse_events_evlist *data,</span>
 		evsel-&gt;scale = info.scale;
 		evsel-&gt;per_pkg = info.per_pkg;
 		evsel-&gt;snapshot = info.snapshot;
<span class="p_add">+		evsel-&gt;metric_expr = info.metric_expr;</span>
 	}
 
 	return evsel ? 0 : -ENOMEM;
<span class="p_header">diff --git a/tools/perf/util/pmu.c b/tools/perf/util/pmu.c</span>
<span class="p_header">index b78b348068d7..28b9c5f0b547 100644</span>
<span class="p_header">--- a/tools/perf/util/pmu.c</span>
<span class="p_header">+++ b/tools/perf/util/pmu.c</span>
<span class="p_chunk">@@ -232,7 +232,7 @@</span> <span class="p_context"> static int __perf_pmu__new_alias(struct list_head *list, char *dir, char *name,</span>
 				 char *desc, char *val,
 				 char *long_desc, char *topic,
 				 char *unit, char *perpkg,
<span class="p_del">-				 char *dividedby)</span>
<span class="p_add">+				 char *metric_expr)</span>
 {
 	struct perf_pmu_alias *alias;
 	int ret;
<span class="p_chunk">@@ -266,7 +266,7 @@</span> <span class="p_context"> static int __perf_pmu__new_alias(struct list_head *list, char *dir, char *name,</span>
 		perf_pmu__parse_snapshot(alias, dir, name);
 	}
 
<span class="p_del">-	alias-&gt;dividedby = dividedby ? strdup(dividedby) : NULL;</span>
<span class="p_add">+	alias-&gt;metric_expr = metric_expr ? strdup(metric_expr) : NULL;</span>
 	alias-&gt;desc = desc ? strdup(desc) : NULL;
 	alias-&gt;long_desc = long_desc ? strdup(long_desc) :
 				desc ? strdup(desc) : NULL;
<span class="p_chunk">@@ -567,7 +567,7 @@</span> <span class="p_context"> static void pmu_add_cpu_aliases(struct list_head *head, const char *name)</span>
 				(char *)pe-&gt;desc, (char *)pe-&gt;event,
 				(char *)pe-&gt;long_desc, (char *)pe-&gt;topic,
 				(char *)pe-&gt;unit, (char *)pe-&gt;perpkg,
<span class="p_del">-				(char *)pe-&gt;dividedby);</span>
<span class="p_add">+				(char *)pe-&gt;metric_expr);</span>
 	}
 
 out:
<span class="p_chunk">@@ -985,6 +985,7 @@</span> <span class="p_context"> int perf_pmu__check_alias(struct perf_pmu *pmu, struct list_head *head_terms,</span>
 	info-&gt;unit     = NULL;
 	info-&gt;scale    = 0.0;
 	info-&gt;snapshot = false;
<span class="p_add">+	info-&gt;metric_expr = NULL;</span>
 
 	list_for_each_entry_safe(term, h, head_terms, list) {
 		alias = pmu_find_alias(pmu, term);
<span class="p_chunk">@@ -1000,6 +1001,7 @@</span> <span class="p_context"> int perf_pmu__check_alias(struct perf_pmu *pmu, struct list_head *head_terms,</span>
 
 		if (alias-&gt;per_pkg)
 			info-&gt;per_pkg = true;
<span class="p_add">+		info-&gt;metric_expr = alias-&gt;metric_expr;</span>
 
 		list_del(&amp;term-&gt;list);
 		free(term);
<span class="p_header">diff --git a/tools/perf/util/pmu.h b/tools/perf/util/pmu.h</span>
<span class="p_header">index faf8a7f97d03..27f078ccc594 100644</span>
<span class="p_header">--- a/tools/perf/util/pmu.h</span>
<span class="p_header">+++ b/tools/perf/util/pmu.h</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"> struct perf_pmu {</span>
 
 struct perf_pmu_info {
 	const char *unit;
<span class="p_add">+	const char *metric_expr;</span>
 	double scale;
 	bool per_pkg;
 	bool snapshot;
<span class="p_chunk">@@ -50,7 +51,7 @@</span> <span class="p_context"> struct perf_pmu_alias {</span>
 	double scale;
 	bool per_pkg;
 	bool snapshot;
<span class="p_del">-	char *dividedby;</span>
<span class="p_add">+	char *metric_expr;</span>
 };
 
 struct perf_pmu *perf_pmu__find(const char *name);
<span class="p_header">diff --git a/tools/perf/util/stat-shadow.c b/tools/perf/util/stat-shadow.c</span>
<span class="p_header">index 8a2bbd2a4d82..f22178ddc0ef 100644</span>
<span class="p_header">--- a/tools/perf/util/stat-shadow.c</span>
<span class="p_header">+++ b/tools/perf/util/stat-shadow.c</span>
<span class="p_chunk">@@ -3,6 +3,9 @@</span> <span class="p_context"></span>
 #include &quot;stat.h&quot;
 #include &quot;color.h&quot;
 #include &quot;pmu.h&quot;
<span class="p_add">+#include &quot;rblist.h&quot;</span>
<span class="p_add">+#include &quot;evlist.h&quot;</span>
<span class="p_add">+#include &quot;expr.h&quot;</span>
 
 enum {
 	CTX_BIT_USER	= 1 &lt;&lt; 0,
<span class="p_chunk">@@ -41,13 +44,73 @@</span> <span class="p_context"> static struct stats runtime_topdown_slots_issued[NUM_CTX][MAX_NR_CPUS];</span>
 static struct stats runtime_topdown_slots_retired[NUM_CTX][MAX_NR_CPUS];
 static struct stats runtime_topdown_fetch_bubbles[NUM_CTX][MAX_NR_CPUS];
 static struct stats runtime_topdown_recovery_bubbles[NUM_CTX][MAX_NR_CPUS];
<span class="p_add">+static struct rblist runtime_saved_values;</span>
 static bool have_frontend_stalled;
 
 struct stats walltime_nsecs_stats;
 
<span class="p_add">+struct saved_value {</span>
<span class="p_add">+	struct rb_node rb_node;</span>
<span class="p_add">+	struct perf_evsel *evsel;</span>
<span class="p_add">+	int cpu;</span>
<span class="p_add">+	int ctx;</span>
<span class="p_add">+	struct stats stats;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int saved_value_cmp(struct rb_node *rb_node, const void *entry)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct saved_value *a = container_of(rb_node,</span>
<span class="p_add">+					     struct saved_value,</span>
<span class="p_add">+					     rb_node);</span>
<span class="p_add">+	const struct saved_value *b = entry;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (a-&gt;ctx != b-&gt;ctx)</span>
<span class="p_add">+		return a-&gt;ctx - b-&gt;ctx;</span>
<span class="p_add">+	if (a-&gt;cpu != b-&gt;cpu)</span>
<span class="p_add">+		return a-&gt;cpu - b-&gt;cpu;</span>
<span class="p_add">+	return a-&gt;evsel - b-&gt;evsel;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct rb_node *saved_value_new(struct rblist *rblist __maybe_unused,</span>
<span class="p_add">+				     const void *entry)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct saved_value *nd = malloc(sizeof(struct saved_value));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!nd)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	memcpy(nd, entry, sizeof(struct saved_value));</span>
<span class="p_add">+	return &amp;nd-&gt;rb_node;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct saved_value *saved_value_lookup(struct perf_evsel *evsel,</span>
<span class="p_add">+					      int cpu, int ctx,</span>
<span class="p_add">+					      bool create)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rb_node *nd;</span>
<span class="p_add">+	struct saved_value dm = {</span>
<span class="p_add">+		.cpu = cpu,</span>
<span class="p_add">+		.ctx = ctx,</span>
<span class="p_add">+		.evsel = evsel,</span>
<span class="p_add">+	};</span>
<span class="p_add">+	nd = rblist__find(&amp;runtime_saved_values, &amp;dm);</span>
<span class="p_add">+	if (nd)</span>
<span class="p_add">+		return container_of(nd, struct saved_value, rb_node);</span>
<span class="p_add">+	if (create) {</span>
<span class="p_add">+		rblist__add_node(&amp;runtime_saved_values, &amp;dm);</span>
<span class="p_add">+		nd = rblist__find(&amp;runtime_saved_values, &amp;dm);</span>
<span class="p_add">+		if (nd)</span>
<span class="p_add">+			return container_of(nd, struct saved_value, rb_node);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void perf_stat__init_shadow_stats(void)
 {
 	have_frontend_stalled = pmu_have_event(&quot;cpu&quot;, &quot;stalled-cycles-frontend&quot;);
<span class="p_add">+	rblist__init(&amp;runtime_saved_values);</span>
<span class="p_add">+	runtime_saved_values.node_cmp = saved_value_cmp;</span>
<span class="p_add">+	runtime_saved_values.node_new = saved_value_new;</span>
<span class="p_add">+	/* No delete for now */</span>
 }
 
 static int evsel_context(struct perf_evsel *evsel)
<span class="p_chunk">@@ -70,6 +133,8 @@</span> <span class="p_context"> static int evsel_context(struct perf_evsel *evsel)</span>
 
 void perf_stat__reset_shadow_stats(void)
 {
<span class="p_add">+	struct rb_node *pos, *next;</span>
<span class="p_add">+</span>
 	memset(runtime_nsecs_stats, 0, sizeof(runtime_nsecs_stats));
 	memset(runtime_cycles_stats, 0, sizeof(runtime_cycles_stats));
 	memset(runtime_stalled_cycles_front_stats, 0, sizeof(runtime_stalled_cycles_front_stats));
<span class="p_chunk">@@ -92,6 +157,15 @@</span> <span class="p_context"> void perf_stat__reset_shadow_stats(void)</span>
 	memset(runtime_topdown_slots_issued, 0, sizeof(runtime_topdown_slots_issued));
 	memset(runtime_topdown_fetch_bubbles, 0, sizeof(runtime_topdown_fetch_bubbles));
 	memset(runtime_topdown_recovery_bubbles, 0, sizeof(runtime_topdown_recovery_bubbles));
<span class="p_add">+</span>
<span class="p_add">+	next = rb_first(&amp;runtime_saved_values.entries);</span>
<span class="p_add">+	while (next) {</span>
<span class="p_add">+		pos = next;</span>
<span class="p_add">+		next = rb_next(pos);</span>
<span class="p_add">+		memset(&amp;container_of(pos, struct saved_value, rb_node)-&gt;stats,</span>
<span class="p_add">+		       0,</span>
<span class="p_add">+		       sizeof(struct stats));</span>
<span class="p_add">+	}</span>
 }
 
 /*
<span class="p_chunk">@@ -143,6 +217,12 @@</span> <span class="p_context"> void perf_stat__update_shadow_stats(struct perf_evsel *counter, u64 *count,</span>
 		update_stats(&amp;runtime_dtlb_cache_stats[ctx][cpu], count[0]);
 	else if (perf_evsel__match(counter, HW_CACHE, HW_CACHE_ITLB))
 		update_stats(&amp;runtime_itlb_cache_stats[ctx][cpu], count[0]);
<span class="p_add">+</span>
<span class="p_add">+	if (counter-&gt;collect_stat) {</span>
<span class="p_add">+		struct saved_value *v = saved_value_lookup(counter, cpu, ctx,</span>
<span class="p_add">+							   true);</span>
<span class="p_add">+		update_stats(&amp;v-&gt;stats, count[0]);</span>
<span class="p_add">+	}</span>
 }
 
 /* used for get_ratio_color() */
<span class="p_chunk">@@ -172,6 +252,60 @@</span> <span class="p_context"> static const char *get_ratio_color(enum grc_type type, double ratio)</span>
 	return color;
 }
 
<span class="p_add">+static struct perf_evsel *perf_stat__find_event(struct perf_evlist *evsel_list,</span>
<span class="p_add">+						const char *name)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct perf_evsel *c2;</span>
<span class="p_add">+</span>
<span class="p_add">+	evlist__for_each_entry (evsel_list, c2) {</span>
<span class="p_add">+		if (!strcasecmp(c2-&gt;name, name))</span>
<span class="p_add">+			return c2;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Mark DividedBy target events and link events using them to them. */</span>
<span class="p_add">+void perf_stat__collect_metric_expr(struct perf_evlist *evsel_list)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct perf_evsel *counter, *leader, *c2;</span>
<span class="p_add">+	bool found;</span>
<span class="p_add">+	const char *metric_event;</span>
<span class="p_add">+</span>
<span class="p_add">+	evlist__for_each_entry(evsel_list, counter) {</span>
<span class="p_add">+		leader = counter-&gt;leader;</span>
<span class="p_add">+		if (!counter-&gt;metric_expr)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if (expr_find_other(counter-&gt;metric_expr, counter-&gt;name,</span>
<span class="p_add">+					&amp;metric_event) &lt; 0)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		found = false;</span>
<span class="p_add">+		if (leader) {</span>
<span class="p_add">+			/* Search in group */</span>
<span class="p_add">+			for_each_group_member (c2, leader) {</span>
<span class="p_add">+				if (!strcasecmp(c2-&gt;name, metric_event)) {</span>
<span class="p_add">+					found = true;</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (!found) {</span>
<span class="p_add">+			/* Search ignoring groups */</span>
<span class="p_add">+			c2 = perf_stat__find_event(evsel_list, metric_event);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (!c2) {</span>
<span class="p_add">+			/* Could try to automatically add the event here. */</span>
<span class="p_add">+			fprintf(stderr, &quot;Add %s to groups to get metric event for %s\n&quot;,</span>
<span class="p_add">+						metric_event,</span>
<span class="p_add">+						counter-&gt;name);</span>
<span class="p_add">+			counter-&gt;metric_expr = NULL;</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		counter-&gt;metric_event = c2;</span>
<span class="p_add">+		c2-&gt;collect_stat = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void print_stalled_cycles_frontend(int cpu,
 					  struct perf_evsel *evsel, double avg,
 					  struct perf_stat_output_ctx *out)
<span class="p_chunk">@@ -614,6 +748,24 @@</span> <span class="p_context"> void perf_stat__print_shadow_stats(struct perf_evsel *evsel,</span>
 					be_bound * 100.);
 		else
 			print_metric(ctxp, NULL, NULL, name, 0);
<span class="p_add">+	} else if (evsel-&gt;metric_expr) {</span>
<span class="p_add">+		struct saved_value *v = saved_value_lookup(evsel-&gt;metric_event, cpu, ctx,</span>
<span class="p_add">+							   false);</span>
<span class="p_add">+		if (v) {</span>
<span class="p_add">+			struct parse_ctx pctx;</span>
<span class="p_add">+			const char *p;</span>
<span class="p_add">+</span>
<span class="p_add">+			expr_ctx_init(&amp;pctx);</span>
<span class="p_add">+			expr_add_id(&amp;pctx, evsel-&gt;name, avg);</span>
<span class="p_add">+			expr_add_id(&amp;pctx, evsel-&gt;metric_event-&gt;name, avg_stats(&amp;v-&gt;stats));</span>
<span class="p_add">+			p = evsel-&gt;metric_expr;</span>
<span class="p_add">+			if (expr_parse(&amp;ratio, &amp;pctx, &amp;p) == 0)</span>
<span class="p_add">+				print_metric(ctxp, NULL, &quot;%8.1f&quot;,</span>
<span class="p_add">+					out-&gt;force_header ? evsel-&gt;name : &quot;&quot;,</span>
<span class="p_add">+					ratio);</span>
<span class="p_add">+			else</span>
<span class="p_add">+				print_metric(ctxp, NULL, NULL, &quot;&quot;, 0);</span>
<span class="p_add">+		}</span>
 	} else if (runtime_nsecs_stats[cpu].n != 0) {
 		char unit = &#39;M&#39;;
 		char unit_buf[10];
<span class="p_header">diff --git a/tools/perf/util/stat.h b/tools/perf/util/stat.h</span>
<span class="p_header">index c29bb94c48a4..0a65ae23f495 100644</span>
<span class="p_header">--- a/tools/perf/util/stat.h</span>
<span class="p_header">+++ b/tools/perf/util/stat.h</span>
<span class="p_chunk">@@ -85,11 +85,13 @@</span> <span class="p_context"> struct perf_stat_output_ctx {</span>
 	void *ctx;
 	print_metric_t print_metric;
 	new_line_t new_line;
<span class="p_add">+	bool force_header;</span>
 };
 
 void perf_stat__print_shadow_stats(struct perf_evsel *evsel,
 				   double avg, int cpu,
 				   struct perf_stat_output_ctx *out);
<span class="p_add">+void perf_stat__collect_metric_expr(struct perf_evlist *);</span>
 
 int perf_evlist__alloc_stats(struct perf_evlist *evlist, bool alloc_raw);
 void perf_evlist__free_stats(struct perf_evlist *evlist);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



