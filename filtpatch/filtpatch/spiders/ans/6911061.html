
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[4/4] powerpc: pm: support deep sleep feature on T104x - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [4/4] powerpc: pm: support deep sleep feature on T104x</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=38761">Zhao Chenhui</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>July 31, 2015, 12:53 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1438347186-8462-4-git-send-email-chenhui.zhao@freescale.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6911061/mbox/"
   >mbox</a>
|
   <a href="/patch/6911061/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6911061/">/patch/6911061/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 908EA9F380
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 31 Jul 2015 12:53:52 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 2BB3220611
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 31 Jul 2015 12:53:50 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 5769120608
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 31 Jul 2015 12:53:47 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752262AbbGaMxg (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 31 Jul 2015 08:53:36 -0400
Received: from mail-bl2on0107.outbound.protection.outlook.com
	([65.55.169.107]:4773
	&quot;EHLO na01-bl2-obe.outbound.protection.outlook.com&quot;
	rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
	id S1751013AbbGaMxc (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 31 Jul 2015 08:53:32 -0400
Received: from CO2PR03CA0048.namprd03.prod.outlook.com (10.141.194.175) by
	DM2PR03MB304.namprd03.prod.outlook.com (10.141.54.26) with Microsoft
	SMTP Server (TLS) id 15.1.225.19; Fri, 31 Jul 2015 12:53:29 +0000
Received: from BN1AFFO11FD008.protection.gbl (2a01:111:f400:7c10::116) by
	CO2PR03CA0048.outlook.office365.com (2a01:111:e400:1414::47) with
	Microsoft SMTP Server (TLS) id 15.1.225.19 via Frontend Transport;
	Fri, 31 Jul 2015 12:53:29 +0000
Authentication-Results: spf=fail (sender IP is 192.88.158.2)
	smtp.mailfrom=freescale.com; freescale.mail.onmicrosoft.com; dkim=none
	(message not signed) header.d=none;
Received-SPF: Fail (protection.outlook.com: domain of freescale.com does not
	designate 192.88.158.2 as permitted sender)
	receiver=protection.outlook.com; 
	client-ip=192.88.158.2; helo=az84smr01.freescale.net;
Received: from az84smr01.freescale.net (192.88.158.2) by
	BN1AFFO11FD008.mail.protection.outlook.com (10.58.52.68) with
	Microsoft SMTP Server (TLS) id 15.1.231.11 via Frontend Transport;
	Fri, 31 Jul 2015 12:53:26 +0000
Received: from localhost.localdomain ([10.193.20.174])
	by az84smr01.freescale.net (8.14.3/8.14.0) with ESMTP id
	t6VCrGZj029225; Fri, 31 Jul 2015 05:53:23 -0700
From: Chenhui Zhao &lt;chenhui.zhao@freescale.com&gt;
To: &lt;linuxppc-dev@lists.ozlabs.org&gt;, &lt;scottwood@freescale.com&gt;
CC: &lt;linux-kernel@vger.kernel.org&gt;, &lt;Jason.Jin@freescale.com&gt;
Subject: [PATCH 4/4] powerpc: pm: support deep sleep feature on T104x
Date: Fri, 31 Jul 2015 20:53:06 +0800
Message-ID: &lt;1438347186-8462-4-git-send-email-chenhui.zhao@freescale.com&gt;
X-Mailer: git-send-email 1.9.1
In-Reply-To: &lt;1438347186-8462-1-git-send-email-chenhui.zhao@freescale.com&gt;
References: &lt;1438347186-8462-1-git-send-email-chenhui.zhao@freescale.com&gt;
X-EOPAttributedMessage: 0
X-Microsoft-Exchange-Diagnostics: 1; BN1AFFO11FD008;
	1:lBILoGfcbT7HXkUC32Qe28AYAr6zIFLAZ3y1uto8mQsRLiOcgwG8V1breUSP2BUHdYGgVK8fhFXCTEaV0fBtwJhWz1dCyAxZz+6hxEbAJ/E8014T5Krj+1bOLpyPh06hBXfrhY5LopaLL7uzhTjSY5rFdF9nYtoQTx7xnZNBVWw01Au/AW57E5RkqcnUnCb0pJ0u9p/cK+Pa/HZ2cVni6t1/GxS2oGkaRc9jW7aDmG6pioP6n4JQlhEdmIlvvK1bnYt92OQ1Ru2abZKSd1Et9Bl8f6VQ9aY0xVtJ2Kpb7gKkC1cUGAlb6QHpT11JVg18jIPPRnjgkLjRhdTPOGm2xw==
X-Forefront-Antispam-Report: CIP:192.88.158.2; CTRY:US; IPV:NLI; EFV:NLI;
	SFV:NSPM;
	SFS:(10019020)(6009001)(2980300002)(339900001)(189002)(199003)(105606002)(2950100001)(107886002)(49486002)(77156002)(19580405001)(47776003)(77096005)(19580395003)(4001450100002)(46102003)(6806004)(5001770100001)(86362001)(85426001)(62966003)(33646002)(5001960100002)(50986999)(87936001)(36756003)(229853001)(104016003)(50226001)(50466002)(76176999)(48376002)(106466001)(92566002)(189998001)(4001430100001);
	DIR:OUT; SFP:1102; SCL:1; SRVR:DM2PR03MB304;
	H:az84smr01.freescale.net; FPR:; SPF:Fail; MLV:sfv; MX:1; A:1;
	LANG:en; 
MIME-Version: 1.0
Content-Type: text/plain
X-Microsoft-Exchange-Diagnostics: 1; DM2PR03MB304;
	2:CV4X8u1KHl7oBzCArRtn+vHoykzSHVDfOsDpUcDVTkG5KnvJy5vKzEYBybpZaJ4Q93V3GauVAnoe1Mwmo9C80SrBfAE8v1/fa2v8DJTOBKSoaMvG4qbesnyofyPi7X7ns53qkwK0VH1MfZFwheD+nF8nvp7HEzyTD5z3y56Sjfs=;
	3:wRP+tz98+/CIXv8Zk73hSUdoaTx7Bn4esE9iytGOIxxmtod4Tk0OmlGHH7UoIOWNiFPsjJfNu4ymcqCuyg8NPUOOOObkMe2lEVuuGHn+IYFwBFauP41W1yVSrbQRtk0YaiR1vaBzYR1JB2u+FWo5EoWjbxqPJfs+Gmlih7D067YJEXstO5qkm3P/816LO6TZehrksbwX/L+QTEVeRZBRxCR8UcBFXYQnWRKq+Njs/2c=;
	25:WVhwEdAzhrw4HHcGb9IhIlSx31YUYTQC5fklZU+t/PYHhlhyx/OHb8UzM9codAEqSQcZ+wHDO5GwQg2XXaHGpAd/7O1VcwYOud3Z9vXBOEvmXvnbp82ptbkv1e4NeHyuDQCWZ9w7M6Yswzi7E+Lfg1lLpj7D3pc4qMXCDTnWURXed62PKGvWdUy0u78jOMowpORoekBwZucwV04yjZgIe17rNQlaYSAoCPQIBwhcDAlmMHG6eBG6WJPrqANn4AvpKgpNJrwfntHsqaTgDVyuLg==
X-Microsoft-Antispam: UriScan:;BCL:0;PCL:0;RULEID:;SRVR:DM2PR03MB304;
X-Microsoft-Exchange-Diagnostics: 1; DM2PR03MB304;
	20:jppgvBxVuhngpqSqfl33hTRyG+o89hF9jtiGQuifgIbOqQl8wP8/0czeUFWxhDkVEe0bNAyKQaYeZ7X53uT0VwKCGlQiK8TAe+gZh0WXe/oi2rLOc3r+7rBkfYcGyCTDw8VtN0YJiYnnP86b9MSTjEAGo6ChB5Dc1h3fyL5X79eN6fRsxisJIlaYI/Bt0/bn4d6MyqgB8I4SLDIjF0zUAj89PV2IpSsNRAWxuzMb0oI3OugGiAI6PdVbad/ZKHrlF7fKg6LKF+nTkuxJACivJXC4md5EjLAXSwf8t+WwbIDHKbcsU5XX9n3zbKNyT6subiUWftPVSA4j3rxloBu+9pRpwrqF+bRPRvctqTjU+uk=;
	4:SS2zb96e0mgxmga1i6SpUCs6kUdzRe/uVD7bYV8WxvHq2xfm4dGB1bnsgwAJh5NY7UEIKNjk1jNRPlTs+7NQJ8GokkvPJQ5AJuZwPXmFRR+1AcJgR6Vt29Q+vNJfQ3o3JfIw41vZ3TMdpkY8zzUKUQEM+9B6KkeVIzwqf7o3ME9xxPG4NVrtdai3hYnyWNvYV0AIMoJ68D4Uten52SfCv4k9u2o3vMaUGnpxtyjZfLDBhXaJTdFcRGicBnA3G/8pnD65MzBCMT1JfUfjCbzfwAe0rVxjjUYrJCpiytAHEak=
DM2PR03MB304: X-MS-Exchange-Organization-RulesExecuted
X-Microsoft-Antispam-PRVS: &lt;DM2PR03MB304901DD611EE157E47FE329F8A0@DM2PR03MB304.namprd03.prod.outlook.com&gt;
X-Exchange-Antispam-Report-Test: UriScan:;
X-Exchange-Antispam-Report-CFA-Test: BCL:0; PCL:0;
	RULEID:(601004)(5005006)(3002001); SRVR:DM2PR03MB304; BCL:0;
	PCL:0; RULEID:; SRVR:DM2PR03MB304; 
X-Forefront-PRVS: 0654257CF5
X-Microsoft-Exchange-Diagnostics: =?us-ascii?Q?1; DM2PR03MB304;
	23:sAwMat9B2+aluVrRKemBjZrGZNeiKBNMJxPLCAeM//?=
	=?us-ascii?Q?30IsBwodFGfl9hOM3ww0G0Nh27AU4EFKZv4gjmBWB84US0gNbqT1imF6d5LK?=
	=?us-ascii?Q?UZeH3O5gKb96KUirpLfeII1w6Kypfm2bqpYDVsvMqZLn8sGEIBXnLDo0abGj?=
	=?us-ascii?Q?FHrnNQ6NSAATLuk+B/DL0ciZlJjfccCrt/vOWwRia2fiDVMWun20URTgFsag?=
	=?us-ascii?Q?dfSKINs2dU03VX7F30eRs/4adrOikwyqDiACfAeOM+vxvoYRro94a6sqKDpD?=
	=?us-ascii?Q?GVaiFLWrzU35PVTkdsGvGTtsEHEWfOEx3jMKaQzbjo3I9IZECHE2B1KdCZpP?=
	=?us-ascii?Q?2DkEsiEz4o2nvKOjIs1AtPsCyymudU+lXX+e+oS8MumANaVNXcNqinFpOQ71?=
	=?us-ascii?Q?gkJZS6QY2BO7t6A6DR2OmUVEwkgMOuB4LgzfSd9wMKB5VmpMjoKT6J8ixl4i?=
	=?us-ascii?Q?AJsERNxlcPTVES45jnUq6HHr9LP5AKn0oT5LNc23vq5pGPydLzJN93ziYKNW?=
	=?us-ascii?Q?79Fe63rZiI/THQ/JSXw67kDe4cNevHpixLYbmJkew9XyEPJkv+0uIcqvPuWP?=
	=?us-ascii?Q?roblNZmptkomzQGWa0Xhy4ULcR5MS+vfzZI0dxbxjiBPj/RHBNQQk5nRHeFV?=
	=?us-ascii?Q?Svpd4i9fZQuwM61LckmOBhSReq1xU06EmxC8lkb0DHL7lBSFBQKHIIjyyjbM?=
	=?us-ascii?Q?7JxJD0Zj1P3/zs2dZ0P+QJCYunXMDEeE91aAwFaFcPgVahtgbkMN81/mX//R?=
	=?us-ascii?Q?s/lLLExtBv3b+9IPqklChEK7FKAUwaNYgydESxQ7vgQJmRhm/N7c25ECk2Xc?=
	=?us-ascii?Q?a6pLEhfQE4J7ZDsnwRPd5AgzX7fXr7mZzbY3b3l7v2Cgc/510KOH2Ua9lbom?=
	=?us-ascii?Q?QlqJvSqrvPMIHA7xzOTR6YJM70ugmoFREh2J6U0R0DvIRm8YQwwKkW92NuAW?=
	=?us-ascii?Q?7bdykyqGc771Ru65TKzL7n/YUOs0uDz+s3llOWMA=3D=3D?=
X-Microsoft-Exchange-Diagnostics: 1; DM2PR03MB304;
	5:AMTCxLGTqFvT/z92jytF/Bgc9ujiaNYoW8G/+/z2G0q1aOBiUnS7lSX/ZSHTSLa2/f+XRi8xZXdfjSCnynJIoa4tKB48LgbVmewoFS11yJebYCOZsh3u4s284EYbOtwy4DpMOVX2K28k9ulWTCclSQ==;
	24:m7oehpvyW1ufXx2wGNSHAw3muddAoCZf7bcWHfHDpHN6v3XvX03sn1ewdq9nT21NJOGm8yvI/cwG/w8ohcGLegRP+Mc0J9BmeU+G28lVI6s=;
	20:63x3CpB4c378lxPWODN3sXO50EA4Mydqvekd14MOqEvtBeEDSrQqH6EXKEJZ8cviJzynEg0j6Xs7JEt51jDMkg==
X-OriginatorOrg: freescale.com
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 31 Jul 2015 12:53:26.6366
	(UTC)
X-MS-Exchange-CrossTenant-Id: 710a03f5-10f6-4d38-9ff4-a80b81da590d
X-MS-Exchange-CrossTenant-OriginalAttributedTenantConnectingIp: TenantId=710a03f5-10f6-4d38-9ff4-a80b81da590d;
	Ip=[192.88.158.2]; Helo=[az84smr01.freescale.net]
X-MS-Exchange-CrossTenant-FromEntityHeader: HybridOnPrem
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DM2PR03MB304
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-8.3 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=38761">Zhao Chenhui</a> - July 31, 2015, 12:53 p.m.</div>
<pre class="content">
T104x has deep sleep feature, which can switch off most parts of
the SoC when it is in deep sleep mode. This way, it becomes more
energy-efficient.

The DDR controller will also be powered off in deep sleep. Therefore,
the last stage (the latter part of fsl_dp_enter_low) will run without DDR
access. This piece of code and related TLBs are prefetched in advance.

Due to the different initialization code between 32-bit and 64-bit, they
have separate resume entry and precedure.

The feature supports 32-bit and 64-bit kernel mode.
<span class="signed-off-by">
Signed-off-by: Chenhui Zhao &lt;chenhui.zhao@freescale.com&gt;</span>
---
 arch/powerpc/include/asm/fsl_pm.h             |  14 +
 arch/powerpc/kernel/fsl_booke_entry_mapping.S |  10 +
 arch/powerpc/kernel/head_64.S                 |   2 +-
 arch/powerpc/platforms/85xx/Makefile          |   1 +
 arch/powerpc/platforms/85xx/deepsleep.c       | 322 +++++++++++++++
 arch/powerpc/platforms/85xx/qoriq_pm.c        |  81 +++-
 arch/powerpc/platforms/85xx/t104x_deepsleep.S | 570 ++++++++++++++++++++++++++
 7 files changed, 997 insertions(+), 3 deletions(-)
 create mode 100644 arch/powerpc/platforms/85xx/deepsleep.c
 create mode 100644 arch/powerpc/platforms/85xx/t104x_deepsleep.S
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=1011">Scott Wood</a> - Aug. 1, 2015, 2:49 a.m.</div>
<pre class="content">
On Fri, 2015-07-31 at 20:53 +0800, Chenhui Zhao wrote:
<span class="quote">&gt; diff --git a/arch/powerpc/kernel/fsl_booke_entry_mapping.S </span>
<span class="quote">&gt; b/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="quote">&gt; index f22e7e4..32ec426f 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="quote">&gt; +++ b/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="quote">&gt; @@ -170,6 +170,10 @@ skpinv:  addi    r6,r6,1                         /* Increment */</span>
<span class="quote">&gt;       lis     r6,MAS2_VAL(PAGE_OFFSET, BOOK3E_PAGESZ_64M, M_IF_SMP)@h</span>
<span class="quote">&gt;       ori     r6,r6,MAS2_VAL(PAGE_OFFSET, BOOK3E_PAGESZ_64M, M_IF_SMP)@l</span>
<span class="quote">&gt;       mtspr   SPRN_MAS2,r6</span>
<span class="quote">&gt; +#ifdef ENTRY_DEEPSLEEP_SETUP</span>
<span class="quote">&gt; +     LOAD_REG_IMMEDIATE(r8, MEMORY_START)</span>
<span class="quote">&gt; +     ori     r8,r8,(MAS3_SX|MAS3_SW|MAS3_SR)</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt;       mtspr   SPRN_MAS3,r8</span>
<span class="quote">&gt;       tlbwe</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; @@ -212,12 +216,18 @@ next_tlb_setup:</span>
<span class="quote">&gt;       #error You need to specify the mapping or not use this at all.</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +#ifdef ENTRY_DEEPSLEEP_SETUP</span>
<span class="quote">&gt; +     LOAD_REG_ADDR(r6, 2f)</span>
<span class="quote">&gt; +     mfmsr   r7</span>
<span class="quote">&gt; +     rlwinm  r7,r7,0,~(MSR_IS|MSR_DS)</span>
<span class="quote">&gt; +#else</span>
<span class="quote">&gt;       lis     r7,MSR_KERNEL@h</span>
<span class="quote">&gt;       ori     r7,r7,MSR_KERNEL@l</span>
<span class="quote">&gt;       bl      1f                      /* Find our address */</span>
<span class="quote">&gt;  1:   mflr    r9</span>
<span class="quote">&gt;       rlwimi  r6,r9,0,20,31</span>
<span class="quote">&gt;       addi    r6,r6,(2f - 1b)</span>
<span class="quote">&gt; +#endif</span>

Could you explain what&#39;s going on here?  What does the TLB look like before 
and after?
<span class="quote">
&gt; +int fsl_dp_iomap(void)</span>

I don&#39;t think this needs to be global (see the comment where it gets called), 
but if it must be, this name is too terse.
<span class="quote">
&gt; +{</span>
<span class="quote">&gt; +     struct device_node *np;</span>
<span class="quote">&gt; +     int ret = 0;</span>
<span class="quote">&gt; +     phys_addr_t ccsr_phy_addr, dcsr_phy_addr;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +     saved_law = NULL;</span>
<span class="quote">&gt; +     ccsr_base = NULL;</span>
<span class="quote">&gt; +     dcsr_base = NULL;</span>
<span class="quote">&gt; +     pld_base = NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +     ccsr_phy_addr = get_immrbase();</span>
<span class="quote">&gt; +     if (ccsr_phy_addr == -1) {</span>
<span class="quote">&gt; +             pr_err(&quot;%s: Can&#39;t get the address of CCSR\n&quot;, __func__);</span>
<span class="quote">&gt; +             ret = -EINVAL;</span>
<span class="quote">&gt; +             goto ccsr_err;</span>
<span class="quote">&gt; +     }</span>
<span class="quote">&gt; +     ccsr_base = ioremap(ccsr_phy_addr, SIZE_2MB);</span>
<span class="quote">&gt; +     if (!ccsr_base) {</span>
<span class="quote">&gt; +             ret = -ENOMEM;</span>
<span class="quote">&gt; +             goto ccsr_err;</span>
<span class="quote">&gt; +     }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +     dcsr_phy_addr = get_dcsrbase();</span>
<span class="quote">&gt; +     if (dcsr_phy_addr == -1) {</span>
<span class="quote">&gt; +             pr_err(&quot;%s: Can&#39;t get the address of DCSR\n&quot;, __func__);</span>
<span class="quote">&gt; +             ret = -EINVAL;</span>
<span class="quote">&gt; +             goto dcsr_err;</span>
<span class="quote">&gt; +     }</span>
<span class="quote">&gt; +     dcsr_base = ioremap(dcsr_phy_addr, SIZE_1MB);</span>
<span class="quote">&gt; +     if (!dcsr_base) {</span>
<span class="quote">&gt; +             ret = -ENOMEM;</span>
<span class="quote">&gt; +             goto dcsr_err;</span>
<span class="quote">&gt; +     }</span>

Please just map the device tree nodes you need.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +     np = of_find_compatible_node(NULL, NULL, &quot;fsl,tetra-fpga&quot;);</span>
<span class="quote">&gt; +     if (np) {</span>
<span class="quote">&gt; +             pld_flag = T1040QDS_TETRA_FLAG;</span>
<span class="quote">&gt; +     } else {</span>
<span class="quote">&gt; +             np = of_find_compatible_node(NULL, NULL, &quot;fsl,deepsleep-cpld&quot;);</span>

I&#39;ve already rejected fsl,deepsleep-cpld multiple times when others tried to 
add it to a device tree.
<span class="quote">
&gt; +{</span>
<span class="quote">&gt; +     u32 ddr_buff_addr;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +     /*</span>
<span class="quote">&gt; +      * DDR training initialization will break 128 bytes at the beginning</span>
<span class="quote">&gt; +      * of DDR, therefore, save them so that the bootloader will restore</span>
<span class="quote">&gt; +      * them. Assume that DDR is mapped to the address space started with</span>
<span class="quote">&gt; +      * CONFIG_PAGE_OFFSET.</span>
<span class="quote">&gt; +      */</span>
<span class="quote">&gt; +     memcpy(ddr_buff, (void *)CONFIG_PAGE_OFFSET, DDR_BUF_SIZE);</span>

That assumption may not be true in all relocatable scenarios.

It&#39;d be a lot simpler to just mark that first page as reserved.
<span class="quote">
&gt; +     /* assume ddr_buff is in the physical address space of 4GB */</span>
<span class="quote">&gt; +     ddr_buff_addr = (u32)(__pa(ddr_buff) &amp; 0xffffffff);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +     /*</span>
<span class="quote">&gt; +      * the bootloader will restore the first 128 bytes of DDR from</span>
<span class="quote">&gt; +      * the location indicated by the register SPARECR3</span>
<span class="quote">&gt; +      */</span>
<span class="quote">&gt; +     out_be32(ccsr_base + CCSR_SCFG_SPARECR3, ddr_buff_addr);</span>

...yeah, please just mark it reserved.
<span class="quote">
&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void fsl_dp_mp_save(void *ccsr)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +      struct fsl_bstr *dst = &amp;saved_bstr;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +      dst-&gt;bstrh = in_be32(ccsr + LCC_BSTRH);</span>
<span class="quote">&gt; +      dst-&gt;bstrl = in_be32(ccsr + LCC_BSTRL);</span>
<span class="quote">&gt; +      dst-&gt;bstar = in_be32(ccsr + LCC_BSTAR);</span>
<span class="quote">&gt; +      dst-&gt;cpu_mask = in_be32(ccsr + DCFG_BASE + DCFG_BRR);</span>
<span class="quote">&gt; +}</span>

What is &quot;mp&quot;?
<span class="quote">
&gt; +static void fsl_dp_law_save(void *ccsr)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +     int i;</span>
<span class="quote">&gt; +     struct fsl_law *dst = saved_law;</span>
<span class="quote">&gt; +     struct fsl_law *src = (void *)(ccsr + CCSR_LAW_BASE);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +     for (i = 0; i &lt; num_laws; i++) {</span>
<span class="quote">&gt; +             dst-&gt;lawbarh = in_be32(&amp;src-&gt;lawbarh);</span>
<span class="quote">&gt; +             dst-&gt;lawbarl = in_be32(&amp;src-&gt;lawbarl);</span>
<span class="quote">&gt; +             dst-&gt;lawar = in_be32(&amp;src-&gt;lawar);</span>
<span class="quote">&gt; +             dst++;</span>
<span class="quote">&gt; +             src++;</span>
<span class="quote">&gt; +     }</span>
<span class="quote">&gt; +}</span>

Why wouldn&#39;t U-Boot restore these the same way on resume as they are now?
<span class="quote">
&gt; +int fsl_enter_epu_deepsleep(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +     fsl_dp_ddr_save(ccsr_base);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +     fsl_dp_set_resume_pointer(ccsr_base);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +     fsl_dp_mp_save(ccsr_base);</span>
<span class="quote">&gt; +     fsl_dp_law_save(ccsr_base);</span>
<span class="quote">&gt; +     /*  enable Warm Device Reset request. */</span>
<span class="quote">&gt; +     setbits32(ccsr_base + CCSR_SCFG_DPSLPCR, CCSR_SCFG_DPSLPCR_WDRR_EN);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +     /* set GPIO1_29 as an output pin (not open-drain), and output 0 */</span>
<span class="quote">&gt; +     clrbits32(ccsr_base + CCSR_GPIO1_GPDAT, CCSR_GPIO1_GPDIR_29);</span>
<span class="quote">&gt; +     clrbits32(ccsr_base + CCSR_GPIO1_GPODR, CCSR_GPIO1_GPDIR_29);</span>
<span class="quote">&gt; +     setbits32(ccsr_base + CCSR_GPIO1_GPDIR, CCSR_GPIO1_GPDIR_29);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +     /*</span>
<span class="quote">&gt; +      * Disable CPC speculation to avoid deep sleep hang, especially</span>
<span class="quote">&gt; +      * in secure boot mode. This bit will be cleared automatically</span>
<span class="quote">&gt; +      * when resuming from deep sleep.</span>
<span class="quote">&gt; +      */</span>
<span class="quote">&gt; +     setbits32(ccsr_base + CPC_CPCHDBCR0, CPC_CPCHDBCR0_SPEC_DIS);</span>

Is there an erratum for this?
<span class="quote">
&gt; +     fsl_epu_setup_default(dcsr_base + EPU_BLOCK_OFFSET);</span>
<span class="quote">&gt; +     fsl_npc_setup_default(dcsr_base + NPC_BLOCK_OFFSET);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +     out_be32(dcsr_base + RCPM_BLOCK_OFFSET + CSTTACR0, 0x00001001);</span>
<span class="quote">&gt; +     out_be32(dcsr_base + RCPM_BLOCK_OFFSET + CG1CR0, 0x00000001);</span>

What is 0x1001 and 0x1 here?
<span class="quote">
&gt; diff --git a/arch/powerpc/platforms/85xx/qoriq_pm.c </span>
<span class="quote">&gt; b/arch/powerpc/platforms/85xx/qoriq_pm.c</span>
<span class="quote">&gt; index 27ec337..f65f6cf 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/platforms/85xx/qoriq_pm.c</span>
<span class="quote">&gt; +++ b/arch/powerpc/platforms/85xx/qoriq_pm.c</span>
<span class="quote">&gt; @@ -17,17 +17,68 @@</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #include &lt;asm/fsl_pm.h&gt;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +static suspend_state_t cur_pm_state;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/**</span>
<span class="quote">&gt; + * fsl_set_power_except - set which IP block is not powerdown when sleep or</span>
<span class="quote">&gt; + * deep sleep, such as MAC, USB, etc.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * @dev: a pointer to the struct device of the device with wakeup </span>
<span class="quote">&gt; capability</span>
<span class="quote">&gt; + * @on: if 1, do not power down; if 0, power down.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +static void fsl_set_power_except(struct device *dev, int on)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +     u32 value[2];</span>
<span class="quote">&gt; +     int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +     ret = of_property_read_u32_array(dev-&gt;of_node, &quot;sleep&quot;, value, 2);</span>
<span class="quote">&gt; +     if (ret)</span>
<span class="quote">&gt; +             goto out;</span>

This property is not defined in the binding for t1040, and was largely 
abandoned.  Nothing in the kernel currently uses it.

It might be better to do something with the clock API.  Then again, it might 
be an odd fit given the odd nature of this register.  Then again, it&#39;s an 
equally bad fit for the sleep property as currently documented (on the only 
85xx the binding supports, it&#39;s used for DEVDISR).  In any case, don&#39;t use 
this without a binding update.

This function will also crash if you pass it a device that doesn&#39;t have an 
of_node.
<span class="quote">
&gt;       switch (state) {</span>
<span class="quote">&gt;       case PM_SUSPEND_STANDBY:</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;               cur_cpu_spec-&gt;cpu_down_flush();</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;               ret = qoriq_pm_ops-&gt;plat_enter_sleep();</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +             break;</span>

Why are you adding these blank lines, particularly right after the case line?
<span class="quote">
&gt; +     case PM_SUSPEND_MEM:</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +             cpu = smp_processor_id();</span>
<span class="quote">&gt; +             qoriq_pm_ops-&gt;irq_mask(cpu);</span>

Should this be hard_smp_processor_id()?
<span class="quote">
&gt; +static int qoriq_suspend_begin(suspend_state_t state)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +     const int enable = 1;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +     cur_pm_state = state;</span>
<span class="quote">&gt; +     dpm_for_each_dev((void *)&amp;enable, qoriq_set_wakeup_source);</span>

Unnecessary cast.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +     if (cur_pm_state == PM_SUSPEND_MEM)</span>
<span class="quote">&gt; +             return fsl_dp_iomap();</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +     return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void qoriq_suspend_end(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +     const int enable = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +     dpm_for_each_dev((void *)&amp;enable, qoriq_set_wakeup_source);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +     if (cur_pm_state == PM_SUSPEND_MEM)</span>
<span class="quote">&gt; +             fsl_dp_iounmap();</span>
<span class="quote">&gt; +}</span>

Why are you mapping/unmapping on demand?  Just map it once at bootup.

 static int __init qoriq_suspend_init(void)
<span class="quote">&gt;  {</span>
<span class="quote">&gt;       suspend_set_ops(&amp;qoriq_suspend_ops);</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt;       return 0;</span>
<span class="quote">&gt;  }</span>

Please don&#39;t make random whitespace changes, especially to code you&#39;re not 
otherwise touching.
<span class="quote">

&gt;  arch_initcall(qoriq_suspend_init);</span>
<span class="quote">&gt; diff --git a/arch/powerpc/platforms/85xx/t104x_deepsleep.S </span>
<span class="quote">&gt; b/arch/powerpc/platforms/85xx/t104x_deepsleep.S</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 0000000..773a9e4</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/powerpc/platforms/85xx/t104x_deepsleep.S</span>
<span class="quote">&gt; @@ -0,0 +1,570 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Enter and resume from deep sleep state</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * Copyright 2015 Freescale Semiconductor Inc.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * This program is free software; you can redistribute       it and/or modify it</span>
<span class="quote">&gt; + * under  the terms of       the GNU General  Public License as published by the</span>
<span class="quote">&gt; + * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="quote">&gt; + * option) any later version.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;asm/page.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/ppc_asm.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/reg.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/asm-offsets.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/fsl_pm.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/mmu.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * the number of bytes occupied by one register</span>
<span class="quote">&gt; + * the value of 8 is compatible with both 32-bit and 64-bit registers</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +#define STRIDE_SIZE          8</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* GPR0 - GPR31 */</span>
<span class="quote">&gt; +#define BOOKE_GPR0_OFF               0x0000</span>
<span class="quote">&gt; +#define BOOKE_GPR_COUNT              32</span>
<span class="quote">&gt; +/* IVOR0 - IVOR42 */</span>
<span class="quote">&gt; +#define BOOKE_IVOR0_OFF         (BOOKE_GPR0_OFF + BOOKE_GPR_COUNT * STRIDE_SIZE)</span>
<span class="quote">&gt; +#define BOOKE_IVOR_COUNT     43</span>
<span class="quote">&gt; +/* SPRG0 - SPRG9 */</span>
<span class="quote">&gt; +#define BOOKE_SPRG0_OFF         (BOOKE_IVOR0_OFF + BOOKE_IVOR_COUNT * </span>
<span class="quote">&gt; STRIDE_SIZE)</span>
<span class="quote">&gt; +#define BOOKE_SPRG_COUNT     10</span>
<span class="quote">&gt; +/* IVPR */</span>
<span class="quote">&gt; +#define BOOKE_IVPR_OFF          (BOOKE_SPRG0_OFF + BOOKE_SPRG_COUNT * </span>
<span class="quote">&gt; STRIDE_SIZE)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define BOOKE_LR_OFF         (BOOKE_IVPR_OFF + STRIDE_SIZE)</span>
<span class="quote">&gt; +#define BOOKE_MSR_OFF                (BOOKE_LR_OFF + STRIDE_SIZE)</span>
<span class="quote">&gt; +#define BOOKE_TBU_OFF                (BOOKE_MSR_OFF + STRIDE_SIZE)</span>
<span class="quote">&gt; +#define BOOKE_TBL_OFF                (BOOKE_TBU_OFF + STRIDE_SIZE)</span>
<span class="quote">&gt; +#define BOOKE_EPCR_OFF               (BOOKE_TBL_OFF + STRIDE_SIZE)</span>
<span class="quote">&gt; +#define BOOKE_HID0_OFF               (BOOKE_EPCR_OFF + STRIDE_SIZE)</span>
<span class="quote">&gt; +#define BOOKE_PIR_OFF                (BOOKE_HID0_OFF + STRIDE_SIZE)</span>
<span class="quote">&gt; +#define BOOKE_PID0_OFF               (BOOKE_PIR_OFF + STRIDE_SIZE)</span>
<span class="quote">&gt; +#define BOOKE_BUCSR_OFF              (BOOKE_PID0_OFF + STRIDE_SIZE)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define BUFFER_SIZE          (BOOKE_BUCSR_OFF + STRIDE_SIZE)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#undef SAVE_GPR</span>
<span class="quote">&gt; +#define SAVE_GPR(gpr, offset) \</span>
<span class="quote">&gt; +     PPC_STL gpr, offset(r10)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define RESTORE_GPR(gpr, offset) \</span>
<span class="quote">&gt; +     PPC_LL gpr, offset(r10)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define SAVE_SPR(spr, offset) \</span>
<span class="quote">&gt; +     mfspr   r0, spr ;\</span>
<span class="quote">&gt; +     PPC_STL r0, offset(r10)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define RESTORE_SPR(spr, offset) \</span>
<span class="quote">&gt; +     PPC_LL  r0, offset(r10) ;\</span>
<span class="quote">&gt; +     mtspr   spr, r0</span>

No space before ;
<span class="quote">
&gt; +/* reset time base to prevent from overflow */</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * There are two kind of register maps, one for T1040QDS and</span>
<span class="quote">&gt; + * the other for T104xRDB.</span>
<span class="quote">&gt; + */</span>

And then what happens on a custom board?  Is there any way this stuff can 
happen earlier, from C code?  In any case, please rework so that there&#39;s a 
function pointer for board-specific logic.

-Scott

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/powerpc/include/asm/fsl_pm.h b/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="p_header">index 4b09f09..b44f484 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"></span>
 #define __PPC_FSL_PM_H
 #ifdef __KERNEL__
 
<span class="p_add">+#ifndef __ASSEMBLY__</span>
 #define E500_PM_PH10	1
 #define E500_PM_PH15	2
 #define E500_PM_PH20	3
<span class="p_chunk">@@ -44,5 +45,18 @@</span> <span class="p_context"> struct fsl_pm_ops {</span>
 };
 
 extern const struct fsl_pm_ops *qoriq_pm_ops;
<span class="p_add">+</span>
<span class="p_add">+extern int fsl_dp_iomap(void);</span>
<span class="p_add">+extern void fsl_dp_iounmap(void);</span>
<span class="p_add">+</span>
<span class="p_add">+extern int fsl_enter_epu_deepsleep(void);</span>
<span class="p_add">+extern void fsl_dp_enter_low(void __iomem *ccsr_base, void __iomem *dcsr_base,</span>
<span class="p_add">+			     void __iomem *pld_base, int pld_flag);</span>
<span class="p_add">+extern void fsl_booke_deep_sleep_resume(void);</span>
<span class="p_add">+#endif	/* __ASSEMBLY__ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define T1040QDS_TETRA_FLAG	1</span>
<span class="p_add">+#define T104xRDB_CPLD_FLAG	2</span>
<span class="p_add">+</span>
 #endif /* __KERNEL__ */
 #endif /* __PPC_FSL_PM_H */
<span class="p_header">diff --git a/arch/powerpc/kernel/fsl_booke_entry_mapping.S b/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="p_header">index f22e7e4..32ec426f 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="p_chunk">@@ -170,6 +170,10 @@</span> <span class="p_context"> skpinv:	addi	r6,r6,1				/* Increment */</span>
 	lis	r6,MAS2_VAL(PAGE_OFFSET, BOOK3E_PAGESZ_64M, M_IF_SMP)@h
 	ori	r6,r6,MAS2_VAL(PAGE_OFFSET, BOOK3E_PAGESZ_64M, M_IF_SMP)@l
 	mtspr	SPRN_MAS2,r6
<span class="p_add">+#ifdef ENTRY_DEEPSLEEP_SETUP</span>
<span class="p_add">+	LOAD_REG_IMMEDIATE(r8, MEMORY_START)</span>
<span class="p_add">+	ori	r8,r8,(MAS3_SX|MAS3_SW|MAS3_SR)</span>
<span class="p_add">+#endif</span>
 	mtspr	SPRN_MAS3,r8
 	tlbwe
 
<span class="p_chunk">@@ -212,12 +216,18 @@</span> <span class="p_context"> next_tlb_setup:</span>
 	#error You need to specify the mapping or not use this at all.
 #endif
 
<span class="p_add">+#ifdef ENTRY_DEEPSLEEP_SETUP</span>
<span class="p_add">+	LOAD_REG_ADDR(r6, 2f)</span>
<span class="p_add">+	mfmsr	r7</span>
<span class="p_add">+	rlwinm	r7,r7,0,~(MSR_IS|MSR_DS)</span>
<span class="p_add">+#else</span>
 	lis	r7,MSR_KERNEL@h
 	ori	r7,r7,MSR_KERNEL@l
 	bl	1f			/* Find our address */
 1:	mflr	r9
 	rlwimi	r6,r9,0,20,31
 	addi	r6,r6,(2f - 1b)
<span class="p_add">+#endif</span>
 	mtspr	SPRN_SRR0,r6
 	mtspr	SPRN_SRR1,r7
 	rfi				/* start execution out of TLB1[0] entry */
<span class="p_header">diff --git a/arch/powerpc/kernel/head_64.S b/arch/powerpc/kernel/head_64.S</span>
<span class="p_header">index d48125d..b9eb02a 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/head_64.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/head_64.S</span>
<span class="p_chunk">@@ -696,7 +696,7 @@</span> <span class="p_context"> _GLOBAL(start_secondary_resume)</span>
 /*
  * This subroutine clobbers r11 and r12
  */
<span class="p_del">-enable_64b_mode:</span>
<span class="p_add">+_GLOBAL(enable_64b_mode)</span>
 	mfmsr	r11			/* grab the current MSR */
 #ifdef CONFIG_PPC_BOOK3E
 	oris	r11,r11,0x8000		/* CM bit set, we&#39;ll set ICM later */
<span class="p_header">diff --git a/arch/powerpc/platforms/85xx/Makefile b/arch/powerpc/platforms/85xx/Makefile</span>
<span class="p_header">index 87fb847..a73d563 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/85xx/Makefile</span>
<span class="p_header">+++ b/arch/powerpc/platforms/85xx/Makefile</span>
<span class="p_chunk">@@ -4,6 +4,7 @@</span> <span class="p_context"></span>
 obj-$(CONFIG_SMP) += smp.o
 obj-$(CONFIG_FSL_PMC)		  += mpc85xx_pm_ops.o
 obj-$(CONFIG_FSL_QORIQ_PM)	  += qoriq_pm.o sleep_fsm.o
<span class="p_add">+obj-$(CONFIG_FSL_QORIQ_PM)	  += deepsleep.o t104x_deepsleep.o</span>
 
 obj-y += common.o
 
<span class="p_header">diff --git a/arch/powerpc/platforms/85xx/deepsleep.c b/arch/powerpc/platforms/85xx/deepsleep.c</span>
new file mode 100644
<span class="p_header">index 0000000..5de904d</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/powerpc/platforms/85xx/deepsleep.c</span>
<span class="p_chunk">@@ -0,0 +1,322 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Support deep sleep feature for T104x</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright 2015 Freescale Semiconductor Inc.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Author: Chenhui Zhao &lt;chenhui.zhao@freescale.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute	it and/or modify it</span>
<span class="p_add">+ * under  the terms of	the GNU General	 Public License as published by the</span>
<span class="p_add">+ * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="p_add">+ * option) any later version.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/kernel.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_platform.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_address.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+#include &lt;sysdev/fsl_soc.h&gt;</span>
<span class="p_add">+#include &lt;asm/machdep.h&gt;</span>
<span class="p_add">+#include &lt;asm/fsl_pm.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;sleep_fsm.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#define SIZE_1MB	0x100000</span>
<span class="p_add">+#define SIZE_2MB	0x200000</span>
<span class="p_add">+</span>
<span class="p_add">+#define CPC_CPCHDBCR0		0x10f00</span>
<span class="p_add">+#define CPC_CPCHDBCR0_SPEC_DIS	0x08000000</span>
<span class="p_add">+</span>
<span class="p_add">+#define CCSR_SCFG_DPSLPCR	0xfc000</span>
<span class="p_add">+#define CCSR_SCFG_DPSLPCR_WDRR_EN	0x1</span>
<span class="p_add">+#define CCSR_SCFG_SPARECR2	0xfc504</span>
<span class="p_add">+#define CCSR_SCFG_SPARECR3	0xfc508</span>
<span class="p_add">+</span>
<span class="p_add">+#define CCSR_GPIO1_GPDIR	0x130000</span>
<span class="p_add">+#define CCSR_GPIO1_GPODR	0x130004</span>
<span class="p_add">+#define CCSR_GPIO1_GPDAT	0x130008</span>
<span class="p_add">+#define CCSR_GPIO1_GPDIR_29	0x4</span>
<span class="p_add">+</span>
<span class="p_add">+#define CCSR_LAW_BASE		0xC00</span>
<span class="p_add">+#define DCFG_BRR	0xE4	/* boot release register */</span>
<span class="p_add">+#define LCC_BSTRH	0x20	/* Boot space translation register high */</span>
<span class="p_add">+#define LCC_BSTRL	0x24	/* Boot space translation register low */</span>
<span class="p_add">+#define LCC_BSTAR	0x28	/* Boot space translation attribute register */</span>
<span class="p_add">+#define RCPM_PCTBENR	0x1A0	/* Physical Core Timebase Enable Register */</span>
<span class="p_add">+#define RCPM_BASE	0xE2000</span>
<span class="p_add">+#define DCFG_BASE	0xE0000</span>
<span class="p_add">+</span>
<span class="p_add">+/* 128 bytes buffer for restoring data broke by DDR training initialization */</span>
<span class="p_add">+#define DDR_BUF_SIZE	128</span>
<span class="p_add">+static u8 ddr_buff[DDR_BUF_SIZE] __aligned(64);</span>
<span class="p_add">+</span>
<span class="p_add">+static void *dcsr_base, *ccsr_base, *pld_base;</span>
<span class="p_add">+static int pld_flag;</span>
<span class="p_add">+</span>
<span class="p_add">+/* save LAW registers */</span>
<span class="p_add">+struct fsl_law {</span>
<span class="p_add">+	u32	lawbarh;	/* LAWn base address high */</span>
<span class="p_add">+	u32	lawbarl;	/* LAWn base address low */</span>
<span class="p_add">+	u32	lawar;		/* LAWn attributes */</span>
<span class="p_add">+	u32	reserved;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct fsl_law *saved_law;</span>
<span class="p_add">+static u32 num_laws;</span>
<span class="p_add">+</span>
<span class="p_add">+/* for nonboot cpu */</span>
<span class="p_add">+struct fsl_bstr {</span>
<span class="p_add">+	u32	bstrh;</span>
<span class="p_add">+	u32	bstrl;</span>
<span class="p_add">+	u32	bstar;</span>
<span class="p_add">+	u32 cpu_mask;</span>
<span class="p_add">+};</span>
<span class="p_add">+static struct fsl_bstr saved_bstr;</span>
<span class="p_add">+</span>
<span class="p_add">+int fsl_dp_iomap(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *np;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	phys_addr_t ccsr_phy_addr, dcsr_phy_addr;</span>
<span class="p_add">+</span>
<span class="p_add">+	saved_law = NULL;</span>
<span class="p_add">+	ccsr_base = NULL;</span>
<span class="p_add">+	dcsr_base = NULL;</span>
<span class="p_add">+	pld_base = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	ccsr_phy_addr = get_immrbase();</span>
<span class="p_add">+	if (ccsr_phy_addr == -1) {</span>
<span class="p_add">+		pr_err(&quot;%s: Can&#39;t get the address of CCSR\n&quot;, __func__);</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto ccsr_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	ccsr_base = ioremap(ccsr_phy_addr, SIZE_2MB);</span>
<span class="p_add">+	if (!ccsr_base) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto ccsr_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dcsr_phy_addr = get_dcsrbase();</span>
<span class="p_add">+	if (dcsr_phy_addr == -1) {</span>
<span class="p_add">+		pr_err(&quot;%s: Can&#39;t get the address of DCSR\n&quot;, __func__);</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto dcsr_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	dcsr_base = ioremap(dcsr_phy_addr, SIZE_1MB);</span>
<span class="p_add">+	if (!dcsr_base) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto dcsr_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	np = of_find_compatible_node(NULL, NULL, &quot;fsl,tetra-fpga&quot;);</span>
<span class="p_add">+	if (np) {</span>
<span class="p_add">+		pld_flag = T1040QDS_TETRA_FLAG;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		np = of_find_compatible_node(NULL, NULL, &quot;fsl,deepsleep-cpld&quot;);</span>
<span class="p_add">+		if (np) {</span>
<span class="p_add">+			pld_flag = T104xRDB_CPLD_FLAG;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			pr_err(&quot;%s: Can&#39;t find the FPGA/CPLD node\n&quot;,</span>
<span class="p_add">+					__func__);</span>
<span class="p_add">+			ret = -EINVAL;</span>
<span class="p_add">+			goto pld_err;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	pld_base = of_iomap(np, 0);</span>
<span class="p_add">+	of_node_put(np);</span>
<span class="p_add">+</span>
<span class="p_add">+	np = of_find_compatible_node(NULL, NULL, &quot;fsl,corenet-law&quot;);</span>
<span class="p_add">+	if (!np) {</span>
<span class="p_add">+		pr_err(&quot;%s: Can&#39;t find the node of \&quot;law\&quot;\n&quot;, __func__);</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto alloc_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	ret = of_property_read_u32(np, &quot;fsl,num-laws&quot;, &amp;num_laws);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto alloc_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	saved_law = kcalloc(num_laws, sizeof(struct fsl_law), GFP_KERNEL);</span>
<span class="p_add">+	if (!saved_law) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto alloc_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	of_node_put(np);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+alloc_err:</span>
<span class="p_add">+	iounmap(pld_base);</span>
<span class="p_add">+	pld_base = NULL;</span>
<span class="p_add">+pld_err:</span>
<span class="p_add">+	iounmap(dcsr_base);</span>
<span class="p_add">+	dcsr_base = NULL;</span>
<span class="p_add">+dcsr_err:</span>
<span class="p_add">+	iounmap(ccsr_base);</span>
<span class="p_add">+	ccsr_base = NULL;</span>
<span class="p_add">+ccsr_err:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void fsl_dp_iounmap(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (dcsr_base) {</span>
<span class="p_add">+		iounmap(dcsr_base);</span>
<span class="p_add">+		dcsr_base = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ccsr_base) {</span>
<span class="p_add">+		iounmap(ccsr_base);</span>
<span class="p_add">+		ccsr_base = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pld_base) {</span>
<span class="p_add">+		iounmap(pld_base);</span>
<span class="p_add">+		pld_base = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(saved_law);</span>
<span class="p_add">+	saved_law = NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void fsl_dp_ddr_save(void *ccsr_base)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 ddr_buff_addr;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * DDR training initialization will break 128 bytes at the beginning</span>
<span class="p_add">+	 * of DDR, therefore, save them so that the bootloader will restore</span>
<span class="p_add">+	 * them. Assume that DDR is mapped to the address space started with</span>
<span class="p_add">+	 * CONFIG_PAGE_OFFSET.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	memcpy(ddr_buff, (void *)CONFIG_PAGE_OFFSET, DDR_BUF_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* assume ddr_buff is in the physical address space of 4GB */</span>
<span class="p_add">+	ddr_buff_addr = (u32)(__pa(ddr_buff) &amp; 0xffffffff);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * the bootloader will restore the first 128 bytes of DDR from</span>
<span class="p_add">+	 * the location indicated by the register SPARECR3</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	out_be32(ccsr_base + CCSR_SCFG_SPARECR3, ddr_buff_addr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void fsl_dp_mp_save(void *ccsr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	 struct fsl_bstr *dst = &amp;saved_bstr;</span>
<span class="p_add">+</span>
<span class="p_add">+	 dst-&gt;bstrh = in_be32(ccsr + LCC_BSTRH);</span>
<span class="p_add">+	 dst-&gt;bstrl = in_be32(ccsr + LCC_BSTRL);</span>
<span class="p_add">+	 dst-&gt;bstar = in_be32(ccsr + LCC_BSTAR);</span>
<span class="p_add">+	 dst-&gt;cpu_mask = in_be32(ccsr + DCFG_BASE + DCFG_BRR);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void fsl_dp_mp_restore(void *ccsr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	 struct fsl_bstr *src = &amp;saved_bstr;</span>
<span class="p_add">+</span>
<span class="p_add">+	 out_be32(ccsr + LCC_BSTRH, src-&gt;bstrh);</span>
<span class="p_add">+	 out_be32(ccsr + LCC_BSTRL, src-&gt;bstrl);</span>
<span class="p_add">+	 out_be32(ccsr + LCC_BSTAR, src-&gt;bstar);</span>
<span class="p_add">+</span>
<span class="p_add">+	 /* release the nonboot cpus */</span>
<span class="p_add">+	 out_be32(ccsr + DCFG_BASE + DCFG_BRR, src-&gt;cpu_mask);</span>
<span class="p_add">+</span>
<span class="p_add">+	 /* enable the time base */</span>
<span class="p_add">+	 out_be32(ccsr + RCPM_BASE + RCPM_PCTBENR, src-&gt;cpu_mask);</span>
<span class="p_add">+	 /* read back to sync write */</span>
<span class="p_add">+	 in_be32(ccsr + RCPM_BASE + RCPM_PCTBENR);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void fsl_dp_law_save(void *ccsr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	struct fsl_law *dst = saved_law;</span>
<span class="p_add">+	struct fsl_law *src = (void *)(ccsr + CCSR_LAW_BASE);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; num_laws; i++) {</span>
<span class="p_add">+		dst-&gt;lawbarh = in_be32(&amp;src-&gt;lawbarh);</span>
<span class="p_add">+		dst-&gt;lawbarl = in_be32(&amp;src-&gt;lawbarl);</span>
<span class="p_add">+		dst-&gt;lawar = in_be32(&amp;src-&gt;lawar);</span>
<span class="p_add">+		dst++;</span>
<span class="p_add">+		src++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void fsl_dp_law_restore(void *ccsr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	struct fsl_law *src = saved_law;</span>
<span class="p_add">+	struct fsl_law *dst = (void *)(ccsr + CCSR_LAW_BASE);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; num_laws - 1; i++) {</span>
<span class="p_add">+		out_be32(&amp;dst-&gt;lawar, 0);</span>
<span class="p_add">+		out_be32(&amp;dst-&gt;lawbarl, src-&gt;lawbarl);</span>
<span class="p_add">+		out_be32(&amp;dst-&gt;lawbarh, src-&gt;lawbarh);</span>
<span class="p_add">+		out_be32(&amp;dst-&gt;lawar, src-&gt;lawar);</span>
<span class="p_add">+</span>
<span class="p_add">+		 /* Read back so that we sync the writes */</span>
<span class="p_add">+		in_be32(&amp;dst-&gt;lawar);</span>
<span class="p_add">+		src++;</span>
<span class="p_add">+		dst++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void fsl_dp_set_resume_pointer(void *ccsr_base)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 resume_addr;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* the bootloader will finally jump to this address to return kernel */</span>
<span class="p_add">+#ifdef CONFIG_PPC32</span>
<span class="p_add">+	resume_addr = (u32)(__pa(fsl_booke_deep_sleep_resume));</span>
<span class="p_add">+#else</span>
<span class="p_add">+	resume_addr = (u32)(__pa(*(u64 *)fsl_booke_deep_sleep_resume)</span>
<span class="p_add">+			    &amp; 0xffffffff);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	/* use the register SPARECR2 to save the resume address */</span>
<span class="p_add">+	out_be32(ccsr_base + CCSR_SCFG_SPARECR2, resume_addr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int fsl_enter_epu_deepsleep(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	fsl_dp_ddr_save(ccsr_base);</span>
<span class="p_add">+</span>
<span class="p_add">+	fsl_dp_set_resume_pointer(ccsr_base);</span>
<span class="p_add">+</span>
<span class="p_add">+	fsl_dp_mp_save(ccsr_base);</span>
<span class="p_add">+	fsl_dp_law_save(ccsr_base);</span>
<span class="p_add">+	/*  enable Warm Device Reset request. */</span>
<span class="p_add">+	setbits32(ccsr_base + CCSR_SCFG_DPSLPCR, CCSR_SCFG_DPSLPCR_WDRR_EN);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* set GPIO1_29 as an output pin (not open-drain), and output 0 */</span>
<span class="p_add">+	clrbits32(ccsr_base + CCSR_GPIO1_GPDAT, CCSR_GPIO1_GPDIR_29);</span>
<span class="p_add">+	clrbits32(ccsr_base + CCSR_GPIO1_GPODR, CCSR_GPIO1_GPDIR_29);</span>
<span class="p_add">+	setbits32(ccsr_base + CCSR_GPIO1_GPDIR, CCSR_GPIO1_GPDIR_29);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Disable CPC speculation to avoid deep sleep hang, especially</span>
<span class="p_add">+	 * in secure boot mode. This bit will be cleared automatically</span>
<span class="p_add">+	 * when resuming from deep sleep.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	setbits32(ccsr_base + CPC_CPCHDBCR0, CPC_CPCHDBCR0_SPEC_DIS);</span>
<span class="p_add">+</span>
<span class="p_add">+	fsl_epu_setup_default(dcsr_base + EPU_BLOCK_OFFSET);</span>
<span class="p_add">+	fsl_npc_setup_default(dcsr_base + NPC_BLOCK_OFFSET);</span>
<span class="p_add">+</span>
<span class="p_add">+	out_be32(dcsr_base + RCPM_BLOCK_OFFSET + CSTTACR0, 0x00001001);</span>
<span class="p_add">+	out_be32(dcsr_base + RCPM_BLOCK_OFFSET + CG1CR0, 0x00000001);</span>
<span class="p_add">+</span>
<span class="p_add">+	fsl_dp_enter_low(ccsr_base, dcsr_base, pld_base, pld_flag);</span>
<span class="p_add">+</span>
<span class="p_add">+	fsl_dp_law_restore(ccsr_base);</span>
<span class="p_add">+	fsl_dp_mp_restore(ccsr_base);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* disable Warm Device Reset request */</span>
<span class="p_add">+	clrbits32(ccsr_base + CCSR_SCFG_DPSLPCR, CCSR_SCFG_DPSLPCR_WDRR_EN);</span>
<span class="p_add">+</span>
<span class="p_add">+	fsl_epu_clean_default(dcsr_base + EPU_BLOCK_OFFSET);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/powerpc/platforms/85xx/qoriq_pm.c b/arch/powerpc/platforms/85xx/qoriq_pm.c</span>
<span class="p_header">index 27ec337..f65f6cf 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/85xx/qoriq_pm.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/85xx/qoriq_pm.c</span>
<span class="p_chunk">@@ -17,17 +17,68 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/fsl_pm.h&gt;
 
<span class="p_add">+static suspend_state_t cur_pm_state;</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * fsl_set_power_except - set which IP block is not powerdown when sleep or</span>
<span class="p_add">+ * deep sleep, such as MAC, USB, etc.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @dev: a pointer to the struct device of the device with wakeup capability</span>
<span class="p_add">+ * @on: if 1, do not power down; if 0, power down.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void fsl_set_power_except(struct device *dev, int on)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 value[2];</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = of_property_read_u32_array(dev-&gt;of_node, &quot;sleep&quot;, value, 2);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* get value[1], it is a bit mask */</span>
<span class="p_add">+	qoriq_pm_ops-&gt;set_ip_power(on, &amp;value[1]);</span>
<span class="p_add">+</span>
<span class="p_add">+	return;</span>
<span class="p_add">+out:</span>
<span class="p_add">+	dev_dbg(dev, &quot;Can not set as wakeup sources\n&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void qoriq_set_wakeup_source(struct device *dev, void *enable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!device_may_wakeup(dev))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	fsl_set_power_except(dev, *((int *)enable));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int qoriq_suspend_enter(suspend_state_t state)
 {
 	int ret = 0;
<span class="p_add">+	int cpu;</span>
 
 	switch (state) {
 	case PM_SUSPEND_STANDBY:
<span class="p_add">+</span>
 		cur_cpu_spec-&gt;cpu_down_flush();
<span class="p_add">+</span>
 		ret = qoriq_pm_ops-&gt;plat_enter_sleep();
<span class="p_add">+</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case PM_SUSPEND_MEM:</span>
<span class="p_add">+</span>
<span class="p_add">+		cpu = smp_processor_id();</span>
<span class="p_add">+		qoriq_pm_ops-&gt;irq_mask(cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = fsl_enter_epu_deepsleep();</span>
<span class="p_add">+</span>
<span class="p_add">+		qoriq_pm_ops-&gt;irq_unmask(cpu);</span>
<span class="p_add">+</span>
 		break;
<span class="p_add">+</span>
 	default:
 		ret = -EINVAL;
<span class="p_add">+</span>
 	}
 
 	return ret;
<span class="p_chunk">@@ -38,22 +89,48 @@</span> <span class="p_context"> static int qoriq_suspend_valid(suspend_state_t state)</span>
 	unsigned int pm_modes;
 
 	pm_modes = qoriq_pm_ops-&gt;get_pm_modes();
<span class="p_add">+	if (state == PM_SUSPEND_STANDBY &amp;&amp; (pm_modes &amp; FSL_PM_SLEEP))</span>
<span class="p_add">+		return 1;</span>
 
<span class="p_del">-	if ((state == PM_SUSPEND_STANDBY) &amp;&amp; (pm_modes &amp; FSL_PM_SLEEP))</span>
<span class="p_add">+	if (state == PM_SUSPEND_MEM &amp;&amp; (pm_modes &amp; FSL_PM_DEEP_SLEEP))</span>
 		return 1;
 
 	return 0;
 }
 
<span class="p_add">+static int qoriq_suspend_begin(suspend_state_t state)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const int enable = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	cur_pm_state = state;</span>
<span class="p_add">+	dpm_for_each_dev((void *)&amp;enable, qoriq_set_wakeup_source);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cur_pm_state == PM_SUSPEND_MEM)</span>
<span class="p_add">+		return fsl_dp_iomap();</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void qoriq_suspend_end(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const int enable = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	dpm_for_each_dev((void *)&amp;enable, qoriq_set_wakeup_source);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cur_pm_state == PM_SUSPEND_MEM)</span>
<span class="p_add">+		fsl_dp_iounmap();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct platform_suspend_ops qoriq_suspend_ops = {
 	.valid = qoriq_suspend_valid,
 	.enter = qoriq_suspend_enter,
<span class="p_add">+	.begin = qoriq_suspend_begin,</span>
<span class="p_add">+	.end = qoriq_suspend_end,</span>
 };
 
 static int __init qoriq_suspend_init(void)
 {
 	suspend_set_ops(&amp;qoriq_suspend_ops);
<span class="p_del">-</span>
 	return 0;
 }
 arch_initcall(qoriq_suspend_init);
<span class="p_header">diff --git a/arch/powerpc/platforms/85xx/t104x_deepsleep.S b/arch/powerpc/platforms/85xx/t104x_deepsleep.S</span>
new file mode 100644
<span class="p_header">index 0000000..773a9e4</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/powerpc/platforms/85xx/t104x_deepsleep.S</span>
<span class="p_chunk">@@ -0,0 +1,570 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Enter and resume from deep sleep state</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright 2015 Freescale Semiconductor Inc.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute	it and/or modify it</span>
<span class="p_add">+ * under  the terms of	the GNU General	 Public License as published by the</span>
<span class="p_add">+ * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="p_add">+ * option) any later version.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/page.h&gt;</span>
<span class="p_add">+#include &lt;asm/ppc_asm.h&gt;</span>
<span class="p_add">+#include &lt;asm/reg.h&gt;</span>
<span class="p_add">+#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_add">+#include &lt;asm/fsl_pm.h&gt;</span>
<span class="p_add">+#include &lt;asm/mmu.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * the number of bytes occupied by one register</span>
<span class="p_add">+ * the value of 8 is compatible with both 32-bit and 64-bit registers</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define STRIDE_SIZE		8</span>
<span class="p_add">+</span>
<span class="p_add">+/* GPR0 - GPR31 */</span>
<span class="p_add">+#define BOOKE_GPR0_OFF		0x0000</span>
<span class="p_add">+#define BOOKE_GPR_COUNT		32</span>
<span class="p_add">+/* IVOR0 - IVOR42 */</span>
<span class="p_add">+#define BOOKE_IVOR0_OFF	   (BOOKE_GPR0_OFF + BOOKE_GPR_COUNT * STRIDE_SIZE)</span>
<span class="p_add">+#define BOOKE_IVOR_COUNT	43</span>
<span class="p_add">+/* SPRG0 - SPRG9 */</span>
<span class="p_add">+#define BOOKE_SPRG0_OFF	   (BOOKE_IVOR0_OFF + BOOKE_IVOR_COUNT * STRIDE_SIZE)</span>
<span class="p_add">+#define BOOKE_SPRG_COUNT	10</span>
<span class="p_add">+/* IVPR */</span>
<span class="p_add">+#define BOOKE_IVPR_OFF	   (BOOKE_SPRG0_OFF + BOOKE_SPRG_COUNT * STRIDE_SIZE)</span>
<span class="p_add">+</span>
<span class="p_add">+#define BOOKE_LR_OFF		(BOOKE_IVPR_OFF + STRIDE_SIZE)</span>
<span class="p_add">+#define BOOKE_MSR_OFF		(BOOKE_LR_OFF + STRIDE_SIZE)</span>
<span class="p_add">+#define BOOKE_TBU_OFF		(BOOKE_MSR_OFF + STRIDE_SIZE)</span>
<span class="p_add">+#define BOOKE_TBL_OFF		(BOOKE_TBU_OFF + STRIDE_SIZE)</span>
<span class="p_add">+#define BOOKE_EPCR_OFF		(BOOKE_TBL_OFF + STRIDE_SIZE)</span>
<span class="p_add">+#define BOOKE_HID0_OFF		(BOOKE_EPCR_OFF + STRIDE_SIZE)</span>
<span class="p_add">+#define BOOKE_PIR_OFF		(BOOKE_HID0_OFF + STRIDE_SIZE)</span>
<span class="p_add">+#define BOOKE_PID0_OFF		(BOOKE_PIR_OFF + STRIDE_SIZE)</span>
<span class="p_add">+#define BOOKE_BUCSR_OFF		(BOOKE_PID0_OFF + STRIDE_SIZE)</span>
<span class="p_add">+</span>
<span class="p_add">+#define BUFFER_SIZE		(BOOKE_BUCSR_OFF + STRIDE_SIZE)</span>
<span class="p_add">+</span>
<span class="p_add">+#undef SAVE_GPR</span>
<span class="p_add">+#define SAVE_GPR(gpr, offset) \</span>
<span class="p_add">+	PPC_STL gpr, offset(r10)</span>
<span class="p_add">+</span>
<span class="p_add">+#define RESTORE_GPR(gpr, offset) \</span>
<span class="p_add">+	PPC_LL gpr, offset(r10)</span>
<span class="p_add">+</span>
<span class="p_add">+#define SAVE_SPR(spr, offset) \</span>
<span class="p_add">+	mfspr	r0, spr ;\</span>
<span class="p_add">+	PPC_STL	r0, offset(r10)</span>
<span class="p_add">+</span>
<span class="p_add">+#define RESTORE_SPR(spr, offset) \</span>
<span class="p_add">+	PPC_LL	r0, offset(r10) ;\</span>
<span class="p_add">+	mtspr	spr, r0</span>
<span class="p_add">+</span>
<span class="p_add">+#define SAVE_ALL_GPR \</span>
<span class="p_add">+	SAVE_GPR(r1, BOOKE_GPR0_OFF + STRIDE_SIZE * 1) ;\</span>
<span class="p_add">+	SAVE_GPR(r2, BOOKE_GPR0_OFF + STRIDE_SIZE * 2) ;\</span>
<span class="p_add">+	SAVE_GPR(r13, BOOKE_GPR0_OFF + STRIDE_SIZE * 13) ;\</span>
<span class="p_add">+	SAVE_GPR(r14, BOOKE_GPR0_OFF + STRIDE_SIZE * 14) ;\</span>
<span class="p_add">+	SAVE_GPR(r15, BOOKE_GPR0_OFF + STRIDE_SIZE * 15) ;\</span>
<span class="p_add">+	SAVE_GPR(r16, BOOKE_GPR0_OFF + STRIDE_SIZE * 16) ;\</span>
<span class="p_add">+	SAVE_GPR(r17, BOOKE_GPR0_OFF + STRIDE_SIZE * 17) ;\</span>
<span class="p_add">+	SAVE_GPR(r18, BOOKE_GPR0_OFF + STRIDE_SIZE * 18) ;\</span>
<span class="p_add">+	SAVE_GPR(r19, BOOKE_GPR0_OFF + STRIDE_SIZE * 19) ;\</span>
<span class="p_add">+	SAVE_GPR(r20, BOOKE_GPR0_OFF + STRIDE_SIZE * 20) ;\</span>
<span class="p_add">+	SAVE_GPR(r21, BOOKE_GPR0_OFF + STRIDE_SIZE * 21) ;\</span>
<span class="p_add">+	SAVE_GPR(r22, BOOKE_GPR0_OFF + STRIDE_SIZE * 22) ;\</span>
<span class="p_add">+	SAVE_GPR(r23, BOOKE_GPR0_OFF + STRIDE_SIZE * 23) ;\</span>
<span class="p_add">+	SAVE_GPR(r24, BOOKE_GPR0_OFF + STRIDE_SIZE * 24) ;\</span>
<span class="p_add">+	SAVE_GPR(r25, BOOKE_GPR0_OFF + STRIDE_SIZE * 25) ;\</span>
<span class="p_add">+	SAVE_GPR(r26, BOOKE_GPR0_OFF + STRIDE_SIZE * 26) ;\</span>
<span class="p_add">+	SAVE_GPR(r27, BOOKE_GPR0_OFF + STRIDE_SIZE * 27) ;\</span>
<span class="p_add">+	SAVE_GPR(r28, BOOKE_GPR0_OFF + STRIDE_SIZE * 28) ;\</span>
<span class="p_add">+	SAVE_GPR(r29, BOOKE_GPR0_OFF + STRIDE_SIZE * 29) ;\</span>
<span class="p_add">+	SAVE_GPR(r30, BOOKE_GPR0_OFF + STRIDE_SIZE * 30) ;\</span>
<span class="p_add">+	SAVE_GPR(r31, BOOKE_GPR0_OFF + STRIDE_SIZE * 31)</span>
<span class="p_add">+</span>
<span class="p_add">+#define RESTORE_ALL_GPR \</span>
<span class="p_add">+	RESTORE_GPR(r1, BOOKE_GPR0_OFF + STRIDE_SIZE * 1) ;\</span>
<span class="p_add">+	RESTORE_GPR(r2, BOOKE_GPR0_OFF + STRIDE_SIZE * 2) ;\</span>
<span class="p_add">+	RESTORE_GPR(r13, BOOKE_GPR0_OFF + STRIDE_SIZE * 13) ;\</span>
<span class="p_add">+	RESTORE_GPR(r14, BOOKE_GPR0_OFF + STRIDE_SIZE * 14) ;\</span>
<span class="p_add">+	RESTORE_GPR(r15, BOOKE_GPR0_OFF + STRIDE_SIZE * 15) ;\</span>
<span class="p_add">+	RESTORE_GPR(r16, BOOKE_GPR0_OFF + STRIDE_SIZE * 16) ;\</span>
<span class="p_add">+	RESTORE_GPR(r17, BOOKE_GPR0_OFF + STRIDE_SIZE * 17) ;\</span>
<span class="p_add">+	RESTORE_GPR(r18, BOOKE_GPR0_OFF + STRIDE_SIZE * 18) ;\</span>
<span class="p_add">+	RESTORE_GPR(r19, BOOKE_GPR0_OFF + STRIDE_SIZE * 19) ;\</span>
<span class="p_add">+	RESTORE_GPR(r20, BOOKE_GPR0_OFF + STRIDE_SIZE * 20) ;\</span>
<span class="p_add">+	RESTORE_GPR(r21, BOOKE_GPR0_OFF + STRIDE_SIZE * 21) ;\</span>
<span class="p_add">+	RESTORE_GPR(r22, BOOKE_GPR0_OFF + STRIDE_SIZE * 22) ;\</span>
<span class="p_add">+	RESTORE_GPR(r23, BOOKE_GPR0_OFF + STRIDE_SIZE * 23) ;\</span>
<span class="p_add">+	RESTORE_GPR(r24, BOOKE_GPR0_OFF + STRIDE_SIZE * 24) ;\</span>
<span class="p_add">+	RESTORE_GPR(r25, BOOKE_GPR0_OFF + STRIDE_SIZE * 25) ;\</span>
<span class="p_add">+	RESTORE_GPR(r26, BOOKE_GPR0_OFF + STRIDE_SIZE * 26) ;\</span>
<span class="p_add">+	RESTORE_GPR(r27, BOOKE_GPR0_OFF + STRIDE_SIZE * 27) ;\</span>
<span class="p_add">+	RESTORE_GPR(r28, BOOKE_GPR0_OFF + STRIDE_SIZE * 28) ;\</span>
<span class="p_add">+	RESTORE_GPR(r29, BOOKE_GPR0_OFF + STRIDE_SIZE * 29) ;\</span>
<span class="p_add">+	RESTORE_GPR(r30, BOOKE_GPR0_OFF + STRIDE_SIZE * 30) ;\</span>
<span class="p_add">+	RESTORE_GPR(r31, BOOKE_GPR0_OFF + STRIDE_SIZE * 31)</span>
<span class="p_add">+</span>
<span class="p_add">+#define SAVE_ALL_SPRG \</span>
<span class="p_add">+	SAVE_SPR(SPRN_SPRG0, BOOKE_SPRG0_OFF + STRIDE_SIZE * 0) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_SPRG1, BOOKE_SPRG0_OFF + STRIDE_SIZE * 1) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_SPRG2, BOOKE_SPRG0_OFF + STRIDE_SIZE * 2) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_SPRG3, BOOKE_SPRG0_OFF + STRIDE_SIZE * 3) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_SPRG4, BOOKE_SPRG0_OFF + STRIDE_SIZE * 4) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_SPRG5, BOOKE_SPRG0_OFF + STRIDE_SIZE * 5) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_SPRG6, BOOKE_SPRG0_OFF + STRIDE_SIZE * 6) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_SPRG7, BOOKE_SPRG0_OFF + STRIDE_SIZE * 7) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_SPRG8, BOOKE_SPRG0_OFF + STRIDE_SIZE * 8) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_SPRG9, BOOKE_SPRG0_OFF + STRIDE_SIZE * 9)</span>
<span class="p_add">+</span>
<span class="p_add">+#define RESTORE_ALL_SPRG \</span>
<span class="p_add">+	RESTORE_SPR(SPRN_SPRG0, BOOKE_SPRG0_OFF + STRIDE_SIZE * 0) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_SPRG1, BOOKE_SPRG0_OFF + STRIDE_SIZE * 1) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_SPRG2, BOOKE_SPRG0_OFF + STRIDE_SIZE * 2) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_SPRG3, BOOKE_SPRG0_OFF + STRIDE_SIZE * 3) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_SPRG4, BOOKE_SPRG0_OFF + STRIDE_SIZE * 4) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_SPRG5, BOOKE_SPRG0_OFF + STRIDE_SIZE * 5) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_SPRG6, BOOKE_SPRG0_OFF + STRIDE_SIZE * 6) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_SPRG7, BOOKE_SPRG0_OFF + STRIDE_SIZE * 7) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_SPRG8, BOOKE_SPRG0_OFF + STRIDE_SIZE * 8) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_SPRG9, BOOKE_SPRG0_OFF + STRIDE_SIZE * 9)</span>
<span class="p_add">+</span>
<span class="p_add">+#define SAVE_ALL_IVOR \</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR0, BOOKE_IVOR0_OFF + STRIDE_SIZE * 0) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR1, BOOKE_IVOR0_OFF + STRIDE_SIZE * 1) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR2, BOOKE_IVOR0_OFF + STRIDE_SIZE * 2) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR3, BOOKE_IVOR0_OFF + STRIDE_SIZE * 3) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR4, BOOKE_IVOR0_OFF + STRIDE_SIZE * 4) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR5, BOOKE_IVOR0_OFF + STRIDE_SIZE * 5) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR6, BOOKE_IVOR0_OFF + STRIDE_SIZE * 6) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR7, BOOKE_IVOR0_OFF + STRIDE_SIZE * 7) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR8, BOOKE_IVOR0_OFF + STRIDE_SIZE * 8) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR9, BOOKE_IVOR0_OFF + STRIDE_SIZE * 9) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR10, BOOKE_IVOR0_OFF + STRIDE_SIZE * 10) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR11, BOOKE_IVOR0_OFF + STRIDE_SIZE * 11) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR12, BOOKE_IVOR0_OFF + STRIDE_SIZE * 12) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR13, BOOKE_IVOR0_OFF + STRIDE_SIZE * 13) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR14, BOOKE_IVOR0_OFF + STRIDE_SIZE * 14) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR15, BOOKE_IVOR0_OFF + STRIDE_SIZE * 15) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR35, BOOKE_IVOR0_OFF + STRIDE_SIZE * 35) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR36, BOOKE_IVOR0_OFF + STRIDE_SIZE * 36) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR37, BOOKE_IVOR0_OFF + STRIDE_SIZE * 37) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR38, BOOKE_IVOR0_OFF + STRIDE_SIZE * 38) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR39, BOOKE_IVOR0_OFF + STRIDE_SIZE * 39) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR40, BOOKE_IVOR0_OFF + STRIDE_SIZE * 40) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR41, BOOKE_IVOR0_OFF + STRIDE_SIZE * 41)</span>
<span class="p_add">+</span>
<span class="p_add">+#define RESTORE_ALL_IVOR \</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR0, BOOKE_IVOR0_OFF + STRIDE_SIZE * 0) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR1, BOOKE_IVOR0_OFF + STRIDE_SIZE * 1) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR2, BOOKE_IVOR0_OFF + STRIDE_SIZE * 2) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR3, BOOKE_IVOR0_OFF + STRIDE_SIZE * 3) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR4, BOOKE_IVOR0_OFF + STRIDE_SIZE * 4) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR5, BOOKE_IVOR0_OFF + STRIDE_SIZE * 5) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR6, BOOKE_IVOR0_OFF + STRIDE_SIZE * 6) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR7, BOOKE_IVOR0_OFF + STRIDE_SIZE * 7) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR8, BOOKE_IVOR0_OFF + STRIDE_SIZE * 8) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR9, BOOKE_IVOR0_OFF + STRIDE_SIZE * 9) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR10, BOOKE_IVOR0_OFF + STRIDE_SIZE * 10) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR11, BOOKE_IVOR0_OFF + STRIDE_SIZE * 11) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR12, BOOKE_IVOR0_OFF + STRIDE_SIZE * 12) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR13, BOOKE_IVOR0_OFF + STRIDE_SIZE * 13) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR14, BOOKE_IVOR0_OFF + STRIDE_SIZE * 14) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR15, BOOKE_IVOR0_OFF + STRIDE_SIZE * 15) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR35, BOOKE_IVOR0_OFF + STRIDE_SIZE * 35) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR36, BOOKE_IVOR0_OFF + STRIDE_SIZE * 36) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR37, BOOKE_IVOR0_OFF + STRIDE_SIZE * 37) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR38, BOOKE_IVOR0_OFF + STRIDE_SIZE * 38) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR39, BOOKE_IVOR0_OFF + STRIDE_SIZE * 39) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR40, BOOKE_IVOR0_OFF + STRIDE_SIZE * 40) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR41, BOOKE_IVOR0_OFF + STRIDE_SIZE * 41)</span>
<span class="p_add">+</span>
<span class="p_add">+/* reset time base to prevent from overflow */</span>
<span class="p_add">+#define DELAY(count)		\</span>
<span class="p_add">+	li	r3, count;	\</span>
<span class="p_add">+	li	r4, 0;		\</span>
<span class="p_add">+	mtspr	SPRN_TBWL, r4;	\</span>
<span class="p_add">+101:	mfspr	r4, SPRN_TBRL;	\</span>
<span class="p_add">+	cmpw	r4, r3;		\</span>
<span class="p_add">+	blt	101b</span>
<span class="p_add">+</span>
<span class="p_add">+#define FSL_DIS_ALL_IRQ		\</span>
<span class="p_add">+	mfmsr	r8;			\</span>
<span class="p_add">+	rlwinm	r8, r8, 0, ~MSR_CE;	\</span>
<span class="p_add">+	rlwinm	r8, r8, 0, ~MSR_ME;	\</span>
<span class="p_add">+	rlwinm	r8, r8, 0, ~MSR_EE;	\</span>
<span class="p_add">+	rlwinm	r8, r8, 0, ~MSR_DE;	\</span>
<span class="p_add">+	mtmsr	r8;			\</span>
<span class="p_add">+	isync</span>
<span class="p_add">+</span>
<span class="p_add">+	.section .data</span>
<span class="p_add">+	.align	6</span>
<span class="p_add">+regs_buffer:</span>
<span class="p_add">+	.space BUFFER_SIZE</span>
<span class="p_add">+</span>
<span class="p_add">+	.section .text</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Save CPU registers</span>
<span class="p_add">+ * r3 : the base address of the buffer which stores the values of registers</span>
<span class="p_add">+ */</span>
<span class="p_add">+e5500_cpu_state_save:</span>
<span class="p_add">+	/* store the base address to r10 */</span>
<span class="p_add">+	mr	r10, r3</span>
<span class="p_add">+</span>
<span class="p_add">+	SAVE_ALL_GPR</span>
<span class="p_add">+	SAVE_ALL_SPRG</span>
<span class="p_add">+	SAVE_ALL_IVOR</span>
<span class="p_add">+</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVPR, BOOKE_IVPR_OFF)</span>
<span class="p_add">+	SAVE_SPR(SPRN_PID0, BOOKE_PID0_OFF)</span>
<span class="p_add">+	SAVE_SPR(SPRN_EPCR, BOOKE_EPCR_OFF)</span>
<span class="p_add">+	SAVE_SPR(SPRN_HID0, BOOKE_HID0_OFF)</span>
<span class="p_add">+	SAVE_SPR(SPRN_PIR, BOOKE_PIR_OFF)</span>
<span class="p_add">+	SAVE_SPR(SPRN_BUCSR, BOOKE_BUCSR_OFF)</span>
<span class="p_add">+1:</span>
<span class="p_add">+	mfspr	r5, SPRN_TBRU</span>
<span class="p_add">+	mfspr	r4, SPRN_TBRL</span>
<span class="p_add">+	SAVE_GPR(r5, BOOKE_TBU_OFF)</span>
<span class="p_add">+	SAVE_GPR(r4, BOOKE_TBL_OFF)</span>
<span class="p_add">+	mfspr	r3, SPRN_TBRU</span>
<span class="p_add">+	cmpw	r3, r5</span>
<span class="p_add">+	bne	1b</span>
<span class="p_add">+</span>
<span class="p_add">+	blr</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Restore CPU registers</span>
<span class="p_add">+ * r3 : the base address of the buffer which stores the values of registers</span>
<span class="p_add">+ */</span>
<span class="p_add">+e5500_cpu_state_restore:</span>
<span class="p_add">+	/* store the base address to r10 */</span>
<span class="p_add">+	mr	r10, r3</span>
<span class="p_add">+</span>
<span class="p_add">+	RESTORE_ALL_GPR</span>
<span class="p_add">+	RESTORE_ALL_SPRG</span>
<span class="p_add">+	RESTORE_ALL_IVOR</span>
<span class="p_add">+</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVPR, BOOKE_IVPR_OFF)</span>
<span class="p_add">+	RESTORE_SPR(SPRN_PID0, BOOKE_PID0_OFF)</span>
<span class="p_add">+	RESTORE_SPR(SPRN_EPCR, BOOKE_EPCR_OFF)</span>
<span class="p_add">+	RESTORE_SPR(SPRN_HID0, BOOKE_HID0_OFF)</span>
<span class="p_add">+	RESTORE_SPR(SPRN_PIR, BOOKE_PIR_OFF)</span>
<span class="p_add">+	RESTORE_SPR(SPRN_BUCSR, BOOKE_BUCSR_OFF)</span>
<span class="p_add">+</span>
<span class="p_add">+	li	r0, 0</span>
<span class="p_add">+	mtspr	SPRN_TBWL, r0</span>
<span class="p_add">+	RESTORE_SPR(SPRN_TBWU, BOOKE_TBU_OFF)</span>
<span class="p_add">+	RESTORE_SPR(SPRN_TBWL, BOOKE_TBL_OFF)</span>
<span class="p_add">+</span>
<span class="p_add">+	blr</span>
<span class="p_add">+</span>
<span class="p_add">+#define CPC_CPCCSR0		0x0</span>
<span class="p_add">+#define CPC_CPCCSR0_CPCFL	0x800</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Flush the CPC cache.</span>
<span class="p_add">+ * r3 : the base address of CPC</span>
<span class="p_add">+ */</span>
<span class="p_add">+flush_cpc_cache:</span>
<span class="p_add">+	lwz	r6, CPC_CPCCSR0(r3)</span>
<span class="p_add">+	ori	r6, r6, CPC_CPCCSR0_CPCFL</span>
<span class="p_add">+	stw	r6, CPC_CPCCSR0(r3)</span>
<span class="p_add">+	sync</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Wait until completing the flush */</span>
<span class="p_add">+1:	lwz	r6, CPC_CPCCSR0(r3)</span>
<span class="p_add">+	andi.	r6, r6, CPC_CPCCSR0_CPCFL</span>
<span class="p_add">+	bne	1b</span>
<span class="p_add">+</span>
<span class="p_add">+	blr</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * the last stage to enter deep sleep</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
<span class="p_add">+	.align 6</span>
<span class="p_add">+_GLOBAL(fsl_dp_enter_low)</span>
<span class="p_add">+deepsleep_start:</span>
<span class="p_add">+	LOAD_REG_ADDR(r9, buf_tmp)</span>
<span class="p_add">+	/* save the return address and MSR */</span>
<span class="p_add">+	mflr	r8</span>
<span class="p_add">+	PPC_STL r8, 0(r9)</span>
<span class="p_add">+	mfmsr	r8</span>
<span class="p_add">+	PPC_STL r8, 8(r9)</span>
<span class="p_add">+	mfspr	r8, SPRN_TCR</span>
<span class="p_add">+	PPC_STL r8, 16(r9)</span>
<span class="p_add">+	mfcr	r8</span>
<span class="p_add">+	PPC_STL	r8, 24(r9)</span>
<span class="p_add">+	li	r8, 0</span>
<span class="p_add">+	mtspr	SPRN_TCR, r8</span>
<span class="p_add">+</span>
<span class="p_add">+	/* save the parameters */</span>
<span class="p_add">+	PPC_STL	r3, 32(r9)</span>
<span class="p_add">+	PPC_STL	r4, 40(r9)</span>
<span class="p_add">+	PPC_STL	r5, 48(r9)</span>
<span class="p_add">+	PPC_STL	r6, 56(r9)</span>
<span class="p_add">+</span>
<span class="p_add">+	LOAD_REG_ADDR(r3, regs_buffer)</span>
<span class="p_add">+	bl	e5500_cpu_state_save</span>
<span class="p_add">+</span>
<span class="p_add">+	/* restore the parameters */</span>
<span class="p_add">+	LOAD_REG_ADDR(r9, buf_tmp)</span>
<span class="p_add">+	PPC_LL	r31, 32(r9)</span>
<span class="p_add">+	PPC_LL	r30, 40(r9)</span>
<span class="p_add">+	PPC_LL	r29, 48(r9)</span>
<span class="p_add">+	PPC_LL	r28, 56(r9)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* flush caches inside CPU */</span>
<span class="p_add">+	LOAD_REG_ADDR(r3, cur_cpu_spec)</span>
<span class="p_add">+	PPC_LL	r3, 0(r3)</span>
<span class="p_add">+	PPC_LL	r3, CPU_DOWN_FLUSH(r3)</span>
<span class="p_add">+	PPC_LCMPI  0, r3, 0</span>
<span class="p_add">+	beq	6f</span>
<span class="p_add">+#ifdef CONFIG_PPC64</span>
<span class="p_add">+	PPC_LL	r3, 0(r3)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	mtctr	r3</span>
<span class="p_add">+	bctrl</span>
<span class="p_add">+6:</span>
<span class="p_add">+	/* Flush the CPC cache */</span>
<span class="p_add">+#define CPC_OFFSET	0x10000</span>
<span class="p_add">+	mr	r3, r31</span>
<span class="p_add">+	addis	r3, r3, CPC_OFFSET@h</span>
<span class="p_add">+	bl	flush_cpc_cache</span>
<span class="p_add">+</span>
<span class="p_add">+	/* prefecth TLB */</span>
<span class="p_add">+#define CCSR_GPIO1_GPDAT	0x130008</span>
<span class="p_add">+#define CCSR_GPIO1_GPDAT_29	0x4</span>
<span class="p_add">+	LOAD_REG_IMMEDIATE(r11, CCSR_GPIO1_GPDAT)</span>
<span class="p_add">+	add	r11, r31, r11</span>
<span class="p_add">+	lwz	r10, 0(r11)</span>
<span class="p_add">+</span>
<span class="p_add">+#define CCSR_RCPM_PCPH15SETR	0xe20b4</span>
<span class="p_add">+#define CCSR_RCPM_PCPH15SETR_CORE0	0x1</span>
<span class="p_add">+	LOAD_REG_IMMEDIATE(r12, CCSR_RCPM_PCPH15SETR)</span>
<span class="p_add">+	add	r12, r31, r12</span>
<span class="p_add">+	lwz	r10, 0(r12)</span>
<span class="p_add">+</span>
<span class="p_add">+#define CCSR_DDR_SDRAM_CFG_2	0x8114</span>
<span class="p_add">+#define CCSR_DDR_SDRAM_CFG_2_FRC_SR	0x80000000</span>
<span class="p_add">+	LOAD_REG_IMMEDIATE(r13, CCSR_DDR_SDRAM_CFG_2)</span>
<span class="p_add">+	add	r13, r31, r13</span>
<span class="p_add">+	lwz	r10, 0(r13)</span>
<span class="p_add">+</span>
<span class="p_add">+#define	DCSR_EPU_EPGCR		0x000</span>
<span class="p_add">+#define DCSR_EPU_EPGCR_GCE	0x80000000</span>
<span class="p_add">+	li	r14, DCSR_EPU_EPGCR</span>
<span class="p_add">+	add	r14, r30, r14</span>
<span class="p_add">+	lwz	r10, 0(r14)</span>
<span class="p_add">+</span>
<span class="p_add">+#define	DCSR_EPU_EPECR15	0x33C</span>
<span class="p_add">+#define DCSR_EPU_EPECR15_IC0	0x80000000</span>
<span class="p_add">+	li	r15, DCSR_EPU_EPECR15</span>
<span class="p_add">+	add	r15, r30, r15</span>
<span class="p_add">+	lwz	r10, 0(r15)</span>
<span class="p_add">+</span>
<span class="p_add">+#define CCSR_SCFG_QMIFRSTCR		0xfc40c</span>
<span class="p_add">+#define CCSR_SCFG_QMIFRSTCR_QMIFRST	0x80000000</span>
<span class="p_add">+	LOAD_REG_IMMEDIATE(r16, CCSR_SCFG_QMIFRSTCR)</span>
<span class="p_add">+	add	r16, r31, r16</span>
<span class="p_add">+	lwz	r10, 0(r16)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * There are two kind of register maps, one for T1040QDS and</span>
<span class="p_add">+ * the other for T104xRDB.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define T104XRDB_CPLD_MISCCSR		0x17</span>
<span class="p_add">+#define T104XRDB_CPLD_MISCCSR_SLEEPEN	0x40</span>
<span class="p_add">+#define T1040QDS_QIXIS_PWR_CTL2		0x21</span>
<span class="p_add">+#define T1040QDS_QIXIS_PWR_CTL2_PCTL	0x2</span>
<span class="p_add">+	li	r3, T1040QDS_QIXIS_PWR_CTL2</span>
<span class="p_add">+	PPC_LCMPI  0, r28, T1040QDS_TETRA_FLAG</span>
<span class="p_add">+	beq	20f</span>
<span class="p_add">+	li	r3, T104XRDB_CPLD_MISCCSR</span>
<span class="p_add">+20:	add	r29, r29, r3</span>
<span class="p_add">+	lbz	r10, 0(r29)</span>
<span class="p_add">+	sync</span>
<span class="p_add">+</span>
<span class="p_add">+	LOAD_REG_ADDR(r8, deepsleep_start)</span>
<span class="p_add">+	LOAD_REG_ADDR(r9, deepsleep_end)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* prefecth code to cache so that executing code after disable DDR */</span>
<span class="p_add">+1:	icbtls	2, 0, r8</span>
<span class="p_add">+	addi	r8, r8, 64</span>
<span class="p_add">+	cmpw	r8, r9</span>
<span class="p_add">+	blt	1b</span>
<span class="p_add">+	sync</span>
<span class="p_add">+</span>
<span class="p_add">+	FSL_DIS_ALL_IRQ</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Place DDR controller in self refresh mode.</span>
<span class="p_add">+	 * From here on, can&#39;t access DDR any more.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	lwz	r10, 0(r13)</span>
<span class="p_add">+	oris	r10, r10, CCSR_DDR_SDRAM_CFG_2_FRC_SR@h</span>
<span class="p_add">+	stw	r10, 0(r13)</span>
<span class="p_add">+	lwz	r10, 0(r13)</span>
<span class="p_add">+	sync</span>
<span class="p_add">+</span>
<span class="p_add">+	DELAY(500)</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Enable deep sleep signals by write external CPLD/FPGA register.</span>
<span class="p_add">+	 * The bootloader will disable them when wakeup from deep sleep.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	lbz	r10, 0(r29)</span>
<span class="p_add">+	li	r3, T1040QDS_QIXIS_PWR_CTL2_PCTL</span>
<span class="p_add">+	PPC_LCMPI  0, r28, T1040QDS_TETRA_FLAG</span>
<span class="p_add">+	beq	22f</span>
<span class="p_add">+	li	r3, T104XRDB_CPLD_MISCCSR_SLEEPEN</span>
<span class="p_add">+22:	or	r10, r10, r3</span>
<span class="p_add">+	stb	r10, 0(r29)</span>
<span class="p_add">+	lbz	r10, 0(r29)</span>
<span class="p_add">+	sync</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Set GPIO1_29 to lock the signal MCKE down during deep sleep.</span>
<span class="p_add">+	 * The bootloader will clear it when wakeup.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	lwz	r10, 0(r11)</span>
<span class="p_add">+	ori	r10, r10, CCSR_GPIO1_GPDAT_29</span>
<span class="p_add">+	stw	r10, 0(r11)</span>
<span class="p_add">+	lwz	r10, 0(r11)</span>
<span class="p_add">+</span>
<span class="p_add">+	DELAY(100)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Reset QMan system bus interface */</span>
<span class="p_add">+	lwz	r10, 0(r16)</span>
<span class="p_add">+	oris	r10, r10, CCSR_SCFG_QMIFRSTCR_QMIFRST@h</span>
<span class="p_add">+	stw	r10, 0(r16)</span>
<span class="p_add">+	lwz	r10, 0(r16)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable all EPU Counters */</span>
<span class="p_add">+	li	r10, 0</span>
<span class="p_add">+	oris	r10, r10, DCSR_EPU_EPGCR_GCE@h</span>
<span class="p_add">+	stw	r10, 0(r14)</span>
<span class="p_add">+	lwz	r10, 0(r14)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable SCU15 to trigger on RCPM Concentrator 0 */</span>
<span class="p_add">+	lwz	r10, 0(r15)</span>
<span class="p_add">+	oris	r10, r10, DCSR_EPU_EPECR15_IC0@h</span>
<span class="p_add">+	stw	r10, 0(r15)</span>
<span class="p_add">+	lwz	r10, 0(r15)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* put Core0 in PH15 mode, trigger EPU FSM */</span>
<span class="p_add">+	lwz	r10, 0(r12)</span>
<span class="p_add">+	ori	r10, r10, CCSR_RCPM_PCPH15SETR_CORE0</span>
<span class="p_add">+	stw	r10, 0(r12)</span>
<span class="p_add">+2:</span>
<span class="p_add">+	b 2b</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Leave some space to prevent prefeching instruction</span>
<span class="p_add">+	 * beyond deepsleep_end. The space also can be used as heap.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+buf_tmp:</span>
<span class="p_add">+	.space 128</span>
<span class="p_add">+	.align 6</span>
<span class="p_add">+deepsleep_end:</span>
<span class="p_add">+</span>
<span class="p_add">+	.align 12</span>
<span class="p_add">+#ifdef CONFIG_PPC32</span>
<span class="p_add">+_GLOBAL(fsl_booke_deep_sleep_resume)</span>
<span class="p_add">+	/* disable interrupts */</span>
<span class="p_add">+	FSL_DIS_ALL_IRQ</span>
<span class="p_add">+</span>
<span class="p_add">+#define ENTRY_DEEPSLEEP_SETUP</span>
<span class="p_add">+#define ENTRY_MAPPING_BOOT_SETUP</span>
<span class="p_add">+#include &lt;../../kernel/fsl_booke_entry_mapping.S&gt;</span>
<span class="p_add">+#undef ENTRY_DEEPSLEEP_SETUP</span>
<span class="p_add">+#undef ENTRY_MAPPING_BOOT_SETUP</span>
<span class="p_add">+</span>
<span class="p_add">+	li	r3, 0</span>
<span class="p_add">+	mfspr   r4, SPRN_PIR</span>
<span class="p_add">+	bl	call_setup_cpu</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Load each CAM entry */</span>
<span class="p_add">+	LOAD_REG_ADDR(r3, tlbcam_index)</span>
<span class="p_add">+	lwz	r3, 0(r3)</span>
<span class="p_add">+	mtctr	r3</span>
<span class="p_add">+	li	r9, 0</span>
<span class="p_add">+3:	mr	r3, r9</span>
<span class="p_add">+	bl	loadcam_entry</span>
<span class="p_add">+	addi	r9, r9, 1</span>
<span class="p_add">+	bdnz	3b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* restore cpu registers */</span>
<span class="p_add">+	LOAD_REG_ADDR(r3, regs_buffer)</span>
<span class="p_add">+	bl	e5500_cpu_state_restore</span>
<span class="p_add">+</span>
<span class="p_add">+	/* restore return address */</span>
<span class="p_add">+	LOAD_REG_ADDR(r3, buf_tmp)</span>
<span class="p_add">+	lwz	r4, 16(r3)</span>
<span class="p_add">+	mtspr	SPRN_TCR, r4</span>
<span class="p_add">+	lwz	r4, 0(r3)</span>
<span class="p_add">+	mtlr	r4</span>
<span class="p_add">+	lwz	r4, 8(r3)</span>
<span class="p_add">+	mtmsr	r4</span>
<span class="p_add">+	lwz	r4, 24(r3)</span>
<span class="p_add">+	mtcr	r4</span>
<span class="p_add">+</span>
<span class="p_add">+	blr</span>
<span class="p_add">+</span>
<span class="p_add">+#else /* CONFIG_PPC32 */</span>
<span class="p_add">+</span>
<span class="p_add">+_GLOBAL(fsl_booke_deep_sleep_resume)</span>
<span class="p_add">+	/* disable interrupts */</span>
<span class="p_add">+	FSL_DIS_ALL_IRQ</span>
<span class="p_add">+</span>
<span class="p_add">+	/* switch to 64-bit mode */</span>
<span class="p_add">+	bl	.enable_64b_mode</span>
<span class="p_add">+</span>
<span class="p_add">+	/* set TOC pointer */</span>
<span class="p_add">+	bl	.relative_toc</span>
<span class="p_add">+</span>
<span class="p_add">+	/* setup initial TLBs, switch to kernel space ... */</span>
<span class="p_add">+	bl	.start_initialization_book3e</span>
<span class="p_add">+</span>
<span class="p_add">+	/* address space changed, set TOC pointer again */</span>
<span class="p_add">+	bl	.relative_toc</span>
<span class="p_add">+</span>
<span class="p_add">+	/* call a cpu state restore handler */</span>
<span class="p_add">+	LOAD_REG_ADDR(r23, cur_cpu_spec)</span>
<span class="p_add">+	ld	r23,0(r23)</span>
<span class="p_add">+	ld	r23,CPU_SPEC_RESTORE(r23)</span>
<span class="p_add">+	cmpdi	0,r23,0</span>
<span class="p_add">+	beq	1f</span>
<span class="p_add">+	ld	r23,0(r23)</span>
<span class="p_add">+	mtctr	r23</span>
<span class="p_add">+	bctrl</span>
<span class="p_add">+1:</span>
<span class="p_add">+	LOAD_REG_ADDR(r3, regs_buffer)</span>
<span class="p_add">+	bl	e5500_cpu_state_restore</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Load each CAM entry */</span>
<span class="p_add">+	LOAD_REG_ADDR(r3, tlbcam_index)</span>
<span class="p_add">+	lwz	r3, 0(r3)</span>
<span class="p_add">+	mtctr	r3</span>
<span class="p_add">+	li	r0, 0</span>
<span class="p_add">+3:	mr	r3, r0</span>
<span class="p_add">+	bl	loadcam_entry</span>
<span class="p_add">+	addi	r0, r0, 1</span>
<span class="p_add">+	bdnz	3b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* restore return address */</span>
<span class="p_add">+	LOAD_REG_ADDR(r3, buf_tmp)</span>
<span class="p_add">+	ld	r4, 16(r3)</span>
<span class="p_add">+	mtspr	SPRN_TCR, r4</span>
<span class="p_add">+	ld	r4, 0(r3)</span>
<span class="p_add">+	mtlr	r4</span>
<span class="p_add">+	ld	r4, 8(r3)</span>
<span class="p_add">+	mtmsr	r4</span>
<span class="p_add">+	ld	r4, 24(r3)</span>
<span class="p_add">+	mtcr	r4</span>
<span class="p_add">+</span>
<span class="p_add">+	blr</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* CONFIG_PPC32 */</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



