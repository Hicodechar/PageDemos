
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.7.2 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.7.2</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 20, 2016, 4:16 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160820161627.GB28439@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9291757/mbox/"
   >mbox</a>
|
   <a href="/patch/9291757/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9291757/">/patch/9291757/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	9B9D960574 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 20 Aug 2016 16:16:56 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 7B6CD28BAC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 20 Aug 2016 16:16:56 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 6CDF228BB0; Sat, 20 Aug 2016 16:16:56 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id CB20828BAC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 20 Aug 2016 16:16:44 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932261AbcHTQQc (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sat, 20 Aug 2016 12:16:32 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:51592 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S932163AbcHTQQY (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sat, 20 Aug 2016 12:16:24 -0400
Received: from localhost (pes75-3-78-192-101-3.fbxo.proxad.net
	[78.192.101.3])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id D80C57AA;
	Sat, 20 Aug 2016 16:16:20 +0000 (UTC)
Date: Sat, 20 Aug 2016 18:16:27 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.7.2
Message-ID: &lt;20160820161627.GB28439@kroah.com&gt;
References: &lt;20160820161620.GA28439@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=utf-8
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
In-Reply-To: &lt;20160820161620.GA28439@kroah.com&gt;
User-Agent: Mutt/1.7.0 (2016-08-17)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Aug. 20, 2016, 4:16 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/module-signing.txt b/Documentation/module-signing.txt</span>
<span class="p_header">index 696d5caf4fd8..f0e3361db20c 100644</span>
<span class="p_header">--- a/Documentation/module-signing.txt</span>
<span class="p_header">+++ b/Documentation/module-signing.txt</span>
<span class="p_chunk">@@ -271,3 +271,9 @@</span> <span class="p_context"> Since the private key is used to sign modules, viruses and malware could use</span>
 the private key to sign modules and compromise the operating system.  The
 private key must be either destroyed or moved to a secure location and not kept
 in the root node of the kernel source tree.
<span class="p_add">+</span>
<span class="p_add">+If you use the same private key to sign modules for multiple kernel</span>
<span class="p_add">+configurations, you must ensure that the module version information is</span>
<span class="p_add">+sufficient to prevent loading a module into a different kernel.  Either</span>
<span class="p_add">+set CONFIG_MODVERSIONS=y or ensure that each configuration has a different</span>
<span class="p_add">+kernel release string by changing EXTRAVERSION or CONFIG_LOCALVERSION.</span>
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 84335c0b2eda..bb98f1ce854e 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 7
<span class="p_del">-SUBLEVEL = 1</span>
<span class="p_add">+SUBLEVEL = 2</span>
 EXTRAVERSION =
 NAME = Psychotic Stoned Sheep
 
<span class="p_header">diff --git a/arch/arc/include/asm/pgtable.h b/arch/arc/include/asm/pgtable.h</span>
<span class="p_header">index 858f98ef7f1b..0f92d97432a2 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -110,7 +110,7 @@</span> <span class="p_context"></span>
 #define ___DEF (_PAGE_PRESENT | _PAGE_CACHEABLE)
 
 /* Set of bits not changed in pte_modify */
<span class="p_del">-#define _PAGE_CHG_MASK	(PAGE_MASK | _PAGE_ACCESSED | _PAGE_DIRTY)</span>
<span class="p_add">+#define _PAGE_CHG_MASK	(PAGE_MASK | _PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_SPECIAL)</span>
 
 /* More Abbrevaited helpers */
 #define PAGE_U_NONE     __pgprot(___DEF)
<span class="p_header">diff --git a/arch/arc/mm/dma.c b/arch/arc/mm/dma.c</span>
<span class="p_header">index 73d7e4c75b7d..ab74b5d9186c 100644</span>
<span class="p_header">--- a/arch/arc/mm/dma.c</span>
<span class="p_header">+++ b/arch/arc/mm/dma.c</span>
<span class="p_chunk">@@ -92,7 +92,8 @@</span> <span class="p_context"> static void *arc_dma_alloc(struct device *dev, size_t size,</span>
 static void arc_dma_free(struct device *dev, size_t size, void *vaddr,
 		dma_addr_t dma_handle, struct dma_attrs *attrs)
 {
<span class="p_del">-	struct page *page = virt_to_page(dma_handle);</span>
<span class="p_add">+	phys_addr_t paddr = plat_dma_to_phys(dev, dma_handle);</span>
<span class="p_add">+	struct page *page = virt_to_page(paddr);</span>
 	int is_non_coh = 1;
 
 	is_non_coh = dma_get_attr(DMA_ATTR_NON_CONSISTENT, attrs) ||
<span class="p_header">diff --git a/arch/arm/boot/dts/arm-realview-pbx-a9.dts b/arch/arm/boot/dts/arm-realview-pbx-a9.dts</span>
<span class="p_header">index db808f92dd79..90d00b407f85 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/arm-realview-pbx-a9.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/arm-realview-pbx-a9.dts</span>
<span class="p_chunk">@@ -70,13 +70,12 @@</span> <span class="p_context"></span>
 		 * associativity as these may be erroneously set
 		 * up by boot loader(s).
 		 */
<span class="p_del">-		cache-size = &lt;1048576&gt;; // 1MB</span>
<span class="p_del">-		cache-sets = &lt;4096&gt;;</span>
<span class="p_add">+		cache-size = &lt;131072&gt;; // 128KB</span>
<span class="p_add">+		cache-sets = &lt;512&gt;;</span>
 		cache-line-size = &lt;32&gt;;
 		arm,parity-disable;
<span class="p_del">-		arm,tag-latency = &lt;1&gt;;</span>
<span class="p_del">-		arm,data-latency = &lt;1 1&gt;;</span>
<span class="p_del">-		arm,dirty-latency = &lt;1&gt;;</span>
<span class="p_add">+		arm,tag-latency = &lt;1 1 1&gt;;</span>
<span class="p_add">+		arm,data-latency = &lt;1 1 1&gt;;</span>
 	};
 
 	scu: scu@1f000000 {
<span class="p_header">diff --git a/arch/arm/boot/dts/sun4i-a10-a1000.dts b/arch/arm/boot/dts/sun4i-a10-a1000.dts</span>
<span class="p_header">index c92a1ae33a1e..fa70b8fbf221 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/sun4i-a10-a1000.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/sun4i-a10-a1000.dts</span>
<span class="p_chunk">@@ -84,6 +84,7 @@</span> <span class="p_context"></span>
 		regulator-name = &quot;emac-3v3&quot;;
 		regulator-min-microvolt = &lt;3300000&gt;;
 		regulator-max-microvolt = &lt;3300000&gt;;
<span class="p_add">+		startup-delay-us = &lt;20000&gt;;</span>
 		enable-active-high;
 		gpio = &lt;&amp;pio 7 15 GPIO_ACTIVE_HIGH&gt;;
 	};
<span class="p_header">diff --git a/arch/arm/boot/dts/sun4i-a10-hackberry.dts b/arch/arm/boot/dts/sun4i-a10-hackberry.dts</span>
<span class="p_header">index 2b17c5199151..6de83a6187d0 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/sun4i-a10-hackberry.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/sun4i-a10-hackberry.dts</span>
<span class="p_chunk">@@ -66,6 +66,7 @@</span> <span class="p_context"></span>
 		regulator-name = &quot;emac-3v3&quot;;
 		regulator-min-microvolt = &lt;3300000&gt;;
 		regulator-max-microvolt = &lt;3300000&gt;;
<span class="p_add">+		startup-delay-us = &lt;20000&gt;;</span>
 		enable-active-high;
 		gpio = &lt;&amp;pio 7 19 GPIO_ACTIVE_HIGH&gt;;
 	};
<span class="p_header">diff --git a/arch/arm/boot/dts/sun4i-a10-jesurun-q5.dts b/arch/arm/boot/dts/sun4i-a10-jesurun-q5.dts</span>
<span class="p_header">index 7afc7a64eef1..e28f080b1fd5 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/sun4i-a10-jesurun-q5.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/sun4i-a10-jesurun-q5.dts</span>
<span class="p_chunk">@@ -80,6 +80,7 @@</span> <span class="p_context"></span>
 		regulator-name = &quot;emac-3v3&quot;;
 		regulator-min-microvolt = &lt;3300000&gt;;
 		regulator-max-microvolt = &lt;3300000&gt;;
<span class="p_add">+		startup-delay-us = &lt;20000&gt;;</span>
 		enable-active-high;
 		gpio = &lt;&amp;pio 7 19 GPIO_ACTIVE_HIGH&gt;;   /* PH19 */
 	};
<span class="p_header">diff --git a/arch/arm/boot/dts/sun5i-a10s-wobo-i5.dts b/arch/arm/boot/dts/sun5i-a10s-wobo-i5.dts</span>
<span class="p_header">index 9fea918f949e..39731a78f087 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/sun5i-a10s-wobo-i5.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/sun5i-a10s-wobo-i5.dts</span>
<span class="p_chunk">@@ -79,6 +79,7 @@</span> <span class="p_context"></span>
 		regulator-name = &quot;emac-3v3&quot;;
 		regulator-min-microvolt = &lt;3300000&gt;;
 		regulator-max-microvolt = &lt;3300000&gt;;
<span class="p_add">+		startup-delay-us = &lt;20000&gt;;</span>
 		enable-active-high;
 		gpio = &lt;&amp;pio 0 2 GPIO_ACTIVE_HIGH&gt;;
 	};
<span class="p_header">diff --git a/arch/arm/boot/dts/tegra124-jetson-tk1.dts b/arch/arm/boot/dts/tegra124-jetson-tk1.dts</span>
<span class="p_header">index 941f36263c8f..f4d8125c1bfc 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/tegra124-jetson-tk1.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/tegra124-jetson-tk1.dts</span>
<span class="p_chunk">@@ -1386,7 +1386,7 @@</span> <span class="p_context"></span>
 	 *   Pin 41: BR_UART1_TXD
 	 *   Pin 44: BR_UART1_RXD
 	 */
<span class="p_del">-	serial@70006000 {</span>
<span class="p_add">+	serial@0,70006000 {</span>
 		compatible = &quot;nvidia,tegra124-hsuart&quot;, &quot;nvidia,tegra30-hsuart&quot;;
 		status = &quot;okay&quot;;
 	};
<span class="p_chunk">@@ -1398,7 +1398,7 @@</span> <span class="p_context"></span>
 	 *   Pin 71: UART2_CTS_L
 	 *   Pin 74: UART2_RTS_L
 	 */
<span class="p_del">-	serial@70006040 {</span>
<span class="p_add">+	serial@0,70006040 {</span>
 		compatible = &quot;nvidia,tegra124-hsuart&quot;, &quot;nvidia,tegra30-hsuart&quot;;
 		status = &quot;okay&quot;;
 	};
<span class="p_header">diff --git a/arch/arm/configs/aspeed_g4_defconfig b/arch/arm/configs/aspeed_g4_defconfig</span>
<span class="p_header">index b6e54ee9bdbd..ca39c04fec6b 100644</span>
<span class="p_header">--- a/arch/arm/configs/aspeed_g4_defconfig</span>
<span class="p_header">+++ b/arch/arm/configs/aspeed_g4_defconfig</span>
<span class="p_chunk">@@ -58,7 +58,7 @@</span> <span class="p_context"> CONFIG_SERIAL_OF_PLATFORM=y</span>
 # CONFIG_IOMMU_SUPPORT is not set
 CONFIG_FIRMWARE_MEMMAP=y
 CONFIG_FANOTIFY=y
<span class="p_del">-CONFIG_PRINTK_TIME=1</span>
<span class="p_add">+CONFIG_PRINTK_TIME=y</span>
 CONFIG_DYNAMIC_DEBUG=y
 CONFIG_STRIP_ASM_SYMS=y
 CONFIG_PAGE_POISONING=y
<span class="p_header">diff --git a/arch/arm/configs/aspeed_g5_defconfig b/arch/arm/configs/aspeed_g5_defconfig</span>
<span class="p_header">index 892605167357..4f366b0370e9 100644</span>
<span class="p_header">--- a/arch/arm/configs/aspeed_g5_defconfig</span>
<span class="p_header">+++ b/arch/arm/configs/aspeed_g5_defconfig</span>
<span class="p_chunk">@@ -59,7 +59,7 @@</span> <span class="p_context"> CONFIG_SERIAL_OF_PLATFORM=y</span>
 # CONFIG_IOMMU_SUPPORT is not set
 CONFIG_FIRMWARE_MEMMAP=y
 CONFIG_FANOTIFY=y
<span class="p_del">-CONFIG_PRINTK_TIME=1</span>
<span class="p_add">+CONFIG_PRINTK_TIME=y</span>
 CONFIG_DYNAMIC_DEBUG=y
 CONFIG_STRIP_ASM_SYMS=y
 CONFIG_PAGE_POISONING=y
<span class="p_header">diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c</span>
<span class="p_header">index ff7ed5697d3e..d2485c749ad5 100644</span>
<span class="p_header">--- a/arch/arm/mm/dma-mapping.c</span>
<span class="p_header">+++ b/arch/arm/mm/dma-mapping.c</span>
<span class="p_chunk">@@ -49,6 +49,7 @@</span> <span class="p_context"> struct arm_dma_alloc_args {</span>
 	pgprot_t prot;
 	const void *caller;
 	bool want_vaddr;
<span class="p_add">+	int coherent_flag;</span>
 };
 
 struct arm_dma_free_args {
<span class="p_chunk">@@ -59,6 +60,9 @@</span> <span class="p_context"> struct arm_dma_free_args {</span>
 	bool want_vaddr;
 };
 
<span class="p_add">+#define NORMAL	    0</span>
<span class="p_add">+#define COHERENT    1</span>
<span class="p_add">+</span>
 struct arm_dma_allocator {
 	void *(*alloc)(struct arm_dma_alloc_args *args,
 		       struct page **ret_page);
<span class="p_chunk">@@ -272,7 +276,7 @@</span> <span class="p_context"> static u64 get_coherent_dma_mask(struct device *dev)</span>
 	return mask;
 }
 
<span class="p_del">-static void __dma_clear_buffer(struct page *page, size_t size)</span>
<span class="p_add">+static void __dma_clear_buffer(struct page *page, size_t size, int coherent_flag)</span>
 {
 	/*
 	 * Ensure that the allocated pages are zeroed, and that any data
<span class="p_chunk">@@ -284,17 +288,21 @@</span> <span class="p_context"> static void __dma_clear_buffer(struct page *page, size_t size)</span>
 		while (size &gt; 0) {
 			void *ptr = kmap_atomic(page);
 			memset(ptr, 0, PAGE_SIZE);
<span class="p_del">-			dmac_flush_range(ptr, ptr + PAGE_SIZE);</span>
<span class="p_add">+			if (coherent_flag != COHERENT)</span>
<span class="p_add">+				dmac_flush_range(ptr, ptr + PAGE_SIZE);</span>
 			kunmap_atomic(ptr);
 			page++;
 			size -= PAGE_SIZE;
 		}
<span class="p_del">-		outer_flush_range(base, end);</span>
<span class="p_add">+		if (coherent_flag != COHERENT)</span>
<span class="p_add">+			outer_flush_range(base, end);</span>
 	} else {
 		void *ptr = page_address(page);
 		memset(ptr, 0, size);
<span class="p_del">-		dmac_flush_range(ptr, ptr + size);</span>
<span class="p_del">-		outer_flush_range(__pa(ptr), __pa(ptr) + size);</span>
<span class="p_add">+		if (coherent_flag != COHERENT) {</span>
<span class="p_add">+			dmac_flush_range(ptr, ptr + size);</span>
<span class="p_add">+			outer_flush_range(__pa(ptr), __pa(ptr) + size);</span>
<span class="p_add">+		}</span>
 	}
 }
 
<span class="p_chunk">@@ -302,7 +310,8 @@</span> <span class="p_context"> static void __dma_clear_buffer(struct page *page, size_t size)</span>
  * Allocate a DMA buffer for &#39;dev&#39; of size &#39;size&#39; using the
  * specified gfp mask.  Note that &#39;size&#39; must be page aligned.
  */
<span class="p_del">-static struct page *__dma_alloc_buffer(struct device *dev, size_t size, gfp_t gfp)</span>
<span class="p_add">+static struct page *__dma_alloc_buffer(struct device *dev, size_t size,</span>
<span class="p_add">+				       gfp_t gfp, int coherent_flag)</span>
 {
 	unsigned long order = get_order(size);
 	struct page *page, *p, *e;
<span class="p_chunk">@@ -318,7 +327,7 @@</span> <span class="p_context"> static struct page *__dma_alloc_buffer(struct device *dev, size_t size, gfp_t gf</span>
 	for (p = page + (size &gt;&gt; PAGE_SHIFT), e = page + (1 &lt;&lt; order); p &lt; e; p++)
 		__free_page(p);
 
<span class="p_del">-	__dma_clear_buffer(page, size);</span>
<span class="p_add">+	__dma_clear_buffer(page, size, coherent_flag);</span>
 
 	return page;
 }
<span class="p_chunk">@@ -340,7 +349,8 @@</span> <span class="p_context"> static void __dma_free_buffer(struct page *page, size_t size)</span>
 
 static void *__alloc_from_contiguous(struct device *dev, size_t size,
 				     pgprot_t prot, struct page **ret_page,
<span class="p_del">-				     const void *caller, bool want_vaddr);</span>
<span class="p_add">+				     const void *caller, bool want_vaddr,</span>
<span class="p_add">+				     int coherent_flag);</span>
 
 static void *__alloc_remap_buffer(struct device *dev, size_t size, gfp_t gfp,
 				 pgprot_t prot, struct page **ret_page,
<span class="p_chunk">@@ -405,10 +415,13 @@</span> <span class="p_context"> static int __init atomic_pool_init(void)</span>
 	atomic_pool = gen_pool_create(PAGE_SHIFT, -1);
 	if (!atomic_pool)
 		goto out;
<span class="p_del">-</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The atomic pool is only used for non-coherent allocations</span>
<span class="p_add">+	 * so we must pass NORMAL for coherent_flag.</span>
<span class="p_add">+	 */</span>
 	if (dev_get_cma_area(NULL))
 		ptr = __alloc_from_contiguous(NULL, atomic_pool_size, prot,
<span class="p_del">-					      &amp;page, atomic_pool_init, true);</span>
<span class="p_add">+				      &amp;page, atomic_pool_init, true, NORMAL);</span>
 	else
 		ptr = __alloc_remap_buffer(NULL, atomic_pool_size, gfp, prot,
 					   &amp;page, atomic_pool_init, true);
<span class="p_chunk">@@ -522,7 +535,11 @@</span> <span class="p_context"> static void *__alloc_remap_buffer(struct device *dev, size_t size, gfp_t gfp,</span>
 {
 	struct page *page;
 	void *ptr = NULL;
<span class="p_del">-	page = __dma_alloc_buffer(dev, size, gfp);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * __alloc_remap_buffer is only called when the device is</span>
<span class="p_add">+	 * non-coherent</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	page = __dma_alloc_buffer(dev, size, gfp, NORMAL);</span>
 	if (!page)
 		return NULL;
 	if (!want_vaddr)
<span class="p_chunk">@@ -577,7 +594,8 @@</span> <span class="p_context"> static int __free_from_pool(void *start, size_t size)</span>
 
 static void *__alloc_from_contiguous(struct device *dev, size_t size,
 				     pgprot_t prot, struct page **ret_page,
<span class="p_del">-				     const void *caller, bool want_vaddr)</span>
<span class="p_add">+				     const void *caller, bool want_vaddr,</span>
<span class="p_add">+				     int coherent_flag)</span>
 {
 	unsigned long order = get_order(size);
 	size_t count = size &gt;&gt; PAGE_SHIFT;
<span class="p_chunk">@@ -588,7 +606,7 @@</span> <span class="p_context"> static void *__alloc_from_contiguous(struct device *dev, size_t size,</span>
 	if (!page)
 		return NULL;
 
<span class="p_del">-	__dma_clear_buffer(page, size);</span>
<span class="p_add">+	__dma_clear_buffer(page, size, coherent_flag);</span>
 
 	if (!want_vaddr)
 		goto out;
<span class="p_chunk">@@ -638,7 +656,7 @@</span> <span class="p_context"> static inline pgprot_t __get_dma_pgprot(struct dma_attrs *attrs, pgprot_t prot)</span>
 #define __get_dma_pgprot(attrs, prot)				__pgprot(0)
 #define __alloc_remap_buffer(dev, size, gfp, prot, ret, c, wv)	NULL
 #define __alloc_from_pool(size, ret_page)			NULL
<span class="p_del">-#define __alloc_from_contiguous(dev, size, prot, ret, c, wv)	NULL</span>
<span class="p_add">+#define __alloc_from_contiguous(dev, size, prot, ret, c, wv, coherent_flag)	NULL</span>
 #define __free_from_pool(cpu_addr, size)			do { } while (0)
 #define __free_from_contiguous(dev, page, cpu_addr, size, wv)	do { } while (0)
 #define __dma_free_remap(cpu_addr, size)			do { } while (0)
<span class="p_chunk">@@ -649,7 +667,8 @@</span> <span class="p_context"> static void *__alloc_simple_buffer(struct device *dev, size_t size, gfp_t gfp,</span>
 				   struct page **ret_page)
 {
 	struct page *page;
<span class="p_del">-	page = __dma_alloc_buffer(dev, size, gfp);</span>
<span class="p_add">+	/* __alloc_simple_buffer is only called when the device is coherent */</span>
<span class="p_add">+	page = __dma_alloc_buffer(dev, size, gfp, COHERENT);</span>
 	if (!page)
 		return NULL;
 
<span class="p_chunk">@@ -679,7 +698,7 @@</span> <span class="p_context"> static void *cma_allocator_alloc(struct arm_dma_alloc_args *args,</span>
 {
 	return __alloc_from_contiguous(args-&gt;dev, args-&gt;size, args-&gt;prot,
 				       ret_page, args-&gt;caller,
<span class="p_del">-				       args-&gt;want_vaddr);</span>
<span class="p_add">+				       args-&gt;want_vaddr, args-&gt;coherent_flag);</span>
 }
 
 static void cma_allocator_free(struct arm_dma_free_args *args)
<span class="p_chunk">@@ -746,6 +765,7 @@</span> <span class="p_context"> static void *__dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,</span>
 		.prot = prot,
 		.caller = caller,
 		.want_vaddr = !dma_get_attr(DMA_ATTR_NO_KERNEL_MAPPING, attrs),
<span class="p_add">+		.coherent_flag = is_coherent ? COHERENT : NORMAL,</span>
 	};
 
 #ifdef CONFIG_DMA_API_DEBUG
<span class="p_chunk">@@ -1253,7 +1273,8 @@</span> <span class="p_context"> static inline void __free_iova(struct dma_iommu_mapping *mapping,</span>
 static const int iommu_order_array[] = { 9, 8, 4, 0 };
 
 static struct page **__iommu_alloc_buffer(struct device *dev, size_t size,
<span class="p_del">-					  gfp_t gfp, struct dma_attrs *attrs)</span>
<span class="p_add">+					  gfp_t gfp, struct dma_attrs *attrs,</span>
<span class="p_add">+					  int coherent_flag)</span>
 {
 	struct page **pages;
 	int count = size &gt;&gt; PAGE_SHIFT;
<span class="p_chunk">@@ -1277,7 +1298,7 @@</span> <span class="p_context"> static struct page **__iommu_alloc_buffer(struct device *dev, size_t size,</span>
 		if (!page)
 			goto error;
 
<span class="p_del">-		__dma_clear_buffer(page, size);</span>
<span class="p_add">+		__dma_clear_buffer(page, size, coherent_flag);</span>
 
 		for (i = 0; i &lt; count; i++)
 			pages[i] = page + i;
<span class="p_chunk">@@ -1327,7 +1348,7 @@</span> <span class="p_context"> static struct page **__iommu_alloc_buffer(struct device *dev, size_t size,</span>
 				pages[i + j] = pages[i] + j;
 		}
 
<span class="p_del">-		__dma_clear_buffer(pages[i], PAGE_SIZE &lt;&lt; order);</span>
<span class="p_add">+		__dma_clear_buffer(pages[i], PAGE_SIZE &lt;&lt; order, coherent_flag);</span>
 		i += 1 &lt;&lt; order;
 		count -= 1 &lt;&lt; order;
 	}
<span class="p_chunk">@@ -1505,7 +1526,8 @@</span> <span class="p_context"> static void *arm_iommu_alloc_attrs(struct device *dev, size_t size,</span>
 	 */
 	gfp &amp;= ~(__GFP_COMP);
 
<span class="p_del">-	pages = __iommu_alloc_buffer(dev, size, gfp, attrs);</span>
<span class="p_add">+	/* For now always consider we are in a non-coherent case */</span>
<span class="p_add">+	pages = __iommu_alloc_buffer(dev, size, gfp, attrs, NORMAL);</span>
 	if (!pages)
 		return NULL;
 
<span class="p_header">diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig</span>
<span class="p_header">index 5a0a691d4220..20384925bb0f 100644</span>
<span class="p_header">--- a/arch/arm64/Kconfig</span>
<span class="p_header">+++ b/arch/arm64/Kconfig</span>
<span class="p_chunk">@@ -872,7 +872,7 @@</span> <span class="p_context"> config RELOCATABLE</span>
 
 config RANDOMIZE_BASE
 	bool &quot;Randomize the address of the kernel image&quot;
<span class="p_del">-	select ARM64_MODULE_PLTS</span>
<span class="p_add">+	select ARM64_MODULE_PLTS if MODULES</span>
 	select RELOCATABLE
 	help
 	  Randomizes the virtual address at which the kernel image is
<span class="p_header">diff --git a/arch/arm64/boot/dts/rockchip/rk3368.dtsi b/arch/arm64/boot/dts/rockchip/rk3368.dtsi</span>
<span class="p_header">index 8b4a7c9154e9..080203e3aa2f 100644</span>
<span class="p_header">--- a/arch/arm64/boot/dts/rockchip/rk3368.dtsi</span>
<span class="p_header">+++ b/arch/arm64/boot/dts/rockchip/rk3368.dtsi</span>
<span class="p_chunk">@@ -670,7 +670,7 @@</span> <span class="p_context"></span>
 		#address-cells = &lt;0&gt;;
 
 		reg = &lt;0x0 0xffb71000 0x0 0x1000&gt;,
<span class="p_del">-		      &lt;0x0 0xffb72000 0x0 0x1000&gt;,</span>
<span class="p_add">+		      &lt;0x0 0xffb72000 0x0 0x2000&gt;,</span>
 		      &lt;0x0 0xffb74000 0x0 0x2000&gt;,
 		      &lt;0x0 0xffb76000 0x0 0x2000&gt;;
 		interrupts = &lt;GIC_PPI 9
<span class="p_header">diff --git a/arch/arm64/kernel/debug-monitors.c b/arch/arm64/kernel/debug-monitors.c</span>
<span class="p_header">index 4fbf3c54275c..0800d23e2fdd 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/debug-monitors.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/debug-monitors.c</span>
<span class="p_chunk">@@ -151,7 +151,6 @@</span> <span class="p_context"> static int debug_monitors_init(void)</span>
 	/* Clear the OS lock. */
 	on_each_cpu(clear_os_lock, NULL, 1);
 	isb();
<span class="p_del">-	local_dbg_enable();</span>
 
 	/* Register hotplug handler. */
 	__register_cpu_notifier(&amp;os_lock_nb);
<span class="p_header">diff --git a/arch/arm64/kernel/hibernate.c b/arch/arm64/kernel/hibernate.c</span>
<span class="p_header">index 21ab5df9fa76..65d81f965e74 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/hibernate.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/hibernate.c</span>
<span class="p_chunk">@@ -35,6 +35,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/sections.h&gt;
 #include &lt;asm/smp.h&gt;
 #include &lt;asm/suspend.h&gt;
<span class="p_add">+#include &lt;asm/sysreg.h&gt;</span>
 #include &lt;asm/virt.h&gt;
 
 /*
<span class="p_chunk">@@ -217,12 +218,22 @@</span> <span class="p_context"> static int create_safe_exec_page(void *src_start, size_t length,</span>
 	set_pte(pte, __pte(virt_to_phys((void *)dst) |
 			 pgprot_val(PAGE_KERNEL_EXEC)));
 
<span class="p_del">-	/* Load our new page tables */</span>
<span class="p_del">-	asm volatile(&quot;msr	ttbr0_el1, %0;&quot;</span>
<span class="p_del">-		     &quot;isb;&quot;</span>
<span class="p_del">-		     &quot;tlbi	vmalle1is;&quot;</span>
<span class="p_del">-		     &quot;dsb	ish;&quot;</span>
<span class="p_del">-		     &quot;isb&quot; : : &quot;r&quot;(virt_to_phys(pgd)));</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Load our new page tables. A strict BBM approach requires that we</span>
<span class="p_add">+	 * ensure that TLBs are free of any entries that may overlap with the</span>
<span class="p_add">+	 * global mappings we are about to install.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * For a real hibernate/resume cycle TTBR0 currently points to a zero</span>
<span class="p_add">+	 * page, but TLBs may contain stale ASID-tagged entries (e.g. for EFI</span>
<span class="p_add">+	 * runtime services), while for a userspace-driven test_resume cycle it</span>
<span class="p_add">+	 * points to userspace page tables (and we must point it at a zero page</span>
<span class="p_add">+	 * ourselves). Elsewhere we only (un)install the idmap with preemption</span>
<span class="p_add">+	 * disabled, so T0SZ should be as required regardless.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	cpu_set_reserved_ttbr0();</span>
<span class="p_add">+	local_flush_tlb_all();</span>
<span class="p_add">+	write_sysreg(virt_to_phys(pgd), ttbr0_el1);</span>
<span class="p_add">+	isb();</span>
 
 	*phys_dst_addr = virt_to_phys((void *)dst);
 
<span class="p_chunk">@@ -394,6 +405,38 @@</span> <span class="p_context"> int swsusp_arch_resume(void)</span>
 					  void *, phys_addr_t, phys_addr_t);
 
 	/*
<span class="p_add">+	 * Restoring the memory image will overwrite the ttbr1 page tables.</span>
<span class="p_add">+	 * Create a second copy of just the linear map, and use this when</span>
<span class="p_add">+	 * restoring.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	tmp_pg_dir = (pgd_t *)get_safe_page(GFP_ATOMIC);</span>
<span class="p_add">+	if (!tmp_pg_dir) {</span>
<span class="p_add">+		pr_err(&quot;Failed to allocate memory for temporary page tables.&quot;);</span>
<span class="p_add">+		rc = -ENOMEM;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	rc = copy_page_tables(tmp_pg_dir, PAGE_OFFSET, 0);</span>
<span class="p_add">+	if (rc)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Since we only copied the linear map, we need to find restore_pblist&#39;s</span>
<span class="p_add">+	 * linear map address.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	lm_restore_pblist = LMADDR(restore_pblist);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need a zero page that is zero before &amp; after resume in order to</span>
<span class="p_add">+	 * to break before make on the ttbr1 page tables.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	zero_page = (void *)get_safe_page(GFP_ATOMIC);</span>
<span class="p_add">+	if (!zero_page) {</span>
<span class="p_add">+		pr_err(&quot;Failed to allocate zero page.&quot;);</span>
<span class="p_add">+		rc = -ENOMEM;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * Locate the exit code in the bottom-but-one page, so that *NULL
 	 * still has disastrous affects.
 	 */
<span class="p_chunk">@@ -419,27 +462,6 @@</span> <span class="p_context"> int swsusp_arch_resume(void)</span>
 	__flush_dcache_area(hibernate_exit, exit_size);
 
 	/*
<span class="p_del">-	 * Restoring the memory image will overwrite the ttbr1 page tables.</span>
<span class="p_del">-	 * Create a second copy of just the linear map, and use this when</span>
<span class="p_del">-	 * restoring.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	tmp_pg_dir = (pgd_t *)get_safe_page(GFP_ATOMIC);</span>
<span class="p_del">-	if (!tmp_pg_dir) {</span>
<span class="p_del">-		pr_err(&quot;Failed to allocate memory for temporary page tables.&quot;);</span>
<span class="p_del">-		rc = -ENOMEM;</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	rc = copy_page_tables(tmp_pg_dir, PAGE_OFFSET, 0);</span>
<span class="p_del">-	if (rc)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Since we only copied the linear map, we need to find restore_pblist&#39;s</span>
<span class="p_del">-	 * linear map address.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	lm_restore_pblist = LMADDR(restore_pblist);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
 	 * KASLR will cause the el2 vectors to be in a different location in
 	 * the resumed kernel. Load hibernate&#39;s temporary copy into el2.
 	 *
<span class="p_chunk">@@ -453,12 +475,6 @@</span> <span class="p_context"> int swsusp_arch_resume(void)</span>
 		__hyp_set_vectors(el2_vectors);
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We need a zero page that is zero before &amp; after resume in order to</span>
<span class="p_del">-	 * to break before make on the ttbr1 page tables.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	zero_page = (void *)get_safe_page(GFP_ATOMIC);</span>
<span class="p_del">-</span>
 	hibernate_exit(virt_to_phys(tmp_pg_dir), resume_hdr.ttbr1_el1,
 		       resume_hdr.reenter_kernel, lm_restore_pblist,
 		       resume_hdr.__hyp_stub_vectors, virt_to_phys(zero_page));
<span class="p_header">diff --git a/arch/arm64/kernel/smp.c b/arch/arm64/kernel/smp.c</span>
<span class="p_header">index 62ff3c0622e2..490db85dec23 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/smp.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/smp.c</span>
<span class="p_chunk">@@ -267,7 +267,6 @@</span> <span class="p_context"> asmlinkage void secondary_start_kernel(void)</span>
 	set_cpu_online(cpu, true);
 	complete(&amp;cpu_running);
 
<span class="p_del">-	local_dbg_enable();</span>
 	local_irq_enable();
 	local_async_enable();
 
<span class="p_chunk">@@ -437,9 +436,9 @@</span> <span class="p_context"> void __init smp_cpus_done(unsigned int max_cpus)</span>
 
 void __init smp_prepare_boot_cpu(void)
 {
<span class="p_add">+	set_my_cpu_offset(per_cpu_offset(smp_processor_id()));</span>
 	cpuinfo_store_boot_cpu();
 	save_boot_cpu_run_el();
<span class="p_del">-	set_my_cpu_offset(per_cpu_offset(smp_processor_id()));</span>
 }
 
 static u64 __init of_get_cpu_mpidr(struct device_node *dn)
<span class="p_chunk">@@ -694,6 +693,13 @@</span> <span class="p_context"> void __init smp_prepare_cpus(unsigned int max_cpus)</span>
 	smp_store_cpu_info(smp_processor_id());
 
 	/*
<span class="p_add">+	 * If UP is mandated by &quot;nosmp&quot; (which implies &quot;maxcpus=0&quot;), don&#39;t set</span>
<span class="p_add">+	 * secondary CPUs present.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (max_cpus == 0)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * Initialise the present map (which describes the set of CPUs
 	 * actually populated at the present time) and release the
 	 * secondaries from the bootloader.
<span class="p_header">diff --git a/arch/arm64/kernel/vmlinux.lds.S b/arch/arm64/kernel/vmlinux.lds.S</span>
<span class="p_header">index 435e820e898d..e564d4595998 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/vmlinux.lds.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/vmlinux.lds.S</span>
<span class="p_chunk">@@ -181,9 +181,9 @@</span> <span class="p_context"> SECTIONS</span>
 		*(.hash)
 	}
 
<span class="p_del">-	__rela_offset	= ADDR(.rela) - KIMAGE_VADDR;</span>
<span class="p_add">+	__rela_offset	= ABSOLUTE(ADDR(.rela) - KIMAGE_VADDR);</span>
 	__rela_size	= SIZEOF(.rela);
<span class="p_del">-	__dynsym_offset	= ADDR(.dynsym) - KIMAGE_VADDR;</span>
<span class="p_add">+	__dynsym_offset	= ABSOLUTE(ADDR(.dynsym) - KIMAGE_VADDR);</span>
 
 	. = ALIGN(SEGMENT_ALIGN);
 	__init_end = .;
<span class="p_header">diff --git a/arch/arm64/kvm/hyp/sysreg-sr.c b/arch/arm64/kvm/hyp/sysreg-sr.c</span>
<span class="p_header">index 0f7c40eb3f53..934137647837 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/hyp/sysreg-sr.c</span>
<span class="p_header">+++ b/arch/arm64/kvm/hyp/sysreg-sr.c</span>
<span class="p_chunk">@@ -27,8 +27,8 @@</span> <span class="p_context"> static void __hyp_text __sysreg_do_nothing(struct kvm_cpu_context *ctxt) { }</span>
 /*
  * Non-VHE: Both host and guest must save everything.
  *
<span class="p_del">- * VHE: Host must save tpidr*_el[01], actlr_el1, sp0, pc, pstate, and</span>
<span class="p_del">- * guest must save everything.</span>
<span class="p_add">+ * VHE: Host must save tpidr*_el[01], actlr_el1, mdscr_el1, sp0, pc,</span>
<span class="p_add">+ * pstate, and guest must save everything.</span>
  */
 
 static void __hyp_text __sysreg_save_common_state(struct kvm_cpu_context *ctxt)
<span class="p_chunk">@@ -37,6 +37,7 @@</span> <span class="p_context"> static void __hyp_text __sysreg_save_common_state(struct kvm_cpu_context *ctxt)</span>
 	ctxt-&gt;sys_regs[TPIDR_EL0]	= read_sysreg(tpidr_el0);
 	ctxt-&gt;sys_regs[TPIDRRO_EL0]	= read_sysreg(tpidrro_el0);
 	ctxt-&gt;sys_regs[TPIDR_EL1]	= read_sysreg(tpidr_el1);
<span class="p_add">+	ctxt-&gt;sys_regs[MDSCR_EL1]	= read_sysreg(mdscr_el1);</span>
 	ctxt-&gt;gp_regs.regs.sp		= read_sysreg(sp_el0);
 	ctxt-&gt;gp_regs.regs.pc		= read_sysreg_el2(elr);
 	ctxt-&gt;gp_regs.regs.pstate	= read_sysreg_el2(spsr);
<span class="p_chunk">@@ -61,7 +62,6 @@</span> <span class="p_context"> static void __hyp_text __sysreg_save_state(struct kvm_cpu_context *ctxt)</span>
 	ctxt-&gt;sys_regs[AMAIR_EL1]	= read_sysreg_el1(amair);
 	ctxt-&gt;sys_regs[CNTKCTL_EL1]	= read_sysreg_el1(cntkctl);
 	ctxt-&gt;sys_regs[PAR_EL1]		= read_sysreg(par_el1);
<span class="p_del">-	ctxt-&gt;sys_regs[MDSCR_EL1]	= read_sysreg(mdscr_el1);</span>
 
 	ctxt-&gt;gp_regs.sp_el1		= read_sysreg(sp_el1);
 	ctxt-&gt;gp_regs.elr_el1		= read_sysreg_el1(elr);
<span class="p_chunk">@@ -90,6 +90,7 @@</span> <span class="p_context"> static void __hyp_text __sysreg_restore_common_state(struct kvm_cpu_context *ctx</span>
 	write_sysreg(ctxt-&gt;sys_regs[TPIDR_EL0],	  tpidr_el0);
 	write_sysreg(ctxt-&gt;sys_regs[TPIDRRO_EL0], tpidrro_el0);
 	write_sysreg(ctxt-&gt;sys_regs[TPIDR_EL1],	  tpidr_el1);
<span class="p_add">+	write_sysreg(ctxt-&gt;sys_regs[MDSCR_EL1],	  mdscr_el1);</span>
 	write_sysreg(ctxt-&gt;gp_regs.regs.sp,	  sp_el0);
 	write_sysreg_el2(ctxt-&gt;gp_regs.regs.pc,	  elr);
 	write_sysreg_el2(ctxt-&gt;gp_regs.regs.pstate, spsr);
<span class="p_chunk">@@ -114,7 +115,6 @@</span> <span class="p_context"> static void __hyp_text __sysreg_restore_state(struct kvm_cpu_context *ctxt)</span>
 	write_sysreg_el1(ctxt-&gt;sys_regs[AMAIR_EL1],	amair);
 	write_sysreg_el1(ctxt-&gt;sys_regs[CNTKCTL_EL1], 	cntkctl);
 	write_sysreg(ctxt-&gt;sys_regs[PAR_EL1],		par_el1);
<span class="p_del">-	write_sysreg(ctxt-&gt;sys_regs[MDSCR_EL1],		mdscr_el1);</span>
 
 	write_sysreg(ctxt-&gt;gp_regs.sp_el1,		sp_el1);
 	write_sysreg_el1(ctxt-&gt;gp_regs.elr_el1,		elr);
<span class="p_header">diff --git a/arch/arm64/kvm/inject_fault.c b/arch/arm64/kvm/inject_fault.c</span>
<span class="p_header">index e9e0e6db73f6..898c0e6aedd4 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/inject_fault.c</span>
<span class="p_header">+++ b/arch/arm64/kvm/inject_fault.c</span>
<span class="p_chunk">@@ -132,16 +132,14 @@</span> <span class="p_context"> static u64 get_except_vector(struct kvm_vcpu *vcpu, enum exception_type type)</span>
 static void inject_abt64(struct kvm_vcpu *vcpu, bool is_iabt, unsigned long addr)
 {
 	unsigned long cpsr = *vcpu_cpsr(vcpu);
<span class="p_del">-	bool is_aarch32;</span>
<span class="p_add">+	bool is_aarch32 = vcpu_mode_is_32bit(vcpu);</span>
 	u32 esr = 0;
 
<span class="p_del">-	is_aarch32 = vcpu_mode_is_32bit(vcpu);</span>
<span class="p_del">-</span>
<span class="p_del">-	*vcpu_spsr(vcpu) = cpsr;</span>
 	*vcpu_elr_el1(vcpu) = *vcpu_pc(vcpu);
<span class="p_del">-</span>
 	*vcpu_pc(vcpu) = get_except_vector(vcpu, except_type_sync);
<span class="p_add">+</span>
 	*vcpu_cpsr(vcpu) = PSTATE_FAULT_BITS_64;
<span class="p_add">+	*vcpu_spsr(vcpu) = cpsr;</span>
 
 	vcpu_sys_reg(vcpu, FAR_EL1) = addr;
 
<span class="p_chunk">@@ -172,11 +170,11 @@</span> <span class="p_context"> static void inject_undef64(struct kvm_vcpu *vcpu)</span>
 	unsigned long cpsr = *vcpu_cpsr(vcpu);
 	u32 esr = (ESR_ELx_EC_UNKNOWN &lt;&lt; ESR_ELx_EC_SHIFT);
 
<span class="p_del">-	*vcpu_spsr(vcpu) = cpsr;</span>
 	*vcpu_elr_el1(vcpu) = *vcpu_pc(vcpu);
<span class="p_del">-</span>
 	*vcpu_pc(vcpu) = get_except_vector(vcpu, except_type_sync);
<span class="p_add">+</span>
 	*vcpu_cpsr(vcpu) = PSTATE_FAULT_BITS_64;
<span class="p_add">+	*vcpu_spsr(vcpu) = cpsr;</span>
 
 	/*
 	 * Build an unknown exception, depending on the instruction
<span class="p_header">diff --git a/arch/arm64/mm/mmu.c b/arch/arm64/mm/mmu.c</span>
<span class="p_header">index 0f85a46c3e18..3e90a2cad995 100644</span>
<span class="p_header">--- a/arch/arm64/mm/mmu.c</span>
<span class="p_header">+++ b/arch/arm64/mm/mmu.c</span>
<span class="p_chunk">@@ -748,9 +748,9 @@</span> <span class="p_context"> void *__init __fixmap_remap_fdt(phys_addr_t dt_phys, int *size, pgprot_t prot)</span>
 	/*
 	 * Check whether the physical FDT address is set and meets the minimum
 	 * alignment requirement. Since we are relying on MIN_FDT_ALIGN to be
<span class="p_del">-	 * at least 8 bytes so that we can always access the size field of the</span>
<span class="p_del">-	 * FDT header after mapping the first chunk, double check here if that</span>
<span class="p_del">-	 * is indeed the case.</span>
<span class="p_add">+	 * at least 8 bytes so that we can always access the magic and size</span>
<span class="p_add">+	 * fields of the FDT header after mapping the first chunk, double check</span>
<span class="p_add">+	 * here if that is indeed the case.</span>
 	 */
 	BUILD_BUG_ON(MIN_FDT_ALIGN &lt; 8);
 	if (!dt_phys || dt_phys % MIN_FDT_ALIGN)
<span class="p_chunk">@@ -778,7 +778,7 @@</span> <span class="p_context"> void *__init __fixmap_remap_fdt(phys_addr_t dt_phys, int *size, pgprot_t prot)</span>
 	create_mapping_noalloc(round_down(dt_phys, SWAPPER_BLOCK_SIZE),
 			dt_virt_base, SWAPPER_BLOCK_SIZE, prot);
 
<span class="p_del">-	if (fdt_check_header(dt_virt) != 0)</span>
<span class="p_add">+	if (fdt_magic(dt_virt) != FDT_MAGIC)</span>
 		return NULL;
 
 	*size = fdt_totalsize(dt_virt);
<span class="p_header">diff --git a/arch/arm64/mm/proc.S b/arch/arm64/mm/proc.S</span>
<span class="p_header">index c4317879b938..5bb61de23201 100644</span>
<span class="p_header">--- a/arch/arm64/mm/proc.S</span>
<span class="p_header">+++ b/arch/arm64/mm/proc.S</span>
<span class="p_chunk">@@ -180,6 +180,8 @@</span> <span class="p_context"> ENTRY(__cpu_setup)</span>
 	msr	cpacr_el1, x0			// Enable FP/ASIMD
 	mov	x0, #1 &lt;&lt; 12			// Reset mdscr_el1 and disable
 	msr	mdscr_el1, x0			// access to the DCC from EL0
<span class="p_add">+	isb					// Unmask debug exceptions now,</span>
<span class="p_add">+	enable_dbg				// since this is per-cpu</span>
 	reset_pmuserenr_el0 x0			// Disable PMU access from EL0
 	/*
 	 * Memory region attributes for LPAE:
<span class="p_header">diff --git a/arch/metag/include/asm/cmpxchg_lnkget.h b/arch/metag/include/asm/cmpxchg_lnkget.h</span>
<span class="p_header">index 0154e2807ebb..2369ad394876 100644</span>
<span class="p_header">--- a/arch/metag/include/asm/cmpxchg_lnkget.h</span>
<span class="p_header">+++ b/arch/metag/include/asm/cmpxchg_lnkget.h</span>
<span class="p_chunk">@@ -73,7 +73,7 @@</span> <span class="p_context"> static inline unsigned long __cmpxchg_u32(volatile int *m, unsigned long old,</span>
 		      &quot;	DCACHE	[%2], %0\n&quot;
 #endif
 		      &quot;2:\n&quot;
<span class="p_del">-		      : &quot;=&amp;d&quot; (temp), &quot;=&amp;da&quot; (retval)</span>
<span class="p_add">+		      : &quot;=&amp;d&quot; (temp), &quot;=&amp;d&quot; (retval)</span>
 		      : &quot;da&quot; (m), &quot;bd&quot; (old), &quot;da&quot; (new)
 		      : &quot;cc&quot;
 		      );
<span class="p_header">diff --git a/arch/mips/kernel/cevt-r4k.c b/arch/mips/kernel/cevt-r4k.c</span>
<span class="p_header">index e4c21bbf9422..804d2a2a19fe 100644</span>
<span class="p_header">--- a/arch/mips/kernel/cevt-r4k.c</span>
<span class="p_header">+++ b/arch/mips/kernel/cevt-r4k.c</span>
<span class="p_chunk">@@ -276,12 +276,7 @@</span> <span class="p_context"> int r4k_clockevent_init(void)</span>
 				  CLOCK_EVT_FEAT_C3STOP |
 				  CLOCK_EVT_FEAT_PERCPU;
 
<span class="p_del">-	clockevent_set_clock(cd, mips_hpt_frequency);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Calculate the min / max delta */</span>
<span class="p_del">-	cd-&gt;max_delta_ns	= clockevent_delta2ns(0x7fffffff, cd);</span>
 	min_delta		= calculate_min_delta();
<span class="p_del">-	cd-&gt;min_delta_ns	= clockevent_delta2ns(min_delta, cd);</span>
 
 	cd-&gt;rating		= 300;
 	cd-&gt;irq			= irq;
<span class="p_chunk">@@ -289,7 +284,7 @@</span> <span class="p_context"> int r4k_clockevent_init(void)</span>
 	cd-&gt;set_next_event	= mips_next_event;
 	cd-&gt;event_handler	= mips_event_handler;
 
<span class="p_del">-	clockevents_register_device(cd);</span>
<span class="p_add">+	clockevents_config_and_register(cd, mips_hpt_frequency, min_delta, 0x7fffffff);</span>
 
 	if (cp0_timer_irq_installed)
 		return 0;
<span class="p_header">diff --git a/arch/mips/kernel/csrc-r4k.c b/arch/mips/kernel/csrc-r4k.c</span>
<span class="p_header">index 1f910563fdf6..d76275da54cb 100644</span>
<span class="p_header">--- a/arch/mips/kernel/csrc-r4k.c</span>
<span class="p_header">+++ b/arch/mips/kernel/csrc-r4k.c</span>
<span class="p_chunk">@@ -23,7 +23,7 @@</span> <span class="p_context"> static struct clocksource clocksource_mips = {</span>
 	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 };
 
<span class="p_del">-static u64 notrace r4k_read_sched_clock(void)</span>
<span class="p_add">+static u64 __maybe_unused notrace r4k_read_sched_clock(void)</span>
 {
 	return read_c0_count();
 }
<span class="p_chunk">@@ -82,7 +82,9 @@</span> <span class="p_context"> int __init init_r4k_clocksource(void)</span>
 
 	clocksource_register_hz(&amp;clocksource_mips, mips_hpt_frequency);
 
<span class="p_add">+#ifndef CONFIG_CPU_FREQ</span>
 	sched_clock_register(r4k_read_sched_clock, 32, mips_hpt_frequency);
<span class="p_add">+#endif</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/arch/mips/kvm/emulate.c b/arch/mips/kvm/emulate.c</span>
<span class="p_header">index 645c8a1982a7..2b42a74ed771 100644</span>
<span class="p_header">--- a/arch/mips/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/mips/kvm/emulate.c</span>
<span class="p_chunk">@@ -1615,8 +1615,14 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emulate_cache(uint32_t inst, uint32_t *opc,</span>
 
 	preempt_disable();
 	if (KVM_GUEST_KSEGX(va) == KVM_GUEST_KSEG0) {
<span class="p_del">-		if (kvm_mips_host_tlb_lookup(vcpu, va) &lt; 0)</span>
<span class="p_del">-			kvm_mips_handle_kseg0_tlb_fault(va, vcpu);</span>
<span class="p_add">+		if (kvm_mips_host_tlb_lookup(vcpu, va) &lt; 0 &amp;&amp;</span>
<span class="p_add">+		    kvm_mips_handle_kseg0_tlb_fault(va, vcpu)) {</span>
<span class="p_add">+			kvm_err(&quot;%s: handling mapped kseg0 tlb fault for %lx, vcpu: %p, ASID: %#lx\n&quot;,</span>
<span class="p_add">+				__func__, va, vcpu, read_c0_entryhi());</span>
<span class="p_add">+			er = EMULATE_FAIL;</span>
<span class="p_add">+			preempt_enable();</span>
<span class="p_add">+			goto done;</span>
<span class="p_add">+		}</span>
 	} else if ((KVM_GUEST_KSEGX(va) &lt; KVM_GUEST_KSEG0) ||
 		   KVM_GUEST_KSEGX(va) == KVM_GUEST_KSEG23) {
 		int index;
<span class="p_chunk">@@ -1654,14 +1660,19 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emulate_cache(uint32_t inst, uint32_t *opc,</span>
 								run, vcpu);
 				preempt_enable();
 				goto dont_update_pc;
<span class="p_del">-			} else {</span>
<span class="p_del">-				/*</span>
<span class="p_del">-				 * We fault an entry from the guest tlb to the</span>
<span class="p_del">-				 * shadow host TLB</span>
<span class="p_del">-				 */</span>
<span class="p_del">-				kvm_mips_handle_mapped_seg_tlb_fault(vcpu, tlb,</span>
<span class="p_del">-								     NULL,</span>
<span class="p_del">-								     NULL);</span>
<span class="p_add">+			}</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * We fault an entry from the guest tlb to the</span>
<span class="p_add">+			 * shadow host TLB</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (kvm_mips_handle_mapped_seg_tlb_fault(vcpu, tlb,</span>
<span class="p_add">+								 NULL, NULL)) {</span>
<span class="p_add">+				kvm_err(&quot;%s: handling mapped seg tlb fault for %lx, index: %u, vcpu: %p, ASID: %#lx\n&quot;,</span>
<span class="p_add">+					__func__, va, index, vcpu,</span>
<span class="p_add">+					read_c0_entryhi());</span>
<span class="p_add">+				er = EMULATE_FAIL;</span>
<span class="p_add">+				preempt_enable();</span>
<span class="p_add">+				goto done;</span>
 			}
 		}
 	} else {
<span class="p_chunk">@@ -2625,8 +2636,13 @@</span> <span class="p_context"> enum emulation_result kvm_mips_handle_tlbmiss(unsigned long cause,</span>
 			 * OK we have a Guest TLB entry, now inject it into the
 			 * shadow host TLB
 			 */
<span class="p_del">-			kvm_mips_handle_mapped_seg_tlb_fault(vcpu, tlb, NULL,</span>
<span class="p_del">-							     NULL);</span>
<span class="p_add">+			if (kvm_mips_handle_mapped_seg_tlb_fault(vcpu, tlb,</span>
<span class="p_add">+								 NULL, NULL)) {</span>
<span class="p_add">+				kvm_err(&quot;%s: handling mapped seg tlb fault for %lx, index: %u, vcpu: %p, ASID: %#lx\n&quot;,</span>
<span class="p_add">+					__func__, va, index, vcpu,</span>
<span class="p_add">+					read_c0_entryhi());</span>
<span class="p_add">+				er = EMULATE_FAIL;</span>
<span class="p_add">+			}</span>
 		}
 	}
 
<span class="p_header">diff --git a/arch/mips/kvm/tlb.c b/arch/mips/kvm/tlb.c</span>
<span class="p_header">index ed021ae7867a..ad2270ff83d1 100644</span>
<span class="p_header">--- a/arch/mips/kvm/tlb.c</span>
<span class="p_header">+++ b/arch/mips/kvm/tlb.c</span>
<span class="p_chunk">@@ -284,7 +284,7 @@</span> <span class="p_context"> int kvm_mips_handle_kseg0_tlb_fault(unsigned long badvaddr,</span>
 	}
 
 	gfn = (KVM_GUEST_CPHYSADDR(badvaddr) &gt;&gt; PAGE_SHIFT);
<span class="p_del">-	if (gfn &gt;= kvm-&gt;arch.guest_pmap_npages) {</span>
<span class="p_add">+	if ((gfn | 1) &gt;= kvm-&gt;arch.guest_pmap_npages) {</span>
 		kvm_err(&quot;%s: Invalid gfn: %#llx, BadVaddr: %#lx\n&quot;, __func__,
 			gfn, badvaddr);
 		kvm_mips_dump_host_tlbs();
<span class="p_chunk">@@ -373,26 +373,40 @@</span> <span class="p_context"> int kvm_mips_handle_mapped_seg_tlb_fault(struct kvm_vcpu *vcpu,</span>
 	unsigned long entryhi = 0, entrylo0 = 0, entrylo1 = 0;
 	struct kvm *kvm = vcpu-&gt;kvm;
 	kvm_pfn_t pfn0, pfn1;
<span class="p_add">+	gfn_t gfn0, gfn1;</span>
<span class="p_add">+	long tlb_lo[2];</span>
 	int ret;
 
<span class="p_del">-	if ((tlb-&gt;tlb_hi &amp; VPN2_MASK) == 0) {</span>
<span class="p_del">-		pfn0 = 0;</span>
<span class="p_del">-		pfn1 = 0;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		if (kvm_mips_map_page(kvm, mips3_tlbpfn_to_paddr(tlb-&gt;tlb_lo0)</span>
<span class="p_del">-					   &gt;&gt; PAGE_SHIFT) &lt; 0)</span>
<span class="p_del">-			return -1;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (kvm_mips_map_page(kvm, mips3_tlbpfn_to_paddr(tlb-&gt;tlb_lo1)</span>
<span class="p_del">-					   &gt;&gt; PAGE_SHIFT) &lt; 0)</span>
<span class="p_del">-			return -1;</span>
<span class="p_del">-</span>
<span class="p_del">-		pfn0 = kvm-&gt;arch.guest_pmap[mips3_tlbpfn_to_paddr(tlb-&gt;tlb_lo0)</span>
<span class="p_del">-					    &gt;&gt; PAGE_SHIFT];</span>
<span class="p_del">-		pfn1 = kvm-&gt;arch.guest_pmap[mips3_tlbpfn_to_paddr(tlb-&gt;tlb_lo1)</span>
<span class="p_del">-					    &gt;&gt; PAGE_SHIFT];</span>
<span class="p_add">+	tlb_lo[0] = tlb-&gt;tlb_lo0;</span>
<span class="p_add">+	tlb_lo[1] = tlb-&gt;tlb_lo1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The commpage address must not be mapped to anything else if the guest</span>
<span class="p_add">+	 * TLB contains entries nearby, or commpage accesses will break.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!((tlb-&gt;tlb_hi ^ KVM_GUEST_COMMPAGE_ADDR) &amp;</span>
<span class="p_add">+			VPN2_MASK &amp; (PAGE_MASK &lt;&lt; 1)))</span>
<span class="p_add">+		tlb_lo[(KVM_GUEST_COMMPAGE_ADDR &gt;&gt; PAGE_SHIFT) &amp; 1] = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	gfn0 = mips3_tlbpfn_to_paddr(tlb_lo[0]) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	gfn1 = mips3_tlbpfn_to_paddr(tlb_lo[1]) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	if (gfn0 &gt;= kvm-&gt;arch.guest_pmap_npages ||</span>
<span class="p_add">+	    gfn1 &gt;= kvm-&gt;arch.guest_pmap_npages) {</span>
<span class="p_add">+		kvm_err(&quot;%s: Invalid gfn: [%#llx, %#llx], EHi: %#lx\n&quot;,</span>
<span class="p_add">+			__func__, gfn0, gfn1, tlb-&gt;tlb_hi);</span>
<span class="p_add">+		kvm_mips_dump_guest_tlbs(vcpu);</span>
<span class="p_add">+		return -1;</span>
 	}
 
<span class="p_add">+	if (kvm_mips_map_page(kvm, gfn0) &lt; 0)</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (kvm_mips_map_page(kvm, gfn1) &lt; 0)</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+</span>
<span class="p_add">+	pfn0 = kvm-&gt;arch.guest_pmap[gfn0];</span>
<span class="p_add">+	pfn1 = kvm-&gt;arch.guest_pmap[gfn1];</span>
<span class="p_add">+</span>
 	if (hpa0)
 		*hpa0 = pfn0 &lt;&lt; PAGE_SHIFT;
 
<span class="p_chunk">@@ -401,9 +415,9 @@</span> <span class="p_context"> int kvm_mips_handle_mapped_seg_tlb_fault(struct kvm_vcpu *vcpu,</span>
 
 	/* Get attributes from the Guest TLB */
 	entrylo0 = mips3_paddr_to_tlbpfn(pfn0 &lt;&lt; PAGE_SHIFT) | (0x3 &lt;&lt; 3) |
<span class="p_del">-		   (tlb-&gt;tlb_lo0 &amp; MIPS3_PG_D) | (tlb-&gt;tlb_lo0 &amp; MIPS3_PG_V);</span>
<span class="p_add">+		   (tlb_lo[0] &amp; MIPS3_PG_D) | (tlb_lo[0] &amp; MIPS3_PG_V);</span>
 	entrylo1 = mips3_paddr_to_tlbpfn(pfn1 &lt;&lt; PAGE_SHIFT) | (0x3 &lt;&lt; 3) |
<span class="p_del">-		   (tlb-&gt;tlb_lo1 &amp; MIPS3_PG_D) | (tlb-&gt;tlb_lo1 &amp; MIPS3_PG_V);</span>
<span class="p_add">+		   (tlb_lo[1] &amp; MIPS3_PG_D) | (tlb_lo[1] &amp; MIPS3_PG_V);</span>
 
 	kvm_debug(&quot;@ %#lx tlb_lo0: 0x%08lx tlb_lo1: 0x%08lx\n&quot;, vcpu-&gt;arch.pc,
 		  tlb-&gt;tlb_lo0, tlb-&gt;tlb_lo1);
<span class="p_chunk">@@ -776,10 +790,16 @@</span> <span class="p_context"> uint32_t kvm_get_inst(uint32_t *opc, struct kvm_vcpu *vcpu)</span>
 				local_irq_restore(flags);
 				return KVM_INVALID_INST;
 			}
<span class="p_del">-			kvm_mips_handle_mapped_seg_tlb_fault(vcpu,</span>
<span class="p_del">-							     &amp;vcpu-&gt;arch.</span>
<span class="p_del">-							     guest_tlb[index],</span>
<span class="p_del">-							     NULL, NULL);</span>
<span class="p_add">+			if (kvm_mips_handle_mapped_seg_tlb_fault(vcpu,</span>
<span class="p_add">+						&amp;vcpu-&gt;arch.guest_tlb[index],</span>
<span class="p_add">+						NULL, NULL)) {</span>
<span class="p_add">+				kvm_err(&quot;%s: handling mapped seg tlb fault failed for %p, index: %u, vcpu: %p, ASID: %#lx\n&quot;,</span>
<span class="p_add">+					__func__, opc, index, vcpu,</span>
<span class="p_add">+					read_c0_entryhi());</span>
<span class="p_add">+				kvm_mips_dump_guest_tlbs(vcpu);</span>
<span class="p_add">+				local_irq_restore(flags);</span>
<span class="p_add">+				return KVM_INVALID_INST;</span>
<span class="p_add">+			}</span>
 			inst = *(opc);
 		}
 		local_irq_restore(flags);
<span class="p_header">diff --git a/arch/mips/loongson64/loongson-3/hpet.c b/arch/mips/loongson64/loongson-3/hpet.c</span>
<span class="p_header">index 249039af66c4..4788bea62a6a 100644</span>
<span class="p_header">--- a/arch/mips/loongson64/loongson-3/hpet.c</span>
<span class="p_header">+++ b/arch/mips/loongson64/loongson-3/hpet.c</span>
<span class="p_chunk">@@ -13,8 +13,8 @@</span> <span class="p_context"></span>
 #define SMBUS_PCI_REG64		0x64
 #define SMBUS_PCI_REGB4		0xb4
 
<span class="p_del">-#define HPET_MIN_CYCLES		64</span>
<span class="p_del">-#define HPET_MIN_PROG_DELTA	(HPET_MIN_CYCLES + (HPET_MIN_CYCLES &gt;&gt; 1))</span>
<span class="p_add">+#define HPET_MIN_CYCLES		16</span>
<span class="p_add">+#define HPET_MIN_PROG_DELTA	(HPET_MIN_CYCLES * 12)</span>
 
 static DEFINE_SPINLOCK(hpet_lock);
 DEFINE_PER_CPU(struct clock_event_device, hpet_clockevent_device);
<span class="p_chunk">@@ -157,14 +157,14 @@</span> <span class="p_context"> static int hpet_tick_resume(struct clock_event_device *evt)</span>
 static int hpet_next_event(unsigned long delta,
 		struct clock_event_device *evt)
 {
<span class="p_del">-	unsigned int cnt;</span>
<span class="p_del">-	int res;</span>
<span class="p_add">+	u32 cnt;</span>
<span class="p_add">+	s32 res;</span>
 
 	cnt = hpet_read(HPET_COUNTER);
<span class="p_del">-	cnt += delta;</span>
<span class="p_add">+	cnt += (u32) delta;</span>
 	hpet_write(HPET_T0_CMP, cnt);
 
<span class="p_del">-	res = (int)(cnt - hpet_read(HPET_COUNTER));</span>
<span class="p_add">+	res = (s32)(cnt - hpet_read(HPET_COUNTER));</span>
 
 	return res &lt; HPET_MIN_CYCLES ? -ETIME : 0;
 }
<span class="p_chunk">@@ -230,7 +230,7 @@</span> <span class="p_context"> void __init setup_hpet_timer(void)</span>
 
 	cd = &amp;per_cpu(hpet_clockevent_device, cpu);
 	cd-&gt;name = &quot;hpet&quot;;
<span class="p_del">-	cd-&gt;rating = 320;</span>
<span class="p_add">+	cd-&gt;rating = 100;</span>
 	cd-&gt;features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;
 	cd-&gt;set_state_shutdown = hpet_set_state_shutdown;
 	cd-&gt;set_state_periodic = hpet_set_state_periodic;
<span class="p_header">diff --git a/arch/mips/mm/uasm-mips.c b/arch/mips/mm/uasm-mips.c</span>
<span class="p_header">index 9c2220a45189..45e3b8799ed0 100644</span>
<span class="p_header">--- a/arch/mips/mm/uasm-mips.c</span>
<span class="p_header">+++ b/arch/mips/mm/uasm-mips.c</span>
<span class="p_chunk">@@ -65,7 +65,7 @@</span> <span class="p_context"> static struct insn insn_table[] = {</span>
 #ifndef CONFIG_CPU_MIPSR6
 	{ insn_cache,  M(cache_op, 0, 0, 0, 0, 0),  RS | RT | SIMM },
 #else
<span class="p_del">-	{ insn_cache,  M6(cache_op, 0, 0, 0, cache6_op),  RS | RT | SIMM9 },</span>
<span class="p_add">+	{ insn_cache,  M6(spec3_op, 0, 0, 0, cache6_op),  RS | RT | SIMM9 },</span>
 #endif
 	{ insn_daddiu, M(daddiu_op, 0, 0, 0, 0, 0), RS | RT | SIMM },
 	{ insn_daddu, M(spec_op, 0, 0, 0, 0, daddu_op), RS | RT | RD },
<span class="p_header">diff --git a/arch/powerpc/kernel/tm.S b/arch/powerpc/kernel/tm.S</span>
<span class="p_header">index b7019b559ddb..298afcf3bf2a 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/tm.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/tm.S</span>
<span class="p_chunk">@@ -338,8 +338,6 @@</span> <span class="p_context"> _GLOBAL(__tm_recheckpoint)</span>
 	 */
 	subi	r7, r7, STACK_FRAME_OVERHEAD
 
<span class="p_del">-	SET_SCRATCH0(r1)</span>
<span class="p_del">-</span>
 	mfmsr	r6
 	/* R4 = original MSR to indicate whether thread used FP/Vector etc. */
 
<span class="p_chunk">@@ -468,6 +466,7 @@</span> <span class="p_context"> restore_gprs:</span>
 	 * until we turn MSR RI back on.
 	 */
 
<span class="p_add">+	SET_SCRATCH0(r1)</span>
 	ld	r5, -8(r1)
 	ld	r1, -16(r1)
 
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv_rmhandlers.S b/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_header">index e571ad277398..38e108eaeafe 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_chunk">@@ -655,112 +655,8 @@</span> <span class="p_context"> END_FTR_SECTION_IFCLR(CPU_FTR_ARCH_207S)</span>
 
 #ifdef CONFIG_PPC_TRANSACTIONAL_MEM
 BEGIN_FTR_SECTION
<span class="p_del">-	b	skip_tm</span>
<span class="p_del">-END_FTR_SECTION_IFCLR(CPU_FTR_TM)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Turn on TM/FP/VSX/VMX so we can restore them. */</span>
<span class="p_del">-	mfmsr	r5</span>
<span class="p_del">-	li	r6, MSR_TM &gt;&gt; 32</span>
<span class="p_del">-	sldi	r6, r6, 32</span>
<span class="p_del">-	or	r5, r5, r6</span>
<span class="p_del">-	ori	r5, r5, MSR_FP</span>
<span class="p_del">-	oris	r5, r5, (MSR_VEC | MSR_VSX)@h</span>
<span class="p_del">-	mtmsrd	r5</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The user may change these outside of a transaction, so they must</span>
<span class="p_del">-	 * always be context switched.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ld	r5, VCPU_TFHAR(r4)</span>
<span class="p_del">-	ld	r6, VCPU_TFIAR(r4)</span>
<span class="p_del">-	ld	r7, VCPU_TEXASR(r4)</span>
<span class="p_del">-	mtspr	SPRN_TFHAR, r5</span>
<span class="p_del">-	mtspr	SPRN_TFIAR, r6</span>
<span class="p_del">-	mtspr	SPRN_TEXASR, r7</span>
<span class="p_del">-</span>
<span class="p_del">-	ld	r5, VCPU_MSR(r4)</span>
<span class="p_del">-	rldicl. r5, r5, 64 - MSR_TS_S_LG, 62</span>
<span class="p_del">-	beq	skip_tm	/* TM not active in guest */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Make sure the failure summary is set, otherwise we&#39;ll program check</span>
<span class="p_del">-	 * when we trechkpt.  It&#39;s possible that this might have been not set</span>
<span class="p_del">-	 * on a kvmppc_set_one_reg() call but we shouldn&#39;t let this crash the</span>
<span class="p_del">-	 * host.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	oris	r7, r7, (TEXASR_FS)@h</span>
<span class="p_del">-	mtspr	SPRN_TEXASR, r7</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We need to load up the checkpointed state for the guest.</span>
<span class="p_del">-	 * We need to do this early as it will blow away any GPRs, VSRs and</span>
<span class="p_del">-	 * some SPRs.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-</span>
<span class="p_del">-	mr	r31, r4</span>
<span class="p_del">-	addi	r3, r31, VCPU_FPRS_TM</span>
<span class="p_del">-	bl	load_fp_state</span>
<span class="p_del">-	addi	r3, r31, VCPU_VRS_TM</span>
<span class="p_del">-	bl	load_vr_state</span>
<span class="p_del">-	mr	r4, r31</span>
<span class="p_del">-	lwz	r7, VCPU_VRSAVE_TM(r4)</span>
<span class="p_del">-	mtspr	SPRN_VRSAVE, r7</span>
<span class="p_del">-</span>
<span class="p_del">-	ld	r5, VCPU_LR_TM(r4)</span>
<span class="p_del">-	lwz	r6, VCPU_CR_TM(r4)</span>
<span class="p_del">-	ld	r7, VCPU_CTR_TM(r4)</span>
<span class="p_del">-	ld	r8, VCPU_AMR_TM(r4)</span>
<span class="p_del">-	ld	r9, VCPU_TAR_TM(r4)</span>
<span class="p_del">-	mtlr	r5</span>
<span class="p_del">-	mtcr	r6</span>
<span class="p_del">-	mtctr	r7</span>
<span class="p_del">-	mtspr	SPRN_AMR, r8</span>
<span class="p_del">-	mtspr	SPRN_TAR, r9</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Load up PPR and DSCR values but don&#39;t put them in the actual SPRs</span>
<span class="p_del">-	 * till the last moment to avoid running with userspace PPR and DSCR for</span>
<span class="p_del">-	 * too long.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ld	r29, VCPU_DSCR_TM(r4)</span>
<span class="p_del">-	ld	r30, VCPU_PPR_TM(r4)</span>
<span class="p_del">-</span>
<span class="p_del">-	std	r2, PACATMSCRATCH(r13) /* Save TOC */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Clear the MSR RI since r1, r13 are all going to be foobar. */</span>
<span class="p_del">-	li	r5, 0</span>
<span class="p_del">-	mtmsrd	r5, 1</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Load GPRs r0-r28 */</span>
<span class="p_del">-	reg = 0</span>
<span class="p_del">-	.rept	29</span>
<span class="p_del">-	ld	reg, VCPU_GPRS_TM(reg)(r31)</span>
<span class="p_del">-	reg = reg + 1</span>
<span class="p_del">-	.endr</span>
<span class="p_del">-</span>
<span class="p_del">-	mtspr	SPRN_DSCR, r29</span>
<span class="p_del">-	mtspr	SPRN_PPR, r30</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Load final GPRs */</span>
<span class="p_del">-	ld	29, VCPU_GPRS_TM(29)(r31)</span>
<span class="p_del">-	ld	30, VCPU_GPRS_TM(30)(r31)</span>
<span class="p_del">-	ld	31, VCPU_GPRS_TM(31)(r31)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* TM checkpointed state is now setup.  All GPRs are now volatile. */</span>
<span class="p_del">-	TRECHKPT</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Now let&#39;s get back the state we need. */</span>
<span class="p_del">-	HMT_MEDIUM</span>
<span class="p_del">-	GET_PACA(r13)</span>
<span class="p_del">-	ld	r29, HSTATE_DSCR(r13)</span>
<span class="p_del">-	mtspr	SPRN_DSCR, r29</span>
<span class="p_del">-	ld	r4, HSTATE_KVM_VCPU(r13)</span>
<span class="p_del">-	ld	r1, HSTATE_HOST_R1(r13)</span>
<span class="p_del">-	ld	r2, PACATMSCRATCH(r13)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Set the MSR RI since we have our registers back. */</span>
<span class="p_del">-	li	r5, MSR_RI</span>
<span class="p_del">-	mtmsrd	r5, 1</span>
<span class="p_del">-skip_tm:</span>
<span class="p_add">+	bl	kvmppc_restore_tm</span>
<span class="p_add">+END_FTR_SECTION_IFSET(CPU_FTR_TM)</span>
 #endif
 
 	/* Load guest PMU registers */
<span class="p_chunk">@@ -841,12 +737,6 @@</span> <span class="p_context"> BEGIN_FTR_SECTION</span>
 	/* Skip next section on POWER7 */
 	b	8f
 END_FTR_SECTION_IFCLR(CPU_FTR_ARCH_207S)
<span class="p_del">-	/* Turn on TM so we can access TFHAR/TFIAR/TEXASR */</span>
<span class="p_del">-	mfmsr	r8</span>
<span class="p_del">-	li	r0, 1</span>
<span class="p_del">-	rldimi	r8, r0, MSR_TM_LG, 63-MSR_TM_LG</span>
<span class="p_del">-	mtmsrd	r8</span>
<span class="p_del">-</span>
 	/* Load up POWER8-specific registers */
 	ld	r5, VCPU_IAMR(r4)
 	lwz	r6, VCPU_PSPB(r4)
<span class="p_chunk">@@ -1436,106 +1326,8 @@</span> <span class="p_context"> END_FTR_SECTION_IFCLR(CPU_FTR_ARCH_207S)</span>
 
 #ifdef CONFIG_PPC_TRANSACTIONAL_MEM
 BEGIN_FTR_SECTION
<span class="p_del">-	b	2f</span>
<span class="p_del">-END_FTR_SECTION_IFCLR(CPU_FTR_TM)</span>
<span class="p_del">-	/* Turn on TM. */</span>
<span class="p_del">-	mfmsr	r8</span>
<span class="p_del">-	li	r0, 1</span>
<span class="p_del">-	rldimi	r8, r0, MSR_TM_LG, 63-MSR_TM_LG</span>
<span class="p_del">-	mtmsrd	r8</span>
<span class="p_del">-</span>
<span class="p_del">-	ld	r5, VCPU_MSR(r9)</span>
<span class="p_del">-	rldicl. r5, r5, 64 - MSR_TS_S_LG, 62</span>
<span class="p_del">-	beq	1f	/* TM not active in guest. */</span>
<span class="p_del">-</span>
<span class="p_del">-	li	r3, TM_CAUSE_KVM_RESCHED</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Clear the MSR RI since r1, r13 are all going to be foobar. */</span>
<span class="p_del">-	li	r5, 0</span>
<span class="p_del">-	mtmsrd	r5, 1</span>
<span class="p_del">-</span>
<span class="p_del">-	/* All GPRs are volatile at this point. */</span>
<span class="p_del">-	TRECLAIM(R3)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Temporarily store r13 and r9 so we have some regs to play with */</span>
<span class="p_del">-	SET_SCRATCH0(r13)</span>
<span class="p_del">-	GET_PACA(r13)</span>
<span class="p_del">-	std	r9, PACATMSCRATCH(r13)</span>
<span class="p_del">-	ld	r9, HSTATE_KVM_VCPU(r13)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Get a few more GPRs free. */</span>
<span class="p_del">-	std	r29, VCPU_GPRS_TM(29)(r9)</span>
<span class="p_del">-	std	r30, VCPU_GPRS_TM(30)(r9)</span>
<span class="p_del">-	std	r31, VCPU_GPRS_TM(31)(r9)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Save away PPR and DSCR soon so don&#39;t run with user values. */</span>
<span class="p_del">-	mfspr	r31, SPRN_PPR</span>
<span class="p_del">-	HMT_MEDIUM</span>
<span class="p_del">-	mfspr	r30, SPRN_DSCR</span>
<span class="p_del">-	ld	r29, HSTATE_DSCR(r13)</span>
<span class="p_del">-	mtspr	SPRN_DSCR, r29</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Save all but r9, r13 &amp; r29-r31 */</span>
<span class="p_del">-	reg = 0</span>
<span class="p_del">-	.rept	29</span>
<span class="p_del">-	.if (reg != 9) &amp;&amp; (reg != 13)</span>
<span class="p_del">-	std	reg, VCPU_GPRS_TM(reg)(r9)</span>
<span class="p_del">-	.endif</span>
<span class="p_del">-	reg = reg + 1</span>
<span class="p_del">-	.endr</span>
<span class="p_del">-	/* ... now save r13 */</span>
<span class="p_del">-	GET_SCRATCH0(r4)</span>
<span class="p_del">-	std	r4, VCPU_GPRS_TM(13)(r9)</span>
<span class="p_del">-	/* ... and save r9 */</span>
<span class="p_del">-	ld	r4, PACATMSCRATCH(r13)</span>
<span class="p_del">-	std	r4, VCPU_GPRS_TM(9)(r9)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Reload stack pointer and TOC. */</span>
<span class="p_del">-	ld	r1, HSTATE_HOST_R1(r13)</span>
<span class="p_del">-	ld	r2, PACATOC(r13)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Set MSR RI now we have r1 and r13 back. */</span>
<span class="p_del">-	li	r5, MSR_RI</span>
<span class="p_del">-	mtmsrd	r5, 1</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Save away checkpinted SPRs. */</span>
<span class="p_del">-	std	r31, VCPU_PPR_TM(r9)</span>
<span class="p_del">-	std	r30, VCPU_DSCR_TM(r9)</span>
<span class="p_del">-	mflr	r5</span>
<span class="p_del">-	mfcr	r6</span>
<span class="p_del">-	mfctr	r7</span>
<span class="p_del">-	mfspr	r8, SPRN_AMR</span>
<span class="p_del">-	mfspr	r10, SPRN_TAR</span>
<span class="p_del">-	std	r5, VCPU_LR_TM(r9)</span>
<span class="p_del">-	stw	r6, VCPU_CR_TM(r9)</span>
<span class="p_del">-	std	r7, VCPU_CTR_TM(r9)</span>
<span class="p_del">-	std	r8, VCPU_AMR_TM(r9)</span>
<span class="p_del">-	std	r10, VCPU_TAR_TM(r9)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Restore r12 as trap number. */</span>
<span class="p_del">-	lwz	r12, VCPU_TRAP(r9)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Save FP/VSX. */</span>
<span class="p_del">-	addi	r3, r9, VCPU_FPRS_TM</span>
<span class="p_del">-	bl	store_fp_state</span>
<span class="p_del">-	addi	r3, r9, VCPU_VRS_TM</span>
<span class="p_del">-	bl	store_vr_state</span>
<span class="p_del">-	mfspr	r6, SPRN_VRSAVE</span>
<span class="p_del">-	stw	r6, VCPU_VRSAVE_TM(r9)</span>
<span class="p_del">-1:</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We need to save these SPRs after the treclaim so that the software</span>
<span class="p_del">-	 * error code is recorded correctly in the TEXASR.  Also the user may</span>
<span class="p_del">-	 * change these outside of a transaction, so they must always be</span>
<span class="p_del">-	 * context switched.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	mfspr	r5, SPRN_TFHAR</span>
<span class="p_del">-	mfspr	r6, SPRN_TFIAR</span>
<span class="p_del">-	mfspr	r7, SPRN_TEXASR</span>
<span class="p_del">-	std	r5, VCPU_TFHAR(r9)</span>
<span class="p_del">-	std	r6, VCPU_TFIAR(r9)</span>
<span class="p_del">-	std	r7, VCPU_TEXASR(r9)</span>
<span class="p_del">-2:</span>
<span class="p_add">+	bl	kvmppc_save_tm</span>
<span class="p_add">+END_FTR_SECTION_IFSET(CPU_FTR_TM)</span>
 #endif
 
 	/* Increment yield count if they have a VPA */
<span class="p_chunk">@@ -2245,6 +2037,13 @@</span> <span class="p_context"> _GLOBAL(kvmppc_h_cede)		/* r3 = vcpu pointer, r11 = msr, r13 = paca */</span>
 	/* save FP state */
 	bl	kvmppc_save_fp
 
<span class="p_add">+#ifdef CONFIG_PPC_TRANSACTIONAL_MEM</span>
<span class="p_add">+BEGIN_FTR_SECTION</span>
<span class="p_add">+	ld	r9, HSTATE_KVM_VCPU(r13)</span>
<span class="p_add">+	bl	kvmppc_save_tm</span>
<span class="p_add">+END_FTR_SECTION_IFSET(CPU_FTR_TM)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	/*
 	 * Set DEC to the smaller of DEC and HDEC, so that we wake
 	 * no later than the end of our timeslice (HDEC interrupts
<span class="p_chunk">@@ -2321,6 +2120,12 @@</span> <span class="p_context"> kvm_end_cede:</span>
 	bl	kvmhv_accumulate_time
 #endif
 
<span class="p_add">+#ifdef CONFIG_PPC_TRANSACTIONAL_MEM</span>
<span class="p_add">+BEGIN_FTR_SECTION</span>
<span class="p_add">+	bl	kvmppc_restore_tm</span>
<span class="p_add">+END_FTR_SECTION_IFSET(CPU_FTR_TM)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	/* load up FP state */
 	bl	kvmppc_load_fp
 
<span class="p_chunk">@@ -2631,6 +2436,239 @@</span> <span class="p_context"> END_FTR_SECTION_IFSET(CPU_FTR_ALTIVEC)</span>
 	mr	r4,r31
 	blr
 
<span class="p_add">+#ifdef CONFIG_PPC_TRANSACTIONAL_MEM</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Save transactional state and TM-related registers.</span>
<span class="p_add">+ * Called with r9 pointing to the vcpu struct.</span>
<span class="p_add">+ * This can modify all checkpointed registers, but</span>
<span class="p_add">+ * restores r1, r2 and r9 (vcpu pointer) before exit.</span>
<span class="p_add">+ */</span>
<span class="p_add">+kvmppc_save_tm:</span>
<span class="p_add">+	mflr	r0</span>
<span class="p_add">+	std	r0, PPC_LR_STKOFF(r1)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Turn on TM. */</span>
<span class="p_add">+	mfmsr	r8</span>
<span class="p_add">+	li	r0, 1</span>
<span class="p_add">+	rldimi	r8, r0, MSR_TM_LG, 63-MSR_TM_LG</span>
<span class="p_add">+	mtmsrd	r8</span>
<span class="p_add">+</span>
<span class="p_add">+	ld	r5, VCPU_MSR(r9)</span>
<span class="p_add">+	rldicl. r5, r5, 64 - MSR_TS_S_LG, 62</span>
<span class="p_add">+	beq	1f	/* TM not active in guest. */</span>
<span class="p_add">+</span>
<span class="p_add">+	std	r1, HSTATE_HOST_R1(r13)</span>
<span class="p_add">+	li	r3, TM_CAUSE_KVM_RESCHED</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Clear the MSR RI since r1, r13 are all going to be foobar. */</span>
<span class="p_add">+	li	r5, 0</span>
<span class="p_add">+	mtmsrd	r5, 1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* All GPRs are volatile at this point. */</span>
<span class="p_add">+	TRECLAIM(R3)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Temporarily store r13 and r9 so we have some regs to play with */</span>
<span class="p_add">+	SET_SCRATCH0(r13)</span>
<span class="p_add">+	GET_PACA(r13)</span>
<span class="p_add">+	std	r9, PACATMSCRATCH(r13)</span>
<span class="p_add">+	ld	r9, HSTATE_KVM_VCPU(r13)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Get a few more GPRs free. */</span>
<span class="p_add">+	std	r29, VCPU_GPRS_TM(29)(r9)</span>
<span class="p_add">+	std	r30, VCPU_GPRS_TM(30)(r9)</span>
<span class="p_add">+	std	r31, VCPU_GPRS_TM(31)(r9)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save away PPR and DSCR soon so don&#39;t run with user values. */</span>
<span class="p_add">+	mfspr	r31, SPRN_PPR</span>
<span class="p_add">+	HMT_MEDIUM</span>
<span class="p_add">+	mfspr	r30, SPRN_DSCR</span>
<span class="p_add">+	ld	r29, HSTATE_DSCR(r13)</span>
<span class="p_add">+	mtspr	SPRN_DSCR, r29</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save all but r9, r13 &amp; r29-r31 */</span>
<span class="p_add">+	reg = 0</span>
<span class="p_add">+	.rept	29</span>
<span class="p_add">+	.if (reg != 9) &amp;&amp; (reg != 13)</span>
<span class="p_add">+	std	reg, VCPU_GPRS_TM(reg)(r9)</span>
<span class="p_add">+	.endif</span>
<span class="p_add">+	reg = reg + 1</span>
<span class="p_add">+	.endr</span>
<span class="p_add">+	/* ... now save r13 */</span>
<span class="p_add">+	GET_SCRATCH0(r4)</span>
<span class="p_add">+	std	r4, VCPU_GPRS_TM(13)(r9)</span>
<span class="p_add">+	/* ... and save r9 */</span>
<span class="p_add">+	ld	r4, PACATMSCRATCH(r13)</span>
<span class="p_add">+	std	r4, VCPU_GPRS_TM(9)(r9)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Reload stack pointer and TOC. */</span>
<span class="p_add">+	ld	r1, HSTATE_HOST_R1(r13)</span>
<span class="p_add">+	ld	r2, PACATOC(r13)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set MSR RI now we have r1 and r13 back. */</span>
<span class="p_add">+	li	r5, MSR_RI</span>
<span class="p_add">+	mtmsrd	r5, 1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save away checkpinted SPRs. */</span>
<span class="p_add">+	std	r31, VCPU_PPR_TM(r9)</span>
<span class="p_add">+	std	r30, VCPU_DSCR_TM(r9)</span>
<span class="p_add">+	mflr	r5</span>
<span class="p_add">+	mfcr	r6</span>
<span class="p_add">+	mfctr	r7</span>
<span class="p_add">+	mfspr	r8, SPRN_AMR</span>
<span class="p_add">+	mfspr	r10, SPRN_TAR</span>
<span class="p_add">+	std	r5, VCPU_LR_TM(r9)</span>
<span class="p_add">+	stw	r6, VCPU_CR_TM(r9)</span>
<span class="p_add">+	std	r7, VCPU_CTR_TM(r9)</span>
<span class="p_add">+	std	r8, VCPU_AMR_TM(r9)</span>
<span class="p_add">+	std	r10, VCPU_TAR_TM(r9)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Restore r12 as trap number. */</span>
<span class="p_add">+	lwz	r12, VCPU_TRAP(r9)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save FP/VSX. */</span>
<span class="p_add">+	addi	r3, r9, VCPU_FPRS_TM</span>
<span class="p_add">+	bl	store_fp_state</span>
<span class="p_add">+	addi	r3, r9, VCPU_VRS_TM</span>
<span class="p_add">+	bl	store_vr_state</span>
<span class="p_add">+	mfspr	r6, SPRN_VRSAVE</span>
<span class="p_add">+	stw	r6, VCPU_VRSAVE_TM(r9)</span>
<span class="p_add">+1:</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to save these SPRs after the treclaim so that the software</span>
<span class="p_add">+	 * error code is recorded correctly in the TEXASR.  Also the user may</span>
<span class="p_add">+	 * change these outside of a transaction, so they must always be</span>
<span class="p_add">+	 * context switched.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mfspr	r5, SPRN_TFHAR</span>
<span class="p_add">+	mfspr	r6, SPRN_TFIAR</span>
<span class="p_add">+	mfspr	r7, SPRN_TEXASR</span>
<span class="p_add">+	std	r5, VCPU_TFHAR(r9)</span>
<span class="p_add">+	std	r6, VCPU_TFIAR(r9)</span>
<span class="p_add">+	std	r7, VCPU_TEXASR(r9)</span>
<span class="p_add">+</span>
<span class="p_add">+	ld	r0, PPC_LR_STKOFF(r1)</span>
<span class="p_add">+	mtlr	r0</span>
<span class="p_add">+	blr</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Restore transactional state and TM-related registers.</span>
<span class="p_add">+ * Called with r4 pointing to the vcpu struct.</span>
<span class="p_add">+ * This potentially modifies all checkpointed registers.</span>
<span class="p_add">+ * It restores r1, r2, r4 from the PACA.</span>
<span class="p_add">+ */</span>
<span class="p_add">+kvmppc_restore_tm:</span>
<span class="p_add">+	mflr	r0</span>
<span class="p_add">+	std	r0, PPC_LR_STKOFF(r1)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Turn on TM/FP/VSX/VMX so we can restore them. */</span>
<span class="p_add">+	mfmsr	r5</span>
<span class="p_add">+	li	r6, MSR_TM &gt;&gt; 32</span>
<span class="p_add">+	sldi	r6, r6, 32</span>
<span class="p_add">+	or	r5, r5, r6</span>
<span class="p_add">+	ori	r5, r5, MSR_FP</span>
<span class="p_add">+	oris	r5, r5, (MSR_VEC | MSR_VSX)@h</span>
<span class="p_add">+	mtmsrd	r5</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The user may change these outside of a transaction, so they must</span>
<span class="p_add">+	 * always be context switched.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ld	r5, VCPU_TFHAR(r4)</span>
<span class="p_add">+	ld	r6, VCPU_TFIAR(r4)</span>
<span class="p_add">+	ld	r7, VCPU_TEXASR(r4)</span>
<span class="p_add">+	mtspr	SPRN_TFHAR, r5</span>
<span class="p_add">+	mtspr	SPRN_TFIAR, r6</span>
<span class="p_add">+	mtspr	SPRN_TEXASR, r7</span>
<span class="p_add">+</span>
<span class="p_add">+	ld	r5, VCPU_MSR(r4)</span>
<span class="p_add">+	rldicl. r5, r5, 64 - MSR_TS_S_LG, 62</span>
<span class="p_add">+	beqlr		/* TM not active in guest */</span>
<span class="p_add">+	std	r1, HSTATE_HOST_R1(r13)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Make sure the failure summary is set, otherwise we&#39;ll program check</span>
<span class="p_add">+	 * when we trechkpt.  It&#39;s possible that this might have been not set</span>
<span class="p_add">+	 * on a kvmppc_set_one_reg() call but we shouldn&#39;t let this crash the</span>
<span class="p_add">+	 * host.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	oris	r7, r7, (TEXASR_FS)@h</span>
<span class="p_add">+	mtspr	SPRN_TEXASR, r7</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to load up the checkpointed state for the guest.</span>
<span class="p_add">+	 * We need to do this early as it will blow away any GPRs, VSRs and</span>
<span class="p_add">+	 * some SPRs.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	mr	r31, r4</span>
<span class="p_add">+	addi	r3, r31, VCPU_FPRS_TM</span>
<span class="p_add">+	bl	load_fp_state</span>
<span class="p_add">+	addi	r3, r31, VCPU_VRS_TM</span>
<span class="p_add">+	bl	load_vr_state</span>
<span class="p_add">+	mr	r4, r31</span>
<span class="p_add">+	lwz	r7, VCPU_VRSAVE_TM(r4)</span>
<span class="p_add">+	mtspr	SPRN_VRSAVE, r7</span>
<span class="p_add">+</span>
<span class="p_add">+	ld	r5, VCPU_LR_TM(r4)</span>
<span class="p_add">+	lwz	r6, VCPU_CR_TM(r4)</span>
<span class="p_add">+	ld	r7, VCPU_CTR_TM(r4)</span>
<span class="p_add">+	ld	r8, VCPU_AMR_TM(r4)</span>
<span class="p_add">+	ld	r9, VCPU_TAR_TM(r4)</span>
<span class="p_add">+	mtlr	r5</span>
<span class="p_add">+	mtcr	r6</span>
<span class="p_add">+	mtctr	r7</span>
<span class="p_add">+	mtspr	SPRN_AMR, r8</span>
<span class="p_add">+	mtspr	SPRN_TAR, r9</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Load up PPR and DSCR values but don&#39;t put them in the actual SPRs</span>
<span class="p_add">+	 * till the last moment to avoid running with userspace PPR and DSCR for</span>
<span class="p_add">+	 * too long.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ld	r29, VCPU_DSCR_TM(r4)</span>
<span class="p_add">+	ld	r30, VCPU_PPR_TM(r4)</span>
<span class="p_add">+</span>
<span class="p_add">+	std	r2, PACATMSCRATCH(r13) /* Save TOC */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Clear the MSR RI since r1, r13 are all going to be foobar. */</span>
<span class="p_add">+	li	r5, 0</span>
<span class="p_add">+	mtmsrd	r5, 1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Load GPRs r0-r28 */</span>
<span class="p_add">+	reg = 0</span>
<span class="p_add">+	.rept	29</span>
<span class="p_add">+	ld	reg, VCPU_GPRS_TM(reg)(r31)</span>
<span class="p_add">+	reg = reg + 1</span>
<span class="p_add">+	.endr</span>
<span class="p_add">+</span>
<span class="p_add">+	mtspr	SPRN_DSCR, r29</span>
<span class="p_add">+	mtspr	SPRN_PPR, r30</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Load final GPRs */</span>
<span class="p_add">+	ld	29, VCPU_GPRS_TM(29)(r31)</span>
<span class="p_add">+	ld	30, VCPU_GPRS_TM(30)(r31)</span>
<span class="p_add">+	ld	31, VCPU_GPRS_TM(31)(r31)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* TM checkpointed state is now setup.  All GPRs are now volatile. */</span>
<span class="p_add">+	TRECHKPT</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Now let&#39;s get back the state we need. */</span>
<span class="p_add">+	HMT_MEDIUM</span>
<span class="p_add">+	GET_PACA(r13)</span>
<span class="p_add">+	ld	r29, HSTATE_DSCR(r13)</span>
<span class="p_add">+	mtspr	SPRN_DSCR, r29</span>
<span class="p_add">+	ld	r4, HSTATE_KVM_VCPU(r13)</span>
<span class="p_add">+	ld	r1, HSTATE_HOST_R1(r13)</span>
<span class="p_add">+	ld	r2, PACATMSCRATCH(r13)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set the MSR RI since we have our registers back. */</span>
<span class="p_add">+	li	r5, MSR_RI</span>
<span class="p_add">+	mtmsrd	r5, 1</span>
<span class="p_add">+</span>
<span class="p_add">+	ld	r0, PPC_LR_STKOFF(r1)</span>
<span class="p_add">+	mtlr	r0</span>
<span class="p_add">+	blr</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /*
  * We come here if we get any exception or interrupt while we are
  * executing host real mode code while in guest MMU context.
<span class="p_header">diff --git a/arch/s390/include/asm/pgtable.h b/arch/s390/include/asm/pgtable.h</span>
<span class="p_header">index 18d2beb89340..42b968a85863 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -893,7 +893,7 @@</span> <span class="p_context"> void ptep_zap_key(struct mm_struct *mm, unsigned long addr, pte_t *ptep);</span>
 bool test_and_clear_guest_dirty(struct mm_struct *mm, unsigned long address);
 int set_guest_storage_key(struct mm_struct *mm, unsigned long addr,
 			  unsigned char key, bool nq);
<span class="p_del">-unsigned char get_guest_storage_key(struct mm_struct *mm, unsigned long addr);</span>
<span class="p_add">+unsigned long get_guest_storage_key(struct mm_struct *mm, unsigned long addr);</span>
 
 /*
  * Certain architectures need to do special things when PTEs
<span class="p_header">diff --git a/arch/s390/include/asm/tlbflush.h b/arch/s390/include/asm/tlbflush.h</span>
<span class="p_header">index a2e6ef32e054..0a2031618f7f 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -81,7 +81,8 @@</span> <span class="p_context"> static inline void __tlb_flush_full(struct mm_struct *mm)</span>
 }
 
 /*
<span class="p_del">- * Flush TLB entries for a specific ASCE on all CPUs.</span>
<span class="p_add">+ * Flush TLB entries for a specific ASCE on all CPUs. Should never be used</span>
<span class="p_add">+ * when more than one asce (e.g. gmap) ran on this mm.</span>
  */
 static inline void __tlb_flush_asce(struct mm_struct *mm, unsigned long asce)
 {
<span class="p_header">diff --git a/arch/s390/mm/gmap.c b/arch/s390/mm/gmap.c</span>
<span class="p_header">index cace818d86eb..313c3b8cf7dd 100644</span>
<span class="p_header">--- a/arch/s390/mm/gmap.c</span>
<span class="p_header">+++ b/arch/s390/mm/gmap.c</span>
<span class="p_chunk">@@ -85,7 +85,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(gmap_alloc);</span>
 static void gmap_flush_tlb(struct gmap *gmap)
 {
 	if (MACHINE_HAS_IDTE)
<span class="p_del">-		__tlb_flush_asce(gmap-&gt;mm, gmap-&gt;asce);</span>
<span class="p_add">+		__tlb_flush_idte(gmap-&gt;asce);</span>
 	else
 		__tlb_flush_global();
 }
<span class="p_chunk">@@ -124,7 +124,7 @@</span> <span class="p_context"> void gmap_free(struct gmap *gmap)</span>
 
 	/* Flush tlb. */
 	if (MACHINE_HAS_IDTE)
<span class="p_del">-		__tlb_flush_asce(gmap-&gt;mm, gmap-&gt;asce);</span>
<span class="p_add">+		__tlb_flush_idte(gmap-&gt;asce);</span>
 	else
 		__tlb_flush_global();
 
<span class="p_header">diff --git a/arch/s390/mm/pgtable.c b/arch/s390/mm/pgtable.c</span>
<span class="p_header">index 9f0ce0e6eeb4..ebb4f87112f4 100644</span>
<span class="p_header">--- a/arch/s390/mm/pgtable.c</span>
<span class="p_header">+++ b/arch/s390/mm/pgtable.c</span>
<span class="p_chunk">@@ -543,7 +543,7 @@</span> <span class="p_context"> int set_guest_storage_key(struct mm_struct *mm, unsigned long addr,</span>
 }
 EXPORT_SYMBOL(set_guest_storage_key);
 
<span class="p_del">-unsigned char get_guest_storage_key(struct mm_struct *mm, unsigned long addr)</span>
<span class="p_add">+unsigned long get_guest_storage_key(struct mm_struct *mm, unsigned long addr)</span>
 {
 	unsigned char key;
 	spinlock_t *ptl;
<span class="p_header">diff --git a/arch/um/os-Linux/signal.c b/arch/um/os-Linux/signal.c</span>
<span class="p_header">index 8acaf4e384c0..a86d7cc2c2d8 100644</span>
<span class="p_header">--- a/arch/um/os-Linux/signal.c</span>
<span class="p_header">+++ b/arch/um/os-Linux/signal.c</span>
<span class="p_chunk">@@ -15,6 +15,7 @@</span> <span class="p_context"></span>
 #include &lt;kern_util.h&gt;
 #include &lt;os.h&gt;
 #include &lt;sysdep/mcontext.h&gt;
<span class="p_add">+#include &lt;um_malloc.h&gt;</span>
 
 void (*sig_info[NSIG])(int, struct siginfo *, struct uml_pt_regs *) = {
 	[SIGTRAP]	= relay_signal,
<span class="p_chunk">@@ -32,7 +33,7 @@</span> <span class="p_context"> static void sig_handler_common(int sig, struct siginfo *si, mcontext_t *mc)</span>
 	struct uml_pt_regs *r;
 	int save_errno = errno;
 
<span class="p_del">-	r = malloc(sizeof(struct uml_pt_regs));</span>
<span class="p_add">+	r = uml_kmalloc(sizeof(struct uml_pt_regs), UM_GFP_ATOMIC);</span>
 	if (!r)
 		panic(&quot;out of memory&quot;);
 
<span class="p_chunk">@@ -91,7 +92,7 @@</span> <span class="p_context"> static void timer_real_alarm_handler(mcontext_t *mc)</span>
 {
 	struct uml_pt_regs *regs;
 
<span class="p_del">-	regs = malloc(sizeof(struct uml_pt_regs));</span>
<span class="p_add">+	regs = uml_kmalloc(sizeof(struct uml_pt_regs), UM_GFP_ATOMIC);</span>
 	if (!regs)
 		panic(&quot;out of memory&quot;);
 
<span class="p_header">diff --git a/arch/unicore32/include/asm/mmu_context.h b/arch/unicore32/include/asm/mmu_context.h</span>
<span class="p_header">index e35632ef23c7..62dfc644c908 100644</span>
<span class="p_header">--- a/arch/unicore32/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/unicore32/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -98,7 +98,7 @@</span> <span class="p_context"> static inline void arch_bprm_mm_init(struct mm_struct *mm,</span>
 }
 
 static inline bool arch_vma_access_permitted(struct vm_area_struct *vma,
<span class="p_del">-		bool write, bool foreign)</span>
<span class="p_add">+		bool write, bool execute, bool foreign)</span>
 {
 	/* by default, allow everything */
 	return true;
<span class="p_header">diff --git a/arch/x86/events/intel/uncore_snbep.c b/arch/x86/events/intel/uncore_snbep.c</span>
<span class="p_header">index 874e8bd64d1d..bd136ac140be 100644</span>
<span class="p_header">--- a/arch/x86/events/intel/uncore_snbep.c</span>
<span class="p_header">+++ b/arch/x86/events/intel/uncore_snbep.c</span>
<span class="p_chunk">@@ -2546,7 +2546,7 @@</span> <span class="p_context"> void hswep_uncore_cpu_init(void)</span>
 
 static struct intel_uncore_type hswep_uncore_ha = {
 	.name		= &quot;ha&quot;,
<span class="p_del">-	.num_counters   = 5,</span>
<span class="p_add">+	.num_counters   = 4,</span>
 	.num_boxes	= 2,
 	.perf_ctr_bits	= 48,
 	SNBEP_UNCORE_PCI_COMMON_INIT(),
<span class="p_chunk">@@ -2565,7 +2565,7 @@</span> <span class="p_context"> static struct uncore_event_desc hswep_uncore_imc_events[] = {</span>
 
 static struct intel_uncore_type hswep_uncore_imc = {
 	.name		= &quot;imc&quot;,
<span class="p_del">-	.num_counters   = 5,</span>
<span class="p_add">+	.num_counters   = 4,</span>
 	.num_boxes	= 8,
 	.perf_ctr_bits	= 48,
 	.fixed_ctr_bits	= 48,
<span class="p_chunk">@@ -2611,7 +2611,7 @@</span> <span class="p_context"> static struct intel_uncore_type hswep_uncore_irp = {</span>
 
 static struct intel_uncore_type hswep_uncore_qpi = {
 	.name			= &quot;qpi&quot;,
<span class="p_del">-	.num_counters		= 5,</span>
<span class="p_add">+	.num_counters		= 4,</span>
 	.num_boxes		= 3,
 	.perf_ctr_bits		= 48,
 	.perf_ctr		= SNBEP_PCI_PMON_CTR0,
<span class="p_chunk">@@ -2693,7 +2693,7 @@</span> <span class="p_context"> static struct event_constraint hswep_uncore_r3qpi_constraints[] = {</span>
 
 static struct intel_uncore_type hswep_uncore_r3qpi = {
 	.name		= &quot;r3qpi&quot;,
<span class="p_del">-	.num_counters   = 4,</span>
<span class="p_add">+	.num_counters   = 3,</span>
 	.num_boxes	= 3,
 	.perf_ctr_bits	= 44,
 	.constraints	= hswep_uncore_r3qpi_constraints,
<span class="p_chunk">@@ -2892,7 +2892,7 @@</span> <span class="p_context"> static struct intel_uncore_type bdx_uncore_ha = {</span>
 
 static struct intel_uncore_type bdx_uncore_imc = {
 	.name		= &quot;imc&quot;,
<span class="p_del">-	.num_counters   = 5,</span>
<span class="p_add">+	.num_counters   = 4,</span>
 	.num_boxes	= 8,
 	.perf_ctr_bits	= 48,
 	.fixed_ctr_bits	= 48,
<span class="p_header">diff --git a/arch/x86/kvm/mtrr.c b/arch/x86/kvm/mtrr.c</span>
<span class="p_header">index c146f3c262c3..0149ac59c273 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mtrr.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mtrr.c</span>
<span class="p_chunk">@@ -539,6 +539,7 @@</span> <span class="p_context"> static void mtrr_lookup_var_start(struct mtrr_iter *iter)</span>
 
 	iter-&gt;fixed = false;
 	iter-&gt;start_max = iter-&gt;start;
<span class="p_add">+	iter-&gt;range = NULL;</span>
 	iter-&gt;range = list_prepare_entry(iter-&gt;range, &amp;mtrr_state-&gt;head, node);
 
 	__mtrr_lookup_var_next(iter);
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 64a79f271276..8326d6891395 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -8224,6 +8224,7 @@</span> <span class="p_context"> static int vmx_handle_exit(struct kvm_vcpu *vcpu)</span>
 	if ((vectoring_info &amp; VECTORING_INFO_VALID_MASK) &amp;&amp;
 			(exit_reason != EXIT_REASON_EXCEPTION_NMI &amp;&amp;
 			exit_reason != EXIT_REASON_EPT_VIOLATION &amp;&amp;
<span class="p_add">+			exit_reason != EXIT_REASON_PML_FULL &amp;&amp;</span>
 			exit_reason != EXIT_REASON_TASK_SWITCH)) {
 		vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_INTERNAL_ERROR;
 		vcpu-&gt;run-&gt;internal.suberror = KVM_INTERNAL_ERROR_DELIVERY_EV;
<span class="p_chunk">@@ -8854,6 +8855,22 @@</span> <span class="p_context"> static void vmx_load_vmcs01(struct kvm_vcpu *vcpu)</span>
 	put_cpu();
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Ensure that the current vmcs of the logical processor is the</span>
<span class="p_add">+ * vmcs01 of the vcpu before calling free_nested().</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void vmx_free_vcpu_nested(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+       struct vcpu_vmx *vmx = to_vmx(vcpu);</span>
<span class="p_add">+       int r;</span>
<span class="p_add">+</span>
<span class="p_add">+       r = vcpu_load(vcpu);</span>
<span class="p_add">+       BUG_ON(r);</span>
<span class="p_add">+       vmx_load_vmcs01(vcpu);</span>
<span class="p_add">+       free_nested(vmx);</span>
<span class="p_add">+       vcpu_put(vcpu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void vmx_free_vcpu(struct kvm_vcpu *vcpu)
 {
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
<span class="p_chunk">@@ -8862,8 +8879,7 @@</span> <span class="p_context"> static void vmx_free_vcpu(struct kvm_vcpu *vcpu)</span>
 		vmx_destroy_pml_buffer(vmx);
 	free_vpid(vmx-&gt;vpid);
 	leave_guest_mode(vcpu);
<span class="p_del">-	vmx_load_vmcs01(vcpu);</span>
<span class="p_del">-	free_nested(vmx);</span>
<span class="p_add">+	vmx_free_vcpu_nested(vcpu);</span>
 	free_loaded_vmcs(vmx-&gt;loaded_vmcs);
 	kfree(vmx-&gt;guest_msrs);
 	kvm_vcpu_uninit(vcpu);
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 7da5dd2057a9..fea2c5717ec1 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -91,6 +91,7 @@</span> <span class="p_context"> static u64 __read_mostly efer_reserved_bits = ~((u64)EFER_SCE);</span>
 
 static void update_cr8_intercept(struct kvm_vcpu *vcpu);
 static void process_nmi(struct kvm_vcpu *vcpu);
<span class="p_add">+static void process_smi(struct kvm_vcpu *vcpu);</span>
 static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);
 
 struct kvm_x86_ops *kvm_x86_ops __read_mostly;
<span class="p_chunk">@@ -5296,13 +5297,8 @@</span> <span class="p_context"> static void kvm_smm_changed(struct kvm_vcpu *vcpu)</span>
 		/* This is a good place to trace that we are exiting SMM.  */
 		trace_kvm_enter_smm(vcpu-&gt;vcpu_id, vcpu-&gt;arch.smbase, false);
 
<span class="p_del">-		if (unlikely(vcpu-&gt;arch.smi_pending)) {</span>
<span class="p_del">-			kvm_make_request(KVM_REQ_SMI, vcpu);</span>
<span class="p_del">-			vcpu-&gt;arch.smi_pending = 0;</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			/* Process a latched INIT, if any.  */</span>
<span class="p_del">-			kvm_make_request(KVM_REQ_EVENT, vcpu);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		/* Process a latched INIT or SMI, if any.  */</span>
<span class="p_add">+		kvm_make_request(KVM_REQ_EVENT, vcpu);</span>
 	}
 
 	kvm_mmu_reset_context(vcpu);
<span class="p_chunk">@@ -6102,7 +6098,10 @@</span> <span class="p_context"> static int inject_pending_event(struct kvm_vcpu *vcpu, bool req_int_win)</span>
 	}
 
 	/* try to inject new event if pending */
<span class="p_del">-	if (vcpu-&gt;arch.nmi_pending &amp;&amp; kvm_x86_ops-&gt;nmi_allowed(vcpu)) {</span>
<span class="p_add">+	if (vcpu-&gt;arch.smi_pending &amp;&amp; !is_smm(vcpu)) {</span>
<span class="p_add">+		vcpu-&gt;arch.smi_pending = false;</span>
<span class="p_add">+		process_smi(vcpu);</span>
<span class="p_add">+	} else if (vcpu-&gt;arch.nmi_pending &amp;&amp; kvm_x86_ops-&gt;nmi_allowed(vcpu)) {</span>
 		--vcpu-&gt;arch.nmi_pending;
 		vcpu-&gt;arch.nmi_injected = true;
 		kvm_x86_ops-&gt;set_nmi(vcpu);
<span class="p_chunk">@@ -6312,11 +6311,6 @@</span> <span class="p_context"> static void process_smi(struct kvm_vcpu *vcpu)</span>
 	char buf[512];
 	u32 cr0;
 
<span class="p_del">-	if (is_smm(vcpu)) {</span>
<span class="p_del">-		vcpu-&gt;arch.smi_pending = true;</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	trace_kvm_enter_smm(vcpu-&gt;vcpu_id, vcpu-&gt;arch.smbase, true);
 	vcpu-&gt;arch.hflags |= HF_SMM_MASK;
 	memset(buf, 0, 512);
<span class="p_chunk">@@ -6379,6 +6373,12 @@</span> <span class="p_context"> static void process_smi(struct kvm_vcpu *vcpu)</span>
 	kvm_mmu_reset_context(vcpu);
 }
 
<span class="p_add">+static void process_smi_request(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	vcpu-&gt;arch.smi_pending = true;</span>
<span class="p_add">+	kvm_make_request(KVM_REQ_EVENT, vcpu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void kvm_make_scan_ioapic_request(struct kvm *kvm)
 {
 	kvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);
<span class="p_chunk">@@ -6500,7 +6500,7 @@</span> <span class="p_context"> static int vcpu_enter_guest(struct kvm_vcpu *vcpu)</span>
 		if (kvm_check_request(KVM_REQ_STEAL_UPDATE, vcpu))
 			record_steal_time(vcpu);
 		if (kvm_check_request(KVM_REQ_SMI, vcpu))
<span class="p_del">-			process_smi(vcpu);</span>
<span class="p_add">+			process_smi_request(vcpu);</span>
 		if (kvm_check_request(KVM_REQ_NMI, vcpu))
 			process_nmi(vcpu);
 		if (kvm_check_request(KVM_REQ_PMU, vcpu))
<span class="p_chunk">@@ -6573,8 +6573,18 @@</span> <span class="p_context"> static int vcpu_enter_guest(struct kvm_vcpu *vcpu)</span>
 
 		if (inject_pending_event(vcpu, req_int_win) != 0)
 			req_immediate_exit = true;
<span class="p_del">-		/* enable NMI/IRQ window open exits if needed */</span>
 		else {
<span class="p_add">+			/* Enable NMI/IRQ window open exits if needed.</span>
<span class="p_add">+			 *</span>
<span class="p_add">+			 * SMIs have two cases: 1) they can be nested, and</span>
<span class="p_add">+			 * then there is nothing to do here because RSM will</span>
<span class="p_add">+			 * cause a vmexit anyway; 2) or the SMI can be pending</span>
<span class="p_add">+			 * because inject_pending_event has completed the</span>
<span class="p_add">+			 * injection of an IRQ or NMI from the previous vmexit,</span>
<span class="p_add">+			 * and then we request an immediate exit to inject the SMI.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (vcpu-&gt;arch.smi_pending &amp;&amp; !is_smm(vcpu))</span>
<span class="p_add">+				req_immediate_exit = true;</span>
 			if (vcpu-&gt;arch.nmi_pending)
 				kvm_x86_ops-&gt;enable_nmi_window(vcpu);
 			if (kvm_cpu_has_injectable_intr(vcpu) || req_int_win)
<span class="p_chunk">@@ -6625,8 +6635,10 @@</span> <span class="p_context"> static int vcpu_enter_guest(struct kvm_vcpu *vcpu)</span>
 
 	kvm_load_guest_xcr0(vcpu);
 
<span class="p_del">-	if (req_immediate_exit)</span>
<span class="p_add">+	if (req_immediate_exit) {</span>
<span class="p_add">+		kvm_make_request(KVM_REQ_EVENT, vcpu);</span>
 		smp_send_reschedule(vcpu-&gt;cpu);
<span class="p_add">+	}</span>
 
 	trace_kvm_entry(vcpu-&gt;vcpu_id);
 	wait_lapic_expire(vcpu);
<span class="p_chunk">@@ -7427,6 +7439,7 @@</span> <span class="p_context"> void kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)</span>
 {
 	vcpu-&gt;arch.hflags = 0;
 
<span class="p_add">+	vcpu-&gt;arch.smi_pending = 0;</span>
 	atomic_set(&amp;vcpu-&gt;arch.nmi_queued, 0);
 	vcpu-&gt;arch.nmi_pending = 0;
 	vcpu-&gt;arch.nmi_injected = false;
<span class="p_header">diff --git a/arch/x86/pci/intel_mid_pci.c b/arch/x86/pci/intel_mid_pci.c</span>
<span class="p_header">index 8b93e634af84..ae97f24a4371 100644</span>
<span class="p_header">--- a/arch/x86/pci/intel_mid_pci.c</span>
<span class="p_header">+++ b/arch/x86/pci/intel_mid_pci.c</span>
<span class="p_chunk">@@ -37,6 +37,7 @@</span> <span class="p_context"></span>
 
 /* Quirks for the listed devices */
 #define PCI_DEVICE_ID_INTEL_MRFL_MMC	0x1190
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_MRFL_HSU	0x1191</span>
 
 /* Fixed BAR fields */
 #define PCIE_VNDR_CAP_ID_FIXED_BAR 0x00	/* Fixed BAR (TBD) */
<span class="p_chunk">@@ -225,13 +226,20 @@</span> <span class="p_context"> static int intel_mid_pci_irq_enable(struct pci_dev *dev)</span>
 		/* Special treatment for IRQ0 */
 		if (dev-&gt;irq == 0) {
 			/*
<span class="p_add">+			 * Skip HS UART common registers device since it has</span>
<span class="p_add">+			 * IRQ0 assigned and not used by the kernel.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (dev-&gt;device == PCI_DEVICE_ID_INTEL_MRFL_HSU)</span>
<span class="p_add">+				return -EBUSY;</span>
<span class="p_add">+			/*</span>
 			 * TNG has IRQ0 assigned to eMMC controller. But there
 			 * are also other devices with bogus PCI configuration
 			 * that have IRQ0 assigned. This check ensures that
<span class="p_del">-			 * eMMC gets it.</span>
<span class="p_add">+			 * eMMC gets it. The rest of devices still could be</span>
<span class="p_add">+			 * enabled without interrupt line being allocated.</span>
 			 */
 			if (dev-&gt;device != PCI_DEVICE_ID_INTEL_MRFL_MMC)
<span class="p_del">-				return -EBUSY;</span>
<span class="p_add">+				return 0;</span>
 		}
 		break;
 	default:
<span class="p_header">diff --git a/block/bio.c b/block/bio.c</span>
<span class="p_header">index 0e4aa42bc30d..462386908835 100644</span>
<span class="p_header">--- a/block/bio.c</span>
<span class="p_header">+++ b/block/bio.c</span>
<span class="p_chunk">@@ -579,6 +579,8 @@</span> <span class="p_context"> void __bio_clone_fast(struct bio *bio, struct bio *bio_src)</span>
 	bio-&gt;bi_rw = bio_src-&gt;bi_rw;
 	bio-&gt;bi_iter = bio_src-&gt;bi_iter;
 	bio-&gt;bi_io_vec = bio_src-&gt;bi_io_vec;
<span class="p_add">+</span>
<span class="p_add">+	bio_clone_blkcg_association(bio, bio_src);</span>
 }
 EXPORT_SYMBOL(__bio_clone_fast);
 
<span class="p_chunk">@@ -684,6 +686,8 @@</span> <span class="p_context"> integrity_clone:</span>
 		}
 	}
 
<span class="p_add">+	bio_clone_blkcg_association(bio, bio_src);</span>
<span class="p_add">+</span>
 	return bio;
 }
 EXPORT_SYMBOL(bio_clone_bioset);
<span class="p_chunk">@@ -2005,6 +2009,17 @@</span> <span class="p_context"> void bio_disassociate_task(struct bio *bio)</span>
 	}
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * bio_clone_blkcg_association - clone blkcg association from src to dst bio</span>
<span class="p_add">+ * @dst: destination bio</span>
<span class="p_add">+ * @src: source bio</span>
<span class="p_add">+ */</span>
<span class="p_add">+void bio_clone_blkcg_association(struct bio *dst, struct bio *src)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (src-&gt;bi_css)</span>
<span class="p_add">+		WARN_ON(bio_associate_blkcg(dst, src-&gt;bi_css));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif /* CONFIG_BLK_CGROUP */
 
 static void __init biovec_init_slabs(void)
<span class="p_header">diff --git a/block/genhd.c b/block/genhd.c</span>
<span class="p_header">index 3eebd256b765..086f1a357734 100644</span>
<span class="p_header">--- a/block/genhd.c</span>
<span class="p_header">+++ b/block/genhd.c</span>
<span class="p_chunk">@@ -613,7 +613,7 @@</span> <span class="p_context"> void add_disk(struct gendisk *disk)</span>
 
 	/* Register BDI before referencing it from bdev */
 	bdi = &amp;disk-&gt;queue-&gt;backing_dev_info;
<span class="p_del">-	bdi_register_dev(bdi, disk_devt(disk));</span>
<span class="p_add">+	bdi_register_owner(bdi, disk_to_dev(disk));</span>
 
 	blk_register_region(disk_devt(disk), disk-&gt;minors, NULL,
 			    exact_match, exact_lock, disk);
<span class="p_header">diff --git a/drivers/acpi/ec.c b/drivers/acpi/ec.c</span>
<span class="p_header">index 290d6f5be44b..f4218df00883 100644</span>
<span class="p_header">--- a/drivers/acpi/ec.c</span>
<span class="p_header">+++ b/drivers/acpi/ec.c</span>
<span class="p_chunk">@@ -101,6 +101,7 @@</span> <span class="p_context"> enum ec_command {</span>
 #define ACPI_EC_UDELAY_POLL	550	/* Wait 1ms for EC transaction polling */
 #define ACPI_EC_CLEAR_MAX	100	/* Maximum number of events to query
 					 * when trying to clear the EC */
<span class="p_add">+#define ACPI_EC_MAX_QUERIES	16	/* Maximum number of parallel queries */</span>
 
 enum {
 	EC_FLAGS_QUERY_PENDING,		/* Query is pending */
<span class="p_chunk">@@ -121,6 +122,10 @@</span> <span class="p_context"> static unsigned int ec_delay __read_mostly = ACPI_EC_DELAY;</span>
 module_param(ec_delay, uint, 0644);
 MODULE_PARM_DESC(ec_delay, &quot;Timeout(ms) waited until an EC command completes&quot;);
 
<span class="p_add">+static unsigned int ec_max_queries __read_mostly = ACPI_EC_MAX_QUERIES;</span>
<span class="p_add">+module_param(ec_max_queries, uint, 0644);</span>
<span class="p_add">+MODULE_PARM_DESC(ec_max_queries, &quot;Maximum parallel _Qxx evaluations&quot;);</span>
<span class="p_add">+</span>
 static bool ec_busy_polling __read_mostly;
 module_param(ec_busy_polling, bool, 0644);
 MODULE_PARM_DESC(ec_busy_polling, &quot;Use busy polling to advance EC transaction&quot;);
<span class="p_chunk">@@ -174,6 +179,7 @@</span> <span class="p_context"> static void acpi_ec_event_processor(struct work_struct *work);</span>
 
 struct acpi_ec *boot_ec, *first_ec;
 EXPORT_SYMBOL(first_ec);
<span class="p_add">+static struct workqueue_struct *ec_query_wq;</span>
 
 static int EC_FLAGS_CLEAR_ON_RESUME; /* Needs acpi_ec_clear() on boot/resume */
 static int EC_FLAGS_QUERY_HANDSHAKE; /* Needs QR_EC issued when SCI_EVT set */
<span class="p_chunk">@@ -1098,7 +1104,7 @@</span> <span class="p_context"> static int acpi_ec_query(struct acpi_ec *ec, u8 *data)</span>
 	 * work queue execution.
 	 */
 	ec_dbg_evt(&quot;Query(0x%02x) scheduled&quot;, value);
<span class="p_del">-	if (!schedule_work(&amp;q-&gt;work)) {</span>
<span class="p_add">+	if (!queue_work(ec_query_wq, &amp;q-&gt;work)) {</span>
 		ec_dbg_evt(&quot;Query(0x%02x) overlapped&quot;, value);
 		result = -EBUSY;
 	}
<span class="p_chunk">@@ -1660,15 +1666,41 @@</span> <span class="p_context"> static struct acpi_driver acpi_ec_driver = {</span>
 		},
 };
 
<span class="p_add">+static inline int acpi_ec_query_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!ec_query_wq) {</span>
<span class="p_add">+		ec_query_wq = alloc_workqueue(&quot;kec_query&quot;, 0,</span>
<span class="p_add">+					      ec_max_queries);</span>
<span class="p_add">+		if (!ec_query_wq)</span>
<span class="p_add">+			return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void acpi_ec_query_exit(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (ec_query_wq) {</span>
<span class="p_add">+		destroy_workqueue(ec_query_wq);</span>
<span class="p_add">+		ec_query_wq = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int __init acpi_ec_init(void)
 {
<span class="p_del">-	int result = 0;</span>
<span class="p_add">+	int result;</span>
 
<span class="p_add">+	/* register workqueue for _Qxx evaluations */</span>
<span class="p_add">+	result = acpi_ec_query_init();</span>
<span class="p_add">+	if (result)</span>
<span class="p_add">+		goto err_exit;</span>
 	/* Now register the driver for the EC */
 	result = acpi_bus_register_driver(&amp;acpi_ec_driver);
<span class="p_del">-	if (result &lt; 0)</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+	if (result)</span>
<span class="p_add">+		goto err_exit;</span>
 
<span class="p_add">+err_exit:</span>
<span class="p_add">+	if (result)</span>
<span class="p_add">+		acpi_ec_query_exit();</span>
 	return result;
 }
 
<span class="p_chunk">@@ -1678,5 +1710,6 @@</span> <span class="p_context"> static void __exit acpi_ec_exit(void)</span>
 {
 
 	acpi_bus_unregister_driver(&amp;acpi_ec_driver);
<span class="p_add">+	acpi_ec_query_exit();</span>
 }
 #endif	/* 0 */
<span class="p_header">diff --git a/drivers/bcma/host_pci.c b/drivers/bcma/host_pci.c</span>
<span class="p_header">index cae5385cf499..bd46569e0e52 100644</span>
<span class="p_header">--- a/drivers/bcma/host_pci.c</span>
<span class="p_header">+++ b/drivers/bcma/host_pci.c</span>
<span class="p_chunk">@@ -295,6 +295,7 @@</span> <span class="p_context"> static const struct pci_device_id bcma_pci_bridge_tbl[] = {</span>
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4359) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4360) },
 	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_BROADCOM, 0x4365, PCI_VENDOR_ID_DELL, 0x0016) },
<span class="p_add">+	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_BROADCOM, 0x4365, PCI_VENDOR_ID_FOXCONN, 0xe092) },</span>
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x43a0) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x43a9) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x43aa) },
<span class="p_header">diff --git a/drivers/block/floppy.c b/drivers/block/floppy.c</span>
<span class="p_header">index 84708a5f8c52..a1dcf12d3dad 100644</span>
<span class="p_header">--- a/drivers/block/floppy.c</span>
<span class="p_header">+++ b/drivers/block/floppy.c</span>
<span class="p_chunk">@@ -3663,11 +3663,6 @@</span> <span class="p_context"> static int floppy_open(struct block_device *bdev, fmode_t mode)</span>
 
 	opened_bdev[drive] = bdev;
 
<span class="p_del">-	if (!(mode &amp; (FMODE_READ|FMODE_WRITE))) {</span>
<span class="p_del">-		res = -EINVAL;</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	res = -ENXIO;
 
 	if (!floppy_track_buffer) {
<span class="p_chunk">@@ -3711,13 +3706,15 @@</span> <span class="p_context"> static int floppy_open(struct block_device *bdev, fmode_t mode)</span>
 	if (UFDCS-&gt;rawcmd == 1)
 		UFDCS-&gt;rawcmd = 2;
 
<span class="p_del">-	UDRS-&gt;last_checked = 0;</span>
<span class="p_del">-	clear_bit(FD_OPEN_SHOULD_FAIL_BIT, &amp;UDRS-&gt;flags);</span>
<span class="p_del">-	check_disk_change(bdev);</span>
<span class="p_del">-	if (test_bit(FD_DISK_CHANGED_BIT, &amp;UDRS-&gt;flags))</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	if (test_bit(FD_OPEN_SHOULD_FAIL_BIT, &amp;UDRS-&gt;flags))</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+	if (mode &amp; (FMODE_READ|FMODE_WRITE)) {</span>
<span class="p_add">+		UDRS-&gt;last_checked = 0;</span>
<span class="p_add">+		clear_bit(FD_OPEN_SHOULD_FAIL_BIT, &amp;UDRS-&gt;flags);</span>
<span class="p_add">+		check_disk_change(bdev);</span>
<span class="p_add">+		if (test_bit(FD_DISK_CHANGED_BIT, &amp;UDRS-&gt;flags))</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		if (test_bit(FD_OPEN_SHOULD_FAIL_BIT, &amp;UDRS-&gt;flags))</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+	}</span>
 
 	res = -EROFS;
 
<span class="p_header">diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c</span>
<span class="p_header">index 25894687c168..fadba88745dc 100644</span>
<span class="p_header">--- a/drivers/bluetooth/ath3k.c</span>
<span class="p_header">+++ b/drivers/bluetooth/ath3k.c</span>
<span class="p_chunk">@@ -123,6 +123,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_table[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3472) },
 	{ USB_DEVICE(0x13d3, 0x3474) },
 	{ USB_DEVICE(0x13d3, 0x3487) },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3490) },</span>
 
 	/* Atheros AR5BBU12 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xE02C) },
<span class="p_chunk">@@ -190,6 +191,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_blist_tbl[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3472), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3474), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3487), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3490), .driver_info = BTUSB_ATH3012 },</span>
 
 	/* Atheros AR5BBU22 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xE036), .driver_info = BTUSB_ATH3012 },
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index a3be65e6231a..9f40c3426f0c 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -237,6 +237,7 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3472), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3474), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3487), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3490), .driver_info = BTUSB_ATH3012 },</span>
 
 	/* Atheros AR5BBU12 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xe02c), .driver_info = BTUSB_IGNORE },
<span class="p_header">diff --git a/drivers/char/random.c b/drivers/char/random.c</span>
<span class="p_header">index 87ab9f6b4112..d72c6d14a1c9 100644</span>
<span class="p_header">--- a/drivers/char/random.c</span>
<span class="p_header">+++ b/drivers/char/random.c</span>
<span class="p_chunk">@@ -949,6 +949,7 @@</span> <span class="p_context"> void add_interrupt_randomness(int irq, int irq_flags)</span>
 	/* award one bit for the contents of the fast pool */
 	credit_entropy_bits(r, credit + 1);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(add_interrupt_randomness);</span>
 
 #ifdef CONFIG_BLOCK
 void add_disk_randomness(struct gendisk *disk)
<span class="p_chunk">@@ -1461,12 +1462,16 @@</span> <span class="p_context"> random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)</span>
 static ssize_t
 urandom_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
 {
<span class="p_add">+	static int maxwarn = 10;</span>
 	int ret;
 
<span class="p_del">-	if (unlikely(nonblocking_pool.initialized == 0))</span>
<span class="p_del">-		printk_once(KERN_NOTICE &quot;random: %s urandom read &quot;</span>
<span class="p_del">-			    &quot;with %d bits of entropy available\n&quot;,</span>
<span class="p_del">-			    current-&gt;comm, nonblocking_pool.entropy_total);</span>
<span class="p_add">+	if (unlikely(nonblocking_pool.initialized == 0) &amp;&amp;</span>
<span class="p_add">+	    maxwarn &gt; 0) {</span>
<span class="p_add">+		maxwarn--;</span>
<span class="p_add">+		printk(KERN_NOTICE &quot;random: %s: uninitialized urandom read &quot;</span>
<span class="p_add">+		       &quot;(%zd bytes read, %d bits of entropy available)\n&quot;,</span>
<span class="p_add">+		       current-&gt;comm, nbytes, nonblocking_pool.entropy_total);</span>
<span class="p_add">+	}</span>
 
 	nbytes = min_t(size_t, nbytes, INT_MAX &gt;&gt; (ENTROPY_SHIFT + 3));
 	ret = extract_entropy_user(&amp;nonblocking_pool, buf, nbytes);
<span class="p_chunk">@@ -1774,13 +1779,15 @@</span> <span class="p_context"> int random_int_secret_init(void)</span>
 	return 0;
 }
 
<span class="p_add">+static DEFINE_PER_CPU(__u32 [MD5_DIGEST_WORDS], get_random_int_hash)</span>
<span class="p_add">+		__aligned(sizeof(unsigned long));</span>
<span class="p_add">+</span>
 /*
  * Get a random word for internal kernel use only. Similar to urandom but
  * with the goal of minimal entropy pool depletion. As a result, the random
  * value is not cryptographically secure but for several uses the cost of
  * depleting entropy is too high
  */
<span class="p_del">-static DEFINE_PER_CPU(__u32 [MD5_DIGEST_WORDS], get_random_int_hash);</span>
 unsigned int get_random_int(void)
 {
 	__u32 *hash;
<span class="p_chunk">@@ -1850,12 +1857,18 @@</span> <span class="p_context"> void add_hwgenerator_randomness(const char *buffer, size_t count,</span>
 {
 	struct entropy_store *poolp = &amp;input_pool;
 
<span class="p_del">-	/* Suspend writing if we&#39;re above the trickle threshold.</span>
<span class="p_del">-	 * We&#39;ll be woken up again once below random_write_wakeup_thresh,</span>
<span class="p_del">-	 * or when the calling thread is about to terminate.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	wait_event_interruptible(random_write_wait, kthread_should_stop() ||</span>
<span class="p_add">+	if (unlikely(nonblocking_pool.initialized == 0))</span>
<span class="p_add">+		poolp = &amp;nonblocking_pool;</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		/* Suspend writing if we&#39;re above the trickle</span>
<span class="p_add">+		 * threshold.  We&#39;ll be woken up again once below</span>
<span class="p_add">+		 * random_write_wakeup_thresh, or when the calling</span>
<span class="p_add">+		 * thread is about to terminate.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		wait_event_interruptible(random_write_wait,</span>
<span class="p_add">+					 kthread_should_stop() ||</span>
 			ENTROPY_BITS(&amp;input_pool) &lt;= random_write_wakeup_bits);
<span class="p_add">+	}</span>
 	mix_pool_bytes(poolp, buffer, count);
 	credit_entropy_bits(poolp, entropy);
 }
<span class="p_header">diff --git a/drivers/char/tpm/tpm_crb.c b/drivers/char/tpm/tpm_crb.c</span>
<span class="p_header">index a12b31940344..e9fd1d83f9f1 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_crb.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_crb.c</span>
<span class="p_chunk">@@ -246,7 +246,7 @@</span> <span class="p_context"> static void __iomem *crb_map_res(struct device *dev, struct crb_priv *priv,</span>
 
 	/* Detect a 64 bit address on a 32 bit system */
 	if (start != new_res.start)
<span class="p_del">-		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+		return (void __iomem *) ERR_PTR(-EINVAL);</span>
 
 	if (!resource_contains(&amp;priv-&gt;res, &amp;new_res))
 		return devm_ioremap_resource(dev, &amp;new_res);
<span class="p_header">diff --git a/drivers/clk/rockchip/clk-rk3399.c b/drivers/clk/rockchip/clk-rk3399.c</span>
<span class="p_header">index 8059a8d3ea36..31b77f71313f 100644</span>
<span class="p_header">--- a/drivers/clk/rockchip/clk-rk3399.c</span>
<span class="p_header">+++ b/drivers/clk/rockchip/clk-rk3399.c</span>
<span class="p_chunk">@@ -586,7 +586,7 @@</span> <span class="p_context"> static struct rockchip_clk_branch rk3399_clk_branches[] __initdata = {</span>
 			RK3399_CLKGATE_CON(8), 15, GFLAGS),
 
 	COMPOSITE(SCLK_SPDIF_REC_DPTX, &quot;clk_spdif_rec_dptx&quot;, mux_pll_src_cpll_gpll_p, 0,
<span class="p_del">-			RK3399_CLKSEL_CON(32), 15, 1, MFLAGS, 0, 5, DFLAGS,</span>
<span class="p_add">+			RK3399_CLKSEL_CON(32), 15, 1, MFLAGS, 8, 5, DFLAGS,</span>
 			RK3399_CLKGATE_CON(10), 6, GFLAGS),
 	/* i2s */
 	COMPOSITE(0, &quot;clk_i2s0_div&quot;, mux_pll_src_cpll_gpll_p, 0,
<span class="p_header">diff --git a/drivers/cpufreq/intel_pstate.c b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">index 1fa1a32928d7..1b159171f1f9 100644</span>
<span class="p_header">--- a/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">+++ b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_chunk">@@ -944,7 +944,7 @@</span> <span class="p_context"> static int core_get_max_pstate(void)</span>
 			if (err)
 				goto skip_tar;
 
<span class="p_del">-			tdp_msr = MSR_CONFIG_TDP_NOMINAL + tdp_ctrl;</span>
<span class="p_add">+			tdp_msr = MSR_CONFIG_TDP_NOMINAL + (tdp_ctrl &amp; 0x3);</span>
 			err = rdmsrl_safe(tdp_msr, &amp;tdp_ratio);
 			if (err)
 				goto skip_tar;
<span class="p_header">diff --git a/drivers/edac/edac_mc_sysfs.c b/drivers/edac/edac_mc_sysfs.c</span>
<span class="p_header">index 10c305b4a2e1..4e0f8e720ad9 100644</span>
<span class="p_header">--- a/drivers/edac/edac_mc_sysfs.c</span>
<span class="p_header">+++ b/drivers/edac/edac_mc_sysfs.c</span>
<span class="p_chunk">@@ -313,7 +313,6 @@</span> <span class="p_context"> static struct device_type csrow_attr_type = {</span>
  * possible dynamic channel DIMM Label attribute files
  *
  */
<span class="p_del">-</span>
 DEVICE_CHANNEL(ch0_dimm_label, S_IRUGO | S_IWUSR,
 	channel_dimm_label_show, channel_dimm_label_store, 0);
 DEVICE_CHANNEL(ch1_dimm_label, S_IRUGO | S_IWUSR,
<span class="p_chunk">@@ -326,6 +325,10 @@</span> <span class="p_context"> DEVICE_CHANNEL(ch4_dimm_label, S_IRUGO | S_IWUSR,</span>
 	channel_dimm_label_show, channel_dimm_label_store, 4);
 DEVICE_CHANNEL(ch5_dimm_label, S_IRUGO | S_IWUSR,
 	channel_dimm_label_show, channel_dimm_label_store, 5);
<span class="p_add">+DEVICE_CHANNEL(ch6_dimm_label, S_IRUGO | S_IWUSR,</span>
<span class="p_add">+	channel_dimm_label_show, channel_dimm_label_store, 6);</span>
<span class="p_add">+DEVICE_CHANNEL(ch7_dimm_label, S_IRUGO | S_IWUSR,</span>
<span class="p_add">+	channel_dimm_label_show, channel_dimm_label_store, 7);</span>
 
 /* Total possible dynamic DIMM Label attribute file table */
 static struct attribute *dynamic_csrow_dimm_attr[] = {
<span class="p_chunk">@@ -335,6 +338,8 @@</span> <span class="p_context"> static struct attribute *dynamic_csrow_dimm_attr[] = {</span>
 	&amp;dev_attr_legacy_ch3_dimm_label.attr.attr,
 	&amp;dev_attr_legacy_ch4_dimm_label.attr.attr,
 	&amp;dev_attr_legacy_ch5_dimm_label.attr.attr,
<span class="p_add">+	&amp;dev_attr_legacy_ch6_dimm_label.attr.attr,</span>
<span class="p_add">+	&amp;dev_attr_legacy_ch7_dimm_label.attr.attr,</span>
 	NULL
 };
 
<span class="p_chunk">@@ -351,6 +356,10 @@</span> <span class="p_context"> DEVICE_CHANNEL(ch4_ce_count, S_IRUGO,</span>
 		   channel_ce_count_show, NULL, 4);
 DEVICE_CHANNEL(ch5_ce_count, S_IRUGO,
 		   channel_ce_count_show, NULL, 5);
<span class="p_add">+DEVICE_CHANNEL(ch6_ce_count, S_IRUGO,</span>
<span class="p_add">+		   channel_ce_count_show, NULL, 6);</span>
<span class="p_add">+DEVICE_CHANNEL(ch7_ce_count, S_IRUGO,</span>
<span class="p_add">+		   channel_ce_count_show, NULL, 7);</span>
 
 /* Total possible dynamic ce_count attribute file table */
 static struct attribute *dynamic_csrow_ce_count_attr[] = {
<span class="p_chunk">@@ -360,6 +369,8 @@</span> <span class="p_context"> static struct attribute *dynamic_csrow_ce_count_attr[] = {</span>
 	&amp;dev_attr_legacy_ch3_ce_count.attr.attr,
 	&amp;dev_attr_legacy_ch4_ce_count.attr.attr,
 	&amp;dev_attr_legacy_ch5_ce_count.attr.attr,
<span class="p_add">+	&amp;dev_attr_legacy_ch6_ce_count.attr.attr,</span>
<span class="p_add">+	&amp;dev_attr_legacy_ch7_ce_count.attr.attr,</span>
 	NULL
 };
 
<span class="p_chunk">@@ -371,9 +382,16 @@</span> <span class="p_context"> static umode_t csrow_dev_is_visible(struct kobject *kobj,</span>
 
 	if (idx &gt;= csrow-&gt;nr_channels)
 		return 0;
<span class="p_add">+</span>
<span class="p_add">+	if (idx &gt;= ARRAY_SIZE(dynamic_csrow_ce_count_attr) - 1) {</span>
<span class="p_add">+		WARN_ONCE(1, &quot;idx: %d\n&quot;, idx);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* Only expose populated DIMMs */
 	if (!csrow-&gt;channels[idx]-&gt;dimm-&gt;nr_pages)
 		return 0;
<span class="p_add">+</span>
 	return attr-&gt;mode;
 }
 
<span class="p_header">diff --git a/drivers/gpio/gpio-intel-mid.c b/drivers/gpio/gpio-intel-mid.c</span>
<span class="p_header">index cdaba13cb8e8..c0f7cce23f62 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-intel-mid.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-intel-mid.c</span>
<span class="p_chunk">@@ -17,7 +17,6 @@</span> <span class="p_context"></span>
  * Moorestown platform Langwell chip.
  * Medfield platform Penwell chip.
  * Clovertrail platform Cloverview chip.
<span class="p_del">- * Merrifield platform Tangier chip.</span>
  */
 
 #include &lt;linux/module.h&gt;
<span class="p_chunk">@@ -64,10 +63,6 @@</span> <span class="p_context"> enum GPIO_REG {</span>
 /* intel_mid gpio driver data */
 struct intel_mid_gpio_ddata {
 	u16 ngpio;		/* number of gpio pins */
<span class="p_del">-	u32 gplr_offset;	/* offset of first GPLR register from base */</span>
<span class="p_del">-	u32 flis_base;		/* base address of FLIS registers */</span>
<span class="p_del">-	u32 flis_len;		/* length of FLIS registers */</span>
<span class="p_del">-	u32 (*get_flis_offset)(int gpio);</span>
 	u32 chip_irq_type;	/* chip interrupt type */
 };
 
<span class="p_chunk">@@ -252,15 +247,6 @@</span> <span class="p_context"> static const struct intel_mid_gpio_ddata gpio_cloverview_core = {</span>
 	.chip_irq_type = INTEL_MID_IRQ_TYPE_EDGE,
 };
 
<span class="p_del">-static const struct intel_mid_gpio_ddata gpio_tangier = {</span>
<span class="p_del">-	.ngpio = 192,</span>
<span class="p_del">-	.gplr_offset = 4,</span>
<span class="p_del">-	.flis_base = 0xff0c0000,</span>
<span class="p_del">-	.flis_len = 0x8000,</span>
<span class="p_del">-	.get_flis_offset = NULL,</span>
<span class="p_del">-	.chip_irq_type = INTEL_MID_IRQ_TYPE_EDGE,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 static const struct pci_device_id intel_gpio_ids[] = {
 	{
 		/* Lincroft */
<span class="p_chunk">@@ -287,11 +273,6 @@</span> <span class="p_context"> static const struct pci_device_id intel_gpio_ids[] = {</span>
 		PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x08f7),
 		.driver_data = (kernel_ulong_t)&amp;gpio_cloverview_core,
 	},
<span class="p_del">-	{</span>
<span class="p_del">-		/* Tangier */</span>
<span class="p_del">-		PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x1199),</span>
<span class="p_del">-		.driver_data = (kernel_ulong_t)&amp;gpio_tangier,</span>
<span class="p_del">-	},</span>
 	{ 0 }
 };
 MODULE_DEVICE_TABLE(pci, intel_gpio_ids);
<span class="p_chunk">@@ -401,7 +382,7 @@</span> <span class="p_context"> static int intel_gpio_probe(struct pci_dev *pdev,</span>
 	spin_lock_init(&amp;priv-&gt;lock);
 
 	pci_set_drvdata(pdev, priv);
<span class="p_del">-	retval = gpiochip_add_data(&amp;priv-&gt;chip, priv);</span>
<span class="p_add">+	retval = devm_gpiochip_add_data(&amp;pdev-&gt;dev, &amp;priv-&gt;chip, priv);</span>
 	if (retval) {
 		dev_err(&amp;pdev-&gt;dev, &quot;gpiochip_add error %d\n&quot;, retval);
 		return retval;
<span class="p_header">diff --git a/drivers/gpio/gpio-pca953x.c b/drivers/gpio/gpio-pca953x.c</span>
<span class="p_header">index 5e3be32ebb8d..3745de659594 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-pca953x.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-pca953x.c</span>
<span class="p_chunk">@@ -90,7 +90,7 @@</span> <span class="p_context"> MODULE_DEVICE_TABLE(acpi, pca953x_acpi_ids);</span>
 #define MAX_BANK 5
 #define BANK_SZ 8
 
<span class="p_del">-#define NBANK(chip) (chip-&gt;gpio_chip.ngpio / BANK_SZ)</span>
<span class="p_add">+#define NBANK(chip) DIV_ROUND_UP(chip-&gt;gpio_chip.ngpio, BANK_SZ)</span>
 
 struct pca953x_chip {
 	unsigned gpio_start;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_header">index 9df1bcb35bf0..983175363b06 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_chunk">@@ -551,28 +551,19 @@</span> <span class="p_context"> int amdgpu_atombios_get_clock_info(struct amdgpu_device *adev)</span>
 		    le16_to_cpu(firmware_info-&gt;info.usReferenceClock);
 		ppll-&gt;reference_div = 0;
 
<span class="p_del">-		if (crev &lt; 2)</span>
<span class="p_del">-			ppll-&gt;pll_out_min =</span>
<span class="p_del">-				le16_to_cpu(firmware_info-&gt;info.usMinPixelClockPLL_Output);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			ppll-&gt;pll_out_min =</span>
<span class="p_del">-				le32_to_cpu(firmware_info-&gt;info_12.ulMinPixelClockPLL_Output);</span>
<span class="p_add">+		ppll-&gt;pll_out_min =</span>
<span class="p_add">+			le32_to_cpu(firmware_info-&gt;info_12.ulMinPixelClockPLL_Output);</span>
 		ppll-&gt;pll_out_max =
 		    le32_to_cpu(firmware_info-&gt;info.ulMaxPixelClockPLL_Output);
 
<span class="p_del">-		if (crev &gt;= 4) {</span>
<span class="p_del">-			ppll-&gt;lcd_pll_out_min =</span>
<span class="p_del">-				le16_to_cpu(firmware_info-&gt;info_14.usLcdMinPixelClockPLL_Output) * 100;</span>
<span class="p_del">-			if (ppll-&gt;lcd_pll_out_min == 0)</span>
<span class="p_del">-				ppll-&gt;lcd_pll_out_min = ppll-&gt;pll_out_min;</span>
<span class="p_del">-			ppll-&gt;lcd_pll_out_max =</span>
<span class="p_del">-				le16_to_cpu(firmware_info-&gt;info_14.usLcdMaxPixelClockPLL_Output) * 100;</span>
<span class="p_del">-			if (ppll-&gt;lcd_pll_out_max == 0)</span>
<span class="p_del">-				ppll-&gt;lcd_pll_out_max = ppll-&gt;pll_out_max;</span>
<span class="p_del">-		} else {</span>
<span class="p_add">+		ppll-&gt;lcd_pll_out_min =</span>
<span class="p_add">+			le16_to_cpu(firmware_info-&gt;info_14.usLcdMinPixelClockPLL_Output) * 100;</span>
<span class="p_add">+		if (ppll-&gt;lcd_pll_out_min == 0)</span>
 			ppll-&gt;lcd_pll_out_min = ppll-&gt;pll_out_min;
<span class="p_add">+		ppll-&gt;lcd_pll_out_max =</span>
<span class="p_add">+			le16_to_cpu(firmware_info-&gt;info_14.usLcdMaxPixelClockPLL_Output) * 100;</span>
<span class="p_add">+		if (ppll-&gt;lcd_pll_out_max == 0)</span>
 			ppll-&gt;lcd_pll_out_max = ppll-&gt;pll_out_max;
<span class="p_del">-		}</span>
 
 		if (ppll-&gt;pll_out_min == 0)
 			ppll-&gt;pll_out_min = 64800;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c</span>
<span class="p_header">index 35a1248aaa77..1b4c069f7765 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c</span>
<span class="p_chunk">@@ -10,6 +10,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/acpi.h&gt;
 #include &lt;linux/pci.h&gt;
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
 
 #include &quot;amd_acpi.h&quot;
 
<span class="p_chunk">@@ -259,6 +260,10 @@</span> <span class="p_context"> static int amdgpu_atpx_set_discrete_state(struct amdgpu_atpx *atpx, u8 state)</span>
 		if (!info)
 			return -EIO;
 		kfree(info);
<span class="p_add">+</span>
<span class="p_add">+		/* 200ms delay is required after off */</span>
<span class="p_add">+		if (state == 0)</span>
<span class="p_add">+			msleep(200);</span>
 	}
 	return 0;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c</span>
<span class="p_header">index cb07da41152b..ff0b55a65ca3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c</span>
<span class="p_chunk">@@ -1690,7 +1690,6 @@</span> <span class="p_context"> amdgpu_connector_add(struct amdgpu_device *adev,</span>
 						   DRM_MODE_SCALE_NONE);
 			/* no HPD on analog connectors */
 			amdgpu_connector-&gt;hpd.hpd = AMDGPU_HPD_NONE;
<span class="p_del">-			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
 			connector-&gt;interlace_allowed = true;
 			connector-&gt;doublescan_allowed = true;
 			break;
<span class="p_chunk">@@ -1893,8 +1892,10 @@</span> <span class="p_context"> amdgpu_connector_add(struct amdgpu_device *adev,</span>
 	}
 
 	if (amdgpu_connector-&gt;hpd.hpd == AMDGPU_HPD_NONE) {
<span class="p_del">-		if (i2c_bus-&gt;valid)</span>
<span class="p_del">-			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
<span class="p_add">+		if (i2c_bus-&gt;valid) {</span>
<span class="p_add">+			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT |</span>
<span class="p_add">+			                    DRM_CONNECTOR_POLL_DISCONNECT;</span>
<span class="p_add">+		}</span>
 	} else
 		connector-&gt;polled = DRM_CONNECTOR_POLL_HPD;
 
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_header">index 6e920086af46..b7f5650d8218 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_chunk">@@ -1841,7 +1841,23 @@</span> <span class="p_context"> int amdgpu_resume_kms(struct drm_device *dev, bool resume, bool fbcon)</span>
 	}
 
 	drm_kms_helper_poll_enable(dev);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Most of the connector probing functions try to acquire runtime pm</span>
<span class="p_add">+	 * refs to ensure that the GPU is powered on when connector polling is</span>
<span class="p_add">+	 * performed. Since we&#39;re calling this from a runtime PM callback,</span>
<span class="p_add">+	 * trying to acquire rpm refs will cause us to deadlock.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Since we&#39;re guaranteed to be holding the rpm lock, it&#39;s safe to</span>
<span class="p_add">+	 * temporarily disable the rpm helpers so this doesn&#39;t deadlock us.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+#ifdef CONFIG_PM</span>
<span class="p_add">+	dev-&gt;dev-&gt;power.disable_depth++;</span>
<span class="p_add">+#endif</span>
 	drm_helper_hpd_irq_event(dev);
<span class="p_add">+#ifdef CONFIG_PM</span>
<span class="p_add">+	dev-&gt;dev-&gt;power.disable_depth--;</span>
<span class="p_add">+#endif</span>
 
 	if (fbcon) {
 		amdgpu_fbdev_set_suspend(adev, 0);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c b/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c</span>
<span class="p_header">index 48b6bd671cda..c32eca26155c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c</span>
<span class="p_chunk">@@ -98,6 +98,7 @@</span> <span class="p_context"> amdgpu_atombios_encoder_set_backlight_level(struct amdgpu_encoder *amdgpu_encode</span>
 		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:
 		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:
 		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:
<span class="p_add">+		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:</span>
 			if (dig-&gt;backlight_level == 0)
 				amdgpu_atombios_encoder_setup_dig_transmitter(encoder,
 								       ATOM_TRANSMITTER_ACTION_LCD_BLOFF, 0, 0);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c</span>
<span class="p_header">index 1feb6439cb0b..92695481093e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c</span>
<span class="p_chunk">@@ -167,6 +167,7 @@</span> <span class="p_context"> static int gmc_v7_0_init_microcode(struct amdgpu_device *adev)</span>
 		break;
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
<span class="p_add">+	case CHIP_MULLINS:</span>
 		return 0;
 	default: BUG();
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/amd/powerplay/hwmgr/ppatomctrl.c b/drivers/gpu/drm/amd/powerplay/hwmgr/ppatomctrl.c</span>
<span class="p_header">index 90b35c5c10a4..ffc7c0dd3f14 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/powerplay/hwmgr/ppatomctrl.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/powerplay/hwmgr/ppatomctrl.c</span>
<span class="p_chunk">@@ -592,12 +592,12 @@</span> <span class="p_context"> bool atomctrl_get_pp_assign_pin(</span>
 		const uint32_t pinId,
 		pp_atomctrl_gpio_pin_assignment *gpio_pin_assignment)
 {
<span class="p_del">-	bool bRet = 0;</span>
<span class="p_add">+	bool bRet = false;</span>
 	ATOM_GPIO_PIN_LUT *gpio_lookup_table =
 		get_gpio_lookup_table(hwmgr-&gt;device);
 
 	PP_ASSERT_WITH_CODE((NULL != gpio_lookup_table),
<span class="p_del">-			&quot;Could not find GPIO lookup Table in BIOS.&quot;, return -1);</span>
<span class="p_add">+			&quot;Could not find GPIO lookup Table in BIOS.&quot;, return false);</span>
 
 	bRet = atomctrl_lookup_gpio_pin(gpio_lookup_table, pinId,
 		gpio_pin_assignment);
<span class="p_header">diff --git a/drivers/gpu/drm/drm_cache.c b/drivers/gpu/drm/drm_cache.c</span>
<span class="p_header">index 059f7c39c582..a7916e5f8864 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_cache.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_cache.c</span>
<span class="p_chunk">@@ -136,6 +136,7 @@</span> <span class="p_context"> drm_clflush_virt_range(void *addr, unsigned long length)</span>
 		mb();
 		for (; addr &lt; end; addr += size)
 			clflushopt(addr);
<span class="p_add">+		clflushopt(end - 1); /* force serialisation */</span>
 		mb();
 		return;
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c</span>
<span class="p_header">index eeaf5a7c3aa7..67b28f8018d2 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_dp_helper.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_dp_helper.c</span>
<span class="p_chunk">@@ -203,7 +203,7 @@</span> <span class="p_context"> static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,</span>
 
 		ret = aux-&gt;transfer(aux, &amp;msg);
 
<span class="p_del">-		if (ret &gt; 0) {</span>
<span class="p_add">+		if (ret &gt;= 0) {</span>
 			native_reply = msg.reply &amp; DP_AUX_NATIVE_REPLY_MASK;
 			if (native_reply == DP_AUX_NATIVE_REPLY_ACK) {
 				if (ret == size)
<span class="p_header">diff --git a/drivers/gpu/drm/drm_edid.c b/drivers/gpu/drm/drm_edid.c</span>
<span class="p_header">index 7df26d4b7ad8..2cb472b9976a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_edid.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_edid.c</span>
<span class="p_chunk">@@ -74,6 +74,8 @@</span> <span class="p_context"></span>
 #define EDID_QUIRK_FORCE_8BPC			(1 &lt;&lt; 8)
 /* Force 12bpc */
 #define EDID_QUIRK_FORCE_12BPC			(1 &lt;&lt; 9)
<span class="p_add">+/* Force 6bpc */</span>
<span class="p_add">+#define EDID_QUIRK_FORCE_6BPC			(1 &lt;&lt; 10)</span>
 
 struct detailed_mode_closure {
 	struct drm_connector *connector;
<span class="p_chunk">@@ -100,6 +102,9 @@</span> <span class="p_context"> static struct edid_quirk {</span>
 	/* Unknown Acer */
 	{ &quot;ACR&quot;, 2423, EDID_QUIRK_FIRST_DETAILED_PREFERRED },
 
<span class="p_add">+	/* AEO model 0 reports 8 bpc, but is a 6 bpc panel */</span>
<span class="p_add">+	{ &quot;AEO&quot;, 0, EDID_QUIRK_FORCE_6BPC },</span>
<span class="p_add">+</span>
 	/* Belinea 10 15 55 */
 	{ &quot;MAX&quot;, 1516, EDID_QUIRK_PREFER_LARGE_60 },
 	{ &quot;MAX&quot;, 0x77e, EDID_QUIRK_PREFER_LARGE_60 },
<span class="p_chunk">@@ -4082,6 +4087,9 @@</span> <span class="p_context"> int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid)</span>
 
 	drm_add_display_info(edid, &amp;connector-&gt;display_info, connector);
 
<span class="p_add">+	if (quirks &amp; EDID_QUIRK_FORCE_6BPC)</span>
<span class="p_add">+		connector-&gt;display_info.bpc = 6;</span>
<span class="p_add">+</span>
 	if (quirks &amp; EDID_QUIRK_FORCE_8BPC)
 		connector-&gt;display_info.bpc = 8;
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_header">index bc3f2e6842e7..227a63ee0067 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_chunk">@@ -2591,6 +2591,8 @@</span> <span class="p_context"> struct drm_i915_cmd_table {</span>
 #define SKL_REVID_D0		0x3
 #define SKL_REVID_E0		0x4
 #define SKL_REVID_F0		0x5
<span class="p_add">+#define SKL_REVID_G0		0x6</span>
<span class="p_add">+#define SKL_REVID_H0		0x7</span>
 
 #define IS_SKL_REVID(p, since, until) (IS_SKYLAKE(p) &amp;&amp; IS_REVID(p, since, until))
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_reg.h b/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_header">index 3fcf7dd5b6ca..bc3b6dde7b4b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_chunk">@@ -1672,6 +1672,9 @@</span> <span class="p_context"> enum skl_disp_power_wells {</span>
 
 #define GEN7_TLB_RD_ADDR	_MMIO(0x4700)
 
<span class="p_add">+#define GEN9_GAMT_ECO_REG_RW_IA _MMIO(0x4ab0)</span>
<span class="p_add">+#define   GAMT_ECO_ENABLE_IN_PLACE_DECOMPRESS	(1&lt;&lt;18)</span>
<span class="p_add">+</span>
 #define GAMT_CHKN_BIT_REG	_MMIO(0x4ab8)
 #define   GAMT_CHKN_DISABLE_DYNAMIC_CREDIT_SHARING	(1&lt;&lt;28)
 
<span class="p_chunk">@@ -7538,6 +7541,8 @@</span> <span class="p_context"> enum skl_disp_power_wells {</span>
 
 #define CDCLK_FREQ			_MMIO(0x46200)
 
<span class="p_add">+#define CDCLK_FREQ			_MMIO(0x46200)</span>
<span class="p_add">+</span>
 #define _TRANSA_MSA_MISC		0x60410
 #define _TRANSB_MSA_MISC		0x61410
 #define _TRANSC_MSA_MISC		0x62410
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index 3074c56a643d..32893195d7c4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -9700,6 +9700,8 @@</span> <span class="p_context"> static void broadwell_set_cdclk(struct drm_device *dev, int cdclk)</span>
 
 	I915_WRITE(CDCLK_FREQ, DIV_ROUND_CLOSEST(cdclk, 1000) - 1);
 
<span class="p_add">+	I915_WRITE(CDCLK_FREQ, DIV_ROUND_CLOSEST(cdclk, 1000) - 1);</span>
<span class="p_add">+</span>
 	intel_update_cdclk(dev);
 
 	WARN(cdclk != dev_priv-&gt;cdclk_freq,
<span class="p_chunk">@@ -12095,21 +12097,11 @@</span> <span class="p_context"> connected_sink_compute_bpp(struct intel_connector *connector,</span>
 		pipe_config-&gt;pipe_bpp = connector-&gt;base.display_info.bpc*3;
 	}
 
<span class="p_del">-	/* Clamp bpp to default limit on screens without EDID 1.4 */</span>
<span class="p_del">-	if (connector-&gt;base.display_info.bpc == 0) {</span>
<span class="p_del">-		int type = connector-&gt;base.connector_type;</span>
<span class="p_del">-		int clamp_bpp = 24;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Fall back to 18 bpp when DP sink capability is unknown. */</span>
<span class="p_del">-		if (type == DRM_MODE_CONNECTOR_DisplayPort ||</span>
<span class="p_del">-		    type == DRM_MODE_CONNECTOR_eDP)</span>
<span class="p_del">-			clamp_bpp = 18;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (bpp &gt; clamp_bpp) {</span>
<span class="p_del">-			DRM_DEBUG_KMS(&quot;clamping display bpp (was %d) to default limit of %d\n&quot;,</span>
<span class="p_del">-				      bpp, clamp_bpp);</span>
<span class="p_del">-			pipe_config-&gt;pipe_bpp = clamp_bpp;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	/* Clamp bpp to 8 on screens without EDID 1.4 */</span>
<span class="p_add">+	if (connector-&gt;base.display_info.bpc == 0 &amp;&amp; bpp &gt; 24) {</span>
<span class="p_add">+		DRM_DEBUG_KMS(&quot;clamping display bpp (was %d) to default limit of 24\n&quot;,</span>
<span class="p_add">+			      bpp);</span>
<span class="p_add">+		pipe_config-&gt;pipe_bpp = 24;</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_pm.c b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">index 2863b92c9da6..c1ca5a7ba86f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_chunk">@@ -4563,7 +4563,8 @@</span> <span class="p_context"> void gen6_rps_idle(struct drm_i915_private *dev_priv)</span>
 		else
 			gen6_set_rps(dev_priv-&gt;dev, dev_priv-&gt;rps.idle_freq);
 		dev_priv-&gt;rps.last_adj = 0;
<span class="p_del">-		I915_WRITE(GEN6_PMINTRMSK, 0xffffffff);</span>
<span class="p_add">+		I915_WRITE(GEN6_PMINTRMSK,</span>
<span class="p_add">+			   gen6_sanitize_rps_pm_mask(dev_priv, ~0));</span>
 	}
 	mutex_unlock(&amp;dev_priv-&gt;rps.hw_lock);
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_ringbuffer.c b/drivers/gpu/drm/i915/intel_ringbuffer.c</span>
<span class="p_header">index 68c5af079ef8..9d778f3ab27d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_ringbuffer.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_ringbuffer.c</span>
<span class="p_chunk">@@ -1135,6 +1135,11 @@</span> <span class="p_context"> static int skl_init_workarounds(struct intel_engine_cs *engine)</span>
 	/* WaDisableGafsUnitClkGating:skl */
 	WA_SET_BIT(GEN7_UCGCTL4, GEN8_EU_GAUNIT_CLOCK_GATE_DISABLE);
 
<span class="p_add">+	/* WaInPlaceDecompressionHang:skl */</span>
<span class="p_add">+	if (IS_SKL_REVID(dev_priv, SKL_REVID_H0, REVID_FOREVER))</span>
<span class="p_add">+		WA_SET_BIT(GEN9_GAMT_ECO_REG_RW_IA,</span>
<span class="p_add">+			   GAMT_ECO_ENABLE_IN_PLACE_DECOMPRESS);</span>
<span class="p_add">+</span>
 	/* WaDisableLSQCROPERFforOCL:skl */
 	ret = wa_ring_whitelist_reg(engine, GEN8_L3SQCREG4);
 	if (ret)
<span class="p_chunk">@@ -1194,6 +1199,11 @@</span> <span class="p_context"> static int bxt_init_workarounds(struct intel_engine_cs *engine)</span>
 		WA_SET_BIT_MASKED(COMMON_SLICE_CHICKEN2,
 				  GEN8_SBE_DISABLE_REPLAY_BUF_OPTIMIZATION);
 
<span class="p_add">+	/* WaInPlaceDecompressionHang:bxt */</span>
<span class="p_add">+	if (IS_BXT_REVID(dev_priv, BXT_REVID_C0, REVID_FOREVER))</span>
<span class="p_add">+		WA_SET_BIT(GEN9_GAMT_ECO_REG_RW_IA,</span>
<span class="p_add">+			   GAMT_ECO_ENABLE_IN_PLACE_DECOMPRESS);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1241,6 +1251,10 @@</span> <span class="p_context"> static int kbl_init_workarounds(struct intel_engine_cs *engine)</span>
 		GEN7_HALF_SLICE_CHICKEN1,
 		GEN7_SBE_SS_CACHE_DISPATCH_PORT_SHARING_DISABLE);
 
<span class="p_add">+	/* WaInPlaceDecompressionHang:kbl */</span>
<span class="p_add">+	WA_SET_BIT(GEN9_GAMT_ECO_REG_RW_IA,</span>
<span class="p_add">+		   GAMT_ECO_ENABLE_IN_PLACE_DECOMPRESS);</span>
<span class="p_add">+</span>
 	/* WaDisableLSQCROPERFforOCL:kbl */
 	ret = wa_ring_whitelist_reg(engine, GEN8_L3SQCREG4);
 	if (ret)
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nouveau_drm.c b/drivers/gpu/drm/nouveau/nouveau_drm.c</span>
<span class="p_header">index 11f8dd9c0edb..d6c134b01833 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nouveau_drm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nouveau_drm.c</span>
<span class="p_chunk">@@ -324,7 +324,16 @@</span> <span class="p_context"> static int nouveau_drm_probe(struct pci_dev *pdev,</span>
 	    !vga_switcheroo_handler_flags())
 		return -EPROBE_DEFER;
 
<span class="p_del">-	/* remove conflicting drivers (vesafb, efifb etc) */</span>
<span class="p_add">+	/* We need to check that the chipset is supported before booting</span>
<span class="p_add">+	 * fbdev off the hardware, as there&#39;s no way to put it back.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ret = nvkm_device_pci_new(pdev, NULL, &quot;error&quot;, true, false, 0, &amp;device);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	nvkm_device_del(&amp;device);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Remove conflicting drivers (vesafb, efifb etc). */</span>
 	aper = alloc_apertures(3);
 	if (!aper)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nv04_fbcon.c b/drivers/gpu/drm/nouveau/nv04_fbcon.c</span>
<span class="p_header">index 7d9248b8c664..da8fd5ff9d0f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nv04_fbcon.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nv04_fbcon.c</span>
<span class="p_chunk">@@ -107,11 +107,11 @@</span> <span class="p_context"> nv04_fbcon_imageblit(struct fb_info *info, const struct fb_image *image)</span>
 			 ((image-&gt;dx + image-&gt;width) &amp; 0xffff));
 	OUT_RING(chan, bg);
 	OUT_RING(chan, fg);
<span class="p_del">-	OUT_RING(chan, (image-&gt;height &lt;&lt; 16) | image-&gt;width);</span>
<span class="p_add">+	OUT_RING(chan, (image-&gt;height &lt;&lt; 16) | ALIGN(image-&gt;width, 8));</span>
 	OUT_RING(chan, (image-&gt;height &lt;&lt; 16) | image-&gt;width);
 	OUT_RING(chan, (image-&gt;dy &lt;&lt; 16) | (image-&gt;dx &amp; 0xffff));
 
<span class="p_del">-	dsize = ALIGN(image-&gt;width * image-&gt;height, 32) &gt;&gt; 5;</span>
<span class="p_add">+	dsize = ALIGN(ALIGN(image-&gt;width, 8) * image-&gt;height, 32) &gt;&gt; 5;</span>
 	while (dsize) {
 		int iter_len = dsize &gt; 128 ? 128 : dsize;
 
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nv50_fbcon.c b/drivers/gpu/drm/nouveau/nv50_fbcon.c</span>
<span class="p_header">index 1aeb698e9707..af3d3c49411a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nv50_fbcon.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nv50_fbcon.c</span>
<span class="p_chunk">@@ -125,7 +125,7 @@</span> <span class="p_context"> nv50_fbcon_imageblit(struct fb_info *info, const struct fb_image *image)</span>
 	OUT_RING(chan, 0);
 	OUT_RING(chan, image-&gt;dy);
 
<span class="p_del">-	dwords = ALIGN(image-&gt;width * image-&gt;height, 32) &gt;&gt; 5;</span>
<span class="p_add">+	dwords = ALIGN(ALIGN(image-&gt;width, 8) * image-&gt;height, 32) &gt;&gt; 5;</span>
 	while (dwords) {
 		int push = dwords &gt; 2047 ? 2047 : dwords;
 
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvc0_fbcon.c b/drivers/gpu/drm/nouveau/nvc0_fbcon.c</span>
<span class="p_header">index 839f4c8c1805..054b6a056d99 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvc0_fbcon.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvc0_fbcon.c</span>
<span class="p_chunk">@@ -125,7 +125,7 @@</span> <span class="p_context"> nvc0_fbcon_imageblit(struct fb_info *info, const struct fb_image *image)</span>
 	OUT_RING  (chan, 0);
 	OUT_RING  (chan, image-&gt;dy);
 
<span class="p_del">-	dwords = ALIGN(image-&gt;width * image-&gt;height, 32) &gt;&gt; 5;</span>
<span class="p_add">+	dwords = ALIGN(ALIGN(image-&gt;width, 8) * image-&gt;height, 32) &gt;&gt; 5;</span>
 	while (dwords) {
 		int push = dwords &gt; 2047 ? 2047 : dwords;
 
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv30.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv30.c</span>
<span class="p_header">index 69de8c6259fe..f1e15a4d4f64 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv30.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv30.c</span>
<span class="p_chunk">@@ -76,8 +76,8 @@</span> <span class="p_context"> nv30_gr_chan_new(struct nvkm_gr *base, struct nvkm_fifo_chan *fifoch,</span>
 		nvkm_wo32(chan-&gt;inst, i, 0x00040004);
 	for (i = 0x1f18; i &lt;= 0x3088 ; i += 16) {
 		nvkm_wo32(chan-&gt;inst, i + 0, 0x10700ff9);
<span class="p_del">-		nvkm_wo32(chan-&gt;inst, i + 1, 0x0436086c);</span>
<span class="p_del">-		nvkm_wo32(chan-&gt;inst, i + 2, 0x000c001b);</span>
<span class="p_add">+		nvkm_wo32(chan-&gt;inst, i + 4, 0x0436086c);</span>
<span class="p_add">+		nvkm_wo32(chan-&gt;inst, i + 8, 0x000c001b);</span>
 	}
 	for (i = 0x30b8; i &lt; 0x30c8; i += 4)
 		nvkm_wo32(chan-&gt;inst, i, 0x0000ffff);
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv34.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv34.c</span>
<span class="p_header">index 2207dac23981..300f5ed5de0b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv34.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv34.c</span>
<span class="p_chunk">@@ -75,8 +75,8 @@</span> <span class="p_context"> nv34_gr_chan_new(struct nvkm_gr *base, struct nvkm_fifo_chan *fifoch,</span>
 		nvkm_wo32(chan-&gt;inst, i, 0x00040004);
 	for (i = 0x15ac; i &lt;= 0x271c ; i += 16) {
 		nvkm_wo32(chan-&gt;inst, i + 0, 0x10700ff9);
<span class="p_del">-		nvkm_wo32(chan-&gt;inst, i + 1, 0x0436086c);</span>
<span class="p_del">-		nvkm_wo32(chan-&gt;inst, i + 2, 0x000c001b);</span>
<span class="p_add">+		nvkm_wo32(chan-&gt;inst, i + 4, 0x0436086c);</span>
<span class="p_add">+		nvkm_wo32(chan-&gt;inst, i + 8, 0x000c001b);</span>
 	}
 	for (i = 0x274c; i &lt; 0x275c; i += 4)
 		nvkm_wo32(chan-&gt;inst, i, 0x0000ffff);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_encoders.c b/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_header">index 587cae4e73c9..56bb758f4e33 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_chunk">@@ -120,6 +120,7 @@</span> <span class="p_context"> atombios_set_backlight_level(struct radeon_encoder *radeon_encoder, u8 level)</span>
 		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:
 		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:
 		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:
<span class="p_add">+		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:</span>
 			if (dig-&gt;backlight_level == 0)
 				atombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_LCD_BLOFF, 0, 0);
 			else {
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_atombios.c b/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_header">index f8097a0e7a79..5df3ec73021b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_chunk">@@ -1155,7 +1155,7 @@</span> <span class="p_context"> bool radeon_atom_get_clock_info(struct drm_device *dev)</span>
 		    le16_to_cpu(firmware_info-&gt;info.usReferenceClock);
 		p1pll-&gt;reference_div = 0;
 
<span class="p_del">-		if (crev &lt; 2)</span>
<span class="p_add">+		if ((frev &lt; 2) &amp;&amp; (crev &lt; 2))</span>
 			p1pll-&gt;pll_out_min =
 				le16_to_cpu(firmware_info-&gt;info.usMinPixelClockPLL_Output);
 		else
<span class="p_chunk">@@ -1164,7 +1164,7 @@</span> <span class="p_context"> bool radeon_atom_get_clock_info(struct drm_device *dev)</span>
 		p1pll-&gt;pll_out_max =
 		    le32_to_cpu(firmware_info-&gt;info.ulMaxPixelClockPLL_Output);
 
<span class="p_del">-		if (crev &gt;= 4) {</span>
<span class="p_add">+		if (((frev &lt; 2) &amp;&amp; (crev &gt;= 4)) || (frev &gt;= 2)) {</span>
 			p1pll-&gt;lcd_pll_out_min =
 				le16_to_cpu(firmware_info-&gt;info_14.usLcdMinPixelClockPLL_Output) * 100;
 			if (p1pll-&gt;lcd_pll_out_min == 0)
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c</span>
<span class="p_header">index 95f4fea89302..1b3f4e51f5dc 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c</span>
<span class="p_chunk">@@ -10,6 +10,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/acpi.h&gt;
 #include &lt;linux/pci.h&gt;
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
 
 #include &quot;radeon_acpi.h&quot;
 
<span class="p_chunk">@@ -258,6 +259,10 @@</span> <span class="p_context"> static int radeon_atpx_set_discrete_state(struct radeon_atpx *atpx, u8 state)</span>
 		if (!info)
 			return -EIO;
 		kfree(info);
<span class="p_add">+</span>
<span class="p_add">+		/* 200ms delay is required after off */</span>
<span class="p_add">+		if (state == 0)</span>
<span class="p_add">+			msleep(200);</span>
 	}
 	return 0;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_connectors.c b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">index 81a63d7f5cd9..b79f3b002471 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_chunk">@@ -2064,7 +2064,6 @@</span> <span class="p_context"> radeon_add_atom_connector(struct drm_device *dev,</span>
 							   RADEON_OUTPUT_CSC_BYPASS);
 			/* no HPD on analog connectors */
 			radeon_connector-&gt;hpd.hpd = RADEON_HPD_NONE;
<span class="p_del">-			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
 			connector-&gt;interlace_allowed = true;
 			connector-&gt;doublescan_allowed = true;
 			break;
<span class="p_chunk">@@ -2314,8 +2313,10 @@</span> <span class="p_context"> radeon_add_atom_connector(struct drm_device *dev,</span>
 	}
 
 	if (radeon_connector-&gt;hpd.hpd == RADEON_HPD_NONE) {
<span class="p_del">-		if (i2c_bus-&gt;valid)</span>
<span class="p_del">-			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
<span class="p_add">+		if (i2c_bus-&gt;valid) {</span>
<span class="p_add">+			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT |</span>
<span class="p_add">+			                    DRM_CONNECTOR_POLL_DISCONNECT;</span>
<span class="p_add">+		}</span>
 	} else
 		connector-&gt;polled = DRM_CONNECTOR_POLL_HPD;
 
<span class="p_chunk">@@ -2391,7 +2392,6 @@</span> <span class="p_context"> radeon_add_legacy_connector(struct drm_device *dev,</span>
 					      1);
 		/* no HPD on analog connectors */
 		radeon_connector-&gt;hpd.hpd = RADEON_HPD_NONE;
<span class="p_del">-		connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
 		connector-&gt;interlace_allowed = true;
 		connector-&gt;doublescan_allowed = true;
 		break;
<span class="p_chunk">@@ -2476,10 +2476,13 @@</span> <span class="p_context"> radeon_add_legacy_connector(struct drm_device *dev,</span>
 	}
 
 	if (radeon_connector-&gt;hpd.hpd == RADEON_HPD_NONE) {
<span class="p_del">-		if (i2c_bus-&gt;valid)</span>
<span class="p_del">-			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
<span class="p_add">+		if (i2c_bus-&gt;valid) {</span>
<span class="p_add">+			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT |</span>
<span class="p_add">+			                    DRM_CONNECTOR_POLL_DISCONNECT;</span>
<span class="p_add">+		}</span>
 	} else
 		connector-&gt;polled = DRM_CONNECTOR_POLL_HPD;
<span class="p_add">+</span>
 	connector-&gt;display_info.subpixel_order = subpixel_order;
 	drm_connector_register(connector);
 }
<span class="p_header">diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_vop.c b/drivers/gpu/drm/rockchip/rockchip_drm_vop.c</span>
<span class="p_header">index 1c4d5b5a70a2..b1673236c356 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/rockchip/rockchip_drm_vop.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/rockchip/rockchip_drm_vop.c</span>
<span class="p_chunk">@@ -1048,6 +1048,17 @@</span> <span class="p_context"> static void vop_crtc_destroy(struct drm_crtc *crtc)</span>
 	drm_crtc_cleanup(crtc);
 }
 
<span class="p_add">+static void vop_crtc_reset(struct drm_crtc *crtc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (crtc-&gt;state)</span>
<span class="p_add">+		__drm_atomic_helper_crtc_destroy_state(crtc-&gt;state);</span>
<span class="p_add">+	kfree(crtc-&gt;state);</span>
<span class="p_add">+</span>
<span class="p_add">+	crtc-&gt;state = kzalloc(sizeof(struct rockchip_crtc_state), GFP_KERNEL);</span>
<span class="p_add">+	if (crtc-&gt;state)</span>
<span class="p_add">+		crtc-&gt;state-&gt;crtc = crtc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct drm_crtc_state *vop_crtc_duplicate_state(struct drm_crtc *crtc)
 {
 	struct rockchip_crtc_state *rockchip_state;
<span class="p_chunk">@@ -1073,7 +1084,7 @@</span> <span class="p_context"> static const struct drm_crtc_funcs vop_crtc_funcs = {</span>
 	.set_config = drm_atomic_helper_set_config,
 	.page_flip = drm_atomic_helper_page_flip,
 	.destroy = vop_crtc_destroy,
<span class="p_del">-	.reset = drm_atomic_helper_crtc_reset,</span>
<span class="p_add">+	.reset = vop_crtc_reset,</span>
 	.atomic_duplicate_state = vop_crtc_duplicate_state,
 	.atomic_destroy_state = vop_crtc_destroy_state,
 };
<span class="p_header">diff --git a/drivers/hid/uhid.c b/drivers/hid/uhid.c</span>
<span class="p_header">index 16b6f11a0700..99ec3ff7563b 100644</span>
<span class="p_header">--- a/drivers/hid/uhid.c</span>
<span class="p_header">+++ b/drivers/hid/uhid.c</span>
<span class="p_chunk">@@ -51,10 +51,26 @@</span> <span class="p_context"> struct uhid_device {</span>
 	u32 report_id;
 	u32 report_type;
 	struct uhid_event report_buf;
<span class="p_add">+	struct work_struct worker;</span>
 };
 
 static struct miscdevice uhid_misc;
 
<span class="p_add">+static void uhid_device_add_worker(struct work_struct *work)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct uhid_device *uhid = container_of(work, struct uhid_device, worker);</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = hid_add_device(uhid-&gt;hid);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		hid_err(uhid-&gt;hid, &quot;Cannot register HID device: error %d\n&quot;, ret);</span>
<span class="p_add">+</span>
<span class="p_add">+		hid_destroy_device(uhid-&gt;hid);</span>
<span class="p_add">+		uhid-&gt;hid = NULL;</span>
<span class="p_add">+		uhid-&gt;running = false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void uhid_queue(struct uhid_device *uhid, struct uhid_event *ev)
 {
 	__u8 newhead;
<span class="p_chunk">@@ -498,18 +514,14 @@</span> <span class="p_context"> static int uhid_dev_create2(struct uhid_device *uhid,</span>
 	uhid-&gt;hid = hid;
 	uhid-&gt;running = true;
 
<span class="p_del">-	ret = hid_add_device(hid);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		hid_err(hid, &quot;Cannot register HID device\n&quot;);</span>
<span class="p_del">-		goto err_hid;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* Adding of a HID device is done through a worker, to allow HID drivers</span>
<span class="p_add">+	 * which use feature requests during .probe to work, without they would</span>
<span class="p_add">+	 * be blocked on devlock, which is held by uhid_char_write.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	schedule_work(&amp;uhid-&gt;worker);</span>
 
 	return 0;
 
<span class="p_del">-err_hid:</span>
<span class="p_del">-	hid_destroy_device(hid);</span>
<span class="p_del">-	uhid-&gt;hid = NULL;</span>
<span class="p_del">-	uhid-&gt;running = false;</span>
 err_free:
 	kfree(uhid-&gt;rd_data);
 	uhid-&gt;rd_data = NULL;
<span class="p_chunk">@@ -550,6 +562,8 @@</span> <span class="p_context"> static int uhid_dev_destroy(struct uhid_device *uhid)</span>
 	uhid-&gt;running = false;
 	wake_up_interruptible(&amp;uhid-&gt;report_wait);
 
<span class="p_add">+	cancel_work_sync(&amp;uhid-&gt;worker);</span>
<span class="p_add">+</span>
 	hid_destroy_device(uhid-&gt;hid);
 	kfree(uhid-&gt;rd_data);
 
<span class="p_chunk">@@ -612,6 +626,7 @@</span> <span class="p_context"> static int uhid_char_open(struct inode *inode, struct file *file)</span>
 	init_waitqueue_head(&amp;uhid-&gt;waitq);
 	init_waitqueue_head(&amp;uhid-&gt;report_wait);
 	uhid-&gt;running = false;
<span class="p_add">+	INIT_WORK(&amp;uhid-&gt;worker, uhid_device_add_worker);</span>
 
 	file-&gt;private_data = uhid;
 	nonseekable_open(inode, file);
<span class="p_header">diff --git a/drivers/hv/vmbus_drv.c b/drivers/hv/vmbus_drv.c</span>
<span class="p_header">index 952f20fdc7e3..e82f7e1c217c 100644</span>
<span class="p_header">--- a/drivers/hv/vmbus_drv.c</span>
<span class="p_header">+++ b/drivers/hv/vmbus_drv.c</span>
<span class="p_chunk">@@ -42,6 +42,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/screen_info.h&gt;
 #include &lt;linux/kdebug.h&gt;
 #include &lt;linux/efi.h&gt;
<span class="p_add">+#include &lt;linux/random.h&gt;</span>
 #include &quot;hyperv_vmbus.h&quot;
 
 static struct acpi_device  *hv_acpi_dev;
<span class="p_chunk">@@ -806,6 +807,8 @@</span> <span class="p_context"> static void vmbus_isr(void)</span>
 		else
 			tasklet_schedule(hv_context.msg_dpc[cpu]);
 	}
<span class="p_add">+</span>
<span class="p_add">+	add_interrupt_randomness(HYPERVISOR_CALLBACK_VECTOR, 0);</span>
 }
 
 
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-efm32.c b/drivers/i2c/busses/i2c-efm32.c</span>
<span class="p_header">index 8eff62738877..e253598d764c 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-efm32.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-efm32.c</span>
<span class="p_chunk">@@ -433,7 +433,7 @@</span> <span class="p_context"> static int efm32_i2c_probe(struct platform_device *pdev)</span>
 	ret = request_irq(ddata-&gt;irq, efm32_i2c_irq, 0, DRIVER_NAME, ddata);
 	if (ret &lt; 0) {
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to request irq (%d)\n&quot;, ret);
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto err_disable_clk;</span>
 	}
 
 	ret = i2c_add_adapter(&amp;ddata-&gt;adapter);
<span class="p_header">diff --git a/drivers/infiniband/core/rw.c b/drivers/infiniband/core/rw.c</span>
<span class="p_header">index 1eb9b1294a63..dbfd854c32c9 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/rw.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/rw.c</span>
<span class="p_chunk">@@ -58,19 +58,13 @@</span> <span class="p_context"> static inline bool rdma_rw_io_needs_mr(struct ib_device *dev, u8 port_num,</span>
 	return false;
 }
 
<span class="p_del">-static inline u32 rdma_rw_max_sge(struct ib_device *dev,</span>
<span class="p_del">-		enum dma_data_direction dir)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return dir == DMA_TO_DEVICE ?</span>
<span class="p_del">-		dev-&gt;attrs.max_sge : dev-&gt;attrs.max_sge_rd;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline u32 rdma_rw_fr_page_list_len(struct ib_device *dev)
 {
 	/* arbitrary limit to avoid allocating gigantic resources */
 	return min_t(u32, dev-&gt;attrs.max_fast_reg_page_list_len, 256);
 }
 
<span class="p_add">+/* Caller must have zero-initialized *reg. */</span>
 static int rdma_rw_init_one_mr(struct ib_qp *qp, u8 port_num,
 		struct rdma_rw_reg_ctx *reg, struct scatterlist *sg,
 		u32 sg_cnt, u32 offset)
<span class="p_chunk">@@ -114,6 +108,7 @@</span> <span class="p_context"> static int rdma_rw_init_mr_wrs(struct rdma_rw_ctx *ctx, struct ib_qp *qp,</span>
 		u8 port_num, struct scatterlist *sg, u32 sg_cnt, u32 offset,
 		u64 remote_addr, u32 rkey, enum dma_data_direction dir)
 {
<span class="p_add">+	struct rdma_rw_reg_ctx *prev = NULL;</span>
 	u32 pages_per_mr = rdma_rw_fr_page_list_len(qp-&gt;pd-&gt;device);
 	int i, j, ret = 0, count = 0;
 
<span class="p_chunk">@@ -125,7 +120,6 @@</span> <span class="p_context"> static int rdma_rw_init_mr_wrs(struct rdma_rw_ctx *ctx, struct ib_qp *qp,</span>
 	}
 
 	for (i = 0; i &lt; ctx-&gt;nr_ops; i++) {
<span class="p_del">-		struct rdma_rw_reg_ctx *prev = i ? &amp;ctx-&gt;reg[i - 1] : NULL;</span>
 		struct rdma_rw_reg_ctx *reg = &amp;ctx-&gt;reg[i];
 		u32 nents = min(sg_cnt, pages_per_mr);
 
<span class="p_chunk">@@ -162,9 +156,13 @@</span> <span class="p_context"> static int rdma_rw_init_mr_wrs(struct rdma_rw_ctx *ctx, struct ib_qp *qp,</span>
 		sg_cnt -= nents;
 		for (j = 0; j &lt; nents; j++)
 			sg = sg_next(sg);
<span class="p_add">+		prev = reg;</span>
 		offset = 0;
 	}
 
<span class="p_add">+	if (prev)</span>
<span class="p_add">+		prev-&gt;wr.wr.next = NULL;</span>
<span class="p_add">+</span>
 	ctx-&gt;type = RDMA_RW_MR;
 	return count;
 
<span class="p_chunk">@@ -181,7 +179,8 @@</span> <span class="p_context"> static int rdma_rw_init_map_wrs(struct rdma_rw_ctx *ctx, struct ib_qp *qp,</span>
 		u64 remote_addr, u32 rkey, enum dma_data_direction dir)
 {
 	struct ib_device *dev = qp-&gt;pd-&gt;device;
<span class="p_del">-	u32 max_sge = rdma_rw_max_sge(dev, dir);</span>
<span class="p_add">+	u32 max_sge = dir == DMA_TO_DEVICE ? qp-&gt;max_write_sge :</span>
<span class="p_add">+		      qp-&gt;max_read_sge;</span>
 	struct ib_sge *sge;
 	u32 total_len = 0, i, j;
 
<span class="p_chunk">@@ -205,11 +204,10 @@</span> <span class="p_context"> static int rdma_rw_init_map_wrs(struct rdma_rw_ctx *ctx, struct ib_qp *qp,</span>
 			rdma_wr-&gt;wr.opcode = IB_WR_RDMA_READ;
 		rdma_wr-&gt;remote_addr = remote_addr + total_len;
 		rdma_wr-&gt;rkey = rkey;
<span class="p_add">+		rdma_wr-&gt;wr.num_sge = nr_sge;</span>
 		rdma_wr-&gt;wr.sg_list = sge;
 
 		for (j = 0; j &lt; nr_sge; j++, sg = sg_next(sg)) {
<span class="p_del">-			rdma_wr-&gt;wr.num_sge++;</span>
<span class="p_del">-</span>
 			sge-&gt;addr = ib_sg_dma_address(dev, sg) + offset;
 			sge-&gt;length = ib_sg_dma_len(dev, sg) - offset;
 			sge-&gt;lkey = qp-&gt;pd-&gt;local_dma_lkey;
<span class="p_chunk">@@ -220,8 +218,8 @@</span> <span class="p_context"> static int rdma_rw_init_map_wrs(struct rdma_rw_ctx *ctx, struct ib_qp *qp,</span>
 			offset = 0;
 		}
 
<span class="p_del">-		if (i + 1 &lt; ctx-&gt;nr_ops)</span>
<span class="p_del">-			rdma_wr-&gt;wr.next = &amp;ctx-&gt;map.wrs[i + 1].wr;</span>
<span class="p_add">+		rdma_wr-&gt;wr.next = i + 1 &lt; ctx-&gt;nr_ops ?</span>
<span class="p_add">+			&amp;ctx-&gt;map.wrs[i + 1].wr : NULL;</span>
 	}
 
 	ctx-&gt;type = RDMA_RW_MULTI_WR;
<span class="p_header">diff --git a/drivers/infiniband/core/verbs.c b/drivers/infiniband/core/verbs.c</span>
<span class="p_header">index 6298f54b4137..e39a0b597234 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/verbs.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/verbs.c</span>
<span class="p_chunk">@@ -814,6 +814,15 @@</span> <span class="p_context"> struct ib_qp *ib_create_qp(struct ib_pd *pd,</span>
 		}
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Note: all hw drivers guarantee that max_send_sge is lower than</span>
<span class="p_add">+	 * the device RDMA WRITE SGE limit but not all hw drivers ensure that</span>
<span class="p_add">+	 * max_send_sge &lt;= max_sge_rd.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	qp-&gt;max_write_sge = qp_init_attr-&gt;cap.max_send_sge;</span>
<span class="p_add">+	qp-&gt;max_read_sge = min_t(u32, qp_init_attr-&gt;cap.max_send_sge,</span>
<span class="p_add">+				 device-&gt;attrs.max_sge_rd);</span>
<span class="p_add">+</span>
 	return qp;
 }
 EXPORT_SYMBOL(ib_create_qp);
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/gsi.c b/drivers/infiniband/hw/mlx5/gsi.c</span>
<span class="p_header">index 53e03c8ede79..79e6309460dc 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/gsi.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/gsi.c</span>
<span class="p_chunk">@@ -69,15 +69,6 @@</span> <span class="p_context"> static bool mlx5_ib_deth_sqpn_cap(struct mlx5_ib_dev *dev)</span>
 	return MLX5_CAP_GEN(dev-&gt;mdev, set_deth_sqpn);
 }
 
<span class="p_del">-static u32 next_outstanding(struct mlx5_ib_gsi_qp *gsi, u32 index)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return ++index % gsi-&gt;cap.max_send_wr;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#define for_each_outstanding_wr(gsi, index) \</span>
<span class="p_del">-	for (index = gsi-&gt;outstanding_ci; index != gsi-&gt;outstanding_pi; \</span>
<span class="p_del">-	     index = next_outstanding(gsi, index))</span>
<span class="p_del">-</span>
 /* Call with gsi-&gt;lock locked */
 static void generate_completions(struct mlx5_ib_gsi_qp *gsi)
 {
<span class="p_chunk">@@ -85,8 +76,9 @@</span> <span class="p_context"> static void generate_completions(struct mlx5_ib_gsi_qp *gsi)</span>
 	struct mlx5_ib_gsi_wr *wr;
 	u32 index;
 
<span class="p_del">-	for_each_outstanding_wr(gsi, index) {</span>
<span class="p_del">-		wr = &amp;gsi-&gt;outstanding_wrs[index];</span>
<span class="p_add">+	for (index = gsi-&gt;outstanding_ci; index != gsi-&gt;outstanding_pi;</span>
<span class="p_add">+	     index++) {</span>
<span class="p_add">+		wr = &amp;gsi-&gt;outstanding_wrs[index % gsi-&gt;cap.max_send_wr];</span>
 
 		if (!wr-&gt;completed)
 			break;
<span class="p_chunk">@@ -430,8 +422,9 @@</span> <span class="p_context"> static int mlx5_ib_add_outstanding_wr(struct mlx5_ib_gsi_qp *gsi,</span>
 		return -ENOMEM;
 	}
 
<span class="p_del">-	gsi_wr = &amp;gsi-&gt;outstanding_wrs[gsi-&gt;outstanding_pi];</span>
<span class="p_del">-	gsi-&gt;outstanding_pi = next_outstanding(gsi, gsi-&gt;outstanding_pi);</span>
<span class="p_add">+	gsi_wr = &amp;gsi-&gt;outstanding_wrs[gsi-&gt;outstanding_pi %</span>
<span class="p_add">+				       gsi-&gt;cap.max_send_wr];</span>
<span class="p_add">+	gsi-&gt;outstanding_pi++;</span>
 
 	if (!wc) {
 		memset(&amp;gsi_wr-&gt;wc, 0, sizeof(gsi_wr-&gt;wc));
<span class="p_header">diff --git a/drivers/infiniband/sw/rdmavt/Kconfig b/drivers/infiniband/sw/rdmavt/Kconfig</span>
<span class="p_header">index 11aa6a34bd71..1da8d01a6855 100644</span>
<span class="p_header">--- a/drivers/infiniband/sw/rdmavt/Kconfig</span>
<span class="p_header">+++ b/drivers/infiniband/sw/rdmavt/Kconfig</span>
<span class="p_chunk">@@ -1,6 +1,5 @@</span> <span class="p_context"></span>
 config INFINIBAND_RDMAVT
 	tristate &quot;RDMA verbs transport library&quot;
 	depends on 64BIT
<span class="p_del">-	default m</span>
 	---help---
 	This is a common software verbs provider for RDMA networks.
<span class="p_header">diff --git a/drivers/infiniband/sw/rdmavt/cq.c b/drivers/infiniband/sw/rdmavt/cq.c</span>
<span class="p_header">index 6ca6fa80dd6e..f2f229efbe64 100644</span>
<span class="p_header">--- a/drivers/infiniband/sw/rdmavt/cq.c</span>
<span class="p_header">+++ b/drivers/infiniband/sw/rdmavt/cq.c</span>
<span class="p_chunk">@@ -510,6 +510,7 @@</span> <span class="p_context"> int rvt_driver_cq_init(struct rvt_dev_info *rdi)</span>
 
 	if (rdi-&gt;worker)
 		return 0;
<span class="p_add">+	spin_lock_init(&amp;rdi-&gt;n_cqs_lock);</span>
 	rdi-&gt;worker = kzalloc(sizeof(*rdi-&gt;worker), GFP_KERNEL);
 	if (!rdi-&gt;worker)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/infiniband/ulp/srpt/ib_srpt.c b/drivers/infiniband/ulp/srpt/ib_srpt.c</span>
<span class="p_header">index 4a4155640d51..9a3b954e862d 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/srpt/ib_srpt.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/srpt/ib_srpt.c</span>
<span class="p_chunk">@@ -1601,6 +1601,7 @@</span> <span class="p_context"> static int srpt_create_ch_ib(struct srpt_rdma_ch *ch)</span>
 	struct ib_qp_init_attr *qp_init;
 	struct srpt_port *sport = ch-&gt;sport;
 	struct srpt_device *sdev = sport-&gt;sdev;
<span class="p_add">+	const struct ib_device_attr *attrs = &amp;sdev-&gt;device-&gt;attrs;</span>
 	u32 srp_sq_size = sport-&gt;port_attrib.srp_sq_size;
 	int ret;
 
<span class="p_chunk">@@ -1638,7 +1639,7 @@</span> <span class="p_context"> retry:</span>
 	 */
 	qp_init-&gt;cap.max_send_wr = srp_sq_size / 2;
 	qp_init-&gt;cap.max_rdma_ctxs = srp_sq_size / 2;
<span class="p_del">-	qp_init-&gt;cap.max_send_sge = SRPT_DEF_SG_PER_WQE;</span>
<span class="p_add">+	qp_init-&gt;cap.max_send_sge = min(attrs-&gt;max_sge, SRPT_MAX_SG_PER_WQE);</span>
 	qp_init-&gt;port_num = ch-&gt;sport-&gt;port;
 
 	ch-&gt;qp = ib_create_qp(sdev-&gt;pd, qp_init);
<span class="p_header">diff --git a/drivers/infiniband/ulp/srpt/ib_srpt.h b/drivers/infiniband/ulp/srpt/ib_srpt.h</span>
<span class="p_header">index 389030487da7..581878782854 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/srpt/ib_srpt.h</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/srpt/ib_srpt.h</span>
<span class="p_chunk">@@ -106,7 +106,11 @@</span> <span class="p_context"> enum {</span>
 	SRP_LOGIN_RSP_MULTICHAN_MAINTAINED = 0x2,
 
 	SRPT_DEF_SG_TABLESIZE = 128,
<span class="p_del">-	SRPT_DEF_SG_PER_WQE = 16,</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * An experimentally determined value that avoids that QP creation</span>
<span class="p_add">+	 * fails due to &quot;swiotlb buffer is full&quot; on systems using the swiotlb.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	SRPT_MAX_SG_PER_WQE = 16,</span>
 
 	MIN_SRPT_SQ_SIZE = 16,
 	DEF_SRPT_SQ_SIZE = 4096,
<span class="p_header">diff --git a/drivers/input/mouse/elan_i2c_core.c b/drivers/input/mouse/elan_i2c_core.c</span>
<span class="p_header">index 2f589857a039..d15b33813021 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elan_i2c_core.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elan_i2c_core.c</span>
<span class="p_chunk">@@ -4,7 +4,8 @@</span> <span class="p_context"></span>
  * Copyright (c) 2013 ELAN Microelectronics Corp.
  *
  * Author: 林政維 (Duson Lin) &lt;dusonlin@emc.com.tw&gt;
<span class="p_del">- * Version: 1.6.0</span>
<span class="p_add">+ * Author: KT Liao &lt;kt.liao@emc.com.tw&gt;</span>
<span class="p_add">+ * Version: 1.6.2</span>
  *
  * Based on cyapa driver:
  * copyright (c) 2011-2012 Cypress Semiconductor, Inc.
<span class="p_chunk">@@ -40,7 +41,7 @@</span> <span class="p_context"></span>
 #include &quot;elan_i2c.h&quot;
 
 #define DRIVER_NAME		&quot;elan_i2c&quot;
<span class="p_del">-#define ELAN_DRIVER_VERSION	&quot;1.6.1&quot;</span>
<span class="p_add">+#define ELAN_DRIVER_VERSION	&quot;1.6.2&quot;</span>
 #define ELAN_VENDOR_ID		0x04f3
 #define ETP_MAX_PRESSURE	255
 #define ETP_FWIDTH_REDUCE	90
<span class="p_chunk">@@ -199,9 +200,41 @@</span> <span class="p_context"> static int elan_sleep(struct elan_tp_data *data)</span>
 	return error;
 }
 
<span class="p_add">+static int elan_query_product(struct elan_tp_data *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int error;</span>
<span class="p_add">+</span>
<span class="p_add">+	error = data-&gt;ops-&gt;get_product_id(data-&gt;client, &amp;data-&gt;product_id);</span>
<span class="p_add">+	if (error)</span>
<span class="p_add">+		return error;</span>
<span class="p_add">+</span>
<span class="p_add">+	error = data-&gt;ops-&gt;get_sm_version(data-&gt;client, &amp;data-&gt;ic_type,</span>
<span class="p_add">+					  &amp;data-&gt;sm_version);</span>
<span class="p_add">+	if (error)</span>
<span class="p_add">+		return error;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int elan_check_ASUS_special_fw(struct elan_tp_data *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (data-&gt;ic_type != 0x0E)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (data-&gt;product_id) {</span>
<span class="p_add">+	case 0x05 ... 0x07:</span>
<span class="p_add">+	case 0x09:</span>
<span class="p_add">+	case 0x13:</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int __elan_initialize(struct elan_tp_data *data)
 {
 	struct i2c_client *client = data-&gt;client;
<span class="p_add">+	bool woken_up = false;</span>
 	int error;
 
 	error = data-&gt;ops-&gt;initialize(client);
<span class="p_chunk">@@ -210,6 +243,27 @@</span> <span class="p_context"> static int __elan_initialize(struct elan_tp_data *data)</span>
 		return error;
 	}
 
<span class="p_add">+	error = elan_query_product(data);</span>
<span class="p_add">+	if (error)</span>
<span class="p_add">+		return error;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Some ASUS devices were shipped with firmware that requires</span>
<span class="p_add">+	 * touchpads to be woken up first, before attempting to switch</span>
<span class="p_add">+	 * them into absolute reporting mode.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (elan_check_ASUS_special_fw(data)) {</span>
<span class="p_add">+		error = data-&gt;ops-&gt;sleep_control(client, false);</span>
<span class="p_add">+		if (error) {</span>
<span class="p_add">+			dev_err(&amp;client-&gt;dev,</span>
<span class="p_add">+				&quot;failed to wake device up: %d\n&quot;, error);</span>
<span class="p_add">+			return error;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		msleep(200);</span>
<span class="p_add">+		woken_up = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	data-&gt;mode |= ETP_ENABLE_ABS;
 	error = data-&gt;ops-&gt;set_mode(client, data-&gt;mode);
 	if (error) {
<span class="p_chunk">@@ -218,11 +272,13 @@</span> <span class="p_context"> static int __elan_initialize(struct elan_tp_data *data)</span>
 		return error;
 	}
 
<span class="p_del">-	error = data-&gt;ops-&gt;sleep_control(client, false);</span>
<span class="p_del">-	if (error) {</span>
<span class="p_del">-		dev_err(&amp;client-&gt;dev,</span>
<span class="p_del">-			&quot;failed to wake device up: %d\n&quot;, error);</span>
<span class="p_del">-		return error;</span>
<span class="p_add">+	if (!woken_up) {</span>
<span class="p_add">+		error = data-&gt;ops-&gt;sleep_control(client, false);</span>
<span class="p_add">+		if (error) {</span>
<span class="p_add">+			dev_err(&amp;client-&gt;dev,</span>
<span class="p_add">+				&quot;failed to wake device up: %d\n&quot;, error);</span>
<span class="p_add">+			return error;</span>
<span class="p_add">+		}</span>
 	}
 
 	return 0;
<span class="p_chunk">@@ -248,10 +304,6 @@</span> <span class="p_context"> static int elan_query_device_info(struct elan_tp_data *data)</span>
 {
 	int error;
 
<span class="p_del">-	error = data-&gt;ops-&gt;get_product_id(data-&gt;client, &amp;data-&gt;product_id);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		return error;</span>
<span class="p_del">-</span>
 	error = data-&gt;ops-&gt;get_version(data-&gt;client, false, &amp;data-&gt;fw_version);
 	if (error)
 		return error;
<span class="p_chunk">@@ -261,11 +313,6 @@</span> <span class="p_context"> static int elan_query_device_info(struct elan_tp_data *data)</span>
 	if (error)
 		return error;
 
<span class="p_del">-	error = data-&gt;ops-&gt;get_sm_version(data-&gt;client, &amp;data-&gt;ic_type,</span>
<span class="p_del">-					  &amp;data-&gt;sm_version);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		return error;</span>
<span class="p_del">-</span>
 	error = data-&gt;ops-&gt;get_version(data-&gt;client, true, &amp;data-&gt;iap_version);
 	if (error)
 		return error;
<span class="p_header">diff --git a/drivers/input/touchscreen/sur40.c b/drivers/input/touchscreen/sur40.c</span>
<span class="p_header">index 880c40b23f66..b7e8c11a6fc2 100644</span>
<span class="p_header">--- a/drivers/input/touchscreen/sur40.c</span>
<span class="p_header">+++ b/drivers/input/touchscreen/sur40.c</span>
<span class="p_chunk">@@ -126,7 +126,7 @@</span> <span class="p_context"> struct sur40_image_header {</span>
 #define VIDEO_PACKET_SIZE  16384
 
 /* polling interval (ms) */
<span class="p_del">-#define POLL_INTERVAL 4</span>
<span class="p_add">+#define POLL_INTERVAL 1</span>
 
 /* maximum number of contacts FIXME: this is a guess? */
 #define MAX_CONTACTS 64
<span class="p_chunk">@@ -448,7 +448,7 @@</span> <span class="p_context"> static void sur40_process_video(struct sur40_state *sur40)</span>
 
 	/* return error if streaming was stopped in the meantime */
 	if (sur40-&gt;sequence == -1)
<span class="p_del">-		goto err_poll;</span>
<span class="p_add">+		return;</span>
 
 	/* mark as finished */
 	new_buf-&gt;vb.vb2_buf.timestamp = ktime_get_ns();
<span class="p_chunk">@@ -736,6 +736,7 @@</span> <span class="p_context"> static int sur40_start_streaming(struct vb2_queue *vq, unsigned int count)</span>
 static void sur40_stop_streaming(struct vb2_queue *vq)
 {
 	struct sur40_state *sur40 = vb2_get_drv_priv(vq);
<span class="p_add">+	vb2_wait_for_all_buffers(vq);</span>
 	sur40-&gt;sequence = -1;
 
 	/* Release all active buffers */
<span class="p_header">diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c</span>
<span class="p_header">index 634f636393d5..2511c8b6aada 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu.c</span>
<span class="p_chunk">@@ -466,9 +466,11 @@</span> <span class="p_context"> static void init_iommu_group(struct device *dev)</span>
 	if (!domain)
 		goto out;
 
<span class="p_del">-	dma_domain = to_pdomain(domain)-&gt;priv;</span>
<span class="p_add">+	if (to_pdomain(domain)-&gt;flags == PD_DMA_OPS_MASK) {</span>
<span class="p_add">+		dma_domain = to_pdomain(domain)-&gt;priv;</span>
<span class="p_add">+		init_unity_mappings_for_device(dev, dma_domain);</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	init_unity_mappings_for_device(dev, dma_domain);</span>
 out:
 	iommu_group_put(group);
 }
<span class="p_chunk">@@ -2512,8 +2514,15 @@</span> <span class="p_context"> static void update_device_table(struct protection_domain *domain)</span>
 {
 	struct iommu_dev_data *dev_data;
 
<span class="p_del">-	list_for_each_entry(dev_data, &amp;domain-&gt;dev_list, list)</span>
<span class="p_add">+	list_for_each_entry(dev_data, &amp;domain-&gt;dev_list, list) {</span>
 		set_dte_entry(dev_data-&gt;devid, domain, dev_data-&gt;ats.enabled);
<span class="p_add">+</span>
<span class="p_add">+		if (dev_data-&gt;devid == dev_data-&gt;alias)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* There is an alias, update device table entry for it */</span>
<span class="p_add">+		set_dte_entry(dev_data-&gt;alias, domain, dev_data-&gt;ats.enabled);</span>
<span class="p_add">+	}</span>
 }
 
 static void update_domain(struct protection_domain *domain)
<span class="p_chunk">@@ -3103,9 +3112,7 @@</span> <span class="p_context"> static struct iommu_domain *amd_iommu_domain_alloc(unsigned type)</span>
 static void amd_iommu_domain_free(struct iommu_domain *dom)
 {
 	struct protection_domain *domain;
<span class="p_del">-</span>
<span class="p_del">-	if (!dom)</span>
<span class="p_del">-		return;</span>
<span class="p_add">+	struct dma_ops_domain *dma_dom;</span>
 
 	domain = to_pdomain(dom);
 
<span class="p_chunk">@@ -3114,13 +3121,24 @@</span> <span class="p_context"> static void amd_iommu_domain_free(struct iommu_domain *dom)</span>
 
 	BUG_ON(domain-&gt;dev_cnt != 0);
 
<span class="p_del">-	if (domain-&gt;mode != PAGE_MODE_NONE)</span>
<span class="p_del">-		free_pagetable(domain);</span>
<span class="p_add">+	if (!dom)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (dom-&gt;type) {</span>
<span class="p_add">+	case IOMMU_DOMAIN_DMA:</span>
<span class="p_add">+		dma_dom = domain-&gt;priv;</span>
<span class="p_add">+		dma_ops_domain_free(dma_dom);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		if (domain-&gt;mode != PAGE_MODE_NONE)</span>
<span class="p_add">+			free_pagetable(domain);</span>
 
<span class="p_del">-	if (domain-&gt;flags &amp; PD_IOMMUV2_MASK)</span>
<span class="p_del">-		free_gcr3_table(domain);</span>
<span class="p_add">+		if (domain-&gt;flags &amp; PD_IOMMUV2_MASK)</span>
<span class="p_add">+			free_gcr3_table(domain);</span>
 
<span class="p_del">-	protection_domain_free(domain);</span>
<span class="p_add">+		protection_domain_free(domain);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 }
 
 static void amd_iommu_detach_device(struct iommu_domain *dom,
<span class="p_header">diff --git a/drivers/iommu/exynos-iommu.c b/drivers/iommu/exynos-iommu.c</span>
<span class="p_header">index 5ecc86cb74c8..e27e3b7df4e7 100644</span>
<span class="p_header">--- a/drivers/iommu/exynos-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/exynos-iommu.c</span>
<span class="p_chunk">@@ -709,6 +709,7 @@</span> <span class="p_context"> static struct platform_driver exynos_sysmmu_driver __refdata = {</span>
 		.name		= &quot;exynos-sysmmu&quot;,
 		.of_match_table	= sysmmu_of_match,
 		.pm		= &amp;sysmmu_pm_ops,
<span class="p_add">+		.suppress_bind_attrs = true,</span>
 	}
 };
 
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index 323dac9900ba..d416242c4ab8 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -2076,7 +2076,7 @@</span> <span class="p_context"> out_unlock:</span>
 	spin_unlock(&amp;iommu-&gt;lock);
 	spin_unlock_irqrestore(&amp;device_domain_lock, flags);
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return ret;</span>
 }
 
 struct domain_context_mapping_data {
<span class="p_header">diff --git a/drivers/iommu/io-pgtable-arm.c b/drivers/iommu/io-pgtable-arm.c</span>
<span class="p_header">index a1ed1b73fed4..f5c90e1366ce 100644</span>
<span class="p_header">--- a/drivers/iommu/io-pgtable-arm.c</span>
<span class="p_header">+++ b/drivers/iommu/io-pgtable-arm.c</span>
<span class="p_chunk">@@ -576,7 +576,7 @@</span> <span class="p_context"> static phys_addr_t arm_lpae_iova_to_phys(struct io_pgtable_ops *ops,</span>
 	return 0;
 
 found_translation:
<span class="p_del">-	iova &amp;= (ARM_LPAE_GRANULE(data) - 1);</span>
<span class="p_add">+	iova &amp;= (ARM_LPAE_BLOCK_SIZE(lvl, data) - 1);</span>
 	return ((phys_addr_t)iopte_to_pfn(pte,data) &lt;&lt; data-&gt;pg_shift) | iova;
 }
 
<span class="p_header">diff --git a/drivers/md/dm-flakey.c b/drivers/md/dm-flakey.c</span>
<span class="p_header">index b7341de87015..4bb49cd602e9 100644</span>
<span class="p_header">--- a/drivers/md/dm-flakey.c</span>
<span class="p_header">+++ b/drivers/md/dm-flakey.c</span>
<span class="p_chunk">@@ -289,10 +289,16 @@</span> <span class="p_context"> static int flakey_map(struct dm_target *ti, struct bio *bio)</span>
 		pb-&gt;bio_submitted = true;
 
 		/*
<span class="p_del">-		 * Map reads as normal.</span>
<span class="p_add">+		 * Map reads as normal only if corrupt_bio_byte set.</span>
 		 */
<span class="p_del">-		if (bio_data_dir(bio) == READ)</span>
<span class="p_del">-			goto map_bio;</span>
<span class="p_add">+		if (bio_data_dir(bio) == READ) {</span>
<span class="p_add">+			/* If flags were specified, only corrupt those that match. */</span>
<span class="p_add">+			if (fc-&gt;corrupt_bio_byte &amp;&amp; (fc-&gt;corrupt_bio_rw == READ) &amp;&amp;</span>
<span class="p_add">+			    all_corrupt_bio_flags_match(bio, fc))</span>
<span class="p_add">+				goto map_bio;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				return -EIO;</span>
<span class="p_add">+		}</span>
 
 		/*
 		 * Drop writes?
<span class="p_chunk">@@ -330,12 +336,13 @@</span> <span class="p_context"> static int flakey_end_io(struct dm_target *ti, struct bio *bio, int error)</span>
 
 	/*
 	 * Corrupt successful READs while in down state.
<span class="p_del">-	 * If flags were specified, only corrupt those that match.</span>
 	 */
<span class="p_del">-	if (fc-&gt;corrupt_bio_byte &amp;&amp; !error &amp;&amp; pb-&gt;bio_submitted &amp;&amp;</span>
<span class="p_del">-	    (bio_data_dir(bio) == READ) &amp;&amp; (fc-&gt;corrupt_bio_rw == READ) &amp;&amp;</span>
<span class="p_del">-	    all_corrupt_bio_flags_match(bio, fc))</span>
<span class="p_del">-		corrupt_bio_data(bio, fc);</span>
<span class="p_add">+	if (!error &amp;&amp; pb-&gt;bio_submitted &amp;&amp; (bio_data_dir(bio) == READ)) {</span>
<span class="p_add">+		if (fc-&gt;corrupt_bio_byte)</span>
<span class="p_add">+			corrupt_bio_data(bio, fc);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			return -EIO;</span>
<span class="p_add">+	}</span>
 
 	return error;
 }
<span class="p_header">diff --git a/drivers/md/dm-verity-fec.c b/drivers/md/dm-verity-fec.c</span>
<span class="p_header">index 459a9f8905ed..0f0eb8a3d922 100644</span>
<span class="p_header">--- a/drivers/md/dm-verity-fec.c</span>
<span class="p_header">+++ b/drivers/md/dm-verity-fec.c</span>
<span class="p_chunk">@@ -453,9 +453,7 @@</span> <span class="p_context"> int verity_fec_decode(struct dm_verity *v, struct dm_verity_io *io,</span>
 	 */
 
 	offset = block &lt;&lt; v-&gt;data_dev_block_bits;
<span class="p_del">-</span>
<span class="p_del">-	res = offset;</span>
<span class="p_del">-	div64_u64(res, v-&gt;fec-&gt;rounds &lt;&lt; v-&gt;data_dev_block_bits);</span>
<span class="p_add">+	res = div64_u64(offset, v-&gt;fec-&gt;rounds &lt;&lt; v-&gt;data_dev_block_bits);</span>
 
 	/*
 	 * The base RS block we can feed to the interleaver to find out all
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index 1b2f96205361..fd40bcb3937d 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -2175,7 +2175,7 @@</span> <span class="p_context"> static void dm_request_fn(struct request_queue *q)</span>
 		     md_in_flight(md) &amp;&amp; rq-&gt;bio &amp;&amp; rq-&gt;bio-&gt;bi_vcnt == 1 &amp;&amp;
 		     md-&gt;last_rq_pos == pos &amp;&amp; md-&gt;last_rq_rw == rq_data_dir(rq)) ||
 		    (ti-&gt;type-&gt;busy &amp;&amp; ti-&gt;type-&gt;busy(ti))) {
<span class="p_del">-			blk_delay_queue(q, HZ / 100);</span>
<span class="p_add">+			blk_delay_queue(q, 10);</span>
 			return;
 		}
 
<span class="p_chunk">@@ -3128,7 +3128,8 @@</span> <span class="p_context"> static void unlock_fs(struct mapped_device *md)</span>
  * Caller must hold md-&gt;suspend_lock
  */
 static int __dm_suspend(struct mapped_device *md, struct dm_table *map,
<span class="p_del">-			unsigned suspend_flags, int interruptible)</span>
<span class="p_add">+			unsigned suspend_flags, int interruptible,</span>
<span class="p_add">+			int dmf_suspended_flag)</span>
 {
 	bool do_lockfs = suspend_flags &amp; DM_SUSPEND_LOCKFS_FLAG;
 	bool noflush = suspend_flags &amp; DM_SUSPEND_NOFLUSH_FLAG;
<span class="p_chunk">@@ -3195,6 +3196,8 @@</span> <span class="p_context"> static int __dm_suspend(struct mapped_device *md, struct dm_table *map,</span>
 	 * to finish.
 	 */
 	r = dm_wait_for_completion(md, interruptible);
<span class="p_add">+	if (!r)</span>
<span class="p_add">+		set_bit(dmf_suspended_flag, &amp;md-&gt;flags);</span>
 
 	if (noflush)
 		clear_bit(DMF_NOFLUSH_SUSPENDING, &amp;md-&gt;flags);
<span class="p_chunk">@@ -3256,12 +3259,10 @@</span> <span class="p_context"> retry:</span>
 
 	map = rcu_dereference_protected(md-&gt;map, lockdep_is_held(&amp;md-&gt;suspend_lock));
 
<span class="p_del">-	r = __dm_suspend(md, map, suspend_flags, TASK_INTERRUPTIBLE);</span>
<span class="p_add">+	r = __dm_suspend(md, map, suspend_flags, TASK_INTERRUPTIBLE, DMF_SUSPENDED);</span>
 	if (r)
 		goto out_unlock;
 
<span class="p_del">-	set_bit(DMF_SUSPENDED, &amp;md-&gt;flags);</span>
<span class="p_del">-</span>
 	dm_table_postsuspend_targets(map);
 
 out_unlock:
<span class="p_chunk">@@ -3355,9 +3356,8 @@</span> <span class="p_context"> static void __dm_internal_suspend(struct mapped_device *md, unsigned suspend_fla</span>
 	 * would require changing .presuspend to return an error -- avoid this
 	 * until there is a need for more elaborate variants of internal suspend.
 	 */
<span class="p_del">-	(void) __dm_suspend(md, map, suspend_flags, TASK_UNINTERRUPTIBLE);</span>
<span class="p_del">-</span>
<span class="p_del">-	set_bit(DMF_SUSPENDED_INTERNALLY, &amp;md-&gt;flags);</span>
<span class="p_add">+	(void) __dm_suspend(md, map, suspend_flags, TASK_UNINTERRUPTIBLE,</span>
<span class="p_add">+			    DMF_SUSPENDED_INTERNALLY);</span>
 
 	dm_table_postsuspend_targets(map);
 }
<span class="p_header">diff --git a/drivers/media/dvb-core/dvb_ringbuffer.c b/drivers/media/dvb-core/dvb_ringbuffer.c</span>
<span class="p_header">index 1100e98a7b1d..7df7fb3738a0 100644</span>
<span class="p_header">--- a/drivers/media/dvb-core/dvb_ringbuffer.c</span>
<span class="p_header">+++ b/drivers/media/dvb-core/dvb_ringbuffer.c</span>
<span class="p_chunk">@@ -55,7 +55,13 @@</span> <span class="p_context"> void dvb_ringbuffer_init(struct dvb_ringbuffer *rbuf, void *data, size_t len)</span>
 
 int dvb_ringbuffer_empty(struct dvb_ringbuffer *rbuf)
 {
<span class="p_del">-	return (rbuf-&gt;pread==rbuf-&gt;pwrite);</span>
<span class="p_add">+	/* smp_load_acquire() to load write pointer on reader side</span>
<span class="p_add">+	 * this pairs with smp_store_release() in dvb_ringbuffer_write(),</span>
<span class="p_add">+	 * dvb_ringbuffer_write_user(), or dvb_ringbuffer_reset()</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * for memory barriers also see Documentation/circular-buffers.txt</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return (rbuf-&gt;pread == smp_load_acquire(&amp;rbuf-&gt;pwrite));</span>
 }
 
 
<span class="p_chunk">@@ -64,7 +70,12 @@</span> <span class="p_context"> ssize_t dvb_ringbuffer_free(struct dvb_ringbuffer *rbuf)</span>
 {
 	ssize_t free;
 
<span class="p_del">-	free = rbuf-&gt;pread - rbuf-&gt;pwrite;</span>
<span class="p_add">+	/* ACCESS_ONCE() to load read pointer on writer side</span>
<span class="p_add">+	 * this pairs with smp_store_release() in dvb_ringbuffer_read(),</span>
<span class="p_add">+	 * dvb_ringbuffer_read_user(), dvb_ringbuffer_flush(),</span>
<span class="p_add">+	 * or dvb_ringbuffer_reset()</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	free = ACCESS_ONCE(rbuf-&gt;pread) - rbuf-&gt;pwrite;</span>
 	if (free &lt;= 0)
 		free += rbuf-&gt;size;
 	return free-1;
<span class="p_chunk">@@ -76,7 +87,11 @@</span> <span class="p_context"> ssize_t dvb_ringbuffer_avail(struct dvb_ringbuffer *rbuf)</span>
 {
 	ssize_t avail;
 
<span class="p_del">-	avail = rbuf-&gt;pwrite - rbuf-&gt;pread;</span>
<span class="p_add">+	/* smp_load_acquire() to load write pointer on reader side</span>
<span class="p_add">+	 * this pairs with smp_store_release() in dvb_ringbuffer_write(),</span>
<span class="p_add">+	 * dvb_ringbuffer_write_user(), or dvb_ringbuffer_reset()</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	avail = smp_load_acquire(&amp;rbuf-&gt;pwrite) - rbuf-&gt;pread;</span>
 	if (avail &lt; 0)
 		avail += rbuf-&gt;size;
 	return avail;
<span class="p_chunk">@@ -86,14 +101,25 @@</span> <span class="p_context"> ssize_t dvb_ringbuffer_avail(struct dvb_ringbuffer *rbuf)</span>
 
 void dvb_ringbuffer_flush(struct dvb_ringbuffer *rbuf)
 {
<span class="p_del">-	rbuf-&gt;pread = rbuf-&gt;pwrite;</span>
<span class="p_add">+	/* dvb_ringbuffer_flush() counts as read operation</span>
<span class="p_add">+	 * smp_load_acquire() to load write pointer</span>
<span class="p_add">+	 * smp_store_release() to update read pointer, this ensures that the</span>
<span class="p_add">+	 * correct pointer is visible for subsequent dvb_ringbuffer_free()</span>
<span class="p_add">+	 * calls on other cpu cores</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_store_release(&amp;rbuf-&gt;pread, smp_load_acquire(&amp;rbuf-&gt;pwrite));</span>
 	rbuf-&gt;error = 0;
 }
 EXPORT_SYMBOL(dvb_ringbuffer_flush);
 
 void dvb_ringbuffer_reset(struct dvb_ringbuffer *rbuf)
 {
<span class="p_del">-	rbuf-&gt;pread = rbuf-&gt;pwrite = 0;</span>
<span class="p_add">+	/* dvb_ringbuffer_reset() counts as read and write operation</span>
<span class="p_add">+	 * smp_store_release() to update read pointer</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_store_release(&amp;rbuf-&gt;pread, 0);</span>
<span class="p_add">+	/* smp_store_release() to update write pointer */</span>
<span class="p_add">+	smp_store_release(&amp;rbuf-&gt;pwrite, 0);</span>
 	rbuf-&gt;error = 0;
 }
 
<span class="p_chunk">@@ -119,12 +145,17 @@</span> <span class="p_context"> ssize_t dvb_ringbuffer_read_user(struct dvb_ringbuffer *rbuf, u8 __user *buf, si</span>
 			return -EFAULT;
 		buf += split;
 		todo -= split;
<span class="p_del">-		rbuf-&gt;pread = 0;</span>
<span class="p_add">+		/* smp_store_release() for read pointer update to ensure</span>
<span class="p_add">+		 * that buf is not overwritten until read is complete,</span>
<span class="p_add">+		 * this pairs with ACCESS_ONCE() in dvb_ringbuffer_free()</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smp_store_release(&amp;rbuf-&gt;pread, 0);</span>
 	}
 	if (copy_to_user(buf, rbuf-&gt;data+rbuf-&gt;pread, todo))
 		return -EFAULT;
 
<span class="p_del">-	rbuf-&gt;pread = (rbuf-&gt;pread + todo) % rbuf-&gt;size;</span>
<span class="p_add">+	/* smp_store_release() to update read pointer, see above */</span>
<span class="p_add">+	smp_store_release(&amp;rbuf-&gt;pread, (rbuf-&gt;pread + todo) % rbuf-&gt;size);</span>
 
 	return len;
 }
<span class="p_chunk">@@ -139,11 +170,16 @@</span> <span class="p_context"> void dvb_ringbuffer_read(struct dvb_ringbuffer *rbuf, u8 *buf, size_t len)</span>
 		memcpy(buf, rbuf-&gt;data+rbuf-&gt;pread, split);
 		buf += split;
 		todo -= split;
<span class="p_del">-		rbuf-&gt;pread = 0;</span>
<span class="p_add">+		/* smp_store_release() for read pointer update to ensure</span>
<span class="p_add">+		 * that buf is not overwritten until read is complete,</span>
<span class="p_add">+		 * this pairs with ACCESS_ONCE() in dvb_ringbuffer_free()</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smp_store_release(&amp;rbuf-&gt;pread, 0);</span>
 	}
 	memcpy(buf, rbuf-&gt;data+rbuf-&gt;pread, todo);
 
<span class="p_del">-	rbuf-&gt;pread = (rbuf-&gt;pread + todo) % rbuf-&gt;size;</span>
<span class="p_add">+	/* smp_store_release() to update read pointer, see above */</span>
<span class="p_add">+	smp_store_release(&amp;rbuf-&gt;pread, (rbuf-&gt;pread + todo) % rbuf-&gt;size);</span>
 }
 
 
<span class="p_chunk">@@ -158,10 +194,16 @@</span> <span class="p_context"> ssize_t dvb_ringbuffer_write(struct dvb_ringbuffer *rbuf, const u8 *buf, size_t</span>
 		memcpy(rbuf-&gt;data+rbuf-&gt;pwrite, buf, split);
 		buf += split;
 		todo -= split;
<span class="p_del">-		rbuf-&gt;pwrite = 0;</span>
<span class="p_add">+		/* smp_store_release() for write pointer update to ensure that</span>
<span class="p_add">+		 * written data is visible on other cpu cores before the pointer</span>
<span class="p_add">+		 * update, this pairs with smp_load_acquire() in</span>
<span class="p_add">+		 * dvb_ringbuffer_empty() or dvb_ringbuffer_avail()</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smp_store_release(&amp;rbuf-&gt;pwrite, 0);</span>
 	}
 	memcpy(rbuf-&gt;data+rbuf-&gt;pwrite, buf, todo);
<span class="p_del">-	rbuf-&gt;pwrite = (rbuf-&gt;pwrite + todo) % rbuf-&gt;size;</span>
<span class="p_add">+	/* smp_store_release() for write pointer update, see above */</span>
<span class="p_add">+	smp_store_release(&amp;rbuf-&gt;pwrite, (rbuf-&gt;pwrite + todo) % rbuf-&gt;size);</span>
 
 	return len;
 }
<span class="p_chunk">@@ -181,12 +223,18 @@</span> <span class="p_context"> ssize_t dvb_ringbuffer_write_user(struct dvb_ringbuffer *rbuf,</span>
 			return len - todo;
 		buf += split;
 		todo -= split;
<span class="p_del">-		rbuf-&gt;pwrite = 0;</span>
<span class="p_add">+		/* smp_store_release() for write pointer update to ensure that</span>
<span class="p_add">+		 * written data is visible on other cpu cores before the pointer</span>
<span class="p_add">+		 * update, this pairs with smp_load_acquire() in</span>
<span class="p_add">+		 * dvb_ringbuffer_empty() or dvb_ringbuffer_avail()</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smp_store_release(&amp;rbuf-&gt;pwrite, 0);</span>
 	}
 	status = copy_from_user(rbuf-&gt;data+rbuf-&gt;pwrite, buf, todo);
 	if (status)
 		return len - todo;
<span class="p_del">-	rbuf-&gt;pwrite = (rbuf-&gt;pwrite + todo) % rbuf-&gt;size;</span>
<span class="p_add">+	/* smp_store_release() for write pointer update, see above */</span>
<span class="p_add">+	smp_store_release(&amp;rbuf-&gt;pwrite, (rbuf-&gt;pwrite + todo) % rbuf-&gt;size);</span>
 
 	return len;
 }
<span class="p_header">diff --git a/drivers/media/platform/s5p-mfc/s5p_mfc.c b/drivers/media/platform/s5p-mfc/s5p_mfc.c</span>
<span class="p_header">index b16466fe35ee..beb4fd5bd326 100644</span>
<span class="p_header">--- a/drivers/media/platform/s5p-mfc/s5p_mfc.c</span>
<span class="p_header">+++ b/drivers/media/platform/s5p-mfc/s5p_mfc.c</span>
<span class="p_chunk">@@ -1050,6 +1050,11 @@</span> <span class="p_context"> static int match_child(struct device *dev, void *data)</span>
 	return !strcmp(dev_name(dev), (char *)data);
 }
 
<span class="p_add">+static void s5p_mfc_memdev_release(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dma_release_declared_memory(dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void *mfc_get_drv_data(struct platform_device *pdev);
 
 static int s5p_mfc_alloc_memdevs(struct s5p_mfc_dev *dev)
<span class="p_chunk">@@ -1062,6 +1067,9 @@</span> <span class="p_context"> static int s5p_mfc_alloc_memdevs(struct s5p_mfc_dev *dev)</span>
 		mfc_err(&quot;Not enough memory\n&quot;);
 		return -ENOMEM;
 	}
<span class="p_add">+</span>
<span class="p_add">+	dev_set_name(dev-&gt;mem_dev_l, &quot;%s&quot;, &quot;s5p-mfc-l&quot;);</span>
<span class="p_add">+	dev-&gt;mem_dev_l-&gt;release = s5p_mfc_memdev_release;</span>
 	device_initialize(dev-&gt;mem_dev_l);
 	of_property_read_u32_array(dev-&gt;plat_dev-&gt;dev.of_node,
 			&quot;samsung,mfc-l&quot;, mem_info, 2);
<span class="p_chunk">@@ -1079,6 +1087,9 @@</span> <span class="p_context"> static int s5p_mfc_alloc_memdevs(struct s5p_mfc_dev *dev)</span>
 		mfc_err(&quot;Not enough memory\n&quot;);
 		return -ENOMEM;
 	}
<span class="p_add">+</span>
<span class="p_add">+	dev_set_name(dev-&gt;mem_dev_r, &quot;%s&quot;, &quot;s5p-mfc-r&quot;);</span>
<span class="p_add">+	dev-&gt;mem_dev_r-&gt;release = s5p_mfc_memdev_release;</span>
 	device_initialize(dev-&gt;mem_dev_r);
 	of_property_read_u32_array(dev-&gt;plat_dev-&gt;dev.of_node,
 			&quot;samsung,mfc-r&quot;, mem_info, 2);
<span class="p_header">diff --git a/drivers/media/rc/ir-rc5-decoder.c b/drivers/media/rc/ir-rc5-decoder.c</span>
<span class="p_header">index 6ffe776abf6b..a0fd4e6b2155 100644</span>
<span class="p_header">--- a/drivers/media/rc/ir-rc5-decoder.c</span>
<span class="p_header">+++ b/drivers/media/rc/ir-rc5-decoder.c</span>
<span class="p_chunk">@@ -29,7 +29,7 @@</span> <span class="p_context"></span>
 #define RC5_BIT_START		(1 * RC5_UNIT)
 #define RC5_BIT_END		(1 * RC5_UNIT)
 #define RC5X_SPACE		(4 * RC5_UNIT)
<span class="p_del">-#define RC5_TRAILER		(10 * RC5_UNIT) /* In reality, approx 100 */</span>
<span class="p_add">+#define RC5_TRAILER		(6 * RC5_UNIT) /* In reality, approx 100 */</span>
 
 enum rc5_state {
 	STATE_INACTIVE,
<span class="p_header">diff --git a/drivers/media/rc/nuvoton-cir.c b/drivers/media/rc/nuvoton-cir.c</span>
<span class="p_header">index 99b303b702ac..e8ceb0e2f6d7 100644</span>
<span class="p_header">--- a/drivers/media/rc/nuvoton-cir.c</span>
<span class="p_header">+++ b/drivers/media/rc/nuvoton-cir.c</span>
<span class="p_chunk">@@ -401,6 +401,7 @@</span> <span class="p_context"> static int nvt_hw_detect(struct nvt_dev *nvt)</span>
 	/* Check if we&#39;re wired for the alternate EFER setup */
 	nvt-&gt;chip_major = nvt_cr_read(nvt, CR_CHIP_ID_HI);
 	if (nvt-&gt;chip_major == 0xff) {
<span class="p_add">+		nvt_efm_disable(nvt);</span>
 		nvt-&gt;cr_efir = CR_EFIR2;
 		nvt-&gt;cr_efdr = CR_EFDR2;
 		nvt_efm_enable(nvt);
<span class="p_header">diff --git a/drivers/media/usb/usbtv/usbtv-audio.c b/drivers/media/usb/usbtv/usbtv-audio.c</span>
<span class="p_header">index 78c12d22dfbb..5dab02432e82 100644</span>
<span class="p_header">--- a/drivers/media/usb/usbtv/usbtv-audio.c</span>
<span class="p_header">+++ b/drivers/media/usb/usbtv/usbtv-audio.c</span>
<span class="p_chunk">@@ -278,6 +278,9 @@</span> <span class="p_context"> static void snd_usbtv_trigger(struct work_struct *work)</span>
 {
 	struct usbtv *chip = container_of(work, struct usbtv, snd_trigger);
 
<span class="p_add">+	if (!chip-&gt;snd)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	if (atomic_read(&amp;chip-&gt;snd_stream))
 		usbtv_audio_start(chip);
 	else
<span class="p_chunk">@@ -378,6 +381,8 @@</span> <span class="p_context"> err:</span>
 
 void usbtv_audio_free(struct usbtv *usbtv)
 {
<span class="p_add">+	cancel_work_sync(&amp;usbtv-&gt;snd_trigger);</span>
<span class="p_add">+</span>
 	if (usbtv-&gt;snd &amp;&amp; usbtv-&gt;udev) {
 		snd_card_free(usbtv-&gt;snd);
 		usbtv-&gt;snd = NULL;
<span class="p_header">diff --git a/drivers/media/v4l2-core/videobuf2-core.c b/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_header">index 9fbcb67a9ee6..633fc1ab1d7a 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_chunk">@@ -1648,7 +1648,7 @@</span> <span class="p_context"> static int __vb2_get_done_vb(struct vb2_queue *q, struct vb2_buffer **vb,</span>
 			     void *pb, int nonblocking)
 {
 	unsigned long flags;
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = 0;</span>
 
 	/*
 	 * Wait for at least one buffer to become available on the done_list.
<span class="p_chunk">@@ -1664,10 +1664,12 @@</span> <span class="p_context"> static int __vb2_get_done_vb(struct vb2_queue *q, struct vb2_buffer **vb,</span>
 	spin_lock_irqsave(&amp;q-&gt;done_lock, flags);
 	*vb = list_first_entry(&amp;q-&gt;done_list, struct vb2_buffer, done_entry);
 	/*
<span class="p_del">-	 * Only remove the buffer from done_list if v4l2_buffer can handle all</span>
<span class="p_del">-	 * the planes.</span>
<span class="p_add">+	 * Only remove the buffer from done_list if all planes can be</span>
<span class="p_add">+	 * handled. Some cases such as V4L2 file I/O and DVB have pb</span>
<span class="p_add">+	 * == NULL; skip the check then as there&#39;s nothing to verify.</span>
 	 */
<span class="p_del">-	ret = call_bufop(q, verify_planes_array, *vb, pb);</span>
<span class="p_add">+	if (pb)</span>
<span class="p_add">+		ret = call_bufop(q, verify_planes_array, *vb, pb);</span>
 	if (!ret)
 		list_del(&amp;(*vb)-&gt;done_entry);
 	spin_unlock_irqrestore(&amp;q-&gt;done_lock, flags);
<span class="p_header">diff --git a/drivers/media/v4l2-core/videobuf2-v4l2.c b/drivers/media/v4l2-core/videobuf2-v4l2.c</span>
<span class="p_header">index 0b1b8c7b6ce5..7f366f1b0377 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/videobuf2-v4l2.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/videobuf2-v4l2.c</span>
<span class="p_chunk">@@ -74,6 +74,11 @@</span> <span class="p_context"> static int __verify_planes_array(struct vb2_buffer *vb, const struct v4l2_buffer</span>
 	return 0;
 }
 
<span class="p_add">+static int __verify_planes_array_core(struct vb2_buffer *vb, const void *pb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __verify_planes_array(vb, pb);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * __verify_length() - Verify that the bytesused value for each plane fits in
  * the plane length and that the data offset doesn&#39;t exceed the bytesused value.
<span class="p_chunk">@@ -437,6 +442,7 @@</span> <span class="p_context"> static int __fill_vb2_buffer(struct vb2_buffer *vb,</span>
 }
 
 static const struct vb2_buf_ops v4l2_buf_ops = {
<span class="p_add">+	.verify_planes_array	= __verify_planes_array_core,</span>
 	.fill_user_buffer	= __fill_v4l2_buffer,
 	.fill_vb2_buffer	= __fill_vb2_buffer,
 	.copy_timestamp		= __copy_timestamp,
<span class="p_header">diff --git a/drivers/mfd/qcom_rpm.c b/drivers/mfd/qcom_rpm.c</span>
<span class="p_header">index 1be47ad6441b..880d4699bcb0 100644</span>
<span class="p_header">--- a/drivers/mfd/qcom_rpm.c</span>
<span class="p_header">+++ b/drivers/mfd/qcom_rpm.c</span>
<span class="p_chunk">@@ -34,7 +34,13 @@</span> <span class="p_context"> struct qcom_rpm_resource {</span>
 struct qcom_rpm_data {
 	u32 version;
 	const struct qcom_rpm_resource *resource_table;
<span class="p_del">-	unsigned n_resources;</span>
<span class="p_add">+	unsigned int n_resources;</span>
<span class="p_add">+	unsigned int req_ctx_off;</span>
<span class="p_add">+	unsigned int req_sel_off;</span>
<span class="p_add">+	unsigned int ack_ctx_off;</span>
<span class="p_add">+	unsigned int ack_sel_off;</span>
<span class="p_add">+	unsigned int req_sel_size;</span>
<span class="p_add">+	unsigned int ack_sel_size;</span>
 };
 
 struct qcom_rpm {
<span class="p_chunk">@@ -61,11 +67,7 @@</span> <span class="p_context"> struct qcom_rpm {</span>
 
 #define RPM_REQUEST_TIMEOUT	(5 * HZ)
 
<span class="p_del">-#define RPM_REQUEST_CONTEXT	3</span>
<span class="p_del">-#define RPM_REQ_SELECT		11</span>
<span class="p_del">-#define RPM_ACK_CONTEXT		15</span>
<span class="p_del">-#define RPM_ACK_SELECTOR	23</span>
<span class="p_del">-#define RPM_SELECT_SIZE		7</span>
<span class="p_add">+#define RPM_MAX_SEL_SIZE	7</span>
 
 #define RPM_NOTIFICATION	BIT(30)
 #define RPM_REJECTED		BIT(31)
<span class="p_chunk">@@ -157,6 +159,12 @@</span> <span class="p_context"> static const struct qcom_rpm_data apq8064_template = {</span>
 	.version = 3,
 	.resource_table = apq8064_rpm_resource_table,
 	.n_resources = ARRAY_SIZE(apq8064_rpm_resource_table),
<span class="p_add">+	.req_ctx_off = 3,</span>
<span class="p_add">+	.req_sel_off = 11,</span>
<span class="p_add">+	.ack_ctx_off = 15,</span>
<span class="p_add">+	.ack_sel_off = 23,</span>
<span class="p_add">+	.req_sel_size = 4,</span>
<span class="p_add">+	.ack_sel_size = 7,</span>
 };
 
 static const struct qcom_rpm_resource msm8660_rpm_resource_table[] = {
<span class="p_chunk">@@ -240,6 +248,12 @@</span> <span class="p_context"> static const struct qcom_rpm_data msm8660_template = {</span>
 	.version = 2,
 	.resource_table = msm8660_rpm_resource_table,
 	.n_resources = ARRAY_SIZE(msm8660_rpm_resource_table),
<span class="p_add">+	.req_ctx_off = 3,</span>
<span class="p_add">+	.req_sel_off = 11,</span>
<span class="p_add">+	.ack_ctx_off = 19,</span>
<span class="p_add">+	.ack_sel_off = 27,</span>
<span class="p_add">+	.req_sel_size = 7,</span>
<span class="p_add">+	.ack_sel_size = 7,</span>
 };
 
 static const struct qcom_rpm_resource msm8960_rpm_resource_table[] = {
<span class="p_chunk">@@ -322,6 +336,12 @@</span> <span class="p_context"> static const struct qcom_rpm_data msm8960_template = {</span>
 	.version = 3,
 	.resource_table = msm8960_rpm_resource_table,
 	.n_resources = ARRAY_SIZE(msm8960_rpm_resource_table),
<span class="p_add">+	.req_ctx_off = 3,</span>
<span class="p_add">+	.req_sel_off = 11,</span>
<span class="p_add">+	.ack_ctx_off = 15,</span>
<span class="p_add">+	.ack_sel_off = 23,</span>
<span class="p_add">+	.req_sel_size = 4,</span>
<span class="p_add">+	.ack_sel_size = 7,</span>
 };
 
 static const struct qcom_rpm_resource ipq806x_rpm_resource_table[] = {
<span class="p_chunk">@@ -362,6 +382,12 @@</span> <span class="p_context"> static const struct qcom_rpm_data ipq806x_template = {</span>
 	.version = 3,
 	.resource_table = ipq806x_rpm_resource_table,
 	.n_resources = ARRAY_SIZE(ipq806x_rpm_resource_table),
<span class="p_add">+	.req_ctx_off = 3,</span>
<span class="p_add">+	.req_sel_off = 11,</span>
<span class="p_add">+	.ack_ctx_off = 15,</span>
<span class="p_add">+	.ack_sel_off = 23,</span>
<span class="p_add">+	.req_sel_size = 4,</span>
<span class="p_add">+	.ack_sel_size = 7,</span>
 };
 
 static const struct of_device_id qcom_rpm_of_match[] = {
<span class="p_chunk">@@ -380,7 +406,7 @@</span> <span class="p_context"> int qcom_rpm_write(struct qcom_rpm *rpm,</span>
 {
 	const struct qcom_rpm_resource *res;
 	const struct qcom_rpm_data *data = rpm-&gt;data;
<span class="p_del">-	u32 sel_mask[RPM_SELECT_SIZE] = { 0 };</span>
<span class="p_add">+	u32 sel_mask[RPM_MAX_SEL_SIZE] = { 0 };</span>
 	int left;
 	int ret = 0;
 	int i;
<span class="p_chunk">@@ -398,12 +424,12 @@</span> <span class="p_context"> int qcom_rpm_write(struct qcom_rpm *rpm,</span>
 		writel_relaxed(buf[i], RPM_REQ_REG(rpm, res-&gt;target_id + i));
 
 	bitmap_set((unsigned long *)sel_mask, res-&gt;select_id, 1);
<span class="p_del">-	for (i = 0; i &lt; ARRAY_SIZE(sel_mask); i++) {</span>
<span class="p_add">+	for (i = 0; i &lt; rpm-&gt;data-&gt;req_sel_size; i++) {</span>
 		writel_relaxed(sel_mask[i],
<span class="p_del">-			       RPM_CTRL_REG(rpm, RPM_REQ_SELECT + i));</span>
<span class="p_add">+			       RPM_CTRL_REG(rpm, rpm-&gt;data-&gt;req_sel_off + i));</span>
 	}
 
<span class="p_del">-	writel_relaxed(BIT(state), RPM_CTRL_REG(rpm, RPM_REQUEST_CONTEXT));</span>
<span class="p_add">+	writel_relaxed(BIT(state), RPM_CTRL_REG(rpm, rpm-&gt;data-&gt;req_ctx_off));</span>
 
 	reinit_completion(&amp;rpm-&gt;ack);
 	regmap_write(rpm-&gt;ipc_regmap, rpm-&gt;ipc_offset, BIT(rpm-&gt;ipc_bit));
<span class="p_chunk">@@ -426,10 +452,11 @@</span> <span class="p_context"> static irqreturn_t qcom_rpm_ack_interrupt(int irq, void *dev)</span>
 	u32 ack;
 	int i;
 
<span class="p_del">-	ack = readl_relaxed(RPM_CTRL_REG(rpm, RPM_ACK_CONTEXT));</span>
<span class="p_del">-	for (i = 0; i &lt; RPM_SELECT_SIZE; i++)</span>
<span class="p_del">-		writel_relaxed(0, RPM_CTRL_REG(rpm, RPM_ACK_SELECTOR + i));</span>
<span class="p_del">-	writel(0, RPM_CTRL_REG(rpm, RPM_ACK_CONTEXT));</span>
<span class="p_add">+	ack = readl_relaxed(RPM_CTRL_REG(rpm, rpm-&gt;data-&gt;ack_ctx_off));</span>
<span class="p_add">+	for (i = 0; i &lt; rpm-&gt;data-&gt;ack_sel_size; i++)</span>
<span class="p_add">+		writel_relaxed(0,</span>
<span class="p_add">+			RPM_CTRL_REG(rpm, rpm-&gt;data-&gt;ack_sel_off + i));</span>
<span class="p_add">+	writel(0, RPM_CTRL_REG(rpm, rpm-&gt;data-&gt;ack_ctx_off));</span>
 
 	if (ack &amp; RPM_NOTIFICATION) {
 		dev_warn(rpm-&gt;dev, &quot;ignoring notification!\n&quot;);
<span class="p_header">diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">index 0b0dc29d2af7..77533f7f2429 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/nand_base.c</span>
<span class="p_chunk">@@ -2610,7 +2610,7 @@</span> <span class="p_context"> static int nand_do_write_ops(struct mtd_info *mtd, loff_t to,</span>
 		int cached = writelen &gt; bytes &amp;&amp; page != blockmask;
 		uint8_t *wbuf = buf;
 		int use_bufpoi;
<span class="p_del">-		int part_pagewr = (column || writelen &lt; (mtd-&gt;writesize - 1));</span>
<span class="p_add">+		int part_pagewr = (column || writelen &lt; mtd-&gt;writesize);</span>
 
 		if (part_pagewr)
 			use_bufpoi = 1;
<span class="p_header">diff --git a/drivers/mtd/ubi/build.c b/drivers/mtd/ubi/build.c</span>
<span class="p_header">index ef3618299494..0680516bb472 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/build.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/build.c</span>
<span class="p_chunk">@@ -874,7 +874,7 @@</span> <span class="p_context"> int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,</span>
 	for (i = 0; i &lt; UBI_MAX_DEVICES; i++) {
 		ubi = ubi_devices[i];
 		if (ubi &amp;&amp; mtd-&gt;index == ubi-&gt;mtd-&gt;index) {
<span class="p_del">-			ubi_err(ubi, &quot;mtd%d is already attached to ubi%d&quot;,</span>
<span class="p_add">+			pr_err(&quot;ubi: mtd%d is already attached to ubi%d&quot;,</span>
 				mtd-&gt;index, i);
 			return -EEXIST;
 		}
<span class="p_chunk">@@ -889,7 +889,7 @@</span> <span class="p_context"> int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,</span>
 	 * no sense to attach emulated MTD devices, so we prohibit this.
 	 */
 	if (mtd-&gt;type == MTD_UBIVOLUME) {
<span class="p_del">-		ubi_err(ubi, &quot;refuse attaching mtd%d - it is already emulated on top of UBI&quot;,</span>
<span class="p_add">+		pr_err(&quot;ubi: refuse attaching mtd%d - it is already emulated on top of UBI&quot;,</span>
 			mtd-&gt;index);
 		return -EINVAL;
 	}
<span class="p_chunk">@@ -900,7 +900,7 @@</span> <span class="p_context"> int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,</span>
 			if (!ubi_devices[ubi_num])
 				break;
 		if (ubi_num == UBI_MAX_DEVICES) {
<span class="p_del">-			ubi_err(ubi, &quot;only %d UBI devices may be created&quot;,</span>
<span class="p_add">+			pr_err(&quot;ubi: only %d UBI devices may be created&quot;,</span>
 				UBI_MAX_DEVICES);
 			return -ENFILE;
 		}
<span class="p_chunk">@@ -910,7 +910,7 @@</span> <span class="p_context"> int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,</span>
 
 		/* Make sure ubi_num is not busy */
 		if (ubi_devices[ubi_num]) {
<span class="p_del">-			ubi_err(ubi, &quot;already exists&quot;);</span>
<span class="p_add">+			pr_err(&quot;ubi: ubi%i already exists&quot;, ubi_num);</span>
 			return -EEXIST;
 		}
 	}
<span class="p_chunk">@@ -992,6 +992,9 @@</span> <span class="p_context"> int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,</span>
 			goto out_detach;
 	}
 
<span class="p_add">+	/* Make device &quot;available&quot; before it becomes accessible via sysfs */</span>
<span class="p_add">+	ubi_devices[ubi_num] = ubi;</span>
<span class="p_add">+</span>
 	err = uif_init(ubi, &amp;ref);
 	if (err)
 		goto out_detach;
<span class="p_chunk">@@ -1036,7 +1039,6 @@</span> <span class="p_context"> int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,</span>
 	wake_up_process(ubi-&gt;bgt_thread);
 	spin_unlock(&amp;ubi-&gt;wl_lock);
 
<span class="p_del">-	ubi_devices[ubi_num] = ubi;</span>
 	ubi_notify_all(ubi, UBI_VOLUME_ADDED, NULL);
 	return ubi_num;
 
<span class="p_chunk">@@ -1047,6 +1049,7 @@</span> <span class="p_context"> out_uif:</span>
 	ubi_assert(ref);
 	uif_close(ubi);
 out_detach:
<span class="p_add">+	ubi_devices[ubi_num] = NULL;</span>
 	ubi_wl_close(ubi);
 	ubi_free_internal_volumes(ubi);
 	vfree(ubi-&gt;vtbl);
<span class="p_header">diff --git a/drivers/mtd/ubi/vmt.c b/drivers/mtd/ubi/vmt.c</span>
<span class="p_header">index 10059dfdc1b6..0138f526474a 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/vmt.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/vmt.c</span>
<span class="p_chunk">@@ -488,13 +488,6 @@</span> <span class="p_context"> int ubi_resize_volume(struct ubi_volume_desc *desc, int reserved_pebs)</span>
 		spin_unlock(&amp;ubi-&gt;volumes_lock);
 	}
 
<span class="p_del">-	/* Change volume table record */</span>
<span class="p_del">-	vtbl_rec = ubi-&gt;vtbl[vol_id];</span>
<span class="p_del">-	vtbl_rec.reserved_pebs = cpu_to_be32(reserved_pebs);</span>
<span class="p_del">-	err = ubi_change_vtbl_record(ubi, vol_id, &amp;vtbl_rec);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto out_acc;</span>
<span class="p_del">-</span>
 	if (pebs &lt; 0) {
 		for (i = 0; i &lt; -pebs; i++) {
 			err = ubi_eba_unmap_leb(ubi, vol, reserved_pebs + i);
<span class="p_chunk">@@ -512,6 +505,24 @@</span> <span class="p_context"> int ubi_resize_volume(struct ubi_volume_desc *desc, int reserved_pebs)</span>
 		spin_unlock(&amp;ubi-&gt;volumes_lock);
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * When we shrink a volume we have to flush all pending (erase) work.</span>
<span class="p_add">+	 * Otherwise it can happen that upon next attach UBI finds a LEB with</span>
<span class="p_add">+	 * lnum &gt; highest_lnum and refuses to attach.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (pebs &lt; 0) {</span>
<span class="p_add">+		err = ubi_wl_flush(ubi, vol_id, UBI_ALL);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto out_acc;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Change volume table record */</span>
<span class="p_add">+	vtbl_rec = ubi-&gt;vtbl[vol_id];</span>
<span class="p_add">+	vtbl_rec.reserved_pebs = cpu_to_be32(reserved_pebs);</span>
<span class="p_add">+	err = ubi_change_vtbl_record(ubi, vol_id, &amp;vtbl_rec);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto out_acc;</span>
<span class="p_add">+</span>
 	vol-&gt;reserved_pebs = reserved_pebs;
 	if (vol-&gt;vol_type == UBI_DYNAMIC_VOLUME) {
 		vol-&gt;used_ebs = reserved_pebs;
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c</span>
<span class="p_header">index 5b30922b67ec..2ce319903cfb 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c</span>
<span class="p_chunk">@@ -2469,10 +2469,22 @@</span> <span class="p_context"> void brcmf_fws_bustxfail(struct brcmf_fws_info *fws, struct sk_buff *skb)</span>
 void brcmf_fws_bus_blocked(struct brcmf_pub *drvr, bool flow_blocked)
 {
 	struct brcmf_fws_info *fws = drvr-&gt;fws;
<span class="p_add">+	struct brcmf_if *ifp;</span>
<span class="p_add">+	int i;</span>
 
<span class="p_del">-	fws-&gt;bus_flow_blocked = flow_blocked;</span>
<span class="p_del">-	if (!flow_blocked)</span>
<span class="p_del">-		brcmf_fws_schedule_deq(fws);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		fws-&gt;stats.bus_flow_block++;</span>
<span class="p_add">+	if (fws-&gt;avoid_queueing) {</span>
<span class="p_add">+		for (i = 0; i &lt; BRCMF_MAX_IFS; i++) {</span>
<span class="p_add">+			ifp = drvr-&gt;iflist[i];</span>
<span class="p_add">+			if (!ifp || !ifp-&gt;ndev)</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			brcmf_txflowblock_if(ifp, BRCMF_NETIF_STOP_REASON_FLOW,</span>
<span class="p_add">+					     flow_blocked);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		fws-&gt;bus_flow_blocked = flow_blocked;</span>
<span class="p_add">+		if (!flow_blocked)</span>
<span class="p_add">+			brcmf_fws_schedule_deq(fws);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			fws-&gt;stats.bus_flow_block++;</span>
<span class="p_add">+	}</span>
 }
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/pcie/drv.c b/drivers/net/wireless/intel/iwlwifi/pcie/drv.c</span>
<span class="p_header">index a588b05e38eb..6f020e4ec7dc 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/pcie/drv.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/pcie/drv.c</span>
<span class="p_chunk">@@ -433,6 +433,7 @@</span> <span class="p_context"> static const struct pci_device_id iwl_hw_card_ids[] = {</span>
 /* 8000 Series */
 	{IWL_PCI_DEVICE(0x24F3, 0x0010, iwl8260_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x24F3, 0x1010, iwl8260_2ac_cfg)},
<span class="p_add">+	{IWL_PCI_DEVICE(0x24F3, 0x10B0, iwl8260_2ac_cfg)},</span>
 	{IWL_PCI_DEVICE(0x24F3, 0x0130, iwl8260_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x24F3, 0x1130, iwl8260_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x24F3, 0x0132, iwl8260_2ac_cfg)},
<span class="p_chunk">@@ -454,6 +455,8 @@</span> <span class="p_context"> static const struct pci_device_id iwl_hw_card_ids[] = {</span>
 	{IWL_PCI_DEVICE(0x24F3, 0xD010, iwl8260_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x24F3, 0xC050, iwl8260_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x24F3, 0xD050, iwl8260_2ac_cfg)},
<span class="p_add">+	{IWL_PCI_DEVICE(0x24F3, 0xD0B0, iwl8260_2ac_cfg)},</span>
<span class="p_add">+	{IWL_PCI_DEVICE(0x24F3, 0xB0B0, iwl8260_2ac_cfg)},</span>
 	{IWL_PCI_DEVICE(0x24F3, 0x8010, iwl8260_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x24F3, 0x8110, iwl8260_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x24F3, 0x9010, iwl8260_2ac_cfg)},
<span class="p_chunk">@@ -481,6 +484,8 @@</span> <span class="p_context"> static const struct pci_device_id iwl_hw_card_ids[] = {</span>
 	{IWL_PCI_DEVICE(0x24FD, 0x0010, iwl8265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x24FD, 0x0110, iwl8265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x24FD, 0x1110, iwl8265_2ac_cfg)},
<span class="p_add">+	{IWL_PCI_DEVICE(0x24FD, 0x1130, iwl8265_2ac_cfg)},</span>
<span class="p_add">+	{IWL_PCI_DEVICE(0x24FD, 0x0130, iwl8265_2ac_cfg)},</span>
 	{IWL_PCI_DEVICE(0x24FD, 0x1010, iwl8265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x24FD, 0x0050, iwl8265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x24FD, 0x0150, iwl8265_2ac_cfg)},
<span class="p_chunk">@@ -491,6 +496,10 @@</span> <span class="p_context"> static const struct pci_device_id iwl_hw_card_ids[] = {</span>
 	{IWL_PCI_DEVICE(0x24FD, 0x0810, iwl8265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x24FD, 0x9110, iwl8265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x24FD, 0x8130, iwl8265_2ac_cfg)},
<span class="p_add">+	{IWL_PCI_DEVICE(0x24FD, 0x0910, iwl8265_2ac_cfg)},</span>
<span class="p_add">+	{IWL_PCI_DEVICE(0x24FD, 0x0930, iwl8265_2ac_cfg)},</span>
<span class="p_add">+	{IWL_PCI_DEVICE(0x24FD, 0x0950, iwl8265_2ac_cfg)},</span>
<span class="p_add">+	{IWL_PCI_DEVICE(0x24FD, 0x0850, iwl8265_2ac_cfg)},</span>
 
 /* 9000 Series */
 	{IWL_PCI_DEVICE(0x2526, 0x0000, iwl9260_2ac_cfg)},
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/pcie/internal.h b/drivers/net/wireless/intel/iwlwifi/pcie/internal.h</span>
<span class="p_header">index de6974f9c52f..2d8cce290a15 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/pcie/internal.h</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/pcie/internal.h</span>
<span class="p_chunk">@@ -496,7 +496,7 @@</span> <span class="p_context"> void iwl_pcie_dump_csr(struct iwl_trans *trans);</span>
 /*****************************************************
 * Helpers
 ******************************************************/
<span class="p_del">-static inline void iwl_disable_interrupts(struct iwl_trans *trans)</span>
<span class="p_add">+static inline void _iwl_disable_interrupts(struct iwl_trans *trans)</span>
 {
 	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
 
<span class="p_chunk">@@ -519,7 +519,16 @@</span> <span class="p_context"> static inline void iwl_disable_interrupts(struct iwl_trans *trans)</span>
 	IWL_DEBUG_ISR(trans, &quot;Disabled interrupts\n&quot;);
 }
 
<span class="p_del">-static inline void iwl_enable_interrupts(struct iwl_trans *trans)</span>
<span class="p_add">+static inline void iwl_disable_interrupts(struct iwl_trans *trans)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;trans_pcie-&gt;irq_lock);</span>
<span class="p_add">+	_iwl_disable_interrupts(trans);</span>
<span class="p_add">+	spin_unlock(&amp;trans_pcie-&gt;irq_lock);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void _iwl_enable_interrupts(struct iwl_trans *trans)</span>
 {
 	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
 
<span class="p_chunk">@@ -542,6 +551,14 @@</span> <span class="p_context"> static inline void iwl_enable_interrupts(struct iwl_trans *trans)</span>
 	}
 }
 
<span class="p_add">+static inline void iwl_enable_interrupts(struct iwl_trans *trans)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;trans_pcie-&gt;irq_lock);</span>
<span class="p_add">+	_iwl_enable_interrupts(trans);</span>
<span class="p_add">+	spin_unlock(&amp;trans_pcie-&gt;irq_lock);</span>
<span class="p_add">+}</span>
 static inline void iwl_enable_hw_int_msk_msix(struct iwl_trans *trans, u32 msk)
 {
 	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/pcie/rx.c b/drivers/net/wireless/intel/iwlwifi/pcie/rx.c</span>
<span class="p_header">index 0a4a3c502c3c..aaaf2ad6e4da 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/pcie/rx.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/pcie/rx.c</span>
<span class="p_chunk">@@ -1507,7 +1507,7 @@</span> <span class="p_context"> irqreturn_t iwl_pcie_irq_handler(int irq, void *dev_id)</span>
 		 * have anything to service
 		 */
 		if (test_bit(STATUS_INT_ENABLED, &amp;trans-&gt;status))
<span class="p_del">-			iwl_enable_interrupts(trans);</span>
<span class="p_add">+			_iwl_enable_interrupts(trans);</span>
 		spin_unlock(&amp;trans_pcie-&gt;irq_lock);
 		lock_map_release(&amp;trans-&gt;sync_cmd_lockdep_map);
 		return IRQ_NONE;
<span class="p_chunk">@@ -1699,15 +1699,17 @@</span> <span class="p_context"> irqreturn_t iwl_pcie_irq_handler(int irq, void *dev_id)</span>
 			 inta &amp; ~trans_pcie-&gt;inta_mask);
 	}
 
<span class="p_add">+	spin_lock(&amp;trans_pcie-&gt;irq_lock);</span>
<span class="p_add">+	/* only Re-enable all interrupt if disabled by irq */</span>
<span class="p_add">+	if (test_bit(STATUS_INT_ENABLED, &amp;trans-&gt;status))</span>
<span class="p_add">+		_iwl_enable_interrupts(trans);</span>
 	/* we are loading the firmware, enable FH_TX interrupt only */
<span class="p_del">-	if (handled &amp; CSR_INT_BIT_FH_TX)</span>
<span class="p_add">+	else if (handled &amp; CSR_INT_BIT_FH_TX)</span>
 		iwl_enable_fw_load_int(trans);
<span class="p_del">-	/* only Re-enable all interrupt if disabled by irq */</span>
<span class="p_del">-	else if (test_bit(STATUS_INT_ENABLED, &amp;trans-&gt;status))</span>
<span class="p_del">-		iwl_enable_interrupts(trans);</span>
 	/* Re-enable RF_KILL if it occurred */
 	else if (handled &amp; CSR_INT_BIT_RF_KILL)
 		iwl_enable_rfkill_int(trans);
<span class="p_add">+	spin_unlock(&amp;trans_pcie-&gt;irq_lock);</span>
 
 out:
 	lock_map_release(&amp;trans-&gt;sync_cmd_lockdep_map);
<span class="p_chunk">@@ -1771,7 +1773,7 @@</span> <span class="p_context"> void iwl_pcie_reset_ict(struct iwl_trans *trans)</span>
 		return;
 
 	spin_lock(&amp;trans_pcie-&gt;irq_lock);
<span class="p_del">-	iwl_disable_interrupts(trans);</span>
<span class="p_add">+	_iwl_disable_interrupts(trans);</span>
 
 	memset(trans_pcie-&gt;ict_tbl, 0, ICT_SIZE);
 
<span class="p_chunk">@@ -1787,7 +1789,7 @@</span> <span class="p_context"> void iwl_pcie_reset_ict(struct iwl_trans *trans)</span>
 	trans_pcie-&gt;use_ict = true;
 	trans_pcie-&gt;ict_index = 0;
 	iwl_write32(trans, CSR_INT, trans_pcie-&gt;inta_mask);
<span class="p_del">-	iwl_enable_interrupts(trans);</span>
<span class="p_add">+	_iwl_enable_interrupts(trans);</span>
 	spin_unlock(&amp;trans_pcie-&gt;irq_lock);
 }
 
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/pcie/trans.c b/drivers/net/wireless/intel/iwlwifi/pcie/trans.c</span>
<span class="p_header">index f603d7830a6b..d9f139462b31 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/pcie/trans.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/pcie/trans.c</span>
<span class="p_chunk">@@ -801,6 +801,8 @@</span> <span class="p_context"> static int iwl_pcie_load_cpu_sections_8000(struct iwl_trans *trans,</span>
 
 	*first_ucode_section = last_read_idx;
 
<span class="p_add">+	iwl_enable_interrupts(trans);</span>
<span class="p_add">+</span>
 	if (cpu == 1)
 		iwl_write_direct32(trans, FH_UCODE_LOAD_STATUS, 0xFFFF);
 	else
<span class="p_chunk">@@ -980,6 +982,8 @@</span> <span class="p_context"> static int iwl_pcie_load_given_ucode(struct iwl_trans *trans,</span>
 		iwl_pcie_apply_destination(trans);
 	}
 
<span class="p_add">+	iwl_enable_interrupts(trans);</span>
<span class="p_add">+</span>
 	/* release CPU reset */
 	iwl_write32(trans, CSR_RESET, 0);
 
<span class="p_chunk">@@ -1033,9 +1037,7 @@</span> <span class="p_context"> static void _iwl_trans_pcie_stop_device(struct iwl_trans *trans, bool low_power)</span>
 	was_hw_rfkill = iwl_is_rfkill_set(trans);
 
 	/* tell the device to stop sending interrupts */
<span class="p_del">-	spin_lock(&amp;trans_pcie-&gt;irq_lock);</span>
 	iwl_disable_interrupts(trans);
<span class="p_del">-	spin_unlock(&amp;trans_pcie-&gt;irq_lock);</span>
 
 	/* device going down, Stop using ICT table */
 	iwl_pcie_disable_ict(trans);
<span class="p_chunk">@@ -1079,9 +1081,7 @@</span> <span class="p_context"> static void _iwl_trans_pcie_stop_device(struct iwl_trans *trans, bool low_power)</span>
 	 * the time, unless the interrupt is ACKed even if the interrupt
 	 * should be masked. Re-ACK all the interrupts here.
 	 */
<span class="p_del">-	spin_lock(&amp;trans_pcie-&gt;irq_lock);</span>
 	iwl_disable_interrupts(trans);
<span class="p_del">-	spin_unlock(&amp;trans_pcie-&gt;irq_lock);</span>
 
 	/* clear all status bits */
 	clear_bit(STATUS_SYNC_HCMD_ACTIVE, &amp;trans-&gt;status);
<span class="p_chunk">@@ -1215,7 +1215,6 @@</span> <span class="p_context"> static int iwl_trans_pcie_start_fw(struct iwl_trans *trans,</span>
 		ret = iwl_pcie_load_given_ucode_8000(trans, fw);
 	else
 		ret = iwl_pcie_load_given_ucode(trans, fw);
<span class="p_del">-	iwl_enable_interrupts(trans);</span>
 
 	/* re-check RF-Kill state since we may have missed the interrupt */
 	hw_rfkill = iwl_is_rfkill_set(trans);
<span class="p_chunk">@@ -1567,15 +1566,11 @@</span> <span class="p_context"> static void iwl_trans_pcie_op_mode_leave(struct iwl_trans *trans)</span>
 	mutex_lock(&amp;trans_pcie-&gt;mutex);
 
 	/* disable interrupts - don&#39;t enable HW RF kill interrupt */
<span class="p_del">-	spin_lock(&amp;trans_pcie-&gt;irq_lock);</span>
 	iwl_disable_interrupts(trans);
<span class="p_del">-	spin_unlock(&amp;trans_pcie-&gt;irq_lock);</span>
 
 	iwl_pcie_apm_stop(trans, true);
 
<span class="p_del">-	spin_lock(&amp;trans_pcie-&gt;irq_lock);</span>
 	iwl_disable_interrupts(trans);
<span class="p_del">-	spin_unlock(&amp;trans_pcie-&gt;irq_lock);</span>
 
 	iwl_pcie_disable_ict(trans);
 
<span class="p_header">diff --git a/drivers/of/base.c b/drivers/of/base.c</span>
<span class="p_header">index ebf84e3b56d5..8bb3d1adf1b0 100644</span>
<span class="p_header">--- a/drivers/of/base.c</span>
<span class="p_header">+++ b/drivers/of/base.c</span>
<span class="p_chunk">@@ -112,6 +112,7 @@</span> <span class="p_context"> static ssize_t of_node_property_read(struct file *filp, struct kobject *kobj,</span>
 	return memory_read_from_buffer(buf, count, &amp;offset, pp-&gt;value, pp-&gt;length);
 }
 
<span class="p_add">+/* always return newly allocated name, caller must free after use */</span>
 static const char *safe_name(struct kobject *kobj, const char *orig_name)
 {
 	const char *name = orig_name;
<span class="p_chunk">@@ -126,9 +127,12 @@</span> <span class="p_context"> static const char *safe_name(struct kobject *kobj, const char *orig_name)</span>
 		name = kasprintf(GFP_KERNEL, &quot;%s#%i&quot;, orig_name, ++i);
 	}
 
<span class="p_del">-	if (name != orig_name)</span>
<span class="p_add">+	if (name == orig_name) {</span>
<span class="p_add">+		name = kstrdup(orig_name, GFP_KERNEL);</span>
<span class="p_add">+	} else {</span>
 		pr_warn(&quot;device-tree: Duplicate name in %s, renamed to \&quot;%s\&quot;\n&quot;,
 			kobject_name(kobj), name);
<span class="p_add">+	}</span>
 	return name;
 }
 
<span class="p_chunk">@@ -159,6 +163,7 @@</span> <span class="p_context"> int __of_add_property_sysfs(struct device_node *np, struct property *pp)</span>
 int __of_attach_node_sysfs(struct device_node *np)
 {
 	const char *name;
<span class="p_add">+	struct kobject *parent;</span>
 	struct property *pp;
 	int rc;
 
<span class="p_chunk">@@ -171,15 +176,16 @@</span> <span class="p_context"> int __of_attach_node_sysfs(struct device_node *np)</span>
 	np-&gt;kobj.kset = of_kset;
 	if (!np-&gt;parent) {
 		/* Nodes without parents are new top level trees */
<span class="p_del">-		rc = kobject_add(&amp;np-&gt;kobj, NULL, &quot;%s&quot;,</span>
<span class="p_del">-				 safe_name(&amp;of_kset-&gt;kobj, &quot;base&quot;));</span>
<span class="p_add">+		name = safe_name(&amp;of_kset-&gt;kobj, &quot;base&quot;);</span>
<span class="p_add">+		parent = NULL;</span>
 	} else {
 		name = safe_name(&amp;np-&gt;parent-&gt;kobj, kbasename(np-&gt;full_name));
<span class="p_del">-		if (!name || !name[0])</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-		rc = kobject_add(&amp;np-&gt;kobj, &amp;np-&gt;parent-&gt;kobj, &quot;%s&quot;, name);</span>
<span class="p_add">+		parent = &amp;np-&gt;parent-&gt;kobj;</span>
 	}
<span class="p_add">+	if (!name)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	rc = kobject_add(&amp;np-&gt;kobj, parent, &quot;%s&quot;, name);</span>
<span class="p_add">+	kfree(name);</span>
 	if (rc)
 		return rc;
 
<span class="p_chunk">@@ -1815,6 +1821,12 @@</span> <span class="p_context"> int __of_remove_property(struct device_node *np, struct property *prop)</span>
 	return 0;
 }
 
<span class="p_add">+void __of_sysfs_remove_bin_file(struct device_node *np, struct property *prop)</span>
<span class="p_add">+{</span>
<span class="p_add">+	sysfs_remove_bin_file(&amp;np-&gt;kobj, &amp;prop-&gt;attr);</span>
<span class="p_add">+	kfree(prop-&gt;attr.attr.name);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void __of_remove_property_sysfs(struct device_node *np, struct property *prop)
 {
 	if (!IS_ENABLED(CONFIG_SYSFS))
<span class="p_chunk">@@ -1822,7 +1834,7 @@</span> <span class="p_context"> void __of_remove_property_sysfs(struct device_node *np, struct property *prop)</span>
 
 	/* at early boot, bail here and defer setup to of_init() */
 	if (of_kset &amp;&amp; of_node_is_attached(np))
<span class="p_del">-		sysfs_remove_bin_file(&amp;np-&gt;kobj, &amp;prop-&gt;attr);</span>
<span class="p_add">+		__of_sysfs_remove_bin_file(np, prop);</span>
 }
 
 /**
<span class="p_chunk">@@ -1895,7 +1907,7 @@</span> <span class="p_context"> void __of_update_property_sysfs(struct device_node *np, struct property *newprop</span>
 		return;
 
 	if (oldprop)
<span class="p_del">-		sysfs_remove_bin_file(&amp;np-&gt;kobj, &amp;oldprop-&gt;attr);</span>
<span class="p_add">+		__of_sysfs_remove_bin_file(np, oldprop);</span>
 	__of_add_property_sysfs(np, newprop);
 }
 
<span class="p_header">diff --git a/drivers/of/dynamic.c b/drivers/of/dynamic.c</span>
<span class="p_header">index 3033fa3250dc..a2015599ed7e 100644</span>
<span class="p_header">--- a/drivers/of/dynamic.c</span>
<span class="p_header">+++ b/drivers/of/dynamic.c</span>
<span class="p_chunk">@@ -55,7 +55,7 @@</span> <span class="p_context"> void __of_detach_node_sysfs(struct device_node *np)</span>
 	/* only remove properties if on sysfs */
 	if (of_node_is_attached(np)) {
 		for_each_property_of_node(np, pp)
<span class="p_del">-			sysfs_remove_bin_file(&amp;np-&gt;kobj, &amp;pp-&gt;attr);</span>
<span class="p_add">+			__of_sysfs_remove_bin_file(np, pp);</span>
 		kobject_del(&amp;np-&gt;kobj);
 	}
 
<span class="p_header">diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h</span>
<span class="p_header">index 829469faeb23..18bbb4517e25 100644</span>
<span class="p_header">--- a/drivers/of/of_private.h</span>
<span class="p_header">+++ b/drivers/of/of_private.h</span>
<span class="p_chunk">@@ -83,6 +83,9 @@</span> <span class="p_context"> extern int __of_attach_node_sysfs(struct device_node *np);</span>
 extern void __of_detach_node(struct device_node *np);
 extern void __of_detach_node_sysfs(struct device_node *np);
 
<span class="p_add">+extern void __of_sysfs_remove_bin_file(struct device_node *np,</span>
<span class="p_add">+				       struct property *prop);</span>
<span class="p_add">+</span>
 /* iterators for transactions, used for overlays */
 /* forward iterator */
 #define for_each_transaction_entry(_oft, _te) \
<span class="p_header">diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c</span>
<span class="p_header">index ee72ebe18f4b..7902fbf47f89 100644</span>
<span class="p_header">--- a/drivers/pci/quirks.c</span>
<span class="p_header">+++ b/drivers/pci/quirks.c</span>
<span class="p_chunk">@@ -3189,13 +3189,15 @@</span> <span class="p_context"> static void quirk_no_bus_reset(struct pci_dev *dev)</span>
 }
 
 /*
<span class="p_del">- * Atheros AR93xx chips do not behave after a bus reset.  The device will</span>
<span class="p_del">- * throw a Link Down error on AER-capable systems and regardless of AER,</span>
<span class="p_del">- * config space of the device is never accessible again and typically</span>
<span class="p_del">- * causes the system to hang or reset when access is attempted.</span>
<span class="p_add">+ * Some Atheros AR9xxx and QCA988x chips do not behave after a bus reset.</span>
<span class="p_add">+ * The device will throw a Link Down error on AER-capable systems and</span>
<span class="p_add">+ * regardless of AER, config space of the device is never accessible again</span>
<span class="p_add">+ * and typically causes the system to hang or reset when access is attempted.</span>
  * http://www.spinics.net/lists/linux-pci/msg34797.html
  */
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0030, quirk_no_bus_reset);
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0032, quirk_no_bus_reset);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x003c, quirk_no_bus_reset);</span>
 
 static void quirk_no_pm_reset(struct pci_dev *dev)
 {
<span class="p_header">diff --git a/drivers/phy/phy-rcar-gen3-usb2.c b/drivers/phy/phy-rcar-gen3-usb2.c</span>
<span class="p_header">index 4be3f5dbbc9f..31156c9c4707 100644</span>
<span class="p_header">--- a/drivers/phy/phy-rcar-gen3-usb2.c</span>
<span class="p_header">+++ b/drivers/phy/phy-rcar-gen3-usb2.c</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/phy/phy.h&gt;
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/regulator/consumer.h&gt;
<span class="p_add">+#include &lt;linux/workqueue.h&gt;</span>
 
 /******* USB2.0 Host registers (original offset is +0x200) *******/
 #define USB2_INT_ENABLE		0x000
<span class="p_chunk">@@ -81,9 +82,25 @@</span> <span class="p_context"> struct rcar_gen3_chan {</span>
 	struct extcon_dev *extcon;
 	struct phy *phy;
 	struct regulator *vbus;
<span class="p_add">+	struct work_struct work;</span>
<span class="p_add">+	bool extcon_host;</span>
 	bool has_otg;
 };
 
<span class="p_add">+static void rcar_gen3_phy_usb2_work(struct work_struct *work)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rcar_gen3_chan *ch = container_of(work, struct rcar_gen3_chan,</span>
<span class="p_add">+						 work);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ch-&gt;extcon_host) {</span>
<span class="p_add">+		extcon_set_cable_state_(ch-&gt;extcon, EXTCON_USB_HOST, true);</span>
<span class="p_add">+		extcon_set_cable_state_(ch-&gt;extcon, EXTCON_USB, false);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		extcon_set_cable_state_(ch-&gt;extcon, EXTCON_USB_HOST, false);</span>
<span class="p_add">+		extcon_set_cable_state_(ch-&gt;extcon, EXTCON_USB, true);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void rcar_gen3_set_host_mode(struct rcar_gen3_chan *ch, int host)
 {
 	void __iomem *usb2_base = ch-&gt;base;
<span class="p_chunk">@@ -130,8 +147,8 @@</span> <span class="p_context"> static void rcar_gen3_init_for_host(struct rcar_gen3_chan *ch)</span>
 	rcar_gen3_set_host_mode(ch, 1);
 	rcar_gen3_enable_vbus_ctrl(ch, 1);
 
<span class="p_del">-	extcon_set_cable_state_(ch-&gt;extcon, EXTCON_USB_HOST, true);</span>
<span class="p_del">-	extcon_set_cable_state_(ch-&gt;extcon, EXTCON_USB, false);</span>
<span class="p_add">+	ch-&gt;extcon_host = true;</span>
<span class="p_add">+	schedule_work(&amp;ch-&gt;work);</span>
 }
 
 static void rcar_gen3_init_for_peri(struct rcar_gen3_chan *ch)
<span class="p_chunk">@@ -140,8 +157,8 @@</span> <span class="p_context"> static void rcar_gen3_init_for_peri(struct rcar_gen3_chan *ch)</span>
 	rcar_gen3_set_host_mode(ch, 0);
 	rcar_gen3_enable_vbus_ctrl(ch, 0);
 
<span class="p_del">-	extcon_set_cable_state_(ch-&gt;extcon, EXTCON_USB_HOST, false);</span>
<span class="p_del">-	extcon_set_cable_state_(ch-&gt;extcon, EXTCON_USB, true);</span>
<span class="p_add">+	ch-&gt;extcon_host = false;</span>
<span class="p_add">+	schedule_work(&amp;ch-&gt;work);</span>
 }
 
 static bool rcar_gen3_check_id(struct rcar_gen3_chan *ch)
<span class="p_chunk">@@ -301,6 +318,7 @@</span> <span class="p_context"> static int rcar_gen3_phy_usb2_probe(struct platform_device *pdev)</span>
 	if (irq &gt;= 0) {
 		int ret;
 
<span class="p_add">+		INIT_WORK(&amp;channel-&gt;work, rcar_gen3_phy_usb2_work);</span>
 		irq = devm_request_irq(dev, irq, rcar_gen3_phy_usb2_irq,
 				       IRQF_SHARED, dev_name(dev), channel);
 		if (irq &lt; 0)
<span class="p_header">diff --git a/drivers/pinctrl/intel/pinctrl-cherryview.c b/drivers/pinctrl/intel/pinctrl-cherryview.c</span>
<span class="p_header">index ac4f564f1c3e..bf65c948b31d 100644</span>
<span class="p_header">--- a/drivers/pinctrl/intel/pinctrl-cherryview.c</span>
<span class="p_header">+++ b/drivers/pinctrl/intel/pinctrl-cherryview.c</span>
<span class="p_chunk">@@ -160,7 +160,6 @@</span> <span class="p_context"> struct chv_pin_context {</span>
  * @pctldev: Pointer to the pin controller device
  * @chip: GPIO chip in this pin controller
  * @regs: MMIO registers
<span class="p_del">- * @lock: Lock to serialize register accesses</span>
  * @intr_lines: Stores mapping between 16 HW interrupt wires and GPIO
  *		offset (in GPIO number space)
  * @community: Community this pinctrl instance represents
<span class="p_chunk">@@ -174,7 +173,6 @@</span> <span class="p_context"> struct chv_pinctrl {</span>
 	struct pinctrl_dev *pctldev;
 	struct gpio_chip chip;
 	void __iomem *regs;
<span class="p_del">-	raw_spinlock_t lock;</span>
 	unsigned intr_lines[16];
 	const struct chv_community *community;
 	u32 saved_intmask;
<span class="p_chunk">@@ -657,6 +655,17 @@</span> <span class="p_context"> static const struct chv_community *chv_communities[] = {</span>
 	&amp;southeast_community,
 };
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Lock to serialize register accesses</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Due to a silicon issue, a shared lock must be used to prevent</span>
<span class="p_add">+ * concurrent accesses across the 4 GPIO controllers.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * See Intel Atom Z8000 Processor Series Specification Update (Rev. 005),</span>
<span class="p_add">+ * errata #CHT34, for further information.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static DEFINE_RAW_SPINLOCK(chv_lock);</span>
<span class="p_add">+</span>
 static void __iomem *chv_padreg(struct chv_pinctrl *pctrl, unsigned offset,
 				unsigned reg)
 {
<span class="p_chunk">@@ -718,13 +727,13 @@</span> <span class="p_context"> static void chv_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,</span>
 	u32 ctrl0, ctrl1;
 	bool locked;
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 
 	ctrl0 = readl(chv_padreg(pctrl, offset, CHV_PADCTRL0));
 	ctrl1 = readl(chv_padreg(pctrl, offset, CHV_PADCTRL1));
 	locked = chv_pad_locked(pctrl, offset);
 
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 
 	if (ctrl0 &amp; CHV_PADCTRL0_GPIOEN) {
 		seq_puts(s, &quot;GPIO &quot;);
<span class="p_chunk">@@ -787,14 +796,14 @@</span> <span class="p_context"> static int chv_pinmux_set_mux(struct pinctrl_dev *pctldev, unsigned function,</span>
 
 	grp = &amp;pctrl-&gt;community-&gt;groups[group];
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 
 	/* Check first that the pad is not locked */
 	for (i = 0; i &lt; grp-&gt;npins; i++) {
 		if (chv_pad_locked(pctrl, grp-&gt;pins[i])) {
 			dev_warn(pctrl-&gt;dev, &quot;unable to set mode for locked pin %u\n&quot;,
 				 grp-&gt;pins[i]);
<span class="p_del">-			raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+			raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 			return -EBUSY;
 		}
 	}
<span class="p_chunk">@@ -837,7 +846,7 @@</span> <span class="p_context"> static int chv_pinmux_set_mux(struct pinctrl_dev *pctldev, unsigned function,</span>
 			pin, altfunc-&gt;mode, altfunc-&gt;invert_oe ? &quot;&quot; : &quot;not &quot;);
 	}
 
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -851,13 +860,13 @@</span> <span class="p_context"> static int chv_gpio_request_enable(struct pinctrl_dev *pctldev,</span>
 	void __iomem *reg;
 	u32 value;
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 
 	if (chv_pad_locked(pctrl, offset)) {
 		value = readl(chv_padreg(pctrl, offset, CHV_PADCTRL0));
 		if (!(value &amp; CHV_PADCTRL0_GPIOEN)) {
 			/* Locked so cannot enable */
<span class="p_del">-			raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+			raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 			return -EBUSY;
 		}
 	} else {
<span class="p_chunk">@@ -897,7 +906,7 @@</span> <span class="p_context"> static int chv_gpio_request_enable(struct pinctrl_dev *pctldev,</span>
 		chv_writel(value, reg);
 	}
 
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -911,13 +920,13 @@</span> <span class="p_context"> static void chv_gpio_disable_free(struct pinctrl_dev *pctldev,</span>
 	void __iomem *reg;
 	u32 value;
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 
 	reg = chv_padreg(pctrl, offset, CHV_PADCTRL0);
 	value = readl(reg) &amp; ~CHV_PADCTRL0_GPIOEN;
 	chv_writel(value, reg);
 
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 }
 
 static int chv_gpio_set_direction(struct pinctrl_dev *pctldev,
<span class="p_chunk">@@ -929,7 +938,7 @@</span> <span class="p_context"> static int chv_gpio_set_direction(struct pinctrl_dev *pctldev,</span>
 	unsigned long flags;
 	u32 ctrl0;
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 
 	ctrl0 = readl(reg) &amp; ~CHV_PADCTRL0_GPIOCFG_MASK;
 	if (input)
<span class="p_chunk">@@ -938,7 +947,7 @@</span> <span class="p_context"> static int chv_gpio_set_direction(struct pinctrl_dev *pctldev,</span>
 		ctrl0 |= CHV_PADCTRL0_GPIOCFG_GPO &lt;&lt; CHV_PADCTRL0_GPIOCFG_SHIFT;
 	chv_writel(ctrl0, reg);
 
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -963,10 +972,10 @@</span> <span class="p_context"> static int chv_config_get(struct pinctrl_dev *pctldev, unsigned pin,</span>
 	u16 arg = 0;
 	u32 term;
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 	ctrl0 = readl(chv_padreg(pctrl, pin, CHV_PADCTRL0));
 	ctrl1 = readl(chv_padreg(pctrl, pin, CHV_PADCTRL1));
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 
 	term = (ctrl0 &amp; CHV_PADCTRL0_TERM_MASK) &gt;&gt; CHV_PADCTRL0_TERM_SHIFT;
 
<span class="p_chunk">@@ -1040,7 +1049,7 @@</span> <span class="p_context"> static int chv_config_set_pull(struct chv_pinctrl *pctrl, unsigned pin,</span>
 	unsigned long flags;
 	u32 ctrl0, pull;
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 	ctrl0 = readl(reg);
 
 	switch (param) {
<span class="p_chunk">@@ -1063,7 +1072,7 @@</span> <span class="p_context"> static int chv_config_set_pull(struct chv_pinctrl *pctrl, unsigned pin,</span>
 			pull = CHV_PADCTRL0_TERM_20K &lt;&lt; CHV_PADCTRL0_TERM_SHIFT;
 			break;
 		default:
<span class="p_del">-			raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+			raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 			return -EINVAL;
 		}
 
<span class="p_chunk">@@ -1081,7 +1090,7 @@</span> <span class="p_context"> static int chv_config_set_pull(struct chv_pinctrl *pctrl, unsigned pin,</span>
 			pull = CHV_PADCTRL0_TERM_20K &lt;&lt; CHV_PADCTRL0_TERM_SHIFT;
 			break;
 		default:
<span class="p_del">-			raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+			raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 			return -EINVAL;
 		}
 
<span class="p_chunk">@@ -1089,12 +1098,12 @@</span> <span class="p_context"> static int chv_config_set_pull(struct chv_pinctrl *pctrl, unsigned pin,</span>
 		break;
 
 	default:
<span class="p_del">-		raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+		raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 		return -EINVAL;
 	}
 
 	chv_writel(ctrl0, reg);
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1160,9 +1169,9 @@</span> <span class="p_context"> static int chv_gpio_get(struct gpio_chip *chip, unsigned offset)</span>
 	unsigned long flags;
 	u32 ctrl0, cfg;
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 	ctrl0 = readl(chv_padreg(pctrl, pin, CHV_PADCTRL0));
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 
 	cfg = ctrl0 &amp; CHV_PADCTRL0_GPIOCFG_MASK;
 	cfg &gt;&gt;= CHV_PADCTRL0_GPIOCFG_SHIFT;
<span class="p_chunk">@@ -1180,7 +1189,7 @@</span> <span class="p_context"> static void chv_gpio_set(struct gpio_chip *chip, unsigned offset, int value)</span>
 	void __iomem *reg;
 	u32 ctrl0;
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 
 	reg = chv_padreg(pctrl, pin, CHV_PADCTRL0);
 	ctrl0 = readl(reg);
<span class="p_chunk">@@ -1192,7 +1201,7 @@</span> <span class="p_context"> static void chv_gpio_set(struct gpio_chip *chip, unsigned offset, int value)</span>
 
 	chv_writel(ctrl0, reg);
 
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 }
 
 static int chv_gpio_get_direction(struct gpio_chip *chip, unsigned offset)
<span class="p_chunk">@@ -1202,9 +1211,9 @@</span> <span class="p_context"> static int chv_gpio_get_direction(struct gpio_chip *chip, unsigned offset)</span>
 	u32 ctrl0, direction;
 	unsigned long flags;
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 	ctrl0 = readl(chv_padreg(pctrl, pin, CHV_PADCTRL0));
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 
 	direction = ctrl0 &amp; CHV_PADCTRL0_GPIOCFG_MASK;
 	direction &gt;&gt;= CHV_PADCTRL0_GPIOCFG_SHIFT;
<span class="p_chunk">@@ -1242,14 +1251,14 @@</span> <span class="p_context"> static void chv_gpio_irq_ack(struct irq_data *d)</span>
 	int pin = chv_gpio_offset_to_pin(pctrl, irqd_to_hwirq(d));
 	u32 intr_line;
 
<span class="p_del">-	raw_spin_lock(&amp;pctrl-&gt;lock);</span>
<span class="p_add">+	raw_spin_lock(&amp;chv_lock);</span>
 
 	intr_line = readl(chv_padreg(pctrl, pin, CHV_PADCTRL0));
 	intr_line &amp;= CHV_PADCTRL0_INTSEL_MASK;
 	intr_line &gt;&gt;= CHV_PADCTRL0_INTSEL_SHIFT;
 	chv_writel(BIT(intr_line), pctrl-&gt;regs + CHV_INTSTAT);
 
<span class="p_del">-	raw_spin_unlock(&amp;pctrl-&gt;lock);</span>
<span class="p_add">+	raw_spin_unlock(&amp;chv_lock);</span>
 }
 
 static void chv_gpio_irq_mask_unmask(struct irq_data *d, bool mask)
<span class="p_chunk">@@ -1260,7 +1269,7 @@</span> <span class="p_context"> static void chv_gpio_irq_mask_unmask(struct irq_data *d, bool mask)</span>
 	u32 value, intr_line;
 	unsigned long flags;
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 
 	intr_line = readl(chv_padreg(pctrl, pin, CHV_PADCTRL0));
 	intr_line &amp;= CHV_PADCTRL0_INTSEL_MASK;
<span class="p_chunk">@@ -1273,7 +1282,7 @@</span> <span class="p_context"> static void chv_gpio_irq_mask_unmask(struct irq_data *d, bool mask)</span>
 		value |= BIT(intr_line);
 	chv_writel(value, pctrl-&gt;regs + CHV_INTMASK);
 
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 }
 
 static void chv_gpio_irq_mask(struct irq_data *d)
<span class="p_chunk">@@ -1307,7 +1316,7 @@</span> <span class="p_context"> static unsigned chv_gpio_irq_startup(struct irq_data *d)</span>
 		unsigned long flags;
 		u32 intsel, value;
 
<span class="p_del">-		raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+		raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 		intsel = readl(chv_padreg(pctrl, pin, CHV_PADCTRL0));
 		intsel &amp;= CHV_PADCTRL0_INTSEL_MASK;
 		intsel &gt;&gt;= CHV_PADCTRL0_INTSEL_SHIFT;
<span class="p_chunk">@@ -1322,7 +1331,7 @@</span> <span class="p_context"> static unsigned chv_gpio_irq_startup(struct irq_data *d)</span>
 			irq_set_handler_locked(d, handler);
 			pctrl-&gt;intr_lines[intsel] = offset;
 		}
<span class="p_del">-		raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+		raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 	}
 
 	chv_gpio_irq_unmask(d);
<span class="p_chunk">@@ -1338,7 +1347,7 @@</span> <span class="p_context"> static int chv_gpio_irq_type(struct irq_data *d, unsigned type)</span>
 	unsigned long flags;
 	u32 value;
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 
 	/*
 	 * Pins which can be used as shared interrupt are configured in
<span class="p_chunk">@@ -1387,7 +1396,7 @@</span> <span class="p_context"> static int chv_gpio_irq_type(struct irq_data *d, unsigned type)</span>
 	else if (type &amp; IRQ_TYPE_LEVEL_MASK)
 		irq_set_handler_locked(d, handle_level_irq);
 
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1499,7 +1508,6 @@</span> <span class="p_context"> static int chv_pinctrl_probe(struct platform_device *pdev)</span>
 	if (i == ARRAY_SIZE(chv_communities))
 		return -ENODEV;
 
<span class="p_del">-	raw_spin_lock_init(&amp;pctrl-&gt;lock);</span>
 	pctrl-&gt;dev = &amp;pdev-&gt;dev;
 
 #ifdef CONFIG_PM_SLEEP
<span class="p_header">diff --git a/drivers/platform/x86/hp-wmi.c b/drivers/platform/x86/hp-wmi.c</span>
<span class="p_header">index 6f145f2d004d..96ffda493266 100644</span>
<span class="p_header">--- a/drivers/platform/x86/hp-wmi.c</span>
<span class="p_header">+++ b/drivers/platform/x86/hp-wmi.c</span>
<span class="p_chunk">@@ -718,6 +718,11 @@</span> <span class="p_context"> static int __init hp_wmi_rfkill_setup(struct platform_device *device)</span>
 	if (err)
 		return err;
 
<span class="p_add">+	err = hp_wmi_perform_query(HPWMI_WIRELESS_QUERY, 1, &amp;wireless,</span>
<span class="p_add">+				   sizeof(wireless), 0);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
 	if (wireless &amp; 0x1) {
 		wifi_rfkill = rfkill_alloc(&quot;hp-wifi&quot;, &amp;device-&gt;dev,
 					   RFKILL_TYPE_WLAN,
<span class="p_chunk">@@ -882,7 +887,7 @@</span> <span class="p_context"> static int __init hp_wmi_bios_setup(struct platform_device *device)</span>
 	wwan_rfkill = NULL;
 	rfkill2_count = 0;
 
<span class="p_del">-	if (hp_wmi_bios_2009_later() || hp_wmi_rfkill_setup(device))</span>
<span class="p_add">+	if (hp_wmi_rfkill_setup(device))</span>
 		hp_wmi_rfkill2_setup(device);
 
 	err = device_create_file(&amp;device-&gt;dev, &amp;dev_attr_display);
<span class="p_header">diff --git a/drivers/regulator/s2mps11.c b/drivers/regulator/s2mps11.c</span>
<span class="p_header">index 02fb6b4ea820..d838e77dd947 100644</span>
<span class="p_header">--- a/drivers/regulator/s2mps11.c</span>
<span class="p_header">+++ b/drivers/regulator/s2mps11.c</span>
<span class="p_chunk">@@ -750,7 +750,7 @@</span> <span class="p_context"> static const struct regulator_linear_range s2mps15_ldo_voltage_ranges3[] = {</span>
 
 /* voltage range for s2mps15 LDO 7, 8, 9 and 10 */
 static const struct regulator_linear_range s2mps15_ldo_voltage_ranges4[] = {
<span class="p_del">-	REGULATOR_LINEAR_RANGE(700000, 0xc, 0x18, 25000),</span>
<span class="p_add">+	REGULATOR_LINEAR_RANGE(700000, 0x10, 0x20, 25000),</span>
 };
 
 /* voltage range for s2mps15 LDO 1 */
<span class="p_chunk">@@ -760,12 +760,12 @@</span> <span class="p_context"> static const struct regulator_linear_range s2mps15_ldo_voltage_ranges5[] = {</span>
 
 /* voltage range for s2mps15 BUCK 1, 2, 3, 4, 5, 6 and 7 */
 static const struct regulator_linear_range s2mps15_buck_voltage_ranges1[] = {
<span class="p_del">-	REGULATOR_LINEAR_RANGE(500000, 0x20, 0xb0, 6250),</span>
<span class="p_add">+	REGULATOR_LINEAR_RANGE(500000, 0x20, 0xc0, 6250),</span>
 };
 
 /* voltage range for s2mps15 BUCK 8, 9 and 10 */
 static const struct regulator_linear_range s2mps15_buck_voltage_ranges2[] = {
<span class="p_del">-	REGULATOR_LINEAR_RANGE(1000000, 0x20, 0xc0, 12500),</span>
<span class="p_add">+	REGULATOR_LINEAR_RANGE(1000000, 0x20, 0x78, 12500),</span>
 };
 
 static const struct regulator_desc s2mps15_regulators[] = {
<span class="p_header">diff --git a/drivers/remoteproc/remoteproc_core.c b/drivers/remoteproc/remoteproc_core.c</span>
<span class="p_header">index db3958b3f094..fe0539ed9cb5 100644</span>
<span class="p_header">--- a/drivers/remoteproc/remoteproc_core.c</span>
<span class="p_header">+++ b/drivers/remoteproc/remoteproc_core.c</span>
<span class="p_chunk">@@ -1264,11 +1264,6 @@</span> <span class="p_context"> int rproc_add(struct rproc *rproc)</span>
 	if (ret &lt; 0)
 		return ret;
 
<span class="p_del">-	/* expose to rproc_get_by_phandle users */</span>
<span class="p_del">-	mutex_lock(&amp;rproc_list_mutex);</span>
<span class="p_del">-	list_add(&amp;rproc-&gt;node, &amp;rproc_list);</span>
<span class="p_del">-	mutex_unlock(&amp;rproc_list_mutex);</span>
<span class="p_del">-</span>
 	dev_info(dev, &quot;%s is available\n&quot;, rproc-&gt;name);
 
 	dev_info(dev, &quot;Note: remoteproc is still under development and considered experimental.\n&quot;);
<span class="p_chunk">@@ -1276,8 +1271,16 @@</span> <span class="p_context"> int rproc_add(struct rproc *rproc)</span>
 
 	/* create debugfs entries */
 	rproc_create_debug_dir(rproc);
<span class="p_add">+	ret = rproc_add_virtio_devices(rproc);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return ret;</span>
 
<span class="p_del">-	return rproc_add_virtio_devices(rproc);</span>
<span class="p_add">+	/* expose to rproc_get_by_phandle users */</span>
<span class="p_add">+	mutex_lock(&amp;rproc_list_mutex);</span>
<span class="p_add">+	list_add(&amp;rproc-&gt;node, &amp;rproc_list);</span>
<span class="p_add">+	mutex_unlock(&amp;rproc_list_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 EXPORT_SYMBOL(rproc_add);
 
<span class="p_header">diff --git a/drivers/rtc/rtc-s3c.c b/drivers/rtc/rtc-s3c.c</span>
<span class="p_header">index d01ad7e8078e..4e823c4b7a4d 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-s3c.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-s3c.c</span>
<span class="p_chunk">@@ -149,12 +149,14 @@</span> <span class="p_context"> static int s3c_rtc_setfreq(struct s3c_rtc *info, int freq)</span>
 	if (!is_power_of_2(freq))
 		return -EINVAL;
 
<span class="p_add">+	s3c_rtc_enable_clk(info);</span>
 	spin_lock_irq(&amp;info-&gt;pie_lock);
 
 	if (info-&gt;data-&gt;set_freq)
 		info-&gt;data-&gt;set_freq(info, freq);
 
 	spin_unlock_irq(&amp;info-&gt;pie_lock);
<span class="p_add">+	s3c_rtc_disable_clk(info);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/s390/cio/cmf.c b/drivers/s390/cio/cmf.c</span>
<span class="p_header">index b2afad5a5682..2a34eb5f6161 100644</span>
<span class="p_header">--- a/drivers/s390/cio/cmf.c</span>
<span class="p_header">+++ b/drivers/s390/cio/cmf.c</span>
<span class="p_chunk">@@ -753,6 +753,17 @@</span> <span class="p_context"> static void reset_cmb(struct ccw_device *cdev)</span>
 	cmf_generic_reset(cdev);
 }
 
<span class="p_add">+static int cmf_enabled(struct ccw_device *cdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int enabled;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irq(cdev-&gt;ccwlock);</span>
<span class="p_add">+	enabled = !!cdev-&gt;private-&gt;cmb;</span>
<span class="p_add">+	spin_unlock_irq(cdev-&gt;ccwlock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return enabled;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct attribute_group cmf_attr_group;
 
 static struct cmb_operations cmbops_basic = {
<span class="p_chunk">@@ -1153,13 +1164,8 @@</span> <span class="p_context"> static ssize_t cmb_enable_show(struct device *dev,</span>
 			       char *buf)
 {
 	struct ccw_device *cdev = to_ccwdev(dev);
<span class="p_del">-	int enabled;</span>
 
<span class="p_del">-	spin_lock_irq(cdev-&gt;ccwlock);</span>
<span class="p_del">-	enabled = !!cdev-&gt;private-&gt;cmb;</span>
<span class="p_del">-	spin_unlock_irq(cdev-&gt;ccwlock);</span>
<span class="p_del">-</span>
<span class="p_del">-	return sprintf(buf, &quot;%d\n&quot;, enabled);</span>
<span class="p_add">+	return sprintf(buf, &quot;%d\n&quot;, cmf_enabled(cdev));</span>
 }
 
 static ssize_t cmb_enable_store(struct device *dev,
<span class="p_chunk">@@ -1199,15 +1205,20 @@</span> <span class="p_context"> int ccw_set_cmf(struct ccw_device *cdev, int enable)</span>
  *  @cdev:	The ccw device to be enabled
  *
  *  Returns %0 for success or a negative error value.
<span class="p_del">- *</span>
<span class="p_add">+ *  Note: If this is called on a device for which channel measurement is already</span>
<span class="p_add">+ *	  enabled a reset of the measurement data is triggered.</span>
  *  Context:
  *    non-atomic
  */
 int enable_cmf(struct ccw_device *cdev)
 {
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = 0;</span>
 
 	device_lock(&amp;cdev-&gt;dev);
<span class="p_add">+	if (cmf_enabled(cdev)) {</span>
<span class="p_add">+		cmbops-&gt;reset(cdev);</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
 	get_device(&amp;cdev-&gt;dev);
 	ret = cmbops-&gt;alloc(cdev);
 	if (ret)
<span class="p_chunk">@@ -1226,7 +1237,7 @@</span> <span class="p_context"> int enable_cmf(struct ccw_device *cdev)</span>
 out:
 	if (ret)
 		put_device(&amp;cdev-&gt;dev);
<span class="p_del">-</span>
<span class="p_add">+out_unlock:</span>
 	device_unlock(&amp;cdev-&gt;dev);
 	return ret;
 }
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_scsi.c b/drivers/scsi/lpfc/lpfc_scsi.c</span>
<span class="p_header">index 3bd0be6277b3..c7e5695da4f5 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_scsi.c</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_scsi.c</span>
<span class="p_chunk">@@ -3874,7 +3874,7 @@</span> <span class="p_context"> int lpfc_sli4_scmd_to_wqidx_distr(struct lpfc_hba *phba,</span>
 	uint32_t tag;
 	uint16_t hwq;
 
<span class="p_del">-	if (shost_use_blk_mq(cmnd-&gt;device-&gt;host)) {</span>
<span class="p_add">+	if (cmnd &amp;&amp; shost_use_blk_mq(cmnd-&gt;device-&gt;host)) {</span>
 		tag = blk_mq_unique_tag(cmnd-&gt;request);
 		hwq = blk_mq_unique_tag_to_hwq(tag);
 
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">index f4b0690450d2..2dab3dc2aa69 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_chunk">@@ -4079,6 +4079,12 @@</span> <span class="p_context"> megasas_get_pd_list(struct megasas_instance *instance)</span>
 	struct MR_PD_ADDRESS *pd_addr;
 	dma_addr_t ci_h = 0;
 
<span class="p_add">+	if (instance-&gt;pd_list_not_supported) {</span>
<span class="p_add">+		dev_info(&amp;instance-&gt;pdev-&gt;dev, &quot;MR_DCMD_PD_LIST_QUERY &quot;</span>
<span class="p_add">+		&quot;not supported by firmware\n&quot;);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	cmd = megasas_get_cmd(instance);
 
 	if (!cmd) {
<span class="p_header">diff --git a/drivers/soc/qcom/smp2p.c b/drivers/soc/qcom/smp2p.c</span>
<span class="p_header">index f1eed7f9dd67..9c2788b8f2c3 100644</span>
<span class="p_header">--- a/drivers/soc/qcom/smp2p.c</span>
<span class="p_header">+++ b/drivers/soc/qcom/smp2p.c</span>
<span class="p_chunk">@@ -344,11 +344,12 @@</span> <span class="p_context"> static int qcom_smp2p_outbound_entry(struct qcom_smp2p *smp2p,</span>
 	/* Allocate an entry from the smem item */
 	strlcpy(buf, entry-&gt;name, SMP2P_MAX_ENTRY_NAME);
 	memcpy_toio(out-&gt;entries[out-&gt;valid_entries].name, buf, SMP2P_MAX_ENTRY_NAME);
<span class="p_del">-	out-&gt;valid_entries++;</span>
 
 	/* Make the logical entry reference the physical value */
 	entry-&gt;value = &amp;out-&gt;entries[out-&gt;valid_entries].value;
 
<span class="p_add">+	out-&gt;valid_entries++;</span>
<span class="p_add">+</span>
 	entry-&gt;state = qcom_smem_state_register(node, &amp;smp2p_state_ops, entry);
 	if (IS_ERR(entry-&gt;state)) {
 		dev_err(smp2p-&gt;dev, &quot;failed to register qcom_smem_state\n&quot;);
<span class="p_header">diff --git a/drivers/spi/spi-pxa2xx.c b/drivers/spi/spi-pxa2xx.c</span>
<span class="p_header">index fe07c0592b44..daf28443b7ad 100644</span>
<span class="p_header">--- a/drivers/spi/spi-pxa2xx.c</span>
<span class="p_header">+++ b/drivers/spi/spi-pxa2xx.c</span>
<span class="p_chunk">@@ -585,7 +585,14 @@</span> <span class="p_context"> static void reset_sccr1(struct driver_data *drv_data)</span>
 	u32 sccr1_reg;
 
 	sccr1_reg = pxa2xx_spi_read(drv_data, SSCR1) &amp; ~drv_data-&gt;int_cr1;
<span class="p_del">-	sccr1_reg &amp;= ~SSCR1_RFT;</span>
<span class="p_add">+	switch (drv_data-&gt;ssp_type) {</span>
<span class="p_add">+	case QUARK_X1000_SSP:</span>
<span class="p_add">+		sccr1_reg &amp;= ~QUARK_X1000_SSCR1_RFT;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		sccr1_reg &amp;= ~SSCR1_RFT;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 	sccr1_reg |= chip-&gt;threshold;
 	pxa2xx_spi_write(drv_data, SSCR1, sccr1_reg);
 }
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">index 50f3d3a0dd7b..39b928c2849d 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_chunk">@@ -492,7 +492,8 @@</span> <span class="p_context"> void iscsit_aborted_task(struct iscsi_conn *conn, struct iscsi_cmd *cmd)</span>
 	bool scsi_cmd = (cmd-&gt;iscsi_opcode == ISCSI_OP_SCSI_CMD);
 
 	spin_lock_bh(&amp;conn-&gt;cmd_lock);
<span class="p_del">-	if (!list_empty(&amp;cmd-&gt;i_conn_node))</span>
<span class="p_add">+	if (!list_empty(&amp;cmd-&gt;i_conn_node) &amp;&amp;</span>
<span class="p_add">+	    !(cmd-&gt;se_cmd.transport_state &amp; CMD_T_FABRIC_STOP))</span>
 		list_del_init(&amp;cmd-&gt;i_conn_node);
 	spin_unlock_bh(&amp;conn-&gt;cmd_lock);
 
<span class="p_chunk">@@ -4034,6 +4035,7 @@</span> <span class="p_context"> int iscsi_target_rx_thread(void *arg)</span>
 
 static void iscsit_release_commands_from_conn(struct iscsi_conn *conn)
 {
<span class="p_add">+	LIST_HEAD(tmp_list);</span>
 	struct iscsi_cmd *cmd = NULL, *cmd_tmp = NULL;
 	struct iscsi_session *sess = conn-&gt;sess;
 	/*
<span class="p_chunk">@@ -4042,18 +4044,26 @@</span> <span class="p_context"> static void iscsit_release_commands_from_conn(struct iscsi_conn *conn)</span>
 	 * has been reset -&gt; returned sleeping pre-handler state.
 	 */
 	spin_lock_bh(&amp;conn-&gt;cmd_lock);
<span class="p_del">-	list_for_each_entry_safe(cmd, cmd_tmp, &amp;conn-&gt;conn_cmd_list, i_conn_node) {</span>
<span class="p_add">+	list_splice_init(&amp;conn-&gt;conn_cmd_list, &amp;tmp_list);</span>
 
<span class="p_add">+	list_for_each_entry(cmd, &amp;tmp_list, i_conn_node) {</span>
<span class="p_add">+		struct se_cmd *se_cmd = &amp;cmd-&gt;se_cmd;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (se_cmd-&gt;se_tfo != NULL) {</span>
<span class="p_add">+			spin_lock(&amp;se_cmd-&gt;t_state_lock);</span>
<span class="p_add">+			se_cmd-&gt;transport_state |= CMD_T_FABRIC_STOP;</span>
<span class="p_add">+			spin_unlock(&amp;se_cmd-&gt;t_state_lock);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_bh(&amp;conn-&gt;cmd_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry_safe(cmd, cmd_tmp, &amp;tmp_list, i_conn_node) {</span>
 		list_del_init(&amp;cmd-&gt;i_conn_node);
<span class="p_del">-		spin_unlock_bh(&amp;conn-&gt;cmd_lock);</span>
 
 		iscsit_increment_maxcmdsn(cmd, sess);
<span class="p_del">-</span>
 		iscsit_free_cmd(cmd, true);
 
<span class="p_del">-		spin_lock_bh(&amp;conn-&gt;cmd_lock);</span>
 	}
<span class="p_del">-	spin_unlock_bh(&amp;conn-&gt;cmd_lock);</span>
 }
 
 static void iscsit_stop_timers_for_cmds(
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_login.c b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">index b5212f0f9571..adf419fa4291 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_chunk">@@ -1371,8 +1371,9 @@</span> <span class="p_context"> static int __iscsi_target_login_thread(struct iscsi_np *np)</span>
 	}
 	login-&gt;zero_tsih = zero_tsih;
 
<span class="p_del">-	conn-&gt;sess-&gt;se_sess-&gt;sup_prot_ops =</span>
<span class="p_del">-		conn-&gt;conn_transport-&gt;iscsit_get_sup_prot_ops(conn);</span>
<span class="p_add">+	if (conn-&gt;sess)</span>
<span class="p_add">+		conn-&gt;sess-&gt;se_sess-&gt;sup_prot_ops =</span>
<span class="p_add">+			conn-&gt;conn_transport-&gt;iscsit_get_sup_prot_ops(conn);</span>
 
 	tpg = conn-&gt;tpg;
 	if (!tpg) {
<span class="p_header">diff --git a/drivers/target/target_core_device.c b/drivers/target/target_core_device.c</span>
<span class="p_header">index a4046ca6e60d..6b423485c5d6 100644</span>
<span class="p_header">--- a/drivers/target/target_core_device.c</span>
<span class="p_header">+++ b/drivers/target/target_core_device.c</span>
<span class="p_chunk">@@ -821,13 +821,15 @@</span> <span class="p_context"> struct se_device *target_alloc_device(struct se_hba *hba, const char *name)</span>
  * in ATA and we need to set TPE=1
  */
 bool target_configure_unmap_from_queue(struct se_dev_attrib *attrib,
<span class="p_del">-				       struct request_queue *q, int block_size)</span>
<span class="p_add">+				       struct request_queue *q)</span>
 {
<span class="p_add">+	int block_size = queue_logical_block_size(q);</span>
<span class="p_add">+</span>
 	if (!blk_queue_discard(q))
 		return false;
 
<span class="p_del">-	attrib-&gt;max_unmap_lba_count = (q-&gt;limits.max_discard_sectors &lt;&lt; 9) /</span>
<span class="p_del">-								block_size;</span>
<span class="p_add">+	attrib-&gt;max_unmap_lba_count =</span>
<span class="p_add">+		q-&gt;limits.max_discard_sectors &gt;&gt; (ilog2(block_size) - 9);</span>
 	/*
 	 * Currently hardcoded to 1 in Linux/SCSI code..
 	 */
<span class="p_header">diff --git a/drivers/target/target_core_file.c b/drivers/target/target_core_file.c</span>
<span class="p_header">index 75f0f08b2a34..79291869bce6 100644</span>
<span class="p_header">--- a/drivers/target/target_core_file.c</span>
<span class="p_header">+++ b/drivers/target/target_core_file.c</span>
<span class="p_chunk">@@ -161,8 +161,7 @@</span> <span class="p_context"> static int fd_configure_device(struct se_device *dev)</span>
 			dev_size, div_u64(dev_size, fd_dev-&gt;fd_block_size),
 			fd_dev-&gt;fd_block_size);
 
<span class="p_del">-		if (target_configure_unmap_from_queue(&amp;dev-&gt;dev_attrib, q,</span>
<span class="p_del">-						      fd_dev-&gt;fd_block_size))</span>
<span class="p_add">+		if (target_configure_unmap_from_queue(&amp;dev-&gt;dev_attrib, q))</span>
 			pr_debug(&quot;IFILE: BLOCK Discard support available,&quot;
 				 &quot; disabled by default\n&quot;);
 		/*
<span class="p_header">diff --git a/drivers/target/target_core_iblock.c b/drivers/target/target_core_iblock.c</span>
<span class="p_header">index 7c4efb4417b0..2077bc28640a 100644</span>
<span class="p_header">--- a/drivers/target/target_core_iblock.c</span>
<span class="p_header">+++ b/drivers/target/target_core_iblock.c</span>
<span class="p_chunk">@@ -121,8 +121,7 @@</span> <span class="p_context"> static int iblock_configure_device(struct se_device *dev)</span>
 	dev-&gt;dev_attrib.hw_max_sectors = queue_max_hw_sectors(q);
 	dev-&gt;dev_attrib.hw_queue_depth = q-&gt;nr_requests;
 
<span class="p_del">-	if (target_configure_unmap_from_queue(&amp;dev-&gt;dev_attrib, q,</span>
<span class="p_del">-					      dev-&gt;dev_attrib.hw_block_size))</span>
<span class="p_add">+	if (target_configure_unmap_from_queue(&amp;dev-&gt;dev_attrib, q))</span>
 		pr_debug(&quot;IBLOCK: BLOCK Discard support available,&quot;
 			 &quot; disabled by default\n&quot;);
 
<span class="p_header">diff --git a/drivers/target/target_core_internal.h b/drivers/target/target_core_internal.h</span>
<span class="p_header">index fc91e85f54ba..e2c970a9d61c 100644</span>
<span class="p_header">--- a/drivers/target/target_core_internal.h</span>
<span class="p_header">+++ b/drivers/target/target_core_internal.h</span>
<span class="p_chunk">@@ -146,6 +146,7 @@</span> <span class="p_context"> sense_reason_t	target_cmd_size_check(struct se_cmd *cmd, unsigned int size);</span>
 void	target_qf_do_work(struct work_struct *work);
 bool	target_check_wce(struct se_device *dev);
 bool	target_check_fua(struct se_device *dev);
<span class="p_add">+void	__target_execute_cmd(struct se_cmd *, bool);</span>
 
 /* target_core_stat.c */
 void	target_stat_setup_dev_default_groups(struct se_device *);
<span class="p_header">diff --git a/drivers/target/target_core_sbc.c b/drivers/target/target_core_sbc.c</span>
<span class="p_header">index a9057aa07176..04f616b3ba0a 100644</span>
<span class="p_header">--- a/drivers/target/target_core_sbc.c</span>
<span class="p_header">+++ b/drivers/target/target_core_sbc.c</span>
<span class="p_chunk">@@ -602,7 +602,7 @@</span> <span class="p_context"> static sense_reason_t compare_and_write_callback(struct se_cmd *cmd, bool succes</span>
 	cmd-&gt;transport_state |= CMD_T_ACTIVE|CMD_T_BUSY|CMD_T_SENT;
 	spin_unlock_irq(&amp;cmd-&gt;t_state_lock);
 
<span class="p_del">-	__target_execute_cmd(cmd);</span>
<span class="p_add">+	__target_execute_cmd(cmd, false);</span>
 
 	kfree(buf);
 	return ret;
<span class="p_header">diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c</span>
<span class="p_header">index 5ab3967dda43..42c2a44b83dd 100644</span>
<span class="p_header">--- a/drivers/target/target_core_transport.c</span>
<span class="p_header">+++ b/drivers/target/target_core_transport.c</span>
<span class="p_chunk">@@ -1303,23 +1303,6 @@</span> <span class="p_context"> target_setup_cmd_from_cdb(struct se_cmd *cmd, unsigned char *cdb)</span>
 
 	trace_target_sequencer_start(cmd);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Check for an existing UNIT ATTENTION condition</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ret = target_scsi3_ua_check(cmd);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = target_alua_state_check(cmd);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = target_check_reservation(cmd);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		cmd-&gt;scsi_status = SAM_STAT_RESERVATION_CONFLICT;</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	ret = dev-&gt;transport-&gt;parse_cdb(cmd);
 	if (ret == TCM_UNSUPPORTED_SCSI_OPCODE)
 		pr_warn_ratelimited(&quot;%s/%s: Unsupported SCSI Opcode 0x%02x, sending CHECK_CONDITION.\n&quot;,
<span class="p_chunk">@@ -1761,20 +1744,45 @@</span> <span class="p_context"> queue_full:</span>
 }
 EXPORT_SYMBOL(transport_generic_request_failure);
 
<span class="p_del">-void __target_execute_cmd(struct se_cmd *cmd)</span>
<span class="p_add">+void __target_execute_cmd(struct se_cmd *cmd, bool do_checks)</span>
 {
 	sense_reason_t ret;
 
<span class="p_del">-	if (cmd-&gt;execute_cmd) {</span>
<span class="p_del">-		ret = cmd-&gt;execute_cmd(cmd);</span>
<span class="p_del">-		if (ret) {</span>
<span class="p_del">-			spin_lock_irq(&amp;cmd-&gt;t_state_lock);</span>
<span class="p_del">-			cmd-&gt;transport_state &amp;= ~(CMD_T_BUSY|CMD_T_SENT);</span>
<span class="p_del">-			spin_unlock_irq(&amp;cmd-&gt;t_state_lock);</span>
<span class="p_add">+	if (!cmd-&gt;execute_cmd) {</span>
<span class="p_add">+		ret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (do_checks) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Check for an existing UNIT ATTENTION condition after</span>
<span class="p_add">+		 * target_handle_task_attr() has done SAM task attr</span>
<span class="p_add">+		 * checking, and possibly have already defered execution</span>
<span class="p_add">+		 * out to target_restart_delayed_cmds() context.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		ret = target_scsi3_ua_check(cmd);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto err;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = target_alua_state_check(cmd);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto err;</span>
 
<span class="p_del">-			transport_generic_request_failure(cmd, ret);</span>
<span class="p_add">+		ret = target_check_reservation(cmd);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			cmd-&gt;scsi_status = SAM_STAT_RESERVATION_CONFLICT;</span>
<span class="p_add">+			goto err;</span>
 		}
 	}
<span class="p_add">+</span>
<span class="p_add">+	ret = cmd-&gt;execute_cmd(cmd);</span>
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+err:</span>
<span class="p_add">+	spin_lock_irq(&amp;cmd-&gt;t_state_lock);</span>
<span class="p_add">+	cmd-&gt;transport_state &amp;= ~(CMD_T_BUSY|CMD_T_SENT);</span>
<span class="p_add">+	spin_unlock_irq(&amp;cmd-&gt;t_state_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	transport_generic_request_failure(cmd, ret);</span>
 }
 
 static int target_write_prot_action(struct se_cmd *cmd)
<span class="p_chunk">@@ -1819,6 +1827,8 @@</span> <span class="p_context"> static bool target_handle_task_attr(struct se_cmd *cmd)</span>
 	if (dev-&gt;transport-&gt;transport_flags &amp; TRANSPORT_FLAG_PASSTHROUGH)
 		return false;
 
<span class="p_add">+	cmd-&gt;se_cmd_flags |= SCF_TASK_ATTR_SET;</span>
<span class="p_add">+</span>
 	/*
 	 * Check for the existence of HEAD_OF_QUEUE, and if true return 1
 	 * to allow the passed struct se_cmd list of tasks to the front of the list.
<span class="p_chunk">@@ -1899,7 +1909,7 @@</span> <span class="p_context"> void target_execute_cmd(struct se_cmd *cmd)</span>
 		return;
 	}
 
<span class="p_del">-	__target_execute_cmd(cmd);</span>
<span class="p_add">+	__target_execute_cmd(cmd, true);</span>
 }
 EXPORT_SYMBOL(target_execute_cmd);
 
<span class="p_chunk">@@ -1923,7 +1933,7 @@</span> <span class="p_context"> static void target_restart_delayed_cmds(struct se_device *dev)</span>
 		list_del(&amp;cmd-&gt;se_delayed_node);
 		spin_unlock(&amp;dev-&gt;delayed_cmd_lock);
 
<span class="p_del">-		__target_execute_cmd(cmd);</span>
<span class="p_add">+		__target_execute_cmd(cmd, true);</span>
 
 		if (cmd-&gt;sam_task_attr == TCM_ORDERED_TAG)
 			break;
<span class="p_chunk">@@ -1941,6 +1951,9 @@</span> <span class="p_context"> static void transport_complete_task_attr(struct se_cmd *cmd)</span>
 	if (dev-&gt;transport-&gt;transport_flags &amp; TRANSPORT_FLAG_PASSTHROUGH)
 		return;
 
<span class="p_add">+	if (!(cmd-&gt;se_cmd_flags &amp; SCF_TASK_ATTR_SET))</span>
<span class="p_add">+		goto restart;</span>
<span class="p_add">+</span>
 	if (cmd-&gt;sam_task_attr == TCM_SIMPLE_TAG) {
 		atomic_dec_mb(&amp;dev-&gt;simple_cmds);
 		dev-&gt;dev_cur_ordered_id++;
<span class="p_chunk">@@ -1957,7 +1970,7 @@</span> <span class="p_context"> static void transport_complete_task_attr(struct se_cmd *cmd)</span>
 		pr_debug(&quot;Incremented dev_cur_ordered_id: %u for ORDERED\n&quot;,
 			 dev-&gt;dev_cur_ordered_id);
 	}
<span class="p_del">-</span>
<span class="p_add">+restart:</span>
 	target_restart_delayed_cmds(dev);
 }
 
<span class="p_chunk">@@ -2557,15 +2570,10 @@</span> <span class="p_context"> static void target_release_cmd_kref(struct kref *kref)</span>
 	bool fabric_stop;
 
 	spin_lock_irqsave(&amp;se_sess-&gt;sess_cmd_lock, flags);
<span class="p_del">-	if (list_empty(&amp;se_cmd-&gt;se_cmd_list)) {</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;se_sess-&gt;sess_cmd_lock, flags);</span>
<span class="p_del">-		target_free_cmd_mem(se_cmd);</span>
<span class="p_del">-		se_cmd-&gt;se_tfo-&gt;release_cmd(se_cmd);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
 
 	spin_lock(&amp;se_cmd-&gt;t_state_lock);
<span class="p_del">-	fabric_stop = (se_cmd-&gt;transport_state &amp; CMD_T_FABRIC_STOP);</span>
<span class="p_add">+	fabric_stop = (se_cmd-&gt;transport_state &amp; CMD_T_FABRIC_STOP) &amp;&amp;</span>
<span class="p_add">+		      (se_cmd-&gt;transport_state &amp; CMD_T_ABORTED);</span>
 	spin_unlock(&amp;se_cmd-&gt;t_state_lock);
 
 	if (se_cmd-&gt;cmd_wait_set || fabric_stop) {
<span class="p_header">diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">index 954941dd8124..f9c798cba83f 100644</span>
<span class="p_header">--- a/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_chunk">@@ -482,19 +482,21 @@</span> <span class="p_context"> static void atmel_start_tx(struct uart_port *port)</span>
 {
 	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
 
<span class="p_del">-	if (atmel_use_pdc_tx(port)) {</span>
<span class="p_del">-		if (atmel_uart_readl(port, ATMEL_PDC_PTSR) &amp; ATMEL_PDC_TXTEN)</span>
<span class="p_del">-			/* The transmitter is already running.  Yes, we</span>
<span class="p_del">-			   really need this.*/</span>
<span class="p_del">-			return;</span>
<span class="p_add">+	if (atmel_use_pdc_tx(port) &amp;&amp; (atmel_uart_readl(port, ATMEL_PDC_PTSR)</span>
<span class="p_add">+				       &amp; ATMEL_PDC_TXTEN))</span>
<span class="p_add">+		/* The transmitter is already running.  Yes, we</span>
<span class="p_add">+		   really need this.*/</span>
<span class="p_add">+		return;</span>
 
<span class="p_add">+	if (atmel_use_pdc_tx(port) || atmel_use_dma_tx(port))</span>
 		if ((port-&gt;rs485.flags &amp; SER_RS485_ENABLED) &amp;&amp;
 		    !(port-&gt;rs485.flags &amp; SER_RS485_RX_DURING_TX))
 			atmel_stop_rx(port);
 
<span class="p_add">+	if (atmel_use_pdc_tx(port))</span>
 		/* re-enable PDC transmit */
 		atmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_TXTEN);
<span class="p_del">-	}</span>
<span class="p_add">+</span>
 	/* Enable interrupts */
 	atmel_uart_writel(port, ATMEL_US_IER, atmel_port-&gt;tx_done_mask);
 }
<span class="p_header">diff --git a/drivers/tty/serial/msm_serial.c b/drivers/tty/serial/msm_serial.c</span>
<span class="p_header">index b7d80bd57db9..7d62610d9de5 100644</span>
<span class="p_header">--- a/drivers/tty/serial/msm_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/msm_serial.c</span>
<span class="p_chunk">@@ -726,7 +726,7 @@</span> <span class="p_context"> static void msm_handle_tx(struct uart_port *port)</span>
 		return;
 	}
 
<span class="p_del">-	pio_count = CIRC_CNT(xmit-&gt;head, xmit-&gt;tail, UART_XMIT_SIZE);</span>
<span class="p_add">+	pio_count = CIRC_CNT_TO_END(xmit-&gt;head, xmit-&gt;tail, UART_XMIT_SIZE);</span>
 	dma_count = CIRC_CNT_TO_END(xmit-&gt;head, xmit-&gt;tail, UART_XMIT_SIZE);
 
 	dma_min = 1;	/* Always DMA */
<span class="p_header">diff --git a/drivers/tty/serial/samsung.c b/drivers/tty/serial/samsung.c</span>
<span class="p_header">index 99bb23161dd6..f0bd2ec0db59 100644</span>
<span class="p_header">--- a/drivers/tty/serial/samsung.c</span>
<span class="p_header">+++ b/drivers/tty/serial/samsung.c</span>
<span class="p_chunk">@@ -1684,7 +1684,7 @@</span> <span class="p_context"> static int s3c24xx_serial_init_port(struct s3c24xx_uart_port *ourport,</span>
 		return -ENODEV;
 
 	if (port-&gt;mapbase != 0)
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	/* setup info for port */
 	port-&gt;dev	= &amp;platdev-&gt;dev;
<span class="p_chunk">@@ -1738,22 +1738,25 @@</span> <span class="p_context"> static int s3c24xx_serial_init_port(struct s3c24xx_uart_port *ourport,</span>
 		ourport-&gt;dma = devm_kzalloc(port-&gt;dev,
 					    sizeof(*ourport-&gt;dma),
 					    GFP_KERNEL);
<span class="p_del">-		if (!ourport-&gt;dma)</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_add">+		if (!ourport-&gt;dma) {</span>
<span class="p_add">+			ret = -ENOMEM;</span>
<span class="p_add">+			goto err;</span>
<span class="p_add">+		}</span>
 	}
 
 	ourport-&gt;clk	= clk_get(&amp;platdev-&gt;dev, &quot;uart&quot;);
 	if (IS_ERR(ourport-&gt;clk)) {
 		pr_err(&quot;%s: Controller clock not found\n&quot;,
 				dev_name(&amp;platdev-&gt;dev));
<span class="p_del">-		return PTR_ERR(ourport-&gt;clk);</span>
<span class="p_add">+		ret = PTR_ERR(ourport-&gt;clk);</span>
<span class="p_add">+		goto err;</span>
 	}
 
 	ret = clk_prepare_enable(ourport-&gt;clk);
 	if (ret) {
 		pr_err(&quot;uart: clock failed to prepare+enable: %d\n&quot;, ret);
 		clk_put(ourport-&gt;clk);
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto err;</span>
 	}
 
 	/* Keep all interrupts masked and cleared */
<span class="p_chunk">@@ -1769,7 +1772,12 @@</span> <span class="p_context"> static int s3c24xx_serial_init_port(struct s3c24xx_uart_port *ourport,</span>
 
 	/* reset the fifos (and setup the uart) */
 	s3c24xx_serial_resetport(port, cfg);
<span class="p_add">+</span>
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+err:</span>
<span class="p_add">+	port-&gt;mapbase = 0;</span>
<span class="p_add">+	return ret;</span>
 }
 
 /* Device driver serial port probe */
<span class="p_header">diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c</span>
<span class="p_header">index 944a6dca0fcb..d2e50a27140c 100644</span>
<span class="p_header">--- a/drivers/usb/core/quirks.c</span>
<span class="p_header">+++ b/drivers/usb/core/quirks.c</span>
<span class="p_chunk">@@ -128,6 +128,9 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	{ USB_DEVICE(0x04f3, 0x016f), .driver_info =
 			USB_QUIRK_DEVICE_QUALIFIER },
 
<span class="p_add">+	{ USB_DEVICE(0x04f3, 0x0381), .driver_info =</span>
<span class="p_add">+			USB_QUIRK_NO_LPM },</span>
<span class="p_add">+</span>
 	{ USB_DEVICE(0x04f3, 0x21b8), .driver_info =
 			USB_QUIRK_DEVICE_QUALIFIER },
 
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index 07248ff1be5c..716f4f051a0a 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -258,11 +258,13 @@</span> <span class="p_context"> int dwc3_send_gadget_ep_cmd(struct dwc3 *dwc, unsigned ep,</span>
 	 * We will also set SUSPHY bit to what it was before returning as stated
 	 * by the same section on Synopsys databook.
 	 */
<span class="p_del">-	reg = dwc3_readl(dwc-&gt;regs, DWC3_GUSB2PHYCFG(0));</span>
<span class="p_del">-	if (unlikely(reg &amp; DWC3_GUSB2PHYCFG_SUSPHY)) {</span>
<span class="p_del">-		susphy = true;</span>
<span class="p_del">-		reg &amp;= ~DWC3_GUSB2PHYCFG_SUSPHY;</span>
<span class="p_del">-		dwc3_writel(dwc-&gt;regs, DWC3_GUSB2PHYCFG(0), reg);</span>
<span class="p_add">+	if (dwc-&gt;gadget.speed &lt;= USB_SPEED_HIGH) {</span>
<span class="p_add">+		reg = dwc3_readl(dwc-&gt;regs, DWC3_GUSB2PHYCFG(0));</span>
<span class="p_add">+		if (unlikely(reg &amp; DWC3_GUSB2PHYCFG_SUSPHY)) {</span>
<span class="p_add">+			susphy = true;</span>
<span class="p_add">+			reg &amp;= ~DWC3_GUSB2PHYCFG_SUSPHY;</span>
<span class="p_add">+			dwc3_writel(dwc-&gt;regs, DWC3_GUSB2PHYCFG(0), reg);</span>
<span class="p_add">+		}</span>
 	}
 
 	if (cmd == DWC3_DEPCMD_STARTTRANSFER) {
<span class="p_chunk">@@ -2023,6 +2025,10 @@</span> <span class="p_context"> static int dwc3_cleanup_done_reqs(struct dwc3 *dwc, struct dwc3_ep *dep,</span>
 		return 1;
 	}
 
<span class="p_add">+	if (usb_endpoint_xfer_isoc(dep-&gt;endpoint.desc))</span>
<span class="p_add">+		if ((event-&gt;status &amp; DEPEVT_STATUS_IOC) &amp;&amp;</span>
<span class="p_add">+				(trb-&gt;ctrl &amp; DWC3_TRB_CTRL_IOC))</span>
<span class="p_add">+			return 0;</span>
 	return 1;
 }
 
<span class="p_header">diff --git a/drivers/usb/gadget/udc/atmel_usba_udc.c b/drivers/usb/gadget/udc/atmel_usba_udc.c</span>
<span class="p_header">index 18569de06b04..bb1f6c8f0f01 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/atmel_usba_udc.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/atmel_usba_udc.c</span>
<span class="p_chunk">@@ -1920,6 +1920,8 @@</span> <span class="p_context"> static struct usba_ep * atmel_udc_of_init(struct platform_device *pdev,</span>
 
 	udc-&gt;errata = match-&gt;data;
 	udc-&gt;pmc = syscon_regmap_lookup_by_compatible(&quot;atmel,at91sam9g45-pmc&quot;);
<span class="p_add">+	if (IS_ERR(udc-&gt;pmc))</span>
<span class="p_add">+		udc-&gt;pmc = syscon_regmap_lookup_by_compatible(&quot;atmel,at91sam9x5-pmc&quot;);</span>
 	if (udc-&gt;errata &amp;&amp; IS_ERR(udc-&gt;pmc))
 		return ERR_CAST(udc-&gt;pmc);
 
<span class="p_header">diff --git a/drivers/usb/gadget/udc/pch_udc.c b/drivers/usb/gadget/udc/pch_udc.c</span>
<span class="p_header">index ebc51ec5790a..71751429814f 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/pch_udc.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/pch_udc.c</span>
<span class="p_chunk">@@ -1477,11 +1477,11 @@</span> <span class="p_context"> static void complete_req(struct pch_udc_ep *ep, struct pch_udc_request *req,</span>
 		req-&gt;dma_mapped = 0;
 	}
 	ep-&gt;halted = 1;
<span class="p_del">-	spin_lock(&amp;dev-&gt;lock);</span>
<span class="p_add">+	spin_unlock(&amp;dev-&gt;lock);</span>
 	if (!ep-&gt;in)
 		pch_udc_ep_clear_rrdy(ep);
 	usb_gadget_giveback_request(&amp;ep-&gt;ep, &amp;req-&gt;req);
<span class="p_del">-	spin_unlock(&amp;dev-&gt;lock);</span>
<span class="p_add">+	spin_lock(&amp;dev-&gt;lock);</span>
 	ep-&gt;halted = halted;
 }
 
<span class="p_chunk">@@ -2573,9 +2573,9 @@</span> <span class="p_context"> static void pch_udc_svc_ur_interrupt(struct pch_udc_dev *dev)</span>
 		empty_req_queue(ep);
 	}
 	if (dev-&gt;driver) {
<span class="p_del">-		spin_lock(&amp;dev-&gt;lock);</span>
<span class="p_del">-		usb_gadget_udc_reset(&amp;dev-&gt;gadget, dev-&gt;driver);</span>
 		spin_unlock(&amp;dev-&gt;lock);
<span class="p_add">+		usb_gadget_udc_reset(&amp;dev-&gt;gadget, dev-&gt;driver);</span>
<span class="p_add">+		spin_lock(&amp;dev-&gt;lock);</span>
 	}
 }
 
<span class="p_chunk">@@ -2654,9 +2654,9 @@</span> <span class="p_context"> static void pch_udc_svc_intf_interrupt(struct pch_udc_dev *dev)</span>
 		dev-&gt;ep[i].halted = 0;
 	}
 	dev-&gt;stall = 0;
<span class="p_del">-	spin_lock(&amp;dev-&gt;lock);</span>
<span class="p_del">-	dev-&gt;driver-&gt;setup(&amp;dev-&gt;gadget, &amp;dev-&gt;setup_data);</span>
 	spin_unlock(&amp;dev-&gt;lock);
<span class="p_add">+	dev-&gt;driver-&gt;setup(&amp;dev-&gt;gadget, &amp;dev-&gt;setup_data);</span>
<span class="p_add">+	spin_lock(&amp;dev-&gt;lock);</span>
 }
 
 /**
<span class="p_chunk">@@ -2691,9 +2691,9 @@</span> <span class="p_context"> static void pch_udc_svc_cfg_interrupt(struct pch_udc_dev *dev)</span>
 	dev-&gt;stall = 0;
 
 	/* call gadget zero with setup data received */
<span class="p_del">-	spin_lock(&amp;dev-&gt;lock);</span>
<span class="p_del">-	dev-&gt;driver-&gt;setup(&amp;dev-&gt;gadget, &amp;dev-&gt;setup_data);</span>
 	spin_unlock(&amp;dev-&gt;lock);
<span class="p_add">+	dev-&gt;driver-&gt;setup(&amp;dev-&gt;gadget, &amp;dev-&gt;setup_data);</span>
<span class="p_add">+	spin_lock(&amp;dev-&gt;lock);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/fifo.c b/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_header">index 7be4e7d57ace..280ed5ff021b 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_chunk">@@ -810,20 +810,27 @@</span> <span class="p_context"> static void xfer_work(struct work_struct *work)</span>
 {
 	struct usbhs_pkt *pkt = container_of(work, struct usbhs_pkt, work);
 	struct usbhs_pipe *pipe = pkt-&gt;pipe;
<span class="p_del">-	struct usbhs_fifo *fifo = usbhs_pipe_to_fifo(pipe);</span>
<span class="p_add">+	struct usbhs_fifo *fifo;</span>
 	struct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);
 	struct dma_async_tx_descriptor *desc;
<span class="p_del">-	struct dma_chan *chan = usbhsf_dma_chan_get(fifo, pkt);</span>
<span class="p_add">+	struct dma_chan *chan;</span>
 	struct device *dev = usbhs_priv_to_dev(priv);
 	enum dma_transfer_direction dir;
<span class="p_add">+	unsigned long flags;</span>
 
<span class="p_add">+	usbhs_lock(priv, flags);</span>
<span class="p_add">+	fifo = usbhs_pipe_to_fifo(pipe);</span>
<span class="p_add">+	if (!fifo)</span>
<span class="p_add">+		goto xfer_work_end;</span>
<span class="p_add">+</span>
<span class="p_add">+	chan = usbhsf_dma_chan_get(fifo, pkt);</span>
 	dir = usbhs_pipe_is_dir_in(pipe) ? DMA_DEV_TO_MEM : DMA_MEM_TO_DEV;
 
 	desc = dmaengine_prep_slave_single(chan, pkt-&gt;dma + pkt-&gt;actual,
 					pkt-&gt;trans, dir,
 					DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
 	if (!desc)
<span class="p_del">-		return;</span>
<span class="p_add">+		goto xfer_work_end;</span>
 
 	desc-&gt;callback		= usbhsf_dma_complete;
 	desc-&gt;callback_param	= pipe;
<span class="p_chunk">@@ -831,7 +838,7 @@</span> <span class="p_context"> static void xfer_work(struct work_struct *work)</span>
 	pkt-&gt;cookie = dmaengine_submit(desc);
 	if (pkt-&gt;cookie &lt; 0) {
 		dev_err(dev, &quot;Failed to submit dma descriptor\n&quot;);
<span class="p_del">-		return;</span>
<span class="p_add">+		goto xfer_work_end;</span>
 	}
 
 	dev_dbg(dev, &quot;  %s %d (%d/ %d)\n&quot;,
<span class="p_chunk">@@ -842,6 +849,9 @@</span> <span class="p_context"> static void xfer_work(struct work_struct *work)</span>
 	usbhs_pipe_set_trans_count_if_bulk(pipe, pkt-&gt;trans);
 	dma_async_issue_pending(chan);
 	usbhs_pipe_enable(pipe);
<span class="p_add">+</span>
<span class="p_add">+xfer_work_end:</span>
<span class="p_add">+	usbhs_unlock(priv, flags);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_header">index 30345c2d01be..50f3363cc382 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_chunk">@@ -585,6 +585,9 @@</span> <span class="p_context"> static int usbhsg_ep_enable(struct usb_ep *ep,</span>
 	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
 	struct usbhs_pipe *pipe;
 	int ret = -EIO;
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	usbhs_lock(priv, flags);</span>
 
 	/*
 	 * if it already have pipe,
<span class="p_chunk">@@ -593,7 +596,8 @@</span> <span class="p_context"> static int usbhsg_ep_enable(struct usb_ep *ep,</span>
 	if (uep-&gt;pipe) {
 		usbhs_pipe_clear(uep-&gt;pipe);
 		usbhs_pipe_sequence_data0(uep-&gt;pipe);
<span class="p_del">-		return 0;</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto usbhsg_ep_enable_end;</span>
 	}
 
 	pipe = usbhs_pipe_malloc(priv,
<span class="p_chunk">@@ -621,6 +625,9 @@</span> <span class="p_context"> static int usbhsg_ep_enable(struct usb_ep *ep,</span>
 		ret = 0;
 	}
 
<span class="p_add">+usbhsg_ep_enable_end:</span>
<span class="p_add">+	usbhs_unlock(priv, flags);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index d96d423d00e6..8e07536c233a 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -273,6 +273,7 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define TELIT_PRODUCT_LE922_USBCFG5		0x1045
 #define TELIT_PRODUCT_LE920			0x1200
 #define TELIT_PRODUCT_LE910			0x1201
<span class="p_add">+#define TELIT_PRODUCT_LE910_USBCFG4		0x1206</span>
 
 /* ZTE PRODUCTS */
 #define ZTE_VENDOR_ID				0x19d2
<span class="p_chunk">@@ -1198,6 +1199,8 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg0 },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE910),
 		.driver_info = (kernel_ulong_t)&amp;telit_le910_blacklist },
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE910_USBCFG4),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg3 },</span>
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920),
 		.driver_info = (kernel_ulong_t)&amp;telit_le920_blacklist },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_MF622, 0xff, 0xff, 0xff) }, /* ZTE WCDMA products */
<span class="p_header">diff --git a/drivers/virtio/virtio_balloon.c b/drivers/virtio/virtio_balloon.c</span>
<span class="p_header">index 476c0e3a7150..f6ea8f4ba7cf 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_balloon.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio_balloon.c</span>
<span class="p_chunk">@@ -202,6 +202,8 @@</span> <span class="p_context"> static unsigned leak_balloon(struct virtio_balloon *vb, size_t num)</span>
 	num = min(num, ARRAY_SIZE(vb-&gt;pfns));
 
 	mutex_lock(&amp;vb-&gt;balloon_lock);
<span class="p_add">+	/* We can&#39;t release more pages than taken */</span>
<span class="p_add">+	num = min(num, (size_t)vb-&gt;num_pages);</span>
 	for (vb-&gt;num_pfns = 0; vb-&gt;num_pfns &lt; num;
 	     vb-&gt;num_pfns += VIRTIO_BALLOON_PAGES_PER_PAGE) {
 		page = balloon_page_dequeue(vb_dev_info);
<span class="p_header">diff --git a/drivers/w1/masters/omap_hdq.c b/drivers/w1/masters/omap_hdq.c</span>
<span class="p_header">index a2eec97d5064..bb09de633939 100644</span>
<span class="p_header">--- a/drivers/w1/masters/omap_hdq.c</span>
<span class="p_header">+++ b/drivers/w1/masters/omap_hdq.c</span>
<span class="p_chunk">@@ -390,8 +390,6 @@</span> <span class="p_context"> static int hdq_read_byte(struct hdq_data *hdq_data, u8 *val)</span>
 		goto out;
 	}
 
<span class="p_del">-	hdq_data-&gt;hdq_irqstatus = 0;</span>
<span class="p_del">-</span>
 	if (!(hdq_data-&gt;hdq_irqstatus &amp; OMAP_HDQ_INT_STATUS_RXCOMPLETE)) {
 		hdq_reg_merge(hdq_data, OMAP_HDQ_CTRL_STATUS,
 			OMAP_HDQ_CTRL_STATUS_DIR | OMAP_HDQ_CTRL_STATUS_GO,
<span class="p_header">diff --git a/fs/btrfs/extent_io.c b/fs/btrfs/extent_io.c</span>
<span class="p_header">index 75533adef998..92fe3f8012db 100644</span>
<span class="p_header">--- a/fs/btrfs/extent_io.c</span>
<span class="p_header">+++ b/fs/btrfs/extent_io.c</span>
<span class="p_chunk">@@ -2696,12 +2696,6 @@</span> <span class="p_context"> struct bio *btrfs_bio_clone(struct bio *bio, gfp_t gfp_mask)</span>
 		btrfs_bio-&gt;csum = NULL;
 		btrfs_bio-&gt;csum_allocated = NULL;
 		btrfs_bio-&gt;end_io = NULL;
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_BLK_CGROUP</span>
<span class="p_del">-		/* FIXME, put this into bio_clone_bioset */</span>
<span class="p_del">-		if (bio-&gt;bi_css)</span>
<span class="p_del">-			bio_associate_blkcg(new, bio-&gt;bi_css);</span>
<span class="p_del">-#endif</span>
 	}
 	return new;
 }
<span class="p_header">diff --git a/fs/btrfs/file.c b/fs/btrfs/file.c</span>
<span class="p_header">index 2234e88cf674..b56887b35889 100644</span>
<span class="p_header">--- a/fs/btrfs/file.c</span>
<span class="p_header">+++ b/fs/btrfs/file.c</span>
<span class="p_chunk">@@ -1629,13 +1629,11 @@</span> <span class="p_context"> again:</span>
 		 * managed to copy.
 		 */
 		if (num_sectors &gt; dirty_sectors) {
<span class="p_del">-			/*</span>
<span class="p_del">-			 * we round down because we don&#39;t want to count</span>
<span class="p_del">-			 * any partial blocks actually sent through the</span>
<span class="p_del">-			 * IO machines</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			release_bytes = round_down(release_bytes - copied,</span>
<span class="p_del">-				      root-&gt;sectorsize);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* release everything except the sectors we dirtied */</span>
<span class="p_add">+			release_bytes -= dirty_sectors &lt;&lt;</span>
<span class="p_add">+				root-&gt;fs_info-&gt;sb-&gt;s_blocksize_bits;</span>
<span class="p_add">+</span>
 			if (copied &gt; 0) {
 				spin_lock(&amp;BTRFS_I(inode)-&gt;lock);
 				BTRFS_I(inode)-&gt;outstanding_extents++;
<span class="p_header">diff --git a/fs/cachefiles/namei.c b/fs/cachefiles/namei.c</span>
<span class="p_header">index 4ae75006e73b..3f7c2cd41f8f 100644</span>
<span class="p_header">--- a/fs/cachefiles/namei.c</span>
<span class="p_header">+++ b/fs/cachefiles/namei.c</span>
<span class="p_chunk">@@ -263,6 +263,8 @@</span> <span class="p_context"> requeue:</span>
 void cachefiles_mark_object_inactive(struct cachefiles_cache *cache,
 				     struct cachefiles_object *object)
 {
<span class="p_add">+	blkcnt_t i_blocks = d_backing_inode(object-&gt;dentry)-&gt;i_blocks;</span>
<span class="p_add">+</span>
 	write_lock(&amp;cache-&gt;active_lock);
 	rb_erase(&amp;object-&gt;active_node, &amp;cache-&gt;active_nodes);
 	clear_bit(CACHEFILES_OBJECT_ACTIVE, &amp;object-&gt;flags);
<span class="p_chunk">@@ -273,8 +275,7 @@</span> <span class="p_context"> void cachefiles_mark_object_inactive(struct cachefiles_cache *cache,</span>
 	/* This object can now be culled, so we need to let the daemon know
 	 * that there is something it can remove if it needs to.
 	 */
<span class="p_del">-	atomic_long_add(d_backing_inode(object-&gt;dentry)-&gt;i_blocks,</span>
<span class="p_del">-			&amp;cache-&gt;b_released);</span>
<span class="p_add">+	atomic_long_add(i_blocks, &amp;cache-&gt;b_released);</span>
 	if (atomic_inc_return(&amp;cache-&gt;f_released))
 		cachefiles_state_changed(cache);
 }
<span class="p_header">diff --git a/fs/cifs/cifs_fs_sb.h b/fs/cifs/cifs_fs_sb.h</span>
<span class="p_header">index 3182273a3407..1418daa03d95 100644</span>
<span class="p_header">--- a/fs/cifs/cifs_fs_sb.h</span>
<span class="p_header">+++ b/fs/cifs/cifs_fs_sb.h</span>
<span class="p_chunk">@@ -46,6 +46,9 @@</span> <span class="p_context"></span>
 #define CIFS_MOUNT_CIFS_BACKUPUID 0x200000 /* backup intent bit for a user */
 #define CIFS_MOUNT_CIFS_BACKUPGID 0x400000 /* backup intent bit for a group */
 #define CIFS_MOUNT_MAP_SFM_CHR	0x800000 /* SFM/MAC mapping for illegal chars */
<span class="p_add">+#define CIFS_MOUNT_USE_PREFIX_PATH 0x1000000 /* make subpath with unaccessible</span>
<span class="p_add">+					      * root mountable</span>
<span class="p_add">+					      */</span>
 
 struct cifs_sb_info {
 	struct rb_root tlink_tree;
<span class="p_chunk">@@ -67,5 +70,6 @@</span> <span class="p_context"> struct cifs_sb_info {</span>
 	struct backing_dev_info bdi;
 	struct delayed_work prune_tlinks;
 	struct rcu_head rcu;
<span class="p_add">+	char *prepath;</span>
 };
 #endif				/* _CIFS_FS_SB_H */
<span class="p_header">diff --git a/fs/cifs/cifsencrypt.c b/fs/cifs/cifsencrypt.c</span>
<span class="p_header">index 6aeb8d4616a4..8347c90cf483 100644</span>
<span class="p_header">--- a/fs/cifs/cifsencrypt.c</span>
<span class="p_header">+++ b/fs/cifs/cifsencrypt.c</span>
<span class="p_chunk">@@ -743,24 +743,26 @@</span> <span class="p_context"> setup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)</span>
 
 	memcpy(ses-&gt;auth_key.response + baselen, tiblob, tilen);
 
<span class="p_add">+	mutex_lock(&amp;ses-&gt;server-&gt;srv_mutex);</span>
<span class="p_add">+</span>
 	rc = crypto_hmacmd5_alloc(ses-&gt;server);
 	if (rc) {
 		cifs_dbg(VFS, &quot;could not crypto alloc hmacmd5 rc %d\n&quot;, rc);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	/* calculate ntlmv2_hash */
 	rc = calc_ntlmv2_hash(ses, ntlmv2_hash, nls_cp);
 	if (rc) {
 		cifs_dbg(VFS, &quot;could not get v2 hash rc %d\n&quot;, rc);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	/* calculate first part of the client response (CR1) */
 	rc = CalcNTLMv2_response(ses, ntlmv2_hash);
 	if (rc) {
 		cifs_dbg(VFS, &quot;Could not calculate CR1 rc: %d\n&quot;, rc);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	/* now calculate the session key for NTLMv2 */
<span class="p_chunk">@@ -769,13 +771,13 @@</span> <span class="p_context"> setup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)</span>
 	if (rc) {
 		cifs_dbg(VFS, &quot;%s: Could not set NTLMV2 Hash as a key\n&quot;,
 			 __func__);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	rc = crypto_shash_init(&amp;ses-&gt;server-&gt;secmech.sdeschmacmd5-&gt;shash);
 	if (rc) {
 		cifs_dbg(VFS, &quot;%s: Could not init hmacmd5\n&quot;, __func__);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	rc = crypto_shash_update(&amp;ses-&gt;server-&gt;secmech.sdeschmacmd5-&gt;shash,
<span class="p_chunk">@@ -783,7 +785,7 @@</span> <span class="p_context"> setup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)</span>
 		CIFS_HMAC_MD5_HASH_SIZE);
 	if (rc) {
 		cifs_dbg(VFS, &quot;%s: Could not update with response\n&quot;, __func__);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	rc = crypto_shash_final(&amp;ses-&gt;server-&gt;secmech.sdeschmacmd5-&gt;shash,
<span class="p_chunk">@@ -791,6 +793,8 @@</span> <span class="p_context"> setup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)</span>
 	if (rc)
 		cifs_dbg(VFS, &quot;%s: Could not generate md5 hash\n&quot;, __func__);
 
<span class="p_add">+unlock:</span>
<span class="p_add">+	mutex_unlock(&amp;ses-&gt;server-&gt;srv_mutex);</span>
 setup_ntlmv2_rsp_ret:
 	kfree(tiblob);
 
<span class="p_header">diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c</span>
<span class="p_header">index 5d841f39c4b7..6bbec5e784cd 100644</span>
<span class="p_header">--- a/fs/cifs/cifsfs.c</span>
<span class="p_header">+++ b/fs/cifs/cifsfs.c</span>
<span class="p_chunk">@@ -689,6 +689,14 @@</span> <span class="p_context"> cifs_do_mount(struct file_system_type *fs_type,</span>
 		goto out_cifs_sb;
 	}
 
<span class="p_add">+	if (volume_info-&gt;prepath) {</span>
<span class="p_add">+		cifs_sb-&gt;prepath = kstrdup(volume_info-&gt;prepath, GFP_KERNEL);</span>
<span class="p_add">+		if (cifs_sb-&gt;prepath == NULL) {</span>
<span class="p_add">+			root = ERR_PTR(-ENOMEM);</span>
<span class="p_add">+			goto out_cifs_sb;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	cifs_setup_cifs_sb(volume_info, cifs_sb);
 
 	rc = cifs_mount(cifs_sb, volume_info);
<span class="p_chunk">@@ -727,7 +735,11 @@</span> <span class="p_context"> cifs_do_mount(struct file_system_type *fs_type,</span>
 		sb-&gt;s_flags |= MS_ACTIVE;
 	}
 
<span class="p_del">-	root = cifs_get_root(volume_info, sb);</span>
<span class="p_add">+	if (cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_USE_PREFIX_PATH)</span>
<span class="p_add">+		root = dget(sb-&gt;s_root);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		root = cifs_get_root(volume_info, sb);</span>
<span class="p_add">+</span>
 	if (IS_ERR(root))
 		goto out_super;
 
<span class="p_header">diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c</span>
<span class="p_header">index 7d2b15c06090..7ae03283bd61 100644</span>
<span class="p_header">--- a/fs/cifs/connect.c</span>
<span class="p_header">+++ b/fs/cifs/connect.c</span>
<span class="p_chunk">@@ -1228,6 +1228,8 @@</span> <span class="p_context"> cifs_parse_mount_options(const char *mountdata, const char *devname,</span>
 	vol-&gt;ops = &amp;smb1_operations;
 	vol-&gt;vals = &amp;smb1_values;
 
<span class="p_add">+	vol-&gt;echo_interval = SMB_ECHO_INTERVAL_DEFAULT;</span>
<span class="p_add">+</span>
 	if (!mountdata)
 		goto cifs_parse_mount_err;
 
<span class="p_chunk">@@ -2049,7 +2051,7 @@</span> <span class="p_context"> static int match_server(struct TCP_Server_Info *server, struct smb_vol *vol)</span>
 	if (!match_security(server, vol))
 		return 0;
 
<span class="p_del">-	if (server-&gt;echo_interval != vol-&gt;echo_interval)</span>
<span class="p_add">+	if (server-&gt;echo_interval != vol-&gt;echo_interval * HZ)</span>
 		return 0;
 
 	return 1;
<span class="p_chunk">@@ -3483,6 +3485,44 @@</span> <span class="p_context"> cifs_get_volume_info(char *mount_data, const char *devname)</span>
 	return volume_info;
 }
 
<span class="p_add">+static int</span>
<span class="p_add">+cifs_are_all_path_components_accessible(struct TCP_Server_Info *server,</span>
<span class="p_add">+					unsigned int xid,</span>
<span class="p_add">+					struct cifs_tcon *tcon,</span>
<span class="p_add">+					struct cifs_sb_info *cifs_sb,</span>
<span class="p_add">+					char *full_path)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+	char *s;</span>
<span class="p_add">+	char sep, tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	sep = CIFS_DIR_SEP(cifs_sb);</span>
<span class="p_add">+	s = full_path;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = server-&gt;ops-&gt;is_path_accessible(xid, tcon, cifs_sb, &quot;&quot;);</span>
<span class="p_add">+	while (rc == 0) {</span>
<span class="p_add">+		/* skip separators */</span>
<span class="p_add">+		while (*s == sep)</span>
<span class="p_add">+			s++;</span>
<span class="p_add">+		if (!*s)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		/* next separator */</span>
<span class="p_add">+		while (*s &amp;&amp; *s != sep)</span>
<span class="p_add">+			s++;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * temporarily null-terminate the path at the end of</span>
<span class="p_add">+		 * the current component</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		tmp = *s;</span>
<span class="p_add">+		*s = 0;</span>
<span class="p_add">+		rc = server-&gt;ops-&gt;is_path_accessible(xid, tcon, cifs_sb,</span>
<span class="p_add">+						     full_path);</span>
<span class="p_add">+		*s = tmp;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int
 cifs_mount(struct cifs_sb_info *cifs_sb, struct smb_vol *volume_info)
 {
<span class="p_chunk">@@ -3620,6 +3660,16 @@</span> <span class="p_context"> remote_path_check:</span>
 			kfree(full_path);
 			goto mount_fail_check;
 		}
<span class="p_add">+</span>
<span class="p_add">+		rc = cifs_are_all_path_components_accessible(server,</span>
<span class="p_add">+							     xid, tcon, cifs_sb,</span>
<span class="p_add">+							     full_path);</span>
<span class="p_add">+		if (rc != 0) {</span>
<span class="p_add">+			cifs_dbg(VFS, &quot;cannot query dirs between root and final path, &quot;</span>
<span class="p_add">+				 &quot;enabling CIFS_MOUNT_USE_PREFIX_PATH\n&quot;);</span>
<span class="p_add">+			cifs_sb-&gt;mnt_cifs_flags |= CIFS_MOUNT_USE_PREFIX_PATH;</span>
<span class="p_add">+			rc = 0;</span>
<span class="p_add">+		}</span>
 		kfree(full_path);
 	}
 
<span class="p_chunk">@@ -3889,6 +3939,7 @@</span> <span class="p_context"> cifs_umount(struct cifs_sb_info *cifs_sb)</span>
 
 	bdi_destroy(&amp;cifs_sb-&gt;bdi);
 	kfree(cifs_sb-&gt;mountdata);
<span class="p_add">+	kfree(cifs_sb-&gt;prepath);</span>
 	call_rcu(&amp;cifs_sb-&gt;rcu, delayed_free);
 }
 
<span class="p_header">diff --git a/fs/cifs/dir.c b/fs/cifs/dir.c</span>
<span class="p_header">index fb0903fffc22..6f7333d552a3 100644</span>
<span class="p_header">--- a/fs/cifs/dir.c</span>
<span class="p_header">+++ b/fs/cifs/dir.c</span>
<span class="p_chunk">@@ -84,6 +84,7 @@</span> <span class="p_context"> build_path_from_dentry(struct dentry *direntry)</span>
 	struct dentry *temp;
 	int namelen;
 	int dfsplen;
<span class="p_add">+	int pplen = 0;</span>
 	char *full_path;
 	char dirsep;
 	struct cifs_sb_info *cifs_sb = CIFS_SB(direntry-&gt;d_sb);
<span class="p_chunk">@@ -95,8 +96,12 @@</span> <span class="p_context"> build_path_from_dentry(struct dentry *direntry)</span>
 		dfsplen = strnlen(tcon-&gt;treeName, MAX_TREE_SIZE + 1);
 	else
 		dfsplen = 0;
<span class="p_add">+</span>
<span class="p_add">+	if (cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_USE_PREFIX_PATH)</span>
<span class="p_add">+		pplen = cifs_sb-&gt;prepath ? strlen(cifs_sb-&gt;prepath) + 1 : 0;</span>
<span class="p_add">+</span>
 cifs_bp_rename_retry:
<span class="p_del">-	namelen = dfsplen;</span>
<span class="p_add">+	namelen = dfsplen + pplen;</span>
 	seq = read_seqbegin(&amp;rename_lock);
 	rcu_read_lock();
 	for (temp = direntry; !IS_ROOT(temp);) {
<span class="p_chunk">@@ -137,7 +142,7 @@</span> <span class="p_context"> cifs_bp_rename_retry:</span>
 		}
 	}
 	rcu_read_unlock();
<span class="p_del">-	if (namelen != dfsplen || read_seqretry(&amp;rename_lock, seq)) {</span>
<span class="p_add">+	if (namelen != dfsplen + pplen || read_seqretry(&amp;rename_lock, seq)) {</span>
 		cifs_dbg(FYI, &quot;did not end path lookup where expected. namelen=%ddfsplen=%d\n&quot;,
 			 namelen, dfsplen);
 		/* presumably this is only possible if racing with a rename
<span class="p_chunk">@@ -153,6 +158,17 @@</span> <span class="p_context"> cifs_bp_rename_retry:</span>
 	   those safely to &#39;/&#39; if any are found in the middle of the prepath */
 	/* BB test paths to Windows with &#39;/&#39; in the midst of prepath */
 
<span class="p_add">+	if (pplen) {</span>
<span class="p_add">+		int i;</span>
<span class="p_add">+</span>
<span class="p_add">+		cifs_dbg(FYI, &quot;using cifs_sb prepath &lt;%s&gt;\n&quot;, cifs_sb-&gt;prepath);</span>
<span class="p_add">+		memcpy(full_path+dfsplen+1, cifs_sb-&gt;prepath, pplen-1);</span>
<span class="p_add">+		full_path[dfsplen] = &#39;\\&#39;;</span>
<span class="p_add">+		for (i = 0; i &lt; pplen-1; i++)</span>
<span class="p_add">+			if (full_path[dfsplen+1+i] == &#39;/&#39;)</span>
<span class="p_add">+				full_path[dfsplen+1+i] = CIFS_DIR_SEP(cifs_sb);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (dfsplen) {
 		strncpy(full_path, tcon-&gt;treeName, dfsplen);
 		if (cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_POSIX_PATHS) {
<span class="p_chunk">@@ -229,6 +245,13 @@</span> <span class="p_context"> cifs_do_create(struct inode *inode, struct dentry *direntry, unsigned int xid,</span>
 				goto cifs_create_get_file_info;
 			}
 
<span class="p_add">+			if (S_ISDIR(newinode-&gt;i_mode)) {</span>
<span class="p_add">+				CIFSSMBClose(xid, tcon, fid-&gt;netfid);</span>
<span class="p_add">+				iput(newinode);</span>
<span class="p_add">+				rc = -EISDIR;</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			if (!S_ISREG(newinode-&gt;i_mode)) {
 				/*
 				 * The server may allow us to open things like
<span class="p_chunk">@@ -399,10 +422,14 @@</span> <span class="p_context"> cifs_create_set_dentry:</span>
 	if (rc != 0) {
 		cifs_dbg(FYI, &quot;Create worked, get_inode_info failed rc = %d\n&quot;,
 			 rc);
<span class="p_del">-		if (server-&gt;ops-&gt;close)</span>
<span class="p_del">-			server-&gt;ops-&gt;close(xid, tcon, fid);</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto out_err;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (S_ISDIR(newinode-&gt;i_mode)) {</span>
<span class="p_add">+		rc = -EISDIR;</span>
<span class="p_add">+		goto out_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	d_drop(direntry);
 	d_add(direntry, newinode);
 
<span class="p_chunk">@@ -410,6 +437,13 @@</span> <span class="p_context"> out:</span>
 	kfree(buf);
 	kfree(full_path);
 	return rc;
<span class="p_add">+</span>
<span class="p_add">+out_err:</span>
<span class="p_add">+	if (server-&gt;ops-&gt;close)</span>
<span class="p_add">+		server-&gt;ops-&gt;close(xid, tcon, fid);</span>
<span class="p_add">+	if (newinode)</span>
<span class="p_add">+		iput(newinode);</span>
<span class="p_add">+	goto out;</span>
 }
 
 int
<span class="p_header">diff --git a/fs/cifs/inode.c b/fs/cifs/inode.c</span>
<span class="p_header">index 514dadb0575d..b87efd0c92d6 100644</span>
<span class="p_header">--- a/fs/cifs/inode.c</span>
<span class="p_header">+++ b/fs/cifs/inode.c</span>
<span class="p_chunk">@@ -1002,10 +1002,26 @@</span> <span class="p_context"> struct inode *cifs_root_iget(struct super_block *sb)</span>
 	struct inode *inode = NULL;
 	long rc;
 	struct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);
<span class="p_add">+	char *path = NULL;</span>
<span class="p_add">+	int len;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_USE_PREFIX_PATH)</span>
<span class="p_add">+	    &amp;&amp; cifs_sb-&gt;prepath) {</span>
<span class="p_add">+		len = strlen(cifs_sb-&gt;prepath);</span>
<span class="p_add">+		path = kzalloc(len + 2 /* leading sep + null */, GFP_KERNEL);</span>
<span class="p_add">+		if (path == NULL)</span>
<span class="p_add">+			return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+		path[0] = &#39;/&#39;;</span>
<span class="p_add">+		memcpy(path+1, cifs_sb-&gt;prepath, len);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		path = kstrdup(&quot;&quot;, GFP_KERNEL);</span>
<span class="p_add">+		if (path == NULL)</span>
<span class="p_add">+			return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+	}</span>
 
 	xid = get_xid();
 	if (tcon-&gt;unix_ext) {
<span class="p_del">-		rc = cifs_get_inode_info_unix(&amp;inode, &quot;&quot;, sb, xid);</span>
<span class="p_add">+		rc = cifs_get_inode_info_unix(&amp;inode, path, sb, xid);</span>
 		/* some servers mistakenly claim POSIX support */
 		if (rc != -EOPNOTSUPP)
 			goto iget_no_retry;
<span class="p_chunk">@@ -1013,7 +1029,8 @@</span> <span class="p_context"> struct inode *cifs_root_iget(struct super_block *sb)</span>
 		tcon-&gt;unix_ext = false;
 	}
 
<span class="p_del">-	rc = cifs_get_inode_info(&amp;inode, &quot;&quot;, NULL, sb, xid, NULL);</span>
<span class="p_add">+	convert_delimiter(path, CIFS_DIR_SEP(cifs_sb));</span>
<span class="p_add">+	rc = cifs_get_inode_info(&amp;inode, path, NULL, sb, xid, NULL);</span>
 
 iget_no_retry:
 	if (!inode) {
<span class="p_chunk">@@ -1042,6 +1059,7 @@</span> <span class="p_context"> iget_no_retry:</span>
 	}
 
 out:
<span class="p_add">+	kfree(path);</span>
 	/* can not call macro free_xid here since in a void func
 	 * TODO: This is no longer true
 	 */
<span class="p_header">diff --git a/fs/cifs/smb2ops.c b/fs/cifs/smb2ops.c</span>
<span class="p_header">index 3525ed756173..505e6d6406fd 100644</span>
<span class="p_header">--- a/fs/cifs/smb2ops.c</span>
<span class="p_header">+++ b/fs/cifs/smb2ops.c</span>
<span class="p_chunk">@@ -1044,6 +1044,9 @@</span> <span class="p_context"> smb2_new_lease_key(struct cifs_fid *fid)</span>
 	get_random_bytes(fid-&gt;lease_key, SMB2_LEASE_KEY_SIZE);
 }
 
<span class="p_add">+#define SMB2_SYMLINK_STRUCT_SIZE \</span>
<span class="p_add">+	(sizeof(struct smb2_err_rsp) - 1 + sizeof(struct smb2_symlink_err_rsp))</span>
<span class="p_add">+</span>
 static int
 smb2_query_symlink(const unsigned int xid, struct cifs_tcon *tcon,
 		   const char *full_path, char **target_path,
<span class="p_chunk">@@ -1056,7 +1059,10 @@</span> <span class="p_context"> smb2_query_symlink(const unsigned int xid, struct cifs_tcon *tcon,</span>
 	struct cifs_fid fid;
 	struct smb2_err_rsp *err_buf = NULL;
 	struct smb2_symlink_err_rsp *symlink;
<span class="p_del">-	unsigned int sub_len, sub_offset;</span>
<span class="p_add">+	unsigned int sub_len;</span>
<span class="p_add">+	unsigned int sub_offset;</span>
<span class="p_add">+	unsigned int print_len;</span>
<span class="p_add">+	unsigned int print_offset;</span>
 
 	cifs_dbg(FYI, &quot;%s: path: %s\n&quot;, __func__, full_path);
 
<span class="p_chunk">@@ -1077,11 +1083,33 @@</span> <span class="p_context"> smb2_query_symlink(const unsigned int xid, struct cifs_tcon *tcon,</span>
 		kfree(utf16_path);
 		return -ENOENT;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (le32_to_cpu(err_buf-&gt;ByteCount) &lt; sizeof(struct smb2_symlink_err_rsp) ||</span>
<span class="p_add">+	    get_rfc1002_length(err_buf) + 4 &lt; SMB2_SYMLINK_STRUCT_SIZE) {</span>
<span class="p_add">+		kfree(utf16_path);</span>
<span class="p_add">+		return -ENOENT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* open must fail on symlink - reset rc */
 	rc = 0;
 	symlink = (struct smb2_symlink_err_rsp *)err_buf-&gt;ErrorData;
 	sub_len = le16_to_cpu(symlink-&gt;SubstituteNameLength);
 	sub_offset = le16_to_cpu(symlink-&gt;SubstituteNameOffset);
<span class="p_add">+	print_len = le16_to_cpu(symlink-&gt;PrintNameLength);</span>
<span class="p_add">+	print_offset = le16_to_cpu(symlink-&gt;PrintNameOffset);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (get_rfc1002_length(err_buf) + 4 &lt;</span>
<span class="p_add">+			SMB2_SYMLINK_STRUCT_SIZE + sub_offset + sub_len) {</span>
<span class="p_add">+		kfree(utf16_path);</span>
<span class="p_add">+		return -ENOENT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (get_rfc1002_length(err_buf) + 4 &lt;</span>
<span class="p_add">+			SMB2_SYMLINK_STRUCT_SIZE + print_offset + print_len) {</span>
<span class="p_add">+		kfree(utf16_path);</span>
<span class="p_add">+		return -ENOENT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	*target_path = cifs_strndup_from_utf16(
 				(char *)symlink-&gt;PathBuffer + sub_offset,
 				sub_len, true, cifs_sb-&gt;local_nls);
<span class="p_header">diff --git a/fs/jbd2/commit.c b/fs/jbd2/commit.c</span>
<span class="p_header">index 70078096117d..78313adb3c95 100644</span>
<span class="p_header">--- a/fs/jbd2/commit.c</span>
<span class="p_header">+++ b/fs/jbd2/commit.c</span>
<span class="p_chunk">@@ -124,7 +124,7 @@</span> <span class="p_context"> static int journal_submit_commit_record(journal_t *journal,</span>
 	struct commit_header *tmp;
 	struct buffer_head *bh;
 	int ret;
<span class="p_del">-	struct timespec now = current_kernel_time();</span>
<span class="p_add">+	struct timespec64 now = current_kernel_time64();</span>
 
 	*cbh = NULL;
 
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index ff416d0e24bc..7796beacdefb 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -427,6 +427,7 @@</span> <span class="p_context"> static int nfs4_do_handle_exception(struct nfs_server *server,</span>
 		case -NFS4ERR_DELAY:
 			nfs_inc_server_stats(server, NFSIOS_DELAY);
 		case -NFS4ERR_GRACE:
<span class="p_add">+		case -NFS4ERR_LAYOUTTRYLATER:</span>
 		case -NFS4ERR_RECALLCONFLICT:
 			exception-&gt;delay = 1;
 			return 0;
<span class="p_chunk">@@ -7869,11 +7870,13 @@</span> <span class="p_context"> nfs4_layoutget_handle_exception(struct rpc_task *task,</span>
 	struct inode *inode = lgp-&gt;args.inode;
 	struct nfs_server *server = NFS_SERVER(inode);
 	struct pnfs_layout_hdr *lo;
<span class="p_del">-	int status = task-&gt;tk_status;</span>
<span class="p_add">+	int nfs4err = task-&gt;tk_status;</span>
<span class="p_add">+	int err, status = 0;</span>
<span class="p_add">+	LIST_HEAD(head);</span>
 
 	dprintk(&quot;--&gt; %s tk_status =&gt; %d\n&quot;, __func__, -task-&gt;tk_status);
 
<span class="p_del">-	switch (status) {</span>
<span class="p_add">+	switch (nfs4err) {</span>
 	case 0:
 		goto out;
 
<span class="p_chunk">@@ -7905,45 +7908,43 @@</span> <span class="p_context"> nfs4_layoutget_handle_exception(struct rpc_task *task,</span>
 			status = -EOVERFLOW;
 			goto out;
 		}
<span class="p_del">-		/* Fallthrough */</span>
<span class="p_add">+		status = -EBUSY;</span>
<span class="p_add">+		break;</span>
 	case -NFS4ERR_RECALLCONFLICT:
<span class="p_del">-		nfs4_handle_exception(server, -NFS4ERR_RECALLCONFLICT,</span>
<span class="p_del">-					exception);</span>
 		status = -ERECALLCONFLICT;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		break;</span>
 	case -NFS4ERR_EXPIRED:
 	case -NFS4ERR_BAD_STATEID:
 		exception-&gt;timeout = 0;
 		spin_lock(&amp;inode-&gt;i_lock);
<span class="p_del">-		if (nfs4_stateid_match(&amp;lgp-&gt;args.stateid,</span>
<span class="p_add">+		lo = NFS_I(inode)-&gt;layout;</span>
<span class="p_add">+		/* If the open stateid was bad, then recover it. */</span>
<span class="p_add">+		if (!lo || test_bit(NFS_LAYOUT_INVALID_STID, &amp;lo-&gt;plh_flags) ||</span>
<span class="p_add">+		    nfs4_stateid_match_other(&amp;lgp-&gt;args.stateid,</span>
 					&amp;lgp-&gt;args.ctx-&gt;state-&gt;stateid)) {
 			spin_unlock(&amp;inode-&gt;i_lock);
<span class="p_del">-			/* If the open stateid was bad, then recover it. */</span>
 			exception-&gt;state = lgp-&gt;args.ctx-&gt;state;
 			break;
 		}
<span class="p_del">-		lo = NFS_I(inode)-&gt;layout;</span>
<span class="p_del">-		if (lo &amp;&amp; !test_bit(NFS_LAYOUT_INVALID_STID, &amp;lo-&gt;plh_flags) &amp;&amp;</span>
<span class="p_del">-		    nfs4_stateid_match_other(&amp;lgp-&gt;args.stateid, &amp;lo-&gt;plh_stateid)) {</span>
<span class="p_del">-			LIST_HEAD(head);</span>
<span class="p_del">-</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Mark the bad layout state as invalid, then retry</span>
<span class="p_del">-			 * with the current stateid.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			set_bit(NFS_LAYOUT_INVALID_STID, &amp;lo-&gt;plh_flags);</span>
<span class="p_del">-			pnfs_mark_matching_lsegs_invalid(lo, &amp;head, NULL, 0);</span>
<span class="p_del">-			spin_unlock(&amp;inode-&gt;i_lock);</span>
<span class="p_del">-			pnfs_free_lseg_list(&amp;head);</span>
<span class="p_del">-			status = -EAGAIN;</span>
<span class="p_del">-			goto out;</span>
<span class="p_del">-		} else</span>
<span class="p_del">-			spin_unlock(&amp;inode-&gt;i_lock);</span>
<span class="p_del">-	}</span>
 
<span class="p_del">-	status = nfs4_handle_exception(server, status, exception);</span>
<span class="p_del">-	if (exception-&gt;retry)</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Mark the bad layout state as invalid, then retry</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		set_bit(NFS_LAYOUT_INVALID_STID, &amp;lo-&gt;plh_flags);</span>
<span class="p_add">+		pnfs_mark_matching_lsegs_invalid(lo, &amp;head, NULL, 0);</span>
<span class="p_add">+		spin_unlock(&amp;inode-&gt;i_lock);</span>
<span class="p_add">+		pnfs_free_lseg_list(&amp;head);</span>
 		status = -EAGAIN;
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	err = nfs4_handle_exception(server, nfs4err, exception);</span>
<span class="p_add">+	if (!status) {</span>
<span class="p_add">+		if (exception-&gt;retry)</span>
<span class="p_add">+			status = -EAGAIN;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			status = err;</span>
<span class="p_add">+	}</span>
 out:
 	dprintk(&quot;&lt;-- %s\n&quot;, __func__);
 	return status;
<span class="p_header">diff --git a/fs/nfs/pnfs.c b/fs/nfs/pnfs.c</span>
<span class="p_header">index 0fbe734cc38c..7d992362ff04 100644</span>
<span class="p_header">--- a/fs/nfs/pnfs.c</span>
<span class="p_header">+++ b/fs/nfs/pnfs.c</span>
<span class="p_chunk">@@ -1505,7 +1505,7 @@</span> <span class="p_context"> pnfs_update_layout(struct inode *ino,</span>
 	struct pnfs_layout_segment *lseg = NULL;
 	nfs4_stateid stateid;
 	long timeout = 0;
<span class="p_del">-	unsigned long giveup = jiffies + rpc_get_timeout(server-&gt;client);</span>
<span class="p_add">+	unsigned long giveup = jiffies + (clp-&gt;cl_lease_time &lt;&lt; 1);</span>
 	bool first;
 
 	if (!pnfs_enabled_sb(NFS_SERVER(ino))) {
<span class="p_chunk">@@ -1645,33 +1645,44 @@</span> <span class="p_context"> lookup_again:</span>
 	lseg = send_layoutget(lo, ctx, &amp;stateid, &amp;arg, &amp;timeout, gfp_flags);
 	trace_pnfs_update_layout(ino, pos, count, iomode, lo, lseg,
 				 PNFS_UPDATE_LAYOUT_SEND_LAYOUTGET);
<span class="p_add">+	atomic_dec(&amp;lo-&gt;plh_outstanding);</span>
 	if (IS_ERR(lseg)) {
 		switch(PTR_ERR(lseg)) {
<span class="p_del">-		case -ERECALLCONFLICT:</span>
<span class="p_add">+		case -EBUSY:</span>
 			if (time_after(jiffies, giveup))
 				lseg = NULL;
<span class="p_del">-			/* Fallthrough */</span>
<span class="p_del">-		case -EAGAIN:</span>
<span class="p_del">-			pnfs_put_layout_hdr(lo);</span>
<span class="p_del">-			if (first)</span>
<span class="p_del">-				pnfs_clear_first_layoutget(lo);</span>
<span class="p_del">-			if (lseg) {</span>
<span class="p_del">-				trace_pnfs_update_layout(ino, pos, count,</span>
<span class="p_del">-					iomode, lo, lseg, PNFS_UPDATE_LAYOUT_RETRY);</span>
<span class="p_del">-				goto lookup_again;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case -ERECALLCONFLICT:</span>
<span class="p_add">+			/* Huh? We hold no layouts, how is there a recall? */</span>
<span class="p_add">+			if (first) {</span>
<span class="p_add">+				lseg = NULL;</span>
<span class="p_add">+				break;</span>
 			}
<span class="p_add">+			/* Destroy the existing layout and start over */</span>
<span class="p_add">+			if (time_after(jiffies, giveup))</span>
<span class="p_add">+				pnfs_destroy_layout(NFS_I(ino));</span>
 			/* Fallthrough */
<span class="p_add">+		case -EAGAIN:</span>
<span class="p_add">+			break;</span>
 		default:
 			if (!nfs_error_is_fatal(PTR_ERR(lseg))) {
 				pnfs_layout_clear_fail_bit(lo, pnfs_iomode_to_fail_bit(iomode));
 				lseg = NULL;
 			}
<span class="p_add">+			goto out_put_layout_hdr;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (lseg) {</span>
<span class="p_add">+			if (first)</span>
<span class="p_add">+				pnfs_clear_first_layoutget(lo);</span>
<span class="p_add">+			trace_pnfs_update_layout(ino, pos, count,</span>
<span class="p_add">+				iomode, lo, lseg, PNFS_UPDATE_LAYOUT_RETRY);</span>
<span class="p_add">+			pnfs_put_layout_hdr(lo);</span>
<span class="p_add">+			goto lookup_again;</span>
 		}
 	} else {
 		pnfs_layout_clear_fail_bit(lo, pnfs_iomode_to_fail_bit(iomode));
 	}
 
<span class="p_del">-	atomic_dec(&amp;lo-&gt;plh_outstanding);</span>
 out_put_layout_hdr:
 	if (first)
 		pnfs_clear_first_layoutget(lo);
<span class="p_header">diff --git a/fs/nfs/write.c b/fs/nfs/write.c</span>
<span class="p_header">index e1c74d3db64d..649fa5e26050 100644</span>
<span class="p_header">--- a/fs/nfs/write.c</span>
<span class="p_header">+++ b/fs/nfs/write.c</span>
<span class="p_chunk">@@ -1289,6 +1289,9 @@</span> <span class="p_context"> int nfs_updatepage(struct file *file, struct page *page,</span>
 	dprintk(&quot;NFS:       nfs_updatepage(%pD2 %d@%lld)\n&quot;,
 		file, count, (long long)(page_file_offset(page) + offset));
 
<span class="p_add">+	if (!count)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	if (nfs_can_extend_write(file, page, inode)) {
 		count = max(count + offset, nfs_page_length(page));
 		offset = 0;
<span class="p_chunk">@@ -1299,7 +1302,7 @@</span> <span class="p_context"> int nfs_updatepage(struct file *file, struct page *page,</span>
 		nfs_set_pageerror(page);
 	else
 		__set_page_dirty_nobuffers(page);
<span class="p_del">-</span>
<span class="p_add">+out:</span>
 	dprintk(&quot;NFS:       nfs_updatepage returns %d (isize %lld)\n&quot;,
 			status, (long long)i_size_read(inode));
 	return status;
<span class="p_header">diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c</span>
<span class="p_header">index 70d0b9b33031..806eda192d1c 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4state.c</span>
<span class="p_chunk">@@ -4906,6 +4906,32 @@</span> <span class="p_context"> nfsd4_test_stateid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,</span>
 	return nfs_ok;
 }
 
<span class="p_add">+static __be32</span>
<span class="p_add">+nfsd4_free_lock_stateid(stateid_t *stateid, struct nfs4_stid *s)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct nfs4_ol_stateid *stp = openlockstateid(s);</span>
<span class="p_add">+	__be32 ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;stp-&gt;st_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = check_stateid_generation(stateid, &amp;s-&gt;sc_stateid, 1);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = nfserr_locks_held;</span>
<span class="p_add">+	if (check_for_locks(stp-&gt;st_stid.sc_file,</span>
<span class="p_add">+			    lockowner(stp-&gt;st_stateowner)))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	release_lock_stateid(stp);</span>
<span class="p_add">+	ret = nfs_ok;</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	mutex_unlock(&amp;stp-&gt;st_mutex);</span>
<span class="p_add">+	nfs4_put_stid(s);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 __be32
 nfsd4_free_stateid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 		   struct nfsd4_free_stateid *free_stateid)
<span class="p_chunk">@@ -4913,7 +4939,6 @@</span> <span class="p_context"> nfsd4_free_stateid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,</span>
 	stateid_t *stateid = &amp;free_stateid-&gt;fr_stateid;
 	struct nfs4_stid *s;
 	struct nfs4_delegation *dp;
<span class="p_del">-	struct nfs4_ol_stateid *stp;</span>
 	struct nfs4_client *cl = cstate-&gt;session-&gt;se_client;
 	__be32 ret = nfserr_bad_stateid;
 
<span class="p_chunk">@@ -4932,18 +4957,9 @@</span> <span class="p_context"> nfsd4_free_stateid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,</span>
 		ret = nfserr_locks_held;
 		break;
 	case NFS4_LOCK_STID:
<span class="p_del">-		ret = check_stateid_generation(stateid, &amp;s-&gt;sc_stateid, 1);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		stp = openlockstateid(s);</span>
<span class="p_del">-		ret = nfserr_locks_held;</span>
<span class="p_del">-		if (check_for_locks(stp-&gt;st_stid.sc_file,</span>
<span class="p_del">-				    lockowner(stp-&gt;st_stateowner)))</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		WARN_ON(!unhash_lock_stateid(stp));</span>
<span class="p_add">+		atomic_inc(&amp;s-&gt;sc_count);</span>
 		spin_unlock(&amp;cl-&gt;cl_lock);
<span class="p_del">-		nfs4_put_stid(s);</span>
<span class="p_del">-		ret = nfs_ok;</span>
<span class="p_add">+		ret = nfsd4_free_lock_stateid(stateid, s);</span>
 		goto out;
 	case NFS4_REVOKED_DELEG_STID:
 		dp = delegstateid(s);
<span class="p_chunk">@@ -5510,7 +5526,7 @@</span> <span class="p_context"> static __be32</span>
 lookup_or_create_lock_state(struct nfsd4_compound_state *cstate,
 			    struct nfs4_ol_stateid *ost,
 			    struct nfsd4_lock *lock,
<span class="p_del">-			    struct nfs4_ol_stateid **lst, bool *new)</span>
<span class="p_add">+			    struct nfs4_ol_stateid **plst, bool *new)</span>
 {
 	__be32 status;
 	struct nfs4_file *fi = ost-&gt;st_stid.sc_file;
<span class="p_chunk">@@ -5518,7 +5534,9 @@</span> <span class="p_context"> lookup_or_create_lock_state(struct nfsd4_compound_state *cstate,</span>
 	struct nfs4_client *cl = oo-&gt;oo_owner.so_client;
 	struct inode *inode = d_inode(cstate-&gt;current_fh.fh_dentry);
 	struct nfs4_lockowner *lo;
<span class="p_add">+	struct nfs4_ol_stateid *lst;</span>
 	unsigned int strhashval;
<span class="p_add">+	bool hashed;</span>
 
 	lo = find_lockowner_str(cl, &amp;lock-&gt;lk_new_owner);
 	if (!lo) {
<span class="p_chunk">@@ -5534,12 +5552,27 @@</span> <span class="p_context"> lookup_or_create_lock_state(struct nfsd4_compound_state *cstate,</span>
 			goto out;
 	}
 
<span class="p_del">-	*lst = find_or_create_lock_stateid(lo, fi, inode, ost, new);</span>
<span class="p_del">-	if (*lst == NULL) {</span>
<span class="p_add">+retry:</span>
<span class="p_add">+	lst = find_or_create_lock_stateid(lo, fi, inode, ost, new);</span>
<span class="p_add">+	if (lst == NULL) {</span>
 		status = nfserr_jukebox;
 		goto out;
 	}
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;lst-&gt;st_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* See if it&#39;s still hashed to avoid race with FREE_STATEID */</span>
<span class="p_add">+	spin_lock(&amp;cl-&gt;cl_lock);</span>
<span class="p_add">+	hashed = !list_empty(&amp;lst-&gt;st_perfile);</span>
<span class="p_add">+	spin_unlock(&amp;cl-&gt;cl_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!hashed) {</span>
<span class="p_add">+		mutex_unlock(&amp;lst-&gt;st_mutex);</span>
<span class="p_add">+		nfs4_put_stid(&amp;lst-&gt;st_stid);</span>
<span class="p_add">+		goto retry;</span>
<span class="p_add">+	}</span>
 	status = nfs_ok;
<span class="p_add">+	*plst = lst;</span>
 out:
 	nfs4_put_stateowner(&amp;lo-&gt;lo_owner);
 	return status;
<span class="p_chunk">@@ -5606,8 +5639,6 @@</span> <span class="p_context"> nfsd4_lock(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,</span>
 			goto out;
 		status = lookup_or_create_lock_state(cstate, open_stp, lock,
 							&amp;lock_stp, &amp;new);
<span class="p_del">-		if (status == nfs_ok)</span>
<span class="p_del">-			mutex_lock(&amp;lock_stp-&gt;st_mutex);</span>
 	} else {
 		status = nfs4_preprocess_seqid_op(cstate,
 				       lock-&gt;lk_old_lock_seqid,
<span class="p_header">diff --git a/fs/overlayfs/super.c b/fs/overlayfs/super.c</span>
<span class="p_header">index 9a7693d5f8ff..6db75cbb668f 100644</span>
<span class="p_header">--- a/fs/overlayfs/super.c</span>
<span class="p_header">+++ b/fs/overlayfs/super.c</span>
<span class="p_chunk">@@ -404,7 +404,8 @@</span> <span class="p_context"> static struct ovl_entry *ovl_alloc_entry(unsigned int numlower)</span>
 static bool ovl_dentry_remote(struct dentry *dentry)
 {
 	return dentry-&gt;d_flags &amp;
<span class="p_del">-		(DCACHE_OP_REVALIDATE | DCACHE_OP_WEAK_REVALIDATE);</span>
<span class="p_add">+		(DCACHE_OP_REVALIDATE | DCACHE_OP_WEAK_REVALIDATE |</span>
<span class="p_add">+		 DCACHE_OP_REAL);</span>
 }
 
 static bool ovl_dentry_weird(struct dentry *dentry)
<span class="p_header">diff --git a/fs/xfs/xfs_aops.c b/fs/xfs/xfs_aops.c</span>
<span class="p_header">index 4c463b99fe57..a36a5a418f7d 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_aops.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_aops.c</span>
<span class="p_chunk">@@ -87,6 +87,12 @@</span> <span class="p_context"> xfs_find_bdev_for_inode(</span>
  * We&#39;re now finished for good with this page.  Update the page state via the
  * associated buffer_heads, paying attention to the start and end offsets that
  * we need to process on the page.
<span class="p_add">+ *</span>
<span class="p_add">+ * Landmine Warning: bh-&gt;b_end_io() will call end_page_writeback() on the last</span>
<span class="p_add">+ * buffer in the IO. Once it does this, it is unsafe to access the bufferhead or</span>
<span class="p_add">+ * the page at all, as we may be racing with memory reclaim and it can free both</span>
<span class="p_add">+ * the bufferhead chain and the page as it will see the page as clean and</span>
<span class="p_add">+ * unused.</span>
  */
 static void
 xfs_finish_page_writeback(
<span class="p_chunk">@@ -95,8 +101,9 @@</span> <span class="p_context"> xfs_finish_page_writeback(</span>
 	int			error)
 {
 	unsigned int		end = bvec-&gt;bv_offset + bvec-&gt;bv_len - 1;
<span class="p_del">-	struct buffer_head	*head, *bh;</span>
<span class="p_add">+	struct buffer_head	*head, *bh, *next;</span>
 	unsigned int		off = 0;
<span class="p_add">+	unsigned int		bsize;</span>
 
 	ASSERT(bvec-&gt;bv_offset &lt; PAGE_SIZE);
 	ASSERT((bvec-&gt;bv_offset &amp; ((1 &lt;&lt; inode-&gt;i_blkbits) - 1)) == 0);
<span class="p_chunk">@@ -105,15 +112,17 @@</span> <span class="p_context"> xfs_finish_page_writeback(</span>
 
 	bh = head = page_buffers(bvec-&gt;bv_page);
 
<span class="p_add">+	bsize = bh-&gt;b_size;</span>
 	do {
<span class="p_add">+		next = bh-&gt;b_this_page;</span>
 		if (off &lt; bvec-&gt;bv_offset)
 			goto next_bh;
 		if (off &gt; end)
 			break;
 		bh-&gt;b_end_io(bh, !error);
 next_bh:
<span class="p_del">-		off += bh-&gt;b_size;</span>
<span class="p_del">-	} while ((bh = bh-&gt;b_this_page) != head);</span>
<span class="p_add">+		off += bsize;</span>
<span class="p_add">+	} while ((bh = next) != head);</span>
 }
 
 /*
<span class="p_header">diff --git a/include/linux/backing-dev-defs.h b/include/linux/backing-dev-defs.h</span>
<span class="p_header">index 3f103076d0bf..c357f27d5483 100644</span>
<span class="p_header">--- a/include/linux/backing-dev-defs.h</span>
<span class="p_header">+++ b/include/linux/backing-dev-defs.h</span>
<span class="p_chunk">@@ -163,6 +163,7 @@</span> <span class="p_context"> struct backing_dev_info {</span>
 	wait_queue_head_t wb_waitq;
 
 	struct device *dev;
<span class="p_add">+	struct device *owner;</span>
 
 	struct timer_list laptop_mode_wb_timer;
 
<span class="p_header">diff --git a/include/linux/backing-dev.h b/include/linux/backing-dev.h</span>
<span class="p_header">index c82794f20110..89d3de3e096b 100644</span>
<span class="p_header">--- a/include/linux/backing-dev.h</span>
<span class="p_header">+++ b/include/linux/backing-dev.h</span>
<span class="p_chunk">@@ -24,6 +24,7 @@</span> <span class="p_context"> __printf(3, 4)</span>
 int bdi_register(struct backing_dev_info *bdi, struct device *parent,
 		const char *fmt, ...);
 int bdi_register_dev(struct backing_dev_info *bdi, dev_t dev);
<span class="p_add">+int bdi_register_owner(struct backing_dev_info *bdi, struct device *owner);</span>
 void bdi_unregister(struct backing_dev_info *bdi);
 
 int __must_check bdi_setup_and_register(struct backing_dev_info *, char *);
<span class="p_header">diff --git a/include/linux/bio.h b/include/linux/bio.h</span>
<span class="p_header">index 9faebf7f9a33..75fadd28eec8 100644</span>
<span class="p_header">--- a/include/linux/bio.h</span>
<span class="p_header">+++ b/include/linux/bio.h</span>
<span class="p_chunk">@@ -527,11 +527,14 @@</span> <span class="p_context"> extern unsigned int bvec_nr_vecs(unsigned short idx);</span>
 int bio_associate_blkcg(struct bio *bio, struct cgroup_subsys_state *blkcg_css);
 int bio_associate_current(struct bio *bio);
 void bio_disassociate_task(struct bio *bio);
<span class="p_add">+void bio_clone_blkcg_association(struct bio *dst, struct bio *src);</span>
 #else	/* CONFIG_BLK_CGROUP */
 static inline int bio_associate_blkcg(struct bio *bio,
 			struct cgroup_subsys_state *blkcg_css) { return 0; }
 static inline int bio_associate_current(struct bio *bio) { return -ENOENT; }
 static inline void bio_disassociate_task(struct bio *bio) { }
<span class="p_add">+static inline void bio_clone_blkcg_association(struct bio *dst,</span>
<span class="p_add">+			struct bio *src) { }</span>
 #endif	/* CONFIG_BLK_CGROUP */
 
 #ifdef CONFIG_HIGHMEM
<span class="p_header">diff --git a/include/linux/mlx5/qp.h b/include/linux/mlx5/qp.h</span>
<span class="p_header">index ab310819ac36..7879bf411891 100644</span>
<span class="p_header">--- a/include/linux/mlx5/qp.h</span>
<span class="p_header">+++ b/include/linux/mlx5/qp.h</span>
<span class="p_chunk">@@ -556,9 +556,9 @@</span> <span class="p_context"> struct mlx5_destroy_qp_mbox_out {</span>
 struct mlx5_modify_qp_mbox_in {
 	struct mlx5_inbox_hdr	hdr;
 	__be32			qpn;
<span class="p_del">-	u8			rsvd1[4];</span>
<span class="p_del">-	__be32			optparam;</span>
 	u8			rsvd0[4];
<span class="p_add">+	__be32			optparam;</span>
<span class="p_add">+	u8			rsvd1[4];</span>
 	struct mlx5_qp_context	ctx;
 	u8			rsvd2[16];
 };
<span class="p_header">diff --git a/include/rdma/ib_verbs.h b/include/rdma/ib_verbs.h</span>
<span class="p_header">index 7e440d41487a..e694f02d42e3 100644</span>
<span class="p_header">--- a/include/rdma/ib_verbs.h</span>
<span class="p_header">+++ b/include/rdma/ib_verbs.h</span>
<span class="p_chunk">@@ -1428,6 +1428,10 @@</span> <span class="p_context"> struct ib_srq {</span>
 	} ext;
 };
 
<span class="p_add">+/*</span>
<span class="p_add">+ * @max_write_sge: Maximum SGE elements per RDMA WRITE request.</span>
<span class="p_add">+ * @max_read_sge:  Maximum SGE elements per RDMA READ request.</span>
<span class="p_add">+ */</span>
 struct ib_qp {
 	struct ib_device       *device;
 	struct ib_pd	       *pd;
<span class="p_chunk">@@ -1449,6 +1453,8 @@</span> <span class="p_context"> struct ib_qp {</span>
 	void                  (*event_handler)(struct ib_event *, void *);
 	void		       *qp_context;
 	u32			qp_num;
<span class="p_add">+	u32			max_write_sge;</span>
<span class="p_add">+	u32			max_read_sge;</span>
 	enum ib_qp_type		qp_type;
 };
 
<span class="p_header">diff --git a/include/target/target_core_backend.h b/include/target/target_core_backend.h</span>
<span class="p_header">index d8ab5101fad5..f6f3bc52c1ac 100644</span>
<span class="p_header">--- a/include/target/target_core_backend.h</span>
<span class="p_header">+++ b/include/target/target_core_backend.h</span>
<span class="p_chunk">@@ -95,6 +95,6 @@</span> <span class="p_context"> sense_reason_t passthrough_parse_cdb(struct se_cmd *cmd,</span>
 bool target_sense_desc_format(struct se_device *dev);
 sector_t target_to_linux_sector(struct se_device *dev, sector_t lb);
 bool target_configure_unmap_from_queue(struct se_dev_attrib *attrib,
<span class="p_del">-				       struct request_queue *q, int block_size);</span>
<span class="p_add">+				       struct request_queue *q);</span>
 
 #endif /* TARGET_CORE_BACKEND_H */
<span class="p_header">diff --git a/include/target/target_core_base.h b/include/target/target_core_base.h</span>
<span class="p_header">index b316b44d03f3..fb8e3b6febdf 100644</span>
<span class="p_header">--- a/include/target/target_core_base.h</span>
<span class="p_header">+++ b/include/target/target_core_base.h</span>
<span class="p_chunk">@@ -142,6 +142,7 @@</span> <span class="p_context"> enum se_cmd_flags_table {</span>
 	SCF_PASSTHROUGH_PROT_SG_TO_MEM_NOALLOC = 0x00200000,
 	SCF_ACK_KREF			= 0x00400000,
 	SCF_USE_CPUID			= 0x00800000,
<span class="p_add">+	SCF_TASK_ATTR_SET		= 0x01000000,</span>
 };
 
 /*
<span class="p_header">diff --git a/include/target/target_core_fabric.h b/include/target/target_core_fabric.h</span>
<span class="p_header">index de44462a7680..5cd6faa6e0d1 100644</span>
<span class="p_header">--- a/include/target/target_core_fabric.h</span>
<span class="p_header">+++ b/include/target/target_core_fabric.h</span>
<span class="p_chunk">@@ -163,7 +163,6 @@</span> <span class="p_context"> int	core_tmr_alloc_req(struct se_cmd *, void *, u8, gfp_t);</span>
 void	core_tmr_release_req(struct se_tmr_req *);
 int	transport_generic_handle_tmr(struct se_cmd *);
 void	transport_generic_request_failure(struct se_cmd *, sense_reason_t);
<span class="p_del">-void	__target_execute_cmd(struct se_cmd *);</span>
 int	transport_lookup_tmr_lun(struct se_cmd *, u64);
 void	core_allocate_nexus_loss_ua(struct se_node_acl *acl);
 
<span class="p_header">diff --git a/include/trace/events/sunrpc.h b/include/trace/events/sunrpc.h</span>
<span class="p_header">index 003dca933803..5664ca07c9c7 100644</span>
<span class="p_header">--- a/include/trace/events/sunrpc.h</span>
<span class="p_header">+++ b/include/trace/events/sunrpc.h</span>
<span class="p_chunk">@@ -529,20 +529,27 @@</span> <span class="p_context"> TRACE_EVENT(svc_xprt_do_enqueue,</span>
 
 	TP_STRUCT__entry(
 		__field(struct svc_xprt *, xprt)
<span class="p_del">-		__field_struct(struct sockaddr_storage, ss)</span>
 		__field(int, pid)
 		__field(unsigned long, flags)
<span class="p_add">+		__dynamic_array(unsigned char, addr, xprt != NULL ?</span>
<span class="p_add">+			xprt-&gt;xpt_remotelen : 0)</span>
 	),
 
 	TP_fast_assign(
 		__entry-&gt;xprt = xprt;
<span class="p_del">-		xprt ? memcpy(&amp;__entry-&gt;ss, &amp;xprt-&gt;xpt_remote, sizeof(__entry-&gt;ss)) : memset(&amp;__entry-&gt;ss, 0, sizeof(__entry-&gt;ss));</span>
 		__entry-&gt;pid = rqst? rqst-&gt;rq_task-&gt;pid : 0;
<span class="p_del">-		__entry-&gt;flags = xprt ? xprt-&gt;xpt_flags : 0;</span>
<span class="p_add">+		if (xprt) {</span>
<span class="p_add">+			memcpy(__get_dynamic_array(addr),</span>
<span class="p_add">+				&amp;xprt-&gt;xpt_remote,</span>
<span class="p_add">+				xprt-&gt;xpt_remotelen);</span>
<span class="p_add">+			__entry-&gt;flags = xprt-&gt;xpt_flags;</span>
<span class="p_add">+		} else</span>
<span class="p_add">+			__entry-&gt;flags = 0;</span>
 	),
 
 	TP_printk(&quot;xprt=0x%p addr=%pIScp pid=%d flags=%s&quot;, __entry-&gt;xprt,
<span class="p_del">-		(struct sockaddr *)&amp;__entry-&gt;ss,</span>
<span class="p_add">+		__get_dynamic_array_len(addr) != 0 ?</span>
<span class="p_add">+			(struct sockaddr *)__get_dynamic_array(addr) : NULL,</span>
 		__entry-&gt;pid, show_svc_xprt_flags(__entry-&gt;flags))
 );
 
<span class="p_chunk">@@ -553,18 +560,25 @@</span> <span class="p_context"> TRACE_EVENT(svc_xprt_dequeue,</span>
 
 	TP_STRUCT__entry(
 		__field(struct svc_xprt *, xprt)
<span class="p_del">-		__field_struct(struct sockaddr_storage, ss)</span>
 		__field(unsigned long, flags)
<span class="p_add">+		__dynamic_array(unsigned char, addr, xprt != NULL ?</span>
<span class="p_add">+			xprt-&gt;xpt_remotelen : 0)</span>
 	),
 
 	TP_fast_assign(
<span class="p_del">-		__entry-&gt;xprt = xprt,</span>
<span class="p_del">-		xprt ? memcpy(&amp;__entry-&gt;ss, &amp;xprt-&gt;xpt_remote, sizeof(__entry-&gt;ss)) : memset(&amp;__entry-&gt;ss, 0, sizeof(__entry-&gt;ss));</span>
<span class="p_del">-		__entry-&gt;flags = xprt ? xprt-&gt;xpt_flags : 0;</span>
<span class="p_add">+		__entry-&gt;xprt = xprt;</span>
<span class="p_add">+		if (xprt) {</span>
<span class="p_add">+			memcpy(__get_dynamic_array(addr),</span>
<span class="p_add">+					&amp;xprt-&gt;xpt_remote,</span>
<span class="p_add">+					xprt-&gt;xpt_remotelen);</span>
<span class="p_add">+			__entry-&gt;flags = xprt-&gt;xpt_flags;</span>
<span class="p_add">+		} else</span>
<span class="p_add">+			__entry-&gt;flags = 0;</span>
 	),
 
 	TP_printk(&quot;xprt=0x%p addr=%pIScp flags=%s&quot;, __entry-&gt;xprt,
<span class="p_del">-		(struct sockaddr *)&amp;__entry-&gt;ss,</span>
<span class="p_add">+		__get_dynamic_array_len(addr) != 0 ?</span>
<span class="p_add">+			(struct sockaddr *)__get_dynamic_array(addr) : NULL,</span>
 		show_svc_xprt_flags(__entry-&gt;flags))
 );
 
<span class="p_chunk">@@ -592,19 +606,26 @@</span> <span class="p_context"> TRACE_EVENT(svc_handle_xprt,</span>
 	TP_STRUCT__entry(
 		__field(struct svc_xprt *, xprt)
 		__field(int, len)
<span class="p_del">-		__field_struct(struct sockaddr_storage, ss)</span>
 		__field(unsigned long, flags)
<span class="p_add">+		__dynamic_array(unsigned char, addr, xprt != NULL ?</span>
<span class="p_add">+			xprt-&gt;xpt_remotelen : 0)</span>
 	),
 
 	TP_fast_assign(
 		__entry-&gt;xprt = xprt;
<span class="p_del">-		xprt ? memcpy(&amp;__entry-&gt;ss, &amp;xprt-&gt;xpt_remote, sizeof(__entry-&gt;ss)) : memset(&amp;__entry-&gt;ss, 0, sizeof(__entry-&gt;ss));</span>
 		__entry-&gt;len = len;
<span class="p_del">-		__entry-&gt;flags = xprt ? xprt-&gt;xpt_flags : 0;</span>
<span class="p_add">+		if (xprt) {</span>
<span class="p_add">+			memcpy(__get_dynamic_array(addr),</span>
<span class="p_add">+					&amp;xprt-&gt;xpt_remote,</span>
<span class="p_add">+					xprt-&gt;xpt_remotelen);</span>
<span class="p_add">+			__entry-&gt;flags = xprt-&gt;xpt_flags;</span>
<span class="p_add">+		} else</span>
<span class="p_add">+			__entry-&gt;flags = 0;</span>
 	),
 
 	TP_printk(&quot;xprt=0x%p addr=%pIScp len=%d flags=%s&quot;, __entry-&gt;xprt,
<span class="p_del">-		(struct sockaddr *)&amp;__entry-&gt;ss,</span>
<span class="p_add">+		__get_dynamic_array_len(addr) != 0 ?</span>
<span class="p_add">+			(struct sockaddr *)__get_dynamic_array(addr) : NULL,</span>
 		__entry-&gt;len, show_svc_xprt_flags(__entry-&gt;flags))
 );
 #endif /* _TRACE_SUNRPC_H */
<span class="p_header">diff --git a/kernel/auditsc.c b/kernel/auditsc.c</span>
<span class="p_header">index 2672d105cffc..b3341284f1c6 100644</span>
<span class="p_header">--- a/kernel/auditsc.c</span>
<span class="p_header">+++ b/kernel/auditsc.c</span>
<span class="p_chunk">@@ -72,6 +72,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/compat.h&gt;
 #include &lt;linux/ctype.h&gt;
 #include &lt;linux/string.h&gt;
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 #include &lt;uapi/linux/limits.h&gt;
 
 #include &quot;audit.h&quot;
<span class="p_chunk">@@ -81,7 +82,8 @@</span> <span class="p_context"></span>
 #define AUDITSC_SUCCESS 1
 #define AUDITSC_FAILURE 2
 
<span class="p_del">-/* no execve audit message should be longer than this (userspace limits) */</span>
<span class="p_add">+/* no execve audit message should be longer than this (userspace limits),</span>
<span class="p_add">+ * see the note near the top of audit_log_execve_info() about this value */</span>
 #define MAX_EXECVE_AUDIT_LEN 7500
 
 /* max length to print of cmdline/proctitle value during audit */
<span class="p_chunk">@@ -987,184 +989,178 @@</span> <span class="p_context"> static int audit_log_pid_context(struct audit_context *context, pid_t pid,</span>
 	return rc;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * to_send and len_sent accounting are very loose estimates.  We aren&#39;t</span>
<span class="p_del">- * really worried about a hard cap to MAX_EXECVE_AUDIT_LEN so much as being</span>
<span class="p_del">- * within about 500 bytes (next page boundary)</span>
<span class="p_del">- *</span>
<span class="p_del">- * why snprintf?  an int is up to 12 digits long.  if we just assumed when</span>
<span class="p_del">- * logging that a[%d]= was going to be 16 characters long we would be wasting</span>
<span class="p_del">- * space in every audit message.  In one 7500 byte message we can log up to</span>
<span class="p_del">- * about 1000 min size arguments.  That comes down to about 50% waste of space</span>
<span class="p_del">- * if we didn&#39;t do the snprintf to find out how long arg_num_len was.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int audit_log_single_execve_arg(struct audit_context *context,</span>
<span class="p_del">-					struct audit_buffer **ab,</span>
<span class="p_del">-					int arg_num,</span>
<span class="p_del">-					size_t *len_sent,</span>
<span class="p_del">-					const char __user *p,</span>
<span class="p_del">-					char *buf)</span>
<span class="p_add">+static void audit_log_execve_info(struct audit_context *context,</span>
<span class="p_add">+				  struct audit_buffer **ab)</span>
 {
<span class="p_del">-	char arg_num_len_buf[12];</span>
<span class="p_del">-	const char __user *tmp_p = p;</span>
<span class="p_del">-	/* how many digits are in arg_num? 5 is the length of &#39; a=&quot;&quot;&#39; */</span>
<span class="p_del">-	size_t arg_num_len = snprintf(arg_num_len_buf, 12, &quot;%d&quot;, arg_num) + 5;</span>
<span class="p_del">-	size_t len, len_left, to_send;</span>
<span class="p_del">-	size_t max_execve_audit_len = MAX_EXECVE_AUDIT_LEN;</span>
<span class="p_del">-	unsigned int i, has_cntl = 0, too_long = 0;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* strnlen_user includes the null we don&#39;t want to send */</span>
<span class="p_del">-	len_left = len = strnlen_user(p, MAX_ARG_STRLEN) - 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We just created this mm, if we can&#39;t find the strings</span>
<span class="p_del">-	 * we just copied into it something is _very_ wrong. Similar</span>
<span class="p_del">-	 * for strings that are too long, we should not have created</span>
<span class="p_del">-	 * any.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (WARN_ON_ONCE(len &lt; 0 || len &gt; MAX_ARG_STRLEN - 1)) {</span>
<span class="p_del">-		send_sig(SIGKILL, current, 0);</span>
<span class="p_del">-		return -1;</span>
<span class="p_add">+	long len_max;</span>
<span class="p_add">+	long len_rem;</span>
<span class="p_add">+	long len_full;</span>
<span class="p_add">+	long len_buf;</span>
<span class="p_add">+	long len_abuf;</span>
<span class="p_add">+	long len_tmp;</span>
<span class="p_add">+	bool require_data;</span>
<span class="p_add">+	bool encode;</span>
<span class="p_add">+	unsigned int iter;</span>
<span class="p_add">+	unsigned int arg;</span>
<span class="p_add">+	char *buf_head;</span>
<span class="p_add">+	char *buf;</span>
<span class="p_add">+	const char __user *p = (const char __user *)current-&gt;mm-&gt;arg_start;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* NOTE: this buffer needs to be large enough to hold all the non-arg</span>
<span class="p_add">+	 *       data we put in the audit record for this argument (see the</span>
<span class="p_add">+	 *       code below) ... at this point in time 96 is plenty */</span>
<span class="p_add">+	char abuf[96];</span>
<span class="p_add">+</span>
<span class="p_add">+	/* NOTE: we set MAX_EXECVE_AUDIT_LEN to a rather arbitrary limit, the</span>
<span class="p_add">+	 *       current value of 7500 is not as important as the fact that it</span>
<span class="p_add">+	 *       is less than 8k, a setting of 7500 gives us plenty of wiggle</span>
<span class="p_add">+	 *       room if we go over a little bit in the logging below */</span>
<span class="p_add">+	WARN_ON_ONCE(MAX_EXECVE_AUDIT_LEN &gt; 7500);</span>
<span class="p_add">+	len_max = MAX_EXECVE_AUDIT_LEN;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* scratch buffer to hold the userspace args */</span>
<span class="p_add">+	buf_head = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);</span>
<span class="p_add">+	if (!buf_head) {</span>
<span class="p_add">+		audit_panic(&quot;out of memory for argv string&quot;);</span>
<span class="p_add">+		return;</span>
 	}
<span class="p_add">+	buf = buf_head;</span>
 
<span class="p_del">-	/* walk the whole argument looking for non-ascii chars */</span>
<span class="p_add">+	audit_log_format(*ab, &quot;argc=%d&quot;, context-&gt;execve.argc);</span>
<span class="p_add">+</span>
<span class="p_add">+	len_rem = len_max;</span>
<span class="p_add">+	len_buf = 0;</span>
<span class="p_add">+	len_full = 0;</span>
<span class="p_add">+	require_data = true;</span>
<span class="p_add">+	encode = false;</span>
<span class="p_add">+	iter = 0;</span>
<span class="p_add">+	arg = 0;</span>
 	do {
<span class="p_del">-		if (len_left &gt; MAX_EXECVE_AUDIT_LEN)</span>
<span class="p_del">-			to_send = MAX_EXECVE_AUDIT_LEN;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			to_send = len_left;</span>
<span class="p_del">-		ret = copy_from_user(buf, tmp_p, to_send);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * There is no reason for this copy to be short. We just</span>
<span class="p_del">-		 * copied them here, and the mm hasn&#39;t been exposed to user-</span>
<span class="p_del">-		 * space yet.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (ret) {</span>
<span class="p_del">-			WARN_ON(1);</span>
<span class="p_del">-			send_sig(SIGKILL, current, 0);</span>
<span class="p_del">-			return -1;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		buf[to_send] = &#39;\0&#39;;</span>
<span class="p_del">-		has_cntl = audit_string_contains_control(buf, to_send);</span>
<span class="p_del">-		if (has_cntl) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * hex messages get logged as 2 bytes, so we can only</span>
<span class="p_del">-			 * send half as much in each message</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			max_execve_audit_len = MAX_EXECVE_AUDIT_LEN / 2;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		len_left -= to_send;</span>
<span class="p_del">-		tmp_p += to_send;</span>
<span class="p_del">-	} while (len_left &gt; 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	len_left = len;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (len &gt; max_execve_audit_len)</span>
<span class="p_del">-		too_long = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* rewalk the argument actually logging the message */</span>
<span class="p_del">-	for (i = 0; len_left &gt; 0; i++) {</span>
<span class="p_del">-		int room_left;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (len_left &gt; max_execve_audit_len)</span>
<span class="p_del">-			to_send = max_execve_audit_len;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			to_send = len_left;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* do we have space left to send this argument in this ab? */</span>
<span class="p_del">-		room_left = MAX_EXECVE_AUDIT_LEN - arg_num_len - *len_sent;</span>
<span class="p_del">-		if (has_cntl)</span>
<span class="p_del">-			room_left -= (to_send * 2);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			room_left -= to_send;</span>
<span class="p_del">-		if (room_left &lt; 0) {</span>
<span class="p_del">-			*len_sent = 0;</span>
<span class="p_del">-			audit_log_end(*ab);</span>
<span class="p_del">-			*ab = audit_log_start(context, GFP_KERNEL, AUDIT_EXECVE);</span>
<span class="p_del">-			if (!*ab)</span>
<span class="p_del">-				return 0;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		/* NOTE: we don&#39;t ever want to trust this value for anything</span>
<span class="p_add">+		 *       serious, but the audit record format insists we</span>
<span class="p_add">+		 *       provide an argument length for really long arguments,</span>
<span class="p_add">+		 *       e.g. &gt; MAX_EXECVE_AUDIT_LEN, so we have no choice but</span>
<span class="p_add">+		 *       to use strncpy_from_user() to obtain this value for</span>
<span class="p_add">+		 *       recording in the log, although we don&#39;t use it</span>
<span class="p_add">+		 *       anywhere here to avoid a double-fetch problem */</span>
<span class="p_add">+		if (len_full == 0)</span>
<span class="p_add">+			len_full = strnlen_user(p, MAX_ARG_STRLEN) - 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* read more data from userspace */</span>
<span class="p_add">+		if (require_data) {</span>
<span class="p_add">+			/* can we make more room in the buffer? */</span>
<span class="p_add">+			if (buf != buf_head) {</span>
<span class="p_add">+				memmove(buf_head, buf, len_buf);</span>
<span class="p_add">+				buf = buf_head;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			/* fetch as much as we can of the argument */</span>
<span class="p_add">+			len_tmp = strncpy_from_user(&amp;buf_head[len_buf], p,</span>
<span class="p_add">+						    len_max - len_buf);</span>
<span class="p_add">+			if (len_tmp == -EFAULT) {</span>
<span class="p_add">+				/* unable to copy from userspace */</span>
<span class="p_add">+				send_sig(SIGKILL, current, 0);</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+			} else if (len_tmp == (len_max - len_buf)) {</span>
<span class="p_add">+				/* buffer is not large enough */</span>
<span class="p_add">+				require_data = true;</span>
<span class="p_add">+				/* NOTE: if we are going to span multiple</span>
<span class="p_add">+				 *       buffers force the encoding so we stand</span>
<span class="p_add">+				 *       a chance at a sane len_full value and</span>
<span class="p_add">+				 *       consistent record encoding */</span>
<span class="p_add">+				encode = true;</span>
<span class="p_add">+				len_full = len_full * 2;</span>
<span class="p_add">+				p += len_tmp;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				require_data = false;</span>
<span class="p_add">+				if (!encode)</span>
<span class="p_add">+					encode = audit_string_contains_control(</span>
<span class="p_add">+								buf, len_tmp);</span>
<span class="p_add">+				/* try to use a trusted value for len_full */</span>
<span class="p_add">+				if (len_full &lt; len_max)</span>
<span class="p_add">+					len_full = (encode ?</span>
<span class="p_add">+						    len_tmp * 2 : len_tmp);</span>
<span class="p_add">+				p += len_tmp + 1;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			len_buf += len_tmp;</span>
<span class="p_add">+			buf_head[len_buf] = &#39;\0&#39;;</span>
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * first record needs to say how long the original string was</span>
<span class="p_del">-		 * so we can be sure nothing was lost.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if ((i == 0) &amp;&amp; (too_long))</span>
<span class="p_del">-			audit_log_format(*ab, &quot; a%d_len=%zu&quot;, arg_num,</span>
<span class="p_del">-					 has_cntl ? 2*len : len);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * normally arguments are small enough to fit and we already</span>
<span class="p_del">-		 * filled buf above when we checked for control characters</span>
<span class="p_del">-		 * so don&#39;t bother with another copy_from_user</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (len &gt;= max_execve_audit_len)</span>
<span class="p_del">-			ret = copy_from_user(buf, p, to_send);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			ret = 0;</span>
<span class="p_del">-		if (ret) {</span>
<span class="p_del">-			WARN_ON(1);</span>
<span class="p_del">-			send_sig(SIGKILL, current, 0);</span>
<span class="p_del">-			return -1;</span>
<span class="p_add">+			/* length of the buffer in the audit record? */</span>
<span class="p_add">+			len_abuf = (encode ? len_buf * 2 : len_buf + 2);</span>
 		}
<span class="p_del">-		buf[to_send] = &#39;\0&#39;;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* actually log it */</span>
<span class="p_del">-		audit_log_format(*ab, &quot; a%d&quot;, arg_num);</span>
<span class="p_del">-		if (too_long)</span>
<span class="p_del">-			audit_log_format(*ab, &quot;[%d]&quot;, i);</span>
<span class="p_del">-		audit_log_format(*ab, &quot;=&quot;);</span>
<span class="p_del">-		if (has_cntl)</span>
<span class="p_del">-			audit_log_n_hex(*ab, buf, to_send);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			audit_log_string(*ab, buf);</span>
<span class="p_del">-</span>
<span class="p_del">-		p += to_send;</span>
<span class="p_del">-		len_left -= to_send;</span>
<span class="p_del">-		*len_sent += arg_num_len;</span>
<span class="p_del">-		if (has_cntl)</span>
<span class="p_del">-			*len_sent += to_send * 2;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			*len_sent += to_send;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	/* include the null we didn&#39;t log */</span>
<span class="p_del">-	return len + 1;</span>
<span class="p_del">-}</span>
 
<span class="p_del">-static void audit_log_execve_info(struct audit_context *context,</span>
<span class="p_del">-				  struct audit_buffer **ab)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i, len;</span>
<span class="p_del">-	size_t len_sent = 0;</span>
<span class="p_del">-	const char __user *p;</span>
<span class="p_del">-	char *buf;</span>
<span class="p_add">+		/* write as much as we can to the audit log */</span>
<span class="p_add">+		if (len_buf &gt; 0) {</span>
<span class="p_add">+			/* NOTE: some magic numbers here - basically if we</span>
<span class="p_add">+			 *       can&#39;t fit a reasonable amount of data into the</span>
<span class="p_add">+			 *       existing audit buffer, flush it and start with</span>
<span class="p_add">+			 *       a new buffer */</span>
<span class="p_add">+			if ((sizeof(abuf) + 8) &gt; len_rem) {</span>
<span class="p_add">+				len_rem = len_max;</span>
<span class="p_add">+				audit_log_end(*ab);</span>
<span class="p_add">+				*ab = audit_log_start(context,</span>
<span class="p_add">+						      GFP_KERNEL, AUDIT_EXECVE);</span>
<span class="p_add">+				if (!*ab)</span>
<span class="p_add">+					goto out;</span>
<span class="p_add">+			}</span>
 
<span class="p_del">-	p = (const char __user *)current-&gt;mm-&gt;arg_start;</span>
<span class="p_add">+			/* create the non-arg portion of the arg record */</span>
<span class="p_add">+			len_tmp = 0;</span>
<span class="p_add">+			if (require_data || (iter &gt; 0) ||</span>
<span class="p_add">+			    ((len_abuf + sizeof(abuf)) &gt; len_rem)) {</span>
<span class="p_add">+				if (iter == 0) {</span>
<span class="p_add">+					len_tmp += snprintf(&amp;abuf[len_tmp],</span>
<span class="p_add">+							sizeof(abuf) - len_tmp,</span>
<span class="p_add">+							&quot; a%d_len=%lu&quot;,</span>
<span class="p_add">+							arg, len_full);</span>
<span class="p_add">+				}</span>
<span class="p_add">+				len_tmp += snprintf(&amp;abuf[len_tmp],</span>
<span class="p_add">+						    sizeof(abuf) - len_tmp,</span>
<span class="p_add">+						    &quot; a%d[%d]=&quot;, arg, iter++);</span>
<span class="p_add">+			} else</span>
<span class="p_add">+				len_tmp += snprintf(&amp;abuf[len_tmp],</span>
<span class="p_add">+						    sizeof(abuf) - len_tmp,</span>
<span class="p_add">+						    &quot; a%d=&quot;, arg);</span>
<span class="p_add">+			WARN_ON(len_tmp &gt;= sizeof(abuf));</span>
<span class="p_add">+			abuf[sizeof(abuf) - 1] = &#39;\0&#39;;</span>
<span class="p_add">+</span>
<span class="p_add">+			/* log the arg in the audit record */</span>
<span class="p_add">+			audit_log_format(*ab, &quot;%s&quot;, abuf);</span>
<span class="p_add">+			len_rem -= len_tmp;</span>
<span class="p_add">+			len_tmp = len_buf;</span>
<span class="p_add">+			if (encode) {</span>
<span class="p_add">+				if (len_abuf &gt; len_rem)</span>
<span class="p_add">+					len_tmp = len_rem / 2; /* encoding */</span>
<span class="p_add">+				audit_log_n_hex(*ab, buf, len_tmp);</span>
<span class="p_add">+				len_rem -= len_tmp * 2;</span>
<span class="p_add">+				len_abuf -= len_tmp * 2;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				if (len_abuf &gt; len_rem)</span>
<span class="p_add">+					len_tmp = len_rem - 2; /* quotes */</span>
<span class="p_add">+				audit_log_n_string(*ab, buf, len_tmp);</span>
<span class="p_add">+				len_rem -= len_tmp + 2;</span>
<span class="p_add">+				/* don&#39;t subtract the &quot;2&quot; because we still need</span>
<span class="p_add">+				 * to add quotes to the remaining string */</span>
<span class="p_add">+				len_abuf -= len_tmp;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			len_buf -= len_tmp;</span>
<span class="p_add">+			buf += len_tmp;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-	audit_log_format(*ab, &quot;argc=%d&quot;, context-&gt;execve.argc);</span>
<span class="p_add">+		/* ready to move to the next argument? */</span>
<span class="p_add">+		if ((len_buf == 0) &amp;&amp; !require_data) {</span>
<span class="p_add">+			arg++;</span>
<span class="p_add">+			iter = 0;</span>
<span class="p_add">+			len_full = 0;</span>
<span class="p_add">+			require_data = true;</span>
<span class="p_add">+			encode = false;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while (arg &lt; context-&gt;execve.argc);</span>
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * we need some kernel buffer to hold the userspace args.  Just</span>
<span class="p_del">-	 * allocate one big one rather than allocating one of the right size</span>
<span class="p_del">-	 * for every single argument inside audit_log_single_execve_arg()</span>
<span class="p_del">-	 * should be &lt;8k allocation so should be pretty safe.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	buf = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);</span>
<span class="p_del">-	if (!buf) {</span>
<span class="p_del">-		audit_panic(&quot;out of memory for argv string&quot;);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* NOTE: the caller handles the final audit_log_end() call */</span>
 
<span class="p_del">-	for (i = 0; i &lt; context-&gt;execve.argc; i++) {</span>
<span class="p_del">-		len = audit_log_single_execve_arg(context, ab, i,</span>
<span class="p_del">-						  &amp;len_sent, p, buf);</span>
<span class="p_del">-		if (len &lt;= 0)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		p += len;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	kfree(buf);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	kfree(buf_head);</span>
 }
 
 static void show_special(struct audit_context *context, int *call_panic)
<span class="p_header">diff --git a/kernel/cgroup.c b/kernel/cgroup.c</span>
<span class="p_header">index 75c0ff00aca6..e0be49fc382f 100644</span>
<span class="p_header">--- a/kernel/cgroup.c</span>
<span class="p_header">+++ b/kernel/cgroup.c</span>
<span class="p_chunk">@@ -2215,12 +2215,8 @@</span> <span class="p_context"> static struct dentry *cgroup_mount(struct file_system_type *fs_type,</span>
 		goto out_unlock;
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We know this subsystem has not yet been bound.  Users in a non-init</span>
<span class="p_del">-	 * user namespace may only mount hierarchies with no bound subsystems,</span>
<span class="p_del">-	 * i.e. &#39;none,name=user1&#39;</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!opts.none &amp;&amp; !capable(CAP_SYS_ADMIN)) {</span>
<span class="p_add">+	/* Hierarchies may only be created in the initial cgroup namespace. */</span>
<span class="p_add">+	if (ns != &amp;init_cgroup_ns) {</span>
 		ret = -EPERM;
 		goto out_unlock;
 	}
<span class="p_chunk">@@ -2962,6 +2958,7 @@</span> <span class="p_context"> int cgroup_attach_task_all(struct task_struct *from, struct task_struct *tsk)</span>
 	int retval = 0;
 
 	mutex_lock(&amp;cgroup_mutex);
<span class="p_add">+	percpu_down_write(&amp;cgroup_threadgroup_rwsem);</span>
 	for_each_root(root) {
 		struct cgroup *from_cgrp;
 
<span class="p_chunk">@@ -2976,6 +2973,7 @@</span> <span class="p_context"> int cgroup_attach_task_all(struct task_struct *from, struct task_struct *tsk)</span>
 		if (retval)
 			break;
 	}
<span class="p_add">+	percpu_up_write(&amp;cgroup_threadgroup_rwsem);</span>
 	mutex_unlock(&amp;cgroup_mutex);
 
 	return retval;
<span class="p_chunk">@@ -4343,6 +4341,8 @@</span> <span class="p_context"> int cgroup_transfer_tasks(struct cgroup *to, struct cgroup *from)</span>
 
 	mutex_lock(&amp;cgroup_mutex);
 
<span class="p_add">+	percpu_down_write(&amp;cgroup_threadgroup_rwsem);</span>
<span class="p_add">+</span>
 	/* all tasks in @from are being moved, all csets are source */
 	spin_lock_irq(&amp;css_set_lock);
 	list_for_each_entry(link, &amp;from-&gt;cset_links, cset_link)
<span class="p_chunk">@@ -4371,6 +4371,7 @@</span> <span class="p_context"> int cgroup_transfer_tasks(struct cgroup *to, struct cgroup *from)</span>
 	} while (task &amp;&amp; !ret);
 out_err:
 	cgroup_migrate_finish(&amp;preloaded_csets);
<span class="p_add">+	percpu_up_write(&amp;cgroup_threadgroup_rwsem);</span>
 	mutex_unlock(&amp;cgroup_mutex);
 	return ret;
 }
<span class="p_chunk">@@ -6309,14 +6310,11 @@</span> <span class="p_context"> struct cgroup_namespace *copy_cgroup_ns(unsigned long flags,</span>
 	if (!ns_capable(user_ns, CAP_SYS_ADMIN))
 		return ERR_PTR(-EPERM);
 
<span class="p_del">-	mutex_lock(&amp;cgroup_mutex);</span>
<span class="p_add">+	/* It is not safe to take cgroup_mutex here */</span>
 	spin_lock_irq(&amp;css_set_lock);
<span class="p_del">-</span>
 	cset = task_css_set(current);
 	get_css_set(cset);
<span class="p_del">-</span>
 	spin_unlock_irq(&amp;css_set_lock);
<span class="p_del">-	mutex_unlock(&amp;cgroup_mutex);</span>
 
 	new_ns = alloc_cgroup_ns();
 	if (IS_ERR(new_ns)) {
<span class="p_header">diff --git a/kernel/module.c b/kernel/module.c</span>
<span class="p_header">index 5f71aa63ed2a..6458a2f17d58 100644</span>
<span class="p_header">--- a/kernel/module.c</span>
<span class="p_header">+++ b/kernel/module.c</span>
<span class="p_chunk">@@ -2687,13 +2687,18 @@</span> <span class="p_context"> static inline void kmemleak_load_module(const struct module *mod,</span>
 #endif
 
 #ifdef CONFIG_MODULE_SIG
<span class="p_del">-static int module_sig_check(struct load_info *info)</span>
<span class="p_add">+static int module_sig_check(struct load_info *info, int flags)</span>
 {
 	int err = -ENOKEY;
 	const unsigned long markerlen = sizeof(MODULE_SIG_STRING) - 1;
 	const void *mod = info-&gt;hdr;
 
<span class="p_del">-	if (info-&gt;len &gt; markerlen &amp;&amp;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Require flags == 0, as a module with version information</span>
<span class="p_add">+	 * removed is no longer the module that was signed</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (flags == 0 &amp;&amp;</span>
<span class="p_add">+	    info-&gt;len &gt; markerlen &amp;&amp;</span>
 	    memcmp(mod + info-&gt;len - markerlen, MODULE_SIG_STRING, markerlen) == 0) {
 		/* We truncate the module to discard the signature */
 		info-&gt;len -= markerlen;
<span class="p_chunk">@@ -2712,7 +2717,7 @@</span> <span class="p_context"> static int module_sig_check(struct load_info *info)</span>
 	return err;
 }
 #else /* !CONFIG_MODULE_SIG */
<span class="p_del">-static int module_sig_check(struct load_info *info)</span>
<span class="p_add">+static int module_sig_check(struct load_info *info, int flags)</span>
 {
 	return 0;
 }
<span class="p_chunk">@@ -3498,7 +3503,7 @@</span> <span class="p_context"> static int load_module(struct load_info *info, const char __user *uargs,</span>
 	long err;
 	char *after_dashes;
 
<span class="p_del">-	err = module_sig_check(info);</span>
<span class="p_add">+	err = module_sig_check(info, flags);</span>
 	if (err)
 		goto free_copy;
 
<span class="p_header">diff --git a/mm/backing-dev.c b/mm/backing-dev.c</span>
<span class="p_header">index ed173b8ae8f2..9269911d10dd 100644</span>
<span class="p_header">--- a/mm/backing-dev.c</span>
<span class="p_header">+++ b/mm/backing-dev.c</span>
<span class="p_chunk">@@ -825,6 +825,20 @@</span> <span class="p_context"> int bdi_register_dev(struct backing_dev_info *bdi, dev_t dev)</span>
 }
 EXPORT_SYMBOL(bdi_register_dev);
 
<span class="p_add">+int bdi_register_owner(struct backing_dev_info *bdi, struct device *owner)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = bdi_register(bdi, NULL, &quot;%u:%u&quot;, MAJOR(owner-&gt;devt),</span>
<span class="p_add">+			MINOR(owner-&gt;devt));</span>
<span class="p_add">+	if (rc)</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+	bdi-&gt;owner = owner;</span>
<span class="p_add">+	get_device(owner);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(bdi_register_owner);</span>
<span class="p_add">+</span>
 /*
  * Remove bdi from bdi_list, and ensure that it is no longer visible
  */
<span class="p_chunk">@@ -849,6 +863,11 @@</span> <span class="p_context"> void bdi_unregister(struct backing_dev_info *bdi)</span>
 		device_unregister(bdi-&gt;dev);
 		bdi-&gt;dev = NULL;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (bdi-&gt;owner) {</span>
<span class="p_add">+		put_device(bdi-&gt;owner);</span>
<span class="p_add">+		bdi-&gt;owner = NULL;</span>
<span class="p_add">+	}</span>
 }
 
 void bdi_exit(struct backing_dev_info *bdi)
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index addfe4accc07..d9ec1a5b37ff 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -2214,6 +2214,10 @@</span> <span class="p_context"> static unsigned long set_max_huge_pages(struct hstate *h, unsigned long count,</span>
 		 * and reducing the surplus.
 		 */
 		spin_unlock(&amp;hugetlb_lock);
<span class="p_add">+</span>
<span class="p_add">+		/* yield cpu to avoid soft lockup */</span>
<span class="p_add">+		cond_resched();</span>
<span class="p_add">+</span>
 		if (hstate_is_gigantic(h))
 			ret = alloc_fresh_gigantic_page(h, nodes_allowed);
 		else
<span class="p_header">diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c</span>
<span class="p_header">index 388ee8b59145..1842141baedb 100644</span>
<span class="p_header">--- a/net/bluetooth/l2cap_sock.c</span>
<span class="p_header">+++ b/net/bluetooth/l2cap_sock.c</span>
<span class="p_chunk">@@ -927,7 +927,7 @@</span> <span class="p_context"> static int l2cap_sock_setsockopt(struct socket *sock, int level, int optname,</span>
 			break;
 		}
 
<span class="p_del">-		if (get_user(opt, (u32 __user *) optval)) {</span>
<span class="p_add">+		if (get_user(opt, (u16 __user *) optval)) {</span>
 			err = -EFAULT;
 			break;
 		}
<span class="p_header">diff --git a/net/netlabel/netlabel_kapi.c b/net/netlabel/netlabel_kapi.c</span>
<span class="p_header">index 1325776daa27..bd007a9fd921 100644</span>
<span class="p_header">--- a/net/netlabel/netlabel_kapi.c</span>
<span class="p_header">+++ b/net/netlabel/netlabel_kapi.c</span>
<span class="p_chunk">@@ -824,7 +824,11 @@</span> <span class="p_context"> socket_setattr_return:</span>
  */
 void netlbl_sock_delattr(struct sock *sk)
 {
<span class="p_del">-	cipso_v4_sock_delattr(sk);</span>
<span class="p_add">+	switch (sk-&gt;sk_family) {</span>
<span class="p_add">+	case AF_INET:</span>
<span class="p_add">+		cipso_v4_sock_delattr(sk);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_chunk">@@ -987,7 +991,11 @@</span> <span class="p_context"> req_setattr_return:</span>
 */
 void netlbl_req_delattr(struct request_sock *req)
 {
<span class="p_del">-	cipso_v4_req_delattr(req);</span>
<span class="p_add">+	switch (req-&gt;rsk_ops-&gt;family) {</span>
<span class="p_add">+	case AF_INET:</span>
<span class="p_add">+		cipso_v4_req_delattr(req);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_header">diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c</span>
<span class="p_header">index e167592793a7..42396a74405d 100644</span>
<span class="p_header">--- a/scripts/recordmcount.c</span>
<span class="p_header">+++ b/scripts/recordmcount.c</span>
<span class="p_chunk">@@ -33,10 +33,17 @@</span> <span class="p_context"></span>
 #include &lt;string.h&gt;
 #include &lt;unistd.h&gt;
 
<span class="p_add">+/*</span>
<span class="p_add">+ * glibc synced up and added the metag number but didn&#39;t add the relocations.</span>
<span class="p_add">+ * Work around this in a crude manner for now.</span>
<span class="p_add">+ */</span>
 #ifndef EM_METAG
<span class="p_del">-/* Remove this when these make it to the standard system elf.h. */</span>
 #define EM_METAG      174
<span class="p_add">+#endif</span>
<span class="p_add">+#ifndef R_METAG_ADDR32</span>
 #define R_METAG_ADDR32                   2
<span class="p_add">+#endif</span>
<span class="p_add">+#ifndef R_METAG_NONE</span>
 #define R_METAG_NONE                     3
 #endif
 
<span class="p_header">diff --git a/sound/hda/array.c b/sound/hda/array.c</span>
<span class="p_header">index 516795baa7db..5dfa610e4471 100644</span>
<span class="p_header">--- a/sound/hda/array.c</span>
<span class="p_header">+++ b/sound/hda/array.c</span>
<span class="p_chunk">@@ -21,13 +21,15 @@</span> <span class="p_context"> void *snd_array_new(struct snd_array *array)</span>
 		return NULL;
 	if (array-&gt;used &gt;= array-&gt;alloced) {
 		int num = array-&gt;alloced + array-&gt;alloc_align;
<span class="p_add">+		int oldsize = array-&gt;alloced * array-&gt;elem_size;</span>
 		int size = (num + 1) * array-&gt;elem_size;
 		void *nlist;
 		if (snd_BUG_ON(num &gt;= 4096))
 			return NULL;
<span class="p_del">-		nlist = krealloc(array-&gt;list, size, GFP_KERNEL | __GFP_ZERO);</span>
<span class="p_add">+		nlist = krealloc(array-&gt;list, size, GFP_KERNEL);</span>
 		if (!nlist)
 			return NULL;
<span class="p_add">+		memset(nlist + oldsize, 0, size - oldsize);</span>
 		array-&gt;list = nlist;
 		array-&gt;alloced = num;
 	}
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index 6f8ea13323c1..89dacf9b4e6c 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -2265,6 +2265,8 @@</span> <span class="p_context"> static const struct pci_device_id azx_ids[] = {</span>
 	{ PCI_DEVICE(0x1022, 0x780d),
 	  .driver_data = AZX_DRIVER_GENERIC | AZX_DCAPS_PRESET_ATI_SB },
 	/* ATI HDMI */
<span class="p_add">+	{ PCI_DEVICE(0x1002, 0x0002),</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },</span>
 	{ PCI_DEVICE(0x1002, 0x1308),
 	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },
 	{ PCI_DEVICE(0x1002, 0x157a),
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index abcb5a6a1cd9..f25479ba3981 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -4674,6 +4674,22 @@</span> <span class="p_context"> static void alc290_fixup_mono_speakers(struct hda_codec *codec,</span>
 	}
 }
 
<span class="p_add">+static void alc298_fixup_speaker_volume(struct hda_codec *codec,</span>
<span class="p_add">+					const struct hda_fixup *fix, int action)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (action == HDA_FIXUP_ACT_PRE_PROBE) {</span>
<span class="p_add">+		/* The speaker is routed to the Node 0x06 by a mistake, as a result</span>
<span class="p_add">+		   we can&#39;t adjust the speaker&#39;s volume since this node does not has</span>
<span class="p_add">+		   Amp-out capability. we change the speaker&#39;s route to:</span>
<span class="p_add">+		   Node 0x02 (Audio Output) -&gt; Node 0x0c (Audio Mixer) -&gt; Node 0x17 (</span>
<span class="p_add">+		   Pin Complex), since Node 0x02 has Amp-out caps, we can adjust</span>
<span class="p_add">+		   speaker&#39;s volume now. */</span>
<span class="p_add">+</span>
<span class="p_add">+		hda_nid_t conn1[1] = { 0x0c };</span>
<span class="p_add">+		snd_hda_override_conn_list(codec, 0x17, 1, conn1);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Hook to update amp GPIO4 for automute */
 static void alc280_hp_gpio4_automute_hook(struct hda_codec *codec,
 					  struct hda_jack_callback *jack)
<span class="p_chunk">@@ -4823,6 +4839,7 @@</span> <span class="p_context"> enum {</span>
 	ALC280_FIXUP_HP_HEADSET_MIC,
 	ALC221_FIXUP_HP_FRONT_MIC,
 	ALC292_FIXUP_TPT460,
<span class="p_add">+	ALC298_FIXUP_SPK_VOLUME,</span>
 };
 
 static const struct hda_fixup alc269_fixups[] = {
<span class="p_chunk">@@ -5478,6 +5495,12 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 		.chained = true,
 		.chain_id = ALC293_FIXUP_LENOVO_SPK_NOISE,
 	},
<span class="p_add">+	[ALC298_FIXUP_SPK_VOLUME] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc298_fixup_speaker_volume,</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC298_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
<span class="p_add">+	},</span>
 };
 
 static const struct snd_pci_quirk alc269_fixup_tbl[] = {
<span class="p_chunk">@@ -5524,6 +5547,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x0704, &quot;Dell XPS 13 9350&quot;, ALC256_FIXUP_DELL_XPS_13_HEADPHONE_NOISE),
 	SND_PCI_QUIRK(0x1028, 0x0725, &quot;Dell Inspiron 3162&quot;, ALC255_FIXUP_DELL_SPK_NOISE),
 	SND_PCI_QUIRK(0x1028, 0x075b, &quot;Dell XPS 13 9360&quot;, ALC256_FIXUP_DELL_XPS_13_HEADPHONE_NOISE),
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x075d, &quot;Dell AIO&quot;, ALC298_FIXUP_SPK_VOLUME),</span>
 	SND_PCI_QUIRK(0x1028, 0x164a, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x164b, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x103c, 0x1586, &quot;HP&quot;, ALC269_FIXUP_HP_MUTE_LED_MIC2),
<span class="p_chunk">@@ -5799,6 +5823,10 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 		{0x1b, 0x01014020},
 		{0x21, 0x0221103f}),
 	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
<span class="p_add">+		{0x14, 0x90170130},</span>
<span class="p_add">+		{0x1b, 0x02011020},</span>
<span class="p_add">+		{0x21, 0x0221103f}),</span>
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
 		{0x14, 0x90170150},
 		{0x1b, 0x02011020},
 		{0x21, 0x0221105f}),
<span class="p_header">diff --git a/tools/objtool/.gitignore b/tools/objtool/.gitignore</span>
<span class="p_header">index a0b3128bb31f..d3102c865a95 100644</span>
<span class="p_header">--- a/tools/objtool/.gitignore</span>
<span class="p_header">+++ b/tools/objtool/.gitignore</span>
<span class="p_chunk">@@ -1,2 +1,3 @@</span> <span class="p_context"></span>
 arch/x86/insn/inat-tables.c
 objtool
<span class="p_add">+fixdep</span>
<span class="p_header">diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c</span>
<span class="p_header">index 48bd520fc702..dd25346ec356 100644</span>
<span class="p_header">--- a/virt/kvm/kvm_main.c</span>
<span class="p_header">+++ b/virt/kvm/kvm_main.c</span>
<span class="p_chunk">@@ -148,6 +148,7 @@</span> <span class="p_context"> int vcpu_load(struct kvm_vcpu *vcpu)</span>
 	put_cpu();
 	return 0;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(vcpu_load);</span>
 
 void vcpu_put(struct kvm_vcpu *vcpu)
 {
<span class="p_chunk">@@ -157,6 +158,7 @@</span> <span class="p_context"> void vcpu_put(struct kvm_vcpu *vcpu)</span>
 	preempt_enable();
 	mutex_unlock(&amp;vcpu-&gt;mutex);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(vcpu_put);</span>
 
 static void ack_flush(void *_completed)
 {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



