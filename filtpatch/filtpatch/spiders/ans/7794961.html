
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v4] acpi, apei, arm64: APEI initial support for aarch64. - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v4] acpi, apei, arm64: APEI initial support for aarch64.</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=131991">fu.wei@linaro.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 8, 2015, 7:03 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1449558183-12259-1-git-send-email-fu.wei@linaro.org&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7794961/mbox/"
   >mbox</a>
|
   <a href="/patch/7794961/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7794961/">/patch/7794961/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id BD6FA9F387
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  8 Dec 2015 07:04:11 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id B348A204FB
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  8 Dec 2015 07:04:10 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 320B3204EA
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  8 Dec 2015 07:04:09 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S933185AbbLHHEF (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 8 Dec 2015 02:04:05 -0500
Received: from mx1.redhat.com ([209.132.183.28]:60264 &quot;EHLO mx1.redhat.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S933155AbbLHHEB (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 8 Dec 2015 02:04:01 -0500
Received: from int-mx14.intmail.prod.int.phx2.redhat.com
	(int-mx14.intmail.prod.int.phx2.redhat.com [10.5.11.27])
	by mx1.redhat.com (Postfix) with ESMTPS id F31C63C234;
	Tue,  8 Dec 2015 07:03:59 +0000 (UTC)
Received: from magi-f22.redhat.com (vpn1-5-196.pek2.redhat.com [10.72.5.196])
	by int-mx14.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with
	ESMTP id tB873cRo008769; Tue, 8 Dec 2015 02:03:40 -0500
From: fu.wei@linaro.org
To: tomasz.nowicki@linaro.org, tn@semihalf.com, rjw@rjwysocki.net,
	lenb@kernel.org, catalin.marinas@arm.com, will.deacon@arm.com
Cc: linux-kernel@vger.kernel.org, linux-arm-kernel@lists.infradead.org,
	linux-acpi@vger.kernel.org, linaro-acpi@lists.linaro.org,
	graeme.gregory@linaro.org, al.stone@linaro.org,
	hanjun.guo@linaro.org, mark.rutland@arm.com, Marc.Zyngier@arm.com,
	lorenzo.pieralisi@arm.com, rruigrok@codeaurora.org,
	harba@qti.qualcomm.com, jcm@redhat.com, msalter@redhat.com,
	grant.likely@linaro.org, rrichter@cavium.com,
	jarkko.nikula@linux.intel.com, jon.zhixiong.zhang@gmail.com,
	Fu Wei &lt;fu.wei@linaro.org&gt;
Subject: [PATCH v4] acpi, apei, arm64: APEI initial support for aarch64.
Date: Tue,  8 Dec 2015 15:03:03 +0800
Message-Id: &lt;1449558183-12259-1-git-send-email-fu.wei@linaro.org&gt;
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.27
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131991">fu.wei@linaro.org</a> - Dec. 8, 2015, 7:03 a.m.</div>
<pre class="content">
<span class="from">From: Tomasz Nowicki &lt;tomasz.nowicki@linaro.org&gt;</span>

This commit provides APEI arch-specific bits for aarch64

Meanwhile, add a new subfunction &quot;hest_ia_init&quot; for
&quot;acpi_disable_cmcff&quot; which is used by IA-32 Architecture
Corrected Machine Check (CMC).
<span class="signed-off-by">
Signed-off-by: Tomasz Nowicki &lt;tomasz.nowicki@linaro.org&gt;</span>
<span class="tested-by">Tested-by: Jonathan (Zhixiong) Zhang &lt;zjzhang@codeaurora.org&gt;</span>
<span class="signed-off-by">Signed-off-by: Fu Wei &lt;fu.wei@linaro.org&gt;</span>
---
Changelog:
v4: Rebase to latest kernel version(4.4-rc4).
    Move arch_apei_flush_tlb_one into header file as a inline function
    Add a new subfunction &quot;hest_ia_init&quot; for &quot;acpi_disable_cmcff&quot;.

v3: https://lkml.org/lkml/2015/12/3/521
    Remove &quot;acpi_disable_cmcff&quot; from arm64 code,
    and wrap it in hest.c by &quot;#if defined(__i386__) || defined(__x86_64__)&quot;

v2: https://lkml.org/lkml/2015/12/2/432
    Rebase to latest kernel version(4.4-rc3).
    Move arch_apei_flush_tlb_one() to arch/arm64/kernel/acpi.c

v1: https://lkml.org/lkml/2015/8/14/199
    Move arch_apei_flush_tlb_one() to arch/arm64/include/asm/apci.h.
    Delete arch/arm64/kernel/apei.c.
    Add &quot;#ifdef CONFIG_ACPI_APEI&quot; for &quot;acpi_disable_cmcff&quot;.

 arch/arm64/Kconfig            |  1 +
 arch/arm64/include/asm/acpi.h |  5 +++++
 drivers/acpi/apei/hest.c      | 19 ++++++++++++++++---
 3 files changed, 22 insertions(+), 3 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=67511">Hanjun Guo</a> - Dec. 8, 2015, 11:26 a.m.</div>
<pre class="content">
Hi Fu Wei,

On 12/08/2015 03:03 PM, fu.wei@linaro.org wrote:
<span class="quote">&gt; From: Tomasz Nowicki &lt;tomasz.nowicki@linaro.org&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This commit provides APEI arch-specific bits for aarch64</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Meanwhile, add a new subfunction &quot;hest_ia_init&quot; for</span>
<span class="quote">&gt; &quot;acpi_disable_cmcff&quot; which is used by IA-32 Architecture</span>
<span class="quote">&gt; Corrected Machine Check (CMC).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Signed-off-by: Tomasz Nowicki &lt;tomasz.nowicki@linaro.org&gt;</span>
<span class="quote">&gt; Tested-by: Jonathan (Zhixiong) Zhang &lt;zjzhang@codeaurora.org&gt;</span>
<span class="quote">&gt; Signed-off-by: Fu Wei &lt;fu.wei@linaro.org&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt; Changelog:</span>
<span class="quote">&gt; v4: Rebase to latest kernel version(4.4-rc4).</span>
<span class="quote">&gt;      Move arch_apei_flush_tlb_one into header file as a inline function</span>
<span class="quote">&gt;      Add a new subfunction &quot;hest_ia_init&quot; for &quot;acpi_disable_cmcff&quot;.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; v3: https://lkml.org/lkml/2015/12/3/521</span>
<span class="quote">&gt;      Remove &quot;acpi_disable_cmcff&quot; from arm64 code,</span>
<span class="quote">&gt;      and wrap it in hest.c by &quot;#if defined(__i386__) || defined(__x86_64__)&quot;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; v2: https://lkml.org/lkml/2015/12/2/432</span>
<span class="quote">&gt;      Rebase to latest kernel version(4.4-rc3).</span>
<span class="quote">&gt;      Move arch_apei_flush_tlb_one() to arch/arm64/kernel/acpi.c</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; v1: https://lkml.org/lkml/2015/8/14/199</span>
<span class="quote">&gt;      Move arch_apei_flush_tlb_one() to arch/arm64/include/asm/apci.h.</span>
<span class="quote">&gt;      Delete arch/arm64/kernel/apei.c.</span>
<span class="quote">&gt;      Add &quot;#ifdef CONFIG_ACPI_APEI&quot; for &quot;acpi_disable_cmcff&quot;.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;   arch/arm64/Kconfig            |  1 +</span>
<span class="quote">&gt;   arch/arm64/include/asm/acpi.h |  5 +++++</span>
<span class="quote">&gt;   drivers/acpi/apei/hest.c      | 19 ++++++++++++++++---</span>
<span class="quote">&gt;   3 files changed, 22 insertions(+), 3 deletions(-)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig</span>
<span class="quote">&gt; index 871f217..58c8992 100644</span>
<span class="quote">&gt; --- a/arch/arm64/Kconfig</span>
<span class="quote">&gt; +++ b/arch/arm64/Kconfig</span>
<span class="quote">&gt; @@ -3,6 +3,7 @@ config ARM64</span>
<span class="quote">&gt;   	select ACPI_CCA_REQUIRED if ACPI</span>
<span class="quote">&gt;   	select ACPI_GENERIC_GSI if ACPI</span>
<span class="quote">&gt;   	select ACPI_REDUCED_HARDWARE_ONLY if ACPI</span>
<span class="quote">&gt; +	select HAVE_ACPI_APEI if ACPI</span>
<span class="quote">&gt;   	select ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE</span>
<span class="quote">&gt;   	select ARCH_HAS_ELF_RANDOMIZE</span>
<span class="quote">&gt;   	select ARCH_HAS_GCOV_PROFILE_ALL</span>
<span class="quote">&gt; diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h</span>
<span class="quote">&gt; index caafd63..31d3d9a 100644</span>
<span class="quote">&gt; --- a/arch/arm64/include/asm/acpi.h</span>
<span class="quote">&gt; +++ b/arch/arm64/include/asm/acpi.h</span>
<span class="quote">&gt; @@ -17,6 +17,7 @@</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;   #include &lt;asm/cputype.h&gt;</span>
<span class="quote">&gt;   #include &lt;asm/smp_plat.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/tlbflush.h&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;   /* Macros for consistency checks of the GICC subtable of MADT */</span>
<span class="quote">&gt;   #define ACPI_MADT_GICC_LENGTH	\</span>
<span class="quote">&gt; @@ -94,6 +95,10 @@ static inline const char *acpi_get_enable_method(int cpu)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;   #ifdef	CONFIG_ACPI_APEI</span>
<span class="quote">&gt;   pgprot_t arch_apei_get_mem_attribute(phys_addr_t addr);</span>

How bout adding a empty line here?

Except that,
<span class="acked-by">
Acked-by: Hanjun Guo &lt;hanjun.guo@linaro.org&gt;</span>

Thanks
Hanjun
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=22691">Lorenzo Pieralisi</a> - Dec. 8, 2015, 12:34 p.m.</div>
<pre class="content">
On Tue, Dec 08, 2015 at 03:03:03PM +0800, fu.wei@linaro.org wrote:
<span class="quote">&gt; From: Tomasz Nowicki &lt;tomasz.nowicki@linaro.org&gt;</span>

[...]
<span class="quote">
&gt; +#if defined(__i386__) || defined(__x86_64__)</span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt;   * Check if firmware advertises firmware first mode. We need FF bit to be set</span>
<span class="quote">&gt;   * along with a set of MC banks which work in FF mode.</span>
<span class="quote">&gt;   */</span>
<span class="quote">&gt;  static int __init hest_parse_cmc(struct acpi_hest_header *hest_hdr, void *data)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; -	return arch_apei_enable_cmcff(hest_hdr, data);</span>
<span class="quote">&gt; +	if (!acpi_disable_cmcff)</span>

Why do not you define the flag above in this file (move it out of x86 -
that&#39;s what I was aiming at in my previous reply) and remove this ifdeffery
altogether (First firmware handling could apply to arm64 too according to
specs and ACPI on arm64 guidelines) ?

arch_apei_enable_cmcff() is a weak function that does nothing on arm64
and if we need to add an implementation we can do it later.

Thanks,
Lorenzo
<span class="quote">
&gt; +		return !arch_apei_enable_cmcff(hest_hdr, data);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +static inline int __init hest_ia_init(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return apei_hest_parse(hest_parse_cmc, NULL);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +#else</span>
<span class="quote">&gt; +static inline int __init hest_ia_init(void) { return 0; }</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  struct ghes_arr {</span>
<span class="quote">&gt;  	struct platform_device **ghes_devs;</span>
<span class="quote">&gt;  	unsigned int count;</span>
<span class="quote">&gt; @@ -232,8 +244,9 @@ void __init acpi_hest_init(void)</span>
<span class="quote">&gt;  		goto err;</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -	if (!acpi_disable_cmcff)</span>
<span class="quote">&gt; -		apei_hest_parse(hest_parse_cmc, NULL);</span>
<span class="quote">&gt; +	rc = hest_ia_init();</span>
<span class="quote">&gt; +	if (rc)</span>
<span class="quote">&gt; +		goto err;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	if (!ghes_disable) {</span>
<span class="quote">&gt;  		rc = apei_hest_parse(hest_parse_ghes_count, &amp;ghes_count);</span>
<span class="quote">&gt; -- </span>
<span class="quote">&gt; 2.5.0</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in</span>
<span class="quote">&gt; the body of a message to majordomo@vger.kernel.org</span>
<span class="quote">&gt; More majordomo info at  http://vger.kernel.org/majordomo-info.html</span>
<span class="quote">&gt; Please read the FAQ at  http://www.tux.org/lkml/</span>
<span class="quote">&gt; </span>
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=67511">Hanjun Guo</a> - Dec. 8, 2015, 12:52 p.m.</div>
<pre class="content">
Hi Lorenzo,

On 12/08/2015 08:34 PM, Lorenzo Pieralisi wrote:
<span class="quote">&gt; On Tue, Dec 08, 2015 at 03:03:03PM +0800, fu.wei@linaro.org wrote:</span>
<span class="quote">&gt;&gt; From: Tomasz Nowicki &lt;tomasz.nowicki@linaro.org&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; +#if defined(__i386__) || defined(__x86_64__)</span>
<span class="quote">&gt;&gt;   /*</span>
<span class="quote">&gt;&gt;    * Check if firmware advertises firmware first mode. We need FF bit to be set</span>
<span class="quote">&gt;&gt;    * along with a set of MC banks which work in FF mode.</span>
<span class="quote">&gt;&gt;    */</span>
<span class="quote">&gt;&gt;   static int __init hest_parse_cmc(struct acpi_hest_header *hest_hdr, void *data)</span>
<span class="quote">&gt;&gt;   {</span>
<span class="quote">&gt;&gt; -	return arch_apei_enable_cmcff(hest_hdr, data);</span>
<span class="quote">&gt;&gt; +	if (!acpi_disable_cmcff)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Why do not you define the flag above in this file (move it out of x86 -</span>
<span class="quote">&gt; that&#39;s what I was aiming at in my previous reply) and remove this ifdeffery</span>
<span class="quote">&gt; altogether (First firmware handling could apply to arm64 too according to</span>
<span class="quote">&gt; specs and ACPI on arm64 guidelines) ?</span>

If I understand it correctly, CMC (Corrected Machine Check) is for IA32
only, see section 18.3.2.1 IA-32 Architecture Machine Check Exception
in ACPI 6.0. for ARM64, we can use other type of error source for
firmware first handling, such as Generic Hardware Error Source, did
I miss something?

Thanks
Hanjun
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131991">fu.wei@linaro.org</a> - Dec. 8, 2015, 1:08 p.m.</div>
<pre class="content">
Hi Lorenzo,



On 8 December 2015 at 20:52, Hanjun Guo &lt;hanjun.guo@linaro.org&gt; wrote:
<span class="quote">&gt; Hi Lorenzo,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; On 12/08/2015 08:34 PM, Lorenzo Pieralisi wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On Tue, Dec 08, 2015 at 03:03:03PM +0800, fu.wei@linaro.org wrote:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; From: Tomasz Nowicki &lt;tomasz.nowicki@linaro.org&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; [...]</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; +#if defined(__i386__) || defined(__x86_64__)</span>
<span class="quote">&gt;&gt;&gt;   /*</span>
<span class="quote">&gt;&gt;&gt;    * Check if firmware advertises firmware first mode. We need FF bit to</span>
<span class="quote">&gt;&gt;&gt; be set</span>
<span class="quote">&gt;&gt;&gt;    * along with a set of MC banks which work in FF mode.</span>
<span class="quote">&gt;&gt;&gt;    */</span>
<span class="quote">&gt;&gt;&gt;   static int __init hest_parse_cmc(struct acpi_hest_header *hest_hdr,</span>
<span class="quote">&gt;&gt;&gt; void *data)</span>
<span class="quote">&gt;&gt;&gt;   {</span>
<span class="quote">&gt;&gt;&gt; -       return arch_apei_enable_cmcff(hest_hdr, data);</span>
<span class="quote">&gt;&gt;&gt; +       if (!acpi_disable_cmcff)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Why do not you define the flag above in this file (move it out of x86 -</span>
<span class="quote">&gt;&gt; that&#39;s what I was aiming at in my previous reply) and remove this</span>
<span class="quote">&gt;&gt; ifdeffery</span>
<span class="quote">&gt;&gt; altogether (First firmware handling could apply to arm64 too according to</span>
<span class="quote">&gt;&gt; specs and ACPI on arm64 guidelines) ?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; If I understand it correctly, CMC (Corrected Machine Check) is for IA32</span>
<span class="quote">&gt; only, see section 18.3.2.1 IA-32 Architecture Machine Check Exception</span>
<span class="quote">&gt; in ACPI 6.0. for ARM64, we can use other type of error source for</span>
<span class="quote">&gt; firmware first handling, such as Generic Hardware Error Source, did</span>
<span class="quote">&gt; I miss something?</span>

yes, that is why I try to use &quot;#if defined(__i386__) ||
defined(__x86_64__)&quot; instead of moving acpi_disable_cmcff out of x86
code to here.

And I thinks we also can do &quot;arch_apei_enable_cmcff&quot; --&gt;
&quot;apei_enable_ia_cmcff&quot; because that is IA32 only.

Please correct me if I misunderstand something.  Thanks :-)

Great thanks for your feedback :-)
<span class="quote">
&gt;</span>
<span class="quote">&gt; Thanks</span>
<span class="quote">&gt; Hanjun</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=22691">Lorenzo Pieralisi</a> - Dec. 8, 2015, 2:07 p.m.</div>
<pre class="content">
On Tue, Dec 08, 2015 at 09:08:24PM +0800, Fu Wei wrote:
<span class="quote">&gt; Hi Lorenzo,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On 8 December 2015 at 20:52, Hanjun Guo &lt;hanjun.guo@linaro.org&gt; wrote:</span>
<span class="quote">&gt; &gt; Hi Lorenzo,</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; On 12/08/2015 08:34 PM, Lorenzo Pieralisi wrote:</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; On Tue, Dec 08, 2015 at 03:03:03PM +0800, fu.wei@linaro.org wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; From: Tomasz Nowicki &lt;tomasz.nowicki@linaro.org&gt;</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; [...]</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; +#if defined(__i386__) || defined(__x86_64__)</span>
<span class="quote">&gt; &gt;&gt;&gt;   /*</span>
<span class="quote">&gt; &gt;&gt;&gt;    * Check if firmware advertises firmware first mode. We need FF bit to</span>
<span class="quote">&gt; &gt;&gt;&gt; be set</span>
<span class="quote">&gt; &gt;&gt;&gt;    * along with a set of MC banks which work in FF mode.</span>
<span class="quote">&gt; &gt;&gt;&gt;    */</span>
<span class="quote">&gt; &gt;&gt;&gt;   static int __init hest_parse_cmc(struct acpi_hest_header *hest_hdr,</span>
<span class="quote">&gt; &gt;&gt;&gt; void *data)</span>
<span class="quote">&gt; &gt;&gt;&gt;   {</span>
<span class="quote">&gt; &gt;&gt;&gt; -       return arch_apei_enable_cmcff(hest_hdr, data);</span>
<span class="quote">&gt; &gt;&gt;&gt; +       if (!acpi_disable_cmcff)</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Why do not you define the flag above in this file (move it out of x86 -</span>
<span class="quote">&gt; &gt;&gt; that&#39;s what I was aiming at in my previous reply) and remove this</span>
<span class="quote">&gt; &gt;&gt; ifdeffery</span>
<span class="quote">&gt; &gt;&gt; altogether (First firmware handling could apply to arm64 too according to</span>
<span class="quote">&gt; &gt;&gt; specs and ACPI on arm64 guidelines) ?</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; If I understand it correctly, CMC (Corrected Machine Check) is for IA32</span>
<span class="quote">&gt; &gt; only, see section 18.3.2.1 IA-32 Architecture Machine Check Exception</span>
<span class="quote">&gt; &gt; in ACPI 6.0. for ARM64, we can use other type of error source for</span>
<span class="quote">&gt; &gt; firmware first handling, such as Generic Hardware Error Source, did</span>
<span class="quote">&gt; &gt; I miss something?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; yes, that is why I try to use &quot;#if defined(__i386__) ||</span>
<span class="quote">&gt; defined(__x86_64__)&quot; instead of moving acpi_disable_cmcff out of x86</span>
<span class="quote">&gt; code to here.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; And I thinks we also can do &quot;arch_apei_enable_cmcff&quot; --&gt;</span>
<span class="quote">&gt; &quot;apei_enable_ia_cmcff&quot; because that is IA32 only.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Please correct me if I misunderstand something.  Thanks :-)</span>

No you are right, I was confused by the arch_apei_enable_cmcff __weak
function declaration, I am not sure that makes much sense, as you say.

Side note: I wonder if there is a way to make the TLB flushing API common
across architectures therefore avoiding this arch_apei_flush_tlb* churn.

Thanks,
Lorenzo
<span class="quote">
&gt; Great thanks for your feedback :-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Thanks</span>
<span class="quote">&gt; &gt; Hanjun</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; -- </span>
<span class="quote">&gt; Best regards,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Fu Wei</span>
<span class="quote">&gt; Software Engineer</span>
<span class="quote">&gt; Red Hat Software (Beijing) Co.,Ltd.Shanghai Branch</span>
<span class="quote">&gt; Ph: +86 21 61221326(direct)</span>
<span class="quote">&gt; Ph: +86 186 2020 4684 (mobile)</span>
<span class="quote">&gt; Room 1512, Regus One Corporate Avenue,Level 15,</span>
<span class="quote">&gt; One Corporate Avenue,222 Hubin Road,Huangpu District,</span>
<span class="quote">&gt; Shanghai,China 200021</span>
<span class="quote">&gt; </span>
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=114661">Suzuki K. Poulose</a> - Dec. 8, 2015, 3:53 p.m.</div>
<pre class="content">
On 08/12/15 07:03, fu.wei@linaro.org wrote:
<span class="quote">&gt; From: Tomasz Nowicki &lt;tomasz.nowicki@linaro.org&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This commit provides APEI arch-specific bits for aarch64</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Meanwhile, add a new subfunction &quot;hest_ia_init&quot; for</span>
<span class="quote">&gt; &quot;acpi_disable_cmcff&quot; which is used by IA-32 Architecture</span>
<span class="quote">&gt; Corrected Machine Check (CMC).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Signed-off-by: Tomasz Nowicki &lt;tomasz.nowicki@linaro.org&gt;</span>
<span class="quote">&gt; Tested-by: Jonathan (Zhixiong) Zhang &lt;zjzhang@codeaurora.org&gt;</span>
<span class="quote">&gt; Signed-off-by: Fu Wei &lt;fu.wei@linaro.org&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt; Changelog:</span>
<span class="quote">&gt; v4: Rebase to latest kernel version(4.4-rc4).</span>
<span class="quote">&gt;      Move arch_apei_flush_tlb_one into header file as a inline function</span>
<span class="quote">&gt;      Add a new subfunction &quot;hest_ia_init&quot; for &quot;acpi_disable_cmcff&quot;.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; v3: https://lkml.org/lkml/2015/12/3/521</span>
<span class="quote">&gt;      Remove &quot;acpi_disable_cmcff&quot; from arm64 code,</span>
<span class="quote">&gt;      and wrap it in hest.c by &quot;#if defined(__i386__) || defined(__x86_64__)&quot;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; v2: https://lkml.org/lkml/2015/12/2/432</span>
<span class="quote">&gt;      Rebase to latest kernel version(4.4-rc3).</span>
<span class="quote">&gt;      Move arch_apei_flush_tlb_one() to arch/arm64/kernel/acpi.c</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; v1: https://lkml.org/lkml/2015/8/14/199</span>
<span class="quote">&gt;      Move arch_apei_flush_tlb_one() to arch/arm64/include/asm/apci.h.</span>
<span class="quote">&gt;      Delete arch/arm64/kernel/apei.c.</span>
<span class="quote">&gt;      Add &quot;#ifdef CONFIG_ACPI_APEI&quot; for &quot;acpi_disable_cmcff&quot;.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;   arch/arm64/Kconfig            |  1 +</span>
<span class="quote">&gt;   arch/arm64/include/asm/acpi.h |  5 +++++</span>
<span class="quote">&gt;   drivers/acpi/apei/hest.c      | 19 ++++++++++++++++---</span>
<span class="quote">&gt;   3 files changed, 22 insertions(+), 3 deletions(-)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig</span>
<span class="quote">&gt; index 871f217..58c8992 100644</span>
<span class="quote">&gt; --- a/arch/arm64/Kconfig</span>
<span class="quote">&gt; +++ b/arch/arm64/Kconfig</span>
<span class="quote">&gt; @@ -3,6 +3,7 @@ config ARM64</span>
<span class="quote">&gt;   	select ACPI_CCA_REQUIRED if ACPI</span>
<span class="quote">&gt;   	select ACPI_GENERIC_GSI if ACPI</span>
<span class="quote">&gt;   	select ACPI_REDUCED_HARDWARE_ONLY if ACPI</span>
<span class="quote">&gt; +	select HAVE_ACPI_APEI if ACPI</span>
<span class="quote">&gt;   	select ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE</span>
<span class="quote">&gt;   	select ARCH_HAS_ELF_RANDOMIZE</span>
<span class="quote">&gt;   	select ARCH_HAS_GCOV_PROFILE_ALL</span>
<span class="quote">&gt; diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h</span>
<span class="quote">&gt; index caafd63..31d3d9a 100644</span>
<span class="quote">&gt; --- a/arch/arm64/include/asm/acpi.h</span>
<span class="quote">&gt; +++ b/arch/arm64/include/asm/acpi.h</span>
<span class="quote">&gt; @@ -17,6 +17,7 @@</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;   #include &lt;asm/cputype.h&gt;</span>
<span class="quote">&gt;   #include &lt;asm/smp_plat.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/tlbflush.h&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;   /* Macros for consistency checks of the GICC subtable of MADT */</span>
<span class="quote">&gt;   #define ACPI_MADT_GICC_LENGTH	\</span>
<span class="quote">&gt; @@ -94,6 +95,10 @@ static inline const char *acpi_get_enable_method(int cpu)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;   #ifdef	CONFIG_ACPI_APEI</span>
<span class="quote">&gt;   pgprot_t arch_apei_get_mem_attribute(phys_addr_t addr);</span>
<span class="quote">&gt; +static inline void arch_apei_flush_tlb_one(unsigned long addr)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	flush_tlb_kernel_range(addr, addr + PAGE_SIZE);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt;   #endif</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;   #endif /*_ASM_ACPI_H*/</span>
<span class="quote">&gt; diff --git a/drivers/acpi/apei/hest.c b/drivers/acpi/apei/hest.c</span>
<span class="quote">&gt; index 20b3fcf..715c58b 100644</span>
<span class="quote">&gt; --- a/drivers/acpi/apei/hest.c</span>
<span class="quote">&gt; +++ b/drivers/acpi/apei/hest.c</span>
<span class="quote">&gt; @@ -117,15 +117,27 @@ int apei_hest_parse(apei_hest_func_t func, void *data)</span>
<span class="quote">&gt;   }</span>
<span class="quote">&gt;   EXPORT_SYMBOL_GPL(apei_hest_parse);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +#if defined(__i386__) || defined(__x86_64__)</span>

Would it be better if define a symbol like :

HAVE_ARCH_APEI_CMCFF for x86 and wrap it around that ?
<span class="quote">
&gt;   /*</span>
<span class="quote">&gt;    * Check if firmware advertises firmware first mode. We need FF bit to be set</span>
<span class="quote">&gt;    * along with a set of MC banks which work in FF mode.</span>
<span class="quote">&gt;    */</span>
<span class="quote">&gt;   static int __init hest_parse_cmc(struct acpi_hest_header *hest_hdr, void *data)</span>
<span class="quote">&gt;   {</span>
<span class="quote">&gt; -	return arch_apei_enable_cmcff(hest_hdr, data);</span>
<span class="quote">&gt; +	if (!acpi_disable_cmcff)</span>
<span class="quote">&gt; +		return !arch_apei_enable_cmcff(hest_hdr, data);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt;   }</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +static inline int __init hest_ia_init(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return apei_hest_parse(hest_parse_cmc, NULL);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +#else</span>
<span class="quote">&gt; +static inline int __init hest_ia_init(void) { return 0; }</span>
<span class="quote">&gt; +#endif</span>

Cheers
Suzuki

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131991">fu.wei@linaro.org</a> - Dec. 9, 2015, 3 a.m.</div>
<pre class="content">
Hi Suzuki,

On 8 December 2015 at 23:53, Suzuki K. Poulose &lt;Suzuki.Poulose@arm.com&gt; wrote:
<span class="quote">&gt; On 08/12/15 07:03, fu.wei@linaro.org wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; From: Tomasz Nowicki &lt;tomasz.nowicki@linaro.org&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This commit provides APEI arch-specific bits for aarch64</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Meanwhile, add a new subfunction &quot;hest_ia_init&quot; for</span>
<span class="quote">&gt;&gt; &quot;acpi_disable_cmcff&quot; which is used by IA-32 Architecture</span>
<span class="quote">&gt;&gt; Corrected Machine Check (CMC).</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Tomasz Nowicki &lt;tomasz.nowicki@linaro.org&gt;</span>
<span class="quote">&gt;&gt; Tested-by: Jonathan (Zhixiong) Zhang &lt;zjzhang@codeaurora.org&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Fu Wei &lt;fu.wei@linaro.org&gt;</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt;&gt; Changelog:</span>
<span class="quote">&gt;&gt; v4: Rebase to latest kernel version(4.4-rc4).</span>
<span class="quote">&gt;&gt;      Move arch_apei_flush_tlb_one into header file as a inline function</span>
<span class="quote">&gt;&gt;      Add a new subfunction &quot;hest_ia_init&quot; for &quot;acpi_disable_cmcff&quot;.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; v3: https://lkml.org/lkml/2015/12/3/521</span>
<span class="quote">&gt;&gt;      Remove &quot;acpi_disable_cmcff&quot; from arm64 code,</span>
<span class="quote">&gt;&gt;      and wrap it in hest.c by &quot;#if defined(__i386__) ||</span>
<span class="quote">&gt;&gt; defined(__x86_64__)&quot;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; v2: https://lkml.org/lkml/2015/12/2/432</span>
<span class="quote">&gt;&gt;      Rebase to latest kernel version(4.4-rc3).</span>
<span class="quote">&gt;&gt;      Move arch_apei_flush_tlb_one() to arch/arm64/kernel/acpi.c</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; v1: https://lkml.org/lkml/2015/8/14/199</span>
<span class="quote">&gt;&gt;      Move arch_apei_flush_tlb_one() to arch/arm64/include/asm/apci.h.</span>
<span class="quote">&gt;&gt;      Delete arch/arm64/kernel/apei.c.</span>
<span class="quote">&gt;&gt;      Add &quot;#ifdef CONFIG_ACPI_APEI&quot; for &quot;acpi_disable_cmcff&quot;.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;   arch/arm64/Kconfig            |  1 +</span>
<span class="quote">&gt;&gt;   arch/arm64/include/asm/acpi.h |  5 +++++</span>
<span class="quote">&gt;&gt;   drivers/acpi/apei/hest.c      | 19 ++++++++++++++++---</span>
<span class="quote">&gt;&gt;   3 files changed, 22 insertions(+), 3 deletions(-)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig</span>
<span class="quote">&gt;&gt; index 871f217..58c8992 100644</span>
<span class="quote">&gt;&gt; --- a/arch/arm64/Kconfig</span>
<span class="quote">&gt;&gt; +++ b/arch/arm64/Kconfig</span>
<span class="quote">&gt;&gt; @@ -3,6 +3,7 @@ config ARM64</span>
<span class="quote">&gt;&gt;         select ACPI_CCA_REQUIRED if ACPI</span>
<span class="quote">&gt;&gt;         select ACPI_GENERIC_GSI if ACPI</span>
<span class="quote">&gt;&gt;         select ACPI_REDUCED_HARDWARE_ONLY if ACPI</span>
<span class="quote">&gt;&gt; +       select HAVE_ACPI_APEI if ACPI</span>
<span class="quote">&gt;&gt;         select ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE</span>
<span class="quote">&gt;&gt;         select ARCH_HAS_ELF_RANDOMIZE</span>
<span class="quote">&gt;&gt;         select ARCH_HAS_GCOV_PROFILE_ALL</span>
<span class="quote">&gt;&gt; diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h</span>
<span class="quote">&gt;&gt; index caafd63..31d3d9a 100644</span>
<span class="quote">&gt;&gt; --- a/arch/arm64/include/asm/acpi.h</span>
<span class="quote">&gt;&gt; +++ b/arch/arm64/include/asm/acpi.h</span>
<span class="quote">&gt;&gt; @@ -17,6 +17,7 @@</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;   #include &lt;asm/cputype.h&gt;</span>
<span class="quote">&gt;&gt;   #include &lt;asm/smp_plat.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;asm/tlbflush.h&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;   /* Macros for consistency checks of the GICC subtable of MADT */</span>
<span class="quote">&gt;&gt;   #define ACPI_MADT_GICC_LENGTH \</span>
<span class="quote">&gt;&gt; @@ -94,6 +95,10 @@ static inline const char *acpi_get_enable_method(int</span>
<span class="quote">&gt;&gt; cpu)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;   #ifdef        CONFIG_ACPI_APEI</span>
<span class="quote">&gt;&gt;   pgprot_t arch_apei_get_mem_attribute(phys_addr_t addr);</span>
<span class="quote">&gt;&gt; +static inline void arch_apei_flush_tlb_one(unsigned long addr)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +       flush_tlb_kernel_range(addr, addr + PAGE_SIZE);</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt;   #endif</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;   #endif /*_ASM_ACPI_H*/</span>
<span class="quote">&gt;&gt; diff --git a/drivers/acpi/apei/hest.c b/drivers/acpi/apei/hest.c</span>
<span class="quote">&gt;&gt; index 20b3fcf..715c58b 100644</span>
<span class="quote">&gt;&gt; --- a/drivers/acpi/apei/hest.c</span>
<span class="quote">&gt;&gt; +++ b/drivers/acpi/apei/hest.c</span>
<span class="quote">&gt;&gt; @@ -117,15 +117,27 @@ int apei_hest_parse(apei_hest_func_t func, void</span>
<span class="quote">&gt;&gt; *data)</span>
<span class="quote">&gt;&gt;   }</span>
<span class="quote">&gt;&gt;   EXPORT_SYMBOL_GPL(apei_hest_parse);</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +#if defined(__i386__) || defined(__x86_64__)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Would it be better if define a symbol like :</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; HAVE_ARCH_APEI_CMCFF for x86 and wrap it around that ?</span>

I think that is a brilliant idea!
By this way , we can avoid to use  &quot;defined(__i386__) ||
defined(__x86_64__)&quot; which is not recommended in Linux kernel.

Thanks for your suggestion.

I thinks maybe we can name this as HAVE_ACPI_APEI_HEST_IA32 for or x86
and wrap all hest_ia_init relevant code.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt;   /*</span>
<span class="quote">&gt;&gt;    * Check if firmware advertises firmware first mode. We need FF bit to</span>
<span class="quote">&gt;&gt; be set</span>
<span class="quote">&gt;&gt;    * along with a set of MC banks which work in FF mode.</span>
<span class="quote">&gt;&gt;    */</span>
<span class="quote">&gt;&gt;   static int __init hest_parse_cmc(struct acpi_hest_header *hest_hdr, void</span>
<span class="quote">&gt;&gt; *data)</span>
<span class="quote">&gt;&gt;   {</span>
<span class="quote">&gt;&gt; -       return arch_apei_enable_cmcff(hest_hdr, data);</span>
<span class="quote">&gt;&gt; +       if (!acpi_disable_cmcff)</span>
<span class="quote">&gt;&gt; +               return !arch_apei_enable_cmcff(hest_hdr, data);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       return 0;</span>
<span class="quote">&gt;&gt;   }</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +static inline int __init hest_ia_init(void)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +       return apei_hest_parse(hest_parse_cmc, NULL);</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +#else</span>
<span class="quote">&gt;&gt; +static inline int __init hest_ia_init(void) { return 0; }</span>
<span class="quote">&gt;&gt; +#endif</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Cheers</span>
<span class="quote">&gt; Suzuki</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131991">fu.wei@linaro.org</a> - Dec. 9, 2015, 3:25 a.m.</div>
<pre class="content">
Hi Lorenzo,

On 8 December 2015 at 22:07, Lorenzo Pieralisi
&lt;lorenzo.pieralisi@arm.com&gt; wrote:
<span class="quote">&gt; On Tue, Dec 08, 2015 at 09:08:24PM +0800, Fu Wei wrote:</span>
<span class="quote">&gt;&gt; Hi Lorenzo,</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On 8 December 2015 at 20:52, Hanjun Guo &lt;hanjun.guo@linaro.org&gt; wrote:</span>
<span class="quote">&gt;&gt; &gt; Hi Lorenzo,</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; On 12/08/2015 08:34 PM, Lorenzo Pieralisi wrote:</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; On Tue, Dec 08, 2015 at 03:03:03PM +0800, fu.wei@linaro.org wrote:</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; From: Tomasz Nowicki &lt;tomasz.nowicki@linaro.org&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; [...]</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; +#if defined(__i386__) || defined(__x86_64__)</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;   /*</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;    * Check if firmware advertises firmware first mode. We need FF bit to</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; be set</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;    * along with a set of MC banks which work in FF mode.</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;    */</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;   static int __init hest_parse_cmc(struct acpi_hest_header *hest_hdr,</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; void *data)</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;   {</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; -       return arch_apei_enable_cmcff(hest_hdr, data);</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; +       if (!acpi_disable_cmcff)</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; Why do not you define the flag above in this file (move it out of x86 -</span>
<span class="quote">&gt;&gt; &gt;&gt; that&#39;s what I was aiming at in my previous reply) and remove this</span>
<span class="quote">&gt;&gt; &gt;&gt; ifdeffery</span>
<span class="quote">&gt;&gt; &gt;&gt; altogether (First firmware handling could apply to arm64 too according to</span>
<span class="quote">&gt;&gt; &gt;&gt; specs and ACPI on arm64 guidelines) ?</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; If I understand it correctly, CMC (Corrected Machine Check) is for IA32</span>
<span class="quote">&gt;&gt; &gt; only, see section 18.3.2.1 IA-32 Architecture Machine Check Exception</span>
<span class="quote">&gt;&gt; &gt; in ACPI 6.0. for ARM64, we can use other type of error source for</span>
<span class="quote">&gt;&gt; &gt; firmware first handling, such as Generic Hardware Error Source, did</span>
<span class="quote">&gt;&gt; &gt; I miss something?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; yes, that is why I try to use &quot;#if defined(__i386__) ||</span>
<span class="quote">&gt;&gt; defined(__x86_64__)&quot; instead of moving acpi_disable_cmcff out of x86</span>
<span class="quote">&gt;&gt; code to here.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; And I thinks we also can do &quot;arch_apei_enable_cmcff&quot; --&gt;</span>
<span class="quote">&gt;&gt; &quot;apei_enable_ia_cmcff&quot; because that is IA32 only.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Please correct me if I misunderstand something.  Thanks :-)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; No you are right, I was confused by the arch_apei_enable_cmcff __weak</span>
<span class="quote">&gt; function declaration, I am not sure that makes much sense, as you say.</span>
<span class="quote">&gt;</span>

Thanks :-)
<span class="quote">

&gt; Side note: I wonder if there is a way to make the TLB flushing API common</span>
<span class="quote">&gt; across architectures therefore avoiding this arch_apei_flush_tlb* churn.</span>

yes, make sense, I will think about this today , thanks for your suggestion.
<span class="quote">
&gt;</span>
<span class="quote">&gt; Thanks,</span>
<span class="quote">&gt; Lorenzo</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; Great thanks for your feedback :-)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; Thanks</span>
<span class="quote">&gt;&gt; &gt; Hanjun</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; --</span>
<span class="quote">&gt;&gt; Best regards,</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Fu Wei</span>
<span class="quote">&gt;&gt; Software Engineer</span>
<span class="quote">&gt;&gt; Red Hat Software (Beijing) Co.,Ltd.Shanghai Branch</span>
<span class="quote">&gt;&gt; Ph: +86 21 61221326(direct)</span>
<span class="quote">&gt;&gt; Ph: +86 186 2020 4684 (mobile)</span>
<span class="quote">&gt;&gt; Room 1512, Regus One Corporate Avenue,Level 15,</span>
<span class="quote">&gt;&gt; One Corporate Avenue,222 Hubin Road,Huangpu District,</span>
<span class="quote">&gt;&gt; Shanghai,China 200021</span>
<span class="quote">&gt;&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131991">fu.wei@linaro.org</a> - Dec. 10, 2015, 2:02 a.m.</div>
<pre class="content">
Hi Lorenzo,

On 9 December 2015 at 11:25, Fu Wei &lt;fu.wei@linaro.org&gt; wrote:
<span class="quote">&gt; Hi Lorenzo,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; On 8 December 2015 at 22:07, Lorenzo Pieralisi</span>
<span class="quote">&gt; &lt;lorenzo.pieralisi@arm.com&gt; wrote:</span>
<span class="quote">&gt;&gt; On Tue, Dec 08, 2015 at 09:08:24PM +0800, Fu Wei wrote:</span>
<span class="quote">&gt;&gt;&gt; Hi Lorenzo,</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; On 8 December 2015 at 20:52, Hanjun Guo &lt;hanjun.guo@linaro.org&gt; wrote:</span>
<span class="quote">&gt;&gt;&gt; &gt; Hi Lorenzo,</span>
<span class="quote">&gt;&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt;&gt; &gt; On 12/08/2015 08:34 PM, Lorenzo Pieralisi wrote:</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt; On Tue, Dec 08, 2015 at 03:03:03PM +0800, fu.wei@linaro.org wrote:</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt;&gt; From: Tomasz Nowicki &lt;tomasz.nowicki@linaro.org&gt;</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt; [...]</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt;&gt; +#if defined(__i386__) || defined(__x86_64__)</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt;&gt;   /*</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt;&gt;    * Check if firmware advertises firmware first mode. We need FF bit to</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt;&gt; be set</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt;&gt;    * along with a set of MC banks which work in FF mode.</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt;&gt;    */</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt;&gt;   static int __init hest_parse_cmc(struct acpi_hest_header *hest_hdr,</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt;&gt; void *data)</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt;&gt;   {</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt;&gt; -       return arch_apei_enable_cmcff(hest_hdr, data);</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt;&gt; +       if (!acpi_disable_cmcff)</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt; Why do not you define the flag above in this file (move it out of x86 -</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt; that&#39;s what I was aiming at in my previous reply) and remove this</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt; ifdeffery</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt; altogether (First firmware handling could apply to arm64 too according to</span>
<span class="quote">&gt;&gt;&gt; &gt;&gt; specs and ACPI on arm64 guidelines) ?</span>
<span class="quote">&gt;&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt;&gt; &gt; If I understand it correctly, CMC (Corrected Machine Check) is for IA32</span>
<span class="quote">&gt;&gt;&gt; &gt; only, see section 18.3.2.1 IA-32 Architecture Machine Check Exception</span>
<span class="quote">&gt;&gt;&gt; &gt; in ACPI 6.0. for ARM64, we can use other type of error source for</span>
<span class="quote">&gt;&gt;&gt; &gt; firmware first handling, such as Generic Hardware Error Source, did</span>
<span class="quote">&gt;&gt;&gt; &gt; I miss something?</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; yes, that is why I try to use &quot;#if defined(__i386__) ||</span>
<span class="quote">&gt;&gt;&gt; defined(__x86_64__)&quot; instead of moving acpi_disable_cmcff out of x86</span>
<span class="quote">&gt;&gt;&gt; code to here.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; And I thinks we also can do &quot;arch_apei_enable_cmcff&quot; --&gt;</span>
<span class="quote">&gt;&gt;&gt; &quot;apei_enable_ia_cmcff&quot; because that is IA32 only.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Please correct me if I misunderstand something.  Thanks :-)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; No you are right, I was confused by the arch_apei_enable_cmcff __weak</span>
<span class="quote">&gt;&gt; function declaration, I am not sure that makes much sense, as you say.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Thanks :-)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; Side note: I wonder if there is a way to make the TLB flushing API common</span>
<span class="quote">&gt;&gt; across architectures therefore avoiding this arch_apei_flush_tlb* churn.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; yes, make sense, I will think about this today , thanks for your suggestion.</span>

I do some investigation on this &quot;tlb&quot; problem(actually not just tlb,
but also &quot;get_mem_attribute&quot;) today,
I think we need to
(1)have a common API in tlbflush.h (at least for flushing one page)
across architectures(at least in x86 and arm64)
(2)use this API in drivers/acpi/apei/gest.c instead of arch_apei_flush_tlb_one
(3)delete the old function from arm64 and x86

So maybe we can have the another patchset to solve this problem, make
this patch just enable APEI for arm64 first. :-)
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Thanks,</span>
<span class="quote">&gt;&gt; Lorenzo</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Great thanks for your feedback :-)</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt;&gt; &gt; Thanks</span>
<span class="quote">&gt;&gt;&gt; &gt; Hanjun</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; --</span>
<span class="quote">&gt;&gt;&gt; Best regards,</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Fu Wei</span>
<span class="quote">&gt;&gt;&gt; Software Engineer</span>
<span class="quote">&gt;&gt;&gt; Red Hat Software (Beijing) Co.,Ltd.Shanghai Branch</span>
<span class="quote">&gt;&gt;&gt; Ph: +86 21 61221326(direct)</span>
<span class="quote">&gt;&gt;&gt; Ph: +86 186 2020 4684 (mobile)</span>
<span class="quote">&gt;&gt;&gt; Room 1512, Regus One Corporate Avenue,Level 15,</span>
<span class="quote">&gt;&gt;&gt; One Corporate Avenue,222 Hubin Road,Huangpu District,</span>
<span class="quote">&gt;&gt;&gt; Shanghai,China 200021</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; Best regards,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Fu Wei</span>
<span class="quote">&gt; Software Engineer</span>
<span class="quote">&gt; Red Hat Software (Beijing) Co.,Ltd.Shanghai Branch</span>
<span class="quote">&gt; Ph: +86 21 61221326(direct)</span>
<span class="quote">&gt; Ph: +86 186 2020 4684 (mobile)</span>
<span class="quote">&gt; Room 1512, Regus One Corporate Avenue,Level 15,</span>
<span class="quote">&gt; One Corporate Avenue,222 Hubin Road,Huangpu District,</span>
<span class="quote">&gt; Shanghai,China 200021</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7096">Will Deacon</a> - Dec. 10, 2015, 11:01 a.m.</div>
<pre class="content">
[adding Boris, as he might know how this works]

On Thu, Dec 10, 2015 at 10:02:39AM +0800, Fu Wei wrote:
<span class="quote">&gt; On 9 December 2015 at 11:25, Fu Wei &lt;fu.wei@linaro.org&gt; wrote:</span>
<span class="quote">&gt; &gt; On 8 December 2015 at 22:07, Lorenzo Pieralisi</span>
<span class="quote">&gt; &gt; &lt;lorenzo.pieralisi@arm.com&gt; wrote:</span>
<span class="quote">&gt; &gt;&gt; Side note: I wonder if there is a way to make the TLB flushing API common</span>
<span class="quote">&gt; &gt;&gt; across architectures therefore avoiding this arch_apei_flush_tlb* churn.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; yes, make sense, I will think about this today , thanks for your suggestion.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I do some investigation on this &quot;tlb&quot; problem(actually not just tlb,</span>
<span class="quote">&gt; but also &quot;get_mem_attribute&quot;) today,</span>
<span class="quote">&gt; I think we need to</span>
<span class="quote">&gt; (1)have a common API in tlbflush.h (at least for flushing one page)</span>
<span class="quote">&gt; across architectures(at least in x86 and arm64)</span>

It&#39;s not about flushing one page, flush_tlb_kernel_range (which is called
by unmap_kernel_range) already takes care of that. The problem is that
the unmap is called from irq/nmi context, so the IPIs required for
broadcasting the TLB maintenance on x86 cannot be safely executed.

So, if you&#39;re going to introduce anything in the way of TLB API, then it
should be a generic form of the local_flush_tlb_* functions that we already
have on ARM, imo. That sounds like a lot of work for this one problem.

You could call flush_tlb_page with a fake vma/mm, but it&#39;s pretty ugly.
<span class="quote">
&gt; (2)use this API in drivers/acpi/apei/gest.c instead of arch_apei_flush_tlb_one</span>
<span class="quote">&gt; (3)delete the old function from arm64 and x86</span>

Ideally, I think the ghes code would just use unmap_kernel_range unless
the architecture specifically says that doesn&#39;t work in irq context. In
that case, we don&#39;t need to implement the arch_apei_flush_tlb_one callback
on arm64.

One thing I don&#39;t fully grok about the code: since the page is mapped
using ioremap_page_range, doesn&#39;t that allow other CPUs to speculatively
fill their TLB with entries corresponding to the page mapped by the IRQ
handler on another core? If the core with the speculative entries then
takes an APEI exception, what guarantees do we have that it&#39;s looking at
the right page? I think, for x86, we need a local invalidation on map,
too.

Will
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7500">Borislav Petkov</a> - Dec. 14, 2015, 10:46 a.m.</div>
<pre class="content">
On Tue, Dec 08, 2015 at 03:03:03PM +0800, fu.wei@linaro.org wrote:
<span class="quote">&gt; From: Tomasz Nowicki &lt;tomasz.nowicki@linaro.org&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This commit provides APEI arch-specific bits for aarch64</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Meanwhile, add a new subfunction &quot;hest_ia_init&quot; for</span>
<span class="quote">&gt; &quot;acpi_disable_cmcff&quot; which is used by IA-32 Architecture</span>
<span class="quote">&gt; Corrected Machine Check (CMC).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Tomasz Nowicki &lt;tomasz.nowicki@linaro.org&gt;</span>
<span class="quote">&gt; Tested-by: Jonathan (Zhixiong) Zhang &lt;zjzhang@codeaurora.org&gt;</span>
<span class="quote">&gt; Signed-off-by: Fu Wei &lt;fu.wei@linaro.org&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt; Changelog:</span>
<span class="quote">&gt; v4: Rebase to latest kernel version(4.4-rc4).</span>
<span class="quote">&gt;     Move arch_apei_flush_tlb_one into header file as a inline function</span>
<span class="quote">&gt;     Add a new subfunction &quot;hest_ia_init&quot; for &quot;acpi_disable_cmcff&quot;.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; v3: https://lkml.org/lkml/2015/12/3/521</span>
<span class="quote">&gt;     Remove &quot;acpi_disable_cmcff&quot; from arm64 code,</span>
<span class="quote">&gt;     and wrap it in hest.c by &quot;#if defined(__i386__) || defined(__x86_64__)&quot;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; v2: https://lkml.org/lkml/2015/12/2/432</span>
<span class="quote">&gt;     Rebase to latest kernel version(4.4-rc3).</span>
<span class="quote">&gt;     Move arch_apei_flush_tlb_one() to arch/arm64/kernel/acpi.c</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; v1: https://lkml.org/lkml/2015/8/14/199</span>
<span class="quote">&gt;     Move arch_apei_flush_tlb_one() to arch/arm64/include/asm/apci.h.</span>
<span class="quote">&gt;     Delete arch/arm64/kernel/apei.c.</span>
<span class="quote">&gt;     Add &quot;#ifdef CONFIG_ACPI_APEI&quot; for &quot;acpi_disable_cmcff&quot;.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;  arch/arm64/Kconfig            |  1 +</span>
<span class="quote">&gt;  arch/arm64/include/asm/acpi.h |  5 +++++</span>
<span class="quote">&gt;  drivers/acpi/apei/hest.c      | 19 ++++++++++++++++---</span>
<span class="quote">&gt;  3 files changed, 22 insertions(+), 3 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig</span>
<span class="quote">&gt; index 871f217..58c8992 100644</span>
<span class="quote">&gt; --- a/arch/arm64/Kconfig</span>
<span class="quote">&gt; +++ b/arch/arm64/Kconfig</span>
<span class="quote">&gt; @@ -3,6 +3,7 @@ config ARM64</span>
<span class="quote">&gt;  	select ACPI_CCA_REQUIRED if ACPI</span>
<span class="quote">&gt;  	select ACPI_GENERIC_GSI if ACPI</span>
<span class="quote">&gt;  	select ACPI_REDUCED_HARDWARE_ONLY if ACPI</span>
<span class="quote">&gt; +	select HAVE_ACPI_APEI if ACPI</span>
<span class="quote">&gt;  	select ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE</span>
<span class="quote">&gt;  	select ARCH_HAS_ELF_RANDOMIZE</span>
<span class="quote">&gt;  	select ARCH_HAS_GCOV_PROFILE_ALL</span>
<span class="quote">&gt; diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h</span>
<span class="quote">&gt; index caafd63..31d3d9a 100644</span>
<span class="quote">&gt; --- a/arch/arm64/include/asm/acpi.h</span>
<span class="quote">&gt; +++ b/arch/arm64/include/asm/acpi.h</span>
<span class="quote">&gt; @@ -17,6 +17,7 @@</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #include &lt;asm/cputype.h&gt;</span>
<span class="quote">&gt;  #include &lt;asm/smp_plat.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/tlbflush.h&gt;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  /* Macros for consistency checks of the GICC subtable of MADT */</span>
<span class="quote">&gt;  #define ACPI_MADT_GICC_LENGTH	\</span>
<span class="quote">&gt; @@ -94,6 +95,10 @@ static inline const char *acpi_get_enable_method(int cpu)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #ifdef	CONFIG_ACPI_APEI</span>
<span class="quote">&gt;  pgprot_t arch_apei_get_mem_attribute(phys_addr_t addr);</span>
<span class="quote">&gt; +static inline void arch_apei_flush_tlb_one(unsigned long addr)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	flush_tlb_kernel_range(addr, addr + PAGE_SIZE);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #endif /*_ASM_ACPI_H*/</span>
<span class="quote">&gt; diff --git a/drivers/acpi/apei/hest.c b/drivers/acpi/apei/hest.c</span>
<span class="quote">&gt; index 20b3fcf..715c58b 100644</span>
<span class="quote">&gt; --- a/drivers/acpi/apei/hest.c</span>
<span class="quote">&gt; +++ b/drivers/acpi/apei/hest.c</span>
<span class="quote">&gt; @@ -117,15 +117,27 @@ int apei_hest_parse(apei_hest_func_t func, void *data)</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  EXPORT_SYMBOL_GPL(apei_hest_parse);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +#if defined(__i386__) || defined(__x86_64__)</span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt;   * Check if firmware advertises firmware first mode. We need FF bit to be set</span>
<span class="quote">&gt;   * along with a set of MC banks which work in FF mode.</span>
<span class="quote">&gt;   */</span>
<span class="quote">&gt;  static int __init hest_parse_cmc(struct acpi_hest_header *hest_hdr, void *data)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; -	return arch_apei_enable_cmcff(hest_hdr, data);</span>
<span class="quote">&gt; +	if (!acpi_disable_cmcff)</span>
<span class="quote">&gt; +		return !arch_apei_enable_cmcff(hest_hdr, data);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>

So the proper way to do this is to leave the code still do this check
(in arch/x86/kernel/acpi/apei.c:arch_apei_enable_cmcff()):

	if (hest_hdr-&gt;type != ACPI_HEST_TYPE_IA32_CORRECTED_CHECK)
		return 0;

which should JustWork(tm) on ARM too because if ARM doesn&#39;t support IA32
CMCI, then that header type should be different and the function will
return 0.

For that to work, though, the check should be moved to a generic place,
like drivers/acpi/apei/hest.c:hest_parse_cmc() for example.

No crazy ifdeffery and no redundant Kconfig symbols please.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=57321">Borislav Petkov</a> - Dec. 14, 2015, 11:20 a.m.</div>
<pre class="content">
On Thu, Dec 10, 2015 at 11:01:35AM +0000, Will Deacon wrote:
<span class="quote">&gt; [adding Boris, as he might know how this works]</span>

Gee, thanks Will, now you&#39;re making me look at this too :-)
<span class="quote">
&gt; It&#39;s not about flushing one page, flush_tlb_kernel_range (which is called</span>
<span class="quote">&gt; by unmap_kernel_range) already takes care of that. The problem is that</span>
<span class="quote">&gt; the unmap is called from irq/nmi context, so the IPIs required for</span>
<span class="quote">&gt; broadcasting the TLB maintenance on x86 cannot be safely executed.</span>

Hmm, if you&#39;re talking about ghes_iounmap_nmi() and ghes_iounmap_irq()
which are the two callers of unmap_kernel_range_noflush(), that last one
is calling vunmap_page_range() which is fiddling with the page table.
And I don&#39;t see TLB flushing IPIs there.

If you mean arch_apei_flush_tlb_one(), that&#39;s INVLPG on x86 so also no
IPI.

What am I missing?
<span class="quote">
&gt; Ideally, I think the ghes code would just use unmap_kernel_range unless</span>
<span class="quote">&gt; the architecture specifically says that doesn&#39;t work in irq context. In</span>
<span class="quote">&gt; that case, we don&#39;t need to implement the arch_apei_flush_tlb_one callback</span>
<span class="quote">&gt; on arm64.</span>

Well, what bothers me with using
unmap_kernel_range()/vunmap_page_range() is that if a GHES IRQ/NMI
happens while something is executing those, the NMI will interrupt
whatever&#39;s happening and it will possibly corrupt the pagetable, IMHO.

Michal, Vlasta, can you please take a look?

More specifically, those ghes_iounmap_nmi/ghes_iounmap_irq calls to
unmap_kernel_range_noflush() happening in NMI/IRQ context.
<span class="quote">
&gt; One thing I don&#39;t fully grok about the code: since the page is mapped</span>
<span class="quote">&gt; using ioremap_page_range, doesn&#39;t that allow other CPUs to speculatively</span>
<span class="quote">&gt; fill their TLB with entries corresponding to the page mapped by the IRQ</span>
<span class="quote">&gt; handler on another core? If the core with the speculative entries then</span>
<span class="quote">&gt; takes an APEI exception, what guarantees do we have that it&#39;s looking at</span>
<span class="quote">&gt; the right page? I think, for x86, we need a local invalidation on map,</span>
<span class="quote">&gt; too.</span>

You&#39;re looking at ghes_copy_tofrom_phys(), right? That&#39;s grabbing
spinlocks in IRQ/NMI context and doing the iounmap a bit later, below
on the same core. I mean, I don&#39;t see us landing on another core in
between, we&#39;re non-preemptible...

Or do you mean something else?
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7096">Will Deacon</a> - Dec. 14, 2015, 11:46 a.m.</div>
<pre class="content">
On Mon, Dec 14, 2015 at 12:20:04PM +0100, Borislav Petkov wrote:
<span class="quote">&gt; On Thu, Dec 10, 2015 at 11:01:35AM +0000, Will Deacon wrote:</span>
<span class="quote">&gt; &gt; [adding Boris, as he might know how this works]</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Gee, thanks Will, now you&#39;re making me look at this too :-)</span>

Hey, I was having way too much fun by myself, so figured you&#39;d like to
be involved as well!
<span class="quote">
&gt; &gt; It&#39;s not about flushing one page, flush_tlb_kernel_range (which is called</span>
<span class="quote">&gt; &gt; by unmap_kernel_range) already takes care of that. The problem is that</span>
<span class="quote">&gt; &gt; the unmap is called from irq/nmi context, so the IPIs required for</span>
<span class="quote">&gt; &gt; broadcasting the TLB maintenance on x86 cannot be safely executed.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hmm, if you&#39;re talking about ghes_iounmap_nmi() and ghes_iounmap_irq()</span>
<span class="quote">&gt; which are the two callers of unmap_kernel_range_noflush(), that last one</span>
<span class="quote">&gt; is calling vunmap_page_range() which is fiddling with the page table.</span>
<span class="quote">&gt; And I don&#39;t see TLB flushing IPIs there.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; If you mean arch_apei_flush_tlb_one(), that&#39;s INVLPG on x86 so also no</span>
<span class="quote">&gt; IPI.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; What am I missing?</span>

We&#39;re in violent agreement. I&#39;m just saying that&#39;s *why*
arch_apei_flush_tlb_one exists, as opposed to calling unmap_kernel_range
in the driver (which will attempt IPIs). On arm64, unmap_kernel_range
will actually work correctly, since we don&#39;t need IPIs to broadcast TLB
maintenance.

The (incorrect) premise earlier in the thread was that
arch_apei_flush_tlb_one exists because there&#39;s no portable API for
flushing a single page, but that&#39;s simply not true.
<span class="quote">
&gt; &gt; Ideally, I think the ghes code would just use unmap_kernel_range unless</span>
<span class="quote">&gt; &gt; the architecture specifically says that doesn&#39;t work in irq context. In</span>
<span class="quote">&gt; &gt; that case, we don&#39;t need to implement the arch_apei_flush_tlb_one callback</span>
<span class="quote">&gt; &gt; on arm64.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Well, what bothers me with using</span>
<span class="quote">&gt; unmap_kernel_range()/vunmap_page_range() is that if a GHES IRQ/NMI</span>
<span class="quote">&gt; happens while something is executing those, the NMI will interrupt</span>
<span class="quote">&gt; whatever&#39;s happening and it will possibly corrupt the pagetable, IMHO.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Michal, Vlasta, can you please take a look?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; More specifically, those ghes_iounmap_nmi/ghes_iounmap_irq calls to</span>
<span class="quote">&gt; unmap_kernel_range_noflush() happening in NMI/IRQ context.</span>

Yikes, I&#39;d not even thought about that. Perhaps its all serialised
somehow, but I have no idea.
<span class="quote">
&gt; &gt; One thing I don&#39;t fully grok about the code: since the page is mapped</span>
<span class="quote">&gt; &gt; using ioremap_page_range, doesn&#39;t that allow other CPUs to speculatively</span>
<span class="quote">&gt; &gt; fill their TLB with entries corresponding to the page mapped by the IRQ</span>
<span class="quote">&gt; &gt; handler on another core? If the core with the speculative entries then</span>
<span class="quote">&gt; &gt; takes an APEI exception, what guarantees do we have that it&#39;s looking at</span>
<span class="quote">&gt; &gt; the right page? I think, for x86, we need a local invalidation on map,</span>
<span class="quote">&gt; &gt; too.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; You&#39;re looking at ghes_copy_tofrom_phys(), right? That&#39;s grabbing</span>
<span class="quote">&gt; spinlocks in IRQ/NMI context and doing the iounmap a bit later, below</span>
<span class="quote">&gt; on the same core. I mean, I don&#39;t see us landing on another core in</span>
<span class="quote">&gt; between, we&#39;re non-preemptible...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Or do you mean something else?</span>

Right, imagine the following sequence of events:

 1. CPU x takes a GHES IRQ
 2. CPU x then maps the buffer a page at a time in ghes_copy_tofrom_phys.
    After each unmap, it performs a local TLBI. Let&#39;s say that it has
    the final page of the buffer mapped when...
 3. ... CPU y is meanwhile happily executing some other kernel code.
 4. CPU y&#39;s page table walker speculatively fills the TLB with a translation
    for the last buffer page that CPU x has mapped (because its just been
    mapped with ioremap_page_range and is in the kernel page table).
 5. CPU x unmaps the last page, performs a *local* TLBI, handles the
    event and returns from the exception
 6. CPU y takes a GHES IRQ
 7. CPU y then maps the first buffer page at the same virtual address
    that CPU x used to map the last buffer page
 8. CPU y accesses the page, hits the stale TLB entry and gets junk

which I think means you need to perform local TLB invalidation on map
as well as unmap.

Is there some reason this can&#39;t happen on x86? It sounds plausible on
arm64 if we were to use local invalidation.

Will
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=57321">Borislav Petkov</a> - Dec. 14, 2015, 12:39 p.m.</div>
<pre class="content">
On Mon, Dec 14, 2015 at 11:46:59AM +0000, Will Deacon wrote:
<span class="quote">&gt; We&#39;re in violent agreement. I&#39;m just saying that&#39;s *why*</span>
<span class="quote">&gt; arch_apei_flush_tlb_one exists, as opposed to calling unmap_kernel_range</span>
<span class="quote">&gt; in the driver (which will attempt IPIs). On arm64, unmap_kernel_range</span>
<span class="quote">&gt; will actually work correctly, since we don&#39;t need IPIs to broadcast TLB</span>
<span class="quote">&gt; maintenance.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The (incorrect) premise earlier in the thread was that</span>
<span class="quote">&gt; arch_apei_flush_tlb_one exists because there&#39;s no portable API for</span>
<span class="quote">&gt; flushing a single page, but that&#39;s simply not true.</span>

Right.
<span class="quote">
&gt; Yikes, I&#39;d not even thought about that. Perhaps its all serialised</span>
<span class="quote">&gt; somehow, but I have no idea.</span>

Yeah, didn&#39;t see any serialization there...
<span class="quote">
&gt; Right, imagine the following sequence of events:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;  1. CPU x takes a GHES IRQ</span>
<span class="quote">&gt;  2. CPU x then maps the buffer a page at a time in ghes_copy_tofrom_phys.</span>
<span class="quote">&gt;     After each unmap, it performs a local TLBI. Let&#39;s say that it has</span>
<span class="quote">&gt;     the final page of the buffer mapped when...</span>
<span class="quote">&gt;  3. ... CPU y is meanwhile happily executing some other kernel code.</span>
<span class="quote">&gt;  4. CPU y&#39;s page table walker speculatively fills the TLB with a translation</span>
<span class="quote">&gt;     for the last buffer page that CPU x has mapped (because its just been</span>
<span class="quote">&gt;     mapped with ioremap_page_range and is in the kernel page table).</span>
<span class="quote">&gt;  5. CPU x unmaps the last page, performs a *local* TLBI, handles the</span>
<span class="quote">&gt;     event and returns from the exception</span>
<span class="quote">&gt;  6. CPU y takes a GHES IRQ</span>
<span class="quote">&gt;  7. CPU y then maps the first buffer page at the same virtual address</span>
<span class="quote">&gt;     that CPU x used to map the last buffer page</span>
<span class="quote">&gt;  8. CPU y accesses the page, hits the stale TLB entry and gets junk</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; which I think means you need to perform local TLB invalidation on map</span>
<span class="quote">&gt; as well as unmap.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Is there some reason this can&#39;t happen on x86? It sounds plausible on</span>
<span class="quote">&gt; arm64 if we were to use local invalidation.</span>

Ha, thanks for the detailed example, I see it now!

And I too don&#39;t see a reason why that can&#39;t happen. And the GHES
IRQ is a GSI, which has &quot;global&quot; in the name but I don&#39;t think that
means it interrupts the whole system like an NMI does. Especially
if it is registered/handled like a normal irq: acpi_gsi_to_irq() ..
request_irq()...

Adding Tony.

If anything, we probably should be doing something with irq_work at the
end of ghes_copy_tofrom_phys() so that the invalidation of any possible
speculative mappings happens before we return from the GHES IRQ.

Hmm, currently I&#39;m not even clear whether this&#39;ll work: we would
theoretically need to send IPIs from IRQ context, at the end of the GHES
IRQ...

Thanks.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig</span>
<span class="p_header">index 871f217..58c8992 100644</span>
<span class="p_header">--- a/arch/arm64/Kconfig</span>
<span class="p_header">+++ b/arch/arm64/Kconfig</span>
<span class="p_chunk">@@ -3,6 +3,7 @@</span> <span class="p_context"> config ARM64</span>
 	select ACPI_CCA_REQUIRED if ACPI
 	select ACPI_GENERIC_GSI if ACPI
 	select ACPI_REDUCED_HARDWARE_ONLY if ACPI
<span class="p_add">+	select HAVE_ACPI_APEI if ACPI</span>
 	select ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE
 	select ARCH_HAS_ELF_RANDOMIZE
 	select ARCH_HAS_GCOV_PROFILE_ALL
<span class="p_header">diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h</span>
<span class="p_header">index caafd63..31d3d9a 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/acpi.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/acpi.h</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/cputype.h&gt;
 #include &lt;asm/smp_plat.h&gt;
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
 
 /* Macros for consistency checks of the GICC subtable of MADT */
 #define ACPI_MADT_GICC_LENGTH	\
<span class="p_chunk">@@ -94,6 +95,10 @@</span> <span class="p_context"> static inline const char *acpi_get_enable_method(int cpu)</span>
 
 #ifdef	CONFIG_ACPI_APEI
 pgprot_t arch_apei_get_mem_attribute(phys_addr_t addr);
<span class="p_add">+static inline void arch_apei_flush_tlb_one(unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	flush_tlb_kernel_range(addr, addr + PAGE_SIZE);</span>
<span class="p_add">+}</span>
 #endif
 
 #endif /*_ASM_ACPI_H*/
<span class="p_header">diff --git a/drivers/acpi/apei/hest.c b/drivers/acpi/apei/hest.c</span>
<span class="p_header">index 20b3fcf..715c58b 100644</span>
<span class="p_header">--- a/drivers/acpi/apei/hest.c</span>
<span class="p_header">+++ b/drivers/acpi/apei/hest.c</span>
<span class="p_chunk">@@ -117,15 +117,27 @@</span> <span class="p_context"> int apei_hest_parse(apei_hest_func_t func, void *data)</span>
 }
 EXPORT_SYMBOL_GPL(apei_hest_parse);
 
<span class="p_add">+#if defined(__i386__) || defined(__x86_64__)</span>
 /*
  * Check if firmware advertises firmware first mode. We need FF bit to be set
  * along with a set of MC banks which work in FF mode.
  */
 static int __init hest_parse_cmc(struct acpi_hest_header *hest_hdr, void *data)
 {
<span class="p_del">-	return arch_apei_enable_cmcff(hest_hdr, data);</span>
<span class="p_add">+	if (!acpi_disable_cmcff)</span>
<span class="p_add">+		return !arch_apei_enable_cmcff(hest_hdr, data);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
<span class="p_add">+static inline int __init hest_ia_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return apei_hest_parse(hest_parse_cmc, NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+static inline int __init hest_ia_init(void) { return 0; }</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 struct ghes_arr {
 	struct platform_device **ghes_devs;
 	unsigned int count;
<span class="p_chunk">@@ -232,8 +244,9 @@</span> <span class="p_context"> void __init acpi_hest_init(void)</span>
 		goto err;
 	}
 
<span class="p_del">-	if (!acpi_disable_cmcff)</span>
<span class="p_del">-		apei_hest_parse(hest_parse_cmc, NULL);</span>
<span class="p_add">+	rc = hest_ia_init();</span>
<span class="p_add">+	if (rc)</span>
<span class="p_add">+		goto err;</span>
 
 	if (!ghes_disable) {
 		rc = apei_hest_parse(hest_parse_ghes_count, &amp;ghes_count);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



