
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.14.41 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.14.41</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 7, 2015, 11:10 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20150507231026.GB5156@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6361181/mbox/"
   >mbox</a>
|
   <a href="/patch/6361181/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6361181/">/patch/6361181/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 256C5BEEE1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  7 May 2015 23:11:11 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 760F4203B4
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  7 May 2015 23:11:04 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 34B962038F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  7 May 2015 23:10:57 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752030AbbEGXKl (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 7 May 2015 19:10:41 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:46085 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751846AbbEGXKb (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 7 May 2015 19:10:31 -0400
Received: from localhost (gob75-2-82-67-192-59.fbx.proxad.net [82.67.192.59])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 83C05AC1;
	Thu,  7 May 2015 23:10:28 +0000 (UTC)
Date: Fri, 8 May 2015 01:10:26 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 3.14.41
Message-ID: &lt;20150507231026.GB5156@kroah.com&gt;
References: &lt;20150507231020.GA5156@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20150507231020.GA5156@kroah.com&gt;
User-Agent: Mutt/1.5.23 (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - May 7, 2015, 11:10 p.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 070e0ebb9231..7a60d4a1301c 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 14
<span class="p_del">-SUBLEVEL = 40</span>
<span class="p_add">+SUBLEVEL = 41</span>
 EXTRAVERSION =
 NAME = Remembering Coco
 
<span class="p_header">diff --git a/arch/arm/boot/dts/dove.dtsi b/arch/arm/boot/dts/dove.dtsi</span>
<span class="p_header">index 187fd46b7b5e..355117cbbf4a 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/dove.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/dove.dtsi</span>
<span class="p_chunk">@@ -154,7 +154,7 @@</span> <span class="p_context"></span>
 
 			uart2: serial@12200 {
 				compatible = &quot;ns16550a&quot;;
<span class="p_del">-				reg = &lt;0x12000 0x100&gt;;</span>
<span class="p_add">+				reg = &lt;0x12200 0x100&gt;;</span>
 				reg-shift = &lt;2&gt;;
 				interrupts = &lt;9&gt;;
 				clocks = &lt;&amp;core_clk 0&gt;;
<span class="p_chunk">@@ -163,7 +163,7 @@</span> <span class="p_context"></span>
 
 			uart3: serial@12300 {
 				compatible = &quot;ns16550a&quot;;
<span class="p_del">-				reg = &lt;0x12100 0x100&gt;;</span>
<span class="p_add">+				reg = &lt;0x12300 0x100&gt;;</span>
 				reg-shift = &lt;2&gt;;
 				interrupts = &lt;10&gt;;
 				clocks = &lt;&amp;core_clk 0&gt;;
<span class="p_header">diff --git a/arch/arm/include/asm/elf.h b/arch/arm/include/asm/elf.h</span>
<span class="p_header">index f4b46d39b9cf..051b7269e639 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/elf.h</span>
<span class="p_chunk">@@ -114,7 +114,7 @@</span> <span class="p_context"> int dump_task_regs(struct task_struct *t, elf_gregset_t *elfregs);</span>
    the loader.  We need to make sure that it is out of the way of the program
    that it will &quot;exec&quot;, and that there is sufficient room for the brk.  */
 
<span class="p_del">-#define ELF_ET_DYN_BASE	(2 * TASK_SIZE / 3)</span>
<span class="p_add">+#define ELF_ET_DYN_BASE	(TASK_SIZE / 3 * 2)</span>
 
 /* When the program starts, a1 contains a pointer to a function to be 
    registered with atexit, as per the SVR4 ABI.  A value of 0 means we 
<span class="p_header">diff --git a/arch/arm/mach-s3c64xx/crag6410.h b/arch/arm/mach-s3c64xx/crag6410.h</span>
<span class="p_header">index 7bc66682687e..dcbe17f5e5f8 100644</span>
<span class="p_header">--- a/arch/arm/mach-s3c64xx/crag6410.h</span>
<span class="p_header">+++ b/arch/arm/mach-s3c64xx/crag6410.h</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"></span>
 #include &lt;mach/gpio-samsung.h&gt;
 
 #define GLENFARCLAS_PMIC_IRQ_BASE	IRQ_BOARD_START
<span class="p_add">+#define BANFF_PMIC_IRQ_BASE		(IRQ_BOARD_START + 64)</span>
 
 #define PCA935X_GPIO_BASE		GPIO_BOARD_START
 #define CODEC_GPIO_BASE			(GPIO_BOARD_START + 8)
<span class="p_header">diff --git a/arch/arm/mach-s3c64xx/mach-crag6410.c b/arch/arm/mach-s3c64xx/mach-crag6410.c</span>
<span class="p_header">index 3df3c372ee1f..66b95c466497 100644</span>
<span class="p_header">--- a/arch/arm/mach-s3c64xx/mach-crag6410.c</span>
<span class="p_header">+++ b/arch/arm/mach-s3c64xx/mach-crag6410.c</span>
<span class="p_chunk">@@ -555,6 +555,7 @@</span> <span class="p_context"> static struct wm831x_touch_pdata touch_pdata = {</span>
 
 static struct wm831x_pdata crag_pmic_pdata = {
 	.wm831x_num = 1,
<span class="p_add">+	.irq_base = BANFF_PMIC_IRQ_BASE,</span>
 	.gpio_base = BANFF_PMIC_GPIO_BASE,
 	.soft_shutdown = true,
 
<span class="p_header">diff --git a/arch/arm64/kernel/vdso/Makefile b/arch/arm64/kernel/vdso/Makefile</span>
<span class="p_header">index 6d20b7d162d8..a268a9af0c2d 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/vdso/Makefile</span>
<span class="p_header">+++ b/arch/arm64/kernel/vdso/Makefile</span>
<span class="p_chunk">@@ -43,7 +43,7 @@</span> <span class="p_context"> $(obj)/vdso-offsets.h: $(obj)/vdso.so.dbg FORCE</span>
 	$(call if_changed,vdsosym)
 
 # Assembly rules for the .S files
<span class="p_del">-$(obj-vdso): %.o: %.S</span>
<span class="p_add">+$(obj-vdso): %.o: %.S FORCE</span>
 	$(call if_changed_dep,vdsoas)
 
 # Actual build commands
<span class="p_header">diff --git a/arch/c6x/kernel/time.c b/arch/c6x/kernel/time.c</span>
<span class="p_header">index 356ee84cad95..04845aaf5985 100644</span>
<span class="p_header">--- a/arch/c6x/kernel/time.c</span>
<span class="p_header">+++ b/arch/c6x/kernel/time.c</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> u64 sched_clock(void)</span>
 	return (tsc * sched_clock_multiplier) &gt;&gt; SCHED_CLOCK_SHIFT;
 }
 
<span class="p_del">-void time_init(void)</span>
<span class="p_add">+void __init time_init(void)</span>
 {
 	u64 tmp = (u64)NSEC_PER_SEC &lt;&lt; SCHED_CLOCK_SHIFT;
 
<span class="p_header">diff --git a/arch/mips/include/asm/suspend.h b/arch/mips/include/asm/suspend.h</span>
deleted file mode 100644
<span class="p_header">index 3adac3b53d19..000000000000</span>
<span class="p_header">--- a/arch/mips/include/asm/suspend.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,7 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-#ifndef __ASM_SUSPEND_H</span>
<span class="p_del">-#define __ASM_SUSPEND_H</span>
<span class="p_del">-</span>
<span class="p_del">-/* References to section boundaries */</span>
<span class="p_del">-extern const void __nosave_begin, __nosave_end;</span>
<span class="p_del">-</span>
<span class="p_del">-#endif /* __ASM_SUSPEND_H */</span>
<span class="p_header">diff --git a/arch/mips/power/cpu.c b/arch/mips/power/cpu.c</span>
<span class="p_header">index 521e5963df05..2129e67723ff 100644</span>
<span class="p_header">--- a/arch/mips/power/cpu.c</span>
<span class="p_header">+++ b/arch/mips/power/cpu.c</span>
<span class="p_chunk">@@ -7,7 +7,7 @@</span> <span class="p_context"></span>
  * Author: Hu Hongbing &lt;huhb@lemote.com&gt;
  *	   Wu Zhangjin &lt;wuzhangjin@gmail.com&gt;
  */
<span class="p_del">-#include &lt;asm/suspend.h&gt;</span>
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 #include &lt;asm/fpu.h&gt;
 #include &lt;asm/dsp.h&gt;
 
<span class="p_header">diff --git a/arch/mips/power/hibernate.S b/arch/mips/power/hibernate.S</span>
<span class="p_header">index 32a7c828f073..e7567c8a9e79 100644</span>
<span class="p_header">--- a/arch/mips/power/hibernate.S</span>
<span class="p_header">+++ b/arch/mips/power/hibernate.S</span>
<span class="p_chunk">@@ -30,6 +30,8 @@</span> <span class="p_context"> LEAF(swsusp_arch_suspend)</span>
 END(swsusp_arch_suspend)
 
 LEAF(swsusp_arch_resume)
<span class="p_add">+	/* Avoid TLB mismatch during and after kernel resume */</span>
<span class="p_add">+	jal local_flush_tlb_all</span>
 	PTR_L t0, restore_pblist
 0:
 	PTR_L t1, PBE_ADDRESS(t0)   /* source */
<span class="p_chunk">@@ -43,7 +45,6 @@</span> <span class="p_context"> LEAF(swsusp_arch_resume)</span>
 	bne t1, t3, 1b
 	PTR_L t0, PBE_NEXT(t0)
 	bnez t0, 0b
<span class="p_del">-	jal local_flush_tlb_all /* Avoid TLB mismatch after kernel resume */</span>
 	PTR_LA t0, saved_regs
 	PTR_L ra, PT_R31(t0)
 	PTR_L sp, PT_R29(t0)
<span class="p_header">diff --git a/arch/powerpc/kernel/cacheinfo.c b/arch/powerpc/kernel/cacheinfo.c</span>
<span class="p_header">index 2912b8787aa4..3eb36cea324c 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/cacheinfo.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/cacheinfo.c</span>
<span class="p_chunk">@@ -61,12 +61,22 @@</span> <span class="p_context"> struct cache_type_info {</span>
 };
 
 /* These are used to index the cache_type_info array. */
<span class="p_del">-#define CACHE_TYPE_UNIFIED     0</span>
<span class="p_del">-#define CACHE_TYPE_INSTRUCTION 1</span>
<span class="p_del">-#define CACHE_TYPE_DATA        2</span>
<span class="p_add">+#define CACHE_TYPE_UNIFIED     0 /* cache-size, cache-block-size, etc. */</span>
<span class="p_add">+#define CACHE_TYPE_UNIFIED_D   1 /* d-cache-size, d-cache-block-size, etc */</span>
<span class="p_add">+#define CACHE_TYPE_INSTRUCTION 2</span>
<span class="p_add">+#define CACHE_TYPE_DATA        3</span>
 
 static const struct cache_type_info cache_type_info[] = {
 	{
<span class="p_add">+		/* Embedded systems that use cache-size, cache-block-size,</span>
<span class="p_add">+		 * etc. for the Unified (typically L2) cache. */</span>
<span class="p_add">+		.name            = &quot;Unified&quot;,</span>
<span class="p_add">+		.size_prop       = &quot;cache-size&quot;,</span>
<span class="p_add">+		.line_size_props = { &quot;cache-line-size&quot;,</span>
<span class="p_add">+				     &quot;cache-block-size&quot;, },</span>
<span class="p_add">+		.nr_sets_prop    = &quot;cache-sets&quot;,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		/* PowerPC Processor binding says the [di]-cache-*
 		 * must be equal on unified caches, so just use
 		 * d-cache properties. */
<span class="p_chunk">@@ -293,7 +303,8 @@</span> <span class="p_context"> static struct cache *cache_find_first_sibling(struct cache *cache)</span>
 {
 	struct cache *iter;
 
<span class="p_del">-	if (cache-&gt;type == CACHE_TYPE_UNIFIED)</span>
<span class="p_add">+	if (cache-&gt;type == CACHE_TYPE_UNIFIED ||</span>
<span class="p_add">+	    cache-&gt;type == CACHE_TYPE_UNIFIED_D)</span>
 		return cache;
 
 	list_for_each_entry(iter, &amp;cache_list, list)
<span class="p_chunk">@@ -324,16 +335,29 @@</span> <span class="p_context"> static bool cache_node_is_unified(const struct device_node *np)</span>
 	return of_get_property(np, &quot;cache-unified&quot;, NULL);
 }
 
<span class="p_del">-static struct cache *cache_do_one_devnode_unified(struct device_node *node,</span>
<span class="p_del">-						  int level)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Unified caches can have two different sets of tags.  Most embedded</span>
<span class="p_add">+ * use cache-size, etc. for the unified cache size, but open firmware systems</span>
<span class="p_add">+ * use d-cache-size, etc.   Check on initialization for which type we have, and</span>
<span class="p_add">+ * return the appropriate structure type.  Assume it&#39;s embedded if it isn&#39;t</span>
<span class="p_add">+ * open firmware.  If it&#39;s yet a 3rd type, then there will be missing entries</span>
<span class="p_add">+ * in /sys/devices/system/cpu/cpu0/cache/index2/, and this code will need</span>
<span class="p_add">+ * to be extended further.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int cache_is_unified_d(const struct device_node *np)</span>
 {
<span class="p_del">-	struct cache *cache;</span>
<span class="p_add">+	return of_get_property(np,</span>
<span class="p_add">+		cache_type_info[CACHE_TYPE_UNIFIED_D].size_prop, NULL) ?</span>
<span class="p_add">+		CACHE_TYPE_UNIFIED_D : CACHE_TYPE_UNIFIED;</span>
<span class="p_add">+}</span>
 
<span class="p_add">+/*</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct cache *cache_do_one_devnode_unified(struct device_node *node, int level)</span>
<span class="p_add">+{</span>
 	pr_debug(&quot;creating L%d ucache for %s\n&quot;, level, node-&gt;full_name);
 
<span class="p_del">-	cache = new_cache(CACHE_TYPE_UNIFIED, level, node);</span>
<span class="p_del">-</span>
<span class="p_del">-	return cache;</span>
<span class="p_add">+	return new_cache(cache_is_unified_d(node), level, node);</span>
 }
 
 static struct cache *cache_do_one_devnode_split(struct device_node *node,
<span class="p_header">diff --git a/arch/powerpc/kernel/suspend.c b/arch/powerpc/kernel/suspend.c</span>
<span class="p_header">index 0167d53da30c..a531154cc0f3 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/suspend.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/suspend.c</span>
<span class="p_chunk">@@ -9,9 +9,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/mm.h&gt;
 #include &lt;asm/page.h&gt;
<span class="p_del">-</span>
<span class="p_del">-/* References to section boundaries */</span>
<span class="p_del">-extern const void __nosave_begin, __nosave_end;</span>
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 
 /*
  *	pfn_is_nosave - check if given pfn is in the &#39;nosave&#39; section
<span class="p_header">diff --git a/arch/powerpc/perf/callchain.c b/arch/powerpc/perf/callchain.c</span>
<span class="p_header">index 2396dda282cd..ead55351b254 100644</span>
<span class="p_header">--- a/arch/powerpc/perf/callchain.c</span>
<span class="p_header">+++ b/arch/powerpc/perf/callchain.c</span>
<span class="p_chunk">@@ -243,7 +243,7 @@</span> <span class="p_context"> static void perf_callchain_user_64(struct perf_callchain_entry *entry,</span>
 	sp = regs-&gt;gpr[1];
 	perf_callchain_store(entry, next_ip);
 
<span class="p_del">-	for (;;) {</span>
<span class="p_add">+	while (entry-&gt;nr &lt; PERF_MAX_STACK_DEPTH) {</span>
 		fp = (unsigned long __user *) sp;
 		if (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &amp;next_sp))
 			return;
<span class="p_header">diff --git a/arch/powerpc/platforms/cell/iommu.c b/arch/powerpc/platforms/cell/iommu.c</span>
<span class="p_header">index 2b90ff8a93be..59ef76c5f4f4 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/cell/iommu.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/cell/iommu.c</span>
<span class="p_chunk">@@ -197,7 +197,7 @@</span> <span class="p_context"> static int tce_build_cell(struct iommu_table *tbl, long index, long npages,</span>
 
 	io_pte = (unsigned long *)tbl-&gt;it_base + (index - tbl-&gt;it_offset);
 
<span class="p_del">-	for (i = 0; i &lt; npages; i++, uaddr += tbl-&gt;it_page_shift)</span>
<span class="p_add">+	for (i = 0; i &lt; npages; i++, uaddr += (1 &lt;&lt; tbl-&gt;it_page_shift))</span>
 		io_pte[i] = base_pte | (__pa(uaddr) &amp; CBE_IOPTE_RPN_Mask);
 
 	mb();
<span class="p_header">diff --git a/arch/s390/kernel/suspend.c b/arch/s390/kernel/suspend.c</span>
<span class="p_header">index a7a7537ce1e7..d3236c9e226b 100644</span>
<span class="p_header">--- a/arch/s390/kernel/suspend.c</span>
<span class="p_header">+++ b/arch/s390/kernel/suspend.c</span>
<span class="p_chunk">@@ -13,14 +13,10 @@</span> <span class="p_context"></span>
 #include &lt;asm/ipl.h&gt;
 #include &lt;asm/cio.h&gt;
 #include &lt;asm/pci.h&gt;
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 #include &quot;entry.h&quot;
 
 /*
<span class="p_del">- * References to section boundaries</span>
<span class="p_del">- */</span>
<span class="p_del">-extern const void __nosave_begin, __nosave_end;</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
  * The restore of the saved pages in an hibernation image will set
  * the change and referenced bits in the storage key for each page.
  * Overindication of the referenced bits after an hibernation cycle
<span class="p_chunk">@@ -142,6 +138,8 @@</span> <span class="p_context"> int pfn_is_nosave(unsigned long pfn)</span>
 {
 	unsigned long nosave_begin_pfn = PFN_DOWN(__pa(&amp;__nosave_begin));
 	unsigned long nosave_end_pfn = PFN_DOWN(__pa(&amp;__nosave_end));
<span class="p_add">+	unsigned long eshared_pfn = PFN_DOWN(__pa(&amp;_eshared)) - 1;</span>
<span class="p_add">+	unsigned long stext_pfn = PFN_DOWN(__pa(&amp;_stext));</span>
 
 	/* Always save lowcore pages (LC protection might be enabled). */
 	if (pfn &lt;= LC_PAGES)
<span class="p_chunk">@@ -149,6 +147,8 @@</span> <span class="p_context"> int pfn_is_nosave(unsigned long pfn)</span>
 	if (pfn &gt;= nosave_begin_pfn &amp;&amp; pfn &lt; nosave_end_pfn)
 		return 1;
 	/* Skip memory holes and read-only pages (NSS, DCSS, ...). */
<span class="p_add">+	if (pfn &gt;= stext_pfn &amp;&amp; pfn &lt;= eshared_pfn)</span>
<span class="p_add">+		return ipl_info.type == IPL_TYPE_NSS ? 1 : 0;</span>
 	if (tprot(PFN_PHYS(pfn)))
 		return 1;
 	return 0;
<span class="p_header">diff --git a/arch/s390/kvm/priv.c b/arch/s390/kvm/priv.c</span>
<span class="p_header">index 75beea632a10..3588f2f37986 100644</span>
<span class="p_header">--- a/arch/s390/kvm/priv.c</span>
<span class="p_header">+++ b/arch/s390/kvm/priv.c</span>
<span class="p_chunk">@@ -414,6 +414,7 @@</span> <span class="p_context"> static void handle_stsi_3_2_2(struct kvm_vcpu *vcpu, struct sysinfo_3_2_2 *mem)</span>
 	for (n = mem-&gt;count - 1; n &gt; 0 ; n--)
 		memcpy(&amp;mem-&gt;vm[n], &amp;mem-&gt;vm[n - 1], sizeof(mem-&gt;vm[0]));
 
<span class="p_add">+	memset(&amp;mem-&gt;vm[0], 0, sizeof(mem-&gt;vm[0]));</span>
 	mem-&gt;vm[0].cpus_total = cpus;
 	mem-&gt;vm[0].cpus_configured = cpus;
 	mem-&gt;vm[0].cpus_standby = 0;
<span class="p_header">diff --git a/arch/sh/include/asm/sections.h b/arch/sh/include/asm/sections.h</span>
<span class="p_header">index 1b6199740e98..7a99e6af6372 100644</span>
<span class="p_header">--- a/arch/sh/include/asm/sections.h</span>
<span class="p_header">+++ b/arch/sh/include/asm/sections.h</span>
<span class="p_chunk">@@ -3,7 +3,6 @@</span> <span class="p_context"></span>
 
 #include &lt;asm-generic/sections.h&gt;
 
<span class="p_del">-extern long __nosave_begin, __nosave_end;</span>
 extern long __machvec_start, __machvec_end;
 extern char __uncached_start, __uncached_end;
 extern char __start_eh_frame[], __stop_eh_frame[];
<span class="p_header">diff --git a/arch/sparc/power/hibernate.c b/arch/sparc/power/hibernate.c</span>
<span class="p_header">index 42b0b8ce699a..17bd2e167e07 100644</span>
<span class="p_header">--- a/arch/sparc/power/hibernate.c</span>
<span class="p_header">+++ b/arch/sparc/power/hibernate.c</span>
<span class="p_chunk">@@ -9,11 +9,9 @@</span> <span class="p_context"></span>
 #include &lt;asm/hibernate.h&gt;
 #include &lt;asm/visasm.h&gt;
 #include &lt;asm/page.h&gt;
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 #include &lt;asm/tlb.h&gt;
 
<span class="p_del">-/* References to section boundaries */</span>
<span class="p_del">-extern const void __nosave_begin, __nosave_end;</span>
<span class="p_del">-</span>
 struct saved_context saved_context;
 
 /*
<span class="p_header">diff --git a/arch/unicore32/include/mach/pm.h b/arch/unicore32/include/mach/pm.h</span>
<span class="p_header">index 4dcd34ae194c..77b522694e74 100644</span>
<span class="p_header">--- a/arch/unicore32/include/mach/pm.h</span>
<span class="p_header">+++ b/arch/unicore32/include/mach/pm.h</span>
<span class="p_chunk">@@ -36,8 +36,5 @@</span> <span class="p_context"> extern int puv3_pm_enter(suspend_state_t state);</span>
 /* Defined in hibernate_asm.S */
 extern int restore_image(pgd_t *resume_pg_dir, struct pbe *restore_pblist);
 
<span class="p_del">-/* References to section boundaries */</span>
<span class="p_del">-extern const void __nosave_begin, __nosave_end;</span>
<span class="p_del">-</span>
 extern struct pbe *restore_pblist;
 #endif
<span class="p_header">diff --git a/arch/unicore32/kernel/hibernate.c b/arch/unicore32/kernel/hibernate.c</span>
<span class="p_header">index d75ef8b6cb56..9969ec374abb 100644</span>
<span class="p_header">--- a/arch/unicore32/kernel/hibernate.c</span>
<span class="p_header">+++ b/arch/unicore32/kernel/hibernate.c</span>
<span class="p_chunk">@@ -18,6 +18,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/page.h&gt;
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/pgalloc.h&gt;
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 #include &lt;asm/suspend.h&gt;
 
 #include &quot;mach/pm.h&quot;
<span class="p_header">diff --git a/arch/x86/include/asm/mwait.h b/arch/x86/include/asm/mwait.h</span>
<span class="p_header">index 1da25a5f96f9..3ba047cbcf5b 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mwait.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mwait.h</span>
<span class="p_chunk">@@ -30,6 +30,14 @@</span> <span class="p_context"> static inline void __mwait(unsigned long eax, unsigned long ecx)</span>
 		     :: &quot;a&quot; (eax), &quot;c&quot; (ecx));
 }
 
<span class="p_add">+static inline void __sti_mwait(unsigned long eax, unsigned long ecx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	trace_hardirqs_on();</span>
<span class="p_add">+	/* &quot;mwait %eax, %ecx;&quot; */</span>
<span class="p_add">+	asm volatile(&quot;sti; .byte 0x0f, 0x01, 0xc9;&quot;</span>
<span class="p_add">+		     :: &quot;a&quot; (eax), &quot;c&quot; (ecx));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * This uses new MONITOR/MWAIT instructions on P4 processors with PNI,
  * which can obviate IPI to trigger checking of need_resched.
<span class="p_header">diff --git a/arch/x86/kernel/process.c b/arch/x86/kernel/process.c</span>
<span class="p_header">index 3fb8d95ab8b5..1a1ff42094a7 100644</span>
<span class="p_header">--- a/arch/x86/kernel/process.c</span>
<span class="p_header">+++ b/arch/x86/kernel/process.c</span>
<span class="p_chunk">@@ -28,6 +28,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/fpu-internal.h&gt;
 #include &lt;asm/debugreg.h&gt;
 #include &lt;asm/nmi.h&gt;
<span class="p_add">+#include &lt;asm/mwait.h&gt;</span>
 
 /*
  * per-CPU TSS segments. Threads are completely &#39;soft&#39; on Linux,
<span class="p_chunk">@@ -398,6 +399,52 @@</span> <span class="p_context"> static void amd_e400_idle(void)</span>
 		default_idle();
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Intel Core2 and older machines prefer MWAIT over HALT for C1.</span>
<span class="p_add">+ * We can&#39;t rely on cpuidle installing MWAIT, because it will not load</span>
<span class="p_add">+ * on systems that support only C1 -- so the boot default must be MWAIT.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Some AMD machines are the opposite, they depend on using HALT.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * So for default C1, which is used during boot until cpuidle loads,</span>
<span class="p_add">+ * use MWAIT-C1 on Intel HW that has it, else use HALT.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int prefer_mwait_c1_over_halt(const struct cpuinfo_x86 *c)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (c-&gt;x86_vendor != X86_VENDOR_INTEL)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!cpu_has(c, X86_FEATURE_MWAIT))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * MONITOR/MWAIT with no hints, used for default default C1 state.</span>
<span class="p_add">+ * This invokes MWAIT with interrutps enabled and no flags,</span>
<span class="p_add">+ * which is backwards compatible with the original MWAIT implementation.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+static void mwait_idle(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!current_set_polling_and_test()) {</span>
<span class="p_add">+		if (static_cpu_has(X86_FEATURE_CLFLUSH_MONITOR)) {</span>
<span class="p_add">+			mb();</span>
<span class="p_add">+			clflush((void *)&amp;current_thread_info()-&gt;flags);</span>
<span class="p_add">+			mb();</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		__monitor((void *)&amp;current_thread_info()-&gt;flags, 0, 0);</span>
<span class="p_add">+		if (!need_resched())</span>
<span class="p_add">+			__sti_mwait(0, 0);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			local_irq_enable();</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		local_irq_enable();</span>
<span class="p_add">+	current_clr_polling();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void select_idle_routine(const struct cpuinfo_x86 *c)
 {
 #ifdef CONFIG_SMP
<span class="p_chunk">@@ -411,6 +458,9 @@</span> <span class="p_context"> void select_idle_routine(const struct cpuinfo_x86 *c)</span>
 		/* E400: APIC timer interrupt does not wake up CPU from C1e */
 		pr_info(&quot;using AMD E400 aware idle routine\n&quot;);
 		x86_idle = amd_e400_idle;
<span class="p_add">+	} else if (prefer_mwait_c1_over_halt(c)) {</span>
<span class="p_add">+		pr_info(&quot;using mwait in idle threads\n&quot;);</span>
<span class="p_add">+		x86_idle = mwait_idle;</span>
 	} else
 		x86_idle = default_idle;
 }
<span class="p_header">diff --git a/arch/x86/power/hibernate_32.c b/arch/x86/power/hibernate_32.c</span>
<span class="p_header">index 7d28c885d238..291226b952a9 100644</span>
<span class="p_header">--- a/arch/x86/power/hibernate_32.c</span>
<span class="p_header">+++ b/arch/x86/power/hibernate_32.c</span>
<span class="p_chunk">@@ -13,13 +13,11 @@</span> <span class="p_context"></span>
 #include &lt;asm/page.h&gt;
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/mmzone.h&gt;
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 
 /* Defined in hibernate_asm_32.S */
 extern int restore_image(void);
 
<span class="p_del">-/* References to section boundaries */</span>
<span class="p_del">-extern const void __nosave_begin, __nosave_end;</span>
<span class="p_del">-</span>
 /* Pointer to the temporary resume page tables */
 pgd_t *resume_pg_dir;
 
<span class="p_header">diff --git a/arch/x86/power/hibernate_64.c b/arch/x86/power/hibernate_64.c</span>
<span class="p_header">index 304fca20d96e..2276238fde6f 100644</span>
<span class="p_header">--- a/arch/x86/power/hibernate_64.c</span>
<span class="p_header">+++ b/arch/x86/power/hibernate_64.c</span>
<span class="p_chunk">@@ -17,11 +17,9 @@</span> <span class="p_context"></span>
 #include &lt;asm/page.h&gt;
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/mtrr.h&gt;
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 #include &lt;asm/suspend.h&gt;
 
<span class="p_del">-/* References to section boundaries */</span>
<span class="p_del">-extern __visible const void __nosave_begin, __nosave_end;</span>
<span class="p_del">-</span>
 /* Defined in hibernate_asm_64.S */
 extern asmlinkage int restore_image(void);
 
<span class="p_header">diff --git a/arch/xtensa/Kconfig b/arch/xtensa/Kconfig</span>
<span class="p_header">index c87ae7c6e5f9..8879361e477e 100644</span>
<span class="p_header">--- a/arch/xtensa/Kconfig</span>
<span class="p_header">+++ b/arch/xtensa/Kconfig</span>
<span class="p_chunk">@@ -336,6 +336,36 @@</span> <span class="p_context"> menu &quot;Executable file formats&quot;</span>
 
 source &quot;fs/Kconfig.binfmt&quot;
 
<span class="p_add">+config XTFPGA_LCD</span>
<span class="p_add">+	bool &quot;Enable XTFPGA LCD driver&quot;</span>
<span class="p_add">+	depends on XTENSA_PLATFORM_XTFPGA</span>
<span class="p_add">+	default n</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  There&#39;s a 2x16 LCD on most of XTFPGA boards, kernel may output</span>
<span class="p_add">+	  progress messages there during bootup/shutdown. It may be useful</span>
<span class="p_add">+	  during board bringup.</span>
<span class="p_add">+</span>
<span class="p_add">+	  If unsure, say N.</span>
<span class="p_add">+</span>
<span class="p_add">+config XTFPGA_LCD_BASE_ADDR</span>
<span class="p_add">+	hex &quot;XTFPGA LCD base address&quot;</span>
<span class="p_add">+	depends on XTFPGA_LCD</span>
<span class="p_add">+	default &quot;0x0d0c0000&quot;</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Base address of the LCD controller inside KIO region.</span>
<span class="p_add">+	  Different boards from XTFPGA family have LCD controller at different</span>
<span class="p_add">+	  addresses. Please consult prototyping user guide for your board for</span>
<span class="p_add">+	  the correct address. Wrong address here may lead to hardware lockup.</span>
<span class="p_add">+</span>
<span class="p_add">+config XTFPGA_LCD_8BIT_ACCESS</span>
<span class="p_add">+	bool &quot;Use 8-bit access to XTFPGA LCD&quot;</span>
<span class="p_add">+	depends on XTFPGA_LCD</span>
<span class="p_add">+	default n</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  LCD may be connected with 4- or 8-bit interface, 8-bit access may</span>
<span class="p_add">+	  only be used with 8-bit interface. Please consult prototyping user</span>
<span class="p_add">+	  guide for your board for the correct interface width.</span>
<span class="p_add">+</span>
 endmenu
 
 source &quot;net/Kconfig&quot;
<span class="p_header">diff --git a/arch/xtensa/include/uapi/asm/unistd.h b/arch/xtensa/include/uapi/asm/unistd.h</span>
<span class="p_header">index 50084f7c01c8..b54fa1bd7f7e 100644</span>
<span class="p_header">--- a/arch/xtensa/include/uapi/asm/unistd.h</span>
<span class="p_header">+++ b/arch/xtensa/include/uapi/asm/unistd.h</span>
<span class="p_chunk">@@ -715,7 +715,7 @@</span> <span class="p_context"> __SYSCALL(323, sys_process_vm_writev, 6)</span>
 __SYSCALL(324, sys_name_to_handle_at, 5)
 #define __NR_open_by_handle_at			325
 __SYSCALL(325, sys_open_by_handle_at, 3)
<span class="p_del">-#define __NR_sync_file_range			326</span>
<span class="p_add">+#define __NR_sync_file_range2			326</span>
 __SYSCALL(326, sys_sync_file_range2, 6)
 #define __NR_perf_event_open			327
 __SYSCALL(327, sys_perf_event_open, 5)
<span class="p_header">diff --git a/arch/xtensa/platforms/iss/network.c b/arch/xtensa/platforms/iss/network.c</span>
<span class="p_header">index d05f8feeb8d7..17b1ef3232e4 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/iss/network.c</span>
<span class="p_header">+++ b/arch/xtensa/platforms/iss/network.c</span>
<span class="p_chunk">@@ -349,8 +349,8 @@</span> <span class="p_context"> static void iss_net_timer(unsigned long priv)</span>
 {
 	struct iss_net_private *lp = (struct iss_net_private *)priv;
 
<span class="p_del">-	spin_lock(&amp;lp-&gt;lock);</span>
 	iss_net_poll();
<span class="p_add">+	spin_lock(&amp;lp-&gt;lock);</span>
 	mod_timer(&amp;lp-&gt;timer, jiffies + lp-&gt;timer_val);
 	spin_unlock(&amp;lp-&gt;lock);
 }
<span class="p_chunk">@@ -361,7 +361,7 @@</span> <span class="p_context"> static int iss_net_open(struct net_device *dev)</span>
 	struct iss_net_private *lp = netdev_priv(dev);
 	int err;
 
<span class="p_del">-	spin_lock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;lp-&gt;lock);</span>
 
 	err = lp-&gt;tp.open(lp);
 	if (err &lt; 0)
<span class="p_chunk">@@ -376,9 +376,11 @@</span> <span class="p_context"> static int iss_net_open(struct net_device *dev)</span>
 	while ((err = iss_net_rx(dev)) &gt; 0)
 		;
 
<span class="p_del">-	spin_lock(&amp;opened_lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;opened_lock);</span>
 	list_add(&amp;lp-&gt;opened_list, &amp;opened);
<span class="p_del">-	spin_unlock(&amp;opened_lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;opened_lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;lp-&gt;lock);</span>
 
 	init_timer(&amp;lp-&gt;timer);
 	lp-&gt;timer_val = ISS_NET_TIMER_VALUE;
<span class="p_chunk">@@ -387,7 +389,7 @@</span> <span class="p_context"> static int iss_net_open(struct net_device *dev)</span>
 	mod_timer(&amp;lp-&gt;timer, jiffies + lp-&gt;timer_val);
 
 out:
<span class="p_del">-	spin_unlock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;lp-&gt;lock);</span>
 	return err;
 }
 
<span class="p_chunk">@@ -395,7 +397,7 @@</span> <span class="p_context"> static int iss_net_close(struct net_device *dev)</span>
 {
 	struct iss_net_private *lp = netdev_priv(dev);
 	netif_stop_queue(dev);
<span class="p_del">-	spin_lock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;lp-&gt;lock);</span>
 
 	spin_lock(&amp;opened_lock);
 	list_del(&amp;opened);
<span class="p_chunk">@@ -405,18 +407,17 @@</span> <span class="p_context"> static int iss_net_close(struct net_device *dev)</span>
 
 	lp-&gt;tp.close(lp);
 
<span class="p_del">-	spin_unlock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;lp-&gt;lock);</span>
 	return 0;
 }
 
 static int iss_net_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct iss_net_private *lp = netdev_priv(dev);
<span class="p_del">-	unsigned long flags;</span>
 	int len;
 
 	netif_stop_queue(dev);
<span class="p_del">-	spin_lock_irqsave(&amp;lp-&gt;lock, flags);</span>
<span class="p_add">+	spin_lock_bh(&amp;lp-&gt;lock);</span>
 
 	len = lp-&gt;tp.write(lp, &amp;skb);
 
<span class="p_chunk">@@ -438,7 +439,7 @@</span> <span class="p_context"> static int iss_net_start_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 		pr_err(&quot;%s: %s failed(%d)\n&quot;, dev-&gt;name, __func__, len);
 	}
 
<span class="p_del">-	spin_unlock_irqrestore(&amp;lp-&gt;lock, flags);</span>
<span class="p_add">+	spin_unlock_bh(&amp;lp-&gt;lock);</span>
 
 	dev_kfree_skb(skb);
 	return NETDEV_TX_OK;
<span class="p_chunk">@@ -466,9 +467,9 @@</span> <span class="p_context"> static int iss_net_set_mac(struct net_device *dev, void *addr)</span>
 
 	if (!is_valid_ether_addr(hwaddr-&gt;sa_data))
 		return -EADDRNOTAVAIL;
<span class="p_del">-	spin_lock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;lp-&gt;lock);</span>
 	memcpy(dev-&gt;dev_addr, hwaddr-&gt;sa_data, ETH_ALEN);
<span class="p_del">-	spin_unlock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;lp-&gt;lock);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -520,11 +521,11 @@</span> <span class="p_context"> static int iss_net_configure(int index, char *init)</span>
 	*lp = (struct iss_net_private) {
 		.device_list		= LIST_HEAD_INIT(lp-&gt;device_list),
 		.opened_list		= LIST_HEAD_INIT(lp-&gt;opened_list),
<span class="p_del">-		.lock			= __SPIN_LOCK_UNLOCKED(lp.lock),</span>
 		.dev			= dev,
 		.index			= index,
<span class="p_del">-		};</span>
<span class="p_add">+	};</span>
 
<span class="p_add">+	spin_lock_init(&amp;lp-&gt;lock);</span>
 	/*
 	 * If this name ends up conflicting with an existing registered
 	 * netdevice, that is OK, register_netdev{,ice}() will notice this
<span class="p_header">diff --git a/arch/xtensa/platforms/xtfpga/Makefile b/arch/xtensa/platforms/xtfpga/Makefile</span>
<span class="p_header">index b9ae206340cd..7839d38b2337 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xtfpga/Makefile</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xtfpga/Makefile</span>
<span class="p_chunk">@@ -6,4 +6,5 @@</span> <span class="p_context"></span>
 #
 # Note 2! The CFLAGS definitions are in the main makefile...
 
<span class="p_del">-obj-y			= setup.o lcd.o</span>
<span class="p_add">+obj-y			+= setup.o</span>
<span class="p_add">+obj-$(CONFIG_XTFPGA_LCD) += lcd.o</span>
<span class="p_header">diff --git a/arch/xtensa/platforms/xtfpga/include/platform/hardware.h b/arch/xtensa/platforms/xtfpga/include/platform/hardware.h</span>
<span class="p_header">index aeb316b7ff88..e8cc86fbba09 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xtfpga/include/platform/hardware.h</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xtfpga/include/platform/hardware.h</span>
<span class="p_chunk">@@ -40,9 +40,6 @@</span> <span class="p_context"></span>
 
 /* UART */
 #define DUART16552_PADDR	(XCHAL_KIO_PADDR + 0x0D050020)
<span class="p_del">-/* LCD instruction and data addresses. */</span>
<span class="p_del">-#define LCD_INSTR_ADDR		((char *)IOADDR(0x0D040000))</span>
<span class="p_del">-#define LCD_DATA_ADDR		((char *)IOADDR(0x0D040004))</span>
 
 /* Misc. */
 #define XTFPGA_FPGAREGS_VADDR	IOADDR(0x0D020000)
<span class="p_header">diff --git a/arch/xtensa/platforms/xtfpga/include/platform/lcd.h b/arch/xtensa/platforms/xtfpga/include/platform/lcd.h</span>
<span class="p_header">index 0e435645af5a..4c8541ed1139 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xtfpga/include/platform/lcd.h</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xtfpga/include/platform/lcd.h</span>
<span class="p_chunk">@@ -11,10 +11,25 @@</span> <span class="p_context"></span>
 #ifndef __XTENSA_XTAVNET_LCD_H
 #define __XTENSA_XTAVNET_LCD_H
 
<span class="p_add">+#ifdef CONFIG_XTFPGA_LCD</span>
 /* Display string STR at position POS on the LCD. */
 void lcd_disp_at_pos(char *str, unsigned char pos);
 
 /* Shift the contents of the LCD display left or right. */
 void lcd_shiftleft(void);
 void lcd_shiftright(void);
<span class="p_add">+#else</span>
<span class="p_add">+static inline void lcd_disp_at_pos(char *str, unsigned char pos)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void lcd_shiftleft(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void lcd_shiftright(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/arch/xtensa/platforms/xtfpga/lcd.c b/arch/xtensa/platforms/xtfpga/lcd.c</span>
<span class="p_header">index 2872301598df..4dc0c1b43f4b 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xtfpga/lcd.c</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xtfpga/lcd.c</span>
<span class="p_chunk">@@ -1,50 +1,63 @@</span> <span class="p_context"></span>
 /*
<span class="p_del">- * Driver for the LCD display on the Tensilica LX60 Board.</span>
<span class="p_add">+ * Driver for the LCD display on the Tensilica XTFPGA board family.</span>
<span class="p_add">+ * http://www.mytechcorp.com/cfdata/productFile/File1/MOC-16216B-B-A0A04.pdf</span>
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file &quot;COPYING&quot; in the main directory of this archive
  * for more details.
  *
  * Copyright (C) 2001, 2006 Tensilica Inc.
<span class="p_add">+ * Copyright (C) 2015 Cadence Design Systems Inc.</span>
  */
 
<span class="p_del">-/*</span>
<span class="p_del">- *</span>
<span class="p_del">- * FIXME: this code is from the examples from the LX60 user guide.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The lcd_pause function does busy waiting, which is probably not</span>
<span class="p_del">- * great. Maybe the code could be changed to use kernel timers, or</span>
<span class="p_del">- * change the hardware to not need to wait.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
 #include &lt;linux/init.h&gt;
 #include &lt;linux/io.h&gt;
 
 #include &lt;platform/hardware.h&gt;
 #include &lt;platform/lcd.h&gt;
<span class="p_del">-#include &lt;linux/delay.h&gt;</span>
 
<span class="p_del">-#define LCD_PAUSE_ITERATIONS	4000</span>
<span class="p_add">+/* LCD instruction and data addresses. */</span>
<span class="p_add">+#define LCD_INSTR_ADDR		((char *)IOADDR(CONFIG_XTFPGA_LCD_BASE_ADDR))</span>
<span class="p_add">+#define LCD_DATA_ADDR		(LCD_INSTR_ADDR + 4)</span>
<span class="p_add">+</span>
 #define LCD_CLEAR		0x1
 #define LCD_DISPLAY_ON		0xc
 
 /* 8bit and 2 lines display */
 #define LCD_DISPLAY_MODE8BIT	0x38
<span class="p_add">+#define LCD_DISPLAY_MODE4BIT	0x28</span>
 #define LCD_DISPLAY_POS		0x80
 #define LCD_SHIFT_LEFT		0x18
 #define LCD_SHIFT_RIGHT		0x1c
 
<span class="p_add">+static void lcd_put_byte(u8 *addr, u8 data)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_XTFPGA_LCD_8BIT_ACCESS</span>
<span class="p_add">+	ACCESS_ONCE(*addr) = data;</span>
<span class="p_add">+#else</span>
<span class="p_add">+	ACCESS_ONCE(*addr) = data &amp; 0xf0;</span>
<span class="p_add">+	ACCESS_ONCE(*addr) = (data &lt;&lt; 4) &amp; 0xf0;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int __init lcd_init(void)
 {
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE8BIT;</span>
 	mdelay(5);
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE8BIT;</span>
 	udelay(200);
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	udelay(50);</span>
<span class="p_add">+#ifndef CONFIG_XTFPGA_LCD_8BIT_ACCESS</span>
<span class="p_add">+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE4BIT;</span>
<span class="p_add">+	udelay(50);</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_DISPLAY_MODE4BIT);</span>
 	udelay(50);
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_ON;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_DISPLAY_ON);</span>
 	udelay(50);
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_CLEAR;</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_CLEAR);</span>
 	mdelay(10);
 	lcd_disp_at_pos(&quot;XTENSA LINUX&quot;, 0);
 	return 0;
<span class="p_chunk">@@ -52,10 +65,10 @@</span> <span class="p_context"> static int __init lcd_init(void)</span>
 
 void lcd_disp_at_pos(char *str, unsigned char pos)
 {
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_POS | pos;</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_DISPLAY_POS | pos);</span>
 	udelay(100);
 	while (*str != 0) {
<span class="p_del">-		*LCD_DATA_ADDR = *str;</span>
<span class="p_add">+		lcd_put_byte(LCD_DATA_ADDR, *str);</span>
 		udelay(200);
 		str++;
 	}
<span class="p_chunk">@@ -63,13 +76,13 @@</span> <span class="p_context"> void lcd_disp_at_pos(char *str, unsigned char pos)</span>
 
 void lcd_shiftleft(void)
 {
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_SHIFT_LEFT;</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_SHIFT_LEFT);</span>
 	udelay(50);
 }
 
 void lcd_shiftright(void)
 {
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_SHIFT_RIGHT;</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_SHIFT_RIGHT);</span>
 	udelay(50);
 }
 
<span class="p_header">diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c</span>
<span class="p_header">index 666beea3bf1c..9498c3d575d4 100644</span>
<span class="p_header">--- a/drivers/acpi/scan.c</span>
<span class="p_header">+++ b/drivers/acpi/scan.c</span>
<span class="p_chunk">@@ -192,7 +192,11 @@</span> <span class="p_context"> bool acpi_scan_is_offline(struct acpi_device *adev, bool uevent)</span>
 	struct acpi_device_physical_node *pn;
 	bool offline = true;
 
<span class="p_del">-	mutex_lock(&amp;adev-&gt;physical_node_lock);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * acpi_container_offline() calls this for all of the container&#39;s</span>
<span class="p_add">+	 * children under the container&#39;s physical_node_lock lock.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mutex_lock_nested(&amp;adev-&gt;physical_node_lock, SINGLE_DEPTH_NESTING);</span>
 
 	list_for_each_entry(pn, &amp;adev-&gt;physical_node_list, node)
 		if (device_supports_offline(pn-&gt;dev) &amp;&amp; !pn-&gt;dev-&gt;offline) {
<span class="p_header">diff --git a/drivers/base/bus.c b/drivers/base/bus.c</span>
<span class="p_header">index 45d0fa78981c..12b39dc2ad5c 100644</span>
<span class="p_header">--- a/drivers/base/bus.c</span>
<span class="p_header">+++ b/drivers/base/bus.c</span>
<span class="p_chunk">@@ -515,11 +515,11 @@</span> <span class="p_context"> int bus_add_device(struct device *dev)</span>
 			goto out_put;
 		error = device_add_groups(dev, bus-&gt;dev_groups);
 		if (error)
<span class="p_del">-			goto out_groups;</span>
<span class="p_add">+			goto out_id;</span>
 		error = sysfs_create_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj,
 						&amp;dev-&gt;kobj, dev_name(dev));
 		if (error)
<span class="p_del">-			goto out_id;</span>
<span class="p_add">+			goto out_groups;</span>
 		error = sysfs_create_link(&amp;dev-&gt;kobj,
 				&amp;dev-&gt;bus-&gt;p-&gt;subsys.kobj, &quot;subsystem&quot;);
 		if (error)
<span class="p_header">diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c</span>
<span class="p_header">index 5afe556a70f8..26b03e1254ef 100644</span>
<span class="p_header">--- a/drivers/bluetooth/ath3k.c</span>
<span class="p_header">+++ b/drivers/bluetooth/ath3k.c</span>
<span class="p_chunk">@@ -64,6 +64,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_table[] = {</span>
 	/* Atheros AR3011 with sflash firmware*/
 	{ USB_DEVICE(0x0489, 0xE027) },
 	{ USB_DEVICE(0x0489, 0xE03D) },
<span class="p_add">+	{ USB_DEVICE(0x04F2, 0xAFF1) },</span>
 	{ USB_DEVICE(0x0930, 0x0215) },
 	{ USB_DEVICE(0x0CF3, 0x3002) },
 	{ USB_DEVICE(0x0CF3, 0xE019) },
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index 03b331798e16..9eb1669962ef 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -142,6 +142,7 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 	/* Atheros 3011 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xe027), .driver_info = BTUSB_IGNORE },
 	{ USB_DEVICE(0x0489, 0xe03d), .driver_info = BTUSB_IGNORE },
<span class="p_add">+	{ USB_DEVICE(0x04f2, 0xaff1), .driver_info = BTUSB_IGNORE },</span>
 	{ USB_DEVICE(0x0930, 0x0215), .driver_info = BTUSB_IGNORE },
 	{ USB_DEVICE(0x0cf3, 0x3002), .driver_info = BTUSB_IGNORE },
 	{ USB_DEVICE(0x0cf3, 0xe019), .driver_info = BTUSB_IGNORE },
<span class="p_header">diff --git a/drivers/clk/qcom/clk-rcg2.c b/drivers/clk/qcom/clk-rcg2.c</span>
<span class="p_header">index 0996a3a39855..a9dd21aff6bb 100644</span>
<span class="p_header">--- a/drivers/clk/qcom/clk-rcg2.c</span>
<span class="p_header">+++ b/drivers/clk/qcom/clk-rcg2.c</span>
<span class="p_chunk">@@ -257,7 +257,7 @@</span> <span class="p_context"> static int __clk_rcg2_set_rate(struct clk_hw *hw, unsigned long rate)</span>
 	mask |= CFG_SRC_SEL_MASK | CFG_MODE_MASK;
 	cfg = f-&gt;pre_div &lt;&lt; CFG_SRC_DIV_SHIFT;
 	cfg |= rcg-&gt;parent_map[f-&gt;src] &lt;&lt; CFG_SRC_SEL_SHIFT;
<span class="p_del">-	if (rcg-&gt;mnd_width &amp;&amp; f-&gt;n)</span>
<span class="p_add">+	if (rcg-&gt;mnd_width &amp;&amp; f-&gt;n &amp;&amp; (f-&gt;m != f-&gt;n))</span>
 		cfg |= CFG_MODE_DUAL_EDGE;
 	ret = regmap_update_bits(rcg-&gt;clkr.regmap, rcg-&gt;cmd_rcgr + CFG_REG, mask,
 			cfg);
<span class="p_header">diff --git a/drivers/clk/tegra/clk.c b/drivers/clk/tegra/clk.c</span>
<span class="p_header">index c0a7d7723510..a90af1780cf2 100644</span>
<span class="p_header">--- a/drivers/clk/tegra/clk.c</span>
<span class="p_header">+++ b/drivers/clk/tegra/clk.c</span>
<span class="p_chunk">@@ -266,7 +266,7 @@</span> <span class="p_context"> void __init tegra_add_of_provider(struct device_node *np)</span>
 	of_clk_add_provider(np, of_clk_src_onecell_get, &amp;clk_data);
 
 	rst_ctlr.of_node = np;
<span class="p_del">-	rst_ctlr.nr_resets = clk_num * 32;</span>
<span class="p_add">+	rst_ctlr.nr_resets = periph_banks * 32;</span>
 	reset_controller_register(&amp;rst_ctlr);
 }
 
<span class="p_header">diff --git a/drivers/crypto/omap-aes.c b/drivers/crypto/omap-aes.c</span>
<span class="p_header">index dde41f1df608..d522396174c3 100644</span>
<span class="p_header">--- a/drivers/crypto/omap-aes.c</span>
<span class="p_header">+++ b/drivers/crypto/omap-aes.c</span>
<span class="p_chunk">@@ -554,15 +554,23 @@</span> <span class="p_context"> static int omap_aes_crypt_dma_stop(struct omap_aes_dev *dd)</span>
 	return err;
 }
 
<span class="p_del">-static int omap_aes_check_aligned(struct scatterlist *sg)</span>
<span class="p_add">+static int omap_aes_check_aligned(struct scatterlist *sg, int total)</span>
 {
<span class="p_add">+	int len = 0;</span>
<span class="p_add">+</span>
 	while (sg) {
 		if (!IS_ALIGNED(sg-&gt;offset, 4))
 			return -1;
 		if (!IS_ALIGNED(sg-&gt;length, AES_BLOCK_SIZE))
 			return -1;
<span class="p_add">+</span>
<span class="p_add">+		len += sg-&gt;length;</span>
 		sg = sg_next(sg);
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (len != total)</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -633,8 +641,8 @@</span> <span class="p_context"> static int omap_aes_handle_queue(struct omap_aes_dev *dd,</span>
 	dd-&gt;in_sg = req-&gt;src;
 	dd-&gt;out_sg = req-&gt;dst;
 
<span class="p_del">-	if (omap_aes_check_aligned(dd-&gt;in_sg) ||</span>
<span class="p_del">-	    omap_aes_check_aligned(dd-&gt;out_sg)) {</span>
<span class="p_add">+	if (omap_aes_check_aligned(dd-&gt;in_sg, dd-&gt;total) ||</span>
<span class="p_add">+	    omap_aes_check_aligned(dd-&gt;out_sg, dd-&gt;total)) {</span>
 		if (omap_aes_copy_sgs(dd))
 			pr_err(&quot;Failed to copy SGs for unaligned cases\n&quot;);
 		dd-&gt;sgs_copied = 1;
<span class="p_header">diff --git a/drivers/gpio/gpio-mvebu.c b/drivers/gpio/gpio-mvebu.c</span>
<span class="p_header">index 3b1fd1ce460f..e9d8cf6c2f79 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-mvebu.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-mvebu.c</span>
<span class="p_chunk">@@ -304,11 +304,13 @@</span> <span class="p_context"> static void mvebu_gpio_edge_irq_mask(struct irq_data *d)</span>
 {
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct mvebu_gpio_chip *mvchip = gc-&gt;private;
<span class="p_add">+	struct irq_chip_type *ct = irq_data_get_chip_type(d);</span>
 	u32 mask = 1 &lt;&lt; (d-&gt;irq - gc-&gt;irq_base);
 
 	irq_gc_lock(gc);
<span class="p_del">-	gc-&gt;mask_cache &amp;= ~mask;</span>
<span class="p_del">-	writel_relaxed(gc-&gt;mask_cache, mvebu_gpioreg_edge_mask(mvchip));</span>
<span class="p_add">+	ct-&gt;mask_cache_priv &amp;= ~mask;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(ct-&gt;mask_cache_priv, mvebu_gpioreg_edge_mask(mvchip));</span>
 	irq_gc_unlock(gc);
 }
 
<span class="p_chunk">@@ -316,11 +318,13 @@</span> <span class="p_context"> static void mvebu_gpio_edge_irq_unmask(struct irq_data *d)</span>
 {
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct mvebu_gpio_chip *mvchip = gc-&gt;private;
<span class="p_add">+	struct irq_chip_type *ct = irq_data_get_chip_type(d);</span>
<span class="p_add">+</span>
 	u32 mask = 1 &lt;&lt; (d-&gt;irq - gc-&gt;irq_base);
 
 	irq_gc_lock(gc);
<span class="p_del">-	gc-&gt;mask_cache |= mask;</span>
<span class="p_del">-	writel_relaxed(gc-&gt;mask_cache, mvebu_gpioreg_edge_mask(mvchip));</span>
<span class="p_add">+	ct-&gt;mask_cache_priv |= mask;</span>
<span class="p_add">+	writel_relaxed(ct-&gt;mask_cache_priv, mvebu_gpioreg_edge_mask(mvchip));</span>
 	irq_gc_unlock(gc);
 }
 
<span class="p_chunk">@@ -328,11 +332,13 @@</span> <span class="p_context"> static void mvebu_gpio_level_irq_mask(struct irq_data *d)</span>
 {
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct mvebu_gpio_chip *mvchip = gc-&gt;private;
<span class="p_add">+	struct irq_chip_type *ct = irq_data_get_chip_type(d);</span>
<span class="p_add">+</span>
 	u32 mask = 1 &lt;&lt; (d-&gt;irq - gc-&gt;irq_base);
 
 	irq_gc_lock(gc);
<span class="p_del">-	gc-&gt;mask_cache &amp;= ~mask;</span>
<span class="p_del">-	writel_relaxed(gc-&gt;mask_cache, mvebu_gpioreg_level_mask(mvchip));</span>
<span class="p_add">+	ct-&gt;mask_cache_priv &amp;= ~mask;</span>
<span class="p_add">+	writel_relaxed(ct-&gt;mask_cache_priv, mvebu_gpioreg_level_mask(mvchip));</span>
 	irq_gc_unlock(gc);
 }
 
<span class="p_chunk">@@ -340,11 +346,13 @@</span> <span class="p_context"> static void mvebu_gpio_level_irq_unmask(struct irq_data *d)</span>
 {
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct mvebu_gpio_chip *mvchip = gc-&gt;private;
<span class="p_add">+	struct irq_chip_type *ct = irq_data_get_chip_type(d);</span>
<span class="p_add">+</span>
 	u32 mask = 1 &lt;&lt; (d-&gt;irq - gc-&gt;irq_base);
 
 	irq_gc_lock(gc);
<span class="p_del">-	gc-&gt;mask_cache |= mask;</span>
<span class="p_del">-	writel_relaxed(gc-&gt;mask_cache, mvebu_gpioreg_level_mask(mvchip));</span>
<span class="p_add">+	ct-&gt;mask_cache_priv |= mask;</span>
<span class="p_add">+	writel_relaxed(ct-&gt;mask_cache_priv, mvebu_gpioreg_level_mask(mvchip));</span>
 	irq_gc_unlock(gc);
 }
 
<span class="p_header">diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c</span>
<span class="p_header">index 8f42bd724682..f1fc14c33be5 100644</span>
<span class="p_header">--- a/drivers/gpio/gpiolib.c</span>
<span class="p_header">+++ b/drivers/gpio/gpiolib.c</span>
<span class="p_chunk">@@ -1928,15 +1928,15 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(gpiod_is_active_low);</span>
  * that the GPIO was actually requested.
  */
 
<span class="p_del">-static int _gpiod_get_raw_value(const struct gpio_desc *desc)</span>
<span class="p_add">+static bool _gpiod_get_raw_value(const struct gpio_desc *desc)</span>
 {
 	struct gpio_chip	*chip;
<span class="p_del">-	int value;</span>
<span class="p_add">+	bool value;</span>
 	int offset;
 
 	chip = desc-&gt;chip;
 	offset = gpio_chip_hwgpio(desc);
<span class="p_del">-	value = chip-&gt;get ? chip-&gt;get(chip, offset) : 0;</span>
<span class="p_add">+	value = chip-&gt;get ? chip-&gt;get(chip, offset) : false;</span>
 	trace_gpio_value(desc_to_gpio(desc), 1, value);
 	return value;
 }
<span class="p_chunk">@@ -1992,7 +1992,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(gpiod_get_value);</span>
  * @desc: gpio descriptor whose state need to be set.
  * @value: Non-zero for setting it HIGH otherise it will set to LOW.
  */
<span class="p_del">-static void _gpio_set_open_drain_value(struct gpio_desc *desc, int value)</span>
<span class="p_add">+static void _gpio_set_open_drain_value(struct gpio_desc *desc, bool value)</span>
 {
 	int err = 0;
 	struct gpio_chip *chip = desc-&gt;chip;
<span class="p_chunk">@@ -2019,7 +2019,7 @@</span> <span class="p_context"> static void _gpio_set_open_drain_value(struct gpio_desc *desc, int value)</span>
  * @desc: gpio descriptor whose state need to be set.
  * @value: Non-zero for setting it HIGH otherise it will set to LOW.
  */
<span class="p_del">-static void _gpio_set_open_source_value(struct gpio_desc *desc, int value)</span>
<span class="p_add">+static void _gpio_set_open_source_value(struct gpio_desc *desc, bool value)</span>
 {
 	int err = 0;
 	struct gpio_chip *chip = desc-&gt;chip;
<span class="p_chunk">@@ -2041,7 +2041,7 @@</span> <span class="p_context"> static void _gpio_set_open_source_value(struct gpio_desc *desc, int value)</span>
 			  __func__, err);
 }
 
<span class="p_del">-static void _gpiod_set_raw_value(struct gpio_desc *desc, int value)</span>
<span class="p_add">+static void _gpiod_set_raw_value(struct gpio_desc *desc, bool value)</span>
 {
 	struct gpio_chip	*chip;
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_reg.h b/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_header">index 0c83b3dab58c..5b38bf819b7b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_chunk">@@ -1181,6 +1181,7 @@</span> <span class="p_context"></span>
 #define   GMBUS_CYCLE_INDEX	(2&lt;&lt;25)
 #define   GMBUS_CYCLE_STOP	(4&lt;&lt;25)
 #define   GMBUS_BYTE_COUNT_SHIFT 16
<span class="p_add">+#define   GMBUS_BYTE_COUNT_MAX   256U</span>
 #define   GMBUS_SLAVE_INDEX_SHIFT 8
 #define   GMBUS_SLAVE_ADDR_SHIFT 1
 #define   GMBUS_SLAVE_READ	(1&lt;&lt;0)
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_i2c.c b/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_header">index d33b61d0dd33..1d02970ed395 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_chunk">@@ -324,18 +324,17 @@</span> <span class="p_context"> gmbus_wait_idle(struct drm_i915_private *dev_priv)</span>
 }
 
 static int
<span class="p_del">-gmbus_xfer_read(struct drm_i915_private *dev_priv, struct i2c_msg *msg,</span>
<span class="p_del">-		u32 gmbus1_index)</span>
<span class="p_add">+gmbus_xfer_read_chunk(struct drm_i915_private *dev_priv,</span>
<span class="p_add">+		      unsigned short addr, u8 *buf, unsigned int len,</span>
<span class="p_add">+		      u32 gmbus1_index)</span>
 {
 	int reg_offset = dev_priv-&gt;gpio_mmio_base;
<span class="p_del">-	u16 len = msg-&gt;len;</span>
<span class="p_del">-	u8 *buf = msg-&gt;buf;</span>
 
 	I915_WRITE(GMBUS1 + reg_offset,
 		   gmbus1_index |
 		   GMBUS_CYCLE_WAIT |
 		   (len &lt;&lt; GMBUS_BYTE_COUNT_SHIFT) |
<span class="p_del">-		   (msg-&gt;addr &lt;&lt; GMBUS_SLAVE_ADDR_SHIFT) |</span>
<span class="p_add">+		   (addr &lt;&lt; GMBUS_SLAVE_ADDR_SHIFT) |</span>
 		   GMBUS_SLAVE_READ | GMBUS_SW_RDY);
 	while (len) {
 		int ret;
<span class="p_chunk">@@ -357,11 +356,35 @@</span> <span class="p_context"> gmbus_xfer_read(struct drm_i915_private *dev_priv, struct i2c_msg *msg,</span>
 }
 
 static int
<span class="p_del">-gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)</span>
<span class="p_add">+gmbus_xfer_read(struct drm_i915_private *dev_priv, struct i2c_msg *msg,</span>
<span class="p_add">+		u32 gmbus1_index)</span>
 {
<span class="p_del">-	int reg_offset = dev_priv-&gt;gpio_mmio_base;</span>
<span class="p_del">-	u16 len = msg-&gt;len;</span>
 	u8 *buf = msg-&gt;buf;
<span class="p_add">+	unsigned int rx_size = msg-&gt;len;</span>
<span class="p_add">+	unsigned int len;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		len = min(rx_size, GMBUS_BYTE_COUNT_MAX);</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = gmbus_xfer_read_chunk(dev_priv, msg-&gt;addr,</span>
<span class="p_add">+					    buf, len, gmbus1_index);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		rx_size -= len;</span>
<span class="p_add">+		buf += len;</span>
<span class="p_add">+	} while (rx_size != 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int</span>
<span class="p_add">+gmbus_xfer_write_chunk(struct drm_i915_private *dev_priv,</span>
<span class="p_add">+		       unsigned short addr, u8 *buf, unsigned int len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int reg_offset = dev_priv-&gt;gpio_mmio_base;</span>
<span class="p_add">+	unsigned int chunk_size = len;</span>
 	u32 val, loop;
 
 	val = loop = 0;
<span class="p_chunk">@@ -373,8 +396,8 @@</span> <span class="p_context"> gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)</span>
 	I915_WRITE(GMBUS3 + reg_offset, val);
 	I915_WRITE(GMBUS1 + reg_offset,
 		   GMBUS_CYCLE_WAIT |
<span class="p_del">-		   (msg-&gt;len &lt;&lt; GMBUS_BYTE_COUNT_SHIFT) |</span>
<span class="p_del">-		   (msg-&gt;addr &lt;&lt; GMBUS_SLAVE_ADDR_SHIFT) |</span>
<span class="p_add">+		   (chunk_size &lt;&lt; GMBUS_BYTE_COUNT_SHIFT) |</span>
<span class="p_add">+		   (addr &lt;&lt; GMBUS_SLAVE_ADDR_SHIFT) |</span>
 		   GMBUS_SLAVE_WRITE | GMBUS_SW_RDY);
 	while (len) {
 		int ret;
<span class="p_chunk">@@ -391,6 +414,29 @@</span> <span class="p_context"> gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)</span>
 		if (ret)
 			return ret;
 	}
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int</span>
<span class="p_add">+gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 *buf = msg-&gt;buf;</span>
<span class="p_add">+	unsigned int tx_size = msg-&gt;len;</span>
<span class="p_add">+	unsigned int len;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		len = min(tx_size, GMBUS_BYTE_COUNT_MAX);</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = gmbus_xfer_write_chunk(dev_priv, msg-&gt;addr, buf, len);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		buf += len;</span>
<span class="p_add">+		tx_size -= len;</span>
<span class="p_add">+	} while (tx_size != 0);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/msm/adreno/a3xx_gpu.c b/drivers/gpu/drm/msm/adreno/a3xx_gpu.c</span>
<span class="p_header">index 461df93e825e..4f32b34f48d4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/msm/adreno/a3xx_gpu.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/msm/adreno/a3xx_gpu.c</span>
<span class="p_chunk">@@ -35,8 +35,6 @@</span> <span class="p_context"></span>
 	 A3XX_INT0_CP_AHB_ERROR_HALT |     \
 	 A3XX_INT0_UCHE_OOB_ACCESS)
 
<span class="p_del">-static struct platform_device *a3xx_pdev;</span>
<span class="p_del">-</span>
 static void a3xx_me_init(struct msm_gpu *gpu)
 {
 	struct msm_ringbuffer *ring = gpu-&gt;rb;
<span class="p_chunk">@@ -311,7 +309,6 @@</span> <span class="p_context"> static void a3xx_destroy(struct msm_gpu *gpu)</span>
 		ocmem_free(OCMEM_GRAPHICS, a3xx_gpu-&gt;ocmem_hdl);
 #endif
 
<span class="p_del">-	put_device(&amp;a3xx_gpu-&gt;pdev-&gt;dev);</span>
 	kfree(a3xx_gpu);
 }
 
<span class="p_chunk">@@ -439,7 +436,8 @@</span> <span class="p_context"> struct msm_gpu *a3xx_gpu_init(struct drm_device *dev)</span>
 	struct a3xx_gpu *a3xx_gpu = NULL;
 	struct adreno_gpu *adreno_gpu;
 	struct msm_gpu *gpu;
<span class="p_del">-	struct platform_device *pdev = a3xx_pdev;</span>
<span class="p_add">+	struct msm_drm_private *priv = dev-&gt;dev_private;</span>
<span class="p_add">+	struct platform_device *pdev = priv-&gt;gpu_pdev;</span>
 	struct adreno_platform_config *config;
 	int ret;
 
<span class="p_chunk">@@ -460,7 +458,6 @@</span> <span class="p_context"> struct msm_gpu *a3xx_gpu_init(struct drm_device *dev)</span>
 	adreno_gpu = &amp;a3xx_gpu-&gt;base;
 	gpu = &amp;adreno_gpu-&gt;base;
 
<span class="p_del">-	get_device(&amp;pdev-&gt;dev);</span>
 	a3xx_gpu-&gt;pdev = pdev;
 
 	gpu-&gt;fast_rate = config-&gt;fast_rate;
<span class="p_chunk">@@ -522,17 +519,24 @@</span> <span class="p_context"> fail:</span>
 #  include &lt;mach/kgsl.h&gt;
 #endif
 
<span class="p_del">-static int a3xx_probe(struct platform_device *pdev)</span>
<span class="p_add">+static void set_gpu_pdev(struct drm_device *dev,</span>
<span class="p_add">+		struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct msm_drm_private *priv = dev-&gt;dev_private;</span>
<span class="p_add">+	priv-&gt;gpu_pdev = pdev;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int a3xx_bind(struct device *dev, struct device *master, void *data)</span>
 {
 	static struct adreno_platform_config config = {};
 #ifdef CONFIG_OF
<span class="p_del">-	struct device_node *child, *node = pdev-&gt;dev.of_node;</span>
<span class="p_add">+	struct device_node *child, *node = dev-&gt;of_node;</span>
 	u32 val;
 	int ret;
 
 	ret = of_property_read_u32(node, &quot;qcom,chipid&quot;, &amp;val);
 	if (ret) {
<span class="p_del">-		dev_err(&amp;pdev-&gt;dev, &quot;could not find chipid: %d\n&quot;, ret);</span>
<span class="p_add">+		dev_err(dev, &quot;could not find chipid: %d\n&quot;, ret);</span>
 		return ret;
 	}
 
<span class="p_chunk">@@ -548,7 +552,7 @@</span> <span class="p_context"> static int a3xx_probe(struct platform_device *pdev)</span>
 			for_each_child_of_node(child, pwrlvl) {
 				ret = of_property_read_u32(pwrlvl, &quot;qcom,gpu-freq&quot;, &amp;val);
 				if (ret) {
<span class="p_del">-					dev_err(&amp;pdev-&gt;dev, &quot;could not find gpu-freq: %d\n&quot;, ret);</span>
<span class="p_add">+					dev_err(dev, &quot;could not find gpu-freq: %d\n&quot;, ret);</span>
 					return ret;
 				}
 				config.fast_rate = max(config.fast_rate, val);
<span class="p_chunk">@@ -558,12 +562,12 @@</span> <span class="p_context"> static int a3xx_probe(struct platform_device *pdev)</span>
 	}
 
 	if (!config.fast_rate) {
<span class="p_del">-		dev_err(&amp;pdev-&gt;dev, &quot;could not find clk rates\n&quot;);</span>
<span class="p_add">+		dev_err(dev, &quot;could not find clk rates\n&quot;);</span>
 		return -ENXIO;
 	}
 
 #else
<span class="p_del">-	struct kgsl_device_platform_data *pdata = pdev-&gt;dev.platform_data;</span>
<span class="p_add">+	struct kgsl_device_platform_data *pdata = dev-&gt;platform_data;</span>
 	uint32_t version = socinfo_get_version();
 	if (cpu_is_apq8064ab()) {
 		config.fast_rate = 450000000;
<span class="p_chunk">@@ -609,14 +613,30 @@</span> <span class="p_context"> static int a3xx_probe(struct platform_device *pdev)</span>
 	config.bus_scale_table = pdata-&gt;bus_scale_table;
 #  endif
 #endif
<span class="p_del">-	pdev-&gt;dev.platform_data = &amp;config;</span>
<span class="p_del">-	a3xx_pdev = pdev;</span>
<span class="p_add">+	dev-&gt;platform_data = &amp;config;</span>
<span class="p_add">+	set_gpu_pdev(dev_get_drvdata(master), to_platform_device(dev));</span>
 	return 0;
 }
 
<span class="p_add">+static void a3xx_unbind(struct device *dev, struct device *master,</span>
<span class="p_add">+		void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	set_gpu_pdev(dev_get_drvdata(master), NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct component_ops a3xx_ops = {</span>
<span class="p_add">+		.bind   = a3xx_bind,</span>
<span class="p_add">+		.unbind = a3xx_unbind,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int a3xx_probe(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return component_add(&amp;pdev-&gt;dev, &amp;a3xx_ops);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int a3xx_remove(struct platform_device *pdev)
 {
<span class="p_del">-	a3xx_pdev = NULL;</span>
<span class="p_add">+	component_del(&amp;pdev-&gt;dev, &amp;a3xx_ops);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -624,7 +644,6 @@</span> <span class="p_context"> static const struct of_device_id dt_match[] = {</span>
 	{ .compatible = &quot;qcom,kgsl-3d0&quot; },
 	{}
 };
<span class="p_del">-MODULE_DEVICE_TABLE(of, dt_match);</span>
 
 static struct platform_driver a3xx_driver = {
 	.probe = a3xx_probe,
<span class="p_header">diff --git a/drivers/gpu/drm/msm/hdmi/hdmi.c b/drivers/gpu/drm/msm/hdmi/hdmi.c</span>
<span class="p_header">index 6f1588aa9071..8a04a1d206cd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/msm/hdmi/hdmi.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/msm/hdmi/hdmi.c</span>
<span class="p_chunk">@@ -17,8 +17,6 @@</span> <span class="p_context"></span>
 
 #include &quot;hdmi.h&quot;
 
<span class="p_del">-static struct platform_device *hdmi_pdev;</span>
<span class="p_del">-</span>
 void hdmi_set_mode(struct hdmi *hdmi, bool power_on)
 {
 	uint32_t ctrl = 0;
<span class="p_chunk">@@ -75,7 +73,7 @@</span> <span class="p_context"> struct hdmi *hdmi_init(struct drm_device *dev, struct drm_encoder *encoder)</span>
 {
 	struct hdmi *hdmi = NULL;
 	struct msm_drm_private *priv = dev-&gt;dev_private;
<span class="p_del">-	struct platform_device *pdev = hdmi_pdev;</span>
<span class="p_add">+	struct platform_device *pdev = priv-&gt;hdmi_pdev;</span>
 	struct hdmi_platform_config *config;
 	int i, ret;
 
<span class="p_chunk">@@ -95,8 +93,6 @@</span> <span class="p_context"> struct hdmi *hdmi_init(struct drm_device *dev, struct drm_encoder *encoder)</span>
 
 	kref_init(&amp;hdmi-&gt;refcount);
 
<span class="p_del">-	get_device(&amp;pdev-&gt;dev);</span>
<span class="p_del">-</span>
 	hdmi-&gt;dev = dev;
 	hdmi-&gt;pdev = pdev;
 	hdmi-&gt;config = config;
<span class="p_chunk">@@ -249,17 +245,24 @@</span> <span class="p_context"> fail:</span>
 
 #include &lt;linux/of_gpio.h&gt;
 
<span class="p_del">-static int hdmi_dev_probe(struct platform_device *pdev)</span>
<span class="p_add">+static void set_hdmi_pdev(struct drm_device *dev,</span>
<span class="p_add">+		struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct msm_drm_private *priv = dev-&gt;dev_private;</span>
<span class="p_add">+	priv-&gt;hdmi_pdev = pdev;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hdmi_bind(struct device *dev, struct device *master, void *data)</span>
 {
 	static struct hdmi_platform_config config = {};
 #ifdef CONFIG_OF
<span class="p_del">-	struct device_node *of_node = pdev-&gt;dev.of_node;</span>
<span class="p_add">+	struct device_node *of_node = dev-&gt;of_node;</span>
 
 	int get_gpio(const char *name)
 	{
 		int gpio = of_get_named_gpio(of_node, name, 0);
 		if (gpio &lt; 0) {
<span class="p_del">-			dev_err(&amp;pdev-&gt;dev, &quot;failed to get gpio: %s (%d)\n&quot;,</span>
<span class="p_add">+			dev_err(dev, &quot;failed to get gpio: %s (%d)\n&quot;,</span>
 					name, gpio);
 			gpio = -1;
 		}
<span class="p_chunk">@@ -336,14 +339,30 @@</span> <span class="p_context"> static int hdmi_dev_probe(struct platform_device *pdev)</span>
 		config.mux_sel_gpio  = -1;
 	}
 #endif
<span class="p_del">-	pdev-&gt;dev.platform_data = &amp;config;</span>
<span class="p_del">-	hdmi_pdev = pdev;</span>
<span class="p_add">+	dev-&gt;platform_data = &amp;config;</span>
<span class="p_add">+	set_hdmi_pdev(dev_get_drvdata(master), to_platform_device(dev));</span>
 	return 0;
 }
 
<span class="p_add">+static void hdmi_unbind(struct device *dev, struct device *master,</span>
<span class="p_add">+		void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	set_hdmi_pdev(dev_get_drvdata(master), NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct component_ops hdmi_ops = {</span>
<span class="p_add">+		.bind   = hdmi_bind,</span>
<span class="p_add">+		.unbind = hdmi_unbind,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int hdmi_dev_probe(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return component_add(&amp;pdev-&gt;dev, &amp;hdmi_ops);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int hdmi_dev_remove(struct platform_device *pdev)
 {
<span class="p_del">-	hdmi_pdev = NULL;</span>
<span class="p_add">+	component_del(&amp;pdev-&gt;dev, &amp;hdmi_ops);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -351,7 +370,6 @@</span> <span class="p_context"> static const struct of_device_id dt_match[] = {</span>
 	{ .compatible = &quot;qcom,hdmi-tx&quot; },
 	{}
 };
<span class="p_del">-MODULE_DEVICE_TABLE(of, dt_match);</span>
 
 static struct platform_driver hdmi_driver = {
 	.probe = hdmi_dev_probe,
<span class="p_header">diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c</span>
<span class="p_header">index e6adafc7eff3..e79cfd0b2b04 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/msm/msm_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/msm/msm_drv.c</span>
<span class="p_chunk">@@ -56,6 +56,10 @@</span> <span class="p_context"> static char *vram;</span>
 MODULE_PARM_DESC(vram, &quot;Configure VRAM size (for devices without IOMMU/GPUMMU&quot;);
 module_param(vram, charp, 0);
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Util/helpers:</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
 void __iomem *msm_ioremap(struct platform_device *pdev, const char *name,
 		const char *dbgname)
 {
<span class="p_chunk">@@ -143,6 +147,8 @@</span> <span class="p_context"> static int msm_unload(struct drm_device *dev)</span>
 				priv-&gt;vram.paddr, &amp;attrs);
 	}
 
<span class="p_add">+	component_unbind_all(dev-&gt;dev, dev);</span>
<span class="p_add">+</span>
 	dev-&gt;dev_private = NULL;
 
 	kfree(priv);
<span class="p_chunk">@@ -175,6 +181,7 @@</span> <span class="p_context"> static int msm_load(struct drm_device *dev, unsigned long flags)</span>
 	struct msm_kms *kms;
 	int ret;
 
<span class="p_add">+</span>
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv) {
 		dev_err(dev-&gt;dev, &quot;failed to allocate private data\n&quot;);
<span class="p_chunk">@@ -226,6 +233,13 @@</span> <span class="p_context"> static int msm_load(struct drm_device *dev, unsigned long flags)</span>
 				(uint32_t)(priv-&gt;vram.paddr + size));
 	}
 
<span class="p_add">+	platform_set_drvdata(pdev, dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Bind all our sub-components: */</span>
<span class="p_add">+	ret = component_bind_all(dev-&gt;dev, dev);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
 	switch (get_mdp_ver(pdev)) {
 	case 4:
 		kms = mdp4_kms_init(dev);
<span class="p_chunk">@@ -281,8 +295,6 @@</span> <span class="p_context"> static int msm_load(struct drm_device *dev, unsigned long flags)</span>
 		goto fail;
 	}
 
<span class="p_del">-	platform_set_drvdata(pdev, dev);</span>
<span class="p_del">-</span>
 #ifdef CONFIG_DRM_MSM_FBDEV
 	priv-&gt;fbdev = msm_fbdev_init(dev);
 #endif
<span class="p_chunk">@@ -819,18 +831,110 @@</span> <span class="p_context"> static const struct dev_pm_ops msm_pm_ops = {</span>
 };
 
 /*
<span class="p_add">+ * Componentized driver support:</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_OF</span>
<span class="p_add">+/* NOTE: the CONFIG_OF case duplicates the same code as exynos or imx</span>
<span class="p_add">+ * (or probably any other).. so probably some room for some helpers</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int compare_of(struct device *dev, void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return dev-&gt;of_node == data;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int msm_drm_add_components(struct device *master, struct master *m)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *np = master-&gt;of_node;</span>
<span class="p_add">+	unsigned i;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; ; i++) {</span>
<span class="p_add">+		struct device_node *node;</span>
<span class="p_add">+</span>
<span class="p_add">+		node = of_parse_phandle(np, &quot;connectors&quot;, i);</span>
<span class="p_add">+		if (!node)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = component_master_add_child(m, compare_of, node);</span>
<span class="p_add">+		of_node_put(node);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+static int compare_dev(struct device *dev, void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return dev == data;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int msm_drm_add_components(struct device *master, struct master *m)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* For non-DT case, it kinda sucks.  We don&#39;t actually have a way</span>
<span class="p_add">+	 * to know whether or not we are waiting for certain devices (or if</span>
<span class="p_add">+	 * they are simply not present).  But for non-DT we only need to</span>
<span class="p_add">+	 * care about apq8064/apq8060/etc (all mdp4/a3xx):</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	static const char *devnames[] = {</span>
<span class="p_add">+			&quot;hdmi_msm.0&quot;, &quot;kgsl-3d0.0&quot;,</span>
<span class="p_add">+	};</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	DBG(&quot;Adding components..&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(devnames); i++) {</span>
<span class="p_add">+		struct device *dev;</span>
<span class="p_add">+		int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		dev = bus_find_device_by_name(&amp;platform_bus_type,</span>
<span class="p_add">+				NULL, devnames[i]);</span>
<span class="p_add">+		if (!dev) {</span>
<span class="p_add">+			dev_info(master, &quot;still waiting for %s\n&quot;, devnames[i]);</span>
<span class="p_add">+			return -EPROBE_DEFER;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = component_master_add_child(m, compare_dev, dev);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			DBG(&quot;could not add child: %d&quot;, ret);</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static int msm_drm_bind(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return drm_platform_init(&amp;msm_driver, to_platform_device(dev));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void msm_drm_unbind(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	drm_put_dev(platform_get_drvdata(to_platform_device(dev)));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct component_master_ops msm_drm_ops = {</span>
<span class="p_add">+		.add_components = msm_drm_add_components,</span>
<span class="p_add">+		.bind = msm_drm_bind,</span>
<span class="p_add">+		.unbind = msm_drm_unbind,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Platform driver:
  */
 
 static int msm_pdev_probe(struct platform_device *pdev)
 {
 	pdev-&gt;dev.coherent_dma_mask = DMA_BIT_MASK(32);
<span class="p_del">-	return drm_platform_init(&amp;msm_driver, pdev);</span>
<span class="p_add">+	return component_master_add(&amp;pdev-&gt;dev, &amp;msm_drm_ops);</span>
 }
 
 static int msm_pdev_remove(struct platform_device *pdev)
 {
<span class="p_del">-	drm_put_dev(platform_get_drvdata(pdev));</span>
<span class="p_add">+	component_master_del(&amp;pdev-&gt;dev, &amp;msm_drm_ops);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/msm/msm_drv.h b/drivers/gpu/drm/msm/msm_drv.h</span>
<span class="p_header">index 3d63269c5b29..9d10ee0b5aac 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/msm/msm_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/msm/msm_drv.h</span>
<span class="p_chunk">@@ -22,6 +22,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/clk.h&gt;
 #include &lt;linux/cpufreq.h&gt;
 #include &lt;linux/module.h&gt;
<span class="p_add">+#include &lt;linux/component.h&gt;</span>
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/pm.h&gt;
 #include &lt;linux/pm_runtime.h&gt;
<span class="p_chunk">@@ -69,6 +70,9 @@</span> <span class="p_context"> struct msm_drm_private {</span>
 
 	struct msm_kms *kms;
 
<span class="p_add">+	/* subordinate devices, if present: */</span>
<span class="p_add">+	struct platform_device *hdmi_pdev, *gpu_pdev;</span>
<span class="p_add">+</span>
 	/* when we have more than one &#39;msm_gpu&#39; these need to be an array: */
 	struct msm_gpu *gpu;
 	struct msm_file_private *lastctx;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_crtc.c b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">index 663394f0c166..0db3e208f02a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_chunk">@@ -330,8 +330,10 @@</span> <span class="p_context"> atombios_set_crtc_dtd_timing(struct drm_crtc *crtc,</span>
 		misc |= ATOM_COMPOSITESYNC;
 	if (mode-&gt;flags &amp; DRM_MODE_FLAG_INTERLACE)
 		misc |= ATOM_INTERLACE;
<span class="p_del">-	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLCLK)</span>
 		misc |= ATOM_DOUBLE_CLOCK_MODE;
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+		misc |= ATOM_H_REPLICATIONBY2 | ATOM_V_REPLICATIONBY2;</span>
 
 	args.susModeMiscInfo.usAccess = cpu_to_le16(misc);
 	args.ucCRTC = radeon_crtc-&gt;crtc_id;
<span class="p_chunk">@@ -374,8 +376,10 @@</span> <span class="p_context"> static void atombios_crtc_set_timing(struct drm_crtc *crtc,</span>
 		misc |= ATOM_COMPOSITESYNC;
 	if (mode-&gt;flags &amp; DRM_MODE_FLAG_INTERLACE)
 		misc |= ATOM_INTERLACE;
<span class="p_del">-	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLCLK)</span>
 		misc |= ATOM_DOUBLE_CLOCK_MODE;
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+		misc |= ATOM_H_REPLICATIONBY2 | ATOM_V_REPLICATIONBY2;</span>
 
 	args.susModeMiscInfo.usAccess = cpu_to_le16(misc);
 	args.ucCRTC = radeon_crtc-&gt;crtc_id;
<span class="p_header">diff --git a/drivers/hv/channel.c b/drivers/hv/channel.c</span>
<span class="p_header">index e99e71a6ea59..356f22f90a05 100644</span>
<span class="p_header">--- a/drivers/hv/channel.c</span>
<span class="p_header">+++ b/drivers/hv/channel.c</span>
<span class="p_chunk">@@ -134,7 +134,7 @@</span> <span class="p_context"> int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,</span>
 			   GFP_KERNEL);
 	if (!open_info) {
 		err = -ENOMEM;
<span class="p_del">-		goto error0;</span>
<span class="p_add">+		goto error_gpadl;</span>
 	}
 
 	init_completion(&amp;open_info-&gt;waitevent);
<span class="p_chunk">@@ -150,7 +150,7 @@</span> <span class="p_context"> int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,</span>
 
 	if (userdatalen &gt; MAX_USER_DEFINED_BYTES) {
 		err = -EINVAL;
<span class="p_del">-		goto error0;</span>
<span class="p_add">+		goto error_gpadl;</span>
 	}
 
 	if (userdatalen)
<span class="p_chunk">@@ -194,6 +194,9 @@</span> <span class="p_context"> error1:</span>
 	list_del(&amp;open_info-&gt;msglistentry);
 	spin_unlock_irqrestore(&amp;vmbus_connection.channelmsg_lock, flags);
 
<span class="p_add">+error_gpadl:</span>
<span class="p_add">+	vmbus_teardown_gpadl(newchannel, newchannel-&gt;ringbuffer_gpadlhandle);</span>
<span class="p_add">+</span>
 error0:
 	free_pages((unsigned long)out,
 		get_order(send_ringbuffer_size + recv_ringbuffer_size));
<span class="p_header">diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c</span>
<span class="p_header">index 5fb80b8962a2..43fe15a0e5cc 100644</span>
<span class="p_header">--- a/drivers/i2c/i2c-core.c</span>
<span class="p_header">+++ b/drivers/i2c/i2c-core.c</span>
<span class="p_chunk">@@ -217,6 +217,7 @@</span> <span class="p_context"> int i2c_generic_scl_recovery(struct i2c_adapter *adap)</span>
 	adap-&gt;bus_recovery_info-&gt;set_scl(adap, 1);
 	return i2c_generic_recovery(adap);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(i2c_generic_scl_recovery);</span>
 
 int i2c_generic_gpio_recovery(struct i2c_adapter *adap)
 {
<span class="p_chunk">@@ -231,6 +232,7 @@</span> <span class="p_context"> int i2c_generic_gpio_recovery(struct i2c_adapter *adap)</span>
 
 	return ret;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(i2c_generic_gpio_recovery);</span>
 
 int i2c_recover_bus(struct i2c_adapter *adap)
 {
<span class="p_chunk">@@ -240,6 +242,7 @@</span> <span class="p_context"> int i2c_recover_bus(struct i2c_adapter *adap)</span>
 	dev_dbg(&amp;adap-&gt;dev, &quot;Trying i2c bus recovery\n&quot;);
 	return adap-&gt;bus_recovery_info-&gt;recover_bus(adap);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(i2c_recover_bus);</span>
 
 static int i2c_device_probe(struct device *dev)
 {
<span class="p_header">diff --git a/drivers/infiniband/core/umem.c b/drivers/infiniband/core/umem.c</span>
<span class="p_header">index 055ebebc07dd..c1fef27010d4 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/umem.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/umem.c</span>
<span class="p_chunk">@@ -94,12 +94,15 @@</span> <span class="p_context"> struct ib_umem *ib_umem_get(struct ib_ucontext *context, unsigned long addr,</span>
 	if (dmasync)
 		dma_set_attr(DMA_ATTR_WRITE_BARRIER, &amp;attrs);
 
<span class="p_add">+	if (!size)</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
 	/*
 	 * If the combination of the addr and size requested for this memory
 	 * region causes an integer overflow, return error.
 	 */
<span class="p_del">-	if ((PAGE_ALIGN(addr + size) &lt;= size) ||</span>
<span class="p_del">-	    (PAGE_ALIGN(addr + size) &lt;= addr))</span>
<span class="p_add">+	if (((addr + size) &lt; addr) ||</span>
<span class="p_add">+	    PAGE_ALIGN(addr + size) &lt; (addr + size))</span>
 		return ERR_PTR(-EINVAL);
 
 	if (!can_do_mlock())
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">index d8f4d1fe8494..8d7cd98c9671 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_chunk">@@ -2274,8 +2274,7 @@</span> <span class="p_context"> static int build_lso_seg(struct mlx4_wqe_lso_seg *wqe, struct ib_send_wr *wr,</span>
 
 	memcpy(wqe-&gt;header, wr-&gt;wr.ud.header, wr-&gt;wr.ud.hlen);
 
<span class="p_del">-	*lso_hdr_sz  = cpu_to_be32((wr-&gt;wr.ud.mss - wr-&gt;wr.ud.hlen) &lt;&lt; 16 |</span>
<span class="p_del">-				   wr-&gt;wr.ud.hlen);</span>
<span class="p_add">+	*lso_hdr_sz  = cpu_to_be32(wr-&gt;wr.ud.mss &lt;&lt; 16 | wr-&gt;wr.ud.hlen);</span>
 	*lso_seg_len = halign;
 	return 0;
 }
<span class="p_header">diff --git a/drivers/input/mouse/elantech.c b/drivers/input/mouse/elantech.c</span>
<span class="p_header">index 0b75b5764f31..cfc5a2e6dcce 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.c</span>
<span class="p_chunk">@@ -814,6 +814,21 @@</span> <span class="p_context"> static psmouse_ret_t elantech_process_byte(struct psmouse *psmouse)</span>
 }
 
 /*
<span class="p_add">+ * This writes the reg_07 value again to the hardware at the end of every</span>
<span class="p_add">+ * set_rate call because the register loses its value. reg_07 allows setting</span>
<span class="p_add">+ * absolute mode on v4 hardware</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void elantech_set_rate_restore_reg_07(struct psmouse *psmouse,</span>
<span class="p_add">+		unsigned int rate)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct elantech_data *etd = psmouse-&gt;private;</span>
<span class="p_add">+</span>
<span class="p_add">+	etd-&gt;original_set_rate(psmouse, rate);</span>
<span class="p_add">+	if (elantech_write_reg(psmouse, 0x07, etd-&gt;reg_07))</span>
<span class="p_add">+		psmouse_err(psmouse, &quot;restoring reg_07 failed\n&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Put the touchpad into absolute mode
  */
 static int elantech_set_absolute_mode(struct psmouse *psmouse)
<span class="p_chunk">@@ -1015,6 +1030,8 @@</span> <span class="p_context"> static int elantech_get_resolution_v4(struct psmouse *psmouse,</span>
  * Asus K53SV              0x450f01        78, 15, 0c      2 hw buttons
  * Asus G46VW              0x460f02        00, 18, 0c      2 hw buttons
  * Asus G750JX             0x360f00        00, 16, 0c      2 hw buttons
<span class="p_add">+ * Asus TP500LN            0x381f17        10, 14, 0e      clickpad</span>
<span class="p_add">+ * Asus X750JN             0x381f17        10, 14, 0e      clickpad</span>
  * Asus UX31               0x361f00        20, 15, 0e      clickpad
  * Asus UX32VD             0x361f02        00, 15, 0e      clickpad
  * Avatar AVIU-145A2       0x361f00        ?               clickpad
<span class="p_chunk">@@ -1490,6 +1507,11 @@</span> <span class="p_context"> int elantech_init(struct psmouse *psmouse)</span>
 		goto init_fail;
 	}
 
<span class="p_add">+	if (etd-&gt;fw_version == 0x381f17) {</span>
<span class="p_add">+		etd-&gt;original_set_rate = psmouse-&gt;set_rate;</span>
<span class="p_add">+		psmouse-&gt;set_rate = elantech_set_rate_restore_reg_07;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (elantech_set_input_params(psmouse)) {
 		psmouse_err(psmouse, &quot;failed to query touchpad range.\n&quot;);
 		goto init_fail;
<span class="p_header">diff --git a/drivers/input/mouse/elantech.h b/drivers/input/mouse/elantech.h</span>
<span class="p_header">index 9e0e2a1f340d..59263a3a8667 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.h</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.h</span>
<span class="p_chunk">@@ -139,6 +139,7 @@</span> <span class="p_context"> struct elantech_data {</span>
 	struct finger_pos mt[ETP_MAX_FINGERS];
 	unsigned char parity[256];
 	int (*send_cmd)(struct psmouse *psmouse, unsigned char c, unsigned char *param);
<span class="p_add">+	void (*original_set_rate)(struct psmouse *psmouse, unsigned int rate);</span>
 };
 
 #ifdef CONFIG_MOUSE_PS2_ELANTECH
<span class="p_header">diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c</span>
<span class="p_header">index 4a8d19d0a5a4..5a4cda24e302 100644</span>
<span class="p_header">--- a/drivers/md/dm-crypt.c</span>
<span class="p_header">+++ b/drivers/md/dm-crypt.c</span>
<span class="p_chunk">@@ -915,11 +915,10 @@</span> <span class="p_context"> static int crypt_convert(struct crypt_config *cc,</span>
 
 		switch (r) {
 		/* async */
<span class="p_add">+		case -EINPROGRESS:</span>
 		case -EBUSY:
 			wait_for_completion(&amp;ctx-&gt;restart);
 			reinit_completion(&amp;ctx-&gt;restart);
<span class="p_del">-			/* fall through*/</span>
<span class="p_del">-		case -EINPROGRESS:</span>
 			ctx-&gt;req = NULL;
 			ctx-&gt;cc_sector++;
 			continue;
<span class="p_chunk">@@ -1314,10 +1313,8 @@</span> <span class="p_context"> static void kcryptd_async_done(struct crypto_async_request *async_req,</span>
 	struct dm_crypt_io *io = container_of(ctx, struct dm_crypt_io, ctx);
 	struct crypt_config *cc = io-&gt;cc;
 
<span class="p_del">-	if (error == -EINPROGRESS) {</span>
<span class="p_del">-		complete(&amp;ctx-&gt;restart);</span>
<span class="p_add">+	if (error == -EINPROGRESS)</span>
 		return;
<span class="p_del">-	}</span>
 
 	if (!error &amp;&amp; cc-&gt;iv_gen_ops &amp;&amp; cc-&gt;iv_gen_ops-&gt;post)
 		error = cc-&gt;iv_gen_ops-&gt;post(cc, iv_of_dmreq(cc, dmreq), dmreq);
<span class="p_chunk">@@ -1328,12 +1325,15 @@</span> <span class="p_context"> static void kcryptd_async_done(struct crypto_async_request *async_req,</span>
 	mempool_free(req_of_dmreq(cc, dmreq), cc-&gt;req_pool);
 
 	if (!atomic_dec_and_test(&amp;ctx-&gt;cc_pending))
<span class="p_del">-		return;</span>
<span class="p_add">+		goto done;</span>
 
 	if (bio_data_dir(io-&gt;base_bio) == READ)
 		kcryptd_crypt_read_done(io);
 	else
 		kcryptd_crypt_write_io_submit(io, 1);
<span class="p_add">+done:</span>
<span class="p_add">+	if (!completion_done(&amp;ctx-&gt;restart))</span>
<span class="p_add">+		complete(&amp;ctx-&gt;restart);</span>
 }
 
 static void kcryptd_crypt(struct work_struct *work)
<span class="p_header">diff --git a/drivers/md/raid0.c b/drivers/md/raid0.c</span>
<span class="p_header">index 407a99e46f69..683e685ed697 100644</span>
<span class="p_header">--- a/drivers/md/raid0.c</span>
<span class="p_header">+++ b/drivers/md/raid0.c</span>
<span class="p_chunk">@@ -320,7 +320,7 @@</span> <span class="p_context"> static struct strip_zone *find_zone(struct r0conf *conf,</span>
 
 /*
  * remaps the bio to the target device. we separate two flows.
<span class="p_del">- * power 2 flow and a general flow for the sake of perfromance</span>
<span class="p_add">+ * power 2 flow and a general flow for the sake of performance</span>
 */
 static struct md_rdev *map_sector(struct mddev *mddev, struct strip_zone *zone,
 				sector_t sector, sector_t *sector_offset)
<span class="p_chunk">@@ -538,6 +538,7 @@</span> <span class="p_context"> static void raid0_make_request(struct mddev *mddev, struct bio *bio)</span>
 			split = bio;
 		}
 
<span class="p_add">+		sector = bio-&gt;bi_iter.bi_sector;</span>
 		zone = find_zone(mddev-&gt;private, &amp;sector);
 		tmp_dev = map_sector(mddev, zone, sector, &amp;sector);
 		split-&gt;bi_bdev = tmp_dev-&gt;bdev;
<span class="p_header">diff --git a/drivers/media/usb/stk1160/stk1160-v4l.c b/drivers/media/usb/stk1160/stk1160-v4l.c</span>
<span class="p_header">index c45c9881bb5f..4572530346fb 100644</span>
<span class="p_header">--- a/drivers/media/usb/stk1160/stk1160-v4l.c</span>
<span class="p_header">+++ b/drivers/media/usb/stk1160/stk1160-v4l.c</span>
<span class="p_chunk">@@ -244,6 +244,11 @@</span> <span class="p_context"> static int stk1160_stop_streaming(struct stk1160 *dev)</span>
 	if (mutex_lock_interruptible(&amp;dev-&gt;v4l_lock))
 		return -ERESTARTSYS;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Once URBs are cancelled, the URB complete handler</span>
<span class="p_add">+	 * won&#39;t be running. This is required to safely release the</span>
<span class="p_add">+	 * current buffer (dev-&gt;isoc_ctl.buf).</span>
<span class="p_add">+	 */</span>
 	stk1160_cancel_isoc(dev);
 
 	/*
<span class="p_chunk">@@ -624,8 +629,16 @@</span> <span class="p_context"> void stk1160_clear_queue(struct stk1160 *dev)</span>
 		stk1160_info(&quot;buffer [%p/%d] aborted\n&quot;,
 				buf, buf-&gt;vb.v4l2_buf.index);
 	}
<span class="p_del">-	/* It&#39;s important to clear current buffer */</span>
<span class="p_del">-	dev-&gt;isoc_ctl.buf = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* It&#39;s important to release the current buffer */</span>
<span class="p_add">+	if (dev-&gt;isoc_ctl.buf) {</span>
<span class="p_add">+		buf = dev-&gt;isoc_ctl.buf;</span>
<span class="p_add">+		dev-&gt;isoc_ctl.buf = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+		vb2_buffer_done(&amp;buf-&gt;vb, VB2_BUF_STATE_ERROR);</span>
<span class="p_add">+		stk1160_info(&quot;buffer [%p/%d] aborted\n&quot;,</span>
<span class="p_add">+				buf, buf-&gt;vb.v4l2_buf.index);</span>
<span class="p_add">+	}</span>
 	spin_unlock_irqrestore(&amp;dev-&gt;buf_lock, flags);
 }
 
<span class="p_header">diff --git a/drivers/memstick/core/mspro_block.c b/drivers/memstick/core/mspro_block.c</span>
<span class="p_header">index fc145d202c46..922a750640e8 100644</span>
<span class="p_header">--- a/drivers/memstick/core/mspro_block.c</span>
<span class="p_header">+++ b/drivers/memstick/core/mspro_block.c</span>
<span class="p_chunk">@@ -758,7 +758,7 @@</span> <span class="p_context"> static int mspro_block_complete_req(struct memstick_dev *card, int error)</span>
 
 		if (error || (card-&gt;current_mrq.tpc == MSPRO_CMD_STOP)) {
 			if (msb-&gt;data_dir == READ) {
<span class="p_del">-				for (cnt = 0; cnt &lt; msb-&gt;current_seg; cnt++)</span>
<span class="p_add">+				for (cnt = 0; cnt &lt; msb-&gt;current_seg; cnt++) {</span>
 					t_len += msb-&gt;req_sg[cnt].length
 						 / msb-&gt;page_size;
 
<span class="p_chunk">@@ -766,6 +766,7 @@</span> <span class="p_context"> static int mspro_block_complete_req(struct memstick_dev *card, int error)</span>
 						t_len += msb-&gt;current_page - 1;
 
 					t_len *= msb-&gt;page_size;
<span class="p_add">+				}</span>
 			}
 		} else
 			t_len = blk_rq_bytes(msb-&gt;block_req);
<span class="p_header">diff --git a/drivers/mtd/ubi/attach.c b/drivers/mtd/ubi/attach.c</span>
<span class="p_header">index 6f27d9a1be3b..21841fe25ad3 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/attach.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/attach.c</span>
<span class="p_chunk">@@ -408,7 +408,7 @@</span> <span class="p_context"> int ubi_compare_lebs(struct ubi_device *ubi, const struct ubi_ainf_peb *aeb,</span>
 		second_is_newer = !second_is_newer;
 	} else {
 		dbg_bld(&quot;PEB %d CRC is OK&quot;, pnum);
<span class="p_del">-		bitflips = !!err;</span>
<span class="p_add">+		bitflips |= !!err;</span>
 	}
 	mutex_unlock(&amp;ubi-&gt;buf_mutex);
 
<span class="p_header">diff --git a/drivers/mtd/ubi/cdev.c b/drivers/mtd/ubi/cdev.c</span>
<span class="p_header">index 8ca49f2043e4..4cbbd5531133 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/cdev.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/cdev.c</span>
<span class="p_chunk">@@ -451,7 +451,7 @@</span> <span class="p_context"> static long vol_cdev_ioctl(struct file *file, unsigned int cmd,</span>
 		/* Validate the request */
 		err = -EINVAL;
 		if (req.lnum &lt; 0 || req.lnum &gt;= vol-&gt;reserved_pebs ||
<span class="p_del">-		    req.bytes &lt; 0 || req.lnum &gt;= vol-&gt;usable_leb_size)</span>
<span class="p_add">+		    req.bytes &lt; 0 || req.bytes &gt; vol-&gt;usable_leb_size)</span>
 			break;
 
 		err = get_exclusive(desc);
<span class="p_header">diff --git a/drivers/mtd/ubi/eba.c b/drivers/mtd/ubi/eba.c</span>
<span class="p_header">index 0e11671dadc4..930cf2c77abb 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/eba.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/eba.c</span>
<span class="p_chunk">@@ -1362,7 +1362,8 @@</span> <span class="p_context"> int ubi_eba_init(struct ubi_device *ubi, struct ubi_attach_info *ai)</span>
 				 * during re-size.
 				 */
 				ubi_move_aeb_to_list(av, aeb, &amp;ai-&gt;erase);
<span class="p_del">-			vol-&gt;eba_tbl[aeb-&gt;lnum] = aeb-&gt;pnum;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				vol-&gt;eba_tbl[aeb-&gt;lnum] = aeb-&gt;pnum;</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/mtd/ubi/wl.c b/drivers/mtd/ubi/wl.c</span>
<span class="p_header">index 68b924ec222e..c6b0b078ab99 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/wl.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/wl.c</span>
<span class="p_chunk">@@ -995,7 +995,7 @@</span> <span class="p_context"> static int wear_leveling_worker(struct ubi_device *ubi, struct ubi_work *wrk,</span>
 				int cancel)
 {
 	int err, scrubbing = 0, torture = 0, protect = 0, erroneous = 0;
<span class="p_del">-	int vol_id = -1, uninitialized_var(lnum);</span>
<span class="p_add">+	int vol_id = -1, lnum = -1;</span>
 #ifdef CONFIG_MTD_UBI_FASTMAP
 	int anchor = wrk-&gt;anchor;
 #endif
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000/e1000_main.c b/drivers/net/ethernet/intel/e1000/e1000_main.c</span>
<span class="p_header">index 46e6544ed1b7..b655fe4f4c2e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000/e1000_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000/e1000_main.c</span>
<span class="p_chunk">@@ -144,6 +144,11 @@</span> <span class="p_context"> static bool e1000_clean_rx_irq(struct e1000_adapter *adapter,</span>
 static bool e1000_clean_jumbo_rx_irq(struct e1000_adapter *adapter,
 				     struct e1000_rx_ring *rx_ring,
 				     int *work_done, int work_to_do);
<span class="p_add">+static void e1000_alloc_dummy_rx_buffers(struct e1000_adapter *adapter,</span>
<span class="p_add">+					 struct e1000_rx_ring *rx_ring,</span>
<span class="p_add">+					 int cleaned_count)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
 static void e1000_alloc_rx_buffers(struct e1000_adapter *adapter,
 				   struct e1000_rx_ring *rx_ring,
 				   int cleaned_count);
<span class="p_chunk">@@ -3531,8 +3536,11 @@</span> <span class="p_context"> static int e1000_change_mtu(struct net_device *netdev, int new_mtu)</span>
 		msleep(1);
 	/* e1000_down has a dependency on max_frame_size */
 	hw-&gt;max_frame_size = max_frame;
<span class="p_del">-	if (netif_running(netdev))</span>
<span class="p_add">+	if (netif_running(netdev)) {</span>
<span class="p_add">+		/* prevent buffers from being reallocated */</span>
<span class="p_add">+		adapter-&gt;alloc_rx_buf = e1000_alloc_dummy_rx_buffers;</span>
 		e1000_down(adapter);
<span class="p_add">+	}</span>
 
 	/* NOTE: netdev_alloc_skb reserves 16 bytes, and typically NET_IP_ALIGN
 	 * means we reserve 2 more, this pushes us to allocate from the next
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_header">index f58316769159..66c92a16da29 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_chunk">@@ -314,6 +314,7 @@</span> <span class="p_context"> static struct usb_device_id rtl8192c_usb_ids[] = {</span>
 	{RTL_USB_DEVICE(0x07b8, 0x8188, rtl92cu_hal_cfg)}, /*Abocom - Abocom*/
 	{RTL_USB_DEVICE(0x07b8, 0x8189, rtl92cu_hal_cfg)}, /*Funai - Abocom*/
 	{RTL_USB_DEVICE(0x0846, 0x9041, rtl92cu_hal_cfg)}, /*NetGear WNA1000M*/
<span class="p_add">+	{RTL_USB_DEVICE(0x0b05, 0x17ba, rtl92cu_hal_cfg)}, /*ASUS-Edimax*/</span>
 	{RTL_USB_DEVICE(0x0bda, 0x5088, rtl92cu_hal_cfg)}, /*Thinkware-CC&amp;C*/
 	{RTL_USB_DEVICE(0x0df6, 0x0052, rtl92cu_hal_cfg)}, /*Sitecom - Edimax*/
 	{RTL_USB_DEVICE(0x0df6, 0x005c, rtl92cu_hal_cfg)}, /*Sitecom - Edimax*/
<span class="p_chunk">@@ -370,6 +371,7 @@</span> <span class="p_context"> static struct usb_device_id rtl8192c_usb_ids[] = {</span>
 	{RTL_USB_DEVICE(0x2001, 0x3307, rtl92cu_hal_cfg)}, /*D-Link-Cameo*/
 	{RTL_USB_DEVICE(0x2001, 0x3309, rtl92cu_hal_cfg)}, /*D-Link-Alpha*/
 	{RTL_USB_DEVICE(0x2001, 0x330a, rtl92cu_hal_cfg)}, /*D-Link-Alpha*/
<span class="p_add">+	{RTL_USB_DEVICE(0x2001, 0x330d, rtl92cu_hal_cfg)}, /*D-Link DWA-131 */</span>
 	{RTL_USB_DEVICE(0x2019, 0xab2b, rtl92cu_hal_cfg)}, /*Planex -Abocom*/
 	{RTL_USB_DEVICE(0x20f4, 0x624d, rtl92cu_hal_cfg)}, /*TRENDNet*/
 	{RTL_USB_DEVICE(0x2357, 0x0100, rtl92cu_hal_cfg)}, /*TP-Link WN8200ND*/
<span class="p_header">diff --git a/drivers/net/wireless/ti/wl18xx/debugfs.c b/drivers/net/wireless/ti/wl18xx/debugfs.c</span>
<span class="p_header">index 7f1669cdea09..779dc2b2ca75 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wl18xx/debugfs.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wl18xx/debugfs.c</span>
<span class="p_chunk">@@ -136,7 +136,7 @@</span> <span class="p_context"> WL18XX_DEBUGFS_FWSTATS_FILE(rx_filter, protection_filter, &quot;%u&quot;);</span>
 WL18XX_DEBUGFS_FWSTATS_FILE(rx_filter, accum_arp_pend_requests, &quot;%u&quot;);
 WL18XX_DEBUGFS_FWSTATS_FILE(rx_filter, max_arp_queue_dep, &quot;%u&quot;);
 
<span class="p_del">-WL18XX_DEBUGFS_FWSTATS_FILE(rx_rate, rx_frames_per_rates, &quot;%u&quot;);</span>
<span class="p_add">+WL18XX_DEBUGFS_FWSTATS_FILE_ARRAY(rx_rate, rx_frames_per_rates, 50);</span>
 
 WL18XX_DEBUGFS_FWSTATS_FILE_ARRAY(aggr_size, tx_agg_vs_rate,
 				  AGGR_STATS_TX_AGG*AGGR_STATS_TX_RATE);
<span class="p_header">diff --git a/drivers/net/wireless/ti/wlcore/debugfs.h b/drivers/net/wireless/ti/wlcore/debugfs.h</span>
<span class="p_header">index f7381dd69009..1bce4325e86b 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wlcore/debugfs.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wlcore/debugfs.h</span>
<span class="p_chunk">@@ -26,8 +26,8 @@</span> <span class="p_context"></span>
 
 #include &quot;wlcore.h&quot;
 
<span class="p_del">-int wl1271_format_buffer(char __user *userbuf, size_t count,</span>
<span class="p_del">-			 loff_t *ppos, char *fmt, ...);</span>
<span class="p_add">+__printf(4, 5) int wl1271_format_buffer(char __user *userbuf, size_t count,</span>
<span class="p_add">+					loff_t *ppos, char *fmt, ...);</span>
 
 int wl1271_debugfs_init(struct wl1271 *wl);
 void wl1271_debugfs_exit(struct wl1271 *wl);
<span class="p_header">diff --git a/drivers/platform/x86/compal-laptop.c b/drivers/platform/x86/compal-laptop.c</span>
<span class="p_header">index 7297df2ebf50..2d9d1985adc1 100644</span>
<span class="p_header">--- a/drivers/platform/x86/compal-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/compal-laptop.c</span>
<span class="p_chunk">@@ -1037,7 +1037,9 @@</span> <span class="p_context"> static int compal_probe(struct platform_device *pdev)</span>
 
 	/* Power supply */
 	initialize_power_supply_data(data);
<span class="p_del">-	power_supply_register(&amp;compal_device-&gt;dev, &amp;data-&gt;psy);</span>
<span class="p_add">+	err = power_supply_register(&amp;compal_device-&gt;dev, &amp;data-&gt;psy);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		goto remove;</span>
 
 	platform_set_drvdata(pdev, data);
 
<span class="p_header">diff --git a/drivers/power/lp8788-charger.c b/drivers/power/lp8788-charger.c</span>
<span class="p_header">index ed49b50b220b..72da2a6c22db 100644</span>
<span class="p_header">--- a/drivers/power/lp8788-charger.c</span>
<span class="p_header">+++ b/drivers/power/lp8788-charger.c</span>
<span class="p_chunk">@@ -417,8 +417,10 @@</span> <span class="p_context"> static int lp8788_psy_register(struct platform_device *pdev,</span>
 	pchg-&gt;battery.num_properties = ARRAY_SIZE(lp8788_battery_prop);
 	pchg-&gt;battery.get_property = lp8788_battery_get_property;
 
<span class="p_del">-	if (power_supply_register(&amp;pdev-&gt;dev, &amp;pchg-&gt;battery))</span>
<span class="p_add">+	if (power_supply_register(&amp;pdev-&gt;dev, &amp;pchg-&gt;battery)) {</span>
<span class="p_add">+		power_supply_unregister(&amp;pchg-&gt;charger);</span>
 		return -EPERM;
<span class="p_add">+	}</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/power/twl4030_madc_battery.c b/drivers/power/twl4030_madc_battery.c</span>
<span class="p_header">index 7ef445a6cfa6..cf907609ec49 100644</span>
<span class="p_header">--- a/drivers/power/twl4030_madc_battery.c</span>
<span class="p_header">+++ b/drivers/power/twl4030_madc_battery.c</span>
<span class="p_chunk">@@ -192,6 +192,7 @@</span> <span class="p_context"> static int twl4030_madc_battery_probe(struct platform_device *pdev)</span>
 {
 	struct twl4030_madc_battery *twl4030_madc_bat;
 	struct twl4030_madc_bat_platform_data *pdata = pdev-&gt;dev.platform_data;
<span class="p_add">+	int ret = 0;</span>
 
 	twl4030_madc_bat = kzalloc(sizeof(*twl4030_madc_bat), GFP_KERNEL);
 	if (!twl4030_madc_bat)
<span class="p_chunk">@@ -216,9 +217,11 @@</span> <span class="p_context"> static int twl4030_madc_battery_probe(struct platform_device *pdev)</span>
 
 	twl4030_madc_bat-&gt;pdata = pdata;
 	platform_set_drvdata(pdev, twl4030_madc_bat);
<span class="p_del">-	power_supply_register(&amp;pdev-&gt;dev, &amp;twl4030_madc_bat-&gt;psy);</span>
<span class="p_add">+	ret = power_supply_register(&amp;pdev-&gt;dev, &amp;twl4030_madc_bat-&gt;psy);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		kfree(twl4030_madc_bat);</span>
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int twl4030_madc_battery_remove(struct platform_device *pdev)
<span class="p_header">diff --git a/drivers/scsi/bfa/bfa_ioc.c b/drivers/scsi/bfa/bfa_ioc.c</span>
<span class="p_header">index 65180e15de6e..50c75e1fbf8a 100644</span>
<span class="p_header">--- a/drivers/scsi/bfa/bfa_ioc.c</span>
<span class="p_header">+++ b/drivers/scsi/bfa/bfa_ioc.c</span>
<span class="p_chunk">@@ -7006,7 +7006,7 @@</span> <span class="p_context"> bfa_flash_sem_get(void __iomem *bar)</span>
 	while (!bfa_raw_sem_get(bar)) {
 		if (--n &lt;= 0)
 			return BFA_STATUS_BADFLASH;
<span class="p_del">-		udelay(10000);</span>
<span class="p_add">+		mdelay(10);</span>
 	}
 	return BFA_STATUS_OK;
 }
<span class="p_header">diff --git a/drivers/scsi/mvsas/mv_sas.c b/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_header">index 6c1f223a8e1d..4c0b8b4e1d40 100644</span>
<span class="p_header">--- a/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_header">+++ b/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_chunk">@@ -441,14 +441,11 @@</span> <span class="p_context"> static u32 mvs_get_ncq_tag(struct sas_task *task, u32 *tag)</span>
 static int mvs_task_prep_ata(struct mvs_info *mvi,
 			     struct mvs_task_exec_info *tei)
 {
<span class="p_del">-	struct sas_ha_struct *sha = mvi-&gt;sas;</span>
 	struct sas_task *task = tei-&gt;task;
 	struct domain_device *dev = task-&gt;dev;
 	struct mvs_device *mvi_dev = dev-&gt;lldd_dev;
 	struct mvs_cmd_hdr *hdr = tei-&gt;hdr;
 	struct asd_sas_port *sas_port = dev-&gt;port;
<span class="p_del">-	struct sas_phy *sphy = dev-&gt;phy;</span>
<span class="p_del">-	struct asd_sas_phy *sas_phy = sha-&gt;sas_phy[sphy-&gt;number];</span>
 	struct mvs_slot_info *slot;
 	void *buf_prd;
 	u32 tag = tei-&gt;tag, hdr_tag;
<span class="p_chunk">@@ -468,7 +465,7 @@</span> <span class="p_context"> static int mvs_task_prep_ata(struct mvs_info *mvi,</span>
 	slot-&gt;tx = mvi-&gt;tx_prod;
 	del_q = TXQ_MODE_I | tag |
 		(TXQ_CMD_STP &lt;&lt; TXQ_CMD_SHIFT) |
<span class="p_del">-		(MVS_PHY_ID &lt;&lt; TXQ_PHY_SHIFT) |</span>
<span class="p_add">+		((sas_port-&gt;phy_mask &amp; TXQ_PHY_MASK) &lt;&lt; TXQ_PHY_SHIFT) |</span>
 		(mvi_dev-&gt;taskfileset &lt;&lt; TXQ_SRS_SHIFT);
 	mvi-&gt;tx[mvi-&gt;tx_prod] = cpu_to_le32(del_q);
 
<span class="p_header">diff --git a/drivers/scsi/storvsc_drv.c b/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">index 86b05151fdab..97892f258043 100644</span>
<span class="p_header">--- a/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">+++ b/drivers/scsi/storvsc_drv.c</span>
<span class="p_chunk">@@ -739,21 +739,22 @@</span> <span class="p_context"> static unsigned int copy_to_bounce_buffer(struct scatterlist *orig_sgl,</span>
 			if (bounce_sgl[j].length == PAGE_SIZE) {
 				/* full..move to next entry */
 				sg_kunmap_atomic(bounce_addr);
<span class="p_add">+				bounce_addr = 0;</span>
 				j++;
<span class="p_add">+			}</span>
 
<span class="p_del">-				/* if we need to use another bounce buffer */</span>
<span class="p_del">-				if (srclen || i != orig_sgl_count - 1)</span>
<span class="p_del">-					bounce_addr = sg_kmap_atomic(bounce_sgl,j);</span>
<span class="p_add">+			/* if we need to use another bounce buffer */</span>
<span class="p_add">+			if (srclen &amp;&amp; bounce_addr == 0)</span>
<span class="p_add">+				bounce_addr = sg_kmap_atomic(bounce_sgl, j);</span>
 
<span class="p_del">-			} else if (srclen == 0 &amp;&amp; i == orig_sgl_count - 1) {</span>
<span class="p_del">-				/* unmap the last bounce that is &lt; PAGE_SIZE */</span>
<span class="p_del">-				sg_kunmap_atomic(bounce_addr);</span>
<span class="p_del">-			}</span>
 		}
 
 		sg_kunmap_atomic(src_addr - orig_sgl[i].offset);
 	}
 
<span class="p_add">+	if (bounce_addr)</span>
<span class="p_add">+		sg_kunmap_atomic(bounce_addr);</span>
<span class="p_add">+</span>
 	local_irq_restore(flags);
 
 	return total_copied;
<span class="p_header">diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c</span>
<span class="p_header">index d7c6e36021e8..2fe5b61d886a 100644</span>
<span class="p_header">--- a/drivers/spi/spidev.c</span>
<span class="p_header">+++ b/drivers/spi/spidev.c</span>
<span class="p_chunk">@@ -243,7 +243,10 @@</span> <span class="p_context"> static int spidev_message(struct spidev_data *spidev,</span>
 		k_tmp-&gt;len = u_tmp-&gt;len;
 
 		total += k_tmp-&gt;len;
<span class="p_del">-		if (total &gt; bufsiz) {</span>
<span class="p_add">+		/* Check total length of transfers.  Also check each</span>
<span class="p_add">+		 * transfer length to avoid arithmetic overflow.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (total &gt; bufsiz || k_tmp-&gt;len &gt; bufsiz) {</span>
 			status = -EMSGSIZE;
 			goto done;
 		}
<span class="p_header">diff --git a/drivers/target/target_core_file.c b/drivers/target/target_core_file.c</span>
<span class="p_header">index 41eff7d64cb8..b199f1e21d0e 100644</span>
<span class="p_header">--- a/drivers/target/target_core_file.c</span>
<span class="p_header">+++ b/drivers/target/target_core_file.c</span>
<span class="p_chunk">@@ -263,40 +263,32 @@</span> <span class="p_context"> static int fd_do_prot_rw(struct se_cmd *cmd, struct fd_prot *fd_prot,</span>
 	struct se_device *se_dev = cmd-&gt;se_dev;
 	struct fd_dev *dev = FD_DEV(se_dev);
 	struct file *prot_fd = dev-&gt;fd_prot_file;
<span class="p_del">-	struct scatterlist *sg;</span>
 	loff_t pos = (cmd-&gt;t_task_lba * se_dev-&gt;prot_length);
 	unsigned char *buf;
<span class="p_del">-	u32 prot_size, len, size;</span>
<span class="p_del">-	int rc, ret = 1, i;</span>
<span class="p_add">+	u32 prot_size;</span>
<span class="p_add">+	int rc, ret = 1;</span>
 
 	prot_size = (cmd-&gt;data_length / se_dev-&gt;dev_attrib.block_size) *
 		     se_dev-&gt;prot_length;
 
 	if (!is_write) {
<span class="p_del">-		fd_prot-&gt;prot_buf = vzalloc(prot_size);</span>
<span class="p_add">+		fd_prot-&gt;prot_buf = kzalloc(prot_size, GFP_KERNEL);</span>
 		if (!fd_prot-&gt;prot_buf) {
 			pr_err(&quot;Unable to allocate fd_prot-&gt;prot_buf\n&quot;);
 			return -ENOMEM;
 		}
 		buf = fd_prot-&gt;prot_buf;
 
<span class="p_del">-		fd_prot-&gt;prot_sg_nents = cmd-&gt;t_prot_nents;</span>
<span class="p_del">-		fd_prot-&gt;prot_sg = kzalloc(sizeof(struct scatterlist) *</span>
<span class="p_del">-					   fd_prot-&gt;prot_sg_nents, GFP_KERNEL);</span>
<span class="p_add">+		fd_prot-&gt;prot_sg_nents = 1;</span>
<span class="p_add">+		fd_prot-&gt;prot_sg = kzalloc(sizeof(struct scatterlist),</span>
<span class="p_add">+					   GFP_KERNEL);</span>
 		if (!fd_prot-&gt;prot_sg) {
 			pr_err(&quot;Unable to allocate fd_prot-&gt;prot_sg\n&quot;);
<span class="p_del">-			vfree(fd_prot-&gt;prot_buf);</span>
<span class="p_add">+			kfree(fd_prot-&gt;prot_buf);</span>
 			return -ENOMEM;
 		}
<span class="p_del">-		size = prot_size;</span>
<span class="p_del">-</span>
<span class="p_del">-		for_each_sg(fd_prot-&gt;prot_sg, sg, fd_prot-&gt;prot_sg_nents, i) {</span>
<span class="p_del">-</span>
<span class="p_del">-			len = min_t(u32, PAGE_SIZE, size);</span>
<span class="p_del">-			sg_set_buf(sg, buf, len);</span>
<span class="p_del">-			size -= len;</span>
<span class="p_del">-			buf += len;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		sg_init_table(fd_prot-&gt;prot_sg, fd_prot-&gt;prot_sg_nents);</span>
<span class="p_add">+		sg_set_buf(fd_prot-&gt;prot_sg, buf, prot_size);</span>
 	}
 
 	if (is_write) {
<span class="p_chunk">@@ -317,7 +309,7 @@</span> <span class="p_context"> static int fd_do_prot_rw(struct se_cmd *cmd, struct fd_prot *fd_prot,</span>
 
 	if (is_write || ret &lt; 0) {
 		kfree(fd_prot-&gt;prot_sg);
<span class="p_del">-		vfree(fd_prot-&gt;prot_buf);</span>
<span class="p_add">+		kfree(fd_prot-&gt;prot_buf);</span>
 	}
 
 	return ret;
<span class="p_chunk">@@ -652,11 +644,11 @@</span> <span class="p_context"> fd_execute_rw(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_nents,</span>
 						 0, fd_prot.prot_sg, 0);
 			if (rc) {
 				kfree(fd_prot.prot_sg);
<span class="p_del">-				vfree(fd_prot.prot_buf);</span>
<span class="p_add">+				kfree(fd_prot.prot_buf);</span>
 				return rc;
 			}
 			kfree(fd_prot.prot_sg);
<span class="p_del">-			vfree(fd_prot.prot_buf);</span>
<span class="p_add">+			kfree(fd_prot.prot_buf);</span>
 		}
 	} else {
 		memset(&amp;fd_prot, 0, sizeof(struct fd_prot));
<span class="p_chunk">@@ -672,7 +664,7 @@</span> <span class="p_context"> fd_execute_rw(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_nents,</span>
 						  0, fd_prot.prot_sg, 0);
 			if (rc) {
 				kfree(fd_prot.prot_sg);
<span class="p_del">-				vfree(fd_prot.prot_buf);</span>
<span class="p_add">+				kfree(fd_prot.prot_buf);</span>
 				return rc;
 			}
 		}
<span class="p_chunk">@@ -703,7 +695,7 @@</span> <span class="p_context"> fd_execute_rw(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_nents,</span>
 
 	if (ret &lt; 0) {
 		kfree(fd_prot.prot_sg);
<span class="p_del">-		vfree(fd_prot.prot_buf);</span>
<span class="p_add">+		kfree(fd_prot.prot_buf);</span>
 		return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
 	}
 
<span class="p_header">diff --git a/drivers/target/target_core_sbc.c b/drivers/target/target_core_sbc.c</span>
<span class="p_header">index 68511e83486b..f89b24a09b19 100644</span>
<span class="p_header">--- a/drivers/target/target_core_sbc.c</span>
<span class="p_header">+++ b/drivers/target/target_core_sbc.c</span>
<span class="p_chunk">@@ -314,7 +314,7 @@</span> <span class="p_context"> sbc_setup_write_same(struct se_cmd *cmd, unsigned char *flags, struct sbc_ops *o</span>
 	return 0;
 }
 
<span class="p_del">-static sense_reason_t xdreadwrite_callback(struct se_cmd *cmd)</span>
<span class="p_add">+static sense_reason_t xdreadwrite_callback(struct se_cmd *cmd, bool success)</span>
 {
 	unsigned char *buf, *addr;
 	struct scatterlist *sg;
<span class="p_chunk">@@ -378,7 +378,7 @@</span> <span class="p_context"> sbc_execute_rw(struct se_cmd *cmd)</span>
 			       cmd-&gt;data_direction);
 }
 
<span class="p_del">-static sense_reason_t compare_and_write_post(struct se_cmd *cmd)</span>
<span class="p_add">+static sense_reason_t compare_and_write_post(struct se_cmd *cmd, bool success)</span>
 {
 	struct se_device *dev = cmd-&gt;se_dev;
 
<span class="p_chunk">@@ -401,7 +401,7 @@</span> <span class="p_context"> static sense_reason_t compare_and_write_post(struct se_cmd *cmd)</span>
 	return TCM_NO_SENSE;
 }
 
<span class="p_del">-static sense_reason_t compare_and_write_callback(struct se_cmd *cmd)</span>
<span class="p_add">+static sense_reason_t compare_and_write_callback(struct se_cmd *cmd, bool success)</span>
 {
 	struct se_device *dev = cmd-&gt;se_dev;
 	struct scatterlist *write_sg = NULL, *sg;
<span class="p_chunk">@@ -416,11 +416,16 @@</span> <span class="p_context"> static sense_reason_t compare_and_write_callback(struct se_cmd *cmd)</span>
 
 	/*
 	 * Handle early failure in transport_generic_request_failure(),
<span class="p_del">-	 * which will not have taken -&gt;caw_mutex yet..</span>
<span class="p_add">+	 * which will not have taken -&gt;caw_sem yet..</span>
 	 */
<span class="p_del">-	if (!cmd-&gt;t_data_sg || !cmd-&gt;t_bidi_data_sg)</span>
<span class="p_add">+	if (!success &amp;&amp; (!cmd-&gt;t_data_sg || !cmd-&gt;t_bidi_data_sg))</span>
 		return TCM_NO_SENSE;
 	/*
<span class="p_add">+	 * Handle special case for zero-length COMPARE_AND_WRITE</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!cmd-&gt;data_length)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	/*</span>
 	 * Immediately exit + release dev-&gt;caw_sem if command has already
 	 * been failed with a non-zero SCSI status.
 	 */
<span class="p_header">diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c</span>
<span class="p_header">index 9e54c0fe718d..6fc38903046c 100644</span>
<span class="p_header">--- a/drivers/target/target_core_transport.c</span>
<span class="p_header">+++ b/drivers/target/target_core_transport.c</span>
<span class="p_chunk">@@ -1600,11 +1600,11 @@</span> <span class="p_context"> void transport_generic_request_failure(struct se_cmd *cmd,</span>
 	transport_complete_task_attr(cmd);
 	/*
 	 * Handle special case for COMPARE_AND_WRITE failure, where the
<span class="p_del">-	 * callback is expected to drop the per device -&gt;caw_mutex.</span>
<span class="p_add">+	 * callback is expected to drop the per device -&gt;caw_sem.</span>
 	 */
 	if ((cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) &amp;&amp;
 	     cmd-&gt;transport_complete_callback)
<span class="p_del">-		cmd-&gt;transport_complete_callback(cmd);</span>
<span class="p_add">+		cmd-&gt;transport_complete_callback(cmd, false);</span>
 
 	switch (sense_reason) {
 	case TCM_NON_EXISTENT_LUN:
<span class="p_chunk">@@ -1941,8 +1941,12 @@</span> <span class="p_context"> static void target_complete_ok_work(struct work_struct *work)</span>
 	if (cmd-&gt;transport_complete_callback) {
 		sense_reason_t rc;
 
<span class="p_del">-		rc = cmd-&gt;transport_complete_callback(cmd);</span>
<span class="p_add">+		rc = cmd-&gt;transport_complete_callback(cmd, true);</span>
 		if (!rc &amp;&amp; !(cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE_POST)) {
<span class="p_add">+			if ((cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) &amp;&amp;</span>
<span class="p_add">+			    !cmd-&gt;data_length)</span>
<span class="p_add">+				goto queue_rsp;</span>
<span class="p_add">+</span>
 			return;
 		} else if (rc) {
 			ret = transport_send_check_condition_and_sense(cmd,
<span class="p_chunk">@@ -1956,6 +1960,7 @@</span> <span class="p_context"> static void target_complete_ok_work(struct work_struct *work)</span>
 		}
 	}
 
<span class="p_add">+queue_rsp:</span>
 	switch (cmd-&gt;data_direction) {
 	case DMA_FROM_DEVICE:
 		spin_lock(&amp;cmd-&gt;se_lun-&gt;lun_sep_lock);
<span class="p_chunk">@@ -2044,6 +2049,16 @@</span> <span class="p_context"> static inline void transport_reset_sgl_orig(struct se_cmd *cmd)</span>
 static inline void transport_free_pages(struct se_cmd *cmd)
 {
 	if (cmd-&gt;se_cmd_flags &amp; SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC) {
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Release special case READ buffer payload required for</span>
<span class="p_add">+		 * SG_TO_MEM_NOALLOC to function with COMPARE_AND_WRITE</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) {</span>
<span class="p_add">+			transport_free_sgl(cmd-&gt;t_bidi_data_sg,</span>
<span class="p_add">+					   cmd-&gt;t_bidi_data_nents);</span>
<span class="p_add">+			cmd-&gt;t_bidi_data_sg = NULL;</span>
<span class="p_add">+			cmd-&gt;t_bidi_data_nents = 0;</span>
<span class="p_add">+		}</span>
 		transport_reset_sgl_orig(cmd);
 		return;
 	}
<span class="p_chunk">@@ -2192,6 +2207,7 @@</span> <span class="p_context"> sense_reason_t</span>
 transport_generic_new_cmd(struct se_cmd *cmd)
 {
 	int ret = 0;
<span class="p_add">+	bool zero_flag = !(cmd-&gt;se_cmd_flags &amp; SCF_SCSI_DATA_CDB);</span>
 
 	/*
 	 * Determine is the TCM fabric module has already allocated physical
<span class="p_chunk">@@ -2200,7 +2216,6 @@</span> <span class="p_context"> transport_generic_new_cmd(struct se_cmd *cmd)</span>
 	 */
 	if (!(cmd-&gt;se_cmd_flags &amp; SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC) &amp;&amp;
 	    cmd-&gt;data_length) {
<span class="p_del">-		bool zero_flag = !(cmd-&gt;se_cmd_flags &amp; SCF_SCSI_DATA_CDB);</span>
 
 		if ((cmd-&gt;se_cmd_flags &amp; SCF_BIDI) ||
 		    (cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE)) {
<span class="p_chunk">@@ -2223,6 +2238,20 @@</span> <span class="p_context"> transport_generic_new_cmd(struct se_cmd *cmd)</span>
 				       cmd-&gt;data_length, zero_flag);
 		if (ret &lt; 0)
 			return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
<span class="p_add">+	} else if ((cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) &amp;&amp;</span>
<span class="p_add">+		    cmd-&gt;data_length) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Special case for COMPARE_AND_WRITE with fabrics</span>
<span class="p_add">+		 * using SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		u32 caw_length = cmd-&gt;t_task_nolb *</span>
<span class="p_add">+				 cmd-&gt;se_dev-&gt;dev_attrib.block_size;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = target_alloc_sgl(&amp;cmd-&gt;t_bidi_data_sg,</span>
<span class="p_add">+				       &amp;cmd-&gt;t_bidi_data_nents,</span>
<span class="p_add">+				       caw_length, zero_flag);</span>
<span class="p_add">+		if (ret &lt; 0)</span>
<span class="p_add">+			return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;</span>
 	}
 	/*
 	 * If this command is not a write we can execute it right here,
<span class="p_header">diff --git a/drivers/usb/class/cdc-wdm.c b/drivers/usb/class/cdc-wdm.c</span>
<span class="p_header">index a051a7a2b1bd..a81f9dd7ee97 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-wdm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-wdm.c</span>
<span class="p_chunk">@@ -245,7 +245,7 @@</span> <span class="p_context"> static void wdm_int_callback(struct urb *urb)</span>
 	case USB_CDC_NOTIFY_RESPONSE_AVAILABLE:
 		dev_dbg(&amp;desc-&gt;intf-&gt;dev,
 			&quot;NOTIFY_RESPONSE_AVAILABLE received: index %d len %d&quot;,
<span class="p_del">-			dr-&gt;wIndex, dr-&gt;wLength);</span>
<span class="p_add">+			le16_to_cpu(dr-&gt;wIndex), le16_to_cpu(dr-&gt;wLength));</span>
 		break;
 
 	case USB_CDC_NOTIFY_NETWORK_CONNECTION:
<span class="p_chunk">@@ -262,7 +262,9 @@</span> <span class="p_context"> static void wdm_int_callback(struct urb *urb)</span>
 		clear_bit(WDM_POLL_RUNNING, &amp;desc-&gt;flags);
 		dev_err(&amp;desc-&gt;intf-&gt;dev,
 			&quot;unknown notification %d received: index %d len %d\n&quot;,
<span class="p_del">-			dr-&gt;bNotificationType, dr-&gt;wIndex, dr-&gt;wLength);</span>
<span class="p_add">+			dr-&gt;bNotificationType,</span>
<span class="p_add">+			le16_to_cpu(dr-&gt;wIndex),</span>
<span class="p_add">+			le16_to_cpu(dr-&gt;wLength));</span>
 		goto exit;
 	}
 
<span class="p_chunk">@@ -408,7 +410,7 @@</span> <span class="p_context"> static ssize_t wdm_write</span>
 			     USB_RECIP_INTERFACE);
 	req-&gt;bRequest = USB_CDC_SEND_ENCAPSULATED_COMMAND;
 	req-&gt;wValue = 0;
<span class="p_del">-	req-&gt;wIndex = desc-&gt;inum;</span>
<span class="p_add">+	req-&gt;wIndex = desc-&gt;inum; /* already converted */</span>
 	req-&gt;wLength = cpu_to_le16(count);
 	set_bit(WDM_IN_USE, &amp;desc-&gt;flags);
 	desc-&gt;outbuf = buf;
<span class="p_chunk">@@ -422,7 +424,7 @@</span> <span class="p_context"> static ssize_t wdm_write</span>
 		rv = usb_translate_errors(rv);
 	} else {
 		dev_dbg(&amp;desc-&gt;intf-&gt;dev, &quot;Tx URB has been submitted index=%d&quot;,
<span class="p_del">-			req-&gt;wIndex);</span>
<span class="p_add">+			le16_to_cpu(req-&gt;wIndex));</span>
 	}
 out:
 	usb_autopm_put_interface(desc-&gt;intf);
<span class="p_chunk">@@ -820,7 +822,7 @@</span> <span class="p_context"> static int wdm_create(struct usb_interface *intf, struct usb_endpoint_descriptor</span>
 	desc-&gt;irq-&gt;bRequestType = (USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE);
 	desc-&gt;irq-&gt;bRequest = USB_CDC_GET_ENCAPSULATED_RESPONSE;
 	desc-&gt;irq-&gt;wValue = 0;
<span class="p_del">-	desc-&gt;irq-&gt;wIndex = desc-&gt;inum;</span>
<span class="p_add">+	desc-&gt;irq-&gt;wIndex = desc-&gt;inum; /* already converted */</span>
 	desc-&gt;irq-&gt;wLength = cpu_to_le16(desc-&gt;wMaxCommand);
 
 	usb_fill_control_urb(
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index d2bd9d7c8f4b..1847a7d38026 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -3289,10 +3289,10 @@</span> <span class="p_context"> int usb_port_resume(struct usb_device *udev, pm_message_t msg)</span>
 		dev_dbg(hub-&gt;intfdev, &quot;can&#39;t resume port %d, status %d\n&quot;,
 				port1, status);
 	} else {
<span class="p_del">-		/* drive resume for at least 20 msec */</span>
<span class="p_add">+		/* drive resume for USB_RESUME_TIMEOUT msec */</span>
 		dev_dbg(&amp;udev-&gt;dev, &quot;usb %sresume\n&quot;,
 				(PMSG_IS_AUTO(msg) ? &quot;auto-&quot; : &quot;&quot;));
<span class="p_del">-		msleep(25);</span>
<span class="p_add">+		msleep(USB_RESUME_TIMEOUT);</span>
 
 		/* Virtual root hubs can trigger on GET_PORT_STATUS to
 		 * stop resume signaling.  Then finish the resume
<span class="p_header">diff --git a/drivers/usb/dwc2/hcd.c b/drivers/usb/dwc2/hcd.c</span>
<span class="p_header">index 4d918ed8d343..0f9980088c08 100644</span>
<span class="p_header">--- a/drivers/usb/dwc2/hcd.c</span>
<span class="p_header">+++ b/drivers/usb/dwc2/hcd.c</span>
<span class="p_chunk">@@ -1501,7 +1501,7 @@</span> <span class="p_context"> static int dwc2_hcd_hub_control(struct dwc2_hsotg *hsotg, u16 typereq,</span>
 			dev_dbg(hsotg-&gt;dev,
 				&quot;ClearPortFeature USB_PORT_FEAT_SUSPEND\n&quot;);
 			writel(0, hsotg-&gt;regs + PCGCTL);
<span class="p_del">-			usleep_range(20000, 40000);</span>
<span class="p_add">+			msleep(USB_RESUME_TIMEOUT);</span>
 
 			hprt0 = dwc2_read_hprt0(hsotg);
 			hprt0 |= HPRT0_RES;
<span class="p_header">diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c</span>
<span class="p_header">index d742bed7a5fa..82df926c765d 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/composite.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/composite.c</span>
<span class="p_chunk">@@ -528,7 +528,7 @@</span> <span class="p_context"> static int bos_desc(struct usb_composite_dev *cdev)</span>
 	usb_ext-&gt;bLength = USB_DT_USB_EXT_CAP_SIZE;
 	usb_ext-&gt;bDescriptorType = USB_DT_DEVICE_CAPABILITY;
 	usb_ext-&gt;bDevCapabilityType = USB_CAP_TYPE_EXT;
<span class="p_del">-	usb_ext-&gt;bmAttributes = cpu_to_le32(USB_LPM_SUPPORT);</span>
<span class="p_add">+	usb_ext-&gt;bmAttributes = cpu_to_le32(USB_LPM_SUPPORT | USB_BESL_SUPPORT);</span>
 
 	/*
 	 * The Superspeed USB Capability descriptor shall be implemented by all
<span class="p_header">diff --git a/drivers/usb/host/fotg210-hcd.c b/drivers/usb/host/fotg210-hcd.c</span>
<span class="p_header">index 98a89d16cc3e..8aa4ba0a0c69 100644</span>
<span class="p_header">--- a/drivers/usb/host/fotg210-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/fotg210-hcd.c</span>
<span class="p_chunk">@@ -1595,7 +1595,7 @@</span> <span class="p_context"> static int fotg210_hub_control(</span>
 			/* resume signaling for 20 msec */
 			fotg210_writel(fotg210, temp | PORT_RESUME, status_reg);
 			fotg210-&gt;reset_done[wIndex] = jiffies
<span class="p_del">-					+ msecs_to_jiffies(20);</span>
<span class="p_add">+					+ msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
 			clear_bit(wIndex, &amp;fotg210-&gt;port_c_suspend);
<span class="p_header">diff --git a/drivers/usb/host/fusbh200-hcd.c b/drivers/usb/host/fusbh200-hcd.c</span>
<span class="p_header">index ba9499060f63..3e3926aa584e 100644</span>
<span class="p_header">--- a/drivers/usb/host/fusbh200-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/fusbh200-hcd.c</span>
<span class="p_chunk">@@ -1550,10 +1550,9 @@</span> <span class="p_context"> static int fusbh200_hub_control (</span>
 			if ((temp &amp; PORT_PE) == 0)
 				goto error;
 
<span class="p_del">-			/* resume signaling for 20 msec */</span>
 			fusbh200_writel(fusbh200, temp | PORT_RESUME, status_reg);
 			fusbh200-&gt;reset_done[wIndex] = jiffies
<span class="p_del">-					+ msecs_to_jiffies(20);</span>
<span class="p_add">+					+ msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
 			clear_bit(wIndex, &amp;fusbh200-&gt;port_c_suspend);
<span class="p_header">diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c</span>
<span class="p_header">index 240e792c81a7..b62298fe0be8 100644</span>
<span class="p_header">--- a/drivers/usb/host/isp116x-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/isp116x-hcd.c</span>
<span class="p_chunk">@@ -1487,7 +1487,7 @@</span> <span class="p_context"> static int isp116x_bus_resume(struct usb_hcd *hcd)</span>
 	spin_unlock_irq(&amp;isp116x-&gt;lock);
 
 	hcd-&gt;state = HC_STATE_RESUMING;
<span class="p_del">-	msleep(20);</span>
<span class="p_add">+	msleep(USB_RESUME_TIMEOUT);</span>
 
 	/* Go operational */
 	spin_lock_irq(&amp;isp116x-&gt;lock);
<span class="p_header">diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_header">index 110b4b9ebeaa..f130bb2f7bbe 100644</span>
<span class="p_header">--- a/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_chunk">@@ -2300,7 +2300,7 @@</span> <span class="p_context"> static int r8a66597_bus_resume(struct usb_hcd *hcd)</span>
 		rh-&gt;port &amp;= ~USB_PORT_STAT_SUSPEND;
 		rh-&gt;port |= USB_PORT_STAT_C_SUSPEND &lt;&lt; 16;
 		r8a66597_mdfy(r8a66597, RESUME, RESUME | UACT, dvstctr_reg);
<span class="p_del">-		msleep(50);</span>
<span class="p_add">+		msleep(USB_RESUME_TIMEOUT);</span>
 		r8a66597_mdfy(r8a66597, UACT, RESUME | UACT, dvstctr_reg);
 	}
 
<span class="p_header">diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c</span>
<span class="p_header">index a517151867af..0f53cc8c8ecf 100644</span>
<span class="p_header">--- a/drivers/usb/host/sl811-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/sl811-hcd.c</span>
<span class="p_chunk">@@ -1259,7 +1259,7 @@</span> <span class="p_context"> sl811h_hub_control(</span>
 			sl811_write(sl811, SL11H_CTLREG1, sl811-&gt;ctrl1);
 
 			mod_timer(&amp;sl811-&gt;timer, jiffies
<span class="p_del">-					+ msecs_to_jiffies(20));</span>
<span class="p_add">+					+ msecs_to_jiffies(USB_RESUME_TIMEOUT));</span>
 			break;
 		case USB_PORT_FEAT_POWER:
 			port_power(sl811, 0);
<span class="p_header">diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c</span>
<span class="p_header">index 93e17b12fb33..98c66d88ebde 100644</span>
<span class="p_header">--- a/drivers/usb/host/uhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/uhci-hub.c</span>
<span class="p_chunk">@@ -165,7 +165,7 @@</span> <span class="p_context"> static void uhci_check_ports(struct uhci_hcd *uhci)</span>
 				/* Port received a wakeup request */
 				set_bit(port, &amp;uhci-&gt;resuming_ports);
 				uhci-&gt;ports_timeout = jiffies +
<span class="p_del">-						msecs_to_jiffies(25);</span>
<span class="p_add">+					msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 				usb_hcd_start_port_resume(
 						&amp;uhci_to_hcd(uhci)-&gt;self, port);
 
<span class="p_chunk">@@ -337,7 +337,8 @@</span> <span class="p_context"> static int uhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,</span>
 			uhci_finish_suspend(uhci, port, port_addr);
 
 			/* USB v2.0 7.1.7.5 */
<span class="p_del">-			uhci-&gt;ports_timeout = jiffies + msecs_to_jiffies(50);</span>
<span class="p_add">+			uhci-&gt;ports_timeout = jiffies +</span>
<span class="p_add">+				msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			break;
 		case USB_PORT_FEAT_POWER:
 			/* UHCI has no power switching */
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index a95eee8ddc38..05185b9d4495 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -1768,7 +1768,7 @@</span> <span class="p_context"> static void handle_port_status(struct xhci_hcd *xhci,</span>
 		} else {
 			xhci_dbg(xhci, &quot;resume HS port %d\n&quot;, port_id);
 			bus_state-&gt;resume_done[faked_port_index] = jiffies +
<span class="p_del">-				msecs_to_jiffies(20);</span>
<span class="p_add">+				msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			set_bit(faked_port_index, &amp;bus_state-&gt;resuming_ports);
 			mod_timer(&amp;hcd-&gt;rh_timer,
 				  bus_state-&gt;resume_done[faked_port_index]);
<span class="p_header">diff --git a/drivers/usb/phy/phy.c b/drivers/usb/phy/phy.c</span>
<span class="p_header">index 0180eef05656..964ebafe8b44 100644</span>
<span class="p_header">--- a/drivers/usb/phy/phy.c</span>
<span class="p_header">+++ b/drivers/usb/phy/phy.c</span>
<span class="p_chunk">@@ -78,7 +78,9 @@</span> <span class="p_context"> static void devm_usb_phy_release(struct device *dev, void *res)</span>
 
 static int devm_usb_phy_match(struct device *dev, void *res, void *match_data)
 {
<span class="p_del">-	return res == match_data;</span>
<span class="p_add">+	struct usb_phy **phy = res;</span>
<span class="p_add">+</span>
<span class="p_add">+	return *phy == match_data;</span>
 }
 
 /**
<span class="p_header">diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c</span>
<span class="p_header">index f4d7b2fc9ffb..78f46089a077 100644</span>
<span class="p_header">--- a/fs/binfmt_elf.c</span>
<span class="p_header">+++ b/fs/binfmt_elf.c</span>
<span class="p_chunk">@@ -751,6 +751,7 @@</span> <span class="p_context"> static int load_elf_binary(struct linux_binprm *bprm)</span>
 	    i &lt; loc-&gt;elf_ex.e_phnum; i++, elf_ppnt++) {
 		int elf_prot = 0, elf_flags;
 		unsigned long k, vaddr;
<span class="p_add">+		unsigned long total_size = 0;</span>
 
 		if (elf_ppnt-&gt;p_type != PT_LOAD)
 			continue;
<span class="p_chunk">@@ -815,10 +816,16 @@</span> <span class="p_context"> static int load_elf_binary(struct linux_binprm *bprm)</span>
 #else
 			load_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);
 #endif
<span class="p_add">+			total_size = total_mapping_size(elf_phdata,</span>
<span class="p_add">+							loc-&gt;elf_ex.e_phnum);</span>
<span class="p_add">+			if (!total_size) {</span>
<span class="p_add">+				error = -EINVAL;</span>
<span class="p_add">+				goto out_free_dentry;</span>
<span class="p_add">+			}</span>
 		}
 
 		error = elf_map(bprm-&gt;file, load_bias + vaddr, elf_ppnt,
<span class="p_del">-				elf_prot, elf_flags, 0);</span>
<span class="p_add">+				elf_prot, elf_flags, total_size);</span>
 		if (BAD_ADDR(error)) {
 			send_sig(SIGKILL, current, 0);
 			retval = IS_ERR((void *)error) ?
<span class="p_header">diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c</span>
<span class="p_header">index d2f1c011d73a..794d7c6ea9ee 100644</span>
<span class="p_header">--- a/fs/btrfs/extent-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/extent-tree.c</span>
<span class="p_chunk">@@ -6645,12 +6645,11 @@</span> <span class="p_context"> static int __btrfs_free_reserved_extent(struct btrfs_root *root,</span>
 		return -ENOSPC;
 	}
 
<span class="p_del">-	if (btrfs_test_opt(root, DISCARD))</span>
<span class="p_del">-		ret = btrfs_discard_extent(root, start, len, NULL);</span>
<span class="p_del">-</span>
 	if (pin)
 		pin_down_extent(root, cache, start, len, 1);
 	else {
<span class="p_add">+		if (btrfs_test_opt(root, DISCARD))</span>
<span class="p_add">+			ret = btrfs_discard_extent(root, start, len, NULL);</span>
 		btrfs_add_free_space(cache, start, len);
 		btrfs_update_reserved_bytes(cache, len, RESERVE_FREE);
 	}
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index 0b72006aecbe..3e16042338e4 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -2708,6 +2708,9 @@</span> <span class="p_context"> static int btrfs_extent_same(struct inode *src, u64 loff, u64 len,</span>
 	if (src == dst)
 		return -EINVAL;
 
<span class="p_add">+	if (len == 0)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	btrfs_double_lock(src, loff, dst, dst_loff, len);
 
 	ret = extent_same_check_offsets(src, loff, len);
<span class="p_chunk">@@ -3226,6 +3229,11 @@</span> <span class="p_context"> static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,</span>
 	if (off + len == src-&gt;i_size)
 		len = ALIGN(src-&gt;i_size, bs) - off;
 
<span class="p_add">+	if (len == 0) {</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* verify the end result is block aligned */
 	if (!IS_ALIGNED(off, bs) || !IS_ALIGNED(off + len, bs) ||
 	    !IS_ALIGNED(destoff, bs))
<span class="p_header">diff --git a/fs/btrfs/xattr.c b/fs/btrfs/xattr.c</span>
<span class="p_header">index ad8328d797ea..488e987c3374 100644</span>
<span class="p_header">--- a/fs/btrfs/xattr.c</span>
<span class="p_header">+++ b/fs/btrfs/xattr.c</span>
<span class="p_chunk">@@ -324,22 +324,42 @@</span> <span class="p_context"> const struct xattr_handler *btrfs_xattr_handlers[] = {</span>
 /*
  * Check if the attribute is in a supported namespace.
  *
<span class="p_del">- * This applied after the check for the synthetic attributes in the system</span>
<span class="p_add">+ * This is applied after the check for the synthetic attributes in the system</span>
  * namespace.
  */
<span class="p_del">-static bool btrfs_is_valid_xattr(const char *name)</span>
<span class="p_add">+static int btrfs_is_valid_xattr(const char *name)</span>
 {
<span class="p_del">-	return !strncmp(name, XATTR_SECURITY_PREFIX,</span>
<span class="p_del">-			XATTR_SECURITY_PREFIX_LEN) ||</span>
<span class="p_del">-	       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||</span>
<span class="p_del">-	       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||</span>
<span class="p_del">-	       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) ||</span>
<span class="p_del">-		!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN);</span>
<span class="p_add">+	int len = strlen(name);</span>
<span class="p_add">+	int prefixlen = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!strncmp(name, XATTR_SECURITY_PREFIX,</span>
<span class="p_add">+			XATTR_SECURITY_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_SECURITY_PREFIX_LEN;</span>
<span class="p_add">+	else if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_SYSTEM_PREFIX_LEN;</span>
<span class="p_add">+	else if (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_TRUSTED_PREFIX_LEN;</span>
<span class="p_add">+	else if (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_USER_PREFIX_LEN;</span>
<span class="p_add">+	else if (!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_BTRFS_PREFIX_LEN;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return -EOPNOTSUPP;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The name cannot consist of just prefix</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (len &lt;= prefixlen)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 ssize_t btrfs_getxattr(struct dentry *dentry, const char *name,
 		       void *buffer, size_t size)
 {
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
 	/*
 	 * If this is a request for a synthetic attribute in the system.*
 	 * namespace use the generic infrastructure to resolve a handler
<span class="p_chunk">@@ -348,8 +368,9 @@</span> <span class="p_context"> ssize_t btrfs_getxattr(struct dentry *dentry, const char *name,</span>
 	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
 		return generic_getxattr(dentry, name, buffer, size);
 
<span class="p_del">-	if (!btrfs_is_valid_xattr(name))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+	ret = btrfs_is_valid_xattr(name);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 	return __btrfs_getxattr(dentry-&gt;d_inode, name, buffer, size);
 }
 
<span class="p_chunk">@@ -357,6 +378,7 @@</span> <span class="p_context"> int btrfs_setxattr(struct dentry *dentry, const char *name, const void *value,</span>
 		   size_t size, int flags)
 {
 	struct btrfs_root *root = BTRFS_I(dentry-&gt;d_inode)-&gt;root;
<span class="p_add">+	int ret;</span>
 
 	/*
 	 * The permission on security.* and system.* is not checked
<span class="p_chunk">@@ -373,8 +395,9 @@</span> <span class="p_context"> int btrfs_setxattr(struct dentry *dentry, const char *name, const void *value,</span>
 	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
 		return generic_setxattr(dentry, name, value, size, flags);
 
<span class="p_del">-	if (!btrfs_is_valid_xattr(name))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+	ret = btrfs_is_valid_xattr(name);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	if (!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN))
 		return btrfs_set_prop(dentry-&gt;d_inode, name,
<span class="p_chunk">@@ -390,6 +413,7 @@</span> <span class="p_context"> int btrfs_setxattr(struct dentry *dentry, const char *name, const void *value,</span>
 int btrfs_removexattr(struct dentry *dentry, const char *name)
 {
 	struct btrfs_root *root = BTRFS_I(dentry-&gt;d_inode)-&gt;root;
<span class="p_add">+	int ret;</span>
 
 	/*
 	 * The permission on security.* and system.* is not checked
<span class="p_chunk">@@ -406,8 +430,9 @@</span> <span class="p_context"> int btrfs_removexattr(struct dentry *dentry, const char *name)</span>
 	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
 		return generic_removexattr(dentry, name);
 
<span class="p_del">-	if (!btrfs_is_valid_xattr(name))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+	ret = btrfs_is_valid_xattr(name);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	if (!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN))
 		return btrfs_set_prop(dentry-&gt;d_inode, name,
<span class="p_header">diff --git a/fs/exec.c b/fs/exec.c</span>
<span class="p_header">index ea4449d0536a..05f1942d7edb 100644</span>
<span class="p_header">--- a/fs/exec.c</span>
<span class="p_header">+++ b/fs/exec.c</span>
<span class="p_chunk">@@ -1268,6 +1268,53 @@</span> <span class="p_context"> static void check_unsafe_exec(struct linux_binprm *bprm)</span>
 	spin_unlock(&amp;p-&gt;fs-&gt;lock);
 }
 
<span class="p_add">+static void bprm_fill_uid(struct linux_binprm *bprm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct inode *inode;</span>
<span class="p_add">+	unsigned int mode;</span>
<span class="p_add">+	kuid_t uid;</span>
<span class="p_add">+	kgid_t gid;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* clear any previous set[ug]id data from a previous binary */</span>
<span class="p_add">+	bprm-&gt;cred-&gt;euid = current_euid();</span>
<span class="p_add">+	bprm-&gt;cred-&gt;egid = current_egid();</span>
<span class="p_add">+</span>
<span class="p_add">+	if (bprm-&gt;file-&gt;f_path.mnt-&gt;mnt_flags &amp; MNT_NOSUID)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (current-&gt;no_new_privs)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	inode = file_inode(bprm-&gt;file);</span>
<span class="p_add">+	mode = ACCESS_ONCE(inode-&gt;i_mode);</span>
<span class="p_add">+	if (!(mode &amp; (S_ISUID|S_ISGID)))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Be careful if suid/sgid is set */</span>
<span class="p_add">+	mutex_lock(&amp;inode-&gt;i_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* reload atomically mode/uid/gid now that lock held */</span>
<span class="p_add">+	mode = inode-&gt;i_mode;</span>
<span class="p_add">+	uid = inode-&gt;i_uid;</span>
<span class="p_add">+	gid = inode-&gt;i_gid;</span>
<span class="p_add">+	mutex_unlock(&amp;inode-&gt;i_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We ignore suid/sgid if there are no mappings for them in the ns */</span>
<span class="p_add">+	if (!kuid_has_mapping(bprm-&gt;cred-&gt;user_ns, uid) ||</span>
<span class="p_add">+		 !kgid_has_mapping(bprm-&gt;cred-&gt;user_ns, gid))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mode &amp; S_ISUID) {</span>
<span class="p_add">+		bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span>
<span class="p_add">+		bprm-&gt;cred-&gt;euid = uid;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((mode &amp; (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {</span>
<span class="p_add">+		bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span>
<span class="p_add">+		bprm-&gt;cred-&gt;egid = gid;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Fill the binprm structure from the inode.
  * Check permissions, then read the first 128 (BINPRM_BUF_SIZE) bytes
<span class="p_chunk">@@ -1276,36 +1323,9 @@</span> <span class="p_context"> static void check_unsafe_exec(struct linux_binprm *bprm)</span>
  */
 int prepare_binprm(struct linux_binprm *bprm)
 {
<span class="p_del">-	struct inode *inode = file_inode(bprm-&gt;file);</span>
<span class="p_del">-	umode_t mode = inode-&gt;i_mode;</span>
 	int retval;
 
<span class="p_del">-</span>
<span class="p_del">-	/* clear any previous set[ug]id data from a previous binary */</span>
<span class="p_del">-	bprm-&gt;cred-&gt;euid = current_euid();</span>
<span class="p_del">-	bprm-&gt;cred-&gt;egid = current_egid();</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!(bprm-&gt;file-&gt;f_path.mnt-&gt;mnt_flags &amp; MNT_NOSUID) &amp;&amp;</span>
<span class="p_del">-	    !current-&gt;no_new_privs &amp;&amp;</span>
<span class="p_del">-	    kuid_has_mapping(bprm-&gt;cred-&gt;user_ns, inode-&gt;i_uid) &amp;&amp;</span>
<span class="p_del">-	    kgid_has_mapping(bprm-&gt;cred-&gt;user_ns, inode-&gt;i_gid)) {</span>
<span class="p_del">-		/* Set-uid? */</span>
<span class="p_del">-		if (mode &amp; S_ISUID) {</span>
<span class="p_del">-			bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span>
<span class="p_del">-			bprm-&gt;cred-&gt;euid = inode-&gt;i_uid;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Set-gid? */</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * If setgid is set but no group execute bit then this</span>
<span class="p_del">-		 * is a candidate for mandatory locking, not a setgid</span>
<span class="p_del">-		 * executable.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if ((mode &amp; (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {</span>
<span class="p_del">-			bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span>
<span class="p_del">-			bprm-&gt;cred-&gt;egid = inode-&gt;i_gid;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_add">+	bprm_fill_uid(bprm);</span>
 
 	/* fill in binprm security blob */
 	retval = security_bprm_set_creds(bprm);
<span class="p_header">diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c</span>
<span class="p_header">index 2dcbfb6245d8..bc7e37bc0c5b 100644</span>
<span class="p_header">--- a/fs/ext4/namei.c</span>
<span class="p_header">+++ b/fs/ext4/namei.c</span>
<span class="p_chunk">@@ -1869,7 +1869,7 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 			  struct inode *inode)
 {
 	struct inode *dir = dentry-&gt;d_parent-&gt;d_inode;
<span class="p_del">-	struct buffer_head *bh;</span>
<span class="p_add">+	struct buffer_head *bh = NULL;</span>
 	struct ext4_dir_entry_2 *de;
 	struct ext4_dir_entry_tail *t;
 	struct super_block *sb;
<span class="p_chunk">@@ -1893,14 +1893,14 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 			return retval;
 		if (retval == 1) {
 			retval = 0;
<span class="p_del">-			return retval;</span>
<span class="p_add">+			goto out;</span>
 		}
 	}
 
 	if (is_dx(dir)) {
 		retval = ext4_dx_add_entry(handle, dentry, inode);
 		if (!retval || (retval != ERR_BAD_DX_DIR))
<span class="p_del">-			return retval;</span>
<span class="p_add">+			goto out;</span>
 		ext4_clear_inode_flag(dir, EXT4_INODE_INDEX);
 		dx_fallback++;
 		ext4_mark_inode_dirty(handle, dir);
<span class="p_chunk">@@ -1912,14 +1912,15 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 			return PTR_ERR(bh);
 
 		retval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);
<span class="p_del">-		if (retval != -ENOSPC) {</span>
<span class="p_del">-			brelse(bh);</span>
<span class="p_del">-			return retval;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (retval != -ENOSPC)</span>
<span class="p_add">+			goto out;</span>
 
 		if (blocks == 1 &amp;&amp; !dx_fallback &amp;&amp;
<span class="p_del">-		    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX))</span>
<span class="p_del">-			return make_indexed_dir(handle, dentry, inode, bh);</span>
<span class="p_add">+		    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX)) {</span>
<span class="p_add">+			retval = make_indexed_dir(handle, dentry, inode, bh);</span>
<span class="p_add">+			bh = NULL; /* make_indexed_dir releases bh */</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
 		brelse(bh);
 	}
 	bh = ext4_append(handle, dir, &amp;block);
<span class="p_chunk">@@ -1935,6 +1936,7 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 	}
 
 	retval = add_dirent_to_buf(handle, dentry, inode, de, bh);
<span class="p_add">+out:</span>
 	brelse(bh);
 	if (retval == 0)
 		ext4_set_inode_state(inode, EXT4_STATE_NEWENTRY);
<span class="p_header">diff --git a/fs/namei.c b/fs/namei.c</span>
<span class="p_header">index 0dd72c8e65fd..ccb8000f3459 100644</span>
<span class="p_header">--- a/fs/namei.c</span>
<span class="p_header">+++ b/fs/namei.c</span>
<span class="p_chunk">@@ -1545,7 +1545,8 @@</span> <span class="p_context"> static inline int walk_component(struct nameidata *nd, struct path *path,</span>
 
 	if (should_follow_link(path-&gt;dentry, follow)) {
 		if (nd-&gt;flags &amp; LOOKUP_RCU) {
<span class="p_del">-			if (unlikely(unlazy_walk(nd, path-&gt;dentry))) {</span>
<span class="p_add">+			if (unlikely(nd-&gt;path.mnt != path-&gt;mnt ||</span>
<span class="p_add">+				     unlazy_walk(nd, path-&gt;dentry))) {</span>
 				err = -ECHILD;
 				goto out_err;
 			}
<span class="p_chunk">@@ -2992,7 +2993,8 @@</span> <span class="p_context"> finish_lookup:</span>
 
 	if (should_follow_link(path-&gt;dentry, !symlink_ok)) {
 		if (nd-&gt;flags &amp; LOOKUP_RCU) {
<span class="p_del">-			if (unlikely(unlazy_walk(nd, path-&gt;dentry))) {</span>
<span class="p_add">+			if (unlikely(nd-&gt;path.mnt != path-&gt;mnt ||</span>
<span class="p_add">+				     unlazy_walk(nd, path-&gt;dentry))) {</span>
 				error = -ECHILD;
 				goto out;
 			}
<span class="p_header">diff --git a/fs/open.c b/fs/open.c</span>
<span class="p_header">index 2ed7325f713e..17679f2b2f1c 100644</span>
<span class="p_header">--- a/fs/open.c</span>
<span class="p_header">+++ b/fs/open.c</span>
<span class="p_chunk">@@ -539,6 +539,7 @@</span> <span class="p_context"> static int chown_common(struct path *path, uid_t user, gid_t group)</span>
 	uid = make_kuid(current_user_ns(), user);
 	gid = make_kgid(current_user_ns(), group);
 
<span class="p_add">+retry_deleg:</span>
 	newattrs.ia_valid =  ATTR_CTIME;
 	if (user != (uid_t) -1) {
 		if (!uid_valid(uid))
<span class="p_chunk">@@ -555,7 +556,6 @@</span> <span class="p_context"> static int chown_common(struct path *path, uid_t user, gid_t group)</span>
 	if (!S_ISDIR(inode-&gt;i_mode))
 		newattrs.ia_valid |=
 			ATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_KILL_PRIV;
<span class="p_del">-retry_deleg:</span>
 	mutex_lock(&amp;inode-&gt;i_mutex);
 	error = security_path_chown(path, uid, gid);
 	if (!error)
<span class="p_header">diff --git a/include/acpi/actypes.h b/include/acpi/actypes.h</span>
<span class="p_header">index 68a3ada689c9..8fc12f80b616 100644</span>
<span class="p_header">--- a/include/acpi/actypes.h</span>
<span class="p_header">+++ b/include/acpi/actypes.h</span>
<span class="p_chunk">@@ -198,9 +198,29 @@</span> <span class="p_context"> typedef int INT32;</span>
 typedef s32 acpi_native_int;
 
 typedef u32 acpi_size;
<span class="p_add">+</span>
<span class="p_add">+#ifdef ACPI_32BIT_PHYSICAL_ADDRESS</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * OSPMs can define this to shrink the size of the structures for 32-bit</span>
<span class="p_add">+ * none PAE environment. ASL compiler may always define this to generate</span>
<span class="p_add">+ * 32-bit OSPM compliant tables.</span>
<span class="p_add">+ */</span>
 typedef u32 acpi_io_address;
 typedef u32 acpi_physical_address;
 
<span class="p_add">+#else				/* ACPI_32BIT_PHYSICAL_ADDRESS */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * It is reported that, after some calculations, the physical addresses can</span>
<span class="p_add">+ * wrap over the 32-bit boundary on 32-bit PAE environment.</span>
<span class="p_add">+ * https://bugzilla.kernel.org/show_bug.cgi?id=87971</span>
<span class="p_add">+ */</span>
<span class="p_add">+typedef u64 acpi_io_address;</span>
<span class="p_add">+typedef u64 acpi_physical_address;</span>
<span class="p_add">+</span>
<span class="p_add">+#endif				/* ACPI_32BIT_PHYSICAL_ADDRESS */</span>
<span class="p_add">+</span>
 #define ACPI_MAX_PTR                    ACPI_UINT32_MAX
 #define ACPI_SIZE_MAX                   ACPI_UINT32_MAX
 
<span class="p_header">diff --git a/include/acpi/platform/acenv.h b/include/acpi/platform/acenv.h</span>
<span class="p_header">index b402eb67af83..579912c7156c 100644</span>
<span class="p_header">--- a/include/acpi/platform/acenv.h</span>
<span class="p_header">+++ b/include/acpi/platform/acenv.h</span>
<span class="p_chunk">@@ -76,6 +76,7 @@</span> <span class="p_context"></span>
 #define ACPI_LARGE_NAMESPACE_NODE
 #define ACPI_DATA_TABLE_DISASSEMBLY
 #define ACPI_SINGLE_THREADED
<span class="p_add">+#define ACPI_32BIT_PHYSICAL_ADDRESS</span>
 #endif
 
 /* acpi_exec configuration. Multithreaded with full AML debugger */
<span class="p_header">diff --git a/include/asm-generic/sections.h b/include/asm-generic/sections.h</span>
<span class="p_header">index f1a24b5c3b90..b58fd667f87b 100644</span>
<span class="p_header">--- a/include/asm-generic/sections.h</span>
<span class="p_header">+++ b/include/asm-generic/sections.h</span>
<span class="p_chunk">@@ -3,6 +3,8 @@</span> <span class="p_context"></span>
 
 /* References to section boundaries */
 
<span class="p_add">+#include &lt;linux/compiler.h&gt;</span>
<span class="p_add">+</span>
 /*
  * Usage guidelines:
  * _text, _data: architecture specific, don&#39;t use them in arch-independent code
<span class="p_chunk">@@ -37,6 +39,8 @@</span> <span class="p_context"> extern char __start_rodata[], __end_rodata[];</span>
 /* Start and end of .ctors section - used for constructor calls. */
 extern char __ctors_start[], __ctors_end[];
 
<span class="p_add">+extern __visible const void __nosave_begin, __nosave_end;</span>
<span class="p_add">+</span>
 /* function descriptor handling (if any).  Override
  * in asm/sections.h */
 #ifndef dereference_function_descriptor
<span class="p_header">diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h</span>
<span class="p_header">index ad8f85908a56..ab3133797ff7 100644</span>
<span class="p_header">--- a/include/linux/skbuff.h</span>
<span class="p_header">+++ b/include/linux/skbuff.h</span>
<span class="p_chunk">@@ -661,6 +661,7 @@</span> <span class="p_context"> bool skb_try_coalesce(struct sk_buff *to, struct sk_buff *from,</span>
 
 struct sk_buff *__alloc_skb(unsigned int size, gfp_t priority, int flags,
 			    int node);
<span class="p_add">+struct sk_buff *__build_skb(void *data, unsigned int frag_size);</span>
 struct sk_buff *build_skb(void *data, unsigned int frag_size);
 static inline struct sk_buff *alloc_skb(unsigned int size,
 					gfp_t priority)
<span class="p_header">diff --git a/include/linux/usb.h b/include/linux/usb.h</span>
<span class="p_header">index 7f6eb859873e..49466beab90d 100644</span>
<span class="p_header">--- a/include/linux/usb.h</span>
<span class="p_header">+++ b/include/linux/usb.h</span>
<span class="p_chunk">@@ -206,6 +206,32 @@</span> <span class="p_context"> void usb_put_intf(struct usb_interface *intf);</span>
 #define USB_MAXINTERFACES	32
 #define USB_MAXIADS		(USB_MAXINTERFACES/2)
 
<span class="p_add">+/*</span>
<span class="p_add">+ * USB Resume Timer: Every Host controller driver should drive the resume</span>
<span class="p_add">+ * signalling on the bus for the amount of time defined by this macro.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * That way we will have a &#39;stable&#39; behavior among all HCDs supported by Linux.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Note that the USB Specification states we should drive resume for *at least*</span>
<span class="p_add">+ * 20 ms, but it doesn&#39;t give an upper bound. This creates two possible</span>
<span class="p_add">+ * situations which we want to avoid:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * (a) sometimes an msleep(20) might expire slightly before 20 ms, which causes</span>
<span class="p_add">+ * us to fail USB Electrical Tests, thus failing Certification</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * (b) Some (many) devices actually need more than 20 ms of resume signalling,</span>
<span class="p_add">+ * and while we can argue that&#39;s against the USB Specification, we don&#39;t have</span>
<span class="p_add">+ * control over which devices a certification laboratory will be using for</span>
<span class="p_add">+ * certification. If CertLab uses a device which was tested against Windows and</span>
<span class="p_add">+ * that happens to have relaxed resume signalling rules, we might fall into</span>
<span class="p_add">+ * situations where we fail interoperability and electrical tests.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * In order to avoid both conditions, we&#39;re using a 40 ms resume timeout, which</span>
<span class="p_add">+ * should cope with both LPJ calibration errors and devices not following every</span>
<span class="p_add">+ * detail of the USB Specification.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define USB_RESUME_TIMEOUT	40 /* ms */</span>
<span class="p_add">+</span>
 /**
  * struct usb_interface_cache - long-term representation of a device interface
  * @num_altsetting: number of altsettings defined.
<span class="p_header">diff --git a/include/target/target_core_base.h b/include/target/target_core_base.h</span>
<span class="p_header">index 349325404add..e4b9e011d2a1 100644</span>
<span class="p_header">--- a/include/target/target_core_base.h</span>
<span class="p_header">+++ b/include/target/target_core_base.h</span>
<span class="p_chunk">@@ -513,7 +513,7 @@</span> <span class="p_context"> struct se_cmd {</span>
 	sense_reason_t		(*execute_cmd)(struct se_cmd *);
 	sense_reason_t		(*execute_rw)(struct se_cmd *, struct scatterlist *,
 					      u32, enum dma_data_direction);
<span class="p_del">-	sense_reason_t (*transport_complete_callback)(struct se_cmd *);</span>
<span class="p_add">+	sense_reason_t (*transport_complete_callback)(struct se_cmd *, bool);</span>
 
 	unsigned char		*t_task_cdb;
 	unsigned char		__t_task_cdb[TCM_MAX_COMMAND_SIZE];
<span class="p_header">diff --git a/kernel/ptrace.c b/kernel/ptrace.c</span>
<span class="p_header">index 1f4bcb3cc21c..be9760f8284a 100644</span>
<span class="p_header">--- a/kernel/ptrace.c</span>
<span class="p_header">+++ b/kernel/ptrace.c</span>
<span class="p_chunk">@@ -720,6 +720,8 @@</span> <span class="p_context"> static int ptrace_peek_siginfo(struct task_struct *child,</span>
 static int ptrace_resume(struct task_struct *child, long request,
 			 unsigned long data)
 {
<span class="p_add">+	bool need_siglock;</span>
<span class="p_add">+</span>
 	if (!valid_signal(data))
 		return -EIO;
 
<span class="p_chunk">@@ -747,8 +749,26 @@</span> <span class="p_context"> static int ptrace_resume(struct task_struct *child, long request,</span>
 		user_disable_single_step(child);
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Change -&gt;exit_code and -&gt;state under siglock to avoid the race</span>
<span class="p_add">+	 * with wait_task_stopped() in between; a non-zero -&gt;exit_code will</span>
<span class="p_add">+	 * wrongly look like another report from tracee.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note that we need siglock even if -&gt;exit_code == data and/or this</span>
<span class="p_add">+	 * status was not reported yet, the new status must not be cleared by</span>
<span class="p_add">+	 * wait_task_stopped() after resume.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * If data == 0 we do not care if wait_task_stopped() reports the old</span>
<span class="p_add">+	 * status and clears the code too; this can&#39;t race with the tracee, it</span>
<span class="p_add">+	 * takes siglock after resume.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	need_siglock = data &amp;&amp; !thread_group_empty(current);</span>
<span class="p_add">+	if (need_siglock)</span>
<span class="p_add">+		spin_lock_irq(&amp;child-&gt;sighand-&gt;siglock);</span>
 	child-&gt;exit_code = data;
 	wake_up_state(child, __TASK_TRACED);
<span class="p_add">+	if (need_siglock)</span>
<span class="p_add">+		spin_unlock_irq(&amp;child-&gt;sighand-&gt;siglock);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/kernel/softirq.c b/kernel/softirq.c</span>
<span class="p_header">index 490fcbb1dc5b..93be750348c8 100644</span>
<span class="p_header">--- a/kernel/softirq.c</span>
<span class="p_header">+++ b/kernel/softirq.c</span>
<span class="p_chunk">@@ -657,9 +657,13 @@</span> <span class="p_context"> static void run_ksoftirqd(unsigned int cpu)</span>
 		 * in the task stack here.
 		 */
 		__do_softirq();
<span class="p_del">-		rcu_note_context_switch(cpu);</span>
 		local_irq_enable();
 		cond_resched();
<span class="p_add">+</span>
<span class="p_add">+		preempt_disable();</span>
<span class="p_add">+		rcu_note_context_switch(cpu);</span>
<span class="p_add">+		preempt_enable();</span>
<span class="p_add">+</span>
 		return;
 	}
 	local_irq_enable();
<span class="p_header">diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c</span>
<span class="p_header">index 774a0807fe81..da41de9dc319 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer.c</span>
<span class="p_chunk">@@ -2651,7 +2651,7 @@</span> <span class="p_context"> static DEFINE_PER_CPU(unsigned int, current_context);</span>
 
 static __always_inline int trace_recursive_lock(void)
 {
<span class="p_del">-	unsigned int val = this_cpu_read(current_context);</span>
<span class="p_add">+	unsigned int val = __this_cpu_read(current_context);</span>
 	int bit;
 
 	if (in_interrupt()) {
<span class="p_chunk">@@ -2668,18 +2668,17 @@</span> <span class="p_context"> static __always_inline int trace_recursive_lock(void)</span>
 		return 1;
 
 	val |= (1 &lt;&lt; bit);
<span class="p_del">-	this_cpu_write(current_context, val);</span>
<span class="p_add">+	__this_cpu_write(current_context, val);</span>
 
 	return 0;
 }
 
 static __always_inline void trace_recursive_unlock(void)
 {
<span class="p_del">-	unsigned int val = this_cpu_read(current_context);</span>
<span class="p_add">+	unsigned int val = __this_cpu_read(current_context);</span>
 
<span class="p_del">-	val--;</span>
<span class="p_del">-	val &amp;= this_cpu_read(current_context);</span>
<span class="p_del">-	this_cpu_write(current_context, val);</span>
<span class="p_add">+	val &amp;= val &amp; (val - 1);</span>
<span class="p_add">+	__this_cpu_write(current_context, val);</span>
 }
 
 #else
<span class="p_header">diff --git a/lib/string.c b/lib/string.c</span>
<span class="p_header">index 43d0781daf47..cb9ea2181557 100644</span>
<span class="p_header">--- a/lib/string.c</span>
<span class="p_header">+++ b/lib/string.c</span>
<span class="p_chunk">@@ -598,7 +598,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(memset);</span>
 void memzero_explicit(void *s, size_t count)
 {
 	memset(s, 0, count);
<span class="p_del">-	OPTIMIZER_HIDE_VAR(s);</span>
<span class="p_add">+	barrier();</span>
 }
 EXPORT_SYMBOL(memzero_explicit);
 
<span class="p_header">diff --git a/net/core/skbuff.c b/net/core/skbuff.c</span>
<span class="p_header">index e2b1bba69882..69ec61abfb37 100644</span>
<span class="p_header">--- a/net/core/skbuff.c</span>
<span class="p_header">+++ b/net/core/skbuff.c</span>
<span class="p_chunk">@@ -278,13 +278,14 @@</span> <span class="p_context"> nodata:</span>
 EXPORT_SYMBOL(__alloc_skb);
 
 /**
<span class="p_del">- * build_skb - build a network buffer</span>
<span class="p_add">+ * __build_skb - build a network buffer</span>
  * @data: data buffer provided by caller
<span class="p_del">- * @frag_size: size of fragment, or 0 if head was kmalloced</span>
<span class="p_add">+ * @frag_size: size of data, or 0 if head was kmalloced</span>
  *
  * Allocate a new &amp;sk_buff. Caller provides space holding head and
  * skb_shared_info. @data must have been allocated by kmalloc() only if
<span class="p_del">- * @frag_size is 0, otherwise data should come from the page allocator.</span>
<span class="p_add">+ * @frag_size is 0, otherwise data should come from the page allocator</span>
<span class="p_add">+ *  or vmalloc()</span>
  * The return is the new skb buffer.
  * On a failure the return is %NULL, and @data is not freed.
  * Notes :
<span class="p_chunk">@@ -295,7 +296,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(__alloc_skb);</span>
  *  before giving packet to stack.
  *  RX rings only contains data buffers, not full skbs.
  */
<span class="p_del">-struct sk_buff *build_skb(void *data, unsigned int frag_size)</span>
<span class="p_add">+struct sk_buff *__build_skb(void *data, unsigned int frag_size)</span>
 {
 	struct skb_shared_info *shinfo;
 	struct sk_buff *skb;
<span class="p_chunk">@@ -309,7 +310,6 @@</span> <span class="p_context"> struct sk_buff *build_skb(void *data, unsigned int frag_size)</span>
 
 	memset(skb, 0, offsetof(struct sk_buff, tail));
 	skb-&gt;truesize = SKB_TRUESIZE(size);
<span class="p_del">-	skb-&gt;head_frag = frag_size != 0;</span>
 	atomic_set(&amp;skb-&gt;users, 1);
 	skb-&gt;head = data;
 	skb-&gt;data = data;
<span class="p_chunk">@@ -326,6 +326,23 @@</span> <span class="p_context"> struct sk_buff *build_skb(void *data, unsigned int frag_size)</span>
 
 	return skb;
 }
<span class="p_add">+</span>
<span class="p_add">+/* build_skb() is wrapper over __build_skb(), that specifically</span>
<span class="p_add">+ * takes care of skb-&gt;head and skb-&gt;pfmemalloc</span>
<span class="p_add">+ * This means that if @frag_size is not zero, then @data must be backed</span>
<span class="p_add">+ * by a page fragment, not kmalloc() or vmalloc()</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct sk_buff *build_skb(void *data, unsigned int frag_size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sk_buff *skb = __build_skb(data, frag_size);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (skb &amp;&amp; frag_size) {</span>
<span class="p_add">+		skb-&gt;head_frag = 1;</span>
<span class="p_add">+		if (virt_to_head_page(data)-&gt;pfmemalloc)</span>
<span class="p_add">+			skb-&gt;pfmemalloc = 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return skb;</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL(build_skb);
 
 struct netdev_alloc_cache {
<span class="p_chunk">@@ -352,7 +369,8 @@</span> <span class="p_context"> refill:</span>
 			gfp_t gfp = gfp_mask;
 
 			if (order)
<span class="p_del">-				gfp |= __GFP_COMP | __GFP_NOWARN;</span>
<span class="p_add">+				gfp |= __GFP_COMP | __GFP_NOWARN |</span>
<span class="p_add">+				       __GFP_NOMEMALLOC;</span>
 			nc-&gt;frag.page = alloc_pages(gfp, order);
 			if (likely(nc-&gt;frag.page))
 				break;
<span class="p_header">diff --git a/net/ipv4/ip_forward.c b/net/ipv4/ip_forward.c</span>
<span class="p_header">index ecb34b5ea42f..57075c4508f7 100644</span>
<span class="p_header">--- a/net/ipv4/ip_forward.c</span>
<span class="p_header">+++ b/net/ipv4/ip_forward.c</span>
<span class="p_chunk">@@ -127,6 +127,9 @@</span> <span class="p_context"> int ip_forward(struct sk_buff *skb)</span>
 	struct rtable *rt;	/* Route we use */
 	struct ip_options *opt	= &amp;(IPCB(skb)-&gt;opt);
 
<span class="p_add">+	if (unlikely(skb-&gt;sk))</span>
<span class="p_add">+		goto drop;</span>
<span class="p_add">+</span>
 	if (skb_warn_if_lro(skb))
 		goto drop;
 
<span class="p_header">diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c</span>
<span class="p_header">index 8c70c73da347..a68cd7100349 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_output.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_output.c</span>
<span class="p_chunk">@@ -2595,39 +2595,65 @@</span> <span class="p_context"> begin_fwd:</span>
 	}
 }
 
<span class="p_del">-/* Send a fin.  The caller locks the socket for us.  This cannot be</span>
<span class="p_del">- * allowed to fail queueing a FIN frame under any circumstances.</span>
<span class="p_add">+/* We allow to exceed memory limits for FIN packets to expedite</span>
<span class="p_add">+ * connection tear down and (memory) recovery.</span>
<span class="p_add">+ * Otherwise tcp_send_fin() could be tempted to either delay FIN</span>
<span class="p_add">+ * or even be forced to close flow without any FIN.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void sk_forced_wmem_schedule(struct sock *sk, int size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int amt, status;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (size &lt;= sk-&gt;sk_forward_alloc)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	amt = sk_mem_pages(size);</span>
<span class="p_add">+	sk-&gt;sk_forward_alloc += amt * SK_MEM_QUANTUM;</span>
<span class="p_add">+	sk_memory_allocated_add(sk, amt, &amp;status);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Send a FIN. The caller locks the socket for us.</span>
<span class="p_add">+ * We should try to send a FIN packet really hard, but eventually give up.</span>
  */
 void tcp_send_fin(struct sock *sk)
 {
<span class="p_add">+	struct sk_buff *skb, *tskb = tcp_write_queue_tail(sk);</span>
 	struct tcp_sock *tp = tcp_sk(sk);
<span class="p_del">-	struct sk_buff *skb = tcp_write_queue_tail(sk);</span>
<span class="p_del">-	int mss_now;</span>
 
<span class="p_del">-	/* Optimization, tack on the FIN if we have a queue of</span>
<span class="p_del">-	 * unsent frames.  But be careful about outgoing SACKS</span>
<span class="p_del">-	 * and IP options.</span>
<span class="p_add">+	/* Optimization, tack on the FIN if we have one skb in write queue and</span>
<span class="p_add">+	 * this skb was not yet sent, or we are under memory pressure.</span>
<span class="p_add">+	 * Note: in the latter case, FIN packet will be sent after a timeout,</span>
<span class="p_add">+	 * as TCP stack thinks it has already been transmitted.</span>
 	 */
<span class="p_del">-	mss_now = tcp_current_mss(sk);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (tcp_send_head(sk) != NULL) {</span>
<span class="p_del">-		TCP_SKB_CB(skb)-&gt;tcp_flags |= TCPHDR_FIN;</span>
<span class="p_del">-		TCP_SKB_CB(skb)-&gt;end_seq++;</span>
<span class="p_add">+	if (tskb &amp;&amp; (tcp_send_head(sk) || sk_under_memory_pressure(sk))) {</span>
<span class="p_add">+coalesce:</span>
<span class="p_add">+		TCP_SKB_CB(tskb)-&gt;tcp_flags |= TCPHDR_FIN;</span>
<span class="p_add">+		TCP_SKB_CB(tskb)-&gt;end_seq++;</span>
 		tp-&gt;write_seq++;
<span class="p_add">+		if (!tcp_send_head(sk)) {</span>
<span class="p_add">+			/* This means tskb was already sent.</span>
<span class="p_add">+			 * Pretend we included the FIN on previous transmit.</span>
<span class="p_add">+			 * We need to set tp-&gt;snd_nxt to the value it would have</span>
<span class="p_add">+			 * if FIN had been sent. This is because retransmit path</span>
<span class="p_add">+			 * does not change tp-&gt;snd_nxt.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			tp-&gt;snd_nxt++;</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
 	} else {
<span class="p_del">-		/* Socket is locked, keep trying until memory is available. */</span>
<span class="p_del">-		for (;;) {</span>
<span class="p_del">-			skb = sk_stream_alloc_skb(sk, 0, sk-&gt;sk_allocation);</span>
<span class="p_del">-			if (skb)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			yield();</span>
<span class="p_add">+		skb = alloc_skb_fclone(MAX_TCP_HEADER, sk-&gt;sk_allocation);</span>
<span class="p_add">+		if (unlikely(!skb)) {</span>
<span class="p_add">+			if (tskb)</span>
<span class="p_add">+				goto coalesce;</span>
<span class="p_add">+			return;</span>
 		}
<span class="p_add">+		skb_reserve(skb, MAX_TCP_HEADER);</span>
<span class="p_add">+		sk_forced_wmem_schedule(sk, skb-&gt;truesize);</span>
 		/* FIN eats a sequence byte, write_seq advanced by tcp_queue_skb(). */
 		tcp_init_nondata_skb(skb, tp-&gt;write_seq,
 				     TCPHDR_ACK | TCPHDR_FIN);
 		tcp_queue_skb(sk, skb);
 	}
<span class="p_del">-	__tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_OFF);</span>
<span class="p_add">+	__tcp_push_pending_frames(sk, tcp_current_mss(sk), TCP_NAGLE_OFF);</span>
 }
 
 /* We get here when a process closes a file descriptor (either due to
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index 1d52506bda14..a0b0ea949192 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -1624,13 +1624,11 @@</span> <span class="p_context"> static struct sk_buff *netlink_alloc_large_skb(unsigned int size,</span>
 	if (data == NULL)
 		return NULL;
 
<span class="p_del">-	skb = build_skb(data, size);</span>
<span class="p_add">+	skb = __build_skb(data, size);</span>
 	if (skb == NULL)
 		vfree(data);
<span class="p_del">-	else {</span>
<span class="p_del">-		skb-&gt;head_frag = 0;</span>
<span class="p_add">+	else</span>
 		skb-&gt;destructor = netlink_skb_destructor;
<span class="p_del">-	}</span>
 
 	return skb;
 }
<span class="p_header">diff --git a/sound/pci/emu10k1/emuproc.c b/sound/pci/emu10k1/emuproc.c</span>
<span class="p_header">index 2ca9f2e93139..53745f4c2bf5 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emuproc.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emuproc.c</span>
<span class="p_chunk">@@ -241,31 +241,22 @@</span> <span class="p_context"> static void snd_emu10k1_proc_spdif_read(struct snd_info_entry *entry,</span>
 	struct snd_emu10k1 *emu = entry-&gt;private_data;
 	u32 value;
 	u32 value2;
<span class="p_del">-	unsigned long flags;</span>
 	u32 rate;
 
 	if (emu-&gt;card_capabilities-&gt;emu_model) {
<span class="p_del">-		spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_emu1010_fpga_read(emu, 0x38, &amp;value);
<span class="p_del">-		spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 		if ((value &amp; 0x1) == 0) {
<span class="p_del">-			spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 			snd_emu1010_fpga_read(emu, 0x2a, &amp;value);
 			snd_emu1010_fpga_read(emu, 0x2b, &amp;value2);
<span class="p_del">-			spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 			rate = 0x1770000 / (((value &lt;&lt; 5) | value2)+1);	
 			snd_iprintf(buffer, &quot;ADAT Locked : %u\n&quot;, rate);
 		} else {
 			snd_iprintf(buffer, &quot;ADAT Unlocked\n&quot;);
 		}
<span class="p_del">-		spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_emu1010_fpga_read(emu, 0x20, &amp;value);
<span class="p_del">-		spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 		if ((value &amp; 0x4) == 0) {
<span class="p_del">-			spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 			snd_emu1010_fpga_read(emu, 0x28, &amp;value);
 			snd_emu1010_fpga_read(emu, 0x29, &amp;value2);
<span class="p_del">-			spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 			rate = 0x1770000 / (((value &lt;&lt; 5) | value2)+1);	
 			snd_iprintf(buffer, &quot;SPDIF Locked : %d\n&quot;, rate);
 		} else {
<span class="p_chunk">@@ -410,14 +401,11 @@</span> <span class="p_context"> static void snd_emu_proc_emu1010_reg_read(struct snd_info_entry *entry,</span>
 {
 	struct snd_emu10k1 *emu = entry-&gt;private_data;
 	u32 value;
<span class="p_del">-	unsigned long flags;</span>
 	int i;
 	snd_iprintf(buffer, &quot;EMU1010 Registers:\n\n&quot;);
 
 	for(i = 0; i &lt; 0x40; i+=1) {
<span class="p_del">-		spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_emu1010_fpga_read(emu, i, &amp;value);
<span class="p_del">-		spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_iprintf(buffer, &quot;%02X: %08X, %02X\n&quot;, i, value, (value &gt;&gt; 8) &amp; 0x7f);
 	}
 }
<span class="p_header">diff --git a/sound/soc/davinci/davinci-evm.c b/sound/soc/davinci/davinci-evm.c</span>
<span class="p_header">index 5e3bc3c6801a..f40a7a4b6591 100644</span>
<span class="p_header">--- a/sound/soc/davinci/davinci-evm.c</span>
<span class="p_header">+++ b/sound/soc/davinci/davinci-evm.c</span>
<span class="p_chunk">@@ -384,18 +384,8 @@</span> <span class="p_context"> static int davinci_evm_probe(struct platform_device *pdev)</span>
 	return ret;
 }
 
<span class="p_del">-static int davinci_evm_remove(struct platform_device *pdev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct snd_soc_card *card = platform_get_drvdata(pdev);</span>
<span class="p_del">-</span>
<span class="p_del">-	snd_soc_unregister_card(card);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static struct platform_driver davinci_evm_driver = {
 	.probe		= davinci_evm_probe,
<span class="p_del">-	.remove		= davinci_evm_remove,</span>
 	.driver		= {
 		.name	= &quot;davinci_evm&quot;,
 		.owner	= THIS_MODULE,
<span class="p_header">diff --git a/tools/lib/traceevent/kbuffer-parse.c b/tools/lib/traceevent/kbuffer-parse.c</span>
<span class="p_header">index dcc665228c71..deb3569ab004 100644</span>
<span class="p_header">--- a/tools/lib/traceevent/kbuffer-parse.c</span>
<span class="p_header">+++ b/tools/lib/traceevent/kbuffer-parse.c</span>
<span class="p_chunk">@@ -372,7 +372,6 @@</span> <span class="p_context"> translate_data(struct kbuffer *kbuf, void *data, void **rptr,</span>
 	switch (type_len) {
 	case KBUFFER_TYPE_PADDING:
 		*length = read_4(kbuf, data);
<span class="p_del">-		data += *length;</span>
 		break;
 
 	case KBUFFER_TYPE_TIME_EXTEND:
<span class="p_header">diff --git a/tools/power/x86/turbostat/Makefile b/tools/power/x86/turbostat/Makefile</span>
<span class="p_header">index d1b3a361e526..4039854560d0 100644</span>
<span class="p_header">--- a/tools/power/x86/turbostat/Makefile</span>
<span class="p_header">+++ b/tools/power/x86/turbostat/Makefile</span>
<span class="p_chunk">@@ -1,8 +1,12 @@</span> <span class="p_context"></span>
 CC		= $(CROSS_COMPILE)gcc
<span class="p_del">-BUILD_OUTPUT	:= $(PWD)</span>
<span class="p_add">+BUILD_OUTPUT	:= $(CURDIR)</span>
 PREFIX		:= /usr
 DESTDIR		:=
 
<span class="p_add">+ifeq (&quot;$(origin O)&quot;, &quot;command line&quot;)</span>
<span class="p_add">+	BUILD_OUTPUT := $(O)</span>
<span class="p_add">+endif</span>
<span class="p_add">+</span>
 turbostat : turbostat.c
 CFLAGS +=	-Wall
 CFLAGS +=	-DMSRHEADER=&#39;&quot;../../../../arch/x86/include/uapi/asm/msr-index.h&quot;&#39;
<span class="p_header">diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c</span>
<span class="p_header">index 66112533b1e9..eed250e9c218 100644</span>
<span class="p_header">--- a/virt/kvm/kvm_main.c</span>
<span class="p_header">+++ b/virt/kvm/kvm_main.c</span>
<span class="p_chunk">@@ -1549,8 +1549,8 @@</span> <span class="p_context"> int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc,</span>
 	ghc-&gt;generation = slots-&gt;generation;
 	ghc-&gt;len = len;
 	ghc-&gt;memslot = gfn_to_memslot(kvm, start_gfn);
<span class="p_del">-	ghc-&gt;hva = gfn_to_hva_many(ghc-&gt;memslot, start_gfn, &amp;nr_pages_avail);</span>
<span class="p_del">-	if (!kvm_is_error_hva(ghc-&gt;hva) &amp;&amp; nr_pages_avail &gt;= nr_pages_needed) {</span>
<span class="p_add">+	ghc-&gt;hva = gfn_to_hva_many(ghc-&gt;memslot, start_gfn, NULL);</span>
<span class="p_add">+	if (!kvm_is_error_hva(ghc-&gt;hva) &amp;&amp; nr_pages_needed &lt;= 1) {</span>
 		ghc-&gt;hva += offset;
 	} else {
 		/*

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



