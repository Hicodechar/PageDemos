
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3.4,000/146] 3.4.109-rc1 review - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3.4,000/146] 3.4.109-rc1 review</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=109711">Zefan Li</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Sept. 15, 2015, 9:18 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1442308696-32280-1-git-send-email-lizf@kernel.org&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7182091/mbox/"
   >mbox</a>
|
   <a href="/patch/7182091/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7182091/">/patch/7182091/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id AAB57BEEC1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 15 Sep 2015 09:20:03 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id D70262069D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 15 Sep 2015 09:19:54 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id B218A2045A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 15 Sep 2015 09:19:45 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1755353AbbIOJT2 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 15 Sep 2015 05:19:28 -0400
Received: from mail.kernel.org ([198.145.29.136]:54878 &quot;EHLO mail.kernel.org&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1755337AbbIOJTY (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 15 Sep 2015 05:19:24 -0400
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 18A6820328;
	Tue, 15 Sep 2015 09:19:14 +0000 (UTC)
Received: from localhost.localdomain (unknown [183.247.163.231])
	(using TLSv1.2 with cipher AES128-SHA256 (128/128 bits))
	(No client certificate requested)
	by mail.kernel.org (Postfix) with ESMTPSA id 0E91F2045A;
	Tue, 15 Sep 2015 09:19:01 +0000 (UTC)
From: lizf@kernel.org
To: stable@vger.kernel.org
Cc: linux-kernel@vger.kernel.org, linux@roeck-us.net,
	Zefan Li &lt;lizefan@huawei.com&gt;
Subject: Re: [PATCH 3.4 000/146] 3.4.109-rc1 review
Date: Tue, 15 Sep 2015 17:18:16 +0800
Message-Id: &lt;1442308696-32280-1-git-send-email-lizf@kernel.org&gt;
X-Mailer: git-send-email 1.9.1
In-Reply-To: &lt;1442307787-31952-1-git-send-email-lizf@kernel.org&gt;
References: &lt;1442307787-31952-1-git-send-email-lizf@kernel.org&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=109711">Zefan Li</a> - Sept. 15, 2015, 9:18 a.m.</div>
<pre class="content">
<span class="from">From: Zefan Li &lt;lizefan@huawei.com&gt;</span>

This is the combined patch for 3.4.106-rc1 relative to 3.4.105.

---

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/networking/rds.txt b/Documentation/networking/rds.txt</span>
<span class="p_header">index c67077c..e1a3d59 100644</span>
<span class="p_header">--- a/Documentation/networking/rds.txt</span>
<span class="p_header">+++ b/Documentation/networking/rds.txt</span>
<span class="p_chunk">@@ -62,11 +62,10 @@</span> <span class="p_context"> Socket Interface</span>
 ================
 
   AF_RDS, PF_RDS, SOL_RDS
<span class="p_del">-        These constants haven&#39;t been assigned yet, because RDS isn&#39;t in</span>
<span class="p_del">-        mainline yet. Currently, the kernel module assigns some constant</span>
<span class="p_del">-        and publishes it to user space through two sysctl files</span>
<span class="p_del">-                /proc/sys/net/rds/pf_rds</span>
<span class="p_del">-                /proc/sys/net/rds/sol_rds</span>
<span class="p_add">+	AF_RDS and PF_RDS are the domain type to be used with socket(2)</span>
<span class="p_add">+	to create RDS sockets. SOL_RDS is the socket-level to be used</span>
<span class="p_add">+	with setsockopt(2) and getsockopt(2) for RDS specific socket</span>
<span class="p_add">+	options.</span>
 
   fd = socket(PF_RDS, SOCK_SEQPACKET, 0);
         This creates a new, unbound RDS socket.
<span class="p_header">diff --git a/Documentation/pinctrl.txt b/Documentation/pinctrl.txt</span>
<span class="p_header">index d97bccf..d464716 100644</span>
<span class="p_header">--- a/Documentation/pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/pinctrl.txt</span>
<span class="p_chunk">@@ -72,7 +72,6 @@</span> <span class="p_context"> static struct pinctrl_desc foo_desc = {</span>
 	.name = &quot;foo&quot;,
 	.pins = foo_pins,
 	.npins = ARRAY_SIZE(foo_pins),
<span class="p_del">-	.maxpin = 63,</span>
 	.owner = THIS_MODULE,
 };
 
<span class="p_chunk">@@ -166,8 +165,8 @@</span> <span class="p_context"> static const char *foo_get_group_name(struct pinctrl_dev *pctldev,</span>
 }
 
 static int foo_get_group_pins(struct pinctrl_dev *pctldev, unsigned selector,
<span class="p_del">-			       unsigned ** const pins,</span>
<span class="p_del">-			       unsigned * const num_pins)</span>
<span class="p_add">+			       const unsigned **pins,</span>
<span class="p_add">+			       unsigned *num_pins)</span>
 {
 	*pins = (unsigned *) foo_groups[selector].pins;
 	*num_pins = foo_groups[selector].num_pins;
<span class="p_chunk">@@ -1043,7 +1042,7 @@</span> <span class="p_context"> The semantics of the pinctrl APIs are:</span>
 
 Usually the pin control core handled the get/put pair and call out to the
 device drivers bookkeeping operations, like checking available functions and
<span class="p_del">-the associated pins, whereas the enable/disable pass on to the pin controller</span>
<span class="p_add">+the associated pins, whereas select_state pass on to the pin controller</span>
 driver which takes care of activating and/or deactivating the mux setting by
 quickly poking some registers.
 
<span class="p_chunk">@@ -1089,8 +1088,9 @@</span> <span class="p_context"> function, but with different named in the mapping as described under</span>
 &quot;Advanced mapping&quot; above. So that for an SPI device, we have two states named
 &quot;pos-A&quot; and &quot;pos-B&quot;.
 
<span class="p_del">-This snippet first muxes the function in the pins defined by group A, enables</span>
<span class="p_del">-it, disables and releases it, and muxes it in on the pins defined by group B:</span>
<span class="p_add">+This snippet first initializes a state object for both groups (in foo_probe()),</span>
<span class="p_add">+then muxes the function in the pins defined by group A, and finally muxes it in</span>
<span class="p_add">+on the pins defined by group B:</span>
 
 #include &lt;linux/pinctrl/consumer.h&gt;
 
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 5056e1b..e78af5c 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 108</span>
<span class="p_del">-EXTRAVERSION =</span>
<span class="p_add">+SUBLEVEL = 109</span>
<span class="p_add">+EXTRAVERSION = -rc1</span>
 NAME = Saber-toothed Squirrel
 
 # *DOCUMENTATION*
<span class="p_header">diff --git a/arch/arm/boot/dts/imx27.dtsi b/arch/arm/boot/dts/imx27.dtsi</span>
<span class="p_header">index bc5e7d5..9cc8ed2 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx27.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx27.dtsi</span>
<span class="p_chunk">@@ -208,7 +208,7 @@</span> <span class="p_context"></span>
 
 			fec: fec@1002b000 {
 				compatible = &quot;fsl,imx27-fec&quot;;
<span class="p_del">-				reg = &lt;0x1002b000 0x4000&gt;;</span>
<span class="p_add">+				reg = &lt;0x1002b000 0x1000&gt;;</span>
 				interrupts = &lt;50&gt;;
 				status = &quot;disabled&quot;;
 			};
<span class="p_header">diff --git a/arch/arm/include/asm/elf.h b/arch/arm/include/asm/elf.h</span>
<span class="p_header">index 38050b1..dfc980b 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/elf.h</span>
<span class="p_chunk">@@ -116,7 +116,7 @@</span> <span class="p_context"> int dump_task_regs(struct task_struct *t, elf_gregset_t *elfregs);</span>
    the loader.  We need to make sure that it is out of the way of the program
    that it will &quot;exec&quot;, and that there is sufficient room for the brk.  */
 
<span class="p_del">-#define ELF_ET_DYN_BASE	(2 * TASK_SIZE / 3)</span>
<span class="p_add">+#define ELF_ET_DYN_BASE	(TASK_SIZE / 3 * 2)</span>
 
 /* When the program starts, a1 contains a pointer to a function to be 
    registered with atexit, as per the SVR4 ABI.  A value of 0 means we 
<span class="p_header">diff --git a/arch/arm/mach-pxa/Kconfig b/arch/arm/mach-pxa/Kconfig</span>
<span class="p_header">index fe2d1f8..2f8b171 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/Kconfig</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/Kconfig</span>
<span class="p_chunk">@@ -718,4 +718,13 @@</span> <span class="p_context"> config PXA_HAVE_ISA_IRQS</span>
 config PXA310_ULPI
 	bool
 
<span class="p_add">+config PXA_SYSTEMS_CPLDS</span>
<span class="p_add">+	tristate &quot;Motherboard cplds&quot;</span>
<span class="p_add">+	default ARCH_LUBBOCK || MACH_MAINSTONE</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  This driver supports the Lubbock and Mainstone multifunction chip</span>
<span class="p_add">+	  found on the pxa25x development platform system (Lubbock) and pxa27x</span>
<span class="p_add">+	  development platform system (Mainstone). This IO board supports the</span>
<span class="p_add">+	  interrupts handling, ethernet controller, flash chips, etc ...</span>
<span class="p_add">+</span>
 endif
<span class="p_header">diff --git a/arch/arm/mach-pxa/Makefile b/arch/arm/mach-pxa/Makefile</span>
<span class="p_header">index be0f7df..318c0d7 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/Makefile</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/Makefile</span>
<span class="p_chunk">@@ -103,4 +103,5 @@</span> <span class="p_context"> led-$(CONFIG_ARCH_PXA_IDP)	+= leds-idp.o</span>
 
 obj-$(CONFIG_LEDS)		+= $(led-y)
 
<span class="p_add">+obj-$(CONFIG_PXA_SYSTEMS_CPLDS)	+= pxa_cplds_irqs.o</span>
 obj-$(CONFIG_TOSA_BT)		+= tosa-bt.o
<span class="p_header">diff --git a/arch/arm/mach-pxa/include/mach/lubbock.h b/arch/arm/mach-pxa/include/mach/lubbock.h</span>
<span class="p_header">index 2a086e8..b20b97e 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/include/mach/lubbock.h</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/include/mach/lubbock.h</span>
<span class="p_chunk">@@ -35,7 +35,9 @@</span> <span class="p_context"></span>
 #define LUB_GP			__LUB_REG(LUBBOCK_FPGA_PHYS + 0x100)
 
 /* Board specific IRQs */
<span class="p_del">-#define LUBBOCK_IRQ(x)		(IRQ_BOARD_START + (x))</span>
<span class="p_add">+#define LUBBOCK_NR_IRQS		IRQ_BOARD_START</span>
<span class="p_add">+</span>
<span class="p_add">+#define LUBBOCK_IRQ(x)		(LUBBOCK_NR_IRQS + (x))</span>
 #define LUBBOCK_SD_IRQ		LUBBOCK_IRQ(0)
 #define LUBBOCK_SA1111_IRQ	LUBBOCK_IRQ(1)
 #define LUBBOCK_USB_IRQ		LUBBOCK_IRQ(2)  /* usb connect */
<span class="p_chunk">@@ -45,8 +47,7 @@</span> <span class="p_context"></span>
 #define LUBBOCK_USB_DISC_IRQ	LUBBOCK_IRQ(6)  /* usb disconnect */
 #define LUBBOCK_LAST_IRQ	LUBBOCK_IRQ(6)
 
<span class="p_del">-#define LUBBOCK_SA1111_IRQ_BASE	(IRQ_BOARD_START + 16)</span>
<span class="p_del">-#define LUBBOCK_NR_IRQS		(IRQ_BOARD_START + 16 + 55)</span>
<span class="p_add">+#define LUBBOCK_SA1111_IRQ_BASE	(LUBBOCK_NR_IRQS + 32)</span>
 
 #ifndef __ASSEMBLY__
 extern void lubbock_set_misc_wr(unsigned int mask, unsigned int set);
<span class="p_header">diff --git a/arch/arm/mach-pxa/include/mach/mainstone.h b/arch/arm/mach-pxa/include/mach/mainstone.h</span>
<span class="p_header">index 1bfc4e8..e82a7d3 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/include/mach/mainstone.h</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/include/mach/mainstone.h</span>
<span class="p_chunk">@@ -120,7 +120,9 @@</span> <span class="p_context"></span>
 #define MST_PCMCIA_PWR_VCC_50   0x4	   /* voltage VCC = 5.0V */
 
 /* board specific IRQs */
<span class="p_del">-#define MAINSTONE_IRQ(x)	(IRQ_BOARD_START + (x))</span>
<span class="p_add">+#define MAINSTONE_NR_IRQS	IRQ_BOARD_START</span>
<span class="p_add">+</span>
<span class="p_add">+#define MAINSTONE_IRQ(x)	(MAINSTONE_NR_IRQS + (x))</span>
 #define MAINSTONE_MMC_IRQ	MAINSTONE_IRQ(0)
 #define MAINSTONE_USIM_IRQ	MAINSTONE_IRQ(1)
 #define MAINSTONE_USBC_IRQ	MAINSTONE_IRQ(2)
<span class="p_chunk">@@ -136,6 +138,4 @@</span> <span class="p_context"></span>
 #define MAINSTONE_S1_STSCHG_IRQ	MAINSTONE_IRQ(14)
 #define MAINSTONE_S1_IRQ	MAINSTONE_IRQ(15)
 
<span class="p_del">-#define MAINSTONE_NR_IRQS	(IRQ_BOARD_START + 16)</span>
<span class="p_del">-</span>
 #endif
<span class="p_header">diff --git a/arch/arm/mach-pxa/lubbock.c b/arch/arm/mach-pxa/lubbock.c</span>
<span class="p_header">index 6bb3f47..799f31f 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/lubbock.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/lubbock.c</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"></span>
  *  published by the Free Software Foundation.
  */
 #include &lt;linux/gpio.h&gt;
<span class="p_add">+#include &lt;linux/gpio/machine.h&gt;</span>
 #include &lt;linux/module.h&gt;
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/init.h&gt;
<span class="p_chunk">@@ -120,84 +121,6 @@</span> <span class="p_context"> void lubbock_set_misc_wr(unsigned int mask, unsigned int set)</span>
 }
 EXPORT_SYMBOL(lubbock_set_misc_wr);
 
<span class="p_del">-static unsigned long lubbock_irq_enabled;</span>
<span class="p_del">-</span>
<span class="p_del">-static void lubbock_mask_irq(struct irq_data *d)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int lubbock_irq = (d-&gt;irq - LUBBOCK_IRQ(0));</span>
<span class="p_del">-	LUB_IRQ_MASK_EN = (lubbock_irq_enabled &amp;= ~(1 &lt;&lt; lubbock_irq));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void lubbock_unmask_irq(struct irq_data *d)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int lubbock_irq = (d-&gt;irq - LUBBOCK_IRQ(0));</span>
<span class="p_del">-	/* the irq can be acknowledged only if deasserted, so it&#39;s done here */</span>
<span class="p_del">-	LUB_IRQ_SET_CLR &amp;= ~(1 &lt;&lt; lubbock_irq);</span>
<span class="p_del">-	LUB_IRQ_MASK_EN = (lubbock_irq_enabled |= (1 &lt;&lt; lubbock_irq));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static struct irq_chip lubbock_irq_chip = {</span>
<span class="p_del">-	.name		= &quot;FPGA&quot;,</span>
<span class="p_del">-	.irq_ack	= lubbock_mask_irq,</span>
<span class="p_del">-	.irq_mask	= lubbock_mask_irq,</span>
<span class="p_del">-	.irq_unmask	= lubbock_unmask_irq,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static void lubbock_irq_handler(unsigned int irq, struct irq_desc *desc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long pending = LUB_IRQ_SET_CLR &amp; lubbock_irq_enabled;</span>
<span class="p_del">-	do {</span>
<span class="p_del">-		/* clear our parent irq */</span>
<span class="p_del">-		desc-&gt;irq_data.chip-&gt;irq_ack(&amp;desc-&gt;irq_data);</span>
<span class="p_del">-		if (likely(pending)) {</span>
<span class="p_del">-			irq = LUBBOCK_IRQ(0) + __ffs(pending);</span>
<span class="p_del">-			generic_handle_irq(irq);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		pending = LUB_IRQ_SET_CLR &amp; lubbock_irq_enabled;</span>
<span class="p_del">-	} while (pending);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init lubbock_init_irq(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int irq;</span>
<span class="p_del">-</span>
<span class="p_del">-	pxa25x_init_irq();</span>
<span class="p_del">-</span>
<span class="p_del">-	/* setup extra lubbock irqs */</span>
<span class="p_del">-	for (irq = LUBBOCK_IRQ(0); irq &lt;= LUBBOCK_LAST_IRQ; irq++) {</span>
<span class="p_del">-		irq_set_chip_and_handler(irq, &amp;lubbock_irq_chip,</span>
<span class="p_del">-					 handle_level_irq);</span>
<span class="p_del">-		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	irq_set_chained_handler(PXA_GPIO_TO_IRQ(0), lubbock_irq_handler);</span>
<span class="p_del">-	irq_set_irq_type(PXA_GPIO_TO_IRQ(0), IRQ_TYPE_EDGE_FALLING);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_PM</span>
<span class="p_del">-</span>
<span class="p_del">-static void lubbock_irq_resume(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	LUB_IRQ_MASK_EN = lubbock_irq_enabled;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static struct syscore_ops lubbock_irq_syscore_ops = {</span>
<span class="p_del">-	.resume = lubbock_irq_resume,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static int __init lubbock_irq_device_init(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (machine_is_lubbock()) {</span>
<span class="p_del">-		register_syscore_ops(&amp;lubbock_irq_syscore_ops);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return -ENODEV;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-device_initcall(lubbock_irq_device_init);</span>
<span class="p_del">-</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 static int lubbock_udc_is_connected(void)
 {
 	return (LUB_MISC_RD &amp; (1 &lt;&lt; 9)) == 0;
<span class="p_chunk">@@ -380,11 +303,38 @@</span> <span class="p_context"> static struct platform_device lubbock_flash_device[2] = {</span>
 	},
 };
 
<span class="p_add">+static struct resource lubbock_cplds_resources[] = {</span>
<span class="p_add">+	[0] = {</span>
<span class="p_add">+		.start	= LUBBOCK_FPGA_PHYS + 0xc0,</span>
<span class="p_add">+		.end	= LUBBOCK_FPGA_PHYS + 0xe0 - 1,</span>
<span class="p_add">+		.flags	= IORESOURCE_MEM,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	[1] = {</span>
<span class="p_add">+		.start	= PXA_GPIO_TO_IRQ(0),</span>
<span class="p_add">+		.end	= PXA_GPIO_TO_IRQ(0),</span>
<span class="p_add">+		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_LOWEDGE,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	[2] = {</span>
<span class="p_add">+		.start	= LUBBOCK_IRQ(0),</span>
<span class="p_add">+		.end	= LUBBOCK_IRQ(6),</span>
<span class="p_add">+		.flags	= IORESOURCE_IRQ,</span>
<span class="p_add">+	},</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct platform_device lubbock_cplds_device = {</span>
<span class="p_add">+	.name		= &quot;pxa_cplds_irqs&quot;,</span>
<span class="p_add">+	.id		= -1,</span>
<span class="p_add">+	.resource	= &amp;lubbock_cplds_resources[0],</span>
<span class="p_add">+	.num_resources	= 3,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 static struct platform_device *devices[] __initdata = {
 	&amp;sa1111_device,
 	&amp;smc91x_device,
 	&amp;lubbock_flash_device[0],
 	&amp;lubbock_flash_device[1],
<span class="p_add">+	&amp;lubbock_cplds_device,</span>
 };
 
 static struct pxafb_mode_info sharp_lm8v31_mode = {
<span class="p_chunk">@@ -553,7 +503,7 @@</span> <span class="p_context"> MACHINE_START(LUBBOCK, &quot;Intel DBPXA250 Development Platform (aka Lubbock)&quot;)</span>
 	/* Maintainer: MontaVista Software Inc. */
 	.map_io		= lubbock_map_io,
 	.nr_irqs	= LUBBOCK_NR_IRQS,
<span class="p_del">-	.init_irq	= lubbock_init_irq,</span>
<span class="p_add">+	.init_irq	= pxa25x_init_irq,</span>
 	.handle_irq	= pxa25x_handle_irq,
 	.timer		= &amp;pxa_timer,
 	.init_machine	= lubbock_init,
<span class="p_header">diff --git a/arch/arm/mach-pxa/mainstone.c b/arch/arm/mach-pxa/mainstone.c</span>
<span class="p_header">index 1aebaf7..3d679db 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/mainstone.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/mainstone.c</span>
<span class="p_chunk">@@ -13,6 +13,7 @@</span> <span class="p_context"></span>
  *  published by the Free Software Foundation.
  */
 #include &lt;linux/gpio.h&gt;
<span class="p_add">+#include &lt;linux/gpio/machine.h&gt;</span>
 #include &lt;linux/init.h&gt;
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/syscore_ops.h&gt;
<span class="p_chunk">@@ -120,92 +121,6 @@</span> <span class="p_context"> static unsigned long mainstone_pin_config[] = {</span>
 	GPIO1_GPIO | WAKEUP_ON_EDGE_BOTH,
 };
 
<span class="p_del">-static unsigned long mainstone_irq_enabled;</span>
<span class="p_del">-</span>
<span class="p_del">-static void mainstone_mask_irq(struct irq_data *d)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int mainstone_irq = (d-&gt;irq - MAINSTONE_IRQ(0));</span>
<span class="p_del">-	MST_INTMSKENA = (mainstone_irq_enabled &amp;= ~(1 &lt;&lt; mainstone_irq));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void mainstone_unmask_irq(struct irq_data *d)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int mainstone_irq = (d-&gt;irq - MAINSTONE_IRQ(0));</span>
<span class="p_del">-	/* the irq can be acknowledged only if deasserted, so it&#39;s done here */</span>
<span class="p_del">-	MST_INTSETCLR &amp;= ~(1 &lt;&lt; mainstone_irq);</span>
<span class="p_del">-	MST_INTMSKENA = (mainstone_irq_enabled |= (1 &lt;&lt; mainstone_irq));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static struct irq_chip mainstone_irq_chip = {</span>
<span class="p_del">-	.name		= &quot;FPGA&quot;,</span>
<span class="p_del">-	.irq_ack	= mainstone_mask_irq,</span>
<span class="p_del">-	.irq_mask	= mainstone_mask_irq,</span>
<span class="p_del">-	.irq_unmask	= mainstone_unmask_irq,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static void mainstone_irq_handler(unsigned int irq, struct irq_desc *desc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long pending = MST_INTSETCLR &amp; mainstone_irq_enabled;</span>
<span class="p_del">-	do {</span>
<span class="p_del">-		/* clear useless edge notification */</span>
<span class="p_del">-		desc-&gt;irq_data.chip-&gt;irq_ack(&amp;desc-&gt;irq_data);</span>
<span class="p_del">-		if (likely(pending)) {</span>
<span class="p_del">-			irq = MAINSTONE_IRQ(0) + __ffs(pending);</span>
<span class="p_del">-			generic_handle_irq(irq);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		pending = MST_INTSETCLR &amp; mainstone_irq_enabled;</span>
<span class="p_del">-	} while (pending);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init mainstone_init_irq(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int irq;</span>
<span class="p_del">-</span>
<span class="p_del">-	pxa27x_init_irq();</span>
<span class="p_del">-</span>
<span class="p_del">-	/* setup extra Mainstone irqs */</span>
<span class="p_del">-	for(irq = MAINSTONE_IRQ(0); irq &lt;= MAINSTONE_IRQ(15); irq++) {</span>
<span class="p_del">-		irq_set_chip_and_handler(irq, &amp;mainstone_irq_chip,</span>
<span class="p_del">-					 handle_level_irq);</span>
<span class="p_del">-		if (irq == MAINSTONE_IRQ(10) || irq == MAINSTONE_IRQ(14))</span>
<span class="p_del">-			set_irq_flags(irq, IRQF_VALID | IRQF_PROBE | IRQF_NOAUTOEN);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	set_irq_flags(MAINSTONE_IRQ(8), 0);</span>
<span class="p_del">-	set_irq_flags(MAINSTONE_IRQ(12), 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	MST_INTMSKENA = 0;</span>
<span class="p_del">-	MST_INTSETCLR = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	irq_set_chained_handler(PXA_GPIO_TO_IRQ(0), mainstone_irq_handler);</span>
<span class="p_del">-	irq_set_irq_type(PXA_GPIO_TO_IRQ(0), IRQ_TYPE_EDGE_FALLING);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_PM</span>
<span class="p_del">-</span>
<span class="p_del">-static void mainstone_irq_resume(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	MST_INTMSKENA = mainstone_irq_enabled;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static struct syscore_ops mainstone_irq_syscore_ops = {</span>
<span class="p_del">-	.resume = mainstone_irq_resume,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static int __init mainstone_irq_device_init(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (machine_is_mainstone())</span>
<span class="p_del">-		register_syscore_ops(&amp;mainstone_irq_syscore_ops);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-device_initcall(mainstone_irq_device_init);</span>
<span class="p_del">-</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
 static struct resource smc91x_resources[] = {
 	[0] = {
 		.start	= (MST_ETH_PHYS + 0x300),
<span class="p_chunk">@@ -483,11 +398,37 @@</span> <span class="p_context"> static struct platform_device mst_gpio_keys_device = {</span>
 	},
 };
 
<span class="p_add">+static struct resource mst_cplds_resources[] = {</span>
<span class="p_add">+	[0] = {</span>
<span class="p_add">+		.start	= MST_FPGA_PHYS + 0xc0,</span>
<span class="p_add">+		.end	= MST_FPGA_PHYS + 0xe0 - 1,</span>
<span class="p_add">+		.flags	= IORESOURCE_MEM,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	[1] = {</span>
<span class="p_add">+		.start	= PXA_GPIO_TO_IRQ(0),</span>
<span class="p_add">+		.end	= PXA_GPIO_TO_IRQ(0),</span>
<span class="p_add">+		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_LOWEDGE,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	[2] = {</span>
<span class="p_add">+		.start	= MAINSTONE_IRQ(0),</span>
<span class="p_add">+		.end	= MAINSTONE_IRQ(15),</span>
<span class="p_add">+		.flags	= IORESOURCE_IRQ,</span>
<span class="p_add">+	},</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct platform_device mst_cplds_device = {</span>
<span class="p_add">+	.name		= &quot;pxa_cplds_irqs&quot;,</span>
<span class="p_add">+	.id		= -1,</span>
<span class="p_add">+	.resource	= &amp;mst_cplds_resources[0],</span>
<span class="p_add">+	.num_resources	= 3,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static struct platform_device *platform_devices[] __initdata = {
 	&amp;smc91x_device,
 	&amp;mst_flash_device[0],
 	&amp;mst_flash_device[1],
 	&amp;mst_gpio_keys_device,
<span class="p_add">+	&amp;mst_cplds_device,</span>
 };
 
 static struct pxaohci_platform_data mainstone_ohci_platform_data = {
<span class="p_chunk">@@ -618,7 +559,7 @@</span> <span class="p_context"> MACHINE_START(MAINSTONE, &quot;Intel HCDDBBVA0 Development Platform (aka Mainstone)&quot;)</span>
 	.atag_offset	= 0x100,	/* BLOB boot parameter setting */
 	.map_io		= mainstone_map_io,
 	.nr_irqs	= MAINSTONE_NR_IRQS,
<span class="p_del">-	.init_irq	= mainstone_init_irq,</span>
<span class="p_add">+	.init_irq	= pxa27x_init_irq,</span>
 	.handle_irq	= pxa27x_handle_irq,
 	.timer		= &amp;pxa_timer,
 	.init_machine	= mainstone_init,
<span class="p_header">diff --git a/arch/arm/mach-pxa/pxa_cplds_irqs.c b/arch/arm/mach-pxa/pxa_cplds_irqs.c</span>
new file mode 100644
<span class="p_header">index 0000000..f1aeb54</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/pxa_cplds_irqs.c</span>
<span class="p_chunk">@@ -0,0 +1,200 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Intel Reference Systems cplds</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2014 Robert Jarzmik</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License as published by</span>
<span class="p_add">+ * the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_add">+ * (at your option) any later version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Cplds motherboard driver, supporting lubbock and mainstone SoC board.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/bitops.h&gt;</span>
<span class="p_add">+#include &lt;linux/gpio.h&gt;</span>
<span class="p_add">+#include &lt;linux/gpio/consumer.h&gt;</span>
<span class="p_add">+#include &lt;linux/interrupt.h&gt;</span>
<span class="p_add">+#include &lt;linux/io.h&gt;</span>
<span class="p_add">+#include &lt;linux/irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/irqdomain.h&gt;</span>
<span class="p_add">+#include &lt;linux/mfd/core.h&gt;</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_platform.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define FPGA_IRQ_MASK_EN 0x0</span>
<span class="p_add">+#define FPGA_IRQ_SET_CLR 0x10</span>
<span class="p_add">+</span>
<span class="p_add">+#define CPLDS_NB_IRQ	32</span>
<span class="p_add">+</span>
<span class="p_add">+struct cplds {</span>
<span class="p_add">+	void __iomem *base;</span>
<span class="p_add">+	int irq;</span>
<span class="p_add">+	unsigned int irq_mask;</span>
<span class="p_add">+	struct gpio_desc *gpio0;</span>
<span class="p_add">+	struct irq_domain *irqdomain;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static irqreturn_t cplds_irq_handler(int in_irq, void *d)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cplds *fpga = d;</span>
<span class="p_add">+	unsigned long pending;</span>
<span class="p_add">+	unsigned int bit;</span>
<span class="p_add">+</span>
<span class="p_add">+	pending = readl(fpga-&gt;base + FPGA_IRQ_SET_CLR) &amp; fpga-&gt;irq_mask;</span>
<span class="p_add">+	for_each_set_bit(bit, &amp;pending, CPLDS_NB_IRQ)</span>
<span class="p_add">+		generic_handle_irq(irq_find_mapping(fpga-&gt;irqdomain, bit));</span>
<span class="p_add">+</span>
<span class="p_add">+	return IRQ_HANDLED;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void cplds_irq_mask_ack(struct irq_data *d)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cplds *fpga = irq_data_get_irq_chip_data(d);</span>
<span class="p_add">+	unsigned int cplds_irq = irqd_to_hwirq(d);</span>
<span class="p_add">+	unsigned int set, bit = BIT(cplds_irq);</span>
<span class="p_add">+</span>
<span class="p_add">+	fpga-&gt;irq_mask &amp;= ~bit;</span>
<span class="p_add">+	writel(fpga-&gt;irq_mask, fpga-&gt;base + FPGA_IRQ_MASK_EN);</span>
<span class="p_add">+	set = readl(fpga-&gt;base + FPGA_IRQ_SET_CLR);</span>
<span class="p_add">+	writel(set &amp; ~bit, fpga-&gt;base + FPGA_IRQ_SET_CLR);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void cplds_irq_unmask(struct irq_data *d)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cplds *fpga = irq_data_get_irq_chip_data(d);</span>
<span class="p_add">+	unsigned int cplds_irq = irqd_to_hwirq(d);</span>
<span class="p_add">+	unsigned int bit = BIT(cplds_irq);</span>
<span class="p_add">+</span>
<span class="p_add">+	fpga-&gt;irq_mask |= bit;</span>
<span class="p_add">+	writel(fpga-&gt;irq_mask, fpga-&gt;base + FPGA_IRQ_MASK_EN);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct irq_chip cplds_irq_chip = {</span>
<span class="p_add">+	.name		= &quot;pxa_cplds&quot;,</span>
<span class="p_add">+	.irq_mask_ack	= cplds_irq_mask_ack,</span>
<span class="p_add">+	.irq_unmask	= cplds_irq_unmask,</span>
<span class="p_add">+	.flags		= IRQCHIP_MASK_ON_SUSPEND | IRQCHIP_SKIP_SET_WAKE,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int cplds_irq_domain_map(struct irq_domain *d, unsigned int irq,</span>
<span class="p_add">+				   irq_hw_number_t hwirq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cplds *fpga = d-&gt;host_data;</span>
<span class="p_add">+</span>
<span class="p_add">+	irq_set_chip_and_handler(irq, &amp;cplds_irq_chip, handle_level_irq);</span>
<span class="p_add">+	irq_set_chip_data(irq, fpga);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct irq_domain_ops cplds_irq_domain_ops = {</span>
<span class="p_add">+	.xlate = irq_domain_xlate_twocell,</span>
<span class="p_add">+	.map = cplds_irq_domain_map,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int cplds_resume(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cplds *fpga = platform_get_drvdata(pdev);</span>
<span class="p_add">+</span>
<span class="p_add">+	writel(fpga-&gt;irq_mask, fpga-&gt;base + FPGA_IRQ_MASK_EN);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int cplds_probe(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct resource *res;</span>
<span class="p_add">+	struct cplds *fpga;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	unsigned int base_irq = 0;</span>
<span class="p_add">+	unsigned long irqflags = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	fpga = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*fpga), GFP_KERNEL);</span>
<span class="p_add">+	if (!fpga)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);</span>
<span class="p_add">+	if (res) {</span>
<span class="p_add">+		fpga-&gt;irq = (unsigned int)res-&gt;start;</span>
<span class="p_add">+		irqflags = res-&gt;flags;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (!fpga-&gt;irq)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	base_irq = platform_get_irq(pdev, 1);</span>
<span class="p_add">+	if (base_irq &lt; 0)</span>
<span class="p_add">+		base_irq = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);</span>
<span class="p_add">+	fpga-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span>
<span class="p_add">+	if (IS_ERR(fpga-&gt;base))</span>
<span class="p_add">+		return PTR_ERR(fpga-&gt;base);</span>
<span class="p_add">+</span>
<span class="p_add">+	platform_set_drvdata(pdev, fpga);</span>
<span class="p_add">+</span>
<span class="p_add">+	writel(fpga-&gt;irq_mask, fpga-&gt;base + FPGA_IRQ_MASK_EN);</span>
<span class="p_add">+	writel(0, fpga-&gt;base + FPGA_IRQ_SET_CLR);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = devm_request_irq(&amp;pdev-&gt;dev, fpga-&gt;irq, cplds_irq_handler,</span>
<span class="p_add">+			       irqflags, dev_name(&amp;pdev-&gt;dev), fpga);</span>
<span class="p_add">+	if (ret == -ENOSYS)</span>
<span class="p_add">+		return -EPROBE_DEFER;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_err(&amp;pdev-&gt;dev, &quot;couldn&#39;t request main irq%d: %d\n&quot;,</span>
<span class="p_add">+			fpga-&gt;irq, ret);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	irq_set_irq_wake(fpga-&gt;irq, 1);</span>
<span class="p_add">+	fpga-&gt;irqdomain = irq_domain_add_linear(pdev-&gt;dev.of_node,</span>
<span class="p_add">+					       CPLDS_NB_IRQ,</span>
<span class="p_add">+					       &amp;cplds_irq_domain_ops, fpga);</span>
<span class="p_add">+	if (!fpga-&gt;irqdomain)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (base_irq) {</span>
<span class="p_add">+		ret = irq_create_strict_mappings(fpga-&gt;irqdomain, base_irq, 0,</span>
<span class="p_add">+						 CPLDS_NB_IRQ);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			dev_err(&amp;pdev-&gt;dev, &quot;couldn&#39;t create the irq mapping %d..%d\n&quot;,</span>
<span class="p_add">+				base_irq, base_irq + CPLDS_NB_IRQ);</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int cplds_remove(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cplds *fpga = platform_get_drvdata(pdev);</span>
<span class="p_add">+</span>
<span class="p_add">+	irq_set_chip_and_handler(fpga-&gt;irq, NULL, NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct of_device_id cplds_id_table[] = {</span>
<span class="p_add">+	{ .compatible = &quot;intel,lubbock-cplds-irqs&quot;, },</span>
<span class="p_add">+	{ .compatible = &quot;intel,mainstone-cplds-irqs&quot;, },</span>
<span class="p_add">+	{ }</span>
<span class="p_add">+};</span>
<span class="p_add">+MODULE_DEVICE_TABLE(of, cplds_id_table);</span>
<span class="p_add">+</span>
<span class="p_add">+static struct platform_driver cplds_driver = {</span>
<span class="p_add">+	.driver		= {</span>
<span class="p_add">+		.name	= &quot;pxa_cplds_irqs&quot;,</span>
<span class="p_add">+		.of_match_table = of_match_ptr(cplds_id_table),</span>
<span class="p_add">+	},</span>
<span class="p_add">+	.probe		= cplds_probe,</span>
<span class="p_add">+	.remove		= cplds_remove,</span>
<span class="p_add">+	.resume		= cplds_resume,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+module_platform_driver(cplds_driver);</span>
<span class="p_add">+</span>
<span class="p_add">+MODULE_DESCRIPTION(&quot;PXA Cplds interrupts driver&quot;);</span>
<span class="p_add">+MODULE_AUTHOR(&quot;Robert Jarzmik &lt;robert.jarzmik@free.fr&gt;&quot;);</span>
<span class="p_add">+MODULE_LICENSE(&quot;GPL&quot;);</span>
<span class="p_header">diff --git a/arch/arm/net/bpf_jit_32.c b/arch/arm/net/bpf_jit_32.c</span>
<span class="p_header">index 62135849..ad94145 100644</span>
<span class="p_header">--- a/arch/arm/net/bpf_jit_32.c</span>
<span class="p_header">+++ b/arch/arm/net/bpf_jit_32.c</span>
<span class="p_chunk">@@ -52,6 +52,7 @@</span> <span class="p_context"></span>
 #define SEEN_DATA		(1 &lt;&lt; (BPF_MEMWORDS + 3))
 
 #define FLAG_NEED_X_RESET	(1 &lt;&lt; 0)
<span class="p_add">+#define FLAG_IMM_OVERFLOW	(1 &lt;&lt; 1)</span>
 
 struct jit_ctx {
 	const struct sk_filter *skf;
<span class="p_chunk">@@ -286,6 +287,15 @@</span> <span class="p_context"> static u16 imm_offset(u32 k, struct jit_ctx *ctx)</span>
 	/* PC in ARM mode == address of the instruction + 8 */
 	imm = offset - (8 + ctx-&gt;idx * 4);
 
<span class="p_add">+	if (imm &amp; ~0xfff) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * literal pool is too far, signal it into flags. we</span>
<span class="p_add">+		 * can only detect it on the second pass unfortunately.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		ctx-&gt;flags |= FLAG_IMM_OVERFLOW;</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return imm;
 }
 
<span class="p_chunk">@@ -817,6 +827,14 @@</span> <span class="p_context"> b_epilogue:</span>
 		default:
 			return -1;
 		}
<span class="p_add">+</span>
<span class="p_add">+		if (ctx-&gt;flags &amp; FLAG_IMM_OVERFLOW)</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * this instruction generated an overflow when</span>
<span class="p_add">+			 * trying to access the literal pool, so</span>
<span class="p_add">+			 * delegate this filter to the kernel interpreter.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			return -1;</span>
 	}
 
 	/* compute offsets only during the first pass */
<span class="p_chunk">@@ -876,7 +894,14 @@</span> <span class="p_context"> void bpf_jit_compile(struct sk_filter *fp)</span>
 
 	ctx.idx = 0;
 	build_prologue(&amp;ctx);
<span class="p_del">-	build_body(&amp;ctx);</span>
<span class="p_add">+	if (build_body(&amp;ctx) &lt; 0) {</span>
<span class="p_add">+#if __LINUX_ARM_ARCH__ &lt; 7</span>
<span class="p_add">+		if (ctx.imm_count)</span>
<span class="p_add">+			kfree(ctx.imms);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+		bpf_jit_binary_free(header);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 	build_epilogue(&amp;ctx);
 
 	flush_icache_range((u32)ctx.target, (u32)(ctx.target + ctx.idx));
<span class="p_header">diff --git a/arch/c6x/kernel/time.c b/arch/c6x/kernel/time.c</span>
<span class="p_header">index 356ee84..04845aa 100644</span>
<span class="p_header">--- a/arch/c6x/kernel/time.c</span>
<span class="p_header">+++ b/arch/c6x/kernel/time.c</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> u64 sched_clock(void)</span>
 	return (tsc * sched_clock_multiplier) &gt;&gt; SCHED_CLOCK_SHIFT;
 }
 
<span class="p_del">-void time_init(void)</span>
<span class="p_add">+void __init time_init(void)</span>
 {
 	u64 tmp = (u64)NSEC_PER_SEC &lt;&lt; SCHED_CLOCK_SHIFT;
 
<span class="p_header">diff --git a/arch/mips/kernel/irq.c b/arch/mips/kernel/irq.c</span>
<span class="p_header">index a5aa43d..9cd8cbf 100644</span>
<span class="p_header">--- a/arch/mips/kernel/irq.c</span>
<span class="p_header">+++ b/arch/mips/kernel/irq.c</span>
<span class="p_chunk">@@ -110,7 +110,7 @@</span> <span class="p_context"> void __init init_IRQ(void)</span>
 #endif
 }
 
<span class="p_del">-#ifdef DEBUG_STACKOVERFLOW</span>
<span class="p_add">+#ifdef CONFIG_DEBUG_STACKOVERFLOW</span>
 static inline void check_stack_overflow(void)
 {
 	unsigned long sp;
<span class="p_header">diff --git a/arch/mips/power/hibernate.S b/arch/mips/power/hibernate.S</span>
<span class="p_header">index 5bf34ec..2ca1735 100644</span>
<span class="p_header">--- a/arch/mips/power/hibernate.S</span>
<span class="p_header">+++ b/arch/mips/power/hibernate.S</span>
<span class="p_chunk">@@ -31,6 +31,8 @@</span> <span class="p_context"> LEAF(swsusp_arch_suspend)</span>
 END(swsusp_arch_suspend)
 
 LEAF(swsusp_arch_resume)
<span class="p_add">+	/* Avoid TLB mismatch during and after kernel resume */</span>
<span class="p_add">+	jal local_flush_tlb_all</span>
 	PTR_L t0, restore_pblist
 0:
 	PTR_L t1, PBE_ADDRESS(t0)   /* source */
<span class="p_chunk">@@ -44,7 +46,6 @@</span> <span class="p_context"> LEAF(swsusp_arch_resume)</span>
 	bne t1, t3, 1b
 	PTR_L t0, PBE_NEXT(t0)
 	bnez t0, 0b
<span class="p_del">-	jal local_flush_tlb_all /* Avoid TLB mismatch after kernel resume */</span>
 	PTR_LA t0, saved_regs
 	PTR_L ra, PT_R31(t0)
 	PTR_L sp, PT_R29(t0)
<span class="p_header">diff --git a/arch/powerpc/kernel/cacheinfo.c b/arch/powerpc/kernel/cacheinfo.c</span>
<span class="p_header">index b4437e8..334254c 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/cacheinfo.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/cacheinfo.c</span>
<span class="p_chunk">@@ -62,12 +62,22 @@</span> <span class="p_context"> struct cache_type_info {</span>
 };
 
 /* These are used to index the cache_type_info array. */
<span class="p_del">-#define CACHE_TYPE_UNIFIED     0</span>
<span class="p_del">-#define CACHE_TYPE_INSTRUCTION 1</span>
<span class="p_del">-#define CACHE_TYPE_DATA        2</span>
<span class="p_add">+#define CACHE_TYPE_UNIFIED     0 /* cache-size, cache-block-size, etc. */</span>
<span class="p_add">+#define CACHE_TYPE_UNIFIED_D   1 /* d-cache-size, d-cache-block-size, etc */</span>
<span class="p_add">+#define CACHE_TYPE_INSTRUCTION 2</span>
<span class="p_add">+#define CACHE_TYPE_DATA        3</span>
 
 static const struct cache_type_info cache_type_info[] = {
 	{
<span class="p_add">+		/* Embedded systems that use cache-size, cache-block-size,</span>
<span class="p_add">+		 * etc. for the Unified (typically L2) cache. */</span>
<span class="p_add">+		.name            = &quot;Unified&quot;,</span>
<span class="p_add">+		.size_prop       = &quot;cache-size&quot;,</span>
<span class="p_add">+		.line_size_props = { &quot;cache-line-size&quot;,</span>
<span class="p_add">+				     &quot;cache-block-size&quot;, },</span>
<span class="p_add">+		.nr_sets_prop    = &quot;cache-sets&quot;,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		/* PowerPC Processor binding says the [di]-cache-*
 		 * must be equal on unified caches, so just use
 		 * d-cache properties. */
<span class="p_chunk">@@ -293,7 +303,8 @@</span> <span class="p_context"> static struct cache *cache_find_first_sibling(struct cache *cache)</span>
 {
 	struct cache *iter;
 
<span class="p_del">-	if (cache-&gt;type == CACHE_TYPE_UNIFIED)</span>
<span class="p_add">+	if (cache-&gt;type == CACHE_TYPE_UNIFIED ||</span>
<span class="p_add">+	    cache-&gt;type == CACHE_TYPE_UNIFIED_D)</span>
 		return cache;
 
 	list_for_each_entry(iter, &amp;cache_list, list)
<span class="p_chunk">@@ -324,15 +335,27 @@</span> <span class="p_context"> static bool cache_node_is_unified(const struct device_node *np)</span>
 	return of_get_property(np, &quot;cache-unified&quot;, NULL);
 }
 
<span class="p_del">-static struct cache *__cpuinit cache_do_one_devnode_unified(struct device_node *node, int level)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Unified caches can have two different sets of tags.  Most embedded</span>
<span class="p_add">+ * use cache-size, etc. for the unified cache size, but open firmware systems</span>
<span class="p_add">+ * use d-cache-size, etc.   Check on initialization for which type we have, and</span>
<span class="p_add">+ * return the appropriate structure type.  Assume it&#39;s embedded if it isn&#39;t</span>
<span class="p_add">+ * open firmware.  If it&#39;s yet a 3rd type, then there will be missing entries</span>
<span class="p_add">+ * in /sys/devices/system/cpu/cpu0/cache/index2/, and this code will need</span>
<span class="p_add">+ * to be extended further.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int cache_is_unified_d(const struct device_node *np)</span>
 {
<span class="p_del">-	struct cache *cache;</span>
<span class="p_add">+	return of_get_property(np,</span>
<span class="p_add">+		cache_type_info[CACHE_TYPE_UNIFIED_D].size_prop, NULL) ?</span>
<span class="p_add">+		CACHE_TYPE_UNIFIED_D : CACHE_TYPE_UNIFIED;</span>
<span class="p_add">+}</span>
 
<span class="p_add">+static struct cache *__cpuinit cache_do_one_devnode_unified(struct device_node *node, int level)</span>
<span class="p_add">+{</span>
 	pr_debug(&quot;creating L%d ucache for %s\n&quot;, level, node-&gt;full_name);
 
<span class="p_del">-	cache = new_cache(CACHE_TYPE_UNIFIED, level, node);</span>
<span class="p_del">-</span>
<span class="p_del">-	return cache;</span>
<span class="p_add">+	return new_cache(cache_is_unified_d(node), level, node);</span>
 }
 
 static struct cache *__cpuinit cache_do_one_devnode_split(struct device_node *node, int level)
<span class="p_header">diff --git a/arch/powerpc/kernel/vmlinux.lds.S b/arch/powerpc/kernel/vmlinux.lds.S</span>
<span class="p_header">index 7703569..6be807d 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/vmlinux.lds.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/vmlinux.lds.S</span>
<span class="p_chunk">@@ -213,6 +213,7 @@</span> <span class="p_context"> SECTIONS</span>
 		*(.opd)
 	}
 
<span class="p_add">+	. = ALIGN(256);</span>
 	.got : AT(ADDR(.got) - LOAD_OFFSET) {
 		__toc_start = .;
 		*(.got)
<span class="p_header">diff --git a/arch/powerpc/perf/callchain.c b/arch/powerpc/perf/callchain.c</span>
<span class="p_header">index e8a18d1..a9bd794 100644</span>
<span class="p_header">--- a/arch/powerpc/perf/callchain.c</span>
<span class="p_header">+++ b/arch/powerpc/perf/callchain.c</span>
<span class="p_chunk">@@ -243,7 +243,7 @@</span> <span class="p_context"> static void perf_callchain_user_64(struct perf_callchain_entry *entry,</span>
 	sp = regs-&gt;gpr[1];
 	perf_callchain_store(entry, next_ip);
 
<span class="p_del">-	for (;;) {</span>
<span class="p_add">+	while (entry-&gt;nr &lt; PERF_MAX_STACK_DEPTH) {</span>
 		fp = (unsigned long __user *) sp;
 		if (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &amp;next_sp))
 			return;
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/dlpar.c b/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_header">index 0f1b706..2767276 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_chunk">@@ -416,6 +416,12 @@</span> <span class="p_context"> static ssize_t dlpar_cpu_probe(const char *buf, size_t count)</span>
 		goto out;
 	}
 
<span class="p_add">+	rc = dlpar_acquire_drc(drc_index);</span>
<span class="p_add">+	if (rc) {</span>
<span class="p_add">+		rc = -EINVAL;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	dn = dlpar_configure_connector(drc_index);
 	if (!dn) {
 		rc = -EINVAL;
<span class="p_chunk">@@ -436,13 +442,6 @@</span> <span class="p_context"> static ssize_t dlpar_cpu_probe(const char *buf, size_t count)</span>
 	kfree(dn-&gt;full_name);
 	dn-&gt;full_name = cpu_name;
 
<span class="p_del">-	rc = dlpar_acquire_drc(drc_index);</span>
<span class="p_del">-	if (rc) {</span>
<span class="p_del">-		dlpar_free_cc_nodes(dn);</span>
<span class="p_del">-		rc = -EINVAL;</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	rc = dlpar_attach_node(dn);
 	if (rc) {
 		dlpar_release_drc(drc_index);
<span class="p_header">diff --git a/arch/s390/crypto/ghash_s390.c b/arch/s390/crypto/ghash_s390.c</span>
<span class="p_header">index b1bd170..c4a954e 100644</span>
<span class="p_header">--- a/arch/s390/crypto/ghash_s390.c</span>
<span class="p_header">+++ b/arch/s390/crypto/ghash_s390.c</span>
<span class="p_chunk">@@ -16,11 +16,12 @@</span> <span class="p_context"></span>
 #define GHASH_DIGEST_SIZE	16
 
 struct ghash_ctx {
<span class="p_del">-	u8 icv[16];</span>
<span class="p_del">-	u8 key[16];</span>
<span class="p_add">+	u8 key[GHASH_BLOCK_SIZE];</span>
 };
 
 struct ghash_desc_ctx {
<span class="p_add">+	u8 icv[GHASH_BLOCK_SIZE];</span>
<span class="p_add">+	u8 key[GHASH_BLOCK_SIZE];</span>
 	u8 buffer[GHASH_BLOCK_SIZE];
 	u32 bytes;
 };
<span class="p_chunk">@@ -28,8 +29,10 @@</span> <span class="p_context"> struct ghash_desc_ctx {</span>
 static int ghash_init(struct shash_desc *desc)
 {
 	struct ghash_desc_ctx *dctx = shash_desc_ctx(desc);
<span class="p_add">+	struct ghash_ctx *ctx = crypto_shash_ctx(desc-&gt;tfm);</span>
 
 	memset(dctx, 0, sizeof(*dctx));
<span class="p_add">+	memcpy(dctx-&gt;key, ctx-&gt;key, GHASH_BLOCK_SIZE);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -45,7 +48,6 @@</span> <span class="p_context"> static int ghash_setkey(struct crypto_shash *tfm,</span>
 	}
 
 	memcpy(ctx-&gt;key, key, GHASH_BLOCK_SIZE);
<span class="p_del">-	memset(ctx-&gt;icv, 0, GHASH_BLOCK_SIZE);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -54,7 +56,6 @@</span> <span class="p_context"> static int ghash_update(struct shash_desc *desc,</span>
 			 const u8 *src, unsigned int srclen)
 {
 	struct ghash_desc_ctx *dctx = shash_desc_ctx(desc);
<span class="p_del">-	struct ghash_ctx *ctx = crypto_shash_ctx(desc-&gt;tfm);</span>
 	unsigned int n;
 	u8 *buf = dctx-&gt;buffer;
 	int ret;
<span class="p_chunk">@@ -70,7 +71,7 @@</span> <span class="p_context"> static int ghash_update(struct shash_desc *desc,</span>
 		src += n;
 
 		if (!dctx-&gt;bytes) {
<span class="p_del">-			ret = crypt_s390_kimd(KIMD_GHASH, ctx, buf,</span>
<span class="p_add">+			ret = crypt_s390_kimd(KIMD_GHASH, dctx, buf,</span>
 					      GHASH_BLOCK_SIZE);
 			BUG_ON(ret != GHASH_BLOCK_SIZE);
 		}
<span class="p_chunk">@@ -78,7 +79,7 @@</span> <span class="p_context"> static int ghash_update(struct shash_desc *desc,</span>
 
 	n = srclen &amp; ~(GHASH_BLOCK_SIZE - 1);
 	if (n) {
<span class="p_del">-		ret = crypt_s390_kimd(KIMD_GHASH, ctx, src, n);</span>
<span class="p_add">+		ret = crypt_s390_kimd(KIMD_GHASH, dctx, src, n);</span>
 		BUG_ON(ret != n);
 		src += n;
 		srclen -= n;
<span class="p_chunk">@@ -92,7 +93,7 @@</span> <span class="p_context"> static int ghash_update(struct shash_desc *desc,</span>
 	return 0;
 }
 
<span class="p_del">-static void ghash_flush(struct ghash_ctx *ctx, struct ghash_desc_ctx *dctx)</span>
<span class="p_add">+static int ghash_flush(struct ghash_desc_ctx *dctx)</span>
 {
 	u8 *buf = dctx-&gt;buffer;
 	int ret;
<span class="p_chunk">@@ -102,19 +103,18 @@</span> <span class="p_context"> static void ghash_flush(struct ghash_ctx *ctx, struct ghash_desc_ctx *dctx)</span>
 
 		memset(pos, 0, dctx-&gt;bytes);
 
<span class="p_del">-		ret = crypt_s390_kimd(KIMD_GHASH, ctx, buf, GHASH_BLOCK_SIZE);</span>
<span class="p_add">+		ret = crypt_s390_kimd(KIMD_GHASH, dctx, buf, GHASH_BLOCK_SIZE);</span>
 		BUG_ON(ret != GHASH_BLOCK_SIZE);
<span class="p_del">-	}</span>
 
<span class="p_del">-	dctx-&gt;bytes = 0;</span>
<span class="p_add">+		dctx-&gt;bytes = 0;</span>
<span class="p_add">+	}</span>
 }
 
 static int ghash_final(struct shash_desc *desc, u8 *dst)
 {
 	struct ghash_desc_ctx *dctx = shash_desc_ctx(desc);
<span class="p_del">-	struct ghash_ctx *ctx = crypto_shash_ctx(desc-&gt;tfm);</span>
 
<span class="p_del">-	ghash_flush(ctx, dctx);</span>
<span class="p_add">+	ghash_flush(dctx);</span>
 	memcpy(dst, ctx-&gt;icv, GHASH_BLOCK_SIZE);
 
 	return 0;
<span class="p_header">diff --git a/arch/s390/kernel/suspend.c b/arch/s390/kernel/suspend.c</span>
<span class="p_header">index aa1494d..4206804 100644</span>
<span class="p_header">--- a/arch/s390/kernel/suspend.c</span>
<span class="p_header">+++ b/arch/s390/kernel/suspend.c</span>
<span class="p_chunk">@@ -9,6 +9,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/pfn.h&gt;
 #include &lt;linux/suspend.h&gt;
 #include &lt;linux/mm.h&gt;
<span class="p_add">+#include &lt;asm/ipl.h&gt;</span>
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 #include &lt;asm/ctl_reg.h&gt;
 
 /*
<span class="p_chunk">@@ -137,6 +139,8 @@</span> <span class="p_context"> int pfn_is_nosave(unsigned long pfn)</span>
 {
 	unsigned long nosave_begin_pfn = PFN_DOWN(__pa(&amp;__nosave_begin));
 	unsigned long nosave_end_pfn = PFN_DOWN(__pa(&amp;__nosave_end));
<span class="p_add">+	unsigned long eshared_pfn = PFN_DOWN(__pa(&amp;_eshared)) - 1;</span>
<span class="p_add">+	unsigned long stext_pfn = PFN_DOWN(__pa(&amp;_stext));</span>
 
 	/* Always save lowcore pages (LC protection might be enabled). */
 	if (pfn &lt;= LC_PAGES)
<span class="p_chunk">@@ -144,6 +148,8 @@</span> <span class="p_context"> int pfn_is_nosave(unsigned long pfn)</span>
 	if (pfn &gt;= nosave_begin_pfn &amp;&amp; pfn &lt; nosave_end_pfn)
 		return 1;
 	/* Skip memory holes and read-only pages (NSS, DCSS, ...). */
<span class="p_add">+	if (pfn &gt;= stext_pfn &amp;&amp; pfn &lt;= eshared_pfn)</span>
<span class="p_add">+		return ipl_info.type == IPL_TYPE_NSS ? 1 : 0;</span>
 	if (tprot(PFN_PHYS(pfn)))
 		return 1;
 	return 0;
<span class="p_header">diff --git a/arch/s390/kvm/priv.c b/arch/s390/kvm/priv.c</span>
<span class="p_header">index e5a45db..f641458 100644</span>
<span class="p_header">--- a/arch/s390/kvm/priv.c</span>
<span class="p_header">+++ b/arch/s390/kvm/priv.c</span>
<span class="p_chunk">@@ -218,6 +218,7 @@</span> <span class="p_context"> static void handle_stsi_3_2_2(struct kvm_vcpu *vcpu, struct sysinfo_3_2_2 *mem)</span>
 	for (n = mem-&gt;count - 1; n &gt; 0 ; n--)
 		memcpy(&amp;mem-&gt;vm[n], &amp;mem-&gt;vm[n - 1], sizeof(mem-&gt;vm[0]));
 
<span class="p_add">+	memset(&amp;mem-&gt;vm[0], 0, sizeof(mem-&gt;vm[0]));</span>
 	mem-&gt;vm[0].cpus_total = cpus;
 	mem-&gt;vm[0].cpus_configured = cpus;
 	mem-&gt;vm[0].cpus_standby = 0;
<span class="p_header">diff --git a/arch/x86/include/asm/i387.h b/arch/x86/include/asm/i387.h</span>
<span class="p_header">index 257d9cc..1262fb6 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/i387.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/i387.h</span>
<span class="p_chunk">@@ -23,8 +23,32 @@</span> <span class="p_context"> extern int dump_fpu(struct pt_regs *, struct user_i387_struct *);</span>
 extern void math_state_restore(void);
 
 extern bool irq_fpu_usable(void);
<span class="p_del">-extern void kernel_fpu_begin(void);</span>
<span class="p_del">-extern void kernel_fpu_end(void);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Careful: __kernel_fpu_begin/end() must be called with preempt disabled</span>
<span class="p_add">+ * and they don&#39;t touch the preempt state on their own.</span>
<span class="p_add">+ * If you enable preemption after __kernel_fpu_begin(), preempt notifier</span>
<span class="p_add">+ * should call the __kernel_fpu_end() to prevent the kernel/user FPU</span>
<span class="p_add">+ * state from getting corrupted. KVM for example uses this model.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * All other cases use kernel_fpu_begin/end() which disable preemption</span>
<span class="p_add">+ * during kernel FPU usage.</span>
<span class="p_add">+ */</span>
<span class="p_add">+extern void __kernel_fpu_begin(void);</span>
<span class="p_add">+extern void __kernel_fpu_end(void);</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void kernel_fpu_begin(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	WARN_ON_ONCE(!irq_fpu_usable());</span>
<span class="p_add">+	preempt_disable();</span>
<span class="p_add">+	__kernel_fpu_begin();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void kernel_fpu_end(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__kernel_fpu_end();</span>
<span class="p_add">+	preempt_enable();</span>
<span class="p_add">+}</span>
 
 /*
  * Some instructions like VIA&#39;s padlock instructions generate a spurious
<span class="p_header">diff --git a/arch/x86/include/asm/iommu_table.h b/arch/x86/include/asm/iommu_table.h</span>
<span class="p_header">index f229b13..0c54822 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/iommu_table.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/iommu_table.h</span>
<span class="p_chunk">@@ -79,11 +79,12 @@</span> <span class="p_context"> struct iommu_table_entry {</span>
  *  d). Similar to the &#39;init&#39;, except that this gets called from pci_iommu_init
  *      where we do have a memory allocator.
  *
<span class="p_del">- * The standard vs the _FINISH differs in that the _FINISH variant will</span>
<span class="p_del">- * continue detecting other IOMMUs in the call list after the</span>
<span class="p_del">- * the detection routine returns a positive number. The _FINISH will</span>
<span class="p_del">- * stop the execution chain. Both will still call the &#39;init&#39; and</span>
<span class="p_del">- * &#39;late_init&#39; functions if they are set.</span>
<span class="p_add">+ * The standard IOMMU_INIT differs from the IOMMU_INIT_FINISH variant</span>
<span class="p_add">+ * in that the former will continue detecting other IOMMUs in the call</span>
<span class="p_add">+ * list after the detection routine returns a positive number, while the</span>
<span class="p_add">+ * latter will stop the execution chain upon first successful detection.</span>
<span class="p_add">+ * Both variants will still call the &#39;init&#39; and &#39;late_init&#39; functions if</span>
<span class="p_add">+ * they are set.</span>
  */
 #define IOMMU_INIT_FINISH(_detect, _depend, _init, _late_init)		\
 	__IOMMU_INIT(_detect, _depend, _init, _late_init, 1)
<span class="p_header">diff --git a/arch/x86/kernel/cpu/mcheck/mce.c b/arch/x86/kernel/cpu/mcheck/mce.c</span>
<span class="p_header">index 0d2db0e..9eeaed4 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/mcheck/mce.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/mcheck/mce.c</span>
<span class="p_chunk">@@ -652,11 +652,14 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(machine_check_poll);</span>
 static int mce_no_way_out(struct mce *m, char **msg)
 {
 	int i;
<span class="p_add">+	char *tmp;</span>
 
 	for (i = 0; i &lt; banks; i++) {
 		m-&gt;status = mce_rdmsrl(MSR_IA32_MCx_STATUS(i));
<span class="p_del">-		if (mce_severity(m, tolerant, msg) &gt;= MCE_PANIC_SEVERITY)</span>
<span class="p_add">+		if (mce_severity(m, tolerant, &amp;tmp) &gt;= MCE_PANIC_SEVERITY) {</span>
<span class="p_add">+			*msg = tmp;</span>
 			return 1;
<span class="p_add">+		}</span>
 	}
 	return 0;
 }
<span class="p_header">diff --git a/arch/x86/kernel/i387.c b/arch/x86/kernel/i387.c</span>
<span class="p_header">index 6610e81..7aa728d 100644</span>
<span class="p_header">--- a/arch/x86/kernel/i387.c</span>
<span class="p_header">+++ b/arch/x86/kernel/i387.c</span>
<span class="p_chunk">@@ -77,29 +77,26 @@</span> <span class="p_context"> bool irq_fpu_usable(void)</span>
 }
 EXPORT_SYMBOL(irq_fpu_usable);
 
<span class="p_del">-void kernel_fpu_begin(void)</span>
<span class="p_add">+void __kernel_fpu_begin(void)</span>
 {
 	struct task_struct *me = current;
 
<span class="p_del">-	WARN_ON_ONCE(!irq_fpu_usable());</span>
<span class="p_del">-	preempt_disable();</span>
 	if (__thread_has_fpu(me)) {
 		__save_init_fpu(me);
 		__thread_clear_has_fpu(me);
<span class="p_del">-		/* We do &#39;stts()&#39; in kernel_fpu_end() */</span>
<span class="p_add">+		/* We do &#39;stts()&#39; in __kernel_fpu_end() */</span>
 	} else {
 		percpu_write(fpu_owner_task, NULL);
 		clts();
 	}
 }
<span class="p_del">-EXPORT_SYMBOL(kernel_fpu_begin);</span>
<span class="p_add">+EXPORT_SYMBOL(__kernel_fpu_begin);</span>
 
<span class="p_del">-void kernel_fpu_end(void)</span>
<span class="p_add">+void __kernel_fpu_end(void)</span>
 {
 	stts();
<span class="p_del">-	preempt_enable();</span>
 }
<span class="p_del">-EXPORT_SYMBOL(kernel_fpu_end);</span>
<span class="p_add">+EXPORT_SYMBOL(__kernel_fpu_end);</span>
 
 void unlazy_fpu(struct task_struct *tsk)
 {
<span class="p_header">diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c</span>
<span class="p_header">index 84f4bca..2da1a8c 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mmu.c</span>
<span class="p_chunk">@@ -3658,7 +3658,7 @@</span> <span class="p_context"> void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,</span>
 	++vcpu-&gt;kvm-&gt;stat.mmu_pte_write;
 	kvm_mmu_audit(vcpu, AUDIT_PRE_PTE_WRITE);
 
<span class="p_del">-	mask.cr0_wp = mask.cr4_pae = mask.nxe = 1;</span>
<span class="p_add">+	mask.cr0_wp = mask.cr4_pae = mask.nxe = mask.smep_andnot_wp = 1;</span>
 	for_each_gfn_indirect_valid_sp(vcpu-&gt;kvm, sp, gfn, node) {
 		if (detect_write_misaligned(sp, gpa, bytes) ||
 		      detect_write_flooding(sp)) {
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 2eb4e5a..4ad0d71 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -1455,8 +1455,12 @@</span> <span class="p_context"> static void __vmx_load_host_state(struct vcpu_vmx *vmx)</span>
 #ifdef CONFIG_X86_64
 	wrmsrl(MSR_KERNEL_GS_BASE, vmx-&gt;msr_host_kernel_gs_base);
 #endif
<span class="p_del">-	if (user_has_fpu())</span>
<span class="p_del">-		clts();</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If the FPU is not active (through the host task or</span>
<span class="p_add">+	 * the guest vcpu), then restore the cr0.TS bit.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!user_has_fpu() &amp;&amp; !vmx-&gt;vcpu.guest_fpu_loaded)</span>
<span class="p_add">+		stts();</span>
 	load_gdt(&amp;__get_cpu_var(host_gdt));
 }
 
<span class="p_chunk">@@ -3633,7 +3637,7 @@</span> <span class="p_context"> static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)</span>
 	struct desc_ptr dt;
 	unsigned long cr4;
 
<span class="p_del">-	vmcs_writel(HOST_CR0, read_cr0() | X86_CR0_TS);  /* 22.2.3 */</span>
<span class="p_add">+	vmcs_writel(HOST_CR0, read_cr0() &amp; ~X86_CR0_TS);  /* 22.2.3 */</span>
 	vmcs_writel(HOST_CR3, read_cr3());  /* 22.2.3  FIXME: shadow tables */
 
 	/* Save the most likely value for this task&#39;s CR4 in the VMCS. */
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 318a245..4ad2b7b 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -5907,7 +5907,7 @@</span> <span class="p_context"> void kvm_load_guest_fpu(struct kvm_vcpu *vcpu)</span>
 	 */
 	kvm_put_guest_xcr0(vcpu);
 	vcpu-&gt;guest_fpu_loaded = 1;
<span class="p_del">-	unlazy_fpu(current);</span>
<span class="p_add">+	__kernel_fpu_begin();</span>
 	fpu_restore_checking(&amp;vcpu-&gt;arch.guest_fpu);
 	trace_kvm_fpu(1);
 }
<span class="p_chunk">@@ -5921,6 +5921,7 @@</span> <span class="p_context"> void kvm_put_guest_fpu(struct kvm_vcpu *vcpu)</span>
 
 	vcpu-&gt;guest_fpu_loaded = 0;
 	fpu_save_init(&amp;vcpu-&gt;arch.guest_fpu);
<span class="p_add">+	__kernel_fpu_end();</span>
 	++vcpu-&gt;stat.fpu_reload;
 	kvm_make_request(KVM_REQ_DEACTIVATE_FPU, vcpu);
 	trace_kvm_fpu(0);
<span class="p_header">diff --git a/arch/x86/net/bpf_jit_comp.c b/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_header">index 0597f95..95f9934 100644</span>
<span class="p_header">--- a/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_header">+++ b/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_chunk">@@ -155,7 +155,12 @@</span> <span class="p_context"> void bpf_jit_compile(struct sk_filter *fp)</span>
 	}
 	cleanup_addr = proglen; /* epilogue address */
 
<span class="p_del">-	for (pass = 0; pass &lt; 10; pass++) {</span>
<span class="p_add">+	/* JITed image shrinks with every pass and the loop iterates</span>
<span class="p_add">+	 * until the image stops shrinking. Very large bpf programs</span>
<span class="p_add">+	 * may converge on the last pass. In such case do one more</span>
<span class="p_add">+	 * pass to emit the final image</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (pass = 0; pass &lt; 10 || image; pass++) {</span>
 		u8 seen_or_pass0 = (pass == 0) ? (SEEN_XREG | SEEN_DATAREF | SEEN_MEM) : seen;
 		/* no prologue/epilogue for trivial filters (RET something) */
 		proglen = 0;
<span class="p_header">diff --git a/block/genhd.c b/block/genhd.c</span>
<span class="p_header">index 7a2a8dc..618ca1a 100644</span>
<span class="p_header">--- a/block/genhd.c</span>
<span class="p_header">+++ b/block/genhd.c</span>
<span class="p_chunk">@@ -420,13 +420,13 @@</span> <span class="p_context"> int blk_alloc_devt(struct hd_struct *part, dev_t *devt)</span>
 	do {
 		if (!idr_pre_get(&amp;ext_devt_idr, GFP_KERNEL))
 			return -ENOMEM;
<span class="p_del">-		spin_lock(&amp;ext_devt_lock);</span>
<span class="p_add">+		spin_lock_bh(&amp;ext_devt_lock);</span>
 		rc = idr_get_new(&amp;ext_devt_idr, part, &amp;idx);
 		if (!rc &amp;&amp; idx &gt;= NR_EXT_DEVT) {
 			idr_remove(&amp;ext_devt_idr, idx);
 			rc = -EBUSY;
 		}
<span class="p_del">-		spin_unlock(&amp;ext_devt_lock);</span>
<span class="p_add">+		spin_unlock_bh(&amp;ext_devt_lock);</span>
 	} while (rc == -EAGAIN);
 
 	if (rc)
<span class="p_chunk">@@ -451,9 +451,9 @@</span> <span class="p_context"> void blk_free_devt(dev_t devt)</span>
 		return;
 
 	if (MAJOR(devt) == BLOCK_EXT_MAJOR) {
<span class="p_del">-		spin_lock(&amp;ext_devt_lock);</span>
<span class="p_add">+		spin_lock_bh(&amp;ext_devt_lock);</span>
 		idr_remove(&amp;ext_devt_idr, blk_mangle_minor(MINOR(devt)));
<span class="p_del">-		spin_unlock(&amp;ext_devt_lock);</span>
<span class="p_add">+		spin_unlock_bh(&amp;ext_devt_lock);</span>
 	}
 }
 
<span class="p_chunk">@@ -684,13 +684,13 @@</span> <span class="p_context"> struct gendisk *get_gendisk(dev_t devt, int *partno)</span>
 	} else {
 		struct hd_struct *part;
 
<span class="p_del">-		spin_lock(&amp;ext_devt_lock);</span>
<span class="p_add">+		spin_lock_bh(&amp;ext_devt_lock);</span>
 		part = idr_find(&amp;ext_devt_idr, blk_mangle_minor(MINOR(devt)));
 		if (part &amp;&amp; get_disk(part_to_disk(part))) {
 			*partno = part-&gt;partno;
 			disk = part_to_disk(part);
 		}
<span class="p_del">-		spin_unlock(&amp;ext_devt_lock);</span>
<span class="p_add">+		spin_unlock_bh(&amp;ext_devt_lock);</span>
 	}
 
 	return disk;
<span class="p_header">diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c</span>
<span class="p_header">index 6fc61eb..1338f1f 100644</span>
<span class="p_header">--- a/drivers/ata/ahci.c</span>
<span class="p_header">+++ b/drivers/ata/ahci.c</span>
<span class="p_chunk">@@ -67,6 +67,7 @@</span> <span class="p_context"> enum board_ids {</span>
 	board_ahci_yes_fbs,
 
 	/* board IDs for specific chipsets in alphabetical order */
<span class="p_add">+	board_ahci_avn,</span>
 	board_ahci_mcp65,
 	board_ahci_mcp77,
 	board_ahci_mcp89,
<span class="p_chunk">@@ -85,6 +86,8 @@</span> <span class="p_context"> enum board_ids {</span>
 static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent);
 static int ahci_vt8251_hardreset(struct ata_link *link, unsigned int *class,
 				 unsigned long deadline);
<span class="p_add">+static int ahci_avn_hardreset(struct ata_link *link, unsigned int *class,</span>
<span class="p_add">+			      unsigned long deadline);</span>
 static int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,
 				unsigned long deadline);
 #ifdef CONFIG_PM
<span class="p_chunk">@@ -106,6 +109,11 @@</span> <span class="p_context"> static struct ata_port_operations ahci_p5wdh_ops = {</span>
 	.hardreset		= ahci_p5wdh_hardreset,
 };
 
<span class="p_add">+static struct ata_port_operations ahci_avn_ops = {</span>
<span class="p_add">+	.inherits		= &amp;ahci_ops,</span>
<span class="p_add">+	.hardreset		= ahci_avn_hardreset,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct ata_port_info ahci_port_info[] = {
 	/* by features */
 	[board_ahci] =
<span class="p_chunk">@@ -154,6 +162,12 @@</span> <span class="p_context"> static const struct ata_port_info ahci_port_info[] = {</span>
 		.port_ops	= &amp;ahci_ops,
 	},
 	/* by chipsets */
<span class="p_add">+	[board_ahci_avn] = {</span>
<span class="p_add">+		.flags          = AHCI_FLAG_COMMON,</span>
<span class="p_add">+		.pio_mask       = ATA_PIO4,</span>
<span class="p_add">+		.udma_mask      = ATA_UDMA6,</span>
<span class="p_add">+		.port_ops       = &amp;ahci_avn_ops,</span>
<span class="p_add">+	},</span>
 	[board_ahci_mcp65] =
 	{
 		AHCI_HFLAGS	(AHCI_HFLAG_NO_FPDMA_AA | AHCI_HFLAG_NO_PMP |
<span class="p_chunk">@@ -300,14 +314,14 @@</span> <span class="p_context"> static const struct pci_device_id ahci_pci_tbl[] = {</span>
 	{ PCI_VDEVICE(INTEL, 0x1f27), board_ahci }, /* Avoton RAID */
 	{ PCI_VDEVICE(INTEL, 0x1f2e), board_ahci }, /* Avoton RAID */
 	{ PCI_VDEVICE(INTEL, 0x1f2f), board_ahci }, /* Avoton RAID */
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f32), board_ahci }, /* Avoton AHCI */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f33), board_ahci }, /* Avoton AHCI */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f34), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f35), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f36), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f37), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f3e), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f3f), board_ahci }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f32), board_ahci_avn }, /* Avoton AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f33), board_ahci_avn }, /* Avoton AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f34), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f35), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f36), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f37), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f3e), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f3f), board_ahci_avn }, /* Avoton RAID */</span>
 	{ PCI_VDEVICE(INTEL, 0x8d02), board_ahci }, /* Wellsburg AHCI */
 	{ PCI_VDEVICE(INTEL, 0x8d04), board_ahci }, /* Wellsburg RAID */
 	{ PCI_VDEVICE(INTEL, 0x8d06), board_ahci }, /* Wellsburg RAID */
<span class="p_chunk">@@ -671,6 +685,78 @@</span> <span class="p_context"> static int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,</span>
 	return rc;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * ahci_avn_hardreset - attempt more aggressive recovery of Avoton ports.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * It has been observed with some SSDs that the timing of events in the</span>
<span class="p_add">+ * link synchronization phase can leave the port in a state that can not</span>
<span class="p_add">+ * be recovered by a SATA-hard-reset alone.  The failing signature is</span>
<span class="p_add">+ * SStatus.DET stuck at 1 (&quot;Device presence detected but Phy</span>
<span class="p_add">+ * communication not established&quot;).  It was found that unloading and</span>
<span class="p_add">+ * reloading the driver when this problem occurs allows the drive</span>
<span class="p_add">+ * connection to be recovered (DET advanced to 0x3).  The critical</span>
<span class="p_add">+ * component of reloading the driver is that the port state machines are</span>
<span class="p_add">+ * reset by bouncing &quot;port enable&quot; in the AHCI PCS configuration</span>
<span class="p_add">+ * register.  So, reproduce that effect by bouncing a port whenever we</span>
<span class="p_add">+ * see DET==1 after a reset.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int ahci_avn_hardreset(struct ata_link *link, unsigned int *class,</span>
<span class="p_add">+			      unsigned long deadline)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const unsigned long *timing = sata_ehc_deb_timing(&amp;link-&gt;eh_context);</span>
<span class="p_add">+	struct ata_port *ap = link-&gt;ap;</span>
<span class="p_add">+	struct ahci_port_priv *pp = ap-&gt;private_data;</span>
<span class="p_add">+	u8 *d2h_fis = pp-&gt;rx_fis + RX_FIS_D2H_REG;</span>
<span class="p_add">+	unsigned long tmo = deadline - jiffies;</span>
<span class="p_add">+	struct ata_taskfile tf;</span>
<span class="p_add">+	bool online;</span>
<span class="p_add">+	int rc, i;</span>
<span class="p_add">+</span>
<span class="p_add">+	DPRINTK(&quot;ENTER\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	ahci_stop_engine(ap);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; 2; i++) {</span>
<span class="p_add">+		u16 val;</span>
<span class="p_add">+		u32 sstatus;</span>
<span class="p_add">+		int port = ap-&gt;port_no;</span>
<span class="p_add">+		struct ata_host *host = ap-&gt;host;</span>
<span class="p_add">+		struct pci_dev *pdev = to_pci_dev(host-&gt;dev);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* clear D2H reception area to properly wait for D2H FIS */</span>
<span class="p_add">+		ata_tf_init(link-&gt;device, &amp;tf);</span>
<span class="p_add">+		tf.command = ATA_BUSY;</span>
<span class="p_add">+		ata_tf_to_fis(&amp;tf, 0, 0, d2h_fis);</span>
<span class="p_add">+</span>
<span class="p_add">+		rc = sata_link_hardreset(link, timing, deadline, &amp;online,</span>
<span class="p_add">+				ahci_check_ready);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (sata_scr_read(link, SCR_STATUS, &amp;sstatus) != 0 ||</span>
<span class="p_add">+				(sstatus &amp; 0xf) != 1)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		ata_link_printk(link, KERN_INFO, &quot;avn bounce port%d\n&quot;,</span>
<span class="p_add">+				port);</span>
<span class="p_add">+</span>
<span class="p_add">+		pci_read_config_word(pdev, 0x92, &amp;val);</span>
<span class="p_add">+		val &amp;= ~(1 &lt;&lt; port);</span>
<span class="p_add">+		pci_write_config_word(pdev, 0x92, val);</span>
<span class="p_add">+		ata_msleep(ap, 1000);</span>
<span class="p_add">+		val |= 1 &lt;&lt; port;</span>
<span class="p_add">+		pci_write_config_word(pdev, 0x92, val);</span>
<span class="p_add">+		deadline += tmo;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ahci_start_engine(ap);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (online)</span>
<span class="p_add">+		*class = ahci_dev_classify(ap);</span>
<span class="p_add">+</span>
<span class="p_add">+	DPRINTK(&quot;EXIT, rc=%d, class=%u\n&quot;, rc, *class);</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 #ifdef CONFIG_PM
 static int ahci_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg)
 {
<span class="p_header">diff --git a/drivers/ata/ahci.h b/drivers/ata/ahci.h</span>
<span class="p_header">index c2594dd..57eb1c2 100644</span>
<span class="p_header">--- a/drivers/ata/ahci.h</span>
<span class="p_header">+++ b/drivers/ata/ahci.h</span>
<span class="p_chunk">@@ -320,6 +320,7 @@</span> <span class="p_context"> extern struct device_attribute *ahci_sdev_attrs[];</span>
 extern struct ata_port_operations ahci_ops;
 extern struct ata_port_operations ahci_pmp_retry_srst_ops;
 
<span class="p_add">+unsigned int ahci_dev_classify(struct ata_port *ap);</span>
 void ahci_fill_cmd_slot(struct ahci_port_priv *pp, unsigned int tag,
 			u32 opts);
 void ahci_save_initial_config(struct device *dev,
<span class="p_header">diff --git a/drivers/ata/libahci.c b/drivers/ata/libahci.c</span>
<span class="p_header">index 60f41cd..30cdba7 100644</span>
<span class="p_header">--- a/drivers/ata/libahci.c</span>
<span class="p_header">+++ b/drivers/ata/libahci.c</span>
<span class="p_chunk">@@ -1139,7 +1139,7 @@</span> <span class="p_context"> static void ahci_dev_config(struct ata_device *dev)</span>
 	}
 }
 
<span class="p_del">-static unsigned int ahci_dev_classify(struct ata_port *ap)</span>
<span class="p_add">+unsigned int ahci_dev_classify(struct ata_port *ap)</span>
 {
 	void __iomem *port_mmio = ahci_port_base(ap);
 	struct ata_taskfile tf;
<span class="p_chunk">@@ -1153,6 +1153,7 @@</span> <span class="p_context"> static unsigned int ahci_dev_classify(struct ata_port *ap)</span>
 
 	return ata_dev_classify(&amp;tf);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(ahci_dev_classify);</span>
 
 void ahci_fill_cmd_slot(struct ahci_port_priv *pp, unsigned int tag,
 			u32 opts)
<span class="p_chunk">@@ -1670,8 +1671,7 @@</span> <span class="p_context"> static void ahci_port_intr(struct ata_port *ap)</span>
 	if (unlikely(resetting))
 		status &amp;= ~PORT_IRQ_BAD_PMP;
 
<span class="p_del">-	/* if LPM is enabled, PHYRDY doesn&#39;t mean anything */</span>
<span class="p_del">-	if (ap-&gt;link.lpm_policy &gt; ATA_LPM_MAX_POWER) {</span>
<span class="p_add">+	if (sata_lpm_ignore_phy_events(&amp;ap-&gt;link)) {</span>
 		status &amp;= ~PORT_IRQ_PHYRDY;
 		ahci_scr_write(&amp;ap-&gt;link, SCR_ERROR, SERR_PHYRDY_CHG);
 	}
<span class="p_header">diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c</span>
<span class="p_header">index adaf994..0a6767b 100644</span>
<span class="p_header">--- a/drivers/ata/libata-core.c</span>
<span class="p_header">+++ b/drivers/ata/libata-core.c</span>
<span class="p_chunk">@@ -6657,6 +6657,38 @@</span> <span class="p_context"> u32 ata_wait_register(struct ata_port *ap, void __iomem *reg, u32 mask, u32 val,</span>
 	return tmp;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ *	sata_lpm_ignore_phy_events - test if PHY event should be ignored</span>
<span class="p_add">+ *	@link: Link receiving the event</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Test whether the received PHY event has to be ignored or not.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	LOCKING:</span>
<span class="p_add">+ *	None:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	RETURNS:</span>
<span class="p_add">+ *	True if the event has to be ignored.</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool sata_lpm_ignore_phy_events(struct ata_link *link)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long lpm_timeout = link-&gt;last_lpm_change +</span>
<span class="p_add">+				    msecs_to_jiffies(ATA_TMOUT_SPURIOUS_PHY);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* if LPM is enabled, PHYRDY doesn&#39;t mean anything */</span>
<span class="p_add">+	if (link-&gt;lpm_policy &gt; ATA_LPM_MAX_POWER)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* ignore the first PHY event after the LPM policy changed</span>
<span class="p_add">+	 * as it is might be spurious</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((link-&gt;flags &amp; ATA_LFLAG_CHANGED) &amp;&amp;</span>
<span class="p_add">+	    time_before(jiffies, lpm_timeout))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(sata_lpm_ignore_phy_events);</span>
<span class="p_add">+</span>
 /*
  * Dummy port_ops
  */
<span class="p_header">diff --git a/drivers/ata/libata-eh.c b/drivers/ata/libata-eh.c</span>
<span class="p_header">index 37fb4d6..033b8cd 100644</span>
<span class="p_header">--- a/drivers/ata/libata-eh.c</span>
<span class="p_header">+++ b/drivers/ata/libata-eh.c</span>
<span class="p_chunk">@@ -3424,6 +3424,9 @@</span> <span class="p_context"> static int ata_eh_set_lpm(struct ata_link *link, enum ata_lpm_policy policy,</span>
 		}
 	}
 
<span class="p_add">+	link-&gt;last_lpm_change = jiffies;</span>
<span class="p_add">+	link-&gt;flags |= ATA_LFLAG_CHANGED;</span>
<span class="p_add">+</span>
 	return 0;
 
 fail:
<span class="p_header">diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c</span>
<span class="p_header">index 8a084bf..52be498 100644</span>
<span class="p_header">--- a/drivers/bluetooth/ath3k.c</span>
<span class="p_header">+++ b/drivers/bluetooth/ath3k.c</span>
<span class="p_chunk">@@ -64,6 +64,7 @@</span> <span class="p_context"> static struct usb_device_id ath3k_table[] = {</span>
 	/* Atheros AR3011 with sflash firmware*/
 	{ USB_DEVICE(0x0489, 0xE027) },
 	{ USB_DEVICE(0x0489, 0xE03D) },
<span class="p_add">+	{ USB_DEVICE(0x04F2, 0xAFF1) },</span>
 	{ USB_DEVICE(0x0930, 0x0215) },
 	{ USB_DEVICE(0x0CF3, 0x3002) },
 	{ USB_DEVICE(0x0CF3, 0xE019) },
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index 7c0b21e..f8a58db 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -142,6 +142,7 @@</span> <span class="p_context"> static struct usb_device_id blacklist_table[] = {</span>
 	/* Atheros 3011 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xe027), .driver_info = BTUSB_IGNORE },
 	{ USB_DEVICE(0x0489, 0xe03d), .driver_info = BTUSB_IGNORE },
<span class="p_add">+	{ USB_DEVICE(0x04f2, 0xaff1), .driver_info = BTUSB_IGNORE },</span>
 	{ USB_DEVICE(0x0930, 0x0215), .driver_info = BTUSB_IGNORE },
 	{ USB_DEVICE(0x0cf3, 0x3002), .driver_info = BTUSB_IGNORE },
 	{ USB_DEVICE(0x0cf3, 0xe019), .driver_info = BTUSB_IGNORE },
<span class="p_header">diff --git a/drivers/char/ipmi/ipmi_si_intf.c b/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_header">index bdecba5..e539949 100644</span>
<span class="p_header">--- a/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_header">+++ b/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_chunk">@@ -2668,7 +2668,7 @@</span> <span class="p_context"> static int wait_for_msg_done(struct smi_info *smi_info)</span>
 		    smi_result == SI_SM_CALL_WITH_TICK_DELAY) {
 			schedule_timeout_uninterruptible(1);
 			smi_result = smi_info-&gt;handlers-&gt;event(
<span class="p_del">-				smi_info-&gt;si_sm, 100);</span>
<span class="p_add">+				smi_info-&gt;si_sm, jiffies_to_usecs(1));</span>
 		} else if (smi_result == SI_SM_CALL_WITHOUT_DELAY) {
 			smi_result = smi_info-&gt;handlers-&gt;event(
 				smi_info-&gt;si_sm, 0);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c</span>
<span class="p_header">index b1f1d10..e1c744d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem.c</span>
<span class="p_chunk">@@ -1779,9 +1779,6 @@</span> <span class="p_context"> i915_gem_retire_requests_ring(struct intel_ring_buffer *ring)</span>
 	uint32_t seqno;
 	int i;
 
<span class="p_del">-	if (list_empty(&amp;ring-&gt;request_list))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	WARN_ON(i915_verify_lists(ring-&gt;dev));
 
 	seqno = ring-&gt;get_seqno(ring);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_crtc.c b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">index d51c08d..af6790c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_chunk">@@ -318,8 +318,10 @@</span> <span class="p_context"> atombios_set_crtc_dtd_timing(struct drm_crtc *crtc,</span>
 		misc |= ATOM_COMPOSITESYNC;
 	if (mode-&gt;flags &amp; DRM_MODE_FLAG_INTERLACE)
 		misc |= ATOM_INTERLACE;
<span class="p_del">-	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLCLK)</span>
 		misc |= ATOM_DOUBLE_CLOCK_MODE;
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+		misc |= ATOM_H_REPLICATIONBY2 | ATOM_V_REPLICATIONBY2;</span>
 
 	args.susModeMiscInfo.usAccess = cpu_to_le16(misc);
 	args.ucCRTC = radeon_crtc-&gt;crtc_id;
<span class="p_chunk">@@ -362,8 +364,10 @@</span> <span class="p_context"> static void atombios_crtc_set_timing(struct drm_crtc *crtc,</span>
 		misc |= ATOM_COMPOSITESYNC;
 	if (mode-&gt;flags &amp; DRM_MODE_FLAG_INTERLACE)
 		misc |= ATOM_INTERLACE;
<span class="p_del">-	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLCLK)</span>
 		misc |= ATOM_DOUBLE_CLOCK_MODE;
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+		misc |= ATOM_H_REPLICATIONBY2 | ATOM_V_REPLICATIONBY2;</span>
 
 	args.susModeMiscInfo.usAccess = cpu_to_le16(misc);
 	args.ucCRTC = radeon_crtc-&gt;crtc_id;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/evergreen.c b/drivers/gpu/drm/radeon/evergreen.c</span>
<span class="p_header">index c5fe79e..db4df97 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/evergreen.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/evergreen.c</span>
<span class="p_chunk">@@ -1079,7 +1079,7 @@</span> <span class="p_context"> int evergreen_pcie_gart_enable(struct radeon_device *rdev)</span>
 	WREG32(MC_VM_MB_L1_TLB2_CNTL, tmp);
 	WREG32(MC_VM_MB_L1_TLB3_CNTL, tmp);
 	WREG32(VM_CONTEXT0_PAGE_TABLE_START_ADDR, rdev-&gt;mc.gtt_start &gt;&gt; 12);
<span class="p_del">-	WREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR, rdev-&gt;mc.gtt_end &gt;&gt; 12);</span>
<span class="p_add">+	WREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR, (rdev-&gt;mc.gtt_end &gt;&gt; 12) - 1);</span>
 	WREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR, rdev-&gt;gart.table_addr &gt;&gt; 12);
 	WREG32(VM_CONTEXT0_CNTL, ENABLE_CONTEXT | PAGE_TABLE_DEPTH(0) |
 				RANGE_PROTECTION_FAULT_ENABLE_DEFAULT);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/ni.c b/drivers/gpu/drm/radeon/ni.c</span>
<span class="p_header">index 461262e..1f45179 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/ni.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/ni.c</span>
<span class="p_chunk">@@ -1075,7 +1075,7 @@</span> <span class="p_context"> int cayman_pcie_gart_enable(struct radeon_device *rdev)</span>
 	       L2_CACHE_BIGK_FRAGMENT_SIZE(6));
 	/* setup context0 */
 	WREG32(VM_CONTEXT0_PAGE_TABLE_START_ADDR, rdev-&gt;mc.gtt_start &gt;&gt; 12);
<span class="p_del">-	WREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR, rdev-&gt;mc.gtt_end &gt;&gt; 12);</span>
<span class="p_add">+	WREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR, (rdev-&gt;mc.gtt_end &gt;&gt; 12) - 1);</span>
 	WREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR, rdev-&gt;gart.table_addr &gt;&gt; 12);
 	WREG32(VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR,
 			(u32)(rdev-&gt;dummy_page.addr &gt;&gt; 12));
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/r600.c b/drivers/gpu/drm/radeon/r600.c</span>
<span class="p_header">index 9c7062d..d441aed 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/r600.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/r600.c</span>
<span class="p_chunk">@@ -930,7 +930,7 @@</span> <span class="p_context"> int r600_pcie_gart_enable(struct radeon_device *rdev)</span>
 	WREG32(MC_VM_L1_TLB_MCB_RD_SEM_CNTL, tmp | ENABLE_SEMAPHORE_MODE);
 	WREG32(MC_VM_L1_TLB_MCB_WR_SEM_CNTL, tmp | ENABLE_SEMAPHORE_MODE);
 	WREG32(VM_CONTEXT0_PAGE_TABLE_START_ADDR, rdev-&gt;mc.gtt_start &gt;&gt; 12);
<span class="p_del">-	WREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR, rdev-&gt;mc.gtt_end &gt;&gt; 12);</span>
<span class="p_add">+	WREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR, (rdev-&gt;mc.gtt_end &gt;&gt; 12) - 1);</span>
 	WREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR, rdev-&gt;gart.table_addr &gt;&gt; 12);
 	WREG32(VM_CONTEXT0_CNTL, ENABLE_CONTEXT | PAGE_TABLE_DEPTH(0) |
 				RANGE_PROTECTION_FAULT_ENABLE_DEFAULT);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_cs.c b/drivers/gpu/drm/radeon/radeon_cs.c</span>
<span class="p_header">index f3ee360..d66d2cd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_cs.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_cs.c</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> int radeon_cs_parser_relocs(struct radeon_cs_parser *p)</span>
 	if (p-&gt;relocs_ptr == NULL) {
 		return -ENOMEM;
 	}
<span class="p_del">-	p-&gt;relocs = kcalloc(p-&gt;nrelocs, sizeof(struct radeon_cs_reloc), GFP_KERNEL);</span>
<span class="p_add">+	p-&gt;relocs = drm_calloc_large(p-&gt;nrelocs, sizeof(struct radeon_bo_list));</span>
 	if (p-&gt;relocs == NULL) {
 		return -ENOMEM;
 	}
<span class="p_chunk">@@ -324,7 +324,7 @@</span> <span class="p_context"> static void radeon_cs_parser_fini(struct radeon_cs_parser *parser, int error)</span>
 		}
 	}
 	kfree(parser-&gt;track);
<span class="p_del">-	kfree(parser-&gt;relocs);</span>
<span class="p_add">+	drm_free_large(parser-&gt;relocs);</span>
 	kfree(parser-&gt;relocs_ptr);
 	for (i = 0; i &lt; parser-&gt;nchunks; i++) {
 		kfree(parser-&gt;chunks[i].kdata);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/rv770.c b/drivers/gpu/drm/radeon/rv770.c</span>
<span class="p_header">index 1ec1255..3358730 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/rv770.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/rv770.c</span>
<span class="p_chunk">@@ -158,7 +158,7 @@</span> <span class="p_context"> int rv770_pcie_gart_enable(struct radeon_device *rdev)</span>
 	WREG32(MC_VM_MB_L1_TLB2_CNTL, tmp);
 	WREG32(MC_VM_MB_L1_TLB3_CNTL, tmp);
 	WREG32(VM_CONTEXT0_PAGE_TABLE_START_ADDR, rdev-&gt;mc.gtt_start &gt;&gt; 12);
<span class="p_del">-	WREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR, rdev-&gt;mc.gtt_end &gt;&gt; 12);</span>
<span class="p_add">+	WREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR, (rdev-&gt;mc.gtt_end &gt;&gt; 12) - 1);</span>
 	WREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR, rdev-&gt;gart.table_addr &gt;&gt; 12);
 	WREG32(VM_CONTEXT0_CNTL, ENABLE_CONTEXT | PAGE_TABLE_DEPTH(0) |
 				RANGE_PROTECTION_FAULT_ENABLE_DEFAULT);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si.c b/drivers/gpu/drm/radeon/si.c</span>
<span class="p_header">index 068b21f..3b6e641 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si.c</span>
<span class="p_chunk">@@ -2537,7 +2537,7 @@</span> <span class="p_context"> int si_pcie_gart_enable(struct radeon_device *rdev)</span>
 	       L2_CACHE_BIGK_FRAGMENT_SIZE(0));
 	/* setup context0 */
 	WREG32(VM_CONTEXT0_PAGE_TABLE_START_ADDR, rdev-&gt;mc.gtt_start &gt;&gt; 12);
<span class="p_del">-	WREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR, rdev-&gt;mc.gtt_end &gt;&gt; 12);</span>
<span class="p_add">+	WREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR, (rdev-&gt;mc.gtt_end &gt;&gt; 12) - 1);</span>
 	WREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR, rdev-&gt;gart.table_addr &gt;&gt; 12);
 	WREG32(VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR,
 			(u32)(rdev-&gt;dummy_page.addr &gt;&gt; 12));
<span class="p_chunk">@@ -2555,7 +2555,7 @@</span> <span class="p_context"> int si_pcie_gart_enable(struct radeon_device *rdev)</span>
 	 */
 	/* set vm size, must be a multiple of 4 */
 	WREG32(VM_CONTEXT1_PAGE_TABLE_START_ADDR, 0);
<span class="p_del">-	WREG32(VM_CONTEXT1_PAGE_TABLE_END_ADDR, rdev-&gt;vm_manager.max_pfn);</span>
<span class="p_add">+	WREG32(VM_CONTEXT1_PAGE_TABLE_END_ADDR, rdev-&gt;vm_manager.max_pfn - 1);</span>
 	for (i = 1; i &lt; 16; i++) {
 		if (i &lt; 8)
 			WREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR + (i &lt;&lt; 2),
<span class="p_header">diff --git a/drivers/hv/channel.c b/drivers/hv/channel.c</span>
<span class="p_header">index 3c8b2c4..980ef7e 100644</span>
<span class="p_header">--- a/drivers/hv/channel.c</span>
<span class="p_header">+++ b/drivers/hv/channel.c</span>
<span class="p_chunk">@@ -177,7 +177,7 @@</span> <span class="p_context"> int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,</span>
 			   GFP_KERNEL);
 	if (!open_info) {
 		err = -ENOMEM;
<span class="p_del">-		goto error0;</span>
<span class="p_add">+		goto error_gpadl;</span>
 	}
 
 	init_completion(&amp;open_info-&gt;waitevent);
<span class="p_chunk">@@ -193,7 +193,7 @@</span> <span class="p_context"> int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,</span>
 
 	if (userdatalen &gt; MAX_USER_DEFINED_BYTES) {
 		err = -EINVAL;
<span class="p_del">-		goto error0;</span>
<span class="p_add">+		goto error_gpadl;</span>
 	}
 
 	if (userdatalen)
<span class="p_chunk">@@ -234,6 +234,9 @@</span> <span class="p_context"> error1:</span>
 	list_del(&amp;open_info-&gt;msglistentry);
 	spin_unlock_irqrestore(&amp;vmbus_connection.channelmsg_lock, flags);
 
<span class="p_add">+error_gpadl:</span>
<span class="p_add">+	vmbus_teardown_gpadl(newchannel, newchannel-&gt;ringbuffer_gpadlhandle);</span>
<span class="p_add">+</span>
 error0:
 	free_pages((unsigned long)out,
 		get_order(send_ringbuffer_size + recv_ringbuffer_size));
<span class="p_header">diff --git a/drivers/hv/channel_mgmt.c b/drivers/hv/channel_mgmt.c</span>
<span class="p_header">index 9ffbfc5..bcf67af 100644</span>
<span class="p_header">--- a/drivers/hv/channel_mgmt.c</span>
<span class="p_header">+++ b/drivers/hv/channel_mgmt.c</span>
<span class="p_chunk">@@ -531,7 +531,7 @@</span> <span class="p_context"> int vmbus_request_offers(void)</span>
 {
 	struct vmbus_channel_message_header *msg;
 	struct vmbus_channel_msginfo *msginfo;
<span class="p_del">-	int ret, t;</span>
<span class="p_add">+	int ret;</span>
 
 	msginfo = kmalloc(sizeof(*msginfo) +
 			  sizeof(struct vmbus_channel_message_header),
<span class="p_chunk">@@ -539,8 +539,6 @@</span> <span class="p_context"> int vmbus_request_offers(void)</span>
 	if (!msginfo)
 		return -ENOMEM;
 
<span class="p_del">-	init_completion(&amp;msginfo-&gt;waitevent);</span>
<span class="p_del">-</span>
 	msg = (struct vmbus_channel_message_header *)msginfo-&gt;msg;
 
 	msg-&gt;msgtype = CHANNELMSG_REQUESTOFFERS;
<span class="p_chunk">@@ -554,14 +552,6 @@</span> <span class="p_context"> int vmbus_request_offers(void)</span>
 		goto cleanup;
 	}
 
<span class="p_del">-	t = wait_for_completion_timeout(&amp;msginfo-&gt;waitevent, 5*HZ);</span>
<span class="p_del">-	if (t == 0) {</span>
<span class="p_del">-		ret = -ETIMEDOUT;</span>
<span class="p_del">-		goto cleanup;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
 cleanup:
 	kfree(msginfo);
 
<span class="p_header">diff --git a/drivers/infiniband/core/cma.c b/drivers/infiniband/core/cma.c</span>
<span class="p_header">index 67432e2..8987a9a 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/cma.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/cma.c</span>
<span class="p_chunk">@@ -759,36 +759,43 @@</span> <span class="p_context"> static int cma_get_net_info(void *hdr, enum rdma_port_space ps,</span>
 	return 0;
 }
 
<span class="p_add">+static __be16 ss_get_port(const struct sockaddr_storage *ss)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (ss-&gt;ss_family == AF_INET)</span>
<span class="p_add">+		return ((struct sockaddr_in *)ss)-&gt;sin_port;</span>
<span class="p_add">+	else if (ss-&gt;ss_family == AF_INET6)</span>
<span class="p_add">+		return ((struct sockaddr_in6 *)ss)-&gt;sin6_port;</span>
<span class="p_add">+	BUG();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void cma_save_net_info(struct rdma_addr *addr,
 			      struct rdma_addr *listen_addr,
 			      u8 ip_ver, __be16 port,
 			      union cma_ip_addr *src, union cma_ip_addr *dst)
 {
<span class="p_del">-	struct sockaddr_in *listen4, *ip4;</span>
<span class="p_del">-	struct sockaddr_in6 *listen6, *ip6;</span>
<span class="p_add">+	struct sockaddr_in *ip4;</span>
<span class="p_add">+	struct sockaddr_in6 *ip6;</span>
 
 	switch (ip_ver) {
 	case 4:
<span class="p_del">-		listen4 = (struct sockaddr_in *) &amp;listen_addr-&gt;src_addr;</span>
 		ip4 = (struct sockaddr_in *) &amp;addr-&gt;src_addr;
<span class="p_del">-		ip4-&gt;sin_family = listen4-&gt;sin_family;</span>
<span class="p_add">+		ip4-&gt;sin_family = AF_INET;;</span>
 		ip4-&gt;sin_addr.s_addr = dst-&gt;ip4.addr;
<span class="p_del">-		ip4-&gt;sin_port = listen4-&gt;sin_port;</span>
<span class="p_add">+		ip4-&gt;sin_port = ss_get_port(&amp;listen_addr-&gt;src_addr);</span>
 
 		ip4 = (struct sockaddr_in *) &amp;addr-&gt;dst_addr;
<span class="p_del">-		ip4-&gt;sin_family = listen4-&gt;sin_family;</span>
<span class="p_add">+		ip4-&gt;sin_family = AF_INET;</span>
 		ip4-&gt;sin_addr.s_addr = src-&gt;ip4.addr;
 		ip4-&gt;sin_port = port;
 		break;
 	case 6:
<span class="p_del">-		listen6 = (struct sockaddr_in6 *) &amp;listen_addr-&gt;src_addr;</span>
 		ip6 = (struct sockaddr_in6 *) &amp;addr-&gt;src_addr;
<span class="p_del">-		ip6-&gt;sin6_family = listen6-&gt;sin6_family;</span>
<span class="p_add">+		ip6-&gt;sin6_family = AF_INET6;</span>
 		ip6-&gt;sin6_addr = dst-&gt;ip6;
<span class="p_del">-		ip6-&gt;sin6_port = listen6-&gt;sin6_port;</span>
<span class="p_add">+		ip6-&gt;sin6_port = ss_get_port(&amp;listen_addr-&gt;src_addr);</span>
 
 		ip6 = (struct sockaddr_in6 *) &amp;addr-&gt;dst_addr;
<span class="p_del">-		ip6-&gt;sin6_family = listen6-&gt;sin6_family;</span>
<span class="p_add">+		ip6-&gt;sin6_family = AF_INET6;</span>
 		ip6-&gt;sin6_addr = src-&gt;ip6;
 		ip6-&gt;sin6_port = port;
 		break;
<span class="p_header">diff --git a/drivers/infiniband/core/umem.c b/drivers/infiniband/core/umem.c</span>
<span class="p_header">index d0254be..c1fef27 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/umem.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/umem.c</span>
<span class="p_chunk">@@ -94,6 +94,9 @@</span> <span class="p_context"> struct ib_umem *ib_umem_get(struct ib_ucontext *context, unsigned long addr,</span>
 	if (dmasync)
 		dma_set_attr(DMA_ATTR_WRITE_BARRIER, &amp;attrs);
 
<span class="p_add">+	if (!size)</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
 	/*
 	 * If the combination of the addr and size requested for this memory
 	 * region causes an integer overflow, return error.
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">index 3a78489..b53548c 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_chunk">@@ -1670,8 +1670,7 @@</span> <span class="p_context"> static int build_lso_seg(struct mlx4_wqe_lso_seg *wqe, struct ib_send_wr *wr,</span>
 
 	memcpy(wqe-&gt;header, wr-&gt;wr.ud.header, wr-&gt;wr.ud.hlen);
 
<span class="p_del">-	*lso_hdr_sz  = cpu_to_be32((wr-&gt;wr.ud.mss - wr-&gt;wr.ud.hlen) &lt;&lt; 16 |</span>
<span class="p_del">-				   wr-&gt;wr.ud.hlen);</span>
<span class="p_add">+	*lso_hdr_sz  = cpu_to_be32(wr-&gt;wr.ud.mss &lt;&lt; 16 | wr-&gt;wr.ud.hlen);</span>
 	*lso_seg_len = halign;
 	return 0;
 }
<span class="p_header">diff --git a/drivers/input/mouse/elantech.c b/drivers/input/mouse/elantech.c</span>
<span class="p_header">index f2c2ffe..8eeff9e 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.c</span>
<span class="p_chunk">@@ -313,7 +313,7 @@</span> <span class="p_context"> static void elantech_report_semi_mt_data(struct input_dev *dev,</span>
 					 unsigned int x2, unsigned int y2)
 {
 	elantech_set_slot(dev, 0, num_fingers != 0, x1, y1);
<span class="p_del">-	elantech_set_slot(dev, 1, num_fingers == 2, x2, y2);</span>
<span class="p_add">+	elantech_set_slot(dev, 1, num_fingers &gt;= 2, x2, y2);</span>
 }
 
 /*
<span class="p_chunk">@@ -783,6 +783,21 @@</span> <span class="p_context"> static psmouse_ret_t elantech_process_byte(struct psmouse *psmouse)</span>
 }
 
 /*
<span class="p_add">+ * This writes the reg_07 value again to the hardware at the end of every</span>
<span class="p_add">+ * set_rate call because the register loses its value. reg_07 allows setting</span>
<span class="p_add">+ * absolute mode on v4 hardware</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void elantech_set_rate_restore_reg_07(struct psmouse *psmouse,</span>
<span class="p_add">+		unsigned int rate)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct elantech_data *etd = psmouse-&gt;private;</span>
<span class="p_add">+</span>
<span class="p_add">+	etd-&gt;original_set_rate(psmouse, rate);</span>
<span class="p_add">+	if (elantech_write_reg(psmouse, 0x07, etd-&gt;reg_07))</span>
<span class="p_add">+		psmouse_err(psmouse, &quot;restoring reg_07 failed\n&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Put the touchpad into absolute mode
  */
 static int elantech_set_absolute_mode(struct psmouse *psmouse)
<span class="p_chunk">@@ -980,6 +995,8 @@</span> <span class="p_context"> static int elantech_get_resolution_v4(struct psmouse *psmouse,</span>
  * Asus K53SV              0x450f01        78, 15, 0c      2 hw buttons
  * Asus G46VW              0x460f02        00, 18, 0c      2 hw buttons
  * Asus G750JX             0x360f00        00, 16, 0c      2 hw buttons
<span class="p_add">+ * Asus TP500LN            0x381f17        10, 14, 0e      clickpad</span>
<span class="p_add">+ * Asus X750JN             0x381f17        10, 14, 0e      clickpad</span>
  * Asus UX31               0x361f00        20, 15, 0e      clickpad
  * Asus UX32VD             0x361f02        00, 15, 0e      clickpad
  * Avatar AVIU-145A2       0x361f00        ?               clickpad
<span class="p_chunk">@@ -1219,10 +1236,11 @@</span> <span class="p_context"> static bool elantech_is_signature_valid(const unsigned char *param)</span>
 		return true;
 
 	/*
<span class="p_del">-	 * Some models have a revision higher then 20. Meaning param[2] may</span>
<span class="p_del">-	 * be 10 or 20, skip the rates check for these.</span>
<span class="p_add">+	 * Some hw_version &gt;= 4 models have a revision higher then 20. Meaning</span>
<span class="p_add">+	 * that param[2] may be 10 or 20, skip the rates check for these.</span>
 	 */
<span class="p_del">-	if (param[0] == 0x46 &amp;&amp; (param[1] &amp; 0xef) == 0x0f &amp;&amp; param[2] &lt; 40)</span>
<span class="p_add">+	if ((param[0] &amp; 0x0f) &gt;= 0x06 &amp;&amp; (param[1] &amp; 0xaf) == 0x0f &amp;&amp;</span>
<span class="p_add">+	    param[2] &lt; 40)</span>
 		return true;
 
 	for (i = 0; i &lt; ARRAY_SIZE(rates); i++)
<span class="p_chunk">@@ -1427,6 +1445,11 @@</span> <span class="p_context"> int elantech_init(struct psmouse *psmouse)</span>
 		goto init_fail;
 	}
 
<span class="p_add">+	if (etd-&gt;fw_version == 0x381f17) {</span>
<span class="p_add">+		etd-&gt;original_set_rate = psmouse-&gt;set_rate;</span>
<span class="p_add">+		psmouse-&gt;set_rate = elantech_set_rate_restore_reg_07;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (elantech_set_input_params(psmouse)) {
 		psmouse_err(psmouse, &quot;failed to query touchpad range.\n&quot;);
 		goto init_fail;
<span class="p_header">diff --git a/drivers/input/mouse/elantech.h b/drivers/input/mouse/elantech.h</span>
<span class="p_header">index 46db3be..4d1b220 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.h</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.h</span>
<span class="p_chunk">@@ -137,6 +137,7 @@</span> <span class="p_context"> struct elantech_data {</span>
 	struct finger_pos mt[ETP_MAX_FINGERS];
 	unsigned char parity[256];
 	int (*send_cmd)(struct psmouse *psmouse, unsigned char c, unsigned char *param);
<span class="p_add">+	void (*original_set_rate)(struct psmouse *psmouse, unsigned int rate);</span>
 };
 
 #ifdef CONFIG_MOUSE_PS2_ELANTECH
<span class="p_header">diff --git a/drivers/lguest/core.c b/drivers/lguest/core.c</span>
<span class="p_header">index b5fdcb7..34842e5 100644</span>
<span class="p_header">--- a/drivers/lguest/core.c</span>
<span class="p_header">+++ b/drivers/lguest/core.c</span>
<span class="p_chunk">@@ -171,7 +171,7 @@</span> <span class="p_context"> static void unmap_switcher(void)</span>
 bool lguest_address_ok(const struct lguest *lg,
 		       unsigned long addr, unsigned long len)
 {
<span class="p_del">-	return (addr+len) / PAGE_SIZE &lt; lg-&gt;pfn_limit &amp;&amp; (addr+len &gt;= addr);</span>
<span class="p_add">+	return addr+len &lt;= lg-&gt;pfn_limit * PAGE_SIZE &amp;&amp; (addr+len &gt;= addr);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c</span>
<span class="p_header">index 926989d..a1bd688 100644</span>
<span class="p_header">--- a/drivers/md/dm-crypt.c</span>
<span class="p_header">+++ b/drivers/md/dm-crypt.c</span>
<span class="p_chunk">@@ -782,11 +782,10 @@</span> <span class="p_context"> static int crypt_convert(struct crypt_config *cc,</span>
 
 		switch (r) {
 		/* async */
<span class="p_add">+		case -EINPROGRESS:</span>
 		case -EBUSY:
 			wait_for_completion(&amp;ctx-&gt;restart);
 			INIT_COMPLETION(ctx-&gt;restart);
<span class="p_del">-			/* fall through*/</span>
<span class="p_del">-		case -EINPROGRESS:</span>
 			this_cc-&gt;req = NULL;
 			ctx-&gt;sector++;
 			continue;
<span class="p_chunk">@@ -1195,10 +1194,8 @@</span> <span class="p_context"> static void kcryptd_async_done(struct crypto_async_request *async_req,</span>
 	struct dm_crypt_io *io = container_of(ctx, struct dm_crypt_io, ctx);
 	struct crypt_config *cc = io-&gt;target-&gt;private;
 
<span class="p_del">-	if (error == -EINPROGRESS) {</span>
<span class="p_del">-		complete(&amp;ctx-&gt;restart);</span>
<span class="p_add">+	if (error == -EINPROGRESS)</span>
 		return;
<span class="p_del">-	}</span>
 
 	if (!error &amp;&amp; cc-&gt;iv_gen_ops &amp;&amp; cc-&gt;iv_gen_ops-&gt;post)
 		error = cc-&gt;iv_gen_ops-&gt;post(cc, iv_of_dmreq(cc, dmreq), dmreq);
<span class="p_chunk">@@ -1209,12 +1206,15 @@</span> <span class="p_context"> static void kcryptd_async_done(struct crypto_async_request *async_req,</span>
 	mempool_free(req_of_dmreq(cc, dmreq), cc-&gt;req_pool);
 
 	if (!atomic_dec_and_test(&amp;ctx-&gt;pending))
<span class="p_del">-		return;</span>
<span class="p_add">+		goto done;</span>
 
 	if (bio_data_dir(io-&gt;base_bio) == READ)
 		kcryptd_crypt_read_done(io);
 	else
 		kcryptd_crypt_write_io_submit(io, 1);
<span class="p_add">+done:</span>
<span class="p_add">+	if (!completion_done(&amp;ctx-&gt;restart))</span>
<span class="p_add">+		complete(&amp;ctx-&gt;restart);</span>
 }
 
 static void kcryptd_crypt(struct work_struct *work)
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index 17e2f52..83dba06 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -5431,9 +5431,9 @@</span> <span class="p_context"> static int get_bitmap_file(struct mddev * mddev, void __user * arg)</span>
 	int err = -ENOMEM;
 
 	if (md_allow_write(mddev))
<span class="p_del">-		file = kmalloc(sizeof(*file), GFP_NOIO);</span>
<span class="p_add">+		file = kzalloc(sizeof(*file), GFP_NOIO);</span>
 	else
<span class="p_del">-		file = kmalloc(sizeof(*file), GFP_KERNEL);</span>
<span class="p_add">+		file = kzalloc(sizeof(*file), GFP_KERNEL);</span>
 
 	if (!file)
 		goto out;
<span class="p_header">diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c</span>
<span class="p_header">index c276ad0..7a218e8 100644</span>
<span class="p_header">--- a/drivers/md/raid5.c</span>
<span class="p_header">+++ b/drivers/md/raid5.c</span>
<span class="p_chunk">@@ -1622,7 +1622,8 @@</span> <span class="p_context"> static int resize_stripes(struct r5conf *conf, int newsize)</span>
 
 	conf-&gt;slab_cache = sc;
 	conf-&gt;active_name = 1-conf-&gt;active_name;
<span class="p_del">-	conf-&gt;pool_size = newsize;</span>
<span class="p_add">+	if (!err)</span>
<span class="p_add">+		conf-&gt;pool_size = newsize;</span>
 	return err;
 }
 
<span class="p_header">diff --git a/drivers/memstick/core/mspro_block.c b/drivers/memstick/core/mspro_block.c</span>
<span class="p_header">index 9729b92..f8449d5 100644</span>
<span class="p_header">--- a/drivers/memstick/core/mspro_block.c</span>
<span class="p_header">+++ b/drivers/memstick/core/mspro_block.c</span>
<span class="p_chunk">@@ -760,7 +760,7 @@</span> <span class="p_context"> static int mspro_block_complete_req(struct memstick_dev *card, int error)</span>
 
 		if (error || (card-&gt;current_mrq.tpc == MSPRO_CMD_STOP)) {
 			if (msb-&gt;data_dir == READ) {
<span class="p_del">-				for (cnt = 0; cnt &lt; msb-&gt;current_seg; cnt++)</span>
<span class="p_add">+				for (cnt = 0; cnt &lt; msb-&gt;current_seg; cnt++) {</span>
 					t_len += msb-&gt;req_sg[cnt].length
 						 / msb-&gt;page_size;
 
<span class="p_chunk">@@ -768,6 +768,7 @@</span> <span class="p_context"> static int mspro_block_complete_req(struct memstick_dev *card, int error)</span>
 						t_len += msb-&gt;current_page - 1;
 
 					t_len *= msb-&gt;page_size;
<span class="p_add">+				}</span>
 			}
 		} else
 			t_len = blk_rq_bytes(msb-&gt;block_req);
<span class="p_header">diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c</span>
<span class="p_header">index ba821fe..eef1261 100644</span>
<span class="p_header">--- a/drivers/mmc/core/core.c</span>
<span class="p_header">+++ b/drivers/mmc/core/core.c</span>
<span class="p_chunk">@@ -2370,6 +2370,7 @@</span> <span class="p_context"> int mmc_pm_notify(struct notifier_block *notify_block,</span>
 	switch (mode) {
 	case PM_HIBERNATION_PREPARE:
 	case PM_SUSPEND_PREPARE:
<span class="p_add">+	case PM_RESTORE_PREPARE:</span>
 
 		spin_lock_irqsave(&amp;host-&gt;lock, flags);
 		host-&gt;rescan_disable = 1;
<span class="p_header">diff --git a/drivers/mmc/host/atmel-mci.c b/drivers/mmc/host/atmel-mci.c</span>
<span class="p_header">index e6f08d9..c300cc4 100644</span>
<span class="p_header">--- a/drivers/mmc/host/atmel-mci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/atmel-mci.c</span>
<span class="p_chunk">@@ -1125,7 +1125,7 @@</span> <span class="p_context"> static void atmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)</span>
 
 	if (ios-&gt;clock) {
 		unsigned int clock_min = ~0U;
<span class="p_del">-		u32 clkdiv;</span>
<span class="p_add">+		int clkdiv;</span>
 
 		spin_lock_bh(&amp;host-&gt;lock);
 		if (!host-&gt;mode_reg) {
<span class="p_chunk">@@ -1150,7 +1150,12 @@</span> <span class="p_context"> static void atmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)</span>
 		/* Calculate clock divider */
 		if (host-&gt;caps.has_odd_clk_div) {
 			clkdiv = DIV_ROUND_UP(host-&gt;bus_hz, clock_min) - 2;
<span class="p_del">-			if (clkdiv &gt; 511) {</span>
<span class="p_add">+			if (clkdiv &lt; 0) {</span>
<span class="p_add">+				dev_warn(&amp;mmc-&gt;class_dev,</span>
<span class="p_add">+					 &quot;clock %u too fast; using %lu\n&quot;,</span>
<span class="p_add">+					 clock_min, host-&gt;bus_hz / 2);</span>
<span class="p_add">+				clkdiv = 0;</span>
<span class="p_add">+			} else if (clkdiv &gt; 511) {</span>
 				dev_warn(&amp;mmc-&gt;class_dev,
 				         &quot;clock %u too slow; using %lu\n&quot;,
 				         clock_min, host-&gt;bus_hz / (511 + 2));
<span class="p_header">diff --git a/drivers/mtd/ubi/cdev.c b/drivers/mtd/ubi/cdev.c</span>
<span class="p_header">index ad76592..7ac2c05 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/cdev.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/cdev.c</span>
<span class="p_chunk">@@ -475,7 +475,7 @@</span> <span class="p_context"> static long vol_cdev_ioctl(struct file *file, unsigned int cmd,</span>
 		/* Validate the request */
 		err = -EINVAL;
 		if (req.lnum &lt; 0 || req.lnum &gt;= vol-&gt;reserved_pebs ||
<span class="p_del">-		    req.bytes &lt; 0 || req.lnum &gt;= vol-&gt;usable_leb_size)</span>
<span class="p_add">+		    req.bytes &lt; 0 || req.bytes &gt; vol-&gt;usable_leb_size)</span>
 			break;
 		if (req.dtype != UBI_LONGTERM &amp;&amp; req.dtype != UBI_SHORTTERM &amp;&amp;
 		    req.dtype != UBI_UNKNOWN)
<span class="p_header">diff --git a/drivers/mtd/ubi/eba.c b/drivers/mtd/ubi/eba.c</span>
<span class="p_header">index 2455d62..9abc0ea 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/eba.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/eba.c</span>
<span class="p_chunk">@@ -1261,7 +1261,8 @@</span> <span class="p_context"> int ubi_eba_init_scan(struct ubi_device *ubi, struct ubi_scan_info *si)</span>
 				 * during re-size.
 				 */
 				ubi_scan_move_to_list(sv, seb, &amp;si-&gt;erase);
<span class="p_del">-			vol-&gt;eba_tbl[seb-&gt;lnum] = seb-&gt;pnum;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				vol-&gt;eba_tbl[seb-&gt;lnum] = seb-&gt;pnum;</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/mtd/ubi/wl.c b/drivers/mtd/ubi/wl.c</span>
<span class="p_header">index 7c1a9bf..284d144 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/wl.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/wl.c</span>
<span class="p_chunk">@@ -666,7 +666,7 @@</span> <span class="p_context"> static int wear_leveling_worker(struct ubi_device *ubi, struct ubi_work *wrk,</span>
 				int cancel)
 {
 	int err, scrubbing = 0, torture = 0, protect = 0, erroneous = 0;
<span class="p_del">-	int vol_id = -1, uninitialized_var(lnum);</span>
<span class="p_add">+	int vol_id = -1, lnum = -1;</span>
 	struct ubi_wl_entry *e1, *e2;
 	struct ubi_vid_hdr *vid_hdr;
 
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000/e1000_main.c b/drivers/net/ethernet/intel/e1000/e1000_main.c</span>
<span class="p_header">index 8d8908d..b7a7524 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000/e1000_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000/e1000_main.c</span>
<span class="p_chunk">@@ -144,6 +144,11 @@</span> <span class="p_context"> static bool e1000_clean_rx_irq(struct e1000_adapter *adapter,</span>
 static bool e1000_clean_jumbo_rx_irq(struct e1000_adapter *adapter,
 				     struct e1000_rx_ring *rx_ring,
 				     int *work_done, int work_to_do);
<span class="p_add">+static void e1000_alloc_dummy_rx_buffers(struct e1000_adapter *adapter,</span>
<span class="p_add">+					 struct e1000_rx_ring *rx_ring,</span>
<span class="p_add">+					 int cleaned_count)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
 static void e1000_alloc_rx_buffers(struct e1000_adapter *adapter,
 				   struct e1000_rx_ring *rx_ring,
 				   int cleaned_count);
<span class="p_chunk">@@ -3545,8 +3550,11 @@</span> <span class="p_context"> static int e1000_change_mtu(struct net_device *netdev, int new_mtu)</span>
 		msleep(1);
 	/* e1000_down has a dependency on max_frame_size */
 	hw-&gt;max_frame_size = max_frame;
<span class="p_del">-	if (netif_running(netdev))</span>
<span class="p_add">+	if (netif_running(netdev)) {</span>
<span class="p_add">+		/* prevent buffers from being reallocated */</span>
<span class="p_add">+		adapter-&gt;alloc_rx_buf = e1000_alloc_dummy_rx_buffers;</span>
 		e1000_down(adapter);
<span class="p_add">+	}</span>
 
 	/* NOTE: netdev_alloc_skb reserves 16 bytes, and typically NET_IP_ALIGN
 	 * means we reserve 2 more, this pushes us to allocate from the next
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_header">index 2c4cdce..091c85f 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_chunk">@@ -357,6 +357,7 @@</span> <span class="p_context"> static struct usb_device_id rtl8192c_usb_ids[] = {</span>
 	{RTL_USB_DEVICE(0x2001, 0x3307, rtl92cu_hal_cfg)}, /*D-Link-Cameo*/
 	{RTL_USB_DEVICE(0x2001, 0x3309, rtl92cu_hal_cfg)}, /*D-Link-Alpha*/
 	{RTL_USB_DEVICE(0x2001, 0x330a, rtl92cu_hal_cfg)}, /*D-Link-Alpha*/
<span class="p_add">+	{RTL_USB_DEVICE(0x2001, 0x330d, rtl92cu_hal_cfg)}, /*D-Link DWA-131 */</span>
 	{RTL_USB_DEVICE(0x2019, 0xab2b, rtl92cu_hal_cfg)}, /*Planex -Abocom*/
 	{RTL_USB_DEVICE(0x20f4, 0x624d, rtl92cu_hal_cfg)}, /*TRENDNet*/
 	{RTL_USB_DEVICE(0x2357, 0x0100, rtl92cu_hal_cfg)}, /*TP-Link WN8200ND*/
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/usb.c b/drivers/net/wireless/rtlwifi/usb.c</span>
<span class="p_header">index 2b6faa0..9b6cb58 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/usb.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/usb.c</span>
<span class="p_chunk">@@ -119,7 +119,7 @@</span> <span class="p_context"> static int _usbctrl_vendorreq_sync_read(struct usb_device *udev, u8 request,</span>
 
 	do {
 		status = usb_control_msg(udev, pipe, request, reqtype, value,
<span class="p_del">-					 index, pdata, len, 0); /*max. timeout*/</span>
<span class="p_add">+					 index, pdata, len, 1000);</span>
 		if (status &lt; 0) {
 			/* firmware download is checksumed, don&#39;t retry */
 			if ((value &gt;= FW_8192C_START_ADDRESS &amp;&amp;
<span class="p_header">diff --git a/drivers/platform/x86/compal-laptop.c b/drivers/platform/x86/compal-laptop.c</span>
<span class="p_header">index 1887e2f..6793888 100644</span>
<span class="p_header">--- a/drivers/platform/x86/compal-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/compal-laptop.c</span>
<span class="p_chunk">@@ -1047,7 +1047,13 @@</span> <span class="p_context"> static int __devinit compal_probe(struct platform_device *pdev)</span>
 
 	/* Power supply */
 	initialize_power_supply_data(data);
<span class="p_del">-	power_supply_register(&amp;compal_device-&gt;dev, &amp;data-&gt;psy);</span>
<span class="p_add">+	err = power_supply_register(&amp;compal_device-&gt;dev, &amp;data-&gt;psy);</span>
<span class="p_add">+	if (err &lt; 0) {</span>
<span class="p_add">+		hwmon_device_unregister(data-&gt;hwmon_dev);</span>
<span class="p_add">+		sysfs_remove_group(&amp;pdev-&gt;dev.kobj,</span>
<span class="p_add">+				&amp;compal_attribute_group);</span>
<span class="p_add">+		kfree(data);</span>
<span class="p_add">+	}</span>
 
 	platform_set_drvdata(pdev, data);
 
<span class="p_header">diff --git a/drivers/scsi/3w-9xxx.c b/drivers/scsi/3w-9xxx.c</span>
<span class="p_header">index 3868ab2..fb37df6 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-9xxx.c</span>
<span class="p_header">+++ b/drivers/scsi/3w-9xxx.c</span>
<span class="p_chunk">@@ -149,7 +149,6 @@</span> <span class="p_context"> static int twa_reset_sequence(TW_Device_Extension *tw_dev, int soft_reset);</span>
 static int twa_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id, char *cdb, int use_sg, TW_SG_Entry *sglistarg);
 static void twa_scsiop_execute_scsi_complete(TW_Device_Extension *tw_dev, int request_id);
 static char *twa_string_lookup(twa_message_type *table, unsigned int aen_code);
<span class="p_del">-static void twa_unmap_scsi_data(TW_Device_Extension *tw_dev, int request_id);</span>
 
 /* Functions */
 
<span class="p_chunk">@@ -1352,11 +1351,11 @@</span> <span class="p_context"> static irqreturn_t twa_interrupt(int irq, void *dev_instance)</span>
 				}
 
 				/* Now complete the io */
<span class="p_add">+				scsi_dma_unmap(cmd);</span>
<span class="p_add">+				cmd-&gt;scsi_done(cmd);</span>
 				tw_dev-&gt;state[request_id] = TW_S_COMPLETED;
 				twa_free_request_id(tw_dev, request_id);
 				tw_dev-&gt;posted_request_count--;
<span class="p_del">-				tw_dev-&gt;srb[request_id]-&gt;scsi_done(tw_dev-&gt;srb[request_id]);</span>
<span class="p_del">-				twa_unmap_scsi_data(tw_dev, request_id);</span>
 			}
 
 			/* Check for valid status after each drain */
<span class="p_chunk">@@ -1414,26 +1413,6 @@</span> <span class="p_context"> static void twa_load_sgl(TW_Device_Extension *tw_dev, TW_Command_Full *full_comm</span>
 	}
 } /* End twa_load_sgl() */
 
<span class="p_del">-/* This function will perform a pci-dma mapping for a scatter gather list */</span>
<span class="p_del">-static int twa_map_scsi_sg_data(TW_Device_Extension *tw_dev, int request_id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int use_sg;</span>
<span class="p_del">-	struct scsi_cmnd *cmd = tw_dev-&gt;srb[request_id];</span>
<span class="p_del">-</span>
<span class="p_del">-	use_sg = scsi_dma_map(cmd);</span>
<span class="p_del">-	if (!use_sg)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	else if (use_sg &lt; 0) {</span>
<span class="p_del">-		TW_PRINTK(tw_dev-&gt;host, TW_DRIVER, 0x1c, &quot;Failed to map scatter gather list&quot;);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	cmd-&gt;SCp.phase = TW_PHASE_SGLIST;</span>
<span class="p_del">-	cmd-&gt;SCp.have_data_in = use_sg;</span>
<span class="p_del">-</span>
<span class="p_del">-	return use_sg;</span>
<span class="p_del">-} /* End twa_map_scsi_sg_data() */</span>
<span class="p_del">-</span>
 /* This function will poll for a response interrupt of a request */
 static int twa_poll_response(TW_Device_Extension *tw_dev, int request_id, int seconds)
 {
<span class="p_chunk">@@ -1612,9 +1591,11 @@</span> <span class="p_context"> static int twa_reset_device_extension(TW_Device_Extension *tw_dev)</span>
 		    (tw_dev-&gt;state[i] != TW_S_INITIAL) &amp;&amp;
 		    (tw_dev-&gt;state[i] != TW_S_COMPLETED)) {
 			if (tw_dev-&gt;srb[i]) {
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;result = (DID_RESET &lt;&lt; 16);</span>
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;scsi_done(tw_dev-&gt;srb[i]);</span>
<span class="p_del">-				twa_unmap_scsi_data(tw_dev, i);</span>
<span class="p_add">+				struct scsi_cmnd *cmd = tw_dev-&gt;srb[i];</span>
<span class="p_add">+</span>
<span class="p_add">+				cmd-&gt;result = (DID_RESET &lt;&lt; 16);</span>
<span class="p_add">+				scsi_dma_unmap(cmd);</span>
<span class="p_add">+				cmd-&gt;scsi_done(cmd);</span>
 			}
 		}
 	}
<span class="p_chunk">@@ -1793,21 +1774,18 @@</span> <span class="p_context"> static int twa_scsi_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_</span>
 	/* Save the scsi command for use by the ISR */
 	tw_dev-&gt;srb[request_id] = SCpnt;
 
<span class="p_del">-	/* Initialize phase to zero */</span>
<span class="p_del">-	SCpnt-&gt;SCp.phase = TW_PHASE_INITIAL;</span>
<span class="p_del">-</span>
 	retval = twa_scsiop_execute_scsi(tw_dev, request_id, NULL, 0, NULL);
 	switch (retval) {
 	case SCSI_MLQUEUE_HOST_BUSY:
<span class="p_add">+		scsi_dma_unmap(SCpnt);</span>
 		twa_free_request_id(tw_dev, request_id);
<span class="p_del">-		twa_unmap_scsi_data(tw_dev, request_id);</span>
 		break;
 	case 1:
<span class="p_del">-		tw_dev-&gt;state[request_id] = TW_S_COMPLETED;</span>
<span class="p_del">-		twa_free_request_id(tw_dev, request_id);</span>
<span class="p_del">-		twa_unmap_scsi_data(tw_dev, request_id);</span>
 		SCpnt-&gt;result = (DID_ERROR &lt;&lt; 16);
<span class="p_add">+		scsi_dma_unmap(SCpnt);</span>
 		done(SCpnt);
<span class="p_add">+		tw_dev-&gt;state[request_id] = TW_S_COMPLETED;</span>
<span class="p_add">+		twa_free_request_id(tw_dev, request_id);</span>
 		retval = 0;
 	}
 out:
<span class="p_chunk">@@ -1875,8 +1853,8 @@</span> <span class="p_context"> static int twa_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id,</span>
 				command_packet-&gt;sg_list[0].address = TW_CPU_TO_SGL(tw_dev-&gt;generic_buffer_phys[request_id]);
 				command_packet-&gt;sg_list[0].length = cpu_to_le32(TW_MIN_SGL_LENGTH);
 			} else {
<span class="p_del">-				sg_count = twa_map_scsi_sg_data(tw_dev, request_id);</span>
<span class="p_del">-				if (sg_count == 0)</span>
<span class="p_add">+				sg_count = scsi_dma_map(srb);</span>
<span class="p_add">+				if (sg_count &lt; 0)</span>
 					goto out;
 
 				scsi_for_each_sg(srb, sg, sg_count, i) {
<span class="p_chunk">@@ -1991,15 +1969,6 @@</span> <span class="p_context"> static char *twa_string_lookup(twa_message_type *table, unsigned int code)</span>
 	return(table[index].text);
 } /* End twa_string_lookup() */
 
<span class="p_del">-/* This function will perform a pci-dma unmap */</span>
<span class="p_del">-static void twa_unmap_scsi_data(TW_Device_Extension *tw_dev, int request_id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct scsi_cmnd *cmd = tw_dev-&gt;srb[request_id];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cmd-&gt;SCp.phase == TW_PHASE_SGLIST)</span>
<span class="p_del">-		scsi_dma_unmap(cmd);</span>
<span class="p_del">-} /* End twa_unmap_scsi_data() */</span>
<span class="p_del">-</span>
 /* This function gets called when a disk is coming on-line */
 static int twa_slave_configure(struct scsi_device *sdev)
 {
<span class="p_header">diff --git a/drivers/scsi/3w-9xxx.h b/drivers/scsi/3w-9xxx.h</span>
<span class="p_header">index 040f721..0fdc83c 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-9xxx.h</span>
<span class="p_header">+++ b/drivers/scsi/3w-9xxx.h</span>
<span class="p_chunk">@@ -324,11 +324,6 @@</span> <span class="p_context"> static twa_message_type twa_error_table[] = {</span>
 #define TW_CURRENT_DRIVER_BUILD 0
 #define TW_CURRENT_DRIVER_BRANCH 0
 
<span class="p_del">-/* Phase defines */</span>
<span class="p_del">-#define TW_PHASE_INITIAL 0</span>
<span class="p_del">-#define TW_PHASE_SINGLE  1</span>
<span class="p_del">-#define TW_PHASE_SGLIST  2</span>
<span class="p_del">-</span>
 /* Misc defines */
 #define TW_9550SX_DRAIN_COMPLETED	      0xFFFF
 #define TW_SECTOR_SIZE                        512
<span class="p_header">diff --git a/drivers/scsi/3w-sas.c b/drivers/scsi/3w-sas.c</span>
<span class="p_header">index 13e39e1..c555ccb 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-sas.c</span>
<span class="p_header">+++ b/drivers/scsi/3w-sas.c</span>
<span class="p_chunk">@@ -303,26 +303,6 @@</span> <span class="p_context"> static int twl_post_command_packet(TW_Device_Extension *tw_dev, int request_id)</span>
 	return 0;
 } /* End twl_post_command_packet() */
 
<span class="p_del">-/* This function will perform a pci-dma mapping for a scatter gather list */</span>
<span class="p_del">-static int twl_map_scsi_sg_data(TW_Device_Extension *tw_dev, int request_id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int use_sg;</span>
<span class="p_del">-	struct scsi_cmnd *cmd = tw_dev-&gt;srb[request_id];</span>
<span class="p_del">-</span>
<span class="p_del">-	use_sg = scsi_dma_map(cmd);</span>
<span class="p_del">-	if (!use_sg)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	else if (use_sg &lt; 0) {</span>
<span class="p_del">-		TW_PRINTK(tw_dev-&gt;host, TW_DRIVER, 0x1, &quot;Failed to map scatter gather list&quot;);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	cmd-&gt;SCp.phase = TW_PHASE_SGLIST;</span>
<span class="p_del">-	cmd-&gt;SCp.have_data_in = use_sg;</span>
<span class="p_del">-</span>
<span class="p_del">-	return use_sg;</span>
<span class="p_del">-} /* End twl_map_scsi_sg_data() */</span>
<span class="p_del">-</span>
 /* This function hands scsi cdb&#39;s to the firmware */
 static int twl_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id, char *cdb, int use_sg, TW_SG_Entry_ISO *sglistarg)
 {
<span class="p_chunk">@@ -370,8 +350,8 @@</span> <span class="p_context"> static int twl_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id,</span>
 	if (!sglistarg) {
 		/* Map sglist from scsi layer to cmd packet */
 		if (scsi_sg_count(srb)) {
<span class="p_del">-			sg_count = twl_map_scsi_sg_data(tw_dev, request_id);</span>
<span class="p_del">-			if (sg_count == 0)</span>
<span class="p_add">+			sg_count = scsi_dma_map(srb);</span>
<span class="p_add">+			if (sg_count &lt;= 0)</span>
 				goto out;
 
 			scsi_for_each_sg(srb, sg, sg_count, i) {
<span class="p_chunk">@@ -1116,15 +1096,6 @@</span> <span class="p_context"> out:</span>
 	return retval;
 } /* End twl_initialize_device_extension() */
 
<span class="p_del">-/* This function will perform a pci-dma unmap */</span>
<span class="p_del">-static void twl_unmap_scsi_data(TW_Device_Extension *tw_dev, int request_id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct scsi_cmnd *cmd = tw_dev-&gt;srb[request_id];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cmd-&gt;SCp.phase == TW_PHASE_SGLIST)</span>
<span class="p_del">-		scsi_dma_unmap(cmd);</span>
<span class="p_del">-} /* End twl_unmap_scsi_data() */</span>
<span class="p_del">-</span>
 /* This function will handle attention interrupts */
 static int twl_handle_attention_interrupt(TW_Device_Extension *tw_dev)
 {
<span class="p_chunk">@@ -1265,11 +1236,11 @@</span> <span class="p_context"> static irqreturn_t twl_interrupt(int irq, void *dev_instance)</span>
 			}
 
 			/* Now complete the io */
<span class="p_add">+			scsi_dma_unmap(cmd);</span>
<span class="p_add">+			cmd-&gt;scsi_done(cmd);</span>
 			tw_dev-&gt;state[request_id] = TW_S_COMPLETED;
 			twl_free_request_id(tw_dev, request_id);
 			tw_dev-&gt;posted_request_count--;
<span class="p_del">-			tw_dev-&gt;srb[request_id]-&gt;scsi_done(tw_dev-&gt;srb[request_id]);</span>
<span class="p_del">-			twl_unmap_scsi_data(tw_dev, request_id);</span>
 		}
 
 		/* Check for another response interrupt */
<span class="p_chunk">@@ -1414,10 +1385,12 @@</span> <span class="p_context"> static int twl_reset_device_extension(TW_Device_Extension *tw_dev, int ioctl_res</span>
 		if ((tw_dev-&gt;state[i] != TW_S_FINISHED) &amp;&amp;
 		    (tw_dev-&gt;state[i] != TW_S_INITIAL) &amp;&amp;
 		    (tw_dev-&gt;state[i] != TW_S_COMPLETED)) {
<span class="p_del">-			if (tw_dev-&gt;srb[i]) {</span>
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;result = (DID_RESET &lt;&lt; 16);</span>
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;scsi_done(tw_dev-&gt;srb[i]);</span>
<span class="p_del">-				twl_unmap_scsi_data(tw_dev, i);</span>
<span class="p_add">+			struct scsi_cmnd *cmd = tw_dev-&gt;srb[i];</span>
<span class="p_add">+</span>
<span class="p_add">+			if (cmd) {</span>
<span class="p_add">+				cmd-&gt;result = (DID_RESET &lt;&lt; 16);</span>
<span class="p_add">+				scsi_dma_unmap(cmd);</span>
<span class="p_add">+				cmd-&gt;scsi_done(cmd);</span>
 			}
 		}
 	}
<span class="p_chunk">@@ -1521,9 +1494,6 @@</span> <span class="p_context"> static int twl_scsi_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_</span>
 	/* Save the scsi command for use by the ISR */
 	tw_dev-&gt;srb[request_id] = SCpnt;
 
<span class="p_del">-	/* Initialize phase to zero */</span>
<span class="p_del">-	SCpnt-&gt;SCp.phase = TW_PHASE_INITIAL;</span>
<span class="p_del">-</span>
 	retval = twl_scsiop_execute_scsi(tw_dev, request_id, NULL, 0, NULL);
 	if (retval) {
 		tw_dev-&gt;state[request_id] = TW_S_COMPLETED;
<span class="p_header">diff --git a/drivers/scsi/3w-sas.h b/drivers/scsi/3w-sas.h</span>
<span class="p_header">index d474892..fec6449 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-sas.h</span>
<span class="p_header">+++ b/drivers/scsi/3w-sas.h</span>
<span class="p_chunk">@@ -103,10 +103,6 @@</span> <span class="p_context"> static char *twl_aen_severity_table[] =</span>
 #define TW_CURRENT_DRIVER_BUILD 0
 #define TW_CURRENT_DRIVER_BRANCH 0
 
<span class="p_del">-/* Phase defines */</span>
<span class="p_del">-#define TW_PHASE_INITIAL 0</span>
<span class="p_del">-#define TW_PHASE_SGLIST  2</span>
<span class="p_del">-</span>
 /* Misc defines */
 #define TW_SECTOR_SIZE                        512
 #define TW_MAX_UNITS			      32
<span class="p_header">diff --git a/drivers/scsi/3w-xxxx.c b/drivers/scsi/3w-xxxx.c</span>
<span class="p_header">index 7fe96ff..86bc5f9 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-xxxx.c</span>
<span class="p_header">+++ b/drivers/scsi/3w-xxxx.c</span>
<span class="p_chunk">@@ -1283,32 +1283,6 @@</span> <span class="p_context"> static int tw_initialize_device_extension(TW_Device_Extension *tw_dev)</span>
 	return 0;
 } /* End tw_initialize_device_extension() */
 
<span class="p_del">-static int tw_map_scsi_sg_data(struct pci_dev *pdev, struct scsi_cmnd *cmd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int use_sg;</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintk(KERN_WARNING &quot;3w-xxxx: tw_map_scsi_sg_data()\n&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	use_sg = scsi_dma_map(cmd);</span>
<span class="p_del">-	if (use_sg &lt; 0) {</span>
<span class="p_del">-		printk(KERN_WARNING &quot;3w-xxxx: tw_map_scsi_sg_data(): pci_map_sg() failed.\n&quot;);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	cmd-&gt;SCp.phase = TW_PHASE_SGLIST;</span>
<span class="p_del">-	cmd-&gt;SCp.have_data_in = use_sg;</span>
<span class="p_del">-</span>
<span class="p_del">-	return use_sg;</span>
<span class="p_del">-} /* End tw_map_scsi_sg_data() */</span>
<span class="p_del">-</span>
<span class="p_del">-static void tw_unmap_scsi_data(struct pci_dev *pdev, struct scsi_cmnd *cmd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	dprintk(KERN_WARNING &quot;3w-xxxx: tw_unmap_scsi_data()\n&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cmd-&gt;SCp.phase == TW_PHASE_SGLIST)</span>
<span class="p_del">-		scsi_dma_unmap(cmd);</span>
<span class="p_del">-} /* End tw_unmap_scsi_data() */</span>
<span class="p_del">-</span>
 /* This function will reset a device extension */
 static int tw_reset_device_extension(TW_Device_Extension *tw_dev)
 {
<span class="p_chunk">@@ -1331,8 +1305,8 @@</span> <span class="p_context"> static int tw_reset_device_extension(TW_Device_Extension *tw_dev)</span>
 			srb = tw_dev-&gt;srb[i];
 			if (srb != NULL) {
 				srb-&gt;result = (DID_RESET &lt;&lt; 16);
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;scsi_done(tw_dev-&gt;srb[i]);</span>
<span class="p_del">-				tw_unmap_scsi_data(tw_dev-&gt;tw_pci_dev, tw_dev-&gt;srb[i]);</span>
<span class="p_add">+				scsi_dma_unmap(srb);</span>
<span class="p_add">+				srb-&gt;scsi_done(srb);</span>
 			}
 		}
 	}
<span class="p_chunk">@@ -1779,8 +1753,8 @@</span> <span class="p_context"> static int tw_scsiop_read_write(TW_Device_Extension *tw_dev, int request_id)</span>
 	command_packet-&gt;byte8.io.lba = lba;
 	command_packet-&gt;byte6.block_count = num_sectors;
 
<span class="p_del">-	use_sg = tw_map_scsi_sg_data(tw_dev-&gt;tw_pci_dev, tw_dev-&gt;srb[request_id]);</span>
<span class="p_del">-	if (!use_sg)</span>
<span class="p_add">+	use_sg = scsi_dma_map(srb);</span>
<span class="p_add">+	if (use_sg &lt;= 0)</span>
 		return 1;
 
 	scsi_for_each_sg(tw_dev-&gt;srb[request_id], sg, use_sg, i) {
<span class="p_chunk">@@ -1967,9 +1941,6 @@</span> <span class="p_context"> static int tw_scsi_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_c</span>
 	/* Save the scsi command for use by the ISR */
 	tw_dev-&gt;srb[request_id] = SCpnt;
 
<span class="p_del">-	/* Initialize phase to zero */</span>
<span class="p_del">-	SCpnt-&gt;SCp.phase = TW_PHASE_INITIAL;</span>
<span class="p_del">-</span>
 	switch (*command) {
 		case READ_10:
 		case READ_6:
<span class="p_chunk">@@ -2196,12 +2167,11 @@</span> <span class="p_context"> static irqreturn_t tw_interrupt(int irq, void *dev_instance)</span>
 
 				/* Now complete the io */
 				if ((error != TW_ISR_DONT_COMPLETE)) {
<span class="p_add">+					scsi_dma_unmap(tw_dev-&gt;srb[request_id]);</span>
<span class="p_add">+					tw_dev-&gt;srb[request_id]-&gt;scsi_done(tw_dev-&gt;srb[request_id]);</span>
 					tw_dev-&gt;state[request_id] = TW_S_COMPLETED;
 					tw_state_request_finish(tw_dev, request_id);
 					tw_dev-&gt;posted_request_count--;
<span class="p_del">-					tw_dev-&gt;srb[request_id]-&gt;scsi_done(tw_dev-&gt;srb[request_id]);</span>
<span class="p_del">-					</span>
<span class="p_del">-					tw_unmap_scsi_data(tw_dev-&gt;tw_pci_dev, tw_dev-&gt;srb[request_id]);</span>
 				}
 			}
 				
<span class="p_header">diff --git a/drivers/scsi/3w-xxxx.h b/drivers/scsi/3w-xxxx.h</span>
<span class="p_header">index 49dcf03..1d31858 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-xxxx.h</span>
<span class="p_header">+++ b/drivers/scsi/3w-xxxx.h</span>
<span class="p_chunk">@@ -195,11 +195,6 @@</span> <span class="p_context"> static unsigned char tw_sense_table[][4] =</span>
 #define TW_AEN_SMART_FAIL        0x000F
 #define TW_AEN_SBUF_FAIL         0x0024
 
<span class="p_del">-/* Phase defines */</span>
<span class="p_del">-#define TW_PHASE_INITIAL 0</span>
<span class="p_del">-#define TW_PHASE_SINGLE 1</span>
<span class="p_del">-#define TW_PHASE_SGLIST 2</span>
<span class="p_del">-</span>
 /* Misc defines */
 #define TW_ALIGNMENT_6000		      64 /* 64 bytes */
 #define TW_ALIGNMENT_7000                     4  /* 4 bytes */
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_fusion.c b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">index bfd87fa..3e0f71c 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_chunk">@@ -1426,11 +1426,11 @@</span> <span class="p_context"> megasas_build_ldio_fusion(struct megasas_instance *instance,</span>
 			fp_possible = io_info.fpOkForIo;
 	}
 
<span class="p_del">-	/* Use smp_processor_id() for now until cmd-&gt;request-&gt;cpu is CPU</span>
<span class="p_add">+	/* Use raw_smp_processor_id() for now until cmd-&gt;request-&gt;cpu is CPU</span>
 	   id by default, not CPU group id, otherwise all MSI-X queues won&#39;t
 	   be utilized */
 	cmd-&gt;request_desc-&gt;SCSIIO.MSIxIndex = instance-&gt;msix_vectors ?
<span class="p_del">-		smp_processor_id() % instance-&gt;msix_vectors : 0;</span>
<span class="p_add">+		raw_smp_processor_id() % instance-&gt;msix_vectors : 0;</span>
 
 	if (fp_possible) {
 		megasas_set_pd_lba(io_request, scp-&gt;cmd_len, &amp;io_info, scp,
<span class="p_header">diff --git a/drivers/scsi/scsi_devinfo.c b/drivers/scsi/scsi_devinfo.c</span>
<span class="p_header">index cf8dfab..28a635c 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_devinfo.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_devinfo.c</span>
<span class="p_chunk">@@ -222,6 +222,7 @@</span> <span class="p_context"> static struct {</span>
 	{&quot;PIONEER&quot;, &quot;CD-ROM DRM-604X&quot;, NULL, BLIST_FORCELUN | BLIST_SINGLELUN},
 	{&quot;PIONEER&quot;, &quot;CD-ROM DRM-624X&quot;, NULL, BLIST_FORCELUN | BLIST_SINGLELUN},
 	{&quot;Promise&quot;, &quot;&quot;, NULL, BLIST_SPARSELUN},
<span class="p_add">+	{&quot;QNAP&quot;, &quot;iSCSI Storage&quot;, NULL, BLIST_MAX_1024},</span>
 	{&quot;QUANTUM&quot;, &quot;XP34301&quot;, &quot;1071&quot;, BLIST_NOTQ},
 	{&quot;REGAL&quot;, &quot;CDC-4X&quot;, NULL, BLIST_MAX5LUN | BLIST_SINGLELUN},
 	{&quot;SanDisk&quot;, &quot;ImageMate CF-SD1&quot;, NULL, BLIST_FORCELUN},
<span class="p_header">diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c</span>
<span class="p_header">index 348840e..37abf4f 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_scan.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_scan.c</span>
<span class="p_chunk">@@ -888,6 +888,12 @@</span> <span class="p_context"> static int scsi_add_lun(struct scsi_device *sdev, unsigned char *inq_result,</span>
 	 */
 	if (*bflags &amp; BLIST_MAX_512)
 		blk_queue_max_hw_sectors(sdev-&gt;request_queue, 512);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Max 1024 sector transfer length for targets that report incorrect</span>
<span class="p_add">+	 * max/optimal lengths and relied on the old block layer safe default</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	else if (*bflags &amp; BLIST_MAX_1024)</span>
<span class="p_add">+		blk_queue_max_hw_sectors(sdev-&gt;request_queue, 1024);</span>
 
 	/*
 	 * Some devices may not want to have a start command automatically
<span class="p_header">diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c</span>
<span class="p_header">index 7f6746a..97aa6c6 100644</span>
<span class="p_header">--- a/drivers/scsi/sd.c</span>
<span class="p_header">+++ b/drivers/scsi/sd.c</span>
<span class="p_chunk">@@ -1423,6 +1423,7 @@</span> <span class="p_context"> static unsigned int sd_completed_bytes(struct scsi_cmnd *scmd)</span>
 {
 	u64 start_lba = blk_rq_pos(scmd-&gt;request);
 	u64 end_lba = blk_rq_pos(scmd-&gt;request) + (scsi_bufflen(scmd) / 512);
<span class="p_add">+	u64 factor = scmd-&gt;device-&gt;sector_size / 512;</span>
 	u64 bad_lba;
 	int info_valid;
 	/*
<span class="p_chunk">@@ -1444,16 +1445,10 @@</span> <span class="p_context"> static unsigned int sd_completed_bytes(struct scsi_cmnd *scmd)</span>
 	if (scsi_bufflen(scmd) &lt;= scmd-&gt;device-&gt;sector_size)
 		return 0;
 
<span class="p_del">-	if (scmd-&gt;device-&gt;sector_size &lt; 512) {</span>
<span class="p_del">-		/* only legitimate sector_size here is 256 */</span>
<span class="p_del">-		start_lba &lt;&lt;= 1;</span>
<span class="p_del">-		end_lba &lt;&lt;= 1;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		/* be careful ... don&#39;t want any overflows */</span>
<span class="p_del">-		u64 factor = scmd-&gt;device-&gt;sector_size / 512;</span>
<span class="p_del">-		do_div(start_lba, factor);</span>
<span class="p_del">-		do_div(end_lba, factor);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* be careful ... don&#39;t want any overflows */</span>
<span class="p_add">+	factor = scmd-&gt;device-&gt;sector_size / 512;</span>
<span class="p_add">+	do_div(start_lba, factor);</span>
<span class="p_add">+	do_div(end_lba, factor);</span>
 
 	/* The bad lba was reported incorrectly, we have no idea where
 	 * the error is.
<span class="p_chunk">@@ -1984,8 +1979,7 @@</span> <span class="p_context"> got_data:</span>
 	if (sector_size != 512 &amp;&amp;
 	    sector_size != 1024 &amp;&amp;
 	    sector_size != 2048 &amp;&amp;
<span class="p_del">-	    sector_size != 4096 &amp;&amp;</span>
<span class="p_del">-	    sector_size != 256) {</span>
<span class="p_add">+	    sector_size != 4096) {</span>
 		sd_printk(KERN_NOTICE, sdkp, &quot;Unsupported sector size %d.\n&quot;,
 			  sector_size);
 		/*
<span class="p_chunk">@@ -2034,8 +2028,6 @@</span> <span class="p_context"> got_data:</span>
 		sdkp-&gt;capacity &lt;&lt;= 2;
 	else if (sector_size == 1024)
 		sdkp-&gt;capacity &lt;&lt;= 1;
<span class="p_del">-	else if (sector_size == 256)</span>
<span class="p_del">-		sdkp-&gt;capacity &gt;&gt;= 1;</span>
 
 	blk_queue_physical_block_size(sdp-&gt;request_queue,
 				      sdkp-&gt;physical_block_size);
<span class="p_header">diff --git a/drivers/scsi/storvsc_drv.c b/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">index a0df0fb..4ae7769 100644</span>
<span class="p_header">--- a/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">+++ b/drivers/scsi/storvsc_drv.c</span>
<span class="p_chunk">@@ -610,21 +610,22 @@</span> <span class="p_context"> static unsigned int copy_to_bounce_buffer(struct scatterlist *orig_sgl,</span>
 			if (bounce_sgl[j].length == PAGE_SIZE) {
 				/* full..move to next entry */
 				sg_kunmap_atomic(bounce_addr);
<span class="p_add">+				bounce_addr = 0;</span>
 				j++;
<span class="p_add">+			}</span>
 
<span class="p_del">-				/* if we need to use another bounce buffer */</span>
<span class="p_del">-				if (srclen || i != orig_sgl_count - 1)</span>
<span class="p_del">-					bounce_addr = sg_kmap_atomic(bounce_sgl,j);</span>
<span class="p_add">+			/* if we need to use another bounce buffer */</span>
<span class="p_add">+			if (srclen &amp;&amp; bounce_addr == 0)</span>
<span class="p_add">+				bounce_addr = sg_kmap_atomic(bounce_sgl, j);</span>
 
<span class="p_del">-			} else if (srclen == 0 &amp;&amp; i == orig_sgl_count - 1) {</span>
<span class="p_del">-				/* unmap the last bounce that is &lt; PAGE_SIZE */</span>
<span class="p_del">-				sg_kunmap_atomic(bounce_addr);</span>
<span class="p_del">-			}</span>
 		}
 
 		sg_kunmap_atomic(src_addr - orig_sgl[i].offset);
 	}
 
<span class="p_add">+	if (bounce_addr)</span>
<span class="p_add">+		sg_kunmap_atomic(bounce_addr);</span>
<span class="p_add">+</span>
 	local_irq_restore(flags);
 
 	return total_copied;
<span class="p_header">diff --git a/drivers/staging/ozwpan/ozusbsvc1.c b/drivers/staging/ozwpan/ozusbsvc1.c</span>
<span class="p_header">index 66bd576..ca61576 100644</span>
<span class="p_header">--- a/drivers/staging/ozwpan/ozusbsvc1.c</span>
<span class="p_header">+++ b/drivers/staging/ozwpan/ozusbsvc1.c</span>
<span class="p_chunk">@@ -314,7 +314,11 @@</span> <span class="p_context"> void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,</span>
 			struct oz_multiple_fixed *body =
 				(struct oz_multiple_fixed *)data_hdr;
 			u8 *data = body-&gt;data;
<span class="p_del">-			int n = (len - sizeof(struct oz_multiple_fixed)+1)</span>
<span class="p_add">+			unsigned int n;</span>
<span class="p_add">+			if (!body-&gt;unit_size ||</span>
<span class="p_add">+				len &lt; sizeof(struct oz_multiple_fixed) - 1)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			n = (len - (sizeof(struct oz_multiple_fixed) - 1))</span>
 				/ body-&gt;unit_size;
 			while (n--) {
 				oz_hcd_data_ind(usb_ctx-&gt;hport, body-&gt;endpoint,
<span class="p_chunk">@@ -376,10 +380,15 @@</span> <span class="p_context"> void oz_usb_rx(struct oz_pd *pd, struct oz_elt *elt)</span>
 	case OZ_GET_DESC_RSP: {
 			struct oz_get_desc_rsp *body =
 				(struct oz_get_desc_rsp *)usb_hdr;
<span class="p_del">-			int data_len = elt-&gt;length -</span>
<span class="p_del">-					sizeof(struct oz_get_desc_rsp) + 1;</span>
<span class="p_del">-			u16 offs = le16_to_cpu(get_unaligned(&amp;body-&gt;offset));</span>
<span class="p_del">-			u16 total_size =</span>
<span class="p_add">+			u16 offs, total_size;</span>
<span class="p_add">+			u8 data_len;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (elt-&gt;length &lt; sizeof(struct oz_get_desc_rsp) - 1)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			data_len = elt-&gt;length -</span>
<span class="p_add">+					(sizeof(struct oz_get_desc_rsp) - 1);</span>
<span class="p_add">+			offs = le16_to_cpu(get_unaligned(&amp;body-&gt;offset));</span>
<span class="p_add">+			total_size =</span>
 				le16_to_cpu(get_unaligned(&amp;body-&gt;total_size));
 			oz_trace(&quot;USB_REQ_GET_DESCRIPTOR - cnf\n&quot;);
 			oz_hcd_get_desc_cnf(usb_ctx-&gt;hport, body-&gt;req_id,
<span class="p_header">diff --git a/drivers/staging/panel/panel.c b/drivers/staging/panel/panel.c</span>
<span class="p_header">index 6183573..5d4b4f07 100644</span>
<span class="p_header">--- a/drivers/staging/panel/panel.c</span>
<span class="p_header">+++ b/drivers/staging/panel/panel.c</span>
<span class="p_chunk">@@ -273,11 +273,11 @@</span> <span class="p_context"> static unsigned char lcd_bits[LCD_PORTS][LCD_BITS][BIT_STATES];</span>
  * LCD types
  */
 #define LCD_TYPE_NONE		0
<span class="p_del">-#define LCD_TYPE_OLD		1</span>
<span class="p_del">-#define LCD_TYPE_KS0074		2</span>
<span class="p_del">-#define LCD_TYPE_HANTRONIX	3</span>
<span class="p_del">-#define LCD_TYPE_NEXCOM		4</span>
<span class="p_del">-#define LCD_TYPE_CUSTOM		5</span>
<span class="p_add">+#define LCD_TYPE_CUSTOM		1</span>
<span class="p_add">+#define LCD_TYPE_OLD		2</span>
<span class="p_add">+#define LCD_TYPE_KS0074		3</span>
<span class="p_add">+#define LCD_TYPE_HANTRONIX	4</span>
<span class="p_add">+#define LCD_TYPE_NEXCOM		5</span>
 
 /*
  * keypad types
<span class="p_chunk">@@ -455,8 +455,7 @@</span> <span class="p_context"> MODULE_PARM_DESC(keypad_enabled, &quot;Deprecated option, use keypad_type instead&quot;);</span>
 static int lcd_type = -1;
 module_param(lcd_type, int, 0000);
 MODULE_PARM_DESC(lcd_type,
<span class="p_del">-		 &quot;LCD type: 0=none, 1=old //, 2=serial ks0074, &quot;</span>
<span class="p_del">-		 &quot;3=hantronix //, 4=nexcom //, 5=compiled-in&quot;);</span>
<span class="p_add">+		 &quot;LCD type: 0=none, 1=compiled-in, 2=old, 3=serial ks0074, 4=hantronix, 5=nexcom&quot;);</span>
 
 static int lcd_proto = -1;
 module_param(lcd_proto, int, 0000);
<span class="p_header">diff --git a/drivers/target/target_core_pscsi.c b/drivers/target/target_core_pscsi.c</span>
<span class="p_header">index 8082674..ec7e71c 100644</span>
<span class="p_header">--- a/drivers/target/target_core_pscsi.c</span>
<span class="p_header">+++ b/drivers/target/target_core_pscsi.c</span>
<span class="p_chunk">@@ -567,6 +567,7 @@</span> <span class="p_context"> static struct se_device *pscsi_create_virtdevice(</span>
 					&quot; pdv_host_id: %d\n&quot;, pdv-&gt;pdv_host_id);
 				return ERR_PTR(-EINVAL);
 			}
<span class="p_add">+			pdv-&gt;pdv_lld_host = sh;</span>
 		}
 	} else {
 		if (phv-&gt;phv_mode == PHV_VIRTUAL_HOST_ID) {
<span class="p_chunk">@@ -653,6 +654,8 @@</span> <span class="p_context"> static void pscsi_free_device(void *p)</span>
 		if ((phv-&gt;phv_mode == PHV_LLD_SCSI_HOST_NO) &amp;&amp;
 		    (phv-&gt;phv_lld_host != NULL))
 			scsi_host_put(phv-&gt;phv_lld_host);
<span class="p_add">+		else if (pdv-&gt;pdv_lld_host)</span>
<span class="p_add">+			scsi_host_put(pdv-&gt;pdv_lld_host);</span>
 
 		if ((sd-&gt;type == TYPE_DISK) || (sd-&gt;type == TYPE_ROM))
 			scsi_device_put(sd);
<span class="p_header">diff --git a/drivers/target/target_core_pscsi.h b/drivers/target/target_core_pscsi.h</span>
<span class="p_header">index 43f1c41..6c23c94 100644</span>
<span class="p_header">--- a/drivers/target/target_core_pscsi.h</span>
<span class="p_header">+++ b/drivers/target/target_core_pscsi.h</span>
<span class="p_chunk">@@ -45,6 +45,7 @@</span> <span class="p_context"> struct pscsi_dev_virt {</span>
 	int	pdv_lun_id;
 	struct block_device *pdv_bd;
 	struct scsi_device *pdv_sd;
<span class="p_add">+	struct Scsi_Host *pdv_lld_host;</span>
 	struct se_hba *pdv_se_hba;
 } ____cacheline_aligned;
 
<span class="p_header">diff --git a/drivers/tty/hvc/hvc_xen.c b/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_header">index 944eaeb..160b1f3 100644</span>
<span class="p_header">--- a/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_header">+++ b/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_chunk">@@ -290,7 +290,7 @@</span> <span class="p_context"> static int xen_initial_domain_console_init(void)</span>
 			return -ENOMEM;
 	}
 
<span class="p_del">-	info-&gt;irq = bind_virq_to_irq(VIRQ_CONSOLE, 0);</span>
<span class="p_add">+	info-&gt;irq = bind_virq_to_irq(VIRQ_CONSOLE, 0, false);</span>
 	info-&gt;vtermno = HVC_COOKIE;
 
 	spin_lock(&amp;xencons_lock);
<span class="p_chunk">@@ -300,11 +300,27 @@</span> <span class="p_context"> static int xen_initial_domain_console_init(void)</span>
 	return 0;
 }
 
<span class="p_add">+static void xen_console_update_evtchn(struct xencons_info *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (xen_hvm_domain()) {</span>
<span class="p_add">+		uint64_t v;</span>
<span class="p_add">+		int err;</span>
<span class="p_add">+</span>
<span class="p_add">+		err = hvm_get_parameter(HVM_PARAM_CONSOLE_EVTCHN, &amp;v);</span>
<span class="p_add">+		if (!err &amp;&amp; v)</span>
<span class="p_add">+			info-&gt;evtchn = v;</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		info-&gt;evtchn = xen_start_info-&gt;console.domU.evtchn;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void xen_console_resume(void)
 {
 	struct xencons_info *info = vtermno_to_xencons(HVC_COOKIE);
<span class="p_del">-	if (info != NULL &amp;&amp; info-&gt;irq)</span>
<span class="p_add">+	if (info != NULL &amp;&amp; info-&gt;irq) {</span>
<span class="p_add">+		if (!xen_initial_domain())</span>
<span class="p_add">+			xen_console_update_evtchn(info);</span>
 		rebind_evtchn_irq(info-&gt;evtchn, info-&gt;irq);
<span class="p_add">+	}</span>
 }
 
 static void xencons_disconnect_backend(struct xencons_info *info)
<span class="p_header">diff --git a/drivers/tty/serial/of_serial.c b/drivers/tty/serial/of_serial.c</span>
<span class="p_header">index 6563cad..746e771 100644</span>
<span class="p_header">--- a/drivers/tty/serial/of_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/of_serial.c</span>
<span class="p_chunk">@@ -192,7 +192,6 @@</span> <span class="p_context"> static struct of_device_id __devinitdata of_platform_serial_table[] = {</span>
 	{ .compatible = &quot;ibm,qpace-nwp-serial&quot;,
 		.data = (void *)PORT_NWPSERIAL, },
 #endif
<span class="p_del">-	{ .type = &quot;serial&quot;,         .data = (void *)PORT_UNKNOWN, },</span>
 	{ /* end of list */ },
 };
 
<span class="p_header">diff --git a/drivers/tty/serial/uartlite.c b/drivers/tty/serial/uartlite.c</span>
<span class="p_header">index 6cd4143..d9706e7 100644</span>
<span class="p_header">--- a/drivers/tty/serial/uartlite.c</span>
<span class="p_header">+++ b/drivers/tty/serial/uartlite.c</span>
<span class="p_chunk">@@ -573,7 +573,8 @@</span> <span class="p_context"> MODULE_DEVICE_TABLE(of, ulite_of_match);</span>
 
 static int __devinit ulite_probe(struct platform_device *pdev)
 {
<span class="p_del">-	struct resource *res, *res2;</span>
<span class="p_add">+	struct resource *res;</span>
<span class="p_add">+	int irq;</span>
 	int id = pdev-&gt;id;
 #ifdef CONFIG_OF
 	const __be32 *prop;
<span class="p_chunk">@@ -587,11 +588,11 @@</span> <span class="p_context"> static int __devinit ulite_probe(struct platform_device *pdev)</span>
 	if (!res)
 		return -ENODEV;
 
<span class="p_del">-	res2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);</span>
<span class="p_del">-	if (!res2)</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+	irq = platform_get_irq(pdev, 0);</span>
<span class="p_add">+	if (irq &lt;= 0)</span>
<span class="p_add">+		return -ENXIO;</span>
 
<span class="p_del">-	return ulite_assign(&amp;pdev-&gt;dev, id, res-&gt;start, res2-&gt;start);</span>
<span class="p_add">+	return ulite_assign(&amp;pdev-&gt;dev, id, res-&gt;start, irq);</span>
 }
 
 static int __devexit ulite_remove(struct platform_device *pdev)
<span class="p_header">diff --git a/drivers/tty/serial/xilinx_uartps.c b/drivers/tty/serial/xilinx_uartps.c</span>
<span class="p_header">index b627363..778c39a 100644</span>
<span class="p_header">--- a/drivers/tty/serial/xilinx_uartps.c</span>
<span class="p_header">+++ b/drivers/tty/serial/xilinx_uartps.c</span>
<span class="p_chunk">@@ -941,9 +941,9 @@</span> <span class="p_context"> static struct uart_driver xuartps_uart_driver = {</span>
  **/
 static int __devinit xuartps_probe(struct platform_device *pdev)
 {
<span class="p_del">-	int rc;</span>
<span class="p_add">+	int rc, irq;</span>
 	struct uart_port *port;
<span class="p_del">-	struct resource *res, *res2;</span>
<span class="p_add">+	struct resource *res;</span>
 	int clk = 0;
 
 #ifdef CONFIG_OF
<span class="p_chunk">@@ -964,9 +964,9 @@</span> <span class="p_context"> static int __devinit xuartps_probe(struct platform_device *pdev)</span>
 	if (!res)
 		return -ENODEV;
 
<span class="p_del">-	res2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);</span>
<span class="p_del">-	if (!res2)</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+	irq = platform_get_irq(pdev, 0);</span>
<span class="p_add">+	if (irq &lt;= 0)</span>
<span class="p_add">+		return -ENXIO;</span>
 
 	/* Initialize the port structure */
 	port = xuartps_get_port();
<span class="p_chunk">@@ -980,7 +980,7 @@</span> <span class="p_context"> static int __devinit xuartps_probe(struct platform_device *pdev)</span>
 		 * and triggers invocation of the config_port() entry point.
 		 */
 		port-&gt;mapbase = res-&gt;start;
<span class="p_del">-		port-&gt;irq = res2-&gt;start;</span>
<span class="p_add">+		port-&gt;irq = irq;</span>
 		port-&gt;dev = &amp;pdev-&gt;dev;
 		port-&gt;uartclk = clk;
 		dev_set_drvdata(&amp;pdev-&gt;dev, port);
<span class="p_header">diff --git a/drivers/usb/class/cdc-wdm.c b/drivers/usb/class/cdc-wdm.c</span>
<span class="p_header">index e5fa34e..c65c939 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-wdm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-wdm.c</span>
<span class="p_chunk">@@ -268,7 +268,7 @@</span> <span class="p_context"> static void wdm_int_callback(struct urb *urb)</span>
 	case USB_CDC_NOTIFY_RESPONSE_AVAILABLE:
 		dev_dbg(&amp;desc-&gt;intf-&gt;dev,
 			&quot;NOTIFY_RESPONSE_AVAILABLE received: index %d len %d&quot;,
<span class="p_del">-			dr-&gt;wIndex, dr-&gt;wLength);</span>
<span class="p_add">+			le16_to_cpu(dr-&gt;wIndex), le16_to_cpu(dr-&gt;wLength));</span>
 		break;
 
 	case USB_CDC_NOTIFY_NETWORK_CONNECTION:
<span class="p_chunk">@@ -281,7 +281,9 @@</span> <span class="p_context"> static void wdm_int_callback(struct urb *urb)</span>
 		clear_bit(WDM_POLL_RUNNING, &amp;desc-&gt;flags);
 		dev_err(&amp;desc-&gt;intf-&gt;dev,
 			&quot;unknown notification %d received: index %d len %d\n&quot;,
<span class="p_del">-			dr-&gt;bNotificationType, dr-&gt;wIndex, dr-&gt;wLength);</span>
<span class="p_add">+			dr-&gt;bNotificationType,</span>
<span class="p_add">+			le16_to_cpu(dr-&gt;wIndex),</span>
<span class="p_add">+			le16_to_cpu(dr-&gt;wLength));</span>
 		goto exit;
 	}
 
<span class="p_chunk">@@ -425,7 +427,7 @@</span> <span class="p_context"> static ssize_t wdm_write</span>
 			     USB_RECIP_INTERFACE);
 	req-&gt;bRequest = USB_CDC_SEND_ENCAPSULATED_COMMAND;
 	req-&gt;wValue = 0;
<span class="p_del">-	req-&gt;wIndex = desc-&gt;inum;</span>
<span class="p_add">+	req-&gt;wIndex = desc-&gt;inum; /* already converted */</span>
 	req-&gt;wLength = cpu_to_le16(count);
 	set_bit(WDM_IN_USE, &amp;desc-&gt;flags);
 	desc-&gt;outbuf = buf;
<span class="p_chunk">@@ -438,7 +440,7 @@</span> <span class="p_context"> static ssize_t wdm_write</span>
 		dev_err(&amp;desc-&gt;intf-&gt;dev, &quot;Tx URB error: %d\n&quot;, rv);
 	} else {
 		dev_dbg(&amp;desc-&gt;intf-&gt;dev, &quot;Tx URB has been submitted index=%d&quot;,
<span class="p_del">-			req-&gt;wIndex);</span>
<span class="p_add">+			le16_to_cpu(req-&gt;wIndex));</span>
 	}
 out:
 	usb_autopm_put_interface(desc-&gt;intf);
<span class="p_chunk">@@ -782,7 +784,7 @@</span> <span class="p_context"> static int wdm_create(struct usb_interface *intf, struct usb_endpoint_descriptor</span>
 	desc-&gt;irq-&gt;bRequestType = (USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE);
 	desc-&gt;irq-&gt;bRequest = USB_CDC_GET_ENCAPSULATED_RESPONSE;
 	desc-&gt;irq-&gt;wValue = 0;
<span class="p_del">-	desc-&gt;irq-&gt;wIndex = desc-&gt;inum;</span>
<span class="p_add">+	desc-&gt;irq-&gt;wIndex = desc-&gt;inum; /* already converted */</span>
 	desc-&gt;irq-&gt;wLength = cpu_to_le16(desc-&gt;wMaxCommand);
 
 	usb_fill_control_urb(
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index e47a4e1..5e93425 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -2129,8 +2129,13 @@</span> <span class="p_context"> static int process_isoc_td(struct xhci_hcd *xhci, struct xhci_td *td,</span>
 		break;
 	case COMP_DEV_ERR:
 	case COMP_STALL:
<span class="p_add">+		frame-&gt;status = -EPROTO;</span>
<span class="p_add">+		skip_td = true;</span>
<span class="p_add">+		break;</span>
 	case COMP_TX_ERR:
 		frame-&gt;status = -EPROTO;
<span class="p_add">+		if (event_trb != td-&gt;last_trb)</span>
<span class="p_add">+			return 0;</span>
 		skip_td = true;
 		break;
 	case COMP_STOP:
<span class="p_chunk">@@ -2738,7 +2743,7 @@</span> <span class="p_context"> irqreturn_t xhci_irq(struct usb_hcd *hcd)</span>
 		xhci_halt(xhci);
 hw_died:
 		spin_unlock(&amp;xhci-&gt;lock);
<span class="p_del">-		return -ESHUTDOWN;</span>
<span class="p_add">+		return IRQ_HANDLED;</span>
 	}
 
 	/*
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index 80b3d85..855f084 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -1233,7 +1233,7 @@</span> <span class="p_context"> union xhci_trb {</span>
  * since the command ring is 64-byte aligned.
  * It must also be greater than 16.
  */
<span class="p_del">-#define TRBS_PER_SEGMENT	64</span>
<span class="p_add">+#define TRBS_PER_SEGMENT	256</span>
 /* Allow two commands + a link TRB, along with any reserved command TRBs */
 #define MAX_RSVD_CMD_TRBS	(TRBS_PER_SEGMENT - 3)
 #define SEGMENT_SIZE		(TRBS_PER_SEGMENT*16)
<span class="p_header">diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c</span>
<span class="p_header">index a2b4008..d3481c4 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musb_core.c</span>
<span class="p_header">+++ b/drivers/usb/musb/musb_core.c</span>
<span class="p_chunk">@@ -1544,16 +1544,30 @@</span> <span class="p_context"> irqreturn_t musb_interrupt(struct musb *musb)</span>
 		(devctl &amp; MUSB_DEVCTL_HM) ? &quot;host&quot; : &quot;peripheral&quot;,
 		musb-&gt;int_usb, musb-&gt;int_tx, musb-&gt;int_rx);
 
<span class="p_del">-	/* the core can interrupt us for multiple reasons; docs have</span>
<span class="p_del">-	 * a generic interrupt flowchart to follow</span>
<span class="p_add">+	/**</span>
<span class="p_add">+	 * According to Mentor Graphics&#39; documentation, flowchart on page 98,</span>
<span class="p_add">+	 * IRQ should be handled as follows:</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * . Resume IRQ</span>
<span class="p_add">+	 * . Session Request IRQ</span>
<span class="p_add">+	 * . VBUS Error IRQ</span>
<span class="p_add">+	 * . Suspend IRQ</span>
<span class="p_add">+	 * . Connect IRQ</span>
<span class="p_add">+	 * . Disconnect IRQ</span>
<span class="p_add">+	 * . Reset/Babble IRQ</span>
<span class="p_add">+	 * . SOF IRQ (we&#39;re not using this one)</span>
<span class="p_add">+	 * . Endpoint 0 IRQ</span>
<span class="p_add">+	 * . TX Endpoints</span>
<span class="p_add">+	 * . RX Endpoints</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We will be following that flowchart in order to avoid any problems</span>
<span class="p_add">+	 * that might arise with internal Finite State Machine.</span>
 	 */
<span class="p_add">+</span>
 	if (musb-&gt;int_usb)
 		retval |= musb_stage0_irq(musb, musb-&gt;int_usb,
 				devctl, power);
 
<span class="p_del">-	/* &quot;stage 1&quot; is handling endpoint irqs */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* handle endpoint 0 first */</span>
 	if (musb-&gt;int_tx &amp; 1) {
 		if (devctl &amp; MUSB_DEVCTL_HM)
 			retval |= musb_h_ep0_irq(musb);
<span class="p_chunk">@@ -1561,43 +1575,37 @@</span> <span class="p_context"> irqreturn_t musb_interrupt(struct musb *musb)</span>
 			retval |= musb_g_ep0_irq(musb);
 	}
 
<span class="p_del">-	/* RX on endpoints 1-15 */</span>
<span class="p_del">-	reg = musb-&gt;int_rx &gt;&gt; 1;</span>
<span class="p_add">+	reg = musb-&gt;int_tx &gt;&gt; 1;</span>
 	ep_num = 1;
 	while (reg) {
 		if (reg &amp; 1) {
<span class="p_del">-			/* musb_ep_select(musb-&gt;mregs, ep_num); */</span>
<span class="p_del">-			/* REVISIT just retval = ep-&gt;rx_irq(...) */</span>
 			retval = IRQ_HANDLED;
 			if (devctl &amp; MUSB_DEVCTL_HM) {
 				if (is_host_capable())
<span class="p_del">-					musb_host_rx(musb, ep_num);</span>
<span class="p_add">+					musb_host_tx(musb, ep_num);</span>
 			} else {
 				if (is_peripheral_capable())
<span class="p_del">-					musb_g_rx(musb, ep_num);</span>
<span class="p_add">+					musb_g_tx(musb, ep_num);</span>
 			}
 		}
<span class="p_del">-</span>
 		reg &gt;&gt;= 1;
 		ep_num++;
 	}
 
<span class="p_del">-	/* TX on endpoints 1-15 */</span>
<span class="p_del">-	reg = musb-&gt;int_tx &gt;&gt; 1;</span>
<span class="p_add">+	reg = musb-&gt;int_rx &gt;&gt; 1;</span>
 	ep_num = 1;
 	while (reg) {
 		if (reg &amp; 1) {
<span class="p_del">-			/* musb_ep_select(musb-&gt;mregs, ep_num); */</span>
<span class="p_del">-			/* REVISIT just retval |= ep-&gt;tx_irq(...) */</span>
 			retval = IRQ_HANDLED;
 			if (devctl &amp; MUSB_DEVCTL_HM) {
 				if (is_host_capable())
<span class="p_del">-					musb_host_tx(musb, ep_num);</span>
<span class="p_add">+					musb_host_rx(musb, ep_num);</span>
 			} else {
 				if (is_peripheral_capable())
<span class="p_del">-					musb_g_tx(musb, ep_num);</span>
<span class="p_add">+					musb_g_rx(musb, ep_num);</span>
 			}
 		}
<span class="p_add">+</span>
 		reg &gt;&gt;= 1;
 		ep_num++;
 	}
<span class="p_header">diff --git a/drivers/usb/otg/otg_fsm.c b/drivers/usb/otg/otg_fsm.c</span>
<span class="p_header">index ade131a..e87edda 100644</span>
<span class="p_header">--- a/drivers/usb/otg/otg_fsm.c</span>
<span class="p_header">+++ b/drivers/usb/otg/otg_fsm.c</span>
<span class="p_chunk">@@ -138,9 +138,9 @@</span> <span class="p_context"> int otg_set_state(struct otg_fsm *fsm, enum usb_otg_state new_state)</span>
 		break;
 	case OTG_STATE_B_PERIPHERAL:
 		otg_chrg_vbus(fsm, 0);
<span class="p_del">-		otg_loc_conn(fsm, 1);</span>
 		otg_loc_sof(fsm, 0);
 		otg_set_protocol(fsm, PROTO_GADGET);
<span class="p_add">+		otg_loc_conn(fsm, 1);</span>
 		break;
 	case OTG_STATE_B_WAIT_ACON:
 		otg_chrg_vbus(fsm, 0);
<span class="p_chunk">@@ -200,10 +200,10 @@</span> <span class="p_context"> int otg_set_state(struct otg_fsm *fsm, enum usb_otg_state new_state)</span>
 
 		break;
 	case OTG_STATE_A_PERIPHERAL:
<span class="p_del">-		otg_loc_conn(fsm, 1);</span>
 		otg_loc_sof(fsm, 0);
 		otg_set_protocol(fsm, PROTO_GADGET);
 		otg_drv_vbus(fsm, 1);
<span class="p_add">+		otg_loc_conn(fsm, 1);</span>
 		break;
 	case OTG_STATE_A_WAIT_VFALL:
 		otg_drv_vbus(fsm, 0);
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 5c289fc..29bf383 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -133,6 +133,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x10C4, 0x88A5) }, /* Planet Innovation Ingeni ZigBee USB Device */
 	{ USB_DEVICE(0x10C4, 0x8946) }, /* Ketra N1 Wireless Interface */
 	{ USB_DEVICE(0x10C4, 0x8977) },	/* CEL MeshWorks DevKit Device */
<span class="p_add">+	{ USB_DEVICE(0x10C4, 0x8998) }, /* KCF Technologies PRN */</span>
<span class="p_add">+	{ USB_DEVICE(0x10C4, 0x8A2A) }, /* HubZ dual ZigBee and Z-Wave dongle */</span>
 	{ USB_DEVICE(0x10C4, 0xEA60) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA61) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA70) }, /* Silicon Labs factory default */
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index 06abee6..1e4899c 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -723,6 +723,7 @@</span> <span class="p_context"> static struct usb_device_id id_table_combined [] = {</span>
 	{ USB_DEVICE(XSENS_VID, XSENS_AWINDA_DONGLE_PID) },
 	{ USB_DEVICE(XSENS_VID, XSENS_AWINDA_STATION_PID) },
 	{ USB_DEVICE(XSENS_VID, XSENS_CONVERTER_PID) },
<span class="p_add">+	{ USB_DEVICE(XSENS_VID, XSENS_MTDEVBOARD_PID) },</span>
 	{ USB_DEVICE(XSENS_VID, XSENS_MTW_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_OMNI1509) },
 	{ USB_DEVICE(MOBILITY_VID, MOBILITY_USB_SERIAL_PID) },
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index 105b982..1fee973 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -155,6 +155,7 @@</span> <span class="p_context"></span>
 #define XSENS_AWINDA_STATION_PID 0x0101
 #define XSENS_AWINDA_DONGLE_PID 0x0102
 #define XSENS_MTW_PID		0x0200	/* Xsens MTw */
<span class="p_add">+#define XSENS_MTDEVBOARD_PID	0x0300	/* Motion Tracker Development Board */</span>
 #define XSENS_CONVERTER_PID	0xD00D	/* Xsens USB-serial converter */
 
 /* Xsens devices using FTDI VID */
<span class="p_header">diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c</span>
<span class="p_header">index 3e450b4..723ed87 100644</span>
<span class="p_header">--- a/drivers/usb/serial/pl2303.c</span>
<span class="p_header">+++ b/drivers/usb/serial/pl2303.c</span>
<span class="p_chunk">@@ -67,7 +67,6 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(DCU10_VENDOR_ID, DCU10_PRODUCT_ID) },
 	{ USB_DEVICE(SITECOM_VENDOR_ID, SITECOM_PRODUCT_ID) },
 	{ USB_DEVICE(ALCATEL_VENDOR_ID, ALCATEL_PRODUCT_ID) },
<span class="p_del">-	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_PRODUCT_ID) },</span>
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_SX1) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X65) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X75) },
<span class="p_header">diff --git a/drivers/usb/serial/pl2303.h b/drivers/usb/serial/pl2303.h</span>
<span class="p_header">index 71fd9da..e3b7af8 100644</span>
<span class="p_header">--- a/drivers/usb/serial/pl2303.h</span>
<span class="p_header">+++ b/drivers/usb/serial/pl2303.h</span>
<span class="p_chunk">@@ -62,10 +62,6 @@</span> <span class="p_context"></span>
 #define ALCATEL_VENDOR_ID	0x11f7
 #define ALCATEL_PRODUCT_ID	0x02df
 
<span class="p_del">-/* Samsung I330 phone cradle */</span>
<span class="p_del">-#define SAMSUNG_VENDOR_ID	0x04e8</span>
<span class="p_del">-#define SAMSUNG_PRODUCT_ID	0x8001</span>
<span class="p_del">-</span>
 #define SIEMENS_VENDOR_ID	0x11f5
 #define SIEMENS_PRODUCT_ID_SX1	0x0001
 #define SIEMENS_PRODUCT_ID_X65	0x0003
<span class="p_header">diff --git a/drivers/usb/serial/visor.c b/drivers/usb/serial/visor.c</span>
<span class="p_header">index b3afd19..c5cf350 100644</span>
<span class="p_header">--- a/drivers/usb/serial/visor.c</span>
<span class="p_header">+++ b/drivers/usb/serial/visor.c</span>
<span class="p_chunk">@@ -101,7 +101,7 @@</span> <span class="p_context"> static struct usb_device_id id_table [] = {</span>
 		.driver_info = (kernel_ulong_t)&amp;palm_os_4_probe },
 	{ USB_DEVICE(ACER_VENDOR_ID, ACER_S10_ID),
 		.driver_info = (kernel_ulong_t)&amp;palm_os_4_probe },
<span class="p_del">-	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_SCH_I330_ID),</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(SAMSUNG_VENDOR_ID, SAMSUNG_SCH_I330_ID, 0xff),</span>
 		.driver_info = (kernel_ulong_t)&amp;palm_os_4_probe },
 	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_SPH_I500_ID),
 		.driver_info = (kernel_ulong_t)&amp;palm_os_4_probe },
<span class="p_header">diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">index 25174be..d0ecaf9 100644</span>
<span class="p_header">--- a/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">+++ b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_chunk">@@ -752,6 +752,13 @@</span> <span class="p_context"> UNUSUAL_DEV(  0x059f, 0x0643, 0x0000, 0x0000,</span>
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_GO_SLOW ),
 
<span class="p_add">+/* Reported by Christian Schaller &lt;cschalle@redhat.com&gt; */</span>
<span class="p_add">+UNUSUAL_DEV(  0x059f, 0x0651, 0x0000, 0x0000,</span>
<span class="p_add">+		&quot;LaCie&quot;,</span>
<span class="p_add">+		&quot;External HDD&quot;,</span>
<span class="p_add">+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,</span>
<span class="p_add">+		US_FL_NO_WP_DETECT ),</span>
<span class="p_add">+</span>
 /* Submitted by Joel Bourquard &lt;numlock@freesurf.ch&gt;
  * Some versions of this device need the SubClass and Protocol overrides
  * while others don&#39;t.
<span class="p_header">diff --git a/drivers/xen/events.c b/drivers/xen/events.c</span>
<span class="p_header">index 9161f06..d6e2dee 100644</span>
<span class="p_header">--- a/drivers/xen/events.c</span>
<span class="p_header">+++ b/drivers/xen/events.c</span>
<span class="p_chunk">@@ -563,8 +563,8 @@</span> <span class="p_context"> static unsigned int __startup_pirq(unsigned int irq)</span>
 	pirq_query_unmask(irq);
 
 	evtchn_to_irq[evtchn] = irq;
<span class="p_del">-	bind_evtchn_to_cpu(evtchn, 0);</span>
 	info-&gt;evtchn = evtchn;
<span class="p_add">+	bind_evtchn_to_cpu(evtchn, 0);</span>
 
 out:
 	unmask_evtchn(evtchn);
<span class="p_chunk">@@ -906,7 +906,7 @@</span> <span class="p_context"> static int find_virq(unsigned int virq, unsigned int cpu)</span>
 	return rc;
 }
 
<span class="p_del">-int bind_virq_to_irq(unsigned int virq, unsigned int cpu)</span>
<span class="p_add">+int bind_virq_to_irq(unsigned int virq, unsigned int cpu, bool percpu)</span>
 {
 	struct evtchn_bind_virq bind_virq;
 	int evtchn, irq, ret;
<span class="p_chunk">@@ -920,8 +920,12 @@</span> <span class="p_context"> int bind_virq_to_irq(unsigned int virq, unsigned int cpu)</span>
 		if (irq == -1)
 			goto out;
 
<span class="p_del">-		irq_set_chip_and_handler_name(irq, &amp;xen_percpu_chip,</span>
<span class="p_del">-					      handle_percpu_irq, &quot;virq&quot;);</span>
<span class="p_add">+		if (percpu)</span>
<span class="p_add">+			irq_set_chip_and_handler_name(irq, &amp;xen_percpu_chip,</span>
<span class="p_add">+						      handle_percpu_irq, &quot;virq&quot;);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			irq_set_chip_and_handler_name(irq, &amp;xen_dynamic_chip,</span>
<span class="p_add">+						      handle_edge_irq, &quot;virq&quot;);</span>
 
 		bind_virq.virq = virq;
 		bind_virq.vcpu = cpu;
<span class="p_chunk">@@ -1042,7 +1046,7 @@</span> <span class="p_context"> int bind_virq_to_irqhandler(unsigned int virq, unsigned int cpu,</span>
 {
 	int irq, retval;
 
<span class="p_del">-	irq = bind_virq_to_irq(virq, cpu);</span>
<span class="p_add">+	irq = bind_virq_to_irq(virq, cpu, irqflags &amp; IRQF_PERCPU);</span>
 	if (irq &lt; 0)
 		return irq;
 	retval = request_irq(irq, handler, irqflags, devname, dev_id);
<span class="p_header">diff --git a/firmware/ihex2fw.c b/firmware/ihex2fw.c</span>
<span class="p_header">index cf38e15..08d90e2 100644</span>
<span class="p_header">--- a/firmware/ihex2fw.c</span>
<span class="p_header">+++ b/firmware/ihex2fw.c</span>
<span class="p_chunk">@@ -86,6 +86,7 @@</span> <span class="p_context"> int main(int argc, char **argv)</span>
 		case &#39;j&#39;:
 			include_jump = 1;
 			break;
<span class="p_add">+		default:</span>
 			return usage();
 		}
 	}
<span class="p_header">diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c</span>
<span class="p_header">index 6dacccef..a181b58 100644</span>
<span class="p_header">--- a/fs/binfmt_elf.c</span>
<span class="p_header">+++ b/fs/binfmt_elf.c</span>
<span class="p_chunk">@@ -742,6 +742,7 @@</span> <span class="p_context"> static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)</span>
 	    i &lt; loc-&gt;elf_ex.e_phnum; i++, elf_ppnt++) {
 		int elf_prot = 0, elf_flags;
 		unsigned long k, vaddr;
<span class="p_add">+		unsigned long total_size = 0;</span>
 
 		if (elf_ppnt-&gt;p_type != PT_LOAD)
 			continue;
<span class="p_chunk">@@ -805,10 +806,16 @@</span> <span class="p_context"> static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)</span>
 #else
 			load_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);
 #endif
<span class="p_add">+			total_size = total_mapping_size(elf_phdata,</span>
<span class="p_add">+							loc-&gt;elf_ex.e_phnum);</span>
<span class="p_add">+			if (!total_size) {</span>
<span class="p_add">+				error = -EINVAL;</span>
<span class="p_add">+				goto out_free_dentry;</span>
<span class="p_add">+			}</span>
 		}
 
 		error = elf_map(bprm-&gt;file, load_bias + vaddr, elf_ppnt,
<span class="p_del">-				elf_prot, elf_flags, 0);</span>
<span class="p_add">+				elf_prot, elf_flags, total_size);</span>
 		if (BAD_ADDR(error)) {
 			send_sig(SIGKILL, current, 0);
 			retval = IS_ERR((void *)error) ?
<span class="p_header">diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c</span>
<span class="p_header">index cf6e7f4..f4576dc 100644</span>
<span class="p_header">--- a/fs/btrfs/extent-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/extent-tree.c</span>
<span class="p_chunk">@@ -5939,12 +5939,11 @@</span> <span class="p_context"> static int __btrfs_free_reserved_extent(struct btrfs_root *root,</span>
 		return -ENOSPC;
 	}
 
<span class="p_del">-	if (btrfs_test_opt(root, DISCARD))</span>
<span class="p_del">-		ret = btrfs_discard_extent(root, start, len, NULL);</span>
<span class="p_del">-</span>
 	if (pin)
 		pin_down_extent(root, cache, start, len, 1);
 	else {
<span class="p_add">+		if (btrfs_test_opt(root, DISCARD))</span>
<span class="p_add">+			ret = btrfs_discard_extent(root, start, len, NULL);</span>
 		btrfs_add_free_space(cache, start, len);
 		btrfs_update_reserved_bytes(cache, len, RESERVE_FREE);
 	}
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index 3a65f43..d46c481 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -2374,6 +2374,11 @@</span> <span class="p_context"> static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,</span>
 	if (off + len == src-&gt;i_size)
 		len = ALIGN(src-&gt;i_size, bs) - off;
 
<span class="p_add">+	if (len == 0) {</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* verify the end result is block aligned */
 	if (!IS_ALIGNED(off, bs) || !IS_ALIGNED(off + len, bs) ||
 	    !IS_ALIGNED(destoff, bs))
<span class="p_header">diff --git a/fs/btrfs/xattr.c b/fs/btrfs/xattr.c</span>
<span class="p_header">index e7a5659..0ee73d1 100644</span>
<span class="p_header">--- a/fs/btrfs/xattr.c</span>
<span class="p_header">+++ b/fs/btrfs/xattr.c</span>
<span class="p_chunk">@@ -310,21 +310,40 @@</span> <span class="p_context"> const struct xattr_handler *btrfs_xattr_handlers[] = {</span>
 /*
  * Check if the attribute is in a supported namespace.
  *
<span class="p_del">- * This applied after the check for the synthetic attributes in the system</span>
<span class="p_add">+ * This is applied after the check for the synthetic attributes in the system</span>
  * namespace.
  */
<span class="p_del">-static bool btrfs_is_valid_xattr(const char *name)</span>
<span class="p_add">+static int btrfs_is_valid_xattr(const char *name)</span>
 {
<span class="p_del">-	return !strncmp(name, XATTR_SECURITY_PREFIX,</span>
<span class="p_del">-			XATTR_SECURITY_PREFIX_LEN) ||</span>
<span class="p_del">-	       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||</span>
<span class="p_del">-	       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||</span>
<span class="p_del">-	       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);</span>
<span class="p_add">+	int len = strlen(name);</span>
<span class="p_add">+	int prefixlen = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!strncmp(name, XATTR_SECURITY_PREFIX,</span>
<span class="p_add">+			XATTR_SECURITY_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_SECURITY_PREFIX_LEN;</span>
<span class="p_add">+	else if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_SYSTEM_PREFIX_LEN;</span>
<span class="p_add">+	else if (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_TRUSTED_PREFIX_LEN;</span>
<span class="p_add">+	else if (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_USER_PREFIX_LEN;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return -EOPNOTSUPP;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The name cannot consist of just prefix</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (len &lt;= prefixlen)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 ssize_t btrfs_getxattr(struct dentry *dentry, const char *name,
 		       void *buffer, size_t size)
 {
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
 	/*
 	 * If this is a request for a synthetic attribute in the system.*
 	 * namespace use the generic infrastructure to resolve a handler
<span class="p_chunk">@@ -333,8 +352,9 @@</span> <span class="p_context"> ssize_t btrfs_getxattr(struct dentry *dentry, const char *name,</span>
 	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
 		return generic_getxattr(dentry, name, buffer, size);
 
<span class="p_del">-	if (!btrfs_is_valid_xattr(name))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+	ret = btrfs_is_valid_xattr(name);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 	return __btrfs_getxattr(dentry-&gt;d_inode, name, buffer, size);
 }
 
<span class="p_chunk">@@ -342,6 +362,7 @@</span> <span class="p_context"> int btrfs_setxattr(struct dentry *dentry, const char *name, const void *value,</span>
 		   size_t size, int flags)
 {
 	struct btrfs_root *root = BTRFS_I(dentry-&gt;d_inode)-&gt;root;
<span class="p_add">+	int ret;</span>
 
 	/*
 	 * The permission on security.* and system.* is not checked
<span class="p_chunk">@@ -358,8 +379,9 @@</span> <span class="p_context"> int btrfs_setxattr(struct dentry *dentry, const char *name, const void *value,</span>
 	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
 		return generic_setxattr(dentry, name, value, size, flags);
 
<span class="p_del">-	if (!btrfs_is_valid_xattr(name))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+	ret = btrfs_is_valid_xattr(name);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	if (size == 0)
 		value = &quot;&quot;;  /* empty EA, do not remove */
<span class="p_chunk">@@ -371,6 +393,7 @@</span> <span class="p_context"> int btrfs_setxattr(struct dentry *dentry, const char *name, const void *value,</span>
 int btrfs_removexattr(struct dentry *dentry, const char *name)
 {
 	struct btrfs_root *root = BTRFS_I(dentry-&gt;d_inode)-&gt;root;
<span class="p_add">+	int ret;</span>
 
 	/*
 	 * The permission on security.* and system.* is not checked
<span class="p_chunk">@@ -387,8 +410,9 @@</span> <span class="p_context"> int btrfs_removexattr(struct dentry *dentry, const char *name)</span>
 	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
 		return generic_removexattr(dentry, name);
 
<span class="p_del">-	if (!btrfs_is_valid_xattr(name))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+	ret = btrfs_is_valid_xattr(name);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	return __btrfs_setxattr(NULL, dentry-&gt;d_inode, name, NULL, 0,
 				XATTR_REPLACE);
<span class="p_header">diff --git a/fs/dcache.c b/fs/dcache.c</span>
<span class="p_header">index 8038a78..d071ea7 100644</span>
<span class="p_header">--- a/fs/dcache.c</span>
<span class="p_header">+++ b/fs/dcache.c</span>
<span class="p_chunk">@@ -1204,13 +1204,13 @@</span> <span class="p_context"> ascend:</span>
 		/* might go back up the wrong parent if we have had a rename */
 		if (!locked &amp;&amp; read_seqretry(&amp;rename_lock, seq))
 			goto rename_retry;
<span class="p_del">-		next = child-&gt;d_child.next;</span>
<span class="p_del">-		while (unlikely(child-&gt;d_flags &amp; DCACHE_DENTRY_KILLED)) {</span>
<span class="p_add">+		/* go into the first sibling still alive */</span>
<span class="p_add">+		do {</span>
<span class="p_add">+			next = child-&gt;d_child.next;</span>
 			if (next == &amp;this_parent-&gt;d_subdirs)
 				goto ascend;
 			child = list_entry(next, struct dentry, d_child);
<span class="p_del">-			next = next-&gt;next;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		} while (unlikely(child-&gt;d_flags &amp; DCACHE_DENTRY_KILLED));</span>
 		rcu_read_unlock();
 		goto resume;
 	}
<span class="p_header">diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c</span>
<span class="p_header">index 4296a6f..bbe09a9 100644</span>
<span class="p_header">--- a/fs/ext4/extents.c</span>
<span class="p_header">+++ b/fs/ext4/extents.c</span>
<span class="p_chunk">@@ -320,7 +320,7 @@</span> <span class="p_context"> static int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext)</span>
 	ext4_lblk_t lblock = le32_to_cpu(ext-&gt;ee_block);
 	ext4_lblk_t last = lblock + len - 1;
 
<span class="p_del">-	if (lblock &gt; last)</span>
<span class="p_add">+	if (len == 0 || lblock &gt; last)</span>
 		return 0;
 	return ext4_data_block_valid(EXT4_SB(inode-&gt;i_sb), block, len);
 }
<span class="p_chunk">@@ -4365,13 +4365,6 @@</span> <span class="p_context"> long ext4_fallocate(struct file *file, int mode, loff_t offset, loff_t len)</span>
 	struct ext4_map_blocks map;
 	unsigned int credits, blkbits = inode-&gt;i_blkbits;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * currently supporting (pre)allocate mode for extent-based</span>
<span class="p_del">-	 * files _only_</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_del">-</span>
 	/* Return error if mode is not supported */
 	if (mode &amp; ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE))
 		return -EOPNOTSUPP;
<span class="p_chunk">@@ -4392,6 +4385,15 @@</span> <span class="p_context"> long ext4_fallocate(struct file *file, int mode, loff_t offset, loff_t len)</span>
 	 */
 	credits = ext4_chunk_trans_blocks(inode, max_blocks);
 	mutex_lock(&amp;inode-&gt;i_mutex);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We only support preallocation for extent-based files only</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {</span>
<span class="p_add">+		mutex_unlock(&amp;inode-&gt;i_mutex);</span>
<span class="p_add">+		return -EOPNOTSUPP;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ret = inode_newsize_ok(inode, (len + offset));
 	if (ret) {
 		mutex_unlock(&amp;inode-&gt;i_mutex);
<span class="p_header">diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c</span>
<span class="p_header">index dc58523..e1e1d46 100644</span>
<span class="p_header">--- a/fs/ext4/namei.c</span>
<span class="p_header">+++ b/fs/ext4/namei.c</span>
<span class="p_chunk">@@ -1469,7 +1469,7 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 			  struct inode *inode)
 {
 	struct inode *dir = dentry-&gt;d_parent-&gt;d_inode;
<span class="p_del">-	struct buffer_head *bh;</span>
<span class="p_add">+	struct buffer_head *bh = NULL;</span>
 	struct ext4_dir_entry_2 *de;
 	struct super_block *sb;
 	int	retval;
<span class="p_chunk">@@ -1484,7 +1484,7 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 	if (is_dx(dir)) {
 		retval = ext4_dx_add_entry(handle, dentry, inode);
 		if (!retval || (retval != ERR_BAD_DX_DIR))
<span class="p_del">-			return retval;</span>
<span class="p_add">+			goto out;</span>
 		ext4_clear_inode_flag(dir, EXT4_INODE_INDEX);
 		dx_fallback++;
 		ext4_mark_inode_dirty(handle, dir);
<span class="p_chunk">@@ -1495,14 +1495,15 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 		if(!bh)
 			return retval;
 		retval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);
<span class="p_del">-		if (retval != -ENOSPC) {</span>
<span class="p_del">-			brelse(bh);</span>
<span class="p_del">-			return retval;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (retval != -ENOSPC)</span>
<span class="p_add">+			goto out;</span>
 
 		if (blocks == 1 &amp;&amp; !dx_fallback &amp;&amp;
<span class="p_del">-		    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX))</span>
<span class="p_del">-			return make_indexed_dir(handle, dentry, inode, bh);</span>
<span class="p_add">+		    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX)) {</span>
<span class="p_add">+			retval = make_indexed_dir(handle, dentry, inode, bh);</span>
<span class="p_add">+			bh = NULL; /* make_indexed_dir releases bh */</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
 		brelse(bh);
 	}
 	bh = ext4_append(handle, dir, &amp;block, &amp;retval);
<span class="p_chunk">@@ -1512,6 +1513,7 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 	de-&gt;inode = 0;
 	de-&gt;rec_len = ext4_rec_len_to_disk(blocksize, blocksize);
 	retval = add_dirent_to_buf(handle, dentry, inode, de, bh);
<span class="p_add">+out:</span>
 	brelse(bh);
 	if (retval == 0)
 		ext4_set_inode_state(inode, EXT4_STATE_NEWENTRY);
<span class="p_header">diff --git a/fs/fhandle.c b/fs/fhandle.c</span>
<span class="p_header">index a48e4a1..f7c18e9 100644</span>
<span class="p_header">--- a/fs/fhandle.c</span>
<span class="p_header">+++ b/fs/fhandle.c</span>
<span class="p_chunk">@@ -198,8 +198,9 @@</span> <span class="p_context"> static int handle_to_path(int mountdirfd, struct file_handle __user *ufh,</span>
 		goto out_err;
 	}
 	/* copy the full handle */
<span class="p_del">-	if (copy_from_user(handle, ufh,</span>
<span class="p_del">-			   sizeof(struct file_handle) +</span>
<span class="p_add">+	*handle = f_handle;</span>
<span class="p_add">+	if (copy_from_user(&amp;handle-&gt;f_handle,</span>
<span class="p_add">+			   &amp;ufh-&gt;f_handle,</span>
 			   f_handle.handle_bytes)) {
 		retval = -EFAULT;
 		goto out_handle;
<span class="p_header">diff --git a/fs/namei.c b/fs/namei.c</span>
<span class="p_header">index bdcd705..9c4b9b8 100644</span>
<span class="p_header">--- a/fs/namei.c</span>
<span class="p_header">+++ b/fs/namei.c</span>
<span class="p_chunk">@@ -1314,7 +1314,8 @@</span> <span class="p_context"> static inline int walk_component(struct nameidata *nd, struct path *path,</span>
 	}
 	if (should_follow_link(inode, follow)) {
 		if (nd-&gt;flags &amp; LOOKUP_RCU) {
<span class="p_del">-			if (unlikely(unlazy_walk(nd, path-&gt;dentry))) {</span>
<span class="p_add">+			if (unlikely(nd-&gt;path.mnt != path-&gt;mnt ||</span>
<span class="p_add">+				     unlazy_walk(nd, path-&gt;dentry))) {</span>
 				terminate_walk(nd);
 				return -ECHILD;
 			}
<span class="p_header">diff --git a/fs/nfs/callback.c b/fs/nfs/callback.c</span>
<span class="p_header">index 38a44c6..0184e91 100644</span>
<span class="p_header">--- a/fs/nfs/callback.c</span>
<span class="p_header">+++ b/fs/nfs/callback.c</span>
<span class="p_chunk">@@ -156,6 +156,7 @@</span> <span class="p_context"> nfs41_callback_svc(void *vrqstp)</span>
 					struct rpc_rqst, rq_bc_list);
 			list_del(&amp;req-&gt;rq_bc_list);
 			spin_unlock_bh(&amp;serv-&gt;sv_cb_lock);
<span class="p_add">+			finish_wait(&amp;serv-&gt;sv_cb_waitq, &amp;wq);</span>
 			dprintk(&quot;Invoking bc_svc_process()\n&quot;);
 			error = bc_svc_process(serv, req, rqstp);
 			dprintk(&quot;bc_svc_process() returned w/ error code= %d\n&quot;,
<span class="p_chunk">@@ -163,8 +164,9 @@</span> <span class="p_context"> nfs41_callback_svc(void *vrqstp)</span>
 		} else {
 			spin_unlock_bh(&amp;serv-&gt;sv_cb_lock);
 			schedule();
<span class="p_add">+			finish_wait(&amp;serv-&gt;sv_cb_waitq, &amp;wq);</span>
 		}
<span class="p_del">-		finish_wait(&amp;serv-&gt;sv_cb_waitq, &amp;wq);</span>
<span class="p_add">+		flush_signals(current);</span>
 	}
 	return 0;
 }
<span class="p_header">diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c</span>
<span class="p_header">index a4b87c6..6143a1e 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4state.c</span>
<span class="p_chunk">@@ -3364,10 +3364,17 @@</span> <span class="p_context"> static int check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_sess</span>
 	return nfserr_old_stateid;
 }
 
<span class="p_add">+static __be32 nfsd4_check_openowner_confirmed(struct nfs4_ol_stateid *ols)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (ols-&gt;st_stateowner-&gt;so_is_open_owner &amp;&amp;</span>
<span class="p_add">+	    !(openowner(ols-&gt;st_stateowner)-&gt;oo_flags &amp; NFS4_OO_CONFIRMED))</span>
<span class="p_add">+		return nfserr_bad_stateid;</span>
<span class="p_add">+	return nfs_ok;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 __be32 nfs4_validate_stateid(struct nfs4_client *cl, stateid_t *stateid)
 {
 	struct nfs4_stid *s;
<span class="p_del">-	struct nfs4_ol_stateid *ols;</span>
 	__be32 status;
 
 	if (STALE_STATEID(stateid))
<span class="p_chunk">@@ -3381,11 +3388,7 @@</span> <span class="p_context"> __be32 nfs4_validate_stateid(struct nfs4_client *cl, stateid_t *stateid)</span>
 		return status;
 	if (!(s-&gt;sc_type &amp; (NFS4_OPEN_STID | NFS4_LOCK_STID)))
 		return nfs_ok;
<span class="p_del">-	ols = openlockstateid(s);</span>
<span class="p_del">-	if (ols-&gt;st_stateowner-&gt;so_is_open_owner</span>
<span class="p_del">-	    &amp;&amp; !(openowner(ols-&gt;st_stateowner)-&gt;oo_flags &amp; NFS4_OO_CONFIRMED))</span>
<span class="p_del">-		return nfserr_bad_stateid;</span>
<span class="p_del">-	return nfs_ok;</span>
<span class="p_add">+	return nfsd4_check_openowner_confirmed(openlockstateid(s));</span>
 }
 
 static __be32 nfsd4_lookup_stateid(stateid_t *stateid, unsigned char typemask, struct nfs4_stid **s)
<span class="p_chunk">@@ -3452,8 +3455,8 @@</span> <span class="p_context"> nfs4_preprocess_stateid_op(struct nfsd4_compound_state *cstate,</span>
 		status = nfs4_check_fh(current_fh, stp);
 		if (status)
 			goto out;
<span class="p_del">-		if (stp-&gt;st_stateowner-&gt;so_is_open_owner</span>
<span class="p_del">-		    &amp;&amp; !(openowner(stp-&gt;st_stateowner)-&gt;oo_flags &amp; NFS4_OO_CONFIRMED))</span>
<span class="p_add">+		status = nfsd4_check_openowner_confirmed(stp);</span>
<span class="p_add">+		if (status)</span>
 			goto out;
 		status = nfs4_check_openmode(stp, flags);
 		if (status)
<span class="p_header">diff --git a/fs/nfsd/nfsctl.c b/fs/nfsd/nfsctl.c</span>
<span class="p_header">index 4db777d..c8bc7ea 100644</span>
<span class="p_header">--- a/fs/nfsd/nfsctl.c</span>
<span class="p_header">+++ b/fs/nfsd/nfsctl.c</span>
<span class="p_chunk">@@ -1163,15 +1163,15 @@</span> <span class="p_context"> static int __init init_nfsd(void)</span>
 	int retval;
 	printk(KERN_INFO &quot;Installing knfsd (copyright (C) 1996 okir@monad.swb.de).\n&quot;);
 
<span class="p_del">-	retval = register_cld_notifier();</span>
<span class="p_del">-	if (retval)</span>
<span class="p_del">-		return retval;</span>
 	retval = register_pernet_subsys(&amp;nfsd_net_ops);
 	if (retval &lt; 0)
<span class="p_del">-		goto out_unregister_notifier;</span>
<span class="p_del">-	retval = nfsd4_init_slabs();</span>
<span class="p_add">+		return retval;</span>
<span class="p_add">+	retval = register_cld_notifier();</span>
 	if (retval)
 		goto out_unregister_pernet;
<span class="p_add">+	retval = nfsd4_init_slabs();</span>
<span class="p_add">+	if (retval)</span>
<span class="p_add">+		goto out_unregister_notifier;</span>
 	nfs4_state_init();
 	retval = nfsd_fault_inject_init(); /* nfsd fault injection controls */
 	if (retval)
<span class="p_chunk">@@ -1209,10 +1209,10 @@</span> <span class="p_context"> out_free_stat:</span>
 	nfsd_fault_inject_cleanup();
 out_free_slabs:
 	nfsd4_free_slabs();
<span class="p_del">-out_unregister_pernet:</span>
<span class="p_del">-	unregister_pernet_subsys(&amp;nfsd_net_ops);</span>
 out_unregister_notifier:
 	unregister_cld_notifier();
<span class="p_add">+out_unregister_pernet:</span>
<span class="p_add">+	unregister_pernet_subsys(&amp;nfsd_net_ops);</span>
 	return retval;
 }
 
<span class="p_chunk">@@ -1228,8 +1228,8 @@</span> <span class="p_context"> static void __exit exit_nfsd(void)</span>
 	nfsd4_free_slabs();
 	nfsd_fault_inject_cleanup();
 	unregister_filesystem(&amp;nfsd_fs_type);
<span class="p_del">-	unregister_pernet_subsys(&amp;nfsd_net_ops);</span>
 	unregister_cld_notifier();
<span class="p_add">+	unregister_pernet_subsys(&amp;nfsd_net_ops);</span>
 }
 
 MODULE_AUTHOR(&quot;Olaf Kirch &lt;okir@monad.swb.de&gt;&quot;);
<span class="p_header">diff --git a/fs/nilfs2/btree.c b/fs/nilfs2/btree.c</span>
<span class="p_header">index ecdbae1..090d8ce 100644</span>
<span class="p_header">--- a/fs/nilfs2/btree.c</span>
<span class="p_header">+++ b/fs/nilfs2/btree.c</span>
<span class="p_chunk">@@ -388,7 +388,7 @@</span> <span class="p_context"> static int nilfs_btree_root_broken(const struct nilfs_btree_node *node,</span>
 	nchildren = nilfs_btree_node_get_nchildren(node);
 
 	if (unlikely(level &lt; NILFS_BTREE_LEVEL_NODE_MIN ||
<span class="p_del">-		     level &gt; NILFS_BTREE_LEVEL_MAX ||</span>
<span class="p_add">+		     level &gt;= NILFS_BTREE_LEVEL_MAX ||</span>
 		     nchildren &lt; 0 ||
 		     nchildren &gt; NILFS_BTREE_ROOT_NCHILDREN_MAX)) {
 		pr_crit(&quot;NILFS: bad btree root (inode number=%lu): level = %d, flags = 0x%x, nchildren = %d\n&quot;,
<span class="p_header">diff --git a/fs/ocfs2/dlm/dlmmaster.c b/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_header">index dbc372e..7ba6ac1 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_chunk">@@ -729,6 +729,19 @@</span> <span class="p_context"> lookup:</span>
 	if (tmpres) {
 		spin_unlock(&amp;dlm-&gt;spinlock);
 		spin_lock(&amp;tmpres-&gt;spinlock);
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Right after dlm spinlock was released, dlm_thread could have</span>
<span class="p_add">+		 * purged the lockres. Check if lockres got unhashed. If so</span>
<span class="p_add">+		 * start over.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (hlist_unhashed(&amp;tmpres-&gt;hash_node)) {</span>
<span class="p_add">+			spin_unlock(&amp;tmpres-&gt;spinlock);</span>
<span class="p_add">+			dlm_lockres_put(tmpres);</span>
<span class="p_add">+			tmpres = NULL;</span>
<span class="p_add">+			goto lookup;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		/* Wait on the thread that is mastering the resource */
 		if (tmpres-&gt;owner == DLM_LOCK_RES_OWNER_UNKNOWN) {
 			__dlm_wait_on_lockres(tmpres);
<span class="p_header">diff --git a/fs/omfs/inode.c b/fs/omfs/inode.c</span>
<span class="p_header">index dbc8422..798dedc 100644</span>
<span class="p_header">--- a/fs/omfs/inode.c</span>
<span class="p_header">+++ b/fs/omfs/inode.c</span>
<span class="p_chunk">@@ -361,7 +361,7 @@</span> <span class="p_context"> nomem:</span>
 }
 
 enum {
<span class="p_del">-	Opt_uid, Opt_gid, Opt_umask, Opt_dmask, Opt_fmask</span>
<span class="p_add">+	Opt_uid, Opt_gid, Opt_umask, Opt_dmask, Opt_fmask, Opt_err</span>
 };
 
 static const match_table_t tokens = {
<span class="p_chunk">@@ -370,6 +370,7 @@</span> <span class="p_context"> static const match_table_t tokens = {</span>
 	{Opt_umask, &quot;umask=%o&quot;},
 	{Opt_dmask, &quot;dmask=%o&quot;},
 	{Opt_fmask, &quot;fmask=%o&quot;},
<span class="p_add">+	{Opt_err, NULL},</span>
 };
 
 static int parse_options(char *options, struct omfs_sb_info *sbi)
<span class="p_header">diff --git a/fs/pipe.c b/fs/pipe.c</span>
<span class="p_header">index 1667e6f..abfb935 100644</span>
<span class="p_header">--- a/fs/pipe.c</span>
<span class="p_header">+++ b/fs/pipe.c</span>
<span class="p_chunk">@@ -104,25 +104,27 @@</span> <span class="p_context"> void pipe_wait(struct pipe_inode_info *pipe)</span>
 }
 
 static int
<span class="p_del">-pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,</span>
<span class="p_del">-			int atomic)</span>
<span class="p_add">+pipe_iov_copy_from_user(void *addr, int *offset, struct iovec *iov,</span>
<span class="p_add">+			size_t *remaining, int atomic)</span>
 {
 	unsigned long copy;
 
<span class="p_del">-	while (len &gt; 0) {</span>
<span class="p_add">+	while (*remaining &gt; 0) {</span>
 		while (!iov-&gt;iov_len)
 			iov++;
<span class="p_del">-		copy = min_t(unsigned long, len, iov-&gt;iov_len);</span>
<span class="p_add">+		copy = min_t(unsigned long, *remaining, iov-&gt;iov_len);</span>
 
 		if (atomic) {
<span class="p_del">-			if (__copy_from_user_inatomic(to, iov-&gt;iov_base, copy))</span>
<span class="p_add">+			if (__copy_from_user_inatomic(addr + *offset,</span>
<span class="p_add">+						      iov-&gt;iov_base, copy))</span>
 				return -EFAULT;
 		} else {
<span class="p_del">-			if (copy_from_user(to, iov-&gt;iov_base, copy))</span>
<span class="p_add">+			if (copy_from_user(addr + *offset,</span>
<span class="p_add">+					   iov-&gt;iov_base, copy))</span>
 				return -EFAULT;
 		}
<span class="p_del">-		to += copy;</span>
<span class="p_del">-		len -= copy;</span>
<span class="p_add">+		*offset += copy;</span>
<span class="p_add">+		*remaining -= copy;</span>
 		iov-&gt;iov_base += copy;
 		iov-&gt;iov_len -= copy;
 	}
<span class="p_chunk">@@ -130,25 +132,27 @@</span> <span class="p_context"> pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,</span>
 }
 
 static int
<span class="p_del">-pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,</span>
<span class="p_del">-		      int atomic)</span>
<span class="p_add">+pipe_iov_copy_to_user(struct iovec *iov, void *addr, int *offset,</span>
<span class="p_add">+		      size_t *remaining, int atomic)</span>
 {
 	unsigned long copy;
 
<span class="p_del">-	while (len &gt; 0) {</span>
<span class="p_add">+	while (*remaining &gt; 0) {</span>
 		while (!iov-&gt;iov_len)
 			iov++;
<span class="p_del">-		copy = min_t(unsigned long, len, iov-&gt;iov_len);</span>
<span class="p_add">+		copy = min_t(unsigned long, *remaining, iov-&gt;iov_len);</span>
 
 		if (atomic) {
<span class="p_del">-			if (__copy_to_user_inatomic(iov-&gt;iov_base, from, copy))</span>
<span class="p_add">+			if (__copy_to_user_inatomic(iov-&gt;iov_base,</span>
<span class="p_add">+						    addr + *offset, copy))</span>
 				return -EFAULT;
 		} else {
<span class="p_del">-			if (copy_to_user(iov-&gt;iov_base, from, copy))</span>
<span class="p_add">+			if (copy_to_user(iov-&gt;iov_base,</span>
<span class="p_add">+					 addr + *offset, copy))</span>
 				return -EFAULT;
 		}
<span class="p_del">-		from += copy;</span>
<span class="p_del">-		len -= copy;</span>
<span class="p_add">+		*offset += copy;</span>
<span class="p_add">+		*remaining -= copy;</span>
 		iov-&gt;iov_base += copy;
 		iov-&gt;iov_len -= copy;
 	}
<span class="p_chunk">@@ -384,7 +388,7 @@</span> <span class="p_context"> pipe_read(struct kiocb *iocb, const struct iovec *_iov,</span>
 			struct pipe_buffer *buf = pipe-&gt;bufs + curbuf;
 			const struct pipe_buf_operations *ops = buf-&gt;ops;
 			void *addr;
<span class="p_del">-			size_t chars = buf-&gt;len;</span>
<span class="p_add">+			size_t chars = buf-&gt;len, remaining;</span>
 			int error, atomic;
 
 			if (chars &gt; total_len)
<span class="p_chunk">@@ -398,9 +402,11 @@</span> <span class="p_context"> pipe_read(struct kiocb *iocb, const struct iovec *_iov,</span>
 			}
 
 			atomic = !iov_fault_in_pages_write(iov, chars);
<span class="p_add">+			remaining = chars;</span>
 redo:
 			addr = ops-&gt;map(pipe, buf, atomic);
<span class="p_del">-			error = pipe_iov_copy_to_user(iov, addr + buf-&gt;offset, chars, atomic);</span>
<span class="p_add">+			error = pipe_iov_copy_to_user(iov, addr, &amp;buf-&gt;offset,</span>
<span class="p_add">+						      &amp;remaining, atomic);</span>
 			ops-&gt;unmap(pipe, buf, addr);
 			if (unlikely(error)) {
 				/*
<span class="p_chunk">@@ -415,7 +421,6 @@</span> <span class="p_context"> redo:</span>
 				break;
 			}
 			ret += chars;
<span class="p_del">-			buf-&gt;offset += chars;</span>
 			buf-&gt;len -= chars;
 
 			/* Was it a packet buffer? Clean up and exit */
<span class="p_chunk">@@ -522,6 +527,7 @@</span> <span class="p_context"> pipe_write(struct kiocb *iocb, const struct iovec *_iov,</span>
 		if (ops-&gt;can_merge &amp;&amp; offset + chars &lt;= PAGE_SIZE) {
 			int error, atomic = 1;
 			void *addr;
<span class="p_add">+			size_t remaining = chars;</span>
 
 			error = ops-&gt;confirm(pipe, buf);
 			if (error)
<span class="p_chunk">@@ -530,8 +536,8 @@</span> <span class="p_context"> pipe_write(struct kiocb *iocb, const struct iovec *_iov,</span>
 			iov_fault_in_pages_read(iov, chars);
 redo1:
 			addr = ops-&gt;map(pipe, buf, atomic);
<span class="p_del">-			error = pipe_iov_copy_from_user(offset + addr, iov,</span>
<span class="p_del">-							chars, atomic);</span>
<span class="p_add">+			error = pipe_iov_copy_from_user(addr, &amp;offset, iov,</span>
<span class="p_add">+							&amp;remaining, atomic);</span>
 			ops-&gt;unmap(pipe, buf, addr);
 			ret = error;
 			do_wakeup = 1;
<span class="p_chunk">@@ -566,6 +572,8 @@</span> <span class="p_context"> redo1:</span>
 			struct page *page = pipe-&gt;tmp_page;
 			char *src;
 			int error, atomic = 1;
<span class="p_add">+			int offset = 0;</span>
<span class="p_add">+			size_t remaining;</span>
 
 			if (!page) {
 				page = alloc_page(GFP_HIGHUSER);
<span class="p_chunk">@@ -586,14 +594,15 @@</span> <span class="p_context"> redo1:</span>
 				chars = total_len;
 
 			iov_fault_in_pages_read(iov, chars);
<span class="p_add">+			remaining = chars;</span>
 redo2:
 			if (atomic)
 				src = kmap_atomic(page);
 			else
 				src = kmap(page);
 
<span class="p_del">-			error = pipe_iov_copy_from_user(src, iov, chars,</span>
<span class="p_del">-							atomic);</span>
<span class="p_add">+			error = pipe_iov_copy_from_user(src, &amp;offset, iov,</span>
<span class="p_add">+							&amp;remaining, atomic);</span>
 			if (atomic)
 				kunmap_atomic(src);
 			else
<span class="p_header">diff --git a/fs/udf/inode.c b/fs/udf/inode.c</span>
<span class="p_header">index 8053ee7..330ec8c 100644</span>
<span class="p_header">--- a/fs/udf/inode.c</span>
<span class="p_header">+++ b/fs/udf/inode.c</span>
<span class="p_chunk">@@ -1392,6 +1392,19 @@</span> <span class="p_context"> static void udf_fill_inode(struct inode *inode, struct buffer_head *bh)</span>
 							iinfo-&gt;i_lenEAttr;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Sanity check length of allocation descriptors and extended attrs to</span>
<span class="p_add">+	 * avoid integer overflows</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (iinfo-&gt;i_lenEAttr &gt; inode-&gt;i_sb-&gt;s_blocksize || iinfo-&gt;i_lenAlloc &gt; inode-&gt;i_sb-&gt;s_blocksize) {</span>
<span class="p_add">+		make_bad_inode(inode);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* Now do exact checks */</span>
<span class="p_add">+	if (udf_file_entry_alloc_offset(inode) + iinfo-&gt;i_lenAlloc &gt; inode-&gt;i_sb-&gt;s_blocksize) {</span>
<span class="p_add">+		make_bad_inode(inode);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 	/* Sanity checks for files in ICB so that we don&#39;t get confused later */
 	if (iinfo-&gt;i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {
 		/*
<span class="p_header">diff --git a/include/acpi/actypes.h b/include/acpi/actypes.h</span>
<span class="p_header">index e8bcc47..6d52429 100644</span>
<span class="p_header">--- a/include/acpi/actypes.h</span>
<span class="p_header">+++ b/include/acpi/actypes.h</span>
<span class="p_chunk">@@ -198,9 +198,29 @@</span> <span class="p_context"> typedef int INT32;</span>
 typedef s32 acpi_native_int;
 
 typedef u32 acpi_size;
<span class="p_add">+</span>
<span class="p_add">+#ifdef ACPI_32BIT_PHYSICAL_ADDRESS</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * OSPMs can define this to shrink the size of the structures for 32-bit</span>
<span class="p_add">+ * none PAE environment. ASL compiler may always define this to generate</span>
<span class="p_add">+ * 32-bit OSPM compliant tables.</span>
<span class="p_add">+ */</span>
 typedef u32 acpi_io_address;
 typedef u32 acpi_physical_address;
 
<span class="p_add">+#else				/* ACPI_32BIT_PHYSICAL_ADDRESS */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * It is reported that, after some calculations, the physical addresses can</span>
<span class="p_add">+ * wrap over the 32-bit boundary on 32-bit PAE environment.</span>
<span class="p_add">+ * https://bugzilla.kernel.org/show_bug.cgi?id=87971</span>
<span class="p_add">+ */</span>
<span class="p_add">+typedef u64 acpi_io_address;</span>
<span class="p_add">+typedef u64 acpi_physical_address;</span>
<span class="p_add">+</span>
<span class="p_add">+#endif				/* ACPI_32BIT_PHYSICAL_ADDRESS */</span>
<span class="p_add">+</span>
 #define ACPI_MAX_PTR                    ACPI_UINT32_MAX
 #define ACPI_SIZE_MAX                   ACPI_UINT32_MAX
 
<span class="p_header">diff --git a/include/acpi/platform/acenv.h b/include/acpi/platform/acenv.h</span>
<span class="p_header">index 5af3ed5..b9f9210 100644</span>
<span class="p_header">--- a/include/acpi/platform/acenv.h</span>
<span class="p_header">+++ b/include/acpi/platform/acenv.h</span>
<span class="p_chunk">@@ -75,6 +75,7 @@</span> <span class="p_context"></span>
 #define ACPI_CONSTANT_EVAL_ONLY
 #define ACPI_LARGE_NAMESPACE_NODE
 #define ACPI_DATA_TABLE_DISASSEMBLY
<span class="p_add">+#define ACPI_32BIT_PHYSICAL_ADDRESS</span>
 #endif
 
 #ifdef ACPI_EXEC_APP
<span class="p_header">diff --git a/include/linux/jhash.h b/include/linux/jhash.h</span>
<span class="p_header">index 47cb09e..348c6f4 100644</span>
<span class="p_header">--- a/include/linux/jhash.h</span>
<span class="p_header">+++ b/include/linux/jhash.h</span>
<span class="p_chunk">@@ -145,11 +145,11 @@</span> <span class="p_context"> static inline u32 jhash2(const u32 *k, u32 length, u32 initval)</span>
 }
 
 
<span class="p_del">-/* jhash_3words - hash exactly 3, 2 or 1 word(s) */</span>
<span class="p_del">-static inline u32 jhash_3words(u32 a, u32 b, u32 c, u32 initval)</span>
<span class="p_add">+/* __jhash_nwords - hash exactly 3, 2 or 1 word(s) */</span>
<span class="p_add">+static inline u32 __jhash_nwords(u32 a, u32 b, u32 c, u32 initval)</span>
 {
<span class="p_del">-	a += JHASH_INITVAL;</span>
<span class="p_del">-	b += JHASH_INITVAL;</span>
<span class="p_add">+	a += initval;</span>
<span class="p_add">+	b += initval;</span>
 	c += initval;
 
 	__jhash_final(a, b, c);
<span class="p_chunk">@@ -157,14 +157,19 @@</span> <span class="p_context"> static inline u32 jhash_3words(u32 a, u32 b, u32 c, u32 initval)</span>
 	return c;
 }
 
<span class="p_add">+static inline u32 jhash_3words(u32 a, u32 b, u32 c, u32 initval)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __jhash_nwords(a, b, c, initval + JHASH_INITVAL + (3 &lt;&lt; 2));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline u32 jhash_2words(u32 a, u32 b, u32 initval)
 {
<span class="p_del">-	return jhash_3words(a, b, 0, initval);</span>
<span class="p_add">+	return __jhash_nwords(a, b, 0, initval + JHASH_INITVAL + (2 &lt;&lt; 2));</span>
 }
 
 static inline u32 jhash_1word(u32 a, u32 initval)
 {
<span class="p_del">-	return jhash_3words(a, 0, 0, initval);</span>
<span class="p_add">+	return __jhash_nwords(a, 0, 0, initval + JHASH_INITVAL + (1 &lt;&lt; 2));</span>
 }
 
 #endif /* _LINUX_JHASH_H */
<span class="p_header">diff --git a/include/linux/libata.h b/include/linux/libata.h</span>
<span class="p_header">index 764cd54..35e7f71 100644</span>
<span class="p_header">--- a/include/linux/libata.h</span>
<span class="p_header">+++ b/include/linux/libata.h</span>
<span class="p_chunk">@@ -182,6 +182,7 @@</span> <span class="p_context"> enum {</span>
 	ATA_LFLAG_DISABLED	= (1 &lt;&lt; 6), /* link is disabled */
 	ATA_LFLAG_SW_ACTIVITY	= (1 &lt;&lt; 7), /* keep activity stats */
 	ATA_LFLAG_NO_LPM	= (1 &lt;&lt; 8), /* disable LPM on this link */
<span class="p_add">+	 ATA_LFLAG_CHANGED       = (1 &lt;&lt; 10), /* LPM state changed on this link */</span>
 
 	/* struct ata_port flags */
 	ATA_FLAG_SLAVE_POSS	= (1 &lt;&lt; 0), /* host supports slave dev */
<span class="p_chunk">@@ -285,6 +286,12 @@</span> <span class="p_context"> enum {</span>
 	 */
 	ATA_TMOUT_PMP_SRST_WAIT	= 5000,
 
<span class="p_add">+	/* When the LPM policy is set to ATA_LPM_MAX_POWER, there might</span>
<span class="p_add">+	 * be a spurious PHY event, so ignore the first PHY event that</span>
<span class="p_add">+	 * occurs within 10s after the policy change.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ATA_TMOUT_SPURIOUS_PHY	= 10000,</span>
<span class="p_add">+</span>
 	/* ATA bus states */
 	BUS_UNKNOWN		= 0,
 	BUS_DMA			= 1,
<span class="p_chunk">@@ -727,6 +734,8 @@</span> <span class="p_context"> struct ata_link {</span>
 	struct ata_eh_context	eh_context;
 
 	struct ata_device	device[ATA_MAX_DEVICES];
<span class="p_add">+</span>
<span class="p_add">+	unsigned long		last_lpm_change; /* when last LPM change happened */</span>
 };
 #define ATA_LINK_CLEAR_BEGIN		offsetof(struct ata_link, active_tag)
 #define ATA_LINK_CLEAR_END		offsetof(struct ata_link, device[0])
<span class="p_chunk">@@ -1065,6 +1074,7 @@</span> <span class="p_context"> extern struct ata_device *ata_dev_pair(struct ata_device *adev);</span>
 extern int ata_do_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);
 extern void ata_scsi_port_error_handler(struct Scsi_Host *host, struct ata_port *ap);
 extern void ata_scsi_cmd_error_handler(struct Scsi_Host *host, struct ata_port *ap, struct list_head *eh_q);
<span class="p_add">+extern bool sata_lpm_ignore_phy_events(struct ata_link *link);</span>
 
 extern int ata_cable_40wire(struct ata_port *ap);
 extern int ata_cable_80wire(struct ata_port *ap);
<span class="p_header">diff --git a/include/linux/nilfs2_fs.h b/include/linux/nilfs2_fs.h</span>
<span class="p_header">index 89bd4a4..25c6891 100644</span>
<span class="p_header">--- a/include/linux/nilfs2_fs.h</span>
<span class="p_header">+++ b/include/linux/nilfs2_fs.h</span>
<span class="p_chunk">@@ -458,7 +458,7 @@</span> <span class="p_context"> struct nilfs_btree_node {</span>
 /* level */
 #define NILFS_BTREE_LEVEL_DATA          0
 #define NILFS_BTREE_LEVEL_NODE_MIN      (NILFS_BTREE_LEVEL_DATA + 1)
<span class="p_del">-#define NILFS_BTREE_LEVEL_MAX           14</span>
<span class="p_add">+#define NILFS_BTREE_LEVEL_MAX           14	/* Max level (exclusive) */</span>
 
 /**
  * struct nilfs_palloc_group_desc - block group descriptor
<span class="p_header">diff --git a/include/scsi/scsi_devinfo.h b/include/scsi/scsi_devinfo.h</span>
<span class="p_header">index b4ddd3b..fc8cdff 100644</span>
<span class="p_header">--- a/include/scsi/scsi_devinfo.h</span>
<span class="p_header">+++ b/include/scsi/scsi_devinfo.h</span>
<span class="p_chunk">@@ -30,4 +30,5 @@</span> <span class="p_context"></span>
 #define BLIST_RETRY_HWERROR	0x400000 /* retry HARDWARE_ERROR */
 #define BLIST_MAX_512		0x800000 /* maximum 512 sector cdb length */
 #define BLIST_ATTACH_PQ3	0x1000000 /* Scan: Attach to PQ3 devices */
<span class="p_add">+#define BLIST_MAX_1024		0x40000000 /* maximum 1024 sector cdb length */</span>
 #endif
<span class="p_header">diff --git a/include/sound/emu10k1.h b/include/sound/emu10k1.h</span>
<span class="p_header">index 4f865df..7ee55e3 100644</span>
<span class="p_header">--- a/include/sound/emu10k1.h</span>
<span class="p_header">+++ b/include/sound/emu10k1.h</span>
<span class="p_chunk">@@ -43,7 +43,8 @@</span> <span class="p_context"></span>
 
 #define EMUPAGESIZE     4096
 #define MAXREQVOICES    8
<span class="p_del">-#define MAXPAGES        8192</span>
<span class="p_add">+#define MAXPAGES0       4096	/* 32 bit mode */</span>
<span class="p_add">+#define MAXPAGES1       8192	/* 31 bit mode */</span>
 #define RESERVED        0
 #define NUM_MIDI        16
 #define NUM_G           64              /* use all channels */
<span class="p_chunk">@@ -52,8 +53,7 @@</span> <span class="p_context"></span>
 
 /* FIXME? - according to the OSS driver the EMU10K1 needs a 29 bit DMA mask */
 #define EMU10K1_DMA_MASK	0x7fffffffUL	/* 31bit */
<span class="p_del">-#define AUDIGY_DMA_MASK		0x7fffffffUL	/* 31bit FIXME - 32 should work? */</span>
<span class="p_del">-						/* See ALSA bug #1276 - rlrevell */</span>
<span class="p_add">+#define AUDIGY_DMA_MASK		0xffffffffUL	/* 32bit mode */</span>
 
 #define TMEMSIZE        256*1024
 #define TMEMSIZEREG     4
<span class="p_chunk">@@ -470,8 +470,11 @@</span> <span class="p_context"></span>
 
 #define MAPB			0x0d		/* Cache map B						*/
 
<span class="p_del">-#define MAP_PTE_MASK		0xffffe000	/* The 19 MSBs of the PTE indexed by the PTI		*/</span>
<span class="p_del">-#define MAP_PTI_MASK		0x00001fff	/* The 13 bit index to one of the 8192 PTE dwords      	*/</span>
<span class="p_add">+#define MAP_PTE_MASK0		0xfffff000	/* The 20 MSBs of the PTE indexed by the PTI		*/</span>
<span class="p_add">+#define MAP_PTI_MASK0		0x00000fff	/* The 12 bit index to one of the 4096 PTE dwords      	*/</span>
<span class="p_add">+</span>
<span class="p_add">+#define MAP_PTE_MASK1		0xffffe000	/* The 19 MSBs of the PTE indexed by the PTI		*/</span>
<span class="p_add">+#define MAP_PTI_MASK1		0x00001fff	/* The 13 bit index to one of the 8192 PTE dwords      	*/</span>
 
 /* 0x0e, 0x0f: Not used */
 
<span class="p_chunk">@@ -1708,6 +1711,7 @@</span> <span class="p_context"> struct snd_emu10k1 {</span>
 	unsigned short model;			/* subsystem id */
 	unsigned int card_type;			/* EMU10K1_CARD_* */
 	unsigned int ecard_ctrl;		/* ecard control bits */
<span class="p_add">+	unsigned int address_mode;		/* address mode */</span>
 	unsigned long dma_mask;			/* PCI DMA mask */
 	unsigned int delay_pcm_irq;		/* in samples */
 	int max_cache_pages;			/* max memory size / PAGE_SIZE */
<span class="p_header">diff --git a/include/xen/events.h b/include/xen/events.h</span>
<span class="p_header">index 04399b2..f9cb630 100644</span>
<span class="p_header">--- a/include/xen/events.h</span>
<span class="p_header">+++ b/include/xen/events.h</span>
<span class="p_chunk">@@ -12,7 +12,7 @@</span> <span class="p_context"> int bind_evtchn_to_irqhandler(unsigned int evtchn,</span>
 			      irq_handler_t handler,
 			      unsigned long irqflags, const char *devname,
 			      void *dev_id);
<span class="p_del">-int bind_virq_to_irq(unsigned int virq, unsigned int cpu);</span>
<span class="p_add">+int bind_virq_to_irq(unsigned int virq, unsigned int cpu, bool percpu);</span>
 int bind_virq_to_irqhandler(unsigned int virq, unsigned int cpu,
 			    irq_handler_t handler,
 			    unsigned long irqflags, const char *devname,
<span class="p_header">diff --git a/kernel/ptrace.c b/kernel/ptrace.c</span>
<span class="p_header">index a143236..d9e71e3 100644</span>
<span class="p_header">--- a/kernel/ptrace.c</span>
<span class="p_header">+++ b/kernel/ptrace.c</span>
<span class="p_chunk">@@ -632,6 +632,8 @@</span> <span class="p_context"> static int ptrace_setsiginfo(struct task_struct *child, const siginfo_t *info)</span>
 static int ptrace_resume(struct task_struct *child, long request,
 			 unsigned long data)
 {
<span class="p_add">+	bool need_siglock;</span>
<span class="p_add">+</span>
 	if (!valid_signal(data))
 		return -EIO;
 
<span class="p_chunk">@@ -659,8 +661,26 @@</span> <span class="p_context"> static int ptrace_resume(struct task_struct *child, long request,</span>
 		user_disable_single_step(child);
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Change -&gt;exit_code and -&gt;state under siglock to avoid the race</span>
<span class="p_add">+	 * with wait_task_stopped() in between; a non-zero -&gt;exit_code will</span>
<span class="p_add">+	 * wrongly look like another report from tracee.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note that we need siglock even if -&gt;exit_code == data and/or this</span>
<span class="p_add">+	 * status was not reported yet, the new status must not be cleared by</span>
<span class="p_add">+	 * wait_task_stopped() after resume.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * If data == 0 we do not care if wait_task_stopped() reports the old</span>
<span class="p_add">+	 * status and clears the code too; this can&#39;t race with the tracee, it</span>
<span class="p_add">+	 * takes siglock after resume.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	need_siglock = data &amp;&amp; !thread_group_empty(current);</span>
<span class="p_add">+	if (need_siglock)</span>
<span class="p_add">+		spin_lock_irq(&amp;child-&gt;sighand-&gt;siglock);</span>
 	child-&gt;exit_code = data;
 	wake_up_state(child, __TASK_TRACED);
<span class="p_add">+	if (need_siglock)</span>
<span class="p_add">+		spin_unlock_irq(&amp;child-&gt;sighand-&gt;siglock);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 2f8363e..15be435 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -4396,8 +4396,13 @@</span> <span class="p_context"> recheck:</span>
 
 	if (running)
 		p-&gt;sched_class-&gt;set_curr_task(rq);
<span class="p_del">-	if (on_rq)</span>
<span class="p_del">-		enqueue_task(rq, p, 0);</span>
<span class="p_add">+	if (on_rq) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We enqueue to tail when the priority of a task is</span>
<span class="p_add">+		 * increased (user space view).</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		enqueue_task(rq, p, oldprio &lt;= p-&gt;prio ? ENQUEUE_HEAD : 0);</span>
<span class="p_add">+	}</span>
 
 	check_class_changed(rq, p, prev_class, oldprio);
 	task_rq_unlock(rq, p, &amp;flags);
<span class="p_header">diff --git a/kernel/trace/ring_buffer_benchmark.c b/kernel/trace/ring_buffer_benchmark.c</span>
<span class="p_header">index a5457d5..6ad2e2d 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer_benchmark.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer_benchmark.c</span>
<span class="p_chunk">@@ -455,7 +455,7 @@</span> <span class="p_context"> static int __init ring_buffer_benchmark_init(void)</span>
 
 	if (producer_fifo &gt;= 0) {
 		struct sched_param param = {
<span class="p_del">-			.sched_priority = consumer_fifo</span>
<span class="p_add">+			.sched_priority = producer_fifo</span>
 		};
 		sched_setscheduler(producer, SCHED_FIFO, &amp;param);
 	} else
<span class="p_header">diff --git a/kernel/trace/trace_events_filter.c b/kernel/trace/trace_events_filter.c</span>
<span class="p_header">index 289197a..3b04aec 100644</span>
<span class="p_header">--- a/kernel/trace/trace_events_filter.c</span>
<span class="p_header">+++ b/kernel/trace/trace_events_filter.c</span>
<span class="p_chunk">@@ -1357,19 +1357,25 @@</span> <span class="p_context"> static int check_preds(struct filter_parse_state *ps)</span>
 {
 	int n_normal_preds = 0, n_logical_preds = 0;
 	struct postfix_elt *elt;
<span class="p_add">+	int cnt = 0;</span>
 
 	list_for_each_entry(elt, &amp;ps-&gt;postfix, list) {
<span class="p_del">-		if (elt-&gt;op == OP_NONE)</span>
<span class="p_add">+		if (elt-&gt;op == OP_NONE) {</span>
<span class="p_add">+			cnt++;</span>
 			continue;
<span class="p_add">+		}</span>
 
 		if (elt-&gt;op == OP_AND || elt-&gt;op == OP_OR) {
 			n_logical_preds++;
<span class="p_add">+			cnt--;</span>
 			continue;
 		}
<span class="p_add">+		cnt--;</span>
 		n_normal_preds++;
<span class="p_add">+		WARN_ON_ONCE(cnt &lt; 0);</span>
 	}
 
<span class="p_del">-	if (!n_normal_preds || n_logical_preds &gt;= n_normal_preds) {</span>
<span class="p_add">+	if (cnt != 1 || !n_normal_preds || n_logical_preds &gt;= n_normal_preds) {</span>
 		parse_error(ps, FILT_ERR_INVALID_FILTER, 0);
 		return -EINVAL;
 	}
<span class="p_header">diff --git a/mm/memory-failure.c b/mm/memory-failure.c</span>
<span class="p_header">index 97eec21..c957a37 100644</span>
<span class="p_header">--- a/mm/memory-failure.c</span>
<span class="p_header">+++ b/mm/memory-failure.c</span>
<span class="p_chunk">@@ -1095,10 +1095,10 @@</span> <span class="p_context"> int memory_failure(unsigned long pfn, int trapno, int flags)</span>
 	 * The check (unnecessarily) ignores LRU pages being isolated and
 	 * walked by the page reclaim code, however that&#39;s not a big loss.
 	 */
<span class="p_del">-	if (!PageHuge(p) &amp;&amp; !PageTransTail(p)) {</span>
<span class="p_del">-		if (!PageLRU(p))</span>
<span class="p_del">-			shake_page(p, 0);</span>
<span class="p_del">-		if (!PageLRU(p)) {</span>
<span class="p_add">+	if (!PageHuge(p)) {</span>
<span class="p_add">+		if (!PageLRU(hpage))</span>
<span class="p_add">+			shake_page(hpage, 0);</span>
<span class="p_add">+		if (!PageLRU(hpage)) {</span>
 			/*
 			 * shake_page could have turned it free.
 			 */
<span class="p_header">diff --git a/net/bridge/br_fdb.c b/net/bridge/br_fdb.c</span>
<span class="p_header">index 5ba0c84..3cb93e8 100644</span>
<span class="p_header">--- a/net/bridge/br_fdb.c</span>
<span class="p_header">+++ b/net/bridge/br_fdb.c</span>
<span class="p_chunk">@@ -440,7 +440,7 @@</span> <span class="p_context"> void br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,</span>
 			fdb-&gt;updated = jiffies;
 		}
 	} else {
<span class="p_del">-		spin_lock(&amp;br-&gt;hash_lock);</span>
<span class="p_add">+		spin_lock_bh(&amp;br-&gt;hash_lock);</span>
 		if (likely(!fdb_find(head, addr))) {
 			fdb = fdb_create(head, source, addr);
 			if (fdb)
<span class="p_chunk">@@ -449,7 +449,7 @@</span> <span class="p_context"> void br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,</span>
 		/* else  we lose race and someone else inserts
 		 * it first, don&#39;t bother updating
 		 */
<span class="p_del">-		spin_unlock(&amp;br-&gt;hash_lock);</span>
<span class="p_add">+		spin_unlock_bh(&amp;br-&gt;hash_lock);</span>
 	}
 }
 
<span class="p_chunk">@@ -665,9 +665,11 @@</span> <span class="p_context"> int br_fdb_add(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)</span>
 	}
 
 	if (ndm-&gt;ndm_flags &amp; NTF_USE) {
<span class="p_add">+		local_bh_disable();</span>
 		rcu_read_lock();
 		br_fdb_update(p-&gt;br, p, addr);
 		rcu_read_unlock();
<span class="p_add">+		local_bh_enable();</span>
 	} else {
 		spin_lock_bh(&amp;p-&gt;br-&gt;hash_lock);
 		err = fdb_add_entry(p, addr, ndm-&gt;ndm_state, nlh-&gt;nlmsg_flags);
<span class="p_header">diff --git a/net/bridge/br_multicast.c b/net/bridge/br_multicast.c</span>
<span class="p_header">index 0b870d7..a41051a 100644</span>
<span class="p_header">--- a/net/bridge/br_multicast.c</span>
<span class="p_header">+++ b/net/bridge/br_multicast.c</span>
<span class="p_chunk">@@ -972,7 +972,7 @@</span> <span class="p_context"> static int br_ip6_multicast_mld2_report(struct net_bridge *br,</span>
 		}
 
 		err = br_ip6_multicast_add_group(br, port, &amp;grec-&gt;grec_mca);
<span class="p_del">-		if (!err)</span>
<span class="p_add">+		if (err)</span>
 			break;
 	}
 
<span class="p_chunk">@@ -991,6 +991,9 @@</span> <span class="p_context"> static void br_multicast_add_router(struct net_bridge *br,</span>
 	struct net_bridge_port *p;
 	struct hlist_node *n, *slot = NULL;
 
<span class="p_add">+	if (!hlist_unhashed(&amp;port-&gt;rlist))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	hlist_for_each_entry(p, n, &amp;br-&gt;router_list, rlist) {
 		if ((unsigned long) port &gt;= (unsigned long) p)
 			break;
<span class="p_chunk">@@ -1018,12 +1021,8 @@</span> <span class="p_context"> static void br_multicast_mark_router(struct net_bridge *br,</span>
 	if (port-&gt;multicast_router != 1)
 		return;
 
<span class="p_del">-	if (!hlist_unhashed(&amp;port-&gt;rlist))</span>
<span class="p_del">-		goto timer;</span>
<span class="p_del">-</span>
 	br_multicast_add_router(br, port);
 
<span class="p_del">-timer:</span>
 	mod_timer(&amp;port-&gt;multicast_router_timer,
 		  now + br-&gt;multicast_querier_interval);
 }
<span class="p_header">diff --git a/net/bridge/br_netfilter.c b/net/bridge/br_netfilter.c</span>
<span class="p_header">index e54ef82..5ba4248 100644</span>
<span class="p_header">--- a/net/bridge/br_netfilter.c</span>
<span class="p_header">+++ b/net/bridge/br_netfilter.c</span>
<span class="p_chunk">@@ -818,12 +818,12 @@</span> <span class="p_context"> static unsigned int br_nf_forward_arp(unsigned int hook, struct sk_buff *skb,</span>
 	return NF_STOLEN;
 }
 
<span class="p_del">-#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV4)</span>
<span class="p_add">+#if IS_ENABLED(CONFIG_NF_DEFRAG_IPV4)</span>
 static int br_nf_dev_queue_xmit(struct sk_buff *skb)
 {
 	int ret;
 
<span class="p_del">-	if (skb-&gt;nfct != NULL &amp;&amp; skb-&gt;protocol == htons(ETH_P_IP) &amp;&amp;</span>
<span class="p_add">+	if (skb-&gt;protocol == htons(ETH_P_IP) &amp;&amp;</span>
 	    skb-&gt;len + nf_bridge_mtu_reduction(skb) &gt; skb-&gt;dev-&gt;mtu &amp;&amp;
 	    !skb_is_gso(skb)) {
 		if (br_parse_ip_options(skb))
<span class="p_header">diff --git a/net/ipv4/ping.c b/net/ipv4/ping.c</span>
<span class="p_header">index cb90852..9f471c3 100644</span>
<span class="p_header">--- a/net/ipv4/ping.c</span>
<span class="p_header">+++ b/net/ipv4/ping.c</span>
<span class="p_chunk">@@ -138,6 +138,7 @@</span> <span class="p_context"> static void ping_v4_unhash(struct sock *sk)</span>
 	if (sk_hashed(sk)) {
 		write_lock_bh(&amp;ping_table.lock);
 		hlist_nulls_del(&amp;sk-&gt;sk_nulls_node);
<span class="p_add">+		sk_nulls_node_init(&amp;sk-&gt;sk_nulls_node);</span>
 		sock_put(sk);
 		isk-&gt;inet_num = 0;
 		isk-&gt;inet_sport = 0;
<span class="p_header">diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c</span>
<span class="p_header">index 7949b5d..5f8c20b 100644</span>
<span class="p_header">--- a/net/ipv4/udp.c</span>
<span class="p_header">+++ b/net/ipv4/udp.c</span>
<span class="p_chunk">@@ -1251,10 +1251,8 @@</span> <span class="p_context"> csum_copy_err:</span>
 		UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_INERRORS, is_udplite);
 	unlock_sock_fast(sk, slow);
 
<span class="p_del">-	if (noblock)</span>
<span class="p_del">-		return -EAGAIN;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* starting over for a new packet */</span>
<span class="p_add">+	/* starting over for a new packet, but check if we need to yield */</span>
<span class="p_add">+	cond_resched();</span>
 	msg-&gt;msg_flags &amp;= ~MSG_TRUNC;
 	goto try_again;
 }
<span class="p_header">diff --git a/net/ipv6/route.c b/net/ipv6/route.c</span>
<span class="p_header">index 4cfba3d..6a80567 100644</span>
<span class="p_header">--- a/net/ipv6/route.c</span>
<span class="p_header">+++ b/net/ipv6/route.c</span>
<span class="p_chunk">@@ -1661,6 +1661,28 @@</span> <span class="p_context"> void rt6_redirect(const struct in6_addr *dest, const struct in6_addr *src,</span>
 		goto out;
 	}
 
<span class="p_add">+#ifdef CONFIG_IPV6_MULTIPLE_TABLES</span>
<span class="p_add">+	if (rt == net-&gt;ipv6.ip6_blk_hole_entry ||</span>
<span class="p_add">+	    rt == net-&gt;ipv6.ip6_prohibit_entry) {</span>
<span class="p_add">+		if (net_ratelimit())</span>
<span class="p_add">+			printk(KERN_DEBUG &quot;rt6_redirect: source isn&#39;t a valid&quot; \</span>
<span class="p_add">+			       &quot; nexthop for redirect target &quot; \</span>
<span class="p_add">+			       &quot;(blackhole or prohibited)\n&quot;);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_IPV6_MULTIPLE_TABLES</span>
<span class="p_add">+	if (rt == net-&gt;ipv6.ip6_blk_hole_entry ||</span>
<span class="p_add">+	    rt == net-&gt;ipv6.ip6_prohibit_entry) {</span>
<span class="p_add">+		if (net_ratelimit())</span>
<span class="p_add">+			printk(KERN_DEBUG &quot;rt6_redirect: source isn&#39;t a valid&quot; \</span>
<span class="p_add">+			       &quot; nexthop for redirect target &quot; \</span>
<span class="p_add">+			       &quot;(blackhole or prohibited)\n&quot;);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	/*
 	 *	We have finally decided to accept it.
 	 */
<span class="p_header">diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c</span>
<span class="p_header">index ef9052f..2f99b12 100644</span>
<span class="p_header">--- a/net/ipv6/udp.c</span>
<span class="p_header">+++ b/net/ipv6/udp.c</span>
<span class="p_chunk">@@ -451,10 +451,8 @@</span> <span class="p_context"> csum_copy_err:</span>
 	}
 	unlock_sock_fast(sk, slow);
 
<span class="p_del">-	if (noblock)</span>
<span class="p_del">-		return -EAGAIN;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* starting over for a new packet */</span>
<span class="p_add">+	/* starting over for a new packet, but check if we need to yield */</span>
<span class="p_add">+	cond_resched();</span>
 	msg-&gt;msg_flags &amp;= ~MSG_TRUNC;
 	goto try_again;
 }
<span class="p_header">diff --git a/net/mac80211/wep.c b/net/mac80211/wep.c</span>
<span class="p_header">index 7aa31bb..9464f92 100644</span>
<span class="p_header">--- a/net/mac80211/wep.c</span>
<span class="p_header">+++ b/net/mac80211/wep.c</span>
<span class="p_chunk">@@ -97,8 +97,7 @@</span> <span class="p_context"> static u8 *ieee80211_wep_add_iv(struct ieee80211_local *local,</span>
 
 	hdr-&gt;frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);
 
<span class="p_del">-	if (WARN_ON(skb_tailroom(skb) &lt; WEP_ICV_LEN ||</span>
<span class="p_del">-		    skb_headroom(skb) &lt; WEP_IV_LEN))</span>
<span class="p_add">+	if (WARN_ON(skb_headroom(skb) &lt; WEP_IV_LEN))</span>
 		return NULL;
 
 	hdrlen = ieee80211_hdrlen(hdr-&gt;frame_control);
<span class="p_chunk">@@ -160,6 +159,9 @@</span> <span class="p_context"> int ieee80211_wep_encrypt(struct ieee80211_local *local,</span>
 	size_t len;
 	u8 rc4key[3 + WLAN_KEY_LEN_WEP104];
 
<span class="p_add">+	if (WARN_ON(skb_tailroom(skb) &lt; WEP_ICV_LEN))</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+</span>
 	iv = ieee80211_wep_add_iv(local, skb, keylen, keyidx);
 	if (!iv)
 		return -1;
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_ctl.c b/net/netfilter/ipvs/ip_vs_ctl.c</span>
<span class="p_header">index cbc5bfd..f2ed4a9 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_ctl.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_ctl.c</span>
<span class="p_chunk">@@ -3689,6 +3689,9 @@</span> <span class="p_context"> void __net_exit ip_vs_control_net_cleanup_sysctl(struct net *net)</span>
 	cancel_delayed_work_sync(&amp;ipvs-&gt;defense_work);
 	cancel_work_sync(&amp;ipvs-&gt;defense_work.work);
 	unregister_net_sysctl_table(ipvs-&gt;sysctl_hdr);
<span class="p_add">+</span>
<span class="p_add">+	if (!net_eq(net, &amp;init_net))</span>
<span class="p_add">+		kfree(ipvs-&gt;sysctl_tbl);</span>
 }
 
 #else
<span class="p_header">diff --git a/net/rose/af_rose.c b/net/rose/af_rose.c</span>
<span class="p_header">index bde7d69..e895636 100644</span>
<span class="p_header">--- a/net/rose/af_rose.c</span>
<span class="p_header">+++ b/net/rose/af_rose.c</span>
<span class="p_chunk">@@ -194,7 +194,8 @@</span> <span class="p_context"> static void rose_kill_by_device(struct net_device *dev)</span>
 
 		if (rose-&gt;device == dev) {
 			rose_disconnect(s, ENETUNREACH, ROSE_OUT_OF_ORDER, 0);
<span class="p_del">-			rose-&gt;neighbour-&gt;use--;</span>
<span class="p_add">+			if (rose-&gt;neighbour)</span>
<span class="p_add">+				rose-&gt;neighbour-&gt;use--;</span>
 			rose-&gt;device = NULL;
 		}
 	}
<span class="p_header">diff --git a/net/socket.c b/net/socket.c</span>
<span class="p_header">index 025f7f4..f5ce151 100644</span>
<span class="p_header">--- a/net/socket.c</span>
<span class="p_header">+++ b/net/socket.c</span>
<span class="p_chunk">@@ -1934,14 +1934,12 @@</span> <span class="p_context"> static int ___sys_sendmsg(struct socket *sock, struct msghdr __user *msg,</span>
 	int err, ctl_len, iov_size, total_len;
 
 	err = -EFAULT;
<span class="p_del">-	if (MSG_CMSG_COMPAT &amp; flags) {</span>
<span class="p_del">-		if (get_compat_msghdr(msg_sys, msg_compat))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-	} else {</span>
<span class="p_add">+	if (MSG_CMSG_COMPAT &amp; flags)</span>
<span class="p_add">+		err = get_compat_msghdr(msg_sys, msg_compat);</span>
<span class="p_add">+	else</span>
 		err = copy_msghdr_from_user(msg_sys, msg);
<span class="p_del">-		if (err)</span>
<span class="p_del">-			return err;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
 
 	/* do not move before msg_sys is valid */
 	err = -EMSGSIZE;
<span class="p_chunk">@@ -2149,14 +2147,12 @@</span> <span class="p_context"> static int ___sys_recvmsg(struct socket *sock, struct msghdr __user *msg,</span>
 	struct sockaddr __user *uaddr;
 	int __user *uaddr_len;
 
<span class="p_del">-	if (MSG_CMSG_COMPAT &amp; flags) {</span>
<span class="p_del">-		if (get_compat_msghdr(msg_sys, msg_compat))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-	} else {</span>
<span class="p_add">+	if (MSG_CMSG_COMPAT &amp; flags)</span>
<span class="p_add">+		err = get_compat_msghdr(msg_sys, msg_compat);</span>
<span class="p_add">+	else</span>
 		err = copy_msghdr_from_user(msg_sys, msg);
<span class="p_del">-		if (err)</span>
<span class="p_del">-			return err;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
 
 	err = -EMSGSIZE;
 	if (msg_sys-&gt;msg_iovlen &gt; UIO_MAXIOV)
<span class="p_header">diff --git a/security/selinux/nlmsgtab.c b/security/selinux/nlmsgtab.c</span>
<span class="p_header">index 0920ea3..5776921 100644</span>
<span class="p_header">--- a/security/selinux/nlmsgtab.c</span>
<span class="p_header">+++ b/security/selinux/nlmsgtab.c</span>
<span class="p_chunk">@@ -100,6 +100,12 @@</span> <span class="p_context"> static struct nlmsg_perm nlmsg_xfrm_perms[] =</span>
 	{ XFRM_MSG_FLUSHPOLICY,	NETLINK_XFRM_SOCKET__NLMSG_WRITE },
 	{ XFRM_MSG_NEWAE,	NETLINK_XFRM_SOCKET__NLMSG_WRITE },
 	{ XFRM_MSG_GETAE,	NETLINK_XFRM_SOCKET__NLMSG_READ  },
<span class="p_add">+	{ XFRM_MSG_REPORT,	NETLINK_XFRM_SOCKET__NLMSG_READ  },</span>
<span class="p_add">+	{ XFRM_MSG_MIGRATE,	NETLINK_XFRM_SOCKET__NLMSG_WRITE },</span>
<span class="p_add">+	{ XFRM_MSG_NEWSADINFO,	NETLINK_XFRM_SOCKET__NLMSG_READ  },</span>
<span class="p_add">+	{ XFRM_MSG_GETSADINFO,	NETLINK_XFRM_SOCKET__NLMSG_READ  },</span>
<span class="p_add">+	{ XFRM_MSG_GETSPDINFO,	NETLINK_XFRM_SOCKET__NLMSG_READ  },</span>
<span class="p_add">+	{ XFRM_MSG_MAPPING,	NETLINK_XFRM_SOCKET__NLMSG_READ  },</span>
 };
 
 static struct nlmsg_perm nlmsg_audit_perms[] =
<span class="p_header">diff --git a/sound/pci/emu10k1/emu10k1.c b/sound/pci/emu10k1/emu10k1.c</span>
<span class="p_header">index 790c65d..aefde01 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emu10k1.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emu10k1.c</span>
<span class="p_chunk">@@ -181,8 +181,10 @@</span> <span class="p_context"> static int __devinit snd_card_emu10k1_probe(struct pci_dev *pci,</span>
 	}
 #endif
  
<span class="p_del">-	strcpy(card-&gt;driver, emu-&gt;card_capabilities-&gt;driver);</span>
<span class="p_del">-	strcpy(card-&gt;shortname, emu-&gt;card_capabilities-&gt;name);</span>
<span class="p_add">+	strlcpy(card-&gt;driver, emu-&gt;card_capabilities-&gt;driver,</span>
<span class="p_add">+		sizeof(card-&gt;driver));</span>
<span class="p_add">+	strlcpy(card-&gt;shortname, emu-&gt;card_capabilities-&gt;name,</span>
<span class="p_add">+		sizeof(card-&gt;shortname));</span>
 	snprintf(card-&gt;longname, sizeof(card-&gt;longname),
 		 &quot;%s (rev.%d, serial:0x%x) at 0x%lx, irq %i&quot;,
 		 card-&gt;shortname, emu-&gt;revision, emu-&gt;serial, emu-&gt;port, emu-&gt;irq);
<span class="p_header">diff --git a/sound/pci/emu10k1/emu10k1_callback.c b/sound/pci/emu10k1/emu10k1_callback.c</span>
<span class="p_header">index f35284b..8295950 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emu10k1_callback.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emu10k1_callback.c</span>
<span class="p_chunk">@@ -415,7 +415,7 @@</span> <span class="p_context"> start_voice(struct snd_emux_voice *vp)</span>
 	snd_emu10k1_ptr_write(hw, Z2, ch, 0);
 
 	/* invalidate maps */
<span class="p_del">-	temp = (hw-&gt;silent_page.addr &lt;&lt; 1) | MAP_PTI_MASK;</span>
<span class="p_add">+	temp = (hw-&gt;silent_page.addr &lt;&lt; hw-&gt;address_mode) | (hw-&gt;address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);</span>
 	snd_emu10k1_ptr_write(hw, MAPA, ch, temp);
 	snd_emu10k1_ptr_write(hw, MAPB, ch, temp);
 #if 0
<span class="p_chunk">@@ -436,7 +436,7 @@</span> <span class="p_context"> start_voice(struct snd_emux_voice *vp)</span>
 		snd_emu10k1_ptr_write(hw, CDF, ch, sample);
 
 		/* invalidate maps */
<span class="p_del">-		temp = ((unsigned int)hw-&gt;silent_page.addr &lt;&lt; 1) | MAP_PTI_MASK;</span>
<span class="p_add">+		temp = ((unsigned int)hw-&gt;silent_page.addr &lt;&lt; hw_address_mode) | (hw-&gt;address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);</span>
 		snd_emu10k1_ptr_write(hw, MAPA, ch, temp);
 		snd_emu10k1_ptr_write(hw, MAPB, ch, temp);
 		
<span class="p_header">diff --git a/sound/pci/emu10k1/emu10k1_main.c b/sound/pci/emu10k1/emu10k1_main.c</span>
<span class="p_header">index a78fdf4..124ae93 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emu10k1_main.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emu10k1_main.c</span>
<span class="p_chunk">@@ -282,7 +282,7 @@</span> <span class="p_context"> static int snd_emu10k1_init(struct snd_emu10k1 *emu, int enable_ir, int resume)</span>
 	snd_emu10k1_ptr_write(emu, TCB, 0, 0);	/* taken from original driver */
 	snd_emu10k1_ptr_write(emu, TCBS, 0, 4);	/* taken from original driver */
 
<span class="p_del">-	silent_page = (emu-&gt;silent_page.addr &lt;&lt; 1) | MAP_PTI_MASK;</span>
<span class="p_add">+	silent_page = (emu-&gt;silent_page.addr &lt;&lt; emu-&gt;address_mode) | (emu-&gt;address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);</span>
 	for (ch = 0; ch &lt; NUM_G; ch++) {
 		snd_emu10k1_ptr_write(emu, MAPA, ch, silent_page);
 		snd_emu10k1_ptr_write(emu, MAPB, ch, silent_page);
<span class="p_chunk">@@ -348,6 +348,11 @@</span> <span class="p_context"> static int snd_emu10k1_init(struct snd_emu10k1 *emu, int enable_ir, int resume)</span>
 		outl(reg | A_IOCFG_GPOUT0, emu-&gt;port + A_IOCFG);
 	}
 
<span class="p_add">+	if (emu-&gt;address_mode == 0) {</span>
<span class="p_add">+		/* use 16M in 4G */</span>
<span class="p_add">+		outl(inl(emu-&gt;port + HCFG) | HCFG_EXPANDED_MEM, emu-&gt;port + HCFG);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1390,7 +1395,7 @@</span> <span class="p_context"> static struct snd_emu_chip_details emu_chip_details[] = {</span>
 	 *
 	 */
 	{.vendor = 0x1102, .device = 0x0008, .subsystem = 0x20011102,
<span class="p_del">-	 .driver = &quot;Audigy2&quot;, .name = &quot;SB Audigy 2 ZS Notebook [SB0530]&quot;,</span>
<span class="p_add">+	 .driver = &quot;Audigy2&quot;, .name = &quot;Audigy 2 ZS Notebook [SB0530]&quot;,</span>
 	 .id = &quot;Audigy2&quot;,
 	 .emu10k2_chip = 1,
 	 .ca0108_chip = 1,
<span class="p_chunk">@@ -1540,7 +1545,7 @@</span> <span class="p_context"> static struct snd_emu_chip_details emu_chip_details[] = {</span>
 	 .adc_1361t = 1,  /* 24 bit capture instead of 16bit */
 	 .ac97_chip = 1} ,
 	{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x10051102,
<span class="p_del">-	 .driver = &quot;Audigy2&quot;, .name = &quot;SB Audigy 2 Platinum EX [SB0280]&quot;,</span>
<span class="p_add">+	 .driver = &quot;Audigy2&quot;, .name = &quot;Audigy 2 Platinum EX [SB0280]&quot;,</span>
 	 .id = &quot;Audigy2&quot;,
 	 .emu10k2_chip = 1,
 	 .ca0102_chip = 1,
<span class="p_chunk">@@ -1844,8 +1849,10 @@</span> <span class="p_context"> int __devinit snd_emu10k1_create(struct snd_card *card,</span>
 
 	is_audigy = emu-&gt;audigy = c-&gt;emu10k2_chip;
 
<span class="p_add">+	/* set addressing mode */</span>
<span class="p_add">+	emu-&gt;address_mode = is_audigy ? 0 : 1;</span>
 	/* set the DMA transfer mask */
<span class="p_del">-	emu-&gt;dma_mask = is_audigy ? AUDIGY_DMA_MASK : EMU10K1_DMA_MASK;</span>
<span class="p_add">+	emu-&gt;dma_mask = emu-&gt;address_mode ? EMU10K1_DMA_MASK : AUDIGY_DMA_MASK;</span>
 	if (pci_set_dma_mask(pci, emu-&gt;dma_mask) &lt; 0 ||
 	    pci_set_consistent_dma_mask(pci, emu-&gt;dma_mask) &lt; 0) {
 		snd_printk(KERN_ERR &quot;architecture does not support PCI busmaster DMA with mask 0x%lx\n&quot;, emu-&gt;dma_mask);
<span class="p_chunk">@@ -1868,7 +1875,7 @@</span> <span class="p_context"> int __devinit snd_emu10k1_create(struct snd_card *card,</span>
 
 	emu-&gt;max_cache_pages = max_cache_bytes &gt;&gt; PAGE_SHIFT;
 	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
<span class="p_del">-				32 * 1024, &amp;emu-&gt;ptb_pages) &lt; 0) {</span>
<span class="p_add">+				(emu-&gt;address_mode ? 32 : 16) * 1024, &amp;emu-&gt;ptb_pages) &lt; 0) {</span>
 		err = -ENOMEM;
 		goto error;
 	}
<span class="p_chunk">@@ -1967,8 +1974,8 @@</span> <span class="p_context"> int __devinit snd_emu10k1_create(struct snd_card *card,</span>
 
 	/* Clear silent pages and set up pointers */
 	memset(emu-&gt;silent_page.area, 0, PAGE_SIZE);
<span class="p_del">-	silent_page = emu-&gt;silent_page.addr &lt;&lt; 1;</span>
<span class="p_del">-	for (idx = 0; idx &lt; MAXPAGES; idx++)</span>
<span class="p_add">+	silent_page = emu-&gt;silent_page.addr &lt;&lt; emu-&gt;address_mode;</span>
<span class="p_add">+	for (idx = 0; idx &lt; (emu-&gt;address_mode ? MAXPAGES1 : MAXPAGES0); idx++)</span>
 		((u32 *)emu-&gt;ptb_pages.area)[idx] = cpu_to_le32(silent_page | idx);
 
 	/* set up voice indices */
<span class="p_header">diff --git a/sound/pci/emu10k1/emupcm.c b/sound/pci/emu10k1/emupcm.c</span>
<span class="p_header">index e22b8e2..c673d2b 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emupcm.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emupcm.c</span>
<span class="p_chunk">@@ -379,7 +379,7 @@</span> <span class="p_context"> static void snd_emu10k1_pcm_init_voice(struct snd_emu10k1 *emu,</span>
 	snd_emu10k1_ptr_write(emu, Z1, voice, 0);
 	snd_emu10k1_ptr_write(emu, Z2, voice, 0);
 	/* invalidate maps */
<span class="p_del">-	silent_page = ((unsigned int)emu-&gt;silent_page.addr &lt;&lt; 1) | MAP_PTI_MASK;</span>
<span class="p_add">+	silent_page = ((unsigned int)emu-&gt;silent_page.addr &lt;&lt; emu-&gt;address_mode) | (emu-&gt;address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);</span>
 	snd_emu10k1_ptr_write(emu, MAPA, voice, silent_page);
 	snd_emu10k1_ptr_write(emu, MAPB, voice, silent_page);
 	/* modulation envelope */
<span class="p_header">diff --git a/sound/pci/emu10k1/emuproc.c b/sound/pci/emu10k1/emuproc.c</span>
<span class="p_header">index bc38dd4..9c499e6 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emuproc.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emuproc.c</span>
<span class="p_chunk">@@ -241,31 +241,22 @@</span> <span class="p_context"> static void snd_emu10k1_proc_spdif_read(struct snd_info_entry *entry,</span>
 	struct snd_emu10k1 *emu = entry-&gt;private_data;
 	u32 value;
 	u32 value2;
<span class="p_del">-	unsigned long flags;</span>
 	u32 rate;
 
 	if (emu-&gt;card_capabilities-&gt;emu_model) {
<span class="p_del">-		spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_emu1010_fpga_read(emu, 0x38, &amp;value);
<span class="p_del">-		spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 		if ((value &amp; 0x1) == 0) {
<span class="p_del">-			spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 			snd_emu1010_fpga_read(emu, 0x2a, &amp;value);
 			snd_emu1010_fpga_read(emu, 0x2b, &amp;value2);
<span class="p_del">-			spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 			rate = 0x1770000 / (((value &lt;&lt; 5) | value2)+1);	
 			snd_iprintf(buffer, &quot;ADAT Locked : %u\n&quot;, rate);
 		} else {
 			snd_iprintf(buffer, &quot;ADAT Unlocked\n&quot;);
 		}
<span class="p_del">-		spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_emu1010_fpga_read(emu, 0x20, &amp;value);
<span class="p_del">-		spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 		if ((value &amp; 0x4) == 0) {
<span class="p_del">-			spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 			snd_emu1010_fpga_read(emu, 0x28, &amp;value);
 			snd_emu1010_fpga_read(emu, 0x29, &amp;value2);
<span class="p_del">-			spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 			rate = 0x1770000 / (((value &lt;&lt; 5) | value2)+1);	
 			snd_iprintf(buffer, &quot;SPDIF Locked : %d\n&quot;, rate);
 		} else {
<span class="p_chunk">@@ -410,14 +401,11 @@</span> <span class="p_context"> static void snd_emu_proc_emu1010_reg_read(struct snd_info_entry *entry,</span>
 {
 	struct snd_emu10k1 *emu = entry-&gt;private_data;
 	u32 value;
<span class="p_del">-	unsigned long flags;</span>
 	int i;
 	snd_iprintf(buffer, &quot;EMU1010 Registers:\n\n&quot;);
 
 	for(i = 0; i &lt; 0x40; i+=1) {
<span class="p_del">-		spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_emu1010_fpga_read(emu, i, &amp;value);
<span class="p_del">-		spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_iprintf(buffer, &quot;%02X: %08X, %02X\n&quot;, i, value, (value &gt;&gt; 8) &amp; 0x7f);
 	}
 }
<span class="p_header">diff --git a/sound/pci/emu10k1/memory.c b/sound/pci/emu10k1/memory.c</span>
<span class="p_header">index 4f502a2..87b7c65 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/memory.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/memory.c</span>
<span class="p_chunk">@@ -34,10 +34,11 @@</span> <span class="p_context"></span>
  * aligned pages in others
  */
 #define __set_ptb_entry(emu,page,addr) \
<span class="p_del">-	(((u32 *)(emu)-&gt;ptb_pages.area)[page] = cpu_to_le32(((addr) &lt;&lt; 1) | (page)))</span>
<span class="p_add">+	(((u32 *)(emu)-&gt;ptb_pages.area)[page] = cpu_to_le32(((addr) &lt;&lt; (emu-&gt;address_mode)) | (page)))</span>
 
 #define UNIT_PAGES		(PAGE_SIZE / EMUPAGESIZE)
<span class="p_del">-#define MAX_ALIGN_PAGES		(MAXPAGES / UNIT_PAGES)</span>
<span class="p_add">+#define MAX_ALIGN_PAGES0		(MAXPAGES0 / UNIT_PAGES)</span>
<span class="p_add">+#define MAX_ALIGN_PAGES1		(MAXPAGES1 / UNIT_PAGES)</span>
 /* get aligned page from offset address */
 #define get_aligned_page(offset)	((offset) &gt;&gt; PAGE_SHIFT)
 /* get offset address from aligned page */
<span class="p_chunk">@@ -124,7 +125,7 @@</span> <span class="p_context"> static int search_empty_map_area(struct snd_emu10k1 *emu, int npages, struct lis</span>
 		}
 		page = blk-&gt;mapped_page + blk-&gt;pages;
 	}
<span class="p_del">-	size = MAX_ALIGN_PAGES - page;</span>
<span class="p_add">+	size = (emu-&gt;address_mode ? MAX_ALIGN_PAGES1 : MAX_ALIGN_PAGES0) - page;</span>
 	if (size &gt;= max_size) {
 		*nextp = pos;
 		return page;
<span class="p_chunk">@@ -181,7 +182,7 @@</span> <span class="p_context"> static int unmap_memblk(struct snd_emu10k1 *emu, struct snd_emu10k1_memblk *blk)</span>
 		q = get_emu10k1_memblk(p, mapped_link);
 		end_page = q-&gt;mapped_page;
 	} else
<span class="p_del">-		end_page = MAX_ALIGN_PAGES;</span>
<span class="p_add">+		end_page = (emu-&gt;address_mode ? MAX_ALIGN_PAGES1 : MAX_ALIGN_PAGES0);</span>
 
 	/* remove links */
 	list_del(&amp;blk-&gt;mapped_link);
<span class="p_chunk">@@ -305,7 +306,7 @@</span> <span class="p_context"> snd_emu10k1_alloc_pages(struct snd_emu10k1 *emu, struct snd_pcm_substream *subst</span>
 	if (snd_BUG_ON(!emu))
 		return NULL;
 	if (snd_BUG_ON(runtime-&gt;dma_bytes &lt;= 0 ||
<span class="p_del">-		       runtime-&gt;dma_bytes &gt;= MAXPAGES * EMUPAGESIZE))</span>
<span class="p_add">+		       runtime-&gt;dma_bytes &gt;= (emu-&gt;address_mode ? MAXPAGES1 : MAXPAGES0) * EMUPAGESIZE))</span>
 		return NULL;
 	hdr = emu-&gt;memhdr;
 	if (snd_BUG_ON(!hdr))
<span class="p_header">diff --git a/sound/pci/hda/hda_codec.c b/sound/pci/hda/hda_codec.c</span>
<span class="p_header">index c74a044..f70115e 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_codec.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_codec.c</span>
<span class="p_chunk">@@ -2093,6 +2093,16 @@</span> <span class="p_context"> _snd_hda_find_mixer_ctl(struct hda_codec *codec,</span>
 	return snd_ctl_find_id(codec-&gt;bus-&gt;card, &amp;id);
 }
 
<span class="p_add">+/* meta hook to call each driver&#39;s vmaster hook */</span>
<span class="p_add">+static void vmaster_hook(void *private_data, int enabled)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hda_vmaster_mute_hook *hook = private_data;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hook-&gt;mute_mode != HDA_VMUTE_FOLLOW_MASTER)</span>
<span class="p_add">+		enabled = hook-&gt;mute_mode;</span>
<span class="p_add">+	hook-&gt;hook(hook-&gt;codec, enabled);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * snd_hda_find_mixer_ctl - Find a mixer control element with the given name
  * @codec: HD-audio codec
<span class="p_chunk">@@ -2520,9 +2530,9 @@</span> <span class="p_context"> int snd_hda_add_vmaster_hook(struct hda_codec *codec,</span>
 
 	if (!hook-&gt;hook || !hook-&gt;sw_kctl)
 		return 0;
<span class="p_del">-	snd_ctl_add_vmaster_hook(hook-&gt;sw_kctl, hook-&gt;hook, codec);</span>
 	hook-&gt;codec = codec;
 	hook-&gt;mute_mode = HDA_VMUTE_FOLLOW_MASTER;
<span class="p_add">+	snd_ctl_add_vmaster_hook(hook-&gt;sw_kctl, vmaster_hook, hook);</span>
 	if (!expose_enum_ctl)
 		return 0;
 	kctl = snd_ctl_new1(&amp;vmaster_mute_mode, hook);
<span class="p_chunk">@@ -2540,14 +2550,7 @@</span> <span class="p_context"> void snd_hda_sync_vmaster_hook(struct hda_vmaster_mute_hook *hook)</span>
 {
 	if (!hook-&gt;hook || !hook-&gt;codec)
 		return;
<span class="p_del">-	switch (hook-&gt;mute_mode) {</span>
<span class="p_del">-	case HDA_VMUTE_FOLLOW_MASTER:</span>
<span class="p_del">-		snd_ctl_sync_vmaster_hook(hook-&gt;sw_kctl);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		hook-&gt;hook(hook-&gt;codec, hook-&gt;mute_mode);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	snd_ctl_sync_vmaster_hook(hook-&gt;sw_kctl);</span>
 }
 EXPORT_SYMBOL_HDA(snd_hda_sync_vmaster_hook);
 
<span class="p_header">diff --git a/sound/pci/hda/patch_conexant.c b/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">index 20cfc5b..ba80c2f 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_conexant.c</span>
<span class="p_chunk">@@ -4606,6 +4606,14 @@</span> <span class="p_context"> static const struct hda_codec_preset snd_hda_preset_conexant[] = {</span>
 	  .patch = patch_conexant_auto },
 	{ .id = 0x14f150b9, .name = &quot;CX20665&quot;,
 	  .patch = patch_conexant_auto },
<span class="p_add">+	{ .id = 0x14f150f1, .name = &quot;CX20721&quot;,</span>
<span class="p_add">+	  .patch = patch_conexant_auto },</span>
<span class="p_add">+	{ .id = 0x14f150f2, .name = &quot;CX20722&quot;,</span>
<span class="p_add">+	  .patch = patch_conexant_auto },</span>
<span class="p_add">+	{ .id = 0x14f150f3, .name = &quot;CX20723&quot;,</span>
<span class="p_add">+	  .patch = patch_conexant_auto },</span>
<span class="p_add">+	{ .id = 0x14f150f4, .name = &quot;CX20724&quot;,</span>
<span class="p_add">+	  .patch = patch_conexant_auto },</span>
 	{ .id = 0x14f1510f, .name = &quot;CX20751/2&quot;,
 	  .patch = patch_conexant_auto },
 	{ .id = 0x14f15110, .name = &quot;CX20751/2&quot;,
<span class="p_chunk">@@ -4640,6 +4648,10 @@</span> <span class="p_context"> MODULE_ALIAS(&quot;snd-hda-codec-id:14f150ab&quot;);</span>
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f150ac&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f150b8&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f150b9&quot;);
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:14f150f1&quot;);</span>
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:14f150f2&quot;);</span>
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:14f150f3&quot;);</span>
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:14f150f4&quot;);</span>
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f1510f&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f15110&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f15111&quot;);
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index b16a37f..bf1f0ab 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -5412,6 +5412,7 @@</span> <span class="p_context"> static const struct alc_fixup alc882_fixups[] = {</span>
 static const struct snd_pci_quirk alc882_fixup_tbl[] = {
 	SND_PCI_QUIRK(0x1025, 0x006c, &quot;Acer Aspire 9810&quot;, ALC883_FIXUP_ACER_EAPD),
 	SND_PCI_QUIRK(0x1025, 0x0090, &quot;Acer Aspire&quot;, ALC883_FIXUP_ACER_EAPD),
<span class="p_add">+	SND_PCI_QUIRK(0x1025, 0x0107, &quot;Acer Aspire&quot;, ALC883_FIXUP_ACER_EAPD),</span>
 	SND_PCI_QUIRK(0x1025, 0x010a, &quot;Acer Ferrari 5000&quot;, ALC883_FIXUP_ACER_EAPD),
 	SND_PCI_QUIRK(0x1025, 0x0110, &quot;Acer Aspire&quot;, ALC883_FIXUP_ACER_EAPD),
 	SND_PCI_QUIRK(0x1025, 0x0112, &quot;Acer Aspire 9303&quot;, ALC883_FIXUP_ACER_EAPD),
<span class="p_header">diff --git a/sound/soc/codecs/cs4271.c b/sound/soc/codecs/cs4271.c</span>
<span class="p_header">index f9e2bda..5405932 100644</span>
<span class="p_header">--- a/sound/soc/codecs/cs4271.c</span>
<span class="p_header">+++ b/sound/soc/codecs/cs4271.c</span>
<span class="p_chunk">@@ -475,10 +475,10 @@</span> <span class="p_context"> static int cs4271_probe(struct snd_soc_codec *codec)</span>
 	if (gpio_nreset &gt;= 0) {
 		/* Reset codec */
 		gpio_direction_output(gpio_nreset, 0);
<span class="p_del">-		udelay(1);</span>
<span class="p_add">+		mdelay(1);</span>
 		gpio_set_value(gpio_nreset, 1);
 		/* Give the codec time to wake up */
<span class="p_del">-		udelay(1);</span>
<span class="p_add">+		mdelay(1);</span>
 	}
 
 	cs4271-&gt;gpio_nreset = gpio_nreset;
<span class="p_header">diff --git a/sound/soc/codecs/wm8741.c b/sound/soc/codecs/wm8741.c</span>
<span class="p_header">index 3941f50..90deecd 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8741.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8741.c</span>
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> static struct {</span>
 };
 
 static unsigned int rates_11289[] = {
<span class="p_del">-	44100, 88235,</span>
<span class="p_add">+	44100, 88200,</span>
 };
 
 static struct snd_pcm_hw_constraint_list constraints_11289 = {
<span class="p_chunk">@@ -132,7 +132,7 @@</span> <span class="p_context"> static struct snd_pcm_hw_constraint_list constraints_16384 = {</span>
 };
 
 static unsigned int rates_16934[] = {
<span class="p_del">-	44100, 88235,</span>
<span class="p_add">+	44100, 88200,</span>
 };
 
 static struct snd_pcm_hw_constraint_list constraints_16934 = {
<span class="p_chunk">@@ -150,7 +150,7 @@</span> <span class="p_context"> static struct snd_pcm_hw_constraint_list constraints_18432 = {</span>
 };
 
 static unsigned int rates_22579[] = {
<span class="p_del">-	44100, 88235, 1764000</span>
<span class="p_add">+	44100, 88200, 176400</span>
 };
 
 static struct snd_pcm_hw_constraint_list constraints_22579 = {
<span class="p_chunk">@@ -168,7 +168,7 @@</span> <span class="p_context"> static struct snd_pcm_hw_constraint_list constraints_24576 = {</span>
 };
 
 static unsigned int rates_36864[] = {
<span class="p_del">-	48000, 96000, 19200</span>
<span class="p_add">+	48000, 96000, 192000</span>
 };
 
 static struct snd_pcm_hw_constraint_list constraints_36864 = {
<span class="p_header">diff --git a/sound/soc/codecs/wm8960.c b/sound/soc/codecs/wm8960.c</span>
<span class="p_header">index a3e4831..ed986e6 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8960.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8960.c</span>
<span class="p_chunk">@@ -333,7 +333,7 @@</span> <span class="p_context"> static const struct snd_soc_dapm_route audio_paths[] = {</span>
 	{ &quot;Right Input Mixer&quot;, &quot;Boost Switch&quot;, &quot;Right Boost Mixer&quot;, },
 	{ &quot;Right Input Mixer&quot;, NULL, &quot;RINPUT1&quot;, },  /* Really Boost Switch */
 	{ &quot;Right Input Mixer&quot;, NULL, &quot;RINPUT2&quot; },
<span class="p_del">-	{ &quot;Right Input Mixer&quot;, NULL, &quot;LINPUT3&quot; },</span>
<span class="p_add">+	{ &quot;Right Input Mixer&quot;, NULL, &quot;RINPUT3&quot; },</span>
 
 	{ &quot;Left ADC&quot;, NULL, &quot;Left Input Mixer&quot; },
 	{ &quot;Right ADC&quot;, NULL, &quot;Right Input Mixer&quot; },
<span class="p_header">diff --git a/sound/soc/codecs/wm8994.c b/sound/soc/codecs/wm8994.c</span>
<span class="p_header">index d9924d7..c93c573 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8994.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8994.c</span>
<span class="p_chunk">@@ -2636,7 +2636,7 @@</span> <span class="p_context"> static struct {</span>
 };
 
 static int fs_ratios[] = {
<span class="p_del">-	64, 128, 192, 256, 348, 512, 768, 1024, 1408, 1536</span>
<span class="p_add">+	64, 128, 192, 256, 384, 512, 768, 1024, 1408, 1536</span>
 };
 
 static int bclk_divs[] = {
<span class="p_header">diff --git a/sound/synth/emux/emux_oss.c b/sound/synth/emux/emux_oss.c</span>
<span class="p_header">index 319754c..daf61ab 100644</span>
<span class="p_header">--- a/sound/synth/emux/emux_oss.c</span>
<span class="p_header">+++ b/sound/synth/emux/emux_oss.c</span>
<span class="p_chunk">@@ -118,12 +118,8 @@</span> <span class="p_context"> snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)</span>
 	if (snd_BUG_ON(!arg || !emu))
 		return -ENXIO;
 
<span class="p_del">-	mutex_lock(&amp;emu-&gt;register_mutex);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!snd_emux_inc_count(emu)) {</span>
<span class="p_del">-		mutex_unlock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+	if (!snd_emux_inc_count(emu))</span>
 		return -EFAULT;
<span class="p_del">-	}</span>
 
 	memset(&amp;callback, 0, sizeof(callback));
 	callback.owner = THIS_MODULE;
<span class="p_chunk">@@ -135,7 +131,6 @@</span> <span class="p_context"> snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)</span>
 	if (p == NULL) {
 		snd_printk(KERN_ERR &quot;can&#39;t create port\n&quot;);
 		snd_emux_dec_count(emu);
<span class="p_del">-		mutex_unlock(&amp;emu-&gt;register_mutex);</span>
 		return -ENOMEM;
 	}
 
<span class="p_chunk">@@ -148,8 +143,6 @@</span> <span class="p_context"> snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)</span>
 	reset_port_mode(p, arg-&gt;seq_mode);
 
 	snd_emux_reset_port(p);
<span class="p_del">-</span>
<span class="p_del">-	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -195,13 +188,11 @@</span> <span class="p_context"> snd_emux_close_seq_oss(struct snd_seq_oss_arg *arg)</span>
 	if (snd_BUG_ON(!emu))
 		return -ENXIO;
 
<span class="p_del">-	mutex_lock(&amp;emu-&gt;register_mutex);</span>
 	snd_emux_sounds_off_all(p);
 	snd_soundfont_close_check(emu-&gt;sflist, SF_CLIENT_NO(p-&gt;chset.port));
 	snd_seq_event_port_detach(p-&gt;chset.client, p-&gt;chset.port);
 	snd_emux_dec_count(emu);
 
<span class="p_del">-	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c</span>
<span class="p_header">index 7778b8e..a020920 100644</span>
<span class="p_header">--- a/sound/synth/emux/emux_seq.c</span>
<span class="p_header">+++ b/sound/synth/emux/emux_seq.c</span>
<span class="p_chunk">@@ -124,12 +124,10 @@</span> <span class="p_context"> snd_emux_detach_seq(struct snd_emux *emu)</span>
 	if (emu-&gt;voices)
 		snd_emux_terminate_all(emu);
 		
<span class="p_del">-	mutex_lock(&amp;emu-&gt;register_mutex);</span>
 	if (emu-&gt;client &gt;= 0) {
 		snd_seq_delete_kernel_client(emu-&gt;client);
 		emu-&gt;client = -1;
 	}
<span class="p_del">-	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
 }
 
 
<span class="p_chunk">@@ -269,8 +267,8 @@</span> <span class="p_context"> snd_emux_event_input(struct snd_seq_event *ev, int direct, void *private_data,</span>
 /*
  * increment usage count
  */
<span class="p_del">-int</span>
<span class="p_del">-snd_emux_inc_count(struct snd_emux *emu)</span>
<span class="p_add">+static int</span>
<span class="p_add">+__snd_emux_inc_count(struct snd_emux *emu)</span>
 {
 	emu-&gt;used++;
 	if (!try_module_get(emu-&gt;ops.owner))
<span class="p_chunk">@@ -284,12 +282,21 @@</span> <span class="p_context"> snd_emux_inc_count(struct snd_emux *emu)</span>
 	return 1;
 }
 
<span class="p_add">+int snd_emux_inc_count(struct snd_emux *emu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+	ret = __snd_emux_inc_count(emu);</span>
<span class="p_add">+	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
 
 /*
  * decrease usage count
  */
<span class="p_del">-void</span>
<span class="p_del">-snd_emux_dec_count(struct snd_emux *emu)</span>
<span class="p_add">+static void</span>
<span class="p_add">+__snd_emux_dec_count(struct snd_emux *emu)</span>
 {
 	module_put(emu-&gt;card-&gt;module);
 	emu-&gt;used--;
<span class="p_chunk">@@ -298,6 +305,12 @@</span> <span class="p_context"> snd_emux_dec_count(struct snd_emux *emu)</span>
 	module_put(emu-&gt;ops.owner);
 }
 
<span class="p_add">+void snd_emux_dec_count(struct snd_emux *emu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mutex_lock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+	__snd_emux_dec_count(emu);</span>
<span class="p_add">+	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+}</span>
 
 /*
  * Routine that is called upon a first use of a particular port
<span class="p_chunk">@@ -317,7 +330,7 @@</span> <span class="p_context"> snd_emux_use(void *private_data, struct snd_seq_port_subscribe *info)</span>
 
 	mutex_lock(&amp;emu-&gt;register_mutex);
 	snd_emux_init_port(p);
<span class="p_del">-	snd_emux_inc_count(emu);</span>
<span class="p_add">+	__snd_emux_inc_count(emu);</span>
 	mutex_unlock(&amp;emu-&gt;register_mutex);
 	return 0;
 }
<span class="p_chunk">@@ -340,7 +353,7 @@</span> <span class="p_context"> snd_emux_unuse(void *private_data, struct snd_seq_port_subscribe *info)</span>
 
 	mutex_lock(&amp;emu-&gt;register_mutex);
 	snd_emux_sounds_off_all(p);
<span class="p_del">-	snd_emux_dec_count(emu);</span>
<span class="p_add">+	__snd_emux_dec_count(emu);</span>
 	mutex_unlock(&amp;emu-&gt;register_mutex);
 	return 0;
 }
<span class="p_header">diff --git a/sound/usb/mixer_maps.c b/sound/usb/mixer_maps.c</span>
<span class="p_header">index 1e0798f..851786f 100644</span>
<span class="p_header">--- a/sound/usb/mixer_maps.c</span>
<span class="p_header">+++ b/sound/usb/mixer_maps.c</span>
<span class="p_chunk">@@ -380,6 +380,11 @@</span> <span class="p_context"> static struct usbmix_ctl_map usbmix_ctl_maps[] = {</span>
 		.ignore_ctl_error = 1,
 	},
 	{
<span class="p_add">+		/* MAYA44 USB+ */</span>
<span class="p_add">+		.id = USB_ID(0x2573, 0x0008),</span>
<span class="p_add">+		.map = maya44_map,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		/* KEF X300A */
 		.id = USB_ID(0x27ac, 0x1000),
 		.map = scms_usb3318_map,

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



