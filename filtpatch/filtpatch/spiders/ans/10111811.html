
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.14.6 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.14.6</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 14, 2017, 10:44 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171214104412.GB13969@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10111811/mbox/"
   >mbox</a>
|
   <a href="/patch/10111811/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10111811/">/patch/10111811/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	2622660352 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 14 Dec 2017 10:44:32 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id E265A29B77
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 14 Dec 2017 10:44:31 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id D65DC29B7D; Thu, 14 Dec 2017 10:44:31 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id B912D29B77
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 14 Dec 2017 10:44:24 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751789AbdLNKoU (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 14 Dec 2017 05:44:20 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:39870 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751620AbdLNKoJ (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 14 Dec 2017 05:44:09 -0500
Received: from localhost (LFbn-1-12262-44.w90-92.abo.wanadoo.fr
	[90.92.75.44])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 378D5BAA;
	Thu, 14 Dec 2017 10:44:08 +0000 (UTC)
Date: Thu, 14 Dec 2017 11:44:12 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.14.6
Message-ID: &lt;20171214104412.GB13969@kroah.com&gt;
References: &lt;20171214104408.GA13969@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20171214104408.GA13969@kroah.com&gt;
User-Agent: Mutt/1.9.1 (2017-09-22)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Dec. 14, 2017, 10:44 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/usb/usb-device.txt b/Documentation/devicetree/bindings/usb/usb-device.txt</span>
<span class="p_header">index ce02cebac26a..464ddf7b509a 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/usb/usb-device.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/usb/usb-device.txt</span>
<span class="p_chunk">@@ -11,7 +11,7 @@</span> <span class="p_context"> Required properties:</span>
   be used, but a device adhering to this binding may leave out all except
   for usbVID,PID.
 - reg: the port number which this device is connecting to, the range
<span class="p_del">-  is 1-31.</span>
<span class="p_add">+  is 1-255.</span>
 
 Example:
 
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 43ac7bdb10ad..eabbd7748a24 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 # SPDX-License-Identifier: GPL-2.0
 VERSION = 4
 PATCHLEVEL = 14
<span class="p_del">-SUBLEVEL = 5</span>
<span class="p_add">+SUBLEVEL = 6</span>
 EXTRAVERSION =
 NAME = Petit Gorille
 
<span class="p_header">diff --git a/arch/arm/boot/dts/imx53.dtsi b/arch/arm/boot/dts/imx53.dtsi</span>
<span class="p_header">index 8bf0d89cdd35..2e516f4985e4 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx53.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx53.dtsi</span>
<span class="p_chunk">@@ -433,15 +433,6 @@</span> <span class="p_context"></span>
 				clock-names = &quot;ipg&quot;, &quot;per&quot;;
 			};
 
<span class="p_del">-			srtc: srtc@53fa4000 {</span>
<span class="p_del">-				compatible = &quot;fsl,imx53-rtc&quot;, &quot;fsl,imx25-rtc&quot;;</span>
<span class="p_del">-				reg = &lt;0x53fa4000 0x4000&gt;;</span>
<span class="p_del">-				interrupts = &lt;24&gt;;</span>
<span class="p_del">-				interrupt-parent = &lt;&amp;tzic&gt;;</span>
<span class="p_del">-				clocks = &lt;&amp;clks IMX5_CLK_SRTC_GATE&gt;;</span>
<span class="p_del">-				clock-names = &quot;ipg&quot;;</span>
<span class="p_del">-			};</span>
<span class="p_del">-</span>
 			iomuxc: iomuxc@53fa8000 {
 				compatible = &quot;fsl,imx53-iomuxc&quot;;
 				reg = &lt;0x53fa8000 0x4000&gt;;
<span class="p_header">diff --git a/arch/arm/include/asm/assembler.h b/arch/arm/include/asm/assembler.h</span>
<span class="p_header">index ad301f107dd2..bc8d4bbd82e2 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/assembler.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/assembler.h</span>
<span class="p_chunk">@@ -518,4 +518,22 @@</span> <span class="p_context"> THUMB(	orr	\reg , \reg , #PSR_T_BIT	)</span>
 #endif
 	.endm
 
<span class="p_add">+	.macro	bug, msg, line</span>
<span class="p_add">+#ifdef CONFIG_THUMB2_KERNEL</span>
<span class="p_add">+1:	.inst	0xde02</span>
<span class="p_add">+#else</span>
<span class="p_add">+1:	.inst	0xe7f001f2</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifdef CONFIG_DEBUG_BUGVERBOSE</span>
<span class="p_add">+	.pushsection .rodata.str, &quot;aMS&quot;, %progbits, 1</span>
<span class="p_add">+2:	.asciz	&quot;\msg&quot;</span>
<span class="p_add">+	.popsection</span>
<span class="p_add">+	.pushsection __bug_table, &quot;aw&quot;</span>
<span class="p_add">+	.align	2</span>
<span class="p_add">+	.word	1b, 2b</span>
<span class="p_add">+	.hword	\line</span>
<span class="p_add">+	.popsection</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
 #endif /* __ASM_ASSEMBLER_H__ */
<span class="p_header">diff --git a/arch/arm/include/asm/kvm_arm.h b/arch/arm/include/asm/kvm_arm.h</span>
<span class="p_header">index c8781450905b..3ab8b3781bfe 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/kvm_arm.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/kvm_arm.h</span>
<span class="p_chunk">@@ -161,8 +161,7 @@</span> <span class="p_context"></span>
 #else
 #define VTTBR_X		(5 - KVM_T0SZ)
 #endif
<span class="p_del">-#define VTTBR_BADDR_SHIFT (VTTBR_X - 1)</span>
<span class="p_del">-#define VTTBR_BADDR_MASK  (((_AC(1, ULL) &lt;&lt; (40 - VTTBR_X)) - 1) &lt;&lt; VTTBR_BADDR_SHIFT)</span>
<span class="p_add">+#define VTTBR_BADDR_MASK  (((_AC(1, ULL) &lt;&lt; (40 - VTTBR_X)) - 1) &lt;&lt; VTTBR_X)</span>
 #define VTTBR_VMID_SHIFT  _AC(48, ULL)
 #define VTTBR_VMID_MASK(size)	(_AT(u64, (1 &lt;&lt; size) - 1) &lt;&lt; VTTBR_VMID_SHIFT)
 
<span class="p_header">diff --git a/arch/arm/kernel/entry-header.S b/arch/arm/kernel/entry-header.S</span>
<span class="p_header">index d523cd8439a3..0f07579af472 100644</span>
<span class="p_header">--- a/arch/arm/kernel/entry-header.S</span>
<span class="p_header">+++ b/arch/arm/kernel/entry-header.S</span>
<span class="p_chunk">@@ -300,6 +300,8 @@</span> <span class="p_context"></span>
 	mov	r2, sp
 	ldr	r1, [r2, #\offset + S_PSR]	@ get calling cpsr
 	ldr	lr, [r2, #\offset + S_PC]!	@ get pc
<span class="p_add">+	tst	r1, #PSR_I_BIT | 0x0f</span>
<span class="p_add">+	bne	1f</span>
 	msr	spsr_cxsf, r1			@ save in spsr_svc
 #if defined(CONFIG_CPU_V6) || defined(CONFIG_CPU_32v6K)
 	@ We must avoid clrex due to Cortex-A15 erratum #830321
<span class="p_chunk">@@ -314,6 +316,7 @@</span> <span class="p_context"></span>
 						@ after ldm {}^
 	add	sp, sp, #\offset + PT_REGS_SIZE
 	movs	pc, lr				@ return &amp; move spsr_svc into cpsr
<span class="p_add">+1:	bug	&quot;Returning to usermode but unexpected PSR bits set?&quot;, \@</span>
 #elif defined(CONFIG_CPU_V7M)
 	@ V7M restore.
 	@ Note that we don&#39;t need to do clrex here as clearing the local
<span class="p_chunk">@@ -329,6 +332,8 @@</span> <span class="p_context"></span>
 	ldr	r1, [sp, #\offset + S_PSR]	@ get calling cpsr
 	ldr	lr, [sp, #\offset + S_PC]	@ get pc
 	add	sp, sp, #\offset + S_SP
<span class="p_add">+	tst	r1, #PSR_I_BIT | 0x0f</span>
<span class="p_add">+	bne	1f</span>
 	msr	spsr_cxsf, r1			@ save in spsr_svc
 
 	@ We must avoid clrex due to Cortex-A15 erratum #830321
<span class="p_chunk">@@ -341,6 +346,7 @@</span> <span class="p_context"></span>
 	.endif
 	add	sp, sp, #PT_REGS_SIZE - S_SP
 	movs	pc, lr				@ return &amp; move spsr_svc into cpsr
<span class="p_add">+1:	bug	&quot;Returning to usermode but unexpected PSR bits set?&quot;, \@</span>
 #endif	/* !CONFIG_THUMB2_KERNEL */
 	.endm
 
<span class="p_header">diff --git a/arch/arm64/include/asm/efi.h b/arch/arm64/include/asm/efi.h</span>
<span class="p_header">index 650344d01124..c4cd5081d78b 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/efi.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/efi.h</span>
<span class="p_chunk">@@ -132,11 +132,9 @@</span> <span class="p_context"> static inline void efi_set_pgd(struct mm_struct *mm)</span>
 			 * Defer the switch to the current thread&#39;s TTBR0_EL1
 			 * until uaccess_enable(). Restore the current
 			 * thread&#39;s saved ttbr0 corresponding to its active_mm
<span class="p_del">-			 * (if different from init_mm).</span>
 			 */
 			cpu_set_reserved_ttbr0();
<span class="p_del">-			if (current-&gt;active_mm != &amp;init_mm)</span>
<span class="p_del">-				update_saved_ttbr0(current, current-&gt;active_mm);</span>
<span class="p_add">+			update_saved_ttbr0(current, current-&gt;active_mm);</span>
 		}
 	}
 }
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_arm.h b/arch/arm64/include/asm/kvm_arm.h</span>
<span class="p_header">index 61d694c2eae5..555d463c0eaa 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_arm.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_arm.h</span>
<span class="p_chunk">@@ -170,8 +170,7 @@</span> <span class="p_context"></span>
 #define VTCR_EL2_FLAGS			(VTCR_EL2_COMMON_BITS | VTCR_EL2_TGRAN_FLAGS)
 #define VTTBR_X				(VTTBR_X_TGRAN_MAGIC - VTCR_EL2_T0SZ_IPA)
 
<span class="p_del">-#define VTTBR_BADDR_SHIFT (VTTBR_X - 1)</span>
<span class="p_del">-#define VTTBR_BADDR_MASK  (((UL(1) &lt;&lt; (PHYS_MASK_SHIFT - VTTBR_X)) - 1) &lt;&lt; VTTBR_BADDR_SHIFT)</span>
<span class="p_add">+#define VTTBR_BADDR_MASK  (((UL(1) &lt;&lt; (PHYS_MASK_SHIFT - VTTBR_X)) - 1) &lt;&lt; VTTBR_X)</span>
 #define VTTBR_VMID_SHIFT  (UL(48))
 #define VTTBR_VMID_MASK(size) (_AT(u64, (1 &lt;&lt; size) - 1) &lt;&lt; VTTBR_VMID_SHIFT)
 
<span class="p_header">diff --git a/arch/arm64/include/asm/mmu_context.h b/arch/arm64/include/asm/mmu_context.h</span>
<span class="p_header">index 3257895a9b5e..9d155fa9a507 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -156,29 +156,21 @@</span> <span class="p_context"> void check_and_switch_context(struct mm_struct *mm, unsigned int cpu);</span>
 
 #define init_new_context(tsk,mm)	({ atomic64_set(&amp;(mm)-&gt;context.id, 0); 0; })
 
<span class="p_del">-/*</span>
<span class="p_del">- * This is called when &quot;tsk&quot; is about to enter lazy TLB mode.</span>
<span class="p_del">- *</span>
<span class="p_del">- * mm:  describes the currently active mm context</span>
<span class="p_del">- * tsk: task which is entering lazy tlb</span>
<span class="p_del">- * cpu: cpu number which is entering lazy tlb</span>
<span class="p_del">- *</span>
<span class="p_del">- * tsk-&gt;mm will be NULL</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline void</span>
<span class="p_del">-enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 #ifdef CONFIG_ARM64_SW_TTBR0_PAN
 static inline void update_saved_ttbr0(struct task_struct *tsk,
 				      struct mm_struct *mm)
 {
<span class="p_del">-	if (system_uses_ttbr0_pan()) {</span>
<span class="p_del">-		BUG_ON(mm-&gt;pgd == swapper_pg_dir);</span>
<span class="p_del">-		task_thread_info(tsk)-&gt;ttbr0 =</span>
<span class="p_del">-			virt_to_phys(mm-&gt;pgd) | ASID(mm) &lt;&lt; 48;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	u64 ttbr;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!system_uses_ttbr0_pan())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mm == &amp;init_mm)</span>
<span class="p_add">+		ttbr = __pa_symbol(empty_zero_page);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ttbr = virt_to_phys(mm-&gt;pgd) | ASID(mm) &lt;&lt; 48;</span>
<span class="p_add">+</span>
<span class="p_add">+	task_thread_info(tsk)-&gt;ttbr0 = ttbr;</span>
 }
 #else
 static inline void update_saved_ttbr0(struct task_struct *tsk,
<span class="p_chunk">@@ -187,6 +179,16 @@</span> <span class="p_context"> static inline void update_saved_ttbr0(struct task_struct *tsk,</span>
 }
 #endif
 
<span class="p_add">+static inline void</span>
<span class="p_add">+enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We don&#39;t actually care about the ttbr0 mapping, so point it at the</span>
<span class="p_add">+	 * zero page.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	update_saved_ttbr0(tsk, &amp;init_mm);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void __switch_mm(struct mm_struct *next)
 {
 	unsigned int cpu = smp_processor_id();
<span class="p_chunk">@@ -214,11 +216,9 @@</span> <span class="p_context"> switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
 	 * Update the saved TTBR0_EL1 of the scheduled-in task as the previous
 	 * value may have not been initialised yet (activate_mm caller) or the
 	 * ASID has changed since the last run (following the context switch
<span class="p_del">-	 * of another thread of the same process). Avoid setting the reserved</span>
<span class="p_del">-	 * TTBR0_EL1 to swapper_pg_dir (init_mm; e.g. via idle_task_exit).</span>
<span class="p_add">+	 * of another thread of the same process).</span>
 	 */
<span class="p_del">-	if (next != &amp;init_mm)</span>
<span class="p_del">-		update_saved_ttbr0(tsk, next);</span>
<span class="p_add">+	update_saved_ttbr0(tsk, next);</span>
 }
 
 #define deactivate_mm(tsk,mm)	do { } while (0)
<span class="p_header">diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c</span>
<span class="p_header">index 2dc0f8482210..bcd22d7ee590 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/process.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/process.c</span>
<span class="p_chunk">@@ -258,6 +258,15 @@</span> <span class="p_context"> int copy_thread(unsigned long clone_flags, unsigned long stack_start,</span>
 
 	memset(&amp;p-&gt;thread.cpu_context, 0, sizeof(struct cpu_context));
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In case p was allocated the same task_struct pointer as some</span>
<span class="p_add">+	 * other recently-exited task, make sure p is disassociated from</span>
<span class="p_add">+	 * any cpu that may have run that now-exited task recently.</span>
<span class="p_add">+	 * Otherwise we could erroneously skip reloading the FPSIMD</span>
<span class="p_add">+	 * registers for p.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	fpsimd_flush_task_state(p);</span>
<span class="p_add">+</span>
 	if (likely(!(p-&gt;flags &amp; PF_KTHREAD))) {
 		*childregs = *current_pt_regs();
 		childregs-&gt;regs[0] = 0;
<span class="p_header">diff --git a/arch/powerpc/include/asm/machdep.h b/arch/powerpc/include/asm/machdep.h</span>
<span class="p_header">index 73b92017b6d7..cd2fc1cc1cc7 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/machdep.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/machdep.h</span>
<span class="p_chunk">@@ -76,6 +76,7 @@</span> <span class="p_context"> struct machdep_calls {</span>
 
 	void __noreturn	(*restart)(char *cmd);
 	void __noreturn (*halt)(void);
<span class="p_add">+	void		(*panic)(char *str);</span>
 	void		(*cpu_die)(void);
 
 	long		(*time_init)(void); /* Optional, may be NULL */
<span class="p_header">diff --git a/arch/powerpc/include/asm/setup.h b/arch/powerpc/include/asm/setup.h</span>
<span class="p_header">index 257d23dbf55d..cf00ec26303a 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/setup.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/setup.h</span>
<span class="p_chunk">@@ -24,6 +24,7 @@</span> <span class="p_context"> extern void reloc_got2(unsigned long);</span>
 
 void check_for_initrd(void);
 void initmem_init(void);
<span class="p_add">+void setup_panic(void);</span>
 #define ARCH_PANIC_TIMEOUT 180
 
 #ifdef CONFIG_PPC_PSERIES
<span class="p_header">diff --git a/arch/powerpc/kernel/cpu_setup_power.S b/arch/powerpc/kernel/cpu_setup_power.S</span>
<span class="p_header">index 610955fe8b81..679bbe714e85 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/cpu_setup_power.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/cpu_setup_power.S</span>
<span class="p_chunk">@@ -102,6 +102,7 @@</span> <span class="p_context"> _GLOBAL(__setup_cpu_power9)</span>
 	li	r0,0
 	mtspr	SPRN_PSSCR,r0
 	mtspr	SPRN_LPID,r0
<span class="p_add">+	mtspr	SPRN_PID,r0</span>
 	mfspr	r3,SPRN_LPCR
 	LOAD_REG_IMMEDIATE(r4, LPCR_PECEDH | LPCR_PECE_HVEE | LPCR_HVICE  | LPCR_HEIC)
 	or	r3, r3, r4
<span class="p_chunk">@@ -126,6 +127,7 @@</span> <span class="p_context"> _GLOBAL(__restore_cpu_power9)</span>
 	li	r0,0
 	mtspr	SPRN_PSSCR,r0
 	mtspr	SPRN_LPID,r0
<span class="p_add">+	mtspr	SPRN_PID,r0</span>
 	mfspr   r3,SPRN_LPCR
 	LOAD_REG_IMMEDIATE(r4, LPCR_PECEDH | LPCR_PECE_HVEE | LPCR_HVICE | LPCR_HEIC)
 	or	r3, r3, r4
<span class="p_header">diff --git a/arch/powerpc/kernel/fadump.c b/arch/powerpc/kernel/fadump.c</span>
<span class="p_header">index e1431800bfb9..29d2b6050140 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/fadump.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/fadump.c</span>
<span class="p_chunk">@@ -1453,25 +1453,6 @@</span> <span class="p_context"> static void fadump_init_files(void)</span>
 	return;
 }
 
<span class="p_del">-static int fadump_panic_event(struct notifier_block *this,</span>
<span class="p_del">-			      unsigned long event, void *ptr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If firmware-assisted dump has been registered then trigger</span>
<span class="p_del">-	 * firmware-assisted dump and let firmware handle everything</span>
<span class="p_del">-	 * else. If this returns, then fadump was not registered, so</span>
<span class="p_del">-	 * go through the rest of the panic path.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	crash_fadump(NULL, ptr);</span>
<span class="p_del">-</span>
<span class="p_del">-	return NOTIFY_DONE;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static struct notifier_block fadump_panic_block = {</span>
<span class="p_del">-	.notifier_call = fadump_panic_event,</span>
<span class="p_del">-	.priority = INT_MIN /* may not return; must be done last */</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 /*
  * Prepare for firmware-assisted dump.
  */
<span class="p_chunk">@@ -1504,9 +1485,6 @@</span> <span class="p_context"> int __init setup_fadump(void)</span>
 		init_fadump_mem_struct(&amp;fdm, fw_dump.reserve_dump_area_start);
 	fadump_init_files();
 
<span class="p_del">-	atomic_notifier_chain_register(&amp;panic_notifier_list,</span>
<span class="p_del">-					&amp;fadump_panic_block);</span>
<span class="p_del">-</span>
 	return 1;
 }
 subsys_initcall(setup_fadump);
<span class="p_header">diff --git a/arch/powerpc/kernel/setup-common.c b/arch/powerpc/kernel/setup-common.c</span>
<span class="p_header">index 2e3bc16d02b2..90bc20efb4c7 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/setup-common.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/setup-common.c</span>
<span class="p_chunk">@@ -704,6 +704,30 @@</span> <span class="p_context"> int check_legacy_ioport(unsigned long base_port)</span>
 }
 EXPORT_SYMBOL(check_legacy_ioport);
 
<span class="p_add">+static int ppc_panic_event(struct notifier_block *this,</span>
<span class="p_add">+                             unsigned long event, void *ptr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If firmware-assisted dump has been registered then trigger</span>
<span class="p_add">+	 * firmware-assisted dump and let firmware handle everything else.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	crash_fadump(NULL, ptr);</span>
<span class="p_add">+	ppc_md.panic(ptr);  /* May not return */</span>
<span class="p_add">+	return NOTIFY_DONE;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct notifier_block ppc_panic_block = {</span>
<span class="p_add">+	.notifier_call = ppc_panic_event,</span>
<span class="p_add">+	.priority = INT_MIN /* may not return; must be done last */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+void __init setup_panic(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!ppc_md.panic)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	atomic_notifier_chain_register(&amp;panic_notifier_list, &amp;ppc_panic_block);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #ifdef CONFIG_CHECK_CACHE_COHERENCY
 /*
  * For platforms that have configurable cache-coherency.  This function
<span class="p_chunk">@@ -848,6 +872,9 @@</span> <span class="p_context"> void __init setup_arch(char **cmdline_p)</span>
 	/* Probe the machine type, establish ppc_md. */
 	probe_machine();
 
<span class="p_add">+	/* Setup panic notifier if requested by the platform. */</span>
<span class="p_add">+	setup_panic();</span>
<span class="p_add">+</span>
 	/*
 	 * Configure ppc_md.power_save (ppc32 only, 64-bit machines do
 	 * it from their respective probe() function.
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/opal-imc.c b/arch/powerpc/platforms/powernv/opal-imc.c</span>
<span class="p_header">index 21f6531fae20..b150f4deaccf 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/opal-imc.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/opal-imc.c</span>
<span class="p_chunk">@@ -191,8 +191,10 @@</span> <span class="p_context"> static int opal_imc_counters_probe(struct platform_device *pdev)</span>
 			break;
 		}
 
<span class="p_del">-		if (!imc_pmu_create(imc_dev, pmu_count, domain))</span>
<span class="p_del">-			pmu_count++;</span>
<span class="p_add">+		if (!imc_pmu_create(imc_dev, pmu_count, domain)) {</span>
<span class="p_add">+			if (domain == IMC_DOMAIN_NEST)</span>
<span class="p_add">+				pmu_count++;</span>
<span class="p_add">+		}</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/arch/powerpc/platforms/ps3/setup.c b/arch/powerpc/platforms/ps3/setup.c</span>
<span class="p_header">index 9dabea6e1443..6244bc849469 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/ps3/setup.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/ps3/setup.c</span>
<span class="p_chunk">@@ -104,6 +104,20 @@</span> <span class="p_context"> static void __noreturn ps3_halt(void)</span>
 	ps3_sys_manager_halt(); /* never returns */
 }
 
<span class="p_add">+static void ps3_panic(char *str)</span>
<span class="p_add">+{</span>
<span class="p_add">+	DBG(&quot;%s:%d %s\n&quot;, __func__, __LINE__, str);</span>
<span class="p_add">+</span>
<span class="p_add">+	smp_send_stop();</span>
<span class="p_add">+	printk(&quot;\n&quot;);</span>
<span class="p_add">+	printk(&quot;   System does not reboot automatically.\n&quot;);</span>
<span class="p_add">+	printk(&quot;   Please press POWER button.\n&quot;);</span>
<span class="p_add">+	printk(&quot;\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	while(1)</span>
<span class="p_add">+		lv1_pause(1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #if defined(CONFIG_FB_PS3) || defined(CONFIG_FB_PS3_MODULE) || \
     defined(CONFIG_PS3_FLASH) || defined(CONFIG_PS3_FLASH_MODULE)
 static void __init prealloc(struct ps3_prealloc *p)
<span class="p_chunk">@@ -255,6 +269,7 @@</span> <span class="p_context"> define_machine(ps3) {</span>
 	.probe				= ps3_probe,
 	.setup_arch			= ps3_setup_arch,
 	.init_IRQ			= ps3_init_IRQ,
<span class="p_add">+	.panic				= ps3_panic,</span>
 	.get_boot_time			= ps3_get_boot_time,
 	.set_dabr			= ps3_set_dabr,
 	.calibrate_decr			= ps3_calibrate_decr,
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c</span>
<span class="p_header">index 5f1beb8367ac..a8531e012658 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/setup.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/setup.c</span>
<span class="p_chunk">@@ -726,6 +726,7 @@</span> <span class="p_context"> define_machine(pseries) {</span>
 	.pcibios_fixup		= pSeries_final_fixup,
 	.restart		= rtas_restart,
 	.halt			= rtas_halt,
<span class="p_add">+	.panic			= rtas_os_term,</span>
 	.get_boot_time		= rtas_get_boot_time,
 	.get_rtc_time		= rtas_get_rtc_time,
 	.set_rtc_time		= rtas_set_rtc_time,
<span class="p_header">diff --git a/arch/s390/include/asm/switch_to.h b/arch/s390/include/asm/switch_to.h</span>
<span class="p_header">index ec7b476c1ac5..c61b2cc1a8a8 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/switch_to.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/switch_to.h</span>
<span class="p_chunk">@@ -30,21 +30,20 @@</span> <span class="p_context"> static inline void restore_access_regs(unsigned int *acrs)</span>
 	asm volatile(&quot;lam 0,15,%0&quot; : : &quot;Q&quot; (*(acrstype *)acrs));
 }
 
<span class="p_del">-#define switch_to(prev,next,last) do {					\</span>
<span class="p_del">-	if (prev-&gt;mm) {							\</span>
<span class="p_del">-		save_fpu_regs();					\</span>
<span class="p_del">-		save_access_regs(&amp;prev-&gt;thread.acrs[0]);		\</span>
<span class="p_del">-		save_ri_cb(prev-&gt;thread.ri_cb);				\</span>
<span class="p_del">-		save_gs_cb(prev-&gt;thread.gs_cb);				\</span>
<span class="p_del">-	}								\</span>
<span class="p_add">+#define switch_to(prev, next, last) do {				\</span>
<span class="p_add">+	/* save_fpu_regs() sets the CIF_FPU flag, which enforces	\</span>
<span class="p_add">+	 * a restore of the floating point / vector registers as	\</span>
<span class="p_add">+	 * soon as the next task returns to user space			\</span>
<span class="p_add">+	 */								\</span>
<span class="p_add">+	save_fpu_regs();						\</span>
<span class="p_add">+	save_access_regs(&amp;prev-&gt;thread.acrs[0]);			\</span>
<span class="p_add">+	save_ri_cb(prev-&gt;thread.ri_cb);					\</span>
<span class="p_add">+	save_gs_cb(prev-&gt;thread.gs_cb);					\</span>
 	update_cr_regs(next);						\
<span class="p_del">-	if (next-&gt;mm) {							\</span>
<span class="p_del">-		set_cpu_flag(CIF_FPU);					\</span>
<span class="p_del">-		restore_access_regs(&amp;next-&gt;thread.acrs[0]);		\</span>
<span class="p_del">-		restore_ri_cb(next-&gt;thread.ri_cb, prev-&gt;thread.ri_cb);	\</span>
<span class="p_del">-		restore_gs_cb(next-&gt;thread.gs_cb);			\</span>
<span class="p_del">-	}								\</span>
<span class="p_del">-	prev = __switch_to(prev,next);					\</span>
<span class="p_add">+	restore_access_regs(&amp;next-&gt;thread.acrs[0]);			\</span>
<span class="p_add">+	restore_ri_cb(next-&gt;thread.ri_cb, prev-&gt;thread.ri_cb);		\</span>
<span class="p_add">+	restore_gs_cb(next-&gt;thread.gs_cb);				\</span>
<span class="p_add">+	prev = __switch_to(prev, next);					\</span>
 } while (0)
 
 #endif /* __ASM_SWITCH_TO_H */
<span class="p_header">diff --git a/arch/s390/kernel/syscalls.S b/arch/s390/kernel/syscalls.S</span>
<span class="p_header">index d39f121e67a9..bc905ae1d5c8 100644</span>
<span class="p_header">--- a/arch/s390/kernel/syscalls.S</span>
<span class="p_header">+++ b/arch/s390/kernel/syscalls.S</span>
<span class="p_chunk">@@ -370,10 +370,10 @@</span> <span class="p_context"> SYSCALL(sys_recvmmsg,compat_sys_recvmmsg)</span>
 SYSCALL(sys_sendmmsg,compat_sys_sendmmsg)
 SYSCALL(sys_socket,sys_socket)
 SYSCALL(sys_socketpair,compat_sys_socketpair)		/* 360 */
<span class="p_del">-SYSCALL(sys_bind,sys_bind)</span>
<span class="p_del">-SYSCALL(sys_connect,sys_connect)</span>
<span class="p_add">+SYSCALL(sys_bind,compat_sys_bind)</span>
<span class="p_add">+SYSCALL(sys_connect,compat_sys_connect)</span>
 SYSCALL(sys_listen,sys_listen)
<span class="p_del">-SYSCALL(sys_accept4,sys_accept4)</span>
<span class="p_add">+SYSCALL(sys_accept4,compat_sys_accept4)</span>
 SYSCALL(sys_getsockopt,compat_sys_getsockopt)		/* 365 */
 SYSCALL(sys_setsockopt,compat_sys_setsockopt)
 SYSCALL(sys_getsockname,compat_sys_getsockname)
<span class="p_header">diff --git a/arch/s390/kvm/priv.c b/arch/s390/kvm/priv.c</span>
<span class="p_header">index c954ac49eee4..5b25287f449b 100644</span>
<span class="p_header">--- a/arch/s390/kvm/priv.c</span>
<span class="p_header">+++ b/arch/s390/kvm/priv.c</span>
<span class="p_chunk">@@ -235,8 +235,6 @@</span> <span class="p_context"> static int try_handle_skey(struct kvm_vcpu *vcpu)</span>
 		VCPU_EVENT(vcpu, 4, &quot;%s&quot;, &quot;retrying storage key operation&quot;);
 		return -EAGAIN;
 	}
<span class="p_del">-	if (vcpu-&gt;arch.sie_block-&gt;gpsw.mask &amp; PSW_MASK_PSTATE)</span>
<span class="p_del">-		return kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -247,6 +245,9 @@</span> <span class="p_context"> static int handle_iske(struct kvm_vcpu *vcpu)</span>
 	int reg1, reg2;
 	int rc;
 
<span class="p_add">+	if (vcpu-&gt;arch.sie_block-&gt;gpsw.mask &amp; PSW_MASK_PSTATE)</span>
<span class="p_add">+		return kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);</span>
<span class="p_add">+</span>
 	rc = try_handle_skey(vcpu);
 	if (rc)
 		return rc != -EAGAIN ? rc : 0;
<span class="p_chunk">@@ -276,6 +277,9 @@</span> <span class="p_context"> static int handle_rrbe(struct kvm_vcpu *vcpu)</span>
 	int reg1, reg2;
 	int rc;
 
<span class="p_add">+	if (vcpu-&gt;arch.sie_block-&gt;gpsw.mask &amp; PSW_MASK_PSTATE)</span>
<span class="p_add">+		return kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);</span>
<span class="p_add">+</span>
 	rc = try_handle_skey(vcpu);
 	if (rc)
 		return rc != -EAGAIN ? rc : 0;
<span class="p_chunk">@@ -311,6 +315,9 @@</span> <span class="p_context"> static int handle_sske(struct kvm_vcpu *vcpu)</span>
 	int reg1, reg2;
 	int rc;
 
<span class="p_add">+	if (vcpu-&gt;arch.sie_block-&gt;gpsw.mask &amp; PSW_MASK_PSTATE)</span>
<span class="p_add">+		return kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);</span>
<span class="p_add">+</span>
 	rc = try_handle_skey(vcpu);
 	if (rc)
 		return rc != -EAGAIN ? rc : 0;
<span class="p_header">diff --git a/arch/s390/mm/pgalloc.c b/arch/s390/mm/pgalloc.c</span>
<span class="p_header">index cc2faffa7d6e..334b6d103cbd 100644</span>
<span class="p_header">--- a/arch/s390/mm/pgalloc.c</span>
<span class="p_header">+++ b/arch/s390/mm/pgalloc.c</span>
<span class="p_chunk">@@ -85,8 +85,6 @@</span> <span class="p_context"> int crst_table_upgrade(struct mm_struct *mm, unsigned long end)</span>
 
 	/* upgrade should only happen from 3 to 4, 3 to 5, or 4 to 5 levels */
 	VM_BUG_ON(mm-&gt;context.asce_limit &lt; _REGION2_SIZE);
<span class="p_del">-	if (end &gt;= TASK_SIZE_MAX)</span>
<span class="p_del">-		return -ENOMEM;</span>
 	rc = 0;
 	notify = 0;
 	while (mm-&gt;context.asce_limit &lt; end) {
<span class="p_header">diff --git a/arch/sparc/mm/init_64.c b/arch/sparc/mm/init_64.c</span>
<span class="p_header">index 61bdc1270d19..a0cc1be767c8 100644</span>
<span class="p_header">--- a/arch/sparc/mm/init_64.c</span>
<span class="p_header">+++ b/arch/sparc/mm/init_64.c</span>
<span class="p_chunk">@@ -2540,9 +2540,16 @@</span> <span class="p_context"> void __init mem_init(void)</span>
 {
 	high_memory = __va(last_valid_pfn &lt;&lt; PAGE_SHIFT);
 
<span class="p_del">-	register_page_bootmem_info();</span>
 	free_all_bootmem();
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Must be done after boot memory is put on freelist, because here we</span>
<span class="p_add">+	 * might set fields in deferred struct pages that have not yet been</span>
<span class="p_add">+	 * initialized, and free_all_bootmem() initializes all the reserved</span>
<span class="p_add">+	 * deferred pages for us.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	register_page_bootmem_info();</span>
<span class="p_add">+</span>
 	/*
 	 * Set up the zero page, mark it reserved, so that page count
 	 * is not manipulated when freeing the page from user ptes.
<span class="p_header">diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h</span>
<span class="p_header">index c73e493adf07..eb38ac9d9a31 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -1426,4 +1426,7 @@</span> <span class="p_context"> static inline int kvm_cpu_get_apicid(int mps_cpu)</span>
 #endif
 }
 
<span class="p_add">+void kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,</span>
<span class="p_add">+		unsigned long start, unsigned long end);</span>
<span class="p_add">+</span>
 #endif /* _ASM_X86_KVM_HOST_H */
<span class="p_header">diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c</span>
<span class="p_header">index 65a0ccdc3050..5e0453f18a57 100644</span>
<span class="p_header">--- a/arch/x86/kernel/smpboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/smpboot.c</span>
<span class="p_chunk">@@ -239,7 +239,7 @@</span> <span class="p_context"> static void notrace start_secondary(void *unused)</span>
 	load_cr3(swapper_pg_dir);
 	__flush_tlb_all();
 #endif
<span class="p_del">-</span>
<span class="p_add">+	load_current_idt();</span>
 	cpu_init();
 	x86_cpuinit.early_percpu_clock_init();
 	preempt_disable();
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index b21113bcf227..f366e6d3a5e1 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -6750,12 +6750,7 @@</span> <span class="p_context"> static __init int hardware_setup(void)</span>
 	memset(vmx_vmread_bitmap, 0xff, PAGE_SIZE);
 	memset(vmx_vmwrite_bitmap, 0xff, PAGE_SIZE);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Allow direct access to the PC debug port (it is often used for I/O</span>
<span class="p_del">-	 * delays, but the vmexits simply slow things down).</span>
<span class="p_del">-	 */</span>
 	memset(vmx_io_bitmap_a, 0xff, PAGE_SIZE);
<span class="p_del">-	clear_bit(0x80, vmx_io_bitmap_a);</span>
 
 	memset(vmx_io_bitmap_b, 0xff, PAGE_SIZE);
 
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 4195cbcdb310..df62cdc7a258 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -6745,6 +6745,20 @@</span> <span class="p_context"> static void kvm_vcpu_flush_tlb(struct kvm_vcpu *vcpu)</span>
 	kvm_x86_ops-&gt;tlb_flush(vcpu);
 }
 
<span class="p_add">+void kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,</span>
<span class="p_add">+		unsigned long start, unsigned long end)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long apic_address;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The physical address of apic access page is stored in the VMCS.</span>
<span class="p_add">+	 * Update it when it becomes invalid.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	apic_address = gfn_to_hva(kvm, APIC_DEFAULT_PHYS_BASE &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+	if (start &lt;= apic_address &amp;&amp; apic_address &lt; end)</span>
<span class="p_add">+		kvm_make_all_cpus_request(kvm, KVM_REQ_APIC_PAGE_RELOAD);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu)
 {
 	struct page *page = NULL;
<span class="p_header">diff --git a/arch/x86/pci/broadcom_bus.c b/arch/x86/pci/broadcom_bus.c</span>
<span class="p_header">index bb461cfd01ab..526536c81ddc 100644</span>
<span class="p_header">--- a/arch/x86/pci/broadcom_bus.c</span>
<span class="p_header">+++ b/arch/x86/pci/broadcom_bus.c</span>
<span class="p_chunk">@@ -97,7 +97,7 @@</span> <span class="p_context"> static int __init broadcom_postcore_init(void)</span>
 	 * We should get host bridge information from ACPI unless the BIOS
 	 * doesn&#39;t support it.
 	 */
<span class="p_del">-	if (acpi_os_get_root_pointer())</span>
<span class="p_add">+	if (!acpi_disabled &amp;&amp; acpi_os_get_root_pointer())</span>
 		return 0;
 #endif
 
<span class="p_header">diff --git a/block/blk-core.c b/block/blk-core.c</span>
<span class="p_header">index 33ee583cfe45..516ce3174683 100644</span>
<span class="p_header">--- a/block/blk-core.c</span>
<span class="p_header">+++ b/block/blk-core.c</span>
<span class="p_chunk">@@ -605,8 +605,8 @@</span> <span class="p_context"> void blk_set_queue_dying(struct request_queue *q)</span>
 		spin_lock_irq(q-&gt;queue_lock);
 		blk_queue_for_each_rl(rl, q) {
 			if (rl-&gt;rq_pool) {
<span class="p_del">-				wake_up(&amp;rl-&gt;wait[BLK_RW_SYNC]);</span>
<span class="p_del">-				wake_up(&amp;rl-&gt;wait[BLK_RW_ASYNC]);</span>
<span class="p_add">+				wake_up_all(&amp;rl-&gt;wait[BLK_RW_SYNC]);</span>
<span class="p_add">+				wake_up_all(&amp;rl-&gt;wait[BLK_RW_ASYNC]);</span>
 			}
 		}
 		spin_unlock_irq(q-&gt;queue_lock);
<span class="p_header">diff --git a/crypto/asymmetric_keys/pkcs7_verify.c b/crypto/asymmetric_keys/pkcs7_verify.c</span>
<span class="p_header">index 2d93d9eccb4d..986033e64a83 100644</span>
<span class="p_header">--- a/crypto/asymmetric_keys/pkcs7_verify.c</span>
<span class="p_header">+++ b/crypto/asymmetric_keys/pkcs7_verify.c</span>
<span class="p_chunk">@@ -150,7 +150,7 @@</span> <span class="p_context"> static int pkcs7_find_key(struct pkcs7_message *pkcs7,</span>
 		pr_devel(&quot;Sig %u: Found cert serial match X.509[%u]\n&quot;,
 			 sinfo-&gt;index, certix);
 
<span class="p_del">-		if (x509-&gt;pub-&gt;pkey_algo != sinfo-&gt;sig-&gt;pkey_algo) {</span>
<span class="p_add">+		if (strcmp(x509-&gt;pub-&gt;pkey_algo, sinfo-&gt;sig-&gt;pkey_algo) != 0) {</span>
 			pr_warn(&quot;Sig %u: X.509 algo and PKCS#7 sig algo don&#39;t match\n&quot;,
 				sinfo-&gt;index);
 			continue;
<span class="p_header">diff --git a/crypto/asymmetric_keys/x509_cert_parser.c b/crypto/asymmetric_keys/x509_cert_parser.c</span>
<span class="p_header">index dd03fead1ca3..ce2df8c9c583 100644</span>
<span class="p_header">--- a/crypto/asymmetric_keys/x509_cert_parser.c</span>
<span class="p_header">+++ b/crypto/asymmetric_keys/x509_cert_parser.c</span>
<span class="p_chunk">@@ -409,6 +409,8 @@</span> <span class="p_context"> int x509_extract_key_data(void *context, size_t hdrlen,</span>
 	ctx-&gt;cert-&gt;pub-&gt;pkey_algo = &quot;rsa&quot;;
 
 	/* Discard the BIT STRING metadata */
<span class="p_add">+	if (vlen &lt; 1 || *(const u8 *)value != 0)</span>
<span class="p_add">+		return -EBADMSG;</span>
 	ctx-&gt;key = value + 1;
 	ctx-&gt;key_size = vlen - 1;
 	return 0;
<span class="p_header">diff --git a/crypto/asymmetric_keys/x509_public_key.c b/crypto/asymmetric_keys/x509_public_key.c</span>
<span class="p_header">index eea71dc9686c..1bd0cf71a22d 100644</span>
<span class="p_header">--- a/crypto/asymmetric_keys/x509_public_key.c</span>
<span class="p_header">+++ b/crypto/asymmetric_keys/x509_public_key.c</span>
<span class="p_chunk">@@ -135,7 +135,7 @@</span> <span class="p_context"> int x509_check_for_self_signed(struct x509_certificate *cert)</span>
 	}
 
 	ret = -EKEYREJECTED;
<span class="p_del">-	if (cert-&gt;pub-&gt;pkey_algo != cert-&gt;sig-&gt;pkey_algo)</span>
<span class="p_add">+	if (strcmp(cert-&gt;pub-&gt;pkey_algo, cert-&gt;sig-&gt;pkey_algo) != 0)</span>
 		goto out;
 
 	ret = public_key_verify_signature(cert-&gt;pub, cert-&gt;sig);
<span class="p_header">diff --git a/drivers/atm/horizon.c b/drivers/atm/horizon.c</span>
<span class="p_header">index 7e76b35f422c..e121b8485731 100644</span>
<span class="p_header">--- a/drivers/atm/horizon.c</span>
<span class="p_header">+++ b/drivers/atm/horizon.c</span>
<span class="p_chunk">@@ -2803,7 +2803,7 @@</span> <span class="p_context"> static int hrz_probe(struct pci_dev *pci_dev,</span>
 	return err;
 
 out_free_irq:
<span class="p_del">-	free_irq(dev-&gt;irq, dev);</span>
<span class="p_add">+	free_irq(irq, dev);</span>
 out_free:
 	kfree(dev);
 out_release:
<span class="p_header">diff --git a/drivers/base/Kconfig b/drivers/base/Kconfig</span>
<span class="p_header">index 2f6614c9a229..bdc87907d6a1 100644</span>
<span class="p_header">--- a/drivers/base/Kconfig</span>
<span class="p_header">+++ b/drivers/base/Kconfig</span>
<span class="p_chunk">@@ -91,22 +91,23 @@</span> <span class="p_context"> config FIRMWARE_IN_KERNEL</span>
 	depends on FW_LOADER
 	default y
 	help
<span class="p_del">-	  The kernel source tree includes a number of firmware &#39;blobs&#39;</span>
<span class="p_del">-	  that are used by various drivers. The recommended way to</span>
<span class="p_del">-	  use these is to run &quot;make firmware_install&quot;, which, after</span>
<span class="p_del">-	  converting ihex files to binary, copies all of the needed</span>
<span class="p_del">-	  binary files in firmware/ to /lib/firmware/ on your system so</span>
<span class="p_del">-	  that they can be loaded by userspace helpers on request.</span>
<span class="p_add">+	  Various drivers in the kernel source tree may require firmware,</span>
<span class="p_add">+	  which is generally available in your distribution&#39;s linux-firmware</span>
<span class="p_add">+	  package.</span>
<span class="p_add">+</span>
<span class="p_add">+	  The linux-firmware package should install firmware into</span>
<span class="p_add">+	  /lib/firmware/ on your system, so they can be loaded by userspace</span>
<span class="p_add">+	  helpers on request.</span>
 
 	  Enabling this option will build each required firmware blob
<span class="p_del">-	  into the kernel directly, where request_firmware() will find</span>
<span class="p_del">-	  them without having to call out to userspace. This may be</span>
<span class="p_del">-	  useful if your root file system requires a device that uses</span>
<span class="p_del">-	  such firmware and do not wish to use an initrd.</span>
<span class="p_add">+	  specified by EXTRA_FIRMWARE into the kernel directly, where</span>
<span class="p_add">+	  request_firmware() will find them without having to call out to</span>
<span class="p_add">+	  userspace. This may be useful if your root file system requires a</span>
<span class="p_add">+	  device that uses such firmware and you do not wish to use an</span>
<span class="p_add">+	  initrd.</span>
 
 	  This single option controls the inclusion of firmware for
<span class="p_del">-	  every driver that uses request_firmware() and ships its</span>
<span class="p_del">-	  firmware in the kernel source tree, which avoids a</span>
<span class="p_add">+	  every driver that uses request_firmware(), which avoids a</span>
 	  proliferation of &#39;Include firmware for xxx device&#39; options.
 
 	  Say &#39;N&#39; and let firmware be loaded from userspace.
<span class="p_header">diff --git a/drivers/base/isa.c b/drivers/base/isa.c</span>
<span class="p_header">index cd6ccdcf9df0..372d10af2600 100644</span>
<span class="p_header">--- a/drivers/base/isa.c</span>
<span class="p_header">+++ b/drivers/base/isa.c</span>
<span class="p_chunk">@@ -39,7 +39,7 @@</span> <span class="p_context"> static int isa_bus_probe(struct device *dev)</span>
 {
 	struct isa_driver *isa_driver = dev-&gt;platform_data;
 
<span class="p_del">-	if (isa_driver-&gt;probe)</span>
<span class="p_add">+	if (isa_driver &amp;&amp; isa_driver-&gt;probe)</span>
 		return isa_driver-&gt;probe(dev, to_isa_dev(dev)-&gt;id);
 
 	return 0;
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> static int isa_bus_remove(struct device *dev)</span>
 {
 	struct isa_driver *isa_driver = dev-&gt;platform_data;
 
<span class="p_del">-	if (isa_driver-&gt;remove)</span>
<span class="p_add">+	if (isa_driver &amp;&amp; isa_driver-&gt;remove)</span>
 		return isa_driver-&gt;remove(dev, to_isa_dev(dev)-&gt;id);
 
 	return 0;
<span class="p_chunk">@@ -59,7 +59,7 @@</span> <span class="p_context"> static void isa_bus_shutdown(struct device *dev)</span>
 {
 	struct isa_driver *isa_driver = dev-&gt;platform_data;
 
<span class="p_del">-	if (isa_driver-&gt;shutdown)</span>
<span class="p_add">+	if (isa_driver &amp;&amp; isa_driver-&gt;shutdown)</span>
 		isa_driver-&gt;shutdown(dev, to_isa_dev(dev)-&gt;id);
 }
 
<span class="p_chunk">@@ -67,7 +67,7 @@</span> <span class="p_context"> static int isa_bus_suspend(struct device *dev, pm_message_t state)</span>
 {
 	struct isa_driver *isa_driver = dev-&gt;platform_data;
 
<span class="p_del">-	if (isa_driver-&gt;suspend)</span>
<span class="p_add">+	if (isa_driver &amp;&amp; isa_driver-&gt;suspend)</span>
 		return isa_driver-&gt;suspend(dev, to_isa_dev(dev)-&gt;id, state);
 
 	return 0;
<span class="p_chunk">@@ -77,7 +77,7 @@</span> <span class="p_context"> static int isa_bus_resume(struct device *dev)</span>
 {
 	struct isa_driver *isa_driver = dev-&gt;platform_data;
 
<span class="p_del">-	if (isa_driver-&gt;resume)</span>
<span class="p_add">+	if (isa_driver &amp;&amp; isa_driver-&gt;resume)</span>
 		return isa_driver-&gt;resume(dev, to_isa_dev(dev)-&gt;id);
 
 	return 0;
<span class="p_header">diff --git a/drivers/bus/arm-cci.c b/drivers/bus/arm-cci.c</span>
<span class="p_header">index 3c29d36702a8..5426c04fe24b 100644</span>
<span class="p_header">--- a/drivers/bus/arm-cci.c</span>
<span class="p_header">+++ b/drivers/bus/arm-cci.c</span>
<span class="p_chunk">@@ -1755,14 +1755,17 @@</span> <span class="p_context"> static int cci_pmu_probe(struct platform_device *pdev)</span>
 	raw_spin_lock_init(&amp;cci_pmu-&gt;hw_events.pmu_lock);
 	mutex_init(&amp;cci_pmu-&gt;reserve_mutex);
 	atomic_set(&amp;cci_pmu-&gt;active_events, 0);
<span class="p_del">-	cpumask_set_cpu(smp_processor_id(), &amp;cci_pmu-&gt;cpus);</span>
<span class="p_add">+	cpumask_set_cpu(get_cpu(), &amp;cci_pmu-&gt;cpus);</span>
 
 	ret = cci_pmu_init(cci_pmu, pdev);
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		put_cpu();</span>
 		return ret;
<span class="p_add">+	}</span>
 
 	cpuhp_state_add_instance_nocalls(CPUHP_AP_PERF_ARM_CCI_ONLINE,
 					 &amp;cci_pmu-&gt;node);
<span class="p_add">+	put_cpu();</span>
 	pr_info(&quot;ARM %s PMU driver probed&quot;, cci_pmu-&gt;model-&gt;name);
 	return 0;
 }
<span class="p_header">diff --git a/drivers/bus/arm-ccn.c b/drivers/bus/arm-ccn.c</span>
<span class="p_header">index e8c6946fed9d..03d7faf51c2b 100644</span>
<span class="p_header">--- a/drivers/bus/arm-ccn.c</span>
<span class="p_header">+++ b/drivers/bus/arm-ccn.c</span>
<span class="p_chunk">@@ -1271,6 +1271,10 @@</span> <span class="p_context"> static int arm_ccn_pmu_init(struct arm_ccn *ccn)</span>
 		int len = snprintf(NULL, 0, &quot;ccn_%d&quot;, ccn-&gt;dt.id);
 
 		name = devm_kzalloc(ccn-&gt;dev, len + 1, GFP_KERNEL);
<span class="p_add">+		if (!name) {</span>
<span class="p_add">+			err = -ENOMEM;</span>
<span class="p_add">+			goto error_choose_name;</span>
<span class="p_add">+		}</span>
 		snprintf(name, len + 1, &quot;ccn_%d&quot;, ccn-&gt;dt.id);
 	}
 
<span class="p_chunk">@@ -1297,7 +1301,7 @@</span> <span class="p_context"> static int arm_ccn_pmu_init(struct arm_ccn *ccn)</span>
 	}
 
 	/* Pick one CPU which we will use to collect data from CCN... */
<span class="p_del">-	cpumask_set_cpu(smp_processor_id(), &amp;ccn-&gt;dt.cpu);</span>
<span class="p_add">+	cpumask_set_cpu(get_cpu(), &amp;ccn-&gt;dt.cpu);</span>
 
 	/* Also make sure that the overflow interrupt is handled by this CPU */
 	if (ccn-&gt;irq) {
<span class="p_chunk">@@ -1314,10 +1318,13 @@</span> <span class="p_context"> static int arm_ccn_pmu_init(struct arm_ccn *ccn)</span>
 
 	cpuhp_state_add_instance_nocalls(CPUHP_AP_PERF_ARM_CCN_ONLINE,
 					 &amp;ccn-&gt;dt.node);
<span class="p_add">+	put_cpu();</span>
 	return 0;
 
 error_pmu_register:
 error_set_affinity:
<span class="p_add">+	put_cpu();</span>
<span class="p_add">+error_choose_name:</span>
 	ida_simple_remove(&amp;arm_ccn_pmu_ida, ccn-&gt;dt.id);
 	for (i = 0; i &lt; ccn-&gt;num_xps; i++)
 		writel(0, ccn-&gt;xp[i].base + CCN_XP_DT_CONTROL);
<span class="p_chunk">@@ -1580,8 +1587,8 @@</span> <span class="p_context"> static int __init arm_ccn_init(void)</span>
 
 static void __exit arm_ccn_exit(void)
 {
<span class="p_del">-	cpuhp_remove_multi_state(CPUHP_AP_PERF_ARM_CCN_ONLINE);</span>
 	platform_driver_unregister(&amp;arm_ccn_driver);
<span class="p_add">+	cpuhp_remove_multi_state(CPUHP_AP_PERF_ARM_CCN_ONLINE);</span>
 }
 
 module_init(arm_ccn_init);
<span class="p_header">diff --git a/drivers/clk/clk-stm32h7.c b/drivers/clk/clk-stm32h7.c</span>
<span class="p_header">index a94c3f56c590..61c3e40507d3 100644</span>
<span class="p_header">--- a/drivers/clk/clk-stm32h7.c</span>
<span class="p_header">+++ b/drivers/clk/clk-stm32h7.c</span>
<span class="p_chunk">@@ -384,7 +384,7 @@</span> <span class="p_context"> static void get_cfg_composite_div(const struct composite_clk_gcfg *gcfg,</span>
 	mux_ops = div_ops = gate_ops = NULL;
 	mux_hw = div_hw = gate_hw = NULL;
 
<span class="p_del">-	if (gcfg-&gt;mux &amp;&amp; gcfg-&gt;mux) {</span>
<span class="p_add">+	if (gcfg-&gt;mux &amp;&amp; cfg-&gt;mux) {</span>
 		mux = _get_cmux(base + cfg-&gt;mux-&gt;offset,
 				cfg-&gt;mux-&gt;shift,
 				cfg-&gt;mux-&gt;width,
<span class="p_chunk">@@ -410,7 +410,7 @@</span> <span class="p_context"> static void get_cfg_composite_div(const struct composite_clk_gcfg *gcfg,</span>
 		}
 	}
 
<span class="p_del">-	if (gcfg-&gt;gate &amp;&amp; gcfg-&gt;gate) {</span>
<span class="p_add">+	if (gcfg-&gt;gate &amp;&amp; cfg-&gt;gate) {</span>
 		gate = _get_cgate(base + cfg-&gt;gate-&gt;offset,
 				cfg-&gt;gate-&gt;bit_idx,
 				gcfg-&gt;gate-&gt;flags, lock);
<span class="p_header">diff --git a/drivers/clk/hisilicon/clk-hi3660.c b/drivers/clk/hisilicon/clk-hi3660.c</span>
<span class="p_header">index a18258eb89cb..f40419959656 100644</span>
<span class="p_header">--- a/drivers/clk/hisilicon/clk-hi3660.c</span>
<span class="p_header">+++ b/drivers/clk/hisilicon/clk-hi3660.c</span>
<span class="p_chunk">@@ -34,7 +34,7 @@</span> <span class="p_context"> static const struct hisi_fixed_rate_clock hi3660_fixed_rate_clks[] = {</span>
 
 /* crgctrl */
 static const struct hisi_fixed_factor_clock hi3660_crg_fixed_factor_clks[] = {
<span class="p_del">-	{ HI3660_FACTOR_UART3, &quot;clk_factor_uart3&quot;, &quot;iomcu_peri0&quot;, 1, 8, 0, },</span>
<span class="p_add">+	{ HI3660_FACTOR_UART3, &quot;clk_factor_uart3&quot;, &quot;iomcu_peri0&quot;, 1, 16, 0, },</span>
 	{ HI3660_CLK_FACTOR_MMC, &quot;clk_factor_mmc&quot;, &quot;clkin_sys&quot;, 1, 6, 0, },
 	{ HI3660_CLK_GATE_I2C0, &quot;clk_gate_i2c0&quot;, &quot;clk_i2c0_iomcu&quot;, 1, 4, 0, },
 	{ HI3660_CLK_GATE_I2C1, &quot;clk_gate_i2c1&quot;, &quot;clk_i2c1_iomcu&quot;, 1, 4, 0, },
<span class="p_header">diff --git a/drivers/clk/qcom/common.c b/drivers/clk/qcom/common.c</span>
<span class="p_header">index d523991c945f..28ceaf1e9937 100644</span>
<span class="p_header">--- a/drivers/clk/qcom/common.c</span>
<span class="p_header">+++ b/drivers/clk/qcom/common.c</span>
<span class="p_chunk">@@ -143,8 +143,10 @@</span> <span class="p_context"> static int _qcom_cc_register_board_clk(struct device *dev, const char *path,</span>
 	int ret;
 
 	clocks_node = of_find_node_by_path(&quot;/clocks&quot;);
<span class="p_del">-	if (clocks_node)</span>
<span class="p_del">-		node = of_find_node_by_name(clocks_node, path);</span>
<span class="p_add">+	if (clocks_node) {</span>
<span class="p_add">+		node = of_get_child_by_name(clocks_node, path);</span>
<span class="p_add">+		of_node_put(clocks_node);</span>
<span class="p_add">+	}</span>
 
 	if (!node) {
 		fixed = devm_kzalloc(dev, sizeof(*fixed), GFP_KERNEL);
<span class="p_header">diff --git a/drivers/clk/sunxi-ng/ccu-sun8i-a83t.c b/drivers/clk/sunxi-ng/ccu-sun8i-a83t.c</span>
<span class="p_header">index e43acebdfbcd..f8203115a6bc 100644</span>
<span class="p_header">--- a/drivers/clk/sunxi-ng/ccu-sun8i-a83t.c</span>
<span class="p_header">+++ b/drivers/clk/sunxi-ng/ccu-sun8i-a83t.c</span>
<span class="p_chunk">@@ -354,9 +354,9 @@</span> <span class="p_context"> static SUNXI_CCU_GATE(bus_tdm_clk,	&quot;bus-tdm&quot;,	&quot;apb1&quot;,</span>
 static SUNXI_CCU_GATE(bus_i2c0_clk,	&quot;bus-i2c0&quot;,	&quot;apb2&quot;,
 		      0x06c, BIT(0), 0);
 static SUNXI_CCU_GATE(bus_i2c1_clk,	&quot;bus-i2c1&quot;,	&quot;apb2&quot;,
<span class="p_del">-		      0x06c, BIT(0), 0);</span>
<span class="p_add">+		      0x06c, BIT(1), 0);</span>
 static SUNXI_CCU_GATE(bus_i2c2_clk,	&quot;bus-i2c2&quot;,	&quot;apb2&quot;,
<span class="p_del">-		      0x06c, BIT(0), 0);</span>
<span class="p_add">+		      0x06c, BIT(2), 0);</span>
 static SUNXI_CCU_GATE(bus_uart0_clk,	&quot;bus-uart0&quot;,	&quot;apb2&quot;,
 		      0x06c, BIT(16), 0);
 static SUNXI_CCU_GATE(bus_uart1_clk,	&quot;bus-uart1&quot;,	&quot;apb2&quot;,
<span class="p_header">diff --git a/drivers/clk/uniphier/clk-uniphier-sys.c b/drivers/clk/uniphier/clk-uniphier-sys.c</span>
<span class="p_header">index 07f3b91a7daf..d244e724e198 100644</span>
<span class="p_header">--- a/drivers/clk/uniphier/clk-uniphier-sys.c</span>
<span class="p_header">+++ b/drivers/clk/uniphier/clk-uniphier-sys.c</span>
<span class="p_chunk">@@ -123,7 +123,7 @@</span> <span class="p_context"> const struct uniphier_clk_data uniphier_sld8_sys_clk_data[] = {</span>
 const struct uniphier_clk_data uniphier_pro5_sys_clk_data[] = {
 	UNIPHIER_CLK_FACTOR(&quot;spll&quot;, -1, &quot;ref&quot;, 120, 1),		/* 2400 MHz */
 	UNIPHIER_CLK_FACTOR(&quot;dapll1&quot;, -1, &quot;ref&quot;, 128, 1),	/* 2560 MHz */
<span class="p_del">-	UNIPHIER_CLK_FACTOR(&quot;dapll2&quot;, -1, &quot;ref&quot;, 144, 125),	/* 2949.12 MHz */</span>
<span class="p_add">+	UNIPHIER_CLK_FACTOR(&quot;dapll2&quot;, -1, &quot;dapll1&quot;, 144, 125),	/* 2949.12 MHz */</span>
 	UNIPHIER_CLK_FACTOR(&quot;uart&quot;, 0, &quot;dapll2&quot;, 1, 40),
 	UNIPHIER_CLK_FACTOR(&quot;i2c&quot;, 1, &quot;spll&quot;, 1, 48),
 	UNIPHIER_PRO5_SYS_CLK_NAND(2),
<span class="p_header">diff --git a/drivers/crypto/talitos.c b/drivers/crypto/talitos.c</span>
<span class="p_header">index dff88838dce7..a19b5d0300a9 100644</span>
<span class="p_header">--- a/drivers/crypto/talitos.c</span>
<span class="p_header">+++ b/drivers/crypto/talitos.c</span>
<span class="p_chunk">@@ -1232,12 +1232,11 @@</span> <span class="p_context"> static int ipsec_esp(struct talitos_edesc *edesc, struct aead_request *areq,</span>
 			sg_link_tbl_len += authsize;
 	}
 
<span class="p_del">-	sg_count = talitos_sg_map(dev, areq-&gt;src, cryptlen, edesc,</span>
<span class="p_del">-				  &amp;desc-&gt;ptr[4], sg_count, areq-&gt;assoclen,</span>
<span class="p_del">-				  tbl_off);</span>
<span class="p_add">+	ret = talitos_sg_map(dev, areq-&gt;src, sg_link_tbl_len, edesc,</span>
<span class="p_add">+			     &amp;desc-&gt;ptr[4], sg_count, areq-&gt;assoclen, tbl_off);</span>
 
<span class="p_del">-	if (sg_count &gt; 1) {</span>
<span class="p_del">-		tbl_off += sg_count;</span>
<span class="p_add">+	if (ret &gt; 1) {</span>
<span class="p_add">+		tbl_off += ret;</span>
 		sync_needed = true;
 	}
 
<span class="p_chunk">@@ -1248,14 +1247,15 @@</span> <span class="p_context"> static int ipsec_esp(struct talitos_edesc *edesc, struct aead_request *areq,</span>
 			dma_map_sg(dev, areq-&gt;dst, sg_count, DMA_FROM_DEVICE);
 	}
 
<span class="p_del">-	sg_count = talitos_sg_map(dev, areq-&gt;dst, cryptlen, edesc,</span>
<span class="p_del">-				  &amp;desc-&gt;ptr[5], sg_count, areq-&gt;assoclen,</span>
<span class="p_del">-				  tbl_off);</span>
<span class="p_add">+	ret = talitos_sg_map(dev, areq-&gt;dst, cryptlen, edesc, &amp;desc-&gt;ptr[5],</span>
<span class="p_add">+			     sg_count, areq-&gt;assoclen, tbl_off);</span>
 
 	if (desc-&gt;hdr &amp; DESC_HDR_TYPE_IPSEC_ESP)
 		to_talitos_ptr_ext_or(&amp;desc-&gt;ptr[5], authsize, is_sec1);
 
<span class="p_del">-	if (sg_count &gt; 1) {</span>
<span class="p_add">+	/* ICV data */</span>
<span class="p_add">+	if (ret &gt; 1) {</span>
<span class="p_add">+		tbl_off += ret;</span>
 		edesc-&gt;icv_ool = true;
 		sync_needed = true;
 
<span class="p_chunk">@@ -1265,9 +1265,7 @@</span> <span class="p_context"> static int ipsec_esp(struct talitos_edesc *edesc, struct aead_request *areq,</span>
 				     sizeof(struct talitos_ptr) + authsize;
 
 			/* Add an entry to the link table for ICV data */
<span class="p_del">-			tbl_ptr += sg_count - 1;</span>
<span class="p_del">-			to_talitos_ptr_ext_set(tbl_ptr, 0, is_sec1);</span>
<span class="p_del">-			tbl_ptr++;</span>
<span class="p_add">+			to_talitos_ptr_ext_set(tbl_ptr - 1, 0, is_sec1);</span>
 			to_talitos_ptr_ext_set(tbl_ptr, DESC_PTR_LNKTBL_RETURN,
 					       is_sec1);
 			to_talitos_ptr_len(tbl_ptr, authsize, is_sec1);
<span class="p_chunk">@@ -1275,18 +1273,33 @@</span> <span class="p_context"> static int ipsec_esp(struct talitos_edesc *edesc, struct aead_request *areq,</span>
 			/* icv data follows link tables */
 			to_talitos_ptr(tbl_ptr, edesc-&gt;dma_link_tbl + offset,
 				       is_sec1);
<span class="p_add">+		} else {</span>
<span class="p_add">+			dma_addr_t addr = edesc-&gt;dma_link_tbl;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (is_sec1)</span>
<span class="p_add">+				addr += areq-&gt;assoclen + cryptlen;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				addr += sizeof(struct talitos_ptr) * tbl_off;</span>
<span class="p_add">+</span>
<span class="p_add">+			to_talitos_ptr(&amp;desc-&gt;ptr[6], addr, is_sec1);</span>
<span class="p_add">+			to_talitos_ptr_len(&amp;desc-&gt;ptr[6], authsize, is_sec1);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else if (!(desc-&gt;hdr &amp; DESC_HDR_TYPE_IPSEC_ESP)) {</span>
<span class="p_add">+		ret = talitos_sg_map(dev, areq-&gt;dst, authsize, edesc,</span>
<span class="p_add">+				     &amp;desc-&gt;ptr[6], sg_count, areq-&gt;assoclen +</span>
<span class="p_add">+							      cryptlen,</span>
<span class="p_add">+				     tbl_off);</span>
<span class="p_add">+		if (ret &gt; 1) {</span>
<span class="p_add">+			tbl_off += ret;</span>
<span class="p_add">+			edesc-&gt;icv_ool = true;</span>
<span class="p_add">+			sync_needed = true;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			edesc-&gt;icv_ool = false;</span>
 		}
 	} else {
 		edesc-&gt;icv_ool = false;
 	}
 
<span class="p_del">-	/* ICV data */</span>
<span class="p_del">-	if (!(desc-&gt;hdr &amp; DESC_HDR_TYPE_IPSEC_ESP)) {</span>
<span class="p_del">-		to_talitos_ptr_len(&amp;desc-&gt;ptr[6], authsize, is_sec1);</span>
<span class="p_del">-		to_talitos_ptr(&amp;desc-&gt;ptr[6], edesc-&gt;dma_link_tbl +</span>
<span class="p_del">-			       areq-&gt;assoclen + cryptlen, is_sec1);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	/* iv out */
 	if (desc-&gt;hdr &amp; DESC_HDR_TYPE_IPSEC_ESP)
 		map_single_talitos_ptr(dev, &amp;desc-&gt;ptr[6], ivsize, ctx-&gt;iv,
<span class="p_chunk">@@ -1494,12 +1507,20 @@</span> <span class="p_context"> static int ablkcipher_setkey(struct crypto_ablkcipher *cipher,</span>
 			     const u8 *key, unsigned int keylen)
 {
 	struct talitos_ctx *ctx = crypto_ablkcipher_ctx(cipher);
<span class="p_add">+	u32 tmp[DES_EXPKEY_WORDS];</span>
 
 	if (keylen &gt; TALITOS_MAX_KEY_SIZE) {
 		crypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);
 		return -EINVAL;
 	}
 
<span class="p_add">+	if (unlikely(crypto_ablkcipher_get_flags(cipher) &amp;</span>
<span class="p_add">+		     CRYPTO_TFM_REQ_WEAK_KEY) &amp;&amp;</span>
<span class="p_add">+	    !des_ekey(tmp, key)) {</span>
<span class="p_add">+		crypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_WEAK_KEY);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	memcpy(&amp;ctx-&gt;key, key, keylen);
 	ctx-&gt;keylen = keylen;
 
<span class="p_chunk">@@ -2614,7 +2635,7 @@</span> <span class="p_context"> static struct talitos_alg_template driver_algs[] = {</span>
 				.ivsize = AES_BLOCK_SIZE,
 			}
 		},
<span class="p_del">-		.desc_hdr_template = DESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU |</span>
<span class="p_add">+		.desc_hdr_template = DESC_HDR_TYPE_AESU_CTR_NONSNOOP |</span>
 				     DESC_HDR_SEL0_AESU |
 				     DESC_HDR_MODE0_AESU_CTR,
 	},
<span class="p_chunk">@@ -3047,6 +3068,11 @@</span> <span class="p_context"> static struct talitos_crypto_alg *talitos_alg_alloc(struct device *dev,</span>
 		t_alg-&gt;algt.alg.aead.setkey = aead_setkey;
 		t_alg-&gt;algt.alg.aead.encrypt = aead_encrypt;
 		t_alg-&gt;algt.alg.aead.decrypt = aead_decrypt;
<span class="p_add">+		if (!(priv-&gt;features &amp; TALITOS_FTR_SHA224_HWINIT) &amp;&amp;</span>
<span class="p_add">+		    !strncmp(alg-&gt;cra_name, &quot;authenc(hmac(sha224)&quot;, 20)) {</span>
<span class="p_add">+			kfree(t_alg);</span>
<span class="p_add">+			return ERR_PTR(-ENOTSUPP);</span>
<span class="p_add">+		}</span>
 		break;
 	case CRYPTO_ALG_TYPE_AHASH:
 		alg = &amp;t_alg-&gt;algt.alg.hash.halg.base;
<span class="p_header">diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c</span>
<span class="p_header">index f70febf680c3..c3eefa126e3b 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/efi.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/efi.c</span>
<span class="p_chunk">@@ -143,8 +143,7 @@</span> <span class="p_context"> static ssize_t systab_show(struct kobject *kobj,</span>
 	return str - buf;
 }
 
<span class="p_del">-static struct kobj_attribute efi_attr_systab =</span>
<span class="p_del">-			__ATTR(systab, 0400, systab_show, NULL);</span>
<span class="p_add">+static struct kobj_attribute efi_attr_systab = __ATTR_RO_MODE(systab, 0400);</span>
 
 #define EFI_FIELD(var) efi.var
 
<span class="p_header">diff --git a/drivers/firmware/efi/esrt.c b/drivers/firmware/efi/esrt.c</span>
<span class="p_header">index bd7ed3c1148a..c47e0c6ec00f 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/esrt.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/esrt.c</span>
<span class="p_chunk">@@ -106,7 +106,7 @@</span> <span class="p_context"> static const struct sysfs_ops esre_attr_ops = {</span>
 };
 
 /* Generic ESRT Entry (&quot;ESRE&quot;) support. */
<span class="p_del">-static ssize_t esre_fw_class_show(struct esre_entry *entry, char *buf)</span>
<span class="p_add">+static ssize_t fw_class_show(struct esre_entry *entry, char *buf)</span>
 {
 	char *str = buf;
 
<span class="p_chunk">@@ -117,18 +117,16 @@</span> <span class="p_context"> static ssize_t esre_fw_class_show(struct esre_entry *entry, char *buf)</span>
 	return str - buf;
 }
 
<span class="p_del">-static struct esre_attribute esre_fw_class = __ATTR(fw_class, 0400,</span>
<span class="p_del">-	esre_fw_class_show, NULL);</span>
<span class="p_add">+static struct esre_attribute esre_fw_class = __ATTR_RO_MODE(fw_class, 0400);</span>
 
 #define esre_attr_decl(name, size, fmt) \
<span class="p_del">-static ssize_t esre_##name##_show(struct esre_entry *entry, char *buf) \</span>
<span class="p_add">+static ssize_t name##_show(struct esre_entry *entry, char *buf) \</span>
 { \
 	return sprintf(buf, fmt &quot;\n&quot;, \
 		       le##size##_to_cpu(entry-&gt;esre.esre1-&gt;name)); \
 } \
 \
<span class="p_del">-static struct esre_attribute esre_##name = __ATTR(name, 0400, \</span>
<span class="p_del">-	esre_##name##_show, NULL)</span>
<span class="p_add">+static struct esre_attribute esre_##name = __ATTR_RO_MODE(name, 0400)</span>
 
 esre_attr_decl(fw_type, 32, &quot;%u&quot;);
 esre_attr_decl(fw_version, 32, &quot;%u&quot;);
<span class="p_chunk">@@ -193,14 +191,13 @@</span> <span class="p_context"> static int esre_create_sysfs_entry(void *esre, int entry_num)</span>
 
 /* support for displaying ESRT fields at the top level */
 #define esrt_attr_decl(name, size, fmt) \
<span class="p_del">-static ssize_t esrt_##name##_show(struct kobject *kobj, \</span>
<span class="p_add">+static ssize_t name##_show(struct kobject *kobj, \</span>
 				  struct kobj_attribute *attr, char *buf)\
 { \
 	return sprintf(buf, fmt &quot;\n&quot;, le##size##_to_cpu(esrt-&gt;name)); \
 } \
 \
<span class="p_del">-static struct kobj_attribute esrt_##name = __ATTR(name, 0400, \</span>
<span class="p_del">-	esrt_##name##_show, NULL)</span>
<span class="p_add">+static struct kobj_attribute esrt_##name = __ATTR_RO_MODE(name, 0400)</span>
 
 esrt_attr_decl(fw_resource_count, 32, &quot;%u&quot;);
 esrt_attr_decl(fw_resource_count_max, 32, &quot;%u&quot;);
<span class="p_chunk">@@ -431,7 +428,7 @@</span> <span class="p_context"> static int __init esrt_sysfs_init(void)</span>
 err_remove_esrt:
 	kobject_put(esrt_kobj);
 err:
<span class="p_del">-	kfree(esrt);</span>
<span class="p_add">+	memunmap(esrt);</span>
 	esrt = NULL;
 	return error;
 }
<span class="p_header">diff --git a/drivers/firmware/efi/runtime-map.c b/drivers/firmware/efi/runtime-map.c</span>
<span class="p_header">index 8e64b77aeac9..f377609ff141 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/runtime-map.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/runtime-map.c</span>
<span class="p_chunk">@@ -63,11 +63,11 @@</span> <span class="p_context"> static ssize_t map_attr_show(struct kobject *kobj, struct attribute *attr,</span>
 	return map_attr-&gt;show(entry, buf);
 }
 
<span class="p_del">-static struct map_attribute map_type_attr = __ATTR_RO(type);</span>
<span class="p_del">-static struct map_attribute map_phys_addr_attr   = __ATTR_RO(phys_addr);</span>
<span class="p_del">-static struct map_attribute map_virt_addr_attr  = __ATTR_RO(virt_addr);</span>
<span class="p_del">-static struct map_attribute map_num_pages_attr  = __ATTR_RO(num_pages);</span>
<span class="p_del">-static struct map_attribute map_attribute_attr  = __ATTR_RO(attribute);</span>
<span class="p_add">+static struct map_attribute map_type_attr = __ATTR_RO_MODE(type, 0400);</span>
<span class="p_add">+static struct map_attribute map_phys_addr_attr = __ATTR_RO_MODE(phys_addr, 0400);</span>
<span class="p_add">+static struct map_attribute map_virt_addr_attr = __ATTR_RO_MODE(virt_addr, 0400);</span>
<span class="p_add">+static struct map_attribute map_num_pages_attr = __ATTR_RO_MODE(num_pages, 0400);</span>
<span class="p_add">+static struct map_attribute map_attribute_attr = __ATTR_RO_MODE(attribute, 0400);</span>
 
 /*
  * These are default attributes that are added for every memmap entry.
<span class="p_header">diff --git a/drivers/firmware/google/vpd.c b/drivers/firmware/google/vpd.c</span>
<span class="p_header">index 35e553b3b190..e4b40f2b4627 100644</span>
<span class="p_header">--- a/drivers/firmware/google/vpd.c</span>
<span class="p_header">+++ b/drivers/firmware/google/vpd.c</span>
<span class="p_chunk">@@ -295,38 +295,60 @@</span> <span class="p_context"> static int vpd_probe(struct platform_device *pdev)</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	return vpd_sections_init(entry.cbmem_addr);</span>
<span class="p_add">+	vpd_kobj = kobject_create_and_add(&quot;vpd&quot;, firmware_kobj);</span>
<span class="p_add">+	if (!vpd_kobj)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = vpd_sections_init(entry.cbmem_addr);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		kobject_put(vpd_kobj);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int vpd_remove(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	vpd_section_destroy(&amp;ro_vpd);</span>
<span class="p_add">+	vpd_section_destroy(&amp;rw_vpd);</span>
<span class="p_add">+</span>
<span class="p_add">+	kobject_put(vpd_kobj);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 static struct platform_driver vpd_driver = {
 	.probe = vpd_probe,
<span class="p_add">+	.remove = vpd_remove,</span>
 	.driver = {
 		.name = &quot;vpd&quot;,
 	},
 };
 
<span class="p_add">+static struct platform_device *vpd_pdev;</span>
<span class="p_add">+</span>
 static int __init vpd_platform_init(void)
 {
<span class="p_del">-	struct platform_device *pdev;</span>
<span class="p_del">-</span>
<span class="p_del">-	pdev = platform_device_register_simple(&quot;vpd&quot;, -1, NULL, 0);</span>
<span class="p_del">-	if (IS_ERR(pdev))</span>
<span class="p_del">-		return PTR_ERR(pdev);</span>
<span class="p_add">+	int ret;</span>
 
<span class="p_del">-	vpd_kobj = kobject_create_and_add(&quot;vpd&quot;, firmware_kobj);</span>
<span class="p_del">-	if (!vpd_kobj)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+	ret = platform_driver_register(&amp;vpd_driver);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
<span class="p_del">-	platform_driver_register(&amp;vpd_driver);</span>
<span class="p_add">+	vpd_pdev = platform_device_register_simple(&quot;vpd&quot;, -1, NULL, 0);</span>
<span class="p_add">+	if (IS_ERR(vpd_pdev)) {</span>
<span class="p_add">+		platform_driver_unregister(&amp;vpd_driver);</span>
<span class="p_add">+		return PTR_ERR(vpd_pdev);</span>
<span class="p_add">+	}</span>
 
 	return 0;
 }
 
 static void __exit vpd_platform_exit(void)
 {
<span class="p_del">-	vpd_section_destroy(&amp;ro_vpd);</span>
<span class="p_del">-	vpd_section_destroy(&amp;rw_vpd);</span>
<span class="p_del">-	kobject_put(vpd_kobj);</span>
<span class="p_add">+	platform_device_unregister(vpd_pdev);</span>
<span class="p_add">+	platform_driver_unregister(&amp;vpd_driver);</span>
 }
 
 module_init(vpd_platform_init);
<span class="p_header">diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.c b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.c</span>
<span class="p_header">index 5dd3f1cd074a..a8905049b9da 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.c</span>
<span class="p_chunk">@@ -946,7 +946,9 @@</span> <span class="p_context"> static int analogix_dp_get_modes(struct drm_connector *connector)</span>
 			return 0;
 		}
 
<span class="p_add">+		pm_runtime_get_sync(dp-&gt;dev);</span>
 		edid = drm_get_edid(connector, &amp;dp-&gt;aux.ddc);
<span class="p_add">+		pm_runtime_put(dp-&gt;dev);</span>
 		if (edid) {
 			drm_mode_connector_update_edid_property(&amp;dp-&gt;connector,
 								edid);
<span class="p_header">diff --git a/drivers/gpu/drm/exynos/exynos_drm_gem.c b/drivers/gpu/drm/exynos/exynos_drm_gem.c</span>
<span class="p_header">index 077de014d610..4400efe3974a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/exynos/exynos_drm_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/exynos/exynos_drm_gem.c</span>
<span class="p_chunk">@@ -247,6 +247,15 @@</span> <span class="p_context"> struct exynos_drm_gem *exynos_drm_gem_create(struct drm_device *dev,</span>
 	if (IS_ERR(exynos_gem))
 		return exynos_gem;
 
<span class="p_add">+	if (!is_drm_iommu_supported(dev) &amp;&amp; (flags &amp; EXYNOS_BO_NONCONTIG)) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * when no IOMMU is available, all allocated buffers are</span>
<span class="p_add">+		 * contiguous anyway, so drop EXYNOS_BO_NONCONTIG flag</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		flags &amp;= ~EXYNOS_BO_NONCONTIG;</span>
<span class="p_add">+		DRM_WARN(&quot;Non-contiguous allocation is not supported without IOMMU, falling back to contiguous buffer\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* set memory type and cache attribute from user side. */
 	exynos_gem-&gt;flags = flags;
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index 5ebdb63330dd..1c73d5542681 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -1000,7 +1000,8 @@</span> <span class="p_context"> enum transcoder intel_pipe_to_cpu_transcoder(struct drm_i915_private *dev_priv,</span>
 	return crtc-&gt;config-&gt;cpu_transcoder;
 }
 
<span class="p_del">-static bool pipe_dsl_stopped(struct drm_i915_private *dev_priv, enum pipe pipe)</span>
<span class="p_add">+static bool pipe_scanline_is_moving(struct drm_i915_private *dev_priv,</span>
<span class="p_add">+				    enum pipe pipe)</span>
 {
 	i915_reg_t reg = PIPEDSL(pipe);
 	u32 line1, line2;
<span class="p_chunk">@@ -1015,7 +1016,28 @@</span> <span class="p_context"> static bool pipe_dsl_stopped(struct drm_i915_private *dev_priv, enum pipe pipe)</span>
 	msleep(5);
 	line2 = I915_READ(reg) &amp; line_mask;
 
<span class="p_del">-	return line1 == line2;</span>
<span class="p_add">+	return line1 != line2;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void wait_for_pipe_scanline_moving(struct intel_crtc *crtc, bool state)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_i915_private *dev_priv = to_i915(crtc-&gt;base.dev);</span>
<span class="p_add">+	enum pipe pipe = crtc-&gt;pipe;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Wait for the display line to settle/start moving */</span>
<span class="p_add">+	if (wait_for(pipe_scanline_is_moving(dev_priv, pipe) == state, 100))</span>
<span class="p_add">+		DRM_ERROR(&quot;pipe %c scanline %s wait timed out\n&quot;,</span>
<span class="p_add">+			  pipe_name(pipe), onoff(state));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void intel_wait_for_pipe_scanline_stopped(struct intel_crtc *crtc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	wait_for_pipe_scanline_moving(crtc, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void intel_wait_for_pipe_scanline_moving(struct intel_crtc *crtc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	wait_for_pipe_scanline_moving(crtc, true);</span>
 }
 
 /*
<span class="p_chunk">@@ -1038,7 +1060,6 @@</span> <span class="p_context"> static void intel_wait_for_pipe_off(struct intel_crtc *crtc)</span>
 {
 	struct drm_i915_private *dev_priv = to_i915(crtc-&gt;base.dev);
 	enum transcoder cpu_transcoder = crtc-&gt;config-&gt;cpu_transcoder;
<span class="p_del">-	enum pipe pipe = crtc-&gt;pipe;</span>
 
 	if (INTEL_GEN(dev_priv) &gt;= 4) {
 		i915_reg_t reg = PIPECONF(cpu_transcoder);
<span class="p_chunk">@@ -1049,9 +1070,7 @@</span> <span class="p_context"> static void intel_wait_for_pipe_off(struct intel_crtc *crtc)</span>
 					    100))
 			WARN(1, &quot;pipe_off wait timed out\n&quot;);
 	} else {
<span class="p_del">-		/* Wait for the display line to settle */</span>
<span class="p_del">-		if (wait_for(pipe_dsl_stopped(dev_priv, pipe), 100))</span>
<span class="p_del">-			WARN(1, &quot;pipe_off wait timed out\n&quot;);</span>
<span class="p_add">+		intel_wait_for_pipe_scanline_stopped(crtc);</span>
 	}
 }
 
<span class="p_chunk">@@ -1944,15 +1963,14 @@</span> <span class="p_context"> static void intel_enable_pipe(struct intel_crtc *crtc)</span>
 	POSTING_READ(reg);
 
 	/*
<span class="p_del">-	 * Until the pipe starts DSL will read as 0, which would cause</span>
<span class="p_del">-	 * an apparent vblank timestamp jump, which messes up also the</span>
<span class="p_del">-	 * frame count when it&#39;s derived from the timestamps. So let&#39;s</span>
<span class="p_del">-	 * wait for the pipe to start properly before we call</span>
<span class="p_del">-	 * drm_crtc_vblank_on()</span>
<span class="p_add">+	 * Until the pipe starts PIPEDSL reads will return a stale value,</span>
<span class="p_add">+	 * which causes an apparent vblank timestamp jump when PIPEDSL</span>
<span class="p_add">+	 * resets to its proper value. That also messes up the frame count</span>
<span class="p_add">+	 * when it&#39;s derived from the timestamps. So let&#39;s wait for the</span>
<span class="p_add">+	 * pipe to start properly before we call drm_crtc_vblank_on()</span>
 	 */
<span class="p_del">-	if (dev-&gt;max_vblank_count == 0 &amp;&amp;</span>
<span class="p_del">-	    wait_for(intel_get_crtc_scanline(crtc) != crtc-&gt;scanline_offset, 50))</span>
<span class="p_del">-		DRM_ERROR(&quot;pipe %c didn&#39;t start\n&quot;, pipe_name(pipe));</span>
<span class="p_add">+	if (dev-&gt;max_vblank_count == 0)</span>
<span class="p_add">+		intel_wait_for_pipe_scanline_moving(crtc);</span>
 }
 
 /**
<span class="p_chunk">@@ -14682,6 +14700,8 @@</span> <span class="p_context"> void i830_enable_pipe(struct drm_i915_private *dev_priv, enum pipe pipe)</span>
 
 void i830_disable_pipe(struct drm_i915_private *dev_priv, enum pipe pipe)
 {
<span class="p_add">+	struct intel_crtc *crtc = intel_get_crtc_for_pipe(dev_priv, pipe);</span>
<span class="p_add">+</span>
 	DRM_DEBUG_KMS(&quot;disabling pipe %c due to force quirk\n&quot;,
 		      pipe_name(pipe));
 
<span class="p_chunk">@@ -14691,8 +14711,7 @@</span> <span class="p_context"> void i830_disable_pipe(struct drm_i915_private *dev_priv, enum pipe pipe)</span>
 	I915_WRITE(PIPECONF(pipe), 0);
 	POSTING_READ(PIPECONF(pipe));
 
<span class="p_del">-	if (wait_for(pipe_dsl_stopped(dev_priv, pipe), 100))</span>
<span class="p_del">-		DRM_ERROR(&quot;pipe %c off wait timed out\n&quot;, pipe_name(pipe));</span>
<span class="p_add">+	intel_wait_for_pipe_scanline_stopped(crtc);</span>
 
 	I915_WRITE(DPLL(pipe), DPLL_VGA_MODE_DIS);
 	POSTING_READ(DPLL(pipe));
<span class="p_header">diff --git a/drivers/hv/channel.c b/drivers/hv/channel.c</span>
<span class="p_header">index 894b67ac2cae..05964347008d 100644</span>
<span class="p_header">--- a/drivers/hv/channel.c</span>
<span class="p_header">+++ b/drivers/hv/channel.c</span>
<span class="p_chunk">@@ -640,22 +640,28 @@</span> <span class="p_context"> void vmbus_close(struct vmbus_channel *channel)</span>
 		 */
 		return;
 	}
<span class="p_del">-	mutex_lock(&amp;vmbus_connection.channel_mutex);</span>
 	/*
 	 * Close all the sub-channels first and then close the
 	 * primary channel.
 	 */
 	list_for_each_safe(cur, tmp, &amp;channel-&gt;sc_list) {
 		cur_channel = list_entry(cur, struct vmbus_channel, sc_list);
<span class="p_del">-		vmbus_close_internal(cur_channel);</span>
 		if (cur_channel-&gt;rescind) {
<span class="p_add">+			wait_for_completion(&amp;cur_channel-&gt;rescind_event);</span>
<span class="p_add">+			mutex_lock(&amp;vmbus_connection.channel_mutex);</span>
<span class="p_add">+			vmbus_close_internal(cur_channel);</span>
 			hv_process_channel_removal(
 					   cur_channel-&gt;offermsg.child_relid);
<span class="p_add">+		} else {</span>
<span class="p_add">+			mutex_lock(&amp;vmbus_connection.channel_mutex);</span>
<span class="p_add">+			vmbus_close_internal(cur_channel);</span>
 		}
<span class="p_add">+		mutex_unlock(&amp;vmbus_connection.channel_mutex);</span>
 	}
 	/*
 	 * Now close the primary.
 	 */
<span class="p_add">+	mutex_lock(&amp;vmbus_connection.channel_mutex);</span>
 	vmbus_close_internal(channel);
 	mutex_unlock(&amp;vmbus_connection.channel_mutex);
 }
<span class="p_header">diff --git a/drivers/hv/channel_mgmt.c b/drivers/hv/channel_mgmt.c</span>
<span class="p_header">index 379b0df123be..65c6d6bdce4c 100644</span>
<span class="p_header">--- a/drivers/hv/channel_mgmt.c</span>
<span class="p_header">+++ b/drivers/hv/channel_mgmt.c</span>
<span class="p_chunk">@@ -333,6 +333,7 @@</span> <span class="p_context"> static struct vmbus_channel *alloc_channel(void)</span>
 		return NULL;
 
 	spin_lock_init(&amp;channel-&gt;lock);
<span class="p_add">+	init_completion(&amp;channel-&gt;rescind_event);</span>
 
 	INIT_LIST_HEAD(&amp;channel-&gt;sc_list);
 	INIT_LIST_HEAD(&amp;channel-&gt;percpu_list);
<span class="p_chunk">@@ -883,6 +884,7 @@</span> <span class="p_context"> static void vmbus_onoffer_rescind(struct vmbus_channel_message_header *hdr)</span>
 	/*
 	 * Now wait for offer handling to complete.
 	 */
<span class="p_add">+	vmbus_rescind_cleanup(channel);</span>
 	while (READ_ONCE(channel-&gt;probe_done) == false) {
 		/*
 		 * We wait here until any channel offer is currently
<span class="p_chunk">@@ -898,7 +900,6 @@</span> <span class="p_context"> static void vmbus_onoffer_rescind(struct vmbus_channel_message_header *hdr)</span>
 	if (channel-&gt;device_obj) {
 		if (channel-&gt;chn_rescind_callback) {
 			channel-&gt;chn_rescind_callback(channel);
<span class="p_del">-			vmbus_rescind_cleanup(channel);</span>
 			return;
 		}
 		/*
<span class="p_chunk">@@ -907,7 +908,6 @@</span> <span class="p_context"> static void vmbus_onoffer_rescind(struct vmbus_channel_message_header *hdr)</span>
 		 */
 		dev = get_device(&amp;channel-&gt;device_obj-&gt;device);
 		if (dev) {
<span class="p_del">-			vmbus_rescind_cleanup(channel);</span>
 			vmbus_device_unregister(channel-&gt;device_obj);
 			put_device(dev);
 		}
<span class="p_chunk">@@ -921,13 +921,14 @@</span> <span class="p_context"> static void vmbus_onoffer_rescind(struct vmbus_channel_message_header *hdr)</span>
 		 * 2. Then close the primary channel.
 		 */
 		mutex_lock(&amp;vmbus_connection.channel_mutex);
<span class="p_del">-		vmbus_rescind_cleanup(channel);</span>
 		if (channel-&gt;state == CHANNEL_OPEN_STATE) {
 			/*
 			 * The channel is currently not open;
 			 * it is safe for us to cleanup the channel.
 			 */
 			hv_process_channel_removal(rescind-&gt;child_relid);
<span class="p_add">+		} else {</span>
<span class="p_add">+			complete(&amp;channel-&gt;rescind_event);</span>
 		}
 		mutex_unlock(&amp;vmbus_connection.channel_mutex);
 	}
<span class="p_header">diff --git a/drivers/iio/adc/cpcap-adc.c b/drivers/iio/adc/cpcap-adc.c</span>
<span class="p_header">index 6e419d5a7c14..f153e02686a0 100644</span>
<span class="p_header">--- a/drivers/iio/adc/cpcap-adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/cpcap-adc.c</span>
<span class="p_chunk">@@ -1012,7 +1012,7 @@</span> <span class="p_context"> static int cpcap_adc_probe(struct platform_device *pdev)</span>
 	platform_set_drvdata(pdev, indio_dev);
 
 	ddata-&gt;irq = platform_get_irq_byname(pdev, &quot;adcdone&quot;);
<span class="p_del">-	if (!ddata-&gt;irq)</span>
<span class="p_add">+	if (ddata-&gt;irq &lt; 0)</span>
 		return -ENODEV;
 
 	error = devm_request_threaded_irq(&amp;pdev-&gt;dev, ddata-&gt;irq, NULL,
<span class="p_header">diff --git a/drivers/iio/adc/meson_saradc.c b/drivers/iio/adc/meson_saradc.c</span>
<span class="p_header">index 2e8dbb89c8c9..7dc7d297a0fc 100644</span>
<span class="p_header">--- a/drivers/iio/adc/meson_saradc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/meson_saradc.c</span>
<span class="p_chunk">@@ -221,8 +221,10 @@</span> <span class="p_context"> enum meson_sar_adc_chan7_mux_sel {</span>
 
 struct meson_sar_adc_data {
 	bool					has_bl30_integration;
<span class="p_add">+	u32					bandgap_reg;</span>
 	unsigned int				resolution;
 	const char				*name;
<span class="p_add">+	const struct regmap_config		*regmap_config;</span>
 };
 
 struct meson_sar_adc_priv {
<span class="p_chunk">@@ -242,13 +244,20 @@</span> <span class="p_context"> struct meson_sar_adc_priv {</span>
 	int					calibscale;
 };
 
<span class="p_del">-static const struct regmap_config meson_sar_adc_regmap_config = {</span>
<span class="p_add">+static const struct regmap_config meson_sar_adc_regmap_config_gxbb = {</span>
 	.reg_bits = 8,
 	.val_bits = 32,
 	.reg_stride = 4,
 	.max_register = MESON_SAR_ADC_REG13,
 };
 
<span class="p_add">+static const struct regmap_config meson_sar_adc_regmap_config_meson8 = {</span>
<span class="p_add">+	.reg_bits = 8,</span>
<span class="p_add">+	.val_bits = 32,</span>
<span class="p_add">+	.reg_stride = 4,</span>
<span class="p_add">+	.max_register = MESON_SAR_ADC_DELTA_10,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static unsigned int meson_sar_adc_get_fifo_count(struct iio_dev *indio_dev)
 {
 	struct meson_sar_adc_priv *priv = iio_priv(indio_dev);
<span class="p_chunk">@@ -600,7 +609,7 @@</span> <span class="p_context"> static int meson_sar_adc_clk_init(struct iio_dev *indio_dev,</span>
 	init.num_parents = 1;
 
 	priv-&gt;clk_gate.reg = base + MESON_SAR_ADC_REG3;
<span class="p_del">-	priv-&gt;clk_gate.bit_idx = fls(MESON_SAR_ADC_REG3_CLK_EN);</span>
<span class="p_add">+	priv-&gt;clk_gate.bit_idx = __ffs(MESON_SAR_ADC_REG3_CLK_EN);</span>
 	priv-&gt;clk_gate.hw.init = &amp;init;
 
 	priv-&gt;adc_clk = devm_clk_register(&amp;indio_dev-&gt;dev, &amp;priv-&gt;clk_gate.hw);
<span class="p_chunk">@@ -685,6 +694,20 @@</span> <span class="p_context"> static int meson_sar_adc_init(struct iio_dev *indio_dev)</span>
 	return 0;
 }
 
<span class="p_add">+static void meson_sar_adc_set_bandgap(struct iio_dev *indio_dev, bool on_off)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct meson_sar_adc_priv *priv = iio_priv(indio_dev);</span>
<span class="p_add">+	u32 enable_mask;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (priv-&gt;data-&gt;bandgap_reg == MESON_SAR_ADC_REG11)</span>
<span class="p_add">+		enable_mask = MESON_SAR_ADC_REG11_BANDGAP_EN;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		enable_mask = MESON_SAR_ADC_DELTA_10_TS_VBG_EN;</span>
<span class="p_add">+</span>
<span class="p_add">+	regmap_update_bits(priv-&gt;regmap, priv-&gt;data-&gt;bandgap_reg, enable_mask,</span>
<span class="p_add">+			   on_off ? enable_mask : 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int meson_sar_adc_hw_enable(struct iio_dev *indio_dev)
 {
 	struct meson_sar_adc_priv *priv = iio_priv(indio_dev);
<span class="p_chunk">@@ -717,9 +740,9 @@</span> <span class="p_context"> static int meson_sar_adc_hw_enable(struct iio_dev *indio_dev)</span>
 	regval = FIELD_PREP(MESON_SAR_ADC_REG0_FIFO_CNT_IRQ_MASK, 1);
 	regmap_update_bits(priv-&gt;regmap, MESON_SAR_ADC_REG0,
 			   MESON_SAR_ADC_REG0_FIFO_CNT_IRQ_MASK, regval);
<span class="p_del">-	regmap_update_bits(priv-&gt;regmap, MESON_SAR_ADC_REG11,</span>
<span class="p_del">-			   MESON_SAR_ADC_REG11_BANDGAP_EN,</span>
<span class="p_del">-			   MESON_SAR_ADC_REG11_BANDGAP_EN);</span>
<span class="p_add">+</span>
<span class="p_add">+	meson_sar_adc_set_bandgap(indio_dev, true);</span>
<span class="p_add">+</span>
 	regmap_update_bits(priv-&gt;regmap, MESON_SAR_ADC_REG3,
 			   MESON_SAR_ADC_REG3_ADC_EN,
 			   MESON_SAR_ADC_REG3_ADC_EN);
<span class="p_chunk">@@ -739,8 +762,7 @@</span> <span class="p_context"> static int meson_sar_adc_hw_enable(struct iio_dev *indio_dev)</span>
 err_adc_clk:
 	regmap_update_bits(priv-&gt;regmap, MESON_SAR_ADC_REG3,
 			   MESON_SAR_ADC_REG3_ADC_EN, 0);
<span class="p_del">-	regmap_update_bits(priv-&gt;regmap, MESON_SAR_ADC_REG11,</span>
<span class="p_del">-			   MESON_SAR_ADC_REG11_BANDGAP_EN, 0);</span>
<span class="p_add">+	meson_sar_adc_set_bandgap(indio_dev, false);</span>
 	clk_disable_unprepare(priv-&gt;sana_clk);
 err_sana_clk:
 	clk_disable_unprepare(priv-&gt;core_clk);
<span class="p_chunk">@@ -765,8 +787,8 @@</span> <span class="p_context"> static int meson_sar_adc_hw_disable(struct iio_dev *indio_dev)</span>
 
 	regmap_update_bits(priv-&gt;regmap, MESON_SAR_ADC_REG3,
 			   MESON_SAR_ADC_REG3_ADC_EN, 0);
<span class="p_del">-	regmap_update_bits(priv-&gt;regmap, MESON_SAR_ADC_REG11,</span>
<span class="p_del">-			   MESON_SAR_ADC_REG11_BANDGAP_EN, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	meson_sar_adc_set_bandgap(indio_dev, false);</span>
 
 	clk_disable_unprepare(priv-&gt;sana_clk);
 	clk_disable_unprepare(priv-&gt;core_clk);
<span class="p_chunk">@@ -845,30 +867,40 @@</span> <span class="p_context"> static const struct iio_info meson_sar_adc_iio_info = {</span>
 
 static const struct meson_sar_adc_data meson_sar_adc_meson8_data = {
 	.has_bl30_integration = false,
<span class="p_add">+	.bandgap_reg = MESON_SAR_ADC_DELTA_10,</span>
<span class="p_add">+	.regmap_config = &amp;meson_sar_adc_regmap_config_meson8,</span>
 	.resolution = 10,
 	.name = &quot;meson-meson8-saradc&quot;,
 };
 
 static const struct meson_sar_adc_data meson_sar_adc_meson8b_data = {
 	.has_bl30_integration = false,
<span class="p_add">+	.bandgap_reg = MESON_SAR_ADC_DELTA_10,</span>
<span class="p_add">+	.regmap_config = &amp;meson_sar_adc_regmap_config_meson8,</span>
 	.resolution = 10,
 	.name = &quot;meson-meson8b-saradc&quot;,
 };
 
 static const struct meson_sar_adc_data meson_sar_adc_gxbb_data = {
 	.has_bl30_integration = true,
<span class="p_add">+	.bandgap_reg = MESON_SAR_ADC_REG11,</span>
<span class="p_add">+	.regmap_config = &amp;meson_sar_adc_regmap_config_gxbb,</span>
 	.resolution = 10,
 	.name = &quot;meson-gxbb-saradc&quot;,
 };
 
 static const struct meson_sar_adc_data meson_sar_adc_gxl_data = {
 	.has_bl30_integration = true,
<span class="p_add">+	.bandgap_reg = MESON_SAR_ADC_REG11,</span>
<span class="p_add">+	.regmap_config = &amp;meson_sar_adc_regmap_config_gxbb,</span>
 	.resolution = 12,
 	.name = &quot;meson-gxl-saradc&quot;,
 };
 
 static const struct meson_sar_adc_data meson_sar_adc_gxm_data = {
 	.has_bl30_integration = true,
<span class="p_add">+	.bandgap_reg = MESON_SAR_ADC_REG11,</span>
<span class="p_add">+	.regmap_config = &amp;meson_sar_adc_regmap_config_gxbb,</span>
 	.resolution = 12,
 	.name = &quot;meson-gxm-saradc&quot;,
 };
<span class="p_chunk">@@ -946,7 +978,7 @@</span> <span class="p_context"> static int meson_sar_adc_probe(struct platform_device *pdev)</span>
 		return ret;
 
 	priv-&gt;regmap = devm_regmap_init_mmio(&amp;pdev-&gt;dev, base,
<span class="p_del">-					     &amp;meson_sar_adc_regmap_config);</span>
<span class="p_add">+					     priv-&gt;data-&gt;regmap_config);</span>
 	if (IS_ERR(priv-&gt;regmap))
 		return PTR_ERR(priv-&gt;regmap);
 
<span class="p_header">diff --git a/drivers/iio/health/max30102.c b/drivers/iio/health/max30102.c</span>
<span class="p_header">index 839b875c29b9..9fb4bc73a6bc 100644</span>
<span class="p_header">--- a/drivers/iio/health/max30102.c</span>
<span class="p_header">+++ b/drivers/iio/health/max30102.c</span>
<span class="p_chunk">@@ -371,7 +371,7 @@</span> <span class="p_context"> static int max30102_read_raw(struct iio_dev *indio_dev,</span>
 		mutex_unlock(&amp;indio_dev-&gt;mlock);
 		break;
 	case IIO_CHAN_INFO_SCALE:
<span class="p_del">-		*val = 1;  /* 0.0625 */</span>
<span class="p_add">+		*val = 1000;  /* 62.5 */</span>
 		*val2 = 16;
 		ret = IIO_VAL_FRACTIONAL;
 		break;
<span class="p_header">diff --git a/drivers/infiniband/core/security.c b/drivers/infiniband/core/security.c</span>
<span class="p_header">index 28607bb42d87..a337386652b0 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/security.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/security.c</span>
<span class="p_chunk">@@ -417,8 +417,17 @@</span> <span class="p_context"> void ib_close_shared_qp_security(struct ib_qp_security *sec)</span>
 
 int ib_create_qp_security(struct ib_qp *qp, struct ib_device *dev)
 {
<span class="p_add">+	u8 i = rdma_start_port(dev);</span>
<span class="p_add">+	bool is_ib = false;</span>
 	int ret;
 
<span class="p_add">+	while (i &lt;= rdma_end_port(dev) &amp;&amp; !is_ib)</span>
<span class="p_add">+		is_ib = rdma_protocol_ib(dev, i++);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If this isn&#39;t an IB device don&#39;t create the security context */</span>
<span class="p_add">+	if (!is_ib)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	qp-&gt;qp_sec = kzalloc(sizeof(*qp-&gt;qp_sec), GFP_KERNEL);
 	if (!qp-&gt;qp_sec)
 		return -ENOMEM;
<span class="p_chunk">@@ -441,6 +450,10 @@</span> <span class="p_context"> EXPORT_SYMBOL(ib_create_qp_security);</span>
 
 void ib_destroy_qp_security_begin(struct ib_qp_security *sec)
 {
<span class="p_add">+	/* Return if not IB */</span>
<span class="p_add">+	if (!sec)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;sec-&gt;mutex);
 
 	/* Remove the QP from the lists so it won&#39;t get added to
<span class="p_chunk">@@ -470,6 +483,10 @@</span> <span class="p_context"> void ib_destroy_qp_security_abort(struct ib_qp_security *sec)</span>
 	int ret;
 	int i;
 
<span class="p_add">+	/* Return if not IB */</span>
<span class="p_add">+	if (!sec)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/* If a concurrent cache update is in progress this
 	 * QP security could be marked for an error state
 	 * transition.  Wait for this to complete.
<span class="p_chunk">@@ -505,6 +522,10 @@</span> <span class="p_context"> void ib_destroy_qp_security_end(struct ib_qp_security *sec)</span>
 {
 	int i;
 
<span class="p_add">+	/* Return if not IB */</span>
<span class="p_add">+	if (!sec)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/* If a concurrent cache update is occurring we must
 	 * wait until this QP security structure is processed
 	 * in the QP to error flow before destroying it because
<span class="p_chunk">@@ -557,7 +578,7 @@</span> <span class="p_context"> int ib_security_modify_qp(struct ib_qp *qp,</span>
 {
 	int ret = 0;
 	struct ib_ports_pkeys *tmp_pps;
<span class="p_del">-	struct ib_ports_pkeys *new_pps;</span>
<span class="p_add">+	struct ib_ports_pkeys *new_pps = NULL;</span>
 	struct ib_qp *real_qp = qp-&gt;real_qp;
 	bool special_qp = (real_qp-&gt;qp_type == IB_QPT_SMI ||
 			   real_qp-&gt;qp_type == IB_QPT_GSI ||
<span class="p_chunk">@@ -565,18 +586,27 @@</span> <span class="p_context"> int ib_security_modify_qp(struct ib_qp *qp,</span>
 	bool pps_change = ((qp_attr_mask &amp; (IB_QP_PKEY_INDEX | IB_QP_PORT)) ||
 			   (qp_attr_mask &amp; IB_QP_ALT_PATH));
 
<span class="p_add">+	WARN_ONCE((qp_attr_mask &amp; IB_QP_PORT &amp;&amp;</span>
<span class="p_add">+		   rdma_protocol_ib(real_qp-&gt;device, qp_attr-&gt;port_num) &amp;&amp;</span>
<span class="p_add">+		   !real_qp-&gt;qp_sec),</span>
<span class="p_add">+		   &quot;%s: QP security is not initialized for IB QP: %d\n&quot;,</span>
<span class="p_add">+		   __func__, real_qp-&gt;qp_num);</span>
<span class="p_add">+</span>
 	/* The port/pkey settings are maintained only for the real QP. Open
 	 * handles on the real QP will be in the shared_qp_list. When
 	 * enforcing security on the real QP all the shared QPs will be
 	 * checked as well.
 	 */
 
<span class="p_del">-	if (pps_change &amp;&amp; !special_qp) {</span>
<span class="p_add">+	if (pps_change &amp;&amp; !special_qp &amp;&amp; real_qp-&gt;qp_sec) {</span>
 		mutex_lock(&amp;real_qp-&gt;qp_sec-&gt;mutex);
 		new_pps = get_new_pps(real_qp,
 				      qp_attr,
 				      qp_attr_mask);
<span class="p_del">-</span>
<span class="p_add">+		if (!new_pps) {</span>
<span class="p_add">+			mutex_unlock(&amp;real_qp-&gt;qp_sec-&gt;mutex);</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+		}</span>
 		/* Add this QP to the lists for the new port
 		 * and pkey settings before checking for permission
 		 * in case there is a concurrent cache update
<span class="p_chunk">@@ -600,7 +630,7 @@</span> <span class="p_context"> int ib_security_modify_qp(struct ib_qp *qp,</span>
 						 qp_attr_mask,
 						 udata);
 
<span class="p_del">-	if (pps_change &amp;&amp; !special_qp) {</span>
<span class="p_add">+	if (new_pps) {</span>
 		/* Clean up the lists and free the appropriate
 		 * ports_pkeys structure.
 		 */
<span class="p_chunk">@@ -631,6 +661,9 @@</span> <span class="p_context"> int ib_security_pkey_access(struct ib_device *dev,</span>
 	u16 pkey;
 	int ret;
 
<span class="p_add">+	if (!rdma_protocol_ib(dev, port_num))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	ret = ib_get_cached_pkey(dev, port_num, pkey_index, &amp;pkey);
 	if (ret)
 		return ret;
<span class="p_chunk">@@ -665,6 +698,9 @@</span> <span class="p_context"> int ib_mad_agent_security_setup(struct ib_mad_agent *agent,</span>
 {
 	int ret;
 
<span class="p_add">+	if (!rdma_protocol_ib(agent-&gt;device, agent-&gt;port_num))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	ret = security_ib_alloc_security(&amp;agent-&gt;security);
 	if (ret)
 		return ret;
<span class="p_chunk">@@ -690,6 +726,9 @@</span> <span class="p_context"> int ib_mad_agent_security_setup(struct ib_mad_agent *agent,</span>
 
 void ib_mad_agent_security_cleanup(struct ib_mad_agent *agent)
 {
<span class="p_add">+	if (!rdma_protocol_ib(agent-&gt;device, agent-&gt;port_num))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	security_ib_free_security(agent-&gt;security);
 	if (agent-&gt;lsm_nb_reg)
 		unregister_lsm_notifier(&amp;agent-&gt;lsm_nb);
<span class="p_chunk">@@ -697,20 +736,16 @@</span> <span class="p_context"> void ib_mad_agent_security_cleanup(struct ib_mad_agent *agent)</span>
 
 int ib_mad_enforce_security(struct ib_mad_agent_private *map, u16 pkey_index)
 {
<span class="p_del">-	int ret;</span>
<span class="p_add">+	if (!rdma_protocol_ib(map-&gt;agent.device, map-&gt;agent.port_num))</span>
<span class="p_add">+		return 0;</span>
 
 	if (map-&gt;agent.qp-&gt;qp_type == IB_QPT_SMI &amp;&amp; !map-&gt;agent.smp_allowed)
 		return -EACCES;
 
<span class="p_del">-	ret = ib_security_pkey_access(map-&gt;agent.device,</span>
<span class="p_del">-				      map-&gt;agent.port_num,</span>
<span class="p_del">-				      pkey_index,</span>
<span class="p_del">-				      map-&gt;agent.security);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return ib_security_pkey_access(map-&gt;agent.device,</span>
<span class="p_add">+				       map-&gt;agent.port_num,</span>
<span class="p_add">+				       pkey_index,</span>
<span class="p_add">+				       map-&gt;agent.security);</span>
 }
 
 #endif /* CONFIG_SECURITY_INFINIBAND */
<span class="p_header">diff --git a/drivers/infiniband/hw/bnxt_re/ib_verbs.c b/drivers/infiniband/hw/bnxt_re/ib_verbs.c</span>
<span class="p_header">index 0d89621d9fe8..b210495ff33c 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/bnxt_re/ib_verbs.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/bnxt_re/ib_verbs.c</span>
<span class="p_chunk">@@ -394,6 +394,7 @@</span> <span class="p_context"> int bnxt_re_add_gid(struct ib_device *ibdev, u8 port_num,</span>
 	ctx-&gt;idx = tbl_idx;
 	ctx-&gt;refcnt = 1;
 	ctx_tbl[tbl_idx] = ctx;
<span class="p_add">+	*context = ctx;</span>
 
 	return rc;
 }
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">index b6b33d99b0b4..17e44c86577a 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_chunk">@@ -2216,7 +2216,7 @@</span> <span class="p_context"> static int __mlx4_ib_modify_qp(void *src, enum mlx4_ib_source_type src_type,</span>
 			context-&gt;mtu_msgmax = (IB_MTU_4096 &lt;&lt; 5) |
 					      ilog2(dev-&gt;dev-&gt;caps.max_gso_sz);
 		else
<span class="p_del">-			context-&gt;mtu_msgmax = (IB_MTU_4096 &lt;&lt; 5) | 12;</span>
<span class="p_add">+			context-&gt;mtu_msgmax = (IB_MTU_4096 &lt;&lt; 5) | 13;</span>
 	} else if (attr_mask &amp; IB_QP_PATH_MTU) {
 		if (attr-&gt;path_mtu &lt; IB_MTU_256 || attr-&gt;path_mtu &gt; IB_MTU_4096) {
 			pr_err(&quot;path MTU (%u) is invalid\n&quot;,
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">index 552f7bd4ecc3..5aff1e33d984 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_chunk">@@ -3097,6 +3097,8 @@</span> <span class="p_context"> static int create_umr_res(struct mlx5_ib_dev *dev)</span>
 	qp-&gt;real_qp    = qp;
 	qp-&gt;uobject    = NULL;
 	qp-&gt;qp_type    = MLX5_IB_QPT_REG_UMR;
<span class="p_add">+	qp-&gt;send_cq    = init_attr-&gt;send_cq;</span>
<span class="p_add">+	qp-&gt;recv_cq    = init_attr-&gt;recv_cq;</span>
 
 	attr-&gt;qp_state = IB_QPS_INIT;
 	attr-&gt;port_num = 1;
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index 6784a05dd6b2..83f3d4831f94 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -2254,10 +2254,12 @@</span> <span class="p_context"> static int __domain_mapping(struct dmar_domain *domain, unsigned long iov_pfn,</span>
 		uint64_t tmp;
 
 		if (!sg_res) {
<span class="p_add">+			unsigned int pgoff = sg-&gt;offset &amp; ~PAGE_MASK;</span>
<span class="p_add">+</span>
 			sg_res = aligned_nrpages(sg-&gt;offset, sg-&gt;length);
<span class="p_del">-			sg-&gt;dma_address = ((dma_addr_t)iov_pfn &lt;&lt; VTD_PAGE_SHIFT) + sg-&gt;offset;</span>
<span class="p_add">+			sg-&gt;dma_address = ((dma_addr_t)iov_pfn &lt;&lt; VTD_PAGE_SHIFT) + pgoff;</span>
 			sg-&gt;dma_length = sg-&gt;length;
<span class="p_del">-			pteval = page_to_phys(sg_page(sg)) | prot;</span>
<span class="p_add">+			pteval = (sg_phys(sg) - pgoff) | prot;</span>
 			phys_pfn = pteval &gt;&gt; VTD_PAGE_SHIFT;
 		}
 
<span class="p_chunk">@@ -3790,7 +3792,7 @@</span> <span class="p_context"> static int intel_nontranslate_map_sg(struct device *hddev,</span>
 
 	for_each_sg(sglist, sg, nelems, i) {
 		BUG_ON(!sg_page(sg));
<span class="p_del">-		sg-&gt;dma_address = page_to_phys(sg_page(sg)) + sg-&gt;offset;</span>
<span class="p_add">+		sg-&gt;dma_address = sg_phys(sg);</span>
 		sg-&gt;dma_length = sg-&gt;length;
 	}
 	return nelems;
<span class="p_header">diff --git a/drivers/irqchip/qcom-irq-combiner.c b/drivers/irqchip/qcom-irq-combiner.c</span>
<span class="p_header">index 6aa3ea479214..f31265937439 100644</span>
<span class="p_header">--- a/drivers/irqchip/qcom-irq-combiner.c</span>
<span class="p_header">+++ b/drivers/irqchip/qcom-irq-combiner.c</span>
<span class="p_chunk">@@ -238,7 +238,7 @@</span> <span class="p_context"> static int __init combiner_probe(struct platform_device *pdev)</span>
 {
 	struct combiner *combiner;
 	size_t alloc_sz;
<span class="p_del">-	u32 nregs;</span>
<span class="p_add">+	int nregs;</span>
 	int err;
 
 	nregs = count_registers(pdev);
<span class="p_header">diff --git a/drivers/mailbox/mailbox-test.c b/drivers/mailbox/mailbox-test.c</span>
<span class="p_header">index 97fb956bb6e0..93f3d4d61fa7 100644</span>
<span class="p_header">--- a/drivers/mailbox/mailbox-test.c</span>
<span class="p_header">+++ b/drivers/mailbox/mailbox-test.c</span>
<span class="p_chunk">@@ -30,6 +30,7 @@</span> <span class="p_context"></span>
 #define MBOX_HEXDUMP_MAX_LEN	(MBOX_HEXDUMP_LINE_LEN *		\
 				 (MBOX_MAX_MSG_LEN / MBOX_BYTES_PER_LINE))
 
<span class="p_add">+static bool mbox_data_ready;</span>
 static struct dentry *root_debugfs_dir;
 
 struct mbox_test_device {
<span class="p_chunk">@@ -152,16 +153,14 @@</span> <span class="p_context"> static ssize_t mbox_test_message_write(struct file *filp,</span>
 
 static bool mbox_test_message_data_ready(struct mbox_test_device *tdev)
 {
<span class="p_del">-	unsigned char data;</span>
<span class="p_add">+	bool data_ready;</span>
 	unsigned long flags;
 
 	spin_lock_irqsave(&amp;tdev-&gt;lock, flags);
<span class="p_del">-	data = tdev-&gt;rx_buffer[0];</span>
<span class="p_add">+	data_ready = mbox_data_ready;</span>
 	spin_unlock_irqrestore(&amp;tdev-&gt;lock, flags);
 
<span class="p_del">-	if (data != &#39;\0&#39;)</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	return false;</span>
<span class="p_add">+	return data_ready;</span>
 }
 
 static ssize_t mbox_test_message_read(struct file *filp, char __user *userbuf,
<span class="p_chunk">@@ -223,6 +222,7 @@</span> <span class="p_context"> static ssize_t mbox_test_message_read(struct file *filp, char __user *userbuf,</span>
 	*(touser + l) = &#39;\0&#39;;
 
 	memset(tdev-&gt;rx_buffer, 0, MBOX_MAX_MSG_LEN);
<span class="p_add">+	mbox_data_ready = false;</span>
 
 	spin_unlock_irqrestore(&amp;tdev-&gt;lock, flags);
 
<span class="p_chunk">@@ -292,6 +292,7 @@</span> <span class="p_context"> static void mbox_test_receive_message(struct mbox_client *client, void *message)</span>
 				     message, MBOX_MAX_MSG_LEN);
 		memcpy(tdev-&gt;rx_buffer, message, MBOX_MAX_MSG_LEN);
 	}
<span class="p_add">+	mbox_data_ready = true;</span>
 	spin_unlock_irqrestore(&amp;tdev-&gt;lock, flags);
 
 	wake_up_interruptible(&amp;tdev-&gt;waitq);
<span class="p_header">diff --git a/drivers/md/raid5-cache.c b/drivers/md/raid5-cache.c</span>
<span class="p_header">index 0b7406ac8ce1..9a340728b846 100644</span>
<span class="p_header">--- a/drivers/md/raid5-cache.c</span>
<span class="p_header">+++ b/drivers/md/raid5-cache.c</span>
<span class="p_chunk">@@ -2571,31 +2571,22 @@</span> <span class="p_context"> static ssize_t r5c_journal_mode_show(struct mddev *mddev, char *page)</span>
 int r5c_journal_mode_set(struct mddev *mddev, int mode)
 {
 	struct r5conf *conf;
<span class="p_del">-	int err;</span>
 
 	if (mode &lt; R5C_JOURNAL_MODE_WRITE_THROUGH ||
 	    mode &gt; R5C_JOURNAL_MODE_WRITE_BACK)
 		return -EINVAL;
 
<span class="p_del">-	err = mddev_lock(mddev);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		return err;</span>
 	conf = mddev-&gt;private;
<span class="p_del">-	if (!conf || !conf-&gt;log) {</span>
<span class="p_del">-		mddev_unlock(mddev);</span>
<span class="p_add">+	if (!conf || !conf-&gt;log)</span>
 		return -ENODEV;
<span class="p_del">-	}</span>
 
 	if (raid5_calc_degraded(conf) &gt; 0 &amp;&amp;
<span class="p_del">-	    mode == R5C_JOURNAL_MODE_WRITE_BACK) {</span>
<span class="p_del">-		mddev_unlock(mddev);</span>
<span class="p_add">+	    mode == R5C_JOURNAL_MODE_WRITE_BACK)</span>
 		return -EINVAL;
<span class="p_del">-	}</span>
 
 	mddev_suspend(mddev);
 	conf-&gt;log-&gt;r5c_journal_mode = mode;
 	mddev_resume(mddev);
<span class="p_del">-	mddev_unlock(mddev);</span>
 
 	pr_debug(&quot;md/raid:%s: setting r5c cache mode to %d: %s\n&quot;,
 		 mdname(mddev), mode, r5c_journal_mode_str[mode]);
<span class="p_chunk">@@ -2608,6 +2599,7 @@</span> <span class="p_context"> static ssize_t r5c_journal_mode_store(struct mddev *mddev,</span>
 {
 	int mode = ARRAY_SIZE(r5c_journal_mode_str);
 	size_t len = length;
<span class="p_add">+	int ret;</span>
 
 	if (len &lt; 2)
 		return -EINVAL;
<span class="p_chunk">@@ -2619,8 +2611,12 @@</span> <span class="p_context"> static ssize_t r5c_journal_mode_store(struct mddev *mddev,</span>
 		if (strlen(r5c_journal_mode_str[mode]) == len &amp;&amp;
 		    !strncmp(page, r5c_journal_mode_str[mode], len))
 			break;
<span class="p_del">-</span>
<span class="p_del">-	return r5c_journal_mode_set(mddev, mode) ?: length;</span>
<span class="p_add">+	ret = mddev_lock(mddev);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	ret = r5c_journal_mode_set(mddev, mode);</span>
<span class="p_add">+	mddev_unlock(mddev);</span>
<span class="p_add">+	return ret ?: length;</span>
 }
 
 struct md_sysfs_entry
<span class="p_header">diff --git a/drivers/media/rc/rc-main.c b/drivers/media/rc/rc-main.c</span>
<span class="p_header">index 981cccd6b988..72f381522cb2 100644</span>
<span class="p_header">--- a/drivers/media/rc/rc-main.c</span>
<span class="p_header">+++ b/drivers/media/rc/rc-main.c</span>
<span class="p_chunk">@@ -38,41 +38,41 @@</span> <span class="p_context"> static const struct {</span>
 	[RC_PROTO_UNKNOWN] = { .name = &quot;unknown&quot;, .repeat_period = 250 },
 	[RC_PROTO_OTHER] = { .name = &quot;other&quot;, .repeat_period = 250 },
 	[RC_PROTO_RC5] = { .name = &quot;rc-5&quot;,
<span class="p_del">-		.scancode_bits = 0x1f7f, .repeat_period = 164 },</span>
<span class="p_add">+		.scancode_bits = 0x1f7f, .repeat_period = 250 },</span>
 	[RC_PROTO_RC5X_20] = { .name = &quot;rc-5x-20&quot;,
<span class="p_del">-		.scancode_bits = 0x1f7f3f, .repeat_period = 164 },</span>
<span class="p_add">+		.scancode_bits = 0x1f7f3f, .repeat_period = 250 },</span>
 	[RC_PROTO_RC5_SZ] = { .name = &quot;rc-5-sz&quot;,
<span class="p_del">-		.scancode_bits = 0x2fff, .repeat_period = 164 },</span>
<span class="p_add">+		.scancode_bits = 0x2fff, .repeat_period = 250 },</span>
 	[RC_PROTO_JVC] = { .name = &quot;jvc&quot;,
 		.scancode_bits = 0xffff, .repeat_period = 250 },
 	[RC_PROTO_SONY12] = { .name = &quot;sony-12&quot;,
<span class="p_del">-		.scancode_bits = 0x1f007f, .repeat_period = 100 },</span>
<span class="p_add">+		.scancode_bits = 0x1f007f, .repeat_period = 250 },</span>
 	[RC_PROTO_SONY15] = { .name = &quot;sony-15&quot;,
<span class="p_del">-		.scancode_bits = 0xff007f, .repeat_period = 100 },</span>
<span class="p_add">+		.scancode_bits = 0xff007f, .repeat_period = 250 },</span>
 	[RC_PROTO_SONY20] = { .name = &quot;sony-20&quot;,
<span class="p_del">-		.scancode_bits = 0x1fff7f, .repeat_period = 100 },</span>
<span class="p_add">+		.scancode_bits = 0x1fff7f, .repeat_period = 250 },</span>
 	[RC_PROTO_NEC] = { .name = &quot;nec&quot;,
<span class="p_del">-		.scancode_bits = 0xffff, .repeat_period = 160 },</span>
<span class="p_add">+		.scancode_bits = 0xffff, .repeat_period = 250 },</span>
 	[RC_PROTO_NECX] = { .name = &quot;nec-x&quot;,
<span class="p_del">-		.scancode_bits = 0xffffff, .repeat_period = 160 },</span>
<span class="p_add">+		.scancode_bits = 0xffffff, .repeat_period = 250 },</span>
 	[RC_PROTO_NEC32] = { .name = &quot;nec-32&quot;,
<span class="p_del">-		.scancode_bits = 0xffffffff, .repeat_period = 160 },</span>
<span class="p_add">+		.scancode_bits = 0xffffffff, .repeat_period = 250 },</span>
 	[RC_PROTO_SANYO] = { .name = &quot;sanyo&quot;,
 		.scancode_bits = 0x1fffff, .repeat_period = 250 },
 	[RC_PROTO_MCIR2_KBD] = { .name = &quot;mcir2-kbd&quot;,
<span class="p_del">-		.scancode_bits = 0xffff, .repeat_period = 150 },</span>
<span class="p_add">+		.scancode_bits = 0xffff, .repeat_period = 250 },</span>
 	[RC_PROTO_MCIR2_MSE] = { .name = &quot;mcir2-mse&quot;,
<span class="p_del">-		.scancode_bits = 0x1fffff, .repeat_period = 150 },</span>
<span class="p_add">+		.scancode_bits = 0x1fffff, .repeat_period = 250 },</span>
 	[RC_PROTO_RC6_0] = { .name = &quot;rc-6-0&quot;,
<span class="p_del">-		.scancode_bits = 0xffff, .repeat_period = 164 },</span>
<span class="p_add">+		.scancode_bits = 0xffff, .repeat_period = 250 },</span>
 	[RC_PROTO_RC6_6A_20] = { .name = &quot;rc-6-6a-20&quot;,
<span class="p_del">-		.scancode_bits = 0xfffff, .repeat_period = 164 },</span>
<span class="p_add">+		.scancode_bits = 0xfffff, .repeat_period = 250 },</span>
 	[RC_PROTO_RC6_6A_24] = { .name = &quot;rc-6-6a-24&quot;,
<span class="p_del">-		.scancode_bits = 0xffffff, .repeat_period = 164 },</span>
<span class="p_add">+		.scancode_bits = 0xffffff, .repeat_period = 250 },</span>
 	[RC_PROTO_RC6_6A_32] = { .name = &quot;rc-6-6a-32&quot;,
<span class="p_del">-		.scancode_bits = 0xffffffff, .repeat_period = 164 },</span>
<span class="p_add">+		.scancode_bits = 0xffffffff, .repeat_period = 250 },</span>
 	[RC_PROTO_RC6_MCE] = { .name = &quot;rc-6-mce&quot;,
<span class="p_del">-		.scancode_bits = 0xffff7fff, .repeat_period = 164 },</span>
<span class="p_add">+		.scancode_bits = 0xffff7fff, .repeat_period = 250 },</span>
 	[RC_PROTO_SHARP] = { .name = &quot;sharp&quot;,
 		.scancode_bits = 0x1fff, .repeat_period = 250 },
 	[RC_PROTO_XMP] = { .name = &quot;xmp&quot;, .repeat_period = 250 },
<span class="p_header">diff --git a/drivers/media/rc/sir_ir.c b/drivers/media/rc/sir_ir.c</span>
<span class="p_header">index bc906fb128d5..d59918878eb2 100644</span>
<span class="p_header">--- a/drivers/media/rc/sir_ir.c</span>
<span class="p_header">+++ b/drivers/media/rc/sir_ir.c</span>
<span class="p_chunk">@@ -57,7 +57,7 @@</span> <span class="p_context"> static void add_read_queue(int flag, unsigned long val);</span>
 static irqreturn_t sir_interrupt(int irq, void *dev_id);
 static void send_space(unsigned long len);
 static void send_pulse(unsigned long len);
<span class="p_del">-static void init_hardware(void);</span>
<span class="p_add">+static int init_hardware(void);</span>
 static void drop_hardware(void);
 /* Initialisation */
 
<span class="p_chunk">@@ -263,11 +263,36 @@</span> <span class="p_context"> static void send_pulse(unsigned long len)</span>
 	}
 }
 
<span class="p_del">-static void init_hardware(void)</span>
<span class="p_add">+static int init_hardware(void)</span>
 {
<span class="p_add">+	u8 scratch, scratch2, scratch3;</span>
 	unsigned long flags;
 
 	spin_lock_irqsave(&amp;hardware_lock, flags);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This is a simple port existence test, borrowed from the autoconfig</span>
<span class="p_add">+	 * function in drivers/tty/serial/8250/8250_port.c</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	scratch = sinp(UART_IER);</span>
<span class="p_add">+	soutp(UART_IER, 0);</span>
<span class="p_add">+#ifdef __i386__</span>
<span class="p_add">+	outb(0xff, 0x080);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	scratch2 = sinp(UART_IER) &amp; 0x0f;</span>
<span class="p_add">+	soutp(UART_IER, 0x0f);</span>
<span class="p_add">+#ifdef __i386__</span>
<span class="p_add">+	outb(0x00, 0x080);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	scratch3 = sinp(UART_IER) &amp; 0x0f;</span>
<span class="p_add">+	soutp(UART_IER, scratch);</span>
<span class="p_add">+	if (scratch2 != 0 || scratch3 != 0x0f) {</span>
<span class="p_add">+		/* we fail, there&#39;s nothing here */</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;hardware_lock, flags);</span>
<span class="p_add">+		pr_err(&quot;port existence test failed, cannot continue\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* reset UART */
 	outb(0, io + UART_MCR);
 	outb(0, io + UART_IER);
<span class="p_chunk">@@ -285,6 +310,8 @@</span> <span class="p_context"> static void init_hardware(void)</span>
 	/* turn on UART */
 	outb(UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2, io + UART_MCR);
 	spin_unlock_irqrestore(&amp;hardware_lock, flags);
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 static void drop_hardware(void)
<span class="p_chunk">@@ -334,14 +361,19 @@</span> <span class="p_context"> static int sir_ir_probe(struct platform_device *dev)</span>
 		pr_err(&quot;IRQ %d already in use.\n&quot;, irq);
 		return retval;
 	}
<span class="p_add">+</span>
<span class="p_add">+	retval = init_hardware();</span>
<span class="p_add">+	if (retval) {</span>
<span class="p_add">+		del_timer_sync(&amp;timerlist);</span>
<span class="p_add">+		return retval;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	pr_info(&quot;I/O port 0x%.4x, IRQ %d.\n&quot;, io, irq);
 
 	retval = devm_rc_register_device(&amp;sir_ir_dev-&gt;dev, rcdev);
 	if (retval &lt; 0)
 		return retval;
 
<span class="p_del">-	init_hardware();</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb/dibusb-common.c b/drivers/media/usb/dvb-usb/dibusb-common.c</span>
<span class="p_header">index 8207e6900656..bcacb0f22028 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb/dibusb-common.c</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb/dibusb-common.c</span>
<span class="p_chunk">@@ -223,8 +223,20 @@</span> <span class="p_context"> EXPORT_SYMBOL(dibusb_i2c_algo);</span>
 
 int dibusb_read_eeprom_byte(struct dvb_usb_device *d, u8 offs, u8 *val)
 {
<span class="p_del">-	u8 wbuf[1] = { offs };</span>
<span class="p_del">-	return dibusb_i2c_msg(d, 0x50, wbuf, 1, val, 1);</span>
<span class="p_add">+	u8 *buf;</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	buf = kmalloc(2, GFP_KERNEL);</span>
<span class="p_add">+	if (!buf)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	buf[0] = offs;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = dibusb_i2c_msg(d, 0x50, &amp;buf[0], 1, &amp;buf[1], 1);</span>
<span class="p_add">+	*val = buf[1];</span>
<span class="p_add">+	kfree(buf);</span>
<span class="p_add">+</span>
<span class="p_add">+	return rc;</span>
 }
 EXPORT_SYMBOL(dibusb_read_eeprom_byte);
 
<span class="p_header">diff --git a/drivers/net/can/flexcan.c b/drivers/net/can/flexcan.c</span>
<span class="p_header">index a13a4896a8bd..c4d1140116ea 100644</span>
<span class="p_header">--- a/drivers/net/can/flexcan.c</span>
<span class="p_header">+++ b/drivers/net/can/flexcan.c</span>
<span class="p_chunk">@@ -189,7 +189,7 @@</span> <span class="p_context"></span>
  *   MX35  FlexCAN2  03.00.00.00     no        no         ?       no        no
  *   MX53  FlexCAN2  03.00.00.00    yes        no        no       no        no
  *   MX6s  FlexCAN3  10.00.12.00    yes       yes        no       no       yes
<span class="p_del">- *   VF610 FlexCAN3  ?               no       yes         ?      yes       yes?</span>
<span class="p_add">+ *   VF610 FlexCAN3  ?               no       yes        no      yes       yes?</span>
  *
  * Some SOCs do not have the RX_WARN &amp; TX_WARN interrupt line connected.
  */
<span class="p_chunk">@@ -297,7 +297,8 @@</span> <span class="p_context"> static const struct flexcan_devtype_data fsl_imx6q_devtype_data = {</span>
 
 static const struct flexcan_devtype_data fsl_vf610_devtype_data = {
 	.quirks = FLEXCAN_QUIRK_DISABLE_RXFG | FLEXCAN_QUIRK_ENABLE_EACEN_RRS |
<span class="p_del">-		FLEXCAN_QUIRK_DISABLE_MECR | FLEXCAN_QUIRK_USE_OFF_TIMESTAMP,</span>
<span class="p_add">+		FLEXCAN_QUIRK_DISABLE_MECR | FLEXCAN_QUIRK_USE_OFF_TIMESTAMP |</span>
<span class="p_add">+		FLEXCAN_QUIRK_BROKEN_PERR_STATE,</span>
 };
 
 static const struct can_bittiming_const flexcan_bittiming_const = {
<span class="p_header">diff --git a/drivers/net/can/peak_canfd/peak_canfd.c b/drivers/net/can/peak_canfd/peak_canfd.c</span>
<span class="p_header">index 85268be0c913..55513411a82e 100644</span>
<span class="p_header">--- a/drivers/net/can/peak_canfd/peak_canfd.c</span>
<span class="p_header">+++ b/drivers/net/can/peak_canfd/peak_canfd.c</span>
<span class="p_chunk">@@ -258,21 +258,18 @@</span> <span class="p_context"> static int pucan_handle_can_rx(struct peak_canfd_priv *priv,</span>
 	/* if this frame is an echo, */
 	if ((rx_msg_flags &amp; PUCAN_MSG_LOOPED_BACK) &amp;&amp;
 	    !(rx_msg_flags &amp; PUCAN_MSG_SELF_RECEIVE)) {
<span class="p_del">-		int n;</span>
 		unsigned long flags;
 
 		spin_lock_irqsave(&amp;priv-&gt;echo_lock, flags);
<span class="p_del">-		n = can_get_echo_skb(priv-&gt;ndev, msg-&gt;client);</span>
<span class="p_add">+		can_get_echo_skb(priv-&gt;ndev, msg-&gt;client);</span>
 		spin_unlock_irqrestore(&amp;priv-&gt;echo_lock, flags);
 
 		/* count bytes of the echo instead of skb */
 		stats-&gt;tx_bytes += cf_len;
 		stats-&gt;tx_packets++;
 
<span class="p_del">-		if (n) {</span>
<span class="p_del">-			/* restart tx queue only if a slot is free */</span>
<span class="p_del">-			netif_wake_queue(priv-&gt;ndev);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		/* restart tx queue (a slot is free) */</span>
<span class="p_add">+		netif_wake_queue(priv-&gt;ndev);</span>
 
 		return 0;
 	}
<span class="p_header">diff --git a/drivers/net/can/peak_canfd/peak_pciefd_main.c b/drivers/net/can/peak_canfd/peak_pciefd_main.c</span>
<span class="p_header">index b4efd711f824..788c3464a3b0 100644</span>
<span class="p_header">--- a/drivers/net/can/peak_canfd/peak_pciefd_main.c</span>
<span class="p_header">+++ b/drivers/net/can/peak_canfd/peak_pciefd_main.c</span>
<span class="p_chunk">@@ -825,7 +825,10 @@</span> <span class="p_context"> static int peak_pciefd_probe(struct pci_dev *pdev,</span>
 err_disable_pci:
 	pci_disable_device(pdev);
 
<span class="p_del">-	return err;</span>
<span class="p_add">+	/* pci_xxx_config_word() return positive PCIBIOS_xxx error codes while</span>
<span class="p_add">+	 * the probe() function must return a negative errno in case of failure</span>
<span class="p_add">+	 * (err is unchanged if negative) */</span>
<span class="p_add">+	return pcibios_err_to_errno(err);</span>
 }
 
 /* free the board structure object, as well as its resources: */
<span class="p_header">diff --git a/drivers/net/can/sja1000/peak_pci.c b/drivers/net/can/sja1000/peak_pci.c</span>
<span class="p_header">index 131026fbc2d7..5adc95c922ee 100644</span>
<span class="p_header">--- a/drivers/net/can/sja1000/peak_pci.c</span>
<span class="p_header">+++ b/drivers/net/can/sja1000/peak_pci.c</span>
<span class="p_chunk">@@ -717,7 +717,10 @@</span> <span class="p_context"> static int peak_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)</span>
 failure_disable_pci:
 	pci_disable_device(pdev);
 
<span class="p_del">-	return err;</span>
<span class="p_add">+	/* pci_xxx_config_word() return positive PCIBIOS_xxx error codes while</span>
<span class="p_add">+	 * the probe() function must return a negative errno in case of failure</span>
<span class="p_add">+	 * (err is unchanged if negative) */</span>
<span class="p_add">+	return pcibios_err_to_errno(err);</span>
 }
 
 static void peak_pci_remove(struct pci_dev *pdev)
<span class="p_header">diff --git a/drivers/net/can/ti_hecc.c b/drivers/net/can/ti_hecc.c</span>
<span class="p_header">index 4d4941469cfc..db6ea936dc3f 100644</span>
<span class="p_header">--- a/drivers/net/can/ti_hecc.c</span>
<span class="p_header">+++ b/drivers/net/can/ti_hecc.c</span>
<span class="p_chunk">@@ -637,6 +637,9 @@</span> <span class="p_context"> static int ti_hecc_rx_poll(struct napi_struct *napi, int quota)</span>
 		mbx_mask = hecc_read(priv, HECC_CANMIM);
 		mbx_mask |= HECC_TX_MBOX_MASK;
 		hecc_write(priv, HECC_CANMIM, mbx_mask);
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* repoll is done only if whole budget is used */</span>
<span class="p_add">+		num_pkts = quota;</span>
 	}
 
 	return num_pkts;
<span class="p_header">diff --git a/drivers/net/can/usb/ems_usb.c b/drivers/net/can/usb/ems_usb.c</span>
<span class="p_header">index b3d02759c226..b00358297424 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/ems_usb.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/ems_usb.c</span>
<span class="p_chunk">@@ -288,6 +288,8 @@</span> <span class="p_context"> static void ems_usb_read_interrupt_callback(struct urb *urb)</span>
 
 	case -ECONNRESET: /* unlink */
 	case -ENOENT:
<span class="p_add">+	case -EPIPE:</span>
<span class="p_add">+	case -EPROTO:</span>
 	case -ESHUTDOWN:
 		return;
 
<span class="p_header">diff --git a/drivers/net/can/usb/esd_usb2.c b/drivers/net/can/usb/esd_usb2.c</span>
<span class="p_header">index 9fdb0f0bfa06..c6dcf93675c0 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/esd_usb2.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/esd_usb2.c</span>
<span class="p_chunk">@@ -393,6 +393,8 @@</span> <span class="p_context"> static void esd_usb2_read_bulk_callback(struct urb *urb)</span>
 		break;
 
 	case -ENOENT:
<span class="p_add">+	case -EPIPE:</span>
<span class="p_add">+	case -EPROTO:</span>
 	case -ESHUTDOWN:
 		return;
 
<span class="p_header">diff --git a/drivers/net/can/usb/kvaser_usb.c b/drivers/net/can/usb/kvaser_usb.c</span>
<span class="p_header">index 9b18d96ef526..63587b8e6825 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/kvaser_usb.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/kvaser_usb.c</span>
<span class="p_chunk">@@ -609,8 +609,8 @@</span> <span class="p_context"> static int kvaser_usb_wait_msg(const struct kvaser_usb *dev, u8 id,</span>
 			}
 
 			if (pos + tmp-&gt;len &gt; actual_len) {
<span class="p_del">-				dev_err(dev-&gt;udev-&gt;dev.parent,</span>
<span class="p_del">-					&quot;Format error\n&quot;);</span>
<span class="p_add">+				dev_err_ratelimited(dev-&gt;udev-&gt;dev.parent,</span>
<span class="p_add">+						    &quot;Format error\n&quot;);</span>
 				break;
 			}
 
<span class="p_chunk">@@ -813,6 +813,7 @@</span> <span class="p_context"> static int kvaser_usb_simple_msg_async(struct kvaser_usb_net_priv *priv,</span>
 	if (err) {
 		netdev_err(netdev, &quot;Error transmitting URB\n&quot;);
 		usb_unanchor_urb(urb);
<span class="p_add">+		kfree(buf);</span>
 		usb_free_urb(urb);
 		return err;
 	}
<span class="p_chunk">@@ -1325,6 +1326,8 @@</span> <span class="p_context"> static void kvaser_usb_read_bulk_callback(struct urb *urb)</span>
 	case 0:
 		break;
 	case -ENOENT:
<span class="p_add">+	case -EPIPE:</span>
<span class="p_add">+	case -EPROTO:</span>
 	case -ESHUTDOWN:
 		return;
 	default:
<span class="p_chunk">@@ -1333,7 +1336,7 @@</span> <span class="p_context"> static void kvaser_usb_read_bulk_callback(struct urb *urb)</span>
 		goto resubmit_urb;
 	}
 
<span class="p_del">-	while (pos &lt;= urb-&gt;actual_length - MSG_HEADER_LEN) {</span>
<span class="p_add">+	while (pos &lt;= (int)(urb-&gt;actual_length - MSG_HEADER_LEN)) {</span>
 		msg = urb-&gt;transfer_buffer + pos;
 
 		/* The Kvaser firmware can only read and write messages that
<span class="p_chunk">@@ -1352,7 +1355,8 @@</span> <span class="p_context"> static void kvaser_usb_read_bulk_callback(struct urb *urb)</span>
 		}
 
 		if (pos + msg-&gt;len &gt; urb-&gt;actual_length) {
<span class="p_del">-			dev_err(dev-&gt;udev-&gt;dev.parent, &quot;Format error\n&quot;);</span>
<span class="p_add">+			dev_err_ratelimited(dev-&gt;udev-&gt;dev.parent,</span>
<span class="p_add">+					    &quot;Format error\n&quot;);</span>
 			break;
 		}
 
<span class="p_chunk">@@ -1768,6 +1772,7 @@</span> <span class="p_context"> static netdev_tx_t kvaser_usb_start_xmit(struct sk_buff *skb,</span>
 		spin_unlock_irqrestore(&amp;priv-&gt;tx_contexts_lock, flags);
 
 		usb_unanchor_urb(urb);
<span class="p_add">+		kfree(buf);</span>
 
 		stats-&gt;tx_dropped++;
 
<span class="p_header">diff --git a/drivers/net/can/usb/mcba_usb.c b/drivers/net/can/usb/mcba_usb.c</span>
<span class="p_header">index 7f0272558bef..e0c24abce16c 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/mcba_usb.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/mcba_usb.c</span>
<span class="p_chunk">@@ -592,6 +592,8 @@</span> <span class="p_context"> static void mcba_usb_read_bulk_callback(struct urb *urb)</span>
 		break;
 
 	case -ENOENT:
<span class="p_add">+	case -EPIPE:</span>
<span class="p_add">+	case -EPROTO:</span>
 	case -ESHUTDOWN:
 		return;
 
<span class="p_header">diff --git a/drivers/net/can/usb/usb_8dev.c b/drivers/net/can/usb/usb_8dev.c</span>
<span class="p_header">index d000cb62d6ae..27861c417c94 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/usb_8dev.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/usb_8dev.c</span>
<span class="p_chunk">@@ -524,6 +524,8 @@</span> <span class="p_context"> static void usb_8dev_read_bulk_callback(struct urb *urb)</span>
 		break;
 
 	case -ENOENT:
<span class="p_add">+	case -EPIPE:</span>
<span class="p_add">+	case -EPROTO:</span>
 	case -ESHUTDOWN:
 		return;
 
<span class="p_header">diff --git a/drivers/net/ethernet/netronome/nfp/flower/main.h b/drivers/net/ethernet/netronome/nfp/flower/main.h</span>
<span class="p_header">index c20dd00a1cae..899e7d53e669 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/netronome/nfp/flower/main.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/netronome/nfp/flower/main.h</span>
<span class="p_chunk">@@ -52,8 +52,7 @@</span> <span class="p_context"> struct nfp_app;</span>
 #define NFP_FLOWER_MASK_ELEMENT_RS	1
 #define NFP_FLOWER_MASK_HASH_BITS	10
 
<span class="p_del">-#define NFP_FL_META_FLAG_NEW_MASK	128</span>
<span class="p_del">-#define NFP_FL_META_FLAG_LAST_MASK	1</span>
<span class="p_add">+#define NFP_FL_META_FLAG_MANAGE_MASK	BIT(7)</span>
 
 #define NFP_FL_MASK_REUSE_TIME_NS	40000
 #define NFP_FL_MASK_ID_LOCATION		1
<span class="p_header">diff --git a/drivers/net/ethernet/netronome/nfp/flower/metadata.c b/drivers/net/ethernet/netronome/nfp/flower/metadata.c</span>
<span class="p_header">index 3226ddc55f99..d9582ccc0025 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/netronome/nfp/flower/metadata.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/netronome/nfp/flower/metadata.c</span>
<span class="p_chunk">@@ -282,7 +282,7 @@</span> <span class="p_context"> nfp_check_mask_add(struct nfp_app *app, char *mask_data, u32 mask_len,</span>
 		id = nfp_add_mask_table(app, mask_data, mask_len);
 		if (id &lt; 0)
 			return false;
<span class="p_del">-		*meta_flags |= NFP_FL_META_FLAG_NEW_MASK;</span>
<span class="p_add">+		*meta_flags |= NFP_FL_META_FLAG_MANAGE_MASK;</span>
 	}
 	*mask_id = id;
 
<span class="p_chunk">@@ -299,6 +299,9 @@</span> <span class="p_context"> nfp_check_mask_remove(struct nfp_app *app, char *mask_data, u32 mask_len,</span>
 	if (!mask_entry)
 		return false;
 
<span class="p_add">+	if (meta_flags)</span>
<span class="p_add">+		*meta_flags &amp;= ~NFP_FL_META_FLAG_MANAGE_MASK;</span>
<span class="p_add">+</span>
 	*mask_id = mask_entry-&gt;mask_id;
 	mask_entry-&gt;ref_cnt--;
 	if (!mask_entry-&gt;ref_cnt) {
<span class="p_chunk">@@ -306,7 +309,7 @@</span> <span class="p_context"> nfp_check_mask_remove(struct nfp_app *app, char *mask_data, u32 mask_len,</span>
 		nfp_release_mask_id(app, *mask_id);
 		kfree(mask_entry);
 		if (meta_flags)
<span class="p_del">-			*meta_flags |= NFP_FL_META_FLAG_LAST_MASK;</span>
<span class="p_add">+			*meta_flags |= NFP_FL_META_FLAG_MANAGE_MASK;</span>
 	}
 
 	return true;
<span class="p_header">diff --git a/drivers/net/ethernet/netronome/nfp/nfp_net_repr.c b/drivers/net/ethernet/netronome/nfp/nfp_net_repr.c</span>
<span class="p_header">index d540a9dc77b3..1c43aca8162d 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/netronome/nfp/nfp_net_repr.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_repr.c</span>
<span class="p_chunk">@@ -297,6 +297,8 @@</span> <span class="p_context"> int nfp_repr_init(struct nfp_app *app, struct net_device *netdev,</span>
 	netdev-&gt;netdev_ops = &amp;nfp_repr_netdev_ops;
 	netdev-&gt;ethtool_ops = &amp;nfp_port_ethtool_ops;
 
<span class="p_add">+	netdev-&gt;max_mtu = pf_netdev-&gt;max_mtu;</span>
<span class="p_add">+</span>
 	SWITCHDEV_SET_OPS(netdev, &amp;nfp_port_switchdev_ops);
 
 	if (nfp_app_has_tc(app)) {
<span class="p_header">diff --git a/drivers/net/geneve.c b/drivers/net/geneve.c</span>
<span class="p_header">index ed51018a813e..b9d8d71a6ecc 100644</span>
<span class="p_header">--- a/drivers/net/geneve.c</span>
<span class="p_header">+++ b/drivers/net/geneve.c</span>
<span class="p_chunk">@@ -1503,6 +1503,7 @@</span> <span class="p_context"> static int geneve_fill_info(struct sk_buff *skb, const struct net_device *dev)</span>
 {
 	struct geneve_dev *geneve = netdev_priv(dev);
 	struct ip_tunnel_info *info = &amp;geneve-&gt;info;
<span class="p_add">+	bool metadata = geneve-&gt;collect_md;</span>
 	__u8 tmp_vni[3];
 	__u32 vni;
 
<span class="p_chunk">@@ -1511,32 +1512,24 @@</span> <span class="p_context"> static int geneve_fill_info(struct sk_buff *skb, const struct net_device *dev)</span>
 	if (nla_put_u32(skb, IFLA_GENEVE_ID, vni))
 		goto nla_put_failure;
 
<span class="p_del">-	if (rtnl_dereference(geneve-&gt;sock4)) {</span>
<span class="p_add">+	if (!metadata &amp;&amp; ip_tunnel_info_af(info) == AF_INET) {</span>
 		if (nla_put_in_addr(skb, IFLA_GENEVE_REMOTE,
 				    info-&gt;key.u.ipv4.dst))
 			goto nla_put_failure;
<span class="p_del">-</span>
 		if (nla_put_u8(skb, IFLA_GENEVE_UDP_CSUM,
 			       !!(info-&gt;key.tun_flags &amp; TUNNEL_CSUM)))
 			goto nla_put_failure;
 
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 #if IS_ENABLED(CONFIG_IPV6)
<span class="p_del">-	if (rtnl_dereference(geneve-&gt;sock6)) {</span>
<span class="p_add">+	} else if (!metadata) {</span>
 		if (nla_put_in6_addr(skb, IFLA_GENEVE_REMOTE6,
 				     &amp;info-&gt;key.u.ipv6.dst))
 			goto nla_put_failure;
<span class="p_del">-</span>
 		if (nla_put_u8(skb, IFLA_GENEVE_UDP_ZERO_CSUM6_TX,
 			       !(info-&gt;key.tun_flags &amp; TUNNEL_CSUM)))
 			goto nla_put_failure;
<span class="p_del">-</span>
<span class="p_del">-		if (nla_put_u8(skb, IFLA_GENEVE_UDP_ZERO_CSUM6_RX,</span>
<span class="p_del">-			       !geneve-&gt;use_udp6_rx_checksums))</span>
<span class="p_del">-			goto nla_put_failure;</span>
<span class="p_del">-	}</span>
 #endif
<span class="p_add">+	}</span>
 
 	if (nla_put_u8(skb, IFLA_GENEVE_TTL, info-&gt;key.ttl) ||
 	    nla_put_u8(skb, IFLA_GENEVE_TOS, info-&gt;key.tos) ||
<span class="p_chunk">@@ -1546,10 +1539,13 @@</span> <span class="p_context"> static int geneve_fill_info(struct sk_buff *skb, const struct net_device *dev)</span>
 	if (nla_put_be16(skb, IFLA_GENEVE_PORT, info-&gt;key.tp_dst))
 		goto nla_put_failure;
 
<span class="p_del">-	if (geneve-&gt;collect_md) {</span>
<span class="p_del">-		if (nla_put_flag(skb, IFLA_GENEVE_COLLECT_METADATA))</span>
<span class="p_add">+	if (metadata &amp;&amp; nla_put_flag(skb, IFLA_GENEVE_COLLECT_METADATA))</span>
 			goto nla_put_failure;
<span class="p_del">-	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (nla_put_u8(skb, IFLA_GENEVE_UDP_ZERO_CSUM6_RX,</span>
<span class="p_add">+		       !geneve-&gt;use_udp6_rx_checksums))</span>
<span class="p_add">+		goto nla_put_failure;</span>
<span class="p_add">+</span>
 	return 0;
 
 nla_put_failure:
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c</span>
<span class="p_header">index 613caca7dc02..b3fa8ae80465 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c</span>
<span class="p_chunk">@@ -4096,8 +4096,8 @@</span> <span class="p_context"> static void brcmf_sdio_firmware_callback(struct device *dev, int err,</span>
 	sdio_release_host(sdiodev-&gt;func[1]);
 fail:
 	brcmf_dbg(TRACE, &quot;failed: dev=%s, err=%d\n&quot;, dev_name(dev), err);
<span class="p_del">-	device_release_driver(dev);</span>
 	device_release_driver(&amp;sdiodev-&gt;func[2]-&gt;dev);
<span class="p_add">+	device_release_driver(dev);</span>
 }
 
 struct brcmf_sdio *brcmf_sdio_probe(struct brcmf_sdio_dev *sdiodev)
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/fw/api/txq.h b/drivers/net/wireless/intel/iwlwifi/fw/api/txq.h</span>
<span class="p_header">index 87b4434224a1..dfa111bb411e 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/fw/api/txq.h</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/fw/api/txq.h</span>
<span class="p_chunk">@@ -68,6 +68,9 @@</span> <span class="p_context"></span>
  * @IWL_MVM_DQA_CMD_QUEUE: a queue reserved for sending HCMDs to the FW
  * @IWL_MVM_DQA_AUX_QUEUE: a queue reserved for aux frames
  * @IWL_MVM_DQA_P2P_DEVICE_QUEUE: a queue reserved for P2P device frames
<span class="p_add">+ * @IWL_MVM_DQA_INJECT_MONITOR_QUEUE: a queue reserved for injection using</span>
<span class="p_add">+ *	monitor mode. Note this queue is the same as the queue for P2P device</span>
<span class="p_add">+ *	but we can&#39;t have active monitor mode along with P2P device anyway.</span>
  * @IWL_MVM_DQA_GCAST_QUEUE: a queue reserved for P2P GO/SoftAP GCAST frames
  * @IWL_MVM_DQA_BSS_CLIENT_QUEUE: a queue reserved for BSS activity, to ensure
  *	that we are never left without the possibility to connect to an AP.
<span class="p_chunk">@@ -87,6 +90,7 @@</span> <span class="p_context"> enum iwl_mvm_dqa_txq {</span>
 	IWL_MVM_DQA_CMD_QUEUE = 0,
 	IWL_MVM_DQA_AUX_QUEUE = 1,
 	IWL_MVM_DQA_P2P_DEVICE_QUEUE = 2,
<span class="p_add">+	IWL_MVM_DQA_INJECT_MONITOR_QUEUE = 2,</span>
 	IWL_MVM_DQA_GCAST_QUEUE = 3,
 	IWL_MVM_DQA_BSS_CLIENT_QUEUE = 4,
 	IWL_MVM_DQA_MIN_MGMT_QUEUE = 5,
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/iwl-trans.h b/drivers/net/wireless/intel/iwlwifi/iwl-trans.h</span>
<span class="p_header">index e90abbfba718..ecd5c1df811c 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/iwl-trans.h</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/iwl-trans.h</span>
<span class="p_chunk">@@ -117,6 +117,7 @@</span> <span class="p_context"></span>
 #define FH_RSCSR_FRAME_INVALID		0x55550000
 #define FH_RSCSR_FRAME_ALIGN		0x40
 #define FH_RSCSR_RPA_EN			BIT(25)
<span class="p_add">+#define FH_RSCSR_RADA_EN		BIT(26)</span>
 #define FH_RSCSR_RXQ_POS		16
 #define FH_RSCSR_RXQ_MASK		0x3F0000
 
<span class="p_chunk">@@ -128,7 +129,8 @@</span> <span class="p_context"> struct iwl_rx_packet {</span>
 	 * 31:    flag flush RB request
 	 * 30:    flag ignore TC (terminal counter) request
 	 * 29:    flag fast IRQ request
<span class="p_del">-	 * 28-26: Reserved</span>
<span class="p_add">+	 * 28-27: Reserved</span>
<span class="p_add">+	 * 26:    RADA enabled</span>
 	 * 25:    Offload enabled
 	 * 24:    RPF enabled
 	 * 23:    RSS enabled
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/mac-ctxt.c b/drivers/net/wireless/intel/iwlwifi/mvm/mac-ctxt.c</span>
<span class="p_header">index a2bf530eeae4..2f22e14e00fe 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/mac-ctxt.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/mac-ctxt.c</span>
<span class="p_chunk">@@ -787,7 +787,7 @@</span> <span class="p_context"> static int iwl_mvm_mac_ctxt_cmd_listener(struct iwl_mvm *mvm,</span>
 					 u32 action)
 {
 	struct iwl_mac_ctx_cmd cmd = {};
<span class="p_del">-	u32 tfd_queue_msk = 0;</span>
<span class="p_add">+	u32 tfd_queue_msk = BIT(mvm-&gt;snif_queue);</span>
 	int ret;
 
 	WARN_ON(vif-&gt;type != NL80211_IFTYPE_MONITOR);
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/mvm.h b/drivers/net/wireless/intel/iwlwifi/mvm/mvm.h</span>
<span class="p_header">index 8dcdb522b846..2ec27ceb8af9 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/mvm.h</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/mvm.h</span>
<span class="p_chunk">@@ -954,6 +954,7 @@</span> <span class="p_context"> struct iwl_mvm {</span>
 
 	/* Tx queues */
 	u16 aux_queue;
<span class="p_add">+	u16 snif_queue;</span>
 	u16 probe_queue;
 	u16 p2p_dev_queue;
 
<span class="p_chunk">@@ -1042,6 +1043,7 @@</span> <span class="p_context"> struct iwl_mvm {</span>
  * @IWL_MVM_STATUS_ROC_AUX_RUNNING: AUX remain-on-channel is running
  * @IWL_MVM_STATUS_D3_RECONFIG: D3 reconfiguration is being done
  * @IWL_MVM_STATUS_FIRMWARE_RUNNING: firmware is running
<span class="p_add">+ * @IWL_MVM_STATUS_NEED_FLUSH_P2P: need to flush P2P bcast STA</span>
  */
 enum iwl_mvm_status {
 	IWL_MVM_STATUS_HW_RFKILL,
<span class="p_chunk">@@ -1053,6 +1055,7 @@</span> <span class="p_context"> enum iwl_mvm_status {</span>
 	IWL_MVM_STATUS_ROC_AUX_RUNNING,
 	IWL_MVM_STATUS_D3_RECONFIG,
 	IWL_MVM_STATUS_FIRMWARE_RUNNING,
<span class="p_add">+	IWL_MVM_STATUS_NEED_FLUSH_P2P,</span>
 };
 
 /* Keep track of completed init configuration */
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/ops.c b/drivers/net/wireless/intel/iwlwifi/mvm/ops.c</span>
<span class="p_header">index 231878969332..9fb40955d5f4 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/ops.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/ops.c</span>
<span class="p_chunk">@@ -622,6 +622,7 @@</span> <span class="p_context"> iwl_op_mode_mvm_start(struct iwl_trans *trans, const struct iwl_cfg *cfg,</span>
 	mvm-&gt;fw_restart = iwlwifi_mod_params.fw_restart ? -1 : 0;
 
 	mvm-&gt;aux_queue = IWL_MVM_DQA_AUX_QUEUE;
<span class="p_add">+	mvm-&gt;snif_queue = IWL_MVM_DQA_INJECT_MONITOR_QUEUE;</span>
 	mvm-&gt;probe_queue = IWL_MVM_DQA_AP_PROBE_RESP_QUEUE;
 	mvm-&gt;p2p_dev_queue = IWL_MVM_DQA_P2P_DEVICE_QUEUE;
 
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/rxmq.c b/drivers/net/wireless/intel/iwlwifi/mvm/rxmq.c</span>
<span class="p_header">index 248699c2c4bf..819e6f66a5b5 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/rxmq.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/rxmq.c</span>
<span class="p_chunk">@@ -232,8 +232,8 @@</span> <span class="p_context"> static void iwl_mvm_get_signal_strength(struct iwl_mvm *mvm,</span>
 
 static int iwl_mvm_rx_crypto(struct iwl_mvm *mvm, struct ieee80211_hdr *hdr,
 			     struct ieee80211_rx_status *stats,
<span class="p_del">-			     struct iwl_rx_mpdu_desc *desc, int queue,</span>
<span class="p_del">-			     u8 *crypt_len)</span>
<span class="p_add">+			     struct iwl_rx_mpdu_desc *desc, u32 pkt_flags,</span>
<span class="p_add">+			     int queue, u8 *crypt_len)</span>
 {
 	u16 status = le16_to_cpu(desc-&gt;status);
 
<span class="p_chunk">@@ -253,6 +253,8 @@</span> <span class="p_context"> static int iwl_mvm_rx_crypto(struct iwl_mvm *mvm, struct ieee80211_hdr *hdr,</span>
 			return -1;
 
 		stats-&gt;flag |= RX_FLAG_DECRYPTED;
<span class="p_add">+		if (pkt_flags &amp; FH_RSCSR_RADA_EN)</span>
<span class="p_add">+			stats-&gt;flag |= RX_FLAG_MIC_STRIPPED;</span>
 		*crypt_len = IEEE80211_CCMP_HDR_LEN;
 		return 0;
 	case IWL_RX_MPDU_STATUS_SEC_TKIP:
<span class="p_chunk">@@ -270,6 +272,10 @@</span> <span class="p_context"> static int iwl_mvm_rx_crypto(struct iwl_mvm *mvm, struct ieee80211_hdr *hdr,</span>
 		if ((status &amp; IWL_RX_MPDU_STATUS_SEC_MASK) ==
 				IWL_RX_MPDU_STATUS_SEC_WEP)
 			*crypt_len = IEEE80211_WEP_IV_LEN;
<span class="p_add">+</span>
<span class="p_add">+		if (pkt_flags &amp; FH_RSCSR_RADA_EN)</span>
<span class="p_add">+			stats-&gt;flag |= RX_FLAG_ICV_STRIPPED;</span>
<span class="p_add">+</span>
 		return 0;
 	case IWL_RX_MPDU_STATUS_SEC_EXT_ENC:
 		if (!(status &amp; IWL_RX_MPDU_STATUS_MIC_OK))
<span class="p_chunk">@@ -810,7 +816,9 @@</span> <span class="p_context"> void iwl_mvm_rx_mpdu_mq(struct iwl_mvm *mvm, struct napi_struct *napi,</span>
 
 	rx_status = IEEE80211_SKB_RXCB(skb);
 
<span class="p_del">-	if (iwl_mvm_rx_crypto(mvm, hdr, rx_status, desc, queue, &amp;crypt_len)) {</span>
<span class="p_add">+	if (iwl_mvm_rx_crypto(mvm, hdr, rx_status, desc,</span>
<span class="p_add">+			      le32_to_cpu(pkt-&gt;len_n_flags), queue,</span>
<span class="p_add">+			      &amp;crypt_len)) {</span>
 		kfree_skb(skb);
 		return;
 	}
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/sta.c b/drivers/net/wireless/intel/iwlwifi/mvm/sta.c</span>
<span class="p_header">index c4a343534c5e..0d7929799942 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/sta.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/sta.c</span>
<span class="p_chunk">@@ -1700,29 +1700,29 @@</span> <span class="p_context"> void iwl_mvm_dealloc_int_sta(struct iwl_mvm *mvm, struct iwl_mvm_int_sta *sta)</span>
 	sta-&gt;sta_id = IWL_MVM_INVALID_STA;
 }
 
<span class="p_del">-static void iwl_mvm_enable_aux_queue(struct iwl_mvm *mvm)</span>
<span class="p_add">+static void iwl_mvm_enable_aux_snif_queue(struct iwl_mvm *mvm, u16 *queue,</span>
<span class="p_add">+					  u8 sta_id, u8 fifo)</span>
 {
 	unsigned int wdg_timeout = iwlmvm_mod_params.tfd_q_hang_detect ?
 					mvm-&gt;cfg-&gt;base_params-&gt;wd_timeout :
 					IWL_WATCHDOG_DISABLED;
 
 	if (iwl_mvm_has_new_tx_api(mvm)) {
<span class="p_del">-		int queue = iwl_mvm_tvqm_enable_txq(mvm, mvm-&gt;aux_queue,</span>
<span class="p_del">-						    mvm-&gt;aux_sta.sta_id,</span>
<span class="p_del">-						    IWL_MAX_TID_COUNT,</span>
<span class="p_del">-						    wdg_timeout);</span>
<span class="p_del">-		mvm-&gt;aux_queue = queue;</span>
<span class="p_add">+		int tvqm_queue =</span>
<span class="p_add">+			iwl_mvm_tvqm_enable_txq(mvm, *queue, sta_id,</span>
<span class="p_add">+						IWL_MAX_TID_COUNT,</span>
<span class="p_add">+						wdg_timeout);</span>
<span class="p_add">+		*queue = tvqm_queue;</span>
 	} else {
 		struct iwl_trans_txq_scd_cfg cfg = {
<span class="p_del">-			.fifo = IWL_MVM_TX_FIFO_MCAST,</span>
<span class="p_del">-			.sta_id = mvm-&gt;aux_sta.sta_id,</span>
<span class="p_add">+			.fifo = fifo,</span>
<span class="p_add">+			.sta_id = sta_id,</span>
 			.tid = IWL_MAX_TID_COUNT,
 			.aggregate = false,
 			.frame_limit = IWL_FRAME_LIMIT,
 		};
 
<span class="p_del">-		iwl_mvm_enable_txq(mvm, mvm-&gt;aux_queue, mvm-&gt;aux_queue, 0, &amp;cfg,</span>
<span class="p_del">-				   wdg_timeout);</span>
<span class="p_add">+		iwl_mvm_enable_txq(mvm, *queue, *queue, 0, &amp;cfg, wdg_timeout);</span>
 	}
 }
 
<span class="p_chunk">@@ -1741,7 +1741,9 @@</span> <span class="p_context"> int iwl_mvm_add_aux_sta(struct iwl_mvm *mvm)</span>
 
 	/* Map Aux queue to fifo - needs to happen before adding Aux station */
 	if (!iwl_mvm_has_new_tx_api(mvm))
<span class="p_del">-		iwl_mvm_enable_aux_queue(mvm);</span>
<span class="p_add">+		iwl_mvm_enable_aux_snif_queue(mvm, &amp;mvm-&gt;aux_queue,</span>
<span class="p_add">+					      mvm-&gt;aux_sta.sta_id,</span>
<span class="p_add">+					      IWL_MVM_TX_FIFO_MCAST);</span>
 
 	ret = iwl_mvm_add_int_sta_common(mvm, &amp;mvm-&gt;aux_sta, NULL,
 					 MAC_INDEX_AUX, 0);
<span class="p_chunk">@@ -1755,7 +1757,9 @@</span> <span class="p_context"> int iwl_mvm_add_aux_sta(struct iwl_mvm *mvm)</span>
 	 * to firmware so enable queue here - after the station was added
 	 */
 	if (iwl_mvm_has_new_tx_api(mvm))
<span class="p_del">-		iwl_mvm_enable_aux_queue(mvm);</span>
<span class="p_add">+		iwl_mvm_enable_aux_snif_queue(mvm, &amp;mvm-&gt;aux_queue,</span>
<span class="p_add">+					      mvm-&gt;aux_sta.sta_id,</span>
<span class="p_add">+					      IWL_MVM_TX_FIFO_MCAST);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1763,10 +1767,31 @@</span> <span class="p_context"> int iwl_mvm_add_aux_sta(struct iwl_mvm *mvm)</span>
 int iwl_mvm_add_snif_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
 {
 	struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
<span class="p_add">+	int ret;</span>
 
 	lockdep_assert_held(&amp;mvm-&gt;mutex);
<span class="p_del">-	return iwl_mvm_add_int_sta_common(mvm, &amp;mvm-&gt;snif_sta, vif-&gt;addr,</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Map snif queue to fifo - must happen before adding snif station */</span>
<span class="p_add">+	if (!iwl_mvm_has_new_tx_api(mvm))</span>
<span class="p_add">+		iwl_mvm_enable_aux_snif_queue(mvm, &amp;mvm-&gt;snif_queue,</span>
<span class="p_add">+					      mvm-&gt;snif_sta.sta_id,</span>
<span class="p_add">+					      IWL_MVM_TX_FIFO_BE);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = iwl_mvm_add_int_sta_common(mvm, &amp;mvm-&gt;snif_sta, vif-&gt;addr,</span>
 					 mvmvif-&gt;id, 0);
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * For 22000 firmware and on we cannot add queue to a station unknown</span>
<span class="p_add">+	 * to firmware so enable queue here - after the station was added</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (iwl_mvm_has_new_tx_api(mvm))</span>
<span class="p_add">+		iwl_mvm_enable_aux_snif_queue(mvm, &amp;mvm-&gt;snif_queue,</span>
<span class="p_add">+					      mvm-&gt;snif_sta.sta_id,</span>
<span class="p_add">+					      IWL_MVM_TX_FIFO_BE);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 int iwl_mvm_rm_snif_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
<span class="p_chunk">@@ -1775,6 +1800,8 @@</span> <span class="p_context"> int iwl_mvm_rm_snif_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif)</span>
 
 	lockdep_assert_held(&amp;mvm-&gt;mutex);
 
<span class="p_add">+	iwl_mvm_disable_txq(mvm, mvm-&gt;snif_queue, mvm-&gt;snif_queue,</span>
<span class="p_add">+			    IWL_MAX_TID_COUNT, 0);</span>
 	ret = iwl_mvm_rm_sta_common(mvm, mvm-&gt;snif_sta.sta_id);
 	if (ret)
 		IWL_WARN(mvm, &quot;Failed sending remove station\n&quot;);
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/time-event.c b/drivers/net/wireless/intel/iwlwifi/mvm/time-event.c</span>
<span class="p_header">index 4d0314912e94..e25cda9fbf6c 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/time-event.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/time-event.c</span>
<span class="p_chunk">@@ -132,6 +132,24 @@</span> <span class="p_context"> void iwl_mvm_roc_done_wk(struct work_struct *wk)</span>
 	 * executed, and a new time event means a new command.
 	 */
 	iwl_mvm_flush_sta(mvm, &amp;mvm-&gt;aux_sta, true, CMD_ASYNC);
<span class="p_add">+</span>
<span class="p_add">+	/* Do the same for the P2P device queue (STA) */</span>
<span class="p_add">+	if (test_and_clear_bit(IWL_MVM_STATUS_NEED_FLUSH_P2P, &amp;mvm-&gt;status)) {</span>
<span class="p_add">+		struct iwl_mvm_vif *mvmvif;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * NB: access to this pointer would be racy, but the flush bit</span>
<span class="p_add">+		 * can only be set when we had a P2P-Device VIF, and we have a</span>
<span class="p_add">+		 * flush of this work in iwl_mvm_prepare_mac_removal() so it&#39;s</span>
<span class="p_add">+		 * not really racy.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!WARN_ON(!mvm-&gt;p2p_device_vif)) {</span>
<span class="p_add">+			mvmvif = iwl_mvm_vif_from_mac80211(mvm-&gt;p2p_device_vif);</span>
<span class="p_add">+			iwl_mvm_flush_sta(mvm, &amp;mvmvif-&gt;bcast_sta, true,</span>
<span class="p_add">+					  CMD_ASYNC);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 }
 
 static void iwl_mvm_roc_finished(struct iwl_mvm *mvm)
<span class="p_chunk">@@ -855,10 +873,12 @@</span> <span class="p_context"> void iwl_mvm_stop_roc(struct iwl_mvm *mvm)</span>
 
 	mvmvif = iwl_mvm_vif_from_mac80211(te_data-&gt;vif);
 
<span class="p_del">-	if (te_data-&gt;vif-&gt;type == NL80211_IFTYPE_P2P_DEVICE)</span>
<span class="p_add">+	if (te_data-&gt;vif-&gt;type == NL80211_IFTYPE_P2P_DEVICE) {</span>
 		iwl_mvm_remove_time_event(mvm, mvmvif, te_data);
<span class="p_del">-	else</span>
<span class="p_add">+		set_bit(IWL_MVM_STATUS_NEED_FLUSH_P2P, &amp;mvm-&gt;status);</span>
<span class="p_add">+	} else {</span>
 		iwl_mvm_remove_aux_roc_te(mvm, mvmvif, te_data);
<span class="p_add">+	}</span>
 
 	iwl_mvm_roc_finished(mvm);
 }
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/tx.c b/drivers/net/wireless/intel/iwlwifi/mvm/tx.c</span>
<span class="p_header">index 6f2e2af23219..887a504ce64a 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/tx.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/tx.c</span>
<span class="p_chunk">@@ -657,7 +657,8 @@</span> <span class="p_context"> int iwl_mvm_tx_skb_non_sta(struct iwl_mvm *mvm, struct sk_buff *skb)</span>
 			if (ap_sta_id != IWL_MVM_INVALID_STA)
 				sta_id = ap_sta_id;
 		} else if (info.control.vif-&gt;type == NL80211_IFTYPE_MONITOR) {
<span class="p_del">-			queue = mvm-&gt;aux_queue;</span>
<span class="p_add">+			queue = mvm-&gt;snif_queue;</span>
<span class="p_add">+			sta_id = mvm-&gt;snif_sta.sta_id;</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/utils.c b/drivers/net/wireless/intel/iwlwifi/mvm/utils.c</span>
<span class="p_header">index 2ea74abad73d..53e269d54050 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/utils.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/utils.c</span>
<span class="p_chunk">@@ -1143,9 +1143,18 @@</span> <span class="p_context"> unsigned int iwl_mvm_get_wd_timeout(struct iwl_mvm *mvm,</span>
 	unsigned int default_timeout =
 		cmd_q ? IWL_DEF_WD_TIMEOUT : mvm-&gt;cfg-&gt;base_params-&gt;wd_timeout;
 
<span class="p_del">-	if (!iwl_fw_dbg_trigger_enabled(mvm-&gt;fw, FW_DBG_TRIGGER_TXQ_TIMERS))</span>
<span class="p_add">+	if (!iwl_fw_dbg_trigger_enabled(mvm-&gt;fw, FW_DBG_TRIGGER_TXQ_TIMERS)) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We can&#39;t know when the station is asleep or awake, so we</span>
<span class="p_add">+		 * must disable the queue hang detection.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (fw_has_capa(&amp;mvm-&gt;fw-&gt;ucode_capa,</span>
<span class="p_add">+				IWL_UCODE_TLV_CAPA_STA_PM_NOTIF) &amp;&amp;</span>
<span class="p_add">+		    vif &amp;&amp; vif-&gt;type == NL80211_IFTYPE_AP)</span>
<span class="p_add">+			return IWL_WATCHDOG_DISABLED;</span>
 		return iwlmvm_mod_params.tfd_q_hang_detect ?
 			default_timeout : IWL_WATCHDOG_DISABLED;
<span class="p_add">+	}</span>
 
 	trigger = iwl_fw_dbg_get_trigger(mvm-&gt;fw, FW_DBG_TRIGGER_TXQ_TIMERS);
 	txq_timer = (void *)trigger-&gt;data;
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/pcie/drv.c b/drivers/net/wireless/intel/iwlwifi/pcie/drv.c</span>
<span class="p_header">index 548e1928430d..0f7bd37bf172 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/pcie/drv.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/pcie/drv.c</span>
<span class="p_chunk">@@ -551,6 +551,7 @@</span> <span class="p_context"> static const struct pci_device_id iwl_hw_card_ids[] = {</span>
 	{IWL_PCI_DEVICE(0x271B, 0x0014, iwl9160_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x271B, 0x0210, iwl9160_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x271B, 0x0214, iwl9260_2ac_cfg)},
<span class="p_add">+	{IWL_PCI_DEVICE(0x271C, 0x0214, iwl9260_2ac_cfg)},</span>
 	{IWL_PCI_DEVICE(0x2720, 0x0034, iwl9560_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x2720, 0x0038, iwl9560_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x2720, 0x003C, iwl9560_2ac_cfg)},
<span class="p_chunk">@@ -662,6 +663,7 @@</span> <span class="p_context"> static const struct pci_device_id iwl_hw_card_ids[] = {</span>
 	{IWL_PCI_DEVICE(0x2720, 0x0310, iwla000_2ac_cfg_hr_cdb)},
 	{IWL_PCI_DEVICE(0x40C0, 0x0000, iwla000_2ax_cfg_hr)},
 	{IWL_PCI_DEVICE(0x40C0, 0x0A10, iwla000_2ax_cfg_hr)},
<span class="p_add">+	{IWL_PCI_DEVICE(0xA0F0, 0x0000, iwla000_2ax_cfg_hr)},</span>
 
 #endif /* CONFIG_IWLMVM */
 
<span class="p_header">diff --git a/drivers/net/wireless/mac80211_hwsim.c b/drivers/net/wireless/mac80211_hwsim.c</span>
<span class="p_header">index 6467ffac9811..a59b54328c07 100644</span>
<span class="p_header">--- a/drivers/net/wireless/mac80211_hwsim.c</span>
<span class="p_header">+++ b/drivers/net/wireless/mac80211_hwsim.c</span>
<span class="p_chunk">@@ -3108,6 +3108,7 @@</span> <span class="p_context"> static int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)</span>
 {
 	struct hwsim_new_radio_params param = { 0 };
 	const char *hwname = NULL;
<span class="p_add">+	int ret;</span>
 
 	param.reg_strict = info-&gt;attrs[HWSIM_ATTR_REG_STRICT_REG];
 	param.p2p_device = info-&gt;attrs[HWSIM_ATTR_SUPPORT_P2P_DEVICE];
<span class="p_chunk">@@ -3147,7 +3148,9 @@</span> <span class="p_context"> static int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)</span>
 		param.regd = hwsim_world_regdom_custom[idx];
 	}
 
<span class="p_del">-	return mac80211_hwsim_new_radio(info, &amp;param);</span>
<span class="p_add">+	ret = mac80211_hwsim_new_radio(info, &amp;param);</span>
<span class="p_add">+	kfree(hwname);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int hwsim_del_radio_nl(struct sk_buff *msg, struct genl_info *info)
<span class="p_header">diff --git a/drivers/net/wireless/rsi/rsi_91x_usb.c b/drivers/net/wireless/rsi/rsi_91x_usb.c</span>
<span class="p_header">index 81df09dd2636..f90c10b3c921 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rsi/rsi_91x_usb.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rsi/rsi_91x_usb.c</span>
<span class="p_chunk">@@ -162,13 +162,13 @@</span> <span class="p_context"> static int rsi_usb_reg_read(struct usb_device *usbdev,</span>
 	u8 *buf;
 	int status = -ENOMEM;
 
<span class="p_add">+	if (len &gt; RSI_USB_CTRL_BUF_SIZE)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	buf  = kmalloc(RSI_USB_CTRL_BUF_SIZE, GFP_KERNEL);
 	if (!buf)
 		return status;
 
<span class="p_del">-	if (len &gt; RSI_USB_CTRL_BUF_SIZE)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
 	status = usb_control_msg(usbdev,
 				 usb_rcvctrlpipe(usbdev, 0),
 				 USB_VENDOR_REGISTER_READ,
<span class="p_chunk">@@ -207,13 +207,13 @@</span> <span class="p_context"> static int rsi_usb_reg_write(struct usb_device *usbdev,</span>
 	u8 *usb_reg_buf;
 	int status = -ENOMEM;
 
<span class="p_add">+	if (len &gt; RSI_USB_CTRL_BUF_SIZE)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	usb_reg_buf  = kmalloc(RSI_USB_CTRL_BUF_SIZE, GFP_KERNEL);
 	if (!usb_reg_buf)
 		return status;
 
<span class="p_del">-	if (len &gt; RSI_USB_CTRL_BUF_SIZE)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
 	usb_reg_buf[0] = (value &amp; 0x00ff);
 	usb_reg_buf[1] = (value &amp; 0xff00) &gt;&gt; 8;
 	usb_reg_buf[2] = 0x0;
<span class="p_header">diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c</span>
<span class="p_header">index 71b944748304..c5fe7d4a9065 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c</span>
<span class="p_chunk">@@ -408,12 +408,21 @@</span> <span class="p_context"> static int armada_37xx_gpio_direction_output(struct gpio_chip *chip,</span>
 {
 	struct armada_37xx_pinctrl *info = gpiochip_get_data(chip);
 	unsigned int reg = OUTPUT_EN;
<span class="p_del">-	unsigned int mask;</span>
<span class="p_add">+	unsigned int mask, val, ret;</span>
 
 	armada_37xx_update_reg(&amp;reg, offset);
 	mask = BIT(offset);
 
<span class="p_del">-	return regmap_update_bits(info-&gt;regmap, reg, mask, mask);</span>
<span class="p_add">+	ret = regmap_update_bits(info-&gt;regmap, reg, mask, mask);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	reg = OUTPUT_VAL;</span>
<span class="p_add">+	val = value ? mask : 0;</span>
<span class="p_add">+	regmap_update_bits(info-&gt;regmap, reg, mask, val);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 static int armada_37xx_gpio_get(struct gpio_chip *chip, unsigned int offset)
<span class="p_header">diff --git a/drivers/rapidio/devices/rio_mport_cdev.c b/drivers/rapidio/devices/rio_mport_cdev.c</span>
<span class="p_header">index 5beb0c361076..76afe1449cab 100644</span>
<span class="p_header">--- a/drivers/rapidio/devices/rio_mport_cdev.c</span>
<span class="p_header">+++ b/drivers/rapidio/devices/rio_mport_cdev.c</span>
<span class="p_chunk">@@ -963,7 +963,8 @@</span> <span class="p_context"> rio_dma_transfer(struct file *filp, u32 transfer_mode,</span>
 			   req-&gt;sgt.sgl, req-&gt;sgt.nents, dir);
 	if (nents == -EFAULT) {
 		rmcd_error(&quot;Failed to map SG list&quot;);
<span class="p_del">-		return -EFAULT;</span>
<span class="p_add">+		ret = -EFAULT;</span>
<span class="p_add">+		goto err_pg;</span>
 	}
 
 	ret = do_dma_request(req, xfer, sync, nents);
<span class="p_header">diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c</span>
<span class="p_header">index bcc1694cebcd..635cfa1f2ace 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_lib.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_lib.c</span>
<span class="p_chunk">@@ -2126,11 +2126,13 @@</span> <span class="p_context"> void __scsi_init_queue(struct Scsi_Host *shost, struct request_queue *q)</span>
 		q-&gt;limits.cluster = 0;
 
 	/*
<span class="p_del">-	 * set a reasonable default alignment on word boundaries: the</span>
<span class="p_del">-	 * host and device may alter it using</span>
<span class="p_del">-	 * blk_queue_update_dma_alignment() later.</span>
<span class="p_add">+	 * Set a reasonable default alignment:  The larger of 32-byte (dword),</span>
<span class="p_add">+	 * which is a common minimum for HBAs, and the minimum DMA alignment,</span>
<span class="p_add">+	 * which is set by the platform.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Devices that require a bigger alignment can increase it later.</span>
 	 */
<span class="p_del">-	blk_queue_dma_alignment(q, 0x03);</span>
<span class="p_add">+	blk_queue_dma_alignment(q, max(4, dma_get_cache_alignment()) - 1);</span>
 }
 EXPORT_SYMBOL_GPL(__scsi_init_queue);
 
<span class="p_header">diff --git a/drivers/tty/serdev/serdev-ttyport.c b/drivers/tty/serdev/serdev-ttyport.c</span>
<span class="p_header">index 302018d67efa..7f785d77ba7f 100644</span>
<span class="p_header">--- a/drivers/tty/serdev/serdev-ttyport.c</span>
<span class="p_header">+++ b/drivers/tty/serdev/serdev-ttyport.c</span>
<span class="p_chunk">@@ -35,23 +35,41 @@</span> <span class="p_context"> static int ttyport_receive_buf(struct tty_port *port, const unsigned char *cp,</span>
 {
 	struct serdev_controller *ctrl = port-&gt;client_data;
 	struct serport *serport = serdev_controller_get_drvdata(ctrl);
<span class="p_add">+	int ret;</span>
 
 	if (!test_bit(SERPORT_ACTIVE, &amp;serport-&gt;flags))
 		return 0;
 
<span class="p_del">-	return serdev_controller_receive_buf(ctrl, cp, count);</span>
<span class="p_add">+	ret = serdev_controller_receive_buf(ctrl, cp, count);</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_WARN_ONCE(&amp;ctrl-&gt;dev, ret &lt; 0 || ret &gt; count,</span>
<span class="p_add">+				&quot;receive_buf returns %d (count = %zu)\n&quot;,</span>
<span class="p_add">+				ret, count);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	else if (ret &gt; count)</span>
<span class="p_add">+		return count;</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static void ttyport_write_wakeup(struct tty_port *port)
 {
 	struct serdev_controller *ctrl = port-&gt;client_data;
 	struct serport *serport = serdev_controller_get_drvdata(ctrl);
<span class="p_add">+	struct tty_struct *tty;</span>
<span class="p_add">+</span>
<span class="p_add">+	tty = tty_port_tty_get(port);</span>
<span class="p_add">+	if (!tty)</span>
<span class="p_add">+		return;</span>
 
<span class="p_del">-	if (test_and_clear_bit(TTY_DO_WRITE_WAKEUP, &amp;port-&gt;tty-&gt;flags) &amp;&amp;</span>
<span class="p_add">+	if (test_and_clear_bit(TTY_DO_WRITE_WAKEUP, &amp;tty-&gt;flags) &amp;&amp;</span>
 	    test_bit(SERPORT_ACTIVE, &amp;serport-&gt;flags))
 		serdev_controller_write_wakeup(ctrl);
 
<span class="p_del">-	wake_up_interruptible_poll(&amp;port-&gt;tty-&gt;write_wait, POLLOUT);</span>
<span class="p_add">+	wake_up_interruptible_poll(&amp;tty-&gt;write_wait, POLLOUT);</span>
<span class="p_add">+</span>
<span class="p_add">+	tty_kref_put(tty);</span>
 }
 
 static const struct tty_port_client_operations client_ops = {
<span class="p_chunk">@@ -131,8 +149,10 @@</span> <span class="p_context"> static void ttyport_close(struct serdev_controller *ctrl)</span>
 
 	clear_bit(SERPORT_ACTIVE, &amp;serport-&gt;flags);
 
<span class="p_add">+	tty_lock(tty);</span>
 	if (tty-&gt;ops-&gt;close)
 		tty-&gt;ops-&gt;close(tty, NULL);
<span class="p_add">+	tty_unlock(tty);</span>
 
 	tty_release_struct(tty, serport-&gt;tty_idx);
 }
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_fs.c b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">index ef8f7d63a8f0..0202e5132fa7 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_chunk">@@ -2286,9 +2286,18 @@</span> <span class="p_context"> static int __ffs_data_do_os_desc(enum ffs_os_desc_type type,</span>
 		int i;
 
 		if (len &lt; sizeof(*d) ||
<span class="p_del">-		    d-&gt;bFirstInterfaceNumber &gt;= ffs-&gt;interfaces_count ||</span>
<span class="p_del">-		    !d-&gt;Reserved1)</span>
<span class="p_add">+		    d-&gt;bFirstInterfaceNumber &gt;= ffs-&gt;interfaces_count)</span>
 			return -EINVAL;
<span class="p_add">+		if (d-&gt;Reserved1 != 1) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * According to the spec, Reserved1 must be set to 1</span>
<span class="p_add">+			 * but older kernels incorrectly rejected non-zero</span>
<span class="p_add">+			 * values.  We fix it here to avoid returning EINVAL</span>
<span class="p_add">+			 * in response to values we used to accept.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			pr_debug(&quot;usb_ext_compat_desc::Reserved1 forced to 1\n&quot;);</span>
<span class="p_add">+			d-&gt;Reserved1 = 1;</span>
<span class="p_add">+		}</span>
 		for (i = 0; i &lt; ARRAY_SIZE(d-&gt;Reserved2); ++i)
 			if (d-&gt;Reserved2[i])
 				return -EINVAL;
<span class="p_header">diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c</span>
<span class="p_header">index d41d07aae0ce..def1b05ffca0 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/core.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/core.c</span>
<span class="p_chunk">@@ -1080,8 +1080,12 @@</span> <span class="p_context"> static inline void usb_gadget_udc_stop(struct usb_udc *udc)</span>
 static inline void usb_gadget_udc_set_speed(struct usb_udc *udc,
 					    enum usb_device_speed speed)
 {
<span class="p_del">-	if (udc-&gt;gadget-&gt;ops-&gt;udc_set_speed)</span>
<span class="p_del">-		udc-&gt;gadget-&gt;ops-&gt;udc_set_speed(udc-&gt;gadget, speed);</span>
<span class="p_add">+	if (udc-&gt;gadget-&gt;ops-&gt;udc_set_speed) {</span>
<span class="p_add">+		enum usb_device_speed s;</span>
<span class="p_add">+</span>
<span class="p_add">+		s = min(speed, udc-&gt;gadget-&gt;max_speed);</span>
<span class="p_add">+		udc-&gt;gadget-&gt;ops-&gt;udc_set_speed(udc-&gt;gadget, s);</span>
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/usb/gadget/udc/renesas_usb3.c b/drivers/usb/gadget/udc/renesas_usb3.c</span>
<span class="p_header">index 63a206122058..6b3e8adb64e6 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/renesas_usb3.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/renesas_usb3.c</span>
<span class="p_chunk">@@ -254,7 +254,7 @@</span> <span class="p_context"></span>
 #define USB3_EP0_SS_MAX_PACKET_SIZE	512
 #define USB3_EP0_HSFS_MAX_PACKET_SIZE	64
 #define USB3_EP0_BUF_SIZE		8
<span class="p_del">-#define USB3_MAX_NUM_PIPES		30</span>
<span class="p_add">+#define USB3_MAX_NUM_PIPES		6	/* This includes PIPE 0 */</span>
 #define USB3_WAIT_US			3
 #define USB3_DMA_NUM_SETTING_AREA	4
 /*
<span class="p_header">diff --git a/drivers/virtio/virtio.c b/drivers/virtio/virtio.c</span>
<span class="p_header">index 48230a5e12f2..bf7ff3934d7f 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio.c</span>
<span class="p_chunk">@@ -333,6 +333,8 @@</span> <span class="p_context"> int register_virtio_device(struct virtio_device *dev)</span>
 	/* device_register() causes the bus infrastructure to look for a
 	 * matching driver. */
 	err = device_register(&amp;dev-&gt;dev);
<span class="p_add">+	if (err)</span>
<span class="p_add">+		ida_simple_remove(&amp;virtio_index_ida, dev-&gt;index);</span>
 out:
 	if (err)
 		virtio_add_status(dev, VIRTIO_CONFIG_S_FAILED);
<span class="p_header">diff --git a/fs/afs/cmservice.c b/fs/afs/cmservice.c</span>
<span class="p_header">index 782d4d05a53b..c7475867a52b 100644</span>
<span class="p_header">--- a/fs/afs/cmservice.c</span>
<span class="p_header">+++ b/fs/afs/cmservice.c</span>
<span class="p_chunk">@@ -127,6 +127,9 @@</span> <span class="p_context"> bool afs_cm_incoming_call(struct afs_call *call)</span>
 	case CBProbe:
 		call-&gt;type = &amp;afs_SRXCBProbe;
 		return true;
<span class="p_add">+	case CBProbeUuid:</span>
<span class="p_add">+		call-&gt;type = &amp;afs_SRXCBProbeUuid;</span>
<span class="p_add">+		return true;</span>
 	case CBTellMeAboutYourself:
 		call-&gt;type = &amp;afs_SRXCBTellMeAboutYourself;
 		return true;
<span class="p_header">diff --git a/fs/afs/rxrpc.c b/fs/afs/rxrpc.c</span>
<span class="p_header">index 0bf191f0dbaf..9f715c3edcf9 100644</span>
<span class="p_header">--- a/fs/afs/rxrpc.c</span>
<span class="p_header">+++ b/fs/afs/rxrpc.c</span>
<span class="p_chunk">@@ -377,8 +377,17 @@</span> <span class="p_context"> int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,</span>
 	 */
 	tx_total_len = call-&gt;request_size;
 	if (call-&gt;send_pages) {
<span class="p_del">-		tx_total_len += call-&gt;last_to - call-&gt;first_offset;</span>
<span class="p_del">-		tx_total_len += (call-&gt;last - call-&gt;first) * PAGE_SIZE;</span>
<span class="p_add">+		if (call-&gt;last == call-&gt;first) {</span>
<span class="p_add">+			tx_total_len += call-&gt;last_to - call-&gt;first_offset;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			/* It looks mathematically like you should be able to</span>
<span class="p_add">+			 * combine the following lines with the ones above, but</span>
<span class="p_add">+			 * unsigned arithmetic is fun when it wraps...</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			tx_total_len += PAGE_SIZE - call-&gt;first_offset;</span>
<span class="p_add">+			tx_total_len += call-&gt;last_to;</span>
<span class="p_add">+			tx_total_len += (call-&gt;last - call-&gt;first - 1) * PAGE_SIZE;</span>
<span class="p_add">+		}</span>
 	}
 
 	/* create a call */
<span class="p_header">diff --git a/fs/btrfs/ctree.c b/fs/btrfs/ctree.c</span>
<span class="p_header">index 6d49db7d86be..e2bb2a065741 100644</span>
<span class="p_header">--- a/fs/btrfs/ctree.c</span>
<span class="p_header">+++ b/fs/btrfs/ctree.c</span>
<span class="p_chunk">@@ -1032,14 +1032,17 @@</span> <span class="p_context"> static noinline int update_ref_for_cow(struct btrfs_trans_handle *trans,</span>
 		     root-&gt;root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) &amp;&amp;
 		    !(flags &amp; BTRFS_BLOCK_FLAG_FULL_BACKREF)) {
 			ret = btrfs_inc_ref(trans, root, buf, 1);
<span class="p_del">-			BUG_ON(ret); /* -ENOMEM */</span>
<span class="p_add">+			if (ret)</span>
<span class="p_add">+				return ret;</span>
 
 			if (root-&gt;root_key.objectid ==
 			    BTRFS_TREE_RELOC_OBJECTID) {
 				ret = btrfs_dec_ref(trans, root, buf, 0);
<span class="p_del">-				BUG_ON(ret); /* -ENOMEM */</span>
<span class="p_add">+				if (ret)</span>
<span class="p_add">+					return ret;</span>
 				ret = btrfs_inc_ref(trans, root, cow, 1);
<span class="p_del">-				BUG_ON(ret); /* -ENOMEM */</span>
<span class="p_add">+				if (ret)</span>
<span class="p_add">+					return ret;</span>
 			}
 			new_flags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;
 		} else {
<span class="p_chunk">@@ -1049,7 +1052,8 @@</span> <span class="p_context"> static noinline int update_ref_for_cow(struct btrfs_trans_handle *trans,</span>
 				ret = btrfs_inc_ref(trans, root, cow, 1);
 			else
 				ret = btrfs_inc_ref(trans, root, cow, 0);
<span class="p_del">-			BUG_ON(ret); /* -ENOMEM */</span>
<span class="p_add">+			if (ret)</span>
<span class="p_add">+				return ret;</span>
 		}
 		if (new_flags != 0) {
 			int level = btrfs_header_level(buf);
<span class="p_chunk">@@ -1068,9 +1072,11 @@</span> <span class="p_context"> static noinline int update_ref_for_cow(struct btrfs_trans_handle *trans,</span>
 				ret = btrfs_inc_ref(trans, root, cow, 1);
 			else
 				ret = btrfs_inc_ref(trans, root, cow, 0);
<span class="p_del">-			BUG_ON(ret); /* -ENOMEM */</span>
<span class="p_add">+			if (ret)</span>
<span class="p_add">+				return ret;</span>
 			ret = btrfs_dec_ref(trans, root, buf, 1);
<span class="p_del">-			BUG_ON(ret); /* -ENOMEM */</span>
<span class="p_add">+			if (ret)</span>
<span class="p_add">+				return ret;</span>
 		}
 		clean_tree_block(fs_info, buf);
 		*last_ref = 1;
<span class="p_header">diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c</span>
<span class="p_header">index e4774c02d922..d227d8514b25 100644</span>
<span class="p_header">--- a/fs/btrfs/extent-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/extent-tree.c</span>
<span class="p_chunk">@@ -9283,6 +9283,7 @@</span> <span class="p_context"> int btrfs_drop_snapshot(struct btrfs_root *root,</span>
 	ret = btrfs_del_root(trans, fs_info, &amp;root-&gt;root_key);
 	if (ret) {
 		btrfs_abort_transaction(trans, ret);
<span class="p_add">+		err = ret;</span>
 		goto out_end_trans;
 	}
 
<span class="p_header">diff --git a/fs/f2fs/file.c b/fs/f2fs/file.c</span>
<span class="p_header">index 6ce467872376..b8372095ba0a 100644</span>
<span class="p_header">--- a/fs/f2fs/file.c</span>
<span class="p_header">+++ b/fs/f2fs/file.c</span>
<span class="p_chunk">@@ -2697,6 +2697,7 @@</span> <span class="p_context"> static ssize_t f2fs_file_write_iter(struct kiocb *iocb, struct iov_iter *from)</span>
 
 		err = f2fs_preallocate_blocks(iocb, from);
 		if (err) {
<span class="p_add">+			clear_inode_flag(inode, FI_NO_PREALLOC);</span>
 			inode_unlock(inode);
 			return err;
 		}
<span class="p_header">diff --git a/fs/fcntl.c b/fs/fcntl.c</span>
<span class="p_header">index 8d78ffd7b399..6fd311367efc 100644</span>
<span class="p_header">--- a/fs/fcntl.c</span>
<span class="p_header">+++ b/fs/fcntl.c</span>
<span class="p_chunk">@@ -632,9 +632,8 @@</span> <span class="p_context"> COMPAT_SYSCALL_DEFINE3(fcntl64, unsigned int, fd, unsigned int, cmd,</span>
 		if (err)
 			break;
 		err = fixup_compat_flock(&amp;flock);
<span class="p_del">-		if (err)</span>
<span class="p_del">-			return err;</span>
<span class="p_del">-		err = put_compat_flock(&amp;flock, compat_ptr(arg));</span>
<span class="p_add">+		if (!err)</span>
<span class="p_add">+			err = put_compat_flock(&amp;flock, compat_ptr(arg));</span>
 		break;
 	case F_GETLK64:
 	case F_OFD_GETLK:
<span class="p_header">diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c</span>
<span class="p_header">index b03b3bc05f96..bf2c43635062 100644</span>
<span class="p_header">--- a/fs/nfs/dir.c</span>
<span class="p_header">+++ b/fs/nfs/dir.c</span>
<span class="p_chunk">@@ -2064,7 +2064,7 @@</span> <span class="p_context"> int nfs_rename(struct inode *old_dir, struct dentry *old_dentry,</span>
 		 * should mark the directories for revalidation.
 		 */
 		d_move(old_dentry, new_dentry);
<span class="p_del">-		nfs_set_verifier(new_dentry,</span>
<span class="p_add">+		nfs_set_verifier(old_dentry,</span>
 					nfs_save_change_attribute(new_dir));
 	} else if (error == -ENOENT)
 		nfs_dentry_handle_enoent(old_dentry);
<span class="p_header">diff --git a/fs/pipe.c b/fs/pipe.c</span>
<span class="p_header">index 349c9d56d4b3..3909c55ed389 100644</span>
<span class="p_header">--- a/fs/pipe.c</span>
<span class="p_header">+++ b/fs/pipe.c</span>
<span class="p_chunk">@@ -1125,7 +1125,7 @@</span> <span class="p_context"> int pipe_proc_fn(struct ctl_table *table, int write, void __user *buf,</span>
 {
 	int ret;
 
<span class="p_del">-	ret = proc_dointvec_minmax(table, write, buf, lenp, ppos);</span>
<span class="p_add">+	ret = proc_douintvec_minmax(table, write, buf, lenp, ppos);</span>
 	if (ret &lt; 0 || !write)
 		return ret;
 
<span class="p_header">diff --git a/fs/xfs/xfs_inode.c b/fs/xfs/xfs_inode.c</span>
<span class="p_header">index 4ec5b7f45401..63350906961a 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_inode.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_inode.c</span>
<span class="p_chunk">@@ -2378,6 +2378,7 @@</span> <span class="p_context"> xfs_ifree_cluster(</span>
 				 */
 				if (ip-&gt;i_ino != inum + i) {
 					xfs_iunlock(ip, XFS_ILOCK_EXCL);
<span class="p_add">+					rcu_read_unlock();</span>
 					continue;
 				}
 			}
<span class="p_header">diff --git a/include/linux/dma-mapping.h b/include/linux/dma-mapping.h</span>
<span class="p_header">index 7653ea66874d..46930f82a988 100644</span>
<span class="p_header">--- a/include/linux/dma-mapping.h</span>
<span class="p_header">+++ b/include/linux/dma-mapping.h</span>
<span class="p_chunk">@@ -697,7 +697,6 @@</span> <span class="p_context"> static inline void *dma_zalloc_coherent(struct device *dev, size_t size,</span>
 	return ret;
 }
 
<span class="p_del">-#ifdef CONFIG_HAS_DMA</span>
 static inline int dma_get_cache_alignment(void)
 {
 #ifdef ARCH_DMA_MINALIGN
<span class="p_chunk">@@ -705,7 +704,6 @@</span> <span class="p_context"> static inline int dma_get_cache_alignment(void)</span>
 #endif
 	return 1;
 }
<span class="p_del">-#endif</span>
 
 /* flags for the coherent memory api */
 #define DMA_MEMORY_EXCLUSIVE		0x01
<span class="p_header">diff --git a/include/linux/genalloc.h b/include/linux/genalloc.h</span>
<span class="p_header">index 6dfec4d638df..872f930f1b06 100644</span>
<span class="p_header">--- a/include/linux/genalloc.h</span>
<span class="p_header">+++ b/include/linux/genalloc.h</span>
<span class="p_chunk">@@ -32,6 +32,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/types.h&gt;
 #include &lt;linux/spinlock_types.h&gt;
<span class="p_add">+#include &lt;linux/atomic.h&gt;</span>
 
 struct device;
 struct device_node;
<span class="p_chunk">@@ -71,7 +72,7 @@</span> <span class="p_context"> struct gen_pool {</span>
  */
 struct gen_pool_chunk {
 	struct list_head next_chunk;	/* next chunk in pool */
<span class="p_del">-	atomic_t avail;</span>
<span class="p_add">+	atomic_long_t avail;</span>
 	phys_addr_t phys_addr;		/* physical starting address of memory chunk */
 	unsigned long start_addr;	/* start address of memory chunk */
 	unsigned long end_addr;		/* end address of memory chunk (inclusive) */
<span class="p_header">diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h</span>
<span class="p_header">index 6431087816ba..ba74eaa8eadf 100644</span>
<span class="p_header">--- a/include/linux/hyperv.h</span>
<span class="p_header">+++ b/include/linux/hyperv.h</span>
<span class="p_chunk">@@ -708,6 +708,7 @@</span> <span class="p_context"> struct vmbus_channel {</span>
 	u8 monitor_bit;
 
 	bool rescind; /* got rescind msg */
<span class="p_add">+	struct completion rescind_event;</span>
 
 	u32 ringbuffer_gpadlhandle;
 
<span class="p_header">diff --git a/include/linux/iio/timer/stm32-lptim-trigger.h b/include/linux/iio/timer/stm32-lptim-trigger.h</span>
<span class="p_header">index 34d59bfdce2d..464458d20b16 100644</span>
<span class="p_header">--- a/include/linux/iio/timer/stm32-lptim-trigger.h</span>
<span class="p_header">+++ b/include/linux/iio/timer/stm32-lptim-trigger.h</span>
<span class="p_chunk">@@ -16,11 +16,14 @@</span> <span class="p_context"></span>
 #define LPTIM2_OUT	&quot;lptim2_out&quot;
 #define LPTIM3_OUT	&quot;lptim3_out&quot;
 
<span class="p_del">-#if IS_ENABLED(CONFIG_IIO_STM32_LPTIMER_TRIGGER)</span>
<span class="p_add">+#if IS_REACHABLE(CONFIG_IIO_STM32_LPTIMER_TRIGGER)</span>
 bool is_stm32_lptim_trigger(struct iio_trigger *trig);
 #else
 static inline bool is_stm32_lptim_trigger(struct iio_trigger *trig)
 {
<span class="p_add">+#if IS_ENABLED(CONFIG_IIO_STM32_LPTIMER_TRIGGER)</span>
<span class="p_add">+	pr_warn_once(&quot;stm32 lptim_trigger not linked in\n&quot;);</span>
<span class="p_add">+#endif</span>
 	return false;
 }
 #endif
<span class="p_header">diff --git a/include/linux/sysfs.h b/include/linux/sysfs.h</span>
<span class="p_header">index e32dfe098e82..40839c02d28c 100644</span>
<span class="p_header">--- a/include/linux/sysfs.h</span>
<span class="p_header">+++ b/include/linux/sysfs.h</span>
<span class="p_chunk">@@ -117,6 +117,12 @@</span> <span class="p_context"> struct attribute_group {</span>
 	.show	= _name##_show,						\
 }
 
<span class="p_add">+#define __ATTR_RO_MODE(_name, _mode) {					\</span>
<span class="p_add">+	.attr	= { .name = __stringify(_name),				\</span>
<span class="p_add">+		    .mode = VERIFY_OCTAL_PERMISSIONS(_mode) },		\</span>
<span class="p_add">+	.show	= _name##_show,						\</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define __ATTR_WO(_name) {						\
 	.attr	= { .name = __stringify(_name), .mode = S_IWUSR },	\
 	.store	= _name##_store,					\
<span class="p_header">diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h</span>
<span class="p_header">index 6c0dc6155ee7..a966d281dedc 100644</span>
<span class="p_header">--- a/include/scsi/libsas.h</span>
<span class="p_header">+++ b/include/scsi/libsas.h</span>
<span class="p_chunk">@@ -165,11 +165,11 @@</span> <span class="p_context"> struct expander_device {</span>
 
 struct sata_device {
 	unsigned int class;
<span class="p_del">-	struct smp_resp        rps_resp; /* report_phy_sata_resp */</span>
 	u8     port_no;        /* port number, if this is a PM (Port) */
 
 	struct ata_port *ap;
 	struct ata_host ata_host;
<span class="p_add">+	struct smp_resp rps_resp ____cacheline_aligned; /* report_phy_sata_resp */</span>
 	u8     fis[ATA_RESP_FIS_SIZE];
 };
 
<span class="p_header">diff --git a/kernel/bpf/percpu_freelist.c b/kernel/bpf/percpu_freelist.c</span>
<span class="p_header">index 5c51d1985b51..673fa6fe2d73 100644</span>
<span class="p_header">--- a/kernel/bpf/percpu_freelist.c</span>
<span class="p_header">+++ b/kernel/bpf/percpu_freelist.c</span>
<span class="p_chunk">@@ -78,8 +78,10 @@</span> <span class="p_context"> struct pcpu_freelist_node *pcpu_freelist_pop(struct pcpu_freelist *s)</span>
 {
 	struct pcpu_freelist_head *head;
 	struct pcpu_freelist_node *node;
<span class="p_add">+	unsigned long flags;</span>
 	int orig_cpu, cpu;
 
<span class="p_add">+	local_irq_save(flags);</span>
 	orig_cpu = cpu = raw_smp_processor_id();
 	while (1) {
 		head = per_cpu_ptr(s-&gt;freelist, cpu);
<span class="p_chunk">@@ -87,14 +89,16 @@</span> <span class="p_context"> struct pcpu_freelist_node *pcpu_freelist_pop(struct pcpu_freelist *s)</span>
 		node = head-&gt;first;
 		if (node) {
 			head-&gt;first = node-&gt;next;
<span class="p_del">-			raw_spin_unlock(&amp;head-&gt;lock);</span>
<span class="p_add">+			raw_spin_unlock_irqrestore(&amp;head-&gt;lock, flags);</span>
 			return node;
 		}
 		raw_spin_unlock(&amp;head-&gt;lock);
 		cpu = cpumask_next(cpu, cpu_possible_mask);
 		if (cpu &gt;= nr_cpu_ids)
 			cpu = 0;
<span class="p_del">-		if (cpu == orig_cpu)</span>
<span class="p_add">+		if (cpu == orig_cpu) {</span>
<span class="p_add">+			local_irq_restore(flags);</span>
 			return NULL;
<span class="p_add">+		}</span>
 	}
 }
<span class="p_header">diff --git a/kernel/cpu.c b/kernel/cpu.c</span>
<span class="p_header">index 04892a82f6ac..7891aecc6aec 100644</span>
<span class="p_header">--- a/kernel/cpu.c</span>
<span class="p_header">+++ b/kernel/cpu.c</span>
<span class="p_chunk">@@ -1289,11 +1289,6 @@</span> <span class="p_context"> static struct cpuhp_step cpuhp_bp_states[] = {</span>
 		.teardown.single	= NULL,
 		.cant_stop		= true,
 	},
<span class="p_del">-	[CPUHP_AP_SMPCFD_DYING] = {</span>
<span class="p_del">-		.name			= &quot;smpcfd:dying&quot;,</span>
<span class="p_del">-		.startup.single		= NULL,</span>
<span class="p_del">-		.teardown.single	= smpcfd_dying_cpu,</span>
<span class="p_del">-	},</span>
 	/*
 	 * Handled on controll processor until the plugged processor manages
 	 * this itself.
<span class="p_chunk">@@ -1335,6 +1330,11 @@</span> <span class="p_context"> static struct cpuhp_step cpuhp_ap_states[] = {</span>
 		.startup.single		= NULL,
 		.teardown.single	= rcutree_dying_cpu,
 	},
<span class="p_add">+	[CPUHP_AP_SMPCFD_DYING] = {</span>
<span class="p_add">+		.name			= &quot;smpcfd:dying&quot;,</span>
<span class="p_add">+		.startup.single		= NULL,</span>
<span class="p_add">+		.teardown.single	= smpcfd_dying_cpu,</span>
<span class="p_add">+	},</span>
 	/* Entry state on starting. Interrupts enabled from here on. Transient
 	 * state for synchronsization */
 	[CPUHP_AP_ONLINE] = {
<span class="p_header">diff --git a/kernel/debug/kdb/kdb_io.c b/kernel/debug/kdb/kdb_io.c</span>
<span class="p_header">index e74be38245ad..ed5d34925ad0 100644</span>
<span class="p_header">--- a/kernel/debug/kdb/kdb_io.c</span>
<span class="p_header">+++ b/kernel/debug/kdb/kdb_io.c</span>
<span class="p_chunk">@@ -350,7 +350,7 @@</span> <span class="p_context"> static char *kdb_read(char *buffer, size_t bufsize)</span>
 			}
 			kdb_printf(&quot;\n&quot;);
 			for (i = 0; i &lt; count; i++) {
<span class="p_del">-				if (kallsyms_symbol_next(p_tmp, i) &lt; 0)</span>
<span class="p_add">+				if (WARN_ON(!kallsyms_symbol_next(p_tmp, i)))</span>
 					break;
 				kdb_printf(&quot;%s &quot;, p_tmp);
 				*(p_tmp + len) = &#39;\0&#39;;
<span class="p_header">diff --git a/kernel/jump_label.c b/kernel/jump_label.c</span>
<span class="p_header">index 0bf2e8f5244a..7c3774ac1d51 100644</span>
<span class="p_header">--- a/kernel/jump_label.c</span>
<span class="p_header">+++ b/kernel/jump_label.c</span>
<span class="p_chunk">@@ -769,7 +769,7 @@</span> <span class="p_context"> static __init int jump_label_test(void)</span>
 
 	return 0;
 }
<span class="p_del">-late_initcall(jump_label_test);</span>
<span class="p_add">+early_initcall(jump_label_test);</span>
 #endif /* STATIC_KEYS_SELFTEST */
 
 #endif /* HAVE_JUMP_LABEL */
<span class="p_header">diff --git a/kernel/sysctl.c b/kernel/sysctl.c</span>
<span class="p_header">index d9c31bc2eaea..56aca862c4f5 100644</span>
<span class="p_header">--- a/kernel/sysctl.c</span>
<span class="p_header">+++ b/kernel/sysctl.c</span>
<span class="p_chunk">@@ -1822,7 +1822,7 @@</span> <span class="p_context"> static struct ctl_table fs_table[] = {</span>
 	{
 		.procname	= &quot;pipe-max-size&quot;,
 		.data		= &amp;pipe_max_size,
<span class="p_del">-		.maxlen		= sizeof(int),</span>
<span class="p_add">+		.maxlen		= sizeof(pipe_max_size),</span>
 		.mode		= 0644,
 		.proc_handler	= &amp;pipe_proc_fn,
 		.extra1		= &amp;pipe_min_size,
<span class="p_header">diff --git a/lib/asn1_decoder.c b/lib/asn1_decoder.c</span>
<span class="p_header">index 1ef0cec38d78..dc14beae2c9a 100644</span>
<span class="p_header">--- a/lib/asn1_decoder.c</span>
<span class="p_header">+++ b/lib/asn1_decoder.c</span>
<span class="p_chunk">@@ -313,42 +313,47 @@</span> <span class="p_context"> int asn1_ber_decoder(const struct asn1_decoder *decoder,</span>
 
 	/* Decide how to handle the operation */
 	switch (op) {
<span class="p_del">-	case ASN1_OP_MATCH_ANY_ACT:</span>
<span class="p_del">-	case ASN1_OP_MATCH_ANY_ACT_OR_SKIP:</span>
<span class="p_del">-	case ASN1_OP_COND_MATCH_ANY_ACT:</span>
<span class="p_del">-	case ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP:</span>
<span class="p_del">-		ret = actions[machine[pc + 1]](context, hdr, tag, data + dp, len);</span>
<span class="p_del">-		if (ret &lt; 0)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-		goto skip_data;</span>
<span class="p_del">-</span>
<span class="p_del">-	case ASN1_OP_MATCH_ACT:</span>
<span class="p_del">-	case ASN1_OP_MATCH_ACT_OR_SKIP:</span>
<span class="p_del">-	case ASN1_OP_COND_MATCH_ACT_OR_SKIP:</span>
<span class="p_del">-		ret = actions[machine[pc + 2]](context, hdr, tag, data + dp, len);</span>
<span class="p_del">-		if (ret &lt; 0)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-		goto skip_data;</span>
<span class="p_del">-</span>
 	case ASN1_OP_MATCH:
 	case ASN1_OP_MATCH_OR_SKIP:
<span class="p_add">+	case ASN1_OP_MATCH_ACT:</span>
<span class="p_add">+	case ASN1_OP_MATCH_ACT_OR_SKIP:</span>
 	case ASN1_OP_MATCH_ANY:
 	case ASN1_OP_MATCH_ANY_OR_SKIP:
<span class="p_add">+	case ASN1_OP_MATCH_ANY_ACT:</span>
<span class="p_add">+	case ASN1_OP_MATCH_ANY_ACT_OR_SKIP:</span>
 	case ASN1_OP_COND_MATCH_OR_SKIP:
<span class="p_add">+	case ASN1_OP_COND_MATCH_ACT_OR_SKIP:</span>
 	case ASN1_OP_COND_MATCH_ANY:
 	case ASN1_OP_COND_MATCH_ANY_OR_SKIP:
<span class="p_del">-	skip_data:</span>
<span class="p_add">+	case ASN1_OP_COND_MATCH_ANY_ACT:</span>
<span class="p_add">+	case ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP:</span>
<span class="p_add">+</span>
 		if (!(flags &amp; FLAG_CONS)) {
 			if (flags &amp; FLAG_INDEFINITE_LENGTH) {
<span class="p_add">+				size_t tmp = dp;</span>
<span class="p_add">+</span>
 				ret = asn1_find_indefinite_length(
<span class="p_del">-					data, datalen, &amp;dp, &amp;len, &amp;errmsg);</span>
<span class="p_add">+					data, datalen, &amp;tmp, &amp;len, &amp;errmsg);</span>
 				if (ret &lt; 0)
 					goto error;
<span class="p_del">-			} else {</span>
<span class="p_del">-				dp += len;</span>
 			}
 			pr_debug(&quot;- LEAF: %zu\n&quot;, len);
 		}
<span class="p_add">+</span>
<span class="p_add">+		if (op &amp; ASN1_OP_MATCH__ACT) {</span>
<span class="p_add">+			unsigned char act;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (op &amp; ASN1_OP_MATCH__ANY)</span>
<span class="p_add">+				act = machine[pc + 1];</span>
<span class="p_add">+			else</span>
<span class="p_add">+				act = machine[pc + 2];</span>
<span class="p_add">+			ret = actions[act](context, hdr, tag, data + dp, len);</span>
<span class="p_add">+			if (ret &lt; 0)</span>
<span class="p_add">+				return ret;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!(flags &amp; FLAG_CONS))</span>
<span class="p_add">+			dp += len;</span>
 		pc += asn1_op_lengths[op];
 		goto next_op;
 
<span class="p_chunk">@@ -434,6 +439,8 @@</span> <span class="p_context"> int asn1_ber_decoder(const struct asn1_decoder *decoder,</span>
 			else
 				act = machine[pc + 1];
 			ret = actions[act](context, hdr, 0, data + tdp, len);
<span class="p_add">+			if (ret &lt; 0)</span>
<span class="p_add">+				return ret;</span>
 		}
 		pc += asn1_op_lengths[op];
 		goto next_op;
<span class="p_header">diff --git a/lib/dynamic_debug.c b/lib/dynamic_debug.c</span>
<span class="p_header">index da796e2dc4f5..c7c96bc7654a 100644</span>
<span class="p_header">--- a/lib/dynamic_debug.c</span>
<span class="p_header">+++ b/lib/dynamic_debug.c</span>
<span class="p_chunk">@@ -360,6 +360,10 @@</span> <span class="p_context"> static int ddebug_parse_query(char *words[], int nwords,</span>
 				if (parse_lineno(last, &amp;query-&gt;last_lineno) &lt; 0)
 					return -EINVAL;
 
<span class="p_add">+				/* special case for last lineno not specified */</span>
<span class="p_add">+				if (query-&gt;last_lineno == 0)</span>
<span class="p_add">+					query-&gt;last_lineno = UINT_MAX;</span>
<span class="p_add">+</span>
 				if (query-&gt;last_lineno &lt; query-&gt;first_lineno) {
 					pr_err(&quot;last-line:%d &lt; 1st-line:%d\n&quot;,
 						query-&gt;last_lineno,
<span class="p_header">diff --git a/lib/genalloc.c b/lib/genalloc.c</span>
<span class="p_header">index 144fe6b1a03e..ca06adc4f445 100644</span>
<span class="p_header">--- a/lib/genalloc.c</span>
<span class="p_header">+++ b/lib/genalloc.c</span>
<span class="p_chunk">@@ -194,7 +194,7 @@</span> <span class="p_context"> int gen_pool_add_virt(struct gen_pool *pool, unsigned long virt, phys_addr_t phy</span>
 	chunk-&gt;phys_addr = phys;
 	chunk-&gt;start_addr = virt;
 	chunk-&gt;end_addr = virt + size - 1;
<span class="p_del">-	atomic_set(&amp;chunk-&gt;avail, size);</span>
<span class="p_add">+	atomic_long_set(&amp;chunk-&gt;avail, size);</span>
 
 	spin_lock(&amp;pool-&gt;lock);
 	list_add_rcu(&amp;chunk-&gt;next_chunk, &amp;pool-&gt;chunks);
<span class="p_chunk">@@ -304,7 +304,7 @@</span> <span class="p_context"> unsigned long gen_pool_alloc_algo(struct gen_pool *pool, size_t size,</span>
 	nbits = (size + (1UL &lt;&lt; order) - 1) &gt;&gt; order;
 	rcu_read_lock();
 	list_for_each_entry_rcu(chunk, &amp;pool-&gt;chunks, next_chunk) {
<span class="p_del">-		if (size &gt; atomic_read(&amp;chunk-&gt;avail))</span>
<span class="p_add">+		if (size &gt; atomic_long_read(&amp;chunk-&gt;avail))</span>
 			continue;
 
 		start_bit = 0;
<span class="p_chunk">@@ -324,7 +324,7 @@</span> <span class="p_context"> unsigned long gen_pool_alloc_algo(struct gen_pool *pool, size_t size,</span>
 
 		addr = chunk-&gt;start_addr + ((unsigned long)start_bit &lt;&lt; order);
 		size = nbits &lt;&lt; order;
<span class="p_del">-		atomic_sub(size, &amp;chunk-&gt;avail);</span>
<span class="p_add">+		atomic_long_sub(size, &amp;chunk-&gt;avail);</span>
 		break;
 	}
 	rcu_read_unlock();
<span class="p_chunk">@@ -390,7 +390,7 @@</span> <span class="p_context"> void gen_pool_free(struct gen_pool *pool, unsigned long addr, size_t size)</span>
 			remain = bitmap_clear_ll(chunk-&gt;bits, start_bit, nbits);
 			BUG_ON(remain);
 			size = nbits &lt;&lt; order;
<span class="p_del">-			atomic_add(size, &amp;chunk-&gt;avail);</span>
<span class="p_add">+			atomic_long_add(size, &amp;chunk-&gt;avail);</span>
 			rcu_read_unlock();
 			return;
 		}
<span class="p_chunk">@@ -464,7 +464,7 @@</span> <span class="p_context"> size_t gen_pool_avail(struct gen_pool *pool)</span>
 
 	rcu_read_lock();
 	list_for_each_entry_rcu(chunk, &amp;pool-&gt;chunks, next_chunk)
<span class="p_del">-		avail += atomic_read(&amp;chunk-&gt;avail);</span>
<span class="p_add">+		avail += atomic_long_read(&amp;chunk-&gt;avail);</span>
 	rcu_read_unlock();
 	return avail;
 }
<span class="p_header">diff --git a/mm/slub.c b/mm/slub.c</span>
<span class="p_header">index 1efbb8123037..8e1c027a30f4 100644</span>
<span class="p_header">--- a/mm/slub.c</span>
<span class="p_header">+++ b/mm/slub.c</span>
<span class="p_chunk">@@ -5704,6 +5704,10 @@</span> <span class="p_context"> static int sysfs_slab_add(struct kmem_cache *s)</span>
 		return 0;
 	}
 
<span class="p_add">+	if (!unmergeable &amp;&amp; disable_higher_order_debug &amp;&amp;</span>
<span class="p_add">+			(slub_debug &amp; DEBUG_METADATA_FLAGS))</span>
<span class="p_add">+		unmergeable = 1;</span>
<span class="p_add">+</span>
 	if (unmergeable) {
 		/*
 		 * Slabcache can never be merged so we can use the name proper.
<span class="p_header">diff --git a/mm/zsmalloc.c b/mm/zsmalloc.c</span>
<span class="p_header">index 7c38e850a8fc..685049a9048d 100644</span>
<span class="p_header">--- a/mm/zsmalloc.c</span>
<span class="p_header">+++ b/mm/zsmalloc.c</span>
<span class="p_chunk">@@ -1349,7 +1349,7 @@</span> <span class="p_context"> void *zs_map_object(struct zs_pool *pool, unsigned long handle,</span>
 	 * pools/users, we can&#39;t allow mapping in interrupt context
 	 * because it can corrupt another users mappings.
 	 */
<span class="p_del">-	WARN_ON_ONCE(in_interrupt());</span>
<span class="p_add">+	BUG_ON(in_interrupt());</span>
 
 	/* From now on, migration cannot move the object */
 	pin_tag(handle);
<span class="p_header">diff --git a/net/ipv4/route.c b/net/ipv4/route.c</span>
<span class="p_header">index 3d9f1c2f81c5..647cfc972bde 100644</span>
<span class="p_header">--- a/net/ipv4/route.c</span>
<span class="p_header">+++ b/net/ipv4/route.c</span>
<span class="p_chunk">@@ -651,9 +651,12 @@</span> <span class="p_context"> static void update_or_create_fnhe(struct fib_nh *nh, __be32 daddr, __be32 gw,</span>
 	struct fnhe_hash_bucket *hash;
 	struct fib_nh_exception *fnhe;
 	struct rtable *rt;
<span class="p_add">+	u32 genid, hval;</span>
 	unsigned int i;
 	int depth;
<span class="p_del">-	u32 hval = fnhe_hashfun(daddr);</span>
<span class="p_add">+</span>
<span class="p_add">+	genid = fnhe_genid(dev_net(nh-&gt;nh_dev));</span>
<span class="p_add">+	hval = fnhe_hashfun(daddr);</span>
 
 	spin_lock_bh(&amp;fnhe_lock);
 
<span class="p_chunk">@@ -676,12 +679,13 @@</span> <span class="p_context"> static void update_or_create_fnhe(struct fib_nh *nh, __be32 daddr, __be32 gw,</span>
 	}
 
 	if (fnhe) {
<span class="p_add">+		if (fnhe-&gt;fnhe_genid != genid)</span>
<span class="p_add">+			fnhe-&gt;fnhe_genid = genid;</span>
 		if (gw)
 			fnhe-&gt;fnhe_gw = gw;
<span class="p_del">-		if (pmtu) {</span>
<span class="p_add">+		if (pmtu)</span>
 			fnhe-&gt;fnhe_pmtu = pmtu;
<span class="p_del">-			fnhe-&gt;fnhe_expires = max(1UL, expires);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		fnhe-&gt;fnhe_expires = max(1UL, expires);</span>
 		/* Update all cached dsts too */
 		rt = rcu_dereference(fnhe-&gt;fnhe_rth_input);
 		if (rt)
<span class="p_chunk">@@ -700,7 +704,7 @@</span> <span class="p_context"> static void update_or_create_fnhe(struct fib_nh *nh, __be32 daddr, __be32 gw,</span>
 			fnhe-&gt;fnhe_next = hash-&gt;chain;
 			rcu_assign_pointer(hash-&gt;chain, fnhe);
 		}
<span class="p_del">-		fnhe-&gt;fnhe_genid = fnhe_genid(dev_net(nh-&gt;nh_dev));</span>
<span class="p_add">+		fnhe-&gt;fnhe_genid = genid;</span>
 		fnhe-&gt;fnhe_daddr = daddr;
 		fnhe-&gt;fnhe_gw = gw;
 		fnhe-&gt;fnhe_pmtu = pmtu;
<span class="p_header">diff --git a/net/ipv6/ip6_gre.c b/net/ipv6/ip6_gre.c</span>
<span class="p_header">index 59c121b932ac..5d6bee070871 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_gre.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_gre.c</span>
<span class="p_chunk">@@ -461,7 +461,7 @@</span> <span class="p_context"> static int ip6gre_rcv(struct sk_buff *skb, const struct tnl_ptk_info *tpi)</span>
 				      &amp;ipv6h-&gt;saddr, &amp;ipv6h-&gt;daddr, tpi-&gt;key,
 				      tpi-&gt;proto);
 	if (tunnel) {
<span class="p_del">-		ip6_tnl_rcv(tunnel, skb, tpi, NULL, false);</span>
<span class="p_add">+		ip6_tnl_rcv(tunnel, skb, tpi, NULL, log_ecn_error);</span>
 
 		return PACKET_RCVD;
 	}
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index 6f45d1713452..14c28fbfe6b8 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -83,8 +83,8 @@</span> <span class="p_context"></span>
 /* Forward declarations for internal helper functions. */
 static int sctp_writeable(struct sock *sk);
 static void sctp_wfree(struct sk_buff *skb);
<span class="p_del">-static int sctp_wait_for_sndbuf(struct sctp_association *, long *timeo_p,</span>
<span class="p_del">-				size_t msg_len);</span>
<span class="p_add">+static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,</span>
<span class="p_add">+				size_t msg_len, struct sock **orig_sk);</span>
 static int sctp_wait_for_packet(struct sock *sk, int *err, long *timeo_p);
 static int sctp_wait_for_connect(struct sctp_association *, long *timeo_p);
 static int sctp_wait_for_accept(struct sock *sk, long timeo);
<span class="p_chunk">@@ -1962,9 +1962,16 @@</span> <span class="p_context"> static int sctp_sendmsg(struct sock *sk, struct msghdr *msg, size_t msg_len)</span>
 
 	timeo = sock_sndtimeo(sk, msg-&gt;msg_flags &amp; MSG_DONTWAIT);
 	if (!sctp_wspace(asoc)) {
<span class="p_del">-		err = sctp_wait_for_sndbuf(asoc, &amp;timeo, msg_len);</span>
<span class="p_del">-		if (err)</span>
<span class="p_add">+		/* sk can be changed by peel off when waiting for buf. */</span>
<span class="p_add">+		err = sctp_wait_for_sndbuf(asoc, &amp;timeo, msg_len, &amp;sk);</span>
<span class="p_add">+		if (err) {</span>
<span class="p_add">+			if (err == -ESRCH) {</span>
<span class="p_add">+				/* asoc is already dead. */</span>
<span class="p_add">+				new_asoc = NULL;</span>
<span class="p_add">+				err = -EPIPE;</span>
<span class="p_add">+			}</span>
 			goto out_free;
<span class="p_add">+		}</span>
 	}
 
 	/* If an address is passed with the sendto/sendmsg call, it is used
<span class="p_chunk">@@ -4943,12 +4950,6 @@</span> <span class="p_context"> int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)</span>
 	if (!asoc)
 		return -EINVAL;
 
<span class="p_del">-	/* If there is a thread waiting on more sndbuf space for</span>
<span class="p_del">-	 * sending on this asoc, it cannot be peeled.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (waitqueue_active(&amp;asoc-&gt;wait))</span>
<span class="p_del">-		return -EBUSY;</span>
<span class="p_del">-</span>
 	/* An association cannot be branched off from an already peeled-off
 	 * socket, nor is this supported for tcp style sockets.
 	 */
<span class="p_chunk">@@ -7822,7 +7823,7 @@</span> <span class="p_context"> void sctp_sock_rfree(struct sk_buff *skb)</span>
 
 /* Helper function to wait for space in the sndbuf.  */
 static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
<span class="p_del">-				size_t msg_len)</span>
<span class="p_add">+				size_t msg_len, struct sock **orig_sk)</span>
 {
 	struct sock *sk = asoc-&gt;base.sk;
 	int err = 0;
<span class="p_chunk">@@ -7839,10 +7840,11 @@</span> <span class="p_context"> static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,</span>
 	for (;;) {
 		prepare_to_wait_exclusive(&amp;asoc-&gt;wait, &amp;wait,
 					  TASK_INTERRUPTIBLE);
<span class="p_add">+		if (asoc-&gt;base.dead)</span>
<span class="p_add">+			goto do_dead;</span>
 		if (!*timeo_p)
 			goto do_nonblock;
<span class="p_del">-		if (sk-&gt;sk_err || asoc-&gt;state &gt;= SCTP_STATE_SHUTDOWN_PENDING ||</span>
<span class="p_del">-		    asoc-&gt;base.dead)</span>
<span class="p_add">+		if (sk-&gt;sk_err || asoc-&gt;state &gt;= SCTP_STATE_SHUTDOWN_PENDING)</span>
 			goto do_error;
 		if (signal_pending(current))
 			goto do_interrupted;
<span class="p_chunk">@@ -7855,11 +7857,17 @@</span> <span class="p_context"> static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,</span>
 		release_sock(sk);
 		current_timeo = schedule_timeout(current_timeo);
 		lock_sock(sk);
<span class="p_add">+		if (sk != asoc-&gt;base.sk) {</span>
<span class="p_add">+			release_sock(sk);</span>
<span class="p_add">+			sk = asoc-&gt;base.sk;</span>
<span class="p_add">+			lock_sock(sk);</span>
<span class="p_add">+		}</span>
 
 		*timeo_p = current_timeo;
 	}
 
 out:
<span class="p_add">+	*orig_sk = sk;</span>
 	finish_wait(&amp;asoc-&gt;wait, &amp;wait);
 
 	/* Release the association&#39;s refcnt.  */
<span class="p_chunk">@@ -7867,6 +7875,10 @@</span> <span class="p_context"> static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,</span>
 
 	return err;
 
<span class="p_add">+do_dead:</span>
<span class="p_add">+	err = -ESRCH;</span>
<span class="p_add">+	goto out;</span>
<span class="p_add">+</span>
 do_error:
 	err = -EPIPE;
 	goto out;
<span class="p_header">diff --git a/net/smc/smc_core.c b/net/smc/smc_core.c</span>
<span class="p_header">index 413e3868fbf3..7166e7ecbe86 100644</span>
<span class="p_header">--- a/net/smc/smc_core.c</span>
<span class="p_header">+++ b/net/smc/smc_core.c</span>
<span class="p_chunk">@@ -571,7 +571,7 @@</span> <span class="p_context"> static int __smc_buf_create(struct smc_sock *smc, bool is_rmb)</span>
 		/* use socket send buffer size (w/o overhead) as start value */
 		sk_buf_size = smc-&gt;sk.sk_sndbuf / 2;
 
<span class="p_del">-	for (bufsize_short = smc_compress_bufsize(smc-&gt;sk.sk_sndbuf / 2);</span>
<span class="p_add">+	for (bufsize_short = smc_compress_bufsize(sk_buf_size);</span>
 	     bufsize_short &gt;= 0; bufsize_short--) {
 
 		if (is_rmb) {
<span class="p_header">diff --git a/net/sunrpc/sched.c b/net/sunrpc/sched.c</span>
<span class="p_header">index 0cc83839c13c..f9db5fe52d36 100644</span>
<span class="p_header">--- a/net/sunrpc/sched.c</span>
<span class="p_header">+++ b/net/sunrpc/sched.c</span>
<span class="p_chunk">@@ -274,10 +274,9 @@</span> <span class="p_context"> static inline void rpc_task_set_debuginfo(struct rpc_task *task)</span>
 
 static void rpc_set_active(struct rpc_task *task)
 {
<span class="p_del">-	trace_rpc_task_begin(task-&gt;tk_client, task, NULL);</span>
<span class="p_del">-</span>
 	rpc_task_set_debuginfo(task);
 	set_bit(RPC_TASK_ACTIVE, &amp;task-&gt;tk_runstate);
<span class="p_add">+	trace_rpc_task_begin(task-&gt;tk_client, task, NULL);</span>
 }
 
 /*
<span class="p_header">diff --git a/net/tls/tls_sw.c b/net/tls/tls_sw.c</span>
<span class="p_header">index 7d80040a37b6..f00383a37622 100644</span>
<span class="p_header">--- a/net/tls/tls_sw.c</span>
<span class="p_header">+++ b/net/tls/tls_sw.c</span>
<span class="p_chunk">@@ -219,7 +219,7 @@</span> <span class="p_context"> static int tls_do_encryption(struct tls_context *tls_ctx,</span>
 	struct aead_request *aead_req;
 	int rc;
 
<span class="p_del">-	aead_req = kmalloc(req_size, flags);</span>
<span class="p_add">+	aead_req = kzalloc(req_size, flags);</span>
 	if (!aead_req)
 		return -ENOMEM;
 
<span class="p_header">diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c</span>
<span class="p_header">index 6eb228a70131..2a6093840e7e 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_policy.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_policy.c</span>
<span class="p_chunk">@@ -1306,6 +1306,7 @@</span> <span class="p_context"> static struct xfrm_policy *clone_policy(const struct xfrm_policy *old, int dir)</span>
 		newp-&gt;xfrm_nr = old-&gt;xfrm_nr;
 		newp-&gt;index = old-&gt;index;
 		newp-&gt;type = old-&gt;type;
<span class="p_add">+		newp-&gt;family = old-&gt;family;</span>
 		memcpy(newp-&gt;xfrm_vec, old-&gt;xfrm_vec,
 		       newp-&gt;xfrm_nr*sizeof(struct xfrm_tmpl));
 		spin_lock_bh(&amp;net-&gt;xfrm.xfrm_policy_lock);
<span class="p_header">diff --git a/scripts/coccicheck b/scripts/coccicheck</span>
<span class="p_header">index 28ad1feff9e1..dda283aba96b 100755</span>
<span class="p_header">--- a/scripts/coccicheck</span>
<span class="p_header">+++ b/scripts/coccicheck</span>
<span class="p_chunk">@@ -30,12 +30,6 @@</span> <span class="p_context"> else</span>
 	VERBOSE=0
 fi
 
<span class="p_del">-if [ -z &quot;$J&quot; ]; then</span>
<span class="p_del">-	NPROC=$(getconf _NPROCESSORS_ONLN)</span>
<span class="p_del">-else</span>
<span class="p_del">-	NPROC=&quot;$J&quot;</span>
<span class="p_del">-fi</span>
<span class="p_del">-</span>
 FLAGS=&quot;--very-quiet&quot;
 
 # You can use SPFLAGS to append extra arguments to coccicheck or override any
<span class="p_chunk">@@ -70,6 +64,9 @@</span> <span class="p_context"> if [ &quot;$C&quot; = &quot;1&quot; -o &quot;$C&quot; = &quot;2&quot; ]; then</span>
     # Take only the last argument, which is the C file to test
     shift $(( $# - 1 ))
     OPTIONS=&quot;$COCCIINCLUDE $1&quot;
<span class="p_add">+</span>
<span class="p_add">+    # No need to parallelize Coccinelle since this mode takes one input file.</span>
<span class="p_add">+    NPROC=1</span>
 else
     ONLINE=0
     if [ &quot;$KBUILD_EXTMOD&quot; = &quot;&quot; ] ; then
<span class="p_chunk">@@ -77,6 +74,12 @@</span> <span class="p_context"> else</span>
     else
         OPTIONS=&quot;--dir $KBUILD_EXTMOD $COCCIINCLUDE&quot;
     fi
<span class="p_add">+</span>
<span class="p_add">+    if [ -z &quot;$J&quot; ]; then</span>
<span class="p_add">+        NPROC=$(getconf _NPROCESSORS_ONLN)</span>
<span class="p_add">+    else</span>
<span class="p_add">+        NPROC=&quot;$J&quot;</span>
<span class="p_add">+    fi</span>
 fi
 
 if [ &quot;$KBUILD_EXTMOD&quot; != &quot;&quot; ] ; then
<span class="p_header">diff --git a/scripts/package/Makefile b/scripts/package/Makefile</span>
<span class="p_header">index 73f9f3192b9f..34de8b953ecf 100644</span>
<span class="p_header">--- a/scripts/package/Makefile</span>
<span class="p_header">+++ b/scripts/package/Makefile</span>
<span class="p_chunk">@@ -39,10 +39,9 @@</span> <span class="p_context"> if test &quot;$(objtree)&quot; != &quot;$(srctree)&quot;; then \</span>
 	false; \
 fi ; \
 $(srctree)/scripts/setlocalversion --save-scmversion; \
<span class="p_del">-ln -sf $(srctree) $(2); \</span>
 tar -cz $(RCS_TAR_IGNORE) -f $(2).tar.gz \
<span class="p_del">-	$(addprefix $(2)/,$(TAR_CONTENT) $(3)); \</span>
<span class="p_del">-rm -f $(2) $(objtree)/.scmversion</span>
<span class="p_add">+	--transform &#39;s:^:$(2)/:S&#39; $(TAR_CONTENT) $(3); \</span>
<span class="p_add">+rm -f $(objtree)/.scmversion</span>
 
 # rpm-pkg
 # ---------------------------------------------------------------------------
<span class="p_chunk">@@ -50,7 +49,7 @@</span> <span class="p_context"> rpm-pkg rpm: FORCE</span>
 	$(MAKE) clean
 	$(CONFIG_SHELL) $(MKSPEC) &gt;$(objtree)/kernel.spec
 	$(call cmd,src_tar,$(KERNELPATH),kernel.spec)
<span class="p_del">-	rpmbuild $(RPMOPTS) --target $(UTS_MACHINE) -ta $(KERNELPATH).tar.gz</span>
<span class="p_add">+	+rpmbuild $(RPMOPTS) --target $(UTS_MACHINE) -ta $(KERNELPATH).tar.gz</span>
 	rm $(KERNELPATH).tar.gz kernel.spec
 
 # binrpm-pkg
<span class="p_chunk">@@ -58,7 +57,7 @@</span> <span class="p_context"> rpm-pkg rpm: FORCE</span>
 binrpm-pkg: FORCE
 	$(MAKE) KBUILD_SRC=
 	$(CONFIG_SHELL) $(MKSPEC) prebuilt &gt; $(objtree)/binkernel.spec
<span class="p_del">-	rpmbuild $(RPMOPTS) --define &quot;_builddir $(objtree)&quot; --target \</span>
<span class="p_add">+	+rpmbuild $(RPMOPTS) --define &quot;_builddir $(objtree)&quot; --target \</span>
 		$(UTS_MACHINE) -bb $(objtree)/binkernel.spec
 	rm binkernel.spec
 
<span class="p_header">diff --git a/security/apparmor/policy.c b/security/apparmor/policy.c</span>
<span class="p_header">index 4243b0c3f0e4..586b249d3b46 100644</span>
<span class="p_header">--- a/security/apparmor/policy.c</span>
<span class="p_header">+++ b/security/apparmor/policy.c</span>
<span class="p_chunk">@@ -502,7 +502,7 @@</span> <span class="p_context"> struct aa_profile *aa_new_null_profile(struct aa_profile *parent, bool hat,</span>
 {
 	struct aa_profile *p, *profile;
 	const char *bname;
<span class="p_del">-	char *name;</span>
<span class="p_add">+	char *name = NULL;</span>
 
 	AA_BUG(!parent);
 
<span class="p_chunk">@@ -562,6 +562,7 @@</span> <span class="p_context"> struct aa_profile *aa_new_null_profile(struct aa_profile *parent, bool hat,</span>
 	return profile;
 
 fail:
<span class="p_add">+	kfree(name);</span>
 	aa_free_profile(profile);
 	return NULL;
 }
<span class="p_header">diff --git a/security/keys/keyctl.c b/security/keys/keyctl.c</span>
<span class="p_header">index 76d22f726ae4..1ffe60bb2845 100644</span>
<span class="p_header">--- a/security/keys/keyctl.c</span>
<span class="p_header">+++ b/security/keys/keyctl.c</span>
<span class="p_chunk">@@ -1588,9 +1588,8 @@</span> <span class="p_context"> long keyctl_session_to_parent(void)</span>
  * The caller must have Setattr permission to change keyring restrictions.
  *
  * The requested type name may be a NULL pointer to reject all attempts
<span class="p_del">- * to link to the keyring. If _type is non-NULL, _restriction can be</span>
<span class="p_del">- * NULL or a pointer to a string describing the restriction. If _type is</span>
<span class="p_del">- * NULL, _restriction must also be NULL.</span>
<span class="p_add">+ * to link to the keyring.  In this case, _restriction must also be NULL.</span>
<span class="p_add">+ * Otherwise, both _type and _restriction must be non-NULL.</span>
  *
  * Returns 0 if successful.
  */
<span class="p_chunk">@@ -1598,7 +1597,6 @@</span> <span class="p_context"> long keyctl_restrict_keyring(key_serial_t id, const char __user *_type,</span>
 			     const char __user *_restriction)
 {
 	key_ref_t key_ref;
<span class="p_del">-	bool link_reject = !_type;</span>
 	char type[32];
 	char *restriction = NULL;
 	long ret;
<span class="p_chunk">@@ -1607,31 +1605,29 @@</span> <span class="p_context"> long keyctl_restrict_keyring(key_serial_t id, const char __user *_type,</span>
 	if (IS_ERR(key_ref))
 		return PTR_ERR(key_ref);
 
<span class="p_add">+	ret = -EINVAL;</span>
 	if (_type) {
<span class="p_del">-		ret = key_get_type_from_user(type, _type, sizeof(type));</span>
<span class="p_del">-		if (ret &lt; 0)</span>
<span class="p_add">+		if (!_restriction)</span>
 			goto error;
<span class="p_del">-	}</span>
 
<span class="p_del">-	if (_restriction) {</span>
<span class="p_del">-		if (!_type) {</span>
<span class="p_del">-			ret = -EINVAL;</span>
<span class="p_add">+		ret = key_get_type_from_user(type, _type, sizeof(type));</span>
<span class="p_add">+		if (ret &lt; 0)</span>
 			goto error;
<span class="p_del">-		}</span>
 
 		restriction = strndup_user(_restriction, PAGE_SIZE);
 		if (IS_ERR(restriction)) {
 			ret = PTR_ERR(restriction);
 			goto error;
 		}
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (_restriction)</span>
<span class="p_add">+			goto error;</span>
 	}
 
<span class="p_del">-	ret = keyring_restrict(key_ref, link_reject ? NULL : type, restriction);</span>
<span class="p_add">+	ret = keyring_restrict(key_ref, _type ? type : NULL, restriction);</span>
 	kfree(restriction);
<span class="p_del">-</span>
 error:
 	key_ref_put(key_ref);
<span class="p_del">-</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/security/keys/request_key.c b/security/keys/request_key.c</span>
<span class="p_header">index e8036cd0ad54..7dc741382154 100644</span>
<span class="p_header">--- a/security/keys/request_key.c</span>
<span class="p_header">+++ b/security/keys/request_key.c</span>
<span class="p_chunk">@@ -251,11 +251,12 @@</span> <span class="p_context"> static int construct_key(struct key *key, const void *callout_info,</span>
  * The keyring selected is returned with an extra reference upon it which the
  * caller must release.
  */
<span class="p_del">-static void construct_get_dest_keyring(struct key **_dest_keyring)</span>
<span class="p_add">+static int construct_get_dest_keyring(struct key **_dest_keyring)</span>
 {
 	struct request_key_auth *rka;
 	const struct cred *cred = current_cred();
 	struct key *dest_keyring = *_dest_keyring, *authkey;
<span class="p_add">+	int ret;</span>
 
 	kenter(&quot;%p&quot;, dest_keyring);
 
<span class="p_chunk">@@ -264,6 +265,8 @@</span> <span class="p_context"> static void construct_get_dest_keyring(struct key **_dest_keyring)</span>
 		/* the caller supplied one */
 		key_get(dest_keyring);
 	} else {
<span class="p_add">+		bool do_perm_check = true;</span>
<span class="p_add">+</span>
 		/* use a default keyring; falling through the cases until we
 		 * find one that we actually have */
 		switch (cred-&gt;jit_keyring) {
<span class="p_chunk">@@ -278,8 +281,10 @@</span> <span class="p_context"> static void construct_get_dest_keyring(struct key **_dest_keyring)</span>
 					dest_keyring =
 						key_get(rka-&gt;dest_keyring);
 				up_read(&amp;authkey-&gt;sem);
<span class="p_del">-				if (dest_keyring)</span>
<span class="p_add">+				if (dest_keyring) {</span>
<span class="p_add">+					do_perm_check = false;</span>
 					break;
<span class="p_add">+				}</span>
 			}
 
 		case KEY_REQKEY_DEFL_THREAD_KEYRING:
<span class="p_chunk">@@ -314,11 +319,29 @@</span> <span class="p_context"> static void construct_get_dest_keyring(struct key **_dest_keyring)</span>
 		default:
 			BUG();
 		}
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Require Write permission on the keyring.  This is essential</span>
<span class="p_add">+		 * because the default keyring may be the session keyring, and</span>
<span class="p_add">+		 * joining a keyring only requires Search permission.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * However, this check is skipped for the &quot;requestor keyring&quot; so</span>
<span class="p_add">+		 * that /sbin/request-key can itself use request_key() to add</span>
<span class="p_add">+		 * keys to the original requestor&#39;s destination keyring.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (dest_keyring &amp;&amp; do_perm_check) {</span>
<span class="p_add">+			ret = key_permission(make_key_ref(dest_keyring, 1),</span>
<span class="p_add">+					     KEY_NEED_WRITE);</span>
<span class="p_add">+			if (ret) {</span>
<span class="p_add">+				key_put(dest_keyring);</span>
<span class="p_add">+				return ret;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 	}
 
 	*_dest_keyring = dest_keyring;
 	kleave(&quot; [dk %d]&quot;, key_serial(dest_keyring));
<span class="p_del">-	return;</span>
<span class="p_add">+	return 0;</span>
 }
 
 /*
<span class="p_chunk">@@ -444,11 +467,15 @@</span> <span class="p_context"> static struct key *construct_key_and_link(struct keyring_search_context *ctx,</span>
 	if (ctx-&gt;index_key.type == &amp;key_type_keyring)
 		return ERR_PTR(-EPERM);
 
<span class="p_del">-	user = key_user_lookup(current_fsuid());</span>
<span class="p_del">-	if (!user)</span>
<span class="p_del">-		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+	ret = construct_get_dest_keyring(&amp;dest_keyring);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto error;</span>
 
<span class="p_del">-	construct_get_dest_keyring(&amp;dest_keyring);</span>
<span class="p_add">+	user = key_user_lookup(current_fsuid());</span>
<span class="p_add">+	if (!user) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto error_put_dest_keyring;</span>
<span class="p_add">+	}</span>
 
 	ret = construct_alloc_key(ctx, dest_keyring, flags, user, &amp;key);
 	key_user_put(user);
<span class="p_chunk">@@ -463,7 +490,7 @@</span> <span class="p_context"> static struct key *construct_key_and_link(struct keyring_search_context *ctx,</span>
 	} else if (ret == -EINPROGRESS) {
 		ret = 0;
 	} else {
<span class="p_del">-		goto couldnt_alloc_key;</span>
<span class="p_add">+		goto error_put_dest_keyring;</span>
 	}
 
 	key_put(dest_keyring);
<span class="p_chunk">@@ -473,8 +500,9 @@</span> <span class="p_context"> static struct key *construct_key_and_link(struct keyring_search_context *ctx,</span>
 construction_failed:
 	key_negate_and_link(key, key_negative_timeout, NULL, NULL);
 	key_put(key);
<span class="p_del">-couldnt_alloc_key:</span>
<span class="p_add">+error_put_dest_keyring:</span>
 	key_put(dest_keyring);
<span class="p_add">+error:</span>
 	kleave(&quot; = %d&quot;, ret);
 	return ERR_PTR(ret);
 }
<span class="p_header">diff --git a/sound/core/pcm.c b/sound/core/pcm.c</span>
<span class="p_header">index 7eadb7fd8074..7fea724d093a 100644</span>
<span class="p_header">--- a/sound/core/pcm.c</span>
<span class="p_header">+++ b/sound/core/pcm.c</span>
<span class="p_chunk">@@ -153,7 +153,9 @@</span> <span class="p_context"> static int snd_pcm_control_ioctl(struct snd_card *card,</span>
 				err = -ENXIO;
 				goto _error;
 			}
<span class="p_add">+			mutex_lock(&amp;pcm-&gt;open_mutex);</span>
 			err = snd_pcm_info_user(substream, info);
<span class="p_add">+			mutex_unlock(&amp;pcm-&gt;open_mutex);</span>
 		_error:
 			mutex_unlock(&amp;register_mutex);
 			return err;
<span class="p_header">diff --git a/sound/core/seq/seq_timer.c b/sound/core/seq/seq_timer.c</span>
<span class="p_header">index 37d9cfbc29f9..b80985fbc334 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_timer.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_timer.c</span>
<span class="p_chunk">@@ -355,7 +355,7 @@</span> <span class="p_context"> static int initialize_timer(struct snd_seq_timer *tmr)</span>
 	unsigned long freq;
 
 	t = tmr-&gt;timeri-&gt;timer;
<span class="p_del">-	if (snd_BUG_ON(!t))</span>
<span class="p_add">+	if (!t)</span>
 		return -EINVAL;
 
 	freq = tmr-&gt;preferred_resolution;
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 7c39114d124f..b076386c8952 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -330,6 +330,7 @@</span> <span class="p_context"> static void alc_fill_eapd_coef(struct hda_codec *codec)</span>
 	case 0x10ec0236:
 	case 0x10ec0255:
 	case 0x10ec0256:
<span class="p_add">+	case 0x10ec0257:</span>
 	case 0x10ec0282:
 	case 0x10ec0283:
 	case 0x10ec0286:
<span class="p_chunk">@@ -2749,6 +2750,7 @@</span> <span class="p_context"> enum {</span>
 	ALC269_TYPE_ALC298,
 	ALC269_TYPE_ALC255,
 	ALC269_TYPE_ALC256,
<span class="p_add">+	ALC269_TYPE_ALC257,</span>
 	ALC269_TYPE_ALC215,
 	ALC269_TYPE_ALC225,
 	ALC269_TYPE_ALC294,
<span class="p_chunk">@@ -2782,6 +2784,7 @@</span> <span class="p_context"> static int alc269_parse_auto_config(struct hda_codec *codec)</span>
 	case ALC269_TYPE_ALC298:
 	case ALC269_TYPE_ALC255:
 	case ALC269_TYPE_ALC256:
<span class="p_add">+	case ALC269_TYPE_ALC257:</span>
 	case ALC269_TYPE_ALC215:
 	case ALC269_TYPE_ALC225:
 	case ALC269_TYPE_ALC294:
<span class="p_chunk">@@ -6839,6 +6842,10 @@</span> <span class="p_context"> static int patch_alc269(struct hda_codec *codec)</span>
 		spec-&gt;gen.mixer_nid = 0; /* ALC256 does not have any loopback mixer path */
 		alc_update_coef_idx(codec, 0x36, 1 &lt;&lt; 13, 1 &lt;&lt; 5); /* Switch pcbeep path to Line in path*/
 		break;
<span class="p_add">+	case 0x10ec0257:</span>
<span class="p_add">+		spec-&gt;codec_variant = ALC269_TYPE_ALC257;</span>
<span class="p_add">+		spec-&gt;gen.mixer_nid = 0;</span>
<span class="p_add">+		break;</span>
 	case 0x10ec0215:
 	case 0x10ec0285:
 	case 0x10ec0289:
<span class="p_chunk">@@ -7886,6 +7893,7 @@</span> <span class="p_context"> static const struct hda_device_id snd_hda_id_realtek[] = {</span>
 	HDA_CODEC_ENTRY(0x10ec0236, &quot;ALC236&quot;, patch_alc269),
 	HDA_CODEC_ENTRY(0x10ec0255, &quot;ALC255&quot;, patch_alc269),
 	HDA_CODEC_ENTRY(0x10ec0256, &quot;ALC256&quot;, patch_alc269),
<span class="p_add">+	HDA_CODEC_ENTRY(0x10ec0257, &quot;ALC257&quot;, patch_alc269),</span>
 	HDA_CODEC_ENTRY(0x10ec0260, &quot;ALC260&quot;, patch_alc260),
 	HDA_CODEC_ENTRY(0x10ec0262, &quot;ALC262&quot;, patch_alc262),
 	HDA_CODEC_ENTRY(0x10ec0267, &quot;ALC267&quot;, patch_alc268),
<span class="p_header">diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c</span>
<span class="p_header">index 2b835cca41b1..4fde4f8d4444 100644</span>
<span class="p_header">--- a/sound/usb/mixer.c</span>
<span class="p_header">+++ b/sound/usb/mixer.c</span>
<span class="p_chunk">@@ -204,6 +204,10 @@</span> <span class="p_context"> static int snd_usb_copy_string_desc(struct mixer_build *state,</span>
 				    int index, char *buf, int maxlen)
 {
 	int len = usb_string(state-&gt;chip-&gt;dev, index, buf, maxlen - 1);
<span class="p_add">+</span>
<span class="p_add">+	if (len &lt; 0)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	buf[len] = 0;
 	return len;
 }
<span class="p_chunk">@@ -2174,13 +2178,14 @@</span> <span class="p_context"> static int parse_audio_selector_unit(struct mixer_build *state, int unitid,</span>
 	if (len)
 		;
 	else if (nameid)
<span class="p_del">-		snd_usb_copy_string_desc(state, nameid, kctl-&gt;id.name,</span>
<span class="p_add">+		len = snd_usb_copy_string_desc(state, nameid, kctl-&gt;id.name,</span>
 					 sizeof(kctl-&gt;id.name));
<span class="p_del">-	else {</span>
<span class="p_add">+	else</span>
 		len = get_term_name(state, &amp;state-&gt;oterm,
 				    kctl-&gt;id.name, sizeof(kctl-&gt;id.name), 0);
<span class="p_del">-		if (!len)</span>
<span class="p_del">-			strlcpy(kctl-&gt;id.name, &quot;USB&quot;, sizeof(kctl-&gt;id.name));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!len) {</span>
<span class="p_add">+		strlcpy(kctl-&gt;id.name, &quot;USB&quot;, sizeof(kctl-&gt;id.name));</span>
 
 		if (desc-&gt;bDescriptorSubtype == UAC2_CLOCK_SELECTOR)
 			append_ctl_name(kctl, &quot; Clock Source&quot;);
<span class="p_header">diff --git a/tools/hv/hv_kvp_daemon.c b/tools/hv/hv_kvp_daemon.c</span>
<span class="p_header">index eaa3bec273c8..4c99c57736ce 100644</span>
<span class="p_header">--- a/tools/hv/hv_kvp_daemon.c</span>
<span class="p_header">+++ b/tools/hv/hv_kvp_daemon.c</span>
<span class="p_chunk">@@ -193,11 +193,14 @@</span> <span class="p_context"> static void kvp_update_mem_state(int pool)</span>
 	for (;;) {
 		readp = &amp;record[records_read];
 		records_read += fread(readp, sizeof(struct kvp_record),
<span class="p_del">-					ENTRIES_PER_BLOCK * num_blocks,</span>
<span class="p_del">-					filep);</span>
<span class="p_add">+				ENTRIES_PER_BLOCK * num_blocks - records_read,</span>
<span class="p_add">+				filep);</span>
 
 		if (ferror(filep)) {
<span class="p_del">-			syslog(LOG_ERR, &quot;Failed to read file, pool: %d&quot;, pool);</span>
<span class="p_add">+			syslog(LOG_ERR,</span>
<span class="p_add">+				&quot;Failed to read file, pool: %d; error: %d %s&quot;,</span>
<span class="p_add">+				 pool, errno, strerror(errno));</span>
<span class="p_add">+			kvp_release_lock(pool);</span>
 			exit(EXIT_FAILURE);
 		}
 
<span class="p_chunk">@@ -210,6 +213,7 @@</span> <span class="p_context"> static void kvp_update_mem_state(int pool)</span>
 
 			if (record == NULL) {
 				syslog(LOG_ERR, &quot;malloc failed&quot;);
<span class="p_add">+				kvp_release_lock(pool);</span>
 				exit(EXIT_FAILURE);
 			}
 			continue;
<span class="p_chunk">@@ -224,15 +228,11 @@</span> <span class="p_context"> static void kvp_update_mem_state(int pool)</span>
 	fclose(filep);
 	kvp_release_lock(pool);
 }
<span class="p_add">+</span>
 static int kvp_file_init(void)
 {
 	int  fd;
<span class="p_del">-	FILE *filep;</span>
<span class="p_del">-	size_t records_read;</span>
 	char *fname;
<span class="p_del">-	struct kvp_record *record;</span>
<span class="p_del">-	struct kvp_record *readp;</span>
<span class="p_del">-	int num_blocks;</span>
 	int i;
 	int alloc_unit = sizeof(struct kvp_record) * ENTRIES_PER_BLOCK;
 
<span class="p_chunk">@@ -246,61 +246,19 @@</span> <span class="p_context"> static int kvp_file_init(void)</span>
 
 	for (i = 0; i &lt; KVP_POOL_COUNT; i++) {
 		fname = kvp_file_info[i].fname;
<span class="p_del">-		records_read = 0;</span>
<span class="p_del">-		num_blocks = 1;</span>
 		sprintf(fname, &quot;%s/.kvp_pool_%d&quot;, KVP_CONFIG_LOC, i);
 		fd = open(fname, O_RDWR | O_CREAT | O_CLOEXEC, 0644 /* rw-r--r-- */);
 
 		if (fd == -1)
 			return 1;
 
<span class="p_del">-</span>
<span class="p_del">-		filep = fopen(fname, &quot;re&quot;);</span>
<span class="p_del">-		if (!filep) {</span>
<span class="p_del">-			close(fd);</span>
<span class="p_del">-			return 1;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		record = malloc(alloc_unit * num_blocks);</span>
<span class="p_del">-		if (record == NULL) {</span>
<span class="p_del">-			fclose(filep);</span>
<span class="p_del">-			close(fd);</span>
<span class="p_del">-			return 1;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		for (;;) {</span>
<span class="p_del">-			readp = &amp;record[records_read];</span>
<span class="p_del">-			records_read += fread(readp, sizeof(struct kvp_record),</span>
<span class="p_del">-					ENTRIES_PER_BLOCK,</span>
<span class="p_del">-					filep);</span>
<span class="p_del">-</span>
<span class="p_del">-			if (ferror(filep)) {</span>
<span class="p_del">-				syslog(LOG_ERR, &quot;Failed to read file, pool: %d&quot;,</span>
<span class="p_del">-				       i);</span>
<span class="p_del">-				exit(EXIT_FAILURE);</span>
<span class="p_del">-			}</span>
<span class="p_del">-</span>
<span class="p_del">-			if (!feof(filep)) {</span>
<span class="p_del">-				/*</span>
<span class="p_del">-				 * We have more data to read.</span>
<span class="p_del">-				 */</span>
<span class="p_del">-				num_blocks++;</span>
<span class="p_del">-				record = realloc(record, alloc_unit *</span>
<span class="p_del">-						num_blocks);</span>
<span class="p_del">-				if (record == NULL) {</span>
<span class="p_del">-					fclose(filep);</span>
<span class="p_del">-					close(fd);</span>
<span class="p_del">-					return 1;</span>
<span class="p_del">-				}</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
 		kvp_file_info[i].fd = fd;
<span class="p_del">-		kvp_file_info[i].num_blocks = num_blocks;</span>
<span class="p_del">-		kvp_file_info[i].records = record;</span>
<span class="p_del">-		kvp_file_info[i].num_records = records_read;</span>
<span class="p_del">-		fclose(filep);</span>
<span class="p_del">-</span>
<span class="p_add">+		kvp_file_info[i].num_blocks = 1;</span>
<span class="p_add">+		kvp_file_info[i].records = malloc(alloc_unit);</span>
<span class="p_add">+		if (kvp_file_info[i].records == NULL)</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+		kvp_file_info[i].num_records = 0;</span>
<span class="p_add">+		kvp_update_mem_state(i);</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/tools/testing/selftests/x86/mpx-hw.h b/tools/testing/selftests/x86/mpx-hw.h</span>
<span class="p_header">index 3f0093911f03..d1b61ab870f8 100644</span>
<span class="p_header">--- a/tools/testing/selftests/x86/mpx-hw.h</span>
<span class="p_header">+++ b/tools/testing/selftests/x86/mpx-hw.h</span>
<span class="p_chunk">@@ -52,14 +52,14 @@</span> <span class="p_context"></span>
 struct mpx_bd_entry {
 	union {
 		char x[MPX_BOUNDS_DIR_ENTRY_SIZE_BYTES];
<span class="p_del">-		void *contents[1];</span>
<span class="p_add">+		void *contents[0];</span>
 	};
 } __attribute__((packed));
 
 struct mpx_bt_entry {
 	union {
 		char x[MPX_BOUNDS_TABLE_ENTRY_SIZE_BYTES];
<span class="p_del">-		unsigned long contents[1];</span>
<span class="p_add">+		unsigned long contents[0];</span>
 	};
 } __attribute__((packed));
 
<span class="p_header">diff --git a/virt/kvm/arm/hyp/vgic-v2-sr.c b/virt/kvm/arm/hyp/vgic-v2-sr.c</span>
<span class="p_header">index a3f18d362366..d7fd46fe9efb 100644</span>
<span class="p_header">--- a/virt/kvm/arm/hyp/vgic-v2-sr.c</span>
<span class="p_header">+++ b/virt/kvm/arm/hyp/vgic-v2-sr.c</span>
<span class="p_chunk">@@ -34,11 +34,7 @@</span> <span class="p_context"> static void __hyp_text save_elrsr(struct kvm_vcpu *vcpu, void __iomem *base)</span>
 	else
 		elrsr1 = 0;
 
<span class="p_del">-#ifdef CONFIG_CPU_BIG_ENDIAN</span>
<span class="p_del">-	cpu_if-&gt;vgic_elrsr = ((u64)elrsr0 &lt;&lt; 32) | elrsr1;</span>
<span class="p_del">-#else</span>
 	cpu_if-&gt;vgic_elrsr = ((u64)elrsr1 &lt;&lt; 32) | elrsr0;
<span class="p_del">-#endif</span>
 }
 
 static void __hyp_text save_lrs(struct kvm_vcpu *vcpu, void __iomem *base)
<span class="p_header">diff --git a/virt/kvm/arm/vgic/vgic-irqfd.c b/virt/kvm/arm/vgic/vgic-irqfd.c</span>
<span class="p_header">index b7baf581611a..99e026d2dade 100644</span>
<span class="p_header">--- a/virt/kvm/arm/vgic/vgic-irqfd.c</span>
<span class="p_header">+++ b/virt/kvm/arm/vgic/vgic-irqfd.c</span>
<span class="p_chunk">@@ -112,8 +112,7 @@</span> <span class="p_context"> int kvm_vgic_setup_default_irq_routing(struct kvm *kvm)</span>
 	u32 nr = dist-&gt;nr_spis;
 	int i, ret;
 
<span class="p_del">-	entries = kcalloc(nr, sizeof(struct kvm_kernel_irq_routing_entry),</span>
<span class="p_del">-			  GFP_KERNEL);</span>
<span class="p_add">+	entries = kcalloc(nr, sizeof(*entries), GFP_KERNEL);</span>
 	if (!entries)
 		return -ENOMEM;
 
<span class="p_header">diff --git a/virt/kvm/arm/vgic/vgic-its.c b/virt/kvm/arm/vgic/vgic-its.c</span>
<span class="p_header">index 547f12dc4d54..3108e07526af 100644</span>
<span class="p_header">--- a/virt/kvm/arm/vgic/vgic-its.c</span>
<span class="p_header">+++ b/virt/kvm/arm/vgic/vgic-its.c</span>
<span class="p_chunk">@@ -775,6 +775,8 @@</span> <span class="p_context"> static int vgic_its_alloc_collection(struct vgic_its *its,</span>
 		return E_ITS_MAPC_COLLECTION_OOR;
 
 	collection = kzalloc(sizeof(*collection), GFP_KERNEL);
<span class="p_add">+	if (!collection)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
 	collection-&gt;collection_id = coll_id;
 	collection-&gt;target_addr = COLLECTION_NOT_MAPPED;
<span class="p_header">diff --git a/virt/kvm/arm/vgic/vgic-v3.c b/virt/kvm/arm/vgic/vgic-v3.c</span>
<span class="p_header">index 96ea597db0e7..502f2100e7bf 100644</span>
<span class="p_header">--- a/virt/kvm/arm/vgic/vgic-v3.c</span>
<span class="p_header">+++ b/virt/kvm/arm/vgic/vgic-v3.c</span>
<span class="p_chunk">@@ -324,13 +324,13 @@</span> <span class="p_context"> int vgic_v3_save_pending_tables(struct kvm *kvm)</span>
 	int last_byte_offset = -1;
 	struct vgic_irq *irq;
 	int ret;
<span class="p_add">+	u8 val;</span>
 
 	list_for_each_entry(irq, &amp;dist-&gt;lpi_list_head, lpi_list) {
 		int byte_offset, bit_nr;
 		struct kvm_vcpu *vcpu;
 		gpa_t pendbase, ptr;
 		bool stored;
<span class="p_del">-		u8 val;</span>
 
 		vcpu = irq-&gt;target_vcpu;
 		if (!vcpu)
<span class="p_header">diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c</span>
<span class="p_header">index 9deb5a245b83..484e8820c382 100644</span>
<span class="p_header">--- a/virt/kvm/kvm_main.c</span>
<span class="p_header">+++ b/virt/kvm/kvm_main.c</span>
<span class="p_chunk">@@ -136,6 +136,11 @@</span> <span class="p_context"> static void kvm_uevent_notify_change(unsigned int type, struct kvm *kvm);</span>
 static unsigned long long kvm_createvm_count;
 static unsigned long long kvm_active_vms;
 
<span class="p_add">+__weak void kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,</span>
<span class="p_add">+		unsigned long start, unsigned long end)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 bool kvm_is_reserved_pfn(kvm_pfn_t pfn)
 {
 	if (pfn_valid(pfn))
<span class="p_chunk">@@ -361,6 +366,9 @@</span> <span class="p_context"> static void kvm_mmu_notifier_invalidate_range_start(struct mmu_notifier *mn,</span>
 		kvm_flush_remote_tlbs(kvm);
 
 	spin_unlock(&amp;kvm-&gt;mmu_lock);
<span class="p_add">+</span>
<span class="p_add">+	kvm_arch_mmu_notifier_invalidate_range(kvm, start, end);</span>
<span class="p_add">+</span>
 	srcu_read_unlock(&amp;kvm-&gt;srcu, idx);
 }
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



