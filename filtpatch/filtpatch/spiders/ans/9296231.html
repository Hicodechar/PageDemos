
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.16.37 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.16.37</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 23, 2016, 7:19 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1471979951.13300.169.camel@decadent.org.uk&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9296231/mbox/"
   >mbox</a>
|
   <a href="/patch/9296231/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9296231/">/patch/9296231/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	67FA0607D0 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 23 Aug 2016 19:20:15 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 34B38212D8
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 23 Aug 2016 19:20:13 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 24AC728CDC; Tue, 23 Aug 2016 19:20:13 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id EB195212D8
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 23 Aug 2016 19:19:52 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1754973AbcHWTTi (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 23 Aug 2016 15:19:38 -0400
Received: from shadbolt.e.decadent.org.uk ([88.96.1.126]:39185 &quot;EHLO
	shadbolt.e.decadent.org.uk&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S1754897AbcHWTTX (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 23 Aug 2016 15:19:23 -0400
Received: from [2a02:8011:400e:2:6f00:88c8:c921:d332] (helo=deadeye)
	by shadbolt.decadent.org.uk with esmtps
	(TLS1.2:ECDHE_RSA_AES_256_GCM_SHA384:256) (Exim 4.84_2)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1bcHE8-0003x7-AS; Tue, 23 Aug 2016 20:19:12 +0100
Received: from ben by deadeye with local (Exim 4.87)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1bcHE7-0007SF-Fr; Tue, 23 Aug 2016 20:19:11 +0100
Message-ID: &lt;1471979951.13300.169.camel@decadent.org.uk&gt;
Subject: Linux 3.16.37
From: Ben Hutchings &lt;ben@decadent.org.uk&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, Jiri Slaby &lt;jslaby@suse.cz&gt;,
	stable@vger.kernel.org
Cc: lwn@lwn.net
Date: Tue, 23 Aug 2016 20:19:11 +0100
Content-Type: multipart/signed; micalg=&quot;pgp-sha512&quot;;
	protocol=&quot;application/pgp-signature&quot;;
	boundary=&quot;=-zpamz7b23oupEDR0jxWA&quot;
X-Mailer: Evolution 3.20.4-1 
Mime-Version: 1.0
X-SA-Exim-Connect-IP: 2a02:8011:400e:2:6f00:88c8:c921:d332
X-SA-Exim-Mail-From: ben@decadent.org.uk
X-SA-Exim-Scanned: No (on shadbolt.decadent.org.uk);
	SAEximRunCond expanded to false
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a> - Aug. 23, 2016, 7:19 p.m.</div>
<pre class="content">
I&#39;m announcing the release of the 3.16.37 kernel.

All users of the 3.16 kernel series should upgrade.

The updated 3.16.y git tree can be found at:
        https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git linux-3.16.y
and can be browsed at the normal kernel.org git web browser:
        https://git.kernel.org/?p=linux/kernel/git/stable/linux-stable.git

The diff from 3.16.36 is attached to this message.

Ben.

------------

 .../ABI/testing/sysfs-bus-iio-proximity-as3935     |   2 +-
 Documentation/scsi/scsi_eh.txt                     |   8 +-
 Documentation/serial/driver                        |   2 +-
 Makefile                                           |   9 +-
 arch/alpha/kernel/pci-sysfs.c                      |   4 +-
 arch/arc/Makefile                                  |   2 -
 arch/arc/kernel/stacktrace.c                       |   2 +-
 arch/arm/boot/dts/Makefile                         |   2 +
 arch/arm/boot/dts/exynos4210-trats.dts             |   2 +
 arch/arm/include/asm/pgtable-2level.h              |   1 +
 arch/arm/include/asm/pgtable-3level.h              |   8 +-
 arch/arm/include/asm/pgtable.h                     |   1 -
 arch/arm/kernel/ptrace.c                           |   2 +-
 arch/arm/kvm/arm.c                                 |   1 +
 arch/arm/kvm/mmu.c                                 |  17 +-
 arch/arm/mach-omap2/gpmc.c                         |   2 +-
 arch/arm/mach-omap2/omap_hwmod.c                   |  12 +-
 arch/arm64/include/asm/elf.h                       |   4 +-
 arch/arm64/include/asm/pgtable-hwdef.h             |   1 -
 arch/arm64/include/asm/pgtable.h                   |   4 +-
 arch/arm64/kernel/setup.c                          |  11 +-
 arch/arm64/mm/flush.c                              |   4 -
 arch/mips/ath79/early_printk.c                     |   6 +-
 arch/mips/include/asm/cacheflush.h                 |  38 +-
 arch/mips/include/asm/kvm_host.h                   |   2 +-
 arch/mips/include/asm/msa.h                        |   8 +-
 arch/mips/include/asm/pgtable.h                    |  45 +-
 arch/mips/include/uapi/asm/siginfo.h               |  18 +-
 arch/mips/kernel/bmips_vec.S                       |   9 +-
 arch/mips/kernel/process.c                         |   2 +-
 arch/mips/kernel/traps.c                           |   2 +-
 arch/mips/kvm/kvm_mips_emul.c                      |  89 ++--
 arch/mips/kvm/kvm_trap_emul.c                      |   2 +-
 arch/mips/math-emu/cp1emu.c                        |   8 +-
 arch/mips/mm/cache.c                               |  12 +
 arch/parisc/kernel/unaligned.c                     |  10 +-
 arch/powerpc/Kconfig                               |   2 +-
 arch/powerpc/include/asm/reg.h                     |   6 +-
 arch/powerpc/kernel/exceptions-64s.S               |  16 +-
 arch/powerpc/kernel/process.c                      |  10 +
 arch/powerpc/kernel/tm.S                           |  61 ++-
 arch/powerpc/kvm/book3s_hv_rmhandlers.S            | 462 +++++++++++----------
 arch/powerpc/mm/hash_utils_64.c                    |  29 +-
 arch/powerpc/platforms/pseries/eeh_pseries.c       |  51 ++-
 arch/powerpc/platforms/pseries/iommu.c             |  24 +-
 arch/s390/include/asm/switch_to.h                  |   2 +-
 arch/s390/mm/vmem.c                                |   2 +-
 arch/x86/boot/Makefile                             |   3 +
 arch/x86/kernel/amd_nb.c                           |   4 +-
 arch/x86/kernel/kprobes/core.c                     |  12 +
 arch/x86/kvm/x86.c                                 |   5 +
 arch/x86/pci/fixup.c                               |   7 +
 arch/x86/power/hibernate_64.c                      |  97 ++++-
 arch/x86/power/hibernate_asm_64.S                  |  55 ++-
 block/blk-mq.c                                     |   2 +-
 block/ioprio.c                                     |   2 +
 crypto/asymmetric_keys/Kconfig                     |   1 +
 drivers/acpi/acpi_processor.c                      |   9 -
 drivers/acpi/processor_throttling.c                |   9 +
 drivers/acpi/sysfs.c                               |   7 +-
 drivers/ata/libata-eh.c                            |   2 +-
 drivers/ata/sata_dwc_460ex.c                       |   4 +-
 drivers/base/isa.c                                 |   2 +-
 drivers/base/module.c                              |   8 +-
 drivers/base/power/main.c                          |   5 +-
 drivers/base/power/runtime.c                       |   9 +-
 drivers/base/regmap/regcache.c                     |   2 +-
 drivers/bluetooth/hci_vhci.c                       |  28 +-
 drivers/char/Kconfig                               |   1 -
 drivers/char/i8k.c                                 |  19 +-
 drivers/cpufreq/cpufreq_userspace.c                |  43 +-
 drivers/cpufreq/intel_pstate.c                     |   7 +-
 drivers/cpuidle/cpuidle.c                          |   4 +-
 drivers/crypto/caam/jr.c                           |   2 +-
 drivers/crypto/ccp/ccp-crypto-aes-xts.c            |  17 +-
 drivers/crypto/s5p-sss.c                           |  61 ++-
 drivers/crypto/ux500/hash/hash_core.c              |   4 +-
 drivers/edac/edac_mc.c                             |   2 +-
 drivers/gpio/gpio-bcm-kona.c                       |   4 +-
 drivers/gpu/drm/drm_fb_helper.c                    |   5 +-
 drivers/gpu/drm/gma500/mdfld_dsi_pkg_sender.c      |   2 +-
 drivers/gpu/drm/i915/i915_gem_context.c            |  14 +-
 drivers/gpu/drm/i915/intel_display.c               |  48 ++-
 drivers/gpu/drm/i915/intel_fbdev.c                 |   6 +-
 drivers/gpu/drm/i915/intel_pm.c                    |   2 +
 drivers/gpu/drm/nouveau/nouveau_fbcon.c            |   1 +
 drivers/gpu/drm/nouveau/nv04_fbcon.c               |   7 +-
 drivers/gpu/drm/nouveau/nv50_fbcon.c               |   6 +-
 drivers/gpu/drm/nouveau/nvc0_fbcon.c               |   6 +-
 drivers/gpu/drm/radeon/radeon_device.c             |  21 +
 drivers/hid/hid-elo.c                              |   2 +-
 drivers/hid/usbhid/hiddev.c                        |  10 +-
 drivers/iio/accel/kxsd9.c                          |   4 +-
 drivers/iio/adc/ad7266.c                           |   7 +-
 drivers/iio/industrialio-trigger.c                 |  23 +-
 drivers/iio/pressure/st_pressure_core.c            |  80 ++--
 drivers/iio/proximity/as3935.c                     |  17 +-
 drivers/infiniband/core/cma.c                      |   3 +-
 drivers/infiniband/core/iwpm_util.c                |   1 +
 drivers/infiniband/hw/cxgb3/cxio_hal.c             |   2 +-
 drivers/infiniband/hw/cxgb4/cm.c                   |  12 +-
 drivers/infiniband/hw/mlx4/ah.c                    |   2 +-
 drivers/infiniband/hw/mlx4/mad.c                   |  24 +-
 drivers/infiniband/hw/mlx4/main.c                  |   3 +
 drivers/infiniband/hw/mlx4/qp.c                    |   6 +-
 drivers/infiniband/hw/mlx5/main.c                  |   5 +-
 drivers/infiniband/hw/mlx5/qp.c                    |  21 +-
 drivers/infiniband/ulp/ipoib/ipoib.h               |   1 +
 drivers/infiniband/ulp/ipoib/ipoib_cm.c            |   4 +
 drivers/infiniband/ulp/ipoib/ipoib_main.c          |   7 +-
 drivers/infiniband/ulp/ipoib/ipoib_vlan.c          |   6 +
 drivers/input/joystick/xpad.c                      |   4 +
 drivers/input/misc/pwm-beeper.c                    |  70 +++-
 drivers/input/misc/uinput.c                        |   6 +
 drivers/input/mouse/elantech.c                     |   8 +-
 drivers/input/touchscreen/wacom_w8001.c            |   2 +-
 drivers/iommu/dmar.c                               |  47 ++-
 drivers/irqchip/irq-gic.c                          |   8 +
 drivers/mcb/mcb-parse.c                            |   2 +-
 drivers/media/pci/cx23885/cx23885-av.c             |   2 +-
 drivers/media/usb/uvc/uvc_v4l2.c                   |  39 +-
 drivers/mfd/lp8788-irq.c                           |   2 +-
 drivers/mfd/omap-usb-tll.c                         |  13 +-
 drivers/misc/mic/host/mic_virtio.c                 |   5 +
 drivers/mmc/card/block.c                           |   5 +-
 drivers/mmc/core/core.c                            |   4 +-
 drivers/mmc/core/mmc.c                             |   7 +
 drivers/mtd/ubi/eba.c                              |  42 +-
 drivers/mtd/ubi/fastmap.c                          |   1 +
 drivers/mtd/ubi/ubi.h                              |   2 +
 drivers/net/bonding/bond_3ad.c                     |  13 +-
 drivers/net/bonding/bond_alb.c                     |   7 +-
 drivers/net/bonding/bonding.h                      |   3 +
 drivers/net/can/at91_can.c                         |   5 +-
 drivers/net/can/c_can/c_can.c                      |  38 +-
 drivers/net/can/dev.c                              |   6 +
 drivers/net/ethernet/broadcom/bcmsysport.c         |   2 +-
 drivers/net/ethernet/broadcom/bgmac.c              |   2 +-
 drivers/net/ethernet/ibm/ehea/ehea_main.c          |   9 +-
 drivers/net/ethernet/intel/i40e/i40e_hmc.c         |   2 +-
 drivers/net/ethernet/mellanox/mlx4/en_netdev.c     |  18 +-
 drivers/net/ethernet/mellanox/mlx4/mcg.c           |   4 +-
 drivers/net/ethernet/mellanox/mlx5/core/cmd.c      | 123 +++---
 drivers/net/ethernet/mellanox/mlx5/core/qp.c       |   2 +-
 drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c     |   2 +-
 drivers/net/ethernet/sfc/ef10.c                    |  16 +
 drivers/net/phy/fixed.c                            |  22 +-
 drivers/net/tun.c                                  |   6 +-
 drivers/net/wireless/ath/ath5k/led.c               |   2 +-
 drivers/net/wireless/mac80211_hwsim.c              |   1 +
 drivers/net/wireless/rtlwifi/base.c                |   4 +-
 drivers/of/irq.c                                   |  19 +-
 drivers/pci/pci-sysfs.c                            |   7 +-
 drivers/pci/probe.c                                |   6 +-
 drivers/pinctrl/pinctrl-single.c                   |   3 +
 drivers/s390/char/sclp_ctl.c                       |  12 +-
 drivers/s390/net/qeth_l2_main.c                    |   1 +
 drivers/s390/net/qeth_l3_main.c                    |   1 +
 drivers/scsi/aacraid/commsup.c                     |  12 +-
 drivers/scsi/ipr.c                                 |   1 +
 drivers/scsi/scsi_devinfo.c                        |   1 +
 drivers/scsi/scsi_error.c                          |   4 +-
 drivers/scsi/scsi_lib.c                            |   7 +-
 drivers/scsi/scsi_scan.c                           |   1 +
 drivers/scsi/scsi_sysfs.c                          |   6 +-
 drivers/spi/spi-sun4i.c                            |  23 +-
 drivers/spi/spi-sun6i.c                            |  10 +-
 drivers/staging/iio/accel/sca3000_core.c           |   2 +-
 drivers/tty/n_tty.c                                |  17 +-
 drivers/tty/vt/vt.c                                |   5 +-
 drivers/usb/core/devio.c                           |   9 +-
 drivers/usb/core/hcd.c                             |  14 +-
 drivers/usb/core/quirks.c                          |  27 +-
 drivers/usb/dwc3/dwc3-exynos.c                     |  19 +-
 drivers/usb/gadget/f_fs.c                          |  12 +-
 drivers/usb/gadget/f_uac2.c                        |   1 +
 drivers/usb/gadget/inode.c                         |  17 +-
 drivers/usb/host/xhci-pci.c                        |   5 +
 drivers/usb/host/xhci-plat.c                       |   3 +
 drivers/usb/musb/musb_host.c                       |  21 +-
 drivers/usb/serial/io_edgeport.c                   |  56 ++-
 drivers/usb/serial/keyspan.c                       |   4 +
 drivers/usb/serial/mxuport.c                       |  10 +
 drivers/usb/serial/option.c                        | 155 ++++++-
 drivers/usb/serial/quatech2.c                      |   1 +
 drivers/xen/events/events_base.c                   |   6 +-
 drivers/xen/xen-acpi-processor.c                   |  35 +-
 drivers/xen/xen-pciback/conf_space.c               |   6 +-
 drivers/xen/xenbus/xenbus_xs.c                     |   3 -
 fs/btrfs/ctree.h                                   |   1 +
 fs/btrfs/file.c                                    |   2 +-
 fs/btrfs/inode.c                                   |   2 +-
 fs/btrfs/ioctl.c                                   |  21 +
 fs/cifs/cifs_spnego.c                              |  67 +++
 fs/cifs/cifsfs.c                                   |   4 +-
 fs/cifs/cifsproto.h                                |   2 +
 fs/cifs/connect.c                                  |   4 +-
 fs/cifs/ntlmssp.h                                  |   2 +-
 fs/cifs/sess.c                                     | 210 ++++++----
 fs/cifs/smb2glob.h                                 |   1 +
 fs/cifs/smb2inode.c                                |   8 +-
 fs/cifs/smb2pdu.c                                  |  53 ++-
 fs/cifs/smb2proto.h                                |   2 +
 fs/dcache.c                                        |   5 +-
 fs/ecryptfs/file.c                                 |  15 +-
 fs/ecryptfs/main.c                                 |   7 +
 fs/ext4/ialloc.c                                   |  55 ++-
 fs/ext4/inode.c                                    |  23 +-
 fs/ext4/namei.c                                    |   2 +-
 fs/hpfs/super.c                                    |  42 +-
 fs/namespace.c                                     |   2 +-
 fs/nfs/dir.c                                       |   2 +-
 fs/nfs/nfs4proc.c                                  |   5 +-
 fs/nfsd/nfs2acl.c                                  |  20 +-
 fs/nfsd/nfs3acl.c                                  |  16 +-
 fs/nfsd/nfs4acl.c                                  |  16 +-
 fs/nilfs2/the_nilfs.c                              |   2 +-
 fs/posix_acl.c                                     |  38 +-
 fs/proc/root.c                                     |   7 +
 fs/ubifs/file.c                                    |  24 ++
 fs/xfs/xfs_inode.c                                 |  26 +-
 fs/xfs/xfs_super.c                                 |  10 +
 include/asm-generic/preempt.h                      |   4 +-
 include/linux/device.h                             |   7 +-
 include/linux/fs.h                                 |  11 +
 include/linux/mlx5/driver.h                        |   1 +
 include/linux/mlx5/qp.h                            |   2 +
 include/linux/netfilter/x_tables.h                 |  12 +-
 include/linux/sunrpc/msg_prot.h                    |   4 +-
 include/net/codel.h                                |   4 +
 include/net/sch_generic.h                          |  20 +-
 include/scsi/scsi_device.h                         |   1 +
 kernel/auditsc.c                                   | 335 ++++++++-------
 kernel/exit.c                                      |  29 +-
 kernel/sched/core.c                                |   6 +-
 kernel/sched/proc.c                                |  11 +-
 kernel/trace/ring_buffer.c                         |  35 +-
 kernel/trace/trace_printk.c                        |   7 +-
 lib/dma-debug.c                                    |   2 +-
 mm/migrate.c                                       |   2 +
 mm/shmem.c                                         |   8 +-
 net/batman-adv/bat_iv_ogm.c                        |   9 +-
 net/batman-adv/routing.c                           |   5 +-
 net/batman-adv/soft-interface.c                    |   9 +
 net/batman-adv/translation-table.c                 |  52 ++-
 net/batman-adv/types.h                             |   2 +
 net/bridge/br_multicast.c                          |   4 +
 net/bridge/br_private.h                            |  25 +-
 net/ipv4/netfilter/arp_tables.c                    | 279 ++++---------
 net/ipv4/netfilter/ip_tables.c                     | 305 ++++----------
 net/ipv4/tcp_input.c                               |  13 +-
 net/ipv6/addrconf.c                                |  10 +-
 net/ipv6/icmp.c                                    |   2 +-
 net/ipv6/netfilter/ip6_tables.c                    | 300 +++----------
 net/ipv6/tcp_ipv6.c                                |   4 +-
 net/mac80211/mesh.c                                |  11 +-
 net/netfilter/x_tables.c                           | 245 ++++++++++-
 net/netlink/af_netlink.c                           |   7 +-
 net/rds/recv.c                                     |   2 +
 net/sched/sch_api.c                                |   8 +-
 net/sched/sch_cbq.c                                |  12 +-
 net/sched/sch_choke.c                              |   6 +-
 net/sched/sch_codel.c                              |  10 +-
 net/sched/sch_drr.c                                |   9 +-
 net/sched/sch_dsmark.c                             |   8 +-
 net/sched/sch_fifo.c                               |   4 +
 net/sched/sch_fq.c                                 |   4 +-
 net/sched/sch_fq_codel.c                           |  17 +-
 net/sched/sch_hfsc.c                               |   9 +-
 net/sched/sch_hhf.c                                |  10 +-
 net/sched/sch_htb.c                                |  19 +-
 net/sched/sch_multiq.c                             |  16 +-
 net/sched/sch_netem.c                              |  21 +-
 net/sched/sch_pie.c                                |   5 +-
 net/sched/sch_prio.c                               |  15 +-
 net/sched/sch_qfq.c                                |   9 +-
 net/sched/sch_red.c                                |  10 +-
 net/sched/sch_sfb.c                                |  10 +-
 net/sched/sch_sfq.c                                |  16 +-
 net/sched/sch_tbf.c                                |  15 +-
 net/sunrpc/auth_gss/svcauth_gss.c                  |   4 +-
 net/tipc/node.c                                    |   3 +-
 scripts/Makefile.extrawarn                         |   1 +
 scripts/mod/file2alias.c                           |   2 +-
 security/keys/key.c                                |   2 +-
 sound/core/compress_offload.c                      |   2 +-
 sound/core/timer.c                                 |   5 +-
 sound/drivers/dummy.c                              |   1 +
 sound/pci/au88x0/au88x0_core.c                     |   5 +-
 sound/pci/echoaudio/echoaudio.c                    |   4 +-
 sound/pci/hda/patch_realtek.c                      |   7 +
 tools/perf/util/perf_regs.c                        |   8 +-
 virt/kvm/irqchip.c                                 |   2 +-
 virt/kvm/kvm_main.c                                |   2 +-
 294 files changed, 3382 insertions(+), 2290 deletions(-)

AceLan Kao (1):
      ALSA: hda - Fix headset mic detection problem for Dell machine

Adrian Hunter (1):
      mmc: mmc: Fix partition switch timeout for some eMMCs

Al Viro (2):
      fix d_walk()/non-delayed __d_free() race
      make nfs_atomic_open() call d_drop() on all -&gt;open_context() errors.

Alan Stern (1):
      USB: don&#39;t free bandwidth_mutex too early

Alex Deucher (1):
      drm/radeon: fix asic initialization for virtualized environments

Alex Williamson (2):
      iommu/vt-d: Ratelimit fault handler
      iommu/vt-d: Improve fault handler error messages

Alexey Brodkin (1):
      arc: unwind: warn only once if DW2_UNWIND is disabled

Andreas Gruenbacher (1):
      posix_acl: Add set_posix_acl

Andreas Werner (1):
      mcb: Fixed bar number assignment for the gdd

Andrew F. Davis (1):
      regmap: cache: Fix typo in cache_bypass parameter description

Andrew Goodbody (2):
      usb: musb: Ensure rx reinit occurs for shared_fifo endpoints
      usb: musb: Stop bulk endpoint while queue is rotated

Andrey Grodzovsky (1):
      xen/pciback: Fix conf_space read/write overlap check.

Andrey Ryabinin (1):
      kernel/sysrq, watchdog, sched/core: Reset watchdog on all CPUs while processing sysrq-w

Andy Lutomirski (1):
      uvc: Forward compat ioctls to their handlers directly

Anthony Romano (1):
      tmpfs: don&#39;t undo fallocate past its last page

Arnd Bergmann (4):
      driver-core: use &#39;dev&#39; argument in dev_dbg_ratelimited stub
      gcov: disable tree-loop-im to reduce stack usage
      kbuild: move -Wunused-const-variable to W=1 warning level
      crypto: public_key: select CRYPTO_AKCIPHER

Artem Bityutskiy (1):
      UBI: do propagate positive error codes up

Ashutosh Dixit (1):
      misc: mic: Fix for double fetch security bug in VOP driver

Bartlomiej Zolnierkiewicz (1):
      blk-mq: fix undefined behaviour in order_to_size()

Ben Dooks (1):
      gpio: bcm-kona: fix bcm_kona_gpio_reset() warnings

Ben Hutchings (4):
      USB: quirks: Fix entries on wrong list in 3.16.y
      nfsd: check permissions when setting ACLs
      batman-adv: Fix double-put of vlan object
      Linux 3.16.37

Ben Skeggs (1):
      drm/nouveau/fbcon: fix out-of-bounds memory accesses

Bernhard Thaler (1):
      Revert &quot;netfilter: ensure number of counters is &gt;0 in do_replace()&quot;

Bin Liu (1):
      usb: gadget: fix spinlock dead lock in gadgetfs

Bjorn Helgaas (2):
      PCI: Supply CPU physical address (not bus address) to iomem_is_exclusive()
      alpha/PCI: Call iomem_is_exclusive() for IORESOURCE_MEM, but not IORESOURCE_IO

Bob Copeland (1):
      mac80211: mesh: flush mesh paths unconditionally

Borislav Petkov (1):
      x86/amd_nb: Fix boot crash on non-AMD systems

Brian Bloniarz (1):
      Fix OpenSSH pty regression on close

Brian King (1):
      ipr: Clear interrupt on croc/crocodile when running with LSI

Brian Norris (1):
      UBI: fix missing brace control flow

Cameron Gutman (1):
      Input: xpad - prevent spurious input from wired Xbox 360 controllers

Catalin Marinas (2):
      arm64: Ensure pmd_present() returns false after pmd_mknotpresent()
      arm64: Provide &quot;model name&quot; in /proc/cpuinfo for PER_LINUX32 tasks

Catalin Vasile (1):
      crypto: caam - fix caam_jr_alloc() ret code

Chris Wilson (1):
      drm/i915: Prevent machine death on Ivybridge context switching

Christophe JAILLET (1):
      ALSA: echoaudio: Fix memory allocation

Chuck Lever (1):
      sunrpc: Update RPCBIND_MAXNETIDLEN

Crestez Dan Leonard (1):
      iio: Fix error handling in iio_trigger_attach_poll_func

Cyril Bur (1):
      powerpc/tm: Always reclaim in start_thread() for exec() class syscalls

Dan Carpenter (8):
      mfd: lp8788-irq: Uninitialized variable in irq handler
      cx23885: uninitialized variable in cx23885_av_work_handler()
      ACPI / sysfs: fix error code in get_status()
      i40e: fix an uninitialized variable bug
      usb: f_fs: off by one bug in _ffs_func_bind()
      KEYS: potential uninitialized variable
      qlcnic: use the correct ring in qlcnic_83xx_process_rcv_ring_diag()
      ALSA: compress: fix an integer overflow check

Daniel Borkmann (1):
      ipv6, token: allow for clearing the current device token

Daniel Lezcano (1):
      cpuidle: Fix cpuidle_state_is_coupled() argument in cpuidle_enter()

Dave Chinner (3):
      xfs: xfs_iflush_cluster fails to abort on error
      xfs: fix inode validity check in xfs_iflush_cluster
      xfs: skip stale inodes in xfs_iflush_cluster

Dave Gerlach (1):
      cpuidle: Indicate when a device has been unregistered

Dave Jones (1):
      netfilter: ensure number of counters is &gt;0 in do_replace()

Dmitry Torokhov (1):
      Input: elantech - add more IC body types to the list

Dotan Barak (1):
      IB/mlx4: Fix memory leak if QP creation failed

Edward Cree (1):
      sfc: on MC reset, clear PIO buffer linkage in TXQs

Eli Cohen (1):
      IB/mlx5: Fix post send fence logic

Emmanouil Maroudas (1):
      EDAC: Increment correct counter in edac_inc_ue_error()

Erez Shitrit (2):
      IB/IPoIB: Fix race between ipoib_remove_one to sysfs functions
      IB/IPoIB: Don&#39;t update neigh validity for unresolved entries

Eric Dumazet (4):
      netem: fix a use after free
      net_sched: fix pfifo_head_drop behavior vs backlog
      bonding: prevent out of bound accesses
      tcp: make challenge acks less predictable

Eric Sandeen (1):
      xfs: disallow rw remount on fs with unknown ro-compat features

Eric W. Biederman (1):
      mnt: fs_fully_visible test the proper mount for MNT_LOCKED

Ewan D. Milne (1):
      scsi: Add QEMU CD-ROM to VPD Inquiry Blacklist

Florian Fainelli (5):
      MIPS: BMIPS: Fix PRID_IMP_BMIPS5000 masking for BMIPS5200
      net: bgmac: Start transmit queue in bgmac_open
      net: bgmac: Remove superflous netif_carrier_on()
      net: phy: Manage fixed PHY address space using IDA
      net: bcmsysport: Device stats are unsigned long

Florian Westphal (16):
      batman-adv: fix skb deref after free
      netfilter: x_tables: don&#39;t move to non-existent next rule
      netfilter: x_tables: add and use xt_check_entry_offsets
      netfilter: x_tables: kill check_entry helper
      netfilter: x_tables: assert minimum target size
      netfilter: x_tables: add compat version of xt_check_entry_offsets
      netfilter: x_tables: check standard target size too
      netfilter: x_tables: check for bogus target offset
      netfilter: x_tables: validate all offsets and sizes in a rule
      netfilter: x_tables: don&#39;t reject valid target size on some architectures
      netfilter: arp_tables: simplify translate_compat_table args
      netfilter: ip_tables: simplify translate_compat_table args
      netfilter: ip6_tables: simplify translate_compat_table args
      netfilter: x_tables: xt_compat_match_from_user doesn&#39;t need a retval
      netfilter: x_tables: do compat validation via translate_table
      netfilter: x_tables: introduce and use xt_copy_counters_from_user

Gavin Shan (1):
      powerpc/pseries: Fix PCI config address for DDW

Geert Uytterhoeven (3):
      serial: doc: Un-document non-existing uart_write_console()
      serial: doc: Re-add paragraph documenting uart_console_write()
      char: Drop bogus dependency of DEVPORT on !M68K

Gregor Boirie (1):
      iio:st_pressure: fix sampling gains (bring inline with ABI)

Guilherme G. Piccoli (1):
      powerpc/iommu: Remove the dependency on EEH struct in DDW mechanism

H. Peter Anvin (1):
      x86, build: copy ldlinux.c32 to image.iso

Hannes Frederic Sowa (1):
      ipv6: fix endianness error in icmpv6_err

Hans de Goede (3):
      usb: quirks: Fix sorting
      usb: quirks: Add no-lpm quirk for Acer C120 LED Projector
      USB: xhci: Add broken streams quirk for Frescologic device id 1009

Hari Bathini (1):
      powerpc/book3s64: Fix branching to OOL handlers in relocatable kernel

Hariprasad S (1):
      RDMA/iw_cxgb4: Always wake up waiter in c4iw_peer_abort_intr()

Heiko Carstens (1):
      s390/vmem: fix identity mapping

Heinrich Schuchardt (3):
      ARM: dts: kirkwood: add kirkwood-ds112.dtb to Makefile
      ARM: dts: kirkwood: add kirkwood-nsa320.dtb to Makefile
      usb: gadget: avoid exposing kernel stack

Helge Deller (1):
      parisc: Fix pagefault crash in unaligned __get_user() call

Herbert Xu (1):
      netlink: Fix dump skb leak/double free

Honggang Li (1):
      RDMA/cxgb3: device driver frees DMA memory with different size

Hugh Dickins (1):
      tmpfs: fix regression hang in fallocate undo

Hui Wang (1):
      ALSA: hda - Fix headset mic detection problem for one Dell machine

Itai Handler (1):
      drm/gma500: Fix possible out of bounds read

James Bottomley (1):
      scsi_lib: correctly retry failed zero length REQ_TYPE_FS commands

James Hogan (5):
      MIPS: Fix siginfo.h to use strict posix types
      MIPS: Don&#39;t unwind to user mode with EVA
      MIPS: Avoid using unwind_stack() with usermode
      MIPS: KVM: Fix timer IRQ race when freezing timer
      MIPS: KVM: Fix timer IRQ race when writing CP0_Compare

James Morse (1):
      KVM: arm/arm64: Stop leaking vcpu pid references

Jan Beulich (2):
      xenbus: don&#39;t bail early from xenbus_dev_request_and_reply()
      xen/acpi: allow xen-acpi-processor driver to load on Xen 4.7

Jan Kara (2):
      ext4: fix data exposure after a crash
      ext4: fix oops on corrupted filesystem

Jann Horn (1):
      proc: prevent stacking filesystems on top

Jason Gunthorpe (1):
      IB/mlx4: Properly initialize GRH TClass and FlowLabel in AHs

Jason Wang (1):
      tuntap: correctly wake up process during uninit

Jeff Mahoney (1):
      ecryptfs: don&#39;t allow mmap when the lower fs doesn&#39;t support it

Jerome Marchand (2):
      cifs: use CIFS_MAX_DOMAINNAME_LEN when converting the domain name
      cifs: dynamic allocation of ntlmssp blob

Jiri Slaby (4):
      Bluetooth: vhci: fix open_timeout vs. hdev race
      Bluetooth: vhci: purge unhandled skbs
      tty: vt, return error when con_startup fails
      base: make module_create_drivers_dir race-free

Johan Hovold (5):
      USB: serial: io_edgeport: fix memory leaks in attach error path
      USB: serial: io_edgeport: fix memory leaks in probe error path
      USB: serial: keyspan: fix use-after-free in probe error path
      USB: serial: mxuport: fix use-after-free in probe error path
      USB: serial: quatech2: fix use-after-free in probe error path

Johannes Thumshirn (2):
      scsi: Add intermediate STARGET_REMOVE state to scsi_target_state
      Revert &quot;scsi: fix soft lockup in scsi_remove_target() on module removal&quot;

Joseph Salisbury (1):
      ath5k: Change led pin configuration for compaq c700 laptop

Joshua Kinard (1):
      MIPS: Adjust set_pte() SMP fix to handle R10000_LLSC_WAR

Jouni Malinen (1):
      mac80211: Fix mesh estab_plinks counting in STA removal case

Julien Grall (1):
      arm64: cpuinfo: Missing NULL terminator in compat_hwcap_str

Kamal Heib (1):
      net/mlx4_en: Fix the return value of a failure in VLAN VID add/kill

Kangjie Lu (6):
      USB: usbfs: fix potential infoleak in devio
      ALSA: timer: Fix leak in SNDRV_TIMER_IOCTL_PARAMS
      ALSA: timer: Fix leak in events via snd_timer_user_ccallback
      ALSA: timer: Fix leak in events via snd_timer_user_tinterrupt
      tipc: fix an infoleak in tipc_nl_compat_link_dump
      rds: fix an infoleak in rds_inc_info_copy

Kirill A. Shutemov (1):
      UBIFS: Implement -&gt;migratepage()

Krzysztof Kozlowski (1):
      crypto: s5p-sss - Fix missed interrupts when working with 8 kB blocks

Lars Persson (1):
      MIPS: Fix race condition in lazy cache flushing.

Lei Liu (1):
      USB: serial: option: add even more ZTE device ids

Linus Walleij (2):
      crypto: ux500 - memmove the right size
      iio: accel: kxsd9: fix the usage of spi_w8r8()

Luis de Bethencourt (1):
      staging: iio: accel: fix error check

Luke Dashjr (1):
      btrfs: bugfix: handle FS_IOC32_{GETFLAGS,SETFLAGS,GETVERSION} in btrfs_ioctl

Lyude (3):
      drm/i915/fbdev: Fix num_connector references in intel_fb_initial_config()
      drm/fb_helper: Fix references to dev-&gt;mode_config.num_connector
      drm/i915/ilk: Don&#39;t disable SSC source if it&#39;s in use

Majd Dibbiny (2):
      net/mlx5: Fix the size of modify QP mailbox
      net/mlx5: Fix masking of reserved bits in XRCD number

Manfred Schlaegl (1):
      Input: pwm-beeper - fix - scheduling while atomic

Mans Rullgard (1):
      ata: sata_dwc_460ex: remove incorrect locking

Marc Zyngier (1):
      arm/arm64: KVM: Enforce Break-Before-Make on Stage-2 page tables

Marek Szyprowski (2):
      crypto: s5p-sss - fix incorrect usage of scatterlists api
      ARM: dts: exynos: Add interrupt line to MAX8997 PMIC on exynos4210-trats

Mark Bloch (2):
      IB/IWPM: Fix a potential skb leak
      IB/core: Fix a potential array overrun in CMA and SA agent

Mark Brown (3):
      iio:ad7266: Fix broken regulator error handling
      iio:ad7266: Fix support for optional regulators
      iio:ad7266: Fix probe deferral for vref

Martin Schwidefsky (2):
      s390: fix test_fp_ctl inline assembly contraints
      s390/sclp_ctl: fix potential information leak with /dev/sclp

Martin Willi (1):
      mac80211_hwsim: Add missing check for HWSIM_ATTR_SIGNAL

Masami Hiramatsu (1):
      kprobes/x86: Clear TF bit in fault on single-stepping

Matt Gumbel (1):
      mmc: longer timeout for long read time quirk

Matt Ranostay (3):
      iio: proximity: as3935: correct IIO_CHAN_INFO_RAW output
      iio: proximity: as3935: remove triggered buffer processing
      iio: proximity: as3935: fix buffer stack trashing

Matthias Schiffer (1):
      MIPS: ath79: make bootconsole wait for both THRE and TEMT

Michael Ellerman (2):
      powerpc/mm/hash64: Factor out hash preload psize check
      powerpc/mm/hash64: Fix subpage protection with 4K HPTE config

Michael Neuling (1):
      powerpc/tm: Avoid SLB faults in treclaim/trecheckpoint when RI=0

Michal Suchanek (2):
      spi: sun4i: fix FIFO limit
      spi: sunxi: fix transfer timeout

Miklos Szeredi (1):
      fs: limit filesystem stacking depth

Mikulas Patocka (2):
      hpfs: fix remount failure when there are no options changed
      hpfs: implement the show_options method

Mohamad Haj Yahia (2):
      net/mlx5: Fix potential deadlock in command mode change
      net/mlx5: Add timeout handle to commands with callback

Naveen N. Rao (2):
      perf tools: Fix perf regs mask generation
      powerpc/bpf/jit: Disable classic BPF JIT on ppc64le

Noa Osherovich (2):
      IB/mlx5: Return PORT_ERR in Active to Initializing tranisition
      IB/mlx5: Fix returned values of query QP

Ocquidant, Sebastien (1):
      memory: omap-gpmc: Fix omap gpmc EXTRADELAY timing

Oleg Nesterov (1):
      wait/ptrace: assume __WALL if the child is traced

Oliver Hartkopp (1):
      can: fix oops caused by wrong rtnl dellink usage

Oliver Neukum (1):
      HID: elo: kill not flush the work

Olivier Sobrie (1):
      Input: pwm-beeper - remove useless call to pwm_config()

Omar Sandoval (1):
      block: fix use-after-free in sys_ioprio_get()

Pali Rohár (1):
      hwmon: (dell-smm) Restrict fan control and serial number to CAP_SYS_ADMIN by default

Paolo Bonzini (2):
      KVM: irqfd: fix NULL pointer dereference in kvm_irq_map_gsi
      KVM: x86: fix OOPS after invalid KVM_SET_DEBUGREGS

Paul Burton (2):
      MIPS: math-emu: Fix jalr emulation when rd == $0
      MIPS: fix read_msa_* &amp; write_msa_* functions on non-MSA toolchains

Paul Mackerras (2):
      KVM: PPC: Book3S HV: Pull out TM state save/restore into separate procedures
      KVM: PPC: Book3S HV: Save/restore TM state in H_CEDE

Paul Moore (1):
      audit: fix a double fetch in audit_log_single_execve_arg()

Peter Hurley (1):
      Revert &quot;tty: Fix pty master poll() after slave closes v2&quot;

Peter Zijlstra (1):
      sched/preempt: Fix preempt_count manipulations

Ping Cheng (1):
      Input: wacom_w8001 - w8001_MAX_LENGTH should be 13

Prarit Bhargava (2):
      x86/PCI: Mark Broadwell-EP Home Agent 1 as having non-compliant BARs
      PCI: Disable all BAR sizing for devices with non-compliant BARs

Rafael J. Wysocki (3):
      PM / sleep: Handle failures in device_suspend_late() consistently
      ACPI / processor: Avoid reserving IO regions too early
      x86/power/64: Fix kernel text mapping corruption during image restoration

Raghava Aditya Renukunta (2):
      aacraid: Relinquish CPU during timeout wait
      aacraid: Fix for aac_command_thread hang

Richard Weinberger (3):
      UBI: Fix static volume checks when Fastmap is used
      ubi: Make recover_peb power cut aware
      mm: Export migrate_page_move_mapping and migrate_page_copy

Ricky Liang (1):
      Input: uinput - handle compat ioctl for UI_SET_PHYS

Roger Quadros (1):
      mfd: omap-usb-tll: Fix scheduling while atomic BUG

Ross Lagerwall (1):
      xen/events: Don&#39;t move disabled irqs

Russell Currey (1):
      powerpc/pseries/eeh: Handle RTAS delay requests in configure_bridge

Russell King (1):
      ARM: fix PTRACE_SETVFPREGS on SMP systems

Sachin Prabhu (1):
      cifs: Create dedicated keyring for spnego operations

Sai Gurrappadi (1):
      cpufreq: Fix GOV_LIMITS handling for the userspace governor

Schemmel Hans-Christoph (1):
      USB: serial: option: add support for Cinterion PH8 and AHxx

Scott Bauer (1):
      HID: hiddev: validate num_values for HIDIOCGUSAGES, HIDIOCSUSAGES commands

Sergei Shtylyov (1):
      of: irq: fix of_irq_get[_byname]() kernel-doc

Shaokun Zhang (1):
      arm64: mm: remove page_mapping check in __sync_icache_dcache

Simon Wunderlich (1):
      batman-adv: replace WARN with rate limited output on non-existing VLAN

Srinivas Pandruvada (1):
      cpufreq: intel_pstate: Fix -&gt;set_policy() interface for no_turbo

Stefan Metzmacher (4):
      fs/cifs: correctly to anonymous authentication via NTLMSSP
      fs/cifs: correctly to anonymous authentication for the LANMAN authentication
      fs/cifs: correctly to anonymous authentication for the NTLM(v1) authentication
      fs/cifs: correctly to anonymous authentication for the NTLM(v2) authentication

Steinar H. Gunderson (1):
      usb: dwc3: exynos: Fix deferred probing storm.

Steve Capper (1):
      ARM: 8579/1: mm: Fix definition of pmd_mknotpresent

Steve French (2):
      remove directory incorrectly tries to set delete on close on non-empty directories
      Fix reconnect to not defer smb3 session reconnect long after socket reconnect

Steven Rostedt (Red Hat) (3):
      ring-buffer: Use long for nr_pages to avoid overflow failures
      ring-buffer: Prevent overflow of size in ring_buffer_resize()
      tracing: Handle NULL formats in hold_module_trace_bprintk_format()

Suman Anna (1):
      ARM: OMAP2+: hwmod: fix _idle() hwmod state sanity check sequence

Sven Eckelmann (6):
      batman-adv: Fix unexpected free of bcast_own on add_if error
      batman-adv: Fix integer overflow in batadv_iv_ogm_calc_tq
      batman-adv: Fix memory leak on tt add with invalid vlan
      batman-adv: Fix use-after-free/double-free of tt_req_node
      batman-adv: Fix ICMP RR ethernet access after skb_linearize
      batman-adv: Clean up untagged vlan when destroying via rtnl-link

Takashi Iwai (4):
      Bluetooth: vhci: Fix race at creating hci device
      ALSA: dummy: Fix a use-after-free at closing
      ALSA: au88x0: Fix calculation in vortex_wtdma_bufshift()
      ALSA: timer: Fix negative queue usage by racy accesses

Tariq Toukan (1):
      net/mlx4_core: Fix access to uninitialized index

Theodore Ts&#39;o (2):
      ext4: fix hang when processing corrupted orphaned inode list
      ext4: clean up error handling when orphan list is corrupted

Thomas Huth (2):
      powerpc: Fix definition of SIAR and SDAR registers
      powerpc: Use privileged SPR number for MMCR2

Thomas Petazzoni (1):
      usb: xhci-plat: properly handle probe deferral for devm_clk_get()

Thor Thayer (1):
      can: c_can: Update D_CAN TX and RX functions to 32 bit - fix Altera Cyclone access

Tom Lendacky (1):
      crypto: ccp - Fix AES XTS error for request sizes above 4096

Tomáš Trnka (1):
      sunrpc: fix stripping of padded MIC tokens

Tony Lindgren (1):
      pinctrl: single: Fix missing flush of posted write for a wakeirq

Torsten Hilbrich (1):
      fs/nilfs2: fix potential underflow in call to crc32_le

Trond Myklebust (1):
      NFS: Fix another OPEN_DOWNGRADE bug

Ulf Hansson (1):
      PM / Runtime: Fix error path in pm_runtime_force_resume()

Ursula Braun (1):
      qeth: delete napi struct when removing a qeth device

Vik Heyndrickx (1):
      sched/loadavg: Fix loadavg artifacts on fully idle and on fully loaded systems

Ville Syrjälä (2):
      drm/i915: Don&#39;t leave old junk in ilk active watermarks on readout
      dma-debug: avoid spinlock recursion when disabling dma-debug

Vineet Gupta (1):
      ARC: unwind: ensure that .debug_frame is generated (vs. .eh_frame)

WANG Cong (2):
      net_sched: introduce qdisc_replace() helper
      net_sched: update hierarchical backlog too

Wei Fang (1):
      scsi: fix race between simultaneous decrements of -&gt;host_failed

Will Deacon (2):
      irqchip/gic: Ensure ordering between read of INTACK and shared data
      ARM: 8578/1: mm: ensure pmd_present only checks the valid bit

William Breathitt Gray (1):
      isa: Call isa_bus_init before dependent ISA bus drivers register

Wolfgang Grandegger (1):
      can: at91_can: RX queue could get stuck at high bus load

Wolfram Sang (1):
      of: fix autoloading due to broken modalias with no &#39;compatible&#39;

Xiubo Li (1):
      kvm: Fix irq route entries exceeding KVM_MAX_IRQ_ROUTES

Yishai Hadas (3):
      IB/mlx4: Fix the SQ size of an RC QP
      IB/mlx4: Fix error flow when sending mads under SRIOV
      IB/mlx4: Verify port number in flow steering create flow

Yuchung Cheng (1):
      tcp: record TLP and ER timer stats in v6 stats

daniel (1):
      Bridge: Fix ipv6 mc snooping if bridge has no ipv6 address

lei liu (1):
      USB: serial: option: add more ZTE device ids

wang yanqing (1):
      rtlwifi: Fix logic error in enter/exit power-save mode

xypron.glpk@gmx.de (1):
      net: ehea: avoid null pointer dereference
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/ABI/testing/sysfs-bus-iio-proximity-as3935 b/Documentation/ABI/testing/sysfs-bus-iio-proximity-as3935</span>
<span class="p_header">index 6708c5e264aa..33e96f740639 100644</span>
<span class="p_header">--- a/Documentation/ABI/testing/sysfs-bus-iio-proximity-as3935</span>
<span class="p_header">+++ b/Documentation/ABI/testing/sysfs-bus-iio-proximity-as3935</span>
<span class="p_chunk">@@ -1,4 +1,4 @@</span> <span class="p_context"></span>
<span class="p_del">-What		/sys/bus/iio/devices/iio:deviceX/in_proximity_raw</span>
<span class="p_add">+What		/sys/bus/iio/devices/iio:deviceX/in_proximity_input</span>
 Date:		March 2014
 KernelVersion:	3.15
 Contact:	Matt Ranostay &lt;mranostay@gmail.com&gt;
<span class="p_header">diff --git a/Documentation/scsi/scsi_eh.txt b/Documentation/scsi/scsi_eh.txt</span>
<span class="p_header">index a0c85110a07e..689ab9b9953a 100644</span>
<span class="p_header">--- a/Documentation/scsi/scsi_eh.txt</span>
<span class="p_header">+++ b/Documentation/scsi/scsi_eh.txt</span>
<span class="p_chunk">@@ -263,19 +263,23 @@</span> <span class="p_context"> scmd-&gt;allowed.</span>
 
  3. scmd recovered
     ACTION: scsi_eh_finish_cmd() is invoked to EH-finish scmd
<span class="p_del">-	- shost-&gt;host_failed--</span>
 	- clear scmd-&gt;eh_eflags
 	- scsi_setup_cmd_retry()
 	- move from local eh_work_q to local eh_done_q
     LOCKING: none
<span class="p_add">+    CONCURRENCY: at most one thread per separate eh_work_q to</span>
<span class="p_add">+		 keep queue manipulation lockless</span>
 
  4. EH completes
     ACTION: scsi_eh_flush_done_q() retries scmds or notifies upper
<span class="p_del">-	    layer of failure.</span>
<span class="p_add">+	    layer of failure. May be called concurrently but must have</span>
<span class="p_add">+	    a no more than one thread per separate eh_work_q to</span>
<span class="p_add">+	    manipulate the queue locklessly</span>
 	- scmd is removed from eh_done_q and scmd-&gt;eh_entry is cleared
 	- if retry is necessary, scmd is requeued using
           scsi_queue_insert()
 	- otherwise, scsi_finish_command() is invoked for scmd
<span class="p_add">+	- zero shost-&gt;host_failed</span>
     LOCKING: queue or finish function performs appropriate locking
 
 
<span class="p_header">diff --git a/Documentation/serial/driver b/Documentation/serial/driver</span>
<span class="p_header">index 3bba1aeb799c..c86d002486f1 100644</span>
<span class="p_header">--- a/Documentation/serial/driver</span>
<span class="p_header">+++ b/Documentation/serial/driver</span>
<span class="p_chunk">@@ -28,7 +28,7 @@</span> <span class="p_context"> The serial core provides a few helper functions.  This includes identifing</span>
 the correct port structure (via uart_get_console) and decoding command line
 arguments (uart_parse_options).
 
<span class="p_del">-There is also a helper function (uart_write_console) which performs a</span>
<span class="p_add">+There is also a helper function (uart_console_write) which performs a</span>
 character by character write, translating newlines to CRLF sequences.
 Driver writers are recommended to use this function rather than implementing
 their own version.
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 50b4f93c0054..e49d13717d31 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 16
<span class="p_del">-SUBLEVEL = 36</span>
<span class="p_add">+SUBLEVEL = 37</span>
 EXTRAVERSION =
 NAME = Museum of Fishiegoodies
 
<span class="p_chunk">@@ -381,7 +381,7 @@</span> <span class="p_context"> AFLAGS_MODULE   =</span>
 LDFLAGS_MODULE  =
 CFLAGS_KERNEL	=
 AFLAGS_KERNEL	=
<span class="p_del">-CFLAGS_GCOV	= -fprofile-arcs -ftest-coverage</span>
<span class="p_add">+CFLAGS_GCOV	= -fprofile-arcs -ftest-coverage -fno-tree-loop-im</span>
 
 
 # Use USERINCLUDE when you must reference the UAPI directories only.
<span class="p_chunk">@@ -671,9 +671,10 @@</span> <span class="p_context"> KBUILD_CFLAGS += $(call cc-disable-warning, tautological-compare)</span>
 KBUILD_CFLAGS += $(call cc-option, -mno-global-merge,)
 else
 
<span class="p_del">-# This warning generated too much noise in a regular build.</span>
<span class="p_del">-# Use make W=1 to enable this warning (see scripts/Makefile.build)</span>
<span class="p_add">+# These warnings generated too much noise in a regular build.</span>
<span class="p_add">+# Use make W=1 to enable them (see scripts/Makefile.build)</span>
 KBUILD_CFLAGS += $(call cc-disable-warning, unused-but-set-variable)
<span class="p_add">+KBUILD_CFLAGS += $(call cc-disable-warning, unused-const-variable)</span>
 endif
 
 ifdef CONFIG_FRAME_POINTER
<span class="p_header">diff --git a/arch/alpha/kernel/pci-sysfs.c b/arch/alpha/kernel/pci-sysfs.c</span>
<span class="p_header">index 99e8d4796c96..92c0d460815b 100644</span>
<span class="p_header">--- a/arch/alpha/kernel/pci-sysfs.c</span>
<span class="p_header">+++ b/arch/alpha/kernel/pci-sysfs.c</span>
<span class="p_chunk">@@ -77,10 +77,10 @@</span> <span class="p_context"> static int pci_mmap_resource(struct kobject *kobj,</span>
 	if (i &gt;= PCI_ROM_RESOURCE)
 		return -ENODEV;
 
<span class="p_del">-	if (!__pci_mmap_fits(pdev, i, vma, sparse))</span>
<span class="p_add">+	if (res-&gt;flags &amp; IORESOURCE_MEM &amp;&amp; iomem_is_exclusive(res-&gt;start))</span>
 		return -EINVAL;
 
<span class="p_del">-	if (iomem_is_exclusive(res-&gt;start))</span>
<span class="p_add">+	if (!__pci_mmap_fits(pdev, i, vma, sparse))</span>
 		return -EINVAL;
 
 	pcibios_resource_to_bus(pdev-&gt;bus, &amp;bar, res);
<span class="p_header">diff --git a/arch/arc/Makefile b/arch/arc/Makefile</span>
<span class="p_header">index 429279bc3028..e8f8b5133d4d 100644</span>
<span class="p_header">--- a/arch/arc/Makefile</span>
<span class="p_header">+++ b/arch/arc/Makefile</span>
<span class="p_chunk">@@ -35,8 +35,6 @@</span> <span class="p_context"> cflags-$(atleast_gcc44)			+= -fsection-anchors</span>
 cflags-$(CONFIG_ARC_HAS_LLSC)		+= -mlock
 cflags-$(CONFIG_ARC_HAS_SWAPE)		+= -mswape
 cflags-$(CONFIG_ARC_HAS_RTSC)		+= -mrtsc
<span class="p_del">-cflags-$(CONFIG_ARC_DW2_UNWIND)		+= -fasynchronous-unwind-tables</span>
<span class="p_del">-</span>
 # By default gcc 4.8 generates dwarf4 which kernel unwinder can&#39;t grok
 ifeq ($(atleast_gcc48),y)
 cflags-$(CONFIG_ARC_DW2_UNWIND)		+= -gdwarf-2
<span class="p_header">diff --git a/arch/arc/kernel/stacktrace.c b/arch/arc/kernel/stacktrace.c</span>
<span class="p_header">index fb98769b6a98..3e349aefdb9e 100644</span>
<span class="p_header">--- a/arch/arc/kernel/stacktrace.c</span>
<span class="p_header">+++ b/arch/arc/kernel/stacktrace.c</span>
<span class="p_chunk">@@ -131,7 +131,7 @@</span> <span class="p_context"> arc_unwind_core(struct task_struct *tsk, struct pt_regs *regs,</span>
 	 * prelogue is setup (callee regs saved and then fp set and not other
 	 * way around
 	 */
<span class="p_del">-	pr_warn(&quot;CONFIG_ARC_DW2_UNWIND needs to be enabled\n&quot;);</span>
<span class="p_add">+	pr_warn_once(&quot;CONFIG_ARC_DW2_UNWIND needs to be enabled\n&quot;);</span>
 	return 0;
 
 #endif
<span class="p_header">diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile</span>
<span class="p_header">index c04db0ae0895..160eda4cde48 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/Makefile</span>
<span class="p_header">+++ b/arch/arm/boot/dts/Makefile</span>
<span class="p_chunk">@@ -102,6 +102,7 @@</span> <span class="p_context"> kirkwood := \</span>
 	kirkwood-ds109.dtb \
 	kirkwood-ds110jv10.dtb \
 	kirkwood-ds111.dtb \
<span class="p_add">+	kirkwood-ds112.dtb \</span>
 	kirkwood-ds209.dtb \
 	kirkwood-ds210.dtb \
 	kirkwood-ds212.dtb \
<span class="p_chunk">@@ -131,6 +132,7 @@</span> <span class="p_context"> kirkwood := \</span>
 	kirkwood-ns2mini.dtb \
 	kirkwood-nsa310.dtb \
 	kirkwood-nsa310a.dtb \
<span class="p_add">+	kirkwood-nsa320.dtb \</span>
 	kirkwood-openblocks_a6.dtb \
 	kirkwood-openblocks_a7.dtb \
 	kirkwood-openrd-base.dtb \
<span class="p_header">diff --git a/arch/arm/boot/dts/exynos4210-trats.dts b/arch/arm/boot/dts/exynos4210-trats.dts</span>
<span class="p_header">index f516da9e8b3a..37d434dcf25a 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/exynos4210-trats.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/exynos4210-trats.dts</span>
<span class="p_chunk">@@ -188,6 +188,8 @@</span> <span class="p_context"></span>
 			compatible = &quot;maxim,max8997-pmic&quot;;
 
 			reg = &lt;0x66&gt;;
<span class="p_add">+			interrupt-parent = &lt;&amp;gpx0&gt;;</span>
<span class="p_add">+			interrupts = &lt;7 0&gt;;</span>
 
 			max8997,pmic-buck1-uses-gpio-dvs;
 			max8997,pmic-buck2-uses-gpio-dvs;
<span class="p_header">diff --git a/arch/arm/include/asm/pgtable-2level.h b/arch/arm/include/asm/pgtable-2level.h</span>
<span class="p_header">index 219ac88a9542..bed6c8fa54b5 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/pgtable-2level.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/pgtable-2level.h</span>
<span class="p_chunk">@@ -163,6 +163,7 @@</span> <span class="p_context"> static inline pmd_t *pmd_offset(pud_t *pud, unsigned long addr)</span>
 
 #define pmd_large(pmd)		(pmd_val(pmd) &amp; 2)
 #define pmd_bad(pmd)		(pmd_val(pmd) &amp; 2)
<span class="p_add">+#define pmd_present(pmd)	(pmd_val(pmd))</span>
 
 #define copy_pmd(pmdpd,pmdps)		\
 	do {				\
<span class="p_header">diff --git a/arch/arm/include/asm/pgtable-3level.h b/arch/arm/include/asm/pgtable-3level.h</span>
<span class="p_header">index 06e0bc0f8b00..40d60a679fc8 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/pgtable-3level.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/pgtable-3level.h</span>
<span class="p_chunk">@@ -212,6 +212,7 @@</span> <span class="p_context"> static inline pmd_t *pmd_offset(pud_t *pud, unsigned long addr)</span>
 						: !!(pmd_val(pmd) &amp; (val)))
 #define pmd_isclear(pmd, val)	(!(pmd_val(pmd) &amp; (val)))
 
<span class="p_add">+#define pmd_present(pmd)	(pmd_isset((pmd), L_PMD_SECT_VALID))</span>
 #define pmd_young(pmd)		(pmd_isset((pmd), PMD_SECT_AF))
 
 #define __HAVE_ARCH_PMD_WRITE
<span class="p_chunk">@@ -242,8 +243,11 @@</span> <span class="p_context"> PMD_BIT_FUNC(mkyoung,   |= PMD_SECT_AF);</span>
 #define pfn_pmd(pfn,prot)	(__pmd(((phys_addr_t)(pfn) &lt;&lt; PAGE_SHIFT) | pgprot_val(prot)))
 #define mk_pmd(page,prot)	pfn_pmd(page_to_pfn(page),prot)
 
<span class="p_del">-/* represent a notpresent pmd by zero, this is used by pmdp_invalidate */</span>
<span class="p_del">-#define pmd_mknotpresent(pmd)	(__pmd(0))</span>
<span class="p_add">+/* represent a notpresent pmd by faulting entry, this is used by pmdp_invalidate */</span>
<span class="p_add">+static inline pmd_t pmd_mknotpresent(pmd_t pmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __pmd(pmd_val(pmd) &amp; ~L_PMD_SECT_VALID);</span>
<span class="p_add">+}</span>
 
 static inline pmd_t pmd_modify(pmd_t pmd, pgprot_t newprot)
 {
<span class="p_header">diff --git a/arch/arm/include/asm/pgtable.h b/arch/arm/include/asm/pgtable.h</span>
<span class="p_header">index 01baef07cd0c..38bbf1e2a9b6 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -182,7 +182,6 @@</span> <span class="p_context"> extern pgd_t swapper_pg_dir[PTRS_PER_PGD];</span>
 #define pgd_offset_k(addr)	pgd_offset(&amp;init_mm, addr)
 
 #define pmd_none(pmd)		(!pmd_val(pmd))
<span class="p_del">-#define pmd_present(pmd)	(pmd_val(pmd))</span>
 
 static inline pte_t *pmd_page_vaddr(pmd_t pmd)
 {
<span class="p_header">diff --git a/arch/arm/kernel/ptrace.c b/arch/arm/kernel/ptrace.c</span>
<span class="p_header">index 0c27ed6f3f23..a20ebfeac471 100644</span>
<span class="p_header">--- a/arch/arm/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/arm/kernel/ptrace.c</span>
<span class="p_chunk">@@ -733,8 +733,8 @@</span> <span class="p_context"> static int vfp_set(struct task_struct *target,</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	vfp_flush_hwstate(thread);</span>
 	thread-&gt;vfpstate.hard = new_vfp;
<span class="p_add">+	vfp_flush_hwstate(thread);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/arch/arm/kvm/arm.c b/arch/arm/kvm/arm.c</span>
<span class="p_header">index 17c7ac58f887..499b236873d2 100644</span>
<span class="p_header">--- a/arch/arm/kvm/arm.c</span>
<span class="p_header">+++ b/arch/arm/kvm/arm.c</span>
<span class="p_chunk">@@ -258,6 +258,7 @@</span> <span class="p_context"> void kvm_arch_vcpu_free(struct kvm_vcpu *vcpu)</span>
 {
 	kvm_mmu_free_memory_caches(vcpu);
 	kvm_timer_vcpu_terminate(vcpu);
<span class="p_add">+	kvm_vcpu_uninit(vcpu);</span>
 	kmem_cache_free(kvm_vcpu_cache, vcpu);
 }
 
<span class="p_header">diff --git a/arch/arm/kvm/mmu.c b/arch/arm/kvm/mmu.c</span>
<span class="p_header">index c65db5d7ea92..c61da3e6a629 100644</span>
<span class="p_header">--- a/arch/arm/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/kvm/mmu.c</span>
<span class="p_chunk">@@ -682,11 +682,14 @@</span> <span class="p_context"> static int stage2_set_pmd_huge(struct kvm *kvm, struct kvm_mmu_memory_cache</span>
 	VM_BUG_ON(pmd_present(*pmd) &amp;&amp; pmd_pfn(*pmd) != pmd_pfn(*new_pmd));
 
 	old_pmd = *pmd;
<span class="p_del">-	kvm_set_pmd(pmd, *new_pmd);</span>
<span class="p_del">-	if (pmd_present(old_pmd))</span>
<span class="p_add">+	if (pmd_present(old_pmd)) {</span>
<span class="p_add">+		pmd_clear(pmd);</span>
 		kvm_tlb_flush_vmid_ipa(kvm, addr);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
 		get_page(virt_to_page(pmd));
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	kvm_set_pmd(pmd, *new_pmd);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -723,12 +726,14 @@</span> <span class="p_context"> static int stage2_set_pte(struct kvm *kvm, struct kvm_mmu_memory_cache *cache,</span>
 
 	/* Create 2nd stage page table mapping - Level 3 */
 	old_pte = *pte;
<span class="p_del">-	kvm_set_pte(pte, *new_pte);</span>
<span class="p_del">-	if (pte_present(old_pte))</span>
<span class="p_add">+	if (pte_present(old_pte)) {</span>
<span class="p_add">+		kvm_set_pte(pte, __pte(0));</span>
 		kvm_tlb_flush_vmid_ipa(kvm, addr);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
 		get_page(virt_to_page(pte));
<span class="p_add">+	}</span>
 
<span class="p_add">+	kvm_set_pte(pte, *new_pte);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/arch/arm/mach-omap2/gpmc.c b/arch/arm/mach-omap2/gpmc.c</span>
<span class="p_header">index 8bc13380f0a0..2e57435c0775 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/gpmc.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/gpmc.c</span>
<span class="p_chunk">@@ -274,7 +274,7 @@</span> <span class="p_context"> static void gpmc_cs_bool_timings(int cs, const struct gpmc_bool_timings *p)</span>
 	gpmc_cs_modify_reg(cs, GPMC_CS_CONFIG4,
 			   GPMC_CONFIG4_OEEXTRADELAY, p-&gt;oe_extra_delay);
 	gpmc_cs_modify_reg(cs, GPMC_CS_CONFIG4,
<span class="p_del">-			   GPMC_CONFIG4_OEEXTRADELAY, p-&gt;we_extra_delay);</span>
<span class="p_add">+			   GPMC_CONFIG4_WEEXTRADELAY, p-&gt;we_extra_delay);</span>
 	gpmc_cs_modify_reg(cs, GPMC_CS_CONFIG6,
 			   GPMC_CONFIG6_CYCLE2CYCLESAMECSEN,
 			   p-&gt;cycle2cyclesamecsen);
<span class="p_header">diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_header">index 6849ae81a560..a0ec4616d7a5 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_chunk">@@ -2263,15 +2263,15 @@</span> <span class="p_context"> static int _idle(struct omap_hwmod *oh)</span>
 {
 	pr_debug(&quot;omap_hwmod: %s: idling\n&quot;, oh-&gt;name);
 
<span class="p_add">+	if (_are_all_hardreset_lines_asserted(oh))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	if (oh-&gt;_state != _HWMOD_STATE_ENABLED) {
 		WARN(1, &quot;omap_hwmod: %s: idle state can only be entered from enabled state\n&quot;,
 			oh-&gt;name);
 		return -EINVAL;
 	}
 
<span class="p_del">-	if (_are_all_hardreset_lines_asserted(oh))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
 	if (oh-&gt;class-&gt;sysc)
 		_idle_sysc(oh);
 	_del_initiator_dep(oh, mpu_oh);
<span class="p_chunk">@@ -2318,6 +2318,9 @@</span> <span class="p_context"> static int _shutdown(struct omap_hwmod *oh)</span>
 	int ret, i;
 	u8 prev_state;
 
<span class="p_add">+	if (_are_all_hardreset_lines_asserted(oh))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	if (oh-&gt;_state != _HWMOD_STATE_IDLE &amp;&amp;
 	    oh-&gt;_state != _HWMOD_STATE_ENABLED) {
 		WARN(1, &quot;omap_hwmod: %s: disabled state can only be entered from idle, or enabled state\n&quot;,
<span class="p_chunk">@@ -2325,9 +2328,6 @@</span> <span class="p_context"> static int _shutdown(struct omap_hwmod *oh)</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	if (_are_all_hardreset_lines_asserted(oh))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
 	pr_debug(&quot;omap_hwmod: %s: disabling\n&quot;, oh-&gt;name);
 
 	if (oh-&gt;class-&gt;pre_shutdown) {
<span class="p_header">diff --git a/arch/arm64/include/asm/elf.h b/arch/arm64/include/asm/elf.h</span>
<span class="p_header">index 01d3aab64b79..2009daf52bf1 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/elf.h</span>
<span class="p_chunk">@@ -161,14 +161,14 @@</span> <span class="p_context"> struct mm_struct;</span>
 extern unsigned long arch_randomize_brk(struct mm_struct *mm);
 #define arch_randomize_brk arch_randomize_brk
 
<span class="p_del">-#ifdef CONFIG_COMPAT</span>
<span class="p_del">-</span>
 #ifdef __AARCH64EB__
 #define COMPAT_ELF_PLATFORM		(&quot;v8b&quot;)
 #else
 #define COMPAT_ELF_PLATFORM		(&quot;v8l&quot;)
 #endif
 
<span class="p_add">+#ifdef CONFIG_COMPAT</span>
<span class="p_add">+</span>
 #define COMPAT_ELF_ET_DYN_BASE		(randomize_et_dyn(2 * TASK_SIZE_32 / 3))
 
 /* AArch32 registers. */
<span class="p_header">diff --git a/arch/arm64/include/asm/pgtable-hwdef.h b/arch/arm64/include/asm/pgtable-hwdef.h</span>
<span class="p_header">index 955e8c5f0afb..1696c1312462 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/pgtable-hwdef.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/pgtable-hwdef.h</span>
<span class="p_chunk">@@ -45,7 +45,6 @@</span> <span class="p_context"></span>
  * Section
  */
 #define PMD_SECT_VALID		(_AT(pmdval_t, 1) &lt;&lt; 0)
<span class="p_del">-#define PMD_SECT_PROT_NONE	(_AT(pmdval_t, 1) &lt;&lt; 58)</span>
 #define PMD_SECT_USER		(_AT(pmdval_t, 1) &lt;&lt; 6)		/* AP[1] */
 #define PMD_SECT_RDONLY		(_AT(pmdval_t, 1) &lt;&lt; 7)		/* AP[2] */
 #define PMD_SECT_S		(_AT(pmdval_t, 3) &lt;&lt; 8)
<span class="p_header">diff --git a/arch/arm64/include/asm/pgtable.h b/arch/arm64/include/asm/pgtable.h</span>
<span class="p_header">index 2a1508cdead0..7b2b696a1b8c 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -250,6 +250,7 @@</span> <span class="p_context"> static inline pmd_t pte_pmd(pte_t pte)</span>
 #define pmd_trans_splitting(pmd)	pte_special(pmd_pte(pmd))
 #endif
 
<span class="p_add">+#define pmd_present(pmd)	pte_present(pmd_pte(pmd))</span>
 #define pmd_young(pmd)		pte_young(pmd_pte(pmd))
 #define pmd_wrprotect(pmd)	pte_pmd(pte_wrprotect(pmd_pte(pmd)))
 #define pmd_mksplitting(pmd)	pte_pmd(pte_mkspecial(pmd_pte(pmd)))
<span class="p_chunk">@@ -257,7 +258,7 @@</span> <span class="p_context"> static inline pmd_t pte_pmd(pte_t pte)</span>
 #define pmd_mkwrite(pmd)	pte_pmd(pte_mkwrite(pmd_pte(pmd)))
 #define pmd_mkdirty(pmd)	pte_pmd(pte_mkdirty(pmd_pte(pmd)))
 #define pmd_mkyoung(pmd)	pte_pmd(pte_mkyoung(pmd_pte(pmd)))
<span class="p_del">-#define pmd_mknotpresent(pmd)	(__pmd(pmd_val(pmd) &amp; ~PMD_TYPE_MASK))</span>
<span class="p_add">+#define pmd_mknotpresent(pmd)	(__pmd(pmd_val(pmd) &amp; ~PMD_SECT_VALID))</span>
 
 #define __HAVE_ARCH_PMD_WRITE
 #define pmd_write(pmd)		pte_write(pmd_pte(pmd))
<span class="p_chunk">@@ -294,7 +295,6 @@</span> <span class="p_context"> extern pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,</span>
 				     unsigned long size, pgprot_t vma_prot);
 
 #define pmd_none(pmd)		(!pmd_val(pmd))
<span class="p_del">-#define pmd_present(pmd)	(pmd_val(pmd))</span>
 
 #define pmd_bad(pmd)		(!(pmd_val(pmd) &amp; 2))
 
<span class="p_header">diff --git a/arch/arm64/kernel/setup.c b/arch/arm64/kernel/setup.c</span>
<span class="p_header">index 5da0da6e7cf0..528942d8db3a 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/setup.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/setup.c</span>
<span class="p_chunk">@@ -44,6 +44,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/of_platform.h&gt;
 #include &lt;linux/efi.h&gt;
 #include &lt;linux/personality.h&gt;
<span class="p_add">+#include &lt;linux/compat.h&gt;</span>
<span class="p_add">+#include &lt;linux/elf.h&gt;</span>
 
 #include &lt;asm/fixmap.h&gt;
 #include &lt;asm/cputype.h&gt;
<span class="p_chunk">@@ -481,13 +483,15 @@</span> <span class="p_context"> static const char *compat_hwcap_str[] = {</span>
 	&quot;idivt&quot;,
 	&quot;vfpd32&quot;,
 	&quot;lpae&quot;,
<span class="p_del">-	&quot;evtstrm&quot;</span>
<span class="p_add">+	&quot;evtstrm&quot;,</span>
<span class="p_add">+	NULL</span>
 };
 #endif /* CONFIG_COMPAT */
 
 static int c_show(struct seq_file *m, void *v)
 {
 	int i, j;
<span class="p_add">+	bool compat = personality(current-&gt;personality) == PER_LINUX32;</span>
 
 	for_each_online_cpu(i) {
 		struct cpuinfo_arm64 *cpuinfo = &amp;per_cpu(cpu_data, i);
<span class="p_chunk">@@ -499,6 +503,9 @@</span> <span class="p_context"> static int c_show(struct seq_file *m, void *v)</span>
 		 * &quot;processor&quot;.  Give glibc what it expects.
 		 */
 #ifdef CONFIG_SMP
<span class="p_add">+		if (compat)</span>
<span class="p_add">+			seq_printf(m, &quot;model name\t: ARMv8 Processor rev %d (%s)\n&quot;,</span>
<span class="p_add">+				   midr &amp; 0xf, COMPAT_ELF_PLATFORM);</span>
 		seq_printf(m, &quot;processor\t: %d\n&quot;, i);
 #endif
 
<span class="p_chunk">@@ -513,7 +520,7 @@</span> <span class="p_context"> static int c_show(struct seq_file *m, void *v)</span>
 		 * software which does already (at least for 32-bit).
 		 */
 		seq_puts(m, &quot;Features\t:&quot;);
<span class="p_del">-		if (personality(current-&gt;personality) == PER_LINUX32) {</span>
<span class="p_add">+		if (compat) {</span>
 #ifdef CONFIG_COMPAT
 			for (j = 0; compat_hwcap_str[j]; j++)
 				if (compat_elf_hwcap &amp; (1 &lt;&lt; j))
<span class="p_header">diff --git a/arch/arm64/mm/flush.c b/arch/arm64/mm/flush.c</span>
<span class="p_header">index 0d64089d28b5..112cf05691c0 100644</span>
<span class="p_header">--- a/arch/arm64/mm/flush.c</span>
<span class="p_header">+++ b/arch/arm64/mm/flush.c</span>
<span class="p_chunk">@@ -74,10 +74,6 @@</span> <span class="p_context"> void __sync_icache_dcache(pte_t pte, unsigned long addr)</span>
 {
 	struct page *page = pte_page(pte);
 
<span class="p_del">-	/* no flushing needed for anonymous pages */</span>
<span class="p_del">-	if (!page_mapping(page))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	if (!test_and_set_bit(PG_dcache_clean, &amp;page-&gt;flags)) {
 		__flush_dcache_area(page_address(page),
 				PAGE_SIZE &lt;&lt; compound_order(page));
<span class="p_header">diff --git a/arch/mips/ath79/early_printk.c b/arch/mips/ath79/early_printk.c</span>
<span class="p_header">index b955fafc58ba..d1adc59af5bf 100644</span>
<span class="p_header">--- a/arch/mips/ath79/early_printk.c</span>
<span class="p_header">+++ b/arch/mips/ath79/early_printk.c</span>
<span class="p_chunk">@@ -31,13 +31,15 @@</span> <span class="p_context"> static inline void prom_putchar_wait(void __iomem *reg, u32 mask, u32 val)</span>
 	} while (1);
 }
 
<span class="p_add">+#define BOTH_EMPTY (UART_LSR_TEMT | UART_LSR_THRE)</span>
<span class="p_add">+</span>
 static void prom_putchar_ar71xx(unsigned char ch)
 {
 	void __iomem *base = (void __iomem *)(KSEG1ADDR(AR71XX_UART_BASE));
 
<span class="p_del">-	prom_putchar_wait(base + UART_LSR * 4, UART_LSR_THRE, UART_LSR_THRE);</span>
<span class="p_add">+	prom_putchar_wait(base + UART_LSR * 4, BOTH_EMPTY, BOTH_EMPTY);</span>
 	__raw_writel(ch, base + UART_TX * 4);
<span class="p_del">-	prom_putchar_wait(base + UART_LSR * 4, UART_LSR_THRE, UART_LSR_THRE);</span>
<span class="p_add">+	prom_putchar_wait(base + UART_LSR * 4, BOTH_EMPTY, BOTH_EMPTY);</span>
 }
 
 static void prom_putchar_ar933x(unsigned char ch)
<span class="p_header">diff --git a/arch/mips/include/asm/cacheflush.h b/arch/mips/include/asm/cacheflush.h</span>
<span class="p_header">index e08381a37f8b..723229f4cf27 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/cacheflush.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/cacheflush.h</span>
<span class="p_chunk">@@ -29,6 +29,20 @@</span> <span class="p_context"></span>
  *  - flush_icache_all() flush the entire instruction cache
  *  - flush_data_cache_page() flushes a page from the data cache
  */
<span class="p_add">+</span>
<span class="p_add">+ /*</span>
<span class="p_add">+ * This flag is used to indicate that the page pointed to by a pte</span>
<span class="p_add">+ * is dirty and requires cleaning before returning it to the user.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define PG_dcache_dirty			PG_arch_1</span>
<span class="p_add">+</span>
<span class="p_add">+#define Page_dcache_dirty(page)		\</span>
<span class="p_add">+	test_bit(PG_dcache_dirty, &amp;(page)-&gt;flags)</span>
<span class="p_add">+#define SetPageDcacheDirty(page)	\</span>
<span class="p_add">+	set_bit(PG_dcache_dirty, &amp;(page)-&gt;flags)</span>
<span class="p_add">+#define ClearPageDcacheDirty(page)	\</span>
<span class="p_add">+	clear_bit(PG_dcache_dirty, &amp;(page)-&gt;flags)</span>
<span class="p_add">+</span>
 extern void (*flush_cache_all)(void);
 extern void (*__flush_cache_all)(void);
 extern void (*flush_cache_mm)(struct mm_struct *mm);
<span class="p_chunk">@@ -37,13 +51,15 @@</span> <span class="p_context"> extern void (*flush_cache_range)(struct vm_area_struct *vma,</span>
 	unsigned long start, unsigned long end);
 extern void (*flush_cache_page)(struct vm_area_struct *vma, unsigned long page, unsigned long pfn);
 extern void __flush_dcache_page(struct page *page);
<span class="p_add">+extern void __flush_icache_page(struct vm_area_struct *vma, struct page *page);</span>
 
 #define ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE 1
 static inline void flush_dcache_page(struct page *page)
 {
<span class="p_del">-	if (cpu_has_dc_aliases || !cpu_has_ic_fills_f_dc)</span>
<span class="p_add">+	if (cpu_has_dc_aliases)</span>
 		__flush_dcache_page(page);
<span class="p_del">-</span>
<span class="p_add">+	else if (!cpu_has_ic_fills_f_dc)</span>
<span class="p_add">+		SetPageDcacheDirty(page);</span>
 }
 
 #define flush_dcache_mmap_lock(mapping)		do { } while (0)
<span class="p_chunk">@@ -61,6 +77,11 @@</span> <span class="p_context"> static inline void flush_anon_page(struct vm_area_struct *vma,</span>
 static inline void flush_icache_page(struct vm_area_struct *vma,
 	struct page *page)
 {
<span class="p_add">+	if (!cpu_has_ic_fills_f_dc &amp;&amp; (vma-&gt;vm_flags &amp; VM_EXEC) &amp;&amp;</span>
<span class="p_add">+	    Page_dcache_dirty(page)) {</span>
<span class="p_add">+		__flush_icache_page(vma, page);</span>
<span class="p_add">+		ClearPageDcacheDirty(page);</span>
<span class="p_add">+	}</span>
 }
 
 extern void (*flush_icache_range)(unsigned long start, unsigned long end);
<span class="p_chunk">@@ -95,19 +116,6 @@</span> <span class="p_context"> extern void (*flush_icache_all)(void);</span>
 extern void (*local_flush_data_cache_page)(void * addr);
 extern void (*flush_data_cache_page)(unsigned long addr);
 
<span class="p_del">-/*</span>
<span class="p_del">- * This flag is used to indicate that the page pointed to by a pte</span>
<span class="p_del">- * is dirty and requires cleaning before returning it to the user.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define PG_dcache_dirty			PG_arch_1</span>
<span class="p_del">-</span>
<span class="p_del">-#define Page_dcache_dirty(page)		\</span>
<span class="p_del">-	test_bit(PG_dcache_dirty, &amp;(page)-&gt;flags)</span>
<span class="p_del">-#define SetPageDcacheDirty(page)	\</span>
<span class="p_del">-	set_bit(PG_dcache_dirty, &amp;(page)-&gt;flags)</span>
<span class="p_del">-#define ClearPageDcacheDirty(page)	\</span>
<span class="p_del">-	clear_bit(PG_dcache_dirty, &amp;(page)-&gt;flags)</span>
<span class="p_del">-</span>
 /* Run kernel code uncached, useful for cache probing functions. */
 unsigned long run_uncached(void *func);
 
<span class="p_header">diff --git a/arch/mips/include/asm/kvm_host.h b/arch/mips/include/asm/kvm_host.h</span>
<span class="p_header">index 5a8defbad431..5bddbc63fc3b 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -718,7 +718,7 @@</span> <span class="p_context"> extern enum emulation_result kvm_mips_complete_mmio_load(struct kvm_vcpu *vcpu,</span>
 
 uint32_t kvm_mips_read_count(struct kvm_vcpu *vcpu);
 void kvm_mips_write_count(struct kvm_vcpu *vcpu, uint32_t count);
<span class="p_del">-void kvm_mips_write_compare(struct kvm_vcpu *vcpu, uint32_t compare);</span>
<span class="p_add">+void kvm_mips_write_compare(struct kvm_vcpu *vcpu, uint32_t compare, bool ack);</span>
 void kvm_mips_init_count(struct kvm_vcpu *vcpu);
 int kvm_mips_set_count_ctl(struct kvm_vcpu *vcpu, s64 count_ctl);
 int kvm_mips_set_count_resume(struct kvm_vcpu *vcpu, s64 count_resume);
<span class="p_header">diff --git a/arch/mips/include/asm/msa.h b/arch/mips/include/asm/msa.h</span>
<span class="p_header">index 538f6d482db8..d2227285383f 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/msa.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/msa.h</span>
<span class="p_chunk">@@ -112,10 +112,10 @@</span> <span class="p_context"> static inline unsigned int read_msa_##name(void)		\</span>
 	&quot;	.set	push\n&quot;					\
 	&quot;	.set	noat\n&quot;					\
 	&quot;	.insn\n&quot;					\
<span class="p_del">-	&quot;	.word	#CFC_MSA_INSN | (&quot; #cs &quot; &lt;&lt; 11)\n&quot;	\</span>
<span class="p_add">+	&quot;	.word	%1 | (&quot; #cs &quot; &lt;&lt; 11)\n&quot;			\</span>
 	&quot;	move	%0, $1\n&quot;				\
 	&quot;	.set	pop\n&quot;					\
<span class="p_del">-	: &quot;=r&quot;(reg));						\</span>
<span class="p_add">+	: &quot;=r&quot;(reg) : &quot;i&quot;(CFC_MSA_INSN));			\</span>
 	return reg;						\
 }								\
 								\
<span class="p_chunk">@@ -126,9 +126,9 @@</span> <span class="p_context"> static inline void write_msa_##name(unsigned int val)		\</span>
 	&quot;	.set	noat\n&quot;					\
 	&quot;	move	$1, %0\n&quot;				\
 	&quot;	.insn\n&quot;					\
<span class="p_del">-	&quot;	.word	#CTC_MSA_INSN | (&quot; #cs &quot; &lt;&lt; 6)\n&quot;	\</span>
<span class="p_add">+	&quot;	.word	%1 | (&quot; #cs &quot; &lt;&lt; 6)\n&quot;			\</span>
 	&quot;	.set	pop\n&quot;					\
<span class="p_del">-	: : &quot;r&quot;(val));						\</span>
<span class="p_add">+	: : &quot;r&quot;(val), &quot;i&quot;(CTC_MSA_INSN));			\</span>
 }
 
 #endif /* !TOOLCHAIN_SUPPORTS_MSA */
<span class="p_header">diff --git a/arch/mips/include/asm/pgtable.h b/arch/mips/include/asm/pgtable.h</span>
<span class="p_header">index 784b58cdab3e..148a4766bf4d 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -167,20 +167,39 @@</span> <span class="p_context"> static inline void set_pte(pte_t *ptep, pte_t pteval)</span>
 		unsigned long page_global = _PAGE_GLOBAL;
 		unsigned long tmp;
 
<span class="p_del">-		__asm__ __volatile__ (</span>
<span class="p_del">-			&quot;	.set	push\n&quot;</span>
<span class="p_del">-			&quot;	.set	noreorder\n&quot;</span>
<span class="p_del">-			&quot;1:	&quot; LL_INSN &quot;	%[tmp], %[buddy]\n&quot;</span>
<span class="p_del">-			&quot;	bnez	%[tmp], 2f\n&quot;</span>
<span class="p_del">-			&quot;	 or	%[tmp], %[tmp], %[global]\n&quot;</span>
<span class="p_del">-			&quot;	&quot; SC_INSN &quot;	%[tmp], %[buddy]\n&quot;</span>
<span class="p_del">-			&quot;	beqz	%[tmp], 1b\n&quot;</span>
<span class="p_del">-			&quot;	 nop\n&quot;</span>
<span class="p_del">-			&quot;2:\n&quot;</span>
<span class="p_del">-			&quot;	.set pop&quot;</span>
<span class="p_del">-			: [buddy] &quot;+m&quot; (buddy-&gt;pte),</span>
<span class="p_del">-			  [tmp] &quot;=&amp;r&quot; (tmp)</span>
<span class="p_add">+		if (kernel_uses_llsc &amp;&amp; R10000_LLSC_WAR) {</span>
<span class="p_add">+			__asm__ __volatile__ (</span>
<span class="p_add">+			&quot;	.set	arch=r4000			\n&quot;</span>
<span class="p_add">+			&quot;	.set	push				\n&quot;</span>
<span class="p_add">+			&quot;	.set	noreorder			\n&quot;</span>
<span class="p_add">+			&quot;1:&quot;	LL_INSN	&quot; %[tmp], %[buddy]		\n&quot;</span>
<span class="p_add">+			&quot;	bnez	%[tmp], 2f			\n&quot;</span>
<span class="p_add">+			&quot;	 or	%[tmp], %[tmp], %[global]	\n&quot;</span>
<span class="p_add">+				SC_INSN	&quot; %[tmp], %[buddy]		\n&quot;</span>
<span class="p_add">+			&quot;	beqzl	%[tmp], 1b			\n&quot;</span>
<span class="p_add">+			&quot;	nop					\n&quot;</span>
<span class="p_add">+			&quot;2:						\n&quot;</span>
<span class="p_add">+			&quot;	.set	pop				\n&quot;</span>
<span class="p_add">+			&quot;	.set	mips0				\n&quot;</span>
<span class="p_add">+			: [buddy] &quot;+m&quot; (buddy-&gt;pte), [tmp] &quot;=&amp;r&quot; (tmp)</span>
 			: [global] &quot;r&quot; (page_global));
<span class="p_add">+		} else if (kernel_uses_llsc) {</span>
<span class="p_add">+			__asm__ __volatile__ (</span>
<span class="p_add">+			&quot;	.set	arch=r4000			\n&quot;</span>
<span class="p_add">+			&quot;	.set	push				\n&quot;</span>
<span class="p_add">+			&quot;	.set	noreorder			\n&quot;</span>
<span class="p_add">+			&quot;1:&quot;	LL_INSN	&quot; %[tmp], %[buddy]		\n&quot;</span>
<span class="p_add">+			&quot;	bnez	%[tmp], 2f			\n&quot;</span>
<span class="p_add">+			&quot;	 or	%[tmp], %[tmp], %[global]	\n&quot;</span>
<span class="p_add">+				SC_INSN	&quot; %[tmp], %[buddy]		\n&quot;</span>
<span class="p_add">+			&quot;	beqz	%[tmp], 1b			\n&quot;</span>
<span class="p_add">+			&quot;	nop					\n&quot;</span>
<span class="p_add">+			&quot;2:						\n&quot;</span>
<span class="p_add">+			&quot;	.set	pop				\n&quot;</span>
<span class="p_add">+			&quot;	.set	mips0				\n&quot;</span>
<span class="p_add">+			: [buddy] &quot;+m&quot; (buddy-&gt;pte), [tmp] &quot;=&amp;r&quot; (tmp)</span>
<span class="p_add">+			: [global] &quot;r&quot; (page_global));</span>
<span class="p_add">+		}</span>
 #else /* !CONFIG_SMP */
 		if (pte_none(*buddy))
 			pte_val(*buddy) = pte_val(*buddy) | _PAGE_GLOBAL;
<span class="p_header">diff --git a/arch/mips/include/uapi/asm/siginfo.h b/arch/mips/include/uapi/asm/siginfo.h</span>
<span class="p_header">index e81174432bab..6e1218ae916c 100644</span>
<span class="p_header">--- a/arch/mips/include/uapi/asm/siginfo.h</span>
<span class="p_header">+++ b/arch/mips/include/uapi/asm/siginfo.h</span>
<span class="p_chunk">@@ -48,13 +48,13 @@</span> <span class="p_context"> typedef struct siginfo {</span>
 
 		/* kill() */
 		struct {
<span class="p_del">-			pid_t _pid;		/* sender&#39;s pid */</span>
<span class="p_add">+			__kernel_pid_t _pid;	/* sender&#39;s pid */</span>
 			__ARCH_SI_UID_T _uid;	/* sender&#39;s uid */
 		} _kill;
 
 		/* POSIX.1b timers */
 		struct {
<span class="p_del">-			timer_t _tid;		/* timer id */</span>
<span class="p_add">+			__kernel_timer_t _tid;	/* timer id */</span>
 			int _overrun;		/* overrun count */
 			char _pad[sizeof( __ARCH_SI_UID_T) - sizeof(int)];
 			sigval_t _sigval;	/* same as below */
<span class="p_chunk">@@ -63,26 +63,26 @@</span> <span class="p_context"> typedef struct siginfo {</span>
 
 		/* POSIX.1b signals */
 		struct {
<span class="p_del">-			pid_t _pid;		/* sender&#39;s pid */</span>
<span class="p_add">+			__kernel_pid_t _pid;	/* sender&#39;s pid */</span>
 			__ARCH_SI_UID_T _uid;	/* sender&#39;s uid */
 			sigval_t _sigval;
 		} _rt;
 
 		/* SIGCHLD */
 		struct {
<span class="p_del">-			pid_t _pid;		/* which child */</span>
<span class="p_add">+			__kernel_pid_t _pid;	/* which child */</span>
 			__ARCH_SI_UID_T _uid;	/* sender&#39;s uid */
 			int _status;		/* exit code */
<span class="p_del">-			clock_t _utime;</span>
<span class="p_del">-			clock_t _stime;</span>
<span class="p_add">+			__kernel_clock_t _utime;</span>
<span class="p_add">+			__kernel_clock_t _stime;</span>
 		} _sigchld;
 
 		/* IRIX SIGCHLD */
 		struct {
<span class="p_del">-			pid_t _pid;		/* which child */</span>
<span class="p_del">-			clock_t _utime;</span>
<span class="p_add">+			__kernel_pid_t _pid;	/* which child */</span>
<span class="p_add">+			__kernel_clock_t _utime;</span>
 			int _status;		/* exit code */
<span class="p_del">-			clock_t _stime;</span>
<span class="p_add">+			__kernel_clock_t _stime;</span>
 		} _irix_sigchld;
 
 		/* SIGILL, SIGFPE, SIGSEGV, SIGBUS */
<span class="p_header">diff --git a/arch/mips/kernel/bmips_vec.S b/arch/mips/kernel/bmips_vec.S</span>
<span class="p_header">index 290c23b51678..d4614d31d828 100644</span>
<span class="p_header">--- a/arch/mips/kernel/bmips_vec.S</span>
<span class="p_header">+++ b/arch/mips/kernel/bmips_vec.S</span>
<span class="p_chunk">@@ -93,7 +93,8 @@</span> <span class="p_context"> NESTED(bmips_reset_nmi_vec, PT_SIZE, sp)</span>
 #if defined(CONFIG_CPU_BMIPS5000)
 	mfc0	k0, CP0_PRID
 	li	k1, PRID_IMP_BMIPS5000
<span class="p_del">-	andi	k0, 0xff00</span>
<span class="p_add">+	/* mask with PRID_IMP_BMIPS5000 to cover both variants */</span>
<span class="p_add">+	andi	k0, PRID_IMP_BMIPS5000</span>
 	bne	k0, k1, 1f
 
 	/* if we&#39;re not on core 0, this must be the SMP boot signal */
<span class="p_chunk">@@ -166,10 +167,12 @@</span> <span class="p_context"> bmips_smp_entry:</span>
 2:
 #endif /* CONFIG_CPU_BMIPS4350 || CONFIG_CPU_BMIPS4380 */
 #if defined(CONFIG_CPU_BMIPS5000)
<span class="p_del">-	/* set exception vector base */</span>
<span class="p_add">+	/* mask with PRID_IMP_BMIPS5000 to cover both variants */</span>
 	li	k1, PRID_IMP_BMIPS5000
<span class="p_add">+	andi	k0, PRID_IMP_BMIPS5000</span>
 	bne	k0, k1, 3f
 
<span class="p_add">+	/* set exception vector base */</span>
 	la	k0, ebase
 	lw	k0, 0(k0)
 	mtc0	k0, $15, 1
<span class="p_chunk">@@ -264,6 +267,8 @@</span> <span class="p_context"> LEAF(bmips_enable_xks01)</span>
 #endif /* CONFIG_CPU_BMIPS4380 */
 #if defined(CONFIG_CPU_BMIPS5000)
 	li	t1, PRID_IMP_BMIPS5000
<span class="p_add">+	/* mask with PRID_IMP_BMIPS5000 to cover both variants */</span>
<span class="p_add">+	andi	t2, PRID_IMP_BMIPS5000</span>
 	bne	t2, t1, 2f
 
 	mfc0	t0, $22, 5
<span class="p_header">diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c</span>
<span class="p_header">index 0a1ec0f3beff..f206dd3c1b4f 100644</span>
<span class="p_header">--- a/arch/mips/kernel/process.c</span>
<span class="p_header">+++ b/arch/mips/kernel/process.c</span>
<span class="p_chunk">@@ -489,7 +489,7 @@</span> <span class="p_context"> unsigned long notrace unwind_stack_by_address(unsigned long stack_page,</span>
 		    *sp + sizeof(*regs) &lt;= stack_page + THREAD_SIZE - 32) {
 			regs = (struct pt_regs *)*sp;
 			pc = regs-&gt;cp0_epc;
<span class="p_del">-			if (__kernel_text_address(pc)) {</span>
<span class="p_add">+			if (!user_mode(regs) &amp;&amp; __kernel_text_address(pc)) {</span>
 				*sp = regs-&gt;regs[29];
 				*ra = regs-&gt;regs[31];
 				return pc;
<span class="p_header">diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c</span>
<span class="p_header">index bdf9139fd92b..2868b3927cb4 100644</span>
<span class="p_header">--- a/arch/mips/kernel/traps.c</span>
<span class="p_header">+++ b/arch/mips/kernel/traps.c</span>
<span class="p_chunk">@@ -140,7 +140,7 @@</span> <span class="p_context"> static void show_backtrace(struct task_struct *task, const struct pt_regs *regs)</span>
 	if (!task)
 		task = current;
 
<span class="p_del">-	if (raw_show_trace || !__kernel_text_address(pc)) {</span>
<span class="p_add">+	if (raw_show_trace || user_mode(regs) || !__kernel_text_address(pc)) {</span>
 		show_raw_backtrace(sp);
 		return;
 	}
<span class="p_header">diff --git a/arch/mips/kvm/kvm_mips_emul.c b/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_header">index 950229176c2f..1983678883c9 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_chunk">@@ -310,12 +310,31 @@</span> <span class="p_context"> static inline ktime_t kvm_mips_count_time(struct kvm_vcpu *vcpu)</span>
  */
 static uint32_t kvm_mips_read_count_running(struct kvm_vcpu *vcpu, ktime_t now)
 {
<span class="p_del">-	ktime_t expires;</span>
<span class="p_add">+	struct mips_coproc *cop0 = vcpu-&gt;arch.cop0;</span>
<span class="p_add">+	ktime_t expires, threshold;</span>
<span class="p_add">+	uint32_t count, compare;</span>
 	int running;
 
<span class="p_del">-	/* Is the hrtimer pending? */</span>
<span class="p_add">+	/* Calculate the biased and scaled guest CP0_Count */</span>
<span class="p_add">+	count = vcpu-&gt;arch.count_bias + kvm_mips_ktime_to_count(vcpu, now);</span>
<span class="p_add">+	compare = kvm_read_c0_guest_compare(cop0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Find whether CP0_Count has reached the closest timer interrupt. If</span>
<span class="p_add">+	 * not, we shouldn&#39;t inject it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((int32_t)(count - compare) &lt; 0)</span>
<span class="p_add">+		return count;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The CP0_Count we&#39;re going to return has already reached the closest</span>
<span class="p_add">+	 * timer interrupt. Quickly check if it really is a new interrupt by</span>
<span class="p_add">+	 * looking at whether the interval until the hrtimer expiry time is</span>
<span class="p_add">+	 * less than 1/4 of the timer period.</span>
<span class="p_add">+	 */</span>
 	expires = hrtimer_get_expires(&amp;vcpu-&gt;arch.comparecount_timer);
<span class="p_del">-	if (ktime_compare(now, expires) &gt;= 0) {</span>
<span class="p_add">+	threshold = ktime_add_ns(now, vcpu-&gt;arch.count_period / 4);</span>
<span class="p_add">+	if (ktime_before(expires, threshold)) {</span>
 		/*
 		 * Cancel it while we handle it so there&#39;s no chance of
 		 * interference with the timeout handler.
<span class="p_chunk">@@ -337,8 +356,7 @@</span> <span class="p_context"> static uint32_t kvm_mips_read_count_running(struct kvm_vcpu *vcpu, ktime_t now)</span>
 		}
 	}
 
<span class="p_del">-	/* Return the biased and scaled guest CP0_Count */</span>
<span class="p_del">-	return vcpu-&gt;arch.count_bias + kvm_mips_ktime_to_count(vcpu, now);</span>
<span class="p_add">+	return count;</span>
 }
 
 /**
<span class="p_chunk">@@ -429,32 +447,6 @@</span> <span class="p_context"> static void kvm_mips_resume_hrtimer(struct kvm_vcpu *vcpu,</span>
 }
 
 /**
<span class="p_del">- * kvm_mips_update_hrtimer() - Update next expiry time of hrtimer.</span>
<span class="p_del">- * @vcpu:	Virtual CPU.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Recalculates and updates the expiry time of the hrtimer. This can be used</span>
<span class="p_del">- * after timer parameters have been altered which do not depend on the time that</span>
<span class="p_del">- * the change occurs (in those cases kvm_mips_freeze_hrtimer() and</span>
<span class="p_del">- * kvm_mips_resume_hrtimer() are used directly).</span>
<span class="p_del">- *</span>
<span class="p_del">- * It is guaranteed that no timer interrupts will be lost in the process.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Assumes !kvm_mips_count_disabled(@vcpu) (guest CP0_Count timer is running).</span>
<span class="p_del">- */</span>
<span class="p_del">-static void kvm_mips_update_hrtimer(struct kvm_vcpu *vcpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	ktime_t now;</span>
<span class="p_del">-	uint32_t count;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * freeze_hrtimer takes care of a timer interrupts &lt;= count, and</span>
<span class="p_del">-	 * resume_hrtimer the hrtimer takes care of a timer interrupts &gt; count.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	now = kvm_mips_freeze_hrtimer(vcpu, &amp;count);</span>
<span class="p_del">-	kvm_mips_resume_hrtimer(vcpu, now, count);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
  * kvm_mips_write_count() - Modify the count and update timer.
  * @vcpu:	Virtual CPU.
  * @count:	Guest CP0_Count value to set.
<span class="p_chunk">@@ -549,23 +541,42 @@</span> <span class="p_context"> int kvm_mips_set_count_hz(struct kvm_vcpu *vcpu, s64 count_hz)</span>
  * kvm_mips_write_compare() - Modify compare and update timer.
  * @vcpu:	Virtual CPU.
  * @compare:	New CP0_Compare value.
<span class="p_add">+ * @ack:	Whether to acknowledge timer interrupt.</span>
  *
  * Update CP0_Compare to a new value and update the timeout.
<span class="p_add">+ * If @ack, atomically acknowledge any pending timer interrupt, otherwise ensure</span>
<span class="p_add">+ * any pending timer interrupt is preserved.</span>
  */
<span class="p_del">-void kvm_mips_write_compare(struct kvm_vcpu *vcpu, uint32_t compare)</span>
<span class="p_add">+void kvm_mips_write_compare(struct kvm_vcpu *vcpu, uint32_t compare, bool ack)</span>
 {
 	struct mips_coproc *cop0 = vcpu-&gt;arch.cop0;
<span class="p_add">+	int dc;</span>
<span class="p_add">+	u32 old_compare = kvm_read_c0_guest_compare(cop0);</span>
<span class="p_add">+	ktime_t now;</span>
<span class="p_add">+	uint32_t count;</span>
 
 	/* if unchanged, must just be an ack */
<span class="p_del">-	if (kvm_read_c0_guest_compare(cop0) == compare)</span>
<span class="p_add">+	if (old_compare == compare) {</span>
<span class="p_add">+		if (!ack)</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		kvm_mips_callbacks-&gt;dequeue_timer_int(vcpu);</span>
<span class="p_add">+		kvm_write_c0_guest_compare(cop0, compare);</span>
 		return;
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* freeze_hrtimer() takes care of timer interrupts &lt;= count */</span>
<span class="p_add">+	dc = kvm_mips_count_disabled(vcpu);</span>
<span class="p_add">+	if (!dc)</span>
<span class="p_add">+		now = kvm_mips_freeze_hrtimer(vcpu, &amp;count);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ack)</span>
<span class="p_add">+		kvm_mips_callbacks-&gt;dequeue_timer_int(vcpu);</span>
 
<span class="p_del">-	/* Update compare */</span>
 	kvm_write_c0_guest_compare(cop0, compare);
 
<span class="p_del">-	/* Update timeout if count enabled */</span>
<span class="p_del">-	if (!kvm_mips_count_disabled(vcpu))</span>
<span class="p_del">-		kvm_mips_update_hrtimer(vcpu);</span>
<span class="p_add">+	/* resume_hrtimer() takes care of timer interrupts &gt; count */</span>
<span class="p_add">+	if (!dc)</span>
<span class="p_add">+		kvm_mips_resume_hrtimer(vcpu, now, count);</span>
 }
 
 /**
<span class="p_chunk">@@ -1043,9 +1054,9 @@</span> <span class="p_context"> kvm_mips_emulate_CP0(uint32_t inst, uint32_t *opc, uint32_t cause,</span>
 
 				/* If we are writing to COMPARE */
 				/* Clear pending timer interrupt, if any */
<span class="p_del">-				kvm_mips_callbacks-&gt;dequeue_timer_int(vcpu);</span>
 				kvm_mips_write_compare(vcpu,
<span class="p_del">-						       vcpu-&gt;arch.gprs[rt]);</span>
<span class="p_add">+						       vcpu-&gt;arch.gprs[rt],</span>
<span class="p_add">+						       true);</span>
 			} else if ((rd == MIPS_CP0_STATUS) &amp;&amp; (sel == 0)) {
 				kvm_write_c0_guest_status(cop0,
 							  vcpu-&gt;arch.gprs[rt]);
<span class="p_header">diff --git a/arch/mips/kvm/kvm_trap_emul.c b/arch/mips/kvm/kvm_trap_emul.c</span>
<span class="p_header">index 0c521c356553..69c605e9d201 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_trap_emul.c</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_trap_emul.c</span>
<span class="p_chunk">@@ -451,7 +451,7 @@</span> <span class="p_context"> static int kvm_trap_emul_set_one_reg(struct kvm_vcpu *vcpu,</span>
 		kvm_mips_write_count(vcpu, v);
 		break;
 	case KVM_REG_MIPS_CP0_COMPARE:
<span class="p_del">-		kvm_mips_write_compare(vcpu, v);</span>
<span class="p_add">+		kvm_mips_write_compare(vcpu, v, false);</span>
 		break;
 	case KVM_REG_MIPS_CP0_CAUSE:
 		/*
<span class="p_header">diff --git a/arch/mips/math-emu/cp1emu.c b/arch/mips/math-emu/cp1emu.c</span>
<span class="p_header">index 51a0fde4bec1..bc5ab0dbdf91 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/cp1emu.c</span>
<span class="p_header">+++ b/arch/mips/math-emu/cp1emu.c</span>
<span class="p_chunk">@@ -443,9 +443,11 @@</span> <span class="p_context"> static int isBranchInstr(struct pt_regs *regs, struct mm_decoded_insn dec_insn,</span>
 	case spec_op:
 		switch (insn.r_format.func) {
 		case jalr_op:
<span class="p_del">-			regs-&gt;regs[insn.r_format.rd] =</span>
<span class="p_del">-				regs-&gt;cp0_epc + dec_insn.pc_inc +</span>
<span class="p_del">-				dec_insn.next_pc_inc;</span>
<span class="p_add">+			if (insn.r_format.rd != 0) {</span>
<span class="p_add">+				regs-&gt;regs[insn.r_format.rd] =</span>
<span class="p_add">+					regs-&gt;cp0_epc + dec_insn.pc_inc +</span>
<span class="p_add">+					dec_insn.next_pc_inc;</span>
<span class="p_add">+			}</span>
 			/* Fall through */
 		case jr_op:
 			*contpc = regs-&gt;regs[insn.r_format.rs];
<span class="p_header">diff --git a/arch/mips/mm/cache.c b/arch/mips/mm/cache.c</span>
<span class="p_header">index f7b91d3a371d..77d96db8253c 100644</span>
<span class="p_header">--- a/arch/mips/mm/cache.c</span>
<span class="p_header">+++ b/arch/mips/mm/cache.c</span>
<span class="p_chunk">@@ -119,6 +119,18 @@</span> <span class="p_context"> void __flush_anon_page(struct page *page, unsigned long vmaddr)</span>
 
 EXPORT_SYMBOL(__flush_anon_page);
 
<span class="p_add">+void __flush_icache_page(struct vm_area_struct *vma, struct page *page)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long addr;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (PageHighMem(page))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	addr = (unsigned long) page_address(page);</span>
<span class="p_add">+	flush_data_cache_page(addr);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(__flush_icache_page);</span>
<span class="p_add">+</span>
 void __update_cache(struct vm_area_struct *vma, unsigned long address,
 	pte_t pte)
 {
<span class="p_header">diff --git a/arch/parisc/kernel/unaligned.c b/arch/parisc/kernel/unaligned.c</span>
<span class="p_header">index d7c0acb35ec2..8d49614d600d 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/unaligned.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/unaligned.c</span>
<span class="p_chunk">@@ -666,7 +666,7 @@</span> <span class="p_context"> void handle_unaligned(struct pt_regs *regs)</span>
 		break;
 	}
 
<span class="p_del">-	if (modify &amp;&amp; R1(regs-&gt;iir))</span>
<span class="p_add">+	if (ret == 0 &amp;&amp; modify &amp;&amp; R1(regs-&gt;iir))</span>
 		regs-&gt;gr[R1(regs-&gt;iir)] = newbase;
 
 
<span class="p_chunk">@@ -677,6 +677,14 @@</span> <span class="p_context"> void handle_unaligned(struct pt_regs *regs)</span>
 
 	if (ret)
 	{
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The unaligned handler failed.</span>
<span class="p_add">+		 * If we were called by __get_user() or __put_user() jump</span>
<span class="p_add">+		 * to it&#39;s exception fixup handler instead of crashing.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!user_mode(regs) &amp;&amp; fixup_exception(regs))</span>
<span class="p_add">+			return;</span>
<span class="p_add">+</span>
 		printk(KERN_CRIT &quot;Unaligned handler failed, ret = %d\n&quot;, ret);
 		die_if_kernel(&quot;Unaligned data reference&quot;, regs, 28);
 
<span class="p_header">diff --git a/arch/powerpc/Kconfig b/arch/powerpc/Kconfig</span>
<span class="p_header">index 80b94b0add1f..5ff5ab0411b3 100644</span>
<span class="p_header">--- a/arch/powerpc/Kconfig</span>
<span class="p_header">+++ b/arch/powerpc/Kconfig</span>
<span class="p_chunk">@@ -124,7 +124,7 @@</span> <span class="p_context"> config PPC</span>
 	select IRQ_FORCED_THREADING
 	select HAVE_RCU_TABLE_FREE if SMP
 	select HAVE_SYSCALL_TRACEPOINTS
<span class="p_del">-	select HAVE_BPF_JIT if PPC64</span>
<span class="p_add">+	select HAVE_BPF_JIT if PPC64 &amp;&amp; CPU_BIG_ENDIAN</span>
 	select HAVE_ARCH_JUMP_LABEL
 	select ARCH_HAVE_NMI_SAFE_CMPXCHG
 	select GENERIC_SMP_IDLE_THREAD
<span class="p_header">diff --git a/arch/powerpc/include/asm/reg.h b/arch/powerpc/include/asm/reg.h</span>
<span class="p_header">index c34b2d302f0e..5df8e5cde4a6 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/reg.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/reg.h</span>
<span class="p_chunk">@@ -704,7 +704,7 @@</span> <span class="p_context"></span>
 #define   MMCR0_FCWAIT	0x00000002UL /* freeze counter in WAIT state */
 #define   MMCR0_FCHV	0x00000001UL /* freeze conditions in hypervisor mode */
 #define SPRN_MMCR1	798
<span class="p_del">-#define SPRN_MMCR2	769</span>
<span class="p_add">+#define SPRN_MMCR2	785</span>
 #define SPRN_MMCRA	0x312
 #define   MMCRA_SDSYNC	0x80000000UL /* SDAR synced with SIAR */
 #define   MMCRA_SDAR_DCACHE_MISS 0x40000000UL
<span class="p_chunk">@@ -740,13 +740,13 @@</span> <span class="p_context"></span>
 #define SPRN_PMC6	792
 #define SPRN_PMC7	793
 #define SPRN_PMC8	794
<span class="p_del">-#define SPRN_SIAR	780</span>
<span class="p_del">-#define SPRN_SDAR	781</span>
 #define SPRN_SIER	784
 #define   SIER_SIPR		0x2000000	/* Sampled MSR_PR */
 #define   SIER_SIHV		0x1000000	/* Sampled MSR_HV */
 #define   SIER_SIAR_VALID	0x0400000	/* SIAR contents valid */
 #define   SIER_SDAR_VALID	0x0200000	/* SDAR contents valid */
<span class="p_add">+#define SPRN_SIAR	796</span>
<span class="p_add">+#define SPRN_SDAR	797</span>
 #define SPRN_TACR	888
 #define SPRN_TCSCR	889
 #define SPRN_CSIGR	890
<span class="p_header">diff --git a/arch/powerpc/kernel/exceptions-64s.S b/arch/powerpc/kernel/exceptions-64s.S</span>
<span class="p_header">index 246740cc796e..9ff25dcbfb87 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/exceptions-64s.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/exceptions-64s.S</span>
<span class="p_chunk">@@ -965,11 +965,6 @@</span> <span class="p_context"> hv_facility_unavailable_relon_trampoline:</span>
 #endif
 	STD_RELON_EXCEPTION_PSERIES(0x5700, 0x1700, altivec_assist)
 
<span class="p_del">-	/* Other future vectors */</span>
<span class="p_del">-	.align	7</span>
<span class="p_del">-	.globl	__end_interrupts</span>
<span class="p_del">-__end_interrupts:</span>
<span class="p_del">-</span>
 	.align	7
 system_call_entry_direct:
 #if defined(CONFIG_RELOCATABLE)
<span class="p_chunk">@@ -1323,6 +1318,17 @@</span> <span class="p_context"> __end_handlers:</span>
 	STD_RELON_EXCEPTION_PSERIES_OOL(0xf60, facility_unavailable)
 	STD_RELON_EXCEPTION_HV_OOL(0xf80, hv_facility_unavailable)
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The __end_interrupts marker must be past the out-of-line (OOL)</span>
<span class="p_add">+	 * handlers, so that they are copied to real address 0x100 when running</span>
<span class="p_add">+	 * a relocatable kernel. This ensures they can be reached from the short</span>
<span class="p_add">+	 * trampoline handlers (like 0x4f00, 0x4f20, etc.) which branch</span>
<span class="p_add">+	 * directly, without using LOAD_HANDLER().</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	.align	7</span>
<span class="p_add">+	.globl	__end_interrupts</span>
<span class="p_add">+__end_interrupts:</span>
<span class="p_add">+</span>
 #if defined(CONFIG_PPC_PSERIES) || defined(CONFIG_PPC_POWERNV)
 /*
  * Data area reserved for FWNMI option.
<span class="p_header">diff --git a/arch/powerpc/kernel/process.c b/arch/powerpc/kernel/process.c</span>
<span class="p_header">index 7ecc2f9dfa86..9a084ab1b78d 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/process.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/process.c</span>
<span class="p_chunk">@@ -1237,6 +1237,16 @@</span> <span class="p_context"> void start_thread(struct pt_regs *regs, unsigned long start, unsigned long sp)</span>
 		current-&gt;thread.regs = regs - 1;
 	}
 
<span class="p_add">+#ifdef CONFIG_PPC_TRANSACTIONAL_MEM</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Clear any transactional state, we&#39;re exec()ing. The cause is</span>
<span class="p_add">+	 * not important as there will never be a recheckpoint so it&#39;s not</span>
<span class="p_add">+	 * user visible.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (MSR_TM_SUSPENDED(mfmsr()))</span>
<span class="p_add">+		tm_reclaim_current(0);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	memset(regs-&gt;gpr, 0, sizeof(regs-&gt;gpr));
 	regs-&gt;ctr = 0;
 	regs-&gt;link = 0;
<span class="p_header">diff --git a/arch/powerpc/kernel/tm.S b/arch/powerpc/kernel/tm.S</span>
<span class="p_header">index 2a324f4cb1b9..f81d900a562a 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/tm.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/tm.S</span>
<span class="p_chunk">@@ -110,17 +110,11 @@</span> <span class="p_context"> _GLOBAL(tm_reclaim)</span>
 	std	r3, STK_PARAM(R3)(r1)
 	SAVE_NVGPRS(r1)
 
<span class="p_del">-	/* We need to setup MSR for VSX register save instructions.  Here we</span>
<span class="p_del">-	 * also clear the MSR RI since when we do the treclaim, we won&#39;t have a</span>
<span class="p_del">-	 * valid kernel pointer for a while.  We clear RI here as it avoids</span>
<span class="p_del">-	 * adding another mtmsr closer to the treclaim.  This makes the region</span>
<span class="p_del">-	 * maked as non-recoverable wider than it needs to be but it saves on</span>
<span class="p_del">-	 * inserting another mtmsrd later.</span>
<span class="p_del">-	 */</span>
<span class="p_add">+	/* We need to setup MSR for VSX register save instructions. */</span>
 	mfmsr	r14
 	mr	r15, r14
 	ori	r15, r15, MSR_FP
<span class="p_del">-	li	r16, MSR_RI</span>
<span class="p_add">+	li	r16, 0</span>
 	ori	r16, r16, MSR_EE /* IRQs hard off */
 	andc	r15, r15, r16
 	oris	r15, r15, MSR_VEC@h
<span class="p_chunk">@@ -176,7 +170,17 @@</span> <span class="p_context"> dont_backup_fp:</span>
 1:	tdeqi   r6, 0
 	EMIT_BUG_ENTRY 1b,__FILE__,__LINE__,0
 
<span class="p_del">-	/* The moment we treclaim, ALL of our GPRs will switch</span>
<span class="p_add">+	/* Clear MSR RI since we are about to change r1, EE is already off. */</span>
<span class="p_add">+	li	r4, 0</span>
<span class="p_add">+	mtmsrd	r4, 1</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * BE CAREFUL HERE:</span>
<span class="p_add">+	 * At this point we can&#39;t take an SLB miss since we have MSR_RI</span>
<span class="p_add">+	 * off. Load only to/from the stack/paca which are in SLB bolted regions</span>
<span class="p_add">+	 * until we turn MSR RI back on.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * The moment we treclaim, ALL of our GPRs will switch</span>
 	 * to user register state.  (FPRs, CCR etc. also!)
 	 * Use an sprg and a tm_scratch in the PACA to shuffle.
 	 */
<span class="p_chunk">@@ -197,6 +201,11 @@</span> <span class="p_context"> dont_backup_fp:</span>
 
 	/* Store the PPR in r11 and reset to decent value */
 	std	r11, GPR11(r1)			/* Temporary stash */
<span class="p_add">+</span>
<span class="p_add">+	/* Reset MSR RI so we can take SLB faults again */</span>
<span class="p_add">+	li	r11, MSR_RI</span>
<span class="p_add">+	mtmsrd	r11, 1</span>
<span class="p_add">+</span>
 	mfspr	r11, SPRN_PPR
 	HMT_MEDIUM
 
<span class="p_chunk">@@ -397,11 +406,6 @@</span> <span class="p_context"> restore_gprs:</span>
 	ld	r5, THREAD_TM_DSCR(r3)
 	ld	r6, THREAD_TM_PPR(r3)
 
<span class="p_del">-	/* Clear the MSR RI since we are about to change R1.  EE is already off</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	li	r4, 0</span>
<span class="p_del">-	mtmsrd	r4, 1</span>
<span class="p_del">-</span>
 	REST_GPR(0, r7)				/* GPR0 */
 	REST_2GPRS(2, r7)			/* GPR2-3 */
 	REST_GPR(4, r7)				/* GPR4 */
<span class="p_chunk">@@ -439,10 +443,33 @@</span> <span class="p_context"> restore_gprs:</span>
 	ld	r6, _CCR(r7)
 	mtcr    r6
 
<span class="p_del">-	REST_GPR(1, r7)				/* GPR1 */</span>
<span class="p_del">-	REST_GPR(5, r7)				/* GPR5-7 */</span>
 	REST_GPR(6, r7)
<span class="p_del">-	ld	r7, GPR7(r7)</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Store r1 and r5 on the stack so that we can access them</span>
<span class="p_add">+	 * after we clear MSR RI.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	REST_GPR(5, r7)</span>
<span class="p_add">+	std	r5, -8(r1)</span>
<span class="p_add">+	ld	r5, GPR1(r7)</span>
<span class="p_add">+	std	r5, -16(r1)</span>
<span class="p_add">+</span>
<span class="p_add">+	REST_GPR(7, r7)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Clear MSR RI since we are about to change r1. EE is already off */</span>
<span class="p_add">+	li	r5, 0</span>
<span class="p_add">+	mtmsrd	r5, 1</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * BE CAREFUL HERE:</span>
<span class="p_add">+	 * At this point we can&#39;t take an SLB miss since we have MSR_RI</span>
<span class="p_add">+	 * off. Load only to/from the stack/paca which are in SLB bolted regions</span>
<span class="p_add">+	 * until we turn MSR RI back on.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	ld	r5, -8(r1)</span>
<span class="p_add">+	ld	r1, -16(r1)</span>
 
 	/* Commit register state as checkpointed state: */
 	TRECHKPT
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv_rmhandlers.S b/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_header">index f3197994b733..2f0c1394efa8 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_chunk">@@ -628,112 +628,8 @@</span> <span class="p_context"> END_FTR_SECTION_IFCLR(CPU_FTR_ARCH_207S)</span>
 
 #ifdef CONFIG_PPC_TRANSACTIONAL_MEM
 BEGIN_FTR_SECTION
<span class="p_del">-	b	skip_tm</span>
<span class="p_del">-END_FTR_SECTION_IFCLR(CPU_FTR_TM)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Turn on TM/FP/VSX/VMX so we can restore them. */</span>
<span class="p_del">-	mfmsr	r5</span>
<span class="p_del">-	li	r6, MSR_TM &gt;&gt; 32</span>
<span class="p_del">-	sldi	r6, r6, 32</span>
<span class="p_del">-	or	r5, r5, r6</span>
<span class="p_del">-	ori	r5, r5, MSR_FP</span>
<span class="p_del">-	oris	r5, r5, (MSR_VEC | MSR_VSX)@h</span>
<span class="p_del">-	mtmsrd	r5</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The user may change these outside of a transaction, so they must</span>
<span class="p_del">-	 * always be context switched.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ld	r5, VCPU_TFHAR(r4)</span>
<span class="p_del">-	ld	r6, VCPU_TFIAR(r4)</span>
<span class="p_del">-	ld	r7, VCPU_TEXASR(r4)</span>
<span class="p_del">-	mtspr	SPRN_TFHAR, r5</span>
<span class="p_del">-	mtspr	SPRN_TFIAR, r6</span>
<span class="p_del">-	mtspr	SPRN_TEXASR, r7</span>
<span class="p_del">-</span>
<span class="p_del">-	ld	r5, VCPU_MSR(r4)</span>
<span class="p_del">-	rldicl. r5, r5, 64 - MSR_TS_S_LG, 62</span>
<span class="p_del">-	beq	skip_tm	/* TM not active in guest */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Make sure the failure summary is set, otherwise we&#39;ll program check</span>
<span class="p_del">-	 * when we trechkpt.  It&#39;s possible that this might have been not set</span>
<span class="p_del">-	 * on a kvmppc_set_one_reg() call but we shouldn&#39;t let this crash the</span>
<span class="p_del">-	 * host.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	oris	r7, r7, (TEXASR_FS)@h</span>
<span class="p_del">-	mtspr	SPRN_TEXASR, r7</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We need to load up the checkpointed state for the guest.</span>
<span class="p_del">-	 * We need to do this early as it will blow away any GPRs, VSRs and</span>
<span class="p_del">-	 * some SPRs.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-</span>
<span class="p_del">-	mr	r31, r4</span>
<span class="p_del">-	addi	r3, r31, VCPU_FPRS_TM</span>
<span class="p_del">-	bl	.load_fp_state</span>
<span class="p_del">-	addi	r3, r31, VCPU_VRS_TM</span>
<span class="p_del">-	bl	.load_vr_state</span>
<span class="p_del">-	mr	r4, r31</span>
<span class="p_del">-	lwz	r7, VCPU_VRSAVE_TM(r4)</span>
<span class="p_del">-	mtspr	SPRN_VRSAVE, r7</span>
<span class="p_del">-</span>
<span class="p_del">-	ld	r5, VCPU_LR_TM(r4)</span>
<span class="p_del">-	lwz	r6, VCPU_CR_TM(r4)</span>
<span class="p_del">-	ld	r7, VCPU_CTR_TM(r4)</span>
<span class="p_del">-	ld	r8, VCPU_AMR_TM(r4)</span>
<span class="p_del">-	ld	r9, VCPU_TAR_TM(r4)</span>
<span class="p_del">-	mtlr	r5</span>
<span class="p_del">-	mtcr	r6</span>
<span class="p_del">-	mtctr	r7</span>
<span class="p_del">-	mtspr	SPRN_AMR, r8</span>
<span class="p_del">-	mtspr	SPRN_TAR, r9</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Load up PPR and DSCR values but don&#39;t put them in the actual SPRs</span>
<span class="p_del">-	 * till the last moment to avoid running with userspace PPR and DSCR for</span>
<span class="p_del">-	 * too long.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ld	r29, VCPU_DSCR_TM(r4)</span>
<span class="p_del">-	ld	r30, VCPU_PPR_TM(r4)</span>
<span class="p_del">-</span>
<span class="p_del">-	std	r2, PACATMSCRATCH(r13) /* Save TOC */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Clear the MSR RI since r1, r13 are all going to be foobar. */</span>
<span class="p_del">-	li	r5, 0</span>
<span class="p_del">-	mtmsrd	r5, 1</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Load GPRs r0-r28 */</span>
<span class="p_del">-	reg = 0</span>
<span class="p_del">-	.rept	29</span>
<span class="p_del">-	ld	reg, VCPU_GPRS_TM(reg)(r31)</span>
<span class="p_del">-	reg = reg + 1</span>
<span class="p_del">-	.endr</span>
<span class="p_del">-</span>
<span class="p_del">-	mtspr	SPRN_DSCR, r29</span>
<span class="p_del">-	mtspr	SPRN_PPR, r30</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Load final GPRs */</span>
<span class="p_del">-	ld	29, VCPU_GPRS_TM(29)(r31)</span>
<span class="p_del">-	ld	30, VCPU_GPRS_TM(30)(r31)</span>
<span class="p_del">-	ld	31, VCPU_GPRS_TM(31)(r31)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* TM checkpointed state is now setup.  All GPRs are now volatile. */</span>
<span class="p_del">-	TRECHKPT</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Now let&#39;s get back the state we need. */</span>
<span class="p_del">-	HMT_MEDIUM</span>
<span class="p_del">-	GET_PACA(r13)</span>
<span class="p_del">-	ld	r29, HSTATE_DSCR(r13)</span>
<span class="p_del">-	mtspr	SPRN_DSCR, r29</span>
<span class="p_del">-	ld	r4, HSTATE_KVM_VCPU(r13)</span>
<span class="p_del">-	ld	r1, HSTATE_HOST_R1(r13)</span>
<span class="p_del">-	ld	r2, PACATMSCRATCH(r13)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Set the MSR RI since we have our registers back. */</span>
<span class="p_del">-	li	r5, MSR_RI</span>
<span class="p_del">-	mtmsrd	r5, 1</span>
<span class="p_del">-skip_tm:</span>
<span class="p_add">+	bl	kvmppc_restore_tm</span>
<span class="p_add">+END_FTR_SECTION_IFSET(CPU_FTR_TM)</span>
 #endif
 
 	/* Load guest PMU registers */
<span class="p_chunk">@@ -824,12 +720,6 @@</span> <span class="p_context"> BEGIN_FTR_SECTION</span>
 	/* Skip next section on POWER7 or PPC970 */
 	b	8f
 END_FTR_SECTION_IFCLR(CPU_FTR_ARCH_207S)
<span class="p_del">-	/* Turn on TM so we can access TFHAR/TFIAR/TEXASR */</span>
<span class="p_del">-	mfmsr	r8</span>
<span class="p_del">-	li	r0, 1</span>
<span class="p_del">-	rldimi	r8, r0, MSR_TM_LG, 63-MSR_TM_LG</span>
<span class="p_del">-	mtmsrd	r8</span>
<span class="p_del">-</span>
 	/* Load up POWER8-specific registers */
 	ld	r5, VCPU_IAMR(r4)
 	lwz	r6, VCPU_PSPB(r4)
<span class="p_chunk">@@ -1350,106 +1240,8 @@</span> <span class="p_context"> END_FTR_SECTION_IFSET(CPU_FTR_ARCH_206)</span>
 
 #ifdef CONFIG_PPC_TRANSACTIONAL_MEM
 BEGIN_FTR_SECTION
<span class="p_del">-	b	2f</span>
<span class="p_del">-END_FTR_SECTION_IFCLR(CPU_FTR_TM)</span>
<span class="p_del">-	/* Turn on TM. */</span>
<span class="p_del">-	mfmsr	r8</span>
<span class="p_del">-	li	r0, 1</span>
<span class="p_del">-	rldimi	r8, r0, MSR_TM_LG, 63-MSR_TM_LG</span>
<span class="p_del">-	mtmsrd	r8</span>
<span class="p_del">-</span>
<span class="p_del">-	ld	r5, VCPU_MSR(r9)</span>
<span class="p_del">-	rldicl. r5, r5, 64 - MSR_TS_S_LG, 62</span>
<span class="p_del">-	beq	1f	/* TM not active in guest. */</span>
<span class="p_del">-</span>
<span class="p_del">-	li	r3, TM_CAUSE_KVM_RESCHED</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Clear the MSR RI since r1, r13 are all going to be foobar. */</span>
<span class="p_del">-	li	r5, 0</span>
<span class="p_del">-	mtmsrd	r5, 1</span>
<span class="p_del">-</span>
<span class="p_del">-	/* All GPRs are volatile at this point. */</span>
<span class="p_del">-	TRECLAIM(R3)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Temporarily store r13 and r9 so we have some regs to play with */</span>
<span class="p_del">-	SET_SCRATCH0(r13)</span>
<span class="p_del">-	GET_PACA(r13)</span>
<span class="p_del">-	std	r9, PACATMSCRATCH(r13)</span>
<span class="p_del">-	ld	r9, HSTATE_KVM_VCPU(r13)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Get a few more GPRs free. */</span>
<span class="p_del">-	std	r29, VCPU_GPRS_TM(29)(r9)</span>
<span class="p_del">-	std	r30, VCPU_GPRS_TM(30)(r9)</span>
<span class="p_del">-	std	r31, VCPU_GPRS_TM(31)(r9)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Save away PPR and DSCR soon so don&#39;t run with user values. */</span>
<span class="p_del">-	mfspr	r31, SPRN_PPR</span>
<span class="p_del">-	HMT_MEDIUM</span>
<span class="p_del">-	mfspr	r30, SPRN_DSCR</span>
<span class="p_del">-	ld	r29, HSTATE_DSCR(r13)</span>
<span class="p_del">-	mtspr	SPRN_DSCR, r29</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Save all but r9, r13 &amp; r29-r31 */</span>
<span class="p_del">-	reg = 0</span>
<span class="p_del">-	.rept	29</span>
<span class="p_del">-	.if (reg != 9) &amp;&amp; (reg != 13)</span>
<span class="p_del">-	std	reg, VCPU_GPRS_TM(reg)(r9)</span>
<span class="p_del">-	.endif</span>
<span class="p_del">-	reg = reg + 1</span>
<span class="p_del">-	.endr</span>
<span class="p_del">-	/* ... now save r13 */</span>
<span class="p_del">-	GET_SCRATCH0(r4)</span>
<span class="p_del">-	std	r4, VCPU_GPRS_TM(13)(r9)</span>
<span class="p_del">-	/* ... and save r9 */</span>
<span class="p_del">-	ld	r4, PACATMSCRATCH(r13)</span>
<span class="p_del">-	std	r4, VCPU_GPRS_TM(9)(r9)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Reload stack pointer and TOC. */</span>
<span class="p_del">-	ld	r1, HSTATE_HOST_R1(r13)</span>
<span class="p_del">-	ld	r2, PACATOC(r13)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Set MSR RI now we have r1 and r13 back. */</span>
<span class="p_del">-	li	r5, MSR_RI</span>
<span class="p_del">-	mtmsrd	r5, 1</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Save away checkpinted SPRs. */</span>
<span class="p_del">-	std	r31, VCPU_PPR_TM(r9)</span>
<span class="p_del">-	std	r30, VCPU_DSCR_TM(r9)</span>
<span class="p_del">-	mflr	r5</span>
<span class="p_del">-	mfcr	r6</span>
<span class="p_del">-	mfctr	r7</span>
<span class="p_del">-	mfspr	r8, SPRN_AMR</span>
<span class="p_del">-	mfspr	r10, SPRN_TAR</span>
<span class="p_del">-	std	r5, VCPU_LR_TM(r9)</span>
<span class="p_del">-	stw	r6, VCPU_CR_TM(r9)</span>
<span class="p_del">-	std	r7, VCPU_CTR_TM(r9)</span>
<span class="p_del">-	std	r8, VCPU_AMR_TM(r9)</span>
<span class="p_del">-	std	r10, VCPU_TAR_TM(r9)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Restore r12 as trap number. */</span>
<span class="p_del">-	lwz	r12, VCPU_TRAP(r9)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Save FP/VSX. */</span>
<span class="p_del">-	addi	r3, r9, VCPU_FPRS_TM</span>
<span class="p_del">-	bl	.store_fp_state</span>
<span class="p_del">-	addi	r3, r9, VCPU_VRS_TM</span>
<span class="p_del">-	bl	.store_vr_state</span>
<span class="p_del">-	mfspr	r6, SPRN_VRSAVE</span>
<span class="p_del">-	stw	r6, VCPU_VRSAVE_TM(r9)</span>
<span class="p_del">-1:</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We need to save these SPRs after the treclaim so that the software</span>
<span class="p_del">-	 * error code is recorded correctly in the TEXASR.  Also the user may</span>
<span class="p_del">-	 * change these outside of a transaction, so they must always be</span>
<span class="p_del">-	 * context switched.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	mfspr	r5, SPRN_TFHAR</span>
<span class="p_del">-	mfspr	r6, SPRN_TFIAR</span>
<span class="p_del">-	mfspr	r7, SPRN_TEXASR</span>
<span class="p_del">-	std	r5, VCPU_TFHAR(r9)</span>
<span class="p_del">-	std	r6, VCPU_TFIAR(r9)</span>
<span class="p_del">-	std	r7, VCPU_TEXASR(r9)</span>
<span class="p_del">-2:</span>
<span class="p_add">+	bl	kvmppc_save_tm</span>
<span class="p_add">+END_FTR_SECTION_IFSET(CPU_FTR_TM)</span>
 #endif
 
 	/* Increment yield count if they have a VPA */
<span class="p_chunk">@@ -2162,6 +1954,13 @@</span> <span class="p_context"> END_FTR_SECTION_IFCLR(CPU_FTR_ARCH_206)</span>
 	/* save FP state */
 	bl	kvmppc_save_fp
 
<span class="p_add">+#ifdef CONFIG_PPC_TRANSACTIONAL_MEM</span>
<span class="p_add">+BEGIN_FTR_SECTION</span>
<span class="p_add">+	ld	r9, HSTATE_KVM_VCPU(r13)</span>
<span class="p_add">+	bl	kvmppc_save_tm</span>
<span class="p_add">+END_FTR_SECTION_IFSET(CPU_FTR_TM)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	/*
 	 * Take a nap until a decrementer or external or doobell interrupt
 	 * occurs, with PECE1, PECE0 and PECEDP set in LPCR. Also clear the
<span class="p_chunk">@@ -2201,6 +2000,12 @@</span> <span class="p_context"> kvm_end_cede:</span>
 	/* Woken by external or decrementer interrupt */
 	ld	r1, HSTATE_HOST_R1(r13)
 
<span class="p_add">+#ifdef CONFIG_PPC_TRANSACTIONAL_MEM</span>
<span class="p_add">+BEGIN_FTR_SECTION</span>
<span class="p_add">+	bl	kvmppc_restore_tm</span>
<span class="p_add">+END_FTR_SECTION_IFSET(CPU_FTR_TM)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	/* load up FP state */
 	bl	kvmppc_load_fp
 
<span class="p_chunk">@@ -2471,6 +2276,239 @@</span> <span class="p_context"> END_FTR_SECTION_IFSET(CPU_FTR_ALTIVEC)</span>
 	mr	r4,r31
 	blr
 
<span class="p_add">+#ifdef CONFIG_PPC_TRANSACTIONAL_MEM</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Save transactional state and TM-related registers.</span>
<span class="p_add">+ * Called with r9 pointing to the vcpu struct.</span>
<span class="p_add">+ * This can modify all checkpointed registers, but</span>
<span class="p_add">+ * restores r1, r2 and r9 (vcpu pointer) before exit.</span>
<span class="p_add">+ */</span>
<span class="p_add">+kvmppc_save_tm:</span>
<span class="p_add">+	mflr	r0</span>
<span class="p_add">+	std	r0, PPC_LR_STKOFF(r1)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Turn on TM. */</span>
<span class="p_add">+	mfmsr	r8</span>
<span class="p_add">+	li	r0, 1</span>
<span class="p_add">+	rldimi	r8, r0, MSR_TM_LG, 63-MSR_TM_LG</span>
<span class="p_add">+	mtmsrd	r8</span>
<span class="p_add">+</span>
<span class="p_add">+	ld	r5, VCPU_MSR(r9)</span>
<span class="p_add">+	rldicl. r5, r5, 64 - MSR_TS_S_LG, 62</span>
<span class="p_add">+	beq	1f	/* TM not active in guest. */</span>
<span class="p_add">+</span>
<span class="p_add">+	std	r1, HSTATE_HOST_R1(r13)</span>
<span class="p_add">+	li	r3, TM_CAUSE_KVM_RESCHED</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Clear the MSR RI since r1, r13 are all going to be foobar. */</span>
<span class="p_add">+	li	r5, 0</span>
<span class="p_add">+	mtmsrd	r5, 1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* All GPRs are volatile at this point. */</span>
<span class="p_add">+	TRECLAIM(R3)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Temporarily store r13 and r9 so we have some regs to play with */</span>
<span class="p_add">+	SET_SCRATCH0(r13)</span>
<span class="p_add">+	GET_PACA(r13)</span>
<span class="p_add">+	std	r9, PACATMSCRATCH(r13)</span>
<span class="p_add">+	ld	r9, HSTATE_KVM_VCPU(r13)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Get a few more GPRs free. */</span>
<span class="p_add">+	std	r29, VCPU_GPRS_TM(29)(r9)</span>
<span class="p_add">+	std	r30, VCPU_GPRS_TM(30)(r9)</span>
<span class="p_add">+	std	r31, VCPU_GPRS_TM(31)(r9)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save away PPR and DSCR soon so don&#39;t run with user values. */</span>
<span class="p_add">+	mfspr	r31, SPRN_PPR</span>
<span class="p_add">+	HMT_MEDIUM</span>
<span class="p_add">+	mfspr	r30, SPRN_DSCR</span>
<span class="p_add">+	ld	r29, HSTATE_DSCR(r13)</span>
<span class="p_add">+	mtspr	SPRN_DSCR, r29</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save all but r9, r13 &amp; r29-r31 */</span>
<span class="p_add">+	reg = 0</span>
<span class="p_add">+	.rept	29</span>
<span class="p_add">+	.if (reg != 9) &amp;&amp; (reg != 13)</span>
<span class="p_add">+	std	reg, VCPU_GPRS_TM(reg)(r9)</span>
<span class="p_add">+	.endif</span>
<span class="p_add">+	reg = reg + 1</span>
<span class="p_add">+	.endr</span>
<span class="p_add">+	/* ... now save r13 */</span>
<span class="p_add">+	GET_SCRATCH0(r4)</span>
<span class="p_add">+	std	r4, VCPU_GPRS_TM(13)(r9)</span>
<span class="p_add">+	/* ... and save r9 */</span>
<span class="p_add">+	ld	r4, PACATMSCRATCH(r13)</span>
<span class="p_add">+	std	r4, VCPU_GPRS_TM(9)(r9)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Reload stack pointer and TOC. */</span>
<span class="p_add">+	ld	r1, HSTATE_HOST_R1(r13)</span>
<span class="p_add">+	ld	r2, PACATOC(r13)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set MSR RI now we have r1 and r13 back. */</span>
<span class="p_add">+	li	r5, MSR_RI</span>
<span class="p_add">+	mtmsrd	r5, 1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save away checkpinted SPRs. */</span>
<span class="p_add">+	std	r31, VCPU_PPR_TM(r9)</span>
<span class="p_add">+	std	r30, VCPU_DSCR_TM(r9)</span>
<span class="p_add">+	mflr	r5</span>
<span class="p_add">+	mfcr	r6</span>
<span class="p_add">+	mfctr	r7</span>
<span class="p_add">+	mfspr	r8, SPRN_AMR</span>
<span class="p_add">+	mfspr	r10, SPRN_TAR</span>
<span class="p_add">+	std	r5, VCPU_LR_TM(r9)</span>
<span class="p_add">+	stw	r6, VCPU_CR_TM(r9)</span>
<span class="p_add">+	std	r7, VCPU_CTR_TM(r9)</span>
<span class="p_add">+	std	r8, VCPU_AMR_TM(r9)</span>
<span class="p_add">+	std	r10, VCPU_TAR_TM(r9)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Restore r12 as trap number. */</span>
<span class="p_add">+	lwz	r12, VCPU_TRAP(r9)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save FP/VSX. */</span>
<span class="p_add">+	addi	r3, r9, VCPU_FPRS_TM</span>
<span class="p_add">+	bl	.store_fp_state</span>
<span class="p_add">+	addi	r3, r9, VCPU_VRS_TM</span>
<span class="p_add">+	bl	.store_vr_state</span>
<span class="p_add">+	mfspr	r6, SPRN_VRSAVE</span>
<span class="p_add">+	stw	r6, VCPU_VRSAVE_TM(r9)</span>
<span class="p_add">+1:</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to save these SPRs after the treclaim so that the software</span>
<span class="p_add">+	 * error code is recorded correctly in the TEXASR.  Also the user may</span>
<span class="p_add">+	 * change these outside of a transaction, so they must always be</span>
<span class="p_add">+	 * context switched.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mfspr	r5, SPRN_TFHAR</span>
<span class="p_add">+	mfspr	r6, SPRN_TFIAR</span>
<span class="p_add">+	mfspr	r7, SPRN_TEXASR</span>
<span class="p_add">+	std	r5, VCPU_TFHAR(r9)</span>
<span class="p_add">+	std	r6, VCPU_TFIAR(r9)</span>
<span class="p_add">+	std	r7, VCPU_TEXASR(r9)</span>
<span class="p_add">+</span>
<span class="p_add">+	ld	r0, PPC_LR_STKOFF(r1)</span>
<span class="p_add">+	mtlr	r0</span>
<span class="p_add">+	blr</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Restore transactional state and TM-related registers.</span>
<span class="p_add">+ * Called with r4 pointing to the vcpu struct.</span>
<span class="p_add">+ * This potentially modifies all checkpointed registers.</span>
<span class="p_add">+ * It restores r1, r2, r4 from the PACA.</span>
<span class="p_add">+ */</span>
<span class="p_add">+kvmppc_restore_tm:</span>
<span class="p_add">+	mflr	r0</span>
<span class="p_add">+	std	r0, PPC_LR_STKOFF(r1)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Turn on TM/FP/VSX/VMX so we can restore them. */</span>
<span class="p_add">+	mfmsr	r5</span>
<span class="p_add">+	li	r6, MSR_TM &gt;&gt; 32</span>
<span class="p_add">+	sldi	r6, r6, 32</span>
<span class="p_add">+	or	r5, r5, r6</span>
<span class="p_add">+	ori	r5, r5, MSR_FP</span>
<span class="p_add">+	oris	r5, r5, (MSR_VEC | MSR_VSX)@h</span>
<span class="p_add">+	mtmsrd	r5</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The user may change these outside of a transaction, so they must</span>
<span class="p_add">+	 * always be context switched.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ld	r5, VCPU_TFHAR(r4)</span>
<span class="p_add">+	ld	r6, VCPU_TFIAR(r4)</span>
<span class="p_add">+	ld	r7, VCPU_TEXASR(r4)</span>
<span class="p_add">+	mtspr	SPRN_TFHAR, r5</span>
<span class="p_add">+	mtspr	SPRN_TFIAR, r6</span>
<span class="p_add">+	mtspr	SPRN_TEXASR, r7</span>
<span class="p_add">+</span>
<span class="p_add">+	ld	r5, VCPU_MSR(r4)</span>
<span class="p_add">+	rldicl. r5, r5, 64 - MSR_TS_S_LG, 62</span>
<span class="p_add">+	beqlr		/* TM not active in guest */</span>
<span class="p_add">+	std	r1, HSTATE_HOST_R1(r13)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Make sure the failure summary is set, otherwise we&#39;ll program check</span>
<span class="p_add">+	 * when we trechkpt.  It&#39;s possible that this might have been not set</span>
<span class="p_add">+	 * on a kvmppc_set_one_reg() call but we shouldn&#39;t let this crash the</span>
<span class="p_add">+	 * host.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	oris	r7, r7, (TEXASR_FS)@h</span>
<span class="p_add">+	mtspr	SPRN_TEXASR, r7</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to load up the checkpointed state for the guest.</span>
<span class="p_add">+	 * We need to do this early as it will blow away any GPRs, VSRs and</span>
<span class="p_add">+	 * some SPRs.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	mr	r31, r4</span>
<span class="p_add">+	addi	r3, r31, VCPU_FPRS_TM</span>
<span class="p_add">+	bl	.load_fp_state</span>
<span class="p_add">+	addi	r3, r31, VCPU_VRS_TM</span>
<span class="p_add">+	bl	.load_vr_state</span>
<span class="p_add">+	mr	r4, r31</span>
<span class="p_add">+	lwz	r7, VCPU_VRSAVE_TM(r4)</span>
<span class="p_add">+	mtspr	SPRN_VRSAVE, r7</span>
<span class="p_add">+</span>
<span class="p_add">+	ld	r5, VCPU_LR_TM(r4)</span>
<span class="p_add">+	lwz	r6, VCPU_CR_TM(r4)</span>
<span class="p_add">+	ld	r7, VCPU_CTR_TM(r4)</span>
<span class="p_add">+	ld	r8, VCPU_AMR_TM(r4)</span>
<span class="p_add">+	ld	r9, VCPU_TAR_TM(r4)</span>
<span class="p_add">+	mtlr	r5</span>
<span class="p_add">+	mtcr	r6</span>
<span class="p_add">+	mtctr	r7</span>
<span class="p_add">+	mtspr	SPRN_AMR, r8</span>
<span class="p_add">+	mtspr	SPRN_TAR, r9</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Load up PPR and DSCR values but don&#39;t put them in the actual SPRs</span>
<span class="p_add">+	 * till the last moment to avoid running with userspace PPR and DSCR for</span>
<span class="p_add">+	 * too long.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ld	r29, VCPU_DSCR_TM(r4)</span>
<span class="p_add">+	ld	r30, VCPU_PPR_TM(r4)</span>
<span class="p_add">+</span>
<span class="p_add">+	std	r2, PACATMSCRATCH(r13) /* Save TOC */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Clear the MSR RI since r1, r13 are all going to be foobar. */</span>
<span class="p_add">+	li	r5, 0</span>
<span class="p_add">+	mtmsrd	r5, 1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Load GPRs r0-r28 */</span>
<span class="p_add">+	reg = 0</span>
<span class="p_add">+	.rept	29</span>
<span class="p_add">+	ld	reg, VCPU_GPRS_TM(reg)(r31)</span>
<span class="p_add">+	reg = reg + 1</span>
<span class="p_add">+	.endr</span>
<span class="p_add">+</span>
<span class="p_add">+	mtspr	SPRN_DSCR, r29</span>
<span class="p_add">+	mtspr	SPRN_PPR, r30</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Load final GPRs */</span>
<span class="p_add">+	ld	29, VCPU_GPRS_TM(29)(r31)</span>
<span class="p_add">+	ld	30, VCPU_GPRS_TM(30)(r31)</span>
<span class="p_add">+	ld	31, VCPU_GPRS_TM(31)(r31)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* TM checkpointed state is now setup.  All GPRs are now volatile. */</span>
<span class="p_add">+	TRECHKPT</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Now let&#39;s get back the state we need. */</span>
<span class="p_add">+	HMT_MEDIUM</span>
<span class="p_add">+	GET_PACA(r13)</span>
<span class="p_add">+	ld	r29, HSTATE_DSCR(r13)</span>
<span class="p_add">+	mtspr	SPRN_DSCR, r29</span>
<span class="p_add">+	ld	r4, HSTATE_KVM_VCPU(r13)</span>
<span class="p_add">+	ld	r1, HSTATE_HOST_R1(r13)</span>
<span class="p_add">+	ld	r2, PACATMSCRATCH(r13)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set the MSR RI since we have our registers back. */</span>
<span class="p_add">+	li	r5, MSR_RI</span>
<span class="p_add">+	mtmsrd	r5, 1</span>
<span class="p_add">+</span>
<span class="p_add">+	ld	r0, PPC_LR_STKOFF(r1)</span>
<span class="p_add">+	mtlr	r0</span>
<span class="p_add">+	blr</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /*
  * We come here if we get any exception or interrupt while we are
  * executing host real mode code while in guest MMU context.
<span class="p_header">diff --git a/arch/powerpc/mm/hash_utils_64.c b/arch/powerpc/mm/hash_utils_64.c</span>
<span class="p_header">index 88fdd9d25077..8089998dbca3 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/hash_utils_64.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/hash_utils_64.c</span>
<span class="p_chunk">@@ -1196,6 +1196,30 @@</span> <span class="p_context"> bail:</span>
 }
 EXPORT_SYMBOL_GPL(hash_page);
 
<span class="p_add">+#ifdef CONFIG_PPC_MM_SLICES</span>
<span class="p_add">+static bool should_hash_preload(struct mm_struct *mm, unsigned long ea)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int psize = get_slice_psize(mm, ea);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We only prefault standard pages for now */</span>
<span class="p_add">+	if (unlikely(psize != mm-&gt;context.user_psize))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Don&#39;t prefault if subpage protection is enabled for the EA.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely((psize == MMU_PAGE_4K) &amp;&amp; subpage_protection(mm, ea)))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+static bool should_hash_preload(struct mm_struct *mm, unsigned long ea)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 void hash_preload(struct mm_struct *mm, unsigned long ea,
 		  unsigned long access, unsigned long trap)
 {
<span class="p_chunk">@@ -1208,11 +1232,8 @@</span> <span class="p_context"> void hash_preload(struct mm_struct *mm, unsigned long ea,</span>
 
 	BUG_ON(REGION_ID(ea) != USER_REGION_ID);
 
<span class="p_del">-#ifdef CONFIG_PPC_MM_SLICES</span>
<span class="p_del">-	/* We only prefault standard pages for now */</span>
<span class="p_del">-	if (unlikely(get_slice_psize(mm, ea) != mm-&gt;context.user_psize))</span>
<span class="p_add">+	if (!should_hash_preload(mm, ea))</span>
 		return;
<span class="p_del">-#endif</span>
 
 	DBG_LOW(&quot;hash_preload(mm=%p, mm-&gt;pgdir=%p, ea=%016lx, access=%lx,&quot;
 		&quot; trap=%lx\n&quot;, mm, mm-&gt;pgd, ea, access, trap);
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/eeh_pseries.c b/arch/powerpc/platforms/pseries/eeh_pseries.c</span>
<span class="p_header">index 0bec0c02c5e7..16ab240847d4 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/eeh_pseries.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/eeh_pseries.c</span>
<span class="p_chunk">@@ -655,29 +655,50 @@</span> <span class="p_context"> static int pseries_eeh_configure_bridge(struct eeh_pe *pe)</span>
 {
 	int config_addr;
 	int ret;
<span class="p_add">+	/* Waiting 0.2s maximum before skipping configuration */</span>
<span class="p_add">+	int max_wait = 200;</span>
 
 	/* Figure out the PE address */
 	config_addr = pe-&gt;config_addr;
 	if (pe-&gt;addr)
 		config_addr = pe-&gt;addr;
 
<span class="p_del">-	/* Use new configure-pe function, if supported */</span>
<span class="p_del">-	if (ibm_configure_pe != RTAS_UNKNOWN_SERVICE) {</span>
<span class="p_del">-		ret = rtas_call(ibm_configure_pe, 3, 1, NULL,</span>
<span class="p_del">-				config_addr, BUID_HI(pe-&gt;phb-&gt;buid),</span>
<span class="p_del">-				BUID_LO(pe-&gt;phb-&gt;buid));</span>
<span class="p_del">-	} else if (ibm_configure_bridge != RTAS_UNKNOWN_SERVICE) {</span>
<span class="p_del">-		ret = rtas_call(ibm_configure_bridge, 3, 1, NULL,</span>
<span class="p_del">-				config_addr, BUID_HI(pe-&gt;phb-&gt;buid),</span>
<span class="p_del">-				BUID_LO(pe-&gt;phb-&gt;buid));</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	while (max_wait &gt; 0) {</span>
<span class="p_add">+		/* Use new configure-pe function, if supported */</span>
<span class="p_add">+		if (ibm_configure_pe != RTAS_UNKNOWN_SERVICE) {</span>
<span class="p_add">+			ret = rtas_call(ibm_configure_pe, 3, 1, NULL,</span>
<span class="p_add">+					config_addr, BUID_HI(pe-&gt;phb-&gt;buid),</span>
<span class="p_add">+					BUID_LO(pe-&gt;phb-&gt;buid));</span>
<span class="p_add">+		} else if (ibm_configure_bridge != RTAS_UNKNOWN_SERVICE) {</span>
<span class="p_add">+			ret = rtas_call(ibm_configure_bridge, 3, 1, NULL,</span>
<span class="p_add">+					config_addr, BUID_HI(pe-&gt;phb-&gt;buid),</span>
<span class="p_add">+					BUID_LO(pe-&gt;phb-&gt;buid));</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		pr_warning(&quot;%s: Unable to configure bridge PHB#%d-PE#%x (%d)\n&quot;,</span>
<span class="p_del">-			__func__, pe-&gt;phb-&gt;global_number, pe-&gt;addr, ret);</span>
<span class="p_add">+		if (!ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If RTAS returns a delay value that&#39;s above 100ms, cut it</span>
<span class="p_add">+		 * down to 100ms in case firmware made a mistake.  For more</span>
<span class="p_add">+		 * on how these delay values work see rtas_busy_delay_time</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (ret &gt; RTAS_EXTENDED_DELAY_MIN+2 &amp;&amp;</span>
<span class="p_add">+		    ret &lt;= RTAS_EXTENDED_DELAY_MAX)</span>
<span class="p_add">+			ret = RTAS_EXTENDED_DELAY_MIN+2;</span>
<span class="p_add">+</span>
<span class="p_add">+		max_wait -= rtas_busy_delay_time(ret);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (max_wait &lt; 0)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		rtas_busy_delay(ret);</span>
<span class="p_add">+	}</span>
 
<span class="p_add">+	pr_warn(&quot;%s: Unable to configure bridge PHB#%d-PE#%x (%d)\n&quot;,</span>
<span class="p_add">+		__func__, pe-&gt;phb-&gt;global_number, pe-&gt;addr, ret);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/iommu.c b/arch/powerpc/platforms/pseries/iommu.c</span>
<span class="p_header">index 78723292c883..ed874816d7f4 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/iommu.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/iommu.c</span>
<span class="p_chunk">@@ -826,7 +826,8 @@</span> <span class="p_context"> machine_arch_initcall(pseries, find_existing_ddw_windows);</span>
 static int query_ddw(struct pci_dev *dev, const u32 *ddw_avail,
 			struct ddw_query_response *query)
 {
<span class="p_del">-	struct eeh_dev *edev;</span>
<span class="p_add">+	struct device_node *dn;</span>
<span class="p_add">+	struct pci_dn *pdn;</span>
 	u32 cfg_addr;
 	u64 buid;
 	int ret;
<span class="p_chunk">@@ -837,11 +838,10 @@</span> <span class="p_context"> static int query_ddw(struct pci_dev *dev, const u32 *ddw_avail,</span>
 	 * Retrieve them from the pci device, not the node with the
 	 * dma-window property
 	 */
<span class="p_del">-	edev = pci_dev_to_eeh_dev(dev);</span>
<span class="p_del">-	cfg_addr = edev-&gt;config_addr;</span>
<span class="p_del">-	if (edev-&gt;pe_config_addr)</span>
<span class="p_del">-		cfg_addr = edev-&gt;pe_config_addr;</span>
<span class="p_del">-	buid = edev-&gt;phb-&gt;buid;</span>
<span class="p_add">+	dn = pci_device_to_OF_node(dev);</span>
<span class="p_add">+	pdn = PCI_DN(dn);</span>
<span class="p_add">+	buid = pdn-&gt;phb-&gt;buid;</span>
<span class="p_add">+	cfg_addr = ((pdn-&gt;busno &lt;&lt; 16) | (pdn-&gt;devfn &lt;&lt; 8));</span>
 
 	ret = rtas_call(ddw_avail[0], 3, 5, (u32 *)query,
 		  cfg_addr, BUID_HI(buid), BUID_LO(buid));
<span class="p_chunk">@@ -855,7 +855,8 @@</span> <span class="p_context"> static int create_ddw(struct pci_dev *dev, const u32 *ddw_avail,</span>
 			struct ddw_create_response *create, int page_shift,
 			int window_shift)
 {
<span class="p_del">-	struct eeh_dev *edev;</span>
<span class="p_add">+	struct device_node *dn;</span>
<span class="p_add">+	struct pci_dn *pdn;</span>
 	u32 cfg_addr;
 	u64 buid;
 	int ret;
<span class="p_chunk">@@ -866,11 +867,10 @@</span> <span class="p_context"> static int create_ddw(struct pci_dev *dev, const u32 *ddw_avail,</span>
 	 * Retrieve them from the pci device, not the node with the
 	 * dma-window property
 	 */
<span class="p_del">-	edev = pci_dev_to_eeh_dev(dev);</span>
<span class="p_del">-	cfg_addr = edev-&gt;config_addr;</span>
<span class="p_del">-	if (edev-&gt;pe_config_addr)</span>
<span class="p_del">-		cfg_addr = edev-&gt;pe_config_addr;</span>
<span class="p_del">-	buid = edev-&gt;phb-&gt;buid;</span>
<span class="p_add">+	dn = pci_device_to_OF_node(dev);</span>
<span class="p_add">+	pdn = PCI_DN(dn);</span>
<span class="p_add">+	buid = pdn-&gt;phb-&gt;buid;</span>
<span class="p_add">+	cfg_addr = ((pdn-&gt;busno &lt;&lt; 16) | (pdn-&gt;devfn &lt;&lt; 8));</span>
 
 	do {
 		/* extra outputs are LIOBN and dma-addr (hi, lo) */
<span class="p_header">diff --git a/arch/s390/include/asm/switch_to.h b/arch/s390/include/asm/switch_to.h</span>
<span class="p_header">index 18ea9e3f8142..716df3a992d0 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/switch_to.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/switch_to.h</span>
<span class="p_chunk">@@ -28,7 +28,7 @@</span> <span class="p_context"> static inline int test_fp_ctl(u32 fpc)</span>
 		&quot;	la	%0,0\n&quot;
 		&quot;1:\n&quot;
 		EX_TABLE(0b,1b)
<span class="p_del">-		: &quot;=d&quot; (rc), &quot;=d&quot; (orig_fpc)</span>
<span class="p_add">+		: &quot;=d&quot; (rc), &quot;=&amp;d&quot; (orig_fpc)</span>
 		: &quot;d&quot; (fpc), &quot;0&quot; (-EINVAL));
 	return rc;
 }
<span class="p_header">diff --git a/arch/s390/mm/vmem.c b/arch/s390/mm/vmem.c</span>
<span class="p_header">index fe9012a49aa5..4f0b2864fd76 100644</span>
<span class="p_header">--- a/arch/s390/mm/vmem.c</span>
<span class="p_header">+++ b/arch/s390/mm/vmem.c</span>
<span class="p_chunk">@@ -380,7 +380,7 @@</span> <span class="p_context"> void __init vmem_map_init(void)</span>
 	ro_end = (unsigned long)&amp;_eshared &amp; PAGE_MASK;
 	for_each_memblock(memory, reg) {
 		start = reg-&gt;base;
<span class="p_del">-		end = reg-&gt;base + reg-&gt;size - 1;</span>
<span class="p_add">+		end = reg-&gt;base + reg-&gt;size;</span>
 		if (start &gt;= ro_end || end &lt;= ro_start)
 			vmem_add_mem(start, end - start, 0);
 		else if (start &gt;= ro_start &amp;&amp; end &lt;= ro_end)
<span class="p_header">diff --git a/arch/x86/boot/Makefile b/arch/x86/boot/Makefile</span>
<span class="p_header">index dbe8dd2fe247..cd75e3e76efc 100644</span>
<span class="p_header">--- a/arch/x86/boot/Makefile</span>
<span class="p_header">+++ b/arch/x86/boot/Makefile</span>
<span class="p_chunk">@@ -156,6 +156,9 @@</span> <span class="p_context"> isoimage: $(obj)/bzImage</span>
 	for i in lib lib64 share end ; do \
 		if [ -f /usr/$$i/syslinux/isolinux.bin ] ; then \
 			cp /usr/$$i/syslinux/isolinux.bin $(obj)/isoimage ; \
<span class="p_add">+			if [ -f /usr/$$i/syslinux/ldlinux.c32 ]; then \</span>
<span class="p_add">+				cp /usr/$$i/syslinux/ldlinux.c32 $(obj)/isoimage ; \</span>
<span class="p_add">+			fi ; \</span>
 			break ; \
 		fi ; \
 		if [ $$i = end ] ; then exit 1 ; fi ; \
<span class="p_header">diff --git a/arch/x86/kernel/amd_nb.c b/arch/x86/kernel/amd_nb.c</span>
<span class="p_header">index f04dbb3069b8..29f0c55d6efc 100644</span>
<span class="p_header">--- a/arch/x86/kernel/amd_nb.c</span>
<span class="p_header">+++ b/arch/x86/kernel/amd_nb.c</span>
<span class="p_chunk">@@ -69,8 +69,8 @@</span> <span class="p_context"> int amd_cache_northbridges(void)</span>
 	while ((misc = next_northbridge(misc, amd_nb_misc_ids)) != NULL)
 		i++;
 
<span class="p_del">-	if (i == 0)</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+	if (!i)</span>
<span class="p_add">+		return -ENODEV;</span>
 
 	nb = kzalloc(i * sizeof(struct amd_northbridge), GFP_KERNEL);
 	if (!nb)
<span class="p_header">diff --git a/arch/x86/kernel/kprobes/core.c b/arch/x86/kernel/kprobes/core.c</span>
<span class="p_header">index f2e281cf8c19..a78aa118afc2 100644</span>
<span class="p_header">--- a/arch/x86/kernel/kprobes/core.c</span>
<span class="p_header">+++ b/arch/x86/kernel/kprobes/core.c</span>
<span class="p_chunk">@@ -931,7 +931,19 @@</span> <span class="p_context"> int kprobe_fault_handler(struct pt_regs *regs, int trapnr)</span>
 		 * normal page fault.
 		 */
 		regs-&gt;ip = (unsigned long)cur-&gt;addr;
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Trap flag (TF) has been set here because this fault</span>
<span class="p_add">+		 * happened where the single stepping will be done.</span>
<span class="p_add">+		 * So clear it by resetting the current kprobe:</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		regs-&gt;flags &amp;= ~X86_EFLAGS_TF;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If the TF flag was set before the kprobe hit,</span>
<span class="p_add">+		 * don&#39;t touch it:</span>
<span class="p_add">+		 */</span>
 		regs-&gt;flags |= kcb-&gt;kprobe_old_flags;
<span class="p_add">+</span>
 		if (kcb-&gt;kprobe_status == KPROBE_REENTER)
 			restore_previous_kprobe(kcb);
 		else
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index ba6f9822c474..4226d8fd93d1 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -3069,6 +3069,11 @@</span> <span class="p_context"> static int kvm_vcpu_ioctl_x86_set_debugregs(struct kvm_vcpu *vcpu,</span>
 	if (dbgregs-&gt;flags)
 		return -EINVAL;
 
<span class="p_add">+	if (dbgregs-&gt;dr6 &amp; ~0xffffffffull)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	if (dbgregs-&gt;dr7 &amp; ~0xffffffffull)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	memcpy(vcpu-&gt;arch.db, dbgregs-&gt;db, sizeof(vcpu-&gt;arch.db));
 	vcpu-&gt;arch.dr6 = dbgregs-&gt;dr6;
 	kvm_update_dr6(vcpu);
<span class="p_header">diff --git a/arch/x86/pci/fixup.c b/arch/x86/pci/fixup.c</span>
<span class="p_header">index f16af96c60a2..156fbb69031c 100644</span>
<span class="p_header">--- a/arch/x86/pci/fixup.c</span>
<span class="p_header">+++ b/arch/x86/pci/fixup.c</span>
<span class="p_chunk">@@ -554,9 +554,16 @@</span> <span class="p_context"> static void twinhead_reserve_killing_zone(struct pci_dev *dev)</span>
 }
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x27B9, twinhead_reserve_killing_zone);
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Broadwell EP Home Agent BARs erroneously return non-zero values when read.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * See http://www.intel.com/content/www/us/en/processors/xeon/xeon-e5-v4-spec-update.html</span>
<span class="p_add">+ * entry BDF2.</span>
<span class="p_add">+ */</span>
 static void pci_bdwep_bar(struct pci_dev *dev)
 {
 	dev-&gt;non_compliant_bars = 1;
 }
<span class="p_add">+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x6f60, pci_bdwep_bar);</span>
 DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x6fa0, pci_bdwep_bar);
 DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x6fc0, pci_bdwep_bar);
<span class="p_header">diff --git a/arch/x86/power/hibernate_64.c b/arch/x86/power/hibernate_64.c</span>
<span class="p_header">index 009947d419a6..f2b5e6a5cf95 100644</span>
<span class="p_header">--- a/arch/x86/power/hibernate_64.c</span>
<span class="p_header">+++ b/arch/x86/power/hibernate_64.c</span>
<span class="p_chunk">@@ -19,6 +19,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/mtrr.h&gt;
 #include &lt;asm/sections.h&gt;
 #include &lt;asm/suspend.h&gt;
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
 
 /* Defined in hibernate_asm_64.S */
 extern asmlinkage __visible int restore_image(void);
<span class="p_chunk">@@ -28,6 +29,7 @@</span> <span class="p_context"> extern asmlinkage __visible int restore_image(void);</span>
  * kernel&#39;s text (this value is passed in the image header).
  */
 unsigned long restore_jump_address __visible;
<span class="p_add">+unsigned long jump_address_phys;</span>
 
 /*
  * Value of the cr3 register from before the hibernation (this value is passed
<span class="p_chunk">@@ -37,7 +39,43 @@</span> <span class="p_context"> unsigned long restore_cr3 __visible;</span>
 
 pgd_t *temp_level4_pgt __visible;
 
<span class="p_del">-void *relocated_restore_code __visible;</span>
<span class="p_add">+unsigned long relocated_restore_code __visible;</span>
<span class="p_add">+</span>
<span class="p_add">+static int set_up_temporary_text_mapping(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pmd_t *pmd;</span>
<span class="p_add">+	pud_t *pud;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The new mapping only has to cover the page containing the image</span>
<span class="p_add">+	 * kernel&#39;s entry point (jump_address_phys), because the switch over to</span>
<span class="p_add">+	 * it is carried out by relocated code running from a page allocated</span>
<span class="p_add">+	 * specifically for this purpose and covered by the identity mapping, so</span>
<span class="p_add">+	 * the temporary kernel text mapping is only needed for the final jump.</span>
<span class="p_add">+	 * Moreover, in that mapping the virtual address of the image kernel&#39;s</span>
<span class="p_add">+	 * entry point must be the same as its virtual address in the image</span>
<span class="p_add">+	 * kernel (restore_jump_address), so the image kernel&#39;s</span>
<span class="p_add">+	 * restore_registers() code doesn&#39;t find itself in a different area of</span>
<span class="p_add">+	 * the virtual address space after switching over to the original page</span>
<span class="p_add">+	 * tables used by the image kernel.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pud = (pud_t *)get_safe_page(GFP_ATOMIC);</span>
<span class="p_add">+	if (!pud)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	pmd = (pmd_t *)get_safe_page(GFP_ATOMIC);</span>
<span class="p_add">+	if (!pmd)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	set_pmd(pmd + pmd_index(restore_jump_address),</span>
<span class="p_add">+		__pmd((jump_address_phys &amp; PMD_MASK) | __PAGE_KERNEL_LARGE_EXEC));</span>
<span class="p_add">+	set_pud(pud + pud_index(restore_jump_address),</span>
<span class="p_add">+		__pud(__pa(pmd) | _KERNPG_TABLE));</span>
<span class="p_add">+	set_pgd(temp_level4_pgt + pgd_index(restore_jump_address),</span>
<span class="p_add">+		__pgd(__pa(pud) | _KERNPG_TABLE));</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
 
 static void *alloc_pgt_page(void *context)
 {
<span class="p_chunk">@@ -59,9 +97,10 @@</span> <span class="p_context"> static int set_up_temporary_mappings(void)</span>
 	if (!temp_level4_pgt)
 		return -ENOMEM;
 
<span class="p_del">-	/* It is safe to reuse the original kernel mapping */</span>
<span class="p_del">-	set_pgd(temp_level4_pgt + pgd_index(__START_KERNEL_map),</span>
<span class="p_del">-		init_level4_pgt[pgd_index(__START_KERNEL_map)]);</span>
<span class="p_add">+	/* Prepare a temporary mapping for the kernel text */</span>
<span class="p_add">+	result = set_up_temporary_text_mapping();</span>
<span class="p_add">+	if (result)</span>
<span class="p_add">+		return result;</span>
 
 	/* Set up the direct mapping from scratch */
 	for (i = 0; i &lt; nr_pfn_mapped; i++) {
<span class="p_chunk">@@ -78,19 +117,50 @@</span> <span class="p_context"> static int set_up_temporary_mappings(void)</span>
 	return 0;
 }
 
<span class="p_add">+static int relocate_restore_code(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pgd_t *pgd;</span>
<span class="p_add">+	pud_t *pud;</span>
<span class="p_add">+</span>
<span class="p_add">+	relocated_restore_code = get_safe_page(GFP_ATOMIC);</span>
<span class="p_add">+	if (!relocated_restore_code)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy((void *)relocated_restore_code, &amp;core_restore_code, PAGE_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Make the page containing the relocated code executable */</span>
<span class="p_add">+	pgd = (pgd_t *)__va(read_cr3()) + pgd_index(relocated_restore_code);</span>
<span class="p_add">+	pud = pud_offset(pgd, relocated_restore_code);</span>
<span class="p_add">+	if (pud_large(*pud)) {</span>
<span class="p_add">+		set_pud(pud, __pud(pud_val(*pud) &amp; ~_PAGE_NX));</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		pmd_t *pmd = pmd_offset(pud, relocated_restore_code);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (pmd_large(*pmd)) {</span>
<span class="p_add">+			set_pmd(pmd, __pmd(pmd_val(*pmd) &amp; ~_PAGE_NX));</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			pte_t *pte = pte_offset_kernel(pmd, relocated_restore_code);</span>
<span class="p_add">+</span>
<span class="p_add">+			set_pte(pte, __pte(pte_val(*pte) &amp; ~_PAGE_NX));</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	__flush_tlb_all();</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int swsusp_arch_resume(void)
 {
 	int error;
 
 	/* We have got enough memory and from now on we cannot recover */
<span class="p_del">-	if ((error = set_up_temporary_mappings()))</span>
<span class="p_add">+	error = set_up_temporary_mappings();</span>
<span class="p_add">+	if (error)</span>
 		return error;
 
<span class="p_del">-	relocated_restore_code = (void *)get_safe_page(GFP_ATOMIC);</span>
<span class="p_del">-	if (!relocated_restore_code)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-	memcpy(relocated_restore_code, &amp;core_restore_code,</span>
<span class="p_del">-	       &amp;restore_registers - &amp;core_restore_code);</span>
<span class="p_add">+	error = relocate_restore_code();</span>
<span class="p_add">+	if (error)</span>
<span class="p_add">+		return error;</span>
 
 	restore_image();
 	return 0;
<span class="p_chunk">@@ -109,11 +179,12 @@</span> <span class="p_context"> int pfn_is_nosave(unsigned long pfn)</span>
 
 struct restore_data_record {
 	unsigned long jump_address;
<span class="p_add">+	unsigned long jump_address_phys;</span>
 	unsigned long cr3;
 	unsigned long magic;
 };
 
<span class="p_del">-#define RESTORE_MAGIC	0x0123456789ABCDEFUL</span>
<span class="p_add">+#define RESTORE_MAGIC	0x123456789ABCDEF0UL</span>
 
 /**
  *	arch_hibernation_header_save - populate the architecture specific part
<span class="p_chunk">@@ -126,7 +197,8 @@</span> <span class="p_context"> int arch_hibernation_header_save(void *addr, unsigned int max_size)</span>
 
 	if (max_size &lt; sizeof(struct restore_data_record))
 		return -EOVERFLOW;
<span class="p_del">-	rdr-&gt;jump_address = restore_jump_address;</span>
<span class="p_add">+	rdr-&gt;jump_address = (unsigned long)&amp;restore_registers;</span>
<span class="p_add">+	rdr-&gt;jump_address_phys = __pa_symbol(&amp;restore_registers);</span>
 	rdr-&gt;cr3 = restore_cr3;
 	rdr-&gt;magic = RESTORE_MAGIC;
 	return 0;
<span class="p_chunk">@@ -142,6 +214,7 @@</span> <span class="p_context"> int arch_hibernation_header_restore(void *addr)</span>
 	struct restore_data_record *rdr = addr;
 
 	restore_jump_address = rdr-&gt;jump_address;
<span class="p_add">+	jump_address_phys = rdr-&gt;jump_address_phys;</span>
 	restore_cr3 = rdr-&gt;cr3;
 	return (rdr-&gt;magic == RESTORE_MAGIC) ? 0 : -EINVAL;
 }
<span class="p_header">diff --git a/arch/x86/power/hibernate_asm_64.S b/arch/x86/power/hibernate_asm_64.S</span>
<span class="p_header">index 3c4469a7a929..cf5ae8149e44 100644</span>
<span class="p_header">--- a/arch/x86/power/hibernate_asm_64.S</span>
<span class="p_header">+++ b/arch/x86/power/hibernate_asm_64.S</span>
<span class="p_chunk">@@ -42,9 +42,6 @@</span> <span class="p_context"> ENTRY(swsusp_arch_suspend)</span>
 	pushfq
 	popq	pt_regs_flags(%rax)
 
<span class="p_del">-	/* save the address of restore_registers */</span>
<span class="p_del">-	movq	$restore_registers, %rax</span>
<span class="p_del">-	movq	%rax, restore_jump_address(%rip)</span>
 	/* save cr3 */
 	movq	%cr3, %rax
 	movq	%rax, restore_cr3(%rip)
<span class="p_chunk">@@ -53,31 +50,34 @@</span> <span class="p_context"> ENTRY(swsusp_arch_suspend)</span>
 	ret
 
 ENTRY(restore_image)
<span class="p_del">-	/* switch to temporary page tables */</span>
<span class="p_del">-	movq	$__PAGE_OFFSET, %rdx</span>
<span class="p_del">-	movq	temp_level4_pgt(%rip), %rax</span>
<span class="p_del">-	subq	%rdx, %rax</span>
<span class="p_del">-	movq	%rax, %cr3</span>
<span class="p_del">-	/* Flush TLB */</span>
<span class="p_del">-	movq	mmu_cr4_features(%rip), %rax</span>
<span class="p_del">-	movq	%rax, %rdx</span>
<span class="p_del">-	andq	$~(X86_CR4_PGE), %rdx</span>
<span class="p_del">-	movq	%rdx, %cr4;  # turn off PGE</span>
<span class="p_del">-	movq	%cr3, %rcx;  # flush TLB</span>
<span class="p_del">-	movq	%rcx, %cr3;</span>
<span class="p_del">-	movq	%rax, %cr4;  # turn PGE back on</span>
<span class="p_del">-</span>
 	/* prepare to jump to the image kernel */
<span class="p_del">-	movq	restore_jump_address(%rip), %rax</span>
<span class="p_del">-	movq	restore_cr3(%rip), %rbx</span>
<span class="p_add">+	movq	restore_jump_address(%rip), %r8</span>
<span class="p_add">+	movq	restore_cr3(%rip), %r9</span>
<span class="p_add">+</span>
<span class="p_add">+	/* prepare to switch to temporary page tables */</span>
<span class="p_add">+	movq	temp_level4_pgt(%rip), %rax</span>
<span class="p_add">+	movq	mmu_cr4_features(%rip), %rbx</span>
 
 	/* prepare to copy image data to their original locations */
 	movq	restore_pblist(%rip), %rdx
<span class="p_add">+</span>
<span class="p_add">+	/* jump to relocated restore code */</span>
 	movq	relocated_restore_code(%rip), %rcx
 	jmpq	*%rcx
 
 	/* code below has been relocated to a safe page */
 ENTRY(core_restore_code)
<span class="p_add">+	/* switch to temporary page tables */</span>
<span class="p_add">+	movq	$__PAGE_OFFSET, %rcx</span>
<span class="p_add">+	subq	%rcx, %rax</span>
<span class="p_add">+	movq	%rax, %cr3</span>
<span class="p_add">+	/* flush TLB */</span>
<span class="p_add">+	movq	%rbx, %rcx</span>
<span class="p_add">+	andq	$~(X86_CR4_PGE), %rcx</span>
<span class="p_add">+	movq	%rcx, %cr4;  # turn off PGE</span>
<span class="p_add">+	movq	%cr3, %rcx;  # flush TLB</span>
<span class="p_add">+	movq	%rcx, %cr3;</span>
<span class="p_add">+	movq	%rbx, %cr4;  # turn PGE back on</span>
 loop:
 	testq	%rdx, %rdx
 	jz	done
<span class="p_chunk">@@ -92,23 +92,16 @@</span> <span class="p_context"> loop:</span>
 	/* progress to the next pbe */
 	movq	pbe_next(%rdx), %rdx
 	jmp	loop
<span class="p_add">+</span>
 done:
 	/* jump to the restore_registers address from the image header */
<span class="p_del">-	jmpq	*%rax</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * NOTE: This assumes that the boot kernel&#39;s text mapping covers the</span>
<span class="p_del">-	 * image kernel&#39;s page containing restore_registers and the address of</span>
<span class="p_del">-	 * this page is the same as in the image kernel&#39;s text mapping (it</span>
<span class="p_del">-	 * should always be true, because the text mapping is linear, starting</span>
<span class="p_del">-	 * from 0, and is supposed to cover the entire kernel text for every</span>
<span class="p_del">-	 * kernel).</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * code below belongs to the image kernel</span>
<span class="p_del">-	 */</span>
<span class="p_add">+	jmpq	*%r8</span>
 
<span class="p_add">+	 /* code below belongs to the image kernel */</span>
<span class="p_add">+	.align PAGE_SIZE</span>
 ENTRY(restore_registers)
 	/* go back to the original page tables */
<span class="p_del">-	movq    %rbx, %cr3</span>
<span class="p_add">+	movq    %r9, %cr3</span>
 
 	/* Flush TLB, including &quot;global&quot; things (vmalloc) */
 	movq	mmu_cr4_features(%rip), %rax
<span class="p_header">diff --git a/block/blk-mq.c b/block/blk-mq.c</span>
<span class="p_header">index 50dd29bc4972..31c4fa508e77 100644</span>
<span class="p_header">--- a/block/blk-mq.c</span>
<span class="p_header">+++ b/block/blk-mq.c</span>
<span class="p_chunk">@@ -1385,7 +1385,7 @@</span> <span class="p_context"> static struct blk_mq_tags *blk_mq_init_rq_map(struct blk_mq_tag_set *set,</span>
 		int to_do;
 		void *p;
 
<span class="p_del">-		while (left &lt; order_to_size(this_order - 1) &amp;&amp; this_order)</span>
<span class="p_add">+		while (this_order &amp;&amp; left &lt; order_to_size(this_order - 1))</span>
 			this_order--;
 
 		do {
<span class="p_header">diff --git a/block/ioprio.c b/block/ioprio.c</span>
<span class="p_header">index 31666c92b46a..563435684c3c 100644</span>
<span class="p_header">--- a/block/ioprio.c</span>
<span class="p_header">+++ b/block/ioprio.c</span>
<span class="p_chunk">@@ -149,8 +149,10 @@</span> <span class="p_context"> static int get_task_ioprio(struct task_struct *p)</span>
 	if (ret)
 		goto out;
 	ret = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, IOPRIO_NORM);
<span class="p_add">+	task_lock(p);</span>
 	if (p-&gt;io_context)
 		ret = p-&gt;io_context-&gt;ioprio;
<span class="p_add">+	task_unlock(p);</span>
 out:
 	return ret;
 }
<span class="p_header">diff --git a/crypto/asymmetric_keys/Kconfig b/crypto/asymmetric_keys/Kconfig</span>
<span class="p_header">index 03a6eb95ab50..f25fd337e81a 100644</span>
<span class="p_header">--- a/crypto/asymmetric_keys/Kconfig</span>
<span class="p_header">+++ b/crypto/asymmetric_keys/Kconfig</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"> config ASYMMETRIC_PUBLIC_KEY_SUBTYPE</span>
 	select MPILIB
 	select PUBLIC_KEY_ALGO_RSA
 	select CRYPTO_HASH_INFO
<span class="p_add">+	select CRYPTO_AKCIPHER</span>
 	help
 	  This option provides support for asymmetric public key type handling.
 	  If signature generation and/or verification are to be used,
<span class="p_header">diff --git a/drivers/acpi/acpi_processor.c b/drivers/acpi/acpi_processor.c</span>
<span class="p_header">index 1c085742644f..69af230636d6 100644</span>
<span class="p_header">--- a/drivers/acpi/acpi_processor.c</span>
<span class="p_header">+++ b/drivers/acpi/acpi_processor.c</span>
<span class="p_chunk">@@ -311,15 +311,6 @@</span> <span class="p_context"> static int acpi_processor_get_info(struct acpi_device *device)</span>
 		pr-&gt;throttling.duty_width = acpi_gbl_FADT.duty_width;
 
 		pr-&gt;pblk = object.processor.pblk_address;
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * We don&#39;t care about error returns - we just try to mark</span>
<span class="p_del">-		 * these reserved so that nobody else is confused into thinking</span>
<span class="p_del">-		 * that this region might be unused..</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * (In particular, allocating the IO range for Cardbus)</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		request_region(pr-&gt;throttling.address, 6, &quot;ACPI CPU throttle&quot;);</span>
 	}
 
 	/*
<span class="p_header">diff --git a/drivers/acpi/processor_throttling.c b/drivers/acpi/processor_throttling.c</span>
<span class="p_header">index 84243c32e29c..f3df4b5e5fc9 100644</span>
<span class="p_header">--- a/drivers/acpi/processor_throttling.c</span>
<span class="p_header">+++ b/drivers/acpi/processor_throttling.c</span>
<span class="p_chunk">@@ -680,6 +680,15 @@</span> <span class="p_context"> static int acpi_processor_get_throttling_fadt(struct acpi_processor *pr)</span>
 	if (!pr-&gt;flags.throttling)
 		return -ENODEV;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We don&#39;t care about error returns - we just try to mark</span>
<span class="p_add">+	 * these reserved so that nobody else is confused into thinking</span>
<span class="p_add">+	 * that this region might be unused..</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * (In particular, allocating the IO range for Cardbus)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	request_region(pr-&gt;throttling.address, 6, &quot;ACPI CPU throttle&quot;);</span>
<span class="p_add">+</span>
 	pr-&gt;throttling.state = 0;
 
 	duty_mask = pr-&gt;throttling.state_count - 1;
<span class="p_header">diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c</span>
<span class="p_header">index 38cb9782d4b8..3454fce84515 100644</span>
<span class="p_header">--- a/drivers/acpi/sysfs.c</span>
<span class="p_header">+++ b/drivers/acpi/sysfs.c</span>
<span class="p_chunk">@@ -492,23 +492,22 @@</span> <span class="p_context"> static void acpi_global_event_handler(u32 event_type, acpi_handle device,</span>
 static int get_status(u32 index, acpi_event_status *status,
 		      acpi_handle *handle)
 {
<span class="p_del">-	int result = 0;</span>
<span class="p_add">+	int result;</span>
 
 	if (index &gt;= num_gpes + ACPI_NUM_FIXED_EVENTS)
<span class="p_del">-		goto end;</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	if (index &lt; num_gpes) {
 		result = acpi_get_gpe_device(index, handle);
 		if (result) {
 			ACPI_EXCEPTION((AE_INFO, AE_NOT_FOUND,
 					&quot;Invalid GPE 0x%x&quot;, index));
<span class="p_del">-			goto end;</span>
<span class="p_add">+			return result;</span>
 		}
 		result = acpi_get_gpe_status(*handle, index, status);
 	} else if (index &lt; (num_gpes + ACPI_NUM_FIXED_EVENTS))
 		result = acpi_get_event_status(index - num_gpes, status);
 
<span class="p_del">-end:</span>
 	return result;
 }
 
<span class="p_header">diff --git a/drivers/ata/libata-eh.c b/drivers/ata/libata-eh.c</span>
<span class="p_header">index 4ec95b76f6a1..0550c76f4e6c 100644</span>
<span class="p_header">--- a/drivers/ata/libata-eh.c</span>
<span class="p_header">+++ b/drivers/ata/libata-eh.c</span>
<span class="p_chunk">@@ -605,7 +605,7 @@</span> <span class="p_context"> void ata_scsi_error(struct Scsi_Host *host)</span>
 	ata_scsi_port_error_handler(host, ap);
 
 	/* finish or retry handled scmd&#39;s and clean up */
<span class="p_del">-	WARN_ON(host-&gt;host_failed || !list_empty(&amp;eh_work_q));</span>
<span class="p_add">+	WARN_ON(!list_empty(&amp;eh_work_q));</span>
 
 	DPRINTK(&quot;EXIT\n&quot;);
 }
<span class="p_header">diff --git a/drivers/ata/sata_dwc_460ex.c b/drivers/ata/sata_dwc_460ex.c</span>
<span class="p_header">index 4ebaa1e7b2d3..5b25dbe78989 100644</span>
<span class="p_header">--- a/drivers/ata/sata_dwc_460ex.c</span>
<span class="p_header">+++ b/drivers/ata/sata_dwc_460ex.c</span>
<span class="p_chunk">@@ -1392,15 +1392,13 @@</span> <span class="p_context"> static void sata_dwc_exec_command_by_tag(struct ata_port *ap,</span>
 					 struct ata_taskfile *tf,
 					 u8 tag, u32 cmd_issued)
 {
<span class="p_del">-	unsigned long flags;</span>
 	struct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);
 
 	dev_dbg(ap-&gt;dev, &quot;%s cmd(0x%02x): %s tag=%d\n&quot;, __func__, tf-&gt;command,
 		ata_get_cmd_descript(tf-&gt;command), tag);
 
<span class="p_del">-	spin_lock_irqsave(&amp;ap-&gt;host-&gt;lock, flags);</span>
 	hsdevp-&gt;cmd_issued[tag] = cmd_issued;
<span class="p_del">-	spin_unlock_irqrestore(&amp;ap-&gt;host-&gt;lock, flags);</span>
<span class="p_add">+</span>
 	/*
 	 * Clear SError before executing a new command.
 	 * sata_dwc_scr_write and read can not be used here. Clearing the PM
<span class="p_header">diff --git a/drivers/base/isa.c b/drivers/base/isa.c</span>
<span class="p_header">index 91dba65d7264..cd6ccdcf9df0 100644</span>
<span class="p_header">--- a/drivers/base/isa.c</span>
<span class="p_header">+++ b/drivers/base/isa.c</span>
<span class="p_chunk">@@ -180,4 +180,4 @@</span> <span class="p_context"> static int __init isa_bus_init(void)</span>
 	return error;
 }
 
<span class="p_del">-device_initcall(isa_bus_init);</span>
<span class="p_add">+postcore_initcall(isa_bus_init);</span>
<span class="p_header">diff --git a/drivers/base/module.c b/drivers/base/module.c</span>
<span class="p_header">index db930d3ee312..2a215780eda2 100644</span>
<span class="p_header">--- a/drivers/base/module.c</span>
<span class="p_header">+++ b/drivers/base/module.c</span>
<span class="p_chunk">@@ -24,10 +24,12 @@</span> <span class="p_context"> static char *make_driver_name(struct device_driver *drv)</span>
 
 static void module_create_drivers_dir(struct module_kobject *mk)
 {
<span class="p_del">-	if (!mk || mk-&gt;drivers_dir)</span>
<span class="p_del">-		return;</span>
<span class="p_add">+	static DEFINE_MUTEX(drivers_dir_mutex);</span>
 
<span class="p_del">-	mk-&gt;drivers_dir = kobject_create_and_add(&quot;drivers&quot;, &amp;mk-&gt;kobj);</span>
<span class="p_add">+	mutex_lock(&amp;drivers_dir_mutex);</span>
<span class="p_add">+	if (mk &amp;&amp; !mk-&gt;drivers_dir)</span>
<span class="p_add">+		mk-&gt;drivers_dir = kobject_create_and_add(&quot;drivers&quot;, &amp;mk-&gt;kobj);</span>
<span class="p_add">+	mutex_unlock(&amp;drivers_dir_mutex);</span>
 }
 
 void module_add_driver(struct module *mod, struct device_driver *drv)
<span class="p_header">diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c</span>
<span class="p_header">index 1f6da3ad6db0..0f632958a4dd 100644</span>
<span class="p_header">--- a/drivers/base/power/main.c</span>
<span class="p_header">+++ b/drivers/base/power/main.c</span>
<span class="p_chunk">@@ -1247,14 +1247,15 @@</span> <span class="p_context"> static int dpm_suspend_late(pm_message_t state)</span>
 		error = device_suspend_late(dev);
 
 		mutex_lock(&amp;dpm_list_mtx);
<span class="p_add">+		if (!list_empty(&amp;dev-&gt;power.entry))</span>
<span class="p_add">+			list_move(&amp;dev-&gt;power.entry, &amp;dpm_late_early_list);</span>
<span class="p_add">+</span>
 		if (error) {
 			pm_dev_err(dev, state, &quot; late&quot;, error);
 			dpm_save_failed_dev(dev_name(dev));
 			put_device(dev);
 			break;
 		}
<span class="p_del">-		if (!list_empty(&amp;dev-&gt;power.entry))</span>
<span class="p_del">-			list_move(&amp;dev-&gt;power.entry, &amp;dpm_late_early_list);</span>
 		put_device(dev);
 
 		if (async_error)
<span class="p_header">diff --git a/drivers/base/power/runtime.c b/drivers/base/power/runtime.c</span>
<span class="p_header">index 67c7938e430b..f6f1f90e9448 100644</span>
<span class="p_header">--- a/drivers/base/power/runtime.c</span>
<span class="p_header">+++ b/drivers/base/power/runtime.c</span>
<span class="p_chunk">@@ -1474,11 +1474,16 @@</span> <span class="p_context"> int pm_runtime_force_resume(struct device *dev)</span>
 		goto out;
 	}
 
<span class="p_del">-	ret = callback(dev);</span>
<span class="p_add">+	ret = pm_runtime_set_active(dev);</span>
 	if (ret)
 		goto out;
 
<span class="p_del">-	pm_runtime_set_active(dev);</span>
<span class="p_add">+	ret = callback(dev);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pm_runtime_set_suspended(dev);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	pm_runtime_mark_last_busy(dev);
 out:
 	pm_runtime_enable(dev);
<span class="p_header">diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c</span>
<span class="p_header">index 5c1cc008af9e..3568186a77a7 100644</span>
<span class="p_header">--- a/drivers/base/regmap/regcache.c</span>
<span class="p_header">+++ b/drivers/base/regmap/regcache.c</span>
<span class="p_chunk">@@ -473,7 +473,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(regcache_mark_dirty);</span>
  * regcache_cache_bypass: Put a register map into cache bypass mode
  *
  * @map: map to configure
<span class="p_del">- * @cache_bypass: flag if changes should not be written to the hardware</span>
<span class="p_add">+ * @cache_bypass: flag if changes should not be written to the cache</span>
  *
  * When a register map is marked with the cache bypass option, writes
  * to the register map API will only update the hardware and not the
<span class="p_header">diff --git a/drivers/bluetooth/hci_vhci.c b/drivers/bluetooth/hci_vhci.c</span>
<span class="p_header">index add1c6a72063..e26eb6b606e1 100644</span>
<span class="p_header">--- a/drivers/bluetooth/hci_vhci.c</span>
<span class="p_header">+++ b/drivers/bluetooth/hci_vhci.c</span>
<span class="p_chunk">@@ -50,6 +50,7 @@</span> <span class="p_context"> struct vhci_data {</span>
 	wait_queue_head_t read_wait;
 	struct sk_buff_head readq;
 
<span class="p_add">+	struct mutex open_mutex;</span>
 	struct delayed_work open_timeout;
 };
 
<span class="p_chunk">@@ -95,11 +96,14 @@</span> <span class="p_context"> static int vhci_send_frame(struct hci_dev *hdev, struct sk_buff *skb)</span>
 	return 0;
 }
 
<span class="p_del">-static int vhci_create_device(struct vhci_data *data, __u8 dev_type)</span>
<span class="p_add">+static int __vhci_create_device(struct vhci_data *data, __u8 dev_type)</span>
 {
 	struct hci_dev *hdev;
 	struct sk_buff *skb;
 
<span class="p_add">+	if (data-&gt;hdev)</span>
<span class="p_add">+		return -EBADFD;</span>
<span class="p_add">+</span>
 	skb = bt_skb_alloc(4, GFP_KERNEL);
 	if (!skb)
 		return -ENOMEM;
<span class="p_chunk">@@ -140,6 +144,17 @@</span> <span class="p_context"> static int vhci_create_device(struct vhci_data *data, __u8 dev_type)</span>
 	return 0;
 }
 
<span class="p_add">+static int vhci_create_device(struct vhci_data *data, __u8 opcode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;data-&gt;open_mutex);</span>
<span class="p_add">+	err = __vhci_create_device(data, opcode);</span>
<span class="p_add">+	mutex_unlock(&amp;data-&gt;open_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline ssize_t vhci_get_user(struct vhci_data *data,
 				    const struct iovec *iov,
 				    unsigned long count)
<span class="p_chunk">@@ -183,11 +198,6 @@</span> <span class="p_context"> static inline ssize_t vhci_get_user(struct vhci_data *data,</span>
 		break;
 
 	case HCI_VENDOR_PKT:
<span class="p_del">-		if (data-&gt;hdev) {</span>
<span class="p_del">-			kfree_skb(skb);</span>
<span class="p_del">-			return -EBADFD;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
 		cancel_delayed_work_sync(&amp;data-&gt;open_timeout);
 
 		dev_type = *((__u8 *) skb-&gt;data);
<span class="p_chunk">@@ -318,6 +328,7 @@</span> <span class="p_context"> static int vhci_open(struct inode *inode, struct file *file)</span>
 	skb_queue_head_init(&amp;data-&gt;readq);
 	init_waitqueue_head(&amp;data-&gt;read_wait);
 
<span class="p_add">+	mutex_init(&amp;data-&gt;open_mutex);</span>
 	INIT_DELAYED_WORK(&amp;data-&gt;open_timeout, vhci_open_timeout);
 
 	file-&gt;private_data = data;
<span class="p_chunk">@@ -331,15 +342,18 @@</span> <span class="p_context"> static int vhci_open(struct inode *inode, struct file *file)</span>
 static int vhci_release(struct inode *inode, struct file *file)
 {
 	struct vhci_data *data = file-&gt;private_data;
<span class="p_del">-	struct hci_dev *hdev = data-&gt;hdev;</span>
<span class="p_add">+	struct hci_dev *hdev;</span>
 
 	cancel_delayed_work_sync(&amp;data-&gt;open_timeout);
 
<span class="p_add">+	hdev = data-&gt;hdev;</span>
<span class="p_add">+</span>
 	if (hdev) {
 		hci_unregister_dev(hdev);
 		hci_free_dev(hdev);
 	}
 
<span class="p_add">+	skb_queue_purge(&amp;data-&gt;readq);</span>
 	file-&gt;private_data = NULL;
 	kfree(data);
 
<span class="p_header">diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig</span>
<span class="p_header">index 6e9f74a5c095..f3a46b956abe 100644</span>
<span class="p_header">--- a/drivers/char/Kconfig</span>
<span class="p_header">+++ b/drivers/char/Kconfig</span>
<span class="p_chunk">@@ -575,7 +575,6 @@</span> <span class="p_context"> config TELCLOCK</span>
 
 config DEVPORT
 	bool
<span class="p_del">-	depends on !M68K</span>
 	depends on ISA || PCI
 	default y
 
<span class="p_header">diff --git a/drivers/char/i8k.c b/drivers/char/i8k.c</span>
<span class="p_header">index 93dcad0c1cbe..89d1284e67f0 100644</span>
<span class="p_header">--- a/drivers/char/i8k.c</span>
<span class="p_header">+++ b/drivers/char/i8k.c</span>
<span class="p_chunk">@@ -62,6 +62,7 @@</span> <span class="p_context"></span>
 
 static DEFINE_MUTEX(i8k_mutex);
 static char bios_version[4];
<span class="p_add">+static char bios_machineid[16];</span>
 static struct device *i8k_hwmon_dev;
 static u32 i8k_hwmon_flags;
 static int i8k_fan_mult;
<span class="p_chunk">@@ -85,13 +86,13 @@</span> <span class="p_context"> static bool ignore_dmi;</span>
 module_param(ignore_dmi, bool, 0);
 MODULE_PARM_DESC(ignore_dmi, &quot;Continue probing hardware even if DMI data does not match&quot;);
 
<span class="p_del">-static bool restricted;</span>
<span class="p_add">+static bool restricted = true;</span>
 module_param(restricted, bool, 0);
<span class="p_del">-MODULE_PARM_DESC(restricted, &quot;Allow fan control if SYS_ADMIN capability set&quot;);</span>
<span class="p_add">+MODULE_PARM_DESC(restricted, &quot;Restrict fan control and serial number to CAP_SYS_ADMIN (default: 1)&quot;);</span>
 
 static bool power_status;
 module_param(power_status, bool, 0600);
<span class="p_del">-MODULE_PARM_DESC(power_status, &quot;Report power status in /proc/i8k&quot;);</span>
<span class="p_add">+MODULE_PARM_DESC(power_status, &quot;Report power status in /proc/i8k (default: 0)&quot;);</span>
 
 static int fan_mult = I8K_FAN_MULT;
 module_param(fan_mult, int, 0);
<span class="p_chunk">@@ -350,9 +351,11 @@</span> <span class="p_context"> i8k_ioctl_unlocked(struct file *fp, unsigned int cmd, unsigned long arg)</span>
 		break;
 
 	case I8K_MACHINE_ID:
<span class="p_del">-		memset(buff, 0, 16);</span>
<span class="p_del">-		strlcpy(buff, i8k_get_dmi_data(DMI_PRODUCT_SERIAL),</span>
<span class="p_del">-			sizeof(buff));</span>
<span class="p_add">+		if (restricted &amp;&amp; !capable(CAP_SYS_ADMIN))</span>
<span class="p_add">+			return -EPERM;</span>
<span class="p_add">+</span>
<span class="p_add">+		memset(buff, 0, sizeof(buff));</span>
<span class="p_add">+		strlcpy(buff, bios_machineid, sizeof(buff));</span>
 		break;
 
 	case I8K_FN_STATUS:
<span class="p_chunk">@@ -469,7 +472,7 @@</span> <span class="p_context"> static int i8k_proc_show(struct seq_file *seq, void *offset)</span>
 	return seq_printf(seq, &quot;%s %s %s %d %d %d %d %d %d %d\n&quot;,
 			  I8K_PROC_FMT,
 			  bios_version,
<span class="p_del">-			  i8k_get_dmi_data(DMI_PRODUCT_SERIAL),</span>
<span class="p_add">+			  (restricted &amp;&amp; !capable(CAP_SYS_ADMIN)) ? &quot;-1&quot; : bios_machineid,</span>
 			  cpu_temp,
 			  left_fan, right_fan, left_speed, right_speed,
 			  ac_power, fn_key);
<span class="p_chunk">@@ -765,6 +768,8 @@</span> <span class="p_context"> static int __init i8k_probe(void)</span>
 
 	strlcpy(bios_version, i8k_get_dmi_data(DMI_BIOS_VERSION),
 		sizeof(bios_version));
<span class="p_add">+	strlcpy(bios_machineid, i8k_get_dmi_data(DMI_PRODUCT_SERIAL),</span>
<span class="p_add">+		sizeof(bios_machineid));</span>
 
 	/*
 	 * Get SMM Dell signature
<span class="p_header">diff --git a/drivers/cpufreq/cpufreq_userspace.c b/drivers/cpufreq/cpufreq_userspace.c</span>
<span class="p_header">index 4dbf1db16aca..9cc8abd3d116 100644</span>
<span class="p_header">--- a/drivers/cpufreq/cpufreq_userspace.c</span>
<span class="p_header">+++ b/drivers/cpufreq/cpufreq_userspace.c</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/init.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/mutex.h&gt;
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
 
 static DEFINE_PER_CPU(unsigned int, cpu_is_managed);
 static DEFINE_MUTEX(userspace_mutex);
<span class="p_chunk">@@ -31,6 +32,7 @@</span> <span class="p_context"> static DEFINE_MUTEX(userspace_mutex);</span>
 static int cpufreq_set(struct cpufreq_policy *policy, unsigned int freq)
 {
 	int ret = -EINVAL;
<span class="p_add">+	unsigned int *setspeed = policy-&gt;governor_data;</span>
 
 	pr_debug(&quot;cpufreq_set for cpu %u, freq %u kHz\n&quot;, policy-&gt;cpu, freq);
 
<span class="p_chunk">@@ -38,6 +40,8 @@</span> <span class="p_context"> static int cpufreq_set(struct cpufreq_policy *policy, unsigned int freq)</span>
 	if (!per_cpu(cpu_is_managed, policy-&gt;cpu))
 		goto err;
 
<span class="p_add">+	*setspeed = freq;</span>
<span class="p_add">+</span>
 	ret = __cpufreq_driver_target(policy, freq, CPUFREQ_RELATION_L);
  err:
 	mutex_unlock(&amp;userspace_mutex);
<span class="p_chunk">@@ -49,19 +53,45 @@</span> <span class="p_context"> static ssize_t show_speed(struct cpufreq_policy *policy, char *buf)</span>
 	return sprintf(buf, &quot;%u\n&quot;, policy-&gt;cur);
 }
 
<span class="p_add">+static int cpufreq_userspace_policy_init(struct cpufreq_policy *policy)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int *setspeed;</span>
<span class="p_add">+</span>
<span class="p_add">+	setspeed = kzalloc(sizeof(*setspeed), GFP_KERNEL);</span>
<span class="p_add">+	if (!setspeed)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	policy-&gt;governor_data = setspeed;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int cpufreq_governor_userspace(struct cpufreq_policy *policy,
 				   unsigned int event)
 {
<span class="p_add">+	unsigned int *setspeed = policy-&gt;governor_data;</span>
 	unsigned int cpu = policy-&gt;cpu;
 	int rc = 0;
 
<span class="p_add">+	if (event == CPUFREQ_GOV_POLICY_INIT)</span>
<span class="p_add">+		return cpufreq_userspace_policy_init(policy);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!setspeed)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	switch (event) {
<span class="p_add">+	case CPUFREQ_GOV_POLICY_EXIT:</span>
<span class="p_add">+		mutex_lock(&amp;userspace_mutex);</span>
<span class="p_add">+		policy-&gt;governor_data = NULL;</span>
<span class="p_add">+		kfree(setspeed);</span>
<span class="p_add">+		mutex_unlock(&amp;userspace_mutex);</span>
<span class="p_add">+		break;</span>
 	case CPUFREQ_GOV_START:
 		BUG_ON(!policy-&gt;cur);
 		pr_debug(&quot;started managing cpu %u\n&quot;, cpu);
 
 		mutex_lock(&amp;userspace_mutex);
 		per_cpu(cpu_is_managed, cpu) = 1;
<span class="p_add">+		*setspeed = policy-&gt;cur;</span>
 		mutex_unlock(&amp;userspace_mutex);
 		break;
 	case CPUFREQ_GOV_STOP:
<span class="p_chunk">@@ -69,20 +99,23 @@</span> <span class="p_context"> static int cpufreq_governor_userspace(struct cpufreq_policy *policy,</span>
 
 		mutex_lock(&amp;userspace_mutex);
 		per_cpu(cpu_is_managed, cpu) = 0;
<span class="p_add">+		*setspeed = 0;</span>
 		mutex_unlock(&amp;userspace_mutex);
 		break;
 	case CPUFREQ_GOV_LIMITS:
 		mutex_lock(&amp;userspace_mutex);
<span class="p_del">-		pr_debug(&quot;limit event for cpu %u: %u - %u kHz, currently %u kHz\n&quot;,</span>
<span class="p_del">-			cpu, policy-&gt;min, policy-&gt;max,</span>
<span class="p_del">-			policy-&gt;cur);</span>
<span class="p_add">+		pr_debug(&quot;limit event for cpu %u: %u - %u kHz, currently %u kHz, last set to %u kHz\n&quot;,</span>
<span class="p_add">+			cpu, policy-&gt;min, policy-&gt;max, policy-&gt;cur, *setspeed);</span>
 
<span class="p_del">-		if (policy-&gt;max &lt; policy-&gt;cur)</span>
<span class="p_add">+		if (policy-&gt;max &lt; *setspeed)</span>
 			__cpufreq_driver_target(policy, policy-&gt;max,
 						CPUFREQ_RELATION_H);
<span class="p_del">-		else if (policy-&gt;min &gt; policy-&gt;cur)</span>
<span class="p_add">+		else if (policy-&gt;min &gt; *setspeed)</span>
 			__cpufreq_driver_target(policy, policy-&gt;min,
 						CPUFREQ_RELATION_L);
<span class="p_add">+		else</span>
<span class="p_add">+			__cpufreq_driver_target(policy, *setspeed,</span>
<span class="p_add">+						CPUFREQ_RELATION_L);</span>
 		mutex_unlock(&amp;userspace_mutex);
 		break;
 	}
<span class="p_header">diff --git a/drivers/cpufreq/intel_pstate.c b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">index dad4346189ae..087b5c32a6a1 100644</span>
<span class="p_header">--- a/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">+++ b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_chunk">@@ -877,8 +877,11 @@</span> <span class="p_context"> static int intel_pstate_cpu_init(struct cpufreq_policy *policy)</span>
 
 	/* cpuinfo and default policy values */
 	policy-&gt;cpuinfo.min_freq = cpu-&gt;pstate.min_pstate * cpu-&gt;pstate.scaling;
<span class="p_del">-	policy-&gt;cpuinfo.max_freq =</span>
<span class="p_del">-		cpu-&gt;pstate.turbo_pstate * cpu-&gt;pstate.scaling;</span>
<span class="p_add">+	update_turbo_state();</span>
<span class="p_add">+	policy-&gt;cpuinfo.max_freq = limits.turbo_disabled ?</span>
<span class="p_add">+			cpu-&gt;pstate.max_pstate : cpu-&gt;pstate.turbo_pstate;</span>
<span class="p_add">+	policy-&gt;cpuinfo.max_freq *= cpu-&gt;pstate.scaling;</span>
<span class="p_add">+</span>
 	policy-&gt;cpuinfo.transition_latency = CPUFREQ_ETERNAL;
 	cpumask_set_cpu(policy-&gt;cpu, policy-&gt;cpus);
 
<span class="p_header">diff --git a/drivers/cpuidle/cpuidle.c b/drivers/cpuidle/cpuidle.c</span>
<span class="p_header">index d3185606473a..4cfa952edafd 100644</span>
<span class="p_header">--- a/drivers/cpuidle/cpuidle.c</span>
<span class="p_header">+++ b/drivers/cpuidle/cpuidle.c</span>
<span class="p_chunk">@@ -125,7 +125,7 @@</span> <span class="p_context"> int cpuidle_enter_state(struct cpuidle_device *dev, struct cpuidle_driver *drv,</span>
 
 	time_end = ktime_get();
 
<span class="p_del">-	if (!cpuidle_state_is_coupled(dev, drv, entered_state))</span>
<span class="p_add">+	if (!cpuidle_state_is_coupled(dev, drv, index))</span>
 		local_irq_enable();
 
 	diff = ktime_to_us(ktime_sub(time_end, time_start));
<span class="p_chunk">@@ -347,6 +347,8 @@</span> <span class="p_context"> static void __cpuidle_unregister_device(struct cpuidle_device *dev)</span>
 	list_del(&amp;dev-&gt;device_list);
 	per_cpu(cpuidle_devices, dev-&gt;cpu) = NULL;
 	module_put(drv-&gt;owner);
<span class="p_add">+</span>
<span class="p_add">+	dev-&gt;registered = 0;</span>
 }
 
 static void __cpuidle_device_init(struct cpuidle_device *dev)
<span class="p_header">diff --git a/drivers/crypto/caam/jr.c b/drivers/crypto/caam/jr.c</span>
<span class="p_header">index b512a4ba7569..33308810d1b5 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/jr.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/jr.c</span>
<span class="p_chunk">@@ -244,7 +244,7 @@</span> <span class="p_context"> static void caam_jr_dequeue(unsigned long devarg)</span>
 struct device *caam_jr_alloc(void)
 {
 	struct caam_drv_private_jr *jrpriv, *min_jrpriv = NULL;
<span class="p_del">-	struct device *dev = NULL;</span>
<span class="p_add">+	struct device *dev = ERR_PTR(-ENODEV);</span>
 	int min_tfm_cnt	= INT_MAX;
 	int tfm_cnt;
 
<span class="p_header">diff --git a/drivers/crypto/ccp/ccp-crypto-aes-xts.c b/drivers/crypto/ccp/ccp-crypto-aes-xts.c</span>
<span class="p_header">index 0cc5594b7de3..8b294c27c8b1 100644</span>
<span class="p_header">--- a/drivers/crypto/ccp/ccp-crypto-aes-xts.c</span>
<span class="p_header">+++ b/drivers/crypto/ccp/ccp-crypto-aes-xts.c</span>
<span class="p_chunk">@@ -123,6 +123,7 @@</span> <span class="p_context"> static int ccp_aes_xts_crypt(struct ablkcipher_request *req,</span>
 	struct ccp_ctx *ctx = crypto_tfm_ctx(req-&gt;base.tfm);
 	struct ccp_aes_req_ctx *rctx = ablkcipher_request_ctx(req);
 	unsigned int unit;
<span class="p_add">+	u32 unit_size;</span>
 	int ret;
 
 	if (!ctx-&gt;u.aes.key_len)
<span class="p_chunk">@@ -134,11 +135,17 @@</span> <span class="p_context"> static int ccp_aes_xts_crypt(struct ablkcipher_request *req,</span>
 	if (!req-&gt;info)
 		return -EINVAL;
 
<span class="p_del">-	for (unit = 0; unit &lt; ARRAY_SIZE(unit_size_map); unit++)</span>
<span class="p_del">-		if (!(req-&gt;nbytes &amp; (unit_size_map[unit].size - 1)))</span>
<span class="p_del">-			break;</span>
<span class="p_add">+	unit_size = CCP_XTS_AES_UNIT_SIZE__LAST;</span>
<span class="p_add">+	if (req-&gt;nbytes &lt;= unit_size_map[0].size) {</span>
<span class="p_add">+		for (unit = 0; unit &lt; ARRAY_SIZE(unit_size_map); unit++) {</span>
<span class="p_add">+			if (!(req-&gt;nbytes &amp; (unit_size_map[unit].size - 1))) {</span>
<span class="p_add">+				unit_size = unit_size_map[unit].value;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	if ((unit_size_map[unit].value == CCP_XTS_AES_UNIT_SIZE__LAST) ||</span>
<span class="p_add">+	if ((unit_size == CCP_XTS_AES_UNIT_SIZE__LAST) ||</span>
 	    (ctx-&gt;u.aes.key_len != AES_KEYSIZE_128)) {
 		/* Use the fallback to process the request for any
 		 * unsupported unit sizes or key sizes
<span class="p_chunk">@@ -159,7 +166,7 @@</span> <span class="p_context"> static int ccp_aes_xts_crypt(struct ablkcipher_request *req,</span>
 	rctx-&gt;cmd.engine = CCP_ENGINE_XTS_AES_128;
 	rctx-&gt;cmd.u.xts.action = (encrypt) ? CCP_AES_ACTION_ENCRYPT
 					   : CCP_AES_ACTION_DECRYPT;
<span class="p_del">-	rctx-&gt;cmd.u.xts.unit_size = unit_size_map[unit].value;</span>
<span class="p_add">+	rctx-&gt;cmd.u.xts.unit_size = unit_size;</span>
 	rctx-&gt;cmd.u.xts.key = &amp;ctx-&gt;u.aes.key_sg;
 	rctx-&gt;cmd.u.xts.key_len = ctx-&gt;u.aes.key_len;
 	rctx-&gt;cmd.u.xts.iv = &amp;rctx-&gt;iv_sg;
<span class="p_header">diff --git a/drivers/crypto/s5p-sss.c b/drivers/crypto/s5p-sss.c</span>
<span class="p_header">index 4197ad9a711b..cb86d4487605 100644</span>
<span class="p_header">--- a/drivers/crypto/s5p-sss.c</span>
<span class="p_header">+++ b/drivers/crypto/s5p-sss.c</span>
<span class="p_chunk">@@ -265,11 +265,11 @@</span> <span class="p_context"> static int s5p_set_outdata(struct s5p_aes_dev *dev, struct scatterlist *sg)</span>
 {
 	int err;
 
<span class="p_del">-	if (!IS_ALIGNED(sg_dma_len(sg), AES_BLOCK_SIZE)) {</span>
<span class="p_add">+	if (!IS_ALIGNED(sg-&gt;length, AES_BLOCK_SIZE)) {</span>
 		err = -EINVAL;
 		goto exit;
 	}
<span class="p_del">-	if (!sg_dma_len(sg)) {</span>
<span class="p_add">+	if (!sg-&gt;length) {</span>
 		err = -EINVAL;
 		goto exit;
 	}
<span class="p_chunk">@@ -291,11 +291,11 @@</span> <span class="p_context"> static int s5p_set_indata(struct s5p_aes_dev *dev, struct scatterlist *sg)</span>
 {
 	int err;
 
<span class="p_del">-	if (!IS_ALIGNED(sg_dma_len(sg), AES_BLOCK_SIZE)) {</span>
<span class="p_add">+	if (!IS_ALIGNED(sg-&gt;length, AES_BLOCK_SIZE)) {</span>
 		err = -EINVAL;
 		goto exit;
 	}
<span class="p_del">-	if (!sg_dma_len(sg)) {</span>
<span class="p_add">+	if (!sg-&gt;length) {</span>
 		err = -EINVAL;
 		goto exit;
 	}
<span class="p_chunk">@@ -313,43 +313,55 @@</span> <span class="p_context"> static int s5p_set_indata(struct s5p_aes_dev *dev, struct scatterlist *sg)</span>
 	return err;
 }
 
<span class="p_del">-static void s5p_aes_tx(struct s5p_aes_dev *dev)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Returns true if new transmitting (output) data is ready and its</span>
<span class="p_add">+ * address+length have to be written to device (by calling</span>
<span class="p_add">+ * s5p_set_dma_outdata()). False otherwise.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool s5p_aes_tx(struct s5p_aes_dev *dev)</span>
 {
 	int err = 0;
<span class="p_add">+	bool ret = false;</span>
 
 	s5p_unset_outdata(dev);
 
 	if (!sg_is_last(dev-&gt;sg_dst)) {
 		err = s5p_set_outdata(dev, sg_next(dev-&gt;sg_dst));
<span class="p_del">-		if (err) {</span>
<span class="p_add">+		if (err)</span>
 			s5p_aes_complete(dev, err);
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		s5p_set_dma_outdata(dev, dev-&gt;sg_dst);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			ret = true;</span>
 	} else {
 		s5p_aes_complete(dev, err);
 
 		dev-&gt;busy = true;
 		tasklet_schedule(&amp;dev-&gt;tasklet);
 	}
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
<span class="p_del">-static void s5p_aes_rx(struct s5p_aes_dev *dev)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Returns true if new receiving (input) data is ready and its</span>
<span class="p_add">+ * address+length have to be written to device (by calling</span>
<span class="p_add">+ * s5p_set_dma_indata()). False otherwise.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool s5p_aes_rx(struct s5p_aes_dev *dev)</span>
 {
 	int err;
<span class="p_add">+	bool ret = false;</span>
 
 	s5p_unset_indata(dev);
 
 	if (!sg_is_last(dev-&gt;sg_src)) {
 		err = s5p_set_indata(dev, sg_next(dev-&gt;sg_src));
<span class="p_del">-		if (err) {</span>
<span class="p_add">+		if (err)</span>
 			s5p_aes_complete(dev, err);
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		s5p_set_dma_indata(dev, dev-&gt;sg_src);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			ret = true;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static irqreturn_t s5p_aes_interrupt(int irq, void *dev_id)
<span class="p_chunk">@@ -358,19 +370,32 @@</span> <span class="p_context"> static irqreturn_t s5p_aes_interrupt(int irq, void *dev_id)</span>
 	struct s5p_aes_dev     *dev  = platform_get_drvdata(pdev);
 	uint32_t                status;
 	unsigned long           flags;
<span class="p_add">+	bool			set_dma_tx = false;</span>
<span class="p_add">+	bool			set_dma_rx = false;</span>
 
 	spin_lock_irqsave(&amp;dev-&gt;lock, flags);
 
 	if (irq == dev-&gt;irq_fc) {
 		status = SSS_READ(dev, FCINTSTAT);
 		if (status &amp; SSS_FCINTSTAT_BRDMAINT)
<span class="p_del">-			s5p_aes_rx(dev);</span>
<span class="p_add">+			set_dma_rx = s5p_aes_rx(dev);</span>
 		if (status &amp; SSS_FCINTSTAT_BTDMAINT)
<span class="p_del">-			s5p_aes_tx(dev);</span>
<span class="p_add">+			set_dma_tx = s5p_aes_tx(dev);</span>
 
 		SSS_WRITE(dev, FCINTPEND, status);
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Writing length of DMA block (either receiving or transmitting)</span>
<span class="p_add">+	 * will start the operation immediately, so this should be done</span>
<span class="p_add">+	 * at the end (even after clearing pending interrupts to not miss the</span>
<span class="p_add">+	 * interrupt).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (set_dma_tx)</span>
<span class="p_add">+		s5p_set_dma_outdata(dev, dev-&gt;sg_dst);</span>
<span class="p_add">+	if (set_dma_rx)</span>
<span class="p_add">+		s5p_set_dma_indata(dev, dev-&gt;sg_src);</span>
<span class="p_add">+</span>
 	spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);
 
 	return IRQ_HANDLED;
<span class="p_header">diff --git a/drivers/crypto/ux500/hash/hash_core.c b/drivers/crypto/ux500/hash/hash_core.c</span>
<span class="p_header">index 8e5e0187506f..3ff21c3e9ab2 100644</span>
<span class="p_header">--- a/drivers/crypto/ux500/hash/hash_core.c</span>
<span class="p_header">+++ b/drivers/crypto/ux500/hash/hash_core.c</span>
<span class="p_chunk">@@ -797,7 +797,7 @@</span> <span class="p_context"> static int hash_process_data(struct hash_device_data *device_data,</span>
 						&amp;device_data-&gt;state);
 				memmove(req_ctx-&gt;state.buffer,
 					device_data-&gt;state.buffer,
<span class="p_del">-					HASH_BLOCK_SIZE / sizeof(u32));</span>
<span class="p_add">+					HASH_BLOCK_SIZE);</span>
 				if (ret) {
 					dev_err(device_data-&gt;dev,
 						&quot;%s: hash_resume_state() failed!\n&quot;,
<span class="p_chunk">@@ -848,7 +848,7 @@</span> <span class="p_context"> static int hash_process_data(struct hash_device_data *device_data,</span>
 
 			memmove(device_data-&gt;state.buffer,
 				req_ctx-&gt;state.buffer,
<span class="p_del">-				HASH_BLOCK_SIZE / sizeof(u32));</span>
<span class="p_add">+				HASH_BLOCK_SIZE);</span>
 			if (ret) {
 				dev_err(device_data-&gt;dev, &quot;%s: hash_save_state() failed!\n&quot;,
 					__func__);
<span class="p_header">diff --git a/drivers/edac/edac_mc.c b/drivers/edac/edac_mc.c</span>
<span class="p_header">index 9e471c5e185b..6238143aa476 100644</span>
<span class="p_header">--- a/drivers/edac/edac_mc.c</span>
<span class="p_header">+++ b/drivers/edac/edac_mc.c</span>
<span class="p_chunk">@@ -962,7 +962,7 @@</span> <span class="p_context"> static void edac_inc_ue_error(struct mem_ctl_info *mci,</span>
 	mci-&gt;ue_mc += count;
 
 	if (!enable_per_layer_report) {
<span class="p_del">-		mci-&gt;ce_noinfo_count += count;</span>
<span class="p_add">+		mci-&gt;ue_noinfo_count += count;</span>
 		return;
 	}
 
<span class="p_header">diff --git a/drivers/gpio/gpio-bcm-kona.c b/drivers/gpio/gpio-bcm-kona.c</span>
<span class="p_header">index 3f6b33ce9bd4..39805c87034c 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-bcm-kona.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-bcm-kona.c</span>
<span class="p_chunk">@@ -549,11 +549,11 @@</span> <span class="p_context"> static void bcm_kona_gpio_reset(struct bcm_kona_gpio *kona_gpio)</span>
 	/* disable interrupts and clear status */
 	for (i = 0; i &lt; kona_gpio-&gt;num_bank; i++) {
 		/* Unlock the entire bank first */
<span class="p_del">-		bcm_kona_gpio_write_lock_regs(kona_gpio, i, UNLOCK_CODE);</span>
<span class="p_add">+		bcm_kona_gpio_write_lock_regs(reg_base, i, UNLOCK_CODE);</span>
 		writel(0xffffffff, reg_base + GPIO_INT_MASK(i));
 		writel(0xffffffff, reg_base + GPIO_INT_STATUS(i));
 		/* Now re-lock the bank */
<span class="p_del">-		bcm_kona_gpio_write_lock_regs(kona_gpio, i, LOCK_CODE);</span>
<span class="p_add">+		bcm_kona_gpio_write_lock_regs(reg_base, i, LOCK_CODE);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/drm_fb_helper.c b/drivers/gpu/drm/drm_fb_helper.c</span>
<span class="p_header">index 20e820c3abbb..a61dcb35606d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_fb_helper.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_fb_helper.c</span>
<span class="p_chunk">@@ -1396,7 +1396,6 @@</span> <span class="p_context"> static int drm_pick_crtcs(struct drm_fb_helper *fb_helper,</span>
 			  int n, int width, int height)
 {
 	int c, o;
<span class="p_del">-	struct drm_device *dev = fb_helper-&gt;dev;</span>
 	struct drm_connector *connector;
 	struct drm_connector_helper_funcs *connector_funcs;
 	struct drm_encoder *encoder;
<span class="p_chunk">@@ -1415,7 +1414,7 @@</span> <span class="p_context"> static int drm_pick_crtcs(struct drm_fb_helper *fb_helper,</span>
 	if (modes[n] == NULL)
 		return best_score;
 
<span class="p_del">-	crtcs = kzalloc(dev-&gt;mode_config.num_connector *</span>
<span class="p_add">+	crtcs = kzalloc(fb_helper-&gt;connector_count *</span>
 			sizeof(struct drm_fb_helper_crtc *), GFP_KERNEL);
 	if (!crtcs)
 		return best_score;
<span class="p_chunk">@@ -1461,7 +1460,7 @@</span> <span class="p_context"> static int drm_pick_crtcs(struct drm_fb_helper *fb_helper,</span>
 		if (score &gt; best_score) {
 			best_score = score;
 			memcpy(best_crtcs, crtcs,
<span class="p_del">-			       dev-&gt;mode_config.num_connector *</span>
<span class="p_add">+			       fb_helper-&gt;connector_count *</span>
 			       sizeof(struct drm_fb_helper_crtc *));
 		}
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/gma500/mdfld_dsi_pkg_sender.c b/drivers/gpu/drm/gma500/mdfld_dsi_pkg_sender.c</span>
<span class="p_header">index 87885d8c06e8..4869117b69eb 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/gma500/mdfld_dsi_pkg_sender.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/gma500/mdfld_dsi_pkg_sender.c</span>
<span class="p_chunk">@@ -85,7 +85,7 @@</span> <span class="p_context"> static const char *const dsi_errors[] = {</span>
 	&quot;RX Prot Violation&quot;,
 	&quot;HS Generic Write FIFO Full&quot;,
 	&quot;LP Generic Write FIFO Full&quot;,
<span class="p_del">-	&quot;Generic Read Data Avail&quot;</span>
<span class="p_add">+	&quot;Generic Read Data Avail&quot;,</span>
 	&quot;Special Packet Sent&quot;,
 	&quot;Tearing Effect&quot;,
 };
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem_context.c b/drivers/gpu/drm/i915/i915_gem_context.c</span>
<span class="p_header">index 14f92644828a..c1dc47202021 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem_context.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem_context.c</span>
<span class="p_chunk">@@ -566,7 +566,7 @@</span> <span class="p_context"> mi_set_context(struct intel_engine_cs *ring,</span>
 
 	len = 4;
 	if (INTEL_INFO(ring-&gt;dev)-&gt;gen &gt;= 7)
<span class="p_del">-		len += 2 + (num_rings ? 4*num_rings + 2 : 0);</span>
<span class="p_add">+		len += 2 + (num_rings ? 4*num_rings + 6 : 0);</span>
 
 	ret = intel_ring_begin(ring, len);
 	if (ret)
<span class="p_chunk">@@ -605,15 +605,25 @@</span> <span class="p_context"> mi_set_context(struct intel_engine_cs *ring,</span>
 	if (INTEL_INFO(ring-&gt;dev)-&gt;gen &gt;= 7) {
 		if (num_rings) {
 			struct intel_engine_cs *signaller;
<span class="p_add">+			u32 last_reg = 0; /* keep gcc quiet */</span>
 
 			intel_ring_emit(ring, MI_LOAD_REGISTER_IMM(num_rings));
 			for_each_ring(signaller, to_i915(ring-&gt;dev), i) {
 				if (signaller == ring)
 					continue;
 
<span class="p_del">-				intel_ring_emit(ring, RING_PSMI_CTL(signaller-&gt;mmio_base));</span>
<span class="p_add">+				last_reg = RING_PSMI_CTL(signaller-&gt;mmio_base);</span>
<span class="p_add">+				intel_ring_emit(ring, last_reg);</span>
 				intel_ring_emit(ring, _MASKED_BIT_DISABLE(GEN6_PSMI_SLEEP_MSG_DISABLE));
 			}
<span class="p_add">+</span>
<span class="p_add">+			/* Insert a delay before the next switch! */</span>
<span class="p_add">+			intel_ring_emit(ring,</span>
<span class="p_add">+					MI_STORE_REGISTER_MEM(1) |</span>
<span class="p_add">+					MI_SRM_LRM_GLOBAL_GTT);</span>
<span class="p_add">+			intel_ring_emit(ring, last_reg);</span>
<span class="p_add">+			intel_ring_emit(ring, ring-&gt;scratch.gtt_offset);</span>
<span class="p_add">+			intel_ring_emit(ring, MI_NOOP);</span>
 		}
 		intel_ring_emit(ring, MI_ARB_ON_OFF | MI_ARB_ENABLE);
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index 3b06ebf58813..a62393650307 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -6263,12 +6263,14 @@</span> <span class="p_context"> static void ironlake_init_pch_refclk(struct drm_device *dev)</span>
 	struct drm_i915_private *dev_priv = dev-&gt;dev_private;
 	struct drm_mode_config *mode_config = &amp;dev-&gt;mode_config;
 	struct intel_encoder *encoder;
<span class="p_add">+	int i;</span>
 	u32 val, final;
 	bool has_lvds = false;
 	bool has_cpu_edp = false;
 	bool has_panel = false;
 	bool has_ck505 = false;
 	bool can_ssc = false;
<span class="p_add">+	bool using_ssc_source = false;</span>
 
 	/* We need to take the global config into account */
 	list_for_each_entry(encoder, &amp;mode_config-&gt;encoder_list,
<span class="p_chunk">@@ -6294,8 +6296,22 @@</span> <span class="p_context"> static void ironlake_init_pch_refclk(struct drm_device *dev)</span>
 		can_ssc = true;
 	}
 
<span class="p_del">-	DRM_DEBUG_KMS(&quot;has_panel %d has_lvds %d has_ck505 %d\n&quot;,</span>
<span class="p_del">-		      has_panel, has_lvds, has_ck505);</span>
<span class="p_add">+	/* Check if any DPLLs are using the SSC source */</span>
<span class="p_add">+	for (i = 0; i &lt; dev_priv-&gt;num_shared_dpll; i++) {</span>
<span class="p_add">+		u32 temp = I915_READ(PCH_DPLL(i));</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!(temp &amp; DPLL_VCO_ENABLE))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((temp &amp; PLL_REF_INPUT_MASK) ==</span>
<span class="p_add">+		    PLLB_REF_INPUT_SPREADSPECTRUMIN) {</span>
<span class="p_add">+			using_ssc_source = true;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	DRM_DEBUG_KMS(&quot;has_panel %d has_lvds %d has_ck505 %d using_ssc_source %d\n&quot;,</span>
<span class="p_add">+		      has_panel, has_lvds, has_ck505, using_ssc_source);</span>
 
 	/* Ironlake: try to setup display ref clock before DPLL
 	 * enabling. This is only under driver&#39;s control after
<span class="p_chunk">@@ -6332,9 +6348,9 @@</span> <span class="p_context"> static void ironlake_init_pch_refclk(struct drm_device *dev)</span>
 				final |= DREF_CPU_SOURCE_OUTPUT_NONSPREAD;
 		} else
 			final |= DREF_CPU_SOURCE_OUTPUT_DISABLE;
<span class="p_del">-	} else {</span>
<span class="p_del">-		final |= DREF_SSC_SOURCE_DISABLE;</span>
<span class="p_del">-		final |= DREF_CPU_SOURCE_OUTPUT_DISABLE;</span>
<span class="p_add">+	} else if (using_ssc_source) {</span>
<span class="p_add">+		final |= DREF_SSC_SOURCE_ENABLE;</span>
<span class="p_add">+		final |= DREF_SSC1_ENABLE;</span>
 	}
 
 	if (final == val)
<span class="p_chunk">@@ -6380,7 +6396,7 @@</span> <span class="p_context"> static void ironlake_init_pch_refclk(struct drm_device *dev)</span>
 		POSTING_READ(PCH_DREF_CONTROL);
 		udelay(200);
 	} else {
<span class="p_del">-		DRM_DEBUG_KMS(&quot;Disabling SSC entirely\n&quot;);</span>
<span class="p_add">+		DRM_DEBUG_KMS(&quot;Disabling CPU source output\n&quot;);</span>
 
 		val &amp;= ~DREF_CPU_SOURCE_OUTPUT_MASK;
 
<span class="p_chunk">@@ -6391,16 +6407,20 @@</span> <span class="p_context"> static void ironlake_init_pch_refclk(struct drm_device *dev)</span>
 		POSTING_READ(PCH_DREF_CONTROL);
 		udelay(200);
 
<span class="p_del">-		/* Turn off the SSC source */</span>
<span class="p_del">-		val &amp;= ~DREF_SSC_SOURCE_MASK;</span>
<span class="p_del">-		val |= DREF_SSC_SOURCE_DISABLE;</span>
<span class="p_add">+		if (!using_ssc_source) {</span>
<span class="p_add">+			DRM_DEBUG_KMS(&quot;Disabling SSC source\n&quot;);</span>
 
<span class="p_del">-		/* Turn off SSC1 */</span>
<span class="p_del">-		val &amp;= ~DREF_SSC1_ENABLE;</span>
<span class="p_add">+			/* Turn off the SSC source */</span>
<span class="p_add">+			val &amp;= ~DREF_SSC_SOURCE_MASK;</span>
<span class="p_add">+			val |= DREF_SSC_SOURCE_DISABLE;</span>
 
<span class="p_del">-		I915_WRITE(PCH_DREF_CONTROL, val);</span>
<span class="p_del">-		POSTING_READ(PCH_DREF_CONTROL);</span>
<span class="p_del">-		udelay(200);</span>
<span class="p_add">+			/* Turn off SSC1 */</span>
<span class="p_add">+			val &amp;= ~DREF_SSC1_ENABLE;</span>
<span class="p_add">+</span>
<span class="p_add">+			I915_WRITE(PCH_DREF_CONTROL, val);</span>
<span class="p_add">+			POSTING_READ(PCH_DREF_CONTROL);</span>
<span class="p_add">+			udelay(200);</span>
<span class="p_add">+		}</span>
 	}
 
 	BUG_ON(val != final);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_fbdev.c b/drivers/gpu/drm/i915/intel_fbdev.c</span>
<span class="p_header">index 088fe9378a4c..6f859fff3bc4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_fbdev.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_fbdev.c</span>
<span class="p_chunk">@@ -323,12 +323,12 @@</span> <span class="p_context"> static bool intel_fb_initial_config(struct drm_fb_helper *fb_helper,</span>
 			return false;
 	}
 
<span class="p_del">-	save_enabled = kcalloc(dev-&gt;mode_config.num_connector, sizeof(bool),</span>
<span class="p_add">+	save_enabled = kcalloc(fb_helper-&gt;connector_count, sizeof(bool),</span>
 			       GFP_KERNEL);
 	if (!save_enabled)
 		return false;
 
<span class="p_del">-	memcpy(save_enabled, enabled, dev-&gt;mode_config.num_connector);</span>
<span class="p_add">+	memcpy(save_enabled, enabled, fb_helper-&gt;connector_count);</span>
 
 	for (i = 0; i &lt; fb_helper-&gt;connector_count; i++) {
 		struct drm_fb_helper_connector *fb_conn;
<span class="p_chunk">@@ -443,7 +443,7 @@</span> <span class="p_context"> static bool intel_fb_initial_config(struct drm_fb_helper *fb_helper,</span>
 out:
 	if (fallback) {
 		DRM_DEBUG_KMS(&quot;Not using firmware configuration\n&quot;);
<span class="p_del">-		memcpy(enabled, save_enabled, dev-&gt;mode_config.num_connector);</span>
<span class="p_add">+		memcpy(enabled, save_enabled, fb_helper-&gt;connector_count);</span>
 		kfree(save_enabled);
 		return false;
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_pm.c b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">index e6f131db18cc..700a7d068204 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_chunk">@@ -2751,6 +2751,8 @@</span> <span class="p_context"> static void ilk_pipe_wm_get_hw_state(struct drm_crtc *crtc)</span>
 	if (IS_HASWELL(dev) || IS_BROADWELL(dev))
 		hw-&gt;wm_linetime[pipe] = I915_READ(PIPE_WM_LINETIME(pipe));
 
<span class="p_add">+	memset(active, 0, sizeof(*active));</span>
<span class="p_add">+</span>
 	active-&gt;pipe_enabled = intel_crtc_active(crtc);
 
 	if (active-&gt;pipe_enabled) {
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nouveau_fbcon.c b/drivers/gpu/drm/nouveau/nouveau_fbcon.c</span>
<span class="p_header">index b9d6bf22cc5a..f6cbc9f66c18 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nouveau_fbcon.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nouveau_fbcon.c</span>
<span class="p_chunk">@@ -562,6 +562,7 @@</span> <span class="p_context"> nouveau_fbcon_init(struct drm_device *dev)</span>
 	drm_helper_disable_unused_functions(dev);
 
 	drm_fb_helper_initial_config(&amp;fbcon-&gt;helper, preferred_bpp);
<span class="p_add">+	fbcon-&gt;helper.fbdev-&gt;pixmap.buf_align = 4;</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nv04_fbcon.c b/drivers/gpu/drm/nouveau/nv04_fbcon.c</span>
<span class="p_header">index 8fe32bbed99a..cf4ad5142f21 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nv04_fbcon.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nv04_fbcon.c</span>
<span class="p_chunk">@@ -84,7 +84,6 @@</span> <span class="p_context"> nv04_fbcon_imageblit(struct fb_info *info, const struct fb_image *image)</span>
 	uint32_t fg;
 	uint32_t bg;
 	uint32_t dsize;
<span class="p_del">-	uint32_t width;</span>
 	uint32_t *data = (uint32_t *)image-&gt;data;
 	int ret;
 
<span class="p_chunk">@@ -95,9 +94,6 @@</span> <span class="p_context"> nv04_fbcon_imageblit(struct fb_info *info, const struct fb_image *image)</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	width = ALIGN(image-&gt;width, 8);</span>
<span class="p_del">-	dsize = ALIGN(width * image-&gt;height, 32) &gt;&gt; 5;</span>
<span class="p_del">-</span>
 	if (info-&gt;fix.visual == FB_VISUAL_TRUECOLOR ||
 	    info-&gt;fix.visual == FB_VISUAL_DIRECTCOLOR) {
 		fg = ((uint32_t *) info-&gt;pseudo_palette)[image-&gt;fg_color];
<span class="p_chunk">@@ -113,10 +109,11 @@</span> <span class="p_context"> nv04_fbcon_imageblit(struct fb_info *info, const struct fb_image *image)</span>
 			 ((image-&gt;dx + image-&gt;width) &amp; 0xffff));
 	OUT_RING(chan, bg);
 	OUT_RING(chan, fg);
<span class="p_del">-	OUT_RING(chan, (image-&gt;height &lt;&lt; 16) | width);</span>
<span class="p_add">+	OUT_RING(chan, (image-&gt;height &lt;&lt; 16) | image-&gt;width);</span>
 	OUT_RING(chan, (image-&gt;height &lt;&lt; 16) | image-&gt;width);
 	OUT_RING(chan, (image-&gt;dy &lt;&lt; 16) | (image-&gt;dx &amp; 0xffff));
 
<span class="p_add">+	dsize = ALIGN(image-&gt;width * image-&gt;height, 32) &gt;&gt; 5;</span>
 	while (dsize) {
 		int iter_len = dsize &gt; 128 ? 128 : dsize;
 
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nv50_fbcon.c b/drivers/gpu/drm/nouveau/nv50_fbcon.c</span>
<span class="p_header">index 52068a0910dc..3860b7443e90 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nv50_fbcon.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nv50_fbcon.c</span>
<span class="p_chunk">@@ -95,7 +95,7 @@</span> <span class="p_context"> nv50_fbcon_imageblit(struct fb_info *info, const struct fb_image *image)</span>
 	struct nouveau_fbdev *nfbdev = info-&gt;par;
 	struct nouveau_drm *drm = nouveau_drm(nfbdev-&gt;dev);
 	struct nouveau_channel *chan = drm-&gt;channel;
<span class="p_del">-	uint32_t width, dwords, *data = (uint32_t *)image-&gt;data;</span>
<span class="p_add">+	uint32_t dwords, *data = (uint32_t *)image-&gt;data;</span>
 	uint32_t mask = ~(~0 &gt;&gt; (32 - info-&gt;var.bits_per_pixel));
 	uint32_t *palette = info-&gt;pseudo_palette;
 	int ret;
<span class="p_chunk">@@ -107,9 +107,6 @@</span> <span class="p_context"> nv50_fbcon_imageblit(struct fb_info *info, const struct fb_image *image)</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	width = ALIGN(image-&gt;width, 32);</span>
<span class="p_del">-	dwords = (width * image-&gt;height) &gt;&gt; 5;</span>
<span class="p_del">-</span>
 	BEGIN_NV04(chan, NvSub2D, 0x0814, 2);
 	if (info-&gt;fix.visual == FB_VISUAL_TRUECOLOR ||
 	    info-&gt;fix.visual == FB_VISUAL_DIRECTCOLOR) {
<span class="p_chunk">@@ -128,6 +125,7 @@</span> <span class="p_context"> nv50_fbcon_imageblit(struct fb_info *info, const struct fb_image *image)</span>
 	OUT_RING(chan, 0);
 	OUT_RING(chan, image-&gt;dy);
 
<span class="p_add">+	dwords = ALIGN(image-&gt;width * image-&gt;height, 32) &gt;&gt; 5;</span>
 	while (dwords) {
 		int push = dwords &gt; 2047 ? 2047 : dwords;
 
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvc0_fbcon.c b/drivers/gpu/drm/nouveau/nvc0_fbcon.c</span>
<span class="p_header">index 9dcd30f3e1e0..fff0a1a33df0 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvc0_fbcon.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvc0_fbcon.c</span>
<span class="p_chunk">@@ -95,7 +95,7 @@</span> <span class="p_context"> nvc0_fbcon_imageblit(struct fb_info *info, const struct fb_image *image)</span>
 	struct nouveau_fbdev *nfbdev = info-&gt;par;
 	struct nouveau_drm *drm = nouveau_drm(nfbdev-&gt;dev);
 	struct nouveau_channel *chan = drm-&gt;channel;
<span class="p_del">-	uint32_t width, dwords, *data = (uint32_t *)image-&gt;data;</span>
<span class="p_add">+	uint32_t dwords, *data = (uint32_t *)image-&gt;data;</span>
 	uint32_t mask = ~(~0 &gt;&gt; (32 - info-&gt;var.bits_per_pixel));
 	uint32_t *palette = info-&gt;pseudo_palette;
 	int ret;
<span class="p_chunk">@@ -107,9 +107,6 @@</span> <span class="p_context"> nvc0_fbcon_imageblit(struct fb_info *info, const struct fb_image *image)</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	width = ALIGN(image-&gt;width, 32);</span>
<span class="p_del">-	dwords = (width * image-&gt;height) &gt;&gt; 5;</span>
<span class="p_del">-</span>
 	BEGIN_NVC0(chan, NvSub2D, 0x0814, 2);
 	if (info-&gt;fix.visual == FB_VISUAL_TRUECOLOR ||
 	    info-&gt;fix.visual == FB_VISUAL_DIRECTCOLOR) {
<span class="p_chunk">@@ -128,6 +125,7 @@</span> <span class="p_context"> nvc0_fbcon_imageblit(struct fb_info *info, const struct fb_image *image)</span>
 	OUT_RING  (chan, 0);
 	OUT_RING  (chan, image-&gt;dy);
 
<span class="p_add">+	dwords = ALIGN(image-&gt;width * image-&gt;height, 32) &gt;&gt; 5;</span>
 	while (dwords) {
 		int push = dwords &gt; 2047 ? 2047 : dwords;
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_device.c b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">index e8122c91edcf..821c86bc70c2 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_chunk">@@ -598,6 +598,23 @@</span> <span class="p_context"> void radeon_gtt_location(struct radeon_device *rdev, struct radeon_mc *mc)</span>
 /*
  * GPU helpers function.
  */
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * radeon_device_is_virtual - check if we are running is a virtual environment</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Check if the asic has been passed through to a VM (all asics).</span>
<span class="p_add">+ * Used at driver startup.</span>
<span class="p_add">+ * Returns true if virtual or false if not.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool radeon_device_is_virtual(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_X86</span>
<span class="p_add">+	return boot_cpu_has(X86_FEATURE_HYPERVISOR);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * radeon_card_posted - check if the hw has already been initialized
  *
<span class="p_chunk">@@ -611,6 +628,10 @@</span> <span class="p_context"> bool radeon_card_posted(struct radeon_device *rdev)</span>
 {
 	uint32_t reg;
 
<span class="p_add">+	/* for pass through, always force asic_init */</span>
<span class="p_add">+	if (radeon_device_is_virtual())</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
 	/* required for EFI mode on macbook2,1 which uses an r5xx asic */
 	if (efi_enabled(EFI_BOOT) &amp;&amp;
 	    (rdev-&gt;pdev-&gt;subsystem_vendor == PCI_VENDOR_ID_APPLE) &amp;&amp;
<span class="p_header">diff --git a/drivers/hid/hid-elo.c b/drivers/hid/hid-elo.c</span>
<span class="p_header">index 4e49462870ab..d0c8a1c1e1fe 100644</span>
<span class="p_header">--- a/drivers/hid/hid-elo.c</span>
<span class="p_header">+++ b/drivers/hid/hid-elo.c</span>
<span class="p_chunk">@@ -259,7 +259,7 @@</span> <span class="p_context"> static void elo_remove(struct hid_device *hdev)</span>
 	struct elo_priv *priv = hid_get_drvdata(hdev);
 
 	hid_hw_stop(hdev);
<span class="p_del">-	flush_workqueue(wq);</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;priv-&gt;work);</span>
 	kfree(priv);
 }
 
<span class="p_header">diff --git a/drivers/hid/usbhid/hiddev.c b/drivers/hid/usbhid/hiddev.c</span>
<span class="p_header">index 2f1ddca6f2e0..700145b15088 100644</span>
<span class="p_header">--- a/drivers/hid/usbhid/hiddev.c</span>
<span class="p_header">+++ b/drivers/hid/usbhid/hiddev.c</span>
<span class="p_chunk">@@ -516,13 +516,13 @@</span> <span class="p_context"> static noinline int hiddev_ioctl_usage(struct hiddev *hiddev, unsigned int cmd,</span>
 					goto inval;
 			} else if (uref-&gt;usage_index &gt;= field-&gt;report_count)
 				goto inval;
<span class="p_del">-</span>
<span class="p_del">-			else if ((cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) &amp;&amp;</span>
<span class="p_del">-				 (uref_multi-&gt;num_values &gt; HID_MAX_MULTI_USAGES ||</span>
<span class="p_del">-				  uref-&gt;usage_index + uref_multi-&gt;num_values &gt; field-&gt;report_count))</span>
<span class="p_del">-				goto inval;</span>
 		}
 
<span class="p_add">+		if ((cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) &amp;&amp;</span>
<span class="p_add">+		    (uref_multi-&gt;num_values &gt; HID_MAX_MULTI_USAGES ||</span>
<span class="p_add">+		     uref-&gt;usage_index + uref_multi-&gt;num_values &gt; field-&gt;report_count))</span>
<span class="p_add">+			goto inval;</span>
<span class="p_add">+</span>
 		switch (cmd) {
 		case HIDIOCGUSAGE:
 			uref-&gt;value = field-&gt;value[uref-&gt;usage_index];
<span class="p_header">diff --git a/drivers/iio/accel/kxsd9.c b/drivers/iio/accel/kxsd9.c</span>
<span class="p_header">index 98ba761cbb9c..d8738d4f8df3 100644</span>
<span class="p_header">--- a/drivers/iio/accel/kxsd9.c</span>
<span class="p_header">+++ b/drivers/iio/accel/kxsd9.c</span>
<span class="p_chunk">@@ -81,7 +81,7 @@</span> <span class="p_context"> static int kxsd9_write_scale(struct iio_dev *indio_dev, int micro)</span>
 
 	mutex_lock(&amp;st-&gt;buf_lock);
 	ret = spi_w8r8(st-&gt;us, KXSD9_READ(KXSD9_REG_CTRL_C));
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret &lt; 0)</span>
 		goto error_ret;
 	st-&gt;tx[0] = KXSD9_WRITE(KXSD9_REG_CTRL_C);
 	st-&gt;tx[1] = (ret &amp; ~KXSD9_FS_MASK) | i;
<span class="p_chunk">@@ -163,7 +163,7 @@</span> <span class="p_context"> static int kxsd9_read_raw(struct iio_dev *indio_dev,</span>
 		break;
 	case IIO_CHAN_INFO_SCALE:
 		ret = spi_w8r8(st-&gt;us, KXSD9_READ(KXSD9_REG_CTRL_C));
<span class="p_del">-		if (ret)</span>
<span class="p_add">+		if (ret &lt; 0)</span>
 			goto error_ret;
 		*val2 = kxsd9_micro_scales[ret &amp; KXSD9_FS_MASK];
 		ret = IIO_VAL_INT_PLUS_MICRO;
<span class="p_header">diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c</span>
<span class="p_header">index 70f78c3062a7..8e2b9e70511d 100644</span>
<span class="p_header">--- a/drivers/iio/adc/ad7266.c</span>
<span class="p_header">+++ b/drivers/iio/adc/ad7266.c</span>
<span class="p_chunk">@@ -396,8 +396,8 @@</span> <span class="p_context"> static int ad7266_probe(struct spi_device *spi)</span>
 
 	st = iio_priv(indio_dev);
 
<span class="p_del">-	st-&gt;reg = devm_regulator_get(&amp;spi-&gt;dev, &quot;vref&quot;);</span>
<span class="p_del">-	if (!IS_ERR_OR_NULL(st-&gt;reg)) {</span>
<span class="p_add">+	st-&gt;reg = devm_regulator_get_optional(&amp;spi-&gt;dev, &quot;vref&quot;);</span>
<span class="p_add">+	if (!IS_ERR(st-&gt;reg)) {</span>
 		ret = regulator_enable(st-&gt;reg);
 		if (ret)
 			return ret;
<span class="p_chunk">@@ -408,6 +408,9 @@</span> <span class="p_context"> static int ad7266_probe(struct spi_device *spi)</span>
 
 		st-&gt;vref_mv = ret / 1000;
 	} else {
<span class="p_add">+		/* Any other error indicates that the regulator does exist */</span>
<span class="p_add">+		if (PTR_ERR(st-&gt;reg) != -ENODEV)</span>
<span class="p_add">+			return PTR_ERR(st-&gt;reg);</span>
 		/* Use internal reference */
 		st-&gt;vref_mv = 2500;
 	}
<span class="p_header">diff --git a/drivers/iio/industrialio-trigger.c b/drivers/iio/industrialio-trigger.c</span>
<span class="p_header">index 3383b025f62e..68e3611787a6 100644</span>
<span class="p_header">--- a/drivers/iio/industrialio-trigger.c</span>
<span class="p_header">+++ b/drivers/iio/industrialio-trigger.c</span>
<span class="p_chunk">@@ -203,22 +203,35 @@</span> <span class="p_context"> static int iio_trigger_attach_poll_func(struct iio_trigger *trig,</span>
 
 	/* Prevent the module from being removed whilst attached to a trigger */
 	__module_get(pf-&gt;indio_dev-&gt;info-&gt;driver_module);
<span class="p_add">+</span>
<span class="p_add">+	/* Get irq number */</span>
 	pf-&gt;irq = iio_trigger_get_irq(trig);
<span class="p_add">+	if (pf-&gt;irq &lt; 0)</span>
<span class="p_add">+		goto out_put_module;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Request irq */</span>
 	ret = request_threaded_irq(pf-&gt;irq, pf-&gt;h, pf-&gt;thread,
 				   pf-&gt;type, pf-&gt;name,
 				   pf);
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		module_put(pf-&gt;indio_dev-&gt;info-&gt;driver_module);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		goto out_put_irq;</span>
 
<span class="p_add">+	/* Enable trigger in driver */</span>
 	if (trig-&gt;ops &amp;&amp; trig-&gt;ops-&gt;set_trigger_state &amp;&amp; notinuse) {
 		ret = trig-&gt;ops-&gt;set_trigger_state(trig, true);
 		if (ret &lt; 0)
<span class="p_del">-			module_put(pf-&gt;indio_dev-&gt;info-&gt;driver_module);</span>
<span class="p_add">+			goto out_free_irq;</span>
 	}
 
 	return ret;
<span class="p_add">+</span>
<span class="p_add">+out_free_irq:</span>
<span class="p_add">+	free_irq(pf-&gt;irq, pf);</span>
<span class="p_add">+out_put_irq:</span>
<span class="p_add">+	iio_trigger_put_irq(trig, pf-&gt;irq);</span>
<span class="p_add">+out_put_module:</span>
<span class="p_add">+	module_put(pf-&gt;indio_dev-&gt;info-&gt;driver_module);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int iio_trigger_detach_poll_func(struct iio_trigger *trig,
<span class="p_header">diff --git a/drivers/iio/pressure/st_pressure_core.c b/drivers/iio/pressure/st_pressure_core.c</span>
<span class="p_header">index 1aa7c18471a8..0d70176af296 100644</span>
<span class="p_header">--- a/drivers/iio/pressure/st_pressure_core.c</span>
<span class="p_header">+++ b/drivers/iio/pressure/st_pressure_core.c</span>
<span class="p_chunk">@@ -28,15 +28,21 @@</span> <span class="p_context"></span>
 #include &lt;linux/iio/common/st_sensors.h&gt;
 #include &quot;st_pressure.h&quot;
 
<span class="p_add">+#define MCELSIUS_PER_CELSIUS			1000</span>
<span class="p_add">+</span>
<span class="p_add">+/* Default pressure sensitivity */</span>
 #define ST_PRESS_LSB_PER_MBAR			4096UL
 #define ST_PRESS_KPASCAL_NANO_SCALE		(100000000UL / \
 						 ST_PRESS_LSB_PER_MBAR)
<span class="p_add">+</span>
<span class="p_add">+/* Default temperature sensitivity */</span>
 #define ST_PRESS_LSB_PER_CELSIUS		480UL
<span class="p_del">-#define ST_PRESS_CELSIUS_NANO_SCALE		(1000000000UL / \</span>
<span class="p_del">-						 ST_PRESS_LSB_PER_CELSIUS)</span>
<span class="p_add">+#define ST_PRESS_MILLI_CELSIUS_OFFSET		42500UL</span>
<span class="p_add">+</span>
 #define ST_PRESS_NUMBER_DATA_CHANNELS		1
 
 /* FULLSCALE */
<span class="p_add">+#define ST_PRESS_FS_AVL_1100MB			1100</span>
 #define ST_PRESS_FS_AVL_1260MB			1260
 
 #define ST_PRESS_1_OUT_XL_ADDR			0x28
<span class="p_chunk">@@ -54,18 +60,20 @@</span> <span class="p_context"></span>
 #define ST_PRESS_LPS331AP_PW_MASK		0x80
 #define ST_PRESS_LPS331AP_FS_ADDR		0x23
 #define ST_PRESS_LPS331AP_FS_MASK		0x30
<span class="p_del">-#define ST_PRESS_LPS331AP_FS_AVL_1260_VAL	0x00</span>
<span class="p_del">-#define ST_PRESS_LPS331AP_FS_AVL_1260_GAIN	ST_PRESS_KPASCAL_NANO_SCALE</span>
<span class="p_del">-#define ST_PRESS_LPS331AP_FS_AVL_TEMP_GAIN	ST_PRESS_CELSIUS_NANO_SCALE</span>
 #define ST_PRESS_LPS331AP_BDU_ADDR		0x20
 #define ST_PRESS_LPS331AP_BDU_MASK		0x04
 #define ST_PRESS_LPS331AP_DRDY_IRQ_ADDR		0x22
 #define ST_PRESS_LPS331AP_DRDY_IRQ_INT1_MASK	0x04
 #define ST_PRESS_LPS331AP_DRDY_IRQ_INT2_MASK	0x20
 #define ST_PRESS_LPS331AP_MULTIREAD_BIT		true
<span class="p_del">-#define ST_PRESS_LPS331AP_TEMP_OFFSET		42500</span>
 
 /* CUSTOM VALUES FOR LPS001WP SENSOR */
<span class="p_add">+</span>
<span class="p_add">+/* LPS001WP pressure resolution */</span>
<span class="p_add">+#define ST_PRESS_LPS001WP_LSB_PER_MBAR		16UL</span>
<span class="p_add">+/* LPS001WP temperature resolution */</span>
<span class="p_add">+#define ST_PRESS_LPS001WP_LSB_PER_CELSIUS	64UL</span>
<span class="p_add">+</span>
 #define ST_PRESS_LPS001WP_WAI_EXP		0xba
 #define ST_PRESS_LPS001WP_ODR_ADDR		0x20
 #define ST_PRESS_LPS001WP_ODR_MASK		0x30
<span class="p_chunk">@@ -74,6 +82,8 @@</span> <span class="p_context"></span>
 #define ST_PRESS_LPS001WP_ODR_AVL_13HZ_VAL	0x03
 #define ST_PRESS_LPS001WP_PW_ADDR		0x20
 #define ST_PRESS_LPS001WP_PW_MASK		0x40
<span class="p_add">+#define ST_PRESS_LPS001WP_FS_AVL_PRESS_GAIN \</span>
<span class="p_add">+	(100000000UL / ST_PRESS_LPS001WP_LSB_PER_MBAR)</span>
 #define ST_PRESS_LPS001WP_BDU_ADDR		0x20
 #define ST_PRESS_LPS001WP_BDU_MASK		0x04
 #define ST_PRESS_LPS001WP_MULTIREAD_BIT		true
<span class="p_chunk">@@ -90,18 +100,12 @@</span> <span class="p_context"></span>
 #define ST_PRESS_LPS25H_ODR_AVL_25HZ_VAL	0x04
 #define ST_PRESS_LPS25H_PW_ADDR			0x20
 #define ST_PRESS_LPS25H_PW_MASK			0x80
<span class="p_del">-#define ST_PRESS_LPS25H_FS_ADDR			0x00</span>
<span class="p_del">-#define ST_PRESS_LPS25H_FS_MASK			0x00</span>
<span class="p_del">-#define ST_PRESS_LPS25H_FS_AVL_1260_VAL		0x00</span>
<span class="p_del">-#define ST_PRESS_LPS25H_FS_AVL_1260_GAIN	ST_PRESS_KPASCAL_NANO_SCALE</span>
<span class="p_del">-#define ST_PRESS_LPS25H_FS_AVL_TEMP_GAIN	ST_PRESS_CELSIUS_NANO_SCALE</span>
 #define ST_PRESS_LPS25H_BDU_ADDR		0x20
 #define ST_PRESS_LPS25H_BDU_MASK		0x04
 #define ST_PRESS_LPS25H_DRDY_IRQ_ADDR		0x23
 #define ST_PRESS_LPS25H_DRDY_IRQ_INT1_MASK	0x01
 #define ST_PRESS_LPS25H_DRDY_IRQ_INT2_MASK	0x10
 #define ST_PRESS_LPS25H_MULTIREAD_BIT		true
<span class="p_del">-#define ST_PRESS_LPS25H_TEMP_OFFSET		42500</span>
 #define ST_PRESS_LPS25H_OUT_XL_ADDR		0x28
 #define ST_TEMP_LPS25H_OUT_L_ADDR		0x2b
 
<span class="p_chunk">@@ -153,7 +157,9 @@</span> <span class="p_context"> static const struct iio_chan_spec st_press_lps001wp_channels[] = {</span>
 			.storagebits = 16,
 			.endianness = IIO_LE,
 		},
<span class="p_del">-		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),</span>
<span class="p_add">+		.info_mask_separate =</span>
<span class="p_add">+			BIT(IIO_CHAN_INFO_RAW) |</span>
<span class="p_add">+			BIT(IIO_CHAN_INFO_SCALE),</span>
 		.modified = 0,
 	},
 	{
<span class="p_chunk">@@ -169,7 +175,7 @@</span> <span class="p_context"> static const struct iio_chan_spec st_press_lps001wp_channels[] = {</span>
 		},
 		.info_mask_separate =
 			BIT(IIO_CHAN_INFO_RAW) |
<span class="p_del">-			BIT(IIO_CHAN_INFO_OFFSET),</span>
<span class="p_add">+			BIT(IIO_CHAN_INFO_SCALE),</span>
 		.modified = 0,
 	},
 	IIO_CHAN_SOFT_TIMESTAMP(1)
<span class="p_chunk">@@ -203,11 +209,14 @@</span> <span class="p_context"> static const struct st_sensors st_press_sensors[] = {</span>
 			.addr = ST_PRESS_LPS331AP_FS_ADDR,
 			.mask = ST_PRESS_LPS331AP_FS_MASK,
 			.fs_avl = {
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Pressure and temperature sensitivity values</span>
<span class="p_add">+				 * as defined in table 3 of LPS331AP datasheet.</span>
<span class="p_add">+				 */</span>
 				[0] = {
 					.num = ST_PRESS_FS_AVL_1260MB,
<span class="p_del">-					.value = ST_PRESS_LPS331AP_FS_AVL_1260_VAL,</span>
<span class="p_del">-					.gain = ST_PRESS_LPS331AP_FS_AVL_1260_GAIN,</span>
<span class="p_del">-					.gain2 = ST_PRESS_LPS331AP_FS_AVL_TEMP_GAIN,</span>
<span class="p_add">+					.gain = ST_PRESS_KPASCAL_NANO_SCALE,</span>
<span class="p_add">+					.gain2 = ST_PRESS_LSB_PER_CELSIUS,</span>
 				},
 			},
 		},
<span class="p_chunk">@@ -246,7 +255,17 @@</span> <span class="p_context"> static const struct st_sensors st_press_sensors[] = {</span>
 			.value_off = ST_SENSORS_DEFAULT_POWER_OFF_VALUE,
 		},
 		.fs = {
<span class="p_del">-			.addr = 0,</span>
<span class="p_add">+			.fs_avl = {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Pressure and temperature resolution values</span>
<span class="p_add">+				 * as defined in table 3 of LPS001WP datasheet.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				[0] = {</span>
<span class="p_add">+					.num = ST_PRESS_FS_AVL_1100MB,</span>
<span class="p_add">+					.gain = ST_PRESS_LPS001WP_FS_AVL_PRESS_GAIN,</span>
<span class="p_add">+					.gain2 = ST_PRESS_LPS001WP_LSB_PER_CELSIUS,</span>
<span class="p_add">+				},</span>
<span class="p_add">+			},</span>
 		},
 		.bdu = {
 			.addr = ST_PRESS_LPS001WP_BDU_ADDR,
<span class="p_chunk">@@ -282,14 +301,15 @@</span> <span class="p_context"> static const struct st_sensors st_press_sensors[] = {</span>
 			.value_off = ST_SENSORS_DEFAULT_POWER_OFF_VALUE,
 		},
 		.fs = {
<span class="p_del">-			.addr = ST_PRESS_LPS25H_FS_ADDR,</span>
<span class="p_del">-			.mask = ST_PRESS_LPS25H_FS_MASK,</span>
 			.fs_avl = {
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Pressure and temperature sensitivity values</span>
<span class="p_add">+				 * as defined in table 3 of LPS25H datasheet.</span>
<span class="p_add">+				 */</span>
 				[0] = {
 					.num = ST_PRESS_FS_AVL_1260MB,
<span class="p_del">-					.value = ST_PRESS_LPS25H_FS_AVL_1260_VAL,</span>
<span class="p_del">-					.gain = ST_PRESS_LPS25H_FS_AVL_1260_GAIN,</span>
<span class="p_del">-					.gain2 = ST_PRESS_LPS25H_FS_AVL_TEMP_GAIN,</span>
<span class="p_add">+					.gain = ST_PRESS_KPASCAL_NANO_SCALE,</span>
<span class="p_add">+					.gain2 = ST_PRESS_LSB_PER_CELSIUS,</span>
 				},
 			},
 		},
<span class="p_chunk">@@ -322,26 +342,26 @@</span> <span class="p_context"> static int st_press_read_raw(struct iio_dev *indio_dev,</span>
 
 		return IIO_VAL_INT;
 	case IIO_CHAN_INFO_SCALE:
<span class="p_del">-		*val = 0;</span>
<span class="p_del">-</span>
 		switch (ch-&gt;type) {
 		case IIO_PRESSURE:
<span class="p_add">+			*val = 0;</span>
 			*val2 = pdata-&gt;current_fullscale-&gt;gain;
<span class="p_del">-			break;</span>
<span class="p_add">+			return IIO_VAL_INT_PLUS_NANO;</span>
 		case IIO_TEMP:
<span class="p_add">+			*val = MCELSIUS_PER_CELSIUS;</span>
 			*val2 = pdata-&gt;current_fullscale-&gt;gain2;
<span class="p_del">-			break;</span>
<span class="p_add">+			return IIO_VAL_FRACTIONAL;</span>
 		default:
 			err = -EINVAL;
 			goto read_error;
 		}
 
<span class="p_del">-		return IIO_VAL_INT_PLUS_NANO;</span>
 	case IIO_CHAN_INFO_OFFSET:
 		switch (ch-&gt;type) {
 		case IIO_TEMP:
<span class="p_del">-			*val = 425;</span>
<span class="p_del">-			*val2 = 10;</span>
<span class="p_add">+			*val = ST_PRESS_MILLI_CELSIUS_OFFSET *</span>
<span class="p_add">+			       pdata-&gt;current_fullscale-&gt;gain2;</span>
<span class="p_add">+			*val2 = MCELSIUS_PER_CELSIUS;</span>
 			break;
 		default:
 			err = -EINVAL;
<span class="p_header">diff --git a/drivers/iio/proximity/as3935.c b/drivers/iio/proximity/as3935.c</span>
<span class="p_header">index d102210b207d..37c1bb2afd08 100644</span>
<span class="p_header">--- a/drivers/iio/proximity/as3935.c</span>
<span class="p_header">+++ b/drivers/iio/proximity/as3935.c</span>
<span class="p_chunk">@@ -64,6 +64,7 @@</span> <span class="p_context"> struct as3935_state {</span>
 	struct delayed_work work;
 
 	u32 tune_cap;
<span class="p_add">+	u8 buffer[16]; /* 8-bit data + 56-bit padding + 64-bit timestamp */</span>
 	u8 buf[2] ____cacheline_aligned;
 };
 
<span class="p_chunk">@@ -72,7 +73,8 @@</span> <span class="p_context"> static const struct iio_chan_spec as3935_channels[] = {</span>
 		.type           = IIO_PROXIMITY,
 		.info_mask_separate =
 			BIT(IIO_CHAN_INFO_RAW) |
<span class="p_del">-			BIT(IIO_CHAN_INFO_PROCESSED),</span>
<span class="p_add">+			BIT(IIO_CHAN_INFO_PROCESSED) |</span>
<span class="p_add">+			BIT(IIO_CHAN_INFO_SCALE),</span>
 		.scan_index     = 0,
 		.scan_type = {
 			.sign           = &#39;u&#39;,
<span class="p_chunk">@@ -181,7 +183,12 @@</span> <span class="p_context"> static int as3935_read_raw(struct iio_dev *indio_dev,</span>
 		/* storm out of range */
 		if (*val == AS3935_DATA_MASK)
 			return -EINVAL;
<span class="p_del">-		*val *= 1000;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (m == IIO_CHAN_INFO_PROCESSED)</span>
<span class="p_add">+			*val *= 1000;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case IIO_CHAN_INFO_SCALE:</span>
<span class="p_add">+		*val = 1000;</span>
 		break;
 	default:
 		return -EINVAL;
<span class="p_chunk">@@ -206,10 +213,10 @@</span> <span class="p_context"> static irqreturn_t as3935_trigger_handler(int irq, void *private)</span>
 	ret = as3935_read(st, AS3935_DATA, &amp;val);
 	if (ret)
 		goto err_read;
<span class="p_del">-	val &amp;= AS3935_DATA_MASK;</span>
<span class="p_del">-	val *= 1000;</span>
 
<span class="p_del">-	iio_push_to_buffers_with_timestamp(indio_dev, &amp;val, pf-&gt;timestamp);</span>
<span class="p_add">+	st-&gt;buffer[0] = val &amp; AS3935_DATA_MASK;</span>
<span class="p_add">+	iio_push_to_buffers_with_timestamp(indio_dev, &amp;st-&gt;buffer,</span>
<span class="p_add">+					   pf-&gt;timestamp);</span>
 err_read:
 	iio_trigger_notify_done(indio_dev-&gt;trig);
 
<span class="p_header">diff --git a/drivers/infiniband/core/cma.c b/drivers/infiniband/core/cma.c</span>
<span class="p_header">index 06441a43c3aa..cf3d9dee8aff 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/cma.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/cma.c</span>
<span class="p_chunk">@@ -3679,7 +3679,8 @@</span> <span class="p_context"> static int __init cma_init(void)</span>
 	if (ret)
 		goto err;
 
<span class="p_del">-	if (ibnl_add_client(RDMA_NL_RDMA_CM, RDMA_NL_RDMA_CM_NUM_OPS, cma_cb_table))</span>
<span class="p_add">+	if (ibnl_add_client(RDMA_NL_RDMA_CM, ARRAY_SIZE(cma_cb_table),</span>
<span class="p_add">+			    cma_cb_table))</span>
 		printk(KERN_WARNING &quot;RDMA CMA: failed to add netlink callback\n&quot;);
 
 	return 0;
<span class="p_header">diff --git a/drivers/infiniband/core/iwpm_util.c b/drivers/infiniband/core/iwpm_util.c</span>
<span class="p_header">index 69e9f84c1605..e532ba6d3627 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/iwpm_util.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/iwpm_util.c</span>
<span class="p_chunk">@@ -484,6 +484,7 @@</span> <span class="p_context"> static int send_nlmsg_done(struct sk_buff *skb, u8 nl_client, int iwpm_pid)</span>
 	if (!(ibnl_put_msg(skb, &amp;nlh, 0, 0, nl_client,
 			   RDMA_NL_IWPM_MAPINFO, NLM_F_MULTI))) {
 		pr_warn(&quot;%s Unable to put NLMSG_DONE\n&quot;, __func__);
<span class="p_add">+		dev_kfree_skb(skb);</span>
 		return -ENOMEM;
 	}
 	nlh-&gt;nlmsg_type = NLMSG_DONE;
<span class="p_header">diff --git a/drivers/infiniband/hw/cxgb3/cxio_hal.c b/drivers/infiniband/hw/cxgb3/cxio_hal.c</span>
<span class="p_header">index de1c61b417d6..ada2e5009c86 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/cxgb3/cxio_hal.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/cxgb3/cxio_hal.c</span>
<span class="p_chunk">@@ -327,7 +327,7 @@</span> <span class="p_context"> int cxio_destroy_cq(struct cxio_rdev *rdev_p, struct t3_cq *cq)</span>
 	kfree(cq-&gt;sw_queue);
 	dma_free_coherent(&amp;(rdev_p-&gt;rnic_info.pdev-&gt;dev),
 			  (1UL &lt;&lt; (cq-&gt;size_log2))
<span class="p_del">-			  * sizeof(struct t3_cqe), cq-&gt;queue,</span>
<span class="p_add">+			  * sizeof(struct t3_cqe) + 1, cq-&gt;queue,</span>
 			  dma_unmap_addr(cq, mapping));
 	cxio_hal_put_cqid(rdev_p-&gt;rscp, cq-&gt;cqid);
 	return err;
<span class="p_header">diff --git a/drivers/infiniband/hw/cxgb4/cm.c b/drivers/infiniband/hw/cxgb4/cm.c</span>
<span class="p_header">index 768a0fb67dd6..bf488ae4dbe4 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/cxgb4/cm.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/cxgb4/cm.c</span>
<span class="p_chunk">@@ -1904,6 +1904,7 @@</span> <span class="p_context"> static int c4iw_reconnect(struct c4iw_ep *ep)</span>
 
 	PDBG(&quot;%s qp %p cm_id %p\n&quot;, __func__, ep-&gt;com.qp, ep-&gt;com.cm_id);
 	init_timer(&amp;ep-&gt;timer);
<span class="p_add">+	c4iw_init_wr_wait(&amp;ep-&gt;com.wr_wait);</span>
 
 	/*
 	 * Allocate an active TID to initiate a TCP connection.
<span class="p_chunk">@@ -3875,16 +3876,7 @@</span> <span class="p_context"> static int peer_abort_intr(struct c4iw_dev *dev, struct sk_buff *skb)</span>
 	PDBG(&quot;%s ep %p tid %u state %u\n&quot;, __func__, ep, ep-&gt;hwtid,
 	     ep-&gt;com.state);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Wake up any threads in rdma_init() or rdma_fini().</span>
<span class="p_del">-	 * However, if we are on MPAv2 and want to retry with MPAv1</span>
<span class="p_del">-	 * then, don&#39;t wake up yet.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (mpa_rev == 2 &amp;&amp; !ep-&gt;tried_with_mpa_v1) {</span>
<span class="p_del">-		if (ep-&gt;com.state != MPA_REQ_SENT)</span>
<span class="p_del">-			c4iw_wake_up(&amp;ep-&gt;com.wr_wait, -ECONNRESET);</span>
<span class="p_del">-	} else</span>
<span class="p_del">-		c4iw_wake_up(&amp;ep-&gt;com.wr_wait, -ECONNRESET);</span>
<span class="p_add">+	c4iw_wake_up(&amp;ep-&gt;com.wr_wait, -ECONNRESET);</span>
 	sched(dev, skb);
 	return 0;
 }
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/ah.c b/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_header">index 6dc27ffa1cec..4c2686514ced 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_chunk">@@ -46,6 +46,7 @@</span> <span class="p_context"> static struct ib_ah *create_ib_ah(struct ib_pd *pd, struct ib_ah_attr *ah_attr,</span>
 
 	ah-&gt;av.ib.port_pd = cpu_to_be32(to_mpd(pd)-&gt;pdn | (ah_attr-&gt;port_num &lt;&lt; 24));
 	ah-&gt;av.ib.g_slid  = ah_attr-&gt;src_path_bits;
<span class="p_add">+	ah-&gt;av.ib.sl_tclass_flowlabel = cpu_to_be32(ah_attr-&gt;sl &lt;&lt; 28);</span>
 	if (ah_attr-&gt;ah_flags &amp; IB_AH_GRH) {
 		ah-&gt;av.ib.g_slid   |= 0x80;
 		ah-&gt;av.ib.gid_index = ah_attr-&gt;grh.sgid_index;
<span class="p_chunk">@@ -63,7 +64,6 @@</span> <span class="p_context"> static struct ib_ah *create_ib_ah(struct ib_pd *pd, struct ib_ah_attr *ah_attr,</span>
 		       !(1 &lt;&lt; ah-&gt;av.ib.stat_rate &amp; dev-&gt;caps.stat_rate_support))
 			--ah-&gt;av.ib.stat_rate;
 	}
<span class="p_del">-	ah-&gt;av.ib.sl_tclass_flowlabel = cpu_to_be32(ah_attr-&gt;sl &lt;&lt; 28);</span>
 
 	return &amp;ah-&gt;ibah;
 }
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/mad.c b/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_header">index 35df708ffa53..1cc83abb9b44 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_chunk">@@ -531,7 +531,7 @@</span> <span class="p_context"> int mlx4_ib_send_to_slave(struct mlx4_ib_dev *dev, int slave, u8 port,</span>
 		tun_tx_ix = (++tun_qp-&gt;tx_ix_head) &amp; (MLX4_NUM_TUNNEL_BUFS - 1);
 	spin_unlock(&amp;tun_qp-&gt;tx_lock);
 	if (ret)
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto end;</span>
 
 	tun_mad = (struct mlx4_rcv_tunnel_mad *) (tun_qp-&gt;tx_ring[tun_tx_ix].buf.addr);
 	if (tun_qp-&gt;tx_ring[tun_tx_ix].ah)
<span class="p_chunk">@@ -600,9 +600,15 @@</span> <span class="p_context"> int mlx4_ib_send_to_slave(struct mlx4_ib_dev *dev, int slave, u8 port,</span>
 	wr.send_flags = IB_SEND_SIGNALED;
 
 	ret = ib_post_send(src_qp, &amp;wr, &amp;bad_wr);
<span class="p_del">-out:</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		ib_destroy_ah(ah);</span>
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+ out:</span>
<span class="p_add">+	spin_lock(&amp;tun_qp-&gt;tx_lock);</span>
<span class="p_add">+	tun_qp-&gt;tx_ix_tail++;</span>
<span class="p_add">+	spin_unlock(&amp;tun_qp-&gt;tx_lock);</span>
<span class="p_add">+	tun_qp-&gt;tx_ring[tun_tx_ix].ah = NULL;</span>
<span class="p_add">+end:</span>
<span class="p_add">+	ib_destroy_ah(ah);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -1256,9 +1262,15 @@</span> <span class="p_context"> int mlx4_ib_send_to_wire(struct mlx4_ib_dev *dev, int slave, u8 port,</span>
 
 
 	ret = ib_post_send(send_qp, &amp;wr, &amp;bad_wr);
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;sqp-&gt;tx_lock);</span>
<span class="p_add">+	sqp-&gt;tx_ix_tail++;</span>
<span class="p_add">+	spin_unlock(&amp;sqp-&gt;tx_lock);</span>
<span class="p_add">+	sqp-&gt;tx_ring[wire_tx_ix].ah = NULL;</span>
 out:
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		ib_destroy_ah(ah);</span>
<span class="p_add">+	ib_destroy_ah(ah);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/main.c b/drivers/infiniband/hw/mlx4/main.c</span>
<span class="p_header">index e48e96528657..85c47a0e524c 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/main.c</span>
<span class="p_chunk">@@ -1016,6 +1016,9 @@</span> <span class="p_context"> static int __mlx4_ib_create_flow(struct ib_qp *qp, struct ib_flow_attr *flow_att</span>
 		[IB_FLOW_DOMAIN_NIC] = MLX4_DOMAIN_NIC,
 	};
 
<span class="p_add">+	if (flow_attr-&gt;port &lt; 1 || flow_attr-&gt;port &gt; qp-&gt;device-&gt;phys_port_cnt)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if (flow_attr-&gt;priority &gt; MLX4_IB_FLOW_MAX_PRIO) {
 		pr_err(&quot;Invalid priority value %d\n&quot;, flow_attr-&gt;priority);
 		return -EINVAL;
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">index 6914462e4b5b..5fe3646b248f 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_chunk">@@ -361,7 +361,7 @@</span> <span class="p_context"> static int send_wqe_overhead(enum mlx4_ib_qp_type type, u32 flags)</span>
 			sizeof (struct mlx4_wqe_raddr_seg);
 	case MLX4_IB_QPT_RC:
 		return sizeof (struct mlx4_wqe_ctrl_seg) +
<span class="p_del">-			sizeof (struct mlx4_wqe_atomic_seg) +</span>
<span class="p_add">+			sizeof (struct mlx4_wqe_masked_atomic_seg) +</span>
 			sizeof (struct mlx4_wqe_raddr_seg);
 	case MLX4_IB_QPT_SMI:
 	case MLX4_IB_QPT_GSI:
<span class="p_chunk">@@ -1108,8 +1108,10 @@</span> <span class="p_context"> struct ib_qp *mlx4_ib_create_qp(struct ib_pd *pd,</span>
 	{
 		err = create_qp_common(to_mdev(pd-&gt;device), pd, init_attr,
 				       udata, 0, &amp;qp, gfp);
<span class="p_del">-		if (err)</span>
<span class="p_add">+		if (err) {</span>
<span class="p_add">+			kfree(qp);</span>
 			return ERR_PTR(err);
<span class="p_add">+		}</span>
 
 		qp-&gt;ibqp.qp_num = qp-&gt;mqp.qpn;
 		qp-&gt;xrcdn = xrcdn;
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">index 364d4b6937f5..cad8cab43559 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_chunk">@@ -1002,14 +1002,11 @@</span> <span class="p_context"> static void mlx5_ib_event(struct mlx5_core_dev *dev, enum mlx5_dev_event event,</span>
 		break;
 
 	case MLX5_DEV_EVENT_PORT_DOWN:
<span class="p_add">+	case MLX5_DEV_EVENT_PORT_INITIALIZED:</span>
 		ibev.event = IB_EVENT_PORT_ERR;
 		port = *(u8 *)data;
 		break;
 
<span class="p_del">-	case MLX5_DEV_EVENT_PORT_INITIALIZED:</span>
<span class="p_del">-		/* not used by ULPs */</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	case MLX5_DEV_EVENT_LID_CHANGE:
 		ibev.event = IB_EVENT_LID_CHANGE;
 		port = *(u8 *)data;
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/qp.c b/drivers/infiniband/hw/mlx5/qp.c</span>
<span class="p_header">index 44f4f3976f7c..aaa3a0b0ec95 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/qp.c</span>
<span class="p_chunk">@@ -169,6 +169,8 @@</span> <span class="p_context"> static int set_rq_size(struct mlx5_ib_dev *dev, struct ib_qp_cap *cap,</span>
 		qp-&gt;rq.max_gs = 0;
 		qp-&gt;rq.wqe_cnt = 0;
 		qp-&gt;rq.wqe_shift = 0;
<span class="p_add">+		cap-&gt;max_recv_wr = 0;</span>
<span class="p_add">+		cap-&gt;max_recv_sge = 0;</span>
 	} else {
 		if (ucmd) {
 			qp-&gt;rq.wqe_cnt = ucmd-&gt;rq_wqe_count;
<span class="p_chunk">@@ -2417,10 +2419,11 @@</span> <span class="p_context"> static u8 get_fence(u8 fence, struct ib_send_wr *wr)</span>
 			return MLX5_FENCE_MODE_SMALL_AND_FENCE;
 		else
 			return fence;
<span class="p_del">-</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+	} else if (unlikely(wr-&gt;send_flags &amp; IB_SEND_FENCE)) {</span>
<span class="p_add">+		return MLX5_FENCE_MODE_FENCE;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 static int begin_wqe(struct mlx5_ib_qp *qp, void **seg,
<span class="p_chunk">@@ -2979,17 +2982,19 @@</span> <span class="p_context"> int mlx5_ib_query_qp(struct ib_qp *ibqp, struct ib_qp_attr *qp_attr, int qp_attr</span>
 	qp_attr-&gt;cap.max_recv_sge    = qp-&gt;rq.max_gs;
 
 	if (!ibqp-&gt;uobject) {
<span class="p_del">-		qp_attr-&gt;cap.max_send_wr  = qp-&gt;sq.wqe_cnt;</span>
<span class="p_add">+		qp_attr-&gt;cap.max_send_wr  = qp-&gt;sq.max_post;</span>
 		qp_attr-&gt;cap.max_send_sge = qp-&gt;sq.max_gs;
<span class="p_add">+		qp_init_attr-&gt;qp_context = ibqp-&gt;qp_context;</span>
 	} else {
 		qp_attr-&gt;cap.max_send_wr  = 0;
 		qp_attr-&gt;cap.max_send_sge = 0;
 	}
 
<span class="p_del">-	/* We don&#39;t support inline sends for kernel QPs (yet), and we</span>
<span class="p_del">-	 * don&#39;t know what userspace&#39;s value should be.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	qp_attr-&gt;cap.max_inline_data = 0;</span>
<span class="p_add">+	qp_init_attr-&gt;qp_type = ibqp-&gt;qp_type;</span>
<span class="p_add">+	qp_init_attr-&gt;recv_cq = ibqp-&gt;recv_cq;</span>
<span class="p_add">+	qp_init_attr-&gt;send_cq = ibqp-&gt;send_cq;</span>
<span class="p_add">+	qp_init_attr-&gt;srq = ibqp-&gt;srq;</span>
<span class="p_add">+	qp_attr-&gt;cap.max_inline_data = qp-&gt;max_inline_data;</span>
 
 	qp_init_attr-&gt;cap	     = qp_attr-&gt;cap;
 
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib.h b/drivers/infiniband/ulp/ipoib/ipoib.h</span>
<span class="p_header">index c639f90cfda4..2a7c7dc28726 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib.h</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib.h</span>
<span class="p_chunk">@@ -94,6 +94,7 @@</span> <span class="p_context"> enum {</span>
 	IPOIB_FLAG_UMCAST	  = 10,
 	IPOIB_STOP_NEIGH_GC	  = 11,
 	IPOIB_NEIGH_TBL_FLUSH	  = 12,
<span class="p_add">+	IPOIB_FLAG_GOING_DOWN	  = 15,</span>
 
 	IPOIB_MAX_BACKOFF_SECONDS = 16,
 
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_cm.c b/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_header">index 933efcea0d03..105eebd77ad4 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_chunk">@@ -1472,6 +1472,10 @@</span> <span class="p_context"> static ssize_t set_mode(struct device *d, struct device_attribute *attr,</span>
 {
 	struct net_device *dev = to_net_dev(d);
 	int ret;
<span class="p_add">+	struct ipoib_dev_priv *priv = netdev_priv(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (test_bit(IPOIB_FLAG_GOING_DOWN, &amp;priv-&gt;flags))</span>
<span class="p_add">+		return -EPERM;</span>
 
 	if (!rtnl_trylock())
 		return restart_syscall();
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">index 5786a78ff8bc..7e4a6efbf2ce 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_chunk">@@ -884,7 +884,9 @@</span> <span class="p_context"> struct ipoib_neigh *ipoib_neigh_get(struct net_device *dev, u8 *daddr)</span>
 				neigh = NULL;
 				goto out_unlock;
 			}
<span class="p_del">-			neigh-&gt;alive = jiffies;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (likely(skb_queue_len(&amp;neigh-&gt;queue) &lt; IPOIB_MAX_PATH_REC_QUEUE))</span>
<span class="p_add">+				neigh-&gt;alive = jiffies;</span>
 			goto out_unlock;
 		}
 	}
<span class="p_chunk">@@ -1701,6 +1703,9 @@</span> <span class="p_context"> static void ipoib_remove_one(struct ib_device *device)</span>
 	list_for_each_entry_safe(priv, tmp, dev_list, list) {
 		ib_unregister_event_handler(&amp;priv-&gt;event_handler);
 
<span class="p_add">+		/* mark interface in the middle of destruction */</span>
<span class="p_add">+		set_bit(IPOIB_FLAG_GOING_DOWN, &amp;priv-&gt;flags);</span>
<span class="p_add">+</span>
 		rtnl_lock();
 		dev_change_flags(priv-&gt;dev, priv-&gt;dev-&gt;flags &amp; ~IFF_UP);
 		rtnl_unlock();
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_vlan.c b/drivers/infiniband/ulp/ipoib/ipoib_vlan.c</span>
<span class="p_header">index 9fad7b5ac8b9..91da685cdafd 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_vlan.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_vlan.c</span>
<span class="p_chunk">@@ -131,6 +131,9 @@</span> <span class="p_context"> int ipoib_vlan_add(struct net_device *pdev, unsigned short pkey)</span>
 
 	ppriv = netdev_priv(pdev);
 
<span class="p_add">+	if (test_bit(IPOIB_FLAG_GOING_DOWN, &amp;ppriv-&gt;flags))</span>
<span class="p_add">+		return -EPERM;</span>
<span class="p_add">+</span>
 	snprintf(intf_name, sizeof intf_name, &quot;%s.%04x&quot;,
 		 ppriv-&gt;dev-&gt;name, pkey);
 	priv = ipoib_intf_alloc(intf_name);
<span class="p_chunk">@@ -183,6 +186,9 @@</span> <span class="p_context"> int ipoib_vlan_delete(struct net_device *pdev, unsigned short pkey)</span>
 
 	ppriv = netdev_priv(pdev);
 
<span class="p_add">+	if (test_bit(IPOIB_FLAG_GOING_DOWN, &amp;ppriv-&gt;flags))</span>
<span class="p_add">+		return -EPERM;</span>
<span class="p_add">+</span>
 	if (!rtnl_trylock())
 		return restart_syscall();
 
<span class="p_header">diff --git a/drivers/input/joystick/xpad.c b/drivers/input/joystick/xpad.c</span>
<span class="p_header">index 18558f73b4a3..e2c655964711 100644</span>
<span class="p_header">--- a/drivers/input/joystick/xpad.c</span>
<span class="p_header">+++ b/drivers/input/joystick/xpad.c</span>
<span class="p_chunk">@@ -415,6 +415,10 @@</span> <span class="p_context"> static void xpad360_process_packet(struct usb_xpad *xpad,</span>
 {
 	struct input_dev *dev = xpad-&gt;dev;
 
<span class="p_add">+	/* valid pad data */</span>
<span class="p_add">+	if (data[0] != 0x00)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/* digital pad */
 	if (xpad-&gt;mapping &amp; MAP_DPAD_TO_BUTTONS) {
 		/* dpad as buttons (left, right, up, down) */
<span class="p_header">diff --git a/drivers/input/misc/pwm-beeper.c b/drivers/input/misc/pwm-beeper.c</span>
<span class="p_header">index 8ef288e7c971..e92fee9be9a1 100644</span>
<span class="p_header">--- a/drivers/input/misc/pwm-beeper.c</span>
<span class="p_header">+++ b/drivers/input/misc/pwm-beeper.c</span>
<span class="p_chunk">@@ -20,21 +20,40 @@</span> <span class="p_context"></span>
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/pwm.h&gt;
 #include &lt;linux/slab.h&gt;
<span class="p_add">+#include &lt;linux/workqueue.h&gt;</span>
 
 struct pwm_beeper {
 	struct input_dev *input;
 	struct pwm_device *pwm;
<span class="p_add">+	struct work_struct work;</span>
 	unsigned long period;
 };
 
 #define HZ_TO_NANOSECONDS(x) (1000000000UL/(x))
 
<span class="p_add">+static void __pwm_beeper_set(struct pwm_beeper *beeper)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long period = beeper-&gt;period;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (period) {</span>
<span class="p_add">+		pwm_config(beeper-&gt;pwm, period / 2, period);</span>
<span class="p_add">+		pwm_enable(beeper-&gt;pwm);</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		pwm_disable(beeper-&gt;pwm);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void pwm_beeper_work(struct work_struct *work)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pwm_beeper *beeper =</span>
<span class="p_add">+		container_of(work, struct pwm_beeper, work);</span>
<span class="p_add">+</span>
<span class="p_add">+	__pwm_beeper_set(beeper);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int pwm_beeper_event(struct input_dev *input,
 			    unsigned int type, unsigned int code, int value)
 {
<span class="p_del">-	int ret = 0;</span>
 	struct pwm_beeper *beeper = input_get_drvdata(input);
<span class="p_del">-	unsigned long period;</span>
 
 	if (type != EV_SND || value &lt; 0)
 		return -EINVAL;
<span class="p_chunk">@@ -49,23 +68,31 @@</span> <span class="p_context"> static int pwm_beeper_event(struct input_dev *input,</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	if (value == 0) {</span>
<span class="p_del">-		pwm_config(beeper-&gt;pwm, 0, 0);</span>
<span class="p_del">-		pwm_disable(beeper-&gt;pwm);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		period = HZ_TO_NANOSECONDS(value);</span>
<span class="p_del">-		ret = pwm_config(beeper-&gt;pwm, period / 2, period);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-		ret = pwm_enable(beeper-&gt;pwm);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-		beeper-&gt;period = period;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (value == 0)</span>
<span class="p_add">+		beeper-&gt;period = 0;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		beeper-&gt;period = HZ_TO_NANOSECONDS(value);</span>
<span class="p_add">+</span>
<span class="p_add">+	schedule_work(&amp;beeper-&gt;work);</span>
 
 	return 0;
 }
 
<span class="p_add">+static void pwm_beeper_stop(struct pwm_beeper *beeper)</span>
<span class="p_add">+{</span>
<span class="p_add">+	cancel_work_sync(&amp;beeper-&gt;work);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (beeper-&gt;period)</span>
<span class="p_add">+		pwm_disable(beeper-&gt;pwm);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void pwm_beeper_close(struct input_dev *input)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pwm_beeper *beeper = input_get_drvdata(input);</span>
<span class="p_add">+</span>
<span class="p_add">+	pwm_beeper_stop(beeper);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int pwm_beeper_probe(struct platform_device *pdev)
 {
 	unsigned long pwm_id = (unsigned long)dev_get_platdata(&amp;pdev-&gt;dev);
<span class="p_chunk">@@ -88,6 +115,8 @@</span> <span class="p_context"> static int pwm_beeper_probe(struct platform_device *pdev)</span>
 		goto err_free;
 	}
 
<span class="p_add">+	INIT_WORK(&amp;beeper-&gt;work, pwm_beeper_work);</span>
<span class="p_add">+</span>
 	beeper-&gt;input = input_allocate_device();
 	if (!beeper-&gt;input) {
 		dev_err(&amp;pdev-&gt;dev, &quot;Failed to allocate input device\n&quot;);
<span class="p_chunk">@@ -107,6 +136,7 @@</span> <span class="p_context"> static int pwm_beeper_probe(struct platform_device *pdev)</span>
 	beeper-&gt;input-&gt;sndbit[0] = BIT(SND_TONE) | BIT(SND_BELL);
 
 	beeper-&gt;input-&gt;event = pwm_beeper_event;
<span class="p_add">+	beeper-&gt;input-&gt;close = pwm_beeper_close;</span>
 
 	input_set_drvdata(beeper-&gt;input, beeper);
 
<span class="p_chunk">@@ -136,7 +166,6 @@</span> <span class="p_context"> static int pwm_beeper_remove(struct platform_device *pdev)</span>
 
 	input_unregister_device(beeper-&gt;input);
 
<span class="p_del">-	pwm_disable(beeper-&gt;pwm);</span>
 	pwm_free(beeper-&gt;pwm);
 
 	kfree(beeper);
<span class="p_chunk">@@ -149,8 +178,7 @@</span> <span class="p_context"> static int pwm_beeper_suspend(struct device *dev)</span>
 {
 	struct pwm_beeper *beeper = dev_get_drvdata(dev);
 
<span class="p_del">-	if (beeper-&gt;period)</span>
<span class="p_del">-		pwm_disable(beeper-&gt;pwm);</span>
<span class="p_add">+	pwm_beeper_stop(beeper);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -159,10 +187,8 @@</span> <span class="p_context"> static int pwm_beeper_resume(struct device *dev)</span>
 {
 	struct pwm_beeper *beeper = dev_get_drvdata(dev);
 
<span class="p_del">-	if (beeper-&gt;period) {</span>
<span class="p_del">-		pwm_config(beeper-&gt;pwm, beeper-&gt;period / 2, beeper-&gt;period);</span>
<span class="p_del">-		pwm_enable(beeper-&gt;pwm);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (beeper-&gt;period)</span>
<span class="p_add">+		__pwm_beeper_set(beeper);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/input/misc/uinput.c b/drivers/input/misc/uinput.c</span>
<span class="p_header">index 856936247500..5a63c274ae1c 100644</span>
<span class="p_header">--- a/drivers/input/misc/uinput.c</span>
<span class="p_header">+++ b/drivers/input/misc/uinput.c</span>
<span class="p_chunk">@@ -886,9 +886,15 @@</span> <span class="p_context"> static long uinput_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
 }
 
 #ifdef CONFIG_COMPAT
<span class="p_add">+</span>
<span class="p_add">+#define UI_SET_PHYS_COMPAT	_IOW(UINPUT_IOCTL_BASE, 108, compat_uptr_t)</span>
<span class="p_add">+</span>
 static long uinput_compat_ioctl(struct file *file,
 				unsigned int cmd, unsigned long arg)
 {
<span class="p_add">+	if (cmd == UI_SET_PHYS_COMPAT)</span>
<span class="p_add">+		cmd = UI_SET_PHYS;</span>
<span class="p_add">+</span>
 	return uinput_ioctl_handler(file, cmd, arg, compat_ptr(arg));
 }
 #endif
<span class="p_header">diff --git a/drivers/input/mouse/elantech.c b/drivers/input/mouse/elantech.c</span>
<span class="p_header">index 447b4545c7f7..92cebaf5d621 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.c</span>
<span class="p_chunk">@@ -1450,13 +1450,7 @@</span> <span class="p_context"> static int elantech_set_properties(struct elantech_data *etd)</span>
 		case 5:
 			etd-&gt;hw_version = 3;
 			break;
<span class="p_del">-		case 6:</span>
<span class="p_del">-		case 7:</span>
<span class="p_del">-		case 8:</span>
<span class="p_del">-		case 9:</span>
<span class="p_del">-		case 10:</span>
<span class="p_del">-		case 13:</span>
<span class="p_del">-		case 14:</span>
<span class="p_add">+		case 6 ... 14:</span>
 			etd-&gt;hw_version = 4;
 			break;
 		default:
<span class="p_header">diff --git a/drivers/input/touchscreen/wacom_w8001.c b/drivers/input/touchscreen/wacom_w8001.c</span>
<span class="p_header">index 2792ca397dd0..3ed0ce1e4dcb 100644</span>
<span class="p_header">--- a/drivers/input/touchscreen/wacom_w8001.c</span>
<span class="p_header">+++ b/drivers/input/touchscreen/wacom_w8001.c</span>
<span class="p_chunk">@@ -27,7 +27,7 @@</span> <span class="p_context"> MODULE_AUTHOR(&quot;Jaya Kumar &lt;jayakumar.lkml@gmail.com&gt;&quot;);</span>
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE(&quot;GPL&quot;);
 
<span class="p_del">-#define W8001_MAX_LENGTH	11</span>
<span class="p_add">+#define W8001_MAX_LENGTH	13</span>
 #define W8001_LEAD_MASK		0x80
 #define W8001_LEAD_BYTE		0x80
 #define W8001_TAB_MASK		0x40
<span class="p_header">diff --git a/drivers/iommu/dmar.c b/drivers/iommu/dmar.c</span>
<span class="p_header">index 04a5e5366ac0..8d3f5d89cfc2 100644</span>
<span class="p_header">--- a/drivers/iommu/dmar.c</span>
<span class="p_header">+++ b/drivers/iommu/dmar.c</span>
<span class="p_chunk">@@ -1459,18 +1459,14 @@</span> <span class="p_context"> static int dmar_fault_do_one(struct intel_iommu *iommu, int type,</span>
 	reason = dmar_get_fault_reason(fault_reason, &amp;fault_type);
 
 	if (fault_type == INTR_REMAP)
<span class="p_del">-		pr_err(&quot;INTR-REMAP: Request device [[%02x:%02x.%d] &quot;</span>
<span class="p_del">-		       &quot;fault index %llx\n&quot;</span>
<span class="p_del">-			&quot;INTR-REMAP:[fault reason %02d] %s\n&quot;,</span>
<span class="p_del">-			(source_id &gt;&gt; 8), PCI_SLOT(source_id &amp; 0xFF),</span>
<span class="p_add">+		pr_err(&quot;[INTR-REMAP] Request device [%02x:%02x.%d] fault index %llx [fault reason %02d] %s\n&quot;,</span>
<span class="p_add">+			source_id &gt;&gt; 8, PCI_SLOT(source_id &amp; 0xFF),</span>
 			PCI_FUNC(source_id &amp; 0xFF), addr &gt;&gt; 48,
 			fault_reason, reason);
 	else
<span class="p_del">-		pr_err(&quot;DMAR:[%s] Request device [%02x:%02x.%d] &quot;</span>
<span class="p_del">-		       &quot;fault addr %llx \n&quot;</span>
<span class="p_del">-		       &quot;DMAR:[fault reason %02d] %s\n&quot;,</span>
<span class="p_del">-		       (type ? &quot;DMA Read&quot; : &quot;DMA Write&quot;),</span>
<span class="p_del">-		       (source_id &gt;&gt; 8), PCI_SLOT(source_id &amp; 0xFF),</span>
<span class="p_add">+		pr_err(&quot;[%s] Request device [%02x:%02x.%d] fault addr %llx [fault reason %02d] %s\n&quot;,</span>
<span class="p_add">+		       type ? &quot;DMA Read&quot; : &quot;DMA Write&quot;,</span>
<span class="p_add">+		       source_id &gt;&gt; 8, PCI_SLOT(source_id &amp; 0xFF),</span>
 		       PCI_FUNC(source_id &amp; 0xFF), addr, fault_reason, reason);
 	return 0;
 }
<span class="p_chunk">@@ -1482,10 +1478,17 @@</span> <span class="p_context"> irqreturn_t dmar_fault(int irq, void *dev_id)</span>
 	int reg, fault_index;
 	u32 fault_status;
 	unsigned long flag;
<span class="p_add">+	bool ratelimited;</span>
<span class="p_add">+	static DEFINE_RATELIMIT_STATE(rs,</span>
<span class="p_add">+				      DEFAULT_RATELIMIT_INTERVAL,</span>
<span class="p_add">+				      DEFAULT_RATELIMIT_BURST);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Disable printing, simply clear the fault when ratelimited */</span>
<span class="p_add">+	ratelimited = !__ratelimit(&amp;rs);</span>
 
 	raw_spin_lock_irqsave(&amp;iommu-&gt;register_lock, flag);
 	fault_status = readl(iommu-&gt;reg + DMAR_FSTS_REG);
<span class="p_del">-	if (fault_status)</span>
<span class="p_add">+	if (fault_status &amp;&amp; !ratelimited)</span>
 		pr_err(&quot;DRHD: handling fault status reg %x\n&quot;, fault_status);
 
 	/* TBD: ignore advanced fault log currently */
<span class="p_chunk">@@ -1507,24 +1510,28 @@</span> <span class="p_context"> irqreturn_t dmar_fault(int irq, void *dev_id)</span>
 		if (!(data &amp; DMA_FRCD_F))
 			break;
 
<span class="p_del">-		fault_reason = dma_frcd_fault_reason(data);</span>
<span class="p_del">-		type = dma_frcd_type(data);</span>
<span class="p_add">+		if (!ratelimited) {</span>
<span class="p_add">+			fault_reason = dma_frcd_fault_reason(data);</span>
<span class="p_add">+			type = dma_frcd_type(data);</span>
 
<span class="p_del">-		data = readl(iommu-&gt;reg + reg +</span>
<span class="p_del">-				fault_index * PRIMARY_FAULT_REG_LEN + 8);</span>
<span class="p_del">-		source_id = dma_frcd_source_id(data);</span>
<span class="p_add">+			data = readl(iommu-&gt;reg + reg +</span>
<span class="p_add">+				     fault_index * PRIMARY_FAULT_REG_LEN + 8);</span>
<span class="p_add">+			source_id = dma_frcd_source_id(data);</span>
<span class="p_add">+</span>
<span class="p_add">+			guest_addr = dmar_readq(iommu-&gt;reg + reg +</span>
<span class="p_add">+					fault_index * PRIMARY_FAULT_REG_LEN);</span>
<span class="p_add">+			guest_addr = dma_frcd_page_addr(guest_addr);</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-		guest_addr = dmar_readq(iommu-&gt;reg + reg +</span>
<span class="p_del">-				fault_index * PRIMARY_FAULT_REG_LEN);</span>
<span class="p_del">-		guest_addr = dma_frcd_page_addr(guest_addr);</span>
 		/* clear the fault */
 		writel(DMA_FRCD_F, iommu-&gt;reg + reg +
 			fault_index * PRIMARY_FAULT_REG_LEN + 12);
 
 		raw_spin_unlock_irqrestore(&amp;iommu-&gt;register_lock, flag);
 
<span class="p_del">-		dmar_fault_do_one(iommu, type, fault_reason,</span>
<span class="p_del">-				source_id, guest_addr);</span>
<span class="p_add">+		if (!ratelimited)</span>
<span class="p_add">+			dmar_fault_do_one(iommu, type, fault_reason,</span>
<span class="p_add">+					  source_id, guest_addr);</span>
 
 		fault_index++;
 		if (fault_index &gt;= cap_num_fault_regs(iommu-&gt;cap))
<span class="p_header">diff --git a/drivers/irqchip/irq-gic.c b/drivers/irqchip/irq-gic.c</span>
<span class="p_header">index 7c131cf7cc13..605e65713093 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-gic.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-gic.c</span>
<span class="p_chunk">@@ -302,6 +302,14 @@</span> <span class="p_context"> static void __exception_irq_entry gic_handle_irq(struct pt_regs *regs)</span>
 		if (irqnr &lt; 16) {
 			writel_relaxed(irqstat, cpu_base + GIC_CPU_EOI);
 #ifdef CONFIG_SMP
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Ensure any shared data written by the CPU sending</span>
<span class="p_add">+			 * the IPI is read after we&#39;ve read the ACK register</span>
<span class="p_add">+			 * on the GIC.</span>
<span class="p_add">+			 *</span>
<span class="p_add">+			 * Pairs with the write barrier in gic_raise_softirq</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			smp_rmb();</span>
 			handle_IPI(irqnr, regs);
 #endif
 			continue;
<span class="p_header">diff --git a/drivers/mcb/mcb-parse.c b/drivers/mcb/mcb-parse.c</span>
<span class="p_header">index 004926955263..b0155b05cddb 100644</span>
<span class="p_header">--- a/drivers/mcb/mcb-parse.c</span>
<span class="p_header">+++ b/drivers/mcb/mcb-parse.c</span>
<span class="p_chunk">@@ -57,7 +57,7 @@</span> <span class="p_context"> static int chameleon_parse_gdd(struct mcb_bus *bus,</span>
 	mdev-&gt;id = GDD_DEV(reg1);
 	mdev-&gt;rev = GDD_REV(reg1);
 	mdev-&gt;var = GDD_VAR(reg1);
<span class="p_del">-	mdev-&gt;bar = GDD_BAR(reg1);</span>
<span class="p_add">+	mdev-&gt;bar = GDD_BAR(reg2);</span>
 	mdev-&gt;group = GDD_GRP(reg2);
 	mdev-&gt;inst = GDD_INS(reg2);
 
<span class="p_header">diff --git a/drivers/media/pci/cx23885/cx23885-av.c b/drivers/media/pci/cx23885/cx23885-av.c</span>
<span class="p_header">index c443b7ac5adf..cf91fa220993 100644</span>
<span class="p_header">--- a/drivers/media/pci/cx23885/cx23885-av.c</span>
<span class="p_header">+++ b/drivers/media/pci/cx23885/cx23885-av.c</span>
<span class="p_chunk">@@ -29,7 +29,7 @@</span> <span class="p_context"> void cx23885_av_work_handler(struct work_struct *work)</span>
 {
 	struct cx23885_dev *dev =
 			   container_of(work, struct cx23885_dev, cx25840_work);
<span class="p_del">-	bool handled;</span>
<span class="p_add">+	bool handled = false;</span>
 
 	v4l2_subdev_call(dev-&gt;sd_cx25840, core, interrupt_service_routine,
 			 PCI_MSK_AV_CORE, &amp;handled);
<span class="p_header">diff --git a/drivers/media/usb/uvc/uvc_v4l2.c b/drivers/media/usb/uvc/uvc_v4l2.c</span>
<span class="p_header">index 378ae02e593b..836c252c12f4 100644</span>
<span class="p_header">--- a/drivers/media/usb/uvc/uvc_v4l2.c</span>
<span class="p_header">+++ b/drivers/media/usb/uvc/uvc_v4l2.c</span>
<span class="p_chunk">@@ -1279,47 +1279,44 @@</span> <span class="p_context"> static int uvc_v4l2_put_xu_query(const struct uvc_xu_control_query *kp,</span>
 static long uvc_v4l2_compat_ioctl32(struct file *file,
 		     unsigned int cmd, unsigned long arg)
 {
<span class="p_add">+	struct uvc_fh *handle = file-&gt;private_data;</span>
 	union {
 		struct uvc_xu_control_mapping xmap;
 		struct uvc_xu_control_query xqry;
 	} karg;
 	void __user *up = compat_ptr(arg);
<span class="p_del">-	mm_segment_t old_fs;</span>
 	long ret;
 
 	switch (cmd) {
 	case UVCIOC_CTRL_MAP32:
<span class="p_del">-		cmd = UVCIOC_CTRL_MAP;</span>
 		ret = uvc_v4l2_get_xu_mapping(&amp;karg.xmap, up);
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		ret = uvc_ioctl_ctrl_map(handle-&gt;chain, &amp;karg.xmap);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		ret = uvc_v4l2_put_xu_mapping(&amp;karg.xmap, up);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
 		break;
 
 	case UVCIOC_CTRL_QUERY32:
<span class="p_del">-		cmd = UVCIOC_CTRL_QUERY;</span>
 		ret = uvc_v4l2_get_xu_query(&amp;karg.xqry, up);
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		ret = uvc_xu_ctrl_query(handle-&gt;chain, &amp;karg.xqry);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		ret = uvc_v4l2_put_xu_query(&amp;karg.xqry, up);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
 		break;
 
 	default:
 		return -ENOIOCTLCMD;
 	}
 
<span class="p_del">-	old_fs = get_fs();</span>
<span class="p_del">-	set_fs(KERNEL_DS);</span>
<span class="p_del">-	ret = uvc_v4l2_ioctl(file, cmd, (unsigned long)&amp;karg);</span>
<span class="p_del">-	set_fs(old_fs);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (cmd) {</span>
<span class="p_del">-	case UVCIOC_CTRL_MAP:</span>
<span class="p_del">-		ret = uvc_v4l2_put_xu_mapping(&amp;karg.xmap, up);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
<span class="p_del">-	case UVCIOC_CTRL_QUERY:</span>
<span class="p_del">-		ret = uvc_v4l2_put_xu_query(&amp;karg.xqry, up);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	return ret;
 }
 #endif
<span class="p_header">diff --git a/drivers/mfd/lp8788-irq.c b/drivers/mfd/lp8788-irq.c</span>
<span class="p_header">index c84ded5f8ece..3bf5fac21640 100644</span>
<span class="p_header">--- a/drivers/mfd/lp8788-irq.c</span>
<span class="p_header">+++ b/drivers/mfd/lp8788-irq.c</span>
<span class="p_chunk">@@ -110,7 +110,7 @@</span> <span class="p_context"> static irqreturn_t lp8788_irq_handler(int irq, void *ptr)</span>
 	struct lp8788_irq_data *irqd = ptr;
 	struct lp8788 *lp = irqd-&gt;lp;
 	u8 status[NUM_REGS], addr, mask;
<span class="p_del">-	bool handled;</span>
<span class="p_add">+	bool handled = false;</span>
 	int i;
 
 	if (lp8788_read_multi_bytes(lp, LP8788_INT_1, status, NUM_REGS))
<span class="p_header">diff --git a/drivers/mfd/omap-usb-tll.c b/drivers/mfd/omap-usb-tll.c</span>
<span class="p_header">index 532eacab6b46..0f8cd6bbe914 100644</span>
<span class="p_header">--- a/drivers/mfd/omap-usb-tll.c</span>
<span class="p_header">+++ b/drivers/mfd/omap-usb-tll.c</span>
<span class="p_chunk">@@ -269,6 +269,8 @@</span> <span class="p_context"> static int usbtll_omap_probe(struct platform_device *pdev)</span>
 
 		if (IS_ERR(tll-&gt;ch_clk[i]))
 			dev_dbg(dev, &quot;can&#39;t get clock : %s\n&quot;, clkname);
<span class="p_add">+		else</span>
<span class="p_add">+			clk_prepare(tll-&gt;ch_clk[i]);</span>
 	}
 
 	pm_runtime_put_sync(dev);
<span class="p_chunk">@@ -301,9 +303,12 @@</span> <span class="p_context"> static int usbtll_omap_remove(struct platform_device *pdev)</span>
 	tll_dev = NULL;
 	spin_unlock(&amp;tll_lock);
 
<span class="p_del">-	for (i = 0; i &lt; tll-&gt;nch; i++)</span>
<span class="p_del">-		if (!IS_ERR(tll-&gt;ch_clk[i]))</span>
<span class="p_add">+	for (i = 0; i &lt; tll-&gt;nch; i++) {</span>
<span class="p_add">+		if (!IS_ERR(tll-&gt;ch_clk[i])) {</span>
<span class="p_add">+			clk_unprepare(tll-&gt;ch_clk[i]);</span>
 			clk_put(tll-&gt;ch_clk[i]);
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
 	pm_runtime_disable(&amp;pdev-&gt;dev);
 	return 0;
<span class="p_chunk">@@ -421,7 +426,7 @@</span> <span class="p_context"> int omap_tll_enable(struct usbhs_omap_platform_data *pdata)</span>
 			if (IS_ERR(tll-&gt;ch_clk[i]))
 				continue;
 
<span class="p_del">-			r = clk_prepare_enable(tll-&gt;ch_clk[i]);</span>
<span class="p_add">+			r = clk_enable(tll-&gt;ch_clk[i]);</span>
 			if (r) {
 				dev_err(tll_dev,
 				 &quot;Error enabling ch %d clock: %d\n&quot;, i, r);
<span class="p_chunk">@@ -449,7 +454,7 @@</span> <span class="p_context"> int omap_tll_disable(struct usbhs_omap_platform_data *pdata)</span>
 	for (i = 0; i &lt; tll-&gt;nch; i++) {
 		if (omap_usb_mode_needs_tll(pdata-&gt;port_mode[i])) {
 			if (!IS_ERR(tll-&gt;ch_clk[i]))
<span class="p_del">-				clk_disable_unprepare(tll-&gt;ch_clk[i]);</span>
<span class="p_add">+				clk_disable(tll-&gt;ch_clk[i]);</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/misc/mic/host/mic_virtio.c b/drivers/misc/mic/host/mic_virtio.c</span>
<span class="p_header">index 7e1ef0ebbb80..dba3c19929db 100644</span>
<span class="p_header">--- a/drivers/misc/mic/host/mic_virtio.c</span>
<span class="p_header">+++ b/drivers/misc/mic/host/mic_virtio.c</span>
<span class="p_chunk">@@ -456,6 +456,11 @@</span> <span class="p_context"> static int mic_copy_dp_entry(struct mic_vdev *mvdev,</span>
 			__func__, __LINE__, ret);
 		goto exit;
 	}
<span class="p_add">+	/* Ensure desc has not changed between the two reads */</span>
<span class="p_add">+	if (memcmp(&amp;dd, dd_config, sizeof(dd))) {</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto exit;</span>
<span class="p_add">+	}</span>
 
 	vqconfig = mic_vq_config(dd_config);
 	for (i = 0; i &lt; dd.num_vq; i++) {
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index 76efef5af670..c51e164dfae0 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -2401,11 +2401,12 @@</span> <span class="p_context"> static const struct mmc_fixup blk_fixups[] =</span>
 		  MMC_QUIRK_BLK_NO_CMD23),
 
 	/*
<span class="p_del">-	 * Some Micron MMC cards needs longer data read timeout than</span>
<span class="p_del">-	 * indicated in CSD.</span>
<span class="p_add">+	 * Some MMC cards need longer data read timeout than indicated in CSD.</span>
 	 */
 	MMC_FIXUP(CID_NAME_ANY, CID_MANFID_MICRON, 0x200, add_quirk_mmc,
 		  MMC_QUIRK_LONG_READ_TIME),
<span class="p_add">+	MMC_FIXUP(&quot;008GE0&quot;, CID_MANFID_TOSHIBA, CID_OEMID_ANY, add_quirk_mmc,</span>
<span class="p_add">+		  MMC_QUIRK_LONG_READ_TIME),</span>
 
 	/*
 	 * On these Samsung MoviNAND parts, performing secure erase or
<span class="p_header">diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c</span>
<span class="p_header">index aba0b8c632ee..2b051b32f38f 100644</span>
<span class="p_header">--- a/drivers/mmc/core/core.c</span>
<span class="p_header">+++ b/drivers/mmc/core/core.c</span>
<span class="p_chunk">@@ -811,11 +811,11 @@</span> <span class="p_context"> void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)</span>
 	/*
 	 * Some cards require longer data read timeout than indicated in CSD.
 	 * Address this by setting the read timeout to a &quot;reasonably high&quot;
<span class="p_del">-	 * value. For the cards tested, 300ms has proven enough. If necessary,</span>
<span class="p_add">+	 * value. For the cards tested, 600ms has proven enough. If necessary,</span>
 	 * this value can be increased if other problematic cards require this.
 	 */
 	if (mmc_card_long_read_time(card) &amp;&amp; data-&gt;flags &amp; MMC_DATA_READ) {
<span class="p_del">-		data-&gt;timeout_ns = 300000000;</span>
<span class="p_add">+		data-&gt;timeout_ns = 600000000;</span>
 		data-&gt;timeout_clks = 0;
 	}
 
<span class="p_header">diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c</span>
<span class="p_header">index 793c6f7ddb04..094ba8b8dc3a 100644</span>
<span class="p_header">--- a/drivers/mmc/core/mmc.c</span>
<span class="p_header">+++ b/drivers/mmc/core/mmc.c</span>
<span class="p_chunk">@@ -298,6 +298,9 @@</span> <span class="p_context"> static void mmc_select_card_type(struct mmc_card *card)</span>
 	card-&gt;mmc_avail_type = avail_type;
 }
 
<span class="p_add">+/* Minimum partition switch timeout in milliseconds */</span>
<span class="p_add">+#define MMC_MIN_PART_SWITCH_TIME	300</span>
<span class="p_add">+</span>
 /*
  * Decode extended CSD.
  */
<span class="p_chunk">@@ -362,6 +365,10 @@</span> <span class="p_context"> static int mmc_read_ext_csd(struct mmc_card *card, u8 *ext_csd)</span>
 
 		/* EXT_CSD value is in units of 10ms, but we store in ms */
 		card-&gt;ext_csd.part_time = 10 * ext_csd[EXT_CSD_PART_SWITCH_TIME];
<span class="p_add">+		/* Some eMMC set the value too low so set a minimum */</span>
<span class="p_add">+		if (card-&gt;ext_csd.part_time &amp;&amp;</span>
<span class="p_add">+		    card-&gt;ext_csd.part_time &lt; MMC_MIN_PART_SWITCH_TIME)</span>
<span class="p_add">+			card-&gt;ext_csd.part_time = MMC_MIN_PART_SWITCH_TIME;</span>
 
 		/* Sleep / awake timeout in 100ns units */
 		if (sa_shift &gt; 0 &amp;&amp; sa_shift &lt;= 0x17)
<span class="p_header">diff --git a/drivers/mtd/ubi/eba.c b/drivers/mtd/ubi/eba.c</span>
<span class="p_header">index 930cf2c77abb..0fd03856f8de 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/eba.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/eba.c</span>
<span class="p_chunk">@@ -425,8 +425,27 @@</span> <span class="p_context"> retry:</span>
 					ubi_warn(&quot;corrupted VID header at PEB %d, LEB %d:%d&quot;,
 						 pnum, vol_id, lnum);
 					err = -EBADMSG;
<span class="p_del">-				} else</span>
<span class="p_del">-					ubi_ro_mode(ubi);</span>
<span class="p_add">+				} else {</span>
<span class="p_add">+					/*</span>
<span class="p_add">+					 * Ending up here in the non-Fastmap case</span>
<span class="p_add">+					 * is a clear bug as the VID header had to</span>
<span class="p_add">+					 * be present at scan time to have it referenced.</span>
<span class="p_add">+					 * With fastmap the story is more complicated.</span>
<span class="p_add">+					 * Fastmap has the mapping info without the need</span>
<span class="p_add">+					 * of a full scan. So the LEB could have been</span>
<span class="p_add">+					 * unmapped, Fastmap cannot know this and keeps</span>
<span class="p_add">+					 * the LEB referenced.</span>
<span class="p_add">+					 * This is valid and works as the layer above UBI</span>
<span class="p_add">+					 * has to do bookkeeping about used/referenced</span>
<span class="p_add">+					 * LEBs in any case.</span>
<span class="p_add">+					 */</span>
<span class="p_add">+					if (ubi-&gt;fast_attach) {</span>
<span class="p_add">+						err = -EBADMSG;</span>
<span class="p_add">+					} else {</span>
<span class="p_add">+						err = -EINVAL;</span>
<span class="p_add">+						ubi_ro_mode(ubi);</span>
<span class="p_add">+					}</span>
<span class="p_add">+				}</span>
 			}
 			goto out_free;
 		} else if (err == UBI_IO_BITFLIPS)
<span class="p_chunk">@@ -502,6 +521,7 @@</span> <span class="p_context"> static int recover_peb(struct ubi_device *ubi, int pnum, int vol_id, int lnum,</span>
 	int err, idx = vol_id2idx(ubi, vol_id), new_pnum, data_size, tries = 0;
 	struct ubi_volume *vol = ubi-&gt;volumes[idx];
 	struct ubi_vid_hdr *vid_hdr;
<span class="p_add">+	uint32_t crc;</span>
 
 	vid_hdr = ubi_zalloc_vid_hdr(ubi, GFP_NOFS);
 	if (!vid_hdr)
<span class="p_chunk">@@ -523,12 +543,8 @@</span> <span class="p_context"> retry:</span>
 		goto out_put;
 	}
 
<span class="p_del">-	vid_hdr-&gt;sqnum = cpu_to_be64(ubi_next_sqnum(ubi));</span>
<span class="p_del">-	err = ubi_io_write_vid_hdr(ubi, new_pnum, vid_hdr);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto write_error;</span>
<span class="p_add">+	ubi_assert(vid_hdr-&gt;vol_type == UBI_VID_DYNAMIC);</span>
 
<span class="p_del">-	data_size = offset + len;</span>
 	mutex_lock(&amp;ubi-&gt;buf_mutex);
 	memset(ubi-&gt;peb_buf + offset, 0xFF, len);
 
<span class="p_chunk">@@ -541,6 +557,18 @@</span> <span class="p_context"> retry:</span>
 
 	memcpy(ubi-&gt;peb_buf + offset, buf, len);
 
<span class="p_add">+	data_size = offset + len;</span>
<span class="p_add">+	crc = crc32(UBI_CRC32_INIT, ubi-&gt;peb_buf, data_size);</span>
<span class="p_add">+	vid_hdr-&gt;sqnum = cpu_to_be64(ubi_next_sqnum(ubi));</span>
<span class="p_add">+	vid_hdr-&gt;copy_flag = 1;</span>
<span class="p_add">+	vid_hdr-&gt;data_size = cpu_to_be32(data_size);</span>
<span class="p_add">+	vid_hdr-&gt;data_crc = cpu_to_be32(crc);</span>
<span class="p_add">+	err = ubi_io_write_vid_hdr(ubi, new_pnum, vid_hdr);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		mutex_unlock(&amp;ubi-&gt;buf_mutex);</span>
<span class="p_add">+		goto write_error;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	err = ubi_io_write_data(ubi, ubi-&gt;peb_buf, new_pnum, 0, data_size);
 	if (err) {
 		mutex_unlock(&amp;ubi-&gt;buf_mutex);
<span class="p_header">diff --git a/drivers/mtd/ubi/fastmap.c b/drivers/mtd/ubi/fastmap.c</span>
<span class="p_header">index c701369090fb..5c0b66ed1ddb 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/fastmap.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/fastmap.c</span>
<span class="p_chunk">@@ -1070,6 +1070,7 @@</span> <span class="p_context"> int ubi_scan_fastmap(struct ubi_device *ubi, struct ubi_attach_info *ai,</span>
 	ubi_msg(&quot;fastmap pool size: %d&quot;, ubi-&gt;fm_pool.max_size);
 	ubi_msg(&quot;fastmap WL pool size: %d&quot;, ubi-&gt;fm_wl_pool.max_size);
 	ubi-&gt;fm_disabled = 0;
<span class="p_add">+	ubi-&gt;fast_attach = 1;</span>
 
 	ubi_free_vid_hdr(ubi, vh);
 	kfree(ech);
<span class="p_header">diff --git a/drivers/mtd/ubi/ubi.h b/drivers/mtd/ubi/ubi.h</span>
<span class="p_header">index 7bf416329c19..c1f1087b6939 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/ubi.h</span>
<span class="p_header">+++ b/drivers/mtd/ubi/ubi.h</span>
<span class="p_chunk">@@ -426,6 +426,7 @@</span> <span class="p_context"> struct ubi_debug_info {</span>
  * @fm_size: fastmap size in bytes
  * @fm_sem: allows ubi_update_fastmap() to block EBA table changes
  * @fm_work: fastmap work queue
<span class="p_add">+ * @fast_attach: non-zero if UBI was attached by fastmap</span>
  *
  * @used: RB-tree of used physical eraseblocks
  * @erroneous: RB-tree of erroneous used physical eraseblocks
<span class="p_chunk">@@ -531,6 +532,7 @@</span> <span class="p_context"> struct ubi_device {</span>
 	void *fm_buf;
 	size_t fm_size;
 	struct work_struct fm_work;
<span class="p_add">+	int fast_attach;</span>
 
 	/* Wear-leveling sub-system&#39;s stuff */
 	struct rb_root used;
<span class="p_header">diff --git a/drivers/net/bonding/bond_3ad.c b/drivers/net/bonding/bond_3ad.c</span>
<span class="p_header">index 0dfeaf5da3f2..f65bfbbefd28 100644</span>
<span class="p_header">--- a/drivers/net/bonding/bond_3ad.c</span>
<span class="p_header">+++ b/drivers/net/bonding/bond_3ad.c</span>
<span class="p_chunk">@@ -95,11 +95,14 @@</span> <span class="p_context"></span>
 #define MAC_ADDRESS_EQUAL(A, B)	\
 	ether_addr_equal_64bits((const u8 *)A, (const u8 *)B)
 
<span class="p_del">-static struct mac_addr null_mac_addr = { { 0, 0, 0, 0, 0, 0 } };</span>
<span class="p_add">+static const u8 null_mac_addr[ETH_ALEN + 2] __long_aligned = {</span>
<span class="p_add">+	0, 0, 0, 0, 0, 0</span>
<span class="p_add">+};</span>
 static u16 ad_ticks_per_sec;
 static const int ad_delta_in_ticks = (AD_TIMER_INTERVAL * HZ) / 1000;
 
<span class="p_del">-static const u8 lacpdu_mcast_addr[ETH_ALEN] = MULTICAST_LACPDU_ADDR;</span>
<span class="p_add">+static const u8 lacpdu_mcast_addr[ETH_ALEN + 2] __long_aligned =</span>
<span class="p_add">+	MULTICAST_LACPDU_ADDR;</span>
 
 /* ================= main 802.3ad protocol functions ================== */
 static int ad_lacpdu_send(struct port *port);
<span class="p_chunk">@@ -1614,7 +1617,7 @@</span> <span class="p_context"> static void ad_clear_agg(struct aggregator *aggregator)</span>
 		aggregator-&gt;is_individual = false;
 		aggregator-&gt;actor_admin_aggregator_key = 0;
 		aggregator-&gt;actor_oper_aggregator_key = 0;
<span class="p_del">-		aggregator-&gt;partner_system = null_mac_addr;</span>
<span class="p_add">+		eth_zero_addr(aggregator-&gt;partner_system.mac_addr_value);</span>
 		aggregator-&gt;partner_system_priority = 0;
 		aggregator-&gt;partner_oper_aggregator_key = 0;
 		aggregator-&gt;receive_state = 0;
<span class="p_chunk">@@ -1636,7 +1639,7 @@</span> <span class="p_context"> static void ad_initialize_agg(struct aggregator *aggregator)</span>
 	if (aggregator) {
 		ad_clear_agg(aggregator);
 
<span class="p_del">-		aggregator-&gt;aggregator_mac_address = null_mac_addr;</span>
<span class="p_add">+		eth_zero_addr(aggregator-&gt;aggregator_mac_address.mac_addr_value);</span>
 		aggregator-&gt;aggregator_identifier = 0;
 		aggregator-&gt;slave = NULL;
 	}
<span class="p_chunk">@@ -1671,7 +1674,7 @@</span> <span class="p_context"> static void ad_initialize_port(struct port *port, int lacp_fast)</span>
 	if (port) {
 		port-&gt;actor_port_number = 1;
 		port-&gt;actor_port_priority = 0xff;
<span class="p_del">-		port-&gt;actor_system = null_mac_addr;</span>
<span class="p_add">+		eth_zero_addr(port-&gt;actor_system.mac_addr_value);</span>
 		port-&gt;actor_system_priority = 0xffff;
 		port-&gt;actor_port_aggregator_identifier = 0;
 		port-&gt;ntt = false;
<span class="p_header">diff --git a/drivers/net/bonding/bond_alb.c b/drivers/net/bonding/bond_alb.c</span>
<span class="p_header">index 76c0dade233f..cd440dfffad1 100644</span>
<span class="p_header">--- a/drivers/net/bonding/bond_alb.c</span>
<span class="p_header">+++ b/drivers/net/bonding/bond_alb.c</span>
<span class="p_chunk">@@ -44,13 +44,10 @@</span> <span class="p_context"></span>
 
 
 
<span class="p_del">-#ifndef __long_aligned</span>
<span class="p_del">-#define __long_aligned __attribute__((aligned((sizeof(long)))))</span>
<span class="p_del">-#endif</span>
<span class="p_del">-static const u8 mac_bcast[ETH_ALEN] __long_aligned = {</span>
<span class="p_add">+static const u8 mac_bcast[ETH_ALEN + 2] __long_aligned = {</span>
 	0xff, 0xff, 0xff, 0xff, 0xff, 0xff
 };
<span class="p_del">-static const u8 mac_v6_allmcast[ETH_ALEN] __long_aligned = {</span>
<span class="p_add">+static const u8 mac_v6_allmcast[ETH_ALEN + 2] __long_aligned = {</span>
 	0x33, 0x33, 0x00, 0x00, 0x00, 0x01
 };
 static const int alb_delta_in_ticks = HZ / ALB_TIMER_TICKS_PER_SEC;
<span class="p_header">diff --git a/drivers/net/bonding/bonding.h b/drivers/net/bonding/bonding.h</span>
<span class="p_header">index 0b4d9cde0b05..0aadbae041f4 100644</span>
<span class="p_header">--- a/drivers/net/bonding/bonding.h</span>
<span class="p_header">+++ b/drivers/net/bonding/bonding.h</span>
<span class="p_chunk">@@ -41,6 +41,9 @@</span> <span class="p_context"></span>
 
 #define BOND_DEFAULT_MIIMON	100
 
<span class="p_add">+#ifndef __long_aligned</span>
<span class="p_add">+#define __long_aligned __attribute__((aligned((sizeof(long)))))</span>
<span class="p_add">+#endif</span>
 /*
  * Less bad way to call ioctl from within the kernel; this needs to be
  * done some other way to get the call out of interrupt context.
<span class="p_header">diff --git a/drivers/net/can/at91_can.c b/drivers/net/can/at91_can.c</span>
<span class="p_header">index 05e1aa090add..2c4e54f764c5 100644</span>
<span class="p_header">--- a/drivers/net/can/at91_can.c</span>
<span class="p_header">+++ b/drivers/net/can/at91_can.c</span>
<span class="p_chunk">@@ -734,9 +734,10 @@</span> <span class="p_context"> static int at91_poll_rx(struct net_device *dev, int quota)</span>
 
 	/* upper group completed, look again in lower */
 	if (priv-&gt;rx_next &gt; get_mb_rx_low_last(priv) &amp;&amp;
<span class="p_del">-	    quota &gt; 0 &amp;&amp; mb &gt; get_mb_rx_last(priv)) {</span>
<span class="p_add">+	    mb &gt; get_mb_rx_last(priv)) {</span>
 		priv-&gt;rx_next = get_mb_rx_first(priv);
<span class="p_del">-		goto again;</span>
<span class="p_add">+		if (quota &gt; 0)</span>
<span class="p_add">+			goto again;</span>
 	}
 
 	return received;
<span class="p_header">diff --git a/drivers/net/can/c_can/c_can.c b/drivers/net/can/c_can/c_can.c</span>
<span class="p_header">index 60285820f7b4..055457619c1e 100644</span>
<span class="p_header">--- a/drivers/net/can/c_can/c_can.c</span>
<span class="p_header">+++ b/drivers/net/can/c_can/c_can.c</span>
<span class="p_chunk">@@ -331,9 +331,23 @@</span> <span class="p_context"> static void c_can_setup_tx_object(struct net_device *dev, int iface,</span>
 
 	priv-&gt;write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface), ctrl);
 
<span class="p_del">-	for (i = 0; i &lt; frame-&gt;can_dlc; i += 2) {</span>
<span class="p_del">-		priv-&gt;write_reg(priv, C_CAN_IFACE(DATA1_REG, iface) + i / 2,</span>
<span class="p_del">-				frame-&gt;data[i] | (frame-&gt;data[i + 1] &lt;&lt; 8));</span>
<span class="p_add">+	if (priv-&gt;type == BOSCH_D_CAN) {</span>
<span class="p_add">+		u32 data = 0, dreg = C_CAN_IFACE(DATA1_REG, iface);</span>
<span class="p_add">+</span>
<span class="p_add">+		for (i = 0; i &lt; frame-&gt;can_dlc; i += 4, dreg += 2) {</span>
<span class="p_add">+			data = (u32)frame-&gt;data[i];</span>
<span class="p_add">+			data |= (u32)frame-&gt;data[i + 1] &lt;&lt; 8;</span>
<span class="p_add">+			data |= (u32)frame-&gt;data[i + 2] &lt;&lt; 16;</span>
<span class="p_add">+			data |= (u32)frame-&gt;data[i + 3] &lt;&lt; 24;</span>
<span class="p_add">+			priv-&gt;write_reg32(priv, dreg, data);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		for (i = 0; i &lt; frame-&gt;can_dlc; i += 2) {</span>
<span class="p_add">+			priv-&gt;write_reg(priv,</span>
<span class="p_add">+					C_CAN_IFACE(DATA1_REG, iface) + i / 2,</span>
<span class="p_add">+					frame-&gt;data[i] |</span>
<span class="p_add">+					(frame-&gt;data[i + 1] &lt;&lt; 8));</span>
<span class="p_add">+		}</span>
 	}
 }
 
<span class="p_chunk">@@ -401,10 +415,20 @@</span> <span class="p_context"> static int c_can_read_msg_object(struct net_device *dev, int iface, u32 ctrl)</span>
 	} else {
 		int i, dreg = C_CAN_IFACE(DATA1_REG, iface);
 
<span class="p_del">-		for (i = 0; i &lt; frame-&gt;can_dlc; i += 2, dreg ++) {</span>
<span class="p_del">-			data = priv-&gt;read_reg(priv, dreg);</span>
<span class="p_del">-			frame-&gt;data[i] = data;</span>
<span class="p_del">-			frame-&gt;data[i + 1] = data &gt;&gt; 8;</span>
<span class="p_add">+		if (priv-&gt;type == BOSCH_D_CAN) {</span>
<span class="p_add">+			for (i = 0; i &lt; frame-&gt;can_dlc; i += 4, dreg += 2) {</span>
<span class="p_add">+				data = priv-&gt;read_reg32(priv, dreg);</span>
<span class="p_add">+				frame-&gt;data[i] = data;</span>
<span class="p_add">+				frame-&gt;data[i + 1] = data &gt;&gt; 8;</span>
<span class="p_add">+				frame-&gt;data[i + 2] = data &gt;&gt; 16;</span>
<span class="p_add">+				frame-&gt;data[i + 3] = data &gt;&gt; 24;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			for (i = 0; i &lt; frame-&gt;can_dlc; i += 2, dreg++) {</span>
<span class="p_add">+				data = priv-&gt;read_reg(priv, dreg);</span>
<span class="p_add">+				frame-&gt;data[i] = data;</span>
<span class="p_add">+				frame-&gt;data[i + 1] = data &gt;&gt; 8;</span>
<span class="p_add">+			}</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/net/can/dev.c b/drivers/net/can/dev.c</span>
<span class="p_header">index 5635c6e7af57..edb3b86eb118 100644</span>
<span class="p_header">--- a/drivers/net/can/dev.c</span>
<span class="p_header">+++ b/drivers/net/can/dev.c</span>
<span class="p_chunk">@@ -881,6 +881,11 @@</span> <span class="p_context"> static int can_newlink(struct net *src_net, struct net_device *dev,</span>
 	return -EOPNOTSUPP;
 }
 
<span class="p_add">+static void can_dellink(struct net_device *dev, struct list_head *head)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct rtnl_link_ops can_link_ops __read_mostly = {
 	.kind		= &quot;can&quot;,
 	.maxtype	= IFLA_CAN_MAX,
<span class="p_chunk">@@ -888,6 +893,7 @@</span> <span class="p_context"> static struct rtnl_link_ops can_link_ops __read_mostly = {</span>
 	.setup		= can_setup,
 	.newlink	= can_newlink,
 	.changelink	= can_changelink,
<span class="p_add">+	.dellink	= can_dellink,</span>
 	.get_size	= can_get_size,
 	.fill_info	= can_fill_info,
 	.get_xstats_size = can_get_xstats_size,
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bcmsysport.c b/drivers/net/ethernet/broadcom/bcmsysport.c</span>
<span class="p_header">index 6e4a6bddf56e..c583dd58268b 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bcmsysport.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bcmsysport.c</span>
<span class="p_chunk">@@ -380,7 +380,7 @@</span> <span class="p_context"> static void bcm_sysport_get_stats(struct net_device *dev,</span>
 		else
 			p = (char *)priv;
 		p += s-&gt;stat_offset;
<span class="p_del">-		data[i] = *(u32 *)p;</span>
<span class="p_add">+		data[i] = *(unsigned long *)p;</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bgmac.c b/drivers/net/ethernet/broadcom/bgmac.c</span>
<span class="p_header">index 05c6af6c418f..41877a3f8596 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bgmac.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bgmac.c</span>
<span class="p_chunk">@@ -1198,7 +1198,7 @@</span> <span class="p_context"> static int bgmac_open(struct net_device *net_dev)</span>
 
 	phy_start(bgmac-&gt;phy_dev);
 
<span class="p_del">-	netif_carrier_on(net_dev);</span>
<span class="p_add">+	netif_start_queue(net_dev);</span>
 
 err_out:
 	return err;
<span class="p_header">diff --git a/drivers/net/ethernet/ibm/ehea/ehea_main.c b/drivers/net/ethernet/ibm/ehea/ehea_main.c</span>
<span class="p_header">index a0b418e007a0..50f9f98c0657 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/ibm/ehea/ehea_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/ibm/ehea/ehea_main.c</span>
<span class="p_chunk">@@ -1169,16 +1169,15 @@</span> <span class="p_context"> static void ehea_parse_eqe(struct ehea_adapter *adapter, u64 eqe)</span>
 	ec = EHEA_BMASK_GET(NEQE_EVENT_CODE, eqe);
 	portnum = EHEA_BMASK_GET(NEQE_PORTNUM, eqe);
 	port = ehea_get_port(adapter, portnum);
<span class="p_add">+	if (!port) {</span>
<span class="p_add">+		netdev_err(NULL, &quot;unknown portnum %x\n&quot;, portnum);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 	dev = port-&gt;netdev;
 
 	switch (ec) {
 	case EHEA_EC_PORTSTATE_CHG:	/* port state change */
 
<span class="p_del">-		if (!port) {</span>
<span class="p_del">-			netdev_err(dev, &quot;unknown portnum %x\n&quot;, portnum);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
 		if (EHEA_BMASK_GET(NEQE_PORT_UP, eqe)) {
 			if (!netif_carrier_ok(dev)) {
 				ret = ehea_sense_port_attr(port);
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40e/i40e_hmc.c b/drivers/net/ethernet/intel/i40e/i40e_hmc.c</span>
<span class="p_header">index 9b987ccc9e82..a91503099a9a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40e/i40e_hmc.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40e/i40e_hmc.c</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> i40e_status i40e_add_sd_table_entry(struct i40e_hw *hw,</span>
 	struct i40e_hmc_sd_entry *sd_entry;
 	bool dma_mem_alloc_done = false;
 	struct i40e_dma_mem mem;
<span class="p_del">-	i40e_status ret_code;</span>
<span class="p_add">+	i40e_status ret_code = I40E_SUCCESS;</span>
 	u64 alloc_len;
 
 	if (NULL == hmc_info-&gt;sd_table.sd_entry) {
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_header">index 50b1f909ce0d..dea92f1af362 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_chunk">@@ -424,14 +424,18 @@</span> <span class="p_context"> static int mlx4_en_vlan_rx_add_vid(struct net_device *dev,</span>
 	mutex_lock(&amp;mdev-&gt;state_lock);
 	if (mdev-&gt;device_up &amp;&amp; priv-&gt;port_up) {
 		err = mlx4_SET_VLAN_FLTR(mdev-&gt;dev, priv);
<span class="p_del">-		if (err)</span>
<span class="p_add">+		if (err) {</span>
 			en_err(priv, &quot;Failed configuring VLAN filter\n&quot;);
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
 	}
<span class="p_del">-	if (mlx4_register_vlan(mdev-&gt;dev, priv-&gt;port, vid, &amp;idx))</span>
<span class="p_del">-		en_dbg(HW, priv, &quot;failed adding vlan %d\n&quot;, vid);</span>
<span class="p_del">-	mutex_unlock(&amp;mdev-&gt;state_lock);</span>
<span class="p_add">+	err = mlx4_register_vlan(mdev-&gt;dev, priv-&gt;port, vid, &amp;idx);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		en_dbg(HW, priv, &quot;Failed adding vlan %d\n&quot;, vid);</span>
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+out:</span>
<span class="p_add">+	mutex_unlock(&amp;mdev-&gt;state_lock);</span>
<span class="p_add">+	return err;</span>
 }
 
 static int mlx4_en_vlan_rx_kill_vid(struct net_device *dev,
<span class="p_chunk">@@ -439,7 +443,7 @@</span> <span class="p_context"> static int mlx4_en_vlan_rx_kill_vid(struct net_device *dev,</span>
 {
 	struct mlx4_en_priv *priv = netdev_priv(dev);
 	struct mlx4_en_dev *mdev = priv-&gt;mdev;
<span class="p_del">-	int err;</span>
<span class="p_add">+	int err = 0;</span>
 
 	en_dbg(HW, priv, &quot;Killing VID:%d\n&quot;, vid);
 
<span class="p_chunk">@@ -456,7 +460,7 @@</span> <span class="p_context"> static int mlx4_en_vlan_rx_kill_vid(struct net_device *dev,</span>
 	}
 	mutex_unlock(&amp;mdev-&gt;state_lock);
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return err;</span>
 }
 
 static void mlx4_en_u64_to_mac(unsigned char dst_mac[ETH_ALEN + 2], u64 src_mac)
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/mcg.c b/drivers/net/ethernet/mellanox/mlx4/mcg.c</span>
<span class="p_header">index 4c36def8e10f..d9afcffee737 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/mcg.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/mcg.c</span>
<span class="p_chunk">@@ -953,7 +953,7 @@</span> <span class="p_context"> int mlx4_qp_attach_common(struct mlx4_dev *dev, struct mlx4_qp *qp, u8 gid[16],</span>
 	struct mlx4_cmd_mailbox *mailbox;
 	struct mlx4_mgm *mgm;
 	u32 members_count;
<span class="p_del">-	int index, prev;</span>
<span class="p_add">+	int index = -1, prev;</span>
 	int link = 0;
 	int i;
 	int err;
<span class="p_chunk">@@ -1032,7 +1032,7 @@</span> <span class="p_context"> int mlx4_qp_attach_common(struct mlx4_dev *dev, struct mlx4_qp *qp, u8 gid[16],</span>
 		goto out;
 
 out:
<span class="p_del">-	if (prot == MLX4_PROT_ETH) {</span>
<span class="p_add">+	if (prot == MLX4_PROT_ETH &amp;&amp; index != -1) {</span>
 		/* manage the steering entry for promisc mode */
 		if (new_entry)
 			new_steering_entry(dev, port, steer, index, qp-&gt;qpn);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c</span>
<span class="p_header">index 87d1b018a9c3..cea4098b1d80 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c</span>
<span class="p_chunk">@@ -509,11 +509,36 @@</span> <span class="p_context"> static void dump_command(struct mlx5_core_dev *dev,</span>
 		pr_debug(&quot;\n&quot;);
 }
 
<span class="p_add">+static u16 msg_to_opcode(struct mlx5_cmd_msg *in)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mlx5_inbox_hdr *hdr = (struct mlx5_inbox_hdr *)(in-&gt;first.data);</span>
<span class="p_add">+</span>
<span class="p_add">+	return be16_to_cpu(hdr-&gt;opcode);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void cb_timeout_handler(struct work_struct *work)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct delayed_work *dwork = container_of(work, struct delayed_work,</span>
<span class="p_add">+						  work);</span>
<span class="p_add">+	struct mlx5_cmd_work_ent *ent = container_of(dwork,</span>
<span class="p_add">+						     struct mlx5_cmd_work_ent,</span>
<span class="p_add">+						     cb_timeout_work);</span>
<span class="p_add">+	struct mlx5_core_dev *dev = container_of(ent-&gt;cmd, struct mlx5_core_dev,</span>
<span class="p_add">+						 cmd);</span>
<span class="p_add">+</span>
<span class="p_add">+	ent-&gt;ret = -ETIMEDOUT;</span>
<span class="p_add">+	mlx5_core_warn(dev, &quot;%s(0x%x) timeout. Will cause a leak of a command resource\n&quot;,</span>
<span class="p_add">+		       mlx5_command_str(msg_to_opcode(ent-&gt;in)),</span>
<span class="p_add">+		       msg_to_opcode(ent-&gt;in));</span>
<span class="p_add">+	mlx5_cmd_comp_handler(dev, 1UL &lt;&lt; ent-&gt;idx);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void cmd_work_handler(struct work_struct *work)
 {
 	struct mlx5_cmd_work_ent *ent = container_of(work, struct mlx5_cmd_work_ent, work);
 	struct mlx5_cmd *cmd = ent-&gt;cmd;
 	struct mlx5_core_dev *dev = container_of(cmd, struct mlx5_core_dev, cmd);
<span class="p_add">+	unsigned long cb_timeout = msecs_to_jiffies(MLX5_CMD_TIMEOUT_MSEC);</span>
 	struct mlx5_cmd_layout *lay;
 	struct semaphore *sem;
 
<span class="p_chunk">@@ -550,6 +575,9 @@</span> <span class="p_context"> static void cmd_work_handler(struct work_struct *work)</span>
 	dump_command(dev, ent, 1);
 	ktime_get_ts(&amp;ent-&gt;ts1);
 
<span class="p_add">+	if (ent-&gt;callback)</span>
<span class="p_add">+		schedule_delayed_work(&amp;ent-&gt;cb_timeout_work, cb_timeout);</span>
<span class="p_add">+</span>
 	/* ring doorbell after the descriptor is valid */
 	wmb();
 	iowrite32be(1 &lt;&lt; ent-&gt;idx, &amp;dev-&gt;iseg-&gt;cmd_dbell);
<span class="p_chunk">@@ -593,13 +621,6 @@</span> <span class="p_context"> static const char *deliv_status_to_str(u8 status)</span>
 	}
 }
 
<span class="p_del">-static u16 msg_to_opcode(struct mlx5_cmd_msg *in)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mlx5_inbox_hdr *hdr = (struct mlx5_inbox_hdr *)(in-&gt;first.data);</span>
<span class="p_del">-</span>
<span class="p_del">-	return be16_to_cpu(hdr-&gt;opcode);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int wait_func(struct mlx5_core_dev *dev, struct mlx5_cmd_work_ent *ent)
 {
 	unsigned long timeout = msecs_to_jiffies(MLX5_CMD_TIMEOUT_MSEC);
<span class="p_chunk">@@ -608,13 +629,13 @@</span> <span class="p_context"> static int wait_func(struct mlx5_core_dev *dev, struct mlx5_cmd_work_ent *ent)</span>
 
 	if (cmd-&gt;mode == CMD_MODE_POLLING) {
 		wait_for_completion(&amp;ent-&gt;done);
<span class="p_del">-		err = ent-&gt;ret;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		if (!wait_for_completion_timeout(&amp;ent-&gt;done, timeout))</span>
<span class="p_del">-			err = -ETIMEDOUT;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			err = 0;</span>
<span class="p_add">+	} else if (!wait_for_completion_timeout(&amp;ent-&gt;done, timeout)) {</span>
<span class="p_add">+		ent-&gt;ret = -ETIMEDOUT;</span>
<span class="p_add">+		mlx5_cmd_comp_handler(dev, 1UL &lt;&lt; ent-&gt;idx);</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	err = ent-&gt;ret;</span>
<span class="p_add">+</span>
 	if (err == -ETIMEDOUT) {
 		mlx5_core_warn(dev, &quot;%s(0x%x) timeout. Will cause a leak of a command resource\n&quot;,
 			       mlx5_command_str(msg_to_opcode(ent-&gt;in)),
<span class="p_chunk">@@ -654,6 +675,7 @@</span> <span class="p_context"> static int mlx5_cmd_invoke(struct mlx5_core_dev *dev, struct mlx5_cmd_msg *in,</span>
 	if (!callback)
 		init_completion(&amp;ent-&gt;done);
 
<span class="p_add">+	INIT_DELAYED_WORK(&amp;ent-&gt;cb_timeout_work, cb_timeout_handler);</span>
 	INIT_WORK(&amp;ent-&gt;work, cmd_work_handler);
 	if (page_queue) {
 		cmd_work_handler(&amp;ent-&gt;work);
<span class="p_chunk">@@ -663,31 +685,29 @@</span> <span class="p_context"> static int mlx5_cmd_invoke(struct mlx5_core_dev *dev, struct mlx5_cmd_msg *in,</span>
 		goto out_free;
 	}
 
<span class="p_del">-	if (!callback) {</span>
<span class="p_del">-		err = wait_func(dev, ent);</span>
<span class="p_del">-		if (err == -ETIMEDOUT)</span>
<span class="p_del">-			goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-		t1 = timespec_to_ktime(ent-&gt;ts1);</span>
<span class="p_del">-		t2 = timespec_to_ktime(ent-&gt;ts2);</span>
<span class="p_del">-		delta = ktime_sub(t2, t1);</span>
<span class="p_del">-		ds = ktime_to_ns(delta);</span>
<span class="p_del">-		op = be16_to_cpu(((struct mlx5_inbox_hdr *)in-&gt;first.data)-&gt;opcode);</span>
<span class="p_del">-		if (op &lt; ARRAY_SIZE(cmd-&gt;stats)) {</span>
<span class="p_del">-			stats = &amp;cmd-&gt;stats[op];</span>
<span class="p_del">-			spin_lock_irq(&amp;stats-&gt;lock);</span>
<span class="p_del">-			stats-&gt;sum += ds;</span>
<span class="p_del">-			++stats-&gt;n;</span>
<span class="p_del">-			spin_unlock_irq(&amp;stats-&gt;lock);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		mlx5_core_dbg_mask(dev, 1 &lt;&lt; MLX5_CMD_TIME,</span>
<span class="p_del">-				   &quot;fw exec time for %s is %lld nsec\n&quot;,</span>
<span class="p_del">-				   mlx5_command_str(op), ds);</span>
<span class="p_del">-		*status = ent-&gt;status;</span>
<span class="p_del">-		free_cmd(ent);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (callback)</span>
<span class="p_add">+		goto out;</span>
 
<span class="p_del">-	return err;</span>
<span class="p_add">+	err = wait_func(dev, ent);</span>
<span class="p_add">+	if (err == -ETIMEDOUT)</span>
<span class="p_add">+		goto out_free;</span>
<span class="p_add">+</span>
<span class="p_add">+	t1 = timespec_to_ktime(ent-&gt;ts1);</span>
<span class="p_add">+	t2 = timespec_to_ktime(ent-&gt;ts2);</span>
<span class="p_add">+	delta = ktime_sub(t2, t1);</span>
<span class="p_add">+	ds = ktime_to_ns(delta);</span>
<span class="p_add">+	op = be16_to_cpu(((struct mlx5_inbox_hdr *)in-&gt;first.data)-&gt;opcode);</span>
<span class="p_add">+	if (op &lt; ARRAY_SIZE(cmd-&gt;stats)) {</span>
<span class="p_add">+		stats = &amp;cmd-&gt;stats[op];</span>
<span class="p_add">+		spin_lock_irq(&amp;stats-&gt;lock);</span>
<span class="p_add">+		stats-&gt;sum += ds;</span>
<span class="p_add">+		++stats-&gt;n;</span>
<span class="p_add">+		spin_unlock_irq(&amp;stats-&gt;lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	mlx5_core_dbg_mask(dev, 1 &lt;&lt; MLX5_CMD_TIME,</span>
<span class="p_add">+			   &quot;fw exec time for %s is %lld nsec\n&quot;,</span>
<span class="p_add">+			   mlx5_command_str(op), ds);</span>
<span class="p_add">+	*status = ent-&gt;status;</span>
 
 out_free:
 	free_cmd(ent);
<span class="p_chunk">@@ -1077,41 +1097,30 @@</span> <span class="p_context"> err_dbg:</span>
 	return err;
 }
 
<span class="p_del">-void mlx5_cmd_use_events(struct mlx5_core_dev *dev)</span>
<span class="p_add">+static void mlx5_cmd_change_mod(struct mlx5_core_dev *dev, int mode)</span>
 {
 	struct mlx5_cmd *cmd = &amp;dev-&gt;cmd;
 	int i;
 
 	for (i = 0; i &lt; cmd-&gt;max_reg_cmds; i++)
 		down(&amp;cmd-&gt;sem);
<span class="p_del">-</span>
 	down(&amp;cmd-&gt;pages_sem);
 
<span class="p_del">-	flush_workqueue(cmd-&gt;wq);</span>
<span class="p_del">-</span>
<span class="p_del">-	cmd-&gt;mode = CMD_MODE_EVENTS;</span>
<span class="p_add">+	cmd-&gt;mode = mode;</span>
 
 	up(&amp;cmd-&gt;pages_sem);
 	for (i = 0; i &lt; cmd-&gt;max_reg_cmds; i++)
 		up(&amp;cmd-&gt;sem);
 }
 
<span class="p_del">-void mlx5_cmd_use_polling(struct mlx5_core_dev *dev)</span>
<span class="p_add">+void mlx5_cmd_use_events(struct mlx5_core_dev *dev)</span>
 {
<span class="p_del">-	struct mlx5_cmd *cmd = &amp;dev-&gt;cmd;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; cmd-&gt;max_reg_cmds; i++)</span>
<span class="p_del">-		down(&amp;cmd-&gt;sem);</span>
<span class="p_del">-</span>
<span class="p_del">-	down(&amp;cmd-&gt;pages_sem);</span>
<span class="p_del">-</span>
<span class="p_del">-	flush_workqueue(cmd-&gt;wq);</span>
<span class="p_del">-	cmd-&gt;mode = CMD_MODE_POLLING;</span>
<span class="p_add">+	mlx5_cmd_change_mod(dev, CMD_MODE_EVENTS);</span>
<span class="p_add">+}</span>
 
<span class="p_del">-	up(&amp;cmd-&gt;pages_sem);</span>
<span class="p_del">-	for (i = 0; i &lt; cmd-&gt;max_reg_cmds; i++)</span>
<span class="p_del">-		up(&amp;cmd-&gt;sem);</span>
<span class="p_add">+void mlx5_cmd_use_polling(struct mlx5_core_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mlx5_cmd_change_mod(dev, CMD_MODE_POLLING);</span>
 }
 
 static void free_msg(struct mlx5_core_dev *dev, struct mlx5_cmd_msg *msg)
<span class="p_chunk">@@ -1145,6 +1154,8 @@</span> <span class="p_context"> void mlx5_cmd_comp_handler(struct mlx5_core_dev *dev, unsigned long vector)</span>
 			struct semaphore *sem;
 
 			ent = cmd-&gt;ent_arr[i];
<span class="p_add">+			if (ent-&gt;callback)</span>
<span class="p_add">+				cancel_delayed_work(&amp;ent-&gt;cb_timeout_work);</span>
 			if (ent-&gt;page_queue)
 				sem = &amp;cmd-&gt;pages_sem;
 			else
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/qp.c b/drivers/net/ethernet/mellanox/mlx5/core/qp.c</span>
<span class="p_header">index 8145b4668229..e7c94a58864b 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/qp.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/qp.c</span>
<span class="p_chunk">@@ -274,7 +274,7 @@</span> <span class="p_context"> int mlx5_core_xrcd_alloc(struct mlx5_core_dev *dev, u32 *xrcdn)</span>
 	if (out.hdr.status)
 		err = mlx5_cmd_status_to_err(&amp;out.hdr);
 	else
<span class="p_del">-		*xrcdn = be32_to_cpu(out.xrcdn);</span>
<span class="p_add">+		*xrcdn = be32_to_cpu(out.xrcdn) &amp; 0xffffff;</span>
 
 	return err;
 }
<span class="p_header">diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c</span>
<span class="p_header">index e45bf09af0c9..df081f64c5c2 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c</span>
<span class="p_chunk">@@ -2198,7 +2198,7 @@</span> <span class="p_context"> void qlcnic_83xx_process_rcv_ring_diag(struct qlcnic_host_sds_ring *sds_ring)</span>
 	if (!opcode)
 		return;
 
<span class="p_del">-	ring = QLCNIC_FETCH_RING_ID(qlcnic_83xx_hndl(sts_data[0]));</span>
<span class="p_add">+	ring = QLCNIC_FETCH_RING_ID(sts_data[0]);</span>
 	qlcnic_83xx_process_rcv_diag(adapter, ring, sts_data);
 	desc = &amp;sds_ring-&gt;desc_head[consumer];
 	desc-&gt;status_desc_data[0] = cpu_to_le64(STATUS_OWNER_PHANTOM);
<span class="p_header">diff --git a/drivers/net/ethernet/sfc/ef10.c b/drivers/net/ethernet/sfc/ef10.c</span>
<span class="p_header">index b5ed30a39144..f41d07bcb400 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sfc/ef10.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sfc/ef10.c</span>
<span class="p_chunk">@@ -451,6 +451,17 @@</span> <span class="p_context"> fail:</span>
 	return rc;
 }
 
<span class="p_add">+static void efx_ef10_forget_old_piobufs(struct efx_nic *efx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct efx_channel *channel;</span>
<span class="p_add">+	struct efx_tx_queue *tx_queue;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* All our existing PIO buffers went away */</span>
<span class="p_add">+	efx_for_each_channel(channel, efx)</span>
<span class="p_add">+		efx_for_each_channel_tx_queue(tx_queue, channel)</span>
<span class="p_add">+			tx_queue-&gt;piobuf = NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #else /* !EFX_USE_PIO */
 
 static int efx_ef10_alloc_piobufs(struct efx_nic *efx, unsigned int n)
<span class="p_chunk">@@ -467,6 +478,10 @@</span> <span class="p_context"> static void efx_ef10_free_piobufs(struct efx_nic *efx)</span>
 {
 }
 
<span class="p_add">+static void efx_ef10_forget_old_piobufs(struct efx_nic *efx)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif /* EFX_USE_PIO */
 
 static void efx_ef10_remove(struct efx_nic *efx)
<span class="p_chunk">@@ -698,6 +713,7 @@</span> <span class="p_context"> static void efx_ef10_reset_mc_allocations(struct efx_nic *efx)</span>
 	nic_data-&gt;must_realloc_vis = true;
 	nic_data-&gt;must_restore_filters = true;
 	nic_data-&gt;must_restore_piobufs = true;
<span class="p_add">+	efx_ef10_forget_old_piobufs(efx);</span>
 	nic_data-&gt;rx_rss_context = EFX_EF10_RSS_CONTEXT_INVALID;
 }
 
<span class="p_header">diff --git a/drivers/net/phy/fixed.c b/drivers/net/phy/fixed.c</span>
<span class="p_header">index 5ea82da50ceb..28157ceadc48 100644</span>
<span class="p_header">--- a/drivers/net/phy/fixed.c</span>
<span class="p_header">+++ b/drivers/net/phy/fixed.c</span>
<span class="p_chunk">@@ -22,6 +22,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/err.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/of.h&gt;
<span class="p_add">+#include &lt;linux/idr.h&gt;</span>
 
 #define MII_REGS_NUM 29
 
<span class="p_chunk">@@ -204,6 +205,8 @@</span> <span class="p_context"> err_regs:</span>
 }
 EXPORT_SYMBOL_GPL(fixed_phy_add);
 
<span class="p_add">+static DEFINE_IDA(phy_fixed_ida);</span>
<span class="p_add">+</span>
 void fixed_phy_del(int phy_addr)
 {
 	struct fixed_mdio_bus *fmb = &amp;platform_fmb;
<span class="p_chunk">@@ -213,15 +216,13 @@</span> <span class="p_context"> void fixed_phy_del(int phy_addr)</span>
 		if (fp-&gt;addr == phy_addr) {
 			list_del(&amp;fp-&gt;node);
 			kfree(fp);
<span class="p_add">+			ida_simple_remove(&amp;phy_fixed_ida, phy_addr);</span>
 			return;
 		}
 	}
 }
 EXPORT_SYMBOL_GPL(fixed_phy_del);
 
<span class="p_del">-static int phy_fixed_addr;</span>
<span class="p_del">-static DEFINE_SPINLOCK(phy_fixed_addr_lock);</span>
<span class="p_del">-</span>
 int fixed_phy_register(unsigned int irq,
 		       struct fixed_phy_status *status,
 		       struct device_node *np)
<span class="p_chunk">@@ -232,17 +233,15 @@</span> <span class="p_context"> int fixed_phy_register(unsigned int irq,</span>
 	int ret;
 
 	/* Get the next available PHY address, up to PHY_MAX_ADDR */
<span class="p_del">-	spin_lock(&amp;phy_fixed_addr_lock);</span>
<span class="p_del">-	if (phy_fixed_addr == PHY_MAX_ADDR) {</span>
<span class="p_del">-		spin_unlock(&amp;phy_fixed_addr_lock);</span>
<span class="p_del">-		return -ENOSPC;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	phy_addr = phy_fixed_addr++;</span>
<span class="p_del">-	spin_unlock(&amp;phy_fixed_addr_lock);</span>
<span class="p_add">+	phy_addr = ida_simple_get(&amp;phy_fixed_ida, 0, PHY_MAX_ADDR, GFP_KERNEL);</span>
<span class="p_add">+	if (phy_addr &lt; 0)</span>
<span class="p_add">+		return phy_addr;</span>
 
 	ret = fixed_phy_add(irq, phy_addr, status);
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		ida_simple_remove(&amp;phy_fixed_ida, phy_addr);</span>
 		return ret;
<span class="p_add">+	}</span>
 
 	phy = get_phy_device(fmb-&gt;mii_bus, phy_addr, false);
 	if (!phy || IS_ERR(phy)) {
<span class="p_chunk">@@ -317,6 +316,7 @@</span> <span class="p_context"> static void __exit fixed_mdio_bus_exit(void)</span>
 		list_del(&amp;fp-&gt;node);
 		kfree(fp);
 	}
<span class="p_add">+	ida_destroy(&amp;phy_fixed_ida);</span>
 }
 module_exit(fixed_mdio_bus_exit);
 
<span class="p_header">diff --git a/drivers/net/tun.c b/drivers/net/tun.c</span>
<span class="p_header">index 999484feb377..4d4527c13f52 100644</span>
<span class="p_header">--- a/drivers/net/tun.c</span>
<span class="p_header">+++ b/drivers/net/tun.c</span>
<span class="p_chunk">@@ -499,11 +499,13 @@</span> <span class="p_context"> static void tun_detach_all(struct net_device *dev)</span>
 	for (i = 0; i &lt; n; i++) {
 		tfile = rtnl_dereference(tun-&gt;tfiles[i]);
 		BUG_ON(!tfile);
<span class="p_add">+		tfile-&gt;socket.sk-&gt;sk_shutdown = RCV_SHUTDOWN;</span>
 		tfile-&gt;socket.sk-&gt;sk_data_ready(tfile-&gt;socket.sk);
 		RCU_INIT_POINTER(tfile-&gt;tun, NULL);
 		--tun-&gt;numqueues;
 	}
 	list_for_each_entry(tfile, &amp;tun-&gt;disabled, next) {
<span class="p_add">+		tfile-&gt;socket.sk-&gt;sk_shutdown = RCV_SHUTDOWN;</span>
 		tfile-&gt;socket.sk-&gt;sk_data_ready(tfile-&gt;socket.sk);
 		RCU_INIT_POINTER(tfile-&gt;tun, NULL);
 	}
<span class="p_chunk">@@ -559,6 +561,7 @@</span> <span class="p_context"> static int tun_attach(struct tun_struct *tun, struct file *file, bool skip_filte</span>
 			goto out;
 	}
 	tfile-&gt;queue_index = tun-&gt;numqueues;
<span class="p_add">+	tfile-&gt;socket.sk-&gt;sk_shutdown &amp;= ~RCV_SHUTDOWN;</span>
 	rcu_assign_pointer(tfile-&gt;tun, tun);
 	rcu_assign_pointer(tun-&gt;tfiles[tun-&gt;numqueues], tfile);
 	tun-&gt;numqueues++;
<span class="p_chunk">@@ -1345,9 +1348,6 @@</span> <span class="p_context"> static ssize_t tun_do_read(struct tun_struct *tun, struct tun_file *tfile,</span>
 	if (!len)
 		return ret;
 
<span class="p_del">-	if (tun-&gt;dev-&gt;reg_state != NETREG_REGISTERED)</span>
<span class="p_del">-		return -EIO;</span>
<span class="p_del">-</span>
 	/* Read frames from queue */
 	skb = __skb_recv_datagram(tfile-&gt;socket.sk, noblock ? MSG_DONTWAIT : 0,
 				  &amp;peeked, &amp;off, &amp;err);
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath5k/led.c b/drivers/net/wireless/ath/ath5k/led.c</span>
<span class="p_header">index f77ef36acf87..61879b1f7083 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath5k/led.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath5k/led.c</span>
<span class="p_chunk">@@ -77,7 +77,7 @@</span> <span class="p_context"> static DEFINE_PCI_DEVICE_TABLE(ath5k_led_devices) = {</span>
 	/* HP Compaq CQ60-206US (ddreggors@jumptv.com) */
 	{ ATH_SDEVICE(PCI_VENDOR_ID_HP, 0x0137a), ATH_LED(3, 1) },
 	/* HP Compaq C700 (nitrousnrg@gmail.com) */
<span class="p_del">-	{ ATH_SDEVICE(PCI_VENDOR_ID_HP, 0x0137b), ATH_LED(3, 1) },</span>
<span class="p_add">+	{ ATH_SDEVICE(PCI_VENDOR_ID_HP, 0x0137b), ATH_LED(3, 0) },</span>
 	/* LiteOn AR5BXB63 (magooz@salug.it) */
 	{ ATH_SDEVICE(PCI_VENDOR_ID_ATHEROS, 0x3067), ATH_LED(3, 0) },
 	/* IBM-specific AR5212 (all others) */
<span class="p_header">diff --git a/drivers/net/wireless/mac80211_hwsim.c b/drivers/net/wireless/mac80211_hwsim.c</span>
<span class="p_header">index d7cc36304e58..b6eca0cdfd46 100644</span>
<span class="p_header">--- a/drivers/net/wireless/mac80211_hwsim.c</span>
<span class="p_header">+++ b/drivers/net/wireless/mac80211_hwsim.c</span>
<span class="p_chunk">@@ -2275,6 +2275,7 @@</span> <span class="p_context"> static int hwsim_tx_info_frame_received_nl(struct sk_buff *skb_2,</span>
 	if (!info-&gt;attrs[HWSIM_ATTR_ADDR_TRANSMITTER] ||
 	    !info-&gt;attrs[HWSIM_ATTR_FLAGS] ||
 	    !info-&gt;attrs[HWSIM_ATTR_COOKIE] ||
<span class="p_add">+	    !info-&gt;attrs[HWSIM_ATTR_SIGNAL] ||</span>
 	    !info-&gt;attrs[HWSIM_ATTR_TX_INFO])
 		goto out;
 
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/base.c b/drivers/net/wireless/rtlwifi/base.c</span>
<span class="p_header">index 93bb384eb001..0484de7847e9 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/base.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/base.c</span>
<span class="p_chunk">@@ -1401,9 +1401,9 @@</span> <span class="p_context"> void rtl_watchdog_wq_callback(void *data)</span>
 		if (((rtlpriv-&gt;link_info.num_rx_inperiod +
 		      rtlpriv-&gt;link_info.num_tx_inperiod) &gt; 8) ||
 		    (rtlpriv-&gt;link_info.num_rx_inperiod &gt; 2))
<span class="p_del">-			rtlpriv-&gt;enter_ps = true;</span>
<span class="p_del">-		else</span>
 			rtlpriv-&gt;enter_ps = false;
<span class="p_add">+		else</span>
<span class="p_add">+			rtlpriv-&gt;enter_ps = true;</span>
 
 		/* LeisurePS only work in infra mode. */
 		schedule_work(&amp;rtlpriv-&gt;works.lps_change_work);
<span class="p_header">diff --git a/drivers/of/irq.c b/drivers/of/irq.c</span>
<span class="p_header">index b97363adca0b..8e557ebb8d84 100644</span>
<span class="p_header">--- a/drivers/of/irq.c</span>
<span class="p_header">+++ b/drivers/of/irq.c</span>
<span class="p_chunk">@@ -385,13 +385,13 @@</span> <span class="p_context"> int of_irq_to_resource(struct device_node *dev, int index, struct resource *r)</span>
 EXPORT_SYMBOL_GPL(of_irq_to_resource);
 
 /**
<span class="p_del">- * of_irq_get - Decode a node&#39;s IRQ and return it as a Linux irq number</span>
<span class="p_add">+ * of_irq_get - Decode a node&#39;s IRQ and return it as a Linux IRQ number</span>
  * @dev: pointer to device tree node
<span class="p_del">- * @index: zero-based index of the irq</span>
<span class="p_del">- *</span>
<span class="p_del">- * Returns Linux irq number on success, or -EPROBE_DEFER if the irq domain</span>
<span class="p_del">- * is not yet created.</span>
<span class="p_add">+ * @index: zero-based index of the IRQ</span>
  *
<span class="p_add">+ * Returns Linux IRQ number on success, or 0 on the IRQ mapping failure, or</span>
<span class="p_add">+ * -EPROBE_DEFER if the IRQ domain is not yet created, or error code in case</span>
<span class="p_add">+ * of any other failure.</span>
  */
 int of_irq_get(struct device_node *dev, int index)
 {
<span class="p_chunk">@@ -411,12 +411,13 @@</span> <span class="p_context"> int of_irq_get(struct device_node *dev, int index)</span>
 }
 
 /**
<span class="p_del">- * of_irq_get_byname - Decode a node&#39;s IRQ and return it as a Linux irq number</span>
<span class="p_add">+ * of_irq_get_byname - Decode a node&#39;s IRQ and return it as a Linux IRQ number</span>
  * @dev: pointer to device tree node
<span class="p_del">- * @name: irq name</span>
<span class="p_add">+ * @name: IRQ name</span>
  *
<span class="p_del">- * Returns Linux irq number on success, or -EPROBE_DEFER if the irq domain</span>
<span class="p_del">- * is not yet created, or error code in case of any other failure.</span>
<span class="p_add">+ * Returns Linux IRQ number on success, or 0 on the IRQ mapping failure, or</span>
<span class="p_add">+ * -EPROBE_DEFER if the IRQ domain is not yet created, or error code in case</span>
<span class="p_add">+ * of any other failure.</span>
  */
 int of_irq_get_byname(struct device_node *dev, const char *name)
 {
<span class="p_header">diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c</span>
<span class="p_header">index 045b63ae97d5..ca5434b97ef4 100644</span>
<span class="p_header">--- a/drivers/pci/pci-sysfs.c</span>
<span class="p_header">+++ b/drivers/pci/pci-sysfs.c</span>
<span class="p_chunk">@@ -1005,6 +1005,9 @@</span> <span class="p_context"> static int pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,</span>
 	if (i &gt;= PCI_ROM_RESOURCE)
 		return -ENODEV;
 
<span class="p_add">+	if (res-&gt;flags &amp; IORESOURCE_MEM &amp;&amp; iomem_is_exclusive(res-&gt;start))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if (!pci_mmap_fits(pdev, i, vma, PCI_MMAP_SYSFS)) {
 		WARN(1, &quot;process \&quot;%s\&quot; tried to map 0x%08lx bytes at page 0x%08lx on %s BAR %d (start 0x%16Lx, size 0x%16Lx)\n&quot;,
 			current-&gt;comm, vma-&gt;vm_end-vma-&gt;vm_start, vma-&gt;vm_pgoff,
<span class="p_chunk">@@ -1021,10 +1024,6 @@</span> <span class="p_context"> static int pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,</span>
 	pci_resource_to_user(pdev, i, res, &amp;start, &amp;end);
 	vma-&gt;vm_pgoff += start &gt;&gt; PAGE_SHIFT;
 	mmap_type = res-&gt;flags &amp; IORESOURCE_MEM ? pci_mmap_mem : pci_mmap_io;
<span class="p_del">-</span>
<span class="p_del">-	if (res-&gt;flags &amp; IORESOURCE_MEM &amp;&amp; iomem_is_exclusive(start))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
 	return pci_mmap_page_range(pdev, vma, mmap_type, write_combine);
 }
 
<span class="p_header">diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c</span>
<span class="p_header">index 57d884c7412e..28b557c5563d 100644</span>
<span class="p_header">--- a/drivers/pci/probe.c</span>
<span class="p_header">+++ b/drivers/pci/probe.c</span>
<span class="p_chunk">@@ -176,9 +176,6 @@</span> <span class="p_context"> int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,</span>
 	struct pci_bus_region region, inverted_region;
 	bool bar_too_big = false, bar_too_high = false, bar_invalid = false;
 
<span class="p_del">-	if (dev-&gt;non_compliant_bars)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
 	mask = type ? PCI_ROM_ADDRESS_MASK : ~0;
 
 	/* No printks while decoding is disabled! */
<span class="p_chunk">@@ -330,6 +327,9 @@</span> <span class="p_context"> static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)</span>
 {
 	unsigned int pos, reg;
 
<span class="p_add">+	if (dev-&gt;non_compliant_bars)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	for (pos = 0; pos &lt; howmany; pos++) {
 		struct resource *res = &amp;dev-&gt;resource[pos];
 		reg = PCI_BASE_ADDRESS_0 + (pos &lt;&lt; 2);
<span class="p_header">diff --git a/drivers/pinctrl/pinctrl-single.c b/drivers/pinctrl/pinctrl-single.c</span>
<span class="p_header">index 8fda801c5c48..0d19ac11ab9e 100644</span>
<span class="p_header">--- a/drivers/pinctrl/pinctrl-single.c</span>
<span class="p_header">+++ b/drivers/pinctrl/pinctrl-single.c</span>
<span class="p_chunk">@@ -1632,6 +1632,9 @@</span> <span class="p_context"> static inline void pcs_irq_set(struct pcs_soc_data *pcs_soc,</span>
 		else
 			mask &amp;= ~soc_mask;
 		pcs-&gt;write(mask, pcswi-&gt;reg);
<span class="p_add">+</span>
<span class="p_add">+		/* flush posted write */</span>
<span class="p_add">+		mask = pcs-&gt;read(pcswi-&gt;reg);</span>
 		raw_spin_unlock(&amp;pcs-&gt;lock);
 	}
 
<span class="p_header">diff --git a/drivers/s390/char/sclp_ctl.c b/drivers/s390/char/sclp_ctl.c</span>
<span class="p_header">index 648cb86afd42..ea607a4a1bdd 100644</span>
<span class="p_header">--- a/drivers/s390/char/sclp_ctl.c</span>
<span class="p_header">+++ b/drivers/s390/char/sclp_ctl.c</span>
<span class="p_chunk">@@ -56,6 +56,7 @@</span> <span class="p_context"> static int sclp_ctl_ioctl_sccb(void __user *user_area)</span>
 {
 	struct sclp_ctl_sccb ctl_sccb;
 	struct sccb_header *sccb;
<span class="p_add">+	unsigned long copied;</span>
 	int rc;
 
 	if (copy_from_user(&amp;ctl_sccb, user_area, sizeof(ctl_sccb)))
<span class="p_chunk">@@ -65,14 +66,15 @@</span> <span class="p_context"> static int sclp_ctl_ioctl_sccb(void __user *user_area)</span>
 	sccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);
 	if (!sccb)
 		return -ENOMEM;
<span class="p_del">-	if (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sizeof(*sccb))) {</span>
<span class="p_add">+	copied = PAGE_SIZE -</span>
<span class="p_add">+		copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), PAGE_SIZE);</span>
<span class="p_add">+	if (offsetof(struct sccb_header, length) +</span>
<span class="p_add">+	    sizeof(sccb-&gt;length) &gt; copied || sccb-&gt;length &gt; copied) {</span>
 		rc = -EFAULT;
 		goto out_free;
 	}
<span class="p_del">-	if (sccb-&gt;length &gt; PAGE_SIZE || sccb-&gt;length &lt; 8)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	if (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sccb-&gt;length)) {</span>
<span class="p_del">-		rc = -EFAULT;</span>
<span class="p_add">+	if (sccb-&gt;length &lt; 8) {</span>
<span class="p_add">+		rc = -EINVAL;</span>
 		goto out_free;
 	}
 	rc = sclp_sync_request(ctl_sccb.cmdw, sccb);
<span class="p_header">diff --git a/drivers/s390/net/qeth_l2_main.c b/drivers/s390/net/qeth_l2_main.c</span>
<span class="p_header">index 12339e6bd23e..c75bddfaa837 100644</span>
<span class="p_header">--- a/drivers/s390/net/qeth_l2_main.c</span>
<span class="p_header">+++ b/drivers/s390/net/qeth_l2_main.c</span>
<span class="p_chunk">@@ -911,6 +911,7 @@</span> <span class="p_context"> static void qeth_l2_remove_device(struct ccwgroup_device *cgdev)</span>
 		qeth_l2_set_offline(cgdev);
 
 	if (card-&gt;dev) {
<span class="p_add">+		netif_napi_del(&amp;card-&gt;napi);</span>
 		unregister_netdev(card-&gt;dev);
 		card-&gt;dev = NULL;
 	}
<span class="p_header">diff --git a/drivers/s390/net/qeth_l3_main.c b/drivers/s390/net/qeth_l3_main.c</span>
<span class="p_header">index 3cbe133a0d96..3e5ba1ac9e2a 100644</span>
<span class="p_header">--- a/drivers/s390/net/qeth_l3_main.c</span>
<span class="p_header">+++ b/drivers/s390/net/qeth_l3_main.c</span>
<span class="p_chunk">@@ -3337,6 +3337,7 @@</span> <span class="p_context"> static void qeth_l3_remove_device(struct ccwgroup_device *cgdev)</span>
 		qeth_l3_set_offline(cgdev);
 
 	if (card-&gt;dev) {
<span class="p_add">+		netif_napi_del(&amp;card-&gt;napi);</span>
 		unregister_netdev(card-&gt;dev);
 		card-&gt;dev = NULL;
 	}
<span class="p_header">diff --git a/drivers/scsi/aacraid/commsup.c b/drivers/scsi/aacraid/commsup.c</span>
<span class="p_header">index 6b32ddcefc11..ce177a50ec05 100644</span>
<span class="p_header">--- a/drivers/scsi/aacraid/commsup.c</span>
<span class="p_header">+++ b/drivers/scsi/aacraid/commsup.c</span>
<span class="p_chunk">@@ -590,10 +590,10 @@</span> <span class="p_context"> int aac_fib_send(u16 command, struct fib *fibptr, unsigned long size,</span>
 					}
 					return -EFAULT;
 				}
<span class="p_del">-				/* We used to udelay() here but that absorbed</span>
<span class="p_del">-				 * a CPU when a timeout occured. Not very</span>
<span class="p_del">-				 * useful. */</span>
<span class="p_del">-				cpu_relax();</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Allow other processes / CPUS to use core</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				schedule();</span>
 			}
 		} else if (down_interruptible(&amp;fibptr-&gt;event_wait)) {
 			/* Do nothing ... satisfy
<span class="p_chunk">@@ -1921,6 +1921,10 @@</span> <span class="p_context"> int aac_command_thread(void *data)</span>
 		if (difference &lt;= 0)
 			difference = 1;
 		set_current_state(TASK_INTERRUPTIBLE);
<span class="p_add">+</span>
<span class="p_add">+		if (kthread_should_stop())</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
 		schedule_timeout(difference);
 
 		if (kthread_should_stop())
<span class="p_header">diff --git a/drivers/scsi/ipr.c b/drivers/scsi/ipr.c</span>
<span class="p_header">index de2bfa24b91a..ee38ab64422b 100644</span>
<span class="p_header">--- a/drivers/scsi/ipr.c</span>
<span class="p_header">+++ b/drivers/scsi/ipr.c</span>
<span class="p_chunk">@@ -9753,6 +9753,7 @@</span> <span class="p_context"> static int ipr_probe_ioa(struct pci_dev *pdev,</span>
 		ioa_cfg-&gt;intr_flag = IPR_USE_MSI;
 	else {
 		ioa_cfg-&gt;intr_flag = IPR_USE_LSI;
<span class="p_add">+		ioa_cfg-&gt;clear_isr = 1;</span>
 		ioa_cfg-&gt;nvectors = 1;
 		dev_info(&amp;pdev-&gt;dev, &quot;Cannot enable MSI.\n&quot;);
 	}
<span class="p_header">diff --git a/drivers/scsi/scsi_devinfo.c b/drivers/scsi/scsi_devinfo.c</span>
<span class="p_header">index 6e2256f7d7d6..7439304f01d0 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_devinfo.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_devinfo.c</span>
<span class="p_chunk">@@ -227,6 +227,7 @@</span> <span class="p_context"> static struct {</span>
 	{&quot;PIONEER&quot;, &quot;CD-ROM DRM-624X&quot;, NULL, BLIST_FORCELUN | BLIST_SINGLELUN},
 	{&quot;Promise&quot;, &quot;VTrak E610f&quot;, NULL, BLIST_SPARSELUN | BLIST_NO_RSOC},
 	{&quot;Promise&quot;, &quot;&quot;, NULL, BLIST_SPARSELUN},
<span class="p_add">+	{&quot;QEMU&quot;, &quot;QEMU CD-ROM&quot;, NULL, BLIST_SKIP_VPD_PAGES},</span>
 	{&quot;QNAP&quot;, &quot;iSCSI Storage&quot;, NULL, BLIST_MAX_1024},
 	{&quot;QUANTUM&quot;, &quot;XP34301&quot;, &quot;1071&quot;, BLIST_NOTQ},
 	{&quot;REGAL&quot;, &quot;CDC-4X&quot;, NULL, BLIST_MAX5LUN | BLIST_SINGLELUN},
<span class="p_header">diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c</span>
<span class="p_header">index 48790f1dbf79..07ab11da83a0 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_error.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_error.c</span>
<span class="p_chunk">@@ -1115,7 +1115,6 @@</span> <span class="p_context"> static int scsi_eh_action(struct scsi_cmnd *scmd, int rtn)</span>
  */
 void scsi_eh_finish_cmd(struct scsi_cmnd *scmd, struct list_head *done_q)
 {
<span class="p_del">-	scmd-&gt;device-&gt;host-&gt;host_failed--;</span>
 	scmd-&gt;eh_eflags = 0;
 	list_move_tail(&amp;scmd-&gt;eh_entry, done_q);
 }
<span class="p_chunk">@@ -2198,6 +2197,9 @@</span> <span class="p_context"> int scsi_error_handler(void *data)</span>
 		else
 			scsi_unjam_host(shost);
 
<span class="p_add">+		/* All scmds have been handled */</span>
<span class="p_add">+		shost-&gt;host_failed = 0;</span>
<span class="p_add">+</span>
 		/*
 		 * Note - if the above fails completely, the action is to take
 		 * individual devices offline and flush the queue of any
<span class="p_header">diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c</span>
<span class="p_header">index d7062a06f72e..7e817b1f95f0 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_lib.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_lib.c</span>
<span class="p_chunk">@@ -775,9 +775,12 @@</span> <span class="p_context"> void scsi_io_completion(struct scsi_cmnd *cmd, unsigned int good_bytes)</span>
 	}
 
 	/*
<span class="p_del">-	 * If we finished all bytes in the request we are done now.</span>
<span class="p_add">+	 * special case: failed zero length commands always need to</span>
<span class="p_add">+	 * drop down into the retry code. Otherwise, if we finished</span>
<span class="p_add">+	 * all bytes in the request we are done now.</span>
 	 */
<span class="p_del">-	if (!blk_end_request(req, error, good_bytes))</span>
<span class="p_add">+	if (!(blk_rq_bytes(req) == 0 &amp;&amp; error) &amp;&amp;</span>
<span class="p_add">+	    !blk_end_request(req, error, good_bytes))</span>
 		goto next_command;
 
 	/*
<span class="p_header">diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c</span>
<span class="p_header">index 44458696c7b6..98996ba87f3b 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_scan.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_scan.c</span>
<span class="p_chunk">@@ -320,6 +320,7 @@</span> <span class="p_context"> static void scsi_target_destroy(struct scsi_target *starget)</span>
 	struct Scsi_Host *shost = dev_to_shost(dev-&gt;parent);
 	unsigned long flags;
 
<span class="p_add">+	BUG_ON(starget-&gt;state == STARGET_DEL);</span>
 	starget-&gt;state = STARGET_DEL;
 	transport_destroy_device(dev);
 	spin_lock_irqsave(shost-&gt;host_lock, flags);
<span class="p_header">diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c</span>
<span class="p_header">index 6c26b9743c52..1b30a65554f9 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_sysfs.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_sysfs.c</span>
<span class="p_chunk">@@ -1148,18 +1148,18 @@</span> <span class="p_context"> static void __scsi_remove_target(struct scsi_target *starget)</span>
 void scsi_remove_target(struct device *dev)
 {
 	struct Scsi_Host *shost = dev_to_shost(dev-&gt;parent);
<span class="p_del">-	struct scsi_target *starget, *last_target = NULL;</span>
<span class="p_add">+	struct scsi_target *starget;</span>
 	unsigned long flags;
 
 restart:
 	spin_lock_irqsave(shost-&gt;host_lock, flags);
 	list_for_each_entry(starget, &amp;shost-&gt;__targets, siblings) {
 		if (starget-&gt;state == STARGET_DEL ||
<span class="p_del">-		    starget == last_target)</span>
<span class="p_add">+		    starget-&gt;state == STARGET_REMOVE)</span>
 			continue;
 		if (starget-&gt;dev.parent == dev || &amp;starget-&gt;dev == dev) {
 			kref_get(&amp;starget-&gt;reap_ref);
<span class="p_del">-			last_target = starget;</span>
<span class="p_add">+			starget-&gt;state = STARGET_REMOVE;</span>
 			spin_unlock_irqrestore(shost-&gt;host_lock, flags);
 			__scsi_remove_target(starget);
 			scsi_target_reap(starget);
<span class="p_header">diff --git a/drivers/spi/spi-sun4i.c b/drivers/spi/spi-sun4i.c</span>
<span class="p_header">index 85204c93f3d3..36f39a331a01 100644</span>
<span class="p_header">--- a/drivers/spi/spi-sun4i.c</span>
<span class="p_header">+++ b/drivers/spi/spi-sun4i.c</span>
<span class="p_chunk">@@ -170,13 +170,17 @@</span> <span class="p_context"> static int sun4i_spi_transfer_one(struct spi_master *master,</span>
 {
 	struct sun4i_spi *sspi = spi_master_get_devdata(master);
 	unsigned int mclk_rate, div, timeout;
<span class="p_add">+	unsigned int start, end, tx_time;</span>
 	unsigned int tx_len = 0;
 	int ret = 0;
 	u32 reg;
 
 	/* We don&#39;t support transfer larger than the FIFO */
 	if (tfr-&gt;len &gt; SUN4I_FIFO_DEPTH)
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		return -EMSGSIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tfr-&gt;tx_buf &amp;&amp; tfr-&gt;len &gt;= SUN4I_FIFO_DEPTH)</span>
<span class="p_add">+		return -EMSGSIZE;</span>
 
 	reinit_completion(&amp;sspi-&gt;done);
 	sspi-&gt;tx_buf = tfr-&gt;tx_buf;
<span class="p_chunk">@@ -269,8 +273,12 @@</span> <span class="p_context"> static int sun4i_spi_transfer_one(struct spi_master *master,</span>
 	sun4i_spi_write(sspi, SUN4I_BURST_CNT_REG, SUN4I_BURST_CNT(tfr-&gt;len));
 	sun4i_spi_write(sspi, SUN4I_XMIT_CNT_REG, SUN4I_XMIT_CNT(tx_len));
 
<span class="p_del">-	/* Fill the TX FIFO */</span>
<span class="p_del">-	sun4i_spi_fill_fifo(sspi, SUN4I_FIFO_DEPTH);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Fill the TX FIFO</span>
<span class="p_add">+	 * Filling the FIFO fully causes timeout for some reason</span>
<span class="p_add">+	 * at least on spi2 on A10s</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	sun4i_spi_fill_fifo(sspi, SUN4I_FIFO_DEPTH - 1);</span>
 
 	/* Enable the interrupts */
 	sun4i_spi_write(sspi, SUN4I_INT_CTL_REG, SUN4I_INT_CTL_TC);
<span class="p_chunk">@@ -279,9 +287,16 @@</span> <span class="p_context"> static int sun4i_spi_transfer_one(struct spi_master *master,</span>
 	reg = sun4i_spi_read(sspi, SUN4I_CTL_REG);
 	sun4i_spi_write(sspi, SUN4I_CTL_REG, reg | SUN4I_CTL_XCH);
 
<span class="p_add">+	tx_time = max(tfr-&gt;len * 8 * 2 / (tfr-&gt;speed_hz / 1000), 100U);</span>
<span class="p_add">+	start = jiffies;</span>
 	timeout = wait_for_completion_timeout(&amp;sspi-&gt;done,
<span class="p_del">-					      msecs_to_jiffies(1000));</span>
<span class="p_add">+					      msecs_to_jiffies(tx_time));</span>
<span class="p_add">+	end = jiffies;</span>
 	if (!timeout) {
<span class="p_add">+		dev_warn(&amp;master-&gt;dev,</span>
<span class="p_add">+			 &quot;%s: timeout transferring %u bytes@%iHz for %i(%i)ms&quot;,</span>
<span class="p_add">+			 dev_name(&amp;spi-&gt;dev), tfr-&gt;len, tfr-&gt;speed_hz,</span>
<span class="p_add">+			 jiffies_to_msecs(end - start), tx_time);</span>
 		ret = -ETIMEDOUT;
 		goto out;
 	}
<span class="p_header">diff --git a/drivers/spi/spi-sun6i.c b/drivers/spi/spi-sun6i.c</span>
<span class="p_header">index bd24093f4038..97f2e9bb3c24 100644</span>
<span class="p_header">--- a/drivers/spi/spi-sun6i.c</span>
<span class="p_header">+++ b/drivers/spi/spi-sun6i.c</span>
<span class="p_chunk">@@ -160,6 +160,7 @@</span> <span class="p_context"> static int sun6i_spi_transfer_one(struct spi_master *master,</span>
 {
 	struct sun6i_spi *sspi = spi_master_get_devdata(master);
 	unsigned int mclk_rate, div, timeout;
<span class="p_add">+	unsigned int start, end, tx_time;</span>
 	unsigned int tx_len = 0;
 	int ret = 0;
 	u32 reg;
<span class="p_chunk">@@ -269,9 +270,16 @@</span> <span class="p_context"> static int sun6i_spi_transfer_one(struct spi_master *master,</span>
 	reg = sun6i_spi_read(sspi, SUN6I_TFR_CTL_REG);
 	sun6i_spi_write(sspi, SUN6I_TFR_CTL_REG, reg | SUN6I_TFR_CTL_XCH);
 
<span class="p_add">+	tx_time = max(tfr-&gt;len * 8 * 2 / (tfr-&gt;speed_hz / 1000), 100U);</span>
<span class="p_add">+	start = jiffies;</span>
 	timeout = wait_for_completion_timeout(&amp;sspi-&gt;done,
<span class="p_del">-					      msecs_to_jiffies(1000));</span>
<span class="p_add">+					      msecs_to_jiffies(tx_time));</span>
<span class="p_add">+	end = jiffies;</span>
 	if (!timeout) {
<span class="p_add">+		dev_warn(&amp;master-&gt;dev,</span>
<span class="p_add">+			 &quot;%s: timeout transferring %u bytes@%iHz for %i(%i)ms&quot;,</span>
<span class="p_add">+			 dev_name(&amp;spi-&gt;dev), tfr-&gt;len, tfr-&gt;speed_hz,</span>
<span class="p_add">+			 jiffies_to_msecs(end - start), tx_time);</span>
 		ret = -ETIMEDOUT;
 		goto out;
 	}
<span class="p_header">diff --git a/drivers/staging/iio/accel/sca3000_core.c b/drivers/staging/iio/accel/sca3000_core.c</span>
<span class="p_header">index ed30e32e60de..3a6a56d62c9f 100644</span>
<span class="p_header">--- a/drivers/staging/iio/accel/sca3000_core.c</span>
<span class="p_header">+++ b/drivers/staging/iio/accel/sca3000_core.c</span>
<span class="p_chunk">@@ -619,7 +619,7 @@</span> <span class="p_context"> static ssize_t sca3000_read_frequency(struct device *dev,</span>
 		goto error_ret_mut;
 	ret = sca3000_read_ctrl_reg(st, SCA3000_REG_CTRL_SEL_OUT_CTRL);
 	mutex_unlock(&amp;st-&gt;lock);
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret &lt; 0)</span>
 		goto error_ret;
 	val = ret;
 	if (base_freq &gt; 0)
<span class="p_header">diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c</span>
<span class="p_header">index cdf72bcb3d78..2d7c57e11dd5 100644</span>
<span class="p_header">--- a/drivers/tty/n_tty.c</span>
<span class="p_header">+++ b/drivers/tty/n_tty.c</span>
<span class="p_chunk">@@ -2251,15 +2251,14 @@</span> <span class="p_context"> static ssize_t n_tty_read(struct tty_struct *tty, struct file *file,</span>
 			ldata-&gt;minimum_to_wake = (minimum - (b - buf));
 
 		if (!input_available_p(tty, 0)) {
<span class="p_del">-			if (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags)) {</span>
<span class="p_del">-				up_read(&amp;tty-&gt;termios_rwsem);</span>
<span class="p_del">-				tty_flush_to_ldisc(tty);</span>
<span class="p_del">-				down_read(&amp;tty-&gt;termios_rwsem);</span>
<span class="p_del">-				if (!input_available_p(tty, 0)) {</span>
<span class="p_add">+			up_read(&amp;tty-&gt;termios_rwsem);</span>
<span class="p_add">+			tty_flush_to_ldisc(tty);</span>
<span class="p_add">+			down_read(&amp;tty-&gt;termios_rwsem);</span>
<span class="p_add">+			if (!input_available_p(tty, 0)) {</span>
<span class="p_add">+				if (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags)) {</span>
 					retval = -EIO;
 					break;
 				}
<span class="p_del">-			} else {</span>
 				if (tty_hung_up_p(file))
 					break;
 				if (!timeout)
<span class="p_chunk">@@ -2465,17 +2464,17 @@</span> <span class="p_context"> static unsigned int n_tty_poll(struct tty_struct *tty, struct file *file,</span>
 
 	poll_wait(file, &amp;tty-&gt;read_wait, wait);
 	poll_wait(file, &amp;tty-&gt;write_wait, wait);
<span class="p_del">-	if (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags))</span>
<span class="p_del">-		mask |= POLLHUP;</span>
 	if (input_available_p(tty, 1))
 		mask |= POLLIN | POLLRDNORM;
<span class="p_del">-	else if (mask &amp; POLLHUP) {</span>
<span class="p_add">+	else {</span>
 		tty_flush_to_ldisc(tty);
 		if (input_available_p(tty, 1))
 			mask |= POLLIN | POLLRDNORM;
 	}
 	if (tty-&gt;packet &amp;&amp; tty-&gt;link-&gt;ctrl_status)
 		mask |= POLLPRI | POLLIN | POLLRDNORM;
<span class="p_add">+	if (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags))</span>
<span class="p_add">+		mask |= POLLHUP;</span>
 	if (tty_hung_up_p(file))
 		mask |= POLLHUP;
 	if (!(mask &amp; (POLLHUP | POLLIN | POLLRDNORM))) {
<span class="p_header">diff --git a/drivers/tty/vt/vt.c b/drivers/tty/vt/vt.c</span>
<span class="p_header">index 53c25bca7d05..9062636d3154 100644</span>
<span class="p_header">--- a/drivers/tty/vt/vt.c</span>
<span class="p_header">+++ b/drivers/tty/vt/vt.c</span>
<span class="p_chunk">@@ -3591,9 +3591,10 @@</span> <span class="p_context"> static int do_register_con_driver(const struct consw *csw, int first, int last)</span>
 		goto err;
 
 	desc = csw-&gt;con_startup();
<span class="p_del">-</span>
<span class="p_del">-	if (!desc)</span>
<span class="p_add">+	if (!desc) {</span>
<span class="p_add">+		retval = -ENODEV;</span>
 		goto err;
<span class="p_add">+	}</span>
 
 	retval = -EINVAL;
 
<span class="p_header">diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c</span>
<span class="p_header">index a85eadff6bea..dfcb5f8b8f18 100644</span>
<span class="p_header">--- a/drivers/usb/core/devio.c</span>
<span class="p_header">+++ b/drivers/usb/core/devio.c</span>
<span class="p_chunk">@@ -1202,10 +1202,11 @@</span> <span class="p_context"> static int proc_getdriver(struct usb_dev_state *ps, void __user *arg)</span>
 
 static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)
 {
<span class="p_del">-	struct usbdevfs_connectinfo ci = {</span>
<span class="p_del">-		.devnum = ps-&gt;dev-&gt;devnum,</span>
<span class="p_del">-		.slow = ps-&gt;dev-&gt;speed == USB_SPEED_LOW</span>
<span class="p_del">-	};</span>
<span class="p_add">+	struct usbdevfs_connectinfo ci;</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(&amp;ci, 0, sizeof(ci));</span>
<span class="p_add">+	ci.devnum = ps-&gt;dev-&gt;devnum;</span>
<span class="p_add">+	ci.slow = ps-&gt;dev-&gt;speed == USB_SPEED_LOW;</span>
 
 	if (copy_to_user(arg, &amp;ci, sizeof(ci)))
 		return -EFAULT;
<span class="p_header">diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c</span>
<span class="p_header">index c4dc63ad580a..7f2144eb58d9 100644</span>
<span class="p_header">--- a/drivers/usb/core/hcd.c</span>
<span class="p_header">+++ b/drivers/usb/core/hcd.c</span>
<span class="p_chunk">@@ -2518,24 +2518,22 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(usb_create_hcd);</span>
  * Don&#39;t deallocate the bandwidth_mutex until the last shared usb_hcd is
  * deallocated.
  *
<span class="p_del">- * Make sure to only deallocate the bandwidth_mutex when the primary HCD is</span>
<span class="p_del">- * freed.  When hcd_release() is called for either hcd in a peer set</span>
<span class="p_del">- * invalidate the peer&#39;s -&gt;shared_hcd and -&gt;primary_hcd pointers to</span>
<span class="p_del">- * block new peering attempts</span>
<span class="p_add">+ * Make sure to deallocate the bandwidth_mutex only when the last HCD is</span>
<span class="p_add">+ * freed.  When hcd_release() is called for either hcd in a peer set,</span>
<span class="p_add">+ * invalidate the peer&#39;s -&gt;shared_hcd and -&gt;primary_hcd pointers.</span>
  */
 static void hcd_release(struct kref *kref)
 {
 	struct usb_hcd *hcd = container_of (kref, struct usb_hcd, kref);
 
 	mutex_lock(&amp;usb_port_peer_mutex);
<span class="p_del">-	if (usb_hcd_is_primary_hcd(hcd))</span>
<span class="p_del">-		kfree(hcd-&gt;bandwidth_mutex);</span>
 	if (hcd-&gt;shared_hcd) {
 		struct usb_hcd *peer = hcd-&gt;shared_hcd;
 
 		peer-&gt;shared_hcd = NULL;
<span class="p_del">-		if (peer-&gt;primary_hcd == hcd)</span>
<span class="p_del">-			peer-&gt;primary_hcd = NULL;</span>
<span class="p_add">+		peer-&gt;primary_hcd = NULL;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		kfree(hcd-&gt;bandwidth_mutex);</span>
 	}
 	mutex_unlock(&amp;usb_port_peer_mutex);
 	kfree(hcd);
<span class="p_header">diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c</span>
<span class="p_header">index 0e8e656a045f..0673a5abc21d 100644</span>
<span class="p_header">--- a/drivers/usb/core/quirks.c</span>
<span class="p_header">+++ b/drivers/usb/core/quirks.c</span>
<span class="p_chunk">@@ -44,6 +44,9 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	/* Creative SB Audigy 2 NX */
 	{ USB_DEVICE(0x041e, 0x3020), .driver_info = USB_QUIRK_RESET_RESUME },
 
<span class="p_add">+	/* USB3503 */</span>
<span class="p_add">+	{ USB_DEVICE(0x0424, 0x3503), .driver_info = USB_QUIRK_RESET_RESUME },</span>
<span class="p_add">+</span>
 	/* Microsoft Wireless Laser Mouse 6000 Receiver */
 	{ USB_DEVICE(0x045e, 0x00e1), .driver_info = USB_QUIRK_RESET_RESUME },
 
<span class="p_chunk">@@ -167,6 +170,10 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	/* MAYA44USB sound device */
 	{ USB_DEVICE(0x0a92, 0x0091), .driver_info = USB_QUIRK_RESET_RESUME },
 
<span class="p_add">+	/* ASUS Base Station(T100) */</span>
<span class="p_add">+	{ USB_DEVICE(0x0b05, 0x17e0), .driver_info =</span>
<span class="p_add">+			USB_QUIRK_IGNORE_REMOTE_WAKEUP },</span>
<span class="p_add">+</span>
 	/* Action Semiconductor flash disk */
 	{ USB_DEVICE(0x10d6, 0x2200), .driver_info =
 			USB_QUIRK_STRING_FETCH_255 },
<span class="p_chunk">@@ -182,11 +189,12 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	{ USB_DEVICE(0x1908, 0x1315), .driver_info =
 			USB_QUIRK_HONOR_BNUMINTERFACES },
 
<span class="p_del">-	/* INTEL VALUE SSD */</span>
<span class="p_del">-	{ USB_DEVICE(0x8086, 0xf1a5), .driver_info = USB_QUIRK_RESET_RESUME },</span>
<span class="p_add">+	/* Protocol and OTG Electrical Test Device */</span>
<span class="p_add">+	{ USB_DEVICE(0x1a0a, 0x0200), .driver_info =</span>
<span class="p_add">+			USB_QUIRK_LINEAR_UFRAME_INTR_BINTERVAL },</span>
 
<span class="p_del">-	/* USB3503 */</span>
<span class="p_del">-	{ USB_DEVICE(0x0424, 0x3503), .driver_info = USB_QUIRK_RESET_RESUME },</span>
<span class="p_add">+	/* Acer C120 LED Projector */</span>
<span class="p_add">+	{ USB_DEVICE(0x1de1, 0xc102), .driver_info = USB_QUIRK_NO_LPM },</span>
 
 	/* Blackmagic Design Intensity Shuttle */
 	{ USB_DEVICE(0x1edb, 0xbd3b), .driver_info = USB_QUIRK_NO_LPM },
<span class="p_chunk">@@ -194,6 +202,9 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	/* Blackmagic Design UltraStudio SDI */
 	{ USB_DEVICE(0x1edb, 0xbd4f), .driver_info = USB_QUIRK_NO_LPM },
 
<span class="p_add">+	/* INTEL VALUE SSD */</span>
<span class="p_add">+	{ USB_DEVICE(0x8086, 0xf1a5), .driver_info = USB_QUIRK_RESET_RESUME },</span>
<span class="p_add">+</span>
 	{ }  /* terminating entry must be last */
 };
 
<span class="p_chunk">@@ -202,14 +213,6 @@</span> <span class="p_context"> static const struct usb_device_id usb_interface_quirk_list[] = {</span>
 	{ USB_VENDOR_AND_INTERFACE_INFO(0x046d, USB_CLASS_VIDEO, 1, 0),
 	  .driver_info = USB_QUIRK_RESET_RESUME },
 
<span class="p_del">-	/* ASUS Base Station(T100) */</span>
<span class="p_del">-	{ USB_DEVICE(0x0b05, 0x17e0), .driver_info =</span>
<span class="p_del">-			USB_QUIRK_IGNORE_REMOTE_WAKEUP },</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Protocol and OTG Electrical Test Device */</span>
<span class="p_del">-	{ USB_DEVICE(0x1a0a, 0x0200), .driver_info =</span>
<span class="p_del">-			USB_QUIRK_LINEAR_UFRAME_INTR_BINTERVAL },</span>
<span class="p_del">-</span>
 	{ }  /* terminating entry must be last */
 };
 
<span class="p_header">diff --git a/drivers/usb/dwc3/dwc3-exynos.c b/drivers/usb/dwc3/dwc3-exynos.c</span>
<span class="p_header">index f9fb8adb785b..abc334546156 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/dwc3-exynos.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/dwc3-exynos.c</span>
<span class="p_chunk">@@ -129,12 +129,6 @@</span> <span class="p_context"> static int dwc3_exynos_probe(struct platform_device *pdev)</span>
 
 	platform_set_drvdata(pdev, exynos);
 
<span class="p_del">-	ret = dwc3_exynos_register_phys(exynos);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		dev_err(dev, &quot;couldn&#39;t register PHYs\n&quot;);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	clk = devm_clk_get(dev, &quot;usbdrd30&quot;);
 	if (IS_ERR(clk)) {
 		dev_err(dev, &quot;couldn&#39;t get clock\n&quot;);
<span class="p_chunk">@@ -168,20 +162,29 @@</span> <span class="p_context"> static int dwc3_exynos_probe(struct platform_device *pdev)</span>
 		goto err3;
 	}
 
<span class="p_add">+	ret = dwc3_exynos_register_phys(exynos);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_err(dev, &quot;couldn&#39;t register PHYs\n&quot;);</span>
<span class="p_add">+		goto err4;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (node) {
 		ret = of_platform_populate(node, NULL, NULL, dev);
 		if (ret) {
 			dev_err(dev, &quot;failed to add dwc3 core\n&quot;);
<span class="p_del">-			goto err4;</span>
<span class="p_add">+			goto err5;</span>
 		}
 	} else {
 		dev_err(dev, &quot;no device node, failed to add dwc3 core\n&quot;);
 		ret = -ENODEV;
<span class="p_del">-		goto err4;</span>
<span class="p_add">+		goto err5;</span>
 	}
 
 	return 0;
 
<span class="p_add">+err5:</span>
<span class="p_add">+	platform_device_unregister(exynos-&gt;usb2_phy);</span>
<span class="p_add">+	platform_device_unregister(exynos-&gt;usb3_phy);</span>
 err4:
 	regulator_disable(exynos-&gt;vdd10);
 err3:
<span class="p_header">diff --git a/drivers/usb/gadget/f_fs.c b/drivers/usb/gadget/f_fs.c</span>
<span class="p_header">index 7a5167088de1..4d6c0630f1f9 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/f_fs.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/f_fs.c</span>
<span class="p_chunk">@@ -2355,7 +2355,8 @@</span> <span class="p_context"> static int _ffs_func_bind(struct usb_configuration *c,</span>
 	const int super = gadget_is_superspeed(func-&gt;gadget) &amp;&amp;
 		func-&gt;ffs-&gt;ss_descs_count;
 
<span class="p_del">-	int fs_len, hs_len, ret;</span>
<span class="p_add">+	int fs_len, hs_len, ret, i;</span>
<span class="p_add">+	struct ffs_ep *eps_ptr;</span>
 
 	/* Make it a single chunk, less management later on */
 	vla_group(d);
<span class="p_chunk">@@ -2388,12 +2389,9 @@</span> <span class="p_context"> static int _ffs_func_bind(struct usb_configuration *c,</span>
 	       ffs-&gt;raw_descs_length);
 
 	memset(vla_ptr(vlabuf, d, inums), 0xff, d_inums__sz);
<span class="p_del">-	for (ret = ffs-&gt;eps_count; ret; --ret) {</span>
<span class="p_del">-		struct ffs_ep *ptr;</span>
<span class="p_del">-</span>
<span class="p_del">-		ptr = vla_ptr(vlabuf, d, eps);</span>
<span class="p_del">-		ptr[ret].num = -1;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	eps_ptr = vla_ptr(vlabuf, d, eps);</span>
<span class="p_add">+	for (i = 0; i &lt; ffs-&gt;eps_count; i++)</span>
<span class="p_add">+		eps_ptr[i].num = -1;</span>
 
 	/* Save pointers
 	 * d_eps == vlabuf, func-&gt;eps used to kfree vlabuf later
<span class="p_header">diff --git a/drivers/usb/gadget/f_uac2.c b/drivers/usb/gadget/f_uac2.c</span>
<span class="p_header">index 6261db4a9910..a9a6341e866b 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/f_uac2.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/f_uac2.c</span>
<span class="p_chunk">@@ -1153,6 +1153,7 @@</span> <span class="p_context"> in_rq_cur(struct usb_function *fn, const struct usb_ctrlrequest *cr)</span>
 
 	if (control_selector == UAC2_CS_CONTROL_SAM_FREQ) {
 		struct cntrl_cur_lay3 c;
<span class="p_add">+		memset(&amp;c, 0, sizeof(struct cntrl_cur_lay3));</span>
 
 		if (entity_id == USB_IN_CLK_ID)
 			c.dCUR = p_srate;
<span class="p_header">diff --git a/drivers/usb/gadget/inode.c b/drivers/usb/gadget/inode.c</span>
<span class="p_header">index c44dc6ef2500..1ceaf0e6a859 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/inode.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/inode.c</span>
<span class="p_chunk">@@ -1010,8 +1010,11 @@</span> <span class="p_context"> ep0_read (struct file *fd, char __user *buf, size_t len, loff_t *ptr)</span>
 			struct usb_ep		*ep = dev-&gt;gadget-&gt;ep0;
 			struct usb_request	*req = dev-&gt;req;
 
<span class="p_del">-			if ((retval = setup_req (ep, req, 0)) == 0)</span>
<span class="p_del">-				retval = usb_ep_queue (ep, req, GFP_ATOMIC);</span>
<span class="p_add">+			if ((retval = setup_req (ep, req, 0)) == 0) {</span>
<span class="p_add">+				spin_unlock_irq (&amp;dev-&gt;lock);</span>
<span class="p_add">+				retval = usb_ep_queue (ep, req, GFP_KERNEL);</span>
<span class="p_add">+				spin_lock_irq (&amp;dev-&gt;lock);</span>
<span class="p_add">+			}</span>
 			dev-&gt;state = STATE_DEV_CONNECTED;
 
 			/* assume that was SET_CONFIGURATION */
<span class="p_chunk">@@ -1542,8 +1545,11 @@</span> <span class="p_context"> delegate:</span>
 							w_length);
 				if (value &lt; 0)
 					break;
<span class="p_add">+</span>
<span class="p_add">+				spin_unlock (&amp;dev-&gt;lock);</span>
 				value = usb_ep_queue (gadget-&gt;ep0, dev-&gt;req,
<span class="p_del">-							GFP_ATOMIC);</span>
<span class="p_add">+							GFP_KERNEL);</span>
<span class="p_add">+				spin_lock (&amp;dev-&gt;lock);</span>
 				if (value &lt; 0) {
 					clean_req (gadget-&gt;ep0, dev-&gt;req);
 					break;
<span class="p_chunk">@@ -1566,11 +1572,14 @@</span> <span class="p_context"> delegate:</span>
 	if (value &gt;= 0 &amp;&amp; dev-&gt;state != STATE_DEV_SETUP) {
 		req-&gt;length = value;
 		req-&gt;zero = value &lt; w_length;
<span class="p_del">-		value = usb_ep_queue (gadget-&gt;ep0, req, GFP_ATOMIC);</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_unlock (&amp;dev-&gt;lock);</span>
<span class="p_add">+		value = usb_ep_queue (gadget-&gt;ep0, req, GFP_KERNEL);</span>
 		if (value &lt; 0) {
 			DBG (dev, &quot;ep_queue --&gt; %d\n&quot;, value);
 			req-&gt;status = 0;
 		}
<span class="p_add">+		return value;</span>
 	}
 
 	/* device stalls when value &lt; 0 */
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index 3a8696c2c228..4b36d8562eef 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -30,6 +30,7 @@</span> <span class="p_context"></span>
 /* Device for a quirk */
 #define PCI_VENDOR_ID_FRESCO_LOGIC	0x1b73
 #define PCI_DEVICE_ID_FRESCO_LOGIC_PDK	0x1000
<span class="p_add">+#define PCI_DEVICE_ID_FRESCO_LOGIC_FL1009	0x1009</span>
 #define PCI_DEVICE_ID_FRESCO_LOGIC_FL1400	0x1400
 
 #define PCI_VENDOR_ID_ETRON		0x1b6f
<span class="p_chunk">@@ -99,6 +100,10 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 		xhci-&gt;quirks |= XHCI_TRUST_TX_LENGTH;
 	}
 
<span class="p_add">+	if (pdev-&gt;vendor == PCI_VENDOR_ID_FRESCO_LOGIC &amp;&amp;</span>
<span class="p_add">+			pdev-&gt;device == PCI_DEVICE_ID_FRESCO_LOGIC_FL1009)</span>
<span class="p_add">+		xhci-&gt;quirks |= XHCI_BROKEN_STREAMS;</span>
<span class="p_add">+</span>
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_NEC)
 		xhci-&gt;quirks |= XHCI_NEC_HOST;
 
<span class="p_header">diff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c</span>
<span class="p_header">index bbf86db713ce..b1e4031d081a 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-plat.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-plat.c</span>
<span class="p_chunk">@@ -154,6 +154,9 @@</span> <span class="p_context"> static int xhci_plat_probe(struct platform_device *pdev)</span>
 		ret = clk_prepare_enable(clk);
 		if (ret)
 			goto unmap_registers;
<span class="p_add">+	} else if (PTR_ERR(clk) == -EPROBE_DEFER) {</span>
<span class="p_add">+		ret = -EPROBE_DEFER;</span>
<span class="p_add">+		goto unmap_registers;</span>
 	}
 
 	if (of_device_is_compatible(pdev-&gt;dev.of_node,
<span class="p_header">diff --git a/drivers/usb/musb/musb_host.c b/drivers/usb/musb/musb_host.c</span>
<span class="p_header">index 0ae35ab5c392..2314186738ba 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musb_host.c</span>
<span class="p_header">+++ b/drivers/usb/musb/musb_host.c</span>
<span class="p_chunk">@@ -583,14 +583,13 @@</span> <span class="p_context"> musb_rx_reinit(struct musb *musb, struct musb_qh *qh, struct musb_hw_ep *ep)</span>
 		musb_writew(ep-&gt;regs, MUSB_TXCSR, 0);
 
 	/* scrub all previous state, clearing toggle */
<span class="p_del">-	} else {</span>
<span class="p_del">-		csr = musb_readw(ep-&gt;regs, MUSB_RXCSR);</span>
<span class="p_del">-		if (csr &amp; MUSB_RXCSR_RXPKTRDY)</span>
<span class="p_del">-			WARNING(&quot;rx%d, packet/%d ready?\n&quot;, ep-&gt;epnum,</span>
<span class="p_del">-				musb_readw(ep-&gt;regs, MUSB_RXCOUNT));</span>
<span class="p_del">-</span>
<span class="p_del">-		musb_h_flush_rxfifo(ep, MUSB_RXCSR_CLRDATATOG);</span>
 	}
<span class="p_add">+	csr = musb_readw(ep-&gt;regs, MUSB_RXCSR);</span>
<span class="p_add">+	if (csr &amp; MUSB_RXCSR_RXPKTRDY)</span>
<span class="p_add">+		WARNING(&quot;rx%d, packet/%d ready?\n&quot;, ep-&gt;epnum,</span>
<span class="p_add">+			musb_readw(ep-&gt;regs, MUSB_RXCOUNT));</span>
<span class="p_add">+</span>
<span class="p_add">+	musb_h_flush_rxfifo(ep, MUSB_RXCSR_CLRDATATOG);</span>
 
 	/* target addr and (for multipoint) hub addr/port */
 	if (musb-&gt;is_multipoint) {
<span class="p_chunk">@@ -950,9 +949,15 @@</span> <span class="p_context"> static void musb_bulk_nak_timeout(struct musb *musb, struct musb_hw_ep *ep,</span>
 	if (is_in) {
 		dma = is_dma_capable() ? ep-&gt;rx_channel : NULL;
 
<span class="p_del">-		/* clear nak timeout bit */</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Need to stop the transaction by clearing REQPKT first</span>
<span class="p_add">+		 * then the NAK Timeout bit ref MUSBMHDRC USB 2.0 HIGH-SPEED</span>
<span class="p_add">+		 * DUAL-ROLE CONTROLLER Programmer&#39;s Guide, section 9.2.2</span>
<span class="p_add">+		 */</span>
 		rx_csr = musb_readw(epio, MUSB_RXCSR);
 		rx_csr |= MUSB_RXCSR_H_WZC_BITS;
<span class="p_add">+		rx_csr &amp;= ~MUSB_RXCSR_H_REQPKT;</span>
<span class="p_add">+		musb_writew(epio, MUSB_RXCSR, rx_csr);</span>
 		rx_csr &amp;= ~MUSB_RXCSR_DATAERROR;
 		musb_writew(epio, MUSB_RXCSR, rx_csr);
 
<span class="p_header">diff --git a/drivers/usb/serial/io_edgeport.c b/drivers/usb/serial/io_edgeport.c</span>
<span class="p_header">index c0866971db2b..1947ea0e0988 100644</span>
<span class="p_header">--- a/drivers/usb/serial/io_edgeport.c</span>
<span class="p_header">+++ b/drivers/usb/serial/io_edgeport.c</span>
<span class="p_chunk">@@ -2856,14 +2856,16 @@</span> <span class="p_context"> static int edge_startup(struct usb_serial *serial)</span>
 				/* not set up yet, so do it now */
 				edge_serial-&gt;interrupt_read_urb =
 						usb_alloc_urb(0, GFP_KERNEL);
<span class="p_del">-				if (!edge_serial-&gt;interrupt_read_urb)</span>
<span class="p_del">-					return -ENOMEM;</span>
<span class="p_add">+				if (!edge_serial-&gt;interrupt_read_urb) {</span>
<span class="p_add">+					response = -ENOMEM;</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
 
 				edge_serial-&gt;interrupt_in_buffer =
 					kmalloc(buffer_size, GFP_KERNEL);
 				if (!edge_serial-&gt;interrupt_in_buffer) {
<span class="p_del">-					usb_free_urb(edge_serial-&gt;interrupt_read_urb);</span>
<span class="p_del">-					return -ENOMEM;</span>
<span class="p_add">+					response = -ENOMEM;</span>
<span class="p_add">+					break;</span>
 				}
 				edge_serial-&gt;interrupt_in_endpoint =
 						endpoint-&gt;bEndpointAddress;
<span class="p_chunk">@@ -2891,14 +2893,16 @@</span> <span class="p_context"> static int edge_startup(struct usb_serial *serial)</span>
 				/* not set up yet, so do it now */
 				edge_serial-&gt;read_urb =
 						usb_alloc_urb(0, GFP_KERNEL);
<span class="p_del">-				if (!edge_serial-&gt;read_urb)</span>
<span class="p_del">-					return -ENOMEM;</span>
<span class="p_add">+				if (!edge_serial-&gt;read_urb) {</span>
<span class="p_add">+					response = -ENOMEM;</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
 
 				edge_serial-&gt;bulk_in_buffer =
 					kmalloc(buffer_size, GFP_KERNEL);
 				if (!edge_serial-&gt;bulk_in_buffer) {
<span class="p_del">-					usb_free_urb(edge_serial-&gt;read_urb);</span>
<span class="p_del">-					return -ENOMEM;</span>
<span class="p_add">+					response = -ENOMEM;</span>
<span class="p_add">+					break;</span>
 				}
 				edge_serial-&gt;bulk_in_endpoint =
 						endpoint-&gt;bEndpointAddress;
<span class="p_chunk">@@ -2924,9 +2928,22 @@</span> <span class="p_context"> static int edge_startup(struct usb_serial *serial)</span>
 			}
 		}
 
<span class="p_del">-		if (!interrupt_in_found || !bulk_in_found || !bulk_out_found) {</span>
<span class="p_del">-			dev_err(ddev, &quot;Error - the proper endpoints were not found!\n&quot;);</span>
<span class="p_del">-			return -ENODEV;</span>
<span class="p_add">+		if (response || !interrupt_in_found || !bulk_in_found ||</span>
<span class="p_add">+							!bulk_out_found) {</span>
<span class="p_add">+			if (!response) {</span>
<span class="p_add">+				dev_err(ddev, &quot;expected endpoints not found\n&quot;);</span>
<span class="p_add">+				response = -ENODEV;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			usb_free_urb(edge_serial-&gt;interrupt_read_urb);</span>
<span class="p_add">+			kfree(edge_serial-&gt;interrupt_in_buffer);</span>
<span class="p_add">+</span>
<span class="p_add">+			usb_free_urb(edge_serial-&gt;read_urb);</span>
<span class="p_add">+			kfree(edge_serial-&gt;bulk_in_buffer);</span>
<span class="p_add">+</span>
<span class="p_add">+			kfree(edge_serial);</span>
<span class="p_add">+</span>
<span class="p_add">+			return response;</span>
 		}
 
 		/* start interrupt read for this edgeport this interrupt will
<span class="p_chunk">@@ -2949,16 +2966,9 @@</span> <span class="p_context"> static void edge_disconnect(struct usb_serial *serial)</span>
 {
 	struct edgeport_serial *edge_serial = usb_get_serial_data(serial);
 
<span class="p_del">-	/* stop reads and writes on all ports */</span>
<span class="p_del">-	/* free up our endpoint stuff */</span>
 	if (edge_serial-&gt;is_epic) {
 		usb_kill_urb(edge_serial-&gt;interrupt_read_urb);
<span class="p_del">-		usb_free_urb(edge_serial-&gt;interrupt_read_urb);</span>
<span class="p_del">-		kfree(edge_serial-&gt;interrupt_in_buffer);</span>
<span class="p_del">-</span>
 		usb_kill_urb(edge_serial-&gt;read_urb);
<span class="p_del">-		usb_free_urb(edge_serial-&gt;read_urb);</span>
<span class="p_del">-		kfree(edge_serial-&gt;bulk_in_buffer);</span>
 	}
 }
 
<span class="p_chunk">@@ -2971,6 +2981,16 @@</span> <span class="p_context"> static void edge_release(struct usb_serial *serial)</span>
 {
 	struct edgeport_serial *edge_serial = usb_get_serial_data(serial);
 
<span class="p_add">+	if (edge_serial-&gt;is_epic) {</span>
<span class="p_add">+		usb_kill_urb(edge_serial-&gt;interrupt_read_urb);</span>
<span class="p_add">+		usb_free_urb(edge_serial-&gt;interrupt_read_urb);</span>
<span class="p_add">+		kfree(edge_serial-&gt;interrupt_in_buffer);</span>
<span class="p_add">+</span>
<span class="p_add">+		usb_kill_urb(edge_serial-&gt;read_urb);</span>
<span class="p_add">+		usb_free_urb(edge_serial-&gt;read_urb);</span>
<span class="p_add">+		kfree(edge_serial-&gt;bulk_in_buffer);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	kfree(edge_serial);
 }
 
<span class="p_header">diff --git a/drivers/usb/serial/keyspan.c b/drivers/usb/serial/keyspan.c</span>
<span class="p_header">index e07b15ed5814..7faa901ee47f 100644</span>
<span class="p_header">--- a/drivers/usb/serial/keyspan.c</span>
<span class="p_header">+++ b/drivers/usb/serial/keyspan.c</span>
<span class="p_chunk">@@ -2376,6 +2376,10 @@</span> <span class="p_context"> static void keyspan_release(struct usb_serial *serial)</span>
 
 	s_priv = usb_get_serial_data(serial);
 
<span class="p_add">+	/* Make sure to unlink the URBs submitted in attach. */</span>
<span class="p_add">+	usb_kill_urb(s_priv-&gt;instat_urb);</span>
<span class="p_add">+	usb_kill_urb(s_priv-&gt;indat_urb);</span>
<span class="p_add">+</span>
 	usb_free_urb(s_priv-&gt;instat_urb);
 	usb_free_urb(s_priv-&gt;indat_urb);
 	usb_free_urb(s_priv-&gt;glocont_urb);
<span class="p_header">diff --git a/drivers/usb/serial/mxuport.c b/drivers/usb/serial/mxuport.c</span>
<span class="p_header">index 460a40669967..d029b2fc0f75 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mxuport.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mxuport.c</span>
<span class="p_chunk">@@ -1263,6 +1263,15 @@</span> <span class="p_context"> static int mxuport_attach(struct usb_serial *serial)</span>
 	return 0;
 }
 
<span class="p_add">+static void mxuport_release(struct usb_serial *serial)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct usb_serial_port *port0 = serial-&gt;port[0];</span>
<span class="p_add">+	struct usb_serial_port *port1 = serial-&gt;port[1];</span>
<span class="p_add">+</span>
<span class="p_add">+	usb_serial_generic_close(port1);</span>
<span class="p_add">+	usb_serial_generic_close(port0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int mxuport_open(struct tty_struct *tty, struct usb_serial_port *port)
 {
 	struct mxuport_port *mxport = usb_get_serial_port_data(port);
<span class="p_chunk">@@ -1365,6 +1374,7 @@</span> <span class="p_context"> static struct usb_serial_driver mxuport_device = {</span>
 	.probe			= mxuport_probe,
 	.port_probe		= mxuport_port_probe,
 	.attach			= mxuport_attach,
<span class="p_add">+	.release		= mxuport_release,</span>
 	.calc_num_ports		= mxuport_calc_num_ports,
 	.open			= mxuport_open,
 	.close			= mxuport_close,
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 1f3c11972d36..9d8fe3d2feca 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -377,18 +377,22 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define HAIER_PRODUCT_CE81B			0x10f8
 #define HAIER_PRODUCT_CE100			0x2009
 
<span class="p_del">-/* Cinterion (formerly Siemens) products */</span>
<span class="p_del">-#define SIEMENS_VENDOR_ID				0x0681</span>
<span class="p_del">-#define CINTERION_VENDOR_ID				0x1e2d</span>
<span class="p_add">+/* Gemalto&#39;s Cinterion products (formerly Siemens) */</span>
<span class="p_add">+#define SIEMENS_VENDOR_ID			0x0681</span>
<span class="p_add">+#define CINTERION_VENDOR_ID			0x1e2d</span>
<span class="p_add">+#define CINTERION_PRODUCT_HC25_MDMNET		0x0040</span>
 #define CINTERION_PRODUCT_HC25_MDM		0x0047
<span class="p_del">-#define CINTERION_PRODUCT_HC25_MDMNET	0x0040</span>
<span class="p_add">+#define CINTERION_PRODUCT_HC28_MDMNET		0x004A /* same for HC28J */</span>
 #define CINTERION_PRODUCT_HC28_MDM		0x004C
<span class="p_del">-#define CINTERION_PRODUCT_HC28_MDMNET	0x004A /* same for HC28J */</span>
 #define CINTERION_PRODUCT_EU3_E			0x0051
 #define CINTERION_PRODUCT_EU3_P			0x0052
 #define CINTERION_PRODUCT_PH8			0x0053
 #define CINTERION_PRODUCT_AHXX			0x0055
 #define CINTERION_PRODUCT_PLXX			0x0060
<span class="p_add">+#define CINTERION_PRODUCT_PH8_2RMNET		0x0082</span>
<span class="p_add">+#define CINTERION_PRODUCT_PH8_AUDIO		0x0083</span>
<span class="p_add">+#define CINTERION_PRODUCT_AHXX_2RMNET		0x0084</span>
<span class="p_add">+#define CINTERION_PRODUCT_AHXX_AUDIO		0x0085</span>
 
 /* Olivetti products */
 #define OLIVETTI_VENDOR_ID			0x0b3c
<span class="p_chunk">@@ -648,6 +652,10 @@</span> <span class="p_context"> static const struct option_blacklist_info telit_le922_blacklist_usbcfg3 = {</span>
 	.reserved = BIT(1) | BIT(2) | BIT(3),
 };
 
<span class="p_add">+static const struct option_blacklist_info cinterion_rmnet2_blacklist = {</span>
<span class="p_add">+	.reserved = BIT(4) | BIT(5),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) },
<span class="p_chunk">@@ -1621,7 +1629,79 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 		.driver_info = (kernel_ulong_t)&amp;net_intf3_blacklist },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff),
 		.driver_info = (kernel_ulong_t)&amp;net_intf3_blacklist },
<span class="p_del">-	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffe9, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff42, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff43, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff44, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff45, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff46, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff47, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff48, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff49, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff4a, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff4b, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff4c, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff4d, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff4e, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff4f, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff50, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff51, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff52, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff53, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff54, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff55, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff56, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff57, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff58, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff59, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff5a, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff5b, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff5c, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff5d, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff5e, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff5f, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff60, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff61, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff62, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff63, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff64, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff65, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff66, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff67, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff68, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff69, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff6a, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff6b, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff6c, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff6d, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff6e, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff6f, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff70, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff71, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff72, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff73, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff74, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff75, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff76, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff77, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff78, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff79, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff7a, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff7b, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff7c, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff7d, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff7e, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff7f, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff80, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff81, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff82, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff83, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff84, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff85, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff86, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff87, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff88, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff89, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff8a, 0xff, 0xff, 0xff) },</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff8b, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff8c, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff8d, 0xff, 0xff, 0xff) },
<span class="p_chunk">@@ -1632,6 +1712,61 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff92, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff93, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff94, 0xff, 0xff, 0xff) },
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff9f, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa0, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa1, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa2, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa3, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa4, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa5, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa6, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa7, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa8, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa9, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffaa, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffab, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffac, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffae, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffaf, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb0, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb1, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb2, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb3, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb4, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb5, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb6, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb7, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb8, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb9, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffba, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffbb, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffbc, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffbd, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffbe, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffbf, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc0, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc1, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc2, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc3, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc4, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc5, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc6, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc7, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc8, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc9, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffca, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffcb, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffcc, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffcd, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffce, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffcf, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffd0, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffd1, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffd2, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffd3, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffd4, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffd5, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffe9, 0xff, 0xff, 0xff) },</span>
 
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_CDMA_TECH, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_AC2726, 0xff, 0xff, 0xff) },
<span class="p_chunk">@@ -1723,7 +1858,13 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_AHXX, 0xff) },
 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_PLXX),
 		.driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
<span class="p_del">-	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_HC28_MDM) }, </span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_PH8_2RMNET, 0xff),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;cinterion_rmnet2_blacklist },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_PH8_AUDIO, 0xff),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_AHXX_2RMNET, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_AHXX_AUDIO, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_HC28_MDM) },</span>
 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_HC28_MDMNET) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, CINTERION_PRODUCT_HC25_MDM) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, CINTERION_PRODUCT_HC25_MDMNET) },
<span class="p_header">diff --git a/drivers/usb/serial/quatech2.c b/drivers/usb/serial/quatech2.c</span>
<span class="p_header">index 504f5bff79c0..b18974cbd995 100644</span>
<span class="p_header">--- a/drivers/usb/serial/quatech2.c</span>
<span class="p_header">+++ b/drivers/usb/serial/quatech2.c</span>
<span class="p_chunk">@@ -141,6 +141,7 @@</span> <span class="p_context"> static void qt2_release(struct usb_serial *serial)</span>
 
 	serial_priv = usb_get_serial_data(serial);
 
<span class="p_add">+	usb_kill_urb(serial_priv-&gt;read_urb);</span>
 	usb_free_urb(serial_priv-&gt;read_urb);
 	kfree(serial_priv-&gt;read_buffer);
 	kfree(serial_priv);
<span class="p_header">diff --git a/drivers/xen/events/events_base.c b/drivers/xen/events/events_base.c</span>
<span class="p_header">index 6be0ef01b8e6..b254b7d20dfa 100644</span>
<span class="p_header">--- a/drivers/xen/events/events_base.c</span>
<span class="p_header">+++ b/drivers/xen/events/events_base.c</span>
<span class="p_chunk">@@ -486,7 +486,8 @@</span> <span class="p_context"> static void eoi_pirq(struct irq_data *data)</span>
 	if (!VALID_EVTCHN(evtchn))
 		return;
 
<span class="p_del">-	if (unlikely(irqd_is_setaffinity_pending(data))) {</span>
<span class="p_add">+	if (unlikely(irqd_is_setaffinity_pending(data)) &amp;&amp;</span>
<span class="p_add">+	    likely(!irqd_irq_disabled(data))) {</span>
 		int masked = test_and_set_mask(evtchn);
 
 		clear_evtchn(evtchn);
<span class="p_chunk">@@ -1372,7 +1373,8 @@</span> <span class="p_context"> static void ack_dynirq(struct irq_data *data)</span>
 	if (!VALID_EVTCHN(evtchn))
 		return;
 
<span class="p_del">-	if (unlikely(irqd_is_setaffinity_pending(data))) {</span>
<span class="p_add">+	if (unlikely(irqd_is_setaffinity_pending(data)) &amp;&amp;</span>
<span class="p_add">+	    likely(!irqd_irq_disabled(data))) {</span>
 		int masked = test_and_set_mask(evtchn);
 
 		clear_evtchn(evtchn);
<span class="p_header">diff --git a/drivers/xen/xen-acpi-processor.c b/drivers/xen/xen-acpi-processor.c</span>
<span class="p_header">index 59fc190f1e92..b96e207bf250 100644</span>
<span class="p_header">--- a/drivers/xen/xen-acpi-processor.c</span>
<span class="p_header">+++ b/drivers/xen/xen-acpi-processor.c</span>
<span class="p_chunk">@@ -423,36 +423,7 @@</span> <span class="p_context"> upload:</span>
 
 	return 0;
 }
<span class="p_del">-static int __init check_prereq(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct cpuinfo_x86 *c = &amp;cpu_data(0);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!xen_initial_domain())</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!acpi_gbl_FADT.smi_command)</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (c-&gt;x86_vendor == X86_VENDOR_INTEL) {</span>
<span class="p_del">-		if (!cpu_has(c, X86_FEATURE_EST))</span>
<span class="p_del">-			return -ENODEV;</span>
 
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (c-&gt;x86_vendor == X86_VENDOR_AMD) {</span>
<span class="p_del">-		/* Copied from powernow-k8.h, can&#39;t include ../cpufreq/powernow</span>
<span class="p_del">-		 * as we get compile warnings for the static functions.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-#define CPUID_FREQ_VOLT_CAPABILITIES    0x80000007</span>
<span class="p_del">-#define USE_HW_PSTATE                   0x00000080</span>
<span class="p_del">-		u32 eax, ebx, ecx, edx;</span>
<span class="p_del">-		cpuid(CPUID_FREQ_VOLT_CAPABILITIES, &amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_del">-		if ((edx &amp; USE_HW_PSTATE) != USE_HW_PSTATE)</span>
<span class="p_del">-			return -ENODEV;</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return -ENODEV;</span>
<span class="p_del">-}</span>
 /* acpi_perf_data is a pointer to percpu data. */
 static struct acpi_processor_performance __percpu *acpi_perf_data;
 
<span class="p_chunk">@@ -509,10 +480,10 @@</span> <span class="p_context"> struct notifier_block xen_acpi_processor_resume_nb = {</span>
 static int __init xen_acpi_processor_init(void)
 {
 	unsigned int i;
<span class="p_del">-	int rc = check_prereq();</span>
<span class="p_add">+	int rc;</span>
 
<span class="p_del">-	if (rc)</span>
<span class="p_del">-		return rc;</span>
<span class="p_add">+	if (!xen_initial_domain())</span>
<span class="p_add">+		return -ENODEV;</span>
 
 	nr_acpi_bits = get_max_acpi_id() + 1;
 	acpi_ids_done = kcalloc(BITS_TO_LONGS(nr_acpi_bits), sizeof(unsigned long), GFP_KERNEL);
<span class="p_header">diff --git a/drivers/xen/xen-pciback/conf_space.c b/drivers/xen/xen-pciback/conf_space.c</span>
<span class="p_header">index 9c234209d8b5..47a4177b16d2 100644</span>
<span class="p_header">--- a/drivers/xen/xen-pciback/conf_space.c</span>
<span class="p_header">+++ b/drivers/xen/xen-pciback/conf_space.c</span>
<span class="p_chunk">@@ -183,8 +183,7 @@</span> <span class="p_context"> int xen_pcibk_config_read(struct pci_dev *dev, int offset, int size,</span>
 		field_start = OFFSET(cfg_entry);
 		field_end = OFFSET(cfg_entry) + field-&gt;size;
 
<span class="p_del">-		if ((req_start &gt;= field_start &amp;&amp; req_start &lt; field_end)</span>
<span class="p_del">-		    || (req_end &gt; field_start &amp;&amp; req_end &lt;= field_end)) {</span>
<span class="p_add">+		 if (req_end &gt; field_start &amp;&amp; field_end &gt; req_start) {</span>
 			err = conf_space_read(dev, cfg_entry, field_start,
 					      &amp;tmp_val);
 			if (err)
<span class="p_chunk">@@ -230,8 +229,7 @@</span> <span class="p_context"> int xen_pcibk_config_write(struct pci_dev *dev, int offset, int size, u32 value)</span>
 		field_start = OFFSET(cfg_entry);
 		field_end = OFFSET(cfg_entry) + field-&gt;size;
 
<span class="p_del">-		if ((req_start &gt;= field_start &amp;&amp; req_start &lt; field_end)</span>
<span class="p_del">-		    || (req_end &gt; field_start &amp;&amp; req_end &lt;= field_end)) {</span>
<span class="p_add">+		 if (req_end &gt; field_start &amp;&amp; field_end &gt; req_start) {</span>
 			tmp_val = 0;
 
 			err = xen_pcibk_config_read(dev, field_start,
<span class="p_header">diff --git a/drivers/xen/xenbus/xenbus_xs.c b/drivers/xen/xenbus/xenbus_xs.c</span>
<span class="p_header">index ba804f3d8278..ce65591b4168 100644</span>
<span class="p_header">--- a/drivers/xen/xenbus/xenbus_xs.c</span>
<span class="p_header">+++ b/drivers/xen/xenbus/xenbus_xs.c</span>
<span class="p_chunk">@@ -250,9 +250,6 @@</span> <span class="p_context"> void *xenbus_dev_request_and_reply(struct xsd_sockmsg *msg)</span>
 
 	mutex_unlock(&amp;xs_state.request_mutex);
 
<span class="p_del">-	if (IS_ERR(ret))</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
 	if ((msg-&gt;type == XS_TRANSACTION_END) ||
 	    ((req_msg.type == XS_TRANSACTION_START) &amp;&amp;
 	     (msg-&gt;type == XS_ERROR)))
<span class="p_header">diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.h</span>
<span class="p_header">index efb0b8953fa5..796f1d2374ff 100644</span>
<span class="p_header">--- a/fs/btrfs/ctree.h</span>
<span class="p_header">+++ b/fs/btrfs/ctree.h</span>
<span class="p_chunk">@@ -3876,6 +3876,7 @@</span> <span class="p_context"> extern const struct dentry_operations btrfs_dentry_operations;</span>
 
 /* ioctl.c */
 long btrfs_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
<span class="p_add">+long btrfs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg);</span>
 void btrfs_update_iflags(struct inode *inode);
 void btrfs_inherit_iflags(struct inode *inode, struct inode *dir);
 int btrfs_is_empty_uuid(u8 *uuid);
<span class="p_header">diff --git a/fs/btrfs/file.c b/fs/btrfs/file.c</span>
<span class="p_header">index 8d60cf519578..085a90d0d2e4 100644</span>
<span class="p_header">--- a/fs/btrfs/file.c</span>
<span class="p_header">+++ b/fs/btrfs/file.c</span>
<span class="p_chunk">@@ -2739,7 +2739,7 @@</span> <span class="p_context"> const struct file_operations btrfs_file_operations = {</span>
 	.fallocate	= btrfs_fallocate,
 	.unlocked_ioctl	= btrfs_ioctl,
 #ifdef CONFIG_COMPAT
<span class="p_del">-	.compat_ioctl	= btrfs_ioctl,</span>
<span class="p_add">+	.compat_ioctl	= btrfs_compat_ioctl,</span>
 #endif
 };
 
<span class="p_header">diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c</span>
<span class="p_header">index 17472ba1615c..a09ec5e7f3e2 100644</span>
<span class="p_header">--- a/fs/btrfs/inode.c</span>
<span class="p_header">+++ b/fs/btrfs/inode.c</span>
<span class="p_chunk">@@ -9102,7 +9102,7 @@</span> <span class="p_context"> static const struct file_operations btrfs_dir_file_operations = {</span>
 	.iterate	= btrfs_real_readdir,
 	.unlocked_ioctl	= btrfs_ioctl,
 #ifdef CONFIG_COMPAT
<span class="p_del">-	.compat_ioctl	= btrfs_ioctl,</span>
<span class="p_add">+	.compat_ioctl	= btrfs_compat_ioctl,</span>
 #endif
 	.release        = btrfs_release_file,
 	.fsync		= btrfs_sync_file,
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index d0733078e5c5..b69285f0593b 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -5520,3 +5520,24 @@</span> <span class="p_context"> long btrfs_ioctl(struct file *file, unsigned int</span>
 
 	return -ENOTTY;
 }
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_COMPAT</span>
<span class="p_add">+long btrfs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (cmd) {</span>
<span class="p_add">+	case FS_IOC32_GETFLAGS:</span>
<span class="p_add">+		cmd = FS_IOC_GETFLAGS;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case FS_IOC32_SETFLAGS:</span>
<span class="p_add">+		cmd = FS_IOC_SETFLAGS;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case FS_IOC32_GETVERSION:</span>
<span class="p_add">+		cmd = FS_IOC_GETVERSION;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return -ENOIOCTLCMD;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return btrfs_ioctl(file, cmd, (unsigned long) compat_ptr(arg));</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/fs/cifs/cifs_spnego.c b/fs/cifs/cifs_spnego.c</span>
<span class="p_header">index a3e932547617..2f5a7e0103d0 100644</span>
<span class="p_header">--- a/fs/cifs/cifs_spnego.c</span>
<span class="p_header">+++ b/fs/cifs/cifs_spnego.c</span>
<span class="p_chunk">@@ -24,10 +24,13 @@</span> <span class="p_context"></span>
 #include &lt;linux/string.h&gt;
 #include &lt;keys/user-type.h&gt;
 #include &lt;linux/key-type.h&gt;
<span class="p_add">+#include &lt;linux/keyctl.h&gt;</span>
 #include &lt;linux/inet.h&gt;
 #include &quot;cifsglob.h&quot;
 #include &quot;cifs_spnego.h&quot;
 #include &quot;cifs_debug.h&quot;
<span class="p_add">+#include &quot;cifsproto.h&quot;</span>
<span class="p_add">+static const struct cred *spnego_cred;</span>
 
 /* create a new cifs key */
 static int
<span class="p_chunk">@@ -103,6 +106,7 @@</span> <span class="p_context"> cifs_get_spnego_key(struct cifs_ses *sesInfo)</span>
 	size_t desc_len;
 	struct key *spnego_key;
 	const char *hostname = server-&gt;hostname;
<span class="p_add">+	const struct cred *saved_cred;</span>
 
 	/* length of fields (with semicolons): ver=0xyz ip4=ipaddress
 	   host=hostname sec=mechanism uid=0xFF user=username */
<span class="p_chunk">@@ -164,7 +168,9 @@</span> <span class="p_context"> cifs_get_spnego_key(struct cifs_ses *sesInfo)</span>
 	sprintf(dp, &quot;;pid=0x%x&quot;, current-&gt;pid);
 
 	cifs_dbg(FYI, &quot;key description = %s\n&quot;, description);
<span class="p_add">+	saved_cred = override_creds(spnego_cred);</span>
 	spnego_key = request_key(&amp;cifs_spnego_key_type, description, &quot;&quot;);
<span class="p_add">+	revert_creds(saved_cred);</span>
 
 #ifdef CONFIG_CIFS_DEBUG2
 	if (cifsFYI &amp;&amp; !IS_ERR(spnego_key)) {
<span class="p_chunk">@@ -178,3 +184,64 @@</span> <span class="p_context"> out:</span>
 	kfree(description);
 	return spnego_key;
 }
<span class="p_add">+</span>
<span class="p_add">+int</span>
<span class="p_add">+init_cifs_spnego(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cred *cred;</span>
<span class="p_add">+	struct key *keyring;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	cifs_dbg(FYI, &quot;Registering the %s key type\n&quot;,</span>
<span class="p_add">+		 cifs_spnego_key_type.name);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Create an override credential set with special thread keyring for</span>
<span class="p_add">+	 * spnego upcalls.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	cred = prepare_kernel_cred(NULL);</span>
<span class="p_add">+	if (!cred)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	keyring = keyring_alloc(&quot;.cifs_spnego&quot;,</span>
<span class="p_add">+				GLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,</span>
<span class="p_add">+				(KEY_POS_ALL &amp; ~KEY_POS_SETATTR) |</span>
<span class="p_add">+				KEY_USR_VIEW | KEY_USR_READ,</span>
<span class="p_add">+				KEY_ALLOC_NOT_IN_QUOTA, NULL);</span>
<span class="p_add">+	if (IS_ERR(keyring)) {</span>
<span class="p_add">+		ret = PTR_ERR(keyring);</span>
<span class="p_add">+		goto failed_put_cred;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = register_key_type(&amp;cifs_spnego_key_type);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		goto failed_put_key;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * instruct request_key() to use this special keyring as a cache for</span>
<span class="p_add">+	 * the results it looks up</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	set_bit(KEY_FLAG_ROOT_CAN_CLEAR, &amp;keyring-&gt;flags);</span>
<span class="p_add">+	cred-&gt;thread_keyring = keyring;</span>
<span class="p_add">+	cred-&gt;jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;</span>
<span class="p_add">+	spnego_cred = cred;</span>
<span class="p_add">+</span>
<span class="p_add">+	cifs_dbg(FYI, &quot;cifs spnego keyring: %d\n&quot;, key_serial(keyring));</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+failed_put_key:</span>
<span class="p_add">+	key_put(keyring);</span>
<span class="p_add">+failed_put_cred:</span>
<span class="p_add">+	put_cred(cred);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void</span>
<span class="p_add">+exit_cifs_spnego(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	key_revoke(spnego_cred-&gt;thread_keyring);</span>
<span class="p_add">+	unregister_key_type(&amp;cifs_spnego_key_type);</span>
<span class="p_add">+	put_cred(spnego_cred);</span>
<span class="p_add">+	cifs_dbg(FYI, &quot;Unregistered %s key type\n&quot;, cifs_spnego_key_type.name);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c</span>
<span class="p_header">index d678cda1cd81..445e1b01191a 100644</span>
<span class="p_header">--- a/fs/cifs/cifsfs.c</span>
<span class="p_header">+++ b/fs/cifs/cifsfs.c</span>
<span class="p_chunk">@@ -1228,7 +1228,7 @@</span> <span class="p_context"> init_cifs(void)</span>
 		goto out_destroy_mids;
 
 #ifdef CONFIG_CIFS_UPCALL
<span class="p_del">-	rc = register_key_type(&amp;cifs_spnego_key_type);</span>
<span class="p_add">+	rc = init_cifs_spnego();</span>
 	if (rc)
 		goto out_destroy_request_bufs;
 #endif /* CONFIG_CIFS_UPCALL */
<span class="p_chunk">@@ -1251,7 +1251,7 @@</span> <span class="p_context"> out_init_cifs_idmap:</span>
 out_register_key_type:
 #endif
 #ifdef CONFIG_CIFS_UPCALL
<span class="p_del">-	unregister_key_type(&amp;cifs_spnego_key_type);</span>
<span class="p_add">+	exit_cifs_spnego();</span>
 out_destroy_request_bufs:
 #endif
 	cifs_destroy_request_bufs();
<span class="p_header">diff --git a/fs/cifs/cifsproto.h b/fs/cifs/cifsproto.h</span>
<span class="p_header">index ca7980a1e303..05ce3072fb09 100644</span>
<span class="p_header">--- a/fs/cifs/cifsproto.h</span>
<span class="p_header">+++ b/fs/cifs/cifsproto.h</span>
<span class="p_chunk">@@ -59,6 +59,8 @@</span> <span class="p_context"> do {								\</span>
 } while (0)
 extern int init_cifs_idmap(void);
 extern void exit_cifs_idmap(void);
<span class="p_add">+extern int init_cifs_spnego(void);</span>
<span class="p_add">+extern void exit_cifs_spnego(void);</span>
 extern char *build_path_from_dentry(struct dentry *);
 extern char *cifs_build_path_to_root(struct smb_vol *vol,
 				     struct cifs_sb_info *cifs_sb,
<span class="p_header">diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c</span>
<span class="p_header">index 3a4fc1bcde43..3c393b9759d8 100644</span>
<span class="p_header">--- a/fs/cifs/connect.c</span>
<span class="p_header">+++ b/fs/cifs/connect.c</span>
<span class="p_chunk">@@ -410,7 +410,9 @@</span> <span class="p_context"> cifs_echo_request(struct work_struct *work)</span>
 	 * server-&gt;ops-&gt;need_neg() == true. Also, no need to ping if
 	 * we got a response recently.
 	 */
<span class="p_del">-	if (!server-&gt;ops-&gt;need_neg || server-&gt;ops-&gt;need_neg(server) ||</span>
<span class="p_add">+</span>
<span class="p_add">+	if (server-&gt;tcpStatus == CifsNeedReconnect ||</span>
<span class="p_add">+	    server-&gt;tcpStatus == CifsExiting || server-&gt;tcpStatus == CifsNew ||</span>
 	    (server-&gt;ops-&gt;can_echo &amp;&amp; !server-&gt;ops-&gt;can_echo(server)) ||
 	    time_before(jiffies, server-&gt;lstrp + SMB_ECHO_INTERVAL - HZ))
 		goto requeue_echo;
<span class="p_header">diff --git a/fs/cifs/ntlmssp.h b/fs/cifs/ntlmssp.h</span>
<span class="p_header">index 848249fa120f..3079b38f0afb 100644</span>
<span class="p_header">--- a/fs/cifs/ntlmssp.h</span>
<span class="p_header">+++ b/fs/cifs/ntlmssp.h</span>
<span class="p_chunk">@@ -133,6 +133,6 @@</span> <span class="p_context"> typedef struct _AUTHENTICATE_MESSAGE {</span>
 
 int decode_ntlmssp_challenge(char *bcc_ptr, int blob_len, struct cifs_ses *ses);
 void build_ntlmssp_negotiate_blob(unsigned char *pbuffer, struct cifs_ses *ses);
<span class="p_del">-int build_ntlmssp_auth_blob(unsigned char *pbuffer, u16 *buflen,</span>
<span class="p_add">+int build_ntlmssp_auth_blob(unsigned char **pbuffer, u16 *buflen,</span>
 			struct cifs_ses *ses,
 			const struct nls_table *nls_cp);
<span class="p_header">diff --git a/fs/cifs/sess.c b/fs/cifs/sess.c</span>
<span class="p_header">index e87387dbf39f..7225ae94006e 100644</span>
<span class="p_header">--- a/fs/cifs/sess.c</span>
<span class="p_header">+++ b/fs/cifs/sess.c</span>
<span class="p_chunk">@@ -363,19 +363,43 @@</span> <span class="p_context"> void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,</span>
 	sec_blob-&gt;DomainName.MaximumLength = 0;
 }
 
<span class="p_del">-/* We do not malloc the blob, it is passed in pbuffer, because its</span>
<span class="p_del">-   maximum possible size is fixed and small, making this approach cleaner.</span>
<span class="p_del">-   This function returns the length of the data in the blob */</span>
<span class="p_del">-int build_ntlmssp_auth_blob(unsigned char *pbuffer,</span>
<span class="p_add">+static int size_of_ntlmssp_blob(struct cifs_ses *ses)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int sz = sizeof(AUTHENTICATE_MESSAGE) + ses-&gt;auth_key.len</span>
<span class="p_add">+		- CIFS_SESS_KEY_SIZE + CIFS_CPHTXT_SIZE + 2;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ses-&gt;domainName)</span>
<span class="p_add">+		sz += 2 * strnlen(ses-&gt;domainName, CIFS_MAX_DOMAINNAME_LEN);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		sz += 2;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ses-&gt;user_name)</span>
<span class="p_add">+		sz += 2 * strnlen(ses-&gt;user_name, CIFS_MAX_USERNAME_LEN);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		sz += 2;</span>
<span class="p_add">+</span>
<span class="p_add">+	return sz;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int build_ntlmssp_auth_blob(unsigned char **pbuffer,</span>
 					u16 *buflen,
 				   struct cifs_ses *ses,
 				   const struct nls_table *nls_cp)
 {
 	int rc;
<span class="p_del">-	AUTHENTICATE_MESSAGE *sec_blob = (AUTHENTICATE_MESSAGE *)pbuffer;</span>
<span class="p_add">+	AUTHENTICATE_MESSAGE *sec_blob;</span>
 	__u32 flags;
 	unsigned char *tmp;
 
<span class="p_add">+	rc = setup_ntlmv2_rsp(ses, nls_cp);</span>
<span class="p_add">+	if (rc) {</span>
<span class="p_add">+		cifs_dbg(VFS, &quot;Error %d during NTLMSSP authentication\n&quot;, rc);</span>
<span class="p_add">+		*buflen = 0;</span>
<span class="p_add">+		goto setup_ntlmv2_ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	*pbuffer = kmalloc(size_of_ntlmssp_blob(ses), GFP_KERNEL);</span>
<span class="p_add">+	sec_blob = (AUTHENTICATE_MESSAGE *)*pbuffer;</span>
<span class="p_add">+</span>
 	memcpy(sec_blob-&gt;Signature, NTLMSSP_SIGNATURE, 8);
 	sec_blob-&gt;MessageType = NtLmAuthenticate;
 
<span class="p_chunk">@@ -390,7 +414,7 @@</span> <span class="p_context"> int build_ntlmssp_auth_blob(unsigned char *pbuffer,</span>
 			flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
 	}
 
<span class="p_del">-	tmp = pbuffer + sizeof(AUTHENTICATE_MESSAGE);</span>
<span class="p_add">+	tmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);</span>
 	sec_blob-&gt;NegotiateFlags = cpu_to_le32(flags);
 
 	sec_blob-&gt;LmChallengeResponse.BufferOffset =
<span class="p_chunk">@@ -398,39 +422,43 @@</span> <span class="p_context"> int build_ntlmssp_auth_blob(unsigned char *pbuffer,</span>
 	sec_blob-&gt;LmChallengeResponse.Length = 0;
 	sec_blob-&gt;LmChallengeResponse.MaximumLength = 0;
 
<span class="p_del">-	sec_blob-&gt;NtChallengeResponse.BufferOffset = cpu_to_le32(tmp - pbuffer);</span>
<span class="p_del">-	rc = setup_ntlmv2_rsp(ses, nls_cp);</span>
<span class="p_del">-	if (rc) {</span>
<span class="p_del">-		cifs_dbg(VFS, &quot;Error %d during NTLMSSP authentication\n&quot;, rc);</span>
<span class="p_del">-		goto setup_ntlmv2_ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	memcpy(tmp, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_del">-			ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_del">-	tmp += ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE;</span>
<span class="p_add">+	sec_blob-&gt;NtChallengeResponse.BufferOffset =</span>
<span class="p_add">+				cpu_to_le32(tmp - *pbuffer);</span>
<span class="p_add">+	if (ses-&gt;user_name != NULL) {</span>
<span class="p_add">+		memcpy(tmp, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_add">+				ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+		tmp += ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE;</span>
 
<span class="p_del">-	sec_blob-&gt;NtChallengeResponse.Length =</span>
<span class="p_del">-			cpu_to_le16(ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_del">-	sec_blob-&gt;NtChallengeResponse.MaximumLength =</span>
<span class="p_del">-			cpu_to_le16(ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+		sec_blob-&gt;NtChallengeResponse.Length =</span>
<span class="p_add">+				cpu_to_le16(ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+		sec_blob-&gt;NtChallengeResponse.MaximumLength =</span>
<span class="p_add">+				cpu_to_le16(ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * don&#39;t send an NT Response for anonymous access</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		sec_blob-&gt;NtChallengeResponse.Length = 0;</span>
<span class="p_add">+		sec_blob-&gt;NtChallengeResponse.MaximumLength = 0;</span>
<span class="p_add">+	}</span>
 
 	if (ses-&gt;domainName == NULL) {
<span class="p_del">-		sec_blob-&gt;DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);</span>
<span class="p_add">+		sec_blob-&gt;DomainName.BufferOffset = cpu_to_le32(tmp - *pbuffer);</span>
 		sec_blob-&gt;DomainName.Length = 0;
 		sec_blob-&gt;DomainName.MaximumLength = 0;
 		tmp += 2;
 	} else {
 		int len;
 		len = cifs_strtoUTF16((__le16 *)tmp, ses-&gt;domainName,
<span class="p_del">-				      CIFS_MAX_USERNAME_LEN, nls_cp);</span>
<span class="p_add">+				      CIFS_MAX_DOMAINNAME_LEN, nls_cp);</span>
 		len *= 2; /* unicode is 2 bytes each */
<span class="p_del">-		sec_blob-&gt;DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);</span>
<span class="p_add">+		sec_blob-&gt;DomainName.BufferOffset = cpu_to_le32(tmp - *pbuffer);</span>
 		sec_blob-&gt;DomainName.Length = cpu_to_le16(len);
 		sec_blob-&gt;DomainName.MaximumLength = cpu_to_le16(len);
 		tmp += len;
 	}
 
 	if (ses-&gt;user_name == NULL) {
<span class="p_del">-		sec_blob-&gt;UserName.BufferOffset = cpu_to_le32(tmp - pbuffer);</span>
<span class="p_add">+		sec_blob-&gt;UserName.BufferOffset = cpu_to_le32(tmp - *pbuffer);</span>
 		sec_blob-&gt;UserName.Length = 0;
 		sec_blob-&gt;UserName.MaximumLength = 0;
 		tmp += 2;
<span class="p_chunk">@@ -439,13 +467,13 @@</span> <span class="p_context"> int build_ntlmssp_auth_blob(unsigned char *pbuffer,</span>
 		len = cifs_strtoUTF16((__le16 *)tmp, ses-&gt;user_name,
 				      CIFS_MAX_USERNAME_LEN, nls_cp);
 		len *= 2; /* unicode is 2 bytes each */
<span class="p_del">-		sec_blob-&gt;UserName.BufferOffset = cpu_to_le32(tmp - pbuffer);</span>
<span class="p_add">+		sec_blob-&gt;UserName.BufferOffset = cpu_to_le32(tmp - *pbuffer);</span>
 		sec_blob-&gt;UserName.Length = cpu_to_le16(len);
 		sec_blob-&gt;UserName.MaximumLength = cpu_to_le16(len);
 		tmp += len;
 	}
 
<span class="p_del">-	sec_blob-&gt;WorkstationName.BufferOffset = cpu_to_le32(tmp - pbuffer);</span>
<span class="p_add">+	sec_blob-&gt;WorkstationName.BufferOffset = cpu_to_le32(tmp - *pbuffer);</span>
 	sec_blob-&gt;WorkstationName.Length = 0;
 	sec_blob-&gt;WorkstationName.MaximumLength = 0;
 	tmp += 2;
<span class="p_chunk">@@ -454,19 +482,19 @@</span> <span class="p_context"> int build_ntlmssp_auth_blob(unsigned char *pbuffer,</span>
 		(ses-&gt;ntlmssp-&gt;server_flags &amp; NTLMSSP_NEGOTIATE_EXTENDED_SEC))
 			&amp;&amp; !calc_seckey(ses)) {
 		memcpy(tmp, ses-&gt;ntlmssp-&gt;ciphertext, CIFS_CPHTXT_SIZE);
<span class="p_del">-		sec_blob-&gt;SessionKey.BufferOffset = cpu_to_le32(tmp - pbuffer);</span>
<span class="p_add">+		sec_blob-&gt;SessionKey.BufferOffset = cpu_to_le32(tmp - *pbuffer);</span>
 		sec_blob-&gt;SessionKey.Length = cpu_to_le16(CIFS_CPHTXT_SIZE);
 		sec_blob-&gt;SessionKey.MaximumLength =
 				cpu_to_le16(CIFS_CPHTXT_SIZE);
 		tmp += CIFS_CPHTXT_SIZE;
 	} else {
<span class="p_del">-		sec_blob-&gt;SessionKey.BufferOffset = cpu_to_le32(tmp - pbuffer);</span>
<span class="p_add">+		sec_blob-&gt;SessionKey.BufferOffset = cpu_to_le32(tmp - *pbuffer);</span>
 		sec_blob-&gt;SessionKey.Length = 0;
 		sec_blob-&gt;SessionKey.MaximumLength = 0;
 	}
 
<span class="p_add">+	*buflen = tmp - *pbuffer;</span>
 setup_ntlmv2_ret:
<span class="p_del">-	*buflen = tmp - pbuffer;</span>
 	return rc;
 }
 
<span class="p_chunk">@@ -539,7 +567,7 @@</span> <span class="p_context"> CIFS_SessSetup(const unsigned int xid, struct cifs_ses *ses,</span>
 	struct key *spnego_key = NULL;
 	__le32 phase = NtLmNegotiate; /* NTLMSSP, if needed, is multistage */
 	u16 blob_len;
<span class="p_del">-	char *ntlmsspblob = NULL;</span>
<span class="p_add">+	unsigned char *ntlmsspblob = NULL;</span>
 
 	if (ses == NULL) {
 		WARN(1, &quot;%s: ses == NULL!&quot;, __func__);
<span class="p_chunk">@@ -624,22 +652,24 @@</span> <span class="p_context"> ssetup_ntlmssp_authenticate:</span>
 
 		pSMB-&gt;req.hdr.Flags2 &amp;= ~SMBFLG2_UNICODE;
 
<span class="p_del">-		/* no capabilities flags in old lanman negotiation */</span>
<span class="p_del">-</span>
<span class="p_del">-		pSMB-&gt;old_req.PasswordLength = cpu_to_le16(CIFS_AUTH_RESP_SIZE);</span>
<span class="p_add">+		if (ses-&gt;user_name != NULL) {</span>
<span class="p_add">+			/* no capabilities flags in old lanman negotiation */</span>
<span class="p_add">+			pSMB-&gt;old_req.PasswordLength = cpu_to_le16(CIFS_AUTH_RESP_SIZE);</span>
 
<span class="p_del">-		/* Calculate hash with password and copy into bcc_ptr.</span>
<span class="p_del">-		 * Encryption Key (stored as in cryptkey) gets used if the</span>
<span class="p_del">-		 * security mode bit in Negottiate Protocol response states</span>
<span class="p_del">-		 * to use challenge/response method (i.e. Password bit is 1).</span>
<span class="p_del">-		 */</span>
<span class="p_del">-</span>
<span class="p_del">-		rc = calc_lanman_hash(ses-&gt;password, ses-&gt;server-&gt;cryptkey,</span>
<span class="p_del">-				 ses-&gt;server-&gt;sec_mode &amp; SECMODE_PW_ENCRYPT ?</span>
<span class="p_del">-					true : false, lnm_session_key);</span>
<span class="p_del">-</span>
<span class="p_del">-		memcpy(bcc_ptr, (char *)lnm_session_key, CIFS_AUTH_RESP_SIZE);</span>
<span class="p_del">-		bcc_ptr += CIFS_AUTH_RESP_SIZE;</span>
<span class="p_add">+			/* Calculate hash with password and copy into bcc_ptr.</span>
<span class="p_add">+			 * Encryption Key (stored as in cryptkey) gets used if the</span>
<span class="p_add">+			 * security mode bit in Negottiate Protocol response states</span>
<span class="p_add">+			 * to use challenge/response method (i.e. Password bit is 1).</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			rc = calc_lanman_hash(ses-&gt;password, ses-&gt;server-&gt;cryptkey,</span>
<span class="p_add">+					      ses-&gt;server-&gt;sec_mode &amp; SECMODE_PW_ENCRYPT ?</span>
<span class="p_add">+					      true : false, lnm_session_key);</span>
<span class="p_add">+</span>
<span class="p_add">+			memcpy(bcc_ptr, (char *)lnm_session_key, CIFS_AUTH_RESP_SIZE);</span>
<span class="p_add">+			bcc_ptr += CIFS_AUTH_RESP_SIZE;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			pSMB-&gt;old_req.PasswordLength = 0;</span>
<span class="p_add">+		}</span>
 
 		/* can not sign if LANMAN negotiated so no need
 		to calculate signing key? but what if server
<span class="p_chunk">@@ -652,26 +682,31 @@</span> <span class="p_context"> ssetup_ntlmssp_authenticate:</span>
 #endif
 	} else if (type == NTLM) {
 		pSMB-&gt;req_no_secext.Capabilities = cpu_to_le32(capabilities);
<span class="p_del">-		pSMB-&gt;req_no_secext.CaseInsensitivePasswordLength =</span>
<span class="p_del">-			cpu_to_le16(CIFS_AUTH_RESP_SIZE);</span>
<span class="p_del">-		pSMB-&gt;req_no_secext.CaseSensitivePasswordLength =</span>
<span class="p_del">-			cpu_to_le16(CIFS_AUTH_RESP_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* calculate ntlm response and session key */</span>
<span class="p_del">-		rc = setup_ntlm_response(ses, nls_cp);</span>
<span class="p_del">-		if (rc) {</span>
<span class="p_del">-			cifs_dbg(VFS, &quot;Error %d during NTLM authentication\n&quot;,</span>
<span class="p_del">-				 rc);</span>
<span class="p_del">-			goto ssetup_exit;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (ses-&gt;user_name != NULL) {</span>
<span class="p_add">+			pSMB-&gt;req_no_secext.CaseInsensitivePasswordLength =</span>
<span class="p_add">+					cpu_to_le16(CIFS_AUTH_RESP_SIZE);</span>
<span class="p_add">+			pSMB-&gt;req_no_secext.CaseSensitivePasswordLength =</span>
<span class="p_add">+					cpu_to_le16(CIFS_AUTH_RESP_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* calculate ntlm response and session key */</span>
<span class="p_add">+			rc = setup_ntlm_response(ses, nls_cp);</span>
<span class="p_add">+			if (rc) {</span>
<span class="p_add">+				cifs_dbg(VFS, &quot;Error %d during NTLM authentication\n&quot;,</span>
<span class="p_add">+						 rc);</span>
<span class="p_add">+				goto ssetup_exit;</span>
<span class="p_add">+			}</span>
 
<span class="p_del">-		/* copy ntlm response */</span>
<span class="p_del">-		memcpy(bcc_ptr, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_del">-				CIFS_AUTH_RESP_SIZE);</span>
<span class="p_del">-		bcc_ptr += CIFS_AUTH_RESP_SIZE;</span>
<span class="p_del">-		memcpy(bcc_ptr, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_del">-				CIFS_AUTH_RESP_SIZE);</span>
<span class="p_del">-		bcc_ptr += CIFS_AUTH_RESP_SIZE;</span>
<span class="p_add">+			/* copy ntlm response */</span>
<span class="p_add">+			memcpy(bcc_ptr, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_add">+					CIFS_AUTH_RESP_SIZE);</span>
<span class="p_add">+			bcc_ptr += CIFS_AUTH_RESP_SIZE;</span>
<span class="p_add">+			memcpy(bcc_ptr, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_add">+					CIFS_AUTH_RESP_SIZE);</span>
<span class="p_add">+			bcc_ptr += CIFS_AUTH_RESP_SIZE;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			pSMB-&gt;req_no_secext.CaseInsensitivePasswordLength = 0;</span>
<span class="p_add">+			pSMB-&gt;req_no_secext.CaseSensitivePasswordLength = 0;</span>
<span class="p_add">+		}</span>
 
 		if (ses-&gt;capabilities &amp; CAP_UNICODE) {
 			/* unicode strings must be word aligned */
<span class="p_chunk">@@ -688,22 +723,26 @@</span> <span class="p_context"> ssetup_ntlmssp_authenticate:</span>
 		/* LM2 password would be here if we supported it */
 		pSMB-&gt;req_no_secext.CaseInsensitivePasswordLength = 0;
 
<span class="p_del">-		/* calculate nlmv2 response and session key */</span>
<span class="p_del">-		rc = setup_ntlmv2_rsp(ses, nls_cp);</span>
<span class="p_del">-		if (rc) {</span>
<span class="p_del">-			cifs_dbg(VFS, &quot;Error %d during NTLMv2 authentication\n&quot;,</span>
<span class="p_del">-				 rc);</span>
<span class="p_del">-			goto ssetup_exit;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		memcpy(bcc_ptr, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_del">-				ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_del">-		bcc_ptr += ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE;</span>
<span class="p_add">+		if (ses-&gt;user_name != NULL) {</span>
<span class="p_add">+			/* calculate nlmv2 response and session key */</span>
<span class="p_add">+			rc = setup_ntlmv2_rsp(ses, nls_cp);</span>
<span class="p_add">+			if (rc) {</span>
<span class="p_add">+				cifs_dbg(VFS, &quot;Error %d during NTLMv2 authentication\n&quot;, rc);</span>
<span class="p_add">+				goto ssetup_exit;</span>
<span class="p_add">+			}</span>
 
<span class="p_del">-		/* set case sensitive password length after tilen may get</span>
<span class="p_del">-		 * assigned, tilen is 0 otherwise.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		pSMB-&gt;req_no_secext.CaseSensitivePasswordLength =</span>
<span class="p_del">-			cpu_to_le16(ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+			memcpy(bcc_ptr, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_add">+					ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+			bcc_ptr += ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+			/* set case sensitive password length after tilen may get</span>
<span class="p_add">+			 * assigned, tilen is 0 otherwise.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			pSMB-&gt;req_no_secext.CaseSensitivePasswordLength =</span>
<span class="p_add">+				cpu_to_le16(ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			pSMB-&gt;req_no_secext.CaseSensitivePasswordLength = 0;</span>
<span class="p_add">+		}</span>
 
 		if (ses-&gt;capabilities &amp; CAP_UNICODE) {
 			if (iov[0].iov_len % 2) {
<span class="p_chunk">@@ -790,20 +829,7 @@</span> <span class="p_context"> ssetup_ntlmssp_authenticate:</span>
 				cpu_to_le16(sizeof(NEGOTIATE_MESSAGE));
 			break;
 		case NtLmAuthenticate:
<span class="p_del">-			/*</span>
<span class="p_del">-			 * 5 is an empirical value, large enough to hold</span>
<span class="p_del">-			 * authenticate message plus max 10 of av paris,</span>
<span class="p_del">-			 * domain, user, workstation names, flags, etc.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			ntlmsspblob = kzalloc(</span>
<span class="p_del">-				5*sizeof(struct _AUTHENTICATE_MESSAGE),</span>
<span class="p_del">-				GFP_KERNEL);</span>
<span class="p_del">-			if (!ntlmsspblob) {</span>
<span class="p_del">-				rc = -ENOMEM;</span>
<span class="p_del">-				goto ssetup_exit;</span>
<span class="p_del">-			}</span>
<span class="p_del">-</span>
<span class="p_del">-			rc = build_ntlmssp_auth_blob(ntlmsspblob,</span>
<span class="p_add">+			rc = build_ntlmssp_auth_blob(&amp;ntlmsspblob,</span>
 						&amp;blob_len, ses, nls_cp);
 			if (rc)
 				goto ssetup_exit;
<span class="p_header">diff --git a/fs/cifs/smb2glob.h b/fs/cifs/smb2glob.h</span>
<span class="p_header">index bc0bb9c34f72..0ffa18094335 100644</span>
<span class="p_header">--- a/fs/cifs/smb2glob.h</span>
<span class="p_header">+++ b/fs/cifs/smb2glob.h</span>
<span class="p_chunk">@@ -44,6 +44,7 @@</span> <span class="p_context"></span>
 #define SMB2_OP_DELETE 7
 #define SMB2_OP_HARDLINK 8
 #define SMB2_OP_SET_EOF 9
<span class="p_add">+#define SMB2_OP_RMDIR 10</span>
 
 /* Used when constructing chained read requests. */
 #define CHAINED_REQUEST 1
<span class="p_header">diff --git a/fs/cifs/smb2inode.c b/fs/cifs/smb2inode.c</span>
<span class="p_header">index 215f8d3e3e53..f970c5d5b253 100644</span>
<span class="p_header">--- a/fs/cifs/smb2inode.c</span>
<span class="p_header">+++ b/fs/cifs/smb2inode.c</span>
<span class="p_chunk">@@ -80,6 +80,10 @@</span> <span class="p_context"> smb2_open_op_close(const unsigned int xid, struct cifs_tcon *tcon,</span>
 		 * SMB2_open() call.
 		 */
 		break;
<span class="p_add">+	case SMB2_OP_RMDIR:</span>
<span class="p_add">+		tmprc = SMB2_rmdir(xid, tcon, fid.persistent_fid,</span>
<span class="p_add">+				   fid.volatile_fid);</span>
<span class="p_add">+		break;</span>
 	case SMB2_OP_RENAME:
 		tmprc = SMB2_rename(xid, tcon, fid.persistent_fid,
 				    fid.volatile_fid, (__le16 *)data);
<span class="p_chunk">@@ -191,8 +195,8 @@</span> <span class="p_context"> smb2_rmdir(const unsigned int xid, struct cifs_tcon *tcon, const char *name,</span>
 	   struct cifs_sb_info *cifs_sb)
 {
 	return smb2_open_op_close(xid, tcon, cifs_sb, name, DELETE, FILE_OPEN,
<span class="p_del">-				  CREATE_NOT_FILE | CREATE_DELETE_ON_CLOSE,</span>
<span class="p_del">-				  NULL, SMB2_OP_DELETE);</span>
<span class="p_add">+				  CREATE_NOT_FILE,</span>
<span class="p_add">+				  NULL, SMB2_OP_RMDIR);</span>
 }
 
 int
<span class="p_header">diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c</span>
<span class="p_header">index c83a5a2fac70..aa49aaa417be 100644</span>
<span class="p_header">--- a/fs/cifs/smb2pdu.c</span>
<span class="p_header">+++ b/fs/cifs/smb2pdu.c</span>
<span class="p_chunk">@@ -550,7 +550,7 @@</span> <span class="p_context"> SMB2_sess_setup(const unsigned int xid, struct cifs_ses *ses,</span>
 	struct TCP_Server_Info *server = ses-&gt;server;
 	u16 blob_length = 0;
 	char *security_blob;
<span class="p_del">-	char *ntlmssp_blob = NULL;</span>
<span class="p_add">+	unsigned char *ntlmssp_blob = NULL;</span>
 	bool use_spnego = false; /* else use raw ntlmssp */
 
 	cifs_dbg(FYI, &quot;Session Setup\n&quot;);
<span class="p_chunk">@@ -631,13 +631,7 @@</span> <span class="p_context"> ssetup_ntlmssp_authenticate:</span>
 		}
 	} else if (phase == NtLmAuthenticate) {
 		req-&gt;hdr.SessionId = ses-&gt;Suid;
<span class="p_del">-		ntlmssp_blob = kzalloc(sizeof(struct _NEGOTIATE_MESSAGE) + 500,</span>
<span class="p_del">-				       GFP_KERNEL);</span>
<span class="p_del">-		if (ntlmssp_blob == NULL) {</span>
<span class="p_del">-			rc = -ENOMEM;</span>
<span class="p_del">-			goto ssetup_exit;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		rc = build_ntlmssp_auth_blob(ntlmssp_blob, &amp;blob_length, ses,</span>
<span class="p_add">+		rc = build_ntlmssp_auth_blob(&amp;ntlmssp_blob, &amp;blob_length, ses,</span>
 					     nls_cp);
 		if (rc) {
 			cifs_dbg(FYI, &quot;build_ntlmssp_auth_blob failed %d\n&quot;,
<span class="p_chunk">@@ -1596,6 +1590,33 @@</span> <span class="p_context"> SMB2_echo(struct TCP_Server_Info *server)</span>
 
 	cifs_dbg(FYI, &quot;In echo request\n&quot;);
 
<span class="p_add">+	if (server-&gt;tcpStatus == CifsNeedNegotiate) {</span>
<span class="p_add">+		struct list_head *tmp, *tmp2;</span>
<span class="p_add">+		struct cifs_ses *ses;</span>
<span class="p_add">+		struct cifs_tcon *tcon;</span>
<span class="p_add">+</span>
<span class="p_add">+		cifs_dbg(FYI, &quot;Need negotiate, reconnecting tcons\n&quot;);</span>
<span class="p_add">+		spin_lock(&amp;cifs_tcp_ses_lock);</span>
<span class="p_add">+		list_for_each(tmp, &amp;server-&gt;smb_ses_list) {</span>
<span class="p_add">+			ses = list_entry(tmp, struct cifs_ses, smb_ses_list);</span>
<span class="p_add">+			list_for_each(tmp2, &amp;ses-&gt;tcon_list) {</span>
<span class="p_add">+				tcon = list_entry(tmp2, struct cifs_tcon,</span>
<span class="p_add">+						  tcon_list);</span>
<span class="p_add">+				/* add check for persistent handle reconnect */</span>
<span class="p_add">+				if (tcon &amp;&amp; tcon-&gt;need_reconnect) {</span>
<span class="p_add">+					spin_unlock(&amp;cifs_tcp_ses_lock);</span>
<span class="p_add">+					rc = smb2_reconnect(SMB2_ECHO, tcon);</span>
<span class="p_add">+					spin_lock(&amp;cifs_tcp_ses_lock);</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+		spin_unlock(&amp;cifs_tcp_ses_lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* if no session, renegotiate failed above */</span>
<span class="p_add">+	if (server-&gt;tcpStatus == CifsNeedNegotiate)</span>
<span class="p_add">+		return -EIO;</span>
<span class="p_add">+</span>
 	rc = small_smb2_init(SMB2_ECHO, NULL, (void **)&amp;req);
 	if (rc)
 		return rc;
<span class="p_chunk">@@ -2297,6 +2318,22 @@</span> <span class="p_context"> SMB2_rename(const unsigned int xid, struct cifs_tcon *tcon,</span>
 }
 
 int
<span class="p_add">+SMB2_rmdir(const unsigned int xid, struct cifs_tcon *tcon,</span>
<span class="p_add">+		  u64 persistent_fid, u64 volatile_fid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__u8 delete_pending = 1;</span>
<span class="p_add">+	void *data;</span>
<span class="p_add">+	unsigned int size;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = &amp;delete_pending;</span>
<span class="p_add">+	size = 1; /* sizeof __u8 */</span>
<span class="p_add">+</span>
<span class="p_add">+	return send_set_info(xid, tcon, persistent_fid, volatile_fid,</span>
<span class="p_add">+			current-&gt;tgid, FILE_DISPOSITION_INFORMATION, 1, &amp;data,</span>
<span class="p_add">+			&amp;size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int</span>
 SMB2_set_hardlink(const unsigned int xid, struct cifs_tcon *tcon,
 		  u64 persistent_fid, u64 volatile_fid, __le16 *target_file)
 {
<span class="p_header">diff --git a/fs/cifs/smb2proto.h b/fs/cifs/smb2proto.h</span>
<span class="p_header">index 0ce48db20a65..8e0d57bf446b 100644</span>
<span class="p_header">--- a/fs/cifs/smb2proto.h</span>
<span class="p_header">+++ b/fs/cifs/smb2proto.h</span>
<span class="p_chunk">@@ -134,6 +134,8 @@</span> <span class="p_context"> extern int SMB2_query_directory(const unsigned int xid, struct cifs_tcon *tcon,</span>
 extern int SMB2_rename(const unsigned int xid, struct cifs_tcon *tcon,
 		       u64 persistent_fid, u64 volatile_fid,
 		       __le16 *target_file);
<span class="p_add">+extern int SMB2_rmdir(const unsigned int xid, struct cifs_tcon *tcon,</span>
<span class="p_add">+		      u64 persistent_fid, u64 volatile_fid);</span>
 extern int SMB2_set_hardlink(const unsigned int xid, struct cifs_tcon *tcon,
 			     u64 persistent_fid, u64 volatile_fid,
 			     __le16 *target_file);
<span class="p_header">diff --git a/fs/dcache.c b/fs/dcache.c</span>
<span class="p_header">index f9dcd166d878..40b3fc1fb608 100644</span>
<span class="p_header">--- a/fs/dcache.c</span>
<span class="p_header">+++ b/fs/dcache.c</span>
<span class="p_chunk">@@ -1502,7 +1502,7 @@</span> <span class="p_context"> struct dentry *d_alloc(struct dentry * parent, const struct qstr *name)</span>
 	struct dentry *dentry = __d_alloc(parent-&gt;d_sb, name);
 	if (!dentry)
 		return NULL;
<span class="p_del">-</span>
<span class="p_add">+	dentry-&gt;d_flags |= DCACHE_RCUACCESS;</span>
 	spin_lock(&amp;parent-&gt;d_lock);
 	/*
 	 * don&#39;t need child lock because it is not subject
<span class="p_chunk">@@ -2354,7 +2354,6 @@</span> <span class="p_context"> static void __d_rehash(struct dentry * entry, struct hlist_bl_head *b)</span>
 {
 	BUG_ON(!d_unhashed(entry));
 	hlist_bl_lock(b);
<span class="p_del">-	entry-&gt;d_flags |= DCACHE_RCUACCESS;</span>
 	hlist_bl_add_head_rcu(&amp;entry-&gt;d_hash, b);
 	hlist_bl_unlock(b);
 }
<span class="p_chunk">@@ -2560,6 +2559,7 @@</span> <span class="p_context"> static void __d_move(struct dentry *dentry, struct dentry *target,</span>
 
 	/* ... and switch the parents */
 	if (IS_ROOT(dentry)) {
<span class="p_add">+		dentry-&gt;d_flags |= DCACHE_RCUACCESS;</span>
 		dentry-&gt;d_parent = target-&gt;d_parent;
 		target-&gt;d_parent = target;
 		INIT_LIST_HEAD(&amp;target-&gt;d_child);
<span class="p_chunk">@@ -2696,6 +2696,7 @@</span> <span class="p_context"> static void __d_materialise_dentry(struct dentry *dentry, struct dentry *anon)</span>
 
 	switch_names(dentry, anon, false);
 
<span class="p_add">+	dentry-&gt;d_flags |= DCACHE_RCUACCESS;</span>
 	dentry-&gt;d_parent = dentry;
 	list_del_init(&amp;dentry-&gt;d_child);
 	anon-&gt;d_parent = dparent;
<span class="p_header">diff --git a/fs/ecryptfs/file.c b/fs/ecryptfs/file.c</span>
<span class="p_header">index 0682699519af..b6c9410f3d04 100644</span>
<span class="p_header">--- a/fs/ecryptfs/file.c</span>
<span class="p_header">+++ b/fs/ecryptfs/file.c</span>
<span class="p_chunk">@@ -177,6 +177,19 @@</span> <span class="p_context"> out:</span>
 	return rc;
 }
 
<span class="p_add">+static int ecryptfs_mmap(struct file *file, struct vm_area_struct *vma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct file *lower_file = ecryptfs_file_to_lower(file);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Don&#39;t allow mmap on top of file systems that don&#39;t support it</span>
<span class="p_add">+	 * natively.  If FILESYSTEM_MAX_STACK_DEPTH &gt; 2 or ecryptfs</span>
<span class="p_add">+	 * allows recursive mounting, this will need to be extended.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!lower_file-&gt;f_op-&gt;mmap)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	return generic_file_mmap(file, vma);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * ecryptfs_open
  * @inode: inode speciying file to open
<span class="p_chunk">@@ -374,7 +387,7 @@</span> <span class="p_context"> const struct file_operations ecryptfs_main_fops = {</span>
 #ifdef CONFIG_COMPAT
 	.compat_ioctl = ecryptfs_compat_ioctl,
 #endif
<span class="p_del">-	.mmap = generic_file_mmap,</span>
<span class="p_add">+	.mmap = ecryptfs_mmap,</span>
 	.open = ecryptfs_open,
 	.flush = ecryptfs_flush,
 	.release = ecryptfs_release,
<span class="p_header">diff --git a/fs/ecryptfs/main.c b/fs/ecryptfs/main.c</span>
<span class="p_header">index 34eb8433d93f..d9eb84bda559 100644</span>
<span class="p_header">--- a/fs/ecryptfs/main.c</span>
<span class="p_header">+++ b/fs/ecryptfs/main.c</span>
<span class="p_chunk">@@ -576,6 +576,13 @@</span> <span class="p_context"> static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags</span>
 	s-&gt;s_maxbytes = path.dentry-&gt;d_sb-&gt;s_maxbytes;
 	s-&gt;s_blocksize = path.dentry-&gt;d_sb-&gt;s_blocksize;
 	s-&gt;s_magic = ECRYPTFS_SUPER_MAGIC;
<span class="p_add">+	s-&gt;s_stack_depth = path.dentry-&gt;d_sb-&gt;s_stack_depth + 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = -EINVAL;</span>
<span class="p_add">+	if (s-&gt;s_stack_depth &gt; FILESYSTEM_MAX_STACK_DEPTH) {</span>
<span class="p_add">+		pr_err(&quot;eCryptfs: maximum fs stacking depth exceeded\n&quot;);</span>
<span class="p_add">+		goto out_free;</span>
<span class="p_add">+	}</span>
 
 	inode = ecryptfs_get_inode(path.dentry-&gt;d_inode, s);
 	rc = PTR_ERR(inode);
<span class="p_header">diff --git a/fs/ext4/ialloc.c b/fs/ext4/ialloc.c</span>
<span class="p_header">index ac644c31ca67..a6620b1fe334 100644</span>
<span class="p_header">--- a/fs/ext4/ialloc.c</span>
<span class="p_header">+++ b/fs/ext4/ialloc.c</span>
<span class="p_chunk">@@ -1090,22 +1090,19 @@</span> <span class="p_context"> struct inode *ext4_orphan_get(struct super_block *sb, unsigned long ino)</span>
 	unsigned long max_ino = le32_to_cpu(EXT4_SB(sb)-&gt;s_es-&gt;s_inodes_count);
 	ext4_group_t block_group;
 	int bit;
<span class="p_del">-	struct buffer_head *bitmap_bh;</span>
<span class="p_add">+	struct buffer_head *bitmap_bh = NULL;</span>
 	struct inode *inode = NULL;
<span class="p_del">-	long err = -EIO;</span>
<span class="p_add">+	int err = -EIO;</span>
 
<span class="p_del">-	/* Error cases - e2fsck has already cleaned up for us */</span>
<span class="p_del">-	if (ino &gt; max_ino) {</span>
<span class="p_del">-		ext4_warning(sb, &quot;bad orphan ino %lu!  e2fsck was run?&quot;, ino);</span>
<span class="p_del">-		goto error;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (ino &lt; EXT4_FIRST_INO(sb) || ino &gt; max_ino)</span>
<span class="p_add">+		goto bad_orphan;</span>
 
 	block_group = (ino - 1) / EXT4_INODES_PER_GROUP(sb);
 	bit = (ino - 1) % EXT4_INODES_PER_GROUP(sb);
 	bitmap_bh = ext4_read_inode_bitmap(sb, block_group);
 	if (!bitmap_bh) {
<span class="p_del">-		ext4_warning(sb, &quot;inode bitmap error for orphan %lu&quot;, ino);</span>
<span class="p_del">-		goto error;</span>
<span class="p_add">+		ext4_error(sb, &quot;inode bitmap error for orphan %lu&quot;, ino);</span>
<span class="p_add">+		return (struct inode *) bitmap_bh;</span>
 	}
 
 	/* Having the inode bit set should be a 100% indicator that this
<span class="p_chunk">@@ -1116,15 +1113,21 @@</span> <span class="p_context"> struct inode *ext4_orphan_get(struct super_block *sb, unsigned long ino)</span>
 		goto bad_orphan;
 
 	inode = ext4_iget(sb, ino);
<span class="p_del">-	if (IS_ERR(inode))</span>
<span class="p_del">-		goto iget_failed;</span>
<span class="p_add">+	if (IS_ERR(inode)) {</span>
<span class="p_add">+		err = PTR_ERR(inode);</span>
<span class="p_add">+		ext4_error(sb, &quot;couldn&#39;t read orphan inode %lu (err %d)&quot;,</span>
<span class="p_add">+			   ino, err);</span>
<span class="p_add">+		return inode;</span>
<span class="p_add">+	}</span>
 
 	/*
<span class="p_del">-	 * If the orphans has i_nlinks &gt; 0 then it should be able to be</span>
<span class="p_del">-	 * truncated, otherwise it won&#39;t be removed from the orphan list</span>
<span class="p_del">-	 * during processing and an infinite loop will result.</span>
<span class="p_add">+	 * If the orphans has i_nlinks &gt; 0 then it should be able to</span>
<span class="p_add">+	 * be truncated, otherwise it won&#39;t be removed from the orphan</span>
<span class="p_add">+	 * list during processing and an infinite loop will result.</span>
<span class="p_add">+	 * Similarly, it must not be a bad inode.</span>
 	 */
<span class="p_del">-	if (inode-&gt;i_nlink &amp;&amp; !ext4_can_truncate(inode))</span>
<span class="p_add">+	if ((inode-&gt;i_nlink &amp;&amp; !ext4_can_truncate(inode)) ||</span>
<span class="p_add">+	    is_bad_inode(inode))</span>
 		goto bad_orphan;
 
 	if (NEXT_ORPHAN(inode) &gt; max_ino)
<span class="p_chunk">@@ -1132,29 +1135,25 @@</span> <span class="p_context"> struct inode *ext4_orphan_get(struct super_block *sb, unsigned long ino)</span>
 	brelse(bitmap_bh);
 	return inode;
 
<span class="p_del">-iget_failed:</span>
<span class="p_del">-	err = PTR_ERR(inode);</span>
<span class="p_del">-	inode = NULL;</span>
 bad_orphan:
<span class="p_del">-	ext4_warning(sb, &quot;bad orphan inode %lu!  e2fsck was run?&quot;, ino);</span>
<span class="p_del">-	printk(KERN_WARNING &quot;ext4_test_bit(bit=%d, block=%llu) = %d\n&quot;,</span>
<span class="p_del">-	       bit, (unsigned long long)bitmap_bh-&gt;b_blocknr,</span>
<span class="p_del">-	       ext4_test_bit(bit, bitmap_bh-&gt;b_data));</span>
<span class="p_del">-	printk(KERN_WARNING &quot;inode=%p\n&quot;, inode);</span>
<span class="p_add">+	ext4_error(sb, &quot;bad orphan inode %lu&quot;, ino);</span>
<span class="p_add">+	if (bitmap_bh)</span>
<span class="p_add">+		printk(KERN_ERR &quot;ext4_test_bit(bit=%d, block=%llu) = %d\n&quot;,</span>
<span class="p_add">+		       bit, (unsigned long long)bitmap_bh-&gt;b_blocknr,</span>
<span class="p_add">+		       ext4_test_bit(bit, bitmap_bh-&gt;b_data));</span>
 	if (inode) {
<span class="p_del">-		printk(KERN_WARNING &quot;is_bad_inode(inode)=%d\n&quot;,</span>
<span class="p_add">+		printk(KERN_ERR &quot;is_bad_inode(inode)=%d\n&quot;,</span>
 		       is_bad_inode(inode));
<span class="p_del">-		printk(KERN_WARNING &quot;NEXT_ORPHAN(inode)=%u\n&quot;,</span>
<span class="p_add">+		printk(KERN_ERR &quot;NEXT_ORPHAN(inode)=%u\n&quot;,</span>
 		       NEXT_ORPHAN(inode));
<span class="p_del">-		printk(KERN_WARNING &quot;max_ino=%lu\n&quot;, max_ino);</span>
<span class="p_del">-		printk(KERN_WARNING &quot;i_nlink=%u\n&quot;, inode-&gt;i_nlink);</span>
<span class="p_add">+		printk(KERN_ERR &quot;max_ino=%lu\n&quot;, max_ino);</span>
<span class="p_add">+		printk(KERN_ERR &quot;i_nlink=%u\n&quot;, inode-&gt;i_nlink);</span>
 		/* Avoid freeing blocks if we got a bad deleted inode */
 		if (inode-&gt;i_nlink == 0)
 			inode-&gt;i_blocks = 0;
 		iput(inode);
 	}
 	brelse(bitmap_bh);
<span class="p_del">-error:</span>
 	return ERR_PTR(err);
 }
 
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index c9d21642ca79..a2c4495d40e9 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -708,6 +708,20 @@</span> <span class="p_context"> has_zeroout:</span>
 		ret = check_block_validity(inode, map);
 		if (ret != 0)
 			return ret;
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Inodes with freshly allocated blocks where contents will be</span>
<span class="p_add">+		 * visible after transaction commit must be on transaction&#39;s</span>
<span class="p_add">+		 * ordered data list.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (map-&gt;m_flags &amp; EXT4_MAP_NEW &amp;&amp;</span>
<span class="p_add">+		    !(map-&gt;m_flags &amp; EXT4_MAP_UNWRITTEN) &amp;&amp;</span>
<span class="p_add">+		    !IS_NOQUOTA(inode) &amp;&amp;</span>
<span class="p_add">+		    ext4_should_order_data(inode)) {</span>
<span class="p_add">+			ret = ext4_jbd2_file_inode(handle, inode);</span>
<span class="p_add">+			if (ret)</span>
<span class="p_add">+				return ret;</span>
<span class="p_add">+		}</span>
 	}
 	return retval;
 }
<span class="p_chunk">@@ -1101,15 +1115,6 @@</span> <span class="p_context"> static int ext4_write_end(struct file *file,</span>
 	int i_size_changed = 0;
 
 	trace_ext4_write_end(inode, pos, len, copied);
<span class="p_del">-	if (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE)) {</span>
<span class="p_del">-		ret = ext4_jbd2_file_inode(handle, inode);</span>
<span class="p_del">-		if (ret) {</span>
<span class="p_del">-			unlock_page(page);</span>
<span class="p_del">-			page_cache_release(page);</span>
<span class="p_del">-			goto errout;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	if (ext4_has_inline_data(inode)) {
 		ret = ext4_write_inline_data_end(inode, pos, len,
 						 copied, page);
<span class="p_header">diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c</span>
<span class="p_header">index 5dbec667d75b..e253213b39e3 100644</span>
<span class="p_header">--- a/fs/ext4/namei.c</span>
<span class="p_header">+++ b/fs/ext4/namei.c</span>
<span class="p_chunk">@@ -2626,7 +2626,7 @@</span> <span class="p_context"> int ext4_orphan_add(handle_t *handle, struct inode *inode)</span>
 			 * list entries can cause panics at unmount time.
 			 */
 			mutex_lock(&amp;sbi-&gt;s_orphan_lock);
<span class="p_del">-			list_del(&amp;EXT4_I(inode)-&gt;i_orphan);</span>
<span class="p_add">+			list_del_init(&amp;EXT4_I(inode)-&gt;i_orphan);</span>
 			mutex_unlock(&amp;sbi-&gt;s_orphan_lock);
 		}
 	}
<span class="p_header">diff --git a/fs/hpfs/super.c b/fs/hpfs/super.c</span>
<span class="p_header">index 8685c655737f..bc6e5c5da88c 100644</span>
<span class="p_header">--- a/fs/hpfs/super.c</span>
<span class="p_header">+++ b/fs/hpfs/super.c</span>
<span class="p_chunk">@@ -15,6 +15,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/sched.h&gt;
 #include &lt;linux/bitmap.h&gt;
 #include &lt;linux/slab.h&gt;
<span class="p_add">+#include &lt;linux/seq_file.h&gt;</span>
 
 /* Mark the filesystem dirty, so that chkdsk checks it when os/2 booted */
 
<span class="p_chunk">@@ -426,10 +427,6 @@</span> <span class="p_context"> static int hpfs_remount_fs(struct super_block *s, int *flags, char *data)</span>
 	int lowercase, eas, chk, errs, chkdsk, timeshift;
 	int o;
 	struct hpfs_sb_info *sbi = hpfs_sb(s);
<span class="p_del">-	char *new_opts = kstrdup(data, GFP_KERNEL);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!new_opts)</span>
<span class="p_del">-		return -ENOMEM;</span>
 
 	sync_filesystem(s);
 
<span class="p_chunk">@@ -466,17 +463,44 @@</span> <span class="p_context"> static int hpfs_remount_fs(struct super_block *s, int *flags, char *data)</span>
 
 	if (!(*flags &amp; MS_RDONLY)) mark_dirty(s, 1);
 
<span class="p_del">-	replace_mount_options(s, new_opts);</span>
<span class="p_del">-</span>
 	hpfs_unlock(s);
 	return 0;
 
 out_err:
 	hpfs_unlock(s);
<span class="p_del">-	kfree(new_opts);</span>
 	return -EINVAL;
 }
 
<span class="p_add">+static int hpfs_show_options(struct seq_file *seq, struct dentry *root)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hpfs_sb_info *sbi = hpfs_sb(root-&gt;d_sb);</span>
<span class="p_add">+</span>
<span class="p_add">+	seq_printf(seq, &quot;,uid=%u&quot;, from_kuid_munged(&amp;init_user_ns, sbi-&gt;sb_uid));</span>
<span class="p_add">+	seq_printf(seq, &quot;,gid=%u&quot;, from_kgid_munged(&amp;init_user_ns, sbi-&gt;sb_gid));</span>
<span class="p_add">+	seq_printf(seq, &quot;,umask=%03o&quot;, (~sbi-&gt;sb_mode &amp; 0777));</span>
<span class="p_add">+	if (sbi-&gt;sb_lowercase)</span>
<span class="p_add">+		seq_printf(seq, &quot;,case=lower&quot;);</span>
<span class="p_add">+	if (!sbi-&gt;sb_chk)</span>
<span class="p_add">+		seq_printf(seq, &quot;,check=none&quot;);</span>
<span class="p_add">+	if (sbi-&gt;sb_chk == 2)</span>
<span class="p_add">+		seq_printf(seq, &quot;,check=strict&quot;);</span>
<span class="p_add">+	if (!sbi-&gt;sb_err)</span>
<span class="p_add">+		seq_printf(seq, &quot;,errors=continue&quot;);</span>
<span class="p_add">+	if (sbi-&gt;sb_err == 2)</span>
<span class="p_add">+		seq_printf(seq, &quot;,errors=panic&quot;);</span>
<span class="p_add">+	if (!sbi-&gt;sb_chkdsk)</span>
<span class="p_add">+		seq_printf(seq, &quot;,chkdsk=no&quot;);</span>
<span class="p_add">+	if (sbi-&gt;sb_chkdsk == 2)</span>
<span class="p_add">+		seq_printf(seq, &quot;,chkdsk=always&quot;);</span>
<span class="p_add">+	if (!sbi-&gt;sb_eas)</span>
<span class="p_add">+		seq_printf(seq, &quot;,eas=no&quot;);</span>
<span class="p_add">+	if (sbi-&gt;sb_eas == 1)</span>
<span class="p_add">+		seq_printf(seq, &quot;,eas=ro&quot;);</span>
<span class="p_add">+	if (sbi-&gt;sb_timeshift)</span>
<span class="p_add">+		seq_printf(seq, &quot;,timeshift=%d&quot;, sbi-&gt;sb_timeshift);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Super operations */
 
 static const struct super_operations hpfs_sops =
<span class="p_chunk">@@ -487,7 +511,7 @@</span> <span class="p_context"> static const struct super_operations hpfs_sops =</span>
 	.put_super	= hpfs_put_super,
 	.statfs		= hpfs_statfs,
 	.remount_fs	= hpfs_remount_fs,
<span class="p_del">-	.show_options	= generic_show_options,</span>
<span class="p_add">+	.show_options	= hpfs_show_options,</span>
 };
 
 static int hpfs_fill_super(struct super_block *s, void *options, int silent)
<span class="p_chunk">@@ -510,8 +534,6 @@</span> <span class="p_context"> static int hpfs_fill_super(struct super_block *s, void *options, int silent)</span>
 
 	int o;
 
<span class="p_del">-	save_mount_options(s, options);</span>
<span class="p_del">-</span>
 	sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);
 	if (!sbi) {
 		return -ENOMEM;
<span class="p_header">diff --git a/fs/namespace.c b/fs/namespace.c</span>
<span class="p_header">index 506a9921ea46..c957d044b13f 100644</span>
<span class="p_header">--- a/fs/namespace.c</span>
<span class="p_header">+++ b/fs/namespace.c</span>
<span class="p_chunk">@@ -3072,7 +3072,7 @@</span> <span class="p_context"> static bool fs_fully_visible(struct file_system_type *type, int *new_mnt_flags)</span>
 		list_for_each_entry(child, &amp;mnt-&gt;mnt_mounts, mnt_child) {
 			struct inode *inode = child-&gt;mnt_mountpoint-&gt;d_inode;
 			/* Only worry about locked mounts */
<span class="p_del">-			if (!(mnt-&gt;mnt.mnt_flags &amp; MNT_LOCKED))</span>
<span class="p_add">+			if (!(child-&gt;mnt.mnt_flags &amp; MNT_LOCKED))</span>
 				continue;
 			/* Is the directory permanetly empty? */
 			if (!is_empty_dir_inode(inode))
<span class="p_header">diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c</span>
<span class="p_header">index 82253864acf7..c832599669bc 100644</span>
<span class="p_header">--- a/fs/nfs/dir.c</span>
<span class="p_header">+++ b/fs/nfs/dir.c</span>
<span class="p_chunk">@@ -1492,9 +1492,9 @@</span> <span class="p_context"> int nfs_atomic_open(struct inode *dir, struct dentry *dentry,</span>
 		err = PTR_ERR(inode);
 		trace_nfs_atomic_open_exit(dir, ctx, open_flags, err);
 		put_nfs_open_context(ctx);
<span class="p_add">+		d_drop(dentry);</span>
 		switch (err) {
 		case -ENOENT:
<span class="p_del">-			d_drop(dentry);</span>
 			d_add(dentry, NULL);
 			break;
 		case -EISDIR:
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index 864b3214cc89..7dc0bf73e76a 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -2620,12 +2620,11 @@</span> <span class="p_context"> static void nfs4_close_prepare(struct rpc_task *task, void *data)</span>
 			call_close |= is_wronly;
 		else if (is_wronly)
 			calldata-&gt;arg.fmode |= FMODE_WRITE;
<span class="p_add">+		if (calldata-&gt;arg.fmode != (FMODE_READ|FMODE_WRITE))</span>
<span class="p_add">+			call_close |= is_rdwr;</span>
 	} else if (is_rdwr)
 		calldata-&gt;arg.fmode |= FMODE_READ|FMODE_WRITE;
 
<span class="p_del">-	if (calldata-&gt;arg.fmode == 0)</span>
<span class="p_del">-		call_close |= is_rdwr;</span>
<span class="p_del">-</span>
 	if (!nfs4_valid_open_stateid(state))
 		call_close = 0;
 	spin_unlock(&amp;state-&gt;owner-&gt;so_lock);
<span class="p_header">diff --git a/fs/nfsd/nfs2acl.c b/fs/nfsd/nfs2acl.c</span>
<span class="p_header">index 12b023a7ab7d..e5c420c130c6 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs2acl.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs2acl.c</span>
<span class="p_chunk">@@ -104,22 +104,21 @@</span> <span class="p_context"> static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,</span>
 		goto out;
 
 	inode = fh-&gt;fh_dentry-&gt;d_inode;
<span class="p_del">-	if (!IS_POSIXACL(inode) || !inode-&gt;i_op-&gt;set_acl) {</span>
<span class="p_del">-		error = -EOPNOTSUPP;</span>
<span class="p_del">-		goto out_errno;</span>
<span class="p_del">-	}</span>
 
 	error = fh_want_write(fh);
 	if (error)
 		goto out_errno;
 
<span class="p_del">-	error = inode-&gt;i_op-&gt;set_acl(inode, argp-&gt;acl_access, ACL_TYPE_ACCESS);</span>
<span class="p_add">+	fh_lock(fh);</span>
<span class="p_add">+</span>
<span class="p_add">+	error = set_posix_acl(inode, ACL_TYPE_ACCESS, argp-&gt;acl_access);</span>
 	if (error)
<span class="p_del">-		goto out_drop_write;</span>
<span class="p_del">-	error = inode-&gt;i_op-&gt;set_acl(inode, argp-&gt;acl_default,</span>
<span class="p_del">-				     ACL_TYPE_DEFAULT);</span>
<span class="p_add">+		goto out_drop_lock;</span>
<span class="p_add">+	error = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp-&gt;acl_default);</span>
 	if (error)
<span class="p_del">-		goto out_drop_write;</span>
<span class="p_add">+		goto out_drop_lock;</span>
<span class="p_add">+</span>
<span class="p_add">+	fh_unlock(fh);</span>
 
 	fh_drop_write(fh);
 
<span class="p_chunk">@@ -131,7 +130,8 @@</span> <span class="p_context"> out:</span>
 	posix_acl_release(argp-&gt;acl_access);
 	posix_acl_release(argp-&gt;acl_default);
 	return nfserr;
<span class="p_del">-out_drop_write:</span>
<span class="p_add">+out_drop_lock:</span>
<span class="p_add">+	fh_unlock(fh);</span>
 	fh_drop_write(fh);
 out_errno:
 	nfserr = nfserrno(error);
<span class="p_header">diff --git a/fs/nfsd/nfs3acl.c b/fs/nfsd/nfs3acl.c</span>
<span class="p_header">index 2a514e21dc74..3b90faef79e3 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs3acl.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs3acl.c</span>
<span class="p_chunk">@@ -95,22 +95,20 @@</span> <span class="p_context"> static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,</span>
 		goto out;
 
 	inode = fh-&gt;fh_dentry-&gt;d_inode;
<span class="p_del">-	if (!IS_POSIXACL(inode) || !inode-&gt;i_op-&gt;set_acl) {</span>
<span class="p_del">-		error = -EOPNOTSUPP;</span>
<span class="p_del">-		goto out_errno;</span>
<span class="p_del">-	}</span>
 
 	error = fh_want_write(fh);
 	if (error)
 		goto out_errno;
 
<span class="p_del">-	error = inode-&gt;i_op-&gt;set_acl(inode, argp-&gt;acl_access, ACL_TYPE_ACCESS);</span>
<span class="p_add">+	fh_lock(fh);</span>
<span class="p_add">+</span>
<span class="p_add">+	error = set_posix_acl(inode, ACL_TYPE_ACCESS, argp-&gt;acl_access);</span>
 	if (error)
<span class="p_del">-		goto out_drop_write;</span>
<span class="p_del">-	error = inode-&gt;i_op-&gt;set_acl(inode, argp-&gt;acl_default,</span>
<span class="p_del">-				     ACL_TYPE_DEFAULT);</span>
<span class="p_add">+		goto out_drop_lock;</span>
<span class="p_add">+	error = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp-&gt;acl_default);</span>
 
<span class="p_del">-out_drop_write:</span>
<span class="p_add">+out_drop_lock:</span>
<span class="p_add">+	fh_unlock(fh);</span>
 	fh_drop_write(fh);
 out_errno:
 	nfserr = nfserrno(error);
<span class="p_header">diff --git a/fs/nfsd/nfs4acl.c b/fs/nfsd/nfs4acl.c</span>
<span class="p_header">index d714156a19fd..5a2c9660099d 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4acl.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4acl.c</span>
<span class="p_chunk">@@ -822,9 +822,6 @@</span> <span class="p_context"> nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,</span>
 	dentry = fhp-&gt;fh_dentry;
 	inode = dentry-&gt;d_inode;
 
<span class="p_del">-	if (!inode-&gt;i_op-&gt;set_acl || !IS_POSIXACL(inode))</span>
<span class="p_del">-		return nfserr_attrnotsupp;</span>
<span class="p_del">-</span>
 	if (S_ISDIR(inode-&gt;i_mode))
 		flags = NFS4_ACL_DIR;
 
<span class="p_chunk">@@ -834,16 +831,19 @@</span> <span class="p_context"> nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,</span>
 	if (host_error &lt; 0)
 		goto out_nfserr;
 
<span class="p_del">-	host_error = inode-&gt;i_op-&gt;set_acl(inode, pacl, ACL_TYPE_ACCESS);</span>
<span class="p_add">+	fh_lock(fhp);</span>
<span class="p_add">+</span>
<span class="p_add">+	host_error = set_posix_acl(inode, ACL_TYPE_ACCESS, pacl);</span>
 	if (host_error &lt; 0)
<span class="p_del">-		goto out_release;</span>
<span class="p_add">+		goto out_drop_lock;</span>
 
 	if (S_ISDIR(inode-&gt;i_mode)) {
<span class="p_del">-		host_error = inode-&gt;i_op-&gt;set_acl(inode, dpacl,</span>
<span class="p_del">-						  ACL_TYPE_DEFAULT);</span>
<span class="p_add">+		host_error = set_posix_acl(inode, ACL_TYPE_DEFAULT, dpacl);</span>
 	}
 
<span class="p_del">-out_release:</span>
<span class="p_add">+out_drop_lock:</span>
<span class="p_add">+	fh_unlock(fhp);</span>
<span class="p_add">+</span>
 	posix_acl_release(pacl);
 	posix_acl_release(dpacl);
 out_nfserr:
<span class="p_header">diff --git a/fs/nilfs2/the_nilfs.c b/fs/nilfs2/the_nilfs.c</span>
<span class="p_header">index 8ba8229ba076..06ece8cccaee 100644</span>
<span class="p_header">--- a/fs/nilfs2/the_nilfs.c</span>
<span class="p_header">+++ b/fs/nilfs2/the_nilfs.c</span>
<span class="p_chunk">@@ -441,7 +441,7 @@</span> <span class="p_context"> static int nilfs_valid_sb(struct nilfs_super_block *sbp)</span>
 	if (!sbp || le16_to_cpu(sbp-&gt;s_magic) != NILFS_SUPER_MAGIC)
 		return 0;
 	bytes = le16_to_cpu(sbp-&gt;s_bytes);
<span class="p_del">-	if (bytes &gt; BLOCK_SIZE)</span>
<span class="p_add">+	if (bytes &lt; sumoff + 4 || bytes &gt; BLOCK_SIZE)</span>
 		return 0;
 	crc = crc32_le(le32_to_cpu(sbp-&gt;s_crc_seed), (unsigned char *)sbp,
 		       sumoff);
<span class="p_header">diff --git a/fs/posix_acl.c b/fs/posix_acl.c</span>
<span class="p_header">index 0855f772cd41..b1c249115aaa 100644</span>
<span class="p_header">--- a/fs/posix_acl.c</span>
<span class="p_header">+++ b/fs/posix_acl.c</span>
<span class="p_chunk">@@ -787,38 +787,42 @@</span> <span class="p_context"> posix_acl_xattr_get(struct dentry *dentry, const char *name,</span>
 	return error;
 }
 
<span class="p_del">-static int</span>
<span class="p_del">-posix_acl_xattr_set(struct dentry *dentry, const char *name,</span>
<span class="p_del">-		const void *value, size_t size, int flags, int type)</span>
<span class="p_add">+int</span>
<span class="p_add">+set_posix_acl(struct inode *inode, int type, struct posix_acl *acl)</span>
 {
<span class="p_del">-	struct inode *inode = dentry-&gt;d_inode;</span>
<span class="p_del">-	struct posix_acl *acl = NULL;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
 	if (!IS_POSIXACL(inode))
 		return -EOPNOTSUPP;
 	if (!inode-&gt;i_op-&gt;set_acl)
 		return -EOPNOTSUPP;
 
 	if (type == ACL_TYPE_DEFAULT &amp;&amp; !S_ISDIR(inode-&gt;i_mode))
<span class="p_del">-		return value ? -EACCES : 0;</span>
<span class="p_add">+		return acl ? -EACCES : 0;</span>
 	if (!inode_owner_or_capable(inode))
 		return -EPERM;
 
<span class="p_add">+	if (acl) {</span>
<span class="p_add">+		int ret = posix_acl_valid(acl);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return inode-&gt;i_op-&gt;set_acl(inode, acl, type);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(set_posix_acl);</span>
<span class="p_add">+</span>
<span class="p_add">+static int</span>
<span class="p_add">+posix_acl_xattr_set(struct dentry *dentry, const char *name,</span>
<span class="p_add">+               const void *value, size_t size, int flags, int type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct inode *inode = dentry-&gt;d_inode;</span>
<span class="p_add">+	struct posix_acl *acl = NULL;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
 	if (value) {
 		acl = posix_acl_from_xattr(&amp;init_user_ns, value, size);
 		if (IS_ERR(acl))
 			return PTR_ERR(acl);
<span class="p_del">-</span>
<span class="p_del">-		if (acl) {</span>
<span class="p_del">-			ret = posix_acl_valid(acl);</span>
<span class="p_del">-			if (ret)</span>
<span class="p_del">-				goto out;</span>
<span class="p_del">-		}</span>
 	}
<span class="p_del">-</span>
<span class="p_del">-	ret = inode-&gt;i_op-&gt;set_acl(inode, acl, type);</span>
<span class="p_del">-out:</span>
<span class="p_add">+	ret = set_posix_acl(inode, type, acl);</span>
 	posix_acl_release(acl);
 	return ret;
 }
<span class="p_header">diff --git a/fs/proc/root.c b/fs/proc/root.c</span>
<span class="p_header">index dd77e1483196..98992cb44c35 100644</span>
<span class="p_header">--- a/fs/proc/root.c</span>
<span class="p_header">+++ b/fs/proc/root.c</span>
<span class="p_chunk">@@ -121,6 +121,13 @@</span> <span class="p_context"> static struct dentry *proc_mount(struct file_system_type *fs_type,</span>
 	if (IS_ERR(sb))
 		return ERR_CAST(sb);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * procfs isn&#39;t actually a stacking filesystem; however, there is</span>
<span class="p_add">+	 * too much magic going on inside it to permit stacking things on</span>
<span class="p_add">+	 * top of it</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	sb-&gt;s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH;</span>
<span class="p_add">+</span>
 	if (!proc_parse_options(options, ns)) {
 		deactivate_locked_super(sb);
 		return ERR_PTR(-EINVAL);
<span class="p_header">diff --git a/fs/ubifs/file.c b/fs/ubifs/file.c</span>
<span class="p_header">index b5b593c45270..d37140e5b722 100644</span>
<span class="p_header">--- a/fs/ubifs/file.c</span>
<span class="p_header">+++ b/fs/ubifs/file.c</span>
<span class="p_chunk">@@ -54,6 +54,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/mount.h&gt;
 #include &lt;linux/namei.h&gt;
 #include &lt;linux/slab.h&gt;
<span class="p_add">+#include &lt;linux/migrate.h&gt;</span>
 
 static int read_block(struct inode *inode, void *addr, unsigned int block,
 		      struct ubifs_data_node *dn)
<span class="p_chunk">@@ -1419,6 +1420,26 @@</span> <span class="p_context"> static int ubifs_set_page_dirty(struct page *page)</span>
 	return ret;
 }
 
<span class="p_add">+#ifdef CONFIG_MIGRATION</span>
<span class="p_add">+static int ubifs_migrate_page(struct address_space *mapping,</span>
<span class="p_add">+		struct page *newpage, struct page *page, enum migrate_mode mode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = migrate_page_move_mapping(mapping, newpage, page, NULL, mode, 0);</span>
<span class="p_add">+	if (rc != MIGRATEPAGE_SUCCESS)</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (PagePrivate(page)) {</span>
<span class="p_add">+		ClearPagePrivate(page);</span>
<span class="p_add">+		SetPagePrivate(newpage);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	migrate_page_copy(newpage, page);</span>
<span class="p_add">+	return MIGRATEPAGE_SUCCESS;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 static int ubifs_releasepage(struct page *page, gfp_t unused_gfp_flags)
 {
 	/*
<span class="p_chunk">@@ -1556,6 +1577,9 @@</span> <span class="p_context"> const struct address_space_operations ubifs_file_address_operations = {</span>
 	.write_end      = ubifs_write_end,
 	.invalidatepage = ubifs_invalidatepage,
 	.set_page_dirty = ubifs_set_page_dirty,
<span class="p_add">+#ifdef CONFIG_MIGRATION</span>
<span class="p_add">+	.migratepage	= ubifs_migrate_page,</span>
<span class="p_add">+#endif</span>
 	.releasepage    = ubifs_releasepage,
 };
 
<span class="p_header">diff --git a/fs/xfs/xfs_inode.c b/fs/xfs/xfs_inode.c</span>
<span class="p_header">index 634dbe50c292..174379ddf22f 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_inode.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_inode.c</span>
<span class="p_chunk">@@ -3029,13 +3029,14 @@</span> <span class="p_context"> xfs_iflush_cluster(</span>
 		 * We need to check under the i_flags_lock for a valid inode
 		 * here. Skip it if it is not valid or the wrong inode.
 		 */
<span class="p_del">-		spin_lock(&amp;ip-&gt;i_flags_lock);</span>
<span class="p_del">-		if (!ip-&gt;i_ino ||</span>
<span class="p_add">+		spin_lock(&amp;iq-&gt;i_flags_lock);</span>
<span class="p_add">+		if (!iq-&gt;i_ino ||</span>
<span class="p_add">+		    __xfs_iflags_test(iq, XFS_ISTALE) ||</span>
 		    (XFS_INO_TO_AGINO(mp, iq-&gt;i_ino) &amp; mask) != first_index) {
<span class="p_del">-			spin_unlock(&amp;ip-&gt;i_flags_lock);</span>
<span class="p_add">+			spin_unlock(&amp;iq-&gt;i_flags_lock);</span>
 			continue;
 		}
<span class="p_del">-		spin_unlock(&amp;ip-&gt;i_flags_lock);</span>
<span class="p_add">+		spin_unlock(&amp;iq-&gt;i_flags_lock);</span>
 
 		/*
 		 * Do an un-protected check to see if the inode is dirty and
<span class="p_chunk">@@ -3151,7 +3152,7 @@</span> <span class="p_context"> xfs_iflush(</span>
 	struct xfs_buf		**bpp)
 {
 	struct xfs_mount	*mp = ip-&gt;i_mount;
<span class="p_del">-	struct xfs_buf		*bp;</span>
<span class="p_add">+	struct xfs_buf		*bp = NULL;</span>
 	struct xfs_dinode	*dip;
 	int			error;
 
<span class="p_chunk">@@ -3193,14 +3194,22 @@</span> <span class="p_context"> xfs_iflush(</span>
 	}
 
 	/*
<span class="p_del">-	 * Get the buffer containing the on-disk inode.</span>
<span class="p_add">+	 * Get the buffer containing the on-disk inode. We are doing a try-lock</span>
<span class="p_add">+	 * operation here, so we may get  an EAGAIN error. In that case, we</span>
<span class="p_add">+	 * simply want to return with the inode still dirty.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * If we get any other error, we effectively have a corruption situation</span>
<span class="p_add">+	 * and we cannot flush the inode, so we treat it the same as failing</span>
<span class="p_add">+	 * xfs_iflush_int().</span>
 	 */
 	error = xfs_imap_to_bp(mp, NULL, &amp;ip-&gt;i_imap, &amp;dip, &amp;bp, XBF_TRYLOCK,
 			       0);
<span class="p_del">-	if (error || !bp) {</span>
<span class="p_add">+	if (error == EAGAIN) {</span>
 		xfs_ifunlock(ip);
 		return error;
 	}
<span class="p_add">+	if (error)</span>
<span class="p_add">+		goto corrupt_out;</span>
 
 	/*
 	 * First flush out the inode that xfs_iflush was called with.
<span class="p_chunk">@@ -3228,7 +3237,8 @@</span> <span class="p_context"> xfs_iflush(</span>
 	return 0;
 
 corrupt_out:
<span class="p_del">-	xfs_buf_relse(bp);</span>
<span class="p_add">+	if (bp)</span>
<span class="p_add">+		xfs_buf_relse(bp);</span>
 	xfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);
 cluster_corrupt_out:
 	error = XFS_ERROR(EFSCORRUPTED);
<span class="p_header">diff --git a/fs/xfs/xfs_super.c b/fs/xfs/xfs_super.c</span>
<span class="p_header">index a4fcd32134fa..2616ddea6756 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_super.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_super.c</span>
<span class="p_chunk">@@ -1250,6 +1250,16 @@</span> <span class="p_context"> xfs_fs_remount(</span>
 
 	/* ro -&gt; rw */
 	if ((mp-&gt;m_flags &amp; XFS_MOUNT_RDONLY) &amp;&amp; !(*flags &amp; MS_RDONLY)) {
<span class="p_add">+		if (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 &amp;&amp;</span>
<span class="p_add">+		    xfs_sb_has_ro_compat_feature(sbp,</span>
<span class="p_add">+					XFS_SB_FEAT_RO_COMPAT_UNKNOWN)) {</span>
<span class="p_add">+			xfs_warn(mp,</span>
<span class="p_add">+&quot;ro-&gt;rw transition prohibited on unknown (0x%x) ro-compat filesystem&quot;,</span>
<span class="p_add">+				(sbp-&gt;sb_features_ro_compat &amp;</span>
<span class="p_add">+					XFS_SB_FEAT_RO_COMPAT_UNKNOWN));</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		mp-&gt;m_flags &amp;= ~XFS_MOUNT_RDONLY;
 
 		/*
<span class="p_header">diff --git a/include/asm-generic/preempt.h b/include/asm-generic/preempt.h</span>
<span class="p_header">index 54352f4dde1a..25c09df2c046 100644</span>
<span class="p_header">--- a/include/asm-generic/preempt.h</span>
<span class="p_header">+++ b/include/asm-generic/preempt.h</span>
<span class="p_chunk">@@ -7,10 +7,10 @@</span> <span class="p_context"></span>
 
 static __always_inline int preempt_count(void)
 {
<span class="p_del">-	return current_thread_info()-&gt;preempt_count;</span>
<span class="p_add">+	return ACCESS_ONCE(current_thread_info()-&gt;preempt_count);</span>
 }
 
<span class="p_del">-static __always_inline int *preempt_count_ptr(void)</span>
<span class="p_add">+static __always_inline volatile int *preempt_count_ptr(void)</span>
 {
 	return &amp;current_thread_info()-&gt;preempt_count;
 }
<span class="p_header">diff --git a/include/linux/device.h b/include/linux/device.h</span>
<span class="p_header">index af424acd393d..81c5be31dd05 100644</span>
<span class="p_header">--- a/include/linux/device.h</span>
<span class="p_header">+++ b/include/linux/device.h</span>
<span class="p_chunk">@@ -1161,8 +1161,11 @@</span> <span class="p_context"> do {									\</span>
 		dev_printk(KERN_DEBUG, dev, fmt, ##__VA_ARGS__);	\
 } while (0)
 #else
<span class="p_del">-#define dev_dbg_ratelimited(dev, fmt, ...)			\</span>
<span class="p_del">-	no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)</span>
<span class="p_add">+#define dev_dbg_ratelimited(dev, fmt, ...)				\</span>
<span class="p_add">+do {									\</span>
<span class="p_add">+	if (0)								\</span>
<span class="p_add">+		dev_printk(KERN_DEBUG, dev, fmt, ##__VA_ARGS__);	\</span>
<span class="p_add">+} while (0)</span>
 #endif
 
 #ifdef VERBOSE_DEBUG
<span class="p_header">diff --git a/include/linux/fs.h b/include/linux/fs.h</span>
<span class="p_header">index e032a8a40c30..545837db9468 100644</span>
<span class="p_header">--- a/include/linux/fs.h</span>
<span class="p_header">+++ b/include/linux/fs.h</span>
<span class="p_chunk">@@ -256,6 +256,12 @@</span> <span class="p_context"> struct iattr {</span>
  */
 #include &lt;linux/quota.h&gt;
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Maximum number of layers of fs stack.  Needs to be limited to</span>
<span class="p_add">+ * prevent kernel stack overflow</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define FILESYSTEM_MAX_STACK_DEPTH 2</span>
<span class="p_add">+</span>
 /** 
  * enum positive_aop_returns - aop return codes with specific semantics
  *
<span class="p_chunk">@@ -1258,6 +1264,11 @@</span> <span class="p_context"> struct super_block {</span>
 	struct list_lru		s_dentry_lru ____cacheline_aligned_in_smp;
 	struct list_lru		s_inode_lru ____cacheline_aligned_in_smp;
 	struct rcu_head		rcu;
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Indicates how deep in a filesystem stack this SB is</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	int s_stack_depth;</span>
 };
 
 extern struct timespec current_fs_time(struct super_block *sb);
<span class="p_header">diff --git a/include/linux/mlx5/driver.h b/include/linux/mlx5/driver.h</span>
<span class="p_header">index fd152032d779..8ab4eac0292b 100644</span>
<span class="p_header">--- a/include/linux/mlx5/driver.h</span>
<span class="p_header">+++ b/include/linux/mlx5/driver.h</span>
<span class="p_chunk">@@ -594,6 +594,7 @@</span> <span class="p_context"> struct mlx5_cmd_work_ent {</span>
 	void		       *uout;
 	int			uout_size;
 	mlx5_cmd_cbk_t		callback;
<span class="p_add">+	struct delayed_work	cb_timeout_work;</span>
 	void		       *context;
 	int			idx;
 	struct completion	done;
<span class="p_header">diff --git a/include/linux/mlx5/qp.h b/include/linux/mlx5/qp.h</span>
<span class="p_header">index 9709b30e2d69..ab1c14a56e6d 100644</span>
<span class="p_header">--- a/include/linux/mlx5/qp.h</span>
<span class="p_header">+++ b/include/linux/mlx5/qp.h</span>
<span class="p_chunk">@@ -140,6 +140,7 @@</span> <span class="p_context"> enum {</span>
 enum {
 	MLX5_FENCE_MODE_NONE			= 0 &lt;&lt; 5,
 	MLX5_FENCE_MODE_INITIATOR_SMALL		= 1 &lt;&lt; 5,
<span class="p_add">+	MLX5_FENCE_MODE_FENCE			= 2 &lt;&lt; 5,</span>
 	MLX5_FENCE_MODE_STRONG_ORDERING		= 3 &lt;&lt; 5,
 	MLX5_FENCE_MODE_SMALL_AND_FENCE		= 4 &lt;&lt; 5,
 };
<span class="p_chunk">@@ -445,6 +446,7 @@</span> <span class="p_context"> struct mlx5_modify_qp_mbox_in {</span>
 	__be32			optparam;
 	u8			rsvd0[4];
 	struct mlx5_qp_context	ctx;
<span class="p_add">+	u8			rsvd2[16];</span>
 };
 
 struct mlx5_modify_qp_mbox_out {
<span class="p_header">diff --git a/include/linux/netfilter/x_tables.h b/include/linux/netfilter/x_tables.h</span>
<span class="p_header">index a3e215bb0241..7741efa43b35 100644</span>
<span class="p_header">--- a/include/linux/netfilter/x_tables.h</span>
<span class="p_header">+++ b/include/linux/netfilter/x_tables.h</span>
<span class="p_chunk">@@ -239,11 +239,18 @@</span> <span class="p_context"> void xt_unregister_match(struct xt_match *target);</span>
 int xt_register_matches(struct xt_match *match, unsigned int n);
 void xt_unregister_matches(struct xt_match *match, unsigned int n);
 
<span class="p_add">+int xt_check_entry_offsets(const void *base, const char *elems,</span>
<span class="p_add">+			   unsigned int target_offset,</span>
<span class="p_add">+			   unsigned int next_offset);</span>
<span class="p_add">+</span>
 int xt_check_match(struct xt_mtchk_param *, unsigned int size, u_int8_t proto,
 		   bool inv_proto);
 int xt_check_target(struct xt_tgchk_param *, unsigned int size, u_int8_t proto,
 		    bool inv_proto);
 
<span class="p_add">+void *xt_copy_counters_from_user(const void __user *user, unsigned int len,</span>
<span class="p_add">+				 struct xt_counters_info *info, bool compat);</span>
<span class="p_add">+</span>
 struct xt_table *xt_register_table(struct net *net,
 				   const struct xt_table *table,
 				   struct xt_table_info *bootstrap,
<span class="p_chunk">@@ -421,7 +428,7 @@</span> <span class="p_context"> void xt_compat_init_offsets(u_int8_t af, unsigned int number);</span>
 int xt_compat_calc_jump(u_int8_t af, unsigned int offset);
 
 int xt_compat_match_offset(const struct xt_match *match);
<span class="p_del">-int xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,</span>
<span class="p_add">+void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,</span>
 			      unsigned int *size);
 int xt_compat_match_to_user(const struct xt_entry_match *m,
 			    void __user **dstptr, unsigned int *size);
<span class="p_chunk">@@ -431,6 +438,9 @@</span> <span class="p_context"> void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,</span>
 				unsigned int *size);
 int xt_compat_target_to_user(const struct xt_entry_target *t,
 			     void __user **dstptr, unsigned int *size);
<span class="p_add">+int xt_compat_check_entry_offsets(const void *base, const char *elems,</span>
<span class="p_add">+				  unsigned int target_offset,</span>
<span class="p_add">+				  unsigned int next_offset);</span>
 
 #endif /* CONFIG_COMPAT */
 #endif /* _X_TABLES_H */
<span class="p_header">diff --git a/include/linux/sunrpc/msg_prot.h b/include/linux/sunrpc/msg_prot.h</span>
<span class="p_header">index aadc6a04e1ac..9dd47cba12f2 100644</span>
<span class="p_header">--- a/include/linux/sunrpc/msg_prot.h</span>
<span class="p_header">+++ b/include/linux/sunrpc/msg_prot.h</span>
<span class="p_chunk">@@ -152,9 +152,9 @@</span> <span class="p_context"> typedef __be32	rpc_fraghdr;</span>
 
 /*
  * Note that RFC 1833 does not put any size restrictions on the
<span class="p_del">- * netid string, but all currently defined netid&#39;s fit in 4 bytes.</span>
<span class="p_add">+ * netid string, but all currently defined netid&#39;s fit in 5 bytes.</span>
  */
<span class="p_del">-#define RPCBIND_MAXNETIDLEN	(4u)</span>
<span class="p_add">+#define RPCBIND_MAXNETIDLEN	(5u)</span>
 
 /*
  * Universal addresses are introduced in RFC 1833 and further spelled
<span class="p_header">diff --git a/include/net/codel.h b/include/net/codel.h</span>
<span class="p_header">index fe0eab32ce76..6262ce0517f4 100644</span>
<span class="p_header">--- a/include/net/codel.h</span>
<span class="p_header">+++ b/include/net/codel.h</span>
<span class="p_chunk">@@ -158,11 +158,13 @@</span> <span class="p_context"> struct codel_vars {</span>
  * struct codel_stats - contains codel shared variables and stats
  * @maxpacket:	largest packet we&#39;ve seen so far
  * @drop_count:	temp count of dropped packets in dequeue()
<span class="p_add">+ * @drop_len:	bytes of dropped packets in dequeue()</span>
  * ecn_mark:	number of packets we ECN marked instead of dropping
  */
 struct codel_stats {
 	u32		maxpacket;
 	u32		drop_count;
<span class="p_add">+	u32		drop_len;</span>
 	u32		ecn_mark;
 };
 
<span class="p_chunk">@@ -297,6 +299,7 @@</span> <span class="p_context"> static struct sk_buff *codel_dequeue(struct Qdisc *sch,</span>
 								  vars-&gt;rec_inv_sqrt);
 					goto end;
 				}
<span class="p_add">+				stats-&gt;drop_len += qdisc_pkt_len(skb);</span>
 				qdisc_drop(skb, sch);
 				stats-&gt;drop_count++;
 				skb = dequeue_func(vars, sch);
<span class="p_chunk">@@ -319,6 +322,7 @@</span> <span class="p_context"> static struct sk_buff *codel_dequeue(struct Qdisc *sch,</span>
 		if (params-&gt;ecn &amp;&amp; INET_ECN_set_ce(skb)) {
 			stats-&gt;ecn_mark++;
 		} else {
<span class="p_add">+			stats-&gt;drop_len += qdisc_pkt_len(skb);</span>
 			qdisc_drop(skb, sch);
 			stats-&gt;drop_count++;
 
<span class="p_header">diff --git a/include/net/sch_generic.h b/include/net/sch_generic.h</span>
<span class="p_header">index 624f9857c83e..ee2060f507b7 100644</span>
<span class="p_header">--- a/include/net/sch_generic.h</span>
<span class="p_header">+++ b/include/net/sch_generic.h</span>
<span class="p_chunk">@@ -368,7 +368,8 @@</span> <span class="p_context"> struct Qdisc *dev_graft_qdisc(struct netdev_queue *dev_queue,</span>
 			      struct Qdisc *qdisc);
 void qdisc_reset(struct Qdisc *qdisc);
 void qdisc_destroy(struct Qdisc *qdisc);
<span class="p_del">-void qdisc_tree_decrease_qlen(struct Qdisc *qdisc, unsigned int n);</span>
<span class="p_add">+void qdisc_tree_reduce_backlog(struct Qdisc *qdisc, unsigned int n,</span>
<span class="p_add">+			       unsigned int len);</span>
 struct Qdisc *qdisc_alloc(struct netdev_queue *dev_queue,
 			  const struct Qdisc_ops *ops);
 struct Qdisc *qdisc_create_dflt(struct netdev_queue *dev_queue,
<span class="p_chunk">@@ -608,6 +609,23 @@</span> <span class="p_context"> static inline void qdisc_reset_queue(struct Qdisc *sch)</span>
 	sch-&gt;qstats.backlog = 0;
 }
 
<span class="p_add">+static inline struct Qdisc *qdisc_replace(struct Qdisc *sch, struct Qdisc *new,</span>
<span class="p_add">+					  struct Qdisc **pold)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct Qdisc *old;</span>
<span class="p_add">+</span>
<span class="p_add">+	sch_tree_lock(sch);</span>
<span class="p_add">+	old = *pold;</span>
<span class="p_add">+	*pold = new;</span>
<span class="p_add">+	if (old != NULL) {</span>
<span class="p_add">+		qdisc_tree_reduce_backlog(old, old-&gt;q.qlen, old-&gt;qstats.backlog);</span>
<span class="p_add">+		qdisc_reset(old);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	sch_tree_unlock(sch);</span>
<span class="p_add">+</span>
<span class="p_add">+	return old;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline unsigned int __qdisc_queue_drop(struct Qdisc *sch,
 					      struct sk_buff_head *list)
 {
<span class="p_header">diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h</span>
<span class="p_header">index 758bc9f0f399..72a1b3aba1a0 100644</span>
<span class="p_header">--- a/include/scsi/scsi_device.h</span>
<span class="p_header">+++ b/include/scsi/scsi_device.h</span>
<span class="p_chunk">@@ -264,6 +264,7 @@</span> <span class="p_context"> struct scsi_dh_data {</span>
 enum scsi_target_state {
 	STARGET_CREATED = 1,
 	STARGET_RUNNING,
<span class="p_add">+	STARGET_REMOVE,</span>
 	STARGET_DEL,
 };
 
<span class="p_header">diff --git a/kernel/auditsc.c b/kernel/auditsc.c</span>
<span class="p_header">index 21eae3c05ec0..4660027476d2 100644</span>
<span class="p_header">--- a/kernel/auditsc.c</span>
<span class="p_header">+++ b/kernel/auditsc.c</span>
<span class="p_chunk">@@ -71,6 +71,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/fs_struct.h&gt;
 #include &lt;linux/compat.h&gt;
 #include &lt;linux/ctype.h&gt;
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 
 #include &quot;audit.h&quot;
 
<span class="p_chunk">@@ -79,7 +80,8 @@</span> <span class="p_context"></span>
 #define AUDITSC_SUCCESS 1
 #define AUDITSC_FAILURE 2
 
<span class="p_del">-/* no execve audit message should be longer than this (userspace limits) */</span>
<span class="p_add">+/* no execve audit message should be longer than this (userspace limits),</span>
<span class="p_add">+ * see the note near the top of audit_log_execve_info() about this value */</span>
 #define MAX_EXECVE_AUDIT_LEN 7500
 
 /* max length to print of cmdline/proctitle value during audit */
<span class="p_chunk">@@ -1015,185 +1017,178 @@</span> <span class="p_context"> static int audit_log_pid_context(struct audit_context *context, pid_t pid,</span>
 	return rc;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * to_send and len_sent accounting are very loose estimates.  We aren&#39;t</span>
<span class="p_del">- * really worried about a hard cap to MAX_EXECVE_AUDIT_LEN so much as being</span>
<span class="p_del">- * within about 500 bytes (next page boundary)</span>
<span class="p_del">- *</span>
<span class="p_del">- * why snprintf?  an int is up to 12 digits long.  if we just assumed when</span>
<span class="p_del">- * logging that a[%d]= was going to be 16 characters long we would be wasting</span>
<span class="p_del">- * space in every audit message.  In one 7500 byte message we can log up to</span>
<span class="p_del">- * about 1000 min size arguments.  That comes down to about 50% waste of space</span>
<span class="p_del">- * if we didn&#39;t do the snprintf to find out how long arg_num_len was.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int audit_log_single_execve_arg(struct audit_context *context,</span>
<span class="p_del">-					struct audit_buffer **ab,</span>
<span class="p_del">-					int arg_num,</span>
<span class="p_del">-					size_t *len_sent,</span>
<span class="p_del">-					const char __user *p,</span>
<span class="p_del">-					char *buf)</span>
<span class="p_del">-{</span>
<span class="p_del">-	char arg_num_len_buf[12];</span>
<span class="p_del">-	const char __user *tmp_p = p;</span>
<span class="p_del">-	/* how many digits are in arg_num? 5 is the length of &#39; a=&quot;&quot;&#39; */</span>
<span class="p_del">-	size_t arg_num_len = snprintf(arg_num_len_buf, 12, &quot;%d&quot;, arg_num) + 5;</span>
<span class="p_del">-	size_t len, len_left, to_send;</span>
<span class="p_del">-	size_t max_execve_audit_len = MAX_EXECVE_AUDIT_LEN;</span>
<span class="p_del">-	unsigned int i, has_cntl = 0, too_long = 0;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* strnlen_user includes the null we don&#39;t want to send */</span>
<span class="p_del">-	len_left = len = strnlen_user(p, MAX_ARG_STRLEN) - 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We just created this mm, if we can&#39;t find the strings</span>
<span class="p_del">-	 * we just copied into it something is _very_ wrong. Similar</span>
<span class="p_del">-	 * for strings that are too long, we should not have created</span>
<span class="p_del">-	 * any.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (unlikely((len == -1) || len &gt; MAX_ARG_STRLEN - 1)) {</span>
<span class="p_del">-		WARN_ON(1);</span>
<span class="p_del">-		send_sig(SIGKILL, current, 0);</span>
<span class="p_del">-		return -1;</span>
<span class="p_add">+static void audit_log_execve_info(struct audit_context *context,</span>
<span class="p_add">+				  struct audit_buffer **ab)</span>
<span class="p_add">+{</span>
<span class="p_add">+	long len_max;</span>
<span class="p_add">+	long len_rem;</span>
<span class="p_add">+	long len_full;</span>
<span class="p_add">+	long len_buf;</span>
<span class="p_add">+	long len_abuf;</span>
<span class="p_add">+	long len_tmp;</span>
<span class="p_add">+	bool require_data;</span>
<span class="p_add">+	bool encode;</span>
<span class="p_add">+	unsigned int iter;</span>
<span class="p_add">+	unsigned int arg;</span>
<span class="p_add">+	char *buf_head;</span>
<span class="p_add">+	char *buf;</span>
<span class="p_add">+	const char __user *p = (const char __user *)current-&gt;mm-&gt;arg_start;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* NOTE: this buffer needs to be large enough to hold all the non-arg</span>
<span class="p_add">+	 *       data we put in the audit record for this argument (see the</span>
<span class="p_add">+	 *       code below) ... at this point in time 96 is plenty */</span>
<span class="p_add">+	char abuf[96];</span>
<span class="p_add">+</span>
<span class="p_add">+	/* NOTE: we set MAX_EXECVE_AUDIT_LEN to a rather arbitrary limit, the</span>
<span class="p_add">+	 *       current value of 7500 is not as important as the fact that it</span>
<span class="p_add">+	 *       is less than 8k, a setting of 7500 gives us plenty of wiggle</span>
<span class="p_add">+	 *       room if we go over a little bit in the logging below */</span>
<span class="p_add">+	WARN_ON_ONCE(MAX_EXECVE_AUDIT_LEN &gt; 7500);</span>
<span class="p_add">+	len_max = MAX_EXECVE_AUDIT_LEN;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* scratch buffer to hold the userspace args */</span>
<span class="p_add">+	buf_head = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);</span>
<span class="p_add">+	if (!buf_head) {</span>
<span class="p_add">+		audit_panic(&quot;out of memory for argv string&quot;);</span>
<span class="p_add">+		return;</span>
 	}
<span class="p_add">+	buf = buf_head;</span>
<span class="p_add">+</span>
<span class="p_add">+	audit_log_format(*ab, &quot;argc=%d&quot;, context-&gt;execve.argc);</span>
 
<span class="p_del">-	/* walk the whole argument looking for non-ascii chars */</span>
<span class="p_add">+	len_rem = len_max;</span>
<span class="p_add">+	len_buf = 0;</span>
<span class="p_add">+	len_full = 0;</span>
<span class="p_add">+	require_data = true;</span>
<span class="p_add">+	encode = false;</span>
<span class="p_add">+	iter = 0;</span>
<span class="p_add">+	arg = 0;</span>
 	do {
<span class="p_del">-		if (len_left &gt; MAX_EXECVE_AUDIT_LEN)</span>
<span class="p_del">-			to_send = MAX_EXECVE_AUDIT_LEN;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			to_send = len_left;</span>
<span class="p_del">-		ret = copy_from_user(buf, tmp_p, to_send);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * There is no reason for this copy to be short. We just</span>
<span class="p_del">-		 * copied them here, and the mm hasn&#39;t been exposed to user-</span>
<span class="p_del">-		 * space yet.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (ret) {</span>
<span class="p_del">-			WARN_ON(1);</span>
<span class="p_del">-			send_sig(SIGKILL, current, 0);</span>
<span class="p_del">-			return -1;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		buf[to_send] = &#39;\0&#39;;</span>
<span class="p_del">-		has_cntl = audit_string_contains_control(buf, to_send);</span>
<span class="p_del">-		if (has_cntl) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * hex messages get logged as 2 bytes, so we can only</span>
<span class="p_del">-			 * send half as much in each message</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			max_execve_audit_len = MAX_EXECVE_AUDIT_LEN / 2;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		len_left -= to_send;</span>
<span class="p_del">-		tmp_p += to_send;</span>
<span class="p_del">-	} while (len_left &gt; 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	len_left = len;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (len &gt; max_execve_audit_len)</span>
<span class="p_del">-		too_long = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* rewalk the argument actually logging the message */</span>
<span class="p_del">-	for (i = 0; len_left &gt; 0; i++) {</span>
<span class="p_del">-		int room_left;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (len_left &gt; max_execve_audit_len)</span>
<span class="p_del">-			to_send = max_execve_audit_len;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			to_send = len_left;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* do we have space left to send this argument in this ab? */</span>
<span class="p_del">-		room_left = MAX_EXECVE_AUDIT_LEN - arg_num_len - *len_sent;</span>
<span class="p_del">-		if (has_cntl)</span>
<span class="p_del">-			room_left -= (to_send * 2);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			room_left -= to_send;</span>
<span class="p_del">-		if (room_left &lt; 0) {</span>
<span class="p_del">-			*len_sent = 0;</span>
<span class="p_del">-			audit_log_end(*ab);</span>
<span class="p_del">-			*ab = audit_log_start(context, GFP_KERNEL, AUDIT_EXECVE);</span>
<span class="p_del">-			if (!*ab)</span>
<span class="p_del">-				return 0;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		/* NOTE: we don&#39;t ever want to trust this value for anything</span>
<span class="p_add">+		 *       serious, but the audit record format insists we</span>
<span class="p_add">+		 *       provide an argument length for really long arguments,</span>
<span class="p_add">+		 *       e.g. &gt; MAX_EXECVE_AUDIT_LEN, so we have no choice but</span>
<span class="p_add">+		 *       to use strncpy_from_user() to obtain this value for</span>
<span class="p_add">+		 *       recording in the log, although we don&#39;t use it</span>
<span class="p_add">+		 *       anywhere here to avoid a double-fetch problem */</span>
<span class="p_add">+		if (len_full == 0)</span>
<span class="p_add">+			len_full = strnlen_user(p, MAX_ARG_STRLEN) - 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* read more data from userspace */</span>
<span class="p_add">+		if (require_data) {</span>
<span class="p_add">+			/* can we make more room in the buffer? */</span>
<span class="p_add">+			if (buf != buf_head) {</span>
<span class="p_add">+				memmove(buf_head, buf, len_buf);</span>
<span class="p_add">+				buf = buf_head;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			/* fetch as much as we can of the argument */</span>
<span class="p_add">+			len_tmp = strncpy_from_user(&amp;buf_head[len_buf], p,</span>
<span class="p_add">+						    len_max - len_buf);</span>
<span class="p_add">+			if (len_tmp == -EFAULT) {</span>
<span class="p_add">+				/* unable to copy from userspace */</span>
<span class="p_add">+				send_sig(SIGKILL, current, 0);</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+			} else if (len_tmp == (len_max - len_buf)) {</span>
<span class="p_add">+				/* buffer is not large enough */</span>
<span class="p_add">+				require_data = true;</span>
<span class="p_add">+				/* NOTE: if we are going to span multiple</span>
<span class="p_add">+				 *       buffers force the encoding so we stand</span>
<span class="p_add">+				 *       a chance at a sane len_full value and</span>
<span class="p_add">+				 *       consistent record encoding */</span>
<span class="p_add">+				encode = true;</span>
<span class="p_add">+				len_full = len_full * 2;</span>
<span class="p_add">+				p += len_tmp;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				require_data = false;</span>
<span class="p_add">+				if (!encode)</span>
<span class="p_add">+					encode = audit_string_contains_control(</span>
<span class="p_add">+								buf, len_tmp);</span>
<span class="p_add">+				/* try to use a trusted value for len_full */</span>
<span class="p_add">+				if (len_full &lt; len_max)</span>
<span class="p_add">+					len_full = (encode ?</span>
<span class="p_add">+						    len_tmp * 2 : len_tmp);</span>
<span class="p_add">+				p += len_tmp + 1;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			len_buf += len_tmp;</span>
<span class="p_add">+			buf_head[len_buf] = &#39;\0&#39;;</span>
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * first record needs to say how long the original string was</span>
<span class="p_del">-		 * so we can be sure nothing was lost.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if ((i == 0) &amp;&amp; (too_long))</span>
<span class="p_del">-			audit_log_format(*ab, &quot; a%d_len=%zu&quot;, arg_num,</span>
<span class="p_del">-					 has_cntl ? 2*len : len);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * normally arguments are small enough to fit and we already</span>
<span class="p_del">-		 * filled buf above when we checked for control characters</span>
<span class="p_del">-		 * so don&#39;t bother with another copy_from_user</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (len &gt;= max_execve_audit_len)</span>
<span class="p_del">-			ret = copy_from_user(buf, p, to_send);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			ret = 0;</span>
<span class="p_del">-		if (ret) {</span>
<span class="p_del">-			WARN_ON(1);</span>
<span class="p_del">-			send_sig(SIGKILL, current, 0);</span>
<span class="p_del">-			return -1;</span>
<span class="p_add">+			/* length of the buffer in the audit record? */</span>
<span class="p_add">+			len_abuf = (encode ? len_buf * 2 : len_buf + 2);</span>
 		}
<span class="p_del">-		buf[to_send] = &#39;\0&#39;;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* actually log it */</span>
<span class="p_del">-		audit_log_format(*ab, &quot; a%d&quot;, arg_num);</span>
<span class="p_del">-		if (too_long)</span>
<span class="p_del">-			audit_log_format(*ab, &quot;[%d]&quot;, i);</span>
<span class="p_del">-		audit_log_format(*ab, &quot;=&quot;);</span>
<span class="p_del">-		if (has_cntl)</span>
<span class="p_del">-			audit_log_n_hex(*ab, buf, to_send);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			audit_log_string(*ab, buf);</span>
<span class="p_del">-</span>
<span class="p_del">-		p += to_send;</span>
<span class="p_del">-		len_left -= to_send;</span>
<span class="p_del">-		*len_sent += arg_num_len;</span>
<span class="p_del">-		if (has_cntl)</span>
<span class="p_del">-			*len_sent += to_send * 2;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			*len_sent += to_send;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	/* include the null we didn&#39;t log */</span>
<span class="p_del">-	return len + 1;</span>
<span class="p_del">-}</span>
 
<span class="p_del">-static void audit_log_execve_info(struct audit_context *context,</span>
<span class="p_del">-				  struct audit_buffer **ab)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i, len;</span>
<span class="p_del">-	size_t len_sent = 0;</span>
<span class="p_del">-	const char __user *p;</span>
<span class="p_del">-	char *buf;</span>
<span class="p_add">+		/* write as much as we can to the audit log */</span>
<span class="p_add">+		if (len_buf &gt; 0) {</span>
<span class="p_add">+			/* NOTE: some magic numbers here - basically if we</span>
<span class="p_add">+			 *       can&#39;t fit a reasonable amount of data into the</span>
<span class="p_add">+			 *       existing audit buffer, flush it and start with</span>
<span class="p_add">+			 *       a new buffer */</span>
<span class="p_add">+			if ((sizeof(abuf) + 8) &gt; len_rem) {</span>
<span class="p_add">+				len_rem = len_max;</span>
<span class="p_add">+				audit_log_end(*ab);</span>
<span class="p_add">+				*ab = audit_log_start(context,</span>
<span class="p_add">+						      GFP_KERNEL, AUDIT_EXECVE);</span>
<span class="p_add">+				if (!*ab)</span>
<span class="p_add">+					goto out;</span>
<span class="p_add">+			}</span>
 
<span class="p_del">-	p = (const char __user *)current-&gt;mm-&gt;arg_start;</span>
<span class="p_add">+			/* create the non-arg portion of the arg record */</span>
<span class="p_add">+			len_tmp = 0;</span>
<span class="p_add">+			if (require_data || (iter &gt; 0) ||</span>
<span class="p_add">+			    ((len_abuf + sizeof(abuf)) &gt; len_rem)) {</span>
<span class="p_add">+				if (iter == 0) {</span>
<span class="p_add">+					len_tmp += snprintf(&amp;abuf[len_tmp],</span>
<span class="p_add">+							sizeof(abuf) - len_tmp,</span>
<span class="p_add">+							&quot; a%d_len=%lu&quot;,</span>
<span class="p_add">+							arg, len_full);</span>
<span class="p_add">+				}</span>
<span class="p_add">+				len_tmp += snprintf(&amp;abuf[len_tmp],</span>
<span class="p_add">+						    sizeof(abuf) - len_tmp,</span>
<span class="p_add">+						    &quot; a%d[%d]=&quot;, arg, iter++);</span>
<span class="p_add">+			} else</span>
<span class="p_add">+				len_tmp += snprintf(&amp;abuf[len_tmp],</span>
<span class="p_add">+						    sizeof(abuf) - len_tmp,</span>
<span class="p_add">+						    &quot; a%d=&quot;, arg);</span>
<span class="p_add">+			WARN_ON(len_tmp &gt;= sizeof(abuf));</span>
<span class="p_add">+			abuf[sizeof(abuf) - 1] = &#39;\0&#39;;</span>
<span class="p_add">+</span>
<span class="p_add">+			/* log the arg in the audit record */</span>
<span class="p_add">+			audit_log_format(*ab, &quot;%s&quot;, abuf);</span>
<span class="p_add">+			len_rem -= len_tmp;</span>
<span class="p_add">+			len_tmp = len_buf;</span>
<span class="p_add">+			if (encode) {</span>
<span class="p_add">+				if (len_abuf &gt; len_rem)</span>
<span class="p_add">+					len_tmp = len_rem / 2; /* encoding */</span>
<span class="p_add">+				audit_log_n_hex(*ab, buf, len_tmp);</span>
<span class="p_add">+				len_rem -= len_tmp * 2;</span>
<span class="p_add">+				len_abuf -= len_tmp * 2;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				if (len_abuf &gt; len_rem)</span>
<span class="p_add">+					len_tmp = len_rem - 2; /* quotes */</span>
<span class="p_add">+				audit_log_n_string(*ab, buf, len_tmp);</span>
<span class="p_add">+				len_rem -= len_tmp + 2;</span>
<span class="p_add">+				/* don&#39;t subtract the &quot;2&quot; because we still need</span>
<span class="p_add">+				 * to add quotes to the remaining string */</span>
<span class="p_add">+				len_abuf -= len_tmp;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			len_buf -= len_tmp;</span>
<span class="p_add">+			buf += len_tmp;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-	audit_log_format(*ab, &quot;argc=%d&quot;, context-&gt;execve.argc);</span>
<span class="p_add">+		/* ready to move to the next argument? */</span>
<span class="p_add">+		if ((len_buf == 0) &amp;&amp; !require_data) {</span>
<span class="p_add">+			arg++;</span>
<span class="p_add">+			iter = 0;</span>
<span class="p_add">+			len_full = 0;</span>
<span class="p_add">+			require_data = true;</span>
<span class="p_add">+			encode = false;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while (arg &lt; context-&gt;execve.argc);</span>
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * we need some kernel buffer to hold the userspace args.  Just</span>
<span class="p_del">-	 * allocate one big one rather than allocating one of the right size</span>
<span class="p_del">-	 * for every single argument inside audit_log_single_execve_arg()</span>
<span class="p_del">-	 * should be &lt;8k allocation so should be pretty safe.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	buf = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);</span>
<span class="p_del">-	if (!buf) {</span>
<span class="p_del">-		audit_panic(&quot;out of memory for argv string&quot;);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* NOTE: the caller handles the final audit_log_end() call */</span>
 
<span class="p_del">-	for (i = 0; i &lt; context-&gt;execve.argc; i++) {</span>
<span class="p_del">-		len = audit_log_single_execve_arg(context, ab, i,</span>
<span class="p_del">-						  &amp;len_sent, p, buf);</span>
<span class="p_del">-		if (len &lt;= 0)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		p += len;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	kfree(buf);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	kfree(buf_head);</span>
 }
 
 static void show_special(struct audit_context *context, int *call_panic)
<span class="p_header">diff --git a/kernel/exit.c b/kernel/exit.c</span>
<span class="p_header">index ab2472332043..52f4aa336f5e 100644</span>
<span class="p_header">--- a/kernel/exit.c</span>
<span class="p_header">+++ b/kernel/exit.c</span>
<span class="p_chunk">@@ -924,17 +924,28 @@</span> <span class="p_context"> static int eligible_pid(struct wait_opts *wo, struct task_struct *p)</span>
 		task_pid_type(p, wo-&gt;wo_type) == wo-&gt;wo_pid;
 }
 
<span class="p_del">-static int eligible_child(struct wait_opts *wo, struct task_struct *p)</span>
<span class="p_add">+static int</span>
<span class="p_add">+eligible_child(struct wait_opts *wo, bool ptrace, struct task_struct *p)</span>
 {
 	if (!eligible_pid(wo, p))
 		return 0;
<span class="p_del">-	/* Wait for all children (clone and not) if __WALL is set;</span>
<span class="p_del">-	 * otherwise, wait for clone children *only* if __WCLONE is</span>
<span class="p_del">-	 * set; otherwise, wait for non-clone children *only*.  (Note:</span>
<span class="p_del">-	 * A &quot;clone&quot; child here is one that reports to its parent</span>
<span class="p_del">-	 * using a signal other than SIGCHLD.) */</span>
<span class="p_del">-	if (((p-&gt;exit_signal != SIGCHLD) ^ !!(wo-&gt;wo_flags &amp; __WCLONE))</span>
<span class="p_del">-	    &amp;&amp; !(wo-&gt;wo_flags &amp; __WALL))</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Wait for all children (clone and not) if __WALL is set or</span>
<span class="p_add">+	 * if it is traced by us.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ptrace || (wo-&gt;wo_flags &amp; __WALL))</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Otherwise, wait for clone children *only* if __WCLONE is set;</span>
<span class="p_add">+	 * otherwise, wait for non-clone children *only*.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note: a &quot;clone&quot; child here is one that reports to its parent</span>
<span class="p_add">+	 * using a signal other than SIGCHLD, or a non-leader thread which</span>
<span class="p_add">+	 * we can only see if it is traced by us.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((p-&gt;exit_signal != SIGCHLD) ^ !!(wo-&gt;wo_flags &amp; __WCLONE))</span>
 		return 0;
 
 	return 1;
<span class="p_chunk">@@ -1305,7 +1316,7 @@</span> <span class="p_context"> static int wait_consider_task(struct wait_opts *wo, int ptrace,</span>
 	if (unlikely(exit_state == EXIT_DEAD))
 		return 0;
 
<span class="p_del">-	ret = eligible_child(wo, p);</span>
<span class="p_add">+	ret = eligible_child(wo, ptrace, p);</span>
 	if (!ret)
 		return ret;
 
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 8cbf68e6985d..7c90f805e457 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -4548,14 +4548,16 @@</span> <span class="p_context"> void show_state_filter(unsigned long state_filter)</span>
 		/*
 		 * reset the NMI-timeout, listing all files on a slow
 		 * console might take a lot of time:
<span class="p_add">+		 * Also, reset softlockup watchdogs on all CPUs, because</span>
<span class="p_add">+		 * another CPU might be blocked waiting for us to process</span>
<span class="p_add">+		 * an IPI.</span>
 		 */
 		touch_nmi_watchdog();
<span class="p_add">+		touch_all_softlockup_watchdogs();</span>
 		if (!state_filter || (p-&gt;state &amp; state_filter))
 			sched_show_task(p);
 	} while_each_thread(g, p);
 
<span class="p_del">-	touch_all_softlockup_watchdogs();</span>
<span class="p_del">-</span>
 #ifdef CONFIG_SCHED_DEBUG
 	sysrq_sched_debug_show();
 #endif
<span class="p_header">diff --git a/kernel/sched/proc.c b/kernel/sched/proc.c</span>
<span class="p_header">index 16f5a30f9c88..b672d78160cf 100644</span>
<span class="p_header">--- a/kernel/sched/proc.c</span>
<span class="p_header">+++ b/kernel/sched/proc.c</span>
<span class="p_chunk">@@ -104,10 +104,13 @@</span> <span class="p_context"> long calc_load_fold_active(struct rq *this_rq)</span>
 static unsigned long
 calc_load(unsigned long load, unsigned long exp, unsigned long active)
 {
<span class="p_del">-	load *= exp;</span>
<span class="p_del">-	load += active * (FIXED_1 - exp);</span>
<span class="p_del">-	load += 1UL &lt;&lt; (FSHIFT - 1);</span>
<span class="p_del">-	return load &gt;&gt; FSHIFT;</span>
<span class="p_add">+	unsigned long newload;</span>
<span class="p_add">+</span>
<span class="p_add">+	newload = load * exp + active * (FIXED_1 - exp);</span>
<span class="p_add">+	if (active &gt;= load)</span>
<span class="p_add">+		newload += FIXED_1-1;</span>
<span class="p_add">+</span>
<span class="p_add">+	return newload / FIXED_1;</span>
 }
 
 #ifdef CONFIG_NO_HZ_COMMON
<span class="p_header">diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c</span>
<span class="p_header">index 56ce06143148..79bf62b4e740 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer.c</span>
<span class="p_chunk">@@ -466,7 +466,7 @@</span> <span class="p_context"> struct ring_buffer_per_cpu {</span>
 	raw_spinlock_t			reader_lock;	/* serialize readers */
 	arch_spinlock_t			lock;
 	struct lock_class_key		lock_key;
<span class="p_del">-	unsigned int			nr_pages;</span>
<span class="p_add">+	unsigned long			nr_pages;</span>
 	struct list_head		*pages;
 	struct buffer_page		*head_page;	/* read from head */
 	struct buffer_page		*tail_page;	/* write to tail */
<span class="p_chunk">@@ -486,7 +486,7 @@</span> <span class="p_context"> struct ring_buffer_per_cpu {</span>
 	u64				write_stamp;
 	u64				read_stamp;
 	/* ring buffer pages to update, &gt; 0 to add, &lt; 0 to remove */
<span class="p_del">-	int				nr_pages_to_update;</span>
<span class="p_add">+	long				nr_pages_to_update;</span>
 	struct list_head		new_pages; /* new pages to add */
 	struct work_struct		update_pages_work;
 	struct completion		update_done;
<span class="p_chunk">@@ -1165,10 +1165,10 @@</span> <span class="p_context"> static int rb_check_pages(struct ring_buffer_per_cpu *cpu_buffer)</span>
 	return 0;
 }
 
<span class="p_del">-static int __rb_allocate_pages(int nr_pages, struct list_head *pages, int cpu)</span>
<span class="p_add">+static int __rb_allocate_pages(long nr_pages, struct list_head *pages, int cpu)</span>
 {
<span class="p_del">-	int i;</span>
 	struct buffer_page *bpage, *tmp;
<span class="p_add">+	long i;</span>
 
 	for (i = 0; i &lt; nr_pages; i++) {
 		struct page *page;
<span class="p_chunk">@@ -1205,7 +1205,7 @@</span> <span class="p_context"> free_pages:</span>
 }
 
 static int rb_allocate_pages(struct ring_buffer_per_cpu *cpu_buffer,
<span class="p_del">-			     unsigned nr_pages)</span>
<span class="p_add">+			     unsigned long nr_pages)</span>
 {
 	LIST_HEAD(pages);
 
<span class="p_chunk">@@ -1230,7 +1230,7 @@</span> <span class="p_context"> static int rb_allocate_pages(struct ring_buffer_per_cpu *cpu_buffer,</span>
 }
 
 static struct ring_buffer_per_cpu *
<span class="p_del">-rb_allocate_cpu_buffer(struct ring_buffer *buffer, int nr_pages, int cpu)</span>
<span class="p_add">+rb_allocate_cpu_buffer(struct ring_buffer *buffer, long nr_pages, int cpu)</span>
 {
 	struct ring_buffer_per_cpu *cpu_buffer;
 	struct buffer_page *bpage;
<span class="p_chunk">@@ -1330,8 +1330,9 @@</span> <span class="p_context"> struct ring_buffer *__ring_buffer_alloc(unsigned long size, unsigned flags,</span>
 					struct lock_class_key *key)
 {
 	struct ring_buffer *buffer;
<span class="p_add">+	long nr_pages;</span>
 	int bsize;
<span class="p_del">-	int cpu, nr_pages;</span>
<span class="p_add">+	int cpu;</span>
 
 	/* keep it in its own cache line */
 	buffer = kzalloc(ALIGN(sizeof(*buffer), cache_line_size()),
<span class="p_chunk">@@ -1457,12 +1458,12 @@</span> <span class="p_context"> static inline unsigned long rb_page_write(struct buffer_page *bpage)</span>
 }
 
 static int
<span class="p_del">-rb_remove_pages(struct ring_buffer_per_cpu *cpu_buffer, unsigned int nr_pages)</span>
<span class="p_add">+rb_remove_pages(struct ring_buffer_per_cpu *cpu_buffer, unsigned long nr_pages)</span>
 {
 	struct list_head *tail_page, *to_remove, *next_page;
 	struct buffer_page *to_remove_page, *tmp_iter_page;
 	struct buffer_page *last_page, *first_page;
<span class="p_del">-	unsigned int nr_removed;</span>
<span class="p_add">+	unsigned long nr_removed;</span>
 	unsigned long head_bit;
 	int page_entries;
 
<span class="p_chunk">@@ -1679,7 +1680,7 @@</span> <span class="p_context"> int ring_buffer_resize(struct ring_buffer *buffer, unsigned long size,</span>
 			int cpu_id)
 {
 	struct ring_buffer_per_cpu *cpu_buffer;
<span class="p_del">-	unsigned nr_pages;</span>
<span class="p_add">+	unsigned long nr_pages;</span>
 	int cpu, err = 0;
 
 	/*
<span class="p_chunk">@@ -1693,14 +1694,13 @@</span> <span class="p_context"> int ring_buffer_resize(struct ring_buffer *buffer, unsigned long size,</span>
 	    !cpumask_test_cpu(cpu_id, buffer-&gt;cpumask))
 		return size;
 
<span class="p_del">-	size = DIV_ROUND_UP(size, BUF_PAGE_SIZE);</span>
<span class="p_del">-	size *= BUF_PAGE_SIZE;</span>
<span class="p_add">+	nr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);</span>
 
 	/* we need a minimum of two pages */
<span class="p_del">-	if (size &lt; BUF_PAGE_SIZE * 2)</span>
<span class="p_del">-		size = BUF_PAGE_SIZE * 2;</span>
<span class="p_add">+	if (nr_pages &lt; 2)</span>
<span class="p_add">+		nr_pages = 2;</span>
 
<span class="p_del">-	nr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);</span>
<span class="p_add">+	size = nr_pages * BUF_PAGE_SIZE;</span>
 
 	/*
 	 * Don&#39;t succeed if resizing is disabled, as a reader might be
<span class="p_chunk">@@ -4669,8 +4669,9 @@</span> <span class="p_context"> static int rb_cpu_notify(struct notifier_block *self,</span>
 	struct ring_buffer *buffer =
 		container_of(self, struct ring_buffer, cpu_notify);
 	long cpu = (long)hcpu;
<span class="p_del">-	int cpu_i, nr_pages_same;</span>
<span class="p_del">-	unsigned int nr_pages;</span>
<span class="p_add">+	long nr_pages_same;</span>
<span class="p_add">+	int cpu_i;</span>
<span class="p_add">+	unsigned long nr_pages;</span>
 
 	switch (action) {
 	case CPU_UP_PREPARE:
<span class="p_header">diff --git a/kernel/trace/trace_printk.c b/kernel/trace/trace_printk.c</span>
<span class="p_header">index 7b900474209d..6973eeca7d99 100644</span>
<span class="p_header">--- a/kernel/trace/trace_printk.c</span>
<span class="p_header">+++ b/kernel/trace/trace_printk.c</span>
<span class="p_chunk">@@ -38,6 +38,10 @@</span> <span class="p_context"> struct trace_bprintk_fmt {</span>
 static inline struct trace_bprintk_fmt *lookup_format(const char *fmt)
 {
 	struct trace_bprintk_fmt *pos;
<span class="p_add">+</span>
<span class="p_add">+	if (!fmt)</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
 	list_for_each_entry(pos, &amp;trace_bprintk_fmt_list, list) {
 		if (!strcmp(pos-&gt;fmt, fmt))
 			return pos;
<span class="p_chunk">@@ -59,7 +63,8 @@</span> <span class="p_context"> void hold_module_trace_bprintk_format(const char **start, const char **end)</span>
 	for (iter = start; iter &lt; end; iter++) {
 		struct trace_bprintk_fmt *tb_fmt = lookup_format(*iter);
 		if (tb_fmt) {
<span class="p_del">-			*iter = tb_fmt-&gt;fmt;</span>
<span class="p_add">+			if (!IS_ERR(tb_fmt))</span>
<span class="p_add">+				*iter = tb_fmt-&gt;fmt;</span>
 			continue;
 		}
 
<span class="p_header">diff --git a/lib/dma-debug.c b/lib/dma-debug.c</span>
<span class="p_header">index 1cbfc16d0b37..1ba298a9e15d 100644</span>
<span class="p_header">--- a/lib/dma-debug.c</span>
<span class="p_header">+++ b/lib/dma-debug.c</span>
<span class="p_chunk">@@ -646,9 +646,9 @@</span> <span class="p_context"> static struct dma_debug_entry *dma_entry_alloc(void)</span>
 	spin_lock_irqsave(&amp;free_entries_lock, flags);
 
 	if (list_empty(&amp;free_entries)) {
<span class="p_del">-		pr_err(&quot;DMA-API: debugging out of memory - disabling\n&quot;);</span>
 		global_disable = true;
 		spin_unlock_irqrestore(&amp;free_entries_lock, flags);
<span class="p_add">+		pr_err(&quot;DMA-API: debugging out of memory - disabling\n&quot;);</span>
 		return NULL;
 	}
 
<span class="p_header">diff --git a/mm/migrate.c b/mm/migrate.c</span>
<span class="p_header">index 56d273e828d6..5193433d8605 100644</span>
<span class="p_header">--- a/mm/migrate.c</span>
<span class="p_header">+++ b/mm/migrate.c</span>
<span class="p_chunk">@@ -443,6 +443,7 @@</span> <span class="p_context"> int migrate_page_move_mapping(struct address_space *mapping,</span>
 
 	return MIGRATEPAGE_SUCCESS;
 }
<span class="p_add">+EXPORT_SYMBOL(migrate_page_move_mapping);</span>
 
 /*
  * The expected number of remaining references is the same as that
<span class="p_chunk">@@ -591,6 +592,7 @@</span> <span class="p_context"> void migrate_page_copy(struct page *newpage, struct page *page)</span>
 	if (PageWriteback(newpage))
 		end_page_writeback(newpage);
 }
<span class="p_add">+EXPORT_SYMBOL(migrate_page_copy);</span>
 
 /************************************************************
  *                    Migration functions
<span class="p_header">diff --git a/mm/shmem.c b/mm/shmem.c</span>
<span class="p_header">index e53ab3a8a8d3..a2b87affdc23 100644</span>
<span class="p_header">--- a/mm/shmem.c</span>
<span class="p_header">+++ b/mm/shmem.c</span>
<span class="p_chunk">@@ -1865,9 +1865,11 @@</span> <span class="p_context"> static long shmem_fallocate(struct file *file, int mode, loff_t offset,</span>
 									NULL);
 		if (error) {
 			/* Remove the !PageUptodate pages we added */
<span class="p_del">-			shmem_undo_range(inode,</span>
<span class="p_del">-				(loff_t)start &lt;&lt; PAGE_CACHE_SHIFT,</span>
<span class="p_del">-				(loff_t)index &lt;&lt; PAGE_CACHE_SHIFT, true);</span>
<span class="p_add">+			if (index &gt; start) {</span>
<span class="p_add">+				shmem_undo_range(inode,</span>
<span class="p_add">+				    (loff_t)start &lt;&lt; PAGE_CACHE_SHIFT,</span>
<span class="p_add">+				    ((loff_t)index &lt;&lt; PAGE_CACHE_SHIFT) - 1, true);</span>
<span class="p_add">+			}</span>
 			goto undone;
 		}
 
<span class="p_header">diff --git a/net/batman-adv/bat_iv_ogm.c b/net/batman-adv/bat_iv_ogm.c</span>
<span class="p_header">index f04224c32005..3637024b9143 100644</span>
<span class="p_header">--- a/net/batman-adv/bat_iv_ogm.c</span>
<span class="p_header">+++ b/net/batman-adv/bat_iv_ogm.c</span>
<span class="p_chunk">@@ -124,10 +124,8 @@</span> <span class="p_context"> static int batadv_iv_ogm_orig_add_if(struct batadv_orig_node *orig_node,</span>
 	orig_node-&gt;bat_iv.bcast_own = data_ptr;
 
 	data_ptr = kmalloc(max_if_num * sizeof(uint8_t), GFP_ATOMIC);
<span class="p_del">-	if (!data_ptr) {</span>
<span class="p_del">-		kfree(orig_node-&gt;bat_iv.bcast_own);</span>
<span class="p_add">+	if (!data_ptr)</span>
 		goto unlock;
<span class="p_del">-	}</span>
 
 	memcpy(data_ptr, orig_node-&gt;bat_iv.bcast_own_sum,
 	       (max_if_num - 1) * sizeof(uint8_t));
<span class="p_chunk">@@ -1136,9 +1134,10 @@</span> <span class="p_context"> static int batadv_iv_ogm_calc_tq(struct batadv_orig_node *orig_node,</span>
 	uint8_t total_count;
 	uint8_t orig_eq_count, neigh_rq_count, neigh_rq_inv, tq_own;
 	unsigned int neigh_rq_inv_cube, neigh_rq_max_cube;
<span class="p_del">-	int tq_asym_penalty, inv_asym_penalty, if_num, ret = 0;</span>
<span class="p_add">+	int if_num, ret = 0;</span>
<span class="p_add">+	unsigned int tq_asym_penalty, inv_asym_penalty;</span>
 	unsigned int combined_tq;
<span class="p_del">-	int tq_iface_penalty;</span>
<span class="p_add">+	unsigned int tq_iface_penalty;</span>
 
 	/* find corresponding one hop neighbor */
 	rcu_read_lock();
<span class="p_header">diff --git a/net/batman-adv/routing.c b/net/batman-adv/routing.c</span>
<span class="p_header">index fb0c4e6069a7..22bbdd082546 100644</span>
<span class="p_header">--- a/net/batman-adv/routing.c</span>
<span class="p_header">+++ b/net/batman-adv/routing.c</span>
<span class="p_chunk">@@ -344,6 +344,7 @@</span> <span class="p_context"> int batadv_recv_icmp_packet(struct sk_buff *skb,</span>
 		if (skb_cow(skb, ETH_HLEN) &lt; 0)
 			goto out;
 
<span class="p_add">+		ethhdr = eth_hdr(skb);</span>
 		icmph = (struct batadv_icmp_header *)skb-&gt;data;
 		icmp_packet_rr = (struct batadv_icmp_packet_rr *)icmph;
 		if (icmp_packet_rr-&gt;rr_cur &gt;= BATADV_RR_LEN)
<span class="p_chunk">@@ -568,6 +569,7 @@</span> <span class="p_context"> static int batadv_route_unicast_packet(struct sk_buff *skb,</span>
 	struct batadv_unicast_packet *unicast_packet;
 	struct ethhdr *ethhdr = eth_hdr(skb);
 	int res, hdr_len, ret = NET_RX_DROP;
<span class="p_add">+	unsigned int len;</span>
 
 	unicast_packet = (struct batadv_unicast_packet *)skb-&gt;data;
 
<span class="p_chunk">@@ -608,6 +610,7 @@</span> <span class="p_context"> static int batadv_route_unicast_packet(struct sk_buff *skb,</span>
 	if (hdr_len &gt; 0)
 		batadv_skb_set_priority(skb, hdr_len);
 
<span class="p_add">+	len = skb-&gt;len;</span>
 	res = batadv_send_skb_to_orig(skb, orig_node, recv_if);
 
 	/* translate transmit result into receive result */
<span class="p_chunk">@@ -615,7 +618,7 @@</span> <span class="p_context"> static int batadv_route_unicast_packet(struct sk_buff *skb,</span>
 		/* skb was transmitted and consumed */
 		batadv_inc_counter(bat_priv, BATADV_CNT_FORWARD);
 		batadv_add_counter(bat_priv, BATADV_CNT_FORWARD_BYTES,
<span class="p_del">-				   skb-&gt;len + ETH_HLEN);</span>
<span class="p_add">+				   len + ETH_HLEN);</span>
 
 		ret = NET_RX_SUCCESS;
 	} else if (res == NET_XMIT_POLICED) {
<span class="p_header">diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c</span>
<span class="p_header">index ad40f170824d..765c89ccc3fb 100644</span>
<span class="p_header">--- a/net/batman-adv/soft-interface.c</span>
<span class="p_header">+++ b/net/batman-adv/soft-interface.c</span>
<span class="p_chunk">@@ -975,7 +975,9 @@</span> <span class="p_context"> void batadv_softif_destroy_sysfs(struct net_device *soft_iface)</span>
 static void batadv_softif_destroy_netlink(struct net_device *soft_iface,
 					  struct list_head *head)
 {
<span class="p_add">+	struct batadv_priv *bat_priv = netdev_priv(soft_iface);</span>
 	struct batadv_hard_iface *hard_iface;
<span class="p_add">+	struct batadv_softif_vlan *vlan;</span>
 
 	list_for_each_entry(hard_iface, &amp;batadv_hardif_list, list) {
 		if (hard_iface-&gt;soft_iface == soft_iface)
<span class="p_chunk">@@ -983,6 +985,13 @@</span> <span class="p_context"> static void batadv_softif_destroy_netlink(struct net_device *soft_iface,</span>
 							BATADV_IF_CLEANUP_KEEP);
 	}
 
<span class="p_add">+	/* destroy the &quot;untagged&quot; VLAN */</span>
<span class="p_add">+	vlan = batadv_softif_vlan_get(bat_priv, BATADV_NO_FLAGS);</span>
<span class="p_add">+	if (vlan) {</span>
<span class="p_add">+		batadv_softif_destroy_vlan(bat_priv, vlan);</span>
<span class="p_add">+		batadv_softif_vlan_free_ref(vlan);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	batadv_sysfs_del_meshif(soft_iface);
 	unregister_netdevice_queue(soft_iface, head);
 }
<span class="p_header">diff --git a/net/batman-adv/translation-table.c b/net/batman-adv/translation-table.c</span>
<span class="p_header">index eadf11fa083d..7da3f84fff2f 100644</span>
<span class="p_header">--- a/net/batman-adv/translation-table.c</span>
<span class="p_header">+++ b/net/batman-adv/translation-table.c</span>
<span class="p_chunk">@@ -576,9 +576,14 @@</span> <span class="p_context"> bool batadv_tt_local_add(struct net_device *soft_iface, const uint8_t *addr,</span>
 
 	/* increase the refcounter of the related vlan */
 	vlan = batadv_softif_vlan_get(bat_priv, vid);
<span class="p_del">-	if (WARN(!vlan, &quot;adding TT local entry %pM to non-existent VLAN %d&quot;,</span>
<span class="p_del">-		 addr, BATADV_PRINT_VID(vid)))</span>
<span class="p_add">+	if (!vlan) {</span>
<span class="p_add">+		net_ratelimited_function(batadv_info, soft_iface,</span>
<span class="p_add">+					 &quot;adding TT local entry %pM to non-existent VLAN %d\n&quot;,</span>
<span class="p_add">+					 addr, BATADV_PRINT_VID(vid));</span>
<span class="p_add">+		kfree(tt_local);</span>
<span class="p_add">+		tt_local = NULL;</span>
 		goto out;
<span class="p_add">+	}</span>
 
 	batadv_dbg(BATADV_DBG_TT, bat_priv,
 		   &quot;Creating new local tt entry: %pM (vid: %d, ttvn: %d)\n&quot;,
<span class="p_chunk">@@ -613,7 +618,6 @@</span> <span class="p_context"> bool batadv_tt_local_add(struct net_device *soft_iface, const uint8_t *addr,</span>
 	if (unlikely(hash_added != 0)) {
 		/* remove the reference for the hash */
 		batadv_tt_local_entry_free_ref(tt_local);
<span class="p_del">-		batadv_softif_vlan_free_ref(vlan);</span>
 		goto out;
 	}
 
<span class="p_chunk">@@ -2160,6 +2164,29 @@</span> <span class="p_context"> static uint32_t batadv_tt_local_crc(struct batadv_priv *bat_priv,</span>
 	return crc;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * batadv_tt_req_node_release - free tt_req node entry</span>
<span class="p_add">+ * @ref: kref pointer of the tt req_node entry</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void batadv_tt_req_node_release(struct kref *ref)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct batadv_tt_req_node *tt_req_node;</span>
<span class="p_add">+</span>
<span class="p_add">+	tt_req_node = container_of(ref, struct batadv_tt_req_node, refcount);</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(tt_req_node);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * batadv_tt_req_node_put - decrement the tt_req_node refcounter and</span>
<span class="p_add">+ *  possibly release it</span>
<span class="p_add">+ * @tt_req_node: tt_req_node to be free&#39;d</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void batadv_tt_req_node_put(struct batadv_tt_req_node *tt_req_node)</span>
<span class="p_add">+{</span>
<span class="p_add">+	kref_put(&amp;tt_req_node-&gt;refcount, batadv_tt_req_node_release);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void batadv_tt_req_list_free(struct batadv_priv *bat_priv)
 {
 	struct batadv_tt_req_node *node, *safe;
<span class="p_chunk">@@ -2168,7 +2195,7 @@</span> <span class="p_context"> static void batadv_tt_req_list_free(struct batadv_priv *bat_priv)</span>
 
 	list_for_each_entry_safe(node, safe, &amp;bat_priv-&gt;tt.req_list, list) {
 		list_del(&amp;node-&gt;list);
<span class="p_del">-		kfree(node);</span>
<span class="p_add">+		batadv_tt_req_node_put(node);</span>
 	}
 
 	spin_unlock_bh(&amp;bat_priv-&gt;tt.req_list_lock);
<span class="p_chunk">@@ -2204,7 +2231,7 @@</span> <span class="p_context"> static void batadv_tt_req_purge(struct batadv_priv *bat_priv)</span>
 		if (batadv_has_timed_out(node-&gt;issued_at,
 					 BATADV_TT_REQUEST_TIMEOUT)) {
 			list_del(&amp;node-&gt;list);
<span class="p_del">-			kfree(node);</span>
<span class="p_add">+			batadv_tt_req_node_put(node);</span>
 		}
 	}
 	spin_unlock_bh(&amp;bat_priv-&gt;tt.req_list_lock);
<span class="p_chunk">@@ -2231,9 +2258,11 @@</span> <span class="p_context"> batadv_new_tt_req_node(struct batadv_priv *bat_priv,</span>
 	if (!tt_req_node)
 		goto unlock;
 
<span class="p_add">+	kref_init(&amp;tt_req_node-&gt;refcount);</span>
 	ether_addr_copy(tt_req_node-&gt;addr, orig_node-&gt;orig);
 	tt_req_node-&gt;issued_at = jiffies;
 
<span class="p_add">+	kref_get(&amp;tt_req_node-&gt;refcount);</span>
 	list_add(&amp;tt_req_node-&gt;list, &amp;bat_priv-&gt;tt.req_list);
 unlock:
 	spin_unlock_bh(&amp;bat_priv-&gt;tt.req_list_lock);
<span class="p_chunk">@@ -2483,12 +2512,19 @@</span> <span class="p_context"> static int batadv_send_tt_request(struct batadv_priv *bat_priv,</span>
 out:
 	if (primary_if)
 		batadv_hardif_free_ref(primary_if);
<span class="p_add">+</span>
 	if (ret &amp;&amp; tt_req_node) {
 		spin_lock_bh(&amp;bat_priv-&gt;tt.req_list_lock);
<span class="p_del">-		list_del(&amp;tt_req_node-&gt;list);</span>
<span class="p_add">+		if (!list_empty(&amp;tt_req_node-&gt;list)) {</span>
<span class="p_add">+			list_del(&amp;tt_req_node-&gt;list);</span>
<span class="p_add">+			batadv_tt_req_node_put(tt_req_node);</span>
<span class="p_add">+		}</span>
 		spin_unlock_bh(&amp;bat_priv-&gt;tt.req_list_lock);
<span class="p_del">-		kfree(tt_req_node);</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (tt_req_node)</span>
<span class="p_add">+		batadv_tt_req_node_put(tt_req_node);</span>
<span class="p_add">+</span>
 	kfree(tvlv_tt_data);
 	return ret;
 }
<span class="p_chunk">@@ -2924,7 +2960,7 @@</span> <span class="p_context"> static void batadv_handle_tt_response(struct batadv_priv *bat_priv,</span>
 		if (!batadv_compare_eth(node-&gt;addr, resp_src))
 			continue;
 		list_del(&amp;node-&gt;list);
<span class="p_del">-		kfree(node);</span>
<span class="p_add">+		batadv_tt_req_node_put(node);</span>
 	}
 
 	spin_unlock_bh(&amp;bat_priv-&gt;tt.req_list_lock);
<span class="p_header">diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h</span>
<span class="p_header">index 53f2833552f3..0cc890bab7a4 100644</span>
<span class="p_header">--- a/net/batman-adv/types.h</span>
<span class="p_header">+++ b/net/batman-adv/types.h</span>
<span class="p_chunk">@@ -988,11 +988,13 @@</span> <span class="p_context"> struct batadv_tt_change_node {</span>
  * struct batadv_tt_req_node - data to keep track of the tt requests in flight
  * @addr: mac address address of the originator this request was sent to
  * @issued_at: timestamp used for purging stale tt requests
<span class="p_add">+ * @refcount: number of contexts the object is used by</span>
  * @list: list node for batadv_priv_tt::req_list
  */
 struct batadv_tt_req_node {
 	uint8_t addr[ETH_ALEN];
 	unsigned long issued_at;
<span class="p_add">+	struct kref refcount;</span>
 	struct list_head list;
 };
 
<span class="p_header">diff --git a/net/bridge/br_multicast.c b/net/bridge/br_multicast.c</span>
<span class="p_header">index 46ac609d0882..3b104a6d796c 100644</span>
<span class="p_header">--- a/net/bridge/br_multicast.c</span>
<span class="p_header">+++ b/net/bridge/br_multicast.c</span>
<span class="p_chunk">@@ -452,8 +452,11 @@</span> <span class="p_context"> static struct sk_buff *br_ip6_multicast_alloc_query(struct net_bridge *br,</span>
 	if (ipv6_dev_get_saddr(dev_net(br-&gt;dev), br-&gt;dev, &amp;ip6h-&gt;daddr, 0,
 			       &amp;ip6h-&gt;saddr)) {
 		kfree_skb(skb);
<span class="p_add">+		br-&gt;has_ipv6_addr = 0;</span>
 		return NULL;
 	}
<span class="p_add">+</span>
<span class="p_add">+	br-&gt;has_ipv6_addr = 1;</span>
 	ipv6_eth_mc_map(&amp;ip6h-&gt;daddr, eth-&gt;h_dest);
 
 	hopopt = (u8 *)(ip6h + 1);
<span class="p_chunk">@@ -1869,6 +1872,7 @@</span> <span class="p_context"> void br_multicast_init(struct net_bridge *br)</span>
 	br-&gt;ip6_other_query.delay_time = 0;
 	br-&gt;ip6_querier.port = NULL;
 #endif
<span class="p_add">+	br-&gt;has_ipv6_addr = 1;</span>
 
 	spin_lock_init(&amp;br-&gt;multicast_lock);
 	setup_timer(&amp;br-&gt;multicast_router_timer,
<span class="p_header">diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h</span>
<span class="p_header">index 4fd47a1a0e9a..eb8248c9af26 100644</span>
<span class="p_header">--- a/net/bridge/br_private.h</span>
<span class="p_header">+++ b/net/bridge/br_private.h</span>
<span class="p_chunk">@@ -261,6 +261,7 @@</span> <span class="p_context"> struct net_bridge</span>
 	u8				multicast_disabled:1;
 	u8				multicast_querier:1;
 	u8				multicast_query_use_ifaddr:1;
<span class="p_add">+	u8				has_ipv6_addr:1;</span>
 
 	u32				hash_elasticity;
 	u32				hash_max;
<span class="p_chunk">@@ -497,10 +498,22 @@</span> <span class="p_context"> static inline bool br_multicast_is_router(struct net_bridge *br)</span>
 
 static inline bool
 __br_multicast_querier_exists(struct net_bridge *br,
<span class="p_del">-			      struct bridge_mcast_other_query *querier)</span>
<span class="p_del">-{</span>
<span class="p_add">+				struct bridge_mcast_other_query *querier,</span>
<span class="p_add">+				const bool is_ipv6)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bool own_querier_enabled;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (br-&gt;multicast_querier) {</span>
<span class="p_add">+		if (is_ipv6 &amp;&amp; !br-&gt;has_ipv6_addr)</span>
<span class="p_add">+			own_querier_enabled = false;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			own_querier_enabled = true;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		own_querier_enabled = false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return time_is_before_jiffies(querier-&gt;delay_time) &amp;&amp;
<span class="p_del">-	       (br-&gt;multicast_querier || timer_pending(&amp;querier-&gt;timer));</span>
<span class="p_add">+	       (own_querier_enabled || timer_pending(&amp;querier-&gt;timer));</span>
 }
 
 static inline bool br_multicast_querier_exists(struct net_bridge *br,
<span class="p_chunk">@@ -508,10 +521,12 @@</span> <span class="p_context"> static inline bool br_multicast_querier_exists(struct net_bridge *br,</span>
 {
 	switch (eth-&gt;h_proto) {
 	case (htons(ETH_P_IP)):
<span class="p_del">-		return __br_multicast_querier_exists(br, &amp;br-&gt;ip4_other_query);</span>
<span class="p_add">+		return __br_multicast_querier_exists(br,</span>
<span class="p_add">+			&amp;br-&gt;ip4_other_query, false);</span>
 #if IS_ENABLED(CONFIG_IPV6)
 	case (htons(ETH_P_IPV6)):
<span class="p_del">-		return __br_multicast_querier_exists(br, &amp;br-&gt;ip6_other_query);</span>
<span class="p_add">+		return __br_multicast_querier_exists(br,</span>
<span class="p_add">+			&amp;br-&gt;ip6_other_query, true);</span>
 #endif
 	default:
 		return false;
<span class="p_header">diff --git a/net/ipv4/netfilter/arp_tables.c b/net/ipv4/netfilter/arp_tables.c</span>
<span class="p_header">index 738e62d548ce..3bdb46b325ab 100644</span>
<span class="p_header">--- a/net/ipv4/netfilter/arp_tables.c</span>
<span class="p_header">+++ b/net/ipv4/netfilter/arp_tables.c</span>
<span class="p_chunk">@@ -435,6 +435,8 @@</span> <span class="p_context"> static int mark_source_chains(const struct xt_table_info *newinfo,</span>
 				size = e-&gt;next_offset;
 				e = (struct arpt_entry *)
 					(entry0 + pos + size);
<span class="p_add">+				if (pos + size &gt;= newinfo-&gt;size)</span>
<span class="p_add">+					return 0;</span>
 				e-&gt;counters.pcnt = pos;
 				pos += size;
 			} else {
<span class="p_chunk">@@ -457,6 +459,8 @@</span> <span class="p_context"> static int mark_source_chains(const struct xt_table_info *newinfo,</span>
 				} else {
 					/* ... this is a fallthru */
 					newpos = pos + e-&gt;next_offset;
<span class="p_add">+					if (newpos &gt;= newinfo-&gt;size)</span>
<span class="p_add">+						return 0;</span>
 				}
 				e = (struct arpt_entry *)
 					(entry0 + newpos);
<span class="p_chunk">@@ -470,23 +474,6 @@</span> <span class="p_context"> static int mark_source_chains(const struct xt_table_info *newinfo,</span>
 	return 1;
 }
 
<span class="p_del">-static inline int check_entry(const struct arpt_entry *e)</span>
<span class="p_del">-{</span>
<span class="p_del">-	const struct xt_entry_target *t;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!arp_checkentry(&amp;e-&gt;arp))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (e-&gt;target_offset + sizeof(struct xt_entry_target) &gt; e-&gt;next_offset)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	t = arpt_get_target_c(e);</span>
<span class="p_del">-	if (e-&gt;target_offset + t-&gt;u.target_size &gt; e-&gt;next_offset)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline int check_target(struct arpt_entry *e, const char *name)
 {
 	struct xt_entry_target *t = arpt_get_target(e);
<span class="p_chunk">@@ -576,7 +563,11 @@</span> <span class="p_context"> static inline int check_entry_size_and_hooks(struct arpt_entry *e,</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	err = check_entry(e);</span>
<span class="p_add">+	if (!arp_checkentry(&amp;e-&gt;arp))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = xt_check_entry_offsets(e, e-&gt;elems, e-&gt;target_offset,</span>
<span class="p_add">+				     e-&gt;next_offset);</span>
 	if (err)
 		return err;
 
<span class="p_chunk">@@ -680,10 +671,8 @@</span> <span class="p_context"> static int translate_table(struct xt_table_info *newinfo, void *entry0,</span>
 		}
 	}
 
<span class="p_del">-	if (!mark_source_chains(newinfo, repl-&gt;valid_hooks, entry0)) {</span>
<span class="p_del">-		duprintf(&quot;Looping hook\n&quot;);</span>
<span class="p_add">+	if (!mark_source_chains(newinfo, repl-&gt;valid_hooks, entry0))</span>
 		return -ELOOP;
<span class="p_del">-	}</span>
 
 	/* Finally, each sanity check must pass */
 	i = 0;
<span class="p_chunk">@@ -1076,6 +1065,9 @@</span> <span class="p_context"> static int do_replace(struct net *net, const void __user *user,</span>
 	/* overflow check */
 	if (tmp.num_counters &gt;= INT_MAX / sizeof(struct xt_counters))
 		return -ENOMEM;
<span class="p_add">+	if (tmp.num_counters == 0)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	tmp.name[sizeof(tmp.name)-1] = 0;
 
 	newinfo = xt_alloc_table_info(tmp.size);
<span class="p_chunk">@@ -1116,56 +1108,18 @@</span> <span class="p_context"> static int do_add_counters(struct net *net, const void __user *user,</span>
 	unsigned int i, curcpu;
 	struct xt_counters_info tmp;
 	struct xt_counters *paddc;
<span class="p_del">-	unsigned int num_counters;</span>
<span class="p_del">-	const char *name;</span>
<span class="p_del">-	int size;</span>
<span class="p_del">-	void *ptmp;</span>
 	struct xt_table *t;
 	const struct xt_table_info *private;
 	int ret = 0;
 	void *loc_cpu_entry;
 	struct arpt_entry *iter;
 	unsigned int addend;
<span class="p_del">-#ifdef CONFIG_COMPAT</span>
<span class="p_del">-	struct compat_xt_counters_info compat_tmp;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (compat) {</span>
<span class="p_del">-		ptmp = &amp;compat_tmp;</span>
<span class="p_del">-		size = sizeof(struct compat_xt_counters_info);</span>
<span class="p_del">-	} else</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	{</span>
<span class="p_del">-		ptmp = &amp;tmp;</span>
<span class="p_del">-		size = sizeof(struct xt_counters_info);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (copy_from_user(ptmp, user, size) != 0)</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_COMPAT</span>
<span class="p_del">-	if (compat) {</span>
<span class="p_del">-		num_counters = compat_tmp.num_counters;</span>
<span class="p_del">-		name = compat_tmp.name;</span>
<span class="p_del">-	} else</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	{</span>
<span class="p_del">-		num_counters = tmp.num_counters;</span>
<span class="p_del">-		name = tmp.name;</span>
<span class="p_del">-	}</span>
 
<span class="p_del">-	if (len != size + num_counters * sizeof(struct xt_counters))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	paddc = xt_copy_counters_from_user(user, len, &amp;tmp, compat);</span>
<span class="p_add">+	if (IS_ERR(paddc))</span>
<span class="p_add">+		return PTR_ERR(paddc);</span>
 
<span class="p_del">-	paddc = vmalloc(len - size);</span>
<span class="p_del">-	if (!paddc)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (copy_from_user(paddc, user + size, len - size) != 0) {</span>
<span class="p_del">-		ret = -EFAULT;</span>
<span class="p_del">-		goto free;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	t = xt_find_table_lock(net, NFPROTO_ARP, name);</span>
<span class="p_add">+	t = xt_find_table_lock(net, NFPROTO_ARP, tmp.name);</span>
 	if (IS_ERR_OR_NULL(t)) {
 		ret = t ? PTR_ERR(t) : -ENOENT;
 		goto free;
<span class="p_chunk">@@ -1173,7 +1127,7 @@</span> <span class="p_context"> static int do_add_counters(struct net *net, const void __user *user,</span>
 
 	local_bh_disable();
 	private = t-&gt;private;
<span class="p_del">-	if (private-&gt;number != num_counters) {</span>
<span class="p_add">+	if (private-&gt;number != tmp.num_counters) {</span>
 		ret = -EINVAL;
 		goto unlock_up_free;
 	}
<span class="p_chunk">@@ -1199,6 +1153,18 @@</span> <span class="p_context"> static int do_add_counters(struct net *net, const void __user *user,</span>
 }
 
 #ifdef CONFIG_COMPAT
<span class="p_add">+struct compat_arpt_replace {</span>
<span class="p_add">+	char				name[XT_TABLE_MAXNAMELEN];</span>
<span class="p_add">+	u32				valid_hooks;</span>
<span class="p_add">+	u32				num_entries;</span>
<span class="p_add">+	u32				size;</span>
<span class="p_add">+	u32				hook_entry[NF_ARP_NUMHOOKS];</span>
<span class="p_add">+	u32				underflow[NF_ARP_NUMHOOKS];</span>
<span class="p_add">+	u32				num_counters;</span>
<span class="p_add">+	compat_uptr_t			counters;</span>
<span class="p_add">+	struct compat_arpt_entry	entries[0];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static inline void compat_release_entry(struct compat_arpt_entry *e)
 {
 	struct xt_entry_target *t;
<span class="p_chunk">@@ -1207,20 +1173,17 @@</span> <span class="p_context"> static inline void compat_release_entry(struct compat_arpt_entry *e)</span>
 	module_put(t-&gt;u.kernel.target-&gt;me);
 }
 
<span class="p_del">-static inline int</span>
<span class="p_add">+static int</span>
 check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,
 				  struct xt_table_info *newinfo,
 				  unsigned int *size,
 				  const unsigned char *base,
<span class="p_del">-				  const unsigned char *limit,</span>
<span class="p_del">-				  const unsigned int *hook_entries,</span>
<span class="p_del">-				  const unsigned int *underflows,</span>
<span class="p_del">-				  const char *name)</span>
<span class="p_add">+				  const unsigned char *limit)</span>
 {
 	struct xt_entry_target *t;
 	struct xt_target *target;
 	unsigned int entry_offset;
<span class="p_del">-	int ret, off, h;</span>
<span class="p_add">+	int ret, off;</span>
 
 	duprintf(&quot;check_compat_entry_size_and_hooks %p\n&quot;, e);
 	if ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||
<span class="p_chunk">@@ -1237,8 +1200,11 @@</span> <span class="p_context"> check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	/* For purposes of check_entry casting the compat entry is fine */</span>
<span class="p_del">-	ret = check_entry((struct arpt_entry *)e);</span>
<span class="p_add">+	if (!arp_checkentry(&amp;e-&gt;arp))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = xt_compat_check_entry_offsets(e, e-&gt;elems, e-&gt;target_offset,</span>
<span class="p_add">+					    e-&gt;next_offset);</span>
 	if (ret)
 		return ret;
 
<span class="p_chunk">@@ -1262,17 +1228,6 @@</span> <span class="p_context"> check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,</span>
 	if (ret)
 		goto release_target;
 
<span class="p_del">-	/* Check hooks &amp; underflows */</span>
<span class="p_del">-	for (h = 0; h &lt; NF_ARP_NUMHOOKS; h++) {</span>
<span class="p_del">-		if ((unsigned char *)e - base == hook_entries[h])</span>
<span class="p_del">-			newinfo-&gt;hook_entry[h] = hook_entries[h];</span>
<span class="p_del">-		if ((unsigned char *)e - base == underflows[h])</span>
<span class="p_del">-			newinfo-&gt;underflow[h] = underflows[h];</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Clear counters and comefrom */</span>
<span class="p_del">-	memset(&amp;e-&gt;counters, 0, sizeof(e-&gt;counters));</span>
<span class="p_del">-	e-&gt;comefrom = 0;</span>
 	return 0;
 
 release_target:
<span class="p_chunk">@@ -1281,18 +1236,17 @@</span> <span class="p_context"> out:</span>
 	return ret;
 }
 
<span class="p_del">-static int</span>
<span class="p_add">+static void</span>
 compat_copy_entry_from_user(struct compat_arpt_entry *e, void **dstptr,
<span class="p_del">-			    unsigned int *size, const char *name,</span>
<span class="p_add">+			    unsigned int *size,</span>
 			    struct xt_table_info *newinfo, unsigned char *base)
 {
 	struct xt_entry_target *t;
 	struct xt_target *target;
 	struct arpt_entry *de;
 	unsigned int origsize;
<span class="p_del">-	int ret, h;</span>
<span class="p_add">+	int h;</span>
 
<span class="p_del">-	ret = 0;</span>
 	origsize = *size;
 	de = (struct arpt_entry *)*dstptr;
 	memcpy(de, e, sizeof(struct arpt_entry));
<span class="p_chunk">@@ -1313,144 +1267,80 @@</span> <span class="p_context"> compat_copy_entry_from_user(struct compat_arpt_entry *e, void **dstptr,</span>
 		if ((unsigned char *)de - base &lt; newinfo-&gt;underflow[h])
 			newinfo-&gt;underflow[h] -= origsize - *size;
 	}
<span class="p_del">-	return ret;</span>
 }
 
<span class="p_del">-static int translate_compat_table(const char *name,</span>
<span class="p_del">-				  unsigned int valid_hooks,</span>
<span class="p_del">-				  struct xt_table_info **pinfo,</span>
<span class="p_add">+static int translate_compat_table(struct xt_table_info **pinfo,</span>
 				  void **pentry0,
<span class="p_del">-				  unsigned int total_size,</span>
<span class="p_del">-				  unsigned int number,</span>
<span class="p_del">-				  unsigned int *hook_entries,</span>
<span class="p_del">-				  unsigned int *underflows)</span>
<span class="p_add">+				  const struct compat_arpt_replace *compatr)</span>
 {
 	unsigned int i, j;
 	struct xt_table_info *newinfo, *info;
 	void *pos, *entry0, *entry1;
 	struct compat_arpt_entry *iter0;
<span class="p_del">-	struct arpt_entry *iter1;</span>
<span class="p_add">+	struct arpt_replace repl;</span>
 	unsigned int size;
 	int ret = 0;
 
 	info = *pinfo;
 	entry0 = *pentry0;
<span class="p_del">-	size = total_size;</span>
<span class="p_del">-	info-&gt;number = number;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Init all hooks to impossible value. */</span>
<span class="p_del">-	for (i = 0; i &lt; NF_ARP_NUMHOOKS; i++) {</span>
<span class="p_del">-		info-&gt;hook_entry[i] = 0xFFFFFFFF;</span>
<span class="p_del">-		info-&gt;underflow[i] = 0xFFFFFFFF;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	size = compatr-&gt;size;</span>
<span class="p_add">+	info-&gt;number = compatr-&gt;num_entries;</span>
 
 	duprintf(&quot;translate_compat_table: size %u\n&quot;, info-&gt;size);
 	j = 0;
 	xt_compat_lock(NFPROTO_ARP);
<span class="p_del">-	xt_compat_init_offsets(NFPROTO_ARP, number);</span>
<span class="p_add">+	xt_compat_init_offsets(NFPROTO_ARP, compatr-&gt;num_entries);</span>
 	/* Walk through entries, checking offsets. */
<span class="p_del">-	xt_entry_foreach(iter0, entry0, total_size) {</span>
<span class="p_add">+	xt_entry_foreach(iter0, entry0, compatr-&gt;size) {</span>
 		ret = check_compat_entry_size_and_hooks(iter0, info, &amp;size,
 							entry0,
<span class="p_del">-							entry0 + total_size,</span>
<span class="p_del">-							hook_entries,</span>
<span class="p_del">-							underflows,</span>
<span class="p_del">-							name);</span>
<span class="p_add">+							entry0 + compatr-&gt;size);</span>
 		if (ret != 0)
 			goto out_unlock;
 		++j;
 	}
 
 	ret = -EINVAL;
<span class="p_del">-	if (j != number) {</span>
<span class="p_add">+	if (j != compatr-&gt;num_entries) {</span>
 		duprintf(&quot;translate_compat_table: %u not %u entries\n&quot;,
<span class="p_del">-			 j, number);</span>
<span class="p_add">+			 j, compatr-&gt;num_entries);</span>
 		goto out_unlock;
 	}
 
<span class="p_del">-	/* Check hooks all assigned */</span>
<span class="p_del">-	for (i = 0; i &lt; NF_ARP_NUMHOOKS; i++) {</span>
<span class="p_del">-		/* Only hooks which are valid */</span>
<span class="p_del">-		if (!(valid_hooks &amp; (1 &lt;&lt; i)))</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		if (info-&gt;hook_entry[i] == 0xFFFFFFFF) {</span>
<span class="p_del">-			duprintf(&quot;Invalid hook entry %u %u\n&quot;,</span>
<span class="p_del">-				 i, hook_entries[i]);</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (info-&gt;underflow[i] == 0xFFFFFFFF) {</span>
<span class="p_del">-			duprintf(&quot;Invalid underflow %u %u\n&quot;,</span>
<span class="p_del">-				 i, underflows[i]);</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	ret = -ENOMEM;
 	newinfo = xt_alloc_table_info(size);
 	if (!newinfo)
 		goto out_unlock;
 
<span class="p_del">-	newinfo-&gt;number = number;</span>
<span class="p_add">+	newinfo-&gt;number = compatr-&gt;num_entries;</span>
 	for (i = 0; i &lt; NF_ARP_NUMHOOKS; i++) {
 		newinfo-&gt;hook_entry[i] = info-&gt;hook_entry[i];
 		newinfo-&gt;underflow[i] = info-&gt;underflow[i];
 	}
 	entry1 = newinfo-&gt;entries[raw_smp_processor_id()];
 	pos = entry1;
<span class="p_del">-	size = total_size;</span>
<span class="p_del">-	xt_entry_foreach(iter0, entry0, total_size) {</span>
<span class="p_del">-		ret = compat_copy_entry_from_user(iter0, &amp;pos, &amp;size,</span>
<span class="p_del">-						  name, newinfo, entry1);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	size = compatr-&gt;size;</span>
<span class="p_add">+	xt_entry_foreach(iter0, entry0, compatr-&gt;size)</span>
<span class="p_add">+		compat_copy_entry_from_user(iter0, &amp;pos, &amp;size,</span>
<span class="p_add">+					    newinfo, entry1);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* all module references in entry0 are now gone */</span>
<span class="p_add">+</span>
 	xt_compat_flush_offsets(NFPROTO_ARP);
 	xt_compat_unlock(NFPROTO_ARP);
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto free_newinfo;</span>
 
<span class="p_del">-	ret = -ELOOP;</span>
<span class="p_del">-	if (!mark_source_chains(newinfo, valid_hooks, entry1))</span>
<span class="p_del">-		goto free_newinfo;</span>
<span class="p_del">-</span>
<span class="p_del">-	i = 0;</span>
<span class="p_del">-	xt_entry_foreach(iter1, entry1, newinfo-&gt;size) {</span>
<span class="p_del">-		ret = check_target(iter1, name);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		++i;</span>
<span class="p_del">-		if (strcmp(arpt_get_target(iter1)-&gt;u.user.name,</span>
<span class="p_del">-		    XT_ERROR_TARGET) == 0)</span>
<span class="p_del">-			++newinfo-&gt;stacksize;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The first i matches need cleanup_entry (calls -&gt;destroy)</span>
<span class="p_del">-		 * because they had called -&gt;check already. The other j-i</span>
<span class="p_del">-		 * entries need only release.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		int skip = i;</span>
<span class="p_del">-		j -= i;</span>
<span class="p_del">-		xt_entry_foreach(iter0, entry0, newinfo-&gt;size) {</span>
<span class="p_del">-			if (skip-- &gt; 0)</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			if (j-- == 0)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			compat_release_entry(iter0);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		xt_entry_foreach(iter1, entry1, newinfo-&gt;size) {</span>
<span class="p_del">-			if (i-- == 0)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			cleanup_entry(iter1);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		xt_free_table_info(newinfo);</span>
<span class="p_del">-		return ret;</span>
<span class="p_add">+	memcpy(&amp;repl, compatr, sizeof(*compatr));</span>
<span class="p_add">+	for (i = 0; i &lt; NF_ARP_NUMHOOKS; i++) {</span>
<span class="p_add">+		repl.hook_entry[i] = newinfo-&gt;hook_entry[i];</span>
<span class="p_add">+		repl.underflow[i] = newinfo-&gt;underflow[i];</span>
 	}
 
<span class="p_del">-	/* And one copy for every other CPU */</span>
<span class="p_del">-	for_each_possible_cpu(i)</span>
<span class="p_del">-		if (newinfo-&gt;entries[i] &amp;&amp; newinfo-&gt;entries[i] != entry1)</span>
<span class="p_del">-			memcpy(newinfo-&gt;entries[i], entry1, newinfo-&gt;size);</span>
<span class="p_add">+	repl.num_counters = 0;</span>
<span class="p_add">+	repl.counters = NULL;</span>
<span class="p_add">+	repl.size = newinfo-&gt;size;</span>
<span class="p_add">+	ret = translate_table(newinfo, entry1, &amp;repl);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto free_newinfo;</span>
 
 	*pinfo = newinfo;
 	*pentry0 = entry1;
<span class="p_chunk">@@ -1459,31 +1349,18 @@</span> <span class="p_context"> static int translate_compat_table(const char *name,</span>
 
 free_newinfo:
 	xt_free_table_info(newinfo);
<span class="p_del">-out:</span>
<span class="p_del">-	xt_entry_foreach(iter0, entry0, total_size) {</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+out_unlock:</span>
<span class="p_add">+	xt_compat_flush_offsets(NFPROTO_ARP);</span>
<span class="p_add">+	xt_compat_unlock(NFPROTO_ARP);</span>
<span class="p_add">+	xt_entry_foreach(iter0, entry0, compatr-&gt;size) {</span>
 		if (j-- == 0)
 			break;
 		compat_release_entry(iter0);
 	}
 	return ret;
<span class="p_del">-out_unlock:</span>
<span class="p_del">-	xt_compat_flush_offsets(NFPROTO_ARP);</span>
<span class="p_del">-	xt_compat_unlock(NFPROTO_ARP);</span>
<span class="p_del">-	goto out;</span>
 }
 
<span class="p_del">-struct compat_arpt_replace {</span>
<span class="p_del">-	char				name[XT_TABLE_MAXNAMELEN];</span>
<span class="p_del">-	u32				valid_hooks;</span>
<span class="p_del">-	u32				num_entries;</span>
<span class="p_del">-	u32				size;</span>
<span class="p_del">-	u32				hook_entry[NF_ARP_NUMHOOKS];</span>
<span class="p_del">-	u32				underflow[NF_ARP_NUMHOOKS];</span>
<span class="p_del">-	u32				num_counters;</span>
<span class="p_del">-	compat_uptr_t			counters;</span>
<span class="p_del">-	struct compat_arpt_entry	entries[0];</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 static int compat_do_replace(struct net *net, void __user *user,
 			     unsigned int len)
 {
<span class="p_chunk">@@ -1501,6 +1378,9 @@</span> <span class="p_context"> static int compat_do_replace(struct net *net, void __user *user,</span>
 		return -ENOMEM;
 	if (tmp.num_counters &gt;= INT_MAX / sizeof(struct xt_counters))
 		return -ENOMEM;
<span class="p_add">+	if (tmp.num_counters == 0)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	tmp.name[sizeof(tmp.name)-1] = 0;
 
 	newinfo = xt_alloc_table_info(tmp.size);
<span class="p_chunk">@@ -1514,10 +1394,7 @@</span> <span class="p_context"> static int compat_do_replace(struct net *net, void __user *user,</span>
 		goto free_newinfo;
 	}
 
<span class="p_del">-	ret = translate_compat_table(tmp.name, tmp.valid_hooks,</span>
<span class="p_del">-				     &amp;newinfo, &amp;loc_cpu_entry, tmp.size,</span>
<span class="p_del">-				     tmp.num_entries, tmp.hook_entry,</span>
<span class="p_del">-				     tmp.underflow);</span>
<span class="p_add">+	ret = translate_compat_table(&amp;newinfo, &amp;loc_cpu_entry, &amp;tmp);</span>
 	if (ret != 0)
 		goto free_newinfo;
 
<span class="p_header">diff --git a/net/ipv4/netfilter/ip_tables.c b/net/ipv4/netfilter/ip_tables.c</span>
<span class="p_header">index 2c8fb724dde5..baa1f65e5142 100644</span>
<span class="p_header">--- a/net/ipv4/netfilter/ip_tables.c</span>
<span class="p_header">+++ b/net/ipv4/netfilter/ip_tables.c</span>
<span class="p_chunk">@@ -516,6 +516,8 @@</span> <span class="p_context"> mark_source_chains(const struct xt_table_info *newinfo,</span>
 				size = e-&gt;next_offset;
 				e = (struct ipt_entry *)
 					(entry0 + pos + size);
<span class="p_add">+				if (pos + size &gt;= newinfo-&gt;size)</span>
<span class="p_add">+					return 0;</span>
 				e-&gt;counters.pcnt = pos;
 				pos += size;
 			} else {
<span class="p_chunk">@@ -537,6 +539,8 @@</span> <span class="p_context"> mark_source_chains(const struct xt_table_info *newinfo,</span>
 				} else {
 					/* ... this is a fallthru */
 					newpos = pos + e-&gt;next_offset;
<span class="p_add">+					if (newpos &gt;= newinfo-&gt;size)</span>
<span class="p_add">+						return 0;</span>
 				}
 				e = (struct ipt_entry *)
 					(entry0 + newpos);
<span class="p_chunk">@@ -564,25 +568,6 @@</span> <span class="p_context"> static void cleanup_match(struct xt_entry_match *m, struct net *net)</span>
 }
 
 static int
<span class="p_del">-check_entry(const struct ipt_entry *e)</span>
<span class="p_del">-{</span>
<span class="p_del">-	const struct xt_entry_target *t;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!ip_checkentry(&amp;e-&gt;ip))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (e-&gt;target_offset + sizeof(struct xt_entry_target) &gt;</span>
<span class="p_del">-	    e-&gt;next_offset)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	t = ipt_get_target_c(e);</span>
<span class="p_del">-	if (e-&gt;target_offset + t-&gt;u.target_size &gt; e-&gt;next_offset)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int</span>
 check_match(struct xt_entry_match *m, struct xt_mtchk_param *par)
 {
 	const struct ipt_ip *ip = par-&gt;entryinfo;
<span class="p_chunk">@@ -738,7 +723,11 @@</span> <span class="p_context"> check_entry_size_and_hooks(struct ipt_entry *e,</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	err = check_entry(e);</span>
<span class="p_add">+	if (!ip_checkentry(&amp;e-&gt;ip))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = xt_check_entry_offsets(e, e-&gt;elems, e-&gt;target_offset,</span>
<span class="p_add">+				     e-&gt;next_offset);</span>
 	if (err)
 		return err;
 
<span class="p_chunk">@@ -1262,6 +1251,9 @@</span> <span class="p_context"> do_replace(struct net *net, const void __user *user, unsigned int len)</span>
 	/* overflow check */
 	if (tmp.num_counters &gt;= INT_MAX / sizeof(struct xt_counters))
 		return -ENOMEM;
<span class="p_add">+	if (tmp.num_counters == 0)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	tmp.name[sizeof(tmp.name)-1] = 0;
 
 	newinfo = xt_alloc_table_info(tmp.size);
<span class="p_chunk">@@ -1303,56 +1295,18 @@</span> <span class="p_context"> do_add_counters(struct net *net, const void __user *user,</span>
 	unsigned int i, curcpu;
 	struct xt_counters_info tmp;
 	struct xt_counters *paddc;
<span class="p_del">-	unsigned int num_counters;</span>
<span class="p_del">-	const char *name;</span>
<span class="p_del">-	int size;</span>
<span class="p_del">-	void *ptmp;</span>
 	struct xt_table *t;
 	const struct xt_table_info *private;
 	int ret = 0;
 	void *loc_cpu_entry;
 	struct ipt_entry *iter;
 	unsigned int addend;
<span class="p_del">-#ifdef CONFIG_COMPAT</span>
<span class="p_del">-	struct compat_xt_counters_info compat_tmp;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (compat) {</span>
<span class="p_del">-		ptmp = &amp;compat_tmp;</span>
<span class="p_del">-		size = sizeof(struct compat_xt_counters_info);</span>
<span class="p_del">-	} else</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	{</span>
<span class="p_del">-		ptmp = &amp;tmp;</span>
<span class="p_del">-		size = sizeof(struct xt_counters_info);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (copy_from_user(ptmp, user, size) != 0)</span>
<span class="p_del">-		return -EFAULT;</span>
 
<span class="p_del">-#ifdef CONFIG_COMPAT</span>
<span class="p_del">-	if (compat) {</span>
<span class="p_del">-		num_counters = compat_tmp.num_counters;</span>
<span class="p_del">-		name = compat_tmp.name;</span>
<span class="p_del">-	} else</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	{</span>
<span class="p_del">-		num_counters = tmp.num_counters;</span>
<span class="p_del">-		name = tmp.name;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (len != size + num_counters * sizeof(struct xt_counters))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	paddc = vmalloc(len - size);</span>
<span class="p_del">-	if (!paddc)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+	paddc = xt_copy_counters_from_user(user, len, &amp;tmp, compat);</span>
<span class="p_add">+	if (IS_ERR(paddc))</span>
<span class="p_add">+		return PTR_ERR(paddc);</span>
 
<span class="p_del">-	if (copy_from_user(paddc, user + size, len - size) != 0) {</span>
<span class="p_del">-		ret = -EFAULT;</span>
<span class="p_del">-		goto free;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	t = xt_find_table_lock(net, AF_INET, name);</span>
<span class="p_add">+	t = xt_find_table_lock(net, AF_INET, tmp.name);</span>
 	if (IS_ERR_OR_NULL(t)) {
 		ret = t ? PTR_ERR(t) : -ENOENT;
 		goto free;
<span class="p_chunk">@@ -1360,7 +1314,7 @@</span> <span class="p_context"> do_add_counters(struct net *net, const void __user *user,</span>
 
 	local_bh_disable();
 	private = t-&gt;private;
<span class="p_del">-	if (private-&gt;number != num_counters) {</span>
<span class="p_add">+	if (private-&gt;number != tmp.num_counters) {</span>
 		ret = -EINVAL;
 		goto unlock_up_free;
 	}
<span class="p_chunk">@@ -1439,7 +1393,6 @@</span> <span class="p_context"> compat_copy_entry_to_user(struct ipt_entry *e, void __user **dstptr,</span>
 
 static int
 compat_find_calc_match(struct xt_entry_match *m,
<span class="p_del">-		       const char *name,</span>
 		       const struct ipt_ip *ip,
 		       unsigned int hookmask,
 		       int *size)
<span class="p_chunk">@@ -1475,17 +1428,14 @@</span> <span class="p_context"> check_compat_entry_size_and_hooks(struct compat_ipt_entry *e,</span>
 				  struct xt_table_info *newinfo,
 				  unsigned int *size,
 				  const unsigned char *base,
<span class="p_del">-				  const unsigned char *limit,</span>
<span class="p_del">-				  const unsigned int *hook_entries,</span>
<span class="p_del">-				  const unsigned int *underflows,</span>
<span class="p_del">-				  const char *name)</span>
<span class="p_add">+				  const unsigned char *limit)</span>
 {
 	struct xt_entry_match *ematch;
 	struct xt_entry_target *t;
 	struct xt_target *target;
 	unsigned int entry_offset;
 	unsigned int j;
<span class="p_del">-	int ret, off, h;</span>
<span class="p_add">+	int ret, off;</span>
 
 	duprintf(&quot;check_compat_entry_size_and_hooks %p\n&quot;, e);
 	if ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||
<span class="p_chunk">@@ -1502,8 +1452,11 @@</span> <span class="p_context"> check_compat_entry_size_and_hooks(struct compat_ipt_entry *e,</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	/* For purposes of check_entry casting the compat entry is fine */</span>
<span class="p_del">-	ret = check_entry((struct ipt_entry *)e);</span>
<span class="p_add">+	if (!ip_checkentry(&amp;e-&gt;ip))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = xt_compat_check_entry_offsets(e, e-&gt;elems,</span>
<span class="p_add">+					    e-&gt;target_offset, e-&gt;next_offset);</span>
 	if (ret)
 		return ret;
 
<span class="p_chunk">@@ -1511,8 +1464,7 @@</span> <span class="p_context"> check_compat_entry_size_and_hooks(struct compat_ipt_entry *e,</span>
 	entry_offset = (void *)e - (void *)base;
 	j = 0;
 	xt_ematch_foreach(ematch, e) {
<span class="p_del">-		ret = compat_find_calc_match(ematch, name,</span>
<span class="p_del">-					     &amp;e-&gt;ip, e-&gt;comefrom, &amp;off);</span>
<span class="p_add">+		ret = compat_find_calc_match(ematch, &amp;e-&gt;ip, e-&gt;comefrom, &amp;off);</span>
 		if (ret != 0)
 			goto release_matches;
 		++j;
<span class="p_chunk">@@ -1535,17 +1487,6 @@</span> <span class="p_context"> check_compat_entry_size_and_hooks(struct compat_ipt_entry *e,</span>
 	if (ret)
 		goto out;
 
<span class="p_del">-	/* Check hooks &amp; underflows */</span>
<span class="p_del">-	for (h = 0; h &lt; NF_INET_NUMHOOKS; h++) {</span>
<span class="p_del">-		if ((unsigned char *)e - base == hook_entries[h])</span>
<span class="p_del">-			newinfo-&gt;hook_entry[h] = hook_entries[h];</span>
<span class="p_del">-		if ((unsigned char *)e - base == underflows[h])</span>
<span class="p_del">-			newinfo-&gt;underflow[h] = underflows[h];</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Clear counters and comefrom */</span>
<span class="p_del">-	memset(&amp;e-&gt;counters, 0, sizeof(e-&gt;counters));</span>
<span class="p_del">-	e-&gt;comefrom = 0;</span>
 	return 0;
 
 out:
<span class="p_chunk">@@ -1559,19 +1500,18 @@</span> <span class="p_context"> release_matches:</span>
 	return ret;
 }
 
<span class="p_del">-static int</span>
<span class="p_add">+static void</span>
 compat_copy_entry_from_user(struct compat_ipt_entry *e, void **dstptr,
<span class="p_del">-			    unsigned int *size, const char *name,</span>
<span class="p_add">+			    unsigned int *size,</span>
 			    struct xt_table_info *newinfo, unsigned char *base)
 {
 	struct xt_entry_target *t;
 	struct xt_target *target;
 	struct ipt_entry *de;
 	unsigned int origsize;
<span class="p_del">-	int ret, h;</span>
<span class="p_add">+	int h;</span>
 	struct xt_entry_match *ematch;
 
<span class="p_del">-	ret = 0;</span>
 	origsize = *size;
 	de = (struct ipt_entry *)*dstptr;
 	memcpy(de, e, sizeof(struct ipt_entry));
<span class="p_chunk">@@ -1580,198 +1520,104 @@</span> <span class="p_context"> compat_copy_entry_from_user(struct compat_ipt_entry *e, void **dstptr,</span>
 	*dstptr += sizeof(struct ipt_entry);
 	*size += sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);
 
<span class="p_del">-	xt_ematch_foreach(ematch, e) {</span>
<span class="p_del">-		ret = xt_compat_match_from_user(ematch, dstptr, size);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	xt_ematch_foreach(ematch, e)</span>
<span class="p_add">+		xt_compat_match_from_user(ematch, dstptr, size);</span>
<span class="p_add">+</span>
 	de-&gt;target_offset = e-&gt;target_offset - (origsize - *size);
 	t = compat_ipt_get_target(e);
 	target = t-&gt;u.kernel.target;
 	xt_compat_target_from_user(t, dstptr, size);
 
 	de-&gt;next_offset = e-&gt;next_offset - (origsize - *size);
<span class="p_add">+</span>
 	for (h = 0; h &lt; NF_INET_NUMHOOKS; h++) {
 		if ((unsigned char *)de - base &lt; newinfo-&gt;hook_entry[h])
 			newinfo-&gt;hook_entry[h] -= origsize - *size;
 		if ((unsigned char *)de - base &lt; newinfo-&gt;underflow[h])
 			newinfo-&gt;underflow[h] -= origsize - *size;
 	}
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int</span>
<span class="p_del">-compat_check_entry(struct ipt_entry *e, struct net *net, const char *name)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct xt_entry_match *ematch;</span>
<span class="p_del">-	struct xt_mtchk_param mtpar;</span>
<span class="p_del">-	unsigned int j;</span>
<span class="p_del">-	int ret = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	j = 0;</span>
<span class="p_del">-	mtpar.net	= net;</span>
<span class="p_del">-	mtpar.table     = name;</span>
<span class="p_del">-	mtpar.entryinfo = &amp;e-&gt;ip;</span>
<span class="p_del">-	mtpar.hook_mask = e-&gt;comefrom;</span>
<span class="p_del">-	mtpar.family    = NFPROTO_IPV4;</span>
<span class="p_del">-	xt_ematch_foreach(ematch, e) {</span>
<span class="p_del">-		ret = check_match(ematch, &amp;mtpar);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			goto cleanup_matches;</span>
<span class="p_del">-		++j;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = check_target(e, net, name);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto cleanup_matches;</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-</span>
<span class="p_del">- cleanup_matches:</span>
<span class="p_del">-	xt_ematch_foreach(ematch, e) {</span>
<span class="p_del">-		if (j-- == 0)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		cleanup_match(ematch, net);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return ret;</span>
 }
 
 static int
 translate_compat_table(struct net *net,
<span class="p_del">-		       const char *name,</span>
<span class="p_del">-		       unsigned int valid_hooks,</span>
 		       struct xt_table_info **pinfo,
 		       void **pentry0,
<span class="p_del">-		       unsigned int total_size,</span>
<span class="p_del">-		       unsigned int number,</span>
<span class="p_del">-		       unsigned int *hook_entries,</span>
<span class="p_del">-		       unsigned int *underflows)</span>
<span class="p_add">+		       const struct compat_ipt_replace *compatr)</span>
 {
 	unsigned int i, j;
 	struct xt_table_info *newinfo, *info;
 	void *pos, *entry0, *entry1;
 	struct compat_ipt_entry *iter0;
<span class="p_del">-	struct ipt_entry *iter1;</span>
<span class="p_add">+	struct ipt_replace repl;</span>
 	unsigned int size;
 	int ret;
 
 	info = *pinfo;
 	entry0 = *pentry0;
<span class="p_del">-	size = total_size;</span>
<span class="p_del">-	info-&gt;number = number;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Init all hooks to impossible value. */</span>
<span class="p_del">-	for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) {</span>
<span class="p_del">-		info-&gt;hook_entry[i] = 0xFFFFFFFF;</span>
<span class="p_del">-		info-&gt;underflow[i] = 0xFFFFFFFF;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	size = compatr-&gt;size;</span>
<span class="p_add">+	info-&gt;number = compatr-&gt;num_entries;</span>
 
 	duprintf(&quot;translate_compat_table: size %u\n&quot;, info-&gt;size);
 	j = 0;
 	xt_compat_lock(AF_INET);
<span class="p_del">-	xt_compat_init_offsets(AF_INET, number);</span>
<span class="p_add">+	xt_compat_init_offsets(AF_INET, compatr-&gt;num_entries);</span>
 	/* Walk through entries, checking offsets. */
<span class="p_del">-	xt_entry_foreach(iter0, entry0, total_size) {</span>
<span class="p_add">+	xt_entry_foreach(iter0, entry0, compatr-&gt;size) {</span>
 		ret = check_compat_entry_size_and_hooks(iter0, info, &amp;size,
 							entry0,
<span class="p_del">-							entry0 + total_size,</span>
<span class="p_del">-							hook_entries,</span>
<span class="p_del">-							underflows,</span>
<span class="p_del">-							name);</span>
<span class="p_add">+							entry0 + compatr-&gt;size);</span>
 		if (ret != 0)
 			goto out_unlock;
 		++j;
 	}
 
 	ret = -EINVAL;
<span class="p_del">-	if (j != number) {</span>
<span class="p_add">+	if (j != compatr-&gt;num_entries) {</span>
 		duprintf(&quot;translate_compat_table: %u not %u entries\n&quot;,
<span class="p_del">-			 j, number);</span>
<span class="p_add">+			 j, compatr-&gt;num_entries);</span>
 		goto out_unlock;
 	}
 
<span class="p_del">-	/* Check hooks all assigned */</span>
<span class="p_del">-	for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) {</span>
<span class="p_del">-		/* Only hooks which are valid */</span>
<span class="p_del">-		if (!(valid_hooks &amp; (1 &lt;&lt; i)))</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		if (info-&gt;hook_entry[i] == 0xFFFFFFFF) {</span>
<span class="p_del">-			duprintf(&quot;Invalid hook entry %u %u\n&quot;,</span>
<span class="p_del">-				 i, hook_entries[i]);</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (info-&gt;underflow[i] == 0xFFFFFFFF) {</span>
<span class="p_del">-			duprintf(&quot;Invalid underflow %u %u\n&quot;,</span>
<span class="p_del">-				 i, underflows[i]);</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	ret = -ENOMEM;
 	newinfo = xt_alloc_table_info(size);
 	if (!newinfo)
 		goto out_unlock;
 
<span class="p_del">-	newinfo-&gt;number = number;</span>
<span class="p_add">+	newinfo-&gt;number = compatr-&gt;num_entries;</span>
 	for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) {
<span class="p_del">-		newinfo-&gt;hook_entry[i] = info-&gt;hook_entry[i];</span>
<span class="p_del">-		newinfo-&gt;underflow[i] = info-&gt;underflow[i];</span>
<span class="p_add">+		newinfo-&gt;hook_entry[i] = compatr-&gt;hook_entry[i];</span>
<span class="p_add">+		newinfo-&gt;underflow[i] = compatr-&gt;underflow[i];</span>
 	}
 	entry1 = newinfo-&gt;entries[raw_smp_processor_id()];
 	pos = entry1;
<span class="p_del">-	size = total_size;</span>
<span class="p_del">-	xt_entry_foreach(iter0, entry0, total_size) {</span>
<span class="p_del">-		ret = compat_copy_entry_from_user(iter0, &amp;pos, &amp;size,</span>
<span class="p_del">-						  name, newinfo, entry1);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	size = compatr-&gt;size;</span>
<span class="p_add">+	xt_entry_foreach(iter0, entry0, compatr-&gt;size)</span>
<span class="p_add">+		compat_copy_entry_from_user(iter0, &amp;pos, &amp;size,</span>
<span class="p_add">+					    newinfo, entry1);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* all module references in entry0 are now gone.</span>
<span class="p_add">+	 * entry1/newinfo contains a 64bit ruleset that looks exactly as</span>
<span class="p_add">+	 * generated by 64bit userspace.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Call standard translate_table() to validate all hook_entrys,</span>
<span class="p_add">+	 * underflows, check for loops, etc.</span>
<span class="p_add">+	 */</span>
 	xt_compat_flush_offsets(AF_INET);
 	xt_compat_unlock(AF_INET);
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto free_newinfo;</span>
 
<span class="p_del">-	ret = -ELOOP;</span>
<span class="p_del">-	if (!mark_source_chains(newinfo, valid_hooks, entry1))</span>
<span class="p_del">-		goto free_newinfo;</span>
<span class="p_add">+	memcpy(&amp;repl, compatr, sizeof(*compatr));</span>
 
<span class="p_del">-	i = 0;</span>
<span class="p_del">-	xt_entry_foreach(iter1, entry1, newinfo-&gt;size) {</span>
<span class="p_del">-		ret = compat_check_entry(iter1, net, name);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		++i;</span>
<span class="p_del">-		if (strcmp(ipt_get_target(iter1)-&gt;u.user.name,</span>
<span class="p_del">-		    XT_ERROR_TARGET) == 0)</span>
<span class="p_del">-			++newinfo-&gt;stacksize;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The first i matches need cleanup_entry (calls -&gt;destroy)</span>
<span class="p_del">-		 * because they had called -&gt;check already. The other j-i</span>
<span class="p_del">-		 * entries need only release.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		int skip = i;</span>
<span class="p_del">-		j -= i;</span>
<span class="p_del">-		xt_entry_foreach(iter0, entry0, newinfo-&gt;size) {</span>
<span class="p_del">-			if (skip-- &gt; 0)</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			if (j-- == 0)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			compat_release_entry(iter0);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		xt_entry_foreach(iter1, entry1, newinfo-&gt;size) {</span>
<span class="p_del">-			if (i-- == 0)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			cleanup_entry(iter1, net);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		xt_free_table_info(newinfo);</span>
<span class="p_del">-		return ret;</span>
<span class="p_add">+	for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) {</span>
<span class="p_add">+		repl.hook_entry[i] = newinfo-&gt;hook_entry[i];</span>
<span class="p_add">+		repl.underflow[i] = newinfo-&gt;underflow[i];</span>
 	}
 
<span class="p_del">-	/* And one copy for every other CPU */</span>
<span class="p_del">-	for_each_possible_cpu(i)</span>
<span class="p_del">-		if (newinfo-&gt;entries[i] &amp;&amp; newinfo-&gt;entries[i] != entry1)</span>
<span class="p_del">-			memcpy(newinfo-&gt;entries[i], entry1, newinfo-&gt;size);</span>
<span class="p_add">+	repl.num_counters = 0;</span>
<span class="p_add">+	repl.counters = NULL;</span>
<span class="p_add">+	repl.size = newinfo-&gt;size;</span>
<span class="p_add">+	ret = translate_table(net, newinfo, entry1, &amp;repl);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto free_newinfo;</span>
 
 	*pinfo = newinfo;
 	*pentry0 = entry1;
<span class="p_chunk">@@ -1780,17 +1626,16 @@</span> <span class="p_context"> translate_compat_table(struct net *net,</span>
 
 free_newinfo:
 	xt_free_table_info(newinfo);
<span class="p_del">-out:</span>
<span class="p_del">-	xt_entry_foreach(iter0, entry0, total_size) {</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+out_unlock:</span>
<span class="p_add">+	xt_compat_flush_offsets(AF_INET);</span>
<span class="p_add">+	xt_compat_unlock(AF_INET);</span>
<span class="p_add">+	xt_entry_foreach(iter0, entry0, compatr-&gt;size) {</span>
 		if (j-- == 0)
 			break;
 		compat_release_entry(iter0);
 	}
 	return ret;
<span class="p_del">-out_unlock:</span>
<span class="p_del">-	xt_compat_flush_offsets(AF_INET);</span>
<span class="p_del">-	xt_compat_unlock(AF_INET);</span>
<span class="p_del">-	goto out;</span>
 }
 
 static int
<span class="p_chunk">@@ -1810,6 +1655,9 @@</span> <span class="p_context"> compat_do_replace(struct net *net, void __user *user, unsigned int len)</span>
 		return -ENOMEM;
 	if (tmp.num_counters &gt;= INT_MAX / sizeof(struct xt_counters))
 		return -ENOMEM;
<span class="p_add">+	if (tmp.num_counters == 0)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	tmp.name[sizeof(tmp.name)-1] = 0;
 
 	newinfo = xt_alloc_table_info(tmp.size);
<span class="p_chunk">@@ -1824,10 +1672,7 @@</span> <span class="p_context"> compat_do_replace(struct net *net, void __user *user, unsigned int len)</span>
 		goto free_newinfo;
 	}
 
<span class="p_del">-	ret = translate_compat_table(net, tmp.name, tmp.valid_hooks,</span>
<span class="p_del">-				     &amp;newinfo, &amp;loc_cpu_entry, tmp.size,</span>
<span class="p_del">-				     tmp.num_entries, tmp.hook_entry,</span>
<span class="p_del">-				     tmp.underflow);</span>
<span class="p_add">+	ret = translate_compat_table(net, &amp;newinfo, &amp;loc_cpu_entry, &amp;tmp);</span>
 	if (ret != 0)
 		goto free_newinfo;
 
<span class="p_header">diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c</span>
<span class="p_header">index 036615125532..d3b64bfedd18 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_input.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_input.c</span>
<span class="p_chunk">@@ -87,7 +87,7 @@</span> <span class="p_context"> int sysctl_tcp_adv_win_scale __read_mostly = 1;</span>
 EXPORT_SYMBOL(sysctl_tcp_adv_win_scale);
 
 /* rfc5961 challenge ack rate limiting */
<span class="p_del">-int sysctl_tcp_challenge_ack_limit = 100;</span>
<span class="p_add">+int sysctl_tcp_challenge_ack_limit = 1000;</span>
 
 int sysctl_tcp_stdurg __read_mostly;
 int sysctl_tcp_rfc1337 __read_mostly;
<span class="p_chunk">@@ -3285,13 +3285,18 @@</span> <span class="p_context"> static void tcp_send_challenge_ack(struct sock *sk)</span>
 	/* unprotected vars, we dont care of overwrites */
 	static u32 challenge_timestamp;
 	static unsigned int challenge_count;
<span class="p_del">-	u32 now = jiffies / HZ;</span>
<span class="p_add">+	u32 count, now = jiffies / HZ;</span>
 
 	if (now != challenge_timestamp) {
<span class="p_add">+		u32 half = (sysctl_tcp_challenge_ack_limit + 1) &gt;&gt; 1;</span>
<span class="p_add">+</span>
 		challenge_timestamp = now;
<span class="p_del">-		challenge_count = 0;</span>
<span class="p_add">+		ACCESS_ONCE(challenge_count) =</span>
<span class="p_add">+			half + prandom_u32_max(sysctl_tcp_challenge_ack_limit);</span>
 	}
<span class="p_del">-	if (++challenge_count &lt;= sysctl_tcp_challenge_ack_limit) {</span>
<span class="p_add">+	count = ACCESS_ONCE(challenge_count);</span>
<span class="p_add">+	if (count &gt; 0) {</span>
<span class="p_add">+		ACCESS_ONCE(challenge_count) = count - 1;</span>
 		NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);
 		tcp_send_ack(sk);
 	}
<span class="p_header">diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c</span>
<span class="p_header">index c844b31c767e..0002aa9ca91a 100644</span>
<span class="p_header">--- a/net/ipv6/addrconf.c</span>
<span class="p_header">+++ b/net/ipv6/addrconf.c</span>
<span class="p_chunk">@@ -4453,15 +4453,13 @@</span> <span class="p_context"> static int inet6_set_iftoken(struct inet6_dev *idev, struct in6_addr *token)</span>
 {
 	struct inet6_ifaddr *ifp;
 	struct net_device *dev = idev-&gt;dev;
<span class="p_del">-	bool update_rs = false;</span>
<span class="p_add">+	bool clear_token, update_rs = false;</span>
 	struct in6_addr ll_addr;
 
 	ASSERT_RTNL();
 
 	if (token == NULL)
 		return -EINVAL;
<span class="p_del">-	if (ipv6_addr_any(token))</span>
<span class="p_del">-		return -EINVAL;</span>
 	if (dev-&gt;flags &amp; (IFF_LOOPBACK | IFF_NOARP))
 		return -EINVAL;
 	if (!ipv6_accept_ra(idev))
<span class="p_chunk">@@ -4476,10 +4474,13 @@</span> <span class="p_context"> static int inet6_set_iftoken(struct inet6_dev *idev, struct in6_addr *token)</span>
 
 	write_unlock_bh(&amp;idev-&gt;lock);
 
<span class="p_add">+	clear_token = ipv6_addr_any(token);</span>
<span class="p_add">+	if (clear_token)</span>
<span class="p_add">+		goto update_lft;</span>
<span class="p_add">+</span>
 	if (!idev-&gt;dead &amp;&amp; (idev-&gt;if_flags &amp; IF_READY) &amp;&amp;
 	    !ipv6_get_lladdr(dev, &amp;ll_addr, IFA_F_TENTATIVE |
 			     IFA_F_OPTIMISTIC)) {
<span class="p_del">-</span>
 		/* If we&#39;re not ready, then normal ifup will take care
 		 * of this. Otherwise, we need to request our rs here.
 		 */
<span class="p_chunk">@@ -4487,6 +4488,7 @@</span> <span class="p_context"> static int inet6_set_iftoken(struct inet6_dev *idev, struct in6_addr *token)</span>
 		update_rs = true;
 	}
 
<span class="p_add">+update_lft:</span>
 	write_lock_bh(&amp;idev-&gt;lock);
 
 	if (update_rs) {
<span class="p_header">diff --git a/net/ipv6/icmp.c b/net/ipv6/icmp.c</span>
<span class="p_header">index f6c84a6eb238..d69f84e5df03 100644</span>
<span class="p_header">--- a/net/ipv6/icmp.c</span>
<span class="p_header">+++ b/net/ipv6/icmp.c</span>
<span class="p_chunk">@@ -97,7 +97,7 @@</span> <span class="p_context"> static void icmpv6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,</span>
 
 	if (!(type &amp; ICMPV6_INFOMSG_MASK))
 		if (icmp6-&gt;icmp6_type == ICMPV6_ECHO_REQUEST)
<span class="p_del">-			ping_err(skb, offset, info);</span>
<span class="p_add">+			ping_err(skb, offset, ntohl(info));</span>
 }
 
 static int icmpv6_rcv(struct sk_buff *skb);
<span class="p_header">diff --git a/net/ipv6/netfilter/ip6_tables.c b/net/ipv6/netfilter/ip6_tables.c</span>
<span class="p_header">index bc0615b1cf63..9802b2469662 100644</span>
<span class="p_header">--- a/net/ipv6/netfilter/ip6_tables.c</span>
<span class="p_header">+++ b/net/ipv6/netfilter/ip6_tables.c</span>
<span class="p_chunk">@@ -526,6 +526,8 @@</span> <span class="p_context"> mark_source_chains(const struct xt_table_info *newinfo,</span>
 				size = e-&gt;next_offset;
 				e = (struct ip6t_entry *)
 					(entry0 + pos + size);
<span class="p_add">+				if (pos + size &gt;= newinfo-&gt;size)</span>
<span class="p_add">+					return 0;</span>
 				e-&gt;counters.pcnt = pos;
 				pos += size;
 			} else {
<span class="p_chunk">@@ -547,6 +549,8 @@</span> <span class="p_context"> mark_source_chains(const struct xt_table_info *newinfo,</span>
 				} else {
 					/* ... this is a fallthru */
 					newpos = pos + e-&gt;next_offset;
<span class="p_add">+					if (newpos &gt;= newinfo-&gt;size)</span>
<span class="p_add">+						return 0;</span>
 				}
 				e = (struct ip6t_entry *)
 					(entry0 + newpos);
<span class="p_chunk">@@ -573,25 +577,6 @@</span> <span class="p_context"> static void cleanup_match(struct xt_entry_match *m, struct net *net)</span>
 	module_put(par.match-&gt;me);
 }
 
<span class="p_del">-static int</span>
<span class="p_del">-check_entry(const struct ip6t_entry *e)</span>
<span class="p_del">-{</span>
<span class="p_del">-	const struct xt_entry_target *t;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!ip6_checkentry(&amp;e-&gt;ipv6))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (e-&gt;target_offset + sizeof(struct xt_entry_target) &gt;</span>
<span class="p_del">-	    e-&gt;next_offset)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	t = ip6t_get_target_c(e);</span>
<span class="p_del">-	if (e-&gt;target_offset + t-&gt;u.target_size &gt; e-&gt;next_offset)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int check_match(struct xt_entry_match *m, struct xt_mtchk_param *par)
 {
 	const struct ip6t_ip6 *ipv6 = par-&gt;entryinfo;
<span class="p_chunk">@@ -749,7 +734,11 @@</span> <span class="p_context"> check_entry_size_and_hooks(struct ip6t_entry *e,</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	err = check_entry(e);</span>
<span class="p_add">+	if (!ip6_checkentry(&amp;e-&gt;ipv6))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = xt_check_entry_offsets(e, e-&gt;elems, e-&gt;target_offset,</span>
<span class="p_add">+				     e-&gt;next_offset);</span>
 	if (err)
 		return err;
 
<span class="p_chunk">@@ -1272,6 +1261,9 @@</span> <span class="p_context"> do_replace(struct net *net, const void __user *user, unsigned int len)</span>
 	/* overflow check */
 	if (tmp.num_counters &gt;= INT_MAX / sizeof(struct xt_counters))
 		return -ENOMEM;
<span class="p_add">+	if (tmp.num_counters == 0)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	tmp.name[sizeof(tmp.name)-1] = 0;
 
 	newinfo = xt_alloc_table_info(tmp.size);
<span class="p_chunk">@@ -1313,56 +1305,17 @@</span> <span class="p_context"> do_add_counters(struct net *net, const void __user *user, unsigned int len,</span>
 	unsigned int i, curcpu;
 	struct xt_counters_info tmp;
 	struct xt_counters *paddc;
<span class="p_del">-	unsigned int num_counters;</span>
<span class="p_del">-	char *name;</span>
<span class="p_del">-	int size;</span>
<span class="p_del">-	void *ptmp;</span>
 	struct xt_table *t;
 	const struct xt_table_info *private;
 	int ret = 0;
 	const void *loc_cpu_entry;
 	struct ip6t_entry *iter;
 	unsigned int addend;
<span class="p_del">-#ifdef CONFIG_COMPAT</span>
<span class="p_del">-	struct compat_xt_counters_info compat_tmp;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (compat) {</span>
<span class="p_del">-		ptmp = &amp;compat_tmp;</span>
<span class="p_del">-		size = sizeof(struct compat_xt_counters_info);</span>
<span class="p_del">-	} else</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	{</span>
<span class="p_del">-		ptmp = &amp;tmp;</span>
<span class="p_del">-		size = sizeof(struct xt_counters_info);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (copy_from_user(ptmp, user, size) != 0)</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_COMPAT</span>
<span class="p_del">-	if (compat) {</span>
<span class="p_del">-		num_counters = compat_tmp.num_counters;</span>
<span class="p_del">-		name = compat_tmp.name;</span>
<span class="p_del">-	} else</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	{</span>
<span class="p_del">-		num_counters = tmp.num_counters;</span>
<span class="p_del">-		name = tmp.name;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (len != size + num_counters * sizeof(struct xt_counters))</span>
<span class="p_del">-		return -EINVAL;</span>
 
<span class="p_del">-	paddc = vmalloc(len - size);</span>
<span class="p_del">-	if (!paddc)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (copy_from_user(paddc, user + size, len - size) != 0) {</span>
<span class="p_del">-		ret = -EFAULT;</span>
<span class="p_del">-		goto free;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	t = xt_find_table_lock(net, AF_INET6, name);</span>
<span class="p_add">+	paddc = xt_copy_counters_from_user(user, len, &amp;tmp, compat);</span>
<span class="p_add">+	if (IS_ERR(paddc))</span>
<span class="p_add">+		return PTR_ERR(paddc);</span>
<span class="p_add">+	t = xt_find_table_lock(net, AF_INET6, tmp.name);</span>
 	if (IS_ERR_OR_NULL(t)) {
 		ret = t ? PTR_ERR(t) : -ENOENT;
 		goto free;
<span class="p_chunk">@@ -1371,7 +1324,7 @@</span> <span class="p_context"> do_add_counters(struct net *net, const void __user *user, unsigned int len,</span>
 
 	local_bh_disable();
 	private = t-&gt;private;
<span class="p_del">-	if (private-&gt;number != num_counters) {</span>
<span class="p_add">+	if (private-&gt;number != tmp.num_counters) {</span>
 		ret = -EINVAL;
 		goto unlock_up_free;
 	}
<span class="p_chunk">@@ -1451,7 +1404,6 @@</span> <span class="p_context"> compat_copy_entry_to_user(struct ip6t_entry *e, void __user **dstptr,</span>
 
 static int
 compat_find_calc_match(struct xt_entry_match *m,
<span class="p_del">-		       const char *name,</span>
 		       const struct ip6t_ip6 *ipv6,
 		       unsigned int hookmask,
 		       int *size)
<span class="p_chunk">@@ -1487,17 +1439,14 @@</span> <span class="p_context"> check_compat_entry_size_and_hooks(struct compat_ip6t_entry *e,</span>
 				  struct xt_table_info *newinfo,
 				  unsigned int *size,
 				  const unsigned char *base,
<span class="p_del">-				  const unsigned char *limit,</span>
<span class="p_del">-				  const unsigned int *hook_entries,</span>
<span class="p_del">-				  const unsigned int *underflows,</span>
<span class="p_del">-				  const char *name)</span>
<span class="p_add">+				  const unsigned char *limit)</span>
 {
 	struct xt_entry_match *ematch;
 	struct xt_entry_target *t;
 	struct xt_target *target;
 	unsigned int entry_offset;
 	unsigned int j;
<span class="p_del">-	int ret, off, h;</span>
<span class="p_add">+	int ret, off;</span>
 
 	duprintf(&quot;check_compat_entry_size_and_hooks %p\n&quot;, e);
 	if ((unsigned long)e % __alignof__(struct compat_ip6t_entry) != 0 ||
<span class="p_chunk">@@ -1514,8 +1463,11 @@</span> <span class="p_context"> check_compat_entry_size_and_hooks(struct compat_ip6t_entry *e,</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	/* For purposes of check_entry casting the compat entry is fine */</span>
<span class="p_del">-	ret = check_entry((struct ip6t_entry *)e);</span>
<span class="p_add">+	if (!ip6_checkentry(&amp;e-&gt;ipv6))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = xt_compat_check_entry_offsets(e, e-&gt;elems,</span>
<span class="p_add">+					    e-&gt;target_offset, e-&gt;next_offset);</span>
 	if (ret)
 		return ret;
 
<span class="p_chunk">@@ -1523,8 +1475,8 @@</span> <span class="p_context"> check_compat_entry_size_and_hooks(struct compat_ip6t_entry *e,</span>
 	entry_offset = (void *)e - (void *)base;
 	j = 0;
 	xt_ematch_foreach(ematch, e) {
<span class="p_del">-		ret = compat_find_calc_match(ematch, name,</span>
<span class="p_del">-					     &amp;e-&gt;ipv6, e-&gt;comefrom, &amp;off);</span>
<span class="p_add">+		ret = compat_find_calc_match(ematch, &amp;e-&gt;ipv6, e-&gt;comefrom,</span>
<span class="p_add">+					     &amp;off);</span>
 		if (ret != 0)
 			goto release_matches;
 		++j;
<span class="p_chunk">@@ -1547,17 +1499,6 @@</span> <span class="p_context"> check_compat_entry_size_and_hooks(struct compat_ip6t_entry *e,</span>
 	if (ret)
 		goto out;
 
<span class="p_del">-	/* Check hooks &amp; underflows */</span>
<span class="p_del">-	for (h = 0; h &lt; NF_INET_NUMHOOKS; h++) {</span>
<span class="p_del">-		if ((unsigned char *)e - base == hook_entries[h])</span>
<span class="p_del">-			newinfo-&gt;hook_entry[h] = hook_entries[h];</span>
<span class="p_del">-		if ((unsigned char *)e - base == underflows[h])</span>
<span class="p_del">-			newinfo-&gt;underflow[h] = underflows[h];</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Clear counters and comefrom */</span>
<span class="p_del">-	memset(&amp;e-&gt;counters, 0, sizeof(e-&gt;counters));</span>
<span class="p_del">-	e-&gt;comefrom = 0;</span>
 	return 0;
 
 out:
<span class="p_chunk">@@ -1571,18 +1512,17 @@</span> <span class="p_context"> release_matches:</span>
 	return ret;
 }
 
<span class="p_del">-static int</span>
<span class="p_add">+static void</span>
 compat_copy_entry_from_user(struct compat_ip6t_entry *e, void **dstptr,
<span class="p_del">-			    unsigned int *size, const char *name,</span>
<span class="p_add">+			    unsigned int *size,</span>
 			    struct xt_table_info *newinfo, unsigned char *base)
 {
 	struct xt_entry_target *t;
 	struct ip6t_entry *de;
 	unsigned int origsize;
<span class="p_del">-	int ret, h;</span>
<span class="p_add">+	int h;</span>
 	struct xt_entry_match *ematch;
 
<span class="p_del">-	ret = 0;</span>
 	origsize = *size;
 	de = (struct ip6t_entry *)*dstptr;
 	memcpy(de, e, sizeof(struct ip6t_entry));
<span class="p_chunk">@@ -1591,11 +1531,9 @@</span> <span class="p_context"> compat_copy_entry_from_user(struct compat_ip6t_entry *e, void **dstptr,</span>
 	*dstptr += sizeof(struct ip6t_entry);
 	*size += sizeof(struct ip6t_entry) - sizeof(struct compat_ip6t_entry);
 
<span class="p_del">-	xt_ematch_foreach(ematch, e) {</span>
<span class="p_del">-		ret = xt_compat_match_from_user(ematch, dstptr, size);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	xt_ematch_foreach(ematch, e)</span>
<span class="p_add">+		xt_compat_match_from_user(ematch, dstptr, size);</span>
<span class="p_add">+</span>
 	de-&gt;target_offset = e-&gt;target_offset - (origsize - *size);
 	t = compat_ip6t_get_target(e);
 	xt_compat_target_from_user(t, dstptr, size);
<span class="p_chunk">@@ -1607,181 +1545,82 @@</span> <span class="p_context"> compat_copy_entry_from_user(struct compat_ip6t_entry *e, void **dstptr,</span>
 		if ((unsigned char *)de - base &lt; newinfo-&gt;underflow[h])
 			newinfo-&gt;underflow[h] -= origsize - *size;
 	}
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int compat_check_entry(struct ip6t_entry *e, struct net *net,</span>
<span class="p_del">-			      const char *name)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int j;</span>
<span class="p_del">-	int ret = 0;</span>
<span class="p_del">-	struct xt_mtchk_param mtpar;</span>
<span class="p_del">-	struct xt_entry_match *ematch;</span>
<span class="p_del">-</span>
<span class="p_del">-	j = 0;</span>
<span class="p_del">-	mtpar.net	= net;</span>
<span class="p_del">-	mtpar.table     = name;</span>
<span class="p_del">-	mtpar.entryinfo = &amp;e-&gt;ipv6;</span>
<span class="p_del">-	mtpar.hook_mask = e-&gt;comefrom;</span>
<span class="p_del">-	mtpar.family    = NFPROTO_IPV6;</span>
<span class="p_del">-	xt_ematch_foreach(ematch, e) {</span>
<span class="p_del">-		ret = check_match(ematch, &amp;mtpar);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			goto cleanup_matches;</span>
<span class="p_del">-		++j;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = check_target(e, net, name);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto cleanup_matches;</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-</span>
<span class="p_del">- cleanup_matches:</span>
<span class="p_del">-	xt_ematch_foreach(ematch, e) {</span>
<span class="p_del">-		if (j-- == 0)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		cleanup_match(ematch, net);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return ret;</span>
 }
 
 static int
 translate_compat_table(struct net *net,
<span class="p_del">-		       const char *name,</span>
<span class="p_del">-		       unsigned int valid_hooks,</span>
 		       struct xt_table_info **pinfo,
 		       void **pentry0,
<span class="p_del">-		       unsigned int total_size,</span>
<span class="p_del">-		       unsigned int number,</span>
<span class="p_del">-		       unsigned int *hook_entries,</span>
<span class="p_del">-		       unsigned int *underflows)</span>
<span class="p_add">+		       const struct compat_ip6t_replace *compatr)</span>
 {
 	unsigned int i, j;
 	struct xt_table_info *newinfo, *info;
 	void *pos, *entry0, *entry1;
 	struct compat_ip6t_entry *iter0;
<span class="p_del">-	struct ip6t_entry *iter1;</span>
<span class="p_add">+	struct ip6t_replace repl;</span>
 	unsigned int size;
 	int ret = 0;
 
 	info = *pinfo;
 	entry0 = *pentry0;
<span class="p_del">-	size = total_size;</span>
<span class="p_del">-	info-&gt;number = number;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Init all hooks to impossible value. */</span>
<span class="p_del">-	for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) {</span>
<span class="p_del">-		info-&gt;hook_entry[i] = 0xFFFFFFFF;</span>
<span class="p_del">-		info-&gt;underflow[i] = 0xFFFFFFFF;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	size = compatr-&gt;size;</span>
<span class="p_add">+	info-&gt;number = compatr-&gt;num_entries;</span>
 
 	duprintf(&quot;translate_compat_table: size %u\n&quot;, info-&gt;size);
 	j = 0;
 	xt_compat_lock(AF_INET6);
<span class="p_del">-	xt_compat_init_offsets(AF_INET6, number);</span>
<span class="p_add">+	xt_compat_init_offsets(AF_INET6, compatr-&gt;num_entries);</span>
 	/* Walk through entries, checking offsets. */
<span class="p_del">-	xt_entry_foreach(iter0, entry0, total_size) {</span>
<span class="p_add">+	xt_entry_foreach(iter0, entry0, compatr-&gt;size) {</span>
 		ret = check_compat_entry_size_and_hooks(iter0, info, &amp;size,
 							entry0,
<span class="p_del">-							entry0 + total_size,</span>
<span class="p_del">-							hook_entries,</span>
<span class="p_del">-							underflows,</span>
<span class="p_del">-							name);</span>
<span class="p_add">+							entry0 + compatr-&gt;size);</span>
 		if (ret != 0)
 			goto out_unlock;
 		++j;
 	}
 
 	ret = -EINVAL;
<span class="p_del">-	if (j != number) {</span>
<span class="p_add">+	if (j != compatr-&gt;num_entries) {</span>
 		duprintf(&quot;translate_compat_table: %u not %u entries\n&quot;,
<span class="p_del">-			 j, number);</span>
<span class="p_add">+			 j, compatr-&gt;num_entries);</span>
 		goto out_unlock;
 	}
 
<span class="p_del">-	/* Check hooks all assigned */</span>
<span class="p_del">-	for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) {</span>
<span class="p_del">-		/* Only hooks which are valid */</span>
<span class="p_del">-		if (!(valid_hooks &amp; (1 &lt;&lt; i)))</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		if (info-&gt;hook_entry[i] == 0xFFFFFFFF) {</span>
<span class="p_del">-			duprintf(&quot;Invalid hook entry %u %u\n&quot;,</span>
<span class="p_del">-				 i, hook_entries[i]);</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (info-&gt;underflow[i] == 0xFFFFFFFF) {</span>
<span class="p_del">-			duprintf(&quot;Invalid underflow %u %u\n&quot;,</span>
<span class="p_del">-				 i, underflows[i]);</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	ret = -ENOMEM;
 	newinfo = xt_alloc_table_info(size);
 	if (!newinfo)
 		goto out_unlock;
 
<span class="p_del">-	newinfo-&gt;number = number;</span>
<span class="p_add">+	newinfo-&gt;number = compatr-&gt;num_entries;</span>
 	for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) {
<span class="p_del">-		newinfo-&gt;hook_entry[i] = info-&gt;hook_entry[i];</span>
<span class="p_del">-		newinfo-&gt;underflow[i] = info-&gt;underflow[i];</span>
<span class="p_add">+		newinfo-&gt;hook_entry[i] = compatr-&gt;hook_entry[i];</span>
<span class="p_add">+		newinfo-&gt;underflow[i] = compatr-&gt;underflow[i];</span>
 	}
 	entry1 = newinfo-&gt;entries[raw_smp_processor_id()];
 	pos = entry1;
<span class="p_del">-	size = total_size;</span>
<span class="p_del">-	xt_entry_foreach(iter0, entry0, total_size) {</span>
<span class="p_del">-		ret = compat_copy_entry_from_user(iter0, &amp;pos, &amp;size,</span>
<span class="p_del">-						  name, newinfo, entry1);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	size = compatr-&gt;size;</span>
<span class="p_add">+	xt_entry_foreach(iter0, entry0, compatr-&gt;size)</span>
<span class="p_add">+		compat_copy_entry_from_user(iter0, &amp;pos, &amp;size,</span>
<span class="p_add">+					    newinfo, entry1);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* all module references in entry0 are now gone. */</span>
 	xt_compat_flush_offsets(AF_INET6);
 	xt_compat_unlock(AF_INET6);
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto free_newinfo;</span>
 
<span class="p_del">-	ret = -ELOOP;</span>
<span class="p_del">-	if (!mark_source_chains(newinfo, valid_hooks, entry1))</span>
<span class="p_del">-		goto free_newinfo;</span>
<span class="p_add">+	memcpy(&amp;repl, compatr, sizeof(*compatr));</span>
 
<span class="p_del">-	i = 0;</span>
<span class="p_del">-	xt_entry_foreach(iter1, entry1, newinfo-&gt;size) {</span>
<span class="p_del">-		ret = compat_check_entry(iter1, net, name);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		++i;</span>
<span class="p_del">-		if (strcmp(ip6t_get_target(iter1)-&gt;u.user.name,</span>
<span class="p_del">-		    XT_ERROR_TARGET) == 0)</span>
<span class="p_del">-			++newinfo-&gt;stacksize;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The first i matches need cleanup_entry (calls -&gt;destroy)</span>
<span class="p_del">-		 * because they had called -&gt;check already. The other j-i</span>
<span class="p_del">-		 * entries need only release.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		int skip = i;</span>
<span class="p_del">-		j -= i;</span>
<span class="p_del">-		xt_entry_foreach(iter0, entry0, newinfo-&gt;size) {</span>
<span class="p_del">-			if (skip-- &gt; 0)</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			if (j-- == 0)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			compat_release_entry(iter0);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		xt_entry_foreach(iter1, entry1, newinfo-&gt;size) {</span>
<span class="p_del">-			if (i-- == 0)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			cleanup_entry(iter1, net);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		xt_free_table_info(newinfo);</span>
<span class="p_del">-		return ret;</span>
<span class="p_add">+	for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) {</span>
<span class="p_add">+		repl.hook_entry[i] = newinfo-&gt;hook_entry[i];</span>
<span class="p_add">+		repl.underflow[i] = newinfo-&gt;underflow[i];</span>
 	}
 
<span class="p_del">-	/* And one copy for every other CPU */</span>
<span class="p_del">-	for_each_possible_cpu(i)</span>
<span class="p_del">-		if (newinfo-&gt;entries[i] &amp;&amp; newinfo-&gt;entries[i] != entry1)</span>
<span class="p_del">-			memcpy(newinfo-&gt;entries[i], entry1, newinfo-&gt;size);</span>
<span class="p_add">+	repl.num_counters = 0;</span>
<span class="p_add">+	repl.counters = NULL;</span>
<span class="p_add">+	repl.size = newinfo-&gt;size;</span>
<span class="p_add">+	ret = translate_table(net, newinfo, entry1, &amp;repl);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto free_newinfo;</span>
 
 	*pinfo = newinfo;
 	*pentry0 = entry1;
<span class="p_chunk">@@ -1790,17 +1629,16 @@</span> <span class="p_context"> translate_compat_table(struct net *net,</span>
 
 free_newinfo:
 	xt_free_table_info(newinfo);
<span class="p_del">-out:</span>
<span class="p_del">-	xt_entry_foreach(iter0, entry0, total_size) {</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+out_unlock:</span>
<span class="p_add">+	xt_compat_flush_offsets(AF_INET6);</span>
<span class="p_add">+	xt_compat_unlock(AF_INET6);</span>
<span class="p_add">+	xt_entry_foreach(iter0, entry0, compatr-&gt;size) {</span>
 		if (j-- == 0)
 			break;
 		compat_release_entry(iter0);
 	}
 	return ret;
<span class="p_del">-out_unlock:</span>
<span class="p_del">-	xt_compat_flush_offsets(AF_INET6);</span>
<span class="p_del">-	xt_compat_unlock(AF_INET6);</span>
<span class="p_del">-	goto out;</span>
 }
 
 static int
<span class="p_chunk">@@ -1820,6 +1658,9 @@</span> <span class="p_context"> compat_do_replace(struct net *net, void __user *user, unsigned int len)</span>
 		return -ENOMEM;
 	if (tmp.num_counters &gt;= INT_MAX / sizeof(struct xt_counters))
 		return -ENOMEM;
<span class="p_add">+	if (tmp.num_counters == 0)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	tmp.name[sizeof(tmp.name)-1] = 0;
 
 	newinfo = xt_alloc_table_info(tmp.size);
<span class="p_chunk">@@ -1834,10 +1675,7 @@</span> <span class="p_context"> compat_do_replace(struct net *net, void __user *user, unsigned int len)</span>
 		goto free_newinfo;
 	}
 
<span class="p_del">-	ret = translate_compat_table(net, tmp.name, tmp.valid_hooks,</span>
<span class="p_del">-				     &amp;newinfo, &amp;loc_cpu_entry, tmp.size,</span>
<span class="p_del">-				     tmp.num_entries, tmp.hook_entry,</span>
<span class="p_del">-				     tmp.underflow);</span>
<span class="p_add">+	ret = translate_compat_table(net, &amp;newinfo, &amp;loc_cpu_entry, &amp;tmp);</span>
 	if (ret != 0)
 		goto free_newinfo;
 
<span class="p_header">diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">index 2350f12eb318..427d164aad46 100644</span>
<span class="p_header">--- a/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">+++ b/net/ipv6/tcp_ipv6.c</span>
<span class="p_chunk">@@ -1804,7 +1804,9 @@</span> <span class="p_context"> static void get_tcp6_sock(struct seq_file *seq, struct sock *sp, int i)</span>
 	destp = ntohs(inet-&gt;inet_dport);
 	srcp  = ntohs(inet-&gt;inet_sport);
 
<span class="p_del">-	if (icsk-&gt;icsk_pending == ICSK_TIME_RETRANS) {</span>
<span class="p_add">+	if (icsk-&gt;icsk_pending == ICSK_TIME_RETRANS ||</span>
<span class="p_add">+	    icsk-&gt;icsk_pending == ICSK_TIME_EARLY_RETRANS ||</span>
<span class="p_add">+	    icsk-&gt;icsk_pending == ICSK_TIME_LOSS_PROBE) {</span>
 		timer_active	= 1;
 		timer_expires	= icsk-&gt;icsk_timeout;
 	} else if (icsk-&gt;icsk_pending == ICSK_TIME_PROBE0) {
<span class="p_header">diff --git a/net/mac80211/mesh.c b/net/mac80211/mesh.c</span>
<span class="p_header">index 3e328131afb5..27b5b3b43744 100644</span>
<span class="p_header">--- a/net/mac80211/mesh.c</span>
<span class="p_header">+++ b/net/mac80211/mesh.c</span>
<span class="p_chunk">@@ -148,19 +148,26 @@</span> <span class="p_context"> u32 mesh_accept_plinks_update(struct ieee80211_sub_if_data *sdata)</span>
 void mesh_sta_cleanup(struct sta_info *sta)
 {
 	struct ieee80211_sub_if_data *sdata = sta-&gt;sdata;
<span class="p_del">-	u32 changed;</span>
<span class="p_add">+	u32 changed = 0;</span>
 
 	/*
 	 * maybe userspace handles peer allocation and peering, but in either
 	 * case the beacon is still generated by the kernel and we might need
 	 * an update.
 	 */
<span class="p_del">-	changed = mesh_accept_plinks_update(sdata);</span>
<span class="p_add">+	if (sdata-&gt;u.mesh.user_mpm &amp;&amp;</span>
<span class="p_add">+	    sta-&gt;plink_state == NL80211_PLINK_ESTAB)</span>
<span class="p_add">+		changed |= mesh_plink_dec_estab_count(sdata);</span>
<span class="p_add">+	changed |= mesh_accept_plinks_update(sdata);</span>
 	if (!sdata-&gt;u.mesh.user_mpm) {
 		changed |= mesh_plink_deactivate(sta);
 		del_timer_sync(&amp;sta-&gt;plink_timer);
 	}
 
<span class="p_add">+	/* make sure no readers can access nexthop sta from here on */</span>
<span class="p_add">+	mesh_path_flush_by_nexthop(sta);</span>
<span class="p_add">+	synchronize_net();</span>
<span class="p_add">+</span>
 	if (changed)
 		ieee80211_mbss_info_change_notify(sdata, changed);
 }
<span class="p_header">diff --git a/net/netfilter/x_tables.c b/net/netfilter/x_tables.c</span>
<span class="p_header">index 227aa11e8409..1393af786e15 100644</span>
<span class="p_header">--- a/net/netfilter/x_tables.c</span>
<span class="p_header">+++ b/net/netfilter/x_tables.c</span>
<span class="p_chunk">@@ -435,6 +435,47 @@</span> <span class="p_context"> int xt_check_match(struct xt_mtchk_param *par,</span>
 }
 EXPORT_SYMBOL_GPL(xt_check_match);
 
<span class="p_add">+/** xt_check_entry_match - check that matches end before start of target</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @match: beginning of xt_entry_match</span>
<span class="p_add">+ * @target: beginning of this rules target (alleged end of matches)</span>
<span class="p_add">+ * @alignment: alignment requirement of match structures</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Validates that all matches add up to the beginning of the target,</span>
<span class="p_add">+ * and that each match covers at least the base structure size.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: 0 on success, negative errno on failure.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int xt_check_entry_match(const char *match, const char *target,</span>
<span class="p_add">+				const size_t alignment)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const struct xt_entry_match *pos;</span>
<span class="p_add">+	int length = target - match;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (length == 0) /* no matches */</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	pos = (struct xt_entry_match *)match;</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		if ((unsigned long)pos % alignment)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (length &lt; (int)sizeof(struct xt_entry_match))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (pos-&gt;u.match_size &lt; sizeof(struct xt_entry_match))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (pos-&gt;u.match_size &gt; length)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		length -= pos-&gt;u.match_size;</span>
<span class="p_add">+		pos = ((void *)((char *)(pos) + (pos)-&gt;u.match_size));</span>
<span class="p_add">+	} while (length &gt; 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #ifdef CONFIG_COMPAT
 int xt_compat_add_offset(u_int8_t af, unsigned int offset, int delta)
 {
<span class="p_chunk">@@ -504,13 +545,14 @@</span> <span class="p_context"> int xt_compat_match_offset(const struct xt_match *match)</span>
 }
 EXPORT_SYMBOL_GPL(xt_compat_match_offset);
 
<span class="p_del">-int xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,</span>
<span class="p_del">-			      unsigned int *size)</span>
<span class="p_add">+void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,</span>
<span class="p_add">+			       unsigned int *size)</span>
 {
 	const struct xt_match *match = m-&gt;u.kernel.match;
 	struct compat_xt_entry_match *cm = (struct compat_xt_entry_match *)m;
 	int pad, off = xt_compat_match_offset(match);
 	u_int16_t msize = cm-&gt;u.user.match_size;
<span class="p_add">+	char name[sizeof(m-&gt;u.user.name)];</span>
 
 	m = *dstptr;
 	memcpy(m, cm, sizeof(*cm));
<span class="p_chunk">@@ -524,10 +566,12 @@</span> <span class="p_context"> int xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,</span>
 
 	msize += off;
 	m-&gt;u.user.match_size = msize;
<span class="p_add">+	strlcpy(name, match-&gt;name, sizeof(name));</span>
<span class="p_add">+	module_put(match-&gt;me);</span>
<span class="p_add">+	strncpy(m-&gt;u.user.name, name, sizeof(m-&gt;u.user.name));</span>
 
 	*size += off;
 	*dstptr += msize;
<span class="p_del">-	return 0;</span>
 }
 EXPORT_SYMBOL_GPL(xt_compat_match_from_user);
 
<span class="p_chunk">@@ -558,8 +602,125 @@</span> <span class="p_context"> int xt_compat_match_to_user(const struct xt_entry_match *m,</span>
 	return 0;
 }
 EXPORT_SYMBOL_GPL(xt_compat_match_to_user);
<span class="p_add">+</span>
<span class="p_add">+/* non-compat version may have padding after verdict */</span>
<span class="p_add">+struct compat_xt_standard_target {</span>
<span class="p_add">+	struct compat_xt_entry_target t;</span>
<span class="p_add">+	compat_uint_t verdict;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+int xt_compat_check_entry_offsets(const void *base, const char *elems,</span>
<span class="p_add">+				  unsigned int target_offset,</span>
<span class="p_add">+				  unsigned int next_offset)</span>
<span class="p_add">+{</span>
<span class="p_add">+	long size_of_base_struct = elems - (const char *)base;</span>
<span class="p_add">+	const struct compat_xt_entry_target *t;</span>
<span class="p_add">+	const char *e = base;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (target_offset &lt; size_of_base_struct)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (target_offset + sizeof(*t) &gt; next_offset)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	t = (void *)(e + target_offset);</span>
<span class="p_add">+	if (t-&gt;u.target_size &lt; sizeof(*t))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (target_offset + t-&gt;u.target_size &gt; next_offset)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (strcmp(t-&gt;u.user.name, XT_STANDARD_TARGET) == 0 &amp;&amp;</span>
<span class="p_add">+	    COMPAT_XT_ALIGN(target_offset + sizeof(struct compat_xt_standard_target)) != next_offset)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* compat_xt_entry match has less strict aligment requirements,</span>
<span class="p_add">+	 * otherwise they are identical.  In case of padding differences</span>
<span class="p_add">+	 * we need to add compat version of xt_check_entry_match.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(struct compat_xt_entry_match) != sizeof(struct xt_entry_match));</span>
<span class="p_add">+</span>
<span class="p_add">+	return xt_check_entry_match(elems, base + target_offset,</span>
<span class="p_add">+				    __alignof__(struct compat_xt_entry_match));</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(xt_compat_check_entry_offsets);</span>
 #endif /* CONFIG_COMPAT */
 
<span class="p_add">+/**</span>
<span class="p_add">+ * xt_check_entry_offsets - validate arp/ip/ip6t_entry</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @base: pointer to arp/ip/ip6t_entry</span>
<span class="p_add">+ * @elems: pointer to first xt_entry_match, i.e. ip(6)t_entry-&gt;elems</span>
<span class="p_add">+ * @target_offset: the arp/ip/ip6_t-&gt;target_offset</span>
<span class="p_add">+ * @next_offset: the arp/ip/ip6_t-&gt;next_offset</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * validates that target_offset and next_offset are sane and that all</span>
<span class="p_add">+ * match sizes (if any) align with the target offset.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This function does not validate the targets or matches themselves, it</span>
<span class="p_add">+ * only tests that all the offsets and sizes are correct, that all</span>
<span class="p_add">+ * match structures are aligned, and that the last structure ends where</span>
<span class="p_add">+ * the target structure begins.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Also see xt_compat_check_entry_offsets for CONFIG_COMPAT version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The arp/ip/ip6t_entry structure @base must have passed following tests:</span>
<span class="p_add">+ * - it must point to a valid memory location</span>
<span class="p_add">+ * - base to base + next_offset must be accessible, i.e. not exceed allocated</span>
<span class="p_add">+ *   length.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * A well-formed entry looks like this:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * ip(6)t_entry   match [mtdata]  match [mtdata] target [tgdata] ip(6)t_entry</span>
<span class="p_add">+ * e-&gt;elems[]-----&#39;                              |               |</span>
<span class="p_add">+ *                matchsize                      |               |</span>
<span class="p_add">+ *                                matchsize      |               |</span>
<span class="p_add">+ *                                               |               |</span>
<span class="p_add">+ * target_offset---------------------------------&#39;               |</span>
<span class="p_add">+ * next_offset---------------------------------------------------&#39;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * elems[]: flexible array member at end of ip(6)/arpt_entry struct.</span>
<span class="p_add">+ *          This is where matches (if any) and the target reside.</span>
<span class="p_add">+ * target_offset: beginning of target.</span>
<span class="p_add">+ * next_offset: start of the next rule; also: size of this rule.</span>
<span class="p_add">+ * Since targets have a minimum size, target_offset + minlen &lt;= next_offset.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Every match stores its size, sum of sizes must not exceed target_offset.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: 0 on success, negative errno on failure.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int xt_check_entry_offsets(const void *base,</span>
<span class="p_add">+			   const char *elems,</span>
<span class="p_add">+			   unsigned int target_offset,</span>
<span class="p_add">+			   unsigned int next_offset)</span>
<span class="p_add">+{</span>
<span class="p_add">+	long size_of_base_struct = elems - (const char *)base;</span>
<span class="p_add">+	const struct xt_entry_target *t;</span>
<span class="p_add">+	const char *e = base;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* target start is within the ip/ip6/arpt_entry struct */</span>
<span class="p_add">+	if (target_offset &lt; size_of_base_struct)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (target_offset + sizeof(*t) &gt; next_offset)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	t = (void *)(e + target_offset);</span>
<span class="p_add">+	if (t-&gt;u.target_size &lt; sizeof(*t))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (target_offset + t-&gt;u.target_size &gt; next_offset)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (strcmp(t-&gt;u.user.name, XT_STANDARD_TARGET) == 0 &amp;&amp;</span>
<span class="p_add">+	    XT_ALIGN(target_offset + sizeof(struct xt_standard_target)) != next_offset)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return xt_check_entry_match(elems, base + target_offset,</span>
<span class="p_add">+				    __alignof__(struct xt_entry_match));</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(xt_check_entry_offsets);</span>
<span class="p_add">+</span>
 int xt_check_target(struct xt_tgchk_param *par,
 		    unsigned int size, u_int8_t proto, bool inv_proto)
 {
<span class="p_chunk">@@ -610,6 +771,80 @@</span> <span class="p_context"> int xt_check_target(struct xt_tgchk_param *par,</span>
 }
 EXPORT_SYMBOL_GPL(xt_check_target);
 
<span class="p_add">+/**</span>
<span class="p_add">+ * xt_copy_counters_from_user - copy counters and metadata from userspace</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @user: src pointer to userspace memory</span>
<span class="p_add">+ * @len: alleged size of userspace memory</span>
<span class="p_add">+ * @info: where to store the xt_counters_info metadata</span>
<span class="p_add">+ * @compat: true if we setsockopt call is done by 32bit task on 64bit kernel</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copies counter meta data from @user and stores it in @info.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * vmallocs memory to hold the counters, then copies the counter data</span>
<span class="p_add">+ * from @user to the new memory and returns a pointer to it.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * If @compat is true, @info gets converted automatically to the 64bit</span>
<span class="p_add">+ * representation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The metadata associated with the counters is stored in @info.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: returns pointer that caller has to test via IS_ERR().</span>
<span class="p_add">+ * If IS_ERR is false, caller has to vfree the pointer.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void *xt_copy_counters_from_user(const void __user *user, unsigned int len,</span>
<span class="p_add">+				 struct xt_counters_info *info, bool compat)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void *mem;</span>
<span class="p_add">+	u64 size;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_COMPAT</span>
<span class="p_add">+	if (compat) {</span>
<span class="p_add">+		/* structures only differ in size due to alignment */</span>
<span class="p_add">+		struct compat_xt_counters_info compat_tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (len &lt;= sizeof(compat_tmp))</span>
<span class="p_add">+			return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
<span class="p_add">+		len -= sizeof(compat_tmp);</span>
<span class="p_add">+		if (copy_from_user(&amp;compat_tmp, user, sizeof(compat_tmp)) != 0)</span>
<span class="p_add">+			return ERR_PTR(-EFAULT);</span>
<span class="p_add">+</span>
<span class="p_add">+		strlcpy(info-&gt;name, compat_tmp.name, sizeof(info-&gt;name));</span>
<span class="p_add">+		info-&gt;num_counters = compat_tmp.num_counters;</span>
<span class="p_add">+		user += sizeof(compat_tmp);</span>
<span class="p_add">+	} else</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	{</span>
<span class="p_add">+		if (len &lt;= sizeof(*info))</span>
<span class="p_add">+			return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
<span class="p_add">+		len -= sizeof(*info);</span>
<span class="p_add">+		if (copy_from_user(info, user, sizeof(*info)) != 0)</span>
<span class="p_add">+			return ERR_PTR(-EFAULT);</span>
<span class="p_add">+</span>
<span class="p_add">+		info-&gt;name[sizeof(info-&gt;name) - 1] = &#39;\0&#39;;</span>
<span class="p_add">+		user += sizeof(*info);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	size = sizeof(struct xt_counters);</span>
<span class="p_add">+	size *= info-&gt;num_counters;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (size != (u64)len)</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
<span class="p_add">+	mem = vmalloc(len);</span>
<span class="p_add">+	if (!mem)</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (copy_from_user(mem, user, len) == 0)</span>
<span class="p_add">+		return mem;</span>
<span class="p_add">+</span>
<span class="p_add">+	vfree(mem);</span>
<span class="p_add">+	return ERR_PTR(-EFAULT);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(xt_copy_counters_from_user);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_COMPAT
 int xt_compat_target_offset(const struct xt_target *target)
 {
<span class="p_chunk">@@ -625,6 +860,7 @@</span> <span class="p_context"> void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,</span>
 	struct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;
 	int pad, off = xt_compat_target_offset(target);
 	u_int16_t tsize = ct-&gt;u.user.target_size;
<span class="p_add">+	char name[sizeof(t-&gt;u.user.name)];</span>
 
 	t = *dstptr;
 	memcpy(t, ct, sizeof(*ct));
<span class="p_chunk">@@ -638,6 +874,9 @@</span> <span class="p_context"> void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,</span>
 
 	tsize += off;
 	t-&gt;u.user.target_size = tsize;
<span class="p_add">+	strlcpy(name, target-&gt;name, sizeof(name));</span>
<span class="p_add">+	module_put(target-&gt;me);</span>
<span class="p_add">+	strncpy(t-&gt;u.user.name, name, sizeof(t-&gt;u.user.name));</span>
 
 	*size += off;
 	*dstptr += tsize;
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index 46cac8e31a16..24876492f26a 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -2693,6 +2693,7 @@</span> <span class="p_context"> static int netlink_dump(struct sock *sk)</span>
 	struct netlink_callback *cb;
 	struct sk_buff *skb = NULL;
 	struct nlmsghdr *nlh;
<span class="p_add">+	struct module *module;</span>
 	int len, err = -ENOBUFS;
 	int alloc_min_size;
 	int alloc_size;
<span class="p_chunk">@@ -2773,9 +2774,11 @@</span> <span class="p_context"> static int netlink_dump(struct sock *sk)</span>
 		cb-&gt;done(cb);
 
 	nlk-&gt;cb_running = false;
<span class="p_add">+	module = cb-&gt;module;</span>
<span class="p_add">+	skb = cb-&gt;skb;</span>
 	mutex_unlock(nlk-&gt;cb_mutex);
<span class="p_del">-	module_put(cb-&gt;module);</span>
<span class="p_del">-	consume_skb(cb-&gt;skb);</span>
<span class="p_add">+	module_put(module);</span>
<span class="p_add">+	consume_skb(skb);</span>
 	return 0;
 
 errout_skb:
<span class="p_header">diff --git a/net/rds/recv.c b/net/rds/recv.c</span>
<span class="p_header">index bd82522534fc..f6839107d020 100644</span>
<span class="p_header">--- a/net/rds/recv.c</span>
<span class="p_header">+++ b/net/rds/recv.c</span>
<span class="p_chunk">@@ -543,5 +543,7 @@</span> <span class="p_context"> void rds_inc_info_copy(struct rds_incoming *inc,</span>
 		minfo.fport = inc-&gt;i_hdr.h_dport;
 	}
 
<span class="p_add">+	minfo.flags = 0;</span>
<span class="p_add">+</span>
 	rds_info_copy(iter, &amp;minfo, sizeof(minfo));
 }
<span class="p_header">diff --git a/net/sched/sch_api.c b/net/sched/sch_api.c</span>
<span class="p_header">index 04de05ae7c5e..8b7e7e25bd72 100644</span>
<span class="p_header">--- a/net/sched/sch_api.c</span>
<span class="p_header">+++ b/net/sched/sch_api.c</span>
<span class="p_chunk">@@ -737,14 +737,15 @@</span> <span class="p_context"> static u32 qdisc_alloc_handle(struct net_device *dev)</span>
 	return 0;
 }
 
<span class="p_del">-void qdisc_tree_decrease_qlen(struct Qdisc *sch, unsigned int n)</span>
<span class="p_add">+void qdisc_tree_reduce_backlog(struct Qdisc *sch, unsigned int n,</span>
<span class="p_add">+			       unsigned int len)</span>
 {
 	const struct Qdisc_class_ops *cops;
 	unsigned long cl;
 	u32 parentid;
 	int drops;
 
<span class="p_del">-	if (n == 0)</span>
<span class="p_add">+	if (n == 0 &amp;&amp; len == 0)</span>
 		return;
 	drops = max_t(int, n, 0);
 	while ((parentid = sch-&gt;parent)) {
<span class="p_chunk">@@ -763,10 +764,11 @@</span> <span class="p_context"> void qdisc_tree_decrease_qlen(struct Qdisc *sch, unsigned int n)</span>
 			cops-&gt;put(sch, cl);
 		}
 		sch-&gt;q.qlen -= n;
<span class="p_add">+		sch-&gt;qstats.backlog -= len;</span>
 		sch-&gt;qstats.drops += drops;
 	}
 }
<span class="p_del">-EXPORT_SYMBOL(qdisc_tree_decrease_qlen);</span>
<span class="p_add">+EXPORT_SYMBOL(qdisc_tree_reduce_backlog);</span>
 
 static void notify_and_destroy(struct net *net, struct sk_buff *skb,
 			       struct nlmsghdr *n, u32 clid,
<span class="p_header">diff --git a/net/sched/sch_cbq.c b/net/sched/sch_cbq.c</span>
<span class="p_header">index ead526467cca..fc0ea5c63521 100644</span>
<span class="p_header">--- a/net/sched/sch_cbq.c</span>
<span class="p_header">+++ b/net/sched/sch_cbq.c</span>
<span class="p_chunk">@@ -1643,13 +1643,8 @@</span> <span class="p_context"> static int cbq_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,</span>
 			new-&gt;reshape_fail = cbq_reshape_fail;
 #endif
 	}
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	*old = cl-&gt;q;</span>
<span class="p_del">-	cl-&gt;q = new;</span>
<span class="p_del">-	qdisc_tree_decrease_qlen(*old, (*old)-&gt;q.qlen);</span>
<span class="p_del">-	qdisc_reset(*old);</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
 
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;cl-&gt;q);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1932,7 +1927,7 @@</span> <span class="p_context"> static int cbq_delete(struct Qdisc *sch, unsigned long arg)</span>
 {
 	struct cbq_sched_data *q = qdisc_priv(sch);
 	struct cbq_class *cl = (struct cbq_class *)arg;
<span class="p_del">-	unsigned int qlen;</span>
<span class="p_add">+	unsigned int qlen, backlog;</span>
 
 	if (cl-&gt;filters || cl-&gt;children || cl == &amp;q-&gt;link)
 		return -EBUSY;
<span class="p_chunk">@@ -1940,8 +1935,9 @@</span> <span class="p_context"> static int cbq_delete(struct Qdisc *sch, unsigned long arg)</span>
 	sch_tree_lock(sch);
 
 	qlen = cl-&gt;q-&gt;q.qlen;
<span class="p_add">+	backlog = cl-&gt;q-&gt;qstats.backlog;</span>
 	qdisc_reset(cl-&gt;q);
<span class="p_del">-	qdisc_tree_decrease_qlen(cl-&gt;q, qlen);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(cl-&gt;q, qlen, backlog);</span>
 
 	if (cl-&gt;next_alive)
 		cbq_deactivate_class(cl);
<span class="p_header">diff --git a/net/sched/sch_choke.c b/net/sched/sch_choke.c</span>
<span class="p_header">index ed30e436128b..ee0223aaf399 100644</span>
<span class="p_header">--- a/net/sched/sch_choke.c</span>
<span class="p_header">+++ b/net/sched/sch_choke.c</span>
<span class="p_chunk">@@ -128,8 +128,8 @@</span> <span class="p_context"> static void choke_drop_by_idx(struct Qdisc *sch, unsigned int idx)</span>
 		choke_zap_tail_holes(q);
 
 	sch-&gt;qstats.backlog -= qdisc_pkt_len(skb);
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, 1, qdisc_pkt_len(skb));</span>
 	qdisc_drop(skb, sch);
<span class="p_del">-	qdisc_tree_decrease_qlen(sch, 1);</span>
 	--sch-&gt;q.qlen;
 }
 
<span class="p_chunk">@@ -437,6 +437,7 @@</span> <span class="p_context"> static int choke_change(struct Qdisc *sch, struct nlattr *opt)</span>
 		old = q-&gt;tab;
 		if (old) {
 			unsigned int oqlen = sch-&gt;q.qlen, tail = 0;
<span class="p_add">+			unsigned dropped = 0;</span>
 
 			while (q-&gt;head != q-&gt;tail) {
 				struct sk_buff *skb = q-&gt;tab[q-&gt;head];
<span class="p_chunk">@@ -448,11 +449,12 @@</span> <span class="p_context"> static int choke_change(struct Qdisc *sch, struct nlattr *opt)</span>
 					ntab[tail++] = skb;
 					continue;
 				}
<span class="p_add">+				dropped += qdisc_pkt_len(skb);</span>
 				sch-&gt;qstats.backlog -= qdisc_pkt_len(skb);
 				--sch-&gt;q.qlen;
 				qdisc_drop(skb, sch);
 			}
<span class="p_del">-			qdisc_tree_decrease_qlen(sch, oqlen - sch-&gt;q.qlen);</span>
<span class="p_add">+			qdisc_tree_reduce_backlog(sch, oqlen - sch-&gt;q.qlen, dropped);</span>
 			q-&gt;head = 0;
 			q-&gt;tail = tail;
 		}
<span class="p_header">diff --git a/net/sched/sch_codel.c b/net/sched/sch_codel.c</span>
<span class="p_header">index 2f9ab17db85a..ebdb01fbdd24 100644</span>
<span class="p_header">--- a/net/sched/sch_codel.c</span>
<span class="p_header">+++ b/net/sched/sch_codel.c</span>
<span class="p_chunk">@@ -79,12 +79,13 @@</span> <span class="p_context"> static struct sk_buff *codel_qdisc_dequeue(struct Qdisc *sch)</span>
 
 	skb = codel_dequeue(sch, &amp;q-&gt;params, &amp;q-&gt;vars, &amp;q-&gt;stats, dequeue);
 
<span class="p_del">-	/* We cant call qdisc_tree_decrease_qlen() if our qlen is 0,</span>
<span class="p_add">+	/* We cant call qdisc_tree_reduce_backlog() if our qlen is 0,</span>
 	 * or HTB crashes. Defer it for next round.
 	 */
 	if (q-&gt;stats.drop_count &amp;&amp; sch-&gt;q.qlen) {
<span class="p_del">-		qdisc_tree_decrease_qlen(sch, q-&gt;stats.drop_count);</span>
<span class="p_add">+		qdisc_tree_reduce_backlog(sch, q-&gt;stats.drop_count, q-&gt;stats.drop_len);</span>
 		q-&gt;stats.drop_count = 0;
<span class="p_add">+		q-&gt;stats.drop_len = 0;</span>
 	}
 	if (skb)
 		qdisc_bstats_update(sch, skb);
<span class="p_chunk">@@ -115,7 +116,7 @@</span> <span class="p_context"> static int codel_change(struct Qdisc *sch, struct nlattr *opt)</span>
 {
 	struct codel_sched_data *q = qdisc_priv(sch);
 	struct nlattr *tb[TCA_CODEL_MAX + 1];
<span class="p_del">-	unsigned int qlen;</span>
<span class="p_add">+	unsigned int qlen, dropped = 0;</span>
 	int err;
 
 	if (!opt)
<span class="p_chunk">@@ -149,10 +150,11 @@</span> <span class="p_context"> static int codel_change(struct Qdisc *sch, struct nlattr *opt)</span>
 	while (sch-&gt;q.qlen &gt; sch-&gt;limit) {
 		struct sk_buff *skb = __skb_dequeue(&amp;sch-&gt;q);
 
<span class="p_add">+		dropped += qdisc_pkt_len(skb);</span>
 		sch-&gt;qstats.backlog -= qdisc_pkt_len(skb);
 		qdisc_drop(skb, sch);
 	}
<span class="p_del">-	qdisc_tree_decrease_qlen(sch, qlen - sch-&gt;q.qlen);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, qlen - sch-&gt;q.qlen, dropped);</span>
 
 	sch_tree_unlock(sch);
 	return 0;
<span class="p_header">diff --git a/net/sched/sch_drr.c b/net/sched/sch_drr.c</span>
<span class="p_header">index 7bbbfe112192..faf83886e7ad 100644</span>
<span class="p_header">--- a/net/sched/sch_drr.c</span>
<span class="p_header">+++ b/net/sched/sch_drr.c</span>
<span class="p_chunk">@@ -53,9 +53,10 @@</span> <span class="p_context"> static struct drr_class *drr_find_class(struct Qdisc *sch, u32 classid)</span>
 static void drr_purge_queue(struct drr_class *cl)
 {
 	unsigned int len = cl-&gt;qdisc-&gt;q.qlen;
<span class="p_add">+	unsigned int backlog = cl-&gt;qdisc-&gt;qstats.backlog;</span>
 
 	qdisc_reset(cl-&gt;qdisc);
<span class="p_del">-	qdisc_tree_decrease_qlen(cl-&gt;qdisc, len);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(cl-&gt;qdisc, len, backlog);</span>
 }
 
 static const struct nla_policy drr_policy[TCA_DRR_MAX + 1] = {
<span class="p_chunk">@@ -224,11 +225,7 @@</span> <span class="p_context"> static int drr_graft_class(struct Qdisc *sch, unsigned long arg,</span>
 			new = &amp;noop_qdisc;
 	}
 
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	drr_purge_queue(cl);</span>
<span class="p_del">-	*old = cl-&gt;qdisc;</span>
<span class="p_del">-	cl-&gt;qdisc = new;</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;cl-&gt;qdisc);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/sched/sch_dsmark.c b/net/sched/sch_dsmark.c</span>
<span class="p_header">index 49d6ef338b55..5b766242af94 100644</span>
<span class="p_header">--- a/net/sched/sch_dsmark.c</span>
<span class="p_header">+++ b/net/sched/sch_dsmark.c</span>
<span class="p_chunk">@@ -67,13 +67,7 @@</span> <span class="p_context"> static int dsmark_graft(struct Qdisc *sch, unsigned long arg,</span>
 			new = &amp;noop_qdisc;
 	}
 
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	*old = p-&gt;q;</span>
<span class="p_del">-	p-&gt;q = new;</span>
<span class="p_del">-	qdisc_tree_decrease_qlen(*old, (*old)-&gt;q.qlen);</span>
<span class="p_del">-	qdisc_reset(*old);</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
<span class="p_del">-</span>
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;p-&gt;q);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/sched/sch_fifo.c b/net/sched/sch_fifo.c</span>
<span class="p_header">index e15a9eb29087..6475419633e1 100644</span>
<span class="p_header">--- a/net/sched/sch_fifo.c</span>
<span class="p_header">+++ b/net/sched/sch_fifo.c</span>
<span class="p_chunk">@@ -37,14 +37,18 @@</span> <span class="p_context"> static int pfifo_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 
 static int pfifo_tail_enqueue(struct sk_buff *skb, struct Qdisc *sch)
 {
<span class="p_add">+	unsigned int prev_backlog;</span>
<span class="p_add">+</span>
 	if (likely(skb_queue_len(&amp;sch-&gt;q) &lt; sch-&gt;limit))
 		return qdisc_enqueue_tail(skb, sch);
 
<span class="p_add">+	prev_backlog = sch-&gt;qstats.backlog;</span>
 	/* queue full, remove one skb to fulfill the limit */
 	__qdisc_queue_drop_head(sch, &amp;sch-&gt;q);
 	sch-&gt;qstats.drops++;
 	qdisc_enqueue_tail(skb, sch);
 
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, 0, prev_backlog - sch-&gt;qstats.backlog);</span>
 	return NET_XMIT_CN;
 }
 
<span class="p_header">diff --git a/net/sched/sch_fq.c b/net/sched/sch_fq.c</span>
<span class="p_header">index ba32c2b005d0..820eceb98d24 100644</span>
<span class="p_header">--- a/net/sched/sch_fq.c</span>
<span class="p_header">+++ b/net/sched/sch_fq.c</span>
<span class="p_chunk">@@ -646,6 +646,7 @@</span> <span class="p_context"> static int fq_change(struct Qdisc *sch, struct nlattr *opt)</span>
 	struct fq_sched_data *q = qdisc_priv(sch);
 	struct nlattr *tb[TCA_FQ_MAX + 1];
 	int err, drop_count = 0;
<span class="p_add">+	unsigned drop_len = 0;</span>
 	u32 fq_log;
 
 	if (!opt)
<span class="p_chunk">@@ -711,10 +712,11 @@</span> <span class="p_context"> static int fq_change(struct Qdisc *sch, struct nlattr *opt)</span>
 
 		if (!skb)
 			break;
<span class="p_add">+		drop_len += qdisc_pkt_len(skb);</span>
 		kfree_skb(skb);
 		drop_count++;
 	}
<span class="p_del">-	qdisc_tree_decrease_qlen(sch, drop_count);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, drop_count, drop_len);</span>
 
 	sch_tree_unlock(sch);
 	return err;
<span class="p_header">diff --git a/net/sched/sch_fq_codel.c b/net/sched/sch_fq_codel.c</span>
<span class="p_header">index 063b726bf1f8..633be4b72e20 100644</span>
<span class="p_header">--- a/net/sched/sch_fq_codel.c</span>
<span class="p_header">+++ b/net/sched/sch_fq_codel.c</span>
<span class="p_chunk">@@ -170,7 +170,7 @@</span> <span class="p_context"> static unsigned int fq_codel_drop(struct Qdisc *sch)</span>
 static int fq_codel_enqueue(struct sk_buff *skb, struct Qdisc *sch)
 {
 	struct fq_codel_sched_data *q = qdisc_priv(sch);
<span class="p_del">-	unsigned int idx;</span>
<span class="p_add">+	unsigned int idx, prev_backlog;</span>
 	struct fq_codel_flow *flow;
 	int uninitialized_var(ret);
 
<span class="p_chunk">@@ -198,6 +198,7 @@</span> <span class="p_context"> static int fq_codel_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 	if (++sch-&gt;q.qlen &lt;= sch-&gt;limit)
 		return NET_XMIT_SUCCESS;
 
<span class="p_add">+	prev_backlog = sch-&gt;qstats.backlog;</span>
 	q-&gt;drop_overlimit++;
 	/* Return Congestion Notification only if we dropped a packet
 	 * from this flow.
<span class="p_chunk">@@ -206,7 +207,7 @@</span> <span class="p_context"> static int fq_codel_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 		return NET_XMIT_CN;
 
 	/* As we dropped a packet, better let upper stack know this */
<span class="p_del">-	qdisc_tree_decrease_qlen(sch, 1);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, 1, prev_backlog - sch-&gt;qstats.backlog);</span>
 	return NET_XMIT_SUCCESS;
 }
 
<span class="p_chunk">@@ -236,6 +237,7 @@</span> <span class="p_context"> static struct sk_buff *fq_codel_dequeue(struct Qdisc *sch)</span>
 	struct fq_codel_flow *flow;
 	struct list_head *head;
 	u32 prev_drop_count, prev_ecn_mark;
<span class="p_add">+	unsigned int prev_backlog;</span>
 
 begin:
 	head = &amp;q-&gt;new_flows;
<span class="p_chunk">@@ -254,6 +256,7 @@</span> <span class="p_context"> begin:</span>
 
 	prev_drop_count = q-&gt;cstats.drop_count;
 	prev_ecn_mark = q-&gt;cstats.ecn_mark;
<span class="p_add">+	prev_backlog = sch-&gt;qstats.backlog;</span>
 
 	skb = codel_dequeue(sch, &amp;q-&gt;cparams, &amp;flow-&gt;cvars, &amp;q-&gt;cstats,
 			    dequeue);
<span class="p_chunk">@@ -271,12 +274,14 @@</span> <span class="p_context"> begin:</span>
 	}
 	qdisc_bstats_update(sch, skb);
 	flow-&gt;deficit -= qdisc_pkt_len(skb);
<span class="p_del">-	/* We cant call qdisc_tree_decrease_qlen() if our qlen is 0,</span>
<span class="p_add">+	/* We cant call qdisc_tree_reduce_backlog() if our qlen is 0,</span>
 	 * or HTB crashes. Defer it for next round.
 	 */
 	if (q-&gt;cstats.drop_count &amp;&amp; sch-&gt;q.qlen) {
<span class="p_del">-		qdisc_tree_decrease_qlen(sch, q-&gt;cstats.drop_count);</span>
<span class="p_add">+		qdisc_tree_reduce_backlog(sch, q-&gt;cstats.drop_count,</span>
<span class="p_add">+					  q-&gt;cstats.drop_len);</span>
 		q-&gt;cstats.drop_count = 0;
<span class="p_add">+		q-&gt;cstats.drop_len = 0;</span>
 	}
 	return skb;
 }
<span class="p_chunk">@@ -344,11 +349,13 @@</span> <span class="p_context"> static int fq_codel_change(struct Qdisc *sch, struct nlattr *opt)</span>
 	while (sch-&gt;q.qlen &gt; sch-&gt;limit) {
 		struct sk_buff *skb = fq_codel_dequeue(sch);
 
<span class="p_add">+		q-&gt;cstats.drop_len += qdisc_pkt_len(skb);</span>
 		kfree_skb(skb);
 		q-&gt;cstats.drop_count++;
 	}
<span class="p_del">-	qdisc_tree_decrease_qlen(sch, q-&gt;cstats.drop_count);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, q-&gt;cstats.drop_count, q-&gt;cstats.drop_len);</span>
 	q-&gt;cstats.drop_count = 0;
<span class="p_add">+	q-&gt;cstats.drop_len = 0;</span>
 
 	sch_tree_unlock(sch);
 	return 0;
<span class="p_header">diff --git a/net/sched/sch_hfsc.c b/net/sched/sch_hfsc.c</span>
<span class="p_header">index ec8aeaac1dd7..90bc6e56f112 100644</span>
<span class="p_header">--- a/net/sched/sch_hfsc.c</span>
<span class="p_header">+++ b/net/sched/sch_hfsc.c</span>
<span class="p_chunk">@@ -895,9 +895,10 @@</span> <span class="p_context"> static void</span>
 hfsc_purge_queue(struct Qdisc *sch, struct hfsc_class *cl)
 {
 	unsigned int len = cl-&gt;qdisc-&gt;q.qlen;
<span class="p_add">+	unsigned int backlog = cl-&gt;qdisc-&gt;qstats.backlog;</span>
 
 	qdisc_reset(cl-&gt;qdisc);
<span class="p_del">-	qdisc_tree_decrease_qlen(cl-&gt;qdisc, len);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(cl-&gt;qdisc, len, backlog);</span>
 }
 
 static void
<span class="p_chunk">@@ -1212,11 +1213,7 @@</span> <span class="p_context"> hfsc_graft_class(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,</span>
 			new = &amp;noop_qdisc;
 	}
 
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	hfsc_purge_queue(sch, cl);</span>
<span class="p_del">-	*old = cl-&gt;qdisc;</span>
<span class="p_del">-	cl-&gt;qdisc = new;</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;cl-&gt;qdisc);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/sched/sch_hhf.c b/net/sched/sch_hhf.c</span>
<span class="p_header">index d85b6812a7d4..cdc1836810c2 100644</span>
<span class="p_header">--- a/net/sched/sch_hhf.c</span>
<span class="p_header">+++ b/net/sched/sch_hhf.c</span>
<span class="p_chunk">@@ -390,6 +390,7 @@</span> <span class="p_context"> static int hhf_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 	struct hhf_sched_data *q = qdisc_priv(sch);
 	enum wdrr_bucket_idx idx;
 	struct wdrr_bucket *bucket;
<span class="p_add">+	unsigned int prev_backlog;</span>
 
 	idx = hhf_classify(skb, sch);
 
<span class="p_chunk">@@ -417,6 +418,7 @@</span> <span class="p_context"> static int hhf_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 	if (++sch-&gt;q.qlen &lt;= sch-&gt;limit)
 		return NET_XMIT_SUCCESS;
 
<span class="p_add">+	prev_backlog = sch-&gt;qstats.backlog;</span>
 	q-&gt;drop_overlimit++;
 	/* Return Congestion Notification only if we dropped a packet from this
 	 * bucket.
<span class="p_chunk">@@ -425,7 +427,7 @@</span> <span class="p_context"> static int hhf_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 		return NET_XMIT_CN;
 
 	/* As we dropped a packet, better let upper stack know this. */
<span class="p_del">-	qdisc_tree_decrease_qlen(sch, 1);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, 1, prev_backlog - sch-&gt;qstats.backlog);</span>
 	return NET_XMIT_SUCCESS;
 }
 
<span class="p_chunk">@@ -535,7 +537,7 @@</span> <span class="p_context"> static int hhf_change(struct Qdisc *sch, struct nlattr *opt)</span>
 {
 	struct hhf_sched_data *q = qdisc_priv(sch);
 	struct nlattr *tb[TCA_HHF_MAX + 1];
<span class="p_del">-	unsigned int qlen;</span>
<span class="p_add">+	unsigned int qlen, prev_backlog;</span>
 	int err;
 	u64 non_hh_quantum;
 	u32 new_quantum = q-&gt;quantum;
<span class="p_chunk">@@ -585,12 +587,14 @@</span> <span class="p_context"> static int hhf_change(struct Qdisc *sch, struct nlattr *opt)</span>
 	}
 
 	qlen = sch-&gt;q.qlen;
<span class="p_add">+	prev_backlog = sch-&gt;qstats.backlog;</span>
 	while (sch-&gt;q.qlen &gt; sch-&gt;limit) {
 		struct sk_buff *skb = hhf_dequeue(sch);
 
 		kfree_skb(skb);
 	}
<span class="p_del">-	qdisc_tree_decrease_qlen(sch, qlen - sch-&gt;q.qlen);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, qlen - sch-&gt;q.qlen,</span>
<span class="p_add">+				  prev_backlog - sch-&gt;qstats.backlog);</span>
 
 	sch_tree_unlock(sch);
 	return 0;
<span class="p_header">diff --git a/net/sched/sch_htb.c b/net/sched/sch_htb.c</span>
<span class="p_header">index 9f949abcacef..718b015da5c3 100644</span>
<span class="p_header">--- a/net/sched/sch_htb.c</span>
<span class="p_header">+++ b/net/sched/sch_htb.c</span>
<span class="p_chunk">@@ -1164,14 +1164,7 @@</span> <span class="p_context"> static int htb_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,</span>
 				     cl-&gt;common.classid)) == NULL)
 		return -ENOBUFS;
 
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	*old = cl-&gt;un.leaf.q;</span>
<span class="p_del">-	cl-&gt;un.leaf.q = new;</span>
<span class="p_del">-	if (*old != NULL) {</span>
<span class="p_del">-		qdisc_tree_decrease_qlen(*old, (*old)-&gt;q.qlen);</span>
<span class="p_del">-		qdisc_reset(*old);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;cl-&gt;un.leaf.q);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1273,7 +1266,6 @@</span> <span class="p_context"> static int htb_delete(struct Qdisc *sch, unsigned long arg)</span>
 {
 	struct htb_sched *q = qdisc_priv(sch);
 	struct htb_class *cl = (struct htb_class *)arg;
<span class="p_del">-	unsigned int qlen;</span>
 	struct Qdisc *new_q = NULL;
 	int last_child = 0;
 
<span class="p_chunk">@@ -1293,9 +1285,11 @@</span> <span class="p_context"> static int htb_delete(struct Qdisc *sch, unsigned long arg)</span>
 	sch_tree_lock(sch);
 
 	if (!cl-&gt;level) {
<span class="p_del">-		qlen = cl-&gt;un.leaf.q-&gt;q.qlen;</span>
<span class="p_add">+		unsigned int qlen = cl-&gt;un.leaf.q-&gt;q.qlen;</span>
<span class="p_add">+		unsigned int backlog = cl-&gt;un.leaf.q-&gt;qstats.backlog;</span>
<span class="p_add">+</span>
 		qdisc_reset(cl-&gt;un.leaf.q);
<span class="p_del">-		qdisc_tree_decrease_qlen(cl-&gt;un.leaf.q, qlen);</span>
<span class="p_add">+		qdisc_tree_reduce_backlog(cl-&gt;un.leaf.q, qlen, backlog);</span>
 	}
 
 	/* delete from hash and active; remainder in destroy_class */
<span class="p_chunk">@@ -1428,10 +1422,11 @@</span> <span class="p_context"> static int htb_change_class(struct Qdisc *sch, u32 classid,</span>
 		sch_tree_lock(sch);
 		if (parent &amp;&amp; !parent-&gt;level) {
 			unsigned int qlen = parent-&gt;un.leaf.q-&gt;q.qlen;
<span class="p_add">+			unsigned int backlog = parent-&gt;un.leaf.q-&gt;qstats.backlog;</span>
 
 			/* turn parent into inner node */
 			qdisc_reset(parent-&gt;un.leaf.q);
<span class="p_del">-			qdisc_tree_decrease_qlen(parent-&gt;un.leaf.q, qlen);</span>
<span class="p_add">+			qdisc_tree_reduce_backlog(parent-&gt;un.leaf.q, qlen, backlog);</span>
 			qdisc_destroy(parent-&gt;un.leaf.q);
 			if (parent-&gt;prio_activity)
 				htb_deactivate(q, parent);
<span class="p_header">diff --git a/net/sched/sch_multiq.c b/net/sched/sch_multiq.c</span>
<span class="p_header">index afb050a735fa..946392276385 100644</span>
<span class="p_header">--- a/net/sched/sch_multiq.c</span>
<span class="p_header">+++ b/net/sched/sch_multiq.c</span>
<span class="p_chunk">@@ -217,7 +217,8 @@</span> <span class="p_context"> static int multiq_tune(struct Qdisc *sch, struct nlattr *opt)</span>
 		if (q-&gt;queues[i] != &amp;noop_qdisc) {
 			struct Qdisc *child = q-&gt;queues[i];
 			q-&gt;queues[i] = &amp;noop_qdisc;
<span class="p_del">-			qdisc_tree_decrease_qlen(child, child-&gt;q.qlen);</span>
<span class="p_add">+			qdisc_tree_reduce_backlog(child, child-&gt;q.qlen,</span>
<span class="p_add">+						  child-&gt;qstats.backlog);</span>
 			qdisc_destroy(child);
 		}
 	}
<span class="p_chunk">@@ -237,8 +238,9 @@</span> <span class="p_context"> static int multiq_tune(struct Qdisc *sch, struct nlattr *opt)</span>
 				q-&gt;queues[i] = child;
 
 				if (old != &amp;noop_qdisc) {
<span class="p_del">-					qdisc_tree_decrease_qlen(old,</span>
<span class="p_del">-								 old-&gt;q.qlen);</span>
<span class="p_add">+					qdisc_tree_reduce_backlog(old,</span>
<span class="p_add">+								  old-&gt;q.qlen,</span>
<span class="p_add">+								  old-&gt;qstats.backlog);</span>
 					qdisc_destroy(old);
 				}
 				sch_tree_unlock(sch);
<span class="p_chunk">@@ -302,13 +304,7 @@</span> <span class="p_context"> static int multiq_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,</span>
 	if (new == NULL)
 		new = &amp;noop_qdisc;
 
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	*old = q-&gt;queues[band];</span>
<span class="p_del">-	q-&gt;queues[band] = new;</span>
<span class="p_del">-	qdisc_tree_decrease_qlen(*old, (*old)-&gt;q.qlen);</span>
<span class="p_del">-	qdisc_reset(*old);</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
<span class="p_del">-</span>
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;q-&gt;queues[band]);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/sched/sch_netem.c b/net/sched/sch_netem.c</span>
<span class="p_header">index 111d70fddaea..73f1db8e8039 100644</span>
<span class="p_header">--- a/net/sched/sch_netem.c</span>
<span class="p_header">+++ b/net/sched/sch_netem.c</span>
<span class="p_chunk">@@ -606,13 +606,14 @@</span> <span class="p_context"> deliver:</span>
 #endif
 
 			if (q-&gt;qdisc) {
<span class="p_add">+				unsigned int pkt_len = qdisc_pkt_len(skb);</span>
 				int err = qdisc_enqueue(skb, q-&gt;qdisc);
 
<span class="p_del">-				if (unlikely(err != NET_XMIT_SUCCESS)) {</span>
<span class="p_del">-					if (net_xmit_drop_count(err)) {</span>
<span class="p_del">-						sch-&gt;qstats.drops++;</span>
<span class="p_del">-						qdisc_tree_decrease_qlen(sch, 1);</span>
<span class="p_del">-					}</span>
<span class="p_add">+				if (err != NET_XMIT_SUCCESS &amp;&amp;</span>
<span class="p_add">+				    net_xmit_drop_count(err)) {</span>
<span class="p_add">+					sch-&gt;qstats.drops++;</span>
<span class="p_add">+					qdisc_tree_reduce_backlog(sch, 1,</span>
<span class="p_add">+								  pkt_len);</span>
 				}
 				goto tfifo_dequeue;
 			}
<span class="p_chunk">@@ -1050,15 +1051,7 @@</span> <span class="p_context"> static int netem_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,</span>
 {
 	struct netem_sched_data *q = qdisc_priv(sch);
 
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	*old = q-&gt;qdisc;</span>
<span class="p_del">-	q-&gt;qdisc = new;</span>
<span class="p_del">-	if (*old) {</span>
<span class="p_del">-		qdisc_tree_decrease_qlen(*old, (*old)-&gt;q.qlen);</span>
<span class="p_del">-		qdisc_reset(*old);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
<span class="p_del">-</span>
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;q-&gt;qdisc);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/sched/sch_pie.c b/net/sched/sch_pie.c</span>
<span class="p_header">index fefeeb73f15f..9c2b8efdb154 100644</span>
<span class="p_header">--- a/net/sched/sch_pie.c</span>
<span class="p_header">+++ b/net/sched/sch_pie.c</span>
<span class="p_chunk">@@ -183,7 +183,7 @@</span> <span class="p_context"> static int pie_change(struct Qdisc *sch, struct nlattr *opt)</span>
 {
 	struct pie_sched_data *q = qdisc_priv(sch);
 	struct nlattr *tb[TCA_PIE_MAX + 1];
<span class="p_del">-	unsigned int qlen;</span>
<span class="p_add">+	unsigned int qlen, dropped = 0;</span>
 	int err;
 
 	if (!opt)
<span class="p_chunk">@@ -232,10 +232,11 @@</span> <span class="p_context"> static int pie_change(struct Qdisc *sch, struct nlattr *opt)</span>
 	while (sch-&gt;q.qlen &gt; sch-&gt;limit) {
 		struct sk_buff *skb = __skb_dequeue(&amp;sch-&gt;q);
 
<span class="p_add">+		dropped += qdisc_pkt_len(skb);</span>
 		sch-&gt;qstats.backlog -= qdisc_pkt_len(skb);
 		qdisc_drop(skb, sch);
 	}
<span class="p_del">-	qdisc_tree_decrease_qlen(sch, qlen - sch-&gt;q.qlen);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, qlen - sch-&gt;q.qlen, dropped);</span>
 
 	sch_tree_unlock(sch);
 	return 0;
<span class="p_header">diff --git a/net/sched/sch_prio.c b/net/sched/sch_prio.c</span>
<span class="p_header">index 79359b69ad8d..fcdc6bc23e56 100644</span>
<span class="p_header">--- a/net/sched/sch_prio.c</span>
<span class="p_header">+++ b/net/sched/sch_prio.c</span>
<span class="p_chunk">@@ -189,7 +189,7 @@</span> <span class="p_context"> static int prio_tune(struct Qdisc *sch, struct nlattr *opt)</span>
 		struct Qdisc *child = q-&gt;queues[i];
 		q-&gt;queues[i] = &amp;noop_qdisc;
 		if (child != &amp;noop_qdisc) {
<span class="p_del">-			qdisc_tree_decrease_qlen(child, child-&gt;q.qlen);</span>
<span class="p_add">+			qdisc_tree_reduce_backlog(child, child-&gt;q.qlen, child-&gt;qstats.backlog);</span>
 			qdisc_destroy(child);
 		}
 	}
<span class="p_chunk">@@ -208,8 +208,9 @@</span> <span class="p_context"> static int prio_tune(struct Qdisc *sch, struct nlattr *opt)</span>
 				q-&gt;queues[i] = child;
 
 				if (old != &amp;noop_qdisc) {
<span class="p_del">-					qdisc_tree_decrease_qlen(old,</span>
<span class="p_del">-								 old-&gt;q.qlen);</span>
<span class="p_add">+					qdisc_tree_reduce_backlog(old,</span>
<span class="p_add">+								  old-&gt;q.qlen,</span>
<span class="p_add">+								  old-&gt;qstats.backlog);</span>
 					qdisc_destroy(old);
 				}
 				sch_tree_unlock(sch);
<span class="p_chunk">@@ -266,13 +267,7 @@</span> <span class="p_context"> static int prio_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,</span>
 	if (new == NULL)
 		new = &amp;noop_qdisc;
 
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	*old = q-&gt;queues[band];</span>
<span class="p_del">-	q-&gt;queues[band] = new;</span>
<span class="p_del">-	qdisc_tree_decrease_qlen(*old, (*old)-&gt;q.qlen);</span>
<span class="p_del">-	qdisc_reset(*old);</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
<span class="p_del">-</span>
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;q-&gt;queues[band]);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/sched/sch_qfq.c b/net/sched/sch_qfq.c</span>
<span class="p_header">index 8056fb4e618a..85b5bee2c6d8 100644</span>
<span class="p_header">--- a/net/sched/sch_qfq.c</span>
<span class="p_header">+++ b/net/sched/sch_qfq.c</span>
<span class="p_chunk">@@ -221,9 +221,10 @@</span> <span class="p_context"> static struct qfq_class *qfq_find_class(struct Qdisc *sch, u32 classid)</span>
 static void qfq_purge_queue(struct qfq_class *cl)
 {
 	unsigned int len = cl-&gt;qdisc-&gt;q.qlen;
<span class="p_add">+	unsigned int backlog = cl-&gt;qdisc-&gt;qstats.backlog;</span>
 
 	qdisc_reset(cl-&gt;qdisc);
<span class="p_del">-	qdisc_tree_decrease_qlen(cl-&gt;qdisc, len);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(cl-&gt;qdisc, len, backlog);</span>
 }
 
 static const struct nla_policy qfq_policy[TCA_QFQ_MAX + 1] = {
<span class="p_chunk">@@ -616,11 +617,7 @@</span> <span class="p_context"> static int qfq_graft_class(struct Qdisc *sch, unsigned long arg,</span>
 			new = &amp;noop_qdisc;
 	}
 
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	qfq_purge_queue(cl);</span>
<span class="p_del">-	*old = cl-&gt;qdisc;</span>
<span class="p_del">-	cl-&gt;qdisc = new;</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;cl-&gt;qdisc);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/sched/sch_red.c b/net/sched/sch_red.c</span>
<span class="p_header">index 633e32defdcc..f4972baf8881 100644</span>
<span class="p_header">--- a/net/sched/sch_red.c</span>
<span class="p_header">+++ b/net/sched/sch_red.c</span>
<span class="p_chunk">@@ -210,7 +210,8 @@</span> <span class="p_context"> static int red_change(struct Qdisc *sch, struct nlattr *opt)</span>
 	q-&gt;flags = ctl-&gt;flags;
 	q-&gt;limit = ctl-&gt;limit;
 	if (child) {
<span class="p_del">-		qdisc_tree_decrease_qlen(q-&gt;qdisc, q-&gt;qdisc-&gt;q.qlen);</span>
<span class="p_add">+		qdisc_tree_reduce_backlog(q-&gt;qdisc, q-&gt;qdisc-&gt;q.qlen,</span>
<span class="p_add">+					  q-&gt;qdisc-&gt;qstats.backlog);</span>
 		qdisc_destroy(q-&gt;qdisc);
 		q-&gt;qdisc = child;
 	}
<span class="p_chunk">@@ -313,12 +314,7 @@</span> <span class="p_context"> static int red_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,</span>
 	if (new == NULL)
 		new = &amp;noop_qdisc;
 
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	*old = q-&gt;qdisc;</span>
<span class="p_del">-	q-&gt;qdisc = new;</span>
<span class="p_del">-	qdisc_tree_decrease_qlen(*old, (*old)-&gt;q.qlen);</span>
<span class="p_del">-	qdisc_reset(*old);</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;q-&gt;qdisc);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/sched/sch_sfb.c b/net/sched/sch_sfb.c</span>
<span class="p_header">index 9b0f7093d970..1d7e94670c77 100644</span>
<span class="p_header">--- a/net/sched/sch_sfb.c</span>
<span class="p_header">+++ b/net/sched/sch_sfb.c</span>
<span class="p_chunk">@@ -516,7 +516,8 @@</span> <span class="p_context"> static int sfb_change(struct Qdisc *sch, struct nlattr *opt)</span>
 
 	sch_tree_lock(sch);
 
<span class="p_del">-	qdisc_tree_decrease_qlen(q-&gt;qdisc, q-&gt;qdisc-&gt;q.qlen);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(q-&gt;qdisc, q-&gt;qdisc-&gt;q.qlen,</span>
<span class="p_add">+				  q-&gt;qdisc-&gt;qstats.backlog);</span>
 	qdisc_destroy(q-&gt;qdisc);
 	q-&gt;qdisc = child;
 
<span class="p_chunk">@@ -612,12 +613,7 @@</span> <span class="p_context"> static int sfb_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,</span>
 	if (new == NULL)
 		new = &amp;noop_qdisc;
 
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	*old = q-&gt;qdisc;</span>
<span class="p_del">-	q-&gt;qdisc = new;</span>
<span class="p_del">-	qdisc_tree_decrease_qlen(*old, (*old)-&gt;q.qlen);</span>
<span class="p_del">-	qdisc_reset(*old);</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;q-&gt;qdisc);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/sched/sch_sfq.c b/net/sched/sch_sfq.c</span>
<span class="p_header">index 1af2f73906d0..78a5d7d43634 100644</span>
<span class="p_header">--- a/net/sched/sch_sfq.c</span>
<span class="p_header">+++ b/net/sched/sch_sfq.c</span>
<span class="p_chunk">@@ -372,7 +372,7 @@</span> <span class="p_context"> static int</span>
 sfq_enqueue(struct sk_buff *skb, struct Qdisc *sch)
 {
 	struct sfq_sched_data *q = qdisc_priv(sch);
<span class="p_del">-	unsigned int hash;</span>
<span class="p_add">+	unsigned int hash, dropped;</span>
 	sfq_index x, qlen;
 	struct sfq_slot *slot;
 	int uninitialized_var(ret);
<span class="p_chunk">@@ -487,7 +487,7 @@</span> <span class="p_context"> enqueue:</span>
 		return NET_XMIT_SUCCESS;
 
 	qlen = slot-&gt;qlen;
<span class="p_del">-	sfq_drop(sch);</span>
<span class="p_add">+	dropped = sfq_drop(sch);</span>
 	/* Return Congestion Notification only if we dropped a packet
 	 * from this flow.
 	 */
<span class="p_chunk">@@ -495,7 +495,7 @@</span> <span class="p_context"> enqueue:</span>
 		return NET_XMIT_CN;
 
 	/* As we dropped a packet, better let upper stack know this */
<span class="p_del">-	qdisc_tree_decrease_qlen(sch, 1);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, 1, dropped);</span>
 	return NET_XMIT_SUCCESS;
 }
 
<span class="p_chunk">@@ -563,6 +563,7 @@</span> <span class="p_context"> static void sfq_rehash(struct Qdisc *sch)</span>
 	struct sfq_slot *slot;
 	struct sk_buff_head list;
 	int dropped = 0;
<span class="p_add">+	unsigned int drop_len = 0;</span>
 
 	__skb_queue_head_init(&amp;list);
 
<span class="p_chunk">@@ -590,6 +591,7 @@</span> <span class="p_context"> static void sfq_rehash(struct Qdisc *sch)</span>
 			x = q-&gt;dep[0].next; /* get a free slot */
 			if (x &gt;= SFQ_MAX_FLOWS) {
 drop:				sch-&gt;qstats.backlog -= qdisc_pkt_len(skb);
<span class="p_add">+				drop_len += qdisc_pkt_len(skb);</span>
 				kfree_skb(skb);
 				dropped++;
 				continue;
<span class="p_chunk">@@ -619,7 +621,7 @@</span> <span class="p_context"> drop:				sch-&gt;qstats.backlog -= qdisc_pkt_len(skb);</span>
 		}
 	}
 	sch-&gt;q.qlen -= dropped;
<span class="p_del">-	qdisc_tree_decrease_qlen(sch, dropped);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, dropped, drop_len);</span>
 }
 
 static void sfq_perturbation(unsigned long arg)
<span class="p_chunk">@@ -643,7 +645,7 @@</span> <span class="p_context"> static int sfq_change(struct Qdisc *sch, struct nlattr *opt)</span>
 	struct sfq_sched_data *q = qdisc_priv(sch);
 	struct tc_sfq_qopt *ctl = nla_data(opt);
 	struct tc_sfq_qopt_v1 *ctl_v1 = NULL;
<span class="p_del">-	unsigned int qlen;</span>
<span class="p_add">+	unsigned int qlen, dropped = 0;</span>
 	struct red_parms *p = NULL;
 
 	if (opt-&gt;nla_len &lt; nla_attr_size(sizeof(*ctl)))
<span class="p_chunk">@@ -692,8 +694,8 @@</span> <span class="p_context"> static int sfq_change(struct Qdisc *sch, struct nlattr *opt)</span>
 
 	qlen = sch-&gt;q.qlen;
 	while (sch-&gt;q.qlen &gt; q-&gt;limit)
<span class="p_del">-		sfq_drop(sch);</span>
<span class="p_del">-	qdisc_tree_decrease_qlen(sch, qlen - sch-&gt;q.qlen);</span>
<span class="p_add">+		dropped += sfq_drop(sch);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, qlen - sch-&gt;q.qlen, dropped);</span>
 
 	del_timer(&amp;q-&gt;perturb_timer);
 	if (q-&gt;perturb_period) {
<span class="p_header">diff --git a/net/sched/sch_tbf.c b/net/sched/sch_tbf.c</span>
<span class="p_header">index 18ff63433709..7c9545f1a391 100644</span>
<span class="p_header">--- a/net/sched/sch_tbf.c</span>
<span class="p_header">+++ b/net/sched/sch_tbf.c</span>
<span class="p_chunk">@@ -160,6 +160,7 @@</span> <span class="p_context"> static int tbf_segment(struct sk_buff *skb, struct Qdisc *sch)</span>
 	struct tbf_sched_data *q = qdisc_priv(sch);
 	struct sk_buff *segs, *nskb;
 	netdev_features_t features = netif_skb_features(skb);
<span class="p_add">+	unsigned int len = 0, prev_len = qdisc_pkt_len(skb);</span>
 	int ret, nb;
 
 	segs = skb_gso_segment(skb, features &amp; ~NETIF_F_GSO_MASK);
<span class="p_chunk">@@ -172,6 +173,7 @@</span> <span class="p_context"> static int tbf_segment(struct sk_buff *skb, struct Qdisc *sch)</span>
 		nskb = segs-&gt;next;
 		segs-&gt;next = NULL;
 		qdisc_skb_cb(segs)-&gt;pkt_len = segs-&gt;len;
<span class="p_add">+		len += segs-&gt;len;</span>
 		ret = qdisc_enqueue(segs, q-&gt;qdisc);
 		if (ret != NET_XMIT_SUCCESS) {
 			if (net_xmit_drop_count(ret))
<span class="p_chunk">@@ -183,7 +185,7 @@</span> <span class="p_context"> static int tbf_segment(struct sk_buff *skb, struct Qdisc *sch)</span>
 	}
 	sch-&gt;q.qlen += nb;
 	if (nb &gt; 1)
<span class="p_del">-		qdisc_tree_decrease_qlen(sch, 1 - nb);</span>
<span class="p_add">+		qdisc_tree_reduce_backlog(sch, 1 - nb, prev_len - len);</span>
 	consume_skb(skb);
 	return nb &gt; 0 ? NET_XMIT_SUCCESS : NET_XMIT_DROP;
 }
<span class="p_chunk">@@ -398,7 +400,8 @@</span> <span class="p_context"> static int tbf_change(struct Qdisc *sch, struct nlattr *opt)</span>
 
 	sch_tree_lock(sch);
 	if (child) {
<span class="p_del">-		qdisc_tree_decrease_qlen(q-&gt;qdisc, q-&gt;qdisc-&gt;q.qlen);</span>
<span class="p_add">+		qdisc_tree_reduce_backlog(q-&gt;qdisc, q-&gt;qdisc-&gt;q.qlen,</span>
<span class="p_add">+					  q-&gt;qdisc-&gt;qstats.backlog);</span>
 		qdisc_destroy(q-&gt;qdisc);
 		q-&gt;qdisc = child;
 	}
<span class="p_chunk">@@ -501,13 +504,7 @@</span> <span class="p_context"> static int tbf_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,</span>
 	if (new == NULL)
 		new = &amp;noop_qdisc;
 
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	*old = q-&gt;qdisc;</span>
<span class="p_del">-	q-&gt;qdisc = new;</span>
<span class="p_del">-	qdisc_tree_decrease_qlen(*old, (*old)-&gt;q.qlen);</span>
<span class="p_del">-	qdisc_reset(*old);</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
<span class="p_del">-</span>
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;q-&gt;qdisc);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_header">index 4ce5eccec1f6..efac1201c55d 100644</span>
<span class="p_header">--- a/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_header">+++ b/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_chunk">@@ -855,8 +855,8 @@</span> <span class="p_context"> unwrap_integ_data(struct svc_rqst *rqstp, struct xdr_buf *buf, u32 seq, struct g</span>
 		goto out;
 	if (svc_getnl(&amp;buf-&gt;head[0]) != seq)
 		goto out;
<span class="p_del">-	/* trim off the mic at the end before returning */</span>
<span class="p_del">-	xdr_buf_trim(buf, mic.len + 4);</span>
<span class="p_add">+	/* trim off the mic and padding at the end before returning */</span>
<span class="p_add">+	xdr_buf_trim(buf, round_up_to_quad(mic.len) + 4);</span>
 	stat = 0;
 out:
 	kfree(mic.data);
<span class="p_header">diff --git a/net/tipc/node.c b/net/tipc/node.c</span>
<span class="p_header">index 5b44c3041be4..1719d277ed60 100644</span>
<span class="p_header">--- a/net/tipc/node.c</span>
<span class="p_header">+++ b/net/tipc/node.c</span>
<span class="p_chunk">@@ -417,7 +417,8 @@</span> <span class="p_context"> struct sk_buff *tipc_node_get_links(const void *req_tlv_area, int req_tlv_space)</span>
 				continue;
 			link_info.dest = htonl(n_ptr-&gt;addr);
 			link_info.up = htonl(tipc_link_is_up(n_ptr-&gt;links[i]));
<span class="p_del">-			strcpy(link_info.str, n_ptr-&gt;links[i]-&gt;name);</span>
<span class="p_add">+			strncpy(link_info.str, n_ptr-&gt;links[i]-&gt;name,</span>
<span class="p_add">+				sizeof(link_info.str));</span>
 			tipc_cfg_append_tlv(buf, TIPC_TLV_LINK_INFO,
 					    &amp;link_info, sizeof(link_info));
 		}
<span class="p_header">diff --git a/scripts/Makefile.extrawarn b/scripts/Makefile.extrawarn</span>
<span class="p_header">index 65643506c71c..17533969a837 100644</span>
<span class="p_header">--- a/scripts/Makefile.extrawarn</span>
<span class="p_header">+++ b/scripts/Makefile.extrawarn</span>
<span class="p_chunk">@@ -24,6 +24,7 @@</span> <span class="p_context"> warning-1 += $(call cc-option, -Wmissing-prototypes)</span>
 warning-1 += -Wold-style-definition
 warning-1 += $(call cc-option, -Wmissing-include-dirs)
 warning-1 += $(call cc-option, -Wunused-but-set-variable)
<span class="p_add">+warning-1 += $(call cc-option, -Wunused-const-variable)</span>
 warning-1 += $(call cc-disable-warning, missing-field-initializers)
 
 # Clang
<span class="p_header">diff --git a/scripts/mod/file2alias.c b/scripts/mod/file2alias.c</span>
<span class="p_header">index e614ef689eee..268acec72c4f 100644</span>
<span class="p_header">--- a/scripts/mod/file2alias.c</span>
<span class="p_header">+++ b/scripts/mod/file2alias.c</span>
<span class="p_chunk">@@ -653,7 +653,7 @@</span> <span class="p_context"> static int do_of_entry (const char *filename, void *symval, char *alias)</span>
 	len = sprintf(alias, &quot;of:N%sT%s&quot;, (*name)[0] ? *name : &quot;*&quot;,
 		      (*type)[0] ? *type : &quot;*&quot;);
 
<span class="p_del">-	if (compatible[0])</span>
<span class="p_add">+	if ((*compatible)[0])</span>
 		sprintf(&amp;alias[len], &quot;%sC%s&quot;, (*type)[0] ? &quot;*&quot; : &quot;&quot;,
 			*compatible);
 
<span class="p_header">diff --git a/security/keys/key.c b/security/keys/key.c</span>
<span class="p_header">index 2048a110e7f1..07cd1fe2a496 100644</span>
<span class="p_header">--- a/security/keys/key.c</span>
<span class="p_header">+++ b/security/keys/key.c</span>
<span class="p_chunk">@@ -575,7 +575,7 @@</span> <span class="p_context"> int key_reject_and_link(struct key *key,</span>
 
 	mutex_unlock(&amp;key_construction_mutex);
 
<span class="p_del">-	if (keyring)</span>
<span class="p_add">+	if (keyring &amp;&amp; link_ret == 0)</span>
 		__key_link_end(keyring, &amp;key-&gt;index_key, edit);
 
 	/* wake up anyone waiting for a key to be constructed */
<span class="p_header">diff --git a/sound/core/compress_offload.c b/sound/core/compress_offload.c</span>
<span class="p_header">index 91525fafe73b..53cd5d69293e 100644</span>
<span class="p_header">--- a/sound/core/compress_offload.c</span>
<span class="p_header">+++ b/sound/core/compress_offload.c</span>
<span class="p_chunk">@@ -500,7 +500,7 @@</span> <span class="p_context"> static int snd_compress_check_input(struct snd_compr_params *params)</span>
 {
 	/* first let&#39;s check the buffer parameter&#39;s */
 	if (params-&gt;buffer.fragment_size == 0 ||
<span class="p_del">-			params-&gt;buffer.fragments &gt; SIZE_MAX / params-&gt;buffer.fragment_size)</span>
<span class="p_add">+	    params-&gt;buffer.fragments &gt; INT_MAX / params-&gt;buffer.fragment_size)</span>
 		return -EINVAL;
 
 	/* now codec parameters */
<span class="p_header">diff --git a/sound/core/timer.c b/sound/core/timer.c</span>
<span class="p_header">index 17538961e357..cdc22503fdb8 100644</span>
<span class="p_header">--- a/sound/core/timer.c</span>
<span class="p_header">+++ b/sound/core/timer.c</span>
<span class="p_chunk">@@ -1251,6 +1251,7 @@</span> <span class="p_context"> static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,</span>
 		tu-&gt;tstamp = *tstamp;
 	if ((tu-&gt;filter &amp; (1 &lt;&lt; event)) == 0 || !tu-&gt;tread)
 		return;
<span class="p_add">+	memset(&amp;r1, 0, sizeof(r1));</span>
 	r1.event = event;
 	r1.tstamp = *tstamp;
 	r1.val = resolution;
<span class="p_chunk">@@ -1285,6 +1286,7 @@</span> <span class="p_context"> static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,</span>
 	}
 	if ((tu-&gt;filter &amp; (1 &lt;&lt; SNDRV_TIMER_EVENT_RESOLUTION)) &amp;&amp;
 	    tu-&gt;last_resolution != resolution) {
<span class="p_add">+		memset(&amp;r1, 0, sizeof(r1));</span>
 		r1.event = SNDRV_TIMER_EVENT_RESOLUTION;
 		r1.tstamp = tstamp;
 		r1.val = resolution;
<span class="p_chunk">@@ -1750,6 +1752,7 @@</span> <span class="p_context"> static int snd_timer_user_params(struct file *file,</span>
 	if (tu-&gt;timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_EARLY_EVENT) {
 		if (tu-&gt;tread) {
 			struct snd_timer_tread tread;
<span class="p_add">+			memset(&amp;tread, 0, sizeof(tread));</span>
 			tread.event = SNDRV_TIMER_EVENT_EARLY;
 			tread.tstamp.tv_sec = 0;
 			tread.tstamp.tv_nsec = 0;
<span class="p_chunk">@@ -1965,6 +1968,7 @@</span> <span class="p_context"> static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,</span>
 
 		qhead = tu-&gt;qhead++;
 		tu-&gt;qhead %= tu-&gt;queue_size;
<span class="p_add">+		tu-&gt;qused--;</span>
 		spin_unlock_irq(&amp;tu-&gt;qlock);
 
 		if (tu-&gt;tread) {
<span class="p_chunk">@@ -1978,7 +1982,6 @@</span> <span class="p_context"> static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,</span>
 		}
 
 		spin_lock_irq(&amp;tu-&gt;qlock);
<span class="p_del">-		tu-&gt;qused--;</span>
 		if (err &lt; 0)
 			goto _error;
 		result += unit;
<span class="p_header">diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c</span>
<span class="p_header">index 387bb8f603ac..35cc884bca6b 100644</span>
<span class="p_header">--- a/sound/drivers/dummy.c</span>
<span class="p_header">+++ b/sound/drivers/dummy.c</span>
<span class="p_chunk">@@ -422,6 +422,7 @@</span> <span class="p_context"> static int dummy_hrtimer_stop(struct snd_pcm_substream *substream)</span>
 
 static inline void dummy_hrtimer_sync(struct dummy_hrtimer_pcm *dpcm)
 {
<span class="p_add">+	hrtimer_cancel(&amp;dpcm-&gt;timer);</span>
 	tasklet_kill(&amp;dpcm-&gt;tasklet);
 }
 
<span class="p_header">diff --git a/sound/pci/au88x0/au88x0_core.c b/sound/pci/au88x0/au88x0_core.c</span>
<span class="p_header">index ae59dbaa53d9..42d4b13f1fa7 100644</span>
<span class="p_header">--- a/sound/pci/au88x0/au88x0_core.c</span>
<span class="p_header">+++ b/sound/pci/au88x0/au88x0_core.c</span>
<span class="p_chunk">@@ -1442,9 +1442,8 @@</span> <span class="p_context"> static int vortex_wtdma_bufshift(vortex_t * vortex, int wtdma)</span>
 	int page, p, pp, delta, i;
 
 	page =
<span class="p_del">-	    (hwread(vortex-&gt;mmio, VORTEX_WTDMA_STAT + (wtdma &lt;&lt; 2)) &amp;</span>
<span class="p_del">-	     WT_SUBBUF_MASK)</span>
<span class="p_del">-	    &gt;&gt; WT_SUBBUF_SHIFT;</span>
<span class="p_add">+	    (hwread(vortex-&gt;mmio, VORTEX_WTDMA_STAT + (wtdma &lt;&lt; 2))</span>
<span class="p_add">+	     &gt;&gt; WT_SUBBUF_SHIFT) &amp; WT_SUBBUF_MASK;</span>
 	if (dma-&gt;nr_periods &gt;= 4)
 		delta = (page - dma-&gt;period_real) &amp; 3;
 	else {
<span class="p_header">diff --git a/sound/pci/echoaudio/echoaudio.c b/sound/pci/echoaudio/echoaudio.c</span>
<span class="p_header">index 9f10c9e0df5e..2838de08be9b 100644</span>
<span class="p_header">--- a/sound/pci/echoaudio/echoaudio.c</span>
<span class="p_header">+++ b/sound/pci/echoaudio/echoaudio.c</span>
<span class="p_chunk">@@ -2253,11 +2253,11 @@</span> <span class="p_context"> static int snd_echo_resume(struct device *dev)</span>
 
 	DE_INIT((&quot;resume start\n&quot;));
 	pci_restore_state(pci);
<span class="p_del">-	commpage_bak = kmalloc(sizeof(struct echoaudio), GFP_KERNEL);</span>
<span class="p_add">+	commpage_bak = kmalloc(sizeof(*commpage), GFP_KERNEL);</span>
 	if (commpage_bak == NULL)
 		return -ENOMEM;
 	commpage = chip-&gt;comm_page;
<span class="p_del">-	memcpy(commpage_bak, commpage, sizeof(struct comm_page));</span>
<span class="p_add">+	memcpy(commpage_bak, commpage, sizeof(*commpage));</span>
 
 	err = init_hw(chip, chip-&gt;pci-&gt;device, chip-&gt;pci-&gt;subsystem_device);
 	if (err &lt; 0) {
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 50d661fe4da0..4dd1538c1257 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -5103,6 +5103,9 @@</span> <span class="p_context"> static const struct hda_model_fixup alc269_fixup_models[] = {</span>
 
 static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {
 	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
<span class="p_add">+		{0x14, 0x90170130},</span>
<span class="p_add">+		{0x21, 0x02211040}),</span>
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
 		{0x12, 0x90a60140},
 		{0x14, 0x90170110},
 		{0x17, 0x40000000},
<span class="p_chunk">@@ -5179,6 +5182,10 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 		{0x1d, 0x40700001},
 		{0x1e, 0x411111f0},
 		{0x21, 0x02211040}),
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell Inspiron 5565&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
<span class="p_add">+		{0x12, 0x90a60180},</span>
<span class="p_add">+		{0x14, 0x90170120},</span>
<span class="p_add">+		{0x21, 0x02211030}),</span>
 	SND_HDA_PIN_QUIRK(0x10ec0282, 0x103c, &quot;HP 15 Touchsmart&quot;, ALC269_FIXUP_HP_MUTE_LED_MIC1,
 		{0x12, 0x99a30130},
 		{0x14, 0x90170110},
<span class="p_header">diff --git a/tools/perf/util/perf_regs.c b/tools/perf/util/perf_regs.c</span>
<span class="p_header">index 43168fb0d9a2..2fb6f2afb84f 100644</span>
<span class="p_header">--- a/tools/perf/util/perf_regs.c</span>
<span class="p_header">+++ b/tools/perf/util/perf_regs.c</span>
<span class="p_chunk">@@ -7,18 +7,18 @@</span> <span class="p_context"> int perf_reg_value(u64 *valp, struct regs_dump *regs, int id)</span>
 	int i, idx = 0;
 	u64 mask = regs-&gt;mask;
 
<span class="p_del">-	if (regs-&gt;cache_mask &amp; (1 &lt;&lt; id))</span>
<span class="p_add">+	if (regs-&gt;cache_mask &amp; (1ULL &lt;&lt; id))</span>
 		goto out;
 
<span class="p_del">-	if (!(mask &amp; (1 &lt;&lt; id)))</span>
<span class="p_add">+	if (!(mask &amp; (1ULL &lt;&lt; id)))</span>
 		return -EINVAL;
 
 	for (i = 0; i &lt; id; i++) {
<span class="p_del">-		if (mask &amp; (1 &lt;&lt; i))</span>
<span class="p_add">+		if (mask &amp; (1ULL &lt;&lt; i))</span>
 			idx++;
 	}
 
<span class="p_del">-	regs-&gt;cache_mask |= (1 &lt;&lt; id);</span>
<span class="p_add">+	regs-&gt;cache_mask |= (1ULL &lt;&lt; id);</span>
 	regs-&gt;cache_regs[id] = regs-&gt;regs[idx];
 
 out:
<span class="p_header">diff --git a/virt/kvm/irqchip.c b/virt/kvm/irqchip.c</span>
<span class="p_header">index b43c275775cd..2a1f6a0a0dff 100644</span>
<span class="p_header">--- a/virt/kvm/irqchip.c</span>
<span class="p_header">+++ b/virt/kvm/irqchip.c</span>
<span class="p_chunk">@@ -127,7 +127,7 @@</span> <span class="p_context"> int kvm_set_irq(struct kvm *kvm, int irq_source_id, u32 irq, int level,</span>
 	 */
 	idx = srcu_read_lock(&amp;kvm-&gt;irq_srcu);
 	irq_rt = srcu_dereference(kvm-&gt;irq_routing, &amp;kvm-&gt;irq_srcu);
<span class="p_del">-	if (irq &lt; irq_rt-&gt;nr_rt_entries)</span>
<span class="p_add">+	if (irq_rt &amp;&amp; irq &lt; irq_rt-&gt;nr_rt_entries)</span>
 		hlist_for_each_entry(e, &amp;irq_rt-&gt;map[irq], link)
 			irq_set[i++] = *e;
 	srcu_read_unlock(&amp;kvm-&gt;irq_srcu, idx);
<span class="p_header">diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c</span>
<span class="p_header">index 18fac68fb0e7..a63127acc67d 100644</span>
<span class="p_header">--- a/virt/kvm/kvm_main.c</span>
<span class="p_header">+++ b/virt/kvm/kvm_main.c</span>
<span class="p_chunk">@@ -2461,7 +2461,7 @@</span> <span class="p_context"> static long kvm_vm_ioctl(struct file *filp,</span>
 		if (copy_from_user(&amp;routing, argp, sizeof(routing)))
 			goto out;
 		r = -EINVAL;
<span class="p_del">-		if (routing.nr &gt;= KVM_MAX_IRQ_ROUTES)</span>
<span class="p_add">+		if (routing.nr &gt; KVM_MAX_IRQ_ROUTES)</span>
 			goto out;
 		if (routing.flags)
 			goto out;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



