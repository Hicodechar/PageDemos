
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.13.6 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.13.6</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 12, 2017, 10:15 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171012101557.GB23083@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10001471/mbox/"
   >mbox</a>
|
   <a href="/patch/10001471/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10001471/">/patch/10001471/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	DDB5F60325 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 12 Oct 2017 10:16:11 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id A0B5128CEE
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 12 Oct 2017 10:16:11 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 948CD28D54; Thu, 12 Oct 2017 10:16:11 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id BDA7528CEE
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 12 Oct 2017 10:16:02 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1754352AbdJLKQA (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 12 Oct 2017 06:16:00 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:35122 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752696AbdJLKPu (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 12 Oct 2017 06:15:50 -0400
Received: from localhost (LFbn-1-12253-150.w90-92.abo.wanadoo.fr
	[90.92.67.150])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id DD8AF958;
	Thu, 12 Oct 2017 10:15:48 +0000 (UTC)
Date: Thu, 12 Oct 2017 12:15:57 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.13.6
Message-ID: &lt;20171012101557.GB23083@kroah.com&gt;
References: &lt;20171012101551.GA23083@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20171012101551.GA23083@kroah.com&gt;
User-Agent: Mutt/1.9.1 (2017-09-22)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Oct. 12, 2017, 10:15 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/filesystems/overlayfs.txt b/Documentation/filesystems/overlayfs.txt</span>
<span class="p_header">index 36f528a7fdd6..8caa60734647 100644</span>
<span class="p_header">--- a/Documentation/filesystems/overlayfs.txt</span>
<span class="p_header">+++ b/Documentation/filesystems/overlayfs.txt</span>
<span class="p_chunk">@@ -210,8 +210,11 @@</span> <span class="p_context"> path as another overlay mount and it may use a lower layer path that is</span>
 beneath or above the path of another overlay lower layer path.
 
 Using an upper layer path and/or a workdir path that are already used by
<span class="p_del">-another overlay mount is not allowed and will fail with EBUSY.  Using</span>
<span class="p_add">+another overlay mount is not allowed and may fail with EBUSY.  Using</span>
 partially overlapping paths is not allowed but will not fail with EBUSY.
<span class="p_add">+If files are accessed from two overlayfs mounts which share or overlap the</span>
<span class="p_add">+upper layer and/or workdir path the behavior of the overlay is undefined,</span>
<span class="p_add">+though it will not result in a crash or deadlock.</span>
 
 Mounting an overlay using an upper layer path, where the upper layer path
 was previously used by another mounted overlay in combination with a
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 189f1a748e4c..9e1af1af327b 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 13
<span class="p_del">-SUBLEVEL = 5</span>
<span class="p_add">+SUBLEVEL = 6</span>
 EXTRAVERSION =
 NAME = Fearless Coyote
 
<span class="p_header">diff --git a/arch/arm64/boot/dts/marvell/armada-ap806.dtsi b/arch/arm64/boot/dts/marvell/armada-ap806.dtsi</span>
<span class="p_header">index 4d360713ed12..30d48ecf46e0 100644</span>
<span class="p_header">--- a/arch/arm64/boot/dts/marvell/armada-ap806.dtsi</span>
<span class="p_header">+++ b/arch/arm64/boot/dts/marvell/armada-ap806.dtsi</span>
<span class="p_chunk">@@ -254,7 +254,7 @@</span> <span class="p_context"></span>
 
 			ap_syscon: system-controller@6f4000 {
 				compatible = &quot;syscon&quot;, &quot;simple-mfd&quot;;
<span class="p_del">-				reg = &lt;0x6f4000 0x1000&gt;;</span>
<span class="p_add">+				reg = &lt;0x6f4000 0x2000&gt;;</span>
 
 				ap_clk: clock {
 					compatible = &quot;marvell,ap806-clock&quot;;
<span class="p_chunk">@@ -265,7 +265,7 @@</span> <span class="p_context"></span>
 					compatible = &quot;marvell,ap806-pinctrl&quot;;
 				};
 
<span class="p_del">-				ap_gpio: gpio {</span>
<span class="p_add">+				ap_gpio: gpio@1040 {</span>
 					compatible = &quot;marvell,armada-8k-gpio&quot;;
 					offset = &lt;0x1040&gt;;
 					ngpios = &lt;20&gt;;
<span class="p_header">diff --git a/arch/arm64/kernel/armv8_deprecated.c b/arch/arm64/kernel/armv8_deprecated.c</span>
<span class="p_header">index f0e6d717885b..d06fbe4cd38d 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/armv8_deprecated.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/armv8_deprecated.c</span>
<span class="p_chunk">@@ -649,4 +649,4 @@</span> <span class="p_context"> static int __init armv8_deprecated_init(void)</span>
 	return 0;
 }
 
<span class="p_del">-late_initcall(armv8_deprecated_init);</span>
<span class="p_add">+core_initcall(armv8_deprecated_init);</span>
<span class="p_header">diff --git a/arch/arm64/kernel/cpufeature.c b/arch/arm64/kernel/cpufeature.c</span>
<span class="p_header">index 9f9e0064c8c1..276eecab6cea 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/cpufeature.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/cpufeature.c</span>
<span class="p_chunk">@@ -1294,4 +1294,4 @@</span> <span class="p_context"> static int __init enable_mrs_emulation(void)</span>
 	return 0;
 }
 
<span class="p_del">-late_initcall(enable_mrs_emulation);</span>
<span class="p_add">+core_initcall(enable_mrs_emulation);</span>
<span class="p_header">diff --git a/arch/powerpc/kernel/dt_cpu_ftrs.c b/arch/powerpc/kernel/dt_cpu_ftrs.c</span>
<span class="p_header">index 1df770e8cbe0..7275fed271af 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/dt_cpu_ftrs.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/dt_cpu_ftrs.c</span>
<span class="p_chunk">@@ -102,10 +102,10 @@</span> <span class="p_context"> static void cpufeatures_flush_tlb(void)</span>
 	case PVR_POWER8:
 	case PVR_POWER8E:
 	case PVR_POWER8NVL:
<span class="p_del">-		__flush_tlb_power8(POWER8_TLB_SETS);</span>
<span class="p_add">+		__flush_tlb_power8(TLB_INVAL_SCOPE_GLOBAL);</span>
 		break;
 	case PVR_POWER9:
<span class="p_del">-		__flush_tlb_power9(POWER9_TLB_SETS_HASH);</span>
<span class="p_add">+		__flush_tlb_power9(TLB_INVAL_SCOPE_GLOBAL);</span>
 		break;
 	default:
 		pr_err(&quot;unknown CPU version for boot TLB flush\n&quot;);
<span class="p_header">diff --git a/arch/powerpc/kernel/exceptions-64s.S b/arch/powerpc/kernel/exceptions-64s.S</span>
<span class="p_header">index f14f3c04ec7e..d9dfdf7ede45 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/exceptions-64s.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/exceptions-64s.S</span>
<span class="p_chunk">@@ -734,7 +734,29 @@</span> <span class="p_context"> EXC_REAL(program_check, 0x700, 0x100)</span>
 EXC_VIRT(program_check, 0x4700, 0x100, 0x700)
 TRAMP_KVM(PACA_EXGEN, 0x700)
 EXC_COMMON_BEGIN(program_check_common)
<span class="p_del">-	EXCEPTION_PROLOG_COMMON(0x700, PACA_EXGEN)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * It&#39;s possible to receive a TM Bad Thing type program check with</span>
<span class="p_add">+	 * userspace register values (in particular r1), but with SRR1 reporting</span>
<span class="p_add">+	 * that we came from the kernel. Normally that would confuse the bad</span>
<span class="p_add">+	 * stack logic, and we would report a bad kernel stack pointer. Instead</span>
<span class="p_add">+	 * we switch to the emergency stack if we&#39;re taking a TM Bad Thing from</span>
<span class="p_add">+	 * the kernel.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	li	r10,MSR_PR		/* Build a mask of MSR_PR ..	*/</span>
<span class="p_add">+	oris	r10,r10,0x200000@h	/* .. and SRR1_PROGTM		*/</span>
<span class="p_add">+	and	r10,r10,r12		/* Mask SRR1 with that.		*/</span>
<span class="p_add">+	srdi	r10,r10,8		/* Shift it so we can compare	*/</span>
<span class="p_add">+	cmpldi	r10,(0x200000 &gt;&gt; 8)	/* .. with an immediate.	*/</span>
<span class="p_add">+	bne 1f				/* If != go to normal path.	*/</span>
<span class="p_add">+</span>
<span class="p_add">+	/* SRR1 had PR=0 and SRR1_PROGTM=1, so use the emergency stack	*/</span>
<span class="p_add">+	andi.	r10,r12,MSR_PR;		/* Set CR0 correctly for label	*/</span>
<span class="p_add">+					/* 3 in EXCEPTION_PROLOG_COMMON	*/</span>
<span class="p_add">+	mr	r10,r1			/* Save r1			*/</span>
<span class="p_add">+	ld	r1,PACAEMERGSP(r13)	/* Use emergency stack		*/</span>
<span class="p_add">+	subi	r1,r1,INT_FRAME_SIZE	/* alloc stack frame		*/</span>
<span class="p_add">+	b 3f				/* Jump into the macro !!	*/</span>
<span class="p_add">+1:	EXCEPTION_PROLOG_COMMON(0x700, PACA_EXGEN)</span>
 	bl	save_nvgprs
 	RECONCILE_IRQ_STATE(r10, r11)
 	addi	r3,r1,STACK_FRAME_OVERHEAD
<span class="p_header">diff --git a/arch/powerpc/kernel/signal_64.c b/arch/powerpc/kernel/signal_64.c</span>
<span class="p_header">index c83c115858c1..b2c002993d78 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/signal_64.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/signal_64.c</span>
<span class="p_chunk">@@ -452,9 +452,20 @@</span> <span class="p_context"> static long restore_tm_sigcontexts(struct task_struct *tsk,</span>
 	if (MSR_TM_RESV(msr))
 		return -EINVAL;
 
<span class="p_del">-	/* pull in MSR TM from user context */</span>
<span class="p_add">+	/* pull in MSR TS bits from user context */</span>
 	regs-&gt;msr = (regs-&gt;msr &amp; ~MSR_TS_MASK) | (msr &amp; MSR_TS_MASK);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Ensure that TM is enabled in regs-&gt;msr before we leave the signal</span>
<span class="p_add">+	 * handler. It could be the case that (a) user disabled the TM bit</span>
<span class="p_add">+	 * through the manipulation of the MSR bits in uc_mcontext or (b) the</span>
<span class="p_add">+	 * TM bit was disabled because a sufficient number of context switches</span>
<span class="p_add">+	 * happened whilst in the signal handler and load_tm overflowed,</span>
<span class="p_add">+	 * disabling the TM bit. In either case we can end up with an illegal</span>
<span class="p_add">+	 * TM state leading to a TM Bad Thing when we return to userspace.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	regs-&gt;msr |= MSR_TM;</span>
<span class="p_add">+</span>
 	/* pull in MSR LE from user context */
 	regs-&gt;msr = (regs-&gt;msr &amp; ~MSR_LE) | (msr &amp; MSR_LE);
 
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_xive.c b/arch/powerpc/kvm/book3s_xive.c</span>
<span class="p_header">index 13304622ab1c..bf457843e032 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_xive.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_xive.c</span>
<span class="p_chunk">@@ -622,7 +622,7 @@</span> <span class="p_context"> int kvmppc_xive_get_xive(struct kvm *kvm, u32 irq, u32 *server,</span>
 		return -EINVAL;
 	state = &amp;sb-&gt;irq_state[idx];
 	arch_spin_lock(&amp;sb-&gt;lock);
<span class="p_del">-	*server = state-&gt;guest_server;</span>
<span class="p_add">+	*server = state-&gt;act_server;</span>
 	*priority = state-&gt;guest_priority;
 	arch_spin_unlock(&amp;sb-&gt;lock);
 
<span class="p_chunk">@@ -1331,7 +1331,7 @@</span> <span class="p_context"> static int xive_get_source(struct kvmppc_xive *xive, long irq, u64 addr)</span>
 	xive-&gt;saved_src_count++;
 
 	/* Convert saved state into something compatible with xics */
<span class="p_del">-	val = state-&gt;guest_server;</span>
<span class="p_add">+	val = state-&gt;act_server;</span>
 	prio = state-&gt;saved_scan_prio;
 
 	if (prio == MASKED) {
<span class="p_chunk">@@ -1507,7 +1507,6 @@</span> <span class="p_context"> static int xive_set_source(struct kvmppc_xive *xive, long irq, u64 addr)</span>
 	/* First convert prio and mark interrupt as untargetted */
 	act_prio = xive_prio_from_guest(guest_prio);
 	state-&gt;act_priority = MASKED;
<span class="p_del">-	state-&gt;guest_server = server;</span>
 
 	/*
 	 * We need to drop the lock due to the mutex below. Hopefully
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_xive.h b/arch/powerpc/kvm/book3s_xive.h</span>
<span class="p_header">index 5938f7644dc1..6ba63f8e8a61 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_xive.h</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_xive.h</span>
<span class="p_chunk">@@ -35,7 +35,6 @@</span> <span class="p_context"> struct kvmppc_xive_irq_state {</span>
 	struct xive_irq_data *pt_data;	/* XIVE Pass-through associated data */
 
 	/* Targetting as set by guest */
<span class="p_del">-	u32 guest_server;		/* Current guest selected target */</span>
 	u8 guest_priority;		/* Guest set priority */
 	u8 saved_priority;		/* Saved priority when masking */
 
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/setup.c b/arch/powerpc/platforms/powernv/setup.c</span>
<span class="p_header">index 897aa1400eb8..bbb73aa0eb8f 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/setup.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/setup.c</span>
<span class="p_chunk">@@ -272,7 +272,15 @@</span> <span class="p_context"> static void pnv_kexec_cpu_down(int crash_shutdown, int secondary)</span>
 #ifdef CONFIG_MEMORY_HOTPLUG_SPARSE
 static unsigned long pnv_memory_block_size(void)
 {
<span class="p_del">-	return 256UL * 1024 * 1024;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We map the kernel linear region with 1GB large pages on radix. For</span>
<span class="p_add">+	 * memory hot unplug to work our memory block size must be at least</span>
<span class="p_add">+	 * this size.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (radix_enabled())</span>
<span class="p_add">+		return 1UL * 1024 * 1024 * 1024;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return 256UL * 1024 * 1024;</span>
 }
 #endif
 
<span class="p_header">diff --git a/arch/x86/include/asm/kvm_para.h b/arch/x86/include/asm/kvm_para.h</span>
<span class="p_header">index bc62e7cbf1b1..59ad3d132353 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/kvm_para.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/kvm_para.h</span>
<span class="p_chunk">@@ -88,7 +88,7 @@</span> <span class="p_context"> static inline long kvm_hypercall4(unsigned int nr, unsigned long p1,</span>
 bool kvm_para_available(void);
 unsigned int kvm_arch_para_features(void);
 void __init kvm_guest_init(void);
<span class="p_del">-void kvm_async_pf_task_wait(u32 token);</span>
<span class="p_add">+void kvm_async_pf_task_wait(u32 token, int interrupt_kernel);</span>
 void kvm_async_pf_task_wake(u32 token);
 u32 kvm_read_and_reset_pf_reason(void);
 extern void kvm_disable_steal_time(void);
<span class="p_chunk">@@ -103,7 +103,7 @@</span> <span class="p_context"> static inline void kvm_spinlock_init(void)</span>
 
 #else /* CONFIG_KVM_GUEST */
 #define kvm_guest_init() do {} while (0)
<span class="p_del">-#define kvm_async_pf_task_wait(T) do {} while(0)</span>
<span class="p_add">+#define kvm_async_pf_task_wait(T, I) do {} while(0)</span>
 #define kvm_async_pf_task_wake(T) do {} while(0)
 
 static inline bool kvm_para_available(void)
<span class="p_header">diff --git a/arch/x86/kernel/kvm.c b/arch/x86/kernel/kvm.c</span>
<span class="p_header">index 58590a698a1a..e5e4306e4546 100644</span>
<span class="p_header">--- a/arch/x86/kernel/kvm.c</span>
<span class="p_header">+++ b/arch/x86/kernel/kvm.c</span>
<span class="p_chunk">@@ -117,7 +117,11 @@</span> <span class="p_context"> static struct kvm_task_sleep_node *_find_apf_task(struct kvm_task_sleep_head *b,</span>
 	return NULL;
 }
 
<span class="p_del">-void kvm_async_pf_task_wait(u32 token)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * @interrupt_kernel: Is this called from a routine which interrupts the kernel</span>
<span class="p_add">+ * 		      (other than user space)?</span>
<span class="p_add">+ */</span>
<span class="p_add">+void kvm_async_pf_task_wait(u32 token, int interrupt_kernel)</span>
 {
 	u32 key = hash_32(token, KVM_TASK_SLEEP_HASHBITS);
 	struct kvm_task_sleep_head *b = &amp;async_pf_sleepers[key];
<span class="p_chunk">@@ -140,8 +144,10 @@</span> <span class="p_context"> void kvm_async_pf_task_wait(u32 token)</span>
 
 	n.token = token;
 	n.cpu = smp_processor_id();
<span class="p_del">-	n.halted = is_idle_task(current) || preempt_count() &gt; 1 ||</span>
<span class="p_del">-		   rcu_preempt_depth();</span>
<span class="p_add">+	n.halted = is_idle_task(current) ||</span>
<span class="p_add">+		   (IS_ENABLED(CONFIG_PREEMPT_COUNT)</span>
<span class="p_add">+		    ? preempt_count() &gt; 1 || rcu_preempt_depth()</span>
<span class="p_add">+		    : interrupt_kernel);</span>
 	init_swait_queue_head(&amp;n.wq);
 	hlist_add_head(&amp;n.link, &amp;b-&gt;list);
 	raw_spin_unlock(&amp;b-&gt;lock);
<span class="p_chunk">@@ -269,7 +275,7 @@</span> <span class="p_context"> do_async_page_fault(struct pt_regs *regs, unsigned long error_code)</span>
 	case KVM_PV_REASON_PAGE_NOT_PRESENT:
 		/* page is swapped out by the host. */
 		prev_state = exception_enter();
<span class="p_del">-		kvm_async_pf_task_wait((u32)read_cr2());</span>
<span class="p_add">+		kvm_async_pf_task_wait((u32)read_cr2(), !user_mode(regs));</span>
 		exception_exit(prev_state);
 		break;
 	case KVM_PV_REASON_PAGE_READY:
<span class="p_header">diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c</span>
<span class="p_header">index 56e68dfac974..7558531c1215 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mmu.c</span>
<span class="p_chunk">@@ -3799,7 +3799,7 @@</span> <span class="p_context"> int kvm_handle_page_fault(struct kvm_vcpu *vcpu, u64 error_code,</span>
 	case KVM_PV_REASON_PAGE_NOT_PRESENT:
 		vcpu-&gt;arch.apf.host_apf_reason = 0;
 		local_irq_disable();
<span class="p_del">-		kvm_async_pf_task_wait(fault_address);</span>
<span class="p_add">+		kvm_async_pf_task_wait(fault_address, 0);</span>
 		local_irq_enable();
 		break;
 	case KVM_PV_REASON_PAGE_READY:
<span class="p_header">diff --git a/arch/x86/net/bpf_jit_comp.c b/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_header">index e1324f280e06..4d50ced94686 100644</span>
<span class="p_header">--- a/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_header">+++ b/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_chunk">@@ -282,9 +282,9 @@</span> <span class="p_context"> static void emit_bpf_tail_call(u8 **pprog)</span>
 	/* if (index &gt;= array-&gt;map.max_entries)
 	 *   goto out;
 	 */
<span class="p_del">-	EMIT4(0x48, 0x8B, 0x46,                   /* mov rax, qword ptr [rsi + 16] */</span>
<span class="p_add">+	EMIT2(0x89, 0xD2);                        /* mov edx, edx */</span>
<span class="p_add">+	EMIT3(0x39, 0x56,                         /* cmp dword ptr [rsi + 16], edx */</span>
 	      offsetof(struct bpf_array, map.max_entries));
<span class="p_del">-	EMIT3(0x48, 0x39, 0xD0);                  /* cmp rax, rdx */</span>
 #define OFFSET1 47 /* number of bytes to jump */
 	EMIT2(X86_JBE, OFFSET1);                  /* jbe out */
 	label1 = cnt;
<span class="p_header">diff --git a/block/bsg-lib.c b/block/bsg-lib.c</span>
<span class="p_header">index c587c71d78af..82ddfcd23939 100644</span>
<span class="p_header">--- a/block/bsg-lib.c</span>
<span class="p_header">+++ b/block/bsg-lib.c</span>
<span class="p_chunk">@@ -207,20 +207,34 @@</span> <span class="p_context"> static int bsg_init_rq(struct request_queue *q, struct request *req, gfp_t gfp)</span>
 	struct bsg_job *job = blk_mq_rq_to_pdu(req);
 	struct scsi_request *sreq = &amp;job-&gt;sreq;
 
<span class="p_add">+	/* called right after the request is allocated for the request_queue */</span>
<span class="p_add">+</span>
<span class="p_add">+	sreq-&gt;sense = kzalloc(SCSI_SENSE_BUFFERSIZE, gfp);</span>
<span class="p_add">+	if (!sreq-&gt;sense)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void bsg_initialize_rq(struct request *req)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct bsg_job *job = blk_mq_rq_to_pdu(req);</span>
<span class="p_add">+	struct scsi_request *sreq = &amp;job-&gt;sreq;</span>
<span class="p_add">+	void *sense = sreq-&gt;sense;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* called right before the request is given to the request_queue user */</span>
<span class="p_add">+</span>
 	memset(job, 0, sizeof(*job));
 
 	scsi_req_init(sreq);
<span class="p_add">+</span>
<span class="p_add">+	sreq-&gt;sense = sense;</span>
 	sreq-&gt;sense_len = SCSI_SENSE_BUFFERSIZE;
<span class="p_del">-	sreq-&gt;sense = kzalloc(sreq-&gt;sense_len, gfp);</span>
<span class="p_del">-	if (!sreq-&gt;sense)</span>
<span class="p_del">-		return -ENOMEM;</span>
 
 	job-&gt;req = req;
<span class="p_del">-	job-&gt;reply = sreq-&gt;sense;</span>
<span class="p_add">+	job-&gt;reply = sense;</span>
 	job-&gt;reply_len = sreq-&gt;sense_len;
 	job-&gt;dd_data = job + 1;
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
 }
 
 static void bsg_exit_rq(struct request_queue *q, struct request *req)
<span class="p_chunk">@@ -250,6 +264,7 @@</span> <span class="p_context"> struct request_queue *bsg_setup_queue(struct device *dev, char *name,</span>
 	q-&gt;cmd_size = sizeof(struct bsg_job) + dd_job_size;
 	q-&gt;init_rq_fn = bsg_init_rq;
 	q-&gt;exit_rq_fn = bsg_exit_rq;
<span class="p_add">+	q-&gt;initialize_rq_fn = bsg_initialize_rq;</span>
 	q-&gt;request_fn = bsg_request_fn;
 
 	ret = blk_init_allocated_queue(q);
<span class="p_header">diff --git a/drivers/auxdisplay/charlcd.c b/drivers/auxdisplay/charlcd.c</span>
<span class="p_header">index cfeb049a01ef..642afd88870b 100644</span>
<span class="p_header">--- a/drivers/auxdisplay/charlcd.c</span>
<span class="p_header">+++ b/drivers/auxdisplay/charlcd.c</span>
<span class="p_chunk">@@ -647,18 +647,25 @@</span> <span class="p_context"> static ssize_t charlcd_write(struct file *file, const char __user *buf,</span>
 static int charlcd_open(struct inode *inode, struct file *file)
 {
 	struct charlcd_priv *priv = to_priv(the_charlcd);
<span class="p_add">+	int ret;</span>
 
<span class="p_add">+	ret = -EBUSY;</span>
 	if (!atomic_dec_and_test(&amp;charlcd_available))
<span class="p_del">-		return -EBUSY;	/* open only once at a time */</span>
<span class="p_add">+		goto fail;	/* open only once at a time */</span>
 
<span class="p_add">+	ret = -EPERM;</span>
 	if (file-&gt;f_mode &amp; FMODE_READ)	/* device is write-only */
<span class="p_del">-		return -EPERM;</span>
<span class="p_add">+		goto fail;</span>
 
 	if (priv-&gt;must_clear) {
 		charlcd_clear_display(&amp;priv-&gt;lcd);
 		priv-&gt;must_clear = false;
 	}
 	return nonseekable_open(inode, file);
<span class="p_add">+</span>
<span class="p_add">+ fail:</span>
<span class="p_add">+	atomic_inc(&amp;charlcd_available);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int charlcd_release(struct inode *inode, struct file *file)
<span class="p_header">diff --git a/drivers/auxdisplay/panel.c b/drivers/auxdisplay/panel.c</span>
<span class="p_header">index 7a8b8fb2f572..c54c20700d37 100644</span>
<span class="p_header">--- a/drivers/auxdisplay/panel.c</span>
<span class="p_header">+++ b/drivers/auxdisplay/panel.c</span>
<span class="p_chunk">@@ -1105,14 +1105,21 @@</span> <span class="p_context"> static ssize_t keypad_read(struct file *file,</span>
 
 static int keypad_open(struct inode *inode, struct file *file)
 {
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = -EBUSY;</span>
 	if (!atomic_dec_and_test(&amp;keypad_available))
<span class="p_del">-		return -EBUSY;	/* open only once at a time */</span>
<span class="p_add">+		goto fail;	/* open only once at a time */</span>
 
<span class="p_add">+	ret = -EPERM;</span>
 	if (file-&gt;f_mode &amp; FMODE_WRITE)	/* device is read-only */
<span class="p_del">-		return -EPERM;</span>
<span class="p_add">+		goto fail;</span>
 
 	keypad_buflen = 0;	/* flush the buffer on opening */
 	return 0;
<span class="p_add">+ fail:</span>
<span class="p_add">+	atomic_inc(&amp;keypad_available);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int keypad_release(struct inode *inode, struct file *file)
<span class="p_header">diff --git a/drivers/base/arch_topology.c b/drivers/base/arch_topology.c</span>
<span class="p_header">index d1c33a85059e..df8945d7f009 100644</span>
<span class="p_header">--- a/drivers/base/arch_topology.c</span>
<span class="p_header">+++ b/drivers/base/arch_topology.c</span>
<span class="p_chunk">@@ -160,12 +160,12 @@</span> <span class="p_context"> int __init topology_parse_cpu_capacity(struct device_node *cpu_node, int cpu)</span>
 }
 
 #ifdef CONFIG_CPU_FREQ
<span class="p_del">-static cpumask_var_t cpus_to_visit;</span>
<span class="p_del">-static bool cap_parsing_done;</span>
<span class="p_del">-static void parsing_done_workfn(struct work_struct *work);</span>
<span class="p_del">-static DECLARE_WORK(parsing_done_work, parsing_done_workfn);</span>
<span class="p_add">+static bool cap_parsing_done __initdata;</span>
<span class="p_add">+static cpumask_var_t cpus_to_visit __initdata;</span>
<span class="p_add">+static void __init parsing_done_workfn(struct work_struct *work);</span>
<span class="p_add">+static __initdata DECLARE_WORK(parsing_done_work, parsing_done_workfn);</span>
 
<span class="p_del">-static int</span>
<span class="p_add">+static int __init</span>
 init_cpu_capacity_callback(struct notifier_block *nb,
 			   unsigned long val,
 			   void *data)
<span class="p_chunk">@@ -200,7 +200,7 @@</span> <span class="p_context"> init_cpu_capacity_callback(struct notifier_block *nb,</span>
 	return 0;
 }
 
<span class="p_del">-static struct notifier_block init_cpu_capacity_notifier = {</span>
<span class="p_add">+static struct notifier_block init_cpu_capacity_notifier __initdata = {</span>
 	.notifier_call = init_cpu_capacity_callback,
 };
 
<span class="p_chunk">@@ -226,7 +226,7 @@</span> <span class="p_context"> static int __init register_cpufreq_notifier(void)</span>
 }
 core_initcall(register_cpufreq_notifier);
 
<span class="p_del">-static void parsing_done_workfn(struct work_struct *work)</span>
<span class="p_add">+static void __init parsing_done_workfn(struct work_struct *work)</span>
 {
 	cpufreq_unregister_notifier(&amp;init_cpu_capacity_notifier,
 					 CPUFREQ_POLICY_NOTIFIER);
<span class="p_header">diff --git a/drivers/base/platform.c b/drivers/base/platform.c</span>
<span class="p_header">index d1bd99271066..9045c5f3734e 100644</span>
<span class="p_header">--- a/drivers/base/platform.c</span>
<span class="p_header">+++ b/drivers/base/platform.c</span>
<span class="p_chunk">@@ -868,7 +868,8 @@</span> <span class="p_context"> static ssize_t driver_override_store(struct device *dev,</span>
 	struct platform_device *pdev = to_platform_device(dev);
 	char *driver_override, *old, *cp;
 
<span class="p_del">-	if (count &gt; PATH_MAX)</span>
<span class="p_add">+	/* We need to keep extra room for a newline */</span>
<span class="p_add">+	if (count &gt;= (PAGE_SIZE - 1))</span>
 		return -EINVAL;
 
 	driver_override = kstrndup(buf, count, GFP_KERNEL);
<span class="p_header">diff --git a/drivers/clk/samsung/clk-exynos4.c b/drivers/clk/samsung/clk-exynos4.c</span>
<span class="p_header">index e40b77583c47..d8d3cb67b402 100644</span>
<span class="p_header">--- a/drivers/clk/samsung/clk-exynos4.c</span>
<span class="p_header">+++ b/drivers/clk/samsung/clk-exynos4.c</span>
<span class="p_chunk">@@ -294,6 +294,18 @@</span> <span class="p_context"> static const struct samsung_clk_reg_dump src_mask_suspend_e4210[] = {</span>
 #define PLL_ENABLED	(1 &lt;&lt; 31)
 #define PLL_LOCKED	(1 &lt;&lt; 29)
 
<span class="p_add">+static void exynos4_clk_enable_pll(u32 reg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 pll_con = readl(reg_base + reg);</span>
<span class="p_add">+	pll_con |= PLL_ENABLED;</span>
<span class="p_add">+	writel(pll_con, reg_base + reg);</span>
<span class="p_add">+</span>
<span class="p_add">+	while (!(pll_con &amp; PLL_LOCKED)) {</span>
<span class="p_add">+		cpu_relax();</span>
<span class="p_add">+		pll_con = readl(reg_base + reg);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void exynos4_clk_wait_for_pll(u32 reg)
 {
 	u32 pll_con;
<span class="p_chunk">@@ -315,6 +327,9 @@</span> <span class="p_context"> static int exynos4_clk_suspend(void)</span>
 	samsung_clk_save(reg_base, exynos4_save_pll,
 				ARRAY_SIZE(exynos4_clk_pll_regs));
 
<span class="p_add">+	exynos4_clk_enable_pll(EPLL_CON0);</span>
<span class="p_add">+	exynos4_clk_enable_pll(VPLL_CON0);</span>
<span class="p_add">+</span>
 	if (exynos4_soc == EXYNOS4210) {
 		samsung_clk_save(reg_base, exynos4_save_soc,
 					ARRAY_SIZE(exynos4210_clk_save));
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_audio.c b/drivers/gpu/drm/i915/intel_audio.c</span>
<span class="p_header">index d805b6e6fe71..27743be5b768 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_audio.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_audio.c</span>
<span class="p_chunk">@@ -606,11 +606,6 @@</span> <span class="p_context"> void intel_audio_codec_enable(struct intel_encoder *intel_encoder,</span>
 			 connector-&gt;encoder-&gt;base.id,
 			 connector-&gt;encoder-&gt;name);
 
<span class="p_del">-	/* ELD Conn_Type */</span>
<span class="p_del">-	connector-&gt;eld[5] &amp;= ~(3 &lt;&lt; 2);</span>
<span class="p_del">-	if (intel_crtc_has_dp_encoder(crtc_state))</span>
<span class="p_del">-		connector-&gt;eld[5] |= (1 &lt;&lt; 2);</span>
<span class="p_del">-</span>
 	connector-&gt;eld[6] = drm_av_sync_delay(connector, adjusted_mode) / 2;
 
 	if (dev_priv-&gt;display.audio_codec_enable)
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_bios.c b/drivers/gpu/drm/i915/intel_bios.c</span>
<span class="p_header">index 7ea7fd1e8856..645488071944 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_bios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_bios.c</span>
<span class="p_chunk">@@ -1163,6 +1163,13 @@</span> <span class="p_context"> static void parse_ddi_port(struct drm_i915_private *dev_priv, enum port port,</span>
 	is_hdmi = is_dvi &amp;&amp; (child-&gt;common.device_type &amp; DEVICE_TYPE_NOT_HDMI_OUTPUT) == 0;
 	is_edp = is_dp &amp;&amp; (child-&gt;common.device_type &amp; DEVICE_TYPE_INTERNAL_CONNECTOR);
 
<span class="p_add">+	if (port == PORT_A &amp;&amp; is_dvi) {</span>
<span class="p_add">+		DRM_DEBUG_KMS(&quot;VBT claims port A supports DVI%s, ignoring\n&quot;,</span>
<span class="p_add">+			      is_hdmi ? &quot;/HDMI&quot; : &quot;&quot;);</span>
<span class="p_add">+		is_dvi = false;</span>
<span class="p_add">+		is_hdmi = false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	info-&gt;supports_dvi = is_dvi;
 	info-&gt;supports_hdmi = is_hdmi;
 	info-&gt;supports_dp = is_dp;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_modes.c b/drivers/gpu/drm/i915/intel_modes.c</span>
<span class="p_header">index 951e834dd274..28a778b785ac 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_modes.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_modes.c</span>
<span class="p_chunk">@@ -30,6 +30,21 @@</span> <span class="p_context"></span>
 #include &quot;intel_drv.h&quot;
 #include &quot;i915_drv.h&quot;
 
<span class="p_add">+static void intel_connector_update_eld_conn_type(struct drm_connector *connector)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 conn_type;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (connector-&gt;connector_type == DRM_MODE_CONNECTOR_DisplayPort ||</span>
<span class="p_add">+	    connector-&gt;connector_type == DRM_MODE_CONNECTOR_eDP) {</span>
<span class="p_add">+		conn_type = DRM_ELD_CONN_TYPE_DP;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		conn_type = DRM_ELD_CONN_TYPE_HDMI;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	connector-&gt;eld[DRM_ELD_SAD_COUNT_CONN_TYPE] &amp;= ~DRM_ELD_CONN_TYPE_MASK;</span>
<span class="p_add">+	connector-&gt;eld[DRM_ELD_SAD_COUNT_CONN_TYPE] |= conn_type;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * intel_connector_update_modes - update connector from edid
  * @connector: DRM connector device to use
<span class="p_chunk">@@ -44,6 +59,8 @@</span> <span class="p_context"> int intel_connector_update_modes(struct drm_connector *connector,</span>
 	ret = drm_add_edid_modes(connector, edid);
 	drm_edid_to_eld(connector, edid);
 
<span class="p_add">+	intel_connector_update_eld_conn_type(connector);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/hid/hid-rmi.c b/drivers/hid/hid-rmi.c</span>
<span class="p_header">index 5b40c2614599..ef241d66562e 100644</span>
<span class="p_header">--- a/drivers/hid/hid-rmi.c</span>
<span class="p_header">+++ b/drivers/hid/hid-rmi.c</span>
<span class="p_chunk">@@ -436,17 +436,24 @@</span> <span class="p_context"> static int rmi_post_resume(struct hid_device *hdev)</span>
 	if (!(data-&gt;device_flags &amp; RMI_DEVICE))
 		return 0;
 
<span class="p_del">-	ret = rmi_reset_attn_mode(hdev);</span>
<span class="p_add">+	/* Make sure the HID device is ready to receive events */</span>
<span class="p_add">+	ret = hid_hw_open(hdev);</span>
 	if (ret)
 		return ret;
 
<span class="p_add">+	ret = rmi_reset_attn_mode(hdev);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	ret = rmi_driver_resume(rmi_dev, false);
 	if (ret) {
 		hid_warn(hdev, &quot;Failed to resume device: %d\n&quot;, ret);
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto out;</span>
 	}
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+out:</span>
<span class="p_add">+	hid_hw_close(hdev);</span>
<span class="p_add">+	return ret;</span>
 }
 #endif /* CONFIG_PM */
 
<span class="p_header">diff --git a/drivers/hid/i2c-hid/i2c-hid.c b/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_header">index 046f692fd0a2..364150435c62 100644</span>
<span class="p_header">--- a/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_header">+++ b/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_chunk">@@ -543,7 +543,8 @@</span> <span class="p_context"> static int i2c_hid_alloc_buffers(struct i2c_hid *ihid, size_t report_size)</span>
 {
 	/* the worst case is computed from the set_report command with a
 	 * reportID &gt; 15 and the maximum report length */
<span class="p_del">-	int args_len = sizeof(__u8) + /* optional ReportID byte */</span>
<span class="p_add">+	int args_len = sizeof(__u8) + /* ReportID */</span>
<span class="p_add">+		       sizeof(__u8) + /* optional ReportID byte */</span>
 		       sizeof(__u16) + /* data register */
 		       sizeof(__u16) + /* size of the report */
 		       report_size; /* report */
<span class="p_header">diff --git a/drivers/hid/wacom_sys.c b/drivers/hid/wacom_sys.c</span>
<span class="p_header">index 838c1ebfffa9..a805ee2989cb 100644</span>
<span class="p_header">--- a/drivers/hid/wacom_sys.c</span>
<span class="p_header">+++ b/drivers/hid/wacom_sys.c</span>
<span class="p_chunk">@@ -668,8 +668,10 @@</span> <span class="p_context"> static struct wacom_hdev_data *wacom_get_hdev_data(struct hid_device *hdev)</span>
 
 	/* Try to find an already-probed interface from the same device */
 	list_for_each_entry(data, &amp;wacom_udev_list, list) {
<span class="p_del">-		if (compare_device_paths(hdev, data-&gt;dev, &#39;/&#39;))</span>
<span class="p_add">+		if (compare_device_paths(hdev, data-&gt;dev, &#39;/&#39;)) {</span>
<span class="p_add">+			kref_get(&amp;data-&gt;kref);</span>
 			return data;
<span class="p_add">+		}</span>
 	}
 
 	/* Fallback to finding devices that appear to be &quot;siblings&quot; */
<span class="p_chunk">@@ -766,6 +768,9 @@</span> <span class="p_context"> static int wacom_led_control(struct wacom *wacom)</span>
 	if (!wacom-&gt;led.groups)
 		return -ENOTSUPP;
 
<span class="p_add">+	if (wacom-&gt;wacom_wac.features.type == REMOTE)</span>
<span class="p_add">+		return -ENOTSUPP;</span>
<span class="p_add">+</span>
 	if (wacom-&gt;wacom_wac.pid) { /* wireless connected */
 		report_id = WAC_CMD_WL_LED_CONTROL;
 		buf_size = 13;
<span class="p_header">diff --git a/drivers/hid/wacom_wac.c b/drivers/hid/wacom_wac.c</span>
<span class="p_header">index bb17d7bbefd3..aa692e28b2cd 100644</span>
<span class="p_header">--- a/drivers/hid/wacom_wac.c</span>
<span class="p_header">+++ b/drivers/hid/wacom_wac.c</span>
<span class="p_chunk">@@ -567,8 +567,8 @@</span> <span class="p_context"> static int wacom_intuos_pad(struct wacom_wac *wacom)</span>
 				keys = data[9] &amp; 0x07;
 			}
 		} else {
<span class="p_del">-			buttons = ((data[6] &amp; 0x10) &lt;&lt; 10) |</span>
<span class="p_del">-			          ((data[5] &amp; 0x10) &lt;&lt; 9)  |</span>
<span class="p_add">+			buttons = ((data[6] &amp; 0x10) &lt;&lt; 5)  |</span>
<span class="p_add">+			          ((data[5] &amp; 0x10) &lt;&lt; 4)  |</span>
 			          ((data[6] &amp; 0x0F) &lt;&lt; 4)  |
 			          (data[5] &amp; 0x0F);
 		}
<span class="p_chunk">@@ -1227,11 +1227,17 @@</span> <span class="p_context"> static void wacom_intuos_pro2_bt_pen(struct wacom_wac *wacom)</span>
 			continue;
 
 		if (range) {
<span class="p_add">+			/* Fix rotation alignment: userspace expects zero at left */</span>
<span class="p_add">+			int16_t rotation = (int16_t)get_unaligned_le16(&amp;frame[9]);</span>
<span class="p_add">+			rotation += 1800/4;</span>
<span class="p_add">+			if (rotation &gt; 899)</span>
<span class="p_add">+				rotation -= 1800;</span>
<span class="p_add">+</span>
 			input_report_abs(pen_input, ABS_X, get_unaligned_le16(&amp;frame[1]));
 			input_report_abs(pen_input, ABS_Y, get_unaligned_le16(&amp;frame[3]));
<span class="p_del">-			input_report_abs(pen_input, ABS_TILT_X, frame[7]);</span>
<span class="p_del">-			input_report_abs(pen_input, ABS_TILT_Y, frame[8]);</span>
<span class="p_del">-			input_report_abs(pen_input, ABS_Z, get_unaligned_le16(&amp;frame[9]));</span>
<span class="p_add">+			input_report_abs(pen_input, ABS_TILT_X, (char)frame[7]);</span>
<span class="p_add">+			input_report_abs(pen_input, ABS_TILT_Y, (char)frame[8]);</span>
<span class="p_add">+			input_report_abs(pen_input, ABS_Z, rotation);</span>
 			input_report_abs(pen_input, ABS_WHEEL, get_unaligned_le16(&amp;frame[11]));
 		}
 		input_report_abs(pen_input, ABS_PRESSURE, get_unaligned_le16(&amp;frame[5]));
<span class="p_chunk">@@ -1319,12 +1325,19 @@</span> <span class="p_context"> static void wacom_intuos_pro2_bt_pad(struct wacom_wac *wacom)</span>
 	unsigned char *data = wacom-&gt;data;
 
 	int buttons = (data[282] &lt;&lt; 1) | ((data[281] &gt;&gt; 6) &amp; 0x01);
<span class="p_del">-	int ring = data[285];</span>
<span class="p_del">-	int prox = buttons | (ring &amp; 0x80);</span>
<span class="p_add">+	int ring = data[285] &amp; 0x7F;</span>
<span class="p_add">+	bool ringstatus = data[285] &amp; 0x80;</span>
<span class="p_add">+	bool prox = buttons || ringstatus;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Fix touchring data: userspace expects 0 at left and increasing clockwise */</span>
<span class="p_add">+	ring = 71 - ring;</span>
<span class="p_add">+	ring += 3*72/16;</span>
<span class="p_add">+	if (ring &gt; 71)</span>
<span class="p_add">+		ring -= 72;</span>
 
 	wacom_report_numbered_buttons(pad_input, 9, buttons);
 
<span class="p_del">-	input_report_abs(pad_input, ABS_WHEEL, (ring &amp; 0x80) ? (ring &amp; 0x7f) : 0);</span>
<span class="p_add">+	input_report_abs(pad_input, ABS_WHEEL, ringstatus ? ring : 0);</span>
 
 	input_report_key(pad_input, wacom-&gt;tool[1], prox ? 1 : 0);
 	input_report_abs(pad_input, ABS_MISC, prox ? PAD_DEVICE_ID : 0);
<span class="p_chunk">@@ -1616,6 +1629,20 @@</span> <span class="p_context"> static int wacom_tpc_irq(struct wacom_wac *wacom, size_t len)</span>
 	return 0;
 }
 
<span class="p_add">+static int wacom_offset_rotation(struct input_dev *input, struct hid_usage *usage,</span>
<span class="p_add">+				 int value, int num, int denom)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct input_absinfo *abs = &amp;input-&gt;absinfo[usage-&gt;code];</span>
<span class="p_add">+	int range = (abs-&gt;maximum - abs-&gt;minimum + 1);</span>
<span class="p_add">+</span>
<span class="p_add">+	value += num*range/denom;</span>
<span class="p_add">+	if (value &gt; abs-&gt;maximum)</span>
<span class="p_add">+		value -= range;</span>
<span class="p_add">+	else if (value &lt; abs-&gt;minimum)</span>
<span class="p_add">+		value += range;</span>
<span class="p_add">+	return value;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int wacom_equivalent_usage(int usage)
 {
 	if ((usage &amp; HID_USAGE_PAGE) == WACOM_HID_UP_WACOMDIGITIZER) {
<span class="p_chunk">@@ -1898,6 +1925,7 @@</span> <span class="p_context"> static void wacom_wac_pad_event(struct hid_device *hdev, struct hid_field *field</span>
 	unsigned equivalent_usage = wacom_equivalent_usage(usage-&gt;hid);
 	int i;
 	bool is_touch_on = value;
<span class="p_add">+	bool do_report = false;</span>
 
 	/*
 	 * Avoid reporting this event and setting inrange_state if this usage
<span class="p_chunk">@@ -1912,6 +1940,29 @@</span> <span class="p_context"> static void wacom_wac_pad_event(struct hid_device *hdev, struct hid_field *field</span>
 	}
 
 	switch (equivalent_usage) {
<span class="p_add">+	case WACOM_HID_WD_TOUCHRING:</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Userspace expects touchrings to increase in value with</span>
<span class="p_add">+		 * clockwise gestures and have their zero point at the</span>
<span class="p_add">+		 * tablet&#39;s left. HID events &quot;should&quot; be clockwise-</span>
<span class="p_add">+		 * increasing and zero at top, though the MobileStudio</span>
<span class="p_add">+		 * Pro and 2nd-gen Intuos Pro don&#39;t do this...</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (hdev-&gt;vendor == 0x56a &amp;&amp;</span>
<span class="p_add">+		    (hdev-&gt;product == 0x34d || hdev-&gt;product == 0x34e ||  /* MobileStudio Pro */</span>
<span class="p_add">+		     hdev-&gt;product == 0x357 || hdev-&gt;product == 0x358)) { /* Intuos Pro 2 */</span>
<span class="p_add">+			value = (field-&gt;logical_maximum - value);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (hdev-&gt;product == 0x357 || hdev-&gt;product == 0x358)</span>
<span class="p_add">+				value = wacom_offset_rotation(input, usage, value, 3, 16);</span>
<span class="p_add">+			else if (hdev-&gt;product == 0x34d || hdev-&gt;product == 0x34e)</span>
<span class="p_add">+				value = wacom_offset_rotation(input, usage, value, 1, 2);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		else {</span>
<span class="p_add">+			value = wacom_offset_rotation(input, usage, value, 1, 4);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		do_report = true;</span>
<span class="p_add">+		break;</span>
 	case WACOM_HID_WD_TOUCHRINGSTATUS:
 		if (!value)
 			input_event(input, usage-&gt;type, usage-&gt;code, 0);
<span class="p_chunk">@@ -1945,10 +1996,14 @@</span> <span class="p_context"> static void wacom_wac_pad_event(struct hid_device *hdev, struct hid_field *field</span>
 					 value, i);
 		 /* fall through*/
 	default:
<span class="p_add">+		do_report = true;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (do_report) {</span>
 		input_event(input, usage-&gt;type, usage-&gt;code, value);
 		if (value)
 			wacom_wac-&gt;hid_data.pad_input_event_flag = true;
<span class="p_del">-		break;</span>
 	}
 }
 
<span class="p_chunk">@@ -2086,22 +2141,34 @@</span> <span class="p_context"> static void wacom_wac_pen_event(struct hid_device *hdev, struct hid_field *field</span>
 		wacom_wac-&gt;hid_data.tipswitch |= value;
 		return;
 	case HID_DG_TOOLSERIALNUMBER:
<span class="p_del">-		wacom_wac-&gt;serial[0] = (wacom_wac-&gt;serial[0] &amp; ~0xFFFFFFFFULL);</span>
<span class="p_del">-		wacom_wac-&gt;serial[0] |= (__u32)value;</span>
<span class="p_add">+		if (value) {</span>
<span class="p_add">+			wacom_wac-&gt;serial[0] = (wacom_wac-&gt;serial[0] &amp; ~0xFFFFFFFFULL);</span>
<span class="p_add">+			wacom_wac-&gt;serial[0] |= (__u32)value;</span>
<span class="p_add">+		}</span>
 		return;
<span class="p_add">+	case HID_DG_TWIST:</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Userspace expects pen twist to have its zero point when</span>
<span class="p_add">+		 * the buttons/finger is on the tablet&#39;s left. HID values</span>
<span class="p_add">+		 * are zero when buttons are toward the top.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		value = wacom_offset_rotation(input, usage, value, 1, 4);</span>
<span class="p_add">+		break;</span>
 	case WACOM_HID_WD_SENSE:
 		wacom_wac-&gt;hid_data.sense_state = value;
 		return;
 	case WACOM_HID_WD_SERIALHI:
<span class="p_del">-		wacom_wac-&gt;serial[0] = (wacom_wac-&gt;serial[0] &amp; 0xFFFFFFFF);</span>
<span class="p_del">-		wacom_wac-&gt;serial[0] |= ((__u64)value) &lt;&lt; 32;</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Non-USI EMR devices may contain additional tool type</span>
<span class="p_del">-		 * information here. See WACOM_HID_WD_TOOLTYPE case for</span>
<span class="p_del">-		 * more details.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (value &gt;&gt; 20 == 1) {</span>
<span class="p_del">-			wacom_wac-&gt;id[0] |= value &amp; 0xFFFFF;</span>
<span class="p_add">+		if (value) {</span>
<span class="p_add">+			wacom_wac-&gt;serial[0] = (wacom_wac-&gt;serial[0] &amp; 0xFFFFFFFF);</span>
<span class="p_add">+			wacom_wac-&gt;serial[0] |= ((__u64)value) &lt;&lt; 32;</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Non-USI EMR devices may contain additional tool type</span>
<span class="p_add">+			 * information here. See WACOM_HID_WD_TOOLTYPE case for</span>
<span class="p_add">+			 * more details.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (value &gt;&gt; 20 == 1) {</span>
<span class="p_add">+				wacom_wac-&gt;id[0] |= value &amp; 0xFFFFF;</span>
<span class="p_add">+			}</span>
 		}
 		return;
 	case WACOM_HID_WD_TOOLTYPE:
<span class="p_chunk">@@ -2205,7 +2272,7 @@</span> <span class="p_context"> static void wacom_wac_pen_report(struct hid_device *hdev,</span>
 		input_report_key(input, wacom_wac-&gt;tool[0], prox);
 		if (wacom_wac-&gt;serial[0]) {
 			input_event(input, EV_MSC, MSC_SERIAL, wacom_wac-&gt;serial[0]);
<span class="p_del">-			input_report_abs(input, ABS_MISC, id);</span>
<span class="p_add">+			input_report_abs(input, ABS_MISC, prox ? id : 0);</span>
 		}
 
 		wacom_wac-&gt;hid_data.tipswitch = false;
<span class="p_chunk">@@ -2216,6 +2283,7 @@</span> <span class="p_context"> static void wacom_wac_pen_report(struct hid_device *hdev,</span>
 	if (!prox) {
 		wacom_wac-&gt;tool[0] = 0;
 		wacom_wac-&gt;id[0] = 0;
<span class="p_add">+		wacom_wac-&gt;serial[0] = 0;</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/hv/channel_mgmt.c b/drivers/hv/channel_mgmt.c</span>
<span class="p_header">index 4bbb8dea4727..037361158074 100644</span>
<span class="p_header">--- a/drivers/hv/channel_mgmt.c</span>
<span class="p_header">+++ b/drivers/hv/channel_mgmt.c</span>
<span class="p_chunk">@@ -922,14 +922,10 @@</span> <span class="p_context"> static void vmbus_onoffer_rescind(struct vmbus_channel_message_header *hdr)</span>
 
 void vmbus_hvsock_device_unregister(struct vmbus_channel *channel)
 {
<span class="p_del">-	mutex_lock(&amp;vmbus_connection.channel_mutex);</span>
<span class="p_del">-</span>
 	BUG_ON(!is_hvsock_channel(channel));
 
 	channel-&gt;rescind = true;
 	vmbus_device_unregister(channel-&gt;device_obj);
<span class="p_del">-</span>
<span class="p_del">-	mutex_unlock(&amp;vmbus_connection.channel_mutex);</span>
 }
 EXPORT_SYMBOL_GPL(vmbus_hvsock_device_unregister);
 
<span class="p_header">diff --git a/drivers/hv/hv_fcopy.c b/drivers/hv/hv_fcopy.c</span>
<span class="p_header">index daa75bd41f86..2364281d8593 100644</span>
<span class="p_header">--- a/drivers/hv/hv_fcopy.c</span>
<span class="p_header">+++ b/drivers/hv/hv_fcopy.c</span>
<span class="p_chunk">@@ -170,6 +170,10 @@</span> <span class="p_context"> static void fcopy_send_data(struct work_struct *dummy)</span>
 		out_src = smsg_out;
 		break;
 
<span class="p_add">+	case WRITE_TO_FILE:</span>
<span class="p_add">+		out_src = fcopy_transaction.fcopy_msg;</span>
<span class="p_add">+		out_len = sizeof(struct hv_do_fcopy);</span>
<span class="p_add">+		break;</span>
 	default:
 		out_src = fcopy_transaction.fcopy_msg;
 		out_len = fcopy_transaction.recv_len;
<span class="p_header">diff --git a/drivers/hwtracing/intel_th/pci.c b/drivers/hwtracing/intel_th/pci.c</span>
<span class="p_header">index da40df2ff27d..ed6262be3643 100644</span>
<span class="p_header">--- a/drivers/hwtracing/intel_th/pci.c</span>
<span class="p_header">+++ b/drivers/hwtracing/intel_th/pci.c</span>
<span class="p_chunk">@@ -90,6 +90,11 @@</span> <span class="p_context"> static const struct pci_device_id intel_th_pci_id_table[] = {</span>
 		PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x19e1),
 		.driver_data = (kernel_ulong_t)0,
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		/* Lewisburg PCH */</span>
<span class="p_add">+		PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0xa1a6),</span>
<span class="p_add">+		.driver_data = (kernel_ulong_t)0,</span>
<span class="p_add">+	},</span>
 	{
 		/* Gemini Lake */
 		PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x318e),
<span class="p_header">diff --git a/drivers/hwtracing/stm/core.c b/drivers/hwtracing/stm/core.c</span>
<span class="p_header">index 0e731143f6a4..08b8305fee44 100644</span>
<span class="p_header">--- a/drivers/hwtracing/stm/core.c</span>
<span class="p_header">+++ b/drivers/hwtracing/stm/core.c</span>
<span class="p_chunk">@@ -1119,7 +1119,7 @@</span> <span class="p_context"> void stm_source_unregister_device(struct stm_source_data *data)</span>
 
 	stm_source_link_drop(src);
 
<span class="p_del">-	device_destroy(&amp;stm_source_class, src-&gt;dev.devt);</span>
<span class="p_add">+	device_unregister(&amp;src-&gt;dev);</span>
 }
 EXPORT_SYMBOL_GPL(stm_source_unregister_device);
 
<span class="p_header">diff --git a/drivers/iio/adc/ad7793.c b/drivers/iio/adc/ad7793.c</span>
<span class="p_header">index e6706a09e100..47c3d7f32900 100644</span>
<span class="p_header">--- a/drivers/iio/adc/ad7793.c</span>
<span class="p_header">+++ b/drivers/iio/adc/ad7793.c</span>
<span class="p_chunk">@@ -257,7 +257,7 @@</span> <span class="p_context"> static int ad7793_setup(struct iio_dev *indio_dev,</span>
 	unsigned int vref_mv)
 {
 	struct ad7793_state *st = iio_priv(indio_dev);
<span class="p_del">-	int i, ret = -1;</span>
<span class="p_add">+	int i, ret;</span>
 	unsigned long long scale_uv;
 	u32 id;
 
<span class="p_chunk">@@ -266,7 +266,7 @@</span> <span class="p_context"> static int ad7793_setup(struct iio_dev *indio_dev,</span>
 		return ret;
 
 	/* reset the serial interface */
<span class="p_del">-	ret = spi_write(st-&gt;sd.spi, (u8 *)&amp;ret, sizeof(ret));</span>
<span class="p_add">+	ret = ad_sd_reset(&amp;st-&gt;sd, 32);</span>
 	if (ret &lt; 0)
 		goto out;
 	usleep_range(500, 2000); /* Wait for at least 500us */
<span class="p_header">diff --git a/drivers/iio/adc/ad_sigma_delta.c b/drivers/iio/adc/ad_sigma_delta.c</span>
<span class="p_header">index d10bd0c97233..22c4c17cd996 100644</span>
<span class="p_header">--- a/drivers/iio/adc/ad_sigma_delta.c</span>
<span class="p_header">+++ b/drivers/iio/adc/ad_sigma_delta.c</span>
<span class="p_chunk">@@ -177,6 +177,34 @@</span> <span class="p_context"> int ad_sd_read_reg(struct ad_sigma_delta *sigma_delta,</span>
 }
 EXPORT_SYMBOL_GPL(ad_sd_read_reg);
 
<span class="p_add">+/**</span>
<span class="p_add">+ * ad_sd_reset() - Reset the serial interface</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @sigma_delta: The sigma delta device</span>
<span class="p_add">+ * @reset_length: Number of SCLKs with DIN = 1</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns 0 on success, an error code otherwise.</span>
<span class="p_add">+ **/</span>
<span class="p_add">+int ad_sd_reset(struct ad_sigma_delta *sigma_delta,</span>
<span class="p_add">+	unsigned int reset_length)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint8_t *buf;</span>
<span class="p_add">+	unsigned int size;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	size = DIV_ROUND_UP(reset_length, 8);</span>
<span class="p_add">+	buf = kcalloc(size, sizeof(*buf), GFP_KERNEL);</span>
<span class="p_add">+	if (!buf)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(buf, 0xff, size);</span>
<span class="p_add">+	ret = spi_write(sigma_delta-&gt;spi, buf, size);</span>
<span class="p_add">+	kfree(buf);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(ad_sd_reset);</span>
<span class="p_add">+</span>
 static int ad_sd_calibrate(struct ad_sigma_delta *sigma_delta,
 	unsigned int mode, unsigned int channel)
 {
<span class="p_header">diff --git a/drivers/iio/adc/mcp320x.c b/drivers/iio/adc/mcp320x.c</span>
<span class="p_header">index 634717ae12f3..071dd23a33d9 100644</span>
<span class="p_header">--- a/drivers/iio/adc/mcp320x.c</span>
<span class="p_header">+++ b/drivers/iio/adc/mcp320x.c</span>
<span class="p_chunk">@@ -17,6 +17,8 @@</span> <span class="p_context"></span>
  * MCP3204
  * MCP3208
  * ------------
<span class="p_add">+ * 13 bit converter</span>
<span class="p_add">+ * MCP3301</span>
  *
  * Datasheet can be found here:
  * http://ww1.microchip.com/downloads/en/DeviceDoc/21293C.pdf  mcp3001
<span class="p_chunk">@@ -96,7 +98,7 @@</span> <span class="p_context"> static int mcp320x_channel_to_tx_data(int device_index,</span>
 }
 
 static int mcp320x_adc_conversion(struct mcp320x *adc, u8 channel,
<span class="p_del">-				  bool differential, int device_index)</span>
<span class="p_add">+				  bool differential, int device_index, int *val)</span>
 {
 	int ret;
 
<span class="p_chunk">@@ -117,19 +119,25 @@</span> <span class="p_context"> static int mcp320x_adc_conversion(struct mcp320x *adc, u8 channel,</span>
 
 	switch (device_index) {
 	case mcp3001:
<span class="p_del">-		return (adc-&gt;rx_buf[0] &lt;&lt; 5 | adc-&gt;rx_buf[1] &gt;&gt; 3);</span>
<span class="p_add">+		*val = (adc-&gt;rx_buf[0] &lt;&lt; 5 | adc-&gt;rx_buf[1] &gt;&gt; 3);</span>
<span class="p_add">+		return 0;</span>
 	case mcp3002:
 	case mcp3004:
 	case mcp3008:
<span class="p_del">-		return (adc-&gt;rx_buf[0] &lt;&lt; 2 | adc-&gt;rx_buf[1] &gt;&gt; 6);</span>
<span class="p_add">+		*val = (adc-&gt;rx_buf[0] &lt;&lt; 2 | adc-&gt;rx_buf[1] &gt;&gt; 6);</span>
<span class="p_add">+		return 0;</span>
 	case mcp3201:
<span class="p_del">-		return (adc-&gt;rx_buf[0] &lt;&lt; 7 | adc-&gt;rx_buf[1] &gt;&gt; 1);</span>
<span class="p_add">+		*val = (adc-&gt;rx_buf[0] &lt;&lt; 7 | adc-&gt;rx_buf[1] &gt;&gt; 1);</span>
<span class="p_add">+		return 0;</span>
 	case mcp3202:
 	case mcp3204:
 	case mcp3208:
<span class="p_del">-		return (adc-&gt;rx_buf[0] &lt;&lt; 4 | adc-&gt;rx_buf[1] &gt;&gt; 4);</span>
<span class="p_add">+		*val = (adc-&gt;rx_buf[0] &lt;&lt; 4 | adc-&gt;rx_buf[1] &gt;&gt; 4);</span>
<span class="p_add">+		return 0;</span>
 	case mcp3301:
<span class="p_del">-		return sign_extend32((adc-&gt;rx_buf[0] &amp; 0x1f) &lt;&lt; 8 | adc-&gt;rx_buf[1], 12);</span>
<span class="p_add">+		*val = sign_extend32((adc-&gt;rx_buf[0] &amp; 0x1f) &lt;&lt; 8</span>
<span class="p_add">+				    | adc-&gt;rx_buf[1], 12);</span>
<span class="p_add">+		return 0;</span>
 	default:
 		return -EINVAL;
 	}
<span class="p_chunk">@@ -150,12 +158,10 @@</span> <span class="p_context"> static int mcp320x_read_raw(struct iio_dev *indio_dev,</span>
 	switch (mask) {
 	case IIO_CHAN_INFO_RAW:
 		ret = mcp320x_adc_conversion(adc, channel-&gt;address,
<span class="p_del">-			channel-&gt;differential, device_index);</span>
<span class="p_del">-</span>
<span class="p_add">+			channel-&gt;differential, device_index, val);</span>
 		if (ret &lt; 0)
 			goto out;
 
<span class="p_del">-		*val = ret;</span>
 		ret = IIO_VAL_INT;
 		break;
 
<span class="p_chunk">@@ -312,6 +318,7 @@</span> <span class="p_context"> static int mcp320x_probe(struct spi_device *spi)</span>
 	indio_dev-&gt;name = spi_get_device_id(spi)-&gt;name;
 	indio_dev-&gt;modes = INDIO_DIRECT_MODE;
 	indio_dev-&gt;info = &amp;mcp320x_info;
<span class="p_add">+	spi_set_drvdata(spi, indio_dev);</span>
 
 	chip_info = &amp;mcp320x_chip_infos[spi_get_device_id(spi)-&gt;driver_data];
 	indio_dev-&gt;channels = chip_info-&gt;channels;
<span class="p_header">diff --git a/drivers/iio/adc/stm32-adc.c b/drivers/iio/adc/stm32-adc.c</span>
<span class="p_header">index 5bfcc1f13105..10e1d8328461 100644</span>
<span class="p_header">--- a/drivers/iio/adc/stm32-adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/stm32-adc.c</span>
<span class="p_chunk">@@ -1543,7 +1543,7 @@</span> <span class="p_context"> static int stm32_adc_chan_of_init(struct iio_dev *indio_dev)</span>
 
 	num_channels = of_property_count_u32_elems(node, &quot;st,adc-channels&quot;);
 	if (num_channels &lt; 0 ||
<span class="p_del">-	    num_channels &gt;= adc_info-&gt;max_channels) {</span>
<span class="p_add">+	    num_channels &gt; adc_info-&gt;max_channels) {</span>
 		dev_err(&amp;indio_dev-&gt;dev, &quot;Bad st,adc-channels?\n&quot;);
 		return num_channels &lt; 0 ? num_channels : -EINVAL;
 	}
<span class="p_header">diff --git a/drivers/iio/adc/twl4030-madc.c b/drivers/iio/adc/twl4030-madc.c</span>
<span class="p_header">index bd3d37fc2144..0c86fbb3033e 100644</span>
<span class="p_header">--- a/drivers/iio/adc/twl4030-madc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/twl4030-madc.c</span>
<span class="p_chunk">@@ -887,8 +887,10 @@</span> <span class="p_context"> static int twl4030_madc_probe(struct platform_device *pdev)</span>
 
 	/* Enable 3v1 bias regulator for MADC[3:6] */
 	madc-&gt;usb3v1 = devm_regulator_get(madc-&gt;dev, &quot;vusb3v1&quot;);
<span class="p_del">-	if (IS_ERR(madc-&gt;usb3v1))</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+	if (IS_ERR(madc-&gt;usb3v1)) {</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto err_i2c;</span>
<span class="p_add">+	}</span>
 
 	ret = regulator_enable(madc-&gt;usb3v1);
 	if (ret)
<span class="p_chunk">@@ -897,11 +899,13 @@</span> <span class="p_context"> static int twl4030_madc_probe(struct platform_device *pdev)</span>
 	ret = iio_device_register(iio_dev);
 	if (ret) {
 		dev_err(&amp;pdev-&gt;dev, &quot;could not register iio device\n&quot;);
<span class="p_del">-		goto err_i2c;</span>
<span class="p_add">+		goto err_usb3v1;</span>
 	}
 
 	return 0;
 
<span class="p_add">+err_usb3v1:</span>
<span class="p_add">+	regulator_disable(madc-&gt;usb3v1);</span>
 err_i2c:
 	twl4030_madc_set_current_generator(madc, 0, 0);
 err_current_generator:
<span class="p_header">diff --git a/drivers/iio/industrialio-core.c b/drivers/iio/industrialio-core.c</span>
<span class="p_header">index 17ec4cee51dc..a47428b4d31b 100644</span>
<span class="p_header">--- a/drivers/iio/industrialio-core.c</span>
<span class="p_header">+++ b/drivers/iio/industrialio-core.c</span>
<span class="p_chunk">@@ -310,8 +310,10 @@</span> <span class="p_context"> static ssize_t iio_debugfs_read_reg(struct file *file, char __user *userbuf,</span>
 	ret = indio_dev-&gt;info-&gt;debugfs_reg_access(indio_dev,
 						  indio_dev-&gt;cached_reg_addr,
 						  0, &amp;val);
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret) {</span>
 		dev_err(indio_dev-&gt;dev.parent, &quot;%s: read failed\n&quot;, __func__);
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
 
 	len = snprintf(buf, sizeof(buf), &quot;0x%X\n&quot;, val);
 
<span class="p_header">diff --git a/drivers/iio/pressure/bmp280-core.c b/drivers/iio/pressure/bmp280-core.c</span>
<span class="p_header">index 0d2ea3ee371b..8f26428804a2 100644</span>
<span class="p_header">--- a/drivers/iio/pressure/bmp280-core.c</span>
<span class="p_header">+++ b/drivers/iio/pressure/bmp280-core.c</span>
<span class="p_chunk">@@ -573,7 +573,7 @@</span> <span class="p_context"> static int bmp280_chip_config(struct bmp280_data *data)</span>
 	u8 osrs = BMP280_OSRS_TEMP_X(data-&gt;oversampling_temp + 1) |
 		  BMP280_OSRS_PRESS_X(data-&gt;oversampling_press + 1);
 
<span class="p_del">-	ret = regmap_update_bits(data-&gt;regmap, BMP280_REG_CTRL_MEAS,</span>
<span class="p_add">+	ret = regmap_write_bits(data-&gt;regmap, BMP280_REG_CTRL_MEAS,</span>
 				 BMP280_OSRS_TEMP_MASK |
 				 BMP280_OSRS_PRESS_MASK |
 				 BMP280_MODE_MASK,
<span class="p_header">diff --git a/drivers/iio/trigger/stm32-timer-trigger.c b/drivers/iio/trigger/stm32-timer-trigger.c</span>
<span class="p_header">index 25ad6abfee22..ea128bd82a28 100644</span>
<span class="p_header">--- a/drivers/iio/trigger/stm32-timer-trigger.c</span>
<span class="p_header">+++ b/drivers/iio/trigger/stm32-timer-trigger.c</span>
<span class="p_chunk">@@ -138,6 +138,7 @@</span> <span class="p_context"> static void stm32_timer_stop(struct stm32_timer_trigger *priv)</span>
 		clk_disable(priv-&gt;clk);
 
 	/* Stop timer */
<span class="p_add">+	regmap_update_bits(priv-&gt;regmap, TIM_CR1, TIM_CR1_ARPE, 0);</span>
 	regmap_update_bits(priv-&gt;regmap, TIM_CR1, TIM_CR1_CEN, 0);
 	regmap_write(priv-&gt;regmap, TIM_PSC, 0);
 	regmap_write(priv-&gt;regmap, TIM_ARR, 0);
<span class="p_chunk">@@ -679,8 +680,9 @@</span> <span class="p_context"> static ssize_t stm32_count_set_preset(struct iio_dev *indio_dev,</span>
 	if (ret)
 		return ret;
 
<span class="p_add">+	/* TIMx_ARR register shouldn&#39;t be buffered (ARPE=0) */</span>
<span class="p_add">+	regmap_update_bits(priv-&gt;regmap, TIM_CR1, TIM_CR1_ARPE, 0);</span>
 	regmap_write(priv-&gt;regmap, TIM_ARR, preset);
<span class="p_del">-	regmap_update_bits(priv-&gt;regmap, TIM_CR1, TIM_CR1_ARPE, TIM_CR1_ARPE);</span>
 
 	return len;
 }
<span class="p_header">diff --git a/drivers/isdn/i4l/isdn_ppp.c b/drivers/isdn/i4l/isdn_ppp.c</span>
<span class="p_header">index 6c44609fd83a..cd2b3c69771a 100644</span>
<span class="p_header">--- a/drivers/isdn/i4l/isdn_ppp.c</span>
<span class="p_header">+++ b/drivers/isdn/i4l/isdn_ppp.c</span>
<span class="p_chunk">@@ -825,7 +825,6 @@</span> <span class="p_context"> isdn_ppp_write(int min, struct file *file, const char __user *buf, int count)</span>
 	isdn_net_local *lp;
 	struct ippp_struct *is;
 	int proto;
<span class="p_del">-	unsigned char protobuf[4];</span>
 
 	is = file-&gt;private_data;
 
<span class="p_chunk">@@ -839,24 +838,28 @@</span> <span class="p_context"> isdn_ppp_write(int min, struct file *file, const char __user *buf, int count)</span>
 	if (!lp)
 		printk(KERN_DEBUG &quot;isdn_ppp_write: lp == NULL\n&quot;);
 	else {
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Don&#39;t reset huptimer for</span>
<span class="p_del">-		 * LCP packets. (Echo requests).</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (copy_from_user(protobuf, buf, 4))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-		proto = PPP_PROTOCOL(protobuf);</span>
<span class="p_del">-		if (proto != PPP_LCP)</span>
<span class="p_del">-			lp-&gt;huptimer = 0;</span>
<span class="p_add">+		if (lp-&gt;isdn_device &lt; 0 || lp-&gt;isdn_channel &lt; 0) {</span>
<span class="p_add">+			unsigned char protobuf[4];</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Don&#39;t reset huptimer for</span>
<span class="p_add">+			 * LCP packets. (Echo requests).</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (copy_from_user(protobuf, buf, 4))</span>
<span class="p_add">+				return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+			proto = PPP_PROTOCOL(protobuf);</span>
<span class="p_add">+			if (proto != PPP_LCP)</span>
<span class="p_add">+				lp-&gt;huptimer = 0;</span>
 
<span class="p_del">-		if (lp-&gt;isdn_device &lt; 0 || lp-&gt;isdn_channel &lt; 0)</span>
 			return 0;
<span class="p_add">+		}</span>
 
 		if ((dev-&gt;drv[lp-&gt;isdn_device]-&gt;flags &amp; DRV_FLAG_RUNNING) &amp;&amp;
 		    lp-&gt;dialstate == 0 &amp;&amp;
 		    (lp-&gt;flags &amp; ISDN_NET_CONNECTED)) {
 			unsigned short hl;
 			struct sk_buff *skb;
<span class="p_add">+			unsigned char *cpy_buf;</span>
 			/*
 			 * we need to reserve enough space in front of
 			 * sk_buff. old call to dev_alloc_skb only reserved
<span class="p_chunk">@@ -869,11 +872,21 @@</span> <span class="p_context"> isdn_ppp_write(int min, struct file *file, const char __user *buf, int count)</span>
 				return count;
 			}
 			skb_reserve(skb, hl);
<span class="p_del">-			if (copy_from_user(skb_put(skb, count), buf, count))</span>
<span class="p_add">+			cpy_buf = skb_put(skb, count);</span>
<span class="p_add">+			if (copy_from_user(cpy_buf, buf, count))</span>
 			{
 				kfree_skb(skb);
 				return -EFAULT;
 			}
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Don&#39;t reset huptimer for</span>
<span class="p_add">+			 * LCP packets. (Echo requests).</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			proto = PPP_PROTOCOL(cpy_buf);</span>
<span class="p_add">+			if (proto != PPP_LCP)</span>
<span class="p_add">+				lp-&gt;huptimer = 0;</span>
<span class="p_add">+</span>
 			if (is-&gt;debug &amp; 0x40) {
 				printk(KERN_DEBUG &quot;ppp xmit: len %d\n&quot;, (int) skb-&gt;len);
 				isdn_ppp_frame_log(&quot;xmit&quot;, skb-&gt;data, skb-&gt;len, 32, is-&gt;unit, lp-&gt;ppp_slot);
<span class="p_header">diff --git a/drivers/md/dm-core.h b/drivers/md/dm-core.h</span>
<span class="p_header">index 24eddbdf2ab4..203144762f36 100644</span>
<span class="p_header">--- a/drivers/md/dm-core.h</span>
<span class="p_header">+++ b/drivers/md/dm-core.h</span>
<span class="p_chunk">@@ -149,5 +149,6 @@</span> <span class="p_context"> static inline bool dm_message_test_buffer_overflow(char *result, unsigned maxlen</span>
 
 extern atomic_t dm_global_event_nr;
 extern wait_queue_head_t dm_global_eventq;
<span class="p_add">+void dm_issue_global_event(void);</span>
 
 #endif
<span class="p_header">diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c</span>
<span class="p_header">index cdf6b1e12460..e3dd64a12f55 100644</span>
<span class="p_header">--- a/drivers/md/dm-crypt.c</span>
<span class="p_header">+++ b/drivers/md/dm-crypt.c</span>
<span class="p_chunk">@@ -2470,6 +2470,7 @@</span> <span class="p_context"> static int crypt_ctr_cipher_old(struct dm_target *ti, char *cipher_in, char *key</span>
 		kfree(cipher_api);
 		return ret;
 	}
<span class="p_add">+	kfree(cipher_api);</span>
 
 	return 0;
 bad_mem:
<span class="p_chunk">@@ -2588,6 +2589,10 @@</span> <span class="p_context"> static int crypt_ctr_optional(struct dm_target *ti, unsigned int argc, char **ar</span>
 				ti-&gt;error = &quot;Invalid feature value for sector_size&quot;;
 				return -EINVAL;
 			}
<span class="p_add">+			if (ti-&gt;len &amp; ((cc-&gt;sector_size &gt;&gt; SECTOR_SHIFT) - 1)) {</span>
<span class="p_add">+				ti-&gt;error = &quot;Device size is not multiple of sector_size feature&quot;;</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
 			cc-&gt;sector_shift = __ffs(cc-&gt;sector_size) - SECTOR_SHIFT;
 		} else if (!strcasecmp(opt_string, &quot;iv_large_sectors&quot;))
 			set_bit(CRYPT_IV_LARGE_SECTORS, &amp;cc-&gt;cipher_flags);
<span class="p_header">diff --git a/drivers/md/dm-ioctl.c b/drivers/md/dm-ioctl.c</span>
<span class="p_header">index e06f0ef7d2ec..e9f9884b66a8 100644</span>
<span class="p_header">--- a/drivers/md/dm-ioctl.c</span>
<span class="p_header">+++ b/drivers/md/dm-ioctl.c</span>
<span class="p_chunk">@@ -477,9 +477,13 @@</span> <span class="p_context"> static int remove_all(struct file *filp, struct dm_ioctl *param, size_t param_si</span>
  * Round up the ptr to an 8-byte boundary.
  */
 #define ALIGN_MASK 7
<span class="p_add">+static inline size_t align_val(size_t val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (val + ALIGN_MASK) &amp; ~ALIGN_MASK;</span>
<span class="p_add">+}</span>
 static inline void *align_ptr(void *ptr)
 {
<span class="p_del">-	return (void *) (((size_t) (ptr + ALIGN_MASK)) &amp; ~ALIGN_MASK);</span>
<span class="p_add">+	return (void *)align_val((size_t)ptr);</span>
 }
 
 /*
<span class="p_chunk">@@ -505,7 +509,7 @@</span> <span class="p_context"> static int list_devices(struct file *filp, struct dm_ioctl *param, size_t param_</span>
 	struct hash_cell *hc;
 	size_t len, needed = 0;
 	struct gendisk *disk;
<span class="p_del">-	struct dm_name_list *nl, *old_nl = NULL;</span>
<span class="p_add">+	struct dm_name_list *orig_nl, *nl, *old_nl = NULL;</span>
 	uint32_t *event_nr;
 
 	down_write(&amp;_hash_lock);
<span class="p_chunk">@@ -516,17 +520,15 @@</span> <span class="p_context"> static int list_devices(struct file *filp, struct dm_ioctl *param, size_t param_</span>
 	 */
 	for (i = 0; i &lt; NUM_BUCKETS; i++) {
 		list_for_each_entry (hc, _name_buckets + i, name_list) {
<span class="p_del">-			needed += sizeof(struct dm_name_list);</span>
<span class="p_del">-			needed += strlen(hc-&gt;name) + 1;</span>
<span class="p_del">-			needed += ALIGN_MASK;</span>
<span class="p_del">-			needed += (sizeof(uint32_t) + ALIGN_MASK) &amp; ~ALIGN_MASK;</span>
<span class="p_add">+			needed += align_val(offsetof(struct dm_name_list, name) + strlen(hc-&gt;name) + 1);</span>
<span class="p_add">+			needed += align_val(sizeof(uint32_t));</span>
 		}
 	}
 
 	/*
 	 * Grab our output buffer.
 	 */
<span class="p_del">-	nl = get_result_buffer(param, param_size, &amp;len);</span>
<span class="p_add">+	nl = orig_nl = get_result_buffer(param, param_size, &amp;len);</span>
 	if (len &lt; needed) {
 		param-&gt;flags |= DM_BUFFER_FULL_FLAG;
 		goto out;
<span class="p_chunk">@@ -549,11 +551,16 @@</span> <span class="p_context"> static int list_devices(struct file *filp, struct dm_ioctl *param, size_t param_</span>
 			strcpy(nl-&gt;name, hc-&gt;name);
 
 			old_nl = nl;
<span class="p_del">-			event_nr = align_ptr(((void *) (nl + 1)) + strlen(hc-&gt;name) + 1);</span>
<span class="p_add">+			event_nr = align_ptr(nl-&gt;name + strlen(hc-&gt;name) + 1);</span>
 			*event_nr = dm_get_event_nr(hc-&gt;md);
 			nl = align_ptr(event_nr + 1);
 		}
 	}
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If mismatch happens, security may be compromised due to buffer</span>
<span class="p_add">+	 * overflow, so it&#39;s better to crash.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	BUG_ON((char *)nl - (char *)orig_nl != needed);</span>
 
  out:
 	up_write(&amp;_hash_lock);
<span class="p_chunk">@@ -1621,7 +1628,8 @@</span> <span class="p_context"> static int target_message(struct file *filp, struct dm_ioctl *param, size_t para</span>
  * which has a variable size, is not used by the function processing
  * the ioctl.
  */
<span class="p_del">-#define IOCTL_FLAGS_NO_PARAMS	1</span>
<span class="p_add">+#define IOCTL_FLAGS_NO_PARAMS		1</span>
<span class="p_add">+#define IOCTL_FLAGS_ISSUE_GLOBAL_EVENT	2</span>
 
 /*-----------------------------------------------------------------
  * Implementation of open/close/ioctl on the special char
<span class="p_chunk">@@ -1635,12 +1643,12 @@</span> <span class="p_context"> static ioctl_fn lookup_ioctl(unsigned int cmd, int *ioctl_flags)</span>
 		ioctl_fn fn;
 	} _ioctls[] = {
 		{DM_VERSION_CMD, 0, NULL}, /* version is dealt with elsewhere */
<span class="p_del">-		{DM_REMOVE_ALL_CMD, IOCTL_FLAGS_NO_PARAMS, remove_all},</span>
<span class="p_add">+		{DM_REMOVE_ALL_CMD, IOCTL_FLAGS_NO_PARAMS | IOCTL_FLAGS_ISSUE_GLOBAL_EVENT, remove_all},</span>
 		{DM_LIST_DEVICES_CMD, 0, list_devices},
 
<span class="p_del">-		{DM_DEV_CREATE_CMD, IOCTL_FLAGS_NO_PARAMS, dev_create},</span>
<span class="p_del">-		{DM_DEV_REMOVE_CMD, IOCTL_FLAGS_NO_PARAMS, dev_remove},</span>
<span class="p_del">-		{DM_DEV_RENAME_CMD, 0, dev_rename},</span>
<span class="p_add">+		{DM_DEV_CREATE_CMD, IOCTL_FLAGS_NO_PARAMS | IOCTL_FLAGS_ISSUE_GLOBAL_EVENT, dev_create},</span>
<span class="p_add">+		{DM_DEV_REMOVE_CMD, IOCTL_FLAGS_NO_PARAMS | IOCTL_FLAGS_ISSUE_GLOBAL_EVENT, dev_remove},</span>
<span class="p_add">+		{DM_DEV_RENAME_CMD, IOCTL_FLAGS_ISSUE_GLOBAL_EVENT, dev_rename},</span>
 		{DM_DEV_SUSPEND_CMD, IOCTL_FLAGS_NO_PARAMS, dev_suspend},
 		{DM_DEV_STATUS_CMD, IOCTL_FLAGS_NO_PARAMS, dev_status},
 		{DM_DEV_WAIT_CMD, 0, dev_wait},
<span class="p_chunk">@@ -1869,6 +1877,9 @@</span> <span class="p_context"> static int ctl_ioctl(struct file *file, uint command, struct dm_ioctl __user *us</span>
 	    unlikely(ioctl_flags &amp; IOCTL_FLAGS_NO_PARAMS))
 		DMERR(&quot;ioctl %d tried to output some data but has IOCTL_FLAGS_NO_PARAMS set&quot;, cmd);
 
<span class="p_add">+	if (!r &amp;&amp; ioctl_flags &amp; IOCTL_FLAGS_ISSUE_GLOBAL_EVENT)</span>
<span class="p_add">+		dm_issue_global_event();</span>
<span class="p_add">+</span>
 	/*
 	 * Copy the results back to userland.
 	 */
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index 825eaffc24da..eed539a4eec2 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -52,6 +52,12 @@</span> <span class="p_context"> static struct workqueue_struct *deferred_remove_workqueue;</span>
 atomic_t dm_global_event_nr = ATOMIC_INIT(0);
 DECLARE_WAIT_QUEUE_HEAD(dm_global_eventq);
 
<span class="p_add">+void dm_issue_global_event(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	atomic_inc(&amp;dm_global_event_nr);</span>
<span class="p_add">+	wake_up(&amp;dm_global_eventq);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * One of these is allocated per bio.
  */
<span class="p_chunk">@@ -1865,9 +1871,8 @@</span> <span class="p_context"> static void event_callback(void *context)</span>
 	dm_send_uevents(&amp;uevents, &amp;disk_to_dev(md-&gt;disk)-&gt;kobj);
 
 	atomic_inc(&amp;md-&gt;event_nr);
<span class="p_del">-	atomic_inc(&amp;dm_global_event_nr);</span>
 	wake_up(&amp;md-&gt;eventq);
<span class="p_del">-	wake_up(&amp;dm_global_eventq);</span>
<span class="p_add">+	dm_issue_global_event();</span>
 }
 
 /*
<span class="p_chunk">@@ -2283,6 +2288,7 @@</span> <span class="p_context"> struct dm_table *dm_swap_table(struct mapped_device *md, struct dm_table *table)</span>
 	}
 
 	map = __bind(md, table, &amp;limits);
<span class="p_add">+	dm_issue_global_event();</span>
 
 out:
 	mutex_unlock(&amp;md-&gt;suspend_lock);
<span class="p_header">diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c</span>
<span class="p_header">index 2bae69e39544..b64be0ba1222 100644</span>
<span class="p_header">--- a/drivers/mmc/core/mmc.c</span>
<span class="p_header">+++ b/drivers/mmc/core/mmc.c</span>
<span class="p_chunk">@@ -1286,6 +1286,23 @@</span> <span class="p_context"> int mmc_hs400_to_hs200(struct mmc_card *card)</span>
 	return err;
 }
 
<span class="p_add">+static void mmc_select_driver_type(struct mmc_card *card)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int card_drv_type, drive_strength, drv_type;</span>
<span class="p_add">+</span>
<span class="p_add">+	card_drv_type = card-&gt;ext_csd.raw_driver_strength |</span>
<span class="p_add">+			mmc_driver_type_mask(0);</span>
<span class="p_add">+</span>
<span class="p_add">+	drive_strength = mmc_select_drive_strength(card,</span>
<span class="p_add">+						   card-&gt;ext_csd.hs200_max_dtr,</span>
<span class="p_add">+						   card_drv_type, &amp;drv_type);</span>
<span class="p_add">+</span>
<span class="p_add">+	card-&gt;drive_strength = drive_strength;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (drv_type)</span>
<span class="p_add">+		mmc_set_driver_type(card-&gt;host, drv_type);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int mmc_select_hs400es(struct mmc_card *card)
 {
 	struct mmc_host *host = card-&gt;host;
<span class="p_chunk">@@ -1341,6 +1358,8 @@</span> <span class="p_context"> static int mmc_select_hs400es(struct mmc_card *card)</span>
 		goto out_err;
 	}
 
<span class="p_add">+	mmc_select_driver_type(card);</span>
<span class="p_add">+</span>
 	/* Switch card to HS400 */
 	val = EXT_CSD_TIMING_HS400 |
 	      card-&gt;drive_strength &lt;&lt; EXT_CSD_DRV_STR_SHIFT;
<span class="p_chunk">@@ -1374,23 +1393,6 @@</span> <span class="p_context"> static int mmc_select_hs400es(struct mmc_card *card)</span>
 	return err;
 }
 
<span class="p_del">-static void mmc_select_driver_type(struct mmc_card *card)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int card_drv_type, drive_strength, drv_type;</span>
<span class="p_del">-</span>
<span class="p_del">-	card_drv_type = card-&gt;ext_csd.raw_driver_strength |</span>
<span class="p_del">-			mmc_driver_type_mask(0);</span>
<span class="p_del">-</span>
<span class="p_del">-	drive_strength = mmc_select_drive_strength(card,</span>
<span class="p_del">-						   card-&gt;ext_csd.hs200_max_dtr,</span>
<span class="p_del">-						   card_drv_type, &amp;drv_type);</span>
<span class="p_del">-</span>
<span class="p_del">-	card-&gt;drive_strength = drive_strength;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (drv_type)</span>
<span class="p_del">-		mmc_set_driver_type(card-&gt;host, drv_type);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * For device supporting HS200 mode, the following sequence
  * should be done before executing the tuning process.
<span class="p_header">diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c</span>
<span class="p_header">index fc63992ab0e0..c99dc59d729b 100644</span>
<span class="p_header">--- a/drivers/net/bonding/bond_main.c</span>
<span class="p_header">+++ b/drivers/net/bonding/bond_main.c</span>
<span class="p_chunk">@@ -4289,7 +4289,7 @@</span> <span class="p_context"> static int bond_check_params(struct bond_params *params)</span>
 	int bond_mode	= BOND_MODE_ROUNDROBIN;
 	int xmit_hashtype = BOND_XMIT_POLICY_LAYER2;
 	int lacp_fast = 0;
<span class="p_del">-	int tlb_dynamic_lb = 0;</span>
<span class="p_add">+	int tlb_dynamic_lb;</span>
 
 	/* Convert string parameters. */
 	if (mode) {
<span class="p_chunk">@@ -4601,16 +4601,13 @@</span> <span class="p_context"> static int bond_check_params(struct bond_params *params)</span>
 	}
 	ad_user_port_key = valptr-&gt;value;
 
<span class="p_del">-	if ((bond_mode == BOND_MODE_TLB) || (bond_mode == BOND_MODE_ALB)) {</span>
<span class="p_del">-		bond_opt_initstr(&amp;newval, &quot;default&quot;);</span>
<span class="p_del">-		valptr = bond_opt_parse(bond_opt_get(BOND_OPT_TLB_DYNAMIC_LB),</span>
<span class="p_del">-					&amp;newval);</span>
<span class="p_del">-		if (!valptr) {</span>
<span class="p_del">-			pr_err(&quot;Error: No tlb_dynamic_lb default value&quot;);</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		tlb_dynamic_lb = valptr-&gt;value;</span>
<span class="p_add">+	bond_opt_initstr(&amp;newval, &quot;default&quot;);</span>
<span class="p_add">+	valptr = bond_opt_parse(bond_opt_get(BOND_OPT_TLB_DYNAMIC_LB), &amp;newval);</span>
<span class="p_add">+	if (!valptr) {</span>
<span class="p_add">+		pr_err(&quot;Error: No tlb_dynamic_lb default value&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
 	}
<span class="p_add">+	tlb_dynamic_lb = valptr-&gt;value;</span>
 
 	if (lp_interval == 0) {
 		pr_warn(&quot;Warning: ip_interval must be between 1 and %d, so it was reset to %d\n&quot;,
<span class="p_header">diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c</span>
<span class="p_header">index a12d603d41c6..5931aa2fe997 100644</span>
<span class="p_header">--- a/drivers/net/bonding/bond_options.c</span>
<span class="p_header">+++ b/drivers/net/bonding/bond_options.c</span>
<span class="p_chunk">@@ -754,6 +754,9 @@</span> <span class="p_context"> static int bond_option_mode_set(struct bonding *bond,</span>
 			   bond-&gt;params.miimon);
 	}
 
<span class="p_add">+	if (newval-&gt;value == BOND_MODE_ALB)</span>
<span class="p_add">+		bond-&gt;params.tlb_dynamic_lb = 1;</span>
<span class="p_add">+</span>
 	/* don&#39;t cache arp_validate between modes */
 	bond-&gt;params.arp_validate = BOND_ARP_VALIDATE_NONE;
 	bond-&gt;params.mode = newval-&gt;value;
<span class="p_header">diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c</span>
<span class="p_header">index 5bcdd33101b0..c75271c722a7 100644</span>
<span class="p_header">--- a/drivers/net/dsa/mv88e6xxx/chip.c</span>
<span class="p_header">+++ b/drivers/net/dsa/mv88e6xxx/chip.c</span>
<span class="p_chunk">@@ -1184,6 +1184,10 @@</span> <span class="p_context"> static int mv88e6xxx_port_check_hw_vlan(struct dsa_switch *ds, int port,</span>
 	};
 	int i, err;
 
<span class="p_add">+	/* DSA and CPU ports have to be members of multiple vlans */</span>
<span class="p_add">+	if (dsa_is_dsa_port(ds, port) || dsa_is_cpu_port(ds, port))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	if (!vid_begin)
 		return -EOPNOTSUPP;
 
<span class="p_chunk">@@ -4015,7 +4019,9 @@</span> <span class="p_context"> static void mv88e6xxx_remove(struct mdio_device *mdiodev)</span>
 	if (chip-&gt;irq &gt; 0) {
 		if (mv88e6xxx_has(chip, MV88E6XXX_FLAG_G2_INT))
 			mv88e6xxx_g2_irq_free(chip);
<span class="p_add">+		mutex_lock(&amp;chip-&gt;reg_lock);</span>
 		mv88e6xxx_g1_irq_free(chip);
<span class="p_add">+		mutex_unlock(&amp;chip-&gt;reg_lock);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/net/ethernet/ibm/emac/mal.c b/drivers/net/ethernet/ibm/emac/mal.c</span>
<span class="p_header">index 91b1a558f37d..248888328232 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/ibm/emac/mal.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/ibm/emac/mal.c</span>
<span class="p_chunk">@@ -402,7 +402,7 @@</span> <span class="p_context"> static int mal_poll(struct napi_struct *napi, int budget)</span>
 	unsigned long flags;
 
 	MAL_DBG2(mal, &quot;poll(%d)&quot; NL, budget);
<span class="p_del">- again:</span>
<span class="p_add">+</span>
 	/* Process TX skbs */
 	list_for_each(l, &amp;mal-&gt;poll_list) {
 		struct mal_commac *mc =
<span class="p_chunk">@@ -451,7 +451,6 @@</span> <span class="p_context"> static int mal_poll(struct napi_struct *napi, int budget)</span>
 			spin_lock_irqsave(&amp;mal-&gt;lock, flags);
 			mal_disable_eob_irq(mal);
 			spin_unlock_irqrestore(&amp;mal-&gt;lock, flags);
<span class="p_del">-			goto again;</span>
 		}
 		mc-&gt;ops-&gt;poll_tx(mc-&gt;dev);
 	}
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c b/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c</span>
<span class="p_header">index 85298051a3e4..145e392ab849 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c</span>
<span class="p_chunk">@@ -572,12 +572,13 @@</span> <span class="p_context"> void mlx5_rdma_netdev_free(struct net_device *netdev)</span>
 {
 	struct mlx5e_priv          *priv    = mlx5i_epriv(netdev);
 	const struct mlx5e_profile *profile = priv-&gt;profile;
<span class="p_add">+	struct mlx5_core_dev       *mdev    = priv-&gt;mdev;</span>
 
 	mlx5e_detach_netdev(priv);
 	profile-&gt;cleanup(priv);
 	destroy_workqueue(priv-&gt;wq);
 	free_netdev(netdev);
 
<span class="p_del">-	mlx5e_destroy_mdev_resources(priv-&gt;mdev);</span>
<span class="p_add">+	mlx5e_destroy_mdev_resources(mdev);</span>
 }
 EXPORT_SYMBOL(mlx5_rdma_netdev_free);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c</span>
<span class="p_header">index c6a3e61b53bd..73390f90b581 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c</span>
<span class="p_chunk">@@ -572,15 +572,14 @@</span> <span class="p_context"> static void mlxsw_sp_span_entry_destroy(struct mlxsw_sp *mlxsw_sp,</span>
 }
 
 static struct mlxsw_sp_span_entry *
<span class="p_del">-mlxsw_sp_span_entry_find(struct mlxsw_sp_port *port)</span>
<span class="p_add">+mlxsw_sp_span_entry_find(struct mlxsw_sp *mlxsw_sp, u8 local_port)</span>
 {
<span class="p_del">-	struct mlxsw_sp *mlxsw_sp = port-&gt;mlxsw_sp;</span>
 	int i;
 
 	for (i = 0; i &lt; mlxsw_sp-&gt;span.entries_count; i++) {
 		struct mlxsw_sp_span_entry *curr = &amp;mlxsw_sp-&gt;span.entries[i];
 
<span class="p_del">-		if (curr-&gt;used &amp;&amp; curr-&gt;local_port == port-&gt;local_port)</span>
<span class="p_add">+		if (curr-&gt;used &amp;&amp; curr-&gt;local_port == local_port)</span>
 			return curr;
 	}
 	return NULL;
<span class="p_chunk">@@ -591,7 +590,8 @@</span> <span class="p_context"> static struct mlxsw_sp_span_entry</span>
 {
 	struct mlxsw_sp_span_entry *span_entry;
 
<span class="p_del">-	span_entry = mlxsw_sp_span_entry_find(port);</span>
<span class="p_add">+	span_entry = mlxsw_sp_span_entry_find(port-&gt;mlxsw_sp,</span>
<span class="p_add">+					      port-&gt;local_port);</span>
 	if (span_entry) {
 		/* Already exists, just take a reference */
 		span_entry-&gt;ref_count++;
<span class="p_chunk">@@ -780,12 +780,13 @@</span> <span class="p_context"> static int mlxsw_sp_span_mirror_add(struct mlxsw_sp_port *from,</span>
 }
 
 static void mlxsw_sp_span_mirror_remove(struct mlxsw_sp_port *from,
<span class="p_del">-					struct mlxsw_sp_port *to,</span>
<span class="p_add">+					u8 destination_port,</span>
 					enum mlxsw_sp_span_type type)
 {
 	struct mlxsw_sp_span_entry *span_entry;
 
<span class="p_del">-	span_entry = mlxsw_sp_span_entry_find(to);</span>
<span class="p_add">+	span_entry = mlxsw_sp_span_entry_find(from-&gt;mlxsw_sp,</span>
<span class="p_add">+					      destination_port);</span>
 	if (!span_entry) {
 		netdev_err(from-&gt;dev, &quot;no span entry found\n&quot;);
 		return;
<span class="p_chunk">@@ -1560,14 +1561,12 @@</span> <span class="p_context"> static void</span>
 mlxsw_sp_port_del_cls_matchall_mirror(struct mlxsw_sp_port *mlxsw_sp_port,
 				      struct mlxsw_sp_port_mall_mirror_tc_entry *mirror)
 {
<span class="p_del">-	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_port-&gt;mlxsw_sp;</span>
 	enum mlxsw_sp_span_type span_type;
<span class="p_del">-	struct mlxsw_sp_port *to_port;</span>
 
<span class="p_del">-	to_port = mlxsw_sp-&gt;ports[mirror-&gt;to_local_port];</span>
 	span_type = mirror-&gt;ingress ?
 			MLXSW_SP_SPAN_INGRESS : MLXSW_SP_SPAN_EGRESS;
<span class="p_del">-	mlxsw_sp_span_mirror_remove(mlxsw_sp_port, to_port, span_type);</span>
<span class="p_add">+	mlxsw_sp_span_mirror_remove(mlxsw_sp_port, mirror-&gt;to_local_port,</span>
<span class="p_add">+				    span_type);</span>
 }
 
 static int
<span class="p_chunk">@@ -2519,7 +2518,9 @@</span> <span class="p_context"> static int mlxsw_sp_flash_device(struct net_device *dev,</span>
 	return err;
 }
 
<span class="p_del">-#define MLXSW_SP_QSFP_I2C_ADDR 0x50</span>
<span class="p_add">+#define MLXSW_SP_I2C_ADDR_LOW 0x50</span>
<span class="p_add">+#define MLXSW_SP_I2C_ADDR_HIGH 0x51</span>
<span class="p_add">+#define MLXSW_SP_EEPROM_PAGE_LENGTH 256</span>
 
 static int mlxsw_sp_query_module_eeprom(struct mlxsw_sp_port *mlxsw_sp_port,
 					u16 offset, u16 size, void *data,
<span class="p_chunk">@@ -2528,12 +2529,25 @@</span> <span class="p_context"> static int mlxsw_sp_query_module_eeprom(struct mlxsw_sp_port *mlxsw_sp_port,</span>
 	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_port-&gt;mlxsw_sp;
 	char eeprom_tmp[MLXSW_SP_REG_MCIA_EEPROM_SIZE];
 	char mcia_pl[MLXSW_REG_MCIA_LEN];
<span class="p_add">+	u16 i2c_addr;</span>
 	int status;
 	int err;
 
 	size = min_t(u16, size, MLXSW_SP_REG_MCIA_EEPROM_SIZE);
<span class="p_add">+</span>
<span class="p_add">+	if (offset &lt; MLXSW_SP_EEPROM_PAGE_LENGTH &amp;&amp;</span>
<span class="p_add">+	    offset + size &gt; MLXSW_SP_EEPROM_PAGE_LENGTH)</span>
<span class="p_add">+		/* Cross pages read, read until offset 256 in low page */</span>
<span class="p_add">+		size = MLXSW_SP_EEPROM_PAGE_LENGTH - offset;</span>
<span class="p_add">+</span>
<span class="p_add">+	i2c_addr = MLXSW_SP_I2C_ADDR_LOW;</span>
<span class="p_add">+	if (offset &gt;= MLXSW_SP_EEPROM_PAGE_LENGTH) {</span>
<span class="p_add">+		i2c_addr = MLXSW_SP_I2C_ADDR_HIGH;</span>
<span class="p_add">+		offset -= MLXSW_SP_EEPROM_PAGE_LENGTH;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	mlxsw_reg_mcia_pack(mcia_pl, mlxsw_sp_port-&gt;mapping.module,
<span class="p_del">-			    0, 0, offset, size, MLXSW_SP_QSFP_I2C_ADDR);</span>
<span class="p_add">+			    0, 0, offset, size, i2c_addr);</span>
 
 	err = mlxsw_reg_query(mlxsw_sp-&gt;core, MLXSW_REG(mcia), mcia_pl);
 	if (err)
<span class="p_header">diff --git a/drivers/net/ethernet/qualcomm/emac/emac-mac.c b/drivers/net/ethernet/qualcomm/emac/emac-mac.c</span>
<span class="p_header">index bcd4708b3745..97f18cdc9516 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/qualcomm/emac/emac-mac.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/qualcomm/emac/emac-mac.c</span>
<span class="p_chunk">@@ -876,7 +876,8 @@</span> <span class="p_context"> static void emac_mac_rx_descs_refill(struct emac_adapter *adpt,</span>
 
 		curr_rxbuf-&gt;dma_addr =
 			dma_map_single(adpt-&gt;netdev-&gt;dev.parent, skb-&gt;data,
<span class="p_del">-				       curr_rxbuf-&gt;length, DMA_FROM_DEVICE);</span>
<span class="p_add">+				       adpt-&gt;rxbuf_size, DMA_FROM_DEVICE);</span>
<span class="p_add">+</span>
 		ret = dma_mapping_error(adpt-&gt;netdev-&gt;dev.parent,
 					curr_rxbuf-&gt;dma_addr);
 		if (ret) {
<span class="p_header">diff --git a/drivers/net/ethernet/realtek/8139too.c b/drivers/net/ethernet/realtek/8139too.c</span>
<span class="p_header">index ca22f2898664..d24b47b8e0b2 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/realtek/8139too.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/realtek/8139too.c</span>
<span class="p_chunk">@@ -2135,11 +2135,12 @@</span> <span class="p_context"> static int rtl8139_poll(struct napi_struct *napi, int budget)</span>
 	if (likely(RTL_R16(IntrStatus) &amp; RxAckBits))
 		work_done += rtl8139_rx(dev, tp, budget);
 
<span class="p_del">-	if (work_done &lt; budget &amp;&amp; napi_complete_done(napi, work_done)) {</span>
<span class="p_add">+	if (work_done &lt; budget) {</span>
 		unsigned long flags;
 
 		spin_lock_irqsave(&amp;tp-&gt;lock, flags);
<span class="p_del">-		RTL_W16_F(IntrMask, rtl8139_intr_mask);</span>
<span class="p_add">+		if (napi_complete_done(napi, work_done))</span>
<span class="p_add">+			RTL_W16_F(IntrMask, rtl8139_intr_mask);</span>
 		spin_unlock_irqrestore(&amp;tp-&gt;lock, flags);
 	}
 	spin_unlock(&amp;tp-&gt;rx_lock);
<span class="p_header">diff --git a/drivers/net/ethernet/rocker/rocker_tlv.h b/drivers/net/ethernet/rocker/rocker_tlv.h</span>
<span class="p_header">index a63ef82e7c72..dfae3c9d57c6 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/rocker/rocker_tlv.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/rocker/rocker_tlv.h</span>
<span class="p_chunk">@@ -139,40 +139,52 @@</span> <span class="p_context"> rocker_tlv_start(struct rocker_desc_info *desc_info)</span>
 int rocker_tlv_put(struct rocker_desc_info *desc_info,
 		   int attrtype, int attrlen, const void *data);
 
<span class="p_del">-static inline int rocker_tlv_put_u8(struct rocker_desc_info *desc_info,</span>
<span class="p_del">-				    int attrtype, u8 value)</span>
<span class="p_add">+static inline int</span>
<span class="p_add">+rocker_tlv_put_u8(struct rocker_desc_info *desc_info, int attrtype, u8 value)</span>
 {
<span class="p_del">-	return rocker_tlv_put(desc_info, attrtype, sizeof(u8), &amp;value);</span>
<span class="p_add">+	u8 tmp = value; /* work around GCC PR81715 */</span>
<span class="p_add">+</span>
<span class="p_add">+	return rocker_tlv_put(desc_info, attrtype, sizeof(u8), &amp;tmp);</span>
 }
 
<span class="p_del">-static inline int rocker_tlv_put_u16(struct rocker_desc_info *desc_info,</span>
<span class="p_del">-				     int attrtype, u16 value)</span>
<span class="p_add">+static inline int</span>
<span class="p_add">+rocker_tlv_put_u16(struct rocker_desc_info *desc_info, int attrtype, u16 value)</span>
 {
<span class="p_del">-	return rocker_tlv_put(desc_info, attrtype, sizeof(u16), &amp;value);</span>
<span class="p_add">+	u16 tmp = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	return rocker_tlv_put(desc_info, attrtype, sizeof(u16), &amp;tmp);</span>
 }
 
<span class="p_del">-static inline int rocker_tlv_put_be16(struct rocker_desc_info *desc_info,</span>
<span class="p_del">-				      int attrtype, __be16 value)</span>
<span class="p_add">+static inline int</span>
<span class="p_add">+rocker_tlv_put_be16(struct rocker_desc_info *desc_info, int attrtype, __be16 value)</span>
 {
<span class="p_del">-	return rocker_tlv_put(desc_info, attrtype, sizeof(__be16), &amp;value);</span>
<span class="p_add">+	__be16 tmp = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	return rocker_tlv_put(desc_info, attrtype, sizeof(__be16), &amp;tmp);</span>
 }
 
<span class="p_del">-static inline int rocker_tlv_put_u32(struct rocker_desc_info *desc_info,</span>
<span class="p_del">-				     int attrtype, u32 value)</span>
<span class="p_add">+static inline int</span>
<span class="p_add">+rocker_tlv_put_u32(struct rocker_desc_info *desc_info, int attrtype, u32 value)</span>
 {
<span class="p_del">-	return rocker_tlv_put(desc_info, attrtype, sizeof(u32), &amp;value);</span>
<span class="p_add">+	u32 tmp = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	return rocker_tlv_put(desc_info, attrtype, sizeof(u32), &amp;tmp);</span>
 }
 
<span class="p_del">-static inline int rocker_tlv_put_be32(struct rocker_desc_info *desc_info,</span>
<span class="p_del">-				      int attrtype, __be32 value)</span>
<span class="p_add">+static inline int</span>
<span class="p_add">+rocker_tlv_put_be32(struct rocker_desc_info *desc_info, int attrtype, __be32 value)</span>
 {
<span class="p_del">-	return rocker_tlv_put(desc_info, attrtype, sizeof(__be32), &amp;value);</span>
<span class="p_add">+	__be32 tmp = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	return rocker_tlv_put(desc_info, attrtype, sizeof(__be32), &amp;tmp);</span>
 }
 
<span class="p_del">-static inline int rocker_tlv_put_u64(struct rocker_desc_info *desc_info,</span>
<span class="p_del">-				     int attrtype, u64 value)</span>
<span class="p_add">+static inline int</span>
<span class="p_add">+rocker_tlv_put_u64(struct rocker_desc_info *desc_info, int attrtype, u64 value)</span>
 {
<span class="p_del">-	return rocker_tlv_put(desc_info, attrtype, sizeof(u64), &amp;value);</span>
<span class="p_add">+	u64 tmp = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	return rocker_tlv_put(desc_info, attrtype, sizeof(u64), &amp;tmp);</span>
 }
 
 static inline struct rocker_tlv *
<span class="p_header">diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c</span>
<span class="p_header">index a366b3747eeb..8a280b48e3a9 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c</span>
<span class="p_chunk">@@ -315,6 +315,7 @@</span> <span class="p_context"> static int stmmac_dt_phy(struct plat_stmmacenet_data *plat,</span>
 		{ .compatible = &quot;allwinner,sun8i-h3-emac&quot; },
 		{ .compatible = &quot;allwinner,sun8i-v3s-emac&quot; },
 		{ .compatible = &quot;allwinner,sun50i-a64-emac&quot; },
<span class="p_add">+		{},</span>
 	};
 
 	/* If phy-handle property is passed from DT, use it as the PHY */
<span class="p_header">diff --git a/drivers/net/phy/xilinx_gmii2rgmii.c b/drivers/net/phy/xilinx_gmii2rgmii.c</span>
<span class="p_header">index d15dd3938ba8..2e5150b0b8d5 100644</span>
<span class="p_header">--- a/drivers/net/phy/xilinx_gmii2rgmii.c</span>
<span class="p_header">+++ b/drivers/net/phy/xilinx_gmii2rgmii.c</span>
<span class="p_chunk">@@ -44,7 +44,7 @@</span> <span class="p_context"> static int xgmiitorgmii_read_status(struct phy_device *phydev)</span>
 	priv-&gt;phy_drv-&gt;read_status(phydev);
 
 	val = mdiobus_read(phydev-&gt;mdio.bus, priv-&gt;addr, XILINX_GMII2RGMII_REG);
<span class="p_del">-	val &amp;= XILINX_GMII2RGMII_SPEED_MASK;</span>
<span class="p_add">+	val &amp;= ~XILINX_GMII2RGMII_SPEED_MASK;</span>
 
 	if (phydev-&gt;speed == SPEED_1000)
 		val |= BMCR_SPEED1000;
<span class="p_header">diff --git a/drivers/net/tun.c b/drivers/net/tun.c</span>
<span class="p_header">index 0a2c0a42283f..cb1f7747adad 100644</span>
<span class="p_header">--- a/drivers/net/tun.c</span>
<span class="p_header">+++ b/drivers/net/tun.c</span>
<span class="p_chunk">@@ -1298,11 +1298,13 @@</span> <span class="p_context"> static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,</span>
 	switch (tun-&gt;flags &amp; TUN_TYPE_MASK) {
 	case IFF_TUN:
 		if (tun-&gt;flags &amp; IFF_NO_PI) {
<span class="p_del">-			switch (skb-&gt;data[0] &amp; 0xf0) {</span>
<span class="p_del">-			case 0x40:</span>
<span class="p_add">+			u8 ip_version = skb-&gt;len ? (skb-&gt;data[0] &gt;&gt; 4) : 0;</span>
<span class="p_add">+</span>
<span class="p_add">+			switch (ip_version) {</span>
<span class="p_add">+			case 4:</span>
 				pi.proto = htons(ETH_P_IP);
 				break;
<span class="p_del">-			case 0x60:</span>
<span class="p_add">+			case 6:</span>
 				pi.proto = htons(ETH_P_IPV6);
 				break;
 			default:
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c</span>
<span class="p_header">index 7e689c86d565..f27d6fe4d5c0 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c</span>
<span class="p_chunk">@@ -980,7 +980,7 @@</span> <span class="p_context"> static void brcmf_escan_prep(struct brcmf_cfg80211_info *cfg,</span>
 
 	eth_broadcast_addr(params_le-&gt;bssid);
 	params_le-&gt;bss_type = DOT11_BSSTYPE_ANY;
<span class="p_del">-	params_le-&gt;scan_type = 0;</span>
<span class="p_add">+	params_le-&gt;scan_type = BRCMF_SCANTYPE_ACTIVE;</span>
 	params_le-&gt;channel_num = 0;
 	params_le-&gt;nprobes = cpu_to_le32(-1);
 	params_le-&gt;active_time = cpu_to_le32(-1);
<span class="p_chunk">@@ -988,12 +988,9 @@</span> <span class="p_context"> static void brcmf_escan_prep(struct brcmf_cfg80211_info *cfg,</span>
 	params_le-&gt;home_time = cpu_to_le32(-1);
 	memset(&amp;params_le-&gt;ssid_le, 0, sizeof(params_le-&gt;ssid_le));
 
<span class="p_del">-	/* if request is null exit so it will be all channel broadcast scan */</span>
<span class="p_del">-	if (!request)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	n_ssids = request-&gt;n_ssids;
 	n_channels = request-&gt;n_channels;
<span class="p_add">+</span>
 	/* Copy channel array if applicable */
 	brcmf_dbg(SCAN, &quot;### List of channelspecs to scan ### %d\n&quot;,
 		  n_channels);
<span class="p_chunk">@@ -1030,16 +1027,8 @@</span> <span class="p_context"> static void brcmf_escan_prep(struct brcmf_cfg80211_info *cfg,</span>
 			ptr += sizeof(ssid_le);
 		}
 	} else {
<span class="p_del">-		brcmf_dbg(SCAN, &quot;Broadcast scan %p\n&quot;, request-&gt;ssids);</span>
<span class="p_del">-		if ((request-&gt;ssids) &amp;&amp; request-&gt;ssids-&gt;ssid_len) {</span>
<span class="p_del">-			brcmf_dbg(SCAN, &quot;SSID %s len=%d\n&quot;,</span>
<span class="p_del">-				  params_le-&gt;ssid_le.SSID,</span>
<span class="p_del">-				  request-&gt;ssids-&gt;ssid_len);</span>
<span class="p_del">-			params_le-&gt;ssid_le.SSID_len =</span>
<span class="p_del">-				cpu_to_le32(request-&gt;ssids-&gt;ssid_len);</span>
<span class="p_del">-			memcpy(&amp;params_le-&gt;ssid_le.SSID, request-&gt;ssids-&gt;ssid,</span>
<span class="p_del">-				request-&gt;ssids-&gt;ssid_len);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		brcmf_dbg(SCAN, &quot;Performing passive scan\n&quot;);</span>
<span class="p_add">+		params_le-&gt;scan_type = BRCMF_SCANTYPE_PASSIVE;</span>
 	}
 	/* Adding mask to channel numbers */
 	params_le-&gt;channel_num =
<span class="p_chunk">@@ -3162,6 +3151,7 @@</span> <span class="p_context"> brcmf_cfg80211_escan_handler(struct brcmf_if *ifp,</span>
 	struct brcmf_cfg80211_info *cfg = ifp-&gt;drvr-&gt;config;
 	s32 status;
 	struct brcmf_escan_result_le *escan_result_le;
<span class="p_add">+	u32 escan_buflen;</span>
 	struct brcmf_bss_info_le *bss_info_le;
 	struct brcmf_bss_info_le *bss = NULL;
 	u32 bi_length;
<span class="p_chunk">@@ -3181,11 +3171,23 @@</span> <span class="p_context"> brcmf_cfg80211_escan_handler(struct brcmf_if *ifp,</span>
 
 	if (status == BRCMF_E_STATUS_PARTIAL) {
 		brcmf_dbg(SCAN, &quot;ESCAN Partial result\n&quot;);
<span class="p_add">+		if (e-&gt;datalen &lt; sizeof(*escan_result_le)) {</span>
<span class="p_add">+			brcmf_err(&quot;invalid event data length\n&quot;);</span>
<span class="p_add">+			goto exit;</span>
<span class="p_add">+		}</span>
 		escan_result_le = (struct brcmf_escan_result_le *) data;
 		if (!escan_result_le) {
 			brcmf_err(&quot;Invalid escan result (NULL pointer)\n&quot;);
 			goto exit;
 		}
<span class="p_add">+		escan_buflen = le32_to_cpu(escan_result_le-&gt;buflen);</span>
<span class="p_add">+		if (escan_buflen &gt; BRCMF_ESCAN_BUF_SIZE ||</span>
<span class="p_add">+		    escan_buflen &gt; e-&gt;datalen ||</span>
<span class="p_add">+		    escan_buflen &lt; sizeof(*escan_result_le)) {</span>
<span class="p_add">+			brcmf_err(&quot;Invalid escan buffer length: %d\n&quot;,</span>
<span class="p_add">+				  escan_buflen);</span>
<span class="p_add">+			goto exit;</span>
<span class="p_add">+		}</span>
 		if (le16_to_cpu(escan_result_le-&gt;bss_count) != 1) {
 			brcmf_err(&quot;Invalid bss_count %d: ignoring\n&quot;,
 				  escan_result_le-&gt;bss_count);
<span class="p_chunk">@@ -3202,9 +3204,8 @@</span> <span class="p_context"> brcmf_cfg80211_escan_handler(struct brcmf_if *ifp,</span>
 		}
 
 		bi_length = le32_to_cpu(bss_info_le-&gt;length);
<span class="p_del">-		if (bi_length != (le32_to_cpu(escan_result_le-&gt;buflen) -</span>
<span class="p_del">-					WL_ESCAN_RESULTS_FIXED_SIZE)) {</span>
<span class="p_del">-			brcmf_err(&quot;Invalid bss_info length %d: ignoring\n&quot;,</span>
<span class="p_add">+		if (bi_length != escan_buflen -	WL_ESCAN_RESULTS_FIXED_SIZE) {</span>
<span class="p_add">+			brcmf_err(&quot;Ignoring invalid bss_info length: %d\n&quot;,</span>
 				  bi_length);
 			goto exit;
 		}
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil_types.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil_types.h</span>
<span class="p_header">index 8391989b1882..e0d22fedb2b4 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil_types.h</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil_types.h</span>
<span class="p_chunk">@@ -45,6 +45,11 @@</span> <span class="p_context"></span>
 #define BRCMF_SCAN_PARAMS_COUNT_MASK	0x0000ffff
 #define BRCMF_SCAN_PARAMS_NSSID_SHIFT	16
 
<span class="p_add">+/* scan type definitions */</span>
<span class="p_add">+#define BRCMF_SCANTYPE_DEFAULT		0xFF</span>
<span class="p_add">+#define BRCMF_SCANTYPE_ACTIVE		0</span>
<span class="p_add">+#define BRCMF_SCANTYPE_PASSIVE		1</span>
<span class="p_add">+</span>
 #define BRCMF_WSEC_MAX_PSK_LEN		32
 #define	BRCMF_WSEC_PASSPHRASE		BIT(0)
 
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c b/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">index ce901be5fba8..f0132c492a79 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c</span>
<span class="p_chunk">@@ -1589,6 +1589,11 @@</span> <span class="p_context"> static void iwl_mvm_mc_iface_iterator(void *_data, u8 *mac,</span>
 	struct iwl_mvm_mc_iter_data *data = _data;
 	struct iwl_mvm *mvm = data-&gt;mvm;
 	struct iwl_mcast_filter_cmd *cmd = mvm-&gt;mcast_filter_cmd;
<span class="p_add">+	struct iwl_host_cmd hcmd = {</span>
<span class="p_add">+		.id = MCAST_FILTER_CMD,</span>
<span class="p_add">+		.flags = CMD_ASYNC,</span>
<span class="p_add">+		.dataflags[0] = IWL_HCMD_DFL_NOCOPY,</span>
<span class="p_add">+	};</span>
 	int ret, len;
 
 	/* if we don&#39;t have free ports, mcast frames will be dropped */
<span class="p_chunk">@@ -1603,7 +1608,10 @@</span> <span class="p_context"> static void iwl_mvm_mc_iface_iterator(void *_data, u8 *mac,</span>
 	memcpy(cmd-&gt;bssid, vif-&gt;bss_conf.bssid, ETH_ALEN);
 	len = roundup(sizeof(*cmd) + cmd-&gt;count * ETH_ALEN, 4);
 
<span class="p_del">-	ret = iwl_mvm_send_cmd_pdu(mvm, MCAST_FILTER_CMD, CMD_ASYNC, len, cmd);</span>
<span class="p_add">+	hcmd.len[0] = len;</span>
<span class="p_add">+	hcmd.data[0] = cmd;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = iwl_mvm_send_cmd(mvm, &amp;hcmd);</span>
 	if (ret)
 		IWL_ERR(mvm, &quot;mcast filter cmd error. ret=%d\n&quot;, ret);
 }
<span class="p_header">diff --git a/drivers/nvme/host/pci.c b/drivers/nvme/host/pci.c</span>
<span class="p_header">index cdf4c0e471b9..ba41b660b259 100644</span>
<span class="p_header">--- a/drivers/nvme/host/pci.c</span>
<span class="p_header">+++ b/drivers/nvme/host/pci.c</span>
<span class="p_chunk">@@ -93,7 +93,7 @@</span> <span class="p_context"> struct nvme_dev {</span>
 	struct mutex shutdown_lock;
 	bool subsystem;
 	void __iomem *cmb;
<span class="p_del">-	dma_addr_t cmb_dma_addr;</span>
<span class="p_add">+	pci_bus_addr_t cmb_bus_addr;</span>
 	u64 cmb_size;
 	u32 cmbsz;
 	u32 cmbloc;
<span class="p_chunk">@@ -1218,7 +1218,7 @@</span> <span class="p_context"> static int nvme_alloc_sq_cmds(struct nvme_dev *dev, struct nvme_queue *nvmeq,</span>
 	if (qid &amp;&amp; dev-&gt;cmb &amp;&amp; use_cmb_sqes &amp;&amp; NVME_CMB_SQS(dev-&gt;cmbsz)) {
 		unsigned offset = (qid - 1) * roundup(SQ_SIZE(depth),
 						      dev-&gt;ctrl.page_size);
<span class="p_del">-		nvmeq-&gt;sq_dma_addr = dev-&gt;cmb_dma_addr + offset;</span>
<span class="p_add">+		nvmeq-&gt;sq_dma_addr = dev-&gt;cmb_bus_addr + offset;</span>
 		nvmeq-&gt;sq_cmds_io = dev-&gt;cmb + offset;
 	} else {
 		nvmeq-&gt;sq_cmds = dma_alloc_coherent(dev-&gt;dev, SQ_SIZE(depth),
<span class="p_chunk">@@ -1517,7 +1517,7 @@</span> <span class="p_context"> static void __iomem *nvme_map_cmb(struct nvme_dev *dev)</span>
 	resource_size_t bar_size;
 	struct pci_dev *pdev = to_pci_dev(dev-&gt;dev);
 	void __iomem *cmb;
<span class="p_del">-	dma_addr_t dma_addr;</span>
<span class="p_add">+	int bar;</span>
 
 	dev-&gt;cmbsz = readl(dev-&gt;bar + NVME_REG_CMBSZ);
 	if (!(NVME_CMB_SZ(dev-&gt;cmbsz)))
<span class="p_chunk">@@ -1530,7 +1530,8 @@</span> <span class="p_context"> static void __iomem *nvme_map_cmb(struct nvme_dev *dev)</span>
 	szu = (u64)1 &lt;&lt; (12 + 4 * NVME_CMB_SZU(dev-&gt;cmbsz));
 	size = szu * NVME_CMB_SZ(dev-&gt;cmbsz);
 	offset = szu * NVME_CMB_OFST(dev-&gt;cmbloc);
<span class="p_del">-	bar_size = pci_resource_len(pdev, NVME_CMB_BIR(dev-&gt;cmbloc));</span>
<span class="p_add">+	bar = NVME_CMB_BIR(dev-&gt;cmbloc);</span>
<span class="p_add">+	bar_size = pci_resource_len(pdev, bar);</span>
 
 	if (offset &gt; bar_size)
 		return NULL;
<span class="p_chunk">@@ -1543,12 +1544,11 @@</span> <span class="p_context"> static void __iomem *nvme_map_cmb(struct nvme_dev *dev)</span>
 	if (size &gt; bar_size - offset)
 		size = bar_size - offset;
 
<span class="p_del">-	dma_addr = pci_resource_start(pdev, NVME_CMB_BIR(dev-&gt;cmbloc)) + offset;</span>
<span class="p_del">-	cmb = ioremap_wc(dma_addr, size);</span>
<span class="p_add">+	cmb = ioremap_wc(pci_resource_start(pdev, bar) + offset, size);</span>
 	if (!cmb)
 		return NULL;
 
<span class="p_del">-	dev-&gt;cmb_dma_addr = dma_addr;</span>
<span class="p_add">+	dev-&gt;cmb_bus_addr = pci_bus_address(pdev, bar) + offset;</span>
 	dev-&gt;cmb_size = size;
 	return cmb;
 }
<span class="p_header">diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c</span>
<span class="p_header">index fd88dabd599d..9f1d53e18956 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_scan.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_scan.c</span>
<span class="p_chunk">@@ -956,6 +956,9 @@</span> <span class="p_context"> static int scsi_add_lun(struct scsi_device *sdev, unsigned char *inq_result,</span>
 	if (*bflags &amp; BLIST_NO_DIF)
 		sdev-&gt;no_dif = 1;
 
<span class="p_add">+	if (*bflags &amp; BLIST_UNMAP_LIMIT_WS)</span>
<span class="p_add">+		sdev-&gt;unmap_limit_for_ws = 1;</span>
<span class="p_add">+</span>
 	sdev-&gt;eh_timeout = SCSI_DEFAULT_EH_TIMEOUT;
 
 	if (*bflags &amp; BLIST_TRY_VPD_PAGES)
<span class="p_header">diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c</span>
<span class="p_header">index e2647f2d4430..b93d92572c01 100644</span>
<span class="p_header">--- a/drivers/scsi/sd.c</span>
<span class="p_header">+++ b/drivers/scsi/sd.c</span>
<span class="p_chunk">@@ -715,13 +715,21 @@</span> <span class="p_context"> static void sd_config_discard(struct scsi_disk *sdkp, unsigned int mode)</span>
 		break;
 
 	case SD_LBP_WS16:
<span class="p_del">-		max_blocks = min_not_zero(sdkp-&gt;max_ws_blocks,</span>
<span class="p_del">-					  (u32)SD_MAX_WS16_BLOCKS);</span>
<span class="p_add">+		if (sdkp-&gt;device-&gt;unmap_limit_for_ws)</span>
<span class="p_add">+			max_blocks = sdkp-&gt;max_unmap_blocks;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			max_blocks = sdkp-&gt;max_ws_blocks;</span>
<span class="p_add">+</span>
<span class="p_add">+		max_blocks = min_not_zero(max_blocks, (u32)SD_MAX_WS16_BLOCKS);</span>
 		break;
 
 	case SD_LBP_WS10:
<span class="p_del">-		max_blocks = min_not_zero(sdkp-&gt;max_ws_blocks,</span>
<span class="p_del">-					  (u32)SD_MAX_WS10_BLOCKS);</span>
<span class="p_add">+		if (sdkp-&gt;device-&gt;unmap_limit_for_ws)</span>
<span class="p_add">+			max_blocks = sdkp-&gt;max_unmap_blocks;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			max_blocks = sdkp-&gt;max_ws_blocks;</span>
<span class="p_add">+</span>
<span class="p_add">+		max_blocks = min_not_zero(max_blocks, (u32)SD_MAX_WS10_BLOCKS);</span>
 		break;
 
 	case SD_LBP_ZERO:
<span class="p_chunk">@@ -3101,8 +3109,6 @@</span> <span class="p_context"> static int sd_revalidate_disk(struct gendisk *disk)</span>
 		sd_read_security(sdkp, buffer);
 	}
 
<span class="p_del">-	sdkp-&gt;first_scan = 0;</span>
<span class="p_del">-</span>
 	/*
 	 * We now have all cache related info, determine how we deal
 	 * with flush requests.
<span class="p_chunk">@@ -3117,7 +3123,7 @@</span> <span class="p_context"> static int sd_revalidate_disk(struct gendisk *disk)</span>
 	q-&gt;limits.max_dev_sectors = logical_to_sectors(sdp, dev_max);
 
 	/*
<span class="p_del">-	 * Use the device&#39;s preferred I/O size for reads and writes</span>
<span class="p_add">+	 * Determine the device&#39;s preferred I/O size for reads and writes</span>
 	 * unless the reported value is unreasonably small, large, or
 	 * garbage.
 	 */
<span class="p_chunk">@@ -3131,8 +3137,19 @@</span> <span class="p_context"> static int sd_revalidate_disk(struct gendisk *disk)</span>
 		rw_max = min_not_zero(logical_to_sectors(sdp, dev_max),
 				      (sector_t)BLK_DEF_MAX_SECTORS);
 
<span class="p_del">-	/* Combine with controller limits */</span>
<span class="p_del">-	q-&gt;limits.max_sectors = min(rw_max, queue_max_hw_sectors(q));</span>
<span class="p_add">+	/* Do not exceed controller limit */</span>
<span class="p_add">+	rw_max = min(rw_max, queue_max_hw_sectors(q));</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Only update max_sectors if previously unset or if the current value</span>
<span class="p_add">+	 * exceeds the capabilities of the hardware.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (sdkp-&gt;first_scan ||</span>
<span class="p_add">+	    q-&gt;limits.max_sectors &gt; q-&gt;limits.max_dev_sectors ||</span>
<span class="p_add">+	    q-&gt;limits.max_sectors &gt; q-&gt;limits.max_hw_sectors)</span>
<span class="p_add">+		q-&gt;limits.max_sectors = rw_max;</span>
<span class="p_add">+</span>
<span class="p_add">+	sdkp-&gt;first_scan = 0;</span>
 
 	set_capacity(disk, logical_to_sectors(sdp, sdkp-&gt;capacity));
 	sd_config_write_same(sdkp);
<span class="p_header">diff --git a/drivers/staging/iio/adc/ad7192.c b/drivers/staging/iio/adc/ad7192.c</span>
<span class="p_header">index d11c6de9c777..6150d2780e22 100644</span>
<span class="p_header">--- a/drivers/staging/iio/adc/ad7192.c</span>
<span class="p_header">+++ b/drivers/staging/iio/adc/ad7192.c</span>
<span class="p_chunk">@@ -223,11 +223,9 @@</span> <span class="p_context"> static int ad7192_setup(struct ad7192_state *st,</span>
 	struct iio_dev *indio_dev = spi_get_drvdata(st-&gt;sd.spi);
 	unsigned long long scale_uv;
 	int i, ret, id;
<span class="p_del">-	u8 ones[6];</span>
 
 	/* reset the serial interface */
<span class="p_del">-	memset(&amp;ones, 0xFF, 6);</span>
<span class="p_del">-	ret = spi_write(st-&gt;sd.spi, &amp;ones, 6);</span>
<span class="p_add">+	ret = ad_sd_reset(&amp;st-&gt;sd, 48);</span>
 	if (ret &lt; 0)
 		goto out;
 	usleep_range(500, 1000); /* Wait for at least 500us */
<span class="p_header">diff --git a/drivers/staging/media/imx/imx-media-of.c b/drivers/staging/media/imx/imx-media-of.c</span>
<span class="p_header">index b026fe66467c..90e7e702a411 100644</span>
<span class="p_header">--- a/drivers/staging/media/imx/imx-media-of.c</span>
<span class="p_header">+++ b/drivers/staging/media/imx/imx-media-of.c</span>
<span class="p_chunk">@@ -167,7 +167,7 @@</span> <span class="p_context"> of_parse_subdev(struct imx_media_dev *imxmd, struct device_node *sd_np,</span>
 		of_parse_sensor(imxmd, imxsd, sd_np);
 
 	for (i = 0; i &lt; num_pads; i++) {
<span class="p_del">-		struct device_node *epnode = NULL, *port, *remote_np;</span>
<span class="p_add">+		struct device_node *epnode = NULL, *port, *remote_np = NULL;</span>
 		struct imx_media_subdev *remote_imxsd;
 		struct imx_media_pad *pad;
 		int remote_pad;
<span class="p_header">diff --git a/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_2835_arm.c b/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_2835_arm.c</span>
<span class="p_header">index 0159ca4407d8..be08849175ea 100644</span>
<span class="p_header">--- a/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_2835_arm.c</span>
<span class="p_header">+++ b/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_2835_arm.c</span>
<span class="p_chunk">@@ -612,18 +612,20 @@</span> <span class="p_context"> free_pagelist(struct vchiq_pagelist_info *pagelistinfo,</span>
 			if (head_bytes &gt; actual)
 				head_bytes = actual;
 
<span class="p_del">-			memcpy((char *)page_address(pages[0]) +</span>
<span class="p_add">+			memcpy((char *)kmap(pages[0]) +</span>
 				pagelist-&gt;offset,
 				fragments,
 				head_bytes);
<span class="p_add">+			kunmap(pages[0]);</span>
 		}
 		if ((actual &gt;= 0) &amp;&amp; (head_bytes &lt; actual) &amp;&amp;
 			(tail_bytes != 0)) {
<span class="p_del">-			memcpy((char *)page_address(pages[num_pages - 1]) +</span>
<span class="p_add">+			memcpy((char *)kmap(pages[num_pages - 1]) +</span>
 				((pagelist-&gt;offset + actual) &amp;
 				(PAGE_SIZE - 1) &amp; ~(g_cache_line_size - 1)),
 				fragments + g_cache_line_size,
 				tail_bytes);
<span class="p_add">+			kunmap(pages[num_pages - 1]);</span>
 		}
 
 		down(&amp;g_free_fragments_mutex);
<span class="p_header">diff --git a/drivers/usb/class/cdc-wdm.c b/drivers/usb/class/cdc-wdm.c</span>
<span class="p_header">index 8f972247b1c1..6499391695b7 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-wdm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-wdm.c</span>
<span class="p_chunk">@@ -194,8 +194,10 @@</span> <span class="p_context"> static void wdm_in_callback(struct urb *urb)</span>
 	/*
 	 * only set a new error if there is no previous error.
 	 * Errors are only cleared during read/open
<span class="p_add">+	 * Avoid propagating -EPIPE (stall) to userspace since it is</span>
<span class="p_add">+	 * better handled as an empty read</span>
 	 */
<span class="p_del">-	if (desc-&gt;rerr  == 0)</span>
<span class="p_add">+	if (desc-&gt;rerr == 0 &amp;&amp; status != -EPIPE)</span>
 		desc-&gt;rerr = status;
 
 	if (length + desc-&gt;length &gt; desc-&gt;wMaxCommand) {
<span class="p_header">diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c</span>
<span class="p_header">index 4be52c602e9b..68b54bd88d1e 100644</span>
<span class="p_header">--- a/drivers/usb/core/config.c</span>
<span class="p_header">+++ b/drivers/usb/core/config.c</span>
<span class="p_chunk">@@ -643,15 +643,23 @@</span> <span class="p_context"> static int usb_parse_configuration(struct usb_device *dev, int cfgidx,</span>
 
 		} else if (header-&gt;bDescriptorType ==
 				USB_DT_INTERFACE_ASSOCIATION) {
<span class="p_add">+			struct usb_interface_assoc_descriptor *d;</span>
<span class="p_add">+</span>
<span class="p_add">+			d = (struct usb_interface_assoc_descriptor *)header;</span>
<span class="p_add">+			if (d-&gt;bLength &lt; USB_DT_INTERFACE_ASSOCIATION_SIZE) {</span>
<span class="p_add">+				dev_warn(ddev,</span>
<span class="p_add">+					 &quot;config %d has an invalid interface association descriptor of length %d, skipping\n&quot;,</span>
<span class="p_add">+					 cfgno, d-&gt;bLength);</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			if (iad_num == USB_MAXIADS) {
 				dev_warn(ddev, &quot;found more Interface &quot;
 					       &quot;Association Descriptors &quot;
 					       &quot;than allocated for in &quot;
 					       &quot;configuration %d\n&quot;, cfgno);
 			} else {
<span class="p_del">-				config-&gt;intf_assoc[iad_num] =</span>
<span class="p_del">-					(struct usb_interface_assoc_descriptor</span>
<span class="p_del">-					*)header;</span>
<span class="p_add">+				config-&gt;intf_assoc[iad_num] = d;</span>
 				iad_num++;
 			}
 
<span class="p_chunk">@@ -852,7 +860,7 @@</span> <span class="p_context"> int usb_get_configuration(struct usb_device *dev)</span>
 		}
 
 		if (dev-&gt;quirks &amp; USB_QUIRK_DELAY_INIT)
<span class="p_del">-			msleep(100);</span>
<span class="p_add">+			msleep(200);</span>
 
 		result = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,
 		    bigbuffer, length);
<span class="p_header">diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c</span>
<span class="p_header">index 0ff0feddfd1f..1d4dfdeb61c1 100644</span>
<span class="p_header">--- a/drivers/usb/core/devio.c</span>
<span class="p_header">+++ b/drivers/usb/core/devio.c</span>
<span class="p_chunk">@@ -140,6 +140,9 @@</span> <span class="p_context"> module_param(usbfs_memory_mb, uint, 0644);</span>
 MODULE_PARM_DESC(usbfs_memory_mb,
 		&quot;maximum MB allowed for usbfs buffers (0 = no limit)&quot;);
 
<span class="p_add">+/* Hard limit, necessary to avoid arithmetic overflow */</span>
<span class="p_add">+#define USBFS_XFER_MAX         (UINT_MAX / 2 - 1000000)</span>
<span class="p_add">+</span>
 static atomic64_t usbfs_memory_usage;	/* Total memory currently allocated */
 
 /* Check whether it&#39;s okay to allocate more memory for a transfer */
<span class="p_chunk">@@ -1460,6 +1463,8 @@</span> <span class="p_context"> static int proc_do_submiturb(struct usb_dev_state *ps, struct usbdevfs_urb *uurb</span>
 				USBDEVFS_URB_ZERO_PACKET |
 				USBDEVFS_URB_NO_INTERRUPT))
 		return -EINVAL;
<span class="p_add">+	if ((unsigned int)uurb-&gt;buffer_length &gt;= USBFS_XFER_MAX)</span>
<span class="p_add">+		return -EINVAL;</span>
 	if (uurb-&gt;buffer_length &gt; 0 &amp;&amp; !uurb-&gt;buffer)
 		return -EINVAL;
 	if (!(uurb-&gt;type == USBDEVFS_URB_TYPE_CONTROL &amp;&amp;
<span class="p_chunk">@@ -1571,7 +1576,11 @@</span> <span class="p_context"> static int proc_do_submiturb(struct usb_dev_state *ps, struct usbdevfs_urb *uurb</span>
 			totlen += isopkt[u].length;
 		}
 		u *= sizeof(struct usb_iso_packet_descriptor);
<span class="p_del">-		uurb-&gt;buffer_length = totlen;</span>
<span class="p_add">+		if (totlen &lt;= uurb-&gt;buffer_length)</span>
<span class="p_add">+			uurb-&gt;buffer_length = totlen;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			WARN_ONCE(1, &quot;uurb-&gt;buffer_length is too short %d vs %d&quot;,</span>
<span class="p_add">+				  totlen, uurb-&gt;buffer_length);</span>
 		break;
 
 	default:
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 822f8c50e423..78c2aca5b0fc 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -4825,7 +4825,7 @@</span> <span class="p_context"> static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,</span>
 			goto loop;
 
 		if (udev-&gt;quirks &amp; USB_QUIRK_DELAY_INIT)
<span class="p_del">-			msleep(1000);</span>
<span class="p_add">+			msleep(2000);</span>
 
 		/* consecutive bus-powered hubs aren&#39;t reliable; they can
 		 * violate the voltage drop budget.  if the new child has
<span class="p_header">diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c</span>
<span class="p_header">index 4c38ea41ae96..371a07d874a3 100644</span>
<span class="p_header">--- a/drivers/usb/core/message.c</span>
<span class="p_header">+++ b/drivers/usb/core/message.c</span>
<span class="p_chunk">@@ -2069,6 +2069,10 @@</span> <span class="p_context"> int cdc_parse_cdc_header(struct usb_cdc_parsed_header *hdr,</span>
 			elength = 1;
 			goto next_desc;
 		}
<span class="p_add">+		if ((buflen &lt; elength) || (elength &lt; 3)) {</span>
<span class="p_add">+			dev_err(&amp;intf-&gt;dev, &quot;invalid descriptor buffer length\n&quot;);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 		if (buffer[1] != USB_DT_CS_INTERFACE) {
 			dev_err(&amp;intf-&gt;dev, &quot;skipping garbage\n&quot;);
 			goto next_desc;
<span class="p_header">diff --git a/drivers/usb/dwc3/ep0.c b/drivers/usb/dwc3/ep0.c</span>
<span class="p_header">index 827e376bfa97..75e6cb044eb2 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/ep0.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/ep0.c</span>
<span class="p_chunk">@@ -990,6 +990,8 @@</span> <span class="p_context"> static void __dwc3_ep0_do_control_data(struct dwc3 *dwc,</span>
 					 DWC3_TRBCTL_CONTROL_DATA,
 					 true);
 
<span class="p_add">+		req-&gt;trb = &amp;dwc-&gt;ep0_trb[dep-&gt;trb_enqueue - 1];</span>
<span class="p_add">+</span>
 		/* Now prepare one extra TRB to align transfer size */
 		dwc3_ep0_prepare_one_trb(dep, dwc-&gt;bounce_addr,
 					 maxpacket - rem,
<span class="p_chunk">@@ -1015,6 +1017,8 @@</span> <span class="p_context"> static void __dwc3_ep0_do_control_data(struct dwc3 *dwc,</span>
 					 DWC3_TRBCTL_CONTROL_DATA,
 					 true);
 
<span class="p_add">+		req-&gt;trb = &amp;dwc-&gt;ep0_trb[dep-&gt;trb_enqueue - 1];</span>
<span class="p_add">+</span>
 		/* Now prepare one extra TRB to align transfer size */
 		dwc3_ep0_prepare_one_trb(dep, dwc-&gt;bounce_addr,
 					 0, DWC3_TRBCTL_CONTROL_DATA,
<span class="p_chunk">@@ -1029,6 +1033,9 @@</span> <span class="p_context"> static void __dwc3_ep0_do_control_data(struct dwc3 *dwc,</span>
 		dwc3_ep0_prepare_one_trb(dep, req-&gt;request.dma,
 				req-&gt;request.length, DWC3_TRBCTL_CONTROL_DATA,
 				false);
<span class="p_add">+</span>
<span class="p_add">+		req-&gt;trb = &amp;dwc-&gt;ep0_trb[dep-&gt;trb_enqueue];</span>
<span class="p_add">+</span>
 		ret = dwc3_ep0_start_trans(dep);
 	}
 
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_mass_storage.c b/drivers/usb/gadget/function/f_mass_storage.c</span>
<span class="p_header">index f95bddd6513f..daf3a07e3ffb 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_mass_storage.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_mass_storage.c</span>
<span class="p_chunk">@@ -307,8 +307,6 @@</span> <span class="p_context"> struct fsg_common {</span>
 	struct completion	thread_notifier;
 	struct task_struct	*thread_task;
 
<span class="p_del">-	/* Callback functions. */</span>
<span class="p_del">-	const struct fsg_operations	*ops;</span>
 	/* Gadget&#39;s private data. */
 	void			*private_data;
 
<span class="p_chunk">@@ -2440,6 +2438,7 @@</span> <span class="p_context"> static void handle_exception(struct fsg_common *common)</span>
 static int fsg_main_thread(void *common_)
 {
 	struct fsg_common	*common = common_;
<span class="p_add">+	int			i;</span>
 
 	/*
 	 * Allow the thread to be killed by a signal, but set the signal mask
<span class="p_chunk">@@ -2485,21 +2484,16 @@</span> <span class="p_context"> static int fsg_main_thread(void *common_)</span>
 	common-&gt;thread_task = NULL;
 	spin_unlock_irq(&amp;common-&gt;lock);
 
<span class="p_del">-	if (!common-&gt;ops || !common-&gt;ops-&gt;thread_exits</span>
<span class="p_del">-	 || common-&gt;ops-&gt;thread_exits(common) &lt; 0) {</span>
<span class="p_del">-		int i;</span>
<span class="p_add">+	/* Eject media from all LUNs */</span>
 
<span class="p_del">-		down_write(&amp;common-&gt;filesem);</span>
<span class="p_del">-		for (i = 0; i &lt; ARRAY_SIZE(common-&gt;luns); i++) {</span>
<span class="p_del">-			struct fsg_lun *curlun = common-&gt;luns[i];</span>
<span class="p_del">-			if (!curlun || !fsg_lun_is_open(curlun))</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+	down_write(&amp;common-&gt;filesem);</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(common-&gt;luns); i++) {</span>
<span class="p_add">+		struct fsg_lun *curlun = common-&gt;luns[i];</span>
 
<span class="p_add">+		if (curlun &amp;&amp; fsg_lun_is_open(curlun))</span>
 			fsg_lun_close(curlun);
<span class="p_del">-			curlun-&gt;unit_attention_data = SS_MEDIUM_NOT_PRESENT;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		up_write(&amp;common-&gt;filesem);</span>
 	}
<span class="p_add">+	up_write(&amp;common-&gt;filesem);</span>
 
 	/* Let fsg_unbind() know the thread has exited */
 	complete_and_exit(&amp;common-&gt;thread_notifier, 0);
<span class="p_chunk">@@ -2690,13 +2684,6 @@</span> <span class="p_context"> void fsg_common_remove_luns(struct fsg_common *common)</span>
 }
 EXPORT_SYMBOL_GPL(fsg_common_remove_luns);
 
<span class="p_del">-void fsg_common_set_ops(struct fsg_common *common,</span>
<span class="p_del">-			const struct fsg_operations *ops)</span>
<span class="p_del">-{</span>
<span class="p_del">-	common-&gt;ops = ops;</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(fsg_common_set_ops);</span>
<span class="p_del">-</span>
 void fsg_common_free_buffers(struct fsg_common *common)
 {
 	_fsg_common_free_buffers(common-&gt;buffhds, common-&gt;fsg_num_buffers);
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_mass_storage.h b/drivers/usb/gadget/function/f_mass_storage.h</span>
<span class="p_header">index d3902313b8ac..dc05ca0c4359 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_mass_storage.h</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_mass_storage.h</span>
<span class="p_chunk">@@ -60,17 +60,6 @@</span> <span class="p_context"> struct fsg_module_parameters {</span>
 struct fsg_common;
 
 /* FSF callback functions */
<span class="p_del">-struct fsg_operations {</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Callback function to call when thread exits.  If no</span>
<span class="p_del">-	 * callback is set or it returns value lower then zero MSF</span>
<span class="p_del">-	 * will force eject all LUNs it operates on (including those</span>
<span class="p_del">-	 * marked as non-removable or with prevent_medium_removal flag</span>
<span class="p_del">-	 * set).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	int (*thread_exits)(struct fsg_common *common);</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 struct fsg_lun_opts {
 	struct config_group group;
 	struct fsg_lun *lun;
<span class="p_chunk">@@ -142,9 +131,6 @@</span> <span class="p_context"> void fsg_common_remove_lun(struct fsg_lun *lun);</span>
 
 void fsg_common_remove_luns(struct fsg_common *common);
 
<span class="p_del">-void fsg_common_set_ops(struct fsg_common *common,</span>
<span class="p_del">-			const struct fsg_operations *ops);</span>
<span class="p_del">-</span>
 int fsg_common_create_lun(struct fsg_common *common, struct fsg_lun_config *cfg,
 			  unsigned int id, const char *name,
 			  const char **name_pfx);
<span class="p_header">diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_header">index 684900fcfe24..5c28bee327e1 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_chunk">@@ -28,7 +28,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/aio.h&gt;
 #include &lt;linux/uio.h&gt;
 #include &lt;linux/refcount.h&gt;
<span class="p_del">-</span>
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
 #include &lt;linux/device.h&gt;
 #include &lt;linux/moduleparam.h&gt;
 
<span class="p_chunk">@@ -116,6 +116,7 @@</span> <span class="p_context"> enum ep0_state {</span>
 struct dev_data {
 	spinlock_t			lock;
 	refcount_t			count;
<span class="p_add">+	int				udc_usage;</span>
 	enum ep0_state			state;		/* P: lock */
 	struct usb_gadgetfs_event	event [N_EVENT];
 	unsigned			ev_next;
<span class="p_chunk">@@ -513,9 +514,9 @@</span> <span class="p_context"> static void ep_aio_complete(struct usb_ep *ep, struct usb_request *req)</span>
 		INIT_WORK(&amp;priv-&gt;work, ep_user_copy_worker);
 		schedule_work(&amp;priv-&gt;work);
 	}
<span class="p_del">-	spin_unlock(&amp;epdata-&gt;dev-&gt;lock);</span>
 
 	usb_ep_free_request(ep, req);
<span class="p_add">+	spin_unlock(&amp;epdata-&gt;dev-&gt;lock);</span>
 	put_ep(epdata);
 }
 
<span class="p_chunk">@@ -939,9 +940,11 @@</span> <span class="p_context"> ep0_read (struct file *fd, char __user *buf, size_t len, loff_t *ptr)</span>
 			struct usb_request	*req = dev-&gt;req;
 
 			if ((retval = setup_req (ep, req, 0)) == 0) {
<span class="p_add">+				++dev-&gt;udc_usage;</span>
 				spin_unlock_irq (&amp;dev-&gt;lock);
 				retval = usb_ep_queue (ep, req, GFP_KERNEL);
 				spin_lock_irq (&amp;dev-&gt;lock);
<span class="p_add">+				--dev-&gt;udc_usage;</span>
 			}
 			dev-&gt;state = STATE_DEV_CONNECTED;
 
<span class="p_chunk">@@ -983,11 +986,14 @@</span> <span class="p_context"> ep0_read (struct file *fd, char __user *buf, size_t len, loff_t *ptr)</span>
 				retval = -EIO;
 			else {
 				len = min (len, (size_t)dev-&gt;req-&gt;actual);
<span class="p_del">-// FIXME don&#39;t call this with the spinlock held ...</span>
<span class="p_add">+				++dev-&gt;udc_usage;</span>
<span class="p_add">+				spin_unlock_irq(&amp;dev-&gt;lock);</span>
 				if (copy_to_user (buf, dev-&gt;req-&gt;buf, len))
 					retval = -EFAULT;
 				else
 					retval = len;
<span class="p_add">+				spin_lock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+				--dev-&gt;udc_usage;</span>
 				clean_req (dev-&gt;gadget-&gt;ep0, dev-&gt;req);
 				/* NOTE userspace can&#39;t yet choose to stall */
 			}
<span class="p_chunk">@@ -1131,6 +1137,7 @@</span> <span class="p_context"> ep0_write (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)</span>
 			retval = setup_req (dev-&gt;gadget-&gt;ep0, dev-&gt;req, len);
 			if (retval == 0) {
 				dev-&gt;state = STATE_DEV_CONNECTED;
<span class="p_add">+				++dev-&gt;udc_usage;</span>
 				spin_unlock_irq (&amp;dev-&gt;lock);
 				if (copy_from_user (dev-&gt;req-&gt;buf, buf, len))
 					retval = -EFAULT;
<span class="p_chunk">@@ -1142,6 +1149,7 @@</span> <span class="p_context"> ep0_write (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)</span>
 						GFP_KERNEL);
 				}
 				spin_lock_irq(&amp;dev-&gt;lock);
<span class="p_add">+				--dev-&gt;udc_usage;</span>
 				if (retval &lt; 0) {
 					clean_req (dev-&gt;gadget-&gt;ep0, dev-&gt;req);
 				} else
<span class="p_chunk">@@ -1243,9 +1251,21 @@</span> <span class="p_context"> static long dev_ioctl (struct file *fd, unsigned code, unsigned long value)</span>
 	struct usb_gadget	*gadget = dev-&gt;gadget;
 	long ret = -ENOTTY;
 
<span class="p_del">-	if (gadget-&gt;ops-&gt;ioctl)</span>
<span class="p_add">+	spin_lock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+	if (dev-&gt;state == STATE_DEV_OPENED ||</span>
<span class="p_add">+			dev-&gt;state == STATE_DEV_UNBOUND) {</span>
<span class="p_add">+		/* Not bound to a UDC */</span>
<span class="p_add">+	} else if (gadget-&gt;ops-&gt;ioctl) {</span>
<span class="p_add">+		++dev-&gt;udc_usage;</span>
<span class="p_add">+		spin_unlock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+</span>
 		ret = gadget-&gt;ops-&gt;ioctl (gadget, code, value);
 
<span class="p_add">+		spin_lock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+		--dev-&gt;udc_usage;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -1463,10 +1483,12 @@</span> <span class="p_context"> gadgetfs_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)</span>
 				if (value &lt; 0)
 					break;
 
<span class="p_add">+				++dev-&gt;udc_usage;</span>
 				spin_unlock (&amp;dev-&gt;lock);
 				value = usb_ep_queue (gadget-&gt;ep0, dev-&gt;req,
 							GFP_KERNEL);
 				spin_lock (&amp;dev-&gt;lock);
<span class="p_add">+				--dev-&gt;udc_usage;</span>
 				if (value &lt; 0) {
 					clean_req (gadget-&gt;ep0, dev-&gt;req);
 					break;
<span class="p_chunk">@@ -1490,8 +1512,12 @@</span> <span class="p_context"> gadgetfs_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)</span>
 		req-&gt;length = value;
 		req-&gt;zero = value &lt; w_length;
 
<span class="p_add">+		++dev-&gt;udc_usage;</span>
 		spin_unlock (&amp;dev-&gt;lock);
 		value = usb_ep_queue (gadget-&gt;ep0, req, GFP_KERNEL);
<span class="p_add">+		spin_lock(&amp;dev-&gt;lock);</span>
<span class="p_add">+		--dev-&gt;udc_usage;</span>
<span class="p_add">+		spin_unlock(&amp;dev-&gt;lock);</span>
 		if (value &lt; 0) {
 			DBG (dev, &quot;ep_queue --&gt; %d\n&quot;, value);
 			req-&gt;status = 0;
<span class="p_chunk">@@ -1518,21 +1544,24 @@</span> <span class="p_context"> static void destroy_ep_files (struct dev_data *dev)</span>
 		/* break link to FS */
 		ep = list_first_entry (&amp;dev-&gt;epfiles, struct ep_data, epfiles);
 		list_del_init (&amp;ep-&gt;epfiles);
<span class="p_add">+		spin_unlock_irq (&amp;dev-&gt;lock);</span>
<span class="p_add">+</span>
 		dentry = ep-&gt;dentry;
 		ep-&gt;dentry = NULL;
 		parent = d_inode(dentry-&gt;d_parent);
 
 		/* break link to controller */
<span class="p_add">+		mutex_lock(&amp;ep-&gt;lock);</span>
 		if (ep-&gt;state == STATE_EP_ENABLED)
 			(void) usb_ep_disable (ep-&gt;ep);
 		ep-&gt;state = STATE_EP_UNBOUND;
 		usb_ep_free_request (ep-&gt;ep, ep-&gt;req);
 		ep-&gt;ep = NULL;
<span class="p_add">+		mutex_unlock(&amp;ep-&gt;lock);</span>
<span class="p_add">+</span>
 		wake_up (&amp;ep-&gt;wait);
 		put_ep (ep);
 
<span class="p_del">-		spin_unlock_irq (&amp;dev-&gt;lock);</span>
<span class="p_del">-</span>
 		/* break link to dcache */
 		inode_lock(parent);
 		d_delete (dentry);
<span class="p_chunk">@@ -1603,6 +1632,11 @@</span> <span class="p_context"> gadgetfs_unbind (struct usb_gadget *gadget)</span>
 
 	spin_lock_irq (&amp;dev-&gt;lock);
 	dev-&gt;state = STATE_DEV_UNBOUND;
<span class="p_add">+	while (dev-&gt;udc_usage &gt; 0) {</span>
<span class="p_add">+		spin_unlock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+		usleep_range(1000, 2000);</span>
<span class="p_add">+		spin_lock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+	}</span>
 	spin_unlock_irq (&amp;dev-&gt;lock);
 
 	destroy_ep_files (dev);
<span class="p_header">diff --git a/drivers/usb/gadget/legacy/mass_storage.c b/drivers/usb/gadget/legacy/mass_storage.c</span>
<span class="p_header">index e99ab57ee3e5..fcba59782f26 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/legacy/mass_storage.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/legacy/mass_storage.c</span>
<span class="p_chunk">@@ -107,15 +107,6 @@</span> <span class="p_context"> static unsigned int fsg_num_buffers = CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS;</span>
 
 FSG_MODULE_PARAMETERS(/* no prefix */, mod_data);
 
<span class="p_del">-static unsigned long msg_registered;</span>
<span class="p_del">-static void msg_cleanup(void);</span>
<span class="p_del">-</span>
<span class="p_del">-static int msg_thread_exits(struct fsg_common *common)</span>
<span class="p_del">-{</span>
<span class="p_del">-	msg_cleanup();</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int msg_do_config(struct usb_configuration *c)
 {
 	struct fsg_opts *opts;
<span class="p_chunk">@@ -154,9 +145,6 @@</span> <span class="p_context"> static struct usb_configuration msg_config_driver = {</span>
 
 static int msg_bind(struct usb_composite_dev *cdev)
 {
<span class="p_del">-	static const struct fsg_operations ops = {</span>
<span class="p_del">-		.thread_exits = msg_thread_exits,</span>
<span class="p_del">-	};</span>
 	struct fsg_opts *opts;
 	struct fsg_config config;
 	int status;
<span class="p_chunk">@@ -173,8 +161,6 @@</span> <span class="p_context"> static int msg_bind(struct usb_composite_dev *cdev)</span>
 	if (status)
 		goto fail;
 
<span class="p_del">-	fsg_common_set_ops(opts-&gt;common, &amp;ops);</span>
<span class="p_del">-</span>
 	status = fsg_common_set_cdev(opts-&gt;common, cdev, config.can_stall);
 	if (status)
 		goto fail_set_cdev;
<span class="p_chunk">@@ -256,18 +242,12 @@</span> <span class="p_context"> MODULE_LICENSE(&quot;GPL&quot;);</span>
 
 static int __init msg_init(void)
 {
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = usb_composite_probe(&amp;msg_driver);</span>
<span class="p_del">-	set_bit(0, &amp;msg_registered);</span>
<span class="p_del">-</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return usb_composite_probe(&amp;msg_driver);</span>
 }
 module_init(msg_init);
 
<span class="p_del">-static void msg_cleanup(void)</span>
<span class="p_add">+static void __exit msg_cleanup(void)</span>
 {
<span class="p_del">-	if (test_and_clear_bit(0, &amp;msg_registered))</span>
<span class="p_del">-		usb_composite_unregister(&amp;msg_driver);</span>
<span class="p_add">+	usb_composite_unregister(&amp;msg_driver);</span>
 }
 module_exit(msg_cleanup);
<span class="p_header">diff --git a/drivers/usb/gadget/udc/atmel_usba_udc.c b/drivers/usb/gadget/udc/atmel_usba_udc.c</span>
<span class="p_header">index 98d71400f8a1..a884c022df7a 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/atmel_usba_udc.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/atmel_usba_udc.c</span>
<span class="p_chunk">@@ -29,6 +29,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/of_gpio.h&gt;
 
 #include &quot;atmel_usba_udc.h&quot;
<span class="p_add">+#define USBA_VBUS_IRQFLAGS (IRQF_ONESHOT \</span>
<span class="p_add">+			   | IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING)</span>
 
 #ifdef CONFIG_USB_GADGET_DEBUG_FS
 #include &lt;linux/debugfs.h&gt;
<span class="p_chunk">@@ -2361,7 +2363,7 @@</span> <span class="p_context"> static int usba_udc_probe(struct platform_device *pdev)</span>
 					IRQ_NOAUTOEN);
 			ret = devm_request_threaded_irq(&amp;pdev-&gt;dev,
 					gpio_to_irq(udc-&gt;vbus_pin), NULL,
<span class="p_del">-					usba_vbus_irq_thread, IRQF_ONESHOT,</span>
<span class="p_add">+					usba_vbus_irq_thread, USBA_VBUS_IRQFLAGS,</span>
 					&quot;atmel_usba_udc&quot;, udc);
 			if (ret) {
 				udc-&gt;vbus_pin = -ENODEV;
<span class="p_header">diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c</span>
<span class="p_header">index e6f04eee95c4..63c5fe6f7bd4 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/core.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/core.c</span>
<span class="p_chunk">@@ -1314,8 +1314,7 @@</span> <span class="p_context"> static int udc_bind_to_driver(struct usb_udc *udc, struct usb_gadget_driver *dri</span>
 	udc-&gt;dev.driver = &amp;driver-&gt;driver;
 	udc-&gt;gadget-&gt;dev.driver = &amp;driver-&gt;driver;
 
<span class="p_del">-	if (driver-&gt;max_speed &lt; udc-&gt;gadget-&gt;max_speed)</span>
<span class="p_del">-		usb_gadget_udc_set_speed(udc, driver-&gt;max_speed);</span>
<span class="p_add">+	usb_gadget_udc_set_speed(udc, driver-&gt;max_speed);</span>
 
 	ret = driver-&gt;bind(udc-&gt;gadget, driver);
 	if (ret)
<span class="p_header">diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_header">index 3c3760315910..374f85f612d9 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_chunk">@@ -237,6 +237,8 @@</span> <span class="p_context"> struct dummy_hcd {</span>
 
 	struct usb_device		*udev;
 	struct list_head		urbp_list;
<span class="p_add">+	struct urbp			*next_frame_urbp;</span>
<span class="p_add">+</span>
 	u32				stream_en_ep;
 	u8				num_stream[30 / 2];
 
<span class="p_chunk">@@ -253,11 +255,13 @@</span> <span class="p_context"> struct dummy {</span>
 	 */
 	struct dummy_ep			ep[DUMMY_ENDPOINTS];
 	int				address;
<span class="p_add">+	int				callback_usage;</span>
 	struct usb_gadget		gadget;
 	struct usb_gadget_driver	*driver;
 	struct dummy_request		fifo_req;
 	u8				fifo_buf[FIFO_SIZE];
 	u16				devstatus;
<span class="p_add">+	unsigned			ints_enabled:1;</span>
 	unsigned			udc_suspended:1;
 	unsigned			pullup:1;
 
<span class="p_chunk">@@ -440,18 +444,27 @@</span> <span class="p_context"> static void set_link_state(struct dummy_hcd *dum_hcd)</span>
 				(~dum_hcd-&gt;old_status) &amp; dum_hcd-&gt;port_status;
 
 		/* Report reset and disconnect events to the driver */
<span class="p_del">-		if (dum-&gt;driver &amp;&amp; (disconnect || reset)) {</span>
<span class="p_add">+		if (dum-&gt;ints_enabled &amp;&amp; (disconnect || reset)) {</span>
 			stop_activity(dum);
<span class="p_add">+			++dum-&gt;callback_usage;</span>
<span class="p_add">+			spin_unlock(&amp;dum-&gt;lock);</span>
 			if (reset)
 				usb_gadget_udc_reset(&amp;dum-&gt;gadget, dum-&gt;driver);
 			else
 				dum-&gt;driver-&gt;disconnect(&amp;dum-&gt;gadget);
<span class="p_add">+			spin_lock(&amp;dum-&gt;lock);</span>
<span class="p_add">+			--dum-&gt;callback_usage;</span>
 		}
<span class="p_del">-	} else if (dum_hcd-&gt;active != dum_hcd-&gt;old_active) {</span>
<span class="p_add">+	} else if (dum_hcd-&gt;active != dum_hcd-&gt;old_active &amp;&amp;</span>
<span class="p_add">+			dum-&gt;ints_enabled) {</span>
<span class="p_add">+		++dum-&gt;callback_usage;</span>
<span class="p_add">+		spin_unlock(&amp;dum-&gt;lock);</span>
 		if (dum_hcd-&gt;old_active &amp;&amp; dum-&gt;driver-&gt;suspend)
 			dum-&gt;driver-&gt;suspend(&amp;dum-&gt;gadget);
 		else if (!dum_hcd-&gt;old_active &amp;&amp;  dum-&gt;driver-&gt;resume)
 			dum-&gt;driver-&gt;resume(&amp;dum-&gt;gadget);
<span class="p_add">+		spin_lock(&amp;dum-&gt;lock);</span>
<span class="p_add">+		--dum-&gt;callback_usage;</span>
 	}
 
 	dum_hcd-&gt;old_status = dum_hcd-&gt;port_status;
<span class="p_chunk">@@ -972,8 +985,11 @@</span> <span class="p_context"> static int dummy_udc_start(struct usb_gadget *g,</span>
 	 * can&#39;t enumerate without help from the driver we&#39;re binding.
 	 */
 
<span class="p_add">+	spin_lock_irq(&amp;dum-&gt;lock);</span>
 	dum-&gt;devstatus = 0;
 	dum-&gt;driver = driver;
<span class="p_add">+	dum-&gt;ints_enabled = 1;</span>
<span class="p_add">+	spin_unlock_irq(&amp;dum-&gt;lock);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -984,6 +1000,16 @@</span> <span class="p_context"> static int dummy_udc_stop(struct usb_gadget *g)</span>
 	struct dummy		*dum = dum_hcd-&gt;dum;
 
 	spin_lock_irq(&amp;dum-&gt;lock);
<span class="p_add">+	dum-&gt;ints_enabled = 0;</span>
<span class="p_add">+	stop_activity(dum);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* emulate synchronize_irq(): wait for callbacks to finish */</span>
<span class="p_add">+	while (dum-&gt;callback_usage &gt; 0) {</span>
<span class="p_add">+		spin_unlock_irq(&amp;dum-&gt;lock);</span>
<span class="p_add">+		usleep_range(1000, 2000);</span>
<span class="p_add">+		spin_lock_irq(&amp;dum-&gt;lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	dum-&gt;driver = NULL;
 	spin_unlock_irq(&amp;dum-&gt;lock);
 
<span class="p_chunk">@@ -1037,7 +1063,12 @@</span> <span class="p_context"> static int dummy_udc_probe(struct platform_device *pdev)</span>
 	memzero_explicit(&amp;dum-&gt;gadget, sizeof(struct usb_gadget));
 	dum-&gt;gadget.name = gadget_name;
 	dum-&gt;gadget.ops = &amp;dummy_ops;
<span class="p_del">-	dum-&gt;gadget.max_speed = USB_SPEED_SUPER;</span>
<span class="p_add">+	if (mod_data.is_super_speed)</span>
<span class="p_add">+		dum-&gt;gadget.max_speed = USB_SPEED_SUPER;</span>
<span class="p_add">+	else if (mod_data.is_high_speed)</span>
<span class="p_add">+		dum-&gt;gadget.max_speed = USB_SPEED_HIGH;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		dum-&gt;gadget.max_speed = USB_SPEED_FULL;</span>
 
 	dum-&gt;gadget.dev.parent = &amp;pdev-&gt;dev;
 	init_dummy_udc_hw(dum);
<span class="p_chunk">@@ -1246,6 +1277,8 @@</span> <span class="p_context"> static int dummy_urb_enqueue(</span>
 
 	list_add_tail(&amp;urbp-&gt;urbp_list, &amp;dum_hcd-&gt;urbp_list);
 	urb-&gt;hcpriv = urbp;
<span class="p_add">+	if (!dum_hcd-&gt;next_frame_urbp)</span>
<span class="p_add">+		dum_hcd-&gt;next_frame_urbp = urbp;</span>
 	if (usb_pipetype(urb-&gt;pipe) == PIPE_CONTROL)
 		urb-&gt;error_count = 1;		/* mark as a new urb */
 
<span class="p_chunk">@@ -1521,6 +1554,8 @@</span> <span class="p_context"> static struct dummy_ep *find_endpoint(struct dummy *dum, u8 address)</span>
 	if (!is_active((dum-&gt;gadget.speed == USB_SPEED_SUPER ?
 			dum-&gt;ss_hcd : dum-&gt;hs_hcd)))
 		return NULL;
<span class="p_add">+	if (!dum-&gt;ints_enabled)</span>
<span class="p_add">+		return NULL;</span>
 	if ((address &amp; ~USB_DIR_IN) == 0)
 		return &amp;dum-&gt;ep[0];
 	for (i = 1; i &lt; DUMMY_ENDPOINTS; i++) {
<span class="p_chunk">@@ -1762,6 +1797,7 @@</span> <span class="p_context"> static void dummy_timer(unsigned long _dum_hcd)</span>
 		spin_unlock_irqrestore(&amp;dum-&gt;lock, flags);
 		return;
 	}
<span class="p_add">+	dum_hcd-&gt;next_frame_urbp = NULL;</span>
 
 	for (i = 0; i &lt; DUMMY_ENDPOINTS; i++) {
 		if (!ep_info[i].name)
<span class="p_chunk">@@ -1778,6 +1814,10 @@</span> <span class="p_context"> static void dummy_timer(unsigned long _dum_hcd)</span>
 		int			type;
 		int			status = -EINPROGRESS;
 
<span class="p_add">+		/* stop when we reach URBs queued after the timer interrupt */</span>
<span class="p_add">+		if (urbp == dum_hcd-&gt;next_frame_urbp)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
 		urb = urbp-&gt;urb;
 		if (urb-&gt;unlinked)
 			goto return_urb;
<span class="p_chunk">@@ -1857,10 +1897,12 @@</span> <span class="p_context"> static void dummy_timer(unsigned long _dum_hcd)</span>
 			 * until setup() returns; no reentrancy issues etc.
 			 */
 			if (value &gt; 0) {
<span class="p_add">+				++dum-&gt;callback_usage;</span>
 				spin_unlock(&amp;dum-&gt;lock);
 				value = dum-&gt;driver-&gt;setup(&amp;dum-&gt;gadget,
 						&amp;setup);
 				spin_lock(&amp;dum-&gt;lock);
<span class="p_add">+				--dum-&gt;callback_usage;</span>
 
 				if (value &gt;= 0) {
 					/* no delays (max 64KB data stage) */
<span class="p_chunk">@@ -2561,8 +2603,6 @@</span> <span class="p_context"> static struct hc_driver dummy_hcd = {</span>
 	.product_desc =		&quot;Dummy host controller&quot;,
 	.hcd_priv_size =	sizeof(struct dummy_hcd),
 
<span class="p_del">-	.flags =		HCD_USB3 | HCD_SHARED,</span>
<span class="p_del">-</span>
 	.reset =		dummy_setup,
 	.start =		dummy_start,
 	.stop =			dummy_stop,
<span class="p_chunk">@@ -2591,8 +2631,12 @@</span> <span class="p_context"> static int dummy_hcd_probe(struct platform_device *pdev)</span>
 	dev_info(&amp;pdev-&gt;dev, &quot;%s, driver &quot; DRIVER_VERSION &quot;\n&quot;, driver_desc);
 	dum = *((void **)dev_get_platdata(&amp;pdev-&gt;dev));
 
<span class="p_del">-	if (!mod_data.is_super_speed)</span>
<span class="p_add">+	if (mod_data.is_super_speed)</span>
<span class="p_add">+		dummy_hcd.flags = HCD_USB3 | HCD_SHARED;</span>
<span class="p_add">+	else if (mod_data.is_high_speed)</span>
 		dummy_hcd.flags = HCD_USB2;
<span class="p_add">+	else</span>
<span class="p_add">+		dummy_hcd.flags = HCD_USB11;</span>
 	hs_hcd = usb_create_hcd(&amp;dummy_hcd, &amp;pdev-&gt;dev, dev_name(&amp;pdev-&gt;dev));
 	if (!hs_hcd)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/usb/gadget/udc/renesas_usb3.c b/drivers/usb/gadget/udc/renesas_usb3.c</span>
<span class="p_header">index e1de8fe599a3..89ce1eddfe77 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/renesas_usb3.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/renesas_usb3.c</span>
<span class="p_chunk">@@ -1032,7 +1032,7 @@</span> <span class="p_context"> static int usb3_write_pipe(struct renesas_usb3_ep *usb3_ep,</span>
 			usb3_ep-&gt;ep.maxpacket);
 	u8 *buf = usb3_req-&gt;req.buf + usb3_req-&gt;req.actual;
 	u32 tmp = 0;
<span class="p_del">-	bool is_last;</span>
<span class="p_add">+	bool is_last = !len ? true : false;</span>
 
 	if (usb3_wait_pipe_status(usb3_ep, PX_STA_BUFSTS) &lt; 0)
 		return -EBUSY;
<span class="p_chunk">@@ -1053,7 +1053,8 @@</span> <span class="p_context"> static int usb3_write_pipe(struct renesas_usb3_ep *usb3_ep,</span>
 		usb3_write(usb3, tmp, fifo_reg);
 	}
 
<span class="p_del">-	is_last = usb3_is_transfer_complete(usb3_ep, usb3_req);</span>
<span class="p_add">+	if (!is_last)</span>
<span class="p_add">+		is_last = usb3_is_transfer_complete(usb3_ep, usb3_req);</span>
 	/* Send the data */
 	usb3_set_px_con_send(usb3_ep, len, is_last);
 
<span class="p_chunk">@@ -1144,7 +1145,8 @@</span> <span class="p_context"> static void usb3_start_pipe0(struct renesas_usb3_ep *usb3_ep,</span>
 		usb3_set_p0_con_for_ctrl_read_data(usb3);
 	} else {
 		usb3_clear_bit(usb3, P0_MOD_DIR, USB3_P0_MOD);
<span class="p_del">-		usb3_set_p0_con_for_ctrl_write_data(usb3);</span>
<span class="p_add">+		if (usb3_req-&gt;req.length)</span>
<span class="p_add">+			usb3_set_p0_con_for_ctrl_write_data(usb3);</span>
 	}
 
 	usb3_p0_xfer(usb3_ep, usb3_req);
<span class="p_chunk">@@ -2047,7 +2049,16 @@</span> <span class="p_context"> static u32 usb3_calc_ramarea(int ram_size)</span>
 static u32 usb3_calc_rammap_val(struct renesas_usb3_ep *usb3_ep,
 				const struct usb_endpoint_descriptor *desc)
 {
<span class="p_del">-	return usb3_ep-&gt;rammap_val | PN_RAMMAP_MPKT(usb_endpoint_maxp(desc));</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	const u32 max_packet_array[] = {8, 16, 32, 64, 512};</span>
<span class="p_add">+	u32 mpkt = PN_RAMMAP_MPKT(1024);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(max_packet_array); i++) {</span>
<span class="p_add">+		if (usb_endpoint_maxp(desc) &lt;= max_packet_array[i])</span>
<span class="p_add">+			mpkt = PN_RAMMAP_MPKT(max_packet_array[i]);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return usb3_ep-&gt;rammap_val | mpkt;</span>
 }
 
 static int usb3_enable_pipe_n(struct renesas_usb3_ep *usb3_ep,
<span class="p_header">diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c</span>
<span class="p_header">index 658d9d1f9ea3..6dda3623a276 100644</span>
<span class="p_header">--- a/drivers/usb/host/pci-quirks.c</span>
<span class="p_header">+++ b/drivers/usb/host/pci-quirks.c</span>
<span class="p_chunk">@@ -447,7 +447,7 @@</span> <span class="p_context"> static int usb_asmedia_wait_write(struct pci_dev *pdev)</span>
 		if ((value &amp; ASMT_CONTROL_WRITE_BIT) == 0)
 			return 0;
 
<span class="p_del">-		usleep_range(40, 60);</span>
<span class="p_add">+		udelay(50);</span>
 	}
 
 	dev_warn(&amp;pdev-&gt;dev, &quot;%s: check_write_ready timeout&quot;, __func__);
<span class="p_chunk">@@ -1022,7 +1022,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(usb_disable_xhci_ports);</span>
  *
  * Takes care of the handoff between the Pre-OS (i.e. BIOS) and the OS.
  * It signals to the BIOS that the OS wants control of the host controller,
<span class="p_del">- * and then waits 5 seconds for the BIOS to hand over control.</span>
<span class="p_add">+ * and then waits 1 second for the BIOS to hand over control.</span>
  * If we timeout, assume the BIOS is broken and take control anyway.
  */
 static void quirk_usb_handoff_xhci(struct pci_dev *pdev)
<span class="p_chunk">@@ -1069,9 +1069,9 @@</span> <span class="p_context"> static void quirk_usb_handoff_xhci(struct pci_dev *pdev)</span>
 	if (val &amp; XHCI_HC_BIOS_OWNED) {
 		writel(val | XHCI_HC_OS_OWNED, base + ext_cap_offset);
 
<span class="p_del">-		/* Wait for 5 seconds with 10 microsecond polling interval */</span>
<span class="p_add">+		/* Wait for 1 second with 10 microsecond polling interval */</span>
 		timeout = handshake(base + ext_cap_offset, XHCI_HC_BIOS_OWNED,
<span class="p_del">-				0, 5000, 10);</span>
<span class="p_add">+				0, 1000000, 10);</span>
 
 		/* Assume a buggy BIOS and take HC ownership anyway */
 		if (timeout) {
<span class="p_chunk">@@ -1100,7 +1100,7 @@</span> <span class="p_context"> static void quirk_usb_handoff_xhci(struct pci_dev *pdev)</span>
 	 * operational or runtime registers.  Wait 5 seconds and no more.
 	 */
 	timeout = handshake(op_reg_base + XHCI_STS_OFFSET, XHCI_STS_CNR, 0,
<span class="p_del">-			5000, 10);</span>
<span class="p_add">+			5000000, 10);</span>
 	/* Assume a buggy HC and start HC initialization anyway */
 	if (timeout) {
 		val = readl(op_reg_base + XHCI_STS_OFFSET);
<span class="p_header">diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">index 00721e8807ab..950dee33bfcc 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-hub.c</span>
<span class="p_chunk">@@ -112,7 +112,7 @@</span> <span class="p_context"> static int xhci_create_usb3_bos_desc(struct xhci_hcd *xhci, char *buf,</span>
 
 	/* If PSI table exists, add the custom speed attributes from it */
 	if (usb3_1 &amp;&amp; xhci-&gt;usb3_rhub.psi_count) {
<span class="p_del">-		u32 ssp_cap_base, bm_attrib, psi;</span>
<span class="p_add">+		u32 ssp_cap_base, bm_attrib, psi, psi_mant, psi_exp;</span>
 		int offset;
 
 		ssp_cap_base = USB_DT_BOS_SIZE + USB_DT_USB_SS_CAP_SIZE;
<span class="p_chunk">@@ -139,6 +139,15 @@</span> <span class="p_context"> static int xhci_create_usb3_bos_desc(struct xhci_hcd *xhci, char *buf,</span>
 		for (i = 0; i &lt; xhci-&gt;usb3_rhub.psi_count; i++) {
 			psi = xhci-&gt;usb3_rhub.psi[i];
 			psi &amp;= ~USB_SSP_SUBLINK_SPEED_RSVD;
<span class="p_add">+			psi_exp = XHCI_EXT_PORT_PSIE(psi);</span>
<span class="p_add">+			psi_mant = XHCI_EXT_PORT_PSIM(psi);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* Shift to Gbps and set SSP Link BIT(14) if 10Gpbs */</span>
<span class="p_add">+			for (; psi_exp &lt; 3; psi_exp++)</span>
<span class="p_add">+				psi_mant /= 1000;</span>
<span class="p_add">+			if (psi_mant &gt;= 10)</span>
<span class="p_add">+				psi |= BIT(14);</span>
<span class="p_add">+</span>
 			if ((psi &amp; PLT_MASK) == PLT_SYM) {
 			/* Symmetric, create SSA RX and TX from one PSI entry */
 				put_unaligned_le32(psi, &amp;buf[offset]);
<span class="p_chunk">@@ -1473,9 +1482,6 @@</span> <span class="p_context"> int xhci_bus_suspend(struct usb_hcd *hcd)</span>
 				t2 |= PORT_WKOC_E | PORT_WKCONN_E;
 				t2 &amp;= ~PORT_WKDISC_E;
 			}
<span class="p_del">-			if ((xhci-&gt;quirks &amp; XHCI_U2_DISABLE_WAKE) &amp;&amp;</span>
<span class="p_del">-			    (hcd-&gt;speed &lt; HCD_USB3))</span>
<span class="p_del">-				t2 &amp;= ~PORT_WAKE_BITS;</span>
 		} else
 			t2 &amp;= ~PORT_WAKE_BITS;
 
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index 8071c8fdd15e..76f392954733 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -54,11 +54,6 @@</span> <span class="p_context"></span>
 #define PCI_DEVICE_ID_INTEL_APL_XHCI			0x5aa8
 #define PCI_DEVICE_ID_INTEL_DNV_XHCI			0x19d0
 
<span class="p_del">-#define PCI_DEVICE_ID_AMD_PROMONTORYA_4			0x43b9</span>
<span class="p_del">-#define PCI_DEVICE_ID_AMD_PROMONTORYA_3			0x43ba</span>
<span class="p_del">-#define PCI_DEVICE_ID_AMD_PROMONTORYA_2			0x43bb</span>
<span class="p_del">-#define PCI_DEVICE_ID_AMD_PROMONTORYA_1			0x43bc</span>
<span class="p_del">-</span>
 #define PCI_DEVICE_ID_ASMEDIA_1042A_XHCI		0x1142
 
 static const char hcd_name[] = &quot;xhci_hcd&quot;;
<span class="p_chunk">@@ -142,13 +137,6 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_AMD)
 		xhci-&gt;quirks |= XHCI_TRUST_TX_LENGTH;
 
<span class="p_del">-	if ((pdev-&gt;vendor == PCI_VENDOR_ID_AMD) &amp;&amp;</span>
<span class="p_del">-		((pdev-&gt;device == PCI_DEVICE_ID_AMD_PROMONTORYA_4) ||</span>
<span class="p_del">-		(pdev-&gt;device == PCI_DEVICE_ID_AMD_PROMONTORYA_3) ||</span>
<span class="p_del">-		(pdev-&gt;device == PCI_DEVICE_ID_AMD_PROMONTORYA_2) ||</span>
<span class="p_del">-		(pdev-&gt;device == PCI_DEVICE_ID_AMD_PROMONTORYA_1)))</span>
<span class="p_del">-		xhci-&gt;quirks |= XHCI_U2_DISABLE_WAKE;</span>
<span class="p_del">-</span>
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL) {
 		xhci-&gt;quirks |= XHCI_LPM_SUPPORT;
 		xhci-&gt;quirks |= XHCI_INTEL_HOST;
<span class="p_header">diff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c</span>
<span class="p_header">index c04144b25a67..208740771ff9 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-plat.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-plat.c</span>
<span class="p_chunk">@@ -186,14 +186,18 @@</span> <span class="p_context"> static int xhci_plat_probe(struct platform_device *pdev)</span>
 	 * 2. xhci_plat is child of a device from firmware (dwc3-plat)
 	 * 3. xhci_plat is grandchild of a pci device (dwc3-pci)
 	 */
<span class="p_del">-	sysdev = &amp;pdev-&gt;dev;</span>
<span class="p_del">-	if (sysdev-&gt;parent &amp;&amp; !sysdev-&gt;of_node &amp;&amp; sysdev-&gt;parent-&gt;of_node)</span>
<span class="p_del">-		sysdev = sysdev-&gt;parent;</span>
<span class="p_add">+	for (sysdev = &amp;pdev-&gt;dev; sysdev; sysdev = sysdev-&gt;parent) {</span>
<span class="p_add">+		if (is_of_node(sysdev-&gt;fwnode) ||</span>
<span class="p_add">+			is_acpi_device_node(sysdev-&gt;fwnode))</span>
<span class="p_add">+			break;</span>
 #ifdef CONFIG_PCI
<span class="p_del">-	else if (sysdev-&gt;parent &amp;&amp; sysdev-&gt;parent-&gt;parent &amp;&amp;</span>
<span class="p_del">-		 sysdev-&gt;parent-&gt;parent-&gt;bus == &amp;pci_bus_type)</span>
<span class="p_del">-		sysdev = sysdev-&gt;parent-&gt;parent;</span>
<span class="p_add">+		else if (sysdev-&gt;bus == &amp;pci_bus_type)</span>
<span class="p_add">+			break;</span>
 #endif
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!sysdev)</span>
<span class="p_add">+		sysdev = &amp;pdev-&gt;dev;</span>
 
 	/* Try to set 64-bit DMA first */
 	if (WARN_ON(!sysdev-&gt;dma_mask))
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index b2ff1ff1a02f..ee198ea47f49 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -1703,7 +1703,8 @@</span> <span class="p_context"> static int xhci_add_endpoint(struct usb_hcd *hcd, struct usb_device *udev,</span>
 	if (xhci-&gt;quirks &amp; XHCI_MTK_HOST) {
 		ret = xhci_mtk_add_ep_quirk(hcd, udev, ep);
 		if (ret &lt; 0) {
<span class="p_del">-			xhci_free_endpoint_ring(xhci, virt_dev, ep_index);</span>
<span class="p_add">+			xhci_ring_free(xhci, virt_dev-&gt;eps[ep_index].new_ring);</span>
<span class="p_add">+			virt_dev-&gt;eps[ep_index].new_ring = NULL;</span>
 			return ret;
 		}
 	}
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index e3e935291ed6..d7420bb9f2e2 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -728,6 +728,8 @@</span> <span class="p_context"> struct xhci_ep_ctx {</span>
 #define EP_MAXPSTREAMS(p)	(((p) &lt;&lt; 10) &amp; EP_MAXPSTREAMS_MASK)
 /* Endpoint is set up with a Linear Stream Array (vs. Secondary Stream Array) */
 #define	EP_HAS_LSA		(1 &lt;&lt; 15)
<span class="p_add">+/* hosts with LEC=1 use bits 31:24 as ESIT high bits. */</span>
<span class="p_add">+#define CTX_TO_MAX_ESIT_PAYLOAD_HI(p)	(((p) &gt;&gt; 24) &amp; 0xff)</span>
 
 /* ep_info2 bitmasks */
 /*
<span class="p_chunk">@@ -1674,7 +1676,7 @@</span> <span class="p_context"> struct xhci_bus_state {</span>
 
 static inline unsigned int hcd_index(struct usb_hcd *hcd)
 {
<span class="p_del">-	if (hcd-&gt;speed == HCD_USB3)</span>
<span class="p_add">+	if (hcd-&gt;speed &gt;= HCD_USB3)</span>
 		return 0;
 	else
 		return 1;
<span class="p_chunk">@@ -1819,7 +1821,7 @@</span> <span class="p_context"> struct xhci_hcd {</span>
 /* For controller with a broken Port Disable implementation */
 #define XHCI_BROKEN_PORT_PED	(1 &lt;&lt; 25)
 #define XHCI_LIMIT_ENDPOINT_INTERVAL_7	(1 &lt;&lt; 26)
<span class="p_del">-#define XHCI_U2_DISABLE_WAKE	(1 &lt;&lt; 27)</span>
<span class="p_add">+/* Reserved. It was XHCI_U2_DISABLE_WAKE */</span>
 #define XHCI_ASMEDIA_MODIFY_FLOWCONTROL	(1 &lt;&lt; 28)
 
 	unsigned int		num_active_eps;
<span class="p_chunk">@@ -2452,8 +2454,8 @@</span> <span class="p_context"> static inline const char *xhci_decode_ep_context(u32 info, u32 info2, u64 deq,</span>
 	u8 lsa;
 	u8 hid;
 
<span class="p_del">-	esit = EP_MAX_ESIT_PAYLOAD_HI(info) &lt;&lt; 16 |</span>
<span class="p_del">-		EP_MAX_ESIT_PAYLOAD_LO(tx_info);</span>
<span class="p_add">+	esit = CTX_TO_MAX_ESIT_PAYLOAD_HI(info) &lt;&lt; 16 |</span>
<span class="p_add">+		CTX_TO_MAX_ESIT_PAYLOAD(tx_info);</span>
 
 	ep_state = info &amp; EP_STATE_MASK;
 	max_pstr = info &amp; EP_MAXPSTREAMS_MASK;
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/fifo.c b/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_header">index d1af831f43eb..68f26904c316 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_chunk">@@ -282,11 +282,26 @@</span> <span class="p_context"> static void usbhsf_fifo_clear(struct usbhs_pipe *pipe,</span>
 			      struct usbhs_fifo *fifo)
 {
 	struct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);
<span class="p_add">+	int ret = 0;</span>
 
<span class="p_del">-	if (!usbhs_pipe_is_dcp(pipe))</span>
<span class="p_del">-		usbhsf_fifo_barrier(priv, fifo);</span>
<span class="p_add">+	if (!usbhs_pipe_is_dcp(pipe)) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * This driver checks the pipe condition first to avoid -EBUSY</span>
<span class="p_add">+		 * from usbhsf_fifo_barrier() with about 10 msec delay in</span>
<span class="p_add">+		 * the interrupt handler if the pipe is RX direction and empty.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (usbhs_pipe_is_dir_in(pipe))</span>
<span class="p_add">+			ret = usbhs_pipe_is_accessible(pipe);</span>
<span class="p_add">+		if (!ret)</span>
<span class="p_add">+			ret = usbhsf_fifo_barrier(priv, fifo);</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	usbhs_write(priv, fifo-&gt;ctr, BCLR);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * if non-DCP pipe, this driver should set BCLR when</span>
<span class="p_add">+	 * usbhsf_fifo_barrier() returns 0.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		usbhs_write(priv, fifo-&gt;ctr, BCLR);</span>
 }
 
 static int usbhsf_fifo_rcv_len(struct usbhs_priv *priv,
<span class="p_header">diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c</span>
<span class="p_header">index 1a59f335b063..a3ccb899df60 100644</span>
<span class="p_header">--- a/drivers/usb/storage/transport.c</span>
<span class="p_header">+++ b/drivers/usb/storage/transport.c</span>
<span class="p_chunk">@@ -834,13 +834,25 @@</span> <span class="p_context"> void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)</span>
 			if (result == USB_STOR_TRANSPORT_GOOD) {
 				srb-&gt;result = SAM_STAT_GOOD;
 				srb-&gt;sense_buffer[0] = 0x0;
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * ATA-passthru commands use sense data to report</span>
<span class="p_add">+			 * the command completion status, and often devices</span>
<span class="p_add">+			 * return Check Condition status when nothing is</span>
<span class="p_add">+			 * wrong.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			else if (srb-&gt;cmnd[0] == ATA_16 ||</span>
<span class="p_add">+					srb-&gt;cmnd[0] == ATA_12) {</span>
<span class="p_add">+				/* leave the data alone */</span>
<span class="p_add">+			}</span>
 
 			/*
 			 * If there was a problem, report an unspecified
 			 * hardware error to prevent the higher layers from
 			 * entering an infinite retry loop.
 			 */
<span class="p_del">-			} else {</span>
<span class="p_add">+			else {</span>
 				srb-&gt;result = DID_ERROR &lt;&lt; 16;
 				if ((sshdr.response_code &amp; 0x72) == 0x72)
 					srb-&gt;sense_buffer[1] = HARDWARE_ERROR;
<span class="p_header">diff --git a/drivers/usb/storage/uas-detect.h b/drivers/usb/storage/uas-detect.h</span>
<span class="p_header">index f58caa9e6a27..a155cd02bce2 100644</span>
<span class="p_header">--- a/drivers/usb/storage/uas-detect.h</span>
<span class="p_header">+++ b/drivers/usb/storage/uas-detect.h</span>
<span class="p_chunk">@@ -9,7 +9,8 @@</span> <span class="p_context"> static int uas_is_interface(struct usb_host_interface *intf)</span>
 		intf-&gt;desc.bInterfaceProtocol == USB_PR_UAS);
 }
 
<span class="p_del">-static int uas_find_uas_alt_setting(struct usb_interface *intf)</span>
<span class="p_add">+static struct usb_host_interface *uas_find_uas_alt_setting(</span>
<span class="p_add">+		struct usb_interface *intf)</span>
 {
 	int i;
 
<span class="p_chunk">@@ -17,10 +18,10 @@</span> <span class="p_context"> static int uas_find_uas_alt_setting(struct usb_interface *intf)</span>
 		struct usb_host_interface *alt = &amp;intf-&gt;altsetting[i];
 
 		if (uas_is_interface(alt))
<span class="p_del">-			return alt-&gt;desc.bAlternateSetting;</span>
<span class="p_add">+			return alt;</span>
 	}
 
<span class="p_del">-	return -ENODEV;</span>
<span class="p_add">+	return NULL;</span>
 }
 
 static int uas_find_endpoints(struct usb_host_interface *alt,
<span class="p_chunk">@@ -58,14 +59,14 @@</span> <span class="p_context"> static int uas_use_uas_driver(struct usb_interface *intf,</span>
 	struct usb_device *udev = interface_to_usbdev(intf);
 	struct usb_hcd *hcd = bus_to_hcd(udev-&gt;bus);
 	unsigned long flags = id-&gt;driver_info;
<span class="p_del">-	int r, alt;</span>
<span class="p_del">-</span>
<span class="p_add">+	struct usb_host_interface *alt;</span>
<span class="p_add">+	int r;</span>
 
 	alt = uas_find_uas_alt_setting(intf);
<span class="p_del">-	if (alt &lt; 0)</span>
<span class="p_add">+	if (!alt)</span>
 		return 0;
 
<span class="p_del">-	r = uas_find_endpoints(&amp;intf-&gt;altsetting[alt], eps);</span>
<span class="p_add">+	r = uas_find_endpoints(alt, eps);</span>
 	if (r &lt; 0)
 		return 0;
 
<span class="p_header">diff --git a/drivers/usb/storage/uas.c b/drivers/usb/storage/uas.c</span>
<span class="p_header">index 5ef014ba6ae8..9876af4ab64e 100644</span>
<span class="p_header">--- a/drivers/usb/storage/uas.c</span>
<span class="p_header">+++ b/drivers/usb/storage/uas.c</span>
<span class="p_chunk">@@ -873,14 +873,14 @@</span> <span class="p_context"> MODULE_DEVICE_TABLE(usb, uas_usb_ids);</span>
 static int uas_switch_interface(struct usb_device *udev,
 				struct usb_interface *intf)
 {
<span class="p_del">-	int alt;</span>
<span class="p_add">+	struct usb_host_interface *alt;</span>
 
 	alt = uas_find_uas_alt_setting(intf);
<span class="p_del">-	if (alt &lt; 0)</span>
<span class="p_del">-		return alt;</span>
<span class="p_add">+	if (!alt)</span>
<span class="p_add">+		return -ENODEV;</span>
 
<span class="p_del">-	return usb_set_interface(udev,</span>
<span class="p_del">-			intf-&gt;altsetting[0].desc.bInterfaceNumber, alt);</span>
<span class="p_add">+	return usb_set_interface(udev, alt-&gt;desc.bInterfaceNumber,</span>
<span class="p_add">+			alt-&gt;desc.bAlternateSetting);</span>
 }
 
 static int uas_configure_endpoints(struct uas_dev_info *devinfo)
<span class="p_header">diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">index 5a70c33ef0e0..eb06d88b41d6 100644</span>
<span class="p_header">--- a/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">+++ b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_chunk">@@ -1459,6 +1459,13 @@</span> <span class="p_context"> UNUSUAL_DEV( 0x0bc2, 0x3010, 0x0000, 0x0000,</span>
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_SANE_SENSE ),
 
<span class="p_add">+/* Reported by Kris Lindgren &lt;kris.lindgren@gmail.com&gt; */</span>
<span class="p_add">+UNUSUAL_DEV( 0x0bc2, 0x3332, 0x0000, 0x9999,</span>
<span class="p_add">+		&quot;Seagate&quot;,</span>
<span class="p_add">+		&quot;External&quot;,</span>
<span class="p_add">+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,</span>
<span class="p_add">+		US_FL_NO_WP_DETECT ),</span>
<span class="p_add">+</span>
 UNUSUAL_DEV(  0x0d49, 0x7310, 0x0000, 0x9999,
 		&quot;Maxtor&quot;,
 		&quot;USB to SATA&quot;,
<span class="p_header">diff --git a/drivers/uwb/hwa-rc.c b/drivers/uwb/hwa-rc.c</span>
<span class="p_header">index 35a1e777b449..9a53912bdfe9 100644</span>
<span class="p_header">--- a/drivers/uwb/hwa-rc.c</span>
<span class="p_header">+++ b/drivers/uwb/hwa-rc.c</span>
<span class="p_chunk">@@ -825,6 +825,8 @@</span> <span class="p_context"> static int hwarc_probe(struct usb_interface *iface,</span>
 
 	if (iface-&gt;cur_altsetting-&gt;desc.bNumEndpoints &lt; 1)
 		return -ENODEV;
<span class="p_add">+	if (!usb_endpoint_xfer_int(&amp;iface-&gt;cur_altsetting-&gt;endpoint[0].desc))</span>
<span class="p_add">+		return -ENODEV;</span>
 
 	result = -ENOMEM;
 	uwb_rc = uwb_rc_alloc();
<span class="p_header">diff --git a/drivers/uwb/uwbd.c b/drivers/uwb/uwbd.c</span>
<span class="p_header">index 01c20a260a8b..39dd4ef53c77 100644</span>
<span class="p_header">--- a/drivers/uwb/uwbd.c</span>
<span class="p_header">+++ b/drivers/uwb/uwbd.c</span>
<span class="p_chunk">@@ -302,18 +302,22 @@</span> <span class="p_context"> static int uwbd(void *param)</span>
 /** Start the UWB daemon */
 void uwbd_start(struct uwb_rc *rc)
 {
<span class="p_del">-	rc-&gt;uwbd.task = kthread_run(uwbd, rc, &quot;uwbd&quot;);</span>
<span class="p_del">-	if (rc-&gt;uwbd.task == NULL)</span>
<span class="p_add">+	struct task_struct *task = kthread_run(uwbd, rc, &quot;uwbd&quot;);</span>
<span class="p_add">+	if (IS_ERR(task)) {</span>
<span class="p_add">+		rc-&gt;uwbd.task = NULL;</span>
 		printk(KERN_ERR &quot;UWB: Cannot start management daemon; &quot;
 		       &quot;UWB won&#39;t work\n&quot;);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		rc-&gt;uwbd.task = task;</span>
 		rc-&gt;uwbd.pid = rc-&gt;uwbd.task-&gt;pid;
<span class="p_add">+	}</span>
 }
 
 /* Stop the UWB daemon and free any unprocessed events */
 void uwbd_stop(struct uwb_rc *rc)
 {
<span class="p_del">-	kthread_stop(rc-&gt;uwbd.task);</span>
<span class="p_add">+	if (rc-&gt;uwbd.task)</span>
<span class="p_add">+		kthread_stop(rc-&gt;uwbd.task);</span>
 	uwbd_flush(rc);
 }
 
<span class="p_header">diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.h</span>
<span class="p_header">index 3f3eb7b17cac..806eb85343fb 100644</span>
<span class="p_header">--- a/fs/btrfs/ctree.h</span>
<span class="p_header">+++ b/fs/btrfs/ctree.h</span>
<span class="p_chunk">@@ -723,7 +723,7 @@</span> <span class="p_context"> struct btrfs_delayed_root;</span>
  * Indicate that a whole-filesystem exclusive operation is running
  * (device replace, resize, device add/delete, balance)
  */
<span class="p_del">-#define BTRFS_FS_EXCL_OP			14</span>
<span class="p_add">+#define BTRFS_FS_EXCL_OP			16</span>
 
 struct btrfs_fs_info {
 	u8 fsid[BTRFS_FSID_SIZE];
<span class="p_header">diff --git a/fs/btrfs/extent_io.c b/fs/btrfs/extent_io.c</span>
<span class="p_header">index 0aff9b278c19..4aa3d4c27dfe 100644</span>
<span class="p_header">--- a/fs/btrfs/extent_io.c</span>
<span class="p_header">+++ b/fs/btrfs/extent_io.c</span>
<span class="p_chunk">@@ -2799,7 +2799,7 @@</span> <span class="p_context"> static int submit_extent_page(int op, int op_flags, struct extent_io_tree *tree,</span>
 		}
 	}
 
<span class="p_del">-	bio = btrfs_bio_alloc(bdev, sector &lt;&lt; 9);</span>
<span class="p_add">+	bio = btrfs_bio_alloc(bdev, (u64)sector &lt;&lt; 9);</span>
 	bio_add_page(bio, page, page_size, offset);
 	bio-&gt;bi_end_io = end_io_func;
 	bio-&gt;bi_private = tree;
<span class="p_header">diff --git a/fs/overlayfs/copy_up.c b/fs/overlayfs/copy_up.c</span>
<span class="p_header">index acb6f97deb97..196a07a87179 100644</span>
<span class="p_header">--- a/fs/overlayfs/copy_up.c</span>
<span class="p_header">+++ b/fs/overlayfs/copy_up.c</span>
<span class="p_chunk">@@ -561,10 +561,8 @@</span> <span class="p_context"> static int ovl_do_copy_up(struct ovl_copy_up_ctx *c)</span>
 		c-&gt;tmpfile = true;
 		err = ovl_copy_up_locked(c);
 	} else {
<span class="p_del">-		err = -EIO;</span>
<span class="p_del">-		if (lock_rename(c-&gt;workdir, c-&gt;destdir) != NULL) {</span>
<span class="p_del">-			pr_err(&quot;overlayfs: failed to lock workdir+upperdir\n&quot;);</span>
<span class="p_del">-		} else {</span>
<span class="p_add">+		err = ovl_lock_rename_workdir(c-&gt;workdir, c-&gt;destdir);</span>
<span class="p_add">+		if (!err) {</span>
 			err = ovl_copy_up_locked(c);
 			unlock_rename(c-&gt;workdir, c-&gt;destdir);
 		}
<span class="p_header">diff --git a/fs/overlayfs/dir.c b/fs/overlayfs/dir.c</span>
<span class="p_header">index 48b70e6490f3..9b97b35b39c8 100644</span>
<span class="p_header">--- a/fs/overlayfs/dir.c</span>
<span class="p_header">+++ b/fs/overlayfs/dir.c</span>
<span class="p_chunk">@@ -216,26 +216,6 @@</span> <span class="p_context"> static int ovl_create_upper(struct dentry *dentry, struct inode *inode,</span>
 	return err;
 }
 
<span class="p_del">-static int ovl_lock_rename_workdir(struct dentry *workdir,</span>
<span class="p_del">-				   struct dentry *upperdir)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* Workdir should not be the same as upperdir */</span>
<span class="p_del">-	if (workdir == upperdir)</span>
<span class="p_del">-		goto err;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Workdir should not be subdir of upperdir and vice versa */</span>
<span class="p_del">-	if (lock_rename(workdir, upperdir) != NULL)</span>
<span class="p_del">-		goto err_unlock;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-err_unlock:</span>
<span class="p_del">-	unlock_rename(workdir, upperdir);</span>
<span class="p_del">-err:</span>
<span class="p_del">-	pr_err(&quot;overlayfs: failed to lock workdir+upperdir\n&quot;);</span>
<span class="p_del">-	return -EIO;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static struct dentry *ovl_clear_empty(struct dentry *dentry,
 				      struct list_head *list)
 {
<span class="p_header">diff --git a/fs/overlayfs/namei.c b/fs/overlayfs/namei.c</span>
<span class="p_header">index 8aef2b304b2d..9deec68075dc 100644</span>
<span class="p_header">--- a/fs/overlayfs/namei.c</span>
<span class="p_header">+++ b/fs/overlayfs/namei.c</span>
<span class="p_chunk">@@ -506,6 +506,7 @@</span> <span class="p_context"> static struct dentry *ovl_lookup_index(struct dentry *dentry,</span>
 
 	index = lookup_one_len_unlocked(name.name, ofs-&gt;indexdir, name.len);
 	if (IS_ERR(index)) {
<span class="p_add">+		err = PTR_ERR(index);</span>
 		pr_warn_ratelimited(&quot;overlayfs: failed inode index lookup (ino=%lu, key=%*s, err=%i);\n&quot;
 				    &quot;overlayfs: mount with &#39;-o index=off&#39; to disable inodes index.\n&quot;,
 				    d_inode(origin)-&gt;i_ino, name.len, name.name,
<span class="p_header">diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h</span>
<span class="p_header">index e927a62c97ae..f57f47742f5f 100644</span>
<span class="p_header">--- a/fs/overlayfs/overlayfs.h</span>
<span class="p_header">+++ b/fs/overlayfs/overlayfs.h</span>
<span class="p_chunk">@@ -234,6 +234,7 @@</span> <span class="p_context"> bool ovl_inuse_trylock(struct dentry *dentry);</span>
 void ovl_inuse_unlock(struct dentry *dentry);
 int ovl_nlink_start(struct dentry *dentry, bool *locked);
 void ovl_nlink_end(struct dentry *dentry, bool locked);
<span class="p_add">+int ovl_lock_rename_workdir(struct dentry *workdir, struct dentry *upperdir);</span>
 
 static inline bool ovl_is_impuredir(struct dentry *dentry)
 {
<span class="p_header">diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h</span>
<span class="p_header">index 878a750986dd..25d9b5adcd42 100644</span>
<span class="p_header">--- a/fs/overlayfs/ovl_entry.h</span>
<span class="p_header">+++ b/fs/overlayfs/ovl_entry.h</span>
<span class="p_chunk">@@ -37,6 +37,9 @@</span> <span class="p_context"> struct ovl_fs {</span>
 	bool noxattr;
 	/* sb common to all layers */
 	struct super_block *same_sb;
<span class="p_add">+	/* Did we take the inuse lock? */</span>
<span class="p_add">+	bool upperdir_locked;</span>
<span class="p_add">+	bool workdir_locked;</span>
 };
 
 /* private information held for every overlayfs dentry */
<span class="p_header">diff --git a/fs/overlayfs/readdir.c b/fs/overlayfs/readdir.c</span>
<span class="p_header">index 3d424a51cabb..74f7ead442f0 100644</span>
<span class="p_header">--- a/fs/overlayfs/readdir.c</span>
<span class="p_header">+++ b/fs/overlayfs/readdir.c</span>
<span class="p_chunk">@@ -672,6 +672,7 @@</span> <span class="p_context"> int ovl_indexdir_cleanup(struct dentry *dentry, struct vfsmount *mnt,</span>
 			 struct path *lowerstack, unsigned int numlower)
 {
 	int err;
<span class="p_add">+	struct dentry *index = NULL;</span>
 	struct inode *dir = dentry-&gt;d_inode;
 	struct path path = { .mnt = mnt, .dentry = dentry };
 	LIST_HEAD(list);
<span class="p_chunk">@@ -690,8 +691,6 @@</span> <span class="p_context"> int ovl_indexdir_cleanup(struct dentry *dentry, struct vfsmount *mnt,</span>
 
 	inode_lock_nested(dir, I_MUTEX_PARENT);
 	list_for_each_entry(p, &amp;list, l_node) {
<span class="p_del">-		struct dentry *index;</span>
<span class="p_del">-</span>
 		if (p-&gt;name[0] == &#39;.&#39;) {
 			if (p-&gt;len == 1)
 				continue;
<span class="p_chunk">@@ -701,6 +700,7 @@</span> <span class="p_context"> int ovl_indexdir_cleanup(struct dentry *dentry, struct vfsmount *mnt,</span>
 		index = lookup_one_len(p-&gt;name, dentry, p-&gt;len);
 		if (IS_ERR(index)) {
 			err = PTR_ERR(index);
<span class="p_add">+			index = NULL;</span>
 			break;
 		}
 		err = ovl_verify_index(index, lowerstack, numlower);
<span class="p_chunk">@@ -712,7 +712,9 @@</span> <span class="p_context"> int ovl_indexdir_cleanup(struct dentry *dentry, struct vfsmount *mnt,</span>
 				break;
 		}
 		dput(index);
<span class="p_add">+		index = NULL;</span>
 	}
<span class="p_add">+	dput(index);</span>
 	inode_unlock(dir);
 out:
 	ovl_cache_free(&amp;list);
<span class="p_header">diff --git a/fs/overlayfs/super.c b/fs/overlayfs/super.c</span>
<span class="p_header">index d86e89f97201..a1464905c1ea 100644</span>
<span class="p_header">--- a/fs/overlayfs/super.c</span>
<span class="p_header">+++ b/fs/overlayfs/super.c</span>
<span class="p_chunk">@@ -210,9 +210,10 @@</span> <span class="p_context"> static void ovl_put_super(struct super_block *sb)</span>
 
 	dput(ufs-&gt;indexdir);
 	dput(ufs-&gt;workdir);
<span class="p_del">-	ovl_inuse_unlock(ufs-&gt;workbasedir);</span>
<span class="p_add">+	if (ufs-&gt;workdir_locked)</span>
<span class="p_add">+		ovl_inuse_unlock(ufs-&gt;workbasedir);</span>
 	dput(ufs-&gt;workbasedir);
<span class="p_del">-	if (ufs-&gt;upper_mnt)</span>
<span class="p_add">+	if (ufs-&gt;upper_mnt &amp;&amp; ufs-&gt;upperdir_locked)</span>
 		ovl_inuse_unlock(ufs-&gt;upper_mnt-&gt;mnt_root);
 	mntput(ufs-&gt;upper_mnt);
 	for (i = 0; i &lt; ufs-&gt;numlower; i++)
<span class="p_chunk">@@ -880,9 +881,13 @@</span> <span class="p_context"> static int ovl_fill_super(struct super_block *sb, void *data, int silent)</span>
 			goto out_put_upperpath;
 
 		err = -EBUSY;
<span class="p_del">-		if (!ovl_inuse_trylock(upperpath.dentry)) {</span>
<span class="p_del">-			pr_err(&quot;overlayfs: upperdir is in-use by another mount\n&quot;);</span>
<span class="p_add">+		if (ovl_inuse_trylock(upperpath.dentry)) {</span>
<span class="p_add">+			ufs-&gt;upperdir_locked = true;</span>
<span class="p_add">+		} else if (ufs-&gt;config.index) {</span>
<span class="p_add">+			pr_err(&quot;overlayfs: upperdir is in-use by another mount, mount with &#39;-o index=off&#39; to override exclusive upperdir protection.\n&quot;);</span>
 			goto out_put_upperpath;
<span class="p_add">+		} else {</span>
<span class="p_add">+			pr_warn(&quot;overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n&quot;);</span>
 		}
 
 		err = ovl_mount_dir(ufs-&gt;config.workdir, &amp;workpath);
<span class="p_chunk">@@ -900,9 +905,13 @@</span> <span class="p_context"> static int ovl_fill_super(struct super_block *sb, void *data, int silent)</span>
 		}
 
 		err = -EBUSY;
<span class="p_del">-		if (!ovl_inuse_trylock(workpath.dentry)) {</span>
<span class="p_del">-			pr_err(&quot;overlayfs: workdir is in-use by another mount\n&quot;);</span>
<span class="p_add">+		if (ovl_inuse_trylock(workpath.dentry)) {</span>
<span class="p_add">+			ufs-&gt;workdir_locked = true;</span>
<span class="p_add">+		} else if (ufs-&gt;config.index) {</span>
<span class="p_add">+			pr_err(&quot;overlayfs: workdir is in-use by another mount, mount with &#39;-o index=off&#39; to override exclusive workdir protection.\n&quot;);</span>
 			goto out_put_workpath;
<span class="p_add">+		} else {</span>
<span class="p_add">+			pr_warn(&quot;overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n&quot;);</span>
 		}
 
 		ufs-&gt;workbasedir = workpath.dentry;
<span class="p_chunk">@@ -1155,11 +1164,13 @@</span> <span class="p_context"> static int ovl_fill_super(struct super_block *sb, void *data, int silent)</span>
 out_free_lowertmp:
 	kfree(lowertmp);
 out_unlock_workdentry:
<span class="p_del">-	ovl_inuse_unlock(workpath.dentry);</span>
<span class="p_add">+	if (ufs-&gt;workdir_locked)</span>
<span class="p_add">+		ovl_inuse_unlock(workpath.dentry);</span>
 out_put_workpath:
 	path_put(&amp;workpath);
 out_unlock_upperdentry:
<span class="p_del">-	ovl_inuse_unlock(upperpath.dentry);</span>
<span class="p_add">+	if (ufs-&gt;upperdir_locked)</span>
<span class="p_add">+		ovl_inuse_unlock(upperpath.dentry);</span>
 out_put_upperpath:
 	path_put(&amp;upperpath);
 out_free_config:
<span class="p_header">diff --git a/fs/overlayfs/util.c b/fs/overlayfs/util.c</span>
<span class="p_header">index f46ad75dc96a..8bff64f14190 100644</span>
<span class="p_header">--- a/fs/overlayfs/util.c</span>
<span class="p_header">+++ b/fs/overlayfs/util.c</span>
<span class="p_chunk">@@ -418,7 +418,7 @@</span> <span class="p_context"> void ovl_inuse_unlock(struct dentry *dentry)</span>
 	}
 }
 
<span class="p_del">-/* Called must hold OVL_I(inode)-&gt;oi_lock */</span>
<span class="p_add">+/* Caller must hold OVL_I(inode)-&gt;lock */</span>
 static void ovl_cleanup_index(struct dentry *dentry)
 {
 	struct inode *dir = ovl_indexdir(dentry-&gt;d_sb)-&gt;d_inode;
<span class="p_chunk">@@ -457,6 +457,9 @@</span> <span class="p_context"> static void ovl_cleanup_index(struct dentry *dentry)</span>
 	err = PTR_ERR(index);
 	if (!IS_ERR(index))
 		err = ovl_cleanup(dir, index);
<span class="p_add">+	else</span>
<span class="p_add">+		index = NULL;</span>
<span class="p_add">+</span>
 	inode_unlock(dir);
 	if (err)
 		goto fail;
<span class="p_chunk">@@ -545,3 +548,22 @@</span> <span class="p_context"> void ovl_nlink_end(struct dentry *dentry, bool locked)</span>
 		mutex_unlock(&amp;OVL_I(d_inode(dentry))-&gt;lock);
 	}
 }
<span class="p_add">+</span>
<span class="p_add">+int ovl_lock_rename_workdir(struct dentry *workdir, struct dentry *upperdir)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Workdir should not be the same as upperdir */</span>
<span class="p_add">+	if (workdir == upperdir)</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Workdir should not be subdir of upperdir and vice versa */</span>
<span class="p_add">+	if (lock_rename(workdir, upperdir) != NULL)</span>
<span class="p_add">+		goto err_unlock;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+err_unlock:</span>
<span class="p_add">+	unlock_rename(workdir, upperdir);</span>
<span class="p_add">+err:</span>
<span class="p_add">+	pr_err(&quot;overlayfs: failed to lock workdir+upperdir\n&quot;);</span>
<span class="p_add">+	return -EIO;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/fs/userfaultfd.c b/fs/userfaultfd.c</span>
<span class="p_header">index b0d5897bc4e6..be795bf20147 100644</span>
<span class="p_header">--- a/fs/userfaultfd.c</span>
<span class="p_header">+++ b/fs/userfaultfd.c</span>
<span class="p_chunk">@@ -566,6 +566,12 @@</span> <span class="p_context"> static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,</span>
 			break;
 		if (ACCESS_ONCE(ctx-&gt;released) ||
 		    fatal_signal_pending(current)) {
<span class="p_add">+			/*</span>
<span class="p_add">+			 * &amp;ewq-&gt;wq may be queued in fork_event, but</span>
<span class="p_add">+			 * __remove_wait_queue ignores the head</span>
<span class="p_add">+			 * parameter. It would be a problem if it</span>
<span class="p_add">+			 * didn&#39;t.</span>
<span class="p_add">+			 */</span>
 			__remove_wait_queue(&amp;ctx-&gt;event_wqh, &amp;ewq-&gt;wq);
 			if (ewq-&gt;msg.event == UFFD_EVENT_FORK) {
 				struct userfaultfd_ctx *new;
<span class="p_chunk">@@ -1039,6 +1045,12 @@</span> <span class="p_context"> static ssize_t userfaultfd_ctx_read(struct userfaultfd_ctx *ctx, int no_wait,</span>
 					(unsigned long)
 					uwq-&gt;msg.arg.reserved.reserved1;
 				list_move(&amp;uwq-&gt;wq.entry, &amp;fork_event);
<span class="p_add">+				/*</span>
<span class="p_add">+				 * fork_nctx can be freed as soon as</span>
<span class="p_add">+				 * we drop the lock, unless we take a</span>
<span class="p_add">+				 * reference on it.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				userfaultfd_ctx_get(fork_nctx);</span>
 				spin_unlock(&amp;ctx-&gt;event_wqh.lock);
 				ret = 0;
 				break;
<span class="p_chunk">@@ -1069,19 +1081,53 @@</span> <span class="p_context"> static ssize_t userfaultfd_ctx_read(struct userfaultfd_ctx *ctx, int no_wait,</span>
 
 	if (!ret &amp;&amp; msg-&gt;event == UFFD_EVENT_FORK) {
 		ret = resolve_userfault_fork(ctx, fork_nctx, msg);
<span class="p_add">+		spin_lock(&amp;ctx-&gt;event_wqh.lock);</span>
<span class="p_add">+		if (!list_empty(&amp;fork_event)) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * The fork thread didn&#39;t abort, so we can</span>
<span class="p_add">+			 * drop the temporary refcount.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			userfaultfd_ctx_put(fork_nctx);</span>
<span class="p_add">+</span>
<span class="p_add">+			uwq = list_first_entry(&amp;fork_event,</span>
<span class="p_add">+					       typeof(*uwq),</span>
<span class="p_add">+					       wq.entry);</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * If fork_event list wasn&#39;t empty and in turn</span>
<span class="p_add">+			 * the event wasn&#39;t already released by fork</span>
<span class="p_add">+			 * (the event is allocated on fork kernel</span>
<span class="p_add">+			 * stack), put the event back to its place in</span>
<span class="p_add">+			 * the event_wq. fork_event head will be freed</span>
<span class="p_add">+			 * as soon as we return so the event cannot</span>
<span class="p_add">+			 * stay queued there no matter the current</span>
<span class="p_add">+			 * &quot;ret&quot; value.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			list_del(&amp;uwq-&gt;wq.entry);</span>
<span class="p_add">+			__add_wait_queue(&amp;ctx-&gt;event_wqh, &amp;uwq-&gt;wq);</span>
 
<span class="p_del">-		if (!ret) {</span>
<span class="p_del">-			spin_lock(&amp;ctx-&gt;event_wqh.lock);</span>
<span class="p_del">-			if (!list_empty(&amp;fork_event)) {</span>
<span class="p_del">-				uwq = list_first_entry(&amp;fork_event,</span>
<span class="p_del">-						       typeof(*uwq),</span>
<span class="p_del">-						       wq.entry);</span>
<span class="p_del">-				list_del(&amp;uwq-&gt;wq.entry);</span>
<span class="p_del">-				__add_wait_queue(&amp;ctx-&gt;event_wqh, &amp;uwq-&gt;wq);</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Leave the event in the waitqueue and report</span>
<span class="p_add">+			 * error to userland if we failed to resolve</span>
<span class="p_add">+			 * the userfault fork.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (likely(!ret))</span>
 				userfaultfd_event_complete(ctx, uwq);
<span class="p_del">-			}</span>
<span class="p_del">-			spin_unlock(&amp;ctx-&gt;event_wqh.lock);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Here the fork thread aborted and the</span>
<span class="p_add">+			 * refcount from the fork thread on fork_nctx</span>
<span class="p_add">+			 * has already been released. We still hold</span>
<span class="p_add">+			 * the reference we took before releasing the</span>
<span class="p_add">+			 * lock above. If resolve_userfault_fork</span>
<span class="p_add">+			 * failed we&#39;ve to drop it because the</span>
<span class="p_add">+			 * fork_nctx has to be freed in such case. If</span>
<span class="p_add">+			 * it succeeded we&#39;ll hold it because the new</span>
<span class="p_add">+			 * uffd references it.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (ret)</span>
<span class="p_add">+				userfaultfd_ctx_put(fork_nctx);</span>
 		}
<span class="p_add">+		spin_unlock(&amp;ctx-&gt;event_wqh.lock);</span>
 	}
 
 	return ret;
<span class="p_header">diff --git a/fs/xattr.c b/fs/xattr.c</span>
<span class="p_header">index 464c94bf65f9..5441a6d95396 100644</span>
<span class="p_header">--- a/fs/xattr.c</span>
<span class="p_header">+++ b/fs/xattr.c</span>
<span class="p_chunk">@@ -249,7 +249,7 @@</span> <span class="p_context"> xattr_getsecurity(struct inode *inode, const char *name, void *value,</span>
 	}
 	memcpy(value, buffer, len);
 out:
<span class="p_del">-	security_release_secctx(buffer, len);</span>
<span class="p_add">+	kfree(buffer);</span>
 out_noalloc:
 	return len;
 }
<span class="p_header">diff --git a/include/asm-generic/percpu.h b/include/asm-generic/percpu.h</span>
<span class="p_header">index 0504ef8f3aa3..976f8ac26665 100644</span>
<span class="p_header">--- a/include/asm-generic/percpu.h</span>
<span class="p_header">+++ b/include/asm-generic/percpu.h</span>
<span class="p_chunk">@@ -115,15 +115,35 @@</span> <span class="p_context"> do {									\</span>
 	(__ret);							\
 })
 
<span class="p_del">-#define this_cpu_generic_read(pcp)					\</span>
<span class="p_add">+#define __this_cpu_generic_read_nopreempt(pcp)				\</span>
 ({									\
 	typeof(pcp) __ret;						\
 	preempt_disable_notrace();					\
<span class="p_del">-	__ret = raw_cpu_generic_read(pcp);				\</span>
<span class="p_add">+	__ret = READ_ONCE(*raw_cpu_ptr(&amp;(pcp)));			\</span>
 	preempt_enable_notrace();					\
 	__ret;								\
 })
 
<span class="p_add">+#define __this_cpu_generic_read_noirq(pcp)				\</span>
<span class="p_add">+({									\</span>
<span class="p_add">+	typeof(pcp) __ret;						\</span>
<span class="p_add">+	unsigned long __flags;						\</span>
<span class="p_add">+	raw_local_irq_save(__flags);					\</span>
<span class="p_add">+	__ret = raw_cpu_generic_read(pcp);				\</span>
<span class="p_add">+	raw_local_irq_restore(__flags);					\</span>
<span class="p_add">+	__ret;								\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
<span class="p_add">+#define this_cpu_generic_read(pcp)					\</span>
<span class="p_add">+({									\</span>
<span class="p_add">+	typeof(pcp) __ret;						\</span>
<span class="p_add">+	if (__native_word(pcp))						\</span>
<span class="p_add">+		__ret = __this_cpu_generic_read_nopreempt(pcp);		\</span>
<span class="p_add">+	else								\</span>
<span class="p_add">+		__ret = __this_cpu_generic_read_noirq(pcp);		\</span>
<span class="p_add">+	__ret;								\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
 #define this_cpu_generic_to_op(pcp, val, op)				\
 do {									\
 	unsigned long __flags;						\
<span class="p_header">diff --git a/include/linux/iio/adc/ad_sigma_delta.h b/include/linux/iio/adc/ad_sigma_delta.h</span>
<span class="p_header">index 5ba430cc9a87..1fc7abd28b0b 100644</span>
<span class="p_header">--- a/include/linux/iio/adc/ad_sigma_delta.h</span>
<span class="p_header">+++ b/include/linux/iio/adc/ad_sigma_delta.h</span>
<span class="p_chunk">@@ -111,6 +111,9 @@</span> <span class="p_context"> int ad_sd_write_reg(struct ad_sigma_delta *sigma_delta, unsigned int reg,</span>
 int ad_sd_read_reg(struct ad_sigma_delta *sigma_delta, unsigned int reg,
 	unsigned int size, unsigned int *val);
 
<span class="p_add">+int ad_sd_reset(struct ad_sigma_delta *sigma_delta,</span>
<span class="p_add">+	unsigned int reset_length);</span>
<span class="p_add">+</span>
 int ad_sigma_delta_single_conversion(struct iio_dev *indio_dev,
 	const struct iio_chan_spec *chan, int *val);
 int ad_sd_calibrate_all(struct ad_sigma_delta *sigma_delta,
<span class="p_header">diff --git a/include/linux/mmu_notifier.h b/include/linux/mmu_notifier.h</span>
<span class="p_header">index 7b2e31b1745a..6866e8126982 100644</span>
<span class="p_header">--- a/include/linux/mmu_notifier.h</span>
<span class="p_header">+++ b/include/linux/mmu_notifier.h</span>
<span class="p_chunk">@@ -400,6 +400,11 @@</span> <span class="p_context"> extern void mmu_notifier_synchronize(void);</span>
 
 #else /* CONFIG_MMU_NOTIFIER */
 
<span class="p_add">+static inline int mm_has_notifiers(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void mmu_notifier_release(struct mm_struct *mm)
 {
 }
<span class="p_header">diff --git a/include/linux/trace_events.h b/include/linux/trace_events.h</span>
<span class="p_header">index 5012b524283d..60248d644b6f 100644</span>
<span class="p_header">--- a/include/linux/trace_events.h</span>
<span class="p_header">+++ b/include/linux/trace_events.h</span>
<span class="p_chunk">@@ -277,6 +277,7 @@</span> <span class="p_context"> struct trace_event_call {</span>
 	int				perf_refcount;
 	struct hlist_head __percpu	*perf_events;
 	struct bpf_prog			*prog;
<span class="p_add">+	struct perf_event		*bpf_prog_owner;</span>
 
 	int	(*perf_perm)(struct trace_event_call *,
 			     struct perf_event *);
<span class="p_header">diff --git a/include/net/netlink.h b/include/net/netlink.h</span>
<span class="p_header">index ef8e6c3a80a6..4c72c7866da5 100644</span>
<span class="p_header">--- a/include/net/netlink.h</span>
<span class="p_header">+++ b/include/net/netlink.h</span>
<span class="p_chunk">@@ -768,7 +768,10 @@</span> <span class="p_context"> static inline int nla_parse_nested(struct nlattr *tb[], int maxtype,</span>
  */
 static inline int nla_put_u8(struct sk_buff *skb, int attrtype, u8 value)
 {
<span class="p_del">-	return nla_put(skb, attrtype, sizeof(u8), &amp;value);</span>
<span class="p_add">+	/* temporary variables to work around GCC PR81715 with asan-stack=1 */</span>
<span class="p_add">+	u8 tmp = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	return nla_put(skb, attrtype, sizeof(u8), &amp;tmp);</span>
 }
 
 /**
<span class="p_chunk">@@ -779,7 +782,9 @@</span> <span class="p_context"> static inline int nla_put_u8(struct sk_buff *skb, int attrtype, u8 value)</span>
  */
 static inline int nla_put_u16(struct sk_buff *skb, int attrtype, u16 value)
 {
<span class="p_del">-	return nla_put(skb, attrtype, sizeof(u16), &amp;value);</span>
<span class="p_add">+	u16 tmp = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	return nla_put(skb, attrtype, sizeof(u16), &amp;tmp);</span>
 }
 
 /**
<span class="p_chunk">@@ -790,7 +795,9 @@</span> <span class="p_context"> static inline int nla_put_u16(struct sk_buff *skb, int attrtype, u16 value)</span>
  */
 static inline int nla_put_be16(struct sk_buff *skb, int attrtype, __be16 value)
 {
<span class="p_del">-	return nla_put(skb, attrtype, sizeof(__be16), &amp;value);</span>
<span class="p_add">+	__be16 tmp = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	return nla_put(skb, attrtype, sizeof(__be16), &amp;tmp);</span>
 }
 
 /**
<span class="p_chunk">@@ -801,7 +808,9 @@</span> <span class="p_context"> static inline int nla_put_be16(struct sk_buff *skb, int attrtype, __be16 value)</span>
  */
 static inline int nla_put_net16(struct sk_buff *skb, int attrtype, __be16 value)
 {
<span class="p_del">-	return nla_put_be16(skb, attrtype | NLA_F_NET_BYTEORDER, value);</span>
<span class="p_add">+	__be16 tmp = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	return nla_put_be16(skb, attrtype | NLA_F_NET_BYTEORDER, tmp);</span>
 }
 
 /**
<span class="p_chunk">@@ -812,7 +821,9 @@</span> <span class="p_context"> static inline int nla_put_net16(struct sk_buff *skb, int attrtype, __be16 value)</span>
  */
 static inline int nla_put_le16(struct sk_buff *skb, int attrtype, __le16 value)
 {
<span class="p_del">-	return nla_put(skb, attrtype, sizeof(__le16), &amp;value);</span>
<span class="p_add">+	__le16 tmp = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	return nla_put(skb, attrtype, sizeof(__le16), &amp;tmp);</span>
 }
 
 /**
<span class="p_chunk">@@ -823,7 +834,9 @@</span> <span class="p_context"> static inline int nla_put_le16(struct sk_buff *skb, int attrtype, __le16 value)</span>
  */
 static inline int nla_put_u32(struct sk_buff *skb, int attrtype, u32 value)
 {
<span class="p_del">-	return nla_put(skb, attrtype, sizeof(u32), &amp;value);</span>
<span class="p_add">+	u32 tmp = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	return nla_put(skb, attrtype, sizeof(u32), &amp;tmp);</span>
 }
 
 /**
<span class="p_chunk">@@ -834,7 +847,9 @@</span> <span class="p_context"> static inline int nla_put_u32(struct sk_buff *skb, int attrtype, u32 value)</span>
  */
 static inline int nla_put_be32(struct sk_buff *skb, int attrtype, __be32 value)
 {
<span class="p_del">-	return nla_put(skb, attrtype, sizeof(__be32), &amp;value);</span>
<span class="p_add">+	__be32 tmp = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	return nla_put(skb, attrtype, sizeof(__be32), &amp;tmp);</span>
 }
 
 /**
<span class="p_chunk">@@ -845,7 +860,9 @@</span> <span class="p_context"> static inline int nla_put_be32(struct sk_buff *skb, int attrtype, __be32 value)</span>
  */
 static inline int nla_put_net32(struct sk_buff *skb, int attrtype, __be32 value)
 {
<span class="p_del">-	return nla_put_be32(skb, attrtype | NLA_F_NET_BYTEORDER, value);</span>
<span class="p_add">+	__be32 tmp = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	return nla_put_be32(skb, attrtype | NLA_F_NET_BYTEORDER, tmp);</span>
 }
 
 /**
<span class="p_chunk">@@ -856,7 +873,9 @@</span> <span class="p_context"> static inline int nla_put_net32(struct sk_buff *skb, int attrtype, __be32 value)</span>
  */
 static inline int nla_put_le32(struct sk_buff *skb, int attrtype, __le32 value)
 {
<span class="p_del">-	return nla_put(skb, attrtype, sizeof(__le32), &amp;value);</span>
<span class="p_add">+	__le32 tmp = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	return nla_put(skb, attrtype, sizeof(__le32), &amp;tmp);</span>
 }
 
 /**
<span class="p_chunk">@@ -869,7 +888,9 @@</span> <span class="p_context"> static inline int nla_put_le32(struct sk_buff *skb, int attrtype, __le32 value)</span>
 static inline int nla_put_u64_64bit(struct sk_buff *skb, int attrtype,
 				    u64 value, int padattr)
 {
<span class="p_del">-	return nla_put_64bit(skb, attrtype, sizeof(u64), &amp;value, padattr);</span>
<span class="p_add">+	u64 tmp = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	return nla_put_64bit(skb, attrtype, sizeof(u64), &amp;tmp, padattr);</span>
 }
 
 /**
<span class="p_chunk">@@ -882,7 +903,9 @@</span> <span class="p_context"> static inline int nla_put_u64_64bit(struct sk_buff *skb, int attrtype,</span>
 static inline int nla_put_be64(struct sk_buff *skb, int attrtype, __be64 value,
 			       int padattr)
 {
<span class="p_del">-	return nla_put_64bit(skb, attrtype, sizeof(__be64), &amp;value, padattr);</span>
<span class="p_add">+	__be64 tmp = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	return nla_put_64bit(skb, attrtype, sizeof(__be64), &amp;tmp, padattr);</span>
 }
 
 /**
<span class="p_chunk">@@ -895,7 +918,9 @@</span> <span class="p_context"> static inline int nla_put_be64(struct sk_buff *skb, int attrtype, __be64 value,</span>
 static inline int nla_put_net64(struct sk_buff *skb, int attrtype, __be64 value,
 				int padattr)
 {
<span class="p_del">-	return nla_put_be64(skb, attrtype | NLA_F_NET_BYTEORDER, value,</span>
<span class="p_add">+	__be64 tmp = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	return nla_put_be64(skb, attrtype | NLA_F_NET_BYTEORDER, tmp,</span>
 			    padattr);
 }
 
<span class="p_chunk">@@ -909,7 +934,9 @@</span> <span class="p_context"> static inline int nla_put_net64(struct sk_buff *skb, int attrtype, __be64 value,</span>
 static inline int nla_put_le64(struct sk_buff *skb, int attrtype, __le64 value,
 			       int padattr)
 {
<span class="p_del">-	return nla_put_64bit(skb, attrtype, sizeof(__le64), &amp;value, padattr);</span>
<span class="p_add">+	__le64 tmp = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	return nla_put_64bit(skb, attrtype, sizeof(__le64), &amp;tmp, padattr);</span>
 }
 
 /**
<span class="p_chunk">@@ -920,7 +947,9 @@</span> <span class="p_context"> static inline int nla_put_le64(struct sk_buff *skb, int attrtype, __le64 value,</span>
  */
 static inline int nla_put_s8(struct sk_buff *skb, int attrtype, s8 value)
 {
<span class="p_del">-	return nla_put(skb, attrtype, sizeof(s8), &amp;value);</span>
<span class="p_add">+	s8 tmp = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	return nla_put(skb, attrtype, sizeof(s8), &amp;tmp);</span>
 }
 
 /**
<span class="p_chunk">@@ -931,7 +960,9 @@</span> <span class="p_context"> static inline int nla_put_s8(struct sk_buff *skb, int attrtype, s8 value)</span>
  */
 static inline int nla_put_s16(struct sk_buff *skb, int attrtype, s16 value)
 {
<span class="p_del">-	return nla_put(skb, attrtype, sizeof(s16), &amp;value);</span>
<span class="p_add">+	s16 tmp = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	return nla_put(skb, attrtype, sizeof(s16), &amp;tmp);</span>
 }
 
 /**
<span class="p_chunk">@@ -942,7 +973,9 @@</span> <span class="p_context"> static inline int nla_put_s16(struct sk_buff *skb, int attrtype, s16 value)</span>
  */
 static inline int nla_put_s32(struct sk_buff *skb, int attrtype, s32 value)
 {
<span class="p_del">-	return nla_put(skb, attrtype, sizeof(s32), &amp;value);</span>
<span class="p_add">+	s32 tmp = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	return nla_put(skb, attrtype, sizeof(s32), &amp;tmp);</span>
 }
 
 /**
<span class="p_chunk">@@ -955,7 +988,9 @@</span> <span class="p_context"> static inline int nla_put_s32(struct sk_buff *skb, int attrtype, s32 value)</span>
 static inline int nla_put_s64(struct sk_buff *skb, int attrtype, s64 value,
 			      int padattr)
 {
<span class="p_del">-	return nla_put_64bit(skb, attrtype, sizeof(s64), &amp;value, padattr);</span>
<span class="p_add">+	s64 tmp = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	return nla_put_64bit(skb, attrtype, sizeof(s64), &amp;tmp, padattr);</span>
 }
 
 /**
<span class="p_chunk">@@ -1005,7 +1040,9 @@</span> <span class="p_context"> static inline int nla_put_msecs(struct sk_buff *skb, int attrtype,</span>
 static inline int nla_put_in_addr(struct sk_buff *skb, int attrtype,
 				  __be32 addr)
 {
<span class="p_del">-	return nla_put_be32(skb, attrtype, addr);</span>
<span class="p_add">+	__be32 tmp = addr;</span>
<span class="p_add">+</span>
<span class="p_add">+	return nla_put_be32(skb, attrtype, tmp);</span>
 }
 
 /**
<span class="p_header">diff --git a/include/net/protocol.h b/include/net/protocol.h</span>
<span class="p_header">index 65ba335b0e7e..4fc75f7ae23b 100644</span>
<span class="p_header">--- a/include/net/protocol.h</span>
<span class="p_header">+++ b/include/net/protocol.h</span>
<span class="p_chunk">@@ -39,8 +39,8 @@</span> <span class="p_context"></span>
 
 /* This is used to register protocols. */
 struct net_protocol {
<span class="p_del">-	void			(*early_demux)(struct sk_buff *skb);</span>
<span class="p_del">-	void                    (*early_demux_handler)(struct sk_buff *skb);</span>
<span class="p_add">+	int			(*early_demux)(struct sk_buff *skb);</span>
<span class="p_add">+	int			(*early_demux_handler)(struct sk_buff *skb);</span>
 	int			(*handler)(struct sk_buff *skb);
 	void			(*err_handler)(struct sk_buff *skb, u32 info);
 	unsigned int		no_policy:1,
<span class="p_header">diff --git a/include/net/route.h b/include/net/route.h</span>
<span class="p_header">index cb0a76d9dde1..58458966e31e 100644</span>
<span class="p_header">--- a/include/net/route.h</span>
<span class="p_header">+++ b/include/net/route.h</span>
<span class="p_chunk">@@ -175,7 +175,9 @@</span> <span class="p_context"> static inline struct rtable *ip_route_output_gre(struct net *net, struct flowi4</span>
 	fl4-&gt;fl4_gre_key = gre_key;
 	return ip_route_output_key(net, fl4);
 }
<span class="p_del">-</span>
<span class="p_add">+int ip_mc_validate_source(struct sk_buff *skb, __be32 daddr, __be32 saddr,</span>
<span class="p_add">+			  u8 tos, struct net_device *dev,</span>
<span class="p_add">+			  struct in_device *in_dev, u32 *itag);</span>
 int ip_route_input_noref(struct sk_buff *skb, __be32 dst, __be32 src,
 			 u8 tos, struct net_device *devin);
 int ip_route_input_rcu(struct sk_buff *skb, __be32 dst, __be32 src,
<span class="p_header">diff --git a/include/net/sctp/ulpevent.h b/include/net/sctp/ulpevent.h</span>
<span class="p_header">index 1060494ac230..b8c86ec1a8f5 100644</span>
<span class="p_header">--- a/include/net/sctp/ulpevent.h</span>
<span class="p_header">+++ b/include/net/sctp/ulpevent.h</span>
<span class="p_chunk">@@ -153,8 +153,12 @@</span> <span class="p_context"> __u16 sctp_ulpevent_get_notification_type(const struct sctp_ulpevent *event);</span>
 static inline int sctp_ulpevent_type_enabled(__u16 sn_type,
 					     struct sctp_event_subscribe *mask)
 {
<span class="p_add">+	int offset = sn_type - SCTP_SN_TYPE_BASE;</span>
 	char *amask = (char *) mask;
<span class="p_del">-	return amask[sn_type - SCTP_SN_TYPE_BASE];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (offset &gt;= sizeof(struct sctp_event_subscribe))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	return amask[offset];</span>
 }
 
 /* Given an event subscription, is this event enabled? */
<span class="p_header">diff --git a/include/net/tcp.h b/include/net/tcp.h</span>
<span class="p_header">index f642a39f9eee..48978125947b 100644</span>
<span class="p_header">--- a/include/net/tcp.h</span>
<span class="p_header">+++ b/include/net/tcp.h</span>
<span class="p_chunk">@@ -347,7 +347,7 @@</span> <span class="p_context"> void tcp_v4_err(struct sk_buff *skb, u32);</span>
 
 void tcp_shutdown(struct sock *sk, int how);
 
<span class="p_del">-void tcp_v4_early_demux(struct sk_buff *skb);</span>
<span class="p_add">+int tcp_v4_early_demux(struct sk_buff *skb);</span>
 int tcp_v4_rcv(struct sk_buff *skb);
 
 int tcp_v4_tw_remember_stamp(struct inet_timewait_sock *tw);
<span class="p_header">diff --git a/include/net/udp.h b/include/net/udp.h</span>
<span class="p_header">index 626c2d8a70c5..1e6b2476d427 100644</span>
<span class="p_header">--- a/include/net/udp.h</span>
<span class="p_header">+++ b/include/net/udp.h</span>
<span class="p_chunk">@@ -259,7 +259,7 @@</span> <span class="p_context"> static inline struct sk_buff *skb_recv_udp(struct sock *sk, unsigned int flags,</span>
 	return __skb_recv_udp(sk, flags, noblock, &amp;peeked, &amp;off, err);
 }
 
<span class="p_del">-void udp_v4_early_demux(struct sk_buff *skb);</span>
<span class="p_add">+int udp_v4_early_demux(struct sk_buff *skb);</span>
 bool udp_sk_rx_dst_set(struct sock *sk, struct dst_entry *dst);
 int udp_get_port(struct sock *sk, unsigned short snum,
 		 int (*saddr_cmp)(const struct sock *,
<span class="p_header">diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h</span>
<span class="p_header">index 0979a5f3b69a..6ff1bab23679 100644</span>
<span class="p_header">--- a/include/scsi/scsi_device.h</span>
<span class="p_header">+++ b/include/scsi/scsi_device.h</span>
<span class="p_chunk">@@ -182,6 +182,7 @@</span> <span class="p_context"> struct scsi_device {</span>
 	unsigned no_dif:1;	/* T10 PI (DIF) should be disabled */
 	unsigned broken_fua:1;		/* Don&#39;t set FUA bit */
 	unsigned lun_in_cdb:1;		/* Store LUN bits in CDB[1] */
<span class="p_add">+	unsigned unmap_limit_for_ws:1;	/* Use the UNMAP limit for WRITE SAME */</span>
 
 	atomic_t disk_events_disable_depth; /* disable depth for disk events */
 
<span class="p_header">diff --git a/include/scsi/scsi_devinfo.h b/include/scsi/scsi_devinfo.h</span>
<span class="p_header">index 9592570e092a..36b03013d629 100644</span>
<span class="p_header">--- a/include/scsi/scsi_devinfo.h</span>
<span class="p_header">+++ b/include/scsi/scsi_devinfo.h</span>
<span class="p_chunk">@@ -29,5 +29,6 @@</span> <span class="p_context"></span>
 #define BLIST_TRY_VPD_PAGES	0x10000000 /* Attempt to read VPD pages */
 #define BLIST_NO_RSOC		0x20000000 /* don&#39;t try to issue RSOC */
 #define BLIST_MAX_1024		0x40000000 /* maximum 1024 sector cdb length */
<span class="p_add">+#define BLIST_UNMAP_LIMIT_WS	0x80000000 /* Use UNMAP limit for WRITE SAME */</span>
 
 #endif
<span class="p_header">diff --git a/include/uapi/linux/bpf.h b/include/uapi/linux/bpf.h</span>
<span class="p_header">index e99e3e6f8b37..f0add86219f0 100644</span>
<span class="p_header">--- a/include/uapi/linux/bpf.h</span>
<span class="p_header">+++ b/include/uapi/linux/bpf.h</span>
<span class="p_chunk">@@ -294,7 +294,7 @@</span> <span class="p_context"> union bpf_attr {</span>
  *     jump into another BPF program
  *     @ctx: context pointer passed to next program
  *     @prog_array_map: pointer to map which type is BPF_MAP_TYPE_PROG_ARRAY
<span class="p_del">- *     @index: index inside array that selects specific program to run</span>
<span class="p_add">+ *     @index: 32-bit index inside array that selects specific program to run</span>
  *     Return: 0 on success or negative error
  *
  * int bpf_clone_redirect(skb, ifindex, flags)
<span class="p_header">diff --git a/include/uapi/linux/dm-ioctl.h b/include/uapi/linux/dm-ioctl.h</span>
<span class="p_header">index 412c06a624c8..ccaea525340b 100644</span>
<span class="p_header">--- a/include/uapi/linux/dm-ioctl.h</span>
<span class="p_header">+++ b/include/uapi/linux/dm-ioctl.h</span>
<span class="p_chunk">@@ -269,9 +269,9 @@</span> <span class="p_context"> enum {</span>
 #define DM_DEV_SET_GEOMETRY	_IOWR(DM_IOCTL, DM_DEV_SET_GEOMETRY_CMD, struct dm_ioctl)
 
 #define DM_VERSION_MAJOR	4
<span class="p_del">-#define DM_VERSION_MINOR	36</span>
<span class="p_add">+#define DM_VERSION_MINOR	37</span>
 #define DM_VERSION_PATCHLEVEL	0
<span class="p_del">-#define DM_VERSION_EXTRA	&quot;-ioctl (2017-06-09)&quot;</span>
<span class="p_add">+#define DM_VERSION_EXTRA	&quot;-ioctl (2017-09-20)&quot;</span>
 
 /* Status bits */
 #define DM_READONLY_FLAG	(1 &lt;&lt; 0) /* In/Out */
<span class="p_header">diff --git a/include/uapi/linux/usb/ch9.h b/include/uapi/linux/usb/ch9.h</span>
<span class="p_header">index ce1169af39d7..2a5d63040a0b 100644</span>
<span class="p_header">--- a/include/uapi/linux/usb/ch9.h</span>
<span class="p_header">+++ b/include/uapi/linux/usb/ch9.h</span>
<span class="p_chunk">@@ -780,6 +780,7 @@</span> <span class="p_context"> struct usb_interface_assoc_descriptor {</span>
 	__u8  iFunction;
 } __attribute__ ((packed));
 
<span class="p_add">+#define USB_DT_INTERFACE_ASSOCIATION_SIZE	8</span>
 
 /*-------------------------------------------------------------------------*/
 
<span class="p_header">diff --git a/kernel/bpf/core.c b/kernel/bpf/core.c</span>
<span class="p_header">index ad5f55922a13..9a1bed1f3029 100644</span>
<span class="p_header">--- a/kernel/bpf/core.c</span>
<span class="p_header">+++ b/kernel/bpf/core.c</span>
<span class="p_chunk">@@ -1010,7 +1010,7 @@</span> <span class="p_context"> static unsigned int ___bpf_prog_run(u64 *regs, const struct bpf_insn *insn,</span>
 		struct bpf_map *map = (struct bpf_map *) (unsigned long) BPF_R2;
 		struct bpf_array *array = container_of(map, struct bpf_array, map);
 		struct bpf_prog *prog;
<span class="p_del">-		u64 index = BPF_R3;</span>
<span class="p_add">+		u32 index = BPF_R3;</span>
 
 		if (unlikely(index &gt;= array-&gt;map.max_entries))
 			goto out;
<span class="p_header">diff --git a/kernel/bpf/syscall.c b/kernel/bpf/syscall.c</span>
<span class="p_header">index 6c772adabad2..1939d91da1f8 100644</span>
<span class="p_header">--- a/kernel/bpf/syscall.c</span>
<span class="p_header">+++ b/kernel/bpf/syscall.c</span>
<span class="p_chunk">@@ -144,15 +144,17 @@</span> <span class="p_context"> static int bpf_map_alloc_id(struct bpf_map *map)</span>
 
 static void bpf_map_free_id(struct bpf_map *map, bool do_idr_lock)
 {
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
 	if (do_idr_lock)
<span class="p_del">-		spin_lock_bh(&amp;map_idr_lock);</span>
<span class="p_add">+		spin_lock_irqsave(&amp;map_idr_lock, flags);</span>
 	else
 		__acquire(&amp;map_idr_lock);
 
 	idr_remove(&amp;map_idr, map-&gt;id);
 
 	if (do_idr_lock)
<span class="p_del">-		spin_unlock_bh(&amp;map_idr_lock);</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;map_idr_lock, flags);</span>
 	else
 		__release(&amp;map_idr_lock);
 }
<span class="p_header">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c</span>
<span class="p_header">index 664d93972373..3940019b9740 100644</span>
<span class="p_header">--- a/kernel/bpf/verifier.c</span>
<span class="p_header">+++ b/kernel/bpf/verifier.c</span>
<span class="p_chunk">@@ -1978,7 +1978,8 @@</span> <span class="p_context"> static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)</span>
 			}
 		} else {
 			if (insn-&gt;src_reg != BPF_REG_0 || insn-&gt;off != 0 ||
<span class="p_del">-			    (insn-&gt;imm != 16 &amp;&amp; insn-&gt;imm != 32 &amp;&amp; insn-&gt;imm != 64)) {</span>
<span class="p_add">+			    (insn-&gt;imm != 16 &amp;&amp; insn-&gt;imm != 32 &amp;&amp; insn-&gt;imm != 64) ||</span>
<span class="p_add">+			    BPF_CLASS(insn-&gt;code) == BPF_ALU64) {</span>
 				verbose(&quot;BPF_END uses reserved fields\n&quot;);
 				return -EINVAL;
 			}
<span class="p_header">diff --git a/kernel/cgroup/cgroup.c b/kernel/cgroup/cgroup.c</span>
<span class="p_header">index df2e0f14a95d..6d60aafbe8c1 100644</span>
<span class="p_header">--- a/kernel/cgroup/cgroup.c</span>
<span class="p_header">+++ b/kernel/cgroup/cgroup.c</span>
<span class="p_chunk">@@ -2168,6 +2168,14 @@</span> <span class="p_context"> static int cgroup_migrate_execute(struct cgroup_mgctx *mgctx)</span>
 		list_del_init(&amp;cset-&gt;mg_node);
 	}
 	spin_unlock_irq(&amp;css_set_lock);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Re-initialize the cgroup_taskset structure in case it is reused</span>
<span class="p_add">+	 * again in another cgroup_migrate_add_task()/cgroup_migrate_execute()</span>
<span class="p_add">+	 * iteration.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	tset-&gt;nr_tasks = 0;</span>
<span class="p_add">+	tset-&gt;csets    = &amp;tset-&gt;src_csets;</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index 03ac9c8b02fb..7242a6e1ec76 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -8121,6 +8121,7 @@</span> <span class="p_context"> static int perf_event_set_bpf_prog(struct perf_event *event, u32 prog_fd)</span>
 		}
 	}
 	event-&gt;tp_event-&gt;prog = prog;
<span class="p_add">+	event-&gt;tp_event-&gt;bpf_prog_owner = event;</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -8135,7 +8136,7 @@</span> <span class="p_context"> static void perf_event_free_bpf_prog(struct perf_event *event)</span>
 		return;
 
 	prog = event-&gt;tp_event-&gt;prog;
<span class="p_del">-	if (prog) {</span>
<span class="p_add">+	if (prog &amp;&amp; event-&gt;tp_event-&gt;bpf_prog_owner == event) {</span>
 		event-&gt;tp_event-&gt;prog = NULL;
 		bpf_prog_put(prog);
 	}
<span class="p_header">diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c</span>
<span class="p_header">index 725819569fa7..2ee3e3345ff3 100644</span>
<span class="p_header">--- a/kernel/trace/ftrace.c</span>
<span class="p_header">+++ b/kernel/trace/ftrace.c</span>
<span class="p_chunk">@@ -4954,9 +4954,6 @@</span> <span class="p_context"> static char ftrace_graph_buf[FTRACE_FILTER_SIZE] __initdata;</span>
 static char ftrace_graph_notrace_buf[FTRACE_FILTER_SIZE] __initdata;
 static int ftrace_graph_set_hash(struct ftrace_hash *hash, char *buffer);
 
<span class="p_del">-static unsigned long save_global_trampoline;</span>
<span class="p_del">-static unsigned long save_global_flags;</span>
<span class="p_del">-</span>
 static int __init set_graph_function(char *str)
 {
 	strlcpy(ftrace_graph_buf, str, FTRACE_FILTER_SIZE);
<span class="p_chunk">@@ -6756,17 +6753,6 @@</span> <span class="p_context"> void unregister_ftrace_graph(void)</span>
 	unregister_pm_notifier(&amp;ftrace_suspend_notifier);
 	unregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);
 
<span class="p_del">-#ifdef CONFIG_DYNAMIC_FTRACE</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Function graph does not allocate the trampoline, but</span>
<span class="p_del">-	 * other global_ops do. We need to reset the ALLOC_TRAMP flag</span>
<span class="p_del">-	 * if one was used.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	global_ops.trampoline = save_global_trampoline;</span>
<span class="p_del">-	if (save_global_flags &amp; FTRACE_OPS_FL_ALLOC_TRAMP)</span>
<span class="p_del">-		global_ops.flags |= FTRACE_OPS_FL_ALLOC_TRAMP;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
  out:
 	mutex_unlock(&amp;ftrace_lock);
 }
<span class="p_header">diff --git a/lib/ratelimit.c b/lib/ratelimit.c</span>
<span class="p_header">index 08f8043cac61..d01f47135239 100644</span>
<span class="p_header">--- a/lib/ratelimit.c</span>
<span class="p_header">+++ b/lib/ratelimit.c</span>
<span class="p_chunk">@@ -48,7 +48,9 @@</span> <span class="p_context"> int ___ratelimit(struct ratelimit_state *rs, const char *func)</span>
 	if (time_is_before_jiffies(rs-&gt;begin + rs-&gt;interval)) {
 		if (rs-&gt;missed) {
 			if (!(rs-&gt;flags &amp; RATELIMIT_MSG_ON_RELEASE)) {
<span class="p_del">-				pr_warn(&quot;%s: %d callbacks suppressed\n&quot;, func, rs-&gt;missed);</span>
<span class="p_add">+				printk_deferred(KERN_WARNING</span>
<span class="p_add">+						&quot;%s: %d callbacks suppressed\n&quot;,</span>
<span class="p_add">+						func, rs-&gt;missed);</span>
 				rs-&gt;missed = 0;
 			}
 		}
<span class="p_header">diff --git a/mm/ksm.c b/mm/ksm.c</span>
<span class="p_header">index db20f8436bc3..86f0db3d6cdb 100644</span>
<span class="p_header">--- a/mm/ksm.c</span>
<span class="p_header">+++ b/mm/ksm.c</span>
<span class="p_chunk">@@ -1990,6 +1990,7 @@</span> <span class="p_context"> static void stable_tree_append(struct rmap_item *rmap_item,</span>
  */
 static void cmp_and_merge_page(struct page *page, struct rmap_item *rmap_item)
 {
<span class="p_add">+	struct mm_struct *mm = rmap_item-&gt;mm;</span>
 	struct rmap_item *tree_rmap_item;
 	struct page *tree_page = NULL;
 	struct stable_node *stable_node;
<span class="p_chunk">@@ -2062,9 +2063,11 @@</span> <span class="p_context"> static void cmp_and_merge_page(struct page *page, struct rmap_item *rmap_item)</span>
 	if (ksm_use_zero_pages &amp;&amp; (checksum == zero_checksum)) {
 		struct vm_area_struct *vma;
 
<span class="p_del">-		vma = find_mergeable_vma(rmap_item-&gt;mm, rmap_item-&gt;address);</span>
<span class="p_add">+		down_read(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+		vma = find_mergeable_vma(mm, rmap_item-&gt;address);</span>
 		err = try_to_merge_one_page(vma, page,
 					    ZERO_PAGE(rmap_item-&gt;address));
<span class="p_add">+		up_read(&amp;mm-&gt;mmap_sem);</span>
 		/*
 		 * In case of failure, the page was not really empty, so we
 		 * need to continue. Otherwise we&#39;re done.
<span class="p_header">diff --git a/mm/madvise.c b/mm/madvise.c</span>
<span class="p_header">index 4d7d1e5ddba9..4edca1d86339 100644</span>
<span class="p_header">--- a/mm/madvise.c</span>
<span class="p_header">+++ b/mm/madvise.c</span>
<span class="p_chunk">@@ -614,18 +614,26 @@</span> <span class="p_context"> static int madvise_inject_error(int behavior,</span>
 {
 	struct page *page;
 	struct zone *zone;
<span class="p_add">+	unsigned int order;</span>
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
<span class="p_del">-	for (; start &lt; end; start += PAGE_SIZE &lt;&lt;</span>
<span class="p_del">-				compound_order(compound_head(page))) {</span>
<span class="p_add">+</span>
<span class="p_add">+	for (; start &lt; end; start += PAGE_SIZE &lt;&lt; order) {</span>
 		int ret;
 
 		ret = get_user_pages_fast(start, 1, 0, &amp;page);
 		if (ret != 1)
 			return ret;
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * When soft offlining hugepages, after migrating the page</span>
<span class="p_add">+		 * we dissolve it, therefore in the second loop &quot;page&quot; will</span>
<span class="p_add">+		 * no longer be a compound page, and order will be 0.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		order = compound_order(compound_head(page));</span>
<span class="p_add">+</span>
 		if (PageHWPoison(page)) {
 			put_page(page);
 			continue;
<span class="p_header">diff --git a/mm/oom_kill.c b/mm/oom_kill.c</span>
<span class="p_header">index 9e8b4f030c1c..5f6a52903770 100644</span>
<span class="p_header">--- a/mm/oom_kill.c</span>
<span class="p_header">+++ b/mm/oom_kill.c</span>
<span class="p_chunk">@@ -40,6 +40,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/ratelimit.h&gt;
 #include &lt;linux/kthread.h&gt;
 #include &lt;linux/init.h&gt;
<span class="p_add">+#include &lt;linux/mmu_notifier.h&gt;</span>
 
 #include &lt;asm/tlb.h&gt;
 #include &quot;internal.h&quot;
<span class="p_chunk">@@ -494,6 +495,21 @@</span> <span class="p_context"> static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)</span>
 		goto unlock_oom;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If the mm has notifiers then we would need to invalidate them around</span>
<span class="p_add">+	 * unmap_page_range and that is risky because notifiers can sleep and</span>
<span class="p_add">+	 * what they do is basically undeterministic.  So let&#39;s have a short</span>
<span class="p_add">+	 * sleep to give the oom victim some more time.</span>
<span class="p_add">+	 * TODO: we really want to get rid of this ugly hack and make sure that</span>
<span class="p_add">+	 * notifiers cannot block for unbounded amount of time and add</span>
<span class="p_add">+	 * mmu_notifier_invalidate_range_{start,end} around unmap_page_range</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (mm_has_notifiers(mm)) {</span>
<span class="p_add">+		up_read(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+		schedule_timeout_idle(HZ);</span>
<span class="p_add">+		goto unlock_oom;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * increase mm_users only after we know we will reap something so
 	 * that the mmput_async is called only when we have reaped something
<span class="p_header">diff --git a/mm/rodata_test.c b/mm/rodata_test.c</span>
<span class="p_header">index 6bb4deb12e78..d908c8769b48 100644</span>
<span class="p_header">--- a/mm/rodata_test.c</span>
<span class="p_header">+++ b/mm/rodata_test.c</span>
<span class="p_chunk">@@ -14,7 +14,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/uaccess.h&gt;
 #include &lt;asm/sections.h&gt;
 
<span class="p_del">-const int rodata_test_data = 0xC3;</span>
<span class="p_add">+static const int rodata_test_data = 0xC3;</span>
 
 void rodata_test(void)
 {
<span class="p_header">diff --git a/mm/swap.c b/mm/swap.c</span>
<span class="p_header">index 60b1d2a75852..ea84f04d75a4 100644</span>
<span class="p_header">--- a/mm/swap.c</span>
<span class="p_header">+++ b/mm/swap.c</span>
<span class="p_chunk">@@ -575,7 +575,7 @@</span> <span class="p_context"> static void lru_lazyfree_fn(struct page *page, struct lruvec *lruvec,</span>
 			    void *arg)
 {
 	if (PageLRU(page) &amp;&amp; PageAnon(page) &amp;&amp; PageSwapBacked(page) &amp;&amp;
<span class="p_del">-	    !PageUnevictable(page)) {</span>
<span class="p_add">+	    !PageSwapCache(page) &amp;&amp; !PageUnevictable(page)) {</span>
 		bool active = PageActive(page);
 
 		del_page_from_lru_list(page, lruvec,
<span class="p_chunk">@@ -665,7 +665,7 @@</span> <span class="p_context"> void deactivate_file_page(struct page *page)</span>
 void mark_page_lazyfree(struct page *page)
 {
 	if (PageLRU(page) &amp;&amp; PageAnon(page) &amp;&amp; PageSwapBacked(page) &amp;&amp;
<span class="p_del">-	    !PageUnevictable(page)) {</span>
<span class="p_add">+	    !PageSwapCache(page) &amp;&amp; !PageUnevictable(page)) {</span>
 		struct pagevec *pvec = &amp;get_cpu_var(lru_lazyfree_pvecs);
 
 		get_page(page);
<span class="p_header">diff --git a/mm/swap_state.c b/mm/swap_state.c</span>
<span class="p_header">index b68c93014f50..fe9309ba948c 100644</span>
<span class="p_header">--- a/mm/swap_state.c</span>
<span class="p_header">+++ b/mm/swap_state.c</span>
<span class="p_chunk">@@ -219,6 +219,17 @@</span> <span class="p_context"> int add_to_swap(struct page *page)</span>
 		 * clear SWAP_HAS_CACHE flag.
 		 */
 		goto fail;
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Normally the page will be dirtied in unmap because its pte should be</span>
<span class="p_add">+	 * dirty. A special case is MADV_FREE page. The page&#39;e pte could have</span>
<span class="p_add">+	 * dirty bit cleared but the page&#39;s SwapBacked bit is still set because</span>
<span class="p_add">+	 * clearing the dirty bit and SwapBacked bit has no lock protected. For</span>
<span class="p_add">+	 * such page, unmap will not set dirty bit for it, so page reclaim will</span>
<span class="p_add">+	 * not write the page out. This can cause data corruption when the page</span>
<span class="p_add">+	 * is swap in later. Always setting the dirty bit for the page solves</span>
<span class="p_add">+	 * the problem.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	set_page_dirty(page);</span>
 
 	return 1;
 
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index 86b4b0a79e7a..6fa30a4c60ef 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -4408,6 +4408,7 @@</span> <span class="p_context"> static u32 netif_receive_generic_xdp(struct sk_buff *skb,</span>
 		__skb_pull(skb, off);
 	else if (off &lt; 0)
 		__skb_push(skb, -off);
<span class="p_add">+	skb-&gt;mac_header += off;</span>
 
 	switch (act) {
 	case XDP_TX:
<span class="p_header">diff --git a/net/core/filter.c b/net/core/filter.c</span>
<span class="p_header">index 169974998c76..18d591f1ae5a 100644</span>
<span class="p_header">--- a/net/core/filter.c</span>
<span class="p_header">+++ b/net/core/filter.c</span>
<span class="p_chunk">@@ -975,10 +975,14 @@</span> <span class="p_context"> static bool __sk_filter_charge(struct sock *sk, struct sk_filter *fp)</span>
 
 bool sk_filter_charge(struct sock *sk, struct sk_filter *fp)
 {
<span class="p_del">-	bool ret = __sk_filter_charge(sk, fp);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		refcount_inc(&amp;fp-&gt;refcnt);</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	if (!refcount_inc_not_zero(&amp;fp-&gt;refcnt))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!__sk_filter_charge(sk, fp)) {</span>
<span class="p_add">+		sk_filter_release(fp);</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return true;</span>
 }
 
 static struct bpf_prog *bpf_migrate_filter(struct bpf_prog *fp)
<span class="p_header">diff --git a/net/core/gen_estimator.c b/net/core/gen_estimator.c</span>
<span class="p_header">index 0385dece1f6f..7c1ffd6f9501 100644</span>
<span class="p_header">--- a/net/core/gen_estimator.c</span>
<span class="p_header">+++ b/net/core/gen_estimator.c</span>
<span class="p_chunk">@@ -83,10 +83,10 @@</span> <span class="p_context"> static void est_timer(unsigned long arg)</span>
 	u64 rate, brate;
 
 	est_fetch_counters(est, &amp;b);
<span class="p_del">-	brate = (b.bytes - est-&gt;last_bytes) &lt;&lt; (8 - est-&gt;ewma_log);</span>
<span class="p_add">+	brate = (b.bytes - est-&gt;last_bytes) &lt;&lt; (10 - est-&gt;ewma_log - est-&gt;intvl_log);</span>
 	brate -= (est-&gt;avbps &gt;&gt; est-&gt;ewma_log);
 
<span class="p_del">-	rate = (u64)(b.packets - est-&gt;last_packets) &lt;&lt; (8 - est-&gt;ewma_log);</span>
<span class="p_add">+	rate = (u64)(b.packets - est-&gt;last_packets) &lt;&lt; (10 - est-&gt;ewma_log - est-&gt;intvl_log);</span>
 	rate -= (est-&gt;avpps &gt;&gt; est-&gt;ewma_log);
 
 	write_seqcount_begin(&amp;est-&gt;seq);
<span class="p_header">diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c</span>
<span class="p_header">index 9201e3621351..e07c8847c6cf 100644</span>
<span class="p_header">--- a/net/core/rtnetlink.c</span>
<span class="p_header">+++ b/net/core/rtnetlink.c</span>
<span class="p_chunk">@@ -3867,6 +3867,9 @@</span> <span class="p_context"> static int rtnl_fill_statsinfo(struct sk_buff *skb, struct net_device *dev,</span>
 		return -EMSGSIZE;
 
 	ifsm = nlmsg_data(nlh);
<span class="p_add">+	ifsm-&gt;family = PF_UNSPEC;</span>
<span class="p_add">+	ifsm-&gt;pad1 = 0;</span>
<span class="p_add">+	ifsm-&gt;pad2 = 0;</span>
 	ifsm-&gt;ifindex = dev-&gt;ifindex;
 	ifsm-&gt;filter_mask = filter_mask;
 
<span class="p_header">diff --git a/net/core/sock.c b/net/core/sock.c</span>
<span class="p_header">index ac2a404c73eb..0967da925022 100644</span>
<span class="p_header">--- a/net/core/sock.c</span>
<span class="p_header">+++ b/net/core/sock.c</span>
<span class="p_chunk">@@ -1646,6 +1646,8 @@</span> <span class="p_context"> struct sock *sk_clone_lock(const struct sock *sk, const gfp_t priority)</span>
 
 		sock_copy(newsk, sk);
 
<span class="p_add">+		newsk-&gt;sk_prot_creator = sk-&gt;sk_prot;</span>
<span class="p_add">+</span>
 		/* SANITY */
 		if (likely(newsk-&gt;sk_net_refcnt))
 			get_net(sock_net(newsk));
<span class="p_chunk">@@ -1673,13 +1675,16 @@</span> <span class="p_context"> struct sock *sk_clone_lock(const struct sock *sk, const gfp_t priority)</span>
 
 		sock_reset_flag(newsk, SOCK_DONE);
 
<span class="p_del">-		filter = rcu_dereference_protected(newsk-&gt;sk_filter, 1);</span>
<span class="p_add">+		rcu_read_lock();</span>
<span class="p_add">+		filter = rcu_dereference(sk-&gt;sk_filter);</span>
 		if (filter != NULL)
 			/* though it&#39;s an empty new sock, the charging may fail
 			 * if sysctl_optmem_max was changed between creation of
 			 * original socket and cloning
 			 */
 			is_charged = sk_filter_charge(newsk, filter);
<span class="p_add">+		RCU_INIT_POINTER(newsk-&gt;sk_filter, filter);</span>
<span class="p_add">+		rcu_read_unlock();</span>
 
 		if (unlikely(!is_charged || xfrm_sk_clone_policy(newsk, sk))) {
 			/* We need to make sure that we don&#39;t uncharge the new
<span class="p_header">diff --git a/net/dsa/slave.c b/net/dsa/slave.c</span>
<span class="p_header">index 9507bd38cf04..07677540129a 100644</span>
<span class="p_header">--- a/net/dsa/slave.c</span>
<span class="p_header">+++ b/net/dsa/slave.c</span>
<span class="p_chunk">@@ -1180,26 +1180,32 @@</span> <span class="p_context"> int dsa_slave_create(struct dsa_switch *ds, struct device *parent,</span>
 	p-&gt;old_duplex = -1;
 
 	ds-&gt;ports[port].netdev = slave_dev;
<span class="p_del">-	ret = register_netdev(slave_dev);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		netdev_err(master, &quot;error %d registering interface %s\n&quot;,</span>
<span class="p_del">-			   ret, slave_dev-&gt;name);</span>
<span class="p_del">-		ds-&gt;ports[port].netdev = NULL;</span>
<span class="p_del">-		free_netdev(slave_dev);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
 
 	netif_carrier_off(slave_dev);
 
 	ret = dsa_slave_phy_setup(p, slave_dev);
 	if (ret) {
 		netdev_err(master, &quot;error %d setting up slave phy\n&quot;, ret);
<span class="p_del">-		unregister_netdev(slave_dev);</span>
<span class="p_del">-		free_netdev(slave_dev);</span>
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto out_free;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = register_netdev(slave_dev);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		netdev_err(master, &quot;error %d registering interface %s\n&quot;,</span>
<span class="p_add">+			   ret, slave_dev-&gt;name);</span>
<span class="p_add">+		goto out_phy;</span>
 	}
 
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+out_phy:</span>
<span class="p_add">+	phy_disconnect(p-&gt;phy);</span>
<span class="p_add">+	if (of_phy_is_fixed_link(p-&gt;dp-&gt;dn))</span>
<span class="p_add">+		of_phy_deregister_fixed_link(p-&gt;dp-&gt;dn);</span>
<span class="p_add">+out_free:</span>
<span class="p_add">+	free_netdev(slave_dev);</span>
<span class="p_add">+	ds-&gt;ports[port].netdev = NULL;</span>
<span class="p_add">+	return ret;</span>
 }
 
 void dsa_slave_destroy(struct net_device *slave_dev)
<span class="p_header">diff --git a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c</span>
<span class="p_header">index fa2dc8f692c6..57fc13c6ab2b 100644</span>
<span class="p_header">--- a/net/ipv4/ip_input.c</span>
<span class="p_header">+++ b/net/ipv4/ip_input.c</span>
<span class="p_chunk">@@ -311,9 +311,10 @@</span> <span class="p_context"> static inline bool ip_rcv_options(struct sk_buff *skb)</span>
 static int ip_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
 {
 	const struct iphdr *iph = ip_hdr(skb);
<span class="p_del">-	struct rtable *rt;</span>
<span class="p_add">+	int (*edemux)(struct sk_buff *skb);</span>
 	struct net_device *dev = skb-&gt;dev;
<span class="p_del">-	void (*edemux)(struct sk_buff *skb);</span>
<span class="p_add">+	struct rtable *rt;</span>
<span class="p_add">+	int err;</span>
 
 	/* if ingress device is enslaved to an L3 master device pass the
 	 * skb to its handler for processing
<span class="p_chunk">@@ -331,7 +332,9 @@</span> <span class="p_context"> static int ip_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)</span>
 
 		ipprot = rcu_dereference(inet_protos[protocol]);
 		if (ipprot &amp;&amp; (edemux = READ_ONCE(ipprot-&gt;early_demux))) {
<span class="p_del">-			edemux(skb);</span>
<span class="p_add">+			err = edemux(skb);</span>
<span class="p_add">+			if (unlikely(err))</span>
<span class="p_add">+				goto drop_error;</span>
 			/* must reload iph, skb-&gt;head might have changed */
 			iph = ip_hdr(skb);
 		}
<span class="p_chunk">@@ -342,13 +345,10 @@</span> <span class="p_context"> static int ip_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)</span>
 	 *	how the packet travels inside Linux networking.
 	 */
 	if (!skb_valid_dst(skb)) {
<span class="p_del">-		int err = ip_route_input_noref(skb, iph-&gt;daddr, iph-&gt;saddr,</span>
<span class="p_del">-					       iph-&gt;tos, dev);</span>
<span class="p_del">-		if (unlikely(err)) {</span>
<span class="p_del">-			if (err == -EXDEV)</span>
<span class="p_del">-				__NET_INC_STATS(net, LINUX_MIB_IPRPFILTER);</span>
<span class="p_del">-			goto drop;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		err = ip_route_input_noref(skb, iph-&gt;daddr, iph-&gt;saddr,</span>
<span class="p_add">+					   iph-&gt;tos, dev);</span>
<span class="p_add">+		if (unlikely(err))</span>
<span class="p_add">+			goto drop_error;</span>
 	}
 
 #ifdef CONFIG_IP_ROUTE_CLASSID
<span class="p_chunk">@@ -399,6 +399,11 @@</span> <span class="p_context"> static int ip_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)</span>
 drop:
 	kfree_skb(skb);
 	return NET_RX_DROP;
<span class="p_add">+</span>
<span class="p_add">+drop_error:</span>
<span class="p_add">+	if (err == -EXDEV)</span>
<span class="p_add">+		__NET_INC_STATS(net, LINUX_MIB_IPRPFILTER);</span>
<span class="p_add">+	goto drop;</span>
 }
 
 /*
<span class="p_header">diff --git a/net/ipv4/ip_vti.c b/net/ipv4/ip_vti.c</span>
<span class="p_header">index 0192c255e508..74bd46c5bda7 100644</span>
<span class="p_header">--- a/net/ipv4/ip_vti.c</span>
<span class="p_header">+++ b/net/ipv4/ip_vti.c</span>
<span class="p_chunk">@@ -168,6 +168,7 @@</span> <span class="p_context"> static netdev_tx_t vti_xmit(struct sk_buff *skb, struct net_device *dev,</span>
 	struct ip_tunnel_parm *parms = &amp;tunnel-&gt;parms;
 	struct dst_entry *dst = skb_dst(skb);
 	struct net_device *tdev;	/* Device to other host */
<span class="p_add">+	int pkt_len = skb-&gt;len;</span>
 	int err;
 	int mtu;
 
<span class="p_chunk">@@ -229,7 +230,7 @@</span> <span class="p_context"> static netdev_tx_t vti_xmit(struct sk_buff *skb, struct net_device *dev,</span>
 
 	err = dst_output(tunnel-&gt;net, skb-&gt;sk, skb);
 	if (net_xmit_eval(err) == 0)
<span class="p_del">-		err = skb-&gt;len;</span>
<span class="p_add">+		err = pkt_len;</span>
 	iptunnel_xmit_stats(dev, err);
 	return NETDEV_TX_OK;
 
<span class="p_header">diff --git a/net/ipv4/route.c b/net/ipv4/route.c</span>
<span class="p_header">index 2331de20ca50..c5aa25be7108 100644</span>
<span class="p_header">--- a/net/ipv4/route.c</span>
<span class="p_header">+++ b/net/ipv4/route.c</span>
<span class="p_chunk">@@ -1520,43 +1520,56 @@</span> <span class="p_context"> struct rtable *rt_dst_alloc(struct net_device *dev,</span>
 EXPORT_SYMBOL(rt_dst_alloc);
 
 /* called in rcu_read_lock() section */
<span class="p_del">-static int ip_route_input_mc(struct sk_buff *skb, __be32 daddr, __be32 saddr,</span>
<span class="p_del">-				u8 tos, struct net_device *dev, int our)</span>
<span class="p_add">+int ip_mc_validate_source(struct sk_buff *skb, __be32 daddr, __be32 saddr,</span>
<span class="p_add">+			  u8 tos, struct net_device *dev,</span>
<span class="p_add">+			  struct in_device *in_dev, u32 *itag)</span>
 {
<span class="p_del">-	struct rtable *rth;</span>
<span class="p_del">-	struct in_device *in_dev = __in_dev_get_rcu(dev);</span>
<span class="p_del">-	unsigned int flags = RTCF_MULTICAST;</span>
<span class="p_del">-	u32 itag = 0;</span>
 	int err;
 
 	/* Primary sanity checks. */
<span class="p_del">-</span>
 	if (!in_dev)
 		return -EINVAL;
 
 	if (ipv4_is_multicast(saddr) || ipv4_is_lbcast(saddr) ||
 	    skb-&gt;protocol != htons(ETH_P_IP))
<span class="p_del">-		goto e_inval;</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	if (ipv4_is_loopback(saddr) &amp;&amp; !IN_DEV_ROUTE_LOCALNET(in_dev))
<span class="p_del">-		goto e_inval;</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	if (ipv4_is_zeronet(saddr)) {
 		if (!ipv4_is_local_multicast(daddr))
<span class="p_del">-			goto e_inval;</span>
<span class="p_add">+			return -EINVAL;</span>
 	} else {
 		err = fib_validate_source(skb, saddr, 0, tos, 0, dev,
<span class="p_del">-					  in_dev, &amp;itag);</span>
<span class="p_add">+					  in_dev, itag);</span>
 		if (err &lt; 0)
<span class="p_del">-			goto e_err;</span>
<span class="p_add">+			return err;</span>
 	}
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* called in rcu_read_lock() section */</span>
<span class="p_add">+static int ip_route_input_mc(struct sk_buff *skb, __be32 daddr, __be32 saddr,</span>
<span class="p_add">+			     u8 tos, struct net_device *dev, int our)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct in_device *in_dev = __in_dev_get_rcu(dev);</span>
<span class="p_add">+	unsigned int flags = RTCF_MULTICAST;</span>
<span class="p_add">+	struct rtable *rth;</span>
<span class="p_add">+	u32 itag = 0;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = ip_mc_validate_source(skb, daddr, saddr, tos, dev, in_dev, &amp;itag);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
 	if (our)
 		flags |= RTCF_LOCAL;
 
 	rth = rt_dst_alloc(dev_net(dev)-&gt;loopback_dev, flags, RTN_MULTICAST,
 			   IN_DEV_CONF_GET(in_dev, NOPOLICY), false, false);
 	if (!rth)
<span class="p_del">-		goto e_nobufs;</span>
<span class="p_add">+		return -ENOBUFS;</span>
 
 #ifdef CONFIG_IP_ROUTE_CLASSID
 	rth-&gt;dst.tclassid = itag;
<span class="p_chunk">@@ -1572,13 +1585,6 @@</span> <span class="p_context"> static int ip_route_input_mc(struct sk_buff *skb, __be32 daddr, __be32 saddr,</span>
 
 	skb_dst_set(skb, &amp;rth-&gt;dst);
 	return 0;
<span class="p_del">-</span>
<span class="p_del">-e_nobufs:</span>
<span class="p_del">-	return -ENOBUFS;</span>
<span class="p_del">-e_inval:</span>
<span class="p_del">-	return -EINVAL;</span>
<span class="p_del">-e_err:</span>
<span class="p_del">-	return err;</span>
 }
 
 
<span class="p_header">diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c</span>
<span class="p_header">index 21022db7a2a6..b1441bc8192f 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_ipv4.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_ipv4.c</span>
<span class="p_chunk">@@ -1504,23 +1504,23 @@</span> <span class="p_context"> int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)</span>
 }
 EXPORT_SYMBOL(tcp_v4_do_rcv);
 
<span class="p_del">-void tcp_v4_early_demux(struct sk_buff *skb)</span>
<span class="p_add">+int tcp_v4_early_demux(struct sk_buff *skb)</span>
 {
 	const struct iphdr *iph;
 	const struct tcphdr *th;
 	struct sock *sk;
 
 	if (skb-&gt;pkt_type != PACKET_HOST)
<span class="p_del">-		return;</span>
<span class="p_add">+		return 0;</span>
 
 	if (!pskb_may_pull(skb, skb_transport_offset(skb) + sizeof(struct tcphdr)))
<span class="p_del">-		return;</span>
<span class="p_add">+		return 0;</span>
 
 	iph = ip_hdr(skb);
 	th = tcp_hdr(skb);
 
 	if (th-&gt;doff &lt; sizeof(struct tcphdr) / 4)
<span class="p_del">-		return;</span>
<span class="p_add">+		return 0;</span>
 
 	sk = __inet_lookup_established(dev_net(skb-&gt;dev), &amp;tcp_hashinfo,
 				       iph-&gt;saddr, th-&gt;source,
<span class="p_chunk">@@ -1539,6 +1539,7 @@</span> <span class="p_context"> void tcp_v4_early_demux(struct sk_buff *skb)</span>
 				skb_dst_set_noref(skb, dst);
 		}
 	}
<span class="p_add">+	return 0;</span>
 }
 
 /* Packet is added to VJ-style prequeue for processing in process
<span class="p_header">diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c</span>
<span class="p_header">index b7661a68d498..40f7c8ee9ba6 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_output.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_output.c</span>
<span class="p_chunk">@@ -991,6 +991,7 @@</span> <span class="p_context"> static int tcp_transmit_skb(struct sock *sk, struct sk_buff *skb, int clone_it,</span>
 	struct tcp_skb_cb *tcb;
 	struct tcp_out_options opts;
 	unsigned int tcp_options_size, tcp_header_size;
<span class="p_add">+	struct sk_buff *oskb = NULL;</span>
 	struct tcp_md5sig_key *md5;
 	struct tcphdr *th;
 	int err;
<span class="p_chunk">@@ -998,12 +999,10 @@</span> <span class="p_context"> static int tcp_transmit_skb(struct sock *sk, struct sk_buff *skb, int clone_it,</span>
 	BUG_ON(!skb || !tcp_skb_pcount(skb));
 	tp = tcp_sk(sk);
 
<span class="p_del">-	skb-&gt;skb_mstamp = tp-&gt;tcp_mstamp;</span>
 	if (clone_it) {
 		TCP_SKB_CB(skb)-&gt;tx.in_flight = TCP_SKB_CB(skb)-&gt;end_seq
 			- tp-&gt;snd_una;
<span class="p_del">-		tcp_rate_skb_sent(sk, skb);</span>
<span class="p_del">-</span>
<span class="p_add">+		oskb = skb;</span>
 		if (unlikely(skb_cloned(skb)))
 			skb = pskb_copy(skb, gfp_mask);
 		else
<span class="p_chunk">@@ -1011,6 +1010,7 @@</span> <span class="p_context"> static int tcp_transmit_skb(struct sock *sk, struct sk_buff *skb, int clone_it,</span>
 		if (unlikely(!skb))
 			return -ENOBUFS;
 	}
<span class="p_add">+	skb-&gt;skb_mstamp = tp-&gt;tcp_mstamp;</span>
 
 	inet = inet_sk(sk);
 	tcb = TCP_SKB_CB(skb);
<span class="p_chunk">@@ -1122,12 +1122,15 @@</span> <span class="p_context"> static int tcp_transmit_skb(struct sock *sk, struct sk_buff *skb, int clone_it,</span>
 
 	err = icsk-&gt;icsk_af_ops-&gt;queue_xmit(sk, skb, &amp;inet-&gt;cork.fl);
 
<span class="p_del">-	if (likely(err &lt;= 0))</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-</span>
<span class="p_del">-	tcp_enter_cwr(sk);</span>
<span class="p_del">-</span>
<span class="p_del">-	return net_xmit_eval(err);</span>
<span class="p_add">+	if (unlikely(err &gt; 0)) {</span>
<span class="p_add">+		tcp_enter_cwr(sk);</span>
<span class="p_add">+		err = net_xmit_eval(err);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (!err &amp;&amp; oskb) {</span>
<span class="p_add">+		oskb-&gt;skb_mstamp = tp-&gt;tcp_mstamp;</span>
<span class="p_add">+		tcp_rate_skb_sent(sk, oskb);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return err;</span>
 }
 
 /* This routine just queues the buffer for sending.
<span class="p_chunk">@@ -2866,10 +2869,11 @@</span> <span class="p_context"> int __tcp_retransmit_skb(struct sock *sk, struct sk_buff *skb, int segs)</span>
 		     skb_headroom(skb) &gt;= 0xFFFF)) {
 		struct sk_buff *nskb;
 
<span class="p_del">-		skb-&gt;skb_mstamp = tp-&gt;tcp_mstamp;</span>
 		nskb = __pskb_copy(skb, MAX_TCP_HEADER, GFP_ATOMIC);
 		err = nskb ? tcp_transmit_skb(sk, nskb, 0, GFP_ATOMIC) :
 			     -ENOBUFS;
<span class="p_add">+		if (!err)</span>
<span class="p_add">+			skb-&gt;skb_mstamp = tp-&gt;tcp_mstamp;</span>
 	} else {
 		err = tcp_transmit_skb(sk, skb, 1, GFP_ATOMIC);
 	}
<span class="p_chunk">@@ -3416,6 +3420,10 @@</span> <span class="p_context"> static int tcp_send_syn_data(struct sock *sk, struct sk_buff *syn)</span>
 		goto done;
 	}
 
<span class="p_add">+	/* data was not sent, this is our new send_head */</span>
<span class="p_add">+	sk-&gt;sk_send_head = syn_data;</span>
<span class="p_add">+	tp-&gt;packets_out -= tcp_skb_pcount(syn_data);</span>
<span class="p_add">+</span>
 fallback:
 	/* Send a regular SYN with Fast Open cookie request option */
 	if (fo-&gt;cookie.len &gt; 0)
<span class="p_chunk">@@ -3468,6 +3476,11 @@</span> <span class="p_context"> int tcp_connect(struct sock *sk)</span>
 	 */
 	tp-&gt;snd_nxt = tp-&gt;write_seq;
 	tp-&gt;pushed_seq = tp-&gt;write_seq;
<span class="p_add">+	buff = tcp_send_head(sk);</span>
<span class="p_add">+	if (unlikely(buff)) {</span>
<span class="p_add">+		tp-&gt;snd_nxt	= TCP_SKB_CB(buff)-&gt;seq;</span>
<span class="p_add">+		tp-&gt;pushed_seq	= TCP_SKB_CB(buff)-&gt;seq;</span>
<span class="p_add">+	}</span>
 	TCP_INC_STATS(sock_net(sk), TCP_MIB_ACTIVEOPENS);
 
 	/* Timer for repeating the SYN until an answer. */
<span class="p_header">diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c</span>
<span class="p_header">index 979e4d8526ba..84861d71face 100644</span>
<span class="p_header">--- a/net/ipv4/udp.c</span>
<span class="p_header">+++ b/net/ipv4/udp.c</span>
<span class="p_chunk">@@ -2217,9 +2217,10 @@</span> <span class="p_context"> static struct sock *__udp4_lib_demux_lookup(struct net *net,</span>
 	return NULL;
 }
 
<span class="p_del">-void udp_v4_early_demux(struct sk_buff *skb)</span>
<span class="p_add">+int udp_v4_early_demux(struct sk_buff *skb)</span>
 {
 	struct net *net = dev_net(skb-&gt;dev);
<span class="p_add">+	struct in_device *in_dev = NULL;</span>
 	const struct iphdr *iph;
 	const struct udphdr *uh;
 	struct sock *sk = NULL;
<span class="p_chunk">@@ -2229,25 +2230,21 @@</span> <span class="p_context"> void udp_v4_early_demux(struct sk_buff *skb)</span>
 
 	/* validate the packet */
 	if (!pskb_may_pull(skb, skb_transport_offset(skb) + sizeof(struct udphdr)))
<span class="p_del">-		return;</span>
<span class="p_add">+		return 0;</span>
 
 	iph = ip_hdr(skb);
 	uh = udp_hdr(skb);
 
<span class="p_del">-	if (skb-&gt;pkt_type == PACKET_BROADCAST ||</span>
<span class="p_del">-	    skb-&gt;pkt_type == PACKET_MULTICAST) {</span>
<span class="p_del">-		struct in_device *in_dev = __in_dev_get_rcu(skb-&gt;dev);</span>
<span class="p_add">+	if (skb-&gt;pkt_type == PACKET_MULTICAST) {</span>
<span class="p_add">+		in_dev = __in_dev_get_rcu(skb-&gt;dev);</span>
 
 		if (!in_dev)
<span class="p_del">-			return;</span>
<span class="p_add">+			return 0;</span>
 
<span class="p_del">-		/* we are supposed to accept bcast packets */</span>
<span class="p_del">-		if (skb-&gt;pkt_type == PACKET_MULTICAST) {</span>
<span class="p_del">-			ours = ip_check_mc_rcu(in_dev, iph-&gt;daddr, iph-&gt;saddr,</span>
<span class="p_del">-					       iph-&gt;protocol);</span>
<span class="p_del">-			if (!ours)</span>
<span class="p_del">-				return;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		ours = ip_check_mc_rcu(in_dev, iph-&gt;daddr, iph-&gt;saddr,</span>
<span class="p_add">+				       iph-&gt;protocol);</span>
<span class="p_add">+		if (!ours)</span>
<span class="p_add">+			return 0;</span>
 
 		sk = __udp4_lib_mcast_demux_lookup(net, uh-&gt;dest, iph-&gt;daddr,
 						   uh-&gt;source, iph-&gt;saddr, dif);
<span class="p_chunk">@@ -2257,7 +2254,7 @@</span> <span class="p_context"> void udp_v4_early_demux(struct sk_buff *skb)</span>
 	}
 
 	if (!sk || !refcount_inc_not_zero(&amp;sk-&gt;sk_refcnt))
<span class="p_del">-		return;</span>
<span class="p_add">+		return 0;</span>
 
 	skb-&gt;sk = sk;
 	skb-&gt;destructor = sock_efree;
<span class="p_chunk">@@ -2266,12 +2263,23 @@</span> <span class="p_context"> void udp_v4_early_demux(struct sk_buff *skb)</span>
 	if (dst)
 		dst = dst_check(dst, 0);
 	if (dst) {
<span class="p_add">+		u32 itag = 0;</span>
<span class="p_add">+</span>
 		/* set noref for now.
 		 * any place which wants to hold dst has to call
 		 * dst_hold_safe()
 		 */
 		skb_dst_set_noref(skb, dst);
<span class="p_add">+</span>
<span class="p_add">+		/* for unconnected multicast sockets we need to validate</span>
<span class="p_add">+		 * the source on each packet</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!inet_sk(sk)-&gt;inet_daddr &amp;&amp; in_dev)</span>
<span class="p_add">+			return ip_mc_validate_source(skb, iph-&gt;daddr,</span>
<span class="p_add">+						     iph-&gt;saddr, iph-&gt;tos,</span>
<span class="p_add">+						     skb-&gt;dev, in_dev, &amp;itag);</span>
 	}
<span class="p_add">+	return 0;</span>
 }
 
 int udp_rcv(struct sk_buff *skb)
<span class="p_header">diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c</span>
<span class="p_header">index 936e9ab4dda5..ba757c28a301 100644</span>
<span class="p_header">--- a/net/ipv6/addrconf.c</span>
<span class="p_header">+++ b/net/ipv6/addrconf.c</span>
<span class="p_chunk">@@ -4982,9 +4982,10 @@</span> <span class="p_context"> static void inet6_ifa_notify(int event, struct inet6_ifaddr *ifa)</span>
 
 	/* Don&#39;t send DELADDR notification for TENTATIVE address,
 	 * since NEWADDR notification is sent only after removing
<span class="p_del">-	 * TENTATIVE flag.</span>
<span class="p_add">+	 * TENTATIVE flag, if DAD has not failed.</span>
 	 */
<span class="p_del">-	if (ifa-&gt;flags &amp; IFA_F_TENTATIVE &amp;&amp; event == RTM_DELADDR)</span>
<span class="p_add">+	if (ifa-&gt;flags &amp; IFA_F_TENTATIVE &amp;&amp; !(ifa-&gt;flags &amp; IFA_F_DADFAILED) &amp;&amp;</span>
<span class="p_add">+	    event == RTM_DELADDR)</span>
 		return;
 
 	skb = nlmsg_new(inet6_ifaddr_msgsize(), GFP_ATOMIC);
<span class="p_header">diff --git a/net/ipv6/ip6_gre.c b/net/ipv6/ip6_gre.c</span>
<span class="p_header">index b7a72d409334..1602b491b281 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_gre.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_gre.c</span>
<span class="p_chunk">@@ -940,24 +940,25 @@</span> <span class="p_context"> static int ip6gre_tunnel_ioctl(struct net_device *dev,</span>
 }
 
 static int ip6gre_header(struct sk_buff *skb, struct net_device *dev,
<span class="p_del">-			unsigned short type,</span>
<span class="p_del">-			const void *daddr, const void *saddr, unsigned int len)</span>
<span class="p_add">+			 unsigned short type, const void *daddr,</span>
<span class="p_add">+			 const void *saddr, unsigned int len)</span>
 {
 	struct ip6_tnl *t = netdev_priv(dev);
<span class="p_del">-	struct ipv6hdr *ipv6h = skb_push(skb, t-&gt;hlen);</span>
<span class="p_del">-	__be16 *p = (__be16 *)(ipv6h+1);</span>
<span class="p_add">+	struct ipv6hdr *ipv6h;</span>
<span class="p_add">+	__be16 *p;</span>
 
<span class="p_del">-	ip6_flow_hdr(ipv6h, 0,</span>
<span class="p_del">-		     ip6_make_flowlabel(dev_net(dev), skb,</span>
<span class="p_del">-					t-&gt;fl.u.ip6.flowlabel, true,</span>
<span class="p_del">-					&amp;t-&gt;fl.u.ip6));</span>
<span class="p_add">+	ipv6h = skb_push(skb, t-&gt;hlen + sizeof(*ipv6h));</span>
<span class="p_add">+	ip6_flow_hdr(ipv6h, 0, ip6_make_flowlabel(dev_net(dev), skb,</span>
<span class="p_add">+						  t-&gt;fl.u.ip6.flowlabel,</span>
<span class="p_add">+						  true, &amp;t-&gt;fl.u.ip6));</span>
 	ipv6h-&gt;hop_limit = t-&gt;parms.hop_limit;
 	ipv6h-&gt;nexthdr = NEXTHDR_GRE;
 	ipv6h-&gt;saddr = t-&gt;parms.laddr;
 	ipv6h-&gt;daddr = t-&gt;parms.raddr;
 
<span class="p_del">-	p[0]		= t-&gt;parms.o_flags;</span>
<span class="p_del">-	p[1]		= htons(type);</span>
<span class="p_add">+	p = (__be16 *)(ipv6h + 1);</span>
<span class="p_add">+	p[0] = t-&gt;parms.o_flags;</span>
<span class="p_add">+	p[1] = htons(type);</span>
 
 	/*
 	 *	Set the source hardware address.
<span class="p_chunk">@@ -1310,6 +1311,7 @@</span> <span class="p_context"> static void ip6gre_tap_setup(struct net_device *dev)</span>
 	dev-&gt;features |= NETIF_F_NETNS_LOCAL;
 	dev-&gt;priv_flags &amp;= ~IFF_TX_SKB_SHARING;
 	dev-&gt;priv_flags |= IFF_LIVE_ADDR_CHANGE;
<span class="p_add">+	netif_keep_dst(dev);</span>
 }
 
 static bool ip6gre_netlink_encap_parms(struct nlattr *data[],
<span class="p_header">diff --git a/net/ipv6/ip6_tunnel.c b/net/ipv6/ip6_tunnel.c</span>
<span class="p_header">index 3a0ba2ae4b0f..4425b4411bb9 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_tunnel.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_tunnel.c</span>
<span class="p_chunk">@@ -1043,6 +1043,7 @@</span> <span class="p_context"> int ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev, __u8 dsfield,</span>
 	struct dst_entry *dst = NULL, *ndst = NULL;
 	struct net_device *tdev;
 	int mtu;
<span class="p_add">+	unsigned int eth_hlen = t-&gt;dev-&gt;type == ARPHRD_ETHER ? ETH_HLEN : 0;</span>
 	unsigned int psh_hlen = sizeof(struct ipv6hdr) + t-&gt;encap_hlen;
 	unsigned int max_headroom = psh_hlen;
 	bool use_cache = false;
<span class="p_chunk">@@ -1124,7 +1125,7 @@</span> <span class="p_context"> int ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev, __u8 dsfield,</span>
 				     t-&gt;parms.name);
 		goto tx_err_dst_release;
 	}
<span class="p_del">-	mtu = dst_mtu(dst) - psh_hlen - t-&gt;tun_hlen;</span>
<span class="p_add">+	mtu = dst_mtu(dst) - eth_hlen - psh_hlen - t-&gt;tun_hlen;</span>
 	if (encap_limit &gt;= 0) {
 		max_headroom += 8;
 		mtu -= 8;
<span class="p_chunk">@@ -1133,7 +1134,7 @@</span> <span class="p_context"> int ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev, __u8 dsfield,</span>
 		mtu = IPV6_MIN_MTU;
 	if (skb_dst(skb) &amp;&amp; !t-&gt;parms.collect_md)
 		skb_dst(skb)-&gt;ops-&gt;update_pmtu(skb_dst(skb), NULL, skb, mtu);
<span class="p_del">-	if (skb-&gt;len - t-&gt;tun_hlen &gt; mtu &amp;&amp; !skb_is_gso(skb)) {</span>
<span class="p_add">+	if (skb-&gt;len - t-&gt;tun_hlen - eth_hlen &gt; mtu &amp;&amp; !skb_is_gso(skb)) {</span>
 		*pmtu = mtu;
 		err = -EMSGSIZE;
 		goto tx_err_dst_release;
<span class="p_chunk">@@ -2258,6 +2259,9 @@</span> <span class="p_context"> static int __init ip6_tunnel_init(void)</span>
 {
 	int  err;
 
<span class="p_add">+	if (!ipv6_mod_enabled())</span>
<span class="p_add">+		return -EOPNOTSUPP;</span>
<span class="p_add">+</span>
 	err = register_pernet_device(&amp;ip6_tnl_net_ops);
 	if (err &lt; 0)
 		goto out_pernet;
<span class="p_header">diff --git a/net/ipv6/ip6_vti.c b/net/ipv6/ip6_vti.c</span>
<span class="p_header">index 486c2305f53c..e3e3ea655464 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_vti.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_vti.c</span>
<span class="p_chunk">@@ -445,6 +445,7 @@</span> <span class="p_context"> vti6_xmit(struct sk_buff *skb, struct net_device *dev, struct flowi *fl)</span>
 	struct dst_entry *dst = skb_dst(skb);
 	struct net_device *tdev;
 	struct xfrm_state *x;
<span class="p_add">+	int pkt_len = skb-&gt;len;</span>
 	int err = -1;
 	int mtu;
 
<span class="p_chunk">@@ -502,7 +503,7 @@</span> <span class="p_context"> vti6_xmit(struct sk_buff *skb, struct net_device *dev, struct flowi *fl)</span>
 		struct pcpu_sw_netstats *tstats = this_cpu_ptr(dev-&gt;tstats);
 
 		u64_stats_update_begin(&amp;tstats-&gt;syncp);
<span class="p_del">-		tstats-&gt;tx_bytes += skb-&gt;len;</span>
<span class="p_add">+		tstats-&gt;tx_bytes += pkt_len;</span>
 		tstats-&gt;tx_packets++;
 		u64_stats_update_end(&amp;tstats-&gt;syncp);
 	} else {
<span class="p_header">diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c</span>
<span class="p_header">index d6886228e1d0..30b4d55e88f3 100644</span>
<span class="p_header">--- a/net/ipv6/udp.c</span>
<span class="p_header">+++ b/net/ipv6/udp.c</span>
<span class="p_chunk">@@ -1011,6 +1011,7 @@</span> <span class="p_context"> static void udp6_hwcsum_outgoing(struct sock *sk, struct sk_buff *skb,</span>
 		 */
 		offset = skb_transport_offset(skb);
 		skb-&gt;csum = skb_checksum(skb, offset, skb-&gt;len - offset, 0);
<span class="p_add">+		csum = skb-&gt;csum;</span>
 
 		skb-&gt;ip_summed = CHECKSUM_NONE;
 
<span class="p_header">diff --git a/net/l2tp/l2tp_core.c b/net/l2tp/l2tp_core.c</span>
<span class="p_header">index 90165a6874bc..525c66f1121a 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_core.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_core.c</span>
<span class="p_chunk">@@ -1665,14 +1665,12 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(l2tp_tunnel_create);</span>
 
 /* This function is used by the netlink TUNNEL_DELETE command.
  */
<span class="p_del">-int l2tp_tunnel_delete(struct l2tp_tunnel *tunnel)</span>
<span class="p_add">+void l2tp_tunnel_delete(struct l2tp_tunnel *tunnel)</span>
 {
<span class="p_del">-	l2tp_tunnel_inc_refcount(tunnel);</span>
<span class="p_del">-	if (false == queue_work(l2tp_wq, &amp;tunnel-&gt;del_work)) {</span>
<span class="p_del">-		l2tp_tunnel_dec_refcount(tunnel);</span>
<span class="p_del">-		return 1;</span>
<span class="p_add">+	if (!test_and_set_bit(0, &amp;tunnel-&gt;dead)) {</span>
<span class="p_add">+		l2tp_tunnel_inc_refcount(tunnel);</span>
<span class="p_add">+		queue_work(l2tp_wq, &amp;tunnel-&gt;del_work);</span>
 	}
<span class="p_del">-	return 0;</span>
 }
 EXPORT_SYMBOL_GPL(l2tp_tunnel_delete);
 
<span class="p_header">diff --git a/net/l2tp/l2tp_core.h b/net/l2tp/l2tp_core.h</span>
<span class="p_header">index 9101297f27ad..7c5a51f62afc 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_core.h</span>
<span class="p_header">+++ b/net/l2tp/l2tp_core.h</span>
<span class="p_chunk">@@ -160,6 +160,9 @@</span> <span class="p_context"> struct l2tp_tunnel_cfg {</span>
 
 struct l2tp_tunnel {
 	int			magic;		/* Should be L2TP_TUNNEL_MAGIC */
<span class="p_add">+</span>
<span class="p_add">+	unsigned long		dead;</span>
<span class="p_add">+</span>
 	struct rcu_head rcu;
 	rwlock_t		hlist_lock;	/* protect session_hlist */
 	struct hlist_head	session_hlist[L2TP_HASH_SIZE];
<span class="p_chunk">@@ -248,7 +251,7 @@</span> <span class="p_context"> int l2tp_tunnel_create(struct net *net, int fd, int version, u32 tunnel_id,</span>
 		       u32 peer_tunnel_id, struct l2tp_tunnel_cfg *cfg,
 		       struct l2tp_tunnel **tunnelp);
 void l2tp_tunnel_closeall(struct l2tp_tunnel *tunnel);
<span class="p_del">-int l2tp_tunnel_delete(struct l2tp_tunnel *tunnel);</span>
<span class="p_add">+void l2tp_tunnel_delete(struct l2tp_tunnel *tunnel);</span>
 struct l2tp_session *l2tp_session_create(int priv_size,
 					 struct l2tp_tunnel *tunnel,
 					 u32 session_id, u32 peer_session_id,
<span class="p_header">diff --git a/net/l2tp/l2tp_eth.c b/net/l2tp/l2tp_eth.c</span>
<span class="p_header">index 4de2ec94b08c..cf456720930c 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_eth.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_eth.c</span>
<span class="p_chunk">@@ -44,7 +44,6 @@</span> <span class="p_context"> struct l2tp_eth {</span>
 	struct net_device	*dev;
 	struct sock		*tunnel_sock;
 	struct l2tp_session	*session;
<span class="p_del">-	struct list_head	list;</span>
 	atomic_long_t		tx_bytes;
 	atomic_long_t		tx_packets;
 	atomic_long_t		tx_dropped;
<span class="p_chunk">@@ -58,17 +57,6 @@</span> <span class="p_context"> struct l2tp_eth_sess {</span>
 	struct net_device	*dev;
 };
 
<span class="p_del">-/* per-net private data for this module */</span>
<span class="p_del">-static unsigned int l2tp_eth_net_id;</span>
<span class="p_del">-struct l2tp_eth_net {</span>
<span class="p_del">-	struct list_head l2tp_eth_dev_list;</span>
<span class="p_del">-	spinlock_t l2tp_eth_lock;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static inline struct l2tp_eth_net *l2tp_eth_pernet(struct net *net)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return net_generic(net, l2tp_eth_net_id);</span>
<span class="p_del">-}</span>
 
 static int l2tp_eth_dev_init(struct net_device *dev)
 {
<span class="p_chunk">@@ -84,12 +72,6 @@</span> <span class="p_context"> static int l2tp_eth_dev_init(struct net_device *dev)</span>
 
 static void l2tp_eth_dev_uninit(struct net_device *dev)
 {
<span class="p_del">-	struct l2tp_eth *priv = netdev_priv(dev);</span>
<span class="p_del">-	struct l2tp_eth_net *pn = l2tp_eth_pernet(dev_net(dev));</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock(&amp;pn-&gt;l2tp_eth_lock);</span>
<span class="p_del">-	list_del_init(&amp;priv-&gt;list);</span>
<span class="p_del">-	spin_unlock(&amp;pn-&gt;l2tp_eth_lock);</span>
 	dev_put(dev);
 }
 
<span class="p_chunk">@@ -272,7 +254,6 @@</span> <span class="p_context"> static int l2tp_eth_create(struct net *net, u32 tunnel_id, u32 session_id, u32 p</span>
 	struct l2tp_eth *priv;
 	struct l2tp_eth_sess *spriv;
 	int rc;
<span class="p_del">-	struct l2tp_eth_net *pn;</span>
 
 	tunnel = l2tp_tunnel_find(net, tunnel_id);
 	if (!tunnel) {
<span class="p_chunk">@@ -310,7 +291,6 @@</span> <span class="p_context"> static int l2tp_eth_create(struct net *net, u32 tunnel_id, u32 session_id, u32 p</span>
 	priv = netdev_priv(dev);
 	priv-&gt;dev = dev;
 	priv-&gt;session = session;
<span class="p_del">-	INIT_LIST_HEAD(&amp;priv-&gt;list);</span>
 
 	priv-&gt;tunnel_sock = tunnel-&gt;sock;
 	session-&gt;recv_skb = l2tp_eth_dev_recv;
<span class="p_chunk">@@ -331,10 +311,6 @@</span> <span class="p_context"> static int l2tp_eth_create(struct net *net, u32 tunnel_id, u32 session_id, u32 p</span>
 	strlcpy(session-&gt;ifname, dev-&gt;name, IFNAMSIZ);
 
 	dev_hold(dev);
<span class="p_del">-	pn = l2tp_eth_pernet(dev_net(dev));</span>
<span class="p_del">-	spin_lock(&amp;pn-&gt;l2tp_eth_lock);</span>
<span class="p_del">-	list_add(&amp;priv-&gt;list, &amp;pn-&gt;l2tp_eth_dev_list);</span>
<span class="p_del">-	spin_unlock(&amp;pn-&gt;l2tp_eth_lock);</span>
 
 	return 0;
 
<span class="p_chunk">@@ -347,22 +323,6 @@</span> <span class="p_context"> static int l2tp_eth_create(struct net *net, u32 tunnel_id, u32 session_id, u32 p</span>
 	return rc;
 }
 
<span class="p_del">-static __net_init int l2tp_eth_init_net(struct net *net)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct l2tp_eth_net *pn = net_generic(net, l2tp_eth_net_id);</span>
<span class="p_del">-</span>
<span class="p_del">-	INIT_LIST_HEAD(&amp;pn-&gt;l2tp_eth_dev_list);</span>
<span class="p_del">-	spin_lock_init(&amp;pn-&gt;l2tp_eth_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static struct pernet_operations l2tp_eth_net_ops = {</span>
<span class="p_del">-	.init = l2tp_eth_init_net,</span>
<span class="p_del">-	.id   = &amp;l2tp_eth_net_id,</span>
<span class="p_del">-	.size = sizeof(struct l2tp_eth_net),</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 
 static const struct l2tp_nl_cmd_ops l2tp_eth_nl_cmd_ops = {
 	.session_create	= l2tp_eth_create,
<span class="p_chunk">@@ -376,25 +336,18 @@</span> <span class="p_context"> static int __init l2tp_eth_init(void)</span>
 
 	err = l2tp_nl_register_ops(L2TP_PWTYPE_ETH, &amp;l2tp_eth_nl_cmd_ops);
 	if (err)
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	err = register_pernet_device(&amp;l2tp_eth_net_ops);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto out_unreg;</span>
<span class="p_add">+		goto err;</span>
 
 	pr_info(&quot;L2TP ethernet pseudowire support (L2TPv3)\n&quot;);
 
 	return 0;
 
<span class="p_del">-out_unreg:</span>
<span class="p_del">-	l2tp_nl_unregister_ops(L2TP_PWTYPE_ETH);</span>
<span class="p_del">-out:</span>
<span class="p_add">+err:</span>
 	return err;
 }
 
 static void __exit l2tp_eth_exit(void)
 {
<span class="p_del">-	unregister_pernet_device(&amp;l2tp_eth_net_ops);</span>
 	l2tp_nl_unregister_ops(L2TP_PWTYPE_ETH);
 }
 
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index 5acee49db90b..7e794ad50cb0 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -2262,10 +2262,13 @@</span> <span class="p_context"> int __netlink_dump_start(struct sock *ssk, struct sk_buff *skb,</span>
 
 	mutex_unlock(nlk-&gt;cb_mutex);
 
<span class="p_add">+	ret = 0;</span>
 	if (cb-&gt;start)
<span class="p_del">-		cb-&gt;start(cb);</span>
<span class="p_add">+		ret = cb-&gt;start(cb);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		ret = netlink_dump(sk);</span>
 
<span class="p_del">-	ret = netlink_dump(sk);</span>
 	sock_put(sk);
 
 	if (ret)
<span class="p_header">diff --git a/net/openvswitch/datapath.c b/net/openvswitch/datapath.c</span>
<span class="p_header">index 6b44fe405282..294444bb075c 100644</span>
<span class="p_header">--- a/net/openvswitch/datapath.c</span>
<span class="p_header">+++ b/net/openvswitch/datapath.c</span>
<span class="p_chunk">@@ -1126,7 +1126,8 @@</span> <span class="p_context"> static int ovs_nla_init_match_and_action(struct net *net,</span>
 		if (!a[OVS_FLOW_ATTR_KEY]) {
 			OVS_NLERR(log,
 				  &quot;Flow key attribute not present in set flow.&quot;);
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			error = -EINVAL;</span>
<span class="p_add">+			goto error;</span>
 		}
 
 		*acts = get_flow_actions(net, a[OVS_FLOW_ATTR_ACTIONS], key,
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index 1c61af9af67d..29d7b7e5b128 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -1686,10 +1686,6 @@</span> <span class="p_context"> static int fanout_add(struct sock *sk, u16 id, u16 type_flags)</span>
 
 	mutex_lock(&amp;fanout_mutex);
 
<span class="p_del">-	err = -EINVAL;</span>
<span class="p_del">-	if (!po-&gt;running)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
 	err = -EALREADY;
 	if (po-&gt;fanout)
 		goto out;
<span class="p_chunk">@@ -1751,7 +1747,10 @@</span> <span class="p_context"> static int fanout_add(struct sock *sk, u16 id, u16 type_flags)</span>
 		list_add(&amp;match-&gt;list, &amp;fanout_list);
 	}
 	err = -EINVAL;
<span class="p_del">-	if (match-&gt;type == type &amp;&amp;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;po-&gt;bind_lock);</span>
<span class="p_add">+	if (po-&gt;running &amp;&amp;</span>
<span class="p_add">+	    match-&gt;type == type &amp;&amp;</span>
 	    match-&gt;prot_hook.type == po-&gt;prot_hook.type &amp;&amp;
 	    match-&gt;prot_hook.dev == po-&gt;prot_hook.dev) {
 		err = -ENOSPC;
<span class="p_chunk">@@ -1763,6 +1762,13 @@</span> <span class="p_context"> static int fanout_add(struct sock *sk, u16 id, u16 type_flags)</span>
 			err = 0;
 		}
 	}
<span class="p_add">+	spin_unlock(&amp;po-&gt;bind_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (err &amp;&amp; !refcount_read(&amp;match-&gt;sk_ref)) {</span>
<span class="p_add">+		list_del(&amp;match-&gt;list);</span>
<span class="p_add">+		kfree(match);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 out:
 	if (err &amp;&amp; rollover) {
 		kfree(rollover);
<span class="p_chunk">@@ -2836,6 +2842,7 @@</span> <span class="p_context"> static int packet_snd(struct socket *sock, struct msghdr *msg, size_t len)</span>
 	struct virtio_net_hdr vnet_hdr = { 0 };
 	int offset = 0;
 	struct packet_sock *po = pkt_sk(sk);
<span class="p_add">+	bool has_vnet_hdr = false;</span>
 	int hlen, tlen, linear;
 	int extra_len = 0;
 
<span class="p_chunk">@@ -2879,6 +2886,7 @@</span> <span class="p_context"> static int packet_snd(struct socket *sock, struct msghdr *msg, size_t len)</span>
 		err = packet_snd_vnet_parse(msg, &amp;len, &amp;vnet_hdr);
 		if (err)
 			goto out_unlock;
<span class="p_add">+		has_vnet_hdr = true;</span>
 	}
 
 	if (unlikely(sock_flag(sk, SOCK_NOFCS))) {
<span class="p_chunk">@@ -2937,7 +2945,7 @@</span> <span class="p_context"> static int packet_snd(struct socket *sock, struct msghdr *msg, size_t len)</span>
 	skb-&gt;priority = sk-&gt;sk_priority;
 	skb-&gt;mark = sockc.mark;
 
<span class="p_del">-	if (po-&gt;has_vnet_hdr) {</span>
<span class="p_add">+	if (has_vnet_hdr) {</span>
 		err = virtio_net_hdr_to_skb(skb, &amp;vnet_hdr, vio_le());
 		if (err)
 			goto out_free;
<span class="p_chunk">@@ -3065,13 +3073,15 @@</span> <span class="p_context"> static int packet_do_bind(struct sock *sk, const char *name, int ifindex,</span>
 	int ret = 0;
 	bool unlisted = false;
 
<span class="p_del">-	if (po-&gt;fanout)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
 	lock_sock(sk);
 	spin_lock(&amp;po-&gt;bind_lock);
 	rcu_read_lock();
 
<span class="p_add">+	if (po-&gt;fanout) {</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (name) {
 		dev = dev_get_by_name_rcu(sock_net(sk), name);
 		if (!dev) {
<span class="p_header">diff --git a/net/sched/act_api.c b/net/sched/act_api.c</span>
<span class="p_header">index f2e9ed34a963..0c5dbb172437 100644</span>
<span class="p_header">--- a/net/sched/act_api.c</span>
<span class="p_header">+++ b/net/sched/act_api.c</span>
<span class="p_chunk">@@ -174,7 +174,7 @@</span> <span class="p_context"> static int tcf_del_walker(struct tcf_hashinfo *hinfo, struct sk_buff *skb,</span>
 		hlist_for_each_entry_safe(p, n, head, tcfa_head) {
 			ret = __tcf_hash_release(p, false, true);
 			if (ret == ACT_P_DELETED) {
<span class="p_del">-				module_put(p-&gt;ops-&gt;owner);</span>
<span class="p_add">+				module_put(ops-&gt;owner);</span>
 				n_i++;
 			} else if (ret &lt; 0)
 				goto nla_put_failure;
<span class="p_chunk">@@ -506,13 +506,15 @@</span> <span class="p_context"> EXPORT_SYMBOL(tcf_action_exec);</span>
 
 int tcf_action_destroy(struct list_head *actions, int bind)
 {
<span class="p_add">+	const struct tc_action_ops *ops;</span>
 	struct tc_action *a, *tmp;
 	int ret = 0;
 
 	list_for_each_entry_safe(a, tmp, actions, list) {
<span class="p_add">+		ops = a-&gt;ops;</span>
 		ret = __tcf_hash_release(a, bind, true);
 		if (ret == ACT_P_DELETED)
<span class="p_del">-			module_put(a-&gt;ops-&gt;owner);</span>
<span class="p_add">+			module_put(ops-&gt;owner);</span>
 		else if (ret &lt; 0)
 			return ret;
 	}
<span class="p_header">diff --git a/net/sched/cls_matchall.c b/net/sched/cls_matchall.c</span>
<span class="p_header">index 9dc26c32cf32..d720f9376add 100644</span>
<span class="p_header">--- a/net/sched/cls_matchall.c</span>
<span class="p_header">+++ b/net/sched/cls_matchall.c</span>
<span class="p_chunk">@@ -32,6 +32,7 @@</span> <span class="p_context"> static int mall_classify(struct sk_buff *skb, const struct tcf_proto *tp,</span>
 	if (tc_skip_sw(head-&gt;flags))
 		return -1;
 
<span class="p_add">+	*res = head-&gt;res;</span>
 	return tcf_exts_exec(skb, &amp;head-&gt;exts, res);
 }
 
<span class="p_header">diff --git a/net/sched/sch_generic.c b/net/sched/sch_generic.c</span>
<span class="p_header">index 4ba6da5fb254..ff49421ee48a 100644</span>
<span class="p_header">--- a/net/sched/sch_generic.c</span>
<span class="p_header">+++ b/net/sched/sch_generic.c</span>
<span class="p_chunk">@@ -681,6 +681,7 @@</span> <span class="p_context"> void qdisc_reset(struct Qdisc *qdisc)</span>
 		qdisc-&gt;gso_skb = NULL;
 	}
 	qdisc-&gt;q.qlen = 0;
<span class="p_add">+	qdisc-&gt;qstats.backlog = 0;</span>
 }
 EXPORT_SYMBOL(qdisc_reset);
 
<span class="p_header">diff --git a/net/tipc/msg.c b/net/tipc/msg.c</span>
<span class="p_header">index 6ef379f004ac..121e59a1d0e7 100644</span>
<span class="p_header">--- a/net/tipc/msg.c</span>
<span class="p_header">+++ b/net/tipc/msg.c</span>
<span class="p_chunk">@@ -551,7 +551,7 @@</span> <span class="p_context"> bool tipc_msg_lookup_dest(struct net *net, struct sk_buff *skb, int *err)</span>
 		return false;
 	if (msg_errcode(msg))
 		return false;
<span class="p_del">-	*err = -TIPC_ERR_NO_NAME;</span>
<span class="p_add">+	*err = TIPC_ERR_NO_NAME;</span>
 	if (skb_linearize(skb))
 		return false;
 	msg = buf_msg(skb);
<span class="p_header">diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c</span>
<span class="p_header">index 750ba5d24a49..359b1f34c805 100644</span>
<span class="p_header">--- a/net/wireless/nl80211.c</span>
<span class="p_header">+++ b/net/wireless/nl80211.c</span>
<span class="p_chunk">@@ -549,6 +549,14 @@</span> <span class="p_context"> nl80211_nan_srf_policy[NL80211_NAN_SRF_ATTR_MAX + 1] = {</span>
 	[NL80211_NAN_SRF_MAC_ADDRS] = { .type = NLA_NESTED },
 };
 
<span class="p_add">+/* policy for packet pattern attributes */</span>
<span class="p_add">+static const struct nla_policy</span>
<span class="p_add">+nl80211_packet_pattern_policy[MAX_NL80211_PKTPAT + 1] = {</span>
<span class="p_add">+	[NL80211_PKTPAT_MASK] = { .type = NLA_BINARY, },</span>
<span class="p_add">+	[NL80211_PKTPAT_PATTERN] = { .type = NLA_BINARY, },</span>
<span class="p_add">+	[NL80211_PKTPAT_OFFSET] = { .type = NLA_U32 },</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int nl80211_prepare_wdev_dump(struct sk_buff *skb,
 				     struct netlink_callback *cb,
 				     struct cfg80211_registered_device **rdev,
<span class="p_chunk">@@ -10529,7 +10537,8 @@</span> <span class="p_context"> static int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)</span>
 			u8 *mask_pat;
 
 			nla_parse_nested(pat_tb, MAX_NL80211_PKTPAT, pat,
<span class="p_del">-					 NULL, info-&gt;extack);</span>
<span class="p_add">+					 nl80211_packet_pattern_policy,</span>
<span class="p_add">+					 info-&gt;extack);</span>
 			err = -EINVAL;
 			if (!pat_tb[NL80211_PKTPAT_MASK] ||
 			    !pat_tb[NL80211_PKTPAT_PATTERN])
<span class="p_chunk">@@ -10778,7 +10787,8 @@</span> <span class="p_context"> static int nl80211_parse_coalesce_rule(struct cfg80211_registered_device *rdev,</span>
 			    rem) {
 		u8 *mask_pat;
 
<span class="p_del">-		nla_parse_nested(pat_tb, MAX_NL80211_PKTPAT, pat, NULL, NULL);</span>
<span class="p_add">+		nla_parse_nested(pat_tb, MAX_NL80211_PKTPAT, pat,</span>
<span class="p_add">+				 nl80211_packet_pattern_policy, NULL);</span>
 		if (!pat_tb[NL80211_PKTPAT_MASK] ||
 		    !pat_tb[NL80211_PKTPAT_PATTERN])
 			return -EINVAL;
<span class="p_header">diff --git a/security/smack/smack_lsm.c b/security/smack/smack_lsm.c</span>
<span class="p_header">index 463af86812c7..a9e89177a346 100644</span>
<span class="p_header">--- a/security/smack/smack_lsm.c</span>
<span class="p_header">+++ b/security/smack/smack_lsm.c</span>
<span class="p_chunk">@@ -1499,7 +1499,7 @@</span> <span class="p_context"> static int smack_inode_removexattr(struct dentry *dentry, const char *name)</span>
  * @inode: the object
  * @name: attribute name
  * @buffer: where to put the result
<span class="p_del">- * @alloc: unused</span>
<span class="p_add">+ * @alloc: duplicate memory</span>
  *
  * Returns the size of the attribute or an error code
  */
<span class="p_chunk">@@ -1512,43 +1512,38 @@</span> <span class="p_context"> static int smack_inode_getsecurity(struct inode *inode,</span>
 	struct super_block *sbp;
 	struct inode *ip = (struct inode *)inode;
 	struct smack_known *isp;
<span class="p_del">-	int ilen;</span>
<span class="p_del">-	int rc = 0;</span>
 
<span class="p_del">-	if (strcmp(name, XATTR_SMACK_SUFFIX) == 0) {</span>
<span class="p_add">+	if (strcmp(name, XATTR_SMACK_SUFFIX) == 0)</span>
 		isp = smk_of_inode(inode);
<span class="p_del">-		ilen = strlen(isp-&gt;smk_known);</span>
<span class="p_del">-		*buffer = isp-&gt;smk_known;</span>
<span class="p_del">-		return ilen;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The rest of the Smack xattrs are only on sockets.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		sbp = ip-&gt;i_sb;</span>
<span class="p_add">+		if (sbp-&gt;s_magic != SOCKFS_MAGIC)</span>
<span class="p_add">+			return -EOPNOTSUPP;</span>
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The rest of the Smack xattrs are only on sockets.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	sbp = ip-&gt;i_sb;</span>
<span class="p_del">-	if (sbp-&gt;s_magic != SOCKFS_MAGIC)</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+		sock = SOCKET_I(ip);</span>
<span class="p_add">+		if (sock == NULL || sock-&gt;sk == NULL)</span>
<span class="p_add">+			return -EOPNOTSUPP;</span>
 
<span class="p_del">-	sock = SOCKET_I(ip);</span>
<span class="p_del">-	if (sock == NULL || sock-&gt;sk == NULL)</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_del">-</span>
<span class="p_del">-	ssp = sock-&gt;sk-&gt;sk_security;</span>
<span class="p_add">+		ssp = sock-&gt;sk-&gt;sk_security;</span>
 
<span class="p_del">-	if (strcmp(name, XATTR_SMACK_IPIN) == 0)</span>
<span class="p_del">-		isp = ssp-&gt;smk_in;</span>
<span class="p_del">-	else if (strcmp(name, XATTR_SMACK_IPOUT) == 0)</span>
<span class="p_del">-		isp = ssp-&gt;smk_out;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+		if (strcmp(name, XATTR_SMACK_IPIN) == 0)</span>
<span class="p_add">+			isp = ssp-&gt;smk_in;</span>
<span class="p_add">+		else if (strcmp(name, XATTR_SMACK_IPOUT) == 0)</span>
<span class="p_add">+			isp = ssp-&gt;smk_out;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			return -EOPNOTSUPP;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	ilen = strlen(isp-&gt;smk_known);</span>
<span class="p_del">-	if (rc == 0) {</span>
<span class="p_del">-		*buffer = isp-&gt;smk_known;</span>
<span class="p_del">-		rc = ilen;</span>
<span class="p_add">+	if (alloc) {</span>
<span class="p_add">+		*buffer = kstrdup(isp-&gt;smk_known, GFP_KERNEL);</span>
<span class="p_add">+		if (*buffer == NULL)</span>
<span class="p_add">+			return -ENOMEM;</span>
 	}
 
<span class="p_del">-	return rc;</span>
<span class="p_add">+	return strlen(isp-&gt;smk_known);</span>
 }
 
 
<span class="p_header">diff --git a/sound/core/compress_offload.c b/sound/core/compress_offload.c</span>
<span class="p_header">index fec1dfdb14ad..4490a699030b 100644</span>
<span class="p_header">--- a/sound/core/compress_offload.c</span>
<span class="p_header">+++ b/sound/core/compress_offload.c</span>
<span class="p_chunk">@@ -948,14 +948,13 @@</span> <span class="p_context"> static const struct file_operations snd_compr_file_ops = {</span>
 static int snd_compress_dev_register(struct snd_device *device)
 {
 	int ret = -EINVAL;
<span class="p_del">-	char str[16];</span>
 	struct snd_compr *compr;
 
 	if (snd_BUG_ON(!device || !device-&gt;device_data))
 		return -EBADFD;
 	compr = device-&gt;device_data;
 
<span class="p_del">-	pr_debug(&quot;reg %s for device %s, direction %d\n&quot;, str, compr-&gt;name,</span>
<span class="p_add">+	pr_debug(&quot;reg device %s, direction %d\n&quot;, compr-&gt;name,</span>
 			compr-&gt;direction);
 	/* register compressed device */
 	ret = snd_register_device(SNDRV_DEVICE_TYPE_COMPRESS,
<span class="p_header">diff --git a/sound/pci/echoaudio/echoaudio.c b/sound/pci/echoaudio/echoaudio.c</span>
<span class="p_header">index d15ecf9febbf..e54f5f549e38 100644</span>
<span class="p_header">--- a/sound/pci/echoaudio/echoaudio.c</span>
<span class="p_header">+++ b/sound/pci/echoaudio/echoaudio.c</span>
<span class="p_chunk">@@ -1272,11 +1272,11 @@</span> <span class="p_context"> static int snd_echo_mixer_info(struct snd_kcontrol *kcontrol,</span>
 
 	chip = snd_kcontrol_chip(kcontrol);
 	uinfo-&gt;type = SNDRV_CTL_ELEM_TYPE_INTEGER;
<span class="p_add">+	uinfo-&gt;count = 1;</span>
 	uinfo-&gt;value.integer.min = ECHOGAIN_MINOUT;
 	uinfo-&gt;value.integer.max = ECHOGAIN_MAXOUT;
 	uinfo-&gt;dimen.d[0] = num_busses_out(chip);
 	uinfo-&gt;dimen.d[1] = num_busses_in(chip);
<span class="p_del">-	uinfo-&gt;count = uinfo-&gt;dimen.d[0] * uinfo-&gt;dimen.d[1];</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1344,11 +1344,11 @@</span> <span class="p_context"> static int snd_echo_vmixer_info(struct snd_kcontrol *kcontrol,</span>
 
 	chip = snd_kcontrol_chip(kcontrol);
 	uinfo-&gt;type = SNDRV_CTL_ELEM_TYPE_INTEGER;
<span class="p_add">+	uinfo-&gt;count = 1;</span>
 	uinfo-&gt;value.integer.min = ECHOGAIN_MINOUT;
 	uinfo-&gt;value.integer.max = ECHOGAIN_MAXOUT;
 	uinfo-&gt;dimen.d[0] = num_busses_out(chip);
 	uinfo-&gt;dimen.d[1] = num_pipes_out(chip);
<span class="p_del">-	uinfo-&gt;count = uinfo-&gt;dimen.d[0] * uinfo-&gt;dimen.d[1];</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1728,6 +1728,7 @@</span> <span class="p_context"> static int snd_echo_vumeters_info(struct snd_kcontrol *kcontrol,</span>
 				  struct snd_ctl_elem_info *uinfo)
 {
 	uinfo-&gt;type = SNDRV_CTL_ELEM_TYPE_INTEGER;
<span class="p_add">+	uinfo-&gt;count = 96;</span>
 	uinfo-&gt;value.integer.min = ECHOGAIN_MINOUT;
 	uinfo-&gt;value.integer.max = 0;
 #ifdef ECHOCARD_HAS_VMIXER
<span class="p_chunk">@@ -1737,7 +1738,6 @@</span> <span class="p_context"> static int snd_echo_vumeters_info(struct snd_kcontrol *kcontrol,</span>
 #endif
 	uinfo-&gt;dimen.d[1] = 16;	/* 16 channels */
 	uinfo-&gt;dimen.d[2] = 2;	/* 0=level, 1=peak */
<span class="p_del">-	uinfo-&gt;count = uinfo-&gt;dimen.d[0] * uinfo-&gt;dimen.d[1] * uinfo-&gt;dimen.d[2];</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/sound/usb/card.c b/sound/usb/card.c</span>
<span class="p_header">index 6640277a725b..383facf2dc11 100644</span>
<span class="p_header">--- a/sound/usb/card.c</span>
<span class="p_header">+++ b/sound/usb/card.c</span>
<span class="p_chunk">@@ -221,6 +221,7 @@</span> <span class="p_context"> static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)</span>
 	struct usb_interface_descriptor *altsd;
 	void *control_header;
 	int i, protocol;
<span class="p_add">+	int rest_bytes;</span>
 
 	/* find audiocontrol interface */
 	host_iface = &amp;usb_ifnum_to_if(dev, ctrlif)-&gt;altsetting[0];
<span class="p_chunk">@@ -235,6 +236,15 @@</span> <span class="p_context"> static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)</span>
 		return -EINVAL;
 	}
 
<span class="p_add">+	rest_bytes = (void *)(host_iface-&gt;extra + host_iface-&gt;extralen) -</span>
<span class="p_add">+		control_header;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* just to be sure -- this shouldn&#39;t hit at all */</span>
<span class="p_add">+	if (rest_bytes &lt;= 0) {</span>
<span class="p_add">+		dev_err(&amp;dev-&gt;dev, &quot;invalid control header\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	switch (protocol) {
 	default:
 		dev_warn(&amp;dev-&gt;dev,
<span class="p_chunk">@@ -245,11 +255,21 @@</span> <span class="p_context"> static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)</span>
 	case UAC_VERSION_1: {
 		struct uac1_ac_header_descriptor *h1 = control_header;
 
<span class="p_add">+		if (rest_bytes &lt; sizeof(*h1)) {</span>
<span class="p_add">+			dev_err(&amp;dev-&gt;dev, &quot;too short v1 buffer descriptor\n&quot;);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (!h1-&gt;bInCollection) {
 			dev_info(&amp;dev-&gt;dev, &quot;skipping empty audio interface (v1)\n&quot;);
 			return -EINVAL;
 		}
 
<span class="p_add">+		if (rest_bytes &lt; h1-&gt;bLength) {</span>
<span class="p_add">+			dev_err(&amp;dev-&gt;dev, &quot;invalid buffer length (v1)\n&quot;);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (h1-&gt;bLength &lt; sizeof(*h1) + h1-&gt;bInCollection) {
 			dev_err(&amp;dev-&gt;dev, &quot;invalid UAC_HEADER (v1)\n&quot;);
 			return -EINVAL;
<span class="p_header">diff --git a/sound/usb/usx2y/usb_stream.c b/sound/usb/usx2y/usb_stream.c</span>
<span class="p_header">index bf618e1500ac..e7b934f4d837 100644</span>
<span class="p_header">--- a/sound/usb/usx2y/usb_stream.c</span>
<span class="p_header">+++ b/sound/usb/usx2y/usb_stream.c</span>
<span class="p_chunk">@@ -191,7 +191,8 @@</span> <span class="p_context"> struct usb_stream *usb_stream_new(struct usb_stream_kernel *sk,</span>
 	}
 
 	pg = get_order(read_size);
<span class="p_del">-	sk-&gt;s = (void *) __get_free_pages(GFP_KERNEL|__GFP_COMP|__GFP_ZERO, pg);</span>
<span class="p_add">+	sk-&gt;s = (void *) __get_free_pages(GFP_KERNEL|__GFP_COMP|__GFP_ZERO|</span>
<span class="p_add">+					  __GFP_NOWARN, pg);</span>
 	if (!sk-&gt;s) {
 		snd_printk(KERN_WARNING &quot;couldn&#39;t __get_free_pages()\n&quot;);
 		goto out;
<span class="p_chunk">@@ -211,7 +212,8 @@</span> <span class="p_context"> struct usb_stream *usb_stream_new(struct usb_stream_kernel *sk,</span>
 	pg = get_order(write_size);
 
 	sk-&gt;write_page =
<span class="p_del">-		(void *)__get_free_pages(GFP_KERNEL|__GFP_COMP|__GFP_ZERO, pg);</span>
<span class="p_add">+		(void *)__get_free_pages(GFP_KERNEL|__GFP_COMP|__GFP_ZERO|</span>
<span class="p_add">+					 __GFP_NOWARN, pg);</span>
 	if (!sk-&gt;write_page) {
 		snd_printk(KERN_WARNING &quot;couldn&#39;t __get_free_pages()\n&quot;);
 		usb_stream_free(sk);
<span class="p_header">diff --git a/tools/testing/selftests/bpf/test_verifier.c b/tools/testing/selftests/bpf/test_verifier.c</span>
<span class="p_header">index d3ed7324105e..48c145eeeaf7 100644</span>
<span class="p_header">--- a/tools/testing/selftests/bpf/test_verifier.c</span>
<span class="p_header">+++ b/tools/testing/selftests/bpf/test_verifier.c</span>
<span class="p_chunk">@@ -6009,6 +6009,22 @@</span> <span class="p_context"> static struct bpf_test tests[] = {</span>
 		.result = REJECT,
 		.result_unpriv = REJECT,
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		&quot;invalid 64-bit BPF_END&quot;,</span>
<span class="p_add">+		.insns = {</span>
<span class="p_add">+			BPF_MOV32_IMM(BPF_REG_0, 0),</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.code  = BPF_ALU64 | BPF_END | BPF_TO_LE,</span>
<span class="p_add">+				.dst_reg = BPF_REG_0,</span>
<span class="p_add">+				.src_reg = 0,</span>
<span class="p_add">+				.off   = 0,</span>
<span class="p_add">+				.imm   = 32,</span>
<span class="p_add">+			},</span>
<span class="p_add">+			BPF_EXIT_INSN(),</span>
<span class="p_add">+		},</span>
<span class="p_add">+		.errstr = &quot;BPF_END uses reserved fields&quot;,</span>
<span class="p_add">+		.result = REJECT,</span>
<span class="p_add">+	},</span>
 };
 
 static int probe_filter_length(const struct bpf_insn *fp)

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



