
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.16.42 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.16.42</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>March 16, 2017, 4:33 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170316163319.GQ4152@decadent.org.uk&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9628973/mbox/"
   >mbox</a>
|
   <a href="/patch/9628973/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9628973/">/patch/9628973/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	9D1BB604AA for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 16 Mar 2017 16:34:53 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 68EE7285EE
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 16 Mar 2017 16:34:53 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 5A65B2864B; Thu, 16 Mar 2017 16:34:53 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 404A8285EE
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 16 Mar 2017 16:34:34 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1755004AbdCPQeW (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 16 Mar 2017 12:34:22 -0400
Received: from shadbolt.e.decadent.org.uk ([88.96.1.126]:34835 &quot;EHLO
	shadbolt.e.decadent.org.uk&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S1752396AbdCPQeR (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 16 Mar 2017 12:34:17 -0400
Received: from ben by shadbolt.decadent.org.uk with local (Exim 4.84_2)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1coYL1-0005X5-NL; Thu, 16 Mar 2017 16:33:38 +0000
Date: Thu, 16 Mar 2017 16:33:19 +0000
From: Ben Hutchings &lt;ben@decadent.org.uk&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, Jiri Slaby &lt;jslaby@suse.cz&gt;,
	stable@vger.kernel.org
Cc: lwn@lwn.net
Message-ID: &lt;20170316163319.GQ4152@decadent.org.uk&gt;
MIME-Version: 1.0
Content-Type: multipart/signed; micalg=pgp-sha512;
	protocol=&quot;application/pgp-signature&quot;; boundary=&quot;Er97KPJOrxRt+yKZ&quot;
Content-Disposition: inline
X-Mailer: LinuxStableQueue (scripts by bwh)
User-Agent: Mutt/1.5.23 (2014-03-12)
X-SA-Exim-Connect-IP: &lt;locally generated&gt;
X-SA-Exim-Mail-From: ben@decadent.org.uk
Subject: Linux 3.16.42
X-SA-Exim-Version: 4.2.1 (built Mon, 26 Dec 2011 16:24:06 +0000)
X-SA-Exim-Scanned: Yes (on shadbolt.decadent.org.uk)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a> - March 16, 2017, 4:33 p.m.</div>
<pre class="content">
I&#39;m announcing the release of the 3.16.42 kernel.
(This time with a signed mail.)

All users of the 3.16 kernel series should upgrade.

The updated 3.16.y git tree can be found at:
        https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git linux-3.16.y
and can be browsed at the normal kernel.org git web browser:
        https://git.kernel.org/?p=linux/kernel/git/stable/linux-stable.git

The diff from 3.16.41 is attached to this message.

Ben.

------------

 .../devicetree/bindings/clock/imx31-clock.txt      |   2 +-
 Documentation/virtual/kvm/api.txt                  |   1 +
 MAINTAINERS                                        |   4 +-
 Makefile                                           |   2 +-
 arch/arc/kernel/unaligned.c                        |   3 +-
 arch/arm/boot/dts/da850-evm.dts                    |   1 +
 arch/arm/boot/dts/imx31.dtsi                       |  18 +-
 arch/arm/boot/dts/imx6q-cm-fx6.dts                 |   1 -
 arch/arm/include/asm/cputype.h                     |   3 +
 arch/arm/kernel/hw_breakpoint.c                    |  16 ++
 arch/arm/kernel/ptrace.c                           |   2 +-
 arch/arm/mach-davinci/da850.c                      |  12 +-
 arch/arm/mach-ux500/pm.c                           |   4 +-
 arch/arm/mach-zynq/common.c                        |   2 +-
 arch/arm/xen/enlighten.c                           |   3 +-
 arch/arm64/crypto/aes-ce-ccm-core.S                |  53 +++---
 arch/arm64/crypto/aes-ce.S                         |   1 +
 arch/arm64/crypto/aes-modes.S                      |  91 +++++-----
 arch/arm64/crypto/aes-neon.S                       |  25 +--
 arch/arm64/crypto/ghash-ce-core.S                  |   6 +-
 arch/arm64/crypto/sha1-ce-core.S                   |   4 +-
 arch/arm64/crypto/sha2-ce-core.S                   |   4 +-
 arch/arm64/include/uapi/asm/ptrace.h               |   1 +
 arch/arm64/kernel/entry.S                          |   2 +-
 arch/arm64/kernel/ptrace.c                         |  11 +-
 arch/arm64/kernel/traps.c                          |  28 ++-
 arch/cris/boot/rescue/Makefile                     |   8 +
 arch/mips/kvm/kvm_mips.c                           |   4 +-
 arch/parisc/include/asm/bitops.h                   |   8 +-
 arch/parisc/include/uapi/asm/bitsperlong.h         |   2 -
 arch/parisc/include/uapi/asm/swab.h                |   5 +-
 arch/powerpc/boot/ps3-head.S                       |   5 -
 arch/powerpc/boot/ps3.c                            |   8 +-
 arch/powerpc/boot/wrapper                          |  24 ++-
 arch/powerpc/include/asm/kvm_host.h                |   1 +
 arch/powerpc/include/asm/ppc-opcode.h              |  10 +-
 arch/powerpc/include/uapi/asm/kvm.h                |   1 +
 arch/powerpc/kernel/asm-offsets.c                  |   1 +
 arch/powerpc/kernel/ibmebus.c                      |  16 +-
 arch/powerpc/kernel/misc_32.S                      |   2 +-
 arch/powerpc/kernel/prom_init.c                    |   3 +
 arch/powerpc/kernel/ptrace.c                       |   7 +
 arch/powerpc/kvm/book3s_hv.c                       |   6 +
 arch/powerpc/kvm/book3s_hv_rmhandlers.S            |   4 +
 arch/sparc/kernel/leon_kernel.c                    |  56 +++---
 arch/tile/kernel/ptrace.c                          |   2 +-
 arch/x86/boot/string.c                             |   1 +
 arch/x86/boot/string.h                             |   9 +
 arch/x86/kernel/cpu/common.c                       |   2 +-
 arch/x86/kernel/entry_32.S                         |   4 +-
 arch/x86/kvm/lapic.c                               |   6 +
 arch/x86/kvm/lapic.h                               |   1 +
 arch/x86/kvm/vmx.c                                 |  10 +-
 arch/x86/kvm/x86.c                                 |  12 +-
 arch/x86/pci/acpi.c                                |  10 ++
 crypto/algapi.c                                    |   1 +
 drivers/ata/sata_mv.c                              |   3 +
 drivers/base/dma-mapping.c                         |   4 +-
 drivers/base/regmap/regcache-lzo.c                 |   8 +-
 drivers/block/nbd.c                                |  34 ++--
 drivers/bus/vexpress-config.c                      |   7 +-
 drivers/clk/clk-wm831x.c                           |   2 +-
 drivers/clk/shmobile/clk-mstp.c                    |  27 ++-
 drivers/clocksource/exynos_mct.c                   |   5 +
 drivers/crypto/caam/caamalg.c                      |   4 +-
 drivers/devfreq/devfreq.c                          |  19 ++-
 drivers/gpu/drm/ast/ast_main.c                     |   7 +-
 drivers/gpu/drm/gma500/psb_drv.c                   |   3 +
 drivers/gpu/drm/i915/intel_crt.c                   |   9 +-
 drivers/gpu/drm/i915/intel_display.c               |   4 +-
 drivers/gpu/drm/i915/intel_pm.c                    |  11 +-
 drivers/gpu/drm/nouveau/dispnv04/hw.c              |   3 +-
 drivers/gpu/drm/radeon/radeon_cursor.c             |  56 ++++--
 drivers/gpu/drm/radeon/radeon_mode.h               |   1 +
 drivers/gpu/drm/radeon/si_dpm.c                    |  14 +-
 drivers/hid/hid-cypress.c                          |   3 +
 drivers/hwmon/ds620.c                              |   2 +-
 drivers/hwmon/g762.c                               |  11 +-
 drivers/i2c/i2c-dev.c                              |   2 +-
 drivers/i2c/muxes/i2c-mux-pca954x.c                |   5 +-
 drivers/iio/humidity/dht11.c                       |   6 +-
 drivers/infiniband/core/mad.c                      |   2 +-
 drivers/infiniband/core/multicast.c                |   7 +-
 drivers/infiniband/core/uverbs_cmd.c               |   1 -
 drivers/infiniband/core/verbs.c                    |   4 +-
 drivers/infiniband/hw/cxgb4/device.c               |   1 +
 drivers/infiniband/hw/mlx4/ah.c                    |   6 +-
 drivers/infiniband/hw/mlx4/main.c                  |  30 ++--
 drivers/infiniband/hw/mlx4/qp.c                    |   3 +-
 drivers/infiniband/hw/mlx5/main.c                  |   1 +
 drivers/infiniband/hw/mlx5/mr.c                    |  28 +++
 drivers/infiniband/ulp/ipoib/ipoib_cm.c            |   2 -
 drivers/infiniband/ulp/ipoib/ipoib_multicast.c     |   7 +-
 drivers/input/serio/i8042-x86ia64io.h              |   6 +
 drivers/iommu/amd_iommu.c                          |   2 +-
 drivers/isdn/hardware/eicon/message.c              |   3 +-
 drivers/md/dm-crypt.c                              |   7 +-
 drivers/md/dm.c                                    |  10 +-
 drivers/md/md.c                                    |   2 +-
 drivers/md/persistent-data/dm-space-map-metadata.c |  14 +-
 drivers/md/raid5.c                                 |   9 +
 drivers/media/i2c/Kconfig                          |   1 +
 drivers/media/platform/davinci/vpfe_capture.c      |   1 +
 drivers/media/rc/ite-cir.c                         |   2 +
 drivers/media/usb/siano/smsusb.c                   |  18 +-
 drivers/misc/mei/client.c                          |  20 ++-
 drivers/mmc/core/mmc.c                             |   4 +-
 drivers/mmc/host/mxs-mmc.c                         |   6 +-
 drivers/mmc/host/sdhci.c                           |  23 ++-
 drivers/mtd/nand/Kconfig                           |   2 +-
 drivers/net/bonding/bond_netlink.c                 |   6 +-
 drivers/net/can/c_can/c_can_pci.c                  |   1 +
 drivers/net/can/ti_hecc.c                          |  16 +-
 drivers/net/ethernet/atheros/alx/main.c            |   7 +-
 drivers/net/ethernet/broadcom/bcmsysport.c         |  43 +++--
 drivers/net/ethernet/cisco/enic/enic_main.c        |  18 +-
 drivers/net/ethernet/emulex/benet/be_cmds.c        |   2 +-
 drivers/net/ethernet/korina.c                      |   8 +-
 drivers/net/ethernet/marvell/sky2.c                |  13 ++
 drivers/net/ethernet/mellanox/mlx4/cq.c            |  38 +++--
 drivers/net/ethernet/mellanox/mlx4/en_rx.c         |  13 +-
 drivers/net/ethernet/mellanox/mlx4/eq.c            |  23 ++-
 drivers/net/ethernet/mellanox/mlx4/icm.c           |   7 +-
 .../net/ethernet/mellanox/mlx4/resource_tracker.c  |  11 +-
 drivers/net/ethernet/renesas/sh_eth.c              |   6 +-
 drivers/net/ethernet/stmicro/stmmac/stmmac_main.c  |  20 ++-
 drivers/net/ethernet/xilinx/xilinx_emaclite.c      | 126 +++++++-------
 drivers/net/hyperv/netvsc_drv.c                    |   4 +
 drivers/net/macvtap.c                              |   4 +-
 drivers/net/tun.c                                  |  20 ++-
 drivers/net/usb/catc.c                             |  56 +++---
 drivers/net/usb/cdc_ether.c                        |   8 +
 drivers/net/usb/cdc_ncm.c                          |   7 +
 drivers/net/usb/pegasus.c                          |  29 +++-
 drivers/net/usb/qmi_wwan.c                         |   7 +
 drivers/net/usb/r8152.c                            |   7 +-
 drivers/net/usb/rtl8150.c                          |  34 +++-
 drivers/net/vxlan.c                                |   8 +-
 drivers/net/xen-netfront.c                         |   9 +-
 drivers/pci/hotplug/rpadlpar_core.c                |  10 +-
 drivers/pci/pci.c                                  |   4 +
 drivers/platform/x86/intel_mid_powerbtn.c          |   2 +-
 drivers/regulator/stw481x-vmmc.c                   |   3 +-
 drivers/s390/char/vmlogrdr.c                       |   2 +-
 drivers/s390/scsi/zfcp_dbf.c                       |  17 +-
 drivers/s390/scsi/zfcp_dbf.h                       |  41 ++++-
 drivers/s390/scsi/zfcp_erp.c                       |  61 ++++++-
 drivers/s390/scsi/zfcp_ext.h                       |   4 +-
 drivers/s390/scsi/zfcp_fsf.c                       |   8 +-
 drivers/s390/scsi/zfcp_fsf.h                       |   3 +-
 drivers/s390/scsi/zfcp_reqlist.h                   |  30 +++-
 drivers/s390/scsi/zfcp_scsi.c                      |  61 ++++++-
 drivers/scsi/megaraid/megaraid_sas_fusion.c        |   1 +
 drivers/scsi/mvsas/mv_94xx.c                       |   2 +-
 drivers/scsi/qla2xxx/qla_os.c                      |  16 +-
 drivers/scsi/scsi_sysfs.c                          |   4 -
 drivers/scsi/sg.c                                  |   4 +
 drivers/ssb/pci.c                                  |   1 +
 drivers/staging/iio/adc/ad7606_core.c              |   2 +-
 drivers/staging/media/davinci_vpfe/vpfe_video.c    |   2 +-
 drivers/target/iscsi/iscsi_target_tpg.c            |   1 -
 drivers/target/target_core_sbc.c                   |   8 +-
 drivers/target/target_core_transport.c             |  17 +-
 drivers/target/target_core_xcopy.c                 |   2 +-
 drivers/thermal/thermal_hwmon.c                    |   2 +-
 drivers/tty/n_hdlc.c                               | 143 ++++++++--------
 drivers/tty/serial/atmel_serial.c                  |  11 +-
 drivers/tty/sysrq.c                                |   4 +-
 drivers/usb/class/cdc-acm.c                        |   1 +
 drivers/usb/core/config.c                          |  10 ++
 drivers/usb/core/hub.c                             | 134 ++++++---------
 drivers/usb/core/quirks.c                          |   4 +
 drivers/usb/dwc3/ep0.c                             |  37 ++--
 drivers/usb/dwc3/gadget.c                          |  20 ++-
 drivers/usb/gadget/composite.c                     |  23 ++-
 drivers/usb/gadget/dummy_hcd.c                     |   6 +-
 drivers/usb/gadget/inode.c                         |  17 +-
 drivers/usb/gadget/uvc_video.c                     |   2 +-
 drivers/usb/host/uhci-pci.c                        |   4 +
 drivers/usb/host/xhci-mem.c                        |  42 ++++-
 drivers/usb/host/xhci-pci.c                        |   3 +-
 drivers/usb/host/xhci-ring.c                       |  39 +++--
 drivers/usb/host/xhci.c                            |  13 --
 drivers/usb/musb/musbhsdma.h                       |   2 +-
 drivers/usb/phy/phy-am335x-control.c               |   2 +
 drivers/usb/serial/ch341.c                         | 187 +++++++++++++--------
 drivers/usb/serial/cyberjack.c                     |  10 ++
 drivers/usb/serial/garmin_gps.c                    |   1 +
 drivers/usb/serial/io_edgeport.c                   |   5 +
 drivers/usb/serial/io_ti.c                         |  14 +-
 drivers/usb/serial/iuu_phoenix.c                   |  11 ++
 drivers/usb/serial/keyspan_pda.c                   |  14 ++
 drivers/usb/serial/kl5kusb105.c                    |  35 +++-
 drivers/usb/serial/kobil_sct.c                     |  12 ++
 drivers/usb/serial/mos7720.c                       |  51 +++---
 drivers/usb/serial/mos7840.c                       |  16 +-
 drivers/usb/serial/omninet.c                       |  13 ++
 drivers/usb/serial/option.c                        |   8 +
 drivers/usb/serial/oti6858.c                       |  16 ++
 drivers/usb/serial/pl2303.c                        |   9 +
 drivers/usb/serial/pl2303.h                        |   1 +
 drivers/usb/serial/qcserial.c                      |   1 +
 drivers/usb/serial/quatech2.c                      |   4 -
 drivers/usb/serial/spcp8x5.c                       |  14 ++
 drivers/usb/serial/ti_usb_3410_5052.c              |   7 +
 drivers/usb/storage/unusual_devs.h                 |   7 +
 drivers/vme/bridges/vme_ca91cx42.c                 |   2 +-
 drivers/xen/gntdev.c                               |   2 +-
 fs/block_dev.c                                     |   9 +-
 fs/btrfs/async-thread.c                            |  14 ++
 fs/btrfs/async-thread.h                            |   1 +
 fs/btrfs/delayed-inode.c                           |  15 +-
 fs/btrfs/extent-tree.c                             |   5 +-
 fs/btrfs/ioctl.c                                   |   6 +-
 fs/btrfs/tree-log.c                                |   3 +-
 fs/ceph/mds_client.c                               |   9 +-
 fs/cifs/cifsglob.h                                 |   3 +
 fs/cifs/cifsproto.h                                |   3 +
 fs/cifs/connect.c                                  |  34 +++-
 fs/cifs/smb2file.c                                 |   2 +-
 fs/cifs/smb2pdu.c                                  |  77 ++++++---
 fs/cifs/smb2proto.h                                |   1 +
 fs/exec.c                                          |  10 +-
 fs/ext4/inline.c                                   |   4 +-
 fs/ext4/inode.c                                    |   6 +
 fs/ext4/mballoc.c                                  |   4 +-
 fs/ext4/super.c                                    |  64 ++++---
 fs/f2fs/debug.c                                    |   1 +
 fs/nfs/dir.c                                       |  15 +-
 fs/nfs/file.c                                      |   2 +-
 fs/nfs/filelayout/filelayoutdev.c                  |   3 +-
 fs/nfs/nfs4state.c                                 |   1 +
 fs/notify/inode_mark.c                             |  46 +----
 fs/ocfs2/dlmglue.c                                 |  10 ++
 fs/ocfs2/stackglue.c                               |   6 +
 fs/ocfs2/stackglue.h                               |   3 +
 fs/splice.c                                        |   1 +
 fs/ubifs/tnc.c                                     |  25 ++-
 fs/xfs/xfs_bmap_util.c                             |   7 +-
 fs/xfs/xfs_log_recover.c                           |   1 +
 include/linux/can/core.h                           |   7 +-
 include/linux/cpu.h                                |  15 +-
 include/linux/jump_label_ratelimit.h               |   5 +
 include/linux/netdevice.h                          |   9 +-
 include/linux/nfs4.h                               |   3 +-
 include/linux/sunrpc/clnt.h                        |   1 +
 include/linux/tcp.h                                |   7 +-
 include/net/cfg80211.h                             |  11 ++
 include/net/cipso_ipv4.h                           |   4 +
 include/net/netfilter/nf_log.h                     |   2 +
 include/net/sock.h                                 |  17 +-
 include/uapi/linux/usb/ch9.h                       |  19 +++
 ipc/shm.c                                          |  13 +-
 kernel/cpu.c                                       |  13 +-
 kernel/events/core.c                               |  42 ++---
 kernel/futex.c                                     |   2 +-
 kernel/jump_label.c                                |   7 +
 kernel/printk/printk.c                             |   2 +-
 kernel/sched/cputime.c                             |   3 +
 kernel/sysctl.c                                    |   1 +
 kernel/trace/trace_functions_graph.c               |  17 +-
 lib/vsprintf.c                                     |   2 +-
 mm/filemap.c                                       |   5 +
 mm/huge_memory.c                                   |  19 ++-
 mm/hugetlb.c                                       |  37 +++-
 net/bridge/br_ioctl.c                              |   5 +-
 net/can/af_can.c                                   |  12 +-
 net/can/af_can.h                                   |   3 +-
 net/can/bcm.c                                      |  27 ++-
 net/can/gw.c                                       |   2 +-
 net/can/raw.c                                      |   4 +-
 net/ceph/messenger.c                               |  13 ++
 net/core/dev.c                                     | 109 ++++++------
 net/core/drop_monitor.c                            |  39 ++++-
 net/core/sock.c                                    |  16 +-
 net/dccp/ipv4.c                                    |  26 +--
 net/dccp/ipv6.c                                    |  16 +-
 net/dccp/proto.c                                   |   4 +
 net/decnet/dn_route.c                              |   9 +-
 net/ipv4/cipso_ipv4.c                              |   4 +
 net/ipv4/igmp.c                                    |  55 ++++--
 net/ipv4/ipmr.c                                    |   4 +-
 net/ipv4/netfilter/ipt_rpfilter.c                  |   8 +-
 net/ipv4/ping.c                                    |   2 +
 net/ipv4/route.c                                   |  12 ++
 net/ipv4/tcp_fastopen.c                            |   3 +-
 net/ipv4/tcp_output.c                              |  21 ++-
 net/ipv4/udp.c                                     |   2 +-
 net/ipv6/addrconf.c                                |   4 +-
 net/ipv6/ip6_gre.c                                 |   3 +
 net/ipv6/ip6_offload.c                             |   1 +
 net/ipv6/ip6_output.c                              |  11 +-
 net/ipv6/ip6_tunnel.c                              |  49 ++++--
 net/ipv6/ip6mr.c                                   |   1 +
 net/ipv6/mcast.c                                   |  50 +++---
 net/ipv6/netfilter/ip6t_rpfilter.c                 |   8 +-
 net/ipv6/raw.c                                     |   7 +-
 net/ipv6/sit.c                                     |   5 +-
 net/ipv6/udp.c                                     |   2 +-
 net/irda/irqueue.c                                 |  34 ++--
 net/l2tp/l2tp_core.h                               |   1 +
 net/l2tp/l2tp_ip.c                                 |  27 ++-
 net/l2tp/l2tp_ip6.c                                |   2 +-
 net/llc/llc_conn.c                                 |   3 +
 net/llc/llc_sap.c                                  |   3 +
 net/mac80211/mesh.c                                |   2 +-
 net/mac80211/mlme.c                                |  17 +-
 net/netfilter/nf_log.c                             |   1 -
 net/netfilter/nft_log.c                            |   3 +-
 net/packet/af_packet.c                             |  45 +++--
 net/sched/act_pedit.c                              |  24 ++-
 net/sched/cls_api.c                                |   4 +-
 net/sched/em_meta.c                                |   9 +-
 net/sched/sch_dsmark.c                             |   3 +
 net/sched/sch_htb.c                                |   5 +-
 net/sched/sch_netem.c                              |  61 ++++++-
 net/sctp/socket.c                                  |  19 ++-
 net/socket.c                                       |  19 ++-
 net/sunrpc/auth_gss/gss_rpc_xdr.c                  |   2 +-
 net/sunrpc/auth_gss/svcauth_gss.c                  |   2 +-
 net/sunrpc/clnt.c                                  |   5 +
 net/sunrpc/sunrpc_syms.c                           |   1 +
 net/vmw_vsock/af_vsock.c                           |  21 +--
 net/wireless/core.h                                |   1 +
 net/wireless/mlme.c                                |  12 ++
 net/wireless/sme.c                                 |  14 ++
 scripts/kconfig/nconf.gui.c                        |  15 +-
 sound/core/seq/seq_memory.c                        |   9 +-
 sound/core/seq/seq_queue.c                         |  33 ++--
 sound/pci/hda/patch_conexant.c                     |  28 +++
 sound/pci/hda/patch_hdmi.c                         |   1 +
 sound/pci/hda/patch_realtek.c                      |   2 +
 sound/usb/card.c                                   |   1 -
 sound/usb/hiface/pcm.c                             |   2 +
 sound/usb/mixer.c                                  |   3 +-
 tools/perf/builtin-trace.c                         |   4 +-
 tools/perf/util/trace-event-scripting.c            |   6 +-
 tools/testing/selftests/net/run_netsocktests       |   2 +-
 .../powerpc/pmu/ebb/pmc56_overflow_test.c          |   2 +-
 339 files changed, 3027 insertions(+), 1429 deletions(-)

Adrian Hunter (1):
      mmc: sdhci: Fix recovery from tuning timeout

Aidan Thornton (2):
      USB: serial: ch341: add register and USB request definitions
      USB: serial: ch341: reinitialize chip on reconfiguration

Akinobu Mita (1):
      sysrq: attach sysrq handler correctly for 32-bit kernel

Al Viro (2):
      nfs_write_end(): fix handling of short copies
      Fix missing sanity check in /dev/sg

Alan Stern (7):
      PCI: Check for PME in targeted sleep state
      USB: UHCI: report non-PME wakeup signalling for Intel hardware
      USB: dummy-hcd: fix bug in stop_activity (handle ep0)
      USB: gadgetfs: fix unbounded memory allocation bug
      USB: gadgetfs: fix use-after-free bug
      USB: gadgetfs: fix checks of wTotalLength in config descriptors
      USB: fix problems with duplicate endpoint addresses

Aleksa Sarai (1):
      fs: exec: apply CLOEXEC before changing dumpable task flags

Aleksander Morgado (1):
      USB: serial: qcserial: add Dell DW5570 QDL

Alex Deucher (2):
      drm/radeon: add additional pci revision to dpm workaround
      drm/radeon: drop verde dpm quirks

Alex Porosanu (1):
      crypto: caam - fix AEAD givenc descriptors

Alexander Popov (1):
      tty: n_hdlc: get rid of racy n_hdlc.tbuf

Alexander Usyskin (1):
      mei: move write cb to completion on credentials failures

Alexey Kodanev (1):
      tcp: initialize max window for a new fastopen socket

Amir Vadai (1):
      net/sched: pedit: make sure that offset is valid

Ander Conselvan de Oliveira (1):
      drm/i915: Don&#39;t leak edid in intel_crt_detect_ddc()

Andrew Collins (1):
      net: Add netdev all_adj_list refcnt propagation to fix panic

Andrey Ryabinin (1):
      drm/i915: fix use-after-free in page_flip_completed()

Andy Shevchenko (1):
      platform/x86: intel_mid_powerbtn: Set IRQ_ONESHOT

Anoob Soman (2):
      packet: call fanout_release, while UNREGISTERING a netdev
      packet: Do not call fanout_release from atomic contexts

Anssi Hannula (3):
      mmc: core: fix multi-bit bus width without high-speed mode
      net: xilinx_emaclite: fix receive buffer overflow
      net: xilinx_emaclite: fix freezes due to unordered I/O

Anton Blanchard (1):
      powerpc: Ignore reserved field in DCSR and PVR reads and writes

Ard Biesheuvel (7):
      crypto: arm64/ghash-ce - fix for big endian
      crypto: arm64/sha1-ce - fix for big endian
      crypto: arm64/sha2-ce - fix for big endian
      crypto: arm64/aes-ccm-ce: fix for big endian
      crypto: arm64/aes-neon - fix for big endian
      crypto: arm64/aes-xts-ce: fix for big endian
      crypto: arm64/aes-blk - honour iv_out requirement in CBC and CTR modes

Arnaldo Carvalho de Melo (2):
      perf trace: Use the syscall raw_syscalls:sys_enter timestamp
      perf scripting: Avoid leaking the scripting_context variable

Arnd Bergmann (5):
      scsi: mvsas: fix command_active typo
      DaVinci-VPFE-Capture: fix error handling
      s5k4ecgx: select CRC32 helper
      ARM: ux500: fix prcmu_is_cpu_in_wfi() calculation
      ISDN: eicon: silence misleading array-bounds warning

Arvind Yadav (1):
      ata: sata_mv:- Handle return value of devm_ioremap.

Augusto Mecking Caringi (1):
      vme: Fix wrong pointer utilization in ca91cx42_slave_get

Axel Lin (1):
      PM / devfreq: Add proper locking around list_del()

Baolin Wang (1):
      usb: host: xhci: Fix possible wild pointer when handling abort command

Bart Van Assche (4):
      dm rq: fix a race condition in rq_completed()
      IB/mad: Fix an array index check
      IPoIB: Avoid reading an uninitialized member variable
      IB/multicast: Check ib_find_pkey() return value

Bartosz Golaszewski (1):
      ARM: davinci: da850: don&#39;t add emac clock to lookup table twice

Ben Hutchings (8):
      kconfig/nconf: Fix hang when editing symbol with a long prompt
      pegasus: Use heap buffers for all register access
      rtl8150: Use heap buffers for all register access
      catc: Combine failure cleanup code in catc_probe()
      catc: Use heap buffer for memory size test
      net/sock: Add sock_efree() function
      Revert &quot;KVM: x86: expose MSR_TSC_AUX to userspace&quot;
      Linux 3.16.42

Beniamino Galvani (1):
      bonding: set carrier off for devices created through netlink

Benjamin Block (1):
      scsi: zfcp: fix use-after-&quot;free&quot; in FC ingress path after TMF

Benjamin Marzinski (1):
      dm space map metadata: fix &#39;struct sm_metadata&#39; leak on failed create

Benjamin Poirier (1):
      mlx4: Invoke softirqs after napi_reschedule

Bjorn Helgaas (1):
      x86/PCI: Ignore _CRS on Supermicro X8DTH-i/6/iF/6F

Bjørn Mork (3):
      USB: serial: option: add device ID for HP lt2523 (Novatel E371)
      cdc_ncm: workaround for EM7455 &quot;silent&quot; data interface
      qmi_wwan/cdc_ether: add device ID for HP lt2523 (Novatel E371) WWAN card

Boris Ostrovsky (2):
      xen/gntdev: Use VM_MIXEDMAP instead of VM_IO to avoid NUMA balancing
      xen-netfront: Delete rx_refill_timer in xennet_disconnect_backend()

Chandan Rajendra (2):
      ext4: fix mballoc breakage with 64k block size
      ext4: fix stack memory corruption with 64k block size

Chanwoo Choi (1):
      PM / devfreq: Fix the bug of devfreq_add_device when governor is NULL

Chris Brandt (1):
      clk: renesas: mstp: Support 8-bit registers for r7s72100

Chris Friesen (1):
      route: do not cache fib route info on local routes with oif

Christopher Spinrath (1):
      ARM: dts: imx6q-cm-fx6: fix fec pinctrl

Chuck Lever (2):
      nfs: Don&#39;t increment lock sequence ID after NFS4ERR_MOVED
      nfs: Fix &quot;Don&#39;t increment lock sequence ID after NFS4ERR_MOVED&quot;

Con Kolivas (1):
      ALSA: usb-audio: Add QuickCam Communicate Deluxe/S7500 to volume_control_quirks

Dan Carpenter (6):
      usb: xhci-mem: use passed in GFP flags instead of GFP_KERNEL
      staging: media: davinci_vpfe: unlock on error in vpfe_reqbufs()
      ext4: return -ENOMEM instead of success
      sparc: leon: Fix a retry loop in leon_init_timers()
      target/iscsi: Fix double free in lio_target_tiqn_addtpg()
      ipv6: pointer math error in ip6_tnl_parse_tlv_enc_lim()

Daniel Borkmann (1):
      net, sched: fix soft lockup in tc_classify

Daniel Dressler (1):
      Btrfs: delayed-inode: replace root args iff only fs_info used

Daniele Palmas (1):
      USB: serial: option: add support for Telit LE922A PIDs 0x1040, 0x1041

Darren Stevens (1):
      powerpc: Add missing error check to prom_find_boot_cpu()

Darrick J. Wong (2):
      ext4: reject inodes with negative size
      xfs: update MAINTAINERS

Dave Jones (1):
      ipv6: handle -EFAULT from skb_copy_bits

Dave Martin (6):
      tile/ptrace: Preserve previous registers for short regset write
      arm64/ptrace: Preserve previous registers for short regset write
      arm64/ptrace: Avoid uninitialised struct padding in fpr_set()
      arm64/ptrace: Reject attempts to set incomplete hardware breakpoint fields
      powerpc/ptrace: Preserve previous fprs/vsrs on short regset write
      ARM: 8643/3: arm/ptrace: Preserve previous registers for short regset write

David Henningsson (1):
      ALSA: hda - Add inverted internal mic for Asus Aspire 4830T

David Matlack (2):
      jump_labels: API for flushing deferred jump label updates
      KVM: x86: flush pending lapic jump label updates on module unload

David S. Miller (2):
      irda: Fix lockdep annotations in hashbin_delete().
      decnet: Do not build routes to devices without decnet private data.

Davidlohr Bueso (1):
      ipc/shm: Fix shmat mmap nil-page protection

Douglas Caetano dos Santos (1):
      tcp: fix wrong checksum calculation on MTU probing

Einar Jón (1):
      can: c_can_pci: fix null-pointer-deref in c_can_start() - set device pointer

Eli Cohen (1):
      IB/mlx5: Wait for all async command completions to complete

Eran Ben Elisha (1):
      IB/mlx4: When no DMFS for IPoIB, don&#39;t allow NET_IF QPs

Eric Dumazet (22):
      gro: use min_t() in skb_gro_reset_offset()
      net: fix harmonize_features() vs NETIF_F_HIGHDMA
      ip6_tunnel: must reload ipv6h in ip6ip6_tnl_xmit()
      sysctl: fix proc_doulongvec_ms_jiffies_minmax()
      net: use a work queue to defer net_disable_timestamp() work
      netlabel: out of bound access in cipso_v4_validate()
      l2tp: do not use udp_ioctl()
      net/llc: avoid BUG_ON() in skb_orphan()
      packet: fix races in fanout_add()
      net: fix sk_mem_reclaim_partial()
      tcp: fix overflow in __tcp_retransmit_skb()
      net: avoid sk_forward_alloc overflows
      net: clear sk_err_soft in sk_clone_lock()
      net: mangle zero checksum in skb_checksum_help()
      dccp: do not send reset to already closed sockets
      dccp: fix out of bound access in dccp_v4_err()
      ipv6: dccp: fix out of bound access in dccp_v6_err()
      ipv6: dccp: add missing bind_conflict to dccp_ipv6_mapped
      net/dccp: fix use-after-free in dccp_invalid_packet
      can: Fix kernel panic at security_sock_rcv_skb
      ipv6: fix ip6_tnl_parse_tlv_enc_lim()
      tcp: fix 0 divide in __tcp_select_window()

Eric Ren (1):
      ocfs2: fix crash caused by stale lvb with fsdlm plugin

Eric Sandeen (2):
      xfs: fix up xfs_swap_extent_forks inline extent handling
      xfs: set AGI buffer type in xlog_recover_clear_agi_bucket

Eugenia Emantayev (1):
      net/mlx4_en: Fix bad WQE issue

Eva Rachel Retuya (1):
      staging: iio: ad7606: fix improper setting of oversampling pins

Fabien Parent (1):
      ARM: dts: da850-evm: fix read access to SPI flash

Felipe Balbi (7):
      usb: gadget: composite: correctly initialize ep-&gt;maxpacket
      usb: add helper to extract bits 12:11 of wMaxPacketSize
      usb: gadget: composite: always set ep-&gt;mult to a sensible value
      usb: dwc3: gadget: set PCM1 field of isochronous-first TRBs
      usb: dwc3: ep0: add dwc3_ep0_prepare_one_trb()
      usb: dwc3: ep0: explicitly call dwc3_ep0_prepare_one_trb()
      usb: dwc3: gadget: always unmap EP0 requests

Feng Tang (1):
      net: alx: Work around the DMA RX overflow issue

Florian Fainelli (6):
      drivers: base: dma-mapping: Fix typo in dmam_alloc_non_coherent comments
      net: korina: Fix NAPI versus resources freeing
      net: stmmac: Fix race between stmmac_drv_probe and stmmac_open
      net: stmmac: Fix error path after register_netdev move
      net: systemport: Pad packet before inserting TSB
      net: systemport: Decouple flow control from __bcm_sysport_tx_reclaim

Gabriel Krisman Bertazi (1):
      mmc: sdhci: Ignore unexpected CARD_INT interrupts

Geert Uytterhoeven (1):
      usb: hub: Move hub_port_disable() to fix warning if PM is disabled

Geliang Tang (1):
      fs/notify/inode_mark.c: use list_next_entry in fsnotify_unmount_inodes

Geoff Levand (1):
      powerpc/ps3: Fix system hang with GCC 5 builds

Gerald Schaefer (1):
      s390/vmlogrdr: fix IUCV buffer allocation

Giuseppe Lippolis (1):
      USB: serial: option: add dlink dwm-158

Govindarajulu Varadarajan (1):
      enic: set skb-&gt;hash type properly

Greg Kroah-Hartman (2):
      usb: gadgetfs: restrict upper bound on device configuration size
      HID: hid-cypress: validate length of report

Guenter Roeck (3):
      cris: Only build flash rescue image if CONFIG_ETRAX_AXISFLASHMAP is selected
      hwmon: (ds620) Fix overflows seen when writing temperature limits
      hwmon: (g762) Fix overflows and crash seen when writing limit attributes

Hangbin Liu (3):
      igmp: do not remove igmp souce list info when set link down
      mld: do not remove mld souce list info when set link down
      igmp, mld: Fix memory leak in igmpv3/mld_del_delrec()

Hannes Frederic Sowa (1):
      udp: prevent skbs lingering in tunnel socket queues

Hans de Goede (1):
      drm/i915/dsi: Do not clear DPOUNIT_CLOCK_GATE_DISABLE from vlv_init_display_clock_gating

Hauke Mehrtens (1):
      mtd: nand: xway: disable module support

Helge Deller (1):
      parisc: Don&#39;t use BITS_PER_LONG in userspace-exported swab.h header

Herbert Xu (3):
      gro: Enter slow-path if there is no tailroom
      gro: Disable frag0 optimization on IPv6 ext headers
      tun: Fix TUN_PKT_STRIP setting

Hiroshi Shimamoto (1):
      sched/cputime: Fix invalid gtime in proc

Huang Rui (1):
      iommu/amd: Fix the left value check of cmd buffer

Hui Wang (1):
      ALSA: hda - adding a new NV HDMI/DP codec ID in the driver

Ian Campbell (1):
      VSOCK: do not disconnect socket when peer has shutdown SEND only

Ilia Mirkin (1):
      drm/nouveau/nv1a,nv1f/disp: fix memory clock rate retrieval

Ilya Dryomov (1):
      libceph: verify authorize reply on connect

Ivan Vecera (1):
      be2net: fix status check in be_cmd_pmac_add()

J. Bruce Fields (2):
      svcrpc: don&#39;t leak contexts on PROC_DESTROY
      svcrpc: fix oops in absence of krb5 module

Jack Morgenstein (5):
      IB/mlx4: Fix out-of-range array index in destroy qp flow
      net/mlx4_core: Use-after-free causes a resource leak in flow-steering detach
      net/mlx4_core: Fix racy CQ (Completion Queue) free
      net/mlx4_core: Fix when to save some qp context flags for dynamic VST to VGT transitions
      net/mlx4_core: Eliminate warning messages for SRQ_LIMIT under SRIOV

Jakub Sitnicki (1):
      ipv6: Skip XFRM lookup if dst_entry in socket cache is valid

James Hogan (1):
      KVM: MIPS: Flush KVM entry code from icache globally

Jan Kara (1):
      fsnotify: Fix possible use-after-free in inode iteration on umount

Jeff Layton (1):
      ceph: fix bad endianness handling in parse_reply_info_extra

Jeff Mahoney (3):
      btrfs: fix error handling when run_delayed_extent_op fails
      btrfs: fix locking when we put back a delayed ref that&#39;s too new
      btrfs: fix btrfs_compat_ioctl failures on non-compat ioctls

Jens Axboe (1):
      nbd: fix use-after-free of rq/bio in the xmit path

Jeremy Linton (1):
      net: sky2: Fix shutdown crash

Jiri Slaby (2):
      net: sctp, forbid negative length
      TTY: n_hdlc, fix lockdep false positive

Johan Hovold (34):
      powerpc/ibmebus: Fix device reference leaks in sysfs interface
      powerpc/ibmebus: Fix further device reference leaks
      powerpc/pci/rpadlpar: Fix device reference leaks
      USB: phy: am335x-control: fix device and of_node leaks
      USB: serial: kl5kusb105: fix open error path
      bus: vexpress-config: fix device reference leak
      USB: serial: cyberjack: fix NULL-deref at open
      USB: serial: garmin_gps: fix memory leak on failed URB submit
      USB: serial: io_edgeport: fix NULL-deref at open
      USB: serial: io_ti: fix NULL-deref at open
      USB: serial: io_ti: fix another NULL-deref at open
      USB: serial: iuu_phoenix: fix NULL-deref at open
      USB: serial: keyspan_pda: verify endpoints at probe
      USB: serial: kobil_sct: fix NULL-deref in write
      USB: serial: mos7720: fix NULL-deref at open
      USB: serial: mos7720: fix use-after-free on probe errors
      USB: serial: mos7720: fix parport use-after-free on probe errors
      USB: serial: mos7720: fix parallel probe
      USB: serial: mos7840: fix NULL-deref at open
      USB: serial: mos7840: fix misleading interrupt-URB comment
      USB: serial: omninet: fix NULL-derefs at open and disconnect
      USB: serial: oti6858: fix NULL-deref at open
      USB: serial: pl2303: fix NULL-deref at open
      USB: serial: quatech2: fix sleep-while-atomic in close
      USB: serial: spcp8x5: fix NULL-deref at open
      USB: serial: ti_usb_3410_5052: fix NULL-deref at open
      USB: ch341: remove redundant close from open error path
      USB: serial: ch341: fix initial modem-control state
      USB: serial: ch341: fix open and resume after B0
      USB: serial: ch341: fix modem-control and B0 handling
      USB: serial: ch341: fix open error handling
      USB: serial: ch341: fix resume after reset
      USB: serial: ch341: fix baud rate and line-control handling
      USB: serial: ch341: fix control-message error handling

Johannes Berg (1):
      cfg80211/mac80211: fix BSS leaks when abandoning assoc attempts

John Brooks (1):
      iio: dht11: Use usleep_range instead of msleep for start signal

Joonyoung Shim (1):
      clocksource/exynos_mct: Clear interrupt when cpu is shut down

Josef Bacik (1):
      nbd: only set MSG_MORE when we have more to send

Julien Grall (1):
      arm/xen: Use alloc_percpu rather than __alloc_percpu

Jussi Laako (1):
      ALSA: hiface: Fix M2Tech hiFace driver sampling rate change

Kamal Heib (1):
      IB/IPoIB: Remove can&#39;t use GFP_NOIO warning

Kashyap Desai (1):
      scsi: megaraid_sas: For SRIOV enabled firmware, ensure VF driver waits for 30secs before reset

Kefeng Wang (1):
      ipv6: addrconf: Avoid addrconf_disable_change() using RCU read-side lock

Keno Fischer (1):
      mm/huge_memory.c: respect FOLL_FORCE/FOLL_COW for thp

Kinglong Mee (1):
      SUNRPC: cleanup ida information when removing sunrpc module

Kirtika Ruchandani (1):
      regmap: cache: Remove unused &#39;blksize&#39; variable

Konstantin Khlebnikov (1):
      md/raid5: limit request size according to implementation limits

Krzysztof Kozlowski (1):
      thermal: hwmon: Properly report critical temperature in sysfs

Krzysztof Opasiak (1):
      usb: gadget: composite: Test get_alt() presence instead of set_alt()

Kyle Roeschley (1):
      ARM: zynq: Reserve correct amount of non-DMA RAM

Larry Finger (2):
      ssb: Fix error routine when fallback SPROM fails
      powerpc: Fix build warning on 32-bit PPC

Leon Romanovsky (1):
      net/mlx4: Remove BUG_ON from ICM allocation routine

Linus Walleij (1):
      regulator: stw481x-vmmc: fix ages old enable error

Liping Zhang (2):
      netfilter: rpfilter: fix incorrect loopback packet judgment
      netfilter: nft_log: restrict the log prefix length to 127

Lu Baolu (2):
      usb: xhci: fix possible wild pointer
      usb: xhci: hold lock over xhci_abort_cmd_ring()

Lukasz Odzioba (1):
      x86/cpu: Fix bootup crashes by sanitizing the argument of the &#39;clearcpuid=&#39; command-line option

Lukáš Lalinský (1):
      USB: Add quirk for WORLDE easykey.25 MIDI keyboard

Madhavan Srinivasan (1):
      selftest/powerpc: Wrong PMC initialized in pmc56_overflow test

Maor Gottlieb (3):
      IB/mlx5: Put non zero value in max_ah
      IB/mlx4: Set traffic class in AH
      IB/mlx4: Put non zero value in max_ah device attribute

Marcel J.E. Mol (1):
      USB: serial: pl2303: add ATEN device ID

Marcelo Ricardo Leitner (3):
      sctp: assign assoc_id earlier in __sctp_connect
      sctp: avoid BUG_ON on sctp_wait_for_sndbuf
      sctp: deny peeloff operation on asocs with threads sleeping on it

Marcos Paulo de Souza (1):
      Input: i8042 - add Pegatron touchpad to noloop table

Mark Bloch (1):
      IB/core: Save QP in ib_flow structure

Mark Rutland (2):
      ARM: 8634/1: hw_breakpoint: blacklist Scorpion CPUs
      arm64: avoid returning from bad_mode

Mathias Nyman (4):
      usb: hub: Fix auto-remount of safely removed or ejected USB-3 devices
      xhci: free xhci virtual devices with leaf nodes first
      xhci: Handle command completion and timeout race
      xhci: fix deadlock at host remove by running watchdog correctly

Mauro Carvalho Chehab (1):
      siano: make it work again with CONFIG_VMAP_STACK

Maxim Patlasov (1):
      btrfs: limit async_work allocation and worker func duration

Maxime Jayat (1):
      net: socket: fix recvmmsg not returning error from sock_error

Michal Hocko (2):
      hotplug: Make register and unregister notifier API symmetric
      mm, fs: check for fatal signals in do_generic_file_read()

Michal Tesar (1):
      igmp: Make igmp group member RFC 3376 compliant

Michel Dänzer (2):
      drm/radeon: Hide the HW cursor while it&#39;s out of bounds
      drm/radeon: Use mode h/vdisplay fields to hide out of bounds HW cursor

Mike Kravetz (1):
      mm/hugetlb.c: fix reservation race when freeing surplus pages

Miklos Szeredi (1):
      vfs: fix uninitialized flags in splice_to_pipe()

Nathaniel Quillin (1):
      USB: cdc-acm: add device id for GW Instek AFG-125

Neil Horman (1):
      netem: Segment GSO packets on enqueue

NeilBrown (2):
      block_dev: don&#39;t test bdev-&gt;bd_contains when it is not stable
      NFSv4.1: nfs4_fl_prepare_ds must be careful about reporting success.

Nicholas Bellinger (3):
      target: Use correct SCSI status during EXTENDED_COPY exception
      target: Fix early transport_generic_handle_tmr abort scenario
      target: Fix COMPARE_AND_WRITE ref leak for non GOOD status

Nicholas Mc Guire (1):
      x86/boot: Add missing declaration of string functions

Nicholas Piggin (1):
      powerpc/boot: Request no dynamic linker for boot wrapper

Nicolai Stange (1):
      f2fs: set -&gt;owner for debugfs status file&#39;s file_operations

Nicolas Iooss (1):
      ite-cir: initialize use_demodulator before using it

Nicolas PLANEL (1):
      USB: ch341: set tty baud speed according to tty struct

Nikolay Aleksandrov (1):
      net: bridge: fix old ioctl unlocked net device walk

Oliver Hartkopp (1):
      can: bcm: fix hrtimer/tasklet termination in bcm op removal

Oliver Neukum (1):
      usb: storage: unusual_uas: Add JMicron JMS56x to unusual device

Ondrej Kozina (1):
      dm crypt: mark key as invalid until properly loaded

Pan Bian (2):
      USB: serial: kl5kusb105: abort on open exception path
      clk: clk-wm831x: fix a logic error

Paolo Abeni (1):
      ip6_tunnel: disable caching when the traffic class is inherited

Paolo Bonzini (1):
      kvm: fix page struct leak in handle_vmon

Patrik Jakobsson (1):
      drm/gma500: Add compat ioctl

Paul Mackerras (1):
      KVM: PPC: Book3S HV: Save/restore XER in checkpointed register state

Pavel Shilovsky (3):
      CIFS: Fix missing nls unload in smb2_reconnect()
      CIFS: Fix a possible memory corruption in push locks
      CIFS: Fix a possible memory corruption during reconnect

Peter Zijlstra (1):
      perf/core: Fix PERF_RECORD_MMAP2 prot/flags for anonymous memory

Quinn Tran (1):
      qla2xxx: Fix crash due to null pointer access

Rabin Vincent (1):
      block: protect iterate_bdevs() against concurrent close

Rasmus Villemoes (1):
      lib/vsprintf.c: improve sanity check in vsnprintf()

Reiter Wolfgang (2):
      drop_monitor: add missing call to genlmsg_end
      drop_monitor: consider inserted data in genlmsg_end

Richard Genoud (1):
      tty/serial: atmel: RS485 half duplex w/DMA: enable RX after TX is done

Richard Weinberger (1):
      ubifs: Fix journal replay wrt. xattr nodes

Robbie Ko (1):
      Btrfs: fix tree search logic when replaying directory entry deletes

Rolf Eike Beer (1):
      selftests: do not require bash to run netsocktests testcase

Russell Currey (1):
      drivers/gpu/drm/ast: Fix infinite loop if read fails

Russell King (1):
      i2c: mux: pca954x: fix i2c mux selection caching

Saeed Mahameed (1):
      IB/mlx4: Fix port query for 56Gb Ethernet links

Salvatore Benedetto (1):
      crypto: api - Clear CRYPTO_ALG_DEAD bit before registering an alg

Sergei Shtylyov (3):
      sh_eth: enable RX descriptor word 0 shift on SH7734
      sh_eth: fix EESIPR values for SH77{34|63}
      sh_eth: R8A7740 supports packet shecksumming

Sergey Senozhatsky (1):
      printk: use rcuidle console tracepoint

Shannon Nelson (1):
      tcp: fix tcp_fastopen unaligned access complaints on sparc

Shaohua Li (1):
      md: MD_RECOVERY_NEEDED is set for mddev-&gt;recovery

Shmulik Ladkani (1):
      net/sched: em_meta: Fix &#39;meta vlan&#39; to correctly recognize zero VID frames

Simon Horman (1):
      sit: correct IP protocol used in ipip6_err

Soheil Hassas Yeganeh (1):
      sock: fix sendmmsg for partial sendmsg

Stefan Wahren (1):
      mmc: mxs-mmc: Fix additional cycles after transmission stop

Steffen Maier (3):
      scsi: zfcp: do not trace pure benign residual HBA responses at default level
      scsi: zfcp: fix rport unblock race with LUN recovery
      scsi: zfcp: fix use-after-free by not tracing WKA port open/close on failed send

Steven Rostedt (Red Hat) (2):
      ftrace/x86_32: Set ftrace_stub to weak to prevent gcc from using short jumps to it
      fgraph: Handle a case where a tracer ignores set_graph_notrace

Takashi Iwai (7):
      ALSA: usb-audio: Fix bogus error return in snd_usb_create_stream()
      ALSA: hda - Add the top speaker pin config for HP Spectre x360
      ALSA: hda - Gate the mic jack on HP Z1 Gen3 AiO
      ALSA: hda - Fix up GPIO for ASUS ROG Ranger
      ALSA: hda - Apply asus-mode8 fixup to ASUS X71SL
      ALSA: seq: Don&#39;t handle loop timeout at snd_seq_pool_done()
      ALSA: seq: Fix race at creating a queue

Theodore Ts&#39;o (3):
      ext4: fix in-superblock mount options processing
      ext4: use more strict checks for inodes_per_block on mount
      ext4: add sanity checking to count_overhead()

Thorsten Horstmann (1):
      mac80211: Fix adding of mesh vendor IEs

Tom Goff (1):
      ipmr/ip6mr: Initialize the last assert time of mfc entries.

Tony Lindgren (1):
      usb: musb: Fix trying to free already-free IRQ 4

Trond Myklebust (1):
      NFS: Fix a performance regression in readdir

Vineet Gupta (2):
      ARC: [arcompact] handle unaligned access delay slot corner case
      ARC: [arcompact] brown paper bag bug in unaligned access delay slot fixup

Vlad Tsyrklevich (1):
      i2c: fix kernel memory disclosure in dev interface

Vladimir Zapolskiy (3):
      ARM: dts: imx31: fix clock control module interrupts description
      ARM: dts: imx31: move CCM device node to AIPS2 bus devices
      ARM: dts: imx31: fix AVIC base address

WANG Cong (4):
      ping: fix a null pointer dereference
      sch_htb: update backlog as well
      sch_dsmark: update backlog as well
      sit: fix a double free on error path

Wan Ahmad Zainie (1):
      usb: xhci: apply XHCI_PME_STUCK_QUIRK to Intel Apollo Lake

Wei Fang (1):
      scsi: avoid a permanent stop of the scsi device&#39;s request queue

Wei Yongjun (1):
      iw_cxgb4: Fix error return code in c4iw_rdev_open()

Willem de Bruijn (2):
      tun: read vnet_hdr_sz once
      macvtap: read vnet_hdr_size once

Yang Yang (1):
      futex: Move futex_init() to core_initcall

Yegor Yefremov (1):
      can: ti_hecc: add missing prepare and unprepare of the clock

hayeswang (1):
      r8152: fix the sw rx checksum is unavailable

stephen hemminger (1):
      netvsc: reduce maximum GSO size
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/clock/imx31-clock.txt b/Documentation/devicetree/bindings/clock/imx31-clock.txt</span>
<span class="p_header">index 19df842c694f..8163d565f697 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/clock/imx31-clock.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/clock/imx31-clock.txt</span>
<span class="p_chunk">@@ -77,7 +77,7 @@</span> <span class="p_context"> Examples:</span>
 clks: ccm@53f80000{
 	compatible = &quot;fsl,imx31-ccm&quot;;
 	reg = &lt;0x53f80000 0x4000&gt;;
<span class="p_del">-	interrupts = &lt;0 31 0x04 0 53 0x04&gt;;</span>
<span class="p_add">+	interrupts = &lt;31&gt;, &lt;53&gt;;</span>
 	#clock-cells = &lt;1&gt;;
 };
 
<span class="p_header">diff --git a/Documentation/virtual/kvm/api.txt b/Documentation/virtual/kvm/api.txt</span>
<span class="p_header">index 769c2cb7f9b3..e86da4377402 100644</span>
<span class="p_header">--- a/Documentation/virtual/kvm/api.txt</span>
<span class="p_header">+++ b/Documentation/virtual/kvm/api.txt</span>
<span class="p_chunk">@@ -1891,6 +1891,7 @@</span> <span class="p_context"> registers, find a list below:</span>
   PPC   | KVM_REG_PPC_TM_VSCR	| 32
   PPC   | KVM_REG_PPC_TM_DSCR	| 64
   PPC   | KVM_REG_PPC_TM_TAR	| 64
<span class="p_add">+  PPC   | KVM_REG_PPC_TM_XER   | 64</span>
 
 ARM registers are mapped using the lower 32 bits.  The upper 16 of that
 is the register group type, or coprocessor number:
<span class="p_header">diff --git a/MAINTAINERS b/MAINTAINERS</span>
<span class="p_header">index 65791c0891a9..b2a5243e9d0b 100644</span>
<span class="p_header">--- a/MAINTAINERS</span>
<span class="p_header">+++ b/MAINTAINERS</span>
<span class="p_chunk">@@ -10057,11 +10057,11 @@</span> <span class="p_context"> F:	arch/x86/xen/*swiotlb*</span>
 F:	drivers/xen/*swiotlb*
 
 XFS FILESYSTEM
<span class="p_del">-M:	Dave Chinner &lt;david@fromorbit.com&gt;</span>
<span class="p_add">+M:	Darrick J. Wong &lt;darrick.wong@oracle.com&gt;</span>
 M:	linux-xfs@vger.kernel.org
 L:	linux-xfs@vger.kernel.org
 W:	http://xfs.org/
<span class="p_del">-T:	git git://git.kernel.org/pub/scm/linux/kernel/git/dgc/linux-xfs.git</span>
<span class="p_add">+T:	git git://git.kernel.org/pub/scm/fs/xfs/xfs-linux.git</span>
 S:	Supported
 F:	Documentation/filesystems/xfs.txt
 F:	fs/xfs/
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 1edbcba47f75..9deaac9255ff 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 16
<span class="p_del">-SUBLEVEL = 41</span>
<span class="p_add">+SUBLEVEL = 42</span>
 EXTRAVERSION =
 NAME = Museum of Fishiegoodies
 
<span class="p_header">diff --git a/arch/arc/kernel/unaligned.c b/arch/arc/kernel/unaligned.c</span>
<span class="p_header">index 7ff5b5c183bb..2cc82b6ec23d 100644</span>
<span class="p_header">--- a/arch/arc/kernel/unaligned.c</span>
<span class="p_header">+++ b/arch/arc/kernel/unaligned.c</span>
<span class="p_chunk">@@ -240,8 +240,9 @@</span> <span class="p_context"> int misaligned_fixup(unsigned long address, struct pt_regs *regs,</span>
 	if (state.fault)
 		goto fault;
 
<span class="p_add">+	/* clear any remanants of delay slot */</span>
 	if (delay_mode(regs)) {
<span class="p_del">-		regs-&gt;ret = regs-&gt;bta;</span>
<span class="p_add">+		regs-&gt;ret = regs-&gt;bta &amp; ~1U;</span>
 		regs-&gt;status32 &amp;= ~STATUS_DE_MASK;
 	} else {
 		regs-&gt;ret += state.instr_len;
<span class="p_header">diff --git a/arch/arm/boot/dts/da850-evm.dts b/arch/arm/boot/dts/da850-evm.dts</span>
<span class="p_header">index 1e11e5a5f723..21342ab78ff5 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/da850-evm.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/da850-evm.dts</span>
<span class="p_chunk">@@ -59,6 +59,7 @@</span> <span class="p_context"></span>
 				#size-cells = &lt;1&gt;;
 				compatible = &quot;m25p64&quot;;
 				spi-max-frequency = &lt;30000000&gt;;
<span class="p_add">+				m25p,fast-read;</span>
 				reg = &lt;0&gt;;
 				partition@0 {
 					label = &quot;U-Boot-SPL&quot;;
<span class="p_header">diff --git a/arch/arm/boot/dts/imx31.dtsi b/arch/arm/boot/dts/imx31.dtsi</span>
<span class="p_header">index c34f82581248..626e5e374572 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx31.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx31.dtsi</span>
<span class="p_chunk">@@ -30,11 +30,11 @@</span> <span class="p_context"></span>
 		};
 	};
 
<span class="p_del">-	avic: avic-interrupt-controller@60000000 {</span>
<span class="p_add">+	avic: interrupt-controller@68000000 {</span>
 		compatible = &quot;fsl,imx31-avic&quot;, &quot;fsl,avic&quot;;
 		interrupt-controller;
 		#interrupt-cells = &lt;1&gt;;
<span class="p_del">-		reg = &lt;0x60000000 0x100000&gt;;</span>
<span class="p_add">+		reg = &lt;0x68000000 0x100000&gt;;</span>
 	};
 
 	soc {
<span class="p_chunk">@@ -110,13 +110,6 @@</span> <span class="p_context"></span>
 				interrupts = &lt;19&gt;;
 				clocks = &lt;&amp;clks 25&gt;;
 			};
<span class="p_del">-</span>
<span class="p_del">-			clks: ccm@53f80000{</span>
<span class="p_del">-				compatible = &quot;fsl,imx31-ccm&quot;;</span>
<span class="p_del">-				reg = &lt;0x53f80000 0x4000&gt;;</span>
<span class="p_del">-				interrupts = &lt;0 31 0x04 0 53 0x04&gt;;</span>
<span class="p_del">-				#clock-cells = &lt;1&gt;;</span>
<span class="p_del">-			};</span>
 		};
 
 		aips@53f00000 { /* AIPS2 */
<span class="p_chunk">@@ -126,6 +119,13 @@</span> <span class="p_context"></span>
 			reg = &lt;0x53f00000 0x100000&gt;;
 			ranges;
 
<span class="p_add">+			clks: ccm@53f80000{</span>
<span class="p_add">+				compatible = &quot;fsl,imx31-ccm&quot;;</span>
<span class="p_add">+				reg = &lt;0x53f80000 0x4000&gt;;</span>
<span class="p_add">+				interrupts = &lt;31&gt;, &lt;53&gt;;</span>
<span class="p_add">+				#clock-cells = &lt;1&gt;;</span>
<span class="p_add">+			};</span>
<span class="p_add">+</span>
 			gpt: timer@53f90000 {
 				compatible = &quot;fsl,imx31-gpt&quot;;
 				reg = &lt;0x53f90000 0x4000&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6q-cm-fx6.dts b/arch/arm/boot/dts/imx6q-cm-fx6.dts</span>
<span class="p_header">index 99b46f8030ad..172579a14aae 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6q-cm-fx6.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6q-cm-fx6.dts</span>
<span class="p_chunk">@@ -65,7 +65,6 @@</span> <span class="p_context"></span>
 				MX6QDL_PAD_ENET_REF_CLK__ENET_TX_CLK	0x1b0b0
 				MX6QDL_PAD_ENET_MDIO__ENET_MDIO		0x1b0b0
 				MX6QDL_PAD_ENET_MDC__ENET_MDC		0x1b0b0
<span class="p_del">-				MX6QDL_PAD_GPIO_16__ENET_REF_CLK	0x4001b0a8</span>
 			&gt;;
 		};
 
<span class="p_header">diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h</span>
<span class="p_header">index 8c2b7321a478..4b401f1092f3 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/cputype.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/cputype.h</span>
<span class="p_chunk">@@ -79,6 +79,9 @@</span> <span class="p_context"></span>
 #define ARM_CPU_XSCALE_ARCH_V2		0x4000
 #define ARM_CPU_XSCALE_ARCH_V3		0x6000
 
<span class="p_add">+/* Qualcomm implemented cores */</span>
<span class="p_add">+#define ARM_CPU_PART_SCORPION		0x510002d0</span>
<span class="p_add">+</span>
 extern unsigned int processor_id;
 
 #ifdef CONFIG_CPU_CP15
<span class="p_header">diff --git a/arch/arm/kernel/hw_breakpoint.c b/arch/arm/kernel/hw_breakpoint.c</span>
<span class="p_header">index 4d963fb66e3f..5c7404326b7c 100644</span>
<span class="p_header">--- a/arch/arm/kernel/hw_breakpoint.c</span>
<span class="p_header">+++ b/arch/arm/kernel/hw_breakpoint.c</span>
<span class="p_chunk">@@ -1067,6 +1067,22 @@</span> <span class="p_context"> static int __init arch_hw_breakpoint_init(void)</span>
 		return 0;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Scorpion CPUs (at least those in APQ8060) seem to set DBGPRSR.SPD</span>
<span class="p_add">+	 * whenever a WFI is issued, even if the core is not powered down, in</span>
<span class="p_add">+	 * violation of the architecture.  When DBGPRSR.SPD is set, accesses to</span>
<span class="p_add">+	 * breakpoint and watchpoint registers are treated as undefined, so</span>
<span class="p_add">+	 * this results in boot time and runtime failures when these are</span>
<span class="p_add">+	 * accessed and we unexpectedly take a trap.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * It&#39;s not clear if/how this can be worked around, so we blacklist</span>
<span class="p_add">+	 * Scorpion CPUs to avoid these issues.</span>
<span class="p_add">+	*/</span>
<span class="p_add">+	if ((read_cpuid_id() &amp; 0xff00fff0) == ARM_CPU_PART_SCORPION) {</span>
<span class="p_add">+		pr_info(&quot;Scorpion CPU detected. Hardware breakpoints and watchpoints disabled\n&quot;);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	has_ossr = core_has_os_save_restore();
 
 	/* Determine how many BRPs/WRPs are available. */
<span class="p_header">diff --git a/arch/arm/kernel/ptrace.c b/arch/arm/kernel/ptrace.c</span>
<span class="p_header">index a20ebfeac471..e81c15665f10 100644</span>
<span class="p_header">--- a/arch/arm/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/arm/kernel/ptrace.c</span>
<span class="p_chunk">@@ -600,7 +600,7 @@</span> <span class="p_context"> static int gpr_set(struct task_struct *target,</span>
 		   const void *kbuf, const void __user *ubuf)
 {
 	int ret;
<span class="p_del">-	struct pt_regs newregs;</span>
<span class="p_add">+	struct pt_regs newregs = *task_pt_regs(target);</span>
 
 	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf,
 				 &amp;newregs,
<span class="p_header">diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c</span>
<span class="p_header">index 45ce065e7170..1180a75cd707 100644</span>
<span class="p_header">--- a/arch/arm/mach-davinci/da850.c</span>
<span class="p_header">+++ b/arch/arm/mach-davinci/da850.c</span>
<span class="p_chunk">@@ -297,6 +297,16 @@</span> <span class="p_context"> static struct clk emac_clk = {</span>
 	.gpsc		= 1,
 };
 
<span class="p_add">+/*</span>
<span class="p_add">+ * In order to avoid adding the emac_clk to the clock lookup table twice (and</span>
<span class="p_add">+ * screwing up the linked list in the process) create a separate clock for</span>
<span class="p_add">+ * mdio inheriting the rate from emac_clk.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct clk mdio_clk = {</span>
<span class="p_add">+	.name		= &quot;mdio&quot;,</span>
<span class="p_add">+	.parent		= &amp;emac_clk,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static struct clk mcasp_clk = {
 	.name		= &quot;mcasp&quot;,
 	.parent		= &amp;pll0_sysclk2,
<span class="p_chunk">@@ -461,7 +471,7 @@</span> <span class="p_context"> static struct clk_lookup da850_clks[] = {</span>
 	CLK(NULL,		&quot;arm&quot;,		&amp;arm_clk),
 	CLK(NULL,		&quot;rmii&quot;,		&amp;rmii_clk),
 	CLK(&quot;davinci_emac.1&quot;,	NULL,		&amp;emac_clk),
<span class="p_del">-	CLK(&quot;davinci_mdio.0&quot;,	&quot;fck&quot;,		&amp;emac_clk),</span>
<span class="p_add">+	CLK(&quot;davinci_mdio.0&quot;,	&quot;fck&quot;,		&amp;mdio_clk),</span>
 	CLK(&quot;davinci-mcasp.0&quot;,	NULL,		&amp;mcasp_clk),
 	CLK(&quot;da8xx_lcdc.0&quot;,	&quot;fck&quot;,		&amp;lcdc_clk),
 	CLK(&quot;da830-mmc.0&quot;,	NULL,		&amp;mmcsd0_clk),
<span class="p_header">diff --git a/arch/arm/mach-ux500/pm.c b/arch/arm/mach-ux500/pm.c</span>
<span class="p_header">index b80a9a2e356e..ac32ad229429 100644</span>
<span class="p_header">--- a/arch/arm/mach-ux500/pm.c</span>
<span class="p_header">+++ b/arch/arm/mach-ux500/pm.c</span>
<span class="p_chunk">@@ -131,8 +131,8 @@</span> <span class="p_context"> bool prcmu_pending_irq(void)</span>
  */
 bool prcmu_is_cpu_in_wfi(int cpu)
 {
<span class="p_del">-	return readl(PRCM_ARM_WFI_STANDBY) &amp; cpu ? PRCM_ARM_WFI_STANDBY_WFI1 :</span>
<span class="p_del">-		     PRCM_ARM_WFI_STANDBY_WFI0;</span>
<span class="p_add">+	return readl(PRCM_ARM_WFI_STANDBY) &amp;</span>
<span class="p_add">+		(cpu ? PRCM_ARM_WFI_STANDBY_WFI1 : PRCM_ARM_WFI_STANDBY_WFI0);</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/arm/mach-zynq/common.c b/arch/arm/mach-zynq/common.c</span>
<span class="p_header">index 31a6fa40ba37..b4214cf082b1 100644</span>
<span class="p_header">--- a/arch/arm/mach-zynq/common.c</span>
<span class="p_header">+++ b/arch/arm/mach-zynq/common.c</span>
<span class="p_chunk">@@ -59,7 +59,7 @@</span> <span class="p_context"> void __iomem *zynq_scu_base;</span>
 static void __init zynq_memory_init(void)
 {
 	if (!__pa(PAGE_OFFSET))
<span class="p_del">-		memblock_reserve(__pa(PAGE_OFFSET), __pa(swapper_pg_dir));</span>
<span class="p_add">+		memblock_reserve(__pa(PAGE_OFFSET), 0x80000);</span>
 }
 
 static struct platform_device zynq_cpuidle_device = {
<span class="p_header">diff --git a/arch/arm/xen/enlighten.c b/arch/arm/xen/enlighten.c</span>
<span class="p_header">index 1e632430570b..e4d719ff71f6 100644</span>
<span class="p_header">--- a/arch/arm/xen/enlighten.c</span>
<span class="p_header">+++ b/arch/arm/xen/enlighten.c</span>
<span class="p_chunk">@@ -291,8 +291,7 @@</span> <span class="p_context"> static int __init xen_guest_init(void)</span>
 	 * for secondary CPUs as they are brought up.
 	 * For uniformity we use VCPUOP_register_vcpu_info even on cpu0.
 	 */
<span class="p_del">-	xen_vcpu_info = __alloc_percpu(sizeof(struct vcpu_info),</span>
<span class="p_del">-			                       sizeof(struct vcpu_info));</span>
<span class="p_add">+	xen_vcpu_info = alloc_percpu(struct vcpu_info);</span>
 	if (xen_vcpu_info == NULL)
 		return -ENOMEM;
 
<span class="p_header">diff --git a/arch/arm64/crypto/aes-ce-ccm-core.S b/arch/arm64/crypto/aes-ce-ccm-core.S</span>
<span class="p_header">index 432e4841cd81..d04eb27746d2 100644</span>
<span class="p_header">--- a/arch/arm64/crypto/aes-ce-ccm-core.S</span>
<span class="p_header">+++ b/arch/arm64/crypto/aes-ce-ccm-core.S</span>
<span class="p_chunk">@@ -9,6 +9,7 @@</span> <span class="p_context"></span>
  */
 
 #include &lt;linux/linkage.h&gt;
<span class="p_add">+#include &lt;asm/assembler.h&gt;</span>
 
 	.text
 	.arch	armv8-a+crypto
<span class="p_chunk">@@ -19,7 +20,7 @@</span> <span class="p_context"></span>
 	 */
 ENTRY(ce_aes_ccm_auth_data)
 	ldr	w8, [x3]			/* leftover from prev round? */
<span class="p_del">-	ld1	{v0.2d}, [x0]			/* load mac */</span>
<span class="p_add">+	ld1	{v0.16b}, [x0]			/* load mac */</span>
 	cbz	w8, 1f
 	sub	w8, w8, #16
 	eor	v1.16b, v1.16b, v1.16b
<span class="p_chunk">@@ -31,7 +32,7 @@</span> <span class="p_context"> ENTRY(ce_aes_ccm_auth_data)</span>
 	beq	8f				/* out of input? */
 	cbnz	w8, 0b
 	eor	v0.16b, v0.16b, v1.16b
<span class="p_del">-1:	ld1	{v3.2d}, [x4]			/* load first round key */</span>
<span class="p_add">+1:	ld1	{v3.16b}, [x4]			/* load first round key */</span>
 	prfm	pldl1strm, [x1]
 	cmp	w5, #12				/* which key size? */
 	add	x6, x4, #16
<span class="p_chunk">@@ -41,17 +42,17 @@</span> <span class="p_context"> ENTRY(ce_aes_ccm_auth_data)</span>
 	mov	v5.16b, v3.16b
 	b	4f
 2:	mov	v4.16b, v3.16b
<span class="p_del">-	ld1	{v5.2d}, [x6], #16		/* load 2nd round key */</span>
<span class="p_add">+	ld1	{v5.16b}, [x6], #16		/* load 2nd round key */</span>
 3:	aese	v0.16b, v4.16b
 	aesmc	v0.16b, v0.16b
<span class="p_del">-4:	ld1	{v3.2d}, [x6], #16		/* load next round key */</span>
<span class="p_add">+4:	ld1	{v3.16b}, [x6], #16		/* load next round key */</span>
 	aese	v0.16b, v5.16b
 	aesmc	v0.16b, v0.16b
<span class="p_del">-5:	ld1	{v4.2d}, [x6], #16		/* load next round key */</span>
<span class="p_add">+5:	ld1	{v4.16b}, [x6], #16		/* load next round key */</span>
 	subs	w7, w7, #3
 	aese	v0.16b, v3.16b
 	aesmc	v0.16b, v0.16b
<span class="p_del">-	ld1	{v5.2d}, [x6], #16		/* load next round key */</span>
<span class="p_add">+	ld1	{v5.16b}, [x6], #16		/* load next round key */</span>
 	bpl	3b
 	aese	v0.16b, v4.16b
 	subs	w2, w2, #16			/* last data? */
<span class="p_chunk">@@ -60,7 +61,7 @@</span> <span class="p_context"> ENTRY(ce_aes_ccm_auth_data)</span>
 	ld1	{v1.16b}, [x1], #16		/* load next input block */
 	eor	v0.16b, v0.16b, v1.16b		/* xor with mac */
 	bne	1b
<span class="p_del">-6:	st1	{v0.2d}, [x0]			/* store mac */</span>
<span class="p_add">+6:	st1	{v0.16b}, [x0]			/* store mac */</span>
 	beq	10f
 	adds	w2, w2, #16
 	beq	10f
<span class="p_chunk">@@ -79,7 +80,7 @@</span> <span class="p_context"> ENTRY(ce_aes_ccm_auth_data)</span>
 	adds	w7, w7, #1
 	bne	9b
 	eor	v0.16b, v0.16b, v1.16b
<span class="p_del">-	st1	{v0.2d}, [x0]</span>
<span class="p_add">+	st1	{v0.16b}, [x0]</span>
 10:	str	w8, [x3]
 	ret
 ENDPROC(ce_aes_ccm_auth_data)
<span class="p_chunk">@@ -89,27 +90,27 @@</span> <span class="p_context"> ENDPROC(ce_aes_ccm_auth_data)</span>
 	 * 			 u32 rounds);
 	 */
 ENTRY(ce_aes_ccm_final)
<span class="p_del">-	ld1	{v3.2d}, [x2], #16		/* load first round key */</span>
<span class="p_del">-	ld1	{v0.2d}, [x0]			/* load mac */</span>
<span class="p_add">+	ld1	{v3.16b}, [x2], #16		/* load first round key */</span>
<span class="p_add">+	ld1	{v0.16b}, [x0]			/* load mac */</span>
 	cmp	w3, #12				/* which key size? */
 	sub	w3, w3, #2			/* modified # of rounds */
<span class="p_del">-	ld1	{v1.2d}, [x1]			/* load 1st ctriv */</span>
<span class="p_add">+	ld1	{v1.16b}, [x1]			/* load 1st ctriv */</span>
 	bmi	0f
 	bne	3f
 	mov	v5.16b, v3.16b
 	b	2f
 0:	mov	v4.16b, v3.16b
<span class="p_del">-1:	ld1	{v5.2d}, [x2], #16		/* load next round key */</span>
<span class="p_add">+1:	ld1	{v5.16b}, [x2], #16		/* load next round key */</span>
 	aese	v0.16b, v4.16b
 	aese	v1.16b, v4.16b
 	aesmc	v0.16b, v0.16b
 	aesmc	v1.16b, v1.16b
<span class="p_del">-2:	ld1	{v3.2d}, [x2], #16		/* load next round key */</span>
<span class="p_add">+2:	ld1	{v3.16b}, [x2], #16		/* load next round key */</span>
 	aese	v0.16b, v5.16b
 	aese	v1.16b, v5.16b
 	aesmc	v0.16b, v0.16b
 	aesmc	v1.16b, v1.16b
<span class="p_del">-3:	ld1	{v4.2d}, [x2], #16		/* load next round key */</span>
<span class="p_add">+3:	ld1	{v4.16b}, [x2], #16		/* load next round key */</span>
 	subs	w3, w3, #3
 	aese	v0.16b, v3.16b
 	aese	v1.16b, v3.16b
<span class="p_chunk">@@ -120,47 +121,47 @@</span> <span class="p_context"> ENTRY(ce_aes_ccm_final)</span>
 	aese	v1.16b, v4.16b
 	/* final round key cancels out */
 	eor	v0.16b, v0.16b, v1.16b		/* en-/decrypt the mac */
<span class="p_del">-	st1	{v0.2d}, [x0]			/* store result */</span>
<span class="p_add">+	st1	{v0.16b}, [x0]			/* store result */</span>
 	ret
 ENDPROC(ce_aes_ccm_final)
 
 	.macro	aes_ccm_do_crypt,enc
 	ldr	x8, [x6, #8]			/* load lower ctr */
<span class="p_del">-	ld1	{v0.2d}, [x5]			/* load mac */</span>
<span class="p_del">-	rev	x8, x8				/* keep swabbed ctr in reg */</span>
<span class="p_add">+	ld1	{v0.16b}, [x5]			/* load mac */</span>
<span class="p_add">+CPU_LE(	rev	x8, x8			)	/* keep swabbed ctr in reg */</span>
 0:	/* outer loop */
<span class="p_del">-	ld1	{v1.1d}, [x6]			/* load upper ctr */</span>
<span class="p_add">+	ld1	{v1.8b}, [x6]			/* load upper ctr */</span>
 	prfm	pldl1strm, [x1]
 	add	x8, x8, #1
 	rev	x9, x8
 	cmp	w4, #12				/* which key size? */
 	sub	w7, w4, #2			/* get modified # of rounds */
 	ins	v1.d[1], x9			/* no carry in lower ctr */
<span class="p_del">-	ld1	{v3.2d}, [x3]			/* load first round key */</span>
<span class="p_add">+	ld1	{v3.16b}, [x3]			/* load first round key */</span>
 	add	x10, x3, #16
 	bmi	1f
 	bne	4f
 	mov	v5.16b, v3.16b
 	b	3f
 1:	mov	v4.16b, v3.16b
<span class="p_del">-	ld1	{v5.2d}, [x10], #16		/* load 2nd round key */</span>
<span class="p_add">+	ld1	{v5.16b}, [x10], #16		/* load 2nd round key */</span>
 2:	/* inner loop: 3 rounds, 2x interleaved */
 	aese	v0.16b, v4.16b
 	aese	v1.16b, v4.16b
 	aesmc	v0.16b, v0.16b
 	aesmc	v1.16b, v1.16b
<span class="p_del">-3:	ld1	{v3.2d}, [x10], #16		/* load next round key */</span>
<span class="p_add">+3:	ld1	{v3.16b}, [x10], #16		/* load next round key */</span>
 	aese	v0.16b, v5.16b
 	aese	v1.16b, v5.16b
 	aesmc	v0.16b, v0.16b
 	aesmc	v1.16b, v1.16b
<span class="p_del">-4:	ld1	{v4.2d}, [x10], #16		/* load next round key */</span>
<span class="p_add">+4:	ld1	{v4.16b}, [x10], #16		/* load next round key */</span>
 	subs	w7, w7, #3
 	aese	v0.16b, v3.16b
 	aese	v1.16b, v3.16b
 	aesmc	v0.16b, v0.16b
 	aesmc	v1.16b, v1.16b
<span class="p_del">-	ld1	{v5.2d}, [x10], #16		/* load next round key */</span>
<span class="p_add">+	ld1	{v5.16b}, [x10], #16		/* load next round key */</span>
 	bpl	2b
 	aese	v0.16b, v4.16b
 	aese	v1.16b, v4.16b
<span class="p_chunk">@@ -177,14 +178,14 @@</span> <span class="p_context"> ENDPROC(ce_aes_ccm_final)</span>
 	eor	v0.16b, v0.16b, v2.16b		/* xor mac with pt ^ rk[last] */
 	st1	{v1.16b}, [x0], #16		/* write output block */
 	bne	0b
<span class="p_del">-	rev	x8, x8</span>
<span class="p_del">-	st1	{v0.2d}, [x5]			/* store mac */</span>
<span class="p_add">+CPU_LE(	rev	x8, x8			)</span>
<span class="p_add">+	st1	{v0.16b}, [x5]			/* store mac */</span>
 	str	x8, [x6, #8]			/* store lsb end of ctr (BE) */
 5:	ret
 
 6:	eor	v0.16b, v0.16b, v5.16b		/* final round mac */
 	eor	v1.16b, v1.16b, v5.16b		/* final round enc */
<span class="p_del">-	st1	{v0.2d}, [x5]			/* store mac */</span>
<span class="p_add">+	st1	{v0.16b}, [x5]			/* store mac */</span>
 	add	w2, w2, #16			/* process partial tail block */
 7:	ldrb	w9, [x1], #1			/* get 1 byte of input */
 	umov	w6, v1.b[0]			/* get top crypted ctr byte */
<span class="p_header">diff --git a/arch/arm64/crypto/aes-ce.S b/arch/arm64/crypto/aes-ce.S</span>
<span class="p_header">index 685a18f731eb..56a258d4bada 100644</span>
<span class="p_header">--- a/arch/arm64/crypto/aes-ce.S</span>
<span class="p_header">+++ b/arch/arm64/crypto/aes-ce.S</span>
<span class="p_chunk">@@ -10,6 +10,7 @@</span> <span class="p_context"></span>
  */
 
 #include &lt;linux/linkage.h&gt;
<span class="p_add">+#include &lt;asm/assembler.h&gt;</span>
 
 #define AES_ENTRY(func)		ENTRY(ce_ ## func)
 #define AES_ENDPROC(func)	ENDPROC(ce_ ## func)
<span class="p_header">diff --git a/arch/arm64/crypto/aes-modes.S b/arch/arm64/crypto/aes-modes.S</span>
<span class="p_header">index f6e372c528eb..838dad5c209f 100644</span>
<span class="p_header">--- a/arch/arm64/crypto/aes-modes.S</span>
<span class="p_header">+++ b/arch/arm64/crypto/aes-modes.S</span>
<span class="p_chunk">@@ -193,15 +193,16 @@</span> <span class="p_context"> AES_ENTRY(aes_cbc_encrypt)</span>
 	cbz		w6, .Lcbcencloop
 
 	ld1		{v0.16b}, [x5]			/* get iv */
<span class="p_del">-	enc_prepare	w3, x2, x5</span>
<span class="p_add">+	enc_prepare	w3, x2, x6</span>
 
 .Lcbcencloop:
 	ld1		{v1.16b}, [x1], #16		/* get next pt block */
 	eor		v0.16b, v0.16b, v1.16b		/* ..and xor with iv */
<span class="p_del">-	encrypt_block	v0, w3, x2, x5, w6</span>
<span class="p_add">+	encrypt_block	v0, w3, x2, x6, w7</span>
 	st1		{v0.16b}, [x0], #16
 	subs		w4, w4, #1
 	bne		.Lcbcencloop
<span class="p_add">+	st1		{v0.16b}, [x5]			/* return iv */</span>
 	ret
 AES_ENDPROC(aes_cbc_encrypt)
 
<span class="p_chunk">@@ -211,7 +212,7 @@</span> <span class="p_context"> AES_ENTRY(aes_cbc_decrypt)</span>
 	cbz		w6, .LcbcdecloopNx
 
 	ld1		{v7.16b}, [x5]			/* get iv */
<span class="p_del">-	dec_prepare	w3, x2, x5</span>
<span class="p_add">+	dec_prepare	w3, x2, x6</span>
 
 .LcbcdecloopNx:
 #if INTERLEAVE &gt;= 2
<span class="p_chunk">@@ -248,7 +249,7 @@</span> <span class="p_context"> AES_ENTRY(aes_cbc_decrypt)</span>
 .Lcbcdecloop:
 	ld1		{v1.16b}, [x1], #16		/* get next ct block */
 	mov		v0.16b, v1.16b			/* ...and copy to v0 */
<span class="p_del">-	decrypt_block	v0, w3, x2, x5, w6</span>
<span class="p_add">+	decrypt_block	v0, w3, x2, x6, w7</span>
 	eor		v0.16b, v0.16b, v7.16b		/* xor with iv =&gt; pt */
 	mov		v7.16b, v1.16b			/* ct is next iv */
 	st1		{v0.16b}, [x0], #16
<span class="p_chunk">@@ -256,6 +257,7 @@</span> <span class="p_context"> AES_ENTRY(aes_cbc_decrypt)</span>
 	bne		.Lcbcdecloop
 .Lcbcdecout:
 	FRAME_POP
<span class="p_add">+	st1		{v7.16b}, [x5]			/* return iv */</span>
 	ret
 AES_ENDPROC(aes_cbc_decrypt)
 
<span class="p_chunk">@@ -267,24 +269,15 @@</span> <span class="p_context"> AES_ENDPROC(aes_cbc_decrypt)</span>
 
 AES_ENTRY(aes_ctr_encrypt)
 	FRAME_PUSH
<span class="p_del">-	cbnz		w6, .Lctrfirst		/* 1st time around? */</span>
<span class="p_del">-	umov		x5, v4.d[1]		/* keep swabbed ctr in reg */</span>
<span class="p_del">-	rev		x5, x5</span>
<span class="p_del">-#if INTERLEAVE &gt;= 2</span>
<span class="p_del">-	cmn		w5, w4			/* 32 bit overflow? */</span>
<span class="p_del">-	bcs		.Lctrinc</span>
<span class="p_del">-	add		x5, x5, #1		/* increment BE ctr */</span>
<span class="p_del">-	b		.LctrincNx</span>
<span class="p_del">-#else</span>
<span class="p_del">-	b		.Lctrinc</span>
<span class="p_del">-#endif</span>
<span class="p_del">-.Lctrfirst:</span>
<span class="p_add">+	cbz		w6, .Lctrnotfirst	/* 1st time around? */</span>
 	enc_prepare	w3, x2, x6
 	ld1		{v4.16b}, [x5]
<span class="p_del">-	umov		x5, v4.d[1]		/* keep swabbed ctr in reg */</span>
<span class="p_del">-	rev		x5, x5</span>
<span class="p_add">+</span>
<span class="p_add">+.Lctrnotfirst:</span>
<span class="p_add">+	umov		x8, v4.d[1]		/* keep swabbed ctr in reg */</span>
<span class="p_add">+	rev		x8, x8</span>
 #if INTERLEAVE &gt;= 2
<span class="p_del">-	cmn		w5, w4			/* 32 bit overflow? */</span>
<span class="p_add">+	cmn		w8, w4			/* 32 bit overflow? */</span>
 	bcs		.Lctrloop
 .LctrloopNx:
 	subs		w4, w4, #INTERLEAVE
<span class="p_chunk">@@ -292,11 +285,11 @@</span> <span class="p_context"> AES_ENTRY(aes_ctr_encrypt)</span>
 #if INTERLEAVE == 2
 	mov		v0.8b, v4.8b
 	mov		v1.8b, v4.8b
<span class="p_del">-	rev		x7, x5</span>
<span class="p_del">-	add		x5, x5, #1</span>
<span class="p_add">+	rev		x7, x8</span>
<span class="p_add">+	add		x8, x8, #1</span>
 	ins		v0.d[1], x7
<span class="p_del">-	rev		x7, x5</span>
<span class="p_del">-	add		x5, x5, #1</span>
<span class="p_add">+	rev		x7, x8</span>
<span class="p_add">+	add		x8, x8, #1</span>
 	ins		v1.d[1], x7
 	ld1		{v2.16b-v3.16b}, [x1], #32	/* get 2 input blocks */
 	do_encrypt_block2x
<span class="p_chunk">@@ -305,7 +298,7 @@</span> <span class="p_context"> AES_ENTRY(aes_ctr_encrypt)</span>
 	st1		{v0.16b-v1.16b}, [x0], #32
 #else
 	ldr		q8, =0x30000000200000001	/* addends 1,2,3[,0] */
<span class="p_del">-	dup		v7.4s, w5</span>
<span class="p_add">+	dup		v7.4s, w8</span>
 	mov		v0.16b, v4.16b
 	add		v7.4s, v7.4s, v8.4s
 	mov		v1.16b, v4.16b
<span class="p_chunk">@@ -323,18 +316,12 @@</span> <span class="p_context"> AES_ENTRY(aes_ctr_encrypt)</span>
 	eor		v2.16b, v7.16b, v2.16b
 	eor		v3.16b, v5.16b, v3.16b
 	st1		{v0.16b-v3.16b}, [x0], #64
<span class="p_del">-	add		x5, x5, #INTERLEAVE</span>
<span class="p_add">+	add		x8, x8, #INTERLEAVE</span>
 #endif
<span class="p_del">-	cbz		w4, .LctroutNx</span>
<span class="p_del">-.LctrincNx:</span>
<span class="p_del">-	rev		x7, x5</span>
<span class="p_add">+	rev		x7, x8</span>
 	ins		v4.d[1], x7
<span class="p_add">+	cbz		w4, .Lctrout</span>
 	b		.LctrloopNx
<span class="p_del">-.LctroutNx:</span>
<span class="p_del">-	sub		x5, x5, #1</span>
<span class="p_del">-	rev		x7, x5</span>
<span class="p_del">-	ins		v4.d[1], x7</span>
<span class="p_del">-	b		.Lctrout</span>
 .Lctr1x:
 	adds		w4, w4, #INTERLEAVE
 	beq		.Lctrout
<span class="p_chunk">@@ -342,30 +329,39 @@</span> <span class="p_context"> AES_ENTRY(aes_ctr_encrypt)</span>
 .Lctrloop:
 	mov		v0.16b, v4.16b
 	encrypt_block	v0, w3, x2, x6, w7
<span class="p_add">+</span>
<span class="p_add">+	adds		x8, x8, #1		/* increment BE ctr */</span>
<span class="p_add">+	rev		x7, x8</span>
<span class="p_add">+	ins		v4.d[1], x7</span>
<span class="p_add">+	bcs		.Lctrcarry		/* overflow? */</span>
<span class="p_add">+</span>
<span class="p_add">+.Lctrcarrydone:</span>
 	subs		w4, w4, #1
 	bmi		.Lctrhalfblock		/* blocks &lt; 0 means 1/2 block */
 	ld1		{v3.16b}, [x1], #16
 	eor		v3.16b, v0.16b, v3.16b
 	st1		{v3.16b}, [x0], #16
<span class="p_del">-	beq		.Lctrout</span>
<span class="p_del">-.Lctrinc:</span>
<span class="p_del">-	adds		x5, x5, #1		/* increment BE ctr */</span>
<span class="p_del">-	rev		x7, x5</span>
<span class="p_del">-	ins		v4.d[1], x7</span>
<span class="p_del">-	bcc		.Lctrloop		/* no overflow? */</span>
<span class="p_del">-	umov		x7, v4.d[0]		/* load upper word of ctr  */</span>
<span class="p_del">-	rev		x7, x7			/* ... to handle the carry */</span>
<span class="p_del">-	add		x7, x7, #1</span>
<span class="p_del">-	rev		x7, x7</span>
<span class="p_del">-	ins		v4.d[0], x7</span>
<span class="p_del">-	b		.Lctrloop</span>
<span class="p_add">+	bne		.Lctrloop</span>
<span class="p_add">+</span>
<span class="p_add">+.Lctrout:</span>
<span class="p_add">+	st1		{v4.16b}, [x5]		/* return next CTR value */</span>
<span class="p_add">+	FRAME_POP</span>
<span class="p_add">+	ret</span>
<span class="p_add">+</span>
 .Lctrhalfblock:
 	ld1		{v3.8b}, [x1]
 	eor		v3.8b, v0.8b, v3.8b
 	st1		{v3.8b}, [x0]
<span class="p_del">-.Lctrout:</span>
 	FRAME_POP
 	ret
<span class="p_add">+</span>
<span class="p_add">+.Lctrcarry:</span>
<span class="p_add">+	umov		x7, v4.d[0]		/* load upper word of ctr  */</span>
<span class="p_add">+	rev		x7, x7			/* ... to handle the carry */</span>
<span class="p_add">+	add		x7, x7, #1</span>
<span class="p_add">+	rev		x7, x7</span>
<span class="p_add">+	ins		v4.d[0], x7</span>
<span class="p_add">+	b		.Lctrcarrydone</span>
 AES_ENDPROC(aes_ctr_encrypt)
 	.ltorg
 
<span class="p_chunk">@@ -386,7 +382,8 @@</span> <span class="p_context"> AES_ENDPROC(aes_ctr_encrypt)</span>
 	.endm
 
 .Lxts_mul_x:
<span class="p_del">-	.word		1, 0, 0x87, 0</span>
<span class="p_add">+CPU_LE(	.quad		1, 0x87		)</span>
<span class="p_add">+CPU_BE(	.quad		0x87, 1		)</span>
 
 AES_ENTRY(aes_xts_encrypt)
 	FRAME_PUSH
<span class="p_header">diff --git a/arch/arm64/crypto/aes-neon.S b/arch/arm64/crypto/aes-neon.S</span>
<span class="p_header">index b93170e1cc93..85f07ead7c5c 100644</span>
<span class="p_header">--- a/arch/arm64/crypto/aes-neon.S</span>
<span class="p_header">+++ b/arch/arm64/crypto/aes-neon.S</span>
<span class="p_chunk">@@ -9,6 +9,7 @@</span> <span class="p_context"></span>
  */
 
 #include &lt;linux/linkage.h&gt;
<span class="p_add">+#include &lt;asm/assembler.h&gt;</span>
 
 #define AES_ENTRY(func)		ENTRY(neon_ ## func)
 #define AES_ENDPROC(func)	ENDPROC(neon_ ## func)
<span class="p_chunk">@@ -83,13 +84,13 @@</span> <span class="p_context"></span>
 	.endm
 
 	.macro		do_block, enc, in, rounds, rk, rkp, i
<span class="p_del">-	ld1		{v15.16b}, [\rk]</span>
<span class="p_add">+	ld1		{v15.4s}, [\rk]</span>
 	add		\rkp, \rk, #16
 	mov		\i, \rounds
 1111:	eor		\in\().16b, \in\().16b, v15.16b		/* ^round key */
 	tbl		\in\().16b, {\in\().16b}, v13.16b	/* ShiftRows */
 	sub_bytes	\in
<span class="p_del">-	ld1		{v15.16b}, [\rkp], #16</span>
<span class="p_add">+	ld1		{v15.4s}, [\rkp], #16</span>
 	subs		\i, \i, #1
 	beq		2222f
 	.if		\enc == 1
<span class="p_chunk">@@ -229,7 +230,7 @@</span> <span class="p_context"></span>
 	.endm
 
 	.macro		do_block_2x, enc, in0, in1 rounds, rk, rkp, i
<span class="p_del">-	ld1		{v15.16b}, [\rk]</span>
<span class="p_add">+	ld1		{v15.4s}, [\rk]</span>
 	add		\rkp, \rk, #16
 	mov		\i, \rounds
 1111:	eor		\in0\().16b, \in0\().16b, v15.16b	/* ^round key */
<span class="p_chunk">@@ -237,7 +238,7 @@</span> <span class="p_context"></span>
 	sub_bytes_2x	\in0, \in1
 	tbl		\in0\().16b, {\in0\().16b}, v13.16b	/* ShiftRows */
 	tbl		\in1\().16b, {\in1\().16b}, v13.16b	/* ShiftRows */
<span class="p_del">-	ld1		{v15.16b}, [\rkp], #16</span>
<span class="p_add">+	ld1		{v15.4s}, [\rkp], #16</span>
 	subs		\i, \i, #1
 	beq		2222f
 	.if		\enc == 1
<span class="p_chunk">@@ -254,7 +255,7 @@</span> <span class="p_context"></span>
 	.endm
 
 	.macro		do_block_4x, enc, in0, in1, in2, in3, rounds, rk, rkp, i
<span class="p_del">-	ld1		{v15.16b}, [\rk]</span>
<span class="p_add">+	ld1		{v15.4s}, [\rk]</span>
 	add		\rkp, \rk, #16
 	mov		\i, \rounds
 1111:	eor		\in0\().16b, \in0\().16b, v15.16b	/* ^round key */
<span class="p_chunk">@@ -266,7 +267,7 @@</span> <span class="p_context"></span>
 	tbl		\in1\().16b, {\in1\().16b}, v13.16b	/* ShiftRows */
 	tbl		\in2\().16b, {\in2\().16b}, v13.16b	/* ShiftRows */
 	tbl		\in3\().16b, {\in3\().16b}, v13.16b	/* ShiftRows */
<span class="p_del">-	ld1		{v15.16b}, [\rkp], #16</span>
<span class="p_add">+	ld1		{v15.4s}, [\rkp], #16</span>
 	subs		\i, \i, #1
 	beq		2222f
 	.if		\enc == 1
<span class="p_chunk">@@ -306,12 +307,16 @@</span> <span class="p_context"></span>
 	.text
 	.align		4
 .LForward_ShiftRows:
<span class="p_del">-	.byte		0x0, 0x5, 0xa, 0xf, 0x4, 0x9, 0xe, 0x3</span>
<span class="p_del">-	.byte		0x8, 0xd, 0x2, 0x7, 0xc, 0x1, 0x6, 0xb</span>
<span class="p_add">+CPU_LE(	.byte		0x0, 0x5, 0xa, 0xf, 0x4, 0x9, 0xe, 0x3	)</span>
<span class="p_add">+CPU_LE(	.byte		0x8, 0xd, 0x2, 0x7, 0xc, 0x1, 0x6, 0xb	)</span>
<span class="p_add">+CPU_BE(	.byte		0xb, 0x6, 0x1, 0xc, 0x7, 0x2, 0xd, 0x8	)</span>
<span class="p_add">+CPU_BE(	.byte		0x3, 0xe, 0x9, 0x4, 0xf, 0xa, 0x5, 0x0	)</span>
 
 .LReverse_ShiftRows:
<span class="p_del">-	.byte		0x0, 0xd, 0xa, 0x7, 0x4, 0x1, 0xe, 0xb</span>
<span class="p_del">-	.byte		0x8, 0x5, 0x2, 0xf, 0xc, 0x9, 0x6, 0x3</span>
<span class="p_add">+CPU_LE(	.byte		0x0, 0xd, 0xa, 0x7, 0x4, 0x1, 0xe, 0xb	)</span>
<span class="p_add">+CPU_LE(	.byte		0x8, 0x5, 0x2, 0xf, 0xc, 0x9, 0x6, 0x3	)</span>
<span class="p_add">+CPU_BE(	.byte		0x3, 0x6, 0x9, 0xc, 0xf, 0x2, 0x5, 0x8	)</span>
<span class="p_add">+CPU_BE(	.byte		0xb, 0xe, 0x1, 0x4, 0x7, 0xa, 0xd, 0x0	)</span>
 
 .LForward_Sbox:
 	.byte		0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5
<span class="p_header">diff --git a/arch/arm64/crypto/ghash-ce-core.S b/arch/arm64/crypto/ghash-ce-core.S</span>
<span class="p_header">index dc457015884e..f0bb9f0b524f 100644</span>
<span class="p_header">--- a/arch/arm64/crypto/ghash-ce-core.S</span>
<span class="p_header">+++ b/arch/arm64/crypto/ghash-ce-core.S</span>
<span class="p_chunk">@@ -29,8 +29,8 @@</span> <span class="p_context"></span>
 	 *			   struct ghash_key const *k, const char *head)
 	 */
 ENTRY(pmull_ghash_update)
<span class="p_del">-	ld1		{SHASH.16b}, [x3]</span>
<span class="p_del">-	ld1		{XL.16b}, [x1]</span>
<span class="p_add">+	ld1		{SHASH.2d}, [x3]</span>
<span class="p_add">+	ld1		{XL.2d}, [x1]</span>
 	movi		MASK.16b, #0xe1
 	ext		SHASH2.16b, SHASH.16b, SHASH.16b, #8
 	shl		MASK.2d, MASK.2d, #57
<span class="p_chunk">@@ -74,6 +74,6 @@</span> <span class="p_context"> CPU_LE(	rev64		T1.16b, T1.16b	)</span>
 
 	cbnz		w0, 0b
 
<span class="p_del">-	st1		{XL.16b}, [x1]</span>
<span class="p_add">+	st1		{XL.2d}, [x1]</span>
 	ret
 ENDPROC(pmull_ghash_update)
<span class="p_header">diff --git a/arch/arm64/crypto/sha1-ce-core.S b/arch/arm64/crypto/sha1-ce-core.S</span>
<span class="p_header">index 09d57d98609c..1fb70893ce55 100644</span>
<span class="p_header">--- a/arch/arm64/crypto/sha1-ce-core.S</span>
<span class="p_header">+++ b/arch/arm64/crypto/sha1-ce-core.S</span>
<span class="p_chunk">@@ -78,7 +78,7 @@</span> <span class="p_context"> ENTRY(sha1_ce_transform)</span>
 	ld1r		{k3.4s}, [x6]
 
 	/* load state */
<span class="p_del">-	ldr		dga, [x2]</span>
<span class="p_add">+	ld1		{dgav.4s}, [x2]</span>
 	ldr		dgb, [x2, #16]
 
 	/* load partial state (if supplied) */
<span class="p_chunk">@@ -147,7 +147,7 @@</span> <span class="p_context"> CPU_LE(	rev32		v11.16b, v11.16b	)</span>
 	b		2b
 
 	/* store new state */
<span class="p_del">-3:	str		dga, [x2]</span>
<span class="p_add">+3:	st1		{dgav.4s}, [x2]</span>
 	str		dgb, [x2, #16]
 	ret
 ENDPROC(sha1_ce_transform)
<span class="p_header">diff --git a/arch/arm64/crypto/sha2-ce-core.S b/arch/arm64/crypto/sha2-ce-core.S</span>
<span class="p_header">index 7f29fc031ea8..0acd61ef8cb2 100644</span>
<span class="p_header">--- a/arch/arm64/crypto/sha2-ce-core.S</span>
<span class="p_header">+++ b/arch/arm64/crypto/sha2-ce-core.S</span>
<span class="p_chunk">@@ -85,7 +85,7 @@</span> <span class="p_context"> ENTRY(sha2_ce_transform)</span>
 	ld1		{v12.4s-v15.4s}, [x8]
 
 	/* load state */
<span class="p_del">-	ldp		dga, dgb, [x2]</span>
<span class="p_add">+	ld1		{dgav.4s, dgbv.4s}, [x2]</span>
 
 	/* load partial input (if supplied) */
 	cbz		x3, 0f
<span class="p_chunk">@@ -151,6 +151,6 @@</span> <span class="p_context"> CPU_LE(	rev32		v19.16b, v19.16b	)</span>
 	b		2b
 
 	/* store new state */
<span class="p_del">-3:	stp		dga, dgb, [x2]</span>
<span class="p_add">+3:	st1		{dgav.4s, dgbv.4s}, [x2]</span>
 	ret
 ENDPROC(sha2_ce_transform)
<span class="p_header">diff --git a/arch/arm64/include/uapi/asm/ptrace.h b/arch/arm64/include/uapi/asm/ptrace.h</span>
<span class="p_header">index 6913643bbe54..c136fd53c847 100644</span>
<span class="p_header">--- a/arch/arm64/include/uapi/asm/ptrace.h</span>
<span class="p_header">+++ b/arch/arm64/include/uapi/asm/ptrace.h</span>
<span class="p_chunk">@@ -75,6 +75,7 @@</span> <span class="p_context"> struct user_fpsimd_state {</span>
 	__uint128_t	vregs[32];
 	__u32		fpsr;
 	__u32		fpcr;
<span class="p_add">+	__u32		__reserved[2];</span>
 };
 
 struct user_hwdebug_state {
<span class="p_header">diff --git a/arch/arm64/kernel/entry.S b/arch/arm64/kernel/entry.S</span>
<span class="p_header">index 8993a69099c7..67738737be9d 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/entry.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/entry.S</span>
<span class="p_chunk">@@ -491,7 +491,7 @@</span> <span class="p_context"> el0_inv:</span>
 	mov	x0, sp
 	mov	x1, #BAD_SYNC
 	mrs	x2, esr_el1
<span class="p_del">-	b	bad_mode</span>
<span class="p_add">+	b	bad_el0_sync</span>
 ENDPROC(el0_sync)
 
 	.align	6
<span class="p_header">diff --git a/arch/arm64/kernel/ptrace.c b/arch/arm64/kernel/ptrace.c</span>
<span class="p_header">index d2b9a3f7457d..07c5f63a3362 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/ptrace.c</span>
<span class="p_chunk">@@ -446,6 +446,8 @@</span> <span class="p_context"> static int hw_break_set(struct task_struct *target,</span>
 	/* (address, ctrl) registers */
 	limit = regset-&gt;n * regset-&gt;size;
 	while (count &amp;&amp; offset &lt; limit) {
<span class="p_add">+		if (count &lt; PTRACE_HBP_ADDR_SZ)</span>
<span class="p_add">+			return -EINVAL;</span>
 		ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;addr,
 					 offset, offset + PTRACE_HBP_ADDR_SZ);
 		if (ret)
<span class="p_chunk">@@ -455,6 +457,8 @@</span> <span class="p_context"> static int hw_break_set(struct task_struct *target,</span>
 			return ret;
 		offset += PTRACE_HBP_ADDR_SZ;
 
<span class="p_add">+		if (!count)</span>
<span class="p_add">+			break;</span>
 		ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;ctrl,
 					 offset, offset + PTRACE_HBP_CTRL_SZ);
 		if (ret)
<span class="p_chunk">@@ -491,7 +495,7 @@</span> <span class="p_context"> static int gpr_set(struct task_struct *target, const struct user_regset *regset,</span>
 		   const void *kbuf, const void __user *ubuf)
 {
 	int ret;
<span class="p_del">-	struct user_pt_regs newregs;</span>
<span class="p_add">+	struct user_pt_regs newregs = task_pt_regs(target)-&gt;user_regs;</span>
 
 	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;newregs, 0, -1);
 	if (ret)
<span class="p_chunk">@@ -521,7 +525,8 @@</span> <span class="p_context"> static int fpr_set(struct task_struct *target, const struct user_regset *regset,</span>
 		   const void *kbuf, const void __user *ubuf)
 {
 	int ret;
<span class="p_del">-	struct user_fpsimd_state newstate;</span>
<span class="p_add">+	struct user_fpsimd_state newstate =</span>
<span class="p_add">+		target-&gt;thread.fpsimd_state.user_fpsimd;</span>
 
 	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;newstate, 0, -1);
 	if (ret)
<span class="p_chunk">@@ -545,7 +550,7 @@</span> <span class="p_context"> static int tls_set(struct task_struct *target, const struct user_regset *regset,</span>
 		   const void *kbuf, const void __user *ubuf)
 {
 	int ret;
<span class="p_del">-	unsigned long tls;</span>
<span class="p_add">+	unsigned long tls = target-&gt;thread.tp_value;</span>
 
 	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;tls, 0, -1);
 	if (ret)
<span class="p_header">diff --git a/arch/arm64/kernel/traps.c b/arch/arm64/kernel/traps.c</span>
<span class="p_header">index c43cfa9b8304..c1c2ad6a1c94 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/traps.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/traps.c</span>
<span class="p_chunk">@@ -309,16 +309,33 @@</span> <span class="p_context"> asmlinkage long do_ni_syscall(struct pt_regs *regs)</span>
 }
 
 /*
<span class="p_del">- * bad_mode handles the impossible case in the exception vector.</span>
<span class="p_add">+ * bad_mode handles the impossible case in the exception vector. This is always</span>
<span class="p_add">+ * fatal.</span>
  */
 asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)
 {
<span class="p_del">-	siginfo_t info;</span>
<span class="p_del">-	void __user *pc = (void __user *)instruction_pointer(regs);</span>
 	console_verbose();
 
 	pr_crit(&quot;Bad mode in %s handler detected, code 0x%08x\n&quot;,
 		handler[reason], esr);
<span class="p_add">+</span>
<span class="p_add">+	die(&quot;Oops - bad mode&quot;, regs, 0);</span>
<span class="p_add">+	local_irq_disable();</span>
<span class="p_add">+	panic(&quot;bad mode&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * bad_el0_sync handles unexpected, but potentially recoverable synchronous</span>
<span class="p_add">+ * exceptions taken from EL0. Unlike bad_mode, this returns.</span>
<span class="p_add">+ */</span>
<span class="p_add">+asmlinkage void bad_el0_sync(struct pt_regs *regs, int reason, unsigned int esr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	siginfo_t info;</span>
<span class="p_add">+	void __user *pc = (void __user *)instruction_pointer(regs);</span>
<span class="p_add">+	console_verbose();</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_crit(&quot;Bad EL0 synchronous exception detected on CPU%d, code 0x%08x\n&quot;,</span>
<span class="p_add">+		smp_processor_id(), esr);</span>
 	__show_regs(regs);
 
 	info.si_signo = SIGILL;
<span class="p_chunk">@@ -326,7 +343,10 @@</span> <span class="p_context"> asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)</span>
 	info.si_code  = ILL_ILLOPC;
 	info.si_addr  = pc;
 
<span class="p_del">-	arm64_notify_die(&quot;Oops - bad mode&quot;, regs, &amp;info, 0);</span>
<span class="p_add">+	current-&gt;thread.fault_address = 0;</span>
<span class="p_add">+	current-&gt;thread.fault_code = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	force_sig_info(info.si_signo, &amp;info, current);</span>
 }
 
 void __pte_error(const char *file, int line, unsigned long val)
<span class="p_header">diff --git a/arch/cris/boot/rescue/Makefile b/arch/cris/boot/rescue/Makefile</span>
<span class="p_header">index 52bd0bd1dd22..d98edbb30a18 100644</span>
<span class="p_header">--- a/arch/cris/boot/rescue/Makefile</span>
<span class="p_header">+++ b/arch/cris/boot/rescue/Makefile</span>
<span class="p_chunk">@@ -10,6 +10,9 @@</span> <span class="p_context"></span>
 
 asflags-y += $(LINUXINCLUDE)
 ccflags-y += -O2 $(LINUXINCLUDE)
<span class="p_add">+</span>
<span class="p_add">+ifdef CONFIG_ETRAX_AXISFLASHMAP</span>
<span class="p_add">+</span>
 arch-$(CONFIG_ETRAX_ARCH_V10) = v10
 arch-$(CONFIG_ETRAX_ARCH_V32) = v32
 
<span class="p_chunk">@@ -28,6 +31,11 @@</span> <span class="p_context"> $(obj)/rescue.bin: $(obj)/rescue.o FORCE</span>
 	$(call if_changed,objcopy)
 	cp -p $(obj)/rescue.bin $(objtree)
 
<span class="p_add">+else</span>
<span class="p_add">+$(obj)/rescue.bin:</span>
<span class="p_add">+</span>
<span class="p_add">+endif</span>
<span class="p_add">+</span>
 $(obj)/testrescue.bin: $(obj)/testrescue.o
 	$(OBJCOPY) $(OBJCOPYFLAGS) $(obj)/testrescue.o tr.bin
 # Pad it to 784 bytes
<span class="p_header">diff --git a/arch/mips/kvm/kvm_mips.c b/arch/mips/kvm/kvm_mips.c</span>
<span class="p_header">index 72aad2a9a6b4..263c6c1c9bbb 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_mips.c</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_mips.c</span>
<span class="p_chunk">@@ -343,8 +343,8 @@</span> <span class="p_context"> struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm, unsigned int id)</span>
 	       mips32_GuestExceptionEnd - mips32_GuestException);
 
 	/* Invalidate the icache for these ranges */
<span class="p_del">-	local_flush_icache_range((unsigned long)gebase,</span>
<span class="p_del">-				(unsigned long)gebase + ALIGN(size, PAGE_SIZE));</span>
<span class="p_add">+	flush_icache_range((unsigned long)gebase,</span>
<span class="p_add">+			   (unsigned long)gebase + ALIGN(size, PAGE_SIZE));</span>
 
 	/* Allocate comm page for guest kernel, a TLB will be reserved for mapping GVA @ 0xFFFF8000 to this page */
 	vcpu-&gt;arch.kseg0_commpage = kzalloc(PAGE_SIZE &lt;&lt; 1, GFP_KERNEL);
<span class="p_header">diff --git a/arch/parisc/include/asm/bitops.h b/arch/parisc/include/asm/bitops.h</span>
<span class="p_header">index 3f9406d9b9d6..da87943328a5 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/bitops.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/bitops.h</span>
<span class="p_chunk">@@ -6,7 +6,7 @@</span> <span class="p_context"></span>
 #endif
 
 #include &lt;linux/compiler.h&gt;
<span class="p_del">-#include &lt;asm/types.h&gt;		/* for BITS_PER_LONG/SHIFT_PER_LONG */</span>
<span class="p_add">+#include &lt;asm/types.h&gt;</span>
 #include &lt;asm/byteorder.h&gt;
 #include &lt;asm/barrier.h&gt;
 #include &lt;linux/atomic.h&gt;
<span class="p_chunk">@@ -17,6 +17,12 @@</span> <span class="p_context"></span>
  * to include/asm-i386/bitops.h or kerneldoc
  */
 
<span class="p_add">+#if __BITS_PER_LONG == 64</span>
<span class="p_add">+#define SHIFT_PER_LONG 6</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define SHIFT_PER_LONG 5</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #define CHOP_SHIFTCOUNT(x) (((unsigned long) (x)) &amp; (BITS_PER_LONG - 1))
 
 
<span class="p_header">diff --git a/arch/parisc/include/uapi/asm/bitsperlong.h b/arch/parisc/include/uapi/asm/bitsperlong.h</span>
<span class="p_header">index 75196b415d3f..540c94de4427 100644</span>
<span class="p_header">--- a/arch/parisc/include/uapi/asm/bitsperlong.h</span>
<span class="p_header">+++ b/arch/parisc/include/uapi/asm/bitsperlong.h</span>
<span class="p_chunk">@@ -9,10 +9,8 @@</span> <span class="p_context"></span>
  */
 #if (defined(__KERNEL__) &amp;&amp; defined(CONFIG_64BIT)) || defined (__LP64__)
 #define __BITS_PER_LONG 64
<span class="p_del">-#define SHIFT_PER_LONG 6</span>
 #else
 #define __BITS_PER_LONG 32
<span class="p_del">-#define SHIFT_PER_LONG 5</span>
 #endif
 
 #include &lt;asm-generic/bitsperlong.h&gt;
<span class="p_header">diff --git a/arch/parisc/include/uapi/asm/swab.h b/arch/parisc/include/uapi/asm/swab.h</span>
<span class="p_header">index e78403b129ef..928e1bbac98f 100644</span>
<span class="p_header">--- a/arch/parisc/include/uapi/asm/swab.h</span>
<span class="p_header">+++ b/arch/parisc/include/uapi/asm/swab.h</span>
<span class="p_chunk">@@ -1,6 +1,7 @@</span> <span class="p_context"></span>
 #ifndef _PARISC_SWAB_H
 #define _PARISC_SWAB_H
 
<span class="p_add">+#include &lt;asm/bitsperlong.h&gt;</span>
 #include &lt;linux/types.h&gt;
 #include &lt;linux/compiler.h&gt;
 
<span class="p_chunk">@@ -38,7 +39,7 @@</span> <span class="p_context"> static inline __attribute_const__ __u32 __arch_swab32(__u32 x)</span>
 }
 #define __arch_swab32 __arch_swab32
 
<span class="p_del">-#if BITS_PER_LONG &gt; 32</span>
<span class="p_add">+#if __BITS_PER_LONG &gt; 32</span>
 /*
 ** From &quot;PA-RISC 2.0 Architecture&quot;, HP Professional Books.
 ** See Appendix I page 8 , &quot;Endian Byte Swapping&quot;.
<span class="p_chunk">@@ -61,6 +62,6 @@</span> <span class="p_context"> static inline __attribute_const__ __u64 __arch_swab64(__u64 x)</span>
 	return x;
 }
 #define __arch_swab64 __arch_swab64
<span class="p_del">-#endif /* BITS_PER_LONG &gt; 32 */</span>
<span class="p_add">+#endif /* __BITS_PER_LONG &gt; 32 */</span>
 
 #endif /* _PARISC_SWAB_H */
<span class="p_header">diff --git a/arch/powerpc/boot/ps3-head.S b/arch/powerpc/boot/ps3-head.S</span>
<span class="p_header">index b6fcbaf5027b..3dc44b05fb97 100644</span>
<span class="p_header">--- a/arch/powerpc/boot/ps3-head.S</span>
<span class="p_header">+++ b/arch/powerpc/boot/ps3-head.S</span>
<span class="p_chunk">@@ -57,11 +57,6 @@</span> <span class="p_context"> __system_reset_overlay:</span>
 	bctr
 
 1:
<span class="p_del">-	/* Save the value at addr zero for a null pointer write check later. */</span>
<span class="p_del">-</span>
<span class="p_del">-	li	r4, 0</span>
<span class="p_del">-	lwz	r3, 0(r4)</span>
<span class="p_del">-</span>
 	/* Primary delays then goes to _zimage_start in wrapper. */
 
 	or	31, 31, 31 /* db16cyc */
<span class="p_header">diff --git a/arch/powerpc/boot/ps3.c b/arch/powerpc/boot/ps3.c</span>
<span class="p_header">index 4ec2d86d3c50..a05558a7e51a 100644</span>
<span class="p_header">--- a/arch/powerpc/boot/ps3.c</span>
<span class="p_header">+++ b/arch/powerpc/boot/ps3.c</span>
<span class="p_chunk">@@ -119,13 +119,12 @@</span> <span class="p_context"> void ps3_copy_vectors(void)</span>
 	flush_cache((void *)0x100, 512);
 }
 
<span class="p_del">-void platform_init(unsigned long null_check)</span>
<span class="p_add">+void platform_init(void)</span>
 {
 	const u32 heapsize = 0x1000000 - (u32)_end; /* 16MiB */
 	void *chosen;
 	unsigned long ft_addr;
 	u64 rm_size;
<span class="p_del">-	unsigned long val;</span>
 
 	console_ops.write = ps3_console_write;
 	platform_ops.exit = ps3_exit;
<span class="p_chunk">@@ -153,11 +152,6 @@</span> <span class="p_context"> void platform_init(unsigned long null_check)</span>
 
 	printf(&quot; flat tree at 0x%lx\n\r&quot;, ft_addr);
 
<span class="p_del">-	val = *(unsigned long *)0;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (val != null_check)</span>
<span class="p_del">-		printf(&quot;null check failed: %lx != %lx\n\r&quot;, val, null_check);</span>
<span class="p_del">-</span>
 	((kernel_entry_t)0)(ft_addr, 0, NULL);
 
 	ps3_exit();
<span class="p_header">diff --git a/arch/powerpc/boot/wrapper b/arch/powerpc/boot/wrapper</span>
<span class="p_header">index ae0f88ec4a32..c70210d9fb89 100755</span>
<span class="p_header">--- a/arch/powerpc/boot/wrapper</span>
<span class="p_header">+++ b/arch/powerpc/boot/wrapper</span>
<span class="p_chunk">@@ -144,6 +144,28 @@</span> <span class="p_context"> case &quot;$elfformat&quot; in</span>
     elf32-powerpc)	format=elf32ppc	;;
 esac
 
<span class="p_add">+ld_version()</span>
<span class="p_add">+{</span>
<span class="p_add">+    # Poached from scripts/ld-version.sh, but we don&#39;t want to call that because</span>
<span class="p_add">+    # this script (wrapper) is distributed separately from the kernel source.</span>
<span class="p_add">+    # Extract linker version number from stdin and turn into single number.</span>
<span class="p_add">+    awk &#39;{</span>
<span class="p_add">+	gsub(&quot;.*\\)&quot;, &quot;&quot;);</span>
<span class="p_add">+	gsub(&quot;.*version &quot;, &quot;&quot;);</span>
<span class="p_add">+	gsub(&quot;-.*&quot;, &quot;&quot;);</span>
<span class="p_add">+	split($1,a, &quot;.&quot;);</span>
<span class="p_add">+	print a[1]*100000000 + a[2]*1000000 + a[3]*10000;</span>
<span class="p_add">+	exit</span>
<span class="p_add">+    }&#39;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+# Do not include PT_INTERP segment when linking pie. Non-pie linking</span>
<span class="p_add">+# just ignores this option.</span>
<span class="p_add">+LD_VERSION=$(${CROSS}ld --version | ld_version)</span>
<span class="p_add">+LD_NO_DL_MIN_VERSION=$(echo 2.26 | ld_version)</span>
<span class="p_add">+if [ &quot;$LD_VERSION&quot; -ge &quot;$LD_NO_DL_MIN_VERSION&quot; ] ; then</span>
<span class="p_add">+	nodl=&quot;--no-dynamic-linker&quot;</span>
<span class="p_add">+fi</span>
 
 platformo=$object/&quot;$platform&quot;.o
 lds=$object/zImage.lds
<span class="p_chunk">@@ -395,7 +417,7 @@</span> <span class="p_context"> if [ &quot;$platform&quot; != &quot;miboot&quot; ]; then</span>
     if [ -n &quot;$link_address&quot; ] ; then
         text_start=&quot;-Ttext $link_address&quot;
     fi
<span class="p_del">-    ${CROSS}ld -m $format -T $lds $text_start $pie -o &quot;$ofile&quot; \</span>
<span class="p_add">+    ${CROSS}ld -m $format -T $lds $text_start $pie $nodl -o &quot;$ofile&quot; \</span>
 	$platformo $tmp $object/wrapper.a
     rm $tmp
 fi
<span class="p_header">diff --git a/arch/powerpc/include/asm/kvm_host.h b/arch/powerpc/include/asm/kvm_host.h</span>
<span class="p_header">index 2149dbcf8931..c2a82045d64e 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -532,6 +532,7 @@</span> <span class="p_context"> struct kvm_vcpu_arch {</span>
 	u64 tfiar;
 
 	u32 cr_tm;
<span class="p_add">+	u64 xer_tm;</span>
 	u64 lr_tm;
 	u64 ctr_tm;
 	u64 amr_tm;
<span class="p_header">diff --git a/arch/powerpc/include/asm/ppc-opcode.h b/arch/powerpc/include/asm/ppc-opcode.h</span>
<span class="p_header">index 3132bb9365f3..f47c3d9cb997 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/ppc-opcode.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/ppc-opcode.h</span>
<span class="p_chunk">@@ -149,7 +149,7 @@</span> <span class="p_context"></span>
 #define PPC_INST_MCRXR			0x7c000400
 #define PPC_INST_MCRXR_MASK		0xfc0007fe
 #define PPC_INST_MFSPR_PVR		0x7c1f42a6
<span class="p_del">-#define PPC_INST_MFSPR_PVR_MASK		0xfc1fffff</span>
<span class="p_add">+#define PPC_INST_MFSPR_PVR_MASK		0xfc1ffffe</span>
 #define PPC_INST_MSGSND			0x7c00019c
 #define PPC_INST_MSGSNDP		0x7c00011c
 #define PPC_INST_NOP			0x60000000
<span class="p_chunk">@@ -161,13 +161,13 @@</span> <span class="p_context"></span>
 #define PPC_INST_RFDI			0x4c00004e
 #define PPC_INST_RFMCI			0x4c00004c
 #define PPC_INST_MFSPR_DSCR		0x7c1102a6
<span class="p_del">-#define PPC_INST_MFSPR_DSCR_MASK	0xfc1fffff</span>
<span class="p_add">+#define PPC_INST_MFSPR_DSCR_MASK	0xfc1ffffe</span>
 #define PPC_INST_MTSPR_DSCR		0x7c1103a6
<span class="p_del">-#define PPC_INST_MTSPR_DSCR_MASK	0xfc1fffff</span>
<span class="p_add">+#define PPC_INST_MTSPR_DSCR_MASK	0xfc1ffffe</span>
 #define PPC_INST_MFSPR_DSCR_USER	0x7c0302a6
<span class="p_del">-#define PPC_INST_MFSPR_DSCR_USER_MASK	0xfc1fffff</span>
<span class="p_add">+#define PPC_INST_MFSPR_DSCR_USER_MASK	0xfc1ffffe</span>
 #define PPC_INST_MTSPR_DSCR_USER	0x7c0303a6
<span class="p_del">-#define PPC_INST_MTSPR_DSCR_USER_MASK	0xfc1fffff</span>
<span class="p_add">+#define PPC_INST_MTSPR_DSCR_USER_MASK	0xfc1ffffe</span>
 #define PPC_INST_SLBFEE			0x7c0007a7
 
 #define PPC_INST_STRING			0x7c00042a
<span class="p_header">diff --git a/arch/powerpc/include/uapi/asm/kvm.h b/arch/powerpc/include/uapi/asm/kvm.h</span>
<span class="p_header">index de7d426a9b0c..93783f7cf729 100644</span>
<span class="p_header">--- a/arch/powerpc/include/uapi/asm/kvm.h</span>
<span class="p_header">+++ b/arch/powerpc/include/uapi/asm/kvm.h</span>
<span class="p_chunk">@@ -580,6 +580,7 @@</span> <span class="p_context"> struct kvm_get_htab_header {</span>
 #define KVM_REG_PPC_TM_VSCR	(KVM_REG_PPC_TM | KVM_REG_SIZE_U32 | 0x67)
 #define KVM_REG_PPC_TM_DSCR	(KVM_REG_PPC_TM | KVM_REG_SIZE_U64 | 0x68)
 #define KVM_REG_PPC_TM_TAR	(KVM_REG_PPC_TM | KVM_REG_SIZE_U64 | 0x69)
<span class="p_add">+#define KVM_REG_PPC_TM_XER	(KVM_REG_PPC_TM | KVM_REG_SIZE_U64 | 0x6a)</span>
 
 /* PPC64 eXternal Interrupt Controller Specification */
 #define KVM_DEV_XICS_GRP_SOURCES	1	/* 64-bit source attributes */
<span class="p_header">diff --git a/arch/powerpc/kernel/asm-offsets.c b/arch/powerpc/kernel/asm-offsets.c</span>
<span class="p_header">index 88abea889876..213fcaf4168d 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/asm-offsets.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/asm-offsets.c</span>
<span class="p_chunk">@@ -572,6 +572,7 @@</span> <span class="p_context"> int main(void)</span>
 	DEFINE(VCPU_VRS_TM, offsetof(struct kvm_vcpu, arch.vr_tm.vr));
 	DEFINE(VCPU_VRSAVE_TM, offsetof(struct kvm_vcpu, arch.vrsave_tm));
 	DEFINE(VCPU_CR_TM, offsetof(struct kvm_vcpu, arch.cr_tm));
<span class="p_add">+	DEFINE(VCPU_XER_TM, offsetof(struct kvm_vcpu, arch.xer_tm));</span>
 	DEFINE(VCPU_LR_TM, offsetof(struct kvm_vcpu, arch.lr_tm));
 	DEFINE(VCPU_CTR_TM, offsetof(struct kvm_vcpu, arch.ctr_tm));
 	DEFINE(VCPU_AMR_TM, offsetof(struct kvm_vcpu, arch.amr_tm));
<span class="p_header">diff --git a/arch/powerpc/kernel/ibmebus.c b/arch/powerpc/kernel/ibmebus.c</span>
<span class="p_header">index 1114d13ac19f..99ed2cc4c92f 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/ibmebus.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/ibmebus.c</span>
<span class="p_chunk">@@ -180,6 +180,7 @@</span> <span class="p_context"> static int ibmebus_create_device(struct device_node *dn)</span>
 static int ibmebus_create_devices(const struct of_device_id *matches)
 {
 	struct device_node *root, *child;
<span class="p_add">+	struct device *dev;</span>
 	int ret = 0;
 
 	root = of_find_node_by_path(&quot;/&quot;);
<span class="p_chunk">@@ -188,9 +189,12 @@</span> <span class="p_context"> static int ibmebus_create_devices(const struct of_device_id *matches)</span>
 		if (!of_match_node(matches, child))
 			continue;
 
<span class="p_del">-		if (bus_find_device(&amp;ibmebus_bus_type, NULL, child,</span>
<span class="p_del">-				    ibmebus_match_node))</span>
<span class="p_add">+		dev = bus_find_device(&amp;ibmebus_bus_type, NULL, child,</span>
<span class="p_add">+				      ibmebus_match_node);</span>
<span class="p_add">+		if (dev) {</span>
<span class="p_add">+			put_device(dev);</span>
 			continue;
<span class="p_add">+		}</span>
 
 		ret = ibmebus_create_device(child);
 		if (ret) {
<span class="p_chunk">@@ -262,6 +266,7 @@</span> <span class="p_context"> static ssize_t ibmebus_store_probe(struct bus_type *bus,</span>
 				   const char *buf, size_t count)
 {
 	struct device_node *dn = NULL;
<span class="p_add">+	struct device *dev;</span>
 	char *path;
 	ssize_t rc = 0;
 
<span class="p_chunk">@@ -269,8 +274,10 @@</span> <span class="p_context"> static ssize_t ibmebus_store_probe(struct bus_type *bus,</span>
 	if (!path)
 		return -ENOMEM;
 
<span class="p_del">-	if (bus_find_device(&amp;ibmebus_bus_type, NULL, path,</span>
<span class="p_del">-			    ibmebus_match_path)) {</span>
<span class="p_add">+	dev = bus_find_device(&amp;ibmebus_bus_type, NULL, path,</span>
<span class="p_add">+			      ibmebus_match_path);</span>
<span class="p_add">+	if (dev) {</span>
<span class="p_add">+		put_device(dev);</span>
 		printk(KERN_WARNING &quot;%s: %s has already been probed\n&quot;,
 		       __func__, path);
 		rc = -EEXIST;
<span class="p_chunk">@@ -307,6 +314,7 @@</span> <span class="p_context"> static ssize_t ibmebus_store_remove(struct bus_type *bus,</span>
 	if ((dev = bus_find_device(&amp;ibmebus_bus_type, NULL, path,
 				   ibmebus_match_path))) {
 		of_device_unregister(to_platform_device(dev));
<span class="p_add">+		put_device(dev);</span>
 
 		kfree(path);
 		return count;
<span class="p_header">diff --git a/arch/powerpc/kernel/misc_32.S b/arch/powerpc/kernel/misc_32.S</span>
<span class="p_header">index 7c6bb4b17b49..2c70bbcb006f 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/misc_32.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/misc_32.S</span>
<span class="p_chunk">@@ -313,7 +313,7 @@</span> <span class="p_context"> _GLOBAL(flush_instruction_cache)</span>
 	lis	r3, KERNELBASE@h
 	iccci	0,r3
 #endif
<span class="p_del">-#elif CONFIG_FSL_BOOKE</span>
<span class="p_add">+#elif defined(CONFIG_FSL_BOOKE)</span>
 BEGIN_FTR_SECTION
 	mfspr   r3,SPRN_L1CSR0
 	ori     r3,r3,L1CSR0_CFI|L1CSR0_CLFC
<span class="p_header">diff --git a/arch/powerpc/kernel/prom_init.c b/arch/powerpc/kernel/prom_init.c</span>
<span class="p_header">index 69be680f7184..c49a85c5fc6b 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/prom_init.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/prom_init.c</span>
<span class="p_chunk">@@ -2635,6 +2635,9 @@</span> <span class="p_context"> static void __init prom_find_boot_cpu(void)</span>
 
 	cpu_pkg = call_prom(&quot;instance-to-package&quot;, 1, 1, prom_cpu);
 
<span class="p_add">+	if (!PHANDLE_VALID(cpu_pkg))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	prom_getprop(cpu_pkg, &quot;reg&quot;, &amp;rval, sizeof(rval));
 	prom.cpu = be32_to_cpu(rval);
 
<span class="p_header">diff --git a/arch/powerpc/kernel/ptrace.c b/arch/powerpc/kernel/ptrace.c</span>
<span class="p_header">index 665ff668d8ae..1b3f715db647 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/ptrace.c</span>
<span class="p_chunk">@@ -394,6 +394,10 @@</span> <span class="p_context"> static int fpr_set(struct task_struct *target, const struct user_regset *regset,</span>
 	flush_fp_to_thread(target);
 
 #ifdef CONFIG_VSX
<span class="p_add">+	for (i = 0; i &lt; 32 ; i++)</span>
<span class="p_add">+		buf[i] = target-&gt;thread.TS_FPR(i);</span>
<span class="p_add">+	buf[32] = target-&gt;thread.fp_state.fpscr;</span>
<span class="p_add">+</span>
 	/* copy to local buffer then write that out */
 	i = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, buf, 0, -1);
 	if (i)
<span class="p_chunk">@@ -537,6 +541,9 @@</span> <span class="p_context"> static int vsr_set(struct task_struct *target, const struct user_regset *regset,</span>
 
 	flush_vsx_to_thread(target);
 
<span class="p_add">+	for (i = 0; i &lt; 32 ; i++)</span>
<span class="p_add">+		buf[i] = target-&gt;thread.fp_state.fpr[i][TS_VSRLOWOFFSET];</span>
<span class="p_add">+</span>
 	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf,
 				 buf, 0, 32 * sizeof(double));
 	for (i = 0; i &lt; 32 ; i++)
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_header">index a416b6bb0d6a..d39faa230eb1 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_chunk">@@ -988,6 +988,9 @@</span> <span class="p_context"> static int kvmppc_get_one_reg_hv(struct kvm_vcpu *vcpu, u64 id,</span>
 	case KVM_REG_PPC_TM_CR:
 		*val = get_reg_val(id, vcpu-&gt;arch.cr_tm);
 		break;
<span class="p_add">+	case KVM_REG_PPC_TM_XER:</span>
<span class="p_add">+		*val = get_reg_val(id, vcpu-&gt;arch.xer_tm);</span>
<span class="p_add">+		break;</span>
 	case KVM_REG_PPC_TM_LR:
 		*val = get_reg_val(id, vcpu-&gt;arch.lr_tm);
 		break;
<span class="p_chunk">@@ -1201,6 +1204,9 @@</span> <span class="p_context"> static int kvmppc_set_one_reg_hv(struct kvm_vcpu *vcpu, u64 id,</span>
 	case KVM_REG_PPC_TM_CR:
 		vcpu-&gt;arch.cr_tm = set_reg_val(id, *val);
 		break;
<span class="p_add">+	case KVM_REG_PPC_TM_XER:</span>
<span class="p_add">+		vcpu-&gt;arch.xer_tm = set_reg_val(id, *val);</span>
<span class="p_add">+		break;</span>
 	case KVM_REG_PPC_TM_LR:
 		vcpu-&gt;arch.lr_tm = set_reg_val(id, *val);
 		break;
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv_rmhandlers.S b/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_header">index ab69a5f242d1..da1aa24d586f 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_chunk">@@ -2356,11 +2356,13 @@</span> <span class="p_context"> kvmppc_save_tm:</span>
 	mfctr	r7
 	mfspr	r8, SPRN_AMR
 	mfspr	r10, SPRN_TAR
<span class="p_add">+	mfxer	r11</span>
 	std	r5, VCPU_LR_TM(r9)
 	stw	r6, VCPU_CR_TM(r9)
 	std	r7, VCPU_CTR_TM(r9)
 	std	r8, VCPU_AMR_TM(r9)
 	std	r10, VCPU_TAR_TM(r9)
<span class="p_add">+	std	r11, VCPU_XER_TM(r9)</span>
 
 	/* Restore r12 as trap number. */
 	lwz	r12, VCPU_TRAP(r9)
<span class="p_chunk">@@ -2453,11 +2455,13 @@</span> <span class="p_context"> kvmppc_restore_tm:</span>
 	ld	r7, VCPU_CTR_TM(r4)
 	ld	r8, VCPU_AMR_TM(r4)
 	ld	r9, VCPU_TAR_TM(r4)
<span class="p_add">+	ld	r10, VCPU_XER_TM(r4)</span>
 	mtlr	r5
 	mtcr	r6
 	mtctr	r7
 	mtspr	SPRN_AMR, r8
 	mtspr	SPRN_TAR, r9
<span class="p_add">+	mtxer	r10</span>
 
 	/*
 	 * Load up PPR and DSCR values but don&#39;t put them in the actual SPRs
<span class="p_header">diff --git a/arch/sparc/kernel/leon_kernel.c b/arch/sparc/kernel/leon_kernel.c</span>
<span class="p_header">index 683c4af999de..6b46d2f1c741 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/leon_kernel.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/leon_kernel.c</span>
<span class="p_chunk">@@ -339,37 +339,37 @@</span> <span class="p_context"> void __init leon_init_timers(void)</span>
 
 	/* Find GPTIMER Timer Registers base address otherwise bail out. */
 	nnp = rootnp;
<span class="p_del">-	do {</span>
<span class="p_del">-		np = of_find_node_by_name(nnp, &quot;GAISLER_GPTIMER&quot;);</span>
<span class="p_del">-		if (!np) {</span>
<span class="p_del">-			np = of_find_node_by_name(nnp, &quot;01_011&quot;);</span>
<span class="p_del">-			if (!np)</span>
<span class="p_del">-				goto bad;</span>
<span class="p_del">-		}</span>
 
<span class="p_del">-		ampopts = 0;</span>
<span class="p_del">-		pp = of_find_property(np, &quot;ampopts&quot;, &amp;len);</span>
<span class="p_del">-		if (pp) {</span>
<span class="p_del">-			ampopts = *(int *)pp-&gt;value;</span>
<span class="p_del">-			if (ampopts == 0) {</span>
<span class="p_del">-				/* Skip this instance, resource already</span>
<span class="p_del">-				 * allocated by other OS */</span>
<span class="p_del">-				nnp = np;</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			}</span>
<span class="p_add">+retry:</span>
<span class="p_add">+	np = of_find_node_by_name(nnp, &quot;GAISLER_GPTIMER&quot;);</span>
<span class="p_add">+	if (!np) {</span>
<span class="p_add">+		np = of_find_node_by_name(nnp, &quot;01_011&quot;);</span>
<span class="p_add">+		if (!np)</span>
<span class="p_add">+			goto bad;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ampopts = 0;</span>
<span class="p_add">+	pp = of_find_property(np, &quot;ampopts&quot;, &amp;len);</span>
<span class="p_add">+	if (pp) {</span>
<span class="p_add">+		ampopts = *(int *)pp-&gt;value;</span>
<span class="p_add">+		if (ampopts == 0) {</span>
<span class="p_add">+			/* Skip this instance, resource already</span>
<span class="p_add">+			 * allocated by other OS */</span>
<span class="p_add">+			nnp = np;</span>
<span class="p_add">+			goto retry;</span>
 		}
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Select Timer-Instance on Timer Core. Default is zero */</span>
<span class="p_add">+	leon3_gptimer_idx = ampopts &amp; 0x7;</span>
 
<span class="p_del">-		/* Select Timer-Instance on Timer Core. Default is zero */</span>
<span class="p_del">-		leon3_gptimer_idx = ampopts &amp; 0x7;</span>
<span class="p_del">-</span>
<span class="p_del">-		pp = of_find_property(np, &quot;reg&quot;, &amp;len);</span>
<span class="p_del">-		if (pp)</span>
<span class="p_del">-			leon3_gptimer_regs = *(struct leon3_gptimer_regs_map **)</span>
<span class="p_del">-						pp-&gt;value;</span>
<span class="p_del">-		pp = of_find_property(np, &quot;interrupts&quot;, &amp;len);</span>
<span class="p_del">-		if (pp)</span>
<span class="p_del">-			leon3_gptimer_irq = *(unsigned int *)pp-&gt;value;</span>
<span class="p_del">-	} while (0);</span>
<span class="p_add">+	pp = of_find_property(np, &quot;reg&quot;, &amp;len);</span>
<span class="p_add">+	if (pp)</span>
<span class="p_add">+		leon3_gptimer_regs = *(struct leon3_gptimer_regs_map **)</span>
<span class="p_add">+					pp-&gt;value;</span>
<span class="p_add">+	pp = of_find_property(np, &quot;interrupts&quot;, &amp;len);</span>
<span class="p_add">+	if (pp)</span>
<span class="p_add">+		leon3_gptimer_irq = *(unsigned int *)pp-&gt;value;</span>
 
 	if (!(leon3_gptimer_regs &amp;&amp; leon3_irqctrl_regs &amp;&amp; leon3_gptimer_irq))
 		goto bad;
<span class="p_header">diff --git a/arch/tile/kernel/ptrace.c b/arch/tile/kernel/ptrace.c</span>
<span class="p_header">index de98c6ddf136..2343126c4ad2 100644</span>
<span class="p_header">--- a/arch/tile/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/tile/kernel/ptrace.c</span>
<span class="p_chunk">@@ -110,7 +110,7 @@</span> <span class="p_context"> static int tile_gpr_set(struct task_struct *target,</span>
 			  const void *kbuf, const void __user *ubuf)
 {
 	int ret;
<span class="p_del">-	struct pt_regs regs;</span>
<span class="p_add">+	struct pt_regs regs = *task_pt_regs(target);</span>
 
 	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;regs, 0,
 				 sizeof(regs));
<span class="p_header">diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c</span>
<span class="p_header">index 493f3fd9f139..847f56c734b4 100644</span>
<span class="p_header">--- a/arch/x86/boot/string.c</span>
<span class="p_header">+++ b/arch/x86/boot/string.c</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/types.h&gt;
 #include &quot;ctype.h&quot;
<span class="p_add">+#include &quot;string.h&quot;</span>
 
 int memcmp(const void *s1, const void *s2, size_t len)
 {
<span class="p_header">diff --git a/arch/x86/boot/string.h b/arch/x86/boot/string.h</span>
<span class="p_header">index 725e820602b1..113588ddb43f 100644</span>
<span class="p_header">--- a/arch/x86/boot/string.h</span>
<span class="p_header">+++ b/arch/x86/boot/string.h</span>
<span class="p_chunk">@@ -18,4 +18,13 @@</span> <span class="p_context"> int memcmp(const void *s1, const void *s2, size_t len);</span>
 #define memset(d,c,l) __builtin_memset(d,c,l)
 #define memcmp	__builtin_memcmp
 
<span class="p_add">+extern int strcmp(const char *str1, const char *str2);</span>
<span class="p_add">+extern int strncmp(const char *cs, const char *ct, size_t count);</span>
<span class="p_add">+extern size_t strlen(const char *s);</span>
<span class="p_add">+extern char *strstr(const char *s1, const char *s2);</span>
<span class="p_add">+extern size_t strnlen(const char *s, size_t maxlen);</span>
<span class="p_add">+extern unsigned int atou(const char *s);</span>
<span class="p_add">+extern unsigned long long simple_strtoull(const char *cp, char **endp,</span>
<span class="p_add">+					  unsigned int base);</span>
<span class="p_add">+</span>
 #endif /* BOOT_STRING_H */
<span class="p_header">diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">index 3b12b4d1a560..b0f4cfef81c4 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/common.c</span>
<span class="p_chunk">@@ -1105,7 +1105,7 @@</span> <span class="p_context"> static __init int setup_disablecpuid(char *arg)</span>
 {
 	int bit;
 
<span class="p_del">-	if (get_option(&amp;arg, &amp;bit) &amp;&amp; bit &lt; NCAPINTS*32)</span>
<span class="p_add">+	if (get_option(&amp;arg, &amp;bit) &amp;&amp; bit &gt;= 0 &amp;&amp; bit &lt; NCAPINTS * 32)</span>
 		setup_clear_cpu_cap(bit);
 	else
 		return 0;
<span class="p_header">diff --git a/arch/x86/kernel/entry_32.S b/arch/x86/kernel/entry_32.S</span>
<span class="p_header">index 0d0c9d4ab6d5..2c123171944a 100644</span>
<span class="p_header">--- a/arch/x86/kernel/entry_32.S</span>
<span class="p_header">+++ b/arch/x86/kernel/entry_32.S</span>
<span class="p_chunk">@@ -1086,8 +1086,8 @@</span> <span class="p_context"> ftrace_graph_call:</span>
 	jmp ftrace_stub
 #endif
 
<span class="p_del">-.globl ftrace_stub</span>
<span class="p_del">-ftrace_stub:</span>
<span class="p_add">+/* This is weak to keep gas from relaxing the jumps */</span>
<span class="p_add">+WEAK(ftrace_stub)</span>
 	ret
 END(ftrace_caller)
 
<span class="p_header">diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c</span>
<span class="p_header">index 1f4e8e4ea865..d03a88cb3129 100644</span>
<span class="p_header">--- a/arch/x86/kvm/lapic.c</span>
<span class="p_header">+++ b/arch/x86/kvm/lapic.c</span>
<span class="p_chunk">@@ -1941,3 +1941,9 @@</span> <span class="p_context"> void kvm_lapic_init(void)</span>
 	jump_label_rate_limit(&amp;apic_hw_disabled, HZ);
 	jump_label_rate_limit(&amp;apic_sw_disabled, HZ);
 }
<span class="p_add">+</span>
<span class="p_add">+void kvm_lapic_exit(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static_key_deferred_flush(&amp;apic_hw_disabled);</span>
<span class="p_add">+	static_key_deferred_flush(&amp;apic_sw_disabled);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/x86/kvm/lapic.h b/arch/x86/kvm/lapic.h</span>
<span class="p_header">index 72051730caf1..776e9919e910 100644</span>
<span class="p_header">--- a/arch/x86/kvm/lapic.h</span>
<span class="p_header">+++ b/arch/x86/kvm/lapic.h</span>
<span class="p_chunk">@@ -93,6 +93,7 @@</span> <span class="p_context"> static inline bool kvm_hv_vapic_assist_page_enabled(struct kvm_vcpu *vcpu)</span>
 
 int kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data);
 void kvm_lapic_init(void);
<span class="p_add">+void kvm_lapic_exit(void);</span>
 
 static inline u32 kvm_apic_get_reg(struct kvm_lapic *apic, int reg_off)
 {
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 7b16666d6ed4..dad945386800 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -5954,14 +5954,20 @@</span> <span class="p_context"> static int nested_vmx_check_vmptr(struct kvm_vcpu *vcpu, int exit_reason,</span>
 		}
 
 		page = nested_get_page(vcpu, vmptr);
<span class="p_del">-		if (page == NULL ||</span>
<span class="p_del">-		    *(u32 *)kmap(page) != VMCS12_REVISION) {</span>
<span class="p_add">+		if (page == NULL) {</span>
 			nested_vmx_failInvalid(vcpu);
<span class="p_add">+			skip_emulated_instruction(vcpu);</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (*(u32 *)kmap(page) != VMCS12_REVISION) {</span>
 			kunmap(page);
<span class="p_add">+			nested_release_page_clean(page);</span>
<span class="p_add">+			nested_vmx_failInvalid(vcpu);</span>
 			skip_emulated_instruction(vcpu);
 			return 1;
 		}
 		kunmap(page);
<span class="p_add">+		nested_release_page_clean(page);</span>
 		vmx-&gt;nested.vmxon_ptr = vmptr;
 		break;
 	case EXIT_REASON_VMCLEAR:
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index e0a27d684d29..7dcb958a8054 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -892,7 +892,7 @@</span> <span class="p_context"> static u32 msrs_to_save[] = {</span>
 	MSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,
 #endif
 	MSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,
<span class="p_del">-	MSR_IA32_FEATURE_CONTROL, MSR_IA32_BNDCFGS, MSR_TSC_AUX,</span>
<span class="p_add">+	MSR_IA32_FEATURE_CONTROL, MSR_IA32_BNDCFGS</span>
 };
 
 static unsigned num_msrs_to_save;
<span class="p_chunk">@@ -3994,17 +3994,16 @@</span> <span class="p_context"> static void kvm_init_msr_list(void)</span>
 
 		/*
 		 * Even MSRs that are valid in the host may not be exposed
<span class="p_del">-		 * to the guests in some cases.</span>
<span class="p_add">+		 * to the guests in some cases.  We could work around this</span>
<span class="p_add">+		 * in VMX with the generic MSR save/load machinery, but it</span>
<span class="p_add">+		 * is not really worthwhile since it will really only</span>
<span class="p_add">+		 * happen with nested virtualization.</span>
 		 */
 		switch (msrs_to_save[i]) {
 		case MSR_IA32_BNDCFGS:
 			if (!kvm_x86_ops-&gt;mpx_supported())
 				continue;
 			break;
<span class="p_del">-		case MSR_TSC_AUX:</span>
<span class="p_del">-			if (!kvm_x86_ops-&gt;rdtscp_supported())</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			break;</span>
 		default:
 			break;
 		}
<span class="p_chunk">@@ -5677,6 +5676,7 @@</span> <span class="p_context"> out:</span>
 
 void kvm_arch_exit(void)
 {
<span class="p_add">+	kvm_lapic_exit();</span>
 	perf_unregister_guest_info_callbacks(&amp;kvm_guest_cbs);
 
 	if (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))
<span class="p_header">diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c</span>
<span class="p_header">index 0f8002ca2a5c..45bf431a06af 100644</span>
<span class="p_header">--- a/arch/x86/pci/acpi.c</span>
<span class="p_header">+++ b/arch/x86/pci/acpi.c</span>
<span class="p_chunk">@@ -118,6 +118,16 @@</span> <span class="p_context"> static const struct dmi_system_id pci_crs_quirks[] __initconst = {</span>
 			DMI_MATCH(DMI_BIOS_VERSION, &quot;6JET85WW (1.43 )&quot;),
 		},
 	},
<span class="p_add">+	/* https://bugzilla.kernel.org/show_bug.cgi?id=42606 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = set_nouse_crs,</span>
<span class="p_add">+		.ident = &quot;Supermicro X8DTH&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Supermicro&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;X8DTH-i/6/iF/6F&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_BIOS_VERSION, &quot;2.0a&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 
 	/* https://bugzilla.kernel.org/show_bug.cgi?id=15362 */
 	{
<span class="p_header">diff --git a/crypto/algapi.c b/crypto/algapi.c</span>
<span class="p_header">index daf2f653b131..8ea7a5dc3839 100644</span>
<span class="p_header">--- a/crypto/algapi.c</span>
<span class="p_header">+++ b/crypto/algapi.c</span>
<span class="p_chunk">@@ -337,6 +337,7 @@</span> <span class="p_context"> int crypto_register_alg(struct crypto_alg *alg)</span>
 	struct crypto_larval *larval;
 	int err;
 
<span class="p_add">+	alg-&gt;cra_flags &amp;= ~CRYPTO_ALG_DEAD;</span>
 	err = crypto_check_alg(alg);
 	if (err)
 		return err;
<span class="p_header">diff --git a/drivers/ata/sata_mv.c b/drivers/ata/sata_mv.c</span>
<span class="p_header">index 391cfda1e83f..8c3c4ea760fb 100644</span>
<span class="p_header">--- a/drivers/ata/sata_mv.c</span>
<span class="p_header">+++ b/drivers/ata/sata_mv.c</span>
<span class="p_chunk">@@ -4109,6 +4109,9 @@</span> <span class="p_context"> static int mv_platform_probe(struct platform_device *pdev)</span>
 	host-&gt;iomap = NULL;
 	hpriv-&gt;base = devm_ioremap(&amp;pdev-&gt;dev, res-&gt;start,
 				   resource_size(res));
<span class="p_add">+	if (!hpriv-&gt;base)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	hpriv-&gt;base -= SATAHC0_REG_BASE;
 
 	hpriv-&gt;clk = clk_get(&amp;pdev-&gt;dev, NULL);
<span class="p_header">diff --git a/drivers/base/dma-mapping.c b/drivers/base/dma-mapping.c</span>
<span class="p_header">index 6cd08e145bfa..036a05b28eb5 100644</span>
<span class="p_header">--- a/drivers/base/dma-mapping.c</span>
<span class="p_header">+++ b/drivers/base/dma-mapping.c</span>
<span class="p_chunk">@@ -107,13 +107,13 @@</span> <span class="p_context"> void dmam_free_coherent(struct device *dev, size_t size, void *vaddr,</span>
 EXPORT_SYMBOL(dmam_free_coherent);
 
 /**
<span class="p_del">- * dmam_alloc_non_coherent - Managed dma_alloc_non_coherent()</span>
<span class="p_add">+ * dmam_alloc_non_coherent - Managed dma_alloc_noncoherent()</span>
  * @dev: Device to allocate non_coherent memory for
  * @size: Size of allocation
  * @dma_handle: Out argument for allocated DMA handle
  * @gfp: Allocation flags
  *
<span class="p_del">- * Managed dma_alloc_non_coherent().  Memory allocated using this</span>
<span class="p_add">+ * Managed dma_alloc_noncoherent().  Memory allocated using this</span>
  * function will be automatically released on driver detach.
  *
  * RETURNS:
<span class="p_header">diff --git a/drivers/base/regmap/regcache-lzo.c b/drivers/base/regmap/regcache-lzo.c</span>
<span class="p_header">index e210a6d1406a..6ac6b7c02ecf 100644</span>
<span class="p_header">--- a/drivers/base/regmap/regcache-lzo.c</span>
<span class="p_header">+++ b/drivers/base/regmap/regcache-lzo.c</span>
<span class="p_chunk">@@ -236,15 +236,13 @@</span> <span class="p_context"> static int regcache_lzo_read(struct regmap *map,</span>
 {
 	struct regcache_lzo_ctx *lzo_block, **lzo_blocks;
 	int ret, blkindex, blkpos;
<span class="p_del">-	size_t blksize, tmp_dst_len;</span>
<span class="p_add">+	size_t tmp_dst_len;</span>
 	void *tmp_dst;
 
 	/* index of the compressed lzo block */
 	blkindex = regcache_lzo_get_blkindex(map, reg);
 	/* register index within the decompressed block */
 	blkpos = regcache_lzo_get_blkpos(map, reg);
<span class="p_del">-	/* size of the compressed block */</span>
<span class="p_del">-	blksize = regcache_lzo_get_blksize(map);</span>
 	lzo_blocks = map-&gt;cache;
 	lzo_block = lzo_blocks[blkindex];
 
<span class="p_chunk">@@ -275,15 +273,13 @@</span> <span class="p_context"> static int regcache_lzo_write(struct regmap *map,</span>
 {
 	struct regcache_lzo_ctx *lzo_block, **lzo_blocks;
 	int ret, blkindex, blkpos;
<span class="p_del">-	size_t blksize, tmp_dst_len;</span>
<span class="p_add">+	size_t tmp_dst_len;</span>
 	void *tmp_dst;
 
 	/* index of the compressed lzo block */
 	blkindex = regcache_lzo_get_blkindex(map, reg);
 	/* register index within the decompressed block */
 	blkpos = regcache_lzo_get_blkpos(map, reg);
<span class="p_del">-	/* size of the compressed block */</span>
<span class="p_del">-	blksize = regcache_lzo_get_blksize(map);</span>
 	lzo_blocks = map-&gt;cache;
 	lzo_block = lzo_blocks[blkindex];
 
<span class="p_header">diff --git a/drivers/block/nbd.c b/drivers/block/nbd.c</span>
<span class="p_header">index 7be44e464462..a1ecedfc9d39 100644</span>
<span class="p_header">--- a/drivers/block/nbd.c</span>
<span class="p_header">+++ b/drivers/block/nbd.c</span>
<span class="p_chunk">@@ -239,9 +239,10 @@</span> <span class="p_context"> static inline int sock_send_bvec(struct nbd_device *nbd, struct bio_vec *bvec,</span>
 /* always call with the tx_lock held */
 static int nbd_send_req(struct nbd_device *nbd, struct request *req)
 {
<span class="p_del">-	int result, flags;</span>
<span class="p_add">+	int result;</span>
 	struct nbd_request request;
 	unsigned long size = blk_rq_bytes(req);
<span class="p_add">+	struct bio *bio;</span>
 
 	memset(&amp;request, 0, sizeof(request));
 	request.magic = htonl(NBD_REQUEST_MAGIC);
<span class="p_chunk">@@ -266,17 +267,19 @@</span> <span class="p_context"> static int nbd_send_req(struct nbd_device *nbd, struct request *req)</span>
 		goto error_out;
 	}
 
<span class="p_del">-	if (nbd_cmd(req) == NBD_CMD_WRITE) {</span>
<span class="p_del">-		struct req_iterator iter;</span>
<span class="p_add">+	if (nbd_cmd(req) != NBD_CMD_WRITE)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	bio = req-&gt;bio;</span>
<span class="p_add">+	while (bio) {</span>
<span class="p_add">+		struct bio *next = bio-&gt;bi_next;</span>
<span class="p_add">+		struct bvec_iter iter;</span>
 		struct bio_vec bvec;
<span class="p_del">-		/*</span>
<span class="p_del">-		 * we are really probing at internals to determine</span>
<span class="p_del">-		 * whether to set MSG_MORE or not...</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		rq_for_each_segment(bvec, req, iter) {</span>
<span class="p_del">-			flags = 0;</span>
<span class="p_del">-			if (!rq_iter_last(bvec, iter))</span>
<span class="p_del">-				flags = MSG_MORE;</span>
<span class="p_add">+</span>
<span class="p_add">+		bio_for_each_segment(bvec, bio, iter) {</span>
<span class="p_add">+			bool is_last = !next &amp;&amp; bio_iter_last(bvec, iter);</span>
<span class="p_add">+			int flags = is_last ? 0 : MSG_MORE;</span>
<span class="p_add">+</span>
 			dprintk(DBG_TX, &quot;%s: request %p: sending %d bytes data\n&quot;,
 					nbd-&gt;disk-&gt;disk_name, req, bvec.bv_len);
 			result = sock_send_bvec(nbd, &amp;bvec, flags);
<span class="p_chunk">@@ -286,7 +289,16 @@</span> <span class="p_context"> static int nbd_send_req(struct nbd_device *nbd, struct request *req)</span>
 					result);
 				goto error_out;
 			}
<span class="p_add">+			/*</span>
<span class="p_add">+			 * The completion might already have come in,</span>
<span class="p_add">+			 * so break for the last one instead of letting</span>
<span class="p_add">+			 * the iterator do it. This prevents use-after-free</span>
<span class="p_add">+			 * of the bio.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (is_last)</span>
<span class="p_add">+				break;</span>
 		}
<span class="p_add">+		bio = next;</span>
 	}
 	return 0;
 
<span class="p_header">diff --git a/drivers/bus/vexpress-config.c b/drivers/bus/vexpress-config.c</span>
<span class="p_header">index a64763b6b5fd..a803e5d84baf 100644</span>
<span class="p_header">--- a/drivers/bus/vexpress-config.c</span>
<span class="p_header">+++ b/drivers/bus/vexpress-config.c</span>
<span class="p_chunk">@@ -171,6 +171,7 @@</span> <span class="p_context"> static int vexpress_config_populate(struct device_node *node)</span>
 {
 	struct device_node *bridge;
 	struct device *parent;
<span class="p_add">+	int ret;</span>
 
 	bridge = of_parse_phandle(node, &quot;arm,vexpress,config-bridge&quot;, 0);
 	if (!bridge)
<span class="p_chunk">@@ -181,7 +182,11 @@</span> <span class="p_context"> static int vexpress_config_populate(struct device_node *node)</span>
 	if (WARN_ON(!parent))
 		return -ENODEV;
 
<span class="p_del">-	return of_platform_populate(node, NULL, NULL, parent);</span>
<span class="p_add">+	ret = of_platform_populate(node, NULL, NULL, parent);</span>
<span class="p_add">+</span>
<span class="p_add">+	put_device(parent);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int __init vexpress_config_init(void)
<span class="p_header">diff --git a/drivers/clk/clk-wm831x.c b/drivers/clk/clk-wm831x.c</span>
<span class="p_header">index b131041c8f48..093dfe159dfb 100644</span>
<span class="p_header">--- a/drivers/clk/clk-wm831x.c</span>
<span class="p_header">+++ b/drivers/clk/clk-wm831x.c</span>
<span class="p_chunk">@@ -248,7 +248,7 @@</span> <span class="p_context"> static int wm831x_clkout_is_prepared(struct clk_hw *hw)</span>
 	if (ret &lt; 0) {
 		dev_err(wm831x-&gt;dev, &quot;Unable to read CLOCK_CONTROL_1: %d\n&quot;,
 			ret);
<span class="p_del">-		return true;</span>
<span class="p_add">+		return false;</span>
 	}
 
 	return (ret &amp; WM831X_CLKOUT_ENA) != 0;
<span class="p_header">diff --git a/drivers/clk/shmobile/clk-mstp.c b/drivers/clk/shmobile/clk-mstp.c</span>
<span class="p_header">index 2d2fe773ac81..a9e02a38093e 100644</span>
<span class="p_header">--- a/drivers/clk/shmobile/clk-mstp.c</span>
<span class="p_header">+++ b/drivers/clk/shmobile/clk-mstp.c</span>
<span class="p_chunk">@@ -31,12 +31,14 @@</span> <span class="p_context"></span>
  * @smstpcr: module stop control register
  * @mstpsr: module stop status register (optional)
  * @lock: protects writes to SMSTPCR
<span class="p_add">+ * @width_8bit: registers are 8-bit, not 32-bit</span>
  */
 struct mstp_clock_group {
 	struct clk_onecell_data data;
 	void __iomem *smstpcr;
 	void __iomem *mstpsr;
 	spinlock_t lock;
<span class="p_add">+	bool width_8bit;</span>
 };
 
 /**
<span class="p_chunk">@@ -53,6 +55,18 @@</span> <span class="p_context"> struct mstp_clock {</span>
 
 #define to_mstp_clock(_hw) container_of(_hw, struct mstp_clock, hw)
 
<span class="p_add">+static inline u32 cpg_mstp_read(struct mstp_clock_group *group,</span>
<span class="p_add">+				u32 __iomem *reg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return group-&gt;width_8bit ? readb(reg) : clk_readl(reg);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void cpg_mstp_write(struct mstp_clock_group *group, u32 val,</span>
<span class="p_add">+				  u32 __iomem *reg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	group-&gt;width_8bit ? writeb(val, reg) : clk_writel(val, reg);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int cpg_mstp_clock_endisable(struct clk_hw *hw, bool enable)
 {
 	struct mstp_clock *clock = to_mstp_clock(hw);
<span class="p_chunk">@@ -64,12 +78,12 @@</span> <span class="p_context"> static int cpg_mstp_clock_endisable(struct clk_hw *hw, bool enable)</span>
 
 	spin_lock_irqsave(&amp;group-&gt;lock, flags);
 
<span class="p_del">-	value = clk_readl(group-&gt;smstpcr);</span>
<span class="p_add">+	value = cpg_mstp_read(group, group-&gt;smstpcr);</span>
 	if (enable)
 		value &amp;= ~bitmask;
 	else
 		value |= bitmask;
<span class="p_del">-	clk_writel(value, group-&gt;smstpcr);</span>
<span class="p_add">+	cpg_mstp_write(group, value, group-&gt;smstpcr);</span>
 
 	spin_unlock_irqrestore(&amp;group-&gt;lock, flags);
 
<span class="p_chunk">@@ -77,7 +91,7 @@</span> <span class="p_context"> static int cpg_mstp_clock_endisable(struct clk_hw *hw, bool enable)</span>
 		return 0;
 
 	for (i = 1000; i &gt; 0; --i) {
<span class="p_del">-		if (!(clk_readl(group-&gt;mstpsr) &amp; bitmask))</span>
<span class="p_add">+		if (!(cpg_mstp_read(group, group-&gt;mstpsr) &amp; bitmask))</span>
 			break;
 		cpu_relax();
 	}
<span class="p_chunk">@@ -108,9 +122,9 @@</span> <span class="p_context"> static int cpg_mstp_clock_is_enabled(struct clk_hw *hw)</span>
 	u32 value;
 
 	if (group-&gt;mstpsr)
<span class="p_del">-		value = clk_readl(group-&gt;mstpsr);</span>
<span class="p_add">+		value = cpg_mstp_read(group, group-&gt;mstpsr);</span>
 	else
<span class="p_del">-		value = clk_readl(group-&gt;smstpcr);</span>
<span class="p_add">+		value = cpg_mstp_read(group, group-&gt;smstpcr);</span>
 
 	return !(value &amp; BIT(clock-&gt;bit_index));
 }
<span class="p_chunk">@@ -182,6 +196,9 @@</span> <span class="p_context"> static void __init cpg_mstp_clocks_init(struct device_node *np)</span>
 		return;
 	}
 
<span class="p_add">+	if (of_device_is_compatible(np, &quot;renesas,r7s72100-mstp-clocks&quot;))</span>
<span class="p_add">+		group-&gt;width_8bit = true;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; MSTP_MAX_CLOCKS; ++i)
 		clks[i] = ERR_PTR(-ENOENT);
 
<span class="p_header">diff --git a/drivers/clocksource/exynos_mct.c b/drivers/clocksource/exynos_mct.c</span>
<span class="p_header">index 5d1b7f64947c..2163a5145518 100644</span>
<span class="p_header">--- a/drivers/clocksource/exynos_mct.c</span>
<span class="p_header">+++ b/drivers/clocksource/exynos_mct.c</span>
<span class="p_chunk">@@ -458,10 +458,15 @@</span> <span class="p_context"> static int exynos4_local_timer_setup(struct clock_event_device *evt)</span>
 
 static void exynos4_local_timer_stop(struct clock_event_device *evt)
 {
<span class="p_add">+	struct mct_clock_event_device *mevt;</span>
<span class="p_add">+</span>
<span class="p_add">+	mevt = container_of(evt, struct mct_clock_event_device, evt);</span>
<span class="p_add">+</span>
 	evt-&gt;set_mode(CLOCK_EVT_MODE_UNUSED, evt);
 	if (mct_int_type == MCT_INT_SPI) {
 		if (evt-&gt;irq != -1)
 			disable_irq_nosync(evt-&gt;irq);
<span class="p_add">+		exynos4_mct_write(0x1, mevt-&gt;base + MCT_L_INT_CSTAT_OFFSET);</span>
 	} else {
 		disable_percpu_irq(mct_irqs[MCT_L0_IRQ]);
 	}
<span class="p_header">diff --git a/drivers/crypto/caam/caamalg.c b/drivers/crypto/caam/caamalg.c</span>
<span class="p_header">index c09ce1f040d3..1690cc09f905 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/caamalg.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/caamalg.c</span>
<span class="p_chunk">@@ -590,7 +590,9 @@</span> <span class="p_context"> static int aead_set_sh_desc(struct crypto_aead *aead)</span>
 
 	/* Will read cryptlen */
 	append_math_add(desc, VARSEQINLEN, SEQINLEN, REG0, CAAM_CMD_SZ);
<span class="p_del">-	aead_append_src_dst(desc, FIFOLD_TYPE_MSG1OUT2);</span>
<span class="p_add">+	append_seq_fifo_load(desc, 0, FIFOLD_CLASS_BOTH | KEY_VLF |</span>
<span class="p_add">+			     FIFOLD_TYPE_MSG1OUT2 | FIFOLD_TYPE_LASTBOTH);</span>
<span class="p_add">+	append_seq_fifo_store(desc, 0, FIFOST_TYPE_MESSAGE_DATA | KEY_VLF);</span>
 
 	/* Write ICV */
 	append_seq_store(desc, ctx-&gt;authsize, LDST_CLASS_2_CCB |
<span class="p_header">diff --git a/drivers/devfreq/devfreq.c b/drivers/devfreq/devfreq.c</span>
<span class="p_header">index ba850eb2d275..3ec5509b1433 100644</span>
<span class="p_header">--- a/drivers/devfreq/devfreq.c</span>
<span class="p_header">+++ b/drivers/devfreq/devfreq.c</span>
<span class="p_chunk">@@ -502,22 +502,29 @@</span> <span class="p_context"> struct devfreq *devfreq_add_device(struct device *dev,</span>
 	list_add(&amp;devfreq-&gt;node, &amp;devfreq_list);
 
 	governor = find_devfreq_governor(devfreq-&gt;governor_name);
<span class="p_del">-	if (!IS_ERR(governor))</span>
<span class="p_del">-		devfreq-&gt;governor = governor;</span>
<span class="p_del">-	if (devfreq-&gt;governor)</span>
<span class="p_del">-		err = devfreq-&gt;governor-&gt;event_handler(devfreq,</span>
<span class="p_del">-					DEVFREQ_GOV_START, NULL);</span>
<span class="p_del">-	mutex_unlock(&amp;devfreq_list_lock);</span>
<span class="p_add">+	if (IS_ERR(governor)) {</span>
<span class="p_add">+		dev_err(dev, &quot;%s: Unable to find governor for the device\n&quot;,</span>
<span class="p_add">+			__func__);</span>
<span class="p_add">+		err = PTR_ERR(governor);</span>
<span class="p_add">+		goto err_init;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	devfreq-&gt;governor = governor;</span>
<span class="p_add">+	err = devfreq-&gt;governor-&gt;event_handler(devfreq, DEVFREQ_GOV_START,</span>
<span class="p_add">+						NULL);</span>
 	if (err) {
 		dev_err(dev, &quot;%s: Unable to start governor for the device\n&quot;,
 			__func__);
 		goto err_init;
 	}
<span class="p_add">+	mutex_unlock(&amp;devfreq_list_lock);</span>
 
 	return devfreq;
 
 err_init:
 	list_del(&amp;devfreq-&gt;node);
<span class="p_add">+	mutex_unlock(&amp;devfreq_list_lock);</span>
<span class="p_add">+</span>
 	device_unregister(&amp;devfreq-&gt;dev);
 err_dev:
 	kfree(devfreq);
<span class="p_header">diff --git a/drivers/gpu/drm/ast/ast_main.c b/drivers/gpu/drm/ast/ast_main.c</span>
<span class="p_header">index cb6d626dad02..18152350b32f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ast/ast_main.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ast/ast_main.c</span>
<span class="p_chunk">@@ -178,7 +178,8 @@</span> <span class="p_context"> static int ast_get_dram_info(struct drm_device *dev)</span>
 	ast_write32(ast, 0x10000, 0xfc600309);
 
 	do {
<span class="p_del">-		;</span>
<span class="p_add">+		if (pci_channel_offline(dev-&gt;pdev))</span>
<span class="p_add">+			return -EIO;</span>
 	} while (ast_read32(ast, 0x10000) != 0x01);
 	data = ast_read32(ast, 0x10004);
 
<span class="p_chunk">@@ -369,7 +370,9 @@</span> <span class="p_context"> int ast_driver_load(struct drm_device *dev, unsigned long flags)</span>
 	ast_detect_chip(dev);
 
 	if (ast-&gt;chip != AST1180) {
<span class="p_del">-		ast_get_dram_info(dev);</span>
<span class="p_add">+		ret = ast_get_dram_info(dev);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto out_free;</span>
 		ast-&gt;vram_size = ast_get_vram_info(dev);
 		DRM_INFO(&quot;dram %d %d %d %08x\n&quot;, ast-&gt;mclk, ast-&gt;dram_type, ast-&gt;dram_bus_width, ast-&gt;vram_size);
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/gma500/psb_drv.c b/drivers/gpu/drm/gma500/psb_drv.c</span>
<span class="p_header">index 6e8fe9ec02b5..efe5c3c7e8e2 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/gma500/psb_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/gma500/psb_drv.c</span>
<span class="p_chunk">@@ -464,6 +464,9 @@</span> <span class="p_context"> static const struct file_operations psb_gem_fops = {</span>
 	.open = drm_open,
 	.release = drm_release,
 	.unlocked_ioctl = psb_unlocked_ioctl,
<span class="p_add">+#ifdef CONFIG_COMPAT</span>
<span class="p_add">+	.compat_ioctl = drm_compat_ioctl,</span>
<span class="p_add">+#endif</span>
 	.mmap = drm_gem_mmap,
 	.poll = drm_poll,
 	.read = drm_read,
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_crt.c b/drivers/gpu/drm/i915/intel_crt.c</span>
<span class="p_header">index bb3a6209b245..a0e7a2e20111 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_crt.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_crt.c</span>
<span class="p_chunk">@@ -477,6 +477,7 @@</span> <span class="p_context"> static bool intel_crt_detect_ddc(struct drm_connector *connector)</span>
 	struct drm_i915_private *dev_priv = crt-&gt;base.base.dev-&gt;dev_private;
 	struct edid *edid;
 	struct i2c_adapter *i2c;
<span class="p_add">+	bool ret = false;</span>
 
 	BUG_ON(crt-&gt;base.type != INTEL_OUTPUT_ANALOG);
 
<span class="p_chunk">@@ -493,17 +494,17 @@</span> <span class="p_context"> static bool intel_crt_detect_ddc(struct drm_connector *connector)</span>
 		 */
 		if (!is_digital) {
 			DRM_DEBUG_KMS(&quot;CRT detected via DDC:0x50 [EDID]\n&quot;);
<span class="p_del">-			return true;</span>
<span class="p_add">+			ret = true;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			DRM_DEBUG_KMS(&quot;CRT not detected via DDC:0x50 [EDID reports a digital panel]\n&quot;);</span>
 		}
<span class="p_del">-</span>
<span class="p_del">-		DRM_DEBUG_KMS(&quot;CRT not detected via DDC:0x50 [EDID reports a digital panel]\n&quot;);</span>
 	} else {
 		DRM_DEBUG_KMS(&quot;CRT not detected via DDC:0x50 [no valid EDID found]\n&quot;);
 	}
 
 	kfree(edid);
 
<span class="p_del">-	return false;</span>
<span class="p_add">+	return ret;</span>
 }
 
 static enum drm_connector_status
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index 2041c5bbb929..03c76d17f0de 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -8913,9 +8913,9 @@</span> <span class="p_context"> static void do_intel_finish_page_flip(struct drm_device *dev,</span>
 
 	wake_up_all(&amp;dev_priv-&gt;pending_flip_queue);
 
<span class="p_del">-	queue_work(dev_priv-&gt;wq, &amp;work-&gt;work);</span>
<span class="p_del">-</span>
 	trace_i915_flip_complete(intel_crtc-&gt;plane, work-&gt;pending_flip_obj);
<span class="p_add">+</span>
<span class="p_add">+	queue_work(dev_priv-&gt;wq, &amp;work-&gt;work);</span>
 }
 
 void intel_finish_page_flip(struct drm_device *dev, int pipe)
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_pm.c b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">index 5010e2c32c23..aa83a835965c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_chunk">@@ -5346,7 +5346,16 @@</span> <span class="p_context"> static void valleyview_init_clock_gating(struct drm_device *dev)</span>
 	DRM_DEBUG_DRIVER(&quot;Current CD clock rate: %d MHz&quot;,
 			 dev_priv-&gt;vlv_cdclk_freq);
 
<span class="p_del">-	I915_WRITE(DSPCLK_GATE_D, VRHUNIT_CLOCK_GATE_DISABLE);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * On driver load, a pipe may be active and driving a DSI display.</span>
<span class="p_add">+	 * Preserve DPOUNIT_CLOCK_GATE_DISABLE to avoid the pipe getting stuck</span>
<span class="p_add">+	 * (and never recovering) in this case. intel_dsi_post_disable() will</span>
<span class="p_add">+	 * clear it when we turn off the display.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	val = I915_READ(DSPCLK_GATE_D);</span>
<span class="p_add">+	val &amp;= DPOUNIT_CLOCK_GATE_DISABLE;</span>
<span class="p_add">+	val |= VRHUNIT_CLOCK_GATE_DISABLE;</span>
<span class="p_add">+	I915_WRITE(DSPCLK_GATE_D, val);</span>
 
 	/* WaDisableEarlyCull:vlv */
 	I915_WRITE(_3D_CHICKEN3,
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/dispnv04/hw.c b/drivers/gpu/drm/nouveau/dispnv04/hw.c</span>
<span class="p_header">index aca76af115b3..1ddb10b32bbe 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/dispnv04/hw.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/dispnv04/hw.c</span>
<span class="p_chunk">@@ -225,6 +225,7 @@</span> <span class="p_context"> nouveau_hw_get_clock(struct drm_device *dev, enum nvbios_pll_type plltype)</span>
 		uint32_t mpllP;
 
 		pci_read_config_dword(pci_get_bus_and_slot(0, 3), 0x6c, &amp;mpllP);
<span class="p_add">+		mpllP = (mpllP &gt;&gt; 8) &amp; 0xf;</span>
 		if (!mpllP)
 			mpllP = 4;
 
<span class="p_chunk">@@ -235,7 +236,7 @@</span> <span class="p_context"> nouveau_hw_get_clock(struct drm_device *dev, enum nvbios_pll_type plltype)</span>
 		uint32_t clock;
 
 		pci_read_config_dword(pci_get_bus_and_slot(0, 5), 0x4c, &amp;clock);
<span class="p_del">-		return clock;</span>
<span class="p_add">+		return clock / 1000;</span>
 	}
 
 	ret = nouveau_hw_get_pllvals(dev, plltype, &amp;pllvals);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_cursor.c b/drivers/gpu/drm/radeon/radeon_cursor.c</span>
<span class="p_header">index 9630e8d95fb4..faacc400d6fa 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_cursor.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_cursor.c</span>
<span class="p_chunk">@@ -90,6 +90,9 @@</span> <span class="p_context"> static void radeon_show_cursor(struct drm_crtc *crtc)</span>
 	struct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);
 	struct radeon_device *rdev = crtc-&gt;dev-&gt;dev_private;
 
<span class="p_add">+	if (radeon_crtc-&gt;cursor_out_of_bounds)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	if (ASIC_IS_DCE4(rdev)) {
 		WREG32(RADEON_MM_INDEX, EVERGREEN_CUR_CONTROL + radeon_crtc-&gt;crtc_offset);
 		WREG32(RADEON_MM_DATA, EVERGREEN_CURSOR_EN |
<span class="p_chunk">@@ -228,16 +231,17 @@</span> <span class="p_context"> int radeon_crtc_cursor_move(struct drm_crtc *crtc,</span>
 		x += crtc-&gt;x;
 		y += crtc-&gt;y;
 	}
<span class="p_del">-	DRM_DEBUG(&quot;x %d y %d c-&gt;x %d c-&gt;y %d\n&quot;, x, y, crtc-&gt;x, crtc-&gt;y);</span>
 
<span class="p_del">-	if (x &lt; 0) {</span>
<span class="p_add">+	if (x &lt; 0)</span>
 		xorigin = min(-x, radeon_crtc-&gt;max_cursor_width - 1);
<span class="p_del">-		x = 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (y &lt; 0) {</span>
<span class="p_add">+	if (y &lt; 0)</span>
 		yorigin = min(-y, radeon_crtc-&gt;max_cursor_height - 1);
<span class="p_del">-		y = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!ASIC_IS_AVIVO(rdev)) {</span>
<span class="p_add">+		x += crtc-&gt;x;</span>
<span class="p_add">+		y += crtc-&gt;y;</span>
 	}
<span class="p_add">+	DRM_DEBUG(&quot;x %d y %d c-&gt;x %d c-&gt;y %d\n&quot;, x, y, crtc-&gt;x, crtc-&gt;y);</span>
 
 	/* fixed on DCE6 and newer */
 	if (ASIC_IS_AVIVO(rdev) &amp;&amp; !ASIC_IS_DCE6(rdev)) {
<span class="p_chunk">@@ -260,27 +264,31 @@</span> <span class="p_context"> int radeon_crtc_cursor_move(struct drm_crtc *crtc,</span>
 		if (i &gt; 1) {
 			int cursor_end, frame_end;
 
<span class="p_del">-			cursor_end = x - xorigin + w;</span>
<span class="p_add">+			cursor_end = x + w;</span>
 			frame_end = crtc-&gt;x + crtc-&gt;mode.crtc_hdisplay;
 			if (cursor_end &gt;= frame_end) {
 				w = w - (cursor_end - frame_end);
 				if (!(frame_end &amp; 0x7f))
 					w--;
<span class="p_del">-			} else {</span>
<span class="p_del">-				if (!(cursor_end &amp; 0x7f))</span>
<span class="p_del">-					w--;</span>
<span class="p_add">+			} else if (cursor_end &lt;= 0) {</span>
<span class="p_add">+				goto out_of_bounds;</span>
<span class="p_add">+			} else if (!(cursor_end &amp; 0x7f)) {</span>
<span class="p_add">+				w--;</span>
 			}
 			if (w &lt;= 0) {
<span class="p_del">-				w = 1;</span>
<span class="p_del">-				cursor_end = x - xorigin + w;</span>
<span class="p_del">-				if (!(cursor_end &amp; 0x7f)) {</span>
<span class="p_del">-					x--;</span>
<span class="p_del">-					WARN_ON_ONCE(x &lt; 0);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				goto out_of_bounds;</span>
 			}
 		}
 	}
 
<span class="p_add">+	if (x &lt;= (crtc-&gt;x - w) || y &lt;= (crtc-&gt;y - radeon_crtc-&gt;cursor_height) ||</span>
<span class="p_add">+	    x &gt;= (crtc-&gt;x + crtc-&gt;mode.hdisplay) ||</span>
<span class="p_add">+	    y &gt;= (crtc-&gt;y + crtc-&gt;mode.vdisplay))</span>
<span class="p_add">+		goto out_of_bounds;</span>
<span class="p_add">+</span>
<span class="p_add">+	x += xorigin;</span>
<span class="p_add">+	y += yorigin;</span>
<span class="p_add">+</span>
 	radeon_lock_cursor(crtc, true);
 	if (ASIC_IS_DCE4(rdev)) {
 		WREG32(EVERGREEN_CUR_POSITION + radeon_crtc-&gt;crtc_offset, (x &lt;&lt; 16) | y);
<span class="p_chunk">@@ -293,6 +301,9 @@</span> <span class="p_context"> int radeon_crtc_cursor_move(struct drm_crtc *crtc,</span>
 		WREG32(AVIVO_D1CUR_SIZE + radeon_crtc-&gt;crtc_offset,
 		       ((w - 1) &lt;&lt; 16) | (radeon_crtc-&gt;cursor_height - 1));
 	} else {
<span class="p_add">+		x -= crtc-&gt;x;</span>
<span class="p_add">+		y -= crtc-&gt;y;</span>
<span class="p_add">+</span>
 		if (crtc-&gt;mode.flags &amp; DRM_MODE_FLAG_DBLSCAN)
 			y *= 2;
 
<span class="p_chunk">@@ -310,5 +321,18 @@</span> <span class="p_context"> int radeon_crtc_cursor_move(struct drm_crtc *crtc,</span>
 	}
 	radeon_lock_cursor(crtc, false);
 
<span class="p_add">+	if (radeon_crtc-&gt;cursor_out_of_bounds) {</span>
<span class="p_add">+		radeon_crtc-&gt;cursor_out_of_bounds = false;</span>
<span class="p_add">+		if (radeon_crtc-&gt;cursor_bo)</span>
<span class="p_add">+			radeon_show_cursor(crtc);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+ out_of_bounds:</span>
<span class="p_add">+	if (!radeon_crtc-&gt;cursor_out_of_bounds) {</span>
<span class="p_add">+		radeon_hide_cursor(crtc);</span>
<span class="p_add">+		radeon_crtc-&gt;cursor_out_of_bounds = true;</span>
<span class="p_add">+	}</span>
 	return 0;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_mode.h b/drivers/gpu/drm/radeon/radeon_mode.h</span>
<span class="p_header">index 0592ddb0904b..43c4fd754cbd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_mode.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_mode.h</span>
<span class="p_chunk">@@ -318,6 +318,7 @@</span> <span class="p_context"> struct radeon_crtc {</span>
 	u16 lut_r[256], lut_g[256], lut_b[256];
 	bool enabled;
 	bool can_tile;
<span class="p_add">+	bool cursor_out_of_bounds;</span>
 	uint32_t crtc_offset;
 	struct drm_gem_object *cursor_bo;
 	uint64_t cursor_addr;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">index c9b290b5b52b..2b04749ad314 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_chunk">@@ -2953,24 +2953,12 @@</span> <span class="p_context"> static void si_apply_state_adjust_rules(struct radeon_device *rdev,</span>
 		    (rdev-&gt;pdev-&gt;device == 0x6817) ||
 		    (rdev-&gt;pdev-&gt;device == 0x6806))
 			max_mclk = 120000;
<span class="p_del">-	} else if (rdev-&gt;family == CHIP_VERDE) {</span>
<span class="p_del">-		if ((rdev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;revision == 0x83) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;revision == 0x87) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6820) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6821) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6822) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6823) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x682A) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x682B)) {</span>
<span class="p_del">-			max_sclk = 75000;</span>
<span class="p_del">-			max_mclk = 80000;</span>
<span class="p_del">-		}</span>
 	} else if (rdev-&gt;family == CHIP_OLAND) {
 		if ((rdev-&gt;pdev-&gt;revision == 0xC7) ||
 		    (rdev-&gt;pdev-&gt;revision == 0x80) ||
 		    (rdev-&gt;pdev-&gt;revision == 0x81) ||
 		    (rdev-&gt;pdev-&gt;revision == 0x83) ||
<span class="p_add">+		    (rdev-&gt;pdev-&gt;revision == 0x87) ||</span>
 		    (rdev-&gt;pdev-&gt;device == 0x6604) ||
 		    (rdev-&gt;pdev-&gt;device == 0x6605)) {
 			max_sclk = 75000;
<span class="p_header">diff --git a/drivers/hid/hid-cypress.c b/drivers/hid/hid-cypress.c</span>
<span class="p_header">index c4ef3bc726e3..e299576004ce 100644</span>
<span class="p_header">--- a/drivers/hid/hid-cypress.c</span>
<span class="p_header">+++ b/drivers/hid/hid-cypress.c</span>
<span class="p_chunk">@@ -39,6 +39,9 @@</span> <span class="p_context"> static __u8 *cp_report_fixup(struct hid_device *hdev, __u8 *rdesc,</span>
 	if (!(quirks &amp; CP_RDESC_SWAPPED_MIN_MAX))
 		return rdesc;
 
<span class="p_add">+	if (*rsize &lt; 4)</span>
<span class="p_add">+		return rdesc;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; *rsize - 4; i++)
 		if (rdesc[i] == 0x29 &amp;&amp; rdesc[i + 2] == 0x19) {
 			__u8 tmp;
<span class="p_header">diff --git a/drivers/hwmon/ds620.c b/drivers/hwmon/ds620.c</span>
<span class="p_header">index 0918b9136588..2a50ab613238 100644</span>
<span class="p_header">--- a/drivers/hwmon/ds620.c</span>
<span class="p_header">+++ b/drivers/hwmon/ds620.c</span>
<span class="p_chunk">@@ -166,7 +166,7 @@</span> <span class="p_context"> static ssize_t set_temp(struct device *dev, struct device_attribute *da,</span>
 	if (res)
 		return res;
 
<span class="p_del">-	val = (val * 10 / 625) * 8;</span>
<span class="p_add">+	val = (clamp_val(val, -128000, 128000) * 10 / 625) * 8;</span>
 
 	mutex_lock(&amp;data-&gt;update_lock);
 	data-&gt;temp[attr-&gt;index] = val;
<span class="p_header">diff --git a/drivers/hwmon/g762.c b/drivers/hwmon/g762.c</span>
<span class="p_header">index 98a8618d8fbf..2811db085366 100644</span>
<span class="p_header">--- a/drivers/hwmon/g762.c</span>
<span class="p_header">+++ b/drivers/hwmon/g762.c</span>
<span class="p_chunk">@@ -193,14 +193,17 @@</span> <span class="p_context"> static inline unsigned int rpm_from_cnt(u8 cnt, u32 clk_freq, u16 p,</span>
  * Convert fan RPM value from sysfs into count value for fan controller
  * register (FAN_SET_CNT).
  */
<span class="p_del">-static inline unsigned char cnt_from_rpm(u32 rpm, u32 clk_freq, u16 p,</span>
<span class="p_add">+static inline unsigned char cnt_from_rpm(unsigned long rpm, u32 clk_freq, u16 p,</span>
 					 u8 clk_div, u8 gear_mult)
 {
<span class="p_del">-	if (!rpm)         /* to stop the fan, set cnt to 255 */</span>
<span class="p_add">+	unsigned long f1 = clk_freq * 30 * gear_mult;</span>
<span class="p_add">+	unsigned long f2 = p * clk_div;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!rpm)	/* to stop the fan, set cnt to 255 */</span>
 		return 0xff;
 
<span class="p_del">-	return clamp_val(((clk_freq * 30 * gear_mult) / (rpm * p * clk_div)),</span>
<span class="p_del">-			 0, 255);</span>
<span class="p_add">+	rpm = clamp_val(rpm, f1 / (255 * f2), ULONG_MAX / f2);</span>
<span class="p_add">+	return DIV_ROUND_CLOSEST(f1, rpm * f2);</span>
 }
 
 /* helper to grab and cache data, at most one time per second */
<span class="p_header">diff --git a/drivers/i2c/i2c-dev.c b/drivers/i2c/i2c-dev.c</span>
<span class="p_header">index 80b47e8ce030..3baf4af1413a 100644</span>
<span class="p_header">--- a/drivers/i2c/i2c-dev.c</span>
<span class="p_header">+++ b/drivers/i2c/i2c-dev.c</span>
<span class="p_chunk">@@ -334,7 +334,7 @@</span> <span class="p_context"> static noinline int i2cdev_ioctl_smbus(struct i2c_client *client,</span>
 		unsigned long arg)
 {
 	struct i2c_smbus_ioctl_data data_arg;
<span class="p_del">-	union i2c_smbus_data temp;</span>
<span class="p_add">+	union i2c_smbus_data temp = {};</span>
 	int datasize, res;
 
 	if (copy_from_user(&amp;data_arg,
<span class="p_header">diff --git a/drivers/i2c/muxes/i2c-mux-pca954x.c b/drivers/i2c/muxes/i2c-mux-pca954x.c</span>
<span class="p_header">index f1b945509477..5419a356bfdd 100644</span>
<span class="p_header">--- a/drivers/i2c/muxes/i2c-mux-pca954x.c</span>
<span class="p_header">+++ b/drivers/i2c/muxes/i2c-mux-pca954x.c</span>
<span class="p_chunk">@@ -133,6 +133,9 @@</span> <span class="p_context"> static int pca954x_reg_write(struct i2c_adapter *adap,</span>
 		buf[0] = val;
 		msg.buf = buf;
 		ret = adap-&gt;algo-&gt;master_xfer(adap, &amp;msg, 1);
<span class="p_add">+</span>
<span class="p_add">+		if (ret &gt;= 0 &amp;&amp; ret != 1)</span>
<span class="p_add">+			ret = -EREMOTEIO;</span>
 	} else {
 		union i2c_smbus_data data;
 		ret = adap-&gt;algo-&gt;smbus_xfer(adap, client-&gt;addr,
<span class="p_chunk">@@ -161,7 +164,7 @@</span> <span class="p_context"> static int pca954x_select_chan(struct i2c_adapter *adap,</span>
 	/* Only select the channel if its different from the last channel */
 	if (data-&gt;last_chan != regval) {
 		ret = pca954x_reg_write(adap, client, regval);
<span class="p_del">-		data-&gt;last_chan = ret ? 0 : regval;</span>
<span class="p_add">+		data-&gt;last_chan = ret &lt; 0 ? 0 : regval;</span>
 	}
 
 	return ret;
<span class="p_header">diff --git a/drivers/iio/humidity/dht11.c b/drivers/iio/humidity/dht11.c</span>
<span class="p_header">index d8771f546bf2..bd7c386d5878 100644</span>
<span class="p_header">--- a/drivers/iio/humidity/dht11.c</span>
<span class="p_header">+++ b/drivers/iio/humidity/dht11.c</span>
<span class="p_chunk">@@ -44,7 +44,8 @@</span> <span class="p_context"></span>
 #define DHT11_EDGES_PER_READ (2*DHT11_BITS_PER_READ + DHT11_EDGES_PREAMBLE + 1)
 
 /* Data transmission timing (nano seconds) */
<span class="p_del">-#define DHT11_START_TRANSMISSION	18  /* ms */</span>
<span class="p_add">+#define DHT11_START_TRANSMISSION_MIN	18000  /* us */</span>
<span class="p_add">+#define DHT11_START_TRANSMISSION_MAX	20000  /* us */</span>
 #define DHT11_SENSOR_RESPONSE	80000
 #define DHT11_START_BIT		50000
 #define DHT11_DATA_BIT_LOW	27000
<span class="p_chunk">@@ -152,7 +153,8 @@</span> <span class="p_context"> static int dht11_read_raw(struct iio_dev *iio_dev,</span>
 		ret = gpio_direction_output(dht11-&gt;gpio, 0);
 		if (ret)
 			goto err;
<span class="p_del">-		msleep(DHT11_START_TRANSMISSION);</span>
<span class="p_add">+		usleep_range(DHT11_START_TRANSMISSION_MIN,</span>
<span class="p_add">+			     DHT11_START_TRANSMISSION_MAX);</span>
 		ret = gpio_direction_input(dht11-&gt;gpio);
 		if (ret)
 			goto err;
<span class="p_header">diff --git a/drivers/infiniband/core/mad.c b/drivers/infiniband/core/mad.c</span>
<span class="p_header">index ab31f136d04b..5b66fedaacc3 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/mad.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/mad.c</span>
<span class="p_chunk">@@ -1607,7 +1607,7 @@</span> <span class="p_context"> find_mad_agent(struct ib_mad_port_private *port_priv,</span>
 			if (!class)
 				goto out;
 			if (convert_mgmt_class(mad-&gt;mad_hdr.mgmt_class) &gt;=
<span class="p_del">-			    IB_MGMT_MAX_METHODS)</span>
<span class="p_add">+			    ARRAY_SIZE(class-&gt;method_table))</span>
 				goto out;
 			method = class-&gt;method_table[convert_mgmt_class(
 							mad-&gt;mad_hdr.mgmt_class)];
<span class="p_header">diff --git a/drivers/infiniband/core/multicast.c b/drivers/infiniband/core/multicast.c</span>
<span class="p_header">index 180d7f436ed5..2f861b59cbc1 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/multicast.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/multicast.c</span>
<span class="p_chunk">@@ -516,8 +516,11 @@</span> <span class="p_context"> static void join_handler(int status, struct ib_sa_mcmember_rec *rec,</span>
 	if (status)
 		process_join_error(group, status);
 	else {
<span class="p_del">-		ib_find_pkey(group-&gt;port-&gt;dev-&gt;device, group-&gt;port-&gt;port_num,</span>
<span class="p_del">-			     be16_to_cpu(rec-&gt;pkey), &amp;pkey_index);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ib_find_pkey(group-&gt;port-&gt;dev-&gt;device,</span>
<span class="p_add">+				 group-&gt;port-&gt;port_num, be16_to_cpu(rec-&gt;pkey),</span>
<span class="p_add">+				 &amp;pkey_index))</span>
<span class="p_add">+			pkey_index = MCAST_INVALID_PKEY_INDEX;</span>
 
 		spin_lock_irq(&amp;group-&gt;port-&gt;lock);
 		group-&gt;rec = *rec;
<span class="p_header">diff --git a/drivers/infiniband/core/uverbs_cmd.c b/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_header">index 5e66eab292d8..ce649a7ffa56 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_chunk">@@ -2764,7 +2764,6 @@</span> <span class="p_context"> int ib_uverbs_ex_create_flow(struct ib_uverbs_file *file,</span>
 		err = PTR_ERR(flow_id);
 		goto err_free;
 	}
<span class="p_del">-	flow_id-&gt;qp = qp;</span>
 	flow_id-&gt;uobject = uobj;
 	uobj-&gt;object = flow_id;
 
<span class="p_header">diff --git a/drivers/infiniband/core/verbs.c b/drivers/infiniband/core/verbs.c</span>
<span class="p_header">index c2b89cc5dbca..0c859f7fb7a4 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/verbs.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/verbs.c</span>
<span class="p_chunk">@@ -1420,8 +1420,10 @@</span> <span class="p_context"> struct ib_flow *ib_create_flow(struct ib_qp *qp,</span>
 		return ERR_PTR(-ENOSYS);
 
 	flow_id = qp-&gt;device-&gt;create_flow(qp, flow_attr, domain);
<span class="p_del">-	if (!IS_ERR(flow_id))</span>
<span class="p_add">+	if (!IS_ERR(flow_id)) {</span>
 		atomic_inc(&amp;qp-&gt;usecnt);
<span class="p_add">+		flow_id-&gt;qp = qp;</span>
<span class="p_add">+	}</span>
 	return flow_id;
 }
 EXPORT_SYMBOL(ib_create_flow);
<span class="p_header">diff --git a/drivers/infiniband/hw/cxgb4/device.c b/drivers/infiniband/hw/cxgb4/device.c</span>
<span class="p_header">index 7db82b24302b..ea8ce383e57d 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/cxgb4/device.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/cxgb4/device.c</span>
<span class="p_chunk">@@ -694,6 +694,7 @@</span> <span class="p_context"> static int c4iw_rdev_open(struct c4iw_rdev *rdev)</span>
 			    __get_free_page(GFP_KERNEL);
 	if (!rdev-&gt;status_page) {
 		pr_err(MOD &quot;error allocating status page\n&quot;);
<span class="p_add">+		err = -ENOMEM;</span>
 		goto err4;
 	}
 	rdev-&gt;status_page-&gt;db_off = 0;
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/ah.c b/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_header">index 4c2686514ced..62aa7d9422a4 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_chunk">@@ -97,7 +97,9 @@</span> <span class="p_context"> static struct ib_ah *create_iboe_ah(struct ib_pd *pd, struct ib_ah_attr *ah_attr</span>
 		       !(1 &lt;&lt; ah-&gt;av.eth.stat_rate &amp; dev-&gt;caps.stat_rate_support))
 			--ah-&gt;av.eth.stat_rate;
 	}
<span class="p_del">-</span>
<span class="p_add">+	ah-&gt;av.eth.sl_tclass_flowlabel |=</span>
<span class="p_add">+			cpu_to_be32((ah_attr-&gt;grh.traffic_class &lt;&lt; 20) |</span>
<span class="p_add">+				    ah_attr-&gt;grh.flow_label);</span>
 	/*
 	 * HW requires multicast LID so we just choose one.
 	 */
<span class="p_chunk">@@ -105,7 +107,7 @@</span> <span class="p_context"> static struct ib_ah *create_iboe_ah(struct ib_pd *pd, struct ib_ah_attr *ah_attr</span>
 		ah-&gt;av.ib.dlid = cpu_to_be16(0xc000);
 
 	memcpy(ah-&gt;av.eth.dgid, ah_attr-&gt;grh.dgid.raw, 16);
<span class="p_del">-	ah-&gt;av.eth.sl_tclass_flowlabel = cpu_to_be32(ah_attr-&gt;sl &lt;&lt; 29);</span>
<span class="p_add">+	ah-&gt;av.eth.sl_tclass_flowlabel |= cpu_to_be32(ah_attr-&gt;sl &lt;&lt; 29);</span>
 
 	return &amp;ah-&gt;ibah;
 }
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/main.c b/drivers/infiniband/hw/mlx4/main.c</span>
<span class="p_header">index 85c47a0e524c..1397da73f636 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/main.c</span>
<span class="p_chunk">@@ -212,6 +212,7 @@</span> <span class="p_context"> static int mlx4_ib_query_device(struct ib_device *ibdev,</span>
 	props-&gt;max_total_mcast_qp_attach = props-&gt;max_mcast_qp_attach *
 					   props-&gt;max_mcast_grp;
 	props-&gt;max_map_per_fmr = dev-&gt;dev-&gt;caps.max_fmr_maps;
<span class="p_add">+	props-&gt;max_ah = INT_MAX;</span>
 
 out:
 	kfree(in_mad);
<span class="p_chunk">@@ -345,9 +346,11 @@</span> <span class="p_context"> static int eth_link_query_port(struct ib_device *ibdev, u8 port,</span>
 	if (err)
 		goto out;
 
<span class="p_del">-	props-&gt;active_width	=  (((u8 *)mailbox-&gt;buf)[5] == 0x40) ?</span>
<span class="p_del">-						IB_WIDTH_4X : IB_WIDTH_1X;</span>
<span class="p_del">-	props-&gt;active_speed	= IB_SPEED_QDR;</span>
<span class="p_add">+	props-&gt;active_width	=  (((u8 *)mailbox-&gt;buf)[5] == 0x40) ||</span>
<span class="p_add">+				   (((u8 *)mailbox-&gt;buf)[5] == 0x20 /*56Gb*/) ?</span>
<span class="p_add">+					   IB_WIDTH_4X : IB_WIDTH_1X;</span>
<span class="p_add">+	props-&gt;active_speed	=  (((u8 *)mailbox-&gt;buf)[5] == 0x20 /*56Gb*/) ?</span>
<span class="p_add">+					   IB_SPEED_FDR : IB_SPEED_QDR;</span>
 	props-&gt;port_cap_flags	= IB_PORT_CM_SUP | IB_PORT_IP_BASED_GIDS;
 	props-&gt;gid_tbl_len	= mdev-&gt;dev-&gt;caps.gid_table_len[port];
 	props-&gt;max_msg_sz	= mdev-&gt;dev-&gt;caps.max_msg_sz;
<span class="p_chunk">@@ -2156,14 +2159,19 @@</span> <span class="p_context"> static void *mlx4_ib_add(struct mlx4_dev *dev)</span>
 			goto err_steer_qp_release;
 		}
 
<span class="p_del">-		bitmap_zero(ibdev-&gt;ib_uc_qpns_bitmap, ibdev-&gt;steer_qpn_count);</span>
<span class="p_del">-</span>
<span class="p_del">-		err = mlx4_FLOW_STEERING_IB_UC_QP_RANGE(</span>
<span class="p_del">-				dev, ibdev-&gt;steer_qpn_base,</span>
<span class="p_del">-				ibdev-&gt;steer_qpn_base +</span>
<span class="p_del">-				ibdev-&gt;steer_qpn_count - 1);</span>
<span class="p_del">-		if (err)</span>
<span class="p_del">-			goto err_steer_free_bitmap;</span>
<span class="p_add">+		if (dev-&gt;caps.flags2 &amp; MLX4_DEV_CAP_FLAG2_DMFS_IPOIB) {</span>
<span class="p_add">+			bitmap_zero(ibdev-&gt;ib_uc_qpns_bitmap,</span>
<span class="p_add">+				    ibdev-&gt;steer_qpn_count);</span>
<span class="p_add">+			err = mlx4_FLOW_STEERING_IB_UC_QP_RANGE(</span>
<span class="p_add">+					dev, ibdev-&gt;steer_qpn_base,</span>
<span class="p_add">+					ibdev-&gt;steer_qpn_base +</span>
<span class="p_add">+					ibdev-&gt;steer_qpn_count - 1);</span>
<span class="p_add">+			if (err)</span>
<span class="p_add">+				goto err_steer_free_bitmap;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			bitmap_fill(ibdev-&gt;ib_uc_qpns_bitmap,</span>
<span class="p_add">+				    ibdev-&gt;steer_qpn_count);</span>
<span class="p_add">+		}</span>
 	}
 
 	if (ib_register_device(&amp;ibdev-&gt;ib_dev, NULL))
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">index 6f50a21331ed..3e1ea0323983 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_chunk">@@ -1153,7 +1153,8 @@</span> <span class="p_context"> int mlx4_ib_destroy_qp(struct ib_qp *qp)</span>
 	if (is_qp0(dev, mqp))
 		mlx4_CLOSE_PORT(dev-&gt;dev, mqp-&gt;port);
 
<span class="p_del">-	if (dev-&gt;qp1_proxy[mqp-&gt;port - 1] == mqp) {</span>
<span class="p_add">+	if (mqp-&gt;mlx4_ib_qp_type == MLX4_IB_QPT_PROXY_GSI &amp;&amp;</span>
<span class="p_add">+	    dev-&gt;qp1_proxy[mqp-&gt;port - 1] == mqp) {</span>
 		mutex_lock(&amp;dev-&gt;qp1_proxy_lock[mqp-&gt;port - 1]);
 		dev-&gt;qp1_proxy[mqp-&gt;port - 1] = NULL;
 		mutex_unlock(&amp;dev-&gt;qp1_proxy_lock[mqp-&gt;port - 1]);
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">index cad8cab43559..cb938822a91c 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_chunk">@@ -319,6 +319,7 @@</span> <span class="p_context"> static int mlx5_ib_query_device(struct ib_device *ibdev,</span>
 	props-&gt;max_total_mcast_qp_attach = props-&gt;max_mcast_qp_attach *
 					   props-&gt;max_mcast_grp;
 	props-&gt;max_map_per_fmr = INT_MAX; /* no limit in ConnectIB */
<span class="p_add">+	props-&gt;max_ah = INT_MAX;</span>
 
 out:
 	kfree(in_mad);
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/mr.c b/drivers/infiniband/hw/mlx5/mr.c</span>
<span class="p_header">index bf75b943bc31..d1fd8b8f65f0 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/mr.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/mr.c</span>
<span class="p_chunk">@@ -590,6 +590,33 @@</span> <span class="p_context"> int mlx5_mr_cache_init(struct mlx5_ib_dev *dev)</span>
 	return 0;
 }
 
<span class="p_add">+static void wait_for_async_commands(struct mlx5_ib_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mlx5_mr_cache *cache = &amp;dev-&gt;cache;</span>
<span class="p_add">+	struct mlx5_cache_ent *ent;</span>
<span class="p_add">+	int total = 0;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	int j;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; MAX_MR_CACHE_ENTRIES; i++) {</span>
<span class="p_add">+		ent = &amp;cache-&gt;ent[i];</span>
<span class="p_add">+		for (j = 0 ; j &lt; 1000; j++) {</span>
<span class="p_add">+			if (!ent-&gt;pending)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			msleep(50);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	for (i = 0; i &lt; MAX_MR_CACHE_ENTRIES; i++) {</span>
<span class="p_add">+		ent = &amp;cache-&gt;ent[i];</span>
<span class="p_add">+		total += ent-&gt;pending;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (total)</span>
<span class="p_add">+		mlx5_ib_warn(dev, &quot;aborted while there are %d pending mr requests\n&quot;, total);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		mlx5_ib_warn(dev, &quot;done with all pending requests\n&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int mlx5_mr_cache_cleanup(struct mlx5_ib_dev *dev)
 {
 	int i;
<span class="p_chunk">@@ -603,6 +630,7 @@</span> <span class="p_context"> int mlx5_mr_cache_cleanup(struct mlx5_ib_dev *dev)</span>
 		clean_keys(dev, i);
 
 	destroy_workqueue(dev-&gt;cache.wq);
<span class="p_add">+	wait_for_async_commands(dev);</span>
 	del_timer_sync(&amp;dev-&gt;delay_timer);
 
 	return 0;
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_cm.c b/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_header">index 9bf0c8f59d54..6f29bd05441f 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_chunk">@@ -1038,8 +1038,6 @@</span> <span class="p_context"> static struct ib_qp *ipoib_cm_create_tx_qp(struct net_device *dev, struct ipoib_</span>
 
 	tx_qp = ib_create_qp(priv-&gt;pd, &amp;attr);
 	if (PTR_ERR(tx_qp) == -EINVAL) {
<span class="p_del">-		ipoib_warn(priv, &quot;can&#39;t use GFP_NOIO for QPs on device %s, using GFP_KERNEL\n&quot;,</span>
<span class="p_del">-			   priv-&gt;ca-&gt;name);</span>
 		attr.create_flags &amp;= ~IB_QP_CREATE_USE_GFP_NOIO;
 		tx_qp = ib_create_qp(priv-&gt;pd, &amp;attr);
 	}
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c b/drivers/infiniband/ulp/ipoib/ipoib_multicast.c</span>
<span class="p_header">index d4e005720d01..0b0f2c77d74d 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_multicast.c</span>
<span class="p_chunk">@@ -523,8 +523,11 @@</span> <span class="p_context"> void ipoib_mcast_join_task(struct work_struct *work)</span>
 	if (!test_bit(IPOIB_MCAST_RUN, &amp;priv-&gt;flags))
 		return;
 
<span class="p_del">-	if (ib_query_port(priv-&gt;ca, priv-&gt;port, &amp;port_attr) ||</span>
<span class="p_del">-	    port_attr.state != IB_PORT_ACTIVE) {</span>
<span class="p_add">+	if (ib_query_port(priv-&gt;ca, priv-&gt;port, &amp;port_attr)) {</span>
<span class="p_add">+		ipoib_dbg(priv, &quot;ib_query_port() failed\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (port_attr.state != IB_PORT_ACTIVE) {</span>
 		ipoib_dbg(priv, &quot;port state is not ACTIVE (state = %d) suspending join task\n&quot;,
 			  port_attr.state);
 		return;
<span class="p_header">diff --git a/drivers/input/serio/i8042-x86ia64io.h b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">index ccb36fb565de..3f3c517f2039 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_chunk">@@ -211,6 +211,12 @@</span> <span class="p_context"> static const struct dmi_system_id __initconst i8042_dmi_noloop_table[] = {</span>
 			DMI_MATCH(DMI_PRODUCT_VERSION, &quot;Rev 1&quot;),
 		},
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;PEGATRON CORPORATION&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;C15B&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 	{ }
 };
 
<span class="p_header">diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c</span>
<span class="p_header">index 76c71ecba656..07af55cc2dcc 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu.c</span>
<span class="p_chunk">@@ -1044,7 +1044,7 @@</span> <span class="p_context"> again:</span>
 	next_tail = (tail + sizeof(*cmd)) % iommu-&gt;cmd_buf_size;
 	left      = (head - next_tail) % iommu-&gt;cmd_buf_size;
 
<span class="p_del">-	if (left &lt;= 2) {</span>
<span class="p_add">+	if (left &lt;= 0x20) {</span>
 		struct iommu_cmd sync_cmd;
 		volatile u64 sem = 0;
 		int ret;
<span class="p_header">diff --git a/drivers/isdn/hardware/eicon/message.c b/drivers/isdn/hardware/eicon/message.c</span>
<span class="p_header">index a82e542ffc21..fecbf1d2f60b 100644</span>
<span class="p_header">--- a/drivers/isdn/hardware/eicon/message.c</span>
<span class="p_header">+++ b/drivers/isdn/hardware/eicon/message.c</span>
<span class="p_chunk">@@ -11304,7 +11304,8 @@</span> <span class="p_context"> static void mixer_notify_update(PLCI *plci, byte others)</span>
 				((CAPI_MSG *) msg)-&gt;header.ncci = 0;
 				((CAPI_MSG *) msg)-&gt;info.facility_req.Selector = SELECTOR_LINE_INTERCONNECT;
 				((CAPI_MSG *) msg)-&gt;info.facility_req.structs[0] = 3;
<span class="p_del">-				PUT_WORD(&amp;(((CAPI_MSG *) msg)-&gt;info.facility_req.structs[1]), LI_REQ_SILENT_UPDATE);</span>
<span class="p_add">+				((CAPI_MSG *) msg)-&gt;info.facility_req.structs[1] = LI_REQ_SILENT_UPDATE &amp; 0xff;</span>
<span class="p_add">+				((CAPI_MSG *) msg)-&gt;info.facility_req.structs[2] = LI_REQ_SILENT_UPDATE &gt;&gt; 8;</span>
 				((CAPI_MSG *) msg)-&gt;info.facility_req.structs[3] = 0;
 				w = api_put(notify_plci-&gt;appl, (CAPI_MSG *) msg);
 				if (w != _QUEUE_FULL)
<span class="p_header">diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c</span>
<span class="p_header">index 34e7db1e7304..c43187b4dc0e 100644</span>
<span class="p_header">--- a/drivers/md/dm-crypt.c</span>
<span class="p_header">+++ b/drivers/md/dm-crypt.c</span>
<span class="p_chunk">@@ -1449,12 +1449,15 @@</span> <span class="p_context"> static int crypt_set_key(struct crypt_config *cc, char *key)</span>
 	if (!cc-&gt;key_size &amp;&amp; strcmp(key, &quot;-&quot;))
 		goto out;
 
<span class="p_add">+	/* clear the flag since following operations may invalidate previously valid key */</span>
<span class="p_add">+	clear_bit(DM_CRYPT_KEY_VALID, &amp;cc-&gt;flags);</span>
<span class="p_add">+</span>
 	if (cc-&gt;key_size &amp;&amp; crypt_decode_key(cc-&gt;key, key, cc-&gt;key_size) &lt; 0)
 		goto out;
 
<span class="p_del">-	set_bit(DM_CRYPT_KEY_VALID, &amp;cc-&gt;flags);</span>
<span class="p_del">-</span>
 	r = crypt_setkey_allcpus(cc);
<span class="p_add">+	if (!r)</span>
<span class="p_add">+		set_bit(DM_CRYPT_KEY_VALID, &amp;cc-&gt;flags);</span>
 
 out:
 	/* Hex key string not needed after here, so wipe it. */
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index 35caa4c17c3d..d043e50ebea7 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -868,6 +868,9 @@</span> <span class="p_context"> static void end_clone_bio(struct bio *clone, int error)</span>
  */
 static void rq_completed(struct mapped_device *md, int rw, int run_queue)
 {
<span class="p_add">+	struct request_queue *q = md-&gt;queue;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
 	atomic_dec(&amp;md-&gt;pending[rw]);
 
 	/* nudge anyone waiting on suspend queue */
<span class="p_chunk">@@ -880,8 +883,11 @@</span> <span class="p_context"> static void rq_completed(struct mapped_device *md, int rw, int run_queue)</span>
 	 * back into -&gt;request_fn() could deadlock attempting to grab the
 	 * queue lock again.
 	 */
<span class="p_del">-	if (run_queue)</span>
<span class="p_del">-		blk_run_queue_async(md-&gt;queue);</span>
<span class="p_add">+	if (run_queue) {</span>
<span class="p_add">+		spin_lock_irqsave(q-&gt;queue_lock, flags);</span>
<span class="p_add">+		blk_run_queue_async(q);</span>
<span class="p_add">+		spin_unlock_irqrestore(q-&gt;queue_lock, flags);</span>
<span class="p_add">+	}</span>
 
 	/*
 	 * dm_put() must be at the end of this function. See the comment above
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index 60d57bad30bb..4db092cf3a1d 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -6453,7 +6453,7 @@</span> <span class="p_context"> static int md_ioctl(struct block_device *bdev, fmode_t mode,</span>
 		/* need to ensure recovery thread has run */
 		wait_event_interruptible_timeout(mddev-&gt;sb_wait,
 						 !test_bit(MD_RECOVERY_NEEDED,
<span class="p_del">-							   &amp;mddev-&gt;flags),</span>
<span class="p_add">+							   &amp;mddev-&gt;recovery),</span>
 						 msecs_to_jiffies(5000));
 	if (cmd == STOP_ARRAY || cmd == STOP_ARRAY_RO) {
 		/* Need to flush page cache, and ensure no-one else opens
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-space-map-metadata.c b/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_header">index 032ee39a0e9b..8114a29839c4 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_chunk">@@ -773,17 +773,15 @@</span> <span class="p_context"> int dm_sm_metadata_create(struct dm_space_map *sm,</span>
 	memcpy(&amp;smm-&gt;sm, &amp;bootstrap_ops, sizeof(smm-&gt;sm));
 
 	r = sm_ll_new_metadata(&amp;smm-&gt;ll, tm);
<span class="p_add">+	if (!r) {</span>
<span class="p_add">+		if (nr_blocks &gt; DM_SM_METADATA_MAX_BLOCKS)</span>
<span class="p_add">+			nr_blocks = DM_SM_METADATA_MAX_BLOCKS;</span>
<span class="p_add">+		r = sm_ll_extend(&amp;smm-&gt;ll, nr_blocks);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	memcpy(&amp;smm-&gt;sm, &amp;ops, sizeof(smm-&gt;sm));</span>
 	if (r)
 		return r;
 
<span class="p_del">-	if (nr_blocks &gt; DM_SM_METADATA_MAX_BLOCKS)</span>
<span class="p_del">-		nr_blocks = DM_SM_METADATA_MAX_BLOCKS;</span>
<span class="p_del">-	r = sm_ll_extend(&amp;smm-&gt;ll, nr_blocks);</span>
<span class="p_del">-	if (r)</span>
<span class="p_del">-		return r;</span>
<span class="p_del">-</span>
<span class="p_del">-	memcpy(&amp;smm-&gt;sm, &amp;ops, sizeof(smm-&gt;sm));</span>
<span class="p_del">-</span>
 	/*
 	 * Now we need to update the newly created data structures with the
 	 * allocated blocks that they were built from.
<span class="p_header">diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c</span>
<span class="p_header">index 9d9d757a3488..63a094166138 100644</span>
<span class="p_header">--- a/drivers/md/raid5.c</span>
<span class="p_header">+++ b/drivers/md/raid5.c</span>
<span class="p_chunk">@@ -6222,6 +6222,15 @@</span> <span class="p_context"> static int run(struct mddev *mddev)</span>
 			stripe = (stripe | (stripe-1)) + 1;
 		mddev-&gt;queue-&gt;limits.discard_alignment = stripe;
 		mddev-&gt;queue-&gt;limits.discard_granularity = stripe;
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We use 16-bit counter of active stripes in bi_phys_segments</span>
<span class="p_add">+		 * (minus one for over-loaded initialization)</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		blk_queue_max_hw_sectors(mddev-&gt;queue, 0xfffe * STRIPE_SECTORS);</span>
<span class="p_add">+		blk_queue_max_discard_sectors(mddev-&gt;queue,</span>
<span class="p_add">+					      0xfffe * STRIPE_SECTORS);</span>
<span class="p_add">+</span>
 		/*
 		 * unaligned part of discard request will be ignored, so can&#39;t
 		 * guarantee discard_zeroes_data
<span class="p_header">diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig</span>
<span class="p_header">index 441053be7f55..42be1e944b88 100644</span>
<span class="p_header">--- a/drivers/media/i2c/Kconfig</span>
<span class="p_header">+++ b/drivers/media/i2c/Kconfig</span>
<span class="p_chunk">@@ -590,6 +590,7 @@</span> <span class="p_context"> config VIDEO_S5K6A3</span>
 config VIDEO_S5K4ECGX
         tristate &quot;Samsung S5K4ECGX sensor support&quot;
         depends on I2C &amp;&amp; VIDEO_V4L2 &amp;&amp; VIDEO_V4L2_SUBDEV_API
<span class="p_add">+	select CRC32</span>
         ---help---
           This is a V4L2 sensor-level driver for Samsung S5K4ECGX 5M
           camera sensor with an embedded SoC image signal processor.
<span class="p_header">diff --git a/drivers/media/platform/davinci/vpfe_capture.c b/drivers/media/platform/davinci/vpfe_capture.c</span>
<span class="p_header">index a51bda2fb637..ff10c2e90a5a 100644</span>
<span class="p_header">--- a/drivers/media/platform/davinci/vpfe_capture.c</span>
<span class="p_header">+++ b/drivers/media/platform/davinci/vpfe_capture.c</span>
<span class="p_chunk">@@ -1967,6 +1967,7 @@</span> <span class="p_context"> static int vpfe_probe(struct platform_device *pdev)</span>
 			v4l2_info(&amp;vpfe_dev-&gt;v4l2_dev,
 				  &quot;v4l2 sub device %s register fails\n&quot;,
 				  sdinfo-&gt;name);
<span class="p_add">+			ret = -ENXIO;</span>
 			goto probe_sd_out;
 		}
 	}
<span class="p_header">diff --git a/drivers/media/rc/ite-cir.c b/drivers/media/rc/ite-cir.c</span>
<span class="p_header">index ab24cc6d3655..65740093403e 100644</span>
<span class="p_header">--- a/drivers/media/rc/ite-cir.c</span>
<span class="p_header">+++ b/drivers/media/rc/ite-cir.c</span>
<span class="p_chunk">@@ -263,6 +263,8 @@</span> <span class="p_context"> static void ite_set_carrier_params(struct ite_dev *dev)</span>
 
 			if (allowance &gt; ITE_RXDCR_MAX)
 				allowance = ITE_RXDCR_MAX;
<span class="p_add">+</span>
<span class="p_add">+			use_demodulator = true;</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/media/usb/siano/smsusb.c b/drivers/media/usb/siano/smsusb.c</span>
<span class="p_header">index 89c86ee2b225..dcb8d14e5bf5 100644</span>
<span class="p_header">--- a/drivers/media/usb/siano/smsusb.c</span>
<span class="p_header">+++ b/drivers/media/usb/siano/smsusb.c</span>
<span class="p_chunk">@@ -206,22 +206,30 @@</span> <span class="p_context"> static int smsusb_start_streaming(struct smsusb_device_t *dev)</span>
 static int smsusb_sendrequest(void *context, void *buffer, size_t size)
 {
 	struct smsusb_device_t *dev = (struct smsusb_device_t *) context;
<span class="p_del">-	struct sms_msg_hdr *phdr = (struct sms_msg_hdr *) buffer;</span>
<span class="p_del">-	int dummy;</span>
<span class="p_add">+	struct sms_msg_hdr *phdr;</span>
<span class="p_add">+	int dummy, ret;</span>
 
 	if (dev-&gt;state != SMSUSB_ACTIVE) {
 		sms_debug(&quot;Device not active yet&quot;);
 		return -ENOENT;
 	}
 
<span class="p_add">+	phdr = kmalloc(size, GFP_KERNEL);</span>
<span class="p_add">+	if (!phdr)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	memcpy(phdr, buffer, size);</span>
<span class="p_add">+</span>
 	sms_debug(&quot;sending %s(%d) size: %d&quot;,
 		  smscore_translate_msg(phdr-&gt;msg_type), phdr-&gt;msg_type,
 		  phdr-&gt;msg_length);
 
 	smsendian_handle_tx_message((struct sms_msg_data *) phdr);
<span class="p_del">-	smsendian_handle_message_header((struct sms_msg_hdr *)buffer);</span>
<span class="p_del">-	return usb_bulk_msg(dev-&gt;udev, usb_sndbulkpipe(dev-&gt;udev, 2),</span>
<span class="p_del">-			    buffer, size, &amp;dummy, 1000);</span>
<span class="p_add">+	smsendian_handle_message_header((struct sms_msg_hdr *)phdr);</span>
<span class="p_add">+	ret = usb_bulk_msg(dev-&gt;udev, usb_sndbulkpipe(dev-&gt;udev, 2),</span>
<span class="p_add">+			    phdr, size, &amp;dummy, 1000);</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(phdr);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static char *smsusb1_fw_lkup[] = {
<span class="p_header">diff --git a/drivers/misc/mei/client.c b/drivers/misc/mei/client.c</span>
<span class="p_header">index a4afa996d413..ed845efa8fd4 100644</span>
<span class="p_header">--- a/drivers/misc/mei/client.c</span>
<span class="p_header">+++ b/drivers/misc/mei/client.c</span>
<span class="p_chunk">@@ -819,7 +819,7 @@</span> <span class="p_context"> int mei_cl_irq_write(struct mei_cl *cl, struct mei_cl_cb *cb,</span>
 
 	rets = mei_cl_flow_ctrl_creds(cl);
 	if (rets &lt; 0)
<span class="p_del">-		return rets;</span>
<span class="p_add">+		goto err;</span>
 
 	if (rets == 0) {
 		cl_dbg(dev, cl, &quot;No flow control credentials: not sending.\n&quot;);
<span class="p_chunk">@@ -853,23 +853,27 @@</span> <span class="p_context"> int mei_cl_irq_write(struct mei_cl *cl, struct mei_cl_cb *cb,</span>
 			cb-&gt;request_buffer.size, cb-&gt;buf_idx);
 
 	rets = mei_write_message(dev, &amp;mei_hdr, buf-&gt;data + cb-&gt;buf_idx);
<span class="p_del">-	if (rets) {</span>
<span class="p_del">-		cl-&gt;status = rets;</span>
<span class="p_del">-		list_move_tail(&amp;cb-&gt;list, &amp;cmpl_list-&gt;list);</span>
<span class="p_del">-		return rets;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (rets)</span>
<span class="p_add">+		goto err;</span>
 
 	cl-&gt;status = 0;
 	cl-&gt;writing_state = MEI_WRITING;
 	cb-&gt;buf_idx += mei_hdr.length;
 
 	if (mei_hdr.msg_complete) {
<span class="p_del">-		if (mei_cl_flow_ctrl_reduce(cl))</span>
<span class="p_del">-			return -EIO;</span>
<span class="p_add">+		if (mei_cl_flow_ctrl_reduce(cl)) {</span>
<span class="p_add">+			rets = -EIO;</span>
<span class="p_add">+			goto err;</span>
<span class="p_add">+		}</span>
 		list_move_tail(&amp;cb-&gt;list, &amp;dev-&gt;write_waiting_list.list);
 	}
 
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+err:</span>
<span class="p_add">+	cl-&gt;status = rets;</span>
<span class="p_add">+	list_move_tail(&amp;cb-&gt;list, &amp;cmpl_list-&gt;list);</span>
<span class="p_add">+	return rets;</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c</span>
<span class="p_header">index 094ba8b8dc3a..d87f81f3eae4 100644</span>
<span class="p_header">--- a/drivers/mmc/core/mmc.c</span>
<span class="p_header">+++ b/drivers/mmc/core/mmc.c</span>
<span class="p_chunk">@@ -1391,10 +1391,10 @@</span> <span class="p_context"> static int mmc_init_card(struct mmc_host *host, u32 ocr,</span>
 		err = mmc_select_hs400(card);
 		if (err)
 			goto err;
<span class="p_del">-	} else if (mmc_card_hs(card)) {</span>
<span class="p_add">+	} else {</span>
 		/* Select the desired bus width optionally */
 		err = mmc_select_bus_width(card);
<span class="p_del">-		if (!IS_ERR_VALUE(err)) {</span>
<span class="p_add">+		if (!IS_ERR_VALUE(err) &amp;&amp; mmc_card_hs(card)) {</span>
 			err = mmc_select_hs_ddr(card);
 			if (err)
 				goto err;
<span class="p_header">diff --git a/drivers/mmc/host/mxs-mmc.c b/drivers/mmc/host/mxs-mmc.c</span>
<span class="p_header">index ad32f235bdb8..5bbc0e64bab5 100644</span>
<span class="p_header">--- a/drivers/mmc/host/mxs-mmc.c</span>
<span class="p_header">+++ b/drivers/mmc/host/mxs-mmc.c</span>
<span class="p_chunk">@@ -308,6 +308,9 @@</span> <span class="p_context"> static void mxs_mmc_ac(struct mxs_mmc_host *host)</span>
 	cmd0 = BF_SSP(cmd-&gt;opcode, CMD0_CMD);
 	cmd1 = cmd-&gt;arg;
 
<span class="p_add">+	if (cmd-&gt;opcode == MMC_STOP_TRANSMISSION)</span>
<span class="p_add">+		cmd0 |= BM_SSP_CMD0_APPEND_8CYC;</span>
<span class="p_add">+</span>
 	if (host-&gt;sdio_irq_en) {
 		ctrl0 |= BM_SSP_CTRL0_SDIO_IRQ_CHECK;
 		cmd0 |= BM_SSP_CMD0_CONT_CLKING_EN | BM_SSP_CMD0_SLOW_CLKING_EN;
<span class="p_chunk">@@ -416,8 +419,7 @@</span> <span class="p_context"> static void mxs_mmc_adtc(struct mxs_mmc_host *host)</span>
 		       ssp-&gt;base + HW_SSP_BLOCK_SIZE);
 	}
 
<span class="p_del">-	if ((cmd-&gt;opcode == MMC_STOP_TRANSMISSION) ||</span>
<span class="p_del">-	    (cmd-&gt;opcode == SD_IO_RW_EXTENDED))</span>
<span class="p_add">+	if (cmd-&gt;opcode == SD_IO_RW_EXTENDED)</span>
 		cmd0 |= BM_SSP_CMD0_APPEND_8CYC;
 
 	cmd1 = cmd-&gt;arg;
<span class="p_header">diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c</span>
<span class="p_header">index 5114206df053..79d7a10028be 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci.c</span>
<span class="p_chunk">@@ -1959,7 +1959,27 @@</span> <span class="p_context"> static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)</span>
 			ctrl &amp;= ~SDHCI_CTRL_EXEC_TUNING;
 			sdhci_writew(host, ctrl, SDHCI_HOST_CONTROL2);
 
<span class="p_add">+			sdhci_do_reset(host, SDHCI_RESET_CMD);</span>
<span class="p_add">+			sdhci_do_reset(host, SDHCI_RESET_DATA);</span>
<span class="p_add">+</span>
 			err = -EIO;
<span class="p_add">+</span>
<span class="p_add">+			if (cmd.opcode != MMC_SEND_TUNING_BLOCK_HS200)</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+			sdhci_writel(host, host-&gt;ier, SDHCI_INT_ENABLE);</span>
<span class="p_add">+			sdhci_writel(host, host-&gt;ier, SDHCI_SIGNAL_ENABLE);</span>
<span class="p_add">+</span>
<span class="p_add">+			spin_unlock_irqrestore(&amp;host-&gt;lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+			memset(&amp;cmd, 0, sizeof(cmd));</span>
<span class="p_add">+			cmd.opcode = MMC_STOP_TRANSMISSION;</span>
<span class="p_add">+			cmd.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;</span>
<span class="p_add">+			cmd.busy_timeout = 50;</span>
<span class="p_add">+			mmc_wait_for_cmd(mmc, &amp;cmd, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+			spin_lock_irqsave(&amp;host-&gt;lock, flags);</span>
<span class="p_add">+</span>
 			goto out;
 		}
 
<span class="p_chunk">@@ -2465,7 +2485,8 @@</span> <span class="p_context"> static irqreturn_t sdhci_irq(int irq, void *dev_id)</span>
 			pr_err(&quot;%s: Card is consuming too much power!\n&quot;,
 				mmc_hostname(host-&gt;mmc));
 
<span class="p_del">-		if (intmask &amp; SDHCI_INT_CARD_INT) {</span>
<span class="p_add">+		if ((intmask &amp; SDHCI_INT_CARD_INT) &amp;&amp;</span>
<span class="p_add">+		    (host-&gt;ier &amp; SDHCI_INT_CARD_INT)) {</span>
 			sdhci_enable_sdio_irq_nolock(host, false);
 			host-&gt;thread_isr |= SDHCI_INT_CARD_INT;
 			result = IRQ_WAKE_THREAD;
<span class="p_header">diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig</span>
<span class="p_header">index f1cf503517fd..fa1bb0223a02 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/Kconfig</span>
<span class="p_header">+++ b/drivers/mtd/nand/Kconfig</span>
<span class="p_chunk">@@ -506,7 +506,7 @@</span> <span class="p_context"> config MTD_NAND_FSMC</span>
 	  Flexible Static Memory Controller (FSMC)
 
 config MTD_NAND_XWAY
<span class="p_del">-	tristate &quot;Support for NAND on Lantiq XWAY SoC&quot;</span>
<span class="p_add">+	bool &quot;Support for NAND on Lantiq XWAY SoC&quot;</span>
 	depends on LANTIQ &amp;&amp; SOC_TYPE_XWAY
 	select MTD_NAND_PLATFORM
 	help
<span class="p_header">diff --git a/drivers/net/bonding/bond_netlink.c b/drivers/net/bonding/bond_netlink.c</span>
<span class="p_header">index 8626bc0cb2af..1b7545680eae 100644</span>
<span class="p_header">--- a/drivers/net/bonding/bond_netlink.c</span>
<span class="p_header">+++ b/drivers/net/bonding/bond_netlink.c</span>
<span class="p_chunk">@@ -365,7 +365,11 @@</span> <span class="p_context"> static int bond_newlink(struct net *src_net, struct net_device *bond_dev,</span>
 	if (err &lt; 0)
 		return err;
 
<span class="p_del">-	return register_netdevice(bond_dev);</span>
<span class="p_add">+	err = register_netdevice(bond_dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	netif_carrier_off(bond_dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
 }
 
 static size_t bond_get_size(const struct net_device *bond_dev)
<span class="p_header">diff --git a/drivers/net/can/c_can/c_can_pci.c b/drivers/net/can/c_can/c_can_pci.c</span>
<span class="p_header">index 5d11e0e4225b..b997508ea7c6 100644</span>
<span class="p_header">--- a/drivers/net/can/c_can/c_can_pci.c</span>
<span class="p_header">+++ b/drivers/net/can/c_can/c_can_pci.c</span>
<span class="p_chunk">@@ -161,6 +161,7 @@</span> <span class="p_context"> static int c_can_pci_probe(struct pci_dev *pdev,</span>
 
 	dev-&gt;irq = pdev-&gt;irq;
 	priv-&gt;base = addr;
<span class="p_add">+	priv-&gt;device = &amp;pdev-&gt;dev;</span>
 
 	if (!c_can_pci_data-&gt;freq) {
 		dev_err(&amp;pdev-&gt;dev, &quot;no clock frequency defined\n&quot;);
<span class="p_header">diff --git a/drivers/net/can/ti_hecc.c b/drivers/net/can/ti_hecc.c</span>
<span class="p_header">index 258b9c4856ec..386d2c02e18f 100644</span>
<span class="p_header">--- a/drivers/net/can/ti_hecc.c</span>
<span class="p_header">+++ b/drivers/net/can/ti_hecc.c</span>
<span class="p_chunk">@@ -950,7 +950,12 @@</span> <span class="p_context"> static int ti_hecc_probe(struct platform_device *pdev)</span>
 	netif_napi_add(ndev, &amp;priv-&gt;napi, ti_hecc_rx_poll,
 		HECC_DEF_NAPI_WEIGHT);
 
<span class="p_del">-	clk_enable(priv-&gt;clk);</span>
<span class="p_add">+	err = clk_prepare_enable(priv-&gt;clk);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		dev_err(&amp;pdev-&gt;dev, &quot;clk_prepare_enable() failed\n&quot;);</span>
<span class="p_add">+		goto probe_exit_clk;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	err = register_candev(ndev);
 	if (err) {
 		dev_err(&amp;pdev-&gt;dev, &quot;register_candev() failed\n&quot;);
<span class="p_chunk">@@ -983,7 +988,7 @@</span> <span class="p_context"> static int ti_hecc_remove(struct platform_device *pdev)</span>
 	struct ti_hecc_priv *priv = netdev_priv(ndev);
 
 	unregister_candev(ndev);
<span class="p_del">-	clk_disable(priv-&gt;clk);</span>
<span class="p_add">+	clk_disable_unprepare(priv-&gt;clk);</span>
 	clk_put(priv-&gt;clk);
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	iounmap(priv-&gt;base);
<span class="p_chunk">@@ -1008,7 +1013,7 @@</span> <span class="p_context"> static int ti_hecc_suspend(struct platform_device *pdev, pm_message_t state)</span>
 	hecc_set_bit(priv, HECC_CANMC, HECC_CANMC_PDR);
 	priv-&gt;can.state = CAN_STATE_SLEEPING;
 
<span class="p_del">-	clk_disable(priv-&gt;clk);</span>
<span class="p_add">+	clk_disable_unprepare(priv-&gt;clk);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1017,8 +1022,11 @@</span> <span class="p_context"> static int ti_hecc_resume(struct platform_device *pdev)</span>
 {
 	struct net_device *dev = platform_get_drvdata(pdev);
 	struct ti_hecc_priv *priv = netdev_priv(dev);
<span class="p_add">+	int err;</span>
 
<span class="p_del">-	clk_enable(priv-&gt;clk);</span>
<span class="p_add">+	err = clk_prepare_enable(priv-&gt;clk);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
 
 	hecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_PDR);
 	priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
<span class="p_header">diff --git a/drivers/net/ethernet/atheros/alx/main.c b/drivers/net/ethernet/atheros/alx/main.c</span>
<span class="p_header">index e751b5db0132..04c85b94754f 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/atheros/alx/main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/atheros/alx/main.c</span>
<span class="p_chunk">@@ -86,9 +86,14 @@</span> <span class="p_context"> static int alx_refill_rx_ring(struct alx_priv *alx, gfp_t gfp)</span>
 	while (!cur_buf-&gt;skb &amp;&amp; next != rxq-&gt;read_idx) {
 		struct alx_rfd *rfd = &amp;rxq-&gt;rfd[cur];
 
<span class="p_del">-		skb = __netdev_alloc_skb(alx-&gt;dev, alx-&gt;rxbuf_size, gfp);</span>
<span class="p_add">+		skb = __netdev_alloc_skb(alx-&gt;dev, alx-&gt;rxbuf_size + 64, gfp);</span>
 		if (!skb)
 			break;
<span class="p_add">+</span>
<span class="p_add">+		/* Workround for the HW RX DMA overflow issue */</span>
<span class="p_add">+		if (((unsigned long)skb-&gt;data &amp; 0xfff) == 0xfc0)</span>
<span class="p_add">+			skb_reserve(skb, 64);</span>
<span class="p_add">+</span>
 		dma = dma_map_single(&amp;alx-&gt;hw.pdev-&gt;dev,
 				     skb-&gt;data, alx-&gt;rxbuf_size,
 				     DMA_FROM_DEVICE);
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bcmsysport.c b/drivers/net/ethernet/broadcom/bcmsysport.c</span>
<span class="p_header">index 3cca6047578b..4d762138eb39 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bcmsysport.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bcmsysport.c</span>
<span class="p_chunk">@@ -587,11 +587,8 @@</span> <span class="p_context"> static unsigned int __bcm_sysport_tx_reclaim(struct bcm_sysport_priv *priv,</span>
 	unsigned int c_index, last_c_index, last_tx_cn, num_tx_cbs;
 	unsigned int pkts_compl = 0, bytes_compl = 0;
 	struct bcm_sysport_cb *cb;
<span class="p_del">-	struct netdev_queue *txq;</span>
 	u32 hw_ind;
 
<span class="p_del">-	txq = netdev_get_tx_queue(ndev, ring-&gt;index);</span>
<span class="p_del">-</span>
 	/* Compute how many descriptors have been processed since last call */
 	hw_ind = tdma_readl(priv, TDMA_DESC_RING_PROD_CONS_INDEX(ring-&gt;index));
 	c_index = (hw_ind &gt;&gt; RING_CONS_INDEX_SHIFT) &amp; RING_CONS_INDEX_MASK;
<span class="p_chunk">@@ -622,9 +619,6 @@</span> <span class="p_context"> static unsigned int __bcm_sysport_tx_reclaim(struct bcm_sysport_priv *priv,</span>
 
 	ring-&gt;c_index = c_index;
 
<span class="p_del">-	if (netif_tx_queue_stopped(txq) &amp;&amp; pkts_compl)</span>
<span class="p_del">-		netif_tx_wake_queue(txq);</span>
<span class="p_del">-</span>
 	netif_dbg(priv, tx_done, ndev,
 			&quot;ring=%d c_index=%d pkts_compl=%d, bytes_compl=%d\n&quot;,
 			ring-&gt;index, ring-&gt;c_index, pkts_compl, bytes_compl);
<span class="p_chunk">@@ -636,16 +630,33 @@</span> <span class="p_context"> static unsigned int __bcm_sysport_tx_reclaim(struct bcm_sysport_priv *priv,</span>
 static unsigned int bcm_sysport_tx_reclaim(struct bcm_sysport_priv *priv,
 					   struct bcm_sysport_tx_ring *ring)
 {
<span class="p_add">+	struct netdev_queue *txq;</span>
 	unsigned int released;
 	unsigned long flags;
 
<span class="p_add">+	txq = netdev_get_tx_queue(priv-&gt;netdev, ring-&gt;index);</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;ring-&gt;lock, flags);
 	released = __bcm_sysport_tx_reclaim(priv, ring);
<span class="p_add">+	if (released)</span>
<span class="p_add">+		netif_tx_wake_queue(txq);</span>
<span class="p_add">+</span>
 	spin_unlock_irqrestore(&amp;ring-&gt;lock, flags);
 
 	return released;
 }
 
<span class="p_add">+/* Locked version of the per-ring TX reclaim, but does not wake the queue */</span>
<span class="p_add">+static void bcm_sysport_tx_clean(struct bcm_sysport_priv *priv,</span>
<span class="p_add">+				 struct bcm_sysport_tx_ring *ring)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;ring-&gt;lock, flags);</span>
<span class="p_add">+	__bcm_sysport_tx_reclaim(priv, ring);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;ring-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int bcm_sysport_tx_poll(struct napi_struct *napi, int budget)
 {
 	struct bcm_sysport_tx_ring *ring =
<span class="p_chunk">@@ -843,15 +854,6 @@</span> <span class="p_context"> static netdev_tx_t bcm_sysport_xmit(struct sk_buff *skb,</span>
 		goto out;
 	}
 
<span class="p_del">-	/* Insert TSB and checksum infos */</span>
<span class="p_del">-	if (priv-&gt;tsb_en) {</span>
<span class="p_del">-		skb = bcm_sysport_insert_tsb(skb, dev);</span>
<span class="p_del">-		if (!skb) {</span>
<span class="p_del">-			ret = NETDEV_TX_OK;</span>
<span class="p_del">-			goto out;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	/* The Ethernet switch we are interfaced with needs packets to be at
 	 * least 64 bytes (including FCS) otherwise they will be discarded when
 	 * they enter the switch port logic. When Broadcom tags are enabled, we
<span class="p_chunk">@@ -864,6 +866,15 @@</span> <span class="p_context"> static netdev_tx_t bcm_sysport_xmit(struct sk_buff *skb,</span>
 		goto out;
 	}
 
<span class="p_add">+	/* Insert TSB and checksum infos */</span>
<span class="p_add">+	if (priv-&gt;tsb_en) {</span>
<span class="p_add">+		skb = bcm_sysport_insert_tsb(skb, dev);</span>
<span class="p_add">+		if (!skb) {</span>
<span class="p_add">+			ret = NETDEV_TX_OK;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	skb_len = skb-&gt;len &lt; ETH_ZLEN + ENET_BRCM_TAG_LEN ?
 			ETH_ZLEN + ENET_BRCM_TAG_LEN : skb-&gt;len;
 
<span class="p_chunk">@@ -1072,7 +1083,7 @@</span> <span class="p_context"> static void bcm_sysport_fini_tx_ring(struct bcm_sysport_priv *priv,</span>
 	napi_disable(&amp;ring-&gt;napi);
 	netif_napi_del(&amp;ring-&gt;napi);
 
<span class="p_del">-	bcm_sysport_tx_reclaim(priv, ring);</span>
<span class="p_add">+	bcm_sysport_tx_clean(priv, ring);</span>
 
 	kfree(ring-&gt;cbs);
 	ring-&gt;cbs = NULL;
<span class="p_header">diff --git a/drivers/net/ethernet/cisco/enic/enic_main.c b/drivers/net/ethernet/cisco/enic/enic_main.c</span>
<span class="p_header">index fb9708d4b8b5..720eed57d255 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/cisco/enic/enic_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/cisco/enic/enic_main.c</span>
<span class="p_chunk">@@ -1033,12 +1033,18 @@</span> <span class="p_context"> static void enic_rq_indicate_buf(struct vnic_rq *rq,</span>
 		skb-&gt;protocol = eth_type_trans(skb, netdev);
 		skb_record_rx_queue(skb, q_number);
 		if (netdev-&gt;features &amp; NETIF_F_RXHASH) {
<span class="p_del">-			skb_set_hash(skb, rss_hash,</span>
<span class="p_del">-				     (rss_type &amp;</span>
<span class="p_del">-				      (NIC_CFG_RSS_HASH_TYPE_TCP_IPV6_EX |</span>
<span class="p_del">-				       NIC_CFG_RSS_HASH_TYPE_TCP_IPV6 |</span>
<span class="p_del">-				       NIC_CFG_RSS_HASH_TYPE_TCP_IPV4)) ?</span>
<span class="p_del">-				     PKT_HASH_TYPE_L4 : PKT_HASH_TYPE_L3);</span>
<span class="p_add">+			switch (rss_type) {</span>
<span class="p_add">+			case CQ_ENET_RQ_DESC_RSS_TYPE_TCP_IPv4:</span>
<span class="p_add">+			case CQ_ENET_RQ_DESC_RSS_TYPE_TCP_IPv6:</span>
<span class="p_add">+			case CQ_ENET_RQ_DESC_RSS_TYPE_TCP_IPv6_EX:</span>
<span class="p_add">+				skb_set_hash(skb, rss_hash, PKT_HASH_TYPE_L4);</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			case CQ_ENET_RQ_DESC_RSS_TYPE_IPv4:</span>
<span class="p_add">+			case CQ_ENET_RQ_DESC_RSS_TYPE_IPv6:</span>
<span class="p_add">+			case CQ_ENET_RQ_DESC_RSS_TYPE_IPv6_EX:</span>
<span class="p_add">+				skb_set_hash(skb, rss_hash, PKT_HASH_TYPE_L3);</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
 		}
 
 		/* Hardware does not provide whole packet checksum. It only
<span class="p_header">diff --git a/drivers/net/ethernet/emulex/benet/be_cmds.c b/drivers/net/ethernet/emulex/benet/be_cmds.c</span>
<span class="p_header">index f4ea3490f446..8dc7f7221fa1 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/emulex/benet/be_cmds.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/emulex/benet/be_cmds.c</span>
<span class="p_chunk">@@ -1008,7 +1008,7 @@</span> <span class="p_context"> int be_cmd_pmac_add(struct be_adapter *adapter, u8 *mac_addr,</span>
 err:
 	spin_unlock_bh(&amp;adapter-&gt;mcc_lock);
 
<span class="p_del">-	 if (status == MCC_STATUS_UNAUTHORIZED_REQUEST)</span>
<span class="p_add">+	 if (base_status(status) == MCC_STATUS_UNAUTHORIZED_REQUEST)</span>
 		status = -EPERM;
 
 	return status;
<span class="p_header">diff --git a/drivers/net/ethernet/korina.c b/drivers/net/ethernet/korina.c</span>
<span class="p_header">index d74f5f4e5782..07eabf72c480 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/korina.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/korina.c</span>
<span class="p_chunk">@@ -900,10 +900,10 @@</span> <span class="p_context"> static void korina_restart_task(struct work_struct *work)</span>
 				DMA_STAT_DONE | DMA_STAT_HALT | DMA_STAT_ERR,
 				&amp;lp-&gt;rx_dma_regs-&gt;dmasm);
 
<span class="p_del">-	korina_free_ring(dev);</span>
<span class="p_del">-</span>
 	napi_disable(&amp;lp-&gt;napi);
 
<span class="p_add">+	korina_free_ring(dev);</span>
<span class="p_add">+</span>
 	if (korina_init(dev) &lt; 0) {
 		printk(KERN_ERR &quot;%s: cannot restart device\n&quot;, dev-&gt;name);
 		return;
<span class="p_chunk">@@ -1064,12 +1064,12 @@</span> <span class="p_context"> static int korina_close(struct net_device *dev)</span>
 	tmp = tmp | DMA_STAT_DONE | DMA_STAT_HALT | DMA_STAT_ERR;
 	writel(tmp, &amp;lp-&gt;rx_dma_regs-&gt;dmasm);
 
<span class="p_del">-	korina_free_ring(dev);</span>
<span class="p_del">-</span>
 	napi_disable(&amp;lp-&gt;napi);
 
 	cancel_work_sync(&amp;lp-&gt;restart_task);
 
<span class="p_add">+	korina_free_ring(dev);</span>
<span class="p_add">+</span>
 	free_irq(lp-&gt;rx_irq, dev);
 	free_irq(lp-&gt;tx_irq, dev);
 	free_irq(lp-&gt;ovr_irq, dev);
<span class="p_header">diff --git a/drivers/net/ethernet/marvell/sky2.c b/drivers/net/ethernet/marvell/sky2.c</span>
<span class="p_header">index 69693384b58c..d72c33cbaeeb 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/marvell/sky2.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/marvell/sky2.c</span>
<span class="p_chunk">@@ -5211,6 +5211,19 @@</span> <span class="p_context"> static SIMPLE_DEV_PM_OPS(sky2_pm_ops, sky2_suspend, sky2_resume);</span>
 
 static void sky2_shutdown(struct pci_dev *pdev)
 {
<span class="p_add">+	struct sky2_hw *hw = pci_get_drvdata(pdev);</span>
<span class="p_add">+	int port;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (port = 0; port &lt; hw-&gt;ports; port++) {</span>
<span class="p_add">+		struct net_device *ndev = hw-&gt;dev[port];</span>
<span class="p_add">+</span>
<span class="p_add">+		rtnl_lock();</span>
<span class="p_add">+		if (netif_running(ndev)) {</span>
<span class="p_add">+			dev_close(ndev);</span>
<span class="p_add">+			netif_device_detach(ndev);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		rtnl_unlock();</span>
<span class="p_add">+	}</span>
 	sky2_suspend(&amp;pdev-&gt;dev);
 	pci_wake_from_d3(pdev, device_may_wakeup(&amp;pdev-&gt;dev));
 	pci_set_power_state(pdev, PCI_D3hot);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/cq.c b/drivers/net/ethernet/mellanox/mlx4/cq.c</span>
<span class="p_header">index 56022d647837..6bb0521b09a3 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/cq.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/cq.c</span>
<span class="p_chunk">@@ -56,13 +56,19 @@</span> <span class="p_context"> void mlx4_cq_completion(struct mlx4_dev *dev, u32 cqn)</span>
 {
 	struct mlx4_cq *cq;
 
<span class="p_add">+	rcu_read_lock();</span>
 	cq = radix_tree_lookup(&amp;mlx4_priv(dev)-&gt;cq_table.tree,
 			       cqn &amp; (dev-&gt;caps.num_cqs - 1));
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+</span>
 	if (!cq) {
 		mlx4_dbg(dev, &quot;Completion event for bogus CQ %08x\n&quot;, cqn);
 		return;
 	}
 
<span class="p_add">+	/* Acessing the CQ outside of rcu_read_lock is safe, because</span>
<span class="p_add">+	 * the CQ is freed only after interrupt handling is completed.</span>
<span class="p_add">+	 */</span>
 	++cq-&gt;arm_sn;
 
 	cq-&gt;comp(cq);
<span class="p_chunk">@@ -73,23 +79,19 @@</span> <span class="p_context"> void mlx4_cq_event(struct mlx4_dev *dev, u32 cqn, int event_type)</span>
 	struct mlx4_cq_table *cq_table = &amp;mlx4_priv(dev)-&gt;cq_table;
 	struct mlx4_cq *cq;
 
<span class="p_del">-	spin_lock(&amp;cq_table-&gt;lock);</span>
<span class="p_del">-</span>
<span class="p_add">+	rcu_read_lock();</span>
 	cq = radix_tree_lookup(&amp;cq_table-&gt;tree, cqn &amp; (dev-&gt;caps.num_cqs - 1));
<span class="p_del">-	if (cq)</span>
<span class="p_del">-		atomic_inc(&amp;cq-&gt;refcount);</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_unlock(&amp;cq_table-&gt;lock);</span>
<span class="p_add">+	rcu_read_unlock();</span>
 
 	if (!cq) {
<span class="p_del">-		mlx4_warn(dev, &quot;Async event for bogus CQ %08x\n&quot;, cqn);</span>
<span class="p_add">+		mlx4_dbg(dev, &quot;Async event for bogus CQ %08x\n&quot;, cqn);</span>
 		return;
 	}
 
<span class="p_add">+	/* Acessing the CQ outside of rcu_read_lock is safe, because</span>
<span class="p_add">+	 * the CQ is freed only after interrupt handling is completed.</span>
<span class="p_add">+	 */</span>
 	cq-&gt;event(cq, event_type);
<span class="p_del">-</span>
<span class="p_del">-	if (atomic_dec_and_test(&amp;cq-&gt;refcount))</span>
<span class="p_del">-		complete(&amp;cq-&gt;free);</span>
 }
 
 static int mlx4_SW2HW_CQ(struct mlx4_dev *dev, struct mlx4_cmd_mailbox *mailbox,
<span class="p_chunk">@@ -256,9 +258,9 @@</span> <span class="p_context"> int mlx4_cq_alloc(struct mlx4_dev *dev, int nent,</span>
 	if (err)
 		return err;
 
<span class="p_del">-	spin_lock_irq(&amp;cq_table-&gt;lock);</span>
<span class="p_add">+	spin_lock(&amp;cq_table-&gt;lock);</span>
 	err = radix_tree_insert(&amp;cq_table-&gt;tree, cq-&gt;cqn, cq);
<span class="p_del">-	spin_unlock_irq(&amp;cq_table-&gt;lock);</span>
<span class="p_add">+	spin_unlock(&amp;cq_table-&gt;lock);</span>
 	if (err)
 		goto err_icm;
 
<span class="p_chunk">@@ -297,9 +299,9 @@</span> <span class="p_context"> int mlx4_cq_alloc(struct mlx4_dev *dev, int nent,</span>
 	return 0;
 
 err_radix:
<span class="p_del">-	spin_lock_irq(&amp;cq_table-&gt;lock);</span>
<span class="p_add">+	spin_lock(&amp;cq_table-&gt;lock);</span>
 	radix_tree_delete(&amp;cq_table-&gt;tree, cq-&gt;cqn);
<span class="p_del">-	spin_unlock_irq(&amp;cq_table-&gt;lock);</span>
<span class="p_add">+	spin_unlock(&amp;cq_table-&gt;lock);</span>
 
 err_icm:
 	mlx4_cq_free_icm(dev, cq-&gt;cqn);
<span class="p_chunk">@@ -318,11 +320,11 @@</span> <span class="p_context"> void mlx4_cq_free(struct mlx4_dev *dev, struct mlx4_cq *cq)</span>
 	if (err)
 		mlx4_warn(dev, &quot;HW2SW_CQ failed (%d) for CQN %06x\n&quot;, err, cq-&gt;cqn);
 
<span class="p_del">-	synchronize_irq(priv-&gt;eq_table.eq[cq-&gt;vector].irq);</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock_irq(&amp;cq_table-&gt;lock);</span>
<span class="p_add">+	spin_lock(&amp;cq_table-&gt;lock);</span>
 	radix_tree_delete(&amp;cq_table-&gt;tree, cq-&gt;cqn);
<span class="p_del">-	spin_unlock_irq(&amp;cq_table-&gt;lock);</span>
<span class="p_add">+	spin_unlock(&amp;cq_table-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	synchronize_irq(priv-&gt;eq_table.eq[cq-&gt;vector].irq);</span>
 
 	if (atomic_dec_and_test(&amp;cq-&gt;refcount))
 		complete(&amp;cq-&gt;free);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_rx.c b/drivers/net/ethernet/mellanox/mlx4/en_rx.c</span>
<span class="p_header">index 76879a1cca6f..b07f4c0d617b 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_rx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_rx.c</span>
<span class="p_chunk">@@ -437,8 +437,14 @@</span> <span class="p_context"> int mlx4_en_activate_rx_rings(struct mlx4_en_priv *priv)</span>
 		ring-&gt;cqn = priv-&gt;rx_cq[ring_ind]-&gt;mcq.cqn;
 
 		ring-&gt;stride = stride;
<span class="p_del">-		if (ring-&gt;stride &lt;= TXBB_SIZE)</span>
<span class="p_add">+		if (ring-&gt;stride &lt;= TXBB_SIZE) {</span>
<span class="p_add">+			/* Stamp first unused send wqe */</span>
<span class="p_add">+			__be32 *ptr = (__be32 *)ring-&gt;buf;</span>
<span class="p_add">+			__be32 stamp = cpu_to_be32(1 &lt;&lt; STAMP_SHIFT);</span>
<span class="p_add">+			*ptr = stamp;</span>
<span class="p_add">+			/* Move pointer to start of rx section */</span>
 			ring-&gt;buf += TXBB_SIZE;
<span class="p_add">+		}</span>
 
 		ring-&gt;log_stride = ffs(ring-&gt;stride) - 1;
 		ring-&gt;buf_size = ring-&gt;size * ring-&gt;stride;
<span class="p_chunk">@@ -500,8 +506,11 @@</span> <span class="p_context"> void mlx4_en_recover_from_oom(struct mlx4_en_priv *priv)</span>
 		return;
 
 	for (ring = 0; ring &lt; priv-&gt;rx_ring_num; ring++) {
<span class="p_del">-		if (mlx4_en_is_ring_empty(priv-&gt;rx_ring[ring]))</span>
<span class="p_add">+		if (mlx4_en_is_ring_empty(priv-&gt;rx_ring[ring])) {</span>
<span class="p_add">+			local_bh_disable();</span>
 			napi_reschedule(&amp;priv-&gt;rx_cq[ring]-&gt;napi);
<span class="p_add">+			local_bh_enable();</span>
<span class="p_add">+		}</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/eq.c b/drivers/net/ethernet/mellanox/mlx4/eq.c</span>
<span class="p_header">index c26eec5f33c3..e79dbd9ff066 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/eq.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/eq.c</span>
<span class="p_chunk">@@ -506,8 +506,9 @@</span> <span class="p_context"> static int mlx4_eq_int(struct mlx4_dev *dev, struct mlx4_eq *eq)</span>
 			break;
 
 		case MLX4_EVENT_TYPE_SRQ_LIMIT:
<span class="p_del">-			mlx4_dbg(dev, &quot;%s: MLX4_EVENT_TYPE_SRQ_LIMIT\n&quot;,</span>
<span class="p_del">-				 __func__);</span>
<span class="p_add">+			mlx4_dbg(dev, &quot;%s: MLX4_EVENT_TYPE_SRQ_LIMIT. srq_no=0x%x, eq 0x%x\n&quot;,</span>
<span class="p_add">+				 __func__, be32_to_cpu(eqe-&gt;event.srq.srqn),</span>
<span class="p_add">+				 eq-&gt;eqn);</span>
 		case MLX4_EVENT_TYPE_SRQ_CATAS_ERROR:
 			if (mlx4_is_master(dev)) {
 				/* forward only to slave owning the SRQ */
<span class="p_chunk">@@ -522,15 +523,19 @@</span> <span class="p_context"> static int mlx4_eq_int(struct mlx4_dev *dev, struct mlx4_eq *eq)</span>
 						  eq-&gt;eqn, eq-&gt;cons_index, ret);
 					break;
 				}
<span class="p_del">-				mlx4_warn(dev, &quot;%s: slave:%d, srq_no:0x%x, event: %02x(%02x)\n&quot;,</span>
<span class="p_del">-					  __func__, slave,</span>
<span class="p_del">-					  be32_to_cpu(eqe-&gt;event.srq.srqn),</span>
<span class="p_del">-					  eqe-&gt;type, eqe-&gt;subtype);</span>
<span class="p_add">+				if (eqe-&gt;type ==</span>
<span class="p_add">+				    MLX4_EVENT_TYPE_SRQ_CATAS_ERROR)</span>
<span class="p_add">+					mlx4_warn(dev, &quot;%s: slave:%d, srq_no:0x%x, event: %02x(%02x)\n&quot;,</span>
<span class="p_add">+						  __func__, slave,</span>
<span class="p_add">+						  be32_to_cpu(eqe-&gt;event.srq.srqn),</span>
<span class="p_add">+						  eqe-&gt;type, eqe-&gt;subtype);</span>
 
 				if (!ret &amp;&amp; slave != dev-&gt;caps.function) {
<span class="p_del">-					mlx4_warn(dev, &quot;%s: sending event %02x(%02x) to slave:%d\n&quot;,</span>
<span class="p_del">-						  __func__, eqe-&gt;type,</span>
<span class="p_del">-						  eqe-&gt;subtype, slave);</span>
<span class="p_add">+					if (eqe-&gt;type ==</span>
<span class="p_add">+					    MLX4_EVENT_TYPE_SRQ_CATAS_ERROR)</span>
<span class="p_add">+						mlx4_warn(dev, &quot;%s: sending event %02x(%02x) to slave:%d\n&quot;,</span>
<span class="p_add">+							  __func__, eqe-&gt;type,</span>
<span class="p_add">+							  eqe-&gt;subtype, slave);</span>
 					mlx4_slave_event(dev, slave, eqe);
 					break;
 				}
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/icm.c b/drivers/net/ethernet/mellanox/mlx4/icm.c</span>
<span class="p_header">index 97c9b1db1d27..27f22cd3b071 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/icm.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/icm.c</span>
<span class="p_chunk">@@ -117,8 +117,13 @@</span> <span class="p_context"> static int mlx4_alloc_icm_coherent(struct device *dev, struct scatterlist *mem,</span>
 	if (!buf)
 		return -ENOMEM;
 
<span class="p_add">+	if (offset_in_page(buf)) {</span>
<span class="p_add">+		dma_free_coherent(dev, PAGE_SIZE &lt;&lt; order,</span>
<span class="p_add">+				  buf, sg_dma_address(mem));</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	sg_set_buf(mem, buf, PAGE_SIZE &lt;&lt; order);
<span class="p_del">-	BUG_ON(mem-&gt;offset);</span>
 	sg_dma_len(mem) = PAGE_SIZE &lt;&lt; order;
 	return 0;
 }
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c b/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c</span>
<span class="p_header">index 90269b3013b6..bee566803b5d 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c</span>
<span class="p_chunk">@@ -2733,6 +2733,9 @@</span> <span class="p_context"> int mlx4_RST2INIT_QP_wrapper(struct mlx4_dev *dev, int slave,</span>
 		put_res(dev, slave, srqn, RES_SRQ);
 		qp-&gt;srq = srq;
 	}
<span class="p_add">+</span>
<span class="p_add">+	/* Save param3 for dynamic changes from VST back to VGT */</span>
<span class="p_add">+	qp-&gt;param3 = qpc-&gt;param3;</span>
 	put_res(dev, slave, rcqn, RES_CQ);
 	put_res(dev, slave, mtt_base, RES_MTT);
 	res_end_move(dev, slave, RES_QP, qpn);
<span class="p_chunk">@@ -3495,7 +3498,6 @@</span> <span class="p_context"> int mlx4_INIT2RTR_QP_wrapper(struct mlx4_dev *dev, int slave,</span>
 	int qpn = vhcr-&gt;in_modifier &amp; 0x7fffff;
 	struct res_qp *qp;
 	u8 orig_sched_queue;
<span class="p_del">-	__be32	orig_param3 = qpc-&gt;param3;</span>
 	u8 orig_vlan_control = qpc-&gt;pri_path.vlan_control;
 	u8 orig_fvl_rx = qpc-&gt;pri_path.fvl_rx;
 	u8 orig_pri_path_fl = qpc-&gt;pri_path.fl;
<span class="p_chunk">@@ -3536,7 +3538,6 @@</span> <span class="p_context"> out:</span>
 	 */
 	if (!err) {
 		qp-&gt;sched_queue = orig_sched_queue;
<span class="p_del">-		qp-&gt;param3	= orig_param3;</span>
 		qp-&gt;vlan_control = orig_vlan_control;
 		qp-&gt;fvl_rx	=  orig_fvl_rx;
 		qp-&gt;pri_path_fl = orig_pri_path_fl;
<span class="p_chunk">@@ -4091,6 +4092,7 @@</span> <span class="p_context"> int mlx4_QP_FLOW_STEERING_DETACH_wrapper(struct mlx4_dev *dev, int slave,</span>
 	int err;
 	struct res_qp *rqp;
 	struct res_fs_rule *rrule;
<span class="p_add">+	int qpn;</span>
 
 	if (dev-&gt;caps.steering_mode !=
 	    MLX4_STEERING_MODE_DEVICE_MANAGED)
<span class="p_chunk">@@ -4099,9 +4101,10 @@</span> <span class="p_context"> int mlx4_QP_FLOW_STEERING_DETACH_wrapper(struct mlx4_dev *dev, int slave,</span>
 	err = get_res(dev, slave, vhcr-&gt;in_param, RES_FS_RULE, &amp;rrule);
 	if (err)
 		return err;
<span class="p_add">+	qpn = rrule-&gt;qpn;</span>
 	/* Release the rule form busy state before removal */
 	put_res(dev, slave, vhcr-&gt;in_param, RES_FS_RULE);
<span class="p_del">-	err = get_res(dev, slave, rrule-&gt;qpn, RES_QP, &amp;rqp);</span>
<span class="p_add">+	err = get_res(dev, slave, qpn, RES_QP, &amp;rqp);</span>
 	if (err)
 		return err;
 
<span class="p_chunk">@@ -4117,7 +4120,7 @@</span> <span class="p_context"> int mlx4_QP_FLOW_STEERING_DETACH_wrapper(struct mlx4_dev *dev, int slave,</span>
 	if (!err)
 		atomic_dec(&amp;rqp-&gt;ref_count);
 out:
<span class="p_del">-	put_res(dev, slave, rrule-&gt;qpn, RES_QP);</span>
<span class="p_add">+	put_res(dev, slave, qpn, RES_QP);</span>
 	return err;
 }
 
<span class="p_header">diff --git a/drivers/net/ethernet/renesas/sh_eth.c b/drivers/net/ethernet/renesas/sh_eth.c</span>
<span class="p_header">index f1ebb1f50f1c..9a03bfd51397 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/renesas/sh_eth.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/renesas/sh_eth.c</span>
<span class="p_chunk">@@ -696,7 +696,7 @@</span> <span class="p_context"> static struct sh_eth_cpu_data sh7734_data = {</span>
 
 	.ecsr_value	= ECSR_ICD | ECSR_MPD,
 	.ecsipr_value	= ECSIPR_LCHNGIP | ECSIPR_ICDIP | ECSIPR_MPDIP,
<span class="p_del">-	.eesipr_value	= DMAC_M_RFRMER | DMAC_M_ECI | 0x003fffff,</span>
<span class="p_add">+	.eesipr_value	= DMAC_M_RFRMER | DMAC_M_ECI | 0x003f07ff,</span>
 
 	.tx_check	= EESR_TC1 | EESR_FTC,
 	.eesr_err_check	= EESR_TWB1 | EESR_TWB | EESR_TABT | EESR_RABT |
<span class="p_chunk">@@ -713,6 +713,7 @@</span> <span class="p_context"> static struct sh_eth_cpu_data sh7734_data = {</span>
 	.tsu		= 1,
 	.hw_crc		= 1,
 	.select_mii	= 1,
<span class="p_add">+	.shift_rd0	= 1,</span>
 };
 
 /* SH7763 */
<span class="p_chunk">@@ -725,7 +726,7 @@</span> <span class="p_context"> static struct sh_eth_cpu_data sh7763_data = {</span>
 
 	.ecsr_value	= ECSR_ICD | ECSR_MPD,
 	.ecsipr_value	= ECSIPR_LCHNGIP | ECSIPR_ICDIP | ECSIPR_MPDIP,
<span class="p_del">-	.eesipr_value	= DMAC_M_RFRMER | DMAC_M_ECI | 0x003fffff,</span>
<span class="p_add">+	.eesipr_value	= DMAC_M_RFRMER | DMAC_M_ECI | 0x003f07ff,</span>
 
 	.tx_check	= EESR_TC1 | EESR_FTC,
 	.eesr_err_check	= EESR_TWB1 | EESR_TWB | EESR_TABT | EESR_RABT |
<span class="p_chunk">@@ -781,6 +782,7 @@</span> <span class="p_context"> static struct sh_eth_cpu_data r8a7740_data = {</span>
 	.rpadir_value   = 2 &lt;&lt; 16,
 	.no_trimd	= 1,
 	.no_ade		= 1,
<span class="p_add">+	.hw_crc		= 1,</span>
 	.tsu		= 1,
 	.select_mii	= 1,
 	.shift_rd0	= 1,
<span class="p_header">diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c</span>
<span class="p_header">index 641086fc14b5..76fd3a2fa742 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c</span>
<span class="p_chunk">@@ -2769,12 +2769,6 @@</span> <span class="p_context"> struct stmmac_priv *stmmac_dvr_probe(struct device *device,</span>
 	spin_lock_init(&amp;priv-&gt;lock);
 	spin_lock_init(&amp;priv-&gt;tx_lock);
 
<span class="p_del">-	ret = register_netdev(ndev);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		pr_err(&quot;%s: ERROR %i registering the device\n&quot;, __func__, ret);</span>
<span class="p_del">-		goto error_netdev_register;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	/* If a specific clk_csr value is passed from the platform
 	 * this means that the CSR Clock Range selection cannot be
 	 * changed at run-time and it is fixed. Viceversa the driver&#39;ll try to
<span class="p_chunk">@@ -2799,11 +2793,21 @@</span> <span class="p_context"> struct stmmac_priv *stmmac_dvr_probe(struct device *device,</span>
 		}
 	}
 
<span class="p_add">+	ret = register_netdev(ndev);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		netdev_err(priv-&gt;dev, &quot;%s: ERROR %i registering the device\n&quot;,</span>
<span class="p_add">+			   __func__, ret);</span>
<span class="p_add">+		goto error_netdev_register;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return priv;
 
<span class="p_del">-error_mdio_register:</span>
<span class="p_del">-	unregister_netdev(ndev);</span>
 error_netdev_register:
<span class="p_add">+	if (priv-&gt;pcs != STMMAC_PCS_RGMII &amp;&amp;</span>
<span class="p_add">+	    priv-&gt;pcs != STMMAC_PCS_TBI &amp;&amp;</span>
<span class="p_add">+	    priv-&gt;pcs != STMMAC_PCS_RTBI)</span>
<span class="p_add">+		stmmac_mdio_unregister(ndev);</span>
<span class="p_add">+error_mdio_register:</span>
 	netif_napi_del(&amp;priv-&gt;napi);
 error_hw_init:
 	clk_disable_unprepare(priv-&gt;stmmac_clk);
<span class="p_header">diff --git a/drivers/net/ethernet/xilinx/xilinx_emaclite.c b/drivers/net/ethernet/xilinx/xilinx_emaclite.c</span>
<span class="p_header">index 8c4aed3053eb..06b5e4132040 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/xilinx/xilinx_emaclite.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/xilinx/xilinx_emaclite.c</span>
<span class="p_chunk">@@ -100,6 +100,14 @@</span> <span class="p_context"></span>
 /* BUFFER_ALIGN(adr) calculates the number of bytes to the next alignment. */
 #define BUFFER_ALIGN(adr) ((ALIGNMENT - ((u32) adr)) % ALIGNMENT)
 
<span class="p_add">+#ifdef __BIG_ENDIAN</span>
<span class="p_add">+#define xemaclite_readl		ioread32be</span>
<span class="p_add">+#define xemaclite_writel	iowrite32be</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define xemaclite_readl		ioread32</span>
<span class="p_add">+#define xemaclite_writel	iowrite32</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /**
  * struct net_local - Our private per device data
  * @ndev:		instance of the network device
<span class="p_chunk">@@ -158,15 +166,15 @@</span> <span class="p_context"> static void xemaclite_enable_interrupts(struct net_local *drvdata)</span>
 	u32 reg_data;
 
 	/* Enable the Tx interrupts for the first Buffer */
<span class="p_del">-	reg_data = __raw_readl(drvdata-&gt;base_addr + XEL_TSR_OFFSET);</span>
<span class="p_del">-	__raw_writel(reg_data | XEL_TSR_XMIT_IE_MASK,</span>
<span class="p_del">-		     drvdata-&gt;base_addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+	reg_data = xemaclite_readl(drvdata-&gt;base_addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(reg_data | XEL_TSR_XMIT_IE_MASK,</span>
<span class="p_add">+			 drvdata-&gt;base_addr + XEL_TSR_OFFSET);</span>
 
 	/* Enable the Rx interrupts for the first buffer */
<span class="p_del">-	__raw_writel(XEL_RSR_RECV_IE_MASK, drvdata-&gt;base_addr + XEL_RSR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(XEL_RSR_RECV_IE_MASK, drvdata-&gt;base_addr + XEL_RSR_OFFSET);</span>
 
 	/* Enable the Global Interrupt Enable */
<span class="p_del">-	__raw_writel(XEL_GIER_GIE_MASK, drvdata-&gt;base_addr + XEL_GIER_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(XEL_GIER_GIE_MASK, drvdata-&gt;base_addr + XEL_GIER_OFFSET);</span>
 }
 
 /**
<span class="p_chunk">@@ -181,17 +189,17 @@</span> <span class="p_context"> static void xemaclite_disable_interrupts(struct net_local *drvdata)</span>
 	u32 reg_data;
 
 	/* Disable the Global Interrupt Enable */
<span class="p_del">-	__raw_writel(XEL_GIER_GIE_MASK, drvdata-&gt;base_addr + XEL_GIER_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(XEL_GIER_GIE_MASK, drvdata-&gt;base_addr + XEL_GIER_OFFSET);</span>
 
 	/* Disable the Tx interrupts for the first buffer */
<span class="p_del">-	reg_data = __raw_readl(drvdata-&gt;base_addr + XEL_TSR_OFFSET);</span>
<span class="p_del">-	__raw_writel(reg_data &amp; (~XEL_TSR_XMIT_IE_MASK),</span>
<span class="p_del">-		     drvdata-&gt;base_addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+	reg_data = xemaclite_readl(drvdata-&gt;base_addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(reg_data &amp; (~XEL_TSR_XMIT_IE_MASK),</span>
<span class="p_add">+			 drvdata-&gt;base_addr + XEL_TSR_OFFSET);</span>
 
 	/* Disable the Rx interrupts for the first buffer */
<span class="p_del">-	reg_data = __raw_readl(drvdata-&gt;base_addr + XEL_RSR_OFFSET);</span>
<span class="p_del">-	__raw_writel(reg_data &amp; (~XEL_RSR_RECV_IE_MASK),</span>
<span class="p_del">-		     drvdata-&gt;base_addr + XEL_RSR_OFFSET);</span>
<span class="p_add">+	reg_data = xemaclite_readl(drvdata-&gt;base_addr + XEL_RSR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(reg_data &amp; (~XEL_RSR_RECV_IE_MASK),</span>
<span class="p_add">+			 drvdata-&gt;base_addr + XEL_RSR_OFFSET);</span>
 }
 
 /**
<span class="p_chunk">@@ -323,7 +331,7 @@</span> <span class="p_context"> static int xemaclite_send_data(struct net_local *drvdata, u8 *data,</span>
 		byte_count = ETH_FRAME_LEN;
 
 	/* Check if the expected buffer is available */
<span class="p_del">-	reg_data = __raw_readl(addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+	reg_data = xemaclite_readl(addr + XEL_TSR_OFFSET);</span>
 	if ((reg_data &amp; (XEL_TSR_XMIT_BUSY_MASK |
 	     XEL_TSR_XMIT_ACTIVE_MASK)) == 0) {
 
<span class="p_chunk">@@ -336,7 +344,7 @@</span> <span class="p_context"> static int xemaclite_send_data(struct net_local *drvdata, u8 *data,</span>
 
 		addr = (void __iomem __force *)((u32 __force)addr ^
 						 XEL_BUFFER_OFFSET);
<span class="p_del">-		reg_data = __raw_readl(addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+		reg_data = xemaclite_readl(addr + XEL_TSR_OFFSET);</span>
 
 		if ((reg_data &amp; (XEL_TSR_XMIT_BUSY_MASK |
 		     XEL_TSR_XMIT_ACTIVE_MASK)) != 0)
<span class="p_chunk">@@ -347,16 +355,16 @@</span> <span class="p_context"> static int xemaclite_send_data(struct net_local *drvdata, u8 *data,</span>
 	/* Write the frame to the buffer */
 	xemaclite_aligned_write(data, (u32 __force *) addr, byte_count);
 
<span class="p_del">-	__raw_writel((byte_count &amp; XEL_TPLR_LENGTH_MASK),</span>
<span class="p_del">-		     addr + XEL_TPLR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel((byte_count &amp; XEL_TPLR_LENGTH_MASK),</span>
<span class="p_add">+			 addr + XEL_TPLR_OFFSET);</span>
 
 	/* Update the Tx Status Register to indicate that there is a
 	 * frame to send. Set the XEL_TSR_XMIT_ACTIVE_MASK flag which
 	 * is used by the interrupt handler to check whether a frame
 	 * has been transmitted */
<span class="p_del">-	reg_data = __raw_readl(addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+	reg_data = xemaclite_readl(addr + XEL_TSR_OFFSET);</span>
 	reg_data |= (XEL_TSR_XMIT_BUSY_MASK | XEL_TSR_XMIT_ACTIVE_MASK);
<span class="p_del">-	__raw_writel(reg_data, addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(reg_data, addr + XEL_TSR_OFFSET);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -371,7 +379,7 @@</span> <span class="p_context"> static int xemaclite_send_data(struct net_local *drvdata, u8 *data,</span>
  *
  * Return:	Total number of bytes received
  */
<span class="p_del">-static u16 xemaclite_recv_data(struct net_local *drvdata, u8 *data)</span>
<span class="p_add">+static u16 xemaclite_recv_data(struct net_local *drvdata, u8 *data, int maxlen)</span>
 {
 	void __iomem *addr;
 	u16 length, proto_type;
<span class="p_chunk">@@ -381,7 +389,7 @@</span> <span class="p_context"> static u16 xemaclite_recv_data(struct net_local *drvdata, u8 *data)</span>
 	addr = (drvdata-&gt;base_addr + drvdata-&gt;next_rx_buf_to_use);
 
 	/* Verify which buffer has valid data */
<span class="p_del">-	reg_data = __raw_readl(addr + XEL_RSR_OFFSET);</span>
<span class="p_add">+	reg_data = xemaclite_readl(addr + XEL_RSR_OFFSET);</span>
 
 	if ((reg_data &amp; XEL_RSR_RECV_DONE_MASK) == XEL_RSR_RECV_DONE_MASK) {
 		if (drvdata-&gt;rx_ping_pong != 0)
<span class="p_chunk">@@ -398,27 +406,28 @@</span> <span class="p_context"> static u16 xemaclite_recv_data(struct net_local *drvdata, u8 *data)</span>
 			return 0;	/* No data was available */
 
 		/* Verify that buffer has valid data */
<span class="p_del">-		reg_data = __raw_readl(addr + XEL_RSR_OFFSET);</span>
<span class="p_add">+		reg_data = xemaclite_readl(addr + XEL_RSR_OFFSET);</span>
 		if ((reg_data &amp; XEL_RSR_RECV_DONE_MASK) !=
 		     XEL_RSR_RECV_DONE_MASK)
 			return 0;	/* No data was available */
 	}
 
 	/* Get the protocol type of the ethernet frame that arrived */
<span class="p_del">-	proto_type = ((ntohl(__raw_readl(addr + XEL_HEADER_OFFSET +</span>
<span class="p_add">+	proto_type = ((ntohl(xemaclite_readl(addr + XEL_HEADER_OFFSET +</span>
 			XEL_RXBUFF_OFFSET)) &gt;&gt; XEL_HEADER_SHIFT) &amp;
 			XEL_RPLR_LENGTH_MASK);
 
 	/* Check if received ethernet frame is a raw ethernet frame
 	 * or an IP packet or an ARP packet */
<span class="p_del">-	if (proto_type &gt; (ETH_FRAME_LEN + ETH_FCS_LEN)) {</span>
<span class="p_add">+	if (proto_type &gt; ETH_DATA_LEN) {</span>
 
 		if (proto_type == ETH_P_IP) {
<span class="p_del">-			length = ((ntohl(__raw_readl(addr +</span>
<span class="p_add">+			length = ((ntohl(xemaclite_readl(addr +</span>
 					XEL_HEADER_IP_LENGTH_OFFSET +
 					XEL_RXBUFF_OFFSET)) &gt;&gt;
 					XEL_HEADER_SHIFT) &amp;
 					XEL_RPLR_LENGTH_MASK);
<span class="p_add">+			length = min_t(u16, length, ETH_DATA_LEN);</span>
 			length += ETH_HLEN + ETH_FCS_LEN;
 
 		} else if (proto_type == ETH_P_ARP)
<span class="p_chunk">@@ -431,14 +440,17 @@</span> <span class="p_context"> static u16 xemaclite_recv_data(struct net_local *drvdata, u8 *data)</span>
 		/* Use the length in the frame, plus the header and trailer */
 		length = proto_type + ETH_HLEN + ETH_FCS_LEN;
 
<span class="p_add">+	if (WARN_ON(length &gt; maxlen))</span>
<span class="p_add">+		length = maxlen;</span>
<span class="p_add">+</span>
 	/* Read from the EmacLite device */
 	xemaclite_aligned_read((u32 __force *) (addr + XEL_RXBUFF_OFFSET),
 				data, length);
 
 	/* Acknowledge the frame */
<span class="p_del">-	reg_data = __raw_readl(addr + XEL_RSR_OFFSET);</span>
<span class="p_add">+	reg_data = xemaclite_readl(addr + XEL_RSR_OFFSET);</span>
 	reg_data &amp;= ~XEL_RSR_RECV_DONE_MASK;
<span class="p_del">-	__raw_writel(reg_data, addr + XEL_RSR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(reg_data, addr + XEL_RSR_OFFSET);</span>
 
 	return length;
 }
<span class="p_chunk">@@ -465,14 +477,14 @@</span> <span class="p_context"> static void xemaclite_update_address(struct net_local *drvdata,</span>
 
 	xemaclite_aligned_write(address_ptr, (u32 __force *) addr, ETH_ALEN);
 
<span class="p_del">-	__raw_writel(ETH_ALEN, addr + XEL_TPLR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(ETH_ALEN, addr + XEL_TPLR_OFFSET);</span>
 
 	/* Update the MAC address in the EmacLite */
<span class="p_del">-	reg_data = __raw_readl(addr + XEL_TSR_OFFSET);</span>
<span class="p_del">-	__raw_writel(reg_data | XEL_TSR_PROG_MAC_ADDR, addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+	reg_data = xemaclite_readl(addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(reg_data | XEL_TSR_PROG_MAC_ADDR, addr + XEL_TSR_OFFSET);</span>
 
 	/* Wait for EmacLite to finish with the MAC address update */
<span class="p_del">-	while ((__raw_readl(addr + XEL_TSR_OFFSET) &amp;</span>
<span class="p_add">+	while ((xemaclite_readl(addr + XEL_TSR_OFFSET) &amp;</span>
 		XEL_TSR_PROG_MAC_ADDR) != 0)
 		;
 }
<span class="p_chunk">@@ -605,7 +617,7 @@</span> <span class="p_context"> static void xemaclite_rx_handler(struct net_device *dev)</span>
 
 	skb_reserve(skb, 2);
 
<span class="p_del">-	len = xemaclite_recv_data(lp, (u8 *) skb-&gt;data);</span>
<span class="p_add">+	len = xemaclite_recv_data(lp, (u8 *) skb-&gt;data, len);</span>
 
 	if (!len) {
 		dev-&gt;stats.rx_errors++;
<span class="p_chunk">@@ -642,32 +654,32 @@</span> <span class="p_context"> static irqreturn_t xemaclite_interrupt(int irq, void *dev_id)</span>
 	u32 tx_status;
 
 	/* Check if there is Rx Data available */
<span class="p_del">-	if ((__raw_readl(base_addr + XEL_RSR_OFFSET) &amp;</span>
<span class="p_add">+	if ((xemaclite_readl(base_addr + XEL_RSR_OFFSET) &amp;</span>
 			 XEL_RSR_RECV_DONE_MASK) ||
<span class="p_del">-	    (__raw_readl(base_addr + XEL_BUFFER_OFFSET + XEL_RSR_OFFSET)</span>
<span class="p_add">+	    (xemaclite_readl(base_addr + XEL_BUFFER_OFFSET + XEL_RSR_OFFSET)</span>
 			 &amp; XEL_RSR_RECV_DONE_MASK))
 
 		xemaclite_rx_handler(dev);
 
 	/* Check if the Transmission for the first buffer is completed */
<span class="p_del">-	tx_status = __raw_readl(base_addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+	tx_status = xemaclite_readl(base_addr + XEL_TSR_OFFSET);</span>
 	if (((tx_status &amp; XEL_TSR_XMIT_BUSY_MASK) == 0) &amp;&amp;
 		(tx_status &amp; XEL_TSR_XMIT_ACTIVE_MASK) != 0) {
 
 		tx_status &amp;= ~XEL_TSR_XMIT_ACTIVE_MASK;
<span class="p_del">-		__raw_writel(tx_status, base_addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+		xemaclite_writel(tx_status, base_addr + XEL_TSR_OFFSET);</span>
 
 		tx_complete = true;
 	}
 
 	/* Check if the Transmission for the second buffer is completed */
<span class="p_del">-	tx_status = __raw_readl(base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);</span>
<span class="p_add">+	tx_status = xemaclite_readl(base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);</span>
 	if (((tx_status &amp; XEL_TSR_XMIT_BUSY_MASK) == 0) &amp;&amp;
 		(tx_status &amp; XEL_TSR_XMIT_ACTIVE_MASK) != 0) {
 
 		tx_status &amp;= ~XEL_TSR_XMIT_ACTIVE_MASK;
<span class="p_del">-		__raw_writel(tx_status, base_addr + XEL_BUFFER_OFFSET +</span>
<span class="p_del">-			     XEL_TSR_OFFSET);</span>
<span class="p_add">+		xemaclite_writel(tx_status, base_addr + XEL_BUFFER_OFFSET +</span>
<span class="p_add">+				 XEL_TSR_OFFSET);</span>
 
 		tx_complete = true;
 	}
<span class="p_chunk">@@ -700,7 +712,7 @@</span> <span class="p_context"> static int xemaclite_mdio_wait(struct net_local *lp)</span>
 	/* wait for the MDIO interface to not be busy or timeout
 	   after some time.
 	*/
<span class="p_del">-	while (__raw_readl(lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET) &amp;</span>
<span class="p_add">+	while (xemaclite_readl(lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET) &amp;</span>
 			XEL_MDIOCTRL_MDIOSTS_MASK) {
 		if (time_before_eq(end, jiffies)) {
 			WARN_ON(1);
<span class="p_chunk">@@ -736,17 +748,17 @@</span> <span class="p_context"> static int xemaclite_mdio_read(struct mii_bus *bus, int phy_id, int reg)</span>
 	 * MDIO Address register. Set the Status bit in the MDIO Control
 	 * register to start a MDIO read transaction.
 	 */
<span class="p_del">-	ctrl_reg = __raw_readl(lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET);</span>
<span class="p_del">-	__raw_writel(XEL_MDIOADDR_OP_MASK |</span>
<span class="p_del">-		     ((phy_id &lt;&lt; XEL_MDIOADDR_PHYADR_SHIFT) | reg),</span>
<span class="p_del">-		     lp-&gt;base_addr + XEL_MDIOADDR_OFFSET);</span>
<span class="p_del">-	__raw_writel(ctrl_reg | XEL_MDIOCTRL_MDIOSTS_MASK,</span>
<span class="p_del">-		     lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET);</span>
<span class="p_add">+	ctrl_reg = xemaclite_readl(lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(XEL_MDIOADDR_OP_MASK |</span>
<span class="p_add">+			 ((phy_id &lt;&lt; XEL_MDIOADDR_PHYADR_SHIFT) | reg),</span>
<span class="p_add">+			 lp-&gt;base_addr + XEL_MDIOADDR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(ctrl_reg | XEL_MDIOCTRL_MDIOSTS_MASK,</span>
<span class="p_add">+			 lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET);</span>
 
 	if (xemaclite_mdio_wait(lp))
 		return -ETIMEDOUT;
 
<span class="p_del">-	rc = __raw_readl(lp-&gt;base_addr + XEL_MDIORD_OFFSET);</span>
<span class="p_add">+	rc = xemaclite_readl(lp-&gt;base_addr + XEL_MDIORD_OFFSET);</span>
 
 	dev_dbg(&amp;lp-&gt;ndev-&gt;dev,
 		&quot;xemaclite_mdio_read(phy_id=%i, reg=%x) == %x\n&quot;,
<span class="p_chunk">@@ -783,13 +795,13 @@</span> <span class="p_context"> static int xemaclite_mdio_write(struct mii_bus *bus, int phy_id, int reg,</span>
 	 * Data register. Finally, set the Status bit in the MDIO Control
 	 * register to start a MDIO write transaction.
 	 */
<span class="p_del">-	ctrl_reg = __raw_readl(lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET);</span>
<span class="p_del">-	__raw_writel(~XEL_MDIOADDR_OP_MASK &amp;</span>
<span class="p_del">-		     ((phy_id &lt;&lt; XEL_MDIOADDR_PHYADR_SHIFT) | reg),</span>
<span class="p_del">-		     lp-&gt;base_addr + XEL_MDIOADDR_OFFSET);</span>
<span class="p_del">-	__raw_writel(val, lp-&gt;base_addr + XEL_MDIOWR_OFFSET);</span>
<span class="p_del">-	__raw_writel(ctrl_reg | XEL_MDIOCTRL_MDIOSTS_MASK,</span>
<span class="p_del">-		     lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET);</span>
<span class="p_add">+	ctrl_reg = xemaclite_readl(lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(~XEL_MDIOADDR_OP_MASK &amp;</span>
<span class="p_add">+			 ((phy_id &lt;&lt; XEL_MDIOADDR_PHYADR_SHIFT) | reg),</span>
<span class="p_add">+			 lp-&gt;base_addr + XEL_MDIOADDR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(val, lp-&gt;base_addr + XEL_MDIOWR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(ctrl_reg | XEL_MDIOCTRL_MDIOSTS_MASK,</span>
<span class="p_add">+			 lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -834,8 +846,8 @@</span> <span class="p_context"> static int xemaclite_mdio_setup(struct net_local *lp, struct device *dev)</span>
 	/* Enable the MDIO bus by asserting the enable bit in MDIO Control
 	 * register.
 	 */
<span class="p_del">-	__raw_writel(XEL_MDIOCTRL_MDIOEN_MASK,</span>
<span class="p_del">-		     lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(XEL_MDIOCTRL_MDIOEN_MASK,</span>
<span class="p_add">+			 lp-&gt;base_addr + XEL_MDIOCTRL_OFFSET);</span>
 
 	bus = mdiobus_alloc();
 	if (!bus) {
<span class="p_chunk">@@ -1138,8 +1150,8 @@</span> <span class="p_context"> static int xemaclite_of_probe(struct platform_device *ofdev)</span>
 		dev_warn(dev, &quot;No MAC address found\n&quot;);
 
 	/* Clear the Tx CSR&#39;s in case this is a restart */
<span class="p_del">-	__raw_writel(0, lp-&gt;base_addr + XEL_TSR_OFFSET);</span>
<span class="p_del">-	__raw_writel(0, lp-&gt;base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(0, lp-&gt;base_addr + XEL_TSR_OFFSET);</span>
<span class="p_add">+	xemaclite_writel(0, lp-&gt;base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);</span>
 
 	/* Set the MAC address in the EmacLite device */
 	xemaclite_update_address(lp, ndev-&gt;dev_addr);
<span class="p_header">diff --git a/drivers/net/hyperv/netvsc_drv.c b/drivers/net/hyperv/netvsc_drv.c</span>
<span class="p_header">index 7e3331821200..ab68d940a2c7 100644</span>
<span class="p_header">--- a/drivers/net/hyperv/netvsc_drv.c</span>
<span class="p_header">+++ b/drivers/net/hyperv/netvsc_drv.c</span>
<span class="p_chunk">@@ -47,6 +47,9 @@</span> <span class="p_context"> struct net_device_context {</span>
 	struct work_struct work;
 };
 
<span class="p_add">+/* Restrict GSO size to account for NVGRE */</span>
<span class="p_add">+#define NETVSC_GSO_MAX_SIZE	62768</span>
<span class="p_add">+</span>
 #define RING_SIZE_MIN 64
 static int ring_size = 128;
 module_param(ring_size, int, S_IRUGO);
<span class="p_chunk">@@ -839,6 +842,7 @@</span> <span class="p_context"> static int netvsc_probe(struct hv_device *dev,</span>
 	nvdev = hv_get_drvdata(dev);
 	netif_set_real_num_tx_queues(net, nvdev-&gt;num_chn);
 	netif_set_real_num_rx_queues(net, nvdev-&gt;num_chn);
<span class="p_add">+	netif_set_gso_max_size(net, NETVSC_GSO_MAX_SIZE);</span>
 
 	ret = register_netdev(net);
 	if (ret != 0) {
<span class="p_header">diff --git a/drivers/net/macvtap.c b/drivers/net/macvtap.c</span>
<span class="p_header">index faa79040d336..b787d1ceeba6 100644</span>
<span class="p_header">--- a/drivers/net/macvtap.c</span>
<span class="p_header">+++ b/drivers/net/macvtap.c</span>
<span class="p_chunk">@@ -657,7 +657,7 @@</span> <span class="p_context"> static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,</span>
 	size_t linear;
 
 	if (q-&gt;flags &amp; IFF_VNET_HDR) {
<span class="p_del">-		vnet_hdr_len = q-&gt;vnet_hdr_sz;</span>
<span class="p_add">+		vnet_hdr_len = ACCESS_ONCE(q-&gt;vnet_hdr_sz);</span>
 
 		err = -EINVAL;
 		if (len &lt; vnet_hdr_len)
<span class="p_chunk">@@ -793,7 +793,7 @@</span> <span class="p_context"> static ssize_t macvtap_put_user(struct macvtap_queue *q,</span>
 
 	if (q-&gt;flags &amp; IFF_VNET_HDR) {
 		struct virtio_net_hdr vnet_hdr;
<span class="p_del">-		vnet_hdr_len = q-&gt;vnet_hdr_sz;</span>
<span class="p_add">+		vnet_hdr_len = ACCESS_ONCE(q-&gt;vnet_hdr_sz);</span>
 		if ((len -= vnet_hdr_len) &lt; 0)
 			return -EINVAL;
 
<span class="p_header">diff --git a/drivers/net/tun.c b/drivers/net/tun.c</span>
<span class="p_header">index 343a71ad865b..1c843a4ac7a4 100644</span>
<span class="p_header">--- a/drivers/net/tun.c</span>
<span class="p_header">+++ b/drivers/net/tun.c</span>
<span class="p_chunk">@@ -1037,9 +1037,11 @@</span> <span class="p_context"> static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,</span>
 	}
 
 	if (tun-&gt;flags &amp; TUN_VNET_HDR) {
<span class="p_del">-		if (len &lt; tun-&gt;vnet_hdr_sz)</span>
<span class="p_add">+		int vnet_hdr_sz = ACCESS_ONCE(tun-&gt;vnet_hdr_sz);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (len &lt; vnet_hdr_sz)</span>
 			return -EINVAL;
<span class="p_del">-		len -= tun-&gt;vnet_hdr_sz;</span>
<span class="p_add">+		len -= vnet_hdr_sz;</span>
 
 		if (memcpy_fromiovecend((void *)&amp;gso, iv, offset, sizeof(gso)))
 			return -EFAULT;
<span class="p_chunk">@@ -1050,7 +1052,7 @@</span> <span class="p_context"> static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,</span>
 
 		if (gso.hdr_len &gt; len)
 			return -EINVAL;
<span class="p_del">-		offset += tun-&gt;vnet_hdr_sz;</span>
<span class="p_add">+		offset += vnet_hdr_sz;</span>
 	}
 
 	if ((tun-&gt;flags &amp; TUN_TYPE_MASK) == TUN_TAP_DEV) {
<span class="p_chunk">@@ -1227,15 +1229,19 @@</span> <span class="p_context"> static ssize_t tun_put_user(struct tun_struct *tun,</span>
 	ssize_t total = 0;
 	int vlan_offset = 0, copied;
 	int vlan_hlen = 0;
<span class="p_add">+	int vnet_hdr_sz = 0;</span>
 
 	if (vlan_tx_tag_present(skb))
 		vlan_hlen = VLAN_HLEN;
 
<span class="p_add">+	if (tun-&gt;flags &amp; TUN_VNET_HDR)</span>
<span class="p_add">+		vnet_hdr_sz = ACCESS_ONCE(tun-&gt;vnet_hdr_sz);</span>
<span class="p_add">+</span>
 	if (!(tun-&gt;flags &amp; TUN_NO_PI)) {
 		if ((len -= sizeof(pi)) &lt; 0)
 			return -EINVAL;
 
<span class="p_del">-		if (len &lt; skb-&gt;len) {</span>
<span class="p_add">+		if (len &lt; skb-&gt;len + vlan_hlen + vnet_hdr_sz) {</span>
 			/* Packet will be striped */
 			pi.flags |= TUN_PKT_STRIP;
 		}
<span class="p_chunk">@@ -1245,9 +1251,9 @@</span> <span class="p_context"> static ssize_t tun_put_user(struct tun_struct *tun,</span>
 		total += sizeof(pi);
 	}
 
<span class="p_del">-	if (tun-&gt;flags &amp; TUN_VNET_HDR) {</span>
<span class="p_add">+	if (vnet_hdr_sz) {</span>
 		struct virtio_net_hdr gso = { 0 }; /* no info leak */
<span class="p_del">-		if ((len -= tun-&gt;vnet_hdr_sz) &lt; 0)</span>
<span class="p_add">+		if ((len -= vnet_hdr_sz) &lt; 0)</span>
 			return -EINVAL;
 
 		if (skb_is_gso(skb)) {
<span class="p_chunk">@@ -1291,7 +1297,7 @@</span> <span class="p_context"> static ssize_t tun_put_user(struct tun_struct *tun,</span>
 		if (unlikely(memcpy_toiovecend(iv, (void *)&amp;gso, total,
 					       sizeof(gso))))
 			return -EFAULT;
<span class="p_del">-		total += tun-&gt;vnet_hdr_sz;</span>
<span class="p_add">+		total += vnet_hdr_sz;</span>
 	}
 
 	copied = total;
<span class="p_header">diff --git a/drivers/net/usb/catc.c b/drivers/net/usb/catc.c</span>
<span class="p_header">index 8cfc3bb0c6a6..436da0c3ce3b 100644</span>
<span class="p_header">--- a/drivers/net/usb/catc.c</span>
<span class="p_header">+++ b/drivers/net/usb/catc.c</span>
<span class="p_chunk">@@ -777,7 +777,7 @@</span> <span class="p_context"> static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id</span>
 	struct net_device *netdev;
 	struct catc *catc;
 	u8 broadcast[ETH_ALEN];
<span class="p_del">-	int i, pktsz;</span>
<span class="p_add">+	int pktsz, ret;</span>
 
 	if (usb_set_interface(usbdev,
 			intf-&gt;altsetting-&gt;desc.bInterfaceNumber, 1)) {
<span class="p_chunk">@@ -812,12 +812,8 @@</span> <span class="p_context"> static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id</span>
 	if ((!catc-&gt;ctrl_urb) || (!catc-&gt;tx_urb) || 
 	    (!catc-&gt;rx_urb) || (!catc-&gt;irq_urb)) {
 		dev_err(&amp;intf-&gt;dev, &quot;No free urbs available.\n&quot;);
<span class="p_del">-		usb_free_urb(catc-&gt;ctrl_urb);</span>
<span class="p_del">-		usb_free_urb(catc-&gt;tx_urb);</span>
<span class="p_del">-		usb_free_urb(catc-&gt;rx_urb);</span>
<span class="p_del">-		usb_free_urb(catc-&gt;irq_urb);</span>
<span class="p_del">-		free_netdev(netdev);</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto fail_free;</span>
 	}
 
 	/* The F5U011 has the same vendor/product as the netmate but a device version of 0x130 */
<span class="p_chunk">@@ -845,15 +841,24 @@</span> <span class="p_context"> static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id</span>
                 catc-&gt;irq_buf, 2, catc_irq_done, catc, 1);
 
 	if (!catc-&gt;is_f5u011) {
<span class="p_add">+		u32 *buf;</span>
<span class="p_add">+		int i;</span>
<span class="p_add">+</span>
 		dev_dbg(dev, &quot;Checking memory size\n&quot;);
 
<span class="p_del">-		i = 0x12345678;</span>
<span class="p_del">-		catc_write_mem(catc, 0x7a80, &amp;i, 4);</span>
<span class="p_del">-		i = 0x87654321;	</span>
<span class="p_del">-		catc_write_mem(catc, 0xfa80, &amp;i, 4);</span>
<span class="p_del">-		catc_read_mem(catc, 0x7a80, &amp;i, 4);</span>
<span class="p_add">+		buf = kmalloc(4, GFP_KERNEL);</span>
<span class="p_add">+		if (!buf) {</span>
<span class="p_add">+			ret = -ENOMEM;</span>
<span class="p_add">+			goto fail_free;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		*buf = 0x12345678;</span>
<span class="p_add">+		catc_write_mem(catc, 0x7a80, buf, 4);</span>
<span class="p_add">+		*buf = 0x87654321;</span>
<span class="p_add">+		catc_write_mem(catc, 0xfa80, buf, 4);</span>
<span class="p_add">+		catc_read_mem(catc, 0x7a80, buf, 4);</span>
 	  
<span class="p_del">-		switch (i) {</span>
<span class="p_add">+		switch (*buf) {</span>
 		case 0x12345678:
 			catc_set_reg(catc, TxBufCount, 8);
 			catc_set_reg(catc, RxBufCount, 32);
<span class="p_chunk">@@ -868,6 +873,8 @@</span> <span class="p_context"> static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id</span>
 			dev_dbg(dev, &quot;32k Memory\n&quot;);
 			break;
 		}
<span class="p_add">+</span>
<span class="p_add">+		kfree(buf);</span>
 	  
 		dev_dbg(dev, &quot;Getting MAC from SEEROM.\n&quot;);
 	  
<span class="p_chunk">@@ -914,16 +921,21 @@</span> <span class="p_context"> static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id</span>
 	usb_set_intfdata(intf, catc);
 
 	SET_NETDEV_DEV(netdev, &amp;intf-&gt;dev);
<span class="p_del">-	if (register_netdev(netdev) != 0) {</span>
<span class="p_del">-		usb_set_intfdata(intf, NULL);</span>
<span class="p_del">-		usb_free_urb(catc-&gt;ctrl_urb);</span>
<span class="p_del">-		usb_free_urb(catc-&gt;tx_urb);</span>
<span class="p_del">-		usb_free_urb(catc-&gt;rx_urb);</span>
<span class="p_del">-		usb_free_urb(catc-&gt;irq_urb);</span>
<span class="p_del">-		free_netdev(netdev);</span>
<span class="p_del">-		return -EIO;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	ret = register_netdev(netdev);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto fail_clear_intfdata;</span>
<span class="p_add">+</span>
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+fail_clear_intfdata:</span>
<span class="p_add">+	usb_set_intfdata(intf, NULL);</span>
<span class="p_add">+fail_free:</span>
<span class="p_add">+	usb_free_urb(catc-&gt;ctrl_urb);</span>
<span class="p_add">+	usb_free_urb(catc-&gt;tx_urb);</span>
<span class="p_add">+	usb_free_urb(catc-&gt;rx_urb);</span>
<span class="p_add">+	usb_free_urb(catc-&gt;irq_urb);</span>
<span class="p_add">+	free_netdev(netdev);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static void catc_disconnect(struct usb_interface *intf)
<span class="p_header">diff --git a/drivers/net/usb/cdc_ether.c b/drivers/net/usb/cdc_ether.c</span>
<span class="p_header">index 2a32d9167d3b..610b2858c5c3 100644</span>
<span class="p_header">--- a/drivers/net/usb/cdc_ether.c</span>
<span class="p_header">+++ b/drivers/net/usb/cdc_ether.c</span>
<span class="p_chunk">@@ -502,6 +502,7 @@</span> <span class="p_context"> static const struct driver_info wwan_info = {</span>
 #define DELL_VENDOR_ID		0x413C
 #define REALTEK_VENDOR_ID	0x0bda
 #define SAMSUNG_VENDOR_ID	0x04e8
<span class="p_add">+#define HP_VENDOR_ID		0x03f0</span>
 
 static const struct usb_device_id	products[] = {
 /* BLACKLIST !!
<span class="p_chunk">@@ -648,6 +649,13 @@</span> <span class="p_context"> static const struct usb_device_id	products[] = {</span>
 	.driver_info = 0,
 },
 
<span class="p_add">+/* HP lt2523 (Novatel E371) - handled by qmi_wwan */</span>
<span class="p_add">+{</span>
<span class="p_add">+	USB_DEVICE_AND_INTERFACE_INFO(HP_VENDOR_ID, 0x421d, USB_CLASS_COMM,</span>
<span class="p_add">+				      USB_CDC_SUBCLASS_ETHERNET, USB_CDC_PROTO_NONE),</span>
<span class="p_add">+	.driver_info = 0,</span>
<span class="p_add">+},</span>
<span class="p_add">+</span>
 /* AnyDATA ADU960S - handled by qmi_wwan */
 {
 	USB_DEVICE_AND_INTERFACE_INFO(0x16d5, 0x650a, USB_CLASS_COMM,
<span class="p_header">diff --git a/drivers/net/usb/cdc_ncm.c b/drivers/net/usb/cdc_ncm.c</span>
<span class="p_header">index 58990934f192..73c5b0976f65 100644</span>
<span class="p_header">--- a/drivers/net/usb/cdc_ncm.c</span>
<span class="p_header">+++ b/drivers/net/usb/cdc_ncm.c</span>
<span class="p_chunk">@@ -830,6 +830,13 @@</span> <span class="p_context"> advance:</span>
 	if (cdc_ncm_init(dev))
 		goto error2;
 
<span class="p_add">+	/* Some firmwares need a pause here or they will silently fail</span>
<span class="p_add">+	 * to set up the interface properly.  This value was decided</span>
<span class="p_add">+	 * empirically on a Sierra Wireless MC7455 running 02.08.02.00</span>
<span class="p_add">+	 * firmware.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	usleep_range(10000, 20000);</span>
<span class="p_add">+</span>
 	/* configure data interface */
 	temp = usb_set_interface(dev-&gt;udev, iface_no, data_altsetting);
 	if (temp) {
<span class="p_header">diff --git a/drivers/net/usb/pegasus.c b/drivers/net/usb/pegasus.c</span>
<span class="p_header">index f84080215915..17fac0121e56 100644</span>
<span class="p_header">--- a/drivers/net/usb/pegasus.c</span>
<span class="p_header">+++ b/drivers/net/usb/pegasus.c</span>
<span class="p_chunk">@@ -126,40 +126,61 @@</span> <span class="p_context"> static void async_ctrl_callback(struct urb *urb)</span>
 
 static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)
 {
<span class="p_add">+	u8 *buf;</span>
 	int ret;
 
<span class="p_add">+	buf = kmalloc(size, GFP_NOIO);</span>
<span class="p_add">+	if (!buf)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	ret = usb_control_msg(pegasus-&gt;usb, usb_rcvctrlpipe(pegasus-&gt;usb, 0),
 			      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,
<span class="p_del">-			      indx, data, size, 1000);</span>
<span class="p_add">+			      indx, buf, size, 1000);</span>
 	if (ret &lt; 0)
 		netif_dbg(pegasus, drv, pegasus-&gt;net,
 			  &quot;%s returned %d\n&quot;, __func__, ret);
<span class="p_add">+	else if (ret &lt;= size)</span>
<span class="p_add">+		memcpy(data, buf, ret);</span>
<span class="p_add">+	kfree(buf);</span>
 	return ret;
 }
 
<span class="p_del">-static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)</span>
<span class="p_add">+static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size,</span>
<span class="p_add">+			 const void *data)</span>
 {
<span class="p_add">+	u8 *buf;</span>
 	int ret;
 
<span class="p_add">+	buf = kmemdup(data, size, GFP_NOIO);</span>
<span class="p_add">+	if (!buf)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	ret = usb_control_msg(pegasus-&gt;usb, usb_sndctrlpipe(pegasus-&gt;usb, 0),
 			      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,
<span class="p_del">-			      indx, data, size, 100);</span>
<span class="p_add">+			      indx, buf, size, 100);</span>
 	if (ret &lt; 0)
 		netif_dbg(pegasus, drv, pegasus-&gt;net,
 			  &quot;%s returned %d\n&quot;, __func__, ret);
<span class="p_add">+	kfree(buf);</span>
 	return ret;
 }
 
 static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)
 {
<span class="p_add">+	u8 *buf;</span>
 	int ret;
 
<span class="p_add">+	buf = kmemdup(&amp;data, 1, GFP_NOIO);</span>
<span class="p_add">+	if (!buf)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	ret = usb_control_msg(pegasus-&gt;usb, usb_sndctrlpipe(pegasus-&gt;usb, 0),
 			      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,
<span class="p_del">-			      indx, &amp;data, 1, 1000);</span>
<span class="p_add">+			      indx, buf, 1, 1000);</span>
 	if (ret &lt; 0)
 		netif_dbg(pegasus, drv, pegasus-&gt;net,
 			  &quot;%s returned %d\n&quot;, __func__, ret);
<span class="p_add">+	kfree(buf);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/net/usb/qmi_wwan.c b/drivers/net/usb/qmi_wwan.c</span>
<span class="p_header">index f6caedf0920c..f07777eb09b1 100644</span>
<span class="p_header">--- a/drivers/net/usb/qmi_wwan.c</span>
<span class="p_header">+++ b/drivers/net/usb/qmi_wwan.c</span>
<span class="p_chunk">@@ -535,6 +535,13 @@</span> <span class="p_context"> static const struct usb_device_id products[] = {</span>
 					      USB_CDC_PROTO_NONE),
 		.driver_info        = (unsigned long)&amp;qmi_wwan_info,
 	},
<span class="p_add">+	{	/* HP lt2523 (Novatel E371) */</span>
<span class="p_add">+		USB_DEVICE_AND_INTERFACE_INFO(0x03f0, 0x421d,</span>
<span class="p_add">+					      USB_CLASS_COMM,</span>
<span class="p_add">+					      USB_CDC_SUBCLASS_ETHERNET,</span>
<span class="p_add">+					      USB_CDC_PROTO_NONE),</span>
<span class="p_add">+		.driver_info        = (unsigned long)&amp;qmi_wwan_info,</span>
<span class="p_add">+	},</span>
 	{	/* HP lt4112 LTE/HSPA+ Gobi 4G Module (Huawei me906e) */
 		USB_DEVICE_AND_INTERFACE_INFO(0x03f0, 0x581d, USB_CLASS_VENDOR_SPEC, 1, 7),
 		.driver_info = (unsigned long)&amp;qmi_wwan_info,
<span class="p_header">diff --git a/drivers/net/usb/r8152.c b/drivers/net/usb/r8152.c</span>
<span class="p_header">index 3eab74c7c554..580793a8190e 100644</span>
<span class="p_header">--- a/drivers/net/usb/r8152.c</span>
<span class="p_header">+++ b/drivers/net/usb/r8152.c</span>
<span class="p_chunk">@@ -1596,7 +1596,7 @@</span> <span class="p_context"> static u8 r8152_rx_csum(struct r8152 *tp, struct rx_desc *rx_desc)</span>
 	u8 checksum = CHECKSUM_NONE;
 	u32 opts2, opts3;
 
<span class="p_del">-	if (tp-&gt;version == RTL_VER_01)</span>
<span class="p_add">+	if (!(tp-&gt;netdev-&gt;features &amp; NETIF_F_RXCSUM))</span>
 		goto return_result;
 
 	opts2 = le32_to_cpu(rx_desc-&gt;opts2);
<span class="p_chunk">@@ -3454,6 +3454,11 @@</span> <span class="p_context"> static int rtl8152_probe(struct usb_interface *intf,</span>
 			      NETIF_F_TSO | NETIF_F_FRAGLIST |
 			      NETIF_F_IPV6_CSUM | NETIF_F_TSO6;
 
<span class="p_add">+	if (tp-&gt;version == RTL_VER_01) {</span>
<span class="p_add">+		netdev-&gt;features &amp;= ~NETIF_F_RXCSUM;</span>
<span class="p_add">+		netdev-&gt;hw_features &amp;= ~NETIF_F_RXCSUM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	netdev-&gt;ethtool_ops = &amp;ops;
 	netif_set_gso_max_size(netdev, RTL_LIMITED_TSO_SIZE);
 
<span class="p_header">diff --git a/drivers/net/usb/rtl8150.c b/drivers/net/usb/rtl8150.c</span>
<span class="p_header">index 6e87e5710048..eab8fba1f8c9 100644</span>
<span class="p_header">--- a/drivers/net/usb/rtl8150.c</span>
<span class="p_header">+++ b/drivers/net/usb/rtl8150.c</span>
<span class="p_chunk">@@ -155,16 +155,36 @@</span> <span class="p_context"> static const char driver_name [] = &quot;rtl8150&quot;;</span>
 */
 static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)
 {
<span class="p_del">-	return usb_control_msg(dev-&gt;udev, usb_rcvctrlpipe(dev-&gt;udev, 0),</span>
<span class="p_del">-			       RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,</span>
<span class="p_del">-			       indx, 0, data, size, 500);</span>
<span class="p_add">+	void *buf;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	buf = kmalloc(size, GFP_NOIO);</span>
<span class="p_add">+	if (!buf)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = usb_control_msg(dev-&gt;udev, usb_rcvctrlpipe(dev-&gt;udev, 0),</span>
<span class="p_add">+			      RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,</span>
<span class="p_add">+			      indx, 0, buf, size, 500);</span>
<span class="p_add">+	if (ret &gt; 0 &amp;&amp; ret &lt;= size)</span>
<span class="p_add">+		memcpy(data, buf, ret);</span>
<span class="p_add">+	kfree(buf);</span>
<span class="p_add">+	return ret;</span>
 }
 
<span class="p_del">-static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)</span>
<span class="p_add">+static int set_registers(rtl8150_t * dev, u16 indx, u16 size, const void *data)</span>
 {
<span class="p_del">-	return usb_control_msg(dev-&gt;udev, usb_sndctrlpipe(dev-&gt;udev, 0),</span>
<span class="p_del">-			       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,</span>
<span class="p_del">-			       indx, 0, data, size, 500);</span>
<span class="p_add">+	void *buf;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	buf = kmemdup(data, size, GFP_NOIO);</span>
<span class="p_add">+	if (!buf)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = usb_control_msg(dev-&gt;udev, usb_sndctrlpipe(dev-&gt;udev, 0),</span>
<span class="p_add">+			      RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,</span>
<span class="p_add">+			      indx, 0, buf, size, 500);</span>
<span class="p_add">+	kfree(buf);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static void async_set_reg_cb(struct urb *urb)
<span class="p_header">diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c</span>
<span class="p_header">index 74dccfa00a5c..7badf2aa3f61 100644</span>
<span class="p_header">--- a/drivers/net/vxlan.c</span>
<span class="p_header">+++ b/drivers/net/vxlan.c</span>
<span class="p_chunk">@@ -1146,7 +1146,7 @@</span> <span class="p_context"> static int vxlan_udp_encap_recv(struct sock *sk, struct sk_buff *skb)</span>
 
 	/* Need Vxlan and inner Ethernet header to be present */
 	if (!pskb_may_pull(skb, VXLAN_HLEN))
<span class="p_del">-		goto error;</span>
<span class="p_add">+		goto drop;</span>
 
 	/* Return packets with reserved bits set */
 	vxh = (struct vxlanhdr *)(udp_hdr(skb) + 1);
<span class="p_chunk">@@ -1154,7 +1154,7 @@</span> <span class="p_context"> static int vxlan_udp_encap_recv(struct sock *sk, struct sk_buff *skb)</span>
 	    (vxh-&gt;vx_vni &amp; htonl(0xff))) {
 		netdev_dbg(skb-&gt;dev, &quot;invalid vxlan flags=%#x vni=%#x\n&quot;,
 			   ntohl(vxh-&gt;vx_flags), ntohl(vxh-&gt;vx_vni));
<span class="p_del">-		goto error;</span>
<span class="p_add">+		goto drop;</span>
 	}
 
 	if (iptunnel_pull_header(skb, VXLAN_HLEN, htons(ETH_P_TEB)))
<span class="p_chunk">@@ -1173,10 +1173,6 @@</span> <span class="p_context"> drop:</span>
 	/* Consume bad packet */
 	kfree_skb(skb);
 	return 0;
<span class="p_del">-</span>
<span class="p_del">-error:</span>
<span class="p_del">-	/* Return non vxlan pkt */</span>
<span class="p_del">-	return 1;</span>
 }
 
 static void vxlan_rcv(struct vxlan_sock *vs,
<span class="p_header">diff --git a/drivers/net/xen-netfront.c b/drivers/net/xen-netfront.c</span>
<span class="p_header">index 567d5c31dfd2..ea6b55abd42d 100644</span>
<span class="p_header">--- a/drivers/net/xen-netfront.c</span>
<span class="p_header">+++ b/drivers/net/xen-netfront.c</span>
<span class="p_chunk">@@ -1440,6 +1440,8 @@</span> <span class="p_context"> static void xennet_disconnect_backend(struct netfront_info *info)</span>
 	for (i = 0; i &lt; num_queues; ++i) {
 		struct netfront_queue *queue = &amp;info-&gt;queues[i];
 
<span class="p_add">+		del_timer_sync(&amp;queue-&gt;rx_refill_timer);</span>
<span class="p_add">+</span>
 		if (queue-&gt;tx_irq &amp;&amp; (queue-&gt;tx_irq == queue-&gt;rx_irq))
 			unbind_from_irqhandler(queue-&gt;tx_irq, queue);
 		if (queue-&gt;tx_irq &amp;&amp; (queue-&gt;tx_irq != queue-&gt;rx_irq)) {
<span class="p_chunk">@@ -2360,8 +2362,6 @@</span> <span class="p_context"> static int xennet_remove(struct xenbus_device *dev)</span>
 {
 	struct netfront_info *info = dev_get_drvdata(&amp;dev-&gt;dev);
 	unsigned int num_queues = info-&gt;netdev-&gt;real_num_tx_queues;
<span class="p_del">-	struct netfront_queue *queue = NULL;</span>
<span class="p_del">-	unsigned int i = 0;</span>
 
 	dev_dbg(&amp;dev-&gt;dev, &quot;%s\n&quot;, dev-&gt;nodename);
 
<span class="p_chunk">@@ -2371,11 +2371,6 @@</span> <span class="p_context"> static int xennet_remove(struct xenbus_device *dev)</span>
 
 	unregister_netdev(info-&gt;netdev);
 
<span class="p_del">-	for (i = 0; i &lt; num_queues; ++i) {</span>
<span class="p_del">-		queue = &amp;info-&gt;queues[i];</span>
<span class="p_del">-		del_timer_sync(&amp;queue-&gt;rx_refill_timer);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	if (num_queues) {
 		kfree(info-&gt;queues);
 		info-&gt;queues = NULL;
<span class="p_header">diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c</span>
<span class="p_header">index 7660232ef460..6d82498f1e60 100644</span>
<span class="p_header">--- a/drivers/pci/hotplug/rpadlpar_core.c</span>
<span class="p_header">+++ b/drivers/pci/hotplug/rpadlpar_core.c</span>
<span class="p_chunk">@@ -258,8 +258,13 @@</span> <span class="p_context"> static int dlpar_add_phb(char *drc_name, struct device_node *dn)</span>
 
 static int dlpar_add_vio_slot(char *drc_name, struct device_node *dn)
 {
<span class="p_del">-	if (vio_find_node(dn))</span>
<span class="p_add">+	struct vio_dev *vio_dev;</span>
<span class="p_add">+</span>
<span class="p_add">+	vio_dev = vio_find_node(dn);</span>
<span class="p_add">+	if (vio_dev) {</span>
<span class="p_add">+		put_device(&amp;vio_dev-&gt;dev);</span>
 		return -EINVAL;
<span class="p_add">+	}</span>
 
 	if (!vio_register_device_node(dn)) {
 		printk(KERN_ERR
<span class="p_chunk">@@ -335,6 +340,9 @@</span> <span class="p_context"> static int dlpar_remove_vio_slot(char *drc_name, struct device_node *dn)</span>
 		return -EINVAL;
 
 	vio_unregister_device(vio_dev);
<span class="p_add">+</span>
<span class="p_add">+	put_device(&amp;vio_dev-&gt;dev);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c</span>
<span class="p_header">index 3e981329c7a9..2e54269f5458 100644</span>
<span class="p_header">--- a/drivers/pci/pci.c</span>
<span class="p_header">+++ b/drivers/pci/pci.c</span>
<span class="p_chunk">@@ -1982,6 +1982,10 @@</span> <span class="p_context"> bool pci_dev_run_wake(struct pci_dev *dev)</span>
 	if (!dev-&gt;pme_support)
 		return false;
 
<span class="p_add">+	/* PME-capable in principle, but not from the intended sleep state */</span>
<span class="p_add">+	if (!pci_pme_capable(dev, pci_target_state(dev)))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
 	while (bus-&gt;parent) {
 		struct pci_dev *bridge = bus-&gt;self;
 
<span class="p_header">diff --git a/drivers/platform/x86/intel_mid_powerbtn.c b/drivers/platform/x86/intel_mid_powerbtn.c</span>
<span class="p_header">index 8d6775266d66..04dc5ab2e30d 100644</span>
<span class="p_header">--- a/drivers/platform/x86/intel_mid_powerbtn.c</span>
<span class="p_header">+++ b/drivers/platform/x86/intel_mid_powerbtn.c</span>
<span class="p_chunk">@@ -76,7 +76,7 @@</span> <span class="p_context"> static int mfld_pb_probe(struct platform_device *pdev)</span>
 
 	input_set_capability(input, EV_KEY, KEY_POWER);
 
<span class="p_del">-	error = request_threaded_irq(irq, NULL, mfld_pb_isr, IRQF_NO_SUSPEND,</span>
<span class="p_add">+	error = request_threaded_irq(irq, NULL, mfld_pb_isr, IRQF_NO_SUSPEND | IRQF_ONESHOT,</span>
 			DRIVER_NAME, input);
 	if (error) {
 		dev_err(&amp;pdev-&gt;dev, &quot;Unable to request irq %d for mfld power&quot;
<span class="p_header">diff --git a/drivers/regulator/stw481x-vmmc.c b/drivers/regulator/stw481x-vmmc.c</span>
<span class="p_header">index a7e152696a02..f140b42956a4 100644</span>
<span class="p_header">--- a/drivers/regulator/stw481x-vmmc.c</span>
<span class="p_header">+++ b/drivers/regulator/stw481x-vmmc.c</span>
<span class="p_chunk">@@ -47,7 +47,8 @@</span> <span class="p_context"> static struct regulator_desc vmmc_regulator = {</span>
 	.volt_table = stw481x_vmmc_voltages,
 	.enable_time = 200, /* FIXME: look this up */
 	.enable_reg = STW_CONF1,
<span class="p_del">-	.enable_mask = STW_CONF1_PDN_VMMC,</span>
<span class="p_add">+	.enable_mask = STW_CONF1_PDN_VMMC | STW_CONF1_MMC_LS_STATUS,</span>
<span class="p_add">+	.enable_val = STW_CONF1_PDN_VMMC,</span>
 	.vsel_reg = STW_CONF1,
 	.vsel_mask = STW_CONF1_VMMC_MASK,
 };
<span class="p_header">diff --git a/drivers/s390/char/vmlogrdr.c b/drivers/s390/char/vmlogrdr.c</span>
<span class="p_header">index a8848db7b09d..064ffed2589d 100644</span>
<span class="p_header">--- a/drivers/s390/char/vmlogrdr.c</span>
<span class="p_header">+++ b/drivers/s390/char/vmlogrdr.c</span>
<span class="p_chunk">@@ -873,7 +873,7 @@</span> <span class="p_context"> static int __init vmlogrdr_init(void)</span>
 		goto cleanup;
 
 	for (i=0; i &lt; MAXMINOR; ++i ) {
<span class="p_del">-		sys_ser[i].buffer = (char *) get_zeroed_page(GFP_KERNEL);</span>
<span class="p_add">+		sys_ser[i].buffer = (char *) get_zeroed_page(GFP_KERNEL | GFP_DMA);</span>
 		if (!sys_ser[i].buffer) {
 			rc = -ENOMEM;
 			break;
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_dbf.c b/drivers/s390/scsi/zfcp_dbf.c</span>
<span class="p_header">index 7b1fbd303c29..598b577760ef 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_dbf.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_dbf.c</span>
<span class="p_chunk">@@ -289,11 +289,12 @@</span> <span class="p_context"> void zfcp_dbf_rec_trig(char *tag, struct zfcp_adapter *adapter,</span>
 
 
 /**
<span class="p_del">- * zfcp_dbf_rec_run - trace event related to running recovery</span>
<span class="p_add">+ * zfcp_dbf_rec_run_lvl - trace event related to running recovery</span>
<span class="p_add">+ * @level: trace level to be used for event</span>
  * @tag: identifier for event
  * @erp: erp_action running
  */
<span class="p_del">-void zfcp_dbf_rec_run(char *tag, struct zfcp_erp_action *erp)</span>
<span class="p_add">+void zfcp_dbf_rec_run_lvl(int level, char *tag, struct zfcp_erp_action *erp)</span>
 {
 	struct zfcp_dbf *dbf = erp-&gt;adapter-&gt;dbf;
 	struct zfcp_dbf_rec *rec = &amp;dbf-&gt;rec_buf;
<span class="p_chunk">@@ -319,11 +320,21 @@</span> <span class="p_context"> void zfcp_dbf_rec_run(char *tag, struct zfcp_erp_action *erp)</span>
 	else
 		rec-&gt;u.run.rec_count = atomic_read(&amp;erp-&gt;adapter-&gt;erp_counter);
 
<span class="p_del">-	debug_event(dbf-&gt;rec, 1, rec, sizeof(*rec));</span>
<span class="p_add">+	debug_event(dbf-&gt;rec, level, rec, sizeof(*rec));</span>
 	spin_unlock_irqrestore(&amp;dbf-&gt;rec_lock, flags);
 }
 
 /**
<span class="p_add">+ * zfcp_dbf_rec_run - trace event related to running recovery</span>
<span class="p_add">+ * @tag: identifier for event</span>
<span class="p_add">+ * @erp: erp_action running</span>
<span class="p_add">+ */</span>
<span class="p_add">+void zfcp_dbf_rec_run(char *tag, struct zfcp_erp_action *erp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	zfcp_dbf_rec_run_lvl(1, tag, erp);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * zfcp_dbf_rec_run_wka - trace wka port event with info like running recovery
  * @tag: identifier for event
  * @wka_port: well known address port
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h</span>
<span class="p_header">index 36d07584271d..db186d44cfaf 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_dbf.h</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_dbf.h</span>
<span class="p_chunk">@@ -2,7 +2,7 @@</span> <span class="p_context"></span>
  * zfcp device driver
  * debug feature declarations
  *
<span class="p_del">- * Copyright IBM Corp. 2008, 2015</span>
<span class="p_add">+ * Copyright IBM Corp. 2008, 2016</span>
  */
 
 #ifndef ZFCP_DBF_H
<span class="p_chunk">@@ -283,6 +283,30 @@</span> <span class="p_context"> struct zfcp_dbf {</span>
 	struct zfcp_dbf_scsi		scsi_buf;
 };
 
<span class="p_add">+/**</span>
<span class="p_add">+ * zfcp_dbf_hba_fsf_resp_suppress - true if we should not trace by default</span>
<span class="p_add">+ * @req: request that has been completed</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns true if FCP response with only benign residual under count.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline</span>
<span class="p_add">+bool zfcp_dbf_hba_fsf_resp_suppress(struct zfcp_fsf_req *req)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct fsf_qtcb *qtcb = req-&gt;qtcb;</span>
<span class="p_add">+	u32 fsf_stat = qtcb-&gt;header.fsf_status;</span>
<span class="p_add">+	struct fcp_resp *fcp_rsp;</span>
<span class="p_add">+	u8 rsp_flags, fr_status;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (qtcb-&gt;prefix.qtcb_type != FSF_IO_COMMAND)</span>
<span class="p_add">+		return false; /* not an FCP response */</span>
<span class="p_add">+	fcp_rsp = (struct fcp_resp *)&amp;qtcb-&gt;bottom.io.fcp_rsp;</span>
<span class="p_add">+	rsp_flags = fcp_rsp-&gt;fr_flags;</span>
<span class="p_add">+	fr_status = fcp_rsp-&gt;fr_status;</span>
<span class="p_add">+	return (fsf_stat == FSF_FCP_RSP_AVAILABLE) &amp;&amp;</span>
<span class="p_add">+		(rsp_flags == FCP_RESID_UNDER) &amp;&amp;</span>
<span class="p_add">+		(fr_status == SAM_STAT_GOOD);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline
 void zfcp_dbf_hba_fsf_resp(char *tag, int level, struct zfcp_fsf_req *req)
 {
<span class="p_chunk">@@ -304,7 +328,9 @@</span> <span class="p_context"> void zfcp_dbf_hba_fsf_response(struct zfcp_fsf_req *req)</span>
 		zfcp_dbf_hba_fsf_resp(&quot;fs_perr&quot;, 1, req);
 
 	} else if (qtcb-&gt;header.fsf_status != FSF_GOOD) {
<span class="p_del">-		zfcp_dbf_hba_fsf_resp(&quot;fs_ferr&quot;, 1, req);</span>
<span class="p_add">+		zfcp_dbf_hba_fsf_resp(&quot;fs_ferr&quot;,</span>
<span class="p_add">+				      zfcp_dbf_hba_fsf_resp_suppress(req)</span>
<span class="p_add">+				      ? 5 : 1, req);</span>
 
 	} else if ((req-&gt;fsf_command == FSF_QTCB_OPEN_PORT_WITH_DID) ||
 		   (req-&gt;fsf_command == FSF_QTCB_OPEN_LUN)) {
<span class="p_chunk">@@ -388,4 +414,15 @@</span> <span class="p_context"> void zfcp_dbf_scsi_devreset(char *tag, struct scsi_cmnd *scmnd, u8 flag)</span>
 	_zfcp_dbf_scsi(tmp_tag, 1, scmnd, NULL);
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * zfcp_dbf_scsi_nullcmnd() - trace NULLify of SCSI command in dev/tgt-reset.</span>
<span class="p_add">+ * @scmnd: SCSI command that was NULLified.</span>
<span class="p_add">+ * @fsf_req: request that owned @scmnd.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void zfcp_dbf_scsi_nullcmnd(struct scsi_cmnd *scmnd,</span>
<span class="p_add">+					  struct zfcp_fsf_req *fsf_req)</span>
<span class="p_add">+{</span>
<span class="p_add">+	_zfcp_dbf_scsi(&quot;scfc__1&quot;, 3, scmnd, fsf_req);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif /* ZFCP_DBF_H */
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_erp.c b/drivers/s390/scsi/zfcp_erp.c</span>
<span class="p_header">index ac86ff90c897..acb0b8c3989d 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_erp.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_erp.c</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Error Recovery Procedures (ERP).
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2015</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2016</span>
  */
 
 #define KMSG_COMPONENT &quot;zfcp&quot;
<span class="p_chunk">@@ -1211,6 +1211,62 @@</span> <span class="p_context"> static void zfcp_erp_action_dequeue(struct zfcp_erp_action *erp_action)</span>
 	}
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * zfcp_erp_try_rport_unblock - unblock rport if no more/new recovery</span>
<span class="p_add">+ * @port: zfcp_port whose fc_rport we should try to unblock</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void zfcp_erp_try_rport_unblock(struct zfcp_port *port)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	struct zfcp_adapter *adapter = port-&gt;adapter;</span>
<span class="p_add">+	int port_status;</span>
<span class="p_add">+	struct Scsi_Host *shost = adapter-&gt;scsi_host;</span>
<span class="p_add">+	struct scsi_device *sdev;</span>
<span class="p_add">+</span>
<span class="p_add">+	write_lock_irqsave(&amp;adapter-&gt;erp_lock, flags);</span>
<span class="p_add">+	port_status = atomic_read(&amp;port-&gt;status);</span>
<span class="p_add">+	if ((port_status &amp; ZFCP_STATUS_COMMON_UNBLOCKED)    == 0 ||</span>
<span class="p_add">+	    (port_status &amp; (ZFCP_STATUS_COMMON_ERP_INUSE |</span>
<span class="p_add">+			    ZFCP_STATUS_COMMON_ERP_FAILED)) != 0) {</span>
<span class="p_add">+		/* new ERP of severity &gt;= port triggered elsewhere meanwhile or</span>
<span class="p_add">+		 * local link down (adapter erp_failed but not clear unblock)</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		zfcp_dbf_rec_run_lvl(4, &quot;ertru_p&quot;, &amp;port-&gt;erp_action);</span>
<span class="p_add">+		write_unlock_irqrestore(&amp;adapter-&gt;erp_lock, flags);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_lock(shost-&gt;host_lock);</span>
<span class="p_add">+	__shost_for_each_device(sdev, shost) {</span>
<span class="p_add">+		struct zfcp_scsi_dev *zsdev = sdev_to_zfcp(sdev);</span>
<span class="p_add">+		int lun_status;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (zsdev-&gt;port != port)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		/* LUN under port of interest */</span>
<span class="p_add">+		lun_status = atomic_read(&amp;zsdev-&gt;status);</span>
<span class="p_add">+		if ((lun_status &amp; ZFCP_STATUS_COMMON_ERP_FAILED) != 0)</span>
<span class="p_add">+			continue; /* unblock rport despite failed LUNs */</span>
<span class="p_add">+		/* LUN recovery not given up yet [maybe follow-up pending] */</span>
<span class="p_add">+		if ((lun_status &amp; ZFCP_STATUS_COMMON_UNBLOCKED) == 0 ||</span>
<span class="p_add">+		    (lun_status &amp; ZFCP_STATUS_COMMON_ERP_INUSE) != 0) {</span>
<span class="p_add">+			/* LUN blocked:</span>
<span class="p_add">+			 * not yet unblocked [LUN recovery pending]</span>
<span class="p_add">+			 * or meanwhile blocked [new LUN recovery triggered]</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			zfcp_dbf_rec_run_lvl(4, &quot;ertru_l&quot;, &amp;zsdev-&gt;erp_action);</span>
<span class="p_add">+			spin_unlock(shost-&gt;host_lock);</span>
<span class="p_add">+			write_unlock_irqrestore(&amp;adapter-&gt;erp_lock, flags);</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* now port has no child or all children have completed recovery,</span>
<span class="p_add">+	 * and no ERP of severity &gt;= port was meanwhile triggered elsewhere</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	zfcp_scsi_schedule_rport_register(port);</span>
<span class="p_add">+	spin_unlock(shost-&gt;host_lock);</span>
<span class="p_add">+	write_unlock_irqrestore(&amp;adapter-&gt;erp_lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void zfcp_erp_action_cleanup(struct zfcp_erp_action *act, int result)
 {
 	struct zfcp_adapter *adapter = act-&gt;adapter;
<span class="p_chunk">@@ -1221,6 +1277,7 @@</span> <span class="p_context"> static void zfcp_erp_action_cleanup(struct zfcp_erp_action *act, int result)</span>
 	case ZFCP_ERP_ACTION_REOPEN_LUN:
 		if (!(act-&gt;status &amp; ZFCP_STATUS_ERP_NO_REF))
 			scsi_device_put(sdev);
<span class="p_add">+		zfcp_erp_try_rport_unblock(port);</span>
 		break;
 
 	case ZFCP_ERP_ACTION_REOPEN_PORT:
<span class="p_chunk">@@ -1231,7 +1288,7 @@</span> <span class="p_context"> static void zfcp_erp_action_cleanup(struct zfcp_erp_action *act, int result)</span>
 		 */
 		if (act-&gt;step != ZFCP_ERP_STEP_UNINITIALIZED)
 			if (result == ZFCP_ERP_SUCCEEDED)
<span class="p_del">-				zfcp_scsi_schedule_rport_register(port);</span>
<span class="p_add">+				zfcp_erp_try_rport_unblock(port);</span>
 		/* fall through */
 	case ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:
 		put_device(&amp;port-&gt;dev);
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_ext.h b/drivers/s390/scsi/zfcp_ext.h</span>
<span class="p_header">index 1f1fe41ecb97..0c8c8b8fc1de 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_ext.h</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_ext.h</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * External function declarations.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2015</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2016</span>
  */
 
 #ifndef ZFCP_EXT_H
<span class="p_chunk">@@ -35,6 +35,8 @@</span> <span class="p_context"> extern void zfcp_dbf_adapter_unregister(struct zfcp_adapter *);</span>
 extern void zfcp_dbf_rec_trig(char *, struct zfcp_adapter *,
 			      struct zfcp_port *, struct scsi_device *, u8, u8);
 extern void zfcp_dbf_rec_run(char *, struct zfcp_erp_action *);
<span class="p_add">+extern void zfcp_dbf_rec_run_lvl(int level, char *tag,</span>
<span class="p_add">+				 struct zfcp_erp_action *erp);</span>
 extern void zfcp_dbf_rec_run_wka(char *, struct zfcp_fc_wka_port *, u64);
 extern void zfcp_dbf_hba_fsf_uss(char *, struct zfcp_fsf_req *);
 extern void zfcp_dbf_hba_fsf_res(char *, int, struct zfcp_fsf_req *);
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_fsf.c b/drivers/s390/scsi/zfcp_fsf.c</span>
<span class="p_header">index 6065212fdeed..36cf11cafee7 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_fsf.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_fsf.c</span>
<span class="p_chunk">@@ -1584,7 +1584,7 @@</span> <span class="p_context"> out:</span>
 int zfcp_fsf_open_wka_port(struct zfcp_fc_wka_port *wka_port)
 {
 	struct zfcp_qdio *qdio = wka_port-&gt;adapter-&gt;qdio;
<span class="p_del">-	struct zfcp_fsf_req *req = NULL;</span>
<span class="p_add">+	struct zfcp_fsf_req *req;</span>
 	int retval = -EIO;
 
 	spin_lock_irq(&amp;qdio-&gt;req_q_lock);
<span class="p_chunk">@@ -1613,7 +1613,7 @@</span> <span class="p_context"> int zfcp_fsf_open_wka_port(struct zfcp_fc_wka_port *wka_port)</span>
 		zfcp_fsf_req_free(req);
 out:
 	spin_unlock_irq(&amp;qdio-&gt;req_q_lock);
<span class="p_del">-	if (req &amp;&amp; !IS_ERR(req))</span>
<span class="p_add">+	if (!retval)</span>
 		zfcp_dbf_rec_run_wka(&quot;fsowp_1&quot;, wka_port, req-&gt;req_id);
 	return retval;
 }
<span class="p_chunk">@@ -1639,7 +1639,7 @@</span> <span class="p_context"> static void zfcp_fsf_close_wka_port_handler(struct zfcp_fsf_req *req)</span>
 int zfcp_fsf_close_wka_port(struct zfcp_fc_wka_port *wka_port)
 {
 	struct zfcp_qdio *qdio = wka_port-&gt;adapter-&gt;qdio;
<span class="p_del">-	struct zfcp_fsf_req *req = NULL;</span>
<span class="p_add">+	struct zfcp_fsf_req *req;</span>
 	int retval = -EIO;
 
 	spin_lock_irq(&amp;qdio-&gt;req_q_lock);
<span class="p_chunk">@@ -1668,7 +1668,7 @@</span> <span class="p_context"> int zfcp_fsf_close_wka_port(struct zfcp_fc_wka_port *wka_port)</span>
 		zfcp_fsf_req_free(req);
 out:
 	spin_unlock_irq(&amp;qdio-&gt;req_q_lock);
<span class="p_del">-	if (req &amp;&amp; !IS_ERR(req))</span>
<span class="p_add">+	if (!retval)</span>
 		zfcp_dbf_rec_run_wka(&quot;fscwp_1&quot;, wka_port, req-&gt;req_id);
 	return retval;
 }
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_fsf.h b/drivers/s390/scsi/zfcp_fsf.h</span>
<span class="p_header">index be1c04b334c5..ea3c76ac0de1 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_fsf.h</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_fsf.h</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Interface to the FSF support functions.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2015</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2016</span>
  */
 
 #ifndef FSF_H
<span class="p_chunk">@@ -78,6 +78,7 @@</span> <span class="p_context"></span>
 #define FSF_APP_TAG_CHECK_FAILURE		0x00000082
 #define FSF_REF_TAG_CHECK_FAILURE		0x00000083
 #define FSF_ADAPTER_STATUS_AVAILABLE		0x000000AD
<span class="p_add">+#define FSF_FCP_RSP_AVAILABLE			0x000000AF</span>
 #define FSF_UNKNOWN_COMMAND			0x000000E2
 #define FSF_UNKNOWN_OP_SUBTYPE                  0x000000E3
 #define FSF_INVALID_COMMAND_OPTION              0x000000E5
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_reqlist.h b/drivers/s390/scsi/zfcp_reqlist.h</span>
<span class="p_header">index 7c2c6194dfca..703fce59befe 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_reqlist.h</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_reqlist.h</span>
<span class="p_chunk">@@ -4,7 +4,7 @@</span> <span class="p_context"></span>
  * Data structure and helper functions for tracking pending FSF
  * requests.
  *
<span class="p_del">- * Copyright IBM Corp. 2009</span>
<span class="p_add">+ * Copyright IBM Corp. 2009, 2016</span>
  */
 
 #ifndef ZFCP_REQLIST_H
<span class="p_chunk">@@ -180,4 +180,32 @@</span> <span class="p_context"> static inline void zfcp_reqlist_move(struct zfcp_reqlist *rl,</span>
 	spin_unlock_irqrestore(&amp;rl-&gt;lock, flags);
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * zfcp_reqlist_apply_for_all() - apply a function to every request.</span>
<span class="p_add">+ * @rl: the requestlist that contains the target requests.</span>
<span class="p_add">+ * @f: the function to apply to each request; the first parameter of the</span>
<span class="p_add">+ *     function will be the target-request; the second parameter is the same</span>
<span class="p_add">+ *     pointer as given with the argument @data.</span>
<span class="p_add">+ * @data: freely chosen argument; passed through to @f as second parameter.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Uses :c:macro:`list_for_each_entry` to iterate over the lists in the hash-</span>
<span class="p_add">+ * table (not a &#39;safe&#39; variant, so don&#39;t modify the list).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Holds @rl-&gt;lock over the entire request-iteration.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void</span>
<span class="p_add">+zfcp_reqlist_apply_for_all(struct zfcp_reqlist *rl,</span>
<span class="p_add">+			   void (*f)(struct zfcp_fsf_req *, void *), void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct zfcp_fsf_req *req;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	unsigned int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;rl-&gt;lock, flags);</span>
<span class="p_add">+	for (i = 0; i &lt; ZFCP_REQ_LIST_BUCKETS; i++)</span>
<span class="p_add">+		list_for_each_entry(req, &amp;rl-&gt;buckets[i], list)</span>
<span class="p_add">+			f(req, data);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;rl-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif /* ZFCP_REQLIST_H */
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_header">index 38ee0df633a3..66c37e77ac7c 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Interface to Linux SCSI midlayer.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2015</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2016</span>
  */
 
 #define KMSG_COMPONENT &quot;zfcp&quot;
<span class="p_chunk">@@ -109,9 +109,7 @@</span> <span class="p_context"> int zfcp_scsi_queuecommand(struct Scsi_Host *shost, struct scsi_cmnd *scpnt)</span>
 	}
 
 	if (unlikely(!(status &amp; ZFCP_STATUS_COMMON_UNBLOCKED))) {
<span class="p_del">-		/* This could be either</span>
<span class="p_del">-		 * open LUN pending: this is temporary, will result in</span>
<span class="p_del">-		 *	open LUN or ERP_FAILED, so retry command</span>
<span class="p_add">+		/* This could be</span>
 		 * call to rport_delete pending: mimic retry from
 		 * 	fc_remote_port_chkready until rport is BLOCKED
 		 */
<span class="p_chunk">@@ -230,6 +228,57 @@</span> <span class="p_context"> static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)</span>
 	return retval;
 }
 
<span class="p_add">+struct zfcp_scsi_req_filter {</span>
<span class="p_add">+	u8 tmf_scope;</span>
<span class="p_add">+	u32 lun_handle;</span>
<span class="p_add">+	u32 port_handle;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static void zfcp_scsi_forget_cmnd(struct zfcp_fsf_req *old_req, void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct zfcp_scsi_req_filter *filter =</span>
<span class="p_add">+		(struct zfcp_scsi_req_filter *)data;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* already aborted - prevent side-effects - or not a SCSI command */</span>
<span class="p_add">+	if (old_req-&gt;data == NULL || old_req-&gt;fsf_command != FSF_QTCB_FCP_CMND)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* (tmf_scope == FCP_TMF_TGT_RESET || tmf_scope == FCP_TMF_LUN_RESET) */</span>
<span class="p_add">+	if (old_req-&gt;qtcb-&gt;header.port_handle != filter-&gt;port_handle)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (filter-&gt;tmf_scope == FCP_TMF_LUN_RESET &amp;&amp;</span>
<span class="p_add">+	    old_req-&gt;qtcb-&gt;header.lun_handle != filter-&gt;lun_handle)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	zfcp_dbf_scsi_nullcmnd((struct scsi_cmnd *)old_req-&gt;data, old_req);</span>
<span class="p_add">+	old_req-&gt;data = NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void zfcp_scsi_forget_cmnds(struct zfcp_scsi_dev *zsdev, u8 tm_flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct zfcp_adapter *adapter = zsdev-&gt;port-&gt;adapter;</span>
<span class="p_add">+	struct zfcp_scsi_req_filter filter = {</span>
<span class="p_add">+		.tmf_scope = FCP_TMF_TGT_RESET,</span>
<span class="p_add">+		.port_handle = zsdev-&gt;port-&gt;handle,</span>
<span class="p_add">+	};</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tm_flags == FCP_TMF_LUN_RESET) {</span>
<span class="p_add">+		filter.tmf_scope = FCP_TMF_LUN_RESET;</span>
<span class="p_add">+		filter.lun_handle = zsdev-&gt;lun_handle;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * abort_lock secures against other processings - in the abort-function</span>
<span class="p_add">+	 * and normal cmnd-handler - of (struct zfcp_fsf_req *)-&gt;data</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	write_lock_irqsave(&amp;adapter-&gt;abort_lock, flags);</span>
<span class="p_add">+	zfcp_reqlist_apply_for_all(adapter-&gt;req_list, zfcp_scsi_forget_cmnd,</span>
<span class="p_add">+				   &amp;filter);</span>
<span class="p_add">+	write_unlock_irqrestore(&amp;adapter-&gt;abort_lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 {
 	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(scpnt-&gt;device);
<span class="p_chunk">@@ -262,8 +311,10 @@</span> <span class="p_context"> static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)</span>
 	if (fsf_req-&gt;status &amp; ZFCP_STATUS_FSFREQ_TMFUNCFAILED) {
 		zfcp_dbf_scsi_devreset(&quot;fail&quot;, scpnt, tm_flags);
 		retval = FAILED;
<span class="p_del">-	} else</span>
<span class="p_add">+	} else {</span>
 		zfcp_dbf_scsi_devreset(&quot;okay&quot;, scpnt, tm_flags);
<span class="p_add">+		zfcp_scsi_forget_cmnds(zfcp_sdev, tm_flags);</span>
<span class="p_add">+	}</span>
 
 	zfcp_fsf_req_free(fsf_req);
 	return retval;
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_fusion.c b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">index 560bbbd03788..5f335917f477 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_chunk">@@ -2291,6 +2291,7 @@</span> <span class="p_context"> int megasas_wait_for_outstanding_fusion(struct megasas_instance *instance,</span>
 		printk(&quot;megaraid_sas: pending commands remain after waiting, &quot;
 		       &quot;will reset adapter scsi%d.\n&quot;,
 		       instance-&gt;host-&gt;host_no);
<span class="p_add">+		*convert = 1;</span>
 		retval = 1;
 	}
 out:
<span class="p_header">diff --git a/drivers/scsi/mvsas/mv_94xx.c b/drivers/scsi/mvsas/mv_94xx.c</span>
<span class="p_header">index 9270d15ff1a4..7353ac8d0d39 100644</span>
<span class="p_header">--- a/drivers/scsi/mvsas/mv_94xx.c</span>
<span class="p_header">+++ b/drivers/scsi/mvsas/mv_94xx.c</span>
<span class="p_chunk">@@ -621,7 +621,7 @@</span> <span class="p_context"> static void mvs_94xx_command_active(struct mvs_info *mvi, u32 slot_idx)</span>
 {
 	u32 tmp;
 	tmp = mvs_cr32(mvi, MVS_COMMAND_ACTIVE+(slot_idx &gt;&gt; 3));
<span class="p_del">-	if (tmp &amp;&amp; 1 &lt;&lt; (slot_idx % 32)) {</span>
<span class="p_add">+	if (tmp &amp; 1 &lt;&lt; (slot_idx % 32)) {</span>
 		mv_printk(&quot;command active %08X,  slot [%x].\n&quot;, tmp, slot_idx);
 		mvs_cw32(mvi, MVS_COMMAND_ACTIVE + (slot_idx &gt;&gt; 3),
 			1 &lt;&lt; (slot_idx % 32));
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_os.c b/drivers/scsi/qla2xxx/qla_os.c</span>
<span class="p_header">index 5072251cdb8b..c770ef886dc2 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_os.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_os.c</span>
<span class="p_chunk">@@ -3393,7 +3393,7 @@</span> <span class="p_context"> qla2x00_mem_alloc(struct qla_hw_data *ha, uint16_t req_len, uint16_t rsp_len,</span>
 				sizeof(struct ct6_dsd), 0,
 				SLAB_HWCACHE_ALIGN, NULL);
 			if (!ctx_cachep)
<span class="p_del">-				goto fail_free_gid_list;</span>
<span class="p_add">+				goto fail_free_srb_mempool;</span>
 		}
 		ha-&gt;ctx_mempool = mempool_create_slab_pool(SRB_MIN_REQ,
 			ctx_cachep);
<span class="p_chunk">@@ -3546,7 +3546,7 @@</span> <span class="p_context"> qla2x00_mem_alloc(struct qla_hw_data *ha, uint16_t req_len, uint16_t rsp_len,</span>
 	ha-&gt;loop_id_map = kzalloc(BITS_TO_LONGS(LOOPID_MAP_SIZE) * sizeof(long),
 	    GFP_KERNEL);
 	if (!ha-&gt;loop_id_map)
<span class="p_del">-		goto fail_async_pd;</span>
<span class="p_add">+		goto fail_loop_id_map;</span>
 	else {
 		qla2x00_set_reserved_loop_ids(ha);
 		ql_dbg_pci(ql_dbg_init, ha-&gt;pdev, 0x0123,
<span class="p_chunk">@@ -3555,6 +3555,8 @@</span> <span class="p_context"> qla2x00_mem_alloc(struct qla_hw_data *ha, uint16_t req_len, uint16_t rsp_len,</span>
 
 	return 0;
 
<span class="p_add">+fail_loop_id_map:</span>
<span class="p_add">+	dma_pool_free(ha-&gt;s_dma_pool, ha-&gt;async_pd, ha-&gt;async_pd_dma);</span>
 fail_async_pd:
 	dma_pool_free(ha-&gt;s_dma_pool, ha-&gt;ex_init_cb, ha-&gt;ex_init_cb_dma);
 fail_ex_init_cb:
<span class="p_chunk">@@ -3582,6 +3584,10 @@</span> <span class="p_context"> fail_free_ms_iocb:</span>
 	dma_pool_free(ha-&gt;s_dma_pool, ha-&gt;ms_iocb, ha-&gt;ms_iocb_dma);
 	ha-&gt;ms_iocb = NULL;
 	ha-&gt;ms_iocb_dma = 0;
<span class="p_add">+</span>
<span class="p_add">+	if (ha-&gt;sns_cmd)</span>
<span class="p_add">+		dma_free_coherent(&amp;ha-&gt;pdev-&gt;dev, sizeof(struct sns_cmd_pkt),</span>
<span class="p_add">+		    ha-&gt;sns_cmd, ha-&gt;sns_cmd_dma);</span>
 fail_dma_pool:
 	if (IS_QLA82XX(ha) || ql2xenabledif) {
 		dma_pool_destroy(ha-&gt;fcp_cmnd_dma_pool);
<span class="p_chunk">@@ -3599,10 +3605,12 @@</span> <span class="p_context"> fail_free_nvram:</span>
 	kfree(ha-&gt;nvram);
 	ha-&gt;nvram = NULL;
 fail_free_ctx_mempool:
<span class="p_del">-	mempool_destroy(ha-&gt;ctx_mempool);</span>
<span class="p_add">+	if (ha-&gt;ctx_mempool)</span>
<span class="p_add">+		mempool_destroy(ha-&gt;ctx_mempool);</span>
 	ha-&gt;ctx_mempool = NULL;
 fail_free_srb_mempool:
<span class="p_del">-	mempool_destroy(ha-&gt;srb_mempool);</span>
<span class="p_add">+	if (ha-&gt;srb_mempool)</span>
<span class="p_add">+		mempool_destroy(ha-&gt;srb_mempool);</span>
 	ha-&gt;srb_mempool = NULL;
 fail_free_gid_list:
 	dma_free_coherent(&amp;ha-&gt;pdev-&gt;dev, qla2x00_gid_list_size(ha),
<span class="p_header">diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c</span>
<span class="p_header">index 1b30a65554f9..ae280e7d3831 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_sysfs.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_sysfs.c</span>
<span class="p_chunk">@@ -1002,10 +1002,6 @@</span> <span class="p_context"> int scsi_sysfs_add_sdev(struct scsi_device *sdev)</span>
 	struct request_queue *rq = sdev-&gt;request_queue;
 	struct scsi_target *starget = sdev-&gt;sdev_target;
 
<span class="p_del">-	error = scsi_device_set_state(sdev, SDEV_RUNNING);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		return error;</span>
<span class="p_del">-</span>
 	error = scsi_target_add(starget);
 	if (error)
 		return error;
<span class="p_header">diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c</span>
<span class="p_header">index b4d50662fc6f..0206b495b65e 100644</span>
<span class="p_header">--- a/drivers/scsi/sg.c</span>
<span class="p_header">+++ b/drivers/scsi/sg.c</span>
<span class="p_chunk">@@ -1716,6 +1716,10 @@</span> <span class="p_context"> static int sg_start_req(Sg_request *srp, unsigned char *cmd)</span>
 			iov_count = iov_shorten(iov, iov_count, hp-&gt;dxfer_len);
 			len = hp-&gt;dxfer_len;
 		}
<span class="p_add">+		if (len == 0) {</span>
<span class="p_add">+			kfree(iov);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
 
 		res = blk_rq_map_user_iov(q, rq, md, (struct sg_iovec *)iov,
 					  iov_count,
<span class="p_header">diff --git a/drivers/ssb/pci.c b/drivers/ssb/pci.c</span>
<span class="p_header">index a8dc95ebf2d6..7700cef5e177 100644</span>
<span class="p_header">--- a/drivers/ssb/pci.c</span>
<span class="p_header">+++ b/drivers/ssb/pci.c</span>
<span class="p_chunk">@@ -846,6 +846,7 @@</span> <span class="p_context"> static int ssb_pci_sprom_get(struct ssb_bus *bus,</span>
 			if (err) {
 				ssb_warn(&quot;WARNING: Using fallback SPROM failed (err %d)\n&quot;,
 					 err);
<span class="p_add">+				goto out_free;</span>
 			} else {
 				ssb_dbg(&quot;Using SPROM revision %d provided by platform\n&quot;,
 					sprom-&gt;revision);
<span class="p_header">diff --git a/drivers/staging/iio/adc/ad7606_core.c b/drivers/staging/iio/adc/ad7606_core.c</span>
<span class="p_header">index f0f05f195d2c..d4598ef48543 100644</span>
<span class="p_header">--- a/drivers/staging/iio/adc/ad7606_core.c</span>
<span class="p_header">+++ b/drivers/staging/iio/adc/ad7606_core.c</span>
<span class="p_chunk">@@ -186,7 +186,7 @@</span> <span class="p_context"> static ssize_t ad7606_store_oversampling_ratio(struct device *dev,</span>
 	mutex_lock(&amp;indio_dev-&gt;mlock);
 	gpio_set_value(st-&gt;pdata-&gt;gpio_os0, (ret &gt;&gt; 0) &amp; 1);
 	gpio_set_value(st-&gt;pdata-&gt;gpio_os1, (ret &gt;&gt; 1) &amp; 1);
<span class="p_del">-	gpio_set_value(st-&gt;pdata-&gt;gpio_os1, (ret &gt;&gt; 2) &amp; 1);</span>
<span class="p_add">+	gpio_set_value(st-&gt;pdata-&gt;gpio_os2, (ret &gt;&gt; 2) &amp; 1);</span>
 	st-&gt;oversampling = lval;
 	mutex_unlock(&amp;indio_dev-&gt;mlock);
 
<span class="p_header">diff --git a/drivers/staging/media/davinci_vpfe/vpfe_video.c b/drivers/staging/media/davinci_vpfe/vpfe_video.c</span>
<span class="p_header">index d95c427043d4..3c1d1401522f 100644</span>
<span class="p_header">--- a/drivers/staging/media/davinci_vpfe/vpfe_video.c</span>
<span class="p_header">+++ b/drivers/staging/media/davinci_vpfe/vpfe_video.c</span>
<span class="p_chunk">@@ -1351,7 +1351,7 @@</span> <span class="p_context"> static int vpfe_reqbufs(struct file *file, void *priv,</span>
 	if (ret) {
 		v4l2_err(&amp;vpfe_dev-&gt;v4l2_dev, &quot;vb2_queue_init() failed\n&quot;);
 		vb2_dma_contig_cleanup_ctx(vpfe_dev-&gt;pdev);
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto unlock_out;</span>
 	}
 
 	fh-&gt;io_allowed = 1;
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_tpg.c b/drivers/target/iscsi/iscsi_target_tpg.c</span>
<span class="p_header">index c3cb5c15efda..48cd3cf741df 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_tpg.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_tpg.c</span>
<span class="p_chunk">@@ -261,7 +261,6 @@</span> <span class="p_context"> err_out:</span>
 		iscsi_release_param_list(tpg-&gt;param_list);
 		tpg-&gt;param_list = NULL;
 	}
<span class="p_del">-	kfree(tpg);</span>
 	return -ENOMEM;
 }
 
<span class="p_header">diff --git a/drivers/target/target_core_sbc.c b/drivers/target/target_core_sbc.c</span>
<span class="p_header">index f4865901263f..a29fdfab0d3a 100644</span>
<span class="p_header">--- a/drivers/target/target_core_sbc.c</span>
<span class="p_header">+++ b/drivers/target/target_core_sbc.c</span>
<span class="p_chunk">@@ -368,6 +368,7 @@</span> <span class="p_context"> static sense_reason_t compare_and_write_post(struct se_cmd *cmd, bool success,</span>
 					     int *post_ret)
 {
 	struct se_device *dev = cmd-&gt;se_dev;
<span class="p_add">+	sense_reason_t ret = TCM_NO_SENSE;</span>
 
 	/*
 	 * Only set SCF_COMPARE_AND_WRITE_POST to force a response fall-through
<span class="p_chunk">@@ -375,9 +376,12 @@</span> <span class="p_context"> static sense_reason_t compare_and_write_post(struct se_cmd *cmd, bool success,</span>
 	 * sent to the backend driver.
 	 */
 	spin_lock_irq(&amp;cmd-&gt;t_state_lock);
<span class="p_del">-	if ((cmd-&gt;transport_state &amp; CMD_T_SENT) &amp;&amp; !cmd-&gt;scsi_status) {</span>
<span class="p_add">+	if (cmd-&gt;transport_state &amp; CMD_T_SENT) {</span>
 		cmd-&gt;se_cmd_flags |= SCF_COMPARE_AND_WRITE_POST;
 		*post_ret = 1;
<span class="p_add">+</span>
<span class="p_add">+		if (cmd-&gt;scsi_status == SAM_STAT_CHECK_CONDITION)</span>
<span class="p_add">+			ret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;</span>
 	}
 	spin_unlock_irq(&amp;cmd-&gt;t_state_lock);
 
<span class="p_chunk">@@ -387,7 +391,7 @@</span> <span class="p_context"> static sense_reason_t compare_and_write_post(struct se_cmd *cmd, bool success,</span>
 	 */
 	up(&amp;dev-&gt;caw_sem);
 
<span class="p_del">-	return TCM_NO_SENSE;</span>
<span class="p_add">+	return ret;</span>
 }
 
 static sense_reason_t compare_and_write_callback(struct se_cmd *cmd, bool success,
<span class="p_header">diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c</span>
<span class="p_header">index d3f65523a19d..589f9df574f2 100644</span>
<span class="p_header">--- a/drivers/target/target_core_transport.c</span>
<span class="p_header">+++ b/drivers/target/target_core_transport.c</span>
<span class="p_chunk">@@ -3093,7 +3093,6 @@</span> <span class="p_context"> static void target_tmr_work(struct work_struct *work)</span>
 		spin_unlock_irqrestore(&amp;cmd-&gt;t_state_lock, flags);
 		goto check_stop;
 	}
<span class="p_del">-	cmd-&gt;t_state = TRANSPORT_ISTATE_PROCESSING;</span>
 	spin_unlock_irqrestore(&amp;cmd-&gt;t_state_lock, flags);
 
 	cmd-&gt;se_tfo-&gt;queue_tm_rsp(cmd);
<span class="p_chunk">@@ -3106,11 +3105,25 @@</span> <span class="p_context"> int transport_generic_handle_tmr(</span>
 	struct se_cmd *cmd)
 {
 	unsigned long flags;
<span class="p_add">+	bool aborted = false;</span>
 
 	spin_lock_irqsave(&amp;cmd-&gt;t_state_lock, flags);
<span class="p_del">-	cmd-&gt;transport_state |= CMD_T_ACTIVE;</span>
<span class="p_add">+	if (cmd-&gt;transport_state &amp; CMD_T_ABORTED) {</span>
<span class="p_add">+		aborted = true;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		cmd-&gt;t_state = TRANSPORT_ISTATE_PROCESSING;</span>
<span class="p_add">+		cmd-&gt;transport_state |= CMD_T_ACTIVE;</span>
<span class="p_add">+	}</span>
 	spin_unlock_irqrestore(&amp;cmd-&gt;t_state_lock, flags);
 
<span class="p_add">+	if (aborted) {</span>
<span class="p_add">+		pr_warn_ratelimited(&quot;handle_tmr caught CMD_T_ABORTED TMR %d&quot;</span>
<span class="p_add">+			&quot;ref_tag: %u tag: %u\n&quot;, cmd-&gt;se_tmr_req-&gt;function,</span>
<span class="p_add">+			cmd-&gt;se_tmr_req-&gt;ref_task_tag, cmd-&gt;se_tfo-&gt;get_task_tag(cmd));</span>
<span class="p_add">+		transport_cmd_check_stop_to_fabric(cmd);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	INIT_WORK(&amp;cmd-&gt;work, target_tmr_work);
 	queue_work(cmd-&gt;se_dev-&gt;tmr_wq, &amp;cmd-&gt;work);
 	return 0;
<span class="p_header">diff --git a/drivers/target/target_core_xcopy.c b/drivers/target/target_core_xcopy.c</span>
<span class="p_header">index 60e611df4818..f9b28a5a52a4 100644</span>
<span class="p_header">--- a/drivers/target/target_core_xcopy.c</span>
<span class="p_header">+++ b/drivers/target/target_core_xcopy.c</span>
<span class="p_chunk">@@ -881,7 +881,7 @@</span> <span class="p_context"> out:</span>
 			&quot; CHECK_CONDITION -&gt; sending response\n&quot;, rc);
 		ec_cmd-&gt;scsi_status = SAM_STAT_CHECK_CONDITION;
 	}
<span class="p_del">-	target_complete_cmd(ec_cmd, SAM_STAT_CHECK_CONDITION);</span>
<span class="p_add">+	target_complete_cmd(ec_cmd, ec_cmd-&gt;scsi_status);</span>
 }
 
 sense_reason_t target_do_xcopy(struct se_cmd *se_cmd)
<span class="p_header">diff --git a/drivers/thermal/thermal_hwmon.c b/drivers/thermal/thermal_hwmon.c</span>
<span class="p_header">index 1967bee4f076..9035fbc5e98d 100644</span>
<span class="p_header">--- a/drivers/thermal/thermal_hwmon.c</span>
<span class="p_header">+++ b/drivers/thermal/thermal_hwmon.c</span>
<span class="p_chunk">@@ -98,7 +98,7 @@</span> <span class="p_context"> temp_crit_show(struct device *dev, struct device_attribute *attr, char *buf)</span>
 	long temperature;
 	int ret;
 
<span class="p_del">-	ret = tz-&gt;ops-&gt;get_trip_temp(tz, 0, &amp;temperature);</span>
<span class="p_add">+	ret = tz-&gt;ops-&gt;get_crit_temp(tz, &amp;temperature);</span>
 	if (ret)
 		return ret;
 
<span class="p_header">diff --git a/drivers/tty/n_hdlc.c b/drivers/tty/n_hdlc.c</span>
<span class="p_header">index 644ddb841d9f..6d1e2f746ab4 100644</span>
<span class="p_header">--- a/drivers/tty/n_hdlc.c</span>
<span class="p_header">+++ b/drivers/tty/n_hdlc.c</span>
<span class="p_chunk">@@ -114,7 +114,7 @@</span> <span class="p_context"></span>
 #define DEFAULT_TX_BUF_COUNT 3
 
 struct n_hdlc_buf {
<span class="p_del">-	struct n_hdlc_buf *link;</span>
<span class="p_add">+	struct list_head  list_item;</span>
 	int		  count;
 	char		  buf[1];
 };
<span class="p_chunk">@@ -122,8 +122,7 @@</span> <span class="p_context"> struct n_hdlc_buf {</span>
 #define	N_HDLC_BUF_SIZE	(sizeof(struct n_hdlc_buf) + maxframe)
 
 struct n_hdlc_buf_list {
<span class="p_del">-	struct n_hdlc_buf *head;</span>
<span class="p_del">-	struct n_hdlc_buf *tail;</span>
<span class="p_add">+	struct list_head  list;</span>
 	int		  count;
 	spinlock_t	  spinlock;
 };
<span class="p_chunk">@@ -136,7 +135,6 @@</span> <span class="p_context"> struct n_hdlc_buf_list {</span>
  * @backup_tty - TTY to use if tty gets closed
  * @tbusy - reentrancy flag for tx wakeup code
  * @woke_up - FIXME: describe this field
<span class="p_del">- * @tbuf - currently transmitting tx buffer</span>
  * @tx_buf_list - list of pending transmit frame buffers
  * @rx_buf_list - list of received frame buffers
  * @tx_free_buf_list - list unused transmit frame buffers
<span class="p_chunk">@@ -149,7 +147,6 @@</span> <span class="p_context"> struct n_hdlc {</span>
 	struct tty_struct	*backup_tty;
 	int			tbusy;
 	int			woke_up;
<span class="p_del">-	struct n_hdlc_buf	*tbuf;</span>
 	struct n_hdlc_buf_list	tx_buf_list;
 	struct n_hdlc_buf_list	rx_buf_list;
 	struct n_hdlc_buf_list	tx_free_buf_list;
<span class="p_chunk">@@ -159,7 +156,8 @@</span> <span class="p_context"> struct n_hdlc {</span>
 /*
  * HDLC buffer list manipulation functions
  */
<span class="p_del">-static void n_hdlc_buf_list_init(struct n_hdlc_buf_list *list);</span>
<span class="p_add">+static void n_hdlc_buf_return(struct n_hdlc_buf_list *buf_list,</span>
<span class="p_add">+						struct n_hdlc_buf *buf);</span>
 static void n_hdlc_buf_put(struct n_hdlc_buf_list *list,
 			   struct n_hdlc_buf *buf);
 static struct n_hdlc_buf *n_hdlc_buf_get(struct n_hdlc_buf_list *list);
<span class="p_chunk">@@ -209,16 +207,9 @@</span> <span class="p_context"> static void flush_tx_queue(struct tty_struct *tty)</span>
 {
 	struct n_hdlc *n_hdlc = tty2n_hdlc(tty);
 	struct n_hdlc_buf *buf;
<span class="p_del">-	unsigned long flags;</span>
 
 	while ((buf = n_hdlc_buf_get(&amp;n_hdlc-&gt;tx_buf_list)))
 		n_hdlc_buf_put(&amp;n_hdlc-&gt;tx_free_buf_list, buf);
<span class="p_del">- 	spin_lock_irqsave(&amp;n_hdlc-&gt;tx_buf_list.spinlock, flags);</span>
<span class="p_del">-	if (n_hdlc-&gt;tbuf) {</span>
<span class="p_del">-		n_hdlc_buf_put(&amp;n_hdlc-&gt;tx_free_buf_list, n_hdlc-&gt;tbuf);</span>
<span class="p_del">-		n_hdlc-&gt;tbuf = NULL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;n_hdlc-&gt;tx_buf_list.spinlock, flags);</span>
 }
 
 static struct tty_ldisc_ops n_hdlc_ldisc = {
<span class="p_chunk">@@ -284,7 +275,6 @@</span> <span class="p_context"> static void n_hdlc_release(struct n_hdlc *n_hdlc)</span>
 		} else
 			break;
 	}
<span class="p_del">-	kfree(n_hdlc-&gt;tbuf);</span>
 	kfree(n_hdlc);
 	
 }	/* end of n_hdlc_release() */
<span class="p_chunk">@@ -403,13 +393,7 @@</span> <span class="p_context"> static void n_hdlc_send_frames(struct n_hdlc *n_hdlc, struct tty_struct *tty)</span>
 	n_hdlc-&gt;woke_up = 0;
 	spin_unlock_irqrestore(&amp;n_hdlc-&gt;tx_buf_list.spinlock, flags);
 
<span class="p_del">-	/* get current transmit buffer or get new transmit */</span>
<span class="p_del">-	/* buffer from list of pending transmit buffers */</span>
<span class="p_del">-		</span>
<span class="p_del">-	tbuf = n_hdlc-&gt;tbuf;</span>
<span class="p_del">-	if (!tbuf)</span>
<span class="p_del">-		tbuf = n_hdlc_buf_get(&amp;n_hdlc-&gt;tx_buf_list);</span>
<span class="p_del">-		</span>
<span class="p_add">+	tbuf = n_hdlc_buf_get(&amp;n_hdlc-&gt;tx_buf_list);</span>
 	while (tbuf) {
 		if (debuglevel &gt;= DEBUG_LEVEL_INFO)	
 			printk(&quot;%s(%d)sending frame %p, count=%d\n&quot;,
<span class="p_chunk">@@ -421,7 +405,7 @@</span> <span class="p_context"> static void n_hdlc_send_frames(struct n_hdlc *n_hdlc, struct tty_struct *tty)</span>
 
 		/* rollback was possible and has been done */
 		if (actual == -ERESTARTSYS) {
<span class="p_del">-			n_hdlc-&gt;tbuf = tbuf;</span>
<span class="p_add">+			n_hdlc_buf_return(&amp;n_hdlc-&gt;tx_buf_list, tbuf);</span>
 			break;
 		}
 		/* if transmit error, throw frame away by */
<span class="p_chunk">@@ -436,10 +420,7 @@</span> <span class="p_context"> static void n_hdlc_send_frames(struct n_hdlc *n_hdlc, struct tty_struct *tty)</span>
 					
 			/* free current transmit buffer */
 			n_hdlc_buf_put(&amp;n_hdlc-&gt;tx_free_buf_list, tbuf);
<span class="p_del">-			</span>
<span class="p_del">-			/* this tx buffer is done */</span>
<span class="p_del">-			n_hdlc-&gt;tbuf = NULL;</span>
<span class="p_del">-			</span>
<span class="p_add">+</span>
 			/* wait up sleeping writers */
 			wake_up_interruptible(&amp;tty-&gt;write_wait);
 	
<span class="p_chunk">@@ -449,10 +430,12 @@</span> <span class="p_context"> static void n_hdlc_send_frames(struct n_hdlc *n_hdlc, struct tty_struct *tty)</span>
 			if (debuglevel &gt;= DEBUG_LEVEL_INFO)	
 				printk(&quot;%s(%d)frame %p pending\n&quot;,
 					__FILE__,__LINE__,tbuf);
<span class="p_del">-					</span>
<span class="p_del">-			/* buffer not accepted by driver */</span>
<span class="p_del">-			/* set this buffer as pending buffer */</span>
<span class="p_del">-			n_hdlc-&gt;tbuf = tbuf;</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * the buffer was not accepted by driver,</span>
<span class="p_add">+			 * return it back into tx queue</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			n_hdlc_buf_return(&amp;n_hdlc-&gt;tx_buf_list, tbuf);</span>
 			break;
 		}
 	}
<span class="p_chunk">@@ -750,7 +733,8 @@</span> <span class="p_context"> static int n_hdlc_tty_ioctl(struct tty_struct *tty, struct file *file,</span>
 	int error = 0;
 	int count;
 	unsigned long flags;
<span class="p_del">-	</span>
<span class="p_add">+	struct n_hdlc_buf *buf = NULL;</span>
<span class="p_add">+</span>
 	if (debuglevel &gt;= DEBUG_LEVEL_INFO)	
 		printk(&quot;%s(%d)n_hdlc_tty_ioctl() called %d\n&quot;,
 			__FILE__,__LINE__,cmd);
<span class="p_chunk">@@ -764,8 +748,10 @@</span> <span class="p_context"> static int n_hdlc_tty_ioctl(struct tty_struct *tty, struct file *file,</span>
 		/* report count of read data available */
 		/* in next available frame (if any) */
 		spin_lock_irqsave(&amp;n_hdlc-&gt;rx_buf_list.spinlock,flags);
<span class="p_del">-		if (n_hdlc-&gt;rx_buf_list.head)</span>
<span class="p_del">-			count = n_hdlc-&gt;rx_buf_list.head-&gt;count;</span>
<span class="p_add">+		buf = list_first_entry_or_null(&amp;n_hdlc-&gt;rx_buf_list.list,</span>
<span class="p_add">+						struct n_hdlc_buf, list_item);</span>
<span class="p_add">+		if (buf)</span>
<span class="p_add">+			count = buf-&gt;count;</span>
 		else
 			count = 0;
 		spin_unlock_irqrestore(&amp;n_hdlc-&gt;rx_buf_list.spinlock,flags);
<span class="p_chunk">@@ -777,8 +763,10 @@</span> <span class="p_context"> static int n_hdlc_tty_ioctl(struct tty_struct *tty, struct file *file,</span>
 		count = tty_chars_in_buffer(tty);
 		/* add size of next output frame in queue */
 		spin_lock_irqsave(&amp;n_hdlc-&gt;tx_buf_list.spinlock,flags);
<span class="p_del">-		if (n_hdlc-&gt;tx_buf_list.head)</span>
<span class="p_del">-			count += n_hdlc-&gt;tx_buf_list.head-&gt;count;</span>
<span class="p_add">+		buf = list_first_entry_or_null(&amp;n_hdlc-&gt;tx_buf_list.list,</span>
<span class="p_add">+						struct n_hdlc_buf, list_item);</span>
<span class="p_add">+		if (buf)</span>
<span class="p_add">+			count += buf-&gt;count;</span>
 		spin_unlock_irqrestore(&amp;n_hdlc-&gt;tx_buf_list.spinlock,flags);
 		error = put_user(count, (int __user *)arg);
 		break;
<span class="p_chunk">@@ -826,14 +814,14 @@</span> <span class="p_context"> static unsigned int n_hdlc_tty_poll(struct tty_struct *tty, struct file *filp,</span>
 		poll_wait(filp, &amp;tty-&gt;write_wait, wait);
 
 		/* set bits for operations that won&#39;t block */
<span class="p_del">-		if (n_hdlc-&gt;rx_buf_list.head)</span>
<span class="p_add">+		if (!list_empty(&amp;n_hdlc-&gt;rx_buf_list.list))</span>
 			mask |= POLLIN | POLLRDNORM;	/* readable */
 		if (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags))
 			mask |= POLLHUP;
 		if (tty_hung_up_p(filp))
 			mask |= POLLHUP;
 		if (!tty_is_writelocked(tty) &amp;&amp;
<span class="p_del">-				n_hdlc-&gt;tx_free_buf_list.head)</span>
<span class="p_add">+				!list_empty(&amp;n_hdlc-&gt;tx_free_buf_list.list))</span>
 			mask |= POLLOUT | POLLWRNORM;	/* writable */
 	}
 	return mask;
<span class="p_chunk">@@ -853,11 +841,16 @@</span> <span class="p_context"> static struct n_hdlc *n_hdlc_alloc(void)</span>
 	if (!n_hdlc)
 		return NULL;
 
<span class="p_del">-	n_hdlc_buf_list_init(&amp;n_hdlc-&gt;rx_free_buf_list);</span>
<span class="p_del">-	n_hdlc_buf_list_init(&amp;n_hdlc-&gt;tx_free_buf_list);</span>
<span class="p_del">-	n_hdlc_buf_list_init(&amp;n_hdlc-&gt;rx_buf_list);</span>
<span class="p_del">-	n_hdlc_buf_list_init(&amp;n_hdlc-&gt;tx_buf_list);</span>
<span class="p_del">-	</span>
<span class="p_add">+	spin_lock_init(&amp;n_hdlc-&gt;rx_free_buf_list.spinlock);</span>
<span class="p_add">+	spin_lock_init(&amp;n_hdlc-&gt;tx_free_buf_list.spinlock);</span>
<span class="p_add">+	spin_lock_init(&amp;n_hdlc-&gt;rx_buf_list.spinlock);</span>
<span class="p_add">+	spin_lock_init(&amp;n_hdlc-&gt;tx_buf_list.spinlock);</span>
<span class="p_add">+</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;n_hdlc-&gt;rx_free_buf_list.list);</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;n_hdlc-&gt;tx_free_buf_list.list);</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;n_hdlc-&gt;rx_buf_list.list);</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;n_hdlc-&gt;tx_buf_list.list);</span>
<span class="p_add">+</span>
 	/* allocate free rx buffer list */
 	for(i=0;i&lt;DEFAULT_RX_BUF_COUNT;i++) {
 		buf = kmalloc(N_HDLC_BUF_SIZE, GFP_KERNEL);
<span class="p_chunk">@@ -885,63 +878,65 @@</span> <span class="p_context"> static struct n_hdlc *n_hdlc_alloc(void)</span>
 }	/* end of n_hdlc_alloc() */
 
 /**
<span class="p_del">- * n_hdlc_buf_list_init - initialize specified HDLC buffer list</span>
<span class="p_del">- * @list - pointer to buffer list</span>
<span class="p_add">+ * n_hdlc_buf_return - put the HDLC buffer after the head of the specified list</span>
<span class="p_add">+ * @buf_list - pointer to the buffer list</span>
<span class="p_add">+ * @buf - pointer to the buffer</span>
  */
<span class="p_del">-static void n_hdlc_buf_list_init(struct n_hdlc_buf_list *list)</span>
<span class="p_add">+static void n_hdlc_buf_return(struct n_hdlc_buf_list *buf_list,</span>
<span class="p_add">+						struct n_hdlc_buf *buf)</span>
 {
<span class="p_del">-	memset(list, 0, sizeof(*list));</span>
<span class="p_del">-	spin_lock_init(&amp;list-&gt;spinlock);</span>
<span class="p_del">-}	/* end of n_hdlc_buf_list_init() */</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;buf_list-&gt;spinlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_add(&amp;buf-&gt;list_item, &amp;buf_list-&gt;list);</span>
<span class="p_add">+	buf_list-&gt;count++;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;buf_list-&gt;spinlock, flags);</span>
<span class="p_add">+}</span>
 
 /**
  * n_hdlc_buf_put - add specified HDLC buffer to tail of specified list
<span class="p_del">- * @list - pointer to buffer list</span>
<span class="p_add">+ * @buf_list - pointer to buffer list</span>
  * @buf	- pointer to buffer
  */
<span class="p_del">-static void n_hdlc_buf_put(struct n_hdlc_buf_list *list,</span>
<span class="p_add">+static void n_hdlc_buf_put(struct n_hdlc_buf_list *buf_list,</span>
 			   struct n_hdlc_buf *buf)
 {
 	unsigned long flags;
<span class="p_del">-	spin_lock_irqsave(&amp;list-&gt;spinlock,flags);</span>
<span class="p_del">-	</span>
<span class="p_del">-	buf-&gt;link=NULL;</span>
<span class="p_del">-	if (list-&gt;tail)</span>
<span class="p_del">-		list-&gt;tail-&gt;link = buf;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		list-&gt;head = buf;</span>
<span class="p_del">-	list-&gt;tail = buf;</span>
<span class="p_del">-	(list-&gt;count)++;</span>
<span class="p_del">-	</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;list-&gt;spinlock,flags);</span>
<span class="p_del">-	</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;buf_list-&gt;spinlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_add_tail(&amp;buf-&gt;list_item, &amp;buf_list-&gt;list);</span>
<span class="p_add">+	buf_list-&gt;count++;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;buf_list-&gt;spinlock, flags);</span>
 }	/* end of n_hdlc_buf_put() */
 
 /**
  * n_hdlc_buf_get - remove and return an HDLC buffer from list
<span class="p_del">- * @list - pointer to HDLC buffer list</span>
<span class="p_add">+ * @buf_list - pointer to HDLC buffer list</span>
  * 
  * Remove and return an HDLC buffer from the head of the specified HDLC buffer
  * list.
  * Returns a pointer to HDLC buffer if available, otherwise %NULL.
  */
<span class="p_del">-static struct n_hdlc_buf* n_hdlc_buf_get(struct n_hdlc_buf_list *list)</span>
<span class="p_add">+static struct n_hdlc_buf *n_hdlc_buf_get(struct n_hdlc_buf_list *buf_list)</span>
 {
 	unsigned long flags;
 	struct n_hdlc_buf *buf;
<span class="p_del">-	spin_lock_irqsave(&amp;list-&gt;spinlock,flags);</span>
<span class="p_del">-	</span>
<span class="p_del">-	buf = list-&gt;head;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;buf_list-&gt;spinlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	buf = list_first_entry_or_null(&amp;buf_list-&gt;list,</span>
<span class="p_add">+						struct n_hdlc_buf, list_item);</span>
 	if (buf) {
<span class="p_del">-		list-&gt;head = buf-&gt;link;</span>
<span class="p_del">-		(list-&gt;count)--;</span>
<span class="p_add">+		list_del(&amp;buf-&gt;list_item);</span>
<span class="p_add">+		buf_list-&gt;count--;</span>
 	}
<span class="p_del">-	if (!list-&gt;head)</span>
<span class="p_del">-		list-&gt;tail = NULL;</span>
<span class="p_del">-	</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;list-&gt;spinlock,flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;buf_list-&gt;spinlock, flags);</span>
 	return buf;
<span class="p_del">-	</span>
 }	/* end of n_hdlc_buf_get() */
 
 static char hdlc_banner[] __initdata =
<span class="p_header">diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">index d806657ca53e..56a3cc42a4b0 100644</span>
<span class="p_header">--- a/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_chunk">@@ -734,6 +734,11 @@</span> <span class="p_context"> static void atmel_complete_tx_dma(void *arg)</span>
 	/* Do we really need this? */
 	if (!uart_circ_empty(xmit))
 		tasklet_schedule(&amp;atmel_port-&gt;tasklet);
<span class="p_add">+	else if ((atmel_port-&gt;rs485.flags &amp; SER_RS485_ENABLED) &amp;&amp;</span>
<span class="p_add">+		 !(atmel_port-&gt;rs485.flags &amp; SER_RS485_RX_DURING_TX)) {</span>
<span class="p_add">+		/* DMA done, stop TX, start RX for RS485 */</span>
<span class="p_add">+		atmel_start_rx(port);</span>
<span class="p_add">+	}</span>
 
 	spin_unlock_irqrestore(&amp;port-&gt;lock, flags);
 }
<span class="p_chunk">@@ -806,12 +811,6 @@</span> <span class="p_context"> static void atmel_tx_dma(struct uart_port *port)</span>
 		desc-&gt;callback = atmel_complete_tx_dma;
 		desc-&gt;callback_param = atmel_port;
 		atmel_port-&gt;cookie_tx = dmaengine_submit(desc);
<span class="p_del">-</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		if (atmel_port-&gt;rs485.flags &amp; SER_RS485_ENABLED) {</span>
<span class="p_del">-			/* DMA done, stop TX, start RX for RS485 */</span>
<span class="p_del">-			atmel_start_rx(port);</span>
<span class="p_del">-		}</span>
 	}
 
 	if (uart_circ_chars_pending(xmit) &lt; WAKEUP_CHARS)
<span class="p_header">diff --git a/drivers/tty/sysrq.c b/drivers/tty/sysrq.c</span>
<span class="p_header">index 0c79f95383c0..4317a19d60be 100644</span>
<span class="p_header">--- a/drivers/tty/sysrq.c</span>
<span class="p_header">+++ b/drivers/tty/sysrq.c</span>
<span class="p_chunk">@@ -933,8 +933,8 @@</span> <span class="p_context"> static const struct input_device_id sysrq_ids[] = {</span>
 	{
 		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |
 				INPUT_DEVICE_ID_MATCH_KEYBIT,
<span class="p_del">-		.evbit = { BIT_MASK(EV_KEY) },</span>
<span class="p_del">-		.keybit = { BIT_MASK(KEY_LEFTALT) },</span>
<span class="p_add">+		.evbit = { [BIT_WORD(EV_KEY)] = BIT_MASK(EV_KEY) },</span>
<span class="p_add">+		.keybit = { [BIT_WORD(KEY_LEFTALT)] = BIT_MASK(KEY_LEFTALT) },</span>
 	},
 	{ },
 };
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index 8c779ee044d8..919dc6a1bdf3 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1721,6 +1721,7 @@</span> <span class="p_context"> static const struct usb_device_id acm_ids[] = {</span>
 	{ USB_DEVICE(0x20df, 0x0001), /* Simtec Electronics Entropy Key */
 	.driver_info = QUIRK_CONTROL_LINE_STATE, },
 	{ USB_DEVICE(0x2184, 0x001c) },	/* GW Instek AFG-2225 */
<span class="p_add">+	{ USB_DEVICE(0x2184, 0x0036) },	/* GW Instek AFG-125 */</span>
 	{ USB_DEVICE(0x22b8, 0x6425), /* Motorola MOTOMAGX phones */
 	},
 	/* Motorola H24 HSPA module: */
<span class="p_header">diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c</span>
<span class="p_header">index 8de16f982f55..13d8c60c286a 100644</span>
<span class="p_header">--- a/drivers/usb/core/config.c</span>
<span class="p_header">+++ b/drivers/usb/core/config.c</span>
<span class="p_chunk">@@ -205,6 +205,16 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 	if (ifp-&gt;desc.bNumEndpoints &gt;= num_ep)
 		goto skip_to_next_endpoint_or_interface_descriptor;
 
<span class="p_add">+	/* Check for duplicate endpoint addresses */</span>
<span class="p_add">+	for (i = 0; i &lt; ifp-&gt;desc.bNumEndpoints; ++i) {</span>
<span class="p_add">+		if (ifp-&gt;endpoint[i].desc.bEndpointAddress ==</span>
<span class="p_add">+		    d-&gt;bEndpointAddress) {</span>
<span class="p_add">+			dev_warn(ddev, &quot;config %d interface %d altsetting %d has a duplicate endpoint with address 0x%X, skipping\n&quot;,</span>
<span class="p_add">+			    cfgno, inum, asnum, d-&gt;bEndpointAddress);</span>
<span class="p_add">+			goto skip_to_next_endpoint_or_interface_descriptor;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	endpoint = &amp;ifp-&gt;endpoint[ifp-&gt;desc.bNumEndpoints];
 	++ifp-&gt;desc.bNumEndpoints;
 
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 554cc219ac34..624378404b37 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -106,6 +106,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(ehci_cf_port_reset_rwsem);</span>
 
 static void hub_release(struct kref *kref);
 static int usb_reset_and_verify_device(struct usb_device *udev);
<span class="p_add">+static int hub_port_disable(struct usb_hub *hub, int port1, int set_state);</span>
 
 static inline char *portspeed(struct usb_hub *hub, int portstatus)
 {
<span class="p_chunk">@@ -876,88 +877,6 @@</span> <span class="p_context"> static int hub_set_port_link_state(struct usb_hub *hub, int port1,</span>
 }
 
 /*
<span class="p_del">- * If USB 3.0 ports are placed into the Disabled state, they will no longer</span>
<span class="p_del">- * detect any device connects or disconnects.  This is generally not what the</span>
<span class="p_del">- * USB core wants, since it expects a disabled port to produce a port status</span>
<span class="p_del">- * change event when a new device connects.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Instead, set the link state to Disabled, wait for the link to settle into</span>
<span class="p_del">- * that state, clear any change bits, and then put the port into the RxDetect</span>
<span class="p_del">- * state.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int hub_usb3_port_disable(struct usb_hub *hub, int port1)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-	int total_time;</span>
<span class="p_del">-	u16 portchange, portstatus;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!hub_is_superspeed(hub-&gt;hdev))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);</span>
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * USB controller Advanced Micro Devices, Inc. [AMD] FCH USB XHCI</span>
<span class="p_del">-	 * Controller [1022:7814] will have spurious result making the following</span>
<span class="p_del">-	 * usb 3.0 device hotplugging route to the 2.0 root hub and recognized</span>
<span class="p_del">-	 * as high-speed device if we set the usb 3.0 port link state to</span>
<span class="p_del">-	 * Disabled. Since it&#39;s already in USB_SS_PORT_LS_RX_DETECT state, we</span>
<span class="p_del">-	 * check the state here to avoid the bug.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if ((portstatus &amp; USB_PORT_STAT_LINK_STATE) ==</span>
<span class="p_del">-				USB_SS_PORT_LS_RX_DETECT) {</span>
<span class="p_del">-		dev_dbg(&amp;hub-&gt;ports[port1 - 1]-&gt;dev,</span>
<span class="p_del">-			 &quot;Not disabling port; link state is RxDetect\n&quot;);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = hub_set_port_link_state(hub, port1, USB_SS_PORT_LS_SS_DISABLED);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Wait for the link to enter the disabled state. */</span>
<span class="p_del">-	for (total_time = 0; ; total_time += HUB_DEBOUNCE_STEP) {</span>
<span class="p_del">-		ret = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);</span>
<span class="p_del">-		if (ret &lt; 0)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-		if ((portstatus &amp; USB_PORT_STAT_LINK_STATE) ==</span>
<span class="p_del">-				USB_SS_PORT_LS_SS_DISABLED)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		if (total_time &gt;= HUB_DEBOUNCE_TIMEOUT)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		msleep(HUB_DEBOUNCE_STEP);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (total_time &gt;= HUB_DEBOUNCE_TIMEOUT)</span>
<span class="p_del">-		dev_warn(&amp;hub-&gt;ports[port1 - 1]-&gt;dev,</span>
<span class="p_del">-				&quot;Could not disable after %d ms\n&quot;, total_time);</span>
<span class="p_del">-</span>
<span class="p_del">-	return hub_set_port_link_state(hub, port1, USB_SS_PORT_LS_RX_DETECT);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int hub_port_disable(struct usb_hub *hub, int port1, int set_state)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct usb_port *port_dev = hub-&gt;ports[port1 - 1];</span>
<span class="p_del">-	struct usb_device *hdev = hub-&gt;hdev;</span>
<span class="p_del">-	int ret = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (port_dev-&gt;child &amp;&amp; set_state)</span>
<span class="p_del">-		usb_set_device_state(port_dev-&gt;child, USB_STATE_NOTATTACHED);</span>
<span class="p_del">-	if (!hub-&gt;error) {</span>
<span class="p_del">-		if (hub_is_superspeed(hub-&gt;hdev))</span>
<span class="p_del">-			ret = hub_usb3_port_disable(hub, port1);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			ret = usb_clear_port_feature(hdev, port1,</span>
<span class="p_del">-					USB_PORT_FEAT_ENABLE);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (ret &amp;&amp; ret != -ENODEV)</span>
<span class="p_del">-		dev_err(&amp;port_dev-&gt;dev, &quot;cannot disable (err = %d)\n&quot;, ret);</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
  * Disable a port and mark a logical connect-change event, so that some
  * time later khubd will disconnect() any existing usb_device on the port
  * and will re-enumerate if there actually is a device attached.
<span class="p_chunk">@@ -4022,6 +3941,26 @@</span> <span class="p_context"> void usb_unlocked_enable_lpm(struct usb_device *udev)</span>
 }
 EXPORT_SYMBOL_GPL(usb_unlocked_enable_lpm);
 
<span class="p_add">+/* usb3 devices use U3 for disabled, make sure remote wakeup is disabled */</span>
<span class="p_add">+static void hub_usb3_port_prepare_disable(struct usb_hub *hub,</span>
<span class="p_add">+					  struct usb_port *port_dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct usb_device *udev = port_dev-&gt;child;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (udev &amp;&amp; udev-&gt;port_is_suspended &amp;&amp; udev-&gt;do_remote_wakeup) {</span>
<span class="p_add">+		ret = hub_set_port_link_state(hub, port_dev-&gt;portnum,</span>
<span class="p_add">+					      USB_SS_PORT_LS_U0);</span>
<span class="p_add">+		if (!ret) {</span>
<span class="p_add">+			msleep(USB_RESUME_TIMEOUT);</span>
<span class="p_add">+			ret = usb_disable_remote_wakeup(udev);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			dev_warn(&amp;udev-&gt;dev,</span>
<span class="p_add">+				 &quot;Port disable: can&#39;t disable remote wake\n&quot;);</span>
<span class="p_add">+		udev-&gt;do_remote_wakeup = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
 
 #else	/* CONFIG_PM */
 
<span class="p_chunk">@@ -4029,6 +3968,9 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(usb_unlocked_enable_lpm);</span>
 #define hub_resume		NULL
 #define hub_reset_resume	NULL
 
<span class="p_add">+static inline void hub_usb3_port_prepare_disable(struct usb_hub *hub,</span>
<span class="p_add">+						 struct usb_port *port_dev) { }</span>
<span class="p_add">+</span>
 int usb_disable_lpm(struct usb_device *udev)
 {
 	return 0;
<span class="p_chunk">@@ -4064,6 +4006,34 @@</span> <span class="p_context"> static int hub_handle_remote_wakeup(struct usb_hub *hub, unsigned int port,</span>
 
 #endif	/* CONFIG_PM */
 
<span class="p_add">+/*</span>
<span class="p_add">+ * USB-3 does not have a similar link state as USB-2 that will avoid negotiating</span>
<span class="p_add">+ * a connection with a plugged-in cable but will signal the host when the cable</span>
<span class="p_add">+ * is unplugged. Disable remote wake and set link state to U3 for USB-3 devices</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int hub_port_disable(struct usb_hub *hub, int port1, int set_state)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct usb_port *port_dev = hub-&gt;ports[port1 - 1];</span>
<span class="p_add">+	struct usb_device *hdev = hub-&gt;hdev;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!hub-&gt;error) {</span>
<span class="p_add">+		if (hub_is_superspeed(hub-&gt;hdev)) {</span>
<span class="p_add">+			hub_usb3_port_prepare_disable(hub, port_dev);</span>
<span class="p_add">+			ret = hub_set_port_link_state(hub, port_dev-&gt;portnum,</span>
<span class="p_add">+						      USB_SS_PORT_LS_U3);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			ret = usb_clear_port_feature(hdev, port1,</span>
<span class="p_add">+					USB_PORT_FEAT_ENABLE);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (port_dev-&gt;child &amp;&amp; set_state)</span>
<span class="p_add">+		usb_set_device_state(port_dev-&gt;child, USB_STATE_NOTATTACHED);</span>
<span class="p_add">+	if (ret &amp;&amp; ret != -ENODEV)</span>
<span class="p_add">+		dev_err(&amp;port_dev-&gt;dev, &quot;cannot disable (err = %d)\n&quot;, ret);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 
 /* USB 2.0 spec, 7.1.7.3 / fig 7-29:
  *
<span class="p_header">diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c</span>
<span class="p_header">index 6c7e47f67dd4..3a010c19e0ec 100644</span>
<span class="p_header">--- a/drivers/usb/core/quirks.c</span>
<span class="p_header">+++ b/drivers/usb/core/quirks.c</span>
<span class="p_chunk">@@ -37,6 +37,10 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	/* CBM - Flash disk */
 	{ USB_DEVICE(0x0204, 0x6025), .driver_info = USB_QUIRK_RESET_RESUME },
 
<span class="p_add">+	/* WORLDE easy key (easykey.25) MIDI controller  */</span>
<span class="p_add">+	{ USB_DEVICE(0x0218, 0x0401), .driver_info =</span>
<span class="p_add">+			USB_QUIRK_CONFIG_INTF_STRINGS },</span>
<span class="p_add">+</span>
 	/* HP 5300/5370C scanner */
 	{ USB_DEVICE(0x03f0, 0x0701), .driver_info =
 			USB_QUIRK_STRING_FETCH_255 },
<span class="p_header">diff --git a/drivers/usb/dwc3/ep0.c b/drivers/usb/dwc3/ep0.c</span>
<span class="p_header">index ba35201e19fe..096c9e91724e 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/ep0.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/ep0.c</span>
<span class="p_chunk">@@ -54,20 +54,13 @@</span> <span class="p_context"> static const char *dwc3_ep0_state_string(enum dwc3_ep0_state state)</span>
 	}
 }
 
<span class="p_del">-static int dwc3_ep0_start_trans(struct dwc3 *dwc, u8 epnum, dma_addr_t buf_dma,</span>
<span class="p_del">-		u32 len, u32 type)</span>
<span class="p_add">+static void dwc3_ep0_prepare_one_trb(struct dwc3 *dwc, u8 epnum,</span>
<span class="p_add">+		dma_addr_t buf_dma, u32 len, u32 type)</span>
 {
<span class="p_del">-	struct dwc3_gadget_ep_cmd_params params;</span>
 	struct dwc3_trb			*trb;
 	struct dwc3_ep			*dep;
 
<span class="p_del">-	int				ret;</span>
<span class="p_del">-</span>
 	dep = dwc-&gt;eps[epnum];
<span class="p_del">-	if (dep-&gt;flags &amp; DWC3_EP_BUSY) {</span>
<span class="p_del">-		dev_vdbg(dwc-&gt;dev, &quot;%s: still busy\n&quot;, dep-&gt;name);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
 
 	trb = dwc-&gt;ep0_trb;
 
<span class="p_chunk">@@ -80,6 +73,17 @@</span> <span class="p_context"> static int dwc3_ep0_start_trans(struct dwc3 *dwc, u8 epnum, dma_addr_t buf_dma,</span>
 			| DWC3_TRB_CTRL_LST
 			| DWC3_TRB_CTRL_IOC
 			| DWC3_TRB_CTRL_ISP_IMI);
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int dwc3_ep0_start_trans(struct dwc3 *dwc, u8 epnum)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct dwc3_gadget_ep_cmd_params params;</span>
<span class="p_add">+	struct dwc3_ep			*dep;</span>
<span class="p_add">+	int				ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	dep = dwc-&gt;eps[epnum];</span>
<span class="p_add">+	if (dep-&gt;flags &amp; DWC3_EP_BUSY)</span>
<span class="p_add">+		return 0;</span>
 
 	memset(&amp;params, 0, sizeof(params));
 	params.param0 = upper_32_bits(dwc-&gt;ep0_trb_addr);
<span class="p_chunk">@@ -280,8 +284,9 @@</span> <span class="p_context"> void dwc3_ep0_out_start(struct dwc3 *dwc)</span>
 {
 	int				ret;
 
<span class="p_del">-	ret = dwc3_ep0_start_trans(dwc, 0, dwc-&gt;ctrl_req_addr, 8,</span>
<span class="p_add">+	dwc3_ep0_prepare_one_trb(dwc, 0, dwc-&gt;ctrl_req_addr, 8,</span>
 			DWC3_TRBCTL_CONTROL_SETUP);
<span class="p_add">+	ret = dwc3_ep0_start_trans(dwc, 0);</span>
 	WARN_ON(ret &lt; 0);
 }
 
<span class="p_chunk">@@ -890,9 +895,10 @@</span> <span class="p_context"> static void __dwc3_ep0_do_control_data(struct dwc3 *dwc,</span>
 	req-&gt;direction = !!dep-&gt;number;
 
 	if (req-&gt;request.length == 0) {
<span class="p_del">-		ret = dwc3_ep0_start_trans(dwc, dep-&gt;number,</span>
<span class="p_add">+		dwc3_ep0_prepare_one_trb(dwc, dep-&gt;number,</span>
 				dwc-&gt;ctrl_req_addr, 0,
 				DWC3_TRBCTL_CONTROL_DATA);
<span class="p_add">+		ret = dwc3_ep0_start_trans(dwc, dep-&gt;number);</span>
 	} else if (!IS_ALIGNED(req-&gt;request.length, dep-&gt;endpoint.maxpacket)
 			&amp;&amp; (dep-&gt;number == 0)) {
 		u32	transfer_size;
<span class="p_chunk">@@ -920,9 +926,10 @@</span> <span class="p_context"> static void __dwc3_ep0_do_control_data(struct dwc3 *dwc,</span>
 		 * DWC3_EP0_BOUNCE_SIZE we will need two chained
 		 * TRBs to handle the transfer.
 		 */
<span class="p_del">-		ret = dwc3_ep0_start_trans(dwc, dep-&gt;number,</span>
<span class="p_add">+		dwc3_ep0_prepare_one_trb(dwc, dep-&gt;number,</span>
 				dwc-&gt;ep0_bounce_addr, transfer_size,
 				DWC3_TRBCTL_CONTROL_DATA);
<span class="p_add">+		ret = dwc3_ep0_start_trans(dwc, dep-&gt;number);</span>
 	} else {
 		ret = usb_gadget_map_request(&amp;dwc-&gt;gadget, &amp;req-&gt;request,
 				dep-&gt;number);
<span class="p_chunk">@@ -931,8 +938,9 @@</span> <span class="p_context"> static void __dwc3_ep0_do_control_data(struct dwc3 *dwc,</span>
 			return;
 		}
 
<span class="p_del">-		ret = dwc3_ep0_start_trans(dwc, dep-&gt;number, req-&gt;request.dma,</span>
<span class="p_add">+		dwc3_ep0_prepare_one_trb(dwc, dep-&gt;number, req-&gt;request.dma,</span>
 				req-&gt;request.length, DWC3_TRBCTL_CONTROL_DATA);
<span class="p_add">+		ret = dwc3_ep0_start_trans(dwc, dep-&gt;number);</span>
 	}
 
 	WARN_ON(ret &lt; 0);
<span class="p_chunk">@@ -946,8 +954,9 @@</span> <span class="p_context"> static int dwc3_ep0_start_control_status(struct dwc3_ep *dep)</span>
 	type = dwc-&gt;three_stage_setup ? DWC3_TRBCTL_CONTROL_STATUS3
 		: DWC3_TRBCTL_CONTROL_STATUS2;
 
<span class="p_del">-	return dwc3_ep0_start_trans(dwc, dep-&gt;number,</span>
<span class="p_add">+	dwc3_ep0_prepare_one_trb(dwc, dep-&gt;number,</span>
 			dwc-&gt;ctrl_req_addr, 0, type);
<span class="p_add">+	return dwc3_ep0_start_trans(dwc, dep-&gt;number);</span>
 }
 
 static void __dwc3_ep0_do_control_status(struct dwc3 *dwc, struct dwc3_ep *dep)
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index ede2814702c4..e81cda1129a3 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -257,11 +257,11 @@</span> <span class="p_context"> void dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,</span>
 	if (req-&gt;request.status == -EINPROGRESS)
 		req-&gt;request.status = status;
 
<span class="p_del">-	if (dwc-&gt;ep0_bounced &amp;&amp; dep-&gt;number == 0)</span>
<span class="p_add">+	if (dwc-&gt;ep0_bounced &amp;&amp; dep-&gt;number &lt;= 1)</span>
 		dwc-&gt;ep0_bounced = false;
<span class="p_del">-	else</span>
<span class="p_del">-		usb_gadget_unmap_request(&amp;dwc-&gt;gadget, &amp;req-&gt;request,</span>
<span class="p_del">-				req-&gt;direction);</span>
<span class="p_add">+</span>
<span class="p_add">+	usb_gadget_unmap_request(&amp;dwc-&gt;gadget,</span>
<span class="p_add">+			&amp;req-&gt;request, req-&gt;direction);</span>
 
 	dev_dbg(dwc-&gt;dev, &quot;request %p from %s completed %d/%d ===&gt; %d\n&quot;,
 			req, dep-&gt;name, req-&gt;request.actual,
<span class="p_chunk">@@ -863,6 +863,8 @@</span> <span class="p_context"> static void dwc3_prepare_one_trb(struct dwc3_ep *dep,</span>
 {
 	struct dwc3		*dwc = dep-&gt;dwc;
 	struct dwc3_trb		*trb;
<span class="p_add">+	struct usb_gadget	*gadget = &amp;dwc-&gt;gadget;</span>
<span class="p_add">+	enum usb_device_speed	speed = gadget-&gt;speed;</span>
 
 	dev_vdbg(dwc-&gt;dev, &quot;%s: req %p dma %08llx length %d%s%s\n&quot;,
 			dep-&gt;name, req, (unsigned long long) dma,
<span class="p_chunk">@@ -895,10 +897,16 @@</span> <span class="p_context"> static void dwc3_prepare_one_trb(struct dwc3_ep *dep,</span>
 		break;
 
 	case USB_ENDPOINT_XFER_ISOC:
<span class="p_del">-		if (!node)</span>
<span class="p_add">+		if (!node) {</span>
 			trb-&gt;ctrl = DWC3_TRBCTL_ISOCHRONOUS_FIRST;
<span class="p_del">-		else</span>
<span class="p_add">+</span>
<span class="p_add">+			if (speed == USB_SPEED_HIGH) {</span>
<span class="p_add">+				struct usb_ep *ep = &amp;dep-&gt;endpoint;</span>
<span class="p_add">+				trb-&gt;size |= DWC3_TRB_SIZE_PCM1(ep-&gt;mult - 1);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else {</span>
 			trb-&gt;ctrl = DWC3_TRBCTL_ISOCHRONOUS;
<span class="p_add">+		}</span>
 		break;
 
 	case USB_ENDPOINT_XFER_BULK:
<span class="p_header">diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c</span>
<span class="p_header">index 9536b6abf65b..b8a961ba1d2b 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/composite.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/composite.c</span>
<span class="p_chunk">@@ -143,11 +143,16 @@</span> <span class="p_context"> int config_ep_by_speed(struct usb_gadget *g,</span>
 
 ep_found:
 	/* commit results */
<span class="p_del">-	_ep-&gt;maxpacket = usb_endpoint_maxp(chosen_desc);</span>
<span class="p_add">+	_ep-&gt;maxpacket = usb_endpoint_maxp(chosen_desc) &amp; 0x7ff;</span>
 	_ep-&gt;desc = chosen_desc;
 	_ep-&gt;comp_desc = NULL;
 	_ep-&gt;maxburst = 0;
<span class="p_del">-	_ep-&gt;mult = 0;</span>
<span class="p_add">+	_ep-&gt;mult = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g-&gt;speed == USB_SPEED_HIGH &amp;&amp; (usb_endpoint_xfer_isoc(_ep-&gt;desc) ||</span>
<span class="p_add">+				usb_endpoint_xfer_int(_ep-&gt;desc)))</span>
<span class="p_add">+		_ep-&gt;mult = usb_endpoint_maxp_mult(_ep-&gt;desc);</span>
<span class="p_add">+</span>
 	if (!want_comp_desc)
 		return 0;
 
<span class="p_chunk">@@ -164,7 +169,7 @@</span> <span class="p_context"> ep_found:</span>
 		switch (usb_endpoint_type(_ep-&gt;desc)) {
 		case USB_ENDPOINT_XFER_ISOC:
 			/* mult: bits 1:0 of bmAttributes */
<span class="p_del">-			_ep-&gt;mult = comp_desc-&gt;bmAttributes &amp; 0x3;</span>
<span class="p_add">+			_ep-&gt;mult = (comp_desc-&gt;bmAttributes &amp; 0x3) + 1;</span>
 		case USB_ENDPOINT_XFER_BULK:
 		case USB_ENDPOINT_XFER_INT:
 			_ep-&gt;maxburst = comp_desc-&gt;bMaxBurst + 1;
<span class="p_chunk">@@ -1516,9 +1521,7 @@</span> <span class="p_context"> composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)</span>
 		value = min(w_length, (u16) 1);
 		break;
 
<span class="p_del">-	/* function drivers must handle get/set altsetting; if there&#39;s</span>
<span class="p_del">-	 * no get() method, we know only altsetting zero works.</span>
<span class="p_del">-	 */</span>
<span class="p_add">+	/* function drivers must handle get/set altsetting */</span>
 	case USB_REQ_SET_INTERFACE:
 		if (ctrl-&gt;bRequestType != USB_RECIP_INTERFACE)
 			goto unknown;
<span class="p_chunk">@@ -1527,7 +1530,13 @@</span> <span class="p_context"> composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)</span>
 		f = cdev-&gt;config-&gt;interface[intf];
 		if (!f)
 			break;
<span class="p_del">-		if (w_value &amp;&amp; !f-&gt;set_alt)</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If there&#39;s no get_alt() method, we know only altsetting zero</span>
<span class="p_add">+		 * works. There is no need to check if set_alt() is not NULL</span>
<span class="p_add">+		 * as we check this in usb_add_function().</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (w_value &amp;&amp; !f-&gt;get_alt)</span>
 			break;
 		value = f-&gt;set_alt(f, w_index, w_value);
 		if (value == USB_GADGET_DELAYED_STATUS) {
<span class="p_header">diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c</span>
<span class="p_header">index 2b54955d3166..b0da9552b3b0 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/dummy_hcd.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/dummy_hcd.c</span>
<span class="p_chunk">@@ -266,7 +266,7 @@</span> <span class="p_context"> static void nuke(struct dummy *dum, struct dummy_ep *ep)</span>
 /* caller must hold lock */
 static void stop_activity(struct dummy *dum)
 {
<span class="p_del">-	struct dummy_ep	*ep;</span>
<span class="p_add">+	int i;</span>
 
 	/* prevent any more requests */
 	dum-&gt;address = 0;
<span class="p_chunk">@@ -274,8 +274,8 @@</span> <span class="p_context"> static void stop_activity(struct dummy *dum)</span>
 	/* The timer is left running so that outstanding URBs can fail */
 
 	/* nuke any pending requests first, so driver i/o is quiesced */
<span class="p_del">-	list_for_each_entry(ep, &amp;dum-&gt;gadget.ep_list, ep.ep_list)</span>
<span class="p_del">-		nuke(dum, ep);</span>
<span class="p_add">+	for (i = 0; i &lt; DUMMY_ENDPOINTS; ++i)</span>
<span class="p_add">+		nuke(dum, &amp;dum-&gt;ep[i]);</span>
 
 	/* driver now does any non-usb quiescing necessary */
 }
<span class="p_header">diff --git a/drivers/usb/gadget/inode.c b/drivers/usb/gadget/inode.c</span>
<span class="p_header">index 1ceaf0e6a859..ac3c91c7e627 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/inode.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/inode.c</span>
<span class="p_chunk">@@ -1200,7 +1200,7 @@</span> <span class="p_context"> ep0_write (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)</span>
 	/* data and/or status stage for control request */
 	} else if (dev-&gt;state == STATE_DEV_SETUP) {
 
<span class="p_del">-		/* IN DATA+STATUS caller makes len &lt;= wLength */</span>
<span class="p_add">+		len = min_t(size_t, len, dev-&gt;setup_wLength);</span>
 		if (dev-&gt;setup_in) {
 			retval = setup_req (dev-&gt;gadget-&gt;ep0, dev-&gt;req, len);
 			if (retval == 0) {
<span class="p_chunk">@@ -1842,10 +1842,12 @@</span> <span class="p_context"> static struct usb_gadget_driver probe_driver = {</span>
  * such as configuration notifications.
  */
 
<span class="p_del">-static int is_valid_config (struct usb_config_descriptor *config)</span>
<span class="p_add">+static int is_valid_config(struct usb_config_descriptor *config,</span>
<span class="p_add">+		unsigned int total)</span>
 {
 	return config-&gt;bDescriptorType == USB_DT_CONFIG
 		&amp;&amp; config-&gt;bLength == USB_DT_CONFIG_SIZE
<span class="p_add">+		&amp;&amp; total &gt;= USB_DT_CONFIG_SIZE</span>
 		&amp;&amp; config-&gt;bConfigurationValue != 0
 		&amp;&amp; (config-&gt;bmAttributes &amp; USB_CONFIG_ATT_ONE) != 0
 		&amp;&amp; (config-&gt;bmAttributes &amp; USB_CONFIG_ATT_WAKEUP) == 0;
<span class="p_chunk">@@ -1862,7 +1864,8 @@</span> <span class="p_context"> dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)</span>
 	u32			tag;
 	char			*kbuf;
 
<span class="p_del">-	if (len &lt; (USB_DT_CONFIG_SIZE + USB_DT_DEVICE_SIZE + 4))</span>
<span class="p_add">+	if ((len &lt; (USB_DT_CONFIG_SIZE + USB_DT_DEVICE_SIZE + 4)) ||</span>
<span class="p_add">+	    (len &gt; PAGE_SIZE * 4))</span>
 		return -EINVAL;
 
 	/* we might need to change message format someday */
<span class="p_chunk">@@ -1886,7 +1889,8 @@</span> <span class="p_context"> dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)</span>
 	/* full or low speed config */
 	dev-&gt;config = (void *) kbuf;
 	total = le16_to_cpu(dev-&gt;config-&gt;wTotalLength);
<span class="p_del">-	if (!is_valid_config (dev-&gt;config) || total &gt;= length)</span>
<span class="p_add">+	if (!is_valid_config(dev-&gt;config, total) ||</span>
<span class="p_add">+			total &gt; length - USB_DT_DEVICE_SIZE)</span>
 		goto fail;
 	kbuf += total;
 	length -= total;
<span class="p_chunk">@@ -1895,10 +1899,13 @@</span> <span class="p_context"> dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)</span>
 	if (kbuf [1] == USB_DT_CONFIG) {
 		dev-&gt;hs_config = (void *) kbuf;
 		total = le16_to_cpu(dev-&gt;hs_config-&gt;wTotalLength);
<span class="p_del">-		if (!is_valid_config (dev-&gt;hs_config) || total &gt;= length)</span>
<span class="p_add">+		if (!is_valid_config(dev-&gt;hs_config, total) ||</span>
<span class="p_add">+				total &gt; length - USB_DT_DEVICE_SIZE)</span>
 			goto fail;
 		kbuf += total;
 		length -= total;
<span class="p_add">+	} else {</span>
<span class="p_add">+		dev-&gt;hs_config = NULL;</span>
 	}
 
 	/* could support multiple configs, using another encoding! */
<span class="p_header">diff --git a/drivers/usb/gadget/uvc_video.c b/drivers/usb/gadget/uvc_video.c</span>
<span class="p_header">index 71e896d4c5ae..43e8c65fd9ed 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/uvc_video.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/uvc_video.c</span>
<span class="p_chunk">@@ -240,7 +240,7 @@</span> <span class="p_context"> uvc_video_alloc_requests(struct uvc_video *video)</span>
 
 	req_size = video-&gt;ep-&gt;maxpacket
 		 * max_t(unsigned int, video-&gt;ep-&gt;maxburst, 1)
<span class="p_del">-		 * (video-&gt;ep-&gt;mult + 1);</span>
<span class="p_add">+		 * (video-&gt;ep-&gt;mult);</span>
 
 	for (i = 0; i &lt; UVC_NUM_REQUESTS; ++i) {
 		video-&gt;req_buffer[i] = kmalloc(req_size, GFP_KERNEL);
<span class="p_header">diff --git a/drivers/usb/host/uhci-pci.c b/drivers/usb/host/uhci-pci.c</span>
<span class="p_header">index 940304c33224..02260cfdedb1 100644</span>
<span class="p_header">--- a/drivers/usb/host/uhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/uhci-pci.c</span>
<span class="p_chunk">@@ -129,6 +129,10 @@</span> <span class="p_context"> static int uhci_pci_init(struct usb_hcd *hcd)</span>
 	if (to_pci_dev(uhci_dev(uhci))-&gt;vendor == PCI_VENDOR_ID_HP)
 		uhci-&gt;wait_for_hp = 1;
 
<span class="p_add">+	/* Intel controllers use non-PME wakeup signalling */</span>
<span class="p_add">+	if (to_pci_dev(uhci_dev(uhci))-&gt;vendor == PCI_VENDOR_ID_INTEL)</span>
<span class="p_add">+		device_set_run_wake(uhci_dev(uhci), 1);</span>
<span class="p_add">+</span>
 	/* Set up pointers to PCI-specific functions */
 	uhci-&gt;reset_hc = uhci_pci_reset_hc;
 	uhci-&gt;check_and_reset_hc = uhci_pci_check_and_reset_hc;
<span class="p_header">diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">index e46c3b1414b9..0333ccc27b13 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-mem.c</span>
<span class="p_chunk">@@ -965,6 +965,40 @@</span> <span class="p_context"> void xhci_free_virt_device(struct xhci_hcd *xhci, int slot_id)</span>
 	xhci-&gt;devs[slot_id] = NULL;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Free a virt_device structure.</span>
<span class="p_add">+ * If the virt_device added a tt_info (a hub) and has children pointing to</span>
<span class="p_add">+ * that tt_info, then free the child first. Recursive.</span>
<span class="p_add">+ * We can&#39;t rely on udev at this point to find child-parent relationships.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void xhci_free_virt_devices_depth_first(struct xhci_hcd *xhci, int slot_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct xhci_virt_device *vdev;</span>
<span class="p_add">+	struct list_head *tt_list_head;</span>
<span class="p_add">+	struct xhci_tt_bw_info *tt_info, *next;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	vdev = xhci-&gt;devs[slot_id];</span>
<span class="p_add">+	if (!vdev)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	tt_list_head = &amp;(xhci-&gt;rh_bw[vdev-&gt;real_port - 1].tts);</span>
<span class="p_add">+	list_for_each_entry_safe(tt_info, next, tt_list_head, tt_list) {</span>
<span class="p_add">+		/* is this a hub device that added a tt_info to the tts list */</span>
<span class="p_add">+		if (tt_info-&gt;slot_id == slot_id) {</span>
<span class="p_add">+			/* are any devices using this tt_info? */</span>
<span class="p_add">+			for (i = 1; i &lt; HCS_MAX_SLOTS(xhci-&gt;hcs_params1); i++) {</span>
<span class="p_add">+				vdev = xhci-&gt;devs[i];</span>
<span class="p_add">+				if (vdev &amp;&amp; (vdev-&gt;tt_info == tt_info))</span>
<span class="p_add">+					xhci_free_virt_devices_depth_first(</span>
<span class="p_add">+						xhci, i);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* we are now at a leaf device */</span>
<span class="p_add">+	xhci_free_virt_device(xhci, slot_id);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int xhci_alloc_virt_device(struct xhci_hcd *xhci, int slot_id,
 		struct usb_device *udev, gfp_t flags)
 {
<span class="p_chunk">@@ -1828,8 +1862,8 @@</span> <span class="p_context"> void xhci_mem_cleanup(struct xhci_hcd *xhci)</span>
 		}
 	}
 
<span class="p_del">-	for (i = 1; i &lt; MAX_HC_SLOTS; ++i)</span>
<span class="p_del">-		xhci_free_virt_device(xhci, i);</span>
<span class="p_add">+	for (i = HCS_MAX_SLOTS(xhci-&gt;hcs_params1); i &gt; 0; i--)</span>
<span class="p_add">+		xhci_free_virt_devices_depth_first(xhci, i);</span>
 
 	if (xhci-&gt;segment_pool)
 		dma_pool_destroy(xhci-&gt;segment_pool);
<span class="p_chunk">@@ -2368,7 +2402,7 @@</span> <span class="p_context"> int xhci_mem_init(struct xhci_hcd *xhci, gfp_t flags)</span>
 	 * &quot;physically contiguous and 64-byte (cache line) aligned&quot;.
 	 */
 	xhci-&gt;dcbaa = dma_alloc_coherent(dev, sizeof(*xhci-&gt;dcbaa), &amp;dma,
<span class="p_del">-			GFP_KERNEL);</span>
<span class="p_add">+			flags);</span>
 	if (!xhci-&gt;dcbaa)
 		goto fail;
 	memset(xhci-&gt;dcbaa, 0, sizeof *(xhci-&gt;dcbaa));
<span class="p_chunk">@@ -2464,7 +2498,7 @@</span> <span class="p_context"> int xhci_mem_init(struct xhci_hcd *xhci, gfp_t flags)</span>
 
 	xhci-&gt;erst.entries = dma_alloc_coherent(dev,
 			sizeof(struct xhci_erst_entry) * ERST_NUM_SEGS, &amp;dma,
<span class="p_del">-			GFP_KERNEL);</span>
<span class="p_add">+			flags);</span>
 	if (!xhci-&gt;erst.entries)
 		goto fail;
 	xhci_dbg_trace(xhci, trace_xhci_dbg_init,
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index e808d8078b2d..63d4f2897f00 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -150,7 +150,8 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI ||
 		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||
 		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI ||
<span class="p_del">-		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI)) {</span>
<span class="p_add">+		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI ||</span>
<span class="p_add">+		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_APL_XHCI)) {</span>
 		xhci-&gt;quirks |= XHCI_PME_STUCK_QUIRK;
 	}
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL &amp;&amp;
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index 58edc5478d6e..6db00d804d0e 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -878,13 +878,6 @@</span> <span class="p_context"> void xhci_stop_endpoint_command_watchdog(unsigned long arg)</span>
 	spin_lock_irqsave(&amp;xhci-&gt;lock, flags);
 
 	ep-&gt;stop_cmds_pending--;
<span class="p_del">-	if (xhci-&gt;xhc_state &amp; XHCI_STATE_DYING) {</span>
<span class="p_del">-		xhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,</span>
<span class="p_del">-				&quot;Stop EP timer ran, but another timer marked &quot;</span>
<span class="p_del">-				&quot;xHCI as DYING, exiting.&quot;);</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
 	if (!(ep-&gt;stop_cmds_pending == 0 &amp;&amp; (ep-&gt;ep_state &amp; EP_HALT_PENDING))) {
 		xhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,
 				&quot;Stop EP timer ran, but no command pending, &quot;
<span class="p_chunk">@@ -1292,33 +1285,44 @@</span> <span class="p_context"> void xhci_handle_command_timeout(unsigned long data)</span>
 	struct xhci_command *cur_cmd = NULL;
 	xhci = (struct xhci_hcd *) data;
 
<span class="p_del">-	/* mark this command to be cancelled */</span>
 	spin_lock_irqsave(&amp;xhci-&gt;lock, flags);
<span class="p_del">-	if (xhci-&gt;current_cmd) {</span>
<span class="p_del">-		cur_cmd = xhci-&gt;current_cmd;</span>
<span class="p_del">-		cur_cmd-&gt;status = COMP_CMD_ABORT;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If timeout work is pending, or current_cmd is NULL, it means we</span>
<span class="p_add">+	 * raced with command completion. Command is handled so just return.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!xhci-&gt;current_cmd || timer_pending(&amp;xhci-&gt;cmd_timer)) {</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);</span>
<span class="p_add">+		return;</span>
 	}
 
<span class="p_add">+	/* mark this command to be cancelled */</span>
<span class="p_add">+	cur_cmd = xhci-&gt;current_cmd;</span>
<span class="p_add">+	cur_cmd-&gt;status = COMP_CMD_ABORT;</span>
 
 	/* Make sure command ring is running before aborting it */
 	hw_ring_state = xhci_read_64(xhci, &amp;xhci-&gt;op_regs-&gt;cmd_ring);
 	if ((xhci-&gt;cmd_ring_state &amp; CMD_RING_STATE_RUNNING) &amp;&amp;
 	    (hw_ring_state &amp; CMD_RING_RUNNING))  {
<span class="p_del">-</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);</span>
 		xhci_dbg(xhci, &quot;Command timeout\n&quot;);
 		ret = xhci_abort_cmd_ring(xhci);
 		if (unlikely(ret == -ESHUTDOWN)) {
 			xhci_err(xhci, &quot;Abort command ring failed\n&quot;);
 			xhci_cleanup_command_queue(xhci);
<span class="p_add">+			spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);</span>
 			usb_hc_died(xhci_to_hcd(xhci)-&gt;primary_hcd);
 			xhci_dbg(xhci, &quot;xHCI host controller is dead.\n&quot;);
<span class="p_add">+</span>
<span class="p_add">+			return;</span>
 		}
<span class="p_del">-		return;</span>
<span class="p_add">+</span>
<span class="p_add">+		goto time_out_completed;</span>
 	}
 	/* command timeout on stopped ring, ring can&#39;t be aborted */
 	xhci_dbg(xhci, &quot;Command timeout on stopped ring\n&quot;);
 	xhci_handle_stopped_cmd_ring(xhci, xhci-&gt;current_cmd);
<span class="p_add">+</span>
<span class="p_add">+time_out_completed:</span>
 	spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);
 	return;
 }
<span class="p_chunk">@@ -1377,8 +1381,11 @@</span> <span class="p_context"> static void handle_cmd_completion(struct xhci_hcd *xhci,</span>
 	 */
 	if (cmd_comp_code == COMP_CMD_ABORT) {
 		xhci-&gt;cmd_ring_state = CMD_RING_STATE_STOPPED;
<span class="p_del">-		if (cmd-&gt;status == COMP_CMD_ABORT)</span>
<span class="p_add">+		if (cmd-&gt;status == COMP_CMD_ABORT) {</span>
<span class="p_add">+			if (xhci-&gt;current_cmd == cmd)</span>
<span class="p_add">+				xhci-&gt;current_cmd = NULL;</span>
 			goto event_handled;
<span class="p_add">+		}</span>
 	}
 
 	cmd_type = TRB_FIELD_TO_TYPE(le32_to_cpu(cmd_trb-&gt;generic.field[3]));
<span class="p_chunk">@@ -1440,6 +1447,8 @@</span> <span class="p_context"> static void handle_cmd_completion(struct xhci_hcd *xhci,</span>
 		xhci-&gt;current_cmd = list_entry(cmd-&gt;cmd_list.next,
 					       struct xhci_command, cmd_list);
 		mod_timer(&amp;xhci-&gt;cmd_timer, jiffies + XHCI_CMD_DEFAULT_TIMEOUT);
<span class="p_add">+	} else if (xhci-&gt;current_cmd == cmd) {</span>
<span class="p_add">+		xhci-&gt;current_cmd = NULL;</span>
 	}
 
 event_handled:
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index e89d09458789..c92869b3ab56 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -1561,19 +1561,6 @@</span> <span class="p_context"> int xhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)</span>
 		xhci_urb_free_priv(xhci, urb_priv);
 		return ret;
 	}
<span class="p_del">-	if ((xhci-&gt;xhc_state &amp; XHCI_STATE_DYING) ||</span>
<span class="p_del">-			(xhci-&gt;xhc_state &amp; XHCI_STATE_HALTED)) {</span>
<span class="p_del">-		xhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,</span>
<span class="p_del">-				&quot;Ep 0x%x: URB %p to be canceled on &quot;</span>
<span class="p_del">-				&quot;non-responsive xHCI host.&quot;,</span>
<span class="p_del">-				urb-&gt;ep-&gt;desc.bEndpointAddress, urb);</span>
<span class="p_del">-		/* Let the stop endpoint command watchdog timer (which set this</span>
<span class="p_del">-		 * state) finish cleaning up the endpoint TD lists.  We must</span>
<span class="p_del">-		 * have caught it in the middle of dropping a lock and giving</span>
<span class="p_del">-		 * back an URB.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		goto done;</span>
<span class="p_del">-	}</span>
 
 	ep_index = xhci_get_endpoint_index(&amp;urb-&gt;ep-&gt;desc);
 	ep = &amp;xhci-&gt;devs[urb-&gt;dev-&gt;slot_id]-&gt;eps[ep_index];
<span class="p_header">diff --git a/drivers/usb/musb/musbhsdma.h b/drivers/usb/musb/musbhsdma.h</span>
<span class="p_header">index f7b13fd25257..a3dcbd55e436 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musbhsdma.h</span>
<span class="p_header">+++ b/drivers/usb/musb/musbhsdma.h</span>
<span class="p_chunk">@@ -157,5 +157,5 @@</span> <span class="p_context"> struct musb_dma_controller {</span>
 	void __iomem			*base;
 	u8				channel_count;
 	u8				used_channels;
<span class="p_del">-	u8				irq;</span>
<span class="p_add">+	int				irq;</span>
 };
<span class="p_header">diff --git a/drivers/usb/phy/phy-am335x-control.c b/drivers/usb/phy/phy-am335x-control.c</span>
<span class="p_header">index d5eca7b9c555..887ee660fa35 100644</span>
<span class="p_header">--- a/drivers/usb/phy/phy-am335x-control.c</span>
<span class="p_header">+++ b/drivers/usb/phy/phy-am335x-control.c</span>
<span class="p_chunk">@@ -126,10 +126,12 @@</span> <span class="p_context"> struct phy_control *am335x_get_phy_control(struct device *dev)</span>
 		return NULL;
 
 	dev = bus_find_device(&amp;platform_bus_type, NULL, node, match);
<span class="p_add">+	of_node_put(node);</span>
 	if (!dev)
 		return NULL;
 
 	ctrl_usb = dev_get_drvdata(dev);
<span class="p_add">+	put_device(dev);</span>
 	if (!ctrl_usb)
 		return NULL;
 	return &amp;ctrl_usb-&gt;phy_ctrl;
<span class="p_header">diff --git a/drivers/usb/serial/ch341.c b/drivers/usb/serial/ch341.c</span>
<span class="p_header">index 2d72aa3564a3..6a8044291ab4 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ch341.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ch341.c</span>
<span class="p_chunk">@@ -61,13 +61,26 @@</span> <span class="p_context"></span>
  * the Net/FreeBSD uchcom.c driver by Takanori Watanabe.  Domo arigato.
  */
 
<span class="p_add">+#define CH341_REQ_READ_VERSION 0x5F</span>
 #define CH341_REQ_WRITE_REG    0x9A
 #define CH341_REQ_READ_REG     0x95
<span class="p_del">-#define CH341_REG_BREAK1       0x05</span>
<span class="p_del">-#define CH341_REG_BREAK2       0x18</span>
<span class="p_del">-#define CH341_NBREAK_BITS_REG1 0x01</span>
<span class="p_del">-#define CH341_NBREAK_BITS_REG2 0x40</span>
<span class="p_del">-</span>
<span class="p_add">+#define CH341_REQ_SERIAL_INIT  0xA1</span>
<span class="p_add">+#define CH341_REQ_MODEM_CTRL   0xA4</span>
<span class="p_add">+</span>
<span class="p_add">+#define CH341_REG_BREAK        0x05</span>
<span class="p_add">+#define CH341_REG_LCR          0x18</span>
<span class="p_add">+#define CH341_NBREAK_BITS      0x01</span>
<span class="p_add">+</span>
<span class="p_add">+#define CH341_LCR_ENABLE_RX    0x80</span>
<span class="p_add">+#define CH341_LCR_ENABLE_TX    0x40</span>
<span class="p_add">+#define CH341_LCR_MARK_SPACE   0x20</span>
<span class="p_add">+#define CH341_LCR_PAR_EVEN     0x10</span>
<span class="p_add">+#define CH341_LCR_ENABLE_PAR   0x08</span>
<span class="p_add">+#define CH341_LCR_STOP_BITS_2  0x04</span>
<span class="p_add">+#define CH341_LCR_CS8          0x03</span>
<span class="p_add">+#define CH341_LCR_CS7          0x02</span>
<span class="p_add">+#define CH341_LCR_CS6          0x01</span>
<span class="p_add">+#define CH341_LCR_CS5          0x00</span>
 
 static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(0x4348, 0x5523) },
<span class="p_chunk">@@ -84,6 +97,10 @@</span> <span class="p_context"> struct ch341_private {</span>
 	u8 line_status; /* active status of modem control inputs */
 };
 
<span class="p_add">+static void ch341_set_termios(struct tty_struct *tty,</span>
<span class="p_add">+			      struct usb_serial_port *port,</span>
<span class="p_add">+			      struct ktermios *old_termios);</span>
<span class="p_add">+</span>
 static int ch341_control_out(struct usb_device *dev, u8 request,
 			     u16 value, u16 index)
 {
<span class="p_chunk">@@ -95,6 +112,8 @@</span> <span class="p_context"> static int ch341_control_out(struct usb_device *dev, u8 request,</span>
 	r = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), request,
 			    USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,
 			    value, index, NULL, 0, DEFAULT_TIMEOUT);
<span class="p_add">+	if (r &lt; 0)</span>
<span class="p_add">+		dev_err(&amp;dev-&gt;dev, &quot;failed to send control message: %d\n&quot;, r);</span>
 
 	return r;
 }
<span class="p_chunk">@@ -112,13 +131,26 @@</span> <span class="p_context"> static int ch341_control_in(struct usb_device *dev,</span>
 	r = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,
 			    USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,
 			    value, index, buf, bufsize, DEFAULT_TIMEOUT);
<span class="p_del">-	return r;</span>
<span class="p_add">+	if (r &lt; bufsize) {</span>
<span class="p_add">+		if (r &gt;= 0) {</span>
<span class="p_add">+			dev_err(&amp;dev-&gt;dev,</span>
<span class="p_add">+				&quot;short control message received (%d &lt; %u)\n&quot;,</span>
<span class="p_add">+				r, bufsize);</span>
<span class="p_add">+			r = -EIO;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		dev_err(&amp;dev-&gt;dev, &quot;failed to receive control message: %d\n&quot;,</span>
<span class="p_add">+			r);</span>
<span class="p_add">+		return r;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
<span class="p_del">-static int ch341_set_baudrate(struct usb_device *dev,</span>
<span class="p_del">-			      struct ch341_private *priv)</span>
<span class="p_add">+static int ch341_set_baudrate_lcr(struct usb_device *dev,</span>
<span class="p_add">+				  struct ch341_private *priv, u8 lcr)</span>
 {
<span class="p_del">-	short a, b;</span>
<span class="p_add">+	short a;</span>
 	int r;
 	unsigned long factor;
 	short divisor;
<span class="p_chunk">@@ -138,43 +170,47 @@</span> <span class="p_context"> static int ch341_set_baudrate(struct usb_device *dev,</span>
 
 	factor = 0x10000 - factor;
 	a = (factor &amp; 0xff00) | divisor;
<span class="p_del">-	b = factor &amp; 0xff;</span>
 
<span class="p_del">-	r = ch341_control_out(dev, 0x9a, 0x1312, a);</span>
<span class="p_del">-	if (!r)</span>
<span class="p_del">-		r = ch341_control_out(dev, 0x9a, 0x0f2c, b);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * CH341A buffers data until a full endpoint-size packet (32 bytes)</span>
<span class="p_add">+	 * has been received unless bit 7 is set.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	a |= BIT(7);</span>
<span class="p_add">+</span>
<span class="p_add">+	r = ch341_control_out(dev, CH341_REQ_WRITE_REG, 0x1312, a);</span>
<span class="p_add">+	if (r)</span>
<span class="p_add">+		return r;</span>
<span class="p_add">+</span>
<span class="p_add">+	r = ch341_control_out(dev, CH341_REQ_WRITE_REG, 0x2518, lcr);</span>
<span class="p_add">+	if (r)</span>
<span class="p_add">+		return r;</span>
 
 	return r;
 }
 
 static int ch341_set_handshake(struct usb_device *dev, u8 control)
 {
<span class="p_del">-	return ch341_control_out(dev, 0xa4, ~control, 0);</span>
<span class="p_add">+	return ch341_control_out(dev, CH341_REQ_MODEM_CTRL, ~control, 0);</span>
 }
 
 static int ch341_get_status(struct usb_device *dev, struct ch341_private *priv)
 {
<span class="p_add">+	const unsigned int size = 2;</span>
 	char *buffer;
 	int r;
<span class="p_del">-	const unsigned size = 8;</span>
 	unsigned long flags;
 
 	buffer = kmalloc(size, GFP_KERNEL);
 	if (!buffer)
 		return -ENOMEM;
 
<span class="p_del">-	r = ch341_control_in(dev, 0x95, 0x0706, 0, buffer, size);</span>
<span class="p_add">+	r = ch341_control_in(dev, CH341_REQ_READ_REG, 0x0706, 0, buffer, size);</span>
 	if (r &lt; 0)
 		goto out;
 
<span class="p_del">-	/* setup the private status if available */</span>
<span class="p_del">-	if (r == 2) {</span>
<span class="p_del">-		r = 0;</span>
<span class="p_del">-		spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span>
<span class="p_del">-		priv-&gt;line_status = (~(*buffer)) &amp; CH341_BITS_MODEM_STAT;</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span>
<span class="p_del">-	} else</span>
<span class="p_del">-		r = -EPROTO;</span>
<span class="p_add">+	spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span>
<span class="p_add">+	priv-&gt;line_status = (~(*buffer)) &amp; CH341_BITS_MODEM_STAT;</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span>
 
 out:	kfree(buffer);
 	return r;
<span class="p_chunk">@@ -184,33 +220,29 @@</span> <span class="p_context"> out:	kfree(buffer);</span>
 
 static int ch341_configure(struct usb_device *dev, struct ch341_private *priv)
 {
<span class="p_add">+	const unsigned int size = 2;</span>
 	char *buffer;
 	int r;
<span class="p_del">-	const unsigned size = 8;</span>
 
 	buffer = kmalloc(size, GFP_KERNEL);
 	if (!buffer)
 		return -ENOMEM;
 
 	/* expect two bytes 0x27 0x00 */
<span class="p_del">-	r = ch341_control_in(dev, 0x5f, 0, 0, buffer, size);</span>
<span class="p_add">+	r = ch341_control_in(dev, CH341_REQ_READ_VERSION, 0, 0, buffer, size);</span>
 	if (r &lt; 0)
 		goto out;
 
<span class="p_del">-	r = ch341_control_out(dev, 0xa1, 0, 0);</span>
<span class="p_del">-	if (r &lt; 0)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	r = ch341_set_baudrate(dev, priv);</span>
<span class="p_add">+	r = ch341_control_out(dev, CH341_REQ_SERIAL_INIT, 0, 0);</span>
 	if (r &lt; 0)
 		goto out;
 
 	/* expect two bytes 0x56 0x00 */
<span class="p_del">-	r = ch341_control_in(dev, 0x95, 0x2518, 0, buffer, size);</span>
<span class="p_add">+	r = ch341_control_in(dev, CH341_REQ_READ_REG, 0x2518, 0, buffer, size);</span>
 	if (r &lt; 0)
 		goto out;
 
<span class="p_del">-	r = ch341_control_out(dev, 0x9a, 0x2518, 0x0050);</span>
<span class="p_add">+	r = ch341_control_out(dev, CH341_REQ_WRITE_REG, 0x2518, 0x0050);</span>
 	if (r &lt; 0)
 		goto out;
 
<span class="p_chunk">@@ -219,11 +251,7 @@</span> <span class="p_context"> static int ch341_configure(struct usb_device *dev, struct ch341_private *priv)</span>
 	if (r &lt; 0)
 		goto out;
 
<span class="p_del">-	r = ch341_control_out(dev, 0xa1, 0x501f, 0xd90a);</span>
<span class="p_del">-	if (r &lt; 0)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	r = ch341_set_baudrate(dev, priv);</span>
<span class="p_add">+	r = ch341_set_baudrate_lcr(dev, priv, 0);</span>
 	if (r &lt; 0)
 		goto out;
 
<span class="p_chunk">@@ -249,7 +277,6 @@</span> <span class="p_context"> static int ch341_port_probe(struct usb_serial_port *port)</span>
 
 	spin_lock_init(&amp;priv-&gt;lock);
 	priv-&gt;baud_rate = DEFAULT_BAUD_RATE;
<span class="p_del">-	priv-&gt;line_control = CH341_BIT_RTS | CH341_BIT_DTR;</span>
 
 	r = ch341_configure(port-&gt;serial-&gt;dev, priv);
 	if (r &lt; 0)
<span class="p_chunk">@@ -309,32 +336,31 @@</span> <span class="p_context"> static int ch341_open(struct tty_struct *tty, struct usb_serial_port *port)</span>
 	struct ch341_private *priv = usb_get_serial_port_data(port);
 	int r;
 
<span class="p_del">-	priv-&gt;baud_rate = DEFAULT_BAUD_RATE;</span>
<span class="p_del">-</span>
 	r = ch341_configure(serial-&gt;dev, priv);
 	if (r)
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	r = ch341_set_handshake(serial-&gt;dev, priv-&gt;line_control);</span>
<span class="p_del">-	if (r)</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+		return r;</span>
 
<span class="p_del">-	r = ch341_set_baudrate(serial-&gt;dev, priv);</span>
<span class="p_del">-	if (r)</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+	if (tty)</span>
<span class="p_add">+		ch341_set_termios(tty, port, NULL);</span>
 
 	dev_dbg(&amp;port-&gt;dev, &quot;%s - submitting interrupt urb\n&quot;, __func__);
 	r = usb_submit_urb(port-&gt;interrupt_in_urb, GFP_KERNEL);
 	if (r) {
 		dev_err(&amp;port-&gt;dev, &quot;%s - failed to submit interrupt urb: %d\n&quot;,
 			__func__, r);
<span class="p_del">-		ch341_close(port);</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+		return r;</span>
 	}
 
 	r = usb_serial_generic_open(tty, port);
<span class="p_add">+	if (r)</span>
<span class="p_add">+		goto err_kill_interrupt_urb;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+err_kill_interrupt_urb:</span>
<span class="p_add">+	usb_kill_urb(port-&gt;interrupt_in_urb);</span>
 
<span class="p_del">-out:	return r;</span>
<span class="p_add">+	return r;</span>
 }
 
 /* Old_termios contains the original termios settings and
<span class="p_chunk">@@ -346,23 +372,33 @@</span> <span class="p_context"> static void ch341_set_termios(struct tty_struct *tty,</span>
 	struct ch341_private *priv = usb_get_serial_port_data(port);
 	unsigned baud_rate;
 	unsigned long flags;
<span class="p_add">+	unsigned char ctrl;</span>
<span class="p_add">+	int r;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* redundant changes may cause the chip to lose bytes */</span>
<span class="p_add">+	if (old_termios &amp;&amp; !tty_termios_hw_change(&amp;tty-&gt;termios, old_termios))</span>
<span class="p_add">+		return;</span>
 
 	baud_rate = tty_get_baud_rate(tty);
 
<span class="p_del">-	priv-&gt;baud_rate = baud_rate;</span>
<span class="p_add">+	ctrl = CH341_LCR_ENABLE_RX | CH341_LCR_ENABLE_TX | CH341_LCR_CS8;</span>
 
 	if (baud_rate) {
<span class="p_del">-		spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span>
<span class="p_del">-		priv-&gt;line_control |= (CH341_BIT_DTR | CH341_BIT_RTS);</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span>
<span class="p_del">-		ch341_set_baudrate(port-&gt;serial-&gt;dev, priv);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span>
<span class="p_del">-		priv-&gt;line_control &amp;= ~(CH341_BIT_DTR | CH341_BIT_RTS);</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span>
<span class="p_add">+		priv-&gt;baud_rate = baud_rate;</span>
<span class="p_add">+</span>
<span class="p_add">+		r = ch341_set_baudrate_lcr(port-&gt;serial-&gt;dev, priv, ctrl);</span>
<span class="p_add">+		if (r &lt; 0 &amp;&amp; old_termios) {</span>
<span class="p_add">+			priv-&gt;baud_rate = tty_termios_baud_rate(old_termios);</span>
<span class="p_add">+			tty_termios_copy_hw(&amp;tty-&gt;termios, old_termios);</span>
<span class="p_add">+		}</span>
 	}
 
<span class="p_del">-	ch341_set_handshake(port-&gt;serial-&gt;dev, priv-&gt;line_control);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span>
<span class="p_add">+	if (C_BAUD(tty) == B0)</span>
<span class="p_add">+		priv-&gt;line_control &amp;= ~(CH341_BIT_DTR | CH341_BIT_RTS);</span>
<span class="p_add">+	else if (old_termios &amp;&amp; (old_termios-&gt;c_cflag &amp; CBAUD) == B0)</span>
<span class="p_add">+		priv-&gt;line_control |= (CH341_BIT_DTR | CH341_BIT_RTS);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span>
 
 	/* Unimplemented:
 	 * (cflag &amp; CSIZE) : data bits [5, 8]
<span class="p_chunk">@@ -374,7 +410,7 @@</span> <span class="p_context"> static void ch341_set_termios(struct tty_struct *tty,</span>
 static void ch341_break_ctl(struct tty_struct *tty, int break_state)
 {
 	const uint16_t ch341_break_reg =
<span class="p_del">-		CH341_REG_BREAK1 | ((uint16_t) CH341_REG_BREAK2 &lt;&lt; 8);</span>
<span class="p_add">+			((uint16_t) CH341_REG_LCR &lt;&lt; 8) | CH341_REG_BREAK;</span>
 	struct usb_serial_port *port = tty-&gt;driver_data;
 	int r;
 	uint16_t reg_contents;
<span class="p_chunk">@@ -395,12 +431,12 @@</span> <span class="p_context"> static void ch341_break_ctl(struct tty_struct *tty, int break_state)</span>
 		__func__, break_reg[0], break_reg[1]);
 	if (break_state != 0) {
 		dev_dbg(&amp;port-&gt;dev, &quot;%s - Enter break state requested\n&quot;, __func__);
<span class="p_del">-		break_reg[0] &amp;= ~CH341_NBREAK_BITS_REG1;</span>
<span class="p_del">-		break_reg[1] &amp;= ~CH341_NBREAK_BITS_REG2;</span>
<span class="p_add">+		break_reg[0] &amp;= ~CH341_NBREAK_BITS;</span>
<span class="p_add">+		break_reg[1] &amp;= ~CH341_LCR_ENABLE_TX;</span>
 	} else {
 		dev_dbg(&amp;port-&gt;dev, &quot;%s - Leave break state requested\n&quot;, __func__);
<span class="p_del">-		break_reg[0] |= CH341_NBREAK_BITS_REG1;</span>
<span class="p_del">-		break_reg[1] |= CH341_NBREAK_BITS_REG2;</span>
<span class="p_add">+		break_reg[0] |= CH341_NBREAK_BITS;</span>
<span class="p_add">+		break_reg[1] |= CH341_LCR_ENABLE_TX;</span>
 	}
 	dev_dbg(&amp;port-&gt;dev, &quot;%s - New ch341 break register contents - reg1: %x, reg2: %x\n&quot;,
 		__func__, break_reg[0], break_reg[1]);
<span class="p_chunk">@@ -543,14 +579,23 @@</span> <span class="p_context"> static int ch341_tiocmget(struct tty_struct *tty)</span>
 
 static int ch341_reset_resume(struct usb_serial *serial)
 {
<span class="p_del">-	struct ch341_private *priv;</span>
<span class="p_del">-</span>
<span class="p_del">-	priv = usb_get_serial_port_data(serial-&gt;port[0]);</span>
<span class="p_add">+	struct usb_serial_port *port = serial-&gt;port[0];</span>
<span class="p_add">+	struct ch341_private *priv = usb_get_serial_port_data(port);</span>
<span class="p_add">+	int ret;</span>
 
 	/* reconfigure ch341 serial port after bus-reset */
 	ch341_configure(serial-&gt;dev, priv);
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	if (port-&gt;port.flags &amp; ASYNC_INITIALIZED) {</span>
<span class="p_add">+		ret = usb_submit_urb(port-&gt;interrupt_in_urb, GFP_NOIO);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			dev_err(&amp;port-&gt;dev, &quot;failed to submit interrupt urb: %d\n&quot;,</span>
<span class="p_add">+				ret);</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return usb_serial_generic_resume(serial);</span>
 }
 
 static struct usb_serial_driver ch341_device = {
<span class="p_header">diff --git a/drivers/usb/serial/cyberjack.c b/drivers/usb/serial/cyberjack.c</span>
<span class="p_header">index 2916dea3ede8..8948f375e75d 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cyberjack.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cyberjack.c</span>
<span class="p_chunk">@@ -50,6 +50,7 @@</span> <span class="p_context"></span>
 #define CYBERJACK_PRODUCT_ID	0x0100
 
 /* Function prototypes */
<span class="p_add">+static int cyberjack_attach(struct usb_serial *serial);</span>
 static int cyberjack_port_probe(struct usb_serial_port *port);
 static int cyberjack_port_remove(struct usb_serial_port *port);
 static int  cyberjack_open(struct tty_struct *tty,
<span class="p_chunk">@@ -77,6 +78,7 @@</span> <span class="p_context"> static struct usb_serial_driver cyberjack_device = {</span>
 	.description =		&quot;Reiner SCT Cyberjack USB card reader&quot;,
 	.id_table =		id_table,
 	.num_ports =		1,
<span class="p_add">+	.attach =		cyberjack_attach,</span>
 	.port_probe =		cyberjack_port_probe,
 	.port_remove =		cyberjack_port_remove,
 	.open =			cyberjack_open,
<span class="p_chunk">@@ -100,6 +102,14 @@</span> <span class="p_context"> struct cyberjack_private {</span>
 	short		wrsent;		/* Data already sent */
 };
 
<span class="p_add">+static int cyberjack_attach(struct usb_serial *serial)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (serial-&gt;num_bulk_out &lt; serial-&gt;num_ports)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int cyberjack_port_probe(struct usb_serial_port *port)
 {
 	struct cyberjack_private *priv;
<span class="p_header">diff --git a/drivers/usb/serial/garmin_gps.c b/drivers/usb/serial/garmin_gps.c</span>
<span class="p_header">index db591d19d416..37d0e8cc7af6 100644</span>
<span class="p_header">--- a/drivers/usb/serial/garmin_gps.c</span>
<span class="p_header">+++ b/drivers/usb/serial/garmin_gps.c</span>
<span class="p_chunk">@@ -1044,6 +1044,7 @@</span> <span class="p_context"> static int garmin_write_bulk(struct usb_serial_port *port,</span>
 		   &quot;%s - usb_submit_urb(write bulk) failed with status = %d\n&quot;,
 				__func__, status);
 		count = status;
<span class="p_add">+		kfree(buffer);</span>
 	}
 
 	/* we are done with this urb, so let the host driver
<span class="p_header">diff --git a/drivers/usb/serial/io_edgeport.c b/drivers/usb/serial/io_edgeport.c</span>
<span class="p_header">index 1947ea0e0988..b63a6c3899c5 100644</span>
<span class="p_header">--- a/drivers/usb/serial/io_edgeport.c</span>
<span class="p_header">+++ b/drivers/usb/serial/io_edgeport.c</span>
<span class="p_chunk">@@ -2761,6 +2761,11 @@</span> <span class="p_context"> static int edge_startup(struct usb_serial *serial)</span>
 					EDGE_COMPATIBILITY_MASK1,
 					EDGE_COMPATIBILITY_MASK2 };
 
<span class="p_add">+	if (serial-&gt;num_bulk_in &lt; 1 || serial-&gt;num_interrupt_in &lt; 1) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing endpoints\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	dev = serial-&gt;dev;
 
 	/* create our private serial structure */
<span class="p_header">diff --git a/drivers/usb/serial/io_ti.c b/drivers/usb/serial/io_ti.c</span>
<span class="p_header">index c0a42e9e6777..eea16550e582 100644</span>
<span class="p_header">--- a/drivers/usb/serial/io_ti.c</span>
<span class="p_header">+++ b/drivers/usb/serial/io_ti.c</span>
<span class="p_chunk">@@ -1376,7 +1376,7 @@</span> <span class="p_context"> stayinbootmode:</span>
 	dev_dbg(dev, &quot;%s - STAYING IN BOOT MODE\n&quot;, __func__);
 	serial-&gt;product_info.TiMode = TI_MODE_BOOT;
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return 1;</span>
 }
 
 
<span class="p_chunk">@@ -2383,6 +2383,13 @@</span> <span class="p_context"> static int edge_startup(struct usb_serial *serial)</span>
 	struct edgeport_serial *edge_serial;
 	int status;
 
<span class="p_add">+	/* Make sure we have the required endpoints when in download mode. */</span>
<span class="p_add">+	if (serial-&gt;interface-&gt;cur_altsetting-&gt;desc.bNumEndpoints &gt; 1) {</span>
<span class="p_add">+		if (serial-&gt;num_bulk_in &lt; serial-&gt;num_ports ||</span>
<span class="p_add">+				serial-&gt;num_bulk_out &lt; serial-&gt;num_ports)</span>
<span class="p_add">+			return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* create our private serial structure */
 	edge_serial = kzalloc(sizeof(struct edgeport_serial), GFP_KERNEL);
 	if (!edge_serial)
<span class="p_chunk">@@ -2393,11 +2400,14 @@</span> <span class="p_context"> static int edge_startup(struct usb_serial *serial)</span>
 	usb_set_serial_data(serial, edge_serial);
 
 	status = download_fw(edge_serial);
<span class="p_del">-	if (status) {</span>
<span class="p_add">+	if (status &lt; 0) {</span>
 		kfree(edge_serial);
 		return status;
 	}
 
<span class="p_add">+	if (status &gt; 0)</span>
<span class="p_add">+		return 1;	/* bind but do not register any ports */</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/usb/serial/iuu_phoenix.c b/drivers/usb/serial/iuu_phoenix.c</span>
<span class="p_header">index 5ad4a0fb4b26..7ed7d33d6c10 100644</span>
<span class="p_header">--- a/drivers/usb/serial/iuu_phoenix.c</span>
<span class="p_header">+++ b/drivers/usb/serial/iuu_phoenix.c</span>
<span class="p_chunk">@@ -68,6 +68,16 @@</span> <span class="p_context"> struct iuu_private {</span>
 	u32 clk;
 };
 
<span class="p_add">+static int iuu_attach(struct usb_serial *serial)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned char num_ports = serial-&gt;num_ports;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (serial-&gt;num_bulk_in &lt; num_ports || serial-&gt;num_bulk_out &lt; num_ports)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int iuu_port_probe(struct usb_serial_port *port)
 {
 	struct iuu_private *priv;
<span class="p_chunk">@@ -1196,6 +1206,7 @@</span> <span class="p_context"> static struct usb_serial_driver iuu_device = {</span>
 	.tiocmset = iuu_tiocmset,
 	.set_termios = iuu_set_termios,
 	.init_termios = iuu_init_termios,
<span class="p_add">+	.attach = iuu_attach,</span>
 	.port_probe = iuu_port_probe,
 	.port_remove = iuu_port_remove,
 };
<span class="p_header">diff --git a/drivers/usb/serial/keyspan_pda.c b/drivers/usb/serial/keyspan_pda.c</span>
<span class="p_header">index 4f7e072e4e00..930be98d59b3 100644</span>
<span class="p_header">--- a/drivers/usb/serial/keyspan_pda.c</span>
<span class="p_header">+++ b/drivers/usb/serial/keyspan_pda.c</span>
<span class="p_chunk">@@ -699,6 +699,19 @@</span> <span class="p_context"> MODULE_FIRMWARE(&quot;keyspan_pda/keyspan_pda.fw&quot;);</span>
 MODULE_FIRMWARE(&quot;keyspan_pda/xircom_pgs.fw&quot;);
 #endif
 
<span class="p_add">+static int keyspan_pda_attach(struct usb_serial *serial)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned char num_ports = serial-&gt;num_ports;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (serial-&gt;num_bulk_out &lt; num_ports ||</span>
<span class="p_add">+			serial-&gt;num_interrupt_in &lt; num_ports) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing endpoints\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int keyspan_pda_port_probe(struct usb_serial_port *port)
 {
 
<span class="p_chunk">@@ -776,6 +789,7 @@</span> <span class="p_context"> static struct usb_serial_driver keyspan_pda_device = {</span>
 	.break_ctl =		keyspan_pda_break_ctl,
 	.tiocmget =		keyspan_pda_tiocmget,
 	.tiocmset =		keyspan_pda_tiocmset,
<span class="p_add">+	.attach =		keyspan_pda_attach,</span>
 	.port_probe =		keyspan_pda_port_probe,
 	.port_remove =		keyspan_pda_port_remove,
 };
<span class="p_header">diff --git a/drivers/usb/serial/kl5kusb105.c b/drivers/usb/serial/kl5kusb105.c</span>
<span class="p_header">index ca843033170c..85e074c34623 100644</span>
<span class="p_header">--- a/drivers/usb/serial/kl5kusb105.c</span>
<span class="p_header">+++ b/drivers/usb/serial/kl5kusb105.c</span>
<span class="p_chunk">@@ -300,7 +300,7 @@</span> <span class="p_context"> static int  klsi_105_open(struct tty_struct *tty, struct usb_serial_port *port)</span>
 	rc = usb_serial_generic_open(tty, port);
 	if (rc) {
 		retval = rc;
<span class="p_del">-		goto exit;</span>
<span class="p_add">+		goto err_free_cfg;</span>
 	}
 
 	rc = usb_control_msg(port-&gt;serial-&gt;dev,
<span class="p_chunk">@@ -315,21 +315,38 @@</span> <span class="p_context"> static int  klsi_105_open(struct tty_struct *tty, struct usb_serial_port *port)</span>
 	if (rc &lt; 0) {
 		dev_err(&amp;port-&gt;dev, &quot;Enabling read failed (error = %d)\n&quot;, rc);
 		retval = rc;
<span class="p_add">+		goto err_generic_close;</span>
 	} else
 		dev_dbg(&amp;port-&gt;dev, &quot;%s - enabled reading\n&quot;, __func__);
 
 	rc = klsi_105_get_line_state(port, &amp;line_state);
<span class="p_del">-	if (rc &gt;= 0) {</span>
<span class="p_del">-		spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span>
<span class="p_del">-		priv-&gt;line_state = line_state;</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span>
<span class="p_del">-		dev_dbg(&amp;port-&gt;dev, &quot;%s - read line state 0x%lx\n&quot;, __func__, line_state);</span>
<span class="p_del">-		retval = 0;</span>
<span class="p_del">-	} else</span>
<span class="p_add">+	if (rc &lt; 0) {</span>
 		retval = rc;
<span class="p_add">+		goto err_disable_read;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span>
<span class="p_add">+	priv-&gt;line_state = line_state;</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span>
<span class="p_add">+	dev_dbg(&amp;port-&gt;dev, &quot;%s - read line state 0x%lx\n&quot;, __func__,</span>
<span class="p_add">+			line_state);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 
<span class="p_del">-exit:</span>
<span class="p_add">+err_disable_read:</span>
<span class="p_add">+	usb_control_msg(port-&gt;serial-&gt;dev,</span>
<span class="p_add">+			     usb_sndctrlpipe(port-&gt;serial-&gt;dev, 0),</span>
<span class="p_add">+			     KL5KUSB105A_SIO_CONFIGURE,</span>
<span class="p_add">+			     USB_TYPE_VENDOR | USB_DIR_OUT,</span>
<span class="p_add">+			     KL5KUSB105A_SIO_CONFIGURE_READ_OFF,</span>
<span class="p_add">+			     0, /* index */</span>
<span class="p_add">+			     NULL, 0,</span>
<span class="p_add">+			     KLSI_TIMEOUT);</span>
<span class="p_add">+err_generic_close:</span>
<span class="p_add">+	usb_serial_generic_close(port);</span>
<span class="p_add">+err_free_cfg:</span>
 	kfree(cfg);
<span class="p_add">+</span>
 	return retval;
 }
 
<span class="p_header">diff --git a/drivers/usb/serial/kobil_sct.c b/drivers/usb/serial/kobil_sct.c</span>
<span class="p_header">index a31ff1503a99..95795ef7ecd5 100644</span>
<span class="p_header">--- a/drivers/usb/serial/kobil_sct.c</span>
<span class="p_header">+++ b/drivers/usb/serial/kobil_sct.c</span>
<span class="p_chunk">@@ -51,6 +51,7 @@</span> <span class="p_context"></span>
 
 
 /* Function prototypes */
<span class="p_add">+static int kobil_attach(struct usb_serial *serial);</span>
 static int kobil_port_probe(struct usb_serial_port *probe);
 static int kobil_port_remove(struct usb_serial_port *probe);
 static int  kobil_open(struct tty_struct *tty, struct usb_serial_port *port);
<span class="p_chunk">@@ -86,6 +87,7 @@</span> <span class="p_context"> static struct usb_serial_driver kobil_device = {</span>
 	.description =		&quot;KOBIL USB smart card terminal&quot;,
 	.id_table =		id_table,
 	.num_ports =		1,
<span class="p_add">+	.attach =		kobil_attach,</span>
 	.port_probe =		kobil_port_probe,
 	.port_remove =		kobil_port_remove,
 	.ioctl =		kobil_ioctl,
<span class="p_chunk">@@ -113,6 +115,16 @@</span> <span class="p_context"> struct kobil_private {</span>
 };
 
 
<span class="p_add">+static int kobil_attach(struct usb_serial *serial)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (serial-&gt;num_interrupt_out &lt; serial-&gt;num_ports) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing interrupt-out endpoint\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int kobil_port_probe(struct usb_serial_port *port)
 {
 	struct usb_serial *serial = port-&gt;serial;
<span class="p_header">diff --git a/drivers/usb/serial/mos7720.c b/drivers/usb/serial/mos7720.c</span>
<span class="p_header">index c3b8ae360424..56c4f6d074ca 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mos7720.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mos7720.c</span>
<span class="p_chunk">@@ -65,8 +65,6 @@</span> <span class="p_context"> struct moschip_port {</span>
 	struct urb		*write_urb_pool[NUM_URBS];
 };
 
<span class="p_del">-static struct usb_serial_driver moschip7720_2port_driver;</span>
<span class="p_del">-</span>
 #define USB_VENDOR_ID_MOSCHIP		0x9710
 #define MOSCHIP_DEVICE_ID_7720		0x7720
 #define MOSCHIP_DEVICE_ID_7715		0x7715
<span class="p_chunk">@@ -962,25 +960,6 @@</span> <span class="p_context"> static void mos7720_bulk_out_data_callback(struct urb *urb)</span>
 		tty_port_tty_wakeup(&amp;mos7720_port-&gt;port-&gt;port);
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * mos77xx_probe</span>
<span class="p_del">- *	this function installs the appropriate read interrupt endpoint callback</span>
<span class="p_del">- *	depending on whether the device is a 7720 or 7715, thus avoiding costly</span>
<span class="p_del">- *	run-time checks in the high-frequency callback routine itself.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int mos77xx_probe(struct usb_serial *serial,</span>
<span class="p_del">-			 const struct usb_device_id *id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (id-&gt;idProduct == MOSCHIP_DEVICE_ID_7715)</span>
<span class="p_del">-		moschip7720_2port_driver.read_int_callback =</span>
<span class="p_del">-			mos7715_interrupt_callback;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		moschip7720_2port_driver.read_int_callback =</span>
<span class="p_del">-			mos7720_interrupt_callback;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int mos77xx_calc_num_ports(struct usb_serial *serial)
 {
 	u16 product = le16_to_cpu(serial-&gt;dev-&gt;descriptor.idProduct);
<span class="p_chunk">@@ -1901,6 +1880,11 @@</span> <span class="p_context"> static int mos7720_startup(struct usb_serial *serial)</span>
 	u16 product;
 	int ret_val;
 
<span class="p_add">+	if (serial-&gt;num_bulk_in &lt; 2 || serial-&gt;num_bulk_out &lt; 2) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing bulk endpoints\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	product = le16_to_cpu(serial-&gt;dev-&gt;descriptor.idProduct);
 	dev = serial-&gt;dev;
 
<span class="p_chunk">@@ -1925,19 +1909,18 @@</span> <span class="p_context"> static int mos7720_startup(struct usb_serial *serial)</span>
 			tmp-&gt;interrupt_in_endpointAddress;
 		serial-&gt;port[1]-&gt;interrupt_in_urb = NULL;
 		serial-&gt;port[1]-&gt;interrupt_in_buffer = NULL;
<span class="p_add">+</span>
<span class="p_add">+		if (serial-&gt;port[0]-&gt;interrupt_in_urb) {</span>
<span class="p_add">+			struct urb *urb = serial-&gt;port[0]-&gt;interrupt_in_urb;</span>
<span class="p_add">+</span>
<span class="p_add">+			urb-&gt;complete = mos7715_interrupt_callback;</span>
<span class="p_add">+		}</span>
 	}
 
 	/* setting configuration feature to one */
 	usb_control_msg(serial-&gt;dev, usb_sndctrlpipe(serial-&gt;dev, 0),
 			(__u8)0x03, 0x00, 0x01, 0x00, NULL, 0x00, 5000);
 
<span class="p_del">-	/* start the interrupt urb */</span>
<span class="p_del">-	ret_val = usb_submit_urb(serial-&gt;port[0]-&gt;interrupt_in_urb, GFP_KERNEL);</span>
<span class="p_del">-	if (ret_val)</span>
<span class="p_del">-		dev_err(&amp;dev-&gt;dev,</span>
<span class="p_del">-			&quot;%s - Error %d submitting control urb\n&quot;,</span>
<span class="p_del">-			__func__, ret_val);</span>
<span class="p_del">-</span>
 #ifdef CONFIG_USB_SERIAL_MOS7715_PARPORT
 	if (product == MOSCHIP_DEVICE_ID_7715) {
 		ret_val = mos7715_parport_init(serial);
<span class="p_chunk">@@ -1945,6 +1928,13 @@</span> <span class="p_context"> static int mos7720_startup(struct usb_serial *serial)</span>
 			return ret_val;
 	}
 #endif
<span class="p_add">+	/* start the interrupt urb */</span>
<span class="p_add">+	ret_val = usb_submit_urb(serial-&gt;port[0]-&gt;interrupt_in_urb, GFP_KERNEL);</span>
<span class="p_add">+	if (ret_val) {</span>
<span class="p_add">+		dev_err(&amp;dev-&gt;dev, &quot;failed to submit interrupt urb: %d\n&quot;,</span>
<span class="p_add">+			ret_val);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* LSR For Port 1 */
 	read_mos_reg(serial, 0, LSR, &amp;data);
 	dev_dbg(&amp;dev-&gt;dev, &quot;LSR:%x\n&quot;, data);
<span class="p_chunk">@@ -1954,6 +1944,8 @@</span> <span class="p_context"> static int mos7720_startup(struct usb_serial *serial)</span>
 
 static void mos7720_release(struct usb_serial *serial)
 {
<span class="p_add">+	usb_kill_urb(serial-&gt;port[0]-&gt;interrupt_in_urb);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_USB_SERIAL_MOS7715_PARPORT
 	/* close the parallel port */
 
<span class="p_chunk">@@ -2036,7 +2028,6 @@</span> <span class="p_context"> static struct usb_serial_driver moschip7720_2port_driver = {</span>
 	.close			= mos7720_close,
 	.throttle		= mos7720_throttle,
 	.unthrottle		= mos7720_unthrottle,
<span class="p_del">-	.probe			= mos77xx_probe,</span>
 	.attach			= mos7720_startup,
 	.release		= mos7720_release,
 	.port_probe		= mos7720_port_probe,
<span class="p_chunk">@@ -2050,7 +2041,7 @@</span> <span class="p_context"> static struct usb_serial_driver moschip7720_2port_driver = {</span>
 	.chars_in_buffer	= mos7720_chars_in_buffer,
 	.break_ctl		= mos7720_break,
 	.read_bulk_callback	= mos7720_bulk_in_callback,
<span class="p_del">-	.read_int_callback	= NULL  /* dynamically assigned in probe() */</span>
<span class="p_add">+	.read_int_callback	= mos7720_interrupt_callback,</span>
 };
 
 static struct usb_serial_driver * const serial_drivers[] = {
<span class="p_header">diff --git a/drivers/usb/serial/mos7840.c b/drivers/usb/serial/mos7840.c</span>
<span class="p_header">index f5f3b49ff9d5..7cb48d3af1f4 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mos7840.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mos7840.c</span>
<span class="p_chunk">@@ -1037,9 +1037,7 @@</span> <span class="p_context"> static int mos7840_open(struct tty_struct *tty, struct usb_serial_port *port)</span>
 				serial,
 				serial-&gt;port[0]-&gt;interrupt_in_urb-&gt;interval);
 
<span class="p_del">-			/* start interrupt read for mos7840               *</span>
<span class="p_del">-			 * will continue as long as mos7840 is connected  */</span>
<span class="p_del">-</span>
<span class="p_add">+			/* start interrupt read for mos7840 */</span>
 			response =
 			    usb_submit_urb(serial-&gt;port[0]-&gt;interrupt_in_urb,
 					   GFP_KERNEL);
<span class="p_chunk">@@ -2179,6 +2177,17 @@</span> <span class="p_context"> static int mos7840_calc_num_ports(struct usb_serial *serial)</span>
 	return mos7840_num_ports;
 }
 
<span class="p_add">+static int mos7840_attach(struct usb_serial *serial)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (serial-&gt;num_bulk_in &lt; serial-&gt;num_ports ||</span>
<span class="p_add">+			serial-&gt;num_bulk_out &lt; serial-&gt;num_ports) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing endpoints\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int mos7840_port_probe(struct usb_serial_port *port)
 {
 	struct usb_serial *serial = port-&gt;serial;
<span class="p_chunk">@@ -2457,6 +2466,7 @@</span> <span class="p_context"> static struct usb_serial_driver moschip7840_4port_device = {</span>
 	.tiocmset = mos7840_tiocmset,
 	.tiocmiwait = usb_serial_generic_tiocmiwait,
 	.get_icount = usb_serial_generic_get_icount,
<span class="p_add">+	.attach = mos7840_attach,</span>
 	.port_probe = mos7840_port_probe,
 	.port_remove = mos7840_port_remove,
 	.read_bulk_callback = mos7840_bulk_in_callback,
<span class="p_header">diff --git a/drivers/usb/serial/omninet.c b/drivers/usb/serial/omninet.c</span>
<span class="p_header">index f6c6900bccf0..a180b17d2432 100644</span>
<span class="p_header">--- a/drivers/usb/serial/omninet.c</span>
<span class="p_header">+++ b/drivers/usb/serial/omninet.c</span>
<span class="p_chunk">@@ -38,6 +38,7 @@</span> <span class="p_context"> static int  omninet_write(struct tty_struct *tty, struct usb_serial_port *port,</span>
 				const unsigned char *buf, int count);
 static int  omninet_write_room(struct tty_struct *tty);
 static void omninet_disconnect(struct usb_serial *serial);
<span class="p_add">+static int omninet_attach(struct usb_serial *serial);</span>
 static int omninet_port_probe(struct usb_serial_port *port);
 static int omninet_port_remove(struct usb_serial_port *port);
 
<span class="p_chunk">@@ -56,6 +57,7 @@</span> <span class="p_context"> static struct usb_serial_driver zyxel_omninet_device = {</span>
 	.description =		&quot;ZyXEL - omni.net lcd plus usb&quot;,
 	.id_table =		id_table,
 	.num_ports =		1,
<span class="p_add">+	.attach =		omninet_attach,</span>
 	.port_probe =		omninet_port_probe,
 	.port_remove =		omninet_port_remove,
 	.open =			omninet_open,
<span class="p_chunk">@@ -104,6 +106,17 @@</span> <span class="p_context"> struct omninet_data {</span>
 	__u8	od_outseq;	/* Sequence number for bulk_out URBs */
 };
 
<span class="p_add">+static int omninet_attach(struct usb_serial *serial)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* The second bulk-out endpoint is used for writing. */</span>
<span class="p_add">+	if (serial-&gt;num_bulk_out &lt; 2) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing endpoints\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int omninet_port_probe(struct usb_serial_port *port)
 {
 	struct omninet_data *od;
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index f243c734eb05..2c53775226c5 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -271,6 +271,8 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define TELIT_PRODUCT_CC864_SINGLE		0x1006
 #define TELIT_PRODUCT_DE910_DUAL		0x1010
 #define TELIT_PRODUCT_UE910_V2			0x1012
<span class="p_add">+#define TELIT_PRODUCT_LE922_USBCFG1		0x1040</span>
<span class="p_add">+#define TELIT_PRODUCT_LE922_USBCFG2		0x1041</span>
 #define TELIT_PRODUCT_LE922_USBCFG0		0x1042
 #define TELIT_PRODUCT_LE922_USBCFG3		0x1043
 #define TELIT_PRODUCT_LE922_USBCFG5		0x1045
<span class="p_chunk">@@ -1229,6 +1231,10 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_UE910_V2) },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE922_USBCFG0),
 		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg0 },
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE922_USBCFG1),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le910_blacklist },</span>
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE922_USBCFG2),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg3 },</span>
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE922_USBCFG3),
 		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg3 },
 	{ USB_DEVICE_INTERFACE_CLASS(TELIT_VENDOR_ID, TELIT_PRODUCT_LE922_USBCFG5, 0xff),
<span class="p_chunk">@@ -2000,6 +2006,7 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x7d02, 0xff, 0x00, 0x00) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x7d03, 0xff, 0x02, 0x01) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x7d03, 0xff, 0x00, 0x00) },
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(0x2001, 0x7d04, 0xff) },			/* D-Link DWM-158 */</span>
 	{ USB_DEVICE_INTERFACE_CLASS(0x2001, 0x7e19, 0xff),			/* D-Link DWM-221 B1 */
 	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e01, 0xff, 0xff, 0xff) }, /* D-Link DWM-152/C1 */
<span class="p_chunk">@@ -2011,6 +2018,7 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(WETELECOM_VENDOR_ID, WETELECOM_PRODUCT_WMD200, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(WETELECOM_VENDOR_ID, WETELECOM_PRODUCT_6802, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(WETELECOM_VENDOR_ID, WETELECOM_PRODUCT_WMD300, 0xff, 0xff, 0xff) },
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(0x03f0, 0x421d, 0xff, 0xff, 0xff) }, /* HP lt2523 (Novatel E371) */</span>
 	{ } /* Terminating entry */
 };
 MODULE_DEVICE_TABLE(usb, option_ids);
<span class="p_header">diff --git a/drivers/usb/serial/oti6858.c b/drivers/usb/serial/oti6858.c</span>
<span class="p_header">index a4b88bc038b6..b8bf52bf7a94 100644</span>
<span class="p_header">--- a/drivers/usb/serial/oti6858.c</span>
<span class="p_header">+++ b/drivers/usb/serial/oti6858.c</span>
<span class="p_chunk">@@ -134,6 +134,7 @@</span> <span class="p_context"> static int oti6858_chars_in_buffer(struct tty_struct *tty);</span>
 static int oti6858_tiocmget(struct tty_struct *tty);
 static int oti6858_tiocmset(struct tty_struct *tty,
 				unsigned int set, unsigned int clear);
<span class="p_add">+static int oti6858_attach(struct usb_serial *serial);</span>
 static int oti6858_port_probe(struct usb_serial_port *port);
 static int oti6858_port_remove(struct usb_serial_port *port);
 
<span class="p_chunk">@@ -158,6 +159,7 @@</span> <span class="p_context"> static struct usb_serial_driver oti6858_device = {</span>
 	.write_bulk_callback =	oti6858_write_bulk_callback,
 	.write_room =		oti6858_write_room,
 	.chars_in_buffer =	oti6858_chars_in_buffer,
<span class="p_add">+	.attach =		oti6858_attach,</span>
 	.port_probe =		oti6858_port_probe,
 	.port_remove =		oti6858_port_remove,
 };
<span class="p_chunk">@@ -324,6 +326,20 @@</span> <span class="p_context"> static void send_data(struct work_struct *work)</span>
 	usb_serial_port_softint(port);
 }
 
<span class="p_add">+static int oti6858_attach(struct usb_serial *serial)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned char num_ports = serial-&gt;num_ports;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (serial-&gt;num_bulk_in &lt; num_ports ||</span>
<span class="p_add">+			serial-&gt;num_bulk_out &lt; num_ports ||</span>
<span class="p_add">+			serial-&gt;num_interrupt_in &lt; num_ports) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing endpoints\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int oti6858_port_probe(struct usb_serial_port *port)
 {
 	struct oti6858_private *priv;
<span class="p_header">diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c</span>
<span class="p_header">index 521959370b66..4455b1fd8b70 100644</span>
<span class="p_header">--- a/drivers/usb/serial/pl2303.c</span>
<span class="p_header">+++ b/drivers/usb/serial/pl2303.c</span>
<span class="p_chunk">@@ -49,6 +49,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID_RSAQ5) },
 	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID) },
<span class="p_add">+	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID2) },</span>
 	{ USB_DEVICE(ATEN_VENDOR_ID2, ATEN_PRODUCT_ID) },
 	{ USB_DEVICE(ELCOM_VENDOR_ID, ELCOM_PRODUCT_ID) },
 	{ USB_DEVICE(ELCOM_VENDOR_ID, ELCOM_PRODUCT_ID_UCSGT) },
<span class="p_chunk">@@ -216,9 +217,17 @@</span> <span class="p_context"> static int pl2303_probe(struct usb_serial *serial,</span>
 static int pl2303_startup(struct usb_serial *serial)
 {
 	struct pl2303_serial_private *spriv;
<span class="p_add">+	unsigned char num_ports = serial-&gt;num_ports;</span>
 	enum pl2303_type type = TYPE_01;
 	unsigned char *buf;
 
<span class="p_add">+	if (serial-&gt;num_bulk_in &lt; num_ports ||</span>
<span class="p_add">+			serial-&gt;num_bulk_out &lt; num_ports ||</span>
<span class="p_add">+			serial-&gt;num_interrupt_in &lt; num_ports) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing endpoints\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	spriv = kzalloc(sizeof(*spriv), GFP_KERNEL);
 	if (!spriv)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/usb/serial/pl2303.h b/drivers/usb/serial/pl2303.h</span>
<span class="p_header">index e3b7af8adfb7..09d9be88209e 100644</span>
<span class="p_header">--- a/drivers/usb/serial/pl2303.h</span>
<span class="p_header">+++ b/drivers/usb/serial/pl2303.h</span>
<span class="p_chunk">@@ -27,6 +27,7 @@</span> <span class="p_context"></span>
 #define ATEN_VENDOR_ID		0x0557
 #define ATEN_VENDOR_ID2		0x0547
 #define ATEN_PRODUCT_ID		0x2008
<span class="p_add">+#define ATEN_PRODUCT_ID2	0x2118</span>
 
 #define IODATA_VENDOR_ID	0x04bb
 #define IODATA_PRODUCT_ID	0x0a03
<span class="p_header">diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c</span>
<span class="p_header">index f0a2ad15a992..e08ae0505ad2 100644</span>
<span class="p_header">--- a/drivers/usb/serial/qcserial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/qcserial.c</span>
<span class="p_chunk">@@ -124,6 +124,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{USB_DEVICE(0x1410, 0xa021)},	/* Novatel Gobi 3000 Composite */
 	{USB_DEVICE(0x413c, 0x8193)},	/* Dell Gobi 3000 QDL */
 	{USB_DEVICE(0x413c, 0x8194)},	/* Dell Gobi 3000 Composite */
<span class="p_add">+	{USB_DEVICE(0x413c, 0x81a6)},	/* Dell DW5570 QDL (MC8805) */</span>
 	{USB_DEVICE(0x1199, 0x68a4)},	/* Sierra Wireless QDL */
 	{USB_DEVICE(0x1199, 0x68a5)},	/* Sierra Wireless Modem */
 	{USB_DEVICE(0x1199, 0x68a8)},	/* Sierra Wireless QDL */
<span class="p_header">diff --git a/drivers/usb/serial/quatech2.c b/drivers/usb/serial/quatech2.c</span>
<span class="p_header">index b18974cbd995..a3ed07c58754 100644</span>
<span class="p_header">--- a/drivers/usb/serial/quatech2.c</span>
<span class="p_header">+++ b/drivers/usb/serial/quatech2.c</span>
<span class="p_chunk">@@ -408,16 +408,12 @@</span> <span class="p_context"> static void qt2_close(struct usb_serial_port *port)</span>
 {
 	struct usb_serial *serial;
 	struct qt2_port_private *port_priv;
<span class="p_del">-	unsigned long flags;</span>
 	int i;
 
 	serial = port-&gt;serial;
 	port_priv = usb_get_serial_port_data(port);
 
<span class="p_del">-	spin_lock_irqsave(&amp;port_priv-&gt;urb_lock, flags);</span>
 	usb_kill_urb(port_priv-&gt;write_urb);
<span class="p_del">-	port_priv-&gt;urb_in_use = false;</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;port_priv-&gt;urb_lock, flags);</span>
 
 	/* flush the port transmit buffer */
 	i = usb_control_msg(serial-&gt;dev,
<span class="p_header">diff --git a/drivers/usb/serial/spcp8x5.c b/drivers/usb/serial/spcp8x5.c</span>
<span class="p_header">index ef0dbf0703c5..475e6c31b266 100644</span>
<span class="p_header">--- a/drivers/usb/serial/spcp8x5.c</span>
<span class="p_header">+++ b/drivers/usb/serial/spcp8x5.c</span>
<span class="p_chunk">@@ -154,6 +154,19 @@</span> <span class="p_context"> static int spcp8x5_probe(struct usb_serial *serial,</span>
 	return 0;
 }
 
<span class="p_add">+static int spcp8x5_attach(struct usb_serial *serial)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned char num_ports = serial-&gt;num_ports;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (serial-&gt;num_bulk_in &lt; num_ports ||</span>
<span class="p_add">+			serial-&gt;num_bulk_out &lt; num_ports) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing endpoints\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int spcp8x5_port_probe(struct usb_serial_port *port)
 {
 	const struct usb_device_id *id = usb_get_serial_data(port-&gt;serial);
<span class="p_chunk">@@ -477,6 +490,7 @@</span> <span class="p_context"> static struct usb_serial_driver spcp8x5_device = {</span>
 	.tiocmget		= spcp8x5_tiocmget,
 	.tiocmset		= spcp8x5_tiocmset,
 	.probe			= spcp8x5_probe,
<span class="p_add">+	.attach			= spcp8x5_attach,</span>
 	.port_probe		= spcp8x5_port_probe,
 	.port_remove		= spcp8x5_port_remove,
 };
<span class="p_header">diff --git a/drivers/usb/serial/ti_usb_3410_5052.c b/drivers/usb/serial/ti_usb_3410_5052.c</span>
<span class="p_header">index 7a1f446ab204..f60a1c8f2e66 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ti_usb_3410_5052.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ti_usb_3410_5052.c</span>
<span class="p_chunk">@@ -339,6 +339,13 @@</span> <span class="p_context"> static int ti_startup(struct usb_serial *serial)</span>
 		goto free_tdev;
 	}
 
<span class="p_add">+	if (serial-&gt;num_bulk_in &lt; serial-&gt;num_ports ||</span>
<span class="p_add">+			serial-&gt;num_bulk_out &lt; serial-&gt;num_ports) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing endpoints\n&quot;);</span>
<span class="p_add">+		status = -ENODEV;</span>
<span class="p_add">+		goto free_tdev;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 
 free_tdev:
<span class="p_header">diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">index 8a49c47657f4..96379e715d4b 100644</span>
<span class="p_header">--- a/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">+++ b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_chunk">@@ -1990,6 +1990,13 @@</span> <span class="p_context"> UNUSUAL_DEV(  0x152d, 0x2566, 0x0114, 0x0114,</span>
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_BROKEN_FUA ),
 
<span class="p_add">+/* Reported-by George Cherian &lt;george.cherian@cavium.com&gt; */</span>
<span class="p_add">+UNUSUAL_DEV(0x152d, 0x9561, 0x0000, 0x9999,</span>
<span class="p_add">+		&quot;JMicron&quot;,</span>
<span class="p_add">+		&quot;JMS56x&quot;,</span>
<span class="p_add">+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,</span>
<span class="p_add">+		US_FL_NO_REPORT_OPCODES),</span>
<span class="p_add">+</span>
 /* Entrega Technologies U1-SC25 (later Xircom PortGear PGSCSI)
  * and Mac USB Dock USB-SCSI */
 UNUSUAL_DEV(  0x1645, 0x0007, 0x0100, 0x0133,
<span class="p_header">diff --git a/drivers/vme/bridges/vme_ca91cx42.c b/drivers/vme/bridges/vme_ca91cx42.c</span>
<span class="p_header">index bfb2d3f06738..674b972216c2 100644</span>
<span class="p_header">--- a/drivers/vme/bridges/vme_ca91cx42.c</span>
<span class="p_header">+++ b/drivers/vme/bridges/vme_ca91cx42.c</span>
<span class="p_chunk">@@ -468,7 +468,7 @@</span> <span class="p_context"> static int ca91cx42_slave_get(struct vme_slave_resource *image, int *enabled,</span>
 	vme_bound = ioread32(bridge-&gt;base + CA91CX42_VSI_BD[i]);
 	pci_offset = ioread32(bridge-&gt;base + CA91CX42_VSI_TO[i]);
 
<span class="p_del">-	*pci_base = (dma_addr_t)vme_base + pci_offset;</span>
<span class="p_add">+	*pci_base = (dma_addr_t)*vme_base + pci_offset;</span>
 	*size = (unsigned long long)((vme_bound - *vme_base) + granularity);
 
 	*enabled = 0;
<span class="p_header">diff --git a/drivers/xen/gntdev.c b/drivers/xen/gntdev.c</span>
<span class="p_header">index 7ffbb9390628..1102fd09637d 100644</span>
<span class="p_header">--- a/drivers/xen/gntdev.c</span>
<span class="p_header">+++ b/drivers/xen/gntdev.c</span>
<span class="p_chunk">@@ -765,7 +765,7 @@</span> <span class="p_context"> static int gntdev_mmap(struct file *flip, struct vm_area_struct *vma)</span>
 
 	vma-&gt;vm_ops = &amp;gntdev_vmops;
 
<span class="p_del">-	vma-&gt;vm_flags |= VM_DONTEXPAND | VM_DONTDUMP | VM_IO;</span>
<span class="p_add">+	vma-&gt;vm_flags |= VM_DONTEXPAND | VM_DONTDUMP | VM_MIXEDMAP;</span>
 
 	if (use_ptemod)
 		vma-&gt;vm_flags |= VM_DONTCOPY;
<span class="p_header">diff --git a/fs/block_dev.c b/fs/block_dev.c</span>
<span class="p_header">index 6d7274619bf9..ab8652b89577 100644</span>
<span class="p_header">--- a/fs/block_dev.c</span>
<span class="p_header">+++ b/fs/block_dev.c</span>
<span class="p_chunk">@@ -698,7 +698,7 @@</span> <span class="p_context"> static bool bd_may_claim(struct block_device *bdev, struct block_device *whole,</span>
 		return true;	 /* already a holder */
 	else if (bdev-&gt;bd_holder != NULL)
 		return false; 	 /* held by someone else */
<span class="p_del">-	else if (bdev-&gt;bd_contains == bdev)</span>
<span class="p_add">+	else if (whole == bdev)</span>
 		return true;  	 /* is a whole device which isn&#39;t held */
 
 	else if (whole-&gt;bd_holder == bd_may_claim)
<span class="p_chunk">@@ -1731,6 +1731,7 @@</span> <span class="p_context"> void iterate_bdevs(void (*func)(struct block_device *, void *), void *arg)</span>
 	spin_lock(&amp;inode_sb_list_lock);
 	list_for_each_entry(inode, &amp;blockdev_superblock-&gt;s_inodes, i_sb_list) {
 		struct address_space *mapping = inode-&gt;i_mapping;
<span class="p_add">+		struct block_device *bdev;</span>
 
 		spin_lock(&amp;inode-&gt;i_lock);
 		if (inode-&gt;i_state &amp; (I_FREEING|I_WILL_FREE|I_NEW) ||
<span class="p_chunk">@@ -1751,8 +1752,12 @@</span> <span class="p_context"> void iterate_bdevs(void (*func)(struct block_device *, void *), void *arg)</span>
 		 */
 		iput(old_inode);
 		old_inode = inode;
<span class="p_add">+		bdev = I_BDEV(inode);</span>
 
<span class="p_del">-		func(I_BDEV(inode), arg);</span>
<span class="p_add">+		mutex_lock(&amp;bdev-&gt;bd_mutex);</span>
<span class="p_add">+		if (bdev-&gt;bd_openers)</span>
<span class="p_add">+			func(bdev, arg);</span>
<span class="p_add">+		mutex_unlock(&amp;bdev-&gt;bd_mutex);</span>
 
 		spin_lock(&amp;inode_sb_list_lock);
 	}
<span class="p_header">diff --git a/fs/btrfs/async-thread.c b/fs/btrfs/async-thread.c</span>
<span class="p_header">index fbd76ded9a34..f540d163586d 100644</span>
<span class="p_header">--- a/fs/btrfs/async-thread.c</span>
<span class="p_header">+++ b/fs/btrfs/async-thread.c</span>
<span class="p_chunk">@@ -64,6 +64,20 @@</span> <span class="p_context"> void btrfs_##name(struct work_struct *arg)				\</span>
 	normal_work_helper(work);					\
 }
 
<span class="p_add">+bool btrfs_workqueue_normal_congested(struct btrfs_workqueue *wq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We could compare wq-&gt;normal-&gt;pending with num_online_cpus()</span>
<span class="p_add">+	 * to support &quot;thresh == NO_THRESHOLD&quot; case, but it requires</span>
<span class="p_add">+	 * moving up atomic_inc/dec in thresh_queue/exec_hook. Let&#39;s</span>
<span class="p_add">+	 * postpone it until someone needs the support of that case.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (wq-&gt;normal-&gt;thresh == NO_THRESHOLD)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	return atomic_read(&amp;wq-&gt;normal-&gt;pending) &gt; wq-&gt;normal-&gt;thresh * 2;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 BTRFS_WORK_HELPER(worker_helper);
 BTRFS_WORK_HELPER(delalloc_helper);
 BTRFS_WORK_HELPER(flush_delalloc_helper);
<span class="p_header">diff --git a/fs/btrfs/async-thread.h b/fs/btrfs/async-thread.h</span>
<span class="p_header">index e9e31c94758f..703989cd53ca 100644</span>
<span class="p_header">--- a/fs/btrfs/async-thread.h</span>
<span class="p_header">+++ b/fs/btrfs/async-thread.h</span>
<span class="p_chunk">@@ -77,4 +77,5 @@</span> <span class="p_context"> void btrfs_queue_work(struct btrfs_workqueue *wq,</span>
 void btrfs_destroy_workqueue(struct btrfs_workqueue *wq);
 void btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max);
 void btrfs_set_work_high_priority(struct btrfs_work *work);
<span class="p_add">+bool btrfs_workqueue_normal_congested(struct btrfs_workqueue *wq);</span>
 #endif
<span class="p_header">diff --git a/fs/btrfs/delayed-inode.c b/fs/btrfs/delayed-inode.c</span>
<span class="p_header">index 30289bf0601a..61f87c7edbb8 100644</span>
<span class="p_header">--- a/fs/btrfs/delayed-inode.c</span>
<span class="p_header">+++ b/fs/btrfs/delayed-inode.c</span>
<span class="p_chunk">@@ -1371,7 +1371,8 @@</span> <span class="p_context"> release_path:</span>
 	total_done++;
 
 	btrfs_release_prepared_delayed_node(delayed_node);
<span class="p_del">-	if (async_work-&gt;nr == 0 || total_done &lt; async_work-&gt;nr)</span>
<span class="p_add">+	if ((async_work-&gt;nr == 0 &amp;&amp; total_done &lt; BTRFS_DELAYED_WRITEBACK) ||</span>
<span class="p_add">+	    total_done &lt; async_work-&gt;nr)</span>
 		goto again;
 
 free_path:
<span class="p_chunk">@@ -1383,11 +1384,12 @@</span> <span class="p_context"> out:</span>
 
 
 static int btrfs_wq_run_delayed_node(struct btrfs_delayed_root *delayed_root,
<span class="p_del">-				     struct btrfs_root *root, int nr)</span>
<span class="p_add">+				     struct btrfs_fs_info *fs_info, int nr)</span>
 {
 	struct btrfs_async_delayed_work *async_work;
 
<span class="p_del">-	if (atomic_read(&amp;delayed_root-&gt;items) &lt; BTRFS_DELAYED_BACKGROUND)</span>
<span class="p_add">+	if (atomic_read(&amp;delayed_root-&gt;items) &lt; BTRFS_DELAYED_BACKGROUND ||</span>
<span class="p_add">+	    btrfs_workqueue_normal_congested(fs_info-&gt;delayed_workers))</span>
 		return 0;
 
 	async_work = kmalloc(sizeof(*async_work), GFP_NOFS);
<span class="p_chunk">@@ -1399,7 +1401,7 @@</span> <span class="p_context"> static int btrfs_wq_run_delayed_node(struct btrfs_delayed_root *delayed_root,</span>
 			btrfs_async_run_delayed_root, NULL, NULL);
 	async_work-&gt;nr = nr;
 
<span class="p_del">-	btrfs_queue_work(root-&gt;fs_info-&gt;delayed_workers, &amp;async_work-&gt;work);</span>
<span class="p_add">+	btrfs_queue_work(fs_info-&gt;delayed_workers, &amp;async_work-&gt;work);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1426,6 +1428,7 @@</span> <span class="p_context"> static int could_end_wait(struct btrfs_delayed_root *delayed_root, int seq)</span>
 void btrfs_balance_delayed_items(struct btrfs_root *root)
 {
 	struct btrfs_delayed_root *delayed_root;
<span class="p_add">+	struct btrfs_fs_info *fs_info = root-&gt;fs_info;</span>
 
 	delayed_root = btrfs_get_delayed_root(root);
 
<span class="p_chunk">@@ -1438,7 +1441,7 @@</span> <span class="p_context"> void btrfs_balance_delayed_items(struct btrfs_root *root)</span>
 
 		seq = atomic_read(&amp;delayed_root-&gt;items_seq);
 
<span class="p_del">-		ret = btrfs_wq_run_delayed_node(delayed_root, root, 0);</span>
<span class="p_add">+		ret = btrfs_wq_run_delayed_node(delayed_root, fs_info, 0);</span>
 		if (ret)
 			return;
 
<span class="p_chunk">@@ -1447,7 +1450,7 @@</span> <span class="p_context"> void btrfs_balance_delayed_items(struct btrfs_root *root)</span>
 		return;
 	}
 
<span class="p_del">-	btrfs_wq_run_delayed_node(delayed_root, root, BTRFS_DELAYED_BATCH);</span>
<span class="p_add">+	btrfs_wq_run_delayed_node(delayed_root, fs_info, BTRFS_DELAYED_BATCH);</span>
 }
 
 /* Will return 0 or -ENOMEM */
<span class="p_header">diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c</span>
<span class="p_header">index 482ebbcd1d72..fd518dffe6d3 100644</span>
<span class="p_header">--- a/fs/btrfs/extent-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/extent-tree.c</span>
<span class="p_chunk">@@ -2429,11 +2429,11 @@</span> <span class="p_context"> static noinline int __btrfs_run_delayed_refs(struct btrfs_trans_handle *trans,</span>
 		if (ref &amp;&amp; ref-&gt;seq &amp;&amp;
 		    btrfs_check_delayed_seq(fs_info, delayed_refs, ref-&gt;seq)) {
 			spin_unlock(&amp;locked_ref-&gt;lock);
<span class="p_del">-			btrfs_delayed_ref_unlock(locked_ref);</span>
 			spin_lock(&amp;delayed_refs-&gt;lock);
 			locked_ref-&gt;processing = 0;
 			delayed_refs-&gt;num_heads_ready++;
 			spin_unlock(&amp;delayed_refs-&gt;lock);
<span class="p_add">+			btrfs_delayed_ref_unlock(locked_ref);</span>
 			locked_ref = NULL;
 			cond_resched();
 			count++;
<span class="p_chunk">@@ -2479,7 +2479,10 @@</span> <span class="p_context"> static noinline int __btrfs_run_delayed_refs(struct btrfs_trans_handle *trans,</span>
 					 */
 					if (must_insert_reserved)
 						locked_ref-&gt;must_insert_reserved = 1;
<span class="p_add">+					spin_lock(&amp;delayed_refs-&gt;lock);</span>
 					locked_ref-&gt;processing = 0;
<span class="p_add">+					delayed_refs-&gt;num_heads_ready++;</span>
<span class="p_add">+					spin_unlock(&amp;delayed_refs-&gt;lock);</span>
 					btrfs_debug(fs_info, &quot;run_delayed_extent_op returned %d&quot;, ret);
 					btrfs_delayed_ref_unlock(locked_ref);
 					return ret;
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index eb4348781a97..cde876a98fb8 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -5536,6 +5536,10 @@</span> <span class="p_context"> long btrfs_ioctl(struct file *file, unsigned int</span>
 #ifdef CONFIG_COMPAT
 long btrfs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * These all access 32-bit values anyway so no further</span>
<span class="p_add">+	 * handling is necessary.</span>
<span class="p_add">+	 */</span>
 	switch (cmd) {
 	case FS_IOC32_GETFLAGS:
 		cmd = FS_IOC_GETFLAGS;
<span class="p_chunk">@@ -5546,8 +5550,6 @@</span> <span class="p_context"> long btrfs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
 	case FS_IOC32_GETVERSION:
 		cmd = FS_IOC_GETVERSION;
 		break;
<span class="p_del">-	default:</span>
<span class="p_del">-		return -ENOIOCTLCMD;</span>
 	}
 
 	return btrfs_ioctl(file, cmd, (unsigned long) compat_ptr(arg));
<span class="p_header">diff --git a/fs/btrfs/tree-log.c b/fs/btrfs/tree-log.c</span>
<span class="p_header">index 023c5d905aac..a0fa16033006 100644</span>
<span class="p_header">--- a/fs/btrfs/tree-log.c</span>
<span class="p_header">+++ b/fs/btrfs/tree-log.c</span>
<span class="p_chunk">@@ -1778,12 +1778,11 @@</span> <span class="p_context"> static noinline int find_dir_range(struct btrfs_root *root,</span>
 next:
 	/* check the next slot in the tree to see if it is a valid item */
 	nritems = btrfs_header_nritems(path-&gt;nodes[0]);
<span class="p_add">+	path-&gt;slots[0]++;</span>
 	if (path-&gt;slots[0] &gt;= nritems) {
 		ret = btrfs_next_leaf(root, path);
 		if (ret)
 			goto out;
<span class="p_del">-	} else {</span>
<span class="p_del">-		path-&gt;slots[0]++;</span>
 	}
 
 	btrfs_item_key_to_cpu(path-&gt;nodes[0], &amp;key, path-&gt;slots[0]);
<span class="p_header">diff --git a/fs/ceph/mds_client.c b/fs/ceph/mds_client.c</span>
<span class="p_header">index 8f5835c89194..61266439b603 100644</span>
<span class="p_header">--- a/fs/ceph/mds_client.c</span>
<span class="p_header">+++ b/fs/ceph/mds_client.c</span>
<span class="p_chunk">@@ -262,12 +262,13 @@</span> <span class="p_context"> static int parse_reply_info_extra(void **p, void *end,</span>
 				  struct ceph_mds_reply_info_parsed *info,
 				  u64 features)
 {
<span class="p_del">-	if (info-&gt;head-&gt;op == CEPH_MDS_OP_GETFILELOCK)</span>
<span class="p_add">+	u32 op = le32_to_cpu(info-&gt;head-&gt;op);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (op == CEPH_MDS_OP_GETFILELOCK)</span>
 		return parse_reply_info_filelock(p, end, info, features);
<span class="p_del">-	else if (info-&gt;head-&gt;op == CEPH_MDS_OP_READDIR ||</span>
<span class="p_del">-		 info-&gt;head-&gt;op == CEPH_MDS_OP_LSSNAP)</span>
<span class="p_add">+	else if (op == CEPH_MDS_OP_READDIR || op == CEPH_MDS_OP_LSSNAP)</span>
 		return parse_reply_info_dir(p, end, info, features);
<span class="p_del">-	else if (info-&gt;head-&gt;op == CEPH_MDS_OP_CREATE)</span>
<span class="p_add">+	else if (op == CEPH_MDS_OP_CREATE)</span>
 		return parse_reply_info_create(p, end, info, features);
 	else
 		return -EIO;
<span class="p_header">diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h</span>
<span class="p_header">index 1c663a16f78a..ba4b92846cf0 100644</span>
<span class="p_header">--- a/fs/cifs/cifsglob.h</span>
<span class="p_header">+++ b/fs/cifs/cifsglob.h</span>
<span class="p_chunk">@@ -606,6 +606,8 @@</span> <span class="p_context"> struct TCP_Server_Info {</span>
 #ifdef CONFIG_CIFS_SMB2
 	unsigned int	max_read;
 	unsigned int	max_write;
<span class="p_add">+	struct delayed_work reconnect; /* reconnect workqueue job */</span>
<span class="p_add">+	struct mutex reconnect_mutex; /* prevent simultaneous reconnects */</span>
 #endif /* CONFIG_CIFS_SMB2 */
 };
 
<span class="p_chunk">@@ -795,6 +797,7 @@</span> <span class="p_context"> cap_unix(struct cifs_ses *ses)</span>
 struct cifs_tcon {
 	struct list_head tcon_list;
 	int tc_count;
<span class="p_add">+	struct list_head rlist; /* reconnect list */</span>
 	struct list_head openFileList;
 	spinlock_t open_file_lock; /* protects list above */
 	struct cifs_ses *ses;	/* pointer to session associated with */
<span class="p_header">diff --git a/fs/cifs/cifsproto.h b/fs/cifs/cifsproto.h</span>
<span class="p_header">index 05ce3072fb09..ea1cbff2932f 100644</span>
<span class="p_header">--- a/fs/cifs/cifsproto.h</span>
<span class="p_header">+++ b/fs/cifs/cifsproto.h</span>
<span class="p_chunk">@@ -203,6 +203,9 @@</span> <span class="p_context"> extern void cifs_add_pending_open_locked(struct cifs_fid *fid,</span>
 					 struct tcon_link *tlink,
 					 struct cifs_pending_open *open);
 extern void cifs_del_pending_open(struct cifs_pending_open *open);
<span class="p_add">+extern void cifs_put_tcp_session(struct TCP_Server_Info *server,</span>
<span class="p_add">+				 int from_reconnect);</span>
<span class="p_add">+extern void cifs_put_tcon(struct cifs_tcon *tcon);</span>
 
 #if IS_ENABLED(CONFIG_CIFS_DFS_UPCALL)
 extern void cifs_dfs_release_automount_timer(void);
<span class="p_header">diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c</span>
<span class="p_header">index 4392296e6f3f..b8c5b541c813 100644</span>
<span class="p_header">--- a/fs/cifs/connect.c</span>
<span class="p_header">+++ b/fs/cifs/connect.c</span>
<span class="p_chunk">@@ -52,6 +52,9 @@</span> <span class="p_context"></span>
 #include &quot;nterr.h&quot;
 #include &quot;rfc1002pdu.h&quot;
 #include &quot;fscache.h&quot;
<span class="p_add">+#ifdef CONFIG_CIFS_SMB2</span>
<span class="p_add">+#include &quot;smb2proto.h&quot;</span>
<span class="p_add">+#endif</span>
 
 #define CIFS_PORT 445
 #define RFC1001_PORT 139
<span class="p_chunk">@@ -2060,8 +2063,8 @@</span> <span class="p_context"> cifs_find_tcp_session(struct smb_vol *vol)</span>
 	return NULL;
 }
 
<span class="p_del">-static void</span>
<span class="p_del">-cifs_put_tcp_session(struct TCP_Server_Info *server)</span>
<span class="p_add">+void</span>
<span class="p_add">+cifs_put_tcp_session(struct TCP_Server_Info *server, int from_reconnect)</span>
 {
 	struct task_struct *task;
 
<span class="p_chunk">@@ -2078,6 +2081,19 @@</span> <span class="p_context"> cifs_put_tcp_session(struct TCP_Server_Info *server)</span>
 
 	cancel_delayed_work_sync(&amp;server-&gt;echo);
 
<span class="p_add">+#ifdef CONFIG_CIFS_SMB2</span>
<span class="p_add">+	if (from_reconnect)</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Avoid deadlock here: reconnect work calls</span>
<span class="p_add">+		 * cifs_put_tcp_session() at its end. Need to be sure</span>
<span class="p_add">+		 * that reconnect work does nothing with server pointer after</span>
<span class="p_add">+		 * that step.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		cancel_delayed_work(&amp;server-&gt;reconnect);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		cancel_delayed_work_sync(&amp;server-&gt;reconnect);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	spin_lock(&amp;GlobalMid_Lock);
 	server-&gt;tcpStatus = CifsExiting;
 	spin_unlock(&amp;GlobalMid_Lock);
<span class="p_chunk">@@ -2142,6 +2158,10 @@</span> <span class="p_context"> cifs_get_tcp_session(struct smb_vol *volume_info)</span>
 	INIT_LIST_HEAD(&amp;tcp_ses-&gt;tcp_ses_list);
 	INIT_LIST_HEAD(&amp;tcp_ses-&gt;smb_ses_list);
 	INIT_DELAYED_WORK(&amp;tcp_ses-&gt;echo, cifs_echo_request);
<span class="p_add">+#ifdef CONFIG_CIFS_SMB2</span>
<span class="p_add">+	INIT_DELAYED_WORK(&amp;tcp_ses-&gt;reconnect, smb2_reconnect_server);</span>
<span class="p_add">+	mutex_init(&amp;tcp_ses-&gt;reconnect_mutex);</span>
<span class="p_add">+#endif</span>
 	memcpy(&amp;tcp_ses-&gt;srcaddr, &amp;volume_info-&gt;srcaddr,
 	       sizeof(tcp_ses-&gt;srcaddr));
 	memcpy(&amp;tcp_ses-&gt;dstaddr, &amp;volume_info-&gt;dstaddr,
<span class="p_chunk">@@ -2294,7 +2314,7 @@</span> <span class="p_context"> cifs_put_smb_ses(struct cifs_ses *ses)</span>
 	spin_unlock(&amp;cifs_tcp_ses_lock);
 
 	sesInfoFree(ses);
<span class="p_del">-	cifs_put_tcp_session(server);</span>
<span class="p_add">+	cifs_put_tcp_session(server, 0);</span>
 }
 
 #ifdef CONFIG_KEYS
<span class="p_chunk">@@ -2467,7 +2487,7 @@</span> <span class="p_context"> cifs_get_smb_ses(struct TCP_Server_Info *server, struct smb_vol *volume_info)</span>
 		mutex_unlock(&amp;ses-&gt;session_mutex);
 
 		/* existing SMB ses has a server reference already */
<span class="p_del">-		cifs_put_tcp_session(server);</span>
<span class="p_add">+		cifs_put_tcp_session(server, 0);</span>
 		free_xid(xid);
 		return ses;
 	}
<span class="p_chunk">@@ -2557,7 +2577,7 @@</span> <span class="p_context"> cifs_find_tcon(struct cifs_ses *ses, const char *unc)</span>
 	return NULL;
 }
 
<span class="p_del">-static void</span>
<span class="p_add">+void</span>
 cifs_put_tcon(struct cifs_tcon *tcon)
 {
 	unsigned int xid;
<span class="p_chunk">@@ -3606,7 +3626,7 @@</span> <span class="p_context"> mount_fail_check:</span>
 		else if (ses)
 			cifs_put_smb_ses(ses);
 		else
<span class="p_del">-			cifs_put_tcp_session(server);</span>
<span class="p_add">+			cifs_put_tcp_session(server, 0);</span>
 		bdi_destroy(&amp;cifs_sb-&gt;bdi);
 	}
 
<span class="p_chunk">@@ -3910,7 +3930,7 @@</span> <span class="p_context"> cifs_construct_tcon(struct cifs_sb_info *cifs_sb, kuid_t fsuid)</span>
 	ses = cifs_get_smb_ses(master_tcon-&gt;ses-&gt;server, vol_info);
 	if (IS_ERR(ses)) {
 		tcon = (struct cifs_tcon *)ses;
<span class="p_del">-		cifs_put_tcp_session(master_tcon-&gt;ses-&gt;server);</span>
<span class="p_add">+		cifs_put_tcp_session(master_tcon-&gt;ses-&gt;server, 0);</span>
 		goto out;
 	}
 
<span class="p_header">diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c</span>
<span class="p_header">index 45992944e238..b87b07504947 100644</span>
<span class="p_header">--- a/fs/cifs/smb2file.c</span>
<span class="p_header">+++ b/fs/cifs/smb2file.c</span>
<span class="p_chunk">@@ -241,7 +241,7 @@</span> <span class="p_context"> smb2_push_mandatory_locks(struct cifsFileInfo *cfile)</span>
 	 * and check it for zero before using.
 	 */
 	max_buf = tlink_tcon(cfile-&gt;tlink)-&gt;ses-&gt;server-&gt;maxBuf;
<span class="p_del">-	if (!max_buf) {</span>
<span class="p_add">+	if (max_buf &lt; sizeof(struct smb2_lock_element)) {</span>
 		free_xid(xid);
 		return -EINVAL;
 	}
<span class="p_header">diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c</span>
<span class="p_header">index 1da1622aa1ea..2256a992389f 100644</span>
<span class="p_header">--- a/fs/cifs/smb2pdu.c</span>
<span class="p_header">+++ b/fs/cifs/smb2pdu.c</span>
<span class="p_chunk">@@ -282,7 +282,7 @@</span> <span class="p_context"> out:</span>
 	case SMB2_CHANGE_NOTIFY:
 	case SMB2_QUERY_INFO:
 	case SMB2_SET_INFO:
<span class="p_del">-		return -EAGAIN;</span>
<span class="p_add">+		rc = -EAGAIN;</span>
 	}
 	unload_nls(nls_codepage);
 	return rc;
<span class="p_chunk">@@ -1598,6 +1598,54 @@</span> <span class="p_context"> smb2_echo_callback(struct mid_q_entry *mid)</span>
 	add_credits(server, credits_received, CIFS_ECHO_OP);
 }
 
<span class="p_add">+void smb2_reconnect_server(struct work_struct *work)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct TCP_Server_Info *server = container_of(work,</span>
<span class="p_add">+					struct TCP_Server_Info, reconnect.work);</span>
<span class="p_add">+	struct cifs_ses *ses;</span>
<span class="p_add">+	struct cifs_tcon *tcon, *tcon2;</span>
<span class="p_add">+	struct list_head tmp_list;</span>
<span class="p_add">+	int tcon_exist = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Prevent simultaneous reconnects that can corrupt tcon-&gt;rlist list */</span>
<span class="p_add">+	mutex_lock(&amp;server-&gt;reconnect_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;tmp_list);</span>
<span class="p_add">+	cifs_dbg(FYI, &quot;Need negotiate, reconnecting tcons\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;cifs_tcp_ses_lock);</span>
<span class="p_add">+	list_for_each_entry(ses, &amp;server-&gt;smb_ses_list, smb_ses_list) {</span>
<span class="p_add">+		list_for_each_entry(tcon, &amp;ses-&gt;tcon_list, tcon_list) {</span>
<span class="p_add">+			if (tcon-&gt;need_reconnect) {</span>
<span class="p_add">+				tcon-&gt;tc_count++;</span>
<span class="p_add">+				list_add_tail(&amp;tcon-&gt;rlist, &amp;tmp_list);</span>
<span class="p_add">+				tcon_exist = true;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Get the reference to server struct to be sure that the last call of</span>
<span class="p_add">+	 * cifs_put_tcon() in the loop below won&#39;t release the server pointer.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (tcon_exist)</span>
<span class="p_add">+		server-&gt;srv_count++;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock(&amp;cifs_tcp_ses_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry_safe(tcon, tcon2, &amp;tmp_list, rlist) {</span>
<span class="p_add">+		smb2_reconnect(SMB2_ECHO, tcon);</span>
<span class="p_add">+		list_del_init(&amp;tcon-&gt;rlist);</span>
<span class="p_add">+		cifs_put_tcon(tcon);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	cifs_dbg(FYI, &quot;Reconnecting tcons finished\n&quot;);</span>
<span class="p_add">+	mutex_unlock(&amp;server-&gt;reconnect_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* now we can safely release srv struct */</span>
<span class="p_add">+	if (tcon_exist)</span>
<span class="p_add">+		cifs_put_tcp_session(server, 1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int
 SMB2_echo(struct TCP_Server_Info *server)
 {
<span class="p_chunk">@@ -1610,32 +1658,11 @@</span> <span class="p_context"> SMB2_echo(struct TCP_Server_Info *server)</span>
 	cifs_dbg(FYI, &quot;In echo request\n&quot;);
 
 	if (server-&gt;tcpStatus == CifsNeedNegotiate) {
<span class="p_del">-		struct list_head *tmp, *tmp2;</span>
<span class="p_del">-		struct cifs_ses *ses;</span>
<span class="p_del">-		struct cifs_tcon *tcon;</span>
<span class="p_del">-</span>
<span class="p_del">-		cifs_dbg(FYI, &quot;Need negotiate, reconnecting tcons\n&quot;);</span>
<span class="p_del">-		spin_lock(&amp;cifs_tcp_ses_lock);</span>
<span class="p_del">-		list_for_each(tmp, &amp;server-&gt;smb_ses_list) {</span>
<span class="p_del">-			ses = list_entry(tmp, struct cifs_ses, smb_ses_list);</span>
<span class="p_del">-			list_for_each(tmp2, &amp;ses-&gt;tcon_list) {</span>
<span class="p_del">-				tcon = list_entry(tmp2, struct cifs_tcon,</span>
<span class="p_del">-						  tcon_list);</span>
<span class="p_del">-				/* add check for persistent handle reconnect */</span>
<span class="p_del">-				if (tcon &amp;&amp; tcon-&gt;need_reconnect) {</span>
<span class="p_del">-					spin_unlock(&amp;cifs_tcp_ses_lock);</span>
<span class="p_del">-					rc = smb2_reconnect(SMB2_ECHO, tcon);</span>
<span class="p_del">-					spin_lock(&amp;cifs_tcp_ses_lock);</span>
<span class="p_del">-				}</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
<span class="p_del">-		spin_unlock(&amp;cifs_tcp_ses_lock);</span>
<span class="p_add">+		/* No need to send echo on newly established connections */</span>
<span class="p_add">+		queue_delayed_work(cifsiod_wq, &amp;server-&gt;reconnect, 0);</span>
<span class="p_add">+		return rc;</span>
 	}
 
<span class="p_del">-	/* if no session, renegotiate failed above */</span>
<span class="p_del">-	if (server-&gt;tcpStatus == CifsNeedNegotiate)</span>
<span class="p_del">-		return -EIO;</span>
<span class="p_del">-</span>
 	rc = small_smb2_init(SMB2_ECHO, NULL, (void **)&amp;req);
 	if (rc)
 		return rc;
<span class="p_header">diff --git a/fs/cifs/smb2proto.h b/fs/cifs/smb2proto.h</span>
<span class="p_header">index 8e0d57bf446b..98d9b36ea3e2 100644</span>
<span class="p_header">--- a/fs/cifs/smb2proto.h</span>
<span class="p_header">+++ b/fs/cifs/smb2proto.h</span>
<span class="p_chunk">@@ -89,6 +89,7 @@</span> <span class="p_context"> extern int smb2_open_file(const unsigned int xid,</span>
 extern int smb2_unlock_range(struct cifsFileInfo *cfile,
 			     struct file_lock *flock, const unsigned int xid);
 extern int smb2_push_mandatory_locks(struct cifsFileInfo *cfile);
<span class="p_add">+extern void smb2_reconnect_server(struct work_struct *work);</span>
 
 /*
  * SMB2 Worker functions - most of protocol specific implementation details
<span class="p_header">diff --git a/fs/exec.c b/fs/exec.c</span>
<span class="p_header">index 993ed0aba99a..5b653a126b20 100644</span>
<span class="p_header">--- a/fs/exec.c</span>
<span class="p_header">+++ b/fs/exec.c</span>
<span class="p_chunk">@@ -19,7 +19,7 @@</span> <span class="p_context"></span>
  * current-&gt;executable is only used by the procfs.  This allows a dispatch
  * table to check for several different types  of binary formats.  We keep
  * trying until we recognize the file or we run out of supported binary
<span class="p_del">- * formats. </span>
<span class="p_add">+ * formats.</span>
  */
 
 #include &lt;linux/slab.h&gt;
<span class="p_chunk">@@ -1087,6 +1087,13 @@</span> <span class="p_context"> int flush_old_exec(struct linux_binprm * bprm)</span>
 	flush_thread();
 	current-&gt;personality &amp;= ~bprm-&gt;per_clear;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We have to apply CLOEXEC before we change whether the process is</span>
<span class="p_add">+	 * dumpable (in setup_new_exec) to avoid a race with a process in userspace</span>
<span class="p_add">+	 * trying to access the should-be-closed file descriptors of a process</span>
<span class="p_add">+	 * undergoing exec(2).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	do_close_on_exec(current-&gt;files);</span>
 	return 0;
 
 out:
<span class="p_chunk">@@ -1136,7 +1143,6 @@</span> <span class="p_context"> void setup_new_exec(struct linux_binprm * bprm)</span>
 	   group */
 	current-&gt;self_exec_id++;
 	flush_signal_handlers(current, 0);
<span class="p_del">-	do_close_on_exec(current-&gt;files);</span>
 }
 EXPORT_SYMBOL(setup_new_exec);
 
<span class="p_header">diff --git a/fs/ext4/inline.c b/fs/ext4/inline.c</span>
<span class="p_header">index 7af6a3dcbb1f..7bd13f3d1790 100644</span>
<span class="p_header">--- a/fs/ext4/inline.c</span>
<span class="p_header">+++ b/fs/ext4/inline.c</span>
<span class="p_chunk">@@ -340,8 +340,10 @@</span> <span class="p_context"> static int ext4_update_inline_data(handle_t *handle, struct inode *inode,</span>
 
 	len -= EXT4_MIN_INLINE_DATA_SIZE;
 	value = kzalloc(len, GFP_NOFS);
<span class="p_del">-	if (!value)</span>
<span class="p_add">+	if (!value) {</span>
<span class="p_add">+		error = -ENOMEM;</span>
 		goto out;
<span class="p_add">+	}</span>
 
 	error = ext4_xattr_ibody_get(inode, i.name_index, i.name,
 				     value, len);
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index c37dd715060f..898e9659ebf1 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -4118,6 +4118,7 @@</span> <span class="p_context"> struct inode *ext4_iget(struct super_block *sb, unsigned long ino)</span>
 	struct inode *inode;
 	journal_t *journal = EXT4_SB(sb)-&gt;s_journal;
 	long ret;
<span class="p_add">+	loff_t size;</span>
 	int block;
 	uid_t i_uid;
 	gid_t i_gid;
<span class="p_chunk">@@ -4209,6 +4210,11 @@</span> <span class="p_context"> struct inode *ext4_iget(struct super_block *sb, unsigned long ino)</span>
 		ei-&gt;i_file_acl |=
 			((__u64)le16_to_cpu(raw_inode-&gt;i_file_acl_high)) &lt;&lt; 32;
 	inode-&gt;i_size = ext4_isize(raw_inode);
<span class="p_add">+	if ((size = i_size_read(inode)) &lt; 0) {</span>
<span class="p_add">+		EXT4_ERROR_INODE(inode, &quot;bad i_size value: %lld&quot;, size);</span>
<span class="p_add">+		ret = -EIO;</span>
<span class="p_add">+		goto bad_inode;</span>
<span class="p_add">+	}</span>
 	ei-&gt;i_disksize = inode-&gt;i_size;
 #ifdef CONFIG_QUOTA
 	ei-&gt;i_reserved_quota = 0;
<span class="p_header">diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c</span>
<span class="p_header">index 62d0c5cbcad6..425dd618a9e2 100644</span>
<span class="p_header">--- a/fs/ext4/mballoc.c</span>
<span class="p_header">+++ b/fs/ext4/mballoc.c</span>
<span class="p_chunk">@@ -668,7 +668,7 @@</span> <span class="p_context"> static void ext4_mb_mark_free_simple(struct super_block *sb,</span>
 	ext4_grpblk_t min;
 	ext4_grpblk_t max;
 	ext4_grpblk_t chunk;
<span class="p_del">-	unsigned short border;</span>
<span class="p_add">+	unsigned int border;</span>
 
 	BUG_ON(len &gt; EXT4_CLUSTERS_PER_GROUP(sb));
 
<span class="p_chunk">@@ -2252,7 +2252,7 @@</span> <span class="p_context"> static int ext4_mb_seq_groups_show(struct seq_file *seq, void *v)</span>
 	struct ext4_group_info *grinfo;
 	struct sg {
 		struct ext4_group_info info;
<span class="p_del">-		ext4_grpblk_t counters[16];</span>
<span class="p_add">+		ext4_grpblk_t counters[EXT4_MAX_BLOCK_LOG_SIZE + 2];</span>
 	} sg;
 
 	group--;
<span class="p_header">diff --git a/fs/ext4/super.c b/fs/ext4/super.c</span>
<span class="p_header">index 13a33c3047f4..c608d805f509 100644</span>
<span class="p_header">--- a/fs/ext4/super.c</span>
<span class="p_header">+++ b/fs/ext4/super.c</span>
<span class="p_chunk">@@ -3301,10 +3301,15 @@</span> <span class="p_context"> static int count_overhead(struct super_block *sb, ext4_group_t grp,</span>
 			ext4_set_bit(s++, buf);
 			count++;
 		}
<span class="p_del">-		for (j = ext4_bg_num_gdb(sb, grp); j &gt; 0; j--) {</span>
<span class="p_del">-			ext4_set_bit(EXT4_B2C(sbi, s++), buf);</span>
<span class="p_del">-			count++;</span>
<span class="p_add">+		j = ext4_bg_num_gdb(sb, grp);</span>
<span class="p_add">+		if (s + j &gt; EXT4_BLOCKS_PER_GROUP(sb)) {</span>
<span class="p_add">+			ext4_error(sb, &quot;Invalid number of block group &quot;</span>
<span class="p_add">+				   &quot;descriptor blocks: %d&quot;, j);</span>
<span class="p_add">+			j = EXT4_BLOCKS_PER_GROUP(sb) - s;</span>
 		}
<span class="p_add">+		count += j;</span>
<span class="p_add">+		for (; j &gt; 0; j--)</span>
<span class="p_add">+			ext4_set_bit(EXT4_B2C(sbi, s++), buf);</span>
 	}
 	if (!count)
 		return 0;
<span class="p_chunk">@@ -3407,7 +3412,7 @@</span> <span class="p_context"> static int ext4_fill_super(struct super_block *sb, void *data, int silent)</span>
 	char *orig_data = kstrdup(data, GFP_KERNEL);
 	struct buffer_head *bh;
 	struct ext4_super_block *es = NULL;
<span class="p_del">-	struct ext4_sb_info *sbi;</span>
<span class="p_add">+	struct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);</span>
 	ext4_fsblk_t block;
 	ext4_fsblk_t sb_block = get_sb_block(&amp;data);
 	ext4_fsblk_t logical_sb_block;
<span class="p_chunk">@@ -3427,16 +3432,14 @@</span> <span class="p_context"> static int ext4_fill_super(struct super_block *sb, void *data, int silent)</span>
 	unsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;
 	ext4_group_t first_not_zeroed;
 
<span class="p_del">-	sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);</span>
<span class="p_del">-	if (!sbi)</span>
<span class="p_del">-		goto out_free_orig;</span>
<span class="p_add">+	if ((data &amp;&amp; !orig_data) || !sbi)</span>
<span class="p_add">+		goto out_free_base;</span>
 
 	sbi-&gt;s_blockgroup_lock =
 		kzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);
<span class="p_del">-	if (!sbi-&gt;s_blockgroup_lock) {</span>
<span class="p_del">-		kfree(sbi);</span>
<span class="p_del">-		goto out_free_orig;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (!sbi-&gt;s_blockgroup_lock)</span>
<span class="p_add">+		goto out_free_base;</span>
<span class="p_add">+</span>
 	sb-&gt;s_fs_info = sbi;
 	sbi-&gt;s_sb = sb;
 	sbi-&gt;s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;
<span class="p_chunk">@@ -3582,11 +3585,19 @@</span> <span class="p_context"> static int ext4_fill_super(struct super_block *sb, void *data, int silent)</span>
 	 */
 	sbi-&gt;s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;
 
<span class="p_del">-	if (!parse_options((char *) sbi-&gt;s_es-&gt;s_mount_opts, sb,</span>
<span class="p_del">-			   &amp;journal_devnum, &amp;journal_ioprio, 0)) {</span>
<span class="p_del">-		ext4_msg(sb, KERN_WARNING,</span>
<span class="p_del">-			 &quot;failed to parse options in superblock: %s&quot;,</span>
<span class="p_del">-			 sbi-&gt;s_es-&gt;s_mount_opts);</span>
<span class="p_add">+	if (sbi-&gt;s_es-&gt;s_mount_opts[0]) {</span>
<span class="p_add">+		char *s_mount_opts = kstrndup(sbi-&gt;s_es-&gt;s_mount_opts,</span>
<span class="p_add">+					      sizeof(sbi-&gt;s_es-&gt;s_mount_opts),</span>
<span class="p_add">+					      GFP_KERNEL);</span>
<span class="p_add">+		if (!s_mount_opts)</span>
<span class="p_add">+			goto failed_mount;</span>
<span class="p_add">+		if (!parse_options(s_mount_opts, sb, &amp;journal_devnum,</span>
<span class="p_add">+				   &amp;journal_ioprio, 0)) {</span>
<span class="p_add">+			ext4_msg(sb, KERN_WARNING,</span>
<span class="p_add">+				 &quot;failed to parse options in superblock: %s&quot;,</span>
<span class="p_add">+				 s_mount_opts);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		kfree(s_mount_opts);</span>
 	}
 	sbi-&gt;s_def_mount_opt = sbi-&gt;s_mount_opt;
 	if (!parse_options((char *) data, sb, &amp;journal_devnum,
<span class="p_chunk">@@ -3750,12 +3761,16 @@</span> <span class="p_context"> static int ext4_fill_super(struct super_block *sb, void *data, int silent)</span>
 
 	sbi-&gt;s_blocks_per_group = le32_to_cpu(es-&gt;s_blocks_per_group);
 	sbi-&gt;s_inodes_per_group = le32_to_cpu(es-&gt;s_inodes_per_group);
<span class="p_del">-	if (EXT4_INODE_SIZE(sb) == 0 || EXT4_INODES_PER_GROUP(sb) == 0)</span>
<span class="p_del">-		goto cantfind_ext4;</span>
 
 	sbi-&gt;s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);
 	if (sbi-&gt;s_inodes_per_block == 0)
 		goto cantfind_ext4;
<span class="p_add">+	if (sbi-&gt;s_inodes_per_group &lt; sbi-&gt;s_inodes_per_block ||</span>
<span class="p_add">+	    sbi-&gt;s_inodes_per_group &gt; blocksize * 8) {</span>
<span class="p_add">+		ext4_msg(sb, KERN_ERR, &quot;invalid inodes per group: %lu\n&quot;,</span>
<span class="p_add">+			 sbi-&gt;s_blocks_per_group);</span>
<span class="p_add">+		goto failed_mount;</span>
<span class="p_add">+	}</span>
 	sbi-&gt;s_itb_per_group = sbi-&gt;s_inodes_per_group /
 					sbi-&gt;s_inodes_per_block;
 	sbi-&gt;s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);
<span class="p_chunk">@@ -3839,13 +3854,6 @@</span> <span class="p_context"> static int ext4_fill_super(struct super_block *sb, void *data, int silent)</span>
 	}
 	sbi-&gt;s_cluster_ratio = clustersize / blocksize;
 
<span class="p_del">-	if (sbi-&gt;s_inodes_per_group &gt; blocksize * 8) {</span>
<span class="p_del">-		ext4_msg(sb, KERN_ERR,</span>
<span class="p_del">-		       &quot;#inodes per group too big: %lu&quot;,</span>
<span class="p_del">-		       sbi-&gt;s_inodes_per_group);</span>
<span class="p_del">-		goto failed_mount;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	/* Do we have standard group size of clustersize * 8 blocks ? */
 	if (sbi-&gt;s_blocks_per_group == clustersize &lt;&lt; 3)
 		set_opt2(sb, STD_GROUP_SIZE);
<span class="p_chunk">@@ -4251,7 +4259,9 @@</span> <span class="p_context"> no_journal:</span>
 	}
 
 	ext4_msg(sb, KERN_INFO, &quot;mounted filesystem with%s. &quot;
<span class="p_del">-		 &quot;Opts: %s%s%s&quot;, descr, sbi-&gt;s_es-&gt;s_mount_opts,</span>
<span class="p_add">+		 &quot;Opts: %.*s%s%s&quot;, descr,</span>
<span class="p_add">+		 (int) sizeof(sbi-&gt;s_es-&gt;s_mount_opts),</span>
<span class="p_add">+		 sbi-&gt;s_es-&gt;s_mount_opts,</span>
 		 *sbi-&gt;s_es-&gt;s_mount_opts ? &quot;; &quot; : &quot;&quot;, orig_data);
 
 	if (es-&gt;s_error_count)
<span class="p_chunk">@@ -4325,8 +4335,8 @@</span> <span class="p_context"> failed_mount:</span>
 out_fail:
 	sb-&gt;s_fs_info = NULL;
 	kfree(sbi-&gt;s_blockgroup_lock);
<span class="p_add">+out_free_base:</span>
 	kfree(sbi);
<span class="p_del">-out_free_orig:</span>
 	kfree(orig_data);
 	return err ? err : ret;
 }
<span class="p_header">diff --git a/fs/f2fs/debug.c b/fs/f2fs/debug.c</span>
<span class="p_header">index b52c12cf5873..df18edb33601 100644</span>
<span class="p_header">--- a/fs/f2fs/debug.c</span>
<span class="p_header">+++ b/fs/f2fs/debug.c</span>
<span class="p_chunk">@@ -295,6 +295,7 @@</span> <span class="p_context"> static int stat_open(struct inode *inode, struct file *file)</span>
 }
 
 static const struct file_operations stat_fops = {
<span class="p_add">+	.owner = THIS_MODULE,</span>
 	.open = stat_open,
 	.read = seq_read,
 	.llseek = seq_lseek,
<span class="p_header">diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c</span>
<span class="p_header">index c832599669bc..5cbdbb6aedde 100644</span>
<span class="p_header">--- a/fs/nfs/dir.c</span>
<span class="p_header">+++ b/fs/nfs/dir.c</span>
<span class="p_chunk">@@ -455,7 +455,7 @@</span> <span class="p_context"> void nfs_force_use_readdirplus(struct inode *dir)</span>
 {
 	if (!list_empty(&amp;NFS_I(dir)-&gt;open_files)) {
 		nfs_advise_use_readdirplus(dir);
<span class="p_del">-		nfs_zap_mapping(dir, dir-&gt;i_mapping);</span>
<span class="p_add">+		invalidate_mapping_pages(dir-&gt;i_mapping, 0, -1);</span>
 	}
 }
 
<span class="p_chunk">@@ -837,17 +837,6 @@</span> <span class="p_context"> int uncached_readdir(nfs_readdir_descriptor_t *desc)</span>
 	goto out;
 }
 
<span class="p_del">-static bool nfs_dir_mapping_need_revalidate(struct inode *dir)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct nfs_inode *nfsi = NFS_I(dir);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (nfs_attribute_cache_expired(dir))</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	if (nfsi-&gt;cache_validity &amp; NFS_INO_INVALID_DATA)</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* The file offset position represents the dirent entry number.  A
    last cookie cache takes care of the common case of reading the
    whole directory.
<span class="p_chunk">@@ -880,7 +869,7 @@</span> <span class="p_context"> static int nfs_readdir(struct file *file, struct dir_context *ctx)</span>
 	desc-&gt;plus = nfs_use_readdirplus(inode, ctx) ? 1 : 0;
 
 	nfs_block_sillyrename(dentry);
<span class="p_del">-	if (ctx-&gt;pos == 0 || nfs_dir_mapping_need_revalidate(inode))</span>
<span class="p_add">+	if (ctx-&gt;pos == 0 || nfs_attribute_cache_expired(inode))</span>
 		res = nfs_revalidate_mapping(inode, file-&gt;f_mapping);
 	if (res &lt; 0)
 		goto out;
<span class="p_header">diff --git a/fs/nfs/file.c b/fs/nfs/file.c</span>
<span class="p_header">index 4042ff58fe3f..19cfc636b691 100644</span>
<span class="p_header">--- a/fs/nfs/file.c</span>
<span class="p_header">+++ b/fs/nfs/file.c</span>
<span class="p_chunk">@@ -403,7 +403,7 @@</span> <span class="p_context"> static int nfs_write_end(struct file *file, struct address_space *mapping,</span>
 	 */
 	if (!PageUptodate(page)) {
 		unsigned pglen = nfs_page_length(page);
<span class="p_del">-		unsigned end = offset + len;</span>
<span class="p_add">+		unsigned end = offset + copied;</span>
 
 		if (pglen == 0) {
 			zero_user_segments(page, 0, offset,
<span class="p_header">diff --git a/fs/nfs/filelayout/filelayoutdev.c b/fs/nfs/filelayout/filelayoutdev.c</span>
<span class="p_header">index 44bf0140a4c7..651b171387e2 100644</span>
<span class="p_header">--- a/fs/nfs/filelayout/filelayoutdev.c</span>
<span class="p_header">+++ b/fs/nfs/filelayout/filelayoutdev.c</span>
<span class="p_chunk">@@ -827,7 +827,8 @@</span> <span class="p_context"> nfs4_fl_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx)</span>
 		nfs4_wait_ds_connect(ds);
 	}
 out_test_devid:
<span class="p_del">-	if (filelayout_test_devid_unavailable(devid))</span>
<span class="p_add">+	if (ret-&gt;ds_clp == NULL ||</span>
<span class="p_add">+	    filelayout_test_devid_unavailable(devid))</span>
 		ret = NULL;
 out:
 	return ret;
<span class="p_header">diff --git a/fs/nfs/nfs4state.c b/fs/nfs/nfs4state.c</span>
<span class="p_header">index 3d88bc967c8e..f96c66b4d504 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4state.c</span>
<span class="p_chunk">@@ -1086,6 +1086,7 @@</span> <span class="p_context"> static void nfs_increment_seqid(int status, struct nfs_seqid *seqid)</span>
 		case -NFS4ERR_BADXDR:
 		case -NFS4ERR_RESOURCE:
 		case -NFS4ERR_NOFILEHANDLE:
<span class="p_add">+		case -NFS4ERR_MOVED:</span>
 			/* Non-seqid mutating errors */
 			return;
 	};
<span class="p_header">diff --git a/fs/notify/inode_mark.c b/fs/notify/inode_mark.c</span>
<span class="p_header">index fbb9dfb7b1d2..12c6ff070cd8 100644</span>
<span class="p_header">--- a/fs/notify/inode_mark.c</span>
<span class="p_header">+++ b/fs/notify/inode_mark.c</span>
<span class="p_chunk">@@ -249,12 +249,10 @@</span> <span class="p_context"> out:</span>
  */
 void fsnotify_unmount_inodes(struct list_head *list)
 {
<span class="p_del">-	struct inode *inode, *next_i, *need_iput = NULL;</span>
<span class="p_add">+	struct inode *inode, *iput_inode = NULL;</span>
 
 	spin_lock(&amp;inode_sb_list_lock);
<span class="p_del">-	list_for_each_entry_safe(inode, next_i, list, i_sb_list) {</span>
<span class="p_del">-		struct inode *need_iput_tmp;</span>
<span class="p_del">-</span>
<span class="p_add">+	list_for_each_entry(inode, list, i_sb_list) {</span>
 		/*
 		 * We cannot __iget() an inode in state I_FREEING,
 		 * I_WILL_FREE, or I_NEW which is fine because by that point
<span class="p_chunk">@@ -277,50 +275,24 @@</span> <span class="p_context"> void fsnotify_unmount_inodes(struct list_head *list)</span>
 			continue;
 		}
 
<span class="p_del">-		need_iput_tmp = need_iput;</span>
<span class="p_del">-		need_iput = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* In case fsnotify_inode_delete() drops a reference. */</span>
<span class="p_del">-		if (inode != need_iput_tmp)</span>
<span class="p_del">-			__iget(inode);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			need_iput_tmp = NULL;</span>
<span class="p_add">+		__iget(inode);</span>
 		spin_unlock(&amp;inode-&gt;i_lock);
<span class="p_del">-</span>
<span class="p_del">-		/* In case the dropping of a reference would nuke next_i. */</span>
<span class="p_del">-		while (&amp;next_i-&gt;i_sb_list != list) {</span>
<span class="p_del">-			spin_lock(&amp;next_i-&gt;i_lock);</span>
<span class="p_del">-			if (!(next_i-&gt;i_state &amp; (I_FREEING | I_WILL_FREE)) &amp;&amp;</span>
<span class="p_del">-						atomic_read(&amp;next_i-&gt;i_count)) {</span>
<span class="p_del">-				__iget(next_i);</span>
<span class="p_del">-				need_iput = next_i;</span>
<span class="p_del">-				spin_unlock(&amp;next_i-&gt;i_lock);</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			spin_unlock(&amp;next_i-&gt;i_lock);</span>
<span class="p_del">-			next_i = list_entry(next_i-&gt;i_sb_list.next,</span>
<span class="p_del">-						struct inode, i_sb_list);</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * We can safely drop inode_sb_list_lock here because either</span>
<span class="p_del">-		 * we actually hold references on both inode and next_i or</span>
<span class="p_del">-		 * end of list.  Also no new inodes will be added since the</span>
<span class="p_del">-		 * umount has begun.</span>
<span class="p_del">-		 */</span>
 		spin_unlock(&amp;inode_sb_list_lock);
 
<span class="p_del">-		if (need_iput_tmp)</span>
<span class="p_del">-			iput(need_iput_tmp);</span>
<span class="p_add">+		if (iput_inode)</span>
<span class="p_add">+			iput(iput_inode);</span>
 
 		/* for each watch, send FS_UNMOUNT and then remove it */
 		fsnotify(inode, FS_UNMOUNT, inode, FSNOTIFY_EVENT_INODE, NULL, 0);
 
 		fsnotify_inode_delete(inode);
 
<span class="p_del">-		iput(inode);</span>
<span class="p_add">+		iput_inode = inode;</span>
 
 		spin_lock(&amp;inode_sb_list_lock);
 	}
 	spin_unlock(&amp;inode_sb_list_lock);
<span class="p_add">+</span>
<span class="p_add">+	if (iput_inode)</span>
<span class="p_add">+		iput(iput_inode);</span>
 }
<span class="p_header">diff --git a/fs/ocfs2/dlmglue.c b/fs/ocfs2/dlmglue.c</span>
<span class="p_header">index 118a494a323e..3c4d6f5811e8 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlmglue.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlmglue.c</span>
<span class="p_chunk">@@ -3305,6 +3305,16 @@</span> <span class="p_context"> static int ocfs2_downconvert_lock(struct ocfs2_super *osb,</span>
 	mlog(ML_BASTS, &quot;lockres %s, level %d =&gt; %d\n&quot;, lockres-&gt;l_name,
 	     lockres-&gt;l_level, new_level);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * On DLM_LKF_VALBLK, fsdlm behaves differently with o2cb. It always</span>
<span class="p_add">+	 * expects DLM_LKF_VALBLK being set if the LKB has LVB, so that</span>
<span class="p_add">+	 * we can recover correctly from node failure. Otherwise, we may get</span>
<span class="p_add">+	 * invalid LVB in LKB, but without DLM_SBF_VALNOTVALID being set.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!ocfs2_is_o2cb_active() &amp;&amp;</span>
<span class="p_add">+	    lockres-&gt;l_ops-&gt;flags &amp; LOCK_TYPE_USES_LVB)</span>
<span class="p_add">+		lvb = 1;</span>
<span class="p_add">+</span>
 	if (lvb)
 		dlm_flags |= DLM_LKF_VALBLK;
 
<span class="p_header">diff --git a/fs/ocfs2/stackglue.c b/fs/ocfs2/stackglue.c</span>
<span class="p_header">index 5d965e83bd43..783bcdce5666 100644</span>
<span class="p_header">--- a/fs/ocfs2/stackglue.c</span>
<span class="p_header">+++ b/fs/ocfs2/stackglue.c</span>
<span class="p_chunk">@@ -48,6 +48,12 @@</span> <span class="p_context"> static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = &quot;/sbin/ocfs2_hb_ctl&quot;;</span>
  */
 static struct ocfs2_stack_plugin *active_stack;
 
<span class="p_add">+inline int ocfs2_is_o2cb_active(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return !strcmp(active_stack-&gt;sp_name, OCFS2_STACK_PLUGIN_O2CB);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(ocfs2_is_o2cb_active);</span>
<span class="p_add">+</span>
 static struct ocfs2_stack_plugin *ocfs2_stack_lookup(const char *name)
 {
 	struct ocfs2_stack_plugin *p;
<span class="p_header">diff --git a/fs/ocfs2/stackglue.h b/fs/ocfs2/stackglue.h</span>
<span class="p_header">index 66334a30cea8..e1b30931974d 100644</span>
<span class="p_header">--- a/fs/ocfs2/stackglue.h</span>
<span class="p_header">+++ b/fs/ocfs2/stackglue.h</span>
<span class="p_chunk">@@ -298,4 +298,7 @@</span> <span class="p_context"> void ocfs2_stack_glue_set_max_proto_version(struct ocfs2_protocol_version *max_p</span>
 int ocfs2_stack_glue_register(struct ocfs2_stack_plugin *plugin);
 void ocfs2_stack_glue_unregister(struct ocfs2_stack_plugin *plugin);
 
<span class="p_add">+/* In ocfs2_downconvert_lock(), we need to know which stack we are using */</span>
<span class="p_add">+int ocfs2_is_o2cb_active(void);</span>
<span class="p_add">+</span>
 #endif  /* STACKGLUE_H */
<span class="p_header">diff --git a/fs/splice.c b/fs/splice.c</span>
<span class="p_header">index 962c7f7e03f6..41f10ce929dd 100644</span>
<span class="p_header">--- a/fs/splice.c</span>
<span class="p_header">+++ b/fs/splice.c</span>
<span class="p_chunk">@@ -212,6 +212,7 @@</span> <span class="p_context"> ssize_t splice_to_pipe(struct pipe_inode_info *pipe,</span>
 			buf-&gt;len = spd-&gt;partial[page_nr].len;
 			buf-&gt;private = spd-&gt;partial[page_nr].private;
 			buf-&gt;ops = spd-&gt;ops;
<span class="p_add">+			buf-&gt;flags = 0;</span>
 			if (spd-&gt;flags &amp; SPLICE_F_GIFT)
 				buf-&gt;flags |= PIPE_BUF_FLAG_GIFT;
 
<span class="p_header">diff --git a/fs/ubifs/tnc.c b/fs/ubifs/tnc.c</span>
<span class="p_header">index 8a40cf9c02d7..f07596463cde 100644</span>
<span class="p_header">--- a/fs/ubifs/tnc.c</span>
<span class="p_header">+++ b/fs/ubifs/tnc.c</span>
<span class="p_chunk">@@ -34,6 +34,11 @@</span> <span class="p_context"></span>
 #include &lt;linux/slab.h&gt;
 #include &quot;ubifs.h&quot;
 
<span class="p_add">+static int try_read_node(const struct ubifs_info *c, void *buf, int type,</span>
<span class="p_add">+			 int len, int lnum, int offs);</span>
<span class="p_add">+static int fallible_read_node(struct ubifs_info *c, const union ubifs_key *key,</span>
<span class="p_add">+			      struct ubifs_zbranch *zbr, void *node);</span>
<span class="p_add">+</span>
 /*
  * Returned codes of &#39;matches_name()&#39; and &#39;fallible_matches_name()&#39; functions.
  * @NAME_LESS: name corresponding to the first argument is less than second
<span class="p_chunk">@@ -403,7 +408,19 @@</span> <span class="p_context"> static int tnc_read_node_nm(struct ubifs_info *c, struct ubifs_zbranch *zbr,</span>
 		return 0;
 	}
 
<span class="p_del">-	err = ubifs_tnc_read_node(c, zbr, node);</span>
<span class="p_add">+	if (c-&gt;replaying) {</span>
<span class="p_add">+		err = fallible_read_node(c, &amp;zbr-&gt;key, zbr, node);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * When the node was not found, return -ENOENT, 0 otherwise.</span>
<span class="p_add">+		 * Negative return codes stay as-is.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (err == 0)</span>
<span class="p_add">+			err = -ENOENT;</span>
<span class="p_add">+		else if (err == 1)</span>
<span class="p_add">+			err = 0;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		err = ubifs_tnc_read_node(c, zbr, node);</span>
<span class="p_add">+	}</span>
 	if (err)
 		return err;
 
<span class="p_chunk">@@ -2767,7 +2784,11 @@</span> <span class="p_context"> struct ubifs_dent_node *ubifs_tnc_next_ent(struct ubifs_info *c,</span>
 	if (nm-&gt;name) {
 		if (err) {
 			/* Handle collisions */
<span class="p_del">-			err = resolve_collision(c, key, &amp;znode, &amp;n, nm);</span>
<span class="p_add">+			if (c-&gt;replaying)</span>
<span class="p_add">+				err = fallible_resolve_collision(c, key, &amp;znode, &amp;n,</span>
<span class="p_add">+							 nm, 0);</span>
<span class="p_add">+			else</span>
<span class="p_add">+				err = resolve_collision(c, key, &amp;znode, &amp;n, nm);</span>
 			dbg_tnc(&quot;rc returned %d, znode %p, n %d&quot;,
 				err, znode, n);
 			if (unlikely(err &lt; 0))
<span class="p_header">diff --git a/fs/xfs/xfs_bmap_util.c b/fs/xfs/xfs_bmap_util.c</span>
<span class="p_header">index 3d807ef4f821..09dc999a7e4e 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_bmap_util.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_bmap_util.c</span>
<span class="p_chunk">@@ -1632,6 +1632,7 @@</span> <span class="p_context"> xfs_swap_extents(</span>
 	int		error = 0;
 	int		aforkblks = 0;
 	int		taforkblks = 0;
<span class="p_add">+	xfs_extnum_t	nextents;</span>
 	__uint64_t	tmp;
 	int		lock_flags;
 
<span class="p_chunk">@@ -1833,7 +1834,8 @@</span> <span class="p_context"> xfs_swap_extents(</span>
 		 * pointer.  Otherwise it&#39;s already NULL or
 		 * pointing to the extent.
 		 */
<span class="p_del">-		if (ip-&gt;i_d.di_nextents &lt;= XFS_INLINE_EXTS) {</span>
<span class="p_add">+		nextents = ip-&gt;i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+		if (nextents &lt;= XFS_INLINE_EXTS) {</span>
 			ifp-&gt;if_u1.if_extents =
 				ifp-&gt;if_u2.if_inline_ext;
 		}
<span class="p_chunk">@@ -1852,7 +1854,8 @@</span> <span class="p_context"> xfs_swap_extents(</span>
 		 * pointer.  Otherwise it&#39;s already NULL or
 		 * pointing to the extent.
 		 */
<span class="p_del">-		if (tip-&gt;i_d.di_nextents &lt;= XFS_INLINE_EXTS) {</span>
<span class="p_add">+		nextents = tip-&gt;i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+		if (nextents &lt;= XFS_INLINE_EXTS) {</span>
 			tifp-&gt;if_u1.if_extents =
 				tifp-&gt;if_u2.if_inline_ext;
 		}
<span class="p_header">diff --git a/fs/xfs/xfs_log_recover.c b/fs/xfs/xfs_log_recover.c</span>
<span class="p_header">index 4b973653a0e8..21737d4bab7c 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_log_recover.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_log_recover.c</span>
<span class="p_chunk">@@ -3813,6 +3813,7 @@</span> <span class="p_context"> xlog_recover_clear_agi_bucket(</span>
 	agi-&gt;agi_unlinked[bucket] = cpu_to_be32(NULLAGINO);
 	offset = offsetof(xfs_agi_t, agi_unlinked) +
 		 (sizeof(xfs_agino_t) * bucket);
<span class="p_add">+	xfs_trans_buf_set_type(tp, agibp, XFS_BLFT_AGI_BUF);</span>
 	xfs_trans_log_buf(tp, agibp, offset,
 			  (offset + sizeof(xfs_agino_t) - 1));
 
<span class="p_header">diff --git a/include/linux/can/core.h b/include/linux/can/core.h</span>
<span class="p_header">index a0875001b13c..df08a41d5be5 100644</span>
<span class="p_header">--- a/include/linux/can/core.h</span>
<span class="p_header">+++ b/include/linux/can/core.h</span>
<span class="p_chunk">@@ -45,10 +45,9 @@</span> <span class="p_context"> struct can_proto {</span>
 extern int  can_proto_register(const struct can_proto *cp);
 extern void can_proto_unregister(const struct can_proto *cp);
 
<span class="p_del">-extern int  can_rx_register(struct net_device *dev, canid_t can_id,</span>
<span class="p_del">-			    canid_t mask,</span>
<span class="p_del">-			    void (*func)(struct sk_buff *, void *),</span>
<span class="p_del">-			    void *data, char *ident);</span>
<span class="p_add">+int can_rx_register(struct net_device *dev, canid_t can_id, canid_t mask,</span>
<span class="p_add">+		    void (*func)(struct sk_buff *, void *),</span>
<span class="p_add">+		    void *data, char *ident, struct sock *sk);</span>
 
 extern void can_rx_unregister(struct net_device *dev, canid_t can_id,
 			      canid_t mask,
<span class="p_header">diff --git a/include/linux/cpu.h b/include/linux/cpu.h</span>
<span class="p_header">index 285111f95464..3b73e762b2f5 100644</span>
<span class="p_header">--- a/include/linux/cpu.h</span>
<span class="p_header">+++ b/include/linux/cpu.h</span>
<span class="p_chunk">@@ -122,22 +122,16 @@</span> <span class="p_context"> enum {</span>
 		{ .notifier_call = fn, .priority = pri };	\
 	__register_cpu_notifier(&amp;fn##_nb);			\
 }
<span class="p_del">-#else /* #if defined(CONFIG_HOTPLUG_CPU) || !defined(MODULE) */</span>
<span class="p_del">-#define cpu_notifier(fn, pri)	do { (void)(fn); } while (0)</span>
<span class="p_del">-#define __cpu_notifier(fn, pri)	do { (void)(fn); } while (0)</span>
<span class="p_del">-#endif /* #else #if defined(CONFIG_HOTPLUG_CPU) || !defined(MODULE) */</span>
 
<span class="p_del">-#ifdef CONFIG_HOTPLUG_CPU</span>
 extern int register_cpu_notifier(struct notifier_block *nb);
 extern int __register_cpu_notifier(struct notifier_block *nb);
 extern void unregister_cpu_notifier(struct notifier_block *nb);
 extern void __unregister_cpu_notifier(struct notifier_block *nb);
<span class="p_del">-#else</span>
 
<span class="p_del">-#ifndef MODULE</span>
<span class="p_del">-extern int register_cpu_notifier(struct notifier_block *nb);</span>
<span class="p_del">-extern int __register_cpu_notifier(struct notifier_block *nb);</span>
<span class="p_del">-#else</span>
<span class="p_add">+#else /* #if defined(CONFIG_HOTPLUG_CPU) || !defined(MODULE) */</span>
<span class="p_add">+#define cpu_notifier(fn, pri)	do { (void)(fn); } while (0)</span>
<span class="p_add">+#define __cpu_notifier(fn, pri)	do { (void)(fn); } while (0)</span>
<span class="p_add">+</span>
 static inline int register_cpu_notifier(struct notifier_block *nb)
 {
 	return 0;
<span class="p_chunk">@@ -147,7 +141,6 @@</span> <span class="p_context"> static inline int __register_cpu_notifier(struct notifier_block *nb)</span>
 {
 	return 0;
 }
<span class="p_del">-#endif</span>
 
 static inline void unregister_cpu_notifier(struct notifier_block *nb)
 {
<span class="p_header">diff --git a/include/linux/jump_label_ratelimit.h b/include/linux/jump_label_ratelimit.h</span>
<span class="p_header">index 089f70f83e97..23da3af459fe 100644</span>
<span class="p_header">--- a/include/linux/jump_label_ratelimit.h</span>
<span class="p_header">+++ b/include/linux/jump_label_ratelimit.h</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"> struct static_key_deferred {</span>
 
 #ifdef HAVE_JUMP_LABEL
 extern void static_key_slow_dec_deferred(struct static_key_deferred *key);
<span class="p_add">+extern void static_key_deferred_flush(struct static_key_deferred *key);</span>
 extern void
 jump_label_rate_limit(struct static_key_deferred *key, unsigned long rl);
 
<span class="p_chunk">@@ -26,6 +27,10 @@</span> <span class="p_context"> static inline void static_key_slow_dec_deferred(struct static_key_deferred *key)</span>
 	STATIC_KEY_CHECK_USE();
 	static_key_slow_dec(&amp;key-&gt;key);
 }
<span class="p_add">+static inline void static_key_deferred_flush(struct static_key_deferred *key)</span>
<span class="p_add">+{</span>
<span class="p_add">+	STATIC_KEY_CHECK_USE();</span>
<span class="p_add">+}</span>
 static inline void
 jump_label_rate_limit(struct static_key_deferred *key,
 		unsigned long rl)
<span class="p_header">diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h</span>
<span class="p_header">index b3404718fda1..e5145f8e4004 100644</span>
<span class="p_header">--- a/include/linux/netdevice.h</span>
<span class="p_header">+++ b/include/linux/netdevice.h</span>
<span class="p_chunk">@@ -2016,14 +2016,19 @@</span> <span class="p_context"> static inline int skb_gro_header_hard(struct sk_buff *skb, unsigned int hlen)</span>
 	return NAPI_GRO_CB(skb)-&gt;frag0_len &lt; hlen;
 }
 
<span class="p_add">+static inline void skb_gro_frag0_invalidate(struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	NAPI_GRO_CB(skb)-&gt;frag0 = NULL;</span>
<span class="p_add">+	NAPI_GRO_CB(skb)-&gt;frag0_len = 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void *skb_gro_header_slow(struct sk_buff *skb, unsigned int hlen,
 					unsigned int offset)
 {
 	if (!pskb_may_pull(skb, hlen))
 		return NULL;
 
<span class="p_del">-	NAPI_GRO_CB(skb)-&gt;frag0 = NULL;</span>
<span class="p_del">-	NAPI_GRO_CB(skb)-&gt;frag0_len = 0;</span>
<span class="p_add">+	skb_gro_frag0_invalidate(skb);</span>
 	return skb-&gt;data + offset;
 }
 
<span class="p_header">diff --git a/include/linux/nfs4.h b/include/linux/nfs4.h</span>
<span class="p_header">index a1e3064a8d99..b17c7031d2bb 100644</span>
<span class="p_header">--- a/include/linux/nfs4.h</span>
<span class="p_header">+++ b/include/linux/nfs4.h</span>
<span class="p_chunk">@@ -243,7 +243,7 @@</span> <span class="p_context"> enum nfsstat4 {</span>
 
 static inline bool seqid_mutating_err(u32 err)
 {
<span class="p_del">-	/* rfc 3530 section 8.1.5: */</span>
<span class="p_add">+	/* See RFC 7530, section 9.1.7 */</span>
 	switch (err) {
 	case NFS4ERR_STALE_CLIENTID:
 	case NFS4ERR_STALE_STATEID:
<span class="p_chunk">@@ -252,6 +252,7 @@</span> <span class="p_context"> static inline bool seqid_mutating_err(u32 err)</span>
 	case NFS4ERR_BADXDR:
 	case NFS4ERR_RESOURCE:
 	case NFS4ERR_NOFILEHANDLE:
<span class="p_add">+	case NFS4ERR_MOVED:</span>
 		return false;
 	};
 	return true;
<span class="p_header">diff --git a/include/linux/sunrpc/clnt.h b/include/linux/sunrpc/clnt.h</span>
<span class="p_header">index 70736b98c721..c2a0ecf02d27 100644</span>
<span class="p_header">--- a/include/linux/sunrpc/clnt.h</span>
<span class="p_header">+++ b/include/linux/sunrpc/clnt.h</span>
<span class="p_chunk">@@ -175,6 +175,7 @@</span> <span class="p_context"> void		rpc_force_rebind(struct rpc_clnt *);</span>
 size_t		rpc_peeraddr(struct rpc_clnt *, struct sockaddr *, size_t);
 const char	*rpc_peeraddr2str(struct rpc_clnt *, enum rpc_display_format_t);
 int		rpc_localaddr(struct rpc_clnt *, struct sockaddr *, size_t);
<span class="p_add">+void rpc_cleanup_clids(void);</span>
 
 #endif /* __KERNEL__ */
 #endif /* _LINUX_SUNRPC_CLNT_H */
<span class="p_header">diff --git a/include/linux/tcp.h b/include/linux/tcp.h</span>
<span class="p_header">index a0513210798f..d7da0cf3332b 100644</span>
<span class="p_header">--- a/include/linux/tcp.h</span>
<span class="p_header">+++ b/include/linux/tcp.h</span>
<span class="p_chunk">@@ -57,8 +57,13 @@</span> <span class="p_context"> static inline unsigned int tcp_optlen(const struct sk_buff *skb)</span>
 
 /* TCP Fast Open Cookie as stored in memory */
 struct tcp_fastopen_cookie {
<span class="p_add">+	union {</span>
<span class="p_add">+		u8	val[TCP_FASTOPEN_COOKIE_MAX];</span>
<span class="p_add">+#if IS_ENABLED(CONFIG_IPV6)</span>
<span class="p_add">+		struct in6_addr addr;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	};</span>
 	s8	len;
<span class="p_del">-	u8	val[TCP_FASTOPEN_COOKIE_MAX];</span>
 };
 
 /* This defines a selective acknowledgement block. */
<span class="p_header">diff --git a/include/net/cfg80211.h b/include/net/cfg80211.h</span>
<span class="p_header">index e46c437944f7..024ab92822fd 100644</span>
<span class="p_header">--- a/include/net/cfg80211.h</span>
<span class="p_header">+++ b/include/net/cfg80211.h</span>
<span class="p_chunk">@@ -3942,6 +3942,17 @@</span> <span class="p_context"> void cfg80211_rx_assoc_resp(struct net_device *dev,</span>
 void cfg80211_assoc_timeout(struct net_device *dev, struct cfg80211_bss *bss);
 
 /**
<span class="p_add">+ * cfg80211_abandon_assoc - notify cfg80211 of abandoned association attempt</span>
<span class="p_add">+ * @dev: network device</span>
<span class="p_add">+ * @bss: The BSS entry with which association was abandoned.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Call this whenever - for reasons reported through other API, like deauth RX,</span>
<span class="p_add">+ * an association attempt was abandoned.</span>
<span class="p_add">+ * This function may sleep. The caller must hold the corresponding wdev&#39;s mutex.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void cfg80211_abandon_assoc(struct net_device *dev, struct cfg80211_bss *bss);</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * cfg80211_tx_mlme_mgmt - notification of transmitted deauth/disassoc frame
  * @dev: network device
  * @buf: 802.11 frame (header + body)
<span class="p_header">diff --git a/include/net/cipso_ipv4.h b/include/net/cipso_ipv4.h</span>
<span class="p_header">index a6fd939f202d..c8b8852ce9b8 100644</span>
<span class="p_header">--- a/include/net/cipso_ipv4.h</span>
<span class="p_header">+++ b/include/net/cipso_ipv4.h</span>
<span class="p_chunk">@@ -302,6 +302,10 @@</span> <span class="p_context"> static inline int cipso_v4_validate(const struct sk_buff *skb,</span>
 	}
 
 	for (opt_iter = 6; opt_iter &lt; opt_len;) {
<span class="p_add">+		if (opt_iter + 1 == opt_len) {</span>
<span class="p_add">+			err_offset = opt_iter;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
 		tag_len = opt[opt_iter + 1];
 		if ((tag_len == 0) || (tag_len &gt; (opt_len - opt_iter))) {
 			err_offset = opt_iter + 1;
<span class="p_header">diff --git a/include/net/netfilter/nf_log.h b/include/net/netfilter/nf_log.h</span>
<span class="p_header">index 99eac12d040b..6e11c346137d 100644</span>
<span class="p_header">--- a/include/net/netfilter/nf_log.h</span>
<span class="p_header">+++ b/include/net/netfilter/nf_log.h</span>
<span class="p_chunk">@@ -12,6 +12,8 @@</span> <span class="p_context"></span>
 #define NF_LOG_UID		0x08	/* Log UID owning local socket */
 #define NF_LOG_MASK		0x0f
 
<span class="p_add">+#define NF_LOG_PREFIXLEN	128</span>
<span class="p_add">+</span>
 #define NF_LOG_TYPE_LOG		0x01
 #define NF_LOG_TYPE_ULOG	0x02
 
<span class="p_header">diff --git a/include/net/sock.h b/include/net/sock.h</span>
<span class="p_header">index 07ede95596bb..ae9dc6ce5712 100644</span>
<span class="p_header">--- a/include/net/sock.h</span>
<span class="p_header">+++ b/include/net/sock.h</span>
<span class="p_chunk">@@ -1411,7 +1411,7 @@</span> <span class="p_context"> static inline struct inode *SOCK_INODE(struct socket *socket)</span>
  * Functions for memory accounting
  */
 int __sk_mem_schedule(struct sock *sk, int size, int kind);
<span class="p_del">-void __sk_mem_reclaim(struct sock *sk);</span>
<span class="p_add">+void __sk_mem_reclaim(struct sock *sk, int amount);</span>
 
 #define SK_MEM_QUANTUM ((int)PAGE_SIZE)
 #define SK_MEM_QUANTUM_SHIFT ilog2(SK_MEM_QUANTUM)
<span class="p_chunk">@@ -1452,7 +1452,7 @@</span> <span class="p_context"> static inline void sk_mem_reclaim(struct sock *sk)</span>
 	if (!sk_has_account(sk))
 		return;
 	if (sk-&gt;sk_forward_alloc &gt;= SK_MEM_QUANTUM)
<span class="p_del">-		__sk_mem_reclaim(sk);</span>
<span class="p_add">+		__sk_mem_reclaim(sk, sk-&gt;sk_forward_alloc);</span>
 }
 
 static inline void sk_mem_reclaim_partial(struct sock *sk)
<span class="p_chunk">@@ -1460,7 +1460,7 @@</span> <span class="p_context"> static inline void sk_mem_reclaim_partial(struct sock *sk)</span>
 	if (!sk_has_account(sk))
 		return;
 	if (sk-&gt;sk_forward_alloc &gt; SK_MEM_QUANTUM)
<span class="p_del">-		__sk_mem_reclaim(sk);</span>
<span class="p_add">+		__sk_mem_reclaim(sk, sk-&gt;sk_forward_alloc - 1);</span>
 }
 
 static inline void sk_mem_charge(struct sock *sk, int size)
<span class="p_chunk">@@ -1475,6 +1475,16 @@</span> <span class="p_context"> static inline void sk_mem_uncharge(struct sock *sk, int size)</span>
 	if (!sk_has_account(sk))
 		return;
 	sk-&gt;sk_forward_alloc += size;
<span class="p_add">+</span>
<span class="p_add">+	/* Avoid a possible overflow.</span>
<span class="p_add">+	 * TCP send queues can make this happen, if sk_mem_reclaim()</span>
<span class="p_add">+	 * is not called and more than 2 GBytes are released at once.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * If we reach 2 MBytes, reclaim 1 MBytes right now, there is</span>
<span class="p_add">+	 * no need to hold that much forward allocation anyway.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(sk-&gt;sk_forward_alloc &gt;= 1 &lt;&lt; 21))</span>
<span class="p_add">+		__sk_mem_reclaim(sk, 1 &lt;&lt; 20);</span>
 }
 
 static inline void sk_wmem_free_skb(struct sock *sk, struct sk_buff *skb)
<span class="p_chunk">@@ -1569,6 +1579,7 @@</span> <span class="p_context"> struct sk_buff *sock_wmalloc(struct sock *sk, unsigned long size, int force,</span>
 void sock_wfree(struct sk_buff *skb);
 void skb_orphan_partial(struct sk_buff *skb);
 void sock_rfree(struct sk_buff *skb);
<span class="p_add">+void sock_efree(struct sk_buff *skb);</span>
 void sock_edemux(struct sk_buff *skb);
 
 int sock_setsockopt(struct socket *sock, int level, int op,
<span class="p_header">diff --git a/include/uapi/linux/usb/ch9.h b/include/uapi/linux/usb/ch9.h</span>
<span class="p_header">index aa33fd1b2d4f..a81f5473a801 100644</span>
<span class="p_header">--- a/include/uapi/linux/usb/ch9.h</span>
<span class="p_header">+++ b/include/uapi/linux/usb/ch9.h</span>
<span class="p_chunk">@@ -398,6 +398,11 @@</span> <span class="p_context"> struct usb_endpoint_descriptor {</span>
 #define USB_ENDPOINT_XFER_INT		3
 #define USB_ENDPOINT_MAX_ADJUSTABLE	0x80
 
<span class="p_add">+#define USB_EP_MAXP_MULT_SHIFT	11</span>
<span class="p_add">+#define USB_EP_MAXP_MULT_MASK	(3 &lt;&lt; USB_EP_MAXP_MULT_SHIFT)</span>
<span class="p_add">+#define USB_EP_MAXP_MULT(m) \</span>
<span class="p_add">+	(((m) &amp; USB_EP_MAXP_MULT_MASK) &gt;&gt; USB_EP_MAXP_MULT_SHIFT)</span>
<span class="p_add">+</span>
 /* The USB 3.0 spec redefines bits 5:4 of bmAttributes as interrupt ep type. */
 #define USB_ENDPOINT_INTRTYPE		0x30
 #define USB_ENDPOINT_INTR_PERIODIC	(0 &lt;&lt; 4)
<span class="p_chunk">@@ -605,6 +610,20 @@</span> <span class="p_context"> static inline int usb_endpoint_maxp(const struct usb_endpoint_descriptor *epd)</span>
 	return __le16_to_cpu(epd-&gt;wMaxPacketSize);
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * usb_endpoint_maxp_mult - get endpoint&#39;s transactional opportunities</span>
<span class="p_add">+ * @epd: endpoint to be checked</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return @epd&#39;s wMaxPacketSize[12:11] + 1</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline int</span>
<span class="p_add">+usb_endpoint_maxp_mult(const struct usb_endpoint_descriptor *epd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int maxp = __le16_to_cpu(epd-&gt;wMaxPacketSize);</span>
<span class="p_add">+</span>
<span class="p_add">+	return USB_EP_MAXP_MULT(maxp) + 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline int usb_endpoint_interrupt_type(
 		const struct usb_endpoint_descriptor *epd)
 {
<span class="p_header">diff --git a/ipc/shm.c b/ipc/shm.c</span>
<span class="p_header">index 471f730e8640..f8bb7b3fdd49 100644</span>
<span class="p_header">--- a/ipc/shm.c</span>
<span class="p_header">+++ b/ipc/shm.c</span>
<span class="p_chunk">@@ -1044,8 +1044,8 @@</span> <span class="p_context"> out_unlock1:</span>
  * &quot;raddr&quot; thing points to kernel space, and there has to be a wrapper around
  * this.
  */
<span class="p_del">-long do_shmat(int shmid, char __user *shmaddr, int shmflg, ulong *raddr,</span>
<span class="p_del">-	      unsigned long shmlba)</span>
<span class="p_add">+long do_shmat(int shmid, char __user *shmaddr, int shmflg,</span>
<span class="p_add">+	      ulong *raddr, unsigned long shmlba)</span>
 {
 	struct shmid_kernel *shp;
 	unsigned long addr;
<span class="p_chunk">@@ -1066,8 +1066,13 @@</span> <span class="p_context"> long do_shmat(int shmid, char __user *shmaddr, int shmflg, ulong *raddr,</span>
 		goto out;
 	else if ((addr = (ulong)shmaddr)) {
 		if (addr &amp; (shmlba - 1)) {
<span class="p_del">-			if (shmflg &amp; SHM_RND)</span>
<span class="p_del">-				addr &amp;= ~(shmlba - 1);	   /* round down */</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Round down to the nearest multiple of shmlba.</span>
<span class="p_add">+			 * For sane do_mmap_pgoff() parameters, avoid</span>
<span class="p_add">+			 * round downs that trigger nil-page and MAP_FIXED.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if ((shmflg &amp; SHM_RND) &amp;&amp; addr &gt;= shmlba)</span>
<span class="p_add">+				addr &amp;= ~(shmlba - 1);</span>
 			else
 #ifndef __ARCH_FORCE_SHMLBA
 				if (addr &amp; ~PAGE_MASK)
<span class="p_header">diff --git a/kernel/cpu.c b/kernel/cpu.c</span>
<span class="p_header">index 247d8dd17a2c..e160b9b065e6 100644</span>
<span class="p_header">--- a/kernel/cpu.c</span>
<span class="p_header">+++ b/kernel/cpu.c</span>
<span class="p_chunk">@@ -210,12 +210,6 @@</span> <span class="p_context"> static int cpu_notify(unsigned long val, void *v)</span>
 	return __cpu_notify(val, v, -1, NULL);
 }
 
<span class="p_del">-#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="p_del">-</span>
<span class="p_del">-static void cpu_notify_nofail(unsigned long val, void *v)</span>
<span class="p_del">-{</span>
<span class="p_del">-	BUG_ON(cpu_notify(val, v));</span>
<span class="p_del">-}</span>
 EXPORT_SYMBOL(register_cpu_notifier);
 EXPORT_SYMBOL(__register_cpu_notifier);
 
<span class="p_chunk">@@ -233,6 +227,13 @@</span> <span class="p_context"> void __ref __unregister_cpu_notifier(struct notifier_block *nb)</span>
 }
 EXPORT_SYMBOL(__unregister_cpu_notifier);
 
<span class="p_add">+#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="p_add">+</span>
<span class="p_add">+static void cpu_notify_nofail(unsigned long val, void *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(cpu_notify(val, v));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * clear_tasks_mm_cpumask - Safely clear tasks&#39; mm_cpumask for a CPU
  * @cpu: a CPU id
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index 7413ddd1de57..2faaed3ba61b 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -5472,6 +5472,27 @@</span> <span class="p_context"> static void perf_event_mmap_event(struct perf_mmap_event *mmap_event)</span>
 	char *buf = NULL;
 	char *name;
 
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_READ)</span>
<span class="p_add">+		prot |= PROT_READ;</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_WRITE)</span>
<span class="p_add">+		prot |= PROT_WRITE;</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_EXEC)</span>
<span class="p_add">+		prot |= PROT_EXEC;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_MAYSHARE)</span>
<span class="p_add">+		flags = MAP_SHARED;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		flags = MAP_PRIVATE;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_DENYWRITE)</span>
<span class="p_add">+		flags |= MAP_DENYWRITE;</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_MAYEXEC)</span>
<span class="p_add">+		flags |= MAP_EXECUTABLE;</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_LOCKED)</span>
<span class="p_add">+		flags |= MAP_LOCKED;</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_HUGETLB)</span>
<span class="p_add">+		flags |= MAP_HUGETLB;</span>
<span class="p_add">+</span>
 	if (file) {
 		struct inode *inode;
 		dev_t dev;
<span class="p_chunk">@@ -5498,27 +5519,6 @@</span> <span class="p_context"> static void perf_event_mmap_event(struct perf_mmap_event *mmap_event)</span>
 		maj = MAJOR(dev);
 		min = MINOR(dev);
 
<span class="p_del">-		if (vma-&gt;vm_flags &amp; VM_READ)</span>
<span class="p_del">-			prot |= PROT_READ;</span>
<span class="p_del">-		if (vma-&gt;vm_flags &amp; VM_WRITE)</span>
<span class="p_del">-			prot |= PROT_WRITE;</span>
<span class="p_del">-		if (vma-&gt;vm_flags &amp; VM_EXEC)</span>
<span class="p_del">-			prot |= PROT_EXEC;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (vma-&gt;vm_flags &amp; VM_MAYSHARE)</span>
<span class="p_del">-			flags = MAP_SHARED;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			flags = MAP_PRIVATE;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (vma-&gt;vm_flags &amp; VM_DENYWRITE)</span>
<span class="p_del">-			flags |= MAP_DENYWRITE;</span>
<span class="p_del">-		if (vma-&gt;vm_flags &amp; VM_MAYEXEC)</span>
<span class="p_del">-			flags |= MAP_EXECUTABLE;</span>
<span class="p_del">-		if (vma-&gt;vm_flags &amp; VM_LOCKED)</span>
<span class="p_del">-			flags |= MAP_LOCKED;</span>
<span class="p_del">-		if (vma-&gt;vm_flags &amp; VM_HUGETLB)</span>
<span class="p_del">-			flags |= MAP_HUGETLB;</span>
<span class="p_del">-</span>
 		goto got_name;
 	} else {
 		name = (char *)arch_vma_name(vma);
<span class="p_header">diff --git a/kernel/futex.c b/kernel/futex.c</span>
<span class="p_header">index af67d3eaf232..1d1ccb0e87a7 100644</span>
<span class="p_header">--- a/kernel/futex.c</span>
<span class="p_header">+++ b/kernel/futex.c</span>
<span class="p_chunk">@@ -3085,4 +3085,4 @@</span> <span class="p_context"> static int __init futex_init(void)</span>
 
 	return 0;
 }
<span class="p_del">-__initcall(futex_init);</span>
<span class="p_add">+core_initcall(futex_init);</span>
<span class="p_header">diff --git a/kernel/jump_label.c b/kernel/jump_label.c</span>
<span class="p_header">index 9019f15deab2..7d4d0a917d13 100644</span>
<span class="p_header">--- a/kernel/jump_label.c</span>
<span class="p_header">+++ b/kernel/jump_label.c</span>
<span class="p_chunk">@@ -116,6 +116,13 @@</span> <span class="p_context"> void static_key_slow_dec_deferred(struct static_key_deferred *key)</span>
 }
 EXPORT_SYMBOL_GPL(static_key_slow_dec_deferred);
 
<span class="p_add">+void static_key_deferred_flush(struct static_key_deferred *key)</span>
<span class="p_add">+{</span>
<span class="p_add">+	STATIC_KEY_CHECK_USE();</span>
<span class="p_add">+	flush_delayed_work(&amp;key-&gt;work);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(static_key_deferred_flush);</span>
<span class="p_add">+</span>
 void jump_label_rate_limit(struct static_key_deferred *key,
 		unsigned long rl)
 {
<span class="p_header">diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c</span>
<span class="p_header">index 627bf25048c6..e4c6905db298 100644</span>
<span class="p_header">--- a/kernel/printk/printk.c</span>
<span class="p_header">+++ b/kernel/printk/printk.c</span>
<span class="p_chunk">@@ -1356,7 +1356,7 @@</span> <span class="p_context"> static void call_console_drivers(int level, const char *text, size_t len)</span>
 {
 	struct console *con;
 
<span class="p_del">-	trace_console(text, len);</span>
<span class="p_add">+	trace_console_rcuidle(text, len);</span>
 
 	if (level &gt;= console_loglevel &amp;&amp; !ignore_loglevel)
 		return;
<span class="p_header">diff --git a/kernel/sched/cputime.c b/kernel/sched/cputime.c</span>
<span class="p_header">index 349ada9a7fa5..ed0d9b8b666a 100644</span>
<span class="p_header">--- a/kernel/sched/cputime.c</span>
<span class="p_header">+++ b/kernel/sched/cputime.c</span>
<span class="p_chunk">@@ -753,6 +753,9 @@</span> <span class="p_context"> cputime_t task_gtime(struct task_struct *t)</span>
 	unsigned int seq;
 	cputime_t gtime;
 
<span class="p_add">+	if (!context_tracking_is_enabled())</span>
<span class="p_add">+		return t-&gt;gtime;</span>
<span class="p_add">+</span>
 	do {
 		seq = read_seqbegin(&amp;t-&gt;vtime_seqlock);
 
<span class="p_header">diff --git a/kernel/sysctl.c b/kernel/sysctl.c</span>
<span class="p_header">index f9293694b52a..3a3172559b22 100644</span>
<span class="p_header">--- a/kernel/sysctl.c</span>
<span class="p_header">+++ b/kernel/sysctl.c</span>
<span class="p_chunk">@@ -2317,6 +2317,7 @@</span> <span class="p_context"> static int __do_proc_doulongvec_minmax(void *data, struct ctl_table *table, int</span>
 				break;
 			if (neg)
 				continue;
<span class="p_add">+			val = convmul * val / convdiv;</span>
 			if ((min &amp;&amp; val &lt; *min) || (max &amp;&amp; val &gt; *max))
 				continue;
 			*i = val;
<span class="p_header">diff --git a/kernel/trace/trace_functions_graph.c b/kernel/trace/trace_functions_graph.c</span>
<span class="p_header">index 4de3e57f723c..319cf14c92d3 100644</span>
<span class="p_header">--- a/kernel/trace/trace_functions_graph.c</span>
<span class="p_header">+++ b/kernel/trace/trace_functions_graph.c</span>
<span class="p_chunk">@@ -841,6 +841,10 @@</span> <span class="p_context"> print_graph_entry_leaf(struct trace_iterator *iter,</span>
 
 		cpu_data = per_cpu_ptr(data-&gt;cpu_data, cpu);
 
<span class="p_add">+		/* If a graph tracer ignored set_graph_notrace */</span>
<span class="p_add">+		if (call-&gt;depth &lt; -1)</span>
<span class="p_add">+			call-&gt;depth += FTRACE_NOTRACE_DEPTH;</span>
<span class="p_add">+</span>
 		/*
 		 * Comments display at + 1 to depth. Since
 		 * this is a leaf function, keep the comments
<span class="p_chunk">@@ -849,7 +853,8 @@</span> <span class="p_context"> print_graph_entry_leaf(struct trace_iterator *iter,</span>
 		cpu_data-&gt;depth = call-&gt;depth - 1;
 
 		/* No need to keep this function around for this depth */
<span class="p_del">-		if (call-&gt;depth &lt; FTRACE_RETFUNC_DEPTH)</span>
<span class="p_add">+		if (call-&gt;depth &lt; FTRACE_RETFUNC_DEPTH &amp;&amp;</span>
<span class="p_add">+		    !WARN_ON_ONCE(call-&gt;depth &lt; 0))</span>
 			cpu_data-&gt;enter_funcs[call-&gt;depth] = 0;
 	}
 
<span class="p_chunk">@@ -886,11 +891,16 @@</span> <span class="p_context"> print_graph_entry_nested(struct trace_iterator *iter,</span>
 		struct fgraph_cpu_data *cpu_data;
 		int cpu = iter-&gt;cpu;
 
<span class="p_add">+		/* If a graph tracer ignored set_graph_notrace */</span>
<span class="p_add">+		if (call-&gt;depth &lt; -1)</span>
<span class="p_add">+			call-&gt;depth += FTRACE_NOTRACE_DEPTH;</span>
<span class="p_add">+</span>
 		cpu_data = per_cpu_ptr(data-&gt;cpu_data, cpu);
 		cpu_data-&gt;depth = call-&gt;depth;
 
 		/* Save this function pointer to see if the exit matches */
<span class="p_del">-		if (call-&gt;depth &lt; FTRACE_RETFUNC_DEPTH)</span>
<span class="p_add">+		if (call-&gt;depth &lt; FTRACE_RETFUNC_DEPTH &amp;&amp;</span>
<span class="p_add">+		    !WARN_ON_ONCE(call-&gt;depth &lt; 0))</span>
 			cpu_data-&gt;enter_funcs[call-&gt;depth] = call-&gt;func;
 	}
 
<span class="p_chunk">@@ -1143,7 +1153,8 @@</span> <span class="p_context"> print_graph_return(struct ftrace_graph_ret *trace, struct trace_seq *s,</span>
 		 */
 		cpu_data-&gt;depth = trace-&gt;depth - 1;
 
<span class="p_del">-		if (trace-&gt;depth &lt; FTRACE_RETFUNC_DEPTH) {</span>
<span class="p_add">+		if (trace-&gt;depth &lt; FTRACE_RETFUNC_DEPTH &amp;&amp;</span>
<span class="p_add">+		    !WARN_ON_ONCE(trace-&gt;depth &lt; 0)) {</span>
 			if (cpu_data-&gt;enter_funcs[trace-&gt;depth] != trace-&gt;func)
 				func_match = 0;
 			cpu_data-&gt;enter_funcs[trace-&gt;depth] = 0;
<span class="p_header">diff --git a/lib/vsprintf.c b/lib/vsprintf.c</span>
<span class="p_header">index 6fe2c84eb055..ce12a88a8fd1 100644</span>
<span class="p_header">--- a/lib/vsprintf.c</span>
<span class="p_header">+++ b/lib/vsprintf.c</span>
<span class="p_chunk">@@ -1657,7 +1657,7 @@</span> <span class="p_context"> int vsnprintf(char *buf, size_t size, const char *fmt, va_list args)</span>
 
 	/* Reject out-of-range values early.  Large positive sizes are
 	   used for unknown buffer sizes. */
<span class="p_del">-	if (WARN_ON_ONCE((int) size &lt; 0))</span>
<span class="p_add">+	if (WARN_ON_ONCE(size &gt; INT_MAX))</span>
 		return 0;
 
 	str = buf;
<span class="p_header">diff --git a/mm/filemap.c b/mm/filemap.c</span>
<span class="p_header">index a5024d71fcc3..31b5b25c3d2d 100644</span>
<span class="p_header">--- a/mm/filemap.c</span>
<span class="p_header">+++ b/mm/filemap.c</span>
<span class="p_chunk">@@ -1482,6 +1482,11 @@</span> <span class="p_context"> static ssize_t do_generic_file_read(struct file *filp, loff_t *ppos,</span>
 
 		cond_resched();
 find_page:
<span class="p_add">+		if (fatal_signal_pending(current)) {</span>
<span class="p_add">+			error = -EINTR;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		page = find_get_page(mapping, index);
 		if (!page) {
 			page_cache_sync_readahead(mapping,
<span class="p_header">diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="p_header">index dc528a51ccbf..abc04a803aa8 100644</span>
<span class="p_header">--- a/mm/huge_memory.c</span>
<span class="p_header">+++ b/mm/huge_memory.c</span>
<span class="p_chunk">@@ -1192,6 +1192,18 @@</span> <span class="p_context"> out_unlock:</span>
 	return ret;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * FOLL_FORCE can write to even unwritable pmd&#39;s, but only</span>
<span class="p_add">+ * after we&#39;ve gone through a COW cycle and they are dirty.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline bool can_follow_write_pmd(pmd_t pmd, struct page *page,</span>
<span class="p_add">+					unsigned int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return pmd_write(pmd) ||</span>
<span class="p_add">+		((flags &amp; FOLL_FORCE) &amp;&amp; (flags &amp; FOLL_COW) &amp;&amp;</span>
<span class="p_add">+		 page &amp;&amp; PageAnon(page));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct page *follow_trans_huge_pmd(struct vm_area_struct *vma,
 				   unsigned long addr,
 				   pmd_t *pmd,
<span class="p_chunk">@@ -1202,9 +1214,6 @@</span> <span class="p_context"> struct page *follow_trans_huge_pmd(struct vm_area_struct *vma,</span>
 
 	assert_spin_locked(pmd_lockptr(mm, pmd));
 
<span class="p_del">-	if (flags &amp; FOLL_WRITE &amp;&amp; !pmd_write(*pmd))</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
 	/* Avoid dumping huge zero page */
 	if ((flags &amp; FOLL_DUMP) &amp;&amp; is_huge_zero_pmd(*pmd))
 		return ERR_PTR(-EFAULT);
<span class="p_chunk">@@ -1215,6 +1224,10 @@</span> <span class="p_context"> struct page *follow_trans_huge_pmd(struct vm_area_struct *vma,</span>
 
 	page = pmd_page(*pmd);
 	VM_BUG_ON_PAGE(!PageHead(page), page);
<span class="p_add">+</span>
<span class="p_add">+	if (flags &amp; FOLL_WRITE &amp;&amp; !can_follow_write_pmd(*pmd, page, flags))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	if (flags &amp; FOLL_TOUCH) {
 		pmd_t _pmd;
 		/*
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index fca6c6c91d76..467d04b62948 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -1301,23 +1301,32 @@</span> <span class="p_context"> free:</span>
 }
 
 /*
<span class="p_del">- * When releasing a hugetlb pool reservation, any surplus pages that were</span>
<span class="p_del">- * allocated to satisfy the reservation must be explicitly freed if they were</span>
<span class="p_del">- * never used.</span>
<span class="p_del">- * Called with hugetlb_lock held.</span>
<span class="p_add">+ * This routine has two main purposes:</span>
<span class="p_add">+ * 1) Decrement the reservation count (resv_huge_pages) by the value passed</span>
<span class="p_add">+ *    in unused_resv_pages.  This corresponds to the prior adjustments made</span>
<span class="p_add">+ *    to the associated reservation map.</span>
<span class="p_add">+ * 2) Free any unused surplus pages that may have been allocated to satisfy</span>
<span class="p_add">+ *    the reservation.  As many as unused_resv_pages may be freed.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Called with hugetlb_lock held.  However, the lock could be dropped (and</span>
<span class="p_add">+ * reacquired) during calls to cond_resched_lock.  Whenever dropping the lock,</span>
<span class="p_add">+ * we must make sure nobody else can claim pages we are in the process of</span>
<span class="p_add">+ * freeing.  Do this by ensuring resv_huge_page always is greater than the</span>
<span class="p_add">+ * number of huge pages we plan to free when dropping the lock.</span>
  */
 static void return_unused_surplus_pages(struct hstate *h,
 					unsigned long unused_resv_pages)
 {
 	unsigned long nr_pages;
 
<span class="p_del">-	/* Uncommit the reservation */</span>
<span class="p_del">-	h-&gt;resv_huge_pages -= unused_resv_pages;</span>
<span class="p_del">-</span>
 	/* Cannot return gigantic pages currently */
 	if (hstate_is_gigantic(h))
<span class="p_del">-		return;</span>
<span class="p_add">+		goto out;</span>
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Part (or even all) of the reservation could have been backed</span>
<span class="p_add">+	 * by pre-allocated pages. Only free surplus pages.</span>
<span class="p_add">+	 */</span>
 	nr_pages = min(unused_resv_pages, h-&gt;surplus_huge_pages);
 
 	/*
<span class="p_chunk">@@ -1327,12 +1336,22 @@</span> <span class="p_context"> static void return_unused_surplus_pages(struct hstate *h,</span>
 	 * when the nodes with surplus pages have no free pages.
 	 * free_pool_huge_page() will balance the the freed pages across the
 	 * on-line nodes with memory and will handle the hstate accounting.
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note that we decrement resv_huge_pages as we free the pages.  If</span>
<span class="p_add">+	 * we drop the lock, resv_huge_pages will still be sufficiently large</span>
<span class="p_add">+	 * to cover subsequent pages we may free.</span>
 	 */
 	while (nr_pages--) {
<span class="p_add">+		h-&gt;resv_huge_pages--;</span>
<span class="p_add">+		unused_resv_pages--;</span>
 		if (!free_pool_huge_page(h, &amp;node_states[N_MEMORY], 1))
<span class="p_del">-			break;</span>
<span class="p_add">+			goto out;</span>
 		cond_resched_lock(&amp;hugetlb_lock);
 	}
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	/* Fully uncommit the reservation */</span>
<span class="p_add">+	h-&gt;resv_huge_pages -= unused_resv_pages;</span>
 }
 
 /*
<span class="p_header">diff --git a/net/bridge/br_ioctl.c b/net/bridge/br_ioctl.c</span>
<span class="p_header">index 8d423bc649b9..f876f707fd9e 100644</span>
<span class="p_header">--- a/net/bridge/br_ioctl.c</span>
<span class="p_header">+++ b/net/bridge/br_ioctl.c</span>
<span class="p_chunk">@@ -21,18 +21,19 @@</span> <span class="p_context"></span>
 #include &lt;asm/uaccess.h&gt;
 #include &quot;br_private.h&quot;
 
<span class="p_del">-/* called with RTNL */</span>
 static int get_bridge_ifindices(struct net *net, int *indices, int num)
 {
 	struct net_device *dev;
 	int i = 0;
 
<span class="p_del">-	for_each_netdev(net, dev) {</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	for_each_netdev_rcu(net, dev) {</span>
 		if (i &gt;= num)
 			break;
 		if (dev-&gt;priv_flags &amp; IFF_EBRIDGE)
 			indices[i++] = dev-&gt;ifindex;
 	}
<span class="p_add">+	rcu_read_unlock();</span>
 
 	return i;
 }
<span class="p_header">diff --git a/net/can/af_can.c b/net/can/af_can.c</span>
<span class="p_header">index d6030d6949df..ee6eee7a8b42 100644</span>
<span class="p_header">--- a/net/can/af_can.c</span>
<span class="p_header">+++ b/net/can/af_can.c</span>
<span class="p_chunk">@@ -446,6 +446,7 @@</span> <span class="p_context"> static struct hlist_head *find_rcv_list(canid_t *can_id, canid_t *mask,</span>
  * @func: callback function on filter match
  * @data: returned parameter for callback function
  * @ident: string for calling module identification
<span class="p_add">+ * @sk: socket pointer (might be NULL)</span>
  *
  * Description:
  *  Invokes the callback function with the received sk_buff and the given
<span class="p_chunk">@@ -469,7 +470,7 @@</span> <span class="p_context"> static struct hlist_head *find_rcv_list(canid_t *can_id, canid_t *mask,</span>
  */
 int can_rx_register(struct net_device *dev, canid_t can_id, canid_t mask,
 		    void (*func)(struct sk_buff *, void *), void *data,
<span class="p_del">-		    char *ident)</span>
<span class="p_add">+		    char *ident, struct sock *sk)</span>
 {
 	struct receiver *r;
 	struct hlist_head *rl;
<span class="p_chunk">@@ -497,6 +498,7 @@</span> <span class="p_context"> int can_rx_register(struct net_device *dev, canid_t can_id, canid_t mask,</span>
 		r-&gt;func    = func;
 		r-&gt;data    = data;
 		r-&gt;ident   = ident;
<span class="p_add">+		r-&gt;sk      = sk;</span>
 
 		hlist_add_head_rcu(&amp;r-&gt;list, rl);
 		d-&gt;entries++;
<span class="p_chunk">@@ -521,8 +523,11 @@</span> <span class="p_context"> EXPORT_SYMBOL(can_rx_register);</span>
 static void can_rx_delete_receiver(struct rcu_head *rp)
 {
 	struct receiver *r = container_of(rp, struct receiver, rcu);
<span class="p_add">+	struct sock *sk = r-&gt;sk;</span>
 
 	kmem_cache_free(rcv_cache, r);
<span class="p_add">+	if (sk)</span>
<span class="p_add">+		sock_put(sk);</span>
 }
 
 /**
<span class="p_chunk">@@ -597,8 +602,11 @@</span> <span class="p_context"> void can_rx_unregister(struct net_device *dev, canid_t can_id, canid_t mask,</span>
 	spin_unlock(&amp;can_rcvlists_lock);
 
 	/* schedule the receiver item for deletion */
<span class="p_del">-	if (r)</span>
<span class="p_add">+	if (r) {</span>
<span class="p_add">+		if (r-&gt;sk)</span>
<span class="p_add">+			sock_hold(r-&gt;sk);</span>
 		call_rcu(&amp;r-&gt;rcu, can_rx_delete_receiver);
<span class="p_add">+	}</span>
 }
 EXPORT_SYMBOL(can_rx_unregister);
 
<span class="p_header">diff --git a/net/can/af_can.h b/net/can/af_can.h</span>
<span class="p_header">index fca0fe9fc45a..b86f5129e838 100644</span>
<span class="p_header">--- a/net/can/af_can.h</span>
<span class="p_header">+++ b/net/can/af_can.h</span>
<span class="p_chunk">@@ -50,13 +50,14 @@</span> <span class="p_context"></span>
 
 struct receiver {
 	struct hlist_node list;
<span class="p_del">-	struct rcu_head rcu;</span>
 	canid_t can_id;
 	canid_t mask;
 	unsigned long matches;
 	void (*func)(struct sk_buff *, void *);
 	void *data;
 	char *ident;
<span class="p_add">+	struct sock *sk;</span>
<span class="p_add">+	struct rcu_head rcu;</span>
 };
 
 #define CAN_SFF_RCV_ARRAY_SZ (1 &lt;&lt; CAN_SFF_ID_BITS)
<span class="p_header">diff --git a/net/can/bcm.c b/net/can/bcm.c</span>
<span class="p_header">index b96434d09177..468dfa12eebe 100644</span>
<span class="p_header">--- a/net/can/bcm.c</span>
<span class="p_header">+++ b/net/can/bcm.c</span>
<span class="p_chunk">@@ -706,14 +706,23 @@</span> <span class="p_context"> static struct bcm_op *bcm_find_op(struct list_head *ops, canid_t can_id,</span>
 
 static void bcm_remove_op(struct bcm_op *op)
 {
<span class="p_del">-	hrtimer_cancel(&amp;op-&gt;timer);</span>
<span class="p_del">-	hrtimer_cancel(&amp;op-&gt;thrtimer);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (op-&gt;tsklet.func)</span>
<span class="p_del">-		tasklet_kill(&amp;op-&gt;tsklet);</span>
<span class="p_add">+	if (op-&gt;tsklet.func) {</span>
<span class="p_add">+		while (test_bit(TASKLET_STATE_SCHED, &amp;op-&gt;tsklet.state) ||</span>
<span class="p_add">+		       test_bit(TASKLET_STATE_RUN, &amp;op-&gt;tsklet.state) ||</span>
<span class="p_add">+		       hrtimer_active(&amp;op-&gt;timer)) {</span>
<span class="p_add">+			hrtimer_cancel(&amp;op-&gt;timer);</span>
<span class="p_add">+			tasklet_kill(&amp;op-&gt;tsklet);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	if (op-&gt;thrtsklet.func)</span>
<span class="p_del">-		tasklet_kill(&amp;op-&gt;thrtsklet);</span>
<span class="p_add">+	if (op-&gt;thrtsklet.func) {</span>
<span class="p_add">+		while (test_bit(TASKLET_STATE_SCHED, &amp;op-&gt;thrtsklet.state) ||</span>
<span class="p_add">+		       test_bit(TASKLET_STATE_RUN, &amp;op-&gt;thrtsklet.state) ||</span>
<span class="p_add">+		       hrtimer_active(&amp;op-&gt;thrtimer)) {</span>
<span class="p_add">+			hrtimer_cancel(&amp;op-&gt;thrtimer);</span>
<span class="p_add">+			tasklet_kill(&amp;op-&gt;thrtsklet);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
 	if ((op-&gt;frames) &amp;&amp; (op-&gt;frames != &amp;op-&gt;sframe))
 		kfree(op-&gt;frames);
<span class="p_chunk">@@ -1169,7 +1178,7 @@</span> <span class="p_context"> static int bcm_rx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,</span>
 				err = can_rx_register(dev, op-&gt;can_id,
 						      REGMASK(op-&gt;can_id),
 						      bcm_rx_handler, op,
<span class="p_del">-						      &quot;bcm&quot;);</span>
<span class="p_add">+						      &quot;bcm&quot;, sk);</span>
 
 				op-&gt;rx_reg_dev = dev;
 				dev_put(dev);
<span class="p_chunk">@@ -1178,7 +1187,7 @@</span> <span class="p_context"> static int bcm_rx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,</span>
 		} else
 			err = can_rx_register(NULL, op-&gt;can_id,
 					      REGMASK(op-&gt;can_id),
<span class="p_del">-					      bcm_rx_handler, op, &quot;bcm&quot;);</span>
<span class="p_add">+					      bcm_rx_handler, op, &quot;bcm&quot;, sk);</span>
 		if (err) {
 			/* this bcm rx op is broken -&gt; remove it */
 			list_del(&amp;op-&gt;list);
<span class="p_header">diff --git a/net/can/gw.c b/net/can/gw.c</span>
<span class="p_header">index 050a2110d43f..d4921582d3bd 100644</span>
<span class="p_header">--- a/net/can/gw.c</span>
<span class="p_header">+++ b/net/can/gw.c</span>
<span class="p_chunk">@@ -441,7 +441,7 @@</span> <span class="p_context"> static inline int cgw_register_filter(struct cgw_job *gwj)</span>
 {
 	return can_rx_register(gwj-&gt;src.dev, gwj-&gt;ccgw.filter.can_id,
 			       gwj-&gt;ccgw.filter.can_mask, can_can_gw_rcv,
<span class="p_del">-			       gwj, &quot;gw&quot;);</span>
<span class="p_add">+			       gwj, &quot;gw&quot;, NULL);</span>
 }
 
 static inline void cgw_unregister_filter(struct cgw_job *gwj)
<span class="p_header">diff --git a/net/can/raw.c b/net/can/raw.c</span>
<span class="p_header">index 9f5ee3a6b666..59e4cab9cd76 100644</span>
<span class="p_header">--- a/net/can/raw.c</span>
<span class="p_header">+++ b/net/can/raw.c</span>
<span class="p_chunk">@@ -164,7 +164,7 @@</span> <span class="p_context"> static int raw_enable_filters(struct net_device *dev, struct sock *sk,</span>
 	for (i = 0; i &lt; count; i++) {
 		err = can_rx_register(dev, filter[i].can_id,
 				      filter[i].can_mask,
<span class="p_del">-				      raw_rcv, sk, &quot;raw&quot;);</span>
<span class="p_add">+				      raw_rcv, sk, &quot;raw&quot;, sk);</span>
 		if (err) {
 			/* clean up successfully registered filters */
 			while (--i &gt;= 0)
<span class="p_chunk">@@ -185,7 +185,7 @@</span> <span class="p_context"> static int raw_enable_errfilter(struct net_device *dev, struct sock *sk,</span>
 
 	if (err_mask)
 		err = can_rx_register(dev, 0, err_mask | CAN_ERR_FLAG,
<span class="p_del">-				      raw_rcv, sk, &quot;raw&quot;);</span>
<span class="p_add">+				      raw_rcv, sk, &quot;raw&quot;, sk);</span>
 
 	return err;
 }
<span class="p_header">diff --git a/net/ceph/messenger.c b/net/ceph/messenger.c</span>
<span class="p_header">index f2ea1a093800..a1244a228811 100644</span>
<span class="p_header">--- a/net/ceph/messenger.c</span>
<span class="p_header">+++ b/net/ceph/messenger.c</span>
<span class="p_chunk">@@ -1977,6 +1977,19 @@</span> <span class="p_context"> static int process_connect(struct ceph_connection *con)</span>
 
 	dout(&quot;process_connect on %p tag %d\n&quot;, con, (int)con-&gt;in_tag);
 
<span class="p_add">+	if (con-&gt;auth_reply_buf) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Any connection that defines -&gt;get_authorizer()</span>
<span class="p_add">+		 * should also define -&gt;verify_authorizer_reply().</span>
<span class="p_add">+		 * See get_connect_authorizer().</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		ret = con-&gt;ops-&gt;verify_authorizer_reply(con, 0);</span>
<span class="p_add">+		if (ret &lt; 0) {</span>
<span class="p_add">+			con-&gt;error_msg = &quot;bad authorize reply&quot;;</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	switch (con-&gt;in_reply.tag) {
 	case CEPH_MSGR_TAG_FEATURES:
 		pr_err(&quot;%s%lld %s feature set mismatch,&quot;
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index 75be7e226268..c14258a3841e 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -1600,24 +1600,19 @@</span> <span class="p_context"> EXPORT_SYMBOL(call_netdevice_notifiers);</span>
 
 static struct static_key netstamp_needed __read_mostly;
 #ifdef HAVE_JUMP_LABEL
<span class="p_del">-/* We are not allowed to call static_key_slow_dec() from irq context</span>
<span class="p_del">- * If net_disable_timestamp() is called from irq context, defer the</span>
<span class="p_del">- * static_key_slow_dec() calls.</span>
<span class="p_del">- */</span>
 static atomic_t netstamp_needed_deferred;
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-void net_enable_timestamp(void)</span>
<span class="p_add">+static void netstamp_clear(struct work_struct *work)</span>
 {
<span class="p_del">-#ifdef HAVE_JUMP_LABEL</span>
 	int deferred = atomic_xchg(&amp;netstamp_needed_deferred, 0);
 
<span class="p_del">-	if (deferred) {</span>
<span class="p_del">-		while (--deferred)</span>
<span class="p_del">-			static_key_slow_dec(&amp;netstamp_needed);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	while (deferred--)</span>
<span class="p_add">+		static_key_slow_dec(&amp;netstamp_needed);</span>
<span class="p_add">+}</span>
<span class="p_add">+static DECLARE_WORK(netstamp_work, netstamp_clear);</span>
 #endif
<span class="p_add">+</span>
<span class="p_add">+void net_enable_timestamp(void)</span>
<span class="p_add">+{</span>
 	static_key_slow_inc(&amp;netstamp_needed);
 }
 EXPORT_SYMBOL(net_enable_timestamp);
<span class="p_chunk">@@ -1625,12 +1620,12 @@</span> <span class="p_context"> EXPORT_SYMBOL(net_enable_timestamp);</span>
 void net_disable_timestamp(void)
 {
 #ifdef HAVE_JUMP_LABEL
<span class="p_del">-	if (in_interrupt()) {</span>
<span class="p_del">-		atomic_inc(&amp;netstamp_needed_deferred);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-#endif</span>
<span class="p_add">+	/* net_disable_timestamp() can be called from non process context */</span>
<span class="p_add">+	atomic_inc(&amp;netstamp_needed_deferred);</span>
<span class="p_add">+	schedule_work(&amp;netstamp_work);</span>
<span class="p_add">+#else</span>
 	static_key_slow_dec(&amp;netstamp_needed);
<span class="p_add">+#endif</span>
 }
 EXPORT_SYMBOL(net_disable_timestamp);
 
<span class="p_chunk">@@ -2287,7 +2282,7 @@</span> <span class="p_context"> int skb_checksum_help(struct sk_buff *skb)</span>
 			goto out;
 	}
 
<span class="p_del">-	*(__sum16 *)(skb-&gt;data + offset) = csum_fold(csum);</span>
<span class="p_add">+	*(__sum16 *)(skb-&gt;data + offset) = csum_fold(csum) ?: CSUM_MANGLED_0;</span>
 out_set_summed:
 	skb-&gt;ip_summed = CHECKSUM_NONE;
 out:
<span class="p_chunk">@@ -2555,9 +2550,9 @@</span> <span class="p_context"> static netdev_features_t harmonize_features(struct sk_buff *skb,</span>
 	if (skb-&gt;ip_summed != CHECKSUM_NONE &amp;&amp;
 	    !can_checksum_protocol(features, type)) {
 		features &amp;= ~NETIF_F_ALL_CSUM;
<span class="p_del">-	} else if (illegal_highdma(skb-&gt;dev, skb)) {</span>
<span class="p_del">-		features &amp;= ~NETIF_F_SG;</span>
 	}
<span class="p_add">+	if (illegal_highdma(skb-&gt;dev, skb))</span>
<span class="p_add">+		features &amp;= ~NETIF_F_SG;</span>
 
 	return features;
 }
<span class="p_chunk">@@ -3920,7 +3915,9 @@</span> <span class="p_context"> static void skb_gro_reset_offset(struct sk_buff *skb)</span>
 	    pinfo-&gt;nr_frags &amp;&amp;
 	    !PageHighMem(skb_frag_page(frag0))) {
 		NAPI_GRO_CB(skb)-&gt;frag0 = skb_frag_address(frag0);
<span class="p_del">-		NAPI_GRO_CB(skb)-&gt;frag0_len = skb_frag_size(frag0);</span>
<span class="p_add">+		NAPI_GRO_CB(skb)-&gt;frag0_len = min_t(unsigned int,</span>
<span class="p_add">+						    skb_frag_size(frag0),</span>
<span class="p_add">+						    skb-&gt;end - skb-&gt;tail);</span>
 	}
 }
 
<span class="p_chunk">@@ -4815,6 +4812,7 @@</span> <span class="p_context"> static inline bool netdev_adjacent_is_neigh_list(struct net_device *dev,</span>
 
 static int __netdev_adjacent_dev_insert(struct net_device *dev,
 					struct net_device *adj_dev,
<span class="p_add">+					u16 ref_nr,</span>
 					struct list_head *dev_list,
 					void *private, bool master)
 {
<span class="p_chunk">@@ -4824,7 +4822,7 @@</span> <span class="p_context"> static int __netdev_adjacent_dev_insert(struct net_device *dev,</span>
 	adj = __netdev_find_adj(dev, adj_dev, dev_list);
 
 	if (adj) {
<span class="p_del">-		adj-&gt;ref_nr++;</span>
<span class="p_add">+		adj-&gt;ref_nr += ref_nr;</span>
 		return 0;
 	}
 
<span class="p_chunk">@@ -4834,7 +4832,7 @@</span> <span class="p_context"> static int __netdev_adjacent_dev_insert(struct net_device *dev,</span>
 
 	adj-&gt;dev = adj_dev;
 	adj-&gt;master = master;
<span class="p_del">-	adj-&gt;ref_nr = 1;</span>
<span class="p_add">+	adj-&gt;ref_nr = ref_nr;</span>
 	adj-&gt;private = private;
 	dev_hold(adj_dev);
 
<span class="p_chunk">@@ -4873,6 +4871,7 @@</span> <span class="p_context"> free_adj:</span>
 
 static void __netdev_adjacent_dev_remove(struct net_device *dev,
 					 struct net_device *adj_dev,
<span class="p_add">+					 u16 ref_nr,</span>
 					 struct list_head *dev_list)
 {
 	struct netdev_adjacent *adj;
<span class="p_chunk">@@ -4885,10 +4884,10 @@</span> <span class="p_context"> static void __netdev_adjacent_dev_remove(struct net_device *dev,</span>
 		BUG();
 	}
 
<span class="p_del">-	if (adj-&gt;ref_nr &gt; 1) {</span>
<span class="p_del">-		pr_debug(&quot;%s to %s ref_nr-- = %d\n&quot;, dev-&gt;name, adj_dev-&gt;name,</span>
<span class="p_del">-			 adj-&gt;ref_nr-1);</span>
<span class="p_del">-		adj-&gt;ref_nr--;</span>
<span class="p_add">+	if (adj-&gt;ref_nr &gt; ref_nr) {</span>
<span class="p_add">+		pr_debug(&quot;%s to %s ref_nr-%d = %d\n&quot;, dev-&gt;name, adj_dev-&gt;name,</span>
<span class="p_add">+			 ref_nr, adj-&gt;ref_nr-ref_nr);</span>
<span class="p_add">+		adj-&gt;ref_nr -= ref_nr;</span>
 		return;
 	}
 
<span class="p_chunk">@@ -4907,21 +4906,22 @@</span> <span class="p_context"> static void __netdev_adjacent_dev_remove(struct net_device *dev,</span>
 
 static int __netdev_adjacent_dev_link_lists(struct net_device *dev,
 					    struct net_device *upper_dev,
<span class="p_add">+					    u16 ref_nr,</span>
 					    struct list_head *up_list,
 					    struct list_head *down_list,
 					    void *private, bool master)
 {
 	int ret;
 
<span class="p_del">-	ret = __netdev_adjacent_dev_insert(dev, upper_dev, up_list, private,</span>
<span class="p_del">-					   master);</span>
<span class="p_add">+	ret = __netdev_adjacent_dev_insert(dev, upper_dev, ref_nr, up_list,</span>
<span class="p_add">+					   private, master);</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	ret = __netdev_adjacent_dev_insert(upper_dev, dev, down_list, private,</span>
<span class="p_del">-					   false);</span>
<span class="p_add">+	ret = __netdev_adjacent_dev_insert(upper_dev, dev, ref_nr, down_list,</span>
<span class="p_add">+					   private, false);</span>
 	if (ret) {
<span class="p_del">-		__netdev_adjacent_dev_remove(dev, upper_dev, up_list);</span>
<span class="p_add">+		__netdev_adjacent_dev_remove(dev, upper_dev, ref_nr, up_list);</span>
 		return ret;
 	}
 
<span class="p_chunk">@@ -4929,9 +4929,10 @@</span> <span class="p_context"> static int __netdev_adjacent_dev_link_lists(struct net_device *dev,</span>
 }
 
 static int __netdev_adjacent_dev_link(struct net_device *dev,
<span class="p_del">-				      struct net_device *upper_dev)</span>
<span class="p_add">+				      struct net_device *upper_dev,</span>
<span class="p_add">+				      u16 ref_nr)</span>
 {
<span class="p_del">-	return __netdev_adjacent_dev_link_lists(dev, upper_dev,</span>
<span class="p_add">+	return __netdev_adjacent_dev_link_lists(dev, upper_dev, ref_nr,</span>
 						&amp;dev-&gt;all_adj_list.upper,
 						&amp;upper_dev-&gt;all_adj_list.lower,
 						NULL, false);
<span class="p_chunk">@@ -4939,17 +4940,19 @@</span> <span class="p_context"> static int __netdev_adjacent_dev_link(struct net_device *dev,</span>
 
 static void __netdev_adjacent_dev_unlink_lists(struct net_device *dev,
 					       struct net_device *upper_dev,
<span class="p_add">+					       u16 ref_nr,</span>
 					       struct list_head *up_list,
 					       struct list_head *down_list)
 {
<span class="p_del">-	__netdev_adjacent_dev_remove(dev, upper_dev, up_list);</span>
<span class="p_del">-	__netdev_adjacent_dev_remove(upper_dev, dev, down_list);</span>
<span class="p_add">+	__netdev_adjacent_dev_remove(dev, upper_dev, ref_nr, up_list);</span>
<span class="p_add">+	__netdev_adjacent_dev_remove(upper_dev, dev, ref_nr, down_list);</span>
 }
 
 static void __netdev_adjacent_dev_unlink(struct net_device *dev,
<span class="p_del">-					 struct net_device *upper_dev)</span>
<span class="p_add">+					 struct net_device *upper_dev,</span>
<span class="p_add">+					 u16 ref_nr)</span>
 {
<span class="p_del">-	__netdev_adjacent_dev_unlink_lists(dev, upper_dev,</span>
<span class="p_add">+	__netdev_adjacent_dev_unlink_lists(dev, upper_dev, ref_nr,</span>
 					   &amp;dev-&gt;all_adj_list.upper,
 					   &amp;upper_dev-&gt;all_adj_list.lower);
 }
<span class="p_chunk">@@ -4958,17 +4961,17 @@</span> <span class="p_context"> static int __netdev_adjacent_dev_link_neighbour(struct net_device *dev,</span>
 						struct net_device *upper_dev,
 						void *private, bool master)
 {
<span class="p_del">-	int ret = __netdev_adjacent_dev_link(dev, upper_dev);</span>
<span class="p_add">+	int ret = __netdev_adjacent_dev_link(dev, upper_dev, 1);</span>
 
 	if (ret)
 		return ret;
 
<span class="p_del">-	ret = __netdev_adjacent_dev_link_lists(dev, upper_dev,</span>
<span class="p_add">+	ret = __netdev_adjacent_dev_link_lists(dev, upper_dev, 1,</span>
 					       &amp;dev-&gt;adj_list.upper,
 					       &amp;upper_dev-&gt;adj_list.lower,
 					       private, master);
 	if (ret) {
<span class="p_del">-		__netdev_adjacent_dev_unlink(dev, upper_dev);</span>
<span class="p_add">+		__netdev_adjacent_dev_unlink(dev, upper_dev, 1);</span>
 		return ret;
 	}
 
<span class="p_chunk">@@ -4978,8 +4981,8 @@</span> <span class="p_context"> static int __netdev_adjacent_dev_link_neighbour(struct net_device *dev,</span>
 static void __netdev_adjacent_dev_unlink_neighbour(struct net_device *dev,
 						   struct net_device *upper_dev)
 {
<span class="p_del">-	__netdev_adjacent_dev_unlink(dev, upper_dev);</span>
<span class="p_del">-	__netdev_adjacent_dev_unlink_lists(dev, upper_dev,</span>
<span class="p_add">+	__netdev_adjacent_dev_unlink(dev, upper_dev, 1);</span>
<span class="p_add">+	__netdev_adjacent_dev_unlink_lists(dev, upper_dev, 1,</span>
 					   &amp;dev-&gt;adj_list.upper,
 					   &amp;upper_dev-&gt;adj_list.lower);
 }
<span class="p_chunk">@@ -5020,7 +5023,7 @@</span> <span class="p_context"> static int __netdev_upper_dev_link(struct net_device *dev,</span>
 		list_for_each_entry(j, &amp;upper_dev-&gt;all_adj_list.upper, list) {
 			pr_debug(&quot;Interlinking %s with %s, non-neighbour\n&quot;,
 				 i-&gt;dev-&gt;name, j-&gt;dev-&gt;name);
<span class="p_del">-			ret = __netdev_adjacent_dev_link(i-&gt;dev, j-&gt;dev);</span>
<span class="p_add">+			ret = __netdev_adjacent_dev_link(i-&gt;dev, j-&gt;dev, i-&gt;ref_nr);</span>
 			if (ret)
 				goto rollback_mesh;
 		}
<span class="p_chunk">@@ -5030,7 +5033,7 @@</span> <span class="p_context"> static int __netdev_upper_dev_link(struct net_device *dev,</span>
 	list_for_each_entry(i, &amp;upper_dev-&gt;all_adj_list.upper, list) {
 		pr_debug(&quot;linking %s&#39;s upper device %s with %s\n&quot;,
 			 upper_dev-&gt;name, i-&gt;dev-&gt;name, dev-&gt;name);
<span class="p_del">-		ret = __netdev_adjacent_dev_link(dev, i-&gt;dev);</span>
<span class="p_add">+		ret = __netdev_adjacent_dev_link(dev, i-&gt;dev, i-&gt;ref_nr);</span>
 		if (ret)
 			goto rollback_upper_mesh;
 	}
<span class="p_chunk">@@ -5039,7 +5042,7 @@</span> <span class="p_context"> static int __netdev_upper_dev_link(struct net_device *dev,</span>
 	list_for_each_entry(i, &amp;dev-&gt;all_adj_list.lower, list) {
 		pr_debug(&quot;linking %s&#39;s lower device %s with %s\n&quot;, dev-&gt;name,
 			 i-&gt;dev-&gt;name, upper_dev-&gt;name);
<span class="p_del">-		ret = __netdev_adjacent_dev_link(i-&gt;dev, upper_dev);</span>
<span class="p_add">+		ret = __netdev_adjacent_dev_link(i-&gt;dev, upper_dev, i-&gt;ref_nr);</span>
 		if (ret)
 			goto rollback_lower_mesh;
 	}
<span class="p_chunk">@@ -5052,7 +5055,7 @@</span> <span class="p_context"> rollback_lower_mesh:</span>
 	list_for_each_entry(i, &amp;dev-&gt;all_adj_list.lower, list) {
 		if (i == to_i)
 			break;
<span class="p_del">-		__netdev_adjacent_dev_unlink(i-&gt;dev, upper_dev);</span>
<span class="p_add">+		__netdev_adjacent_dev_unlink(i-&gt;dev, upper_dev, i-&gt;ref_nr);</span>
 	}
 
 	i = NULL;
<span class="p_chunk">@@ -5062,7 +5065,7 @@</span> <span class="p_context"> rollback_upper_mesh:</span>
 	list_for_each_entry(i, &amp;upper_dev-&gt;all_adj_list.upper, list) {
 		if (i == to_i)
 			break;
<span class="p_del">-		__netdev_adjacent_dev_unlink(dev, i-&gt;dev);</span>
<span class="p_add">+		__netdev_adjacent_dev_unlink(dev, i-&gt;dev, i-&gt;ref_nr);</span>
 	}
 
 	i = j = NULL;
<span class="p_chunk">@@ -5074,7 +5077,7 @@</span> <span class="p_context"> rollback_mesh:</span>
 		list_for_each_entry(j, &amp;upper_dev-&gt;all_adj_list.upper, list) {
 			if (i == to_i &amp;&amp; j == to_j)
 				break;
<span class="p_del">-			__netdev_adjacent_dev_unlink(i-&gt;dev, j-&gt;dev);</span>
<span class="p_add">+			__netdev_adjacent_dev_unlink(i-&gt;dev, j-&gt;dev, i-&gt;ref_nr);</span>
 		}
 		if (i == to_i)
 			break;
<span class="p_chunk">@@ -5150,16 +5153,16 @@</span> <span class="p_context"> void netdev_upper_dev_unlink(struct net_device *dev,</span>
 	 */
 	list_for_each_entry(i, &amp;dev-&gt;all_adj_list.lower, list)
 		list_for_each_entry(j, &amp;upper_dev-&gt;all_adj_list.upper, list)
<span class="p_del">-			__netdev_adjacent_dev_unlink(i-&gt;dev, j-&gt;dev);</span>
<span class="p_add">+			__netdev_adjacent_dev_unlink(i-&gt;dev, j-&gt;dev, i-&gt;ref_nr);</span>
 
 	/* remove also the devices itself from lower/upper device
 	 * list
 	 */
 	list_for_each_entry(i, &amp;dev-&gt;all_adj_list.lower, list)
<span class="p_del">-		__netdev_adjacent_dev_unlink(i-&gt;dev, upper_dev);</span>
<span class="p_add">+		__netdev_adjacent_dev_unlink(i-&gt;dev, upper_dev, i-&gt;ref_nr);</span>
 
 	list_for_each_entry(i, &amp;upper_dev-&gt;all_adj_list.upper, list)
<span class="p_del">-		__netdev_adjacent_dev_unlink(dev, i-&gt;dev);</span>
<span class="p_add">+		__netdev_adjacent_dev_unlink(dev, i-&gt;dev, i-&gt;ref_nr);</span>
 
 	call_netdevice_notifiers(NETDEV_CHANGEUPPER, dev);
 }
<span class="p_header">diff --git a/net/core/drop_monitor.c b/net/core/drop_monitor.c</span>
<span class="p_header">index e70301eb7a4a..add0544a571a 100644</span>
<span class="p_header">--- a/net/core/drop_monitor.c</span>
<span class="p_header">+++ b/net/core/drop_monitor.c</span>
<span class="p_chunk">@@ -80,6 +80,7 @@</span> <span class="p_context"> static struct sk_buff *reset_per_cpu_data(struct per_cpu_dm_data *data)</span>
 	struct nlattr *nla;
 	struct sk_buff *skb;
 	unsigned long flags;
<span class="p_add">+	void *msg_header;</span>
 
 	al = sizeof(struct net_dm_alert_msg);
 	al += dm_hit_limit * sizeof(struct net_dm_drop_point);
<span class="p_chunk">@@ -87,21 +88,41 @@</span> <span class="p_context"> static struct sk_buff *reset_per_cpu_data(struct per_cpu_dm_data *data)</span>
 
 	skb = genlmsg_new(al, GFP_KERNEL);
 
<span class="p_del">-	if (skb) {</span>
<span class="p_del">-		genlmsg_put(skb, 0, 0, &amp;net_drop_monitor_family,</span>
<span class="p_del">-				0, NET_DM_CMD_ALERT);</span>
<span class="p_del">-		nla = nla_reserve(skb, NLA_UNSPEC,</span>
<span class="p_del">-				  sizeof(struct net_dm_alert_msg));</span>
<span class="p_del">-		msg = nla_data(nla);</span>
<span class="p_del">-		memset(msg, 0, al);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		mod_timer(&amp;data-&gt;send_timer, jiffies + HZ / 10);</span>
<span class="p_add">+	if (!skb)</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+</span>
<span class="p_add">+	msg_header = genlmsg_put(skb, 0, 0, &amp;net_drop_monitor_family,</span>
<span class="p_add">+				 0, NET_DM_CMD_ALERT);</span>
<span class="p_add">+	if (!msg_header) {</span>
<span class="p_add">+		nlmsg_free(skb);</span>
<span class="p_add">+		skb = NULL;</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	nla = nla_reserve(skb, NLA_UNSPEC,</span>
<span class="p_add">+			  sizeof(struct net_dm_alert_msg));</span>
<span class="p_add">+	if (!nla) {</span>
<span class="p_add">+		nlmsg_free(skb);</span>
<span class="p_add">+		skb = NULL;</span>
<span class="p_add">+		goto err;</span>
 	}
<span class="p_add">+	msg = nla_data(nla);</span>
<span class="p_add">+	memset(msg, 0, al);</span>
<span class="p_add">+	goto out;</span>
 
<span class="p_add">+err:</span>
<span class="p_add">+	mod_timer(&amp;data-&gt;send_timer, jiffies + HZ / 10);</span>
<span class="p_add">+out:</span>
 	spin_lock_irqsave(&amp;data-&gt;lock, flags);
 	swap(data-&gt;skb, skb);
 	spin_unlock_irqrestore(&amp;data-&gt;lock, flags);
 
<span class="p_add">+	if (skb) {</span>
<span class="p_add">+		struct nlmsghdr *nlh = (struct nlmsghdr *)skb-&gt;data;</span>
<span class="p_add">+		struct genlmsghdr *gnlh = (struct genlmsghdr *)nlmsg_data(nlh);</span>
<span class="p_add">+</span>
<span class="p_add">+		genlmsg_end(skb, genlmsg_data(gnlh));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return skb;
 }
 
<span class="p_header">diff --git a/net/core/sock.c b/net/core/sock.c</span>
<span class="p_header">index 9cb00d1ea140..af856f01cc8f 100644</span>
<span class="p_header">--- a/net/core/sock.c</span>
<span class="p_header">+++ b/net/core/sock.c</span>
<span class="p_chunk">@@ -1560,6 +1560,7 @@</span> <span class="p_context"> struct sock *sk_clone_lock(const struct sock *sk, const gfp_t priority)</span>
 		}
 
 		newsk-&gt;sk_err	   = 0;
<span class="p_add">+		newsk-&gt;sk_err_soft = 0;</span>
 		newsk-&gt;sk_priority = 0;
 		/*
 		 * Before updating sk_refcnt, we must commit prior changes to memory
<span class="p_chunk">@@ -1678,6 +1679,12 @@</span> <span class="p_context"> void sock_rfree(struct sk_buff *skb)</span>
 }
 EXPORT_SYMBOL(sock_rfree);
 
<span class="p_add">+void sock_efree(struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	sock_put(skb-&gt;sk);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(sock_efree);</span>
<span class="p_add">+</span>
 void sock_edemux(struct sk_buff *skb)
 {
 	struct sock *sk = skb-&gt;sk;
<span class="p_chunk">@@ -2119,12 +2126,13 @@</span> <span class="p_context"> EXPORT_SYMBOL(__sk_mem_schedule);</span>
 /**
  *	__sk_reclaim - reclaim memory_allocated
  *	@sk: socket
<span class="p_add">+ *	@amount: number of bytes (rounded down to a SK_MEM_QUANTUM multiple)</span>
  */
<span class="p_del">-void __sk_mem_reclaim(struct sock *sk)</span>
<span class="p_add">+void __sk_mem_reclaim(struct sock *sk, int amount)</span>
 {
<span class="p_del">-	sk_memory_allocated_sub(sk,</span>
<span class="p_del">-				sk-&gt;sk_forward_alloc &gt;&gt; SK_MEM_QUANTUM_SHIFT);</span>
<span class="p_del">-	sk-&gt;sk_forward_alloc &amp;= SK_MEM_QUANTUM - 1;</span>
<span class="p_add">+	amount &gt;&gt;= SK_MEM_QUANTUM_SHIFT;</span>
<span class="p_add">+	sk_memory_allocated_sub(sk, amount);</span>
<span class="p_add">+	sk-&gt;sk_forward_alloc -= amount &lt;&lt; SK_MEM_QUANTUM_SHIFT;</span>
 
 	if (sk_under_memory_pressure(sk) &amp;&amp;
 	    (sk_memory_allocated(sk) &lt; sk_prot_mem_limits(sk, 0)))
<span class="p_header">diff --git a/net/dccp/ipv4.c b/net/dccp/ipv4.c</span>
<span class="p_header">index b371341d899d..7d9b21a7dbb6 100644</span>
<span class="p_header">--- a/net/dccp/ipv4.c</span>
<span class="p_header">+++ b/net/dccp/ipv4.c</span>
<span class="p_chunk">@@ -213,7 +213,7 @@</span> <span class="p_context"> static void dccp_v4_err(struct sk_buff *skb, u32 info)</span>
 {
 	const struct iphdr *iph = (struct iphdr *)skb-&gt;data;
 	const u8 offset = iph-&gt;ihl &lt;&lt; 2;
<span class="p_del">-	const struct dccp_hdr *dh = (struct dccp_hdr *)(skb-&gt;data + offset);</span>
<span class="p_add">+	const struct dccp_hdr *dh;</span>
 	struct dccp_sock *dp;
 	struct inet_sock *inet;
 	const int type = icmp_hdr(skb)-&gt;type;
<span class="p_chunk">@@ -223,11 +223,13 @@</span> <span class="p_context"> static void dccp_v4_err(struct sk_buff *skb, u32 info)</span>
 	int err;
 	struct net *net = dev_net(skb-&gt;dev);
 
<span class="p_del">-	if (skb-&gt;len &lt; offset + sizeof(*dh) ||</span>
<span class="p_del">-	    skb-&gt;len &lt; offset + __dccp_basic_hdr_len(dh)) {</span>
<span class="p_del">-		ICMP_INC_STATS_BH(net, ICMP_MIB_INERRORS);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* Only need dccph_dport &amp; dccph_sport which are the first</span>
<span class="p_add">+	 * 4 bytes in dccp header.</span>
<span class="p_add">+	 * Our caller (icmp_socket_deliver()) already pulled 8 bytes for us.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	BUILD_BUG_ON(offsetof(struct dccp_hdr, dccph_sport) + sizeof(dh-&gt;dccph_sport) &gt; 8);</span>
<span class="p_add">+	BUILD_BUG_ON(offsetof(struct dccp_hdr, dccph_dport) + sizeof(dh-&gt;dccph_dport) &gt; 8);</span>
<span class="p_add">+	dh = (struct dccp_hdr *)(skb-&gt;data + offset);</span>
 
 	sk = inet_lookup(net, &amp;dccp_hashinfo,
 			iph-&gt;daddr, dh-&gt;dccph_dport,
<span class="p_chunk">@@ -741,6 +743,7 @@</span> <span class="p_context"> int dccp_invalid_packet(struct sk_buff *skb)</span>
 {
 	const struct dccp_hdr *dh;
 	unsigned int cscov;
<span class="p_add">+	u8 dccph_doff;</span>
 
 	if (skb-&gt;pkt_type != PACKET_HOST)
 		return 1;
<span class="p_chunk">@@ -762,18 +765,19 @@</span> <span class="p_context"> int dccp_invalid_packet(struct sk_buff *skb)</span>
 	/*
 	 * If P.Data Offset is too small for packet type, drop packet and return
 	 */
<span class="p_del">-	if (dh-&gt;dccph_doff &lt; dccp_hdr_len(skb) / sizeof(u32)) {</span>
<span class="p_del">-		DCCP_WARN(&quot;P.Data Offset(%u) too small\n&quot;, dh-&gt;dccph_doff);</span>
<span class="p_add">+	dccph_doff = dh-&gt;dccph_doff;</span>
<span class="p_add">+	if (dccph_doff &lt; dccp_hdr_len(skb) / sizeof(u32)) {</span>
<span class="p_add">+		DCCP_WARN(&quot;P.Data Offset(%u) too small\n&quot;, dccph_doff);</span>
 		return 1;
 	}
 	/*
 	 * If P.Data Offset is too too large for packet, drop packet and return
 	 */
<span class="p_del">-	if (!pskb_may_pull(skb, dh-&gt;dccph_doff * sizeof(u32))) {</span>
<span class="p_del">-		DCCP_WARN(&quot;P.Data Offset(%u) too large\n&quot;, dh-&gt;dccph_doff);</span>
<span class="p_add">+	if (!pskb_may_pull(skb, dccph_doff * sizeof(u32))) {</span>
<span class="p_add">+		DCCP_WARN(&quot;P.Data Offset(%u) too large\n&quot;, dccph_doff);</span>
 		return 1;
 	}
<span class="p_del">-</span>
<span class="p_add">+	dh = dccp_hdr(skb);</span>
 	/*
 	 * If P.type is not Data, Ack, or DataAck and P.X == 0 (the packet
 	 * has short sequence numbers), drop packet and return
<span class="p_header">diff --git a/net/dccp/ipv6.c b/net/dccp/ipv6.c</span>
<span class="p_header">index 9f2dc1d15e43..b42151be8afa 100644</span>
<span class="p_header">--- a/net/dccp/ipv6.c</span>
<span class="p_header">+++ b/net/dccp/ipv6.c</span>
<span class="p_chunk">@@ -83,7 +83,7 @@</span> <span class="p_context"> static void dccp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,</span>
 			u8 type, u8 code, int offset, __be32 info)
 {
 	const struct ipv6hdr *hdr = (const struct ipv6hdr *)skb-&gt;data;
<span class="p_del">-	const struct dccp_hdr *dh = (struct dccp_hdr *)(skb-&gt;data + offset);</span>
<span class="p_add">+	const struct dccp_hdr *dh;</span>
 	struct dccp_sock *dp;
 	struct ipv6_pinfo *np;
 	struct sock *sk;
<span class="p_chunk">@@ -91,12 +91,13 @@</span> <span class="p_context"> static void dccp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,</span>
 	__u64 seq;
 	struct net *net = dev_net(skb-&gt;dev);
 
<span class="p_del">-	if (skb-&gt;len &lt; offset + sizeof(*dh) ||</span>
<span class="p_del">-	    skb-&gt;len &lt; offset + __dccp_basic_hdr_len(dh)) {</span>
<span class="p_del">-		ICMP6_INC_STATS_BH(net, __in6_dev_get(skb-&gt;dev),</span>
<span class="p_del">-				   ICMP6_MIB_INERRORS);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* Only need dccph_dport &amp; dccph_sport which are the first</span>
<span class="p_add">+	 * 4 bytes in dccp header.</span>
<span class="p_add">+	 * Our caller (icmpv6_notify()) already pulled 8 bytes for us.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	BUILD_BUG_ON(offsetof(struct dccp_hdr, dccph_sport) + sizeof(dh-&gt;dccph_sport) &gt; 8);</span>
<span class="p_add">+	BUILD_BUG_ON(offsetof(struct dccp_hdr, dccph_dport) + sizeof(dh-&gt;dccph_dport) &gt; 8);</span>
<span class="p_add">+	dh = (struct dccp_hdr *)(skb-&gt;data + offset);</span>
 
 	sk = inet6_lookup(net, &amp;dccp_hashinfo,
 			&amp;hdr-&gt;daddr, dh-&gt;dccph_dport,
<span class="p_chunk">@@ -1023,6 +1024,7 @@</span> <span class="p_context"> static const struct inet_connection_sock_af_ops dccp_ipv6_mapped = {</span>
 	.getsockopt	   = ipv6_getsockopt,
 	.addr2sockaddr	   = inet6_csk_addr2sockaddr,
 	.sockaddr_len	   = sizeof(struct sockaddr_in6),
<span class="p_add">+	.bind_conflict	   = inet6_csk_bind_conflict,</span>
 #ifdef CONFIG_COMPAT
 	.compat_setsockopt = compat_ipv6_setsockopt,
 	.compat_getsockopt = compat_ipv6_getsockopt,
<span class="p_header">diff --git a/net/dccp/proto.c b/net/dccp/proto.c</span>
<span class="p_header">index de2c1e719305..f8fa2d15115e 100644</span>
<span class="p_header">--- a/net/dccp/proto.c</span>
<span class="p_header">+++ b/net/dccp/proto.c</span>
<span class="p_chunk">@@ -1012,6 +1012,10 @@</span> <span class="p_context"> void dccp_close(struct sock *sk, long timeout)</span>
 		__kfree_skb(skb);
 	}
 
<span class="p_add">+	/* If socket has been already reset kill it. */</span>
<span class="p_add">+	if (sk-&gt;sk_state == DCCP_CLOSED)</span>
<span class="p_add">+		goto adjudge_to_death;</span>
<span class="p_add">+</span>
 	if (data_was_unread) {
 		/* Unread data was tossed, send an appropriate Reset Code */
 		DCCP_WARN(&quot;ABORT with %u bytes unread\n&quot;, data_was_unread);
<span class="p_header">diff --git a/net/decnet/dn_route.c b/net/decnet/dn_route.c</span>
<span class="p_header">index daccc4a36d80..4047341f6c07 100644</span>
<span class="p_header">--- a/net/decnet/dn_route.c</span>
<span class="p_header">+++ b/net/decnet/dn_route.c</span>
<span class="p_chunk">@@ -1042,10 +1042,13 @@</span> <span class="p_context"> source_ok:</span>
 	if (!fld.daddr) {
 		fld.daddr = fld.saddr;
 
<span class="p_del">-		err = -EADDRNOTAVAIL;</span>
 		if (dev_out)
 			dev_put(dev_out);
<span class="p_add">+		err = -EINVAL;</span>
 		dev_out = init_net.loopback_dev;
<span class="p_add">+		if (!dev_out-&gt;dn_ptr)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		err = -EADDRNOTAVAIL;</span>
 		dev_hold(dev_out);
 		if (!fld.daddr) {
 			fld.daddr =
<span class="p_chunk">@@ -1118,6 +1121,8 @@</span> <span class="p_context"> source_ok:</span>
 		if (dev_out == NULL)
 			goto out;
 		dn_db = rcu_dereference_raw(dev_out-&gt;dn_ptr);
<span class="p_add">+		if (!dn_db)</span>
<span class="p_add">+			goto e_inval;</span>
 		/* Possible improvement - check all devices for local addr */
 		if (dn_dev_islocal(dev_out, fld.daddr)) {
 			dev_put(dev_out);
<span class="p_chunk">@@ -1159,6 +1164,8 @@</span> <span class="p_context"> select_source:</span>
 			dev_put(dev_out);
 		dev_out = init_net.loopback_dev;
 		dev_hold(dev_out);
<span class="p_add">+		if (!dev_out-&gt;dn_ptr)</span>
<span class="p_add">+			goto e_inval;</span>
 		fld.flowidn_oif = dev_out-&gt;ifindex;
 		if (res.fi)
 			dn_fib_info_put(res.fi);
<span class="p_header">diff --git a/net/ipv4/cipso_ipv4.c b/net/ipv4/cipso_ipv4.c</span>
<span class="p_header">index 69e77c8ff285..25be314d0e17 100644</span>
<span class="p_header">--- a/net/ipv4/cipso_ipv4.c</span>
<span class="p_header">+++ b/net/ipv4/cipso_ipv4.c</span>
<span class="p_chunk">@@ -1645,6 +1645,10 @@</span> <span class="p_context"> int cipso_v4_validate(const struct sk_buff *skb, unsigned char **option)</span>
 				goto validate_return_locked;
 			}
 
<span class="p_add">+		if (opt_iter + 1 == opt_len) {</span>
<span class="p_add">+			err_offset = opt_iter;</span>
<span class="p_add">+			goto validate_return_locked;</span>
<span class="p_add">+		}</span>
 		tag_len = tag[1];
 		if (tag_len &gt; (opt_len - opt_iter)) {
 			err_offset = opt_iter + 1;
<span class="p_header">diff --git a/net/ipv4/igmp.c b/net/ipv4/igmp.c</span>
<span class="p_header">index 727447c17954..8f1ee4bb4c51 100644</span>
<span class="p_header">--- a/net/ipv4/igmp.c</span>
<span class="p_header">+++ b/net/ipv4/igmp.c</span>
<span class="p_chunk">@@ -164,7 +164,7 @@</span> <span class="p_context"> static int unsolicited_report_interval(struct in_device *in_dev)</span>
 }
 
 static void igmpv3_add_delrec(struct in_device *in_dev, struct ip_mc_list *im);
<span class="p_del">-static void igmpv3_del_delrec(struct in_device *in_dev, __be32 multiaddr);</span>
<span class="p_add">+static void igmpv3_del_delrec(struct in_device *in_dev, struct ip_mc_list *im);</span>
 static void igmpv3_clear_delrec(struct in_device *in_dev);
 static int sf_setstate(struct ip_mc_list *pmc);
 static void sf_markstate(struct ip_mc_list *pmc);
<span class="p_chunk">@@ -221,9 +221,14 @@</span> <span class="p_context"> static void igmp_start_timer(struct ip_mc_list *im, int max_delay)</span>
 static void igmp_gq_start_timer(struct in_device *in_dev)
 {
 	int tv = prandom_u32() % in_dev-&gt;mr_maxdelay;
<span class="p_add">+	unsigned long exp = jiffies + tv + 2;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (in_dev-&gt;mr_gq_running &amp;&amp;</span>
<span class="p_add">+	    time_after_eq(exp, (in_dev-&gt;mr_gq_timer).expires))</span>
<span class="p_add">+		return;</span>
 
 	in_dev-&gt;mr_gq_running = 1;
<span class="p_del">-	if (!mod_timer(&amp;in_dev-&gt;mr_gq_timer, jiffies+tv+2))</span>
<span class="p_add">+	if (!mod_timer(&amp;in_dev-&gt;mr_gq_timer, exp))</span>
 		in_dev_hold(in_dev);
 }
 
<span class="p_chunk">@@ -1104,10 +1109,14 @@</span> <span class="p_context"> static void igmpv3_add_delrec(struct in_device *in_dev, struct ip_mc_list *im)</span>
 	spin_unlock_bh(&amp;in_dev-&gt;mc_tomb_lock);
 }
 
<span class="p_del">-static void igmpv3_del_delrec(struct in_device *in_dev, __be32 multiaddr)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * restore ip_mc_list deleted records</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void igmpv3_del_delrec(struct in_device *in_dev, struct ip_mc_list *im)</span>
 {
 	struct ip_mc_list *pmc, *pmc_prev;
<span class="p_del">-	struct ip_sf_list *psf, *psf_next;</span>
<span class="p_add">+	struct ip_sf_list *psf;</span>
<span class="p_add">+	__be32 multiaddr = im-&gt;multiaddr;</span>
 
 	spin_lock_bh(&amp;in_dev-&gt;mc_tomb_lock);
 	pmc_prev = NULL;
<span class="p_chunk">@@ -1123,16 +1132,27 @@</span> <span class="p_context"> static void igmpv3_del_delrec(struct in_device *in_dev, __be32 multiaddr)</span>
 			in_dev-&gt;mc_tomb = pmc-&gt;next;
 	}
 	spin_unlock_bh(&amp;in_dev-&gt;mc_tomb_lock);
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_bh(&amp;im-&gt;lock);</span>
 	if (pmc) {
<span class="p_del">-		for (psf = pmc-&gt;tomb; psf; psf = psf_next) {</span>
<span class="p_del">-			psf_next = psf-&gt;sf_next;</span>
<span class="p_del">-			kfree(psf);</span>
<span class="p_add">+		im-&gt;interface = pmc-&gt;interface;</span>
<span class="p_add">+		im-&gt;crcount = in_dev-&gt;mr_qrv ?: IGMP_Unsolicited_Report_Count;</span>
<span class="p_add">+		im-&gt;sfmode = pmc-&gt;sfmode;</span>
<span class="p_add">+		if (pmc-&gt;sfmode == MCAST_INCLUDE) {</span>
<span class="p_add">+			im-&gt;tomb = pmc-&gt;tomb;</span>
<span class="p_add">+			im-&gt;sources = pmc-&gt;sources;</span>
<span class="p_add">+			for (psf = im-&gt;sources; psf; psf = psf-&gt;sf_next)</span>
<span class="p_add">+				psf-&gt;sf_crcount = im-&gt;crcount;</span>
 		}
 		in_dev_put(pmc-&gt;interface);
 		kfree(pmc);
 	}
<span class="p_add">+	spin_unlock_bh(&amp;im-&gt;lock);</span>
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * flush ip_mc_list deleted records</span>
<span class="p_add">+ */</span>
 static void igmpv3_clear_delrec(struct in_device *in_dev)
 {
 	struct ip_mc_list *pmc, *nextpmc;
<span class="p_chunk">@@ -1330,7 +1350,7 @@</span> <span class="p_context"> void ip_mc_inc_group(struct in_device *in_dev, __be32 addr)</span>
 	ip_mc_hash_add(in_dev, im);
 
 #ifdef CONFIG_IP_MULTICAST
<span class="p_del">-	igmpv3_del_delrec(in_dev, im-&gt;multiaddr);</span>
<span class="p_add">+	igmpv3_del_delrec(in_dev, im);</span>
 #endif
 	igmp_group_added(im);
 	if (!in_dev-&gt;dead)
<span class="p_chunk">@@ -1421,8 +1441,12 @@</span> <span class="p_context"> void ip_mc_remap(struct in_device *in_dev)</span>
 
 	ASSERT_RTNL();
 
<span class="p_del">-	for_each_pmc_rtnl(in_dev, pmc)</span>
<span class="p_add">+	for_each_pmc_rtnl(in_dev, pmc) {</span>
<span class="p_add">+#ifdef CONFIG_IP_MULTICAST</span>
<span class="p_add">+		igmpv3_del_delrec(in_dev, pmc);</span>
<span class="p_add">+#endif</span>
 		igmp_group_added(pmc);
<span class="p_add">+	}</span>
 }
 
 /* Device going down */
<span class="p_chunk">@@ -1443,7 +1467,6 @@</span> <span class="p_context"> void ip_mc_down(struct in_device *in_dev)</span>
 	in_dev-&gt;mr_gq_running = 0;
 	if (del_timer(&amp;in_dev-&gt;mr_gq_timer))
 		__in_dev_put(in_dev);
<span class="p_del">-	igmpv3_clear_delrec(in_dev);</span>
 #endif
 
 	ip_mc_dec_group(in_dev, IGMP_ALL_HOSTS);
<span class="p_chunk">@@ -1474,8 +1497,12 @@</span> <span class="p_context"> void ip_mc_up(struct in_device *in_dev)</span>
 
 	ip_mc_inc_group(in_dev, IGMP_ALL_HOSTS);
 
<span class="p_del">-	for_each_pmc_rtnl(in_dev, pmc)</span>
<span class="p_add">+	for_each_pmc_rtnl(in_dev, pmc) {</span>
<span class="p_add">+#ifdef CONFIG_IP_MULTICAST</span>
<span class="p_add">+		igmpv3_del_delrec(in_dev, pmc);</span>
<span class="p_add">+#endif</span>
 		igmp_group_added(pmc);
<span class="p_add">+	}</span>
 }
 
 /*
<span class="p_chunk">@@ -1490,13 +1517,13 @@</span> <span class="p_context"> void ip_mc_destroy_dev(struct in_device *in_dev)</span>
 
 	/* Deactivate timers */
 	ip_mc_down(in_dev);
<span class="p_add">+#ifdef CONFIG_IP_MULTICAST</span>
<span class="p_add">+	igmpv3_clear_delrec(in_dev);</span>
<span class="p_add">+#endif</span>
 
 	while ((i = rtnl_dereference(in_dev-&gt;mc_list)) != NULL) {
 		in_dev-&gt;mc_list = i-&gt;next_rcu;
 		in_dev-&gt;mc_count--;
<span class="p_del">-</span>
<span class="p_del">-		/* We&#39;ve dropped the groups in ip_mc_down already */</span>
<span class="p_del">-		ip_mc_clear_src(i);</span>
 		ip_ma_put(i);
 	}
 }
<span class="p_header">diff --git a/net/ipv4/ipmr.c b/net/ipv4/ipmr.c</span>
<span class="p_header">index 65a28620006c..643ec0bb80a5 100644</span>
<span class="p_header">--- a/net/ipv4/ipmr.c</span>
<span class="p_header">+++ b/net/ipv4/ipmr.c</span>
<span class="p_chunk">@@ -883,8 +883,10 @@</span> <span class="p_context"> static struct mfc_cache *ipmr_cache_alloc(void)</span>
 {
 	struct mfc_cache *c = kmem_cache_zalloc(mrt_cachep, GFP_KERNEL);
 
<span class="p_del">-	if (c)</span>
<span class="p_add">+	if (c) {</span>
<span class="p_add">+		c-&gt;mfc_un.res.last_assert = jiffies - MFC_ASSERT_THRESH - 1;</span>
 		c-&gt;mfc_un.res.minvif = MAXVIFS;
<span class="p_add">+	}</span>
 	return c;
 }
 
<span class="p_header">diff --git a/net/ipv4/netfilter/ipt_rpfilter.c b/net/ipv4/netfilter/ipt_rpfilter.c</span>
<span class="p_header">index 60f27b1e46f6..d0b38aa58ca7 100644</span>
<span class="p_header">--- a/net/ipv4/netfilter/ipt_rpfilter.c</span>
<span class="p_header">+++ b/net/ipv4/netfilter/ipt_rpfilter.c</span>
<span class="p_chunk">@@ -64,10 +64,10 @@</span> <span class="p_context"> static bool rpfilter_lookup_reverse(struct flowi4 *fl4,</span>
 	return dev_match || flags &amp; XT_RPFILTER_LOOSE;
 }
 
<span class="p_del">-static bool rpfilter_is_local(const struct sk_buff *skb)</span>
<span class="p_add">+static bool</span>
<span class="p_add">+rpfilter_is_loopback(const struct sk_buff *skb, const struct net_device *in)</span>
 {
<span class="p_del">-	const struct rtable *rt = skb_rtable(skb);</span>
<span class="p_del">-	return rt &amp;&amp; (rt-&gt;rt_flags &amp; RTCF_LOCAL);</span>
<span class="p_add">+	return skb-&gt;pkt_type == PACKET_LOOPBACK || in-&gt;flags &amp; IFF_LOOPBACK;</span>
 }
 
 static bool rpfilter_mt(const struct sk_buff *skb, struct xt_action_param *par)
<span class="p_chunk">@@ -80,7 +80,7 @@</span> <span class="p_context"> static bool rpfilter_mt(const struct sk_buff *skb, struct xt_action_param *par)</span>
 	info = par-&gt;matchinfo;
 	invert = info-&gt;flags &amp; XT_RPFILTER_INVERT;
 
<span class="p_del">-	if (rpfilter_is_local(skb))</span>
<span class="p_add">+	if (rpfilter_is_loopback(skb, par-&gt;in))</span>
 		return true ^ invert;
 
 	iph = ip_hdr(skb);
<span class="p_header">diff --git a/net/ipv4/ping.c b/net/ipv4/ping.c</span>
<span class="p_header">index 181d5de8ba52..571dabfe9ef3 100644</span>
<span class="p_header">--- a/net/ipv4/ping.c</span>
<span class="p_header">+++ b/net/ipv4/ping.c</span>
<span class="p_chunk">@@ -646,6 +646,8 @@</span> <span class="p_context"> static int ping_v4_push_pending_frames(struct sock *sk, struct pingfakehdr *pfh,</span>
 {
 	struct sk_buff *skb = skb_peek(&amp;sk-&gt;sk_write_queue);
 
<span class="p_add">+	if (!skb)</span>
<span class="p_add">+		return 0;</span>
 	pfh-&gt;wcheck = csum_partial((char *)&amp;pfh-&gt;icmph,
 		sizeof(struct icmphdr), pfh-&gt;wcheck);
 	pfh-&gt;icmph.checksum = csum_fold(pfh-&gt;wcheck);
<span class="p_header">diff --git a/net/ipv4/route.c b/net/ipv4/route.c</span>
<span class="p_header">index 7cd37b04f3a6..77bf6bde38cc 100644</span>
<span class="p_header">--- a/net/ipv4/route.c</span>
<span class="p_header">+++ b/net/ipv4/route.c</span>
<span class="p_chunk">@@ -1968,6 +1968,18 @@</span> <span class="p_context"> static struct rtable *__mkroute_output(const struct fib_result *res,</span>
 		 */
 		if (fi &amp;&amp; res-&gt;prefixlen &lt; 4)
 			fi = NULL;
<span class="p_add">+	} else if ((type == RTN_LOCAL) &amp;&amp; (orig_oif != 0) &amp;&amp;</span>
<span class="p_add">+		   (orig_oif != dev_out-&gt;ifindex)) {</span>
<span class="p_add">+		/* For local routes that require a particular output interface</span>
<span class="p_add">+		 * we do not want to cache the result.  Caching the result</span>
<span class="p_add">+		 * causes incorrect behaviour when there are multiple source</span>
<span class="p_add">+		 * addresses on the interface, the end result being that if the</span>
<span class="p_add">+		 * intended recipient is waiting on that interface for the</span>
<span class="p_add">+		 * packet he won&#39;t receive it because it will be delivered on</span>
<span class="p_add">+		 * the loopback interface and the IP_PKTINFO ipi_ifindex will</span>
<span class="p_add">+		 * be set to the loopback interface as well.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		fi = NULL;</span>
 	}
 
 	fnhe = NULL;
<span class="p_header">diff --git a/net/ipv4/tcp_fastopen.c b/net/ipv4/tcp_fastopen.c</span>
<span class="p_header">index 2b986576e5ad..0b23c4ec653f 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_fastopen.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_fastopen.c</span>
<span class="p_chunk">@@ -112,7 +112,7 @@</span> <span class="p_context"> static bool tcp_fastopen_cookie_gen(struct request_sock *req,</span>
 		struct tcp_fastopen_cookie tmp;
 
 		if (__tcp_fastopen_cookie_gen(&amp;ip6h-&gt;saddr, &amp;tmp)) {
<span class="p_del">-			struct in6_addr *buf = (struct in6_addr *) tmp.val;</span>
<span class="p_add">+			struct in6_addr *buf = &amp;tmp.addr;</span>
 			int i = 4;
 
 			for (i = 0; i &lt; 4; i++)
<span class="p_chunk">@@ -164,6 +164,7 @@</span> <span class="p_context"> static bool tcp_fastopen_create_child(struct sock *sk,</span>
 	 * scaled. So correct it appropriately.
 	 */
 	tp-&gt;snd_wnd = ntohs(tcp_hdr(skb)-&gt;window);
<span class="p_add">+	tp-&gt;max_window = tp-&gt;snd_wnd;</span>
 
 	/* Activate the retrans timer so that SYNACK can be retransmitted.
 	 * The request socket is not added to the SYN table of the parent
<span class="p_header">diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c</span>
<span class="p_header">index 8b5c457b40cd..f8ee2fc404cd 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_output.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_output.c</span>
<span class="p_chunk">@@ -1821,12 +1821,14 @@</span> <span class="p_context"> static int tcp_mtu_probe(struct sock *sk)</span>
 	len = 0;
 	tcp_for_write_queue_from_safe(skb, next, sk) {
 		copy = min_t(int, skb-&gt;len, probe_size - len);
<span class="p_del">-		if (nskb-&gt;ip_summed)</span>
<span class="p_add">+		if (nskb-&gt;ip_summed) {</span>
 			skb_copy_bits(skb, 0, skb_put(nskb, copy), copy);
<span class="p_del">-		else</span>
<span class="p_del">-			nskb-&gt;csum = skb_copy_and_csum_bits(skb, 0,</span>
<span class="p_del">-							    skb_put(nskb, copy),</span>
<span class="p_del">-							    copy, nskb-&gt;csum);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			__wsum csum = skb_copy_and_csum_bits(skb, 0,</span>
<span class="p_add">+							     skb_put(nskb, copy),</span>
<span class="p_add">+							     copy, 0);</span>
<span class="p_add">+			nskb-&gt;csum = csum_block_add(nskb-&gt;csum, csum, len);</span>
<span class="p_add">+		}</span>
 
 		if (skb-&gt;len &lt;= copy) {
 			/* We&#39;ve eaten all the data from this skb.
<span class="p_chunk">@@ -2249,9 +2251,11 @@</span> <span class="p_context"> u32 __tcp_select_window(struct sock *sk)</span>
 	int full_space = min_t(int, tp-&gt;window_clamp, allowed_space);
 	int window;
 
<span class="p_del">-	if (mss &gt; full_space)</span>
<span class="p_add">+	if (unlikely(mss &gt; full_space)) {</span>
 		mss = full_space;
<span class="p_del">-</span>
<span class="p_add">+		if (mss &lt;= 0)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+	}</span>
 	if (free_space &lt; (full_space &gt;&gt; 1)) {
 		icsk-&gt;icsk_ack.quick = 0;
 
<span class="p_chunk">@@ -2437,7 +2441,8 @@</span> <span class="p_context"> int __tcp_retransmit_skb(struct sock *sk, struct sk_buff *skb)</span>
 	 * copying overhead: fragmentation, tunneling, mangling etc.
 	 */
 	if (atomic_read(&amp;sk-&gt;sk_wmem_alloc) &gt;
<span class="p_del">-	    min(sk-&gt;sk_wmem_queued + (sk-&gt;sk_wmem_queued &gt;&gt; 2), sk-&gt;sk_sndbuf))</span>
<span class="p_add">+	    min_t(u32, sk-&gt;sk_wmem_queued + (sk-&gt;sk_wmem_queued &gt;&gt; 2),</span>
<span class="p_add">+		  sk-&gt;sk_sndbuf))</span>
 		return -EAGAIN;
 
 	if (skb_still_in_host_queue(sk, skb))
<span class="p_header">diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c</span>
<span class="p_header">index 716475fc884b..59ddab1fce28 100644</span>
<span class="p_header">--- a/net/ipv4/udp.c</span>
<span class="p_header">+++ b/net/ipv4/udp.c</span>
<span class="p_chunk">@@ -1533,7 +1533,7 @@</span> <span class="p_context"> int udp_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)</span>
 
 		/* if we&#39;re overly short, let UDP handle it */
 		encap_rcv = ACCESS_ONCE(up-&gt;encap_rcv);
<span class="p_del">-		if (skb-&gt;len &gt; sizeof(struct udphdr) &amp;&amp; encap_rcv != NULL) {</span>
<span class="p_add">+		if (encap_rcv) {</span>
 			int ret;
 
 			/* Verify checksum before giving to encap */
<span class="p_header">diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c</span>
<span class="p_header">index 011a4c710c94..cd12b63faf10 100644</span>
<span class="p_header">--- a/net/ipv6/addrconf.c</span>
<span class="p_header">+++ b/net/ipv6/addrconf.c</span>
<span class="p_chunk">@@ -4837,8 +4837,7 @@</span> <span class="p_context"> static void addrconf_disable_change(struct net *net, __s32 newf)</span>
 	struct net_device *dev;
 	struct inet6_dev *idev;
 
<span class="p_del">-	rcu_read_lock();</span>
<span class="p_del">-	for_each_netdev_rcu(net, dev) {</span>
<span class="p_add">+	for_each_netdev(net, dev) {</span>
 		idev = __in6_dev_get(dev);
 		if (idev) {
 			int changed = (!idev-&gt;cnf.disable_ipv6) ^ (!newf);
<span class="p_chunk">@@ -4847,7 +4846,6 @@</span> <span class="p_context"> static void addrconf_disable_change(struct net *net, __s32 newf)</span>
 				dev_disable_change(idev);
 		}
 	}
<span class="p_del">-	rcu_read_unlock();</span>
 }
 
 static int addrconf_disable_ipv6(struct ctl_table *table, int *p, int newf)
<span class="p_header">diff --git a/net/ipv6/ip6_gre.c b/net/ipv6/ip6_gre.c</span>
<span class="p_header">index 42dd7c0c4283..f204efd21f50 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_gre.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_gre.c</span>
<span class="p_chunk">@@ -819,6 +819,9 @@</span> <span class="p_context"> static inline int ip6gre_xmit_ipv6(struct sk_buff *skb, struct net_device *dev)</span>
 		return -1;
 
 	offset = ip6_tnl_parse_tlv_enc_lim(skb, skb_network_header(skb));
<span class="p_add">+	/* ip6_tnl_parse_tlv_enc_lim() might have reallocated skb-&gt;head */</span>
<span class="p_add">+	ipv6h = ipv6_hdr(skb);</span>
<span class="p_add">+</span>
 	if (offset &gt; 0) {
 		struct ipv6_tlv_tnl_enc_lim *tel;
 		tel = (struct ipv6_tlv_tnl_enc_lim *)&amp;skb_network_header(skb)[offset];
<span class="p_header">diff --git a/net/ipv6/ip6_offload.c b/net/ipv6/ip6_offload.c</span>
<span class="p_header">index ef590d4e0171..f987e8a1282b 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_offload.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_offload.c</span>
<span class="p_chunk">@@ -219,6 +219,7 @@</span> <span class="p_context"> static struct sk_buff **ipv6_gro_receive(struct sk_buff **head,</span>
 	ops = rcu_dereference(inet6_offloads[proto]);
 	if (!ops || !ops-&gt;callbacks.gro_receive) {
 		__pskb_pull(skb, skb_gro_offset(skb));
<span class="p_add">+		skb_gro_frag0_invalidate(skb);</span>
 		proto = ipv6_gso_pull_exthdrs(skb, proto);
 		skb_gro_pull(skb, -skb_transport_offset(skb));
 		skb_reset_transport_header(skb);
<span class="p_header">diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c</span>
<span class="p_header">index cdd0bc79383a..7046af25d6be 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_output.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_output.c</span>
<span class="p_chunk">@@ -1031,17 +1031,12 @@</span> <span class="p_context"> struct dst_entry *ip6_sk_dst_lookup_flow(struct sock *sk, struct flowi6 *fl6,</span>
 					 const struct in6_addr *final_dst)
 {
 	struct dst_entry *dst = sk_dst_check(sk, inet6_sk(sk)-&gt;dst_cookie);
<span class="p_del">-	int err;</span>
 
 	dst = ip6_sk_dst_check(sk, dst, fl6);
<span class="p_add">+	if (!dst)</span>
<span class="p_add">+		dst = ip6_dst_lookup_flow(sk, fl6, final_dst);</span>
 
<span class="p_del">-	err = ip6_dst_lookup_tail(sk, &amp;dst, fl6);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		return ERR_PTR(err);</span>
<span class="p_del">-	if (final_dst)</span>
<span class="p_del">-		fl6-&gt;daddr = *final_dst;</span>
<span class="p_del">-</span>
<span class="p_del">-	return xfrm_lookup_route(sock_net(sk), dst, flowi6_to_flowi(fl6), sk, 0);</span>
<span class="p_add">+	return dst;</span>
 }
 EXPORT_SYMBOL_GPL(ip6_sk_dst_lookup_flow);
 
<span class="p_header">diff --git a/net/ipv6/ip6_tunnel.c b/net/ipv6/ip6_tunnel.c</span>
<span class="p_header">index e9399e5c1709..2879eb9a6049 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_tunnel.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_tunnel.c</span>
<span class="p_chunk">@@ -402,18 +402,19 @@</span> <span class="p_context"> ip6_tnl_dev_uninit(struct net_device *dev)</span>
 
 __u16 ip6_tnl_parse_tlv_enc_lim(struct sk_buff *skb, __u8 *raw)
 {
<span class="p_del">-	const struct ipv6hdr *ipv6h = (const struct ipv6hdr *) raw;</span>
<span class="p_del">-	__u8 nexthdr = ipv6h-&gt;nexthdr;</span>
<span class="p_del">-	__u16 off = sizeof (*ipv6h);</span>
<span class="p_add">+	const struct ipv6hdr *ipv6h = (const struct ipv6hdr *)raw;</span>
<span class="p_add">+	unsigned int nhoff = raw - skb-&gt;data;</span>
<span class="p_add">+	unsigned int off = nhoff + sizeof(*ipv6h);</span>
<span class="p_add">+	u8 next, nexthdr = ipv6h-&gt;nexthdr;</span>
 
 	while (ipv6_ext_hdr(nexthdr) &amp;&amp; nexthdr != NEXTHDR_NONE) {
<span class="p_del">-		__u16 optlen = 0;</span>
 		struct ipv6_opt_hdr *hdr;
<span class="p_del">-		if (raw + off + sizeof (*hdr) &gt; skb-&gt;data &amp;&amp;</span>
<span class="p_del">-		    !pskb_may_pull(skb, raw - skb-&gt;data + off + sizeof (*hdr)))</span>
<span class="p_add">+		u16 optlen;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!pskb_may_pull(skb, off + sizeof(*hdr)))</span>
 			break;
 
<span class="p_del">-		hdr = (struct ipv6_opt_hdr *) (raw + off);</span>
<span class="p_add">+		hdr = (struct ipv6_opt_hdr *)(skb-&gt;data + off);</span>
 		if (nexthdr == NEXTHDR_FRAGMENT) {
 			struct frag_hdr *frag_hdr = (struct frag_hdr *) hdr;
 			if (frag_hdr-&gt;frag_off)
<span class="p_chunk">@@ -424,20 +425,29 @@</span> <span class="p_context"> __u16 ip6_tnl_parse_tlv_enc_lim(struct sk_buff *skb, __u8 *raw)</span>
 		} else {
 			optlen = ipv6_optlen(hdr);
 		}
<span class="p_add">+		/* cache hdr-&gt;nexthdr, since pskb_may_pull() might</span>
<span class="p_add">+		 * invalidate hdr</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		next = hdr-&gt;nexthdr;</span>
 		if (nexthdr == NEXTHDR_DEST) {
<span class="p_del">-			__u16 i = off + 2;</span>
<span class="p_add">+			u16 i = 2;</span>
<span class="p_add">+</span>
<span class="p_add">+			/* Remember : hdr is no longer valid at this point. */</span>
<span class="p_add">+			if (!pskb_may_pull(skb, off + optlen))</span>
<span class="p_add">+				break;</span>
<span class="p_add">+</span>
 			while (1) {
 				struct ipv6_tlv_tnl_enc_lim *tel;
 
 				/* No more room for encapsulation limit */
<span class="p_del">-				if (i + sizeof (*tel) &gt; off + optlen)</span>
<span class="p_add">+				if (i + sizeof(*tel) &gt; optlen)</span>
 					break;
 
<span class="p_del">-				tel = (struct ipv6_tlv_tnl_enc_lim *) &amp;raw[i];</span>
<span class="p_add">+				tel = (struct ipv6_tlv_tnl_enc_lim *)(skb-&gt;data + off + i);</span>
 				/* return index of option if found and valid */
 				if (tel-&gt;type == IPV6_TLV_TNL_ENCAP_LIMIT &amp;&amp;
 				    tel-&gt;length == 1)
<span class="p_del">-					return i;</span>
<span class="p_add">+					return i + off - nhoff;</span>
 				/* else jump to next option */
 				if (tel-&gt;type)
 					i += tel-&gt;length + 2;
<span class="p_chunk">@@ -445,7 +455,7 @@</span> <span class="p_context"> __u16 ip6_tnl_parse_tlv_enc_lim(struct sk_buff *skb, __u8 *raw)</span>
 					i++;
 			}
 		}
<span class="p_del">-		nexthdr = hdr-&gt;nexthdr;</span>
<span class="p_add">+		nexthdr = next;</span>
 		off += optlen;
 	}
 	return 0;
<span class="p_chunk">@@ -958,12 +968,21 @@</span> <span class="p_context"> static int ip6_tnl_xmit2(struct sk_buff *skb,</span>
 	struct ipv6_tel_txoption opt;
 	struct dst_entry *dst = NULL, *ndst = NULL;
 	struct net_device *tdev;
<span class="p_add">+	bool use_cache = false;</span>
 	int mtu;
 	unsigned int max_headroom = sizeof(struct ipv6hdr);
 	u8 proto;
 	int err = -1;
 
<span class="p_del">-	if (!fl6-&gt;flowi6_mark)</span>
<span class="p_add">+	if (!(t-&gt;parms.flags &amp;</span>
<span class="p_add">+		     (IP6_TNL_F_USE_ORIG_TCLASS | IP6_TNL_F_USE_ORIG_FWMARK))) {</span>
<span class="p_add">+		/* enable the cache only only if the routing decision does</span>
<span class="p_add">+		 * not depend on the current inner header value</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		use_cache = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (use_cache)</span>
 		dst = ip6_tnl_dst_check(t);
 	if (!dst) {
 		ndst = ip6_route_output(net, NULL, fl6);
<span class="p_chunk">@@ -1021,7 +1040,7 @@</span> <span class="p_context"> static int ip6_tnl_xmit2(struct sk_buff *skb,</span>
 		consume_skb(skb);
 		skb = new_skb;
 	}
<span class="p_del">-	if (fl6-&gt;flowi6_mark) {</span>
<span class="p_add">+	if (!use_cache) {</span>
 		skb_dst_set(skb, dst);
 		ndst = NULL;
 	} else {
<span class="p_chunk">@@ -1118,6 +1137,8 @@</span> <span class="p_context"> ip6ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 		return -1;
 
 	offset = ip6_tnl_parse_tlv_enc_lim(skb, skb_network_header(skb));
<span class="p_add">+	/* ip6_tnl_parse_tlv_enc_lim() might have reallocated skb-&gt;head */</span>
<span class="p_add">+	ipv6h = ipv6_hdr(skb);</span>
 	if (offset &gt; 0) {
 		struct ipv6_tlv_tnl_enc_lim *tel;
 		tel = (struct ipv6_tlv_tnl_enc_lim *)&amp;skb_network_header(skb)[offset];
<span class="p_header">diff --git a/net/ipv6/ip6mr.c b/net/ipv6/ip6mr.c</span>
<span class="p_header">index 17049f81c750..6d2f7be65f4f 100644</span>
<span class="p_header">--- a/net/ipv6/ip6mr.c</span>
<span class="p_header">+++ b/net/ipv6/ip6mr.c</span>
<span class="p_chunk">@@ -1076,6 +1076,7 @@</span> <span class="p_context"> static struct mfc6_cache *ip6mr_cache_alloc(void)</span>
 	struct mfc6_cache *c = kmem_cache_zalloc(mrt_cachep, GFP_KERNEL);
 	if (c == NULL)
 		return NULL;
<span class="p_add">+	c-&gt;mfc_un.res.last_assert = jiffies - MFC_ASSERT_THRESH - 1;</span>
 	c-&gt;mfc_un.res.minvif = MAXMIFS;
 	return c;
 }
<span class="p_header">diff --git a/net/ipv6/mcast.c b/net/ipv6/mcast.c</span>
<span class="p_header">index ad84e7dec433..23575a0ac6f9 100644</span>
<span class="p_header">--- a/net/ipv6/mcast.c</span>
<span class="p_header">+++ b/net/ipv6/mcast.c</span>
<span class="p_chunk">@@ -93,7 +93,7 @@</span> <span class="p_context"> static void mld_gq_timer_expire(unsigned long data);</span>
 static void mld_ifc_timer_expire(unsigned long data);
 static void mld_ifc_event(struct inet6_dev *idev);
 static void mld_add_delrec(struct inet6_dev *idev, struct ifmcaddr6 *pmc);
<span class="p_del">-static void mld_del_delrec(struct inet6_dev *idev, const struct in6_addr *addr);</span>
<span class="p_add">+static void mld_del_delrec(struct inet6_dev *idev, struct ifmcaddr6 *pmc);</span>
 static void mld_clear_delrec(struct inet6_dev *idev);
 static bool mld_in_v1_mode(const struct inet6_dev *idev);
 static int sf_setstate(struct ifmcaddr6 *pmc);
<span class="p_chunk">@@ -727,9 +727,9 @@</span> <span class="p_context"> static void igmp6_group_dropped(struct ifmcaddr6 *mc)</span>
 			dev_mc_del(dev, buf);
 	}
 
<span class="p_del">-	if (mc-&gt;mca_flags &amp; MAF_NOREPORT)</span>
<span class="p_del">-		goto done;</span>
 	spin_unlock_bh(&amp;mc-&gt;mca_lock);
<span class="p_add">+	if (mc-&gt;mca_flags &amp; MAF_NOREPORT)</span>
<span class="p_add">+		return;</span>
 
 	if (!mc-&gt;idev-&gt;dead)
 		igmp6_leave_group(mc);
<span class="p_chunk">@@ -737,8 +737,6 @@</span> <span class="p_context"> static void igmp6_group_dropped(struct ifmcaddr6 *mc)</span>
 	spin_lock_bh(&amp;mc-&gt;mca_lock);
 	if (del_timer(&amp;mc-&gt;mca_timer))
 		atomic_dec(&amp;mc-&gt;mca_refcnt);
<span class="p_del">-done:</span>
<span class="p_del">-	ip6_mc_clear_src(mc);</span>
 	spin_unlock_bh(&amp;mc-&gt;mca_lock);
 }
 
<span class="p_chunk">@@ -783,10 +781,11 @@</span> <span class="p_context"> static void mld_add_delrec(struct inet6_dev *idev, struct ifmcaddr6 *im)</span>
 	spin_unlock_bh(&amp;idev-&gt;mc_lock);
 }
 
<span class="p_del">-static void mld_del_delrec(struct inet6_dev *idev, const struct in6_addr *pmca)</span>
<span class="p_add">+static void mld_del_delrec(struct inet6_dev *idev, struct ifmcaddr6 *im)</span>
 {
 	struct ifmcaddr6 *pmc, *pmc_prev;
<span class="p_del">-	struct ip6_sf_list *psf, *psf_next;</span>
<span class="p_add">+	struct ip6_sf_list *psf;</span>
<span class="p_add">+	struct in6_addr *pmca = &amp;im-&gt;mca_addr;</span>
 
 	spin_lock_bh(&amp;idev-&gt;mc_lock);
 	pmc_prev = NULL;
<span class="p_chunk">@@ -803,14 +802,21 @@</span> <span class="p_context"> static void mld_del_delrec(struct inet6_dev *idev, const struct in6_addr *pmca)</span>
 	}
 	spin_unlock_bh(&amp;idev-&gt;mc_lock);
 
<span class="p_add">+	spin_lock_bh(&amp;im-&gt;mca_lock);</span>
 	if (pmc) {
<span class="p_del">-		for (psf=pmc-&gt;mca_tomb; psf; psf=psf_next) {</span>
<span class="p_del">-			psf_next = psf-&gt;sf_next;</span>
<span class="p_del">-			kfree(psf);</span>
<span class="p_add">+		im-&gt;idev = pmc-&gt;idev;</span>
<span class="p_add">+		im-&gt;mca_crcount = idev-&gt;mc_qrv;</span>
<span class="p_add">+		im-&gt;mca_sfmode = pmc-&gt;mca_sfmode;</span>
<span class="p_add">+		if (pmc-&gt;mca_sfmode == MCAST_INCLUDE) {</span>
<span class="p_add">+			im-&gt;mca_tomb = pmc-&gt;mca_tomb;</span>
<span class="p_add">+			im-&gt;mca_sources = pmc-&gt;mca_sources;</span>
<span class="p_add">+			for (psf = im-&gt;mca_sources; psf; psf = psf-&gt;sf_next)</span>
<span class="p_add">+				psf-&gt;sf_crcount = im-&gt;mca_crcount;</span>
 		}
 		in6_dev_put(pmc-&gt;idev);
 		kfree(pmc);
 	}
<span class="p_add">+	spin_unlock_bh(&amp;im-&gt;mca_lock);</span>
 }
 
 static void mld_clear_delrec(struct inet6_dev *idev)
<span class="p_chunk">@@ -915,7 +921,7 @@</span> <span class="p_context"> int ipv6_dev_mc_inc(struct net_device *dev, const struct in6_addr *addr)</span>
 	idev-&gt;mc_list = mc;
 	write_unlock_bh(&amp;idev-&gt;lock);
 
<span class="p_del">-	mld_del_delrec(idev, &amp;mc-&gt;mca_addr);</span>
<span class="p_add">+	mld_del_delrec(idev, mc);</span>
 	igmp6_group_added(mc);
 	ma_put(mc);
 	return 0;
<span class="p_chunk">@@ -938,6 +944,7 @@</span> <span class="p_context"> int __ipv6_dev_mc_dec(struct inet6_dev *idev, const struct in6_addr *addr)</span>
 				write_unlock_bh(&amp;idev-&gt;lock);
 
 				igmp6_group_dropped(ma);
<span class="p_add">+				ip6_mc_clear_src(ma);</span>
 
 				ma_put(ma);
 				return 0;
<span class="p_chunk">@@ -2479,15 +2486,17 @@</span> <span class="p_context"> void ipv6_mc_down(struct inet6_dev *idev)</span>
 	/* Withdraw multicast list */
 
 	read_lock_bh(&amp;idev-&gt;lock);
<span class="p_del">-	mld_ifc_stop_timer(idev);</span>
<span class="p_del">-	mld_gq_stop_timer(idev);</span>
<span class="p_del">-	mld_dad_stop_timer(idev);</span>
 
 	for (i = idev-&gt;mc_list; i; i=i-&gt;next)
 		igmp6_group_dropped(i);
<span class="p_del">-	read_unlock_bh(&amp;idev-&gt;lock);</span>
 
<span class="p_del">-	mld_clear_delrec(idev);</span>
<span class="p_add">+	/* Should stop timer after group drop. or we will</span>
<span class="p_add">+	 * start timer again in mld_ifc_event()</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mld_ifc_stop_timer(idev);</span>
<span class="p_add">+	mld_gq_stop_timer(idev);</span>
<span class="p_add">+	mld_dad_stop_timer(idev);</span>
<span class="p_add">+	read_unlock_bh(&amp;idev-&gt;lock);</span>
 }
 
 
<span class="p_chunk">@@ -2500,8 +2509,10 @@</span> <span class="p_context"> void ipv6_mc_up(struct inet6_dev *idev)</span>
 	/* Install multicast list, except for all-nodes (already installed) */
 
 	read_lock_bh(&amp;idev-&gt;lock);
<span class="p_del">-	for (i = idev-&gt;mc_list; i; i=i-&gt;next)</span>
<span class="p_add">+	for (i = idev-&gt;mc_list; i; i = i-&gt;next) {</span>
<span class="p_add">+		mld_del_delrec(idev, i);</span>
 		igmp6_group_added(i);
<span class="p_add">+	}</span>
 	read_unlock_bh(&amp;idev-&gt;lock);
 }
 
<span class="p_chunk">@@ -2540,6 +2551,7 @@</span> <span class="p_context"> void ipv6_mc_destroy_dev(struct inet6_dev *idev)</span>
 
 	/* Deactivate timers */
 	ipv6_mc_down(idev);
<span class="p_add">+	mld_clear_delrec(idev);</span>
 
 	/* Delete all-nodes address. */
 	/* We cannot call ipv6_dev_mc_dec() directly, our caller in
<span class="p_chunk">@@ -2554,11 +2566,9 @@</span> <span class="p_context"> void ipv6_mc_destroy_dev(struct inet6_dev *idev)</span>
 	write_lock_bh(&amp;idev-&gt;lock);
 	while ((i = idev-&gt;mc_list) != NULL) {
 		idev-&gt;mc_list = i-&gt;next;
<span class="p_del">-		write_unlock_bh(&amp;idev-&gt;lock);</span>
 
<span class="p_del">-		igmp6_group_dropped(i);</span>
<span class="p_add">+		write_unlock_bh(&amp;idev-&gt;lock);</span>
 		ma_put(i);
<span class="p_del">-</span>
 		write_lock_bh(&amp;idev-&gt;lock);
 	}
 	write_unlock_bh(&amp;idev-&gt;lock);
<span class="p_header">diff --git a/net/ipv6/netfilter/ip6t_rpfilter.c b/net/ipv6/netfilter/ip6t_rpfilter.c</span>
<span class="p_header">index 790e0c6b19e1..a8af693b717d 100644</span>
<span class="p_header">--- a/net/ipv6/netfilter/ip6t_rpfilter.c</span>
<span class="p_header">+++ b/net/ipv6/netfilter/ip6t_rpfilter.c</span>
<span class="p_chunk">@@ -72,10 +72,10 @@</span> <span class="p_context"> static bool rpfilter_lookup_reverse6(const struct sk_buff *skb,</span>
 	return ret;
 }
 
<span class="p_del">-static bool rpfilter_is_local(const struct sk_buff *skb)</span>
<span class="p_add">+static bool</span>
<span class="p_add">+rpfilter_is_loopback(const struct sk_buff *skb, const struct net_device *in)</span>
 {
<span class="p_del">-	const struct rt6_info *rt = (const void *) skb_dst(skb);</span>
<span class="p_del">-	return rt &amp;&amp; (rt-&gt;rt6i_flags &amp; RTF_LOCAL);</span>
<span class="p_add">+	return skb-&gt;pkt_type == PACKET_LOOPBACK || in-&gt;flags &amp; IFF_LOOPBACK;</span>
 }
 
 static bool rpfilter_mt(const struct sk_buff *skb, struct xt_action_param *par)
<span class="p_chunk">@@ -85,7 +85,7 @@</span> <span class="p_context"> static bool rpfilter_mt(const struct sk_buff *skb, struct xt_action_param *par)</span>
 	struct ipv6hdr *iph;
 	bool invert = info-&gt;flags &amp; XT_RPFILTER_INVERT;
 
<span class="p_del">-	if (rpfilter_is_local(skb))</span>
<span class="p_add">+	if (rpfilter_is_loopback(skb, par-&gt;in))</span>
 		return true ^ invert;
 
 	iph = ipv6_hdr(skb);
<span class="p_header">diff --git a/net/ipv6/raw.c b/net/ipv6/raw.c</span>
<span class="p_header">index 1463757e8682..edff1d1c74cb 100644</span>
<span class="p_header">--- a/net/ipv6/raw.c</span>
<span class="p_header">+++ b/net/ipv6/raw.c</span>
<span class="p_chunk">@@ -588,8 +588,11 @@</span> <span class="p_context"> static int rawv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6,</span>
 	}
 
 	offset += skb_transport_offset(skb);
<span class="p_del">-	if (skb_copy_bits(skb, offset, &amp;csum, 2))</span>
<span class="p_del">-		BUG();</span>
<span class="p_add">+	err = skb_copy_bits(skb, offset, &amp;csum, 2);</span>
<span class="p_add">+	if (err &lt; 0) {</span>
<span class="p_add">+		ip6_flush_pending_frames(sk);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 	/* in case cksum was not initialized */
 	if (unlikely(csum))
<span class="p_header">diff --git a/net/ipv6/sit.c b/net/ipv6/sit.c</span>
<span class="p_header">index b5bdd2aeb2f8..96b442ea904a 100644</span>
<span class="p_header">--- a/net/ipv6/sit.c</span>
<span class="p_header">+++ b/net/ipv6/sit.c</span>
<span class="p_chunk">@@ -559,13 +559,13 @@</span> <span class="p_context"> static int ipip6_err(struct sk_buff *skb, u32 info)</span>
 
 	if (type == ICMP_DEST_UNREACH &amp;&amp; code == ICMP_FRAG_NEEDED) {
 		ipv4_update_pmtu(skb, dev_net(skb-&gt;dev), info,
<span class="p_del">-				 t-&gt;parms.link, 0, IPPROTO_IPV6, 0);</span>
<span class="p_add">+				 t-&gt;parms.link, 0, iph-&gt;protocol, 0);</span>
 		err = 0;
 		goto out;
 	}
 	if (type == ICMP_REDIRECT) {
 		ipv4_redirect(skb, dev_net(skb-&gt;dev), t-&gt;parms.link, 0,
<span class="p_del">-			      IPPROTO_IPV6, 0);</span>
<span class="p_add">+			      iph-&gt;protocol, 0);</span>
 		err = 0;
 		goto out;
 	}
<span class="p_chunk">@@ -1368,6 +1368,7 @@</span> <span class="p_context"> static int ipip6_tunnel_init(struct net_device *dev)</span>
 	tunnel-&gt;dst_cache = alloc_percpu(struct ip_tunnel_dst);
 	if (!tunnel-&gt;dst_cache) {
 		free_percpu(dev-&gt;tstats);
<span class="p_add">+		dev-&gt;tstats = NULL;</span>
 		return -ENOMEM;
 	}
 
<span class="p_header">diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c</span>
<span class="p_header">index 8eb38558e157..067011cff207 100644</span>
<span class="p_header">--- a/net/ipv6/udp.c</span>
<span class="p_header">+++ b/net/ipv6/udp.c</span>
<span class="p_chunk">@@ -631,7 +631,7 @@</span> <span class="p_context"> int udpv6_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)</span>
 
 		/* if we&#39;re overly short, let UDP handle it */
 		encap_rcv = ACCESS_ONCE(up-&gt;encap_rcv);
<span class="p_del">-		if (skb-&gt;len &gt; sizeof(struct udphdr) &amp;&amp; encap_rcv != NULL) {</span>
<span class="p_add">+		if (encap_rcv) {</span>
 			int ret;
 
 			/* Verify checksum before giving to encap */
<span class="p_header">diff --git a/net/irda/irqueue.c b/net/irda/irqueue.c</span>
<span class="p_header">index 7152624ed5f1..26ccd65cdcab 100644</span>
<span class="p_header">--- a/net/irda/irqueue.c</span>
<span class="p_header">+++ b/net/irda/irqueue.c</span>
<span class="p_chunk">@@ -385,9 +385,6 @@</span> <span class="p_context"> EXPORT_SYMBOL(hashbin_new);</span>
  *    for deallocating this structure if it&#39;s complex. If not the user can
  *    just supply kfree, which should take care of the job.
  */
<span class="p_del">-#ifdef CONFIG_LOCKDEP</span>
<span class="p_del">-static int hashbin_lock_depth = 0;</span>
<span class="p_del">-#endif</span>
 int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)
 {
 	irda_queue_t* queue;
<span class="p_chunk">@@ -398,22 +395,27 @@</span> <span class="p_context"> int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)</span>
 	IRDA_ASSERT(hashbin-&gt;magic == HB_MAGIC, return -1;);
 
 	/* Synchronize */
<span class="p_del">-	if ( hashbin-&gt;hb_type &amp; HB_LOCK ) {</span>
<span class="p_del">-		spin_lock_irqsave_nested(&amp;hashbin-&gt;hb_spinlock, flags,</span>
<span class="p_del">-					 hashbin_lock_depth++);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (hashbin-&gt;hb_type &amp; HB_LOCK)</span>
<span class="p_add">+		spin_lock_irqsave(&amp;hashbin-&gt;hb_spinlock, flags);</span>
 
 	/*
 	 *  Free the entries in the hashbin, TODO: use hashbin_clear when
 	 *  it has been shown to work
 	 */
 	for (i = 0; i &lt; HASHBIN_SIZE; i ++ ) {
<span class="p_del">-		queue = dequeue_first((irda_queue_t**) &amp;hashbin-&gt;hb_queue[i]);</span>
<span class="p_del">-		while (queue ) {</span>
<span class="p_del">-			if (free_func)</span>
<span class="p_del">-				(*free_func)(queue);</span>
<span class="p_del">-			queue = dequeue_first(</span>
<span class="p_del">-				(irda_queue_t**) &amp;hashbin-&gt;hb_queue[i]);</span>
<span class="p_add">+		while (1) {</span>
<span class="p_add">+			queue = dequeue_first((irda_queue_t**) &amp;hashbin-&gt;hb_queue[i]);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (!queue)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (free_func) {</span>
<span class="p_add">+				if (hashbin-&gt;hb_type &amp; HB_LOCK)</span>
<span class="p_add">+					spin_unlock_irqrestore(&amp;hashbin-&gt;hb_spinlock, flags);</span>
<span class="p_add">+				free_func(queue);</span>
<span class="p_add">+				if (hashbin-&gt;hb_type &amp; HB_LOCK)</span>
<span class="p_add">+					spin_lock_irqsave(&amp;hashbin-&gt;hb_spinlock, flags);</span>
<span class="p_add">+			}</span>
 		}
 	}
 
<span class="p_chunk">@@ -422,12 +424,8 @@</span> <span class="p_context"> int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)</span>
 	hashbin-&gt;magic = ~HB_MAGIC;
 
 	/* Release lock */
<span class="p_del">-	if ( hashbin-&gt;hb_type &amp; HB_LOCK) {</span>
<span class="p_add">+	if (hashbin-&gt;hb_type &amp; HB_LOCK)</span>
 		spin_unlock_irqrestore(&amp;hashbin-&gt;hb_spinlock, flags);
<span class="p_del">-#ifdef CONFIG_LOCKDEP</span>
<span class="p_del">-		hashbin_lock_depth--;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	}</span>
 
 	/*
 	 *  Free the hashbin structure
<span class="p_header">diff --git a/net/l2tp/l2tp_core.h b/net/l2tp/l2tp_core.h</span>
<span class="p_header">index 68aa9ffd4ae4..e9ec7d2cc357 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_core.h</span>
<span class="p_header">+++ b/net/l2tp/l2tp_core.h</span>
<span class="p_chunk">@@ -273,6 +273,7 @@</span> <span class="p_context"> int l2tp_xmit_skb(struct l2tp_session *session, struct sk_buff *skb,</span>
 int l2tp_nl_register_ops(enum l2tp_pwtype pw_type,
 			 const struct l2tp_nl_cmd_ops *ops);
 void l2tp_nl_unregister_ops(enum l2tp_pwtype pw_type);
<span class="p_add">+int l2tp_ioctl(struct sock *sk, int cmd, unsigned long arg);</span>
 
 /* Session reference counts. Incremented when code obtains a reference
  * to a session.
<span class="p_header">diff --git a/net/l2tp/l2tp_ip.c b/net/l2tp/l2tp_ip.c</span>
<span class="p_header">index 5d53249a2e84..5fc8b6899b90 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ip.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ip.c</span>
<span class="p_chunk">@@ -11,6 +11,7 @@</span> <span class="p_context"></span>
 
 #define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt
 
<span class="p_add">+#include &lt;asm/ioctls.h&gt;</span>
 #include &lt;linux/icmp.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/skbuff.h&gt;
<span class="p_chunk">@@ -555,6 +556,30 @@</span> <span class="p_context"> out:</span>
 	return err ? err : copied;
 }
 
<span class="p_add">+int l2tp_ioctl(struct sock *sk, int cmd, unsigned long arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sk_buff *skb;</span>
<span class="p_add">+	int amount;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (cmd) {</span>
<span class="p_add">+	case SIOCOUTQ:</span>
<span class="p_add">+		amount = sk_wmem_alloc_get(sk);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case SIOCINQ:</span>
<span class="p_add">+		spin_lock_bh(&amp;sk-&gt;sk_receive_queue.lock);</span>
<span class="p_add">+		skb = skb_peek(&amp;sk-&gt;sk_receive_queue);</span>
<span class="p_add">+		amount = skb ? skb-&gt;len : 0;</span>
<span class="p_add">+		spin_unlock_bh(&amp;sk-&gt;sk_receive_queue.lock);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return -ENOIOCTLCMD;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return put_user(amount, (int __user *)arg);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(l2tp_ioctl);</span>
<span class="p_add">+</span>
 static struct proto l2tp_ip_prot = {
 	.name		   = &quot;L2TP/IP&quot;,
 	.owner		   = THIS_MODULE,
<span class="p_chunk">@@ -563,7 +588,7 @@</span> <span class="p_context"> static struct proto l2tp_ip_prot = {</span>
 	.bind		   = l2tp_ip_bind,
 	.connect	   = l2tp_ip_connect,
 	.disconnect	   = l2tp_ip_disconnect,
<span class="p_del">-	.ioctl		   = udp_ioctl,</span>
<span class="p_add">+	.ioctl		   = l2tp_ioctl,</span>
 	.destroy	   = l2tp_ip_destroy_sock,
 	.setsockopt	   = ip_setsockopt,
 	.getsockopt	   = ip_getsockopt,
<span class="p_header">diff --git a/net/l2tp/l2tp_ip6.c b/net/l2tp/l2tp_ip6.c</span>
<span class="p_header">index a6e69677a6a1..0531450657d2 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ip6.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ip6.c</span>
<span class="p_chunk">@@ -716,7 +716,7 @@</span> <span class="p_context"> static struct proto l2tp_ip6_prot = {</span>
 	.bind		   = l2tp_ip6_bind,
 	.connect	   = l2tp_ip6_connect,
 	.disconnect	   = l2tp_ip6_disconnect,
<span class="p_del">-	.ioctl		   = udp_ioctl,</span>
<span class="p_add">+	.ioctl		   = l2tp_ioctl,</span>
 	.destroy	   = l2tp_ip6_destroy_sock,
 	.setsockopt	   = ipv6_setsockopt,
 	.getsockopt	   = ipv6_getsockopt,
<span class="p_header">diff --git a/net/llc/llc_conn.c b/net/llc/llc_conn.c</span>
<span class="p_header">index 42dc2e45c921..9c68d0bca046 100644</span>
<span class="p_header">--- a/net/llc/llc_conn.c</span>
<span class="p_header">+++ b/net/llc/llc_conn.c</span>
<span class="p_chunk">@@ -821,7 +821,10 @@</span> <span class="p_context"> void llc_conn_handler(struct llc_sap *sap, struct sk_buff *skb)</span>
 		 * another trick required to cope with how the PROCOM state
 		 * machine works. -acme
 		 */
<span class="p_add">+		skb_orphan(skb);</span>
<span class="p_add">+		sock_hold(sk);</span>
 		skb-&gt;sk = sk;
<span class="p_add">+		skb-&gt;destructor = sock_efree;</span>
 	}
 	if (!sock_owned_by_user(sk))
 		llc_conn_rcv(sk, skb);
<span class="p_header">diff --git a/net/llc/llc_sap.c b/net/llc/llc_sap.c</span>
<span class="p_header">index 06033f6c845f..cdc1b620cbe1 100644</span>
<span class="p_header">--- a/net/llc/llc_sap.c</span>
<span class="p_header">+++ b/net/llc/llc_sap.c</span>
<span class="p_chunk">@@ -290,7 +290,10 @@</span> <span class="p_context"> static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,</span>
 
 	ev-&gt;type   = LLC_SAP_EV_TYPE_PDU;
 	ev-&gt;reason = 0;
<span class="p_add">+	skb_orphan(skb);</span>
<span class="p_add">+	sock_hold(sk);</span>
 	skb-&gt;sk = sk;
<span class="p_add">+	skb-&gt;destructor = sock_efree;</span>
 	llc_sap_state_process(sap, skb);
 }
 
<span class="p_header">diff --git a/net/mac80211/mesh.c b/net/mac80211/mesh.c</span>
<span class="p_header">index 27b5b3b43744..58f5f34a7af1 100644</span>
<span class="p_header">--- a/net/mac80211/mesh.c</span>
<span class="p_header">+++ b/net/mac80211/mesh.c</span>
<span class="p_chunk">@@ -352,7 +352,7 @@</span> <span class="p_context"> int mesh_add_vendor_ies(struct ieee80211_sub_if_data *sdata,</span>
 	/* fast-forward to vendor IEs */
 	offset = ieee80211_ie_split_vendor(ifmsh-&gt;ie, ifmsh-&gt;ie_len, 0);
 
<span class="p_del">-	if (offset) {</span>
<span class="p_add">+	if (offset &lt; ifmsh-&gt;ie_len) {</span>
 		len = ifmsh-&gt;ie_len - offset;
 		data = ifmsh-&gt;ie + offset;
 		if (skb_tailroom(skb) &lt; len)
<span class="p_header">diff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c</span>
<span class="p_header">index ff3dac855100..58fab5951b22 100644</span>
<span class="p_header">--- a/net/mac80211/mlme.c</span>
<span class="p_header">+++ b/net/mac80211/mlme.c</span>
<span class="p_chunk">@@ -2458,7 +2458,7 @@</span> <span class="p_context"> static void ieee80211_get_rates(struct ieee80211_supported_band *sband,</span>
 }
 
 static void ieee80211_destroy_assoc_data(struct ieee80211_sub_if_data *sdata,
<span class="p_del">-					 bool assoc)</span>
<span class="p_add">+					 bool assoc, bool abandon)</span>
 {
 	struct ieee80211_mgd_assoc_data *assoc_data = sdata-&gt;u.mgd.assoc_data;
 
<span class="p_chunk">@@ -2473,6 +2473,9 @@</span> <span class="p_context"> static void ieee80211_destroy_assoc_data(struct ieee80211_sub_if_data *sdata,</span>
 		mutex_lock(&amp;sdata-&gt;local-&gt;mtx);
 		ieee80211_vif_release_channel(sdata);
 		mutex_unlock(&amp;sdata-&gt;local-&gt;mtx);
<span class="p_add">+</span>
<span class="p_add">+		if (abandon)</span>
<span class="p_add">+			cfg80211_abandon_assoc(sdata-&gt;dev, assoc_data-&gt;bss);</span>
 	}
 
 	kfree(assoc_data);
<span class="p_chunk">@@ -2779,11 +2782,11 @@</span> <span class="p_context"> static void ieee80211_rx_mgmt_assoc_resp(struct ieee80211_sub_if_data *sdata,</span>
 	if (status_code != WLAN_STATUS_SUCCESS) {
 		sdata_info(sdata, &quot;%pM denied association (code=%d)\n&quot;,
 			   mgmt-&gt;sa, status_code);
<span class="p_del">-		ieee80211_destroy_assoc_data(sdata, false);</span>
<span class="p_add">+		ieee80211_destroy_assoc_data(sdata, false, false);</span>
 	} else {
 		if (!ieee80211_assoc_success(sdata, bss, mgmt, len)) {
 			/* oops -- internal error -- send timeout for now */
<span class="p_del">-			ieee80211_destroy_assoc_data(sdata, false);</span>
<span class="p_add">+			ieee80211_destroy_assoc_data(sdata, false, false);</span>
 			cfg80211_assoc_timeout(sdata-&gt;dev, bss);
 			return;
 		}
<span class="p_chunk">@@ -2794,7 +2797,7 @@</span> <span class="p_context"> static void ieee80211_rx_mgmt_assoc_resp(struct ieee80211_sub_if_data *sdata,</span>
 		 * recalc after assoc_data is NULL but before associated
 		 * is set can cause the interface to go idle
 		 */
<span class="p_del">-		ieee80211_destroy_assoc_data(sdata, true);</span>
<span class="p_add">+		ieee80211_destroy_assoc_data(sdata, true, false);</span>
 	}
 
 	cfg80211_rx_assoc_resp(sdata-&gt;dev, bss, (u8 *)mgmt, len);
<span class="p_chunk">@@ -3491,7 +3494,7 @@</span> <span class="p_context"> void ieee80211_sta_work(struct ieee80211_sub_if_data *sdata)</span>
 		    ieee80211_do_assoc(sdata)) {
 			struct cfg80211_bss *bss = ifmgd-&gt;assoc_data-&gt;bss;
 
<span class="p_del">-			ieee80211_destroy_assoc_data(sdata, false);</span>
<span class="p_add">+			ieee80211_destroy_assoc_data(sdata, false, false);</span>
 			cfg80211_assoc_timeout(sdata-&gt;dev, bss);
 		}
 	} else if (ifmgd-&gt;assoc_data &amp;&amp; ifmgd-&gt;assoc_data-&gt;timeout_started)
<span class="p_chunk">@@ -3640,7 +3643,7 @@</span> <span class="p_context"> void ieee80211_mgd_quiesce(struct ieee80211_sub_if_data *sdata)</span>
 					       WLAN_REASON_DEAUTH_LEAVING,
 					       false, frame_buf);
 		if (ifmgd-&gt;assoc_data)
<span class="p_del">-			ieee80211_destroy_assoc_data(sdata, false);</span>
<span class="p_add">+			ieee80211_destroy_assoc_data(sdata, false, true);</span>
 		if (ifmgd-&gt;auth_data)
 			ieee80211_destroy_auth_data(sdata, false);
 		cfg80211_tx_mlme_mgmt(sdata-&gt;dev, frame_buf,
<span class="p_chunk">@@ -4553,7 +4556,7 @@</span> <span class="p_context"> void ieee80211_mgd_stop(struct ieee80211_sub_if_data *sdata)</span>
 	sdata_lock(sdata);
 	if (ifmgd-&gt;assoc_data) {
 		struct cfg80211_bss *bss = ifmgd-&gt;assoc_data-&gt;bss;
<span class="p_del">-		ieee80211_destroy_assoc_data(sdata, false);</span>
<span class="p_add">+		ieee80211_destroy_assoc_data(sdata, false, false);</span>
 		cfg80211_assoc_timeout(sdata-&gt;dev, bss);
 	}
 	if (ifmgd-&gt;auth_data)
<span class="p_header">diff --git a/net/netfilter/nf_log.c b/net/netfilter/nf_log.c</span>
<span class="p_header">index 85296d4eac0e..4e6245f09ee4 100644</span>
<span class="p_header">--- a/net/netfilter/nf_log.c</span>
<span class="p_header">+++ b/net/netfilter/nf_log.c</span>
<span class="p_chunk">@@ -13,7 +13,6 @@</span> <span class="p_context"></span>
 /* Internal logging interface, which relies on the real
    LOG target modules */
 
<span class="p_del">-#define NF_LOG_PREFIXLEN		128</span>
 #define NFLOGGER_NAME_LEN		64
 
 static struct list_head nf_loggers_l[NFPROTO_NUMPROTO] __read_mostly;
<span class="p_header">diff --git a/net/netfilter/nft_log.c b/net/netfilter/nft_log.c</span>
<span class="p_header">index 10cfb156cdf4..8c24270e08e1 100644</span>
<span class="p_header">--- a/net/netfilter/nft_log.c</span>
<span class="p_header">+++ b/net/netfilter/nft_log.c</span>
<span class="p_chunk">@@ -38,7 +38,8 @@</span> <span class="p_context"> static void nft_log_eval(const struct nft_expr *expr,</span>
 
 static const struct nla_policy nft_log_policy[NFTA_LOG_MAX + 1] = {
 	[NFTA_LOG_GROUP]	= { .type = NLA_U16 },
<span class="p_del">-	[NFTA_LOG_PREFIX]	= { .type = NLA_STRING },</span>
<span class="p_add">+	[NFTA_LOG_PREFIX]	= { .type = NLA_STRING,</span>
<span class="p_add">+				    .len = NF_LOG_PREFIXLEN - 1 },</span>
 	[NFTA_LOG_SNAPLEN]	= { .type = NLA_U32 },
 	[NFTA_LOG_QTHRESHOLD]	= { .type = NLA_U16 },
 };
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index 062624c1be7e..193eac992814 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -1402,6 +1402,8 @@</span> <span class="p_context"> static void __fanout_link(struct sock *sk, struct packet_sock *po)</span>
 	f-&gt;arr[f-&gt;num_members] = sk;
 	smp_wmb();
 	f-&gt;num_members++;
<span class="p_add">+	if (f-&gt;num_members == 1)</span>
<span class="p_add">+		dev_add_pack(&amp;f-&gt;prot_hook);</span>
 	spin_unlock(&amp;f-&gt;lock);
 }
 
<span class="p_chunk">@@ -1418,6 +1420,8 @@</span> <span class="p_context"> static void __fanout_unlink(struct sock *sk, struct packet_sock *po)</span>
 	BUG_ON(i &gt;= f-&gt;num_members);
 	f-&gt;arr[i] = f-&gt;arr[f-&gt;num_members - 1];
 	f-&gt;num_members--;
<span class="p_add">+	if (f-&gt;num_members == 0)</span>
<span class="p_add">+		__dev_remove_pack(&amp;f-&gt;prot_hook);</span>
 	spin_unlock(&amp;f-&gt;lock);
 }
 
<span class="p_chunk">@@ -1451,13 +1455,16 @@</span> <span class="p_context"> static int fanout_add(struct sock *sk, u16 id, u16 type_flags)</span>
 		return -EINVAL;
 	}
 
<span class="p_add">+	mutex_lock(&amp;fanout_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = -EINVAL;</span>
 	if (!po-&gt;running)
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		goto out;</span>
 
<span class="p_add">+	err = -EALREADY;</span>
 	if (po-&gt;fanout)
<span class="p_del">-		return -EALREADY;</span>
<span class="p_add">+		goto out;</span>
 
<span class="p_del">-	mutex_lock(&amp;fanout_mutex);</span>
 	match = NULL;
 	list_for_each_entry(f, &amp;fanout_list, list) {
 		if (f-&gt;id == id &amp;&amp;
<span class="p_chunk">@@ -1487,7 +1494,6 @@</span> <span class="p_context"> static int fanout_add(struct sock *sk, u16 id, u16 type_flags)</span>
 		match-&gt;prot_hook.func = packet_rcv_fanout;
 		match-&gt;prot_hook.af_packet_priv = match;
 		match-&gt;prot_hook.id_match = match_fanout_group;
<span class="p_del">-		dev_add_pack(&amp;match-&gt;prot_hook);</span>
 		list_add(&amp;match-&gt;list, &amp;fanout_list);
 	}
 	err = -EINVAL;
<span class="p_chunk">@@ -1508,24 +1514,29 @@</span> <span class="p_context"> out:</span>
 	return err;
 }
 
<span class="p_del">-static void fanout_release(struct sock *sk)</span>
<span class="p_add">+/* If pkt_sk(sk)-&gt;fanout-&gt;sk_ref is zero, this function removes</span>
<span class="p_add">+ * pkt_sk(sk)-&gt;fanout from fanout_list and returns pkt_sk(sk)-&gt;fanout.</span>
<span class="p_add">+ * It is the responsibility of the caller to call fanout_release_data() and</span>
<span class="p_add">+ * free the returned packet_fanout (after synchronize_net())</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct packet_fanout *fanout_release(struct sock *sk)</span>
 {
 	struct packet_sock *po = pkt_sk(sk);
 	struct packet_fanout *f;
 
<span class="p_del">-	f = po-&gt;fanout;</span>
<span class="p_del">-	if (!f)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	mutex_lock(&amp;fanout_mutex);
<span class="p_del">-	po-&gt;fanout = NULL;</span>
<span class="p_add">+	f = po-&gt;fanout;</span>
<span class="p_add">+	if (f) {</span>
<span class="p_add">+		po-&gt;fanout = NULL;</span>
 
<span class="p_del">-	if (atomic_dec_and_test(&amp;f-&gt;sk_ref)) {</span>
<span class="p_del">-		list_del(&amp;f-&gt;list);</span>
<span class="p_del">-		dev_remove_pack(&amp;f-&gt;prot_hook);</span>
<span class="p_del">-		kfree(f);</span>
<span class="p_add">+		if (atomic_dec_and_test(&amp;f-&gt;sk_ref))</span>
<span class="p_add">+			list_del(&amp;f-&gt;list);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			f = NULL;</span>
 	}
 	mutex_unlock(&amp;fanout_mutex);
<span class="p_add">+</span>
<span class="p_add">+	return f;</span>
 }
 
 static bool packet_extra_vlan_len_allowed(const struct net_device *dev,
<span class="p_chunk">@@ -2604,6 +2615,7 @@</span> <span class="p_context"> static int packet_release(struct socket *sock)</span>
 {
 	struct sock *sk = sock-&gt;sk;
 	struct packet_sock *po;
<span class="p_add">+	struct packet_fanout *f;</span>
 	struct net *net;
 	union tpacket_req_u req_u;
 
<span class="p_chunk">@@ -2643,9 +2655,12 @@</span> <span class="p_context"> static int packet_release(struct socket *sock)</span>
 		packet_set_ring(sk, &amp;req_u, 1, 1);
 	}
 
<span class="p_del">-	fanout_release(sk);</span>
<span class="p_add">+	f = fanout_release(sk);</span>
 
 	synchronize_net();
<span class="p_add">+</span>
<span class="p_add">+	kfree(f);</span>
<span class="p_add">+</span>
 	/*
 	 *	Now the socket is dead. No more input will appear.
 	 */
<span class="p_header">diff --git a/net/sched/act_pedit.c b/net/sched/act_pedit.c</span>
<span class="p_header">index 27662e19c3bd..8f357a6eb150 100644</span>
<span class="p_header">--- a/net/sched/act_pedit.c</span>
<span class="p_header">+++ b/net/sched/act_pedit.c</span>
<span class="p_chunk">@@ -103,6 +103,17 @@</span> <span class="p_context"> static void tcf_pedit_cleanup(struct tc_action *a, int bind)</span>
 	kfree(keys);
 }
 
<span class="p_add">+static bool offset_valid(struct sk_buff *skb, int offset)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (offset &gt; 0 &amp;&amp; offset &gt; skb-&gt;len)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	if  (offset &lt; 0 &amp;&amp; -offset &gt; skb_headroom(skb))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int tcf_pedit(struct sk_buff *skb, const struct tc_action *a,
 		     struct tcf_result *res)
 {
<span class="p_chunk">@@ -129,6 +140,11 @@</span> <span class="p_context"> static int tcf_pedit(struct sk_buff *skb, const struct tc_action *a,</span>
 			if (tkey-&gt;offmask) {
 				char *d, _d;
 
<span class="p_add">+				if (!offset_valid(skb, off + tkey-&gt;at)) {</span>
<span class="p_add">+					pr_info(&quot;tc filter pedit &#39;at&#39; offset %d out of bounds\n&quot;,</span>
<span class="p_add">+						off + tkey-&gt;at);</span>
<span class="p_add">+					goto bad;</span>
<span class="p_add">+				}</span>
 				d = skb_header_pointer(skb, off + tkey-&gt;at, 1,
 						       &amp;_d);
 				if (!d)
<span class="p_chunk">@@ -141,10 +157,10 @@</span> <span class="p_context"> static int tcf_pedit(struct sk_buff *skb, const struct tc_action *a,</span>
 					&quot; offset must be on 32 bit boundaries\n&quot;);
 				goto bad;
 			}
<span class="p_del">-			if (offset &gt; 0 &amp;&amp; offset &gt; skb-&gt;len) {</span>
<span class="p_del">-				pr_info(&quot;tc filter pedit&quot;</span>
<span class="p_del">-					&quot; offset %d can&#39;t exceed pkt length %d\n&quot;,</span>
<span class="p_del">-				       offset, skb-&gt;len);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (!offset_valid(skb, off + offset)) {</span>
<span class="p_add">+				pr_info(&quot;tc filter pedit offset %d out of bounds\n&quot;,</span>
<span class="p_add">+					offset);</span>
 				goto bad;
 			}
 
<span class="p_header">diff --git a/net/sched/cls_api.c b/net/sched/cls_api.c</span>
<span class="p_header">index 3b2617aa6bcd..7e4e15075c81 100644</span>
<span class="p_header">--- a/net/sched/cls_api.c</span>
<span class="p_header">+++ b/net/sched/cls_api.c</span>
<span class="p_chunk">@@ -132,13 +132,15 @@</span> <span class="p_context"> static int tc_ctl_tfilter(struct sk_buff *skb, struct nlmsghdr *n)</span>
 	unsigned long cl;
 	unsigned long fh;
 	int err;
<span class="p_del">-	int tp_created = 0;</span>
<span class="p_add">+	int tp_created;</span>
 
 	if ((n-&gt;nlmsg_type != RTM_GETTFILTER) &amp;&amp;
 	    !netlink_ns_capable(skb, net-&gt;user_ns, CAP_NET_ADMIN))
 		return -EPERM;
 
 replay:
<span class="p_add">+	tp_created = 0;</span>
<span class="p_add">+</span>
 	err = nlmsg_parse(n, sizeof(*t), tca, TCA_MAX, NULL);
 	if (err &lt; 0)
 		return err;
<span class="p_header">diff --git a/net/sched/em_meta.c b/net/sched/em_meta.c</span>
<span class="p_header">index 9b8c0b0e60d7..386b2971df1b 100644</span>
<span class="p_header">--- a/net/sched/em_meta.c</span>
<span class="p_header">+++ b/net/sched/em_meta.c</span>
<span class="p_chunk">@@ -176,11 +176,12 @@</span> <span class="p_context"> META_COLLECTOR(int_vlan_tag)</span>
 {
 	unsigned short tag;
 
<span class="p_del">-	tag = vlan_tx_tag_get(skb);</span>
<span class="p_del">-	if (!tag &amp;&amp; __vlan_get_tag(skb, &amp;tag))</span>
<span class="p_del">-		*err = -1;</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (vlan_tx_tag_present(skb))</span>
<span class="p_add">+		dst-&gt;value = vlan_tx_tag_get(skb);</span>
<span class="p_add">+	else if (!__vlan_get_tag(skb, &amp;tag))</span>
 		dst-&gt;value = tag;
<span class="p_add">+	else</span>
<span class="p_add">+		*err = -1;</span>
 }
 
 
<span class="p_header">diff --git a/net/sched/sch_dsmark.c b/net/sched/sch_dsmark.c</span>
<span class="p_header">index 5b766242af94..5d8180269dc9 100644</span>
<span class="p_header">--- a/net/sched/sch_dsmark.c</span>
<span class="p_header">+++ b/net/sched/sch_dsmark.c</span>
<span class="p_chunk">@@ -255,6 +255,7 @@</span> <span class="p_context"> static int dsmark_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 		return err;
 	}
 
<span class="p_add">+	sch-&gt;qstats.backlog += qdisc_pkt_len(skb);</span>
 	sch-&gt;q.qlen++;
 
 	return NET_XMIT_SUCCESS;
<span class="p_chunk">@@ -277,6 +278,7 @@</span> <span class="p_context"> static struct sk_buff *dsmark_dequeue(struct Qdisc *sch)</span>
 		return NULL;
 
 	qdisc_bstats_update(sch, skb);
<span class="p_add">+	sch-&gt;qstats.backlog -= qdisc_pkt_len(skb);</span>
 	sch-&gt;q.qlen--;
 
 	index = skb-&gt;tc_index &amp; (p-&gt;indices - 1);
<span class="p_chunk">@@ -392,6 +394,7 @@</span> <span class="p_context"> static void dsmark_reset(struct Qdisc *sch)</span>
 
 	pr_debug(&quot;%s(sch %p,[qdisc %p])\n&quot;, __func__, sch, p);
 	qdisc_reset(p-&gt;q);
<span class="p_add">+	sch-&gt;qstats.backlog = 0;</span>
 	sch-&gt;q.qlen = 0;
 }
 
<span class="p_header">diff --git a/net/sched/sch_htb.c b/net/sched/sch_htb.c</span>
<span class="p_header">index 718b015da5c3..b169a8a05a5d 100644</span>
<span class="p_header">--- a/net/sched/sch_htb.c</span>
<span class="p_header">+++ b/net/sched/sch_htb.c</span>
<span class="p_chunk">@@ -600,6 +600,7 @@</span> <span class="p_context"> static int htb_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 		htb_activate(q, cl);
 	}
 
<span class="p_add">+	sch-&gt;qstats.backlog += qdisc_pkt_len(skb);</span>
 	sch-&gt;q.qlen++;
 	return NET_XMIT_SUCCESS;
 }
<span class="p_chunk">@@ -889,6 +890,7 @@</span> <span class="p_context"> static struct sk_buff *htb_dequeue(struct Qdisc *sch)</span>
 ok:
 		qdisc_bstats_update(sch, skb);
 		qdisc_unthrottled(sch);
<span class="p_add">+		sch-&gt;qstats.backlog -= qdisc_pkt_len(skb);</span>
 		sch-&gt;q.qlen--;
 		return skb;
 	}
<span class="p_chunk">@@ -955,6 +957,7 @@</span> <span class="p_context"> static unsigned int htb_drop(struct Qdisc *sch)</span>
 			unsigned int len;
 			if (cl-&gt;un.leaf.q-&gt;ops-&gt;drop &amp;&amp;
 			    (len = cl-&gt;un.leaf.q-&gt;ops-&gt;drop(cl-&gt;un.leaf.q))) {
<span class="p_add">+				sch-&gt;qstats.backlog -= len;</span>
 				sch-&gt;q.qlen--;
 				if (!cl-&gt;un.leaf.q-&gt;q.qlen)
 					htb_deactivate(q, cl);
<span class="p_chunk">@@ -984,12 +987,12 @@</span> <span class="p_context"> static void htb_reset(struct Qdisc *sch)</span>
 			}
 			cl-&gt;prio_activity = 0;
 			cl-&gt;cmode = HTB_CAN_SEND;
<span class="p_del">-</span>
 		}
 	}
 	qdisc_watchdog_cancel(&amp;q-&gt;watchdog);
 	__skb_queue_purge(&amp;q-&gt;direct_queue);
 	sch-&gt;q.qlen = 0;
<span class="p_add">+	sch-&gt;qstats.backlog = 0;</span>
 	memset(q-&gt;hlevel, 0, sizeof(q-&gt;hlevel));
 	memset(q-&gt;row_mask, 0, sizeof(q-&gt;row_mask));
 	for (i = 0; i &lt; TC_HTB_NUMPRIO; i++)
<span class="p_header">diff --git a/net/sched/sch_netem.c b/net/sched/sch_netem.c</span>
<span class="p_header">index 73f1db8e8039..aa9e07816feb 100644</span>
<span class="p_header">--- a/net/sched/sch_netem.c</span>
<span class="p_header">+++ b/net/sched/sch_netem.c</span>
<span class="p_chunk">@@ -408,6 +408,25 @@</span> <span class="p_context"> static void tfifo_enqueue(struct sk_buff *nskb, struct Qdisc *sch)</span>
 	sch-&gt;q.qlen++;
 }
 
<span class="p_add">+/* netem can&#39;t properly corrupt a megapacket (like we get from GSO), so instead</span>
<span class="p_add">+ * when we statistically choose to corrupt one, we instead segment it, returning</span>
<span class="p_add">+ * the first packet to be corrupted, and re-enqueue the remaining frames</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct sk_buff *netem_segment(struct sk_buff *skb, struct Qdisc *sch)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sk_buff *segs;</span>
<span class="p_add">+	netdev_features_t features = netif_skb_features(skb);</span>
<span class="p_add">+</span>
<span class="p_add">+	segs = skb_gso_segment(skb, features &amp; ~NETIF_F_GSO_MASK);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_ERR_OR_NULL(segs)) {</span>
<span class="p_add">+		qdisc_reshape_fail(skb, sch);</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	consume_skb(skb);</span>
<span class="p_add">+	return segs;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Insert one skb into qdisc.
  * Note: parent depends on return value to account for queue length.
<span class="p_chunk">@@ -420,7 +439,11 @@</span> <span class="p_context"> static int netem_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 	/* We don&#39;t fill cb now as skb_unshare() may invalidate it */
 	struct netem_skb_cb *cb;
 	struct sk_buff *skb2;
<span class="p_add">+	struct sk_buff *segs = NULL;</span>
<span class="p_add">+	unsigned int len = 0, last_len, prev_len = qdisc_pkt_len(skb);</span>
<span class="p_add">+	int nb = 0;</span>
 	int count = 1;
<span class="p_add">+	int rc = NET_XMIT_SUCCESS;</span>
 
 	/* Random duplication */
 	if (q-&gt;duplicate &amp;&amp; q-&gt;duplicate &gt;= get_crandom(&amp;q-&gt;dup_cor))
<span class="p_chunk">@@ -466,10 +489,23 @@</span> <span class="p_context"> static int netem_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 	 * do it now in software before we mangle it.
 	 */
 	if (q-&gt;corrupt &amp;&amp; q-&gt;corrupt &gt;= get_crandom(&amp;q-&gt;corrupt_cor)) {
<span class="p_add">+		if (skb_is_gso(skb)) {</span>
<span class="p_add">+			segs = netem_segment(skb, sch);</span>
<span class="p_add">+			if (!segs)</span>
<span class="p_add">+				return NET_XMIT_DROP;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			segs = skb;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		skb = segs;</span>
<span class="p_add">+		segs = segs-&gt;next;</span>
<span class="p_add">+</span>
 		if (!(skb = skb_unshare(skb, GFP_ATOMIC)) ||
 		    (skb-&gt;ip_summed == CHECKSUM_PARTIAL &amp;&amp;
<span class="p_del">-		     skb_checksum_help(skb)))</span>
<span class="p_del">-			return qdisc_drop(skb, sch);</span>
<span class="p_add">+		     skb_checksum_help(skb))) {</span>
<span class="p_add">+			rc = qdisc_drop(skb, sch);</span>
<span class="p_add">+			goto finish_segs;</span>
<span class="p_add">+		}</span>
 
 		skb-&gt;data[prandom_u32() % skb_headlen(skb)] ^=
 			1&lt;&lt;(prandom_u32() % 8);
<span class="p_chunk">@@ -529,6 +565,27 @@</span> <span class="p_context"> static int netem_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 		sch-&gt;qstats.requeues++;
 	}
 
<span class="p_add">+finish_segs:</span>
<span class="p_add">+	if (segs) {</span>
<span class="p_add">+		while (segs) {</span>
<span class="p_add">+			skb2 = segs-&gt;next;</span>
<span class="p_add">+			segs-&gt;next = NULL;</span>
<span class="p_add">+			qdisc_skb_cb(segs)-&gt;pkt_len = segs-&gt;len;</span>
<span class="p_add">+			last_len = segs-&gt;len;</span>
<span class="p_add">+			rc = qdisc_enqueue(segs, sch);</span>
<span class="p_add">+			if (rc != NET_XMIT_SUCCESS) {</span>
<span class="p_add">+				if (net_xmit_drop_count(rc))</span>
<span class="p_add">+					sch-&gt;qstats.drops++;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				nb++;</span>
<span class="p_add">+				len += last_len;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			segs = skb2;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		sch-&gt;q.qlen += nb;</span>
<span class="p_add">+		if (nb &gt; 1)</span>
<span class="p_add">+			qdisc_tree_reduce_backlog(sch, 1 - nb, prev_len - len);</span>
<span class="p_add">+	}</span>
 	return NET_XMIT_SUCCESS;
 }
 
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index adfb4b58831f..ad0292262581 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -1217,9 +1217,12 @@</span> <span class="p_context"> static int __sctp_connect(struct sock *sk,</span>
 
 	timeo = sock_sndtimeo(sk, f_flags &amp; O_NONBLOCK);
 
<span class="p_del">-	err = sctp_wait_for_connect(asoc, &amp;timeo);</span>
<span class="p_del">-	if ((err == 0 || err == -EINPROGRESS) &amp;&amp; assoc_id)</span>
<span class="p_add">+	if (assoc_id)</span>
 		*assoc_id = asoc-&gt;assoc_id;
<span class="p_add">+	err = sctp_wait_for_connect(asoc, &amp;timeo);</span>
<span class="p_add">+	/* Note: the asoc may be freed after the return of</span>
<span class="p_add">+	 * sctp_wait_for_connect.</span>
<span class="p_add">+	 */</span>
 
 	/* Don&#39;t free association on exit. */
 	asoc = NULL;
<span class="p_chunk">@@ -4280,7 +4283,7 @@</span> <span class="p_context"> static int sctp_getsockopt_disable_fragments(struct sock *sk, int len,</span>
 static int sctp_getsockopt_events(struct sock *sk, int len, char __user *optval,
 				  int __user *optlen)
 {
<span class="p_del">-	if (len &lt;= 0)</span>
<span class="p_add">+	if (len == 0)</span>
 		return -EINVAL;
 	if (len &gt; sizeof(struct sctp_event_subscribe))
 		len = sizeof(struct sctp_event_subscribe);
<span class="p_chunk">@@ -4328,6 +4331,12 @@</span> <span class="p_context"> int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)</span>
 	if (!asoc)
 		return -EINVAL;
 
<span class="p_add">+	/* If there is a thread waiting on more sndbuf space for</span>
<span class="p_add">+	 * sending on this asoc, it cannot be peeled.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (waitqueue_active(&amp;asoc-&gt;wait))</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+</span>
 	/* An association cannot be branched off from an already peeled-off
 	 * socket, nor is this supported for tcp style sockets.
 	 */
<span class="p_chunk">@@ -5801,6 +5810,9 @@</span> <span class="p_context"> static int sctp_getsockopt(struct sock *sk, int level, int optname,</span>
 	if (get_user(len, optlen))
 		return -EFAULT;
 
<span class="p_add">+	if (len &lt; 0)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	lock_sock(sk);
 
 	switch (optname) {
<span class="p_chunk">@@ -6754,7 +6766,6 @@</span> <span class="p_context"> static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,</span>
 		 */
 		release_sock(sk);
 		current_timeo = schedule_timeout(current_timeo);
<span class="p_del">-		BUG_ON(sk != asoc-&gt;base.sk);</span>
 		lock_sock(sk);
 
 		*timeo_p = current_timeo;
<span class="p_header">diff --git a/net/socket.c b/net/socket.c</span>
<span class="p_header">index 8da2e2ea4151..ccfaebcdba66 100644</span>
<span class="p_header">--- a/net/socket.c</span>
<span class="p_header">+++ b/net/socket.c</span>
<span class="p_chunk">@@ -1998,7 +1998,7 @@</span> <span class="p_context"> static int copy_msghdr_from_user(struct msghdr *kmsg,</span>
 
 static int ___sys_sendmsg(struct socket *sock, struct msghdr __user *msg,
 			 struct msghdr *msg_sys, unsigned int flags,
<span class="p_del">-			 struct used_address *used_address)</span>
<span class="p_add">+			 struct used_address *used_address, int *residue)</span>
 {
 	struct compat_msghdr __user *msg_compat =
 	    (struct compat_msghdr __user *)msg;
<span class="p_chunk">@@ -2097,6 +2097,8 @@</span> <span class="p_context"> static int ___sys_sendmsg(struct socket *sock, struct msghdr __user *msg,</span>
 			memcpy(&amp;used_address-&gt;name, msg_sys-&gt;msg_name,
 			       used_address-&gt;name_len);
 	}
<span class="p_add">+	if (residue &amp;&amp; err &gt;= 0)</span>
<span class="p_add">+		*residue = total_len - err;</span>
 
 out_freectl:
 	if (ctl_buf != ctl)
<span class="p_chunk">@@ -2122,7 +2124,7 @@</span> <span class="p_context"> long __sys_sendmsg(int fd, struct msghdr __user *msg, unsigned flags)</span>
 	if (!sock)
 		goto out;
 
<span class="p_del">-	err = ___sys_sendmsg(sock, msg, &amp;msg_sys, flags, NULL);</span>
<span class="p_add">+	err = ___sys_sendmsg(sock, msg, &amp;msg_sys, flags, NULL, NULL);</span>
 
 	fput_light(sock-&gt;file, fput_needed);
 out:
<span class="p_chunk">@@ -2149,6 +2151,7 @@</span> <span class="p_context"> int __sys_sendmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,</span>
 	struct compat_mmsghdr __user *compat_entry;
 	struct msghdr msg_sys;
 	struct used_address used_address;
<span class="p_add">+	int residue;</span>
 
 	if (vlen &gt; UIO_MAXIOV)
 		vlen = UIO_MAXIOV;
<span class="p_chunk">@@ -2167,7 +2170,8 @@</span> <span class="p_context"> int __sys_sendmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,</span>
 	while (datagrams &lt; vlen) {
 		if (MSG_CMSG_COMPAT &amp; flags) {
 			err = ___sys_sendmsg(sock, (struct msghdr __user *)compat_entry,
<span class="p_del">-					     &amp;msg_sys, flags, &amp;used_address);</span>
<span class="p_add">+					     &amp;msg_sys, flags, &amp;used_address,</span>
<span class="p_add">+					     &amp;residue);</span>
 			if (err &lt; 0)
 				break;
 			err = __put_user(err, &amp;compat_entry-&gt;msg_len);
<span class="p_chunk">@@ -2175,7 +2179,8 @@</span> <span class="p_context"> int __sys_sendmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,</span>
 		} else {
 			err = ___sys_sendmsg(sock,
 					     (struct msghdr __user *)entry,
<span class="p_del">-					     &amp;msg_sys, flags, &amp;used_address);</span>
<span class="p_add">+					     &amp;msg_sys, flags, &amp;used_address,</span>
<span class="p_add">+					     &amp;residue);</span>
 			if (err &lt; 0)
 				break;
 			err = put_user(err, &amp;entry-&gt;msg_len);
<span class="p_chunk">@@ -2185,6 +2190,8 @@</span> <span class="p_context"> int __sys_sendmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,</span>
 		if (err)
 			break;
 		++datagrams;
<span class="p_add">+		if (residue)</span>
<span class="p_add">+			break;</span>
 	}
 
 	fput_light(sock-&gt;file, fput_needed);
<span class="p_chunk">@@ -2349,8 +2356,10 @@</span> <span class="p_context"> int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,</span>
 		return err;
 
 	err = sock_error(sock-&gt;sk);
<span class="p_del">-	if (err)</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		datagrams = err;</span>
 		goto out_put;
<span class="p_add">+	}</span>
 
 	entry = mmsg;
 	compat_entry = (struct compat_mmsghdr __user *)mmsg;
<span class="p_header">diff --git a/net/sunrpc/auth_gss/gss_rpc_xdr.c b/net/sunrpc/auth_gss/gss_rpc_xdr.c</span>
<span class="p_header">index eeeba5adee6d..2410d557ae39 100644</span>
<span class="p_header">--- a/net/sunrpc/auth_gss/gss_rpc_xdr.c</span>
<span class="p_header">+++ b/net/sunrpc/auth_gss/gss_rpc_xdr.c</span>
<span class="p_chunk">@@ -260,7 +260,7 @@</span> <span class="p_context"> static int gssx_dec_option_array(struct xdr_stream *xdr,</span>
 	if (!oa-&gt;data)
 		return -ENOMEM;
 
<span class="p_del">-	creds = kmalloc(sizeof(struct svc_cred), GFP_KERNEL);</span>
<span class="p_add">+	creds = kzalloc(sizeof(struct svc_cred), GFP_KERNEL);</span>
 	if (!creds) {
 		kfree(oa-&gt;data);
 		return -ENOMEM;
<span class="p_header">diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_header">index efac1201c55d..8bc077f3e91f 100644</span>
<span class="p_header">--- a/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_header">+++ b/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_chunk">@@ -1479,7 +1479,7 @@</span> <span class="p_context"> svcauth_gss_accept(struct svc_rqst *rqstp, __be32 *authp)</span>
 	case RPC_GSS_PROC_DESTROY:
 		if (gss_write_verf(rqstp, rsci-&gt;mechctx, gc-&gt;gc_seq))
 			goto auth_err;
<span class="p_del">-		rsci-&gt;h.expiry_time = get_seconds();</span>
<span class="p_add">+		rsci-&gt;h.expiry_time = seconds_since_boot();</span>
 		set_bit(CACHE_NEGATIVE, &amp;rsci-&gt;h.flags);
 		if (resv-&gt;iov_len + 4 &gt; PAGE_SIZE)
 			goto drop;
<span class="p_header">diff --git a/net/sunrpc/clnt.c b/net/sunrpc/clnt.c</span>
<span class="p_header">index 70273ab30e85..710d4191e9d5 100644</span>
<span class="p_header">--- a/net/sunrpc/clnt.c</span>
<span class="p_header">+++ b/net/sunrpc/clnt.c</span>
<span class="p_chunk">@@ -336,6 +336,11 @@</span> <span class="p_context"> out:</span>
 
 static DEFINE_IDA(rpc_clids);
 
<span class="p_add">+void rpc_cleanup_clids(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	ida_destroy(&amp;rpc_clids);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int rpc_alloc_clid(struct rpc_clnt *clnt)
 {
 	int clid;
<span class="p_header">diff --git a/net/sunrpc/sunrpc_syms.c b/net/sunrpc/sunrpc_syms.c</span>
<span class="p_header">index cd30120de9e4..aefb4488880f 100644</span>
<span class="p_header">--- a/net/sunrpc/sunrpc_syms.c</span>
<span class="p_header">+++ b/net/sunrpc/sunrpc_syms.c</span>
<span class="p_chunk">@@ -117,6 +117,7 @@</span> <span class="p_context"> out:</span>
 static void __exit
 cleanup_sunrpc(void)
 {
<span class="p_add">+	rpc_cleanup_clids();</span>
 	rpcauth_remove_module();
 	cleanup_socket_xprt();
 	svc_cleanup_xprt_sock();
<span class="p_header">diff --git a/net/vmw_vsock/af_vsock.c b/net/vmw_vsock/af_vsock.c</span>
<span class="p_header">index 85d232bed87d..e8d3313ea2c9 100644</span>
<span class="p_header">--- a/net/vmw_vsock/af_vsock.c</span>
<span class="p_header">+++ b/net/vmw_vsock/af_vsock.c</span>
<span class="p_chunk">@@ -1796,27 +1796,8 @@</span> <span class="p_context"> vsock_stream_recvmsg(struct kiocb *kiocb,</span>
 	else if (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN)
 		err = 0;
 
<span class="p_del">-	if (copied &gt; 0) {</span>
<span class="p_del">-		/* We only do these additional bookkeeping/notification steps</span>
<span class="p_del">-		 * if we actually copied something out of the queue pair</span>
<span class="p_del">-		 * instead of just peeking ahead.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!(flags &amp; MSG_PEEK)) {</span>
<span class="p_del">-			/* If the other side has shutdown for sending and there</span>
<span class="p_del">-			 * is nothing more to read, then modify the socket</span>
<span class="p_del">-			 * state.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (vsk-&gt;peer_shutdown &amp; SEND_SHUTDOWN) {</span>
<span class="p_del">-				if (vsock_stream_has_data(vsk) &lt;= 0) {</span>
<span class="p_del">-					sk-&gt;sk_state = SS_UNCONNECTED;</span>
<span class="p_del">-					sock_set_flag(sk, SOCK_DONE);</span>
<span class="p_del">-					sk-&gt;sk_state_change(sk);</span>
<span class="p_del">-				}</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
<span class="p_add">+	if (copied &gt; 0)</span>
 		err = copied;
<span class="p_del">-	}</span>
 
 out_wait:
 	finish_wait(sk_sleep(sk), &amp;wait);
<span class="p_header">diff --git a/net/wireless/core.h b/net/wireless/core.h</span>
<span class="p_header">index c4d4b0c4f0e6..805aaab05ffc 100644</span>
<span class="p_header">--- a/net/wireless/core.h</span>
<span class="p_header">+++ b/net/wireless/core.h</span>
<span class="p_chunk">@@ -369,6 +369,7 @@</span> <span class="p_context"> void cfg80211_sme_disassoc(struct wireless_dev *wdev);</span>
 void cfg80211_sme_deauth(struct wireless_dev *wdev);
 void cfg80211_sme_auth_timeout(struct wireless_dev *wdev);
 void cfg80211_sme_assoc_timeout(struct wireless_dev *wdev);
<span class="p_add">+void cfg80211_sme_abandon_assoc(struct wireless_dev *wdev);</span>
 
 /* internal helpers */
 bool cfg80211_supported_cipher_suite(struct wiphy *wiphy, u32 cipher);
<span class="p_header">diff --git a/net/wireless/mlme.c b/net/wireless/mlme.c</span>
<span class="p_header">index 266766b8d80b..66dd9bfe5a96 100644</span>
<span class="p_header">--- a/net/wireless/mlme.c</span>
<span class="p_header">+++ b/net/wireless/mlme.c</span>
<span class="p_chunk">@@ -148,6 +148,18 @@</span> <span class="p_context"> void cfg80211_assoc_timeout(struct net_device *dev, struct cfg80211_bss *bss)</span>
 }
 EXPORT_SYMBOL(cfg80211_assoc_timeout);
 
<span class="p_add">+void cfg80211_abandon_assoc(struct net_device *dev, struct cfg80211_bss *bss)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct wireless_dev *wdev = dev-&gt;ieee80211_ptr;</span>
<span class="p_add">+	struct wiphy *wiphy = wdev-&gt;wiphy;</span>
<span class="p_add">+</span>
<span class="p_add">+	cfg80211_sme_abandon_assoc(wdev);</span>
<span class="p_add">+</span>
<span class="p_add">+	cfg80211_unhold_bss(bss_from_pub(bss));</span>
<span class="p_add">+	cfg80211_put_bss(wiphy, bss);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(cfg80211_abandon_assoc);</span>
<span class="p_add">+</span>
 void cfg80211_tx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len)
 {
 	struct wireless_dev *wdev = dev-&gt;ieee80211_ptr;
<span class="p_header">diff --git a/net/wireless/sme.c b/net/wireless/sme.c</span>
<span class="p_header">index 8bbeeb302216..c74505c1a320 100644</span>
<span class="p_header">--- a/net/wireless/sme.c</span>
<span class="p_header">+++ b/net/wireless/sme.c</span>
<span class="p_chunk">@@ -39,6 +39,7 @@</span> <span class="p_context"> struct cfg80211_conn {</span>
 		CFG80211_CONN_ASSOCIATING,
 		CFG80211_CONN_ASSOC_FAILED,
 		CFG80211_CONN_DEAUTH,
<span class="p_add">+		CFG80211_CONN_ABANDON,</span>
 		CFG80211_CONN_CONNECTED,
 	} state;
 	u8 bssid[ETH_ALEN], prev_bssid[ETH_ALEN];
<span class="p_chunk">@@ -195,6 +196,8 @@</span> <span class="p_context"> static int cfg80211_conn_do_work(struct wireless_dev *wdev)</span>
 		cfg80211_mlme_deauth(rdev, wdev-&gt;netdev, params-&gt;bssid,
 				     NULL, 0,
 				     WLAN_REASON_DEAUTH_LEAVING, false);
<span class="p_add">+		/* fall through */</span>
<span class="p_add">+	case CFG80211_CONN_ABANDON:</span>
 		/* free directly, disconnected event already sent */
 		cfg80211_sme_free(wdev);
 		return 0;
<span class="p_chunk">@@ -418,6 +421,17 @@</span> <span class="p_context"> void cfg80211_sme_assoc_timeout(struct wireless_dev *wdev)</span>
 	schedule_work(&amp;rdev-&gt;conn_work);
 }
 
<span class="p_add">+void cfg80211_sme_abandon_assoc(struct wireless_dev *wdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev-&gt;wiphy);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!wdev-&gt;conn)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	wdev-&gt;conn-&gt;state = CFG80211_CONN_ABANDON;</span>
<span class="p_add">+	schedule_work(&amp;rdev-&gt;conn_work);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int cfg80211_sme_connect(struct wireless_dev *wdev,
 				struct cfg80211_connect_params *connect,
 				const u8 *prev_bssid)
<span class="p_header">diff --git a/scripts/kconfig/nconf.gui.c b/scripts/kconfig/nconf.gui.c</span>
<span class="p_header">index 8275f0e55106..4b2f44c20caf 100644</span>
<span class="p_header">--- a/scripts/kconfig/nconf.gui.c</span>
<span class="p_header">+++ b/scripts/kconfig/nconf.gui.c</span>
<span class="p_chunk">@@ -364,12 +364,14 @@</span> <span class="p_context"> int dialog_inputbox(WINDOW *main_window,</span>
 	WINDOW *prompt_win;
 	WINDOW *form_win;
 	PANEL *panel;
<span class="p_del">-	int i, x, y;</span>
<span class="p_add">+	int i, x, y, lines, columns, win_lines, win_cols;</span>
 	int res = -1;
 	int cursor_position = strlen(init);
 	int cursor_form_win;
 	char *result = *resultp;
 
<span class="p_add">+	getmaxyx(stdscr, lines, columns);</span>
<span class="p_add">+</span>
 	if (strlen(init)+1 &gt; *result_len) {
 		*result_len = strlen(init)+1;
 		*resultp = result = realloc(result, *result_len);
<span class="p_chunk">@@ -386,14 +388,19 @@</span> <span class="p_context"> int dialog_inputbox(WINDOW *main_window,</span>
 	if (title)
 		prompt_width = max(prompt_width, strlen(title));
 
<span class="p_add">+	win_lines = min(prompt_lines+6, lines-2);</span>
<span class="p_add">+	win_cols = min(prompt_width+7, columns-2);</span>
<span class="p_add">+	prompt_lines = max(win_lines-6, 0);</span>
<span class="p_add">+	prompt_width = max(win_cols-7, 0);</span>
<span class="p_add">+</span>
 	/* place dialog in middle of screen */
<span class="p_del">-	y = (getmaxy(stdscr)-(prompt_lines+4))/2;</span>
<span class="p_del">-	x = (getmaxx(stdscr)-(prompt_width+4))/2;</span>
<span class="p_add">+	y = (lines-win_lines)/2;</span>
<span class="p_add">+	x = (columns-win_cols)/2;</span>
 
 	strncpy(result, init, *result_len);
 
 	/* create the windows */
<span class="p_del">-	win = newwin(prompt_lines+6, prompt_width+7, y, x);</span>
<span class="p_add">+	win = newwin(win_lines, win_cols, y, x);</span>
 	prompt_win = derwin(win, prompt_lines+1, prompt_width, 2, 2);
 	form_win = derwin(win, 1, prompt_width, prompt_lines+3, 2);
 	keypad(form_win, TRUE);
<span class="p_header">diff --git a/sound/core/seq/seq_memory.c b/sound/core/seq/seq_memory.c</span>
<span class="p_header">index 04ef9b5351f9..15331bb173f2 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_memory.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_memory.c</span>
<span class="p_chunk">@@ -419,7 +419,6 @@</span> <span class="p_context"> int snd_seq_pool_done(struct snd_seq_pool *pool)</span>
 {
 	unsigned long flags;
 	struct snd_seq_event_cell *ptr;
<span class="p_del">-	int max_count = 5 * HZ;</span>
 
 	if (snd_BUG_ON(!pool))
 		return -EINVAL;
<span class="p_chunk">@@ -432,14 +431,8 @@</span> <span class="p_context"> int snd_seq_pool_done(struct snd_seq_pool *pool)</span>
 	if (waitqueue_active(&amp;pool-&gt;output_sleep))
 		wake_up(&amp;pool-&gt;output_sleep);
 
<span class="p_del">-	while (atomic_read(&amp;pool-&gt;counter) &gt; 0) {</span>
<span class="p_del">-		if (max_count == 0) {</span>
<span class="p_del">-			pr_warn(&quot;ALSA: snd_seq_pool_done timeout: %d cells remain\n&quot;, atomic_read(&amp;pool-&gt;counter));</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	while (atomic_read(&amp;pool-&gt;counter) &gt; 0)</span>
 		schedule_timeout_uninterruptible(1);
<span class="p_del">-		max_count--;</span>
<span class="p_del">-	}</span>
 	
 	/* release all resources */
 	spin_lock_irqsave(&amp;pool-&gt;lock, flags);
<span class="p_header">diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c</span>
<span class="p_header">index 77ec21420355..f676ae53c477 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_queue.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_queue.c</span>
<span class="p_chunk">@@ -181,6 +181,8 @@</span> <span class="p_context"> void __exit snd_seq_queues_delete(void)</span>
 	}
 }
 
<span class="p_add">+static void queue_use(struct snd_seq_queue *queue, int client, int use);</span>
<span class="p_add">+</span>
 /* allocate a new queue -
  * return queue index value or negative value for error
  */
<span class="p_chunk">@@ -192,11 +194,11 @@</span> <span class="p_context"> int snd_seq_queue_alloc(int client, int locked, unsigned int info_flags)</span>
 	if (q == NULL)
 		return -ENOMEM;
 	q-&gt;info_flags = info_flags;
<span class="p_add">+	queue_use(q, client, 1);</span>
 	if (queue_list_add(q) &lt; 0) {
 		queue_delete(q);
 		return -ENOMEM;
 	}
<span class="p_del">-	snd_seq_queue_use(q-&gt;queue, client, 1); /* use this queue */</span>
 	return q-&gt;queue;
 }
 
<span class="p_chunk">@@ -502,19 +504,9 @@</span> <span class="p_context"> int snd_seq_queue_timer_set_tempo(int queueid, int client,</span>
 	return result;
 }
 
<span class="p_del">-</span>
<span class="p_del">-/* use or unuse this queue -</span>
<span class="p_del">- * if it is the first client, starts the timer.</span>
<span class="p_del">- * if it is not longer used by any clients, stop the timer.</span>
<span class="p_del">- */</span>
<span class="p_del">-int snd_seq_queue_use(int queueid, int client, int use)</span>
<span class="p_add">+/* use or unuse this queue */</span>
<span class="p_add">+static void queue_use(struct snd_seq_queue *queue, int client, int use)</span>
 {
<span class="p_del">-	struct snd_seq_queue *queue;</span>
<span class="p_del">-</span>
<span class="p_del">-	queue = queueptr(queueid);</span>
<span class="p_del">-	if (queue == NULL)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	mutex_lock(&amp;queue-&gt;timer_mutex);</span>
 	if (use) {
 		if (!test_and_set_bit(client, queue-&gt;clients_bitmap))
 			queue-&gt;clients++;
<span class="p_chunk">@@ -529,6 +521,21 @@</span> <span class="p_context"> int snd_seq_queue_use(int queueid, int client, int use)</span>
 	} else {
 		snd_seq_timer_close(queue);
 	}
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* use or unuse this queue -</span>
<span class="p_add">+ * if it is the first client, starts the timer.</span>
<span class="p_add">+ * if it is not longer used by any clients, stop the timer.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int snd_seq_queue_use(int queueid, int client, int use)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct snd_seq_queue *queue;</span>
<span class="p_add">+</span>
<span class="p_add">+	queue = queueptr(queueid);</span>
<span class="p_add">+	if (queue == NULL)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	mutex_lock(&amp;queue-&gt;timer_mutex);</span>
<span class="p_add">+	queue_use(queue, client, use);</span>
 	mutex_unlock(&amp;queue-&gt;timer_mutex);
 	queuefree(queue);
 	return 0;
<span class="p_header">diff --git a/sound/pci/hda/patch_conexant.c b/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">index 9b54e936aae7..ced54249c171 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_conexant.c</span>
<span class="p_chunk">@@ -2843,6 +2843,8 @@</span> <span class="p_context"> enum {</span>
 	CXT_FIXUP_HP_530,
 	CXT_FIXUP_CAP_MIX_AMP_5047,
 	CXT_FIXUP_MUTE_LED_EAPD,
<span class="p_add">+	CXT_FIXUP_HP_SPECTRE,</span>
<span class="p_add">+	CXT_FIXUP_HP_GATE_MIC,</span>
 };
 
 /* for hda_fixup_thinkpad_acpi() */
<span class="p_chunk">@@ -3216,6 +3218,17 @@</span> <span class="p_context"> static void cxt_fixup_cap_mix_amp_5047(struct hda_codec *codec,</span>
 				  (1 &lt;&lt; AC_AMPCAP_MUTE_SHIFT));
 }
 
<span class="p_add">+static void cxt_fixup_hp_gate_mic_jack(struct hda_codec *codec,</span>
<span class="p_add">+				       const struct hda_fixup *fix,</span>
<span class="p_add">+				       int action)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* the mic pin (0x19) doesn&#39;t give an unsolicited event;</span>
<span class="p_add">+	 * probe the mic pin together with the headphone pin (0x16)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (action == HDA_FIXUP_ACT_PROBE)</span>
<span class="p_add">+		snd_hda_jack_set_gating_jack(codec, 0x19, 0x16);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* ThinkPad X200 &amp; co with cxt5051 */
 static const struct hda_pintbl cxt_pincfg_lenovo_x200[] = {
 	{ 0x16, 0x042140ff }, /* HP (seq# overridden) */
<span class="p_chunk">@@ -3349,6 +3362,18 @@</span> <span class="p_context"> static const struct hda_fixup cxt_fixups[] = {</span>
 		.type = HDA_FIXUP_FUNC,
 		.v.func = cxt_fixup_mute_led_eapd,
 	},
<span class="p_add">+	[CXT_FIXUP_HP_SPECTRE] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_PINS,</span>
<span class="p_add">+		.v.pins = (const struct hda_pintbl[]) {</span>
<span class="p_add">+			/* enable NID 0x1d for the speaker on top */</span>
<span class="p_add">+			{ 0x1d, 0x91170111 },</span>
<span class="p_add">+			{ }</span>
<span class="p_add">+		}</span>
<span class="p_add">+	},</span>
<span class="p_add">+	[CXT_FIXUP_HP_GATE_MIC] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = cxt_fixup_hp_gate_mic_jack,</span>
<span class="p_add">+	},</span>
 };
 
 static const struct snd_pci_quirk cxt5045_fixups[] = {
<span class="p_chunk">@@ -3397,6 +3422,9 @@</span> <span class="p_context"> static const struct hda_model_fixup cxt5051_fixup_models[] = {</span>
 static const struct snd_pci_quirk cxt5066_fixups[] = {
 	SND_PCI_QUIRK(0x1025, 0x0543, &quot;Acer Aspire One 522&quot;, CXT_FIXUP_STEREO_DMIC),
 	SND_PCI_QUIRK(0x1025, 0x054c, &quot;Acer Aspire 3830TG&quot;, CXT_FIXUP_ASPIRE_DMIC),
<span class="p_add">+	SND_PCI_QUIRK(0x1025, 0x054f, &quot;Acer Aspire 4830T&quot;, CXT_FIXUP_ASPIRE_DMIC),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x103c, 0x8174, &quot;HP Spectre x360&quot;, CXT_FIXUP_HP_SPECTRE),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x103c, 0x8115, &quot;HP Z1 Gen3&quot;, CXT_FIXUP_HP_GATE_MIC),</span>
 	SND_PCI_QUIRK(0x1043, 0x138d, &quot;Asus&quot;, CXT_FIXUP_HEADPHONE_MIC_PIN),
 	SND_PCI_QUIRK(0x152d, 0x0833, &quot;OLPC XO-1.5&quot;, CXT_FIXUP_OLPC_XO),
 	SND_PCI_QUIRK(0x17aa, 0x20f2, &quot;Lenovo T400&quot;, CXT_PINCFG_LENOVO_TP410),
<span class="p_header">diff --git a/sound/pci/hda/patch_hdmi.c b/sound/pci/hda/patch_hdmi.c</span>
<span class="p_header">index c4f149ca1a72..06b990727f68 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_hdmi.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_hdmi.c</span>
<span class="p_chunk">@@ -3345,6 +3345,7 @@</span> <span class="p_context"> static const struct hda_codec_preset snd_hda_preset_hdmi[] = {</span>
 { .id = 0x10de0071, .name = &quot;GPU 71 HDMI/DP&quot;,	.patch = patch_nvhdmi },
 { .id = 0x10de0072, .name = &quot;GPU 72 HDMI/DP&quot;,	.patch = patch_nvhdmi },
 { .id = 0x10de007d, .name = &quot;GPU 7d HDMI/DP&quot;,	.patch = patch_nvhdmi },
<span class="p_add">+{ .id = 0x10de0080, .name = &quot;GPU 80 HDMI/DP&quot;,	.patch = patch_nvhdmi },</span>
 { .id = 0x10de0082, .name = &quot;GPU 82 HDMI/DP&quot;,	.patch = patch_nvhdmi },
 { .id = 0x10de0083, .name = &quot;GPU 83 HDMI/DP&quot;,	.patch = patch_nvhdmi },
 { .id = 0x10de8001, .name = &quot;MCP73 HDMI&quot;,	.patch = patch_nvhdmi_2ch },
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index b76f4ff117a2..1b8fa72a6302 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -2282,6 +2282,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc882_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1043, 0x1971, &quot;Asus W2JC&quot;, ALC882_FIXUP_ASUS_W2JC),
 	SND_PCI_QUIRK(0x1043, 0x835f, &quot;Asus Eee 1601&quot;, ALC888_FIXUP_EEE1601),
 	SND_PCI_QUIRK(0x1043, 0x84bc, &quot;ASUS ET2700&quot;, ALC887_FIXUP_ASUS_BASS),
<span class="p_add">+	SND_PCI_QUIRK(0x1043, 0x8691, &quot;ASUS ROG Ranger VIII&quot;, ALC882_FIXUP_GPIO3),</span>
 	SND_PCI_QUIRK(0x104d, 0x9047, &quot;Sony Vaio TT&quot;, ALC889_FIXUP_VAIO_TT),
 	SND_PCI_QUIRK(0x104d, 0x905a, &quot;Sony Vaio Z&quot;, ALC882_FIXUP_NO_PRIMARY_HP),
 	SND_PCI_QUIRK(0x104d, 0x9043, &quot;Sony Vaio VGC-LN51JGB&quot;, ALC882_FIXUP_NO_PRIMARY_HP),
<span class="p_chunk">@@ -6126,6 +6127,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc662_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1043, 0x15a7, &quot;ASUS UX51VZH&quot;, ALC662_FIXUP_BASS_16),
 	SND_PCI_QUIRK(0x1043, 0x177d, &quot;ASUS N551&quot;, ALC668_FIXUP_ASUS_Nx51),
 	SND_PCI_QUIRK(0x1043, 0x17bd, &quot;ASUS N751&quot;, ALC668_FIXUP_ASUS_Nx51),
<span class="p_add">+	SND_PCI_QUIRK(0x1043, 0x1963, &quot;ASUS X71SL&quot;, ALC662_FIXUP_ASUS_MODE8),</span>
 	SND_PCI_QUIRK(0x1043, 0x1b73, &quot;ASUS N55SF&quot;, ALC662_FIXUP_BASS_16),
 	SND_PCI_QUIRK(0x1043, 0x1bf3, &quot;ASUS N76VZ&quot;, ALC662_FIXUP_BASS_MODE4_CHMAP),
 	SND_PCI_QUIRK(0x1043, 0x8469, &quot;ASUS mobo&quot;, ALC662_FIXUP_NO_JACK_DETECT),
<span class="p_header">diff --git a/sound/usb/card.c b/sound/usb/card.c</span>
<span class="p_header">index 34f934095ddd..8887f4e19956 100644</span>
<span class="p_header">--- a/sound/usb/card.c</span>
<span class="p_header">+++ b/sound/usb/card.c</span>
<span class="p_chunk">@@ -204,7 +204,6 @@</span> <span class="p_context"> static int snd_usb_create_stream(struct snd_usb_audio *chip, int ctrlif, int int</span>
 	if (! snd_usb_parse_audio_interface(chip, interface)) {
 		usb_set_interface(dev, interface, 0); /* reset the current interface */
 		usb_driver_claim_interface(&amp;usb_audio_driver, iface, (void *)-1L);
<span class="p_del">-		return -EINVAL;</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/sound/usb/hiface/pcm.c b/sound/usb/hiface/pcm.c</span>
<span class="p_header">index 2c44139b4041..33db205dd12b 100644</span>
<span class="p_header">--- a/sound/usb/hiface/pcm.c</span>
<span class="p_header">+++ b/sound/usb/hiface/pcm.c</span>
<span class="p_chunk">@@ -445,6 +445,8 @@</span> <span class="p_context"> static int hiface_pcm_prepare(struct snd_pcm_substream *alsa_sub)</span>
 
 	mutex_lock(&amp;rt-&gt;stream_mutex);
 
<span class="p_add">+	hiface_pcm_stream_stop(rt);</span>
<span class="p_add">+</span>
 	sub-&gt;dma_off = 0;
 	sub-&gt;period_off = 0;
 
<span class="p_header">diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c</span>
<span class="p_header">index 21c60eff920e..5d249caf3349 100644</span>
<span class="p_header">--- a/sound/usb/mixer.c</span>
<span class="p_header">+++ b/sound/usb/mixer.c</span>
<span class="p_chunk">@@ -916,9 +916,10 @@</span> <span class="p_context"> static void volume_control_quirks(struct usb_mixer_elem_info *cval,</span>
 	case USB_ID(0x046d, 0x0826): /* HD Webcam c525 */
 	case USB_ID(0x046d, 0x08ca): /* Logitech Quickcam Fusion */
 	case USB_ID(0x046d, 0x0991):
<span class="p_add">+	case USB_ID(0x046d, 0x09a2): /* QuickCam Communicate Deluxe/S7500 */</span>
 	/* Most audio usb devices lie about volume resolution.
 	 * Most Logitech webcams have res = 384.
<span class="p_del">-	 * Proboly there is some logitech magic behind this number --fishor</span>
<span class="p_add">+	 * Probably there is some logitech magic behind this number --fishor</span>
 	 */
 		if (!strcmp(kctl-&gt;id.name, &quot;Mic Capture Volume&quot;)) {
 			usb_audio_info(chip,
<span class="p_header">diff --git a/tools/perf/builtin-trace.c b/tools/perf/builtin-trace.c</span>
<span class="p_header">index f954c26de231..0dbb69a404fe 100644</span>
<span class="p_header">--- a/tools/perf/builtin-trace.c</span>
<span class="p_header">+++ b/tools/perf/builtin-trace.c</span>
<span class="p_chunk">@@ -1646,7 +1646,7 @@</span> <span class="p_context"> static int trace__sys_enter(struct trace *trace, struct perf_evsel *evsel,</span>
 
 	if (!strcmp(sc-&gt;name, &quot;exit_group&quot;) || !strcmp(sc-&gt;name, &quot;exit&quot;)) {
 		if (!trace-&gt;duration_filter &amp;&amp; !trace-&gt;summary_only) {
<span class="p_del">-			trace__fprintf_entry_head(trace, thread, 1, sample-&gt;time, trace-&gt;output);</span>
<span class="p_add">+			trace__fprintf_entry_head(trace, thread, 1, ttrace-&gt;entry_time, trace-&gt;output);</span>
 			fprintf(trace-&gt;output, &quot;%-70s\n&quot;, ttrace-&gt;entry_str);
 		}
 	} else
<span class="p_chunk">@@ -1701,7 +1701,7 @@</span> <span class="p_context"> static int trace__sys_exit(struct trace *trace, struct perf_evsel *evsel,</span>
 	if (trace-&gt;summary_only)
 		goto out;
 
<span class="p_del">-	trace__fprintf_entry_head(trace, thread, duration, sample-&gt;time, trace-&gt;output);</span>
<span class="p_add">+	trace__fprintf_entry_head(trace, thread, duration, ttrace-&gt;entry_time, trace-&gt;output);</span>
 
 	if (ttrace-&gt;entry_pending) {
 		fprintf(trace-&gt;output, &quot;%-70s&quot;, ttrace-&gt;entry_str);
<span class="p_header">diff --git a/tools/perf/util/trace-event-scripting.c b/tools/perf/util/trace-event-scripting.c</span>
<span class="p_header">index 57aaccc1692e..6a1fe83386ea 100644</span>
<span class="p_header">--- a/tools/perf/util/trace-event-scripting.c</span>
<span class="p_header">+++ b/tools/perf/util/trace-event-scripting.c</span>
<span class="p_chunk">@@ -90,7 +90,8 @@</span> <span class="p_context"> static void register_python_scripting(struct scripting_ops *scripting_ops)</span>
 	if (err)
 		die(&quot;error registering py script extension&quot;);
 
<span class="p_del">-	scripting_context = malloc(sizeof(struct scripting_context));</span>
<span class="p_add">+	if (scripting_context == NULL)</span>
<span class="p_add">+		scripting_context = malloc(sizeof(*scripting_context));</span>
 }
 
 #ifdef NO_LIBPYTHON
<span class="p_chunk">@@ -153,7 +154,8 @@</span> <span class="p_context"> static void register_perl_scripting(struct scripting_ops *scripting_ops)</span>
 	if (err)
 		die(&quot;error registering pl script extension&quot;);
 
<span class="p_del">-	scripting_context = malloc(sizeof(struct scripting_context));</span>
<span class="p_add">+	if (scripting_context == NULL)</span>
<span class="p_add">+		scripting_context = malloc(sizeof(*scripting_context));</span>
 }
 
 #ifdef NO_LIBPERL
<span class="p_header">diff --git a/tools/testing/selftests/net/run_netsocktests b/tools/testing/selftests/net/run_netsocktests</span>
<span class="p_header">index c09a682df56a..16058bbea7a8 100644</span>
<span class="p_header">--- a/tools/testing/selftests/net/run_netsocktests</span>
<span class="p_header">+++ b/tools/testing/selftests/net/run_netsocktests</span>
<span class="p_chunk">@@ -1,4 +1,4 @@</span> <span class="p_context"></span>
<span class="p_del">-#!/bin/bash</span>
<span class="p_add">+#!/bin/sh</span>
 
 echo &quot;--------------------&quot;
 echo &quot;running socket test&quot;
<span class="p_header">diff --git a/tools/testing/selftests/powerpc/pmu/ebb/pmc56_overflow_test.c b/tools/testing/selftests/powerpc/pmu/ebb/pmc56_overflow_test.c</span>
<span class="p_header">index a503fa70c950..9be22e932cc4 100644</span>
<span class="p_header">--- a/tools/testing/selftests/powerpc/pmu/ebb/pmc56_overflow_test.c</span>
<span class="p_header">+++ b/tools/testing/selftests/powerpc/pmu/ebb/pmc56_overflow_test.c</span>
<span class="p_chunk">@@ -64,7 +64,7 @@</span> <span class="p_context"> int pmc56_overflow(void)</span>
 
 	FAIL_IF(ebb_event_enable(&amp;event));
 
<span class="p_del">-	mtspr(SPRN_PMC1, pmc_sample_period(sample_period));</span>
<span class="p_add">+	mtspr(SPRN_PMC2, pmc_sample_period(sample_period));</span>
 	mtspr(SPRN_PMC5, 0);
 	mtspr(SPRN_PMC6, 0);
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



