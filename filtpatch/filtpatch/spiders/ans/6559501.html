
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v3] ARM: early fixmap support for earlycon - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v3] ARM: early fixmap support for earlycon</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=71861">Stefan Agner</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 6, 2015, 12:31 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1433593888-7142-1-git-send-email-stefan@agner.ch&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6559501/mbox/"
   >mbox</a>
|
   <a href="/patch/6559501/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6559501/">/patch/6559501/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 550BF9F1C1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat,  6 Jun 2015 12:32:00 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 20A602063B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat,  6 Jun 2015 12:31:59 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id C11F72063A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat,  6 Jun 2015 12:31:57 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752634AbbFFMbm (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sat, 6 Jun 2015 08:31:42 -0400
Received: from mail.kmu-office.ch ([178.209.48.109]:55812 &quot;EHLO
	mail.kmu-office.ch&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752475AbbFFMbd (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sat, 6 Jun 2015 08:31:33 -0400
Received: from trochilidae.agner.local (195-226-23-243.pool.cyberlink.ch
	[195.226.23.243])
	by mail.kmu-office.ch (Postfix) with ESMTPSA id 2117D5C05E2;
	Sat,  6 Jun 2015 14:29:16 +0200 (CEST)
DKIM-Signature: v=1; a=rsa-sha256; c=simple/simple; d=agner.ch; s=dkim;
	t=1433593756; bh=uPpx99G+UEI4ITLwOsxYYgUQEcYm7vqn0LBnJDwgKKs=;
	h=From:To:Cc:Subject:Date:From;
	b=sKaDJoG3dZKtZOPBOHvqpcfum710rbys1oHmYWOcN63EDX4e+JUdXsDY436Lo46he
	JApXZJtzDi5UuAINgd6Zpx+kE9gLtVeiFYJezeVOLQj2H+5139Itcoy7K79u7gbM1v
	TCWkpA//VXuV+5wIBjoGQMpGTkUQU76H/lDznmxc=
From: Stefan Agner &lt;stefan@agner.ch&gt;
To: linux@arm.linux.org.uk
Cc: linux-arm-kernel@lists.infradead.org, linux-kernel@vger.kernel.org,
	Stefan Agner &lt;stefan@agner.ch&gt;, Mark Salter &lt;msalter@redhat.com&gt;,
	Kees Cook &lt;keescook@chromium.org&gt;, Laura Abbott &lt;lauraa@codeaurora.org&gt;,
	Arnd Bergmann &lt;arnd@arndb.de&gt;,
	Ard Biesheuvel &lt;ard.biesheuvel@linaro.org&gt;, Rob Herring &lt;robh@kernel.org&gt;
Subject: [PATCH v3] ARM: early fixmap support for earlycon
Date: Sat,  6 Jun 2015 14:31:28 +0200
Message-Id: &lt;1433593888-7142-1-git-send-email-stefan@agner.ch&gt;
X-Mailer: git-send-email 2.4.2
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.8 required=5.0 tests=BAYES_00,DKIM_SIGNED,
	RCVD_IN_DNSWL_HI,T_DKIM_INVALID,T_RP_MATCHES_RCVD,UNPARSEABLE_RELAY
	autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=71861">Stefan Agner</a> - June 6, 2015, 12:31 p.m.</div>
<pre class="content">
Add early fixmap support, initially to support permanent, fixed
mapping support for early console. A temporary, early pte is
created which is migrated to a permanent mapping in paging_init.
This is also needed since the attributes may change as the memory
types are initialized. The 3MiB range of fixmap spans two pte
tables, but currently only one pte is created for early fixmap
support.

Re-add FIX_KMAP_BEGIN to the index calculation in highmem.c since
the index for kmap does not start at zero anymore. This reverts
4221e2e6b316 (&quot;ARM: 8031/1: fixmap: remove FIX_KMAP_BEGIN and
FIX_KMAP_END&quot;) to some extent.

Cc: Mark Salter &lt;msalter@redhat.com&gt;
Cc: Russell King &lt;linux@arm.linux.org.uk&gt;
Cc: Kees Cook &lt;keescook@chromium.org&gt;
Cc: Laura Abbott &lt;lauraa@codeaurora.org&gt;
Cc: Arnd Bergmann &lt;arnd@arndb.de&gt;
Cc: Ard Biesheuvel &lt;ard.biesheuvel@linaro.org&gt;
<span class="signed-off-by">Signed-off-by: Rob Herring &lt;robh@kernel.org&gt;</span>
<span class="signed-off-by">Signed-off-by: Stefan Agner &lt;stefan@agner.ch&gt;</span>
---
Changes since v2:
- Rebased and tested on rmk/for-next
- Flush TLB&#39;s when clearing the temporary PMD in early_fixmap_shutdown

Changes since v1 (RFC):
- Rebased and tested on v3.19-rc5
- Spelling errors in comments and commit message
- Added Rob&#39;s SOB

 arch/arm/Kconfig              |  3 ++
 arch/arm/include/asm/fixmap.h | 13 +++++++-
 arch/arm/kernel/setup.c       |  3 ++
 arch/arm/mm/highmem.c         |  6 ++--
 arch/arm/mm/mmu.c             | 78 +++++++++++++++++++++++++++++++++++++++++--
 5 files changed, 96 insertions(+), 7 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=709">Russell King - ARM Linux</a> - June 6, 2015, 12:48 p.m.</div>
<pre class="content">
On Sat, Jun 06, 2015 at 02:31:28PM +0200, Stefan Agner wrote:
<span class="quote">&gt; Add early fixmap support, initially to support permanent, fixed</span>
<span class="quote">&gt; mapping support for early console. A temporary, early pte is</span>
<span class="quote">&gt; created which is migrated to a permanent mapping in paging_init.</span>
<span class="quote">&gt; This is also needed since the attributes may change as the memory</span>
<span class="quote">&gt; types are initialized. The 3MiB range of fixmap spans two pte</span>
<span class="quote">&gt; tables, but currently only one pte is created for early fixmap</span>
<span class="quote">&gt; support.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Re-add FIX_KMAP_BEGIN to the index calculation in highmem.c since</span>
<span class="quote">&gt; the index for kmap does not start at zero anymore. This reverts</span>
<span class="quote">&gt; 4221e2e6b316 (&quot;ARM: 8031/1: fixmap: remove FIX_KMAP_BEGIN and</span>
<span class="quote">&gt; FIX_KMAP_END&quot;) to some extent.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Cc: Mark Salter &lt;msalter@redhat.com&gt;</span>
<span class="quote">&gt; Cc: Russell King &lt;linux@arm.linux.org.uk&gt;</span>
<span class="quote">&gt; Cc: Kees Cook &lt;keescook@chromium.org&gt;</span>
<span class="quote">&gt; Cc: Laura Abbott &lt;lauraa@codeaurora.org&gt;</span>
<span class="quote">&gt; Cc: Arnd Bergmann &lt;arnd@arndb.de&gt;</span>
<span class="quote">&gt; Cc: Ard Biesheuvel &lt;ard.biesheuvel@linaro.org&gt;</span>
<span class="quote">&gt; Signed-off-by: Rob Herring &lt;robh@kernel.org&gt;</span>
<span class="quote">&gt; Signed-off-by: Stefan Agner &lt;stefan@agner.ch&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt; Changes since v2:</span>
<span class="quote">&gt; - Rebased and tested on rmk/for-next</span>
<span class="quote">&gt; - Flush TLB&#39;s when clearing the temporary PMD in early_fixmap_shutdown</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Changes since v1 (RFC):</span>
<span class="quote">&gt; - Rebased and tested on v3.19-rc5</span>
<span class="quote">&gt; - Spelling errors in comments and commit message</span>
<span class="quote">&gt; - Added Rob&#39;s SOB</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;  arch/arm/Kconfig              |  3 ++</span>
<span class="quote">&gt;  arch/arm/include/asm/fixmap.h | 13 +++++++-</span>
<span class="quote">&gt;  arch/arm/kernel/setup.c       |  3 ++</span>
<span class="quote">&gt;  arch/arm/mm/highmem.c         |  6 ++--</span>
<span class="quote">&gt;  arch/arm/mm/mmu.c             | 78 +++++++++++++++++++++++++++++++++++++++++--</span>
<span class="quote">&gt;  5 files changed, 96 insertions(+), 7 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig</span>
<span class="quote">&gt; index d0950ce..ef164a7 100644</span>
<span class="quote">&gt; --- a/arch/arm/Kconfig</span>
<span class="quote">&gt; +++ b/arch/arm/Kconfig</span>
<span class="quote">&gt; @@ -186,6 +186,9 @@ config ARCH_HAS_ILOG2_U64</span>
<span class="quote">&gt;  config ARCH_HAS_BANDGAP</span>
<span class="quote">&gt;  	bool</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +config FIX_EARLYCON_MEM</span>
<span class="quote">&gt; +	def_bool y</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  config GENERIC_HWEIGHT</span>
<span class="quote">&gt;  	bool</span>
<span class="quote">&gt;  	default y</span>
<span class="quote">&gt; diff --git a/arch/arm/include/asm/fixmap.h b/arch/arm/include/asm/fixmap.h</span>
<span class="quote">&gt; index 0415eae..2d8b12b 100644</span>
<span class="quote">&gt; --- a/arch/arm/include/asm/fixmap.h</span>
<span class="quote">&gt; +++ b/arch/arm/include/asm/fixmap.h</span>
<span class="quote">&gt; @@ -6,9 +6,13 @@</span>
<span class="quote">&gt;  #define FIXADDR_TOP		(FIXADDR_END - PAGE_SIZE)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #include &lt;asm/kmap_types.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/pgtable.h&gt;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  enum fixed_addresses {</span>
<span class="quote">&gt; -	FIX_KMAP_BEGIN,</span>
<span class="quote">&gt; +	FIX_EARLYCON_MEM_BASE,</span>
<span class="quote">&gt; +	__end_of_permanent_fixed_addresses,</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	FIX_KMAP_BEGIN = __end_of_permanent_fixed_addresses,</span>
<span class="quote">&gt;  	FIX_KMAP_END = FIX_KMAP_BEGIN + (KM_TYPE_NR * NR_CPUS) - 1,</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	/* Support writing RO kernel text via kprobes, jump labels, etc. */</span>
<span class="quote">&gt; @@ -18,7 +22,14 @@ enum fixed_addresses {</span>
<span class="quote">&gt;  	__end_of_fixed_addresses</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +#define FIXMAP_PAGE_COMMON	(L_PTE_YOUNG | L_PTE_PRESENT | L_PTE_XN | L_PTE_DIRTY)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define FIXMAP_PAGE_NORMAL	(FIXMAP_PAGE_COMMON | L_PTE_MT_WRITEBACK)</span>
<span class="quote">&gt; +#define FIXMAP_PAGE_IO		(FIXMAP_PAGE_COMMON | L_PTE_MT_DEV_SHARED | L_PTE_SHARED)</span>
<span class="quote">&gt; +#define FIXMAP_PAGE_NOCACHE	FIXMAP_PAGE_IO</span>

I&#39;m really not happy with this.  What are the expected semantics of the
set_fixmap_nocache() and set_fixmap_offset_nocache() ?  Are they there
for mapping a device, or are they there for mapping _memory_ ?

I would prefer that FIXMAP_PAGE_NOCACHE is _not_ provided until the
semantics of that can be clarified, as there is a difference between the
two on ARM.
<span class="quote">
&gt; +</span>
<span class="quote">&gt;  void __set_fixmap(enum fixed_addresses idx, phys_addr_t phys, pgprot_t prot);</span>
<span class="quote">&gt; +void __init early_fixmap_init(void);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #include &lt;asm-generic/fixmap.h&gt;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c</span>
<span class="quote">&gt; index e6d8c76..6f03beb 100644</span>
<span class="quote">&gt; --- a/arch/arm/kernel/setup.c</span>
<span class="quote">&gt; +++ b/arch/arm/kernel/setup.c</span>
<span class="quote">&gt; @@ -37,6 +37,7 @@</span>
<span class="quote">&gt;  #include &lt;asm/cpu.h&gt;</span>
<span class="quote">&gt;  #include &lt;asm/cputype.h&gt;</span>
<span class="quote">&gt;  #include &lt;asm/elf.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/fixmap.h&gt;</span>
<span class="quote">&gt;  #include &lt;asm/procinfo.h&gt;</span>
<span class="quote">&gt;  #include &lt;asm/psci.h&gt;</span>
<span class="quote">&gt;  #include &lt;asm/sections.h&gt;</span>
<span class="quote">&gt; @@ -953,6 +954,8 @@ void __init setup_arch(char **cmdline_p)</span>
<span class="quote">&gt;  	strlcpy(cmd_line, boot_command_line, COMMAND_LINE_SIZE);</span>
<span class="quote">&gt;  	*cmdline_p = cmd_line;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +	early_fixmap_init();</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  	parse_early_param();</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #ifdef CONFIG_MMU</span>
<span class="quote">&gt; diff --git a/arch/arm/mm/highmem.c b/arch/arm/mm/highmem.c</span>
<span class="quote">&gt; index b98895d..c7097f9 100644</span>
<span class="quote">&gt; --- a/arch/arm/mm/highmem.c</span>
<span class="quote">&gt; +++ b/arch/arm/mm/highmem.c</span>
<span class="quote">&gt; @@ -78,7 +78,7 @@ void *kmap_atomic(struct page *page)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	type = kmap_atomic_idx_push();</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -	idx = type + KM_TYPE_NR * smp_processor_id();</span>
<span class="quote">&gt; +	idx = FIX_KMAP_BEGIN + type + KM_TYPE_NR * smp_processor_id();</span>
<span class="quote">&gt;  	vaddr = __fix_to_virt(idx);</span>
<span class="quote">&gt;  #ifdef CONFIG_DEBUG_HIGHMEM</span>
<span class="quote">&gt;  	/*</span>
<span class="quote">&gt; @@ -105,7 +105,7 @@ void __kunmap_atomic(void *kvaddr)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	if (kvaddr &gt;= (void *)FIXADDR_START) {</span>
<span class="quote">&gt;  		type = kmap_atomic_idx();</span>
<span class="quote">&gt; -		idx = type + KM_TYPE_NR * smp_processor_id();</span>
<span class="quote">&gt; +		idx = FIX_KMAP_BEGIN + type + KM_TYPE_NR * smp_processor_id();</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  		if (cache_is_vivt())</span>
<span class="quote">&gt;  			__cpuc_flush_dcache_area((void *)vaddr, PAGE_SIZE);</span>
<span class="quote">&gt; @@ -135,7 +135,7 @@ void *kmap_atomic_pfn(unsigned long pfn)</span>
<span class="quote">&gt;  		return page_address(page);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	type = kmap_atomic_idx_push();</span>
<span class="quote">&gt; -	idx = type + KM_TYPE_NR * smp_processor_id();</span>
<span class="quote">&gt; +	idx = FIX_KMAP_BEGIN + type + KM_TYPE_NR * smp_processor_id();</span>
<span class="quote">&gt;  	vaddr = __fix_to_virt(idx);</span>
<span class="quote">&gt;  #ifdef CONFIG_DEBUG_HIGHMEM</span>
<span class="quote">&gt;  	BUG_ON(!pte_none(get_fixmap_pte(vaddr)));</span>
<span class="quote">&gt; diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c</span>
<span class="quote">&gt; index 6ca7d9a..d3e9702 100644</span>
<span class="quote">&gt; --- a/arch/arm/mm/mmu.c</span>
<span class="quote">&gt; +++ b/arch/arm/mm/mmu.c</span>
<span class="quote">&gt; @@ -357,6 +357,47 @@ const struct mem_type *get_mem_type(unsigned int type)</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  EXPORT_SYMBOL(get_mem_type);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +static pte_t *(*pte_offset_fixmap)(pmd_t *dir, unsigned long addr);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static pte_t bm_pte[PTRS_PER_PTE + PTE_HWTABLE_PTRS]</span>
<span class="quote">&gt; +	__aligned(PTE_HWTABLE_OFF + PTE_HWTABLE_SIZE) __initdata;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static pte_t * __init pte_offset_early_fixmap(pmd_t *dir, unsigned long addr)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return &amp;bm_pte[pte_index(addr)];</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static pte_t *pte_offset_late_fixmap(pmd_t *dir, unsigned long addr)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return pte_offset_kernel(dir, addr);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static inline pmd_t * __init fixmap_pmd(unsigned long addr)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	pgd_t *pgd = pgd_offset_k(addr);</span>
<span class="quote">&gt; +	pud_t *pud = pud_offset(pgd, addr);</span>
<span class="quote">&gt; +	pmd_t *pmd = pmd_offset(pud, addr);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return pmd;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +void __init early_fixmap_init(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	pmd_t *pmd;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * The early fixmap range spans multiple pmds, for which</span>
<span class="quote">&gt; +	 * we are not prepared:</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	BUILD_BUG_ON((__fix_to_virt(__end_of_permanent_fixed_addresses) &gt;&gt; PMD_SHIFT)</span>
<span class="quote">&gt; +		     != FIXADDR_TOP &gt;&gt; PMD_SHIFT);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pmd = fixmap_pmd(FIXADDR_TOP);</span>
<span class="quote">&gt; +	pmd_populate_kernel(&amp;init_mm, pmd, bm_pte);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pte_offset_fixmap = &amp;pte_offset_early_fixmap;</span>

Please don&#39;t use &quot;address-of function&quot; in the kernel, it&#39;s really not
necessary and is just plain confusing.  We don&#39;t use it elsewhere, so
there&#39;s no reason to be different.
<span class="quote">
&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt;   * To avoid TLB flush broadcasts, this uses local_flush_tlb_kernel_range().</span>
<span class="quote">&gt;   * As a result, this can only be called with preemption disabled, as under</span>
<span class="quote">&gt; @@ -365,7 +406,7 @@ EXPORT_SYMBOL(get_mem_type);</span>
<span class="quote">&gt;  void __set_fixmap(enum fixed_addresses idx, phys_addr_t phys, pgprot_t prot)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	unsigned long vaddr = __fix_to_virt(idx);</span>
<span class="quote">&gt; -	pte_t *pte = pte_offset_kernel(pmd_off_k(vaddr), vaddr);</span>
<span class="quote">&gt; +	pte_t *pte = pte_offset_fixmap(pmd_off_k(vaddr), vaddr);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	/* Make sure fixmap region does not exceed available allocation. */</span>
<span class="quote">&gt;  	BUILD_BUG_ON(FIXADDR_START + (__end_of_fixed_addresses * PAGE_SIZE) &gt;</span>
<span class="quote">&gt; @@ -855,7 +896,7 @@ static void __init create_mapping(struct map_desc *md)</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	if ((md-&gt;type == MT_DEVICE || md-&gt;type == MT_ROM) &amp;&amp;</span>
<span class="quote">&gt; -	    md-&gt;virtual &gt;= PAGE_OFFSET &amp;&amp;</span>
<span class="quote">&gt; +	    md-&gt;virtual &gt;= PAGE_OFFSET &amp;&amp; md-&gt;virtual &lt; FIXADDR_START &amp;&amp;</span>
<span class="quote">&gt;  	    (md-&gt;virtual &lt; VMALLOC_START || md-&gt;virtual &gt;= VMALLOC_END)) {</span>
<span class="quote">&gt;  		pr_warn(&quot;BUG: mapping for 0x%08llx at 0x%08lx out of vmalloc space\n&quot;,</span>
<span class="quote">&gt;  			(long long)__pfn_to_phys((u64)md-&gt;pfn), md-&gt;virtual);</span>
<span class="quote">&gt; @@ -1231,7 +1272,7 @@ static void __init devicemaps_init(const struct machine_desc *mdesc)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	early_trap_init(vectors);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -	for (addr = VMALLOC_START; addr; addr += PMD_SIZE)</span>
<span class="quote">&gt; +	for (addr = VMALLOC_START; addr &lt; FIXADDR_START; addr += PMD_SIZE)</span>
<span class="quote">&gt;  		pmd_clear(pmd_off_k(addr));</span>

You introduce a bug here - we no logner clear the very top entry of the
page tables, which means it could contain anything - and means that the
subsequent creation of the L2 table in early_pte_alloc() can fail.
<span class="quote">
&gt;  </span>
<span class="quote">&gt;  	/*</span>
<span class="quote">&gt; @@ -1483,6 +1524,36 @@ void __init early_paging_init(const struct machine_desc *mdesc)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +static void __init early_fixmap_shutdown(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	int i;</span>
<span class="quote">&gt; +	unsigned long va = fix_to_virt(__end_of_permanent_fixed_addresses - 1);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pte_offset_fixmap = &amp;pte_offset_late_fixmap;</span>

Again, please don&#39;t use &quot;address-of function&quot;.
<span class="quote">
&gt; +	pmd_clear(fixmap_pmd(va));</span>
<span class="quote">&gt; +	local_flush_tlb_kernel_page(va);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	for (i = 0; i &lt; __end_of_permanent_fixed_addresses; i++) {</span>
<span class="quote">&gt; +		pte_t *pte;</span>
<span class="quote">&gt; +		struct map_desc map;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		map.virtual = fix_to_virt(i);</span>
<span class="quote">&gt; +		pte = pte_offset_early_fixmap(pmd_off_k(map.virtual), map.virtual);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		/* Only i/o device mappings are supported ATM */</span>
<span class="quote">&gt; +		if (pte_none(*pte) ||</span>
<span class="quote">&gt; +		    (pte_val(*pte) &amp; L_PTE_MT_MASK) != L_PTE_MT_DEV_SHARED)</span>
<span class="quote">&gt; +			continue;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		map.pfn = pte_pfn(*pte);</span>
<span class="quote">&gt; +		map.type = MT_DEVICE;</span>
<span class="quote">&gt; +		map.length = PAGE_SIZE;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		create_mapping(&amp;map);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt;   * paging_init() sets up the page tables, initialises the zone memory</span>
<span class="quote">&gt;   * maps, and sets up the zero page, bad page and bad page tables.</span>
<span class="quote">&gt; @@ -1495,6 +1566,7 @@ void __init paging_init(const struct machine_desc *mdesc)</span>
<span class="quote">&gt;  	prepare_page_table();</span>
<span class="quote">&gt;  	map_lowmem();</span>
<span class="quote">&gt;  	dma_contiguous_remap();</span>
<span class="quote">&gt; +	early_fixmap_shutdown();</span>
<span class="quote">&gt;  	devicemaps_init(mdesc);</span>
<span class="quote">&gt;  	kmap_init();</span>
<span class="quote">&gt;  	tcm_init();</span>
<span class="quote">&gt; -- </span>
<span class="quote">&gt; 2.4.2</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=71861">Stefan Agner</a> - June 6, 2015, 1:29 p.m.</div>
<pre class="content">
On 2015-06-06 14:48, Russell King - ARM Linux wrote:
<span class="quote">&gt; On Sat, Jun 06, 2015 at 02:31:28PM +0200, Stefan Agner wrote:</span>
&lt;snip&gt;
<span class="quote">&gt;&gt; --- a/arch/arm/include/asm/fixmap.h</span>
<span class="quote">&gt;&gt; +++ b/arch/arm/include/asm/fixmap.h</span>
<span class="quote">&gt;&gt; @@ -6,9 +6,13 @@</span>
<span class="quote">&gt;&gt;  #define FIXADDR_TOP		(FIXADDR_END - PAGE_SIZE)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  #include &lt;asm/kmap_types.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;asm/pgtable.h&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  enum fixed_addresses {</span>
<span class="quote">&gt;&gt; -	FIX_KMAP_BEGIN,</span>
<span class="quote">&gt;&gt; +	FIX_EARLYCON_MEM_BASE,</span>
<span class="quote">&gt;&gt; +	__end_of_permanent_fixed_addresses,</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	FIX_KMAP_BEGIN = __end_of_permanent_fixed_addresses,</span>
<span class="quote">&gt;&gt;  	FIX_KMAP_END = FIX_KMAP_BEGIN + (KM_TYPE_NR * NR_CPUS) - 1,</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  	/* Support writing RO kernel text via kprobes, jump labels, etc. */</span>
<span class="quote">&gt;&gt; @@ -18,7 +22,14 @@ enum fixed_addresses {</span>
<span class="quote">&gt;&gt;  	__end_of_fixed_addresses</span>
<span class="quote">&gt;&gt;  };</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +#define FIXMAP_PAGE_COMMON	(L_PTE_YOUNG | L_PTE_PRESENT | L_PTE_XN | L_PTE_DIRTY)</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +#define FIXMAP_PAGE_NORMAL	(FIXMAP_PAGE_COMMON | L_PTE_MT_WRITEBACK)</span>
<span class="quote">&gt;&gt; +#define FIXMAP_PAGE_IO		(FIXMAP_PAGE_COMMON | L_PTE_MT_DEV_SHARED | L_PTE_SHARED)</span>
<span class="quote">&gt;&gt; +#define FIXMAP_PAGE_NOCACHE	FIXMAP_PAGE_IO</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I&#39;m really not happy with this.  What are the expected semantics of the</span>
<span class="quote">&gt; set_fixmap_nocache() and set_fixmap_offset_nocache() ?  Are they there</span>
<span class="quote">&gt; for mapping a device, or are they there for mapping _memory_ ?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I would prefer that FIXMAP_PAGE_NOCACHE is _not_ provided until the</span>
<span class="quote">&gt; semantics of that can be clarified, as there is a difference between the</span>
<span class="quote">&gt; two on ARM.</span>

set_fixmap_nocache is used for PCIe and IO APIC stuff, so actually IO
devices. However, as far as I understand the x86 page table definitions
in pgtable_types.h, IO devices are not explicitly uncached on x86. The
define set_fixmap_nocache make sure IO devices are mapped uncached...
Maybe set_fixmap_io_nocache instead of set_fixmap_nocache would be more
appropriate...? 

Maybe the initial authors of the common fixmap.h have a more clear
understanding of the expected semantics, Mark?

Since the focus currently is on set_fixmap_io, we could define
FIXMAP_PAGE_IO only for the time being...?

Agreed to the rest, will apply the review in v4.

--
Stefan

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=86391">Rob Herring</a> - June 6, 2015, 3:29 p.m.</div>
<pre class="content">
On Sat, Jun 6, 2015 at 8:29 AM, Stefan Agner &lt;stefan@agner.ch&gt; wrote:
<span class="quote">&gt; On 2015-06-06 14:48, Russell King - ARM Linux wrote:</span>
<span class="quote">&gt;&gt; On Sat, Jun 06, 2015 at 02:31:28PM +0200, Stefan Agner wrote:</span>
<span class="quote">&gt; &lt;snip&gt;</span>
<span class="quote">&gt;&gt;&gt; --- a/arch/arm/include/asm/fixmap.h</span>
<span class="quote">&gt;&gt;&gt; +++ b/arch/arm/include/asm/fixmap.h</span>
<span class="quote">&gt;&gt;&gt; @@ -6,9 +6,13 @@</span>
<span class="quote">&gt;&gt;&gt;  #define FIXADDR_TOP         (FIXADDR_END - PAGE_SIZE)</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;  #include &lt;asm/kmap_types.h&gt;</span>
<span class="quote">&gt;&gt;&gt; +#include &lt;asm/pgtable.h&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;  enum fixed_addresses {</span>
<span class="quote">&gt;&gt;&gt; -    FIX_KMAP_BEGIN,</span>
<span class="quote">&gt;&gt;&gt; +    FIX_EARLYCON_MEM_BASE,</span>
<span class="quote">&gt;&gt;&gt; +    __end_of_permanent_fixed_addresses,</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +    FIX_KMAP_BEGIN = __end_of_permanent_fixed_addresses,</span>
<span class="quote">&gt;&gt;&gt;      FIX_KMAP_END = FIX_KMAP_BEGIN + (KM_TYPE_NR * NR_CPUS) - 1,</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;      /* Support writing RO kernel text via kprobes, jump labels, etc. */</span>
<span class="quote">&gt;&gt;&gt; @@ -18,7 +22,14 @@ enum fixed_addresses {</span>
<span class="quote">&gt;&gt;&gt;      __end_of_fixed_addresses</span>
<span class="quote">&gt;&gt;&gt;  };</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; +#define FIXMAP_PAGE_COMMON  (L_PTE_YOUNG | L_PTE_PRESENT | L_PTE_XN | L_PTE_DIRTY)</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +#define FIXMAP_PAGE_NORMAL  (FIXMAP_PAGE_COMMON | L_PTE_MT_WRITEBACK)</span>
<span class="quote">&gt;&gt;&gt; +#define FIXMAP_PAGE_IO              (FIXMAP_PAGE_COMMON | L_PTE_MT_DEV_SHARED | L_PTE_SHARED)</span>
<span class="quote">&gt;&gt;&gt; +#define FIXMAP_PAGE_NOCACHE FIXMAP_PAGE_IO</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I&#39;m really not happy with this.  What are the expected semantics of the</span>
<span class="quote">&gt;&gt; set_fixmap_nocache() and set_fixmap_offset_nocache() ?  Are they there</span>
<span class="quote">&gt;&gt; for mapping a device, or are they there for mapping _memory_ ?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I would prefer that FIXMAP_PAGE_NOCACHE is _not_ provided until the</span>
<span class="quote">&gt;&gt; semantics of that can be clarified, as there is a difference between the</span>
<span class="quote">&gt;&gt; two on ARM.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; set_fixmap_nocache is used for PCIe and IO APIC stuff, so actually IO</span>
<span class="quote">&gt; devices. However, as far as I understand the x86 page table definitions</span>
<span class="quote">&gt; in pgtable_types.h, IO devices are not explicitly uncached on x86. The</span>
<span class="quote">&gt; define set_fixmap_nocache make sure IO devices are mapped uncached...</span>
<span class="quote">&gt; Maybe set_fixmap_io_nocache instead of set_fixmap_nocache would be more</span>
<span class="quote">&gt; appropriate...?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Maybe the initial authors of the common fixmap.h have a more clear</span>
<span class="quote">&gt; understanding of the expected semantics, Mark?</span>

They should be the same as ioremap and ioremap_nocache which are
aliases of each other on ARM. If you want RAM then you should be using
FIXMAP_PAGE_NORMAL. Perhaps we can come up with some error checking
here.
<span class="quote">
&gt; Since the focus currently is on set_fixmap_io, we could define</span>
<span class="quote">&gt; FIXMAP_PAGE_IO only for the time being...?</span>

We could, but I think it is better to sort this out now.

Rob
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=2518">Mark Salter</a> - June 8, 2015, 2:05 p.m.</div>
<pre class="content">
On Sat, 2015-06-06 at 10:29 -0500, Rob Herring wrote:
<span class="quote">&gt; On Sat, Jun 6, 2015 at 8:29 AM, Stefan Agner &lt;stefan@agner.ch&gt; wrote:</span>
<span class="quote">&gt; &gt; On 2015-06-06 14:48, Russell King - ARM Linux wrote:</span>
<span class="quote">&gt; &gt;&gt; On Sat, Jun 06, 2015 at 02:31:28PM +0200, Stefan Agner wrote:</span>
<span class="quote">&gt; &gt; &lt;snip&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; --- a/arch/arm/include/asm/fixmap.h</span>
<span class="quote">&gt; &gt;&gt;&gt; +++ b/arch/arm/include/asm/fixmap.h</span>
<span class="quote">&gt; &gt;&gt;&gt; @@ -6,9 +6,13 @@</span>
<span class="quote">&gt; &gt;&gt;&gt;  #define FIXADDR_TOP         (FIXADDR_END - PAGE_SIZE)</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;  #include &lt;asm/kmap_types.h&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; +#include &lt;asm/pgtable.h&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;  enum fixed_addresses {</span>
<span class="quote">&gt; &gt;&gt;&gt; -    FIX_KMAP_BEGIN,</span>
<span class="quote">&gt; &gt;&gt;&gt; +    FIX_EARLYCON_MEM_BASE,</span>
<span class="quote">&gt; &gt;&gt;&gt; +    __end_of_permanent_fixed_addresses,</span>
<span class="quote">&gt; &gt;&gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt;&gt; +    FIX_KMAP_BEGIN = __end_of_permanent_fixed_addresses,</span>
<span class="quote">&gt; &gt;&gt;&gt;      FIX_KMAP_END = FIX_KMAP_BEGIN + (KM_TYPE_NR * NR_CPUS) - 1,</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;      /* Support writing RO kernel text via kprobes, jump labels, etc. */</span>
<span class="quote">&gt; &gt;&gt;&gt; @@ -18,7 +22,14 @@ enum fixed_addresses {</span>
<span class="quote">&gt; &gt;&gt;&gt;      __end_of_fixed_addresses</span>
<span class="quote">&gt; &gt;&gt;&gt;  };</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; +#define FIXMAP_PAGE_COMMON  (L_PTE_YOUNG | L_PTE_PRESENT | L_PTE_XN | L_PTE_DIRTY)</span>
<span class="quote">&gt; &gt;&gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt;&gt; +#define FIXMAP_PAGE_NORMAL  (FIXMAP_PAGE_COMMON | L_PTE_MT_WRITEBACK)</span>
<span class="quote">&gt; &gt;&gt;&gt; +#define FIXMAP_PAGE_IO              (FIXMAP_PAGE_COMMON | L_PTE_MT_DEV_SHARED | L_PTE_SHARED)</span>
<span class="quote">&gt; &gt;&gt;&gt; +#define FIXMAP_PAGE_NOCACHE FIXMAP_PAGE_IO</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; I&#39;m really not happy with this.  What are the expected semantics of the</span>
<span class="quote">&gt; &gt;&gt; set_fixmap_nocache() and set_fixmap_offset_nocache() ?  Are they there</span>
<span class="quote">&gt; &gt;&gt; for mapping a device, or are they there for mapping _memory_ ?</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; I would prefer that FIXMAP_PAGE_NOCACHE is _not_ provided until the</span>
<span class="quote">&gt; &gt;&gt; semantics of that can be clarified, as there is a difference between the</span>
<span class="quote">&gt; &gt;&gt; two on ARM.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; set_fixmap_nocache is used for PCIe and IO APIC stuff, so actually IO</span>
<span class="quote">&gt; &gt; devices. However, as far as I understand the x86 page table definitions</span>
<span class="quote">&gt; &gt; in pgtable_types.h, IO devices are not explicitly uncached on x86. The</span>
<span class="quote">&gt; &gt; define set_fixmap_nocache make sure IO devices are mapped uncached...</span>
<span class="quote">&gt; &gt; Maybe set_fixmap_io_nocache instead of set_fixmap_nocache would be more</span>
<span class="quote">&gt; &gt; appropriate...?</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Maybe the initial authors of the common fixmap.h have a more clear</span>
<span class="quote">&gt; &gt; understanding of the expected semantics, Mark?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; They should be the same as ioremap and ioremap_nocache which are</span>
<span class="quote">&gt; aliases of each other on ARM. If you want RAM then you should be using</span>
<span class="quote">&gt; FIXMAP_PAGE_NORMAL. Perhaps we can come up with some error checking</span>
<span class="quote">&gt; here.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; Since the focus currently is on set_fixmap_io, we could define</span>
<span class="quote">&gt; &gt; FIXMAP_PAGE_IO only for the time being...?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; We could, but I think it is better to sort this out now.</span>
<span class="quote">&gt; </span>

I agree with Rob here. AFAICT, x86 is the only arch which actually uses
set_fixmap_nocache. Other arches created definitions for it, but all
uses appear to depend on CONFIG_X86.


--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=709">Russell King - ARM Linux</a> - July 10, 2015, 11:25 a.m.</div>
<pre class="content">
On Sat, Jun 06, 2015 at 01:48:00PM +0100, Russell King - ARM Linux wrote:
<span class="quote">&gt; On Sat, Jun 06, 2015 at 02:31:28PM +0200, Stefan Agner wrote:</span>
<span class="quote">&gt; &gt; @@ -1231,7 +1272,7 @@ static void __init devicemaps_init(const struct machine_desc *mdesc)</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	early_trap_init(vectors);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; -	for (addr = VMALLOC_START; addr; addr += PMD_SIZE)</span>
<span class="quote">&gt; &gt; +	for (addr = VMALLOC_START; addr &lt; FIXADDR_START; addr += PMD_SIZE)</span>
<span class="quote">&gt; &gt;  		pmd_clear(pmd_off_k(addr));</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; You introduce a bug here - we no logner clear the very top entry of the</span>
<span class="quote">&gt; page tables, which means it could contain anything - and means that the</span>
<span class="quote">&gt; subsequent creation of the L2 table in early_pte_alloc() can fail.</span>

You trimmed my reply hard, and seemingly ignored this; the v4 patch
contains exactly the same code here, and therefore continues to leave
the top of the page table uninitialised.

Not applying the v4 patch, sorry.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=71861">Stefan Agner</a> - July 13, 2015, 7:48 p.m.</div>
<pre class="content">
On 2015-07-10 13:25, Russell King - ARM Linux wrote:
<span class="quote">&gt; On Sat, Jun 06, 2015 at 01:48:00PM +0100, Russell King - ARM Linux wrote:</span>
<span class="quote">&gt;&gt; On Sat, Jun 06, 2015 at 02:31:28PM +0200, Stefan Agner wrote:</span>
<span class="quote">&gt;&gt; &gt; @@ -1231,7 +1272,7 @@ static void __init devicemaps_init(const struct machine_desc *mdesc)</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt;  	early_trap_init(vectors);</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; -	for (addr = VMALLOC_START; addr; addr += PMD_SIZE)</span>
<span class="quote">&gt;&gt; &gt; +	for (addr = VMALLOC_START; addr &lt; FIXADDR_START; addr += PMD_SIZE)</span>
<span class="quote">&gt;&gt; &gt;  		pmd_clear(pmd_off_k(addr));</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; You introduce a bug here - we no logner clear the very top entry of the</span>
<span class="quote">&gt;&gt; page tables, which means it could contain anything - and means that the</span>
<span class="quote">&gt;&gt; subsequent creation of the L2 table in early_pte_alloc() can fail.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; You trimmed my reply hard, and seemingly ignored this; the v4 patch</span>
<span class="quote">&gt; contains exactly the same code here, and therefore continues to leave</span>
<span class="quote">&gt; the top of the page table uninitialised.</span>

Maybe I get something wrong here, but the very top PMD is left out on
purpose, since early_fixmap_shutdown takes care of that.

However v3 also did not clear the second to top PMD. I thought I did
take care of that by using this slightly different for loop in v4:
for (addr = VMALLOC_START; addr &lt; (FIXADDR_TOP &amp; PMD_MASK); addr +=
PMD_SIZE)

However, looking now at the code I&#39;m not sure if this is right either. 

I think what is needed is addr &lt; (FIXADDR_TOP &amp; ~PMD_MASK). This will
make sure that only the top PMD is not cleared, which is taken care of
by early fixmap...

--
Stefan
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig</span>
<span class="p_header">index d0950ce..ef164a7 100644</span>
<span class="p_header">--- a/arch/arm/Kconfig</span>
<span class="p_header">+++ b/arch/arm/Kconfig</span>
<span class="p_chunk">@@ -186,6 +186,9 @@</span> <span class="p_context"> config ARCH_HAS_ILOG2_U64</span>
 config ARCH_HAS_BANDGAP
 	bool
 
<span class="p_add">+config FIX_EARLYCON_MEM</span>
<span class="p_add">+	def_bool y</span>
<span class="p_add">+</span>
 config GENERIC_HWEIGHT
 	bool
 	default y
<span class="p_header">diff --git a/arch/arm/include/asm/fixmap.h b/arch/arm/include/asm/fixmap.h</span>
<span class="p_header">index 0415eae..2d8b12b 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/fixmap.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/fixmap.h</span>
<span class="p_chunk">@@ -6,9 +6,13 @@</span> <span class="p_context"></span>
 #define FIXADDR_TOP		(FIXADDR_END - PAGE_SIZE)
 
 #include &lt;asm/kmap_types.h&gt;
<span class="p_add">+#include &lt;asm/pgtable.h&gt;</span>
 
 enum fixed_addresses {
<span class="p_del">-	FIX_KMAP_BEGIN,</span>
<span class="p_add">+	FIX_EARLYCON_MEM_BASE,</span>
<span class="p_add">+	__end_of_permanent_fixed_addresses,</span>
<span class="p_add">+</span>
<span class="p_add">+	FIX_KMAP_BEGIN = __end_of_permanent_fixed_addresses,</span>
 	FIX_KMAP_END = FIX_KMAP_BEGIN + (KM_TYPE_NR * NR_CPUS) - 1,
 
 	/* Support writing RO kernel text via kprobes, jump labels, etc. */
<span class="p_chunk">@@ -18,7 +22,14 @@</span> <span class="p_context"> enum fixed_addresses {</span>
 	__end_of_fixed_addresses
 };
 
<span class="p_add">+#define FIXMAP_PAGE_COMMON	(L_PTE_YOUNG | L_PTE_PRESENT | L_PTE_XN | L_PTE_DIRTY)</span>
<span class="p_add">+</span>
<span class="p_add">+#define FIXMAP_PAGE_NORMAL	(FIXMAP_PAGE_COMMON | L_PTE_MT_WRITEBACK)</span>
<span class="p_add">+#define FIXMAP_PAGE_IO		(FIXMAP_PAGE_COMMON | L_PTE_MT_DEV_SHARED | L_PTE_SHARED)</span>
<span class="p_add">+#define FIXMAP_PAGE_NOCACHE	FIXMAP_PAGE_IO</span>
<span class="p_add">+</span>
 void __set_fixmap(enum fixed_addresses idx, phys_addr_t phys, pgprot_t prot);
<span class="p_add">+void __init early_fixmap_init(void);</span>
 
 #include &lt;asm-generic/fixmap.h&gt;
 
<span class="p_header">diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c</span>
<span class="p_header">index e6d8c76..6f03beb 100644</span>
<span class="p_header">--- a/arch/arm/kernel/setup.c</span>
<span class="p_header">+++ b/arch/arm/kernel/setup.c</span>
<span class="p_chunk">@@ -37,6 +37,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/cpu.h&gt;
 #include &lt;asm/cputype.h&gt;
 #include &lt;asm/elf.h&gt;
<span class="p_add">+#include &lt;asm/fixmap.h&gt;</span>
 #include &lt;asm/procinfo.h&gt;
 #include &lt;asm/psci.h&gt;
 #include &lt;asm/sections.h&gt;
<span class="p_chunk">@@ -953,6 +954,8 @@</span> <span class="p_context"> void __init setup_arch(char **cmdline_p)</span>
 	strlcpy(cmd_line, boot_command_line, COMMAND_LINE_SIZE);
 	*cmdline_p = cmd_line;
 
<span class="p_add">+	early_fixmap_init();</span>
<span class="p_add">+</span>
 	parse_early_param();
 
 #ifdef CONFIG_MMU
<span class="p_header">diff --git a/arch/arm/mm/highmem.c b/arch/arm/mm/highmem.c</span>
<span class="p_header">index b98895d..c7097f9 100644</span>
<span class="p_header">--- a/arch/arm/mm/highmem.c</span>
<span class="p_header">+++ b/arch/arm/mm/highmem.c</span>
<span class="p_chunk">@@ -78,7 +78,7 @@</span> <span class="p_context"> void *kmap_atomic(struct page *page)</span>
 
 	type = kmap_atomic_idx_push();
 
<span class="p_del">-	idx = type + KM_TYPE_NR * smp_processor_id();</span>
<span class="p_add">+	idx = FIX_KMAP_BEGIN + type + KM_TYPE_NR * smp_processor_id();</span>
 	vaddr = __fix_to_virt(idx);
 #ifdef CONFIG_DEBUG_HIGHMEM
 	/*
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> void __kunmap_atomic(void *kvaddr)</span>
 
 	if (kvaddr &gt;= (void *)FIXADDR_START) {
 		type = kmap_atomic_idx();
<span class="p_del">-		idx = type + KM_TYPE_NR * smp_processor_id();</span>
<span class="p_add">+		idx = FIX_KMAP_BEGIN + type + KM_TYPE_NR * smp_processor_id();</span>
 
 		if (cache_is_vivt())
 			__cpuc_flush_dcache_area((void *)vaddr, PAGE_SIZE);
<span class="p_chunk">@@ -135,7 +135,7 @@</span> <span class="p_context"> void *kmap_atomic_pfn(unsigned long pfn)</span>
 		return page_address(page);
 
 	type = kmap_atomic_idx_push();
<span class="p_del">-	idx = type + KM_TYPE_NR * smp_processor_id();</span>
<span class="p_add">+	idx = FIX_KMAP_BEGIN + type + KM_TYPE_NR * smp_processor_id();</span>
 	vaddr = __fix_to_virt(idx);
 #ifdef CONFIG_DEBUG_HIGHMEM
 	BUG_ON(!pte_none(get_fixmap_pte(vaddr)));
<span class="p_header">diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c</span>
<span class="p_header">index 6ca7d9a..d3e9702 100644</span>
<span class="p_header">--- a/arch/arm/mm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/mm/mmu.c</span>
<span class="p_chunk">@@ -357,6 +357,47 @@</span> <span class="p_context"> const struct mem_type *get_mem_type(unsigned int type)</span>
 }
 EXPORT_SYMBOL(get_mem_type);
 
<span class="p_add">+static pte_t *(*pte_offset_fixmap)(pmd_t *dir, unsigned long addr);</span>
<span class="p_add">+</span>
<span class="p_add">+static pte_t bm_pte[PTRS_PER_PTE + PTE_HWTABLE_PTRS]</span>
<span class="p_add">+	__aligned(PTE_HWTABLE_OFF + PTE_HWTABLE_SIZE) __initdata;</span>
<span class="p_add">+</span>
<span class="p_add">+static pte_t * __init pte_offset_early_fixmap(pmd_t *dir, unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return &amp;bm_pte[pte_index(addr)];</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static pte_t *pte_offset_late_fixmap(pmd_t *dir, unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return pte_offset_kernel(dir, addr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline pmd_t * __init fixmap_pmd(unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pgd_t *pgd = pgd_offset_k(addr);</span>
<span class="p_add">+	pud_t *pud = pud_offset(pgd, addr);</span>
<span class="p_add">+	pmd_t *pmd = pmd_offset(pud, addr);</span>
<span class="p_add">+</span>
<span class="p_add">+	return pmd;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init early_fixmap_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pmd_t *pmd;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The early fixmap range spans multiple pmds, for which</span>
<span class="p_add">+	 * we are not prepared:</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	BUILD_BUG_ON((__fix_to_virt(__end_of_permanent_fixed_addresses) &gt;&gt; PMD_SHIFT)</span>
<span class="p_add">+		     != FIXADDR_TOP &gt;&gt; PMD_SHIFT);</span>
<span class="p_add">+</span>
<span class="p_add">+	pmd = fixmap_pmd(FIXADDR_TOP);</span>
<span class="p_add">+	pmd_populate_kernel(&amp;init_mm, pmd, bm_pte);</span>
<span class="p_add">+</span>
<span class="p_add">+	pte_offset_fixmap = &amp;pte_offset_early_fixmap;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * To avoid TLB flush broadcasts, this uses local_flush_tlb_kernel_range().
  * As a result, this can only be called with preemption disabled, as under
<span class="p_chunk">@@ -365,7 +406,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(get_mem_type);</span>
 void __set_fixmap(enum fixed_addresses idx, phys_addr_t phys, pgprot_t prot)
 {
 	unsigned long vaddr = __fix_to_virt(idx);
<span class="p_del">-	pte_t *pte = pte_offset_kernel(pmd_off_k(vaddr), vaddr);</span>
<span class="p_add">+	pte_t *pte = pte_offset_fixmap(pmd_off_k(vaddr), vaddr);</span>
 
 	/* Make sure fixmap region does not exceed available allocation. */
 	BUILD_BUG_ON(FIXADDR_START + (__end_of_fixed_addresses * PAGE_SIZE) &gt;
<span class="p_chunk">@@ -855,7 +896,7 @@</span> <span class="p_context"> static void __init create_mapping(struct map_desc *md)</span>
 	}
 
 	if ((md-&gt;type == MT_DEVICE || md-&gt;type == MT_ROM) &amp;&amp;
<span class="p_del">-	    md-&gt;virtual &gt;= PAGE_OFFSET &amp;&amp;</span>
<span class="p_add">+	    md-&gt;virtual &gt;= PAGE_OFFSET &amp;&amp; md-&gt;virtual &lt; FIXADDR_START &amp;&amp;</span>
 	    (md-&gt;virtual &lt; VMALLOC_START || md-&gt;virtual &gt;= VMALLOC_END)) {
 		pr_warn(&quot;BUG: mapping for 0x%08llx at 0x%08lx out of vmalloc space\n&quot;,
 			(long long)__pfn_to_phys((u64)md-&gt;pfn), md-&gt;virtual);
<span class="p_chunk">@@ -1231,7 +1272,7 @@</span> <span class="p_context"> static void __init devicemaps_init(const struct machine_desc *mdesc)</span>
 
 	early_trap_init(vectors);
 
<span class="p_del">-	for (addr = VMALLOC_START; addr; addr += PMD_SIZE)</span>
<span class="p_add">+	for (addr = VMALLOC_START; addr &lt; FIXADDR_START; addr += PMD_SIZE)</span>
 		pmd_clear(pmd_off_k(addr));
 
 	/*
<span class="p_chunk">@@ -1483,6 +1524,36 @@</span> <span class="p_context"> void __init early_paging_init(const struct machine_desc *mdesc)</span>
 
 #endif
 
<span class="p_add">+static void __init early_fixmap_shutdown(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	unsigned long va = fix_to_virt(__end_of_permanent_fixed_addresses - 1);</span>
<span class="p_add">+</span>
<span class="p_add">+	pte_offset_fixmap = &amp;pte_offset_late_fixmap;</span>
<span class="p_add">+	pmd_clear(fixmap_pmd(va));</span>
<span class="p_add">+	local_flush_tlb_kernel_page(va);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; __end_of_permanent_fixed_addresses; i++) {</span>
<span class="p_add">+		pte_t *pte;</span>
<span class="p_add">+		struct map_desc map;</span>
<span class="p_add">+</span>
<span class="p_add">+		map.virtual = fix_to_virt(i);</span>
<span class="p_add">+		pte = pte_offset_early_fixmap(pmd_off_k(map.virtual), map.virtual);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Only i/o device mappings are supported ATM */</span>
<span class="p_add">+		if (pte_none(*pte) ||</span>
<span class="p_add">+		    (pte_val(*pte) &amp; L_PTE_MT_MASK) != L_PTE_MT_DEV_SHARED)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		map.pfn = pte_pfn(*pte);</span>
<span class="p_add">+		map.type = MT_DEVICE;</span>
<span class="p_add">+		map.length = PAGE_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+		create_mapping(&amp;map);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 /*
  * paging_init() sets up the page tables, initialises the zone memory
  * maps, and sets up the zero page, bad page and bad page tables.
<span class="p_chunk">@@ -1495,6 +1566,7 @@</span> <span class="p_context"> void __init paging_init(const struct machine_desc *mdesc)</span>
 	prepare_page_table();
 	map_lowmem();
 	dma_contiguous_remap();
<span class="p_add">+	early_fixmap_shutdown();</span>
 	devicemaps_init(mdesc);
 	kmap_init();
 	tcm_init();

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



