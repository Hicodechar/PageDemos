
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.1 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.1</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 31, 2016, 7:34 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160131193419.GB26943@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8174901/mbox/"
   >mbox</a>
|
   <a href="/patch/8174901/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8174901/">/patch/8174901/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 1C19A9F96D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 31 Jan 2016 19:34:41 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 76550202EC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 31 Jan 2016 19:34:36 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 7B1B420256
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 31 Jan 2016 19:34:31 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S964793AbcAaTe0 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 31 Jan 2016 14:34:26 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:60909 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S933272AbcAaTeU (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 31 Jan 2016 14:34:20 -0500
Received: from localhost (c-50-170-35-168.hsd1.wa.comcast.net
	[50.170.35.168])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 20664D4F;
	Sun, 31 Jan 2016 19:34:20 +0000 (UTC)
Date: Sun, 31 Jan 2016 11:34:19 -0800
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.1
Message-ID: &lt;20160131193419.GB26943@kroah.com&gt;
References: &lt;20160131193412.GA26943@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20160131193412.GA26943@kroah.com&gt;
User-Agent: Mutt/1.5.24 (2015-08-30)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.5 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Jan. 31, 2016, 7:34 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/ABI/testing/sysfs-bus-usb b/Documentation/ABI/testing/sysfs-bus-usb</span>
<span class="p_header">index 3a4abfc44f5e..136ba17d2da0 100644</span>
<span class="p_header">--- a/Documentation/ABI/testing/sysfs-bus-usb</span>
<span class="p_header">+++ b/Documentation/ABI/testing/sysfs-bus-usb</span>
<span class="p_chunk">@@ -134,19 +134,21 @@</span> <span class="p_context"> Description:</span>
 		enabled for the device. Developer can write y/Y/1 or n/N/0 to
 		the file to enable/disable the feature.
 
<span class="p_del">-What:		/sys/bus/usb/devices/.../power/usb3_hardware_lpm</span>
<span class="p_del">-Date:		June 2015</span>
<span class="p_add">+What:		/sys/bus/usb/devices/.../power/usb3_hardware_lpm_u1</span>
<span class="p_add">+		/sys/bus/usb/devices/.../power/usb3_hardware_lpm_u2</span>
<span class="p_add">+Date:		November 2015</span>
 Contact:	Kevin Strasser &lt;kevin.strasser@linux.intel.com&gt;
<span class="p_add">+		Lu Baolu &lt;baolu.lu@linux.intel.com&gt;</span>
 Description:
 		If CONFIG_PM is set and a USB 3.0 lpm-capable device is plugged
 		in to a xHCI host which supports link PM, it will check if U1
 		and U2 exit latencies have been set in the BOS descriptor; if
<span class="p_del">-		the check is is passed and the host supports USB3 hardware LPM,</span>
<span class="p_add">+		the check is passed and the host supports USB3 hardware LPM,</span>
 		USB3 hardware LPM will be enabled for the device and the USB
<span class="p_del">-		device directory will contain a file named</span>
<span class="p_del">-		power/usb3_hardware_lpm. The file holds a string value (enable</span>
<span class="p_del">-		or disable) indicating whether or not USB3 hardware LPM is</span>
<span class="p_del">-		enabled for the device.</span>
<span class="p_add">+		device directory will contain two files named</span>
<span class="p_add">+		power/usb3_hardware_lpm_u1 and power/usb3_hardware_lpm_u2. These</span>
<span class="p_add">+		files hold a string value (enable or disable) indicating whether</span>
<span class="p_add">+		or not USB3 hardware LPM U1 or U2 is enabled for the device.</span>
 
 What:		/sys/bus/usb/devices/.../removable
 Date:		February 2012
<span class="p_header">diff --git a/Documentation/usb/power-management.txt b/Documentation/usb/power-management.txt</span>
<span class="p_header">index 4a15c90bc11d..0a94ffe17ab6 100644</span>
<span class="p_header">--- a/Documentation/usb/power-management.txt</span>
<span class="p_header">+++ b/Documentation/usb/power-management.txt</span>
<span class="p_chunk">@@ -537,17 +537,18 @@</span> <span class="p_context"> relevant attribute files are usb2_hardware_lpm and usb3_hardware_lpm.</span>
 		can write y/Y/1 or n/N/0 to the file to	enable/disable
 		USB2 hardware LPM manually. This is for	test purpose mainly.
 
<span class="p_del">-	power/usb3_hardware_lpm</span>
<span class="p_add">+	power/usb3_hardware_lpm_u1</span>
<span class="p_add">+	power/usb3_hardware_lpm_u2</span>
 
 		When a USB 3.0 lpm-capable device is plugged in to a
 		xHCI host which supports link PM, it will check if U1
 		and U2 exit latencies have been set in the BOS
 		descriptor; if the check is is passed and the host
 		supports USB3 hardware LPM, USB3 hardware LPM will be
<span class="p_del">-		enabled for the device and this file will be created.</span>
<span class="p_del">-		The file holds a string value (enable or disable)</span>
<span class="p_del">-		indicating whether or not USB3 hardware LPM is</span>
<span class="p_del">-		enabled for the device.</span>
<span class="p_add">+		enabled for the device and these files will be created.</span>
<span class="p_add">+		The files hold a string value (enable or disable)</span>
<span class="p_add">+		indicating whether or not USB3 hardware LPM U1 or U2</span>
<span class="p_add">+		is enabled for the device.</span>
 
 	USB Port Power Control
 	----------------------
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 70dea02f1346..c6a265b52c93 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 0</span>
<span class="p_add">+SUBLEVEL = 1</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arm64/kernel/head.S b/arch/arm64/kernel/head.S</span>
<span class="p_header">index 23cfc08fc8ba..b685257926f0 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/head.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/head.S</span>
<span class="p_chunk">@@ -512,9 +512,14 @@</span> <span class="p_context"> CPU_LE(	movk	x0, #0x30d0, lsl #16	)	// Clear EE and E0E on LE systems</span>
 #endif
 
 	/* EL2 debug */
<span class="p_add">+	mrs	x0, id_aa64dfr0_el1		// Check ID_AA64DFR0_EL1 PMUVer</span>
<span class="p_add">+	sbfx	x0, x0, #8, #4</span>
<span class="p_add">+	cmp	x0, #1</span>
<span class="p_add">+	b.lt	4f				// Skip if no PMU present</span>
 	mrs	x0, pmcr_el0			// Disable debug access traps
 	ubfx	x0, x0, #11, #5			// to EL2 and allow access to
 	msr	mdcr_el2, x0			// all PMU counters from EL1
<span class="p_add">+4:</span>
 
 	/* Stage-2 translation */
 	msr	vttbr_el2, xzr
<span class="p_header">diff --git a/arch/arm64/kernel/perf_event.c b/arch/arm64/kernel/perf_event.c</span>
<span class="p_header">index 5b1897e8ca24..62d3dc60ca09 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/perf_event.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/perf_event.c</span>
<span class="p_chunk">@@ -574,9 +574,6 @@</span> <span class="p_context"> static void armv8pmu_reset(void *info)</span>
 
 	/* Initialize &amp; Reset PMNC: C and P bits. */
 	armv8pmu_pmcr_write(ARMV8_PMCR_P | ARMV8_PMCR_C);
<span class="p_del">-</span>
<span class="p_del">-	/* Disable access from userspace. */</span>
<span class="p_del">-	asm volatile(&quot;msr pmuserenr_el0, %0&quot; :: &quot;r&quot; (0));</span>
 }
 
 static int armv8_pmuv3_map_event(struct perf_event *event)
<span class="p_header">diff --git a/arch/arm64/kernel/ptrace.c b/arch/arm64/kernel/ptrace.c</span>
<span class="p_header">index 1971f491bb90..ff7f13239515 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/ptrace.c</span>
<span class="p_chunk">@@ -58,6 +58,12 @@</span> <span class="p_context"></span>
  */
 void ptrace_disable(struct task_struct *child)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This would be better off in core code, but PTRACE_DETACH has</span>
<span class="p_add">+	 * grown its fair share of arch-specific worts and changing it</span>
<span class="p_add">+	 * is likely to cause regressions on obscure architectures.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	user_disable_single_step(child);</span>
 }
 
 #ifdef CONFIG_HAVE_HW_BREAKPOINT
<span class="p_header">diff --git a/arch/arm64/mm/mmu.c b/arch/arm64/mm/mmu.c</span>
<span class="p_header">index 873e363048c6..116ad654dd59 100644</span>
<span class="p_header">--- a/arch/arm64/mm/mmu.c</span>
<span class="p_header">+++ b/arch/arm64/mm/mmu.c</span>
<span class="p_chunk">@@ -456,6 +456,9 @@</span> <span class="p_context"> void __init paging_init(void)</span>
 
 	empty_zero_page = virt_to_page(zero_page);
 
<span class="p_add">+	/* Ensure the zero page is visible to the page table walker */</span>
<span class="p_add">+	dsb(ishst);</span>
<span class="p_add">+</span>
 	/*
 	 * TTBR0 is only used for the identity mapping at this stage. Make it
 	 * point to zero page to avoid speculatively fetching new entries.
<span class="p_header">diff --git a/arch/arm64/mm/proc-macros.S b/arch/arm64/mm/proc-macros.S</span>
<span class="p_header">index 4c4d93c4bf65..d69dffffaa89 100644</span>
<span class="p_header">--- a/arch/arm64/mm/proc-macros.S</span>
<span class="p_header">+++ b/arch/arm64/mm/proc-macros.S</span>
<span class="p_chunk">@@ -62,3 +62,15 @@</span> <span class="p_context"></span>
 	bfi	\valreg, \tmpreg, #TCR_T0SZ_OFFSET, #TCR_TxSZ_WIDTH
 #endif
 	.endm
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * reset_pmuserenr_el0 - reset PMUSERENR_EL0 if PMUv3 present</span>
<span class="p_add">+ */</span>
<span class="p_add">+	.macro	reset_pmuserenr_el0, tmpreg</span>
<span class="p_add">+	mrs	\tmpreg, id_aa64dfr0_el1	// Check ID_AA64DFR0_EL1 PMUVer</span>
<span class="p_add">+	sbfx	\tmpreg, \tmpreg, #8, #4</span>
<span class="p_add">+	cmp	\tmpreg, #1			// Skip if no PMU present</span>
<span class="p_add">+	b.lt	9000f</span>
<span class="p_add">+	msr	pmuserenr_el0, xzr		// Disable PMU access from EL0</span>
<span class="p_add">+9000:</span>
<span class="p_add">+	.endm</span>
<span class="p_header">diff --git a/arch/arm64/mm/proc.S b/arch/arm64/mm/proc.S</span>
<span class="p_header">index cacecc4ad3e5..b8f04b3f2786 100644</span>
<span class="p_header">--- a/arch/arm64/mm/proc.S</span>
<span class="p_header">+++ b/arch/arm64/mm/proc.S</span>
<span class="p_chunk">@@ -117,6 +117,7 @@</span> <span class="p_context"> ENTRY(cpu_do_resume)</span>
 	 */
 	ubfx	x11, x11, #1, #1
 	msr	oslar_el1, x11
<span class="p_add">+	reset_pmuserenr_el0 x0			// Disable PMU access from EL0</span>
 	mov	x0, x12
 	dsb	nsh		// Make sure local tlb invalidation completed
 	isb
<span class="p_chunk">@@ -155,6 +156,7 @@</span> <span class="p_context"> ENTRY(__cpu_setup)</span>
 	msr	cpacr_el1, x0			// Enable FP/ASIMD
 	mov	x0, #1 &lt;&lt; 12			// Reset mdscr_el1 and disable
 	msr	mdscr_el1, x0			// access to the DCC from EL0
<span class="p_add">+	reset_pmuserenr_el0 x0			// Disable PMU access from EL0</span>
 	/*
 	 * Memory region attributes for LPAE:
 	 *
<span class="p_header">diff --git a/arch/powerpc/include/asm/cmpxchg.h b/arch/powerpc/include/asm/cmpxchg.h</span>
<span class="p_header">index ad6263cffb0f..d1a8d93cccfd 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/cmpxchg.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/cmpxchg.h</span>
<span class="p_chunk">@@ -18,12 +18,12 @@</span> <span class="p_context"> __xchg_u32(volatile void *p, unsigned long val)</span>
 	unsigned long prev;
 
 	__asm__ __volatile__(
<span class="p_del">-	PPC_RELEASE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_ENTRY_BARRIER</span>
 &quot;1:	lwarx	%0,0,%2 \n&quot;
 	PPC405_ERR77(0,%2)
 &quot;	stwcx.	%3,0,%2 \n\
 	bne-	1b&quot;
<span class="p_del">-	PPC_ACQUIRE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_EXIT_BARRIER</span>
 	: &quot;=&amp;r&quot; (prev), &quot;+m&quot; (*(volatile unsigned int *)p)
 	: &quot;r&quot; (p), &quot;r&quot; (val)
 	: &quot;cc&quot;, &quot;memory&quot;);
<span class="p_chunk">@@ -61,12 +61,12 @@</span> <span class="p_context"> __xchg_u64(volatile void *p, unsigned long val)</span>
 	unsigned long prev;
 
 	__asm__ __volatile__(
<span class="p_del">-	PPC_RELEASE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_ENTRY_BARRIER</span>
 &quot;1:	ldarx	%0,0,%2 \n&quot;
 	PPC405_ERR77(0,%2)
 &quot;	stdcx.	%3,0,%2 \n\
 	bne-	1b&quot;
<span class="p_del">-	PPC_ACQUIRE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_EXIT_BARRIER</span>
 	: &quot;=&amp;r&quot; (prev), &quot;+m&quot; (*(volatile unsigned long *)p)
 	: &quot;r&quot; (p), &quot;r&quot; (val)
 	: &quot;cc&quot;, &quot;memory&quot;);
<span class="p_chunk">@@ -151,14 +151,14 @@</span> <span class="p_context"> __cmpxchg_u32(volatile unsigned int *p, unsigned long old, unsigned long new)</span>
 	unsigned int prev;
 
 	__asm__ __volatile__ (
<span class="p_del">-	PPC_RELEASE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_ENTRY_BARRIER</span>
 &quot;1:	lwarx	%0,0,%2		# __cmpxchg_u32\n\
 	cmpw	0,%0,%3\n\
 	bne-	2f\n&quot;
 	PPC405_ERR77(0,%2)
 &quot;	stwcx.	%4,0,%2\n\
 	bne-	1b&quot;
<span class="p_del">-	PPC_ACQUIRE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_EXIT_BARRIER</span>
 	&quot;\n\
 2:&quot;
 	: &quot;=&amp;r&quot; (prev), &quot;+m&quot; (*p)
<span class="p_chunk">@@ -197,13 +197,13 @@</span> <span class="p_context"> __cmpxchg_u64(volatile unsigned long *p, unsigned long old, unsigned long new)</span>
 	unsigned long prev;
 
 	__asm__ __volatile__ (
<span class="p_del">-	PPC_RELEASE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_ENTRY_BARRIER</span>
 &quot;1:	ldarx	%0,0,%2		# __cmpxchg_u64\n\
 	cmpd	0,%0,%3\n\
 	bne-	2f\n\
 	stdcx.	%4,0,%2\n\
 	bne-	1b&quot;
<span class="p_del">-	PPC_ACQUIRE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_EXIT_BARRIER</span>
 	&quot;\n\
 2:&quot;
 	: &quot;=&amp;r&quot; (prev), &quot;+m&quot; (*p)
<span class="p_header">diff --git a/arch/powerpc/include/asm/synch.h b/arch/powerpc/include/asm/synch.h</span>
<span class="p_header">index e682a7143edb..c50868681f9e 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/synch.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/synch.h</span>
<span class="p_chunk">@@ -44,7 +44,7 @@</span> <span class="p_context"> static inline void isync(void)</span>
 	MAKE_LWSYNC_SECTION_ENTRY(97, __lwsync_fixup);
 #define PPC_ACQUIRE_BARRIER	 &quot;\n&quot; stringify_in_c(__PPC_ACQUIRE_BARRIER)
 #define PPC_RELEASE_BARRIER	 stringify_in_c(LWSYNC) &quot;\n&quot;
<span class="p_del">-#define PPC_ATOMIC_ENTRY_BARRIER &quot;\n&quot; stringify_in_c(LWSYNC) &quot;\n&quot;</span>
<span class="p_add">+#define PPC_ATOMIC_ENTRY_BARRIER &quot;\n&quot; stringify_in_c(sync) &quot;\n&quot;</span>
 #define PPC_ATOMIC_EXIT_BARRIER	 &quot;\n&quot; stringify_in_c(sync) &quot;\n&quot;
 #else
 #define PPC_ACQUIRE_BARRIER
<span class="p_header">diff --git a/arch/powerpc/include/uapi/asm/elf.h b/arch/powerpc/include/uapi/asm/elf.h</span>
<span class="p_header">index 59dad113897b..c2d21d11c2d2 100644</span>
<span class="p_header">--- a/arch/powerpc/include/uapi/asm/elf.h</span>
<span class="p_header">+++ b/arch/powerpc/include/uapi/asm/elf.h</span>
<span class="p_chunk">@@ -295,6 +295,8 @@</span> <span class="p_context"> do {									\</span>
 #define R_PPC64_TLSLD		108
 #define R_PPC64_TOCSAVE		109
 
<span class="p_add">+#define R_PPC64_ENTRY		118</span>
<span class="p_add">+</span>
 #define R_PPC64_REL16		249
 #define R_PPC64_REL16_LO	250
 #define R_PPC64_REL16_HI	251
<span class="p_header">diff --git a/arch/powerpc/kernel/module_64.c b/arch/powerpc/kernel/module_64.c</span>
<span class="p_header">index 68384514506b..59663af9315f 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/module_64.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/module_64.c</span>
<span class="p_chunk">@@ -635,6 +635,33 @@</span> <span class="p_context"> int apply_relocate_add(Elf64_Shdr *sechdrs,</span>
 			 */
 			break;
 
<span class="p_add">+		case R_PPC64_ENTRY:</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Optimize ELFv2 large code model entry point if</span>
<span class="p_add">+			 * the TOC is within 2GB range of current location.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			value = my_r2(sechdrs, me) - (unsigned long)location;</span>
<span class="p_add">+			if (value + 0x80008000 &gt; 0xffffffff)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Check for the large code model prolog sequence:</span>
<span class="p_add">+		         *	ld r2, ...(r12)</span>
<span class="p_add">+			 *	add r2, r2, r12</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if ((((uint32_t *)location)[0] &amp; ~0xfffc)</span>
<span class="p_add">+			    != 0xe84c0000)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			if (((uint32_t *)location)[1] != 0x7c426214)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * If found, replace it with:</span>
<span class="p_add">+			 *	addis r2, r12, (.TOC.-func)@ha</span>
<span class="p_add">+			 *	addi r2, r12, (.TOC.-func)@l</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			((uint32_t *)location)[0] = 0x3c4c0000 + PPC_HA(value);</span>
<span class="p_add">+			((uint32_t *)location)[1] = 0x38420000 + PPC_LO(value);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
 		case R_PPC64_REL16_HA:
 			/* Subtract location pointer */
 			value -= (unsigned long)location;
<span class="p_header">diff --git a/arch/powerpc/kernel/process.c b/arch/powerpc/kernel/process.c</span>
<span class="p_header">index 646bf4d222c1..ef2ad2d682da 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/process.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/process.c</span>
<span class="p_chunk">@@ -569,6 +569,24 @@</span> <span class="p_context"> static void tm_reclaim_thread(struct thread_struct *thr,</span>
 	if (!MSR_TM_SUSPENDED(mfmsr()))
 		return;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Use the current MSR TM suspended bit to track if we have</span>
<span class="p_add">+	 * checkpointed state outstanding.</span>
<span class="p_add">+	 * On signal delivery, we&#39;d normally reclaim the checkpointed</span>
<span class="p_add">+	 * state to obtain stack pointer (see:get_tm_stackpointer()).</span>
<span class="p_add">+	 * This will then directly return to userspace without going</span>
<span class="p_add">+	 * through __switch_to(). However, if the stack frame is bad,</span>
<span class="p_add">+	 * we need to exit this thread which calls __switch_to() which</span>
<span class="p_add">+	 * will again attempt to reclaim the already saved tm state.</span>
<span class="p_add">+	 * Hence we need to check that we&#39;ve not already reclaimed</span>
<span class="p_add">+	 * this state.</span>
<span class="p_add">+	 * We do this using the current MSR, rather tracking it in</span>
<span class="p_add">+	 * some specific thread_struct bit, as it has the additional</span>
<span class="p_add">+	 * benifit of checking for a potential TM bad thing exception.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!MSR_TM_SUSPENDED(mfmsr()))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	tm_reclaim(thr, thr-&gt;regs-&gt;msr, cause);
 
 	/* Having done the reclaim, we now have the checkpointed
<span class="p_header">diff --git a/arch/x86/include/asm/boot.h b/arch/x86/include/asm/boot.h</span>
<span class="p_header">index 4fa687a47a62..6b8d6e8cd449 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/boot.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/boot.h</span>
<span class="p_chunk">@@ -27,7 +27,7 @@</span> <span class="p_context"></span>
 #define BOOT_HEAP_SIZE             0x400000
 #else /* !CONFIG_KERNEL_BZIP2 */
 
<span class="p_del">-#define BOOT_HEAP_SIZE	0x8000</span>
<span class="p_add">+#define BOOT_HEAP_SIZE	0x10000</span>
 
 #endif /* !CONFIG_KERNEL_BZIP2 */
 
<span class="p_header">diff --git a/arch/x86/include/asm/mmu_context.h b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">index 379cd3658799..bfd9b2a35a0b 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -116,8 +116,36 @@</span> <span class="p_context"> static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
 #endif
 		cpumask_set_cpu(cpu, mm_cpumask(next));
 
<span class="p_del">-		/* Re-load page tables */</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Re-load page tables.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * This logic has an ordering constraint:</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 *  CPU 0: Write to a PTE for &#39;next&#39;</span>
<span class="p_add">+		 *  CPU 0: load bit 1 in mm_cpumask.  if nonzero, send IPI.</span>
<span class="p_add">+		 *  CPU 1: set bit 1 in next&#39;s mm_cpumask</span>
<span class="p_add">+		 *  CPU 1: load from the PTE that CPU 0 writes (implicit)</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * We need to prevent an outcome in which CPU 1 observes</span>
<span class="p_add">+		 * the new PTE value and CPU 0 observes bit 1 clear in</span>
<span class="p_add">+		 * mm_cpumask.  (If that occurs, then the IPI will never</span>
<span class="p_add">+		 * be sent, and CPU 0&#39;s TLB will contain a stale entry.)</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * The bad outcome can occur if either CPU&#39;s load is</span>
<span class="p_add">+		 * reordered before that CPU&#39;s store, so both CPUs must</span>
<span class="p_add">+		 * execute full barriers to prevent this from happening.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Thus, switch_mm needs a full barrier between the</span>
<span class="p_add">+		 * store to mm_cpumask and any operation that could load</span>
<span class="p_add">+		 * from next-&gt;pgd.  TLB fills are special and can happen</span>
<span class="p_add">+		 * due to instruction fetches or for no reason at all,</span>
<span class="p_add">+		 * and neither LOCK nor MFENCE orders them.</span>
<span class="p_add">+		 * Fortunately, load_cr3() is serializing and gives the</span>
<span class="p_add">+		 * ordering guarantee we need.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 */</span>
 		load_cr3(next-&gt;pgd);
<span class="p_add">+</span>
 		trace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);
 
 		/* Stop flush ipis for the previous mm */
<span class="p_chunk">@@ -156,10 +184,14 @@</span> <span class="p_context"> static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
 			 * schedule, protecting us from simultaneous changes.
 			 */
 			cpumask_set_cpu(cpu, mm_cpumask(next));
<span class="p_add">+</span>
 			/*
 			 * We were in lazy tlb mode and leave_mm disabled
 			 * tlb flush IPI delivery. We must reload CR3
 			 * to make sure to use no freed page tables.
<span class="p_add">+			 *</span>
<span class="p_add">+			 * As above, load_cr3() is serializing and orders TLB</span>
<span class="p_add">+			 * fills with respect to the mm_cpumask write.</span>
 			 */
 			load_cr3(next-&gt;pgd);
 			trace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);
<span class="p_header">diff --git a/arch/x86/kernel/reboot.c b/arch/x86/kernel/reboot.c</span>
<span class="p_header">index 02693dd9a079..f660d63f40fe 100644</span>
<span class="p_header">--- a/arch/x86/kernel/reboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/reboot.c</span>
<span class="p_chunk">@@ -182,6 +182,14 @@</span> <span class="p_context"> static struct dmi_system_id __initdata reboot_dmi_table[] = {</span>
 			DMI_MATCH(DMI_PRODUCT_NAME, &quot;iMac9,1&quot;),
 		},
 	},
<span class="p_add">+	{	/* Handle problems with rebooting on the iMac10,1. */</span>
<span class="p_add">+		.callback = set_pci_reboot,</span>
<span class="p_add">+		.ident = &quot;Apple iMac10,1&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+		    DMI_MATCH(DMI_SYS_VENDOR, &quot;Apple Inc.&quot;),</span>
<span class="p_add">+		    DMI_MATCH(DMI_PRODUCT_NAME, &quot;iMac10,1&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 
 	/* ASRock */
 	{	/* Handle problems with rebooting on ASRock Q1900DC-ITX */
<span class="p_header">diff --git a/arch/x86/kvm/trace.h b/arch/x86/kvm/trace.h</span>
<span class="p_header">index 120302511802..ab9ae67a80e4 100644</span>
<span class="p_header">--- a/arch/x86/kvm/trace.h</span>
<span class="p_header">+++ b/arch/x86/kvm/trace.h</span>
<span class="p_chunk">@@ -268,7 +268,7 @@</span> <span class="p_context"> TRACE_EVENT(kvm_inj_virq,</span>
 #define kvm_trace_sym_exc						\
 	EXS(DE), EXS(DB), EXS(BP), EXS(OF), EXS(BR), EXS(UD), EXS(NM),	\
 	EXS(DF), EXS(TS), EXS(NP), EXS(SS), EXS(GP), EXS(PF),		\
<span class="p_del">-	EXS(MF), EXS(MC)</span>
<span class="p_add">+	EXS(MF), EXS(AC), EXS(MC)</span>
 
 /*
  * Tracepoint for kvm interrupt injection:
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 44976a596fa6..10e7693b3540 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -8932,7 +8932,8 @@</span> <span class="p_context"> static void vmx_cpuid_update(struct kvm_vcpu *vcpu)</span>
 			best-&gt;ebx &amp;= ~bit(X86_FEATURE_INVPCID);
 	}
 
<span class="p_del">-	vmcs_set_secondary_exec_control(secondary_exec_ctl);</span>
<span class="p_add">+	if (cpu_has_secondary_exec_ctrls())</span>
<span class="p_add">+		vmcs_set_secondary_exec_control(secondary_exec_ctl);</span>
 
 	if (static_cpu_has(X86_FEATURE_PCOMMIT) &amp;&amp; nested) {
 		if (guest_cpuid_has_pcommit(vcpu))
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 97592e190413..9a2ed8904513 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -951,7 +951,7 @@</span> <span class="p_context"> static u32 msrs_to_save[] = {</span>
 	MSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,
 #endif
 	MSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,
<span class="p_del">-	MSR_IA32_FEATURE_CONTROL, MSR_IA32_BNDCFGS</span>
<span class="p_add">+	MSR_IA32_FEATURE_CONTROL, MSR_IA32_BNDCFGS, MSR_TSC_AUX,</span>
 };
 
 static unsigned num_msrs_to_save;
<span class="p_chunk">@@ -4006,16 +4006,17 @@</span> <span class="p_context"> static void kvm_init_msr_list(void)</span>
 
 		/*
 		 * Even MSRs that are valid in the host may not be exposed
<span class="p_del">-		 * to the guests in some cases.  We could work around this</span>
<span class="p_del">-		 * in VMX with the generic MSR save/load machinery, but it</span>
<span class="p_del">-		 * is not really worthwhile since it will really only</span>
<span class="p_del">-		 * happen with nested virtualization.</span>
<span class="p_add">+		 * to the guests in some cases.</span>
 		 */
 		switch (msrs_to_save[i]) {
 		case MSR_IA32_BNDCFGS:
 			if (!kvm_x86_ops-&gt;mpx_supported())
 				continue;
 			break;
<span class="p_add">+		case MSR_TSC_AUX:</span>
<span class="p_add">+			if (!kvm_x86_ops-&gt;rdtscp_supported())</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			break;</span>
 		default:
 			break;
 		}
<span class="p_header">diff --git a/arch/x86/mm/tlb.c b/arch/x86/mm/tlb.c</span>
<span class="p_header">index 8ddb5d0d66fb..8f4cc3dfac32 100644</span>
<span class="p_header">--- a/arch/x86/mm/tlb.c</span>
<span class="p_header">+++ b/arch/x86/mm/tlb.c</span>
<span class="p_chunk">@@ -161,7 +161,10 @@</span> <span class="p_context"> void flush_tlb_current_task(void)</span>
 	preempt_disable();
 
 	count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);
<span class="p_add">+</span>
<span class="p_add">+	/* This is an implicit full barrier that synchronizes with switch_mm. */</span>
 	local_flush_tlb();
<span class="p_add">+</span>
 	trace_tlb_flush(TLB_LOCAL_SHOOTDOWN, TLB_FLUSH_ALL);
 	if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) &lt; nr_cpu_ids)
 		flush_tlb_others(mm_cpumask(mm), mm, 0UL, TLB_FLUSH_ALL);
<span class="p_chunk">@@ -188,17 +191,29 @@</span> <span class="p_context"> void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,</span>
 	unsigned long base_pages_to_flush = TLB_FLUSH_ALL;
 
 	preempt_disable();
<span class="p_del">-	if (current-&gt;active_mm != mm)</span>
<span class="p_add">+	if (current-&gt;active_mm != mm) {</span>
<span class="p_add">+		/* Synchronize with switch_mm. */</span>
<span class="p_add">+		smp_mb();</span>
<span class="p_add">+</span>
 		goto out;
<span class="p_add">+	}</span>
 
 	if (!current-&gt;mm) {
 		leave_mm(smp_processor_id());
<span class="p_add">+</span>
<span class="p_add">+		/* Synchronize with switch_mm. */</span>
<span class="p_add">+		smp_mb();</span>
<span class="p_add">+</span>
 		goto out;
 	}
 
 	if ((end != TLB_FLUSH_ALL) &amp;&amp; !(vmflag &amp; VM_HUGETLB))
 		base_pages_to_flush = (end - start) &gt;&gt; PAGE_SHIFT;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Both branches below are implicit full barriers (MOV to CR or</span>
<span class="p_add">+	 * INVLPG) that synchronize with switch_mm.</span>
<span class="p_add">+	 */</span>
 	if (base_pages_to_flush &gt; tlb_single_page_flush_ceiling) {
 		base_pages_to_flush = TLB_FLUSH_ALL;
 		count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);
<span class="p_chunk">@@ -228,10 +243,18 @@</span> <span class="p_context"> void flush_tlb_page(struct vm_area_struct *vma, unsigned long start)</span>
 	preempt_disable();
 
 	if (current-&gt;active_mm == mm) {
<span class="p_del">-		if (current-&gt;mm)</span>
<span class="p_add">+		if (current-&gt;mm) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Implicit full barrier (INVLPG) that synchronizes</span>
<span class="p_add">+			 * with switch_mm.</span>
<span class="p_add">+			 */</span>
 			__flush_tlb_one(start);
<span class="p_del">-		else</span>
<span class="p_add">+		} else {</span>
 			leave_mm(smp_processor_id());
<span class="p_add">+</span>
<span class="p_add">+			/* Synchronize with switch_mm. */</span>
<span class="p_add">+			smp_mb();</span>
<span class="p_add">+		}</span>
 	}
 
 	if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) &lt; nr_cpu_ids)
<span class="p_header">diff --git a/arch/x86/xen/suspend.c b/arch/x86/xen/suspend.c</span>
<span class="p_header">index df0c40559583..7f664c416faf 100644</span>
<span class="p_header">--- a/arch/x86/xen/suspend.c</span>
<span class="p_header">+++ b/arch/x86/xen/suspend.c</span>
<span class="p_chunk">@@ -34,7 +34,8 @@</span> <span class="p_context"> static void xen_hvm_post_suspend(int suspend_cancelled)</span>
 {
 #ifdef CONFIG_XEN_PVHVM
 	int cpu;
<span class="p_del">-	xen_hvm_init_shared_info();</span>
<span class="p_add">+	if (!suspend_cancelled)</span>
<span class="p_add">+	    xen_hvm_init_shared_info();</span>
 	xen_callback_vector();
 	xen_unplug_emulated_devices();
 	if (xen_feature(XENFEAT_hvm_safe_pvclock)) {
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/cq.c b/drivers/infiniband/hw/mlx5/cq.c</span>
<span class="p_header">index 3dfd287256d6..92ddae101ecc 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/cq.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/cq.c</span>
<span class="p_chunk">@@ -756,7 +756,7 @@</span> <span class="p_context"> struct ib_cq *mlx5_ib_create_cq(struct ib_device *ibdev,</span>
 	int uninitialized_var(index);
 	int uninitialized_var(inlen);
 	int cqe_size;
<span class="p_del">-	int irqn;</span>
<span class="p_add">+	unsigned int irqn;</span>
 	int eqn;
 	int err;
 
<span class="p_header">diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c</span>
<span class="p_header">index 9e0f8a7ef8b1..f1692e418fe4 100644</span>
<span class="p_header">--- a/drivers/net/bonding/bond_main.c</span>
<span class="p_header">+++ b/drivers/net/bonding/bond_main.c</span>
<span class="p_chunk">@@ -1207,7 +1207,6 @@</span> <span class="p_context"> static int bond_master_upper_dev_link(struct net_device *bond_dev,</span>
 	err = netdev_master_upper_dev_link_private(slave_dev, bond_dev, slave);
 	if (err)
 		return err;
<span class="p_del">-	slave_dev-&gt;flags |= IFF_SLAVE;</span>
 	rtmsg_ifinfo(RTM_NEWLINK, slave_dev, IFF_SLAVE, GFP_KERNEL);
 	return 0;
 }
<span class="p_chunk">@@ -1465,6 +1464,9 @@</span> <span class="p_context"> int bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev)</span>
 		}
 	}
 
<span class="p_add">+	/* set slave flag before open to prevent IPv6 addrconf */</span>
<span class="p_add">+	slave_dev-&gt;flags |= IFF_SLAVE;</span>
<span class="p_add">+</span>
 	/* open the slave since the application closed it */
 	res = dev_open(slave_dev);
 	if (res) {
<span class="p_chunk">@@ -1725,6 +1727,7 @@</span> <span class="p_context"> err_close:</span>
 	dev_close(slave_dev);
 
 err_restore_mac:
<span class="p_add">+	slave_dev-&gt;flags &amp;= ~IFF_SLAVE;</span>
 	if (!bond-&gt;params.fail_over_mac ||
 	    BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP) {
 		/* XXX TODO - fom follow mode needs to change master&#39;s
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span>
<span class="p_header">index 1e52db32c73d..1203d892e842 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span>
<span class="p_chunk">@@ -746,7 +746,7 @@</span> <span class="p_context"> static int mlx5e_create_cq(struct mlx5e_channel *c,</span>
 	struct mlx5_core_dev *mdev = priv-&gt;mdev;
 	struct mlx5_core_cq *mcq = &amp;cq-&gt;mcq;
 	int eqn_not_used;
<span class="p_del">-	int irqn;</span>
<span class="p_add">+	unsigned int irqn;</span>
 	int err;
 	u32 i;
 
<span class="p_chunk">@@ -800,7 +800,7 @@</span> <span class="p_context"> static int mlx5e_enable_cq(struct mlx5e_cq *cq, struct mlx5e_cq_param *param)</span>
 	void *in;
 	void *cqc;
 	int inlen;
<span class="p_del">-	int irqn_not_used;</span>
<span class="p_add">+	unsigned int irqn_not_used;</span>
 	int eqn;
 	int err;
 
<span class="p_chunk">@@ -1504,7 +1504,7 @@</span> <span class="p_context"> static int mlx5e_create_drop_cq(struct mlx5e_priv *priv,</span>
 	struct mlx5_core_dev *mdev = priv-&gt;mdev;
 	struct mlx5_core_cq *mcq = &amp;cq-&gt;mcq;
 	int eqn_not_used;
<span class="p_del">-	int irqn;</span>
<span class="p_add">+	unsigned int irqn;</span>
 	int err;
 
 	err = mlx5_cqwq_create(mdev, &amp;param-&gt;wq, param-&gt;cqc, &amp;cq-&gt;wq,
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/main.c b/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_header">index 4ac8d4cc4973..6cf6d93d8831 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_chunk">@@ -568,7 +568,8 @@</span> <span class="p_context"> static void mlx5_irq_clear_affinity_hints(struct mlx5_core_dev *mdev)</span>
 		mlx5_irq_clear_affinity_hint(mdev, i);
 }
 
<span class="p_del">-int mlx5_vector2eqn(struct mlx5_core_dev *dev, int vector, int *eqn, int *irqn)</span>
<span class="p_add">+int mlx5_vector2eqn(struct mlx5_core_dev *dev, int vector, int *eqn,</span>
<span class="p_add">+		    unsigned int *irqn)</span>
 {
 	struct mlx5_eq_table *table = &amp;dev-&gt;priv.eq_table;
 	struct mlx5_eq *eq, *n;
<span class="p_header">diff --git a/drivers/net/ethernet/synopsys/dwc_eth_qos.c b/drivers/net/ethernet/synopsys/dwc_eth_qos.c</span>
<span class="p_header">index 9066d7a8483c..f96c6b3606f2 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/synopsys/dwc_eth_qos.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/synopsys/dwc_eth_qos.c</span>
<span class="p_chunk">@@ -2107,7 +2107,7 @@</span> <span class="p_context"> static int dwceqos_tx_frags(struct sk_buff *skb, struct net_local *lp,</span>
 			dd = &amp;lp-&gt;tx_descs[lp-&gt;tx_next];
 
 			/* Set DMA Descriptor fields */
<span class="p_del">-			dd-&gt;des0 = dma_handle;</span>
<span class="p_add">+			dd-&gt;des0 = dma_handle + consumed_size;</span>
 			dd-&gt;des1 = 0;
 			dd-&gt;des2 = dma_size;
 
<span class="p_header">diff --git a/drivers/net/team/team.c b/drivers/net/team/team.c</span>
<span class="p_header">index 651d35ea22c5..59fefca74263 100644</span>
<span class="p_header">--- a/drivers/net/team/team.c</span>
<span class="p_header">+++ b/drivers/net/team/team.c</span>
<span class="p_chunk">@@ -1845,10 +1845,10 @@</span> <span class="p_context"> static int team_vlan_rx_kill_vid(struct net_device *dev, __be16 proto, u16 vid)</span>
 	struct team *team = netdev_priv(dev);
 	struct team_port *port;
 
<span class="p_del">-	rcu_read_lock();</span>
<span class="p_del">-	list_for_each_entry_rcu(port, &amp;team-&gt;port_list, list)</span>
<span class="p_add">+	mutex_lock(&amp;team-&gt;lock);</span>
<span class="p_add">+	list_for_each_entry(port, &amp;team-&gt;port_list, list)</span>
 		vlan_vid_del(port-&gt;dev, proto, vid);
<span class="p_del">-	rcu_read_unlock();</span>
<span class="p_add">+	mutex_unlock(&amp;team-&gt;lock);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c</span>
<span class="p_header">index ba363cedef80..405a7b6cca25 100644</span>
<span class="p_header">--- a/drivers/net/vxlan.c</span>
<span class="p_header">+++ b/drivers/net/vxlan.c</span>
<span class="p_chunk">@@ -2751,7 +2751,7 @@</span> <span class="p_context"> static int vxlan_dev_configure(struct net *src_net, struct net_device *dev,</span>
 			       struct vxlan_config *conf)
 {
 	struct vxlan_net *vn = net_generic(src_net, vxlan_net_id);
<span class="p_del">-	struct vxlan_dev *vxlan = netdev_priv(dev);</span>
<span class="p_add">+	struct vxlan_dev *vxlan = netdev_priv(dev), *tmp;</span>
 	struct vxlan_rdst *dst = &amp;vxlan-&gt;default_dst;
 	unsigned short needed_headroom = ETH_HLEN;
 	int err;
<span class="p_chunk">@@ -2817,9 +2817,15 @@</span> <span class="p_context"> static int vxlan_dev_configure(struct net *src_net, struct net_device *dev,</span>
 	if (!vxlan-&gt;cfg.age_interval)
 		vxlan-&gt;cfg.age_interval = FDB_AGE_DEFAULT;
 
<span class="p_del">-	if (vxlan_find_vni(src_net, conf-&gt;vni, use_ipv6 ? AF_INET6 : AF_INET,</span>
<span class="p_del">-			   vxlan-&gt;cfg.dst_port, vxlan-&gt;flags))</span>
<span class="p_add">+	list_for_each_entry(tmp, &amp;vn-&gt;vxlan_list, next) {</span>
<span class="p_add">+		if (tmp-&gt;cfg.vni == conf-&gt;vni &amp;&amp;</span>
<span class="p_add">+		    (tmp-&gt;default_dst.remote_ip.sa.sa_family == AF_INET6 ||</span>
<span class="p_add">+		     tmp-&gt;cfg.saddr.sa.sa_family == AF_INET6) == use_ipv6 &amp;&amp;</span>
<span class="p_add">+		    tmp-&gt;cfg.dst_port == vxlan-&gt;cfg.dst_port &amp;&amp;</span>
<span class="p_add">+		    (tmp-&gt;flags &amp; VXLAN_F_RCV_FLAGS) ==</span>
<span class="p_add">+		    (vxlan-&gt;flags &amp; VXLAN_F_RCV_FLAGS))</span>
 		return -EEXIST;
<span class="p_add">+	}</span>
 
 	dev-&gt;ethtool_ops = &amp;vxlan_ethtool_ops;
 
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtlwifi/usb.c b/drivers/net/wireless/realtek/rtlwifi/usb.c</span>
<span class="p_header">index 2721cf89fb16..aac1ed3f7bb4 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtlwifi/usb.c</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtlwifi/usb.c</span>
<span class="p_chunk">@@ -531,6 +531,8 @@</span> <span class="p_context"> static void _rtl_usb_rx_process_noagg(struct ieee80211_hw *hw,</span>
 			ieee80211_rx(hw, skb);
 		else
 			dev_kfree_skb_any(skb);
<span class="p_add">+	} else {</span>
<span class="p_add">+		dev_kfree_skb_any(skb);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index ddbf32d599cb..8683436788c3 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -3895,17 +3895,30 @@</span> <span class="p_context"> static void usb_enable_link_state(struct usb_hcd *hcd, struct usb_device *udev,</span>
 		return;
 	}
 
<span class="p_del">-	if (usb_set_lpm_timeout(udev, state, timeout))</span>
<span class="p_add">+	if (usb_set_lpm_timeout(udev, state, timeout)) {</span>
 		/* If we can&#39;t set the parent hub U1/U2 timeout,
 		 * device-initiated LPM won&#39;t be allowed either, so let the xHCI
 		 * host know that this link state won&#39;t be enabled.
 		 */
 		hcd-&gt;driver-&gt;disable_usb3_lpm_timeout(hcd, udev, state);
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* Only a configured device will accept the Set Feature</span>
<span class="p_add">+		 * U1/U2_ENABLE</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (udev-&gt;actconfig)</span>
<span class="p_add">+			usb_set_device_initiated_lpm(udev, state, true);</span>
 
<span class="p_del">-	/* Only a configured device will accept the Set Feature U1/U2_ENABLE */</span>
<span class="p_del">-	else if (udev-&gt;actconfig)</span>
<span class="p_del">-		usb_set_device_initiated_lpm(udev, state, true);</span>
<span class="p_del">-</span>
<span class="p_add">+		/* As soon as usb_set_lpm_timeout(timeout) returns 0, the</span>
<span class="p_add">+		 * hub-initiated LPM is enabled. Thus, LPM is enabled no</span>
<span class="p_add">+		 * matter the result of usb_set_device_initiated_lpm().</span>
<span class="p_add">+		 * The only difference is whether device is able to initiate</span>
<span class="p_add">+		 * LPM.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (state == USB3_LPM_U1)</span>
<span class="p_add">+			udev-&gt;usb3_lpm_u1_enabled = 1;</span>
<span class="p_add">+		else if (state == USB3_LPM_U2)</span>
<span class="p_add">+			udev-&gt;usb3_lpm_u2_enabled = 1;</span>
<span class="p_add">+	}</span>
 }
 
 /*
<span class="p_chunk">@@ -3945,6 +3958,18 @@</span> <span class="p_context"> static int usb_disable_link_state(struct usb_hcd *hcd, struct usb_device *udev,</span>
 		dev_warn(&amp;udev-&gt;dev, &quot;Could not disable xHCI %s timeout, &quot;
 				&quot;bus schedule bandwidth may be impacted.\n&quot;,
 				usb3_lpm_names[state]);
<span class="p_add">+</span>
<span class="p_add">+	/* As soon as usb_set_lpm_timeout(0) return 0, hub initiated LPM</span>
<span class="p_add">+	 * is disabled. Hub will disallows link to enter U1/U2 as well,</span>
<span class="p_add">+	 * even device is initiating LPM. Hence LPM is disabled if hub LPM</span>
<span class="p_add">+	 * timeout set to 0, no matter device-initiated LPM is disabled or</span>
<span class="p_add">+	 * not.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (state == USB3_LPM_U1)</span>
<span class="p_add">+		udev-&gt;usb3_lpm_u1_enabled = 0;</span>
<span class="p_add">+	else if (state == USB3_LPM_U2)</span>
<span class="p_add">+		udev-&gt;usb3_lpm_u2_enabled = 0;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -3979,8 +4004,6 @@</span> <span class="p_context"> int usb_disable_lpm(struct usb_device *udev)</span>
 	if (usb_disable_link_state(hcd, udev, USB3_LPM_U2))
 		goto enable_lpm;
 
<span class="p_del">-	udev-&gt;usb3_lpm_enabled = 0;</span>
<span class="p_del">-</span>
 	return 0;
 
 enable_lpm:
<span class="p_chunk">@@ -4038,8 +4061,6 @@</span> <span class="p_context"> void usb_enable_lpm(struct usb_device *udev)</span>
 
 	usb_enable_link_state(hcd, udev, USB3_LPM_U1);
 	usb_enable_link_state(hcd, udev, USB3_LPM_U2);
<span class="p_del">-</span>
<span class="p_del">-	udev-&gt;usb3_lpm_enabled = 1;</span>
 }
 EXPORT_SYMBOL_GPL(usb_enable_lpm);
 
<span class="p_header">diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c</span>
<span class="p_header">index d9ec2de6c4cf..65b6e6b84043 100644</span>
<span class="p_header">--- a/drivers/usb/core/sysfs.c</span>
<span class="p_header">+++ b/drivers/usb/core/sysfs.c</span>
<span class="p_chunk">@@ -531,7 +531,7 @@</span> <span class="p_context"> static ssize_t usb2_lpm_besl_store(struct device *dev,</span>
 }
 static DEVICE_ATTR_RW(usb2_lpm_besl);
 
<span class="p_del">-static ssize_t usb3_hardware_lpm_show(struct device *dev,</span>
<span class="p_add">+static ssize_t usb3_hardware_lpm_u1_show(struct device *dev,</span>
 				      struct device_attribute *attr, char *buf)
 {
 	struct usb_device *udev = to_usb_device(dev);
<span class="p_chunk">@@ -539,7 +539,7 @@</span> <span class="p_context"> static ssize_t usb3_hardware_lpm_show(struct device *dev,</span>
 
 	usb_lock_device(udev);
 
<span class="p_del">-	if (udev-&gt;usb3_lpm_enabled)</span>
<span class="p_add">+	if (udev-&gt;usb3_lpm_u1_enabled)</span>
 		p = &quot;enabled&quot;;
 	else
 		p = &quot;disabled&quot;;
<span class="p_chunk">@@ -548,7 +548,26 @@</span> <span class="p_context"> static ssize_t usb3_hardware_lpm_show(struct device *dev,</span>
 
 	return sprintf(buf, &quot;%s\n&quot;, p);
 }
<span class="p_del">-static DEVICE_ATTR_RO(usb3_hardware_lpm);</span>
<span class="p_add">+static DEVICE_ATTR_RO(usb3_hardware_lpm_u1);</span>
<span class="p_add">+</span>
<span class="p_add">+static ssize_t usb3_hardware_lpm_u2_show(struct device *dev,</span>
<span class="p_add">+				      struct device_attribute *attr, char *buf)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct usb_device *udev = to_usb_device(dev);</span>
<span class="p_add">+	const char *p;</span>
<span class="p_add">+</span>
<span class="p_add">+	usb_lock_device(udev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (udev-&gt;usb3_lpm_u2_enabled)</span>
<span class="p_add">+		p = &quot;enabled&quot;;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		p = &quot;disabled&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+	usb_unlock_device(udev);</span>
<span class="p_add">+</span>
<span class="p_add">+	return sprintf(buf, &quot;%s\n&quot;, p);</span>
<span class="p_add">+}</span>
<span class="p_add">+static DEVICE_ATTR_RO(usb3_hardware_lpm_u2);</span>
 
 static struct attribute *usb2_hardware_lpm_attr[] = {
 	&amp;dev_attr_usb2_hardware_lpm.attr,
<span class="p_chunk">@@ -562,7 +581,8 @@</span> <span class="p_context"> static struct attribute_group usb2_hardware_lpm_attr_group = {</span>
 };
 
 static struct attribute *usb3_hardware_lpm_attr[] = {
<span class="p_del">-	&amp;dev_attr_usb3_hardware_lpm.attr,</span>
<span class="p_add">+	&amp;dev_attr_usb3_hardware_lpm_u1.attr,</span>
<span class="p_add">+	&amp;dev_attr_usb3_hardware_lpm_u2.attr,</span>
 	NULL,
 };
 static struct attribute_group usb3_hardware_lpm_attr_group = {
<span class="p_chunk">@@ -592,7 +612,8 @@</span> <span class="p_context"> static int add_power_attributes(struct device *dev)</span>
 		if (udev-&gt;usb2_hw_lpm_capable == 1)
 			rc = sysfs_merge_group(&amp;dev-&gt;kobj,
 					&amp;usb2_hardware_lpm_attr_group);
<span class="p_del">-		if (udev-&gt;lpm_capable == 1)</span>
<span class="p_add">+		if (udev-&gt;speed == USB_SPEED_SUPER &amp;&amp;</span>
<span class="p_add">+				udev-&gt;lpm_capable == 1)</span>
 			rc = sysfs_merge_group(&amp;dev-&gt;kobj,
 					&amp;usb3_hardware_lpm_attr_group);
 	}
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index 3f912705dcef..dca0a4692f08 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -5059,6 +5059,10 @@</span> <span class="p_context"> static int __init xhci_hcd_init(void)</span>
 	BUILD_BUG_ON(sizeof(struct xhci_intr_reg) != 8*32/8);
 	/* xhci_run_regs has eight fields and embeds 128 xhci_intr_regs */
 	BUILD_BUG_ON(sizeof(struct xhci_run_regs) != (8+8*128)*32/8);
<span class="p_add">+</span>
<span class="p_add">+	if (usb_disabled())</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 7d4f51a32e66..59b2126b21a3 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -160,6 +160,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x17F4, 0xAAAA) }, /* Wavesense Jazz blood glucose meter */
 	{ USB_DEVICE(0x1843, 0x0200) }, /* Vaisala USB Instrument Cable */
 	{ USB_DEVICE(0x18EF, 0xE00F) }, /* ELV USB-I2C-Interface */
<span class="p_add">+	{ USB_DEVICE(0x18EF, 0xE025) }, /* ELV Marble Sound Board 1 */</span>
 	{ USB_DEVICE(0x1ADB, 0x0001) }, /* Schweitzer Engineering C662 Cable */
 	{ USB_DEVICE(0x1B1C, 0x1C00) }, /* Corsair USB Dongle */
 	{ USB_DEVICE(0x1BA4, 0x0002) },	/* Silicon Labs 358x factory default */
<span class="p_header">diff --git a/include/linux/mlx5/cq.h b/include/linux/mlx5/cq.h</span>
<span class="p_header">index abc4767695e4..b2c9fada8eac 100644</span>
<span class="p_header">--- a/include/linux/mlx5/cq.h</span>
<span class="p_header">+++ b/include/linux/mlx5/cq.h</span>
<span class="p_chunk">@@ -45,7 +45,7 @@</span> <span class="p_context"> struct mlx5_core_cq {</span>
 	atomic_t		refcount;
 	struct completion	free;
 	unsigned		vector;
<span class="p_del">-	int			irqn;</span>
<span class="p_add">+	unsigned int		irqn;</span>
 	void (*comp)		(struct mlx5_core_cq *);
 	void (*event)		(struct mlx5_core_cq *, enum mlx5_event);
 	struct mlx5_uar	       *uar;
<span class="p_header">diff --git a/include/linux/mlx5/driver.h b/include/linux/mlx5/driver.h</span>
<span class="p_header">index 5c857f2a20d7..af3efd9157f0 100644</span>
<span class="p_header">--- a/include/linux/mlx5/driver.h</span>
<span class="p_header">+++ b/include/linux/mlx5/driver.h</span>
<span class="p_chunk">@@ -303,7 +303,7 @@</span> <span class="p_context"> struct mlx5_eq {</span>
 	u32			cons_index;
 	struct mlx5_buf		buf;
 	int			size;
<span class="p_del">-	u8			irqn;</span>
<span class="p_add">+	unsigned int		irqn;</span>
 	u8			eqn;
 	int			nent;
 	u64			mask;
<span class="p_chunk">@@ -762,7 +762,8 @@</span> <span class="p_context"> int mlx5_create_map_eq(struct mlx5_core_dev *dev, struct mlx5_eq *eq, u8 vecidx,</span>
 int mlx5_destroy_unmap_eq(struct mlx5_core_dev *dev, struct mlx5_eq *eq);
 int mlx5_start_eqs(struct mlx5_core_dev *dev);
 int mlx5_stop_eqs(struct mlx5_core_dev *dev);
<span class="p_del">-int mlx5_vector2eqn(struct mlx5_core_dev *dev, int vector, int *eqn, int *irqn);</span>
<span class="p_add">+int mlx5_vector2eqn(struct mlx5_core_dev *dev, int vector, int *eqn,</span>
<span class="p_add">+		    unsigned int *irqn);</span>
 int mlx5_core_attach_mcg(struct mlx5_core_dev *dev, union ib_gid *mgid, u32 qpn);
 int mlx5_core_detach_mcg(struct mlx5_core_dev *dev, union ib_gid *mgid, u32 qpn);
 
<span class="p_header">diff --git a/include/linux/sched.h b/include/linux/sched.h</span>
<span class="p_header">index fa39434e3fdd..21a6e9649012 100644</span>
<span class="p_header">--- a/include/linux/sched.h</span>
<span class="p_header">+++ b/include/linux/sched.h</span>
<span class="p_chunk">@@ -830,6 +830,7 @@</span> <span class="p_context"> struct user_struct {</span>
 	unsigned long mq_bytes;	/* How many bytes can be allocated to mqueue? */
 #endif
 	unsigned long locked_shm; /* How many pages of mlocked shm ? */
<span class="p_add">+	unsigned long unix_inflight;	/* How many files in flight in unix sockets */</span>
 
 #ifdef CONFIG_KEYS
 	struct key *uid_keyring;	/* UID specific keyring */
<span class="p_header">diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h</span>
<span class="p_header">index 4355129fff91..9147f9f34cbe 100644</span>
<span class="p_header">--- a/include/linux/skbuff.h</span>
<span class="p_header">+++ b/include/linux/skbuff.h</span>
<span class="p_chunk">@@ -3446,7 +3446,8 @@</span> <span class="p_context"> struct skb_gso_cb {</span>
 	int	encap_level;
 	__u16	csum_start;
 };
<span class="p_del">-#define SKB_GSO_CB(skb) ((struct skb_gso_cb *)(skb)-&gt;cb)</span>
<span class="p_add">+#define SKB_SGO_CB_OFFSET	32</span>
<span class="p_add">+#define SKB_GSO_CB(skb) ((struct skb_gso_cb *)((skb)-&gt;cb + SKB_SGO_CB_OFFSET))</span>
 
 static inline int skb_tnl_header_len(const struct sk_buff *inner_skb)
 {
<span class="p_header">diff --git a/include/linux/usb.h b/include/linux/usb.h</span>
<span class="p_header">index b9a28074210f..b79925dd2b41 100644</span>
<span class="p_header">--- a/include/linux/usb.h</span>
<span class="p_header">+++ b/include/linux/usb.h</span>
<span class="p_chunk">@@ -511,6 +511,8 @@</span> <span class="p_context"> struct usb3_lpm_parameters {</span>
  * @usb2_hw_lpm_enabled: USB2 hardware LPM is enabled
  * @usb2_hw_lpm_allowed: Userspace allows USB 2.0 LPM to be enabled
  * @usb3_lpm_enabled: USB3 hardware LPM enabled
<span class="p_add">+ * @usb3_lpm_u1_enabled: USB3 hardware U1 LPM enabled</span>
<span class="p_add">+ * @usb3_lpm_u2_enabled: USB3 hardware U2 LPM enabled</span>
  * @string_langid: language ID for strings
  * @product: iProduct string, if present (static)
  * @manufacturer: iManufacturer string, if present (static)
<span class="p_chunk">@@ -584,6 +586,8 @@</span> <span class="p_context"> struct usb_device {</span>
 	unsigned usb2_hw_lpm_enabled:1;
 	unsigned usb2_hw_lpm_allowed:1;
 	unsigned usb3_lpm_enabled:1;
<span class="p_add">+	unsigned usb3_lpm_u1_enabled:1;</span>
<span class="p_add">+	unsigned usb3_lpm_u2_enabled:1;</span>
 	int string_langid;
 
 	/* static strings from the device */
<span class="p_header">diff --git a/include/net/inet_ecn.h b/include/net/inet_ecn.h</span>
<span class="p_header">index 84b20835b736..0dc0a51da38f 100644</span>
<span class="p_header">--- a/include/net/inet_ecn.h</span>
<span class="p_header">+++ b/include/net/inet_ecn.h</span>
<span class="p_chunk">@@ -111,11 +111,24 @@</span> <span class="p_context"> static inline void ipv4_copy_dscp(unsigned int dscp, struct iphdr *inner)</span>
 
 struct ipv6hdr;
 
<span class="p_del">-static inline int IP6_ECN_set_ce(struct ipv6hdr *iph)</span>
<span class="p_add">+/* Note:</span>
<span class="p_add">+ * IP_ECN_set_ce() has to tweak IPV4 checksum when setting CE,</span>
<span class="p_add">+ * meaning both changes have no effect on skb-&gt;csum if/when CHECKSUM_COMPLETE</span>
<span class="p_add">+ * In IPv6 case, no checksum compensates the change in IPv6 header,</span>
<span class="p_add">+ * so we have to update skb-&gt;csum.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline int IP6_ECN_set_ce(struct sk_buff *skb, struct ipv6hdr *iph)</span>
 {
<span class="p_add">+	__be32 from, to;</span>
<span class="p_add">+</span>
 	if (INET_ECN_is_not_ect(ipv6_get_dsfield(iph)))
 		return 0;
<span class="p_del">-	*(__be32*)iph |= htonl(INET_ECN_CE &lt;&lt; 20);</span>
<span class="p_add">+</span>
<span class="p_add">+	from = *(__be32 *)iph;</span>
<span class="p_add">+	to = from | htonl(INET_ECN_CE &lt;&lt; 20);</span>
<span class="p_add">+	*(__be32 *)iph = to;</span>
<span class="p_add">+	if (skb-&gt;ip_summed == CHECKSUM_COMPLETE)</span>
<span class="p_add">+		skb-&gt;csum = csum_add(csum_sub(skb-&gt;csum, from), to);</span>
 	return 1;
 }
 
<span class="p_chunk">@@ -142,7 +155,7 @@</span> <span class="p_context"> static inline int INET_ECN_set_ce(struct sk_buff *skb)</span>
 	case cpu_to_be16(ETH_P_IPV6):
 		if (skb_network_header(skb) + sizeof(struct ipv6hdr) &lt;=
 		    skb_tail_pointer(skb))
<span class="p_del">-			return IP6_ECN_set_ce(ipv6_hdr(skb));</span>
<span class="p_add">+			return IP6_ECN_set_ce(skb, ipv6_hdr(skb));</span>
 		break;
 	}
 
<span class="p_header">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c</span>
<span class="p_header">index a7945d10b378..d1d3e8f57de9 100644</span>
<span class="p_header">--- a/kernel/bpf/verifier.c</span>
<span class="p_header">+++ b/kernel/bpf/verifier.c</span>
<span class="p_chunk">@@ -1121,6 +1121,16 @@</span> <span class="p_context"> static int check_alu_op(struct verifier_env *env, struct bpf_insn *insn)</span>
 			return -EINVAL;
 		}
 
<span class="p_add">+		if ((opcode == BPF_LSH || opcode == BPF_RSH ||</span>
<span class="p_add">+		     opcode == BPF_ARSH) &amp;&amp; BPF_SRC(insn-&gt;code) == BPF_K) {</span>
<span class="p_add">+			int size = BPF_CLASS(insn-&gt;code) == BPF_ALU64 ? 64 : 32;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (insn-&gt;imm &lt; 0 || insn-&gt;imm &gt;= size) {</span>
<span class="p_add">+				verbose(&quot;invalid shift %d\n&quot;, insn-&gt;imm);</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		/* pattern match &#39;bpf_add Rx, imm&#39; instruction */
 		if (opcode == BPF_ADD &amp;&amp; BPF_CLASS(insn-&gt;code) == BPF_ALU64 &amp;&amp;
 		    regs[insn-&gt;dst_reg].type == FRAME_PTR &amp;&amp;
<span class="p_header">diff --git a/net/batman-adv/bridge_loop_avoidance.c b/net/batman-adv/bridge_loop_avoidance.c</span>
<span class="p_header">index 191a70290dca..f5d2fe5e31cc 100644</span>
<span class="p_header">--- a/net/batman-adv/bridge_loop_avoidance.c</span>
<span class="p_header">+++ b/net/batman-adv/bridge_loop_avoidance.c</span>
<span class="p_chunk">@@ -127,21 +127,17 @@</span> <span class="p_context"> batadv_backbone_gw_free_ref(struct batadv_bla_backbone_gw *backbone_gw)</span>
 }
 
 /* finally deinitialize the claim */
<span class="p_del">-static void batadv_claim_free_rcu(struct rcu_head *rcu)</span>
<span class="p_add">+static void batadv_claim_release(struct batadv_bla_claim *claim)</span>
 {
<span class="p_del">-	struct batadv_bla_claim *claim;</span>
<span class="p_del">-</span>
<span class="p_del">-	claim = container_of(rcu, struct batadv_bla_claim, rcu);</span>
<span class="p_del">-</span>
 	batadv_backbone_gw_free_ref(claim-&gt;backbone_gw);
<span class="p_del">-	kfree(claim);</span>
<span class="p_add">+	kfree_rcu(claim, rcu);</span>
 }
 
 /* free a claim, call claim_free_rcu if its the last reference */
 static void batadv_claim_free_ref(struct batadv_bla_claim *claim)
 {
 	if (atomic_dec_and_test(&amp;claim-&gt;refcount))
<span class="p_del">-		call_rcu(&amp;claim-&gt;rcu, batadv_claim_free_rcu);</span>
<span class="p_add">+		batadv_claim_release(claim);</span>
 }
 
 /**
<span class="p_header">diff --git a/net/batman-adv/hard-interface.h b/net/batman-adv/hard-interface.h</span>
<span class="p_header">index 5a31420513e1..7b12ea8ea29d 100644</span>
<span class="p_header">--- a/net/batman-adv/hard-interface.h</span>
<span class="p_header">+++ b/net/batman-adv/hard-interface.h</span>
<span class="p_chunk">@@ -75,18 +75,6 @@</span> <span class="p_context"> batadv_hardif_free_ref(struct batadv_hard_iface *hard_iface)</span>
 		call_rcu(&amp;hard_iface-&gt;rcu, batadv_hardif_free_rcu);
 }
 
<span class="p_del">-/**</span>
<span class="p_del">- * batadv_hardif_free_ref_now - decrement the hard interface refcounter and</span>
<span class="p_del">- *  possibly free it (without rcu callback)</span>
<span class="p_del">- * @hard_iface: the hard interface to free</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline void</span>
<span class="p_del">-batadv_hardif_free_ref_now(struct batadv_hard_iface *hard_iface)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (atomic_dec_and_test(&amp;hard_iface-&gt;refcount))</span>
<span class="p_del">-		batadv_hardif_free_rcu(&amp;hard_iface-&gt;rcu);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline struct batadv_hard_iface *
 batadv_primary_if_get_selected(struct batadv_priv *bat_priv)
 {
<span class="p_header">diff --git a/net/batman-adv/network-coding.c b/net/batman-adv/network-coding.c</span>
<span class="p_header">index f5276be2c77c..d0956f726547 100644</span>
<span class="p_header">--- a/net/batman-adv/network-coding.c</span>
<span class="p_header">+++ b/net/batman-adv/network-coding.c</span>
<span class="p_chunk">@@ -203,28 +203,25 @@</span> <span class="p_context"> void batadv_nc_init_orig(struct batadv_orig_node *orig_node)</span>
 }
 
 /**
<span class="p_del">- * batadv_nc_node_free_rcu - rcu callback to free an nc node and remove</span>
<span class="p_del">- *  its refcount on the orig_node</span>
<span class="p_del">- * @rcu: rcu pointer of the nc node</span>
<span class="p_add">+ * batadv_nc_node_release - release nc_node from lists and queue for free after</span>
<span class="p_add">+ *  rcu grace period</span>
<span class="p_add">+ * @nc_node: the nc node to free</span>
  */
<span class="p_del">-static void batadv_nc_node_free_rcu(struct rcu_head *rcu)</span>
<span class="p_add">+static void batadv_nc_node_release(struct batadv_nc_node *nc_node)</span>
 {
<span class="p_del">-	struct batadv_nc_node *nc_node;</span>
<span class="p_del">-</span>
<span class="p_del">-	nc_node = container_of(rcu, struct batadv_nc_node, rcu);</span>
 	batadv_orig_node_free_ref(nc_node-&gt;orig_node);
<span class="p_del">-	kfree(nc_node);</span>
<span class="p_add">+	kfree_rcu(nc_node, rcu);</span>
 }
 
 /**
<span class="p_del">- * batadv_nc_node_free_ref - decrements the nc node refcounter and possibly</span>
<span class="p_del">- * frees it</span>
<span class="p_add">+ * batadv_nc_node_free_ref - decrement the nc node refcounter and possibly</span>
<span class="p_add">+ *  release it</span>
  * @nc_node: the nc node to free
  */
 static void batadv_nc_node_free_ref(struct batadv_nc_node *nc_node)
 {
 	if (atomic_dec_and_test(&amp;nc_node-&gt;refcount))
<span class="p_del">-		call_rcu(&amp;nc_node-&gt;rcu, batadv_nc_node_free_rcu);</span>
<span class="p_add">+		batadv_nc_node_release(nc_node);</span>
 }
 
 /**
<span class="p_header">diff --git a/net/batman-adv/originator.c b/net/batman-adv/originator.c</span>
<span class="p_header">index 7486df9ed48d..17851d3aaf22 100644</span>
<span class="p_header">--- a/net/batman-adv/originator.c</span>
<span class="p_header">+++ b/net/batman-adv/originator.c</span>
<span class="p_chunk">@@ -163,92 +163,66 @@</span> <span class="p_context"> err:</span>
 }
 
 /**
<span class="p_del">- * batadv_neigh_ifinfo_free_rcu - free the neigh_ifinfo object</span>
<span class="p_del">- * @rcu: rcu pointer of the neigh_ifinfo object</span>
<span class="p_del">- */</span>
<span class="p_del">-static void batadv_neigh_ifinfo_free_rcu(struct rcu_head *rcu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct batadv_neigh_ifinfo *neigh_ifinfo;</span>
<span class="p_del">-</span>
<span class="p_del">-	neigh_ifinfo = container_of(rcu, struct batadv_neigh_ifinfo, rcu);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (neigh_ifinfo-&gt;if_outgoing != BATADV_IF_DEFAULT)</span>
<span class="p_del">-		batadv_hardif_free_ref_now(neigh_ifinfo-&gt;if_outgoing);</span>
<span class="p_del">-</span>
<span class="p_del">-	kfree(neigh_ifinfo);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * batadv_neigh_ifinfo_free_now - decrement the refcounter and possibly free</span>
<span class="p_del">- *  the neigh_ifinfo (without rcu callback)</span>
<span class="p_add">+ * batadv_neigh_ifinfo_release - release neigh_ifinfo from lists and queue for</span>
<span class="p_add">+ *  free after rcu grace period</span>
  * @neigh_ifinfo: the neigh_ifinfo object to release
  */
 static void
<span class="p_del">-batadv_neigh_ifinfo_free_ref_now(struct batadv_neigh_ifinfo *neigh_ifinfo)</span>
<span class="p_add">+batadv_neigh_ifinfo_release(struct batadv_neigh_ifinfo *neigh_ifinfo)</span>
 {
<span class="p_del">-	if (atomic_dec_and_test(&amp;neigh_ifinfo-&gt;refcount))</span>
<span class="p_del">-		batadv_neigh_ifinfo_free_rcu(&amp;neigh_ifinfo-&gt;rcu);</span>
<span class="p_add">+	if (neigh_ifinfo-&gt;if_outgoing != BATADV_IF_DEFAULT)</span>
<span class="p_add">+		batadv_hardif_free_ref(neigh_ifinfo-&gt;if_outgoing);</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree_rcu(neigh_ifinfo, rcu);</span>
 }
 
 /**
<span class="p_del">- * batadv_neigh_ifinfo_free_ref - decrement the refcounter and possibly free</span>
<span class="p_add">+ * batadv_neigh_ifinfo_free_ref - decrement the refcounter and possibly release</span>
  *  the neigh_ifinfo
  * @neigh_ifinfo: the neigh_ifinfo object to release
  */
 void batadv_neigh_ifinfo_free_ref(struct batadv_neigh_ifinfo *neigh_ifinfo)
 {
 	if (atomic_dec_and_test(&amp;neigh_ifinfo-&gt;refcount))
<span class="p_del">-		call_rcu(&amp;neigh_ifinfo-&gt;rcu, batadv_neigh_ifinfo_free_rcu);</span>
<span class="p_add">+		batadv_neigh_ifinfo_release(neigh_ifinfo);</span>
 }
 
 /**
  * batadv_neigh_node_free_rcu - free the neigh_node
<span class="p_del">- * @rcu: rcu pointer of the neigh_node</span>
<span class="p_add">+ * batadv_neigh_node_release - release neigh_node from lists and queue for</span>
<span class="p_add">+ *  free after rcu grace period</span>
<span class="p_add">+ * @neigh_node: neigh neighbor to free</span>
  */
<span class="p_del">-static void batadv_neigh_node_free_rcu(struct rcu_head *rcu)</span>
<span class="p_add">+static void batadv_neigh_node_release(struct batadv_neigh_node *neigh_node)</span>
 {
 	struct hlist_node *node_tmp;
<span class="p_del">-	struct batadv_neigh_node *neigh_node;</span>
 	struct batadv_neigh_ifinfo *neigh_ifinfo;
 	struct batadv_algo_ops *bao;
 
<span class="p_del">-	neigh_node = container_of(rcu, struct batadv_neigh_node, rcu);</span>
 	bao = neigh_node-&gt;orig_node-&gt;bat_priv-&gt;bat_algo_ops;
 
 	hlist_for_each_entry_safe(neigh_ifinfo, node_tmp,
 				  &amp;neigh_node-&gt;ifinfo_list, list) {
<span class="p_del">-		batadv_neigh_ifinfo_free_ref_now(neigh_ifinfo);</span>
<span class="p_add">+		batadv_neigh_ifinfo_free_ref(neigh_ifinfo);</span>
 	}
 
 	if (bao-&gt;bat_neigh_free)
 		bao-&gt;bat_neigh_free(neigh_node);
 
<span class="p_del">-	batadv_hardif_free_ref_now(neigh_node-&gt;if_incoming);</span>
<span class="p_add">+	batadv_hardif_free_ref(neigh_node-&gt;if_incoming);</span>
 
<span class="p_del">-	kfree(neigh_node);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * batadv_neigh_node_free_ref_now - decrement the neighbors refcounter</span>
<span class="p_del">- *  and possibly free it (without rcu callback)</span>
<span class="p_del">- * @neigh_node: neigh neighbor to free</span>
<span class="p_del">- */</span>
<span class="p_del">-static void</span>
<span class="p_del">-batadv_neigh_node_free_ref_now(struct batadv_neigh_node *neigh_node)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (atomic_dec_and_test(&amp;neigh_node-&gt;refcount))</span>
<span class="p_del">-		batadv_neigh_node_free_rcu(&amp;neigh_node-&gt;rcu);</span>
<span class="p_add">+	kfree_rcu(neigh_node, rcu);</span>
 }
 
 /**
  * batadv_neigh_node_free_ref - decrement the neighbors refcounter
<span class="p_del">- *  and possibly free it</span>
<span class="p_add">+ *  and possibly release it</span>
  * @neigh_node: neigh neighbor to free
  */
 void batadv_neigh_node_free_ref(struct batadv_neigh_node *neigh_node)
 {
 	if (atomic_dec_and_test(&amp;neigh_node-&gt;refcount))
<span class="p_del">-		call_rcu(&amp;neigh_node-&gt;rcu, batadv_neigh_node_free_rcu);</span>
<span class="p_add">+		batadv_neigh_node_release(neigh_node);</span>
 }
 
 /**
<span class="p_chunk">@@ -532,108 +506,99 @@</span> <span class="p_context"> out:</span>
 }
 
 /**
<span class="p_del">- * batadv_orig_ifinfo_free_rcu - free the orig_ifinfo object</span>
<span class="p_del">- * @rcu: rcu pointer of the orig_ifinfo object</span>
<span class="p_add">+ * batadv_orig_ifinfo_release - release orig_ifinfo from lists and queue for</span>
<span class="p_add">+ *  free after rcu grace period</span>
<span class="p_add">+ * @orig_ifinfo: the orig_ifinfo object to release</span>
  */
<span class="p_del">-static void batadv_orig_ifinfo_free_rcu(struct rcu_head *rcu)</span>
<span class="p_add">+static void batadv_orig_ifinfo_release(struct batadv_orig_ifinfo *orig_ifinfo)</span>
 {
<span class="p_del">-	struct batadv_orig_ifinfo *orig_ifinfo;</span>
 	struct batadv_neigh_node *router;
 
<span class="p_del">-	orig_ifinfo = container_of(rcu, struct batadv_orig_ifinfo, rcu);</span>
<span class="p_del">-</span>
 	if (orig_ifinfo-&gt;if_outgoing != BATADV_IF_DEFAULT)
<span class="p_del">-		batadv_hardif_free_ref_now(orig_ifinfo-&gt;if_outgoing);</span>
<span class="p_add">+		batadv_hardif_free_ref(orig_ifinfo-&gt;if_outgoing);</span>
 
 	/* this is the last reference to this object */
 	router = rcu_dereference_protected(orig_ifinfo-&gt;router, true);
 	if (router)
<span class="p_del">-		batadv_neigh_node_free_ref_now(router);</span>
<span class="p_del">-	kfree(orig_ifinfo);</span>
<span class="p_add">+		batadv_neigh_node_free_ref(router);</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree_rcu(orig_ifinfo, rcu);</span>
 }
 
 /**
<span class="p_del">- * batadv_orig_ifinfo_free_ref - decrement the refcounter and possibly free</span>
<span class="p_del">- *  the orig_ifinfo (without rcu callback)</span>
<span class="p_add">+ * batadv_orig_ifinfo_free_ref - decrement the refcounter and possibly release</span>
<span class="p_add">+ *  the orig_ifinfo</span>
  * @orig_ifinfo: the orig_ifinfo object to release
  */
<span class="p_del">-static void</span>
<span class="p_del">-batadv_orig_ifinfo_free_ref_now(struct batadv_orig_ifinfo *orig_ifinfo)</span>
<span class="p_add">+void batadv_orig_ifinfo_free_ref(struct batadv_orig_ifinfo *orig_ifinfo)</span>
 {
 	if (atomic_dec_and_test(&amp;orig_ifinfo-&gt;refcount))
<span class="p_del">-		batadv_orig_ifinfo_free_rcu(&amp;orig_ifinfo-&gt;rcu);</span>
<span class="p_add">+		batadv_orig_ifinfo_release(orig_ifinfo);</span>
 }
 
 /**
<span class="p_del">- * batadv_orig_ifinfo_free_ref - decrement the refcounter and possibly free</span>
<span class="p_del">- *  the orig_ifinfo</span>
<span class="p_del">- * @orig_ifinfo: the orig_ifinfo object to release</span>
<span class="p_add">+ * batadv_orig_node_free_rcu - free the orig_node</span>
<span class="p_add">+ * @rcu: rcu pointer of the orig_node</span>
  */
<span class="p_del">-void batadv_orig_ifinfo_free_ref(struct batadv_orig_ifinfo *orig_ifinfo)</span>
<span class="p_add">+static void batadv_orig_node_free_rcu(struct rcu_head *rcu)</span>
 {
<span class="p_del">-	if (atomic_dec_and_test(&amp;orig_ifinfo-&gt;refcount))</span>
<span class="p_del">-		call_rcu(&amp;orig_ifinfo-&gt;rcu, batadv_orig_ifinfo_free_rcu);</span>
<span class="p_add">+	struct batadv_orig_node *orig_node;</span>
<span class="p_add">+</span>
<span class="p_add">+	orig_node = container_of(rcu, struct batadv_orig_node, rcu);</span>
<span class="p_add">+</span>
<span class="p_add">+	batadv_mcast_purge_orig(orig_node);</span>
<span class="p_add">+</span>
<span class="p_add">+	batadv_frag_purge_orig(orig_node, NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (orig_node-&gt;bat_priv-&gt;bat_algo_ops-&gt;bat_orig_free)</span>
<span class="p_add">+		orig_node-&gt;bat_priv-&gt;bat_algo_ops-&gt;bat_orig_free(orig_node);</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(orig_node-&gt;tt_buff);</span>
<span class="p_add">+	kfree(orig_node);</span>
 }
 
<span class="p_del">-static void batadv_orig_node_free_rcu(struct rcu_head *rcu)</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * batadv_orig_node_release - release orig_node from lists and queue for</span>
<span class="p_add">+ *  free after rcu grace period</span>
<span class="p_add">+ * @orig_node: the orig node to free</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void batadv_orig_node_release(struct batadv_orig_node *orig_node)</span>
 {
 	struct hlist_node *node_tmp;
 	struct batadv_neigh_node *neigh_node;
<span class="p_del">-	struct batadv_orig_node *orig_node;</span>
 	struct batadv_orig_ifinfo *orig_ifinfo;
 
<span class="p_del">-	orig_node = container_of(rcu, struct batadv_orig_node, rcu);</span>
<span class="p_del">-</span>
 	spin_lock_bh(&amp;orig_node-&gt;neigh_list_lock);
 
 	/* for all neighbors towards this originator ... */
 	hlist_for_each_entry_safe(neigh_node, node_tmp,
 				  &amp;orig_node-&gt;neigh_list, list) {
 		hlist_del_rcu(&amp;neigh_node-&gt;list);
<span class="p_del">-		batadv_neigh_node_free_ref_now(neigh_node);</span>
<span class="p_add">+		batadv_neigh_node_free_ref(neigh_node);</span>
 	}
 
 	hlist_for_each_entry_safe(orig_ifinfo, node_tmp,
 				  &amp;orig_node-&gt;ifinfo_list, list) {
 		hlist_del_rcu(&amp;orig_ifinfo-&gt;list);
<span class="p_del">-		batadv_orig_ifinfo_free_ref_now(orig_ifinfo);</span>
<span class="p_add">+		batadv_orig_ifinfo_free_ref(orig_ifinfo);</span>
 	}
 	spin_unlock_bh(&amp;orig_node-&gt;neigh_list_lock);
 
<span class="p_del">-	batadv_mcast_purge_orig(orig_node);</span>
<span class="p_del">-</span>
 	/* Free nc_nodes */
 	batadv_nc_purge_orig(orig_node-&gt;bat_priv, orig_node, NULL);
 
<span class="p_del">-	batadv_frag_purge_orig(orig_node, NULL);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (orig_node-&gt;bat_priv-&gt;bat_algo_ops-&gt;bat_orig_free)</span>
<span class="p_del">-		orig_node-&gt;bat_priv-&gt;bat_algo_ops-&gt;bat_orig_free(orig_node);</span>
<span class="p_del">-</span>
<span class="p_del">-	kfree(orig_node-&gt;tt_buff);</span>
<span class="p_del">-	kfree(orig_node);</span>
<span class="p_add">+	call_rcu(&amp;orig_node-&gt;rcu, batadv_orig_node_free_rcu);</span>
 }
 
 /**
  * batadv_orig_node_free_ref - decrement the orig node refcounter and possibly
<span class="p_del">- * schedule an rcu callback for freeing it</span>
<span class="p_add">+ *  release it</span>
  * @orig_node: the orig node to free
  */
 void batadv_orig_node_free_ref(struct batadv_orig_node *orig_node)
 {
 	if (atomic_dec_and_test(&amp;orig_node-&gt;refcount))
<span class="p_del">-		call_rcu(&amp;orig_node-&gt;rcu, batadv_orig_node_free_rcu);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * batadv_orig_node_free_ref_now - decrement the orig node refcounter and</span>
<span class="p_del">- * possibly free it (without rcu callback)</span>
<span class="p_del">- * @orig_node: the orig node to free</span>
<span class="p_del">- */</span>
<span class="p_del">-void batadv_orig_node_free_ref_now(struct batadv_orig_node *orig_node)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (atomic_dec_and_test(&amp;orig_node-&gt;refcount))</span>
<span class="p_del">-		batadv_orig_node_free_rcu(&amp;orig_node-&gt;rcu);</span>
<span class="p_add">+		batadv_orig_node_release(orig_node);</span>
 }
 
 void batadv_originator_free(struct batadv_priv *bat_priv)
<span class="p_header">diff --git a/net/batman-adv/originator.h b/net/batman-adv/originator.h</span>
<span class="p_header">index fa18f9bf266b..a5c37882b409 100644</span>
<span class="p_header">--- a/net/batman-adv/originator.h</span>
<span class="p_header">+++ b/net/batman-adv/originator.h</span>
<span class="p_chunk">@@ -38,7 +38,6 @@</span> <span class="p_context"> int batadv_originator_init(struct batadv_priv *bat_priv);</span>
 void batadv_originator_free(struct batadv_priv *bat_priv);
 void batadv_purge_orig_ref(struct batadv_priv *bat_priv);
 void batadv_orig_node_free_ref(struct batadv_orig_node *orig_node);
<span class="p_del">-void batadv_orig_node_free_ref_now(struct batadv_orig_node *orig_node);</span>
 struct batadv_orig_node *batadv_orig_node_new(struct batadv_priv *bat_priv,
 					      const u8 *addr);
 struct batadv_neigh_node *
<span class="p_header">diff --git a/net/batman-adv/translation-table.c b/net/batman-adv/translation-table.c</span>
<span class="p_header">index 76f19ba62462..83b0ca27a45e 100644</span>
<span class="p_header">--- a/net/batman-adv/translation-table.c</span>
<span class="p_header">+++ b/net/batman-adv/translation-table.c</span>
<span class="p_chunk">@@ -240,20 +240,6 @@</span> <span class="p_context"> int batadv_tt_global_hash_count(struct batadv_priv *bat_priv,</span>
 	return count;
 }
 
<span class="p_del">-static void batadv_tt_orig_list_entry_free_rcu(struct rcu_head *rcu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct batadv_tt_orig_list_entry *orig_entry;</span>
<span class="p_del">-</span>
<span class="p_del">-	orig_entry = container_of(rcu, struct batadv_tt_orig_list_entry, rcu);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We are in an rcu callback here, therefore we cannot use</span>
<span class="p_del">-	 * batadv_orig_node_free_ref() and its call_rcu():</span>
<span class="p_del">-	 * An rcu_barrier() wouldn&#39;t wait for that to finish</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	batadv_orig_node_free_ref_now(orig_entry-&gt;orig_node);</span>
<span class="p_del">-	kfree(orig_entry);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /**
  * batadv_tt_local_size_mod - change the size by v of the local table identified
  *  by vid
<span class="p_chunk">@@ -349,13 +335,25 @@</span> <span class="p_context"> static void batadv_tt_global_size_dec(struct batadv_orig_node *orig_node,</span>
 	batadv_tt_global_size_mod(orig_node, vid, -1);
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * batadv_tt_orig_list_entry_release - release tt orig entry from lists and</span>
<span class="p_add">+ *  queue for free after rcu grace period</span>
<span class="p_add">+ * @orig_entry: tt orig entry to be free&#39;d</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void</span>
<span class="p_add">+batadv_tt_orig_list_entry_release(struct batadv_tt_orig_list_entry *orig_entry)</span>
<span class="p_add">+{</span>
<span class="p_add">+	batadv_orig_node_free_ref(orig_entry-&gt;orig_node);</span>
<span class="p_add">+	kfree_rcu(orig_entry, rcu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void
 batadv_tt_orig_list_entry_free_ref(struct batadv_tt_orig_list_entry *orig_entry)
 {
 	if (!atomic_dec_and_test(&amp;orig_entry-&gt;refcount))
 		return;
 
<span class="p_del">-	call_rcu(&amp;orig_entry-&gt;rcu, batadv_tt_orig_list_entry_free_rcu);</span>
<span class="p_add">+	batadv_tt_orig_list_entry_release(orig_entry);</span>
 }
 
 /**
<span class="p_header">diff --git a/net/bridge/br_device.c b/net/bridge/br_device.c</span>
<span class="p_header">index 5e88d3e17546..2c8095a5d824 100644</span>
<span class="p_header">--- a/net/bridge/br_device.c</span>
<span class="p_header">+++ b/net/bridge/br_device.c</span>
<span class="p_chunk">@@ -28,6 +28,8 @@</span> <span class="p_context"></span>
 const struct nf_br_ops __rcu *nf_br_ops __read_mostly;
 EXPORT_SYMBOL_GPL(nf_br_ops);
 
<span class="p_add">+static struct lock_class_key bridge_netdev_addr_lock_key;</span>
<span class="p_add">+</span>
 /* net device transmit always called with BH disabled */
 netdev_tx_t br_dev_xmit(struct sk_buff *skb, struct net_device *dev)
 {
<span class="p_chunk">@@ -87,6 +89,11 @@</span> <span class="p_context"> out:</span>
 	return NETDEV_TX_OK;
 }
 
<span class="p_add">+static void br_set_lockdep_class(struct net_device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	lockdep_set_class(&amp;dev-&gt;addr_list_lock, &amp;bridge_netdev_addr_lock_key);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int br_dev_init(struct net_device *dev)
 {
 	struct net_bridge *br = netdev_priv(dev);
<span class="p_chunk">@@ -99,6 +106,7 @@</span> <span class="p_context"> static int br_dev_init(struct net_device *dev)</span>
 	err = br_vlan_init(br);
 	if (err)
 		free_percpu(br-&gt;stats);
<span class="p_add">+	br_set_lockdep_class(dev);</span>
 
 	return err;
 }
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index ae00b894e675..7f00f2439770 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -2542,6 +2542,8 @@</span> <span class="p_context"> static inline bool skb_needs_check(struct sk_buff *skb, bool tx_path)</span>
  *
  *	It may return NULL if the skb requires no segmentation.  This is
  *	only possible when GSO is used for verifying header integrity.
<span class="p_add">+ *</span>
<span class="p_add">+ *	Segmentation preserves SKB_SGO_CB_OFFSET bytes of previous skb cb.</span>
  */
 struct sk_buff *__skb_gso_segment(struct sk_buff *skb,
 				  netdev_features_t features, bool tx_path)
<span class="p_chunk">@@ -2556,6 +2558,9 @@</span> <span class="p_context"> struct sk_buff *__skb_gso_segment(struct sk_buff *skb,</span>
 			return ERR_PTR(err);
 	}
 
<span class="p_add">+	BUILD_BUG_ON(SKB_SGO_CB_OFFSET +</span>
<span class="p_add">+		     sizeof(*SKB_GSO_CB(skb)) &gt; sizeof(skb-&gt;cb));</span>
<span class="p_add">+</span>
 	SKB_GSO_CB(skb)-&gt;mac_offset = skb_headroom(skb);
 	SKB_GSO_CB(skb)-&gt;encap_level = 0;
 
<span class="p_header">diff --git a/net/core/filter.c b/net/core/filter.c</span>
<span class="p_header">index 672eefbfbe99..37157c4c1a78 100644</span>
<span class="p_header">--- a/net/core/filter.c</span>
<span class="p_header">+++ b/net/core/filter.c</span>
<span class="p_chunk">@@ -777,6 +777,11 @@</span> <span class="p_context"> static int bpf_check_classic(const struct sock_filter *filter,</span>
 			if (ftest-&gt;k == 0)
 				return -EINVAL;
 			break;
<span class="p_add">+		case BPF_ALU | BPF_LSH | BPF_K:</span>
<span class="p_add">+		case BPF_ALU | BPF_RSH | BPF_K:</span>
<span class="p_add">+			if (ftest-&gt;k &gt;= 32)</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			break;</span>
 		case BPF_LD | BPF_MEM:
 		case BPF_LDX | BPF_MEM:
 		case BPF_ST:
<span class="p_header">diff --git a/net/core/pktgen.c b/net/core/pktgen.c</span>
<span class="p_header">index de8d5cc5eb24..4da4d51a2ccf 100644</span>
<span class="p_header">--- a/net/core/pktgen.c</span>
<span class="p_header">+++ b/net/core/pktgen.c</span>
<span class="p_chunk">@@ -2787,7 +2787,9 @@</span> <span class="p_context"> static struct sk_buff *pktgen_alloc_skb(struct net_device *dev,</span>
 	} else {
 		 skb = __netdev_alloc_skb(dev, size, GFP_NOWAIT);
 	}
<span class="p_del">-	skb_reserve(skb, LL_RESERVED_SPACE(dev));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (likely(skb))</span>
<span class="p_add">+		skb_reserve(skb, LL_RESERVED_SPACE(dev));</span>
 
 	return skb;
 }
<span class="p_header">diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c</span>
<span class="p_header">index 4233cbe47052..49f02856304d 100644</span>
<span class="p_header">--- a/net/ipv4/ip_output.c</span>
<span class="p_header">+++ b/net/ipv4/ip_output.c</span>
<span class="p_chunk">@@ -240,6 +240,7 @@</span> <span class="p_context"> static int ip_finish_output_gso(struct net *net, struct sock *sk,</span>
 	 * from host network stack.
 	 */
 	features = netif_skb_features(skb);
<span class="p_add">+	BUILD_BUG_ON(sizeof(*IPCB(skb)) &gt; SKB_SGO_CB_OFFSET);</span>
 	segs = skb_gso_segment(skb, features &amp; ~NETIF_F_GSO_MASK);
 	if (IS_ERR_OR_NULL(segs)) {
 		kfree_skb(skb);
<span class="p_chunk">@@ -921,7 +922,7 @@</span> <span class="p_context"> static int __ip_append_data(struct sock *sk,</span>
 	if (((length &gt; mtu) || (skb &amp;&amp; skb_is_gso(skb))) &amp;&amp;
 	    (sk-&gt;sk_protocol == IPPROTO_UDP) &amp;&amp;
 	    (rt-&gt;dst.dev-&gt;features &amp; NETIF_F_UFO) &amp;&amp; !rt-&gt;dst.header_len &amp;&amp;
<span class="p_del">-	    (sk-&gt;sk_type == SOCK_DGRAM)) {</span>
<span class="p_add">+	    (sk-&gt;sk_type == SOCK_DGRAM) &amp;&amp; !sk-&gt;sk_no_check_tx) {</span>
 		err = ip_ufo_append_data(sk, queue, getfrag, from, length,
 					 hh_len, fragheaderlen, transhdrlen,
 					 maxfraglen, flags);
<span class="p_header">diff --git a/net/ipv4/tcp_yeah.c b/net/ipv4/tcp_yeah.c</span>
<span class="p_header">index 17d35662930d..3e6a472e6b88 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_yeah.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_yeah.c</span>
<span class="p_chunk">@@ -219,7 +219,7 @@</span> <span class="p_context"> static u32 tcp_yeah_ssthresh(struct sock *sk)</span>
 	yeah-&gt;fast_count = 0;
 	yeah-&gt;reno_count = max(yeah-&gt;reno_count&gt;&gt;1, 2U);
 
<span class="p_del">-	return tp-&gt;snd_cwnd - reduction;</span>
<span class="p_add">+	return max_t(int, tp-&gt;snd_cwnd - reduction, 2);</span>
 }
 
 static struct tcp_congestion_ops tcp_yeah __read_mostly = {
<span class="p_header">diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c</span>
<span class="p_header">index e6a7bd15b9b7..6473889f1736 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_output.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_output.c</span>
<span class="p_chunk">@@ -1353,7 +1353,7 @@</span> <span class="p_context"> emsgsize:</span>
 	     (skb &amp;&amp; skb_is_gso(skb))) &amp;&amp;
 	    (sk-&gt;sk_protocol == IPPROTO_UDP) &amp;&amp;
 	    (rt-&gt;dst.dev-&gt;features &amp; NETIF_F_UFO) &amp;&amp;
<span class="p_del">-	    (sk-&gt;sk_type == SOCK_DGRAM)) {</span>
<span class="p_add">+	    (sk-&gt;sk_type == SOCK_DGRAM) &amp;&amp; !udp_get_no_check6_tx(sk)) {</span>
 		err = ip6_ufo_append_data(sk, queue, getfrag, from, length,
 					  hh_len, fragheaderlen,
 					  transhdrlen, mtu, flags, fl6);
<span class="p_header">diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">index 6b8a8a9091fa..bd100b47c717 100644</span>
<span class="p_header">--- a/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">+++ b/net/ipv6/tcp_ipv6.c</span>
<span class="p_chunk">@@ -462,8 +462,10 @@</span> <span class="p_context"> static int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,</span>
 		if (np-&gt;repflow &amp;&amp; ireq-&gt;pktopts)
 			fl6-&gt;flowlabel = ip6_flowlabel(ipv6_hdr(ireq-&gt;pktopts));
 
<span class="p_add">+		rcu_read_lock();</span>
 		err = ip6_xmit(sk, skb, fl6, rcu_dereference(np-&gt;opt),
 			       np-&gt;tclass);
<span class="p_add">+		rcu_read_unlock();</span>
 		err = net_xmit_eval(err);
 	}
 
<span class="p_header">diff --git a/net/ipv6/xfrm6_mode_tunnel.c b/net/ipv6/xfrm6_mode_tunnel.c</span>
<span class="p_header">index f7fbdbabe50e..372855eeaf42 100644</span>
<span class="p_header">--- a/net/ipv6/xfrm6_mode_tunnel.c</span>
<span class="p_header">+++ b/net/ipv6/xfrm6_mode_tunnel.c</span>
<span class="p_chunk">@@ -23,7 +23,7 @@</span> <span class="p_context"> static inline void ipip6_ecn_decapsulate(struct sk_buff *skb)</span>
 	struct ipv6hdr *inner_iph = ipipv6_hdr(skb);
 
 	if (INET_ECN_is_ce(XFRM_MODE_SKB_CB(skb)-&gt;tos))
<span class="p_del">-		IP6_ECN_set_ce(inner_iph);</span>
<span class="p_add">+		IP6_ECN_set_ce(skb, inner_iph);</span>
 }
 
 /* Add encapsulation header.
<span class="p_header">diff --git a/net/openvswitch/datapath.c b/net/openvswitch/datapath.c</span>
<span class="p_header">index 91a8b004dc51..deadfdab1bc3 100644</span>
<span class="p_header">--- a/net/openvswitch/datapath.c</span>
<span class="p_header">+++ b/net/openvswitch/datapath.c</span>
<span class="p_chunk">@@ -336,12 +336,10 @@</span> <span class="p_context"> static int queue_gso_packets(struct datapath *dp, struct sk_buff *skb,</span>
 	unsigned short gso_type = skb_shinfo(skb)-&gt;gso_type;
 	struct sw_flow_key later_key;
 	struct sk_buff *segs, *nskb;
<span class="p_del">-	struct ovs_skb_cb ovs_cb;</span>
 	int err;
 
<span class="p_del">-	ovs_cb = *OVS_CB(skb);</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(*OVS_CB(skb)) &gt; SKB_SGO_CB_OFFSET);</span>
 	segs = __skb_gso_segment(skb, NETIF_F_SG, false);
<span class="p_del">-	*OVS_CB(skb) = ovs_cb;</span>
 	if (IS_ERR(segs))
 		return PTR_ERR(segs);
 	if (segs == NULL)
<span class="p_chunk">@@ -359,7 +357,6 @@</span> <span class="p_context"> static int queue_gso_packets(struct datapath *dp, struct sk_buff *skb,</span>
 	/* Queue all of the segments. */
 	skb = segs;
 	do {
<span class="p_del">-		*OVS_CB(skb) = ovs_cb;</span>
 		if (gso_type &amp; SKB_GSO_UDP &amp;&amp; skb != segs)
 			key = &amp;later_key;
 
<span class="p_header">diff --git a/net/phonet/af_phonet.c b/net/phonet/af_phonet.c</span>
<span class="p_header">index 10d42f3220ab..f925753668a7 100644</span>
<span class="p_header">--- a/net/phonet/af_phonet.c</span>
<span class="p_header">+++ b/net/phonet/af_phonet.c</span>
<span class="p_chunk">@@ -377,6 +377,10 @@</span> <span class="p_context"> static int phonet_rcv(struct sk_buff *skb, struct net_device *dev,</span>
 	struct sockaddr_pn sa;
 	u16 len;
 
<span class="p_add">+	skb = skb_share_check(skb, GFP_ATOMIC);</span>
<span class="p_add">+	if (!skb)</span>
<span class="p_add">+		return NET_RX_DROP;</span>
<span class="p_add">+</span>
 	/* check we have at least a full Phonet header */
 	if (!pskb_pull(skb, sizeof(struct phonethdr)))
 		goto out;
<span class="p_header">diff --git a/net/sched/cls_flower.c b/net/sched/cls_flower.c</span>
<span class="p_header">index 57692947ebbe..95b021243233 100644</span>
<span class="p_header">--- a/net/sched/cls_flower.c</span>
<span class="p_header">+++ b/net/sched/cls_flower.c</span>
<span class="p_chunk">@@ -252,23 +252,28 @@</span> <span class="p_context"> static int fl_set_key(struct net *net, struct nlattr **tb,</span>
 	fl_set_key_val(tb, key-&gt;eth.src, TCA_FLOWER_KEY_ETH_SRC,
 		       mask-&gt;eth.src, TCA_FLOWER_KEY_ETH_SRC_MASK,
 		       sizeof(key-&gt;eth.src));
<span class="p_add">+</span>
 	fl_set_key_val(tb, &amp;key-&gt;basic.n_proto, TCA_FLOWER_KEY_ETH_TYPE,
 		       &amp;mask-&gt;basic.n_proto, TCA_FLOWER_UNSPEC,
 		       sizeof(key-&gt;basic.n_proto));
<span class="p_add">+</span>
 	if (key-&gt;basic.n_proto == htons(ETH_P_IP) ||
 	    key-&gt;basic.n_proto == htons(ETH_P_IPV6)) {
 		fl_set_key_val(tb, &amp;key-&gt;basic.ip_proto, TCA_FLOWER_KEY_IP_PROTO,
 			       &amp;mask-&gt;basic.ip_proto, TCA_FLOWER_UNSPEC,
 			       sizeof(key-&gt;basic.ip_proto));
 	}
<span class="p_del">-	if (key-&gt;control.addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS) {</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tb[TCA_FLOWER_KEY_IPV4_SRC] || tb[TCA_FLOWER_KEY_IPV4_DST]) {</span>
<span class="p_add">+		key-&gt;control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;</span>
 		fl_set_key_val(tb, &amp;key-&gt;ipv4.src, TCA_FLOWER_KEY_IPV4_SRC,
 			       &amp;mask-&gt;ipv4.src, TCA_FLOWER_KEY_IPV4_SRC_MASK,
 			       sizeof(key-&gt;ipv4.src));
 		fl_set_key_val(tb, &amp;key-&gt;ipv4.dst, TCA_FLOWER_KEY_IPV4_DST,
 			       &amp;mask-&gt;ipv4.dst, TCA_FLOWER_KEY_IPV4_DST_MASK,
 			       sizeof(key-&gt;ipv4.dst));
<span class="p_del">-	} else if (key-&gt;control.addr_type == FLOW_DISSECTOR_KEY_IPV6_ADDRS) {</span>
<span class="p_add">+	} else if (tb[TCA_FLOWER_KEY_IPV6_SRC] || tb[TCA_FLOWER_KEY_IPV6_DST]) {</span>
<span class="p_add">+		key-&gt;control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;</span>
 		fl_set_key_val(tb, &amp;key-&gt;ipv6.src, TCA_FLOWER_KEY_IPV6_SRC,
 			       &amp;mask-&gt;ipv6.src, TCA_FLOWER_KEY_IPV6_SRC_MASK,
 			       sizeof(key-&gt;ipv6.src));
<span class="p_chunk">@@ -276,6 +281,7 @@</span> <span class="p_context"> static int fl_set_key(struct net *net, struct nlattr **tb,</span>
 			       &amp;mask-&gt;ipv6.dst, TCA_FLOWER_KEY_IPV6_DST_MASK,
 			       sizeof(key-&gt;ipv6.dst));
 	}
<span class="p_add">+</span>
 	if (key-&gt;basic.ip_proto == IPPROTO_TCP) {
 		fl_set_key_val(tb, &amp;key-&gt;tp.src, TCA_FLOWER_KEY_TCP_SRC,
 			       &amp;mask-&gt;tp.src, TCA_FLOWER_UNSPEC,
<span class="p_header">diff --git a/net/sctp/sysctl.c b/net/sctp/sysctl.c</span>
<span class="p_header">index 26d50c565f54..3e0fc5127225 100644</span>
<span class="p_header">--- a/net/sctp/sysctl.c</span>
<span class="p_header">+++ b/net/sctp/sysctl.c</span>
<span class="p_chunk">@@ -320,7 +320,7 @@</span> <span class="p_context"> static int proc_sctp_do_hmac_alg(struct ctl_table *ctl, int write,</span>
 	struct ctl_table tbl;
 	bool changed = false;
 	char *none = &quot;none&quot;;
<span class="p_del">-	char tmp[8];</span>
<span class="p_add">+	char tmp[8] = {0};</span>
 	int ret;
 
 	memset(&amp;tbl, 0, sizeof(struct ctl_table));
<span class="p_header">diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c</span>
<span class="p_header">index ef05cd9403d4..e3f85bc8b135 100644</span>
<span class="p_header">--- a/net/unix/af_unix.c</span>
<span class="p_header">+++ b/net/unix/af_unix.c</span>
<span class="p_chunk">@@ -1513,6 +1513,21 @@</span> <span class="p_context"> static void unix_destruct_scm(struct sk_buff *skb)</span>
 	sock_wfree(skb);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * The &quot;user-&gt;unix_inflight&quot; variable is protected by the garbage</span>
<span class="p_add">+ * collection lock, and we just read it locklessly here. If you go</span>
<span class="p_add">+ * over the limit, there might be a tiny race in actually noticing</span>
<span class="p_add">+ * it across threads. Tough.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline bool too_many_unix_fds(struct task_struct *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct user_struct *user = current_user();</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(user-&gt;unix_inflight &gt; task_rlimit(p, RLIMIT_NOFILE)))</span>
<span class="p_add">+		return !capable(CAP_SYS_RESOURCE) &amp;&amp; !capable(CAP_SYS_ADMIN);</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define MAX_RECURSION_LEVEL 4
 
 static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)
<span class="p_chunk">@@ -1521,6 +1536,9 @@</span> <span class="p_context"> static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)</span>
 	unsigned char max_level = 0;
 	int unix_sock_count = 0;
 
<span class="p_add">+	if (too_many_unix_fds(current))</span>
<span class="p_add">+		return -ETOOMANYREFS;</span>
<span class="p_add">+</span>
 	for (i = scm-&gt;fp-&gt;count - 1; i &gt;= 0; i--) {
 		struct sock *sk = unix_get_socket(scm-&gt;fp-&gt;fp[i]);
 
<span class="p_chunk">@@ -1542,10 +1560,8 @@</span> <span class="p_context"> static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)</span>
 	if (!UNIXCB(skb).fp)
 		return -ENOMEM;
 
<span class="p_del">-	if (unix_sock_count) {</span>
<span class="p_del">-		for (i = scm-&gt;fp-&gt;count - 1; i &gt;= 0; i--)</span>
<span class="p_del">-			unix_inflight(scm-&gt;fp-&gt;fp[i]);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	for (i = scm-&gt;fp-&gt;count - 1; i &gt;= 0; i--)</span>
<span class="p_add">+		unix_inflight(scm-&gt;fp-&gt;fp[i]);</span>
 	return max_level;
 }
 
<span class="p_header">diff --git a/net/unix/garbage.c b/net/unix/garbage.c</span>
<span class="p_header">index a73a226f2d33..8fcdc2283af5 100644</span>
<span class="p_header">--- a/net/unix/garbage.c</span>
<span class="p_header">+++ b/net/unix/garbage.c</span>
<span class="p_chunk">@@ -120,11 +120,11 @@</span> <span class="p_context"> void unix_inflight(struct file *fp)</span>
 {
 	struct sock *s = unix_get_socket(fp);
 
<span class="p_add">+	spin_lock(&amp;unix_gc_lock);</span>
<span class="p_add">+</span>
 	if (s) {
 		struct unix_sock *u = unix_sk(s);
 
<span class="p_del">-		spin_lock(&amp;unix_gc_lock);</span>
<span class="p_del">-</span>
 		if (atomic_long_inc_return(&amp;u-&gt;inflight) == 1) {
 			BUG_ON(!list_empty(&amp;u-&gt;link));
 			list_add_tail(&amp;u-&gt;link, &amp;gc_inflight_list);
<span class="p_chunk">@@ -132,25 +132,28 @@</span> <span class="p_context"> void unix_inflight(struct file *fp)</span>
 			BUG_ON(list_empty(&amp;u-&gt;link));
 		}
 		unix_tot_inflight++;
<span class="p_del">-		spin_unlock(&amp;unix_gc_lock);</span>
 	}
<span class="p_add">+	fp-&gt;f_cred-&gt;user-&gt;unix_inflight++;</span>
<span class="p_add">+	spin_unlock(&amp;unix_gc_lock);</span>
 }
 
 void unix_notinflight(struct file *fp)
 {
 	struct sock *s = unix_get_socket(fp);
 
<span class="p_add">+	spin_lock(&amp;unix_gc_lock);</span>
<span class="p_add">+</span>
 	if (s) {
 		struct unix_sock *u = unix_sk(s);
 
<span class="p_del">-		spin_lock(&amp;unix_gc_lock);</span>
 		BUG_ON(list_empty(&amp;u-&gt;link));
 
 		if (atomic_long_dec_and_test(&amp;u-&gt;inflight))
 			list_del_init(&amp;u-&gt;link);
 		unix_tot_inflight--;
<span class="p_del">-		spin_unlock(&amp;unix_gc_lock);</span>
 	}
<span class="p_add">+	fp-&gt;f_cred-&gt;user-&gt;unix_inflight--;</span>
<span class="p_add">+	spin_unlock(&amp;unix_gc_lock);</span>
 }
 
 static void scan_inflight(struct sock *x, void (*func)(struct unix_sock *),
<span class="p_header">diff --git a/net/xfrm/xfrm_output.c b/net/xfrm/xfrm_output.c</span>
<span class="p_header">index cc3676eb6239..ff4a91fcab9f 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_output.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_output.c</span>
<span class="p_chunk">@@ -167,6 +167,8 @@</span> <span class="p_context"> static int xfrm_output_gso(struct net *net, struct sock *sk, struct sk_buff *skb</span>
 {
 	struct sk_buff *segs;
 
<span class="p_add">+	BUILD_BUG_ON(sizeof(*IPCB(skb)) &gt; SKB_SGO_CB_OFFSET);</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(*IP6CB(skb)) &gt; SKB_SGO_CB_OFFSET);</span>
 	segs = skb_gso_segment(skb, 0);
 	kfree_skb(skb);
 	if (IS_ERR(segs))
<span class="p_header">diff --git a/scripts/recordmcount.pl b/scripts/recordmcount.pl</span>
<span class="p_header">index 826470d7f000..96e2486a6fc4 100755</span>
<span class="p_header">--- a/scripts/recordmcount.pl</span>
<span class="p_header">+++ b/scripts/recordmcount.pl</span>
<span class="p_chunk">@@ -263,7 +263,8 @@</span> <span class="p_context"> if ($arch eq &quot;x86_64&quot;) {</span>
 
 } elsif ($arch eq &quot;powerpc&quot;) {
     $local_regex = &quot;^[0-9a-fA-F]+\\s+t\\s+(\\.?\\S+)&quot;;
<span class="p_del">-    $function_regex = &quot;^([0-9a-fA-F]+)\\s+&lt;(\\.?.*?)&gt;:&quot;;</span>
<span class="p_add">+    # See comment in the sparc64 section for why we use &#39;\w&#39;.</span>
<span class="p_add">+    $function_regex = &quot;^([0-9a-fA-F]+)\\s+&lt;(\\.?\\w*?)&gt;:&quot;;</span>
     $mcount_regex = &quot;^\\s*([0-9a-fA-F]+):.*\\s\\.?_mcount\$&quot;;
 
     if ($bits == 64) {
<span class="p_header">diff --git a/security/keys/process_keys.c b/security/keys/process_keys.c</span>
<span class="p_header">index a3f85d2a00bb..e6d50172872f 100644</span>
<span class="p_header">--- a/security/keys/process_keys.c</span>
<span class="p_header">+++ b/security/keys/process_keys.c</span>
<span class="p_chunk">@@ -794,6 +794,7 @@</span> <span class="p_context"> long join_session_keyring(const char *name)</span>
 		ret = PTR_ERR(keyring);
 		goto error2;
 	} else if (keyring == new-&gt;session_keyring) {
<span class="p_add">+		key_put(keyring);</span>
 		ret = 0;
 		goto error2;
 	}
<span class="p_header">diff --git a/sound/core/control.c b/sound/core/control.c</span>
<span class="p_header">index 196a6fe100ca..a85d45595d02 100644</span>
<span class="p_header">--- a/sound/core/control.c</span>
<span class="p_header">+++ b/sound/core/control.c</span>
<span class="p_chunk">@@ -1405,6 +1405,8 @@</span> <span class="p_context"> static int snd_ctl_tlv_ioctl(struct snd_ctl_file *file,</span>
 		return -EFAULT;
 	if (tlv.length &lt; sizeof(unsigned int) * 2)
 		return -EINVAL;
<span class="p_add">+	if (!tlv.numid)</span>
<span class="p_add">+		return -EINVAL;</span>
 	down_read(&amp;card-&gt;controls_rwsem);
 	kctl = snd_ctl_find_numid(card, tlv.numid);
 	if (kctl == NULL) {
<span class="p_header">diff --git a/sound/core/hrtimer.c b/sound/core/hrtimer.c</span>
<span class="p_header">index f845ecf7e172..656d9a9032dc 100644</span>
<span class="p_header">--- a/sound/core/hrtimer.c</span>
<span class="p_header">+++ b/sound/core/hrtimer.c</span>
<span class="p_chunk">@@ -90,7 +90,7 @@</span> <span class="p_context"> static int snd_hrtimer_start(struct snd_timer *t)</span>
 	struct snd_hrtimer *stime = t-&gt;private_data;
 
 	atomic_set(&amp;stime-&gt;running, 0);
<span class="p_del">-	hrtimer_cancel(&amp;stime-&gt;hrt);</span>
<span class="p_add">+	hrtimer_try_to_cancel(&amp;stime-&gt;hrt);</span>
 	hrtimer_start(&amp;stime-&gt;hrt, ns_to_ktime(t-&gt;sticks * resolution),
 		      HRTIMER_MODE_REL);
 	atomic_set(&amp;stime-&gt;running, 1);
<span class="p_chunk">@@ -101,6 +101,7 @@</span> <span class="p_context"> static int snd_hrtimer_stop(struct snd_timer *t)</span>
 {
 	struct snd_hrtimer *stime = t-&gt;private_data;
 	atomic_set(&amp;stime-&gt;running, 0);
<span class="p_add">+	hrtimer_try_to_cancel(&amp;stime-&gt;hrt);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/sound/core/pcm_compat.c b/sound/core/pcm_compat.c</span>
<span class="p_header">index b48b434444ed..9630e9f72b7b 100644</span>
<span class="p_header">--- a/sound/core/pcm_compat.c</span>
<span class="p_header">+++ b/sound/core/pcm_compat.c</span>
<span class="p_chunk">@@ -255,10 +255,15 @@</span> <span class="p_context"> static int snd_pcm_ioctl_hw_params_compat(struct snd_pcm_substream *substream,</span>
 	if (! (runtime = substream-&gt;runtime))
 		return -ENOTTY;
 
<span class="p_del">-	/* only fifo_size is different, so just copy all */</span>
<span class="p_del">-	data = memdup_user(data32, sizeof(*data32));</span>
<span class="p_del">-	if (IS_ERR(data))</span>
<span class="p_del">-		return PTR_ERR(data);</span>
<span class="p_add">+	data = kmalloc(sizeof(*data), GFP_KERNEL);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* only fifo_size (RO from userspace) is different, so just copy all */</span>
<span class="p_add">+	if (copy_from_user(data, data32, sizeof(*data32))) {</span>
<span class="p_add">+		err = -EFAULT;</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	}</span>
 
 	if (refine)
 		err = snd_pcm_hw_refine(substream, data);
<span class="p_header">diff --git a/sound/core/seq/seq_clientmgr.c b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">index b64f20deba90..13cfa815732d 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_chunk">@@ -1962,7 +1962,7 @@</span> <span class="p_context"> static int snd_seq_ioctl_remove_events(struct snd_seq_client *client,</span>
 		 * No restrictions so for a user client we can clear
 		 * the whole fifo
 		 */
<span class="p_del">-		if (client-&gt;type == USER_CLIENT)</span>
<span class="p_add">+		if (client-&gt;type == USER_CLIENT &amp;&amp; client-&gt;data.user.fifo)</span>
 			snd_seq_fifo_clear(client-&gt;data.user.fifo);
 	}
 
<span class="p_header">diff --git a/sound/core/seq/seq_compat.c b/sound/core/seq/seq_compat.c</span>
<span class="p_header">index 81f7c109dc46..65175902a68a 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_compat.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_compat.c</span>
<span class="p_chunk">@@ -49,11 +49,12 @@</span> <span class="p_context"> static int snd_seq_call_port_info_ioctl(struct snd_seq_client *client, unsigned</span>
 	struct snd_seq_port_info *data;
 	mm_segment_t fs;
 
<span class="p_del">-	data = memdup_user(data32, sizeof(*data32));</span>
<span class="p_del">-	if (IS_ERR(data))</span>
<span class="p_del">-		return PTR_ERR(data);</span>
<span class="p_add">+	data = kmalloc(sizeof(*data), GFP_KERNEL);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
<span class="p_del">-	if (get_user(data-&gt;flags, &amp;data32-&gt;flags) ||</span>
<span class="p_add">+	if (copy_from_user(data, data32, sizeof(*data32)) ||</span>
<span class="p_add">+	    get_user(data-&gt;flags, &amp;data32-&gt;flags) ||</span>
 	    get_user(data-&gt;time_queue, &amp;data32-&gt;time_queue))
 		goto error;
 	data-&gt;kernel = NULL;
<span class="p_header">diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c</span>
<span class="p_header">index 7dfd0f429410..0bec02e89d51 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_queue.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_queue.c</span>
<span class="p_chunk">@@ -142,8 +142,10 @@</span> <span class="p_context"> static struct snd_seq_queue *queue_new(int owner, int locked)</span>
 static void queue_delete(struct snd_seq_queue *q)
 {
 	/* stop and release the timer */
<span class="p_add">+	mutex_lock(&amp;q-&gt;timer_mutex);</span>
 	snd_seq_timer_stop(q-&gt;timer);
 	snd_seq_timer_close(q);
<span class="p_add">+	mutex_unlock(&amp;q-&gt;timer_mutex);</span>
 	/* wait until access free */
 	snd_use_lock_sync(&amp;q-&gt;use_lock);
 	/* release resources... */
<span class="p_header">diff --git a/sound/core/timer.c b/sound/core/timer.c</span>
<span class="p_header">index 31f40f03e5b7..0a049c4578f1 100644</span>
<span class="p_header">--- a/sound/core/timer.c</span>
<span class="p_header">+++ b/sound/core/timer.c</span>
<span class="p_chunk">@@ -65,6 +65,7 @@</span> <span class="p_context"> struct snd_timer_user {</span>
 	int qtail;
 	int qused;
 	int queue_size;
<span class="p_add">+	bool disconnected;</span>
 	struct snd_timer_read *queue;
 	struct snd_timer_tread *tqueue;
 	spinlock_t qlock;
<span class="p_chunk">@@ -73,7 +74,7 @@</span> <span class="p_context"> struct snd_timer_user {</span>
 	struct timespec tstamp;		/* trigger tstamp */
 	wait_queue_head_t qchange_sleep;
 	struct fasync_struct *fasync;
<span class="p_del">-	struct mutex tread_sem;</span>
<span class="p_add">+	struct mutex ioctl_lock;</span>
 };
 
 /* list of timers */
<span class="p_chunk">@@ -215,11 +216,13 @@</span> <span class="p_context"> static void snd_timer_check_master(struct snd_timer_instance *master)</span>
 		    slave-&gt;slave_id == master-&gt;slave_id) {
 			list_move_tail(&amp;slave-&gt;open_list, &amp;master-&gt;slave_list_head);
 			spin_lock_irq(&amp;slave_active_lock);
<span class="p_add">+			spin_lock(&amp;master-&gt;timer-&gt;lock);</span>
 			slave-&gt;master = master;
 			slave-&gt;timer = master-&gt;timer;
 			if (slave-&gt;flags &amp; SNDRV_TIMER_IFLG_RUNNING)
 				list_add_tail(&amp;slave-&gt;active_list,
 					      &amp;master-&gt;slave_active_head);
<span class="p_add">+			spin_unlock(&amp;master-&gt;timer-&gt;lock);</span>
 			spin_unlock_irq(&amp;slave_active_lock);
 		}
 	}
<span class="p_chunk">@@ -288,6 +291,9 @@</span> <span class="p_context"> int snd_timer_open(struct snd_timer_instance **ti,</span>
 		mutex_unlock(&amp;register_mutex);
 		return -ENOMEM;
 	}
<span class="p_add">+	/* take a card refcount for safe disconnection */</span>
<span class="p_add">+	if (timer-&gt;card)</span>
<span class="p_add">+		get_device(&amp;timer-&gt;card-&gt;card_dev);</span>
 	timeri-&gt;slave_class = tid-&gt;dev_sclass;
 	timeri-&gt;slave_id = slave_id;
 	if (list_empty(&amp;timer-&gt;open_list_head) &amp;&amp; timer-&gt;hw.open)
<span class="p_chunk">@@ -346,15 +352,21 @@</span> <span class="p_context"> int snd_timer_close(struct snd_timer_instance *timeri)</span>
 		    timer-&gt;hw.close)
 			timer-&gt;hw.close(timer);
 		/* remove slave links */
<span class="p_add">+		spin_lock_irq(&amp;slave_active_lock);</span>
<span class="p_add">+		spin_lock(&amp;timer-&gt;lock);</span>
 		list_for_each_entry_safe(slave, tmp, &amp;timeri-&gt;slave_list_head,
 					 open_list) {
<span class="p_del">-			spin_lock_irq(&amp;slave_active_lock);</span>
<span class="p_del">-			_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);</span>
 			list_move_tail(&amp;slave-&gt;open_list, &amp;snd_timer_slave_list);
 			slave-&gt;master = NULL;
 			slave-&gt;timer = NULL;
<span class="p_del">-			spin_unlock_irq(&amp;slave_active_lock);</span>
<span class="p_add">+			list_del_init(&amp;slave-&gt;ack_list);</span>
<span class="p_add">+			list_del_init(&amp;slave-&gt;active_list);</span>
 		}
<span class="p_add">+		spin_unlock(&amp;timer-&gt;lock);</span>
<span class="p_add">+		spin_unlock_irq(&amp;slave_active_lock);</span>
<span class="p_add">+		/* release a card refcount for safe disconnection */</span>
<span class="p_add">+		if (timer-&gt;card)</span>
<span class="p_add">+			put_device(&amp;timer-&gt;card-&gt;card_dev);</span>
 		mutex_unlock(&amp;register_mutex);
 	}
  out:
<span class="p_chunk">@@ -441,9 +453,12 @@</span> <span class="p_context"> static int snd_timer_start_slave(struct snd_timer_instance *timeri)</span>
 
 	spin_lock_irqsave(&amp;slave_active_lock, flags);
 	timeri-&gt;flags |= SNDRV_TIMER_IFLG_RUNNING;
<span class="p_del">-	if (timeri-&gt;master)</span>
<span class="p_add">+	if (timeri-&gt;master &amp;&amp; timeri-&gt;timer) {</span>
<span class="p_add">+		spin_lock(&amp;timeri-&gt;timer-&gt;lock);</span>
 		list_add_tail(&amp;timeri-&gt;active_list,
 			      &amp;timeri-&gt;master-&gt;slave_active_head);
<span class="p_add">+		spin_unlock(&amp;timeri-&gt;timer-&gt;lock);</span>
<span class="p_add">+	}</span>
 	spin_unlock_irqrestore(&amp;slave_active_lock, flags);
 	return 1; /* delayed start */
 }
<span class="p_chunk">@@ -467,6 +482,8 @@</span> <span class="p_context"> int snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks)</span>
 	timer = timeri-&gt;timer;
 	if (timer == NULL)
 		return -EINVAL;
<span class="p_add">+	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown)</span>
<span class="p_add">+		return -ENODEV;</span>
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
 	timeri-&gt;ticks = timeri-&gt;cticks = ticks;
 	timeri-&gt;pticks = 0;
<span class="p_chunk">@@ -489,6 +506,8 @@</span> <span class="p_context"> static int _snd_timer_stop(struct snd_timer_instance * timeri,</span>
 		if (!keep_flag) {
 			spin_lock_irqsave(&amp;slave_active_lock, flags);
 			timeri-&gt;flags &amp;= ~SNDRV_TIMER_IFLG_RUNNING;
<span class="p_add">+			list_del_init(&amp;timeri-&gt;ack_list);</span>
<span class="p_add">+			list_del_init(&amp;timeri-&gt;active_list);</span>
 			spin_unlock_irqrestore(&amp;slave_active_lock, flags);
 		}
 		goto __end;
<span class="p_chunk">@@ -499,6 +518,10 @@</span> <span class="p_context"> static int _snd_timer_stop(struct snd_timer_instance * timeri,</span>
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
 	list_del_init(&amp;timeri-&gt;ack_list);
 	list_del_init(&amp;timeri-&gt;active_list);
<span class="p_add">+	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown) {</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;timer-&gt;lock, flags);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
 	if ((timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_RUNNING) &amp;&amp;
 	    !(--timer-&gt;running)) {
 		timer-&gt;hw.stop(timer);
<span class="p_chunk">@@ -561,6 +584,8 @@</span> <span class="p_context"> int snd_timer_continue(struct snd_timer_instance *timeri)</span>
 	timer = timeri-&gt;timer;
 	if (! timer)
 		return -EINVAL;
<span class="p_add">+	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown)</span>
<span class="p_add">+		return -ENODEV;</span>
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
 	if (!timeri-&gt;cticks)
 		timeri-&gt;cticks = 1;
<span class="p_chunk">@@ -624,6 +649,9 @@</span> <span class="p_context"> static void snd_timer_tasklet(unsigned long arg)</span>
 	unsigned long resolution, ticks;
 	unsigned long flags;
 
<span class="p_add">+	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
 	/* now process all callbacks */
 	while (!list_empty(&amp;timer-&gt;sack_list_head)) {
<span class="p_chunk">@@ -664,6 +692,9 @@</span> <span class="p_context"> void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)</span>
 	if (timer == NULL)
 		return;
 
<span class="p_add">+	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
 
 	/* remember the current resolution */
<span class="p_chunk">@@ -694,7 +725,7 @@</span> <span class="p_context"> void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)</span>
 		} else {
 			ti-&gt;flags &amp;= ~SNDRV_TIMER_IFLG_RUNNING;
 			if (--timer-&gt;running)
<span class="p_del">-				list_del(&amp;ti-&gt;active_list);</span>
<span class="p_add">+				list_del_init(&amp;ti-&gt;active_list);</span>
 		}
 		if ((timer-&gt;hw.flags &amp; SNDRV_TIMER_HW_TASKLET) ||
 		    (ti-&gt;flags &amp; SNDRV_TIMER_IFLG_FAST))
<span class="p_chunk">@@ -874,11 +905,28 @@</span> <span class="p_context"> static int snd_timer_dev_register(struct snd_device *dev)</span>
 	return 0;
 }
 
<span class="p_add">+/* just for reference in snd_timer_dev_disconnect() below */</span>
<span class="p_add">+static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,</span>
<span class="p_add">+				     int event, struct timespec *tstamp,</span>
<span class="p_add">+				     unsigned long resolution);</span>
<span class="p_add">+</span>
 static int snd_timer_dev_disconnect(struct snd_device *device)
 {
 	struct snd_timer *timer = device-&gt;device_data;
<span class="p_add">+	struct snd_timer_instance *ti;</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;register_mutex);
 	list_del_init(&amp;timer-&gt;device_list);
<span class="p_add">+	/* wake up pending sleepers */</span>
<span class="p_add">+	list_for_each_entry(ti, &amp;timer-&gt;open_list_head, open_list) {</span>
<span class="p_add">+		/* FIXME: better to have a ti.disconnect() op */</span>
<span class="p_add">+		if (ti-&gt;ccallback == snd_timer_user_ccallback) {</span>
<span class="p_add">+			struct snd_timer_user *tu = ti-&gt;callback_data;</span>
<span class="p_add">+</span>
<span class="p_add">+			tu-&gt;disconnected = true;</span>
<span class="p_add">+			wake_up(&amp;tu-&gt;qchange_sleep);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 	mutex_unlock(&amp;register_mutex);
 	return 0;
 }
<span class="p_chunk">@@ -889,6 +937,8 @@</span> <span class="p_context"> void snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstam</span>
 	unsigned long resolution = 0;
 	struct snd_timer_instance *ti, *ts;
 
<span class="p_add">+	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown)</span>
<span class="p_add">+		return;</span>
 	if (! (timer-&gt;hw.flags &amp; SNDRV_TIMER_HW_SLAVE))
 		return;
 	if (snd_BUG_ON(event &lt; SNDRV_TIMER_EVENT_MSTART ||
<span class="p_chunk">@@ -1047,6 +1097,8 @@</span> <span class="p_context"> static void snd_timer_proc_read(struct snd_info_entry *entry,</span>
 
 	mutex_lock(&amp;register_mutex);
 	list_for_each_entry(timer, &amp;snd_timer_list, device_list) {
<span class="p_add">+		if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown)</span>
<span class="p_add">+			continue;</span>
 		switch (timer-&gt;tmr_class) {
 		case SNDRV_TIMER_CLASS_GLOBAL:
 			snd_iprintf(buffer, &quot;G%i: &quot;, timer-&gt;tmr_device);
<span class="p_chunk">@@ -1253,7 +1305,7 @@</span> <span class="p_context"> static int snd_timer_user_open(struct inode *inode, struct file *file)</span>
 		return -ENOMEM;
 	spin_lock_init(&amp;tu-&gt;qlock);
 	init_waitqueue_head(&amp;tu-&gt;qchange_sleep);
<span class="p_del">-	mutex_init(&amp;tu-&gt;tread_sem);</span>
<span class="p_add">+	mutex_init(&amp;tu-&gt;ioctl_lock);</span>
 	tu-&gt;ticks = 1;
 	tu-&gt;queue_size = 128;
 	tu-&gt;queue = kmalloc(tu-&gt;queue_size * sizeof(struct snd_timer_read),
<span class="p_chunk">@@ -1273,8 +1325,10 @@</span> <span class="p_context"> static int snd_timer_user_release(struct inode *inode, struct file *file)</span>
 	if (file-&gt;private_data) {
 		tu = file-&gt;private_data;
 		file-&gt;private_data = NULL;
<span class="p_add">+		mutex_lock(&amp;tu-&gt;ioctl_lock);</span>
 		if (tu-&gt;timeri)
 			snd_timer_close(tu-&gt;timeri);
<span class="p_add">+		mutex_unlock(&amp;tu-&gt;ioctl_lock);</span>
 		kfree(tu-&gt;queue);
 		kfree(tu-&gt;tqueue);
 		kfree(tu);
<span class="p_chunk">@@ -1512,7 +1566,6 @@</span> <span class="p_context"> static int snd_timer_user_tselect(struct file *file,</span>
 	int err = 0;
 
 	tu = file-&gt;private_data;
<span class="p_del">-	mutex_lock(&amp;tu-&gt;tread_sem);</span>
 	if (tu-&gt;timeri) {
 		snd_timer_close(tu-&gt;timeri);
 		tu-&gt;timeri = NULL;
<span class="p_chunk">@@ -1556,7 +1609,6 @@</span> <span class="p_context"> static int snd_timer_user_tselect(struct file *file,</span>
 	}
 
       __err:
<span class="p_del">-      	mutex_unlock(&amp;tu-&gt;tread_sem);</span>
 	return err;
 }
 
<span class="p_chunk">@@ -1769,7 +1821,7 @@</span> <span class="p_context"> enum {</span>
 	SNDRV_TIMER_IOCTL_PAUSE_OLD = _IO(&#39;T&#39;, 0x23),
 };
 
<span class="p_del">-static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,</span>
<span class="p_add">+static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,</span>
 				 unsigned long arg)
 {
 	struct snd_timer_user *tu;
<span class="p_chunk">@@ -1786,17 +1838,11 @@</span> <span class="p_context"> static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,</span>
 	{
 		int xarg;
 
<span class="p_del">-		mutex_lock(&amp;tu-&gt;tread_sem);</span>
<span class="p_del">-		if (tu-&gt;timeri)	{	/* too late */</span>
<span class="p_del">-			mutex_unlock(&amp;tu-&gt;tread_sem);</span>
<span class="p_add">+		if (tu-&gt;timeri)	/* too late */</span>
 			return -EBUSY;
<span class="p_del">-		}</span>
<span class="p_del">-		if (get_user(xarg, p)) {</span>
<span class="p_del">-			mutex_unlock(&amp;tu-&gt;tread_sem);</span>
<span class="p_add">+		if (get_user(xarg, p))</span>
 			return -EFAULT;
<span class="p_del">-		}</span>
 		tu-&gt;tread = xarg ? 1 : 0;
<span class="p_del">-		mutex_unlock(&amp;tu-&gt;tread_sem);</span>
 		return 0;
 	}
 	case SNDRV_TIMER_IOCTL_GINFO:
<span class="p_chunk">@@ -1829,6 +1875,18 @@</span> <span class="p_context"> static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,</span>
 	return -ENOTTY;
 }
 
<span class="p_add">+static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,</span>
<span class="p_add">+				 unsigned long arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct snd_timer_user *tu = file-&gt;private_data;</span>
<span class="p_add">+	long ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;tu-&gt;ioctl_lock);</span>
<span class="p_add">+	ret = __snd_timer_user_ioctl(file, cmd, arg);</span>
<span class="p_add">+	mutex_unlock(&amp;tu-&gt;ioctl_lock);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int snd_timer_user_fasync(int fd, struct file * file, int on)
 {
 	struct snd_timer_user *tu;
<span class="p_chunk">@@ -1866,6 +1924,10 @@</span> <span class="p_context"> static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,</span>
 
 			remove_wait_queue(&amp;tu-&gt;qchange_sleep, &amp;wait);
 
<span class="p_add">+			if (tu-&gt;disconnected) {</span>
<span class="p_add">+				err = -ENODEV;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
 			if (signal_pending(current)) {
 				err = -ERESTARTSYS;
 				break;
<span class="p_chunk">@@ -1915,6 +1977,8 @@</span> <span class="p_context"> static unsigned int snd_timer_user_poll(struct file *file, poll_table * wait)</span>
 	mask = 0;
 	if (tu-&gt;qused)
 		mask |= POLLIN | POLLRDNORM;
<span class="p_add">+	if (tu-&gt;disconnected)</span>
<span class="p_add">+		mask |= POLLERR;</span>
 
 	return mask;
 }
<span class="p_header">diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c</span>
<span class="p_header">index 70671ad65d24..6efadbfb3fe3 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_bind.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_bind.c</span>
<span class="p_chunk">@@ -174,14 +174,40 @@</span> <span class="p_context"> static inline bool codec_probed(struct hda_codec *codec)</span>
 	return device_attach(hda_codec_dev(codec)) &gt; 0 &amp;&amp; codec-&gt;preset;
 }
 
<span class="p_del">-/* try to auto-load and bind the codec module */</span>
<span class="p_del">-static void codec_bind_module(struct hda_codec *codec)</span>
<span class="p_add">+/* try to auto-load codec module */</span>
<span class="p_add">+static void request_codec_module(struct hda_codec *codec)</span>
 {
 #ifdef MODULE
 	char modalias[32];
<span class="p_add">+	const char *mod = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (codec-&gt;probe_id) {</span>
<span class="p_add">+	case HDA_CODEC_ID_GENERIC_HDMI:</span>
<span class="p_add">+#if IS_MODULE(CONFIG_SND_HDA_CODEC_HDMI)</span>
<span class="p_add">+		mod = &quot;snd-hda-codec-hdmi&quot;;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HDA_CODEC_ID_GENERIC:</span>
<span class="p_add">+#if IS_MODULE(CONFIG_SND_HDA_GENERIC)</span>
<span class="p_add">+		mod = &quot;snd-hda-codec-generic&quot;;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		snd_hdac_codec_modalias(&amp;codec-&gt;core, modalias, sizeof(modalias));</span>
<span class="p_add">+		mod = modalias;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mod)</span>
<span class="p_add">+		request_module(mod);</span>
<span class="p_add">+#endif /* MODULE */</span>
<span class="p_add">+}</span>
 
<span class="p_del">-	snd_hdac_codec_modalias(&amp;codec-&gt;core, modalias, sizeof(modalias));</span>
<span class="p_del">-	request_module(modalias);</span>
<span class="p_add">+/* try to auto-load and bind the codec module */</span>
<span class="p_add">+static void codec_bind_module(struct hda_codec *codec)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef MODULE</span>
<span class="p_add">+	request_codec_module(codec);</span>
 	if (codec_probed(codec))
 		return;
 #endif
<span class="p_chunk">@@ -218,17 +244,13 @@</span> <span class="p_context"> static int codec_bind_generic(struct hda_codec *codec)</span>
 
 	if (is_likely_hdmi_codec(codec)) {
 		codec-&gt;probe_id = HDA_CODEC_ID_GENERIC_HDMI;
<span class="p_del">-#if IS_MODULE(CONFIG_SND_HDA_CODEC_HDMI)</span>
<span class="p_del">-		request_module(&quot;snd-hda-codec-hdmi&quot;);</span>
<span class="p_del">-#endif</span>
<span class="p_add">+		request_codec_module(codec);</span>
 		if (codec_probed(codec))
 			return 0;
 	}
 
 	codec-&gt;probe_id = HDA_CODEC_ID_GENERIC;
<span class="p_del">-#if IS_MODULE(CONFIG_SND_HDA_GENERIC)</span>
<span class="p_del">-	request_module(&quot;snd-hda-codec-generic&quot;);</span>
<span class="p_del">-#endif</span>
<span class="p_add">+	request_codec_module(codec);</span>
 	if (codec_probed(codec))
 		return 0;
 	return -ENODEV;
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index 3b3658297070..614baff1f5d7 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -2126,9 +2126,17 @@</span> <span class="p_context"> i915_power_fail:</span>
 static void azx_remove(struct pci_dev *pci)
 {
 	struct snd_card *card = pci_get_drvdata(pci);
<span class="p_add">+	struct azx *chip;</span>
<span class="p_add">+	struct hda_intel *hda;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (card) {</span>
<span class="p_add">+		/* flush the pending probing work */</span>
<span class="p_add">+		chip = card-&gt;private_data;</span>
<span class="p_add">+		hda = container_of(chip, struct hda_intel, chip);</span>
<span class="p_add">+		flush_work(&amp;hda-&gt;probe_work);</span>
 
<span class="p_del">-	if (card)</span>
 		snd_card_free(card);
<span class="p_add">+	}</span>
 }
 
 static void azx_shutdown(struct pci_dev *pci)
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 3a89d82f8057..33753244f48f 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -4666,6 +4666,7 @@</span> <span class="p_context"> enum {</span>
 	ALC290_FIXUP_SUBWOOFER,
 	ALC290_FIXUP_SUBWOOFER_HSJACK,
 	ALC269_FIXUP_THINKPAD_ACPI,
<span class="p_add">+	ALC269_FIXUP_DMIC_THINKPAD_ACPI,</span>
 	ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
 	ALC255_FIXUP_DELL2_MIC_NO_PRESENCE,
 	ALC255_FIXUP_HEADSET_MODE,
<span class="p_chunk">@@ -5103,6 +5104,12 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 		.type = HDA_FIXUP_FUNC,
 		.v.func = hda_fixup_thinkpad_acpi,
 	},
<span class="p_add">+	[ALC269_FIXUP_DMIC_THINKPAD_ACPI] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc_fixup_inv_dmic,</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC269_FIXUP_THINKPAD_ACPI,</span>
<span class="p_add">+	},</span>
 	[ALC255_FIXUP_DELL1_MIC_NO_PRESENCE] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
<span class="p_chunk">@@ -5324,6 +5331,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x0470, &quot;Dell M101z&quot;, ALC269_FIXUP_DELL_M101Z),
 	SND_PCI_QUIRK(0x1028, 0x054b, &quot;Dell XPS one 2710&quot;, ALC275_FIXUP_DELL_XPS),
 	SND_PCI_QUIRK(0x1028, 0x05bd, &quot;Dell Latitude E6440&quot;, ALC292_FIXUP_DELL_E7X),
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x05be, &quot;Dell Latitude E6540&quot;, ALC292_FIXUP_DELL_E7X),</span>
 	SND_PCI_QUIRK(0x1028, 0x05ca, &quot;Dell Latitude E7240&quot;, ALC292_FIXUP_DELL_E7X),
 	SND_PCI_QUIRK(0x1028, 0x05cb, &quot;Dell Latitude E7440&quot;, ALC292_FIXUP_DELL_E7X),
 	SND_PCI_QUIRK(0x1028, 0x05da, &quot;Dell Vostro 5460&quot;, ALC290_FIXUP_SUBWOOFER),
<span class="p_chunk">@@ -5332,6 +5340,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x05f6, &quot;Dell&quot;, ALC269_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x0615, &quot;Dell Vostro 5470&quot;, ALC290_FIXUP_SUBWOOFER_HSJACK),
 	SND_PCI_QUIRK(0x1028, 0x0616, &quot;Dell Vostro 5470&quot;, ALC290_FIXUP_SUBWOOFER_HSJACK),
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x062c, &quot;Dell Latitude E5550&quot;, ALC292_FIXUP_DELL_E7X),</span>
 	SND_PCI_QUIRK(0x1028, 0x062e, &quot;Dell Latitude E7450&quot;, ALC292_FIXUP_DELL_E7X),
 	SND_PCI_QUIRK(0x1028, 0x0638, &quot;Dell Inspiron 5439&quot;, ALC290_FIXUP_MONO_SPEAKERS_HSJACK),
 	SND_PCI_QUIRK(0x1028, 0x064a, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
<span class="p_chunk">@@ -5457,6 +5466,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x2226, &quot;ThinkPad X250&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2233, &quot;Thinkpad&quot;, ALC293_FIXUP_LENOVO_SPK_NOISE),
 	SND_PCI_QUIRK(0x17aa, 0x30bb, &quot;ThinkCentre AIO&quot;, ALC233_FIXUP_LENOVO_LINE2_MIC_HOTKEY),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x3902, &quot;Lenovo E50-80&quot;, ALC269_FIXUP_DMIC_THINKPAD_ACPI),</span>
 	SND_PCI_QUIRK(0x17aa, 0x3977, &quot;IdeaPad S210&quot;, ALC283_FIXUP_INT_MIC),
 	SND_PCI_QUIRK(0x17aa, 0x3978, &quot;IdeaPad Y410P&quot;, ALC269_FIXUP_NO_SHUTUP),
 	SND_PCI_QUIRK(0x17aa, 0x5013, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
<span class="p_chunk">@@ -5617,6 +5627,10 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 		{0x21, 0x02211040}),
 	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
 		{0x12, 0x90a60170},
<span class="p_add">+		{0x14, 0x90171130},</span>
<span class="p_add">+		{0x21, 0x02211040}),</span>
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
<span class="p_add">+		{0x12, 0x90a60170},</span>
 		{0x14, 0x90170140},
 		{0x21, 0x02211050}),
 	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell Inspiron 5548&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
<span class="p_chunk">@@ -6552,6 +6566,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc662_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x069f, &quot;Dell&quot;, ALC668_FIXUP_DELL_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x103c, 0x1632, &quot;HP RP5800&quot;, ALC662_FIXUP_HP_RP5800),
 	SND_PCI_QUIRK(0x1043, 0x11cd, &quot;Asus N550&quot;, ALC662_FIXUP_BASS_1A),
<span class="p_add">+	SND_PCI_QUIRK(0x1043, 0x13df, &quot;Asus N550JX&quot;, ALC662_FIXUP_BASS_1A),</span>
 	SND_PCI_QUIRK(0x1043, 0x1477, &quot;ASUS N56VZ&quot;, ALC662_FIXUP_BASS_MODE4_CHMAP),
 	SND_PCI_QUIRK(0x1043, 0x15a7, &quot;ASUS UX51VZH&quot;, ALC662_FIXUP_BASS_16),
 	SND_PCI_QUIRK(0x1043, 0x1b73, &quot;ASUS N55SF&quot;, ALC662_FIXUP_BASS_16),
<span class="p_header">diff --git a/sound/soc/codecs/wm5110.c b/sound/soc/codecs/wm5110.c</span>
<span class="p_header">index c04c0bc6f58a..52b9ccf6d389 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm5110.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm5110.c</span>
<span class="p_chunk">@@ -360,15 +360,13 @@</span> <span class="p_context"> static int wm5110_hp_ev(struct snd_soc_dapm_widget *w,</span>
 
 static int wm5110_clear_pga_volume(struct arizona *arizona, int output)
 {
<span class="p_del">-	struct reg_sequence clear_pga = {</span>
<span class="p_del">-		ARIZONA_OUTPUT_PATH_CONFIG_1L + output * 4, 0x80</span>
<span class="p_del">-	};</span>
<span class="p_add">+	unsigned int reg = ARIZONA_OUTPUT_PATH_CONFIG_1L + output * 4;</span>
 	int ret;
 
<span class="p_del">-	ret = regmap_multi_reg_write_bypassed(arizona-&gt;regmap, &amp;clear_pga, 1);</span>
<span class="p_add">+	ret = regmap_write(arizona-&gt;regmap, reg, 0x80);</span>
 	if (ret)
 		dev_err(arizona-&gt;dev, &quot;Failed to clear PGA (0x%x): %d\n&quot;,
<span class="p_del">-			clear_pga.reg, ret);</span>
<span class="p_add">+			reg, ret);</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/sound/soc/soc-compress.c b/sound/soc/soc-compress.c</span>
<span class="p_header">index 12a9820feac1..bb82bb966000 100644</span>
<span class="p_header">--- a/sound/soc/soc-compress.c</span>
<span class="p_header">+++ b/sound/soc/soc-compress.c</span>
<span class="p_chunk">@@ -630,6 +630,7 @@</span> <span class="p_context"> int snd_soc_new_compress(struct snd_soc_pcm_runtime *rtd, int num)</span>
 	struct snd_pcm *be_pcm;
 	char new_name[64];
 	int ret = 0, direction = 0;
<span class="p_add">+	int playback = 0, capture = 0;</span>
 
 	if (rtd-&gt;num_codecs &gt; 1) {
 		dev_err(rtd-&gt;card-&gt;dev, &quot;Multicodec not supported for compressed stream\n&quot;);
<span class="p_chunk">@@ -641,11 +642,27 @@</span> <span class="p_context"> int snd_soc_new_compress(struct snd_soc_pcm_runtime *rtd, int num)</span>
 			rtd-&gt;dai_link-&gt;stream_name, codec_dai-&gt;name, num);
 
 	if (codec_dai-&gt;driver-&gt;playback.channels_min)
<span class="p_add">+		playback = 1;</span>
<span class="p_add">+	if (codec_dai-&gt;driver-&gt;capture.channels_min)</span>
<span class="p_add">+		capture = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	capture = capture &amp;&amp; cpu_dai-&gt;driver-&gt;capture.channels_min;</span>
<span class="p_add">+	playback = playback &amp;&amp; cpu_dai-&gt;driver-&gt;playback.channels_min;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Compress devices are unidirectional so only one of the directions</span>
<span class="p_add">+	 * should be set, check for that (xor)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (playback + capture != 1) {</span>
<span class="p_add">+		dev_err(rtd-&gt;card-&gt;dev, &quot;Invalid direction for compress P %d, C %d\n&quot;,</span>
<span class="p_add">+				playback, capture);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if(playback)</span>
 		direction = SND_COMPRESS_PLAYBACK;
<span class="p_del">-	else if (codec_dai-&gt;driver-&gt;capture.channels_min)</span>
<span class="p_del">-		direction = SND_COMPRESS_CAPTURE;</span>
 	else
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		direction = SND_COMPRESS_CAPTURE;</span>
 
 	compr = kzalloc(sizeof(*compr), GFP_KERNEL);
 	if (compr == NULL) {
<span class="p_header">diff --git a/sound/usb/card.c b/sound/usb/card.c</span>
<span class="p_header">index 18f56646ce86..1f09d9591276 100644</span>
<span class="p_header">--- a/sound/usb/card.c</span>
<span class="p_header">+++ b/sound/usb/card.c</span>
<span class="p_chunk">@@ -675,6 +675,8 @@</span> <span class="p_context"> int snd_usb_autoresume(struct snd_usb_audio *chip)</span>
 
 void snd_usb_autosuspend(struct snd_usb_audio *chip)
 {
<span class="p_add">+	if (atomic_read(&amp;chip-&gt;shutdown))</span>
<span class="p_add">+		return;</span>
 	if (atomic_dec_and_test(&amp;chip-&gt;active))
 		usb_autopm_put_interface(chip-&gt;pm_intf);
 }
<span class="p_header">diff --git a/sound/usb/mixer_quirks.c b/sound/usb/mixer_quirks.c</span>
<span class="p_header">index 0ce888dceed0..279025650568 100644</span>
<span class="p_header">--- a/sound/usb/mixer_quirks.c</span>
<span class="p_header">+++ b/sound/usb/mixer_quirks.c</span>
<span class="p_chunk">@@ -793,7 +793,7 @@</span> <span class="p_context"> static int snd_nativeinstruments_control_put(struct snd_kcontrol *kcontrol,</span>
 		return 0;
 
 	kcontrol-&gt;private_value &amp;= ~(0xff &lt;&lt; 24);
<span class="p_del">-	kcontrol-&gt;private_value |= newval;</span>
<span class="p_add">+	kcontrol-&gt;private_value |= (unsigned int)newval &lt;&lt; 24;</span>
 	err = snd_ni_update_cur_val(list);
 	return err &lt; 0 ? err : 1;
 }
<span class="p_header">diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c</span>
<span class="p_header">index b6c0c8e3b450..23ea6d800c4c 100644</span>
<span class="p_header">--- a/sound/usb/quirks.c</span>
<span class="p_header">+++ b/sound/usb/quirks.c</span>
<span class="p_chunk">@@ -1269,6 +1269,7 @@</span> <span class="p_context"> u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,</span>
 	case USB_ID(0x20b1, 0x3008): /* iFi Audio micro/nano iDSD */
 	case USB_ID(0x20b1, 0x2008): /* Matrix Audio X-Sabre */
 	case USB_ID(0x20b1, 0x300a): /* Matrix Audio Mini-i Pro */
<span class="p_add">+	case USB_ID(0x22d8, 0x0416): /* OPPO HA-1*/</span>
 		if (fp-&gt;altsetting == 2)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



