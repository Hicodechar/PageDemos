
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.14.77 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.14.77</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 20, 2016, 4:14 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160820161457.GB28211@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9291753/mbox/"
   >mbox</a>
|
   <a href="/patch/9291753/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9291753/">/patch/9291753/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	D351560574 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 20 Aug 2016 16:15:20 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id C3F3F28BA6
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 20 Aug 2016 16:15:20 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id B770F28BAC; Sat, 20 Aug 2016 16:15:20 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 4778728BA6
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 20 Aug 2016 16:15:18 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1754006AbcHTQO6 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sat, 20 Aug 2016 12:14:58 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:51574 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1753905AbcHTQOx (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sat, 20 Aug 2016 12:14:53 -0400
Received: from localhost (pes75-3-78-192-101-3.fbxo.proxad.net
	[78.192.101.3])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 526F978D;
	Sat, 20 Aug 2016 16:14:50 +0000 (UTC)
Date: Sat, 20 Aug 2016 18:14:57 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 3.14.77
Message-ID: &lt;20160820161457.GB28211@kroah.com&gt;
References: &lt;20160820161449.GA28211@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20160820161449.GA28211@kroah.com&gt;
User-Agent: Mutt/1.7.0 (2016-08-17)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Aug. 20, 2016, 4:14 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/module-signing.txt b/Documentation/module-signing.txt</span>
<span class="p_header">index 2b40e04d3c49..f18b6ef7f805 100644</span>
<span class="p_header">--- a/Documentation/module-signing.txt</span>
<span class="p_header">+++ b/Documentation/module-signing.txt</span>
<span class="p_chunk">@@ -238,3 +238,9 @@</span> <span class="p_context"> Since the private key is used to sign modules, viruses and malware could use</span>
 the private key to sign modules and compromise the operating system.  The
 private key must be either destroyed or moved to a secure location and not kept
 in the root node of the kernel source tree.
<span class="p_add">+</span>
<span class="p_add">+If you use the same private key to sign modules for multiple kernel</span>
<span class="p_add">+configurations, you must ensure that the module version information is</span>
<span class="p_add">+sufficient to prevent loading a module into a different kernel.  Either</span>
<span class="p_add">+set CONFIG_MODVERSIONS=y or ensure that each configuration has a different</span>
<span class="p_add">+kernel release string by changing EXTRAVERSION or CONFIG_LOCALVERSION.</span>
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 306fd306906b..fc4df99727c1 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 14
<span class="p_del">-SUBLEVEL = 76</span>
<span class="p_add">+SUBLEVEL = 77</span>
 EXTRAVERSION =
 NAME = Remembering Coco
 
<span class="p_header">diff --git a/arch/arm/include/asm/pgtable-3level.h b/arch/arm/include/asm/pgtable-3level.h</span>
<span class="p_header">index ab7ee9205ca4..40d60a679fc8 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/pgtable-3level.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/pgtable-3level.h</span>
<span class="p_chunk">@@ -243,8 +243,11 @@</span> <span class="p_context"> PMD_BIT_FUNC(mkyoung,   |= PMD_SECT_AF);</span>
 #define pfn_pmd(pfn,prot)	(__pmd(((phys_addr_t)(pfn) &lt;&lt; PAGE_SHIFT) | pgprot_val(prot)))
 #define mk_pmd(page,prot)	pfn_pmd(page_to_pfn(page),prot)
 
<span class="p_del">-/* represent a notpresent pmd by zero, this is used by pmdp_invalidate */</span>
<span class="p_del">-#define pmd_mknotpresent(pmd)	(__pmd(0))</span>
<span class="p_add">+/* represent a notpresent pmd by faulting entry, this is used by pmdp_invalidate */</span>
<span class="p_add">+static inline pmd_t pmd_mknotpresent(pmd_t pmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __pmd(pmd_val(pmd) &amp; ~L_PMD_SECT_VALID);</span>
<span class="p_add">+}</span>
 
 static inline pmd_t pmd_modify(pmd_t pmd, pgprot_t newprot)
 {
<span class="p_header">diff --git a/arch/metag/include/asm/cmpxchg_lnkget.h b/arch/metag/include/asm/cmpxchg_lnkget.h</span>
<span class="p_header">index 0154e2807ebb..2369ad394876 100644</span>
<span class="p_header">--- a/arch/metag/include/asm/cmpxchg_lnkget.h</span>
<span class="p_header">+++ b/arch/metag/include/asm/cmpxchg_lnkget.h</span>
<span class="p_chunk">@@ -73,7 +73,7 @@</span> <span class="p_context"> static inline unsigned long __cmpxchg_u32(volatile int *m, unsigned long old,</span>
 		      &quot;	DCACHE	[%2], %0\n&quot;
 #endif
 		      &quot;2:\n&quot;
<span class="p_del">-		      : &quot;=&amp;d&quot; (temp), &quot;=&amp;da&quot; (retval)</span>
<span class="p_add">+		      : &quot;=&amp;d&quot; (temp), &quot;=&amp;d&quot; (retval)</span>
 		      : &quot;da&quot; (m), &quot;bd&quot; (old), &quot;da&quot; (new)
 		      : &quot;cc&quot;
 		      );
<span class="p_header">diff --git a/arch/mips/kvm/kvm_mips_emul.c b/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_header">index 33085819cd89..9f7643874fba 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_chunk">@@ -972,8 +972,13 @@</span> <span class="p_context"> kvm_mips_emulate_cache(uint32_t inst, uint32_t *opc, uint32_t cause,</span>
 	preempt_disable();
 	if (KVM_GUEST_KSEGX(va) == KVM_GUEST_KSEG0) {
 
<span class="p_del">-		if (kvm_mips_host_tlb_lookup(vcpu, va) &lt; 0) {</span>
<span class="p_del">-			kvm_mips_handle_kseg0_tlb_fault(va, vcpu);</span>
<span class="p_add">+		if (kvm_mips_host_tlb_lookup(vcpu, va) &lt; 0 &amp;&amp;</span>
<span class="p_add">+		    kvm_mips_handle_kseg0_tlb_fault(va, vcpu)) {</span>
<span class="p_add">+			kvm_err(&quot;%s: handling mapped kseg0 tlb fault for %lx, vcpu: %p, ASID: %#lx\n&quot;,</span>
<span class="p_add">+				__func__, va, vcpu, read_c0_entryhi());</span>
<span class="p_add">+			er = EMULATE_FAIL;</span>
<span class="p_add">+			preempt_enable();</span>
<span class="p_add">+			goto done;</span>
 		}
 	} else if ((KVM_GUEST_KSEGX(va) &lt; KVM_GUEST_KSEG0) ||
 		   KVM_GUEST_KSEGX(va) == KVM_GUEST_KSEG23) {
<span class="p_chunk">@@ -1006,11 +1011,16 @@</span> <span class="p_context"> kvm_mips_emulate_cache(uint32_t inst, uint32_t *opc, uint32_t cause,</span>
 								run, vcpu);
 				preempt_enable();
 				goto dont_update_pc;
<span class="p_del">-			} else {</span>
<span class="p_del">-				/* We fault an entry from the guest tlb to the shadow host TLB */</span>
<span class="p_del">-				kvm_mips_handle_mapped_seg_tlb_fault(vcpu, tlb,</span>
<span class="p_del">-								     NULL,</span>
<span class="p_del">-								     NULL);</span>
<span class="p_add">+			}</span>
<span class="p_add">+			/* We fault an entry from the guest tlb to the shadow host TLB */</span>
<span class="p_add">+			if (kvm_mips_handle_mapped_seg_tlb_fault(vcpu, tlb,</span>
<span class="p_add">+								 NULL, NULL)) {</span>
<span class="p_add">+				kvm_err(&quot;%s: handling mapped seg tlb fault for %lx, index: %u, vcpu: %p, ASID: %#lx\n&quot;,</span>
<span class="p_add">+					__func__, va, index, vcpu,</span>
<span class="p_add">+					read_c0_entryhi());</span>
<span class="p_add">+				er = EMULATE_FAIL;</span>
<span class="p_add">+				preempt_enable();</span>
<span class="p_add">+				goto done;</span>
 			}
 		}
 	} else {
<span class="p_chunk">@@ -1821,8 +1831,13 @@</span> <span class="p_context"> kvm_mips_handle_tlbmiss(unsigned long cause, uint32_t *opc,</span>
 			     tlb-&gt;tlb_hi, tlb-&gt;tlb_lo0, tlb-&gt;tlb_lo1);
 #endif
 			/* OK we have a Guest TLB entry, now inject it into the shadow host TLB */
<span class="p_del">-			kvm_mips_handle_mapped_seg_tlb_fault(vcpu, tlb, NULL,</span>
<span class="p_del">-							     NULL);</span>
<span class="p_add">+			if (kvm_mips_handle_mapped_seg_tlb_fault(vcpu, tlb,</span>
<span class="p_add">+								 NULL, NULL)) {</span>
<span class="p_add">+				kvm_err(&quot;%s: handling mapped seg tlb fault for %lx, index: %u, vcpu: %p, ASID: %#lx\n&quot;,</span>
<span class="p_add">+					__func__, va, index, vcpu,</span>
<span class="p_add">+					read_c0_entryhi());</span>
<span class="p_add">+				er = EMULATE_FAIL;</span>
<span class="p_add">+			}</span>
 		}
 	}
 
<span class="p_header">diff --git a/arch/mips/kvm/kvm_tlb.c b/arch/mips/kvm/kvm_tlb.c</span>
<span class="p_header">index 50ab9c4d4a5d..356b8aa03a70 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_tlb.c</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_tlb.c</span>
<span class="p_chunk">@@ -285,7 +285,7 @@</span> <span class="p_context"> int kvm_mips_handle_kseg0_tlb_fault(unsigned long badvaddr,</span>
 	}
 
 	gfn = (KVM_GUEST_CPHYSADDR(badvaddr) &gt;&gt; PAGE_SHIFT);
<span class="p_del">-	if (gfn &gt;= kvm-&gt;arch.guest_pmap_npages) {</span>
<span class="p_add">+	if ((gfn | 1) &gt;= kvm-&gt;arch.guest_pmap_npages) {</span>
 		kvm_err(&quot;%s: Invalid gfn: %#llx, BadVaddr: %#lx\n&quot;, __func__,
 			gfn, badvaddr);
 		kvm_mips_dump_host_tlbs();
<span class="p_chunk">@@ -370,21 +370,38 @@</span> <span class="p_context"> kvm_mips_handle_mapped_seg_tlb_fault(struct kvm_vcpu *vcpu,</span>
 	unsigned long entryhi = 0, entrylo0 = 0, entrylo1 = 0;
 	struct kvm *kvm = vcpu-&gt;kvm;
 	pfn_t pfn0, pfn1;
<span class="p_add">+	gfn_t gfn0, gfn1;</span>
<span class="p_add">+	long tlb_lo[2];</span>
<span class="p_add">+</span>
<span class="p_add">+	tlb_lo[0] = tlb-&gt;tlb_lo0;</span>
<span class="p_add">+	tlb_lo[1] = tlb-&gt;tlb_lo1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The commpage address must not be mapped to anything else if the guest</span>
<span class="p_add">+	 * TLB contains entries nearby, or commpage accesses will break.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!((tlb-&gt;tlb_hi ^ KVM_GUEST_COMMPAGE_ADDR) &amp;</span>
<span class="p_add">+			VPN2_MASK &amp; (PAGE_MASK &lt;&lt; 1)))</span>
<span class="p_add">+		tlb_lo[(KVM_GUEST_COMMPAGE_ADDR &gt;&gt; PAGE_SHIFT) &amp; 1] = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	gfn0 = mips3_tlbpfn_to_paddr(tlb_lo[0]) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	gfn1 = mips3_tlbpfn_to_paddr(tlb_lo[1]) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	if (gfn0 &gt;= kvm-&gt;arch.guest_pmap_npages ||</span>
<span class="p_add">+	    gfn1 &gt;= kvm-&gt;arch.guest_pmap_npages) {</span>
<span class="p_add">+		kvm_err(&quot;%s: Invalid gfn: [%#llx, %#llx], EHi: %#lx\n&quot;,</span>
<span class="p_add">+			__func__, gfn0, gfn1, tlb-&gt;tlb_hi);</span>
<span class="p_add">+		kvm_mips_dump_guest_tlbs(vcpu);</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+	}</span>
 
<span class="p_add">+	if (kvm_mips_map_page(kvm, gfn0) &lt; 0)</span>
<span class="p_add">+		return -1;</span>
 
<span class="p_del">-	if ((tlb-&gt;tlb_hi &amp; VPN2_MASK) == 0) {</span>
<span class="p_del">-		pfn0 = 0;</span>
<span class="p_del">-		pfn1 = 0;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		if (kvm_mips_map_page(kvm, mips3_tlbpfn_to_paddr(tlb-&gt;tlb_lo0) &gt;&gt; PAGE_SHIFT) &lt; 0)</span>
<span class="p_del">-			return -1;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (kvm_mips_map_page(kvm, mips3_tlbpfn_to_paddr(tlb-&gt;tlb_lo1) &gt;&gt; PAGE_SHIFT) &lt; 0)</span>
<span class="p_del">-			return -1;</span>
<span class="p_add">+	if (kvm_mips_map_page(kvm, gfn1) &lt; 0)</span>
<span class="p_add">+		return -1;</span>
 
<span class="p_del">-		pfn0 = kvm-&gt;arch.guest_pmap[mips3_tlbpfn_to_paddr(tlb-&gt;tlb_lo0) &gt;&gt; PAGE_SHIFT];</span>
<span class="p_del">-		pfn1 = kvm-&gt;arch.guest_pmap[mips3_tlbpfn_to_paddr(tlb-&gt;tlb_lo1) &gt;&gt; PAGE_SHIFT];</span>
<span class="p_del">-	}</span>
<span class="p_add">+	pfn0 = kvm-&gt;arch.guest_pmap[gfn0];</span>
<span class="p_add">+	pfn1 = kvm-&gt;arch.guest_pmap[gfn1];</span>
 
 	if (hpa0)
 		*hpa0 = pfn0 &lt;&lt; PAGE_SHIFT;
<span class="p_chunk">@@ -396,9 +413,9 @@</span> <span class="p_context"> kvm_mips_handle_mapped_seg_tlb_fault(struct kvm_vcpu *vcpu,</span>
 	entryhi = (tlb-&gt;tlb_hi &amp; VPN2_MASK) | (KVM_GUEST_KERNEL_MODE(vcpu) ?
 			kvm_mips_get_kernel_asid(vcpu) : kvm_mips_get_user_asid(vcpu));
 	entrylo0 = mips3_paddr_to_tlbpfn(pfn0 &lt;&lt; PAGE_SHIFT) | (0x3 &lt;&lt; 3) |
<span class="p_del">-			(tlb-&gt;tlb_lo0 &amp; MIPS3_PG_D) | (tlb-&gt;tlb_lo0 &amp; MIPS3_PG_V);</span>
<span class="p_add">+			(tlb_lo[0] &amp; MIPS3_PG_D) | (tlb_lo[0] &amp; MIPS3_PG_V);</span>
 	entrylo1 = mips3_paddr_to_tlbpfn(pfn1 &lt;&lt; PAGE_SHIFT) | (0x3 &lt;&lt; 3) |
<span class="p_del">-			(tlb-&gt;tlb_lo1 &amp; MIPS3_PG_D) | (tlb-&gt;tlb_lo1 &amp; MIPS3_PG_V);</span>
<span class="p_add">+			(tlb_lo[1] &amp; MIPS3_PG_D) | (tlb_lo[1] &amp; MIPS3_PG_V);</span>
 
 #ifdef DEBUG
 	kvm_debug(&quot;@ %#lx tlb_lo0: 0x%08lx tlb_lo1: 0x%08lx\n&quot;, vcpu-&gt;arch.pc,
<span class="p_chunk">@@ -780,10 +797,16 @@</span> <span class="p_context"> uint32_t kvm_get_inst(uint32_t *opc, struct kvm_vcpu *vcpu)</span>
 				local_irq_restore(flags);
 				return KVM_INVALID_INST;
 			}
<span class="p_del">-			kvm_mips_handle_mapped_seg_tlb_fault(vcpu,</span>
<span class="p_del">-							     &amp;vcpu-&gt;arch.</span>
<span class="p_del">-							     guest_tlb[index],</span>
<span class="p_del">-							     NULL, NULL);</span>
<span class="p_add">+			if (kvm_mips_handle_mapped_seg_tlb_fault(vcpu,</span>
<span class="p_add">+						&amp;vcpu-&gt;arch.guest_tlb[index],</span>
<span class="p_add">+						NULL, NULL)) {</span>
<span class="p_add">+				kvm_err(&quot;%s: handling mapped seg tlb fault failed for %p, index: %u, vcpu: %p, ASID: %#lx\n&quot;,</span>
<span class="p_add">+					__func__, opc, index, vcpu,</span>
<span class="p_add">+					read_c0_entryhi());</span>
<span class="p_add">+				kvm_mips_dump_guest_tlbs(vcpu);</span>
<span class="p_add">+				local_irq_restore(flags);</span>
<span class="p_add">+				return KVM_INVALID_INST;</span>
<span class="p_add">+			}</span>
 			inst = *(opc);
 		}
 		local_irq_restore(flags);
<span class="p_header">diff --git a/drivers/char/random.c b/drivers/char/random.c</span>
<span class="p_header">index d20ac1997886..a35a605c418a 100644</span>
<span class="p_header">--- a/drivers/char/random.c</span>
<span class="p_header">+++ b/drivers/char/random.c</span>
<span class="p_chunk">@@ -1339,12 +1339,16 @@</span> <span class="p_context"> random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)</span>
 static ssize_t
 urandom_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
 {
<span class="p_add">+	static int maxwarn = 10;</span>
 	int ret;
 
<span class="p_del">-	if (unlikely(nonblocking_pool.initialized == 0))</span>
<span class="p_del">-		printk_once(KERN_NOTICE &quot;random: %s urandom read &quot;</span>
<span class="p_del">-			    &quot;with %d bits of entropy available\n&quot;,</span>
<span class="p_del">-			    current-&gt;comm, nonblocking_pool.entropy_total);</span>
<span class="p_add">+	if (unlikely(nonblocking_pool.initialized == 0) &amp;&amp;</span>
<span class="p_add">+	    maxwarn &gt; 0) {</span>
<span class="p_add">+		maxwarn--;</span>
<span class="p_add">+		printk(KERN_NOTICE &quot;random: %s: uninitialized urandom read &quot;</span>
<span class="p_add">+		       &quot;(%zd bytes read, %d bits of entropy available)\n&quot;,</span>
<span class="p_add">+		       current-&gt;comm, nbytes, nonblocking_pool.entropy_total);</span>
<span class="p_add">+	}</span>
 
 	ret = extract_entropy_user(&amp;nonblocking_pool, buf, nbytes);
 
<span class="p_header">diff --git a/drivers/gpio/gpio-intel-mid.c b/drivers/gpio/gpio-intel-mid.c</span>
<span class="p_header">index e585163f1ad5..66b8e7ed1464 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-intel-mid.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-intel-mid.c</span>
<span class="p_chunk">@@ -21,7 +21,6 @@</span> <span class="p_context"></span>
  * Moorestown platform Langwell chip.
  * Medfield platform Penwell chip.
  * Clovertrail platform Cloverview chip.
<span class="p_del">- * Merrifield platform Tangier chip.</span>
  */
 
 #include &lt;linux/module.h&gt;
<span class="p_chunk">@@ -70,10 +69,6 @@</span> <span class="p_context"> enum GPIO_REG {</span>
 /* intel_mid gpio driver data */
 struct intel_mid_gpio_ddata {
 	u16 ngpio;		/* number of gpio pins */
<span class="p_del">-	u32 gplr_offset;	/* offset of first GPLR register from base */</span>
<span class="p_del">-	u32 flis_base;		/* base address of FLIS registers */</span>
<span class="p_del">-	u32 flis_len;		/* length of FLIS registers */</span>
<span class="p_del">-	u32 (*get_flis_offset)(int gpio);</span>
 	u32 chip_irq_type;	/* chip interrupt type */
 };
 
<span class="p_chunk">@@ -288,15 +283,6 @@</span> <span class="p_context"> static const struct intel_mid_gpio_ddata gpio_cloverview_core = {</span>
 	.chip_irq_type = INTEL_MID_IRQ_TYPE_EDGE,
 };
 
<span class="p_del">-static const struct intel_mid_gpio_ddata gpio_tangier = {</span>
<span class="p_del">-	.ngpio = 192,</span>
<span class="p_del">-	.gplr_offset = 4,</span>
<span class="p_del">-	.flis_base = 0xff0c0000,</span>
<span class="p_del">-	.flis_len = 0x8000,</span>
<span class="p_del">-	.get_flis_offset = NULL,</span>
<span class="p_del">-	.chip_irq_type = INTEL_MID_IRQ_TYPE_EDGE,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 static const struct pci_device_id intel_gpio_ids[] = {
 	{
 		/* Lincroft */
<span class="p_chunk">@@ -323,11 +309,6 @@</span> <span class="p_context"> static const struct pci_device_id intel_gpio_ids[] = {</span>
 		PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x08f7),
 		.driver_data = (kernel_ulong_t)&amp;gpio_cloverview_core,
 	},
<span class="p_del">-	{</span>
<span class="p_del">-		/* Tangier */</span>
<span class="p_del">-		PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x1199),</span>
<span class="p_del">-		.driver_data = (kernel_ulong_t)&amp;gpio_tangier,</span>
<span class="p_del">-	},</span>
 	{ 0 }
 };
 MODULE_DEVICE_TABLE(pci, intel_gpio_ids);
<span class="p_header">diff --git a/drivers/gpio/gpio-pca953x.c b/drivers/gpio/gpio-pca953x.c</span>
<span class="p_header">index 019b23b955a2..c9cb0fb2302c 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-pca953x.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-pca953x.c</span>
<span class="p_chunk">@@ -75,7 +75,7 @@</span> <span class="p_context"> MODULE_DEVICE_TABLE(i2c, pca953x_id);</span>
 #define MAX_BANK 5
 #define BANK_SZ 8
 
<span class="p_del">-#define NBANK(chip) (chip-&gt;gpio_chip.ngpio / BANK_SZ)</span>
<span class="p_add">+#define NBANK(chip) DIV_ROUND_UP(chip-&gt;gpio_chip.ngpio, BANK_SZ)</span>
 
 struct pca953x_chip {
 	unsigned gpio_start;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index d30aba867a3a..ea58b4654868 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -8841,21 +8841,11 @@</span> <span class="p_context"> connected_sink_compute_bpp(struct intel_connector * connector,</span>
 		pipe_config-&gt;pipe_bpp = connector-&gt;base.display_info.bpc*3;
 	}
 
<span class="p_del">-	/* Clamp bpp to default limit on screens without EDID 1.4 */</span>
<span class="p_del">-	if (connector-&gt;base.display_info.bpc == 0) {</span>
<span class="p_del">-		int type = connector-&gt;base.connector_type;</span>
<span class="p_del">-		int clamp_bpp = 24;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Fall back to 18 bpp when DP sink capability is unknown. */</span>
<span class="p_del">-		if (type == DRM_MODE_CONNECTOR_DisplayPort ||</span>
<span class="p_del">-		    type == DRM_MODE_CONNECTOR_eDP)</span>
<span class="p_del">-			clamp_bpp = 18;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (bpp &gt; clamp_bpp) {</span>
<span class="p_del">-			DRM_DEBUG_KMS(&quot;clamping display bpp (was %d) to default limit of %d\n&quot;,</span>
<span class="p_del">-				      bpp, clamp_bpp);</span>
<span class="p_del">-			pipe_config-&gt;pipe_bpp = clamp_bpp;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	/* Clamp bpp to 8 on screens without EDID 1.4 */</span>
<span class="p_add">+	if (connector-&gt;base.display_info.bpc == 0 &amp;&amp; bpp &gt; 24) {</span>
<span class="p_add">+		DRM_DEBUG_KMS(&quot;clamping display bpp (was %d) to default limit of 24\n&quot;,</span>
<span class="p_add">+			      bpp);</span>
<span class="p_add">+		pipe_config-&gt;pipe_bpp = 24;</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_encoders.c b/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_header">index eeb1369110ac..59049c365cb3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_chunk">@@ -119,6 +119,7 @@</span> <span class="p_context"> atombios_set_backlight_level(struct radeon_encoder *radeon_encoder, u8 level)</span>
 		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:
 		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:
 		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:
<span class="p_add">+		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:</span>
 			if (dig-&gt;backlight_level == 0)
 				atombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_LCD_BLOFF, 0, 0);
 			else {
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_atombios.c b/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_header">index 6a3b5f92219f..923982c44bff 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_chunk">@@ -1128,7 +1128,7 @@</span> <span class="p_context"> bool radeon_atom_get_clock_info(struct drm_device *dev)</span>
 		    le16_to_cpu(firmware_info-&gt;info.usReferenceClock);
 		p1pll-&gt;reference_div = 0;
 
<span class="p_del">-		if (crev &lt; 2)</span>
<span class="p_add">+		if ((frev &lt; 2) &amp;&amp; (crev &lt; 2))</span>
 			p1pll-&gt;pll_out_min =
 				le16_to_cpu(firmware_info-&gt;info.usMinPixelClockPLL_Output);
 		else
<span class="p_chunk">@@ -1137,7 +1137,7 @@</span> <span class="p_context"> bool radeon_atom_get_clock_info(struct drm_device *dev)</span>
 		p1pll-&gt;pll_out_max =
 		    le32_to_cpu(firmware_info-&gt;info.ulMaxPixelClockPLL_Output);
 
<span class="p_del">-		if (crev &gt;= 4) {</span>
<span class="p_add">+		if (((frev &lt; 2) &amp;&amp; (crev &gt;= 4)) || (frev &gt;= 2)) {</span>
 			p1pll-&gt;lcd_pll_out_min =
 				le16_to_cpu(firmware_info-&gt;info_14.usLcdMinPixelClockPLL_Output) * 100;
 			if (p1pll-&gt;lcd_pll_out_min == 0)
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c</span>
<span class="p_header">index a9fb0d016d38..ba95c4934c8d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c</span>
<span class="p_chunk">@@ -10,6 +10,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/acpi.h&gt;
 #include &lt;linux/pci.h&gt;
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
 
 #include &quot;radeon_acpi.h&quot;
 
<span class="p_chunk">@@ -256,6 +257,10 @@</span> <span class="p_context"> static int radeon_atpx_set_discrete_state(struct radeon_atpx *atpx, u8 state)</span>
 		if (!info)
 			return -EIO;
 		kfree(info);
<span class="p_add">+</span>
<span class="p_add">+		/* 200ms delay is required after off */</span>
<span class="p_add">+		if (state == 0)</span>
<span class="p_add">+			msleep(200);</span>
 	}
 	return 0;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_connectors.c b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">index 17ae621dbdab..6ec0273e6191 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_chunk">@@ -1769,7 +1769,6 @@</span> <span class="p_context"> radeon_add_atom_connector(struct drm_device *dev,</span>
 						      1);
 			/* no HPD on analog connectors */
 			radeon_connector-&gt;hpd.hpd = RADEON_HPD_NONE;
<span class="p_del">-			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
 			connector-&gt;interlace_allowed = true;
 			connector-&gt;doublescan_allowed = true;
 			break;
<span class="p_chunk">@@ -1998,8 +1997,10 @@</span> <span class="p_context"> radeon_add_atom_connector(struct drm_device *dev,</span>
 	}
 
 	if (radeon_connector-&gt;hpd.hpd == RADEON_HPD_NONE) {
<span class="p_del">-		if (i2c_bus-&gt;valid)</span>
<span class="p_del">-			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
<span class="p_add">+		if (i2c_bus-&gt;valid) {</span>
<span class="p_add">+			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT |</span>
<span class="p_add">+			                    DRM_CONNECTOR_POLL_DISCONNECT;</span>
<span class="p_add">+		}</span>
 	} else
 		connector-&gt;polled = DRM_CONNECTOR_POLL_HPD;
 
<span class="p_chunk">@@ -2071,7 +2072,6 @@</span> <span class="p_context"> radeon_add_legacy_connector(struct drm_device *dev,</span>
 					      1);
 		/* no HPD on analog connectors */
 		radeon_connector-&gt;hpd.hpd = RADEON_HPD_NONE;
<span class="p_del">-		connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
 		connector-&gt;interlace_allowed = true;
 		connector-&gt;doublescan_allowed = true;
 		break;
<span class="p_chunk">@@ -2156,10 +2156,13 @@</span> <span class="p_context"> radeon_add_legacy_connector(struct drm_device *dev,</span>
 	}
 
 	if (radeon_connector-&gt;hpd.hpd == RADEON_HPD_NONE) {
<span class="p_del">-		if (i2c_bus-&gt;valid)</span>
<span class="p_del">-			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
<span class="p_add">+		if (i2c_bus-&gt;valid) {</span>
<span class="p_add">+			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT |</span>
<span class="p_add">+			                    DRM_CONNECTOR_POLL_DISCONNECT;</span>
<span class="p_add">+		}</span>
 	} else
 		connector-&gt;polled = DRM_CONNECTOR_POLL_HPD;
<span class="p_add">+</span>
 	connector-&gt;display_info.subpixel_order = subpixel_order;
 	drm_sysfs_connector_add(connector);
 }
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">index 8d7cd98c9671..6659796ece16 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_chunk">@@ -361,7 +361,7 @@</span> <span class="p_context"> static int send_wqe_overhead(enum mlx4_ib_qp_type type, u32 flags)</span>
 			sizeof (struct mlx4_wqe_raddr_seg);
 	case MLX4_IB_QPT_RC:
 		return sizeof (struct mlx4_wqe_ctrl_seg) +
<span class="p_del">-			sizeof (struct mlx4_wqe_atomic_seg) +</span>
<span class="p_add">+			sizeof (struct mlx4_wqe_masked_atomic_seg) +</span>
 			sizeof (struct mlx4_wqe_raddr_seg);
 	case MLX4_IB_QPT_SMI:
 	case MLX4_IB_QPT_GSI:
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/qp.c b/drivers/infiniband/hw/mlx5/qp.c</span>
<span class="p_header">index 7dfe8a1c84cf..f09678d817d3 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/qp.c</span>
<span class="p_chunk">@@ -169,6 +169,8 @@</span> <span class="p_context"> static int set_rq_size(struct mlx5_ib_dev *dev, struct ib_qp_cap *cap,</span>
 		qp-&gt;rq.max_gs = 0;
 		qp-&gt;rq.wqe_cnt = 0;
 		qp-&gt;rq.wqe_shift = 0;
<span class="p_add">+		cap-&gt;max_recv_wr = 0;</span>
<span class="p_add">+		cap-&gt;max_recv_sge = 0;</span>
 	} else {
 		if (ucmd) {
 			qp-&gt;rq.wqe_cnt = ucmd-&gt;rq_wqe_count;
<span class="p_chunk">@@ -2035,10 +2037,11 @@</span> <span class="p_context"> static u8 get_fence(u8 fence, struct ib_send_wr *wr)</span>
 			return MLX5_FENCE_MODE_SMALL_AND_FENCE;
 		else
 			return fence;
<span class="p_del">-</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+	} else if (unlikely(wr-&gt;send_flags &amp; IB_SEND_FENCE)) {</span>
<span class="p_add">+		return MLX5_FENCE_MODE_FENCE;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 int mlx5_ib_post_send(struct ib_qp *ibqp, struct ib_send_wr *wr,
<span class="p_chunk">@@ -2503,17 +2506,19 @@</span> <span class="p_context"> int mlx5_ib_query_qp(struct ib_qp *ibqp, struct ib_qp_attr *qp_attr, int qp_attr</span>
 	qp_attr-&gt;cap.max_recv_sge    = qp-&gt;rq.max_gs;
 
 	if (!ibqp-&gt;uobject) {
<span class="p_del">-		qp_attr-&gt;cap.max_send_wr  = qp-&gt;sq.wqe_cnt;</span>
<span class="p_add">+		qp_attr-&gt;cap.max_send_wr  = qp-&gt;sq.max_post;</span>
 		qp_attr-&gt;cap.max_send_sge = qp-&gt;sq.max_gs;
<span class="p_add">+		qp_init_attr-&gt;qp_context = ibqp-&gt;qp_context;</span>
 	} else {
 		qp_attr-&gt;cap.max_send_wr  = 0;
 		qp_attr-&gt;cap.max_send_sge = 0;
 	}
 
<span class="p_del">-	/* We don&#39;t support inline sends for kernel QPs (yet), and we</span>
<span class="p_del">-	 * don&#39;t know what userspace&#39;s value should be.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	qp_attr-&gt;cap.max_inline_data = 0;</span>
<span class="p_add">+	qp_init_attr-&gt;qp_type = ibqp-&gt;qp_type;</span>
<span class="p_add">+	qp_init_attr-&gt;recv_cq = ibqp-&gt;recv_cq;</span>
<span class="p_add">+	qp_init_attr-&gt;send_cq = ibqp-&gt;send_cq;</span>
<span class="p_add">+	qp_init_attr-&gt;srq = ibqp-&gt;srq;</span>
<span class="p_add">+	qp_attr-&gt;cap.max_inline_data = qp-&gt;max_inline_data;</span>
 
 	qp_init_attr-&gt;cap	     = qp_attr-&gt;cap;
 
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">index 5786a78ff8bc..8b97b77572c6 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_chunk">@@ -884,7 +884,9 @@</span> <span class="p_context"> struct ipoib_neigh *ipoib_neigh_get(struct net_device *dev, u8 *daddr)</span>
 				neigh = NULL;
 				goto out_unlock;
 			}
<span class="p_del">-			neigh-&gt;alive = jiffies;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (likely(skb_queue_len(&amp;neigh-&gt;queue) &lt; IPOIB_MAX_PATH_REC_QUEUE))</span>
<span class="p_add">+				neigh-&gt;alive = jiffies;</span>
 			goto out_unlock;
 		}
 	}
<span class="p_header">diff --git a/drivers/md/dm-flakey.c b/drivers/md/dm-flakey.c</span>
<span class="p_header">index b257e46876d3..0f5e1820c92d 100644</span>
<span class="p_header">--- a/drivers/md/dm-flakey.c</span>
<span class="p_header">+++ b/drivers/md/dm-flakey.c</span>
<span class="p_chunk">@@ -287,10 +287,16 @@</span> <span class="p_context"> static int flakey_map(struct dm_target *ti, struct bio *bio)</span>
 		pb-&gt;bio_submitted = true;
 
 		/*
<span class="p_del">-		 * Map reads as normal.</span>
<span class="p_add">+		 * Map reads as normal only if corrupt_bio_byte set.</span>
 		 */
<span class="p_del">-		if (bio_data_dir(bio) == READ)</span>
<span class="p_del">-			goto map_bio;</span>
<span class="p_add">+		if (bio_data_dir(bio) == READ) {</span>
<span class="p_add">+			/* If flags were specified, only corrupt those that match. */</span>
<span class="p_add">+			if (fc-&gt;corrupt_bio_byte &amp;&amp; (fc-&gt;corrupt_bio_rw == READ) &amp;&amp;</span>
<span class="p_add">+			    all_corrupt_bio_flags_match(bio, fc))</span>
<span class="p_add">+				goto map_bio;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				return -EIO;</span>
<span class="p_add">+		}</span>
 
 		/*
 		 * Drop writes?
<span class="p_chunk">@@ -328,12 +334,13 @@</span> <span class="p_context"> static int flakey_end_io(struct dm_target *ti, struct bio *bio, int error)</span>
 
 	/*
 	 * Corrupt successful READs while in down state.
<span class="p_del">-	 * If flags were specified, only corrupt those that match.</span>
 	 */
<span class="p_del">-	if (fc-&gt;corrupt_bio_byte &amp;&amp; !error &amp;&amp; pb-&gt;bio_submitted &amp;&amp;</span>
<span class="p_del">-	    (bio_data_dir(bio) == READ) &amp;&amp; (fc-&gt;corrupt_bio_rw == READ) &amp;&amp;</span>
<span class="p_del">-	    all_corrupt_bio_flags_match(bio, fc))</span>
<span class="p_del">-		corrupt_bio_data(bio, fc);</span>
<span class="p_add">+	if (!error &amp;&amp; pb-&gt;bio_submitted &amp;&amp; (bio_data_dir(bio) == READ)) {</span>
<span class="p_add">+		if (fc-&gt;corrupt_bio_byte)</span>
<span class="p_add">+			corrupt_bio_data(bio, fc);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			return -EIO;</span>
<span class="p_add">+	}</span>
 
 	return error;
 }
<span class="p_header">diff --git a/drivers/media/platform/s5p-mfc/s5p_mfc.c b/drivers/media/platform/s5p-mfc/s5p_mfc.c</span>
<span class="p_header">index e2aac592d29f..983aae1461be 100644</span>
<span class="p_header">--- a/drivers/media/platform/s5p-mfc/s5p_mfc.c</span>
<span class="p_header">+++ b/drivers/media/platform/s5p-mfc/s5p_mfc.c</span>
<span class="p_chunk">@@ -1004,6 +1004,11 @@</span> <span class="p_context"> static int match_child(struct device *dev, void *data)</span>
 	return !strcmp(dev_name(dev), (char *)data);
 }
 
<span class="p_add">+static void s5p_mfc_memdev_release(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dma_release_declared_memory(dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void *mfc_get_drv_data(struct platform_device *pdev);
 
 static int s5p_mfc_alloc_memdevs(struct s5p_mfc_dev *dev)
<span class="p_chunk">@@ -1016,6 +1021,9 @@</span> <span class="p_context"> static int s5p_mfc_alloc_memdevs(struct s5p_mfc_dev *dev)</span>
 		mfc_err(&quot;Not enough memory\n&quot;);
 		return -ENOMEM;
 	}
<span class="p_add">+</span>
<span class="p_add">+	dev_set_name(dev-&gt;mem_dev_l, &quot;%s&quot;, &quot;s5p-mfc-l&quot;);</span>
<span class="p_add">+	dev-&gt;mem_dev_l-&gt;release = s5p_mfc_memdev_release;</span>
 	device_initialize(dev-&gt;mem_dev_l);
 	of_property_read_u32_array(dev-&gt;plat_dev-&gt;dev.of_node,
 			&quot;samsung,mfc-l&quot;, mem_info, 2);
<span class="p_chunk">@@ -1033,6 +1041,9 @@</span> <span class="p_context"> static int s5p_mfc_alloc_memdevs(struct s5p_mfc_dev *dev)</span>
 		mfc_err(&quot;Not enough memory\n&quot;);
 		return -ENOMEM;
 	}
<span class="p_add">+</span>
<span class="p_add">+	dev_set_name(dev-&gt;mem_dev_r, &quot;%s&quot;, &quot;s5p-mfc-r&quot;);</span>
<span class="p_add">+	dev-&gt;mem_dev_r-&gt;release = s5p_mfc_memdev_release;</span>
 	device_initialize(dev-&gt;mem_dev_r);
 	of_property_read_u32_array(dev-&gt;plat_dev-&gt;dev.of_node,
 			&quot;samsung,mfc-r&quot;, mem_info, 2);
<span class="p_header">diff --git a/drivers/mtd/ubi/build.c b/drivers/mtd/ubi/build.c</span>
<span class="p_header">index 57deae961429..cfcb54369ce7 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/build.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/build.c</span>
<span class="p_chunk">@@ -999,6 +999,9 @@</span> <span class="p_context"> int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,</span>
 			goto out_detach;
 	}
 
<span class="p_add">+	/* Make device &quot;available&quot; before it becomes accessible via sysfs */</span>
<span class="p_add">+	ubi_devices[ubi_num] = ubi;</span>
<span class="p_add">+</span>
 	err = uif_init(ubi, &amp;ref);
 	if (err)
 		goto out_detach;
<span class="p_chunk">@@ -1043,7 +1046,6 @@</span> <span class="p_context"> int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,</span>
 	wake_up_process(ubi-&gt;bgt_thread);
 	spin_unlock(&amp;ubi-&gt;wl_lock);
 
<span class="p_del">-	ubi_devices[ubi_num] = ubi;</span>
 	ubi_notify_all(ubi, UBI_VOLUME_ADDED, NULL);
 	return ubi_num;
 
<span class="p_chunk">@@ -1054,6 +1056,7 @@</span> <span class="p_context"> out_uif:</span>
 	ubi_assert(ref);
 	uif_close(ubi);
 out_detach:
<span class="p_add">+	ubi_devices[ubi_num] = NULL;</span>
 	ubi_wl_close(ubi);
 	ubi_free_internal_volumes(ubi);
 	vfree(ubi-&gt;vtbl);
<span class="p_header">diff --git a/drivers/mtd/ubi/vmt.c b/drivers/mtd/ubi/vmt.c</span>
<span class="p_header">index 8330703c098f..96131eb34c9f 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/vmt.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/vmt.c</span>
<span class="p_chunk">@@ -534,13 +534,6 @@</span> <span class="p_context"> int ubi_resize_volume(struct ubi_volume_desc *desc, int reserved_pebs)</span>
 		spin_unlock(&amp;ubi-&gt;volumes_lock);
 	}
 
<span class="p_del">-	/* Change volume table record */</span>
<span class="p_del">-	vtbl_rec = ubi-&gt;vtbl[vol_id];</span>
<span class="p_del">-	vtbl_rec.reserved_pebs = cpu_to_be32(reserved_pebs);</span>
<span class="p_del">-	err = ubi_change_vtbl_record(ubi, vol_id, &amp;vtbl_rec);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto out_acc;</span>
<span class="p_del">-</span>
 	if (pebs &lt; 0) {
 		for (i = 0; i &lt; -pebs; i++) {
 			err = ubi_eba_unmap_leb(ubi, vol, reserved_pebs + i);
<span class="p_chunk">@@ -558,6 +551,24 @@</span> <span class="p_context"> int ubi_resize_volume(struct ubi_volume_desc *desc, int reserved_pebs)</span>
 		spin_unlock(&amp;ubi-&gt;volumes_lock);
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * When we shrink a volume we have to flush all pending (erase) work.</span>
<span class="p_add">+	 * Otherwise it can happen that upon next attach UBI finds a LEB with</span>
<span class="p_add">+	 * lnum &gt; highest_lnum and refuses to attach.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (pebs &lt; 0) {</span>
<span class="p_add">+		err = ubi_wl_flush(ubi, vol_id, UBI_ALL);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto out_acc;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Change volume table record */</span>
<span class="p_add">+	vtbl_rec = ubi-&gt;vtbl[vol_id];</span>
<span class="p_add">+	vtbl_rec.reserved_pebs = cpu_to_be32(reserved_pebs);</span>
<span class="p_add">+	err = ubi_change_vtbl_record(ubi, vol_id, &amp;vtbl_rec);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto out_acc;</span>
<span class="p_add">+</span>
 	vol-&gt;reserved_pebs = reserved_pebs;
 	if (vol-&gt;vol_type == UBI_DYNAMIC_VOLUME) {
 		vol-&gt;used_ebs = reserved_pebs;
<span class="p_header">diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c</span>
<span class="p_header">index 2afa4803280f..09208ac59415 100644</span>
<span class="p_header">--- a/drivers/pci/quirks.c</span>
<span class="p_header">+++ b/drivers/pci/quirks.c</span>
<span class="p_chunk">@@ -3017,13 +3017,15 @@</span> <span class="p_context"> static void quirk_no_bus_reset(struct pci_dev *dev)</span>
 }
 
 /*
<span class="p_del">- * Atheros AR93xx chips do not behave after a bus reset.  The device will</span>
<span class="p_del">- * throw a Link Down error on AER-capable systems and regardless of AER,</span>
<span class="p_del">- * config space of the device is never accessible again and typically</span>
<span class="p_del">- * causes the system to hang or reset when access is attempted.</span>
<span class="p_add">+ * Some Atheros AR9xxx and QCA988x chips do not behave after a bus reset.</span>
<span class="p_add">+ * The device will throw a Link Down error on AER-capable systems and</span>
<span class="p_add">+ * regardless of AER, config space of the device is never accessible again</span>
<span class="p_add">+ * and typically causes the system to hang or reset when access is attempted.</span>
  * http://www.spinics.net/lists/linux-pci/msg34797.html
  */
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0030, quirk_no_bus_reset);
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0032, quirk_no_bus_reset);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x003c, quirk_no_bus_reset);</span>
 
 static void pci_do_fixups(struct pci_dev *dev, struct pci_fixup *f,
 			  struct pci_fixup *end)
<span class="p_header">diff --git a/drivers/platform/x86/hp-wmi.c b/drivers/platform/x86/hp-wmi.c</span>
<span class="p_header">index 8ba8956b5a48..772209739246 100644</span>
<span class="p_header">--- a/drivers/platform/x86/hp-wmi.c</span>
<span class="p_header">+++ b/drivers/platform/x86/hp-wmi.c</span>
<span class="p_chunk">@@ -696,6 +696,11 @@</span> <span class="p_context"> static int hp_wmi_rfkill_setup(struct platform_device *device)</span>
 	if (err)
 		return err;
 
<span class="p_add">+	err = hp_wmi_perform_query(HPWMI_WIRELESS_QUERY, 1, &amp;wireless,</span>
<span class="p_add">+				   sizeof(wireless), 0);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
 	if (wireless &amp; 0x1) {
 		wifi_rfkill = rfkill_alloc(&quot;hp-wifi&quot;, &amp;device-&gt;dev,
 					   RFKILL_TYPE_WLAN,
<span class="p_chunk">@@ -883,7 +888,7 @@</span> <span class="p_context"> static int __init hp_wmi_bios_setup(struct platform_device *device)</span>
 	gps_rfkill = NULL;
 	rfkill2_count = 0;
 
<span class="p_del">-	if (hp_wmi_bios_2009_later() || hp_wmi_rfkill_setup(device))</span>
<span class="p_add">+	if (hp_wmi_rfkill_setup(device))</span>
 		hp_wmi_rfkill2_setup(device);
 
 	err = device_create_file(&amp;device-&gt;dev, &amp;dev_attr_display);
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">index 5600eab07865..1e032be2b7d7 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_chunk">@@ -505,7 +505,8 @@</span> <span class="p_context"> static void iscsit_aborted_task(struct iscsi_conn *conn, struct iscsi_cmd *cmd)</span>
 	bool scsi_cmd = (cmd-&gt;iscsi_opcode == ISCSI_OP_SCSI_CMD);
 
 	spin_lock_bh(&amp;conn-&gt;cmd_lock);
<span class="p_del">-	if (!list_empty(&amp;cmd-&gt;i_conn_node))</span>
<span class="p_add">+	if (!list_empty(&amp;cmd-&gt;i_conn_node) &amp;&amp;</span>
<span class="p_add">+	    !(cmd-&gt;se_cmd.transport_state &amp; CMD_T_FABRIC_STOP))</span>
 		list_del_init(&amp;cmd-&gt;i_conn_node);
 	spin_unlock_bh(&amp;conn-&gt;cmd_lock);
 
<span class="p_chunk">@@ -4160,6 +4161,7 @@</span> <span class="p_context"> transport_err:</span>
 
 static void iscsit_release_commands_from_conn(struct iscsi_conn *conn)
 {
<span class="p_add">+	LIST_HEAD(tmp_list);</span>
 	struct iscsi_cmd *cmd = NULL, *cmd_tmp = NULL;
 	struct iscsi_session *sess = conn-&gt;sess;
 	/*
<span class="p_chunk">@@ -4168,18 +4170,26 @@</span> <span class="p_context"> static void iscsit_release_commands_from_conn(struct iscsi_conn *conn)</span>
 	 * has been reset -&gt; returned sleeping pre-handler state.
 	 */
 	spin_lock_bh(&amp;conn-&gt;cmd_lock);
<span class="p_del">-	list_for_each_entry_safe(cmd, cmd_tmp, &amp;conn-&gt;conn_cmd_list, i_conn_node) {</span>
<span class="p_add">+	list_splice_init(&amp;conn-&gt;conn_cmd_list, &amp;tmp_list);</span>
 
<span class="p_add">+	list_for_each_entry(cmd, &amp;tmp_list, i_conn_node) {</span>
<span class="p_add">+		struct se_cmd *se_cmd = &amp;cmd-&gt;se_cmd;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (se_cmd-&gt;se_tfo != NULL) {</span>
<span class="p_add">+			spin_lock(&amp;se_cmd-&gt;t_state_lock);</span>
<span class="p_add">+			se_cmd-&gt;transport_state |= CMD_T_FABRIC_STOP;</span>
<span class="p_add">+			spin_unlock(&amp;se_cmd-&gt;t_state_lock);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_bh(&amp;conn-&gt;cmd_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry_safe(cmd, cmd_tmp, &amp;tmp_list, i_conn_node) {</span>
 		list_del_init(&amp;cmd-&gt;i_conn_node);
<span class="p_del">-		spin_unlock_bh(&amp;conn-&gt;cmd_lock);</span>
 
 		iscsit_increment_maxcmdsn(cmd, sess);
<span class="p_del">-</span>
 		iscsit_free_cmd(cmd, true);
 
<span class="p_del">-		spin_lock_bh(&amp;conn-&gt;cmd_lock);</span>
 	}
<span class="p_del">-	spin_unlock_bh(&amp;conn-&gt;cmd_lock);</span>
 }
 
 static void iscsit_stop_timers_for_cmds(
<span class="p_header">diff --git a/drivers/target/target_core_device.c b/drivers/target/target_core_device.c</span>
<span class="p_header">index e366b812f0e1..7c3ba7d711f1 100644</span>
<span class="p_header">--- a/drivers/target/target_core_device.c</span>
<span class="p_header">+++ b/drivers/target/target_core_device.c</span>
<span class="p_chunk">@@ -1583,13 +1583,15 @@</span> <span class="p_context"> struct se_device *target_alloc_device(struct se_hba *hba, const char *name)</span>
  * in ATA and we need to set TPE=1
  */
 bool target_configure_unmap_from_queue(struct se_dev_attrib *attrib,
<span class="p_del">-				       struct request_queue *q, int block_size)</span>
<span class="p_add">+				       struct request_queue *q)</span>
 {
<span class="p_add">+	int block_size = queue_logical_block_size(q);</span>
<span class="p_add">+</span>
 	if (!blk_queue_discard(q))
 		return false;
 
<span class="p_del">-	attrib-&gt;max_unmap_lba_count = (q-&gt;limits.max_discard_sectors &lt;&lt; 9) /</span>
<span class="p_del">-								block_size;</span>
<span class="p_add">+	attrib-&gt;max_unmap_lba_count =</span>
<span class="p_add">+		q-&gt;limits.max_discard_sectors &gt;&gt; (ilog2(block_size) - 9);</span>
 	/*
 	 * Currently hardcoded to 1 in Linux/SCSI code..
 	 */
<span class="p_header">diff --git a/drivers/target/target_core_file.c b/drivers/target/target_core_file.c</span>
<span class="p_header">index 6fe5b503f6e1..d8bf1d9c723d 100644</span>
<span class="p_header">--- a/drivers/target/target_core_file.c</span>
<span class="p_header">+++ b/drivers/target/target_core_file.c</span>
<span class="p_chunk">@@ -165,8 +165,7 @@</span> <span class="p_context"> static int fd_configure_device(struct se_device *dev)</span>
 			dev_size, div_u64(dev_size, fd_dev-&gt;fd_block_size),
 			fd_dev-&gt;fd_block_size);
 
<span class="p_del">-		if (target_configure_unmap_from_queue(&amp;dev-&gt;dev_attrib, q,</span>
<span class="p_del">-						      fd_dev-&gt;fd_block_size))</span>
<span class="p_add">+		if (target_configure_unmap_from_queue(&amp;dev-&gt;dev_attrib, q))</span>
 			pr_debug(&quot;IFILE: BLOCK Discard support available,&quot;
 				 &quot; disabled by default\n&quot;);
 		/*
<span class="p_header">diff --git a/drivers/target/target_core_iblock.c b/drivers/target/target_core_iblock.c</span>
<span class="p_header">index 357b9fb61499..f66e677ee5e5 100644</span>
<span class="p_header">--- a/drivers/target/target_core_iblock.c</span>
<span class="p_header">+++ b/drivers/target/target_core_iblock.c</span>
<span class="p_chunk">@@ -126,8 +126,7 @@</span> <span class="p_context"> static int iblock_configure_device(struct se_device *dev)</span>
 	dev-&gt;dev_attrib.hw_max_sectors = queue_max_hw_sectors(q);
 	dev-&gt;dev_attrib.hw_queue_depth = q-&gt;nr_requests;
 
<span class="p_del">-	if (target_configure_unmap_from_queue(&amp;dev-&gt;dev_attrib, q,</span>
<span class="p_del">-					      dev-&gt;dev_attrib.hw_block_size))</span>
<span class="p_add">+	if (target_configure_unmap_from_queue(&amp;dev-&gt;dev_attrib, q))</span>
 		pr_debug(&quot;IBLOCK: BLOCK Discard support available,&quot;
 			 &quot; disabled by default\n&quot;);
 
<span class="p_header">diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c</span>
<span class="p_header">index 9ad3d263d5e1..7ddf11c35eb7 100644</span>
<span class="p_header">--- a/drivers/target/target_core_transport.c</span>
<span class="p_header">+++ b/drivers/target/target_core_transport.c</span>
<span class="p_chunk">@@ -2407,7 +2407,8 @@</span> <span class="p_context"> static void target_release_cmd_kref(struct kref *kref)</span>
 	}
 
 	spin_lock(&amp;se_cmd-&gt;t_state_lock);
<span class="p_del">-	fabric_stop = (se_cmd-&gt;transport_state &amp; CMD_T_FABRIC_STOP);</span>
<span class="p_add">+	fabric_stop = (se_cmd-&gt;transport_state &amp; CMD_T_FABRIC_STOP) &amp;&amp;</span>
<span class="p_add">+		      (se_cmd-&gt;transport_state &amp; CMD_T_ABORTED);</span>
 	spin_unlock(&amp;se_cmd-&gt;t_state_lock);
 
 	if (se_cmd-&gt;cmd_wait_set || fabric_stop) {
<span class="p_header">diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c</span>
<span class="p_header">index 8016aaa158f2..a78766432d69 100644</span>
<span class="p_header">--- a/drivers/usb/core/devio.c</span>
<span class="p_header">+++ b/drivers/usb/core/devio.c</span>
<span class="p_chunk">@@ -1104,10 +1104,11 @@</span> <span class="p_context"> static int proc_getdriver(struct dev_state *ps, void __user *arg)</span>
 
 static int proc_connectinfo(struct dev_state *ps, void __user *arg)
 {
<span class="p_del">-	struct usbdevfs_connectinfo ci = {</span>
<span class="p_del">-		.devnum = ps-&gt;dev-&gt;devnum,</span>
<span class="p_del">-		.slow = ps-&gt;dev-&gt;speed == USB_SPEED_LOW</span>
<span class="p_del">-	};</span>
<span class="p_add">+	struct usbdevfs_connectinfo ci;</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(&amp;ci, 0, sizeof(ci));</span>
<span class="p_add">+	ci.devnum = ps-&gt;dev-&gt;devnum;</span>
<span class="p_add">+	ci.slow = ps-&gt;dev-&gt;speed == USB_SPEED_LOW;</span>
 
 	if (copy_to_user(arg, &amp;ci, sizeof(ci)))
 		return -EFAULT;
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_header">index 458f3766bef1..1858df669965 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_chunk">@@ -558,6 +558,9 @@</span> <span class="p_context"> static int usbhsg_ep_enable(struct usb_ep *ep,</span>
 	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
 	struct usbhs_pipe *pipe;
 	int ret = -EIO;
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	usbhs_lock(priv, flags);</span>
 
 	/*
 	 * if it already have pipe,
<span class="p_chunk">@@ -566,7 +569,8 @@</span> <span class="p_context"> static int usbhsg_ep_enable(struct usb_ep *ep,</span>
 	if (uep-&gt;pipe) {
 		usbhs_pipe_clear(uep-&gt;pipe);
 		usbhs_pipe_sequence_data0(uep-&gt;pipe);
<span class="p_del">-		return 0;</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto usbhsg_ep_enable_end;</span>
 	}
 
 	pipe = usbhs_pipe_malloc(priv,
<span class="p_chunk">@@ -594,6 +598,9 @@</span> <span class="p_context"> static int usbhsg_ep_enable(struct usb_ep *ep,</span>
 		ret = 0;
 	}
 
<span class="p_add">+usbhsg_ep_enable_end:</span>
<span class="p_add">+	usbhs_unlock(priv, flags);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index bcb6f5c2bae4..006a2a721edf 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -274,6 +274,7 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define TELIT_PRODUCT_LE922_USBCFG5		0x1045
 #define TELIT_PRODUCT_LE920			0x1200
 #define TELIT_PRODUCT_LE910			0x1201
<span class="p_add">+#define TELIT_PRODUCT_LE910_USBCFG4		0x1206</span>
 
 /* ZTE PRODUCTS */
 #define ZTE_VENDOR_ID				0x19d2
<span class="p_chunk">@@ -1206,6 +1207,8 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg0 },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE910),
 		.driver_info = (kernel_ulong_t)&amp;telit_le910_blacklist },
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE910_USBCFG4),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg3 },</span>
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920),
 		.driver_info = (kernel_ulong_t)&amp;telit_le920_blacklist },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_MF622, 0xff, 0xff, 0xff) }, /* ZTE WCDMA products */
<span class="p_header">diff --git a/drivers/virtio/virtio_balloon.c b/drivers/virtio/virtio_balloon.c</span>
<span class="p_header">index 36e7859a31aa..8e7e43bbee1a 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_balloon.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio_balloon.c</span>
<span class="p_chunk">@@ -178,6 +178,8 @@</span> <span class="p_context"> static void leak_balloon(struct virtio_balloon *vb, size_t num)</span>
 	num = min(num, ARRAY_SIZE(vb-&gt;pfns));
 
 	mutex_lock(&amp;vb-&gt;balloon_lock);
<span class="p_add">+	/* We can&#39;t release more pages than taken */</span>
<span class="p_add">+	num = min(num, (size_t)vb-&gt;num_pages);</span>
 	for (vb-&gt;num_pfns = 0; vb-&gt;num_pfns &lt; num;
 	     vb-&gt;num_pfns += VIRTIO_BALLOON_PAGES_PER_PAGE) {
 		page = balloon_page_dequeue(vb_dev_info);
<span class="p_header">diff --git a/fs/cifs/cifsencrypt.c b/fs/cifs/cifsencrypt.c</span>
<span class="p_header">index 0bd335a393f8..f1aa100758df 100644</span>
<span class="p_header">--- a/fs/cifs/cifsencrypt.c</span>
<span class="p_header">+++ b/fs/cifs/cifsencrypt.c</span>
<span class="p_chunk">@@ -727,24 +727,26 @@</span> <span class="p_context"> setup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)</span>
 
 	memcpy(ses-&gt;auth_key.response + baselen, tiblob, tilen);
 
<span class="p_add">+	mutex_lock(&amp;ses-&gt;server-&gt;srv_mutex);</span>
<span class="p_add">+</span>
 	rc = crypto_hmacmd5_alloc(ses-&gt;server);
 	if (rc) {
 		cifs_dbg(VFS, &quot;could not crypto alloc hmacmd5 rc %d\n&quot;, rc);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	/* calculate ntlmv2_hash */
 	rc = calc_ntlmv2_hash(ses, ntlmv2_hash, nls_cp);
 	if (rc) {
 		cifs_dbg(VFS, &quot;could not get v2 hash rc %d\n&quot;, rc);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	/* calculate first part of the client response (CR1) */
 	rc = CalcNTLMv2_response(ses, ntlmv2_hash);
 	if (rc) {
 		cifs_dbg(VFS, &quot;Could not calculate CR1 rc: %d\n&quot;, rc);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	/* now calculate the session key for NTLMv2 */
<span class="p_chunk">@@ -753,13 +755,13 @@</span> <span class="p_context"> setup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)</span>
 	if (rc) {
 		cifs_dbg(VFS, &quot;%s: Could not set NTLMV2 Hash as a key\n&quot;,
 			 __func__);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	rc = crypto_shash_init(&amp;ses-&gt;server-&gt;secmech.sdeschmacmd5-&gt;shash);
 	if (rc) {
 		cifs_dbg(VFS, &quot;%s: Could not init hmacmd5\n&quot;, __func__);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	rc = crypto_shash_update(&amp;ses-&gt;server-&gt;secmech.sdeschmacmd5-&gt;shash,
<span class="p_chunk">@@ -767,7 +769,7 @@</span> <span class="p_context"> setup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)</span>
 		CIFS_HMAC_MD5_HASH_SIZE);
 	if (rc) {
 		cifs_dbg(VFS, &quot;%s: Could not update with response\n&quot;, __func__);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	rc = crypto_shash_final(&amp;ses-&gt;server-&gt;secmech.sdeschmacmd5-&gt;shash,
<span class="p_chunk">@@ -775,6 +777,8 @@</span> <span class="p_context"> setup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)</span>
 	if (rc)
 		cifs_dbg(VFS, &quot;%s: Could not generate md5 hash\n&quot;, __func__);
 
<span class="p_add">+unlock:</span>
<span class="p_add">+	mutex_unlock(&amp;ses-&gt;server-&gt;srv_mutex);</span>
 setup_ntlmv2_rsp_ret:
 	kfree(tiblob);
 
<span class="p_header">diff --git a/fs/cifs/dir.c b/fs/cifs/dir.c</span>
<span class="p_header">index 3db0c5fd9a11..3f2dd87b899a 100644</span>
<span class="p_header">--- a/fs/cifs/dir.c</span>
<span class="p_header">+++ b/fs/cifs/dir.c</span>
<span class="p_chunk">@@ -229,6 +229,13 @@</span> <span class="p_context"> cifs_do_create(struct inode *inode, struct dentry *direntry, unsigned int xid,</span>
 				goto cifs_create_get_file_info;
 			}
 
<span class="p_add">+			if (S_ISDIR(newinode-&gt;i_mode)) {</span>
<span class="p_add">+				CIFSSMBClose(xid, tcon, fid-&gt;netfid);</span>
<span class="p_add">+				iput(newinode);</span>
<span class="p_add">+				rc = -EISDIR;</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			if (!S_ISREG(newinode-&gt;i_mode)) {
 				/*
 				 * The server may allow us to open things like
<span class="p_chunk">@@ -399,10 +406,14 @@</span> <span class="p_context"> cifs_create_set_dentry:</span>
 	if (rc != 0) {
 		cifs_dbg(FYI, &quot;Create worked, get_inode_info failed rc = %d\n&quot;,
 			 rc);
<span class="p_del">-		if (server-&gt;ops-&gt;close)</span>
<span class="p_del">-			server-&gt;ops-&gt;close(xid, tcon, fid);</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto out_err;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (S_ISDIR(newinode-&gt;i_mode)) {</span>
<span class="p_add">+		rc = -EISDIR;</span>
<span class="p_add">+		goto out_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	d_drop(direntry);
 	d_add(direntry, newinode);
 
<span class="p_chunk">@@ -410,6 +421,13 @@</span> <span class="p_context"> out:</span>
 	kfree(buf);
 	kfree(full_path);
 	return rc;
<span class="p_add">+</span>
<span class="p_add">+out_err:</span>
<span class="p_add">+	if (server-&gt;ops-&gt;close)</span>
<span class="p_add">+		server-&gt;ops-&gt;close(xid, tcon, fid);</span>
<span class="p_add">+	if (newinode)</span>
<span class="p_add">+		iput(newinode);</span>
<span class="p_add">+	goto out;</span>
 }
 
 int
<span class="p_header">diff --git a/fs/cifs/smb2ops.c b/fs/cifs/smb2ops.c</span>
<span class="p_header">index 6aeb1de0fa23..a2c96326f475 100644</span>
<span class="p_header">--- a/fs/cifs/smb2ops.c</span>
<span class="p_header">+++ b/fs/cifs/smb2ops.c</span>
<span class="p_chunk">@@ -858,6 +858,9 @@</span> <span class="p_context"> smb2_new_lease_key(struct cifs_fid *fid)</span>
 	get_random_bytes(fid-&gt;lease_key, SMB2_LEASE_KEY_SIZE);
 }
 
<span class="p_add">+#define SMB2_SYMLINK_STRUCT_SIZE \</span>
<span class="p_add">+	(sizeof(struct smb2_err_rsp) - 1 + sizeof(struct smb2_symlink_err_rsp))</span>
<span class="p_add">+</span>
 static int
 smb2_query_symlink(const unsigned int xid, struct cifs_tcon *tcon,
 		   const char *full_path, char **target_path,
<span class="p_chunk">@@ -870,7 +873,10 @@</span> <span class="p_context"> smb2_query_symlink(const unsigned int xid, struct cifs_tcon *tcon,</span>
 	struct cifs_fid fid;
 	struct smb2_err_rsp *err_buf = NULL;
 	struct smb2_symlink_err_rsp *symlink;
<span class="p_del">-	unsigned int sub_len, sub_offset;</span>
<span class="p_add">+	unsigned int sub_len;</span>
<span class="p_add">+	unsigned int sub_offset;</span>
<span class="p_add">+	unsigned int print_len;</span>
<span class="p_add">+	unsigned int print_offset;</span>
 
 	cifs_dbg(FYI, &quot;%s: path: %s\n&quot;, __func__, full_path);
 
<span class="p_chunk">@@ -891,11 +897,33 @@</span> <span class="p_context"> smb2_query_symlink(const unsigned int xid, struct cifs_tcon *tcon,</span>
 		kfree(utf16_path);
 		return -ENOENT;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (le32_to_cpu(err_buf-&gt;ByteCount) &lt; sizeof(struct smb2_symlink_err_rsp) ||</span>
<span class="p_add">+	    get_rfc1002_length(err_buf) + 4 &lt; SMB2_SYMLINK_STRUCT_SIZE) {</span>
<span class="p_add">+		kfree(utf16_path);</span>
<span class="p_add">+		return -ENOENT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* open must fail on symlink - reset rc */
 	rc = 0;
 	symlink = (struct smb2_symlink_err_rsp *)err_buf-&gt;ErrorData;
 	sub_len = le16_to_cpu(symlink-&gt;SubstituteNameLength);
 	sub_offset = le16_to_cpu(symlink-&gt;SubstituteNameOffset);
<span class="p_add">+	print_len = le16_to_cpu(symlink-&gt;PrintNameLength);</span>
<span class="p_add">+	print_offset = le16_to_cpu(symlink-&gt;PrintNameOffset);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (get_rfc1002_length(err_buf) + 4 &lt;</span>
<span class="p_add">+			SMB2_SYMLINK_STRUCT_SIZE + sub_offset + sub_len) {</span>
<span class="p_add">+		kfree(utf16_path);</span>
<span class="p_add">+		return -ENOENT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (get_rfc1002_length(err_buf) + 4 &lt;</span>
<span class="p_add">+			SMB2_SYMLINK_STRUCT_SIZE + print_offset + print_len) {</span>
<span class="p_add">+		kfree(utf16_path);</span>
<span class="p_add">+		return -ENOENT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	*target_path = cifs_strndup_from_utf16(
 				(char *)symlink-&gt;PathBuffer + sub_offset,
 				sub_len, true, cifs_sb-&gt;local_nls);
<span class="p_header">diff --git a/fs/nfs/write.c b/fs/nfs/write.c</span>
<span class="p_header">index aaa16b31e21e..253ebd390f9b 100644</span>
<span class="p_header">--- a/fs/nfs/write.c</span>
<span class="p_header">+++ b/fs/nfs/write.c</span>
<span class="p_chunk">@@ -965,6 +965,9 @@</span> <span class="p_context"> int nfs_updatepage(struct file *file, struct page *page,</span>
 	dprintk(&quot;NFS:       nfs_updatepage(%pD2 %d@%lld)\n&quot;,
 		file, count, (long long)(page_file_offset(page) + offset));
 
<span class="p_add">+	if (!count)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	if (nfs_can_extend_write(file, page, inode)) {
 		count = max(count + offset, nfs_page_length(page));
 		offset = 0;
<span class="p_chunk">@@ -975,7 +978,7 @@</span> <span class="p_context"> int nfs_updatepage(struct file *file, struct page *page,</span>
 		nfs_set_pageerror(page);
 	else
 		__set_page_dirty_nobuffers(page);
<span class="p_del">-</span>
<span class="p_add">+out:</span>
 	dprintk(&quot;NFS:       nfs_updatepage returns %d (isize %lld)\n&quot;,
 			status, (long long)i_size_read(inode));
 	return status;
<span class="p_header">diff --git a/include/linux/mlx5/qp.h b/include/linux/mlx5/qp.h</span>
<span class="p_header">index d51eff713549..6dcec3288870 100644</span>
<span class="p_header">--- a/include/linux/mlx5/qp.h</span>
<span class="p_header">+++ b/include/linux/mlx5/qp.h</span>
<span class="p_chunk">@@ -137,6 +137,7 @@</span> <span class="p_context"> enum {</span>
 enum {
 	MLX5_FENCE_MODE_NONE			= 0 &lt;&lt; 5,
 	MLX5_FENCE_MODE_INITIATOR_SMALL		= 1 &lt;&lt; 5,
<span class="p_add">+	MLX5_FENCE_MODE_FENCE			= 2 &lt;&lt; 5,</span>
 	MLX5_FENCE_MODE_STRONG_ORDERING		= 3 &lt;&lt; 5,
 	MLX5_FENCE_MODE_SMALL_AND_FENCE		= 4 &lt;&lt; 5,
 };
<span class="p_chunk">@@ -378,9 +379,9 @@</span> <span class="p_context"> struct mlx5_destroy_qp_mbox_out {</span>
 struct mlx5_modify_qp_mbox_in {
 	struct mlx5_inbox_hdr	hdr;
 	__be32			qpn;
<span class="p_del">-	u8			rsvd1[4];</span>
<span class="p_del">-	__be32			optparam;</span>
 	u8			rsvd0[4];
<span class="p_add">+	__be32			optparam;</span>
<span class="p_add">+	u8			rsvd1[4];</span>
 	struct mlx5_qp_context	ctx;
 };
 
<span class="p_header">diff --git a/include/target/target_core_backend.h b/include/target/target_core_backend.h</span>
<span class="p_header">index 522ae25a61a7..c519c126ee14 100644</span>
<span class="p_header">--- a/include/target/target_core_backend.h</span>
<span class="p_header">+++ b/include/target/target_core_backend.h</span>
<span class="p_chunk">@@ -96,6 +96,6 @@</span> <span class="p_context"> void	array_free(void *array, int n);</span>
 
 sector_t target_to_linux_sector(struct se_device *dev, sector_t lb);
 bool target_configure_unmap_from_queue(struct se_dev_attrib *attrib,
<span class="p_del">-				       struct request_queue *q, int block_size);</span>
<span class="p_add">+				       struct request_queue *q);</span>
 
 #endif /* TARGET_CORE_BACKEND_H */
<span class="p_header">diff --git a/kernel/module.c b/kernel/module.c</span>
<span class="p_header">index 3a311a1d26d7..6113c5a536b8 100644</span>
<span class="p_header">--- a/kernel/module.c</span>
<span class="p_header">+++ b/kernel/module.c</span>
<span class="p_chunk">@@ -2449,13 +2449,18 @@</span> <span class="p_context"> static inline void kmemleak_load_module(const struct module *mod,</span>
 #endif
 
 #ifdef CONFIG_MODULE_SIG
<span class="p_del">-static int module_sig_check(struct load_info *info)</span>
<span class="p_add">+static int module_sig_check(struct load_info *info, int flags)</span>
 {
 	int err = -ENOKEY;
 	const unsigned long markerlen = sizeof(MODULE_SIG_STRING) - 1;
 	const void *mod = info-&gt;hdr;
 
<span class="p_del">-	if (info-&gt;len &gt; markerlen &amp;&amp;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Require flags == 0, as a module with version information</span>
<span class="p_add">+	 * removed is no longer the module that was signed</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (flags == 0 &amp;&amp;</span>
<span class="p_add">+	    info-&gt;len &gt; markerlen &amp;&amp;</span>
 	    memcmp(mod + info-&gt;len - markerlen, MODULE_SIG_STRING, markerlen) == 0) {
 		/* We truncate the module to discard the signature */
 		info-&gt;len -= markerlen;
<span class="p_chunk">@@ -2477,7 +2482,7 @@</span> <span class="p_context"> static int module_sig_check(struct load_info *info)</span>
 	return err;
 }
 #else /* !CONFIG_MODULE_SIG */
<span class="p_del">-static int module_sig_check(struct load_info *info)</span>
<span class="p_add">+static int module_sig_check(struct load_info *info, int flags)</span>
 {
 	return 0;
 }
<span class="p_chunk">@@ -3210,7 +3215,7 @@</span> <span class="p_context"> static int load_module(struct load_info *info, const char __user *uargs,</span>
 	struct module *mod;
 	long err;
 
<span class="p_del">-	err = module_sig_check(info);</span>
<span class="p_add">+	err = module_sig_check(info, flags);</span>
 	if (err)
 		goto free_copy;
 
<span class="p_header">diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c</span>
<span class="p_header">index 06a7a769737f..5fb1cc21df55 100644</span>
<span class="p_header">--- a/net/bluetooth/l2cap_sock.c</span>
<span class="p_header">+++ b/net/bluetooth/l2cap_sock.c</span>
<span class="p_chunk">@@ -922,7 +922,7 @@</span> <span class="p_context"> static int l2cap_sock_setsockopt(struct socket *sock, int level, int optname,</span>
 			break;
 		}
 
<span class="p_del">-		if (get_user(opt, (u32 __user *) optval)) {</span>
<span class="p_add">+		if (get_user(opt, (u16 __user *) optval)) {</span>
 			err = -EFAULT;
 			break;
 		}
<span class="p_header">diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c</span>
<span class="p_header">index 90f9d00a3fbc..963b7f746777 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_input.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_input.c</span>
<span class="p_chunk">@@ -3299,12 +3299,12 @@</span> <span class="p_context"> static void tcp_send_challenge_ack(struct sock *sk)</span>
 		u32 half = (sysctl_tcp_challenge_ack_limit + 1) &gt;&gt; 1;
 
 		challenge_timestamp = now;
<span class="p_del">-		challenge_count = half +</span>
<span class="p_add">+		ACCESS_ONCE(challenge_count) = half +</span>
 				  prandom_u32_max(sysctl_tcp_challenge_ack_limit);
 	}
<span class="p_del">-	count = challenge_count;</span>
<span class="p_add">+	count = ACCESS_ONCE(challenge_count);</span>
 	if (count &gt; 0) {
<span class="p_del">-		challenge_count = count - 1;</span>
<span class="p_add">+		ACCESS_ONCE(challenge_count) = count - 1;</span>
 		NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);
 		tcp_send_ack(sk);
 	}
<span class="p_header">diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c</span>
<span class="p_header">index b0fe13529033..f305c4b49617 100644</span>
<span class="p_header">--- a/net/ipv4/udp.c</span>
<span class="p_header">+++ b/net/ipv4/udp.c</span>
<span class="p_chunk">@@ -1233,6 +1233,7 @@</span> <span class="p_context"> int udp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,</span>
 	int peeked, off = 0;
 	int err;
 	int is_udplite = IS_UDPLITE(sk);
<span class="p_add">+	bool checksum_valid = false;</span>
 	bool slow;
 
 	if (flags &amp; MSG_ERRQUEUE)
<span class="p_chunk">@@ -1258,11 +1259,12 @@</span> <span class="p_context"> try_again:</span>
 	 */
 
 	if (copied &lt; ulen || UDP_SKB_CB(skb)-&gt;partial_cov) {
<span class="p_del">-		if (udp_lib_checksum_complete(skb))</span>
<span class="p_add">+		checksum_valid = !udp_lib_checksum_complete(skb);</span>
<span class="p_add">+		if (!checksum_valid)</span>
 			goto csum_copy_err;
 	}
 
<span class="p_del">-	if (skb_csum_unnecessary(skb))</span>
<span class="p_add">+	if (checksum_valid || skb_csum_unnecessary(skb))</span>
 		err = skb_copy_datagram_iovec(skb, sizeof(struct udphdr),
 					      msg-&gt;msg_iov, copied);
 	else {
<span class="p_header">diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c</span>
<span class="p_header">index d2013c718112..639401cac06e 100644</span>
<span class="p_header">--- a/net/ipv6/udp.c</span>
<span class="p_header">+++ b/net/ipv6/udp.c</span>
<span class="p_chunk">@@ -389,6 +389,7 @@</span> <span class="p_context"> int udpv6_recvmsg(struct kiocb *iocb, struct sock *sk,</span>
 	int peeked, off = 0;
 	int err;
 	int is_udplite = IS_UDPLITE(sk);
<span class="p_add">+	bool checksum_valid = false;</span>
 	int is_udp4;
 	bool slow;
 
<span class="p_chunk">@@ -420,11 +421,12 @@</span> <span class="p_context"> try_again:</span>
 	 */
 
 	if (copied &lt; ulen || UDP_SKB_CB(skb)-&gt;partial_cov) {
<span class="p_del">-		if (udp_lib_checksum_complete(skb))</span>
<span class="p_add">+		checksum_valid = !udp_lib_checksum_complete(skb);</span>
<span class="p_add">+		if (!checksum_valid)</span>
 			goto csum_copy_err;
 	}
 
<span class="p_del">-	if (skb_csum_unnecessary(skb))</span>
<span class="p_add">+	if (checksum_valid || skb_csum_unnecessary(skb))</span>
 		err = skb_copy_datagram_iovec(skb, sizeof(struct udphdr),
 					      msg-&gt;msg_iov, copied);
 	else {
<span class="p_header">diff --git a/net/netlabel/netlabel_kapi.c b/net/netlabel/netlabel_kapi.c</span>
<span class="p_header">index 3045a964f39c..8473d34f2e3a 100644</span>
<span class="p_header">--- a/net/netlabel/netlabel_kapi.c</span>
<span class="p_header">+++ b/net/netlabel/netlabel_kapi.c</span>
<span class="p_chunk">@@ -699,7 +699,11 @@</span> <span class="p_context"> socket_setattr_return:</span>
  */
 void netlbl_sock_delattr(struct sock *sk)
 {
<span class="p_del">-	cipso_v4_sock_delattr(sk);</span>
<span class="p_add">+	switch (sk-&gt;sk_family) {</span>
<span class="p_add">+	case AF_INET:</span>
<span class="p_add">+		cipso_v4_sock_delattr(sk);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_chunk">@@ -862,7 +866,11 @@</span> <span class="p_context"> req_setattr_return:</span>
 */
 void netlbl_req_delattr(struct request_sock *req)
 {
<span class="p_del">-	cipso_v4_req_delattr(req);</span>
<span class="p_add">+	switch (req-&gt;rsk_ops-&gt;family) {</span>
<span class="p_add">+	case AF_INET:</span>
<span class="p_add">+		cipso_v4_req_delattr(req);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_header">diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c</span>
<span class="p_header">index ee625e3a56ba..4f7d13da04a5 100644</span>
<span class="p_header">--- a/scripts/recordmcount.c</span>
<span class="p_header">+++ b/scripts/recordmcount.c</span>
<span class="p_chunk">@@ -33,10 +33,17 @@</span> <span class="p_context"></span>
 #include &lt;string.h&gt;
 #include &lt;unistd.h&gt;
 
<span class="p_add">+/*</span>
<span class="p_add">+ * glibc synced up and added the metag number but didn&#39;t add the relocations.</span>
<span class="p_add">+ * Work around this in a crude manner for now.</span>
<span class="p_add">+ */</span>
 #ifndef EM_METAG
<span class="p_del">-/* Remove this when these make it to the standard system elf.h. */</span>
 #define EM_METAG      174
<span class="p_add">+#endif</span>
<span class="p_add">+#ifndef R_METAG_ADDR32</span>
 #define R_METAG_ADDR32                   2
<span class="p_add">+#endif</span>
<span class="p_add">+#ifndef R_METAG_NONE</span>
 #define R_METAG_NONE                     3
 #endif
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



