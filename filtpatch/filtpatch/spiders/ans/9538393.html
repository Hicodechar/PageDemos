
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.9.6 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.9.6</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 26, 2017, 7:48 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170126074852.GB19870@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9538393/mbox/"
   >mbox</a>
|
   <a href="/patch/9538393/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9538393/">/patch/9538393/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	A42CC6046A for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 26 Jan 2017 07:49:08 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 8505727F17
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 26 Jan 2017 07:49:08 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 768C227F99; Thu, 26 Jan 2017 07:49:08 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 7BE1027F17
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 26 Jan 2017 07:49:01 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753033AbdAZHsy (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 26 Jan 2017 02:48:54 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:56258 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1753008AbdAZHsr (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 26 Jan 2017 02:48:47 -0500
Received: from localhost (unknown [78.192.101.3])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 04D0E8CC;
	Thu, 26 Jan 2017 07:48:38 +0000 (UTC)
Date: Thu, 26 Jan 2017 08:48:52 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.9.6
Message-ID: &lt;20170126074852.GB19870@kroah.com&gt;
References: &lt;20170126074846.GA19870@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170126074846.GA19870@kroah.com&gt;
User-Agent: Mutt/1.7.2 (2016-11-26)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Jan. 26, 2017, 7:48 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/clock/imx31-clock.txt b/Documentation/devicetree/bindings/clock/imx31-clock.txt</span>
<span class="p_header">index 19df842c694f..8163d565f697 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/clock/imx31-clock.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/clock/imx31-clock.txt</span>
<span class="p_chunk">@@ -77,7 +77,7 @@</span> <span class="p_context"> Examples:</span>
 clks: ccm@53f80000{
 	compatible = &quot;fsl,imx31-ccm&quot;;
 	reg = &lt;0x53f80000 0x4000&gt;;
<span class="p_del">-	interrupts = &lt;0 31 0x04 0 53 0x04&gt;;</span>
<span class="p_add">+	interrupts = &lt;31&gt;, &lt;53&gt;;</span>
 	#clock-cells = &lt;1&gt;;
 };
 
<span class="p_header">diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt</span>
<span class="p_header">index 37babf91f2cb..922dec8fa07e 100644</span>
<span class="p_header">--- a/Documentation/kernel-parameters.txt</span>
<span class="p_header">+++ b/Documentation/kernel-parameters.txt</span>
<span class="p_chunk">@@ -3998,10 +3998,11 @@</span> <span class="p_context"> bytes respectively. Such letter suffixes can also be entirely omitted.</span>
 			it if 0 is given (See Documentation/cgroup-v1/memory.txt)
 
 	swiotlb=	[ARM,IA-64,PPC,MIPS,X86]
<span class="p_del">-			Format: { &lt;int&gt; | force }</span>
<span class="p_add">+			Format: { &lt;int&gt; | force | noforce }</span>
 			&lt;int&gt; -- Number of I/O TLB slabs
 			force -- force using of bounce buffers even if they
 			         wouldn&#39;t be automatically used by the kernel
<span class="p_add">+			noforce -- Never use bounce buffers (for debugging)</span>
 
 	switches=	[HW,M68k]
 
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 2a8af8af7b27..ef95231d1625 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 9
<span class="p_del">-SUBLEVEL = 5</span>
<span class="p_add">+SUBLEVEL = 6</span>
 EXTRAVERSION =
 NAME = Roaring Lionus
 
<span class="p_header">diff --git a/arch/arc/Kconfig b/arch/arc/Kconfig</span>
<span class="p_header">index bd204bfa29ed..249e10190d20 100644</span>
<span class="p_header">--- a/arch/arc/Kconfig</span>
<span class="p_header">+++ b/arch/arc/Kconfig</span>
<span class="p_chunk">@@ -28,7 +28,7 @@</span> <span class="p_context"> config ARC</span>
 	select HAVE_KPROBES
 	select HAVE_KRETPROBES
 	select HAVE_MEMBLOCK
<span class="p_del">-	select HAVE_MOD_ARCH_SPECIFIC if ARC_DW2_UNWIND</span>
<span class="p_add">+	select HAVE_MOD_ARCH_SPECIFIC</span>
 	select HAVE_OPROFILE
 	select HAVE_PERF_EVENTS
 	select HANDLE_DOMAIN_IRQ
<span class="p_header">diff --git a/arch/arc/include/asm/module.h b/arch/arc/include/asm/module.h</span>
<span class="p_header">index 6e91d8b339c3..567590ea8f6c 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/module.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/module.h</span>
<span class="p_chunk">@@ -14,13 +14,13 @@</span> <span class="p_context"></span>
 
 #include &lt;asm-generic/module.h&gt;
 
<span class="p_del">-#ifdef CONFIG_ARC_DW2_UNWIND</span>
 struct mod_arch_specific {
<span class="p_add">+#ifdef CONFIG_ARC_DW2_UNWIND</span>
 	void *unw_info;
 	int unw_sec_idx;
<span class="p_add">+#endif</span>
 	const char *secstr;
 };
<span class="p_del">-#endif</span>
 
 #define MODULE_PROC_FAMILY &quot;ARC700&quot;
 
<span class="p_header">diff --git a/arch/arc/kernel/module.c b/arch/arc/kernel/module.c</span>
<span class="p_header">index 42e964db2967..3d99a6091332 100644</span>
<span class="p_header">--- a/arch/arc/kernel/module.c</span>
<span class="p_header">+++ b/arch/arc/kernel/module.c</span>
<span class="p_chunk">@@ -32,8 +32,8 @@</span> <span class="p_context"> int module_frob_arch_sections(Elf_Ehdr *hdr, Elf_Shdr *sechdrs,</span>
 #ifdef CONFIG_ARC_DW2_UNWIND
 	mod-&gt;arch.unw_sec_idx = 0;
 	mod-&gt;arch.unw_info = NULL;
<span class="p_del">-	mod-&gt;arch.secstr = secstr;</span>
 #endif
<span class="p_add">+	mod-&gt;arch.secstr = secstr;</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -113,8 +113,10 @@</span> <span class="p_context"> int apply_relocate_add(Elf32_Shdr *sechdrs,</span>
 
 	}
 
<span class="p_add">+#ifdef CONFIG_ARC_DW2_UNWIND</span>
 	if (strcmp(module-&gt;arch.secstr+sechdrs[tgtsec].sh_name, &quot;.eh_frame&quot;) == 0)
 		module-&gt;arch.unw_sec_idx = tgtsec;
<span class="p_add">+#endif</span>
 
 	return 0;
 
<span class="p_header">diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile</span>
<span class="p_header">index c558ba75cbcc..7037201c5e3a 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/Makefile</span>
<span class="p_header">+++ b/arch/arm/boot/dts/Makefile</span>
<span class="p_chunk">@@ -485,6 +485,7 @@</span> <span class="p_context"> dtb-$(CONFIG_ARCH_OMAP3) += \</span>
 	am3517-evm.dtb \
 	am3517_mt_ventoux.dtb \
 	logicpd-torpedo-37xx-devkit.dtb \
<span class="p_add">+	logicpd-som-lv-37xx-devkit.dtb \</span>
 	omap3430-sdp.dtb \
 	omap3-beagle.dtb \
 	omap3-beagle-xm.dtb \
<span class="p_header">diff --git a/arch/arm/boot/dts/am33xx.dtsi b/arch/arm/boot/dts/am33xx.dtsi</span>
<span class="p_header">index 194d884c9de1..795c1467fa50 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/am33xx.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/am33xx.dtsi</span>
<span class="p_chunk">@@ -16,6 +16,7 @@</span> <span class="p_context"></span>
 	interrupt-parent = &lt;&amp;intc&gt;;
 	#address-cells = &lt;1&gt;;
 	#size-cells = &lt;1&gt;;
<span class="p_add">+	chosen { };</span>
 
 	aliases {
 		i2c0 = &amp;i2c0;
<span class="p_header">diff --git a/arch/arm/boot/dts/am4372.dtsi b/arch/arm/boot/dts/am4372.dtsi</span>
<span class="p_header">index a275fa956813..a20a71d9d22e 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/am4372.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/am4372.dtsi</span>
<span class="p_chunk">@@ -16,6 +16,7 @@</span> <span class="p_context"></span>
 	interrupt-parent = &lt;&amp;wakeupgen&gt;;
 	#address-cells = &lt;1&gt;;
 	#size-cells = &lt;1&gt;;
<span class="p_add">+	chosen { };</span>
 
 	memory@0 {
 		device_type = &quot;memory&quot;;
<span class="p_header">diff --git a/arch/arm/boot/dts/bcm283x.dtsi b/arch/arm/boot/dts/bcm283x.dtsi</span>
<span class="p_header">index 46d46d894a44..74dd21b7373c 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/bcm283x.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/bcm283x.dtsi</span>
<span class="p_chunk">@@ -104,7 +104,7 @@</span> <span class="p_context"></span>
 			reg = &lt;0x7e104000 0x10&gt;;
 		};
 
<span class="p_del">-		mailbox: mailbox@7e00b800 {</span>
<span class="p_add">+		mailbox: mailbox@7e00b880 {</span>
 			compatible = &quot;brcm,bcm2835-mbox&quot;;
 			reg = &lt;0x7e00b880 0x40&gt;;
 			interrupts = &lt;0 1&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/da850-evm.dts b/arch/arm/boot/dts/da850-evm.dts</span>
<span class="p_header">index 41de15fe15a2..78492a0bbbab 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/da850-evm.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/da850-evm.dts</span>
<span class="p_chunk">@@ -99,6 +99,7 @@</span> <span class="p_context"></span>
 				#size-cells = &lt;1&gt;;
 				compatible = &quot;m25p64&quot;;
 				spi-max-frequency = &lt;30000000&gt;;
<span class="p_add">+				m25p,fast-read;</span>
 				reg = &lt;0&gt;;
 				partition@0 {
 					label = &quot;U-Boot-SPL&quot;;
<span class="p_header">diff --git a/arch/arm/boot/dts/dm814x.dtsi b/arch/arm/boot/dts/dm814x.dtsi</span>
<span class="p_header">index ff90a6ce6bdc..d87efab24fa2 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/dm814x.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/dm814x.dtsi</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"></span>
 	interrupt-parent = &lt;&amp;intc&gt;;
 	#address-cells = &lt;1&gt;;
 	#size-cells = &lt;1&gt;;
<span class="p_add">+	chosen { };</span>
 
 	aliases {
 		i2c0 = &amp;i2c1;
<span class="p_header">diff --git a/arch/arm/boot/dts/dm816x.dtsi b/arch/arm/boot/dts/dm816x.dtsi</span>
<span class="p_header">index f1e0f771ff29..cbdfbc4e4a26 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/dm816x.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/dm816x.dtsi</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"></span>
 	interrupt-parent = &lt;&amp;intc&gt;;
 	#address-cells = &lt;1&gt;;
 	#size-cells = &lt;1&gt;;
<span class="p_add">+	chosen { };</span>
 
 	aliases {
 		i2c0 = &amp;i2c1;
<span class="p_header">diff --git a/arch/arm/boot/dts/dra7.dtsi b/arch/arm/boot/dts/dra7.dtsi</span>
<span class="p_header">index d4fcd68f6349..064d84f87e45 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/dra7.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/dra7.dtsi</span>
<span class="p_chunk">@@ -18,6 +18,7 @@</span> <span class="p_context"></span>
 
 	compatible = &quot;ti,dra7xx&quot;;
 	interrupt-parent = &lt;&amp;crossbar_mpu&gt;;
<span class="p_add">+	chosen { };</span>
 
 	aliases {
 		i2c0 = &amp;i2c1;
<span class="p_chunk">@@ -1376,6 +1377,7 @@</span> <span class="p_context"></span>
 			phy-names = &quot;sata-phy&quot;;
 			clocks = &lt;&amp;sata_ref_clk&gt;;
 			ti,hwmods = &quot;sata&quot;;
<span class="p_add">+			ports-implemented = &lt;0x1&gt;;</span>
 		};
 
 		rtc: rtc@48838000 {
<span class="p_header">diff --git a/arch/arm/boot/dts/imx31.dtsi b/arch/arm/boot/dts/imx31.dtsi</span>
<span class="p_header">index 1ce7ae94e7ad..11e9e6bd8abb 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx31.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx31.dtsi</span>
<span class="p_chunk">@@ -30,11 +30,11 @@</span> <span class="p_context"></span>
 		};
 	};
 
<span class="p_del">-	avic: avic-interrupt-controller@60000000 {</span>
<span class="p_add">+	avic: interrupt-controller@68000000 {</span>
 		compatible = &quot;fsl,imx31-avic&quot;, &quot;fsl,avic&quot;;
 		interrupt-controller;
 		#interrupt-cells = &lt;1&gt;;
<span class="p_del">-		reg = &lt;0x60000000 0x100000&gt;;</span>
<span class="p_add">+		reg = &lt;0x68000000 0x100000&gt;;</span>
 	};
 
 	soc {
<span class="p_chunk">@@ -118,13 +118,6 @@</span> <span class="p_context"></span>
 				interrupts = &lt;19&gt;;
 				clocks = &lt;&amp;clks 25&gt;;
 			};
<span class="p_del">-</span>
<span class="p_del">-			clks: ccm@53f80000{</span>
<span class="p_del">-				compatible = &quot;fsl,imx31-ccm&quot;;</span>
<span class="p_del">-				reg = &lt;0x53f80000 0x4000&gt;;</span>
<span class="p_del">-				interrupts = &lt;0 31 0x04 0 53 0x04&gt;;</span>
<span class="p_del">-				#clock-cells = &lt;1&gt;;</span>
<span class="p_del">-			};</span>
 		};
 
 		aips@53f00000 { /* AIPS2 */
<span class="p_chunk">@@ -134,6 +127,13 @@</span> <span class="p_context"></span>
 			reg = &lt;0x53f00000 0x100000&gt;;
 			ranges;
 
<span class="p_add">+			clks: ccm@53f80000{</span>
<span class="p_add">+				compatible = &quot;fsl,imx31-ccm&quot;;</span>
<span class="p_add">+				reg = &lt;0x53f80000 0x4000&gt;;</span>
<span class="p_add">+				interrupts = &lt;31&gt;, &lt;53&gt;;</span>
<span class="p_add">+				#clock-cells = &lt;1&gt;;</span>
<span class="p_add">+			};</span>
<span class="p_add">+</span>
 			gpt: timer@53f90000 {
 				compatible = &quot;fsl,imx31-gpt&quot;;
 				reg = &lt;0x53f90000 0x4000&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6q-cm-fx6.dts b/arch/arm/boot/dts/imx6q-cm-fx6.dts</span>
<span class="p_header">index 59bc5a4dce17..a150bca84daa 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6q-cm-fx6.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6q-cm-fx6.dts</span>
<span class="p_chunk">@@ -183,7 +183,6 @@</span> <span class="p_context"></span>
 			MX6QDL_PAD_ENET_REF_CLK__ENET_TX_CLK	0x1b0b0
 			MX6QDL_PAD_ENET_MDIO__ENET_MDIO		0x1b0b0
 			MX6QDL_PAD_ENET_MDC__ENET_MDC		0x1b0b0
<span class="p_del">-			MX6QDL_PAD_GPIO_16__ENET_REF_CLK	0x4001b0a8</span>
 		&gt;;
 	};
 
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-nitrogen6_max.dtsi b/arch/arm/boot/dts/imx6qdl-nitrogen6_max.dtsi</span>
<span class="p_header">index b0b3220a1fd9..01166ba36f27 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-nitrogen6_max.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-nitrogen6_max.dtsi</span>
<span class="p_chunk">@@ -319,8 +319,6 @@</span> <span class="p_context"></span>
 		compatible = &quot;fsl,imx6q-nitrogen6_max-sgtl5000&quot;,
 			     &quot;fsl,imx-audio-sgtl5000&quot;;
 		model = &quot;imx6q-nitrogen6_max-sgtl5000&quot;;
<span class="p_del">-		pinctrl-names = &quot;default&quot;;</span>
<span class="p_del">-		pinctrl-0 = &lt;&amp;pinctrl_sgtl5000&gt;;</span>
 		ssi-controller = &lt;&amp;ssi1&gt;;
 		audio-codec = &lt;&amp;codec&gt;;
 		audio-routing =
<span class="p_chunk">@@ -402,6 +400,8 @@</span> <span class="p_context"></span>
 
 	codec: sgtl5000@0a {
 		compatible = &quot;fsl,sgtl5000&quot;;
<span class="p_add">+		pinctrl-names = &quot;default&quot;;</span>
<span class="p_add">+		pinctrl-0 = &lt;&amp;pinctrl_sgtl5000&gt;;</span>
 		reg = &lt;0x0a&gt;;
 		clocks = &lt;&amp;clks IMX6QDL_CLK_CKO&gt;;
 		VDDA-supply = &lt;&amp;reg_2p5v&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/logicpd-som-lv-37xx-devkit.dts b/arch/arm/boot/dts/logicpd-som-lv-37xx-devkit.dts</span>
<span class="p_header">index da8598402ab8..38faa90007d7 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/logicpd-som-lv-37xx-devkit.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/logicpd-som-lv-37xx-devkit.dts</span>
<span class="p_chunk">@@ -158,7 +158,7 @@</span> <span class="p_context"></span>
 &amp;mmc1 {
 	interrupts-extended = &lt;&amp;intc 83 &amp;omap3_pmx_core 0x11a&gt;;
 	pinctrl-names = &quot;default&quot;;
<span class="p_del">-	pinctrl-0 = &lt;&amp;mmc1_pins &amp;mmc1_cd&gt;;</span>
<span class="p_add">+	pinctrl-0 = &lt;&amp;mmc1_pins&gt;;</span>
 	wp-gpios = &lt;&amp;gpio4 30 GPIO_ACTIVE_HIGH&gt;;		/* gpio_126 */
 	cd-gpios = &lt;&amp;gpio4 14 IRQ_TYPE_LEVEL_LOW&gt;;		/* gpio_110 */
 	vmmc-supply = &lt;&amp;vmmc1&gt;;
<span class="p_chunk">@@ -193,7 +193,8 @@</span> <span class="p_context"></span>
 			OMAP3_CORE1_IOPAD(0x214a, PIN_INPUT | MUX_MODE0)	/* sdmmc1_dat1.sdmmc1_dat1 */
 			OMAP3_CORE1_IOPAD(0x214c, PIN_INPUT | MUX_MODE0)	/* sdmmc1_dat2.sdmmc1_dat2 */
 			OMAP3_CORE1_IOPAD(0x214e, PIN_INPUT | MUX_MODE0)	/* sdmmc1_dat3.sdmmc1_dat3 */
<span class="p_del">-			OMAP3_CORE1_IOPAD(0x2132, PIN_INPUT_PULLUP | MUX_MODE4)	/* cam_strobe.gpio_126 sdmmc1_wp*/</span>
<span class="p_add">+			OMAP3_CORE1_IOPAD(0x2132, PIN_INPUT_PULLUP | MUX_MODE4)	/* cam_strobe.gpio_126 */</span>
<span class="p_add">+			OMAP3_CORE1_IOPAD(0x212c, PIN_INPUT_PULLUP | MUX_MODE4)	/* cam_d11.gpio_110 */</span>
 		&gt;;
 	};
 
<span class="p_chunk">@@ -242,12 +243,6 @@</span> <span class="p_context"></span>
 			OMAP3_WKUP_IOPAD(0x2a16, PIN_OUTPUT | PIN_OFF_OUTPUT_LOW | MUX_MODE4)       /* sys_boot6.gpio_8 */
 		&gt;;
 	};
<span class="p_del">-</span>
<span class="p_del">-	mmc1_cd: pinmux_mmc1_cd {</span>
<span class="p_del">-		pinctrl-single,pins = &lt;</span>
<span class="p_del">-			OMAP3_WKUP_IOPAD(0x212c, PIN_INPUT_PULLUP | MUX_MODE4)	/* cam_d11.gpio_110 */</span>
<span class="p_del">-		&gt;;</span>
<span class="p_del">-	};</span>
 };
 
 
<span class="p_header">diff --git a/arch/arm/boot/dts/omap2.dtsi b/arch/arm/boot/dts/omap2.dtsi</span>
<span class="p_header">index 4f793a025a72..f1d6de8b3c19 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/omap2.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/omap2.dtsi</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
 	interrupt-parent = &lt;&amp;intc&gt;;
 	#address-cells = &lt;1&gt;;
 	#size-cells = &lt;1&gt;;
<span class="p_add">+	chosen { };</span>
 
 	aliases {
 		serial0 = &amp;uart1;
<span class="p_header">diff --git a/arch/arm/boot/dts/omap3.dtsi b/arch/arm/boot/dts/omap3.dtsi</span>
<span class="p_header">index 353d818ce5a6..2008648b8c9f 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/omap3.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/omap3.dtsi</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
 	interrupt-parent = &lt;&amp;intc&gt;;
 	#address-cells = &lt;1&gt;;
 	#size-cells = &lt;1&gt;;
<span class="p_add">+	chosen { };</span>
 
 	aliases {
 		i2c0 = &amp;i2c1;
<span class="p_header">diff --git a/arch/arm/boot/dts/omap4.dtsi b/arch/arm/boot/dts/omap4.dtsi</span>
<span class="p_header">index 0ced079b7ae3..9c289ddab3df 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/omap4.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/omap4.dtsi</span>
<span class="p_chunk">@@ -15,6 +15,7 @@</span> <span class="p_context"></span>
 	interrupt-parent = &lt;&amp;wakeupgen&gt;;
 	#address-cells = &lt;1&gt;;
 	#size-cells = &lt;1&gt;;
<span class="p_add">+	chosen { };</span>
 
 	aliases {
 		i2c0 = &amp;i2c1;
<span class="p_header">diff --git a/arch/arm/boot/dts/omap5.dtsi b/arch/arm/boot/dts/omap5.dtsi</span>
<span class="p_header">index 25262118ec3d..1d1d8e90cd80 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/omap5.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/omap5.dtsi</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
 
 	compatible = &quot;ti,omap5&quot;;
 	interrupt-parent = &lt;&amp;wakeupgen&gt;;
<span class="p_add">+	chosen { };</span>
 
 	aliases {
 		i2c0 = &amp;i2c1;
<span class="p_chunk">@@ -985,6 +986,7 @@</span> <span class="p_context"></span>
 			phy-names = &quot;sata-phy&quot;;
 			clocks = &lt;&amp;sata_ref_clk&gt;;
 			ti,hwmods = &quot;sata&quot;;
<span class="p_add">+			ports-implemented = &lt;0x1&gt;;</span>
 		};
 
 		dss: dss@58000000 {
<span class="p_header">diff --git a/arch/arm/boot/dts/r8a7794.dtsi b/arch/arm/boot/dts/r8a7794.dtsi</span>
<span class="p_header">index 725ecb3c5fb4..7e860d3737ff 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/r8a7794.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/r8a7794.dtsi</span>
<span class="p_chunk">@@ -319,7 +319,7 @@</span> <span class="p_context"></span>
 				  &quot;ch12&quot;;
 		clocks = &lt;&amp;mstp5_clks R8A7794_CLK_AUDIO_DMAC0&gt;;
 		clock-names = &quot;fck&quot;;
<span class="p_del">-		power-domains = &lt;&amp;cpg_clocks&gt;;</span>
<span class="p_add">+		power-domains = &lt;&amp;sysc R8A7794_PD_ALWAYS_ON&gt;;</span>
 		#dma-cells = &lt;1&gt;;
 		dma-channels = &lt;13&gt;;
 	};
<span class="p_chunk">@@ -1025,8 +1025,7 @@</span> <span class="p_context"></span>
 			clocks = &lt;&amp;extal_clk &amp;usb_extal_clk&gt;;
 			#clock-cells = &lt;1&gt;;
 			clock-output-names = &quot;main&quot;, &quot;pll0&quot;, &quot;pll1&quot;, &quot;pll3&quot;,
<span class="p_del">-					     &quot;lb&quot;, &quot;qspi&quot;, &quot;sdh&quot;, &quot;sd0&quot;, &quot;z&quot;,</span>
<span class="p_del">-					     &quot;rcan&quot;;</span>
<span class="p_add">+					     &quot;lb&quot;, &quot;qspi&quot;, &quot;sdh&quot;, &quot;sd0&quot;, &quot;rcan&quot;;</span>
 			#power-domain-cells = &lt;0&gt;;
 		};
 		/* Variable factor clocks */
<span class="p_chunk">@@ -1483,7 +1482,7 @@</span> <span class="p_context"></span>
 			      &quot;mix.0&quot;, &quot;mix.1&quot;,
 			      &quot;dvc.0&quot;, &quot;dvc.1&quot;,
 			      &quot;clk_a&quot;, &quot;clk_b&quot;, &quot;clk_c&quot;, &quot;clk_i&quot;;
<span class="p_del">-		power-domains = &lt;&amp;cpg_clocks&gt;;</span>
<span class="p_add">+		power-domains = &lt;&amp;sysc R8A7794_PD_ALWAYS_ON&gt;;</span>
 
 		status = &quot;disabled&quot;;
 
<span class="p_header">diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h</span>
<span class="p_header">index 522b5feb4eaa..b62eaeb147aa 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/cputype.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/cputype.h</span>
<span class="p_chunk">@@ -94,6 +94,9 @@</span> <span class="p_context"></span>
 #define ARM_CPU_XSCALE_ARCH_V2		0x4000
 #define ARM_CPU_XSCALE_ARCH_V3		0x6000
 
<span class="p_add">+/* Qualcomm implemented cores */</span>
<span class="p_add">+#define ARM_CPU_PART_SCORPION		0x510002d0</span>
<span class="p_add">+</span>
 extern unsigned int processor_id;
 
 #ifdef CONFIG_CPU_CP15
<span class="p_header">diff --git a/arch/arm/kernel/hw_breakpoint.c b/arch/arm/kernel/hw_breakpoint.c</span>
<span class="p_header">index b8df45883cf7..25538a935874 100644</span>
<span class="p_header">--- a/arch/arm/kernel/hw_breakpoint.c</span>
<span class="p_header">+++ b/arch/arm/kernel/hw_breakpoint.c</span>
<span class="p_chunk">@@ -1066,6 +1066,22 @@</span> <span class="p_context"> static int __init arch_hw_breakpoint_init(void)</span>
 		return 0;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Scorpion CPUs (at least those in APQ8060) seem to set DBGPRSR.SPD</span>
<span class="p_add">+	 * whenever a WFI is issued, even if the core is not powered down, in</span>
<span class="p_add">+	 * violation of the architecture.  When DBGPRSR.SPD is set, accesses to</span>
<span class="p_add">+	 * breakpoint and watchpoint registers are treated as undefined, so</span>
<span class="p_add">+	 * this results in boot time and runtime failures when these are</span>
<span class="p_add">+	 * accessed and we unexpectedly take a trap.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * It&#39;s not clear if/how this can be worked around, so we blacklist</span>
<span class="p_add">+	 * Scorpion CPUs to avoid these issues.</span>
<span class="p_add">+	*/</span>
<span class="p_add">+	if (read_cpuid_part() == ARM_CPU_PART_SCORPION) {</span>
<span class="p_add">+		pr_info(&quot;Scorpion CPU detected. Hardware breakpoints and watchpoints disabled\n&quot;);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	has_ossr = core_has_os_save_restore();
 
 	/* Determine how many BRPs/WRPs are available. */
<span class="p_header">diff --git a/arch/arm/kernel/smp_tlb.c b/arch/arm/kernel/smp_tlb.c</span>
<span class="p_header">index 22313cb53362..9af0701f7094 100644</span>
<span class="p_header">--- a/arch/arm/kernel/smp_tlb.c</span>
<span class="p_header">+++ b/arch/arm/kernel/smp_tlb.c</span>
<span class="p_chunk">@@ -9,6 +9,7 @@</span> <span class="p_context"></span>
  */
 #include &lt;linux/preempt.h&gt;
 #include &lt;linux/smp.h&gt;
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 
 #include &lt;asm/smp_plat.h&gt;
 #include &lt;asm/tlbflush.h&gt;
<span class="p_chunk">@@ -40,8 +41,11 @@</span> <span class="p_context"> static inline void ipi_flush_tlb_mm(void *arg)</span>
 static inline void ipi_flush_tlb_page(void *arg)
 {
 	struct tlb_args *ta = (struct tlb_args *)arg;
<span class="p_add">+	unsigned int __ua_flags = uaccess_save_and_enable();</span>
 
 	local_flush_tlb_page(ta-&gt;ta_vma, ta-&gt;ta_start);
<span class="p_add">+</span>
<span class="p_add">+	uaccess_restore(__ua_flags);</span>
 }
 
 static inline void ipi_flush_tlb_kernel_page(void *arg)
<span class="p_chunk">@@ -54,8 +58,11 @@</span> <span class="p_context"> static inline void ipi_flush_tlb_kernel_page(void *arg)</span>
 static inline void ipi_flush_tlb_range(void *arg)
 {
 	struct tlb_args *ta = (struct tlb_args *)arg;
<span class="p_add">+	unsigned int __ua_flags = uaccess_save_and_enable();</span>
 
 	local_flush_tlb_range(ta-&gt;ta_vma, ta-&gt;ta_start, ta-&gt;ta_end);
<span class="p_add">+</span>
<span class="p_add">+	uaccess_restore(__ua_flags);</span>
 }
 
 static inline void ipi_flush_tlb_kernel_range(void *arg)
<span class="p_header">diff --git a/arch/arm/mach-ux500/pm.c b/arch/arm/mach-ux500/pm.c</span>
<span class="p_header">index 8538910db202..a970e7fcba9e 100644</span>
<span class="p_header">--- a/arch/arm/mach-ux500/pm.c</span>
<span class="p_header">+++ b/arch/arm/mach-ux500/pm.c</span>
<span class="p_chunk">@@ -134,8 +134,8 @@</span> <span class="p_context"> bool prcmu_pending_irq(void)</span>
  */
 bool prcmu_is_cpu_in_wfi(int cpu)
 {
<span class="p_del">-	return readl(PRCM_ARM_WFI_STANDBY) &amp; cpu ? PRCM_ARM_WFI_STANDBY_WFI1 :</span>
<span class="p_del">-		     PRCM_ARM_WFI_STANDBY_WFI0;</span>
<span class="p_add">+	return readl(PRCM_ARM_WFI_STANDBY) &amp;</span>
<span class="p_add">+		(cpu ? PRCM_ARM_WFI_STANDBY_WFI1 : PRCM_ARM_WFI_STANDBY_WFI0);</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/arm64/include/asm/memory.h b/arch/arm64/include/asm/memory.h</span>
<span class="p_header">index b71086d25195..53211a0acf0f 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/memory.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/memory.h</span>
<span class="p_chunk">@@ -217,7 +217,7 @@</span> <span class="p_context"> static inline void *phys_to_virt(phys_addr_t x)</span>
 #define _virt_addr_valid(kaddr)	pfn_valid(__pa(kaddr) &gt;&gt; PAGE_SHIFT)
 #else
 #define __virt_to_pgoff(kaddr)	(((u64)(kaddr) &amp; ~PAGE_OFFSET) / PAGE_SIZE * sizeof(struct page))
<span class="p_del">-#define __page_to_voff(page)	(((u64)(page) &amp; ~VMEMMAP_START) * PAGE_SIZE / sizeof(struct page))</span>
<span class="p_add">+#define __page_to_voff(kaddr)	(((u64)(kaddr) &amp; ~VMEMMAP_START) * PAGE_SIZE / sizeof(struct page))</span>
 
 #define page_to_virt(page)	((void *)((__page_to_voff(page)) | PAGE_OFFSET))
 #define virt_to_page(vaddr)	((struct page *)((__virt_to_pgoff(vaddr)) | VMEMMAP_START))
<span class="p_header">diff --git a/arch/arm64/include/uapi/asm/ptrace.h b/arch/arm64/include/uapi/asm/ptrace.h</span>
<span class="p_header">index b5c3933ed441..d1ff83dfe5de 100644</span>
<span class="p_header">--- a/arch/arm64/include/uapi/asm/ptrace.h</span>
<span class="p_header">+++ b/arch/arm64/include/uapi/asm/ptrace.h</span>
<span class="p_chunk">@@ -77,6 +77,7 @@</span> <span class="p_context"> struct user_fpsimd_state {</span>
 	__uint128_t	vregs[32];
 	__u32		fpsr;
 	__u32		fpcr;
<span class="p_add">+	__u32		__reserved[2];</span>
 };
 
 struct user_hwdebug_state {
<span class="p_header">diff --git a/arch/arm64/kernel/entry.S b/arch/arm64/kernel/entry.S</span>
<span class="p_header">index 223d54a4d66b..79b0fe24d5b7 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/entry.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/entry.S</span>
<span class="p_chunk">@@ -624,7 +624,7 @@</span> <span class="p_context"> el0_inv:</span>
 	mov	x0, sp
 	mov	x1, #BAD_SYNC
 	mov	x2, x25
<span class="p_del">-	bl	bad_mode</span>
<span class="p_add">+	bl	bad_el0_sync</span>
 	b	ret_to_user
 ENDPROC(el0_sync)
 
<span class="p_header">diff --git a/arch/arm64/kernel/ptrace.c b/arch/arm64/kernel/ptrace.c</span>
<span class="p_header">index e0c81da60f76..8eedeef375d6 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/ptrace.c</span>
<span class="p_chunk">@@ -550,6 +550,8 @@</span> <span class="p_context"> static int hw_break_set(struct task_struct *target,</span>
 	/* (address, ctrl) registers */
 	limit = regset-&gt;n * regset-&gt;size;
 	while (count &amp;&amp; offset &lt; limit) {
<span class="p_add">+		if (count &lt; PTRACE_HBP_ADDR_SZ)</span>
<span class="p_add">+			return -EINVAL;</span>
 		ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;addr,
 					 offset, offset + PTRACE_HBP_ADDR_SZ);
 		if (ret)
<span class="p_chunk">@@ -559,6 +561,8 @@</span> <span class="p_context"> static int hw_break_set(struct task_struct *target,</span>
 			return ret;
 		offset += PTRACE_HBP_ADDR_SZ;
 
<span class="p_add">+		if (!count)</span>
<span class="p_add">+			break;</span>
 		ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;ctrl,
 					 offset, offset + PTRACE_HBP_CTRL_SZ);
 		if (ret)
<span class="p_chunk">@@ -595,7 +599,7 @@</span> <span class="p_context"> static int gpr_set(struct task_struct *target, const struct user_regset *regset,</span>
 		   const void *kbuf, const void __user *ubuf)
 {
 	int ret;
<span class="p_del">-	struct user_pt_regs newregs;</span>
<span class="p_add">+	struct user_pt_regs newregs = task_pt_regs(target)-&gt;user_regs;</span>
 
 	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;newregs, 0, -1);
 	if (ret)
<span class="p_chunk">@@ -625,7 +629,8 @@</span> <span class="p_context"> static int fpr_set(struct task_struct *target, const struct user_regset *regset,</span>
 		   const void *kbuf, const void __user *ubuf)
 {
 	int ret;
<span class="p_del">-	struct user_fpsimd_state newstate;</span>
<span class="p_add">+	struct user_fpsimd_state newstate =</span>
<span class="p_add">+		target-&gt;thread.fpsimd_state.user_fpsimd;</span>
 
 	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;newstate, 0, -1);
 	if (ret)
<span class="p_chunk">@@ -649,7 +654,7 @@</span> <span class="p_context"> static int tls_set(struct task_struct *target, const struct user_regset *regset,</span>
 		   const void *kbuf, const void __user *ubuf)
 {
 	int ret;
<span class="p_del">-	unsigned long tls;</span>
<span class="p_add">+	unsigned long tls = target-&gt;thread.tp_value;</span>
 
 	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;tls, 0, -1);
 	if (ret)
<span class="p_chunk">@@ -675,7 +680,8 @@</span> <span class="p_context"> static int system_call_set(struct task_struct *target,</span>
 			   unsigned int pos, unsigned int count,
 			   const void *kbuf, const void __user *ubuf)
 {
<span class="p_del">-	int syscallno, ret;</span>
<span class="p_add">+	int syscallno = task_pt_regs(target)-&gt;syscallno;</span>
<span class="p_add">+	int ret;</span>
 
 	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;syscallno, 0, -1);
 	if (ret)
<span class="p_chunk">@@ -947,7 +953,7 @@</span> <span class="p_context"> static int compat_tls_set(struct task_struct *target,</span>
 			  const void __user *ubuf)
 {
 	int ret;
<span class="p_del">-	compat_ulong_t tls;</span>
<span class="p_add">+	compat_ulong_t tls = target-&gt;thread.tp_value;</span>
 
 	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;tls, 0, -1);
 	if (ret)
<span class="p_header">diff --git a/arch/arm64/kernel/traps.c b/arch/arm64/kernel/traps.c</span>
<span class="p_header">index c9986b3e0a96..11e5eae088ab 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/traps.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/traps.c</span>
<span class="p_chunk">@@ -596,17 +596,34 @@</span> <span class="p_context"> const char *esr_get_class_string(u32 esr)</span>
 }
 
 /*
<span class="p_del">- * bad_mode handles the impossible case in the exception vector.</span>
<span class="p_add">+ * bad_mode handles the impossible case in the exception vector. This is always</span>
<span class="p_add">+ * fatal.</span>
  */
 asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)
 {
<span class="p_del">-	siginfo_t info;</span>
<span class="p_del">-	void __user *pc = (void __user *)instruction_pointer(regs);</span>
 	console_verbose();
 
 	pr_crit(&quot;Bad mode in %s handler detected on CPU%d, code 0x%08x -- %s\n&quot;,
 		handler[reason], smp_processor_id(), esr,
 		esr_get_class_string(esr));
<span class="p_add">+</span>
<span class="p_add">+	die(&quot;Oops - bad mode&quot;, regs, 0);</span>
<span class="p_add">+	local_irq_disable();</span>
<span class="p_add">+	panic(&quot;bad mode&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * bad_el0_sync handles unexpected, but potentially recoverable synchronous</span>
<span class="p_add">+ * exceptions taken from EL0. Unlike bad_mode, this returns.</span>
<span class="p_add">+ */</span>
<span class="p_add">+asmlinkage void bad_el0_sync(struct pt_regs *regs, int reason, unsigned int esr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	siginfo_t info;</span>
<span class="p_add">+	void __user *pc = (void __user *)instruction_pointer(regs);</span>
<span class="p_add">+	console_verbose();</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_crit(&quot;Bad EL0 synchronous exception detected on CPU%d, code 0x%08x -- %s\n&quot;,</span>
<span class="p_add">+		smp_processor_id(), esr, esr_get_class_string(esr));</span>
 	__show_regs(regs);
 
 	info.si_signo = SIGILL;
<span class="p_chunk">@@ -614,7 +631,10 @@</span> <span class="p_context"> asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)</span>
 	info.si_code  = ILL_ILLOPC;
 	info.si_addr  = pc;
 
<span class="p_del">-	arm64_notify_die(&quot;Oops - bad mode&quot;, regs, &amp;info, 0);</span>
<span class="p_add">+	current-&gt;thread.fault_address = 0;</span>
<span class="p_add">+	current-&gt;thread.fault_code = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	force_sig_info(info.si_signo, &amp;info, current);</span>
 }
 
 void __pte_error(const char *file, int line, unsigned long val)
<span class="p_header">diff --git a/arch/arm64/mm/dma-mapping.c b/arch/arm64/mm/dma-mapping.c</span>
<span class="p_header">index 3f74d0d98de6..02265a589ef5 100644</span>
<span class="p_header">--- a/arch/arm64/mm/dma-mapping.c</span>
<span class="p_header">+++ b/arch/arm64/mm/dma-mapping.c</span>
<span class="p_chunk">@@ -524,7 +524,8 @@</span> <span class="p_context"> EXPORT_SYMBOL(dummy_dma_ops);</span>
 
 static int __init arm64_dma_init(void)
 {
<span class="p_del">-	if (swiotlb_force || max_pfn &gt; (arm64_dma_phys_limit &gt;&gt; PAGE_SHIFT))</span>
<span class="p_add">+	if (swiotlb_force == SWIOTLB_FORCE ||</span>
<span class="p_add">+	    max_pfn &gt; (arm64_dma_phys_limit &gt;&gt; PAGE_SHIFT))</span>
 		swiotlb = 1;
 
 	return atomic_pool_init();
<span class="p_header">diff --git a/arch/arm64/mm/init.c b/arch/arm64/mm/init.c</span>
<span class="p_header">index 212c4d1e2f26..380ebe705093 100644</span>
<span class="p_header">--- a/arch/arm64/mm/init.c</span>
<span class="p_header">+++ b/arch/arm64/mm/init.c</span>
<span class="p_chunk">@@ -401,8 +401,11 @@</span> <span class="p_context"> static void __init free_unused_memmap(void)</span>
  */
 void __init mem_init(void)
 {
<span class="p_del">-	if (swiotlb_force || max_pfn &gt; (arm64_dma_phys_limit &gt;&gt; PAGE_SHIFT))</span>
<span class="p_add">+	if (swiotlb_force == SWIOTLB_FORCE ||</span>
<span class="p_add">+	    max_pfn &gt; (arm64_dma_phys_limit &gt;&gt; PAGE_SHIFT))</span>
 		swiotlb_init(1);
<span class="p_add">+	else</span>
<span class="p_add">+		swiotlb_force = SWIOTLB_NO_FORCE;</span>
 
 	set_max_mapnr(pfn_to_page(max_pfn) - mem_map);
 
<span class="p_header">diff --git a/arch/powerpc/include/asm/ppc-opcode.h b/arch/powerpc/include/asm/ppc-opcode.h</span>
<span class="p_header">index c56ea8c84abb..c4ced1d01d57 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/ppc-opcode.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/ppc-opcode.h</span>
<span class="p_chunk">@@ -157,7 +157,7 @@</span> <span class="p_context"></span>
 #define PPC_INST_MCRXR			0x7c000400
 #define PPC_INST_MCRXR_MASK		0xfc0007fe
 #define PPC_INST_MFSPR_PVR		0x7c1f42a6
<span class="p_del">-#define PPC_INST_MFSPR_PVR_MASK		0xfc1fffff</span>
<span class="p_add">+#define PPC_INST_MFSPR_PVR_MASK		0xfc1ffffe</span>
 #define PPC_INST_MFTMR			0x7c0002dc
 #define PPC_INST_MSGSND			0x7c00019c
 #define PPC_INST_MSGCLR			0x7c0001dc
<span class="p_chunk">@@ -174,13 +174,13 @@</span> <span class="p_context"></span>
 #define PPC_INST_RFDI			0x4c00004e
 #define PPC_INST_RFMCI			0x4c00004c
 #define PPC_INST_MFSPR_DSCR		0x7c1102a6
<span class="p_del">-#define PPC_INST_MFSPR_DSCR_MASK	0xfc1fffff</span>
<span class="p_add">+#define PPC_INST_MFSPR_DSCR_MASK	0xfc1ffffe</span>
 #define PPC_INST_MTSPR_DSCR		0x7c1103a6
<span class="p_del">-#define PPC_INST_MTSPR_DSCR_MASK	0xfc1fffff</span>
<span class="p_add">+#define PPC_INST_MTSPR_DSCR_MASK	0xfc1ffffe</span>
 #define PPC_INST_MFSPR_DSCR_USER	0x7c0302a6
<span class="p_del">-#define PPC_INST_MFSPR_DSCR_USER_MASK	0xfc1fffff</span>
<span class="p_add">+#define PPC_INST_MFSPR_DSCR_USER_MASK	0xfc1ffffe</span>
 #define PPC_INST_MTSPR_DSCR_USER	0x7c0303a6
<span class="p_del">-#define PPC_INST_MTSPR_DSCR_USER_MASK	0xfc1fffff</span>
<span class="p_add">+#define PPC_INST_MTSPR_DSCR_USER_MASK	0xfc1ffffe</span>
 #define PPC_INST_MFVSRD			0x7c000066
 #define PPC_INST_MTVSRD			0x7c000166
 #define PPC_INST_SLBFEE			0x7c0007a7
<span class="p_header">diff --git a/arch/powerpc/kernel/ptrace.c b/arch/powerpc/kernel/ptrace.c</span>
<span class="p_header">index b1ec62f2cc31..5c8f12fe9721 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/ptrace.c</span>
<span class="p_chunk">@@ -463,6 +463,10 @@</span> <span class="p_context"> static int fpr_set(struct task_struct *target, const struct user_regset *regset,</span>
 
 	flush_fp_to_thread(target);
 
<span class="p_add">+	for (i = 0; i &lt; 32 ; i++)</span>
<span class="p_add">+		buf[i] = target-&gt;thread.TS_FPR(i);</span>
<span class="p_add">+	buf[32] = target-&gt;thread.fp_state.fpscr;</span>
<span class="p_add">+</span>
 	/* copy to local buffer then write that out */
 	i = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, buf, 0, -1);
 	if (i)
<span class="p_chunk">@@ -672,6 +676,9 @@</span> <span class="p_context"> static int vsr_set(struct task_struct *target, const struct user_regset *regset,</span>
 	flush_altivec_to_thread(target);
 	flush_vsx_to_thread(target);
 
<span class="p_add">+	for (i = 0; i &lt; 32 ; i++)</span>
<span class="p_add">+		buf[i] = target-&gt;thread.fp_state.fpr[i][TS_VSRLOWOFFSET];</span>
<span class="p_add">+</span>
 	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf,
 				 buf, 0, 32 * sizeof(double));
 	if (!ret)
<span class="p_chunk">@@ -1019,6 +1026,10 @@</span> <span class="p_context"> static int tm_cfpr_set(struct task_struct *target,</span>
 	flush_fp_to_thread(target);
 	flush_altivec_to_thread(target);
 
<span class="p_add">+	for (i = 0; i &lt; 32; i++)</span>
<span class="p_add">+		buf[i] = target-&gt;thread.TS_CKFPR(i);</span>
<span class="p_add">+	buf[32] = target-&gt;thread.ckfp_state.fpscr;</span>
<span class="p_add">+</span>
 	/* copy to local buffer then write that out */
 	i = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, buf, 0, -1);
 	if (i)
<span class="p_chunk">@@ -1283,6 +1294,9 @@</span> <span class="p_context"> static int tm_cvsx_set(struct task_struct *target,</span>
 	flush_altivec_to_thread(target);
 	flush_vsx_to_thread(target);
 
<span class="p_add">+	for (i = 0; i &lt; 32 ; i++)</span>
<span class="p_add">+		buf[i] = target-&gt;thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET];</span>
<span class="p_add">+</span>
 	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf,
 				 buf, 0, 32 * sizeof(double));
 	if (!ret)
<span class="p_header">diff --git a/arch/powerpc/perf/power9-events-list.h b/arch/powerpc/perf/power9-events-list.h</span>
<span class="p_header">index 6447dc1c3d89..929b56d47ad9 100644</span>
<span class="p_header">--- a/arch/powerpc/perf/power9-events-list.h</span>
<span class="p_header">+++ b/arch/powerpc/perf/power9-events-list.h</span>
<span class="p_chunk">@@ -16,7 +16,7 @@</span> <span class="p_context"> EVENT(PM_CYC,					0x0001e)</span>
 EVENT(PM_ICT_NOSLOT_CYC,			0x100f8)
 EVENT(PM_CMPLU_STALL,				0x1e054)
 EVENT(PM_INST_CMPL,				0x00002)
<span class="p_del">-EVENT(PM_BRU_CMPL,				0x40060)</span>
<span class="p_add">+EVENT(PM_BRU_CMPL,				0x10012)</span>
 EVENT(PM_BR_MPRED_CMPL,				0x400f6)
 
 /* All L1 D cache load references counted at finish, gated by reject */
<span class="p_header">diff --git a/arch/powerpc/sysdev/xics/icp-opal.c b/arch/powerpc/sysdev/xics/icp-opal.c</span>
<span class="p_header">index d38e86fd5720..60c57657c772 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/xics/icp-opal.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/xics/icp-opal.c</span>
<span class="p_chunk">@@ -20,6 +20,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/xics.h&gt;
 #include &lt;asm/io.h&gt;
 #include &lt;asm/opal.h&gt;
<span class="p_add">+#include &lt;asm/kvm_ppc.h&gt;</span>
 
 static void icp_opal_teardown_cpu(void)
 {
<span class="p_chunk">@@ -39,7 +40,26 @@</span> <span class="p_context"> static void icp_opal_flush_ipi(void)</span>
 	 * Should we be flagging idle loop instead?
 	 * Or creating some task to be scheduled?
 	 */
<span class="p_del">-	opal_int_eoi((0x00 &lt;&lt; 24) | XICS_IPI);</span>
<span class="p_add">+	if (opal_int_eoi((0x00 &lt;&lt; 24) | XICS_IPI) &gt; 0)</span>
<span class="p_add">+		force_external_irq_replay();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned int icp_opal_get_xirr(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int kvm_xirr;</span>
<span class="p_add">+	__be32 hw_xirr;</span>
<span class="p_add">+	int64_t rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Handle an interrupt latched by KVM first */</span>
<span class="p_add">+	kvm_xirr = kvmppc_get_xics_latch();</span>
<span class="p_add">+	if (kvm_xirr)</span>
<span class="p_add">+		return kvm_xirr;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Then ask OPAL */</span>
<span class="p_add">+	rc = opal_int_get_xirr(&amp;hw_xirr, false);</span>
<span class="p_add">+	if (rc &lt; 0)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	return be32_to_cpu(hw_xirr);</span>
 }
 
 static unsigned int icp_opal_get_irq(void)
<span class="p_chunk">@@ -47,12 +67,8 @@</span> <span class="p_context"> static unsigned int icp_opal_get_irq(void)</span>
 	unsigned int xirr;
 	unsigned int vec;
 	unsigned int irq;
<span class="p_del">-	int64_t rc;</span>
 
<span class="p_del">-	rc = opal_int_get_xirr(&amp;xirr, false);</span>
<span class="p_del">-	if (rc &lt; 0)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	xirr = be32_to_cpu(xirr);</span>
<span class="p_add">+	xirr = icp_opal_get_xirr();</span>
 	vec = xirr &amp; 0x00ffffff;
 	if (vec == XICS_IRQ_SPURIOUS)
 		return 0;
<span class="p_chunk">@@ -67,7 +83,8 @@</span> <span class="p_context"> static unsigned int icp_opal_get_irq(void)</span>
 	xics_mask_unknown_vec(vec);
 
 	/* We might learn about it later, so EOI it */
<span class="p_del">-	opal_int_eoi(xirr);</span>
<span class="p_add">+	if (opal_int_eoi(xirr) &gt; 0)</span>
<span class="p_add">+		force_external_irq_replay();</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/arch/s390/kvm/kvm-s390.c b/arch/s390/kvm/kvm-s390.c</span>
<span class="p_header">index 9c7a1ecfe6bd..47a1de77b18d 100644</span>
<span class="p_header">--- a/arch/s390/kvm/kvm-s390.c</span>
<span class="p_header">+++ b/arch/s390/kvm/kvm-s390.c</span>
<span class="p_chunk">@@ -916,7 +916,7 @@</span> <span class="p_context"> static int kvm_s390_get_machine(struct kvm *kvm, struct kvm_device_attr *attr)</span>
 	memcpy(&amp;mach-&gt;fac_mask, kvm-&gt;arch.model.fac_mask,
 	       S390_ARCH_FAC_LIST_SIZE_BYTE);
 	memcpy((unsigned long *)&amp;mach-&gt;fac_list, S390_lowcore.stfle_fac_list,
<span class="p_del">-	       S390_ARCH_FAC_LIST_SIZE_BYTE);</span>
<span class="p_add">+	       sizeof(S390_lowcore.stfle_fac_list));</span>
 	if (copy_to_user((void __user *)attr-&gt;addr, mach, sizeof(*mach)))
 		ret = -EFAULT;
 	kfree(mach);
<span class="p_chunk">@@ -1437,7 +1437,7 @@</span> <span class="p_context"> int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)</span>
 
 	/* Populate the facility mask initially. */
 	memcpy(kvm-&gt;arch.model.fac_mask, S390_lowcore.stfle_fac_list,
<span class="p_del">-	       S390_ARCH_FAC_LIST_SIZE_BYTE);</span>
<span class="p_add">+	       sizeof(S390_lowcore.stfle_fac_list));</span>
 	for (i = 0; i &lt; S390_ARCH_FAC_LIST_SIZE_U64; i++) {
 		if (i &lt; kvm_s390_fac_list_mask_size())
 			kvm-&gt;arch.model.fac_mask[i] &amp;= kvm_s390_fac_list_mask[i];
<span class="p_header">diff --git a/arch/x86/kernel/apic/io_apic.c b/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_header">index 48e6d84f173e..3d8ff40ecc6f 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_chunk">@@ -1876,6 +1876,7 @@</span> <span class="p_context"> static struct irq_chip ioapic_chip __read_mostly = {</span>
 	.irq_ack		= irq_chip_ack_parent,
 	.irq_eoi		= ioapic_ack_level,
 	.irq_set_affinity	= ioapic_set_affinity,
<span class="p_add">+	.irq_retrigger		= irq_chip_retrigger_hierarchy,</span>
 	.flags			= IRQCHIP_SKIP_SET_WAKE,
 };
 
<span class="p_chunk">@@ -1887,6 +1888,7 @@</span> <span class="p_context"> static struct irq_chip ioapic_ir_chip __read_mostly = {</span>
 	.irq_ack		= irq_chip_ack_parent,
 	.irq_eoi		= ioapic_ir_ack_level,
 	.irq_set_affinity	= ioapic_set_affinity,
<span class="p_add">+	.irq_retrigger		= irq_chip_retrigger_hierarchy,</span>
 	.flags			= IRQCHIP_SKIP_SET_WAKE,
 };
 
<span class="p_header">diff --git a/arch/x86/kernel/pci-swiotlb.c b/arch/x86/kernel/pci-swiotlb.c</span>
<span class="p_header">index b47edb8f5256..8da13d4e77cc 100644</span>
<span class="p_header">--- a/arch/x86/kernel/pci-swiotlb.c</span>
<span class="p_header">+++ b/arch/x86/kernel/pci-swiotlb.c</span>
<span class="p_chunk">@@ -70,7 +70,7 @@</span> <span class="p_context"> int __init pci_swiotlb_detect_override(void)</span>
 {
 	int use_swiotlb = swiotlb | swiotlb_force;
 
<span class="p_del">-	if (swiotlb_force)</span>
<span class="p_add">+	if (swiotlb_force == SWIOTLB_FORCE)</span>
 		swiotlb = 1;
 
 	return use_swiotlb;
<span class="p_header">diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c</span>
<span class="p_header">index 3cd69832d7f4..3961103e9176 100644</span>
<span class="p_header">--- a/arch/x86/pci/acpi.c</span>
<span class="p_header">+++ b/arch/x86/pci/acpi.c</span>
<span class="p_chunk">@@ -114,6 +114,16 @@</span> <span class="p_context"> static const struct dmi_system_id pci_crs_quirks[] __initconst = {</span>
 			DMI_MATCH(DMI_BIOS_VERSION, &quot;6JET85WW (1.43 )&quot;),
 		},
 	},
<span class="p_add">+	/* https://bugzilla.kernel.org/show_bug.cgi?id=42606 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = set_nouse_crs,</span>
<span class="p_add">+		.ident = &quot;Supermicro X8DTH&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Supermicro&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;X8DTH-i/6/iF/6F&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_BIOS_VERSION, &quot;2.0a&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 
 	/* https://bugzilla.kernel.org/show_bug.cgi?id=15362 */
 	{
<span class="p_header">diff --git a/arch/x86/xen/pci-swiotlb-xen.c b/arch/x86/xen/pci-swiotlb-xen.c</span>
<span class="p_header">index 0e98e5d241d0..5f8b4b0302b6 100644</span>
<span class="p_header">--- a/arch/x86/xen/pci-swiotlb-xen.c</span>
<span class="p_header">+++ b/arch/x86/xen/pci-swiotlb-xen.c</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> int __init pci_xen_swiotlb_detect(void)</span>
 	 * activate this IOMMU. If running as PV privileged, activate it
 	 * irregardless.
 	 */
<span class="p_del">-	if ((xen_initial_domain() || swiotlb || swiotlb_force))</span>
<span class="p_add">+	if (xen_initial_domain() || swiotlb || swiotlb_force == SWIOTLB_FORCE)</span>
 		xen_swiotlb = 1;
 
 	/* If we are running under Xen, we MUST disable the native SWIOTLB.
<span class="p_header">diff --git a/drivers/clocksource/exynos_mct.c b/drivers/clocksource/exynos_mct.c</span>
<span class="p_header">index 8f3488b80896..7f6fed9f0703 100644</span>
<span class="p_header">--- a/drivers/clocksource/exynos_mct.c</span>
<span class="p_header">+++ b/drivers/clocksource/exynos_mct.c</span>
<span class="p_chunk">@@ -495,6 +495,7 @@</span> <span class="p_context"> static int exynos4_mct_dying_cpu(unsigned int cpu)</span>
 	if (mct_int_type == MCT_INT_SPI) {
 		if (evt-&gt;irq != -1)
 			disable_irq_nosync(evt-&gt;irq);
<span class="p_add">+		exynos4_mct_write(0x1, mevt-&gt;base + MCT_L_INT_CSTAT_OFFSET);</span>
 	} else {
 		disable_percpu_irq(mct_irqs[MCT_L0_IRQ]);
 	}
<span class="p_header">diff --git a/drivers/devfreq/devfreq.c b/drivers/devfreq/devfreq.c</span>
<span class="p_header">index bf3ea7603a58..712592cef1a2 100644</span>
<span class="p_header">--- a/drivers/devfreq/devfreq.c</span>
<span class="p_header">+++ b/drivers/devfreq/devfreq.c</span>
<span class="p_chunk">@@ -593,11 +593,16 @@</span> <span class="p_context"> struct devfreq *devfreq_add_device(struct device *dev,</span>
 	list_add(&amp;devfreq-&gt;node, &amp;devfreq_list);
 
 	governor = find_devfreq_governor(devfreq-&gt;governor_name);
<span class="p_del">-	if (!IS_ERR(governor))</span>
<span class="p_del">-		devfreq-&gt;governor = governor;</span>
<span class="p_del">-	if (devfreq-&gt;governor)</span>
<span class="p_del">-		err = devfreq-&gt;governor-&gt;event_handler(devfreq,</span>
<span class="p_del">-					DEVFREQ_GOV_START, NULL);</span>
<span class="p_add">+	if (IS_ERR(governor)) {</span>
<span class="p_add">+		dev_err(dev, &quot;%s: Unable to find governor for the device\n&quot;,</span>
<span class="p_add">+			__func__);</span>
<span class="p_add">+		err = PTR_ERR(governor);</span>
<span class="p_add">+		goto err_init;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	devfreq-&gt;governor = governor;</span>
<span class="p_add">+	err = devfreq-&gt;governor-&gt;event_handler(devfreq, DEVFREQ_GOV_START,</span>
<span class="p_add">+						NULL);</span>
 	if (err) {
 		dev_err(dev, &quot;%s: Unable to start governor for the device\n&quot;,
 			__func__);
<span class="p_header">diff --git a/drivers/devfreq/exynos-bus.c b/drivers/devfreq/exynos-bus.c</span>
<span class="p_header">index 29866f7e6d7e..1b21bb60e797 100644</span>
<span class="p_header">--- a/drivers/devfreq/exynos-bus.c</span>
<span class="p_header">+++ b/drivers/devfreq/exynos-bus.c</span>
<span class="p_chunk">@@ -498,7 +498,7 @@</span> <span class="p_context"> static int exynos_bus_probe(struct platform_device *pdev)</span>
 	if (IS_ERR(bus-&gt;devfreq)) {
 		dev_err(dev,
 			&quot;failed to add devfreq dev with passive governor\n&quot;);
<span class="p_del">-		ret = -EPROBE_DEFER;</span>
<span class="p_add">+		ret = PTR_ERR(bus-&gt;devfreq);</span>
 		goto err;
 	}
 
<span class="p_header">diff --git a/drivers/dma/pl330.c b/drivers/dma/pl330.c</span>
<span class="p_header">index 030fe05ed43b..9f3dbc8c63d2 100644</span>
<span class="p_header">--- a/drivers/dma/pl330.c</span>
<span class="p_header">+++ b/drivers/dma/pl330.c</span>
<span class="p_chunk">@@ -448,6 +448,9 @@</span> <span class="p_context"> struct dma_pl330_chan {</span>
 
 	/* for cyclic capability */
 	bool cyclic;
<span class="p_add">+</span>
<span class="p_add">+	/* for runtime pm tracking */</span>
<span class="p_add">+	bool active;</span>
 };
 
 struct pl330_dmac {
<span class="p_chunk">@@ -2031,6 +2034,7 @@</span> <span class="p_context"> static void pl330_tasklet(unsigned long data)</span>
 		_stop(pch-&gt;thread);
 		spin_unlock(&amp;pch-&gt;thread-&gt;dmac-&gt;lock);
 		power_down = true;
<span class="p_add">+		pch-&gt;active = false;</span>
 	} else {
 		/* Make sure the PL330 Channel thread is active */
 		spin_lock(&amp;pch-&gt;thread-&gt;dmac-&gt;lock);
<span class="p_chunk">@@ -2050,6 +2054,7 @@</span> <span class="p_context"> static void pl330_tasklet(unsigned long data)</span>
 			desc-&gt;status = PREP;
 			list_move_tail(&amp;desc-&gt;node, &amp;pch-&gt;work_list);
 			if (power_down) {
<span class="p_add">+				pch-&gt;active = true;</span>
 				spin_lock(&amp;pch-&gt;thread-&gt;dmac-&gt;lock);
 				_start(pch-&gt;thread);
 				spin_unlock(&amp;pch-&gt;thread-&gt;dmac-&gt;lock);
<span class="p_chunk">@@ -2164,6 +2169,7 @@</span> <span class="p_context"> static int pl330_terminate_all(struct dma_chan *chan)</span>
 	unsigned long flags;
 	struct pl330_dmac *pl330 = pch-&gt;dmac;
 	LIST_HEAD(list);
<span class="p_add">+	bool power_down = false;</span>
 
 	pm_runtime_get_sync(pl330-&gt;ddma.dev);
 	spin_lock_irqsave(&amp;pch-&gt;lock, flags);
<span class="p_chunk">@@ -2174,6 +2180,8 @@</span> <span class="p_context"> static int pl330_terminate_all(struct dma_chan *chan)</span>
 	pch-&gt;thread-&gt;req[0].desc = NULL;
 	pch-&gt;thread-&gt;req[1].desc = NULL;
 	pch-&gt;thread-&gt;req_running = -1;
<span class="p_add">+	power_down = pch-&gt;active;</span>
<span class="p_add">+	pch-&gt;active = false;</span>
 
 	/* Mark all desc done */
 	list_for_each_entry(desc, &amp;pch-&gt;submitted_list, node) {
<span class="p_chunk">@@ -2191,6 +2199,8 @@</span> <span class="p_context"> static int pl330_terminate_all(struct dma_chan *chan)</span>
 	list_splice_tail_init(&amp;pch-&gt;completed_list, &amp;pl330-&gt;desc_pool);
 	spin_unlock_irqrestore(&amp;pch-&gt;lock, flags);
 	pm_runtime_mark_last_busy(pl330-&gt;ddma.dev);
<span class="p_add">+	if (power_down)</span>
<span class="p_add">+		pm_runtime_put_autosuspend(pl330-&gt;ddma.dev);</span>
 	pm_runtime_put_autosuspend(pl330-&gt;ddma.dev);
 
 	return 0;
<span class="p_chunk">@@ -2350,6 +2360,7 @@</span> <span class="p_context"> static void pl330_issue_pending(struct dma_chan *chan)</span>
 		 * updated on work_list emptiness status.
 		 */
 		WARN_ON(list_empty(&amp;pch-&gt;submitted_list));
<span class="p_add">+		pch-&gt;active = true;</span>
 		pm_runtime_get_sync(pch-&gt;dmac-&gt;ddma.dev);
 	}
 	list_splice_tail_init(&amp;pch-&gt;submitted_list, &amp;pch-&gt;work_list);
<span class="p_header">diff --git a/drivers/dma/sh/rcar-dmac.c b/drivers/dma/sh/rcar-dmac.c</span>
<span class="p_header">index 2e441d0ccd79..4c357d475465 100644</span>
<span class="p_header">--- a/drivers/dma/sh/rcar-dmac.c</span>
<span class="p_header">+++ b/drivers/dma/sh/rcar-dmac.c</span>
<span class="p_chunk">@@ -986,6 +986,7 @@</span> <span class="p_context"> static void rcar_dmac_free_chan_resources(struct dma_chan *chan)</span>
 {
 	struct rcar_dmac_chan *rchan = to_rcar_dmac_chan(chan);
 	struct rcar_dmac *dmac = to_rcar_dmac(chan-&gt;device);
<span class="p_add">+	struct rcar_dmac_chan_map *map = &amp;rchan-&gt;map;</span>
 	struct rcar_dmac_desc_page *page, *_page;
 	struct rcar_dmac_desc *desc;
 	LIST_HEAD(list);
<span class="p_chunk">@@ -1019,6 +1020,13 @@</span> <span class="p_context"> static void rcar_dmac_free_chan_resources(struct dma_chan *chan)</span>
 		free_page((unsigned long)page);
 	}
 
<span class="p_add">+	/* Remove slave mapping if present. */</span>
<span class="p_add">+	if (map-&gt;slave.xfer_size) {</span>
<span class="p_add">+		dma_unmap_resource(chan-&gt;device-&gt;dev, map-&gt;addr,</span>
<span class="p_add">+				   map-&gt;slave.xfer_size, map-&gt;dir, 0);</span>
<span class="p_add">+		map-&gt;slave.xfer_size = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	pm_runtime_put(chan-&gt;device-&gt;dev);
 }
 
<span class="p_header">diff --git a/drivers/hid/hid-corsair.c b/drivers/hid/hid-corsair.c</span>
<span class="p_header">index 717704e9ae07..c0303f61c26a 100644</span>
<span class="p_header">--- a/drivers/hid/hid-corsair.c</span>
<span class="p_header">+++ b/drivers/hid/hid-corsair.c</span>
<span class="p_chunk">@@ -148,26 +148,36 @@</span> <span class="p_context"> static enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)</span>
 	struct usb_interface *usbif = to_usb_interface(dev-&gt;parent);
 	struct usb_device *usbdev = interface_to_usbdev(usbif);
 	int brightness;
<span class="p_del">-	char data[8];</span>
<span class="p_add">+	char *data;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = kmalloc(8, GFP_KERNEL);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
 	ret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),
 			      K90_REQUEST_STATUS,
 			      USB_DIR_IN | USB_TYPE_VENDOR |
 			      USB_RECIP_DEVICE, 0, 0, data, 8,
 			      USB_CTRL_SET_TIMEOUT);
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_add">+	if (ret &lt; 5) {</span>
 		dev_warn(dev, &quot;Failed to get K90 initial state (error %d).\n&quot;,
 			 ret);
<span class="p_del">-		return -EIO;</span>
<span class="p_add">+		ret = -EIO;</span>
<span class="p_add">+		goto out;</span>
 	}
 	brightness = data[4];
 	if (brightness &lt; 0 || brightness &gt; 3) {
 		dev_warn(dev,
 			 &quot;Read invalid backlight brightness: %02hhx.\n&quot;,
 			 data[4]);
<span class="p_del">-		return -EIO;</span>
<span class="p_add">+		ret = -EIO;</span>
<span class="p_add">+		goto out;</span>
 	}
<span class="p_del">-	return brightness;</span>
<span class="p_add">+	ret = brightness;</span>
<span class="p_add">+out:</span>
<span class="p_add">+	kfree(data);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static enum led_brightness k90_record_led_get(struct led_classdev *led_cdev)
<span class="p_chunk">@@ -253,17 +263,22 @@</span> <span class="p_context"> static ssize_t k90_show_macro_mode(struct device *dev,</span>
 	struct usb_interface *usbif = to_usb_interface(dev-&gt;parent);
 	struct usb_device *usbdev = interface_to_usbdev(usbif);
 	const char *macro_mode;
<span class="p_del">-	char data[8];</span>
<span class="p_add">+	char *data;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = kmalloc(2, GFP_KERNEL);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
 	ret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),
 			      K90_REQUEST_GET_MODE,
 			      USB_DIR_IN | USB_TYPE_VENDOR |
 			      USB_RECIP_DEVICE, 0, 0, data, 2,
 			      USB_CTRL_SET_TIMEOUT);
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_add">+	if (ret &lt; 1) {</span>
 		dev_warn(dev, &quot;Failed to get K90 initial mode (error %d).\n&quot;,
 			 ret);
<span class="p_del">-		return -EIO;</span>
<span class="p_add">+		ret = -EIO;</span>
<span class="p_add">+		goto out;</span>
 	}
 
 	switch (data[0]) {
<span class="p_chunk">@@ -277,10 +292,15 @@</span> <span class="p_context"> static ssize_t k90_show_macro_mode(struct device *dev,</span>
 	default:
 		dev_warn(dev, &quot;K90 in unknown mode: %02hhx.\n&quot;,
 			 data[0]);
<span class="p_del">-		return -EIO;</span>
<span class="p_add">+		ret = -EIO;</span>
<span class="p_add">+		goto out;</span>
 	}
 
<span class="p_del">-	return snprintf(buf, PAGE_SIZE, &quot;%s\n&quot;, macro_mode);</span>
<span class="p_add">+	ret = snprintf(buf, PAGE_SIZE, &quot;%s\n&quot;, macro_mode);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	kfree(data);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static ssize_t k90_store_macro_mode(struct device *dev,
<span class="p_chunk">@@ -320,26 +340,36 @@</span> <span class="p_context"> static ssize_t k90_show_current_profile(struct device *dev,</span>
 	struct usb_interface *usbif = to_usb_interface(dev-&gt;parent);
 	struct usb_device *usbdev = interface_to_usbdev(usbif);
 	int current_profile;
<span class="p_del">-	char data[8];</span>
<span class="p_add">+	char *data;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = kmalloc(8, GFP_KERNEL);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
 	ret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),
 			      K90_REQUEST_STATUS,
 			      USB_DIR_IN | USB_TYPE_VENDOR |
 			      USB_RECIP_DEVICE, 0, 0, data, 8,
 			      USB_CTRL_SET_TIMEOUT);
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_add">+	if (ret &lt; 8) {</span>
 		dev_warn(dev, &quot;Failed to get K90 initial state (error %d).\n&quot;,
 			 ret);
<span class="p_del">-		return -EIO;</span>
<span class="p_add">+		ret = -EIO;</span>
<span class="p_add">+		goto out;</span>
 	}
 	current_profile = data[7];
 	if (current_profile &lt; 1 || current_profile &gt; 3) {
 		dev_warn(dev, &quot;Read invalid current profile: %02hhx.\n&quot;,
 			 data[7]);
<span class="p_del">-		return -EIO;</span>
<span class="p_add">+		ret = -EIO;</span>
<span class="p_add">+		goto out;</span>
 	}
 
<span class="p_del">-	return snprintf(buf, PAGE_SIZE, &quot;%d\n&quot;, current_profile);</span>
<span class="p_add">+	ret = snprintf(buf, PAGE_SIZE, &quot;%d\n&quot;, current_profile);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	kfree(data);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static ssize_t k90_store_current_profile(struct device *dev,
<span class="p_header">diff --git a/drivers/infiniband/core/cache.c b/drivers/infiniband/core/cache.c</span>
<span class="p_header">index 1a2984c28b95..ae04826e82fc 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/cache.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/cache.c</span>
<span class="p_chunk">@@ -770,12 +770,8 @@</span> <span class="p_context"> static int _gid_table_setup_one(struct ib_device *ib_dev)</span>
 	int err = 0;
 
 	table = kcalloc(ib_dev-&gt;phys_port_cnt, sizeof(*table), GFP_KERNEL);
<span class="p_del">-</span>
<span class="p_del">-	if (!table) {</span>
<span class="p_del">-		pr_warn(&quot;failed to allocate ib gid cache for %s\n&quot;,</span>
<span class="p_del">-			ib_dev-&gt;name);</span>
<span class="p_add">+	if (!table)</span>
 		return -ENOMEM;
<span class="p_del">-	}</span>
 
 	for (port = 0; port &lt; ib_dev-&gt;phys_port_cnt; port++) {
 		u8 rdma_port = port + rdma_start_port(ib_dev);
<span class="p_chunk">@@ -1170,14 +1166,13 @@</span> <span class="p_context"> int ib_cache_setup_one(struct ib_device *device)</span>
 					  GFP_KERNEL);
 	if (!device-&gt;cache.pkey_cache ||
 	    !device-&gt;cache.lmc_cache) {
<span class="p_del">-		pr_warn(&quot;Couldn&#39;t allocate cache for %s\n&quot;, device-&gt;name);</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+		err = -ENOMEM;</span>
<span class="p_add">+		goto free;</span>
 	}
 
 	err = gid_table_setup_one(device);
 	if (err)
<span class="p_del">-		/* Allocated memory will be cleaned in the release function */</span>
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto free;</span>
 
 	for (p = 0; p &lt;= rdma_end_port(device) - rdma_start_port(device); ++p)
 		ib_cache_update(device, p + rdma_start_port(device));
<span class="p_chunk">@@ -1192,6 +1187,9 @@</span> <span class="p_context"> int ib_cache_setup_one(struct ib_device *device)</span>
 
 err:
 	gid_table_cleanup_one(device);
<span class="p_add">+free:</span>
<span class="p_add">+	kfree(device-&gt;cache.pkey_cache);</span>
<span class="p_add">+	kfree(device-&gt;cache.lmc_cache);</span>
 	return err;
 }
 
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/ah.c b/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_header">index b9bf0759f10a..8dfc76f8cbb4 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_chunk">@@ -114,7 +114,9 @@</span> <span class="p_context"> static struct ib_ah *create_iboe_ah(struct ib_pd *pd, struct ib_ah_attr *ah_attr</span>
 		       !(1 &lt;&lt; ah-&gt;av.eth.stat_rate &amp; dev-&gt;caps.stat_rate_support))
 			--ah-&gt;av.eth.stat_rate;
 	}
<span class="p_del">-</span>
<span class="p_add">+	ah-&gt;av.eth.sl_tclass_flowlabel |=</span>
<span class="p_add">+			cpu_to_be32((ah_attr-&gt;grh.traffic_class &lt;&lt; 20) |</span>
<span class="p_add">+				    ah_attr-&gt;grh.flow_label);</span>
 	/*
 	 * HW requires multicast LID so we just choose one.
 	 */
<span class="p_chunk">@@ -122,7 +124,7 @@</span> <span class="p_context"> static struct ib_ah *create_iboe_ah(struct ib_pd *pd, struct ib_ah_attr *ah_attr</span>
 		ah-&gt;av.ib.dlid = cpu_to_be16(0xc000);
 
 	memcpy(ah-&gt;av.eth.dgid, ah_attr-&gt;grh.dgid.raw, 16);
<span class="p_del">-	ah-&gt;av.eth.sl_tclass_flowlabel = cpu_to_be32(ah_attr-&gt;sl &lt;&lt; 29);</span>
<span class="p_add">+	ah-&gt;av.eth.sl_tclass_flowlabel |= cpu_to_be32(ah_attr-&gt;sl &lt;&lt; 29);</span>
 
 	return &amp;ah-&gt;ibah;
 }
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/mad.c b/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_header">index 1672907ff219..18d309e40f1b 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_chunk">@@ -702,10 +702,18 @@</span> <span class="p_context"> static int mlx4_ib_demux_mad(struct ib_device *ibdev, u8 port,</span>
 
 	/* If a grh is present, we demux according to it */
 	if (wc-&gt;wc_flags &amp; IB_WC_GRH) {
<span class="p_del">-		slave = mlx4_ib_find_real_gid(ibdev, port, grh-&gt;dgid.global.interface_id);</span>
<span class="p_del">-		if (slave &lt; 0) {</span>
<span class="p_del">-			mlx4_ib_warn(ibdev, &quot;failed matching grh\n&quot;);</span>
<span class="p_del">-			return -ENOENT;</span>
<span class="p_add">+		if (grh-&gt;dgid.global.interface_id ==</span>
<span class="p_add">+			cpu_to_be64(IB_SA_WELL_KNOWN_GUID) &amp;&amp;</span>
<span class="p_add">+		    grh-&gt;dgid.global.subnet_prefix == cpu_to_be64(</span>
<span class="p_add">+			atomic64_read(&amp;dev-&gt;sriov.demux[port - 1].subnet_prefix))) {</span>
<span class="p_add">+			slave = 0;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			slave = mlx4_ib_find_real_gid(ibdev, port,</span>
<span class="p_add">+						      grh-&gt;dgid.global.interface_id);</span>
<span class="p_add">+			if (slave &lt; 0) {</span>
<span class="p_add">+				mlx4_ib_warn(ibdev, &quot;failed matching grh\n&quot;);</span>
<span class="p_add">+				return -ENOENT;</span>
<span class="p_add">+			}</span>
 		}
 	}
 	/* Class-specific handling */
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/main.c b/drivers/infiniband/hw/mlx4/main.c</span>
<span class="p_header">index b597e8227591..46ad99595fd2 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/main.c</span>
<span class="p_chunk">@@ -697,9 +697,11 @@</span> <span class="p_context"> static int eth_link_query_port(struct ib_device *ibdev, u8 port,</span>
 	if (err)
 		goto out;
 
<span class="p_del">-	props-&gt;active_width	=  (((u8 *)mailbox-&gt;buf)[5] == 0x40) ?</span>
<span class="p_del">-						IB_WIDTH_4X : IB_WIDTH_1X;</span>
<span class="p_del">-	props-&gt;active_speed	= IB_SPEED_QDR;</span>
<span class="p_add">+	props-&gt;active_width	=  (((u8 *)mailbox-&gt;buf)[5] == 0x40) ||</span>
<span class="p_add">+				   (((u8 *)mailbox-&gt;buf)[5] == 0x20 /*56Gb*/) ?</span>
<span class="p_add">+					   IB_WIDTH_4X : IB_WIDTH_1X;</span>
<span class="p_add">+	props-&gt;active_speed	=  (((u8 *)mailbox-&gt;buf)[5] == 0x20 /*56Gb*/) ?</span>
<span class="p_add">+					   IB_SPEED_FDR : IB_SPEED_QDR;</span>
 	props-&gt;port_cap_flags	= IB_PORT_CM_SUP | IB_PORT_IP_BASED_GIDS;
 	props-&gt;gid_tbl_len	= mdev-&gt;dev-&gt;caps.gid_table_len[port];
 	props-&gt;max_msg_sz	= mdev-&gt;dev-&gt;caps.max_msg_sz;
<span class="p_chunk">@@ -2820,14 +2822,19 @@</span> <span class="p_context"> static void *mlx4_ib_add(struct mlx4_dev *dev)</span>
 			goto err_steer_qp_release;
 		}
 
<span class="p_del">-		bitmap_zero(ibdev-&gt;ib_uc_qpns_bitmap, ibdev-&gt;steer_qpn_count);</span>
<span class="p_del">-</span>
<span class="p_del">-		err = mlx4_FLOW_STEERING_IB_UC_QP_RANGE(</span>
<span class="p_del">-				dev, ibdev-&gt;steer_qpn_base,</span>
<span class="p_del">-				ibdev-&gt;steer_qpn_base +</span>
<span class="p_del">-				ibdev-&gt;steer_qpn_count - 1);</span>
<span class="p_del">-		if (err)</span>
<span class="p_del">-			goto err_steer_free_bitmap;</span>
<span class="p_add">+		if (dev-&gt;caps.flags2 &amp; MLX4_DEV_CAP_FLAG2_DMFS_IPOIB) {</span>
<span class="p_add">+			bitmap_zero(ibdev-&gt;ib_uc_qpns_bitmap,</span>
<span class="p_add">+				    ibdev-&gt;steer_qpn_count);</span>
<span class="p_add">+			err = mlx4_FLOW_STEERING_IB_UC_QP_RANGE(</span>
<span class="p_add">+					dev, ibdev-&gt;steer_qpn_base,</span>
<span class="p_add">+					ibdev-&gt;steer_qpn_base +</span>
<span class="p_add">+					ibdev-&gt;steer_qpn_count - 1);</span>
<span class="p_add">+			if (err)</span>
<span class="p_add">+				goto err_steer_free_bitmap;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			bitmap_fill(ibdev-&gt;ib_uc_qpns_bitmap,</span>
<span class="p_add">+				    ibdev-&gt;steer_qpn_count);</span>
<span class="p_add">+		}</span>
 	}
 
 	for (j = 1; j &lt;= ibdev-&gt;dev-&gt;caps.num_ports; j++)
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">index 570bc866b1d6..c22454383976 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_chunk">@@ -1280,7 +1280,8 @@</span> <span class="p_context"> static int _mlx4_ib_destroy_qp(struct ib_qp *qp)</span>
 	if (is_qp0(dev, mqp))
 		mlx4_CLOSE_PORT(dev-&gt;dev, mqp-&gt;port);
 
<span class="p_del">-	if (dev-&gt;qp1_proxy[mqp-&gt;port - 1] == mqp) {</span>
<span class="p_add">+	if (mqp-&gt;mlx4_ib_qp_type == MLX4_IB_QPT_PROXY_GSI &amp;&amp;</span>
<span class="p_add">+	    dev-&gt;qp1_proxy[mqp-&gt;port - 1] == mqp) {</span>
 		mutex_lock(&amp;dev-&gt;qp1_proxy_lock[mqp-&gt;port - 1]);
 		dev-&gt;qp1_proxy[mqp-&gt;port - 1] = NULL;
 		mutex_unlock(&amp;dev-&gt;qp1_proxy_lock[mqp-&gt;port - 1]);
<span class="p_chunk">@@ -1764,14 +1765,14 @@</span> <span class="p_context"> static int __mlx4_ib_modify_qp(struct ib_qp *ibqp,</span>
 		u8 port_num = mlx4_is_bonded(to_mdev(ibqp-&gt;device)-&gt;dev) ? 1 :
 			attr_mask &amp; IB_QP_PORT ? attr-&gt;port_num : qp-&gt;port;
 		union ib_gid gid;
<span class="p_del">-		struct ib_gid_attr gid_attr;</span>
<span class="p_add">+		struct ib_gid_attr gid_attr = {.gid_type = IB_GID_TYPE_IB};</span>
 		u16 vlan = 0xffff;
 		u8 smac[ETH_ALEN];
 		int status = 0;
 		int is_eth = rdma_cap_eth_ah(&amp;dev-&gt;ib_dev, port_num) &amp;&amp;
 			attr-&gt;ah_attr.ah_flags &amp; IB_AH_GRH;
 
<span class="p_del">-		if (is_eth) {</span>
<span class="p_add">+		if (is_eth &amp;&amp; attr-&gt;ah_attr.ah_flags &amp; IB_AH_GRH) {</span>
 			int index = attr-&gt;ah_attr.grh.sgid_index;
 
 			status = ib_get_cached_gid(ibqp-&gt;device, port_num,
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">index 32b09f059c84..4cab29ea394c 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_chunk">@@ -496,6 +496,7 @@</span> <span class="p_context"> static int mlx5_ib_query_device(struct ib_device *ibdev,</span>
 	struct mlx5_ib_dev *dev = to_mdev(ibdev);
 	struct mlx5_core_dev *mdev = dev-&gt;mdev;
 	int err = -ENOMEM;
<span class="p_add">+	int max_sq_desc;</span>
 	int max_rq_sg;
 	int max_sq_sg;
 	u64 min_page_size = 1ull &lt;&lt; MLX5_CAP_GEN(mdev, log_pg_sz);
<span class="p_chunk">@@ -618,9 +619,10 @@</span> <span class="p_context"> static int mlx5_ib_query_device(struct ib_device *ibdev,</span>
 	props-&gt;max_qp_wr	   = 1 &lt;&lt; MLX5_CAP_GEN(mdev, log_max_qp_sz);
 	max_rq_sg =  MLX5_CAP_GEN(mdev, max_wqe_sz_rq) /
 		     sizeof(struct mlx5_wqe_data_seg);
<span class="p_del">-	max_sq_sg = (MLX5_CAP_GEN(mdev, max_wqe_sz_sq) -</span>
<span class="p_del">-		     sizeof(struct mlx5_wqe_ctrl_seg)) /</span>
<span class="p_del">-		     sizeof(struct mlx5_wqe_data_seg);</span>
<span class="p_add">+	max_sq_desc = min_t(int, MLX5_CAP_GEN(mdev, max_wqe_sz_sq), 512);</span>
<span class="p_add">+	max_sq_sg = (max_sq_desc - sizeof(struct mlx5_wqe_ctrl_seg) -</span>
<span class="p_add">+		     sizeof(struct mlx5_wqe_raddr_seg)) /</span>
<span class="p_add">+		sizeof(struct mlx5_wqe_data_seg);</span>
 	props-&gt;max_sge = min(max_rq_sg, max_sq_sg);
 	props-&gt;max_sge_rd	   = MLX5_MAX_SGE_RD;
 	props-&gt;max_cq		   = 1 &lt;&lt; MLX5_CAP_GEN(mdev, log_max_cq);
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/mr.c b/drivers/infiniband/hw/mlx5/mr.c</span>
<span class="p_header">index 4e9012463c37..be2d02b6a6aa 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/mr.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/mr.c</span>
<span class="p_chunk">@@ -628,7 +628,8 @@</span> <span class="p_context"> int mlx5_mr_cache_init(struct mlx5_ib_dev *dev)</span>
 		ent-&gt;order = i + 2;
 		ent-&gt;dev = dev;
 
<span class="p_del">-		if (dev-&gt;mdev-&gt;profile-&gt;mask &amp; MLX5_PROF_MASK_MR_CACHE)</span>
<span class="p_add">+		if ((dev-&gt;mdev-&gt;profile-&gt;mask &amp; MLX5_PROF_MASK_MR_CACHE) &amp;&amp;</span>
<span class="p_add">+		    (mlx5_core_is_pf(dev-&gt;mdev)))</span>
 			limit = dev-&gt;mdev-&gt;profile-&gt;mr_cache[i].limit;
 		else
 			limit = 0;
<span class="p_chunk">@@ -646,6 +647,33 @@</span> <span class="p_context"> int mlx5_mr_cache_init(struct mlx5_ib_dev *dev)</span>
 	return 0;
 }
 
<span class="p_add">+static void wait_for_async_commands(struct mlx5_ib_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mlx5_mr_cache *cache = &amp;dev-&gt;cache;</span>
<span class="p_add">+	struct mlx5_cache_ent *ent;</span>
<span class="p_add">+	int total = 0;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	int j;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; MAX_MR_CACHE_ENTRIES; i++) {</span>
<span class="p_add">+		ent = &amp;cache-&gt;ent[i];</span>
<span class="p_add">+		for (j = 0 ; j &lt; 1000; j++) {</span>
<span class="p_add">+			if (!ent-&gt;pending)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			msleep(50);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	for (i = 0; i &lt; MAX_MR_CACHE_ENTRIES; i++) {</span>
<span class="p_add">+		ent = &amp;cache-&gt;ent[i];</span>
<span class="p_add">+		total += ent-&gt;pending;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (total)</span>
<span class="p_add">+		mlx5_ib_warn(dev, &quot;aborted while there are %d pending mr requests\n&quot;, total);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		mlx5_ib_warn(dev, &quot;done with all pending requests\n&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int mlx5_mr_cache_cleanup(struct mlx5_ib_dev *dev)
 {
 	int i;
<span class="p_chunk">@@ -659,6 +687,7 @@</span> <span class="p_context"> int mlx5_mr_cache_cleanup(struct mlx5_ib_dev *dev)</span>
 		clean_keys(dev, i);
 
 	destroy_workqueue(dev-&gt;cache.wq);
<span class="p_add">+	wait_for_async_commands(dev);</span>
 	del_timer_sync(&amp;dev-&gt;delay_timer);
 
 	return 0;
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/qp.c b/drivers/infiniband/hw/mlx5/qp.c</span>
<span class="p_header">index d1e921816bfe..aee3942ec68d 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/qp.c</span>
<span class="p_chunk">@@ -351,6 +351,29 @@</span> <span class="p_context"> static int calc_send_wqe(struct ib_qp_init_attr *attr)</span>
 		return ALIGN(max_t(int, inl_size, size), MLX5_SEND_WQE_BB);
 }
 
<span class="p_add">+static int get_send_sge(struct ib_qp_init_attr *attr, int wqe_size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int max_sge;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (attr-&gt;qp_type == IB_QPT_RC)</span>
<span class="p_add">+		max_sge = (min_t(int, wqe_size, 512) -</span>
<span class="p_add">+			   sizeof(struct mlx5_wqe_ctrl_seg) -</span>
<span class="p_add">+			   sizeof(struct mlx5_wqe_raddr_seg)) /</span>
<span class="p_add">+			sizeof(struct mlx5_wqe_data_seg);</span>
<span class="p_add">+	else if (attr-&gt;qp_type == IB_QPT_XRC_INI)</span>
<span class="p_add">+		max_sge = (min_t(int, wqe_size, 512) -</span>
<span class="p_add">+			   sizeof(struct mlx5_wqe_ctrl_seg) -</span>
<span class="p_add">+			   sizeof(struct mlx5_wqe_xrc_seg) -</span>
<span class="p_add">+			   sizeof(struct mlx5_wqe_raddr_seg)) /</span>
<span class="p_add">+			sizeof(struct mlx5_wqe_data_seg);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		max_sge = (wqe_size - sq_overhead(attr)) /</span>
<span class="p_add">+			sizeof(struct mlx5_wqe_data_seg);</span>
<span class="p_add">+</span>
<span class="p_add">+	return min_t(int, max_sge, wqe_size - sq_overhead(attr) /</span>
<span class="p_add">+		     sizeof(struct mlx5_wqe_data_seg));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int calc_sq_size(struct mlx5_ib_dev *dev, struct ib_qp_init_attr *attr,
 			struct mlx5_ib_qp *qp)
 {
<span class="p_chunk">@@ -387,7 +410,11 @@</span> <span class="p_context"> static int calc_sq_size(struct mlx5_ib_dev *dev, struct ib_qp_init_attr *attr,</span>
 		return -ENOMEM;
 	}
 	qp-&gt;sq.wqe_shift = ilog2(MLX5_SEND_WQE_BB);
<span class="p_del">-	qp-&gt;sq.max_gs = attr-&gt;cap.max_send_sge;</span>
<span class="p_add">+	qp-&gt;sq.max_gs = get_send_sge(attr, wqe_size);</span>
<span class="p_add">+	if (qp-&gt;sq.max_gs &lt; attr-&gt;cap.max_send_sge)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	attr-&gt;cap.max_send_sge = qp-&gt;sq.max_gs;</span>
 	qp-&gt;sq.max_post = wq_size / wqe_size;
 	attr-&gt;cap.max_send_wr = qp-&gt;sq.max_post;
 
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/srq.c b/drivers/infiniband/hw/mlx5/srq.c</span>
<span class="p_header">index 3857dbd9c956..729b0696626e 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/srq.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/srq.c</span>
<span class="p_chunk">@@ -282,6 +282,7 @@</span> <span class="p_context"> struct ib_srq *mlx5_ib_create_srq(struct ib_pd *pd,</span>
 	mlx5_ib_dbg(dev, &quot;desc_size 0x%x, req wr 0x%x, srq size 0x%x, max_gs 0x%x, max_avail_gather 0x%x\n&quot;,
 		    desc_size, init_attr-&gt;attr.max_wr, srq-&gt;msrq.max, srq-&gt;msrq.max_gs,
 		    srq-&gt;msrq.max_avail_gather);
<span class="p_add">+	in.type = init_attr-&gt;srq_type;</span>
 
 	if (pd-&gt;uobject)
 		err = create_srq_user(pd, srq, &amp;in, udata, buf_size);
<span class="p_chunk">@@ -294,7 +295,6 @@</span> <span class="p_context"> struct ib_srq *mlx5_ib_create_srq(struct ib_pd *pd,</span>
 		goto err_srq;
 	}
 
<span class="p_del">-	in.type = init_attr-&gt;srq_type;</span>
 	in.log_size = ilog2(srq-&gt;msrq.max);
 	in.wqe_shift = srq-&gt;msrq.wqe_shift - 4;
 	if (srq-&gt;wq_sig)
<span class="p_header">diff --git a/drivers/infiniband/sw/rxe/rxe_param.h b/drivers/infiniband/sw/rxe/rxe_param.h</span>
<span class="p_header">index f459c43a77c8..13ed2cc6eaa2 100644</span>
<span class="p_header">--- a/drivers/infiniband/sw/rxe/rxe_param.h</span>
<span class="p_header">+++ b/drivers/infiniband/sw/rxe/rxe_param.h</span>
<span class="p_chunk">@@ -82,7 +82,7 @@</span> <span class="p_context"> enum rxe_device_param {</span>
 	RXE_MAX_SGE			= 32,
 	RXE_MAX_SGE_RD			= 32,
 	RXE_MAX_CQ			= 16384,
<span class="p_del">-	RXE_MAX_LOG_CQE			= 13,</span>
<span class="p_add">+	RXE_MAX_LOG_CQE			= 15,</span>
 	RXE_MAX_MR			= 2 * 1024,
 	RXE_MAX_PD			= 0x7ffc,
 	RXE_MAX_QP_RD_ATOM		= 128,
<span class="p_header">diff --git a/drivers/infiniband/sw/rxe/rxe_req.c b/drivers/infiniband/sw/rxe/rxe_req.c</span>
<span class="p_header">index 22bd9630dcd9..9f46be52335e 100644</span>
<span class="p_header">--- a/drivers/infiniband/sw/rxe/rxe_req.c</span>
<span class="p_header">+++ b/drivers/infiniband/sw/rxe/rxe_req.c</span>
<span class="p_chunk">@@ -548,23 +548,23 @@</span> <span class="p_context"> static void update_wqe_psn(struct rxe_qp *qp,</span>
 static void save_state(struct rxe_send_wqe *wqe,
 		       struct rxe_qp *qp,
 		       struct rxe_send_wqe *rollback_wqe,
<span class="p_del">-		       struct rxe_qp *rollback_qp)</span>
<span class="p_add">+		       u32 *rollback_psn)</span>
 {
 	rollback_wqe-&gt;state     = wqe-&gt;state;
 	rollback_wqe-&gt;first_psn = wqe-&gt;first_psn;
 	rollback_wqe-&gt;last_psn  = wqe-&gt;last_psn;
<span class="p_del">-	rollback_qp-&gt;req.psn    = qp-&gt;req.psn;</span>
<span class="p_add">+	*rollback_psn		= qp-&gt;req.psn;</span>
 }
 
 static void rollback_state(struct rxe_send_wqe *wqe,
 			   struct rxe_qp *qp,
 			   struct rxe_send_wqe *rollback_wqe,
<span class="p_del">-			   struct rxe_qp *rollback_qp)</span>
<span class="p_add">+			   u32 rollback_psn)</span>
 {
 	wqe-&gt;state     = rollback_wqe-&gt;state;
 	wqe-&gt;first_psn = rollback_wqe-&gt;first_psn;
 	wqe-&gt;last_psn  = rollback_wqe-&gt;last_psn;
<span class="p_del">-	qp-&gt;req.psn    = rollback_qp-&gt;req.psn;</span>
<span class="p_add">+	qp-&gt;req.psn    = rollback_psn;</span>
 }
 
 static void update_state(struct rxe_qp *qp, struct rxe_send_wqe *wqe,
<span class="p_chunk">@@ -593,8 +593,8 @@</span> <span class="p_context"> int rxe_requester(void *arg)</span>
 	int mtu;
 	int opcode;
 	int ret;
<span class="p_del">-	struct rxe_qp rollback_qp;</span>
 	struct rxe_send_wqe rollback_wqe;
<span class="p_add">+	u32 rollback_psn;</span>
 
 next_wqe:
 	if (unlikely(!qp-&gt;valid || qp-&gt;req.state == QP_STATE_ERROR))
<span class="p_chunk">@@ -719,7 +719,7 @@</span> <span class="p_context"> int rxe_requester(void *arg)</span>
 	 * rxe_xmit_packet().
 	 * Otherwise, completer might initiate an unjustified retry flow.
 	 */
<span class="p_del">-	save_state(wqe, qp, &amp;rollback_wqe, &amp;rollback_qp);</span>
<span class="p_add">+	save_state(wqe, qp, &amp;rollback_wqe, &amp;rollback_psn);</span>
 	update_wqe_state(qp, wqe, &amp;pkt);
 	update_wqe_psn(qp, wqe, &amp;pkt, payload);
 	ret = rxe_xmit_packet(to_rdev(qp-&gt;ibqp.device), qp, &amp;pkt, skb);
<span class="p_chunk">@@ -727,7 +727,7 @@</span> <span class="p_context"> int rxe_requester(void *arg)</span>
 		qp-&gt;need_req_skb = 1;
 		kfree_skb(skb);
 
<span class="p_del">-		rollback_state(wqe, qp, &amp;rollback_wqe, &amp;rollback_qp);</span>
<span class="p_add">+		rollback_state(wqe, qp, &amp;rollback_wqe, rollback_psn);</span>
 
 		if (ret == -EAGAIN) {
 			rxe_run_task(&amp;qp-&gt;req.task, 1);
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_cm.c b/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_header">index 339a1eecdfe3..81a8080c18b3 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_chunk">@@ -1054,8 +1054,6 @@</span> <span class="p_context"> static struct ib_qp *ipoib_cm_create_tx_qp(struct net_device *dev, struct ipoib_</span>
 
 	tx_qp = ib_create_qp(priv-&gt;pd, &amp;attr);
 	if (PTR_ERR(tx_qp) == -EINVAL) {
<span class="p_del">-		ipoib_warn(priv, &quot;can&#39;t use GFP_NOIO for QPs on device %s, using GFP_KERNEL\n&quot;,</span>
<span class="p_del">-			   priv-&gt;ca-&gt;name);</span>
 		attr.create_flags &amp;= ~IB_QP_CREATE_USE_GFP_NOIO;
 		tx_qp = ib_create_qp(priv-&gt;pd, &amp;attr);
 	}
<span class="p_header">diff --git a/drivers/input/mouse/alps.c b/drivers/input/mouse/alps.c</span>
<span class="p_header">index 6d7de9bfed9a..b93fe83a0b63 100644</span>
<span class="p_header">--- a/drivers/input/mouse/alps.c</span>
<span class="p_header">+++ b/drivers/input/mouse/alps.c</span>
<span class="p_chunk">@@ -1346,6 +1346,18 @@</span> <span class="p_context"> static void alps_process_packet_ss4_v2(struct psmouse *psmouse)</span>
 
 	priv-&gt;multi_packet = 0;
 
<span class="p_add">+	/* Report trackstick */</span>
<span class="p_add">+	if (alps_get_pkt_id_ss4_v2(packet) == SS4_PACKET_ID_STICK) {</span>
<span class="p_add">+		if (priv-&gt;flags &amp; ALPS_DUALPOINT) {</span>
<span class="p_add">+			input_report_key(dev2, BTN_LEFT, f-&gt;ts_left);</span>
<span class="p_add">+			input_report_key(dev2, BTN_RIGHT, f-&gt;ts_right);</span>
<span class="p_add">+			input_report_key(dev2, BTN_MIDDLE, f-&gt;ts_middle);</span>
<span class="p_add">+			input_sync(dev2);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Report touchpad */</span>
 	alps_report_mt_data(psmouse, (f-&gt;fingers &lt;= 4) ? f-&gt;fingers : 4);
 
 	input_mt_report_finger_count(dev, f-&gt;fingers);
<span class="p_chunk">@@ -1356,13 +1368,6 @@</span> <span class="p_context"> static void alps_process_packet_ss4_v2(struct psmouse *psmouse)</span>
 
 	input_report_abs(dev, ABS_PRESSURE, f-&gt;pressure);
 	input_sync(dev);
<span class="p_del">-</span>
<span class="p_del">-	if (priv-&gt;flags &amp; ALPS_DUALPOINT) {</span>
<span class="p_del">-		input_report_key(dev2, BTN_LEFT, f-&gt;ts_left);</span>
<span class="p_del">-		input_report_key(dev2, BTN_RIGHT, f-&gt;ts_right);</span>
<span class="p_del">-		input_report_key(dev2, BTN_MIDDLE, f-&gt;ts_middle);</span>
<span class="p_del">-		input_sync(dev2);</span>
<span class="p_del">-	}</span>
 }
 
 static bool alps_is_valid_package_ss4_v2(struct psmouse *psmouse)
<span class="p_header">diff --git a/drivers/media/platform/Kconfig b/drivers/media/platform/Kconfig</span>
<span class="p_header">index ce4a96fccc43..5ff803efdc03 100644</span>
<span class="p_header">--- a/drivers/media/platform/Kconfig</span>
<span class="p_header">+++ b/drivers/media/platform/Kconfig</span>
<span class="p_chunk">@@ -93,7 +93,7 @@</span> <span class="p_context"> config VIDEO_OMAP3_DEBUG</span>
 
 config VIDEO_PXA27x
 	tristate &quot;PXA27x Quick Capture Interface driver&quot;
<span class="p_del">-	depends on VIDEO_DEV &amp;&amp; HAS_DMA</span>
<span class="p_add">+	depends on VIDEO_DEV &amp;&amp; VIDEO_V4L2 &amp;&amp; HAS_DMA</span>
 	depends on PXA27x || COMPILE_TEST
 	select VIDEOBUF2_DMA_SG
 	select SG_SPLIT
<span class="p_header">diff --git a/drivers/media/platform/blackfin/ppi.c b/drivers/media/platform/blackfin/ppi.c</span>
<span class="p_header">index cff63e511e6d..b8f3d9fa66e9 100644</span>
<span class="p_header">--- a/drivers/media/platform/blackfin/ppi.c</span>
<span class="p_header">+++ b/drivers/media/platform/blackfin/ppi.c</span>
<span class="p_chunk">@@ -214,6 +214,8 @@</span> <span class="p_context"> static int ppi_set_params(struct ppi_if *ppi, struct ppi_params *params)</span>
 	if (params-&gt;dlen &gt; 24 || params-&gt;dlen &lt;= 0)
 		return -EINVAL;
 	pctrl = devm_pinctrl_get(ppi-&gt;dev);
<span class="p_add">+	if (IS_ERR(pctrl))</span>
<span class="p_add">+		return PTR_ERR(pctrl);</span>
 	pstate = pinctrl_lookup_state(pctrl,
 				      pin_state[(params-&gt;dlen + 7) / 8 - 1]);
 	if (pinctrl_select_state(pctrl, pstate))
<span class="p_header">diff --git a/drivers/media/platform/s5p-mfc/s5p_mfc.c b/drivers/media/platform/s5p-mfc/s5p_mfc.c</span>
<span class="p_header">index 3436eda58855..27e7cf65c2a7 100644</span>
<span class="p_header">--- a/drivers/media/platform/s5p-mfc/s5p_mfc.c</span>
<span class="p_header">+++ b/drivers/media/platform/s5p-mfc/s5p_mfc.c</span>
<span class="p_chunk">@@ -926,10 +926,11 @@</span> <span class="p_context"> static int s5p_mfc_release(struct file *file)</span>
 	mfc_debug_enter();
 	if (dev)
 		mutex_lock(&amp;dev-&gt;mfc_mutex);
<span class="p_del">-	s5p_mfc_clock_on();</span>
 	vb2_queue_release(&amp;ctx-&gt;vq_src);
 	vb2_queue_release(&amp;ctx-&gt;vq_dst);
 	if (dev) {
<span class="p_add">+		s5p_mfc_clock_on();</span>
<span class="p_add">+</span>
 		/* Mark context as idle */
 		clear_work_bit_irqsave(ctx);
 		/*
<span class="p_chunk">@@ -951,9 +952,9 @@</span> <span class="p_context"> static int s5p_mfc_release(struct file *file)</span>
 			if (s5p_mfc_power_off() &lt; 0)
 				mfc_err(&quot;Power off failed\n&quot;);
 		}
<span class="p_add">+		mfc_debug(2, &quot;Shutting down clock\n&quot;);</span>
<span class="p_add">+		s5p_mfc_clock_off();</span>
 	}
<span class="p_del">-	mfc_debug(2, &quot;Shutting down clock\n&quot;);</span>
<span class="p_del">-	s5p_mfc_clock_off();</span>
 	if (dev)
 		dev-&gt;ctx[ctx-&gt;num] = NULL;
 	s5p_mfc_dec_ctrls_delete(ctx);
<span class="p_header">diff --git a/drivers/media/platform/sti/hva/hva-hw.c b/drivers/media/platform/sti/hva/hva-hw.c</span>
<span class="p_header">index d341d4994528..cf2a8d884536 100644</span>
<span class="p_header">--- a/drivers/media/platform/sti/hva/hva-hw.c</span>
<span class="p_header">+++ b/drivers/media/platform/sti/hva/hva-hw.c</span>
<span class="p_chunk">@@ -305,16 +305,16 @@</span> <span class="p_context"> int hva_hw_probe(struct platform_device *pdev, struct hva_dev *hva)</span>
 	/* get memory for registers */
 	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	hva-&gt;regs = devm_ioremap_resource(dev, regs);
<span class="p_del">-	if (IS_ERR_OR_NULL(hva-&gt;regs)) {</span>
<span class="p_add">+	if (IS_ERR(hva-&gt;regs)) {</span>
 		dev_err(dev, &quot;%s     failed to get regs\n&quot;, HVA_PREFIX);
 		return PTR_ERR(hva-&gt;regs);
 	}
 
 	/* get memory for esram */
 	esram = platform_get_resource(pdev, IORESOURCE_MEM, 1);
<span class="p_del">-	if (IS_ERR_OR_NULL(esram)) {</span>
<span class="p_add">+	if (!esram) {</span>
 		dev_err(dev, &quot;%s     failed to get esram\n&quot;, HVA_PREFIX);
<span class="p_del">-		return PTR_ERR(esram);</span>
<span class="p_add">+		return -ENODEV;</span>
 	}
 	hva-&gt;esram_addr = esram-&gt;start;
 	hva-&gt;esram_size = resource_size(esram);
<span class="p_header">diff --git a/drivers/media/rc/ite-cir.c b/drivers/media/rc/ite-cir.c</span>
<span class="p_header">index 0f301903aa6f..63165d324fff 100644</span>
<span class="p_header">--- a/drivers/media/rc/ite-cir.c</span>
<span class="p_header">+++ b/drivers/media/rc/ite-cir.c</span>
<span class="p_chunk">@@ -263,6 +263,8 @@</span> <span class="p_context"> static void ite_set_carrier_params(struct ite_dev *dev)</span>
 
 			if (allowance &gt; ITE_RXDCR_MAX)
 				allowance = ITE_RXDCR_MAX;
<span class="p_add">+</span>
<span class="p_add">+			use_demodulator = true;</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/media/spi/gs1662.c b/drivers/media/spi/gs1662.c</span>
<span class="p_header">index d76f36233f43..5143a90219c0 100644</span>
<span class="p_header">--- a/drivers/media/spi/gs1662.c</span>
<span class="p_header">+++ b/drivers/media/spi/gs1662.c</span>
<span class="p_chunk">@@ -453,10 +453,9 @@</span> <span class="p_context"> static int gs_probe(struct spi_device *spi)</span>
 static int gs_remove(struct spi_device *spi)
 {
 	struct v4l2_subdev *sd = spi_get_drvdata(spi);
<span class="p_del">-	struct gs *gs = to_gs(sd);</span>
 
 	v4l2_device_unregister_subdev(sd);
<span class="p_del">-	kfree(gs);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/mmc/host/mxs-mmc.c b/drivers/mmc/host/mxs-mmc.c</span>
<span class="p_header">index 44ecebd1ea8c..c8b8ac66ff7e 100644</span>
<span class="p_header">--- a/drivers/mmc/host/mxs-mmc.c</span>
<span class="p_header">+++ b/drivers/mmc/host/mxs-mmc.c</span>
<span class="p_chunk">@@ -309,6 +309,9 @@</span> <span class="p_context"> static void mxs_mmc_ac(struct mxs_mmc_host *host)</span>
 	cmd0 = BF_SSP(cmd-&gt;opcode, CMD0_CMD);
 	cmd1 = cmd-&gt;arg;
 
<span class="p_add">+	if (cmd-&gt;opcode == MMC_STOP_TRANSMISSION)</span>
<span class="p_add">+		cmd0 |= BM_SSP_CMD0_APPEND_8CYC;</span>
<span class="p_add">+</span>
 	if (host-&gt;sdio_irq_en) {
 		ctrl0 |= BM_SSP_CTRL0_SDIO_IRQ_CHECK;
 		cmd0 |= BM_SSP_CMD0_CONT_CLKING_EN | BM_SSP_CMD0_SLOW_CLKING_EN;
<span class="p_chunk">@@ -417,8 +420,7 @@</span> <span class="p_context"> static void mxs_mmc_adtc(struct mxs_mmc_host *host)</span>
 		       ssp-&gt;base + HW_SSP_BLOCK_SIZE);
 	}
 
<span class="p_del">-	if ((cmd-&gt;opcode == MMC_STOP_TRANSMISSION) ||</span>
<span class="p_del">-	    (cmd-&gt;opcode == SD_IO_RW_EXTENDED))</span>
<span class="p_add">+	if (cmd-&gt;opcode == SD_IO_RW_EXTENDED)</span>
 		cmd0 |= BM_SSP_CMD0_APPEND_8CYC;
 
 	cmd1 = cmd-&gt;arg;
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-acpi.c b/drivers/mmc/host/sdhci-acpi.c</span>
<span class="p_header">index 81d4dc034793..fddd0be196f4 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-acpi.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-acpi.c</span>
<span class="p_chunk">@@ -394,7 +394,8 @@</span> <span class="p_context"> static int sdhci_acpi_probe(struct platform_device *pdev)</span>
 	/* Power on the SDHCI controller and its children */
 	acpi_device_fix_up_power(device);
 	list_for_each_entry(child, &amp;device-&gt;children, node)
<span class="p_del">-		acpi_device_fix_up_power(child);</span>
<span class="p_add">+		if (child-&gt;status.present &amp;&amp; child-&gt;status.enabled)</span>
<span class="p_add">+			acpi_device_fix_up_power(child);</span>
 
 	if (acpi_bus_get_status(device) || !device-&gt;status.present)
 		return -ENODEV;
<span class="p_header">diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig</span>
<span class="p_header">index 7b7a887b4709..b254090b8a1b 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/Kconfig</span>
<span class="p_header">+++ b/drivers/mtd/nand/Kconfig</span>
<span class="p_chunk">@@ -537,7 +537,7 @@</span> <span class="p_context"> config MTD_NAND_FSMC</span>
 	  Flexible Static Memory Controller (FSMC)
 
 config MTD_NAND_XWAY
<span class="p_del">-	tristate &quot;Support for NAND on Lantiq XWAY SoC&quot;</span>
<span class="p_add">+	bool &quot;Support for NAND on Lantiq XWAY SoC&quot;</span>
 	depends on LANTIQ &amp;&amp; SOC_TYPE_XWAY
 	help
 	  Enables support for NAND Flash chips on Lantiq XWAY SoCs. NAND is attached
<span class="p_header">diff --git a/drivers/mtd/nand/lpc32xx_mlc.c b/drivers/mtd/nand/lpc32xx_mlc.c</span>
<span class="p_header">index 852388171f20..bc6e49af063a 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/lpc32xx_mlc.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/lpc32xx_mlc.c</span>
<span class="p_chunk">@@ -776,7 +776,7 @@</span> <span class="p_context"> static int lpc32xx_nand_probe(struct platform_device *pdev)</span>
 	init_completion(&amp;host-&gt;comp_controller);
 
 	host-&gt;irq = platform_get_irq(pdev, 0);
<span class="p_del">-	if ((host-&gt;irq &lt; 0) || (host-&gt;irq &gt;= NR_IRQS)) {</span>
<span class="p_add">+	if (host-&gt;irq &lt; 0) {</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to get platform irq\n&quot;);
 		res = -EINVAL;
 		goto err_exit3;
<span class="p_header">diff --git a/drivers/mtd/nand/xway_nand.c b/drivers/mtd/nand/xway_nand.c</span>
<span class="p_header">index 1f2948c0c458..895101a5e686 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/xway_nand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/xway_nand.c</span>
<span class="p_chunk">@@ -232,7 +232,6 @@</span> <span class="p_context"> static const struct of_device_id xway_nand_match[] = {</span>
 	{ .compatible = &quot;lantiq,nand-xway&quot; },
 	{},
 };
<span class="p_del">-MODULE_DEVICE_TABLE(of, xway_nand_match);</span>
 
 static struct platform_driver xway_nand_driver = {
 	.probe	= xway_nand_probe,
<span class="p_chunk">@@ -243,6 +242,4 @@</span> <span class="p_context"> static struct platform_driver xway_nand_driver = {</span>
 	},
 };
 
<span class="p_del">-module_platform_driver(xway_nand_driver);</span>
<span class="p_del">-</span>
<span class="p_del">-MODULE_LICENSE(&quot;GPL&quot;);</span>
<span class="p_add">+builtin_platform_driver(xway_nand_driver);</span>
<span class="p_header">diff --git a/drivers/mtd/spi-nor/cadence-quadspi.c b/drivers/mtd/spi-nor/cadence-quadspi.c</span>
<span class="p_header">index d403ba7b8f43..d489fbd07c12 100644</span>
<span class="p_header">--- a/drivers/mtd/spi-nor/cadence-quadspi.c</span>
<span class="p_header">+++ b/drivers/mtd/spi-nor/cadence-quadspi.c</span>
<span class="p_chunk">@@ -1077,12 +1077,14 @@</span> <span class="p_context"> static int cqspi_setup_flash(struct cqspi_st *cqspi, struct device_node *np)</span>
 
 	/* Get flash device data */
 	for_each_available_child_of_node(dev-&gt;of_node, np) {
<span class="p_del">-		if (of_property_read_u32(np, &quot;reg&quot;, &amp;cs)) {</span>
<span class="p_add">+		ret = of_property_read_u32(np, &quot;reg&quot;, &amp;cs);</span>
<span class="p_add">+		if (ret) {</span>
 			dev_err(dev, &quot;Couldn&#39;t determine chip select.\n&quot;);
 			goto err;
 		}
 
<span class="p_del">-		if (cs &gt; CQSPI_MAX_CHIPSELECT) {</span>
<span class="p_add">+		if (cs &gt;= CQSPI_MAX_CHIPSELECT) {</span>
<span class="p_add">+			ret = -EINVAL;</span>
 			dev_err(dev, &quot;Chip select %d out of range.\n&quot;, cs);
 			goto err;
 		}
<span class="p_header">diff --git a/drivers/net/ieee802154/atusb.c b/drivers/net/ieee802154/atusb.c</span>
<span class="p_header">index 1056ed142411..f186e0460cde 100644</span>
<span class="p_header">--- a/drivers/net/ieee802154/atusb.c</span>
<span class="p_header">+++ b/drivers/net/ieee802154/atusb.c</span>
<span class="p_chunk">@@ -112,13 +112,26 @@</span> <span class="p_context"> static int atusb_read_reg(struct atusb *atusb, uint8_t reg)</span>
 {
 	struct usb_device *usb_dev = atusb-&gt;usb_dev;
 	int ret;
<span class="p_add">+	uint8_t *buffer;</span>
 	uint8_t value;
 
<span class="p_add">+	buffer = kmalloc(1, GFP_KERNEL);</span>
<span class="p_add">+	if (!buffer)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	dev_dbg(&amp;usb_dev-&gt;dev, &quot;atusb: reg = 0x%x\n&quot;, reg);
 	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
 				ATUSB_REG_READ, ATUSB_REQ_FROM_DEV,
<span class="p_del">-				0, reg, &amp;value, 1, 1000);</span>
<span class="p_del">-	return ret &gt;= 0 ? value : ret;</span>
<span class="p_add">+				0, reg, buffer, 1, 1000);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret &gt;= 0) {</span>
<span class="p_add">+		value = buffer[0];</span>
<span class="p_add">+		kfree(buffer);</span>
<span class="p_add">+		return value;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		kfree(buffer);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
 }
 
 static int atusb_write_subreg(struct atusb *atusb, uint8_t reg, uint8_t mask,
<span class="p_chunk">@@ -587,9 +600,13 @@</span> <span class="p_context"> static struct ieee802154_ops atusb_ops = {</span>
 static int atusb_get_and_show_revision(struct atusb *atusb)
 {
 	struct usb_device *usb_dev = atusb-&gt;usb_dev;
<span class="p_del">-	unsigned char buffer[3];</span>
<span class="p_add">+	unsigned char *buffer;</span>
 	int ret;
 
<span class="p_add">+	buffer = kmalloc(3, GFP_KERNEL);</span>
<span class="p_add">+	if (!buffer)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	/* Get a couple of the ATMega Firmware values */
 	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
 				ATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,
<span class="p_chunk">@@ -605,15 +622,20 @@</span> <span class="p_context"> static int atusb_get_and_show_revision(struct atusb *atusb)</span>
 		dev_info(&amp;usb_dev-&gt;dev, &quot;Please update to version 0.2 or newer&quot;);
 	}
 
<span class="p_add">+	kfree(buffer);</span>
 	return ret;
 }
 
 static int atusb_get_and_show_build(struct atusb *atusb)
 {
 	struct usb_device *usb_dev = atusb-&gt;usb_dev;
<span class="p_del">-	char build[ATUSB_BUILD_SIZE + 1];</span>
<span class="p_add">+	char *build;</span>
 	int ret;
 
<span class="p_add">+	build = kmalloc(ATUSB_BUILD_SIZE + 1, GFP_KERNEL);</span>
<span class="p_add">+	if (!build)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
 				ATUSB_BUILD, ATUSB_REQ_FROM_DEV, 0, 0,
 				build, ATUSB_BUILD_SIZE, 1000);
<span class="p_chunk">@@ -622,6 +644,7 @@</span> <span class="p_context"> static int atusb_get_and_show_build(struct atusb *atusb)</span>
 		dev_info(&amp;usb_dev-&gt;dev, &quot;Firmware: build %s\n&quot;, build);
 	}
 
<span class="p_add">+	kfree(build);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/nvdimm/namespace_devs.c b/drivers/nvdimm/namespace_devs.c</span>
<span class="p_header">index abe5c6bc756c..1480734c2d6e 100644</span>
<span class="p_header">--- a/drivers/nvdimm/namespace_devs.c</span>
<span class="p_header">+++ b/drivers/nvdimm/namespace_devs.c</span>
<span class="p_chunk">@@ -957,6 +957,7 @@</span> <span class="p_context"> static ssize_t __size_store(struct device *dev, unsigned long long val)</span>
 {
 	resource_size_t allocated = 0, available = 0;
 	struct nd_region *nd_region = to_nd_region(dev-&gt;parent);
<span class="p_add">+	struct nd_namespace_common *ndns = to_ndns(dev);</span>
 	struct nd_mapping *nd_mapping;
 	struct nvdimm_drvdata *ndd;
 	struct nd_label_id label_id;
<span class="p_chunk">@@ -964,7 +965,7 @@</span> <span class="p_context"> static ssize_t __size_store(struct device *dev, unsigned long long val)</span>
 	u8 *uuid = NULL;
 	int rc, i;
 
<span class="p_del">-	if (dev-&gt;driver || to_ndns(dev)-&gt;claim)</span>
<span class="p_add">+	if (dev-&gt;driver || ndns-&gt;claim)</span>
 		return -EBUSY;
 
 	if (is_namespace_pmem(dev)) {
<span class="p_chunk">@@ -1034,20 +1035,16 @@</span> <span class="p_context"> static ssize_t __size_store(struct device *dev, unsigned long long val)</span>
 
 		nd_namespace_pmem_set_resource(nd_region, nspm,
 				val * nd_region-&gt;ndr_mappings);
<span class="p_del">-	} else if (is_namespace_blk(dev)) {</span>
<span class="p_del">-		struct nd_namespace_blk *nsblk = to_nd_namespace_blk(dev);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Try to delete the namespace if we deleted all of its</span>
<span class="p_del">-		 * allocation, this is not the seed device for the</span>
<span class="p_del">-		 * region, and it is not actively claimed by a btt</span>
<span class="p_del">-		 * instance.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (val == 0 &amp;&amp; nd_region-&gt;ns_seed != dev</span>
<span class="p_del">-				&amp;&amp; !nsblk-&gt;common.claim)</span>
<span class="p_del">-			nd_device_unregister(dev, ND_ASYNC);</span>
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Try to delete the namespace if we deleted all of its</span>
<span class="p_add">+	 * allocation, this is not the seed device for the region, and</span>
<span class="p_add">+	 * it is not actively claimed by a btt instance.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (val == 0 &amp;&amp; nd_region-&gt;ns_seed != dev &amp;&amp; !ndns-&gt;claim)</span>
<span class="p_add">+		nd_device_unregister(dev, ND_ASYNC);</span>
<span class="p_add">+</span>
 	return rc;
 }
 
<span class="p_header">diff --git a/drivers/pci/host/pcie-designware.c b/drivers/pci/host/pcie-designware.c</span>
<span class="p_header">index bed19994c1e9..af8f6e92e885 100644</span>
<span class="p_header">--- a/drivers/pci/host/pcie-designware.c</span>
<span class="p_header">+++ b/drivers/pci/host/pcie-designware.c</span>
<span class="p_chunk">@@ -807,11 +807,6 @@</span> <span class="p_context"> void dw_pcie_setup_rc(struct pcie_port *pp)</span>
 {
 	u32 val;
 
<span class="p_del">-	/* get iATU unroll support */</span>
<span class="p_del">-	pp-&gt;iatu_unroll_enabled = dw_pcie_iatu_unroll_enabled(pp);</span>
<span class="p_del">-	dev_dbg(pp-&gt;dev, &quot;iATU unroll: %s\n&quot;,</span>
<span class="p_del">-		pp-&gt;iatu_unroll_enabled ? &quot;enabled&quot; : &quot;disabled&quot;);</span>
<span class="p_del">-</span>
 	/* set the number of lanes */
 	val = dw_pcie_readl_rc(pp, PCIE_PORT_LINK_CONTROL);
 	val &amp;= ~PORT_LINK_MODE_MASK;
<span class="p_chunk">@@ -882,6 +877,11 @@</span> <span class="p_context"> void dw_pcie_setup_rc(struct pcie_port *pp)</span>
 	 * we should not program the ATU here.
 	 */
 	if (!pp-&gt;ops-&gt;rd_other_conf) {
<span class="p_add">+		/* get iATU unroll support */</span>
<span class="p_add">+		pp-&gt;iatu_unroll_enabled = dw_pcie_iatu_unroll_enabled(pp);</span>
<span class="p_add">+		dev_dbg(pp-&gt;dev, &quot;iATU unroll: %s\n&quot;,</span>
<span class="p_add">+			pp-&gt;iatu_unroll_enabled ? &quot;enabled&quot; : &quot;disabled&quot;);</span>
<span class="p_add">+</span>
 		dw_pcie_prog_outbound_atu(pp, PCIE_ATU_REGION_INDEX0,
 					  PCIE_ATU_TYPE_MEM, pp-&gt;mem_base,
 					  pp-&gt;mem_bus_addr, pp-&gt;mem_size);
<span class="p_header">diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c</span>
<span class="p_header">index 104c46d53121..300770cdc084 100644</span>
<span class="p_header">--- a/drivers/pci/probe.c</span>
<span class="p_header">+++ b/drivers/pci/probe.c</span>
<span class="p_chunk">@@ -1050,6 +1050,7 @@</span> <span class="p_context"> void set_pcie_port_type(struct pci_dev *pdev)</span>
 	pos = pci_find_capability(pdev, PCI_CAP_ID_EXP);
 	if (!pos)
 		return;
<span class="p_add">+</span>
 	pdev-&gt;pcie_cap = pos;
 	pci_read_config_word(pdev, pos + PCI_EXP_FLAGS, &amp;reg16);
 	pdev-&gt;pcie_flags_reg = reg16;
<span class="p_chunk">@@ -1057,13 +1058,14 @@</span> <span class="p_context"> void set_pcie_port_type(struct pci_dev *pdev)</span>
 	pdev-&gt;pcie_mpss = reg16 &amp; PCI_EXP_DEVCAP_PAYLOAD;
 
 	/*
<span class="p_del">-	 * A Root Port is always the upstream end of a Link.  No PCIe</span>
<span class="p_del">-	 * component has two Links.  Two Links are connected by a Switch</span>
<span class="p_del">-	 * that has a Port on each Link and internal logic to connect the</span>
<span class="p_del">-	 * two Ports.</span>
<span class="p_add">+	 * A Root Port or a PCI-to-PCIe bridge is always the upstream end</span>
<span class="p_add">+	 * of a Link.  No PCIe component has two Links.  Two Links are</span>
<span class="p_add">+	 * connected by a Switch that has a Port on each Link and internal</span>
<span class="p_add">+	 * logic to connect the two Ports.</span>
 	 */
 	type = pci_pcie_type(pdev);
<span class="p_del">-	if (type == PCI_EXP_TYPE_ROOT_PORT)</span>
<span class="p_add">+	if (type == PCI_EXP_TYPE_ROOT_PORT ||</span>
<span class="p_add">+	    type == PCI_EXP_TYPE_PCIE_BRIDGE)</span>
 		pdev-&gt;has_secondary_link = 1;
 	else if (type == PCI_EXP_TYPE_UPSTREAM ||
 		 type == PCI_EXP_TYPE_DOWNSTREAM) {
<span class="p_header">diff --git a/drivers/rpmsg/rpmsg_core.c b/drivers/rpmsg/rpmsg_core.c</span>
<span class="p_header">index b6ea9ffa7381..e0a629eaceab 100644</span>
<span class="p_header">--- a/drivers/rpmsg/rpmsg_core.c</span>
<span class="p_header">+++ b/drivers/rpmsg/rpmsg_core.c</span>
<span class="p_chunk">@@ -411,8 +411,8 @@</span> <span class="p_context"> int rpmsg_register_device(struct rpmsg_device *rpdev)</span>
 	struct device *dev = &amp;rpdev-&gt;dev;
 	int ret;
 
<span class="p_del">-	dev_set_name(&amp;rpdev-&gt;dev, &quot;%s:%s&quot;,</span>
<span class="p_del">-		     dev_name(dev-&gt;parent), rpdev-&gt;id.name);</span>
<span class="p_add">+	dev_set_name(&amp;rpdev-&gt;dev, &quot;%s.%s.%d.%d&quot;, dev_name(dev-&gt;parent),</span>
<span class="p_add">+		     rpdev-&gt;id.name, rpdev-&gt;src, rpdev-&gt;dst);</span>
 
 	rpdev-&gt;dev.bus = &amp;rpmsg_bus;
 	rpdev-&gt;dev.release = rpmsg_release_device;
<span class="p_header">diff --git a/drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c b/drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c</span>
<span class="p_header">index 608140f16d98..e3b911c895b4 100644</span>
<span class="p_header">--- a/drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c</span>
<span class="p_header">+++ b/drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c</span>
<span class="p_chunk">@@ -45,6 +45,7 @@</span> <span class="p_context"></span>
 
 #define	INITIAL_SRP_LIMIT	800
 #define	DEFAULT_MAX_SECTORS	256
<span class="p_add">+#define MAX_TXU			1024 * 1024</span>
 
 static uint max_vdma_size = MAX_H_COPY_RDMA;
 
<span class="p_chunk">@@ -1239,7 +1240,7 @@</span> <span class="p_context"> static long ibmvscsis_adapter_info(struct scsi_info *vscsi,</span>
 	}
 
 	info = dma_alloc_coherent(&amp;vscsi-&gt;dma_dev-&gt;dev, sizeof(*info), &amp;token,
<span class="p_del">-				  GFP_KERNEL);</span>
<span class="p_add">+				  GFP_ATOMIC);</span>
 	if (!info) {
 		dev_err(&amp;vscsi-&gt;dev, &quot;bad dma_alloc_coherent %p\n&quot;,
 			iue-&gt;target);
<span class="p_chunk">@@ -1291,7 +1292,7 @@</span> <span class="p_context"> static long ibmvscsis_adapter_info(struct scsi_info *vscsi,</span>
 	info-&gt;mad_version = cpu_to_be32(MAD_VERSION_1);
 	info-&gt;os_type = cpu_to_be32(LINUX);
 	memset(&amp;info-&gt;port_max_txu[0], 0, sizeof(info-&gt;port_max_txu));
<span class="p_del">-	info-&gt;port_max_txu[0] = cpu_to_be32(128 * PAGE_SIZE);</span>
<span class="p_add">+	info-&gt;port_max_txu[0] = cpu_to_be32(MAX_TXU);</span>
 
 	dma_wmb();
 	rc = h_copy_rdma(sizeof(*info), vscsi-&gt;dds.window[LOCAL].liobn,
<span class="p_chunk">@@ -1357,7 +1358,7 @@</span> <span class="p_context"> static int ibmvscsis_cap_mad(struct scsi_info *vscsi, struct iu_entry *iue)</span>
 	}
 
 	cap = dma_alloc_coherent(&amp;vscsi-&gt;dma_dev-&gt;dev, olen, &amp;token,
<span class="p_del">-				 GFP_KERNEL);</span>
<span class="p_add">+				 GFP_ATOMIC);</span>
 	if (!cap) {
 		dev_err(&amp;vscsi-&gt;dev, &quot;bad dma_alloc_coherent %p\n&quot;,
 			iue-&gt;target);
<span class="p_header">diff --git a/drivers/scsi/mpt3sas/mpt3sas_base.h b/drivers/scsi/mpt3sas/mpt3sas_base.h</span>
<span class="p_header">index 3e71bc1b4a80..7008061c4b5b 100644</span>
<span class="p_header">--- a/drivers/scsi/mpt3sas/mpt3sas_base.h</span>
<span class="p_header">+++ b/drivers/scsi/mpt3sas/mpt3sas_base.h</span>
<span class="p_chunk">@@ -393,6 +393,7 @@</span> <span class="p_context"> struct MPT3SAS_TARGET {</span>
  * @eedp_enable: eedp support enable bit
  * @eedp_type: 0(type_1), 1(type_2), 2(type_3)
  * @eedp_block_length: block size
<span class="p_add">+ * @ata_command_pending: SATL passthrough outstanding for device</span>
  */
 struct MPT3SAS_DEVICE {
 	struct MPT3SAS_TARGET *sas_target;
<span class="p_chunk">@@ -402,6 +403,17 @@</span> <span class="p_context"> struct MPT3SAS_DEVICE {</span>
 	u8	block;
 	u8	tlr_snoop_check;
 	u8	ignore_delay_remove;
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Bug workaround for SATL handling: the mpt2/3sas firmware</span>
<span class="p_add">+	 * doesn&#39;t return BUSY or TASK_SET_FULL for subsequent</span>
<span class="p_add">+	 * commands while a SATL pass through is in operation as the</span>
<span class="p_add">+	 * spec requires, it simply does nothing with them until the</span>
<span class="p_add">+	 * pass through completes, causing them possibly to timeout if</span>
<span class="p_add">+	 * the passthrough is a long executing command (like format or</span>
<span class="p_add">+	 * secure erase).  This variable allows us to do the right</span>
<span class="p_add">+	 * thing while a SATL command is pending.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	unsigned long ata_command_pending;</span>
 };
 
 #define MPT3_CMD_NOT_USED	0x8000	/* free */
<span class="p_header">diff --git a/drivers/scsi/mpt3sas/mpt3sas_scsih.c b/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_header">index 1c4744e78173..f84a6087cebd 100644</span>
<span class="p_header">--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_header">+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_chunk">@@ -3885,9 +3885,18 @@</span> <span class="p_context"> _scsih_temp_threshold_events(struct MPT3SAS_ADAPTER *ioc,</span>
 	}
 }
 
<span class="p_del">-static inline bool ata_12_16_cmd(struct scsi_cmnd *scmd)</span>
<span class="p_add">+static int _scsih_set_satl_pending(struct scsi_cmnd *scmd, bool pending)</span>
 {
<span class="p_del">-	return (scmd-&gt;cmnd[0] == ATA_12 || scmd-&gt;cmnd[0] == ATA_16);</span>
<span class="p_add">+	struct MPT3SAS_DEVICE *priv = scmd-&gt;device-&gt;hostdata;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (scmd-&gt;cmnd[0] != ATA_12 &amp;&amp; scmd-&gt;cmnd[0] != ATA_16)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pending)</span>
<span class="p_add">+		return test_and_set_bit(0, &amp;priv-&gt;ata_command_pending);</span>
<span class="p_add">+</span>
<span class="p_add">+	clear_bit(0, &amp;priv-&gt;ata_command_pending);</span>
<span class="p_add">+	return 0;</span>
 }
 
 /**
<span class="p_chunk">@@ -3911,9 +3920,7 @@</span> <span class="p_context"> _scsih_flush_running_cmds(struct MPT3SAS_ADAPTER *ioc)</span>
 		if (!scmd)
 			continue;
 		count++;
<span class="p_del">-		if (ata_12_16_cmd(scmd))</span>
<span class="p_del">-			scsi_internal_device_unblock(scmd-&gt;device,</span>
<span class="p_del">-							SDEV_RUNNING);</span>
<span class="p_add">+		_scsih_set_satl_pending(scmd, false);</span>
 		mpt3sas_base_free_smid(ioc, smid);
 		scsi_dma_unmap(scmd);
 		if (ioc-&gt;pci_error_recovery)
<span class="p_chunk">@@ -4044,13 +4051,6 @@</span> <span class="p_context"> scsih_qcmd(struct Scsi_Host *shost, struct scsi_cmnd *scmd)</span>
 	if (ioc-&gt;logging_level &amp; MPT_DEBUG_SCSI)
 		scsi_print_command(scmd);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Lock the device for any subsequent command until command is</span>
<span class="p_del">-	 * done.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (ata_12_16_cmd(scmd))</span>
<span class="p_del">-		scsi_internal_device_block(scmd-&gt;device);</span>
<span class="p_del">-</span>
 	sas_device_priv_data = scmd-&gt;device-&gt;hostdata;
 	if (!sas_device_priv_data || !sas_device_priv_data-&gt;sas_target) {
 		scmd-&gt;result = DID_NO_CONNECT &lt;&lt; 16;
<span class="p_chunk">@@ -4064,6 +4064,19 @@</span> <span class="p_context"> scsih_qcmd(struct Scsi_Host *shost, struct scsi_cmnd *scmd)</span>
 		return 0;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Bug work around for firmware SATL handling.  The loop</span>
<span class="p_add">+	 * is based on atomic operations and ensures consistency</span>
<span class="p_add">+	 * since we&#39;re lockless at this point</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		if (test_bit(0, &amp;sas_device_priv_data-&gt;ata_command_pending)) {</span>
<span class="p_add">+			scmd-&gt;result = SAM_STAT_BUSY;</span>
<span class="p_add">+			scmd-&gt;scsi_done(scmd);</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while (_scsih_set_satl_pending(scmd, true));</span>
<span class="p_add">+</span>
 	sas_target_priv_data = sas_device_priv_data-&gt;sas_target;
 
 	/* invalid device handle */
<span class="p_chunk">@@ -4626,8 +4639,7 @@</span> <span class="p_context"> _scsih_io_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)</span>
 	if (scmd == NULL)
 		return 1;
 
<span class="p_del">-	if (ata_12_16_cmd(scmd))</span>
<span class="p_del">-		scsi_internal_device_unblock(scmd-&gt;device, SDEV_RUNNING);</span>
<span class="p_add">+	_scsih_set_satl_pending(scmd, false);</span>
 
 	mpi_request = mpt3sas_base_get_msg_frame(ioc, smid);
 
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_os.c b/drivers/scsi/qla2xxx/qla_os.c</span>
<span class="p_header">index 56d6142852a5..078d797cb492 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_os.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_os.c</span>
<span class="p_chunk">@@ -3489,7 +3489,7 @@</span> <span class="p_context"> qla2x00_mem_alloc(struct qla_hw_data *ha, uint16_t req_len, uint16_t rsp_len,</span>
 				sizeof(struct ct6_dsd), 0,
 				SLAB_HWCACHE_ALIGN, NULL);
 			if (!ctx_cachep)
<span class="p_del">-				goto fail_free_gid_list;</span>
<span class="p_add">+				goto fail_free_srb_mempool;</span>
 		}
 		ha-&gt;ctx_mempool = mempool_create_slab_pool(SRB_MIN_REQ,
 			ctx_cachep);
<span class="p_chunk">@@ -3642,7 +3642,7 @@</span> <span class="p_context"> qla2x00_mem_alloc(struct qla_hw_data *ha, uint16_t req_len, uint16_t rsp_len,</span>
 	ha-&gt;loop_id_map = kzalloc(BITS_TO_LONGS(LOOPID_MAP_SIZE) * sizeof(long),
 	    GFP_KERNEL);
 	if (!ha-&gt;loop_id_map)
<span class="p_del">-		goto fail_async_pd;</span>
<span class="p_add">+		goto fail_loop_id_map;</span>
 	else {
 		qla2x00_set_reserved_loop_ids(ha);
 		ql_dbg_pci(ql_dbg_init, ha-&gt;pdev, 0x0123,
<span class="p_chunk">@@ -3651,6 +3651,8 @@</span> <span class="p_context"> qla2x00_mem_alloc(struct qla_hw_data *ha, uint16_t req_len, uint16_t rsp_len,</span>
 
 	return 0;
 
<span class="p_add">+fail_loop_id_map:</span>
<span class="p_add">+	dma_pool_free(ha-&gt;s_dma_pool, ha-&gt;async_pd, ha-&gt;async_pd_dma);</span>
 fail_async_pd:
 	dma_pool_free(ha-&gt;s_dma_pool, ha-&gt;ex_init_cb, ha-&gt;ex_init_cb_dma);
 fail_ex_init_cb:
<span class="p_chunk">@@ -3678,6 +3680,10 @@</span> <span class="p_context"> qla2x00_mem_alloc(struct qla_hw_data *ha, uint16_t req_len, uint16_t rsp_len,</span>
 	dma_pool_free(ha-&gt;s_dma_pool, ha-&gt;ms_iocb, ha-&gt;ms_iocb_dma);
 	ha-&gt;ms_iocb = NULL;
 	ha-&gt;ms_iocb_dma = 0;
<span class="p_add">+</span>
<span class="p_add">+	if (ha-&gt;sns_cmd)</span>
<span class="p_add">+		dma_free_coherent(&amp;ha-&gt;pdev-&gt;dev, sizeof(struct sns_cmd_pkt),</span>
<span class="p_add">+		    ha-&gt;sns_cmd, ha-&gt;sns_cmd_dma);</span>
 fail_dma_pool:
 	if (IS_QLA82XX(ha) || ql2xenabledif) {
 		dma_pool_destroy(ha-&gt;fcp_cmnd_dma_pool);
<span class="p_chunk">@@ -3695,10 +3701,12 @@</span> <span class="p_context"> qla2x00_mem_alloc(struct qla_hw_data *ha, uint16_t req_len, uint16_t rsp_len,</span>
 	kfree(ha-&gt;nvram);
 	ha-&gt;nvram = NULL;
 fail_free_ctx_mempool:
<span class="p_del">-	mempool_destroy(ha-&gt;ctx_mempool);</span>
<span class="p_add">+	if (ha-&gt;ctx_mempool)</span>
<span class="p_add">+		mempool_destroy(ha-&gt;ctx_mempool);</span>
 	ha-&gt;ctx_mempool = NULL;
 fail_free_srb_mempool:
<span class="p_del">-	mempool_destroy(ha-&gt;srb_mempool);</span>
<span class="p_add">+	if (ha-&gt;srb_mempool)</span>
<span class="p_add">+		mempool_destroy(ha-&gt;srb_mempool);</span>
 	ha-&gt;srb_mempool = NULL;
 fail_free_gid_list:
 	dma_free_coherent(&amp;ha-&gt;pdev-&gt;dev, qla2x00_gid_list_size(ha),
<span class="p_header">diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c</span>
<span class="p_header">index 8c9a35c91705..50adabbb5808 100644</span>
<span class="p_header">--- a/drivers/scsi/ses.c</span>
<span class="p_header">+++ b/drivers/scsi/ses.c</span>
<span class="p_chunk">@@ -587,7 +587,7 @@</span> <span class="p_context"> static void ses_match_to_enclosure(struct enclosure_device *edev,</span>
 
 	ses_enclosure_data_process(edev, to_scsi_device(edev-&gt;edev.parent), 0);
 
<span class="p_del">-	if (scsi_is_sas_rphy(&amp;sdev-&gt;sdev_gendev))</span>
<span class="p_add">+	if (scsi_is_sas_rphy(sdev-&gt;sdev_target-&gt;dev.parent))</span>
 		efd.addr = sas_get_address(sdev);
 
 	if (efd.addr) {
<span class="p_header">diff --git a/drivers/soc/ti/wkup_m3_ipc.c b/drivers/soc/ti/wkup_m3_ipc.c</span>
<span class="p_header">index 8823cc81ae45..5bb376009d98 100644</span>
<span class="p_header">--- a/drivers/soc/ti/wkup_m3_ipc.c</span>
<span class="p_header">+++ b/drivers/soc/ti/wkup_m3_ipc.c</span>
<span class="p_chunk">@@ -459,6 +459,7 @@</span> <span class="p_context"> static int wkup_m3_ipc_probe(struct platform_device *pdev)</span>
 
 	if (IS_ERR(task)) {
 		dev_err(dev, &quot;can&#39;t create rproc_boot thread\n&quot;);
<span class="p_add">+		ret = PTR_ERR(task);</span>
 		goto err_put_rproc;
 	}
 
<span class="p_header">diff --git a/drivers/spi/spi-pxa2xx.c b/drivers/spi/spi-pxa2xx.c</span>
<span class="p_header">index dd7b5b47291d..d6239fa718be 100644</span>
<span class="p_header">--- a/drivers/spi/spi-pxa2xx.c</span>
<span class="p_header">+++ b/drivers/spi/spi-pxa2xx.c</span>
<span class="p_chunk">@@ -1690,6 +1690,7 @@</span> <span class="p_context"> static int pxa2xx_spi_probe(struct platform_device *pdev)</span>
 		pxa2xx_spi_write(drv_data, SSCR1, tmp);
 		tmp = SSCR0_SCR(2) | SSCR0_Motorola | SSCR0_DataSize(8);
 		pxa2xx_spi_write(drv_data, SSCR0, tmp);
<span class="p_add">+		break;</span>
 	default:
 		tmp = SSCR1_RxTresh(RX_THRESH_DFLT) |
 		      SSCR1_TxTresh(TX_THRESH_DFLT);
<span class="p_header">diff --git a/drivers/staging/media/s5p-cec/s5p_cec.c b/drivers/staging/media/s5p-cec/s5p_cec.c</span>
<span class="p_header">index 1780a08b73c9..58d756231136 100644</span>
<span class="p_header">--- a/drivers/staging/media/s5p-cec/s5p_cec.c</span>
<span class="p_header">+++ b/drivers/staging/media/s5p-cec/s5p_cec.c</span>
<span class="p_chunk">@@ -231,7 +231,7 @@</span> <span class="p_context"> static int s5p_cec_remove(struct platform_device *pdev)</span>
 	return 0;
 }
 
<span class="p_del">-static int s5p_cec_runtime_suspend(struct device *dev)</span>
<span class="p_add">+static int __maybe_unused s5p_cec_runtime_suspend(struct device *dev)</span>
 {
 	struct s5p_cec_dev *cec = dev_get_drvdata(dev);
 
<span class="p_chunk">@@ -239,7 +239,7 @@</span> <span class="p_context"> static int s5p_cec_runtime_suspend(struct device *dev)</span>
 	return 0;
 }
 
<span class="p_del">-static int s5p_cec_runtime_resume(struct device *dev)</span>
<span class="p_add">+static int __maybe_unused s5p_cec_runtime_resume(struct device *dev)</span>
 {
 	struct s5p_cec_dev *cec = dev_get_drvdata(dev);
 	int ret;
<span class="p_header">diff --git a/drivers/xen/swiotlb-xen.c b/drivers/xen/swiotlb-xen.c</span>
<span class="p_header">index 87e6035c9e81..8e7a3d646531 100644</span>
<span class="p_header">--- a/drivers/xen/swiotlb-xen.c</span>
<span class="p_header">+++ b/drivers/xen/swiotlb-xen.c</span>
<span class="p_chunk">@@ -392,7 +392,7 @@</span> <span class="p_context"> dma_addr_t xen_swiotlb_map_page(struct device *dev, struct page *page,</span>
 	if (dma_capable(dev, dev_addr, size) &amp;&amp;
 	    !range_straddles_page_boundary(phys, size) &amp;&amp;
 		!xen_arch_need_swiotlb(dev, phys, dev_addr) &amp;&amp;
<span class="p_del">-		!swiotlb_force) {</span>
<span class="p_add">+		(swiotlb_force != SWIOTLB_FORCE)) {</span>
 		/* we are not interested in the dma_addr returned by
 		 * xen_dma_map_page, only in the potential cache flushes executed
 		 * by the function. */
<span class="p_chunk">@@ -549,7 +549,7 @@</span> <span class="p_context"> xen_swiotlb_map_sg_attrs(struct device *hwdev, struct scatterlist *sgl,</span>
 		phys_addr_t paddr = sg_phys(sg);
 		dma_addr_t dev_addr = xen_phys_to_bus(paddr);
 
<span class="p_del">-		if (swiotlb_force ||</span>
<span class="p_add">+		if (swiotlb_force == SWIOTLB_FORCE ||</span>
 		    xen_arch_need_swiotlb(hwdev, paddr, dev_addr) ||
 		    !dma_capable(hwdev, dev_addr, sg-&gt;length) ||
 		    range_straddles_page_boundary(paddr, sg-&gt;length)) {
<span class="p_header">diff --git a/fs/ceph/caps.c b/fs/ceph/caps.c</span>
<span class="p_header">index 16e6ded0b7f2..f3f21105b860 100644</span>
<span class="p_header">--- a/fs/ceph/caps.c</span>
<span class="p_header">+++ b/fs/ceph/caps.c</span>
<span class="p_chunk">@@ -2507,9 +2507,20 @@</span> <span class="p_context"> int ceph_get_caps(struct ceph_inode_info *ci, int need, int want,</span>
 			if (err &lt; 0)
 				ret = err;
 		} else {
<span class="p_del">-			ret = wait_event_interruptible(ci-&gt;i_cap_wq,</span>
<span class="p_del">-					try_get_cap_refs(ci, need, want, endoff,</span>
<span class="p_del">-							 true, &amp;_got, &amp;err));</span>
<span class="p_add">+			DEFINE_WAIT_FUNC(wait, woken_wake_function);</span>
<span class="p_add">+			add_wait_queue(&amp;ci-&gt;i_cap_wq, &amp;wait);</span>
<span class="p_add">+</span>
<span class="p_add">+			while (!try_get_cap_refs(ci, need, want, endoff,</span>
<span class="p_add">+						 true, &amp;_got, &amp;err)) {</span>
<span class="p_add">+				if (signal_pending(current)) {</span>
<span class="p_add">+					ret = -ERESTARTSYS;</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
<span class="p_add">+				wait_woken(&amp;wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			remove_wait_queue(&amp;ci-&gt;i_cap_wq, &amp;wait);</span>
<span class="p_add">+</span>
 			if (err == -EAGAIN)
 				continue;
 			if (err &lt; 0)
<span class="p_header">diff --git a/fs/ceph/dir.c b/fs/ceph/dir.c</span>
<span class="p_header">index a594c7879cc2..1afa11191000 100644</span>
<span class="p_header">--- a/fs/ceph/dir.c</span>
<span class="p_header">+++ b/fs/ceph/dir.c</span>
<span class="p_chunk">@@ -1255,7 +1255,8 @@</span> <span class="p_context"> static int ceph_d_revalidate(struct dentry *dentry, unsigned int flags)</span>
 		struct ceph_mds_client *mdsc =
 			ceph_sb_to_client(dir-&gt;i_sb)-&gt;mdsc;
 		struct ceph_mds_request *req;
<span class="p_del">-		int op, mask, err;</span>
<span class="p_add">+		int op, err;</span>
<span class="p_add">+		u32 mask;</span>
 
 		if (flags &amp; LOOKUP_RCU)
 			return -ECHILD;
<span class="p_chunk">@@ -1270,7 +1271,7 @@</span> <span class="p_context"> static int ceph_d_revalidate(struct dentry *dentry, unsigned int flags)</span>
 			mask = CEPH_STAT_CAP_INODE | CEPH_CAP_AUTH_SHARED;
 			if (ceph_security_xattr_wanted(dir))
 				mask |= CEPH_CAP_XATTR_SHARED;
<span class="p_del">-			req-&gt;r_args.getattr.mask = mask;</span>
<span class="p_add">+			req-&gt;r_args.getattr.mask = cpu_to_le32(mask);</span>
 
 			err = ceph_mdsc_do_request(mdsc, NULL, req);
 			switch (err) {
<span class="p_header">diff --git a/fs/ceph/inode.c b/fs/ceph/inode.c</span>
<span class="p_header">index ef4d04647325..12f2252f6c98 100644</span>
<span class="p_header">--- a/fs/ceph/inode.c</span>
<span class="p_header">+++ b/fs/ceph/inode.c</span>
<span class="p_chunk">@@ -305,7 +305,8 @@</span> <span class="p_context"> static int frag_tree_split_cmp(const void *l, const void *r)</span>
 {
 	struct ceph_frag_tree_split *ls = (struct ceph_frag_tree_split*)l;
 	struct ceph_frag_tree_split *rs = (struct ceph_frag_tree_split*)r;
<span class="p_del">-	return ceph_frag_compare(ls-&gt;frag, rs-&gt;frag);</span>
<span class="p_add">+	return ceph_frag_compare(le32_to_cpu(ls-&gt;frag),</span>
<span class="p_add">+				 le32_to_cpu(rs-&gt;frag));</span>
 }
 
 static bool is_frag_child(u32 f, struct ceph_inode_frag *frag)
<span class="p_header">diff --git a/fs/ceph/mds_client.c b/fs/ceph/mds_client.c</span>
<span class="p_header">index 815acd1a56d4..6a26c7bd1286 100644</span>
<span class="p_header">--- a/fs/ceph/mds_client.c</span>
<span class="p_header">+++ b/fs/ceph/mds_client.c</span>
<span class="p_chunk">@@ -288,12 +288,13 @@</span> <span class="p_context"> static int parse_reply_info_extra(void **p, void *end,</span>
 				  struct ceph_mds_reply_info_parsed *info,
 				  u64 features)
 {
<span class="p_del">-	if (info-&gt;head-&gt;op == CEPH_MDS_OP_GETFILELOCK)</span>
<span class="p_add">+	u32 op = le32_to_cpu(info-&gt;head-&gt;op);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (op == CEPH_MDS_OP_GETFILELOCK)</span>
 		return parse_reply_info_filelock(p, end, info, features);
<span class="p_del">-	else if (info-&gt;head-&gt;op == CEPH_MDS_OP_READDIR ||</span>
<span class="p_del">-		 info-&gt;head-&gt;op == CEPH_MDS_OP_LSSNAP)</span>
<span class="p_add">+	else if (op == CEPH_MDS_OP_READDIR || op == CEPH_MDS_OP_LSSNAP)</span>
 		return parse_reply_info_dir(p, end, info, features);
<span class="p_del">-	else if (info-&gt;head-&gt;op == CEPH_MDS_OP_CREATE)</span>
<span class="p_add">+	else if (op == CEPH_MDS_OP_CREATE)</span>
 		return parse_reply_info_create(p, end, info, features);
 	else
 		return -EIO;
<span class="p_header">diff --git a/fs/fuse/dev.c b/fs/fuse/dev.c</span>
<span class="p_header">index 70ea57c7b6bb..4e06a27ed7f8 100644</span>
<span class="p_header">--- a/fs/fuse/dev.c</span>
<span class="p_header">+++ b/fs/fuse/dev.c</span>
<span class="p_chunk">@@ -2025,7 +2025,6 @@</span> <span class="p_context"> static void end_requests(struct fuse_conn *fc, struct list_head *head)</span>
 		struct fuse_req *req;
 		req = list_entry(head-&gt;next, struct fuse_req, list);
 		req-&gt;out.h.error = -ECONNABORTED;
<span class="p_del">-		clear_bit(FR_PENDING, &amp;req-&gt;flags);</span>
 		clear_bit(FR_SENT, &amp;req-&gt;flags);
 		list_del_init(&amp;req-&gt;list);
 		request_end(fc, req);
<span class="p_chunk">@@ -2103,6 +2102,8 @@</span> <span class="p_context"> void fuse_abort_conn(struct fuse_conn *fc)</span>
 		spin_lock(&amp;fiq-&gt;waitq.lock);
 		fiq-&gt;connected = 0;
 		list_splice_init(&amp;fiq-&gt;pending, &amp;to_end2);
<span class="p_add">+		list_for_each_entry(req, &amp;to_end2, list)</span>
<span class="p_add">+			clear_bit(FR_PENDING, &amp;req-&gt;flags);</span>
 		while (forget_pending(fiq))
 			kfree(dequeue_forget(fiq, 1, NULL));
 		wake_up_all_locked(&amp;fiq-&gt;waitq);
<span class="p_header">diff --git a/fs/fuse/dir.c b/fs/fuse/dir.c</span>
<span class="p_header">index 096f79997f75..642c57b8de7b 100644</span>
<span class="p_header">--- a/fs/fuse/dir.c</span>
<span class="p_header">+++ b/fs/fuse/dir.c</span>
<span class="p_chunk">@@ -68,7 +68,7 @@</span> <span class="p_context"> static u64 time_to_jiffies(u64 sec, u32 nsec)</span>
 	if (sec || nsec) {
 		struct timespec64 ts = {
 			sec,
<span class="p_del">-			max_t(u32, nsec, NSEC_PER_SEC - 1)</span>
<span class="p_add">+			min_t(u32, nsec, NSEC_PER_SEC - 1)</span>
 		};
 
 		return get_jiffies_64() + timespec64_to_jiffies(&amp;ts);
<span class="p_header">diff --git a/fs/posix_acl.c b/fs/posix_acl.c</span>
<span class="p_header">index 595522022aca..c9d48dc78495 100644</span>
<span class="p_header">--- a/fs/posix_acl.c</span>
<span class="p_header">+++ b/fs/posix_acl.c</span>
<span class="p_chunk">@@ -922,11 +922,10 @@</span> <span class="p_context"> int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 	int error;
 
 	if (type == ACL_TYPE_ACCESS) {
<span class="p_del">-		error = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-		if (error &lt; 0)</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-		if (error == 0)</span>
<span class="p_del">-			acl = NULL;</span>
<span class="p_add">+		error = posix_acl_update_mode(inode,</span>
<span class="p_add">+				&amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			return error;</span>
 	}
 
 	inode-&gt;i_ctime = current_time(inode);
<span class="p_header">diff --git a/fs/ubifs/tnc.c b/fs/ubifs/tnc.c</span>
<span class="p_header">index fa9a20cc60d6..fe5e8d4970ae 100644</span>
<span class="p_header">--- a/fs/ubifs/tnc.c</span>
<span class="p_header">+++ b/fs/ubifs/tnc.c</span>
<span class="p_chunk">@@ -34,6 +34,11 @@</span> <span class="p_context"></span>
 #include &lt;linux/slab.h&gt;
 #include &quot;ubifs.h&quot;
 
<span class="p_add">+static int try_read_node(const struct ubifs_info *c, void *buf, int type,</span>
<span class="p_add">+			 int len, int lnum, int offs);</span>
<span class="p_add">+static int fallible_read_node(struct ubifs_info *c, const union ubifs_key *key,</span>
<span class="p_add">+			      struct ubifs_zbranch *zbr, void *node);</span>
<span class="p_add">+</span>
 /*
  * Returned codes of &#39;matches_name()&#39; and &#39;fallible_matches_name()&#39; functions.
  * @NAME_LESS: name corresponding to the first argument is less than second
<span class="p_chunk">@@ -402,7 +407,19 @@</span> <span class="p_context"> static int tnc_read_node_nm(struct ubifs_info *c, struct ubifs_zbranch *zbr,</span>
 		return 0;
 	}
 
<span class="p_del">-	err = ubifs_tnc_read_node(c, zbr, node);</span>
<span class="p_add">+	if (c-&gt;replaying) {</span>
<span class="p_add">+		err = fallible_read_node(c, &amp;zbr-&gt;key, zbr, node);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * When the node was not found, return -ENOENT, 0 otherwise.</span>
<span class="p_add">+		 * Negative return codes stay as-is.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (err == 0)</span>
<span class="p_add">+			err = -ENOENT;</span>
<span class="p_add">+		else if (err == 1)</span>
<span class="p_add">+			err = 0;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		err = ubifs_tnc_read_node(c, zbr, node);</span>
<span class="p_add">+	}</span>
 	if (err)
 		return err;
 
<span class="p_chunk">@@ -2766,7 +2783,11 @@</span> <span class="p_context"> struct ubifs_dent_node *ubifs_tnc_next_ent(struct ubifs_info *c,</span>
 	if (nm-&gt;name) {
 		if (err) {
 			/* Handle collisions */
<span class="p_del">-			err = resolve_collision(c, key, &amp;znode, &amp;n, nm);</span>
<span class="p_add">+			if (c-&gt;replaying)</span>
<span class="p_add">+				err = fallible_resolve_collision(c, key, &amp;znode, &amp;n,</span>
<span class="p_add">+							 nm, 0);</span>
<span class="p_add">+			else</span>
<span class="p_add">+				err = resolve_collision(c, key, &amp;znode, &amp;n, nm);</span>
 			dbg_tnc(&quot;rc returned %d, znode %p, n %d&quot;,
 				err, znode, n);
 			if (unlikely(err &lt; 0))
<span class="p_header">diff --git a/include/dt-bindings/clock/r8a7794-clock.h b/include/dt-bindings/clock/r8a7794-clock.h</span>
<span class="p_header">index 9d02f5317c7c..88e64846cf37 100644</span>
<span class="p_header">--- a/include/dt-bindings/clock/r8a7794-clock.h</span>
<span class="p_header">+++ b/include/dt-bindings/clock/r8a7794-clock.h</span>
<span class="p_chunk">@@ -20,8 +20,7 @@</span> <span class="p_context"></span>
 #define R8A7794_CLK_QSPI		5
 #define R8A7794_CLK_SDH			6
 #define R8A7794_CLK_SD0			7
<span class="p_del">-#define R8A7794_CLK_Z			8</span>
<span class="p_del">-#define R8A7794_CLK_RCAN		9</span>
<span class="p_add">+#define R8A7794_CLK_RCAN		8</span>
 
 /* MSTP0 */
 #define R8A7794_CLK_MSIOF0		0
<span class="p_header">diff --git a/include/linux/rcupdate.h b/include/linux/rcupdate.h</span>
<span class="p_header">index 321f9ed552a9..01f71e1d2e94 100644</span>
<span class="p_header">--- a/include/linux/rcupdate.h</span>
<span class="p_header">+++ b/include/linux/rcupdate.h</span>
<span class="p_chunk">@@ -444,6 +444,10 @@</span> <span class="p_context"> bool __rcu_is_watching(void);</span>
 #error &quot;Unknown RCU implementation specified to kernel configuration&quot;
 #endif
 
<span class="p_add">+#define RCU_SCHEDULER_INACTIVE	0</span>
<span class="p_add">+#define RCU_SCHEDULER_INIT	1</span>
<span class="p_add">+#define RCU_SCHEDULER_RUNNING	2</span>
<span class="p_add">+</span>
 /*
  * init_rcu_head_on_stack()/destroy_rcu_head_on_stack() are needed for dynamic
  * initialization and destruction of rcu_head on the stack. rcu_head structures
<span class="p_header">diff --git a/include/linux/sunrpc/svc_xprt.h b/include/linux/sunrpc/svc_xprt.h</span>
<span class="p_header">index e5d193440374..7440290f64ac 100644</span>
<span class="p_header">--- a/include/linux/sunrpc/svc_xprt.h</span>
<span class="p_header">+++ b/include/linux/sunrpc/svc_xprt.h</span>
<span class="p_chunk">@@ -66,6 +66,7 @@</span> <span class="p_context"> struct svc_xprt {</span>
 #define XPT_LISTENER	10		/* listening endpoint */
 #define XPT_CACHE_AUTH	11		/* cache auth info */
 #define XPT_LOCAL	12		/* connection from loopback interface */
<span class="p_add">+#define XPT_KILL_TEMP   13		/* call xpo_kill_temp_xprt before closing */</span>
 
 	struct svc_serv		*xpt_server;	/* service for transport */
 	atomic_t    	    	xpt_reserved;	/* space on outq that is rsvd */
<span class="p_header">diff --git a/include/linux/swiotlb.h b/include/linux/swiotlb.h</span>
<span class="p_header">index 5f81f8a187f2..d2613536fd03 100644</span>
<span class="p_header">--- a/include/linux/swiotlb.h</span>
<span class="p_header">+++ b/include/linux/swiotlb.h</span>
<span class="p_chunk">@@ -9,7 +9,13 @@</span> <span class="p_context"> struct device;</span>
 struct page;
 struct scatterlist;
 
<span class="p_del">-extern int swiotlb_force;</span>
<span class="p_add">+enum swiotlb_force {</span>
<span class="p_add">+	SWIOTLB_NORMAL,		/* Default - depending on HW DMA mask etc. */</span>
<span class="p_add">+	SWIOTLB_FORCE,		/* swiotlb=force */</span>
<span class="p_add">+	SWIOTLB_NO_FORCE,	/* swiotlb=noforce */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+extern enum swiotlb_force swiotlb_force;</span>
 
 /*
  * Maximum allowable number of contiguous slabs to map,
<span class="p_header">diff --git a/include/trace/events/swiotlb.h b/include/trace/events/swiotlb.h</span>
<span class="p_header">index 7ea4c5e7c448..288c0c54a2b4 100644</span>
<span class="p_header">--- a/include/trace/events/swiotlb.h</span>
<span class="p_header">+++ b/include/trace/events/swiotlb.h</span>
<span class="p_chunk">@@ -11,16 +11,16 @@</span> <span class="p_context"> TRACE_EVENT(swiotlb_bounced,</span>
 	TP_PROTO(struct device *dev,
 		 dma_addr_t dev_addr,
 		 size_t size,
<span class="p_del">-		 int swiotlb_force),</span>
<span class="p_add">+		 enum swiotlb_force swiotlb_force),</span>
 
 	TP_ARGS(dev, dev_addr, size, swiotlb_force),
 
 	TP_STRUCT__entry(
<span class="p_del">-		__string(	dev_name,	dev_name(dev)	)</span>
<span class="p_del">-		__field(	u64,	dma_mask		)</span>
<span class="p_del">-		__field(	dma_addr_t,	dev_addr	)</span>
<span class="p_del">-		__field(	size_t,	size			)</span>
<span class="p_del">-		__field(	int,	swiotlb_force		)</span>
<span class="p_add">+		__string(	dev_name,	dev_name(dev)		)</span>
<span class="p_add">+		__field(	u64,	dma_mask			)</span>
<span class="p_add">+		__field(	dma_addr_t,	dev_addr		)</span>
<span class="p_add">+		__field(	size_t,	size				)</span>
<span class="p_add">+		__field(	enum swiotlb_force,	swiotlb_force	)</span>
 	),
 
 	TP_fast_assign(
<span class="p_chunk">@@ -37,7 +37,10 @@</span> <span class="p_context"> TRACE_EVENT(swiotlb_bounced,</span>
 		__entry-&gt;dma_mask,
 		(unsigned long long)__entry-&gt;dev_addr,
 		__entry-&gt;size,
<span class="p_del">-		__entry-&gt;swiotlb_force ? &quot;swiotlb_force&quot; : &quot;&quot; )</span>
<span class="p_add">+		__print_symbolic(__entry-&gt;swiotlb_force,</span>
<span class="p_add">+			{ SWIOTLB_NORMAL,	&quot;NORMAL&quot; },</span>
<span class="p_add">+			{ SWIOTLB_FORCE,	&quot;FORCE&quot; },</span>
<span class="p_add">+			{ SWIOTLB_NO_FORCE,	&quot;NO_FORCE&quot; }))</span>
 );
 
 #endif /*  _TRACE_SWIOTLB_H */
<span class="p_header">diff --git a/kernel/rcu/rcu.h b/kernel/rcu/rcu.h</span>
<span class="p_header">index 80adef7d4c3d..0d6ff3e471be 100644</span>
<span class="p_header">--- a/kernel/rcu/rcu.h</span>
<span class="p_header">+++ b/kernel/rcu/rcu.h</span>
<span class="p_chunk">@@ -136,6 +136,7 @@</span> <span class="p_context"> int rcu_jiffies_till_stall_check(void);</span>
 #define TPS(x)  tracepoint_string(x)
 
 void rcu_early_boot_tests(void);
<span class="p_add">+void rcu_test_sync_prims(void);</span>
 
 /*
  * This function really isn&#39;t for public consumption, but RCU is special in
<span class="p_header">diff --git a/kernel/rcu/tiny.c b/kernel/rcu/tiny.c</span>
<span class="p_header">index 1898559e6b60..b23a4d076f3d 100644</span>
<span class="p_header">--- a/kernel/rcu/tiny.c</span>
<span class="p_header">+++ b/kernel/rcu/tiny.c</span>
<span class="p_chunk">@@ -185,9 +185,6 @@</span> <span class="p_context"> static __latent_entropy void rcu_process_callbacks(struct softirq_action *unused</span>
  * benefits of doing might_sleep() to reduce latency.)
  *
  * Cool, huh?  (Due to Josh Triplett.)
<span class="p_del">- *</span>
<span class="p_del">- * But we want to make this a static inline later.  The cond_resched()</span>
<span class="p_del">- * currently makes this problematic.</span>
  */
 void synchronize_sched(void)
 {
<span class="p_chunk">@@ -195,7 +192,6 @@</span> <span class="p_context"> void synchronize_sched(void)</span>
 			 lock_is_held(&amp;rcu_lock_map) ||
 			 lock_is_held(&amp;rcu_sched_lock_map),
 			 &quot;Illegal synchronize_sched() in RCU read-side critical section&quot;);
<span class="p_del">-	cond_resched();</span>
 }
 EXPORT_SYMBOL_GPL(synchronize_sched);
 
<span class="p_header">diff --git a/kernel/rcu/tiny_plugin.h b/kernel/rcu/tiny_plugin.h</span>
<span class="p_header">index 196f0302e2f4..c64b827ecbca 100644</span>
<span class="p_header">--- a/kernel/rcu/tiny_plugin.h</span>
<span class="p_header">+++ b/kernel/rcu/tiny_plugin.h</span>
<span class="p_chunk">@@ -60,12 +60,17 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(rcu_scheduler_active);</span>
 
 /*
  * During boot, we forgive RCU lockdep issues.  After this function is
<span class="p_del">- * invoked, we start taking RCU lockdep issues seriously.</span>
<span class="p_add">+ * invoked, we start taking RCU lockdep issues seriously.  Note that unlike</span>
<span class="p_add">+ * Tree RCU, Tiny RCU transitions directly from RCU_SCHEDULER_INACTIVE</span>
<span class="p_add">+ * to RCU_SCHEDULER_RUNNING, skipping the RCU_SCHEDULER_INIT stage.</span>
<span class="p_add">+ * The reason for this is that Tiny RCU does not need kthreads, so does</span>
<span class="p_add">+ * not have to care about the fact that the scheduler is half-initialized</span>
<span class="p_add">+ * at a certain phase of the boot process.</span>
  */
 void __init rcu_scheduler_starting(void)
 {
 	WARN_ON(nr_context_switches() &gt; 0);
<span class="p_del">-	rcu_scheduler_active = 1;</span>
<span class="p_add">+	rcu_scheduler_active = RCU_SCHEDULER_RUNNING;</span>
 }
 
 #endif /* #ifdef CONFIG_DEBUG_LOCK_ALLOC */
<span class="p_header">diff --git a/kernel/rcu/tree.c b/kernel/rcu/tree.c</span>
<span class="p_header">index 69a5611a7e7c..10f62c6f48e7 100644</span>
<span class="p_header">--- a/kernel/rcu/tree.c</span>
<span class="p_header">+++ b/kernel/rcu/tree.c</span>
<span class="p_chunk">@@ -127,13 +127,16 @@</span> <span class="p_context"> int rcu_num_nodes __read_mostly = NUM_RCU_NODES; /* Total # rcu_nodes in use. */</span>
 int sysctl_panic_on_rcu_stall __read_mostly;
 
 /*
<span class="p_del">- * The rcu_scheduler_active variable transitions from zero to one just</span>
<span class="p_del">- * before the first task is spawned.  So when this variable is zero, RCU</span>
<span class="p_del">- * can assume that there is but one task, allowing RCU to (for example)</span>
<span class="p_add">+ * The rcu_scheduler_active variable is initialized to the value</span>
<span class="p_add">+ * RCU_SCHEDULER_INACTIVE and transitions RCU_SCHEDULER_INIT just before the</span>
<span class="p_add">+ * first task is spawned.  So when this variable is RCU_SCHEDULER_INACTIVE,</span>
<span class="p_add">+ * RCU can assume that there is but one task, allowing RCU to (for example)</span>
  * optimize synchronize_rcu() to a simple barrier().  When this variable
<span class="p_del">- * is one, RCU must actually do all the hard work required to detect real</span>
<span class="p_del">- * grace periods.  This variable is also used to suppress boot-time false</span>
<span class="p_del">- * positives from lockdep-RCU error checking.</span>
<span class="p_add">+ * is RCU_SCHEDULER_INIT, RCU must actually do all the hard work required</span>
<span class="p_add">+ * to detect real grace periods.  This variable is also used to suppress</span>
<span class="p_add">+ * boot-time false positives from lockdep-RCU error checking.  Finally, it</span>
<span class="p_add">+ * transitions from RCU_SCHEDULER_INIT to RCU_SCHEDULER_RUNNING after RCU</span>
<span class="p_add">+ * is fully initialized, including all of its kthreads having been spawned.</span>
  */
 int rcu_scheduler_active __read_mostly;
 EXPORT_SYMBOL_GPL(rcu_scheduler_active);
<span class="p_chunk">@@ -3985,18 +3988,22 @@</span> <span class="p_context"> static int __init rcu_spawn_gp_kthread(void)</span>
 early_initcall(rcu_spawn_gp_kthread);
 
 /*
<span class="p_del">- * This function is invoked towards the end of the scheduler&#39;s initialization</span>
<span class="p_del">- * process.  Before this is called, the idle task might contain</span>
<span class="p_del">- * RCU read-side critical sections (during which time, this idle</span>
<span class="p_del">- * task is booting the system).  After this function is called, the</span>
<span class="p_del">- * idle tasks are prohibited from containing RCU read-side critical</span>
<span class="p_del">- * sections.  This function also enables RCU lockdep checking.</span>
<span class="p_add">+ * This function is invoked towards the end of the scheduler&#39;s</span>
<span class="p_add">+ * initialization process.  Before this is called, the idle task might</span>
<span class="p_add">+ * contain synchronous grace-period primitives (during which time, this idle</span>
<span class="p_add">+ * task is booting the system, and such primitives are no-ops).  After this</span>
<span class="p_add">+ * function is called, any synchronous grace-period primitives are run as</span>
<span class="p_add">+ * expedited, with the requesting task driving the grace period forward.</span>
<span class="p_add">+ * A later core_initcall() rcu_exp_runtime_mode() will switch to full</span>
<span class="p_add">+ * runtime RCU functionality.</span>
  */
 void rcu_scheduler_starting(void)
 {
 	WARN_ON(num_online_cpus() != 1);
 	WARN_ON(nr_context_switches() &gt; 0);
<span class="p_del">-	rcu_scheduler_active = 1;</span>
<span class="p_add">+	rcu_test_sync_prims();</span>
<span class="p_add">+	rcu_scheduler_active = RCU_SCHEDULER_INIT;</span>
<span class="p_add">+	rcu_test_sync_prims();</span>
 }
 
 /*
<span class="p_header">diff --git a/kernel/rcu/tree_exp.h b/kernel/rcu/tree_exp.h</span>
<span class="p_header">index 24343eb87b58..78eba4120d46 100644</span>
<span class="p_header">--- a/kernel/rcu/tree_exp.h</span>
<span class="p_header">+++ b/kernel/rcu/tree_exp.h</span>
<span class="p_chunk">@@ -522,18 +522,28 @@</span> <span class="p_context"> struct rcu_exp_work {</span>
 };
 
 /*
<span class="p_add">+ * Common code to drive an expedited grace period forward, used by</span>
<span class="p_add">+ * workqueues and mid-boot-time tasks.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void rcu_exp_sel_wait_wake(struct rcu_state *rsp,</span>
<span class="p_add">+				  smp_call_func_t func, unsigned long s)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Initialize the rcu_node tree in preparation for the wait. */</span>
<span class="p_add">+	sync_rcu_exp_select_cpus(rsp, func);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Wait and clean up, including waking everyone. */</span>
<span class="p_add">+	rcu_exp_wait_wake(rsp, s);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Work-queue handler to drive an expedited grace period forward.
  */
 static void wait_rcu_exp_gp(struct work_struct *wp)
 {
 	struct rcu_exp_work *rewp;
 
<span class="p_del">-	/* Initialize the rcu_node tree in preparation for the wait. */</span>
 	rewp = container_of(wp, struct rcu_exp_work, rew_work);
<span class="p_del">-	sync_rcu_exp_select_cpus(rewp-&gt;rew_rsp, rewp-&gt;rew_func);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Wait and clean up, including waking everyone. */</span>
<span class="p_del">-	rcu_exp_wait_wake(rewp-&gt;rew_rsp, rewp-&gt;rew_s);</span>
<span class="p_add">+	rcu_exp_sel_wait_wake(rewp-&gt;rew_rsp, rewp-&gt;rew_func, rewp-&gt;rew_s);</span>
 }
 
 /*
<span class="p_chunk">@@ -559,12 +569,18 @@</span> <span class="p_context"> static void _synchronize_rcu_expedited(struct rcu_state *rsp,</span>
 	if (exp_funnel_lock(rsp, s))
 		return;  /* Someone else did our work for us. */
 
<span class="p_del">-	/* Marshall arguments and schedule the expedited grace period. */</span>
<span class="p_del">-	rew.rew_func = func;</span>
<span class="p_del">-	rew.rew_rsp = rsp;</span>
<span class="p_del">-	rew.rew_s = s;</span>
<span class="p_del">-	INIT_WORK_ONSTACK(&amp;rew.rew_work, wait_rcu_exp_gp);</span>
<span class="p_del">-	schedule_work(&amp;rew.rew_work);</span>
<span class="p_add">+	/* Ensure that load happens before action based on it. */</span>
<span class="p_add">+	if (unlikely(rcu_scheduler_active == RCU_SCHEDULER_INIT)) {</span>
<span class="p_add">+		/* Direct call during scheduler init and early_initcalls(). */</span>
<span class="p_add">+		rcu_exp_sel_wait_wake(rsp, func, s);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* Marshall arguments &amp; schedule the expedited grace period. */</span>
<span class="p_add">+		rew.rew_func = func;</span>
<span class="p_add">+		rew.rew_rsp = rsp;</span>
<span class="p_add">+		rew.rew_s = s;</span>
<span class="p_add">+		INIT_WORK_ONSTACK(&amp;rew.rew_work, wait_rcu_exp_gp);</span>
<span class="p_add">+		schedule_work(&amp;rew.rew_work);</span>
<span class="p_add">+	}</span>
 
 	/* Wait for expedited grace period to complete. */
 	rdp = per_cpu_ptr(rsp-&gt;rda, raw_smp_processor_id());
<span class="p_chunk">@@ -666,6 +682,8 @@</span> <span class="p_context"> void synchronize_rcu_expedited(void)</span>
 {
 	struct rcu_state *rsp = rcu_state_p;
 
<span class="p_add">+	if (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)</span>
<span class="p_add">+		return;</span>
 	_synchronize_rcu_expedited(rsp, sync_rcu_exp_handler);
 }
 EXPORT_SYMBOL_GPL(synchronize_rcu_expedited);
<span class="p_chunk">@@ -683,3 +701,15 @@</span> <span class="p_context"> void synchronize_rcu_expedited(void)</span>
 EXPORT_SYMBOL_GPL(synchronize_rcu_expedited);
 
 #endif /* #else #ifdef CONFIG_PREEMPT_RCU */
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Switch to run-time mode once Tree RCU has fully initialized.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int __init rcu_exp_runtime_mode(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	rcu_test_sync_prims();</span>
<span class="p_add">+	rcu_scheduler_active = RCU_SCHEDULER_RUNNING;</span>
<span class="p_add">+	rcu_test_sync_prims();</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+core_initcall(rcu_exp_runtime_mode);</span>
<span class="p_header">diff --git a/kernel/rcu/tree_plugin.h b/kernel/rcu/tree_plugin.h</span>
<span class="p_header">index 85c5a883c6e3..56583e764ebf 100644</span>
<span class="p_header">--- a/kernel/rcu/tree_plugin.h</span>
<span class="p_header">+++ b/kernel/rcu/tree_plugin.h</span>
<span class="p_chunk">@@ -670,7 +670,7 @@</span> <span class="p_context"> void synchronize_rcu(void)</span>
 			 lock_is_held(&amp;rcu_lock_map) ||
 			 lock_is_held(&amp;rcu_sched_lock_map),
 			 &quot;Illegal synchronize_rcu() in RCU read-side critical section&quot;);
<span class="p_del">-	if (!rcu_scheduler_active)</span>
<span class="p_add">+	if (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)</span>
 		return;
 	if (rcu_gp_is_expedited())
 		synchronize_rcu_expedited();
<span class="p_header">diff --git a/kernel/rcu/update.c b/kernel/rcu/update.c</span>
<span class="p_header">index f19271dce0a9..4f6db7e6a117 100644</span>
<span class="p_header">--- a/kernel/rcu/update.c</span>
<span class="p_header">+++ b/kernel/rcu/update.c</span>
<span class="p_chunk">@@ -121,11 +121,14 @@</span> <span class="p_context"> EXPORT_SYMBOL(rcu_read_lock_sched_held);</span>
  * Should expedited grace-period primitives always fall back to their
  * non-expedited counterparts?  Intended for use within RCU.  Note
  * that if the user specifies both rcu_expedited and rcu_normal, then
<span class="p_del">- * rcu_normal wins.</span>
<span class="p_add">+ * rcu_normal wins.  (Except during the time period during boot from</span>
<span class="p_add">+ * when the first task is spawned until the rcu_exp_runtime_mode()</span>
<span class="p_add">+ * core_initcall() is invoked, at which point everything is expedited.)</span>
  */
 bool rcu_gp_is_normal(void)
 {
<span class="p_del">-	return READ_ONCE(rcu_normal);</span>
<span class="p_add">+	return READ_ONCE(rcu_normal) &amp;&amp;</span>
<span class="p_add">+	       rcu_scheduler_active != RCU_SCHEDULER_INIT;</span>
 }
 EXPORT_SYMBOL_GPL(rcu_gp_is_normal);
 
<span class="p_chunk">@@ -135,13 +138,14 @@</span> <span class="p_context"> static atomic_t rcu_expedited_nesting =</span>
 /*
  * Should normal grace-period primitives be expedited?  Intended for
  * use within RCU.  Note that this function takes the rcu_expedited
<span class="p_del">- * sysfs/boot variable into account as well as the rcu_expedite_gp()</span>
<span class="p_del">- * nesting.  So looping on rcu_unexpedite_gp() until rcu_gp_is_expedited()</span>
<span class="p_del">- * returns false is a -really- bad idea.</span>
<span class="p_add">+ * sysfs/boot variable and rcu_scheduler_active into account as well</span>
<span class="p_add">+ * as the rcu_expedite_gp() nesting.  So looping on rcu_unexpedite_gp()</span>
<span class="p_add">+ * until rcu_gp_is_expedited() returns false is a -really- bad idea.</span>
  */
 bool rcu_gp_is_expedited(void)
 {
<span class="p_del">-	return rcu_expedited || atomic_read(&amp;rcu_expedited_nesting);</span>
<span class="p_add">+	return rcu_expedited || atomic_read(&amp;rcu_expedited_nesting) ||</span>
<span class="p_add">+	       rcu_scheduler_active == RCU_SCHEDULER_INIT;</span>
 }
 EXPORT_SYMBOL_GPL(rcu_gp_is_expedited);
 
<span class="p_chunk">@@ -257,7 +261,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(rcu_callback_map);</span>
 
 int notrace debug_lockdep_rcu_enabled(void)
 {
<span class="p_del">-	return rcu_scheduler_active &amp;&amp; debug_locks &amp;&amp;</span>
<span class="p_add">+	return rcu_scheduler_active != RCU_SCHEDULER_INACTIVE &amp;&amp; debug_locks &amp;&amp;</span>
 	       current-&gt;lockdep_recursion == 0;
 }
 EXPORT_SYMBOL_GPL(debug_lockdep_rcu_enabled);
<span class="p_chunk">@@ -591,7 +595,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(call_rcu_tasks);</span>
 void synchronize_rcu_tasks(void)
 {
 	/* Complain if the scheduler has not started.  */
<span class="p_del">-	RCU_LOCKDEP_WARN(!rcu_scheduler_active,</span>
<span class="p_add">+	RCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,</span>
 			 &quot;synchronize_rcu_tasks called too soon&quot;);
 
 	/* Wait for the grace period. */
<span class="p_chunk">@@ -813,6 +817,23 @@</span> <span class="p_context"> static void rcu_spawn_tasks_kthread(void)</span>
 
 #endif /* #ifdef CONFIG_TASKS_RCU */
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Test each non-SRCU synchronous grace-period wait API.  This is</span>
<span class="p_add">+ * useful just after a change in mode for these primitives, and</span>
<span class="p_add">+ * during early boot.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void rcu_test_sync_prims(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!IS_ENABLED(CONFIG_PROVE_RCU))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	synchronize_rcu();</span>
<span class="p_add">+	synchronize_rcu_bh();</span>
<span class="p_add">+	synchronize_sched();</span>
<span class="p_add">+	synchronize_rcu_expedited();</span>
<span class="p_add">+	synchronize_rcu_bh_expedited();</span>
<span class="p_add">+	synchronize_sched_expedited();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #ifdef CONFIG_PROVE_RCU
 
 /*
<span class="p_chunk">@@ -865,6 +886,7 @@</span> <span class="p_context"> void rcu_early_boot_tests(void)</span>
 		early_boot_test_call_rcu_bh();
 	if (rcu_self_test_sched)
 		early_boot_test_call_rcu_sched();
<span class="p_add">+	rcu_test_sync_prims();</span>
 }
 
 static int rcu_verify_early_boot_tests(void)
<span class="p_header">diff --git a/lib/swiotlb.c b/lib/swiotlb.c</span>
<span class="p_header">index 22e13a0e19d7..ad1d2962d129 100644</span>
<span class="p_header">--- a/lib/swiotlb.c</span>
<span class="p_header">+++ b/lib/swiotlb.c</span>
<span class="p_chunk">@@ -53,7 +53,7 @@</span> <span class="p_context"></span>
  */
 #define IO_TLB_MIN_SLABS ((1&lt;&lt;20) &gt;&gt; IO_TLB_SHIFT)
 
<span class="p_del">-int swiotlb_force;</span>
<span class="p_add">+enum swiotlb_force swiotlb_force;</span>
 
 /*
  * Used to do a quick range check in swiotlb_tbl_unmap_single and
<span class="p_chunk">@@ -106,8 +106,12 @@</span> <span class="p_context"> setup_io_tlb_npages(char *str)</span>
 	}
 	if (*str == &#39;,&#39;)
 		++str;
<span class="p_del">-	if (!strcmp(str, &quot;force&quot;))</span>
<span class="p_del">-		swiotlb_force = 1;</span>
<span class="p_add">+	if (!strcmp(str, &quot;force&quot;)) {</span>
<span class="p_add">+		swiotlb_force = SWIOTLB_FORCE;</span>
<span class="p_add">+	} else if (!strcmp(str, &quot;noforce&quot;)) {</span>
<span class="p_add">+		swiotlb_force = SWIOTLB_NO_FORCE;</span>
<span class="p_add">+		io_tlb_nslabs = 1;</span>
<span class="p_add">+	}</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -541,8 +545,15 @@</span> <span class="p_context"> static phys_addr_t</span>
 map_single(struct device *hwdev, phys_addr_t phys, size_t size,
 	   enum dma_data_direction dir)
 {
<span class="p_del">-	dma_addr_t start_dma_addr = phys_to_dma(hwdev, io_tlb_start);</span>
<span class="p_add">+	dma_addr_t start_dma_addr;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (swiotlb_force == SWIOTLB_NO_FORCE) {</span>
<span class="p_add">+		dev_warn_ratelimited(hwdev, &quot;Cannot do DMA to address %pa\n&quot;,</span>
<span class="p_add">+				     &amp;phys);</span>
<span class="p_add">+		return SWIOTLB_MAP_ERROR;</span>
<span class="p_add">+	}</span>
 
<span class="p_add">+	start_dma_addr = phys_to_dma(hwdev, io_tlb_start);</span>
 	return swiotlb_tbl_map_single(hwdev, start_dma_addr, phys, size, dir);
 }
 
<span class="p_chunk">@@ -707,6 +718,9 @@</span> <span class="p_context"> static void</span>
 swiotlb_full(struct device *dev, size_t size, enum dma_data_direction dir,
 	     int do_panic)
 {
<span class="p_add">+	if (swiotlb_force == SWIOTLB_NO_FORCE)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/*
 	 * Ran out of IOMMU space for this operation. This is very bad.
 	 * Unfortunately the drivers cannot handle this operation properly.
<span class="p_chunk">@@ -749,7 +763,7 @@</span> <span class="p_context"> dma_addr_t swiotlb_map_page(struct device *dev, struct page *page,</span>
 	 * we can safely return the device addr and not worry about bounce
 	 * buffering it.
 	 */
<span class="p_del">-	if (dma_capable(dev, dev_addr, size) &amp;&amp; !swiotlb_force)</span>
<span class="p_add">+	if (dma_capable(dev, dev_addr, size) &amp;&amp; swiotlb_force != SWIOTLB_FORCE)</span>
 		return dev_addr;
 
 	trace_swiotlb_bounced(dev, dev_addr, size, swiotlb_force);
<span class="p_chunk">@@ -888,7 +902,7 @@</span> <span class="p_context"> swiotlb_map_sg_attrs(struct device *hwdev, struct scatterlist *sgl, int nelems,</span>
 		phys_addr_t paddr = sg_phys(sg);
 		dma_addr_t dev_addr = phys_to_dma(hwdev, paddr);
 
<span class="p_del">-		if (swiotlb_force ||</span>
<span class="p_add">+		if (swiotlb_force == SWIOTLB_FORCE ||</span>
 		    !dma_capable(hwdev, dev_addr, sg-&gt;length)) {
 			phys_addr_t map = map_single(hwdev, sg_phys(sg),
 						     sg-&gt;length, dir);
<span class="p_header">diff --git a/net/ceph/auth_x.c b/net/ceph/auth_x.c</span>
<span class="p_header">index a0905f04bd13..b216131915e7 100644</span>
<span class="p_header">--- a/net/ceph/auth_x.c</span>
<span class="p_header">+++ b/net/ceph/auth_x.c</span>
<span class="p_chunk">@@ -39,56 +39,58 @@</span> <span class="p_context"> static int ceph_x_should_authenticate(struct ceph_auth_client *ac)</span>
 	return need != 0;
 }
 
<span class="p_add">+static int ceph_x_encrypt_offset(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return sizeof(u32) + sizeof(struct ceph_x_encrypt_header);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int ceph_x_encrypt_buflen(int ilen)
 {
<span class="p_del">-	return sizeof(struct ceph_x_encrypt_header) + ilen + 16 +</span>
<span class="p_del">-		sizeof(u32);</span>
<span class="p_add">+	return ceph_x_encrypt_offset() + ilen + 16;</span>
 }
 
<span class="p_del">-static int ceph_x_encrypt(struct ceph_crypto_key *secret,</span>
<span class="p_del">-			  void *ibuf, int ilen, void *obuf, size_t olen)</span>
<span class="p_add">+static int ceph_x_encrypt(struct ceph_crypto_key *secret, void *buf,</span>
<span class="p_add">+			  int buf_len, int plaintext_len)</span>
 {
<span class="p_del">-	struct ceph_x_encrypt_header head = {</span>
<span class="p_del">-		.struct_v = 1,</span>
<span class="p_del">-		.magic = cpu_to_le64(CEPHX_ENC_MAGIC)</span>
<span class="p_del">-	};</span>
<span class="p_del">-	size_t len = olen - sizeof(u32);</span>
<span class="p_add">+	struct ceph_x_encrypt_header *hdr = buf + sizeof(u32);</span>
<span class="p_add">+	int ciphertext_len;</span>
 	int ret;
 
<span class="p_del">-	ret = ceph_encrypt2(secret, obuf + sizeof(u32), &amp;len,</span>
<span class="p_del">-			    &amp;head, sizeof(head), ibuf, ilen);</span>
<span class="p_add">+	hdr-&gt;struct_v = 1;</span>
<span class="p_add">+	hdr-&gt;magic = cpu_to_le64(CEPHX_ENC_MAGIC);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = ceph_crypt(secret, true, buf + sizeof(u32), buf_len - sizeof(u32),</span>
<span class="p_add">+			 plaintext_len + sizeof(struct ceph_x_encrypt_header),</span>
<span class="p_add">+			 &amp;ciphertext_len);</span>
 	if (ret)
 		return ret;
<span class="p_del">-	ceph_encode_32(&amp;obuf, len);</span>
<span class="p_del">-	return len + sizeof(u32);</span>
<span class="p_add">+</span>
<span class="p_add">+	ceph_encode_32(&amp;buf, ciphertext_len);</span>
<span class="p_add">+	return sizeof(u32) + ciphertext_len;</span>
 }
 
<span class="p_del">-static int ceph_x_decrypt(struct ceph_crypto_key *secret,</span>
<span class="p_del">-			  void **p, void *end, void **obuf, size_t olen)</span>
<span class="p_add">+static int ceph_x_decrypt(struct ceph_crypto_key *secret, void **p, void *end)</span>
 {
<span class="p_del">-	struct ceph_x_encrypt_header head;</span>
<span class="p_del">-	size_t head_len = sizeof(head);</span>
<span class="p_del">-	int len, ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	len = ceph_decode_32(p);</span>
<span class="p_del">-	if (*p + len &gt; end)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	struct ceph_x_encrypt_header *hdr = *p + sizeof(u32);</span>
<span class="p_add">+	int ciphertext_len, plaintext_len;</span>
<span class="p_add">+	int ret;</span>
 
<span class="p_del">-	dout(&quot;ceph_x_decrypt len %d\n&quot;, len);</span>
<span class="p_del">-	if (*obuf == NULL) {</span>
<span class="p_del">-		*obuf = kmalloc(len, GFP_NOFS);</span>
<span class="p_del">-		if (!*obuf)</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_del">-		olen = len;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	ceph_decode_32_safe(p, end, ciphertext_len, e_inval);</span>
<span class="p_add">+	ceph_decode_need(p, end, ciphertext_len, e_inval);</span>
 
<span class="p_del">-	ret = ceph_decrypt2(secret, &amp;head, &amp;head_len, *obuf, &amp;olen, *p, len);</span>
<span class="p_add">+	ret = ceph_crypt(secret, false, *p, end - *p, ciphertext_len,</span>
<span class="p_add">+			 &amp;plaintext_len);</span>
 	if (ret)
 		return ret;
<span class="p_del">-	if (head.struct_v != 1 || le64_to_cpu(head.magic) != CEPHX_ENC_MAGIC)</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hdr-&gt;struct_v != 1 || le64_to_cpu(hdr-&gt;magic) != CEPHX_ENC_MAGIC)</span>
 		return -EPERM;
<span class="p_del">-	*p += len;</span>
<span class="p_del">-	return olen;</span>
<span class="p_add">+</span>
<span class="p_add">+	*p += ciphertext_len;</span>
<span class="p_add">+	return plaintext_len - sizeof(struct ceph_x_encrypt_header);</span>
<span class="p_add">+</span>
<span class="p_add">+e_inval:</span>
<span class="p_add">+	return -EINVAL;</span>
 }
 
 /*
<span class="p_chunk">@@ -143,13 +145,10 @@</span> <span class="p_context"> static int process_one_ticket(struct ceph_auth_client *ac,</span>
 	int type;
 	u8 tkt_struct_v, blob_struct_v;
 	struct ceph_x_ticket_handler *th;
<span class="p_del">-	void *dbuf = NULL;</span>
 	void *dp, *dend;
 	int dlen;
 	char is_enc;
 	struct timespec validity;
<span class="p_del">-	struct ceph_crypto_key old_key;</span>
<span class="p_del">-	void *ticket_buf = NULL;</span>
 	void *tp, *tpend;
 	void **ptp;
 	struct ceph_crypto_key new_session_key;
<span class="p_chunk">@@ -174,20 +173,17 @@</span> <span class="p_context"> static int process_one_ticket(struct ceph_auth_client *ac,</span>
 	}
 
 	/* blob for me */
<span class="p_del">-	dlen = ceph_x_decrypt(secret, p, end, &amp;dbuf, 0);</span>
<span class="p_del">-	if (dlen &lt;= 0) {</span>
<span class="p_del">-		ret = dlen;</span>
<span class="p_add">+	dp = *p + ceph_x_encrypt_offset();</span>
<span class="p_add">+	ret = ceph_x_decrypt(secret, p, end);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
 		goto out;
<span class="p_del">-	}</span>
<span class="p_del">-	dout(&quot; decrypted %d bytes\n&quot;, dlen);</span>
<span class="p_del">-	dp = dbuf;</span>
<span class="p_del">-	dend = dp + dlen;</span>
<span class="p_add">+	dout(&quot; decrypted %d bytes\n&quot;, ret);</span>
<span class="p_add">+	dend = dp + ret;</span>
 
 	tkt_struct_v = ceph_decode_8(&amp;dp);
 	if (tkt_struct_v != 1)
 		goto bad;
 
<span class="p_del">-	memcpy(&amp;old_key, &amp;th-&gt;session_key, sizeof(old_key));</span>
 	ret = ceph_crypto_key_decode(&amp;new_session_key, &amp;dp, dend);
 	if (ret)
 		goto out;
<span class="p_chunk">@@ -203,15 +199,13 @@</span> <span class="p_context"> static int process_one_ticket(struct ceph_auth_client *ac,</span>
 	ceph_decode_8_safe(p, end, is_enc, bad);
 	if (is_enc) {
 		/* encrypted */
<span class="p_del">-		dout(&quot; encrypted ticket\n&quot;);</span>
<span class="p_del">-		dlen = ceph_x_decrypt(&amp;old_key, p, end, &amp;ticket_buf, 0);</span>
<span class="p_del">-		if (dlen &lt; 0) {</span>
<span class="p_del">-			ret = dlen;</span>
<span class="p_add">+		tp = *p + ceph_x_encrypt_offset();</span>
<span class="p_add">+		ret = ceph_x_decrypt(&amp;th-&gt;session_key, p, end);</span>
<span class="p_add">+		if (ret &lt; 0)</span>
 			goto out;
<span class="p_del">-		}</span>
<span class="p_del">-		tp = ticket_buf;</span>
<span class="p_add">+		dout(&quot; encrypted ticket, decrypted %d bytes\n&quot;, ret);</span>
 		ptp = &amp;tp;
<span class="p_del">-		tpend = *ptp + dlen;</span>
<span class="p_add">+		tpend = tp + ret;</span>
 	} else {
 		/* unencrypted */
 		ptp = p;
<span class="p_chunk">@@ -242,8 +236,6 @@</span> <span class="p_context"> static int process_one_ticket(struct ceph_auth_client *ac,</span>
 	xi-&gt;have_keys |= th-&gt;service;
 
 out:
<span class="p_del">-	kfree(ticket_buf);</span>
<span class="p_del">-	kfree(dbuf);</span>
 	return ret;
 
 bad:
<span class="p_chunk">@@ -294,7 +286,7 @@</span> <span class="p_context"> static int ceph_x_build_authorizer(struct ceph_auth_client *ac,</span>
 {
 	int maxlen;
 	struct ceph_x_authorize_a *msg_a;
<span class="p_del">-	struct ceph_x_authorize_b msg_b;</span>
<span class="p_add">+	struct ceph_x_authorize_b *msg_b;</span>
 	void *p, *end;
 	int ret;
 	int ticket_blob_len =
<span class="p_chunk">@@ -308,8 +300,8 @@</span> <span class="p_context"> static int ceph_x_build_authorizer(struct ceph_auth_client *ac,</span>
 	if (ret)
 		goto out_au;
 
<span class="p_del">-	maxlen = sizeof(*msg_a) + sizeof(msg_b) +</span>
<span class="p_del">-		ceph_x_encrypt_buflen(ticket_blob_len);</span>
<span class="p_add">+	maxlen = sizeof(*msg_a) + ticket_blob_len +</span>
<span class="p_add">+		ceph_x_encrypt_buflen(sizeof(*msg_b));</span>
 	dout(&quot;  need len %d\n&quot;, maxlen);
 	if (au-&gt;buf &amp;&amp; au-&gt;buf-&gt;alloc_len &lt; maxlen) {
 		ceph_buffer_put(au-&gt;buf);
<span class="p_chunk">@@ -343,18 +335,19 @@</span> <span class="p_context"> static int ceph_x_build_authorizer(struct ceph_auth_client *ac,</span>
 	p += ticket_blob_len;
 	end = au-&gt;buf-&gt;vec.iov_base + au-&gt;buf-&gt;vec.iov_len;
 
<span class="p_add">+	msg_b = p + ceph_x_encrypt_offset();</span>
<span class="p_add">+	msg_b-&gt;struct_v = 1;</span>
 	get_random_bytes(&amp;au-&gt;nonce, sizeof(au-&gt;nonce));
<span class="p_del">-	msg_b.struct_v = 1;</span>
<span class="p_del">-	msg_b.nonce = cpu_to_le64(au-&gt;nonce);</span>
<span class="p_del">-	ret = ceph_x_encrypt(&amp;au-&gt;session_key, &amp;msg_b, sizeof(msg_b),</span>
<span class="p_del">-			     p, end - p);</span>
<span class="p_add">+	msg_b-&gt;nonce = cpu_to_le64(au-&gt;nonce);</span>
<span class="p_add">+	ret = ceph_x_encrypt(&amp;au-&gt;session_key, p, end - p, sizeof(*msg_b));</span>
 	if (ret &lt; 0)
 		goto out_au;
<span class="p_add">+</span>
 	p += ret;
<span class="p_add">+	WARN_ON(p &gt; end);</span>
 	au-&gt;buf-&gt;vec.iov_len = p - au-&gt;buf-&gt;vec.iov_base;
 	dout(&quot; built authorizer nonce %llx len %d\n&quot;, au-&gt;nonce,
 	     (int)au-&gt;buf-&gt;vec.iov_len);
<span class="p_del">-	BUG_ON(au-&gt;buf-&gt;vec.iov_len &gt; maxlen);</span>
 	return 0;
 
 out_au:
<span class="p_chunk">@@ -452,8 +445,9 @@</span> <span class="p_context"> static int ceph_x_build_request(struct ceph_auth_client *ac,</span>
 	if (need &amp; CEPH_ENTITY_TYPE_AUTH) {
 		struct ceph_x_authenticate *auth = (void *)(head + 1);
 		void *p = auth + 1;
<span class="p_del">-		struct ceph_x_challenge_blob tmp;</span>
<span class="p_del">-		char tmp_enc[40];</span>
<span class="p_add">+		void *enc_buf = xi-&gt;auth_authorizer.enc_buf;</span>
<span class="p_add">+		struct ceph_x_challenge_blob *blob = enc_buf +</span>
<span class="p_add">+							ceph_x_encrypt_offset();</span>
 		u64 *u;
 
 		if (p &gt; end)
<span class="p_chunk">@@ -464,16 +458,16 @@</span> <span class="p_context"> static int ceph_x_build_request(struct ceph_auth_client *ac,</span>
 
 		/* encrypt and hash */
 		get_random_bytes(&amp;auth-&gt;client_challenge, sizeof(u64));
<span class="p_del">-		tmp.client_challenge = auth-&gt;client_challenge;</span>
<span class="p_del">-		tmp.server_challenge = cpu_to_le64(xi-&gt;server_challenge);</span>
<span class="p_del">-		ret = ceph_x_encrypt(&amp;xi-&gt;secret, &amp;tmp, sizeof(tmp),</span>
<span class="p_del">-				     tmp_enc, sizeof(tmp_enc));</span>
<span class="p_add">+		blob-&gt;client_challenge = auth-&gt;client_challenge;</span>
<span class="p_add">+		blob-&gt;server_challenge = cpu_to_le64(xi-&gt;server_challenge);</span>
<span class="p_add">+		ret = ceph_x_encrypt(&amp;xi-&gt;secret, enc_buf, CEPHX_AU_ENC_BUF_LEN,</span>
<span class="p_add">+				     sizeof(*blob));</span>
 		if (ret &lt; 0)
 			return ret;
 
 		auth-&gt;struct_v = 1;
 		auth-&gt;key = 0;
<span class="p_del">-		for (u = (u64 *)tmp_enc; u + 1 &lt;= (u64 *)(tmp_enc + ret); u++)</span>
<span class="p_add">+		for (u = (u64 *)enc_buf; u + 1 &lt;= (u64 *)(enc_buf + ret); u++)</span>
 			auth-&gt;key ^= *(__le64 *)u;
 		dout(&quot; server_challenge %llx client_challenge %llx key %llx\n&quot;,
 		     xi-&gt;server_challenge, le64_to_cpu(auth-&gt;client_challenge),
<span class="p_chunk">@@ -600,8 +594,8 @@</span> <span class="p_context"> static int ceph_x_create_authorizer(</span>
 	auth-&gt;authorizer = (struct ceph_authorizer *) au;
 	auth-&gt;authorizer_buf = au-&gt;buf-&gt;vec.iov_base;
 	auth-&gt;authorizer_buf_len = au-&gt;buf-&gt;vec.iov_len;
<span class="p_del">-	auth-&gt;authorizer_reply_buf = au-&gt;reply_buf;</span>
<span class="p_del">-	auth-&gt;authorizer_reply_buf_len = sizeof (au-&gt;reply_buf);</span>
<span class="p_add">+	auth-&gt;authorizer_reply_buf = au-&gt;enc_buf;</span>
<span class="p_add">+	auth-&gt;authorizer_reply_buf_len = CEPHX_AU_ENC_BUF_LEN;</span>
 	auth-&gt;sign_message = ac-&gt;ops-&gt;sign_message;
 	auth-&gt;check_message_signature = ac-&gt;ops-&gt;check_message_signature;
 
<span class="p_chunk">@@ -632,24 +626,22 @@</span> <span class="p_context"> static int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac,</span>
 					  struct ceph_authorizer *a, size_t len)
 {
 	struct ceph_x_authorizer *au = (void *)a;
<span class="p_del">-	int ret = 0;</span>
<span class="p_del">-	struct ceph_x_authorize_reply reply;</span>
<span class="p_del">-	void *preply = &amp;reply;</span>
<span class="p_del">-	void *p = au-&gt;reply_buf;</span>
<span class="p_del">-	void *end = p + sizeof(au-&gt;reply_buf);</span>
<span class="p_add">+	void *p = au-&gt;enc_buf;</span>
<span class="p_add">+	struct ceph_x_authorize_reply *reply = p + ceph_x_encrypt_offset();</span>
<span class="p_add">+	int ret;</span>
 
<span class="p_del">-	ret = ceph_x_decrypt(&amp;au-&gt;session_key, &amp;p, end, &amp;preply, sizeof(reply));</span>
<span class="p_add">+	ret = ceph_x_decrypt(&amp;au-&gt;session_key, &amp;p, p + CEPHX_AU_ENC_BUF_LEN);</span>
 	if (ret &lt; 0)
 		return ret;
<span class="p_del">-	if (ret != sizeof(reply))</span>
<span class="p_add">+	if (ret != sizeof(*reply))</span>
 		return -EPERM;
 
<span class="p_del">-	if (au-&gt;nonce + 1 != le64_to_cpu(reply.nonce_plus_one))</span>
<span class="p_add">+	if (au-&gt;nonce + 1 != le64_to_cpu(reply-&gt;nonce_plus_one))</span>
 		ret = -EPERM;
 	else
 		ret = 0;
 	dout(&quot;verify_authorizer_reply nonce %llx got %llx ret %d\n&quot;,
<span class="p_del">-	     au-&gt;nonce, le64_to_cpu(reply.nonce_plus_one), ret);</span>
<span class="p_add">+	     au-&gt;nonce, le64_to_cpu(reply-&gt;nonce_plus_one), ret);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -704,35 +696,48 @@</span> <span class="p_context"> static void ceph_x_invalidate_authorizer(struct ceph_auth_client *ac,</span>
 	invalidate_ticket(ac, CEPH_ENTITY_TYPE_AUTH);
 }
 
<span class="p_del">-static int calcu_signature(struct ceph_x_authorizer *au,</span>
<span class="p_del">-			   struct ceph_msg *msg, __le64 *sig)</span>
<span class="p_add">+static int calc_signature(struct ceph_x_authorizer *au, struct ceph_msg *msg,</span>
<span class="p_add">+			  __le64 *psig)</span>
 {
<span class="p_add">+	void *enc_buf = au-&gt;enc_buf;</span>
<span class="p_add">+	struct {</span>
<span class="p_add">+		__le32 len;</span>
<span class="p_add">+		__le32 header_crc;</span>
<span class="p_add">+		__le32 front_crc;</span>
<span class="p_add">+		__le32 middle_crc;</span>
<span class="p_add">+		__le32 data_crc;</span>
<span class="p_add">+	} __packed *sigblock = enc_buf + ceph_x_encrypt_offset();</span>
 	int ret;
<span class="p_del">-	char tmp_enc[40];</span>
<span class="p_del">-	__le32 tmp[5] = {</span>
<span class="p_del">-		cpu_to_le32(16), msg-&gt;hdr.crc, msg-&gt;footer.front_crc,</span>
<span class="p_del">-		msg-&gt;footer.middle_crc, msg-&gt;footer.data_crc,</span>
<span class="p_del">-	};</span>
<span class="p_del">-	ret = ceph_x_encrypt(&amp;au-&gt;session_key, &amp;tmp, sizeof(tmp),</span>
<span class="p_del">-			     tmp_enc, sizeof(tmp_enc));</span>
<span class="p_add">+</span>
<span class="p_add">+	sigblock-&gt;len = cpu_to_le32(4*sizeof(u32));</span>
<span class="p_add">+	sigblock-&gt;header_crc = msg-&gt;hdr.crc;</span>
<span class="p_add">+	sigblock-&gt;front_crc = msg-&gt;footer.front_crc;</span>
<span class="p_add">+	sigblock-&gt;middle_crc = msg-&gt;footer.middle_crc;</span>
<span class="p_add">+	sigblock-&gt;data_crc =  msg-&gt;footer.data_crc;</span>
<span class="p_add">+	ret = ceph_x_encrypt(&amp;au-&gt;session_key, enc_buf, CEPHX_AU_ENC_BUF_LEN,</span>
<span class="p_add">+			     sizeof(*sigblock));</span>
 	if (ret &lt; 0)
 		return ret;
<span class="p_del">-	*sig = *(__le64*)(tmp_enc + 4);</span>
<span class="p_add">+</span>
<span class="p_add">+	*psig = *(__le64 *)(enc_buf + sizeof(u32));</span>
 	return 0;
 }
 
 static int ceph_x_sign_message(struct ceph_auth_handshake *auth,
 			       struct ceph_msg *msg)
 {
<span class="p_add">+	__le64 sig;</span>
 	int ret;
 
 	if (ceph_test_opt(from_msgr(msg-&gt;con-&gt;msgr), NOMSGSIGN))
 		return 0;
 
<span class="p_del">-	ret = calcu_signature((struct ceph_x_authorizer *)auth-&gt;authorizer,</span>
<span class="p_del">-			      msg, &amp;msg-&gt;footer.sig);</span>
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_add">+	ret = calc_signature((struct ceph_x_authorizer *)auth-&gt;authorizer,</span>
<span class="p_add">+			     msg, &amp;sig);</span>
<span class="p_add">+	if (ret)</span>
 		return ret;
<span class="p_add">+</span>
<span class="p_add">+	msg-&gt;footer.sig = sig;</span>
 	msg-&gt;footer.flags |= CEPH_MSG_FOOTER_SIGNED;
 	return 0;
 }
<span class="p_chunk">@@ -746,9 +751,9 @@</span> <span class="p_context"> static int ceph_x_check_message_signature(struct ceph_auth_handshake *auth,</span>
 	if (ceph_test_opt(from_msgr(msg-&gt;con-&gt;msgr), NOMSGSIGN))
 		return 0;
 
<span class="p_del">-	ret = calcu_signature((struct ceph_x_authorizer *)auth-&gt;authorizer,</span>
<span class="p_del">-			      msg, &amp;sig_check);</span>
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_add">+	ret = calc_signature((struct ceph_x_authorizer *)auth-&gt;authorizer,</span>
<span class="p_add">+			     msg, &amp;sig_check);</span>
<span class="p_add">+	if (ret)</span>
 		return ret;
 	if (sig_check == msg-&gt;footer.sig)
 		return 0;
<span class="p_header">diff --git a/net/ceph/auth_x.h b/net/ceph/auth_x.h</span>
<span class="p_header">index 21a5af904bae..48e9ad41bd2a 100644</span>
<span class="p_header">--- a/net/ceph/auth_x.h</span>
<span class="p_header">+++ b/net/ceph/auth_x.h</span>
<span class="p_chunk">@@ -24,6 +24,7 @@</span> <span class="p_context"> struct ceph_x_ticket_handler {</span>
 	unsigned long renew_after, expires;
 };
 
<span class="p_add">+#define CEPHX_AU_ENC_BUF_LEN	128  /* big enough for encrypted blob */</span>
 
 struct ceph_x_authorizer {
 	struct ceph_authorizer base;
<span class="p_chunk">@@ -32,7 +33,7 @@</span> <span class="p_context"> struct ceph_x_authorizer {</span>
 	unsigned int service;
 	u64 nonce;
 	u64 secret_id;
<span class="p_del">-	char reply_buf[128];  /* big enough for encrypted blob */</span>
<span class="p_add">+	char enc_buf[CEPHX_AU_ENC_BUF_LEN] __aligned(8);</span>
 };
 
 struct ceph_x_info {
<span class="p_header">diff --git a/net/ceph/crypto.c b/net/ceph/crypto.c</span>
<span class="p_header">index db2847ac5f12..292e33bd916e 100644</span>
<span class="p_header">--- a/net/ceph/crypto.c</span>
<span class="p_header">+++ b/net/ceph/crypto.c</span>
<span class="p_chunk">@@ -13,14 +13,60 @@</span> <span class="p_context"></span>
 #include &lt;linux/ceph/decode.h&gt;
 #include &quot;crypto.h&quot;
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Set -&gt;key and -&gt;tfm.  The rest of the key should be filled in before</span>
<span class="p_add">+ * this function is called.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int set_secret(struct ceph_crypto_key *key, void *buf)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int noio_flag;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	key-&gt;key = NULL;</span>
<span class="p_add">+	key-&gt;tfm = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (key-&gt;type) {</span>
<span class="p_add">+	case CEPH_CRYPTO_NONE:</span>
<span class="p_add">+		return 0; /* nothing to do */</span>
<span class="p_add">+	case CEPH_CRYPTO_AES:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return -ENOTSUPP;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	WARN_ON(!key-&gt;len);</span>
<span class="p_add">+	key-&gt;key = kmemdup(buf, key-&gt;len, GFP_NOIO);</span>
<span class="p_add">+	if (!key-&gt;key) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto fail;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* crypto_alloc_skcipher() allocates with GFP_KERNEL */</span>
<span class="p_add">+	noio_flag = memalloc_noio_save();</span>
<span class="p_add">+	key-&gt;tfm = crypto_alloc_skcipher(&quot;cbc(aes)&quot;, 0, CRYPTO_ALG_ASYNC);</span>
<span class="p_add">+	memalloc_noio_restore(noio_flag);</span>
<span class="p_add">+	if (IS_ERR(key-&gt;tfm)) {</span>
<span class="p_add">+		ret = PTR_ERR(key-&gt;tfm);</span>
<span class="p_add">+		key-&gt;tfm = NULL;</span>
<span class="p_add">+		goto fail;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = crypto_skcipher_setkey(key-&gt;tfm, key-&gt;key, key-&gt;len);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto fail;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+fail:</span>
<span class="p_add">+	ceph_crypto_key_destroy(key);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int ceph_crypto_key_clone(struct ceph_crypto_key *dst,
 			  const struct ceph_crypto_key *src)
 {
 	memcpy(dst, src, sizeof(struct ceph_crypto_key));
<span class="p_del">-	dst-&gt;key = kmemdup(src-&gt;key, src-&gt;len, GFP_NOFS);</span>
<span class="p_del">-	if (!dst-&gt;key)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return set_secret(dst, src-&gt;key);</span>
 }
 
 int ceph_crypto_key_encode(struct ceph_crypto_key *key, void **p, void *end)
<span class="p_chunk">@@ -37,16 +83,16 @@</span> <span class="p_context"> int ceph_crypto_key_encode(struct ceph_crypto_key *key, void **p, void *end)</span>
 
 int ceph_crypto_key_decode(struct ceph_crypto_key *key, void **p, void *end)
 {
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
 	ceph_decode_need(p, end, 2*sizeof(u16) + sizeof(key-&gt;created), bad);
 	key-&gt;type = ceph_decode_16(p);
 	ceph_decode_copy(p, &amp;key-&gt;created, sizeof(key-&gt;created));
 	key-&gt;len = ceph_decode_16(p);
 	ceph_decode_need(p, end, key-&gt;len, bad);
<span class="p_del">-	key-&gt;key = kmalloc(key-&gt;len, GFP_NOFS);</span>
<span class="p_del">-	if (!key-&gt;key)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-	ceph_decode_copy(p, key-&gt;key, key-&gt;len);</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	ret = set_secret(key, *p);</span>
<span class="p_add">+	*p += key-&gt;len;</span>
<span class="p_add">+	return ret;</span>
 
 bad:
 	dout(&quot;failed to decode crypto key\n&quot;);
<span class="p_chunk">@@ -80,9 +126,14 @@</span> <span class="p_context"> int ceph_crypto_key_unarmor(struct ceph_crypto_key *key, const char *inkey)</span>
 	return 0;
 }
 
<span class="p_del">-static struct crypto_skcipher *ceph_crypto_alloc_cipher(void)</span>
<span class="p_add">+void ceph_crypto_key_destroy(struct ceph_crypto_key *key)</span>
 {
<span class="p_del">-	return crypto_alloc_skcipher(&quot;cbc(aes)&quot;, 0, CRYPTO_ALG_ASYNC);</span>
<span class="p_add">+	if (key) {</span>
<span class="p_add">+		kfree(key-&gt;key);</span>
<span class="p_add">+		key-&gt;key = NULL;</span>
<span class="p_add">+		crypto_free_skcipher(key-&gt;tfm);</span>
<span class="p_add">+		key-&gt;tfm = NULL;</span>
<span class="p_add">+	}</span>
 }
 
 static const u8 *aes_iv = (u8 *)CEPH_AES_IV;
<span class="p_chunk">@@ -157,372 +208,82 @@</span> <span class="p_context"> static void teardown_sgtable(struct sg_table *sgt)</span>
 		sg_free_table(sgt);
 }
 
<span class="p_del">-static int ceph_aes_encrypt(const void *key, int key_len,</span>
<span class="p_del">-			    void *dst, size_t *dst_len,</span>
<span class="p_del">-			    const void *src, size_t src_len)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct scatterlist sg_in[2], prealloc_sg;</span>
<span class="p_del">-	struct sg_table sg_out;</span>
<span class="p_del">-	struct crypto_skcipher *tfm = ceph_crypto_alloc_cipher();</span>
<span class="p_del">-	SKCIPHER_REQUEST_ON_STACK(req, tfm);</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-	char iv[AES_BLOCK_SIZE];</span>
<span class="p_del">-	size_t zero_padding = (0x10 - (src_len &amp; 0x0f));</span>
<span class="p_del">-	char pad[16];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (IS_ERR(tfm))</span>
<span class="p_del">-		return PTR_ERR(tfm);</span>
<span class="p_del">-</span>
<span class="p_del">-	memset(pad, zero_padding, zero_padding);</span>
<span class="p_del">-</span>
<span class="p_del">-	*dst_len = src_len + zero_padding;</span>
<span class="p_del">-</span>
<span class="p_del">-	sg_init_table(sg_in, 2);</span>
<span class="p_del">-	sg_set_buf(&amp;sg_in[0], src, src_len);</span>
<span class="p_del">-	sg_set_buf(&amp;sg_in[1], pad, zero_padding);</span>
<span class="p_del">-	ret = setup_sgtable(&amp;sg_out, &amp;prealloc_sg, dst, *dst_len);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto out_tfm;</span>
<span class="p_del">-</span>
<span class="p_del">-	crypto_skcipher_setkey((void *)tfm, key, key_len);</span>
<span class="p_del">-	memcpy(iv, aes_iv, AES_BLOCK_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-	skcipher_request_set_tfm(req, tfm);</span>
<span class="p_del">-	skcipher_request_set_callback(req, 0, NULL, NULL);</span>
<span class="p_del">-	skcipher_request_set_crypt(req, sg_in, sg_out.sgl,</span>
<span class="p_del">-				   src_len + zero_padding, iv);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	print_hex_dump(KERN_ERR, &quot;enc key: &quot;, DUMP_PREFIX_NONE, 16, 1,</span>
<span class="p_del">-		       key, key_len, 1);</span>
<span class="p_del">-	print_hex_dump(KERN_ERR, &quot;enc src: &quot;, DUMP_PREFIX_NONE, 16, 1,</span>
<span class="p_del">-			src, src_len, 1);</span>
<span class="p_del">-	print_hex_dump(KERN_ERR, &quot;enc pad: &quot;, DUMP_PREFIX_NONE, 16, 1,</span>
<span class="p_del">-			pad, zero_padding, 1);</span>
<span class="p_del">-	*/</span>
<span class="p_del">-	ret = crypto_skcipher_encrypt(req);</span>
<span class="p_del">-	skcipher_request_zero(req);</span>
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		pr_err(&quot;ceph_aes_crypt failed %d\n&quot;, ret);</span>
<span class="p_del">-		goto out_sg;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	print_hex_dump(KERN_ERR, &quot;enc out: &quot;, DUMP_PREFIX_NONE, 16, 1,</span>
<span class="p_del">-		       dst, *dst_len, 1);</span>
<span class="p_del">-	*/</span>
<span class="p_del">-</span>
<span class="p_del">-out_sg:</span>
<span class="p_del">-	teardown_sgtable(&amp;sg_out);</span>
<span class="p_del">-out_tfm:</span>
<span class="p_del">-	crypto_free_skcipher(tfm);</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int ceph_aes_encrypt2(const void *key, int key_len, void *dst,</span>
<span class="p_del">-			     size_t *dst_len,</span>
<span class="p_del">-			     const void *src1, size_t src1_len,</span>
<span class="p_del">-			     const void *src2, size_t src2_len)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct scatterlist sg_in[3], prealloc_sg;</span>
<span class="p_del">-	struct sg_table sg_out;</span>
<span class="p_del">-	struct crypto_skcipher *tfm = ceph_crypto_alloc_cipher();</span>
<span class="p_del">-	SKCIPHER_REQUEST_ON_STACK(req, tfm);</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-	char iv[AES_BLOCK_SIZE];</span>
<span class="p_del">-	size_t zero_padding = (0x10 - ((src1_len + src2_len) &amp; 0x0f));</span>
<span class="p_del">-	char pad[16];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (IS_ERR(tfm))</span>
<span class="p_del">-		return PTR_ERR(tfm);</span>
<span class="p_del">-</span>
<span class="p_del">-	memset(pad, zero_padding, zero_padding);</span>
<span class="p_del">-</span>
<span class="p_del">-	*dst_len = src1_len + src2_len + zero_padding;</span>
<span class="p_del">-</span>
<span class="p_del">-	sg_init_table(sg_in, 3);</span>
<span class="p_del">-	sg_set_buf(&amp;sg_in[0], src1, src1_len);</span>
<span class="p_del">-	sg_set_buf(&amp;sg_in[1], src2, src2_len);</span>
<span class="p_del">-	sg_set_buf(&amp;sg_in[2], pad, zero_padding);</span>
<span class="p_del">-	ret = setup_sgtable(&amp;sg_out, &amp;prealloc_sg, dst, *dst_len);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto out_tfm;</span>
<span class="p_del">-</span>
<span class="p_del">-	crypto_skcipher_setkey((void *)tfm, key, key_len);</span>
<span class="p_del">-	memcpy(iv, aes_iv, AES_BLOCK_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-	skcipher_request_set_tfm(req, tfm);</span>
<span class="p_del">-	skcipher_request_set_callback(req, 0, NULL, NULL);</span>
<span class="p_del">-	skcipher_request_set_crypt(req, sg_in, sg_out.sgl,</span>
<span class="p_del">-				   src1_len + src2_len + zero_padding, iv);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	print_hex_dump(KERN_ERR, &quot;enc  key: &quot;, DUMP_PREFIX_NONE, 16, 1,</span>
<span class="p_del">-		       key, key_len, 1);</span>
<span class="p_del">-	print_hex_dump(KERN_ERR, &quot;enc src1: &quot;, DUMP_PREFIX_NONE, 16, 1,</span>
<span class="p_del">-			src1, src1_len, 1);</span>
<span class="p_del">-	print_hex_dump(KERN_ERR, &quot;enc src2: &quot;, DUMP_PREFIX_NONE, 16, 1,</span>
<span class="p_del">-			src2, src2_len, 1);</span>
<span class="p_del">-	print_hex_dump(KERN_ERR, &quot;enc  pad: &quot;, DUMP_PREFIX_NONE, 16, 1,</span>
<span class="p_del">-			pad, zero_padding, 1);</span>
<span class="p_del">-	*/</span>
<span class="p_del">-	ret = crypto_skcipher_encrypt(req);</span>
<span class="p_del">-	skcipher_request_zero(req);</span>
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		pr_err(&quot;ceph_aes_crypt2 failed %d\n&quot;, ret);</span>
<span class="p_del">-		goto out_sg;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	print_hex_dump(KERN_ERR, &quot;enc  out: &quot;, DUMP_PREFIX_NONE, 16, 1,</span>
<span class="p_del">-		       dst, *dst_len, 1);</span>
<span class="p_del">-	*/</span>
<span class="p_del">-</span>
<span class="p_del">-out_sg:</span>
<span class="p_del">-	teardown_sgtable(&amp;sg_out);</span>
<span class="p_del">-out_tfm:</span>
<span class="p_del">-	crypto_free_skcipher(tfm);</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int ceph_aes_decrypt(const void *key, int key_len,</span>
<span class="p_del">-			    void *dst, size_t *dst_len,</span>
<span class="p_del">-			    const void *src, size_t src_len)</span>
<span class="p_add">+static int ceph_aes_crypt(const struct ceph_crypto_key *key, bool encrypt,</span>
<span class="p_add">+			  void *buf, int buf_len, int in_len, int *pout_len)</span>
 {
<span class="p_del">-	struct sg_table sg_in;</span>
<span class="p_del">-	struct scatterlist sg_out[2], prealloc_sg;</span>
<span class="p_del">-	struct crypto_skcipher *tfm = ceph_crypto_alloc_cipher();</span>
<span class="p_del">-	SKCIPHER_REQUEST_ON_STACK(req, tfm);</span>
<span class="p_del">-	char pad[16];</span>
<span class="p_del">-	char iv[AES_BLOCK_SIZE];</span>
<span class="p_add">+	SKCIPHER_REQUEST_ON_STACK(req, key-&gt;tfm);</span>
<span class="p_add">+	struct sg_table sgt;</span>
<span class="p_add">+	struct scatterlist prealloc_sg;</span>
<span class="p_add">+	char iv[AES_BLOCK_SIZE] __aligned(8);</span>
<span class="p_add">+	int pad_byte = AES_BLOCK_SIZE - (in_len &amp; (AES_BLOCK_SIZE - 1));</span>
<span class="p_add">+	int crypt_len = encrypt ? in_len + pad_byte : in_len;</span>
 	int ret;
<span class="p_del">-	int last_byte;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (IS_ERR(tfm))</span>
<span class="p_del">-		return PTR_ERR(tfm);</span>
 
<span class="p_del">-	sg_init_table(sg_out, 2);</span>
<span class="p_del">-	sg_set_buf(&amp;sg_out[0], dst, *dst_len);</span>
<span class="p_del">-	sg_set_buf(&amp;sg_out[1], pad, sizeof(pad));</span>
<span class="p_del">-	ret = setup_sgtable(&amp;sg_in, &amp;prealloc_sg, src, src_len);</span>
<span class="p_add">+	WARN_ON(crypt_len &gt; buf_len);</span>
<span class="p_add">+	if (encrypt)</span>
<span class="p_add">+		memset(buf + in_len, pad_byte, pad_byte);</span>
<span class="p_add">+	ret = setup_sgtable(&amp;sgt, &amp;prealloc_sg, buf, crypt_len);</span>
 	if (ret)
<span class="p_del">-		goto out_tfm;</span>
<span class="p_add">+		return ret;</span>
 
<span class="p_del">-	crypto_skcipher_setkey((void *)tfm, key, key_len);</span>
 	memcpy(iv, aes_iv, AES_BLOCK_SIZE);
<span class="p_del">-</span>
<span class="p_del">-	skcipher_request_set_tfm(req, tfm);</span>
<span class="p_add">+	skcipher_request_set_tfm(req, key-&gt;tfm);</span>
 	skcipher_request_set_callback(req, 0, NULL, NULL);
<span class="p_del">-	skcipher_request_set_crypt(req, sg_in.sgl, sg_out,</span>
<span class="p_del">-				   src_len, iv);</span>
<span class="p_add">+	skcipher_request_set_crypt(req, sgt.sgl, sgt.sgl, crypt_len, iv);</span>
 
 	/*
<span class="p_del">-	print_hex_dump(KERN_ERR, &quot;dec key: &quot;, DUMP_PREFIX_NONE, 16, 1,</span>
<span class="p_del">-		       key, key_len, 1);</span>
<span class="p_del">-	print_hex_dump(KERN_ERR, &quot;dec  in: &quot;, DUMP_PREFIX_NONE, 16, 1,</span>
<span class="p_del">-		       src, src_len, 1);</span>
<span class="p_add">+	print_hex_dump(KERN_ERR, &quot;key: &quot;, DUMP_PREFIX_NONE, 16, 1,</span>
<span class="p_add">+		       key-&gt;key, key-&gt;len, 1);</span>
<span class="p_add">+	print_hex_dump(KERN_ERR, &quot; in: &quot;, DUMP_PREFIX_NONE, 16, 1,</span>
<span class="p_add">+		       buf, crypt_len, 1);</span>
 	*/
<span class="p_del">-	ret = crypto_skcipher_decrypt(req);</span>
<span class="p_del">-	skcipher_request_zero(req);</span>
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		pr_err(&quot;ceph_aes_decrypt failed %d\n&quot;, ret);</span>
<span class="p_del">-		goto out_sg;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (src_len &lt;= *dst_len)</span>
<span class="p_del">-		last_byte = ((char *)dst)[src_len - 1];</span>
<span class="p_add">+	if (encrypt)</span>
<span class="p_add">+		ret = crypto_skcipher_encrypt(req);</span>
 	else
<span class="p_del">-		last_byte = pad[src_len - *dst_len - 1];</span>
<span class="p_del">-	if (last_byte &lt;= 16 &amp;&amp; src_len &gt;= last_byte) {</span>
<span class="p_del">-		*dst_len = src_len - last_byte;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		pr_err(&quot;ceph_aes_decrypt got bad padding %d on src len %d\n&quot;,</span>
<span class="p_del">-		       last_byte, (int)src_len);</span>
<span class="p_del">-		return -EPERM;  /* bad padding */</span>
<span class="p_del">-	}</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	print_hex_dump(KERN_ERR, &quot;dec out: &quot;, DUMP_PREFIX_NONE, 16, 1,</span>
<span class="p_del">-		       dst, *dst_len, 1);</span>
<span class="p_del">-	*/</span>
<span class="p_del">-</span>
<span class="p_del">-out_sg:</span>
<span class="p_del">-	teardown_sgtable(&amp;sg_in);</span>
<span class="p_del">-out_tfm:</span>
<span class="p_del">-	crypto_free_skcipher(tfm);</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int ceph_aes_decrypt2(const void *key, int key_len,</span>
<span class="p_del">-			     void *dst1, size_t *dst1_len,</span>
<span class="p_del">-			     void *dst2, size_t *dst2_len,</span>
<span class="p_del">-			     const void *src, size_t src_len)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct sg_table sg_in;</span>
<span class="p_del">-	struct scatterlist sg_out[3], prealloc_sg;</span>
<span class="p_del">-	struct crypto_skcipher *tfm = ceph_crypto_alloc_cipher();</span>
<span class="p_del">-	SKCIPHER_REQUEST_ON_STACK(req, tfm);</span>
<span class="p_del">-	char pad[16];</span>
<span class="p_del">-	char iv[AES_BLOCK_SIZE];</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-	int last_byte;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (IS_ERR(tfm))</span>
<span class="p_del">-		return PTR_ERR(tfm);</span>
<span class="p_del">-</span>
<span class="p_del">-	sg_init_table(sg_out, 3);</span>
<span class="p_del">-	sg_set_buf(&amp;sg_out[0], dst1, *dst1_len);</span>
<span class="p_del">-	sg_set_buf(&amp;sg_out[1], dst2, *dst2_len);</span>
<span class="p_del">-	sg_set_buf(&amp;sg_out[2], pad, sizeof(pad));</span>
<span class="p_del">-	ret = setup_sgtable(&amp;sg_in, &amp;prealloc_sg, src, src_len);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto out_tfm;</span>
<span class="p_del">-</span>
<span class="p_del">-	crypto_skcipher_setkey((void *)tfm, key, key_len);</span>
<span class="p_del">-	memcpy(iv, aes_iv, AES_BLOCK_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-	skcipher_request_set_tfm(req, tfm);</span>
<span class="p_del">-	skcipher_request_set_callback(req, 0, NULL, NULL);</span>
<span class="p_del">-	skcipher_request_set_crypt(req, sg_in.sgl, sg_out,</span>
<span class="p_del">-				   src_len, iv);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	print_hex_dump(KERN_ERR, &quot;dec  key: &quot;, DUMP_PREFIX_NONE, 16, 1,</span>
<span class="p_del">-		       key, key_len, 1);</span>
<span class="p_del">-	print_hex_dump(KERN_ERR, &quot;dec   in: &quot;, DUMP_PREFIX_NONE, 16, 1,</span>
<span class="p_del">-		       src, src_len, 1);</span>
<span class="p_del">-	*/</span>
<span class="p_del">-	ret = crypto_skcipher_decrypt(req);</span>
<span class="p_add">+		ret = crypto_skcipher_decrypt(req);</span>
 	skcipher_request_zero(req);
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		pr_err(&quot;ceph_aes_decrypt failed %d\n&quot;, ret);</span>
<span class="p_del">-		goto out_sg;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (src_len &lt;= *dst1_len)</span>
<span class="p_del">-		last_byte = ((char *)dst1)[src_len - 1];</span>
<span class="p_del">-	else if (src_len &lt;= *dst1_len + *dst2_len)</span>
<span class="p_del">-		last_byte = ((char *)dst2)[src_len - *dst1_len - 1];</span>
<span class="p_del">-	else</span>
<span class="p_del">-		last_byte = pad[src_len - *dst1_len - *dst2_len - 1];</span>
<span class="p_del">-	if (last_byte &lt;= 16 &amp;&amp; src_len &gt;= last_byte) {</span>
<span class="p_del">-		src_len -= last_byte;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		pr_err(&quot;ceph_aes_decrypt got bad padding %d on src len %d\n&quot;,</span>
<span class="p_del">-		       last_byte, (int)src_len);</span>
<span class="p_del">-		return -EPERM;  /* bad padding */</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (src_len &lt; *dst1_len) {</span>
<span class="p_del">-		*dst1_len = src_len;</span>
<span class="p_del">-		*dst2_len = 0;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		*dst2_len = src_len - *dst1_len;</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_err(&quot;%s %scrypt failed: %d\n&quot;, __func__,</span>
<span class="p_add">+		       encrypt ? &quot;en&quot; : &quot;de&quot;, ret);</span>
<span class="p_add">+		goto out_sgt;</span>
 	}
 	/*
<span class="p_del">-	print_hex_dump(KERN_ERR, &quot;dec  out1: &quot;, DUMP_PREFIX_NONE, 16, 1,</span>
<span class="p_del">-		       dst1, *dst1_len, 1);</span>
<span class="p_del">-	print_hex_dump(KERN_ERR, &quot;dec  out2: &quot;, DUMP_PREFIX_NONE, 16, 1,</span>
<span class="p_del">-		       dst2, *dst2_len, 1);</span>
<span class="p_add">+	print_hex_dump(KERN_ERR, &quot;out: &quot;, DUMP_PREFIX_NONE, 16, 1,</span>
<span class="p_add">+		       buf, crypt_len, 1);</span>
 	*/
 
<span class="p_del">-out_sg:</span>
<span class="p_del">-	teardown_sgtable(&amp;sg_in);</span>
<span class="p_del">-out_tfm:</span>
<span class="p_del">-	crypto_free_skcipher(tfm);</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-int ceph_decrypt(struct ceph_crypto_key *secret, void *dst, size_t *dst_len,</span>
<span class="p_del">-		 const void *src, size_t src_len)</span>
<span class="p_del">-{</span>
<span class="p_del">-	switch (secret-&gt;type) {</span>
<span class="p_del">-	case CEPH_CRYPTO_NONE:</span>
<span class="p_del">-		if (*dst_len &lt; src_len)</span>
<span class="p_del">-			return -ERANGE;</span>
<span class="p_del">-		memcpy(dst, src, src_len);</span>
<span class="p_del">-		*dst_len = src_len;</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	case CEPH_CRYPTO_AES:</span>
<span class="p_del">-		return ceph_aes_decrypt(secret-&gt;key, secret-&gt;len, dst,</span>
<span class="p_del">-					dst_len, src, src_len);</span>
<span class="p_del">-</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int ceph_decrypt2(struct ceph_crypto_key *secret,</span>
<span class="p_del">-			void *dst1, size_t *dst1_len,</span>
<span class="p_del">-			void *dst2, size_t *dst2_len,</span>
<span class="p_del">-			const void *src, size_t src_len)</span>
<span class="p_del">-{</span>
<span class="p_del">-	size_t t;</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (secret-&gt;type) {</span>
<span class="p_del">-	case CEPH_CRYPTO_NONE:</span>
<span class="p_del">-		if (*dst1_len + *dst2_len &lt; src_len)</span>
<span class="p_del">-			return -ERANGE;</span>
<span class="p_del">-		t = min(*dst1_len, src_len);</span>
<span class="p_del">-		memcpy(dst1, src, t);</span>
<span class="p_del">-		*dst1_len = t;</span>
<span class="p_del">-		src += t;</span>
<span class="p_del">-		src_len -= t;</span>
<span class="p_del">-		if (src_len) {</span>
<span class="p_del">-			t = min(*dst2_len, src_len);</span>
<span class="p_del">-			memcpy(dst2, src, t);</span>
<span class="p_del">-			*dst2_len = t;</span>
<span class="p_add">+	if (encrypt) {</span>
<span class="p_add">+		*pout_len = crypt_len;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		pad_byte = *(char *)(buf + in_len - 1);</span>
<span class="p_add">+		if (pad_byte &gt; 0 &amp;&amp; pad_byte &lt;= AES_BLOCK_SIZE &amp;&amp;</span>
<span class="p_add">+		    in_len &gt;= pad_byte) {</span>
<span class="p_add">+			*pout_len = in_len - pad_byte;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			pr_err(&quot;%s got bad padding %d on in_len %d\n&quot;,</span>
<span class="p_add">+			       __func__, pad_byte, in_len);</span>
<span class="p_add">+			ret = -EPERM;</span>
<span class="p_add">+			goto out_sgt;</span>
 		}
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	case CEPH_CRYPTO_AES:</span>
<span class="p_del">-		return ceph_aes_decrypt2(secret-&gt;key, secret-&gt;len,</span>
<span class="p_del">-					 dst1, dst1_len, dst2, dst2_len,</span>
<span class="p_del">-					 src, src_len);</span>
<span class="p_del">-</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		return -EINVAL;</span>
 	}
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int ceph_encrypt(struct ceph_crypto_key *secret, void *dst, size_t *dst_len,</span>
<span class="p_del">-		 const void *src, size_t src_len)</span>
<span class="p_del">-{</span>
<span class="p_del">-	switch (secret-&gt;type) {</span>
<span class="p_del">-	case CEPH_CRYPTO_NONE:</span>
<span class="p_del">-		if (*dst_len &lt; src_len)</span>
<span class="p_del">-			return -ERANGE;</span>
<span class="p_del">-		memcpy(dst, src, src_len);</span>
<span class="p_del">-		*dst_len = src_len;</span>
<span class="p_del">-		return 0;</span>
 
<span class="p_del">-	case CEPH_CRYPTO_AES:</span>
<span class="p_del">-		return ceph_aes_encrypt(secret-&gt;key, secret-&gt;len, dst,</span>
<span class="p_del">-					dst_len, src, src_len);</span>
<span class="p_del">-</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_add">+out_sgt:</span>
<span class="p_add">+	teardown_sgtable(&amp;sgt);</span>
<span class="p_add">+	return ret;</span>
 }
 
<span class="p_del">-int ceph_encrypt2(struct ceph_crypto_key *secret, void *dst, size_t *dst_len,</span>
<span class="p_del">-		  const void *src1, size_t src1_len,</span>
<span class="p_del">-		  const void *src2, size_t src2_len)</span>
<span class="p_add">+int ceph_crypt(const struct ceph_crypto_key *key, bool encrypt,</span>
<span class="p_add">+	       void *buf, int buf_len, int in_len, int *pout_len)</span>
 {
<span class="p_del">-	switch (secret-&gt;type) {</span>
<span class="p_add">+	switch (key-&gt;type) {</span>
 	case CEPH_CRYPTO_NONE:
<span class="p_del">-		if (*dst_len &lt; src1_len + src2_len)</span>
<span class="p_del">-			return -ERANGE;</span>
<span class="p_del">-		memcpy(dst, src1, src1_len);</span>
<span class="p_del">-		memcpy(dst + src1_len, src2, src2_len);</span>
<span class="p_del">-		*dst_len = src1_len + src2_len;</span>
<span class="p_add">+		*pout_len = in_len;</span>
 		return 0;
<span class="p_del">-</span>
 	case CEPH_CRYPTO_AES:
<span class="p_del">-		return ceph_aes_encrypt2(secret-&gt;key, secret-&gt;len, dst, dst_len,</span>
<span class="p_del">-					 src1, src1_len, src2, src2_len);</span>
<span class="p_del">-</span>
<span class="p_add">+		return ceph_aes_crypt(key, encrypt, buf, buf_len, in_len,</span>
<span class="p_add">+				      pout_len);</span>
 	default:
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		return -ENOTSUPP;</span>
 	}
 }
 
<span class="p_header">diff --git a/net/ceph/crypto.h b/net/ceph/crypto.h</span>
<span class="p_header">index 2e9cab09f37b..58d83aa7740f 100644</span>
<span class="p_header">--- a/net/ceph/crypto.h</span>
<span class="p_header">+++ b/net/ceph/crypto.h</span>
<span class="p_chunk">@@ -12,37 +12,19 @@</span> <span class="p_context"> struct ceph_crypto_key {</span>
 	struct ceph_timespec created;
 	int len;
 	void *key;
<span class="p_add">+	struct crypto_skcipher *tfm;</span>
 };
 
<span class="p_del">-static inline void ceph_crypto_key_destroy(struct ceph_crypto_key *key)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (key) {</span>
<span class="p_del">-		kfree(key-&gt;key);</span>
<span class="p_del">-		key-&gt;key = NULL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 int ceph_crypto_key_clone(struct ceph_crypto_key *dst,
 			  const struct ceph_crypto_key *src);
 int ceph_crypto_key_encode(struct ceph_crypto_key *key, void **p, void *end);
 int ceph_crypto_key_decode(struct ceph_crypto_key *key, void **p, void *end);
 int ceph_crypto_key_unarmor(struct ceph_crypto_key *key, const char *in);
<span class="p_add">+void ceph_crypto_key_destroy(struct ceph_crypto_key *key);</span>
 
 /* crypto.c */
<span class="p_del">-int ceph_decrypt(struct ceph_crypto_key *secret,</span>
<span class="p_del">-		 void *dst, size_t *dst_len,</span>
<span class="p_del">-		 const void *src, size_t src_len);</span>
<span class="p_del">-int ceph_encrypt(struct ceph_crypto_key *secret,</span>
<span class="p_del">-		 void *dst, size_t *dst_len,</span>
<span class="p_del">-		 const void *src, size_t src_len);</span>
<span class="p_del">-int ceph_decrypt2(struct ceph_crypto_key *secret,</span>
<span class="p_del">-		  void *dst1, size_t *dst1_len,</span>
<span class="p_del">-		  void *dst2, size_t *dst2_len,</span>
<span class="p_del">-		  const void *src, size_t src_len);</span>
<span class="p_del">-int ceph_encrypt2(struct ceph_crypto_key *secret,</span>
<span class="p_del">-		  void *dst, size_t *dst_len,</span>
<span class="p_del">-		  const void *src1, size_t src1_len,</span>
<span class="p_del">-		  const void *src2, size_t src2_len);</span>
<span class="p_add">+int ceph_crypt(const struct ceph_crypto_key *key, bool encrypt,</span>
<span class="p_add">+	       void *buf, int buf_len, int in_len, int *pout_len);</span>
 int ceph_crypto_init(void);
 void ceph_crypto_shutdown(void);
 
<span class="p_header">diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c</span>
<span class="p_header">index a47bbc973f2d..2384b4aae064 100644</span>
<span class="p_header">--- a/net/mac80211/rx.c</span>
<span class="p_header">+++ b/net/mac80211/rx.c</span>
<span class="p_chunk">@@ -3939,21 +3939,31 @@</span> <span class="p_context"> static bool ieee80211_invoke_fast_rx(struct ieee80211_rx_data *rx,</span>
 	u64_stats_update_end(&amp;stats-&gt;syncp);
 
 	if (fast_rx-&gt;internal_forward) {
<span class="p_del">-		struct sta_info *dsta = sta_info_get(rx-&gt;sdata, skb-&gt;data);</span>
<span class="p_add">+		struct sk_buff *xmit_skb = NULL;</span>
<span class="p_add">+		bool multicast = is_multicast_ether_addr(skb-&gt;data);</span>
 
<span class="p_del">-		if (dsta) {</span>
<span class="p_add">+		if (multicast) {</span>
<span class="p_add">+			xmit_skb = skb_copy(skb, GFP_ATOMIC);</span>
<span class="p_add">+		} else if (sta_info_get(rx-&gt;sdata, skb-&gt;data)) {</span>
<span class="p_add">+			xmit_skb = skb;</span>
<span class="p_add">+			skb = NULL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (xmit_skb) {</span>
 			/*
 			 * Send to wireless media and increase priority by 256
 			 * to keep the received priority instead of
 			 * reclassifying the frame (see cfg80211_classify8021d).
 			 */
<span class="p_del">-			skb-&gt;priority += 256;</span>
<span class="p_del">-			skb-&gt;protocol = htons(ETH_P_802_3);</span>
<span class="p_del">-			skb_reset_network_header(skb);</span>
<span class="p_del">-			skb_reset_mac_header(skb);</span>
<span class="p_del">-			dev_queue_xmit(skb);</span>
<span class="p_del">-			return true;</span>
<span class="p_add">+			xmit_skb-&gt;priority += 256;</span>
<span class="p_add">+			xmit_skb-&gt;protocol = htons(ETH_P_802_3);</span>
<span class="p_add">+			skb_reset_network_header(xmit_skb);</span>
<span class="p_add">+			skb_reset_mac_header(xmit_skb);</span>
<span class="p_add">+			dev_queue_xmit(xmit_skb);</span>
 		}
<span class="p_add">+</span>
<span class="p_add">+		if (!skb)</span>
<span class="p_add">+			return true;</span>
 	}
 
 	/* deliver to local stack */
<span class="p_header">diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_header">index 45662d7f0943..6fdffde28733 100644</span>
<span class="p_header">--- a/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_header">+++ b/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_chunk">@@ -1489,7 +1489,7 @@</span> <span class="p_context"> svcauth_gss_accept(struct svc_rqst *rqstp, __be32 *authp)</span>
 	case RPC_GSS_PROC_DESTROY:
 		if (gss_write_verf(rqstp, rsci-&gt;mechctx, gc-&gt;gc_seq))
 			goto auth_err;
<span class="p_del">-		rsci-&gt;h.expiry_time = get_seconds();</span>
<span class="p_add">+		rsci-&gt;h.expiry_time = seconds_since_boot();</span>
 		set_bit(CACHE_NEGATIVE, &amp;rsci-&gt;h.flags);
 		if (resv-&gt;iov_len + 4 &gt; PAGE_SIZE)
 			goto drop;
<span class="p_header">diff --git a/net/sunrpc/svc_xprt.c b/net/sunrpc/svc_xprt.c</span>
<span class="p_header">index 3bc1d61694cb..9c9db55a0c1e 100644</span>
<span class="p_header">--- a/net/sunrpc/svc_xprt.c</span>
<span class="p_header">+++ b/net/sunrpc/svc_xprt.c</span>
<span class="p_chunk">@@ -799,6 +799,8 @@</span> <span class="p_context"> static int svc_handle_xprt(struct svc_rqst *rqstp, struct svc_xprt *xprt)</span>
 
 	if (test_bit(XPT_CLOSE, &amp;xprt-&gt;xpt_flags)) {
 		dprintk(&quot;svc_recv: found XPT_CLOSE\n&quot;);
<span class="p_add">+		if (test_and_clear_bit(XPT_KILL_TEMP, &amp;xprt-&gt;xpt_flags))</span>
<span class="p_add">+			xprt-&gt;xpt_ops-&gt;xpo_kill_temp_xprt(xprt);</span>
 		svc_delete_xprt(xprt);
 		/* Leave XPT_BUSY set on the dead xprt: */
 		goto out;
<span class="p_chunk">@@ -1020,9 +1022,11 @@</span> <span class="p_context"> void svc_age_temp_xprts_now(struct svc_serv *serv, struct sockaddr *server_addr)</span>
 		le = to_be_closed.next;
 		list_del_init(le);
 		xprt = list_entry(le, struct svc_xprt, xpt_list);
<span class="p_del">-		dprintk(&quot;svc_age_temp_xprts_now: closing %p\n&quot;, xprt);</span>
<span class="p_del">-		xprt-&gt;xpt_ops-&gt;xpo_kill_temp_xprt(xprt);</span>
<span class="p_del">-		svc_close_xprt(xprt);</span>
<span class="p_add">+		set_bit(XPT_CLOSE, &amp;xprt-&gt;xpt_flags);</span>
<span class="p_add">+		set_bit(XPT_KILL_TEMP, &amp;xprt-&gt;xpt_flags);</span>
<span class="p_add">+		dprintk(&quot;svc_age_temp_xprts_now: queuing xprt %p for closing\n&quot;,</span>
<span class="p_add">+				xprt);</span>
<span class="p_add">+		svc_xprt_enqueue(xprt);</span>
 	}
 }
 EXPORT_SYMBOL_GPL(svc_age_temp_xprts_now);
<span class="p_header">diff --git a/net/sunrpc/xprtrdma/frwr_ops.c b/net/sunrpc/xprtrdma/frwr_ops.c</span>
<span class="p_header">index 26b26beef2d4..adbf52c6df83 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtrdma/frwr_ops.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtrdma/frwr_ops.c</span>
<span class="p_chunk">@@ -421,7 +421,7 @@</span> <span class="p_context"> frwr_op_map(struct rpcrdma_xprt *r_xprt, struct rpcrdma_mr_seg *seg,</span>
 			 IB_ACCESS_REMOTE_WRITE | IB_ACCESS_LOCAL_WRITE :
 			 IB_ACCESS_REMOTE_READ;
 
<span class="p_del">-	DECR_CQCOUNT(&amp;r_xprt-&gt;rx_ep);</span>
<span class="p_add">+	rpcrdma_set_signaled(&amp;r_xprt-&gt;rx_ep, &amp;reg_wr-&gt;wr);</span>
 	rc = ib_post_send(ia-&gt;ri_id-&gt;qp, &amp;reg_wr-&gt;wr, &amp;bad_wr);
 	if (rc)
 		goto out_senderr;
<span class="p_chunk">@@ -486,7 +486,7 @@</span> <span class="p_context"> frwr_op_unmap_sync(struct rpcrdma_xprt *r_xprt, struct rpcrdma_req *req)</span>
 	struct rpcrdma_ia *ia = &amp;r_xprt-&gt;rx_ia;
 	struct rpcrdma_mw *mw, *tmp;
 	struct rpcrdma_frmr *f;
<span class="p_del">-	int rc;</span>
<span class="p_add">+	int count, rc;</span>
 
 	dprintk(&quot;RPC:       %s: req %p\n&quot;, __func__, req);
 
<span class="p_chunk">@@ -496,6 +496,7 @@</span> <span class="p_context"> frwr_op_unmap_sync(struct rpcrdma_xprt *r_xprt, struct rpcrdma_req *req)</span>
 	 * a single ib_post_send() call.
 	 */
 	f = NULL;
<span class="p_add">+	count = 0;</span>
 	invalidate_wrs = pos = prev = NULL;
 	list_for_each_entry(mw, &amp;req-&gt;rl_registered, mw_list) {
 		if ((rep-&gt;rr_wc_flags &amp; IB_WC_WITH_INVALIDATE) &amp;&amp;
<span class="p_chunk">@@ -505,6 +506,7 @@</span> <span class="p_context"> frwr_op_unmap_sync(struct rpcrdma_xprt *r_xprt, struct rpcrdma_req *req)</span>
 		}
 
 		pos = __frwr_prepare_linv_wr(mw);
<span class="p_add">+		count++;</span>
 
 		if (!invalidate_wrs)
 			invalidate_wrs = pos;
<span class="p_chunk">@@ -523,7 +525,12 @@</span> <span class="p_context"> frwr_op_unmap_sync(struct rpcrdma_xprt *r_xprt, struct rpcrdma_req *req)</span>
 	f-&gt;fr_invwr.send_flags = IB_SEND_SIGNALED;
 	f-&gt;fr_cqe.done = frwr_wc_localinv_wake;
 	reinit_completion(&amp;f-&gt;fr_linv_done);
<span class="p_del">-	INIT_CQCOUNT(&amp;r_xprt-&gt;rx_ep);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Initialize CQ count, since there is always a signaled</span>
<span class="p_add">+	 * WR being posted here.  The new cqcount depends on how</span>
<span class="p_add">+	 * many SQEs are about to be consumed.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	rpcrdma_init_cqcount(&amp;r_xprt-&gt;rx_ep, count);</span>
 
 	/* Transport disconnect drains the receive CQ before it
 	 * replaces the QP. The RPC reply handler won&#39;t call us
<span class="p_header">diff --git a/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c b/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c</span>
<span class="p_header">index ad1df979b3f0..a47c9bdef5fa 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c</span>
<span class="p_chunk">@@ -348,8 +348,6 @@</span> <span class="p_context"> int rdma_read_chunk_frmr(struct svcxprt_rdma *xprt,</span>
 	atomic_inc(&amp;rdma_stat_read);
 	return ret;
  err:
<span class="p_del">-	ib_dma_unmap_sg(xprt-&gt;sc_cm_id-&gt;device,</span>
<span class="p_del">-			frmr-&gt;sg, frmr-&gt;sg_nents, frmr-&gt;direction);</span>
 	svc_rdma_put_context(ctxt, 0);
 	svc_rdma_put_frmr(xprt, frmr);
 	return ret;
<span class="p_header">diff --git a/net/sunrpc/xprtrdma/verbs.c b/net/sunrpc/xprtrdma/verbs.c</span>
<span class="p_header">index ec74289af7ec..8da7f6a4dfc3 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtrdma/verbs.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtrdma/verbs.c</span>
<span class="p_chunk">@@ -223,8 +223,8 @@</span> <span class="p_context"> rpcrdma_update_connect_private(struct rpcrdma_xprt *r_xprt,</span>
 		cdata-&gt;inline_rsize = rsize;
 	if (wsize &lt; cdata-&gt;inline_wsize)
 		cdata-&gt;inline_wsize = wsize;
<span class="p_del">-	pr_info(&quot;rpcrdma: max send %u, max recv %u\n&quot;,</span>
<span class="p_del">-		cdata-&gt;inline_wsize, cdata-&gt;inline_rsize);</span>
<span class="p_add">+	dprintk(&quot;RPC:       %s: max send %u, max recv %u\n&quot;,</span>
<span class="p_add">+		__func__, cdata-&gt;inline_wsize, cdata-&gt;inline_rsize);</span>
 	rpcrdma_set_max_header_sizes(r_xprt);
 }
 
<span class="p_chunk">@@ -532,7 +532,7 @@</span> <span class="p_context"> rpcrdma_ep_create(struct rpcrdma_ep *ep, struct rpcrdma_ia *ia,</span>
 	ep-&gt;rep_cqinit = ep-&gt;rep_attr.cap.max_send_wr/2 - 1;
 	if (ep-&gt;rep_cqinit &lt;= 2)
 		ep-&gt;rep_cqinit = 0;	/* always signal? */
<span class="p_del">-	INIT_CQCOUNT(ep);</span>
<span class="p_add">+	rpcrdma_init_cqcount(ep, 0);</span>
 	init_waitqueue_head(&amp;ep-&gt;rep_connect_wait);
 	INIT_DELAYED_WORK(&amp;ep-&gt;rep_connect_worker, rpcrdma_connect_worker);
 
<span class="p_chunk">@@ -1311,13 +1311,7 @@</span> <span class="p_context"> rpcrdma_ep_post(struct rpcrdma_ia *ia,</span>
 	dprintk(&quot;RPC:       %s: posting %d s/g entries\n&quot;,
 		__func__, send_wr-&gt;num_sge);
 
<span class="p_del">-	if (DECR_CQCOUNT(ep) &gt; 0)</span>
<span class="p_del">-		send_wr-&gt;send_flags = 0;</span>
<span class="p_del">-	else { /* Provider must take a send completion every now and then */</span>
<span class="p_del">-		INIT_CQCOUNT(ep);</span>
<span class="p_del">-		send_wr-&gt;send_flags = IB_SEND_SIGNALED;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_add">+	rpcrdma_set_signaled(ep, send_wr);</span>
 	rc = ib_post_send(ia-&gt;ri_id-&gt;qp, send_wr, &amp;send_wr_fail);
 	if (rc)
 		goto out_postsend_err;
<span class="p_header">diff --git a/net/sunrpc/xprtrdma/xprt_rdma.h b/net/sunrpc/xprtrdma/xprt_rdma.h</span>
<span class="p_header">index 6e1bba358203..f6ae1b22da47 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtrdma/xprt_rdma.h</span>
<span class="p_header">+++ b/net/sunrpc/xprtrdma/xprt_rdma.h</span>
<span class="p_chunk">@@ -95,8 +95,24 @@</span> <span class="p_context"> struct rpcrdma_ep {</span>
 	struct delayed_work	rep_connect_worker;
 };
 
<span class="p_del">-#define INIT_CQCOUNT(ep) atomic_set(&amp;(ep)-&gt;rep_cqcount, (ep)-&gt;rep_cqinit)</span>
<span class="p_del">-#define DECR_CQCOUNT(ep) atomic_sub_return(1, &amp;(ep)-&gt;rep_cqcount)</span>
<span class="p_add">+static inline void</span>
<span class="p_add">+rpcrdma_init_cqcount(struct rpcrdma_ep *ep, int count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	atomic_set(&amp;ep-&gt;rep_cqcount, ep-&gt;rep_cqinit - count);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* To update send queue accounting, provider must take a</span>
<span class="p_add">+ * send completion every now and then.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void</span>
<span class="p_add">+rpcrdma_set_signaled(struct rpcrdma_ep *ep, struct ib_send_wr *send_wr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	send_wr-&gt;send_flags = 0;</span>
<span class="p_add">+	if (unlikely(atomic_sub_return(1, &amp;ep-&gt;rep_cqcount) &lt;= 0)) {</span>
<span class="p_add">+		rpcrdma_init_cqcount(ep, 0);</span>
<span class="p_add">+		send_wr-&gt;send_flags = IB_SEND_SIGNALED;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
 
 /* Pre-allocate extra Work Requests for handling backward receives
  * and sends. This is a fixed value because the Work Queues are
<span class="p_header">diff --git a/tools/perf/Makefile.config b/tools/perf/Makefile.config</span>
<span class="p_header">index 72edf83d76b7..cffdd9cf3ebf 100644</span>
<span class="p_header">--- a/tools/perf/Makefile.config</span>
<span class="p_header">+++ b/tools/perf/Makefile.config</span>
<span class="p_chunk">@@ -366,7 +366,7 @@</span> <span class="p_context"> ifndef NO_SDT</span>
 endif
 
 ifdef PERF_HAVE_JITDUMP
<span class="p_del">-  ifndef NO_DWARF</span>
<span class="p_add">+  ifndef NO_LIBELF</span>
     $(call detected,CONFIG_JITDUMP)
     CFLAGS += -DHAVE_JITDUMP
   endif
<span class="p_header">diff --git a/tools/perf/builtin-mem.c b/tools/perf/builtin-mem.c</span>
<span class="p_header">index d1ce29be560e..cd7bc4d104e2 100644</span>
<span class="p_header">--- a/tools/perf/builtin-mem.c</span>
<span class="p_header">+++ b/tools/perf/builtin-mem.c</span>
<span class="p_chunk">@@ -70,8 +70,8 @@</span> <span class="p_context"> static int __cmd_record(int argc, const char **argv, struct perf_mem *mem)</span>
 	OPT_UINTEGER(0, &quot;ldlat&quot;, &amp;perf_mem_events__loads_ldlat, &quot;mem-loads latency&quot;),
 	OPT_INCR(&#39;v&#39;, &quot;verbose&quot;, &amp;verbose,
 		 &quot;be more verbose (show counter open errors, etc)&quot;),
<span class="p_del">-	OPT_BOOLEAN(&#39;U&#39;, &quot;--all-user&quot;, &amp;all_user, &quot;collect only user level data&quot;),</span>
<span class="p_del">-	OPT_BOOLEAN(&#39;K&#39;, &quot;--all-kernel&quot;, &amp;all_kernel, &quot;collect only kernel level data&quot;),</span>
<span class="p_add">+	OPT_BOOLEAN(&#39;U&#39;, &quot;all-user&quot;, &amp;all_user, &quot;collect only user level data&quot;),</span>
<span class="p_add">+	OPT_BOOLEAN(&#39;K&#39;, &quot;all-kernel&quot;, &amp;all_kernel, &quot;collect only kernel level data&quot;),</span>
 	OPT_END()
 	};
 
<span class="p_header">diff --git a/tools/perf/builtin-trace.c b/tools/perf/builtin-trace.c</span>
<span class="p_header">index c298bd3e1d90..21f8a81797a0 100644</span>
<span class="p_header">--- a/tools/perf/builtin-trace.c</span>
<span class="p_header">+++ b/tools/perf/builtin-trace.c</span>
<span class="p_chunk">@@ -1452,7 +1452,7 @@</span> <span class="p_context"> static int trace__printf_interrupted_entry(struct trace *trace, struct perf_samp</span>
 
 	duration = sample-&gt;time - ttrace-&gt;entry_time;
 
<span class="p_del">-	printed  = trace__fprintf_entry_head(trace, trace-&gt;current, duration, sample-&gt;time, trace-&gt;output);</span>
<span class="p_add">+	printed  = trace__fprintf_entry_head(trace, trace-&gt;current, duration, ttrace-&gt;entry_time, trace-&gt;output);</span>
 	printed += fprintf(trace-&gt;output, &quot;%-70s) ...\n&quot;, ttrace-&gt;entry_str);
 	ttrace-&gt;entry_pending = false;
 
<span class="p_chunk">@@ -1499,7 +1499,7 @@</span> <span class="p_context"> static int trace__sys_enter(struct trace *trace, struct perf_evsel *evsel,</span>
 
 	if (sc-&gt;is_exit) {
 		if (!(trace-&gt;duration_filter || trace-&gt;summary_only || trace-&gt;min_stack)) {
<span class="p_del">-			trace__fprintf_entry_head(trace, thread, 1, sample-&gt;time, trace-&gt;output);</span>
<span class="p_add">+			trace__fprintf_entry_head(trace, thread, 1, ttrace-&gt;entry_time, trace-&gt;output);</span>
 			fprintf(trace-&gt;output, &quot;%-70s)\n&quot;, ttrace-&gt;entry_str);
 		}
 	} else {
<span class="p_chunk">@@ -1592,7 +1592,7 @@</span> <span class="p_context"> static int trace__sys_exit(struct trace *trace, struct perf_evsel *evsel,</span>
 	if (trace-&gt;summary_only)
 		goto out;
 
<span class="p_del">-	trace__fprintf_entry_head(trace, thread, duration, sample-&gt;time, trace-&gt;output);</span>
<span class="p_add">+	trace__fprintf_entry_head(trace, thread, duration, ttrace-&gt;entry_time, trace-&gt;output);</span>
 
 	if (ttrace-&gt;entry_pending) {
 		fprintf(trace-&gt;output, &quot;%-70s&quot;, ttrace-&gt;entry_str);
<span class="p_header">diff --git a/tools/perf/trace/beauty/mmap.c b/tools/perf/trace/beauty/mmap.c</span>
<span class="p_header">index fd710ab33684..af1cfde6b97b 100644</span>
<span class="p_header">--- a/tools/perf/trace/beauty/mmap.c</span>
<span class="p_header">+++ b/tools/perf/trace/beauty/mmap.c</span>
<span class="p_chunk">@@ -42,7 +42,9 @@</span> <span class="p_context"> static size_t syscall_arg__scnprintf_mmap_flags(char *bf, size_t size,</span>
 
 	P_MMAP_FLAG(SHARED);
 	P_MMAP_FLAG(PRIVATE);
<span class="p_add">+#ifdef MAP_32BIT</span>
 	P_MMAP_FLAG(32BIT);
<span class="p_add">+#endif</span>
 	P_MMAP_FLAG(ANONYMOUS);
 	P_MMAP_FLAG(DENYWRITE);
 	P_MMAP_FLAG(EXECUTABLE);
<span class="p_header">diff --git a/tools/perf/util/Build b/tools/perf/util/Build</span>
<span class="p_header">index eb60e613d795..1dc67efad634 100644</span>
<span class="p_header">--- a/tools/perf/util/Build</span>
<span class="p_header">+++ b/tools/perf/util/Build</span>
<span class="p_chunk">@@ -120,7 +120,7 @@</span> <span class="p_context"> libperf-y += demangle-rust.o</span>
 ifdef CONFIG_JITDUMP
 libperf-$(CONFIG_LIBELF) += jitdump.o
 libperf-$(CONFIG_LIBELF) += genelf.o
<span class="p_del">-libperf-$(CONFIG_LIBELF) += genelf_debug.o</span>
<span class="p_add">+libperf-$(CONFIG_DWARF) += genelf_debug.o</span>
 endif
 
 CFLAGS_config.o   += -DETC_PERFCONFIG=&quot;BUILD_STR($(ETC_PERFCONFIG_SQ))&quot;
<span class="p_header">diff --git a/tools/perf/util/callchain.c b/tools/perf/util/callchain.c</span>
<span class="p_header">index 07fd30bc2f81..ae58b493af45 100644</span>
<span class="p_header">--- a/tools/perf/util/callchain.c</span>
<span class="p_header">+++ b/tools/perf/util/callchain.c</span>
<span class="p_chunk">@@ -193,7 +193,6 @@</span> <span class="p_context"> int perf_callchain_config(const char *var, const char *value)</span>
 
 	if (!strcmp(var, &quot;record-mode&quot;))
 		return parse_callchain_record_opt(value, &amp;callchain_param);
<span class="p_del">-#ifdef HAVE_DWARF_UNWIND_SUPPORT</span>
 	if (!strcmp(var, &quot;dump-size&quot;)) {
 		unsigned long size = 0;
 		int ret;
<span class="p_chunk">@@ -203,7 +202,6 @@</span> <span class="p_context"> int perf_callchain_config(const char *var, const char *value)</span>
 
 		return ret;
 	}
<span class="p_del">-#endif</span>
 	if (!strcmp(var, &quot;print-type&quot;))
 		return parse_callchain_mode(value);
 	if (!strcmp(var, &quot;order&quot;))
<span class="p_header">diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h</span>
<span class="p_header">index 13e75549c440..47cfd1080975 100644</span>
<span class="p_header">--- a/tools/perf/util/callchain.h</span>
<span class="p_header">+++ b/tools/perf/util/callchain.h</span>
<span class="p_chunk">@@ -11,11 +11,7 @@</span> <span class="p_context"></span>
 
 #define CALLCHAIN_HELP &quot;setup and enables call-graph (stack chain/backtrace):\n\n&quot;
 
<span class="p_del">-#ifdef HAVE_DWARF_UNWIND_SUPPORT</span>
 # define RECORD_MODE_HELP  HELP_PAD &quot;record_mode:\tcall graph recording mode (fp|dwarf|lbr)\n&quot;
<span class="p_del">-#else</span>
<span class="p_del">-# define RECORD_MODE_HELP  HELP_PAD &quot;record_mode:\tcall graph recording mode (fp|lbr)\n&quot;</span>
<span class="p_del">-#endif</span>
 
 #define RECORD_SIZE_HELP						\
 	HELP_PAD &quot;record_size:\tif record_mode is &#39;dwarf&#39;, max size of stack recording (&lt;bytes&gt;)\n&quot; \
<span class="p_header">diff --git a/tools/perf/util/genelf.c b/tools/perf/util/genelf.c</span>
<span class="p_header">index c1ef805c6a8f..14a73acc549c 100644</span>
<span class="p_header">--- a/tools/perf/util/genelf.c</span>
<span class="p_header">+++ b/tools/perf/util/genelf.c</span>
<span class="p_chunk">@@ -19,7 +19,9 @@</span> <span class="p_context"></span>
 #include &lt;limits.h&gt;
 #include &lt;fcntl.h&gt;
 #include &lt;err.h&gt;
<span class="p_add">+#ifdef HAVE_DWARF_SUPPORT</span>
 #include &lt;dwarf.h&gt;
<span class="p_add">+#endif</span>
 
 #include &quot;perf.h&quot;
 #include &quot;genelf.h&quot;
<span class="p_chunk">@@ -157,7 +159,7 @@</span> <span class="p_context"> gen_build_id(struct buildid_note *note, unsigned long load_addr, const void *cod</span>
 int
 jit_write_elf(int fd, uint64_t load_addr, const char *sym,
 	      const void *code, int csize,
<span class="p_del">-	      void *debug, int nr_debug_entries)</span>
<span class="p_add">+	      void *debug __maybe_unused, int nr_debug_entries __maybe_unused)</span>
 {
 	Elf *e;
 	Elf_Data *d;
<span class="p_chunk">@@ -386,11 +388,14 @@</span> <span class="p_context"> jit_write_elf(int fd, uint64_t load_addr, const char *sym,</span>
 	shdr-&gt;sh_size = sizeof(bnote);
 	shdr-&gt;sh_entsize = 0;
 
<span class="p_add">+#ifdef HAVE_DWARF_SUPPORT</span>
 	if (debug &amp;&amp; nr_debug_entries) {
 		retval = jit_add_debug_info(e, load_addr, debug, nr_debug_entries);
 		if (retval)
 			goto error;
<span class="p_del">-	} else {</span>
<span class="p_add">+	} else</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	{</span>
 		if (elf_update(e, ELF_C_WRITE) &lt; 0) {
 			warnx(&quot;elf_update 4 failed&quot;);
 			goto error;
<span class="p_header">diff --git a/tools/perf/util/genelf.h b/tools/perf/util/genelf.h</span>
<span class="p_header">index 2fbeb59c4bdd..5c933ac71451 100644</span>
<span class="p_header">--- a/tools/perf/util/genelf.h</span>
<span class="p_header">+++ b/tools/perf/util/genelf.h</span>
<span class="p_chunk">@@ -4,8 +4,10 @@</span> <span class="p_context"></span>
 /* genelf.c */
 int jit_write_elf(int fd, uint64_t code_addr, const char *sym,
 		  const void *code, int csize, void *debug, int nr_debug_entries);
<span class="p_add">+#ifdef HAVE_DWARF_SUPPORT</span>
 /* genelf_debug.c */
 int jit_add_debug_info(Elf *e, uint64_t code_addr, void *debug, int nr_debug_entries);
<span class="p_add">+#endif</span>
 
 #if   defined(__arm__)
 #define GEN_ELF_ARCH	EM_ARM
<span class="p_header">diff --git a/tools/perf/util/symbol.c b/tools/perf/util/symbol.c</span>
<span class="p_header">index aecff69a510d..f7b35e178582 100644</span>
<span class="p_header">--- a/tools/perf/util/symbol.c</span>
<span class="p_header">+++ b/tools/perf/util/symbol.c</span>
<span class="p_chunk">@@ -1459,7 +1459,8 @@</span> <span class="p_context"> int dso__load(struct dso *dso, struct map *map)</span>
 	 * Read the build id if possible. This is required for
 	 * DSO_BINARY_TYPE__BUILDID_DEBUGINFO to work
 	 */
<span class="p_del">-	if (is_regular_file(dso-&gt;long_name) &amp;&amp;</span>
<span class="p_add">+	if (!dso-&gt;has_build_id &amp;&amp;</span>
<span class="p_add">+	    is_regular_file(dso-&gt;long_name) &amp;&amp;</span>
 	    filename__read_build_id(dso-&gt;long_name, build_id, BUILD_ID_SIZE) &gt; 0)
 		dso__set_build_id(dso, build_id);
 
<span class="p_header">diff --git a/tools/perf/util/trace-event-scripting.c b/tools/perf/util/trace-event-scripting.c</span>
<span class="p_header">index 9df61059a85d..a2fd6e79d5a5 100644</span>
<span class="p_header">--- a/tools/perf/util/trace-event-scripting.c</span>
<span class="p_header">+++ b/tools/perf/util/trace-event-scripting.c</span>
<span class="p_chunk">@@ -95,7 +95,8 @@</span> <span class="p_context"> static void register_python_scripting(struct scripting_ops *scripting_ops)</span>
 	if (err)
 		die(&quot;error registering py script extension&quot;);
 
<span class="p_del">-	scripting_context = malloc(sizeof(struct scripting_context));</span>
<span class="p_add">+	if (scripting_context == NULL)</span>
<span class="p_add">+		scripting_context = malloc(sizeof(*scripting_context));</span>
 }
 
 #ifdef NO_LIBPYTHON
<span class="p_chunk">@@ -159,7 +160,8 @@</span> <span class="p_context"> static void register_perl_scripting(struct scripting_ops *scripting_ops)</span>
 	if (err)
 		die(&quot;error registering pl script extension&quot;);
 
<span class="p_del">-	scripting_context = malloc(sizeof(struct scripting_context));</span>
<span class="p_add">+	if (scripting_context == NULL)</span>
<span class="p_add">+		scripting_context = malloc(sizeof(*scripting_context));</span>
 }
 
 #ifdef NO_LIBPERL
<span class="p_header">diff --git a/tools/testing/selftests/powerpc/pmu/ebb/pmc56_overflow_test.c b/tools/testing/selftests/powerpc/pmu/ebb/pmc56_overflow_test.c</span>
<span class="p_header">index c22860ab9733..30e1ac62e8cb 100644</span>
<span class="p_header">--- a/tools/testing/selftests/powerpc/pmu/ebb/pmc56_overflow_test.c</span>
<span class="p_header">+++ b/tools/testing/selftests/powerpc/pmu/ebb/pmc56_overflow_test.c</span>
<span class="p_chunk">@@ -66,7 +66,7 @@</span> <span class="p_context"> int pmc56_overflow(void)</span>
 
 	FAIL_IF(ebb_event_enable(&amp;event));
 
<span class="p_del">-	mtspr(SPRN_PMC1, pmc_sample_period(sample_period));</span>
<span class="p_add">+	mtspr(SPRN_PMC2, pmc_sample_period(sample_period));</span>
 	mtspr(SPRN_PMC5, 0);
 	mtspr(SPRN_PMC6, 0);
 
<span class="p_header">diff --git a/tools/virtio/ringtest/run-on-all.sh b/tools/virtio/ringtest/run-on-all.sh</span>
<span class="p_header">index 2e69ca812b4c..29b0d3920bfc 100755</span>
<span class="p_header">--- a/tools/virtio/ringtest/run-on-all.sh</span>
<span class="p_header">+++ b/tools/virtio/ringtest/run-on-all.sh</span>
<span class="p_chunk">@@ -1,12 +1,13 @@</span> <span class="p_context"></span>
 #!/bin/sh
 
<span class="p_add">+CPUS_ONLINE=$(lscpu --online -p=cpu|grep -v -e &#39;#&#39;)</span>
 #use last CPU for host. Why not the first?
 #many devices tend to use cpu0 by default so
 #it tends to be busier
<span class="p_del">-HOST_AFFINITY=$(lscpu -p=cpu | tail -1)</span>
<span class="p_add">+HOST_AFFINITY=$(echo &quot;${CPUS_ONLINE}&quot;|tail -n 1)</span>
 
 #run command on all cpus
<span class="p_del">-for cpu in $(seq 0 $HOST_AFFINITY)</span>
<span class="p_add">+for cpu in $CPUS_ONLINE</span>
 do
 	#Don&#39;t run guest and host on same CPU
 	#It actually works ok if using signalling
<span class="p_header">diff --git a/virt/kvm/arm/vgic/vgic-init.c b/virt/kvm/arm/vgic/vgic-init.c</span>
<span class="p_header">index 8cebfbc19e90..539d3f5cb619 100644</span>
<span class="p_header">--- a/virt/kvm/arm/vgic/vgic-init.c</span>
<span class="p_header">+++ b/virt/kvm/arm/vgic/vgic-init.c</span>
<span class="p_chunk">@@ -268,15 +268,11 @@</span> <span class="p_context"> static void kvm_vgic_dist_destroy(struct kvm *kvm)</span>
 {
 	struct vgic_dist *dist = &amp;kvm-&gt;arch.vgic;
 
<span class="p_del">-	mutex_lock(&amp;kvm-&gt;lock);</span>
<span class="p_del">-</span>
 	dist-&gt;ready = false;
 	dist-&gt;initialized = false;
 
 	kfree(dist-&gt;spis);
 	dist-&gt;nr_spis = 0;
<span class="p_del">-</span>
<span class="p_del">-	mutex_unlock(&amp;kvm-&gt;lock);</span>
 }
 
 void kvm_vgic_vcpu_destroy(struct kvm_vcpu *vcpu)
<span class="p_chunk">@@ -286,7 +282,8 @@</span> <span class="p_context"> void kvm_vgic_vcpu_destroy(struct kvm_vcpu *vcpu)</span>
 	INIT_LIST_HEAD(&amp;vgic_cpu-&gt;ap_list_head);
 }
 
<span class="p_del">-void kvm_vgic_destroy(struct kvm *kvm)</span>
<span class="p_add">+/* To be called with kvm-&gt;lock held */</span>
<span class="p_add">+static void __kvm_vgic_destroy(struct kvm *kvm)</span>
 {
 	struct kvm_vcpu *vcpu;
 	int i;
<span class="p_chunk">@@ -297,6 +294,13 @@</span> <span class="p_context"> void kvm_vgic_destroy(struct kvm *kvm)</span>
 		kvm_vgic_vcpu_destroy(vcpu);
 }
 
<span class="p_add">+void kvm_vgic_destroy(struct kvm *kvm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mutex_lock(&amp;kvm-&gt;lock);</span>
<span class="p_add">+	__kvm_vgic_destroy(kvm);</span>
<span class="p_add">+	mutex_unlock(&amp;kvm-&gt;lock);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * vgic_lazy_init: Lazy init is only allowed if the GIC exposed to the guest
  * is a GICv2. A GICv3 must be explicitly initialized by the guest using the
<span class="p_chunk">@@ -348,6 +352,10 @@</span> <span class="p_context"> int kvm_vgic_map_resources(struct kvm *kvm)</span>
 		ret = vgic_v2_map_resources(kvm);
 	else
 		ret = vgic_v3_map_resources(kvm);
<span class="p_add">+</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		__kvm_vgic_destroy(kvm);</span>
<span class="p_add">+</span>
 out:
 	mutex_unlock(&amp;kvm-&gt;lock);
 	return ret;
<span class="p_header">diff --git a/virt/kvm/arm/vgic/vgic-v2.c b/virt/kvm/arm/vgic/vgic-v2.c</span>
<span class="p_header">index 9bab86757fa4..834137e7b83f 100644</span>
<span class="p_header">--- a/virt/kvm/arm/vgic/vgic-v2.c</span>
<span class="p_header">+++ b/virt/kvm/arm/vgic/vgic-v2.c</span>
<span class="p_chunk">@@ -293,8 +293,6 @@</span> <span class="p_context"> int vgic_v2_map_resources(struct kvm *kvm)</span>
 	dist-&gt;ready = true;
 
 out:
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		kvm_vgic_destroy(kvm);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/virt/kvm/arm/vgic/vgic-v3.c b/virt/kvm/arm/vgic/vgic-v3.c</span>
<span class="p_header">index 5c9f9745e6ca..e6b03fd8c374 100644</span>
<span class="p_header">--- a/virt/kvm/arm/vgic/vgic-v3.c</span>
<span class="p_header">+++ b/virt/kvm/arm/vgic/vgic-v3.c</span>
<span class="p_chunk">@@ -302,8 +302,6 @@</span> <span class="p_context"> int vgic_v3_map_resources(struct kvm *kvm)</span>
 	dist-&gt;ready = true;
 
 out:
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		kvm_vgic_destroy(kvm);</span>
 	return ret;
 }
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



