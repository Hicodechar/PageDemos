
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3.2,00/87] 3.2.77-rc1 review - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3.2,00/87] 3.2.77-rc1 review</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Feb. 9, 2016, 12:21 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1454977265.2654.2.camel@decadent.org.uk&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8256571/mbox/"
   >mbox</a>
|
   <a href="/patch/8256571/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8256571/">/patch/8256571/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 2504C9F319
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  9 Feb 2016 00:22:54 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id C58662017E
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  9 Feb 2016 00:22:48 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 87E15202FF
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  9 Feb 2016 00:22:43 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S933394AbcBIAWm (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 8 Feb 2016 19:22:42 -0500
Received: from shadbolt.e.decadent.org.uk ([88.96.1.126]:60291 &quot;EHLO
	shadbolt.e.decadent.org.uk&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S965174AbcBIAVX (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 8 Feb 2016 19:21:23 -0500
Received: from [2a02:8011:400e:2:a11:96ff:fe28:a980] (helo=deadeye)
	by shadbolt.decadent.org.uk with esmtps
	(TLS1.2:ECDHE_RSA_AES_128_GCM_SHA256:128) (Exim 4.84)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1aSw3U-0007M3-4B; Tue, 09 Feb 2016 00:21:20 +0000
Received: from ben by deadeye with local (Exim 4.86)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1aSw3O-0003GO-ST; Tue, 09 Feb 2016 00:21:14 +0000
Message-ID: &lt;1454977265.2654.2.camel@decadent.org.uk&gt;
Subject: Re: [PATCH 3.2 00/87] 3.2.77-rc1 review
From: Ben Hutchings &lt;ben@decadent.org.uk&gt;
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org
Cc: torvalds@linux-foundation.org, Guenter Roeck &lt;linux@roeck-us.net&gt;,
	Phil Jensen &lt;pjensen@evernote.com&gt;, akpm@linux-foundation.org
Date: Tue, 09 Feb 2016 00:21:05 +0000
In-Reply-To: &lt;lsq.1454975630.125133756@decadent.org.uk&gt;
References: &lt;lsq.1454975630.125133756@decadent.org.uk&gt;
Content-Type: multipart/signed; micalg=&quot;pgp-sha512&quot;;
	protocol=&quot;application/pgp-signature&quot;;
	boundary=&quot;=-25Cyi/y4Sp2UIQC/Yx/Q&quot;
X-Mailer: Evolution 3.18.3-1 
Mime-Version: 1.0
X-SA-Exim-Connect-IP: 2a02:8011:400e:2:a11:96ff:fe28:a980
X-SA-Exim-Mail-From: ben@decadent.org.uk
X-SA-Exim-Scanned: No (on shadbolt.decadent.org.uk);
	SAEximRunCond expanded to false
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.2 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD, UNPARSEABLE_RELAY autolearn=ham version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a> - Feb. 9, 2016, 12:21 a.m.</div>
<pre class="content">
This is the combined diff for 3.2.77-rc1 relative to 3.2.76.

Ben.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 289ca14a20d6..9d1b87dc71ba 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 2
<span class="p_del">-SUBLEVEL = 76</span>
<span class="p_del">-EXTRAVERSION =</span>
<span class="p_add">+SUBLEVEL = 77</span>
<span class="p_add">+EXTRAVERSION = -rc1</span>
 NAME = Saber-toothed Squirrel
 
 # *DOCUMENTATION*
<span class="p_header">diff --git a/arch/m32r/kernel/setup.c b/arch/m32r/kernel/setup.c</span>
<span class="p_header">index 0392112a5d70..a5ecef7188ba 100644</span>
<span class="p_header">--- a/arch/m32r/kernel/setup.c</span>
<span class="p_header">+++ b/arch/m32r/kernel/setup.c</span>
<span class="p_chunk">@@ -81,7 +81,10 @@</span> <span class="p_context"> static struct resource code_resource = {</span>
 };
 
 unsigned long memory_start;
<span class="p_add">+EXPORT_SYMBOL(memory_start);</span>
<span class="p_add">+</span>
 unsigned long memory_end;
<span class="p_add">+EXPORT_SYMBOL(memory_end);</span>
 
 void __init setup_arch(char **);
 int get_cpuinfo(char *);
<span class="p_header">diff --git a/arch/parisc/include/asm/siginfo.h b/arch/parisc/include/asm/siginfo.h</span>
<span class="p_header">index d7034728f377..1c75565d984b 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/siginfo.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/siginfo.h</span>
<span class="p_chunk">@@ -1,6 +1,10 @@</span> <span class="p_context"></span>
 #ifndef _PARISC_SIGINFO_H
 #define _PARISC_SIGINFO_H
 
<span class="p_add">+#if defined(__LP64__)</span>
<span class="p_add">+#define __ARCH_SI_PREAMBLE_SIZE   (4 * sizeof(int))</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #include &lt;asm-generic/siginfo.h&gt;
 
 #undef NSIGTRAP
<span class="p_header">diff --git a/arch/powerpc/include/asm/synch.h b/arch/powerpc/include/asm/synch.h</span>
<span class="p_header">index e682a7143edb..c50868681f9e 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/synch.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/synch.h</span>
<span class="p_chunk">@@ -44,7 +44,7 @@</span> <span class="p_context"> static inline void isync(void)</span>
 	MAKE_LWSYNC_SECTION_ENTRY(97, __lwsync_fixup);
 #define PPC_ACQUIRE_BARRIER	 &quot;\n&quot; stringify_in_c(__PPC_ACQUIRE_BARRIER)
 #define PPC_RELEASE_BARRIER	 stringify_in_c(LWSYNC) &quot;\n&quot;
<span class="p_del">-#define PPC_ATOMIC_ENTRY_BARRIER &quot;\n&quot; stringify_in_c(LWSYNC) &quot;\n&quot;</span>
<span class="p_add">+#define PPC_ATOMIC_ENTRY_BARRIER &quot;\n&quot; stringify_in_c(sync) &quot;\n&quot;</span>
 #define PPC_ATOMIC_EXIT_BARRIER	 &quot;\n&quot; stringify_in_c(sync) &quot;\n&quot;
 #else
 #define PPC_ACQUIRE_BARRIER
<span class="p_header">diff --git a/arch/powerpc/include/asm/system.h b/arch/powerpc/include/asm/system.h</span>
<span class="p_header">index e30a13d1ee76..10d5c3e7fc37 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/system.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/system.h</span>
<span class="p_chunk">@@ -234,12 +234,12 @@</span> <span class="p_context"> __xchg_u32(volatile void *p, unsigned long val)</span>
 	unsigned long prev;
 
 	__asm__ __volatile__(
<span class="p_del">-	PPC_RELEASE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_ENTRY_BARRIER</span>
 &quot;1:	lwarx	%0,0,%2 \n&quot;
 	PPC405_ERR77(0,%2)
 &quot;	stwcx.	%3,0,%2 \n\
 	bne-	1b&quot;
<span class="p_del">-	PPC_ACQUIRE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_EXIT_BARRIER</span>
 	: &quot;=&amp;r&quot; (prev), &quot;+m&quot; (*(volatile unsigned int *)p)
 	: &quot;r&quot; (p), &quot;r&quot; (val)
 	: &quot;cc&quot;, &quot;memory&quot;);
<span class="p_chunk">@@ -277,12 +277,12 @@</span> <span class="p_context"> __xchg_u64(volatile void *p, unsigned long val)</span>
 	unsigned long prev;
 
 	__asm__ __volatile__(
<span class="p_del">-	PPC_RELEASE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_ENTRY_BARRIER</span>
 &quot;1:	ldarx	%0,0,%2 \n&quot;
 	PPC405_ERR77(0,%2)
 &quot;	stdcx.	%3,0,%2 \n\
 	bne-	1b&quot;
<span class="p_del">-	PPC_ACQUIRE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_EXIT_BARRIER</span>
 	: &quot;=&amp;r&quot; (prev), &quot;+m&quot; (*(volatile unsigned long *)p)
 	: &quot;r&quot; (p), &quot;r&quot; (val)
 	: &quot;cc&quot;, &quot;memory&quot;);
<span class="p_chunk">@@ -368,14 +368,14 @@</span> <span class="p_context"> __cmpxchg_u32(volatile unsigned int *p, unsigned long old, unsigned long new)</span>
 	unsigned int prev;
 
 	__asm__ __volatile__ (
<span class="p_del">-	PPC_RELEASE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_ENTRY_BARRIER</span>
 &quot;1:	lwarx	%0,0,%2		# __cmpxchg_u32\n\
 	cmpw	0,%0,%3\n\
 	bne-	2f\n&quot;
 	PPC405_ERR77(0,%2)
 &quot;	stwcx.	%4,0,%2\n\
 	bne-	1b&quot;
<span class="p_del">-	PPC_ACQUIRE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_EXIT_BARRIER</span>
 	&quot;\n\
 2:&quot;
 	: &quot;=&amp;r&quot; (prev), &quot;+m&quot; (*p)
<span class="p_chunk">@@ -414,13 +414,13 @@</span> <span class="p_context"> __cmpxchg_u64(volatile unsigned long *p, unsigned long old, unsigned long new)</span>
 	unsigned long prev;
 
 	__asm__ __volatile__ (
<span class="p_del">-	PPC_RELEASE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_ENTRY_BARRIER</span>
 &quot;1:	ldarx	%0,0,%2		# __cmpxchg_u64\n\
 	cmpd	0,%0,%3\n\
 	bne-	2f\n\
 	stdcx.	%4,0,%2\n\
 	bne-	1b&quot;
<span class="p_del">-	PPC_ACQUIRE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_EXIT_BARRIER</span>
 	&quot;\n\
 2:&quot;
 	: &quot;=&amp;r&quot; (prev), &quot;+m&quot; (*p)
<span class="p_header">diff --git a/arch/sparc/kernel/sys_sparc_64.c b/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_header">index 0ff682d284e0..a062fe9a4e49 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_chunk">@@ -517,7 +517,7 @@</span> <span class="p_context"> out:</span>
 
 SYSCALL_DEFINE1(sparc64_personality, unsigned long, personality)
 {
<span class="p_del">-	int ret;</span>
<span class="p_add">+	long ret;</span>
 
 	if (personality(current-&gt;personality) == PER_LINUX32 &amp;&amp;
 	    personality(personality) == PER_LINUX)
<span class="p_header">diff --git a/arch/um/os-Linux/start_up.c b/arch/um/os-Linux/start_up.c</span>
<span class="p_header">index 2f53b892fd80..c8993dfbe8e1 100644</span>
<span class="p_header">--- a/arch/um/os-Linux/start_up.c</span>
<span class="p_header">+++ b/arch/um/os-Linux/start_up.c</span>
<span class="p_chunk">@@ -95,6 +95,8 @@</span> <span class="p_context"> static int start_ptraced_child(void)</span>
 {
 	int pid, n, status;
 
<span class="p_add">+	fflush(stdout);</span>
<span class="p_add">+</span>
 	pid = fork();
 	if (pid == 0)
 		ptrace_child();
<span class="p_header">diff --git a/arch/x86/include/asm/boot.h b/arch/x86/include/asm/boot.h</span>
<span class="p_header">index 5e1a2eef3e7c..60d2f81f7c5e 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/boot.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/boot.h</span>
<span class="p_chunk">@@ -32,7 +32,7 @@</span> <span class="p_context"></span>
 #define BOOT_HEAP_SIZE             0x400000
 #else /* !CONFIG_KERNEL_BZIP2 */
 
<span class="p_del">-#define BOOT_HEAP_SIZE	0x8000</span>
<span class="p_add">+#define BOOT_HEAP_SIZE	0x10000</span>
 
 #endif /* !CONFIG_KERNEL_BZIP2 */
 
<span class="p_header">diff --git a/arch/x86/include/asm/mmu_context.h b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">index ce4ea94fc4be..babbcd18a7a7 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -87,7 +87,34 @@</span> <span class="p_context"> static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
 #endif
 		cpumask_set_cpu(cpu, mm_cpumask(next));
 
<span class="p_del">-		/* Re-load page tables */</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Re-load page tables.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * This logic has an ordering constraint:</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 *  CPU 0: Write to a PTE for &#39;next&#39;</span>
<span class="p_add">+		 *  CPU 0: load bit 1 in mm_cpumask.  if nonzero, send IPI.</span>
<span class="p_add">+		 *  CPU 1: set bit 1 in next&#39;s mm_cpumask</span>
<span class="p_add">+		 *  CPU 1: load from the PTE that CPU 0 writes (implicit)</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * We need to prevent an outcome in which CPU 1 observes</span>
<span class="p_add">+		 * the new PTE value and CPU 0 observes bit 1 clear in</span>
<span class="p_add">+		 * mm_cpumask.  (If that occurs, then the IPI will never</span>
<span class="p_add">+		 * be sent, and CPU 0&#39;s TLB will contain a stale entry.)</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * The bad outcome can occur if either CPU&#39;s load is</span>
<span class="p_add">+		 * reordered before that CPU&#39;s store, so both CPUs must</span>
<span class="p_add">+		 * execute full barriers to prevent this from happening.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Thus, switch_mm needs a full barrier between the</span>
<span class="p_add">+		 * store to mm_cpumask and any operation that could load</span>
<span class="p_add">+		 * from next-&gt;pgd.  TLB fills are special and can happen</span>
<span class="p_add">+		 * due to instruction fetches or for no reason at all,</span>
<span class="p_add">+		 * and neither LOCK nor MFENCE orders them.</span>
<span class="p_add">+		 * Fortunately, load_cr3() is serializing and gives the</span>
<span class="p_add">+		 * ordering guarantee we need.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 */</span>
 		load_cr3(next-&gt;pgd);
 
 		/* stop flush ipis for the previous mm */
<span class="p_chunk">@@ -108,6 +135,9 @@</span> <span class="p_context"> static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
 			/* We were in lazy tlb mode and leave_mm disabled
 			 * tlb flush IPI delivery. We must reload CR3
 			 * to make sure to use no freed page tables.
<span class="p_add">+			 *</span>
<span class="p_add">+			 * As above, load_cr3() is serializing and orders TLB</span>
<span class="p_add">+			 * fills with respect to the mm_cpumask write.</span>
 			 */
 			load_cr3(next-&gt;pgd);
 			load_mm_ldt(next);
<span class="p_header">diff --git a/arch/x86/kernel/process_64.c b/arch/x86/kernel/process_64.c</span>
<span class="p_header">index aaab32e8a078..ee2e70c9fdbf 100644</span>
<span class="p_header">--- a/arch/x86/kernel/process_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/process_64.c</span>
<span class="p_chunk">@@ -221,7 +221,7 @@</span> <span class="p_context"> void release_thread(struct task_struct *dead_task)</span>
 		if (dead_task-&gt;mm-&gt;context.ldt) {
 			printk(&quot;WARNING: dead process %8s still has LDT? &lt;%p/%d&gt;\n&quot;,
 					dead_task-&gt;comm,
<span class="p_del">-					dead_task-&gt;mm-&gt;context.ldt,</span>
<span class="p_add">+					dead_task-&gt;mm-&gt;context.ldt-&gt;entries,</span>
 					dead_task-&gt;mm-&gt;context.ldt-&gt;size);
 			BUG();
 		}
<span class="p_header">diff --git a/arch/x86/kernel/reboot.c b/arch/x86/kernel/reboot.c</span>
<span class="p_header">index 78842ced5f66..a34bdddeca85 100644</span>
<span class="p_header">--- a/arch/x86/kernel/reboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/reboot.c</span>
<span class="p_chunk">@@ -412,6 +412,14 @@</span> <span class="p_context"> static struct dmi_system_id __initdata pci_reboot_dmi_table[] = {</span>
 			DMI_MATCH(DMI_PRODUCT_NAME, &quot;iMac9,1&quot;),
 		},
 	},
<span class="p_add">+	{	/* Handle problems with rebooting on the iMac10,1. */</span>
<span class="p_add">+		.callback = set_pci_reboot,</span>
<span class="p_add">+		.ident = &quot;Apple iMac10,1&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+		    DMI_MATCH(DMI_SYS_VENDOR, &quot;Apple Inc.&quot;),</span>
<span class="p_add">+		    DMI_MATCH(DMI_PRODUCT_NAME, &quot;iMac10,1&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 	/* ASRock */
 	{	/* Handle problems with rebooting on ASRock Q1900DC-ITX */
 		.callback = set_pci_reboot,
<span class="p_header">diff --git a/arch/x86/kvm/trace.h b/arch/x86/kvm/trace.h</span>
<span class="p_header">index 7216916a522e..a39e0e2faf0e 100644</span>
<span class="p_header">--- a/arch/x86/kvm/trace.h</span>
<span class="p_header">+++ b/arch/x86/kvm/trace.h</span>
<span class="p_chunk">@@ -326,7 +326,7 @@</span> <span class="p_context"> TRACE_EVENT(kvm_inj_virq,</span>
 #define kvm_trace_sym_exc						\
 	EXS(DE), EXS(DB), EXS(BP), EXS(OF), EXS(BR), EXS(UD), EXS(NM),	\
 	EXS(DF), EXS(TS), EXS(NP), EXS(SS), EXS(GP), EXS(PF),		\
<span class="p_del">-	EXS(MF), EXS(MC)</span>
<span class="p_add">+	EXS(MF), EXS(AC), EXS(MC)</span>
 
 /*
  * Tracepoint for kvm interrupt injection:
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 80c6d6835805..d47d1537afc4 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -834,7 +834,8 @@</span> <span class="p_context"> static u32 msrs_to_save[] = {</span>
 #ifdef CONFIG_X86_64
 	MSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,
 #endif
<span class="p_del">-	MSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA</span>
<span class="p_add">+	MSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,</span>
<span class="p_add">+	MSR_TSC_AUX,</span>
 };
 
 static unsigned num_msrs_to_save;
<span class="p_chunk">@@ -3867,6 +3868,20 @@</span> <span class="p_context"> static void kvm_init_msr_list(void)</span>
 	for (i = j = KVM_SAVE_MSRS_BEGIN; i &lt; ARRAY_SIZE(msrs_to_save); i++) {
 		if (rdmsr_safe(msrs_to_save[i], &amp;dummy[0], &amp;dummy[1]) &lt; 0)
 			continue;
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Even MSRs that are valid in the host may not be exposed</span>
<span class="p_add">+		 * to the guests in some cases.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		switch (msrs_to_save[i]) {</span>
<span class="p_add">+		case MSR_TSC_AUX:</span>
<span class="p_add">+			if (!kvm_x86_ops-&gt;rdtscp_supported())</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (j &lt; i)
 			msrs_to_save[j] = msrs_to_save[i];
 		j++;
<span class="p_header">diff --git a/arch/x86/mm/tlb.c b/arch/x86/mm/tlb.c</span>
<span class="p_header">index d6c0418c3e47..55034a15f13c 100644</span>
<span class="p_header">--- a/arch/x86/mm/tlb.c</span>
<span class="p_header">+++ b/arch/x86/mm/tlb.c</span>
<span class="p_chunk">@@ -278,7 +278,9 @@</span> <span class="p_context"> void flush_tlb_current_task(void)</span>
 
 	preempt_disable();
 
<span class="p_add">+	/* This is an implicit full barrier that synchronizes with switch_mm. */</span>
 	local_flush_tlb();
<span class="p_add">+</span>
 	if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) &lt; nr_cpu_ids)
 		flush_tlb_others(mm_cpumask(mm), mm, TLB_FLUSH_ALL);
 	preempt_enable();
<span class="p_chunk">@@ -289,10 +291,20 @@</span> <span class="p_context"> void flush_tlb_mm(struct mm_struct *mm)</span>
 	preempt_disable();
 
 	if (current-&gt;active_mm == mm) {
<span class="p_del">-		if (current-&gt;mm)</span>
<span class="p_add">+		if (current-&gt;mm) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * This is an implicit full barrier (MOV to CR) that</span>
<span class="p_add">+			 * synchronizes with switch_mm.</span>
<span class="p_add">+			 */</span>
 			local_flush_tlb();
<span class="p_del">-		else</span>
<span class="p_add">+		} else {</span>
 			leave_mm(smp_processor_id());
<span class="p_add">+			/* Synchronize with switch_mm. */</span>
<span class="p_add">+			smp_mb();</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* Synchronize with switch_mm. */</span>
<span class="p_add">+		smp_mb();</span>
 	}
 	if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) &lt; nr_cpu_ids)
 		flush_tlb_others(mm_cpumask(mm), mm, TLB_FLUSH_ALL);
<span class="p_chunk">@@ -307,10 +319,18 @@</span> <span class="p_context"> void flush_tlb_page(struct vm_area_struct *vma, unsigned long va)</span>
 	preempt_disable();
 
 	if (current-&gt;active_mm == mm) {
<span class="p_del">-		if (current-&gt;mm)</span>
<span class="p_add">+		if (current-&gt;mm) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Implicit full barrier (INVLPG) that synchronizes</span>
<span class="p_add">+			 * with switch_mm.</span>
<span class="p_add">+			 */</span>
 			__flush_tlb_one(va);
<span class="p_del">-		else</span>
<span class="p_add">+		} else {</span>
 			leave_mm(smp_processor_id());
<span class="p_add">+</span>
<span class="p_add">+			/* Synchronize with switch_mm. */</span>
<span class="p_add">+			smp_mb();</span>
<span class="p_add">+		}</span>
 	}
 
 	if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) &lt; nr_cpu_ids)
<span class="p_header">diff --git a/arch/x86/xen/suspend.c b/arch/x86/xen/suspend.c</span>
<span class="p_header">index 45329c8c226e..39e12c10b931 100644</span>
<span class="p_header">--- a/arch/x86/xen/suspend.c</span>
<span class="p_header">+++ b/arch/x86/xen/suspend.c</span>
<span class="p_chunk">@@ -30,7 +30,8 @@</span> <span class="p_context"> void xen_arch_hvm_post_suspend(int suspend_cancelled)</span>
 {
 #ifdef CONFIG_XEN_PVHVM
 	int cpu;
<span class="p_del">-	xen_hvm_init_shared_info();</span>
<span class="p_add">+	if (!suspend_cancelled)</span>
<span class="p_add">+	    xen_hvm_init_shared_info();</span>
 	xen_callback_vector();
 	xen_unplug_emulated_devices();
 	if (xen_feature(XENFEAT_hvm_safe_pvclock)) {
<span class="p_header">diff --git a/crypto/ablkcipher.c b/crypto/ablkcipher.c</span>
<span class="p_header">index 6eb6eb122502..6600a2a15b6b 100644</span>
<span class="p_header">--- a/crypto/ablkcipher.c</span>
<span class="p_header">+++ b/crypto/ablkcipher.c</span>
<span class="p_chunk">@@ -379,6 +379,7 @@</span> <span class="p_context"> static int crypto_init_ablkcipher_ops(struct crypto_tfm *tfm, u32 type,</span>
 	}
 	crt-&gt;base = __crypto_ablkcipher_cast(tfm);
 	crt-&gt;ivsize = alg-&gt;ivsize;
<span class="p_add">+	crt-&gt;has_setkey = alg-&gt;max_keysize;</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/crypto/af_alg.c b/crypto/af_alg.c</span>
<span class="p_header">index 6ef6e2ad344e..68ec1ac4104a 100644</span>
<span class="p_header">--- a/crypto/af_alg.c</span>
<span class="p_header">+++ b/crypto/af_alg.c</span>
<span class="p_chunk">@@ -76,6 +76,8 @@</span> <span class="p_context"> int af_alg_register_type(const struct af_alg_type *type)</span>
 		goto unlock;
 
 	type-&gt;ops-&gt;owner = THIS_MODULE;
<span class="p_add">+	if (type-&gt;ops_nokey)</span>
<span class="p_add">+		type-&gt;ops_nokey-&gt;owner = THIS_MODULE;</span>
 	node-&gt;type = type;
 	list_add(&amp;node-&gt;list, &amp;alg_types);
 	err = 0;
<span class="p_chunk">@@ -125,6 +127,26 @@</span> <span class="p_context"> int af_alg_release(struct socket *sock)</span>
 }
 EXPORT_SYMBOL_GPL(af_alg_release);
 
<span class="p_add">+void af_alg_release_parent(struct sock *sk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct alg_sock *ask = alg_sk(sk);</span>
<span class="p_add">+	unsigned int nokey = ask-&gt;nokey_refcnt;</span>
<span class="p_add">+	bool last = nokey &amp;&amp; !ask-&gt;refcnt;</span>
<span class="p_add">+</span>
<span class="p_add">+	sk = ask-&gt;parent;</span>
<span class="p_add">+	ask = alg_sk(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+	ask-&gt;nokey_refcnt -= nokey;</span>
<span class="p_add">+	if (!last)</span>
<span class="p_add">+		last = !--ask-&gt;refcnt;</span>
<span class="p_add">+	release_sock(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (last)</span>
<span class="p_add">+		sock_put(sk);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(af_alg_release_parent);</span>
<span class="p_add">+</span>
 static int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
 {
 	struct sock *sk = sock-&gt;sk;
<span class="p_chunk">@@ -132,6 +154,7 @@</span> <span class="p_context"> static int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)</span>
 	struct sockaddr_alg *sa = (void *)uaddr;
 	const struct af_alg_type *type;
 	void *private;
<span class="p_add">+	int err;</span>
 
 	if (sock-&gt;state == SS_CONNECTED)
 		return -EINVAL;
<span class="p_chunk">@@ -157,16 +180,22 @@</span> <span class="p_context"> static int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)</span>
 		return PTR_ERR(private);
 	}
 
<span class="p_add">+	err = -EBUSY;</span>
 	lock_sock(sk);
<span class="p_add">+	if (ask-&gt;refcnt | ask-&gt;nokey_refcnt)</span>
<span class="p_add">+		goto unlock;</span>
 
 	swap(ask-&gt;type, type);
 	swap(ask-&gt;private, private);
 
<span class="p_add">+	err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+unlock:</span>
 	release_sock(sk);
 
 	alg_do_release(type, private);
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return err;</span>
 }
 
 static int alg_setkey(struct sock *sk, char __user *ukey,
<span class="p_chunk">@@ -199,11 +228,15 @@</span> <span class="p_context"> static int alg_setsockopt(struct socket *sock, int level, int optname,</span>
 	struct sock *sk = sock-&gt;sk;
 	struct alg_sock *ask = alg_sk(sk);
 	const struct af_alg_type *type;
<span class="p_del">-	int err = -ENOPROTOOPT;</span>
<span class="p_add">+	int err = -EBUSY;</span>
 
 	lock_sock(sk);
<span class="p_add">+	if (ask-&gt;refcnt)</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+</span>
 	type = ask-&gt;type;
 
<span class="p_add">+	err = -ENOPROTOOPT;</span>
 	if (level != SOL_ALG || !type)
 		goto unlock;
 
<span class="p_chunk">@@ -228,6 +261,7 @@</span> <span class="p_context"> int af_alg_accept(struct sock *sk, struct socket *newsock)</span>
 	struct alg_sock *ask = alg_sk(sk);
 	const struct af_alg_type *type;
 	struct sock *sk2;
<span class="p_add">+	unsigned int nokey;</span>
 	int err;
 
 	lock_sock(sk);
<span class="p_chunk">@@ -247,20 +281,29 @@</span> <span class="p_context"> int af_alg_accept(struct sock *sk, struct socket *newsock)</span>
 	security_sk_clone(sk, sk2);
 
 	err = type-&gt;accept(ask-&gt;private, sk2);
<span class="p_del">-	if (err) {</span>
<span class="p_del">-		sk_free(sk2);</span>
<span class="p_add">+</span>
<span class="p_add">+	nokey = err == -ENOKEY;</span>
<span class="p_add">+	if (nokey &amp;&amp; type-&gt;accept_nokey)</span>
<span class="p_add">+		err = type-&gt;accept_nokey(ask-&gt;private, sk2);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (err)</span>
 		goto unlock;
<span class="p_del">-	}</span>
 
 	sk2-&gt;sk_family = PF_ALG;
 
<span class="p_del">-	sock_hold(sk);</span>
<span class="p_add">+	if (nokey || !ask-&gt;refcnt++)</span>
<span class="p_add">+		sock_hold(sk);</span>
<span class="p_add">+	ask-&gt;nokey_refcnt += nokey;</span>
 	alg_sk(sk2)-&gt;parent = sk;
 	alg_sk(sk2)-&gt;type = type;
<span class="p_add">+	alg_sk(sk2)-&gt;nokey_refcnt = nokey;</span>
 
 	newsock-&gt;ops = type-&gt;ops;
 	newsock-&gt;state = SS_CONNECTED;
 
<span class="p_add">+	if (nokey)</span>
<span class="p_add">+		newsock-&gt;ops = type-&gt;ops_nokey;</span>
<span class="p_add">+</span>
 	err = 0;
 
 unlock:
<span class="p_header">diff --git a/crypto/ahash.c b/crypto/ahash.c</span>
<span class="p_header">index 96c8e7cb680f..7fd8ecf71337 100644</span>
<span class="p_header">--- a/crypto/ahash.c</span>
<span class="p_header">+++ b/crypto/ahash.c</span>
<span class="p_chunk">@@ -369,6 +369,7 @@</span> <span class="p_context"> static int crypto_ahash_init_tfm(struct crypto_tfm *tfm)</span>
 	struct ahash_alg *alg = crypto_ahash_alg(hash);
 
 	hash-&gt;setkey = ahash_nosetkey;
<span class="p_add">+	hash-&gt;has_setkey = false;</span>
 	hash-&gt;export = ahash_no_export;
 	hash-&gt;import = ahash_no_import;
 
<span class="p_chunk">@@ -381,8 +382,10 @@</span> <span class="p_context"> static int crypto_ahash_init_tfm(struct crypto_tfm *tfm)</span>
 	hash-&gt;finup = alg-&gt;finup ?: ahash_def_finup;
 	hash-&gt;digest = alg-&gt;digest;
 
<span class="p_del">-	if (alg-&gt;setkey)</span>
<span class="p_add">+	if (alg-&gt;setkey) {</span>
 		hash-&gt;setkey = alg-&gt;setkey;
<span class="p_add">+		hash-&gt;has_setkey = true;</span>
<span class="p_add">+	}</span>
 	if (alg-&gt;export)
 		hash-&gt;export = alg-&gt;export;
 	if (alg-&gt;import)
<span class="p_header">diff --git a/crypto/algif_hash.c b/crypto/algif_hash.c</span>
<span class="p_header">index a68b56a368a8..2dfb0f10e0bb 100644</span>
<span class="p_header">--- a/crypto/algif_hash.c</span>
<span class="p_header">+++ b/crypto/algif_hash.c</span>
<span class="p_chunk">@@ -34,6 +34,11 @@</span> <span class="p_context"> struct hash_ctx {</span>
 	struct ahash_request req;
 };
 
<span class="p_add">+struct algif_hash_tfm {</span>
<span class="p_add">+	struct crypto_ahash *hash;</span>
<span class="p_add">+	bool has_key;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int hash_sendmsg(struct kiocb *unused, struct socket *sock,
 			struct msghdr *msg, size_t ignored)
 {
<span class="p_chunk">@@ -246,19 +251,151 @@</span> <span class="p_context"> static struct proto_ops algif_hash_ops = {</span>
 	.accept		=	hash_accept,
 };
 
<span class="p_add">+static int hash_check_key(struct socket *sock)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err = 0;</span>
<span class="p_add">+	struct sock *psk;</span>
<span class="p_add">+	struct alg_sock *pask;</span>
<span class="p_add">+	struct algif_hash_tfm *tfm;</span>
<span class="p_add">+	struct sock *sk = sock-&gt;sk;</span>
<span class="p_add">+	struct alg_sock *ask = alg_sk(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+	if (ask-&gt;refcnt)</span>
<span class="p_add">+		goto unlock_child;</span>
<span class="p_add">+</span>
<span class="p_add">+	psk = ask-&gt;parent;</span>
<span class="p_add">+	pask = alg_sk(ask-&gt;parent);</span>
<span class="p_add">+	tfm = pask-&gt;private;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = -ENOKEY;</span>
<span class="p_add">+	lock_sock_nested(psk, SINGLE_DEPTH_NESTING);</span>
<span class="p_add">+	if (!tfm-&gt;has_key)</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pask-&gt;refcnt++)</span>
<span class="p_add">+		sock_hold(psk);</span>
<span class="p_add">+</span>
<span class="p_add">+	ask-&gt;refcnt = 1;</span>
<span class="p_add">+	sock_put(psk);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+unlock:</span>
<span class="p_add">+	release_sock(psk);</span>
<span class="p_add">+unlock_child:</span>
<span class="p_add">+	release_sock(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hash_sendmsg_nokey(struct kiocb *unused, struct socket *sock,</span>
<span class="p_add">+			      struct msghdr *msg, size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = hash_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hash_sendmsg(unused, sock, msg, size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static ssize_t hash_sendpage_nokey(struct socket *sock, struct page *page,</span>
<span class="p_add">+				   int offset, size_t size, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = hash_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hash_sendpage(sock, page, offset, size, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hash_recvmsg_nokey(struct kiocb *unused, struct socket *sock,</span>
<span class="p_add">+			      struct msghdr *msg, size_t ignored, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = hash_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hash_recvmsg(unused, sock, msg, ignored, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hash_accept_nokey(struct socket *sock, struct socket *newsock,</span>
<span class="p_add">+			     int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = hash_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hash_accept(sock, newsock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct proto_ops algif_hash_ops_nokey = {</span>
<span class="p_add">+	.family		=	PF_ALG,</span>
<span class="p_add">+</span>
<span class="p_add">+	.connect	=	sock_no_connect,</span>
<span class="p_add">+	.socketpair	=	sock_no_socketpair,</span>
<span class="p_add">+	.getname	=	sock_no_getname,</span>
<span class="p_add">+	.ioctl		=	sock_no_ioctl,</span>
<span class="p_add">+	.listen		=	sock_no_listen,</span>
<span class="p_add">+	.shutdown	=	sock_no_shutdown,</span>
<span class="p_add">+	.getsockopt	=	sock_no_getsockopt,</span>
<span class="p_add">+	.mmap		=	sock_no_mmap,</span>
<span class="p_add">+	.bind		=	sock_no_bind,</span>
<span class="p_add">+	.setsockopt	=	sock_no_setsockopt,</span>
<span class="p_add">+	.poll		=	sock_no_poll,</span>
<span class="p_add">+</span>
<span class="p_add">+	.release	=	af_alg_release,</span>
<span class="p_add">+	.sendmsg	=	hash_sendmsg_nokey,</span>
<span class="p_add">+	.sendpage	=	hash_sendpage_nokey,</span>
<span class="p_add">+	.recvmsg	=	hash_recvmsg_nokey,</span>
<span class="p_add">+	.accept		=	hash_accept_nokey,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static void *hash_bind(const char *name, u32 type, u32 mask)
 {
<span class="p_del">-	return crypto_alloc_ahash(name, type, mask);</span>
<span class="p_add">+	struct algif_hash_tfm *tfm;</span>
<span class="p_add">+	struct crypto_ahash *hash;</span>
<span class="p_add">+</span>
<span class="p_add">+	tfm = kzalloc(sizeof(*tfm), GFP_KERNEL);</span>
<span class="p_add">+	if (!tfm)</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+</span>
<span class="p_add">+	hash = crypto_alloc_ahash(name, type, mask);</span>
<span class="p_add">+	if (IS_ERR(hash)) {</span>
<span class="p_add">+		kfree(tfm);</span>
<span class="p_add">+		return ERR_CAST(hash);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	tfm-&gt;hash = hash;</span>
<span class="p_add">+</span>
<span class="p_add">+	return tfm;</span>
 }
 
 static void hash_release(void *private)
 {
<span class="p_del">-	crypto_free_ahash(private);</span>
<span class="p_add">+	struct algif_hash_tfm *tfm = private;</span>
<span class="p_add">+</span>
<span class="p_add">+	crypto_free_ahash(tfm-&gt;hash);</span>
<span class="p_add">+	kfree(tfm);</span>
 }
 
 static int hash_setkey(void *private, const u8 *key, unsigned int keylen)
 {
<span class="p_del">-	return crypto_ahash_setkey(private, key, keylen);</span>
<span class="p_add">+	struct algif_hash_tfm *tfm = private;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = crypto_ahash_setkey(tfm-&gt;hash, key, keylen);</span>
<span class="p_add">+	tfm-&gt;has_key = !err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
 }
 
 static void hash_sock_destruct(struct sock *sk)
<span class="p_chunk">@@ -272,12 +409,14 @@</span> <span class="p_context"> static void hash_sock_destruct(struct sock *sk)</span>
 	af_alg_release_parent(sk);
 }
 
<span class="p_del">-static int hash_accept_parent(void *private, struct sock *sk)</span>
<span class="p_add">+static int hash_accept_parent_nokey(void *private, struct sock *sk)</span>
 {
 	struct hash_ctx *ctx;
 	struct alg_sock *ask = alg_sk(sk);
<span class="p_del">-	unsigned len = sizeof(*ctx) + crypto_ahash_reqsize(private);</span>
<span class="p_del">-	unsigned ds = crypto_ahash_digestsize(private);</span>
<span class="p_add">+	struct algif_hash_tfm *tfm = private;</span>
<span class="p_add">+	struct crypto_ahash *hash = tfm-&gt;hash;</span>
<span class="p_add">+	unsigned len = sizeof(*ctx) + crypto_ahash_reqsize(hash);</span>
<span class="p_add">+	unsigned ds = crypto_ahash_digestsize(hash);</span>
 
 	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
 	if (!ctx)
<span class="p_chunk">@@ -297,7 +436,7 @@</span> <span class="p_context"> static int hash_accept_parent(void *private, struct sock *sk)</span>
 
 	ask-&gt;private = ctx;
 
<span class="p_del">-	ahash_request_set_tfm(&amp;ctx-&gt;req, private);</span>
<span class="p_add">+	ahash_request_set_tfm(&amp;ctx-&gt;req, hash);</span>
 	ahash_request_set_callback(&amp;ctx-&gt;req, CRYPTO_TFM_REQ_MAY_BACKLOG,
 				   af_alg_complete, &amp;ctx-&gt;completion);
 
<span class="p_chunk">@@ -306,12 +445,24 @@</span> <span class="p_context"> static int hash_accept_parent(void *private, struct sock *sk)</span>
 	return 0;
 }
 
<span class="p_add">+static int hash_accept_parent(void *private, struct sock *sk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct algif_hash_tfm *tfm = private;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tfm-&gt;has_key &amp;&amp; crypto_ahash_has_setkey(tfm-&gt;hash))</span>
<span class="p_add">+		return -ENOKEY;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hash_accept_parent_nokey(private, sk);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct af_alg_type algif_type_hash = {
 	.bind		=	hash_bind,
 	.release	=	hash_release,
 	.setkey		=	hash_setkey,
 	.accept		=	hash_accept_parent,
<span class="p_add">+	.accept_nokey	=	hash_accept_parent_nokey,</span>
 	.ops		=	&amp;algif_hash_ops,
<span class="p_add">+	.ops_nokey	=	&amp;algif_hash_ops_nokey,</span>
 	.name		=	&quot;hash&quot;,
 	.owner		=	THIS_MODULE
 };
<span class="p_header">diff --git a/crypto/algif_skcipher.c b/crypto/algif_skcipher.c</span>
<span class="p_header">index 83187f497c7c..45fa6bd9187b 100644</span>
<span class="p_header">--- a/crypto/algif_skcipher.c</span>
<span class="p_header">+++ b/crypto/algif_skcipher.c</span>
<span class="p_chunk">@@ -31,6 +31,11 @@</span> <span class="p_context"> struct skcipher_sg_list {</span>
 	struct scatterlist sg[0];
 };
 
<span class="p_add">+struct skcipher_tfm {</span>
<span class="p_add">+	struct crypto_ablkcipher *skcipher;</span>
<span class="p_add">+	bool has_key;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 struct skcipher_ctx {
 	struct list_head tsgl;
 	struct af_alg_sgl rsgl;
<span class="p_chunk">@@ -441,13 +446,6 @@</span> <span class="p_context"> static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,</span>
 		char __user *from = iov-&gt;iov_base;
 
 		while (seglen) {
<span class="p_del">-			sgl = list_first_entry(&amp;ctx-&gt;tsgl,</span>
<span class="p_del">-					       struct skcipher_sg_list, list);</span>
<span class="p_del">-			sg = sgl-&gt;sg;</span>
<span class="p_del">-</span>
<span class="p_del">-			while (!sg-&gt;length)</span>
<span class="p_del">-				sg++;</span>
<span class="p_del">-</span>
 			used = ctx-&gt;used;
 			if (!used) {
 				err = skcipher_wait_for_data(sk, flags);
<span class="p_chunk">@@ -469,6 +467,13 @@</span> <span class="p_context"> static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,</span>
 			if (!used)
 				goto free;
 
<span class="p_add">+			sgl = list_first_entry(&amp;ctx-&gt;tsgl,</span>
<span class="p_add">+					       struct skcipher_sg_list, list);</span>
<span class="p_add">+			sg = sgl-&gt;sg;</span>
<span class="p_add">+</span>
<span class="p_add">+			while (!sg-&gt;length)</span>
<span class="p_add">+				sg++;</span>
<span class="p_add">+</span>
 			ablkcipher_request_set_crypt(&amp;ctx-&gt;req, sg,
 						     ctx-&gt;rsgl.sg, used,
 						     ctx-&gt;iv);
<span class="p_chunk">@@ -544,19 +549,139 @@</span> <span class="p_context"> static struct proto_ops algif_skcipher_ops = {</span>
 	.poll		=	skcipher_poll,
 };
 
<span class="p_add">+static int skcipher_check_key(struct socket *sock)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err = 0;</span>
<span class="p_add">+	struct sock *psk;</span>
<span class="p_add">+	struct alg_sock *pask;</span>
<span class="p_add">+	struct skcipher_tfm *tfm;</span>
<span class="p_add">+	struct sock *sk = sock-&gt;sk;</span>
<span class="p_add">+	struct alg_sock *ask = alg_sk(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+	if (ask-&gt;refcnt)</span>
<span class="p_add">+		goto unlock_child;</span>
<span class="p_add">+</span>
<span class="p_add">+	psk = ask-&gt;parent;</span>
<span class="p_add">+	pask = alg_sk(ask-&gt;parent);</span>
<span class="p_add">+	tfm = pask-&gt;private;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = -ENOKEY;</span>
<span class="p_add">+	lock_sock_nested(psk, SINGLE_DEPTH_NESTING);</span>
<span class="p_add">+	if (!tfm-&gt;has_key)</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pask-&gt;refcnt++)</span>
<span class="p_add">+		sock_hold(psk);</span>
<span class="p_add">+</span>
<span class="p_add">+	ask-&gt;refcnt = 1;</span>
<span class="p_add">+	sock_put(psk);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+unlock:</span>
<span class="p_add">+	release_sock(psk);</span>
<span class="p_add">+unlock_child:</span>
<span class="p_add">+	release_sock(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int skcipher_sendmsg_nokey(struct kiocb *unused, struct socket *sock,</span>
<span class="p_add">+				  struct msghdr *msg, size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = skcipher_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return skcipher_sendmsg(unused, sock, msg, size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static ssize_t skcipher_sendpage_nokey(struct socket *sock, struct page *page,</span>
<span class="p_add">+				       int offset, size_t size, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = skcipher_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return skcipher_sendpage(sock, page, offset, size, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int skcipher_recvmsg_nokey(struct kiocb *unused, struct socket *sock,</span>
<span class="p_add">+				  struct msghdr *msg, size_t ignored, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = skcipher_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return skcipher_recvmsg(unused, sock, msg, ignored, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct proto_ops algif_skcipher_ops_nokey = {</span>
<span class="p_add">+	.family		=	PF_ALG,</span>
<span class="p_add">+</span>
<span class="p_add">+	.connect	=	sock_no_connect,</span>
<span class="p_add">+	.socketpair	=	sock_no_socketpair,</span>
<span class="p_add">+	.getname	=	sock_no_getname,</span>
<span class="p_add">+	.ioctl		=	sock_no_ioctl,</span>
<span class="p_add">+	.listen		=	sock_no_listen,</span>
<span class="p_add">+	.shutdown	=	sock_no_shutdown,</span>
<span class="p_add">+	.getsockopt	=	sock_no_getsockopt,</span>
<span class="p_add">+	.mmap		=	sock_no_mmap,</span>
<span class="p_add">+	.bind		=	sock_no_bind,</span>
<span class="p_add">+	.accept		=	sock_no_accept,</span>
<span class="p_add">+	.setsockopt	=	sock_no_setsockopt,</span>
<span class="p_add">+</span>
<span class="p_add">+	.release	=	af_alg_release,</span>
<span class="p_add">+	.sendmsg	=	skcipher_sendmsg_nokey,</span>
<span class="p_add">+	.sendpage	=	skcipher_sendpage_nokey,</span>
<span class="p_add">+	.recvmsg	=	skcipher_recvmsg_nokey,</span>
<span class="p_add">+	.poll		=	skcipher_poll,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static void *skcipher_bind(const char *name, u32 type, u32 mask)
 {
<span class="p_del">-	return crypto_alloc_ablkcipher(name, type, mask);</span>
<span class="p_add">+	struct skcipher_tfm *tfm;</span>
<span class="p_add">+	struct crypto_ablkcipher *skcipher;</span>
<span class="p_add">+</span>
<span class="p_add">+	tfm = kzalloc(sizeof(*tfm), GFP_KERNEL);</span>
<span class="p_add">+	if (!tfm)</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+</span>
<span class="p_add">+	skcipher = crypto_alloc_ablkcipher(name, type, mask);</span>
<span class="p_add">+	if (IS_ERR(skcipher)) {</span>
<span class="p_add">+		kfree(tfm);</span>
<span class="p_add">+		return ERR_CAST(skcipher);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	tfm-&gt;skcipher = skcipher;</span>
<span class="p_add">+</span>
<span class="p_add">+	return tfm;</span>
 }
 
 static void skcipher_release(void *private)
 {
<span class="p_del">-	crypto_free_ablkcipher(private);</span>
<span class="p_add">+	struct skcipher_tfm *tfm = private;</span>
<span class="p_add">+</span>
<span class="p_add">+	crypto_free_ablkcipher(tfm-&gt;skcipher);</span>
<span class="p_add">+	kfree(tfm);</span>
 }
 
 static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
 {
<span class="p_del">-	return crypto_ablkcipher_setkey(private, key, keylen);</span>
<span class="p_add">+	struct skcipher_tfm *tfm = private;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = crypto_ablkcipher_setkey(tfm-&gt;skcipher, key, keylen);</span>
<span class="p_add">+	tfm-&gt;has_key = !err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
 }
 
 static void skcipher_sock_destruct(struct sock *sk)
<span class="p_chunk">@@ -571,24 +696,26 @@</span> <span class="p_context"> static void skcipher_sock_destruct(struct sock *sk)</span>
 	af_alg_release_parent(sk);
 }
 
<span class="p_del">-static int skcipher_accept_parent(void *private, struct sock *sk)</span>
<span class="p_add">+static int skcipher_accept_parent_nokey(void *private, struct sock *sk)</span>
 {
 	struct skcipher_ctx *ctx;
 	struct alg_sock *ask = alg_sk(sk);
<span class="p_del">-	unsigned int len = sizeof(*ctx) + crypto_ablkcipher_reqsize(private);</span>
<span class="p_add">+	struct skcipher_tfm *tfm = private;</span>
<span class="p_add">+	struct crypto_ablkcipher *skcipher = tfm-&gt;skcipher;</span>
<span class="p_add">+	unsigned int len = sizeof(*ctx) + crypto_ablkcipher_reqsize(skcipher);</span>
 
 	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
 	if (!ctx)
 		return -ENOMEM;
 
<span class="p_del">-	ctx-&gt;iv = sock_kmalloc(sk, crypto_ablkcipher_ivsize(private),</span>
<span class="p_add">+	ctx-&gt;iv = sock_kmalloc(sk, crypto_ablkcipher_ivsize(skcipher),</span>
 			       GFP_KERNEL);
 	if (!ctx-&gt;iv) {
 		sock_kfree_s(sk, ctx, len);
 		return -ENOMEM;
 	}
 
<span class="p_del">-	memset(ctx-&gt;iv, 0, crypto_ablkcipher_ivsize(private));</span>
<span class="p_add">+	memset(ctx-&gt;iv, 0, crypto_ablkcipher_ivsize(skcipher));</span>
 
 	INIT_LIST_HEAD(&amp;ctx-&gt;tsgl);
 	ctx-&gt;len = len;
<span class="p_chunk">@@ -600,7 +727,7 @@</span> <span class="p_context"> static int skcipher_accept_parent(void *private, struct sock *sk)</span>
 
 	ask-&gt;private = ctx;
 
<span class="p_del">-	ablkcipher_request_set_tfm(&amp;ctx-&gt;req, private);</span>
<span class="p_add">+	ablkcipher_request_set_tfm(&amp;ctx-&gt;req, skcipher);</span>
 	ablkcipher_request_set_callback(&amp;ctx-&gt;req, CRYPTO_TFM_REQ_MAY_BACKLOG,
 					af_alg_complete, &amp;ctx-&gt;completion);
 
<span class="p_chunk">@@ -609,12 +736,24 @@</span> <span class="p_context"> static int skcipher_accept_parent(void *private, struct sock *sk)</span>
 	return 0;
 }
 
<span class="p_add">+static int skcipher_accept_parent(void *private, struct sock *sk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct skcipher_tfm *tfm = private;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tfm-&gt;has_key &amp;&amp; crypto_ablkcipher_has_setkey(tfm-&gt;skcipher))</span>
<span class="p_add">+		return -ENOKEY;</span>
<span class="p_add">+</span>
<span class="p_add">+	return skcipher_accept_parent_nokey(private, sk);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct af_alg_type algif_type_skcipher = {
 	.bind		=	skcipher_bind,
 	.release	=	skcipher_release,
 	.setkey		=	skcipher_setkey,
 	.accept		=	skcipher_accept_parent,
<span class="p_add">+	.accept_nokey	=	skcipher_accept_parent_nokey,</span>
 	.ops		=	&amp;algif_skcipher_ops,
<span class="p_add">+	.ops_nokey	=	&amp;algif_skcipher_ops_nokey,</span>
 	.name		=	&quot;skcipher&quot;,
 	.owner		=	THIS_MODULE
 };
<span class="p_header">diff --git a/crypto/shash.c b/crypto/shash.c</span>
<span class="p_header">index f507294f2811..d15f35019c4b 100644</span>
<span class="p_header">--- a/crypto/shash.c</span>
<span class="p_header">+++ b/crypto/shash.c</span>
<span class="p_chunk">@@ -354,8 +354,10 @@</span> <span class="p_context"> int crypto_init_shash_ops_async(struct crypto_tfm *tfm)</span>
 	crt-&gt;finup = shash_async_finup;
 	crt-&gt;digest = shash_async_digest;
 
<span class="p_del">-	if (alg-&gt;setkey)</span>
<span class="p_add">+	if (alg-&gt;setkey) {</span>
 		crt-&gt;setkey = shash_async_setkey;
<span class="p_add">+		crt-&gt;has_setkey = true;</span>
<span class="p_add">+	}</span>
 	if (alg-&gt;export)
 		crt-&gt;export = shash_async_export;
 	if (alg-&gt;import)
<span class="p_header">diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c</span>
<span class="p_header">index c3f67437afb6..2f25b5e7d453 100644</span>
<span class="p_header">--- a/drivers/edac/edac_device.c</span>
<span class="p_header">+++ b/drivers/edac/edac_device.c</span>
<span class="p_chunk">@@ -444,13 +444,10 @@</span> <span class="p_context"> void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,</span>
  */
 void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev)
 {
<span class="p_del">-	int status;</span>
<span class="p_add">+	edac_dev-&gt;op_state = OP_OFFLINE;</span>
 
<span class="p_del">-	status = cancel_delayed_work(&amp;edac_dev-&gt;work);</span>
<span class="p_del">-	if (status == 0) {</span>
<span class="p_del">-		/* workq instance might be running, wait for it */</span>
<span class="p_del">-		flush_workqueue(edac_workqueue);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;edac_dev-&gt;work);</span>
<span class="p_add">+	flush_workqueue(edac_workqueue);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/edac/edac_mc.c b/drivers/edac/edac_mc.c</span>
<span class="p_header">index 7db101bcb770..08fdb4abc198 100644</span>
<span class="p_header">--- a/drivers/edac/edac_mc.c</span>
<span class="p_header">+++ b/drivers/edac/edac_mc.c</span>
<span class="p_chunk">@@ -348,19 +348,10 @@</span> <span class="p_context"> static void edac_mc_workq_setup(struct mem_ctl_info *mci, unsigned msec,</span>
  */
 static void edac_mc_workq_teardown(struct mem_ctl_info *mci)
 {
<span class="p_del">-	int status;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (mci-&gt;op_state != OP_RUNNING_POLL)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	status = cancel_delayed_work(&amp;mci-&gt;work);</span>
<span class="p_del">-	if (status == 0) {</span>
<span class="p_del">-		debugf0(&quot;%s() not canceled, flush the queue\n&quot;,</span>
<span class="p_del">-			__func__);</span>
<span class="p_add">+	mci-&gt;op_state = OP_OFFLINE;</span>
 
<span class="p_del">-		/* workq instance might be running, wait for it */</span>
<span class="p_del">-		flush_workqueue(edac_workqueue);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;mci-&gt;work);</span>
<span class="p_add">+	flush_workqueue(edac_workqueue);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/edac/edac_pci.c b/drivers/edac/edac_pci.c</span>
<span class="p_header">index 2b378207d571..17b8324434c6 100644</span>
<span class="p_header">--- a/drivers/edac/edac_pci.c</span>
<span class="p_header">+++ b/drivers/edac/edac_pci.c</span>
<span class="p_chunk">@@ -275,13 +275,12 @@</span> <span class="p_context"> static void edac_pci_workq_setup(struct edac_pci_ctl_info *pci,</span>
  */
 static void edac_pci_workq_teardown(struct edac_pci_ctl_info *pci)
 {
<span class="p_del">-	int status;</span>
<span class="p_del">-</span>
 	debugf0(&quot;%s()\n&quot;, __func__);
 
<span class="p_del">-	status = cancel_delayed_work(&amp;pci-&gt;work);</span>
<span class="p_del">-	if (status == 0)</span>
<span class="p_del">-		flush_workqueue(edac_workqueue);</span>
<span class="p_add">+	pci-&gt;op_state = OP_OFFLINE;</span>
<span class="p_add">+</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;pci-&gt;work);</span>
<span class="p_add">+	flush_workqueue(edac_workqueue);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_atombios.c b/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_header">index 24e9756934b6..473bd330032e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_chunk">@@ -446,7 +446,9 @@</span> <span class="p_context"> static bool radeon_atom_apply_quirks(struct drm_device *dev,</span>
 	}
 
 	/* Fujitsu D3003-S2 board lists DVI-I as DVI-D and VGA */
<span class="p_del">-	if (((dev-&gt;pdev-&gt;device == 0x9802) || (dev-&gt;pdev-&gt;device == 0x9806)) &amp;&amp;</span>
<span class="p_add">+	if (((dev-&gt;pdev-&gt;device == 0x9802) ||</span>
<span class="p_add">+	     (dev-&gt;pdev-&gt;device == 0x9805) ||</span>
<span class="p_add">+	     (dev-&gt;pdev-&gt;device == 0x9806)) &amp;&amp;</span>
 	    (dev-&gt;pdev-&gt;subsystem_vendor == 0x1734) &amp;&amp;
 	    (dev-&gt;pdev-&gt;subsystem_device == 0x11bd)) {
 		if (*connector_type == DRM_MODE_CONNECTOR_VGA) {
<span class="p_chunk">@@ -457,14 +459,6 @@</span> <span class="p_context"> static bool radeon_atom_apply_quirks(struct drm_device *dev,</span>
 		}
 	}
 
<span class="p_del">-	/* Fujitsu D3003-S2 board lists DVI-I as DVI-I and VGA */</span>
<span class="p_del">-	if ((dev-&gt;pdev-&gt;device == 0x9805) &amp;&amp;</span>
<span class="p_del">-	    (dev-&gt;pdev-&gt;subsystem_vendor == 0x1734) &amp;&amp;</span>
<span class="p_del">-	    (dev-&gt;pdev-&gt;subsystem_device == 0x11bd)) {</span>
<span class="p_del">-		if (*connector_type == DRM_MODE_CONNECTOR_VGA)</span>
<span class="p_del">-			return false;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	return true;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_device.c b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">index 8cde84b666d5..e51f09f7a175 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_chunk">@@ -960,6 +960,7 @@</span> <span class="p_context"> int radeon_resume_kms(struct drm_device *dev)</span>
 	}
 
 	drm_kms_helper_poll_enable(dev);
<span class="p_add">+	drm_helper_hpd_irq_event(dev);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/ah.c b/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_header">index 5426ccfca1a2..08f3f28bd2fb 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_chunk">@@ -112,6 +112,7 @@</span> <span class="p_context"> static struct ib_ah *create_iboe_ah(struct ib_pd *pd, struct ib_ah_attr *ah_attr</span>
 	ah-&gt;av.eth.port_pd = cpu_to_be32(to_mpd(pd)-&gt;pdn | (ah_attr-&gt;port_num &lt;&lt; 24));
 	ah-&gt;av.eth.gid_index = ah_attr-&gt;grh.sgid_index;
 	ah-&gt;av.eth.vlan = cpu_to_be16(vlan_tag);
<span class="p_add">+	ah-&gt;av.eth.hop_limit = ah_attr-&gt;grh.hop_limit;</span>
 	if (ah_attr-&gt;static_rate) {
 		ah-&gt;av.eth.stat_rate = ah_attr-&gt;static_rate + MLX4_STAT_RATE_OFFSET;
 		while (ah-&gt;av.eth.stat_rate &gt; IB_RATE_2_5_GBPS + MLX4_STAT_RATE_OFFSET &amp;&amp;
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_verbs_mcast.c b/drivers/infiniband/hw/qib/qib_verbs_mcast.c</span>
<span class="p_header">index dabb697b1c2a..48ba1c3e945a 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_verbs_mcast.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_verbs_mcast.c</span>
<span class="p_chunk">@@ -286,15 +286,13 @@</span> <span class="p_context"> int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)</span>
 	struct qib_ibdev *dev = to_idev(ibqp-&gt;device);
 	struct qib_ibport *ibp = to_iport(ibqp-&gt;device, qp-&gt;port_num);
 	struct qib_mcast *mcast = NULL;
<span class="p_del">-	struct qib_mcast_qp *p, *tmp;</span>
<span class="p_add">+	struct qib_mcast_qp *p, *tmp, *delp = NULL;</span>
 	struct rb_node *n;
 	int last = 0;
 	int ret;
 
<span class="p_del">-	if (ibqp-&gt;qp_num &lt;= 1 || qp-&gt;state == IB_QPS_RESET) {</span>
<span class="p_del">-		ret = -EINVAL;</span>
<span class="p_del">-		goto bail;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (ibqp-&gt;qp_num &lt;= 1 || qp-&gt;state == IB_QPS_RESET)</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	spin_lock_irq(&amp;ibp-&gt;lock);
 
<span class="p_chunk">@@ -303,8 +301,7 @@</span> <span class="p_context"> int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)</span>
 	while (1) {
 		if (n == NULL) {
 			spin_unlock_irq(&amp;ibp-&gt;lock);
<span class="p_del">-			ret = -EINVAL;</span>
<span class="p_del">-			goto bail;</span>
<span class="p_add">+			return -EINVAL;</span>
 		}
 
 		mcast = rb_entry(n, struct qib_mcast, rb_node);
<span class="p_chunk">@@ -328,6 +325,7 @@</span> <span class="p_context"> int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)</span>
 		 */
 		list_del_rcu(&amp;p-&gt;list);
 		mcast-&gt;n_attached--;
<span class="p_add">+		delp = p;</span>
 
 		/* If this was the last attached QP, remove the GID too. */
 		if (list_empty(&amp;mcast-&gt;qp_list)) {
<span class="p_chunk">@@ -338,15 +336,16 @@</span> <span class="p_context"> int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)</span>
 	}
 
 	spin_unlock_irq(&amp;ibp-&gt;lock);
<span class="p_add">+	/* QP not attached */</span>
<span class="p_add">+	if (!delp)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Wait for any list walkers to finish before freeing the</span>
<span class="p_add">+	 * list element.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	wait_event(mcast-&gt;wait, atomic_read(&amp;mcast-&gt;refcount) &lt;= 1);</span>
<span class="p_add">+	qib_mcast_qp_free(delp);</span>
 
<span class="p_del">-	if (p) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Wait for any list walkers to finish before freeing the</span>
<span class="p_del">-		 * list element.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		wait_event(mcast-&gt;wait, atomic_read(&amp;mcast-&gt;refcount) &lt;= 1);</span>
<span class="p_del">-		qib_mcast_qp_free(p);</span>
<span class="p_del">-	}</span>
 	if (last) {
 		atomic_dec(&amp;mcast-&gt;refcount);
 		wait_event(mcast-&gt;wait, !atomic_read(&amp;mcast-&gt;refcount));
<span class="p_chunk">@@ -355,11 +354,7 @@</span> <span class="p_context"> int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)</span>
 		dev-&gt;n_mcast_grps_allocated--;
 		spin_unlock_irq(&amp;dev-&gt;n_mcast_grps_lock);
 	}
<span class="p_del">-</span>
<span class="p_del">-	ret = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-bail:</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return 0;</span>
 }
 
 int qib_mcast_tree_empty(struct qib_ibport *ibp)
<span class="p_header">diff --git a/drivers/input/serio/i8042-x86ia64io.h b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">index 858b0e348443..6ceccc2f2d64 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_chunk">@@ -258,6 +258,13 @@</span> <span class="p_context"> static const struct dmi_system_id __initconst i8042_dmi_nomux_table[] = {</span>
 		},
 	},
 	{
<span class="p_add">+		/* Fujitsu Lifebook U745 */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;LIFEBOOK U745&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		/* Fujitsu T70H */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),
<span class="p_header">diff --git a/drivers/md/dm-exception-store.h b/drivers/md/dm-exception-store.h</span>
<span class="p_header">index 0b2536247cf5..84e27708ad97 100644</span>
<span class="p_header">--- a/drivers/md/dm-exception-store.h</span>
<span class="p_header">+++ b/drivers/md/dm-exception-store.h</span>
<span class="p_chunk">@@ -70,7 +70,7 @@</span> <span class="p_context"> struct dm_exception_store_type {</span>
 	 * Update the metadata with this exception.
 	 */
 	void (*commit_exception) (struct dm_exception_store *store,
<span class="p_del">-				  struct dm_exception *e,</span>
<span class="p_add">+				  struct dm_exception *e, int valid,</span>
 				  void (*callback) (void *, int success),
 				  void *callback_context);
 
<span class="p_header">diff --git a/drivers/md/dm-snap-persistent.c b/drivers/md/dm-snap-persistent.c</span>
<span class="p_header">index 75c182bfd128..6215f34a3d10 100644</span>
<span class="p_header">--- a/drivers/md/dm-snap-persistent.c</span>
<span class="p_header">+++ b/drivers/md/dm-snap-persistent.c</span>
<span class="p_chunk">@@ -646,7 +646,7 @@</span> <span class="p_context"> static int persistent_prepare_exception(struct dm_exception_store *store,</span>
 }
 
 static void persistent_commit_exception(struct dm_exception_store *store,
<span class="p_del">-					struct dm_exception *e,</span>
<span class="p_add">+					struct dm_exception *e, int valid,</span>
 					void (*callback) (void *, int success),
 					void *callback_context)
 {
<span class="p_chunk">@@ -655,6 +655,9 @@</span> <span class="p_context"> static void persistent_commit_exception(struct dm_exception_store *store,</span>
 	struct core_exception ce;
 	struct commit_callback *cb;
 
<span class="p_add">+	if (!valid)</span>
<span class="p_add">+		ps-&gt;valid = 0;</span>
<span class="p_add">+</span>
 	ce.old_chunk = e-&gt;old_chunk;
 	ce.new_chunk = e-&gt;new_chunk;
 	write_exception(ps, ps-&gt;current_committed++, &amp;ce);
<span class="p_header">diff --git a/drivers/md/dm-snap-transient.c b/drivers/md/dm-snap-transient.c</span>
<span class="p_header">index 1ce9a2586e41..31439d53cf7e 100644</span>
<span class="p_header">--- a/drivers/md/dm-snap-transient.c</span>
<span class="p_header">+++ b/drivers/md/dm-snap-transient.c</span>
<span class="p_chunk">@@ -52,12 +52,12 @@</span> <span class="p_context"> static int transient_prepare_exception(struct dm_exception_store *store,</span>
 }
 
 static void transient_commit_exception(struct dm_exception_store *store,
<span class="p_del">-				       struct dm_exception *e,</span>
<span class="p_add">+				       struct dm_exception *e, int valid,</span>
 				       void (*callback) (void *, int success),
 				       void *callback_context)
 {
 	/* Just succeed */
<span class="p_del">-	callback(callback_context, 1);</span>
<span class="p_add">+	callback(callback_context, valid);</span>
 }
 
 static void transient_usage(struct dm_exception_store *store,
<span class="p_header">diff --git a/drivers/md/dm-snap.c b/drivers/md/dm-snap.c</span>
<span class="p_header">index 6b94c3ce42ed..09c2b4f2d512 100644</span>
<span class="p_header">--- a/drivers/md/dm-snap.c</span>
<span class="p_header">+++ b/drivers/md/dm-snap.c</span>
<span class="p_chunk">@@ -1393,8 +1393,9 @@</span> <span class="p_context"> static void __invalidate_snapshot(struct dm_snapshot *s, int err)</span>
 	dm_table_event(s-&gt;ti-&gt;table);
 }
 
<span class="p_del">-static void pending_complete(struct dm_snap_pending_exception *pe, int success)</span>
<span class="p_add">+static void pending_complete(void *context, int success)</span>
 {
<span class="p_add">+	struct dm_snap_pending_exception *pe = context;</span>
 	struct dm_exception *e;
 	struct dm_snapshot *s = pe-&gt;snap;
 	struct bio *origin_bios = NULL;
<span class="p_chunk">@@ -1464,24 +1465,13 @@</span> <span class="p_context"> out:</span>
 	free_pending_exception(pe);
 }
 
<span class="p_del">-static void commit_callback(void *context, int success)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct dm_snap_pending_exception *pe = context;</span>
<span class="p_del">-</span>
<span class="p_del">-	pending_complete(pe, success);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void complete_exception(struct dm_snap_pending_exception *pe)
 {
 	struct dm_snapshot *s = pe-&gt;snap;
 
<span class="p_del">-	if (unlikely(pe-&gt;copy_error))</span>
<span class="p_del">-		pending_complete(pe, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	else</span>
<span class="p_del">-		/* Update the metadata if we are persistent */</span>
<span class="p_del">-		s-&gt;store-&gt;type-&gt;commit_exception(s-&gt;store, &amp;pe-&gt;e,</span>
<span class="p_del">-						 commit_callback, pe);</span>
<span class="p_add">+	/* Update the metadata if we are persistent */</span>
<span class="p_add">+	s-&gt;store-&gt;type-&gt;commit_exception(s-&gt;store, &amp;pe-&gt;e, !pe-&gt;copy_error,</span>
<span class="p_add">+					 pending_complete, pe);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/media/dvb/dvb-core/dvb_frontend.c b/drivers/media/dvb/dvb-core/dvb_frontend.c</span>
<span class="p_header">index 2c0acdb4d811..505374def72a 100644</span>
<span class="p_header">--- a/drivers/media/dvb/dvb-core/dvb_frontend.c</span>
<span class="p_header">+++ b/drivers/media/dvb/dvb-core/dvb_frontend.c</span>
<span class="p_chunk">@@ -1661,9 +1661,9 @@</span> <span class="p_context"> static int dvb_frontend_ioctl_legacy(struct file *file,</span>
 		memcpy(info, &amp;fe-&gt;ops.info, sizeof(struct dvb_frontend_info));
 		dvb_frontend_get_frequency_limits(fe, &amp;info-&gt;frequency_min, &amp;info-&gt;frequency_max);
 
<span class="p_del">-		/* Force the CAN_INVERSION_AUTO bit on. If the frontend doesn&#39;t</span>
<span class="p_del">-		 * do it, it is done for it. */</span>
<span class="p_del">-		info-&gt;caps |= FE_CAN_INVERSION_AUTO;</span>
<span class="p_add">+		/* Set CAN_INVERSION_AUTO bit on in other than oneshot mode */</span>
<span class="p_add">+		if (!(fepriv-&gt;tune_mode_flags &amp; FE_TUNE_MODE_ONESHOT))</span>
<span class="p_add">+			info-&gt;caps |= FE_CAN_INVERSION_AUTO;</span>
 		err = 0;
 		break;
 	}
<span class="p_header">diff --git a/drivers/media/rc/rc-main.c b/drivers/media/rc/rc-main.c</span>
<span class="p_header">index 2be51c890141..0a6ccebff2bf 100644</span>
<span class="p_header">--- a/drivers/media/rc/rc-main.c</span>
<span class="p_header">+++ b/drivers/media/rc/rc-main.c</span>
<span class="p_chunk">@@ -54,7 +54,7 @@</span> <span class="p_context"> struct rc_map *rc_map_get(const char *name)</span>
 	struct rc_map_list *map;
 
 	map = seek_rc_map(name);
<span class="p_del">-#ifdef MODULE</span>
<span class="p_add">+#ifdef CONFIG_MODULES</span>
 	if (!map) {
 		int rc = request_module(name);
 		if (rc &lt; 0) {
<span class="p_header">diff --git a/drivers/media/video/gspca/ov534.c b/drivers/media/video/gspca/ov534.c</span>
<span class="p_header">index 76907eced4a1..47456130fd0b 100644</span>
<span class="p_header">--- a/drivers/media/video/gspca/ov534.c</span>
<span class="p_header">+++ b/drivers/media/video/gspca/ov534.c</span>
<span class="p_chunk">@@ -1481,8 +1481,13 @@</span> <span class="p_context"> static void sd_set_streamparm(struct gspca_dev *gspca_dev,</span>
 	struct v4l2_fract *tpf = &amp;cp-&gt;timeperframe;
 	struct sd *sd = (struct sd *) gspca_dev;
 
<span class="p_del">-	/* Set requested framerate */</span>
<span class="p_del">-	sd-&gt;frame_rate = tpf-&gt;denominator / tpf-&gt;numerator;</span>
<span class="p_add">+	if (tpf-&gt;numerator == 0 || tpf-&gt;denominator == 0)</span>
<span class="p_add">+		/* Set default framerate */</span>
<span class="p_add">+		sd-&gt;frame_rate = 30;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		/* Set requested framerate */</span>
<span class="p_add">+		sd-&gt;frame_rate = tpf-&gt;denominator / tpf-&gt;numerator;</span>
<span class="p_add">+</span>
 	if (gspca_dev-&gt;streaming)
 		set_frame_rate(gspca_dev);
 
<span class="p_header">diff --git a/drivers/media/video/gspca/topro.c b/drivers/media/video/gspca/topro.c</span>
<span class="p_header">index 29596c59837f..aac823b543e4 100644</span>
<span class="p_header">--- a/drivers/media/video/gspca/topro.c</span>
<span class="p_header">+++ b/drivers/media/video/gspca/topro.c</span>
<span class="p_chunk">@@ -4789,7 +4789,11 @@</span> <span class="p_context"> static void sd_set_streamparm(struct gspca_dev *gspca_dev,</span>
 	struct v4l2_fract *tpf = &amp;cp-&gt;timeperframe;
 	int fr, i;
 
<span class="p_del">-	sd-&gt;framerate = tpf-&gt;denominator / tpf-&gt;numerator;</span>
<span class="p_add">+	if (tpf-&gt;numerator == 0 || tpf-&gt;denominator == 0)</span>
<span class="p_add">+		sd-&gt;framerate = 30;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		sd-&gt;framerate = tpf-&gt;denominator / tpf-&gt;numerator;</span>
<span class="p_add">+</span>
 	if (gspca_dev-&gt;streaming)
 		setframerate(gspca_dev);
 
<span class="p_header">diff --git a/drivers/media/video/usbvision/usbvision-video.c b/drivers/media/video/usbvision/usbvision-video.c</span>
<span class="p_header">index 5a74f5e07d7d..902140e8db3e 100644</span>
<span class="p_header">--- a/drivers/media/video/usbvision/usbvision-video.c</span>
<span class="p_header">+++ b/drivers/media/video/usbvision/usbvision-video.c</span>
<span class="p_chunk">@@ -1425,6 +1425,7 @@</span> <span class="p_context"> static void usbvision_release(struct usb_usbvision *usbvision)</span>
 
 	usbvision_remove_sysfs(usbvision-&gt;vdev);
 	usbvision_unregister_video(usbvision);
<span class="p_add">+	kfree(usbvision-&gt;alt_max_pkt_size);</span>
 
 	usb_free_urb(usbvision-&gt;ctrl_urb);
 
<span class="p_chunk">@@ -1486,7 +1487,7 @@</span> <span class="p_context"> static int __devinit usbvision_probe(struct usb_interface *intf,</span>
 	const struct usb_host_interface *interface;
 	struct usb_usbvision *usbvision = NULL;
 	const struct usb_endpoint_descriptor *endpoint;
<span class="p_del">-	int model, i;</span>
<span class="p_add">+	int model, i, ret;</span>
 
 	PDEBUG(DBG_PROBE, &quot;VID=%#04x, PID=%#04x, ifnum=%u&quot;,
 				dev-&gt;descriptor.idVendor,
<span class="p_chunk">@@ -1495,33 +1496,58 @@</span> <span class="p_context"> static int __devinit usbvision_probe(struct usb_interface *intf,</span>
 	model = devid-&gt;driver_info;
 	if (model &lt; 0 || model &gt;= usbvision_device_data_size) {
 		PDEBUG(DBG_PROBE, &quot;model out of bounds %d&quot;, model);
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto err_usb;</span>
 	}
 	printk(KERN_INFO &quot;%s: %s found\n&quot;, __func__,
 				usbvision_device_data[model].model_string);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * this is a security check.</span>
<span class="p_add">+	 * an exploit using an incorrect bInterfaceNumber is known</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ifnum &gt;= USB_MAXINTERFACES || !dev-&gt;actconfig-&gt;interface[ifnum])</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	if (usbvision_device_data[model].interface &gt;= 0)
 		interface = &amp;dev-&gt;actconfig-&gt;interface[usbvision_device_data[model].interface]-&gt;altsetting[0];
<span class="p_del">-	else</span>
<span class="p_add">+	else if (ifnum &lt; dev-&gt;actconfig-&gt;desc.bNumInterfaces)</span>
 		interface = &amp;dev-&gt;actconfig-&gt;interface[ifnum]-&gt;altsetting[0];
<span class="p_add">+	else {</span>
<span class="p_add">+		dev_err(&amp;intf-&gt;dev, &quot;interface %d is invalid, max is %d\n&quot;,</span>
<span class="p_add">+		    ifnum, dev-&gt;actconfig-&gt;desc.bNumInterfaces - 1);</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto err_usb;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (interface-&gt;desc.bNumEndpoints &lt; 2) {</span>
<span class="p_add">+		dev_err(&amp;intf-&gt;dev, &quot;interface %d has %d endpoints, but must&quot;</span>
<span class="p_add">+		    &quot; have minimum 2\n&quot;, ifnum, interface-&gt;desc.bNumEndpoints);</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto err_usb;</span>
<span class="p_add">+	}</span>
 	endpoint = &amp;interface-&gt;endpoint[1].desc;
<span class="p_add">+</span>
 	if (!usb_endpoint_xfer_isoc(endpoint)) {
 		dev_err(&amp;intf-&gt;dev, &quot;%s: interface %d. has non-ISO endpoint!\n&quot;,
 		    __func__, ifnum);
 		dev_err(&amp;intf-&gt;dev, &quot;%s: Endpoint attributes %d&quot;,
 		    __func__, endpoint-&gt;bmAttributes);
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto err_usb;</span>
 	}
 	if (usb_endpoint_dir_out(endpoint)) {
 		dev_err(&amp;intf-&gt;dev, &quot;%s: interface %d. has ISO OUT endpoint!\n&quot;,
 		    __func__, ifnum);
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto err_usb;</span>
 	}
 
 	usbvision = usbvision_alloc(dev, intf);
 	if (usbvision == NULL) {
 		dev_err(&amp;intf-&gt;dev, &quot;%s: couldn&#39;t allocate USBVision struct\n&quot;, __func__);
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto err_usb;</span>
 	}
 
 	if (dev-&gt;descriptor.bNumConfigurations &gt; 1)
<span class="p_chunk">@@ -1540,7 +1566,8 @@</span> <span class="p_context"> static int __devinit usbvision_probe(struct usb_interface *intf,</span>
 	usbvision-&gt;alt_max_pkt_size = kmalloc(32 * usbvision-&gt;num_alt, GFP_KERNEL);
 	if (usbvision-&gt;alt_max_pkt_size == NULL) {
 		dev_err(&amp;intf-&gt;dev, &quot;usbvision: out of memory!\n&quot;);
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto err_pkt;</span>
 	}
 
 	for (i = 0; i &lt; usbvision-&gt;num_alt; i++) {
<span class="p_chunk">@@ -1575,6 +1602,12 @@</span> <span class="p_context"> static int __devinit usbvision_probe(struct usb_interface *intf,</span>
 
 	PDEBUG(DBG_PROBE, &quot;success&quot;);
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+err_pkt:</span>
<span class="p_add">+	usbvision_release(usbvision);</span>
<span class="p_add">+err_usb:</span>
<span class="p_add">+	usb_put_dev(dev);</span>
<span class="p_add">+	return ret;</span>
 }
 
 
<span class="p_header">diff --git a/drivers/net/usb/asix.c b/drivers/net/usb/asix.c</span>
<span class="p_header">index 3d068fe034cc..9f5369888abe 100644</span>
<span class="p_header">--- a/drivers/net/usb/asix.c</span>
<span class="p_header">+++ b/drivers/net/usb/asix.c</span>
<span class="p_chunk">@@ -361,7 +361,7 @@</span> <span class="p_context"> static int asix_rx_fixup_internal(struct usbnet *dev, struct sk_buff *skb,</span>
 		}
 
 		if (rx-&gt;size &gt; dev-&gt;net-&gt;mtu + ETH_HLEN + VLAN_HLEN) {
<span class="p_del">-			netdev_err(dev-&gt;net, &quot;asix_rx_fixup() Bad RX Length %d\n&quot;,</span>
<span class="p_add">+			netdev_dbg(dev-&gt;net, &quot;asix_rx_fixup() Bad RX Length %d\n&quot;,</span>
 				   rx-&gt;size);
 			kfree_skb(rx-&gt;ax_skb);
 			return 0;
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/htc_hst.c b/drivers/net/wireless/ath/ath9k/htc_hst.c</span>
<span class="p_header">index 4f7843ae6800..51e256e7578a 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/htc_hst.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/htc_hst.c</span>
<span class="p_chunk">@@ -377,7 +377,7 @@</span> <span class="p_context"> void ath9k_htc_rx_msg(struct htc_target *htc_handle,</span>
 	htc_hdr = (struct htc_frame_hdr *) skb-&gt;data;
 	epid = htc_hdr-&gt;endpoint_id;
 
<span class="p_del">-	if (epid &gt;= ENDPOINT_MAX) {</span>
<span class="p_add">+	if (epid &lt; 0 || epid &gt;= ENDPOINT_MAX) {</span>
 		if (pipe_id != USB_REG_IN_PIPE)
 			dev_kfree_skb_any(skb);
 		else
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8192ce/sw.c b/drivers/net/wireless/rtlwifi/rtl8192ce/sw.c</span>
<span class="p_header">index df852e8ab529..f7cff456dd06 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8192ce/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8192ce/sw.c</span>
<span class="p_chunk">@@ -138,6 +138,8 @@</span> <span class="p_context"> int rtl92c_init_sw_vars(struct ieee80211_hw *hw)</span>
 	rtlpriv-&gt;psc.inactiveps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;inactiveps;
 	rtlpriv-&gt;psc.swctrl_lps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;swctrl_lps;
 	rtlpriv-&gt;psc.fwctrl_lps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;fwctrl_lps;
<span class="p_add">+	rtlpriv-&gt;cfg-&gt;mod_params-&gt;sw_crypto =</span>
<span class="p_add">+		rtlpriv-&gt;cfg-&gt;mod_params-&gt;sw_crypto;</span>
 	if (!rtlpriv-&gt;psc.inactiveps)
 		pr_info(&quot;rtl8192ce: Power Save off (module option)\n&quot;);
 	if (!rtlpriv-&gt;psc.fwctrl_lps)
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_header">index e813efffd6b3..7d6227c8cf23 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_chunk">@@ -62,6 +62,8 @@</span> <span class="p_context"> static int rtl92cu_init_sw_vars(struct ieee80211_hw *hw)</span>
 	rtlpriv-&gt;dm.disable_framebursting = 0;
 	rtlpriv-&gt;dm.thermalvalue = 0;
 	rtlpriv-&gt;dbg.global_debuglevel = rtlpriv-&gt;cfg-&gt;mod_params-&gt;debug;
<span class="p_add">+	rtlpriv-&gt;cfg-&gt;mod_params-&gt;sw_crypto =</span>
<span class="p_add">+		rtlpriv-&gt;cfg-&gt;mod_params-&gt;sw_crypto;</span>
 	rtlpriv-&gt;rtlhal.pfirmware = vmalloc(0x4000);
 	if (!rtlpriv-&gt;rtlhal.pfirmware) {
 		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8192de/sw.c b/drivers/net/wireless/rtlwifi/rtl8192de/sw.c</span>
<span class="p_header">index 149493f4c25c..1813cde3b4c9 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8192de/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8192de/sw.c</span>
<span class="p_chunk">@@ -387,8 +387,8 @@</span> <span class="p_context"> module_param_named(swlps, rtl92de_mod_params.swctrl_lps, bool, 0444);</span>
 module_param_named(fwlps, rtl92de_mod_params.fwctrl_lps, bool, 0444);
 MODULE_PARM_DESC(swenc, &quot;Set to 1 for software crypto (default 0)\n&quot;);
 MODULE_PARM_DESC(ips, &quot;Set to 0 to not use link power save (default 1)\n&quot;);
<span class="p_del">-MODULE_PARM_DESC(swlps, &quot;Set to 1 to use SW control power save (default 0)\n&quot;);</span>
<span class="p_del">-MODULE_PARM_DESC(fwlps, &quot;Set to 1 to use FW control power save (default 1)\n&quot;);</span>
<span class="p_add">+MODULE_PARM_DESC(swlps, &quot;Set to 1 to use SW control power save (default 1)\n&quot;);</span>
<span class="p_add">+MODULE_PARM_DESC(fwlps, &quot;Set to 1 to use FW control power save (default 0)\n&quot;);</span>
 MODULE_PARM_DESC(debug, &quot;Set debug level (0-5) (default 0)&quot;);
 
 static const struct dev_pm_ops rtlwifi_pm_ops = {
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8192se/sw.c b/drivers/net/wireless/rtlwifi/rtl8192se/sw.c</span>
<span class="p_header">index 92f49d522c56..a0e06142dc75 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8192se/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8192se/sw.c</span>
<span class="p_chunk">@@ -167,6 +167,8 @@</span> <span class="p_context"> static int rtl92s_init_sw_vars(struct ieee80211_hw *hw)</span>
 	rtlpriv-&gt;psc.inactiveps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;inactiveps;
 	rtlpriv-&gt;psc.swctrl_lps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;swctrl_lps;
 	rtlpriv-&gt;psc.fwctrl_lps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;fwctrl_lps;
<span class="p_add">+	rtlpriv-&gt;cfg-&gt;mod_params-&gt;sw_crypto =</span>
<span class="p_add">+		rtlpriv-&gt;cfg-&gt;mod_params-&gt;sw_crypto;</span>
 	if (!rtlpriv-&gt;psc.inactiveps)
 		pr_info(&quot;rtl8192ce: Power Save off (module option)\n&quot;);
 	if (!rtlpriv-&gt;psc.fwctrl_lps)
<span class="p_chunk">@@ -399,8 +401,8 @@</span> <span class="p_context"> module_param_named(swlps, rtl92se_mod_params.swctrl_lps, bool, 0444);</span>
 module_param_named(fwlps, rtl92se_mod_params.fwctrl_lps, bool, 0444);
 MODULE_PARM_DESC(swenc, &quot;Set to 1 for software crypto (default 0)\n&quot;);
 MODULE_PARM_DESC(ips, &quot;Set to 0 to not use link power save (default 1)\n&quot;);
<span class="p_del">-MODULE_PARM_DESC(swlps, &quot;Set to 1 to use SW control power save (default 0)\n&quot;);</span>
<span class="p_del">-MODULE_PARM_DESC(fwlps, &quot;Set to 1 to use FW control power save (default 1)\n&quot;);</span>
<span class="p_add">+MODULE_PARM_DESC(swlps, &quot;Set to 1 to use SW control power save (default 1)\n&quot;);</span>
<span class="p_add">+MODULE_PARM_DESC(fwlps, &quot;Set to 1 to use FW control power save (default 0)\n&quot;);</span>
 MODULE_PARM_DESC(debug, &quot;Set debug level (0-5) (default 0)&quot;);
 
 static const struct dev_pm_ops rtlwifi_pm_ops = {
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/usb.c b/drivers/net/wireless/rtlwifi/usb.c</span>
<span class="p_header">index 17e642978f8d..968137a0eca7 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/usb.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/usb.c</span>
<span class="p_chunk">@@ -500,6 +500,8 @@</span> <span class="p_context"> static void _rtl_usb_rx_process_noagg(struct ieee80211_hw *hw,</span>
 		} else {
 			dev_kfree_skb_any(skb);
 		}
<span class="p_add">+	} else {</span>
<span class="p_add">+		dev_kfree_skb_any(skb);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/net/wireless/wl12xx/spi.c b/drivers/net/wireless/wl12xx/spi.c</span>
<span class="p_header">index 0f9718677860..6866e3f8d64d 100644</span>
<span class="p_header">--- a/drivers/net/wireless/wl12xx/spi.c</span>
<span class="p_header">+++ b/drivers/net/wireless/wl12xx/spi.c</span>
<span class="p_chunk">@@ -67,7 +67,10 @@</span> <span class="p_context"></span>
 /* HW limitation: maximum possible chunk size is 4095 bytes */
 #define WSPI_MAX_CHUNK_SIZE    4092
 
<span class="p_del">-#define WSPI_MAX_NUM_OF_CHUNKS (WL1271_AGGR_BUFFER_SIZE / WSPI_MAX_CHUNK_SIZE)</span>
<span class="p_add">+/* Maximum number of SPI write chunks */</span>
<span class="p_add">+#define WSPI_MAX_NUM_OF_CHUNKS \</span>
<span class="p_add">+	((WL1271_AGGR_BUFFER_SIZE / WSPI_MAX_CHUNK_SIZE) + 1)</span>
<span class="p_add">+</span>
 
 static inline struct spi_device *wl_to_spi(struct wl1271 *wl)
 {
<span class="p_chunk">@@ -274,9 +277,10 @@</span> <span class="p_context"> static void wl1271_spi_raw_read(struct wl1271 *wl, int addr, void *buf,</span>
 static void wl1271_spi_raw_write(struct wl1271 *wl, int addr, void *buf,
 			  size_t len, bool fixed)
 {
<span class="p_add">+	/* SPI write buffers - 2 for each chunk */</span>
 	struct spi_transfer t[2 * WSPI_MAX_NUM_OF_CHUNKS];
 	struct spi_message m;
<span class="p_del">-	u32 commands[WSPI_MAX_NUM_OF_CHUNKS];</span>
<span class="p_add">+	u32 commands[WSPI_MAX_NUM_OF_CHUNKS]; /* 1 command per chunk */</span>
 	u32 *cmd;
 	u32 chunk_len;
 	int i;
<span class="p_header">diff --git a/drivers/power/test_power.c b/drivers/power/test_power.c</span>
<span class="p_header">index b527c93bf2f3..c4a0f5a37189 100644</span>
<span class="p_header">--- a/drivers/power/test_power.c</span>
<span class="p_header">+++ b/drivers/power/test_power.c</span>
<span class="p_chunk">@@ -237,6 +237,8 @@</span> <span class="p_context"> static int map_get_value(struct battery_property_map *map, const char *key,</span>
 	buf[MAX_KEYLENGTH-1] = &#39;\0&#39;;
 
 	cr = strnlen(buf, MAX_KEYLENGTH) - 1;
<span class="p_add">+	if (cr &lt; 0)</span>
<span class="p_add">+		return def_val;</span>
 	if (buf[cr] == &#39;\n&#39;)
 		buf[cr] = &#39;\0&#39;;
 
<span class="p_header">diff --git a/drivers/scsi/initio.c b/drivers/scsi/initio.c</span>
<span class="p_header">index dd741bcd6ccd..fb451f76c2ac 100644</span>
<span class="p_header">--- a/drivers/scsi/initio.c</span>
<span class="p_header">+++ b/drivers/scsi/initio.c</span>
<span class="p_chunk">@@ -110,11 +110,6 @@</span> <span class="p_context"></span>
 #define i91u_MAXQUEUE		2
 #define i91u_REVID &quot;Initio INI-9X00U/UW SCSI device driver; Revision: 1.04a&quot;
 
<span class="p_del">-#define I950_DEVICE_ID	0x9500	/* Initio&#39;s inic-950 product ID   */</span>
<span class="p_del">-#define I940_DEVICE_ID	0x9400	/* Initio&#39;s inic-940 product ID   */</span>
<span class="p_del">-#define I935_DEVICE_ID	0x9401	/* Initio&#39;s inic-935 product ID   */</span>
<span class="p_del">-#define I920_DEVICE_ID	0x0002	/* Initio&#39;s other product ID      */</span>
<span class="p_del">-</span>
 #ifdef DEBUG_i91u
 static unsigned int i91u_debug = DEBUG_DEFAULT;
 #endif
<span class="p_chunk">@@ -127,17 +122,6 @@</span> <span class="p_context"> static int setup_debug = 0;</span>
 
 static void i91uSCBPost(u8 * pHcb, u8 * pScb);
 
<span class="p_del">-/* PCI Devices supported by this driver */</span>
<span class="p_del">-static struct pci_device_id i91u_pci_devices[] = {</span>
<span class="p_del">-	{ PCI_VENDOR_ID_INIT,  I950_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},</span>
<span class="p_del">-	{ PCI_VENDOR_ID_INIT,  I940_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},</span>
<span class="p_del">-	{ PCI_VENDOR_ID_INIT,  I935_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},</span>
<span class="p_del">-	{ PCI_VENDOR_ID_INIT,  I920_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},</span>
<span class="p_del">-	{ PCI_VENDOR_ID_DOMEX, I920_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},</span>
<span class="p_del">-	{ }</span>
<span class="p_del">-};</span>
<span class="p_del">-MODULE_DEVICE_TABLE(pci, i91u_pci_devices);</span>
<span class="p_del">-</span>
 #define DEBUG_INTERRUPT 0
 #define DEBUG_QUEUE     0
 #define DEBUG_STATE     0
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index d7ddb5a064d9..a1f90c7fb564 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -4300,6 +4300,9 @@</span> <span class="p_context"> static int __init xhci_hcd_init(void)</span>
 {
 	int retval;
 
<span class="p_add">+	if (usb_disabled())</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	retval = xhci_register_pci();
 	if (retval &lt; 0) {
 		printk(KERN_DEBUG &quot;Problem registering PCI driver.&quot;);
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 1398597b1725..2d622d7ba534 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -166,6 +166,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x17F4, 0xAAAA) }, /* Wavesense Jazz blood glucose meter */
 	{ USB_DEVICE(0x1843, 0x0200) }, /* Vaisala USB Instrument Cable */
 	{ USB_DEVICE(0x18EF, 0xE00F) }, /* ELV USB-I2C-Interface */
<span class="p_add">+	{ USB_DEVICE(0x18EF, 0xE025) }, /* ELV Marble Sound Board 1 */</span>
 	{ USB_DEVICE(0x1ADB, 0x0001) }, /* Schweitzer Engineering C662 Cable */
 	{ USB_DEVICE(0x1B1C, 0x1C00) }, /* Corsair USB Dongle */
 	{ USB_DEVICE(0x1BA4, 0x0002) },	/* Silicon Labs 358x factory default */
<span class="p_header">diff --git a/fs/cifs/cifs_debug.h b/fs/cifs/cifs_debug.h</span>
<span class="p_header">index 8942b28cf807..3d55d720509d 100644</span>
<span class="p_header">--- a/fs/cifs/cifs_debug.h</span>
<span class="p_header">+++ b/fs/cifs/cifs_debug.h</span>
<span class="p_chunk">@@ -23,6 +23,8 @@</span> <span class="p_context"></span>
 #ifndef _H_CIFS_DEBUG
 #define _H_CIFS_DEBUG
 
<span class="p_add">+#include &lt;linux/ratelimit.h&gt;</span>
<span class="p_add">+</span>
 void cifs_dump_mem(char *label, void *data, int length);
 #ifdef CONFIG_CIFS_DEBUG2
 #define DBG2 2
<span class="p_chunk">@@ -48,7 +50,7 @@</span> <span class="p_context"> extern int cifsFYI;</span>
 #define cifsfyi(fmt, arg...)						\
 do {									\
 	if (cifsFYI &amp; CIFS_INFO)					\
<span class="p_del">-		printk(KERN_DEBUG &quot;%s: &quot; fmt &quot;\n&quot;, __FILE__, ##arg);	\</span>
<span class="p_add">+		pr_debug_ratelimited(&quot;%s: &quot; fmt &quot;\n&quot;, __FILE__, ##arg); \</span>
 } while (0)
 
 #define cFYI(set, fmt, arg...)			\
<span class="p_chunk">@@ -58,7 +60,7 @@</span> <span class="p_context"> do {						\</span>
 } while (0)
 
 #define cifswarn(fmt, arg...)			\
<span class="p_del">-	printk(KERN_WARNING fmt &quot;\n&quot;, ##arg)</span>
<span class="p_add">+	pr_warn_ratelimited(fmt &quot;\n&quot;, ##arg)</span>
 
 /* debug event message: */
 extern int cifsERROR;
<span class="p_chunk">@@ -73,7 +75,7 @@</span> <span class="p_context"> do {									\</span>
 #define cifserror(fmt, arg...)					\
 do {								\
 	if (cifsERROR)						\
<span class="p_del">-		printk(KERN_ERR &quot;CIFS VFS: &quot; fmt &quot;\n&quot;, ##arg);	\</span>
<span class="p_add">+		pr_err_ratelimited(&quot;CIFS VFS: &quot; fmt &quot;\n&quot;, ##arg);	\</span>
 } while (0)
 
 #define cERROR(set, fmt, arg...)		\
<span class="p_header">diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c</span>
<span class="p_header">index 49d6e21052c2..f0f7a6c200b8 100644</span>
<span class="p_header">--- a/fs/cifs/connect.c</span>
<span class="p_header">+++ b/fs/cifs/connect.c</span>
<span class="p_chunk">@@ -134,7 +134,6 @@</span> <span class="p_context"> cifs_reconnect(struct TCP_Server_Info *server)</span>
 	server-&gt;session_key.response = NULL;
 	server-&gt;session_key.len = 0;
 	server-&gt;lstrp = jiffies;
<span class="p_del">-	mutex_unlock(&amp;server-&gt;srv_mutex);</span>
 
 	/* mark submitted MIDs for retry and issue callback */
 	INIT_LIST_HEAD(&amp;retry_list);
<span class="p_chunk">@@ -147,6 +146,7 @@</span> <span class="p_context"> cifs_reconnect(struct TCP_Server_Info *server)</span>
 		list_move(&amp;mid_entry-&gt;qhead, &amp;retry_list);
 	}
 	spin_unlock(&amp;GlobalMid_Lock);
<span class="p_add">+	mutex_unlock(&amp;server-&gt;srv_mutex);</span>
 
 	cFYI(1, &quot;%s: issuing mid callbacks&quot;, __func__);
 	list_for_each_safe(tmp, tmp2, &amp;retry_list) {
<span class="p_header">diff --git a/fs/cifs/readdir.c b/fs/cifs/readdir.c</span>
<span class="p_header">index 52a820a3b98a..dc93a6d20a17 100644</span>
<span class="p_header">--- a/fs/cifs/readdir.c</span>
<span class="p_header">+++ b/fs/cifs/readdir.c</span>
<span class="p_chunk">@@ -823,6 +823,7 @@</span> <span class="p_context"> int cifs_readdir(struct file *file, void *direntry, filldir_t filldir)</span>
 			}
 			/* if buggy server returns . and .. late do
 			we want to check for that here? */
<span class="p_add">+			*tmp_buf = 0;</span>
 			rc = cifs_filldir(current_entry, file,
 					filldir, direntry, tmp_buf, max_len);
 			if (rc == -EOVERFLOW) {
<span class="p_header">diff --git a/fs/cifs/transport.c b/fs/cifs/transport.c</span>
<span class="p_header">index 4e5dfb7f7d80..d21a89b9d495 100644</span>
<span class="p_header">--- a/fs/cifs/transport.c</span>
<span class="p_header">+++ b/fs/cifs/transport.c</span>
<span class="p_chunk">@@ -370,10 +370,8 @@</span> <span class="p_context"> cifs_call_async(struct TCP_Server_Info *server, struct kvec *iov,</span>
 	spin_unlock(&amp;GlobalMid_Lock);
 
 	rc = cifs_sign_smb2(iov, nvec, server, &amp;mid-&gt;sequence_number);
<span class="p_del">-	if (rc) {</span>
<span class="p_del">-		mutex_unlock(&amp;server-&gt;srv_mutex);</span>
<span class="p_del">-		goto out_err;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (rc)</span>
<span class="p_add">+		goto out;</span>
 
 	mid-&gt;receive = receive;
 	mid-&gt;callback = callback;
<span class="p_chunk">@@ -384,14 +382,15 @@</span> <span class="p_context"> cifs_call_async(struct TCP_Server_Info *server, struct kvec *iov,</span>
 	rc = smb_sendv(server, iov, nvec);
 	cifs_in_send_dec(server);
 	cifs_save_when_sent(mid);
<span class="p_add">+out:</span>
<span class="p_add">+	if (rc &lt; 0)</span>
<span class="p_add">+		delete_mid(mid);</span>
<span class="p_add">+</span>
 	mutex_unlock(&amp;server-&gt;srv_mutex);
 
<span class="p_del">-	if (rc)</span>
<span class="p_del">-		goto out_err;</span>
<span class="p_add">+	if (rc == 0)</span>
<span class="p_add">+		return 0;</span>
 
<span class="p_del">-	return rc;</span>
<span class="p_del">-out_err:</span>
<span class="p_del">-	delete_mid(mid);</span>
 	atomic_dec(&amp;server-&gt;inFlight);
 	wake_up(&amp;server-&gt;request_q);
 	return rc;
<span class="p_header">diff --git a/fs/hostfs/hostfs_kern.c b/fs/hostfs/hostfs_kern.c</span>
<span class="p_header">index 104e4d9b4067..8db3979cdba6 100644</span>
<span class="p_header">--- a/fs/hostfs/hostfs_kern.c</span>
<span class="p_header">+++ b/fs/hostfs/hostfs_kern.c</span>
<span class="p_chunk">@@ -720,15 +720,13 @@</span> <span class="p_context"> int hostfs_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)</span>
 
 	init_special_inode(inode, mode, dev);
 	err = do_mknod(name, mode, MAJOR(dev), MINOR(dev));
<span class="p_del">-	if (!err)</span>
<span class="p_add">+	if (err)</span>
 		goto out_free;
 
 	err = read_name(inode, name);
 	__putname(name);
 	if (err)
 		goto out_put;
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto out_put;</span>
 
 	d_instantiate(dentry, inode);
 	return 0;
<span class="p_header">diff --git a/fs/locks.c b/fs/locks.c</span>
<span class="p_header">index d4f1d89d9bc6..c7848dbdec61 100644</span>
<span class="p_header">--- a/fs/locks.c</span>
<span class="p_header">+++ b/fs/locks.c</span>
<span class="p_chunk">@@ -1863,7 +1863,6 @@</span> <span class="p_context"> int fcntl_setlk(unsigned int fd, struct file *filp, unsigned int cmd,</span>
 		goto out;
 	}
 
<span class="p_del">-again:</span>
 	error = flock_to_posix_lock(filp, file_lock, &amp;flock);
 	if (error)
 		goto out;
<span class="p_chunk">@@ -1894,19 +1893,22 @@</span> <span class="p_context"> again:</span>
 	 * Attempt to detect a close/fcntl race and recover by
 	 * releasing the lock that was just acquired.
 	 */
<span class="p_del">-	/*</span>
<span class="p_del">-	 * we need that spin_lock here - it prevents reordering between</span>
<span class="p_del">-	 * update of inode-&gt;i_flock and check for it done in close().</span>
<span class="p_del">-	 * rcu_read_lock() wouldn&#39;t do.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	spin_lock(&amp;current-&gt;files-&gt;file_lock);</span>
<span class="p_del">-	f = fcheck(fd);</span>
<span class="p_del">-	spin_unlock(&amp;current-&gt;files-&gt;file_lock);</span>
<span class="p_del">-	if (!error &amp;&amp; f != filp &amp;&amp; flock.l_type != F_UNLCK) {</span>
<span class="p_del">-		flock.l_type = F_UNLCK;</span>
<span class="p_del">-		goto again;</span>
<span class="p_add">+	if (!error &amp;&amp; file_lock-&gt;fl_type != F_UNLCK) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We need that spin_lock here - it prevents reordering between</span>
<span class="p_add">+		 * update of inode-&gt;i_flock and check for it done in</span>
<span class="p_add">+		 * close(). rcu_read_lock() wouldn&#39;t do.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		spin_lock(&amp;current-&gt;files-&gt;file_lock);</span>
<span class="p_add">+		f = fcheck(fd);</span>
<span class="p_add">+		spin_unlock(&amp;current-&gt;files-&gt;file_lock);</span>
<span class="p_add">+		if (f != filp) {</span>
<span class="p_add">+			file_lock-&gt;fl_type = F_UNLCK;</span>
<span class="p_add">+			error = do_lock_file_wait(filp, cmd, file_lock);</span>
<span class="p_add">+			WARN_ON_ONCE(error);</span>
<span class="p_add">+			error = -EBADF;</span>
<span class="p_add">+		}</span>
 	}
<span class="p_del">-</span>
 out:
 	locks_free_lock(file_lock);
 	return error;
<span class="p_chunk">@@ -1981,7 +1983,6 @@</span> <span class="p_context"> int fcntl_setlk64(unsigned int fd, struct file *filp, unsigned int cmd,</span>
 		goto out;
 	}
 
<span class="p_del">-again:</span>
 	error = flock64_to_posix_lock(filp, file_lock, &amp;flock);
 	if (error)
 		goto out;
<span class="p_chunk">@@ -2012,14 +2013,22 @@</span> <span class="p_context"> again:</span>
 	 * Attempt to detect a close/fcntl race and recover by
 	 * releasing the lock that was just acquired.
 	 */
<span class="p_del">-	spin_lock(&amp;current-&gt;files-&gt;file_lock);</span>
<span class="p_del">-	f = fcheck(fd);</span>
<span class="p_del">-	spin_unlock(&amp;current-&gt;files-&gt;file_lock);</span>
<span class="p_del">-	if (!error &amp;&amp; f != filp &amp;&amp; flock.l_type != F_UNLCK) {</span>
<span class="p_del">-		flock.l_type = F_UNLCK;</span>
<span class="p_del">-		goto again;</span>
<span class="p_add">+	if (!error &amp;&amp; file_lock-&gt;fl_type != F_UNLCK) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We need that spin_lock here - it prevents reordering between</span>
<span class="p_add">+		 * update of inode-&gt;i_flock and check for it done in</span>
<span class="p_add">+		 * close(). rcu_read_lock() wouldn&#39;t do.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		spin_lock(&amp;current-&gt;files-&gt;file_lock);</span>
<span class="p_add">+		f = fcheck(fd);</span>
<span class="p_add">+		spin_unlock(&amp;current-&gt;files-&gt;file_lock);</span>
<span class="p_add">+		if (f != filp) {</span>
<span class="p_add">+			file_lock-&gt;fl_type = F_UNLCK;</span>
<span class="p_add">+			error = do_lock_file_wait(filp, cmd, file_lock);</span>
<span class="p_add">+			WARN_ON_ONCE(error);</span>
<span class="p_add">+			error = -EBADF;</span>
<span class="p_add">+		}</span>
 	}
<span class="p_del">-</span>
 out:
 	locks_free_lock(file_lock);
 	return error;
<span class="p_header">diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c</span>
<span class="p_header">index a1503a7013a1..af47ea125582 100644</span>
<span class="p_header">--- a/fs/nfs/inode.c</span>
<span class="p_header">+++ b/fs/nfs/inode.c</span>
<span class="p_chunk">@@ -1207,6 +1207,7 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 	unsigned long invalid = 0;
 	unsigned long now = jiffies;
 	unsigned long save_cache_validity;
<span class="p_add">+	bool cache_revalidated = true;</span>
 
 	dfprintk(VFS, &quot;NFS: %s(%s/%ld ct=%d info=0x%x)\n&quot;,
 			__func__, inode-&gt;i_sb-&gt;s_id, inode-&gt;i_ino,
<span class="p_chunk">@@ -1252,8 +1253,10 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 				nfs_force_lookup_revalidate(inode);
 			inode-&gt;i_version = fattr-&gt;change_attr;
 		}
<span class="p_del">-	} else if (server-&gt;caps &amp; NFS_CAP_CHANGE_ATTR)</span>
<span class="p_add">+	} else if (server-&gt;caps &amp; NFS_CAP_CHANGE_ATTR) {</span>
 		invalid |= save_cache_validity;
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_MTIME) {
 		/* NFSv2/v3: Check if the mtime agrees */
<span class="p_chunk">@@ -1265,11 +1268,13 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 				nfs_force_lookup_revalidate(inode);
 			memcpy(&amp;inode-&gt;i_mtime, &amp;fattr-&gt;mtime, sizeof(inode-&gt;i_mtime));
 		}
<span class="p_del">-	} else if (server-&gt;caps &amp; NFS_CAP_MTIME)</span>
<span class="p_add">+	} else if (server-&gt;caps &amp; NFS_CAP_MTIME) {</span>
 		invalid |= save_cache_validity &amp; (NFS_INO_INVALID_ATTR
 				| NFS_INO_INVALID_DATA
 				| NFS_INO_REVAL_PAGECACHE
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_CTIME) {
 		/* If ctime has changed we should definitely clear access+acl caches */
<span class="p_chunk">@@ -1284,11 +1289,13 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 			}
 			memcpy(&amp;inode-&gt;i_ctime, &amp;fattr-&gt;ctime, sizeof(inode-&gt;i_ctime));
 		}
<span class="p_del">-	} else if (server-&gt;caps &amp; NFS_CAP_CTIME)</span>
<span class="p_add">+	} else if (server-&gt;caps &amp; NFS_CAP_CTIME) {</span>
 		invalid |= save_cache_validity &amp; (NFS_INO_INVALID_ATTR
 				| NFS_INO_INVALID_ACCESS
 				| NFS_INO_INVALID_ACL
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	/* Check if our cached file size is stale */
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_SIZE) {
<span class="p_chunk">@@ -1309,17 +1316,21 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 					(long long)cur_isize,
 					(long long)new_isize);
 		}
<span class="p_del">-	} else</span>
<span class="p_add">+	} else {</span>
 		invalid |= save_cache_validity &amp; (NFS_INO_INVALID_ATTR
 				| NFS_INO_REVAL_PAGECACHE
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_ATIME)
 		memcpy(&amp;inode-&gt;i_atime, &amp;fattr-&gt;atime, sizeof(inode-&gt;i_atime));
<span class="p_del">-	else if (server-&gt;caps &amp; NFS_CAP_ATIME)</span>
<span class="p_add">+	else if (server-&gt;caps &amp; NFS_CAP_ATIME) {</span>
 		invalid |= save_cache_validity &amp; (NFS_INO_INVALID_ATIME
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_MODE) {
 		if ((inode-&gt;i_mode &amp; S_IALLUGO) != (fattr-&gt;mode &amp; S_IALLUGO)) {
<span class="p_chunk">@@ -1328,33 +1339,39 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 			inode-&gt;i_mode = newmode;
 			invalid |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL;
 		}
<span class="p_del">-	} else if (server-&gt;caps &amp; NFS_CAP_MODE)</span>
<span class="p_add">+	} else if (server-&gt;caps &amp; NFS_CAP_MODE) {</span>
 		invalid |= save_cache_validity &amp; (NFS_INO_INVALID_ATTR
 				| NFS_INO_INVALID_ACCESS
 				| NFS_INO_INVALID_ACL
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_OWNER) {
 		if (inode-&gt;i_uid != fattr-&gt;uid) {
 			invalid |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL;
 			inode-&gt;i_uid = fattr-&gt;uid;
 		}
<span class="p_del">-	} else if (server-&gt;caps &amp; NFS_CAP_OWNER)</span>
<span class="p_add">+	} else if (server-&gt;caps &amp; NFS_CAP_OWNER) {</span>
 		invalid |= save_cache_validity &amp; (NFS_INO_INVALID_ATTR
 				| NFS_INO_INVALID_ACCESS
 				| NFS_INO_INVALID_ACL
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_GROUP) {
 		if (inode-&gt;i_gid != fattr-&gt;gid) {
 			invalid |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL;
 			inode-&gt;i_gid = fattr-&gt;gid;
 		}
<span class="p_del">-	} else if (server-&gt;caps &amp; NFS_CAP_OWNER_GROUP)</span>
<span class="p_add">+	} else if (server-&gt;caps &amp; NFS_CAP_OWNER_GROUP) {</span>
 		invalid |= save_cache_validity &amp; (NFS_INO_INVALID_ATTR
 				| NFS_INO_INVALID_ACCESS
 				| NFS_INO_INVALID_ACL
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_NLINK) {
 		if (inode-&gt;i_nlink != fattr-&gt;nlink) {
<span class="p_chunk">@@ -1363,18 +1380,21 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 				invalid |= NFS_INO_INVALID_DATA;
 			set_nlink(inode, fattr-&gt;nlink);
 		}
<span class="p_del">-	} else if (server-&gt;caps &amp; NFS_CAP_NLINK)</span>
<span class="p_add">+	} else if (server-&gt;caps &amp; NFS_CAP_NLINK) {</span>
 		invalid |= save_cache_validity &amp; (NFS_INO_INVALID_ATTR
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_SPACE_USED) {
 		/*
 		 * report the blocks in 512byte units
 		 */
 		inode-&gt;i_blocks = nfs_calc_block_size(fattr-&gt;du.nfs3.used);
<span class="p_del">- 	}</span>
<span class="p_del">-	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_BLOCKS_USED)</span>
<span class="p_add">+	} else if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_BLOCKS_USED)</span>
 		inode-&gt;i_blocks = fattr-&gt;du.nfs2.blocks;
<span class="p_add">+	else</span>
<span class="p_add">+		cache_revalidated = false;</span>
 
 	/* Update attrtimeo value if we&#39;re out of the unstable period */
 	if (invalid &amp; NFS_INO_INVALID_ATTR) {
<span class="p_chunk">@@ -1383,15 +1403,19 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 		nfsi-&gt;attrtimeo_timestamp = now;
 		nfsi-&gt;attr_gencount = nfs_inc_attr_generation_counter();
 	} else {
<span class="p_del">-		if (!time_in_range_open(now, nfsi-&gt;attrtimeo_timestamp, nfsi-&gt;attrtimeo_timestamp + nfsi-&gt;attrtimeo)) {</span>
<span class="p_del">-			if ((nfsi-&gt;attrtimeo &lt;&lt;= 1) &gt; NFS_MAXATTRTIMEO(inode))</span>
<span class="p_del">-				nfsi-&gt;attrtimeo = NFS_MAXATTRTIMEO(inode);</span>
<span class="p_add">+		if (cache_revalidated) {</span>
<span class="p_add">+			if (!time_in_range_open(now, nfsi-&gt;attrtimeo_timestamp,</span>
<span class="p_add">+				nfsi-&gt;attrtimeo_timestamp + nfsi-&gt;attrtimeo)) {</span>
<span class="p_add">+				nfsi-&gt;attrtimeo &lt;&lt;= 1;</span>
<span class="p_add">+				if (nfsi-&gt;attrtimeo &gt; NFS_MAXATTRTIMEO(inode))</span>
<span class="p_add">+					nfsi-&gt;attrtimeo = NFS_MAXATTRTIMEO(inode);</span>
<span class="p_add">+			}</span>
 			nfsi-&gt;attrtimeo_timestamp = now;
 		}
 	}
 
 	/* Don&#39;t declare attrcache up to date if there were no attrs! */
<span class="p_del">-	if (fattr-&gt;valid != 0)</span>
<span class="p_add">+	if (cache_revalidated)</span>
 		invalid &amp;= ~NFS_INO_INVALID_ATTR;
 
 	/* Don&#39;t invalidate the data if we were to blame */
<span class="p_header">diff --git a/fs/ocfs2/dlm/dlmmaster.c b/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_header">index 8e48ba5f6549..709fb7ad8c6d 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_chunk">@@ -2459,6 +2459,11 @@</span> <span class="p_context"> static int dlm_migrate_lockres(struct dlm_ctxt *dlm,</span>
 	spin_lock(&amp;dlm-&gt;master_lock);
 	ret = dlm_add_migration_mle(dlm, res, mle, &amp;oldmle, name,
 				    namelen, target, dlm-&gt;node_num);
<span class="p_add">+	/* get an extra reference on the mle.</span>
<span class="p_add">+	 * otherwise the assert_master from the new</span>
<span class="p_add">+	 * master will destroy this.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	dlm_get_mle_inuse(mle);</span>
 	spin_unlock(&amp;dlm-&gt;master_lock);
 	spin_unlock(&amp;dlm-&gt;spinlock);
 
<span class="p_chunk">@@ -2494,6 +2499,7 @@</span> <span class="p_context"> fail:</span>
 		if (mle_added) {
 			dlm_mle_detach_hb_events(dlm, mle);
 			dlm_put_mle(mle);
<span class="p_add">+			dlm_put_mle_inuse(mle);</span>
 		} else if (mle) {
 			kmem_cache_free(dlm_mle_cache, mle);
 			mle = NULL;
<span class="p_chunk">@@ -2511,17 +2517,6 @@</span> <span class="p_context"> fail:</span>
 	 * ensure that all assert_master work is flushed. */
 	flush_workqueue(dlm-&gt;dlm_worker);
 
<span class="p_del">-	/* get an extra reference on the mle.</span>
<span class="p_del">-	 * otherwise the assert_master from the new</span>
<span class="p_del">-	 * master will destroy this.</span>
<span class="p_del">-	 * also, make sure that all callers of dlm_get_mle</span>
<span class="p_del">-	 * take both dlm-&gt;spinlock and dlm-&gt;master_lock */</span>
<span class="p_del">-	spin_lock(&amp;dlm-&gt;spinlock);</span>
<span class="p_del">-	spin_lock(&amp;dlm-&gt;master_lock);</span>
<span class="p_del">-	dlm_get_mle_inuse(mle);</span>
<span class="p_del">-	spin_unlock(&amp;dlm-&gt;master_lock);</span>
<span class="p_del">-	spin_unlock(&amp;dlm-&gt;spinlock);</span>
<span class="p_del">-</span>
 	/* notify new node and send all lock state */
 	/* call send_one_lockres with migration flag.
 	 * this serves as notice to the target node that a
<span class="p_chunk">@@ -3249,6 +3244,15 @@</span> <span class="p_context"> top:</span>
 			    mle-&gt;new_master != dead_node)
 				continue;
 
<span class="p_add">+			if (mle-&gt;new_master == dead_node &amp;&amp; mle-&gt;inuse) {</span>
<span class="p_add">+				mlog(ML_NOTICE, &quot;%s: target %u died during &quot;</span>
<span class="p_add">+						&quot;migration from %u, the MLE is &quot;</span>
<span class="p_add">+						&quot;still keep used, ignore it!\n&quot;,</span>
<span class="p_add">+						dlm-&gt;name, dead_node,</span>
<span class="p_add">+						mle-&gt;master);</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			/* If we have reached this point, this mle needs to be
 			 * removed from the list and freed. */
 			dlm_clean_migration_mle(dlm, mle);
<span class="p_header">diff --git a/fs/ocfs2/dlmglue.c b/fs/ocfs2/dlmglue.c</span>
<span class="p_header">index b5e457ccfed2..6465317e47a6 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlmglue.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlmglue.c</span>
<span class="p_chunk">@@ -1373,6 +1373,7 @@</span> <span class="p_context"> static int __ocfs2_cluster_lock(struct ocfs2_super *osb,</span>
 	unsigned long flags;
 	unsigned int gen;
 	int noqueue_attempted = 0;
<span class="p_add">+	int kick_dc = 0;</span>
 
 	ocfs2_init_mask_waiter(&amp;mw);
 
<span class="p_chunk">@@ -1501,7 +1502,12 @@</span> <span class="p_context"> update_holders:</span>
 unlock:
 	lockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);
 
<span class="p_add">+	/* ocfs2_unblock_lock reques on seeing OCFS2_LOCK_UPCONVERT_FINISHING */</span>
<span class="p_add">+	kick_dc = (lockres-&gt;l_flags &amp; OCFS2_LOCK_BLOCKED);</span>
<span class="p_add">+</span>
 	spin_unlock_irqrestore(&amp;lockres-&gt;l_lock, flags);
<span class="p_add">+	if (kick_dc)</span>
<span class="p_add">+		ocfs2_wake_downconvert_thread(osb);</span>
 out:
 	/*
 	 * This is helping work around a lock inversion between the page lock
<span class="p_header">diff --git a/fs/udf/inode.c b/fs/udf/inode.c</span>
<span class="p_header">index e0814407652a..5d67e2023311 100644</span>
<span class="p_header">--- a/fs/udf/inode.c</span>
<span class="p_header">+++ b/fs/udf/inode.c</span>
<span class="p_chunk">@@ -1975,14 +1975,29 @@</span> <span class="p_context"> void udf_write_aext(struct inode *inode, struct extent_position *epos,</span>
 		epos-&gt;offset += adsize;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Only 1 indirect extent in a row really makes sense but allow upto 16 in case</span>
<span class="p_add">+ * someone does some weird stuff.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define UDF_MAX_INDIR_EXTS 16</span>
<span class="p_add">+</span>
 int8_t udf_next_aext(struct inode *inode, struct extent_position *epos,
 		     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)
 {
 	int8_t etype;
<span class="p_add">+	unsigned int indirections = 0;</span>
 
 	while ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==
 	       (EXT_NEXT_EXTENT_ALLOCDECS &gt;&gt; 30)) {
 		int block;
<span class="p_add">+</span>
<span class="p_add">+		if (++indirections &gt; UDF_MAX_INDIR_EXTS) {</span>
<span class="p_add">+			udf_err(inode-&gt;i_sb,</span>
<span class="p_add">+				&quot;too many indirect extents in inode %lu\n&quot;,</span>
<span class="p_add">+				inode-&gt;i_ino);</span>
<span class="p_add">+			return -1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		epos-&gt;block = *eloc;
 		epos-&gt;offset = sizeof(struct allocExtDesc);
 		brelse(epos-&gt;bh);
<span class="p_header">diff --git a/fs/udf/unicode.c b/fs/udf/unicode.c</span>
<span class="p_header">index d29c06fbf4ce..52330cb09daf 100644</span>
<span class="p_header">--- a/fs/udf/unicode.c</span>
<span class="p_header">+++ b/fs/udf/unicode.c</span>
<span class="p_chunk">@@ -133,11 +133,15 @@</span> <span class="p_context"> int udf_CS0toUTF8(struct ustr *utf_o, const struct ustr *ocu_i)</span>
 		if (c &lt; 0x80U)
 			utf_o-&gt;u_name[utf_o-&gt;u_len++] = (uint8_t)c;
 		else if (c &lt; 0x800U) {
<span class="p_add">+			if (utf_o-&gt;u_len &gt; (UDF_NAME_LEN - 4))</span>
<span class="p_add">+				break;</span>
 			utf_o-&gt;u_name[utf_o-&gt;u_len++] =
 						(uint8_t)(0xc0 | (c &gt;&gt; 6));
 			utf_o-&gt;u_name[utf_o-&gt;u_len++] =
 						(uint8_t)(0x80 | (c &amp; 0x3f));
 		} else {
<span class="p_add">+			if (utf_o-&gt;u_len &gt; (UDF_NAME_LEN - 5))</span>
<span class="p_add">+				break;</span>
 			utf_o-&gt;u_name[utf_o-&gt;u_len++] =
 						(uint8_t)(0xe0 | (c &gt;&gt; 12));
 			utf_o-&gt;u_name[utf_o-&gt;u_len++] =
<span class="p_chunk">@@ -178,17 +182,22 @@</span> <span class="p_context"> int udf_CS0toUTF8(struct ustr *utf_o, const struct ustr *ocu_i)</span>
 static int udf_UTF8toCS0(dstring *ocu, struct ustr *utf, int length)
 {
 	unsigned c, i, max_val, utf_char;
<span class="p_del">-	int utf_cnt, u_len;</span>
<span class="p_add">+	int utf_cnt, u_len, u_ch;</span>
 
 	memset(ocu, 0, sizeof(dstring) * length);
 	ocu[0] = 8;
 	max_val = 0xffU;
<span class="p_add">+	u_ch = 1;</span>
 
 try_again:
 	u_len = 0U;
 	utf_char = 0U;
 	utf_cnt = 0U;
 	for (i = 0U; i &lt; utf-&gt;u_len; i++) {
<span class="p_add">+		/* Name didn&#39;t fit? */</span>
<span class="p_add">+		if (u_len + 1 + u_ch &gt;= length)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
 		c = (uint8_t)utf-&gt;u_name[i];
 
 		/* Complete a multi-byte UTF-8 character */
<span class="p_chunk">@@ -230,6 +239,7 @@</span> <span class="p_context"> try_again:</span>
 			if (max_val == 0xffU) {
 				max_val = 0xffffU;
 				ocu[0] = (uint8_t)0x10U;
<span class="p_add">+				u_ch = 2;</span>
 				goto try_again;
 			}
 			goto error_out;
<span class="p_chunk">@@ -282,7 +292,7 @@</span> <span class="p_context"> static int udf_CS0toNLS(struct nls_table *nls, struct ustr *utf_o,</span>
 			c = (c &lt;&lt; 8) | ocu[i++];
 
 		len = nls-&gt;uni2char(c, &amp;utf_o-&gt;u_name[utf_o-&gt;u_len],
<span class="p_del">-				    UDF_NAME_LEN - utf_o-&gt;u_len);</span>
<span class="p_add">+				    UDF_NAME_LEN - 2 - utf_o-&gt;u_len);</span>
 		/* Valid character? */
 		if (len &gt;= 0)
 			utf_o-&gt;u_len += len;
<span class="p_chunk">@@ -300,15 +310,19 @@</span> <span class="p_context"> static int udf_NLStoCS0(struct nls_table *nls, dstring *ocu, struct ustr *uni,</span>
 	int len;
 	unsigned i, max_val;
 	uint16_t uni_char;
<span class="p_del">-	int u_len;</span>
<span class="p_add">+	int u_len, u_ch;</span>
 
 	memset(ocu, 0, sizeof(dstring) * length);
 	ocu[0] = 8;
 	max_val = 0xffU;
<span class="p_add">+	u_ch = 1;</span>
 
 try_again:
 	u_len = 0U;
 	for (i = 0U; i &lt; uni-&gt;u_len; i++) {
<span class="p_add">+		/* Name didn&#39;t fit? */</span>
<span class="p_add">+		if (u_len + 1 + u_ch &gt;= length)</span>
<span class="p_add">+			return 0;</span>
 		len = nls-&gt;char2uni(&amp;uni-&gt;u_name[i], uni-&gt;u_len - i, &amp;uni_char);
 		if (!len)
 			continue;
<span class="p_chunk">@@ -321,6 +335,7 @@</span> <span class="p_context"> try_again:</span>
 		if (uni_char &gt; max_val) {
 			max_val = 0xffffU;
 			ocu[0] = (uint8_t)0x10U;
<span class="p_add">+			u_ch = 2;</span>
 			goto try_again;
 		}
 
<span class="p_header">diff --git a/include/crypto/hash.h b/include/crypto/hash.h</span>
<span class="p_header">index 26cb1eb16f4c..c8c79878c082 100644</span>
<span class="p_header">--- a/include/crypto/hash.h</span>
<span class="p_header">+++ b/include/crypto/hash.h</span>
<span class="p_chunk">@@ -94,6 +94,7 @@</span> <span class="p_context"> struct crypto_ahash {</span>
 		      unsigned int keylen);
 
 	unsigned int reqsize;
<span class="p_add">+	bool has_setkey;</span>
 	struct crypto_tfm base;
 };
 
<span class="p_chunk">@@ -181,6 +182,11 @@</span> <span class="p_context"> static inline void *ahash_request_ctx(struct ahash_request *req)</span>
 
 int crypto_ahash_setkey(struct crypto_ahash *tfm, const u8 *key,
 			unsigned int keylen);
<span class="p_add">+static inline bool crypto_ahash_has_setkey(struct crypto_ahash *tfm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return tfm-&gt;has_setkey;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int crypto_ahash_finup(struct ahash_request *req);
 int crypto_ahash_final(struct ahash_request *req);
 int crypto_ahash_digest(struct ahash_request *req);
<span class="p_header">diff --git a/include/crypto/if_alg.h b/include/crypto/if_alg.h</span>
<span class="p_header">index d61c11170213..bfefd8139e18 100644</span>
<span class="p_header">--- a/include/crypto/if_alg.h</span>
<span class="p_header">+++ b/include/crypto/if_alg.h</span>
<span class="p_chunk">@@ -30,6 +30,9 @@</span> <span class="p_context"> struct alg_sock {</span>
 
 	struct sock *parent;
 
<span class="p_add">+	unsigned int refcnt;</span>
<span class="p_add">+	unsigned int nokey_refcnt;</span>
<span class="p_add">+</span>
 	const struct af_alg_type *type;
 	void *private;
 };
<span class="p_chunk">@@ -49,8 +52,10 @@</span> <span class="p_context"> struct af_alg_type {</span>
 	void (*release)(void *private);
 	int (*setkey)(void *private, const u8 *key, unsigned int keylen);
 	int (*accept)(void *private, struct sock *sk);
<span class="p_add">+	int (*accept_nokey)(void *private, struct sock *sk);</span>
 
 	struct proto_ops *ops;
<span class="p_add">+	struct proto_ops *ops_nokey;</span>
 	struct module *owner;
 	char name[14];
 };
<span class="p_chunk">@@ -64,6 +69,7 @@</span> <span class="p_context"> int af_alg_register_type(const struct af_alg_type *type);</span>
 int af_alg_unregister_type(const struct af_alg_type *type);
 
 int af_alg_release(struct socket *sock);
<span class="p_add">+void af_alg_release_parent(struct sock *sk);</span>
 int af_alg_accept(struct sock *sk, struct socket *newsock);
 
 int af_alg_make_sg(struct af_alg_sgl *sgl, void __user *addr, int len,
<span class="p_chunk">@@ -80,11 +86,6 @@</span> <span class="p_context"> static inline struct alg_sock *alg_sk(struct sock *sk)</span>
 	return (struct alg_sock *)sk;
 }
 
<span class="p_del">-static inline void af_alg_release_parent(struct sock *sk)</span>
<span class="p_del">-{</span>
<span class="p_del">-	sock_put(alg_sk(sk)-&gt;parent);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline void af_alg_init_completion(struct af_alg_completion *completion)
 {
 	init_completion(&amp;completion-&gt;completion);
<span class="p_header">diff --git a/include/linux/crypto.h b/include/linux/crypto.h</span>
<span class="p_header">index ca01ea899114..6f501deccf41 100644</span>
<span class="p_header">--- a/include/linux/crypto.h</span>
<span class="p_header">+++ b/include/linux/crypto.h</span>
<span class="p_chunk">@@ -346,6 +346,7 @@</span> <span class="p_context"> struct ablkcipher_tfm {</span>
 
 	unsigned int ivsize;
 	unsigned int reqsize;
<span class="p_add">+	bool has_setkey;</span>
 };
 
 struct aead_tfm {
<span class="p_chunk">@@ -656,6 +657,13 @@</span> <span class="p_context"> static inline int crypto_ablkcipher_setkey(struct crypto_ablkcipher *tfm,</span>
 	return crt-&gt;setkey(crt-&gt;base, key, keylen);
 }
 
<span class="p_add">+static inline bool crypto_ablkcipher_has_setkey(struct crypto_ablkcipher *tfm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ablkcipher_tfm *crt = crypto_ablkcipher_crt(tfm);</span>
<span class="p_add">+</span>
<span class="p_add">+	return crt-&gt;has_setkey;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline struct crypto_ablkcipher *crypto_ablkcipher_reqtfm(
 	struct ablkcipher_request *req)
 {
<span class="p_header">diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h</span>
<span class="p_header">index b25b09b1ea00..0c4f0ddc8267 100644</span>
<span class="p_header">--- a/include/linux/mtd/nand.h</span>
<span class="p_header">+++ b/include/linux/mtd/nand.h</span>
<span class="p_chunk">@@ -283,7 +283,7 @@</span> <span class="p_context"> struct nand_onfi_params {</span>
 	__le16 t_r;
 	__le16 t_ccs;
 	__le16 src_sync_timing_mode;
<span class="p_del">-	__le16 src_ssync_features;</span>
<span class="p_add">+	u8 src_ssync_features;</span>
 	__le16 clk_pin_capacitance_typ;
 	__le16 io_pin_capacitance_typ;
 	__le16 input_pin_capacitance_typ;
<span class="p_chunk">@@ -291,7 +291,7 @@</span> <span class="p_context"> struct nand_onfi_params {</span>
 	u8 driver_strenght_support;
 	__le16 t_int_r;
 	__le16 t_ald;
<span class="p_del">-	u8 reserved4[7];</span>
<span class="p_add">+	u8 reserved4[8];</span>
 
 	/* vendor */
 	u8 reserved5[90];
<span class="p_header">diff --git a/include/linux/printk.h b/include/linux/printk.h</span>
<span class="p_header">index f0e22f75143f..13abc065e718 100644</span>
<span class="p_header">--- a/include/linux/printk.h</span>
<span class="p_header">+++ b/include/linux/printk.h</span>
<span class="p_chunk">@@ -80,13 +80,13 @@</span> <span class="p_context"> struct va_format {</span>
 
 /*
  * Dummy printk for disabled debugging statements to use whilst maintaining
<span class="p_del">- * gcc&#39;s format and side-effect checking.</span>
<span class="p_add">+ * gcc&#39;s format checking.</span>
  */
<span class="p_del">-static inline __printf(1, 2)</span>
<span class="p_del">-int no_printk(const char *fmt, ...)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_add">+#define no_printk(fmt, ...)			\</span>
<span class="p_add">+do {						\</span>
<span class="p_add">+	if (0)					\</span>
<span class="p_add">+		printk(fmt, ##__VA_ARGS__);	\</span>
<span class="p_add">+} while (0)</span>
 
 extern asmlinkage __printf(1, 2)
 void early_printk(const char *fmt, ...);
<span class="p_header">diff --git a/kernel/futex.c b/kernel/futex.c</span>
<span class="p_header">index 74815953f54c..9dc2c7192b2e 100644</span>
<span class="p_header">--- a/kernel/futex.c</span>
<span class="p_header">+++ b/kernel/futex.c</span>
<span class="p_chunk">@@ -2492,6 +2492,11 @@</span> <span class="p_context"> static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,</span>
 		if (q.pi_state &amp;&amp; (q.pi_state-&gt;owner != current)) {
 			spin_lock(q.lock_ptr);
 			ret = fixup_pi_state_owner(uaddr2, &amp;q, current);
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Drop the reference to the pi state which</span>
<span class="p_add">+			 * the requeue_pi() code acquired for us.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			free_pi_state(q.pi_state);</span>
 			spin_unlock(q.lock_ptr);
 		}
 	} else {
<span class="p_header">diff --git a/kernel/time/posix-clock.c b/kernel/time/posix-clock.c</span>
<span class="p_header">index ce033c7aa2e8..9cff0ab82b63 100644</span>
<span class="p_header">--- a/kernel/time/posix-clock.c</span>
<span class="p_header">+++ b/kernel/time/posix-clock.c</span>
<span class="p_chunk">@@ -69,10 +69,10 @@</span> <span class="p_context"> static ssize_t posix_clock_read(struct file *fp, char __user *buf,</span>
 static unsigned int posix_clock_poll(struct file *fp, poll_table *wait)
 {
 	struct posix_clock *clk = get_posix_clock(fp);
<span class="p_del">-	int result = 0;</span>
<span class="p_add">+	unsigned int result = 0;</span>
 
 	if (!clk)
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+		return POLLERR;</span>
 
 	if (clk-&gt;ops.poll)
 		result = clk-&gt;ops.poll(clk, fp, wait);
<span class="p_header">diff --git a/lib/dma-debug.c b/lib/dma-debug.c</span>
<span class="p_header">index fea790a2b176..551ff7282dad 100644</span>
<span class="p_header">--- a/lib/dma-debug.c</span>
<span class="p_header">+++ b/lib/dma-debug.c</span>
<span class="p_chunk">@@ -942,7 +942,7 @@</span> <span class="p_context"> static inline bool overlap(void *addr, unsigned long len, void *start, void *end</span>
 
 static void check_for_illegal_area(struct device *dev, void *addr, unsigned long len)
 {
<span class="p_del">-	if (overlap(addr, len, _text, _etext) ||</span>
<span class="p_add">+	if (overlap(addr, len, _stext, _etext) ||</span>
 	    overlap(addr, len, __start_rodata, __end_rodata))
 		err_printk(dev, NULL, &quot;DMA-API: device driver maps memory from kernel text or rodata [addr=%p] [len=%lu]\n&quot;, addr, len);
 }
<span class="p_header">diff --git a/mm/memcontrol.c b/mm/memcontrol.c</span>
<span class="p_header">index 204de6ab6292..9ba67dd6db34 100644</span>
<span class="p_header">--- a/mm/memcontrol.c</span>
<span class="p_header">+++ b/mm/memcontrol.c</span>
<span class="p_chunk">@@ -4564,16 +4564,17 @@</span> <span class="p_context"> static void mem_cgroup_usage_unregister_event(struct cgroup *cgrp,</span>
 swap_buffers:
 	/* Swap primary and spare array */
 	thresholds-&gt;spare = thresholds-&gt;primary;
<span class="p_del">-	/* If all events are unregistered, free the spare array */</span>
<span class="p_del">-	if (!new) {</span>
<span class="p_del">-		kfree(thresholds-&gt;spare);</span>
<span class="p_del">-		thresholds-&gt;spare = NULL;</span>
<span class="p_del">-	}</span>
 
 	rcu_assign_pointer(thresholds-&gt;primary, new);
 
 	/* To be sure that nobody uses thresholds */
 	synchronize_rcu();
<span class="p_add">+</span>
<span class="p_add">+	/* If all events are unregistered, free the spare array */</span>
<span class="p_add">+	if (!new) {</span>
<span class="p_add">+		kfree(thresholds-&gt;spare);</span>
<span class="p_add">+		thresholds-&gt;spare = NULL;</span>
<span class="p_add">+	}</span>
 unlock:
 	mutex_unlock(&amp;memcg-&gt;thresholds_lock);
 }
<span class="p_header">diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">index 01706792f282..b20f7a08b4f7 100644</span>
<span class="p_header">--- a/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">+++ b/net/ipv6/tcp_ipv6.c</span>
<span class="p_chunk">@@ -513,8 +513,10 @@</span> <span class="p_context"> static int tcp_v6_send_synack(struct sock *sk, struct request_sock *req,</span>
 		__tcp_v6_send_check(skb, &amp;treq-&gt;loc_addr, &amp;treq-&gt;rmt_addr);
 
 		ipv6_addr_copy(&amp;fl6.daddr, &amp;treq-&gt;rmt_addr);
<span class="p_add">+		rcu_read_lock();</span>
 		err = ip6_xmit(sk, skb, &amp;fl6, rcu_dereference(np-&gt;opt),
 			       np-&gt;tclass);
<span class="p_add">+		rcu_read_unlock();</span>
 		err = net_xmit_eval(err);
 	}
 
<span class="p_header">diff --git a/net/sctp/sm_sideeffect.c b/net/sctp/sm_sideeffect.c</span>
<span class="p_header">index 581c06a04067..5437b33fd33e 100644</span>
<span class="p_header">--- a/net/sctp/sm_sideeffect.c</span>
<span class="p_header">+++ b/net/sctp/sm_sideeffect.c</span>
<span class="p_chunk">@@ -249,11 +249,12 @@</span> <span class="p_context"> void sctp_generate_t3_rtx_event(unsigned long peer)</span>
 	int error;
 	struct sctp_transport *transport = (struct sctp_transport *) peer;
 	struct sctp_association *asoc = transport-&gt;asoc;
<span class="p_add">+	struct sock *sk = asoc-&gt;base.sk;</span>
 
 	/* Check whether a task is in the sock.  */
 
<span class="p_del">-	sctp_bh_lock_sock(asoc-&gt;base.sk);</span>
<span class="p_del">-	if (sock_owned_by_user(asoc-&gt;base.sk)) {</span>
<span class="p_add">+	sctp_bh_lock_sock(sk);</span>
<span class="p_add">+	if (sock_owned_by_user(sk)) {</span>
 		SCTP_DEBUG_PRINTK(&quot;%s:Sock is busy.\n&quot;, __func__);
 
 		/* Try again later.  */
<span class="p_chunk">@@ -276,10 +277,10 @@</span> <span class="p_context"> void sctp_generate_t3_rtx_event(unsigned long peer)</span>
 			   transport, GFP_ATOMIC);
 
 	if (error)
<span class="p_del">-		asoc-&gt;base.sk-&gt;sk_err = -error;</span>
<span class="p_add">+		sk-&gt;sk_err = -error;</span>
 
 out_unlock:
<span class="p_del">-	sctp_bh_unlock_sock(asoc-&gt;base.sk);</span>
<span class="p_add">+	sctp_bh_unlock_sock(sk);</span>
 	sctp_transport_put(transport);
 }
 
<span class="p_chunk">@@ -289,10 +290,11 @@</span> <span class="p_context"> out_unlock:</span>
 static void sctp_generate_timeout_event(struct sctp_association *asoc,
 					sctp_event_timeout_t timeout_type)
 {
<span class="p_add">+	struct sock *sk = asoc-&gt;base.sk;</span>
 	int error = 0;
 
<span class="p_del">-	sctp_bh_lock_sock(asoc-&gt;base.sk);</span>
<span class="p_del">-	if (sock_owned_by_user(asoc-&gt;base.sk)) {</span>
<span class="p_add">+	sctp_bh_lock_sock(sk);</span>
<span class="p_add">+	if (sock_owned_by_user(sk)) {</span>
 		SCTP_DEBUG_PRINTK(&quot;%s:Sock is busy: timer %d\n&quot;,
 				  __func__,
 				  timeout_type);
<span class="p_chunk">@@ -316,10 +318,10 @@</span> <span class="p_context"> static void sctp_generate_timeout_event(struct sctp_association *asoc,</span>
 			   (void *)timeout_type, GFP_ATOMIC);
 
 	if (error)
<span class="p_del">-		asoc-&gt;base.sk-&gt;sk_err = -error;</span>
<span class="p_add">+		sk-&gt;sk_err = -error;</span>
 
 out_unlock:
<span class="p_del">-	sctp_bh_unlock_sock(asoc-&gt;base.sk);</span>
<span class="p_add">+	sctp_bh_unlock_sock(sk);</span>
 	sctp_association_put(asoc);
 }
 
<span class="p_chunk">@@ -369,9 +371,10 @@</span> <span class="p_context"> void sctp_generate_heartbeat_event(unsigned long data)</span>
 	int error = 0;
 	struct sctp_transport *transport = (struct sctp_transport *) data;
 	struct sctp_association *asoc = transport-&gt;asoc;
<span class="p_add">+	struct sock *sk = asoc-&gt;base.sk;</span>
 
<span class="p_del">-	sctp_bh_lock_sock(asoc-&gt;base.sk);</span>
<span class="p_del">-	if (sock_owned_by_user(asoc-&gt;base.sk)) {</span>
<span class="p_add">+	sctp_bh_lock_sock(sk);</span>
<span class="p_add">+	if (sock_owned_by_user(sk)) {</span>
 		SCTP_DEBUG_PRINTK(&quot;%s:Sock is busy.\n&quot;, __func__);
 
 		/* Try again later.  */
<span class="p_chunk">@@ -392,10 +395,10 @@</span> <span class="p_context"> void sctp_generate_heartbeat_event(unsigned long data)</span>
 			   transport, GFP_ATOMIC);
 
 	 if (error)
<span class="p_del">-		 asoc-&gt;base.sk-&gt;sk_err = -error;</span>
<span class="p_add">+		sk-&gt;sk_err = -error;</span>
 
 out_unlock:
<span class="p_del">-	sctp_bh_unlock_sock(asoc-&gt;base.sk);</span>
<span class="p_add">+	sctp_bh_unlock_sock(sk);</span>
 	sctp_transport_put(transport);
 }
 
<span class="p_chunk">@@ -406,9 +409,10 @@</span> <span class="p_context"> void sctp_generate_proto_unreach_event(unsigned long data)</span>
 {
 	struct sctp_transport *transport = (struct sctp_transport *) data;
 	struct sctp_association *asoc = transport-&gt;asoc;
<span class="p_add">+	struct sock *sk = asoc-&gt;base.sk;</span>
 	
<span class="p_del">-	sctp_bh_lock_sock(asoc-&gt;base.sk);</span>
<span class="p_del">-	if (sock_owned_by_user(asoc-&gt;base.sk)) {</span>
<span class="p_add">+	sctp_bh_lock_sock(sk);</span>
<span class="p_add">+	if (sock_owned_by_user(sk)) {</span>
 		SCTP_DEBUG_PRINTK(&quot;%s:Sock is busy.\n&quot;, __func__);
 
 		/* Try again later.  */
<span class="p_chunk">@@ -429,7 +433,7 @@</span> <span class="p_context"> void sctp_generate_proto_unreach_event(unsigned long data)</span>
 		   asoc-&gt;state, asoc-&gt;ep, asoc, transport, GFP_ATOMIC);
 
 out_unlock:
<span class="p_del">-	sctp_bh_unlock_sock(asoc-&gt;base.sk);</span>
<span class="p_add">+	sctp_bh_unlock_sock(sk);</span>
 	sctp_association_put(asoc);
 }
 
<span class="p_header">diff --git a/scripts/bloat-o-meter b/scripts/bloat-o-meter</span>
<span class="p_header">index 6129020c41a9..81228a443122 100755</span>
<span class="p_header">--- a/scripts/bloat-o-meter</span>
<span class="p_header">+++ b/scripts/bloat-o-meter</span>
<span class="p_chunk">@@ -55,8 +55,8 @@</span> <span class="p_context"> for name in common:</span>
 delta.sort()
 delta.reverse()
 
<span class="p_del">-print &quot;add/remove: %s/%s grow/shrink: %s/%s up/down: %s/%s (%s)&quot; % \</span>
<span class="p_del">-      (add, remove, grow, shrink, up, -down, up-down)</span>
<span class="p_del">-print &quot;%-40s %7s %7s %+7s&quot; % (&quot;function&quot;, &quot;old&quot;, &quot;new&quot;, &quot;delta&quot;)</span>
<span class="p_add">+print(&quot;add/remove: %s/%s grow/shrink: %s/%s up/down: %s/%s (%s)&quot; % \</span>
<span class="p_add">+      (add, remove, grow, shrink, up, -down, up-down))</span>
<span class="p_add">+print(&quot;%-40s %7s %7s %+7s&quot; % (&quot;function&quot;, &quot;old&quot;, &quot;new&quot;, &quot;delta&quot;))</span>
 for d, n in delta:
<span class="p_del">-    if d: print &quot;%-40s %7s %7s %+7d&quot; % (n, old.get(n,&quot;-&quot;), new.get(n,&quot;-&quot;), d)</span>
<span class="p_add">+    if d: print(&quot;%-40s %7s %7s %+7d&quot; % (n, old.get(n,&quot;-&quot;), new.get(n,&quot;-&quot;), d))</span>
<span class="p_header">diff --git a/sound/core/control.c b/sound/core/control.c</span>
<span class="p_header">index 1ba5d339acd3..96c62e58d950 100644</span>
<span class="p_header">--- a/sound/core/control.c</span>
<span class="p_header">+++ b/sound/core/control.c</span>
<span class="p_chunk">@@ -1321,6 +1321,8 @@</span> <span class="p_context"> static int snd_ctl_tlv_ioctl(struct snd_ctl_file *file,</span>
 		return -EFAULT;
 	if (tlv.length &lt; sizeof(unsigned int) * 2)
 		return -EINVAL;
<span class="p_add">+	if (!tlv.numid)</span>
<span class="p_add">+		return -EINVAL;</span>
 	down_read(&amp;card-&gt;controls_rwsem);
 	kctl = snd_ctl_find_numid(card, tlv.numid);
 	if (kctl == NULL) {
<span class="p_header">diff --git a/sound/core/hrtimer.c b/sound/core/hrtimer.c</span>
<span class="p_header">index b8b31c433d64..14d483d6b3b0 100644</span>
<span class="p_header">--- a/sound/core/hrtimer.c</span>
<span class="p_header">+++ b/sound/core/hrtimer.c</span>
<span class="p_chunk">@@ -90,7 +90,7 @@</span> <span class="p_context"> static int snd_hrtimer_start(struct snd_timer *t)</span>
 	struct snd_hrtimer *stime = t-&gt;private_data;
 
 	atomic_set(&amp;stime-&gt;running, 0);
<span class="p_del">-	hrtimer_cancel(&amp;stime-&gt;hrt);</span>
<span class="p_add">+	hrtimer_try_to_cancel(&amp;stime-&gt;hrt);</span>
 	hrtimer_start(&amp;stime-&gt;hrt, ns_to_ktime(t-&gt;sticks * resolution),
 		      HRTIMER_MODE_REL);
 	atomic_set(&amp;stime-&gt;running, 1);
<span class="p_chunk">@@ -101,6 +101,7 @@</span> <span class="p_context"> static int snd_hrtimer_stop(struct snd_timer *t)</span>
 {
 	struct snd_hrtimer *stime = t-&gt;private_data;
 	atomic_set(&amp;stime-&gt;running, 0);
<span class="p_add">+	hrtimer_try_to_cancel(&amp;stime-&gt;hrt);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/sound/core/pcm_compat.c b/sound/core/pcm_compat.c</span>
<span class="p_header">index 4dbb66ef435d..ceada096e22a 100644</span>
<span class="p_header">--- a/sound/core/pcm_compat.c</span>
<span class="p_header">+++ b/sound/core/pcm_compat.c</span>
<span class="p_chunk">@@ -235,10 +235,15 @@</span> <span class="p_context"> static int snd_pcm_ioctl_hw_params_compat(struct snd_pcm_substream *substream,</span>
 	if (! (runtime = substream-&gt;runtime))
 		return -ENOTTY;
 
<span class="p_del">-	/* only fifo_size is different, so just copy all */</span>
<span class="p_del">-	data = memdup_user(data32, sizeof(*data32));</span>
<span class="p_del">-	if (IS_ERR(data))</span>
<span class="p_del">-		return PTR_ERR(data);</span>
<span class="p_add">+	data = kmalloc(sizeof(*data), GFP_KERNEL);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* only fifo_size (RO from userspace) is different, so just copy all */</span>
<span class="p_add">+	if (copy_from_user(data, data32, sizeof(*data32))) {</span>
<span class="p_add">+		err = -EFAULT;</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	}</span>
 
 	if (refine)
 		err = snd_pcm_hw_refine(substream, data);
<span class="p_header">diff --git a/sound/core/seq/seq_clientmgr.c b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">index 4dc6bae80e15..ecfbf5f39d38 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_chunk">@@ -1950,7 +1950,7 @@</span> <span class="p_context"> static int snd_seq_ioctl_remove_events(struct snd_seq_client *client,</span>
 		 * No restrictions so for a user client we can clear
 		 * the whole fifo
 		 */
<span class="p_del">-		if (client-&gt;type == USER_CLIENT)</span>
<span class="p_add">+		if (client-&gt;type == USER_CLIENT &amp;&amp; client-&gt;data.user.fifo)</span>
 			snd_seq_fifo_clear(client-&gt;data.user.fifo);
 	}
 
<span class="p_header">diff --git a/sound/core/seq/seq_compat.c b/sound/core/seq/seq_compat.c</span>
<span class="p_header">index 81f7c109dc46..65175902a68a 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_compat.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_compat.c</span>
<span class="p_chunk">@@ -49,11 +49,12 @@</span> <span class="p_context"> static int snd_seq_call_port_info_ioctl(struct snd_seq_client *client, unsigned</span>
 	struct snd_seq_port_info *data;
 	mm_segment_t fs;
 
<span class="p_del">-	data = memdup_user(data32, sizeof(*data32));</span>
<span class="p_del">-	if (IS_ERR(data))</span>
<span class="p_del">-		return PTR_ERR(data);</span>
<span class="p_add">+	data = kmalloc(sizeof(*data), GFP_KERNEL);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
<span class="p_del">-	if (get_user(data-&gt;flags, &amp;data32-&gt;flags) ||</span>
<span class="p_add">+	if (copy_from_user(data, data32, sizeof(*data32)) ||</span>
<span class="p_add">+	    get_user(data-&gt;flags, &amp;data32-&gt;flags) ||</span>
 	    get_user(data-&gt;time_queue, &amp;data32-&gt;time_queue))
 		goto error;
 	data-&gt;kernel = NULL;
<span class="p_header">diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c</span>
<span class="p_header">index f9077361c119..4c9aa462de9b 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_queue.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_queue.c</span>
<span class="p_chunk">@@ -144,8 +144,10 @@</span> <span class="p_context"> static struct snd_seq_queue *queue_new(int owner, int locked)</span>
 static void queue_delete(struct snd_seq_queue *q)
 {
 	/* stop and release the timer */
<span class="p_add">+	mutex_lock(&amp;q-&gt;timer_mutex);</span>
 	snd_seq_timer_stop(q-&gt;timer);
 	snd_seq_timer_close(q);
<span class="p_add">+	mutex_unlock(&amp;q-&gt;timer_mutex);</span>
 	/* wait until access free */
 	snd_use_lock_sync(&amp;q-&gt;use_lock);
 	/* release resources... */
<span class="p_header">diff --git a/sound/core/timer.c b/sound/core/timer.c</span>
<span class="p_header">index 8e7561dfc5fc..76bdfaccb8de 100644</span>
<span class="p_header">--- a/sound/core/timer.c</span>
<span class="p_header">+++ b/sound/core/timer.c</span>
<span class="p_chunk">@@ -72,7 +72,7 @@</span> <span class="p_context"> struct snd_timer_user {</span>
 	struct timespec tstamp;		/* trigger tstamp */
 	wait_queue_head_t qchange_sleep;
 	struct fasync_struct *fasync;
<span class="p_del">-	struct mutex tread_sem;</span>
<span class="p_add">+	struct mutex ioctl_lock;</span>
 };
 
 /* list of timers */
<span class="p_chunk">@@ -214,11 +214,13 @@</span> <span class="p_context"> static void snd_timer_check_master(struct snd_timer_instance *master)</span>
 		    slave-&gt;slave_id == master-&gt;slave_id) {
 			list_move_tail(&amp;slave-&gt;open_list, &amp;master-&gt;slave_list_head);
 			spin_lock_irq(&amp;slave_active_lock);
<span class="p_add">+			spin_lock(&amp;master-&gt;timer-&gt;lock);</span>
 			slave-&gt;master = master;
 			slave-&gt;timer = master-&gt;timer;
 			if (slave-&gt;flags &amp; SNDRV_TIMER_IFLG_RUNNING)
 				list_add_tail(&amp;slave-&gt;active_list,
 					      &amp;master-&gt;slave_active_head);
<span class="p_add">+			spin_unlock(&amp;master-&gt;timer-&gt;lock);</span>
 			spin_unlock_irq(&amp;slave_active_lock);
 		}
 	}
<span class="p_chunk">@@ -344,15 +346,18 @@</span> <span class="p_context"> int snd_timer_close(struct snd_timer_instance *timeri)</span>
 		    timer-&gt;hw.close)
 			timer-&gt;hw.close(timer);
 		/* remove slave links */
<span class="p_add">+		spin_lock_irq(&amp;slave_active_lock);</span>
<span class="p_add">+		spin_lock(&amp;timer-&gt;lock);</span>
 		list_for_each_entry_safe(slave, tmp, &amp;timeri-&gt;slave_list_head,
 					 open_list) {
<span class="p_del">-			spin_lock_irq(&amp;slave_active_lock);</span>
<span class="p_del">-			_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);</span>
 			list_move_tail(&amp;slave-&gt;open_list, &amp;snd_timer_slave_list);
 			slave-&gt;master = NULL;
 			slave-&gt;timer = NULL;
<span class="p_del">-			spin_unlock_irq(&amp;slave_active_lock);</span>
<span class="p_add">+			list_del_init(&amp;slave-&gt;ack_list);</span>
<span class="p_add">+			list_del_init(&amp;slave-&gt;active_list);</span>
 		}
<span class="p_add">+		spin_unlock(&amp;timer-&gt;lock);</span>
<span class="p_add">+		spin_unlock_irq(&amp;slave_active_lock);</span>
 		mutex_unlock(&amp;register_mutex);
 	}
  out:
<span class="p_chunk">@@ -439,9 +444,12 @@</span> <span class="p_context"> static int snd_timer_start_slave(struct snd_timer_instance *timeri)</span>
 
 	spin_lock_irqsave(&amp;slave_active_lock, flags);
 	timeri-&gt;flags |= SNDRV_TIMER_IFLG_RUNNING;
<span class="p_del">-	if (timeri-&gt;master)</span>
<span class="p_add">+	if (timeri-&gt;master &amp;&amp; timeri-&gt;timer) {</span>
<span class="p_add">+		spin_lock(&amp;timeri-&gt;timer-&gt;lock);</span>
 		list_add_tail(&amp;timeri-&gt;active_list,
 			      &amp;timeri-&gt;master-&gt;slave_active_head);
<span class="p_add">+		spin_unlock(&amp;timeri-&gt;timer-&gt;lock);</span>
<span class="p_add">+	}</span>
 	spin_unlock_irqrestore(&amp;slave_active_lock, flags);
 	return 1; /* delayed start */
 }
<span class="p_chunk">@@ -487,6 +495,8 @@</span> <span class="p_context"> static int _snd_timer_stop(struct snd_timer_instance * timeri,</span>
 		if (!keep_flag) {
 			spin_lock_irqsave(&amp;slave_active_lock, flags);
 			timeri-&gt;flags &amp;= ~SNDRV_TIMER_IFLG_RUNNING;
<span class="p_add">+			list_del_init(&amp;timeri-&gt;ack_list);</span>
<span class="p_add">+			list_del_init(&amp;timeri-&gt;active_list);</span>
 			spin_unlock_irqrestore(&amp;slave_active_lock, flags);
 		}
 		goto __end;
<span class="p_chunk">@@ -692,7 +702,7 @@</span> <span class="p_context"> void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)</span>
 		} else {
 			ti-&gt;flags &amp;= ~SNDRV_TIMER_IFLG_RUNNING;
 			if (--timer-&gt;running)
<span class="p_del">-				list_del(&amp;ti-&gt;active_list);</span>
<span class="p_add">+				list_del_init(&amp;ti-&gt;active_list);</span>
 		}
 		if ((timer-&gt;hw.flags &amp; SNDRV_TIMER_HW_TASKLET) ||
 		    (ti-&gt;flags &amp; SNDRV_TIMER_IFLG_FAST))
<span class="p_chunk">@@ -1255,7 +1265,7 @@</span> <span class="p_context"> static int snd_timer_user_open(struct inode *inode, struct file *file)</span>
 		return -ENOMEM;
 	spin_lock_init(&amp;tu-&gt;qlock);
 	init_waitqueue_head(&amp;tu-&gt;qchange_sleep);
<span class="p_del">-	mutex_init(&amp;tu-&gt;tread_sem);</span>
<span class="p_add">+	mutex_init(&amp;tu-&gt;ioctl_lock);</span>
 	tu-&gt;ticks = 1;
 	tu-&gt;queue_size = 128;
 	tu-&gt;queue = kmalloc(tu-&gt;queue_size * sizeof(struct snd_timer_read),
<span class="p_chunk">@@ -1275,8 +1285,10 @@</span> <span class="p_context"> static int snd_timer_user_release(struct inode *inode, struct file *file)</span>
 	if (file-&gt;private_data) {
 		tu = file-&gt;private_data;
 		file-&gt;private_data = NULL;
<span class="p_add">+		mutex_lock(&amp;tu-&gt;ioctl_lock);</span>
 		if (tu-&gt;timeri)
 			snd_timer_close(tu-&gt;timeri);
<span class="p_add">+		mutex_unlock(&amp;tu-&gt;ioctl_lock);</span>
 		kfree(tu-&gt;queue);
 		kfree(tu-&gt;tqueue);
 		kfree(tu);
<span class="p_chunk">@@ -1514,7 +1526,6 @@</span> <span class="p_context"> static int snd_timer_user_tselect(struct file *file,</span>
 	int err = 0;
 
 	tu = file-&gt;private_data;
<span class="p_del">-	mutex_lock(&amp;tu-&gt;tread_sem);</span>
 	if (tu-&gt;timeri) {
 		snd_timer_close(tu-&gt;timeri);
 		tu-&gt;timeri = NULL;
<span class="p_chunk">@@ -1558,7 +1569,6 @@</span> <span class="p_context"> static int snd_timer_user_tselect(struct file *file,</span>
 	}
 
       __err:
<span class="p_del">-      	mutex_unlock(&amp;tu-&gt;tread_sem);</span>
 	return err;
 }
 
<span class="p_chunk">@@ -1771,7 +1781,7 @@</span> <span class="p_context"> enum {</span>
 	SNDRV_TIMER_IOCTL_PAUSE_OLD = _IO(&#39;T&#39;, 0x23),
 };
 
<span class="p_del">-static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,</span>
<span class="p_add">+static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,</span>
 				 unsigned long arg)
 {
 	struct snd_timer_user *tu;
<span class="p_chunk">@@ -1788,17 +1798,11 @@</span> <span class="p_context"> static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,</span>
 	{
 		int xarg;
 
<span class="p_del">-		mutex_lock(&amp;tu-&gt;tread_sem);</span>
<span class="p_del">-		if (tu-&gt;timeri)	{	/* too late */</span>
<span class="p_del">-			mutex_unlock(&amp;tu-&gt;tread_sem);</span>
<span class="p_add">+		if (tu-&gt;timeri)	/* too late */</span>
 			return -EBUSY;
<span class="p_del">-		}</span>
<span class="p_del">-		if (get_user(xarg, p)) {</span>
<span class="p_del">-			mutex_unlock(&amp;tu-&gt;tread_sem);</span>
<span class="p_add">+		if (get_user(xarg, p))</span>
 			return -EFAULT;
<span class="p_del">-		}</span>
 		tu-&gt;tread = xarg ? 1 : 0;
<span class="p_del">-		mutex_unlock(&amp;tu-&gt;tread_sem);</span>
 		return 0;
 	}
 	case SNDRV_TIMER_IOCTL_GINFO:
<span class="p_chunk">@@ -1831,6 +1835,18 @@</span> <span class="p_context"> static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,</span>
 	return -ENOTTY;
 }
 
<span class="p_add">+static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,</span>
<span class="p_add">+				 unsigned long arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct snd_timer_user *tu = file-&gt;private_data;</span>
<span class="p_add">+	long ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;tu-&gt;ioctl_lock);</span>
<span class="p_add">+	ret = __snd_timer_user_ioctl(file, cmd, arg);</span>
<span class="p_add">+	mutex_unlock(&amp;tu-&gt;ioctl_lock);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int snd_timer_user_fasync(int fd, struct file * file, int on)
 {
 	struct snd_timer_user *tu;
<span class="p_header">diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c</span>
<span class="p_header">index ec05ef5a5abf..9aeb1c06a555 100644</span>
<span class="p_header">--- a/sound/pci/fm801.c</span>
<span class="p_header">+++ b/sound/pci/fm801.c</span>
<span class="p_chunk">@@ -1244,6 +1244,8 @@</span> <span class="p_context"> static int __devinit snd_fm801_create(struct snd_card *card,</span>
 			return -ENODEV;
 		}
 	} else if ((tea575x_tuner &amp; TUNER_TYPE_MASK) == 0) {
<span class="p_add">+		unsigned int tuner_only = tea575x_tuner &amp; TUNER_ONLY;</span>
<span class="p_add">+</span>
 		/* autodetect tuner connection */
 		for (tea575x_tuner = 1; tea575x_tuner &lt;= 3; tea575x_tuner++) {
 			chip-&gt;tea575x_tuner = tea575x_tuner;
<span class="p_chunk">@@ -1257,6 +1259,8 @@</span> <span class="p_context"> static int __devinit snd_fm801_create(struct snd_card *card,</span>
 			snd_printk(KERN_ERR &quot;TEA575x radio not found\n&quot;);
 			chip-&gt;tea575x_tuner = TUNER_DISABLED;
 		}
<span class="p_add">+</span>
<span class="p_add">+		chip-&gt;tea575x_tuner |= tuner_only;</span>
 	}
 	if (!(chip-&gt;tea575x_tuner &amp; TUNER_DISABLED)) {
 		strlcpy(chip-&gt;tea.card, get_tea575x_gpio(chip)-&gt;name,

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



