
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[RFC] vhost: basic device IOTLB support - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [RFC] vhost: basic device IOTLB support</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=2154">Jason Wang</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 31, 2015, 7:13 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1451546025-15955-1-git-send-email-jasowang@redhat.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7935581/mbox/"
   >mbox</a>
|
   <a href="/patch/7935581/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7935581/">/patch/7935581/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id E92D39F387
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 31 Dec 2015 07:14:08 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id AD88B20265
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 31 Dec 2015 07:14:07 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 454B520254
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 31 Dec 2015 07:14:06 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1755121AbbLaHOD (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 31 Dec 2015 02:14:03 -0500
Received: from mx1.redhat.com ([209.132.183.28]:57799 &quot;EHLO mx1.redhat.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1751318AbbLaHN7 (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 31 Dec 2015 02:13:59 -0500
Received: from int-mx09.intmail.prod.int.phx2.redhat.com
	(int-mx09.intmail.prod.int.phx2.redhat.com [10.5.11.22])
	by mx1.redhat.com (Postfix) with ESMTPS id 613BD8CB55;
	Thu, 31 Dec 2015 07:13:59 +0000 (UTC)
Received: from jason-ThinkPad-T430s.redhat.com (vpn1-7-116.pek2.redhat.com
	[10.72.7.116])
	by int-mx09.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with
	ESMTP id tBV7DsaY004690; Thu, 31 Dec 2015 02:13:55 -0500
From: Jason Wang &lt;jasowang@redhat.com&gt;
To: mst@redhat.com, kvm@vger.kernel.org,
	virtualization@lists.linux-foundation.org, netdev@vger.kernel.org,
	linux-kernel@vger.kernel.org, linux-api@vger.kernel.org
Cc: Jason Wang &lt;jasowang@redhat.com&gt;
Subject: [PATCH RFC] vhost: basic device IOTLB support
Date: Thu, 31 Dec 2015 15:13:45 +0800
Message-Id: &lt;1451546025-15955-1-git-send-email-jasowang@redhat.com&gt;
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.22
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=2154">Jason Wang</a> - Dec. 31, 2015, 7:13 a.m.</div>
<pre class="content">
This patch tries to implement an device IOTLB for vhost. This could be
used with for co-operation with userspace(qemu) implementation of
iommu for a secure DMA environment in guest.

The idea is simple. When vhost meets an IOTLB miss, it will request
the assistance of userspace to do the translation, this is done
through:

- Fill the translation request in a preset userspace address (This
  address is set through ioctl VHOST_SET_IOTLB_REQUEST_ENTRY).
- Notify userspace through eventfd (This eventfd was set through ioctl
  VHOST_SET_IOTLB_FD).

When userspace finishes the translation, it will update the vhost
IOTLB through VHOST_UPDATE_IOTLB ioctl. Userspace is also in charge of
snooping the IOTLB invalidation of IOMMU IOTLB and use
VHOST_UPDATE_IOTLB to invalidate the possible entry in vhost.

For simplicity, IOTLB was implemented with a simple hash array. The
index were calculated from IOVA page frame number which can only works
at PAGE_SIZE level.

An qemu implementation (for reference) is available at:
git@github.com:jasowang/qemu.git iommu

TODO &amp; Known issues:

- read/write permission validation was not implemented.
- no feature negotiation.
- VHOST_SET_MEM_TABLE is not reused (maybe there&#39;s a chance).
- working at PAGE_SIZE level, don&#39;t support large mappings.
- better data structure for IOTLB instead of simple hash array.
- better API, e.g using mmap() instead of preset userspace address.
<span class="signed-off-by">
Signed-off-by: Jason Wang &lt;jasowang@redhat.com&gt;</span>
---
 drivers/vhost/net.c        |   2 +-
 drivers/vhost/vhost.c      | 190 ++++++++++++++++++++++++++++++++++++++++++++-
 drivers/vhost/vhost.h      |  13 ++++
 include/uapi/linux/vhost.h |  26 +++++++
 4 files changed, 229 insertions(+), 2 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=1984">Michael S. Tsirkin</a> - Dec. 31, 2015, 11:17 a.m.</div>
<pre class="content">
On Thu, Dec 31, 2015 at 03:13:45PM +0800, Jason Wang wrote:
<span class="quote">&gt; This patch tries to implement an device IOTLB for vhost. This could be</span>
<span class="quote">&gt; used with for co-operation with userspace(qemu) implementation of</span>
<span class="quote">&gt; iommu for a secure DMA environment in guest.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The idea is simple. When vhost meets an IOTLB miss, it will request</span>
<span class="quote">&gt; the assistance of userspace to do the translation, this is done</span>
<span class="quote">&gt; through:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; - Fill the translation request in a preset userspace address (This</span>
<span class="quote">&gt;   address is set through ioctl VHOST_SET_IOTLB_REQUEST_ENTRY).</span>
<span class="quote">&gt; - Notify userspace through eventfd (This eventfd was set through ioctl</span>
<span class="quote">&gt;   VHOST_SET_IOTLB_FD).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; When userspace finishes the translation, it will update the vhost</span>
<span class="quote">&gt; IOTLB through VHOST_UPDATE_IOTLB ioctl. Userspace is also in charge of</span>
<span class="quote">&gt; snooping the IOTLB invalidation of IOMMU IOTLB and use</span>
<span class="quote">&gt; VHOST_UPDATE_IOTLB to invalidate the possible entry in vhost.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; For simplicity, IOTLB was implemented with a simple hash array. The</span>
<span class="quote">&gt; index were calculated from IOVA page frame number which can only works</span>
<span class="quote">&gt; at PAGE_SIZE level.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; An qemu implementation (for reference) is available at:</span>
<span class="quote">&gt; git@github.com:jasowang/qemu.git iommu</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; TODO &amp; Known issues:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; - read/write permission validation was not implemented.</span>
<span class="quote">&gt; - no feature negotiation.</span>
<span class="quote">&gt; - VHOST_SET_MEM_TABLE is not reused (maybe there&#39;s a chance).</span>
<span class="quote">&gt; - working at PAGE_SIZE level, don&#39;t support large mappings.</span>
<span class="quote">&gt; - better data structure for IOTLB instead of simple hash array.</span>
<span class="quote">&gt; - better API, e.g using mmap() instead of preset userspace address.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Jason Wang &lt;jasowang@redhat.com&gt;</span>

Interesting. I&#39;m working on a slightly different approach
which is direct vt-d support in vhost.
This one has the advantage of being more portable.
<span class="quote">
&gt; ---</span>
<span class="quote">&gt;  drivers/vhost/net.c        |   2 +-</span>
<span class="quote">&gt;  drivers/vhost/vhost.c      | 190 ++++++++++++++++++++++++++++++++++++++++++++-</span>
<span class="quote">&gt;  drivers/vhost/vhost.h      |  13 ++++</span>
<span class="quote">&gt;  include/uapi/linux/vhost.h |  26 +++++++</span>
<span class="quote">&gt;  4 files changed, 229 insertions(+), 2 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c</span>
<span class="quote">&gt; index 9eda69e..a172be9 100644</span>
<span class="quote">&gt; --- a/drivers/vhost/net.c</span>
<span class="quote">&gt; +++ b/drivers/vhost/net.c</span>
<span class="quote">&gt; @@ -1083,7 +1083,7 @@ static long vhost_net_ioctl(struct file *f, unsigned int ioctl,</span>
<span class="quote">&gt;  		r = vhost_dev_ioctl(&amp;n-&gt;dev, ioctl, argp);</span>
<span class="quote">&gt;  		if (r == -ENOIOCTLCMD)</span>
<span class="quote">&gt;  			r = vhost_vring_ioctl(&amp;n-&gt;dev, ioctl, argp);</span>
<span class="quote">&gt; -		else</span>
<span class="quote">&gt; +		else if (ioctl != VHOST_UPDATE_IOTLB)</span>
<span class="quote">&gt;  			vhost_net_flush(n);</span>
<span class="quote">&gt;  		mutex_unlock(&amp;n-&gt;dev.mutex);</span>
<span class="quote">&gt;  		return r;</span>
<span class="quote">&gt; diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c</span>
<span class="quote">&gt; index eec2f11..729fe05 100644</span>
<span class="quote">&gt; --- a/drivers/vhost/vhost.c</span>
<span class="quote">&gt; +++ b/drivers/vhost/vhost.c</span>
<span class="quote">&gt; @@ -113,6 +113,11 @@ static void vhost_init_is_le(struct vhost_virtqueue *vq)</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  #endif /* CONFIG_VHOST_CROSS_ENDIAN_LEGACY */</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +static inline int vhost_iotlb_hash(u64 iova)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return (iova &gt;&gt; PAGE_SHIFT) &amp; (VHOST_IOTLB_SIZE - 1);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  static void vhost_poll_func(struct file *file, wait_queue_head_t *wqh,</span>
<span class="quote">&gt;  			    poll_table *pt)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; @@ -384,8 +389,14 @@ void vhost_dev_init(struct vhost_dev *dev,</span>
<span class="quote">&gt;  	dev-&gt;memory = NULL;</span>
<span class="quote">&gt;  	dev-&gt;mm = NULL;</span>
<span class="quote">&gt;  	spin_lock_init(&amp;dev-&gt;work_lock);</span>
<span class="quote">&gt; +	spin_lock_init(&amp;dev-&gt;iotlb_lock);</span>
<span class="quote">&gt; +	mutex_init(&amp;dev-&gt;iotlb_req_mutex);</span>
<span class="quote">&gt;  	INIT_LIST_HEAD(&amp;dev-&gt;work_list);</span>
<span class="quote">&gt;  	dev-&gt;worker = NULL;</span>
<span class="quote">&gt; +	dev-&gt;iotlb_request = NULL;</span>
<span class="quote">&gt; +	dev-&gt;iotlb_ctx = NULL;</span>
<span class="quote">&gt; +	dev-&gt;iotlb_file = NULL;</span>
<span class="quote">&gt; +	dev-&gt;pending_request.flags.type = VHOST_IOTLB_INVALIDATE;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	for (i = 0; i &lt; dev-&gt;nvqs; ++i) {</span>
<span class="quote">&gt;  		vq = dev-&gt;vqs[i];</span>
<span class="quote">&gt; @@ -393,12 +404,17 @@ void vhost_dev_init(struct vhost_dev *dev,</span>
<span class="quote">&gt;  		vq-&gt;indirect = NULL;</span>
<span class="quote">&gt;  		vq-&gt;heads = NULL;</span>
<span class="quote">&gt;  		vq-&gt;dev = dev;</span>
<span class="quote">&gt; +		vq-&gt;iotlb_request = NULL;</span>
<span class="quote">&gt;  		mutex_init(&amp;vq-&gt;mutex);</span>
<span class="quote">&gt;  		vhost_vq_reset(dev, vq);</span>
<span class="quote">&gt;  		if (vq-&gt;handle_kick)</span>
<span class="quote">&gt;  			vhost_poll_init(&amp;vq-&gt;poll, vq-&gt;handle_kick,</span>
<span class="quote">&gt;  					POLLIN, dev);</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	init_completion(&amp;dev-&gt;iotlb_completion);</span>
<span class="quote">&gt; +	for (i = 0; i &lt; VHOST_IOTLB_SIZE; i++)</span>
<span class="quote">&gt; +		dev-&gt;iotlb[i].flags.valid = VHOST_IOTLB_INVALID;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  EXPORT_SYMBOL_GPL(vhost_dev_init);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; @@ -940,9 +956,10 @@ long vhost_dev_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *argp)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	struct file *eventfp, *filep = NULL;</span>
<span class="quote">&gt;  	struct eventfd_ctx *ctx = NULL;</span>
<span class="quote">&gt; +	struct vhost_iotlb_entry entry;</span>
<span class="quote">&gt;  	u64 p;</span>
<span class="quote">&gt;  	long r;</span>
<span class="quote">&gt; -	int i, fd;</span>
<span class="quote">&gt; +	int index, i, fd;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	/* If you are not the owner, you can become one */</span>
<span class="quote">&gt;  	if (ioctl == VHOST_SET_OWNER) {</span>
<span class="quote">&gt; @@ -1008,6 +1025,80 @@ long vhost_dev_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *argp)</span>
<span class="quote">&gt;  		if (filep)</span>
<span class="quote">&gt;  			fput(filep);</span>
<span class="quote">&gt;  		break;</span>
<span class="quote">&gt; +	case VHOST_SET_IOTLB_FD:</span>
<span class="quote">&gt; +		r = get_user(fd, (int __user *)argp);</span>
<span class="quote">&gt; +		if (r &lt; 0)</span>
<span class="quote">&gt; +			break;</span>
<span class="quote">&gt; +		eventfp = fd == -1 ? NULL : eventfd_fget(fd);</span>
<span class="quote">&gt; +		if (IS_ERR(eventfp)) {</span>
<span class="quote">&gt; +			r = PTR_ERR(eventfp);</span>
<span class="quote">&gt; +			break;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +		if (eventfp != d-&gt;iotlb_file) {</span>
<span class="quote">&gt; +			filep = d-&gt;iotlb_file;</span>
<span class="quote">&gt; +			d-&gt;iotlb_file = eventfp;</span>
<span class="quote">&gt; +			ctx = d-&gt;iotlb_ctx;</span>
<span class="quote">&gt; +			d-&gt;iotlb_ctx = eventfp ?</span>
<span class="quote">&gt; +				eventfd_ctx_fileget(eventfp) : NULL;</span>
<span class="quote">&gt; +		} else</span>
<span class="quote">&gt; +			filep = eventfp;</span>
<span class="quote">&gt; +		for (i = 0; i &lt; d-&gt;nvqs; ++i) {</span>
<span class="quote">&gt; +			mutex_lock(&amp;d-&gt;vqs[i]-&gt;mutex);</span>
<span class="quote">&gt; +			d-&gt;vqs[i]-&gt;iotlb_ctx = d-&gt;iotlb_ctx;</span>
<span class="quote">&gt; +			mutex_unlock(&amp;d-&gt;vqs[i]-&gt;mutex);</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +		if (ctx)</span>
<span class="quote">&gt; +			eventfd_ctx_put(ctx);</span>
<span class="quote">&gt; +		if (filep)</span>
<span class="quote">&gt; +			fput(filep);</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	case VHOST_SET_IOTLB_REQUEST_ENTRY:</span>
<span class="quote">&gt; +		if (!access_ok(VERIFY_READ, argp, sizeof(*d-&gt;iotlb_request)))</span>
<span class="quote">&gt; +			return -EFAULT;</span>
<span class="quote">&gt; +		if (!access_ok(VERIFY_WRITE, argp, sizeof(*d-&gt;iotlb_request)))</span>
<span class="quote">&gt; +			return -EFAULT;</span>
<span class="quote">&gt; +		d-&gt;iotlb_request = argp;</span>
<span class="quote">&gt; +		for (i = 0; i &lt; d-&gt;nvqs; ++i) {</span>
<span class="quote">&gt; +			mutex_lock(&amp;d-&gt;vqs[i]-&gt;mutex);</span>
<span class="quote">&gt; +			d-&gt;vqs[i]-&gt;iotlb_request = argp;</span>
<span class="quote">&gt; +			mutex_unlock(&amp;d-&gt;vqs[i]-&gt;mutex);</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	case VHOST_UPDATE_IOTLB:</span>
<span class="quote">&gt; +		r = copy_from_user(&amp;entry, argp, sizeof(entry));</span>
<span class="quote">&gt; +		if (r &lt; 0) {</span>
<span class="quote">&gt; +			r = -EFAULT;</span>
<span class="quote">&gt; +			goto done;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		index = vhost_iotlb_hash(entry.iova);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		spin_lock(&amp;d-&gt;iotlb_lock);</span>
<span class="quote">&gt; +		switch (entry.flags.type) {</span>
<span class="quote">&gt; +		case VHOST_IOTLB_UPDATE:</span>
<span class="quote">&gt; +			d-&gt;iotlb[index] = entry;</span>
<span class="quote">&gt; +			break;</span>
<span class="quote">&gt; +		case VHOST_IOTLB_INVALIDATE:</span>
<span class="quote">&gt; +			if (d-&gt;iotlb[index].iova == entry.iova)</span>
<span class="quote">&gt; +				d-&gt;iotlb[index] = entry;</span>
<span class="quote">&gt; +			break;</span>
<span class="quote">&gt; +		default:</span>
<span class="quote">&gt; +			r = -EINVAL;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +		spin_unlock(&amp;d-&gt;iotlb_lock);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		if (!r &amp;&amp; entry.flags.type != VHOST_IOTLB_INVALIDATE) {</span>
<span class="quote">&gt; +			mutex_lock(&amp;d-&gt;iotlb_req_mutex);</span>
<span class="quote">&gt; +			if (entry.iova == d-&gt;pending_request.iova &amp;&amp;</span>
<span class="quote">&gt; +			    d-&gt;pending_request.flags.type ==</span>
<span class="quote">&gt; +				VHOST_IOTLB_MISS) {</span>
<span class="quote">&gt; +				d-&gt;pending_request = entry;</span>
<span class="quote">&gt; +				complete(&amp;d-&gt;iotlb_completion);</span>
<span class="quote">&gt; +			}</span>
<span class="quote">&gt; +			mutex_unlock(&amp;d-&gt;iotlb_req_mutex);</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt;  	default:</span>
<span class="quote">&gt;  		r = -ENOIOCTLCMD;</span>
<span class="quote">&gt;  		break;</span>
<span class="quote">&gt; @@ -1177,9 +1268,104 @@ int vhost_init_used(struct vhost_virtqueue *vq)</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  EXPORT_SYMBOL_GPL(vhost_init_used);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +static struct vhost_iotlb_entry vhost_iotlb_miss(struct vhost_virtqueue *vq,</span>
<span class="quote">&gt; +						 u64 iova)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct completion *c = &amp;vq-&gt;dev-&gt;iotlb_completion;</span>
<span class="quote">&gt; +	struct vhost_iotlb_entry *pending = &amp;vq-&gt;dev-&gt;pending_request;</span>
<span class="quote">&gt; +	struct vhost_iotlb_entry entry = {</span>
<span class="quote">&gt; +		.flags.valid = VHOST_IOTLB_INVALID,</span>
<span class="quote">&gt; +	};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mutex_lock(&amp;vq-&gt;dev-&gt;iotlb_req_mutex);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!vq-&gt;iotlb_ctx)</span>
<span class="quote">&gt; +		goto err;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!vq-&gt;dev-&gt;iotlb_request)</span>
<span class="quote">&gt; +		goto err;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (pending-&gt;flags.type == VHOST_IOTLB_MISS)</span>
<span class="quote">&gt; +		goto err;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pending-&gt;iova = iova &amp; PAGE_MASK;</span>
<span class="quote">&gt; +	pending-&gt;flags.type = VHOST_IOTLB_MISS;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (copy_to_user(vq-&gt;dev-&gt;iotlb_request, pending,</span>
<span class="quote">&gt; +			 sizeof(struct vhost_iotlb_entry))) {</span>
<span class="quote">&gt; +		goto err;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mutex_unlock(&amp;vq-&gt;dev-&gt;iotlb_req_mutex);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	eventfd_signal(vq-&gt;iotlb_ctx, 1);</span>
<span class="quote">&gt; +	wait_for_completion_interruptible(c);</span>

This can still be under vq lock, can it not?
Looks like this can cause deadlocks.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +	mutex_lock(&amp;vq-&gt;dev-&gt;iotlb_req_mutex);</span>
<span class="quote">&gt; +	entry = vq-&gt;dev-&gt;pending_request;</span>
<span class="quote">&gt; +	mutex_unlock(&amp;vq-&gt;dev-&gt;iotlb_req_mutex);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return entry;</span>
<span class="quote">&gt; +err:</span>
<span class="quote">&gt; +	mutex_unlock(&amp;vq-&gt;dev-&gt;iotlb_req_mutex);</span>
<span class="quote">&gt; +	return entry;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int translate_iotlb(struct vhost_virtqueue *vq, u64 iova, u32 len,</span>
<span class="quote">&gt; +			   struct iovec iov[], int iov_size)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct vhost_iotlb_entry *entry;</span>
<span class="quote">&gt; +	struct vhost_iotlb_entry miss;</span>
<span class="quote">&gt; +	struct vhost_dev *dev = vq-&gt;dev;</span>
<span class="quote">&gt; +	int ret = 0;</span>
<span class="quote">&gt; +	u64 s = 0, size;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	spin_lock(&amp;dev-&gt;iotlb_lock);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	while ((u64) len &gt; s) {</span>
<span class="quote">&gt; +		if (unlikely(ret &gt;= iov_size)) {</span>
<span class="quote">&gt; +			ret = -ENOBUFS;</span>
<span class="quote">&gt; +			break;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +		entry = &amp;vq-&gt;dev-&gt;iotlb[vhost_iotlb_hash(iova)];</span>
<span class="quote">&gt; +		if ((entry-&gt;iova != (iova &amp; PAGE_MASK)) ||</span>
<span class="quote">&gt; +		    (entry-&gt;flags.valid != VHOST_IOTLB_VALID)) {</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +			spin_unlock(&amp;dev-&gt;iotlb_lock);</span>
<span class="quote">&gt; +			miss = vhost_iotlb_miss(vq, iova);</span>
<span class="quote">&gt; +			spin_lock(&amp;dev-&gt;iotlb_lock);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +			if (miss.flags.valid != VHOST_IOTLB_VALID ||</span>
<span class="quote">&gt; +			    miss.iova != (iova &amp; PAGE_MASK)) {</span>
<span class="quote">&gt; +				ret = -EFAULT;</span>
<span class="quote">&gt; +				goto err;</span>
<span class="quote">&gt; +			}</span>
<span class="quote">&gt; +			entry = &amp;miss;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		if (entry-&gt;iova == (iova &amp; PAGE_MASK)) {</span>
<span class="quote">&gt; +			size = entry-&gt;userspace_addr + entry-&gt;size - iova;</span>
<span class="quote">&gt; +			iov[ret].iov_base =</span>
<span class="quote">&gt; +				(void __user *)(entry-&gt;userspace_addr +</span>
<span class="quote">&gt; +						(iova &amp; (PAGE_SIZE - 1)));</span>
<span class="quote">&gt; +			iov[ret].iov_len = min((u64)len - s, size);</span>
<span class="quote">&gt; +			s += size;</span>
<span class="quote">&gt; +			iova += size;</span>
<span class="quote">&gt; +			ret++;</span>
<span class="quote">&gt; +		} else {</span>
<span class="quote">&gt; +			BUG();</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +err:</span>
<span class="quote">&gt; +	spin_unlock(&amp;dev-&gt;iotlb_lock);</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  static int translate_desc(struct vhost_virtqueue *vq, u64 addr, u32 len,</span>
<span class="quote">&gt;  			  struct iovec iov[], int iov_size)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; +#if 0</span>
<span class="quote">&gt;  	const struct vhost_memory_region *reg;</span>
<span class="quote">&gt;  	struct vhost_memory *mem;</span>
<span class="quote">&gt;  	struct iovec *_iov;</span>
<span class="quote">&gt; @@ -1209,6 +1395,8 @@ static int translate_desc(struct vhost_virtqueue *vq, u64 addr, u32 len,</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	return ret;</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt; +	return translate_iotlb(vq, addr, len, iov, iov_size);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  /* Each buffer in the virtqueues is actually a chain of descriptors.  This</span>
<span class="quote">&gt; diff --git a/drivers/vhost/vhost.h b/drivers/vhost/vhost.h</span>
<span class="quote">&gt; index d3f7674..d254efc 100644</span>
<span class="quote">&gt; --- a/drivers/vhost/vhost.h</span>
<span class="quote">&gt; +++ b/drivers/vhost/vhost.h</span>
<span class="quote">&gt; @@ -68,6 +68,8 @@ struct vhost_virtqueue {</span>
<span class="quote">&gt;  	struct eventfd_ctx *call_ctx;</span>
<span class="quote">&gt;  	struct eventfd_ctx *error_ctx;</span>
<span class="quote">&gt;  	struct eventfd_ctx *log_ctx;</span>
<span class="quote">&gt; +	struct eventfd_ctx *iotlb_ctx;</span>
<span class="quote">&gt; +	struct vhost_iotlb __user *iotlb_request;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	struct vhost_poll poll;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; @@ -116,6 +118,8 @@ struct vhost_virtqueue {</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +#define VHOST_IOTLB_SIZE 1024</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  struct vhost_dev {</span>
<span class="quote">&gt;  	struct vhost_memory *memory;</span>
<span class="quote">&gt;  	struct mm_struct *mm;</span>
<span class="quote">


&gt; @@ -124,9 +128,18 @@ struct vhost_dev {</span>
<span class="quote">&gt;  	int nvqs;</span>
<span class="quote">&gt;  	struct file *log_file;</span>
<span class="quote">&gt;  	struct eventfd_ctx *log_ctx;</span>
<span class="quote">&gt; +	struct file *iotlb_file;</span>
<span class="quote">&gt; +	struct eventfd_ctx *iotlb_ctx;</span>
<span class="quote">&gt; +	struct mutex iotlb_req_mutex;</span>
<span class="quote">&gt; +	struct vhost_iotlb_entry __user *iotlb_request;</span>
<span class="quote">&gt; +	struct vhost_iotlb_entry pending_request;</span>
<span class="quote">&gt; +	struct completion iotlb_completion;</span>
<span class="quote">&gt; +	struct vhost_iotlb_entry request;</span>
<span class="quote">&gt;  	spinlock_t work_lock;</span>
<span class="quote">&gt;  	struct list_head work_list;</span>
<span class="quote">&gt;  	struct task_struct *worker;</span>
<span class="quote">&gt; +	spinlock_t iotlb_lock;</span>
<span class="quote">&gt; +	struct vhost_iotlb_entry iotlb[VHOST_IOTLB_SIZE];</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  void vhost_dev_init(struct vhost_dev *, struct vhost_virtqueue **vqs, int nvqs);</span>
<span class="quote">&gt; diff --git a/include/uapi/linux/vhost.h b/include/uapi/linux/vhost.h</span>
<span class="quote">&gt; index ab373191..400e513 100644</span>
<span class="quote">&gt; --- a/include/uapi/linux/vhost.h</span>
<span class="quote">&gt; +++ b/include/uapi/linux/vhost.h</span>
<span class="quote">&gt; @@ -63,6 +63,26 @@ struct vhost_memory {</span>
<span class="quote">&gt;  	struct vhost_memory_region regions[0];</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +struct vhost_iotlb_entry {</span>
<span class="quote">&gt; +	__u64 iova;</span>
<span class="quote">&gt; +	__u64 size;</span>
<span class="quote">&gt; +	__u64 userspace_addr;</span>
<span class="quote">&gt; +	struct {</span>
<span class="quote">&gt; +#define VHOST_IOTLB_PERM_READ      0x1</span>
<span class="quote">&gt; +#define VHOST_IOTLB_PERM_WRITE     0x10</span>
<span class="quote">&gt; +		__u8  perm;</span>
<span class="quote">&gt; +#define VHOST_IOTLB_MISS           1</span>
<span class="quote">&gt; +#define VHOST_IOTLB_UPDATE         2</span>
<span class="quote">&gt; +#define VHOST_IOTLB_INVALIDATE     3</span>
<span class="quote">&gt; +		__u8  type;</span>
<span class="quote">&gt; +#define VHOST_IOTLB_INVALID        0x1</span>
<span class="quote">&gt; +#define VHOST_IOTLB_VALID          0x2</span>
<span class="quote">&gt; +		__u8  valid;</span>
<span class="quote">&gt; +		__u8  u8_padding;</span>
<span class="quote">&gt; +		__u32 padding;</span>
<span class="quote">&gt; +	} flags;</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  /* ioctls */</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #define VHOST_VIRTIO 0xAF</span>
<span class="quote">&gt; @@ -127,6 +147,12 @@ struct vhost_memory {</span>
<span class="quote">&gt;  /* Set eventfd to signal an error */</span>
<span class="quote">&gt;  #define VHOST_SET_VRING_ERR _IOW(VHOST_VIRTIO, 0x22, struct vhost_vring_file)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +/* IOTLB */</span>
<span class="quote">&gt; +/* Specify an eventfd file descriptor to signle on IOTLB miss */</span>
<span class="quote">&gt; +#define VHOST_SET_IOTLB_FD _IOW(VHOST_VIRTIO, 0x23, int)</span>
<span class="quote">&gt; +#define VHOST_UPDATE_IOTLB _IOW(VHOST_VIRTIO, 0x24, struct vhost_iotlb_entry)</span>
<span class="quote">&gt; +#define VHOST_SET_IOTLB_REQUEST_ENTRY _IOW(VHOST_VIRTIO, 0x25, struct vhost_iotlb_entry)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  /* VHOST_NET specific defines */</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  /* Attach virtio net ring to a raw socket, or tap device.</span>
<span class="quote">&gt; -- </span>
<span class="quote">&gt; 2.5.0</span>
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=148521">Yang Zhang</a> - Jan. 4, 2016, 1:39 a.m.</div>
<pre class="content">
On 2015/12/31 15:13, Jason Wang wrote:
<span class="quote">&gt; This patch tries to implement an device IOTLB for vhost. This could be</span>
<span class="quote">&gt; used with for co-operation with userspace(qemu) implementation of</span>
<span class="quote">&gt; iommu for a secure DMA environment in guest.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The idea is simple. When vhost meets an IOTLB miss, it will request</span>
<span class="quote">&gt; the assistance of userspace to do the translation, this is done</span>
<span class="quote">&gt; through:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; - Fill the translation request in a preset userspace address (This</span>
<span class="quote">&gt;    address is set through ioctl VHOST_SET_IOTLB_REQUEST_ENTRY).</span>
<span class="quote">&gt; - Notify userspace through eventfd (This eventfd was set through ioctl</span>
<span class="quote">&gt;    VHOST_SET_IOTLB_FD).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; When userspace finishes the translation, it will update the vhost</span>
<span class="quote">&gt; IOTLB through VHOST_UPDATE_IOTLB ioctl. Userspace is also in charge of</span>
<span class="quote">&gt; snooping the IOTLB invalidation of IOMMU IOTLB and use</span>
<span class="quote">&gt; VHOST_UPDATE_IOTLB to invalidate the possible entry in vhost.</span>

Is there any performance data shows the difference with IOTLB 
supporting? I doubt we may see performance decrease since the flush code 
path is longer than before.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=2154">Jason Wang</a> - Jan. 4, 2016, 6:08 a.m.</div>
<pre class="content">
On 12/31/2015 07:17 PM, Michael S. Tsirkin wrote:
<span class="quote">&gt; On Thu, Dec 31, 2015 at 03:13:45PM +0800, Jason Wang wrote:</span>
<span class="quote">&gt;&gt; This patch tries to implement an device IOTLB for vhost. This could be</span>
<span class="quote">&gt;&gt; used with for co-operation with userspace(qemu) implementation of</span>
<span class="quote">&gt;&gt; iommu for a secure DMA environment in guest.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The idea is simple. When vhost meets an IOTLB miss, it will request</span>
<span class="quote">&gt;&gt; the assistance of userspace to do the translation, this is done</span>
<span class="quote">&gt;&gt; through:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; - Fill the translation request in a preset userspace address (This</span>
<span class="quote">&gt;&gt;   address is set through ioctl VHOST_SET_IOTLB_REQUEST_ENTRY).</span>
<span class="quote">&gt;&gt; - Notify userspace through eventfd (This eventfd was set through ioctl</span>
<span class="quote">&gt;&gt;   VHOST_SET_IOTLB_FD).</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; When userspace finishes the translation, it will update the vhost</span>
<span class="quote">&gt;&gt; IOTLB through VHOST_UPDATE_IOTLB ioctl. Userspace is also in charge of</span>
<span class="quote">&gt;&gt; snooping the IOTLB invalidation of IOMMU IOTLB and use</span>
<span class="quote">&gt;&gt; VHOST_UPDATE_IOTLB to invalidate the possible entry in vhost.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; For simplicity, IOTLB was implemented with a simple hash array. The</span>
<span class="quote">&gt;&gt; index were calculated from IOVA page frame number which can only works</span>
<span class="quote">&gt;&gt; at PAGE_SIZE level.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; An qemu implementation (for reference) is available at:</span>
<span class="quote">&gt;&gt; git@github.com:jasowang/qemu.git iommu</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; TODO &amp; Known issues:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; - read/write permission validation was not implemented.</span>
<span class="quote">&gt;&gt; - no feature negotiation.</span>
<span class="quote">&gt;&gt; - VHOST_SET_MEM_TABLE is not reused (maybe there&#39;s a chance).</span>
<span class="quote">&gt;&gt; - working at PAGE_SIZE level, don&#39;t support large mappings.</span>
<span class="quote">&gt;&gt; - better data structure for IOTLB instead of simple hash array.</span>
<span class="quote">&gt;&gt; - better API, e.g using mmap() instead of preset userspace address.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Jason Wang &lt;jasowang@redhat.com&gt;</span>
<span class="quote">&gt; Interesting. I&#39;m working on a slightly different approach</span>
<span class="quote">&gt; which is direct vt-d support in vhost.</span>

I&#39;ve considered this approach. May have advantages but the issues here
is vt-d emulation is even in-complete in qemu and I believe we don&#39;t
want to duplicate the code in both vhost-kernel and vhost-user?
<span class="quote">
&gt; This one has the advantage of being more portable.</span>

Right, the patch tries to be architecture independent.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt;&gt;  drivers/vhost/net.c        |   2 +-</span>
<span class="quote">&gt;&gt;  drivers/vhost/vhost.c      | 190 ++++++++++++++++++++++++++++++++++++++++++++-</span>
<span class="quote">&gt;&gt;  drivers/vhost/vhost.h      |  13 ++++</span>
<span class="quote">&gt;&gt;  include/uapi/linux/vhost.h |  26 +++++++</span>
<span class="quote">&gt;&gt;  4 files changed, 229 insertions(+), 2 deletions(-)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c</span>
<span class="quote">&gt;&gt; index 9eda69e..a172be9 100644</span>
<span class="quote">&gt;&gt; --- a/drivers/vhost/net.c</span>
<span class="quote">&gt;&gt; +++ b/drivers/vhost/net.c</span>
<span class="quote">&gt;&gt; @@ -1083,7 +1083,7 @@ static long vhost_net_ioctl(struct file *f, unsigned int ioctl,</span>
<span class="quote">&gt;&gt;  		r = vhost_dev_ioctl(&amp;n-&gt;dev, ioctl, argp);</span>
<span class="quote">&gt;&gt;  		if (r == -ENOIOCTLCMD)</span>
<span class="quote">&gt;&gt;  			r = vhost_vring_ioctl(&amp;n-&gt;dev, ioctl, argp);</span>
<span class="quote">&gt;&gt; -		else</span>
<span class="quote">&gt;&gt; +		else if (ioctl != VHOST_UPDATE_IOTLB)</span>
<span class="quote">&gt;&gt;  			vhost_net_flush(n);</span>
<span class="quote">&gt;&gt;  		mutex_unlock(&amp;n-&gt;dev.mutex);</span>
<span class="quote">&gt;&gt;  		return r;</span>
<span class="quote">&gt;&gt; diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c</span>
<span class="quote">&gt;&gt; index eec2f11..729fe05 100644</span>
<span class="quote">&gt;&gt; --- a/drivers/vhost/vhost.c</span>
<span class="quote">&gt;&gt; +++ b/drivers/vhost/vhost.c</span>
<span class="quote">&gt;&gt; @@ -113,6 +113,11 @@ static void vhost_init_is_le(struct vhost_virtqueue *vq)</span>
<span class="quote">&gt;&gt;  }</span>
<span class="quote">&gt;&gt;  #endif /* CONFIG_VHOST_CROSS_ENDIAN_LEGACY */</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt; +static inline int vhost_iotlb_hash(u64 iova)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	return (iova &gt;&gt; PAGE_SHIFT) &amp; (VHOST_IOTLB_SIZE - 1);</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;  static void vhost_poll_func(struct file *file, wait_queue_head_t *wqh,</span>
<span class="quote">&gt;&gt;  			    poll_table *pt)</span>
<span class="quote">&gt;&gt;  {</span>
<span class="quote">&gt;&gt; @@ -384,8 +389,14 @@ void vhost_dev_init(struct vhost_dev *dev,</span>
<span class="quote">&gt;&gt;  	dev-&gt;memory = NULL;</span>
<span class="quote">&gt;&gt;  	dev-&gt;mm = NULL;</span>
<span class="quote">&gt;&gt;  	spin_lock_init(&amp;dev-&gt;work_lock);</span>
<span class="quote">&gt;&gt; +	spin_lock_init(&amp;dev-&gt;iotlb_lock);</span>
<span class="quote">&gt;&gt; +	mutex_init(&amp;dev-&gt;iotlb_req_mutex);</span>
<span class="quote">&gt;&gt;  	INIT_LIST_HEAD(&amp;dev-&gt;work_list);</span>
<span class="quote">&gt;&gt;  	dev-&gt;worker = NULL;</span>
<span class="quote">&gt;&gt; +	dev-&gt;iotlb_request = NULL;</span>
<span class="quote">&gt;&gt; +	dev-&gt;iotlb_ctx = NULL;</span>
<span class="quote">&gt;&gt; +	dev-&gt;iotlb_file = NULL;</span>
<span class="quote">&gt;&gt; +	dev-&gt;pending_request.flags.type = VHOST_IOTLB_INVALIDATE;</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt;  	for (i = 0; i &lt; dev-&gt;nvqs; ++i) {</span>
<span class="quote">&gt;&gt;  		vq = dev-&gt;vqs[i];</span>
<span class="quote">&gt;&gt; @@ -393,12 +404,17 @@ void vhost_dev_init(struct vhost_dev *dev,</span>
<span class="quote">&gt;&gt;  		vq-&gt;indirect = NULL;</span>
<span class="quote">&gt;&gt;  		vq-&gt;heads = NULL;</span>
<span class="quote">&gt;&gt;  		vq-&gt;dev = dev;</span>
<span class="quote">&gt;&gt; +		vq-&gt;iotlb_request = NULL;</span>
<span class="quote">&gt;&gt;  		mutex_init(&amp;vq-&gt;mutex);</span>
<span class="quote">&gt;&gt;  		vhost_vq_reset(dev, vq);</span>
<span class="quote">&gt;&gt;  		if (vq-&gt;handle_kick)</span>
<span class="quote">&gt;&gt;  			vhost_poll_init(&amp;vq-&gt;poll, vq-&gt;handle_kick,</span>
<span class="quote">&gt;&gt;  					POLLIN, dev);</span>
<span class="quote">&gt;&gt;  	}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	init_completion(&amp;dev-&gt;iotlb_completion);</span>
<span class="quote">&gt;&gt; +	for (i = 0; i &lt; VHOST_IOTLB_SIZE; i++)</span>
<span class="quote">&gt;&gt; +		dev-&gt;iotlb[i].flags.valid = VHOST_IOTLB_INVALID;</span>
<span class="quote">&gt;&gt;  }</span>
<span class="quote">&gt;&gt;  EXPORT_SYMBOL_GPL(vhost_dev_init);</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt; @@ -940,9 +956,10 @@ long vhost_dev_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *argp)</span>
<span class="quote">&gt;&gt;  {</span>
<span class="quote">&gt;&gt;  	struct file *eventfp, *filep = NULL;</span>
<span class="quote">&gt;&gt;  	struct eventfd_ctx *ctx = NULL;</span>
<span class="quote">&gt;&gt; +	struct vhost_iotlb_entry entry;</span>
<span class="quote">&gt;&gt;  	u64 p;</span>
<span class="quote">&gt;&gt;  	long r;</span>
<span class="quote">&gt;&gt; -	int i, fd;</span>
<span class="quote">&gt;&gt; +	int index, i, fd;</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt;  	/* If you are not the owner, you can become one */</span>
<span class="quote">&gt;&gt;  	if (ioctl == VHOST_SET_OWNER) {</span>
<span class="quote">&gt;&gt; @@ -1008,6 +1025,80 @@ long vhost_dev_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *argp)</span>
<span class="quote">&gt;&gt;  		if (filep)</span>
<span class="quote">&gt;&gt;  			fput(filep);</span>
<span class="quote">&gt;&gt;  		break;</span>
<span class="quote">&gt;&gt; +	case VHOST_SET_IOTLB_FD:</span>
<span class="quote">&gt;&gt; +		r = get_user(fd, (int __user *)argp);</span>
<span class="quote">&gt;&gt; +		if (r &lt; 0)</span>
<span class="quote">&gt;&gt; +			break;</span>
<span class="quote">&gt;&gt; +		eventfp = fd == -1 ? NULL : eventfd_fget(fd);</span>
<span class="quote">&gt;&gt; +		if (IS_ERR(eventfp)) {</span>
<span class="quote">&gt;&gt; +			r = PTR_ERR(eventfp);</span>
<span class="quote">&gt;&gt; +			break;</span>
<span class="quote">&gt;&gt; +		}</span>
<span class="quote">&gt;&gt; +		if (eventfp != d-&gt;iotlb_file) {</span>
<span class="quote">&gt;&gt; +			filep = d-&gt;iotlb_file;</span>
<span class="quote">&gt;&gt; +			d-&gt;iotlb_file = eventfp;</span>
<span class="quote">&gt;&gt; +			ctx = d-&gt;iotlb_ctx;</span>
<span class="quote">&gt;&gt; +			d-&gt;iotlb_ctx = eventfp ?</span>
<span class="quote">&gt;&gt; +				eventfd_ctx_fileget(eventfp) : NULL;</span>
<span class="quote">&gt;&gt; +		} else</span>
<span class="quote">&gt;&gt; +			filep = eventfp;</span>
<span class="quote">&gt;&gt; +		for (i = 0; i &lt; d-&gt;nvqs; ++i) {</span>
<span class="quote">&gt;&gt; +			mutex_lock(&amp;d-&gt;vqs[i]-&gt;mutex);</span>
<span class="quote">&gt;&gt; +			d-&gt;vqs[i]-&gt;iotlb_ctx = d-&gt;iotlb_ctx;</span>
<span class="quote">&gt;&gt; +			mutex_unlock(&amp;d-&gt;vqs[i]-&gt;mutex);</span>
<span class="quote">&gt;&gt; +		}</span>
<span class="quote">&gt;&gt; +		if (ctx)</span>
<span class="quote">&gt;&gt; +			eventfd_ctx_put(ctx);</span>
<span class="quote">&gt;&gt; +		if (filep)</span>
<span class="quote">&gt;&gt; +			fput(filep);</span>
<span class="quote">&gt;&gt; +		break;</span>
<span class="quote">&gt;&gt; +	case VHOST_SET_IOTLB_REQUEST_ENTRY:</span>
<span class="quote">&gt;&gt; +		if (!access_ok(VERIFY_READ, argp, sizeof(*d-&gt;iotlb_request)))</span>
<span class="quote">&gt;&gt; +			return -EFAULT;</span>
<span class="quote">&gt;&gt; +		if (!access_ok(VERIFY_WRITE, argp, sizeof(*d-&gt;iotlb_request)))</span>
<span class="quote">&gt;&gt; +			return -EFAULT;</span>
<span class="quote">&gt;&gt; +		d-&gt;iotlb_request = argp;</span>
<span class="quote">&gt;&gt; +		for (i = 0; i &lt; d-&gt;nvqs; ++i) {</span>
<span class="quote">&gt;&gt; +			mutex_lock(&amp;d-&gt;vqs[i]-&gt;mutex);</span>
<span class="quote">&gt;&gt; +			d-&gt;vqs[i]-&gt;iotlb_request = argp;</span>
<span class="quote">&gt;&gt; +			mutex_unlock(&amp;d-&gt;vqs[i]-&gt;mutex);</span>
<span class="quote">&gt;&gt; +		}</span>
<span class="quote">&gt;&gt; +		break;</span>
<span class="quote">&gt;&gt; +	case VHOST_UPDATE_IOTLB:</span>
<span class="quote">&gt;&gt; +		r = copy_from_user(&amp;entry, argp, sizeof(entry));</span>
<span class="quote">&gt;&gt; +		if (r &lt; 0) {</span>
<span class="quote">&gt;&gt; +			r = -EFAULT;</span>
<span class="quote">&gt;&gt; +			goto done;</span>
<span class="quote">&gt;&gt; +		}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		index = vhost_iotlb_hash(entry.iova);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		spin_lock(&amp;d-&gt;iotlb_lock);</span>
<span class="quote">&gt;&gt; +		switch (entry.flags.type) {</span>
<span class="quote">&gt;&gt; +		case VHOST_IOTLB_UPDATE:</span>
<span class="quote">&gt;&gt; +			d-&gt;iotlb[index] = entry;</span>
<span class="quote">&gt;&gt; +			break;</span>
<span class="quote">&gt;&gt; +		case VHOST_IOTLB_INVALIDATE:</span>
<span class="quote">&gt;&gt; +			if (d-&gt;iotlb[index].iova == entry.iova)</span>
<span class="quote">&gt;&gt; +				d-&gt;iotlb[index] = entry;</span>
<span class="quote">&gt;&gt; +			break;</span>
<span class="quote">&gt;&gt; +		default:</span>
<span class="quote">&gt;&gt; +			r = -EINVAL;</span>
<span class="quote">&gt;&gt; +		}</span>
<span class="quote">&gt;&gt; +		spin_unlock(&amp;d-&gt;iotlb_lock);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		if (!r &amp;&amp; entry.flags.type != VHOST_IOTLB_INVALIDATE) {</span>
<span class="quote">&gt;&gt; +			mutex_lock(&amp;d-&gt;iotlb_req_mutex);</span>
<span class="quote">&gt;&gt; +			if (entry.iova == d-&gt;pending_request.iova &amp;&amp;</span>
<span class="quote">&gt;&gt; +			    d-&gt;pending_request.flags.type ==</span>
<span class="quote">&gt;&gt; +				VHOST_IOTLB_MISS) {</span>
<span class="quote">&gt;&gt; +				d-&gt;pending_request = entry;</span>
<span class="quote">&gt;&gt; +				complete(&amp;d-&gt;iotlb_completion);</span>
<span class="quote">&gt;&gt; +			}</span>
<span class="quote">&gt;&gt; +			mutex_unlock(&amp;d-&gt;iotlb_req_mutex);</span>
<span class="quote">&gt;&gt; +		}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		break;</span>
<span class="quote">&gt;&gt;  	default:</span>
<span class="quote">&gt;&gt;  		r = -ENOIOCTLCMD;</span>
<span class="quote">&gt;&gt;  		break;</span>
<span class="quote">&gt;&gt; @@ -1177,9 +1268,104 @@ int vhost_init_used(struct vhost_virtqueue *vq)</span>
<span class="quote">&gt;&gt;  }</span>
<span class="quote">&gt;&gt;  EXPORT_SYMBOL_GPL(vhost_init_used);</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt; +static struct vhost_iotlb_entry vhost_iotlb_miss(struct vhost_virtqueue *vq,</span>
<span class="quote">&gt;&gt; +						 u64 iova)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	struct completion *c = &amp;vq-&gt;dev-&gt;iotlb_completion;</span>
<span class="quote">&gt;&gt; +	struct vhost_iotlb_entry *pending = &amp;vq-&gt;dev-&gt;pending_request;</span>
<span class="quote">&gt;&gt; +	struct vhost_iotlb_entry entry = {</span>
<span class="quote">&gt;&gt; +		.flags.valid = VHOST_IOTLB_INVALID,</span>
<span class="quote">&gt;&gt; +	};</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	mutex_lock(&amp;vq-&gt;dev-&gt;iotlb_req_mutex);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	if (!vq-&gt;iotlb_ctx)</span>
<span class="quote">&gt;&gt; +		goto err;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	if (!vq-&gt;dev-&gt;iotlb_request)</span>
<span class="quote">&gt;&gt; +		goto err;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	if (pending-&gt;flags.type == VHOST_IOTLB_MISS)</span>
<span class="quote">&gt;&gt; +		goto err;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	pending-&gt;iova = iova &amp; PAGE_MASK;</span>
<span class="quote">&gt;&gt; +	pending-&gt;flags.type = VHOST_IOTLB_MISS;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	if (copy_to_user(vq-&gt;dev-&gt;iotlb_request, pending,</span>
<span class="quote">&gt;&gt; +			 sizeof(struct vhost_iotlb_entry))) {</span>
<span class="quote">&gt;&gt; +		goto err;</span>
<span class="quote">&gt;&gt; +	}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	mutex_unlock(&amp;vq-&gt;dev-&gt;iotlb_req_mutex);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	eventfd_signal(vq-&gt;iotlb_ctx, 1);</span>
<span class="quote">&gt;&gt; +	wait_for_completion_interruptible(c);</span>
<span class="quote">&gt; This can still be under vq lock, can it not?</span>
<span class="quote">&gt; Looks like this can cause deadlocks.</span>

Yes, looks like a solution here is completing the pending translation
request and make it fail if there&#39;s an ioctl other than IOTLB updating.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	mutex_lock(&amp;vq-&gt;dev-&gt;iotlb_req_mutex);</span>
<span class="quote">&gt;&gt; +	entry = vq-&gt;dev-&gt;pending_request;</span>
<span class="quote">&gt;&gt; +	mutex_unlock(&amp;vq-&gt;dev-&gt;iotlb_req_mutex);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	return entry;</span>
<span class="quote">&gt;&gt; +err:</span>
<span class="quote">&gt;&gt; +	mutex_unlock(&amp;vq-&gt;dev-&gt;iotlb_req_mutex);</span>
<span class="quote">&gt;&gt; +	return entry;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +static int translate_iotlb(struct vhost_virtqueue *vq, u64 iova, u32 len,</span>
<span class="quote">&gt;&gt; +			   struct iovec iov[], int iov_size)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	struct vhost_iotlb_entry *entry;</span>
<span class="quote">&gt;&gt; +	struct vhost_iotlb_entry miss;</span>
<span class="quote">&gt;&gt; +	struct vhost_dev *dev = vq-&gt;dev;</span>
<span class="quote">&gt;&gt; +	int ret = 0;</span>
<span class="quote">&gt;&gt; +	u64 s = 0, size;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	spin_lock(&amp;dev-&gt;iotlb_lock);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	while ((u64) len &gt; s) {</span>
<span class="quote">&gt;&gt; +		if (unlikely(ret &gt;= iov_size)) {</span>
<span class="quote">&gt;&gt; +			ret = -ENOBUFS;</span>
<span class="quote">&gt;&gt; +			break;</span>
<span class="quote">&gt;&gt; +		}</span>
<span class="quote">&gt;&gt; +		entry = &amp;vq-&gt;dev-&gt;iotlb[vhost_iotlb_hash(iova)];</span>
<span class="quote">&gt;&gt; +		if ((entry-&gt;iova != (iova &amp; PAGE_MASK)) ||</span>
<span class="quote">&gt;&gt; +		    (entry-&gt;flags.valid != VHOST_IOTLB_VALID)) {</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +			spin_unlock(&amp;dev-&gt;iotlb_lock);</span>
<span class="quote">&gt;&gt; +			miss = vhost_iotlb_miss(vq, iova);</span>
<span class="quote">&gt;&gt; +			spin_lock(&amp;dev-&gt;iotlb_lock);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +			if (miss.flags.valid != VHOST_IOTLB_VALID ||</span>
<span class="quote">&gt;&gt; +			    miss.iova != (iova &amp; PAGE_MASK)) {</span>
<span class="quote">&gt;&gt; +				ret = -EFAULT;</span>
<span class="quote">&gt;&gt; +				goto err;</span>
<span class="quote">&gt;&gt; +			}</span>
<span class="quote">&gt;&gt; +			entry = &amp;miss;</span>
<span class="quote">&gt;&gt; +		}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		if (entry-&gt;iova == (iova &amp; PAGE_MASK)) {</span>
<span class="quote">&gt;&gt; +			size = entry-&gt;userspace_addr + entry-&gt;size - iova;</span>
<span class="quote">&gt;&gt; +			iov[ret].iov_base =</span>
<span class="quote">&gt;&gt; +				(void __user *)(entry-&gt;userspace_addr +</span>
<span class="quote">&gt;&gt; +						(iova &amp; (PAGE_SIZE - 1)));</span>
<span class="quote">&gt;&gt; +			iov[ret].iov_len = min((u64)len - s, size);</span>
<span class="quote">&gt;&gt; +			s += size;</span>
<span class="quote">&gt;&gt; +			iova += size;</span>
<span class="quote">&gt;&gt; +			ret++;</span>
<span class="quote">&gt;&gt; +		} else {</span>
<span class="quote">&gt;&gt; +			BUG();</span>
<span class="quote">&gt;&gt; +		}</span>
<span class="quote">&gt;&gt; +	}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +err:</span>
<span class="quote">&gt;&gt; +	spin_unlock(&amp;dev-&gt;iotlb_lock);</span>
<span class="quote">&gt;&gt; +	return ret;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;  static int translate_desc(struct vhost_virtqueue *vq, u64 addr, u32 len,</span>
<span class="quote">&gt;&gt;  			  struct iovec iov[], int iov_size)</span>
<span class="quote">&gt;&gt;  {</span>
<span class="quote">&gt;&gt; +#if 0</span>
<span class="quote">&gt;&gt;  	const struct vhost_memory_region *reg;</span>
<span class="quote">&gt;&gt;  	struct vhost_memory *mem;</span>
<span class="quote">&gt;&gt;  	struct iovec *_iov;</span>
<span class="quote">&gt;&gt; @@ -1209,6 +1395,8 @@ static int translate_desc(struct vhost_virtqueue *vq, u64 addr, u32 len,</span>
<span class="quote">&gt;&gt;  	}</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt;  	return ret;</span>
<span class="quote">&gt;&gt; +#endif</span>
<span class="quote">&gt;&gt; +	return translate_iotlb(vq, addr, len, iov, iov_size);</span>
<span class="quote">&gt;&gt;  }</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt;  /* Each buffer in the virtqueues is actually a chain of descriptors.  This</span>
<span class="quote">&gt;&gt; diff --git a/drivers/vhost/vhost.h b/drivers/vhost/vhost.h</span>
<span class="quote">&gt;&gt; index d3f7674..d254efc 100644</span>
<span class="quote">&gt;&gt; --- a/drivers/vhost/vhost.h</span>
<span class="quote">&gt;&gt; +++ b/drivers/vhost/vhost.h</span>
<span class="quote">&gt;&gt; @@ -68,6 +68,8 @@ struct vhost_virtqueue {</span>
<span class="quote">&gt;&gt;  	struct eventfd_ctx *call_ctx;</span>
<span class="quote">&gt;&gt;  	struct eventfd_ctx *error_ctx;</span>
<span class="quote">&gt;&gt;  	struct eventfd_ctx *log_ctx;</span>
<span class="quote">&gt;&gt; +	struct eventfd_ctx *iotlb_ctx;</span>
<span class="quote">&gt;&gt; +	struct vhost_iotlb __user *iotlb_request;</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt;  	struct vhost_poll poll;</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt; @@ -116,6 +118,8 @@ struct vhost_virtqueue {</span>
<span class="quote">&gt;&gt;  #endif</span>
<span class="quote">&gt;&gt;  };</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt; +#define VHOST_IOTLB_SIZE 1024</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;  struct vhost_dev {</span>
<span class="quote">&gt;&gt;  	struct vhost_memory *memory;</span>
<span class="quote">&gt;&gt;  	struct mm_struct *mm;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; @@ -124,9 +128,18 @@ struct vhost_dev {</span>
<span class="quote">&gt;&gt;  	int nvqs;</span>
<span class="quote">&gt;&gt;  	struct file *log_file;</span>
<span class="quote">&gt;&gt;  	struct eventfd_ctx *log_ctx;</span>
<span class="quote">&gt;&gt; +	struct file *iotlb_file;</span>
<span class="quote">&gt;&gt; +	struct eventfd_ctx *iotlb_ctx;</span>
<span class="quote">&gt;&gt; +	struct mutex iotlb_req_mutex;</span>
<span class="quote">&gt;&gt; +	struct vhost_iotlb_entry __user *iotlb_request;</span>
<span class="quote">&gt;&gt; +	struct vhost_iotlb_entry pending_request;</span>
<span class="quote">&gt;&gt; +	struct completion iotlb_completion;</span>
<span class="quote">&gt;&gt; +	struct vhost_iotlb_entry request;</span>
<span class="quote">&gt;&gt;  	spinlock_t work_lock;</span>
<span class="quote">&gt;&gt;  	struct list_head work_list;</span>
<span class="quote">&gt;&gt;  	struct task_struct *worker;</span>
<span class="quote">&gt;&gt; +	spinlock_t iotlb_lock;</span>
<span class="quote">&gt;&gt; +	struct vhost_iotlb_entry iotlb[VHOST_IOTLB_SIZE];</span>
<span class="quote">&gt;&gt;  };</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt;  void vhost_dev_init(struct vhost_dev *, struct vhost_virtqueue **vqs, int nvqs);</span>
<span class="quote">&gt;&gt; diff --git a/include/uapi/linux/vhost.h b/include/uapi/linux/vhost.h</span>
<span class="quote">&gt;&gt; index ab373191..400e513 100644</span>
<span class="quote">&gt;&gt; --- a/include/uapi/linux/vhost.h</span>
<span class="quote">&gt;&gt; +++ b/include/uapi/linux/vhost.h</span>
<span class="quote">&gt;&gt; @@ -63,6 +63,26 @@ struct vhost_memory {</span>
<span class="quote">&gt;&gt;  	struct vhost_memory_region regions[0];</span>
<span class="quote">&gt;&gt;  };</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt; +struct vhost_iotlb_entry {</span>
<span class="quote">&gt;&gt; +	__u64 iova;</span>
<span class="quote">&gt;&gt; +	__u64 size;</span>
<span class="quote">&gt;&gt; +	__u64 userspace_addr;</span>
<span class="quote">&gt;&gt; +	struct {</span>
<span class="quote">&gt;&gt; +#define VHOST_IOTLB_PERM_READ      0x1</span>
<span class="quote">&gt;&gt; +#define VHOST_IOTLB_PERM_WRITE     0x10</span>
<span class="quote">&gt;&gt; +		__u8  perm;</span>
<span class="quote">&gt;&gt; +#define VHOST_IOTLB_MISS           1</span>
<span class="quote">&gt;&gt; +#define VHOST_IOTLB_UPDATE         2</span>
<span class="quote">&gt;&gt; +#define VHOST_IOTLB_INVALIDATE     3</span>
<span class="quote">&gt;&gt; +		__u8  type;</span>
<span class="quote">&gt;&gt; +#define VHOST_IOTLB_INVALID        0x1</span>
<span class="quote">&gt;&gt; +#define VHOST_IOTLB_VALID          0x2</span>
<span class="quote">&gt;&gt; +		__u8  valid;</span>
<span class="quote">&gt;&gt; +		__u8  u8_padding;</span>
<span class="quote">&gt;&gt; +		__u32 padding;</span>
<span class="quote">&gt;&gt; +	} flags;</span>
<span class="quote">&gt;&gt; +};</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;  /* ioctls */</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt;  #define VHOST_VIRTIO 0xAF</span>
<span class="quote">&gt;&gt; @@ -127,6 +147,12 @@ struct vhost_memory {</span>
<span class="quote">&gt;&gt;  /* Set eventfd to signal an error */</span>
<span class="quote">&gt;&gt;  #define VHOST_SET_VRING_ERR _IOW(VHOST_VIRTIO, 0x22, struct vhost_vring_file)</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt; +/* IOTLB */</span>
<span class="quote">&gt;&gt; +/* Specify an eventfd file descriptor to signle on IOTLB miss */</span>
<span class="quote">&gt;&gt; +#define VHOST_SET_IOTLB_FD _IOW(VHOST_VIRTIO, 0x23, int)</span>
<span class="quote">&gt;&gt; +#define VHOST_UPDATE_IOTLB _IOW(VHOST_VIRTIO, 0x24, struct vhost_iotlb_entry)</span>
<span class="quote">&gt;&gt; +#define VHOST_SET_IOTLB_REQUEST_ENTRY _IOW(VHOST_VIRTIO, 0x25, struct vhost_iotlb_entry)</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;  /* VHOST_NET specific defines */</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt;  /* Attach virtio net ring to a raw socket, or tap device.</span>
<span class="quote">&gt;&gt; -- </span>
<span class="quote">&gt;&gt; 2.5.0</span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; To unsubscribe from this list: send the line &quot;unsubscribe netdev&quot; in</span>
<span class="quote">&gt; the body of a message to majordomo@vger.kernel.org</span>
<span class="quote">&gt; More majordomo info at  http://vger.kernel.org/majordomo-info.html</span>

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=2154">Jason Wang</a> - Jan. 4, 2016, 6:22 a.m.</div>
<pre class="content">
On 01/04/2016 09:39 AM, Yang Zhang wrote:
<span class="quote">&gt; On 2015/12/31 15:13, Jason Wang wrote:</span>
<span class="quote">&gt;&gt; This patch tries to implement an device IOTLB for vhost. This could be</span>
<span class="quote">&gt;&gt; used with for co-operation with userspace(qemu) implementation of</span>
<span class="quote">&gt;&gt; iommu for a secure DMA environment in guest.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The idea is simple. When vhost meets an IOTLB miss, it will request</span>
<span class="quote">&gt;&gt; the assistance of userspace to do the translation, this is done</span>
<span class="quote">&gt;&gt; through:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; - Fill the translation request in a preset userspace address (This</span>
<span class="quote">&gt;&gt;    address is set through ioctl VHOST_SET_IOTLB_REQUEST_ENTRY).</span>
<span class="quote">&gt;&gt; - Notify userspace through eventfd (This eventfd was set through ioctl</span>
<span class="quote">&gt;&gt;    VHOST_SET_IOTLB_FD).</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; When userspace finishes the translation, it will update the vhost</span>
<span class="quote">&gt;&gt; IOTLB through VHOST_UPDATE_IOTLB ioctl. Userspace is also in charge of</span>
<span class="quote">&gt;&gt; snooping the IOTLB invalidation of IOMMU IOTLB and use</span>
<span class="quote">&gt;&gt; VHOST_UPDATE_IOTLB to invalidate the possible entry in vhost.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Is there any performance data shows the difference with IOTLB supporting?</span>

Basic testing show it was slower than without IOTLB.
<span class="quote">
&gt; I doubt we may see performance decrease since the flush code path is</span>
<span class="quote">&gt; longer than before.</span>
<span class="quote">&gt;</span>

Yes, it also depend on the TLB hit rate.

If lots of dynamic mappings and unmappings are used in guest (e.g normal
Linux driver). This method should be much more slower since:

- lots of invalidation and its path is slow.
- the hit rate is low and the high price of userspace assisted address
translation.
- limitation of userspace IOMMU/IOTLB implementation (qemu&#39;s vtd
emulation simply empty all entries when it&#39;s full).

Another method is to implement kernel IOMMU (e.g vtd). But I&#39;m not sure
vhost is the best place to do this, since vhost should be architecture
independent. Maybe we&#39;d better to do it in kvm or have a pv IOMMU
implementation in vhost.

Another side, if fixed mappings were used in guest, (e.g dpdk in guest).
We have the possibility to have 100% hit rate with almost no
invalidation, the performance penalty should be ignorable, this should
be the main use case for this patch.

The patch is just a prototype for discussion. Any other ideas are welcomed.

Thanks

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=148521">Yang Zhang</a> - Jan. 5, 2016, 3:18 a.m.</div>
<pre class="content">
On 2016/1/4 14:22, Jason Wang wrote:
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; On 01/04/2016 09:39 AM, Yang Zhang wrote:</span>
<span class="quote">&gt;&gt; On 2015/12/31 15:13, Jason Wang wrote:</span>
<span class="quote">&gt;&gt;&gt; This patch tries to implement an device IOTLB for vhost. This could be</span>
<span class="quote">&gt;&gt;&gt; used with for co-operation with userspace(qemu) implementation of</span>
<span class="quote">&gt;&gt;&gt; iommu for a secure DMA environment in guest.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; The idea is simple. When vhost meets an IOTLB miss, it will request</span>
<span class="quote">&gt;&gt;&gt; the assistance of userspace to do the translation, this is done</span>
<span class="quote">&gt;&gt;&gt; through:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; - Fill the translation request in a preset userspace address (This</span>
<span class="quote">&gt;&gt;&gt;     address is set through ioctl VHOST_SET_IOTLB_REQUEST_ENTRY).</span>
<span class="quote">&gt;&gt;&gt; - Notify userspace through eventfd (This eventfd was set through ioctl</span>
<span class="quote">&gt;&gt;&gt;     VHOST_SET_IOTLB_FD).</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; When userspace finishes the translation, it will update the vhost</span>
<span class="quote">&gt;&gt;&gt; IOTLB through VHOST_UPDATE_IOTLB ioctl. Userspace is also in charge of</span>
<span class="quote">&gt;&gt;&gt; snooping the IOTLB invalidation of IOMMU IOTLB and use</span>
<span class="quote">&gt;&gt;&gt; VHOST_UPDATE_IOTLB to invalidate the possible entry in vhost.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Is there any performance data shows the difference with IOTLB supporting?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Basic testing show it was slower than without IOTLB.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; I doubt we may see performance decrease since the flush code path is</span>
<span class="quote">&gt;&gt; longer than before.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Yes, it also depend on the TLB hit rate.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; If lots of dynamic mappings and unmappings are used in guest (e.g normal</span>
<span class="quote">&gt; Linux driver). This method should be much more slower since:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; - lots of invalidation and its path is slow.</span>
<span class="quote">&gt; - the hit rate is low and the high price of userspace assisted address</span>
<span class="quote">&gt; translation.</span>
<span class="quote">&gt; - limitation of userspace IOMMU/IOTLB implementation (qemu&#39;s vtd</span>
<span class="quote">&gt; emulation simply empty all entries when it&#39;s full).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Another method is to implement kernel IOMMU (e.g vtd). But I&#39;m not sure</span>
<span class="quote">&gt; vhost is the best place to do this, since vhost should be architecture</span>
<span class="quote">&gt; independent. Maybe we&#39;d better to do it in kvm or have a pv IOMMU</span>
<span class="quote">&gt; implementation in vhost.</span>

Actually, i have the kernel IOMMU(virtual vtd) patch which can pass 
though the physical device to L2 guest on hand. But it is just a draft 
patch which was written several years ago. If there is real requirement 
for it, I can rebase it and send out it for review.
<span class="quote">
&gt;</span>
<span class="quote">&gt; Another side, if fixed mappings were used in guest, (e.g dpdk in guest).</span>
<span class="quote">&gt; We have the possibility to have 100% hit rate with almost no</span>
<span class="quote">&gt; invalidation, the performance penalty should be ignorable, this should</span>
<span class="quote">&gt; be the main use case for this patch.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The patch is just a prototype for discussion. Any other ideas are welcomed.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Thanks</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=2154">Jason Wang</a> - Jan. 6, 2016, 4:57 a.m.</div>
<pre class="content">
On 01/05/2016 11:18 AM, Yang Zhang wrote:
<span class="quote">&gt; On 2016/1/4 14:22, Jason Wang wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On 01/04/2016 09:39 AM, Yang Zhang wrote:</span>
<span class="quote">&gt;&gt;&gt; On 2015/12/31 15:13, Jason Wang wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; This patch tries to implement an device IOTLB for vhost. This could be</span>
<span class="quote">&gt;&gt;&gt;&gt; used with for co-operation with userspace(qemu) implementation of</span>
<span class="quote">&gt;&gt;&gt;&gt; iommu for a secure DMA environment in guest.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; The idea is simple. When vhost meets an IOTLB miss, it will request</span>
<span class="quote">&gt;&gt;&gt;&gt; the assistance of userspace to do the translation, this is done</span>
<span class="quote">&gt;&gt;&gt;&gt; through:</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; - Fill the translation request in a preset userspace address (This</span>
<span class="quote">&gt;&gt;&gt;&gt;     address is set through ioctl VHOST_SET_IOTLB_REQUEST_ENTRY).</span>
<span class="quote">&gt;&gt;&gt;&gt; - Notify userspace through eventfd (This eventfd was set through ioctl</span>
<span class="quote">&gt;&gt;&gt;&gt;     VHOST_SET_IOTLB_FD).</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; When userspace finishes the translation, it will update the vhost</span>
<span class="quote">&gt;&gt;&gt;&gt; IOTLB through VHOST_UPDATE_IOTLB ioctl. Userspace is also in charge of</span>
<span class="quote">&gt;&gt;&gt;&gt; snooping the IOTLB invalidation of IOMMU IOTLB and use</span>
<span class="quote">&gt;&gt;&gt;&gt; VHOST_UPDATE_IOTLB to invalidate the possible entry in vhost.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Is there any performance data shows the difference with IOTLB</span>
<span class="quote">&gt;&gt;&gt; supporting?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Basic testing show it was slower than without IOTLB.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; I doubt we may see performance decrease since the flush code path is</span>
<span class="quote">&gt;&gt;&gt; longer than before.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Yes, it also depend on the TLB hit rate.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; If lots of dynamic mappings and unmappings are used in guest (e.g normal</span>
<span class="quote">&gt;&gt; Linux driver). This method should be much more slower since:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; - lots of invalidation and its path is slow.</span>
<span class="quote">&gt;&gt; - the hit rate is low and the high price of userspace assisted address</span>
<span class="quote">&gt;&gt; translation.</span>
<span class="quote">&gt;&gt; - limitation of userspace IOMMU/IOTLB implementation (qemu&#39;s vtd</span>
<span class="quote">&gt;&gt; emulation simply empty all entries when it&#39;s full).</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Another method is to implement kernel IOMMU (e.g vtd). But I&#39;m not sure</span>
<span class="quote">&gt;&gt; vhost is the best place to do this, since vhost should be architecture</span>
<span class="quote">&gt;&gt; independent. Maybe we&#39;d better to do it in kvm or have a pv IOMMU</span>
<span class="quote">&gt;&gt; implementation in vhost.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Actually, i have the kernel IOMMU(virtual vtd) patch which can pass</span>
<span class="quote">&gt; though the physical device to L2 guest on hand.</span>

A little bit confused, I believe the first step is to exporting an IOMMU
to L1 guest for it to use for a assigned device?
<span class="quote">
&gt; But it is just a draft patch which was written several years ago. If</span>
<span class="quote">&gt; there is real requirement for it, I can rebase it and send out it for</span>
<span class="quote">&gt; review.</span>

Interesting but I think the goal is different. This patch tries to make
vhost/virtio works with emulated IOMMU.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Another side, if fixed mappings were used in guest, (e.g dpdk in guest).</span>
<span class="quote">&gt;&gt; We have the possibility to have 100% hit rate with almost no</span>
<span class="quote">&gt;&gt; invalidation, the performance penalty should be ignorable, this should</span>
<span class="quote">&gt;&gt; be the main use case for this patch.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The patch is just a prototype for discussion. Any other ideas are</span>
<span class="quote">&gt;&gt; welcomed.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Thanks</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c</span>
<span class="p_header">index 9eda69e..a172be9 100644</span>
<span class="p_header">--- a/drivers/vhost/net.c</span>
<span class="p_header">+++ b/drivers/vhost/net.c</span>
<span class="p_chunk">@@ -1083,7 +1083,7 @@</span> <span class="p_context"> static long vhost_net_ioctl(struct file *f, unsigned int ioctl,</span>
 		r = vhost_dev_ioctl(&amp;n-&gt;dev, ioctl, argp);
 		if (r == -ENOIOCTLCMD)
 			r = vhost_vring_ioctl(&amp;n-&gt;dev, ioctl, argp);
<span class="p_del">-		else</span>
<span class="p_add">+		else if (ioctl != VHOST_UPDATE_IOTLB)</span>
 			vhost_net_flush(n);
 		mutex_unlock(&amp;n-&gt;dev.mutex);
 		return r;
<span class="p_header">diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c</span>
<span class="p_header">index eec2f11..729fe05 100644</span>
<span class="p_header">--- a/drivers/vhost/vhost.c</span>
<span class="p_header">+++ b/drivers/vhost/vhost.c</span>
<span class="p_chunk">@@ -113,6 +113,11 @@</span> <span class="p_context"> static void vhost_init_is_le(struct vhost_virtqueue *vq)</span>
 }
 #endif /* CONFIG_VHOST_CROSS_ENDIAN_LEGACY */
 
<span class="p_add">+static inline int vhost_iotlb_hash(u64 iova)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (iova &gt;&gt; PAGE_SHIFT) &amp; (VHOST_IOTLB_SIZE - 1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void vhost_poll_func(struct file *file, wait_queue_head_t *wqh,
 			    poll_table *pt)
 {
<span class="p_chunk">@@ -384,8 +389,14 @@</span> <span class="p_context"> void vhost_dev_init(struct vhost_dev *dev,</span>
 	dev-&gt;memory = NULL;
 	dev-&gt;mm = NULL;
 	spin_lock_init(&amp;dev-&gt;work_lock);
<span class="p_add">+	spin_lock_init(&amp;dev-&gt;iotlb_lock);</span>
<span class="p_add">+	mutex_init(&amp;dev-&gt;iotlb_req_mutex);</span>
 	INIT_LIST_HEAD(&amp;dev-&gt;work_list);
 	dev-&gt;worker = NULL;
<span class="p_add">+	dev-&gt;iotlb_request = NULL;</span>
<span class="p_add">+	dev-&gt;iotlb_ctx = NULL;</span>
<span class="p_add">+	dev-&gt;iotlb_file = NULL;</span>
<span class="p_add">+	dev-&gt;pending_request.flags.type = VHOST_IOTLB_INVALIDATE;</span>
 
 	for (i = 0; i &lt; dev-&gt;nvqs; ++i) {
 		vq = dev-&gt;vqs[i];
<span class="p_chunk">@@ -393,12 +404,17 @@</span> <span class="p_context"> void vhost_dev_init(struct vhost_dev *dev,</span>
 		vq-&gt;indirect = NULL;
 		vq-&gt;heads = NULL;
 		vq-&gt;dev = dev;
<span class="p_add">+		vq-&gt;iotlb_request = NULL;</span>
 		mutex_init(&amp;vq-&gt;mutex);
 		vhost_vq_reset(dev, vq);
 		if (vq-&gt;handle_kick)
 			vhost_poll_init(&amp;vq-&gt;poll, vq-&gt;handle_kick,
 					POLLIN, dev);
 	}
<span class="p_add">+</span>
<span class="p_add">+	init_completion(&amp;dev-&gt;iotlb_completion);</span>
<span class="p_add">+	for (i = 0; i &lt; VHOST_IOTLB_SIZE; i++)</span>
<span class="p_add">+		dev-&gt;iotlb[i].flags.valid = VHOST_IOTLB_INVALID;</span>
 }
 EXPORT_SYMBOL_GPL(vhost_dev_init);
 
<span class="p_chunk">@@ -940,9 +956,10 @@</span> <span class="p_context"> long vhost_dev_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *argp)</span>
 {
 	struct file *eventfp, *filep = NULL;
 	struct eventfd_ctx *ctx = NULL;
<span class="p_add">+	struct vhost_iotlb_entry entry;</span>
 	u64 p;
 	long r;
<span class="p_del">-	int i, fd;</span>
<span class="p_add">+	int index, i, fd;</span>
 
 	/* If you are not the owner, you can become one */
 	if (ioctl == VHOST_SET_OWNER) {
<span class="p_chunk">@@ -1008,6 +1025,80 @@</span> <span class="p_context"> long vhost_dev_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *argp)</span>
 		if (filep)
 			fput(filep);
 		break;
<span class="p_add">+	case VHOST_SET_IOTLB_FD:</span>
<span class="p_add">+		r = get_user(fd, (int __user *)argp);</span>
<span class="p_add">+		if (r &lt; 0)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		eventfp = fd == -1 ? NULL : eventfd_fget(fd);</span>
<span class="p_add">+		if (IS_ERR(eventfp)) {</span>
<span class="p_add">+			r = PTR_ERR(eventfp);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (eventfp != d-&gt;iotlb_file) {</span>
<span class="p_add">+			filep = d-&gt;iotlb_file;</span>
<span class="p_add">+			d-&gt;iotlb_file = eventfp;</span>
<span class="p_add">+			ctx = d-&gt;iotlb_ctx;</span>
<span class="p_add">+			d-&gt;iotlb_ctx = eventfp ?</span>
<span class="p_add">+				eventfd_ctx_fileget(eventfp) : NULL;</span>
<span class="p_add">+		} else</span>
<span class="p_add">+			filep = eventfp;</span>
<span class="p_add">+		for (i = 0; i &lt; d-&gt;nvqs; ++i) {</span>
<span class="p_add">+			mutex_lock(&amp;d-&gt;vqs[i]-&gt;mutex);</span>
<span class="p_add">+			d-&gt;vqs[i]-&gt;iotlb_ctx = d-&gt;iotlb_ctx;</span>
<span class="p_add">+			mutex_unlock(&amp;d-&gt;vqs[i]-&gt;mutex);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (ctx)</span>
<span class="p_add">+			eventfd_ctx_put(ctx);</span>
<span class="p_add">+		if (filep)</span>
<span class="p_add">+			fput(filep);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case VHOST_SET_IOTLB_REQUEST_ENTRY:</span>
<span class="p_add">+		if (!access_ok(VERIFY_READ, argp, sizeof(*d-&gt;iotlb_request)))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+		if (!access_ok(VERIFY_WRITE, argp, sizeof(*d-&gt;iotlb_request)))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+		d-&gt;iotlb_request = argp;</span>
<span class="p_add">+		for (i = 0; i &lt; d-&gt;nvqs; ++i) {</span>
<span class="p_add">+			mutex_lock(&amp;d-&gt;vqs[i]-&gt;mutex);</span>
<span class="p_add">+			d-&gt;vqs[i]-&gt;iotlb_request = argp;</span>
<span class="p_add">+			mutex_unlock(&amp;d-&gt;vqs[i]-&gt;mutex);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case VHOST_UPDATE_IOTLB:</span>
<span class="p_add">+		r = copy_from_user(&amp;entry, argp, sizeof(entry));</span>
<span class="p_add">+		if (r &lt; 0) {</span>
<span class="p_add">+			r = -EFAULT;</span>
<span class="p_add">+			goto done;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		index = vhost_iotlb_hash(entry.iova);</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock(&amp;d-&gt;iotlb_lock);</span>
<span class="p_add">+		switch (entry.flags.type) {</span>
<span class="p_add">+		case VHOST_IOTLB_UPDATE:</span>
<span class="p_add">+			d-&gt;iotlb[index] = entry;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case VHOST_IOTLB_INVALIDATE:</span>
<span class="p_add">+			if (d-&gt;iotlb[index].iova == entry.iova)</span>
<span class="p_add">+				d-&gt;iotlb[index] = entry;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			r = -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		spin_unlock(&amp;d-&gt;iotlb_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!r &amp;&amp; entry.flags.type != VHOST_IOTLB_INVALIDATE) {</span>
<span class="p_add">+			mutex_lock(&amp;d-&gt;iotlb_req_mutex);</span>
<span class="p_add">+			if (entry.iova == d-&gt;pending_request.iova &amp;&amp;</span>
<span class="p_add">+			    d-&gt;pending_request.flags.type ==</span>
<span class="p_add">+				VHOST_IOTLB_MISS) {</span>
<span class="p_add">+				d-&gt;pending_request = entry;</span>
<span class="p_add">+				complete(&amp;d-&gt;iotlb_completion);</span>
<span class="p_add">+			}</span>
<span class="p_add">+			mutex_unlock(&amp;d-&gt;iotlb_req_mutex);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		break;</span>
 	default:
 		r = -ENOIOCTLCMD;
 		break;
<span class="p_chunk">@@ -1177,9 +1268,104 @@</span> <span class="p_context"> int vhost_init_used(struct vhost_virtqueue *vq)</span>
 }
 EXPORT_SYMBOL_GPL(vhost_init_used);
 
<span class="p_add">+static struct vhost_iotlb_entry vhost_iotlb_miss(struct vhost_virtqueue *vq,</span>
<span class="p_add">+						 u64 iova)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct completion *c = &amp;vq-&gt;dev-&gt;iotlb_completion;</span>
<span class="p_add">+	struct vhost_iotlb_entry *pending = &amp;vq-&gt;dev-&gt;pending_request;</span>
<span class="p_add">+	struct vhost_iotlb_entry entry = {</span>
<span class="p_add">+		.flags.valid = VHOST_IOTLB_INVALID,</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;vq-&gt;dev-&gt;iotlb_req_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!vq-&gt;iotlb_ctx)</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!vq-&gt;dev-&gt;iotlb_request)</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pending-&gt;flags.type == VHOST_IOTLB_MISS)</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+</span>
<span class="p_add">+	pending-&gt;iova = iova &amp; PAGE_MASK;</span>
<span class="p_add">+	pending-&gt;flags.type = VHOST_IOTLB_MISS;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (copy_to_user(vq-&gt;dev-&gt;iotlb_request, pending,</span>
<span class="p_add">+			 sizeof(struct vhost_iotlb_entry))) {</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;vq-&gt;dev-&gt;iotlb_req_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	eventfd_signal(vq-&gt;iotlb_ctx, 1);</span>
<span class="p_add">+	wait_for_completion_interruptible(c);</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;vq-&gt;dev-&gt;iotlb_req_mutex);</span>
<span class="p_add">+	entry = vq-&gt;dev-&gt;pending_request;</span>
<span class="p_add">+	mutex_unlock(&amp;vq-&gt;dev-&gt;iotlb_req_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	return entry;</span>
<span class="p_add">+err:</span>
<span class="p_add">+	mutex_unlock(&amp;vq-&gt;dev-&gt;iotlb_req_mutex);</span>
<span class="p_add">+	return entry;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int translate_iotlb(struct vhost_virtqueue *vq, u64 iova, u32 len,</span>
<span class="p_add">+			   struct iovec iov[], int iov_size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct vhost_iotlb_entry *entry;</span>
<span class="p_add">+	struct vhost_iotlb_entry miss;</span>
<span class="p_add">+	struct vhost_dev *dev = vq-&gt;dev;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	u64 s = 0, size;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;dev-&gt;iotlb_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	while ((u64) len &gt; s) {</span>
<span class="p_add">+		if (unlikely(ret &gt;= iov_size)) {</span>
<span class="p_add">+			ret = -ENOBUFS;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		entry = &amp;vq-&gt;dev-&gt;iotlb[vhost_iotlb_hash(iova)];</span>
<span class="p_add">+		if ((entry-&gt;iova != (iova &amp; PAGE_MASK)) ||</span>
<span class="p_add">+		    (entry-&gt;flags.valid != VHOST_IOTLB_VALID)) {</span>
<span class="p_add">+</span>
<span class="p_add">+			spin_unlock(&amp;dev-&gt;iotlb_lock);</span>
<span class="p_add">+			miss = vhost_iotlb_miss(vq, iova);</span>
<span class="p_add">+			spin_lock(&amp;dev-&gt;iotlb_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (miss.flags.valid != VHOST_IOTLB_VALID ||</span>
<span class="p_add">+			    miss.iova != (iova &amp; PAGE_MASK)) {</span>
<span class="p_add">+				ret = -EFAULT;</span>
<span class="p_add">+				goto err;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			entry = &amp;miss;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (entry-&gt;iova == (iova &amp; PAGE_MASK)) {</span>
<span class="p_add">+			size = entry-&gt;userspace_addr + entry-&gt;size - iova;</span>
<span class="p_add">+			iov[ret].iov_base =</span>
<span class="p_add">+				(void __user *)(entry-&gt;userspace_addr +</span>
<span class="p_add">+						(iova &amp; (PAGE_SIZE - 1)));</span>
<span class="p_add">+			iov[ret].iov_len = min((u64)len - s, size);</span>
<span class="p_add">+			s += size;</span>
<span class="p_add">+			iova += size;</span>
<span class="p_add">+			ret++;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			BUG();</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+err:</span>
<span class="p_add">+	spin_unlock(&amp;dev-&gt;iotlb_lock);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int translate_desc(struct vhost_virtqueue *vq, u64 addr, u32 len,
 			  struct iovec iov[], int iov_size)
 {
<span class="p_add">+#if 0</span>
 	const struct vhost_memory_region *reg;
 	struct vhost_memory *mem;
 	struct iovec *_iov;
<span class="p_chunk">@@ -1209,6 +1395,8 @@</span> <span class="p_context"> static int translate_desc(struct vhost_virtqueue *vq, u64 addr, u32 len,</span>
 	}
 
 	return ret;
<span class="p_add">+#endif</span>
<span class="p_add">+	return translate_iotlb(vq, addr, len, iov, iov_size);</span>
 }
 
 /* Each buffer in the virtqueues is actually a chain of descriptors.  This
<span class="p_header">diff --git a/drivers/vhost/vhost.h b/drivers/vhost/vhost.h</span>
<span class="p_header">index d3f7674..d254efc 100644</span>
<span class="p_header">--- a/drivers/vhost/vhost.h</span>
<span class="p_header">+++ b/drivers/vhost/vhost.h</span>
<span class="p_chunk">@@ -68,6 +68,8 @@</span> <span class="p_context"> struct vhost_virtqueue {</span>
 	struct eventfd_ctx *call_ctx;
 	struct eventfd_ctx *error_ctx;
 	struct eventfd_ctx *log_ctx;
<span class="p_add">+	struct eventfd_ctx *iotlb_ctx;</span>
<span class="p_add">+	struct vhost_iotlb __user *iotlb_request;</span>
 
 	struct vhost_poll poll;
 
<span class="p_chunk">@@ -116,6 +118,8 @@</span> <span class="p_context"> struct vhost_virtqueue {</span>
 #endif
 };
 
<span class="p_add">+#define VHOST_IOTLB_SIZE 1024</span>
<span class="p_add">+</span>
 struct vhost_dev {
 	struct vhost_memory *memory;
 	struct mm_struct *mm;
<span class="p_chunk">@@ -124,9 +128,18 @@</span> <span class="p_context"> struct vhost_dev {</span>
 	int nvqs;
 	struct file *log_file;
 	struct eventfd_ctx *log_ctx;
<span class="p_add">+	struct file *iotlb_file;</span>
<span class="p_add">+	struct eventfd_ctx *iotlb_ctx;</span>
<span class="p_add">+	struct mutex iotlb_req_mutex;</span>
<span class="p_add">+	struct vhost_iotlb_entry __user *iotlb_request;</span>
<span class="p_add">+	struct vhost_iotlb_entry pending_request;</span>
<span class="p_add">+	struct completion iotlb_completion;</span>
<span class="p_add">+	struct vhost_iotlb_entry request;</span>
 	spinlock_t work_lock;
 	struct list_head work_list;
 	struct task_struct *worker;
<span class="p_add">+	spinlock_t iotlb_lock;</span>
<span class="p_add">+	struct vhost_iotlb_entry iotlb[VHOST_IOTLB_SIZE];</span>
 };
 
 void vhost_dev_init(struct vhost_dev *, struct vhost_virtqueue **vqs, int nvqs);
<span class="p_header">diff --git a/include/uapi/linux/vhost.h b/include/uapi/linux/vhost.h</span>
<span class="p_header">index ab373191..400e513 100644</span>
<span class="p_header">--- a/include/uapi/linux/vhost.h</span>
<span class="p_header">+++ b/include/uapi/linux/vhost.h</span>
<span class="p_chunk">@@ -63,6 +63,26 @@</span> <span class="p_context"> struct vhost_memory {</span>
 	struct vhost_memory_region regions[0];
 };
 
<span class="p_add">+struct vhost_iotlb_entry {</span>
<span class="p_add">+	__u64 iova;</span>
<span class="p_add">+	__u64 size;</span>
<span class="p_add">+	__u64 userspace_addr;</span>
<span class="p_add">+	struct {</span>
<span class="p_add">+#define VHOST_IOTLB_PERM_READ      0x1</span>
<span class="p_add">+#define VHOST_IOTLB_PERM_WRITE     0x10</span>
<span class="p_add">+		__u8  perm;</span>
<span class="p_add">+#define VHOST_IOTLB_MISS           1</span>
<span class="p_add">+#define VHOST_IOTLB_UPDATE         2</span>
<span class="p_add">+#define VHOST_IOTLB_INVALIDATE     3</span>
<span class="p_add">+		__u8  type;</span>
<span class="p_add">+#define VHOST_IOTLB_INVALID        0x1</span>
<span class="p_add">+#define VHOST_IOTLB_VALID          0x2</span>
<span class="p_add">+		__u8  valid;</span>
<span class="p_add">+		__u8  u8_padding;</span>
<span class="p_add">+		__u32 padding;</span>
<span class="p_add">+	} flags;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /* ioctls */
 
 #define VHOST_VIRTIO 0xAF
<span class="p_chunk">@@ -127,6 +147,12 @@</span> <span class="p_context"> struct vhost_memory {</span>
 /* Set eventfd to signal an error */
 #define VHOST_SET_VRING_ERR _IOW(VHOST_VIRTIO, 0x22, struct vhost_vring_file)
 
<span class="p_add">+/* IOTLB */</span>
<span class="p_add">+/* Specify an eventfd file descriptor to signle on IOTLB miss */</span>
<span class="p_add">+#define VHOST_SET_IOTLB_FD _IOW(VHOST_VIRTIO, 0x23, int)</span>
<span class="p_add">+#define VHOST_UPDATE_IOTLB _IOW(VHOST_VIRTIO, 0x24, struct vhost_iotlb_entry)</span>
<span class="p_add">+#define VHOST_SET_IOTLB_REQUEST_ENTRY _IOW(VHOST_VIRTIO, 0x25, struct vhost_iotlb_entry)</span>
<span class="p_add">+</span>
 /* VHOST_NET specific defines */
 
 /* Attach virtio net ring to a raw socket, or tap device.

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



