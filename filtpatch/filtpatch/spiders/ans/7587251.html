
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.1.13 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.1.13</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 10, 2015, 1:28 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20151110012820.GB7442@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7587251/mbox/"
   >mbox</a>
|
   <a href="/patch/7587251/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7587251/">/patch/7587251/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id D1F70C05C6
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 10 Nov 2015 01:28:48 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id EC8B2206F3
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 10 Nov 2015 01:28:42 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id C9874206EF
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 10 Nov 2015 01:28:35 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752368AbbKJB2a (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 9 Nov 2015 20:28:30 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:38205 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752291AbbKJB2W (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 9 Nov 2015 20:28:22 -0500
Received: from localhost (c-50-170-35-168.hsd1.wa.comcast.net
	[50.170.35.168])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 44AF08FE;
	Tue, 10 Nov 2015 01:28:21 +0000 (UTC)
Date: Mon, 9 Nov 2015 17:28:20 -0800
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.1.13
Message-ID: &lt;20151110012820.GB7442@kroah.com&gt;
References: &lt;20151110012808.GA7442@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20151110012808.GA7442@kroah.com&gt;
User-Agent: Mutt/1.5.24 (2015-08-30)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.2 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Nov. 10, 2015, 1:28 a.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/mfd/mfd.txt b/Documentation/devicetree/bindings/mfd/mfd.txt</span>
new file mode 100644
<span class="p_header">index 000000000000..af9d6931a1a2</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/mfd/mfd.txt</span>
<span class="p_chunk">@@ -0,0 +1,41 @@</span> <span class="p_context"></span>
<span class="p_add">+Multi-Function Devices (MFD)</span>
<span class="p_add">+</span>
<span class="p_add">+These devices comprise a nexus for heterogeneous hardware blocks containing</span>
<span class="p_add">+more than one non-unique yet varying hardware functionality.</span>
<span class="p_add">+</span>
<span class="p_add">+A typical MFD can be:</span>
<span class="p_add">+</span>
<span class="p_add">+- A mixed signal ASIC on an external bus, sometimes a PMIC (Power Management</span>
<span class="p_add">+  Integrated Circuit) that is manufactured in a lower technology node (rough</span>
<span class="p_add">+  silicon) that handles analog drivers for things like audio amplifiers, LED</span>
<span class="p_add">+  drivers, level shifters, PHY (physical interfaces to things like USB or</span>
<span class="p_add">+  ethernet), regulators etc.</span>
<span class="p_add">+</span>
<span class="p_add">+- A range of memory registers containing &quot;miscellaneous system registers&quot; also</span>
<span class="p_add">+  known as a system controller &quot;syscon&quot; or any other memory range containing a</span>
<span class="p_add">+  mix of unrelated hardware devices.</span>
<span class="p_add">+</span>
<span class="p_add">+Optional properties:</span>
<span class="p_add">+</span>
<span class="p_add">+- compatible : &quot;simple-mfd&quot; - this signifies that the operating system should</span>
<span class="p_add">+  consider all subnodes of the MFD device as separate devices akin to how</span>
<span class="p_add">+  &quot;simple-bus&quot; inidicates when to see subnodes as children for a simple</span>
<span class="p_add">+  memory-mapped bus. For more complex devices, when the nexus driver has to</span>
<span class="p_add">+  probe registers to figure out what child devices exist etc, this should not</span>
<span class="p_add">+  be used. In the latter case the child devices will be determined by the</span>
<span class="p_add">+  operating system.</span>
<span class="p_add">+</span>
<span class="p_add">+Example:</span>
<span class="p_add">+</span>
<span class="p_add">+foo@1000 {</span>
<span class="p_add">+	compatible = &quot;syscon&quot;, &quot;simple-mfd&quot;;</span>
<span class="p_add">+	reg = &lt;0x01000 0x1000&gt;;</span>
<span class="p_add">+</span>
<span class="p_add">+	led@08.0 {</span>
<span class="p_add">+		compatible = &quot;register-bit-led&quot;;</span>
<span class="p_add">+		offset = &lt;0x08&gt;;</span>
<span class="p_add">+		mask = &lt;0x01&gt;;</span>
<span class="p_add">+		label = &quot;myled&quot;;</span>
<span class="p_add">+		default-state = &quot;on&quot;;</span>
<span class="p_add">+	};</span>
<span class="p_add">+};</span>
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 2320f1911404..d5d229db61d5 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 1
<span class="p_del">-SUBLEVEL = 12</span>
<span class="p_add">+SUBLEVEL = 13</span>
 EXTRAVERSION =
 NAME = Series 4800
 
<span class="p_header">diff --git a/arch/arm/boot/dts/am57xx-beagle-x15.dts b/arch/arm/boot/dts/am57xx-beagle-x15.dts</span>
<span class="p_header">index c9df40e5cd3b..e8397879d0a7 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/am57xx-beagle-x15.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/am57xx-beagle-x15.dts</span>
<span class="p_chunk">@@ -354,11 +354,12 @@</span> <span class="p_context"></span>
 				/* SMPS9 unused */
 
 				ldo1_reg: ldo1 {
<span class="p_del">-					/* VDD_SD  */</span>
<span class="p_add">+					/* VDD_SD / VDDSHV8  */</span>
 					regulator-name = &quot;ldo1&quot;;
 					regulator-min-microvolt = &lt;1800000&gt;;
 					regulator-max-microvolt = &lt;3300000&gt;;
 					regulator-boot-on;
<span class="p_add">+					regulator-always-on;</span>
 				};
 
 				ldo2_reg: ldo2 {
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-385-db-ap.dts b/arch/arm/boot/dts/armada-385-db-ap.dts</span>
<span class="p_header">index 7219ac3a3d90..9f730e8e9f87 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-385-db-ap.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-385-db-ap.dts</span>
<span class="p_chunk">@@ -46,7 +46,7 @@</span> <span class="p_context"></span>
 
 / {
 	model = &quot;Marvell Armada 385 Access Point Development Board&quot;;
<span class="p_del">-	compatible = &quot;marvell,a385-db-ap&quot;, &quot;marvell,armada385&quot;, &quot;marvell,armada38x&quot;;</span>
<span class="p_add">+	compatible = &quot;marvell,a385-db-ap&quot;, &quot;marvell,armada385&quot;, &quot;marvell,armada380&quot;;</span>
 
 	chosen {
 		stdout-path = &quot;serial1:115200n8&quot;;
<span class="p_header">diff --git a/arch/arm/boot/dts/exynos5420-peach-pit.dts b/arch/arm/boot/dts/exynos5420-peach-pit.dts</span>
<span class="p_header">index 146e71118a72..a0ec8bff83dd 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/exynos5420-peach-pit.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/exynos5420-peach-pit.dts</span>
<span class="p_chunk">@@ -915,6 +915,11 @@</span> <span class="p_context"></span>
 	};
 };
 
<span class="p_add">+&amp;pmu_system_controller {</span>
<span class="p_add">+	assigned-clocks = &lt;&amp;pmu_system_controller 0&gt;;</span>
<span class="p_add">+	assigned-clock-parents = &lt;&amp;clock CLK_FIN_PLL&gt;;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 &amp;rtc {
 	status = &quot;okay&quot;;
 	clocks = &lt;&amp;clock CLK_RTC&gt;, &lt;&amp;max77802 MAX77802_CLK_32K_AP&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/exynos5800-peach-pi.dts b/arch/arm/boot/dts/exynos5800-peach-pi.dts</span>
<span class="p_header">index 02eb8b15374f..1171f347878a 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/exynos5800-peach-pi.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/exynos5800-peach-pi.dts</span>
<span class="p_chunk">@@ -878,6 +878,11 @@</span> <span class="p_context"></span>
 	};
 };
 
<span class="p_add">+&amp;pmu_system_controller {</span>
<span class="p_add">+	assigned-clocks = &lt;&amp;pmu_system_controller 0&gt;;</span>
<span class="p_add">+	assigned-clock-parents = &lt;&amp;clock CLK_FIN_PLL&gt;;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 &amp;rtc {
 	status = &quot;okay&quot;;
 	clocks = &lt;&amp;clock CLK_RTC&gt;, &lt;&amp;max77802 MAX77802_CLK_32K_AP&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6dl-riotboard.dts b/arch/arm/boot/dts/imx6dl-riotboard.dts</span>
<span class="p_header">index 43cb3fd76be7..5111f5170d53 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6dl-riotboard.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6dl-riotboard.dts</span>
<span class="p_chunk">@@ -305,8 +305,8 @@</span> <span class="p_context"></span>
 &amp;usdhc2 {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc2&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio1 4 0&gt;;</span>
<span class="p_del">-	wp-gpios = &lt;&amp;gpio1 2 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio1 4 GPIO_ACTIVE_LOW&gt;;</span>
<span class="p_add">+	wp-gpios = &lt;&amp;gpio1 2 GPIO_ACTIVE_HIGH&gt;;</span>
 	vmmc-supply = &lt;&amp;reg_3p3v&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_chunk">@@ -314,8 +314,8 @@</span> <span class="p_context"></span>
 &amp;usdhc3 {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc3&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio7 0 0&gt;;</span>
<span class="p_del">-	wp-gpios = &lt;&amp;gpio7 1 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio7 0 GPIO_ACTIVE_LOW&gt;;</span>
<span class="p_add">+	wp-gpios = &lt;&amp;gpio7 1 GPIO_ACTIVE_HIGH&gt;;</span>
 	vmmc-supply = &lt;&amp;reg_3p3v&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6q-arm2.dts b/arch/arm/boot/dts/imx6q-arm2.dts</span>
<span class="p_header">index 78df05e9d1ce..d6515f7a56c4 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6q-arm2.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6q-arm2.dts</span>
<span class="p_chunk">@@ -11,6 +11,7 @@</span> <span class="p_context"></span>
  */
 
 /dts-v1/;
<span class="p_add">+#include &lt;dt-bindings/gpio/gpio.h&gt;</span>
 #include &quot;imx6q.dtsi&quot;
 
 / {
<span class="p_chunk">@@ -196,8 +197,8 @@</span> <span class="p_context"></span>
 };
 
 &amp;usdhc3 {
<span class="p_del">-	cd-gpios = &lt;&amp;gpio6 11 0&gt;;</span>
<span class="p_del">-	wp-gpios = &lt;&amp;gpio6 14 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio6 11 GPIO_ACTIVE_LOW&gt;;</span>
<span class="p_add">+	wp-gpios = &lt;&amp;gpio6 14 GPIO_ACTIVE_HIGH&gt;;</span>
 	vmmc-supply = &lt;&amp;reg_3p3v&gt;;
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc3
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6q-gk802.dts b/arch/arm/boot/dts/imx6q-gk802.dts</span>
<span class="p_header">index 703539cf36d3..00bd63e63d0c 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6q-gk802.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6q-gk802.dts</span>
<span class="p_chunk">@@ -7,6 +7,7 @@</span> <span class="p_context"></span>
  */
 
 /dts-v1/;
<span class="p_add">+#include &lt;dt-bindings/gpio/gpio.h&gt;</span>
 #include &quot;imx6q.dtsi&quot;
 
 / {
<span class="p_chunk">@@ -161,7 +162,7 @@</span> <span class="p_context"></span>
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc3&gt;;
 	bus-width = &lt;4&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio6 11 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio6 11 GPIO_ACTIVE_LOW&gt;;</span>
 	vmmc-supply = &lt;&amp;reg_3p3v&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6q-tbs2910.dts b/arch/arm/boot/dts/imx6q-tbs2910.dts</span>
<span class="p_header">index a43abfa21e33..5645d52850a7 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6q-tbs2910.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6q-tbs2910.dts</span>
<span class="p_chunk">@@ -251,7 +251,7 @@</span> <span class="p_context"></span>
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc2&gt;;
 	bus-width = &lt;4&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio2 2 GPIO_ACTIVE_HIGH&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio2 2 GPIO_ACTIVE_LOW&gt;;</span>
 	vmmc-supply = &lt;&amp;reg_3p3v&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_chunk">@@ -260,7 +260,7 @@</span> <span class="p_context"></span>
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc3&gt;;
 	bus-width = &lt;4&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio2 0 GPIO_ACTIVE_HIGH&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio2 0 GPIO_ACTIVE_LOW&gt;;</span>
 	wp-gpios = &lt;&amp;gpio2 1 GPIO_ACTIVE_HIGH&gt;;
 	vmmc-supply = &lt;&amp;reg_3p3v&gt;;
 	status = &quot;okay&quot;;
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-aristainetos.dtsi b/arch/arm/boot/dts/imx6qdl-aristainetos.dtsi</span>
<span class="p_header">index e6d9195a1da7..f4d6ae564ead 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-aristainetos.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-aristainetos.dtsi</span>
<span class="p_chunk">@@ -173,7 +173,7 @@</span> <span class="p_context"></span>
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc1&gt;;
 	vmmc-supply = &lt;&amp;reg_3p3v&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio4 7 GPIO_ACTIVE_HIGH&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio4 7 GPIO_ACTIVE_LOW&gt;;</span>
 	status = &quot;okay&quot;;
 };
 
<span class="p_chunk">@@ -181,7 +181,7 @@</span> <span class="p_context"></span>
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc2&gt;;
 	vmmc-supply = &lt;&amp;reg_3p3v&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio4 8 GPIO_ACTIVE_HIGH&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio4 8 GPIO_ACTIVE_LOW&gt;;</span>
 	status = &quot;okay&quot;;
 };
 
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-cubox-i.dtsi b/arch/arm/boot/dts/imx6qdl-cubox-i.dtsi</span>
<span class="p_header">index d033bb182060..6a846e0ef505 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-cubox-i.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-cubox-i.dtsi</span>
<span class="p_chunk">@@ -259,6 +259,6 @@</span> <span class="p_context"></span>
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_cubox_i_usdhc2_aux &amp;pinctrl_cubox_i_usdhc2&gt;;
 	vmmc-supply = &lt;&amp;reg_3p3v&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio1 4 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio1 4 GPIO_ACTIVE_LOW&gt;;</span>
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-dfi-fs700-m60.dtsi b/arch/arm/boot/dts/imx6qdl-dfi-fs700-m60.dtsi</span>
<span class="p_header">index 2c253d6d20bd..45e7c39e80d5 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-dfi-fs700-m60.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-dfi-fs700-m60.dtsi</span>
<span class="p_chunk">@@ -1,3 +1,5 @@</span> <span class="p_context"></span>
<span class="p_add">+#include &lt;dt-bindings/gpio/gpio.h&gt;</span>
<span class="p_add">+</span>
 / {
 	regulators {
 		compatible = &quot;simple-bus&quot;;
<span class="p_chunk">@@ -181,7 +183,7 @@</span> <span class="p_context"></span>
 &amp;usdhc2 { /* module slot */
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc2&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio2 2 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio2 2 GPIO_ACTIVE_LOW&gt;;</span>
 	status = &quot;okay&quot;;
 };
 
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-gw52xx.dtsi b/arch/arm/boot/dts/imx6qdl-gw52xx.dtsi</span>
<span class="p_header">index b5756c21ea1d..4493f6e99330 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-gw52xx.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-gw52xx.dtsi</span>
<span class="p_chunk">@@ -318,7 +318,7 @@</span> <span class="p_context"></span>
 &amp;usdhc3 {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc3&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio7 0 GPIO_ACTIVE_HIGH&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio7 0 GPIO_ACTIVE_LOW&gt;;</span>
 	vmmc-supply = &lt;&amp;reg_3p3v&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-gw53xx.dtsi b/arch/arm/boot/dts/imx6qdl-gw53xx.dtsi</span>
<span class="p_header">index 86f03c1b147c..a857d1294609 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-gw53xx.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-gw53xx.dtsi</span>
<span class="p_chunk">@@ -324,7 +324,7 @@</span> <span class="p_context"></span>
 &amp;usdhc3 {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc3&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio7 0 GPIO_ACTIVE_HIGH&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio7 0 GPIO_ACTIVE_LOW&gt;;</span>
 	vmmc-supply = &lt;&amp;reg_3p3v&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-gw54xx.dtsi b/arch/arm/boot/dts/imx6qdl-gw54xx.dtsi</span>
<span class="p_header">index 4a8d97f47759..1afe3385e2d2 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-gw54xx.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-gw54xx.dtsi</span>
<span class="p_chunk">@@ -417,7 +417,7 @@</span> <span class="p_context"></span>
 &amp;usdhc3 {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc3&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio7 0 GPIO_ACTIVE_HIGH&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio7 0 GPIO_ACTIVE_LOW&gt;;</span>
 	vmmc-supply = &lt;&amp;reg_3p3v&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-hummingboard.dtsi b/arch/arm/boot/dts/imx6qdl-hummingboard.dtsi</span>
<span class="p_header">index 151a3db2aea9..c6833d2b4ff5 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-hummingboard.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-hummingboard.dtsi</span>
<span class="p_chunk">@@ -41,6 +41,7 @@</span> <span class="p_context"></span>
  */
 #include &quot;imx6qdl-microsom.dtsi&quot;
 #include &quot;imx6qdl-microsom-ar8035.dtsi&quot;
<span class="p_add">+#include &lt;dt-bindings/gpio/gpio.h&gt;</span>
 
 / {
 	chosen {
<span class="p_chunk">@@ -288,6 +289,6 @@</span> <span class="p_context"></span>
 		&amp;pinctrl_hummingboard_usdhc2
 	&gt;;
 	vmmc-supply = &lt;&amp;reg_3p3v&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio1 4 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio1 4 GPIO_ACTIVE_LOW&gt;;</span>
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-nitrogen6x.dtsi b/arch/arm/boot/dts/imx6qdl-nitrogen6x.dtsi</span>
<span class="p_header">index 08218120e770..64e0b6178bf4 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-nitrogen6x.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-nitrogen6x.dtsi</span>
<span class="p_chunk">@@ -449,7 +449,7 @@</span> <span class="p_context"></span>
 &amp;usdhc3 {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc3&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio7 0 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio7 0 GPIO_ACTIVE_LOW&gt;;</span>
 	vmmc-supply = &lt;&amp;reg_3p3v&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_chunk">@@ -457,7 +457,7 @@</span> <span class="p_context"></span>
 &amp;usdhc4 {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc4&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio2 6 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio2 6 GPIO_ACTIVE_LOW&gt;;</span>
 	vmmc-supply = &lt;&amp;reg_3p3v&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-phytec-pfla02.dtsi b/arch/arm/boot/dts/imx6qdl-phytec-pfla02.dtsi</span>
<span class="p_header">index 1ce6133b67f5..9e6ecd99b472 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-phytec-pfla02.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-phytec-pfla02.dtsi</span>
<span class="p_chunk">@@ -409,8 +409,8 @@</span> <span class="p_context"></span>
 &amp;usdhc2 {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc2&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio1 4 0&gt;;</span>
<span class="p_del">-	wp-gpios = &lt;&amp;gpio1 2 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio1 4 GPIO_ACTIVE_LOW&gt;;</span>
<span class="p_add">+	wp-gpios = &lt;&amp;gpio1 2 GPIO_ACTIVE_HIGH&gt;;</span>
 	status = &quot;disabled&quot;;
 };
 
<span class="p_chunk">@@ -418,7 +418,7 @@</span> <span class="p_context"></span>
         pinctrl-names = &quot;default&quot;;
         pinctrl-0 = &lt;&amp;pinctrl_usdhc3
 		     &amp;pinctrl_usdhc3_cdwp&gt;;
<span class="p_del">-        cd-gpios = &lt;&amp;gpio1 27 0&gt;;</span>
<span class="p_del">-        wp-gpios = &lt;&amp;gpio1 29 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio1 27 GPIO_ACTIVE_LOW&gt;;</span>
<span class="p_add">+	wp-gpios = &lt;&amp;gpio1 29 GPIO_ACTIVE_HIGH&gt;;</span>
         status = &quot;disabled&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-rex.dtsi b/arch/arm/boot/dts/imx6qdl-rex.dtsi</span>
<span class="p_header">index 394a4ace351a..a50356243888 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-rex.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-rex.dtsi</span>
<span class="p_chunk">@@ -340,7 +340,7 @@</span> <span class="p_context"></span>
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc2&gt;;
 	bus-width = &lt;4&gt;;
 	cd-gpios = &lt;&amp;gpio2 2 GPIO_ACTIVE_LOW&gt;;
<span class="p_del">-	wp-gpios = &lt;&amp;gpio2 3 GPIO_ACTIVE_LOW&gt;;</span>
<span class="p_add">+	wp-gpios = &lt;&amp;gpio2 3 GPIO_ACTIVE_HIGH&gt;;</span>
 	status = &quot;okay&quot;;
 };
 
<span class="p_chunk">@@ -349,6 +349,6 @@</span> <span class="p_context"></span>
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc3&gt;;
 	bus-width = &lt;4&gt;;
 	cd-gpios = &lt;&amp;gpio2 0 GPIO_ACTIVE_LOW&gt;;
<span class="p_del">-	wp-gpios = &lt;&amp;gpio2 1 GPIO_ACTIVE_LOW&gt;;</span>
<span class="p_add">+	wp-gpios = &lt;&amp;gpio2 1 GPIO_ACTIVE_HIGH&gt;;</span>
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-sabreauto.dtsi b/arch/arm/boot/dts/imx6qdl-sabreauto.dtsi</span>
<span class="p_header">index 3b24b12651b2..e329ca5c3322 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-sabreauto.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-sabreauto.dtsi</span>
<span class="p_chunk">@@ -467,8 +467,8 @@</span> <span class="p_context"></span>
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc3&gt;;
 	pinctrl-1 = &lt;&amp;pinctrl_usdhc3_100mhz&gt;;
 	pinctrl-2 = &lt;&amp;pinctrl_usdhc3_200mhz&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio6 15 0&gt;;</span>
<span class="p_del">-	wp-gpios = &lt;&amp;gpio1 13 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio6 15 GPIO_ACTIVE_LOW&gt;;</span>
<span class="p_add">+	wp-gpios = &lt;&amp;gpio1 13 GPIO_ACTIVE_HIGH&gt;;</span>
 	status = &quot;okay&quot;;
 };
 
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-sabrelite.dtsi b/arch/arm/boot/dts/imx6qdl-sabrelite.dtsi</span>
<span class="p_header">index 0b28a9d5241e..1e27485e4293 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-sabrelite.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-sabrelite.dtsi</span>
<span class="p_chunk">@@ -444,8 +444,8 @@</span> <span class="p_context"></span>
 &amp;usdhc3 {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc3&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio7 0 0&gt;;</span>
<span class="p_del">-	wp-gpios = &lt;&amp;gpio7 1 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio7 0 GPIO_ACTIVE_LOW&gt;;</span>
<span class="p_add">+	wp-gpios = &lt;&amp;gpio7 1 GPIO_ACTIVE_HIGH&gt;;</span>
 	vmmc-supply = &lt;&amp;reg_3p3v&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_chunk">@@ -453,7 +453,7 @@</span> <span class="p_context"></span>
 &amp;usdhc4 {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc4&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio2 6 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio2 6 GPIO_ACTIVE_LOW&gt;;</span>
 	vmmc-supply = &lt;&amp;reg_3p3v&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-sabresd.dtsi b/arch/arm/boot/dts/imx6qdl-sabresd.dtsi</span>
<span class="p_header">index a626e6dd8022..944eb81cb2b8 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-sabresd.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-sabresd.dtsi</span>
<span class="p_chunk">@@ -562,8 +562,8 @@</span> <span class="p_context"></span>
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc2&gt;;
 	bus-width = &lt;8&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio2 2 0&gt;;</span>
<span class="p_del">-	wp-gpios = &lt;&amp;gpio2 3 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio2 2 GPIO_ACTIVE_LOW&gt;;</span>
<span class="p_add">+	wp-gpios = &lt;&amp;gpio2 3 GPIO_ACTIVE_HIGH&gt;;</span>
 	status = &quot;okay&quot;;
 };
 
<span class="p_chunk">@@ -571,8 +571,8 @@</span> <span class="p_context"></span>
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc3&gt;;
 	bus-width = &lt;8&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio2 0 0&gt;;</span>
<span class="p_del">-	wp-gpios = &lt;&amp;gpio2 1 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio2 0 GPIO_ACTIVE_LOW&gt;;</span>
<span class="p_add">+	wp-gpios = &lt;&amp;gpio2 1 GPIO_ACTIVE_HIGH&gt;;</span>
 	status = &quot;okay&quot;;
 };
 
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-tx6.dtsi b/arch/arm/boot/dts/imx6qdl-tx6.dtsi</span>
<span class="p_header">index f02b80b41d4f..da08de324e9e 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-tx6.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-tx6.dtsi</span>
<span class="p_chunk">@@ -680,7 +680,7 @@</span> <span class="p_context"></span>
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc1&gt;;
 	bus-width = &lt;4&gt;;
 	no-1-8-v;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio7 2 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio7 2 GPIO_ACTIVE_LOW&gt;;</span>
 	fsl,wp-controller;
 	status = &quot;okay&quot;;
 };
<span class="p_chunk">@@ -690,7 +690,7 @@</span> <span class="p_context"></span>
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc2&gt;;
 	bus-width = &lt;4&gt;;
 	no-1-8-v;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio7 3 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio7 3 GPIO_ACTIVE_LOW&gt;;</span>
 	fsl,wp-controller;
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-wandboard.dtsi b/arch/arm/boot/dts/imx6qdl-wandboard.dtsi</span>
<span class="p_header">index 5fb091675582..9e096d811bed 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-wandboard.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-wandboard.dtsi</span>
<span class="p_chunk">@@ -9,6 +9,8 @@</span> <span class="p_context"></span>
  *
  */
 
<span class="p_add">+#include &lt;dt-bindings/gpio/gpio.h&gt;</span>
<span class="p_add">+</span>
 / {
 	regulators {
 		compatible = &quot;simple-bus&quot;;
<span class="p_chunk">@@ -250,13 +252,13 @@</span> <span class="p_context"></span>
 &amp;usdhc1 {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc1&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio1 2 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio1 2 GPIO_ACTIVE_LOW&gt;;</span>
 	status = &quot;okay&quot;;
 };
 
 &amp;usdhc3 {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc3&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio3 9 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio3 9 GPIO_ACTIVE_LOW&gt;;</span>
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6sl-evk.dts b/arch/arm/boot/dts/imx6sl-evk.dts</span>
<span class="p_header">index 945887d3fdb3..b84dff2e94ea 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6sl-evk.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6sl-evk.dts</span>
<span class="p_chunk">@@ -617,8 +617,8 @@</span> <span class="p_context"></span>
 	pinctrl-1 = &lt;&amp;pinctrl_usdhc1_100mhz&gt;;
 	pinctrl-2 = &lt;&amp;pinctrl_usdhc1_200mhz&gt;;
 	bus-width = &lt;8&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio4 7 0&gt;;</span>
<span class="p_del">-	wp-gpios = &lt;&amp;gpio4 6 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio4 7 GPIO_ACTIVE_LOW&gt;;</span>
<span class="p_add">+	wp-gpios = &lt;&amp;gpio4 6 GPIO_ACTIVE_HIGH&gt;;</span>
 	status = &quot;okay&quot;;
 };
 
<span class="p_chunk">@@ -627,8 +627,8 @@</span> <span class="p_context"></span>
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc2&gt;;
 	pinctrl-1 = &lt;&amp;pinctrl_usdhc2_100mhz&gt;;
 	pinctrl-2 = &lt;&amp;pinctrl_usdhc2_200mhz&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio5 0 0&gt;;</span>
<span class="p_del">-	wp-gpios = &lt;&amp;gpio4 29 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio5 0 GPIO_ACTIVE_LOW&gt;;</span>
<span class="p_add">+	wp-gpios = &lt;&amp;gpio4 29 GPIO_ACTIVE_HIGH&gt;;</span>
 	status = &quot;okay&quot;;
 };
 
<span class="p_chunk">@@ -637,6 +637,6 @@</span> <span class="p_context"></span>
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc3&gt;;
 	pinctrl-1 = &lt;&amp;pinctrl_usdhc3_100mhz&gt;;
 	pinctrl-2 = &lt;&amp;pinctrl_usdhc3_200mhz&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio3 22 0&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio3 22 GPIO_ACTIVE_LOW&gt;;</span>
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6sx-sabreauto.dts b/arch/arm/boot/dts/imx6sx-sabreauto.dts</span>
<span class="p_header">index e3c0b63c2205..115f3fd78971 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6sx-sabreauto.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6sx-sabreauto.dts</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"></span>
 	pinctrl-1 = &lt;&amp;pinctrl_usdhc3_100mhz&gt;;
 	pinctrl-2 = &lt;&amp;pinctrl_usdhc3_200mhz&gt;;
 	bus-width = &lt;8&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio7 10 GPIO_ACTIVE_HIGH&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio7 10 GPIO_ACTIVE_LOW&gt;;</span>
 	wp-gpios = &lt;&amp;gpio3 19 GPIO_ACTIVE_HIGH&gt;;
 	keep-power-in-suspend;
 	enable-sdio-wakeup;
<span class="p_chunk">@@ -61,7 +61,7 @@</span> <span class="p_context"></span>
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc4&gt;;
 	bus-width = &lt;8&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio7 11 GPIO_ACTIVE_HIGH&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio7 11 GPIO_ACTIVE_LOW&gt;;</span>
 	no-1-8-v;
 	keep-power-in-suspend;
 	enable-sdio-wakup;
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6sx-sdb.dtsi b/arch/arm/boot/dts/imx6sx-sdb.dtsi</span>
<span class="p_header">index cef04cef3a80..ac88c3467078 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6sx-sdb.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6sx-sdb.dtsi</span>
<span class="p_chunk">@@ -293,7 +293,7 @@</span> <span class="p_context"></span>
 	pinctrl-1 = &lt;&amp;pinctrl_usdhc3_100mhz&gt;;
 	pinctrl-2 = &lt;&amp;pinctrl_usdhc3_200mhz&gt;;
 	bus-width = &lt;8&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio2 10 GPIO_ACTIVE_HIGH&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio2 10 GPIO_ACTIVE_LOW&gt;;</span>
 	wp-gpios = &lt;&amp;gpio2 15 GPIO_ACTIVE_HIGH&gt;;
 	keep-power-in-suspend;
 	enable-sdio-wakeup;
<span class="p_chunk">@@ -304,7 +304,7 @@</span> <span class="p_context"></span>
 &amp;usdhc4 {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_usdhc4&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio6 21 GPIO_ACTIVE_HIGH&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio6 21 GPIO_ACTIVE_LOW&gt;;</span>
 	wp-gpios = &lt;&amp;gpio6 20 GPIO_ACTIVE_HIGH&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/sun7i-a20.dtsi b/arch/arm/boot/dts/sun7i-a20.dtsi</span>
<span class="p_header">index 2b4847c7cbd4..fa36571b755a 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/sun7i-a20.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/sun7i-a20.dtsi</span>
<span class="p_chunk">@@ -111,7 +111,7 @@</span> <span class="p_context"></span>
 				720000  1200000
 				528000  1100000
 				312000  1000000
<span class="p_del">-				144000  900000</span>
<span class="p_add">+				144000  1000000</span>
 				&gt;;
 			#cooling-cells = &lt;2&gt;;
 			cooling-min-level = &lt;0&gt;;
<span class="p_header">diff --git a/arch/arm/kvm/Kconfig b/arch/arm/kvm/Kconfig</span>
<span class="p_header">index f1f79d104309..60c1a0f4d67a 100644</span>
<span class="p_header">--- a/arch/arm/kvm/Kconfig</span>
<span class="p_header">+++ b/arch/arm/kvm/Kconfig</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"> config KVM</span>
 	depends on MMU &amp;&amp; OF
 	select PREEMPT_NOTIFIERS
 	select ANON_INODES
<span class="p_add">+	select ARM_GIC</span>
 	select HAVE_KVM_CPU_RELAX_INTERCEPT
 	select HAVE_KVM_ARCH_TLB_FLUSH_ALL
 	select KVM_MMIO
<span class="p_header">diff --git a/arch/arm/plat-orion/common.c b/arch/arm/plat-orion/common.c</span>
<span class="p_header">index f5b00f41c4f6..b8b6e22f9987 100644</span>
<span class="p_header">--- a/arch/arm/plat-orion/common.c</span>
<span class="p_header">+++ b/arch/arm/plat-orion/common.c</span>
<span class="p_chunk">@@ -499,7 +499,7 @@</span> <span class="p_context"> void __init orion_ge00_switch_init(struct dsa_platform_data *d, int irq)</span>
 
 	d-&gt;netdev = &amp;orion_ge00.dev;
 	for (i = 0; i &lt; d-&gt;nr_chips; i++)
<span class="p_del">-		d-&gt;chip[i].host_dev = &amp;orion_ge00_shared.dev;</span>
<span class="p_add">+		d-&gt;chip[i].host_dev = &amp;orion_ge_mvmdio.dev;</span>
 	orion_switch_device.dev.platform_data = d;
 
 	platform_device_register(&amp;orion_switch_device);
<span class="p_header">diff --git a/arch/arm/vdso/vdsomunge.c b/arch/arm/vdso/vdsomunge.c</span>
<span class="p_header">index aedec81d1198..f6455273b2f8 100644</span>
<span class="p_header">--- a/arch/arm/vdso/vdsomunge.c</span>
<span class="p_header">+++ b/arch/arm/vdso/vdsomunge.c</span>
<span class="p_chunk">@@ -45,7 +45,6 @@</span> <span class="p_context"></span>
  * it does.
  */
 
<span class="p_del">-#include &lt;byteswap.h&gt;</span>
 #include &lt;elf.h&gt;
 #include &lt;errno.h&gt;
 #include &lt;fcntl.h&gt;
<span class="p_chunk">@@ -59,6 +58,16 @@</span> <span class="p_context"></span>
 #include &lt;sys/types.h&gt;
 #include &lt;unistd.h&gt;
 
<span class="p_add">+#define swab16(x) \</span>
<span class="p_add">+	((((x) &amp; 0x00ff) &lt;&lt; 8) | \</span>
<span class="p_add">+	 (((x) &amp; 0xff00) &gt;&gt; 8))</span>
<span class="p_add">+</span>
<span class="p_add">+#define swab32(x) \</span>
<span class="p_add">+	((((x) &amp; 0x000000ff) &lt;&lt; 24) | \</span>
<span class="p_add">+	 (((x) &amp; 0x0000ff00) &lt;&lt;  8) | \</span>
<span class="p_add">+	 (((x) &amp; 0x00ff0000) &gt;&gt;  8) | \</span>
<span class="p_add">+	 (((x) &amp; 0xff000000) &gt;&gt; 24))</span>
<span class="p_add">+</span>
 #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
 #define HOST_ORDER ELFDATA2LSB
 #elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
<span class="p_chunk">@@ -104,17 +113,17 @@</span> <span class="p_context"> static void cleanup(void)</span>
 
 static Elf32_Word read_elf_word(Elf32_Word word, bool swap)
 {
<span class="p_del">-	return swap ? bswap_32(word) : word;</span>
<span class="p_add">+	return swap ? swab32(word) : word;</span>
 }
 
 static Elf32_Half read_elf_half(Elf32_Half half, bool swap)
 {
<span class="p_del">-	return swap ? bswap_16(half) : half;</span>
<span class="p_add">+	return swap ? swab16(half) : half;</span>
 }
 
 static void write_elf_word(Elf32_Word val, Elf32_Word *dst, bool swap)
 {
<span class="p_del">-	*dst = swap ? bswap_32(val) : val;</span>
<span class="p_add">+	*dst = swap ? swab32(val) : val;</span>
 }
 
 int main(int argc, char **argv)
<span class="p_header">diff --git a/arch/arm64/include/asm/cpuidle.h b/arch/arm64/include/asm/cpuidle.h</span>
<span class="p_header">index 141b2fcabaa6..0f74f05d662a 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/cpuidle.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/cpuidle.h</span>
<span class="p_chunk">@@ -5,20 +5,16 @@</span> <span class="p_context"></span>
 
 #ifdef CONFIG_CPU_IDLE
 extern int arm_cpuidle_init(unsigned int cpu);
<span class="p_del">-extern int cpu_suspend(unsigned long arg);</span>
<span class="p_add">+extern int arm_cpuidle_suspend(int index);</span>
 #else
 static inline int arm_cpuidle_init(unsigned int cpu)
 {
 	return -EOPNOTSUPP;
 }
 
<span class="p_del">-static inline int cpu_suspend(unsigned long arg)</span>
<span class="p_add">+static inline int arm_cpuidle_suspend(int index)</span>
 {
 	return -EOPNOTSUPP;
 }
 #endif
<span class="p_del">-static inline int arm_cpuidle_suspend(int index)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return cpu_suspend(index);</span>
<span class="p_del">-}</span>
 #endif
<span class="p_header">diff --git a/arch/arm64/include/asm/suspend.h b/arch/arm64/include/asm/suspend.h</span>
<span class="p_header">index 003802f58963..59a5b0f1e81c 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/suspend.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/suspend.h</span>
<span class="p_chunk">@@ -21,6 +21,6 @@</span> <span class="p_context"> struct sleep_save_sp {</span>
 	phys_addr_t save_ptr_stash_phys;
 };
 
<span class="p_del">-extern int __cpu_suspend(unsigned long arg, int (*fn)(unsigned long));</span>
<span class="p_add">+extern int cpu_suspend(unsigned long arg, int (*fn)(unsigned long));</span>
 extern void cpu_resume(void);
 #endif
<span class="p_header">diff --git a/arch/arm64/kernel/armv8_deprecated.c b/arch/arm64/kernel/armv8_deprecated.c</span>
<span class="p_header">index 7922c2e710ca..7ac3920b1356 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/armv8_deprecated.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/armv8_deprecated.c</span>
<span class="p_chunk">@@ -279,22 +279,24 @@</span> <span class="p_context"> static void register_insn_emulation_sysctl(struct ctl_table *table)</span>
  */
 #define __user_swpX_asm(data, addr, res, temp, B)		\
 	__asm__ __volatile__(					\
<span class="p_del">-	&quot;	mov		%w2, %w1\n&quot;			\</span>
<span class="p_del">-	&quot;0:	ldxr&quot;B&quot;		%w1, [%3]\n&quot;			\</span>
<span class="p_del">-	&quot;1:	stxr&quot;B&quot;		%w0, %w2, [%3]\n&quot;		\</span>
<span class="p_add">+	&quot;0:	ldxr&quot;B&quot;		%w2, [%3]\n&quot;			\</span>
<span class="p_add">+	&quot;1:	stxr&quot;B&quot;		%w0, %w1, [%3]\n&quot;		\</span>
 	&quot;	cbz		%w0, 2f\n&quot;			\
 	&quot;	mov		%w0, %w4\n&quot;			\
<span class="p_add">+	&quot;	b		3f\n&quot;				\</span>
 	&quot;2:\n&quot;							\
<span class="p_add">+	&quot;	mov		%w1, %w2\n&quot;			\</span>
<span class="p_add">+	&quot;3:\n&quot;							\</span>
 	&quot;	.pushsection	 .fixup,\&quot;ax\&quot;\n&quot;		\
 	&quot;	.align		2\n&quot;				\
<span class="p_del">-	&quot;3:	mov		%w0, %w5\n&quot;			\</span>
<span class="p_del">-	&quot;	b		2b\n&quot;				\</span>
<span class="p_add">+	&quot;4:	mov		%w0, %w5\n&quot;			\</span>
<span class="p_add">+	&quot;	b		3b\n&quot;				\</span>
 	&quot;	.popsection&quot;					\
 	&quot;	.pushsection	 __ex_table,\&quot;a\&quot;\n&quot;		\
 	&quot;	.align		3\n&quot;				\
<span class="p_del">-	&quot;	.quad		0b, 3b\n&quot;			\</span>
<span class="p_del">-	&quot;	.quad		1b, 3b\n&quot;			\</span>
<span class="p_del">-	&quot;	.popsection&quot;					\</span>
<span class="p_add">+	&quot;	.quad		0b, 4b\n&quot;			\</span>
<span class="p_add">+	&quot;	.quad		1b, 4b\n&quot;			\</span>
<span class="p_add">+	&quot;	.popsection\n&quot;					\</span>
 	: &quot;=&amp;r&quot; (res), &quot;+r&quot; (data), &quot;=&amp;r&quot; (temp)		\
 	: &quot;r&quot; (addr), &quot;i&quot; (-EAGAIN), &quot;i&quot; (-EFAULT)		\
 	: &quot;memory&quot;)
<span class="p_header">diff --git a/arch/arm64/kernel/cpuidle.c b/arch/arm64/kernel/cpuidle.c</span>
<span class="p_header">index a78143a5c99f..2bbd0fee084f 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/cpuidle.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/cpuidle.c</span>
<span class="p_chunk">@@ -37,7 +37,7 @@</span> <span class="p_context"> int arm_cpuidle_init(unsigned int cpu)</span>
  * Return: 0 on success, -EOPNOTSUPP if CPU suspend hook not initialized, CPU
  * operations back-end error code otherwise.
  */
<span class="p_del">-int cpu_suspend(unsigned long arg)</span>
<span class="p_add">+int arm_cpuidle_suspend(int index)</span>
 {
 	int cpu = smp_processor_id();
 
<span class="p_chunk">@@ -47,5 +47,5 @@</span> <span class="p_context"> int cpu_suspend(unsigned long arg)</span>
 	 */
 	if (!cpu_ops[cpu] || !cpu_ops[cpu]-&gt;cpu_suspend)
 		return -EOPNOTSUPP;
<span class="p_del">-	return cpu_ops[cpu]-&gt;cpu_suspend(arg);</span>
<span class="p_add">+	return cpu_ops[cpu]-&gt;cpu_suspend(index);</span>
 }
<span class="p_header">diff --git a/arch/arm64/kernel/psci.c b/arch/arm64/kernel/psci.c</span>
<span class="p_header">index ea18cb53921e..24d4733b7e3c 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/psci.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/psci.c</span>
<span class="p_chunk">@@ -546,7 +546,7 @@</span> <span class="p_context"> static int __maybe_unused cpu_psci_cpu_suspend(unsigned long index)</span>
 	if (state[index - 1].type == PSCI_POWER_STATE_TYPE_STANDBY)
 		ret = psci_ops.cpu_suspend(state[index - 1], 0);
 	else
<span class="p_del">-		ret = __cpu_suspend(index, psci_suspend_finisher);</span>
<span class="p_add">+		ret = cpu_suspend(index, psci_suspend_finisher);</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/arch/arm64/kernel/stacktrace.c b/arch/arm64/kernel/stacktrace.c</span>
<span class="p_header">index 407991bf79f5..ccb6078ed9f2 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/stacktrace.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/stacktrace.c</span>
<span class="p_chunk">@@ -48,11 +48,7 @@</span> <span class="p_context"> int notrace unwind_frame(struct stackframe *frame)</span>
 
 	frame-&gt;sp = fp + 0x10;
 	frame-&gt;fp = *(unsigned long *)(fp);
<span class="p_del">-	/*</span>
<span class="p_del">-	 * -4 here because we care about the PC at time of bl,</span>
<span class="p_del">-	 * not where the return will go.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	frame-&gt;pc = *(unsigned long *)(fp + 8) - 4;</span>
<span class="p_add">+	frame-&gt;pc = *(unsigned long *)(fp + 8);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/arch/arm64/kernel/suspend.c b/arch/arm64/kernel/suspend.c</span>
<span class="p_header">index d7daf45ae7a2..53f1f8dccf6c 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/suspend.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/suspend.c</span>
<span class="p_chunk">@@ -51,13 +51,13 @@</span> <span class="p_context"> void __init cpu_suspend_set_dbg_restorer(void (*hw_bp_restore)(void *))</span>
 }
 
 /*
<span class="p_del">- * __cpu_suspend</span>
<span class="p_add">+ * cpu_suspend</span>
  *
  * arg: argument to pass to the finisher function
  * fn: finisher function pointer
  *
  */
<span class="p_del">-int __cpu_suspend(unsigned long arg, int (*fn)(unsigned long))</span>
<span class="p_add">+int cpu_suspend(unsigned long arg, int (*fn)(unsigned long))</span>
 {
 	struct mm_struct *mm = current-&gt;active_mm;
 	int ret;
<span class="p_chunk">@@ -80,17 +80,21 @@</span> <span class="p_context"> int __cpu_suspend(unsigned long arg, int (*fn)(unsigned long))</span>
 	if (ret == 0) {
 		/*
 		 * We are resuming from reset with TTBR0_EL1 set to the
<span class="p_del">-		 * idmap to enable the MMU; restore the active_mm mappings in</span>
<span class="p_del">-		 * TTBR0_EL1 unless the active_mm == &amp;init_mm, in which case</span>
<span class="p_del">-		 * the thread entered __cpu_suspend with TTBR0_EL1 set to</span>
<span class="p_del">-		 * reserved TTBR0 page tables and should be restored as such.</span>
<span class="p_add">+		 * idmap to enable the MMU; set the TTBR0 to the reserved</span>
<span class="p_add">+		 * page tables to prevent speculative TLB allocations, flush</span>
<span class="p_add">+		 * the local tlb and set the default tcr_el1.t0sz so that</span>
<span class="p_add">+		 * the TTBR0 address space set-up is properly restored.</span>
<span class="p_add">+		 * If the current active_mm != &amp;init_mm we entered cpu_suspend</span>
<span class="p_add">+		 * with mappings in TTBR0 that must be restored, so we switch</span>
<span class="p_add">+		 * them back to complete the address space configuration</span>
<span class="p_add">+		 * restoration before returning.</span>
 		 */
<span class="p_del">-		if (mm == &amp;init_mm)</span>
<span class="p_del">-			cpu_set_reserved_ttbr0();</span>
<span class="p_del">-		else</span>
<span class="p_del">-			cpu_switch_mm(mm-&gt;pgd, mm);</span>
<span class="p_del">-</span>
<span class="p_add">+		cpu_set_reserved_ttbr0();</span>
 		flush_tlb_all();
<span class="p_add">+		cpu_set_default_tcr_t0sz();</span>
<span class="p_add">+</span>
<span class="p_add">+		if (mm != &amp;init_mm)</span>
<span class="p_add">+			cpu_switch_mm(mm-&gt;pgd, mm);</span>
 
 		/*
 		 * Restore per-cpu offset before any kernel
<span class="p_header">diff --git a/arch/powerpc/kernel/rtas.c b/arch/powerpc/kernel/rtas.c</span>
<span class="p_header">index caffb10e7aa3..5607693f35cf 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/rtas.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/rtas.c</span>
<span class="p_chunk">@@ -1041,6 +1041,9 @@</span> <span class="p_context"> asmlinkage int ppc_rtas(struct rtas_args __user *uargs)</span>
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
<span class="p_add">+	if (!rtas.entry)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if (copy_from_user(&amp;args, uargs, 3 * sizeof(u32)) != 0)
 		return -EFAULT;
 
<span class="p_header">diff --git a/arch/x86/boot/compressed/eboot.c b/arch/x86/boot/compressed/eboot.c</span>
<span class="p_header">index 0cdc154a22b5..4c3f76b425c1 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/eboot.c</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/eboot.c</span>
<span class="p_chunk">@@ -667,6 +667,7 @@</span> <span class="p_context"> setup_gop32(struct screen_info *si, efi_guid_t *proto,</span>
 		bool conout_found = false;
 		void *dummy = NULL;
 		u32 h = handles[i];
<span class="p_add">+		u32 current_fb_base;</span>
 
 		status = efi_call_early(handle_protocol, h,
 					proto, (void **)&amp;gop32);
<span class="p_chunk">@@ -678,7 +679,7 @@</span> <span class="p_context"> setup_gop32(struct screen_info *si, efi_guid_t *proto,</span>
 		if (status == EFI_SUCCESS)
 			conout_found = true;
 
<span class="p_del">-		status = __gop_query32(gop32, &amp;info, &amp;size, &amp;fb_base);</span>
<span class="p_add">+		status = __gop_query32(gop32, &amp;info, &amp;size, &amp;current_fb_base);</span>
 		if (status == EFI_SUCCESS &amp;&amp; (!first_gop || conout_found)) {
 			/*
 			 * Systems that use the UEFI Console Splitter may
<span class="p_chunk">@@ -692,6 +693,7 @@</span> <span class="p_context"> setup_gop32(struct screen_info *si, efi_guid_t *proto,</span>
 			pixel_format = info-&gt;pixel_format;
 			pixel_info = info-&gt;pixel_information;
 			pixels_per_scan_line = info-&gt;pixels_per_scan_line;
<span class="p_add">+			fb_base = current_fb_base;</span>
 
 			/*
 			 * Once we&#39;ve found a GOP supporting ConOut,
<span class="p_chunk">@@ -770,6 +772,7 @@</span> <span class="p_context"> setup_gop64(struct screen_info *si, efi_guid_t *proto,</span>
 		bool conout_found = false;
 		void *dummy = NULL;
 		u64 h = handles[i];
<span class="p_add">+		u32 current_fb_base;</span>
 
 		status = efi_call_early(handle_protocol, h,
 					proto, (void **)&amp;gop64);
<span class="p_chunk">@@ -781,7 +784,7 @@</span> <span class="p_context"> setup_gop64(struct screen_info *si, efi_guid_t *proto,</span>
 		if (status == EFI_SUCCESS)
 			conout_found = true;
 
<span class="p_del">-		status = __gop_query64(gop64, &amp;info, &amp;size, &amp;fb_base);</span>
<span class="p_add">+		status = __gop_query64(gop64, &amp;info, &amp;size, &amp;current_fb_base);</span>
 		if (status == EFI_SUCCESS &amp;&amp; (!first_gop || conout_found)) {
 			/*
 			 * Systems that use the UEFI Console Splitter may
<span class="p_chunk">@@ -795,6 +798,7 @@</span> <span class="p_context"> setup_gop64(struct screen_info *si, efi_guid_t *proto,</span>
 			pixel_format = info-&gt;pixel_format;
 			pixel_info = info-&gt;pixel_information;
 			pixels_per_scan_line = info-&gt;pixels_per_scan_line;
<span class="p_add">+			fb_base = current_fb_base;</span>
 
 			/*
 			 * Once we&#39;ve found a GOP supporting ConOut,
<span class="p_header">diff --git a/arch/x86/xen/enlighten.c b/arch/x86/xen/enlighten.c</span>
<span class="p_header">index 0cc657160cb6..a10ed8915bf4 100644</span>
<span class="p_header">--- a/arch/x86/xen/enlighten.c</span>
<span class="p_header">+++ b/arch/x86/xen/enlighten.c</span>
<span class="p_chunk">@@ -33,7 +33,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/memblock.h&gt;
 #include &lt;linux/edd.h&gt;
 
<span class="p_del">-#ifdef CONFIG_KEXEC_CORE</span>
<span class="p_add">+#ifdef CONFIG_KEXEC</span>
 #include &lt;linux/kexec.h&gt;
 #endif
 
<span class="p_chunk">@@ -1802,7 +1802,7 @@</span> <span class="p_context"> static struct notifier_block xen_hvm_cpu_notifier = {</span>
 	.notifier_call	= xen_hvm_cpu_notify,
 };
 
<span class="p_del">-#ifdef CONFIG_KEXEC_CORE</span>
<span class="p_add">+#ifdef CONFIG_KEXEC</span>
 static void xen_hvm_shutdown(void)
 {
 	native_machine_shutdown();
<span class="p_chunk">@@ -1836,7 +1836,7 @@</span> <span class="p_context"> static void __init xen_hvm_guest_init(void)</span>
 	x86_init.irqs.intr_init = xen_init_IRQ;
 	xen_hvm_init_time_ops();
 	xen_hvm_init_mmu_ops();
<span class="p_del">-#ifdef CONFIG_KEXEC_CORE</span>
<span class="p_add">+#ifdef CONFIG_KEXEC</span>
 	machine_ops.shutdown = xen_hvm_shutdown;
 	machine_ops.crash_shutdown = xen_hvm_crash_shutdown;
 #endif
<span class="p_header">diff --git a/crypto/ablkcipher.c b/crypto/ablkcipher.c</span>
<span class="p_header">index db201bca1581..523dd10e1751 100644</span>
<span class="p_header">--- a/crypto/ablkcipher.c</span>
<span class="p_header">+++ b/crypto/ablkcipher.c</span>
<span class="p_chunk">@@ -698,7 +698,7 @@</span> <span class="p_context"> struct crypto_ablkcipher *crypto_alloc_ablkcipher(const char *alg_name,</span>
 err:
 		if (err != -EAGAIN)
 			break;
<span class="p_del">-		if (signal_pending(current)) {</span>
<span class="p_add">+		if (fatal_signal_pending(current)) {</span>
 			err = -EINTR;
 			break;
 		}
<span class="p_header">diff --git a/crypto/algapi.c b/crypto/algapi.c</span>
<span class="p_header">index d2627a3d4ed8..dda720c6ab08 100644</span>
<span class="p_header">--- a/crypto/algapi.c</span>
<span class="p_header">+++ b/crypto/algapi.c</span>
<span class="p_chunk">@@ -337,7 +337,7 @@</span> <span class="p_context"> static void crypto_wait_for_test(struct crypto_larval *larval)</span>
 		crypto_alg_tested(larval-&gt;alg.cra_driver_name, 0);
 	}
 
<span class="p_del">-	err = wait_for_completion_interruptible(&amp;larval-&gt;completion);</span>
<span class="p_add">+	err = wait_for_completion_killable(&amp;larval-&gt;completion);</span>
 	WARN_ON(err);
 
 out:
<span class="p_header">diff --git a/crypto/api.c b/crypto/api.c</span>
<span class="p_header">index afe4610afc4b..bbc147cb5dec 100644</span>
<span class="p_header">--- a/crypto/api.c</span>
<span class="p_header">+++ b/crypto/api.c</span>
<span class="p_chunk">@@ -172,7 +172,7 @@</span> <span class="p_context"> static struct crypto_alg *crypto_larval_wait(struct crypto_alg *alg)</span>
 	struct crypto_larval *larval = (void *)alg;
 	long timeout;
 
<span class="p_del">-	timeout = wait_for_completion_interruptible_timeout(</span>
<span class="p_add">+	timeout = wait_for_completion_killable_timeout(</span>
 		&amp;larval-&gt;completion, 60 * HZ);
 
 	alg = larval-&gt;adult;
<span class="p_chunk">@@ -445,7 +445,7 @@</span> <span class="p_context"> struct crypto_tfm *crypto_alloc_base(const char *alg_name, u32 type, u32 mask)</span>
 err:
 		if (err != -EAGAIN)
 			break;
<span class="p_del">-		if (signal_pending(current)) {</span>
<span class="p_add">+		if (fatal_signal_pending(current)) {</span>
 			err = -EINTR;
 			break;
 		}
<span class="p_chunk">@@ -562,7 +562,7 @@</span> <span class="p_context"> void *crypto_alloc_tfm(const char *alg_name,</span>
 err:
 		if (err != -EAGAIN)
 			break;
<span class="p_del">-		if (signal_pending(current)) {</span>
<span class="p_add">+		if (fatal_signal_pending(current)) {</span>
 			err = -EINTR;
 			break;
 		}
<span class="p_header">diff --git a/crypto/crypto_user.c b/crypto/crypto_user.c</span>
<span class="p_header">index 41dfe762b7fb..edf2e3ea1740 100644</span>
<span class="p_header">--- a/crypto/crypto_user.c</span>
<span class="p_header">+++ b/crypto/crypto_user.c</span>
<span class="p_chunk">@@ -381,7 +381,7 @@</span> <span class="p_context"> static struct crypto_alg *crypto_user_aead_alg(const char *name, u32 type,</span>
 		err = PTR_ERR(alg);
 		if (err != -EAGAIN)
 			break;
<span class="p_del">-		if (signal_pending(current)) {</span>
<span class="p_add">+		if (fatal_signal_pending(current)) {</span>
 			err = -EINTR;
 			break;
 		}
<span class="p_header">diff --git a/drivers/block/nvme-core.c b/drivers/block/nvme-core.c</span>
<span class="p_header">index 683dff272562..04c0e8f3183c 100644</span>
<span class="p_header">--- a/drivers/block/nvme-core.c</span>
<span class="p_header">+++ b/drivers/block/nvme-core.c</span>
<span class="p_chunk">@@ -590,6 +590,7 @@</span> <span class="p_context"> static void req_completion(struct nvme_queue *nvmeq, void *ctx,</span>
 	struct nvme_iod *iod = ctx;
 	struct request *req = iod_get_private(iod);
 	struct nvme_cmd_info *cmd_rq = blk_mq_rq_to_pdu(req);
<span class="p_add">+	bool requeue = false;</span>
 
 	u16 status = le16_to_cpup(&amp;cqe-&gt;status) &gt;&gt; 1;
 
<span class="p_chunk">@@ -598,12 +599,13 @@</span> <span class="p_context"> static void req_completion(struct nvme_queue *nvmeq, void *ctx,</span>
 		    &amp;&amp; (jiffies - req-&gt;start_time) &lt; req-&gt;timeout) {
 			unsigned long flags;
 
<span class="p_add">+			requeue = true;</span>
 			blk_mq_requeue_request(req);
 			spin_lock_irqsave(req-&gt;q-&gt;queue_lock, flags);
 			if (!blk_queue_stopped(req-&gt;q))
 				blk_mq_kick_requeue_list(req-&gt;q);
 			spin_unlock_irqrestore(req-&gt;q-&gt;queue_lock, flags);
<span class="p_del">-			return;</span>
<span class="p_add">+			goto release_iod;</span>
 		}
 		req-&gt;errors = nvme_error_status(status);
 	} else
<span class="p_chunk">@@ -613,7 +615,7 @@</span> <span class="p_context"> static void req_completion(struct nvme_queue *nvmeq, void *ctx,</span>
 		dev_warn(&amp;nvmeq-&gt;dev-&gt;pci_dev-&gt;dev,
 			&quot;completing aborted command with status:%04x\n&quot;,
 			status);
<span class="p_del">-</span>
<span class="p_add">+ release_iod:</span>
 	if (iod-&gt;nents) {
 		dma_unmap_sg(&amp;nvmeq-&gt;dev-&gt;pci_dev-&gt;dev, iod-&gt;sg, iod-&gt;nents,
 			rq_data_dir(req) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
<span class="p_chunk">@@ -626,7 +628,8 @@</span> <span class="p_context"> static void req_completion(struct nvme_queue *nvmeq, void *ctx,</span>
 	}
 	nvme_free_iod(nvmeq-&gt;dev, iod);
 
<span class="p_del">-	blk_mq_complete_request(req);</span>
<span class="p_add">+	if (likely(!requeue))</span>
<span class="p_add">+		blk_mq_complete_request(req);</span>
 }
 
 /* length is in bytes.  gfp flags indicates whether we may sleep. */
<span class="p_header">diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c</span>
<span class="p_header">index fe8f1e4b4c7c..1ec6441fe2a5 100644</span>
<span class="p_header">--- a/drivers/block/rbd.c</span>
<span class="p_header">+++ b/drivers/block/rbd.c</span>
<span class="p_chunk">@@ -96,6 +96,8 @@</span> <span class="p_context"> static int atomic_dec_return_safe(atomic_t *v)</span>
 #define RBD_MINORS_PER_MAJOR		256
 #define RBD_SINGLE_MAJOR_PART_SHIFT	4
 
<span class="p_add">+#define RBD_MAX_PARENT_CHAIN_LEN	16</span>
<span class="p_add">+</span>
 #define RBD_SNAP_DEV_NAME_PREFIX	&quot;snap_&quot;
 #define RBD_MAX_SNAP_NAME_LEN	\
 			(NAME_MAX - (sizeof (RBD_SNAP_DEV_NAME_PREFIX) - 1))
<span class="p_chunk">@@ -425,7 +427,7 @@</span> <span class="p_context"> static ssize_t rbd_add_single_major(struct bus_type *bus, const char *buf,</span>
 				    size_t count);
 static ssize_t rbd_remove_single_major(struct bus_type *bus, const char *buf,
 				       size_t count);
<span class="p_del">-static int rbd_dev_image_probe(struct rbd_device *rbd_dev, bool mapping);</span>
<span class="p_add">+static int rbd_dev_image_probe(struct rbd_device *rbd_dev, int depth);</span>
 static void rbd_spec_put(struct rbd_spec *spec);
 
 static int rbd_dev_id_to_minor(int dev_id)
<span class="p_chunk">@@ -3797,6 +3799,9 @@</span> <span class="p_context"> static int rbd_init_disk(struct rbd_device *rbd_dev)</span>
 	q-&gt;limits.discard_zeroes_data = 1;
 
 	blk_queue_merge_bvec(q, rbd_merge_bvec);
<span class="p_add">+	if (!ceph_test_opt(rbd_dev-&gt;rbd_client-&gt;client, NOCRC))</span>
<span class="p_add">+		q-&gt;backing_dev_info.capabilities |= BDI_CAP_STABLE_WRITES;</span>
<span class="p_add">+</span>
 	disk-&gt;queue = q;
 
 	q-&gt;queuedata = rbd_dev;
<span class="p_chunk">@@ -5142,44 +5147,50 @@</span> <span class="p_context"> out_err:</span>
 	return ret;
 }
 
<span class="p_del">-static int rbd_dev_probe_parent(struct rbd_device *rbd_dev)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * @depth is rbd_dev_image_probe() -&gt; rbd_dev_probe_parent() -&gt;</span>
<span class="p_add">+ * rbd_dev_image_probe() recursion depth, which means it&#39;s also the</span>
<span class="p_add">+ * length of the already discovered part of the parent chain.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int rbd_dev_probe_parent(struct rbd_device *rbd_dev, int depth)</span>
 {
 	struct rbd_device *parent = NULL;
<span class="p_del">-	struct rbd_spec *parent_spec;</span>
<span class="p_del">-	struct rbd_client *rbdc;</span>
 	int ret;
 
 	if (!rbd_dev-&gt;parent_spec)
 		return 0;
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We need to pass a reference to the client and the parent</span>
<span class="p_del">-	 * spec when creating the parent rbd_dev.  Images related by</span>
<span class="p_del">-	 * parent/child relationships always share both.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	parent_spec = rbd_spec_get(rbd_dev-&gt;parent_spec);</span>
<span class="p_del">-	rbdc = __rbd_get_client(rbd_dev-&gt;rbd_client);</span>
 
<span class="p_del">-	ret = -ENOMEM;</span>
<span class="p_del">-	parent = rbd_dev_create(rbdc, parent_spec);</span>
<span class="p_del">-	if (!parent)</span>
<span class="p_add">+	if (++depth &gt; RBD_MAX_PARENT_CHAIN_LEN) {</span>
<span class="p_add">+		pr_info(&quot;parent chain is too long (%d)\n&quot;, depth);</span>
<span class="p_add">+		ret = -EINVAL;</span>
 		goto out_err;
<span class="p_add">+	}</span>
 
<span class="p_del">-	ret = rbd_dev_image_probe(parent, false);</span>
<span class="p_add">+	parent = rbd_dev_create(rbd_dev-&gt;rbd_client, rbd_dev-&gt;parent_spec);</span>
<span class="p_add">+	if (!parent) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto out_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Images related by parent/child relationships always share</span>
<span class="p_add">+	 * rbd_client and spec/parent_spec, so bump their refcounts.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	__rbd_get_client(rbd_dev-&gt;rbd_client);</span>
<span class="p_add">+	rbd_spec_get(rbd_dev-&gt;parent_spec);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = rbd_dev_image_probe(parent, depth);</span>
 	if (ret &lt; 0)
 		goto out_err;
<span class="p_add">+</span>
 	rbd_dev-&gt;parent = parent;
 	atomic_set(&amp;rbd_dev-&gt;parent_ref, 1);
<span class="p_del">-</span>
 	return 0;
<span class="p_add">+</span>
 out_err:
<span class="p_del">-	if (parent) {</span>
<span class="p_del">-		rbd_dev_unparent(rbd_dev);</span>
<span class="p_add">+	rbd_dev_unparent(rbd_dev);</span>
<span class="p_add">+	if (parent)</span>
 		rbd_dev_destroy(parent);
<span class="p_del">-	} else {</span>
<span class="p_del">-		rbd_put_client(rbdc);</span>
<span class="p_del">-		rbd_spec_put(parent_spec);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -5297,7 +5308,7 @@</span> <span class="p_context"> static void rbd_dev_image_release(struct rbd_device *rbd_dev)</span>
  * parent), initiate a watch on its header object before using that
  * object to get detailed information about the rbd image.
  */
<span class="p_del">-static int rbd_dev_image_probe(struct rbd_device *rbd_dev, bool mapping)</span>
<span class="p_add">+static int rbd_dev_image_probe(struct rbd_device *rbd_dev, int depth)</span>
 {
 	int ret;
 
<span class="p_chunk">@@ -5315,7 +5326,7 @@</span> <span class="p_context"> static int rbd_dev_image_probe(struct rbd_device *rbd_dev, bool mapping)</span>
 	if (ret)
 		goto err_out_format;
 
<span class="p_del">-	if (mapping) {</span>
<span class="p_add">+	if (!depth) {</span>
 		ret = rbd_dev_header_watch_sync(rbd_dev);
 		if (ret) {
 			if (ret == -ENOENT)
<span class="p_chunk">@@ -5336,7 +5347,7 @@</span> <span class="p_context"> static int rbd_dev_image_probe(struct rbd_device *rbd_dev, bool mapping)</span>
 	 * Otherwise this is a parent image, identified by pool, image
 	 * and snap ids - need to fill in names for those ids.
 	 */
<span class="p_del">-	if (mapping)</span>
<span class="p_add">+	if (!depth)</span>
 		ret = rbd_spec_fill_snap_id(rbd_dev);
 	else
 		ret = rbd_spec_fill_names(rbd_dev);
<span class="p_chunk">@@ -5358,12 +5369,12 @@</span> <span class="p_context"> static int rbd_dev_image_probe(struct rbd_device *rbd_dev, bool mapping)</span>
 		 * Need to warn users if this image is the one being
 		 * mapped and has a parent.
 		 */
<span class="p_del">-		if (mapping &amp;&amp; rbd_dev-&gt;parent_spec)</span>
<span class="p_add">+		if (!depth &amp;&amp; rbd_dev-&gt;parent_spec)</span>
 			rbd_warn(rbd_dev,
 				 &quot;WARNING: kernel layering is EXPERIMENTAL!&quot;);
 	}
 
<span class="p_del">-	ret = rbd_dev_probe_parent(rbd_dev);</span>
<span class="p_add">+	ret = rbd_dev_probe_parent(rbd_dev, depth);</span>
 	if (ret)
 		goto err_out_probe;
 
<span class="p_chunk">@@ -5374,7 +5385,7 @@</span> <span class="p_context"> static int rbd_dev_image_probe(struct rbd_device *rbd_dev, bool mapping)</span>
 err_out_probe:
 	rbd_dev_unprobe(rbd_dev);
 err_out_watch:
<span class="p_del">-	if (mapping)</span>
<span class="p_add">+	if (!depth)</span>
 		rbd_dev_header_unwatch_sync(rbd_dev);
 out_header_name:
 	kfree(rbd_dev-&gt;header_name);
<span class="p_chunk">@@ -5439,7 +5450,7 @@</span> <span class="p_context"> static ssize_t do_rbd_add(struct bus_type *bus,</span>
 	rbdc = NULL;		/* rbd_dev now owns this */
 	spec = NULL;		/* rbd_dev now owns this */
 
<span class="p_del">-	rc = rbd_dev_image_probe(rbd_dev, true);</span>
<span class="p_add">+	rc = rbd_dev_image_probe(rbd_dev, 0);</span>
 	if (rc &lt; 0)
 		goto err_out_rbd_dev;
 
<span class="p_header">diff --git a/drivers/block/xen-blkfront.c b/drivers/block/xen-blkfront.c</span>
<span class="p_header">index 89c7371ab2dc..42ef86c409b6 100644</span>
<span class="p_header">--- a/drivers/block/xen-blkfront.c</span>
<span class="p_header">+++ b/drivers/block/xen-blkfront.c</span>
<span class="p_chunk">@@ -1925,7 +1925,8 @@</span> <span class="p_context"> static void blkback_changed(struct xenbus_device *dev,</span>
 			break;
 		/* Missed the backend&#39;s Closing state -- fallthrough */
 	case XenbusStateClosing:
<span class="p_del">-		blkfront_closing(info);</span>
<span class="p_add">+		if (info)</span>
<span class="p_add">+			blkfront_closing(info);</span>
 		break;
 	}
 }
<span class="p_header">diff --git a/drivers/cpufreq/intel_pstate.c b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">index e8d16997c5cb..1ee2ab58e37d 100644</span>
<span class="p_header">--- a/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">+++ b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_chunk">@@ -761,6 +761,11 @@</span> <span class="p_context"> static inline void intel_pstate_sample(struct cpudata *cpu)</span>
 	local_irq_save(flags);
 	rdmsrl(MSR_IA32_APERF, aperf);
 	rdmsrl(MSR_IA32_MPERF, mperf);
<span class="p_add">+	if (cpu-&gt;prev_mperf == mperf) {</span>
<span class="p_add">+		local_irq_restore(flags);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	local_irq_restore(flags);
 
 	cpu-&gt;last_sample_time = cpu-&gt;sample.time;
<span class="p_header">diff --git a/drivers/edac/sb_edac.c b/drivers/edac/sb_edac.c</span>
<span class="p_header">index 1acf57ba4c86..cd6b9c72c8ac 100644</span>
<span class="p_header">--- a/drivers/edac/sb_edac.c</span>
<span class="p_header">+++ b/drivers/edac/sb_edac.c</span>
<span class="p_chunk">@@ -1608,6 +1608,7 @@</span> <span class="p_context"> static int sbridge_mci_bind_devs(struct mem_ctl_info *mci,</span>
 {
 	struct sbridge_pvt *pvt = mci-&gt;pvt_info;
 	struct pci_dev *pdev;
<span class="p_add">+	u8 saw_chan_mask = 0;</span>
 	int i;
 
 	for (i = 0; i &lt; sbridge_dev-&gt;n_devs; i++) {
<span class="p_chunk">@@ -1641,6 +1642,7 @@</span> <span class="p_context"> static int sbridge_mci_bind_devs(struct mem_ctl_info *mci,</span>
 		{
 			int id = pdev-&gt;device - PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_TAD0;
 			pvt-&gt;pci_tad[id] = pdev;
<span class="p_add">+			saw_chan_mask |= 1 &lt;&lt; id;</span>
 		}
 			break;
 		case PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_DDRIO:
<span class="p_chunk">@@ -1661,10 +1663,8 @@</span> <span class="p_context"> static int sbridge_mci_bind_devs(struct mem_ctl_info *mci,</span>
 	    !pvt-&gt; pci_tad || !pvt-&gt;pci_ras  || !pvt-&gt;pci_ta)
 		goto enodev;
 
<span class="p_del">-	for (i = 0; i &lt; NUM_CHANNELS; i++) {</span>
<span class="p_del">-		if (!pvt-&gt;pci_tad[i])</span>
<span class="p_del">-			goto enodev;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (saw_chan_mask != 0x0f)</span>
<span class="p_add">+		goto enodev;</span>
 	return 0;
 
 enodev:
<span class="p_header">diff --git a/drivers/gpu/drm/drm_dp_mst_topology.c b/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_header">index 2a2eb96caeda..109e776345d3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_chunk">@@ -1179,17 +1179,18 @@</span> <span class="p_context"> static struct drm_dp_mst_branch *drm_dp_get_mst_branch_device(struct drm_dp_mst_</span>
 
 		list_for_each_entry(port, &amp;mstb-&gt;ports, next) {
 			if (port-&gt;port_num == port_num) {
<span class="p_del">-				if (!port-&gt;mstb) {</span>
<span class="p_add">+				mstb = port-&gt;mstb;</span>
<span class="p_add">+				if (!mstb) {</span>
 					DRM_ERROR(&quot;failed to lookup MSTB with lct %d, rad %02x\n&quot;, lct, rad[0]);
<span class="p_del">-					return NULL;</span>
<span class="p_add">+					goto out;</span>
 				}
 
<span class="p_del">-				mstb = port-&gt;mstb;</span>
 				break;
 			}
 		}
 	}
 	kref_get(&amp;mstb-&gt;kref);
<span class="p_add">+out:</span>
 	mutex_unlock(&amp;mgr-&gt;lock);
 	return mstb;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem_userptr.c b/drivers/gpu/drm/i915/i915_gem_userptr.c</span>
<span class="p_header">index 1719078c763a..ce175d05260b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem_userptr.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem_userptr.c</span>
<span class="p_chunk">@@ -776,7 +776,10 @@</span> <span class="p_context"> static const struct drm_i915_gem_object_ops i915_gem_userptr_ops = {</span>
  * Also note, that the object created here is not currently a &quot;first class&quot;
  * object, in that several ioctls are banned. These are the CPU access
  * ioctls: mmap(), pwrite and pread. In practice, you are expected to use
<span class="p_del">- * direct access via your pointer rather than use those ioctls.</span>
<span class="p_add">+ * direct access via your pointer rather than use those ioctls. Another</span>
<span class="p_add">+ * restriction is that we do not allow userptr surfaces to be pinned to the</span>
<span class="p_add">+ * hardware and so we reject any attempt to create a framebuffer out of a</span>
<span class="p_add">+ * userptr.</span>
  *
  * If you think this is a good interface to use to pass GPU memory between
  * drivers, please use dma-buf instead. In fact, wherever possible use
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index f208bbc6d58e..7b27a114b030 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -1699,6 +1699,8 @@</span> <span class="p_context"> static void i9xx_enable_pll(struct intel_crtc *crtc)</span>
 			   I915_READ(DPLL(!crtc-&gt;pipe)) | DPLL_DVO_2X_MODE);
 	}
 
<span class="p_add">+	I915_WRITE(reg, dpll);</span>
<span class="p_add">+</span>
 	/* Wait for the clocks to stabilize. */
 	POSTING_READ(reg);
 	udelay(150);
<span class="p_chunk">@@ -13212,6 +13214,11 @@</span> <span class="p_context"> static int intel_user_framebuffer_create_handle(struct drm_framebuffer *fb,</span>
 	struct intel_framebuffer *intel_fb = to_intel_framebuffer(fb);
 	struct drm_i915_gem_object *obj = intel_fb-&gt;obj;
 
<span class="p_add">+	if (obj-&gt;userptr.mm) {</span>
<span class="p_add">+		DRM_DEBUG(&quot;attempting to use a userptr for a framebuffer, denied\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return drm_gem_handle_create(file, &amp;obj-&gt;base, handle);
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_lrc.c b/drivers/gpu/drm/i915/intel_lrc.c</span>
<span class="p_header">index 9ab7c1c758ae..72f1bb8b0499 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_lrc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_lrc.c</span>
<span class="p_chunk">@@ -1298,6 +1298,7 @@</span> <span class="p_context"> static int gen8_emit_flush_render(struct intel_ringbuffer *ringbuf,</span>
 	if (flush_domains) {
 		flags |= PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH;
 		flags |= PIPE_CONTROL_DEPTH_CACHE_FLUSH;
<span class="p_add">+		flags |= PIPE_CONTROL_FLUSH_ENABLE;</span>
 	}
 
 	if (invalidate_domains) {
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_ringbuffer.c b/drivers/gpu/drm/i915/intel_ringbuffer.c</span>
<span class="p_header">index 005b5e04de4d..b7e20dee64c4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_ringbuffer.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_ringbuffer.c</span>
<span class="p_chunk">@@ -342,6 +342,7 @@</span> <span class="p_context"> gen7_render_ring_flush(struct intel_engine_cs *ring,</span>
 	if (flush_domains) {
 		flags |= PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH;
 		flags |= PIPE_CONTROL_DEPTH_CACHE_FLUSH;
<span class="p_add">+		flags |= PIPE_CONTROL_FLUSH_ENABLE;</span>
 	}
 	if (invalidate_domains) {
 		flags |= PIPE_CONTROL_TLB_INVALIDATE;
<span class="p_chunk">@@ -412,6 +413,7 @@</span> <span class="p_context"> gen8_render_ring_flush(struct intel_engine_cs *ring,</span>
 	if (flush_domains) {
 		flags |= PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH;
 		flags |= PIPE_CONTROL_DEPTH_CACHE_FLUSH;
<span class="p_add">+		flags |= PIPE_CONTROL_FLUSH_ENABLE;</span>
 	}
 	if (invalidate_domains) {
 		flags |= PIPE_CONTROL_TLB_INVALIDATE;
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nouveau_gem.c b/drivers/gpu/drm/nouveau/nouveau_gem.c</span>
<span class="p_header">index 0e690bf19fc9..58c959265b1a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nouveau_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nouveau_gem.c</span>
<span class="p_chunk">@@ -227,11 +227,12 @@</span> <span class="p_context"> nouveau_gem_info(struct drm_file *file_priv, struct drm_gem_object *gem,</span>
 	struct nouveau_bo *nvbo = nouveau_gem_object(gem);
 	struct nvkm_vma *vma;
 
<span class="p_del">-	if (nvbo-&gt;bo.mem.mem_type == TTM_PL_TT)</span>
<span class="p_add">+	if (is_power_of_2(nvbo-&gt;valid_domains))</span>
<span class="p_add">+		rep-&gt;domain = nvbo-&gt;valid_domains;</span>
<span class="p_add">+	else if (nvbo-&gt;bo.mem.mem_type == TTM_PL_TT)</span>
 		rep-&gt;domain = NOUVEAU_GEM_DOMAIN_GART;
 	else
 		rep-&gt;domain = NOUVEAU_GEM_DOMAIN_VRAM;
<span class="p_del">-</span>
 	rep-&gt;offset = nvbo-&gt;bo.offset;
 	if (cli-&gt;vm) {
 		vma = nouveau_bo_vma_find(nvbo, cli-&gt;vm);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_encoders.c b/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_header">index b4ff4c134fbb..5be50ef2b30e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_chunk">@@ -237,6 +237,7 @@</span> <span class="p_context"> void radeon_atom_backlight_init(struct radeon_encoder *radeon_encoder,</span>
 	backlight_update_status(bd);
 
 	DRM_INFO(&quot;radeon atom DIG backlight initialized\n&quot;);
<span class="p_add">+	rdev-&gt;mode_info.bl_encoder = radeon_encoder;</span>
 
 	return;
 
<span class="p_chunk">@@ -1624,9 +1625,14 @@</span> <span class="p_context"> radeon_atom_encoder_dpms_avivo(struct drm_encoder *encoder, int mode)</span>
 		} else
 			atom_execute_table(rdev-&gt;mode_info.atom_context, index, (uint32_t *)&amp;args);
 		if (radeon_encoder-&gt;devices &amp; (ATOM_DEVICE_LCD_SUPPORT)) {
<span class="p_del">-			struct radeon_encoder_atom_dig *dig = radeon_encoder-&gt;enc_priv;</span>
<span class="p_add">+			if (rdev-&gt;mode_info.bl_encoder) {</span>
<span class="p_add">+				struct radeon_encoder_atom_dig *dig = radeon_encoder-&gt;enc_priv;</span>
 
<span class="p_del">-			atombios_set_backlight_level(radeon_encoder, dig-&gt;backlight_level);</span>
<span class="p_add">+				atombios_set_backlight_level(radeon_encoder, dig-&gt;backlight_level);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				args.ucAction = ATOM_LCD_BLON;</span>
<span class="p_add">+				atom_execute_table(rdev-&gt;mode_info.atom_context, index, (uint32_t *)&amp;args);</span>
<span class="p_add">+			}</span>
 		}
 		break;
 	case DRM_MODE_DPMS_STANDBY:
<span class="p_chunk">@@ -1706,8 +1712,13 @@</span> <span class="p_context"> radeon_atom_encoder_dpms_dig(struct drm_encoder *encoder, int mode)</span>
 			if (ASIC_IS_DCE4(rdev))
 				atombios_dig_encoder_setup(encoder, ATOM_ENCODER_CMD_DP_VIDEO_ON, 0);
 		}
<span class="p_del">-		if (radeon_encoder-&gt;devices &amp; (ATOM_DEVICE_LCD_SUPPORT))</span>
<span class="p_del">-			atombios_set_backlight_level(radeon_encoder, dig-&gt;backlight_level);</span>
<span class="p_add">+		if (radeon_encoder-&gt;devices &amp; (ATOM_DEVICE_LCD_SUPPORT)) {</span>
<span class="p_add">+			if (rdev-&gt;mode_info.bl_encoder)</span>
<span class="p_add">+				atombios_set_backlight_level(radeon_encoder, dig-&gt;backlight_level);</span>
<span class="p_add">+			else</span>
<span class="p_add">+				atombios_dig_transmitter_setup(encoder,</span>
<span class="p_add">+							       ATOM_TRANSMITTER_ACTION_LCD_BLON, 0, 0);</span>
<span class="p_add">+		}</span>
 		if (ext_encoder)
 			atombios_external_encoder_setup(encoder, ext_encoder, ATOM_ENABLE);
 		break;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon.h b/drivers/gpu/drm/radeon/radeon.h</span>
<span class="p_header">index 46eb0fa75a61..91c3f60f8bac 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon.h</span>
<span class="p_chunk">@@ -1656,6 +1656,7 @@</span> <span class="p_context"> struct radeon_pm {</span>
 	u8                      fan_max_rpm;
 	/* dpm */
 	bool                    dpm_enabled;
<span class="p_add">+	bool                    sysfs_initialized;</span>
 	struct radeon_dpm       dpm;
 };
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_encoders.c b/drivers/gpu/drm/radeon/radeon_encoders.c</span>
<span class="p_header">index ef99917f000d..c6ee80216cf4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_encoders.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_encoders.c</span>
<span class="p_chunk">@@ -194,7 +194,6 @@</span> <span class="p_context"> static void radeon_encoder_add_backlight(struct radeon_encoder *radeon_encoder,</span>
 			radeon_atom_backlight_init(radeon_encoder, connector);
 		else
 			radeon_legacy_backlight_init(radeon_encoder, connector);
<span class="p_del">-		rdev-&gt;mode_info.bl_encoder = radeon_encoder;</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_legacy_encoders.c b/drivers/gpu/drm/radeon/radeon_legacy_encoders.c</span>
<span class="p_header">index 45715307db71..30de43366eae 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_legacy_encoders.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_legacy_encoders.c</span>
<span class="p_chunk">@@ -441,6 +441,7 @@</span> <span class="p_context"> void radeon_legacy_backlight_init(struct radeon_encoder *radeon_encoder,</span>
 	backlight_update_status(bd);
 
 	DRM_INFO(&quot;radeon legacy LVDS backlight initialized\n&quot;);
<span class="p_add">+	rdev-&gt;mode_info.bl_encoder = radeon_encoder;</span>
 
 	return;
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_pm.c b/drivers/gpu/drm/radeon/radeon_pm.c</span>
<span class="p_header">index 948c33105801..91764320c56f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_pm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_pm.c</span>
<span class="p_chunk">@@ -720,10 +720,14 @@</span> <span class="p_context"> static umode_t hwmon_attributes_visible(struct kobject *kobj,</span>
 	struct radeon_device *rdev = dev_get_drvdata(dev);
 	umode_t effective_mode = attr-&gt;mode;
 
<span class="p_del">-	/* Skip limit attributes if DPM is not enabled */</span>
<span class="p_add">+	/* Skip attributes if DPM is not enabled */</span>
 	if (rdev-&gt;pm.pm_method != PM_METHOD_DPM &amp;&amp;
 	    (attr == &amp;sensor_dev_attr_temp1_crit.dev_attr.attr ||
<span class="p_del">-	     attr == &amp;sensor_dev_attr_temp1_crit_hyst.dev_attr.attr))</span>
<span class="p_add">+	     attr == &amp;sensor_dev_attr_temp1_crit_hyst.dev_attr.attr ||</span>
<span class="p_add">+	     attr == &amp;sensor_dev_attr_pwm1.dev_attr.attr ||</span>
<span class="p_add">+	     attr == &amp;sensor_dev_attr_pwm1_enable.dev_attr.attr ||</span>
<span class="p_add">+	     attr == &amp;sensor_dev_attr_pwm1_max.dev_attr.attr ||</span>
<span class="p_add">+	     attr == &amp;sensor_dev_attr_pwm1_min.dev_attr.attr))</span>
 		return 0;
 
 	/* Skip fan attributes if fan is not present */
<span class="p_chunk">@@ -1529,19 +1533,23 @@</span> <span class="p_context"> int radeon_pm_late_init(struct radeon_device *rdev)</span>
 
 	if (rdev-&gt;pm.pm_method == PM_METHOD_DPM) {
 		if (rdev-&gt;pm.dpm_enabled) {
<span class="p_del">-			ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_dpm_state);</span>
<span class="p_del">-			if (ret)</span>
<span class="p_del">-				DRM_ERROR(&quot;failed to create device file for dpm state\n&quot;);</span>
<span class="p_del">-			ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_dpm_force_performance_level);</span>
<span class="p_del">-			if (ret)</span>
<span class="p_del">-				DRM_ERROR(&quot;failed to create device file for dpm state\n&quot;);</span>
<span class="p_del">-			/* XXX: these are noops for dpm but are here for backwards compat */</span>
<span class="p_del">-			ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_profile);</span>
<span class="p_del">-			if (ret)</span>
<span class="p_del">-				DRM_ERROR(&quot;failed to create device file for power profile\n&quot;);</span>
<span class="p_del">-			ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_method);</span>
<span class="p_del">-			if (ret)</span>
<span class="p_del">-				DRM_ERROR(&quot;failed to create device file for power method\n&quot;);</span>
<span class="p_add">+			if (!rdev-&gt;pm.sysfs_initialized) {</span>
<span class="p_add">+				ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_dpm_state);</span>
<span class="p_add">+				if (ret)</span>
<span class="p_add">+					DRM_ERROR(&quot;failed to create device file for dpm state\n&quot;);</span>
<span class="p_add">+				ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_dpm_force_performance_level);</span>
<span class="p_add">+				if (ret)</span>
<span class="p_add">+					DRM_ERROR(&quot;failed to create device file for dpm state\n&quot;);</span>
<span class="p_add">+				/* XXX: these are noops for dpm but are here for backwards compat */</span>
<span class="p_add">+				ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_profile);</span>
<span class="p_add">+				if (ret)</span>
<span class="p_add">+					DRM_ERROR(&quot;failed to create device file for power profile\n&quot;);</span>
<span class="p_add">+				ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_method);</span>
<span class="p_add">+				if (ret)</span>
<span class="p_add">+					DRM_ERROR(&quot;failed to create device file for power method\n&quot;);</span>
<span class="p_add">+				if (!ret)</span>
<span class="p_add">+					rdev-&gt;pm.sysfs_initialized = true;</span>
<span class="p_add">+			}</span>
 
 			mutex_lock(&amp;rdev-&gt;pm.mutex);
 			ret = radeon_dpm_late_enable(rdev);
<span class="p_chunk">@@ -1557,7 +1565,8 @@</span> <span class="p_context"> int radeon_pm_late_init(struct radeon_device *rdev)</span>
 			}
 		}
 	} else {
<span class="p_del">-		if (rdev-&gt;pm.num_power_states &gt; 1) {</span>
<span class="p_add">+		if ((rdev-&gt;pm.num_power_states &gt; 1) &amp;&amp;</span>
<span class="p_add">+		    (!rdev-&gt;pm.sysfs_initialized)) {</span>
 			/* where&#39;s the best place to put these? */
 			ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_profile);
 			if (ret)
<span class="p_chunk">@@ -1565,6 +1574,8 @@</span> <span class="p_context"> int radeon_pm_late_init(struct radeon_device *rdev)</span>
 			ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_method);
 			if (ret)
 				DRM_ERROR(&quot;failed to create device file for power method\n&quot;);
<span class="p_add">+			if (!ret)</span>
<span class="p_add">+				rdev-&gt;pm.sysfs_initialized = true;</span>
 		}
 	}
 	return ret;
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c</span>
<span class="p_header">index 620bb5cf617c..15a8d7746fd2 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c</span>
<span class="p_chunk">@@ -1458,6 +1458,9 @@</span> <span class="p_context"> static void __exit vmwgfx_exit(void)</span>
 	drm_pci_exit(&amp;driver, &amp;vmw_pci_driver);
 }
 
<span class="p_add">+MODULE_INFO(vmw_patch, &quot;ed7d78b2&quot;);</span>
<span class="p_add">+MODULE_INFO(vmw_patch, &quot;54c12bc3&quot;);</span>
<span class="p_add">+</span>
 module_init(vmwgfx_init);
 module_exit(vmwgfx_exit);
 
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h</span>
<span class="p_header">index d26a6daa9719..d8896ed41b9e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h</span>
<span class="p_chunk">@@ -636,7 +636,8 @@</span> <span class="p_context"> extern int vmw_user_dmabuf_alloc(struct vmw_private *dev_priv,</span>
 				 uint32_t size,
 				 bool shareable,
 				 uint32_t *handle,
<span class="p_del">-				 struct vmw_dma_buffer **p_dma_buf);</span>
<span class="p_add">+				 struct vmw_dma_buffer **p_dma_buf,</span>
<span class="p_add">+				 struct ttm_base_object **p_base);</span>
 extern int vmw_user_dmabuf_reference(struct ttm_object_file *tfile,
 				     struct vmw_dma_buffer *dma_buf,
 				     uint32_t *handle);
<span class="p_chunk">@@ -650,7 +651,8 @@</span> <span class="p_context"> extern uint32_t vmw_dmabuf_validate_node(struct ttm_buffer_object *bo,</span>
 					 uint32_t cur_validate_node);
 extern void vmw_dmabuf_validate_clear(struct ttm_buffer_object *bo);
 extern int vmw_user_dmabuf_lookup(struct ttm_object_file *tfile,
<span class="p_del">-				  uint32_t id, struct vmw_dma_buffer **out);</span>
<span class="p_add">+				  uint32_t id, struct vmw_dma_buffer **out,</span>
<span class="p_add">+				  struct ttm_base_object **base);</span>
 extern int vmw_stream_claim_ioctl(struct drm_device *dev, void *data,
 				  struct drm_file *file_priv);
 extern int vmw_stream_unref_ioctl(struct drm_device *dev, void *data,
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c b/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_header">index 97ad3bcb99a7..aee1c6ccc52d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_chunk">@@ -887,7 +887,8 @@</span> <span class="p_context"> static int vmw_translate_mob_ptr(struct vmw_private *dev_priv,</span>
 	struct vmw_relocation *reloc;
 	int ret;
 
<span class="p_del">-	ret = vmw_user_dmabuf_lookup(sw_context-&gt;fp-&gt;tfile, handle, &amp;vmw_bo);</span>
<span class="p_add">+	ret = vmw_user_dmabuf_lookup(sw_context-&gt;fp-&gt;tfile, handle, &amp;vmw_bo,</span>
<span class="p_add">+				     NULL);</span>
 	if (unlikely(ret != 0)) {
 		DRM_ERROR(&quot;Could not find or use MOB buffer.\n&quot;);
 		ret = -EINVAL;
<span class="p_chunk">@@ -949,7 +950,8 @@</span> <span class="p_context"> static int vmw_translate_guest_ptr(struct vmw_private *dev_priv,</span>
 	struct vmw_relocation *reloc;
 	int ret;
 
<span class="p_del">-	ret = vmw_user_dmabuf_lookup(sw_context-&gt;fp-&gt;tfile, handle, &amp;vmw_bo);</span>
<span class="p_add">+	ret = vmw_user_dmabuf_lookup(sw_context-&gt;fp-&gt;tfile, handle, &amp;vmw_bo,</span>
<span class="p_add">+				     NULL);</span>
 	if (unlikely(ret != 0)) {
 		DRM_ERROR(&quot;Could not find or use GMR region.\n&quot;);
 		ret = -EINVAL;
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c b/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c</span>
<span class="p_header">index 87e39f68e9d0..e1898982b44a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c</span>
<span class="p_chunk">@@ -484,7 +484,7 @@</span> <span class="p_context"> int vmw_overlay_ioctl(struct drm_device *dev, void *data,</span>
 		goto out_unlock;
 	}
 
<span class="p_del">-	ret = vmw_user_dmabuf_lookup(tfile, arg-&gt;handle, &amp;buf);</span>
<span class="p_add">+	ret = vmw_user_dmabuf_lookup(tfile, arg-&gt;handle, &amp;buf, NULL);</span>
 	if (ret)
 		goto out_unlock;
 
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c b/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c</span>
<span class="p_header">index 210ef15b1d09..c5b4c47e86d6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c</span>
<span class="p_chunk">@@ -356,7 +356,7 @@</span> <span class="p_context"> int vmw_user_lookup_handle(struct vmw_private *dev_priv,</span>
 	}
 
 	*out_surf = NULL;
<span class="p_del">-	ret = vmw_user_dmabuf_lookup(tfile, handle, out_buf);</span>
<span class="p_add">+	ret = vmw_user_dmabuf_lookup(tfile, handle, out_buf, NULL);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -483,7 +483,8 @@</span> <span class="p_context"> int vmw_user_dmabuf_alloc(struct vmw_private *dev_priv,</span>
 			  uint32_t size,
 			  bool shareable,
 			  uint32_t *handle,
<span class="p_del">-			  struct vmw_dma_buffer **p_dma_buf)</span>
<span class="p_add">+			  struct vmw_dma_buffer **p_dma_buf,</span>
<span class="p_add">+			  struct ttm_base_object **p_base)</span>
 {
 	struct vmw_user_dma_buffer *user_bo;
 	struct ttm_buffer_object *tmp;
<span class="p_chunk">@@ -517,6 +518,10 @@</span> <span class="p_context"> int vmw_user_dmabuf_alloc(struct vmw_private *dev_priv,</span>
 	}
 
 	*p_dma_buf = &amp;user_bo-&gt;dma;
<span class="p_add">+	if (p_base) {</span>
<span class="p_add">+		*p_base = &amp;user_bo-&gt;prime.base;</span>
<span class="p_add">+		kref_get(&amp;(*p_base)-&gt;refcount);</span>
<span class="p_add">+	}</span>
 	*handle = user_bo-&gt;prime.base.hash.key;
 
 out_no_base_object:
<span class="p_chunk">@@ -633,6 +638,7 @@</span> <span class="p_context"> int vmw_user_dmabuf_synccpu_ioctl(struct drm_device *dev, void *data,</span>
 	struct vmw_dma_buffer *dma_buf;
 	struct vmw_user_dma_buffer *user_bo;
 	struct ttm_object_file *tfile = vmw_fpriv(file_priv)-&gt;tfile;
<span class="p_add">+	struct ttm_base_object *buffer_base;</span>
 	int ret;
 
 	if ((arg-&gt;flags &amp; (drm_vmw_synccpu_read | drm_vmw_synccpu_write)) == 0
<span class="p_chunk">@@ -645,7 +651,8 @@</span> <span class="p_context"> int vmw_user_dmabuf_synccpu_ioctl(struct drm_device *dev, void *data,</span>
 
 	switch (arg-&gt;op) {
 	case drm_vmw_synccpu_grab:
<span class="p_del">-		ret = vmw_user_dmabuf_lookup(tfile, arg-&gt;handle, &amp;dma_buf);</span>
<span class="p_add">+		ret = vmw_user_dmabuf_lookup(tfile, arg-&gt;handle, &amp;dma_buf,</span>
<span class="p_add">+					     &amp;buffer_base);</span>
 		if (unlikely(ret != 0))
 			return ret;
 
<span class="p_chunk">@@ -653,6 +660,7 @@</span> <span class="p_context"> int vmw_user_dmabuf_synccpu_ioctl(struct drm_device *dev, void *data,</span>
 				       dma);
 		ret = vmw_user_dmabuf_synccpu_grab(user_bo, tfile, arg-&gt;flags);
 		vmw_dmabuf_unreference(&amp;dma_buf);
<span class="p_add">+		ttm_base_object_unref(&amp;buffer_base);</span>
 		if (unlikely(ret != 0 &amp;&amp; ret != -ERESTARTSYS &amp;&amp;
 			     ret != -EBUSY)) {
 			DRM_ERROR(&quot;Failed synccpu grab on handle 0x%08x.\n&quot;,
<span class="p_chunk">@@ -694,7 +702,8 @@</span> <span class="p_context"> int vmw_dmabuf_alloc_ioctl(struct drm_device *dev, void *data,</span>
 		return ret;
 
 	ret = vmw_user_dmabuf_alloc(dev_priv, vmw_fpriv(file_priv)-&gt;tfile,
<span class="p_del">-				    req-&gt;size, false, &amp;handle, &amp;dma_buf);</span>
<span class="p_add">+				    req-&gt;size, false, &amp;handle, &amp;dma_buf,</span>
<span class="p_add">+				    NULL);</span>
 	if (unlikely(ret != 0))
 		goto out_no_dmabuf;
 
<span class="p_chunk">@@ -723,7 +732,8 @@</span> <span class="p_context"> int vmw_dmabuf_unref_ioctl(struct drm_device *dev, void *data,</span>
 }
 
 int vmw_user_dmabuf_lookup(struct ttm_object_file *tfile,
<span class="p_del">-			   uint32_t handle, struct vmw_dma_buffer **out)</span>
<span class="p_add">+			   uint32_t handle, struct vmw_dma_buffer **out,</span>
<span class="p_add">+			   struct ttm_base_object **p_base)</span>
 {
 	struct vmw_user_dma_buffer *vmw_user_bo;
 	struct ttm_base_object *base;
<span class="p_chunk">@@ -745,7 +755,10 @@</span> <span class="p_context"> int vmw_user_dmabuf_lookup(struct ttm_object_file *tfile,</span>
 	vmw_user_bo = container_of(base, struct vmw_user_dma_buffer,
 				   prime.base);
 	(void)ttm_bo_reference(&amp;vmw_user_bo-&gt;dma.base);
<span class="p_del">-	ttm_base_object_unref(&amp;base);</span>
<span class="p_add">+	if (p_base)</span>
<span class="p_add">+		*p_base = base;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ttm_base_object_unref(&amp;base);</span>
 	*out = &amp;vmw_user_bo-&gt;dma;
 
 	return 0;
<span class="p_chunk">@@ -1006,7 +1019,7 @@</span> <span class="p_context"> int vmw_dumb_create(struct drm_file *file_priv,</span>
 
 	ret = vmw_user_dmabuf_alloc(dev_priv, vmw_fpriv(file_priv)-&gt;tfile,
 				    args-&gt;size, false, &amp;args-&gt;handle,
<span class="p_del">-				    &amp;dma_buf);</span>
<span class="p_add">+				    &amp;dma_buf, NULL);</span>
 	if (unlikely(ret != 0))
 		goto out_no_dmabuf;
 
<span class="p_chunk">@@ -1034,7 +1047,7 @@</span> <span class="p_context"> int vmw_dumb_map_offset(struct drm_file *file_priv,</span>
 	struct vmw_dma_buffer *out_buf;
 	int ret;
 
<span class="p_del">-	ret = vmw_user_dmabuf_lookup(tfile, handle, &amp;out_buf);</span>
<span class="p_add">+	ret = vmw_user_dmabuf_lookup(tfile, handle, &amp;out_buf, NULL);</span>
 	if (ret != 0)
 		return -EINVAL;
 
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_shader.c b/drivers/gpu/drm/vmwgfx/vmwgfx_shader.c</span>
<span class="p_header">index 6a4584a43aa6..d2751ada19b1 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_shader.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_shader.c</span>
<span class="p_chunk">@@ -470,7 +470,7 @@</span> <span class="p_context"> int vmw_shader_define_ioctl(struct drm_device *dev, void *data,</span>
 
 	if (arg-&gt;buffer_handle != SVGA3D_INVALID_ID) {
 		ret = vmw_user_dmabuf_lookup(tfile, arg-&gt;buffer_handle,
<span class="p_del">-					     &amp;buffer);</span>
<span class="p_add">+					     &amp;buffer, NULL);</span>
 		if (unlikely(ret != 0)) {
 			DRM_ERROR(&quot;Could not find buffer for shader &quot;
 				  &quot;creation.\n&quot;);
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c b/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c</span>
<span class="p_header">index 4ecdbf3e59da..17a4107639b2 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c</span>
<span class="p_chunk">@@ -43,6 +43,7 @@</span> <span class="p_context"> struct vmw_user_surface {</span>
 	struct vmw_surface srf;
 	uint32_t size;
 	struct drm_master *master;
<span class="p_add">+	struct ttm_base_object *backup_base;</span>
 };
 
 /**
<span class="p_chunk">@@ -652,6 +653,8 @@</span> <span class="p_context"> static void vmw_user_surface_base_release(struct ttm_base_object **p_base)</span>
 	struct vmw_resource *res = &amp;user_srf-&gt;srf.res;
 
 	*p_base = NULL;
<span class="p_add">+	if (user_srf-&gt;backup_base)</span>
<span class="p_add">+		ttm_base_object_unref(&amp;user_srf-&gt;backup_base);</span>
 	vmw_resource_unreference(&amp;res);
 }
 
<span class="p_chunk">@@ -846,7 +849,8 @@</span> <span class="p_context"> int vmw_surface_define_ioctl(struct drm_device *dev, void *data,</span>
 					    res-&gt;backup_size,
 					    true,
 					    &amp;backup_handle,
<span class="p_del">-					    &amp;res-&gt;backup);</span>
<span class="p_add">+					    &amp;res-&gt;backup,</span>
<span class="p_add">+					    &amp;user_srf-&gt;backup_base);</span>
 		if (unlikely(ret != 0)) {
 			vmw_resource_unreference(&amp;res);
 			goto out_unlock;
<span class="p_chunk">@@ -1309,7 +1313,8 @@</span> <span class="p_context"> int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data,</span>
 
 	if (req-&gt;buffer_handle != SVGA3D_INVALID_ID) {
 		ret = vmw_user_dmabuf_lookup(tfile, req-&gt;buffer_handle,
<span class="p_del">-					     &amp;res-&gt;backup);</span>
<span class="p_add">+					     &amp;res-&gt;backup,</span>
<span class="p_add">+					     &amp;user_srf-&gt;backup_base);</span>
 	} else if (req-&gt;drm_surface_flags &amp;
 		   drm_vmw_surface_flag_create_buffer)
 		ret = vmw_user_dmabuf_alloc(dev_priv, tfile,
<span class="p_chunk">@@ -1317,7 +1322,8 @@</span> <span class="p_context"> int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data,</span>
 					    req-&gt;drm_surface_flags &amp;
 					    drm_vmw_surface_flag_shareable,
 					    &amp;backup_handle,
<span class="p_del">-					    &amp;res-&gt;backup);</span>
<span class="p_add">+					    &amp;res-&gt;backup,</span>
<span class="p_add">+					    &amp;user_srf-&gt;backup_base);</span>
 
 	if (unlikely(ret != 0)) {
 		vmw_resource_unreference(&amp;res);
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-mv64xxx.c b/drivers/i2c/busses/i2c-mv64xxx.c</span>
<span class="p_header">index 30059c1df2a3..5801227b97ab 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-mv64xxx.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-mv64xxx.c</span>
<span class="p_chunk">@@ -669,8 +669,6 @@</span> <span class="p_context"> mv64xxx_i2c_can_offload(struct mv64xxx_i2c_data *drv_data)</span>
 	struct i2c_msg *msgs = drv_data-&gt;msgs;
 	int num = drv_data-&gt;num_msgs;
 
<span class="p_del">-	return false;</span>
<span class="p_del">-</span>
 	if (!drv_data-&gt;offload_enabled)
 		return false;
 
<span class="p_header">diff --git a/drivers/iio/accel/st_accel_core.c b/drivers/iio/accel/st_accel_core.c</span>
<span class="p_header">index 211b13271c61..2ae7150442fc 100644</span>
<span class="p_header">--- a/drivers/iio/accel/st_accel_core.c</span>
<span class="p_header">+++ b/drivers/iio/accel/st_accel_core.c</span>
<span class="p_chunk">@@ -149,8 +149,6 @@</span> <span class="p_context"></span>
 #define ST_ACCEL_4_BDU_MASK			0x40
 #define ST_ACCEL_4_DRDY_IRQ_ADDR		0x21
 #define ST_ACCEL_4_DRDY_IRQ_INT1_MASK		0x04
<span class="p_del">-#define ST_ACCEL_4_IG1_EN_ADDR			0x21</span>
<span class="p_del">-#define ST_ACCEL_4_IG1_EN_MASK			0x08</span>
 #define ST_ACCEL_4_MULTIREAD_BIT		true
 
 static const struct iio_chan_spec st_accel_12bit_channels[] = {
<span class="p_chunk">@@ -446,10 +444,6 @@</span> <span class="p_context"> static const struct st_sensor_settings st_accel_sensors_settings[] = {</span>
 		.drdy_irq = {
 			.addr = ST_ACCEL_4_DRDY_IRQ_ADDR,
 			.mask_int1 = ST_ACCEL_4_DRDY_IRQ_INT1_MASK,
<span class="p_del">-			.ig1 = {</span>
<span class="p_del">-				.en_addr = ST_ACCEL_4_IG1_EN_ADDR,</span>
<span class="p_del">-				.en_mask = ST_ACCEL_4_IG1_EN_MASK,</span>
<span class="p_del">-			},</span>
 		},
 		.multi_read_bit = ST_ACCEL_4_MULTIREAD_BIT,
 		.bootime = 2, /* guess */
<span class="p_header">diff --git a/drivers/infiniband/core/cm.c b/drivers/infiniband/core/cm.c</span>
<span class="p_header">index 0271608a51c4..0962b6821ce1 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/cm.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/cm.c</span>
<span class="p_chunk">@@ -859,6 +859,11 @@</span> <span class="p_context"> retest:</span>
 	case IB_CM_SIDR_REQ_RCVD:
 		spin_unlock_irq(&amp;cm_id_priv-&gt;lock);
 		cm_reject_sidr_req(cm_id_priv, IB_SIDR_REJECT);
<span class="p_add">+		spin_lock_irq(&amp;cm.lock);</span>
<span class="p_add">+		if (!RB_EMPTY_NODE(&amp;cm_id_priv-&gt;sidr_id_node))</span>
<span class="p_add">+			rb_erase(&amp;cm_id_priv-&gt;sidr_id_node,</span>
<span class="p_add">+				 &amp;cm.remote_sidr_table);</span>
<span class="p_add">+		spin_unlock_irq(&amp;cm.lock);</span>
 		break;
 	case IB_CM_REQ_SENT:
 	case IB_CM_MRA_REQ_RCVD:
<span class="p_chunk">@@ -3098,7 +3103,10 @@</span> <span class="p_context"> int ib_send_cm_sidr_rep(struct ib_cm_id *cm_id,</span>
 	spin_unlock_irqrestore(&amp;cm_id_priv-&gt;lock, flags);
 
 	spin_lock_irqsave(&amp;cm.lock, flags);
<span class="p_del">-	rb_erase(&amp;cm_id_priv-&gt;sidr_id_node, &amp;cm.remote_sidr_table);</span>
<span class="p_add">+	if (!RB_EMPTY_NODE(&amp;cm_id_priv-&gt;sidr_id_node)) {</span>
<span class="p_add">+		rb_erase(&amp;cm_id_priv-&gt;sidr_id_node, &amp;cm.remote_sidr_table);</span>
<span class="p_add">+		RB_CLEAR_NODE(&amp;cm_id_priv-&gt;sidr_id_node);</span>
<span class="p_add">+	}</span>
 	spin_unlock_irqrestore(&amp;cm.lock, flags);
 	return 0;
 
<span class="p_header">diff --git a/drivers/input/mouse/alps.c b/drivers/input/mouse/alps.c</span>
<span class="p_header">index bc7eed67998a..4b9e31a5b3f8 100644</span>
<span class="p_header">--- a/drivers/input/mouse/alps.c</span>
<span class="p_header">+++ b/drivers/input/mouse/alps.c</span>
<span class="p_chunk">@@ -100,7 +100,7 @@</span> <span class="p_context"> static const struct alps_nibble_commands alps_v6_nibble_commands[] = {</span>
 #define ALPS_FOUR_BUTTONS	0x40	/* 4 direction button present */
 #define ALPS_PS2_INTERLEAVED	0x80	/* 3-byte PS/2 packet interleaved with
 					   6-byte ALPS packet */
<span class="p_del">-#define ALPS_DELL		0x100	/* device is a Dell laptop */</span>
<span class="p_add">+#define ALPS_STICK_BITS		0x100	/* separate stick button bits */</span>
 #define ALPS_BUTTONPAD		0x200	/* device is a clickpad */
 
 static const struct alps_model_info alps_model_data[] = {
<span class="p_chunk">@@ -159,6 +159,43 @@</span> <span class="p_context"> static const struct alps_protocol_info alps_v8_protocol_data = {</span>
 	ALPS_PROTO_V8, 0x18, 0x18, 0
 };
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Some v2 models report the stick buttons in separate bits</span>
<span class="p_add">+ */</span>
<span class="p_add">+static const struct dmi_system_id alps_dmi_has_separate_stick_buttons[] = {</span>
<span class="p_add">+#if defined(CONFIG_DMI) &amp;&amp; defined(CONFIG_X86)</span>
<span class="p_add">+	{</span>
<span class="p_add">+		/* Extrapolated from other entries */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Dell Inc.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;Latitude D420&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		/* Reported-by: Hans de Bruin &lt;jmdebruin@xmsnet.nl&gt; */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Dell Inc.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;Latitude D430&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		/* Reported-by: Hans de Goede &lt;hdegoede@redhat.com&gt; */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Dell Inc.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;Latitude D620&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		/* Extrapolated from other entries */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Dell Inc.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;Latitude D630&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	{ }</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static void alps_set_abs_params_st(struct alps_data *priv,
 				   struct input_dev *dev1);
 static void alps_set_abs_params_mt(struct alps_data *priv,
<span class="p_chunk">@@ -253,9 +290,8 @@</span> <span class="p_context"> static void alps_process_packet_v1_v2(struct psmouse *psmouse)</span>
 		return;
 	}
 
<span class="p_del">-	/* Dell non interleaved V2 dualpoint has separate stick button bits */</span>
<span class="p_del">-	if (priv-&gt;proto_version == ALPS_PROTO_V2 &amp;&amp;</span>
<span class="p_del">-	    priv-&gt;flags == (ALPS_DELL | ALPS_PASS | ALPS_DUALPOINT)) {</span>
<span class="p_add">+	/* Some models have separate stick button bits */</span>
<span class="p_add">+	if (priv-&gt;flags &amp; ALPS_STICK_BITS) {</span>
 		left |= packet[0] &amp; 1;
 		right |= packet[0] &amp; 2;
 		middle |= packet[0] &amp; 4;
<span class="p_chunk">@@ -2544,8 +2580,6 @@</span> <span class="p_context"> static int alps_set_protocol(struct psmouse *psmouse,</span>
 	priv-&gt;byte0 = protocol-&gt;byte0;
 	priv-&gt;mask0 = protocol-&gt;mask0;
 	priv-&gt;flags = protocol-&gt;flags;
<span class="p_del">-	if (dmi_name_in_vendors(&quot;Dell&quot;))</span>
<span class="p_del">-		priv-&gt;flags |= ALPS_DELL;</span>
 
 	priv-&gt;x_max = 2000;
 	priv-&gt;y_max = 1400;
<span class="p_chunk">@@ -2560,6 +2594,8 @@</span> <span class="p_context"> static int alps_set_protocol(struct psmouse *psmouse,</span>
 		priv-&gt;set_abs_params = alps_set_abs_params_st;
 		priv-&gt;x_max = 1023;
 		priv-&gt;y_max = 767;
<span class="p_add">+		if (dmi_check_system(alps_dmi_has_separate_stick_buttons))</span>
<span class="p_add">+			priv-&gt;flags |= ALPS_STICK_BITS;</span>
 		break;
 
 	case ALPS_PROTO_V3:
<span class="p_header">diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c</span>
<span class="p_header">index ca9f4edbb940..f0fd5352f8ef 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu.c</span>
<span class="p_chunk">@@ -2099,8 +2099,8 @@</span> <span class="p_context"> static void set_dte_entry(u16 devid, struct protection_domain *domain, bool ats)</span>
 static void clear_dte_entry(u16 devid)
 {
 	/* remove entry from the device table seen by the hardware */
<span class="p_del">-	amd_iommu_dev_table[devid].data[0] = IOMMU_PTE_P | IOMMU_PTE_TV;</span>
<span class="p_del">-	amd_iommu_dev_table[devid].data[1] = 0;</span>
<span class="p_add">+	amd_iommu_dev_table[devid].data[0]  = IOMMU_PTE_P | IOMMU_PTE_TV;</span>
<span class="p_add">+	amd_iommu_dev_table[devid].data[1] &amp;= DTE_FLAG_MASK;</span>
 
 	amd_iommu_apply_erratum_63(devid);
 }
<span class="p_header">diff --git a/drivers/iommu/amd_iommu_types.h b/drivers/iommu/amd_iommu_types.h</span>
<span class="p_header">index 05030e523771..cbfd0f4c4608 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu_types.h</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu_types.h</span>
<span class="p_chunk">@@ -295,6 +295,7 @@</span> <span class="p_context"></span>
 #define IOMMU_PTE_IR (1ULL &lt;&lt; 61)
 #define IOMMU_PTE_IW (1ULL &lt;&lt; 62)
 
<span class="p_add">+#define DTE_FLAG_MASK	(0x3ffULL &lt;&lt; 32)</span>
 #define DTE_FLAG_IOTLB	(0x01UL &lt;&lt; 32)
 #define DTE_FLAG_GV	(0x01ULL &lt;&lt; 55)
 #define DTE_GLX_SHIFT	(56)
<span class="p_header">diff --git a/drivers/iommu/amd_iommu_v2.c b/drivers/iommu/amd_iommu_v2.c</span>
<span class="p_header">index 3465faf1809e..45087c3e5c57 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu_v2.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu_v2.c</span>
<span class="p_chunk">@@ -508,6 +508,13 @@</span> <span class="p_context"> static void do_fault(struct work_struct *work)</span>
 		goto out;
 	}
 
<span class="p_add">+	if (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC | VM_WRITE))) {</span>
<span class="p_add">+		/* handle_mm_fault would BUG_ON() */</span>
<span class="p_add">+		up_read(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+		handle_fault_error(fault);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ret = handle_mm_fault(mm, vma, address, write);
 	if (ret &amp; VM_FAULT_ERROR) {
 		/* failed to service fault */
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index c23427951ec1..8b0178db6a04 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -2033,15 +2033,19 @@</span> <span class="p_context"> static int __domain_mapping(struct dmar_domain *domain, unsigned long iov_pfn,</span>
 				return -ENOMEM;
 			/* It is large page*/
 			if (largepage_lvl &gt; 1) {
<span class="p_add">+				unsigned long nr_superpages, end_pfn;</span>
<span class="p_add">+</span>
 				pteval |= DMA_PTE_LARGE_PAGE;
 				lvl_pages = lvl_to_nr_pages(largepage_lvl);
<span class="p_add">+</span>
<span class="p_add">+				nr_superpages = sg_res / lvl_pages;</span>
<span class="p_add">+				end_pfn = iov_pfn + nr_superpages * lvl_pages - 1;</span>
<span class="p_add">+</span>
 				/*
 				 * Ensure that old small page tables are
<span class="p_del">-				 * removed to make room for superpage,</span>
<span class="p_del">-				 * if they exist.</span>
<span class="p_add">+				 * removed to make room for superpage(s).</span>
 				 */
<span class="p_del">-				dma_pte_free_pagetable(domain, iov_pfn,</span>
<span class="p_del">-						       iov_pfn + lvl_pages - 1);</span>
<span class="p_add">+				dma_pte_free_pagetable(domain, iov_pfn, end_pfn);</span>
 			} else {
 				pteval &amp;= ~(uint64_t)DMA_PTE_LARGE_PAGE;
 			}
<span class="p_header">diff --git a/drivers/irqchip/irq-tegra.c b/drivers/irqchip/irq-tegra.c</span>
<span class="p_header">index f67bbd80433e..ab5353a96a82 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-tegra.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-tegra.c</span>
<span class="p_chunk">@@ -215,6 +215,7 @@</span> <span class="p_context"> static struct irq_chip tegra_ictlr_chip = {</span>
 	.irq_unmask		= tegra_unmask,
 	.irq_retrigger		= tegra_retrigger,
 	.irq_set_wake		= tegra_set_wake,
<span class="p_add">+	.irq_set_type		= irq_chip_set_type_parent,</span>
 	.flags			= IRQCHIP_MASK_ON_SUSPEND,
 #ifdef CONFIG_SMP
 	.irq_set_affinity	= irq_chip_set_affinity_parent,
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index e8c44fcb1ad1..78c1f77e7903 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -8013,8 +8013,7 @@</span> <span class="p_context"> static int remove_and_add_spares(struct mddev *mddev,</span>
 		       !test_bit(Bitmap_sync, &amp;rdev-&gt;flags)))
 			continue;
 
<span class="p_del">-		if (rdev-&gt;saved_raid_disk &lt; 0)</span>
<span class="p_del">-			rdev-&gt;recovery_offset = 0;</span>
<span class="p_add">+		rdev-&gt;recovery_offset = 0;</span>
 		if (mddev-&gt;pers-&gt;
 		    hot_add_disk(mddev, rdev) == 0) {
 			if (sysfs_link_rdev(mddev, rdev))
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree-remove.c b/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_header">index 7c0d75547ccf..92cd09f3c69b 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_chunk">@@ -301,11 +301,16 @@</span> <span class="p_context"> static void redistribute3(struct dm_btree_info *info, struct btree_node *parent,</span>
 {
 	int s;
 	uint32_t max_entries = le32_to_cpu(left-&gt;header.max_entries);
<span class="p_del">-	unsigned target = (nr_left + nr_center + nr_right) / 3;</span>
<span class="p_del">-	BUG_ON(target &gt; max_entries);</span>
<span class="p_add">+	unsigned total = nr_left + nr_center + nr_right;</span>
<span class="p_add">+	unsigned target_right = total / 3;</span>
<span class="p_add">+	unsigned remainder = (target_right * 3) != total;</span>
<span class="p_add">+	unsigned target_left = target_right + remainder;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(target_left &gt; max_entries);</span>
<span class="p_add">+	BUG_ON(target_right &gt; max_entries);</span>
 
 	if (nr_left &lt; nr_right) {
<span class="p_del">-		s = nr_left - target;</span>
<span class="p_add">+		s = nr_left - target_left;</span>
 
 		if (s &lt; 0 &amp;&amp; nr_center &lt; -s) {
 			/* not enough in central node */
<span class="p_chunk">@@ -316,10 +321,10 @@</span> <span class="p_context"> static void redistribute3(struct dm_btree_info *info, struct btree_node *parent,</span>
 		} else
 			shift(left, center, s);
 
<span class="p_del">-		shift(center, right, target - nr_right);</span>
<span class="p_add">+		shift(center, right, target_right - nr_right);</span>
 
 	} else {
<span class="p_del">-		s = target - nr_right;</span>
<span class="p_add">+		s = target_right - nr_right;</span>
 		if (s &gt; 0 &amp;&amp; nr_center &lt; s) {
 			/* not enough in central node */
 			shift(center, right, nr_center);
<span class="p_chunk">@@ -329,7 +334,7 @@</span> <span class="p_context"> static void redistribute3(struct dm_btree_info *info, struct btree_node *parent,</span>
 		} else
 			shift(center, right, s);
 
<span class="p_del">-		shift(left, center, nr_left - target);</span>
<span class="p_add">+		shift(left, center, nr_left - target_left);</span>
 	}
 
 	*key_ptr(parent, c-&gt;index) = center-&gt;keys[0];
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree.c b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">index c7726cebc495..d6e47033b5e0 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_chunk">@@ -523,7 +523,7 @@</span> <span class="p_context"> static int btree_split_beneath(struct shadow_spine *s, uint64_t key)</span>
 
 	r = new_block(s-&gt;info, &amp;right);
 	if (r &lt; 0) {
<span class="p_del">-		/* FIXME: put left */</span>
<span class="p_add">+		unlock_block(s-&gt;info, left);</span>
 		return r;
 	}
 
<span class="p_header">diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c</span>
<span class="p_header">index 5ce3cd5c4e1d..bff6c1c7fecb 100644</span>
<span class="p_header">--- a/drivers/md/raid1.c</span>
<span class="p_header">+++ b/drivers/md/raid1.c</span>
<span class="p_chunk">@@ -2248,7 +2248,7 @@</span> <span class="p_context"> static int narrow_write_error(struct r1bio *r1_bio, int i)</span>
 		bio_trim(wbio, sector - r1_bio-&gt;sector, sectors);
 		wbio-&gt;bi_iter.bi_sector += rdev-&gt;data_offset;
 		wbio-&gt;bi_bdev = rdev-&gt;bdev;
<span class="p_del">-		if (submit_bio_wait(WRITE, wbio) == 0)</span>
<span class="p_add">+		if (submit_bio_wait(WRITE, wbio) &lt; 0)</span>
 			/* failure! */
 			ok = rdev_set_badblocks(rdev, sector,
 						sectors, 0)
<span class="p_header">diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c</span>
<span class="p_header">index fe0122771642..adfc83a0f023 100644</span>
<span class="p_header">--- a/drivers/md/raid10.c</span>
<span class="p_header">+++ b/drivers/md/raid10.c</span>
<span class="p_chunk">@@ -2590,7 +2590,7 @@</span> <span class="p_context"> static int narrow_write_error(struct r10bio *r10_bio, int i)</span>
 				   choose_data_offset(r10_bio, rdev) +
 				   (sector - r10_bio-&gt;sector));
 		wbio-&gt;bi_bdev = rdev-&gt;bdev;
<span class="p_del">-		if (submit_bio_wait(WRITE, wbio) == 0)</span>
<span class="p_add">+		if (submit_bio_wait(WRITE, wbio) &lt; 0)</span>
 			/* Failure! */
 			ok = rdev_set_badblocks(rdev, sector,
 						sectors, 0)
<span class="p_header">diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c</span>
<span class="p_header">index 23af6772f146..0d767e31f455 100644</span>
<span class="p_header">--- a/drivers/md/raid5.c</span>
<span class="p_header">+++ b/drivers/md/raid5.c</span>
<span class="p_chunk">@@ -3494,6 +3494,7 @@</span> <span class="p_context"> returnbi:</span>
 		}
 	if (!discard_pending &amp;&amp;
 	    test_bit(R5_Discard, &amp;sh-&gt;dev[sh-&gt;pd_idx].flags)) {
<span class="p_add">+		int hash;</span>
 		clear_bit(R5_Discard, &amp;sh-&gt;dev[sh-&gt;pd_idx].flags);
 		clear_bit(R5_UPTODATE, &amp;sh-&gt;dev[sh-&gt;pd_idx].flags);
 		if (sh-&gt;qd_idx &gt;= 0) {
<span class="p_chunk">@@ -3507,16 +3508,17 @@</span> <span class="p_context"> returnbi:</span>
 		 * no updated data, so remove it from hash list and the stripe
 		 * will be reinitialized
 		 */
<span class="p_del">-		spin_lock_irq(&amp;conf-&gt;device_lock);</span>
 unhash:
<span class="p_add">+		hash = sh-&gt;hash_lock_index;</span>
<span class="p_add">+		spin_lock_irq(conf-&gt;hash_locks + hash);</span>
 		remove_hash(sh);
<span class="p_add">+		spin_unlock_irq(conf-&gt;hash_locks + hash);</span>
 		if (head_sh-&gt;batch_head) {
 			sh = list_first_entry(&amp;sh-&gt;batch_list,
 					      struct stripe_head, batch_list);
 			if (sh != head_sh)
 					goto unhash;
 		}
<span class="p_del">-		spin_unlock_irq(&amp;conf-&gt;device_lock);</span>
 		sh = head_sh;
 
 		if (test_bit(STRIPE_SYNC_REQUESTED, &amp;sh-&gt;state))
<span class="p_header">diff --git a/drivers/media/dvb-frontends/si2168.c b/drivers/media/dvb-frontends/si2168.c</span>
<span class="p_header">index 5db588ebfc24..391e98395b41 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/si2168.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/si2168.c</span>
<span class="p_chunk">@@ -457,6 +457,10 @@</span> <span class="p_context"> static int si2168_init(struct dvb_frontend *fe)</span>
 		/* firmware is in the new format */
 		for (remaining = fw-&gt;size; remaining &gt; 0; remaining -= 17) {
 			len = fw-&gt;data[fw-&gt;size - remaining];
<span class="p_add">+			if (len &gt; SI2168_ARGLEN) {</span>
<span class="p_add">+				ret = -EINVAL;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
 			memcpy(cmd.args, &amp;fw-&gt;data[(fw-&gt;size - remaining) + 1], len);
 			cmd.wlen = len;
 			cmd.rlen = 1;
<span class="p_header">diff --git a/drivers/media/tuners/si2157.c b/drivers/media/tuners/si2157.c</span>
<span class="p_header">index d74ae26621ca..c5dbba5b5bc9 100644</span>
<span class="p_header">--- a/drivers/media/tuners/si2157.c</span>
<span class="p_header">+++ b/drivers/media/tuners/si2157.c</span>
<span class="p_chunk">@@ -165,6 +165,10 @@</span> <span class="p_context"> static int si2157_init(struct dvb_frontend *fe)</span>
 
 	for (remaining = fw-&gt;size; remaining &gt; 0; remaining -= 17) {
 		len = fw-&gt;data[fw-&gt;size - remaining];
<span class="p_add">+		if (len &gt; SI2157_ARGLEN) {</span>
<span class="p_add">+			dev_err(&amp;client-&gt;dev, &quot;Bad firmware length\n&quot;);</span>
<span class="p_add">+			goto err_release_firmware;</span>
<span class="p_add">+		}</span>
 		memcpy(cmd.args, &amp;fw-&gt;data[(fw-&gt;size - remaining) + 1], len);
 		cmd.wlen = len;
 		cmd.rlen = 1;
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb-v2/rtl28xxu.c b/drivers/media/usb/dvb-usb-v2/rtl28xxu.c</span>
<span class="p_header">index 895441fe90f7..e862554952c1 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb-v2/rtl28xxu.c</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb-v2/rtl28xxu.c</span>
<span class="p_chunk">@@ -34,6 +34,14 @@</span> <span class="p_context"> static int rtl28xxu_ctrl_msg(struct dvb_usb_device *d, struct rtl28xxu_req *req)</span>
 	unsigned int pipe;
 	u8 requesttype;
 
<span class="p_add">+	mutex_lock(&amp;d-&gt;usb_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (req-&gt;size &gt; sizeof(dev-&gt;buf)) {</span>
<span class="p_add">+		dev_err(&amp;d-&gt;intf-&gt;dev, &quot;too large message %u\n&quot;, req-&gt;size);</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto err_mutex_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (req-&gt;index &amp; CMD_WR_FLAG) {
 		/* write */
 		memcpy(dev-&gt;buf, req-&gt;data, req-&gt;size);
<span class="p_chunk">@@ -50,14 +58,17 @@</span> <span class="p_context"> static int rtl28xxu_ctrl_msg(struct dvb_usb_device *d, struct rtl28xxu_req *req)</span>
 	dvb_usb_dbg_usb_control_msg(d-&gt;udev, 0, requesttype, req-&gt;value,
 			req-&gt;index, dev-&gt;buf, req-&gt;size);
 	if (ret &lt; 0)
<span class="p_del">-		goto err;</span>
<span class="p_add">+		goto err_mutex_unlock;</span>
 
 	/* read request, copy returned data to return buf */
 	if (requesttype == (USB_TYPE_VENDOR | USB_DIR_IN))
 		memcpy(req-&gt;data, dev-&gt;buf, req-&gt;size);
 
<span class="p_add">+	mutex_unlock(&amp;d-&gt;usb_mutex);</span>
<span class="p_add">+</span>
 	return 0;
<span class="p_del">-err:</span>
<span class="p_add">+err_mutex_unlock:</span>
<span class="p_add">+	mutex_unlock(&amp;d-&gt;usb_mutex);</span>
 	dev_dbg(&amp;d-&gt;intf-&gt;dev, &quot;failed=%d\n&quot;, ret);
 	return ret;
 }
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb-v2/rtl28xxu.h b/drivers/media/usb/dvb-usb-v2/rtl28xxu.h</span>
<span class="p_header">index 1b5d7ffb685e..1bdeda05d332 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb-v2/rtl28xxu.h</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb-v2/rtl28xxu.h</span>
<span class="p_chunk">@@ -69,7 +69,7 @@</span> <span class="p_context"></span>
 
 
 struct rtl28xxu_dev {
<span class="p_del">-	u8 buf[28];</span>
<span class="p_add">+	u8 buf[128];</span>
 	u8 chip_id;
 	u8 tuner;
 	char *tuner_name;
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/init.c b/drivers/net/wireless/ath/ath9k/init.c</span>
<span class="p_header">index f8d11efa7b0f..46a389c20bfc 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/init.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/init.c</span>
<span class="p_chunk">@@ -874,6 +874,7 @@</span> <span class="p_context"> static void ath9k_set_hw_capab(struct ath_softc *sc, struct ieee80211_hw *hw)</span>
 	hw-&gt;max_rate_tries = 10;
 	hw-&gt;sta_data_size = sizeof(struct ath_node);
 	hw-&gt;vif_data_size = sizeof(struct ath_vif);
<span class="p_add">+	hw-&gt;extra_tx_headroom = 4;</span>
 
 	hw-&gt;wiphy-&gt;available_antennas_rx = BIT(ah-&gt;caps.max_rxchains) - 1;
 	hw-&gt;wiphy-&gt;available_antennas_tx = BIT(ah-&gt;caps.max_txchains) - 1;
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/dvm/lib.c b/drivers/net/wireless/iwlwifi/dvm/lib.c</span>
<span class="p_header">index 1d2223df5cb0..e7d3566c714b 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/dvm/lib.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/dvm/lib.c</span>
<span class="p_chunk">@@ -1022,7 +1022,7 @@</span> <span class="p_context"> static void iwlagn_wowlan_program_keys(struct ieee80211_hw *hw,</span>
 			u8 *pn = seq.ccmp.pn;
 
 			ieee80211_get_key_rx_seq(key, i, &amp;seq);
<span class="p_del">-			aes_sc-&gt;pn = cpu_to_le64(</span>
<span class="p_add">+			aes_sc[i].pn = cpu_to_le64(</span>
 					(u64)pn[5] |
 					((u64)pn[4] &lt;&lt; 8) |
 					((u64)pn[3] &lt;&lt; 16) |
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/iwl-7000.c b/drivers/net/wireless/iwlwifi/iwl-7000.c</span>
<span class="p_header">index 74ad278116be..fd83e30eaf00 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/iwl-7000.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/iwl-7000.c</span>
<span class="p_chunk">@@ -325,6 +325,6 @@</span> <span class="p_context"> const struct iwl_cfg iwl7265d_n_cfg = {</span>
 };
 
 MODULE_FIRMWARE(IWL7260_MODULE_FIRMWARE(IWL7260_UCODE_API_OK));
<span class="p_del">-MODULE_FIRMWARE(IWL3160_MODULE_FIRMWARE(IWL3160_UCODE_API_OK));</span>
<span class="p_add">+MODULE_FIRMWARE(IWL3160_MODULE_FIRMWARE(IWL7260_UCODE_API_OK));</span>
 MODULE_FIRMWARE(IWL7265_MODULE_FIRMWARE(IWL7260_UCODE_API_OK));
 MODULE_FIRMWARE(IWL7265D_MODULE_FIRMWARE(IWL7260_UCODE_API_OK));
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/d3.c b/drivers/net/wireless/iwlwifi/mvm/d3.c</span>
<span class="p_header">index 4310cf102d78..89d6a6100c88 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/d3.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/d3.c</span>
<span class="p_chunk">@@ -298,12 +298,12 @@</span> <span class="p_context"> static void iwl_mvm_wowlan_program_keys(struct ieee80211_hw *hw,</span>
 			u8 *pn = seq.ccmp.pn;
 
 			ieee80211_get_key_rx_seq(key, i, &amp;seq);
<span class="p_del">-			aes_sc-&gt;pn = cpu_to_le64((u64)pn[5] |</span>
<span class="p_del">-						 ((u64)pn[4] &lt;&lt; 8) |</span>
<span class="p_del">-						 ((u64)pn[3] &lt;&lt; 16) |</span>
<span class="p_del">-						 ((u64)pn[2] &lt;&lt; 24) |</span>
<span class="p_del">-						 ((u64)pn[1] &lt;&lt; 32) |</span>
<span class="p_del">-						 ((u64)pn[0] &lt;&lt; 40));</span>
<span class="p_add">+			aes_sc[i].pn = cpu_to_le64((u64)pn[5] |</span>
<span class="p_add">+						   ((u64)pn[4] &lt;&lt; 8) |</span>
<span class="p_add">+						   ((u64)pn[3] &lt;&lt; 16) |</span>
<span class="p_add">+						   ((u64)pn[2] &lt;&lt; 24) |</span>
<span class="p_add">+						   ((u64)pn[1] &lt;&lt; 32) |</span>
<span class="p_add">+						   ((u64)pn[0] &lt;&lt; 40));</span>
 		}
 		data-&gt;use_rsc_tsc = true;
 		break;
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/fw.c b/drivers/net/wireless/iwlwifi/mvm/fw.c</span>
<span class="p_header">index df869633f4dd..1e1c77a59760 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/fw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/fw.c</span>
<span class="p_chunk">@@ -364,7 +364,7 @@</span> <span class="p_context"> int iwl_run_init_mvm_ucode(struct iwl_mvm *mvm, bool read_nvm)</span>
 	 * abort after reading the nvm in case RF Kill is on, we will complete
 	 * the init seq later when RF kill will switch to off
 	 */
<span class="p_del">-	if (iwl_mvm_is_radio_killed(mvm)) {</span>
<span class="p_add">+	if (iwl_mvm_is_radio_hw_killed(mvm)) {</span>
 		IWL_DEBUG_RF_KILL(mvm,
 				  &quot;jump over all phy activities due to RF kill\n&quot;);
 		iwl_remove_notification(&amp;mvm-&gt;notif_wait, &amp;calib_wait);
<span class="p_chunk">@@ -397,7 +397,7 @@</span> <span class="p_context"> int iwl_run_init_mvm_ucode(struct iwl_mvm *mvm, bool read_nvm)</span>
 	ret = iwl_wait_notification(&amp;mvm-&gt;notif_wait, &amp;calib_wait,
 			MVM_UCODE_CALIB_TIMEOUT);
 
<span class="p_del">-	if (ret &amp;&amp; iwl_mvm_is_radio_killed(mvm)) {</span>
<span class="p_add">+	if (ret &amp;&amp; iwl_mvm_is_radio_hw_killed(mvm)) {</span>
 		IWL_DEBUG_RF_KILL(mvm, &quot;RFKILL while calibrating.\n&quot;);
 		ret = 1;
 	}
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/mac80211.c b/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">index 60c138a9bf4f..9779c1e5688c 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_chunk">@@ -2277,6 +2277,7 @@</span> <span class="p_context"> static void iwl_mvm_stop_ap_ibss(struct ieee80211_hw *hw,</span>
 		iwl_mvm_remove_time_event(mvm, mvmvif,
 					  &amp;mvmvif-&gt;time_event_data);
 		RCU_INIT_POINTER(mvm-&gt;csa_vif, NULL);
<span class="p_add">+		mvmvif-&gt;csa_countdown = false;</span>
 	}
 
 	if (rcu_access_pointer(mvm-&gt;csa_tx_blocked_vif) == vif) {
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/mvm.h b/drivers/net/wireless/iwlwifi/mvm/mvm.h</span>
<span class="p_header">index 6af21daaaaef..83273adfabdd 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/mvm.h</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/mvm.h</span>
<span class="p_chunk">@@ -870,6 +870,11 @@</span> <span class="p_context"> static inline bool iwl_mvm_is_radio_killed(struct iwl_mvm *mvm)</span>
 	       test_bit(IWL_MVM_STATUS_HW_CTKILL, &amp;mvm-&gt;status);
 }
 
<span class="p_add">+static inline bool iwl_mvm_is_radio_hw_killed(struct iwl_mvm *mvm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return test_bit(IWL_MVM_STATUS_HW_RFKILL, &amp;mvm-&gt;status);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Must be called with rcu_read_lock() held and it can only be
  * released when mvmsta is not needed anymore.
  */
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/ops.c b/drivers/net/wireless/iwlwifi/mvm/ops.c</span>
<span class="p_header">index 2ea01238754e..8d4f287dca3b 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/ops.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/ops.c</span>
<span class="p_chunk">@@ -589,6 +589,7 @@</span> <span class="p_context"> iwl_op_mode_mvm_start(struct iwl_trans *trans, const struct iwl_cfg *cfg,</span>
 	ieee80211_unregister_hw(mvm-&gt;hw);
 	iwl_mvm_leds_exit(mvm);
  out_free:
<span class="p_add">+	flush_delayed_work(&amp;mvm-&gt;fw_dump_wk);</span>
 	iwl_phy_db_free(mvm-&gt;phy_db);
 	kfree(mvm-&gt;scan_cmd);
 	if (!cfg-&gt;no_power_up_nic_in_init || !mvm-&gt;nvm_file_name)
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/pcie/drv.c b/drivers/net/wireless/iwlwifi/pcie/drv.c</span>
<span class="p_header">index b18569734922..8b16949a9cb9 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/pcie/drv.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/pcie/drv.c</span>
<span class="p_chunk">@@ -412,6 +412,11 @@</span> <span class="p_context"> static const struct pci_device_id iwl_hw_card_ids[] = {</span>
 	{IWL_PCI_DEVICE(0x095A, 0x5590, iwl7265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x095B, 0x5290, iwl7265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x095A, 0x5490, iwl7265_2ac_cfg)},
<span class="p_add">+	{IWL_PCI_DEVICE(0x095A, 0x5F10, iwl7265_2ac_cfg)},</span>
<span class="p_add">+	{IWL_PCI_DEVICE(0x095B, 0x5212, iwl7265_2ac_cfg)},</span>
<span class="p_add">+	{IWL_PCI_DEVICE(0x095B, 0x520A, iwl7265_2ac_cfg)},</span>
<span class="p_add">+	{IWL_PCI_DEVICE(0x095A, 0x9000, iwl7265_2ac_cfg)},</span>
<span class="p_add">+	{IWL_PCI_DEVICE(0x095A, 0x9400, iwl7265_2ac_cfg)},</span>
 
 /* 8000 Series */
 	{IWL_PCI_DEVICE(0x24F3, 0x0010, iwl8260_2ac_cfg)},
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/pci.h b/drivers/net/wireless/rtlwifi/pci.h</span>
<span class="p_header">index d4567d12e07e..5da6703942d9 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/pci.h</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/pci.h</span>
<span class="p_chunk">@@ -247,6 +247,8 @@</span> <span class="p_context"> struct rtl_pci {</span>
 	/* MSI support */
 	bool msi_support;
 	bool using_msi;
<span class="p_add">+	/* interrupt clear before set */</span>
<span class="p_add">+	bool int_clear;</span>
 };
 
 struct mp_adapter {
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c b/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_header">index 3fa2fb7c8e4e..76e52dfb2be5 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_chunk">@@ -2253,11 +2253,28 @@</span> <span class="p_context"> void rtl8821ae_set_qos(struct ieee80211_hw *hw, int aci)</span>
 	}
 }
 
<span class="p_add">+static void rtl8821ae_clear_interrupt(struct ieee80211_hw *hw)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rtl_priv *rtlpriv = rtl_priv(hw);</span>
<span class="p_add">+	u32 tmp = rtl_read_dword(rtlpriv, REG_HISR);</span>
<span class="p_add">+</span>
<span class="p_add">+	rtl_write_dword(rtlpriv, REG_HISR, tmp);</span>
<span class="p_add">+</span>
<span class="p_add">+	tmp = rtl_read_dword(rtlpriv, REG_HISRE);</span>
<span class="p_add">+	rtl_write_dword(rtlpriv, REG_HISRE, tmp);</span>
<span class="p_add">+</span>
<span class="p_add">+	tmp = rtl_read_dword(rtlpriv, REG_HSISR);</span>
<span class="p_add">+	rtl_write_dword(rtlpriv, REG_HSISR, tmp);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void rtl8821ae_enable_interrupt(struct ieee80211_hw *hw)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
 
<span class="p_add">+	if (!rtlpci-&gt;int_clear)</span>
<span class="p_add">+		rtl8821ae_clear_interrupt(hw);/*clear it here first*/</span>
<span class="p_add">+</span>
 	rtl_write_dword(rtlpriv, REG_HIMR, rtlpci-&gt;irq_mask[0] &amp; 0xFFFFFFFF);
 	rtl_write_dword(rtlpriv, REG_HIMRE, rtlpci-&gt;irq_mask[1] &amp; 0xFFFFFFFF);
 	rtlpci-&gt;irq_enabled = true;
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8821ae/sw.c b/drivers/net/wireless/rtlwifi/rtl8821ae/sw.c</span>
<span class="p_header">index a4988121e1ab..8ee141a55bc5 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8821ae/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8821ae/sw.c</span>
<span class="p_chunk">@@ -96,6 +96,7 @@</span> <span class="p_context"> int rtl8821ae_init_sw_vars(struct ieee80211_hw *hw)</span>
 
 	rtl8821ae_bt_reg_init(hw);
 	rtlpci-&gt;msi_support = rtlpriv-&gt;cfg-&gt;mod_params-&gt;msi_support;
<span class="p_add">+	rtlpci-&gt;int_clear = rtlpriv-&gt;cfg-&gt;mod_params-&gt;int_clear;</span>
 	rtlpriv-&gt;btcoexist.btc_ops = rtl_btc_get_ops_pointer();
 
 	rtlpriv-&gt;dm.dm_initialgain_enable = 1;
<span class="p_chunk">@@ -167,6 +168,7 @@</span> <span class="p_context"> int rtl8821ae_init_sw_vars(struct ieee80211_hw *hw)</span>
 	rtlpriv-&gt;psc.swctrl_lps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;swctrl_lps;
 	rtlpriv-&gt;psc.fwctrl_lps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;fwctrl_lps;
 	rtlpci-&gt;msi_support = rtlpriv-&gt;cfg-&gt;mod_params-&gt;msi_support;
<span class="p_add">+	rtlpci-&gt;msi_support = rtlpriv-&gt;cfg-&gt;mod_params-&gt;int_clear;</span>
 	if (rtlpriv-&gt;cfg-&gt;mod_params-&gt;disable_watchdog)
 		pr_info(&quot;watchdog disabled\n&quot;);
 	rtlpriv-&gt;psc.reg_fwctrl_lps = 3;
<span class="p_chunk">@@ -308,6 +310,7 @@</span> <span class="p_context"> static struct rtl_mod_params rtl8821ae_mod_params = {</span>
 	.swctrl_lps = false,
 	.fwctrl_lps = true,
 	.msi_support = true,
<span class="p_add">+	.int_clear = true,</span>
 	.debug = DBG_EMERG,
 	.disable_watchdog = 0,
 };
<span class="p_chunk">@@ -437,6 +440,7 @@</span> <span class="p_context"> module_param_named(fwlps, rtl8821ae_mod_params.fwctrl_lps, bool, 0444);</span>
 module_param_named(msi, rtl8821ae_mod_params.msi_support, bool, 0444);
 module_param_named(disable_watchdog, rtl8821ae_mod_params.disable_watchdog,
 		   bool, 0444);
<span class="p_add">+module_param_named(int_clear, rtl8821ae_mod_params.int_clear, bool, 0444);</span>
 MODULE_PARM_DESC(swenc, &quot;Set to 1 for software crypto (default 0)\n&quot;);
 MODULE_PARM_DESC(ips, &quot;Set to 0 to not use link power save (default 1)\n&quot;);
 MODULE_PARM_DESC(swlps, &quot;Set to 1 to use SW control power save (default 0)\n&quot;);
<span class="p_chunk">@@ -444,6 +448,7 @@</span> <span class="p_context"> MODULE_PARM_DESC(fwlps, &quot;Set to 1 to use FW control power save (default 1)\n&quot;);</span>
 MODULE_PARM_DESC(msi, &quot;Set to 1 to use MSI interrupts mode (default 1)\n&quot;);
 MODULE_PARM_DESC(debug, &quot;Set debug level (0-5) (default 0)&quot;);
 MODULE_PARM_DESC(disable_watchdog, &quot;Set to 1 to disable the watchdog (default 0)\n&quot;);
<span class="p_add">+MODULE_PARM_DESC(int_clear, &quot;Set to 1 to disable interrupt clear before set (default 0)\n&quot;);</span>
 
 static SIMPLE_DEV_PM_OPS(rtlwifi_pm_ops, rtl_pci_suspend, rtl_pci_resume);
 
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/wifi.h b/drivers/net/wireless/rtlwifi/wifi.h</span>
<span class="p_header">index 51572912c53d..f1fa8100f288 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/wifi.h</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/wifi.h</span>
<span class="p_chunk">@@ -2233,6 +2233,9 @@</span> <span class="p_context"> struct rtl_mod_params {</span>
 
 	/* default 0: 1 means disable */
 	bool disable_watchdog;
<span class="p_add">+</span>
<span class="p_add">+	/* default 0: 1 means do not disable interrupts */</span>
<span class="p_add">+	bool int_clear;</span>
 };
 
 struct rtl_hal_usbint_cfg {
<span class="p_header">diff --git a/drivers/of/platform.c b/drivers/of/platform.c</span>
<span class="p_header">index a01f57c9e34e..ddf8e42c9367 100644</span>
<span class="p_header">--- a/drivers/of/platform.c</span>
<span class="p_header">+++ b/drivers/of/platform.c</span>
<span class="p_chunk">@@ -25,6 +25,7 @@</span> <span class="p_context"></span>
 
 const struct of_device_id of_default_bus_match_table[] = {
 	{ .compatible = &quot;simple-bus&quot;, },
<span class="p_add">+	{ .compatible = &quot;simple-mfd&quot;, },</span>
 #ifdef CONFIG_ARM_AMBA
 	{ .compatible = &quot;arm,amba-bus&quot;, },
 #endif /* CONFIG_ARM_AMBA */
<span class="p_header">diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c</span>
<span class="p_header">index 312f23a8429c..92618686604c 100644</span>
<span class="p_header">--- a/drivers/pci/pci-sysfs.c</span>
<span class="p_header">+++ b/drivers/pci/pci-sysfs.c</span>
<span class="p_chunk">@@ -216,7 +216,7 @@</span> <span class="p_context"> static ssize_t numa_node_store(struct device *dev,</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	if (!node_online(node))</span>
<span class="p_add">+	if (node &gt;= MAX_NUMNODES || !node_online(node))</span>
 		return -EINVAL;
 
 	add_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_STILL_OK);
<span class="p_header">diff --git a/drivers/pinctrl/intel/pinctrl-baytrail.c b/drivers/pinctrl/intel/pinctrl-baytrail.c</span>
<span class="p_header">index 2062c224e32f..b2602210784d 100644</span>
<span class="p_header">--- a/drivers/pinctrl/intel/pinctrl-baytrail.c</span>
<span class="p_header">+++ b/drivers/pinctrl/intel/pinctrl-baytrail.c</span>
<span class="p_chunk">@@ -146,7 +146,7 @@</span> <span class="p_context"> struct byt_gpio_pin_context {</span>
 struct byt_gpio {
 	struct gpio_chip		chip;
 	struct platform_device		*pdev;
<span class="p_del">-	spinlock_t			lock;</span>
<span class="p_add">+	raw_spinlock_t			lock;</span>
 	void __iomem			*reg_base;
 	struct pinctrl_gpio_range	*range;
 	struct byt_gpio_pin_context	*saved_context;
<span class="p_chunk">@@ -174,11 +174,11 @@</span> <span class="p_context"> static void byt_gpio_clear_triggering(struct byt_gpio *vg, unsigned offset)</span>
 	unsigned long flags;
 	u32 value;
 
<span class="p_del">-	spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
 	value = readl(reg);
 	value &amp;= ~(BYT_TRIG_POS | BYT_TRIG_NEG | BYT_TRIG_LVL);
 	writel(value, reg);
<span class="p_del">-	spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
 }
 
 static u32 byt_get_gpio_mux(struct byt_gpio *vg, unsigned offset)
<span class="p_chunk">@@ -201,6 +201,9 @@</span> <span class="p_context"> static int byt_gpio_request(struct gpio_chip *chip, unsigned offset)</span>
 	struct byt_gpio *vg = to_byt_gpio(chip);
 	void __iomem *reg = byt_gpio_reg(chip, offset, BYT_CONF0_REG);
 	u32 value, gpio_mux;
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
 
 	/*
 	 * In most cases, func pin mux 000 means GPIO function.
<span class="p_chunk">@@ -214,18 +217,16 @@</span> <span class="p_context"> static int byt_gpio_request(struct gpio_chip *chip, unsigned offset)</span>
 	value = readl(reg) &amp; BYT_PIN_MUX;
 	gpio_mux = byt_get_gpio_mux(vg, offset);
 	if (WARN_ON(gpio_mux != value)) {
<span class="p_del">-		unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-		spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
 		value = readl(reg) &amp; ~BYT_PIN_MUX;
 		value |= gpio_mux;
 		writel(value, reg);
<span class="p_del">-		spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
 
 		dev_warn(&amp;vg-&gt;pdev-&gt;dev,
 			 &quot;pin %u forcibly re-configured as GPIO\n&quot;, offset);
 	}
 
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+</span>
 	pm_runtime_get(&amp;vg-&gt;pdev-&gt;dev);
 
 	return 0;
<span class="p_chunk">@@ -250,7 +251,7 @@</span> <span class="p_context"> static int byt_irq_type(struct irq_data *d, unsigned type)</span>
 	if (offset &gt;= vg-&gt;chip.ngpio)
 		return -EINVAL;
 
<span class="p_del">-	spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
 	value = readl(reg);
 
 	WARN(value &amp; BYT_DIRECT_IRQ_EN,
<span class="p_chunk">@@ -269,7 +270,7 @@</span> <span class="p_context"> static int byt_irq_type(struct irq_data *d, unsigned type)</span>
 	else if (type &amp; IRQ_TYPE_LEVEL_MASK)
 		__irq_set_handler_locked(d-&gt;irq, handle_level_irq);
 
<span class="p_del">-	spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -277,7 +278,15 @@</span> <span class="p_context"> static int byt_irq_type(struct irq_data *d, unsigned type)</span>
 static int byt_gpio_get(struct gpio_chip *chip, unsigned offset)
 {
 	void __iomem *reg = byt_gpio_reg(chip, offset, BYT_VAL_REG);
<span class="p_del">-	return readl(reg) &amp; BYT_LEVEL;</span>
<span class="p_add">+	struct byt_gpio *vg = to_byt_gpio(chip);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	val = readl(reg);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return val &amp; BYT_LEVEL;</span>
 }
 
 static void byt_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
<span class="p_chunk">@@ -287,7 +296,7 @@</span> <span class="p_context"> static void byt_gpio_set(struct gpio_chip *chip, unsigned offset, int value)</span>
 	unsigned long flags;
 	u32 old_val;
 
<span class="p_del">-	spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
 
 	old_val = readl(reg);
 
<span class="p_chunk">@@ -296,7 +305,7 @@</span> <span class="p_context"> static void byt_gpio_set(struct gpio_chip *chip, unsigned offset, int value)</span>
 	else
 		writel(old_val &amp; ~BYT_LEVEL, reg);
 
<span class="p_del">-	spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
 }
 
 static int byt_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
<span class="p_chunk">@@ -306,13 +315,13 @@</span> <span class="p_context"> static int byt_gpio_direction_input(struct gpio_chip *chip, unsigned offset)</span>
 	unsigned long flags;
 	u32 value;
 
<span class="p_del">-	spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
 
 	value = readl(reg) | BYT_DIR_MASK;
 	value &amp;= ~BYT_INPUT_EN;		/* active low */
 	writel(value, reg);
 
<span class="p_del">-	spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -326,7 +335,7 @@</span> <span class="p_context"> static int byt_gpio_direction_output(struct gpio_chip *chip,</span>
 	unsigned long flags;
 	u32 reg_val;
 
<span class="p_del">-	spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
 
 	/*
 	 * Before making any direction modifications, do a check if gpio
<span class="p_chunk">@@ -345,7 +354,7 @@</span> <span class="p_context"> static int byt_gpio_direction_output(struct gpio_chip *chip,</span>
 	else
 		writel(reg_val &amp; ~BYT_LEVEL, reg);
 
<span class="p_del">-	spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -354,18 +363,19 @@</span> <span class="p_context"> static void byt_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)</span>
 {
 	struct byt_gpio *vg = to_byt_gpio(chip);
 	int i;
<span class="p_del">-	unsigned long flags;</span>
 	u32 conf0, val, offs;
 
<span class="p_del">-	spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
<span class="p_del">-</span>
 	for (i = 0; i &lt; vg-&gt;chip.ngpio; i++) {
 		const char *pull_str = NULL;
 		const char *pull = NULL;
<span class="p_add">+		unsigned long flags;</span>
 		const char *label;
 		offs = vg-&gt;range-&gt;pins[i] * 16;
<span class="p_add">+</span>
<span class="p_add">+		raw_spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
 		conf0 = readl(vg-&gt;reg_base + offs + BYT_CONF0_REG);
 		val = readl(vg-&gt;reg_base + offs + BYT_VAL_REG);
<span class="p_add">+		raw_spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
 
 		label = gpiochip_is_requested(chip, i);
 		if (!label)
<span class="p_chunk">@@ -418,7 +428,6 @@</span> <span class="p_context"> static void byt_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)</span>
 
 		seq_puts(s, &quot;\n&quot;);
 	}
<span class="p_del">-	spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
 }
 
 static void byt_gpio_irq_handler(unsigned irq, struct irq_desc *desc)
<span class="p_chunk">@@ -450,8 +459,10 @@</span> <span class="p_context"> static void byt_irq_ack(struct irq_data *d)</span>
 	unsigned offset = irqd_to_hwirq(d);
 	void __iomem *reg;
 
<span class="p_add">+	raw_spin_lock(&amp;vg-&gt;lock);</span>
 	reg = byt_gpio_reg(&amp;vg-&gt;chip, offset, BYT_INT_STAT_REG);
 	writel(BIT(offset % 32), reg);
<span class="p_add">+	raw_spin_unlock(&amp;vg-&gt;lock);</span>
 }
 
 static void byt_irq_unmask(struct irq_data *d)
<span class="p_chunk">@@ -463,9 +474,9 @@</span> <span class="p_context"> static void byt_irq_unmask(struct irq_data *d)</span>
 	void __iomem *reg;
 	u32 value;
 
<span class="p_del">-	spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
<span class="p_del">-</span>
 	reg = byt_gpio_reg(&amp;vg-&gt;chip, offset, BYT_CONF0_REG);
<span class="p_add">+</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
 	value = readl(reg);
 
 	switch (irqd_get_trigger_type(d)) {
<span class="p_chunk">@@ -486,7 +497,7 @@</span> <span class="p_context"> static void byt_irq_unmask(struct irq_data *d)</span>
 
 	writel(value, reg);
 
<span class="p_del">-	spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
 }
 
 static void byt_irq_mask(struct irq_data *d)
<span class="p_chunk">@@ -578,7 +589,7 @@</span> <span class="p_context"> static int byt_gpio_probe(struct platform_device *pdev)</span>
 	if (IS_ERR(vg-&gt;reg_base))
 		return PTR_ERR(vg-&gt;reg_base);
 
<span class="p_del">-	spin_lock_init(&amp;vg-&gt;lock);</span>
<span class="p_add">+	raw_spin_lock_init(&amp;vg-&gt;lock);</span>
 
 	gc = &amp;vg-&gt;chip;
 	gc-&gt;label = dev_name(&amp;pdev-&gt;dev);
<span class="p_header">diff --git a/drivers/scsi/mvsas/mv_sas.c b/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_header">index 454536c49315..9c780740fb82 100644</span>
<span class="p_header">--- a/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_header">+++ b/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_chunk">@@ -887,6 +887,8 @@</span> <span class="p_context"> static void mvs_slot_free(struct mvs_info *mvi, u32 rx_desc)</span>
 static void mvs_slot_task_free(struct mvs_info *mvi, struct sas_task *task,
 			  struct mvs_slot_info *slot, u32 slot_idx)
 {
<span class="p_add">+	if (!slot)</span>
<span class="p_add">+		return;</span>
 	if (!slot-&gt;task)
 		return;
 	if (!sas_protocol_ata(task-&gt;task_proto))
<span class="p_header">diff --git a/drivers/staging/iio/accel/sca3000_ring.c b/drivers/staging/iio/accel/sca3000_ring.c</span>
<span class="p_header">index 8589eade1057..de65a8730d88 100644</span>
<span class="p_header">--- a/drivers/staging/iio/accel/sca3000_ring.c</span>
<span class="p_header">+++ b/drivers/staging/iio/accel/sca3000_ring.c</span>
<span class="p_chunk">@@ -116,7 +116,7 @@</span> <span class="p_context"> static int sca3000_read_first_n_hw_rb(struct iio_buffer *r,</span>
 	if (ret)
 		goto error_ret;
 
<span class="p_del">-	for (i = 0; i &lt; num_read; i++)</span>
<span class="p_add">+	for (i = 0; i &lt; num_read / sizeof(u16); i++)</span>
 		*(((u16 *)rx) + i) = be16_to_cpup((__be16 *)rx + i);
 
 	if (copy_to_user(buf, rx, num_read))
<span class="p_header">diff --git a/drivers/staging/iio/adc/mxs-lradc.c b/drivers/staging/iio/adc/mxs-lradc.c</span>
<span class="p_header">index d7c5223f1c3e..2931ea9b75d1 100644</span>
<span class="p_header">--- a/drivers/staging/iio/adc/mxs-lradc.c</span>
<span class="p_header">+++ b/drivers/staging/iio/adc/mxs-lradc.c</span>
<span class="p_chunk">@@ -919,11 +919,12 @@</span> <span class="p_context"> static int mxs_lradc_read_raw(struct iio_dev *iio_dev,</span>
 	case IIO_CHAN_INFO_OFFSET:
 		if (chan-&gt;type == IIO_TEMP) {
 			/* The calculated value from the ADC is in Kelvin, we
<span class="p_del">-			 * want Celsius for hwmon so the offset is</span>
<span class="p_del">-			 * -272.15 * scale</span>
<span class="p_add">+			 * want Celsius for hwmon so the offset is -273.15</span>
<span class="p_add">+			 * The offset is applied before scaling so it is</span>
<span class="p_add">+			 * actually -213.15 * 4 / 1.012 = -1079.644268</span>
 			 */
<span class="p_del">-			*val = -1075;</span>
<span class="p_del">-			*val2 = 691699;</span>
<span class="p_add">+			*val = -1079;</span>
<span class="p_add">+			*val2 = 644268;</span>
 
 			return IIO_VAL_INT_PLUS_MICRO;
 		}
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_dma.c b/drivers/tty/serial/8250/8250_dma.c</span>
<span class="p_header">index 21d01a491405..e508939daea3 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_dma.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_dma.c</span>
<span class="p_chunk">@@ -80,10 +80,6 @@</span> <span class="p_context"> int serial8250_tx_dma(struct uart_8250_port *p)</span>
 		return 0;
 
 	dma-&gt;tx_size = CIRC_CNT_TO_END(xmit-&gt;head, xmit-&gt;tail, UART_XMIT_SIZE);
<span class="p_del">-	if (dma-&gt;tx_size &lt; p-&gt;port.fifosize) {</span>
<span class="p_del">-		ret = -EINVAL;</span>
<span class="p_del">-		goto err;</span>
<span class="p_del">-	}</span>
 
 	desc = dmaengine_prep_slave_single(dma-&gt;txchan,
 					   dma-&gt;tx_addr + xmit-&gt;tail,
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_pci.c b/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_header">index 9373cca121d3..eb8adc2e68c1 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_chunk">@@ -1998,6 +1998,7 @@</span> <span class="p_context"> pci_wch_ch38x_setup(struct serial_private *priv,</span>
 #define PCIE_DEVICE_ID_WCH_CH382_2S1P	0x3250
 #define PCIE_DEVICE_ID_WCH_CH384_4S	0x3470
 
<span class="p_add">+#define PCI_DEVICE_ID_EXAR_XR17V4358	0x4358</span>
 #define PCI_DEVICE_ID_EXAR_XR17V8358	0x8358
 
 #define PCI_VENDOR_ID_PERICOM			0x12D8
<span class="p_chunk">@@ -2515,6 +2516,13 @@</span> <span class="p_context"> static struct pci_serial_quirk pci_serial_quirks[] __refdata = {</span>
 	},
 	{
 		.vendor = PCI_VENDOR_ID_EXAR,
<span class="p_add">+		.device = PCI_DEVICE_ID_EXAR_XR17V4358,</span>
<span class="p_add">+		.subvendor	= PCI_ANY_ID,</span>
<span class="p_add">+		.subdevice	= PCI_ANY_ID,</span>
<span class="p_add">+		.setup		= pci_xr17v35x_setup,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.vendor = PCI_VENDOR_ID_EXAR,</span>
 		.device = PCI_DEVICE_ID_EXAR_XR17V8358,
 		.subvendor	= PCI_ANY_ID,
 		.subdevice	= PCI_ANY_ID,
<span class="p_chunk">@@ -2999,6 +3007,7 @@</span> <span class="p_context"> enum pci_board_num_t {</span>
 	pbn_exar_XR17V352,
 	pbn_exar_XR17V354,
 	pbn_exar_XR17V358,
<span class="p_add">+	pbn_exar_XR17V4358,</span>
 	pbn_exar_XR17V8358,
 	pbn_exar_ibm_saturn,
 	pbn_pasemi_1682M,
<span class="p_chunk">@@ -3690,6 +3699,14 @@</span> <span class="p_context"> static struct pciserial_board pci_boards[] = {</span>
 		.reg_shift	= 0,
 		.first_offset	= 0,
 	},
<span class="p_add">+	[pbn_exar_XR17V4358] = {</span>
<span class="p_add">+		.flags		= FL_BASE0,</span>
<span class="p_add">+		.num_ports	= 12,</span>
<span class="p_add">+		.base_baud	= 7812500,</span>
<span class="p_add">+		.uart_offset	= 0x400,</span>
<span class="p_add">+		.reg_shift	= 0,</span>
<span class="p_add">+		.first_offset	= 0,</span>
<span class="p_add">+	},</span>
 	[pbn_exar_XR17V8358] = {
 		.flags		= FL_BASE0,
 		.num_ports	= 16,
<span class="p_chunk">@@ -5133,6 +5150,10 @@</span> <span class="p_context"> static struct pci_device_id serial_pci_tbl[] = {</span>
 		PCI_ANY_ID, PCI_ANY_ID,
 		0,
 		0, pbn_exar_XR17V358 },
<span class="p_add">+	{	PCI_VENDOR_ID_EXAR, PCI_DEVICE_ID_EXAR_XR17V4358,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID,</span>
<span class="p_add">+		0,</span>
<span class="p_add">+		0, pbn_exar_XR17V4358 },</span>
 	{	PCI_VENDOR_ID_EXAR, PCI_DEVICE_ID_EXAR_XR17V8358,
 		PCI_ANY_ID, PCI_ANY_ID,
 		0,
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index 2af32e26fafc..7e5c90eebb9c 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -135,6 +135,7 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL &amp;&amp;
 		pdev-&gt;device == PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI) {
 		xhci-&gt;quirks |= XHCI_SPURIOUS_REBOOT;
<span class="p_add">+		xhci-&gt;quirks |= XHCI_SPURIOUS_WAKEUP;</span>
 	}
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL &amp;&amp;
 		(pdev-&gt;device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI ||
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index ad975a2975ca..41d7a05f8af4 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -2239,6 +2239,7 @@</span> <span class="p_context"> static int handle_tx_event(struct xhci_hcd *xhci,</span>
 	u32 trb_comp_code;
 	int ret = 0;
 	int td_num = 0;
<span class="p_add">+	bool handling_skipped_tds = false;</span>
 
 	slot_id = TRB_TO_SLOT_ID(le32_to_cpu(event-&gt;flags));
 	xdev = xhci-&gt;devs[slot_id];
<span class="p_chunk">@@ -2372,6 +2373,10 @@</span> <span class="p_context"> static int handle_tx_event(struct xhci_hcd *xhci,</span>
 		ep-&gt;skip = true;
 		xhci_dbg(xhci, &quot;Miss service interval error, set skip flag\n&quot;);
 		goto cleanup;
<span class="p_add">+	case COMP_PING_ERR:</span>
<span class="p_add">+		ep-&gt;skip = true;</span>
<span class="p_add">+		xhci_dbg(xhci, &quot;No Ping response error, Skip one Isoc TD\n&quot;);</span>
<span class="p_add">+		goto cleanup;</span>
 	default:
 		if (xhci_is_vendor_info_code(xhci, trb_comp_code)) {
 			status = 0;
<span class="p_chunk">@@ -2508,13 +2513,18 @@</span> <span class="p_context"> static int handle_tx_event(struct xhci_hcd *xhci,</span>
 						 ep, &amp;status);
 
 cleanup:
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+		handling_skipped_tds = ep-&gt;skip &amp;&amp;</span>
<span class="p_add">+			trb_comp_code != COMP_MISSED_INT &amp;&amp;</span>
<span class="p_add">+			trb_comp_code != COMP_PING_ERR;</span>
<span class="p_add">+</span>
 		/*
<span class="p_del">-		 * Do not update event ring dequeue pointer if ep-&gt;skip is set.</span>
<span class="p_del">-		 * Will roll back to continue process missed tds.</span>
<span class="p_add">+		 * Do not update event ring dequeue pointer if we&#39;re in a loop</span>
<span class="p_add">+		 * processing missed tds.</span>
 		 */
<span class="p_del">-		if (trb_comp_code == COMP_MISSED_INT || !ep-&gt;skip) {</span>
<span class="p_add">+		if (!handling_skipped_tds)</span>
 			inc_deq(xhci, xhci-&gt;event_ring);
<span class="p_del">-		}</span>
 
 		if (ret) {
 			urb = td-&gt;urb;
<span class="p_chunk">@@ -2549,7 +2559,7 @@</span> <span class="p_context"> cleanup:</span>
 	 * Process them as short transfer until reach the td pointed by
 	 * the event.
 	 */
<span class="p_del">-	} while (ep-&gt;skip &amp;&amp; trb_comp_code != COMP_MISSED_INT);</span>
<span class="p_add">+	} while (handling_skipped_tds);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c</span>
<span class="p_header">index ebcec8cda858..f49d262e926b 100644</span>
<span class="p_header">--- a/drivers/usb/serial/qcserial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/qcserial.c</span>
<span class="p_chunk">@@ -153,6 +153,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{DEVICE_SWI(0x1199, 0x9056)},	/* Sierra Wireless Modem */
 	{DEVICE_SWI(0x1199, 0x9060)},	/* Sierra Wireless Modem */
 	{DEVICE_SWI(0x1199, 0x9061)},	/* Sierra Wireless Modem */
<span class="p_add">+	{DEVICE_SWI(0x1199, 0x9070)},	/* Sierra Wireless MC74xx/EM74xx */</span>
<span class="p_add">+	{DEVICE_SWI(0x1199, 0x9071)},	/* Sierra Wireless MC74xx/EM74xx */</span>
 	{DEVICE_SWI(0x413c, 0x81a2)},	/* Dell Wireless 5806 Gobi(TM) 4G LTE Mobile Broadband Card */
 	{DEVICE_SWI(0x413c, 0x81a3)},	/* Dell Wireless 5570 HSPA+ (42Mbps) Mobile Broadband Card */
 	{DEVICE_SWI(0x413c, 0x81a4)},	/* Dell Wireless 5570e HSPA+ (42Mbps) Mobile Broadband Card */
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index af3dd3c55ef1..8b2c82ce36b3 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -4494,7 +4494,7 @@</span> <span class="p_context"> locked:</span>
 
 	if (bctl-&gt;flags &amp; ~(BTRFS_BALANCE_ARGS_MASK | BTRFS_BALANCE_TYPE_MASK)) {
 		ret = -EINVAL;
<span class="p_del">-		goto out_bargs;</span>
<span class="p_add">+		goto out_bctl;</span>
 	}
 
 do_balance:
<span class="p_chunk">@@ -4508,12 +4508,15 @@</span> <span class="p_context"> do_balance:</span>
 	need_unlock = false;
 
 	ret = btrfs_balance(bctl, bargs);
<span class="p_add">+	bctl = NULL;</span>
 
 	if (arg) {
 		if (copy_to_user(arg, bargs, sizeof(*bargs)))
 			ret = -EFAULT;
 	}
 
<span class="p_add">+out_bctl:</span>
<span class="p_add">+	kfree(bctl);</span>
 out_bargs:
 	kfree(bargs);
 out_unlock:
<span class="p_header">diff --git a/fs/overlayfs/copy_up.c b/fs/overlayfs/copy_up.c</span>
<span class="p_header">index 84d693d37428..871fcb67be97 100644</span>
<span class="p_header">--- a/fs/overlayfs/copy_up.c</span>
<span class="p_header">+++ b/fs/overlayfs/copy_up.c</span>
<span class="p_chunk">@@ -81,11 +81,11 @@</span> <span class="p_context"> static int ovl_copy_up_data(struct path *old, struct path *new, loff_t len)</span>
 	if (len == 0)
 		return 0;
 
<span class="p_del">-	old_file = ovl_path_open(old, O_RDONLY);</span>
<span class="p_add">+	old_file = ovl_path_open(old, O_LARGEFILE | O_RDONLY);</span>
 	if (IS_ERR(old_file))
 		return PTR_ERR(old_file);
 
<span class="p_del">-	new_file = ovl_path_open(new, O_WRONLY);</span>
<span class="p_add">+	new_file = ovl_path_open(new, O_LARGEFILE | O_WRONLY);</span>
 	if (IS_ERR(new_file)) {
 		error = PTR_ERR(new_file);
 		goto out_fput;
<span class="p_chunk">@@ -267,7 +267,7 @@</span> <span class="p_context"> out:</span>
 
 out_cleanup:
 	ovl_cleanup(wdir, newdentry);
<span class="p_del">-	goto out;</span>
<span class="p_add">+	goto out2;</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/overlayfs/super.c b/fs/overlayfs/super.c</span>
<span class="p_header">index 33f2d27a6792..d74af7f78fec 100644</span>
<span class="p_header">--- a/fs/overlayfs/super.c</span>
<span class="p_header">+++ b/fs/overlayfs/super.c</span>
<span class="p_chunk">@@ -474,6 +474,7 @@</span> <span class="p_context"> static void ovl_put_super(struct super_block *sb)</span>
 	mntput(ufs-&gt;upper_mnt);
 	for (i = 0; i &lt; ufs-&gt;numlower; i++)
 		mntput(ufs-&gt;lower_mnt[i]);
<span class="p_add">+	kfree(ufs-&gt;lower_mnt);</span>
 
 	kfree(ufs-&gt;config.lowerdir);
 	kfree(ufs-&gt;config.upperdir);
<span class="p_chunk">@@ -981,6 +982,7 @@</span> <span class="p_context"> static int ovl_fill_super(struct super_block *sb, void *data, int silent)</span>
 		oe-&gt;lowerstack[i].dentry = stack[i].dentry;
 		oe-&gt;lowerstack[i].mnt = ufs-&gt;lower_mnt[i];
 	}
<span class="p_add">+	kfree(stack);</span>
 
 	root_dentry-&gt;d_fsdata = oe;
 
<span class="p_header">diff --git a/include/sound/soc.h b/include/sound/soc.h</span>
<span class="p_header">index f6226914acfe..8d948aa9c5c9 100644</span>
<span class="p_header">--- a/include/sound/soc.h</span>
<span class="p_header">+++ b/include/sound/soc.h</span>
<span class="p_chunk">@@ -85,7 +85,7 @@</span> <span class="p_context"></span>
 	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \
 	SNDRV_CTL_ELEM_ACCESS_READWRITE, \
 	.tlv.p  = (tlv_array),\
<span class="p_del">-	.info = snd_soc_info_volsw, \</span>
<span class="p_add">+	.info = snd_soc_info_volsw_sx, \</span>
 	.get = snd_soc_get_volsw_sx,\
 	.put = snd_soc_put_volsw_sx, \
 	.private_value = (unsigned long)&amp;(struct soc_mixer_control) \
<span class="p_chunk">@@ -155,7 +155,7 @@</span> <span class="p_context"></span>
 	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \
 	SNDRV_CTL_ELEM_ACCESS_READWRITE, \
 	.tlv.p  = (tlv_array), \
<span class="p_del">-	.info = snd_soc_info_volsw, \</span>
<span class="p_add">+	.info = snd_soc_info_volsw_sx, \</span>
 	.get = snd_soc_get_volsw_sx, \
 	.put = snd_soc_put_volsw_sx, \
 	.private_value = (unsigned long)&amp;(struct soc_mixer_control) \
<span class="p_chunk">@@ -563,6 +563,8 @@</span> <span class="p_context"> int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,</span>
 	struct snd_ctl_elem_value *ucontrol);
 int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_info *uinfo);
<span class="p_add">+int snd_soc_info_volsw_sx(struct snd_kcontrol *kcontrol,</span>
<span class="p_add">+			  struct snd_ctl_elem_info *uinfo);</span>
 #define snd_soc_info_bool_ext		snd_ctl_boolean_mono_info
 int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol);
<span class="p_header">diff --git a/include/sound/wm8904.h b/include/sound/wm8904.h</span>
<span class="p_header">index 898be3a8db9a..6d8f8fba3341 100644</span>
<span class="p_header">--- a/include/sound/wm8904.h</span>
<span class="p_header">+++ b/include/sound/wm8904.h</span>
<span class="p_chunk">@@ -119,7 +119,7 @@</span> <span class="p_context"></span>
 #define WM8904_MIC_REGS  2
 #define WM8904_GPIO_REGS 4
 #define WM8904_DRC_REGS  4
<span class="p_del">-#define WM8904_EQ_REGS   25</span>
<span class="p_add">+#define WM8904_EQ_REGS   24</span>
 
 /**
  * DRC configurations are specified with a label and a set of register
<span class="p_header">diff --git a/kernel/module.c b/kernel/module.c</span>
<span class="p_header">index cfc9e843a924..3b9ff966edb9 100644</span>
<span class="p_header">--- a/kernel/module.c</span>
<span class="p_header">+++ b/kernel/module.c</span>
<span class="p_chunk">@@ -906,11 +906,15 @@</span> <span class="p_context"> void symbol_put_addr(void *addr)</span>
 	if (core_kernel_text(a))
 		return;
 
<span class="p_del">-	/* module_text_address is safe here: we&#39;re supposed to have reference</span>
<span class="p_del">-	 * to module from symbol_get, so it can&#39;t go away. */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Even though we hold a reference on the module; we still need to</span>
<span class="p_add">+	 * disable preemption in order to safely traverse the data structure.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	preempt_disable();</span>
 	modaddr = __module_text_address(a);
 	BUG_ON(!modaddr);
 	module_put(modaddr);
<span class="p_add">+	preempt_enable();</span>
 }
 EXPORT_SYMBOL_GPL(symbol_put_addr);
 
<span class="p_header">diff --git a/lib/fault-inject.c b/lib/fault-inject.c</span>
<span class="p_header">index f1cdeb024d17..6a823a53e357 100644</span>
<span class="p_header">--- a/lib/fault-inject.c</span>
<span class="p_header">+++ b/lib/fault-inject.c</span>
<span class="p_chunk">@@ -44,7 +44,7 @@</span> <span class="p_context"> static void fail_dump(struct fault_attr *attr)</span>
 		printk(KERN_NOTICE &quot;FAULT_INJECTION: forcing a failure.\n&quot;
 		       &quot;name %pd, interval %lu, probability %lu, &quot;
 		       &quot;space %d, times %d\n&quot;, attr-&gt;dname,
<span class="p_del">-		       attr-&gt;probability, attr-&gt;interval,</span>
<span class="p_add">+		       attr-&gt;interval, attr-&gt;probability,</span>
 		       atomic_read(&amp;attr-&gt;space),
 		       atomic_read(&amp;attr-&gt;times));
 		if (attr-&gt;verbose &gt; 1)
<span class="p_header">diff --git a/mm/filemap.c b/mm/filemap.c</span>
<span class="p_header">index 6bf5e42d560a..1ffef05f1c1f 100644</span>
<span class="p_header">--- a/mm/filemap.c</span>
<span class="p_header">+++ b/mm/filemap.c</span>
<span class="p_chunk">@@ -2461,6 +2461,11 @@</span> <span class="p_context"> again:</span>
 			break;
 		}
 
<span class="p_add">+		if (fatal_signal_pending(current)) {</span>
<span class="p_add">+			status = -EINTR;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		status = a_ops-&gt;write_begin(file, mapping, pos, bytes, flags,
 						&amp;page, &amp;fsdata);
 		if (unlikely(status &lt; 0))
<span class="p_chunk">@@ -2498,10 +2503,6 @@</span> <span class="p_context"> again:</span>
 		written += copied;
 
 		balance_dirty_pages_ratelimited(mapping);
<span class="p_del">-		if (fatal_signal_pending(current)) {</span>
<span class="p_del">-			status = -EINTR;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
 	} while (iov_iter_count(i));
 
 	return written ? written : status;
<span class="p_header">diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="p_header">index 078832cf3636..8e792ec5e84c 100644</span>
<span class="p_header">--- a/mm/huge_memory.c</span>
<span class="p_header">+++ b/mm/huge_memory.c</span>
<span class="p_chunk">@@ -2137,7 +2137,8 @@</span> <span class="p_context"> static int __collapse_huge_page_isolate(struct vm_area_struct *vma,</span>
 	for (_pte = pte; _pte &lt; pte+HPAGE_PMD_NR;
 	     _pte++, address += PAGE_SIZE) {
 		pte_t pteval = *_pte;
<span class="p_del">-		if (pte_none(pteval) || is_zero_pfn(pte_pfn(pteval))) {</span>
<span class="p_add">+		if (pte_none(pteval) || (pte_present(pteval) &amp;&amp;</span>
<span class="p_add">+			is_zero_pfn(pte_pfn(pteval)))) {</span>
 			if (++none_or_zero &lt;= khugepaged_max_ptes_none)
 				continue;
 			else
<span class="p_header">diff --git a/sound/pci/hda/hda_codec.c b/sound/pci/hda/hda_codec.c</span>
<span class="p_header">index 36e8f1236637..57197bef5f5b 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_codec.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_codec.c</span>
<span class="p_chunk">@@ -3833,10 +3833,8 @@</span> <span class="p_context"> int snd_hda_codec_build_pcms(struct hda_codec *codec)</span>
 		return -EINVAL;
 
 	err = snd_hda_codec_parse_pcms(codec);
<span class="p_del">-	if (err &lt; 0) {</span>
<span class="p_del">-		snd_hda_codec_reset(codec);</span>
<span class="p_add">+	if (err &lt; 0)</span>
 		return err;
<span class="p_del">-	}</span>
 
 	/* attach a new PCM streams */
 	list_for_each_entry(cpcm, &amp;codec-&gt;pcm_list_head, list) {
<span class="p_header">diff --git a/sound/pci/hda/patch_conexant.c b/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">index 06cc9d57ba3d..488f4c7be33e 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_conexant.c</span>
<span class="p_chunk">@@ -819,6 +819,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk cxt5066_fixups[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x21da, &quot;Lenovo X220&quot;, CXT_PINCFG_LENOVO_TP410),
 	SND_PCI_QUIRK(0x17aa, 0x21db, &quot;Lenovo X220-tablet&quot;, CXT_PINCFG_LENOVO_TP410),
 	SND_PCI_QUIRK(0x17aa, 0x38af, &quot;Lenovo IdeaPad Z560&quot;, CXT_FIXUP_MUTE_LED_EAPD),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x390b, &quot;Lenovo G50-80&quot;, CXT_FIXUP_STEREO_DMIC),</span>
 	SND_PCI_QUIRK(0x17aa, 0x3975, &quot;Lenovo U300s&quot;, CXT_FIXUP_STEREO_DMIC),
 	SND_PCI_QUIRK(0x17aa, 0x3977, &quot;Lenovo IdeaPad U310&quot;, CXT_FIXUP_STEREO_DMIC),
 	SND_PCI_QUIRK(0x17aa, 0x397b, &quot;Lenovo S205&quot;, CXT_FIXUP_STEREO_DMIC),
<span class="p_header">diff --git a/sound/soc/soc-ops.c b/sound/soc/soc-ops.c</span>
<span class="p_header">index 100d92b5b77e..05977ae1ff2a 100644</span>
<span class="p_header">--- a/sound/soc/soc-ops.c</span>
<span class="p_header">+++ b/sound/soc/soc-ops.c</span>
<span class="p_chunk">@@ -207,6 +207,34 @@</span> <span class="p_context"> int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,</span>
 EXPORT_SYMBOL_GPL(snd_soc_info_volsw);
 
 /**
<span class="p_add">+ * snd_soc_info_volsw_sx - Mixer info callback for SX TLV controls</span>
<span class="p_add">+ * @kcontrol: mixer control</span>
<span class="p_add">+ * @uinfo: control element information</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Callback to provide information about a single mixer control, or a double</span>
<span class="p_add">+ * mixer control that spans 2 registers of the SX TLV type. SX TLV controls</span>
<span class="p_add">+ * have a range that represents both positive and negative values either side</span>
<span class="p_add">+ * of zero but without a sign bit.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns 0 for success.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int snd_soc_info_volsw_sx(struct snd_kcontrol *kcontrol,</span>
<span class="p_add">+			  struct snd_ctl_elem_info *uinfo)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct soc_mixer_control *mc =</span>
<span class="p_add">+		(struct soc_mixer_control *)kcontrol-&gt;private_value;</span>
<span class="p_add">+</span>
<span class="p_add">+	snd_soc_info_volsw(kcontrol, uinfo);</span>
<span class="p_add">+	/* Max represents the number of levels in an SX control not the</span>
<span class="p_add">+	 * maximum value, so add the minimum value back on</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	uinfo-&gt;value.integer.max += mc-&gt;min;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(snd_soc_info_volsw_sx);</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * snd_soc_get_volsw - single mixer get callback
  * @kcontrol: mixer control
  * @ucontrol: control element information

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



