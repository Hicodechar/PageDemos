
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.8.15 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.8.15</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 15, 2016, 5:33 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20161215173326.GB26737@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9476639/mbox/"
   >mbox</a>
|
   <a href="/patch/9476639/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9476639/">/patch/9476639/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	86448607EE for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 15 Dec 2016 17:34:22 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 76B0A284AE
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 15 Dec 2016 17:34:22 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 6B2D5287C4; Thu, 15 Dec 2016 17:34:22 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 8C68B287C4
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 15 Dec 2016 17:34:20 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1757330AbcLORdv (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 15 Dec 2016 12:33:51 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:41220 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1757252AbcLORdS (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 15 Dec 2016 12:33:18 -0500
Received: from localhost (unknown [104.132.0.97])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 0DE33BEB;
	Thu, 15 Dec 2016 17:33:16 +0000 (UTC)
Date: Thu, 15 Dec 2016 09:33:26 -0800
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.8.15
Message-ID: &lt;20161215173326.GB26737@kroah.com&gt;
References: &lt;20161215173321.GA26737@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20161215173321.GA26737@kroah.com&gt;
User-Agent: Mutt/1.7.2 (2016-11-26)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Dec. 15, 2016, 5:33 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 6a7492473a0d..c7f0e798ca34 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 8
<span class="p_del">-SUBLEVEL = 14</span>
<span class="p_add">+SUBLEVEL = 15</span>
 EXTRAVERSION =
 NAME = Psychotic Stoned Sheep
 
<span class="p_header">diff --git a/arch/arm/boot/dts/imx7s.dtsi b/arch/arm/boot/dts/imx7s.dtsi</span>
<span class="p_header">index 1e90bdbe3a6e..fb307de5422c 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx7s.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx7s.dtsi</span>
<span class="p_chunk">@@ -640,9 +640,8 @@</span> <span class="p_context"></span>
 				reg = &lt;0x30730000 0x10000&gt;;
 				interrupts = &lt;GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH&gt;;
 				clocks = &lt;&amp;clks IMX7D_LCDIF_PIXEL_ROOT_CLK&gt;,
<span class="p_del">-					&lt;&amp;clks IMX7D_CLK_DUMMY&gt;,</span>
<span class="p_del">-					&lt;&amp;clks IMX7D_CLK_DUMMY&gt;;</span>
<span class="p_del">-				clock-names = &quot;pix&quot;, &quot;axi&quot;, &quot;disp_axi&quot;;</span>
<span class="p_add">+					&lt;&amp;clks IMX7D_LCDIF_PIXEL_ROOT_CLK&gt;;</span>
<span class="p_add">+				clock-names = &quot;pix&quot;, &quot;axi&quot;;</span>
 				status = &quot;disabled&quot;;
 			};
 		};
<span class="p_header">diff --git a/arch/arm/boot/dts/orion5x-linkstation-lsgl.dts b/arch/arm/boot/dts/orion5x-linkstation-lsgl.dts</span>
<span class="p_header">index 1cf644bfd7ea..51dc734cd5b9 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/orion5x-linkstation-lsgl.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/orion5x-linkstation-lsgl.dts</span>
<span class="p_chunk">@@ -82,6 +82,10 @@</span> <span class="p_context"></span>
 	gpios = &lt;&amp;gpio0 9 GPIO_ACTIVE_HIGH&gt;;
 };
 
<span class="p_add">+&amp;sata {</span>
<span class="p_add">+	nr-ports = &lt;2&gt;;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 &amp;ehci1 {
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/m68k/include/asm/delay.h b/arch/m68k/include/asm/delay.h</span>
<span class="p_header">index d28fa8fe26fe..c598d847d56b 100644</span>
<span class="p_header">--- a/arch/m68k/include/asm/delay.h</span>
<span class="p_header">+++ b/arch/m68k/include/asm/delay.h</span>
<span class="p_chunk">@@ -114,6 +114,6 @@</span> <span class="p_context"> static inline void __udelay(unsigned long usecs)</span>
  */
 #define	HZSCALE		(268435456 / (1000000 / HZ))
 
<span class="p_del">-#define ndelay(n) __delay(DIV_ROUND_UP((n) * ((((HZSCALE) &gt;&gt; 11) * (loops_per_jiffy &gt;&gt; 11)) &gt;&gt; 6), 1000));</span>
<span class="p_add">+#define ndelay(n) __delay(DIV_ROUND_UP((n) * ((((HZSCALE) &gt;&gt; 11) * (loops_per_jiffy &gt;&gt; 11)) &gt;&gt; 6), 1000))</span>
 
 #endif /* defined(_M68K_DELAY_H) */
<span class="p_header">diff --git a/arch/parisc/include/asm/pgtable.h b/arch/parisc/include/asm/pgtable.h</span>
<span class="p_header">index c2c43f714684..3a4ed9f91d57 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -65,9 +65,9 @@</span> <span class="p_context"> static inline void purge_tlb_entries(struct mm_struct *mm, unsigned long addr)</span>
 		unsigned long flags;				\
 		spin_lock_irqsave(&amp;pa_tlb_lock, flags);		\
 		old_pte = *ptep;				\
<span class="p_del">-		set_pte(ptep, pteval);				\</span>
 		if (pte_inserted(old_pte))			\
 			purge_tlb_entries(mm, addr);		\
<span class="p_add">+		set_pte(ptep, pteval);				\</span>
 		spin_unlock_irqrestore(&amp;pa_tlb_lock, flags);	\
 	} while (0)
 
<span class="p_chunk">@@ -478,8 +478,8 @@</span> <span class="p_context"> static inline int ptep_test_and_clear_young(struct vm_area_struct *vma, unsigned</span>
 		spin_unlock_irqrestore(&amp;pa_tlb_lock, flags);
 		return 0;
 	}
<span class="p_del">-	set_pte(ptep, pte_mkold(pte));</span>
 	purge_tlb_entries(vma-&gt;vm_mm, addr);
<span class="p_add">+	set_pte(ptep, pte_mkold(pte));</span>
 	spin_unlock_irqrestore(&amp;pa_tlb_lock, flags);
 	return 1;
 }
<span class="p_chunk">@@ -492,9 +492,9 @@</span> <span class="p_context"> static inline pte_t ptep_get_and_clear(struct mm_struct *mm, unsigned long addr,</span>
 
 	spin_lock_irqsave(&amp;pa_tlb_lock, flags);
 	old_pte = *ptep;
<span class="p_del">-	set_pte(ptep, __pte(0));</span>
 	if (pte_inserted(old_pte))
 		purge_tlb_entries(mm, addr);
<span class="p_add">+	set_pte(ptep, __pte(0));</span>
 	spin_unlock_irqrestore(&amp;pa_tlb_lock, flags);
 
 	return old_pte;
<span class="p_chunk">@@ -504,8 +504,8 @@</span> <span class="p_context"> static inline void ptep_set_wrprotect(struct mm_struct *mm, unsigned long addr,</span>
 {
 	unsigned long flags;
 	spin_lock_irqsave(&amp;pa_tlb_lock, flags);
<span class="p_del">-	set_pte(ptep, pte_wrprotect(*ptep));</span>
 	purge_tlb_entries(mm, addr);
<span class="p_add">+	set_pte(ptep, pte_wrprotect(*ptep));</span>
 	spin_unlock_irqrestore(&amp;pa_tlb_lock, flags);
 }
 
<span class="p_header">diff --git a/arch/parisc/kernel/cache.c b/arch/parisc/kernel/cache.c</span>
<span class="p_header">index c2259d4a3c33..bbb314eb7027 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/cache.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/cache.c</span>
<span class="p_chunk">@@ -393,6 +393,15 @@</span> <span class="p_context"> void __init parisc_setup_cache_timing(void)</span>
 
 	/* calculate TLB flush threshold */
 
<span class="p_add">+	/* On SMP machines, skip the TLB measure of kernel text which</span>
<span class="p_add">+	 * has been mapped as huge pages. */</span>
<span class="p_add">+	if (num_online_cpus() &gt; 1 &amp;&amp; !parisc_requires_coherency()) {</span>
<span class="p_add">+		threshold = max(cache_info.it_size, cache_info.dt_size);</span>
<span class="p_add">+		threshold *= PAGE_SIZE;</span>
<span class="p_add">+		threshold /= num_online_cpus();</span>
<span class="p_add">+		goto set_tlb_threshold;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	alltime = mfctl(16);
 	flush_tlb_all();
 	alltime = mfctl(16) - alltime;
<span class="p_chunk">@@ -411,6 +420,8 @@</span> <span class="p_context"> void __init parisc_setup_cache_timing(void)</span>
 		alltime, size, rangetime);
 
 	threshold = PAGE_ALIGN(num_online_cpus() * size * alltime / rangetime);
<span class="p_add">+</span>
<span class="p_add">+set_tlb_threshold:</span>
 	if (threshold)
 		parisc_tlb_flush_threshold = threshold;
 	printk(KERN_INFO &quot;TLB flush threshold set to %lu KiB\n&quot;,
<span class="p_header">diff --git a/arch/parisc/kernel/pacache.S b/arch/parisc/kernel/pacache.S</span>
<span class="p_header">index 675521919229..a4761b772406 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/pacache.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/pacache.S</span>
<span class="p_chunk">@@ -886,19 +886,10 @@</span> <span class="p_context"> ENTRY(flush_dcache_page_asm)</span>
 	fdc,m		r31(%r28)
 	fdc,m		r31(%r28)
 	fdc,m		r31(%r28)
<span class="p_del">-	cmpb,COND(&lt;&lt;)		%r28, %r25,1b</span>
<span class="p_add">+	cmpb,COND(&lt;&lt;)	%r28, %r25,1b</span>
 	fdc,m		r31(%r28)
 
 	sync
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_PA20</span>
<span class="p_del">-	pdtlb,l		%r0(%r25)</span>
<span class="p_del">-#else</span>
<span class="p_del">-	tlb_lock	%r20,%r21,%r22</span>
<span class="p_del">-	pdtlb		%r0(%r25)</span>
<span class="p_del">-	tlb_unlock	%r20,%r21,%r22</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 	bv		%r0(%r2)
 	nop
 	.exit
<span class="p_chunk">@@ -973,17 +964,6 @@</span> <span class="p_context"> ENTRY(flush_icache_page_asm)</span>
 	fic,m		%r31(%sr4,%r28)
 
 	sync
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_PA20</span>
<span class="p_del">-	pdtlb,l		%r0(%r28)</span>
<span class="p_del">-	pitlb,l         %r0(%sr4,%r25)</span>
<span class="p_del">-#else</span>
<span class="p_del">-	tlb_lock        %r20,%r21,%r22</span>
<span class="p_del">-	pdtlb		%r0(%r28)</span>
<span class="p_del">-	pitlb           %r0(%sr4,%r25)</span>
<span class="p_del">-	tlb_unlock      %r20,%r21,%r22</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 	bv		%r0(%r2)
 	nop
 	.exit
<span class="p_header">diff --git a/arch/powerpc/boot/Makefile b/arch/powerpc/boot/Makefile</span>
<span class="p_header">index 1a2a6e8dc40d..1894beb2c208 100644</span>
<span class="p_header">--- a/arch/powerpc/boot/Makefile</span>
<span class="p_header">+++ b/arch/powerpc/boot/Makefile</span>
<span class="p_chunk">@@ -78,7 +78,8 @@</span> <span class="p_context"> src-wlib-y := string.S crt0.S crtsavres.S stdio.c main.c \</span>
 		ns16550.c serial.c simple_alloc.c div64.S util.S \
 		gunzip_util.c elf_util.c $(zlib) devtree.c stdlib.c \
 		oflib.c ofconsole.c cuboot.c mpsc.c cpm-serial.c \
<span class="p_del">-		uartlite.c mpc52xx-psc.c opal.c opal-calls.S</span>
<span class="p_add">+		uartlite.c mpc52xx-psc.c opal.c</span>
<span class="p_add">+src-wlib-$(CONFIG_PPC64_BOOT_WRAPPER) +=  opal-calls.S</span>
 src-wlib-$(CONFIG_40x) += 4xx.c planetcore.c
 src-wlib-$(CONFIG_44x) += 4xx.c ebony.c bamboo.c
 src-wlib-$(CONFIG_8xx) += mpc8xx.c planetcore.c fsl-soc.c
<span class="p_header">diff --git a/arch/powerpc/boot/opal.c b/arch/powerpc/boot/opal.c</span>
<span class="p_header">index d7b4fd47eb44..0272570d02de 100644</span>
<span class="p_header">--- a/arch/powerpc/boot/opal.c</span>
<span class="p_header">+++ b/arch/powerpc/boot/opal.c</span>
<span class="p_chunk">@@ -13,7 +13,7 @@</span> <span class="p_context"></span>
 #include &lt;libfdt.h&gt;
 #include &quot;../include/asm/opal-api.h&quot;
 
<span class="p_del">-#ifdef __powerpc64__</span>
<span class="p_add">+#ifdef CONFIG_PPC64_BOOT_WRAPPER</span>
 
 /* Global OPAL struct used by opal-call.S */
 struct opal {
<span class="p_header">diff --git a/arch/powerpc/kernel/eeh_driver.c b/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_header">index 29aa8d1ce273..248f28bc4641 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_chunk">@@ -671,8 +671,10 @@</span> <span class="p_context"> static int eeh_reset_device(struct eeh_pe *pe, struct pci_bus *bus,</span>
 
 	/* Clear frozen state */
 	rc = eeh_clear_pe_frozen_state(pe, false);
<span class="p_del">-	if (rc)</span>
<span class="p_add">+	if (rc) {</span>
<span class="p_add">+		pci_unlock_rescan_remove();</span>
 		return rc;
<span class="p_add">+	}</span>
 
 	/* Give the system 5 seconds to finish running the user-space
 	 * hotplug shutdown scripts, e.g. ifdown for ethernet.  Yes,
<span class="p_header">diff --git a/arch/powerpc/mm/hash64_4k.c b/arch/powerpc/mm/hash64_4k.c</span>
<span class="p_header">index 42c702b3be1f..6fa450c12d6d 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/hash64_4k.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/hash64_4k.c</span>
<span class="p_chunk">@@ -55,7 +55,7 @@</span> <span class="p_context"> int __hash_page_4K(unsigned long ea, unsigned long access, unsigned long vsid,</span>
 	 */
 	rflags = htab_convert_pte_flags(new_pte);
 
<span class="p_del">-	if (!cpu_has_feature(CPU_FTR_NOEXECUTE) &amp;&amp;</span>
<span class="p_add">+	if (cpu_has_feature(CPU_FTR_NOEXECUTE) &amp;&amp;</span>
 	    !cpu_has_feature(CPU_FTR_COHERENT_ICACHE))
 		rflags = hash_page_do_lazy_icache(rflags, __pte(old_pte), trap);
 
<span class="p_header">diff --git a/arch/powerpc/mm/hash64_64k.c b/arch/powerpc/mm/hash64_64k.c</span>
<span class="p_header">index 3bbbea07378c..1a68cb19b0e3 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/hash64_64k.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/hash64_64k.c</span>
<span class="p_chunk">@@ -87,7 +87,7 @@</span> <span class="p_context"> int __hash_page_4K(unsigned long ea, unsigned long access, unsigned long vsid,</span>
 	subpg_pte = new_pte &amp; ~subpg_prot;
 	rflags = htab_convert_pte_flags(subpg_pte);
 
<span class="p_del">-	if (!cpu_has_feature(CPU_FTR_NOEXECUTE) &amp;&amp;</span>
<span class="p_add">+	if (cpu_has_feature(CPU_FTR_NOEXECUTE) &amp;&amp;</span>
 	    !cpu_has_feature(CPU_FTR_COHERENT_ICACHE)) {
 
 		/*
<span class="p_chunk">@@ -258,7 +258,7 @@</span> <span class="p_context"> int __hash_page_64K(unsigned long ea, unsigned long access,</span>
 
 	rflags = htab_convert_pte_flags(new_pte);
 
<span class="p_del">-	if (!cpu_has_feature(CPU_FTR_NOEXECUTE) &amp;&amp;</span>
<span class="p_add">+	if (cpu_has_feature(CPU_FTR_NOEXECUTE) &amp;&amp;</span>
 	    !cpu_has_feature(CPU_FTR_COHERENT_ICACHE))
 		rflags = hash_page_do_lazy_icache(rflags, __pte(old_pte), trap);
 
<span class="p_header">diff --git a/arch/x86/events/core.c b/arch/x86/events/core.c</span>
<span class="p_header">index a4e070a51584..8c925ecaf534 100644</span>
<span class="p_header">--- a/arch/x86/events/core.c</span>
<span class="p_header">+++ b/arch/x86/events/core.c</span>
<span class="p_chunk">@@ -68,7 +68,7 @@</span> <span class="p_context"> u64 x86_perf_event_update(struct perf_event *event)</span>
 	int shift = 64 - x86_pmu.cntval_bits;
 	u64 prev_raw_count, new_raw_count;
 	int idx = hwc-&gt;idx;
<span class="p_del">-	s64 delta;</span>
<span class="p_add">+	u64 delta;</span>
 
 	if (idx == INTEL_PMC_IDX_FIXED_BTS)
 		return 0;
<span class="p_header">diff --git a/arch/x86/events/intel/core.c b/arch/x86/events/intel/core.c</span>
<span class="p_header">index 4c9a79b9cd69..3ef34c6e63ca 100644</span>
<span class="p_header">--- a/arch/x86/events/intel/core.c</span>
<span class="p_header">+++ b/arch/x86/events/intel/core.c</span>
<span class="p_chunk">@@ -4024,7 +4024,7 @@</span> <span class="p_context"> __init int intel_pmu_init(void)</span>
 
 	/* Support full width counters using alternative MSR range */
 	if (x86_pmu.intel_cap.full_width_write) {
<span class="p_del">-		x86_pmu.max_period = x86_pmu.cntval_mask;</span>
<span class="p_add">+		x86_pmu.max_period = x86_pmu.cntval_mask &gt;&gt; 1;</span>
 		x86_pmu.perfctr = MSR_IA32_PMC0;
 		pr_cont(&quot;full-width counters, &quot;);
 	}
<span class="p_header">diff --git a/crypto/Makefile b/crypto/Makefile</span>
<span class="p_header">index 99cc64ac70ef..bd6a029094e6 100644</span>
<span class="p_header">--- a/crypto/Makefile</span>
<span class="p_header">+++ b/crypto/Makefile</span>
<span class="p_chunk">@@ -40,6 +40,7 @@</span> <span class="p_context"> obj-$(CONFIG_CRYPTO_ECDH) += ecdh_generic.o</span>
 
 $(obj)/rsapubkey-asn1.o: $(obj)/rsapubkey-asn1.c $(obj)/rsapubkey-asn1.h
 $(obj)/rsaprivkey-asn1.o: $(obj)/rsaprivkey-asn1.c $(obj)/rsaprivkey-asn1.h
<span class="p_add">+$(obj)/rsa_helper.o: $(obj)/rsapubkey-asn1.h $(obj)/rsaprivkey-asn1.h</span>
 clean-files += rsapubkey-asn1.c rsapubkey-asn1.h
 clean-files += rsaprivkey-asn1.c rsaprivkey-asn1.h
 
<span class="p_header">diff --git a/crypto/mcryptd.c b/crypto/mcryptd.c</span>
<span class="p_header">index 86fb59b109a9..c6e992082259 100644</span>
<span class="p_header">--- a/crypto/mcryptd.c</span>
<span class="p_header">+++ b/crypto/mcryptd.c</span>
<span class="p_chunk">@@ -254,18 +254,22 @@</span> <span class="p_context"> out_free_inst:</span>
 	goto out;
 }
 
<span class="p_del">-static inline void mcryptd_check_internal(struct rtattr **tb, u32 *type,</span>
<span class="p_add">+static inline bool mcryptd_check_internal(struct rtattr **tb, u32 *type,</span>
 					  u32 *mask)
 {
 	struct crypto_attr_type *algt;
 
 	algt = crypto_get_attr_type(tb);
 	if (IS_ERR(algt))
<span class="p_del">-		return;</span>
<span class="p_del">-	if ((algt-&gt;type &amp; CRYPTO_ALG_INTERNAL))</span>
<span class="p_del">-		*type |= CRYPTO_ALG_INTERNAL;</span>
<span class="p_del">-	if ((algt-&gt;mask &amp; CRYPTO_ALG_INTERNAL))</span>
<span class="p_del">-		*mask |= CRYPTO_ALG_INTERNAL;</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	*type |= algt-&gt;type &amp; CRYPTO_ALG_INTERNAL;</span>
<span class="p_add">+	*mask |= algt-&gt;mask &amp; CRYPTO_ALG_INTERNAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (*type &amp; *mask &amp; CRYPTO_ALG_INTERNAL)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return false;</span>
 }
 
 static int mcryptd_hash_init_tfm(struct crypto_tfm *tfm)
<span class="p_chunk">@@ -492,7 +496,8 @@</span> <span class="p_context"> static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,</span>
 	u32 mask = 0;
 	int err;
 
<span class="p_del">-	mcryptd_check_internal(tb, &amp;type, &amp;mask);</span>
<span class="p_add">+	if (!mcryptd_check_internal(tb, &amp;type, &amp;mask))</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	halg = ahash_attr_alg(tb[1], type, mask);
 	if (IS_ERR(halg))
<span class="p_header">diff --git a/drivers/acpi/nfit/core.c b/drivers/acpi/nfit/core.c</span>
<span class="p_header">index 2accf784534e..93e0d8333a20 100644</span>
<span class="p_header">--- a/drivers/acpi/nfit/core.c</span>
<span class="p_header">+++ b/drivers/acpi/nfit/core.c</span>
<span class="p_chunk">@@ -94,7 +94,7 @@</span> <span class="p_context"> static struct acpi_device *to_acpi_dev(struct acpi_nfit_desc *acpi_desc)</span>
 	return to_acpi_device(acpi_desc-&gt;dev);
 }
 
<span class="p_del">-static int xlat_status(void *buf, unsigned int cmd, u32 status)</span>
<span class="p_add">+static int xlat_bus_status(void *buf, unsigned int cmd, u32 status)</span>
 {
 	struct nd_cmd_clear_error *clear_err;
 	struct nd_cmd_ars_status *ars_status;
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> static int xlat_status(void *buf, unsigned int cmd, u32 status)</span>
 		flags = ND_ARS_PERSISTENT | ND_ARS_VOLATILE;
 		if ((status &gt;&gt; 16 &amp; flags) == 0)
 			return -ENOTTY;
<span class="p_del">-		break;</span>
<span class="p_add">+		return 0;</span>
 	case ND_CMD_ARS_START:
 		/* ARS is in progress */
 		if ((status &amp; 0xffff) == NFIT_ARS_START_BUSY)
<span class="p_chunk">@@ -122,7 +122,7 @@</span> <span class="p_context"> static int xlat_status(void *buf, unsigned int cmd, u32 status)</span>
 		/* Command failed */
 		if (status &amp; 0xffff)
 			return -EIO;
<span class="p_del">-		break;</span>
<span class="p_add">+		return 0;</span>
 	case ND_CMD_ARS_STATUS:
 		ars_status = buf;
 		/* Command failed */
<span class="p_chunk">@@ -146,7 +146,8 @@</span> <span class="p_context"> static int xlat_status(void *buf, unsigned int cmd, u32 status)</span>
 		 * then just continue with the returned results.
 		 */
 		if (status == NFIT_ARS_STATUS_INTR) {
<span class="p_del">-			if (ars_status-&gt;flags &amp; NFIT_ARS_F_OVERFLOW)</span>
<span class="p_add">+			if (ars_status-&gt;out_length &gt;= 40 &amp;&amp; (ars_status-&gt;flags</span>
<span class="p_add">+						&amp; NFIT_ARS_F_OVERFLOW))</span>
 				return -ENOSPC;
 			return 0;
 		}
<span class="p_chunk">@@ -154,7 +155,7 @@</span> <span class="p_context"> static int xlat_status(void *buf, unsigned int cmd, u32 status)</span>
 		/* Unknown status */
 		if (status &gt;&gt; 16)
 			return -EIO;
<span class="p_del">-		break;</span>
<span class="p_add">+		return 0;</span>
 	case ND_CMD_CLEAR_ERROR:
 		clear_err = buf;
 		if (status &amp; 0xffff)
<span class="p_chunk">@@ -163,7 +164,7 @@</span> <span class="p_context"> static int xlat_status(void *buf, unsigned int cmd, u32 status)</span>
 			return -EIO;
 		if (clear_err-&gt;length &gt; clear_err-&gt;cleared)
 			return clear_err-&gt;cleared;
<span class="p_del">-		break;</span>
<span class="p_add">+		return 0;</span>
 	default:
 		break;
 	}
<span class="p_chunk">@@ -174,6 +175,16 @@</span> <span class="p_context"> static int xlat_status(void *buf, unsigned int cmd, u32 status)</span>
 	return 0;
 }
 
<span class="p_add">+static int xlat_status(struct nvdimm *nvdimm, void *buf, unsigned int cmd,</span>
<span class="p_add">+		u32 status)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!nvdimm)</span>
<span class="p_add">+		return xlat_bus_status(buf, cmd, status);</span>
<span class="p_add">+	if (status)</span>
<span class="p_add">+		return -EIO;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int acpi_nfit_ctl(struct nvdimm_bus_descriptor *nd_desc,
 		struct nvdimm *nvdimm, unsigned int cmd, void *buf,
 		unsigned int buf_len, int *cmd_rc)
<span class="p_chunk">@@ -298,7 +309,8 @@</span> <span class="p_context"> static int acpi_nfit_ctl(struct nvdimm_bus_descriptor *nd_desc,</span>
 
 	for (i = 0, offset = 0; i &lt; desc-&gt;out_num; i++) {
 		u32 out_size = nd_cmd_out_size(nvdimm, cmd, desc, i, buf,
<span class="p_del">-				(u32 *) out_obj-&gt;buffer.pointer);</span>
<span class="p_add">+				(u32 *) out_obj-&gt;buffer.pointer,</span>
<span class="p_add">+				out_obj-&gt;buffer.length - offset);</span>
 
 		if (offset + out_size &gt; out_obj-&gt;buffer.length) {
 			dev_dbg(dev, &quot;%s:%s output object underflow cmd: %s field: %d\n&quot;,
<span class="p_chunk">@@ -333,7 +345,8 @@</span> <span class="p_context"> static int acpi_nfit_ctl(struct nvdimm_bus_descriptor *nd_desc,</span>
 			 */
 			rc = buf_len - offset - in_buf.buffer.length;
 			if (cmd_rc)
<span class="p_del">-				*cmd_rc = xlat_status(buf, cmd, fw_status);</span>
<span class="p_add">+				*cmd_rc = xlat_status(nvdimm, buf, cmd,</span>
<span class="p_add">+						fw_status);</span>
 		} else {
 			dev_err(dev, &quot;%s:%s underrun cmd: %s buf_len: %d out_len: %d\n&quot;,
 					__func__, dimm_name, cmd_name, buf_len,
<span class="p_chunk">@@ -343,7 +356,7 @@</span> <span class="p_context"> static int acpi_nfit_ctl(struct nvdimm_bus_descriptor *nd_desc,</span>
 	} else {
 		rc = 0;
 		if (cmd_rc)
<span class="p_del">-			*cmd_rc = xlat_status(buf, cmd, fw_status);</span>
<span class="p_add">+			*cmd_rc = xlat_status(nvdimm, buf, cmd, fw_status);</span>
 	}
 
  out:
<span class="p_chunk">@@ -1857,19 +1870,32 @@</span> <span class="p_context"> static int ars_get_status(struct acpi_nfit_desc *acpi_desc)</span>
 	return cmd_rc;
 }
 
<span class="p_del">-static int ars_status_process_records(struct nvdimm_bus *nvdimm_bus,</span>
<span class="p_add">+static int ars_status_process_records(struct acpi_nfit_desc *acpi_desc,</span>
 		struct nd_cmd_ars_status *ars_status)
 {
<span class="p_add">+	struct nvdimm_bus *nvdimm_bus = acpi_desc-&gt;nvdimm_bus;</span>
 	int rc;
 	u32 i;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * First record starts at 44 byte offset from the start of the</span>
<span class="p_add">+	 * payload.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ars_status-&gt;out_length &lt; 44)</span>
<span class="p_add">+		return 0;</span>
 	for (i = 0; i &lt; ars_status-&gt;num_records; i++) {
<span class="p_add">+		/* only process full records */</span>
<span class="p_add">+		if (ars_status-&gt;out_length</span>
<span class="p_add">+				&lt; 44 + sizeof(struct nd_ars_record) * (i + 1))</span>
<span class="p_add">+			break;</span>
 		rc = nvdimm_bus_add_poison(nvdimm_bus,
 				ars_status-&gt;records[i].err_address,
 				ars_status-&gt;records[i].length);
 		if (rc)
 			return rc;
 	}
<span class="p_add">+	if (i &lt; ars_status-&gt;num_records)</span>
<span class="p_add">+		dev_warn(acpi_desc-&gt;dev, &quot;detected truncated ars results\n&quot;);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -2122,8 +2148,7 @@</span> <span class="p_context"> static int acpi_nfit_query_poison(struct acpi_nfit_desc *acpi_desc,</span>
 	if (rc &lt; 0 &amp;&amp; rc != -ENOSPC)
 		return rc;
 
<span class="p_del">-	if (ars_status_process_records(acpi_desc-&gt;nvdimm_bus,</span>
<span class="p_del">-				acpi_desc-&gt;ars_status))</span>
<span class="p_add">+	if (ars_status_process_records(acpi_desc, acpi_desc-&gt;ars_status))</span>
 		return -ENOMEM;
 
 	return 0;
<span class="p_header">diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c</span>
<span class="p_header">index 2b38c1bb0446..7a2e4d45b266 100644</span>
<span class="p_header">--- a/drivers/acpi/sleep.c</span>
<span class="p_header">+++ b/drivers/acpi/sleep.c</span>
<span class="p_chunk">@@ -47,32 +47,15 @@</span> <span class="p_context"> static void acpi_sleep_tts_switch(u32 acpi_state)</span>
 	}
 }
 
<span class="p_del">-static void acpi_sleep_pts_switch(u32 acpi_state)</span>
<span class="p_del">-{</span>
<span class="p_del">-	acpi_status status;</span>
<span class="p_del">-</span>
<span class="p_del">-	status = acpi_execute_simple_method(NULL, &quot;\\_PTS&quot;, acpi_state);</span>
<span class="p_del">-	if (ACPI_FAILURE(status) &amp;&amp; status != AE_NOT_FOUND) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * OS can&#39;t evaluate the _PTS object correctly. Some warning</span>
<span class="p_del">-		 * message will be printed. But it won&#39;t break anything.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		printk(KERN_NOTICE &quot;Failure in evaluating _PTS object\n&quot;);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int sleep_notify_reboot(struct notifier_block *this,</span>
<span class="p_add">+static int tts_notify_reboot(struct notifier_block *this,</span>
 			unsigned long code, void *x)
 {
 	acpi_sleep_tts_switch(ACPI_STATE_S5);
<span class="p_del">-</span>
<span class="p_del">-	acpi_sleep_pts_switch(ACPI_STATE_S5);</span>
<span class="p_del">-</span>
 	return NOTIFY_DONE;
 }
 
<span class="p_del">-static struct notifier_block sleep_notifier = {</span>
<span class="p_del">-	.notifier_call	= sleep_notify_reboot,</span>
<span class="p_add">+static struct notifier_block tts_notifier = {</span>
<span class="p_add">+	.notifier_call	= tts_notify_reboot,</span>
 	.next		= NULL,
 	.priority	= 0,
 };
<span class="p_chunk">@@ -916,9 +899,9 @@</span> <span class="p_context"> int __init acpi_sleep_init(void)</span>
 	pr_info(PREFIX &quot;(supports%s)\n&quot;, supported);
 
 	/*
<span class="p_del">-	 * Register the sleep_notifier to reboot notifier list so that the _TTS</span>
<span class="p_del">-	 * and _PTS object can also be evaluated when the system enters S5.</span>
<span class="p_add">+	 * Register the tts_notifier to reboot notifier list so that the _TTS</span>
<span class="p_add">+	 * object can also be evaluated when the system enters S5.</span>
 	 */
<span class="p_del">-	register_reboot_notifier(&amp;sleep_notifier);</span>
<span class="p_add">+	register_reboot_notifier(&amp;tts_notifier);</span>
 	return 0;
 }
<span class="p_header">diff --git a/drivers/block/zram/zram_drv.c b/drivers/block/zram/zram_drv.c</span>
<span class="p_header">index 5163c8f918cb..5497f7fc44d0 100644</span>
<span class="p_header">--- a/drivers/block/zram/zram_drv.c</span>
<span class="p_header">+++ b/drivers/block/zram/zram_drv.c</span>
<span class="p_chunk">@@ -1413,8 +1413,14 @@</span> <span class="p_context"> static ssize_t hot_remove_store(struct class *class,</span>
 	return ret ? ret : count;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * NOTE: hot_add attribute is not the usual read-only sysfs attribute. In a</span>
<span class="p_add">+ * sense that reading from this file does alter the state of your system -- it</span>
<span class="p_add">+ * creates a new un-initialized zram device and returns back this device&#39;s</span>
<span class="p_add">+ * device_id (or an error code if it fails to create a new device).</span>
<span class="p_add">+ */</span>
 static struct class_attribute zram_control_class_attrs[] = {
<span class="p_del">-	__ATTR_RO(hot_add),</span>
<span class="p_add">+	__ATTR(hot_add, 0400, hot_add_show, NULL),</span>
 	__ATTR_WO(hot_remove),
 	__ATTR_NULL,
 };
<span class="p_header">diff --git a/drivers/crypto/caam/ctrl.c b/drivers/crypto/caam/ctrl.c</span>
<span class="p_header">index 0ec112ee5204..2341f3799591 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/ctrl.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/ctrl.c</span>
<span class="p_chunk">@@ -557,8 +557,9 @@</span> <span class="p_context"> static int caam_probe(struct platform_device *pdev)</span>
 	 * Enable DECO watchdogs and, if this is a PHYS_ADDR_T_64BIT kernel,
 	 * long pointers in master configuration register
 	 */
<span class="p_del">-	clrsetbits_32(&amp;ctrl-&gt;mcr, MCFGR_AWCACHE_MASK, MCFGR_AWCACHE_CACH |</span>
<span class="p_del">-		      MCFGR_AWCACHE_BUFF | MCFGR_WDENABLE | MCFGR_LARGE_BURST |</span>
<span class="p_add">+	clrsetbits_32(&amp;ctrl-&gt;mcr, MCFGR_AWCACHE_MASK | MCFGR_LONG_PTR,</span>
<span class="p_add">+		      MCFGR_AWCACHE_CACH | MCFGR_AWCACHE_BUFF |</span>
<span class="p_add">+		      MCFGR_WDENABLE | MCFGR_LARGE_BURST |</span>
 		      (sizeof(dma_addr_t) == sizeof(u64) ? MCFGR_LONG_PTR : 0));
 
 	/*
<span class="p_header">diff --git a/drivers/crypto/marvell/hash.c b/drivers/crypto/marvell/hash.c</span>
<span class="p_header">index b111e14bac1e..13e89afdbb87 100644</span>
<span class="p_header">--- a/drivers/crypto/marvell/hash.c</span>
<span class="p_header">+++ b/drivers/crypto/marvell/hash.c</span>
<span class="p_chunk">@@ -168,12 +168,11 @@</span> <span class="p_context"> static void mv_cesa_ahash_std_step(struct ahash_request *req)</span>
 	mv_cesa_adjust_op(engine, &amp;creq-&gt;op_tmpl);
 	memcpy_toio(engine-&gt;sram, &amp;creq-&gt;op_tmpl, sizeof(creq-&gt;op_tmpl));
 
<span class="p_del">-	digsize = crypto_ahash_digestsize(crypto_ahash_reqtfm(req));</span>
<span class="p_del">-	for (i = 0; i &lt; digsize / 4; i++)</span>
<span class="p_del">-		writel_relaxed(creq-&gt;state[i], engine-&gt;regs + CESA_IVDIG(i));</span>
<span class="p_del">-</span>
<span class="p_del">-	mv_cesa_adjust_op(engine, &amp;creq-&gt;op_tmpl);</span>
<span class="p_del">-	memcpy_toio(engine-&gt;sram, &amp;creq-&gt;op_tmpl, sizeof(creq-&gt;op_tmpl));</span>
<span class="p_add">+	if (!sreq-&gt;offset) {</span>
<span class="p_add">+		digsize = crypto_ahash_digestsize(crypto_ahash_reqtfm(req));</span>
<span class="p_add">+		for (i = 0; i &lt; digsize / 4; i++)</span>
<span class="p_add">+			writel_relaxed(creq-&gt;state[i], engine-&gt;regs + CESA_IVDIG(i));</span>
<span class="p_add">+	}</span>
 
 	if (creq-&gt;cache_ptr)
 		memcpy_toio(engine-&gt;sram + CESA_SA_DATA_SRAM_OFFSET,
<span class="p_header">diff --git a/drivers/dax/dax.c b/drivers/dax/dax.c</span>
<span class="p_header">index ff64313770bd..4894199cebab 100644</span>
<span class="p_header">--- a/drivers/dax/dax.c</span>
<span class="p_header">+++ b/drivers/dax/dax.c</span>
<span class="p_chunk">@@ -324,7 +324,7 @@</span> <span class="p_context"> static int check_vma(struct dax_dev *dax_dev, struct vm_area_struct *vma,</span>
 		return -ENXIO;
 
 	/* prevent private mappings from being established */
<span class="p_del">-	if ((vma-&gt;vm_flags &amp; VM_SHARED) != VM_SHARED) {</span>
<span class="p_add">+	if ((vma-&gt;vm_flags &amp; VM_MAYSHARE) != VM_MAYSHARE) {</span>
 		dev_info(dev, &quot;%s: %s: fail, attempted private mapping\n&quot;,
 				current-&gt;comm, func);
 		return -EINVAL;
<span class="p_header">diff --git a/drivers/net/can/usb/peak_usb/pcan_usb_core.c b/drivers/net/can/usb/peak_usb/pcan_usb_core.c</span>
<span class="p_header">index bfb91d8fa460..1006af40481d 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/peak_usb/pcan_usb_core.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/peak_usb/pcan_usb_core.c</span>
<span class="p_chunk">@@ -872,23 +872,25 @@</span> <span class="p_context"> lbl_free_candev:</span>
 static void peak_usb_disconnect(struct usb_interface *intf)
 {
 	struct peak_usb_device *dev;
<span class="p_add">+	struct peak_usb_device *dev_prev_siblings;</span>
 
 	/* unregister as many netdev devices as siblings */
<span class="p_del">-	for (dev = usb_get_intfdata(intf); dev; dev = dev-&gt;prev_siblings) {</span>
<span class="p_add">+	for (dev = usb_get_intfdata(intf); dev; dev = dev_prev_siblings) {</span>
 		struct net_device *netdev = dev-&gt;netdev;
 		char name[IFNAMSIZ];
 
<span class="p_add">+		dev_prev_siblings = dev-&gt;prev_siblings;</span>
 		dev-&gt;state &amp;= ~PCAN_USB_STATE_CONNECTED;
 		strncpy(name, netdev-&gt;name, IFNAMSIZ);
 
 		unregister_netdev(netdev);
<span class="p_del">-		free_candev(netdev);</span>
 
 		kfree(dev-&gt;cmd_buf);
 		dev-&gt;next_siblings = NULL;
 		if (dev-&gt;adapter-&gt;dev_free)
 			dev-&gt;adapter-&gt;dev_free(dev);
 
<span class="p_add">+		free_candev(netdev);</span>
 		dev_info(&amp;intf-&gt;dev, &quot;%s removed\n&quot;, name);
 	}
 
<span class="p_header">diff --git a/drivers/nvdimm/bus.c b/drivers/nvdimm/bus.c</span>
<span class="p_header">index a8b6949a8778..23d4a1728cdf 100644</span>
<span class="p_header">--- a/drivers/nvdimm/bus.c</span>
<span class="p_header">+++ b/drivers/nvdimm/bus.c</span>
<span class="p_chunk">@@ -715,7 +715,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(nd_cmd_in_size);</span>
 
 u32 nd_cmd_out_size(struct nvdimm *nvdimm, int cmd,
 		const struct nd_cmd_desc *desc, int idx, const u32 *in_field,
<span class="p_del">-		const u32 *out_field)</span>
<span class="p_add">+		const u32 *out_field, unsigned long remainder)</span>
 {
 	if (idx &gt;= desc-&gt;out_num)
 		return UINT_MAX;
<span class="p_chunk">@@ -727,9 +727,24 @@</span> <span class="p_context"> u32 nd_cmd_out_size(struct nvdimm *nvdimm, int cmd,</span>
 		return in_field[1];
 	else if (nvdimm &amp;&amp; cmd == ND_CMD_VENDOR &amp;&amp; idx == 2)
 		return out_field[1];
<span class="p_del">-	else if (!nvdimm &amp;&amp; cmd == ND_CMD_ARS_STATUS &amp;&amp; idx == 2)</span>
<span class="p_del">-		return out_field[1] - 8;</span>
<span class="p_del">-	else if (cmd == ND_CMD_CALL) {</span>
<span class="p_add">+	else if (!nvdimm &amp;&amp; cmd == ND_CMD_ARS_STATUS &amp;&amp; idx == 2) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Per table 9-276 ARS Data in ACPI 6.1, out_field[1] is</span>
<span class="p_add">+		 * &quot;Size of Output Buffer in bytes, including this</span>
<span class="p_add">+		 * field.&quot;</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (out_field[1] &lt; 4)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * ACPI 6.1 is ambiguous if &#39;status&#39; is included in the</span>
<span class="p_add">+		 * output size. If we encounter an output size that</span>
<span class="p_add">+		 * overshoots the remainder by 4 bytes, assume it was</span>
<span class="p_add">+		 * including &#39;status&#39;.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (out_field[1] - 8 == remainder)</span>
<span class="p_add">+			return remainder;</span>
<span class="p_add">+		return out_field[1] - 4;</span>
<span class="p_add">+	} else if (cmd == ND_CMD_CALL) {</span>
 		struct nd_cmd_pkg *pkg = (struct nd_cmd_pkg *) in_field;
 
 		return pkg-&gt;nd_size_out;
<span class="p_chunk">@@ -876,7 +891,7 @@</span> <span class="p_context"> static int __nd_ioctl(struct nvdimm_bus *nvdimm_bus, struct nvdimm *nvdimm,</span>
 	/* process an output envelope */
 	for (i = 0; i &lt; desc-&gt;out_num; i++) {
 		u32 out_size = nd_cmd_out_size(nvdimm, cmd, desc, i,
<span class="p_del">-				(u32 *) in_env, (u32 *) out_env);</span>
<span class="p_add">+				(u32 *) in_env, (u32 *) out_env, 0);</span>
 		u32 copy;
 
 		if (out_size == UINT_MAX) {
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_sli.c b/drivers/scsi/lpfc/lpfc_sli.c</span>
<span class="p_header">index 7080ce2920fd..8214ebae9d50 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_sli.c</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_sli.c</span>
<span class="p_chunk">@@ -1323,18 +1323,20 @@</span> <span class="p_context"> lpfc_sli_ringtxcmpl_put(struct lpfc_hba *phba, struct lpfc_sli_ring *pring,</span>
 {
 	lockdep_assert_held(&amp;phba-&gt;hbalock);
 
<span class="p_del">-	BUG_ON(!piocb || !piocb-&gt;vport);</span>
<span class="p_add">+	BUG_ON(!piocb);</span>
 
 	list_add_tail(&amp;piocb-&gt;list, &amp;pring-&gt;txcmplq);
 	piocb-&gt;iocb_flag |= LPFC_IO_ON_TXCMPLQ;
 
 	if ((unlikely(pring-&gt;ringno == LPFC_ELS_RING)) &amp;&amp;
 	   (piocb-&gt;iocb.ulpCommand != CMD_ABORT_XRI_CN) &amp;&amp;
<span class="p_del">-	   (piocb-&gt;iocb.ulpCommand != CMD_CLOSE_XRI_CN) &amp;&amp;</span>
<span class="p_del">-	    (!(piocb-&gt;vport-&gt;load_flag &amp; FC_UNLOADING)))</span>
<span class="p_del">-		mod_timer(&amp;piocb-&gt;vport-&gt;els_tmofunc,</span>
<span class="p_del">-			  jiffies +</span>
<span class="p_del">-			  msecs_to_jiffies(1000 * (phba-&gt;fc_ratov &lt;&lt; 1)));</span>
<span class="p_add">+	   (piocb-&gt;iocb.ulpCommand != CMD_CLOSE_XRI_CN)) {</span>
<span class="p_add">+		BUG_ON(!piocb-&gt;vport);</span>
<span class="p_add">+		if (!(piocb-&gt;vport-&gt;load_flag &amp; FC_UNLOADING))</span>
<span class="p_add">+			mod_timer(&amp;piocb-&gt;vport-&gt;els_tmofunc,</span>
<span class="p_add">+				  jiffies +</span>
<span class="p_add">+				  msecs_to_jiffies(1000 * (phba-&gt;fc_ratov &lt;&lt; 1)));</span>
<span class="p_add">+	}</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/vhost/vsock.c b/drivers/vhost/vsock.c</span>
<span class="p_header">index e3b30ea9ece5..a504e2e003da 100644</span>
<span class="p_header">--- a/drivers/vhost/vsock.c</span>
<span class="p_header">+++ b/drivers/vhost/vsock.c</span>
<span class="p_chunk">@@ -506,7 +506,7 @@</span> <span class="p_context"> static void vhost_vsock_reset_orphans(struct sock *sk)</span>
 	 * executing.
 	 */
 
<span class="p_del">-	if (!vhost_vsock_get(vsk-&gt;local_addr.svm_cid)) {</span>
<span class="p_add">+	if (!vhost_vsock_get(vsk-&gt;remote_addr.svm_cid)) {</span>
 		sock_set_flag(sk, SOCK_DONE);
 		vsk-&gt;peer_shutdown = SHUTDOWN_MASK;
 		sk-&gt;sk_state = SS_UNCONNECTED;
<span class="p_header">diff --git a/fs/ceph/dir.c b/fs/ceph/dir.c</span>
<span class="p_header">index df4b3e6fa563..93142bfe6112 100644</span>
<span class="p_header">--- a/fs/ceph/dir.c</span>
<span class="p_header">+++ b/fs/ceph/dir.c</span>
<span class="p_chunk">@@ -1257,26 +1257,30 @@</span> <span class="p_context"> static int ceph_d_revalidate(struct dentry *dentry, unsigned int flags)</span>
 			return -ECHILD;
 
 		op = ceph_snap(dir) == CEPH_SNAPDIR ?
<span class="p_del">-			CEPH_MDS_OP_LOOKUPSNAP : CEPH_MDS_OP_LOOKUP;</span>
<span class="p_add">+			CEPH_MDS_OP_LOOKUPSNAP : CEPH_MDS_OP_GETATTR;</span>
 		req = ceph_mdsc_create_request(mdsc, op, USE_ANY_MDS);
 		if (!IS_ERR(req)) {
 			req-&gt;r_dentry = dget(dentry);
<span class="p_del">-			req-&gt;r_num_caps = 2;</span>
<span class="p_add">+			req-&gt;r_num_caps = op == CEPH_MDS_OP_GETATTR ? 1 : 2;</span>
 
 			mask = CEPH_STAT_CAP_INODE | CEPH_CAP_AUTH_SHARED;
 			if (ceph_security_xattr_wanted(dir))
 				mask |= CEPH_CAP_XATTR_SHARED;
 			req-&gt;r_args.getattr.mask = mask;
 
<span class="p_del">-			req-&gt;r_locked_dir = dir;</span>
 			err = ceph_mdsc_do_request(mdsc, NULL, req);
<span class="p_del">-			if (err == 0 || err == -ENOENT) {</span>
<span class="p_del">-				if (dentry == req-&gt;r_dentry) {</span>
<span class="p_del">-					valid = !d_unhashed(dentry);</span>
<span class="p_del">-				} else {</span>
<span class="p_del">-					d_invalidate(req-&gt;r_dentry);</span>
<span class="p_del">-					err = -EAGAIN;</span>
<span class="p_del">-				}</span>
<span class="p_add">+			switch (err) {</span>
<span class="p_add">+			case 0:</span>
<span class="p_add">+				if (d_really_is_positive(dentry) &amp;&amp;</span>
<span class="p_add">+				    d_inode(dentry) == req-&gt;r_target_inode)</span>
<span class="p_add">+					valid = 1;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			case -ENOENT:</span>
<span class="p_add">+				if (d_really_is_negative(dentry))</span>
<span class="p_add">+					valid = 1;</span>
<span class="p_add">+				/* Fallthrough */</span>
<span class="p_add">+			default:</span>
<span class="p_add">+				break;</span>
 			}
 			ceph_mdsc_put_request(req);
 			dout(&quot;d_revalidate %p lookup result=%d\n&quot;,
<span class="p_header">diff --git a/fs/fuse/dir.c b/fs/fuse/dir.c</span>
<span class="p_header">index 4ff9251e9d3a..eb5373a026e3 100644</span>
<span class="p_header">--- a/fs/fuse/dir.c</span>
<span class="p_header">+++ b/fs/fuse/dir.c</span>
<span class="p_chunk">@@ -1709,8 +1709,6 @@</span> <span class="p_context"> static int fuse_setattr(struct dentry *entry, struct iattr *attr)</span>
 		return -EACCES;
 
 	if (attr-&gt;ia_valid &amp; (ATTR_KILL_SUID | ATTR_KILL_SGID)) {
<span class="p_del">-		int kill;</span>
<span class="p_del">-</span>
 		attr-&gt;ia_valid &amp;= ~(ATTR_KILL_SUID | ATTR_KILL_SGID |
 				    ATTR_MODE);
 		/*
<span class="p_chunk">@@ -1722,12 +1720,11 @@</span> <span class="p_context"> static int fuse_setattr(struct dentry *entry, struct iattr *attr)</span>
 			return ret;
 
 		attr-&gt;ia_mode = inode-&gt;i_mode;
<span class="p_del">-		kill = should_remove_suid(entry);</span>
<span class="p_del">-		if (kill &amp; ATTR_KILL_SUID) {</span>
<span class="p_add">+		if (inode-&gt;i_mode &amp; S_ISUID) {</span>
 			attr-&gt;ia_valid |= ATTR_MODE;
 			attr-&gt;ia_mode &amp;= ~S_ISUID;
 		}
<span class="p_del">-		if (kill &amp; ATTR_KILL_SGID) {</span>
<span class="p_add">+		if ((inode-&gt;i_mode &amp; (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {</span>
 			attr-&gt;ia_valid |= ATTR_MODE;
 			attr-&gt;ia_mode &amp;= ~S_ISGID;
 		}
<span class="p_header">diff --git a/include/linux/cpu.h b/include/linux/cpu.h</span>
<span class="p_header">index 797d9c8e9a1b..c8938eb21e34 100644</span>
<span class="p_header">--- a/include/linux/cpu.h</span>
<span class="p_header">+++ b/include/linux/cpu.h</span>
<span class="p_chunk">@@ -105,22 +105,16 @@</span> <span class="p_context"> extern bool cpuhp_tasks_frozen;</span>
 		{ .notifier_call = fn, .priority = pri };	\
 	__register_cpu_notifier(&amp;fn##_nb);			\
 }
<span class="p_del">-#else /* #if defined(CONFIG_HOTPLUG_CPU) || !defined(MODULE) */</span>
<span class="p_del">-#define cpu_notifier(fn, pri)	do { (void)(fn); } while (0)</span>
<span class="p_del">-#define __cpu_notifier(fn, pri)	do { (void)(fn); } while (0)</span>
<span class="p_del">-#endif /* #else #if defined(CONFIG_HOTPLUG_CPU) || !defined(MODULE) */</span>
 
<span class="p_del">-#ifdef CONFIG_HOTPLUG_CPU</span>
 extern int register_cpu_notifier(struct notifier_block *nb);
 extern int __register_cpu_notifier(struct notifier_block *nb);
 extern void unregister_cpu_notifier(struct notifier_block *nb);
 extern void __unregister_cpu_notifier(struct notifier_block *nb);
<span class="p_del">-#else</span>
 
<span class="p_del">-#ifndef MODULE</span>
<span class="p_del">-extern int register_cpu_notifier(struct notifier_block *nb);</span>
<span class="p_del">-extern int __register_cpu_notifier(struct notifier_block *nb);</span>
<span class="p_del">-#else</span>
<span class="p_add">+#else /* #if defined(CONFIG_HOTPLUG_CPU) || !defined(MODULE) */</span>
<span class="p_add">+#define cpu_notifier(fn, pri)	do { (void)(fn); } while (0)</span>
<span class="p_add">+#define __cpu_notifier(fn, pri)	do { (void)(fn); } while (0)</span>
<span class="p_add">+</span>
 static inline int register_cpu_notifier(struct notifier_block *nb)
 {
 	return 0;
<span class="p_chunk">@@ -130,7 +124,6 @@</span> <span class="p_context"> static inline int __register_cpu_notifier(struct notifier_block *nb)</span>
 {
 	return 0;
 }
<span class="p_del">-#endif</span>
 
 static inline void unregister_cpu_notifier(struct notifier_block *nb)
 {
<span class="p_header">diff --git a/include/linux/libnvdimm.h b/include/linux/libnvdimm.h</span>
<span class="p_header">index bbfce62a0bd7..d02d65dfe2d0 100644</span>
<span class="p_header">--- a/include/linux/libnvdimm.h</span>
<span class="p_header">+++ b/include/linux/libnvdimm.h</span>
<span class="p_chunk">@@ -153,7 +153,7 @@</span> <span class="p_context"> u32 nd_cmd_in_size(struct nvdimm *nvdimm, int cmd,</span>
 		const struct nd_cmd_desc *desc, int idx, void *buf);
 u32 nd_cmd_out_size(struct nvdimm *nvdimm, int cmd,
 		const struct nd_cmd_desc *desc, int idx, const u32 *in_field,
<span class="p_del">-		const u32 *out_field);</span>
<span class="p_add">+		const u32 *out_field, unsigned long remainder);</span>
 int nvdimm_bus_check_dimm_count(struct nvdimm_bus *nvdimm_bus, int dimm_count);
 struct nd_region *nvdimm_pmem_region_create(struct nvdimm_bus *nvdimm_bus,
 		struct nd_region_desc *ndr_desc);
<span class="p_header">diff --git a/include/uapi/linux/can.h b/include/uapi/linux/can.h</span>
<span class="p_header">index 9692cda5f8fc..c48d93a28d1a 100644</span>
<span class="p_header">--- a/include/uapi/linux/can.h</span>
<span class="p_header">+++ b/include/uapi/linux/can.h</span>
<span class="p_chunk">@@ -196,5 +196,6 @@</span> <span class="p_context"> struct can_filter {</span>
 };
 
 #define CAN_INV_FILTER 0x20000000U /* to be set in can_filter.can_id */
<span class="p_add">+#define CAN_RAW_FILTER_MAX 512 /* maximum number of can_filter set via setsockopt() */</span>
 
 #endif /* !_UAPI_CAN_H */
<span class="p_header">diff --git a/kernel/cpu.c b/kernel/cpu.c</span>
<span class="p_header">index 341bf80f80bd..73fb59fda809 100644</span>
<span class="p_header">--- a/kernel/cpu.c</span>
<span class="p_header">+++ b/kernel/cpu.c</span>
<span class="p_chunk">@@ -578,7 +578,6 @@</span> <span class="p_context"> void __init cpuhp_threads_init(void)</span>
 	kthread_unpark(this_cpu_read(cpuhp_state.thread));
 }
 
<span class="p_del">-#ifdef CONFIG_HOTPLUG_CPU</span>
 EXPORT_SYMBOL(register_cpu_notifier);
 EXPORT_SYMBOL(__register_cpu_notifier);
 void unregister_cpu_notifier(struct notifier_block *nb)
<span class="p_chunk">@@ -595,6 +594,7 @@</span> <span class="p_context"> void __unregister_cpu_notifier(struct notifier_block *nb)</span>
 }
 EXPORT_SYMBOL(__unregister_cpu_notifier);
 
<span class="p_add">+#ifdef CONFIG_HOTPLUG_CPU</span>
 /**
  * clear_tasks_mm_cpumask - Safely clear tasks&#39; mm_cpumask for a CPU
  * @cpu: a CPU id
<span class="p_header">diff --git a/kernel/locking/rtmutex.c b/kernel/locking/rtmutex.c</span>
<span class="p_header">index 1ec0f48962b3..2c49d76f96c3 100644</span>
<span class="p_header">--- a/kernel/locking/rtmutex.c</span>
<span class="p_header">+++ b/kernel/locking/rtmutex.c</span>
<span class="p_chunk">@@ -65,8 +65,72 @@</span> <span class="p_context"> static inline void clear_rt_mutex_waiters(struct rt_mutex *lock)</span>
 
 static void fixup_rt_mutex_waiters(struct rt_mutex *lock)
 {
<span class="p_del">-	if (!rt_mutex_has_waiters(lock))</span>
<span class="p_del">-		clear_rt_mutex_waiters(lock);</span>
<span class="p_add">+	unsigned long owner, *p = (unsigned long *) &amp;lock-&gt;owner;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rt_mutex_has_waiters(lock))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The rbtree has no waiters enqueued, now make sure that the</span>
<span class="p_add">+	 * lock-&gt;owner still has the waiters bit set, otherwise the</span>
<span class="p_add">+	 * following can happen:</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * CPU 0	CPU 1		CPU2</span>
<span class="p_add">+	 * l-&gt;owner=T1</span>
<span class="p_add">+	 *		rt_mutex_lock(l)</span>
<span class="p_add">+	 *		lock(l-&gt;lock)</span>
<span class="p_add">+	 *		l-&gt;owner = T1 | HAS_WAITERS;</span>
<span class="p_add">+	 *		enqueue(T2)</span>
<span class="p_add">+	 *		boost()</span>
<span class="p_add">+	 *		  unlock(l-&gt;lock)</span>
<span class="p_add">+	 *		block()</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *				rt_mutex_lock(l)</span>
<span class="p_add">+	 *				lock(l-&gt;lock)</span>
<span class="p_add">+	 *				l-&gt;owner = T1 | HAS_WAITERS;</span>
<span class="p_add">+	 *				enqueue(T3)</span>
<span class="p_add">+	 *				boost()</span>
<span class="p_add">+	 *				  unlock(l-&gt;lock)</span>
<span class="p_add">+	 *				block()</span>
<span class="p_add">+	 *		signal(-&gt;T2)	signal(-&gt;T3)</span>
<span class="p_add">+	 *		lock(l-&gt;lock)</span>
<span class="p_add">+	 *		dequeue(T2)</span>
<span class="p_add">+	 *		deboost()</span>
<span class="p_add">+	 *		  unlock(l-&gt;lock)</span>
<span class="p_add">+	 *				lock(l-&gt;lock)</span>
<span class="p_add">+	 *				dequeue(T3)</span>
<span class="p_add">+	 *				 ==&gt; wait list is empty</span>
<span class="p_add">+	 *				deboost()</span>
<span class="p_add">+	 *				 unlock(l-&gt;lock)</span>
<span class="p_add">+	 *		lock(l-&gt;lock)</span>
<span class="p_add">+	 *		fixup_rt_mutex_waiters()</span>
<span class="p_add">+	 *		  if (wait_list_empty(l) {</span>
<span class="p_add">+	 *		    l-&gt;owner = owner</span>
<span class="p_add">+	 *		    owner = l-&gt;owner &amp; ~HAS_WAITERS;</span>
<span class="p_add">+	 *		      ==&gt; l-&gt;owner = T1</span>
<span class="p_add">+	 *		  }</span>
<span class="p_add">+	 *				lock(l-&gt;lock)</span>
<span class="p_add">+	 * rt_mutex_unlock(l)		fixup_rt_mutex_waiters()</span>
<span class="p_add">+	 *				  if (wait_list_empty(l) {</span>
<span class="p_add">+	 *				    owner = l-&gt;owner &amp; ~HAS_WAITERS;</span>
<span class="p_add">+	 * cmpxchg(l-&gt;owner, T1, NULL)</span>
<span class="p_add">+	 *  ===&gt; Success (l-&gt;owner = NULL)</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *				    l-&gt;owner = owner</span>
<span class="p_add">+	 *				      ==&gt; l-&gt;owner = T1</span>
<span class="p_add">+	 *				  }</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * With the check for the waiter bit in place T3 on CPU2 will not</span>
<span class="p_add">+	 * overwrite. All tasks fiddling with the waiters bit are</span>
<span class="p_add">+	 * serialized by l-&gt;lock, so nothing else can modify the waiters</span>
<span class="p_add">+	 * bit. If the bit is set then nothing can change l-&gt;owner either</span>
<span class="p_add">+	 * so the simple RMW is safe. The cmpxchg() will simply fail if it</span>
<span class="p_add">+	 * happens in the middle of the RMW because the waiters bit is</span>
<span class="p_add">+	 * still set.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	owner = READ_ONCE(*p);</span>
<span class="p_add">+	if (owner &amp; RT_MUTEX_HAS_WAITERS)</span>
<span class="p_add">+		WRITE_ONCE(*p, owner &amp; ~RT_MUTEX_HAS_WAITERS);</span>
 }
 
 /*
<span class="p_header">diff --git a/kernel/locking/rtmutex_common.h b/kernel/locking/rtmutex_common.h</span>
<span class="p_header">index 4f5f83c7d2d3..e317e1cbb3eb 100644</span>
<span class="p_header">--- a/kernel/locking/rtmutex_common.h</span>
<span class="p_header">+++ b/kernel/locking/rtmutex_common.h</span>
<span class="p_chunk">@@ -75,8 +75,9 @@</span> <span class="p_context"> task_top_pi_waiter(struct task_struct *p)</span>
 
 static inline struct task_struct *rt_mutex_owner(struct rt_mutex *lock)
 {
<span class="p_del">-	return (struct task_struct *)</span>
<span class="p_del">-		((unsigned long)lock-&gt;owner &amp; ~RT_MUTEX_OWNER_MASKALL);</span>
<span class="p_add">+	unsigned long owner = (unsigned long) READ_ONCE(lock-&gt;owner);</span>
<span class="p_add">+</span>
<span class="p_add">+	return (struct task_struct *) (owner &amp; ~RT_MUTEX_OWNER_MASKALL);</span>
 }
 
 /*
<span class="p_header">diff --git a/kernel/sched/auto_group.c b/kernel/sched/auto_group.c</span>
<span class="p_header">index a5d966cb8891..418d9b6276a3 100644</span>
<span class="p_header">--- a/kernel/sched/auto_group.c</span>
<span class="p_header">+++ b/kernel/sched/auto_group.c</span>
<span class="p_chunk">@@ -192,6 +192,7 @@</span> <span class="p_context"> int proc_sched_autogroup_set_nice(struct task_struct *p, int nice)</span>
 {
 	static unsigned long next = INITIAL_JIFFIES;
 	struct autogroup *ag;
<span class="p_add">+	unsigned long shares;</span>
 	int err;
 
 	if (nice &lt; MIN_NICE || nice &gt; MAX_NICE)
<span class="p_chunk">@@ -210,9 +211,10 @@</span> <span class="p_context"> int proc_sched_autogroup_set_nice(struct task_struct *p, int nice)</span>
 
 	next = HZ / 10 + jiffies;
 	ag = autogroup_task_get(p);
<span class="p_add">+	shares = scale_load(sched_prio_to_weight[nice + 20]);</span>
 
 	down_write(&amp;ag-&gt;lock);
<span class="p_del">-	err = sched_group_set_shares(ag-&gt;tg, sched_prio_to_weight[nice + 20]);</span>
<span class="p_add">+	err = sched_group_set_shares(ag-&gt;tg, shares);</span>
 	if (!err)
 		ag-&gt;nice = nice;
 	up_write(&amp;ag-&gt;lock);
<span class="p_header">diff --git a/net/batman-adv/translation-table.c b/net/batman-adv/translation-table.c</span>
<span class="p_header">index 7e6df7a4964a..67f8fa9fc15a 100644</span>
<span class="p_header">--- a/net/batman-adv/translation-table.c</span>
<span class="p_header">+++ b/net/batman-adv/translation-table.c</span>
<span class="p_chunk">@@ -2849,7 +2849,7 @@</span> <span class="p_context"> static bool batadv_send_my_tt_response(struct batadv_priv *bat_priv,</span>
 							     &amp;tvlv_tt_data,
 							     &amp;tt_change,
 							     &amp;tt_len);
<span class="p_del">-		if (!tt_len)</span>
<span class="p_add">+		if (!tt_len || !tvlv_len)</span>
 			goto unlock;
 
 		/* Copy the last orig_node&#39;s OGM buffer */
<span class="p_chunk">@@ -2867,7 +2867,7 @@</span> <span class="p_context"> static bool batadv_send_my_tt_response(struct batadv_priv *bat_priv,</span>
 							     &amp;tvlv_tt_data,
 							     &amp;tt_change,
 							     &amp;tt_len);
<span class="p_del">-		if (!tt_len)</span>
<span class="p_add">+		if (!tt_len || !tvlv_len)</span>
 			goto out;
 
 		/* fill the rest of the tvlv with the real TT entries */
<span class="p_header">diff --git a/net/can/raw.c b/net/can/raw.c</span>
<span class="p_header">index 972c187d40ab..b075f028d7e2 100644</span>
<span class="p_header">--- a/net/can/raw.c</span>
<span class="p_header">+++ b/net/can/raw.c</span>
<span class="p_chunk">@@ -499,6 +499,9 @@</span> <span class="p_context"> static int raw_setsockopt(struct socket *sock, int level, int optname,</span>
 		if (optlen % sizeof(struct can_filter) != 0)
 			return -EINVAL;
 
<span class="p_add">+		if (optlen &gt; CAN_RAW_FILTER_MAX * sizeof(struct can_filter))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
 		count = optlen / sizeof(struct can_filter);
 
 		if (count &gt; 1) {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



