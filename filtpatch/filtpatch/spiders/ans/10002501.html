
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.16.49 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.16.49</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 12, 2017, 6:36 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171012183657.GJ2971@decadent.org.uk&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10002501/mbox/"
   >mbox</a>
|
   <a href="/patch/10002501/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10002501/">/patch/10002501/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	E5FEA60216 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 12 Oct 2017 18:38:16 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 909A928E6F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 12 Oct 2017 18:38:16 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 834E428E75; Thu, 12 Oct 2017 18:38:16 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 3699428E6F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 12 Oct 2017 18:38:03 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752962AbdJLSh1 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 12 Oct 2017 14:37:27 -0400
Received: from shadbolt.e.decadent.org.uk ([88.96.1.126]:40828 &quot;EHLO
	shadbolt.e.decadent.org.uk&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S1751067AbdJLShR (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 12 Oct 2017 14:37:17 -0400
Received: from ben by shadbolt.decadent.org.uk with local (Exim 4.84_2)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1e2iLp-0007Yc-VZ; Thu, 12 Oct 2017 19:37:11 +0100
Date: Thu, 12 Oct 2017 19:36:57 +0100
From: Ben Hutchings &lt;ben@decadent.org.uk&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, Jiri Slaby &lt;jslaby@suse.cz&gt;,
	stable@vger.kernel.org
Cc: lwn@lwn.net
Message-ID: &lt;20171012183657.GJ2971@decadent.org.uk&gt;
MIME-Version: 1.0
Content-Type: multipart/signed; micalg=pgp-sha512;
	protocol=&quot;application/pgp-signature&quot;; boundary=&quot;Mit9XoPEfICDqq/V&quot;
Content-Disposition: inline
X-Mailer: LinuxStableQueue (scripts by bwh)
User-Agent: Mutt/1.5.23 (2014-03-12)
X-SA-Exim-Connect-IP: &lt;locally generated&gt;
X-SA-Exim-Mail-From: ben@decadent.org.uk
Subject: Linux 3.16.49
X-SA-Exim-Version: 4.2.1 (built Mon, 26 Dec 2011 16:24:06 +0000)
X-SA-Exim-Scanned: Yes (on shadbolt.decadent.org.uk)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a> - Oct. 12, 2017, 6:36 p.m.</div>
<pre class="content">
I&#39;m announcing the release of the 3.16.49 kernel.

All users of the 3.16 kernel series should upgrade.

The updated 3.16.y git tree can be found at:
        https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git linux-3.16.y
and can be browsed at the normal kernel.org git web browser:
        https://git.kernel.org/?p=linux/kernel/git/stable/linux-stable.git

The diff from 3.16.48 is attached to this message.

Ben.

------------

 Documentation/DMA-API.txt                      |   2 +-
 Documentation/cgroups/cpusets.txt              |   6 +-
 Makefile                                       |   2 +-
 arch/arm/include/asm/xen/events.h              |   2 +-
 arch/arm/mach-omap2/sleep34xx.S                |  22 +--
 arch/arm64/include/asm/elf.h                   |  11 +-
 arch/arm64/include/asm/ptrace.h                |  34 +----
 arch/arm64/kernel/ptrace.c                     |  89 ++++++++++-
 arch/arm64/kernel/signal.c                     |   4 +-
 arch/arm64/kernel/signal32.c                   |   2 +-
 arch/m32r/include/asm/io.h                     |  11 +-
 arch/mips/include/asm/branch.h                 |   5 +-
 arch/mips/include/asm/kvm_host.h               |   1 +
 arch/mips/include/asm/processor.h              |   2 +-
 arch/mips/kernel/branch.c                      |   8 +-
 arch/mips/kernel/module-rela.c                 |  19 ++-
 arch/mips/kernel/module.c                      |  43 ++++--
 arch/mips/kernel/ptrace.c                      |   2 +-
 arch/mips/kernel/scall32-o32.S                 |   2 +-
 arch/mips/kernel/scall64-64.S                  |   2 +-
 arch/mips/kernel/scall64-n32.S                 |   2 +-
 arch/mips/kernel/scall64-o32.S                 |   2 +-
 arch/mips/kernel/syscall.c                     |  15 +-
 arch/mips/kvm/kvm_locore.S                     |   1 +
 arch/mips/kvm/kvm_mips.c                       |  11 +-
 arch/mips/kvm/kvm_mips_int.h                   |   2 +
 arch/mips/math-emu/cp1emu.c                    |  38 +++++
 arch/parisc/include/asm/dma-mapping.h          |  11 +-
 arch/parisc/kernel/syscall_table.S             |   2 +-
 arch/parisc/mm/fault.c                         |   2 +-
 arch/powerpc/include/asm/atomic.h              |   4 +-
 arch/powerpc/include/asm/reg.h                 |   2 +-
 arch/powerpc/lib/sstep.c                       |  13 ++
 arch/s390/include/asm/syscall.h                |   8 +-
 arch/sparc/include/asm/head_64.h               |   4 +
 arch/sparc/include/asm/ttable.h                |   8 +-
 arch/sparc/kernel/Makefile                     |   1 +
 arch/sparc/kernel/cherrs.S                     |  14 +-
 arch/sparc/kernel/entry.S                      |  17 +++
 arch/sparc/kernel/fpu_traps.S                  |  11 +-
 arch/sparc/kernel/head_64.S                    |  24 +--
 arch/sparc/kernel/misctrap.S                   |  12 +-
 arch/sparc/kernel/pci.c                        |  17 +++
 arch/sparc/kernel/rtrap_64.S                   |  57 ++-----
 arch/sparc/kernel/signal32.c                   |  46 ++++--
 arch/sparc/kernel/signal_32.c                  |  41 ++++--
 arch/sparc/kernel/signal_64.c                  |  33 +++--
 arch/sparc/kernel/sigutil_32.c                 |   9 +-
 arch/sparc/kernel/sigutil_64.c                 |  10 +-
 arch/sparc/kernel/spiterrs.S                   |  18 +--
 arch/sparc/kernel/syscalls.S                   |  36 +++++
 arch/sparc/kernel/urtt_fill.S                  |  98 +++++++++++++
 arch/sparc/kernel/utrap.S                      |   3 +-
 arch/sparc/kernel/vmlinux.lds.S                |   4 +
 arch/sparc/kernel/winfixup.S                   |   3 +-
 arch/sparc/mm/init_64.c                        |  10 +-
 arch/x86/boot/compressed/Makefile              |   3 +
 arch/x86/boot/compressed/efi_stub_64.S         |  25 ----
 arch/x86/boot/compressed/efi_thunk_64.S        | 196 +++++++++++++++++++++++++
 arch/x86/crypto/sha1_ssse3_glue.c              |   3 +-
 arch/x86/include/asm/xen/hypercall.h           |   3 +
 arch/x86/include/uapi/asm/msr-index.h          |   2 +
 arch/x86/kernel/cpu/perf_event_intel.c         |  12 +-
 arch/x86/kernel/nmi_selftest.c                 |   2 +-
 arch/x86/kvm/cpuid.h                           |   9 ++
 arch/x86/kvm/vmx.c                             |  16 +-
 arch/x86/pci/fixup.c                           |  52 ++++++-
 arch/x86/platform/efi/efi_stub_64.S            | 161 --------------------
 arch/x86/platform/efi/efi_thunk_64.S           | 121 ++++++++++++---
 drivers/acpi/ec.c                              |   4 +-
 drivers/base/power/domain.c                    |   4 +-
 drivers/base/power/sysfs.c                     |   2 +
 drivers/char/tpm/tpm-sysfs.c                   |   3 +-
 drivers/crypto/atmel-sha.c                     |   4 +-
 drivers/crypto/caam/caamhash.c                 |   2 +-
 drivers/crypto/caam/key_gen.c                  |   2 +-
 drivers/crypto/talitos.c                       |   7 +-
 drivers/gpu/drm/drm_irq.c                      |   3 +-
 drivers/gpu/drm/i915/i915_dma.c                |   8 +-
 drivers/gpu/drm/i915/intel_display.c           |  11 +-
 drivers/gpu/drm/i915/intel_drv.h               |   1 +
 drivers/gpu/drm/i915/intel_sprite.c            |  20 +++
 drivers/gpu/drm/msm/hdmi/hdmi_audio.c          |   6 +-
 drivers/gpu/drm/radeon/atombios_encoders.c     |  13 +-
 drivers/i2c/busses/i2c-cadence.c               |   6 +-
 drivers/iio/accel/st_accel_spi.c               |   4 -
 drivers/iio/magnetometer/st_magn_spi.c         |   2 -
 drivers/infiniband/core/cache.c                |  61 ++++----
 drivers/infiniband/core/device.c               |  26 +---
 drivers/infiniband/core/uverbs_cmd.c           |   9 ++
 drivers/input/serio/i8042.c                    |  12 +-
 drivers/input/touchscreen/ads7846.c            |   8 +-
 drivers/macintosh/therm_windtunnel.c           |   1 +
 drivers/md/dm.c                                |  55 +++++++
 drivers/md/raid1.c                             |   5 +-
 drivers/md/raid5.c                             |   5 +-
 drivers/media/pci/saa7164/saa7164-buffer.c     |   4 +-
 drivers/media/pci/saa7164/saa7164-bus.c        |  96 ++++++------
 drivers/media/pci/saa7164/saa7164-core.c       |  13 +-
 drivers/media/pci/saa7164/saa7164-fw.c         |   6 +-
 drivers/media/pci/saa7164/saa7164-types.h      |   4 +-
 drivers/media/pci/saa7164/saa7164.h            |   4 +-
 drivers/media/rc/mceusb.c                      |   5 +
 drivers/misc/ad525x_dpot.c                     |   2 +-
 drivers/misc/enclosure.c                       |  14 +-
 drivers/net/ethernet/intel/e1000e/netdev.c     |  33 ++++-
 drivers/net/hyperv/netvsc_drv.c                |  19 ++-
 drivers/net/vxlan.c                            |   2 +-
 drivers/net/wireless/ath/ath9k/ar9003_phy.c    |   2 -
 drivers/net/wireless/ath/ath9k/tx99.c          |  13 +-
 drivers/net/wireless/iwlwifi/mvm/mac80211.c    |  32 +++-
 drivers/net/wireless/libertas/mesh.c           |   5 +-
 drivers/net/wireless/mwifiex/cfg80211.c        |  37 ++---
 drivers/net/wireless/mwifiex/fw.h              |   5 -
 drivers/net/wireless/mwifiex/uap_cmd.c         |  22 ---
 drivers/net/wireless/ti/wlcore/spi.c           |   3 +-
 drivers/parisc/ccio-dma.c                      |  12 ++
 drivers/parisc/dino.c                          |   5 +-
 drivers/parisc/lba_pci.c                       |   6 +-
 drivers/parisc/sba_iommu.c                     |  14 ++
 drivers/pci/pci-driver.c                       |   1 +
 drivers/pci/pci-sysfs.c                        |  18 +--
 drivers/pci/quirks.c                           |  14 +-
 drivers/pinctrl/pinctrl-imx.c                  |  12 +-
 drivers/rtc/rtc-nuc900.c                       |   2 +-
 drivers/scsi/bnx2i/bnx2i_iscsi.c               |   3 +-
 drivers/scsi/scsi_scan.c                       |   5 +-
 drivers/scsi/scsi_sysfs.c                      |   8 +-
 drivers/scsi/scsi_transport_iscsi.c            |   2 +-
 drivers/scsi/sun_esp.c                         |   9 +-
 drivers/scsi/virtio_scsi.c                     |  12 ++
 drivers/spi/spi-atmel.c                        |  24 ++-
 drivers/staging/comedi/comedi_fops.c           |   1 +
 drivers/staging/usbip/stub_main.c              |   4 +
 drivers/staging/usbip/stub_tx.c                |   4 +
 drivers/target/iscsi/iscsi_target_configfs.c   |   3 +
 drivers/target/iscsi/iscsi_target_core.h       |   9 ++
 drivers/target/iscsi/iscsi_target_nego.c       |   6 +-
 drivers/target/iscsi/iscsi_target_parameters.c |  41 ++++--
 drivers/target/iscsi/iscsi_target_parameters.h |   2 +-
 drivers/target/iscsi/iscsi_target_tpg.c        |  19 +++
 drivers/target/iscsi/iscsi_target_tpg.h        |   1 +
 drivers/target/target_core_transport.c         |   9 ++
 drivers/tty/serial/samsung.c                   |   4 +-
 drivers/tty/serial/sccnxp.c                    |  15 +-
 drivers/tty/vt/vt.c                            |   6 +-
 drivers/usb/core/quirks.c                      |   4 +
 drivers/usb/host/xhci-hub.c                    |   3 +
 drivers/usb/host/xhci-pci.c                    |  12 ++
 drivers/usb/host/xhci.h                        |   1 +
 drivers/usb/musb/musb_cppi41.c                 |  24 +--
 drivers/usb/serial/cp210x.c                    |   1 +
 drivers/usb/serial/option.c                    |   4 +
 drivers/usb/serial/qcserial.c                  |   1 +
 drivers/vfio/vfio.c                            |  46 +++++-
 drivers/video/fbdev/aty/atyfb_base.c           |   2 +-
 fs/btrfs/acl.c                                 |  19 ++-
 fs/btrfs/extent-tree.c                         |   2 +-
 fs/btrfs/file.c                                |   5 +-
 fs/btrfs/ioctl.c                               |   2 +-
 fs/cifs/cifs_fs_sb.h                           |   4 +
 fs/cifs/cifsfs.c                               |  17 ++-
 fs/cifs/cifsproto.h                            |   2 +-
 fs/cifs/connect.c                              |  80 +++++++++-
 fs/cifs/dir.c                                  |  20 ++-
 fs/cifs/file.c                                 |   5 +-
 fs/cifs/inode.c                                |  22 ++-
 fs/dcache.c                                    |   5 +-
 fs/exec.c                                      |   4 +-
 fs/ext2/acl.c                                  |  43 ++++--
 fs/ext3/acl.c                                  |  21 ++-
 fs/ext4/acl.c                                  |  25 +++-
 fs/f2fs/acl.c                                  |   7 +-
 fs/f2fs/gc.c                                   |   9 +-
 fs/f2fs/inode.c                                |   1 +
 fs/hfsplus/posix_acl.c                         |  30 ++--
 fs/jfs/acl.c                                   |  24 ++-
 fs/proc/proc_sysctl.c                          |  10 +-
 fs/reiserfs/xattr_acl.c                        |  17 ++-
 fs/ubifs/journal.c                             |   8 +-
 fs/ubifs/tnc.c                                 |   2 +
 fs/ubifs/ubifs.h                               |   1 +
 fs/ubifs/xattr.c                               |  22 +++
 fs/udf/file.c                                  |   9 +-
 fs/udf/inode.c                                 |   4 +-
 fs/xfs/xfs_acl.c                               |   6 +-
 fs/xfs/xfs_acl.h                               |   1 +
 fs/xfs/xfs_dinode.h                            |   9 +-
 fs/xfs/xfs_iops.c                              |   4 +-
 include/linux/cpumask.h                        |  17 +++
 include/linux/cpuset.h                         |   4 +-
 include/linux/net.h                            |  17 +++
 include/linux/pci_ids.h                        |   7 +
 include/linux/sched.h                          |  34 ++++-
 include/linux/usb/hcd.h                        |   4 +-
 include/linux/vfio.h                           |   2 +
 include/rdma/ib_verbs.h                        |  34 +++++
 include/scsi/scsi_device.h                     |   1 +
 include/uapi/linux/v4l2-dv-timings.h           |  30 ++--
 kernel/cpuset.c                                |   9 +-
 kernel/events/core.c                           |  15 +-
 kernel/sched/core.c                            | 102 +++++++++----
 kernel/seccomp.c                               |   2 +-
 kernel/sys.c                                   |   4 +-
 lib/cpumask.c                                  |  32 ++++
 mm/memory.c                                    |  14 +-
 mm/mmap.c                                      |   8 +-
 mm/slab.c                                      |   4 +-
 mm/swap.c                                      |   9 +-
 net/bluetooth/l2cap_core.c                     |  80 +++++-----
 net/bluetooth/smp.c                            |   5 +-
 net/ipv4/fib_frontend.c                        |   6 +-
 net/ipv4/fib_semantics.c                       |   2 +
 net/ipv4/ip_output.c                           |   3 +-
 net/ipv4/tcp_output.c                          |   1 +
 net/ipv6/addrconf.c                            |  23 +--
 net/ipv6/ip6_fib.c                             |   6 +-
 net/iucv/af_iucv.c                             |   8 +-
 net/l2tp/l2tp_ip.c                             |   2 +-
 net/nfc/core.c                                 |  31 ++--
 net/sched/cls_api.c                            |   3 +-
 net/sunrpc/auth_gss/gss_krb5_crypto.c          |   3 +-
 net/wireless/nl80211.c                         |  11 +-
 scripts/tags.sh                                |   6 +
 security/apparmor/domain.c                     |   4 +-
 sound/pci/oxygen/oxygen_mixer.c                |   2 +-
 sound/soc/soc-compress.c                       |   6 +-
 tools/lib/lockdep/uinclude/linux/lockdep.h     |   2 +-
 virt/kvm/vfio.c                                |  27 +++-
 229 files changed, 2414 insertions(+), 1043 deletions(-)

Abhilash Kesavan (1):
      m32r: add definition of ioremap_wc to io.h

Adam Borowski (1):
      vt: fix unchecked __put_user() in tioclinux ioctls

Alex Williamson (2):
      vfio: Fix group release deadlock
      vfio: New external user group/file match

Andrea Arcangeli (1):
      mm: thp: fix SMP race condition between THP page fault and MADV_DONTNEED

Andrey Gelman (1):
      Input: ads7846 - correct the value got from SPI

Andrey Ryabinin (1):
      perf/x86: Fix undefined shift on 32-bit kernels

Anton Blanchard (1):
      powerpc: Fix emulation of mfocrf in emulate_step()

Arnd Bergmann (2):
      wlcore: fix 64K page support
      xen: avoid type warning in xchg_xen_ulong

Aurelien Aptel (1):
      fs/cifs: make share unaccessible at root level mountable

Babu Moger (1):
      sparc/PCI: Fix for panic while enabling SR-IOV

Ben Hutchings (4):
      tools/lib/lockdep: Reduce MAX_LOCK_DEPTH to avoid overflowing lock_chain/: Depth
      ext3: Don&#39;t clear SGID when inheriting ACLs
      ext3: preserve i_mode if ext2_set_acl() fails
      Linux 3.16.49

Ben Seri (1):
      Bluetooth: Properly check L2CAP config option output buffer length

Benjamin Herrenschmidt (1):
      usb: Fix typo in the definition of Endpoint[out]Request

Bin Liu (2):
      usb: musb: cppi41: correct the macro name EP_MODE_AUTOREG_*
      usb: musb: cppi41: improve rx channel abort routine

Bjorn Helgaas (3):
      PCI: Correct PCI_STD_RESOURCE_END usage
      PCI: Mark Haswell Power Control Unit as having non-compliant BARs
      PCI: Work around poweroff &amp; suspend-to-RAM issue on Macbook Pro 11

Bjørn Mork (1):
      USB: serial: qcserial: new Sierra Wireless EM7305 device ID

Boris Pismenny (1):
      RDMA/uverbs: Check port number supplied by user verbs cmds

Brian Norris (1):
      mwifiex: fixup error cases in mwifiex_add_virtual_intf()

Chanwoo Choi (1):
      serial: samsung: Reorder the sequence of clock control when call s3c24xx_serial_set_termios()

Chen Hong (1):
      Input: i8042 - fix crash at boot time

Chen Yu (1):
      PCI/PM: Restore the status of PCI devices across hibernation

Chris Wilson (1):
      e1000e: Undo e1000e_pm_freeze if __e1000_shutdown fails

Cyrille Pitchen (1):
      spi: atmel: fix corrupted data issue on SAM9 family SoCs

Dan Bogdan Nechita (1):
      misc: ad525x_dpot: Fix the enabling of the &quot;otpXen&quot; attributes

Dan Carpenter (5):
      x86/nmi: Fix timeout test in test_nmi_ipi()
      scsi: bnx2i: missing error code in bnx2i_ep_connect()
      libertas: Fix lbs_prb_rsp_limit_set()
      rtc: rtc-nuc900: fix loop timeout test
      PM / QoS: return -EINVAL for bogus strings

Dave Martin (1):
      arm64: ptrace: Avoid setting compat FP[SC]R to garbage if get_user fails

David Ertman (1):
      e1000e: Fix Runtime PM blocks EEE link negotiation in S5

David S. Miller (5):
      sparc64: Fix bootup regressions on some Kconfig combinations.
      sparc64: Fix sparc64_set_context stack handling.
      sparc64: Take ctx_alloc_lock properly in hugetlb_setup().
      sparc: Harden signal return frame checks.
      sparc64: Fix return from trap window fill crashes.

Devin Heitmueller (1):
      Add USB quirk for HVR-950q to avoid intermittent device resets

Dong Aisheng (1):
      pinctrl: imx: fix debug message for SHARE_MUX_CONF_REG case

Dong Bo (1):
      arm64: Preventing READ_IMPLIES_EXEC propagation

Emmanuel Grumbach (1):
      iwlwifi: mvm: fix the recovery flow while connecting

Eric Biggers (1):
      parisc: use compat_sys_keyctl()

Ernesto A. Fernández (6):
      ext2: preserve i_mode if ext2_set_acl() fails
      reiserfs: preserve i_mode if __reiserfs_set_acl() fails
      jfs: preserve i_mode if __jfs_set_acl() fails
      ext4: preserve i_mode if __ext4_set_acl() fails
      f2fs: preserve i_mode if __f2fs_set_acl() fails
      btrfs: preserve i_mode if __btrfs_set_acl() fails

Ewan D. Milne (1):
      scsi: Add STARGET_CREATED_REMOVE state to scsi_target_state

Filipe Manana (1):
      Btrfs: fix invalid extent maps due to hole punching

Ganapathi Bhat (1):
      mwifiex: do not update MCS set from hostapd

Gilad Ben-Yossef (1):
      crypto: atmel - only treat EBUSY as transient if backlog

Hans Verkuil (2):
      saa7164: fix sparse warnings
      v4l2-dv-timings.h: fix polarity for 4k formats

Helge Deller (2):
      parisc: Report SIGSEGV instead of SIGBUS when running out of stack
      mm: fix overflow check in expand_upwards()

Herbert Xu (1):
      crypto: sha1-ssse3 - Disable avx2

Horia Geantă (1):
      crypto: caam - fix signals handling

Ian Abbott (1):
      staging: comedi: fix clean-up of comedi_class in comedi_init()

Ira Weiny (1):
      IB/core: Create common start/end port functions

Jaegeuk Kim (3):
      f2fs: load inode&#39;s flag from disk
      f2fs: try to freeze in gc and discard threads
      f2fs: Don&#39;t clear SGID when inheriting ACLs

Jamal Hadi Salim (2):
      net: reflect mark on tcp syn ack packets
      net sched filters: fix notification of filter delete with proper handle

James Hogan (5):
      MIPS: Fix mips_atomic_set() retry condition
      MIPS: Save static registers before sysmips
      MIPS: Fix mips_atomic_set() with EVA
      MIPS: Negate error syscall return in trace
      MIPS: KVM: Fix modular KVM under QEMU

Jan Kara (9):
      udf: Fix races with i_size changes during readpage
      udf: Fix deadlock between writeback and udf_setsize()
      xfs: Don&#39;t clear SGID when inheriting ACLs
      btrfs: Don&#39;t clear SGID when inheriting ACLs
      ext2: Don&#39;t clear SGID when inheriting ACLs
      hfsplus: Don&#39;t clear SGID when inheriting ACLs
      reiserfs: Don&#39;t clear SGID when inheriting ACLs
      jfs: Don&#39;t clear SGID when inheriting ACLs
      ext4: Don&#39;t clear SGID when inheriting ACLs

Jan Willeke (1):
      s390/seccomp: fix error return for filtered system calls

Jarkko Sakkinen (1):
      tpm: fix a kernel memory leak in tpm-sysfs.c

Jason A. Donenfeld (4):
      Bluetooth: use constant time memory comparison for secret values
      sunrpc: use constant time memory comparison for mac
      net_dbg_ratelimited: turn into no-op when !DEBUG
      net: Don&#39;t forget pr_fmt on net_dbg_ratelimited for CONFIG_DYNAMIC_DEBUG

Jason S. McMullan (3):
      PCI: Support PCIe devices with short cfg_size
      PCI: Add Netronome vendor and device IDs
      PCI: Limit config space size for Netronome NFP6000 family

Javier Martinez Canillas (1):
      macintosh/therm_windtunnel: Export I2C module alias information

Jeremie Rapin (1):
      USB: serial: cp210x: add ID for CEL EM3588 USB ZigBee stick

Jiahau Chang (1):
      xhci: Limit USB2 port wake support for AMD Promontory hosts

Jiang Yi (1):
      target: Fix COMPARE_AND_WRITE caw_sem leak during se_cmd quiesce

Jim Mattson (4):
      kvm: vmx: Do not disable intercepts for BNDCFGS
      kvm: x86: Guest BNDCFGS requires guest MPX support
      kvm: vmx: Check value written to IA32_BNDCFGS
      kvm: nVMX: Don&#39;t allow L2 to access the hardware CR8

Jiri Olsa (1):
      s390/syscalls: Fix out of bounds arguments access

Johan Hovold (4):
      mceusb: fix memory leaks in error path
      USB: serial: option: add two Longcheer device ids
      NFC: fix broken device allocation
      scsi: sun_esp: fix device reference leaks

Josef Bacik (1):
      Btrfs: don&#39;t use src fd for printk

Kees Cook (1):
      sched: move no_new_privs into new atomic flags

Krzysztof Kozlowski (1):
      PM / Domains: Fix unsafe iteration over modified list of device links

Lauro Ramos Venancio (1):
      sched/topology: Refactor function build_overlap_sched_groups()

Liu Bo (1):
      Btrfs: skip commit transaction if we don&#39;t have enough pinned bytes

Liviu Dudau (1):
      drm/msm/hdmi: Use bitwise operators when building register values

Lorenzo Bianconi (2):
      iio: accel: st_accel_spi: fix spi_device_id table
      iio: magnetometer: st_magn_spi: fix spi_device_id table

Lubomir Rintel (1):
      ipv6: always add flag an address that failed DAD with DADFAILED

Luis R. Rodriguez (1):
      sysctl: fix lax sysctl_check_table() sanity check

Lukasz Odzioba (1):
      mm/swap.c: flush lru pvecs on compound page arrival

Lv Zheng (1):
      Revert &quot;ACPI / EC: Add support to disallow QR_EC to be issued before completing previous QR_EC&quot;

Maciej W. Rozycki (4):
      MIPS: math-emu: Prevent wrong ISA mode instruction emulation
      MIPS: Actually decode JALX in `__compute_return_epc_for_insn&#39;
      MIPS: Fix unaligned PC interpretation in `compute_return_epc&#39;
      MIPS: Send SIGILL for BPOSGE32 in `__compute_return_epc_for_insn&#39;

Marek Marczykowski-Górecki (1):
      x86/xen: allow userspace access during hypercalls

Mario Kleiner (1):
      drm/radeon: Fix eDP for single-display iMac10,1 (v2)

Mark Rutland (1):
      arm64: Rework valid_user_regs

Martin Hicks (1):
      crypto: talitos - Extend max key length for SHA384/512-HMAC and AEAD

Mateusz Jurczyk (1):
      af_iucv: Move sockaddr length checks to before accessing sa_family in bind and connect handlers

Matt Fleming (1):
      x86/efi: Avoid triple faults during EFI mixed mode calls

Matt Weber (1):
      i2c: cadance: fix ctrl/addr reg write order

Maurizio Lombardi (1):
      scsi: ses: do not add a device to an enclosure if enclosure_add_links() fails.

Miaoqing Pan (2):
      ath9k: fix tx99 use after free
      ath9k: fix tx99 bus error

Michael Ellerman (1):
      powerpc/64: Fix atomic64_inc_not_zero() to return an int

Michael Grzeschik (1):
      usb: usbip: set buffer pointers to NULL after free

Michal Hocko (1):
      mm/mmap.c: do not blow on PROT_NONE MAP_FIXED holes in the stack

Mike Frysinger (1):
      sparc: Fix system call tracing register handling.

Mikulas Patocka (2):
      md: don&#39;t use flush_signals in userspace processes
      dm: flush queued bios when process blocks to avoid deadlock

Nicholas Bellinger (1):
      iscsi-target: Add login_keys_workaround attribute for non RFC initiators

Oliver O&#39;Halloran (1):
      powerpc/asm: Mark cr0 as clobbered in mftb()

Palik, Imre (1):
      perf/x86: Honor the architectural performance monitoring version

Paolo Abeni (2):
      net/route: enforce hoplimit max value
      ipv4/fib: don&#39;t warn when primary address is missing if in_dev is dead

Paolo Bonzini (1):
      scsi: virtio_scsi: let host do exception handling

Paul Burton (2):
      MIPS: Bail on unsupported module relocs
      MIPS: module: Ensure we always clean up r_mips_hi16_list

Paul Hüber (1):
      l2tp: avoid use-after-free caused by l2tp_ip_backlog_recv

Peter Zijlstra (5):
      sched/fair, cpumask: Export for_each_cpu_wrap()
      sched/topology: Fix building of overlapping sched-groups
      sched/topology: Fix overlapping sched_group_mask
      sched/topology: Fix overlapping sched_group_capacity
      perf/core: Correct event creation with PERF_FORMAT_GROUP

Rabin Vincent (1):
      CIFS: fix circular locking dependency

Ralf Baechle (1):
      MIPS: Fix 64k page support for 32 bit kernels.

Richard Wareing (1):
      xfs: XFS_IS_REALTIME_INODE() should be false if no rt device present

Richard Weinberger (2):
      ubifs: Correctly evict xattr inodes
      ubifs: Don&#39;t leak kernel memory to the MTD

Rob Clark (1):
      drm/irq: BUG_ON() -&gt; WARN_ON()

Roopa Prabhu (1):
      vxlan: dont migrate permanent fdb entries during learn

Sabrina Dubroca (1):
      ipv6: dad: don&#39;t remove dynamic addresses if link is down

Sachin Prabhu (5):
      Fix memory leaks in cifs_do_mount()
      Compare prepaths when comparing superblocks
      Move check for prefix path to within cifs_get_root()
      Fix regression which breaks DFS mounting
      Fix match_prepath()

Sahitya Tummala (1):
      fs/dcache.c: fix spin lockup issue on nlru-&gt;lock

Satish Babu Patakokila (1):
      ASoC: compress: Derive substream from stream based on direction

Simon Horman (2):
      PCI: Add Netronome NFP4000 PF device ID
      PCI: Limit config space size for Netronome NFP4000

Srinivas Dasari (3):
      cfg80211: Check if PMKID attribute is of expected size
      cfg80211: Define nla_policy for NL80211_ATTR_LOCAL_MESH_POWER_MODE
      cfg80211: Validate frequencies nested in NL80211_ATTR_SCAN_FREQUENCIES

Stephen Hemminger (1):
      netvsc: fix incorrect receive checksum offloading

Steven Toth (1):
      saa7164: fix double fetch PCIe access condition

Sudip Mukherjee (1):
      m32r: add io*_rep helpers

Thomas Bogendoerfer (2):
      Fix serial console on SNI RM400 machines
      parisc: DMA API: return error instead of BUG_ON for dma ops on non dma devs

Tim Bingham (1):
      net: Implement net_dbg_ratelimited() for CONFIG_DYNAMIC_DEBUG case

Tomer Barletz (1):
      ALSA: oxygen: Fix logical-not-parentheses warning

Tony Lindgren (1):
      ARM: OMAP3: Fix booting with thumb2 kernel

Ville Syrjälä (2):
      drm/i915: Workaround VLV/CHV DSI scanline counter hardware fail
      drm/i915: Disable MSI for all pre-gen5

Vladis Dronov (2):
      nl80211: check for the required netlink attributes presence
      video: fbdev: aty: do not leak uninitialized padding in clk to userspace

Wolfram Sang (1):
      Documentation: DMA API: fix a typo in a function name

Xin Long (1):
      scsi: scsi_transport_iscsi: fix the issue that iscsi_if_rx doesn&#39;t parse nlmsg properly

Yuval Shaia (1):
      IB/core: Add inline function to validate port

Zefan Li (3):
      sched: fix confusing PFA_NO_NEW_PRIVS constant
      sched: add macros to define bitops for task atomic flags
      cpuset: PF_SPREAD_PAGE and PF_SPREAD_SLAB should be atomic flags

Zhihui Zhang (1):
      sched: Rename a misleading variable in build_overlap_sched_groups()
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/DMA-API.txt b/Documentation/DMA-API.txt</span>
<span class="p_header">index 52088408668a..8a320ab1f43d 100644</span>
<span class="p_header">--- a/Documentation/DMA-API.txt</span>
<span class="p_header">+++ b/Documentation/DMA-API.txt</span>
<span class="p_chunk">@@ -691,7 +691,7 @@</span> <span class="p_context"> of preallocated entries is defined per architecture. If it is too low for you</span>
 boot with &#39;dma_debug_entries=&lt;your_desired_number&gt;&#39; to overwrite the
 architectural default.
 
<span class="p_del">-void debug_dmap_mapping_error(struct device *dev, dma_addr_t dma_addr);</span>
<span class="p_add">+void debug_dma_mapping_error(struct device *dev, dma_addr_t dma_addr);</span>
 
 dma-debug interface debug_dma_mapping_error() to debug drivers that fail
 to check DMA mapping errors on addresses returned by dma_map_single() and
<span class="p_header">diff --git a/Documentation/cgroups/cpusets.txt b/Documentation/cgroups/cpusets.txt</span>
<span class="p_header">index 7740038d82bc..3c94ff3f9693 100644</span>
<span class="p_header">--- a/Documentation/cgroups/cpusets.txt</span>
<span class="p_header">+++ b/Documentation/cgroups/cpusets.txt</span>
<span class="p_chunk">@@ -345,14 +345,14 @@</span> <span class="p_context"> the named feature on.</span>
 The implementation is simple.
 
 Setting the flag &#39;cpuset.memory_spread_page&#39; turns on a per-process flag
<span class="p_del">-PF_SPREAD_PAGE for each task that is in that cpuset or subsequently</span>
<span class="p_add">+PFA_SPREAD_PAGE for each task that is in that cpuset or subsequently</span>
 joins that cpuset.  The page allocation calls for the page cache
<span class="p_del">-is modified to perform an inline check for this PF_SPREAD_PAGE task</span>
<span class="p_add">+is modified to perform an inline check for this PFA_SPREAD_PAGE task</span>
 flag, and if set, a call to a new routine cpuset_mem_spread_node()
 returns the node to prefer for the allocation.
 
 Similarly, setting &#39;cpuset.memory_spread_slab&#39; turns on the flag
<span class="p_del">-PF_SPREAD_SLAB, and appropriately marked slab caches will allocate</span>
<span class="p_add">+PFA_SPREAD_SLAB, and appropriately marked slab caches will allocate</span>
 pages from the node returned by cpuset_mem_spread_node().
 
 The cpuset_mem_spread_node() routine is also simple.  It uses the
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 890d673d9391..f15a93eded21 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 16
<span class="p_del">-SUBLEVEL = 48</span>
<span class="p_add">+SUBLEVEL = 49</span>
 EXTRAVERSION =
 NAME = Museum of Fishiegoodies
 
<span class="p_header">diff --git a/arch/arm/include/asm/xen/events.h b/arch/arm/include/asm/xen/events.h</span>
<span class="p_header">index 8b1f37bfeeec..b7aadab9b0e8 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/xen/events.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/xen/events.h</span>
<span class="p_chunk">@@ -16,7 +16,7 @@</span> <span class="p_context"> static inline int xen_irqs_disabled(struct pt_regs *regs)</span>
 	return raw_irqs_disabled_flags(regs-&gt;ARM_cpsr);
 }
 
<span class="p_del">-#define xchg_xen_ulong(ptr, val) atomic64_xchg(container_of((ptr),	\</span>
<span class="p_add">+#define xchg_xen_ulong(ptr, val) atomic64_xchg(container_of((long long*)(ptr),\</span>
 							    atomic64_t,	\
 							    counter), (val))
 
<span class="p_header">diff --git a/arch/arm/mach-omap2/sleep34xx.S b/arch/arm/mach-omap2/sleep34xx.S</span>
<span class="p_header">index d1dedc8195ed..eafd120b53f1 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/sleep34xx.S</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/sleep34xx.S</span>
<span class="p_chunk">@@ -203,23 +203,8 @@</span> <span class="p_context"> ENTRY(omap34xx_cpu_suspend)</span>
 	 */
 	ldr	r1, kernel_flush
 	blx	r1
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The kernel doesn&#39;t interwork: v7_flush_dcache_all in particluar will</span>
<span class="p_del">-	 * always return in Thumb state when CONFIG_THUMB2_KERNEL is enabled.</span>
<span class="p_del">-	 * This sequence switches back to ARM.  Note that .align may insert a</span>
<span class="p_del">-	 * nop: bx pc needs to be word-aligned in order to work.</span>
<span class="p_del">-	 */</span>
<span class="p_del">- THUMB(	.thumb		)</span>
<span class="p_del">- THUMB(	.align		)</span>
<span class="p_del">- THUMB(	bx	pc	)</span>
<span class="p_del">- THUMB(	nop		)</span>
<span class="p_del">-	.arm</span>
<span class="p_del">-</span>
 	b	omap3_do_wfi
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Local variables</span>
<span class="p_del">- */</span>
<span class="p_add">+ENDPROC(omap34xx_cpu_suspend)</span>
 omap3_do_wfi_sram_addr:
 	.word omap3_do_wfi_sram
 kernel_flush:
<span class="p_chunk">@@ -364,10 +349,7 @@</span> <span class="p_context"> ENTRY(omap3_do_wfi)</span>
  * ===================================
  */
 	ldmfd	sp!, {r4 - r11, pc}	@ restore regs and return
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Local variables</span>
<span class="p_del">- */</span>
<span class="p_add">+ENDPROC(omap3_do_wfi)</span>
 sdrc_power:
 	.word	SDRC_POWER_V
 cm_idlest1_core:
<span class="p_header">diff --git a/arch/arm64/include/asm/elf.h b/arch/arm64/include/asm/elf.h</span>
<span class="p_header">index 922ff638669e..713852f1b1ff 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/elf.h</span>
<span class="p_chunk">@@ -135,7 +135,11 @@</span> <span class="p_context"> extern unsigned long randomize_et_dyn(unsigned long base);</span>
  */
 #define ELF_PLAT_INIT(_r, load_addr)	(_r)-&gt;regs[0] = 0
 
<span class="p_del">-#define SET_PERSONALITY(ex)		clear_thread_flag(TIF_32BIT);</span>
<span class="p_add">+#define SET_PERSONALITY(ex)						\</span>
<span class="p_add">+({									\</span>
<span class="p_add">+	clear_thread_flag(TIF_32BIT);					\</span>
<span class="p_add">+	current-&gt;personality &amp;= ~READ_IMPLIES_EXEC;			\</span>
<span class="p_add">+})</span>
 
 /* update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT entries changes */
 #define ARCH_DLINFO							\
<span class="p_chunk">@@ -183,6 +187,11 @@</span> <span class="p_context"> typedef compat_elf_greg_t		compat_elf_gregset_t[COMPAT_ELF_NGREG];</span>
 					 ((x)-&gt;e_flags &amp; EF_ARM_EABI_MASK))
 
 #define compat_start_thread		compat_start_thread
<span class="p_add">+/*</span>
<span class="p_add">+ * Unlike the native SET_PERSONALITY macro, the compat version inherits</span>
<span class="p_add">+ * READ_IMPLIES_EXEC across a fork() since this is the behaviour on</span>
<span class="p_add">+ * arch/arm/.</span>
<span class="p_add">+ */</span>
 #define COMPAT_SET_PERSONALITY(ex)	set_thread_flag(TIF_32BIT);
 #define COMPAT_ARCH_DLINFO
 extern int aarch32_setup_vectors_page(struct linux_binprm *bprm,
<span class="p_header">diff --git a/arch/arm64/include/asm/ptrace.h b/arch/arm64/include/asm/ptrace.h</span>
<span class="p_header">index 88d6e2436808..300a382ed88f 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/ptrace.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/ptrace.h</span>
<span class="p_chunk">@@ -58,6 +58,8 @@</span> <span class="p_context"></span>
 #define COMPAT_PSR_Z_BIT	0x40000000
 #define COMPAT_PSR_N_BIT	0x80000000
 #define COMPAT_PSR_IT_MASK	0x0600fc00	/* If-Then execution state mask */
<span class="p_add">+#define COMPAT_PSR_GE_MASK	0x000f0000</span>
<span class="p_add">+</span>
 /*
  * These are &#39;magic&#39; values for PTRACE_PEEKUSR that return info about where a
  * process is located in memory.
<span class="p_chunk">@@ -144,35 +146,9 @@</span> <span class="p_context"> static inline unsigned long regs_return_value(struct pt_regs *regs)</span>
 	return regs-&gt;regs[0];
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * Are the current registers suitable for user mode? (used to maintain</span>
<span class="p_del">- * security in signal handlers)</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline int valid_user_regs(struct user_pt_regs *regs)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (user_mode(regs) &amp;&amp; (regs-&gt;pstate &amp; PSR_I_BIT) == 0) {</span>
<span class="p_del">-		regs-&gt;pstate &amp;= ~(PSR_F_BIT | PSR_A_BIT);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* The T bit is reserved for AArch64 */</span>
<span class="p_del">-		if (!(regs-&gt;pstate &amp; PSR_MODE32_BIT))</span>
<span class="p_del">-			regs-&gt;pstate &amp;= ~COMPAT_PSR_T_BIT;</span>
<span class="p_del">-</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Force PSR to something logical...</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	regs-&gt;pstate &amp;= PSR_f | PSR_s | (PSR_x &amp; ~PSR_A_BIT) | \</span>
<span class="p_del">-			COMPAT_PSR_T_BIT | PSR_MODE32_BIT;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!(regs-&gt;pstate &amp; PSR_MODE32_BIT)) {</span>
<span class="p_del">-		regs-&gt;pstate &amp;= ~COMPAT_PSR_T_BIT;</span>
<span class="p_del">-		regs-&gt;pstate |= PSR_MODE_EL0t;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_add">+/* We must avoid circular header include via sched.h */</span>
<span class="p_add">+struct task_struct;</span>
<span class="p_add">+int valid_user_regs(struct user_pt_regs *regs, struct task_struct *task);</span>
 
 #define instruction_pointer(regs)	((unsigned long)(regs)-&gt;pc)
 
<span class="p_header">diff --git a/arch/arm64/kernel/ptrace.c b/arch/arm64/kernel/ptrace.c</span>
<span class="p_header">index 07c5f63a3362..53bdc598d1c1 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/ptrace.c</span>
<span class="p_chunk">@@ -45,6 +45,10 @@</span> <span class="p_context"></span>
 #define CREATE_TRACE_POINTS
 #include &lt;trace/events/syscalls.h&gt;
 
<span class="p_add">+#ifndef DBG_SPSR_SS</span>
<span class="p_add">+#define DBG_SPSR_SS             (1 &lt;&lt; 21)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /*
  * TODO: does not yet catch signals sent when the child dies.
  * in exit.c or in signal.c.
<span class="p_chunk">@@ -501,7 +505,7 @@</span> <span class="p_context"> static int gpr_set(struct task_struct *target, const struct user_regset *regset,</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	if (!valid_user_regs(&amp;newregs))</span>
<span class="p_add">+	if (!valid_user_regs(&amp;newregs, target))</span>
 		return -EINVAL;
 
 	task_pt_regs(target)-&gt;user_regs = newregs;
<span class="p_chunk">@@ -733,7 +737,7 @@</span> <span class="p_context"> static int compat_gpr_set(struct task_struct *target,</span>
 
 	}
 
<span class="p_del">-	if (valid_user_regs(&amp;newregs.user_regs))</span>
<span class="p_add">+	if (valid_user_regs(&amp;newregs.user_regs, target))</span>
 		*task_pt_regs(target) = newregs;
 	else
 		ret = -EINVAL;
<span class="p_chunk">@@ -787,8 +791,10 @@</span> <span class="p_context"> static int compat_vfp_set(struct task_struct *target,</span>
 
 	if (count &amp;&amp; !ret) {
 		ret = get_user(fpscr, (compat_ulong_t *)ubuf);
<span class="p_del">-		uregs-&gt;fpsr = fpscr &amp; VFP_FPSCR_STAT_MASK;</span>
<span class="p_del">-		uregs-&gt;fpcr = fpscr &amp; VFP_FPSCR_CTRL_MASK;</span>
<span class="p_add">+		if (!ret) {</span>
<span class="p_add">+			uregs-&gt;fpsr = fpscr &amp; VFP_FPSCR_STAT_MASK;</span>
<span class="p_add">+			uregs-&gt;fpcr = fpscr &amp; VFP_FPSCR_CTRL_MASK;</span>
<span class="p_add">+		}</span>
 	}
 
 	fpsimd_flush_task_state(target);
<span class="p_chunk">@@ -1136,3 +1142,78 @@</span> <span class="p_context"> asmlinkage void syscall_trace_exit(struct pt_regs *regs)</span>
 	if (test_thread_flag(TIF_SYSCALL_TRACE))
 		tracehook_report_syscall(regs, PTRACE_SYSCALL_EXIT);
 }
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Bits which are always architecturally RES0 per ARM DDI 0487A.h</span>
<span class="p_add">+ * Userspace cannot use these until they have an architectural meaning.</span>
<span class="p_add">+ * We also reserve IL for the kernel; SS is handled dynamically.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define SPSR_EL1_AARCH64_RES0_BITS \</span>
<span class="p_add">+	(GENMASK_ULL(63,32) | GENMASK_ULL(27, 22) | GENMASK_ULL(20, 10) | \</span>
<span class="p_add">+	 GENMASK_ULL(5, 5))</span>
<span class="p_add">+#define SPSR_EL1_AARCH32_RES0_BITS \</span>
<span class="p_add">+	(GENMASK_ULL(63,32) | GENMASK_ULL(24, 22) | GENMASK_ULL(20,20))</span>
<span class="p_add">+</span>
<span class="p_add">+static int valid_compat_regs(struct user_pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	regs-&gt;pstate &amp;= ~SPSR_EL1_AARCH32_RES0_BITS;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Force kernel endianness on user space */</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))</span>
<span class="p_add">+		regs-&gt;pstate |= COMPAT_PSR_E_BIT;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		regs-&gt;pstate &amp;= ~COMPAT_PSR_E_BIT;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (user_mode(regs) &amp;&amp; (regs-&gt;pstate &amp; PSR_MODE32_BIT) &amp;&amp;</span>
<span class="p_add">+	    (regs-&gt;pstate &amp; COMPAT_PSR_A_BIT) == 0 &amp;&amp;</span>
<span class="p_add">+	    (regs-&gt;pstate &amp; COMPAT_PSR_I_BIT) == 0 &amp;&amp;</span>
<span class="p_add">+	    (regs-&gt;pstate &amp; COMPAT_PSR_F_BIT) == 0) {</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Force PSR to a valid 32-bit EL0t, preserving the same bits as</span>
<span class="p_add">+	 * arch/arm.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	regs-&gt;pstate &amp;= COMPAT_PSR_N_BIT | COMPAT_PSR_Z_BIT |</span>
<span class="p_add">+			COMPAT_PSR_C_BIT | COMPAT_PSR_V_BIT |</span>
<span class="p_add">+			COMPAT_PSR_Q_BIT | COMPAT_PSR_IT_MASK |</span>
<span class="p_add">+			COMPAT_PSR_GE_MASK | COMPAT_PSR_E_BIT |</span>
<span class="p_add">+			COMPAT_PSR_T_BIT;</span>
<span class="p_add">+	regs-&gt;pstate |= PSR_MODE32_BIT;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int valid_native_regs(struct user_pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	regs-&gt;pstate &amp;= ~SPSR_EL1_AARCH64_RES0_BITS;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (user_mode(regs) &amp;&amp; !(regs-&gt;pstate &amp; PSR_MODE32_BIT) &amp;&amp;</span>
<span class="p_add">+	    (regs-&gt;pstate &amp; PSR_D_BIT) == 0 &amp;&amp;</span>
<span class="p_add">+	    (regs-&gt;pstate &amp; PSR_A_BIT) == 0 &amp;&amp;</span>
<span class="p_add">+	    (regs-&gt;pstate &amp; PSR_I_BIT) == 0 &amp;&amp;</span>
<span class="p_add">+	    (regs-&gt;pstate &amp; PSR_F_BIT) == 0) {</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Force PSR to a valid 64-bit EL0t */</span>
<span class="p_add">+	regs-&gt;pstate &amp;= PSR_N_BIT | PSR_Z_BIT | PSR_C_BIT | PSR_V_BIT;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Are the current registers suitable for user mode? (used to maintain</span>
<span class="p_add">+ * security in signal handlers)</span>
<span class="p_add">+ */</span>
<span class="p_add">+int valid_user_regs(struct user_pt_regs *regs, struct task_struct *task)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!test_tsk_thread_flag(task, TIF_SINGLESTEP))</span>
<span class="p_add">+		regs-&gt;pstate &amp;= ~DBG_SPSR_SS;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_compat_thread(task_thread_info(task)))</span>
<span class="p_add">+		return valid_compat_regs(regs);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return valid_native_regs(regs);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/arm64/kernel/signal.c b/arch/arm64/kernel/signal.c</span>
<span class="p_header">index 6357b9c6c90e..d1ae7c217ba9 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/signal.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/signal.c</span>
<span class="p_chunk">@@ -115,7 +115,7 @@</span> <span class="p_context"> static int restore_sigframe(struct pt_regs *regs,</span>
 	 */
 	regs-&gt;syscallno = ~0UL;
 
<span class="p_del">-	err |= !valid_user_regs(&amp;regs-&gt;user_regs);</span>
<span class="p_add">+	err |= !valid_user_regs(&amp;regs-&gt;user_regs, current);</span>
 
 	if (err == 0) {
 		struct fpsimd_context *fpsimd_ctx =
<span class="p_chunk">@@ -322,7 +322,7 @@</span> <span class="p_context"> static void handle_signal(unsigned long sig, struct k_sigaction *ka,</span>
 	/*
 	 * Check that the resulting registers are actually sane.
 	 */
<span class="p_del">-	ret |= !valid_user_regs(&amp;regs-&gt;user_regs);</span>
<span class="p_add">+	ret |= !valid_user_regs(&amp;regs-&gt;user_regs, current);</span>
 
 	if (ret != 0) {
 		force_sigsegv(sig, tsk);
<span class="p_header">diff --git a/arch/arm64/kernel/signal32.c b/arch/arm64/kernel/signal32.c</span>
<span class="p_header">index e3ac8f0c0fc7..03520c650701 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/signal32.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/signal32.c</span>
<span class="p_chunk">@@ -350,7 +350,7 @@</span> <span class="p_context"> static int compat_restore_sigframe(struct pt_regs *regs,</span>
 	 */
 	regs-&gt;syscallno = ~0UL;
 
<span class="p_del">-	err |= !valid_user_regs(&amp;regs-&gt;user_regs);</span>
<span class="p_add">+	err |= !valid_user_regs(&amp;regs-&gt;user_regs, current);</span>
 
 	aux = (struct compat_aux_sigframe __user *) sf-&gt;uc.uc_regspace;
 	if (err == 0)
<span class="p_header">diff --git a/arch/m32r/include/asm/io.h b/arch/m32r/include/asm/io.h</span>
<span class="p_header">index 4010f1fc5b65..cea944caca61 100644</span>
<span class="p_header">--- a/arch/m32r/include/asm/io.h</span>
<span class="p_header">+++ b/arch/m32r/include/asm/io.h</span>
<span class="p_chunk">@@ -67,6 +67,7 @@</span> <span class="p_context"> static inline void __iomem *ioremap(unsigned long offset, unsigned long size)</span>
 
 extern void iounmap(volatile void __iomem *addr);
 #define ioremap_nocache(off,size) ioremap(off,size)
<span class="p_add">+#define ioremap_wc ioremap_nocache</span>
 
 /*
  * IO bus memory addresses are also 1:1 with the physical address
<span class="p_chunk">@@ -162,13 +163,21 @@</span> <span class="p_context"> static inline void _writel(unsigned long l, unsigned long addr)</span>
 #define __raw_writew writew
 #define __raw_writel writel
 
<span class="p_del">-#define ioread8 read</span>
<span class="p_add">+#define ioread8 readb</span>
 #define ioread16 readw
 #define ioread32 readl
 #define iowrite8 writeb
 #define iowrite16 writew
 #define iowrite32 writel
 
<span class="p_add">+#define ioread8_rep(p, dst, count) insb((unsigned long)(p), (dst), (count))</span>
<span class="p_add">+#define ioread16_rep(p, dst, count) insw((unsigned long)(p), (dst), (count))</span>
<span class="p_add">+#define ioread32_rep(p, dst, count) insl((unsigned long)(p), (dst), (count))</span>
<span class="p_add">+</span>
<span class="p_add">+#define iowrite8_rep(p, src, count) outsb((unsigned long)(p), (src), (count))</span>
<span class="p_add">+#define iowrite16_rep(p, src, count) outsw((unsigned long)(p), (src), (count))</span>
<span class="p_add">+#define iowrite32_rep(p, src, count) outsl((unsigned long)(p), (src), (count))</span>
<span class="p_add">+</span>
 #define mmiowb()
 
 #define flush_write_buffers() do { } while (0)  /* M32R_FIXME */
<span class="p_header">diff --git a/arch/mips/include/asm/branch.h b/arch/mips/include/asm/branch.h</span>
<span class="p_header">index de781cf54bc7..da80878f2c0d 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/branch.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/branch.h</span>
<span class="p_chunk">@@ -74,10 +74,7 @@</span> <span class="p_context"> static inline int compute_return_epc(struct pt_regs *regs)</span>
 			return __microMIPS_compute_return_epc(regs);
 		if (cpu_has_mips16)
 			return __MIPS16e_compute_return_epc(regs);
<span class="p_del">-		return regs-&gt;cp0_epc;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!delay_slot(regs)) {</span>
<span class="p_add">+	} else if (!delay_slot(regs)) {</span>
 		regs-&gt;cp0_epc += 4;
 		return 0;
 	}
<span class="p_header">diff --git a/arch/mips/include/asm/kvm_host.h b/arch/mips/include/asm/kvm_host.h</span>
<span class="p_header">index f8cdc274173a..e31b2461cf40 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -378,6 +378,7 @@</span> <span class="p_context"> struct kvm_mips_tlb {</span>
 #define KVM_MIPS_GUEST_TLB_SIZE	64
 struct kvm_vcpu_arch {
 	void *host_ebase, *guest_ebase;
<span class="p_add">+	int (*vcpu_run)(struct kvm_run *run, struct kvm_vcpu *vcpu);</span>
 	unsigned long host_stack;
 	unsigned long host_gp;
 
<span class="p_header">diff --git a/arch/mips/include/asm/processor.h b/arch/mips/include/asm/processor.h</span>
<span class="p_header">index ad70cba8daff..3a05491b851e 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/processor.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/processor.h</span>
<span class="p_chunk">@@ -51,7 +51,7 @@</span> <span class="p_context"> extern unsigned int vced_count, vcei_count;</span>
  * User space process size: 2GB. This is hardcoded into a few places,
  * so don&#39;t change it unless you know what you are doing.
  */
<span class="p_del">-#define TASK_SIZE	0x7fff8000UL</span>
<span class="p_add">+#define TASK_SIZE	0x80000000UL</span>
 #endif
 
 #ifdef __KERNEL__
<span class="p_header">diff --git a/arch/mips/kernel/branch.c b/arch/mips/kernel/branch.c</span>
<span class="p_header">index 4d7d99d601cc..5d34d60919f1 100644</span>
<span class="p_header">--- a/arch/mips/kernel/branch.c</span>
<span class="p_header">+++ b/arch/mips/kernel/branch.c</span>
<span class="p_chunk">@@ -396,7 +396,7 @@</span> <span class="p_context"> int __MIPS16e_compute_return_epc(struct pt_regs *regs)</span>
  *
  * @regs:	Pointer to pt_regs
  * @insn:	branch instruction to decode
<span class="p_del">- * @returns:	-EFAULT on error and forces SIGBUS, and on success</span>
<span class="p_add">+ * @returns:	-EFAULT on error and forces SIGILL, and on success</span>
  *		returns 0 or BRANCH_LIKELY_TAKEN as appropriate after
  *		evaluating the branch.
  */
<span class="p_chunk">@@ -493,6 +493,7 @@</span> <span class="p_context"> int __compute_return_epc_for_insn(struct pt_regs *regs,</span>
 	/*
 	 * These are unconditional and in j_format.
 	 */
<span class="p_add">+	case jalx_op:</span>
 	case jal_op:
 		regs-&gt;regs[31] = regs-&gt;cp0_epc + 8;
 	case j_op:
<span class="p_chunk">@@ -632,8 +633,9 @@</span> <span class="p_context"> int __compute_return_epc_for_insn(struct pt_regs *regs,</span>
 	return ret;
 
 sigill:
<span class="p_del">-	printk(&quot;%s: DSP branch but not DSP ASE - sending SIGBUS.\n&quot;, current-&gt;comm);</span>
<span class="p_del">-	force_sig(SIGBUS, current);</span>
<span class="p_add">+	pr_info(&quot;%s: DSP branch but not DSP ASE - sending SIGILL.\n&quot;,</span>
<span class="p_add">+		current-&gt;comm);</span>
<span class="p_add">+	force_sig(SIGILL, current);</span>
 	return -EFAULT;
 }
 EXPORT_SYMBOL_GPL(__compute_return_epc_for_insn);
<span class="p_header">diff --git a/arch/mips/kernel/module-rela.c b/arch/mips/kernel/module-rela.c</span>
<span class="p_header">index 2b70723071c3..9083d63b765c 100644</span>
<span class="p_header">--- a/arch/mips/kernel/module-rela.c</span>
<span class="p_header">+++ b/arch/mips/kernel/module-rela.c</span>
<span class="p_chunk">@@ -109,9 +109,10 @@</span> <span class="p_context"> int apply_relocate_add(Elf_Shdr *sechdrs, const char *strtab,</span>
 		       struct module *me)
 {
 	Elf_Mips_Rela *rel = (void *) sechdrs[relsec].sh_addr;
<span class="p_add">+	int (*handler)(struct module *me, u32 *location, Elf_Addr v);</span>
 	Elf_Sym *sym;
 	u32 *location;
<span class="p_del">-	unsigned int i;</span>
<span class="p_add">+	unsigned int i, type;</span>
 	Elf_Addr v;
 	int res;
 
<span class="p_chunk">@@ -134,9 +135,21 @@</span> <span class="p_context"> int apply_relocate_add(Elf_Shdr *sechdrs, const char *strtab,</span>
 			return -ENOENT;
 		}
 
<span class="p_del">-		v = sym-&gt;st_value + rel[i].r_addend;</span>
<span class="p_add">+		type = ELF_MIPS_R_TYPE(rel[i]);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (type &lt; ARRAY_SIZE(reloc_handlers_rela))</span>
<span class="p_add">+			handler = reloc_handlers_rela[type];</span>
<span class="p_add">+		else</span>
<span class="p_add">+			handler = NULL;</span>
 
<span class="p_del">-		res = reloc_handlers_rela[ELF_MIPS_R_TYPE(rel[i])](me, location, v);</span>
<span class="p_add">+		if (!handler) {</span>
<span class="p_add">+			pr_err(&quot;%s: Unknown relocation type %u\n&quot;,</span>
<span class="p_add">+			       me-&gt;name, type);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		v = sym-&gt;st_value + rel[i].r_addend;</span>
<span class="p_add">+		res = handler(me, location, v);</span>
 		if (res)
 			return res;
 	}
<span class="p_header">diff --git a/arch/mips/kernel/module.c b/arch/mips/kernel/module.c</span>
<span class="p_header">index 2a52568dbcd6..cd4c8412869d 100644</span>
<span class="p_header">--- a/arch/mips/kernel/module.c</span>
<span class="p_header">+++ b/arch/mips/kernel/module.c</span>
<span class="p_chunk">@@ -197,11 +197,12 @@</span> <span class="p_context"> int apply_relocate(Elf_Shdr *sechdrs, const char *strtab,</span>
 		   struct module *me)
 {
 	Elf_Mips_Rel *rel = (void *) sechdrs[relsec].sh_addr;
<span class="p_add">+	int (*handler)(struct module *me, u32 *location, Elf_Addr v);</span>
 	Elf_Sym *sym;
 	u32 *location;
<span class="p_del">-	unsigned int i;</span>
<span class="p_add">+	unsigned int i, type;</span>
 	Elf_Addr v;
<span class="p_del">-	int res;</span>
<span class="p_add">+	int err = 0;</span>
 
 	pr_debug(&quot;Applying relocate section %u to %u\n&quot;, relsec,
 	       sechdrs[relsec].sh_info);
<span class="p_chunk">@@ -220,30 +221,46 @@</span> <span class="p_context"> int apply_relocate(Elf_Shdr *sechdrs, const char *strtab,</span>
 				continue;
 			printk(KERN_WARNING &quot;%s: Unknown symbol %s\n&quot;,
 			       me-&gt;name, strtab + sym-&gt;st_name);
<span class="p_del">-			return -ENOENT;</span>
<span class="p_add">+			err = -ENOENT;</span>
<span class="p_add">+			goto out;</span>
 		}
 
<span class="p_del">-		v = sym-&gt;st_value;</span>
<span class="p_add">+		type = ELF_MIPS_R_TYPE(rel[i]);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (type &lt; ARRAY_SIZE(reloc_handlers_rel))</span>
<span class="p_add">+			handler = reloc_handlers_rel[type];</span>
<span class="p_add">+		else</span>
<span class="p_add">+			handler = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!handler) {</span>
<span class="p_add">+			pr_err(&quot;%s: Unknown relocation type %u\n&quot;,</span>
<span class="p_add">+			       me-&gt;name, type);</span>
<span class="p_add">+			err = -EINVAL;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-		res = reloc_handlers_rel[ELF_MIPS_R_TYPE(rel[i])](me, location, v);</span>
<span class="p_del">-		if (res)</span>
<span class="p_del">-			return res;</span>
<span class="p_add">+		v = sym-&gt;st_value;</span>
<span class="p_add">+		err = handler(me, location, v);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto out;</span>
 	}
 
<span class="p_add">+out:</span>
 	/*
<span class="p_del">-	 * Normally the hi16 list should be deallocated at this point.	A</span>
<span class="p_add">+	 * Normally the hi16 list should be deallocated at this point. A</span>
 	 * malformed binary however could contain a series of R_MIPS_HI16
<span class="p_del">-	 * relocations not followed by a R_MIPS_LO16 relocation.  In that</span>
<span class="p_del">-	 * case, free up the list and return an error.</span>
<span class="p_add">+	 * relocations not followed by a R_MIPS_LO16 relocation, or if we hit</span>
<span class="p_add">+	 * an error processing a reloc we might have gotten here before</span>
<span class="p_add">+	 * reaching the R_MIPS_LO16. In either case, free up the list and</span>
<span class="p_add">+	 * return an error.</span>
 	 */
 	if (me-&gt;arch.r_mips_hi16_list) {
 		free_relocation_chain(me-&gt;arch.r_mips_hi16_list);
 		me-&gt;arch.r_mips_hi16_list = NULL;
<span class="p_del">-</span>
<span class="p_del">-		return -ENOEXEC;</span>
<span class="p_add">+		err = err ?: -ENOEXEC;</span>
 	}
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return err;</span>
 }
 
 /* Given an address, look for it in the module exception tables. */
<span class="p_header">diff --git a/arch/mips/kernel/ptrace.c b/arch/mips/kernel/ptrace.c</span>
<span class="p_header">index aae71198b515..cdb8cc7800a2 100644</span>
<span class="p_header">--- a/arch/mips/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/mips/kernel/ptrace.c</span>
<span class="p_chunk">@@ -804,7 +804,7 @@</span> <span class="p_context"> asmlinkage void syscall_trace_leave(struct pt_regs *regs)</span>
 	audit_syscall_exit(regs);
 
 	if (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))
<span class="p_del">-		trace_sys_exit(regs, regs-&gt;regs[2]);</span>
<span class="p_add">+		trace_sys_exit(regs, regs_return_value(regs));</span>
 
 	if (test_thread_flag(TIF_SYSCALL_TRACE))
 		tracehook_report_syscall_exit(regs, 0);
<span class="p_header">diff --git a/arch/mips/kernel/scall32-o32.S b/arch/mips/kernel/scall32-o32.S</span>
<span class="p_header">index 3245474f19d5..bc1d0c710269 100644</span>
<span class="p_header">--- a/arch/mips/kernel/scall32-o32.S</span>
<span class="p_header">+++ b/arch/mips/kernel/scall32-o32.S</span>
<span class="p_chunk">@@ -363,7 +363,7 @@</span> <span class="p_context"> EXPORT(sys_call_table)</span>
 	PTR	sys_writev
 	PTR	sys_cacheflush
 	PTR	sys_cachectl
<span class="p_del">-	PTR	sys_sysmips</span>
<span class="p_add">+	PTR	__sys_sysmips</span>
 	PTR	sys_ni_syscall			/* 4150 */
 	PTR	sys_getsid
 	PTR	sys_fdatasync
<span class="p_header">diff --git a/arch/mips/kernel/scall64-64.S b/arch/mips/kernel/scall64-64.S</span>
<span class="p_header">index b204352a7d56..45c539b085e2 100644</span>
<span class="p_header">--- a/arch/mips/kernel/scall64-64.S</span>
<span class="p_header">+++ b/arch/mips/kernel/scall64-64.S</span>
<span class="p_chunk">@@ -318,7 +318,7 @@</span> <span class="p_context"> EXPORT(sys_call_table)</span>
 	PTR	sys_sched_getaffinity
 	PTR	sys_cacheflush
 	PTR	sys_cachectl
<span class="p_del">-	PTR	sys_sysmips</span>
<span class="p_add">+	PTR	__sys_sysmips</span>
 	PTR	sys_io_setup			/* 5200 */
 	PTR	sys_io_destroy
 	PTR	sys_io_getevents
<span class="p_header">diff --git a/arch/mips/kernel/scall64-n32.S b/arch/mips/kernel/scall64-n32.S</span>
<span class="p_header">index 28a2cb2c6c9b..e1eeb09fc2eb 100644</span>
<span class="p_header">--- a/arch/mips/kernel/scall64-n32.S</span>
<span class="p_header">+++ b/arch/mips/kernel/scall64-n32.S</span>
<span class="p_chunk">@@ -307,7 +307,7 @@</span> <span class="p_context"> EXPORT(sysn32_call_table)</span>
 	PTR	compat_sys_sched_getaffinity
 	PTR	sys_cacheflush
 	PTR	sys_cachectl
<span class="p_del">-	PTR	sys_sysmips</span>
<span class="p_add">+	PTR	__sys_sysmips</span>
 	PTR	compat_sys_io_setup			/* 6200 */
 	PTR	sys_io_destroy
 	PTR	compat_sys_io_getevents
<span class="p_header">diff --git a/arch/mips/kernel/scall64-o32.S b/arch/mips/kernel/scall64-o32.S</span>
<span class="p_header">index 3b726b9229b4..37361502d63b 100644</span>
<span class="p_header">--- a/arch/mips/kernel/scall64-o32.S</span>
<span class="p_header">+++ b/arch/mips/kernel/scall64-o32.S</span>
<span class="p_chunk">@@ -358,7 +358,7 @@</span> <span class="p_context"> EXPORT(sys32_call_table)</span>
 	PTR	compat_sys_writev
 	PTR	sys_cacheflush
 	PTR	sys_cachectl
<span class="p_del">-	PTR	sys_sysmips</span>
<span class="p_add">+	PTR	__sys_sysmips</span>
 	PTR	sys_ni_syscall			/* 4150 */
 	PTR	sys_getsid
 	PTR	sys_fdatasync
<span class="p_header">diff --git a/arch/mips/kernel/syscall.c b/arch/mips/kernel/syscall.c</span>
<span class="p_header">index 4a4f9dda5658..1c864e20156f 100644</span>
<span class="p_header">--- a/arch/mips/kernel/syscall.c</span>
<span class="p_header">+++ b/arch/mips/kernel/syscall.c</span>
<span class="p_chunk">@@ -28,6 +28,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/elf.h&gt;
 
 #include &lt;asm/asm.h&gt;
<span class="p_add">+#include &lt;asm/asm-eva.h&gt;</span>
 #include &lt;asm/branch.h&gt;
 #include &lt;asm/cachectl.h&gt;
 #include &lt;asm/cacheflush.h&gt;
<span class="p_chunk">@@ -137,10 +138,12 @@</span> <span class="p_context"> static inline int mips_atomic_set(unsigned long addr, unsigned long new)</span>
 		__asm__ __volatile__ (
 		&quot;	.set	arch=r4000				\n&quot;
 		&quot;	li	%[err], 0				\n&quot;
<span class="p_del">-		&quot;1:	ll	%[old], (%[addr])			\n&quot;</span>
<span class="p_add">+		&quot;1:							\n&quot;</span>
<span class="p_add">+		user_ll(&quot;%[old]&quot;, &quot;(%[addr])&quot;)</span>
 		&quot;	move	%[tmp], %[new]				\n&quot;
<span class="p_del">-		&quot;2:	sc	%[tmp], (%[addr])			\n&quot;</span>
<span class="p_del">-		&quot;	bnez	%[tmp], 4f				\n&quot;</span>
<span class="p_add">+		&quot;2:							\n&quot;</span>
<span class="p_add">+		user_sc(&quot;%[tmp]&quot;, &quot;(%[addr])&quot;)</span>
<span class="p_add">+		&quot;	beqz	%[tmp], 4f				\n&quot;</span>
 		&quot;3:							\n&quot;
 		&quot;	.subsection 2					\n&quot;
 		&quot;4:	b	1b					\n&quot;
<span class="p_chunk">@@ -197,6 +200,12 @@</span> <span class="p_context"> static inline int mips_atomic_set(unsigned long addr, unsigned long new)</span>
 	unreachable();
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * mips_atomic_set() normally returns directly via syscall_exit potentially</span>
<span class="p_add">+ * clobbering static registers, so be sure to preserve them.</span>
<span class="p_add">+ */</span>
<span class="p_add">+save_static_function(sys_sysmips);</span>
<span class="p_add">+</span>
 SYSCALL_DEFINE3(sysmips, long, cmd, long, arg1, long, arg2)
 {
 	switch (cmd) {
<span class="p_header">diff --git a/arch/mips/kvm/kvm_locore.S b/arch/mips/kvm/kvm_locore.S</span>
<span class="p_header">index fc24acb3a837..a397c959a391 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_locore.S</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_locore.S</span>
<span class="p_chunk">@@ -229,6 +229,7 @@</span> <span class="p_context"> FEXPORT(__kvm_mips_load_k0k1)</span>
 
 	/* Jump to guest */
 	eret
<span class="p_add">+EXPORT(__kvm_mips_vcpu_run_end)</span>
 
 VECTOR(MIPSX(exception), unknown)
 /*
<span class="p_header">diff --git a/arch/mips/kvm/kvm_mips.c b/arch/mips/kvm/kvm_mips.c</span>
<span class="p_header">index 263c6c1c9bbb..64f14f6bca52 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_mips.c</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_mips.c</span>
<span class="p_chunk">@@ -342,6 +342,15 @@</span> <span class="p_context"> struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm, unsigned int id)</span>
 	memcpy(gebase + offset, mips32_GuestException,
 	       mips32_GuestExceptionEnd - mips32_GuestException);
 
<span class="p_add">+#ifdef MODULE</span>
<span class="p_add">+	offset += mips32_GuestExceptionEnd - mips32_GuestException;</span>
<span class="p_add">+	memcpy(gebase + offset, (char *)__kvm_mips_vcpu_run,</span>
<span class="p_add">+	       __kvm_mips_vcpu_run_end - (char *)__kvm_mips_vcpu_run);</span>
<span class="p_add">+	vcpu-&gt;arch.vcpu_run = gebase + offset;</span>
<span class="p_add">+#else</span>
<span class="p_add">+	vcpu-&gt;arch.vcpu_run = __kvm_mips_vcpu_run;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	/* Invalidate the icache for these ranges */
 	flush_icache_range((unsigned long)gebase,
 			   (unsigned long)gebase + ALIGN(size, PAGE_SIZE));
<span class="p_chunk">@@ -426,7 +435,7 @@</span> <span class="p_context"> int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 
 	kvm_guest_enter();
 
<span class="p_del">-	r = __kvm_mips_vcpu_run(run, vcpu);</span>
<span class="p_add">+	r = vcpu-&gt;arch.vcpu_run(run, vcpu);</span>
 
 	kvm_guest_exit();
 	local_irq_enable();
<span class="p_header">diff --git a/arch/mips/kvm/kvm_mips_int.h b/arch/mips/kvm/kvm_mips_int.h</span>
<span class="p_header">index 20da7d29eede..bf41ea36210e 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_mips_int.h</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_mips_int.h</span>
<span class="p_chunk">@@ -27,6 +27,8 @@</span> <span class="p_context"></span>
 #define MIPS_EXC_MAX                12
 /* XXXSL More to follow */
 
<span class="p_add">+extern char __kvm_mips_vcpu_run_end[];</span>
<span class="p_add">+</span>
 #define C_TI        (_ULCAST_(1) &lt;&lt; 30)
 
 #define KVM_MIPS_IRQ_DELIVER_ALL_AT_ONCE (0)
<span class="p_header">diff --git a/arch/mips/math-emu/cp1emu.c b/arch/mips/math-emu/cp1emu.c</span>
<span class="p_header">index 22a2e15bd91b..bd0ad058c135 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/cp1emu.c</span>
<span class="p_header">+++ b/arch/mips/math-emu/cp1emu.c</span>
<span class="p_chunk">@@ -1856,6 +1856,35 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 	return 0;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Emulate FPU instructions.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * If we use FPU hardware, then we have been typically called to handle</span>
<span class="p_add">+ * an unimplemented operation, such as where an operand is a NaN or</span>
<span class="p_add">+ * denormalized.  In that case exit the emulation loop after a single</span>
<span class="p_add">+ * iteration so as to let hardware execute any subsequent instructions.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * If we have no FPU hardware or it has been disabled, then continue</span>
<span class="p_add">+ * emulating floating-point instructions until one of these conditions</span>
<span class="p_add">+ * has occurred:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * - a non-FPU instruction has been encountered,</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * - an attempt to emulate has ended with a signal,</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * - the ISA mode has been switched.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * We need to terminate the emulation loop if we got switched to the</span>
<span class="p_add">+ * MIPS16 mode, whether supported or not, so that we do not attempt</span>
<span class="p_add">+ * to emulate a MIPS16 instruction as a regular MIPS FPU instruction.</span>
<span class="p_add">+ * Similarly if we got switched to the microMIPS mode and only the</span>
<span class="p_add">+ * regular MIPS mode is supported, so that we do not attempt to emulate</span>
<span class="p_add">+ * a microMIPS instruction as a regular MIPS FPU instruction.  Or if</span>
<span class="p_add">+ * we got switched to the regular MIPS mode and only the microMIPS mode</span>
<span class="p_add">+ * is supported, so that we do not attempt to emulate a regular MIPS</span>
<span class="p_add">+ * instruction that should cause an Address Error exception instead.</span>
<span class="p_add">+ * For simplicity we always terminate upon an ISA mode switch.</span>
<span class="p_add">+ */</span>
 int fpu_emulator_cop1Handler(struct pt_regs *xcp, struct mips_fpu_struct *ctx,
 	int has_fpu, void *__user *fault_addr)
 {
<span class="p_chunk">@@ -1943,6 +1972,15 @@</span> <span class="p_context"> int fpu_emulator_cop1Handler(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 			break;
 		if (sig)
 			break;
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We have to check for the ISA bit explicitly here,</span>
<span class="p_add">+		 * because `get_isa16_mode&#39; may return 0 if support</span>
<span class="p_add">+		 * for code compression has been globally disabled,</span>
<span class="p_add">+		 * or otherwise we may produce the wrong signal or</span>
<span class="p_add">+		 * even proceed successfully where we must not.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if ((xcp-&gt;cp0_epc ^ prevepc) &amp; 0x1)</span>
<span class="p_add">+			break;</span>
 
 		cond_resched();
 	} while (xcp-&gt;cp0_epc &gt; prevepc);
<span class="p_header">diff --git a/arch/parisc/include/asm/dma-mapping.h b/arch/parisc/include/asm/dma-mapping.h</span>
<span class="p_header">index d0eae5f2bd87..4fb62add2636 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/dma-mapping.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/dma-mapping.h</span>
<span class="p_chunk">@@ -39,6 +39,8 @@</span> <span class="p_context"> struct hppa_dma_ops {</span>
 ** flush/purge and allocate &quot;regular&quot; cacheable pages for everything.
 */
 
<span class="p_add">+#define DMA_ERROR_CODE	(~(dma_addr_t)0)</span>
<span class="p_add">+</span>
 #ifdef CONFIG_PA11
 extern struct hppa_dma_ops pcxl_dma_ops;
 extern struct hppa_dma_ops pcx_dma_ops;
<span class="p_chunk">@@ -209,12 +211,13 @@</span> <span class="p_context"> parisc_walk_tree(struct device *dev)</span>
 			break;
 		}
 	}
<span class="p_del">-	BUG_ON(!dev-&gt;platform_data);</span>
 	return dev-&gt;platform_data;
 }
<span class="p_del">-		</span>
<span class="p_del">-#define GET_IOC(dev) (HBA_DATA(parisc_walk_tree(dev))-&gt;iommu)</span>
<span class="p_del">-	</span>
<span class="p_add">+</span>
<span class="p_add">+#define GET_IOC(dev) ({					\</span>
<span class="p_add">+	void *__pdata = parisc_walk_tree(dev);		\</span>
<span class="p_add">+	__pdata ? HBA_DATA(__pdata)-&gt;iommu : NULL;	\</span>
<span class="p_add">+})</span>
 
 #ifdef CONFIG_IOMMU_CCIO
 struct parisc_device;
<span class="p_header">diff --git a/arch/parisc/kernel/syscall_table.S b/arch/parisc/kernel/syscall_table.S</span>
<span class="p_header">index 3cd1c435c306..cd734c18de6b 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/syscall_table.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/syscall_table.S</span>
<span class="p_chunk">@@ -361,7 +361,7 @@</span> <span class="p_context"></span>
 	ENTRY_SAME(ni_syscall)	/* 263: reserved for vserver */
 	ENTRY_SAME(add_key)
 	ENTRY_SAME(request_key)		/* 265 */
<span class="p_del">-	ENTRY_SAME(keyctl)</span>
<span class="p_add">+	ENTRY_COMP(keyctl)</span>
 	ENTRY_SAME(ioprio_set)
 	ENTRY_SAME(ioprio_get)
 	ENTRY_SAME(inotify_init)
<span class="p_header">diff --git a/arch/parisc/mm/fault.c b/arch/parisc/mm/fault.c</span>
<span class="p_header">index 50d64a7fc672..3b7c02f9b726 100644</span>
<span class="p_header">--- a/arch/parisc/mm/fault.c</span>
<span class="p_header">+++ b/arch/parisc/mm/fault.c</span>
<span class="p_chunk">@@ -303,7 +303,7 @@</span> <span class="p_context"> void do_page_fault(struct pt_regs *regs, unsigned long code,</span>
 		case 15:	/* Data TLB miss fault/Data page fault */
 			/* send SIGSEGV when outside of vma */
 			if (!vma ||
<span class="p_del">-			    address &lt; vma-&gt;vm_start || address &gt; vma-&gt;vm_end) {</span>
<span class="p_add">+			    address &lt; vma-&gt;vm_start || address &gt;= vma-&gt;vm_end) {</span>
 				si.si_signo = SIGSEGV;
 				si.si_code = SEGV_MAPERR;
 				break;
<span class="p_header">diff --git a/arch/powerpc/include/asm/atomic.h b/arch/powerpc/include/asm/atomic.h</span>
<span class="p_header">index 28992d012926..f7f16e9852d8 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/atomic.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/atomic.h</span>
<span class="p_chunk">@@ -497,7 +497,7 @@</span> <span class="p_context"> static __inline__ int atomic64_add_unless(atomic64_t *v, long a, long u)</span>
  * Atomically increments @v by 1, so long as @v is non-zero.
  * Returns non-zero if @v was non-zero, and zero otherwise.
  */
<span class="p_del">-static __inline__ long atomic64_inc_not_zero(atomic64_t *v)</span>
<span class="p_add">+static __inline__ int atomic64_inc_not_zero(atomic64_t *v)</span>
 {
 	long t1, t2;
 
<span class="p_chunk">@@ -516,7 +516,7 @@</span> <span class="p_context"> static __inline__ long atomic64_inc_not_zero(atomic64_t *v)</span>
 	: &quot;r&quot; (&amp;v-&gt;counter)
 	: &quot;cc&quot;, &quot;xer&quot;, &quot;memory&quot;);
 
<span class="p_del">-	return t1;</span>
<span class="p_add">+	return t1 != 0;</span>
 }
 
 #endif /* __powerpc64__ */
<span class="p_header">diff --git a/arch/powerpc/include/asm/reg.h b/arch/powerpc/include/asm/reg.h</span>
<span class="p_header">index e0b1b8482735..ab6dd3e5f176 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/reg.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/reg.h</span>
<span class="p_chunk">@@ -1226,7 +1226,7 @@</span> <span class="p_context"></span>
 				&quot;	.llong 0\n&quot;			\
 				&quot;.previous&quot;				\
 			: &quot;=r&quot; (rval) \
<span class="p_del">-			: &quot;i&quot; (CPU_FTR_CELL_TB_BUG), &quot;i&quot; (SPRN_TBRL)); \</span>
<span class="p_add">+			: &quot;i&quot; (CPU_FTR_CELL_TB_BUG), &quot;i&quot; (SPRN_TBRL) : &quot;cr0&quot;); \</span>
 			rval;})
 #else
 #define mftb()		({unsigned long rval;	\
<span class="p_header">diff --git a/arch/powerpc/lib/sstep.c b/arch/powerpc/lib/sstep.c</span>
<span class="p_header">index 5c09f365c842..74f81c4d7cb6 100644</span>
<span class="p_header">--- a/arch/powerpc/lib/sstep.c</span>
<span class="p_header">+++ b/arch/powerpc/lib/sstep.c</span>
<span class="p_chunk">@@ -938,6 +938,19 @@</span> <span class="p_context"> int __kprobes emulate_step(struct pt_regs *regs, unsigned int instr)</span>
 			goto instr_done;
 #endif
 		case 19:	/* mfcr */
<span class="p_add">+			if ((instr &gt;&gt; 20) &amp; 1) {</span>
<span class="p_add">+				imm = 0xf0000000UL;</span>
<span class="p_add">+				for (sh = 0; sh &lt; 8; ++sh) {</span>
<span class="p_add">+					if (instr &amp; (0x80000 &gt;&gt; sh)) {</span>
<span class="p_add">+						regs-&gt;gpr[rd] = regs-&gt;ccr &amp; imm;</span>
<span class="p_add">+						break;</span>
<span class="p_add">+					}</span>
<span class="p_add">+					imm &gt;&gt;= 4;</span>
<span class="p_add">+				}</span>
<span class="p_add">+</span>
<span class="p_add">+				goto instr_done;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			regs-&gt;gpr[rd] = regs-&gt;ccr;
 			regs-&gt;gpr[rd] &amp;= 0xffffffffUL;
 			goto instr_done;
<span class="p_header">diff --git a/arch/s390/include/asm/syscall.h b/arch/s390/include/asm/syscall.h</span>
<span class="p_header">index abad78d5b10c..13243715e5ad 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/syscall.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/syscall.h</span>
<span class="p_chunk">@@ -54,7 +54,7 @@</span> <span class="p_context"> static inline void syscall_set_return_value(struct task_struct *task,</span>
 					    struct pt_regs *regs,
 					    int error, long val)
 {
<span class="p_del">-	regs-&gt;gprs[2] = error ? -error : val;</span>
<span class="p_add">+	regs-&gt;gprs[2] = error ? error : val;</span>
 }
 
 static inline void syscall_get_arguments(struct task_struct *task,
<span class="p_chunk">@@ -64,6 +64,12 @@</span> <span class="p_context"> static inline void syscall_get_arguments(struct task_struct *task,</span>
 {
 	unsigned long mask = -1UL;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * No arguments for this syscall, there&#39;s nothing to do.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!n)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	BUG_ON(i + n &gt; 6);
 #ifdef CONFIG_COMPAT
 	if (test_tsk_thread_flag(task, TIF_31BIT))
<span class="p_header">diff --git a/arch/sparc/include/asm/head_64.h b/arch/sparc/include/asm/head_64.h</span>
<span class="p_header">index 10e9dabc4c41..f0700cfeedd7 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/head_64.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/head_64.h</span>
<span class="p_chunk">@@ -15,6 +15,10 @@</span> <span class="p_context"></span>
 
 #define	PTREGS_OFF	(STACK_BIAS + STACKFRAME_SZ)
 
<span class="p_add">+#define	RTRAP_PSTATE		(PSTATE_TSO|PSTATE_PEF|PSTATE_PRIV|PSTATE_IE)</span>
<span class="p_add">+#define	RTRAP_PSTATE_IRQOFF	(PSTATE_TSO|PSTATE_PEF|PSTATE_PRIV)</span>
<span class="p_add">+#define RTRAP_PSTATE_AG_IRQOFF	(PSTATE_TSO|PSTATE_PEF|PSTATE_PRIV|PSTATE_AG)</span>
<span class="p_add">+</span>
 #define __CHEETAH_ID	0x003e0014
 #define __JALAPENO_ID	0x003e0016
 #define __SERRANO_ID	0x003e0022
<span class="p_header">diff --git a/arch/sparc/include/asm/ttable.h b/arch/sparc/include/asm/ttable.h</span>
<span class="p_header">index 71b5a67522ab..781b9f1dbdc2 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/ttable.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/ttable.h</span>
<span class="p_chunk">@@ -589,8 +589,8 @@</span> <span class="p_context"> user_rtt_fill_64bit:					\</span>
 	 restored;					\
 	nop; nop; nop; nop; nop; nop;			\
 	nop; nop; nop; nop; nop;			\
<span class="p_del">-	ba,a,pt	%xcc, user_rtt_fill_fixup;		\</span>
<span class="p_del">-	ba,a,pt	%xcc, user_rtt_fill_fixup;		\</span>
<span class="p_add">+	ba,a,pt	%xcc, user_rtt_fill_fixup_dax;		\</span>
<span class="p_add">+	ba,a,pt	%xcc, user_rtt_fill_fixup_mna;		\</span>
 	ba,a,pt	%xcc, user_rtt_fill_fixup;
 
 
<span class="p_chunk">@@ -652,8 +652,8 @@</span> <span class="p_context"> user_rtt_fill_32bit:					\</span>
 	 restored;					\
 	nop; nop; nop; nop; nop;			\
 	nop; nop; nop;					\
<span class="p_del">-	ba,a,pt	%xcc, user_rtt_fill_fixup;		\</span>
<span class="p_del">-	ba,a,pt	%xcc, user_rtt_fill_fixup;		\</span>
<span class="p_add">+	ba,a,pt	%xcc, user_rtt_fill_fixup_dax;		\</span>
<span class="p_add">+	ba,a,pt	%xcc, user_rtt_fill_fixup_mna;		\</span>
 	ba,a,pt	%xcc, user_rtt_fill_fixup;
 
 
<span class="p_header">diff --git a/arch/sparc/kernel/Makefile b/arch/sparc/kernel/Makefile</span>
<span class="p_header">index 7cf9c6ea3f1f..fdb13327fded 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/Makefile</span>
<span class="p_header">+++ b/arch/sparc/kernel/Makefile</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"> CFLAGS_REMOVE_perf_event.o := -pg</span>
 CFLAGS_REMOVE_pcr.o := -pg
 endif
 
<span class="p_add">+obj-$(CONFIG_SPARC64)   += urtt_fill.o</span>
 obj-$(CONFIG_SPARC32)   += entry.o wof.o wuf.o
 obj-$(CONFIG_SPARC32)   += etrap_32.o
 obj-$(CONFIG_SPARC32)   += rtrap_32.o
<span class="p_header">diff --git a/arch/sparc/kernel/cherrs.S b/arch/sparc/kernel/cherrs.S</span>
<span class="p_header">index 4ee1ad420862..655628def68e 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/cherrs.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/cherrs.S</span>
<span class="p_chunk">@@ -214,8 +214,7 @@</span> <span class="p_context"> do_dcpe_tl1_nonfatal:	/* Ok we may use interrupt globals safely. */</span>
 	subcc		%g1, %g2, %g1		! Next cacheline
 	bge,pt		%icc, 1b
 	 nop
<span class="p_del">-	ba,pt		%xcc, dcpe_icpe_tl1_common</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, dcpe_icpe_tl1_common</span>
 
 do_dcpe_tl1_fatal:
 	sethi		%hi(1f), %g7
<span class="p_chunk">@@ -224,8 +223,7 @@</span> <span class="p_context"> do_dcpe_tl1_nonfatal:	/* Ok we may use interrupt globals safely. */</span>
 	mov		0x2, %o0
 	call		cheetah_plus_parity_error
 	 add		%sp, PTREGS_OFF, %o1
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		do_dcpe_tl1,.-do_dcpe_tl1
 
 	.globl		do_icpe_tl1
<span class="p_chunk">@@ -259,8 +257,7 @@</span> <span class="p_context"> do_icpe_tl1_nonfatal:	/* Ok we may use interrupt globals safely. */</span>
 	subcc		%g1, %g2, %g1
 	bge,pt		%icc, 1b
 	 nop
<span class="p_del">-	ba,pt		%xcc, dcpe_icpe_tl1_common</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, dcpe_icpe_tl1_common</span>
 
 do_icpe_tl1_fatal:
 	sethi		%hi(1f), %g7
<span class="p_chunk">@@ -269,8 +266,7 @@</span> <span class="p_context"> do_icpe_tl1_nonfatal:	/* Ok we may use interrupt globals safely. */</span>
 	mov		0x3, %o0
 	call		cheetah_plus_parity_error
 	 add		%sp, PTREGS_OFF, %o1
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		do_icpe_tl1,.-do_icpe_tl1
 	
 	.type		dcpe_icpe_tl1_common,#function
<span class="p_chunk">@@ -456,7 +452,7 @@</span> <span class="p_context"> do_icpe_tl1_nonfatal:	/* Ok we may use interrupt globals safely. */</span>
 	 cmp		%g2, 0x63
 	be		c_cee
 	 nop
<span class="p_del">-	ba,pt		%xcc, c_deferred</span>
<span class="p_add">+	ba,a,pt		%xcc, c_deferred</span>
 	.size		__cheetah_log_error,.-__cheetah_log_error
 
 	/* Cheetah FECC trap handling, we get here from tl{0,1}_fecc
<span class="p_header">diff --git a/arch/sparc/kernel/entry.S b/arch/sparc/kernel/entry.S</span>
<span class="p_header">index 33c02b15f478..a83707c83be8 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/entry.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/entry.S</span>
<span class="p_chunk">@@ -948,7 +948,24 @@</span> <span class="p_context"> SUN_PI_(lda	[%l4] ASI_M_MMUREGS, %l5)	! read sfsr last</span>
 	cmp	%o0, 0
 	bne	3f
 	 mov	-ENOSYS, %o0
<span class="p_add">+</span>
<span class="p_add">+	/* Syscall tracing can modify the registers.  */</span>
<span class="p_add">+	ld	[%sp + STACKFRAME_SZ + PT_G1], %g1</span>
<span class="p_add">+	sethi	%hi(sys_call_table), %l7</span>
<span class="p_add">+	ld	[%sp + STACKFRAME_SZ + PT_I0], %i0</span>
<span class="p_add">+	or	%l7, %lo(sys_call_table), %l7</span>
<span class="p_add">+	ld	[%sp + STACKFRAME_SZ + PT_I1], %i1</span>
<span class="p_add">+	ld	[%sp + STACKFRAME_SZ + PT_I2], %i2</span>
<span class="p_add">+	ld	[%sp + STACKFRAME_SZ + PT_I3], %i3</span>
<span class="p_add">+	ld	[%sp + STACKFRAME_SZ + PT_I4], %i4</span>
<span class="p_add">+	ld	[%sp + STACKFRAME_SZ + PT_I5], %i5</span>
<span class="p_add">+	cmp	%g1, NR_syscalls</span>
<span class="p_add">+	bgeu	3f</span>
<span class="p_add">+	 mov	-ENOSYS, %o0</span>
<span class="p_add">+</span>
<span class="p_add">+	sll	%g1, 2, %l4</span>
 	mov	%i0, %o0
<span class="p_add">+	ld	[%l7 + %l4], %l7</span>
 	mov	%i1, %o1
 	mov	%i2, %o2
 	mov	%i3, %o3
<span class="p_header">diff --git a/arch/sparc/kernel/fpu_traps.S b/arch/sparc/kernel/fpu_traps.S</span>
<span class="p_header">index a6864826a4bd..336d2750fe78 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/fpu_traps.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/fpu_traps.S</span>
<span class="p_chunk">@@ -100,8 +100,8 @@</span> <span class="p_context"></span>
 	fmuld		%f0, %f2, %f26
 	faddd		%f0, %f2, %f28
 	fmuld		%f0, %f2, %f30
<span class="p_del">-	b,pt		%xcc, fpdis_exit</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, fpdis_exit</span>
<span class="p_add">+</span>
 2:	andcc		%g5, FPRS_DU, %g0
 	bne,pt		%icc, 3f
 	 fzero		%f32
<span class="p_chunk">@@ -144,8 +144,8 @@</span> <span class="p_context"></span>
 	fmuld		%f32, %f34, %f58
 	faddd		%f32, %f34, %f60
 	fmuld		%f32, %f34, %f62
<span class="p_del">-	ba,pt		%xcc, fpdis_exit</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, fpdis_exit</span>
<span class="p_add">+</span>
 3:	mov		SECONDARY_CONTEXT, %g3
 	add		%g6, TI_FPREGS, %g1
 
<span class="p_chunk">@@ -197,8 +197,7 @@</span> <span class="p_context"></span>
 fp_other_bounce:
 	call		do_fpother
 	 add		%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		fp_other_bounce,.-fp_other_bounce
 
 	.align		32
<span class="p_header">diff --git a/arch/sparc/kernel/head_64.S b/arch/sparc/kernel/head_64.S</span>
<span class="p_header">index 3d61fcae7ee3..8ff57630a486 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/head_64.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/head_64.S</span>
<span class="p_chunk">@@ -461,9 +461,8 @@</span> <span class="p_context"></span>
 	subcc	%g3, 1, %g3
 	bne,pt	%xcc, 41b
 	add	%g1, 1, %g1
<span class="p_del">-	mov	SUN4V_CHIP_SPARC64X, %g4</span>
 	ba,pt	%xcc, 5f
<span class="p_del">-	nop</span>
<span class="p_add">+	 mov	SUN4V_CHIP_SPARC64X, %g4</span>
 
 49:
 	mov	SUN4V_CHIP_UNKNOWN, %g4
<span class="p_chunk">@@ -548,8 +547,7 @@</span> <span class="p_context"></span>
 	stxa		%g0, [%g7] ASI_DMMU
 	membar	#Sync
 
<span class="p_del">-	ba,pt		%xcc, sun4u_continue</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, sun4u_continue</span>
 
 sun4v_init:
 	/* Set ctx 0 */
<span class="p_chunk">@@ -560,14 +558,12 @@</span> <span class="p_context"></span>
 	mov		SECONDARY_CONTEXT, %g7
 	stxa		%g0, [%g7] ASI_MMU
 	membar		#Sync
<span class="p_del">-	ba,pt		%xcc, niagara_tlb_fixup</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, niagara_tlb_fixup</span>
 
 sun4u_continue:
 	BRANCH_IF_ANY_CHEETAH(g1, g7, cheetah_tlb_fixup)
 
<span class="p_del">-	ba,pt	%xcc, spitfire_tlb_fixup</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt	%xcc, spitfire_tlb_fixup</span>
 
 niagara_tlb_fixup:
 	mov	3, %g2		/* Set TLB type to hypervisor. */
<span class="p_chunk">@@ -639,8 +635,7 @@</span> <span class="p_context"></span>
 	call	hypervisor_patch_cachetlbops
 	 nop
 
<span class="p_del">-	ba,pt	%xcc, tlb_fixup_done</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt	%xcc, tlb_fixup_done</span>
 
 cheetah_tlb_fixup:
 	mov	2, %g2		/* Set TLB type to cheetah+. */
<span class="p_chunk">@@ -659,8 +654,7 @@</span> <span class="p_context"></span>
 	call	cheetah_patch_cachetlbops
 	 nop
 
<span class="p_del">-	ba,pt	%xcc, tlb_fixup_done</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt	%xcc, tlb_fixup_done</span>
 
 spitfire_tlb_fixup:
 	/* Set TLB type to spitfire. */
<span class="p_chunk">@@ -782,8 +776,7 @@</span> <span class="p_context"></span>
 	call	%o1
 	 add	%sp, (2047 + 128), %o0
 
<span class="p_del">-	ba,pt	%xcc, 2f</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt	%xcc, 2f</span>
 
 1:	sethi	%hi(sparc64_ttable_tl0), %o0
 	set	prom_set_trap_table_name, %g2
<span class="p_chunk">@@ -822,8 +815,7 @@</span> <span class="p_context"></span>
 
 	BRANCH_IF_ANY_CHEETAH(o2, o3, 1f)
 
<span class="p_del">-	ba,pt	%xcc, 2f</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt	%xcc, 2f</span>
 
 	/* Disable STICK_INT interrupts. */
 1:
<span class="p_header">diff --git a/arch/sparc/kernel/misctrap.S b/arch/sparc/kernel/misctrap.S</span>
<span class="p_header">index 753b4f031bfb..34b4933900bf 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/misctrap.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/misctrap.S</span>
<span class="p_chunk">@@ -18,8 +18,7 @@</span> <span class="p_context"></span>
 109:	or		%g7, %lo(109b), %g7
 	call		do_privact
 	 add		%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		__do_privact,.-__do_privact
 
 	.type		do_mna,#function
<span class="p_chunk">@@ -46,8 +45,7 @@</span> <span class="p_context"></span>
 	mov		%l5, %o2
 	call		mem_address_unaligned
 	 add		%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		do_mna,.-do_mna
 
 	.type		do_lddfmna,#function
<span class="p_chunk">@@ -65,8 +63,7 @@</span> <span class="p_context"></span>
 	mov		%l5, %o2
 	call		handle_lddfmna
 	 add		%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		do_lddfmna,.-do_lddfmna
 
 	.type		do_stdfmna,#function
<span class="p_chunk">@@ -84,8 +81,7 @@</span> <span class="p_context"></span>
 	mov		%l5, %o2
 	call		handle_stdfmna
 	 add		%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		do_stdfmna,.-do_stdfmna
 
 	.type		breakpoint_trap,#function
<span class="p_header">diff --git a/arch/sparc/kernel/pci.c b/arch/sparc/kernel/pci.c</span>
<span class="p_header">index 539babf00bb2..fce61b57d41c 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/pci.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/pci.c</span>
<span class="p_chunk">@@ -930,6 +930,23 @@</span> <span class="p_context"> void pcibios_set_master(struct pci_dev *dev)</span>
 	/* No special bus mastering setup handling */
 }
 
<span class="p_add">+#ifdef CONFIG_PCI_IOV</span>
<span class="p_add">+int pcibios_add_device(struct pci_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *pdev;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Add sriov arch specific initialization here.</span>
<span class="p_add">+	 * Copy dev_archdata from PF to VF</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (dev-&gt;is_virtfn) {</span>
<span class="p_add">+		pdev = dev-&gt;physfn;</span>
<span class="p_add">+		memcpy(&amp;dev-&gt;dev.archdata, &amp;pdev-&gt;dev.archdata,</span>
<span class="p_add">+		       sizeof(struct dev_archdata));</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_PCI_IOV */</span>
<span class="p_add">+</span>
 static int __init pcibios_init(void)
 {
 	pci_dfl_cache_line_size = 64 &gt;&gt; 2;
<span class="p_header">diff --git a/arch/sparc/kernel/rtrap_64.S b/arch/sparc/kernel/rtrap_64.S</span>
<span class="p_header">index 39f0c662f4c8..8de386dc8150 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/rtrap_64.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/rtrap_64.S</span>
<span class="p_chunk">@@ -14,10 +14,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/visasm.h&gt;
 #include &lt;asm/processor.h&gt;
 
<span class="p_del">-#define		RTRAP_PSTATE		(PSTATE_TSO|PSTATE_PEF|PSTATE_PRIV|PSTATE_IE)</span>
<span class="p_del">-#define		RTRAP_PSTATE_IRQOFF	(PSTATE_TSO|PSTATE_PEF|PSTATE_PRIV)</span>
<span class="p_del">-#define		RTRAP_PSTATE_AG_IRQOFF	(PSTATE_TSO|PSTATE_PEF|PSTATE_PRIV|PSTATE_AG)</span>
<span class="p_del">-</span>
 #ifdef CONFIG_CONTEXT_TRACKING
 # define SCHEDULE_USER schedule_user
 #else
<span class="p_chunk">@@ -236,52 +232,17 @@</span> <span class="p_context"> rt_continue:	ldx			[%sp + PTREGS_OFF + PT_V9_G1], %g1</span>
 		 wrpr			%g1, %cwp
 		ba,a,pt			%xcc, user_rtt_fill_64bit
 
<span class="p_del">-user_rtt_fill_fixup:</span>
<span class="p_del">-		rdpr	%cwp, %g1</span>
<span class="p_del">-		add	%g1, 1, %g1</span>
<span class="p_del">-		wrpr	%g1, 0x0, %cwp</span>
<span class="p_del">-</span>
<span class="p_del">-		rdpr	%wstate, %g2</span>
<span class="p_del">-		sll	%g2, 3, %g2</span>
<span class="p_del">-		wrpr	%g2, 0x0, %wstate</span>
<span class="p_del">-</span>
<span class="p_del">-		/* We know %canrestore and %otherwin are both zero.  */</span>
<span class="p_del">-</span>
<span class="p_del">-		sethi	%hi(sparc64_kern_pri_context), %g2</span>
<span class="p_del">-		ldx	[%g2 + %lo(sparc64_kern_pri_context)], %g2</span>
<span class="p_del">-		mov	PRIMARY_CONTEXT, %g1</span>
<span class="p_del">-</span>
<span class="p_del">-661:		stxa	%g2, [%g1] ASI_DMMU</span>
<span class="p_del">-		.section .sun4v_1insn_patch, &quot;ax&quot;</span>
<span class="p_del">-		.word	661b</span>
<span class="p_del">-		stxa	%g2, [%g1] ASI_MMU</span>
<span class="p_del">-		.previous</span>
<span class="p_del">-</span>
<span class="p_del">-		sethi	%hi(KERNBASE), %g1</span>
<span class="p_del">-		flush	%g1</span>
<span class="p_add">+user_rtt_fill_fixup_dax:</span>
<span class="p_add">+		ba,pt	%xcc, user_rtt_fill_fixup_common</span>
<span class="p_add">+		 mov	1, %g3</span>
 
<span class="p_del">-		or	%g4, FAULT_CODE_WINFIXUP, %g4</span>
<span class="p_del">-		stb	%g4, [%g6 + TI_FAULT_CODE]</span>
<span class="p_del">-		stx	%g5, [%g6 + TI_FAULT_ADDR]</span>
<span class="p_add">+user_rtt_fill_fixup_mna:</span>
<span class="p_add">+		ba,pt	%xcc, user_rtt_fill_fixup_common</span>
<span class="p_add">+		 mov	2, %g3</span>
 
<span class="p_del">-		mov	%g6, %l1</span>
<span class="p_del">-		wrpr	%g0, 0x0, %tl</span>
<span class="p_del">-</span>
<span class="p_del">-661:		nop</span>
<span class="p_del">-		.section		.sun4v_1insn_patch, &quot;ax&quot;</span>
<span class="p_del">-		.word			661b</span>
<span class="p_del">-		SET_GL(0)</span>
<span class="p_del">-		.previous</span>
<span class="p_del">-</span>
<span class="p_del">-		wrpr	%g0, RTRAP_PSTATE, %pstate</span>
<span class="p_del">-</span>
<span class="p_del">-		mov	%l1, %g6</span>
<span class="p_del">-		ldx	[%g6 + TI_TASK], %g4</span>
<span class="p_del">-		LOAD_PER_CPU_BASE(%g5, %g6, %g1, %g2, %g3)</span>
<span class="p_del">-		call	do_sparc64_fault</span>
<span class="p_del">-		 add	%sp, PTREGS_OFF, %o0</span>
<span class="p_del">-		ba,pt	%xcc, rtrap</span>
<span class="p_del">-		 nop</span>
<span class="p_add">+user_rtt_fill_fixup:</span>
<span class="p_add">+		ba,pt	%xcc, user_rtt_fill_fixup_common</span>
<span class="p_add">+		 clr	%g3</span>
 
 user_rtt_pre_restore:
 		add			%g1, 1, %g1
<span class="p_header">diff --git a/arch/sparc/kernel/signal32.c b/arch/sparc/kernel/signal32.c</span>
<span class="p_header">index 62deba7be1a9..05a36431103c 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/signal32.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/signal32.c</span>
<span class="p_chunk">@@ -138,12 +138,24 @@</span> <span class="p_context"> int copy_siginfo_from_user32(siginfo_t *to, compat_siginfo_t __user *from)</span>
 	return 0;
 }
 
<span class="p_add">+/* Checks if the fp is valid.  We always build signal frames which are</span>
<span class="p_add">+ * 16-byte aligned, therefore we can always enforce that the restore</span>
<span class="p_add">+ * frame has that property as well.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool invalid_frame_pointer(void __user *fp, int fplen)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if ((((unsigned long) fp) &amp; 15) ||</span>
<span class="p_add">+	    ((unsigned long)fp) &gt; 0x100000000ULL - fplen)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void do_sigreturn32(struct pt_regs *regs)
 {
 	struct signal_frame32 __user *sf;
 	compat_uptr_t fpu_save;
 	compat_uptr_t rwin_save;
<span class="p_del">-	unsigned int psr;</span>
<span class="p_add">+	unsigned int psr, ufp;</span>
 	unsigned pc, npc;
 	sigset_t set;
 	compat_sigset_t seta;
<span class="p_chunk">@@ -158,11 +170,16 @@</span> <span class="p_context"> void do_sigreturn32(struct pt_regs *regs)</span>
 	sf = (struct signal_frame32 __user *) regs-&gt;u_regs[UREG_FP];
 
 	/* 1. Make sure we are not getting garbage from the user */
<span class="p_del">-	if (!access_ok(VERIFY_READ, sf, sizeof(*sf)) ||</span>
<span class="p_del">-	    (((unsigned long) sf) &amp; 3))</span>
<span class="p_add">+	if (invalid_frame_pointer(sf, sizeof(*sf)))</span>
<span class="p_add">+		goto segv;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (get_user(ufp, &amp;sf-&gt;info.si_regs.u_regs[UREG_FP]))</span>
<span class="p_add">+		goto segv;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ufp &amp; 0x7)</span>
 		goto segv;
 
<span class="p_del">-	if (get_user(pc, &amp;sf-&gt;info.si_regs.pc) ||</span>
<span class="p_add">+	if (__get_user(pc, &amp;sf-&gt;info.si_regs.pc) ||</span>
 	    __get_user(npc, &amp;sf-&gt;info.si_regs.npc))
 		goto segv;
 
<span class="p_chunk">@@ -227,7 +244,7 @@</span> <span class="p_context"> void do_sigreturn32(struct pt_regs *regs)</span>
 asmlinkage void do_rt_sigreturn32(struct pt_regs *regs)
 {
 	struct rt_signal_frame32 __user *sf;
<span class="p_del">-	unsigned int psr, pc, npc;</span>
<span class="p_add">+	unsigned int psr, pc, npc, ufp;</span>
 	compat_uptr_t fpu_save;
 	compat_uptr_t rwin_save;
 	sigset_t set;
<span class="p_chunk">@@ -242,11 +259,16 @@</span> <span class="p_context"> asmlinkage void do_rt_sigreturn32(struct pt_regs *regs)</span>
 	sf = (struct rt_signal_frame32 __user *) regs-&gt;u_regs[UREG_FP];
 
 	/* 1. Make sure we are not getting garbage from the user */
<span class="p_del">-	if (!access_ok(VERIFY_READ, sf, sizeof(*sf)) ||</span>
<span class="p_del">-	    (((unsigned long) sf) &amp; 3))</span>
<span class="p_add">+	if (invalid_frame_pointer(sf, sizeof(*sf)))</span>
 		goto segv;
 
<span class="p_del">-	if (get_user(pc, &amp;sf-&gt;regs.pc) || </span>
<span class="p_add">+	if (get_user(ufp, &amp;sf-&gt;regs.u_regs[UREG_FP]))</span>
<span class="p_add">+		goto segv;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ufp &amp; 0x7)</span>
<span class="p_add">+		goto segv;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (__get_user(pc, &amp;sf-&gt;regs.pc) || </span>
 	    __get_user(npc, &amp;sf-&gt;regs.npc))
 		goto segv;
 
<span class="p_chunk">@@ -307,14 +329,6 @@</span> <span class="p_context"> asmlinkage void do_rt_sigreturn32(struct pt_regs *regs)</span>
 	force_sig(SIGSEGV, current);
 }
 
<span class="p_del">-/* Checks if the fp is valid */</span>
<span class="p_del">-static int invalid_frame_pointer(void __user *fp, int fplen)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if ((((unsigned long) fp) &amp; 7) || ((unsigned long)fp) &gt; 0x100000000ULL - fplen)</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void __user *get_sigframe(struct ksignal *ksig, struct pt_regs *regs, unsigned long framesize)
 {
 	unsigned long sp;
<span class="p_header">diff --git a/arch/sparc/kernel/signal_32.c b/arch/sparc/kernel/signal_32.c</span>
<span class="p_header">index 9ee72fc8e0e4..8492291424ab 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/signal_32.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/signal_32.c</span>
<span class="p_chunk">@@ -60,10 +60,22 @@</span> <span class="p_context"> struct rt_signal_frame {</span>
 #define SF_ALIGNEDSZ  (((sizeof(struct signal_frame) + 7) &amp; (~7)))
 #define RT_ALIGNEDSZ  (((sizeof(struct rt_signal_frame) + 7) &amp; (~7)))
 
<span class="p_add">+/* Checks if the fp is valid.  We always build signal frames which are</span>
<span class="p_add">+ * 16-byte aligned, therefore we can always enforce that the restore</span>
<span class="p_add">+ * frame has that property as well.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline bool invalid_frame_pointer(void __user *fp, int fplen)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if ((((unsigned long) fp) &amp; 15) || !__access_ok((unsigned long)fp, fplen))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 asmlinkage void do_sigreturn(struct pt_regs *regs)
 {
<span class="p_add">+	unsigned long up_psr, pc, npc, ufp;</span>
 	struct signal_frame __user *sf;
<span class="p_del">-	unsigned long up_psr, pc, npc;</span>
 	sigset_t set;
 	__siginfo_fpu_t __user *fpu_save;
 	__siginfo_rwin_t __user *rwin_save;
<span class="p_chunk">@@ -77,10 +89,13 @@</span> <span class="p_context"> asmlinkage void do_sigreturn(struct pt_regs *regs)</span>
 	sf = (struct signal_frame __user *) regs-&gt;u_regs[UREG_FP];
 
 	/* 1. Make sure we are not getting garbage from the user */
<span class="p_del">-	if (!access_ok(VERIFY_READ, sf, sizeof(*sf)))</span>
<span class="p_add">+	if (!invalid_frame_pointer(sf, sizeof(*sf)))</span>
<span class="p_add">+		goto segv_and_exit;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (get_user(ufp, &amp;sf-&gt;info.si_regs.u_regs[UREG_FP]))</span>
 		goto segv_and_exit;
 
<span class="p_del">-	if (((unsigned long) sf) &amp; 3)</span>
<span class="p_add">+	if (ufp &amp; 0x7)</span>
 		goto segv_and_exit;
 
 	err = __get_user(pc,  &amp;sf-&gt;info.si_regs.pc);
<span class="p_chunk">@@ -127,7 +142,7 @@</span> <span class="p_context"> asmlinkage void do_sigreturn(struct pt_regs *regs)</span>
 asmlinkage void do_rt_sigreturn(struct pt_regs *regs)
 {
 	struct rt_signal_frame __user *sf;
<span class="p_del">-	unsigned int psr, pc, npc;</span>
<span class="p_add">+	unsigned int psr, pc, npc, ufp;</span>
 	__siginfo_fpu_t __user *fpu_save;
 	__siginfo_rwin_t __user *rwin_save;
 	sigset_t set;
<span class="p_chunk">@@ -135,8 +150,13 @@</span> <span class="p_context"> asmlinkage void do_rt_sigreturn(struct pt_regs *regs)</span>
 
 	synchronize_user_stack();
 	sf = (struct rt_signal_frame __user *) regs-&gt;u_regs[UREG_FP];
<span class="p_del">-	if (!access_ok(VERIFY_READ, sf, sizeof(*sf)) ||</span>
<span class="p_del">-	    (((unsigned long) sf) &amp; 0x03))</span>
<span class="p_add">+	if (!invalid_frame_pointer(sf, sizeof(*sf)))</span>
<span class="p_add">+		goto segv;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (get_user(ufp, &amp;sf-&gt;regs.u_regs[UREG_FP]))</span>
<span class="p_add">+		goto segv;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ufp &amp; 0x7)</span>
 		goto segv;
 
 	err = __get_user(pc, &amp;sf-&gt;regs.pc);
<span class="p_chunk">@@ -178,15 +198,6 @@</span> <span class="p_context"> asmlinkage void do_rt_sigreturn(struct pt_regs *regs)</span>
 	force_sig(SIGSEGV, current);
 }
 
<span class="p_del">-/* Checks if the fp is valid */</span>
<span class="p_del">-static inline int invalid_frame_pointer(void __user *fp, int fplen)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if ((((unsigned long) fp) &amp; 7) || !__access_ok((unsigned long)fp, fplen))</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline void __user *get_sigframe(struct ksignal *ksig, struct pt_regs *regs, unsigned long framesize)
 {
 	unsigned long sp = regs-&gt;u_regs[UREG_FP];
<span class="p_header">diff --git a/arch/sparc/kernel/signal_64.c b/arch/sparc/kernel/signal_64.c</span>
<span class="p_header">index 1a6999868031..9acf9822cbbd 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/signal_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/signal_64.c</span>
<span class="p_chunk">@@ -52,7 +52,7 @@</span> <span class="p_context"> asmlinkage void sparc64_set_context(struct pt_regs *regs)</span>
 	unsigned char fenab;
 	int err;
 
<span class="p_del">-	flush_user_windows();</span>
<span class="p_add">+	synchronize_user_stack();</span>
 	if (get_thread_wsaved()					||
 	    (((unsigned long)ucp) &amp; (sizeof(unsigned long)-1))	||
 	    (!__access_ok(ucp, sizeof(*ucp))))
<span class="p_chunk">@@ -234,6 +234,17 @@</span> <span class="p_context"> asmlinkage void sparc64_get_context(struct pt_regs *regs)</span>
 	goto out;
 }
 
<span class="p_add">+/* Checks if the fp is valid.  We always build rt signal frames which</span>
<span class="p_add">+ * are 16-byte aligned, therefore we can always enforce that the</span>
<span class="p_add">+ * restore frame has that property as well.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool invalid_frame_pointer(void __user *fp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (((unsigned long) fp) &amp; 15)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct rt_signal_frame {
 	struct sparc_stackf	ss;
 	siginfo_t		info;
<span class="p_chunk">@@ -246,8 +257,8 @@</span> <span class="p_context"> struct rt_signal_frame {</span>
 
 void do_rt_sigreturn(struct pt_regs *regs)
 {
<span class="p_add">+	unsigned long tpc, tnpc, tstate, ufp;</span>
 	struct rt_signal_frame __user *sf;
<span class="p_del">-	unsigned long tpc, tnpc, tstate;</span>
 	__siginfo_fpu_t __user *fpu_save;
 	__siginfo_rwin_t __user *rwin_save;
 	sigset_t set;
<span class="p_chunk">@@ -261,10 +272,16 @@</span> <span class="p_context"> void do_rt_sigreturn(struct pt_regs *regs)</span>
 		(regs-&gt;u_regs [UREG_FP] + STACK_BIAS);
 
 	/* 1. Make sure we are not getting garbage from the user */
<span class="p_del">-	if (((unsigned long) sf) &amp; 3)</span>
<span class="p_add">+	if (invalid_frame_pointer(sf))</span>
<span class="p_add">+		goto segv;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (get_user(ufp, &amp;sf-&gt;regs.u_regs[UREG_FP]))</span>
 		goto segv;
 
<span class="p_del">-	err = get_user(tpc, &amp;sf-&gt;regs.tpc);</span>
<span class="p_add">+	if ((ufp + STACK_BIAS) &amp; 0x7)</span>
<span class="p_add">+		goto segv;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = __get_user(tpc, &amp;sf-&gt;regs.tpc);</span>
 	err |= __get_user(tnpc, &amp;sf-&gt;regs.tnpc);
 	if (test_thread_flag(TIF_32BIT)) {
 		tpc &amp;= 0xffffffff;
<span class="p_chunk">@@ -308,14 +325,6 @@</span> <span class="p_context"> void do_rt_sigreturn(struct pt_regs *regs)</span>
 	force_sig(SIGSEGV, current);
 }
 
<span class="p_del">-/* Checks if the fp is valid */</span>
<span class="p_del">-static int invalid_frame_pointer(void __user *fp)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (((unsigned long) fp) &amp; 15)</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline void __user *get_sigframe(struct ksignal *ksig, struct pt_regs *regs, unsigned long framesize)
 {
 	unsigned long sp = regs-&gt;u_regs[UREG_FP] + STACK_BIAS;
<span class="p_header">diff --git a/arch/sparc/kernel/sigutil_32.c b/arch/sparc/kernel/sigutil_32.c</span>
<span class="p_header">index 0f6eebe71e6c..e5fe8cef9a69 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/sigutil_32.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/sigutil_32.c</span>
<span class="p_chunk">@@ -48,6 +48,10 @@</span> <span class="p_context"> int save_fpu_state(struct pt_regs *regs, __siginfo_fpu_t __user *fpu)</span>
 int restore_fpu_state(struct pt_regs *regs, __siginfo_fpu_t __user *fpu)
 {
 	int err;
<span class="p_add">+</span>
<span class="p_add">+	if (((unsigned long) fpu) &amp; 3)</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
 #ifdef CONFIG_SMP
 	if (test_tsk_thread_flag(current, TIF_USEDFPU))
 		regs-&gt;psr &amp;= ~PSR_EF;
<span class="p_chunk">@@ -97,7 +101,10 @@</span> <span class="p_context"> int restore_rwin_state(__siginfo_rwin_t __user *rp)</span>
 	struct thread_info *t = current_thread_info();
 	int i, wsaved, err;
 
<span class="p_del">-	__get_user(wsaved, &amp;rp-&gt;wsaved);</span>
<span class="p_add">+	if (((unsigned long) rp) &amp; 3)</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	get_user(wsaved, &amp;rp-&gt;wsaved);</span>
 	if (wsaved &gt; NSWINS)
 		return -EFAULT;
 
<span class="p_header">diff --git a/arch/sparc/kernel/sigutil_64.c b/arch/sparc/kernel/sigutil_64.c</span>
<span class="p_header">index 387834a9c56a..36aadcbeac69 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/sigutil_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/sigutil_64.c</span>
<span class="p_chunk">@@ -37,7 +37,10 @@</span> <span class="p_context"> int restore_fpu_state(struct pt_regs *regs, __siginfo_fpu_t __user *fpu)</span>
 	unsigned long fprs;
 	int err;
 
<span class="p_del">-	err = __get_user(fprs, &amp;fpu-&gt;si_fprs);</span>
<span class="p_add">+	if (((unsigned long) fpu) &amp; 7)</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = get_user(fprs, &amp;fpu-&gt;si_fprs);</span>
 	fprs_write(0);
 	regs-&gt;tstate &amp;= ~TSTATE_PEF;
 	if (fprs &amp; FPRS_DL)
<span class="p_chunk">@@ -72,7 +75,10 @@</span> <span class="p_context"> int restore_rwin_state(__siginfo_rwin_t __user *rp)</span>
 	struct thread_info *t = current_thread_info();
 	int i, wsaved, err;
 
<span class="p_del">-	__get_user(wsaved, &amp;rp-&gt;wsaved);</span>
<span class="p_add">+	if (((unsigned long) rp) &amp; 7)</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	get_user(wsaved, &amp;rp-&gt;wsaved);</span>
 	if (wsaved &gt; NSWINS)
 		return -EFAULT;
 
<span class="p_header">diff --git a/arch/sparc/kernel/spiterrs.S b/arch/sparc/kernel/spiterrs.S</span>
<span class="p_header">index c357e40ffd01..4a73009f66a5 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/spiterrs.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/spiterrs.S</span>
<span class="p_chunk">@@ -85,8 +85,7 @@</span> <span class="p_context"></span>
 	ba,pt		%xcc, etraptl1
 	 rd		%pc, %g7
 
<span class="p_del">-	ba,pt		%xcc, 2f</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, 2f</span>
 
 1:	ba,pt		%xcc, etrap_irq
 	 rd		%pc, %g7
<span class="p_chunk">@@ -100,8 +99,7 @@</span> <span class="p_context"></span>
 	mov		%l5, %o2
 	call		spitfire_access_error
 	 add		%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		__spitfire_access_error,.-__spitfire_access_error
 
 	/* This is the trap handler entry point for ECC correctable
<span class="p_chunk">@@ -179,8 +177,7 @@</span> <span class="p_context"></span>
 	mov		%l5, %o2
 	call		spitfire_data_access_exception_tl1
 	 add		%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		__spitfire_data_access_exception_tl1,.-__spitfire_data_access_exception_tl1
 
 	.type		__spitfire_data_access_exception,#function
<span class="p_chunk">@@ -200,8 +197,7 @@</span> <span class="p_context"></span>
 	mov		%l5, %o2
 	call		spitfire_data_access_exception
 	 add		%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		__spitfire_data_access_exception,.-__spitfire_data_access_exception
 
 	.type		__spitfire_insn_access_exception_tl1,#function
<span class="p_chunk">@@ -220,8 +216,7 @@</span> <span class="p_context"></span>
 	mov		%l5, %o2
 	call		spitfire_insn_access_exception_tl1
 	 add		%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		__spitfire_insn_access_exception_tl1,.-__spitfire_insn_access_exception_tl1
 
 	.type		__spitfire_insn_access_exception,#function
<span class="p_chunk">@@ -240,6 +235,5 @@</span> <span class="p_context"></span>
 	mov		%l5, %o2
 	call		spitfire_insn_access_exception
 	 add		%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		__spitfire_insn_access_exception,.-__spitfire_insn_access_exception
<span class="p_header">diff --git a/arch/sparc/kernel/syscalls.S b/arch/sparc/kernel/syscalls.S</span>
<span class="p_header">index 33a17e7b3ccd..6ec7531f27fc 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/syscalls.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/syscalls.S</span>
<span class="p_chunk">@@ -148,7 +148,25 @@</span> <span class="p_context"> sys_vfork: /* Under Linux, vfork and fork are just special cases of clone. */</span>
 	 add	%sp, PTREGS_OFF, %o0
 	brnz,pn	%o0, 3f
 	 mov	-ENOSYS, %o0
<span class="p_add">+</span>
<span class="p_add">+	/* Syscall tracing can modify the registers.  */</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_G1], %g1</span>
<span class="p_add">+	sethi	%hi(sys_call_table32), %l7</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I0], %i0</span>
<span class="p_add">+	or	%l7, %lo(sys_call_table32), %l7</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I1], %i1</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I2], %i2</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I3], %i3</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I4], %i4</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I5], %i5</span>
<span class="p_add">+</span>
<span class="p_add">+	cmp	%g1, NR_syscalls</span>
<span class="p_add">+	bgeu,pn	%xcc, 3f</span>
<span class="p_add">+	 mov	-ENOSYS, %o0</span>
<span class="p_add">+</span>
<span class="p_add">+	sll	%g1, 2, %l4</span>
 	srl	%i0, 0, %o0
<span class="p_add">+	lduw	[%l7 + %l4], %l7</span>
 	srl	%i4, 0, %o4
 	srl	%i1, 0, %o1
 	srl	%i2, 0, %o2
<span class="p_chunk">@@ -160,7 +178,25 @@</span> <span class="p_context"> sys_vfork: /* Under Linux, vfork and fork are just special cases of clone. */</span>
 	 add	%sp, PTREGS_OFF, %o0
 	brnz,pn	%o0, 3f
 	 mov	-ENOSYS, %o0
<span class="p_add">+</span>
<span class="p_add">+	/* Syscall tracing can modify the registers.  */</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_G1], %g1</span>
<span class="p_add">+	sethi	%hi(sys_call_table64), %l7</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I0], %i0</span>
<span class="p_add">+	or	%l7, %lo(sys_call_table64), %l7</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I1], %i1</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I2], %i2</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I3], %i3</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I4], %i4</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I5], %i5</span>
<span class="p_add">+</span>
<span class="p_add">+	cmp	%g1, NR_syscalls</span>
<span class="p_add">+	bgeu,pn	%xcc, 3f</span>
<span class="p_add">+	 mov	-ENOSYS, %o0</span>
<span class="p_add">+</span>
<span class="p_add">+	sll	%g1, 2, %l4</span>
 	mov	%i0, %o0
<span class="p_add">+	lduw	[%l7 + %l4], %l7</span>
 	mov	%i1, %o1
 	mov	%i2, %o2
 	mov	%i3, %o3
<span class="p_header">diff --git a/arch/sparc/kernel/urtt_fill.S b/arch/sparc/kernel/urtt_fill.S</span>
new file mode 100644
<span class="p_header">index 000000000000..5604a2b051d4</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/sparc/kernel/urtt_fill.S</span>
<span class="p_chunk">@@ -0,0 +1,98 @@</span> <span class="p_context"></span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+#include &lt;asm/trap_block.h&gt;</span>
<span class="p_add">+#include &lt;asm/spitfire.h&gt;</span>
<span class="p_add">+#include &lt;asm/ptrace.h&gt;</span>
<span class="p_add">+#include &lt;asm/head.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+		.text</span>
<span class="p_add">+		.align	8</span>
<span class="p_add">+		.globl	user_rtt_fill_fixup_common</span>
<span class="p_add">+user_rtt_fill_fixup_common:</span>
<span class="p_add">+		rdpr	%cwp, %g1</span>
<span class="p_add">+		add	%g1, 1, %g1</span>
<span class="p_add">+		wrpr	%g1, 0x0, %cwp</span>
<span class="p_add">+</span>
<span class="p_add">+		rdpr	%wstate, %g2</span>
<span class="p_add">+		sll	%g2, 3, %g2</span>
<span class="p_add">+		wrpr	%g2, 0x0, %wstate</span>
<span class="p_add">+</span>
<span class="p_add">+		/* We know %canrestore and %otherwin are both zero.  */</span>
<span class="p_add">+</span>
<span class="p_add">+		sethi	%hi(sparc64_kern_pri_context), %g2</span>
<span class="p_add">+		ldx	[%g2 + %lo(sparc64_kern_pri_context)], %g2</span>
<span class="p_add">+		mov	PRIMARY_CONTEXT, %g1</span>
<span class="p_add">+</span>
<span class="p_add">+661:		stxa	%g2, [%g1] ASI_DMMU</span>
<span class="p_add">+		.section .sun4v_1insn_patch, &quot;ax&quot;</span>
<span class="p_add">+		.word	661b</span>
<span class="p_add">+		stxa	%g2, [%g1] ASI_MMU</span>
<span class="p_add">+		.previous</span>
<span class="p_add">+</span>
<span class="p_add">+		sethi	%hi(KERNBASE), %g1</span>
<span class="p_add">+		flush	%g1</span>
<span class="p_add">+</span>
<span class="p_add">+		mov	%g4, %l4</span>
<span class="p_add">+		mov	%g5, %l5</span>
<span class="p_add">+		brnz,pn	%g3, 1f</span>
<span class="p_add">+		 mov	%g3, %l3</span>
<span class="p_add">+</span>
<span class="p_add">+		or	%g4, FAULT_CODE_WINFIXUP, %g4</span>
<span class="p_add">+		stb	%g4, [%g6 + TI_FAULT_CODE]</span>
<span class="p_add">+		stx	%g5, [%g6 + TI_FAULT_ADDR]</span>
<span class="p_add">+1:</span>
<span class="p_add">+		mov	%g6, %l1</span>
<span class="p_add">+		wrpr	%g0, 0x0, %tl</span>
<span class="p_add">+</span>
<span class="p_add">+661:		nop</span>
<span class="p_add">+		.section		.sun4v_1insn_patch, &quot;ax&quot;</span>
<span class="p_add">+		.word			661b</span>
<span class="p_add">+		SET_GL(0)</span>
<span class="p_add">+		.previous</span>
<span class="p_add">+</span>
<span class="p_add">+		wrpr	%g0, RTRAP_PSTATE, %pstate</span>
<span class="p_add">+</span>
<span class="p_add">+		mov	%l1, %g6</span>
<span class="p_add">+		ldx	[%g6 + TI_TASK], %g4</span>
<span class="p_add">+		LOAD_PER_CPU_BASE(%g5, %g6, %g1, %g2, %g3)</span>
<span class="p_add">+</span>
<span class="p_add">+		brnz,pn	%l3, 1f</span>
<span class="p_add">+		 nop</span>
<span class="p_add">+</span>
<span class="p_add">+		call	do_sparc64_fault</span>
<span class="p_add">+		 add	%sp, PTREGS_OFF, %o0</span>
<span class="p_add">+		ba,pt	%xcc, rtrap</span>
<span class="p_add">+		 nop</span>
<span class="p_add">+</span>
<span class="p_add">+1:		cmp	%g3, 2</span>
<span class="p_add">+		bne,pn	%xcc, 2f</span>
<span class="p_add">+		 nop</span>
<span class="p_add">+</span>
<span class="p_add">+		sethi	%hi(tlb_type), %g1</span>
<span class="p_add">+		lduw	[%g1 + %lo(tlb_type)], %g1</span>
<span class="p_add">+		cmp	%g1, 3</span>
<span class="p_add">+		bne,pt	%icc, 1f</span>
<span class="p_add">+		 add	%sp, PTREGS_OFF, %o0</span>
<span class="p_add">+		mov	%l4, %o2</span>
<span class="p_add">+		call	sun4v_do_mna</span>
<span class="p_add">+		 mov	%l5, %o1</span>
<span class="p_add">+		ba,a,pt	%xcc, rtrap</span>
<span class="p_add">+1:		mov	%l4, %o1</span>
<span class="p_add">+		mov	%l5, %o2</span>
<span class="p_add">+		call	mem_address_unaligned</span>
<span class="p_add">+		 nop</span>
<span class="p_add">+		ba,a,pt	%xcc, rtrap</span>
<span class="p_add">+</span>
<span class="p_add">+2:		sethi	%hi(tlb_type), %g1</span>
<span class="p_add">+		mov	%l4, %o1</span>
<span class="p_add">+		lduw	[%g1 + %lo(tlb_type)], %g1</span>
<span class="p_add">+		mov	%l5, %o2</span>
<span class="p_add">+		cmp	%g1, 3</span>
<span class="p_add">+		bne,pt	%icc, 1f</span>
<span class="p_add">+		 add	%sp, PTREGS_OFF, %o0</span>
<span class="p_add">+		call	sun4v_data_access_exception</span>
<span class="p_add">+		 nop</span>
<span class="p_add">+		ba,a,pt	%xcc, rtrap</span>
<span class="p_add">+</span>
<span class="p_add">+1:		call	spitfire_data_access_exception</span>
<span class="p_add">+		 nop</span>
<span class="p_add">+		ba,a,pt	%xcc, rtrap</span>
<span class="p_header">diff --git a/arch/sparc/kernel/utrap.S b/arch/sparc/kernel/utrap.S</span>
<span class="p_header">index b7f0f3f3a909..c731e8023d3e 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/utrap.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/utrap.S</span>
<span class="p_chunk">@@ -11,8 +11,7 @@</span> <span class="p_context"> utrap_trap:		/* %g3=handler,%g4=level */</span>
 	mov		%l4, %o1
         call		bad_trap
 	 add		%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 
 invoke_utrap:
 	sllx		%g3, 3, %g3
<span class="p_header">diff --git a/arch/sparc/kernel/vmlinux.lds.S b/arch/sparc/kernel/vmlinux.lds.S</span>
<span class="p_header">index 09243057cb0b..7028b4dab903 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/vmlinux.lds.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/vmlinux.lds.S</span>
<span class="p_chunk">@@ -33,6 +33,10 @@</span> <span class="p_context"> ENTRY(_start)</span>
 jiffies = jiffies_64;
 #endif
 
<span class="p_add">+#ifdef CONFIG_SPARC64</span>
<span class="p_add">+ASSERT((swapper_tsb == 0x0000000000408000), &quot;Error: sparc64 early assembler too large&quot;)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 SECTIONS
 {
 #ifdef CONFIG_SPARC64
<span class="p_header">diff --git a/arch/sparc/kernel/winfixup.S b/arch/sparc/kernel/winfixup.S</span>
<span class="p_header">index 1e67ce958369..855019a8590e 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/winfixup.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/winfixup.S</span>
<span class="p_chunk">@@ -32,8 +32,7 @@</span> <span class="p_context"></span>
 	 rd	%pc, %g7
 	call	do_sparc64_fault
 	 add	%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt	%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt	%xcc, rtrap</span>
 
 	/* Be very careful about usage of the trap globals here.
 	 * You cannot touch %g5 as that has the fault information.
<span class="p_header">diff --git a/arch/sparc/mm/init_64.c b/arch/sparc/mm/init_64.c</span>
<span class="p_header">index bbb9371f519b..baea27e341e6 100644</span>
<span class="p_header">--- a/arch/sparc/mm/init_64.c</span>
<span class="p_header">+++ b/arch/sparc/mm/init_64.c</span>
<span class="p_chunk">@@ -2682,9 +2682,10 @@</span> <span class="p_context"> void hugetlb_setup(struct pt_regs *regs)</span>
 	 * the Data-TLB for huge pages.
 	 */
 	if (tlb_type == cheetah_plus) {
<span class="p_add">+		bool need_context_reload = false;</span>
 		unsigned long ctx;
 
<span class="p_del">-		spin_lock(&amp;ctx_alloc_lock);</span>
<span class="p_add">+		spin_lock_irq(&amp;ctx_alloc_lock);</span>
 		ctx = mm-&gt;context.sparc64_ctx_val;
 		ctx &amp;= ~CTX_PGSZ_MASK;
 		ctx |= CTX_PGSZ_BASE &lt;&lt; CTX_PGSZ0_SHIFT;
<span class="p_chunk">@@ -2703,9 +2704,12 @@</span> <span class="p_context"> void hugetlb_setup(struct pt_regs *regs)</span>
 			 * also executing in this address space.
 			 */
 			mm-&gt;context.sparc64_ctx_val = ctx;
<span class="p_del">-			on_each_cpu(context_reload, mm, 0);</span>
<span class="p_add">+			need_context_reload = true;</span>
 		}
<span class="p_del">-		spin_unlock(&amp;ctx_alloc_lock);</span>
<span class="p_add">+		spin_unlock_irq(&amp;ctx_alloc_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (need_context_reload)</span>
<span class="p_add">+			on_each_cpu(context_reload, mm, 0);</span>
 	}
 }
 #endif
<span class="p_header">diff --git a/arch/x86/boot/compressed/Makefile b/arch/x86/boot/compressed/Makefile</span>
<span class="p_header">index 67e9f5cc91ed..8036ebb0db3d 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/Makefile</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/Makefile</span>
<span class="p_chunk">@@ -34,6 +34,9 @@</span> <span class="p_context"> $(obj)/eboot.o: KBUILD_CFLAGS += -fshort-wchar -mno-red-zone</span>
 
 ifeq ($(CONFIG_EFI_STUB), y)
 	VMLINUX_OBJS += $(obj)/eboot.o $(obj)/efi_stub_$(BITS).o
<span class="p_add">+ifeq ($(CONFIG_EFI_MIXED), y)</span>
<span class="p_add">+	VMLINUX_OBJS += $(obj)/efi_thunk_$(BITS).o</span>
<span class="p_add">+endif</span>
 endif
 
 $(obj)/vmlinux: $(VMLINUX_OBJS) FORCE
<span class="p_header">diff --git a/arch/x86/boot/compressed/efi_stub_64.S b/arch/x86/boot/compressed/efi_stub_64.S</span>
<span class="p_header">index 7ff3632806b1..99494dff2113 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/efi_stub_64.S</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/efi_stub_64.S</span>
<span class="p_chunk">@@ -3,28 +3,3 @@</span> <span class="p_context"></span>
 #include &lt;asm/processor-flags.h&gt;
 
 #include &quot;../../platform/efi/efi_stub_64.S&quot;
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_EFI_MIXED</span>
<span class="p_del">-	.code64</span>
<span class="p_del">-	.text</span>
<span class="p_del">-ENTRY(efi64_thunk)</span>
<span class="p_del">-	push	%rbp</span>
<span class="p_del">-	push	%rbx</span>
<span class="p_del">-</span>
<span class="p_del">-	subq	$16, %rsp</span>
<span class="p_del">-	leaq	efi_exit32(%rip), %rax</span>
<span class="p_del">-	movl	%eax, 8(%rsp)</span>
<span class="p_del">-	leaq	efi_gdt64(%rip), %rax</span>
<span class="p_del">-	movl	%eax, 4(%rsp)</span>
<span class="p_del">-	movl	%eax, 2(%rax)		/* Fixup the gdt base address */</span>
<span class="p_del">-	leaq	efi32_boot_gdt(%rip), %rax</span>
<span class="p_del">-	movl	%eax, (%rsp)</span>
<span class="p_del">-</span>
<span class="p_del">-	call	__efi64_thunk</span>
<span class="p_del">-</span>
<span class="p_del">-	addq	$16, %rsp</span>
<span class="p_del">-	pop	%rbx</span>
<span class="p_del">-	pop	%rbp</span>
<span class="p_del">-	ret</span>
<span class="p_del">-ENDPROC(efi64_thunk)</span>
<span class="p_del">-#endif /* CONFIG_EFI_MIXED */</span>
<span class="p_header">diff --git a/arch/x86/boot/compressed/efi_thunk_64.S b/arch/x86/boot/compressed/efi_thunk_64.S</span>
new file mode 100644
<span class="p_header">index 000000000000..630384a4c14a</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/efi_thunk_64.S</span>
<span class="p_chunk">@@ -0,0 +1,196 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2014, 2015 Intel Corporation; author Matt Fleming</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Early support for invoking 32-bit EFI services from a 64-bit kernel.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Because this thunking occurs before ExitBootServices() we have to</span>
<span class="p_add">+ * restore the firmware&#39;s 32-bit GDT before we make EFI serivce calls,</span>
<span class="p_add">+ * since the firmware&#39;s 32-bit IDT is still currently installed and it</span>
<span class="p_add">+ * needs to be able to service interrupts.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * On the plus side, we don&#39;t have to worry about mangling 64-bit</span>
<span class="p_add">+ * addresses into 32-bits because we&#39;re executing with an identify</span>
<span class="p_add">+ * mapped pagetable and haven&#39;t transitioned to 64-bit virtual addresses</span>
<span class="p_add">+ * yet.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;asm/msr.h&gt;</span>
<span class="p_add">+#include &lt;asm/page_types.h&gt;</span>
<span class="p_add">+#include &lt;asm/processor-flags.h&gt;</span>
<span class="p_add">+#include &lt;asm/segment.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+	.code64</span>
<span class="p_add">+	.text</span>
<span class="p_add">+ENTRY(efi64_thunk)</span>
<span class="p_add">+	push	%rbp</span>
<span class="p_add">+	push	%rbx</span>
<span class="p_add">+</span>
<span class="p_add">+	subq	$8, %rsp</span>
<span class="p_add">+	leaq	efi_exit32(%rip), %rax</span>
<span class="p_add">+	movl	%eax, 4(%rsp)</span>
<span class="p_add">+	leaq	efi_gdt64(%rip), %rax</span>
<span class="p_add">+	movl	%eax, (%rsp)</span>
<span class="p_add">+	movl	%eax, 2(%rax)		/* Fixup the gdt base address */</span>
<span class="p_add">+</span>
<span class="p_add">+	movl	%ds, %eax</span>
<span class="p_add">+	push	%rax</span>
<span class="p_add">+	movl	%es, %eax</span>
<span class="p_add">+	push	%rax</span>
<span class="p_add">+	movl	%ss, %eax</span>
<span class="p_add">+	push	%rax</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Convert x86-64 ABI params to i386 ABI</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	subq	$32, %rsp</span>
<span class="p_add">+	movl	%esi, 0x0(%rsp)</span>
<span class="p_add">+	movl	%edx, 0x4(%rsp)</span>
<span class="p_add">+	movl	%ecx, 0x8(%rsp)</span>
<span class="p_add">+	movq	%r8, %rsi</span>
<span class="p_add">+	movl	%esi, 0xc(%rsp)</span>
<span class="p_add">+	movq	%r9, %rsi</span>
<span class="p_add">+	movl	%esi,  0x10(%rsp)</span>
<span class="p_add">+</span>
<span class="p_add">+	sgdt	save_gdt(%rip)</span>
<span class="p_add">+</span>
<span class="p_add">+	leaq	1f(%rip), %rbx</span>
<span class="p_add">+	movq	%rbx, func_rt_ptr(%rip)</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Switch to gdt with 32-bit segments. This is the firmware GDT</span>
<span class="p_add">+	 * that was installed when the kernel started executing. This</span>
<span class="p_add">+	 * pointer was saved at the EFI stub entry point in head_64.S.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	leaq	efi32_boot_gdt(%rip), %rax</span>
<span class="p_add">+	lgdt	(%rax)</span>
<span class="p_add">+</span>
<span class="p_add">+	pushq	$__KERNEL_CS</span>
<span class="p_add">+	leaq	efi_enter32(%rip), %rax</span>
<span class="p_add">+	pushq	%rax</span>
<span class="p_add">+	lretq</span>
<span class="p_add">+</span>
<span class="p_add">+1:	addq	$32, %rsp</span>
<span class="p_add">+</span>
<span class="p_add">+	lgdt	save_gdt(%rip)</span>
<span class="p_add">+</span>
<span class="p_add">+	pop	%rbx</span>
<span class="p_add">+	movl	%ebx, %ss</span>
<span class="p_add">+	pop	%rbx</span>
<span class="p_add">+	movl	%ebx, %es</span>
<span class="p_add">+	pop	%rbx</span>
<span class="p_add">+	movl	%ebx, %ds</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Convert 32-bit status code into 64-bit.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	test	%rax, %rax</span>
<span class="p_add">+	jz	1f</span>
<span class="p_add">+	movl	%eax, %ecx</span>
<span class="p_add">+	andl	$0x0fffffff, %ecx</span>
<span class="p_add">+	andl	$0xf0000000, %eax</span>
<span class="p_add">+	shl	$32, %rax</span>
<span class="p_add">+	or	%rcx, %rax</span>
<span class="p_add">+1:</span>
<span class="p_add">+	addq	$8, %rsp</span>
<span class="p_add">+	pop	%rbx</span>
<span class="p_add">+	pop	%rbp</span>
<span class="p_add">+	ret</span>
<span class="p_add">+ENDPROC(efi64_thunk)</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(efi_exit32)</span>
<span class="p_add">+	movq	func_rt_ptr(%rip), %rax</span>
<span class="p_add">+	push	%rax</span>
<span class="p_add">+	mov	%rdi, %rax</span>
<span class="p_add">+	ret</span>
<span class="p_add">+ENDPROC(efi_exit32)</span>
<span class="p_add">+</span>
<span class="p_add">+	.code32</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * EFI service pointer must be in %edi.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The stack should represent the 32-bit calling convention.</span>
<span class="p_add">+ */</span>
<span class="p_add">+ENTRY(efi_enter32)</span>
<span class="p_add">+	movl	$__KERNEL_DS, %eax</span>
<span class="p_add">+	movl	%eax, %ds</span>
<span class="p_add">+	movl	%eax, %es</span>
<span class="p_add">+	movl	%eax, %ss</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Reload pgtables */</span>
<span class="p_add">+	movl	%cr3, %eax</span>
<span class="p_add">+	movl	%eax, %cr3</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Disable paging */</span>
<span class="p_add">+	movl	%cr0, %eax</span>
<span class="p_add">+	btrl	$X86_CR0_PG_BIT, %eax</span>
<span class="p_add">+	movl	%eax, %cr0</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Disable long mode via EFER */</span>
<span class="p_add">+	movl	$MSR_EFER, %ecx</span>
<span class="p_add">+	rdmsr</span>
<span class="p_add">+	btrl	$_EFER_LME, %eax</span>
<span class="p_add">+	wrmsr</span>
<span class="p_add">+</span>
<span class="p_add">+	call	*%edi</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We must preserve return value */</span>
<span class="p_add">+	movl	%eax, %edi</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Some firmware will return with interrupts enabled. Be sure to</span>
<span class="p_add">+	 * disable them before we switch GDTs.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	cli</span>
<span class="p_add">+</span>
<span class="p_add">+	movl	56(%esp), %eax</span>
<span class="p_add">+	movl	%eax, 2(%eax)</span>
<span class="p_add">+	lgdtl	(%eax)</span>
<span class="p_add">+</span>
<span class="p_add">+	movl	%cr4, %eax</span>
<span class="p_add">+	btsl	$(X86_CR4_PAE_BIT), %eax</span>
<span class="p_add">+	movl	%eax, %cr4</span>
<span class="p_add">+</span>
<span class="p_add">+	movl	%cr3, %eax</span>
<span class="p_add">+	movl	%eax, %cr3</span>
<span class="p_add">+</span>
<span class="p_add">+	movl	$MSR_EFER, %ecx</span>
<span class="p_add">+	rdmsr</span>
<span class="p_add">+	btsl	$_EFER_LME, %eax</span>
<span class="p_add">+	wrmsr</span>
<span class="p_add">+</span>
<span class="p_add">+	xorl	%eax, %eax</span>
<span class="p_add">+	lldt	%ax</span>
<span class="p_add">+</span>
<span class="p_add">+	movl	60(%esp), %eax</span>
<span class="p_add">+	pushl	$__KERNEL_CS</span>
<span class="p_add">+	pushl	%eax</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable paging */</span>
<span class="p_add">+	movl	%cr0, %eax</span>
<span class="p_add">+	btsl	$X86_CR0_PG_BIT, %eax</span>
<span class="p_add">+	movl	%eax, %cr0</span>
<span class="p_add">+	lret</span>
<span class="p_add">+ENDPROC(efi_enter32)</span>
<span class="p_add">+</span>
<span class="p_add">+	.data</span>
<span class="p_add">+	.balign	8</span>
<span class="p_add">+	.global	efi32_boot_gdt</span>
<span class="p_add">+efi32_boot_gdt:	.word	0</span>
<span class="p_add">+		.quad	0</span>
<span class="p_add">+</span>
<span class="p_add">+save_gdt:	.word	0</span>
<span class="p_add">+		.quad	0</span>
<span class="p_add">+func_rt_ptr:	.quad	0</span>
<span class="p_add">+</span>
<span class="p_add">+	.global efi_gdt64</span>
<span class="p_add">+efi_gdt64:</span>
<span class="p_add">+	.word	efi_gdt64_end - efi_gdt64</span>
<span class="p_add">+	.long	0			/* Filled out by user */</span>
<span class="p_add">+	.word	0</span>
<span class="p_add">+	.quad	0x0000000000000000	/* NULL descriptor */</span>
<span class="p_add">+	.quad	0x00af9a000000ffff	/* __KERNEL_CS */</span>
<span class="p_add">+	.quad	0x00cf92000000ffff	/* __KERNEL_DS */</span>
<span class="p_add">+	.quad	0x0080890000000000	/* TS descriptor */</span>
<span class="p_add">+	.quad   0x0000000000000000	/* TS continued */</span>
<span class="p_add">+efi_gdt64_end:</span>
<span class="p_header">diff --git a/arch/x86/crypto/sha1_ssse3_glue.c b/arch/x86/crypto/sha1_ssse3_glue.c</span>
<span class="p_header">index 6c20fe04a738..ba9c75c5a432 100644</span>
<span class="p_header">--- a/arch/x86/crypto/sha1_ssse3_glue.c</span>
<span class="p_header">+++ b/arch/x86/crypto/sha1_ssse3_glue.c</span>
<span class="p_chunk">@@ -224,7 +224,8 @@</span> <span class="p_context"> static bool __init avx_usable(void)</span>
 #ifdef CONFIG_AS_AVX2
 static bool __init avx2_usable(void)
 {
<span class="p_del">-	if (avx_usable() &amp;&amp; cpu_has_avx2 &amp;&amp; boot_cpu_has(X86_FEATURE_BMI1) &amp;&amp;</span>
<span class="p_add">+	if (false &amp;&amp; avx_usable() &amp;&amp; cpu_has_avx2 &amp;&amp;</span>
<span class="p_add">+	    boot_cpu_has(X86_FEATURE_BMI1) &amp;&amp;</span>
 	    boot_cpu_has(X86_FEATURE_BMI2))
 		return true;
 
<span class="p_header">diff --git a/arch/x86/include/asm/xen/hypercall.h b/arch/x86/include/asm/xen/hypercall.h</span>
<span class="p_header">index ca08a27b90b3..4ad5a91aea79 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/xen/hypercall.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/xen/hypercall.h</span>
<span class="p_chunk">@@ -43,6 +43,7 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/page.h&gt;
 #include &lt;asm/pgtable.h&gt;
<span class="p_add">+#include &lt;asm/smap.h&gt;</span>
 
 #include &lt;xen/interface/xen.h&gt;
 #include &lt;xen/interface/sched.h&gt;
<span class="p_chunk">@@ -213,10 +214,12 @@</span> <span class="p_context"> privcmd_call(unsigned call,</span>
 	__HYPERCALL_DECLS;
 	__HYPERCALL_5ARG(a1, a2, a3, a4, a5);
 
<span class="p_add">+	stac();</span>
 	asm volatile(&quot;call *%[call]&quot;
 		     : __HYPERCALL_5PARAM
 		     : [call] &quot;a&quot; (&amp;hypercall_page[call])
 		     : __HYPERCALL_CLOBBER5);
<span class="p_add">+	clac();</span>
 
 	return (long)__res;
 }
<span class="p_header">diff --git a/arch/x86/include/uapi/asm/msr-index.h b/arch/x86/include/uapi/asm/msr-index.h</span>
<span class="p_header">index 7db049a7f7ab..392ef72ea41c 100644</span>
<span class="p_header">--- a/arch/x86/include/uapi/asm/msr-index.h</span>
<span class="p_header">+++ b/arch/x86/include/uapi/asm/msr-index.h</span>
<span class="p_chunk">@@ -298,6 +298,8 @@</span> <span class="p_context"></span>
 #define MSR_IA32_TSC_ADJUST             0x0000003b
 #define MSR_IA32_BNDCFGS		0x00000d90
 
<span class="p_add">+#define MSR_IA32_BNDCFGS_RSVD		0x00000ffc</span>
<span class="p_add">+</span>
 #define FEATURE_CONTROL_LOCKED				(1&lt;&lt;0)
 #define FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX	(1&lt;&lt;1)
 #define FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX	(1&lt;&lt;2)
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event_intel.c b/arch/x86/kernel/cpu/perf_event_intel.c</span>
<span class="p_header">index 38b5a3514c7d..73112b9023cd 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event_intel.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event_intel.c</span>
<span class="p_chunk">@@ -2642,13 +2642,13 @@</span> <span class="p_context"> __init int intel_pmu_init(void)</span>
 		 * counter, so do not extend mask to generic counters
 		 */
 		for_each_event_constraint(c, x86_pmu.event_constraints) {
<span class="p_del">-			if (c-&gt;cmask != FIXED_EVENT_FLAGS</span>
<span class="p_del">-			    || c-&gt;idxmsk64 == INTEL_PMC_MSK_FIXED_REF_CYCLES) {</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+			if (c-&gt;cmask == FIXED_EVENT_FLAGS</span>
<span class="p_add">+			    &amp;&amp; c-&gt;idxmsk64 != INTEL_PMC_MSK_FIXED_REF_CYCLES) {</span>
<span class="p_add">+				c-&gt;idxmsk64 |= (1ULL &lt;&lt; x86_pmu.num_counters) - 1;</span>
 			}
<span class="p_del">-</span>
<span class="p_del">-			c-&gt;idxmsk64 |= (1ULL &lt;&lt; x86_pmu.num_counters) - 1;</span>
<span class="p_del">-			c-&gt;weight += x86_pmu.num_counters;</span>
<span class="p_add">+			c-&gt;idxmsk64 &amp;=</span>
<span class="p_add">+				~(~0ULL &lt;&lt; (INTEL_PMC_IDX_FIXED + x86_pmu.num_counters_fixed));</span>
<span class="p_add">+			c-&gt;weight = hweight64(c-&gt;idxmsk64);</span>
 		}
 	}
 
<span class="p_header">diff --git a/arch/x86/kernel/nmi_selftest.c b/arch/x86/kernel/nmi_selftest.c</span>
<span class="p_header">index 6d9582ec0324..d27f8d84c4ff 100644</span>
<span class="p_header">--- a/arch/x86/kernel/nmi_selftest.c</span>
<span class="p_header">+++ b/arch/x86/kernel/nmi_selftest.c</span>
<span class="p_chunk">@@ -78,7 +78,7 @@</span> <span class="p_context"> static void __init test_nmi_ipi(struct cpumask *mask)</span>
 
 	/* Don&#39;t wait longer than a second */
 	timeout = USEC_PER_SEC;
<span class="p_del">-	while (!cpumask_empty(mask) &amp;&amp; timeout--)</span>
<span class="p_add">+	while (!cpumask_empty(mask) &amp;&amp; --timeout)</span>
 	        udelay(1);
 
 	/* What happens if we timeout, do we still unregister?? */
<span class="p_header">diff --git a/arch/x86/kvm/cpuid.h b/arch/x86/kvm/cpuid.h</span>
<span class="p_header">index f9087315e0cd..06fa616e3f69 100644</span>
<span class="p_header">--- a/arch/x86/kvm/cpuid.h</span>
<span class="p_header">+++ b/arch/x86/kvm/cpuid.h</span>
<span class="p_chunk">@@ -95,4 +95,13 @@</span> <span class="p_context"> static inline bool guest_cpuid_has_gbpages(struct kvm_vcpu *vcpu)</span>
 	best = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);
 	return best &amp;&amp; (best-&gt;edx &amp; bit(X86_FEATURE_GBPAGES));
 }
<span class="p_add">+</span>
<span class="p_add">+static inline bool guest_cpuid_has_mpx(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct kvm_cpuid_entry2 *best;</span>
<span class="p_add">+</span>
<span class="p_add">+	best = kvm_find_cpuid_entry(vcpu, 7, 0);</span>
<span class="p_add">+	return best &amp;&amp; (best-&gt;ebx &amp; bit(X86_FEATURE_MPX));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 56772d2781b0..50a1d48b1419 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -2514,7 +2514,7 @@</span> <span class="p_context"> static int vmx_get_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 *pdata)</span>
 		data = vmcs_readl(GUEST_SYSENTER_ESP);
 		break;
 	case MSR_IA32_BNDCFGS:
<span class="p_del">-		if (!vmx_mpx_supported())</span>
<span class="p_add">+		if (!vmx_mpx_supported() || !guest_cpuid_has_mpx(vcpu))</span>
 			return 1;
 		data = vmcs_read64(GUEST_BNDCFGS);
 		break;
<span class="p_chunk">@@ -2587,7 +2587,10 @@</span> <span class="p_context"> static int vmx_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)</span>
 		vmcs_writel(GUEST_SYSENTER_ESP, data);
 		break;
 	case MSR_IA32_BNDCFGS:
<span class="p_del">-		if (!vmx_mpx_supported())</span>
<span class="p_add">+		if (!vmx_mpx_supported() || !guest_cpuid_has_mpx(vcpu))</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+		if (is_noncanonical_address(data &amp; PAGE_MASK) ||</span>
<span class="p_add">+		    (data &amp; MSR_IA32_BNDCFGS_RSVD))</span>
 			return 1;
 		vmcs_write64(GUEST_BNDCFGS, data);
 		break;
<span class="p_chunk">@@ -8045,6 +8048,14 @@</span> <span class="p_context"> static void prepare_vmcs02(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)</span>
 	exec_control &amp;= ~CPU_BASED_VIRTUAL_NMI_PENDING;
 	exec_control &amp;= ~CPU_BASED_TPR_SHADOW;
 	exec_control |= vmcs12-&gt;cpu_based_vm_exec_control;
<span class="p_add">+</span>
<span class="p_add">+ 	if (!(exec_control &amp; CPU_BASED_TPR_SHADOW)) {</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+		exec_control |= CPU_BASED_CR8_LOAD_EXITING |</span>
<span class="p_add">+				CPU_BASED_CR8_STORE_EXITING;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * Merging of IO and MSR bitmaps not currently supported.
 	 * Rather, exit every time.
<span class="p_chunk">@@ -9048,7 +9059,6 @@</span> <span class="p_context"> static int __init vmx_init(void)</span>
 	vmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_CS, false);
 	vmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_ESP, false);
 	vmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_EIP, false);
<span class="p_del">-	vmx_disable_intercept_for_msr(MSR_IA32_BNDCFGS, true);</span>
 
 	memcpy(vmx_msr_bitmap_legacy_x2apic,
 			vmx_msr_bitmap_legacy, PAGE_SIZE);
<span class="p_header">diff --git a/arch/x86/pci/fixup.c b/arch/x86/pci/fixup.c</span>
<span class="p_header">index 156fbb69031c..4c0cfc53263b 100644</span>
<span class="p_header">--- a/arch/x86/pci/fixup.c</span>
<span class="p_header">+++ b/arch/x86/pci/fixup.c</span>
<span class="p_chunk">@@ -555,15 +555,53 @@</span> <span class="p_context"> static void twinhead_reserve_killing_zone(struct pci_dev *dev)</span>
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x27B9, twinhead_reserve_killing_zone);
 
 /*
<span class="p_del">- * Broadwell EP Home Agent BARs erroneously return non-zero values when read.</span>
<span class="p_add">+ * Device [8086:2fc0]</span>
<span class="p_add">+ * Erratum HSE43</span>
<span class="p_add">+ * CONFIG_TDP_NOMINAL CSR Implemented at Incorrect Offset</span>
<span class="p_add">+ * http://www.intel.com/content/www/us/en/processors/xeon/xeon-e5-v3-spec-update.html</span>
  *
<span class="p_del">- * See http://www.intel.com/content/www/us/en/processors/xeon/xeon-e5-v4-spec-update.html</span>
<span class="p_del">- * entry BDF2.</span>
<span class="p_add">+ * Devices [8086:6f60,6fa0,6fc0]</span>
<span class="p_add">+ * Erratum BDF2</span>
<span class="p_add">+ * PCI BARs in the Home Agent Will Return Non-Zero Values During Enumeration</span>
<span class="p_add">+ * http://www.intel.com/content/www/us/en/processors/xeon/xeon-e5-v4-spec-update.html</span>
  */
<span class="p_del">-static void pci_bdwep_bar(struct pci_dev *dev)</span>
<span class="p_add">+static void pci_invalid_bar(struct pci_dev *dev)</span>
 {
 	dev-&gt;non_compliant_bars = 1;
 }
<span class="p_del">-DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x6f60, pci_bdwep_bar);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x6fa0, pci_bdwep_bar);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x6fc0, pci_bdwep_bar);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x2fc0, pci_invalid_bar);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x6f60, pci_invalid_bar);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x6fa0, pci_invalid_bar);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x6fc0, pci_invalid_bar);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Apple MacBook Pro: Avoid [mem 0x7fa00000-0x7fbfffff]</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Using the [mem 0x7fa00000-0x7fbfffff] region, e.g., by assigning it to</span>
<span class="p_add">+ * the 00:1c.0 Root Port, causes a conflict with [io 0x1804], which is used</span>
<span class="p_add">+ * for soft poweroff and suspend-to-RAM.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * As far as we know, this is related to the address space, not to the Root</span>
<span class="p_add">+ * Port itself.  Attaching the quirk to the Root Port is a convenience, but</span>
<span class="p_add">+ * it could probably also be a standalone DMI quirk.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * https://bugzilla.kernel.org/show_bug.cgi?id=103211</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void quirk_apple_mbp_poweroff(struct pci_dev *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device *dev = &amp;pdev-&gt;dev;</span>
<span class="p_add">+	struct resource *res;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((!dmi_match(DMI_PRODUCT_NAME, &quot;MacBookPro11,4&quot;) &amp;&amp;</span>
<span class="p_add">+	     !dmi_match(DMI_PRODUCT_NAME, &quot;MacBookPro11,5&quot;)) ||</span>
<span class="p_add">+	    pdev-&gt;bus-&gt;number != 0 || pdev-&gt;devfn != PCI_DEVFN(0x1c, 0))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	res = request_mem_region(0x7fa00000, 0x200000,</span>
<span class="p_add">+				 &quot;MacBook Pro poweroff workaround&quot;);</span>
<span class="p_add">+	if (res)</span>
<span class="p_add">+		dev_info(dev, &quot;claimed %s %pR\n&quot;, res-&gt;name, res);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		dev_info(dev, &quot;can&#39;t work around MacBook Pro poweroff issue\n&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x8c10, quirk_apple_mbp_poweroff);</span>
<span class="p_header">diff --git a/arch/x86/platform/efi/efi_stub_64.S b/arch/x86/platform/efi/efi_stub_64.S</span>
<span class="p_header">index 5fcda7272550..86d0f9e08dd9 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi_stub_64.S</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi_stub_64.S</span>
<span class="p_chunk">@@ -91,167 +91,6 @@</span> <span class="p_context"> ENTRY(efi_call)</span>
 	ret
 ENDPROC(efi_call)
 
<span class="p_del">-#ifdef CONFIG_EFI_MIXED</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * We run this function from the 1:1 mapping.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This function must be invoked with a 1:1 mapped stack.</span>
<span class="p_del">- */</span>
<span class="p_del">-ENTRY(__efi64_thunk)</span>
<span class="p_del">-	movl	%ds, %eax</span>
<span class="p_del">-	push	%rax</span>
<span class="p_del">-	movl	%es, %eax</span>
<span class="p_del">-	push	%rax</span>
<span class="p_del">-	movl	%ss, %eax</span>
<span class="p_del">-	push	%rax</span>
<span class="p_del">-</span>
<span class="p_del">-	subq	$32, %rsp</span>
<span class="p_del">-	movl	%esi, 0x0(%rsp)</span>
<span class="p_del">-	movl	%edx, 0x4(%rsp)</span>
<span class="p_del">-	movl	%ecx, 0x8(%rsp)</span>
<span class="p_del">-	movq	%r8, %rsi</span>
<span class="p_del">-	movl	%esi, 0xc(%rsp)</span>
<span class="p_del">-	movq	%r9, %rsi</span>
<span class="p_del">-	movl	%esi,  0x10(%rsp)</span>
<span class="p_del">-</span>
<span class="p_del">-	sgdt	save_gdt(%rip)</span>
<span class="p_del">-</span>
<span class="p_del">-	leaq	1f(%rip), %rbx</span>
<span class="p_del">-	movq	%rbx, func_rt_ptr(%rip)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Switch to gdt with 32-bit segments */</span>
<span class="p_del">-	movl	64(%rsp), %eax</span>
<span class="p_del">-	lgdt	(%rax)</span>
<span class="p_del">-</span>
<span class="p_del">-	leaq	efi_enter32(%rip), %rax</span>
<span class="p_del">-	pushq	$__KERNEL_CS</span>
<span class="p_del">-	pushq	%rax</span>
<span class="p_del">-	lretq</span>
<span class="p_del">-</span>
<span class="p_del">-1:	addq	$32, %rsp</span>
<span class="p_del">-</span>
<span class="p_del">-	lgdt	save_gdt(%rip)</span>
<span class="p_del">-</span>
<span class="p_del">-	pop	%rbx</span>
<span class="p_del">-	movl	%ebx, %ss</span>
<span class="p_del">-	pop	%rbx</span>
<span class="p_del">-	movl	%ebx, %es</span>
<span class="p_del">-	pop	%rbx</span>
<span class="p_del">-	movl	%ebx, %ds</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Convert 32-bit status code into 64-bit.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	test	%rax, %rax</span>
<span class="p_del">-	jz	1f</span>
<span class="p_del">-	movl	%eax, %ecx</span>
<span class="p_del">-	andl	$0x0fffffff, %ecx</span>
<span class="p_del">-	andl	$0xf0000000, %eax</span>
<span class="p_del">-	shl	$32, %rax</span>
<span class="p_del">-	or	%rcx, %rax</span>
<span class="p_del">-1:</span>
<span class="p_del">-	ret</span>
<span class="p_del">-ENDPROC(__efi64_thunk)</span>
<span class="p_del">-</span>
<span class="p_del">-ENTRY(efi_exit32)</span>
<span class="p_del">-	movq	func_rt_ptr(%rip), %rax</span>
<span class="p_del">-	push	%rax</span>
<span class="p_del">-	mov	%rdi, %rax</span>
<span class="p_del">-	ret</span>
<span class="p_del">-ENDPROC(efi_exit32)</span>
<span class="p_del">-</span>
<span class="p_del">-	.code32</span>
<span class="p_del">-/*</span>
<span class="p_del">- * EFI service pointer must be in %edi.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The stack should represent the 32-bit calling convention.</span>
<span class="p_del">- */</span>
<span class="p_del">-ENTRY(efi_enter32)</span>
<span class="p_del">-	movl	$__KERNEL_DS, %eax</span>
<span class="p_del">-	movl	%eax, %ds</span>
<span class="p_del">-	movl	%eax, %es</span>
<span class="p_del">-	movl	%eax, %ss</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Reload pgtables */</span>
<span class="p_del">-	movl	%cr3, %eax</span>
<span class="p_del">-	movl	%eax, %cr3</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Disable paging */</span>
<span class="p_del">-	movl	%cr0, %eax</span>
<span class="p_del">-	btrl	$X86_CR0_PG_BIT, %eax</span>
<span class="p_del">-	movl	%eax, %cr0</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Disable long mode via EFER */</span>
<span class="p_del">-	movl	$MSR_EFER, %ecx</span>
<span class="p_del">-	rdmsr</span>
<span class="p_del">-	btrl	$_EFER_LME, %eax</span>
<span class="p_del">-	wrmsr</span>
<span class="p_del">-</span>
<span class="p_del">-	call	*%edi</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We must preserve return value */</span>
<span class="p_del">-	movl	%eax, %edi</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Some firmware will return with interrupts enabled. Be sure to</span>
<span class="p_del">-	 * disable them before we switch GDTs.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	cli</span>
<span class="p_del">-</span>
<span class="p_del">-	movl	68(%esp), %eax</span>
<span class="p_del">-	movl	%eax, 2(%eax)</span>
<span class="p_del">-	lgdtl	(%eax)</span>
<span class="p_del">-</span>
<span class="p_del">-	movl	%cr4, %eax</span>
<span class="p_del">-	btsl	$(X86_CR4_PAE_BIT), %eax</span>
<span class="p_del">-	movl	%eax, %cr4</span>
<span class="p_del">-</span>
<span class="p_del">-	movl	%cr3, %eax</span>
<span class="p_del">-	movl	%eax, %cr3</span>
<span class="p_del">-</span>
<span class="p_del">-	movl	$MSR_EFER, %ecx</span>
<span class="p_del">-	rdmsr</span>
<span class="p_del">-	btsl	$_EFER_LME, %eax</span>
<span class="p_del">-	wrmsr</span>
<span class="p_del">-</span>
<span class="p_del">-	xorl	%eax, %eax</span>
<span class="p_del">-	lldt	%ax</span>
<span class="p_del">-</span>
<span class="p_del">-	movl	72(%esp), %eax</span>
<span class="p_del">-	pushl	$__KERNEL_CS</span>
<span class="p_del">-	pushl	%eax</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Enable paging */</span>
<span class="p_del">-	movl	%cr0, %eax</span>
<span class="p_del">-	btsl	$X86_CR0_PG_BIT, %eax</span>
<span class="p_del">-	movl	%eax, %cr0</span>
<span class="p_del">-	lret</span>
<span class="p_del">-ENDPROC(efi_enter32)</span>
<span class="p_del">-</span>
<span class="p_del">-	.data</span>
<span class="p_del">-	.balign	8</span>
<span class="p_del">-	.global	efi32_boot_gdt</span>
<span class="p_del">-efi32_boot_gdt:	.word	0</span>
<span class="p_del">-		.quad	0</span>
<span class="p_del">-</span>
<span class="p_del">-save_gdt:	.word	0</span>
<span class="p_del">-		.quad	0</span>
<span class="p_del">-func_rt_ptr:	.quad	0</span>
<span class="p_del">-</span>
<span class="p_del">-	.global efi_gdt64</span>
<span class="p_del">-efi_gdt64:</span>
<span class="p_del">-	.word	efi_gdt64_end - efi_gdt64</span>
<span class="p_del">-	.long	0			/* Filled out by user */</span>
<span class="p_del">-	.word	0</span>
<span class="p_del">-	.quad	0x0000000000000000	/* NULL descriptor */</span>
<span class="p_del">-	.quad	0x00af9a000000ffff	/* __KERNEL_CS */</span>
<span class="p_del">-	.quad	0x00cf92000000ffff	/* __KERNEL_DS */</span>
<span class="p_del">-	.quad	0x0080890000000000	/* TS descriptor */</span>
<span class="p_del">-	.quad   0x0000000000000000	/* TS continued */</span>
<span class="p_del">-efi_gdt64_end:</span>
<span class="p_del">-#endif /* CONFIG_EFI_MIXED */</span>
<span class="p_del">-</span>
 	.data
 ENTRY(efi_scratch)
 	.fill 3,8,0
<span class="p_header">diff --git a/arch/x86/platform/efi/efi_thunk_64.S b/arch/x86/platform/efi/efi_thunk_64.S</span>
<span class="p_header">index 8806fa73e6e6..ff85d28c50f2 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi_thunk_64.S</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi_thunk_64.S</span>
<span class="p_chunk">@@ -1,9 +1,26 @@</span> <span class="p_context"></span>
 /*
  * Copyright (C) 2014 Intel Corporation; author Matt Fleming
<span class="p_add">+ *</span>
<span class="p_add">+ * Support for invoking 32-bit EFI runtime services from a 64-bit</span>
<span class="p_add">+ * kernel.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The below thunking functions are only used after ExitBootServices()</span>
<span class="p_add">+ * has been called. This simplifies things considerably as compared with</span>
<span class="p_add">+ * the early EFI thunking because we can leave all the kernel state</span>
<span class="p_add">+ * intact (GDT, IDT, etc) and simply invoke the the 32-bit EFI runtime</span>
<span class="p_add">+ * services from __KERNEL32_CS. This means we can continue to service</span>
<span class="p_add">+ * interrupts across an EFI mixed mode call.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * We do however, need to handle the fact that we&#39;re running in a full</span>
<span class="p_add">+ * 64-bit virtual address space. Things like the stack and instruction</span>
<span class="p_add">+ * addresses need to be accessible by the 32-bit firmware, so we rely on</span>
<span class="p_add">+ * using the identity mappings in the EFI page table to access the stack</span>
<span class="p_add">+ * and kernel text (see efi_setup_page_tables()).</span>
  */
 
 #include &lt;linux/linkage.h&gt;
 #include &lt;asm/page_types.h&gt;
<span class="p_add">+#include &lt;asm/segment.h&gt;</span>
 
 	.text
 	.code64
<span class="p_chunk">@@ -33,14 +50,6 @@</span> <span class="p_context"> ENTRY(efi64_thunk)</span>
 	leaq	efi_exit32(%rip), %rbx
 	subq	%rax, %rbx
 	movl	%ebx, 8(%rsp)
<span class="p_del">-	leaq	efi_gdt64(%rip), %rbx</span>
<span class="p_del">-	subq	%rax, %rbx</span>
<span class="p_del">-	movl	%ebx, 2(%ebx)</span>
<span class="p_del">-	movl	%ebx, 4(%rsp)</span>
<span class="p_del">-	leaq	efi_gdt32(%rip), %rbx</span>
<span class="p_del">-	subq	%rax, %rbx</span>
<span class="p_del">-	movl	%ebx, 2(%ebx)</span>
<span class="p_del">-	movl	%ebx, (%rsp)</span>
 
 	leaq	__efi64_thunk(%rip), %rbx
 	subq	%rax, %rbx
<span class="p_chunk">@@ -52,14 +61,92 @@</span> <span class="p_context"> ENTRY(efi64_thunk)</span>
 	retq
 ENDPROC(efi64_thunk)
 
<span class="p_del">-	.data</span>
<span class="p_del">-efi_gdt32:</span>
<span class="p_del">-	.word 	efi_gdt32_end - efi_gdt32</span>
<span class="p_del">-	.long	0			/* Filled out above */</span>
<span class="p_del">-	.word	0</span>
<span class="p_del">-	.quad	0x0000000000000000	/* NULL descriptor */</span>
<span class="p_del">-	.quad	0x00cf9a000000ffff	/* __KERNEL_CS */</span>
<span class="p_del">-	.quad	0x00cf93000000ffff	/* __KERNEL_DS */</span>
<span class="p_del">-efi_gdt32_end:</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * We run this function from the 1:1 mapping.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This function must be invoked with a 1:1 mapped stack.</span>
<span class="p_add">+ */</span>
<span class="p_add">+ENTRY(__efi64_thunk)</span>
<span class="p_add">+	movl	%ds, %eax</span>
<span class="p_add">+	push	%rax</span>
<span class="p_add">+	movl	%es, %eax</span>
<span class="p_add">+	push	%rax</span>
<span class="p_add">+	movl	%ss, %eax</span>
<span class="p_add">+	push	%rax</span>
<span class="p_add">+</span>
<span class="p_add">+	subq	$32, %rsp</span>
<span class="p_add">+	movl	%esi, 0x0(%rsp)</span>
<span class="p_add">+	movl	%edx, 0x4(%rsp)</span>
<span class="p_add">+	movl	%ecx, 0x8(%rsp)</span>
<span class="p_add">+	movq	%r8, %rsi</span>
<span class="p_add">+	movl	%esi, 0xc(%rsp)</span>
<span class="p_add">+	movq	%r9, %rsi</span>
<span class="p_add">+	movl	%esi,  0x10(%rsp)</span>
<span class="p_add">+</span>
<span class="p_add">+	leaq	1f(%rip), %rbx</span>
<span class="p_add">+	movq	%rbx, func_rt_ptr(%rip)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Switch to 32-bit descriptor */</span>
<span class="p_add">+	pushq	$__KERNEL32_CS</span>
<span class="p_add">+	leaq	efi_enter32(%rip), %rax</span>
<span class="p_add">+	pushq	%rax</span>
<span class="p_add">+	lretq</span>
<span class="p_add">+</span>
<span class="p_add">+1:	addq	$32, %rsp</span>
<span class="p_add">+</span>
<span class="p_add">+	pop	%rbx</span>
<span class="p_add">+	movl	%ebx, %ss</span>
<span class="p_add">+	pop	%rbx</span>
<span class="p_add">+	movl	%ebx, %es</span>
<span class="p_add">+	pop	%rbx</span>
<span class="p_add">+	movl	%ebx, %ds</span>
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Convert 32-bit status code into 64-bit.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	test	%rax, %rax</span>
<span class="p_add">+	jz	1f</span>
<span class="p_add">+	movl	%eax, %ecx</span>
<span class="p_add">+	andl	$0x0fffffff, %ecx</span>
<span class="p_add">+	andl	$0xf0000000, %eax</span>
<span class="p_add">+	shl	$32, %rax</span>
<span class="p_add">+	or	%rcx, %rax</span>
<span class="p_add">+1:</span>
<span class="p_add">+	ret</span>
<span class="p_add">+ENDPROC(__efi64_thunk)</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(efi_exit32)</span>
<span class="p_add">+	movq	func_rt_ptr(%rip), %rax</span>
<span class="p_add">+	push	%rax</span>
<span class="p_add">+	mov	%rdi, %rax</span>
<span class="p_add">+	ret</span>
<span class="p_add">+ENDPROC(efi_exit32)</span>
<span class="p_add">+</span>
<span class="p_add">+	.code32</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * EFI service pointer must be in %edi.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The stack should represent the 32-bit calling convention.</span>
<span class="p_add">+ */</span>
<span class="p_add">+ENTRY(efi_enter32)</span>
<span class="p_add">+	movl	$__KERNEL_DS, %eax</span>
<span class="p_add">+	movl	%eax, %ds</span>
<span class="p_add">+	movl	%eax, %es</span>
<span class="p_add">+	movl	%eax, %ss</span>
<span class="p_add">+</span>
<span class="p_add">+	call	*%edi</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We must preserve return value */</span>
<span class="p_add">+	movl	%eax, %edi</span>
<span class="p_add">+</span>
<span class="p_add">+	movl	72(%esp), %eax</span>
<span class="p_add">+	pushl	$__KERNEL_CS</span>
<span class="p_add">+	pushl	%eax</span>
<span class="p_add">+</span>
<span class="p_add">+	lret</span>
<span class="p_add">+ENDPROC(efi_enter32)</span>
<span class="p_add">+</span>
<span class="p_add">+	.data</span>
<span class="p_add">+	.balign	8</span>
<span class="p_add">+func_rt_ptr:		.quad 0</span>
 efi_saved_sp:		.quad 0
<span class="p_header">diff --git a/drivers/acpi/ec.c b/drivers/acpi/ec.c</span>
<span class="p_header">index 4b45f55dd6a9..745c6ac2fead 100644</span>
<span class="p_header">--- a/drivers/acpi/ec.c</span>
<span class="p_header">+++ b/drivers/acpi/ec.c</span>
<span class="p_chunk">@@ -299,11 +299,11 @@</span> <span class="p_context"> static int acpi_ec_transaction_unlocked(struct acpi_ec *ec,</span>
 	/* following two actions should be kept atomic */
 	ec-&gt;curr = t;
 	start_transaction(ec);
<span class="p_add">+	if (ec-&gt;curr-&gt;command == ACPI_EC_COMMAND_QUERY)</span>
<span class="p_add">+		clear_bit(EC_FLAGS_QUERY_PENDING, &amp;ec-&gt;flags);</span>
 	spin_unlock_irqrestore(&amp;ec-&gt;lock, tmp);
 	ret = ec_poll(ec);
 	spin_lock_irqsave(&amp;ec-&gt;lock, tmp);
<span class="p_del">-	if (ec-&gt;curr-&gt;command == ACPI_EC_COMMAND_QUERY)</span>
<span class="p_del">-		clear_bit(EC_FLAGS_QUERY_PENDING, &amp;ec-&gt;flags);</span>
 	ec-&gt;curr = NULL;
 	spin_unlock_irqrestore(&amp;ec-&gt;lock, tmp);
 	return ret;
<span class="p_header">diff --git a/drivers/base/power/domain.c b/drivers/base/power/domain.c</span>
<span class="p_header">index eee55c1e5fde..5f2e21e9fbb1 100644</span>
<span class="p_header">--- a/drivers/base/power/domain.c</span>
<span class="p_header">+++ b/drivers/base/power/domain.c</span>
<span class="p_chunk">@@ -1704,7 +1704,7 @@</span> <span class="p_context"> int pm_genpd_add_subdomain_names(const char *master_name,</span>
 int pm_genpd_remove_subdomain(struct generic_pm_domain *genpd,
 			      struct generic_pm_domain *subdomain)
 {
<span class="p_del">-	struct gpd_link *link;</span>
<span class="p_add">+	struct gpd_link *l, *link;</span>
 	int ret = -EINVAL;
 
 	if (IS_ERR_OR_NULL(genpd) || IS_ERR_OR_NULL(subdomain))
<span class="p_chunk">@@ -1713,7 +1713,7 @@</span> <span class="p_context"> int pm_genpd_remove_subdomain(struct generic_pm_domain *genpd,</span>
  start:
 	genpd_acquire_lock(genpd);
 
<span class="p_del">-	list_for_each_entry(link, &amp;genpd-&gt;master_links, master_node) {</span>
<span class="p_add">+	list_for_each_entry_safe(link, l, &amp;genpd-&gt;master_links, master_node) {</span>
 		if (link-&gt;slave != subdomain)
 			continue;
 
<span class="p_header">diff --git a/drivers/base/power/sysfs.c b/drivers/base/power/sysfs.c</span>
<span class="p_header">index 95b181d1ca6d..0ed019c8012f 100644</span>
<span class="p_header">--- a/drivers/base/power/sysfs.c</span>
<span class="p_header">+++ b/drivers/base/power/sysfs.c</span>
<span class="p_chunk">@@ -272,6 +272,8 @@</span> <span class="p_context"> static ssize_t pm_qos_latency_tolerance_store(struct device *dev,</span>
 			value = PM_QOS_LATENCY_TOLERANCE_NO_CONSTRAINT;
 		else if (!strcmp(buf, &quot;any&quot;) || !strcmp(buf, &quot;any\n&quot;))
 			value = PM_QOS_LATENCY_ANY;
<span class="p_add">+		else</span>
<span class="p_add">+			return -EINVAL;</span>
 	}
 	ret = dev_pm_qos_update_user_latency_tolerance(dev, value);
 	return ret &lt; 0 ? ret : n;
<span class="p_header">diff --git a/drivers/char/tpm/tpm-sysfs.c b/drivers/char/tpm/tpm-sysfs.c</span>
<span class="p_header">index 01730a27ae07..994fb055e99d 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm-sysfs.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm-sysfs.c</span>
<span class="p_chunk">@@ -54,9 +54,10 @@</span> <span class="p_context"> static ssize_t pubek_show(struct device *dev, struct device_attribute *attr,</span>
 	ssize_t err;
 	int i, rc;
 	char *str = buf;
<span class="p_del">-</span>
 	struct tpm_chip *chip = dev_get_drvdata(dev);
 
<span class="p_add">+	memset(&amp;tpm_cmd, 0, sizeof(tpm_cmd));</span>
<span class="p_add">+</span>
 	tpm_cmd.header.in = tpm_readpubek_header;
 	err = transmit_cmd(chip, &amp;tpm_cmd, READ_PUBEK_RESULT_SIZE,
 			   &quot;attempting to read the PUBEK&quot;);
<span class="p_header">diff --git a/drivers/crypto/atmel-sha.c b/drivers/crypto/atmel-sha.c</span>
<span class="p_header">index 0618be06b9fb..e4ccf1046765 100644</span>
<span class="p_header">--- a/drivers/crypto/atmel-sha.c</span>
<span class="p_header">+++ b/drivers/crypto/atmel-sha.c</span>
<span class="p_chunk">@@ -957,7 +957,9 @@</span> <span class="p_context"> static int atmel_sha_finup(struct ahash_request *req)</span>
 	ctx-&gt;flags |= SHA_FLAGS_FINUP;
 
 	err1 = atmel_sha_update(req);
<span class="p_del">-	if (err1 == -EINPROGRESS || err1 == -EBUSY)</span>
<span class="p_add">+	if (err1 == -EINPROGRESS ||</span>
<span class="p_add">+	    (err1 == -EBUSY &amp;&amp; (ahash_request_flags(req) &amp;</span>
<span class="p_add">+				CRYPTO_TFM_REQ_MAY_BACKLOG)))</span>
 		return err1;
 
 	/*
<span class="p_header">diff --git a/drivers/crypto/caam/caamhash.c b/drivers/crypto/caam/caamhash.c</span>
<span class="p_header">index 4f03b1a14d62..80f3f9b64033 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/caamhash.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/caamhash.c</span>
<span class="p_chunk">@@ -478,7 +478,7 @@</span> <span class="p_context"> static int hash_digest_key(struct caam_hash_ctx *ctx, const u8 *key_in,</span>
 	ret = caam_jr_enqueue(jrdev, desc, split_key_done, &amp;result);
 	if (!ret) {
 		/* in progress */
<span class="p_del">-		wait_for_completion_interruptible(&amp;result.completion);</span>
<span class="p_add">+		wait_for_completion(&amp;result.completion);</span>
 		ret = result.err;
 #ifdef DEBUG
 		print_hex_dump(KERN_ERR,
<span class="p_header">diff --git a/drivers/crypto/caam/key_gen.c b/drivers/crypto/caam/key_gen.c</span>
<span class="p_header">index e1eaf4ff9762..3ce1d5cdcbd2 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/key_gen.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/key_gen.c</span>
<span class="p_chunk">@@ -103,7 +103,7 @@</span> <span class="p_context"> int gen_split_key(struct device *jrdev, u8 *key_out, int split_key_len,</span>
 	ret = caam_jr_enqueue(jrdev, desc, split_key_done, &amp;result);
 	if (!ret) {
 		/* in progress */
<span class="p_del">-		wait_for_completion_interruptible(&amp;result.completion);</span>
<span class="p_add">+		wait_for_completion(&amp;result.completion);</span>
 		ret = result.err;
 #ifdef DEBUG
 		print_hex_dump(KERN_ERR, &quot;ctx.key@&quot;__stringify(__LINE__)&quot;: &quot;,
<span class="p_header">diff --git a/drivers/crypto/talitos.c b/drivers/crypto/talitos.c</span>
<span class="p_header">index da328ed633fb..c6bd28c59d65 100644</span>
<span class="p_header">--- a/drivers/crypto/talitos.c</span>
<span class="p_header">+++ b/drivers/crypto/talitos.c</span>
<span class="p_chunk">@@ -634,7 +634,7 @@</span> <span class="p_context"> static void talitos_unregister_rng(struct device *dev)</span>
  * crypto alg
  */
 #define TALITOS_CRA_PRIORITY		3000
<span class="p_del">-#define TALITOS_MAX_KEY_SIZE		96</span>
<span class="p_add">+#define TALITOS_MAX_KEY_SIZE		(AES_MAX_KEY_SIZE + SHA512_BLOCK_SIZE)</span>
 #define TALITOS_MAX_IV_LENGTH		16 /* max of AES_BLOCK_SIZE, DES3_EDE_BLOCK_SIZE */
 
 #define MD5_BLOCK_SIZE    64
<span class="p_chunk">@@ -1324,6 +1324,11 @@</span> <span class="p_context"> static int ablkcipher_setkey(struct crypto_ablkcipher *cipher,</span>
 {
 	struct talitos_ctx *ctx = crypto_ablkcipher_ctx(cipher);
 
<span class="p_add">+	if (keylen &gt; TALITOS_MAX_KEY_SIZE) {</span>
<span class="p_add">+		crypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	memcpy(&amp;ctx-&gt;key, key, keylen);
 	ctx-&gt;keylen = keylen;
 
<span class="p_header">diff --git a/drivers/gpu/drm/drm_irq.c b/drivers/gpu/drm/drm_irq.c</span>
<span class="p_header">index 0de123afdb34..990e5ac8b18d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_irq.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_irq.c</span>
<span class="p_chunk">@@ -973,7 +973,8 @@</span> <span class="p_context"> EXPORT_SYMBOL(drm_crtc_vblank_get);</span>
  */
 void drm_vblank_put(struct drm_device *dev, int crtc)
 {
<span class="p_del">-	BUG_ON(atomic_read(&amp;dev-&gt;vblank[crtc].refcount) == 0);</span>
<span class="p_add">+	if (WARN_ON(atomic_read(&amp;dev-&gt;vblank[crtc].refcount) == 0))</span>
<span class="p_add">+		return;</span>
 
 	/* Last user schedules interrupt disable */
 	if (atomic_dec_and_test(&amp;dev-&gt;vblank[crtc].refcount) &amp;&amp;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_dma.c b/drivers/gpu/drm/i915/i915_dma.c</span>
<span class="p_header">index 646b68a58979..8bf2ae01b539 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_dma.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_dma.c</span>
<span class="p_chunk">@@ -1747,10 +1747,12 @@</span> <span class="p_context"> int i915_driver_load(struct drm_device *dev, unsigned long flags)</span>
 	 * and the registers being closely associated.
 	 *
 	 * According to chipset errata, on the 965GM, MSI interrupts may
<span class="p_del">-	 * be lost or delayed, but we use them anyways to avoid</span>
<span class="p_del">-	 * stuck interrupts on some machines.</span>
<span class="p_add">+	 * be lost or delayed, and was defeatured. MSI interrupts seem to</span>
<span class="p_add">+	 * get lost on g4x as well, and interrupt delivery seems to stay</span>
<span class="p_add">+	 * properly dead afterwards. So we&#39;ll just disable them for all</span>
<span class="p_add">+	 * pre-gen5 chipsets.</span>
 	 */
<span class="p_del">-	if (!IS_I945G(dev) &amp;&amp; !IS_I945GM(dev))</span>
<span class="p_add">+	if (INTEL_INFO(dev)-&gt;gen &gt;= 5)</span>
 		pci_enable_msi(dev-&gt;pdev);
 
 	intel_device_info_runtime_init(dev);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index 03c76d17f0de..3a3afe1b15bd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -369,7 +369,7 @@</span> <span class="p_context"> static void vlv_clock(int refclk, intel_clock_t *clock)</span>
 /**
  * Returns whether any output on the specified pipe is of the specified type
  */
<span class="p_del">-static bool intel_pipe_has_type(struct drm_crtc *crtc, int type)</span>
<span class="p_add">+bool intel_pipe_has_type(struct drm_crtc *crtc, int type)</span>
 {
 	struct drm_device *dev = crtc-&gt;dev;
 	struct intel_encoder *encoder;
<span class="p_chunk">@@ -10313,6 +10313,15 @@</span> <span class="p_context"> static void update_scanline_offset(struct intel_crtc *crtc)</span>
 	 * type. For DP ports it behaves like most other platforms, but on HDMI
 	 * there&#39;s an extra 1 line difference. So we need to add two instead of
 	 * one to the value.
<span class="p_add">+	 *</span>
<span class="p_add">+	 * On VLV/CHV DSI the scanline counter would appear to increment</span>
<span class="p_add">+	 * approx. 1/3 of a scanline before start of vblank. Unfortunately</span>
<span class="p_add">+	 * that means we can&#39;t tell whether we&#39;re in vblank or not while</span>
<span class="p_add">+	 * we&#39;re on that particular line. We must still set scanline_offset</span>
<span class="p_add">+	 * to 1 so that the vblank timestamps come out correct when we query</span>
<span class="p_add">+	 * the scanline counter from within the vblank interrupt handler.</span>
<span class="p_add">+	 * However if queried just before the start of vblank we&#39;ll get an</span>
<span class="p_add">+	 * answer that&#39;s slightly in the future.</span>
 	 */
 	if (IS_GEN2(dev)) {
 		const struct drm_display_mode *mode = &amp;crtc-&gt;config.adjusted_mode;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_drv.h b/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_header">index 4a2dbcbf13f3..508e4d8ae68d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_chunk">@@ -721,6 +721,7 @@</span> <span class="p_context"> void intel_ddi_get_config(struct intel_encoder *encoder,</span>
 const char *intel_output_name(int output);
 bool intel_has_pending_fb_unpin(struct drm_device *dev);
 int intel_pch_rawclk(struct drm_device *dev);
<span class="p_add">+bool intel_pipe_has_type(struct drm_crtc *crtc, int type);</span>
 int valleyview_cur_cdclk(struct drm_i915_private *dev_priv);
 void intel_mark_busy(struct drm_device *dev);
 void intel_mark_fb_busy(struct drm_i915_gem_object *obj,
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_sprite.c b/drivers/gpu/drm/i915/intel_sprite.c</span>
<span class="p_header">index 9a17b4e92ef4..1d1207ed2abe 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_sprite.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_sprite.c</span>
<span class="p_chunk">@@ -53,6 +53,8 @@</span> <span class="p_context"> static bool intel_pipe_update_start(struct intel_crtc *crtc, uint32_t *start_vbl</span>
 	enum pipe pipe = crtc-&gt;pipe;
 	long timeout = msecs_to_jiffies_timeout(1);
 	int scanline, min, max, vblank_start;
<span class="p_add">+	bool need_vlv_dsi_wa = (IS_VALLEYVIEW(dev) || IS_CHERRYVIEW(dev)) &amp;&amp;</span>
<span class="p_add">+		intel_pipe_has_type(&amp;crtc-&gt;base, INTEL_OUTPUT_DSI);</span>
 	DEFINE_WAIT(wait);
 
 	WARN_ON(!drm_modeset_is_locked(&amp;crtc-&gt;base.mutex));
<span class="p_chunk">@@ -104,6 +106,24 @@</span> <span class="p_context"> static bool intel_pipe_update_start(struct intel_crtc *crtc, uint32_t *start_vbl</span>
 
 	drm_vblank_put(dev, pipe);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * On VLV/CHV DSI the scanline counter would appear to</span>
<span class="p_add">+	 * increment approx. 1/3 of a scanline before start of vblank.</span>
<span class="p_add">+	 * The registers still get latched at start of vblank however.</span>
<span class="p_add">+	 * This means we must not write any registers on the first</span>
<span class="p_add">+	 * line of vblank (since not the whole line is actually in</span>
<span class="p_add">+	 * vblank). And unfortunately we can&#39;t use the interrupt to</span>
<span class="p_add">+	 * wait here since it will fire too soon. We could use the</span>
<span class="p_add">+	 * frame start interrupt instead since it will fire after the</span>
<span class="p_add">+	 * critical scanline, but that would require more changes</span>
<span class="p_add">+	 * in the interrupt code. So for now we&#39;ll just do the nasty</span>
<span class="p_add">+	 * thing and poll for the bad scanline to pass us by.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * FIXME figure out if BXT+ DSI suffers from this as well</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	while (need_vlv_dsi_wa &amp;&amp; scanline == vblank_start)</span>
<span class="p_add">+		scanline = intel_get_crtc_scanline(crtc);</span>
<span class="p_add">+</span>
 	*start_vbl_count = dev-&gt;driver-&gt;get_vblank_counter(dev, pipe);
 
 	trace_i915_pipe_update_vblank_evaded(crtc, min, max, *start_vbl_count);
<span class="p_header">diff --git a/drivers/gpu/drm/msm/hdmi/hdmi_audio.c b/drivers/gpu/drm/msm/hdmi/hdmi_audio.c</span>
<span class="p_header">index 872485f60134..9c7975718c77 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/msm/hdmi/hdmi_audio.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/msm/hdmi/hdmi_audio.c</span>
<span class="p_chunk">@@ -182,10 +182,10 @@</span> <span class="p_context"> int hdmi_audio_update(struct hdmi *hdmi)</span>
 		/* configure infoframe: */
 		hdmi_audio_infoframe_pack(info, buf, sizeof(buf));
 		hdmi_write(hdmi, REG_HDMI_AUDIO_INFO0,
<span class="p_del">-				(buf[3] &lt;&lt;  0) || (buf[4] &lt;&lt;  8) ||</span>
<span class="p_del">-				(buf[5] &lt;&lt; 16) || (buf[6] &lt;&lt; 24));</span>
<span class="p_add">+				(buf[3] &lt;&lt;  0) | (buf[4] &lt;&lt;  8) |</span>
<span class="p_add">+				(buf[5] &lt;&lt; 16) | (buf[6] &lt;&lt; 24));</span>
 		hdmi_write(hdmi, REG_HDMI_AUDIO_INFO1,
<span class="p_del">-				(buf[7] &lt;&lt;  0) || (buf[8] &lt;&lt; 8));</span>
<span class="p_add">+				(buf[7] &lt;&lt;  0) | (buf[8] &lt;&lt; 8));</span>
 
 		hdmi_write(hdmi, REG_HDMI_GC, 0);
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_encoders.c b/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_header">index d38799899ca9..5c1a3e5e3fb4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_chunk">@@ -29,6 +29,7 @@</span> <span class="p_context"></span>
 #include &quot;radeon.h&quot;
 #include &quot;atom.h&quot;
 #include &lt;linux/backlight.h&gt;
<span class="p_add">+#include &lt;linux/dmi.h&gt;</span>
 
 extern int atom_debug;
 
<span class="p_chunk">@@ -2095,9 +2096,17 @@</span> <span class="p_context"> static int radeon_atom_pick_dig_encoder(struct drm_encoder *encoder)</span>
 		}
 	}
 
<span class="p_del">-	/* on DCE32 and encoder can driver any block so just crtc id */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * On DCE32 any encoder can drive any block so usually just use crtc id,</span>
<span class="p_add">+	 * but Apple thinks different at least on iMac10,1, so there use linkb,</span>
<span class="p_add">+	 * otherwise the internal eDP panel will stay dark.</span>
<span class="p_add">+	 */</span>
 	if (ASIC_IS_DCE32(rdev)) {
<span class="p_del">-		return radeon_crtc-&gt;crtc_id;</span>
<span class="p_add">+		if (dmi_match(DMI_PRODUCT_NAME, &quot;iMac10,1&quot;))</span>
<span class="p_add">+			return (dig-&gt;linkb) ? 1 : 0;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			return radeon_crtc-&gt;crtc_id;</span>
<span class="p_add">+</span>
 	}
 
 	/* on DCE3 - LVTMA can only be driven by DIGB */
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-cadence.c b/drivers/i2c/busses/i2c-cadence.c</span>
<span class="p_header">index c604f4c3ac0d..4c4aee58c741 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-cadence.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-cadence.c</span>
<span class="p_chunk">@@ -340,14 +340,14 @@</span> <span class="p_context"> static void cdns_i2c_mrecv(struct cdns_i2c *id)</span>
 				  CDNS_I2C_XFER_SIZE_OFFSET);
 	else
 		cdns_i2c_writereg(id-&gt;recv_count, CDNS_I2C_XFER_SIZE_OFFSET);
<span class="p_add">+	/* Set the slave address in address register - triggers operation */</span>
<span class="p_add">+	cdns_i2c_writereg(id-&gt;p_msg-&gt;addr &amp; CDNS_I2C_ADDR_MASK,</span>
<span class="p_add">+						CDNS_I2C_ADDR_OFFSET);</span>
 	/* Clear the bus hold flag if bytes to receive is less than FIFO size */
 	if (!id-&gt;bus_hold_flag &amp;&amp;
 		((id-&gt;p_msg-&gt;flags &amp; I2C_M_RECV_LEN) != I2C_M_RECV_LEN) &amp;&amp;
 		(id-&gt;recv_count &lt;= CDNS_I2C_FIFO_DEPTH))
 			cdns_i2c_clear_bus_hold(id);
<span class="p_del">-	/* Set the slave address in address register - triggers operation */</span>
<span class="p_del">-	cdns_i2c_writereg(id-&gt;p_msg-&gt;addr &amp; CDNS_I2C_ADDR_MASK,</span>
<span class="p_del">-						CDNS_I2C_ADDR_OFFSET);</span>
 	cdns_i2c_writereg(CDNS_I2C_ENABLED_INTR_MASK, CDNS_I2C_IER_OFFSET);
 }
 
<span class="p_header">diff --git a/drivers/iio/accel/st_accel_spi.c b/drivers/iio/accel/st_accel_spi.c</span>
<span class="p_header">index 195639646e34..d0e1acd7c66b 100644</span>
<span class="p_header">--- a/drivers/iio/accel/st_accel_spi.c</span>
<span class="p_header">+++ b/drivers/iio/accel/st_accel_spi.c</span>
<span class="p_chunk">@@ -48,15 +48,11 @@</span> <span class="p_context"> static int st_accel_spi_remove(struct spi_device *spi)</span>
 }
 
 static const struct spi_device_id st_accel_id_table[] = {
<span class="p_del">-	{ LSM303DLH_ACCEL_DEV_NAME },</span>
<span class="p_del">-	{ LSM303DLHC_ACCEL_DEV_NAME },</span>
 	{ LIS3DH_ACCEL_DEV_NAME },
 	{ LSM330D_ACCEL_DEV_NAME },
 	{ LSM330DL_ACCEL_DEV_NAME },
 	{ LSM330DLC_ACCEL_DEV_NAME },
 	{ LIS331DLH_ACCEL_DEV_NAME },
<span class="p_del">-	{ LSM303DL_ACCEL_DEV_NAME },</span>
<span class="p_del">-	{ LSM303DLM_ACCEL_DEV_NAME },</span>
 	{ LSM330_ACCEL_DEV_NAME },
 	{},
 };
<span class="p_header">diff --git a/drivers/iio/magnetometer/st_magn_spi.c b/drivers/iio/magnetometer/st_magn_spi.c</span>
<span class="p_header">index a6143ea51dfc..d28685bec34e 100644</span>
<span class="p_header">--- a/drivers/iio/magnetometer/st_magn_spi.c</span>
<span class="p_header">+++ b/drivers/iio/magnetometer/st_magn_spi.c</span>
<span class="p_chunk">@@ -49,8 +49,6 @@</span> <span class="p_context"> static int st_magn_spi_remove(struct spi_device *spi)</span>
 }
 
 static const struct spi_device_id st_magn_id_table[] = {
<span class="p_del">-	{ LSM303DLHC_MAGN_DEV_NAME },</span>
<span class="p_del">-	{ LSM303DLM_MAGN_DEV_NAME },</span>
 	{ LIS3MDL_MAGN_DEV_NAME },
 	{},
 };
<span class="p_header">diff --git a/drivers/infiniband/core/cache.c b/drivers/infiniband/core/cache.c</span>
<span class="p_header">index 80f6cf2449fb..896e5e6b0a02 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/cache.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/cache.c</span>
<span class="p_chunk">@@ -58,17 +58,6 @@</span> <span class="p_context"> struct ib_update_work {</span>
 	u8                 port_num;
 };
 
<span class="p_del">-static inline int start_port(struct ib_device *device)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (device-&gt;node_type == RDMA_NODE_IB_SWITCH) ? 0 : 1;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int end_port(struct ib_device *device)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (device-&gt;node_type == RDMA_NODE_IB_SWITCH) ?</span>
<span class="p_del">-		0 : device-&gt;phys_port_cnt;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 int ib_get_cached_gid(struct ib_device *device,
 		      u8                port_num,
 		      int               index,
<span class="p_chunk">@@ -78,12 +67,12 @@</span> <span class="p_context"> int ib_get_cached_gid(struct ib_device *device,</span>
 	unsigned long flags;
 	int ret = 0;
 
<span class="p_del">-	if (port_num &lt; start_port(device) || port_num &gt; end_port(device))</span>
<span class="p_add">+	if (!rdma_is_port_valid(device, port_num))</span>
 		return -EINVAL;
 
 	read_lock_irqsave(&amp;device-&gt;cache.lock, flags);
 
<span class="p_del">-	cache = device-&gt;cache.gid_cache[port_num - start_port(device)];</span>
<span class="p_add">+	cache = device-&gt;cache.gid_cache[port_num - rdma_start_port(device)];</span>
 
 	if (index &lt; 0 || index &gt;= cache-&gt;table_len)
 		ret = -EINVAL;
<span class="p_chunk">@@ -112,11 +101,11 @@</span> <span class="p_context"> int ib_find_cached_gid(struct ib_device *device,</span>
 
 	read_lock_irqsave(&amp;device-&gt;cache.lock, flags);
 
<span class="p_del">-	for (p = 0; p &lt;= end_port(device) - start_port(device); ++p) {</span>
<span class="p_add">+	for (p = 0; p &lt;= rdma_end_port(device) - rdma_start_port(device); ++p) {</span>
 		cache = device-&gt;cache.gid_cache[p];
 		for (i = 0; i &lt; cache-&gt;table_len; ++i) {
 			if (!memcmp(gid, &amp;cache-&gt;table[i], sizeof *gid)) {
<span class="p_del">-				*port_num = p + start_port(device);</span>
<span class="p_add">+				*port_num = p + rdma_start_port(device);</span>
 				if (index)
 					*index = i;
 				ret = 0;
<span class="p_chunk">@@ -140,12 +129,12 @@</span> <span class="p_context"> int ib_get_cached_pkey(struct ib_device *device,</span>
 	unsigned long flags;
 	int ret = 0;
 
<span class="p_del">-	if (port_num &lt; start_port(device) || port_num &gt; end_port(device))</span>
<span class="p_add">+	if (!rdma_is_port_valid(device, port_num))</span>
 		return -EINVAL;
 
 	read_lock_irqsave(&amp;device-&gt;cache.lock, flags);
 
<span class="p_del">-	cache = device-&gt;cache.pkey_cache[port_num - start_port(device)];</span>
<span class="p_add">+	cache = device-&gt;cache.pkey_cache[port_num - rdma_start_port(device)];</span>
 
 	if (index &lt; 0 || index &gt;= cache-&gt;table_len)
 		ret = -EINVAL;
<span class="p_chunk">@@ -169,12 +158,12 @@</span> <span class="p_context"> int ib_find_cached_pkey(struct ib_device *device,</span>
 	int ret = -ENOENT;
 	int partial_ix = -1;
 
<span class="p_del">-	if (port_num &lt; start_port(device) || port_num &gt; end_port(device))</span>
<span class="p_add">+	if (!rdma_is_port_valid(device, port_num))</span>
 		return -EINVAL;
 
 	read_lock_irqsave(&amp;device-&gt;cache.lock, flags);
 
<span class="p_del">-	cache = device-&gt;cache.pkey_cache[port_num - start_port(device)];</span>
<span class="p_add">+	cache = device-&gt;cache.pkey_cache[port_num - rdma_start_port(device)];</span>
 
 	*index = -1;
 
<span class="p_chunk">@@ -209,12 +198,12 @@</span> <span class="p_context"> int ib_find_exact_cached_pkey(struct ib_device *device,</span>
 	int i;
 	int ret = -ENOENT;
 
<span class="p_del">-	if (port_num &lt; start_port(device) || port_num &gt; end_port(device))</span>
<span class="p_add">+	if (!rdma_is_port_valid(device, port_num))</span>
 		return -EINVAL;
 
 	read_lock_irqsave(&amp;device-&gt;cache.lock, flags);
 
<span class="p_del">-	cache = device-&gt;cache.pkey_cache[port_num - start_port(device)];</span>
<span class="p_add">+	cache = device-&gt;cache.pkey_cache[port_num - rdma_start_port(device)];</span>
 
 	*index = -1;
 
<span class="p_chunk">@@ -238,11 +227,11 @@</span> <span class="p_context"> int ib_get_cached_lmc(struct ib_device *device,</span>
 	unsigned long flags;
 	int ret = 0;
 
<span class="p_del">-	if (port_num &lt; start_port(device) || port_num &gt; end_port(device))</span>
<span class="p_add">+	if (!rdma_is_port_valid(device, port_num))</span>
 		return -EINVAL;
 
 	read_lock_irqsave(&amp;device-&gt;cache.lock, flags);
<span class="p_del">-	*lmc = device-&gt;cache.lmc_cache[port_num - start_port(device)];</span>
<span class="p_add">+	*lmc = device-&gt;cache.lmc_cache[port_num - rdma_start_port(device)];</span>
 	read_unlock_irqrestore(&amp;device-&gt;cache.lock, flags);
 
 	return ret;
<span class="p_chunk">@@ -303,13 +292,13 @@</span> <span class="p_context"> static void ib_cache_update(struct ib_device *device,</span>
 
 	write_lock_irq(&amp;device-&gt;cache.lock);
 
<span class="p_del">-	old_pkey_cache = device-&gt;cache.pkey_cache[port - start_port(device)];</span>
<span class="p_del">-	old_gid_cache  = device-&gt;cache.gid_cache [port - start_port(device)];</span>
<span class="p_add">+	old_pkey_cache = device-&gt;cache.pkey_cache[port - rdma_start_port(device)];</span>
<span class="p_add">+	old_gid_cache  = device-&gt;cache.gid_cache [port - rdma_start_port(device)];</span>
 
<span class="p_del">-	device-&gt;cache.pkey_cache[port - start_port(device)] = pkey_cache;</span>
<span class="p_del">-	device-&gt;cache.gid_cache [port - start_port(device)] = gid_cache;</span>
<span class="p_add">+	device-&gt;cache.pkey_cache[port - rdma_start_port(device)] = pkey_cache;</span>
<span class="p_add">+	device-&gt;cache.gid_cache [port - rdma_start_port(device)] = gid_cache;</span>
 
<span class="p_del">-	device-&gt;cache.lmc_cache[port - start_port(device)] = tprops-&gt;lmc;</span>
<span class="p_add">+	device-&gt;cache.lmc_cache[port - rdma_start_port(device)] = tprops-&gt;lmc;</span>
 
 	write_unlock_irq(&amp;device-&gt;cache.lock);
 
<span class="p_chunk">@@ -363,14 +352,14 @@</span> <span class="p_context"> static void ib_cache_setup_one(struct ib_device *device)</span>
 
 	device-&gt;cache.pkey_cache =
 		kmalloc(sizeof *device-&gt;cache.pkey_cache *
<span class="p_del">-			(end_port(device) - start_port(device) + 1), GFP_KERNEL);</span>
<span class="p_add">+			(rdma_end_port(device) - rdma_start_port(device) + 1), GFP_KERNEL);</span>
 	device-&gt;cache.gid_cache =
 		kmalloc(sizeof *device-&gt;cache.gid_cache *
<span class="p_del">-			(end_port(device) - start_port(device) + 1), GFP_KERNEL);</span>
<span class="p_add">+			(rdma_end_port(device) - rdma_start_port(device) + 1), GFP_KERNEL);</span>
 
 	device-&gt;cache.lmc_cache = kmalloc(sizeof *device-&gt;cache.lmc_cache *
<span class="p_del">-					  (end_port(device) -</span>
<span class="p_del">-					   start_port(device) + 1),</span>
<span class="p_add">+					  (rdma_end_port(device) -</span>
<span class="p_add">+					   rdma_start_port(device) + 1),</span>
 					  GFP_KERNEL);
 
 	if (!device-&gt;cache.pkey_cache || !device-&gt;cache.gid_cache ||
<span class="p_chunk">@@ -380,10 +369,10 @@</span> <span class="p_context"> static void ib_cache_setup_one(struct ib_device *device)</span>
 		goto err;
 	}
 
<span class="p_del">-	for (p = 0; p &lt;= end_port(device) - start_port(device); ++p) {</span>
<span class="p_add">+	for (p = 0; p &lt;= rdma_end_port(device) - rdma_start_port(device); ++p) {</span>
 		device-&gt;cache.pkey_cache[p] = NULL;
 		device-&gt;cache.gid_cache [p] = NULL;
<span class="p_del">-		ib_cache_update(device, p + start_port(device));</span>
<span class="p_add">+		ib_cache_update(device, p + rdma_start_port(device));</span>
 	}
 
 	INIT_IB_EVENT_HANDLER(&amp;device-&gt;cache.event_handler,
<span class="p_chunk">@@ -394,7 +383,7 @@</span> <span class="p_context"> static void ib_cache_setup_one(struct ib_device *device)</span>
 	return;
 
 err_cache:
<span class="p_del">-	for (p = 0; p &lt;= end_port(device) - start_port(device); ++p) {</span>
<span class="p_add">+	for (p = 0; p &lt;= rdma_end_port(device) - rdma_start_port(device); ++p) {</span>
 		kfree(device-&gt;cache.pkey_cache[p]);
 		kfree(device-&gt;cache.gid_cache[p]);
 	}
<span class="p_chunk">@@ -412,7 +401,7 @@</span> <span class="p_context"> static void ib_cache_cleanup_one(struct ib_device *device)</span>
 	ib_unregister_event_handler(&amp;device-&gt;cache.event_handler);
 	flush_workqueue(ib_wq);
 
<span class="p_del">-	for (p = 0; p &lt;= end_port(device) - start_port(device); ++p) {</span>
<span class="p_add">+	for (p = 0; p &lt;= rdma_end_port(device) - rdma_start_port(device); ++p) {</span>
 		kfree(device-&gt;cache.pkey_cache[p]);
 		kfree(device-&gt;cache.gid_cache[p]);
 	}
<span class="p_header">diff --git a/drivers/infiniband/core/device.c b/drivers/infiniband/core/device.c</span>
<span class="p_header">index 18c1ece765f2..1d07df37178f 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/device.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/device.c</span>
<span class="p_chunk">@@ -151,18 +151,6 @@</span> <span class="p_context"> static int alloc_name(char *name)</span>
 	return 0;
 }
 
<span class="p_del">-static int start_port(struct ib_device *device)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (device-&gt;node_type == RDMA_NODE_IB_SWITCH) ? 0 : 1;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-static int end_port(struct ib_device *device)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (device-&gt;node_type == RDMA_NODE_IB_SWITCH) ?</span>
<span class="p_del">-		0 : device-&gt;phys_port_cnt;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /**
  * ib_alloc_device - allocate an IB device struct
  * @size:size of structure to allocate
<span class="p_chunk">@@ -232,7 +220,7 @@</span> <span class="p_context"> static int read_port_table_lengths(struct ib_device *device)</span>
 	if (!tprops)
 		goto out;
 
<span class="p_del">-	num_ports = end_port(device) - start_port(device) + 1;</span>
<span class="p_add">+	num_ports = rdma_end_port(device) - rdma_start_port(device) + 1;</span>
 
 	device-&gt;pkey_tbl_len = kmalloc(sizeof *device-&gt;pkey_tbl_len * num_ports,
 				       GFP_KERNEL);
<span class="p_chunk">@@ -242,7 +230,7 @@</span> <span class="p_context"> static int read_port_table_lengths(struct ib_device *device)</span>
 		goto err;
 
 	for (port_index = 0; port_index &lt; num_ports; ++port_index) {
<span class="p_del">-		ret = ib_query_port(device, port_index + start_port(device),</span>
<span class="p_add">+		ret = ib_query_port(device, port_index + rdma_start_port(device),</span>
 					tprops);
 		if (ret)
 			goto err;
<span class="p_chunk">@@ -575,7 +563,7 @@</span> <span class="p_context"> int ib_query_port(struct ib_device *device,</span>
 		  u8 port_num,
 		  struct ib_port_attr *port_attr)
 {
<span class="p_del">-	if (port_num &lt; start_port(device) || port_num &gt; end_port(device))</span>
<span class="p_add">+	if (!rdma_is_port_valid(device, port_num))</span>
 		return -EINVAL;
 
 	return device-&gt;query_port(device, port_num, port_attr);
<span class="p_chunk">@@ -653,7 +641,7 @@</span> <span class="p_context"> int ib_modify_port(struct ib_device *device,</span>
 	if (!device-&gt;modify_port)
 		return -ENOSYS;
 
<span class="p_del">-	if (port_num &lt; start_port(device) || port_num &gt; end_port(device))</span>
<span class="p_add">+	if (!rdma_is_port_valid(device, port_num))</span>
 		return -EINVAL;
 
 	return device-&gt;modify_port(device, port_num, port_modify_mask,
<span class="p_chunk">@@ -676,8 +664,8 @@</span> <span class="p_context"> int ib_find_gid(struct ib_device *device, union ib_gid *gid,</span>
 	union ib_gid tmp_gid;
 	int ret, port, i;
 
<span class="p_del">-	for (port = start_port(device); port &lt;= end_port(device); ++port) {</span>
<span class="p_del">-		for (i = 0; i &lt; device-&gt;gid_tbl_len[port - start_port(device)]; ++i) {</span>
<span class="p_add">+	for (port = rdma_start_port(device); port &lt;= rdma_end_port(device); ++port) {</span>
<span class="p_add">+		for (i = 0; i &lt; device-&gt;gid_tbl_len[port - rdma_start_port(device)]; ++i) {</span>
 			ret = ib_query_gid(device, port, i, &amp;tmp_gid);
 			if (ret)
 				return ret;
<span class="p_chunk">@@ -709,7 +697,7 @@</span> <span class="p_context"> int ib_find_pkey(struct ib_device *device,</span>
 	u16 tmp_pkey;
 	int partial_ix = -1;
 
<span class="p_del">-	for (i = 0; i &lt; device-&gt;pkey_tbl_len[port_num - start_port(device)]; ++i) {</span>
<span class="p_add">+	for (i = 0; i &lt; device-&gt;pkey_tbl_len[port_num - rdma_start_port(device)]; ++i) {</span>
 		ret = ib_query_pkey(device, port_num, i, &amp;tmp_pkey);
 		if (ret)
 			return ret;
<span class="p_header">diff --git a/drivers/infiniband/core/uverbs_cmd.c b/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_header">index 779067acd270..ab6326cdde23 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_chunk">@@ -1915,6 +1915,11 @@</span> <span class="p_context"> ssize_t ib_uverbs_modify_qp(struct ib_uverbs_file *file,</span>
 		goto out;
 	}
 
<span class="p_add">+	if (!rdma_is_port_valid(qp-&gt;device, cmd.port_num)) {</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto release_qp;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	attr-&gt;qp_state 		  = cmd.qp_state;
 	attr-&gt;cur_qp_state 	  = cmd.cur_qp_state;
 	attr-&gt;path_mtu 		  = cmd.path_mtu;
<span class="p_chunk">@@ -2397,6 +2402,7 @@</span> <span class="p_context"> ssize_t ib_uverbs_create_ah(struct ib_uverbs_file *file,</span>
 			    const char __user *buf, int in_len,
 			    int out_len)
 {
<span class="p_add">+	struct ib_device		*ib_dev = file-&gt;device-&gt;ib_dev;</span>
 	struct ib_uverbs_create_ah	 cmd;
 	struct ib_uverbs_create_ah_resp	 resp;
 	struct ib_uobject		*uobj;
<span class="p_chunk">@@ -2411,6 +2417,9 @@</span> <span class="p_context"> ssize_t ib_uverbs_create_ah(struct ib_uverbs_file *file,</span>
 	if (copy_from_user(&amp;cmd, buf, sizeof cmd))
 		return -EFAULT;
 
<span class="p_add">+	if (!rdma_is_port_valid(ib_dev, cmd.attr.port_num))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	uobj = kmalloc(sizeof *uobj, GFP_KERNEL);
 	if (!uobj)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/input/serio/i8042.c b/drivers/input/serio/i8042.c</span>
<span class="p_header">index 9a0cc5b5561a..d3ff4c0082fe 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042.c</span>
<span class="p_header">+++ b/drivers/input/serio/i8042.c</span>
<span class="p_chunk">@@ -397,8 +397,10 @@</span> <span class="p_context"> static int i8042_start(struct serio *serio)</span>
 {
 	struct i8042_port *port = serio-&gt;port_data;
 
<span class="p_add">+	spin_lock_irq(&amp;i8042_lock);</span>
 	port-&gt;exists = true;
<span class="p_del">-	mb();</span>
<span class="p_add">+	spin_unlock_irq(&amp;i8042_lock);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -411,16 +413,20 @@</span> <span class="p_context"> static void i8042_stop(struct serio *serio)</span>
 {
 	struct i8042_port *port = serio-&gt;port_data;
 
<span class="p_add">+	spin_lock_irq(&amp;i8042_lock);</span>
 	port-&gt;exists = false;
<span class="p_add">+	port-&gt;serio = NULL;</span>
<span class="p_add">+	spin_unlock_irq(&amp;i8042_lock);</span>
 
 	/*
<span class="p_add">+	 * We need to make sure that interrupt handler finishes using</span>
<span class="p_add">+	 * our serio port before we return from this function.</span>
 	 * We synchronize with both AUX and KBD IRQs because there is
 	 * a (very unlikely) chance that AUX IRQ is raised for KBD port
 	 * and vice versa.
 	 */
 	synchronize_irq(I8042_AUX_IRQ);
 	synchronize_irq(I8042_KBD_IRQ);
<span class="p_del">-	port-&gt;serio = NULL;</span>
 }
 
 /*
<span class="p_chunk">@@ -537,7 +543,7 @@</span> <span class="p_context"> static irqreturn_t i8042_interrupt(int irq, void *dev_id)</span>
 
 	spin_unlock_irqrestore(&amp;i8042_lock, flags);
 
<span class="p_del">-	if (likely(port-&gt;exists &amp;&amp; !filtered))</span>
<span class="p_add">+	if (likely(serio &amp;&amp; !filtered))</span>
 		serio_interrupt(serio, data, dfl);
 
  out:
<span class="p_header">diff --git a/drivers/input/touchscreen/ads7846.c b/drivers/input/touchscreen/ads7846.c</span>
<span class="p_header">index da201b8e37dc..f0ec124b8f6f 100644</span>
<span class="p_header">--- a/drivers/input/touchscreen/ads7846.c</span>
<span class="p_header">+++ b/drivers/input/touchscreen/ads7846.c</span>
<span class="p_chunk">@@ -668,18 +668,22 @@</span> <span class="p_context"> static int ads7846_no_filter(void *ads, int data_idx, int *val)</span>
 
 static int ads7846_get_value(struct ads7846 *ts, struct spi_message *m)
 {
<span class="p_add">+	int value;</span>
 	struct spi_transfer *t =
 		list_entry(m-&gt;transfers.prev, struct spi_transfer, transfer_list);
 
 	if (ts-&gt;model == 7845) {
<span class="p_del">-		return be16_to_cpup((__be16 *)&amp;(((char*)t-&gt;rx_buf)[1])) &gt;&gt; 3;</span>
<span class="p_add">+		value = be16_to_cpup((__be16 *)&amp;(((char *)t-&gt;rx_buf)[1]));</span>
 	} else {
 		/*
 		 * adjust:  on-wire is a must-ignore bit, a BE12 value, then
 		 * padding; built from two 8 bit values written msb-first.
 		 */
<span class="p_del">-		return be16_to_cpup((__be16 *)t-&gt;rx_buf) &gt;&gt; 3;</span>
<span class="p_add">+		value = be16_to_cpup((__be16 *)t-&gt;rx_buf);</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	/* enforce ADC output is 12 bits width */</span>
<span class="p_add">+	return (value &gt;&gt; 3) &amp; 0xfff;</span>
 }
 
 static void ads7846_update_value(struct spi_message *m, int val)
<span class="p_header">diff --git a/drivers/macintosh/therm_windtunnel.c b/drivers/macintosh/therm_windtunnel.c</span>
<span class="p_header">index 3b4a157714b1..b40ed32379ec 100644</span>
<span class="p_header">--- a/drivers/macintosh/therm_windtunnel.c</span>
<span class="p_header">+++ b/drivers/macintosh/therm_windtunnel.c</span>
<span class="p_chunk">@@ -408,6 +408,7 @@</span> <span class="p_context"> static const struct i2c_device_id therm_windtunnel_id[] = {</span>
 	{ &quot;therm_adm1030&quot;, adm1030 },
 	{ }
 };
<span class="p_add">+MODULE_DEVICE_TABLE(i2c, therm_windtunnel_id);</span>
 
 static int
 do_probe(struct i2c_client *cl, const struct i2c_device_id *id)
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index d043e50ebea7..4f0773c8ad20 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -1183,11 +1183,62 @@</span> <span class="p_context"> void dm_accept_partial_bio(struct bio *bio, unsigned n_sectors)</span>
 }
 EXPORT_SYMBOL_GPL(dm_accept_partial_bio);
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Flush current-&gt;bio_list when the target map method blocks.</span>
<span class="p_add">+ * This fixes deadlocks in snapshot and possibly in other targets.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct dm_offload {</span>
<span class="p_add">+	struct blk_plug plug;</span>
<span class="p_add">+	struct blk_plug_cb cb;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static void flush_current_bio_list(struct blk_plug_cb *cb, bool from_schedule)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct dm_offload *o = container_of(cb, struct dm_offload, cb);</span>
<span class="p_add">+	struct bio_list list;</span>
<span class="p_add">+	struct bio *bio;</span>
<span class="p_add">+</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;o-&gt;cb.list);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(!current-&gt;bio_list))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	list = *current-&gt;bio_list;</span>
<span class="p_add">+	bio_list_init(current-&gt;bio_list);</span>
<span class="p_add">+</span>
<span class="p_add">+	while ((bio = bio_list_pop(&amp;list))) {</span>
<span class="p_add">+		struct bio_set *bs = bio-&gt;bi_pool;</span>
<span class="p_add">+		if (unlikely(!bs) || bs == fs_bio_set) {</span>
<span class="p_add">+			bio_list_add(current-&gt;bio_list, bio);</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock(&amp;bs-&gt;rescue_lock);</span>
<span class="p_add">+		bio_list_add(&amp;bs-&gt;rescue_list, bio);</span>
<span class="p_add">+		queue_work(bs-&gt;rescue_workqueue, &amp;bs-&gt;rescue_work);</span>
<span class="p_add">+		spin_unlock(&amp;bs-&gt;rescue_lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void dm_offload_start(struct dm_offload *o)</span>
<span class="p_add">+{</span>
<span class="p_add">+	blk_start_plug(&amp;o-&gt;plug);</span>
<span class="p_add">+	o-&gt;cb.callback = flush_current_bio_list;</span>
<span class="p_add">+	list_add(&amp;o-&gt;cb.list, &amp;current-&gt;plug-&gt;cb_list);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void dm_offload_end(struct dm_offload *o)</span>
<span class="p_add">+{</span>
<span class="p_add">+	list_del(&amp;o-&gt;cb.list);</span>
<span class="p_add">+	blk_finish_plug(&amp;o-&gt;plug);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void __map_bio(struct dm_target_io *tio)
 {
 	int r;
 	sector_t sector;
 	struct mapped_device *md;
<span class="p_add">+	struct dm_offload o;</span>
 	struct bio *clone = &amp;tio-&gt;clone;
 	struct dm_target *ti = tio-&gt;ti;
 
<span class="p_chunk">@@ -1200,7 +1251,11 @@</span> <span class="p_context"> static void __map_bio(struct dm_target_io *tio)</span>
 	 */
 	atomic_inc(&amp;tio-&gt;io-&gt;io_count);
 	sector = clone-&gt;bi_iter.bi_sector;
<span class="p_add">+</span>
<span class="p_add">+	dm_offload_start(&amp;o);</span>
 	r = ti-&gt;type-&gt;map(ti, clone);
<span class="p_add">+	dm_offload_end(&amp;o);</span>
<span class="p_add">+</span>
 	if (r == DM_MAPIO_REMAPPED) {
 		/* the bio has been remapped so dispatch it */
 
<span class="p_header">diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c</span>
<span class="p_header">index 0d91644e80eb..41b1f7aa88d3 100644</span>
<span class="p_header">--- a/drivers/md/raid1.c</span>
<span class="p_header">+++ b/drivers/md/raid1.c</span>
<span class="p_chunk">@@ -1122,13 +1122,16 @@</span> <span class="p_context"> static void make_request(struct mddev *mddev, struct bio * bio)</span>
 		 */
 		DEFINE_WAIT(w);
 		for (;;) {
<span class="p_del">-			flush_signals(current);</span>
<span class="p_add">+			sigset_t full, old;</span>
 			prepare_to_wait(&amp;conf-&gt;wait_barrier,
 					&amp;w, TASK_INTERRUPTIBLE);
 			if (bio_end_sector(bio) &lt;= mddev-&gt;suspend_lo ||
 			    bio-&gt;bi_iter.bi_sector &gt;= mddev-&gt;suspend_hi)
 				break;
<span class="p_add">+			sigfillset(&amp;full);</span>
<span class="p_add">+			sigprocmask(SIG_BLOCK, &amp;full, &amp;old);</span>
 			schedule();
<span class="p_add">+			sigprocmask(SIG_SETMASK, &amp;old, NULL);</span>
 		}
 		finish_wait(&amp;conf-&gt;wait_barrier, &amp;w);
 	}
<span class="p_header">diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c</span>
<span class="p_header">index 63a094166138..16789320135f 100644</span>
<span class="p_header">--- a/drivers/md/raid5.c</span>
<span class="p_header">+++ b/drivers/md/raid5.c</span>
<span class="p_chunk">@@ -4721,12 +4721,15 @@</span> <span class="p_context"> static void make_request(struct mddev *mddev, struct bio * bi)</span>
 				 * userspace, we want an interruptible
 				 * wait.
 				 */
<span class="p_del">-				flush_signals(current);</span>
 				prepare_to_wait(&amp;conf-&gt;wait_for_overlap,
 						&amp;w, TASK_INTERRUPTIBLE);
 				if (logical_sector &gt;= mddev-&gt;suspend_lo &amp;&amp;
 				    logical_sector &lt; mddev-&gt;suspend_hi) {
<span class="p_add">+					sigset_t full, old;</span>
<span class="p_add">+					sigfillset(&amp;full);</span>
<span class="p_add">+					sigprocmask(SIG_BLOCK, &amp;full, &amp;old);</span>
 					schedule();
<span class="p_add">+					sigprocmask(SIG_SETMASK, &amp;old, NULL);</span>
 					do_prepare = true;
 				}
 				goto retry;
<span class="p_header">diff --git a/drivers/media/pci/saa7164/saa7164-buffer.c b/drivers/media/pci/saa7164/saa7164-buffer.c</span>
<span class="p_header">index 66696fa8341d..9bd1f73f82da 100644</span>
<span class="p_header">--- a/drivers/media/pci/saa7164/saa7164-buffer.c</span>
<span class="p_header">+++ b/drivers/media/pci/saa7164/saa7164-buffer.c</span>
<span class="p_chunk">@@ -130,9 +130,9 @@</span> <span class="p_context"> struct saa7164_buffer *saa7164_buffer_alloc(struct saa7164_port *port,</span>
 		goto fail2;
 
 	/* init the buffers to a known pattern, easier during debugging */
<span class="p_del">-	memset_io(buf-&gt;cpu, 0xff, buf-&gt;pci_size);</span>
<span class="p_add">+	memset(buf-&gt;cpu, 0xff, buf-&gt;pci_size);</span>
 	buf-&gt;crc = crc32(0, buf-&gt;cpu, buf-&gt;actual_size);
<span class="p_del">-	memset_io(buf-&gt;pt_cpu, 0xff, buf-&gt;pt_size);</span>
<span class="p_add">+	memset(buf-&gt;pt_cpu, 0xff, buf-&gt;pt_size);</span>
 
 	dprintk(DBGLVL_BUF, &quot;%s()   allocated buffer @ 0x%p (%d pageptrs)\n&quot;,
 		__func__, buf, params-&gt;numpagetables);
<span class="p_header">diff --git a/drivers/media/pci/saa7164/saa7164-bus.c b/drivers/media/pci/saa7164/saa7164-bus.c</span>
<span class="p_header">index 5f6f3094c44e..1c779ea8b5ec 100644</span>
<span class="p_header">--- a/drivers/media/pci/saa7164/saa7164-bus.c</span>
<span class="p_header">+++ b/drivers/media/pci/saa7164/saa7164-bus.c</span>
<span class="p_chunk">@@ -33,12 +33,12 @@</span> <span class="p_context"> int saa7164_bus_setup(struct saa7164_dev *dev)</span>
 	b-&gt;Type			= TYPE_BUS_PCIe;
 	b-&gt;m_wMaxReqSize	= SAA_DEVICE_MAXREQUESTSIZE;
 
<span class="p_del">-	b-&gt;m_pdwSetRing		= (u8 *)(dev-&gt;bmmio +</span>
<span class="p_add">+	b-&gt;m_pdwSetRing		= (u8 __iomem *)(dev-&gt;bmmio +</span>
 		((u32)dev-&gt;busdesc.CommandRing));
 
 	b-&gt;m_dwSizeSetRing	= SAA_DEVICE_BUFFERBLOCKSIZE;
 
<span class="p_del">-	b-&gt;m_pdwGetRing		= (u8 *)(dev-&gt;bmmio +</span>
<span class="p_add">+	b-&gt;m_pdwGetRing		= (u8 __iomem *)(dev-&gt;bmmio +</span>
 		((u32)dev-&gt;busdesc.ResponseRing));
 
 	b-&gt;m_dwSizeGetRing	= SAA_DEVICE_BUFFERBLOCKSIZE;
<span class="p_chunk">@@ -138,6 +138,7 @@</span> <span class="p_context"> int saa7164_bus_set(struct saa7164_dev *dev, struct tmComResInfo* msg,</span>
 	u32 bytes_to_write, free_write_space, timeout, curr_srp, curr_swp;
 	u32 new_swp, space_rem;
 	int ret = SAA_ERR_BAD_PARAMETER;
<span class="p_add">+	u16 size;</span>
 
 	if (!msg) {
 		printk(KERN_ERR &quot;%s() !msg\n&quot;, __func__);
<span class="p_chunk">@@ -148,10 +149,6 @@</span> <span class="p_context"> int saa7164_bus_set(struct saa7164_dev *dev, struct tmComResInfo* msg,</span>
 
 	saa7164_bus_verify(dev);
 
<span class="p_del">-	msg-&gt;size = cpu_to_le16(msg-&gt;size);</span>
<span class="p_del">-	msg-&gt;command = cpu_to_le32(msg-&gt;command);</span>
<span class="p_del">-	msg-&gt;controlselector = cpu_to_le16(msg-&gt;controlselector);</span>
<span class="p_del">-</span>
 	if (msg-&gt;size &gt; dev-&gt;bus.m_wMaxReqSize) {
 		printk(KERN_ERR &quot;%s() Exceeded dev-&gt;bus.m_wMaxReqSize\n&quot;,
 			__func__);
<span class="p_chunk">@@ -169,8 +166,8 @@</span> <span class="p_context"> int saa7164_bus_set(struct saa7164_dev *dev, struct tmComResInfo* msg,</span>
 	bytes_to_write = sizeof(*msg) + msg-&gt;size;
 	free_write_space = 0;
 	timeout = SAA_BUS_TIMEOUT;
<span class="p_del">-	curr_srp = le32_to_cpu(saa7164_readl(bus-&gt;m_dwSetReadPos));</span>
<span class="p_del">-	curr_swp = le32_to_cpu(saa7164_readl(bus-&gt;m_dwSetWritePos));</span>
<span class="p_add">+	curr_srp = saa7164_readl(bus-&gt;m_dwSetReadPos);</span>
<span class="p_add">+	curr_swp = saa7164_readl(bus-&gt;m_dwSetWritePos);</span>
 
 	/* Deal with ring wrapping issues */
 	if (curr_srp &gt; curr_swp)
<span class="p_chunk">@@ -203,7 +200,7 @@</span> <span class="p_context"> int saa7164_bus_set(struct saa7164_dev *dev, struct tmComResInfo* msg,</span>
 		mdelay(1);
 
 		/* Check the space usage again */
<span class="p_del">-		curr_srp = le32_to_cpu(saa7164_readl(bus-&gt;m_dwSetReadPos));</span>
<span class="p_add">+		curr_srp = saa7164_readl(bus-&gt;m_dwSetReadPos);</span>
 
 		/* Deal with ring wrapping issues */
 		if (curr_srp &gt; curr_swp)
<span class="p_chunk">@@ -223,6 +220,16 @@</span> <span class="p_context"> int saa7164_bus_set(struct saa7164_dev *dev, struct tmComResInfo* msg,</span>
 	dprintk(DBGLVL_BUS, &quot;%s() bus-&gt;m_dwSizeSetRing = %x\n&quot;, __func__,
 		bus-&gt;m_dwSizeSetRing);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Make a copy of msg-&gt;size before it is converted to le16 since it is</span>
<span class="p_add">+	 * used in the code below.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	size = msg-&gt;size;</span>
<span class="p_add">+	/* Convert to le16/le32 */</span>
<span class="p_add">+	msg-&gt;size = (__force u16)cpu_to_le16(msg-&gt;size);</span>
<span class="p_add">+	msg-&gt;command = (__force u32)cpu_to_le32(msg-&gt;command);</span>
<span class="p_add">+	msg-&gt;controlselector = (__force u16)cpu_to_le16(msg-&gt;controlselector);</span>
<span class="p_add">+</span>
 	/* Mental Note: line 462 tmmhComResBusPCIe.cpp */
 
 	/* Check if we&#39;re going to wrap again */
<span class="p_chunk">@@ -243,28 +250,28 @@</span> <span class="p_context"> int saa7164_bus_set(struct saa7164_dev *dev, struct tmComResInfo* msg,</span>
 			dprintk(DBGLVL_BUS, &quot;%s() tr4\n&quot;, __func__);
 
 			/* Split the msg into pieces as the ring wraps */
<span class="p_del">-			memcpy(bus-&gt;m_pdwSetRing + curr_swp, msg, space_rem);</span>
<span class="p_del">-			memcpy(bus-&gt;m_pdwSetRing, (u8 *)msg + space_rem,</span>
<span class="p_add">+			memcpy_toio(bus-&gt;m_pdwSetRing + curr_swp, msg, space_rem);</span>
<span class="p_add">+			memcpy_toio(bus-&gt;m_pdwSetRing, (u8 *)msg + space_rem,</span>
 				sizeof(*msg) - space_rem);
 
<span class="p_del">-			memcpy(bus-&gt;m_pdwSetRing + sizeof(*msg) - space_rem,</span>
<span class="p_del">-				buf, msg-&gt;size);</span>
<span class="p_add">+			memcpy_toio(bus-&gt;m_pdwSetRing + sizeof(*msg) - space_rem,</span>
<span class="p_add">+				buf, size);</span>
 
 		} else if (space_rem == sizeof(*msg)) {
 			dprintk(DBGLVL_BUS, &quot;%s() tr5\n&quot;, __func__);
 
 			/* Additional data at the beginning of the ring */
<span class="p_del">-			memcpy(bus-&gt;m_pdwSetRing + curr_swp, msg, sizeof(*msg));</span>
<span class="p_del">-			memcpy(bus-&gt;m_pdwSetRing, buf, msg-&gt;size);</span>
<span class="p_add">+			memcpy_toio(bus-&gt;m_pdwSetRing + curr_swp, msg, sizeof(*msg));</span>
<span class="p_add">+			memcpy_toio(bus-&gt;m_pdwSetRing, buf, size);</span>
 
 		} else {
 			/* Additional data wraps around the ring */
<span class="p_del">-			memcpy(bus-&gt;m_pdwSetRing + curr_swp, msg, sizeof(*msg));</span>
<span class="p_del">-			if (msg-&gt;size &gt; 0) {</span>
<span class="p_del">-				memcpy(bus-&gt;m_pdwSetRing + curr_swp +</span>
<span class="p_add">+			memcpy_toio(bus-&gt;m_pdwSetRing + curr_swp, msg, sizeof(*msg));</span>
<span class="p_add">+			if (size &gt; 0) {</span>
<span class="p_add">+				memcpy_toio(bus-&gt;m_pdwSetRing + curr_swp +</span>
 					sizeof(*msg), buf, space_rem -
 					sizeof(*msg));
<span class="p_del">-				memcpy(bus-&gt;m_pdwSetRing, (u8 *)buf +</span>
<span class="p_add">+				memcpy_toio(bus-&gt;m_pdwSetRing, (u8 *)buf +</span>
 					space_rem - sizeof(*msg),
 					bytes_to_write - space_rem);
 			}
<span class="p_chunk">@@ -276,15 +283,20 @@</span> <span class="p_context"> int saa7164_bus_set(struct saa7164_dev *dev, struct tmComResInfo* msg,</span>
 		dprintk(DBGLVL_BUS, &quot;%s() tr6\n&quot;, __func__);
 
 		/* The ring buffer doesn&#39;t wrap, two simple copies */
<span class="p_del">-		memcpy(bus-&gt;m_pdwSetRing + curr_swp, msg, sizeof(*msg));</span>
<span class="p_del">-		memcpy(bus-&gt;m_pdwSetRing + curr_swp + sizeof(*msg), buf,</span>
<span class="p_del">-			msg-&gt;size);</span>
<span class="p_add">+		memcpy_toio(bus-&gt;m_pdwSetRing + curr_swp, msg, sizeof(*msg));</span>
<span class="p_add">+		memcpy_toio(bus-&gt;m_pdwSetRing + curr_swp + sizeof(*msg), buf,</span>
<span class="p_add">+			size);</span>
 	}
 
 	dprintk(DBGLVL_BUS, &quot;%s() new_swp = %x\n&quot;, __func__, new_swp);
 
 	/* Update the bus write position */
<span class="p_del">-	saa7164_writel(bus-&gt;m_dwSetWritePos, cpu_to_le32(new_swp));</span>
<span class="p_add">+	saa7164_writel(bus-&gt;m_dwSetWritePos, new_swp);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Convert back to cpu after writing the msg to the ringbuffer. */</span>
<span class="p_add">+	msg-&gt;size = le16_to_cpu((__force __le16)msg-&gt;size);</span>
<span class="p_add">+	msg-&gt;command = le32_to_cpu((__force __le32)msg-&gt;command);</span>
<span class="p_add">+	msg-&gt;controlselector = le16_to_cpu((__force __le16)msg-&gt;controlselector);</span>
 	ret = SAA_OK;
 
 out:
<span class="p_chunk">@@ -336,8 +348,8 @@</span> <span class="p_context"> int saa7164_bus_get(struct saa7164_dev *dev, struct tmComResInfo* msg,</span>
 	/* Peek the bus to see if a msg exists, if it&#39;s not what we&#39;re expecting
 	 * then return cleanly else read the message from the bus.
 	 */
<span class="p_del">-	curr_gwp = le32_to_cpu(saa7164_readl(bus-&gt;m_dwGetWritePos));</span>
<span class="p_del">-	curr_grp = le32_to_cpu(saa7164_readl(bus-&gt;m_dwGetReadPos));</span>
<span class="p_add">+	curr_gwp = saa7164_readl(bus-&gt;m_dwGetWritePos);</span>
<span class="p_add">+	curr_grp = saa7164_readl(bus-&gt;m_dwGetReadPos);</span>
 
 	if (curr_gwp == curr_grp) {
 		ret = SAA_ERR_EMPTY;
<span class="p_chunk">@@ -369,19 +381,23 @@</span> <span class="p_context"> int saa7164_bus_get(struct saa7164_dev *dev, struct tmComResInfo* msg,</span>
 		new_grp -= bus-&gt;m_dwSizeGetRing;
 		space_rem = bus-&gt;m_dwSizeGetRing - curr_grp;
 
<span class="p_del">-		memcpy(&amp;msg_tmp, bus-&gt;m_pdwGetRing + curr_grp, space_rem);</span>
<span class="p_del">-		memcpy((u8 *)&amp;msg_tmp + space_rem, bus-&gt;m_pdwGetRing,</span>
<span class="p_add">+		memcpy_fromio(&amp;msg_tmp, bus-&gt;m_pdwGetRing + curr_grp, space_rem);</span>
<span class="p_add">+		memcpy_fromio((u8 *)&amp;msg_tmp + space_rem, bus-&gt;m_pdwGetRing,</span>
 			bytes_to_read - space_rem);
 
 	} else {
 		/* No wrapping */
<span class="p_del">-		memcpy(&amp;msg_tmp, bus-&gt;m_pdwGetRing + curr_grp, bytes_to_read);</span>
<span class="p_add">+		memcpy_fromio(&amp;msg_tmp, bus-&gt;m_pdwGetRing + curr_grp, bytes_to_read);</span>
 	}
<span class="p_add">+	/* Convert from little endian to CPU */</span>
<span class="p_add">+	msg_tmp.size = le16_to_cpu((__force __le16)msg_tmp.size);</span>
<span class="p_add">+	msg_tmp.command = le32_to_cpu((__force __le32)msg_tmp.command);</span>
<span class="p_add">+	msg_tmp.controlselector = le16_to_cpu((__force __le16)msg_tmp.controlselector);</span>
<span class="p_add">+	memcpy(msg, &amp;msg_tmp, sizeof(*msg));</span>
 
 	/* No need to update the read positions, because this was a peek */
 	/* If the caller specifically want to peek, return */
 	if (peekonly) {
<span class="p_del">-		memcpy(msg, &amp;msg_tmp, sizeof(*msg));</span>
 		goto peekout;
 	}
 
<span class="p_chunk">@@ -426,25 +442,19 @@</span> <span class="p_context"> int saa7164_bus_get(struct saa7164_dev *dev, struct tmComResInfo* msg,</span>
 		space_rem = bus-&gt;m_dwSizeGetRing - curr_grp;
 
 		if (space_rem &lt; sizeof(*msg)) {
<span class="p_del">-			/* msg wraps around the ring */</span>
<span class="p_del">-			memcpy(msg, bus-&gt;m_pdwGetRing + curr_grp, space_rem);</span>
<span class="p_del">-			memcpy((u8 *)msg + space_rem, bus-&gt;m_pdwGetRing,</span>
<span class="p_del">-				sizeof(*msg) - space_rem);</span>
 			if (buf)
<span class="p_del">-				memcpy(buf, bus-&gt;m_pdwGetRing + sizeof(*msg) -</span>
<span class="p_add">+				memcpy_fromio(buf, bus-&gt;m_pdwGetRing + sizeof(*msg) -</span>
 					space_rem, buf_size);
 
 		} else if (space_rem == sizeof(*msg)) {
<span class="p_del">-			memcpy(msg, bus-&gt;m_pdwGetRing + curr_grp, sizeof(*msg));</span>
 			if (buf)
<span class="p_del">-				memcpy(buf, bus-&gt;m_pdwGetRing, buf_size);</span>
<span class="p_add">+				memcpy_fromio(buf, bus-&gt;m_pdwGetRing, buf_size);</span>
 		} else {
 			/* Additional data wraps around the ring */
<span class="p_del">-			memcpy(msg, bus-&gt;m_pdwGetRing + curr_grp, sizeof(*msg));</span>
 			if (buf) {
<span class="p_del">-				memcpy(buf, bus-&gt;m_pdwGetRing + curr_grp +</span>
<span class="p_add">+				memcpy_fromio(buf, bus-&gt;m_pdwGetRing + curr_grp +</span>
 					sizeof(*msg), space_rem - sizeof(*msg));
<span class="p_del">-				memcpy(buf + space_rem - sizeof(*msg),</span>
<span class="p_add">+				memcpy_fromio(buf + space_rem - sizeof(*msg),</span>
 					bus-&gt;m_pdwGetRing, bytes_to_read -
 					space_rem);
 			}
<span class="p_chunk">@@ -453,19 +463,15 @@</span> <span class="p_context"> int saa7164_bus_get(struct saa7164_dev *dev, struct tmComResInfo* msg,</span>
 
 	} else {
 		/* No wrapping */
<span class="p_del">-		memcpy(msg, bus-&gt;m_pdwGetRing + curr_grp, sizeof(*msg));</span>
 		if (buf)
<span class="p_del">-			memcpy(buf, bus-&gt;m_pdwGetRing + curr_grp + sizeof(*msg),</span>
<span class="p_add">+			memcpy_fromio(buf, bus-&gt;m_pdwGetRing + curr_grp + sizeof(*msg),</span>
 				buf_size);
 	}
 
 	/* Update the read positions, adjusting the ring */
<span class="p_del">-	saa7164_writel(bus-&gt;m_dwGetReadPos, cpu_to_le32(new_grp));</span>
<span class="p_add">+	saa7164_writel(bus-&gt;m_dwGetReadPos, new_grp);</span>
 
 peekout:
<span class="p_del">-	msg-&gt;size = le16_to_cpu(msg-&gt;size);</span>
<span class="p_del">-	msg-&gt;command = le32_to_cpu(msg-&gt;command);</span>
<span class="p_del">-	msg-&gt;controlselector = le16_to_cpu(msg-&gt;controlselector);</span>
 	ret = SAA_OK;
 out:
 	mutex_unlock(&amp;bus-&gt;lock);
<span class="p_header">diff --git a/drivers/media/pci/saa7164/saa7164-core.c b/drivers/media/pci/saa7164/saa7164-core.c</span>
<span class="p_header">index 1bf06970ca3e..009140b64bde 100644</span>
<span class="p_header">--- a/drivers/media/pci/saa7164/saa7164-core.c</span>
<span class="p_header">+++ b/drivers/media/pci/saa7164/saa7164-core.c</span>
<span class="p_chunk">@@ -119,7 +119,7 @@</span> <span class="p_context"> static void saa7164_ts_verifier(struct saa7164_buffer *buf)</span>
 	u32 i;
 	u8 cc, a;
 	u16 pid;
<span class="p_del">-	u8 __iomem *bufcpu = (u8 *)buf-&gt;cpu;</span>
<span class="p_add">+	u8 *bufcpu = (u8 *)buf-&gt;cpu;</span>
 
 	port-&gt;sync_errors = 0;
 	port-&gt;v_cc_errors = 0;
<span class="p_chunk">@@ -260,7 +260,7 @@</span> <span class="p_context"> static void saa7164_work_enchandler_helper(struct saa7164_port *port, int bufnr)</span>
 	struct saa7164_user_buffer *ubuf = NULL;
 	struct list_head *c, *n;
 	int i = 0;
<span class="p_del">-	u8 __iomem *p;</span>
<span class="p_add">+	u8 *p;</span>
 
 	mutex_lock(&amp;port-&gt;dmaqueue_lock);
 	list_for_each_safe(c, n, &amp;port-&gt;dmaqueue.list) {
<span class="p_chunk">@@ -318,8 +318,7 @@</span> <span class="p_context"> static void saa7164_work_enchandler_helper(struct saa7164_port *port, int bufnr)</span>
 
 				if (buf-&gt;actual_size &lt;= ubuf-&gt;actual_size) {
 
<span class="p_del">-					memcpy_fromio(ubuf-&gt;data, buf-&gt;cpu,</span>
<span class="p_del">-						ubuf-&gt;actual_size);</span>
<span class="p_add">+					memcpy(ubuf-&gt;data, buf-&gt;cpu, ubuf-&gt;actual_size);</span>
 
 					if (crc_checking) {
 						/* Throw a new checksum on the read buffer */
<span class="p_chunk">@@ -346,7 +345,7 @@</span> <span class="p_context"> static void saa7164_work_enchandler_helper(struct saa7164_port *port, int bufnr)</span>
 			 * with known bad data. We check for this data at a later point
 			 * in time. */
 			saa7164_buffer_zero_offsets(port, bufnr);
<span class="p_del">-			memset_io(buf-&gt;cpu, 0xff, buf-&gt;pci_size);</span>
<span class="p_add">+			memset(buf-&gt;cpu, 0xff, buf-&gt;pci_size);</span>
 			if (crc_checking) {
 				/* Throw yet aanother new checksum on the dma buffer */
 				buf-&gt;crc = crc32(0, buf-&gt;cpu, buf-&gt;actual_size);
<span class="p_chunk">@@ -1096,7 +1095,7 @@</span> <span class="p_context"> static int saa7164_proc_show(struct seq_file *m, void *v)</span>
 			if (c == 0)
 				seq_printf(m, &quot; %04x:&quot;, i);
 
<span class="p_del">-			seq_printf(m, &quot; %02x&quot;, *(b-&gt;m_pdwSetRing + i));</span>
<span class="p_add">+			seq_printf(m, &quot; %02x&quot;, readb(b-&gt;m_pdwSetRing + i));</span>
 
 			if (++c == 16) {
 				seq_printf(m, &quot;\n&quot;);
<span class="p_chunk">@@ -1111,7 +1110,7 @@</span> <span class="p_context"> static int saa7164_proc_show(struct seq_file *m, void *v)</span>
 			if (c == 0)
 				seq_printf(m, &quot; %04x:&quot;, i);
 
<span class="p_del">-			seq_printf(m, &quot; %02x&quot;, *(b-&gt;m_pdwGetRing + i));</span>
<span class="p_add">+			seq_printf(m, &quot; %02x&quot;, readb(b-&gt;m_pdwGetRing + i));</span>
 
 			if (++c == 16) {
 				seq_printf(m, &quot;\n&quot;);
<span class="p_header">diff --git a/drivers/media/pci/saa7164/saa7164-fw.c b/drivers/media/pci/saa7164/saa7164-fw.c</span>
<span class="p_header">index 86763203d61d..add06ab5124d 100644</span>
<span class="p_header">--- a/drivers/media/pci/saa7164/saa7164-fw.c</span>
<span class="p_header">+++ b/drivers/media/pci/saa7164/saa7164-fw.c</span>
<span class="p_chunk">@@ -72,7 +72,7 @@</span> <span class="p_context"> static int saa7164_dl_wait_clr(struct saa7164_dev *dev, u32 reg)</span>
 /* TODO: move dlflags into dev-&gt; and change to write/readl/b */
 /* TODO: Excessive levels of debug */
 static int saa7164_downloadimage(struct saa7164_dev *dev, u8 *src, u32 srcsize,
<span class="p_del">-				 u32 dlflags, u8 *dst, u32 dstsize)</span>
<span class="p_add">+				 u32 dlflags, u8 __iomem *dst, u32 dstsize)</span>
 {
 	u32 reg, timeout, offset;
 	u8 *srcbuf = NULL;
<span class="p_chunk">@@ -136,7 +136,7 @@</span> <span class="p_context"> static int saa7164_downloadimage(struct saa7164_dev *dev, u8 *src, u32 srcsize,</span>
 		srcsize -= dstsize, offset += dstsize) {
 
 		dprintk(DBGLVL_FW, &quot;%s() memcpy %d\n&quot;, __func__, dstsize);
<span class="p_del">-		memcpy(dst, srcbuf + offset, dstsize);</span>
<span class="p_add">+		memcpy_toio(dst, srcbuf + offset, dstsize);</span>
 
 		/* Flag the data as ready */
 		saa7164_writel(drflag, 1);
<span class="p_chunk">@@ -154,7 +154,7 @@</span> <span class="p_context"> static int saa7164_downloadimage(struct saa7164_dev *dev, u8 *src, u32 srcsize,</span>
 
 	dprintk(DBGLVL_FW, &quot;%s() memcpy(l) %d\n&quot;, __func__, dstsize);
 	/* Write last block to the device */
<span class="p_del">-	memcpy(dst, srcbuf+offset, srcsize);</span>
<span class="p_add">+	memcpy_toio(dst, srcbuf+offset, srcsize);</span>
 
 	/* Flag the data as ready */
 	saa7164_writel(drflag, 1);
<span class="p_header">diff --git a/drivers/media/pci/saa7164/saa7164-types.h b/drivers/media/pci/saa7164/saa7164-types.h</span>
<span class="p_header">index 1d2140a3eb38..f48ba978f835 100644</span>
<span class="p_header">--- a/drivers/media/pci/saa7164/saa7164-types.h</span>
<span class="p_header">+++ b/drivers/media/pci/saa7164/saa7164-types.h</span>
<span class="p_chunk">@@ -78,9 +78,9 @@</span> <span class="p_context"> enum tmBusType {</span>
 struct tmComResBusInfo {
 	enum tmBusType Type;
 	u16	m_wMaxReqSize;
<span class="p_del">-	u8	*m_pdwSetRing;</span>
<span class="p_add">+	u8 __iomem *m_pdwSetRing;</span>
 	u32	m_dwSizeSetRing;
<span class="p_del">-	u8	*m_pdwGetRing;</span>
<span class="p_add">+	u8 __iomem *m_pdwGetRing;</span>
 	u32	m_dwSizeGetRing;
 	u32	m_dwSetWritePos;
 	u32	m_dwSetReadPos;
<span class="p_header">diff --git a/drivers/media/pci/saa7164/saa7164.h b/drivers/media/pci/saa7164/saa7164.h</span>
<span class="p_header">index 8b29e8990301..cd1a07ce27cb 100644</span>
<span class="p_header">--- a/drivers/media/pci/saa7164/saa7164.h</span>
<span class="p_header">+++ b/drivers/media/pci/saa7164/saa7164.h</span>
<span class="p_chunk">@@ -313,13 +313,13 @@</span> <span class="p_context"> struct saa7164_buffer {</span>
 
 	/* A block of page align PCI memory */
 	u32 pci_size;	/* PCI allocation size in bytes */
<span class="p_del">-	u64 __iomem *cpu;	/* Virtual address */</span>
<span class="p_add">+	u64 *cpu;	/* Virtual address */</span>
 	dma_addr_t dma;	/* Physical address */
 	u32 crc;	/* Checksum for the entire buffer data */
 
 	/* A page table that splits the block into a number of entries */
 	u32 pt_size;		/* PCI allocation size in bytes */
<span class="p_del">-	u64 __iomem *pt_cpu;		/* Virtual address */</span>
<span class="p_add">+	u64 *pt_cpu;		/* Virtual address */</span>
 	dma_addr_t pt_dma;	/* Physical address */
 
 	/* Encoder fops */
<span class="p_header">diff --git a/drivers/media/rc/mceusb.c b/drivers/media/rc/mceusb.c</span>
<span class="p_header">index 6afe8a211b22..107984cd4825 100644</span>
<span class="p_header">--- a/drivers/media/rc/mceusb.c</span>
<span class="p_header">+++ b/drivers/media/rc/mceusb.c</span>
<span class="p_chunk">@@ -765,6 +765,7 @@</span> <span class="p_context"> static void mce_request_packet(struct mceusb_dev *ir, unsigned char *data,</span>
 	} else if (urb_type == MCEUSB_RX) {
 		/* standard request */
 		async_urb = ir-&gt;urb_in;
<span class="p_add">+		async_buf = NULL;</span>
 		ir-&gt;send_flags = RECV_FLAG_IN_PROGRESS;
 
 	} else {
<span class="p_chunk">@@ -780,6 +781,10 @@</span> <span class="p_context"> static void mce_request_packet(struct mceusb_dev *ir, unsigned char *data,</span>
 	res = usb_submit_urb(async_urb, GFP_ATOMIC);
 	if (res) {
 		dev_err(dev, &quot;receive request FAILED! (res=%d)&quot;, res);
<span class="p_add">+		if (urb_type == MCEUSB_TX) {</span>
<span class="p_add">+			kfree(async_buf);</span>
<span class="p_add">+			usb_free_urb(async_urb);</span>
<span class="p_add">+		}</span>
 		return;
 	}
 	dev_dbg(dev, &quot;receive request complete (res=%d)&quot;, res);
<span class="p_header">diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c</span>
<span class="p_header">index 46272b0ae2dd..6890e726b04f 100644</span>
<span class="p_header">--- a/drivers/misc/ad525x_dpot.c</span>
<span class="p_header">+++ b/drivers/misc/ad525x_dpot.c</span>
<span class="p_chunk">@@ -457,7 +457,7 @@</span> <span class="p_context"> static ssize_t sysfs_set_reg(struct device *dev,</span>
 	int err;
 
 	if (reg &amp; DPOT_ADDR_OTP_EN) {
<span class="p_del">-		if (!strncmp(buf, &quot;enabled&quot;, sizeof(&quot;enabled&quot;)))</span>
<span class="p_add">+		if (sysfs_streq(buf, &quot;enabled&quot;))</span>
 			set_bit(DPOT_RDAC_MASK &amp; reg, data-&gt;otp_en_mask);
 		else
 			clear_bit(DPOT_RDAC_MASK &amp; reg, data-&gt;otp_en_mask);
<span class="p_header">diff --git a/drivers/misc/enclosure.c b/drivers/misc/enclosure.c</span>
<span class="p_header">index 2cf2bbc0b927..6cab9411b158 100644</span>
<span class="p_header">--- a/drivers/misc/enclosure.c</span>
<span class="p_header">+++ b/drivers/misc/enclosure.c</span>
<span class="p_chunk">@@ -320,6 +320,7 @@</span> <span class="p_context"> int enclosure_add_device(struct enclosure_device *edev, int component,</span>
 			 struct device *dev)
 {
 	struct enclosure_component *cdev;
<span class="p_add">+	int err;</span>
 
 	if (!edev || component &gt;= edev-&gt;components)
 		return -EINVAL;
<span class="p_chunk">@@ -329,12 +330,17 @@</span> <span class="p_context"> int enclosure_add_device(struct enclosure_device *edev, int component,</span>
 	if (cdev-&gt;dev == dev)
 		return -EEXIST;
 
<span class="p_del">-	if (cdev-&gt;dev)</span>
<span class="p_add">+	if (cdev-&gt;dev) {</span>
 		enclosure_remove_links(cdev);
<span class="p_del">-</span>
<span class="p_del">-	put_device(cdev-&gt;dev);</span>
<span class="p_add">+		put_device(cdev-&gt;dev);</span>
<span class="p_add">+	}</span>
 	cdev-&gt;dev = get_device(dev);
<span class="p_del">-	return enclosure_add_links(cdev);</span>
<span class="p_add">+	err = enclosure_add_links(cdev);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		put_device(cdev-&gt;dev);</span>
<span class="p_add">+		cdev-&gt;dev = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return err;</span>
 }
 EXPORT_SYMBOL_GPL(enclosure_add_device);
 
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000e/netdev.c b/drivers/net/ethernet/intel/e1000e/netdev.c</span>
<span class="p_header">index fe03a752b84b..388902518dd8 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000e/netdev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000e/netdev.c</span>
<span class="p_chunk">@@ -6031,6 +6031,28 @@</span> <span class="p_context"> static int e1000_init_phy_wakeup(struct e1000_adapter *adapter, u32 wufc)</span>
 	return retval;
 }
 
<span class="p_add">+static void e1000e_flush_lpic(struct pci_dev *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct net_device *netdev = pci_get_drvdata(pdev);</span>
<span class="p_add">+	struct e1000_adapter *adapter = netdev_priv(netdev);</span>
<span class="p_add">+	struct e1000_hw *hw = &amp;adapter-&gt;hw;</span>
<span class="p_add">+	u32 ret_val;</span>
<span class="p_add">+</span>
<span class="p_add">+	pm_runtime_get_sync(netdev-&gt;dev.parent);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret_val = hw-&gt;phy.ops.acquire(hw);</span>
<span class="p_add">+	if (ret_val)</span>
<span class="p_add">+		goto fl_out;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_info(&quot;EEE TX LPI TIMER: %08X\n&quot;,</span>
<span class="p_add">+		er32(LPIC) &gt;&gt; E1000_LPIC_LPIET_SHIFT);</span>
<span class="p_add">+</span>
<span class="p_add">+	hw-&gt;phy.ops.release(hw);</span>
<span class="p_add">+</span>
<span class="p_add">+fl_out:</span>
<span class="p_add">+	pm_runtime_put_sync(netdev-&gt;dev.parent);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int e1000e_pm_freeze(struct device *dev)
 {
 	struct net_device *netdev = pci_get_drvdata(to_pci_dev(dev));
<span class="p_chunk">@@ -6330,10 +6352,17 @@</span> <span class="p_context"> static int e1000e_pm_thaw(struct device *dev)</span>
 static int e1000e_pm_suspend(struct device *dev)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	e1000e_flush_lpic(pdev);</span>
 
 	e1000e_pm_freeze(dev);
 
<span class="p_del">-	return __e1000_shutdown(pdev, false);</span>
<span class="p_add">+	rc = __e1000_shutdown(pdev, false);</span>
<span class="p_add">+	if (rc)</span>
<span class="p_add">+		e1000e_pm_thaw(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	return rc;</span>
 }
 
 static int e1000e_pm_resume(struct device *dev)
<span class="p_chunk">@@ -6409,6 +6438,8 @@</span> <span class="p_context"> static int e1000e_pm_runtime_suspend(struct device *dev)</span>
 
 static void e1000_shutdown(struct pci_dev *pdev)
 {
<span class="p_add">+	e1000e_flush_lpic(pdev);</span>
<span class="p_add">+</span>
 	e1000e_pm_freeze(&amp;pdev-&gt;dev);
 
 	__e1000_shutdown(pdev, false);
<span class="p_header">diff --git a/drivers/net/hyperv/netvsc_drv.c b/drivers/net/hyperv/netvsc_drv.c</span>
<span class="p_header">index ab68d940a2c7..ff0e464441d0 100644</span>
<span class="p_header">--- a/drivers/net/hyperv/netvsc_drv.c</span>
<span class="p_header">+++ b/drivers/net/hyperv/netvsc_drv.c</span>
<span class="p_chunk">@@ -643,15 +643,18 @@</span> <span class="p_context"> int netvsc_recv_callback(struct hv_device *device_obj,</span>
 		packet-&gt;total_data_buflen);
 
 	skb-&gt;protocol = eth_type_trans(skb, net);
<span class="p_del">-	if (csum_info) {</span>
<span class="p_del">-		/* We only look at the IP checksum here.</span>
<span class="p_del">-		 * Should we be dropping the packet if checksum</span>
<span class="p_del">-		 * failed? How do we deal with other checksums - TCP/UDP?</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (csum_info-&gt;receive.ip_checksum_succeeded)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* skb is already created with CHECKSUM_NONE */</span>
<span class="p_add">+	skb_checksum_none_assert(skb);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In Linux, the IP checksum is always checked.</span>
<span class="p_add">+	 * Do L4 checksum offload if enabled and present.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (csum_info &amp;&amp; (net-&gt;features &amp; NETIF_F_RXCSUM)) {</span>
<span class="p_add">+		if (csum_info-&gt;receive.tcp_checksum_succeeded ||</span>
<span class="p_add">+		    csum_info-&gt;receive.udp_checksum_succeeded)</span>
 			skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
<span class="p_del">-		else</span>
<span class="p_del">-			skb-&gt;ip_summed = CHECKSUM_NONE;</span>
 	}
 
 	if (packet-&gt;vlan_tci &amp; VLAN_TAG_PRESENT)
<span class="p_header">diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c</span>
<span class="p_header">index 34f510f78d63..4bb359c79a32 100644</span>
<span class="p_header">--- a/drivers/net/vxlan.c</span>
<span class="p_header">+++ b/drivers/net/vxlan.c</span>
<span class="p_chunk">@@ -991,7 +991,7 @@</span> <span class="p_context"> static bool vxlan_snoop(struct net_device *dev,</span>
 			return false;
 
 		/* Don&#39;t migrate static entries, drop packets */
<span class="p_del">-		if (f-&gt;state &amp; NUD_NOARP)</span>
<span class="p_add">+		if (f-&gt;state &amp; (NUD_PERMANENT | NUD_NOARP))</span>
 			return true;
 
 		if (net_ratelimit())
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/ar9003_phy.c b/drivers/net/wireless/ath/ath9k/ar9003_phy.c</span>
<span class="p_header">index b81f885aa68c..341e3d0435ce 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/ar9003_phy.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.c</span>
<span class="p_chunk">@@ -1688,8 +1688,6 @@</span> <span class="p_context"> static void ar9003_hw_spectral_scan_wait(struct ath_hw *ah)</span>
 static void ar9003_hw_tx99_start(struct ath_hw *ah, u32 qnum)
 {
 	REG_SET_BIT(ah, AR_PHY_TEST, PHY_AGC_CLR);
<span class="p_del">-	REG_SET_BIT(ah, 0x9864, 0x7f000);</span>
<span class="p_del">-	REG_SET_BIT(ah, 0x9924, 0x7f00fe);</span>
 	REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);
 	REG_WRITE(ah, AR_CR, AR_CR_RXD);
 	REG_WRITE(ah, AR_DLCL_IFS(qnum), 0);
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/tx99.c b/drivers/net/wireless/ath/ath9k/tx99.c</span>
<span class="p_header">index a65cfb91adca..fa48dcf3fe03 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/tx99.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/tx99.c</span>
<span class="p_chunk">@@ -184,22 +184,27 @@</span> <span class="p_context"> static ssize_t write_file_tx99(struct file *file, const char __user *user_buf,</span>
 	if (strtobool(buf, &amp;start))
 		return -EINVAL;
 
<span class="p_add">+	mutex_lock(&amp;sc-&gt;mutex);</span>
<span class="p_add">+</span>
 	if (start == sc-&gt;tx99_state) {
 		if (!start)
<span class="p_del">-			return count;</span>
<span class="p_add">+			goto out;</span>
 		ath_dbg(common, XMIT, &quot;Resetting TX99\n&quot;);
 		ath9k_tx99_deinit(sc);
 	}
 
 	if (!start) {
 		ath9k_tx99_deinit(sc);
<span class="p_del">-		return count;</span>
<span class="p_add">+		goto out;</span>
 	}
 
 	r = ath9k_tx99_init(sc);
<span class="p_del">-	if (r)</span>
<span class="p_add">+	if (r) {</span>
<span class="p_add">+		mutex_unlock(&amp;sc-&gt;mutex);</span>
 		return r;
<span class="p_del">-</span>
<span class="p_add">+	}</span>
<span class="p_add">+out:</span>
<span class="p_add">+	mutex_unlock(&amp;sc-&gt;mutex);</span>
 	return count;
 }
 
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/mac80211.c b/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">index b690f7a4ae2f..142e18ff0941 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_chunk">@@ -1315,14 +1315,32 @@</span> <span class="p_context"> static void iwl_mvm_bss_info_changed_station(struct iwl_mvm *mvm,</span>
 			WARN_ONCE(iwl_mvm_sf_update(mvm, vif, false),
 				  &quot;Failed to update SF upon disassociation\n&quot;);
 
<span class="p_del">-			/* remove AP station now that the MAC is unassoc */</span>
<span class="p_del">-			ret = iwl_mvm_rm_sta_id(mvm, vif, mvmvif-&gt;ap_sta_id);</span>
<span class="p_del">-			if (ret)</span>
<span class="p_del">-				IWL_ERR(mvm, &quot;failed to remove AP station\n&quot;);</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * If we get an assert during the connection (after the</span>
<span class="p_add">+			 * station has been added, but before the vif is set</span>
<span class="p_add">+			 * to associated), mac80211 will re-add the station and</span>
<span class="p_add">+			 * then configure the vif. Since the vif is not</span>
<span class="p_add">+			 * associated, we would remove the station here and</span>
<span class="p_add">+			 * this would fail the recovery.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (!test_bit(IWL_MVM_STATUS_IN_HW_RESTART,</span>
<span class="p_add">+				      &amp;mvm-&gt;status)) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Remove AP station now that</span>
<span class="p_add">+				 * the MAC is unassoc</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				ret = iwl_mvm_rm_sta_id(mvm, vif,</span>
<span class="p_add">+							mvmvif-&gt;ap_sta_id);</span>
<span class="p_add">+				if (ret)</span>
<span class="p_add">+					IWL_ERR(mvm,</span>
<span class="p_add">+						&quot;failed to remove AP station\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (mvm-&gt;d0i3_ap_sta_id == mvmvif-&gt;ap_sta_id)</span>
<span class="p_add">+					mvm-&gt;d0i3_ap_sta_id =</span>
<span class="p_add">+						IWL_MVM_STATION_COUNT;</span>
<span class="p_add">+				mvmvif-&gt;ap_sta_id = IWL_MVM_STATION_COUNT;</span>
<span class="p_add">+			}</span>
 
<span class="p_del">-			if (mvm-&gt;d0i3_ap_sta_id == mvmvif-&gt;ap_sta_id)</span>
<span class="p_del">-				mvm-&gt;d0i3_ap_sta_id = IWL_MVM_STATION_COUNT;</span>
<span class="p_del">-			mvmvif-&gt;ap_sta_id = IWL_MVM_STATION_COUNT;</span>
 			/* remove quota for this interface */
 			ret = iwl_mvm_update_quotas(mvm, NULL);
 			if (ret)
<span class="p_header">diff --git a/drivers/net/wireless/libertas/mesh.c b/drivers/net/wireless/libertas/mesh.c</span>
<span class="p_header">index 6fef746345bc..99da58e99082 100644</span>
<span class="p_header">--- a/drivers/net/wireless/libertas/mesh.c</span>
<span class="p_header">+++ b/drivers/net/wireless/libertas/mesh.c</span>
<span class="p_chunk">@@ -240,8 +240,9 @@</span> <span class="p_context"> static ssize_t lbs_prb_rsp_limit_set(struct device *dev,</span>
 	memset(&amp;mesh_access, 0, sizeof(mesh_access));
 	mesh_access.data[0] = cpu_to_le32(CMD_ACT_SET);
 
<span class="p_del">-	if (!kstrtoul(buf, 10, &amp;retry_limit))</span>
<span class="p_del">-		return -ENOTSUPP;</span>
<span class="p_add">+	ret = kstrtoul(buf, 10, &amp;retry_limit);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 	if (retry_limit &gt; 15)
 		return -ENOTSUPP;
 
<span class="p_header">diff --git a/drivers/net/wireless/mwifiex/cfg80211.c b/drivers/net/wireless/mwifiex/cfg80211.c</span>
<span class="p_header">index 4e674c16d091..ca688991c4c1 100644</span>
<span class="p_header">--- a/drivers/net/wireless/mwifiex/cfg80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/mwifiex/cfg80211.c</span>
<span class="p_chunk">@@ -2160,6 +2160,7 @@</span> <span class="p_context"> struct wireless_dev *mwifiex_add_virtual_intf(struct wiphy *wiphy,</span>
 	struct net_device *dev;
 	void *mdev_priv;
 	struct wireless_dev *wdev;
<span class="p_add">+	int ret;</span>
 
 	if (!adapter)
 		return ERR_PTR(-EFAULT);
<span class="p_chunk">@@ -2254,8 +2255,8 @@</span> <span class="p_context"> struct wireless_dev *mwifiex_add_virtual_intf(struct wiphy *wiphy,</span>
 		priv-&gt;bss_num = 0;
 
 		if (mwifiex_cfg80211_init_p2p_client(priv)) {
<span class="p_del">-			wdev = ERR_PTR(-EFAULT);</span>
<span class="p_del">-			goto done;</span>
<span class="p_add">+			ret = -EFAULT;</span>
<span class="p_add">+			goto err_set_bss_mode;</span>
 		}
 
 		break;
<span class="p_chunk">@@ -2268,9 +2269,8 @@</span> <span class="p_context"> struct wireless_dev *mwifiex_add_virtual_intf(struct wiphy *wiphy,</span>
 			       ether_setup, IEEE80211_NUM_ACS, 1);
 	if (!dev) {
 		wiphy_err(wiphy, &quot;no memory available for netdevice\n&quot;);
<span class="p_del">-		priv-&gt;bss_mode = NL80211_IFTYPE_UNSPECIFIED;</span>
<span class="p_del">-		wdev = ERR_PTR(-ENOMEM);</span>
<span class="p_del">-		goto done;</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto err_alloc_netdev;</span>
 	}
 
 	mwifiex_init_priv_params(priv, dev);
<span class="p_chunk">@@ -2305,31 +2305,32 @@</span> <span class="p_context"> struct wireless_dev *mwifiex_add_virtual_intf(struct wiphy *wiphy,</span>
 
 	SET_NETDEV_DEV(dev, adapter-&gt;dev);
 
<span class="p_add">+	sema_init(&amp;priv-&gt;async_sem, 1);</span>
<span class="p_add">+</span>
 	/* Register network device */
 	if (register_netdevice(dev)) {
 		wiphy_err(wiphy, &quot;cannot register virtual network device\n&quot;);
<span class="p_del">-		free_netdev(dev);</span>
<span class="p_del">-		priv-&gt;bss_mode = NL80211_IFTYPE_UNSPECIFIED;</span>
<span class="p_del">-		priv-&gt;netdev = NULL;</span>
<span class="p_del">-		wdev = ERR_PTR(-EFAULT);</span>
<span class="p_del">-		goto done;</span>
<span class="p_add">+		ret = -EFAULT;</span>
<span class="p_add">+		goto err_reg_netdev;</span>
 	}
 
<span class="p_del">-	sema_init(&amp;priv-&gt;async_sem, 1);</span>
<span class="p_del">-</span>
 	dev_dbg(adapter-&gt;dev, &quot;info: %s: Marvell 802.11 Adapter\n&quot;, dev-&gt;name);
 
 #ifdef CONFIG_DEBUG_FS
 	mwifiex_dev_debugfs_init(priv);
 #endif
 
<span class="p_del">-done:</span>
<span class="p_del">-	if (IS_ERR(wdev)) {</span>
<span class="p_del">-		kfree(priv-&gt;wdev);</span>
<span class="p_del">-		priv-&gt;wdev = NULL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	return wdev;
<span class="p_add">+</span>
<span class="p_add">+err_reg_netdev:</span>
<span class="p_add">+	free_netdev(dev);</span>
<span class="p_add">+	priv-&gt;netdev = NULL;</span>
<span class="p_add">+err_set_bss_mode:</span>
<span class="p_add">+err_alloc_netdev:</span>
<span class="p_add">+	kfree(priv-&gt;wdev);</span>
<span class="p_add">+	priv-&gt;wdev = NULL;</span>
<span class="p_add">+	priv-&gt;bss_mode = NL80211_IFTYPE_UNSPECIFIED;</span>
<span class="p_add">+	return ERR_PTR(ret);</span>
 }
 EXPORT_SYMBOL_GPL(mwifiex_add_virtual_intf);
 
<span class="p_header">diff --git a/drivers/net/wireless/mwifiex/fw.h b/drivers/net/wireless/mwifiex/fw.h</span>
<span class="p_header">index 3175dd04834b..f58c6f1fba0c 100644</span>
<span class="p_header">--- a/drivers/net/wireless/mwifiex/fw.h</span>
<span class="p_header">+++ b/drivers/net/wireless/mwifiex/fw.h</span>
<span class="p_chunk">@@ -203,11 +203,6 @@</span> <span class="p_context"> enum MWIFIEX_802_11_PRIVACY_FILTER {</span>
 
 #define MWIFIEX_DEF_AMPDU	IEEE80211_HT_AMPDU_PARM_FACTOR
 
<span class="p_del">-#define GET_RXSTBC(x) (x &amp; IEEE80211_HT_CAP_RX_STBC)</span>
<span class="p_del">-#define MWIFIEX_RX_STBC1	0x0100</span>
<span class="p_del">-#define MWIFIEX_RX_STBC12	0x0200</span>
<span class="p_del">-#define MWIFIEX_RX_STBC123	0x0300</span>
<span class="p_del">-</span>
 /* dev_cap bitmap
  * BIT
  * 0-16		reserved
<span class="p_header">diff --git a/drivers/net/wireless/mwifiex/uap_cmd.c b/drivers/net/wireless/mwifiex/uap_cmd.c</span>
<span class="p_header">index 32643555dd2a..a6a6a53cda40 100644</span>
<span class="p_header">--- a/drivers/net/wireless/mwifiex/uap_cmd.c</span>
<span class="p_header">+++ b/drivers/net/wireless/mwifiex/uap_cmd.c</span>
<span class="p_chunk">@@ -159,7 +159,6 @@</span> <span class="p_context"> mwifiex_set_ht_params(struct mwifiex_private *priv,</span>
 		      struct cfg80211_ap_settings *params)
 {
 	const u8 *ht_ie;
<span class="p_del">-	u16 cap_info;</span>
 
 	if (!ISSUPP_11NENABLED(priv-&gt;adapter-&gt;fw_cap_info))
 		return;
<span class="p_chunk">@@ -169,27 +168,6 @@</span> <span class="p_context"> mwifiex_set_ht_params(struct mwifiex_private *priv,</span>
 	if (ht_ie) {
 		memcpy(&amp;bss_cfg-&gt;ht_cap, ht_ie + 2,
 		       sizeof(struct ieee80211_ht_cap));
<span class="p_del">-		cap_info = le16_to_cpu(bss_cfg-&gt;ht_cap.cap_info);</span>
<span class="p_del">-		memset(&amp;bss_cfg-&gt;ht_cap.mcs, 0,</span>
<span class="p_del">-		       priv-&gt;adapter-&gt;number_of_antenna);</span>
<span class="p_del">-		switch (GET_RXSTBC(cap_info)) {</span>
<span class="p_del">-		case MWIFIEX_RX_STBC1:</span>
<span class="p_del">-			/* HT_CAP 1X1 mode */</span>
<span class="p_del">-			bss_cfg-&gt;ht_cap.mcs.rx_mask[0] = 0xff;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case MWIFIEX_RX_STBC12:	/* fall through */</span>
<span class="p_del">-		case MWIFIEX_RX_STBC123:</span>
<span class="p_del">-			/* HT_CAP 2X2 mode */</span>
<span class="p_del">-			bss_cfg-&gt;ht_cap.mcs.rx_mask[0] = 0xff;</span>
<span class="p_del">-			bss_cfg-&gt;ht_cap.mcs.rx_mask[1] = 0xff;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		default:</span>
<span class="p_del">-			dev_warn(priv-&gt;adapter-&gt;dev,</span>
<span class="p_del">-				 &quot;Unsupported RX-STBC, default to 2x2\n&quot;);</span>
<span class="p_del">-			bss_cfg-&gt;ht_cap.mcs.rx_mask[0] = 0xff;</span>
<span class="p_del">-			bss_cfg-&gt;ht_cap.mcs.rx_mask[1] = 0xff;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
 		priv-&gt;ap_11n_enabled = 1;
 	} else {
 		memset(&amp;bss_cfg-&gt;ht_cap , 0, sizeof(struct ieee80211_ht_cap));
<span class="p_header">diff --git a/drivers/net/wireless/ti/wlcore/spi.c b/drivers/net/wireless/ti/wlcore/spi.c</span>
<span class="p_header">index a460fe669443..a57ee3893c5d 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wlcore/spi.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wlcore/spi.c</span>
<span class="p_chunk">@@ -30,6 +30,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/spi/spi.h&gt;
 #include &lt;linux/wl12xx.h&gt;
 #include &lt;linux/platform_device.h&gt;
<span class="p_add">+#include &lt;linux/sizes.h&gt;</span>
 
 #include &quot;wlcore.h&quot;
 #include &quot;wl12xx_80211.h&quot;
<span class="p_chunk">@@ -71,7 +72,7 @@</span> <span class="p_context"></span>
  * only support SPI for 12xx - this code should be reworked when 18xx
  * support is introduced
  */
<span class="p_del">-#define SPI_AGGR_BUFFER_SIZE (4 * PAGE_SIZE)</span>
<span class="p_add">+#define SPI_AGGR_BUFFER_SIZE (4 * SZ_4K)</span>
 
 /* Maximum number of SPI write chunks */
 #define WSPI_MAX_NUM_OF_CHUNKS \
<span class="p_header">diff --git a/drivers/parisc/ccio-dma.c b/drivers/parisc/ccio-dma.c</span>
<span class="p_header">index 8b490d77054f..0f2b2123d523 100644</span>
<span class="p_header">--- a/drivers/parisc/ccio-dma.c</span>
<span class="p_header">+++ b/drivers/parisc/ccio-dma.c</span>
<span class="p_chunk">@@ -743,6 +743,8 @@</span> <span class="p_context"> ccio_map_single(struct device *dev, void *addr, size_t size,</span>
 
 	BUG_ON(!dev);
 	ioc = GET_IOC(dev);
<span class="p_add">+	if (!ioc)</span>
<span class="p_add">+		return DMA_ERROR_CODE;</span>
 
 	BUG_ON(size &lt;= 0);
 
<span class="p_chunk">@@ -807,6 +809,10 @@</span> <span class="p_context"> ccio_unmap_single(struct device *dev, dma_addr_t iova, size_t size,</span>
 	
 	BUG_ON(!dev);
 	ioc = GET_IOC(dev);
<span class="p_add">+	if (!ioc) {</span>
<span class="p_add">+		WARN_ON(!ioc);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 
 	DBG_RUN(&quot;%s() iovp 0x%lx/%x\n&quot;,
 		__func__, (long)iova, size);
<span class="p_chunk">@@ -910,6 +916,8 @@</span> <span class="p_context"> ccio_map_sg(struct device *dev, struct scatterlist *sglist, int nents,</span>
 	
 	BUG_ON(!dev);
 	ioc = GET_IOC(dev);
<span class="p_add">+	if (!ioc)</span>
<span class="p_add">+		return 0;</span>
 	
 	DBG_RUN_SG(&quot;%s() START %d entries\n&quot;, __func__, nents);
 
<span class="p_chunk">@@ -982,6 +990,10 @@</span> <span class="p_context"> ccio_unmap_sg(struct device *dev, struct scatterlist *sglist, int nents,</span>
 
 	BUG_ON(!dev);
 	ioc = GET_IOC(dev);
<span class="p_add">+	if (!ioc) {</span>
<span class="p_add">+		WARN_ON(!ioc);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 
 	DBG_RUN_SG(&quot;%s() START %d entries,  %08lx,%x\n&quot;,
 		__func__, nents, sg_virt_addr(sglist), sglist-&gt;length);
<span class="p_header">diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c</span>
<span class="p_header">index 9eae9834bcc7..cf77ab14b681 100644</span>
<span class="p_header">--- a/drivers/parisc/dino.c</span>
<span class="p_header">+++ b/drivers/parisc/dino.c</span>
<span class="p_chunk">@@ -154,7 +154,10 @@</span> <span class="p_context"> struct dino_device</span>
 };
 
 /* Looks nice and keeps the compiler happy */
<span class="p_del">-#define DINO_DEV(d) ((struct dino_device *) d)</span>
<span class="p_add">+#define DINO_DEV(d) ({				\</span>
<span class="p_add">+	void *__pdata = d;			\</span>
<span class="p_add">+	BUG_ON(!__pdata);			\</span>
<span class="p_add">+	(struct dino_device *)__pdata; })</span>
 
 
 /*
<span class="p_header">diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c</span>
<span class="p_header">index 37e71ff6408d..4590515a275c 100644</span>
<span class="p_header">--- a/drivers/parisc/lba_pci.c</span>
<span class="p_header">+++ b/drivers/parisc/lba_pci.c</span>
<span class="p_chunk">@@ -111,8 +111,10 @@</span> <span class="p_context"> static u32 lba_t32;</span>
 
 
 /* Looks nice and keeps the compiler happy */
<span class="p_del">-#define LBA_DEV(d) ((struct lba_device *) (d))</span>
<span class="p_del">-</span>
<span class="p_add">+#define LBA_DEV(d) ({				\</span>
<span class="p_add">+	void *__pdata = d;			\</span>
<span class="p_add">+	BUG_ON(!__pdata);			\</span>
<span class="p_add">+	(struct lba_device *)__pdata; })</span>
 
 /*
 ** Only allow 8 subsidiary busses per LBA
<span class="p_header">diff --git a/drivers/parisc/sba_iommu.c b/drivers/parisc/sba_iommu.c</span>
<span class="p_header">index 1ff1b67e8b27..ad21a240f644 100644</span>
<span class="p_header">--- a/drivers/parisc/sba_iommu.c</span>
<span class="p_header">+++ b/drivers/parisc/sba_iommu.c</span>
<span class="p_chunk">@@ -691,6 +691,8 @@</span> <span class="p_context"> static int sba_dma_supported( struct device *dev, u64 mask)</span>
 		return 0;
 
 	ioc = GET_IOC(dev);
<span class="p_add">+	if (!ioc)</span>
<span class="p_add">+		return 0;</span>
 
 	/*
 	 * check if mask is &gt;= than the current max IO Virt Address
<span class="p_chunk">@@ -722,6 +724,8 @@</span> <span class="p_context"> sba_map_single(struct device *dev, void *addr, size_t size,</span>
 	int pide;
 
 	ioc = GET_IOC(dev);
<span class="p_add">+	if (!ioc)</span>
<span class="p_add">+		return DMA_ERROR_CODE;</span>
 
 	/* save offset bits */
 	offset = ((dma_addr_t) (long) addr) &amp; ~IOVP_MASK;
<span class="p_chunk">@@ -803,6 +807,10 @@</span> <span class="p_context"> sba_unmap_single(struct device *dev, dma_addr_t iova, size_t size,</span>
 	DBG_RUN(&quot;%s() iovp 0x%lx/%x\n&quot;, __func__, (long) iova, size);
 
 	ioc = GET_IOC(dev);
<span class="p_add">+	if (!ioc) {</span>
<span class="p_add">+		WARN_ON(!ioc);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 	offset = iova &amp; ~IOVP_MASK;
 	iova ^= offset;        /* clear offset bits */
 	size += offset;
<span class="p_chunk">@@ -942,6 +950,8 @@</span> <span class="p_context"> sba_map_sg(struct device *dev, struct scatterlist *sglist, int nents,</span>
 	DBG_RUN_SG(&quot;%s() START %d entries\n&quot;, __func__, nents);
 
 	ioc = GET_IOC(dev);
<span class="p_add">+	if (!ioc)</span>
<span class="p_add">+		return 0;</span>
 
 	/* Fast path single entry scatterlists. */
 	if (nents == 1) {
<span class="p_chunk">@@ -1028,6 +1038,10 @@</span> <span class="p_context"> sba_unmap_sg(struct device *dev, struct scatterlist *sglist, int nents,</span>
 		__func__, nents, sg_virt_addr(sglist), sglist-&gt;length);
 
 	ioc = GET_IOC(dev);
<span class="p_add">+	if (!ioc) {</span>
<span class="p_add">+		WARN_ON(!ioc);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 
 #ifdef SBA_COLLECT_STATS
 	ioc-&gt;usg_calls++;
<span class="p_header">diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c</span>
<span class="p_header">index e2bab48f6446..51cdff7c2c01 100644</span>
<span class="p_header">--- a/drivers/pci/pci-driver.c</span>
<span class="p_header">+++ b/drivers/pci/pci-driver.c</span>
<span class="p_chunk">@@ -922,6 +922,7 @@</span> <span class="p_context"> static int pci_pm_thaw_noirq(struct device *dev)</span>
 		return pci_legacy_resume_early(dev);
 
 	pci_update_current_state(pci_dev, PCI_D0);
<span class="p_add">+	pci_restore_state(pci_dev);</span>
 
 	if (drv &amp;&amp; drv-&gt;pm &amp;&amp; drv-&gt;pm-&gt;thaw_noirq)
 		error = drv-&gt;pm-&gt;thaw_noirq(dev);
<span class="p_header">diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c</span>
<span class="p_header">index 7505fa72ea5d..0ca2961a56a2 100644</span>
<span class="p_header">--- a/drivers/pci/pci-sysfs.c</span>
<span class="p_header">+++ b/drivers/pci/pci-sysfs.c</span>
<span class="p_chunk">@@ -1367,10 +1367,10 @@</span> <span class="p_context"> int __must_check pci_create_sysfs_dev_files(struct pci_dev *pdev)</span>
 	if (!sysfs_initialized)
 		return -EACCES;
 
<span class="p_del">-	if (pdev-&gt;cfg_size &lt; PCI_CFG_SPACE_EXP_SIZE)</span>
<span class="p_del">-		retval = sysfs_create_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pci_config_attr);</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (pdev-&gt;cfg_size &gt; PCI_CFG_SPACE_SIZE)</span>
 		retval = sysfs_create_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pcie_config_attr);
<span class="p_add">+	else</span>
<span class="p_add">+		retval = sysfs_create_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pci_config_attr);</span>
 	if (retval)
 		goto err;
 
<span class="p_chunk">@@ -1422,10 +1422,10 @@</span> <span class="p_context"> int __must_check pci_create_sysfs_dev_files(struct pci_dev *pdev)</span>
 err_resource_files:
 	pci_remove_resource_files(pdev);
 err_config_file:
<span class="p_del">-	if (pdev-&gt;cfg_size &lt; PCI_CFG_SPACE_EXP_SIZE)</span>
<span class="p_del">-		sysfs_remove_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pci_config_attr);</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (pdev-&gt;cfg_size &gt; PCI_CFG_SPACE_SIZE)</span>
 		sysfs_remove_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pcie_config_attr);
<span class="p_add">+	else</span>
<span class="p_add">+		sysfs_remove_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pci_config_attr);</span>
 err:
 	return retval;
 }
<span class="p_chunk">@@ -1459,10 +1459,10 @@</span> <span class="p_context"> void pci_remove_sysfs_dev_files(struct pci_dev *pdev)</span>
 
 	pci_remove_capabilities_sysfs(pdev);
 
<span class="p_del">-	if (pdev-&gt;cfg_size &lt; PCI_CFG_SPACE_EXP_SIZE)</span>
<span class="p_del">-		sysfs_remove_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pci_config_attr);</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (pdev-&gt;cfg_size &gt; PCI_CFG_SPACE_SIZE)</span>
 		sysfs_remove_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pcie_config_attr);
<span class="p_add">+	else</span>
<span class="p_add">+		sysfs_remove_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pci_config_attr);</span>
 
 	pci_remove_resource_files(pdev);
 
<span class="p_header">diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c</span>
<span class="p_header">index 914c1cbe4d3e..bc4147bfe0ad 100644</span>
<span class="p_header">--- a/drivers/pci/quirks.c</span>
<span class="p_header">+++ b/drivers/pci/quirks.c</span>
<span class="p_chunk">@@ -288,12 +288,24 @@</span> <span class="p_context"> static void quirk_citrine(struct pci_dev *dev)</span>
 }
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_IBM,	PCI_DEVICE_ID_IBM_CITRINE,	quirk_citrine);
 
<span class="p_add">+/*</span>
<span class="p_add">+ * This chip can cause bus lockups if config addresses above 0x600</span>
<span class="p_add">+ * are read or written.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void quirk_nfp6000(struct pci_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dev-&gt;cfg_size = 0x600;</span>
<span class="p_add">+}</span>
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NETRONOME,	PCI_DEVICE_ID_NETRONOME_NFP4000,	quirk_nfp6000);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NETRONOME,	PCI_DEVICE_ID_NETRONOME_NFP6000,	quirk_nfp6000);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NETRONOME,	PCI_DEVICE_ID_NETRONOME_NFP6000_VF,	quirk_nfp6000);</span>
<span class="p_add">+</span>
 /*  On IBM Crocodile ipr SAS adapters, expand BAR to system page size */
 static void quirk_extend_bar_to_page(struct pci_dev *dev)
 {
 	int i;
 
<span class="p_del">-	for (i = 0; i &lt; PCI_STD_RESOURCE_END; i++) {</span>
<span class="p_add">+	for (i = 0; i &lt;= PCI_STD_RESOURCE_END; i++) {</span>
 		struct resource *r = &amp;dev-&gt;resource[i];
 
 		if (r-&gt;flags &amp; IORESOURCE_MEM &amp;&amp; resource_size(r) &lt; PAGE_SIZE) {
<span class="p_header">diff --git a/drivers/pinctrl/pinctrl-imx.c b/drivers/pinctrl/pinctrl-imx.c</span>
<span class="p_header">index 6cd65e6987e4..1c489e179149 100644</span>
<span class="p_header">--- a/drivers/pinctrl/pinctrl-imx.c</span>
<span class="p_header">+++ b/drivers/pinctrl/pinctrl-imx.c</span>
<span class="p_chunk">@@ -216,11 +216,13 @@</span> <span class="p_context"> static int imx_pmx_enable(struct pinctrl_dev *pctldev, unsigned selector,</span>
 			reg &amp;= ~(0x7 &lt;&lt; 20);
 			reg |= (pin-&gt;mux_mode &lt;&lt; 20);
 			writel(reg, ipctl-&gt;base + pin_reg-&gt;mux_reg);
<span class="p_add">+			dev_dbg(ipctl-&gt;dev, &quot;write: offset 0x%x val 0x%x\n&quot;,</span>
<span class="p_add">+				pin_reg-&gt;mux_reg, reg);</span>
 		} else {
 			writel(pin-&gt;mux_mode, ipctl-&gt;base + pin_reg-&gt;mux_reg);
<span class="p_add">+			dev_dbg(ipctl-&gt;dev, &quot;write: offset 0x%x val 0x%x\n&quot;,</span>
<span class="p_add">+				pin_reg-&gt;mux_reg, pin-&gt;mux_mode);</span>
 		}
<span class="p_del">-		dev_dbg(ipctl-&gt;dev, &quot;write: offset 0x%x val 0x%x\n&quot;,</span>
<span class="p_del">-			pin_reg-&gt;mux_reg, pin-&gt;mux_mode);</span>
 
 		/*
 		 * If the select input value begins with 0xff, it&#39;s a quirky
<span class="p_chunk">@@ -347,11 +349,13 @@</span> <span class="p_context"> static int imx_pinconf_set(struct pinctrl_dev *pctldev,</span>
 			reg &amp;= ~0xffff;
 			reg |= configs[i];
 			writel(reg, ipctl-&gt;base + pin_reg-&gt;conf_reg);
<span class="p_add">+			dev_dbg(ipctl-&gt;dev, &quot;write: offset 0x%x val 0x%x\n&quot;,</span>
<span class="p_add">+				pin_reg-&gt;conf_reg, reg);</span>
 		} else {
 			writel(configs[i], ipctl-&gt;base + pin_reg-&gt;conf_reg);
<span class="p_add">+			dev_dbg(ipctl-&gt;dev, &quot;write: offset 0x%x val 0x%lx\n&quot;,</span>
<span class="p_add">+				pin_reg-&gt;conf_reg, configs[i]);</span>
 		}
<span class="p_del">-		dev_dbg(ipctl-&gt;dev, &quot;write: offset 0x%x val 0x%lx\n&quot;,</span>
<span class="p_del">-			pin_reg-&gt;conf_reg, configs[i]);</span>
 	} /* for each config */
 
 	return 0;
<span class="p_header">diff --git a/drivers/rtc/rtc-nuc900.c b/drivers/rtc/rtc-nuc900.c</span>
<span class="p_header">index a53da0958e95..2c87abef1baa 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-nuc900.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-nuc900.c</span>
<span class="p_chunk">@@ -93,7 +93,7 @@</span> <span class="p_context"> static int *check_rtc_access_enable(struct nuc900_rtc *nuc900_rtc)</span>
 	__raw_writel(AERPOWERON, nuc900_rtc-&gt;rtc_reg + REG_RTC_AER);
 
 	while (!(__raw_readl(nuc900_rtc-&gt;rtc_reg + REG_RTC_AER) &amp; AERRWENB)
<span class="p_del">-								&amp;&amp; timeout--)</span>
<span class="p_add">+								&amp;&amp; --timeout)</span>
 		mdelay(1);
 
 	if (!timeout)
<span class="p_header">diff --git a/drivers/scsi/bnx2i/bnx2i_iscsi.c b/drivers/scsi/bnx2i/bnx2i_iscsi.c</span>
<span class="p_header">index 166543f7ef55..0bf408ac5b7a 100644</span>
<span class="p_header">--- a/drivers/scsi/bnx2i/bnx2i_iscsi.c</span>
<span class="p_header">+++ b/drivers/scsi/bnx2i/bnx2i_iscsi.c</span>
<span class="p_chunk">@@ -1906,7 +1906,8 @@</span> <span class="p_context"> static struct iscsi_endpoint *bnx2i_ep_connect(struct Scsi_Host *shost,</span>
 
 	bnx2i_ep_active_list_add(hba, bnx2i_ep);
 
<span class="p_del">-	if (bnx2i_map_ep_dbell_regs(bnx2i_ep))</span>
<span class="p_add">+	rc = bnx2i_map_ep_dbell_regs(bnx2i_ep);</span>
<span class="p_add">+	if (rc)</span>
 		goto del_active_ep;
 
 	mutex_unlock(&amp;hba-&gt;net_dev_lock);
<span class="p_header">diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c</span>
<span class="p_header">index 81d4151179d8..c31e1cb009af 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_scan.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_scan.c</span>
<span class="p_chunk">@@ -387,11 +387,12 @@</span> <span class="p_context"> static void scsi_target_reap_ref_release(struct kref *kref)</span>
 		= container_of(kref, struct scsi_target, reap_ref);
 
 	/*
<span class="p_del">-	 * if we get here and the target is still in the CREATED state that</span>
<span class="p_add">+	 * if we get here and the target is still in a CREATED state that</span>
 	 * means it was allocated but never made visible (because a scan
 	 * turned up no LUNs), so don&#39;t call device_del() on it.
 	 */
<span class="p_del">-	if (starget-&gt;state != STARGET_CREATED) {</span>
<span class="p_add">+	if ((starget-&gt;state != STARGET_CREATED) &amp;&amp;</span>
<span class="p_add">+	    (starget-&gt;state != STARGET_CREATED_REMOVE)) {</span>
 		transport_remove_device(&amp;starget-&gt;dev);
 		device_del(&amp;starget-&gt;dev);
 	}
<span class="p_header">diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c</span>
<span class="p_header">index ae280e7d3831..5c35a9578dd7 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_sysfs.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_sysfs.c</span>
<span class="p_chunk">@@ -1151,11 +1151,15 @@</span> <span class="p_context"> void scsi_remove_target(struct device *dev)</span>
 	spin_lock_irqsave(shost-&gt;host_lock, flags);
 	list_for_each_entry(starget, &amp;shost-&gt;__targets, siblings) {
 		if (starget-&gt;state == STARGET_DEL ||
<span class="p_del">-		    starget-&gt;state == STARGET_REMOVE)</span>
<span class="p_add">+		    starget-&gt;state == STARGET_REMOVE ||</span>
<span class="p_add">+		    starget-&gt;state == STARGET_CREATED_REMOVE)</span>
 			continue;
 		if (starget-&gt;dev.parent == dev || &amp;starget-&gt;dev == dev) {
 			kref_get(&amp;starget-&gt;reap_ref);
<span class="p_del">-			starget-&gt;state = STARGET_REMOVE;</span>
<span class="p_add">+			if (starget-&gt;state == STARGET_CREATED)</span>
<span class="p_add">+				starget-&gt;state = STARGET_CREATED_REMOVE;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				starget-&gt;state = STARGET_REMOVE;</span>
 			spin_unlock_irqrestore(shost-&gt;host_lock, flags);
 			__scsi_remove_target(starget);
 			scsi_target_reap(starget);
<span class="p_header">diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c</span>
<span class="p_header">index 0102a2d70dd8..858085beb902 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_transport_iscsi.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_transport_iscsi.c</span>
<span class="p_chunk">@@ -3689,7 +3689,7 @@</span> <span class="p_context"> iscsi_if_rx(struct sk_buff *skb)</span>
 		uint32_t group;
 
 		nlh = nlmsg_hdr(skb);
<span class="p_del">-		if (nlh-&gt;nlmsg_len &lt; sizeof(*nlh) ||</span>
<span class="p_add">+		if (nlh-&gt;nlmsg_len &lt; sizeof(*nlh) + sizeof(*ev) ||</span>
 		    skb-&gt;len &lt; nlh-&gt;nlmsg_len) {
 			break;
 		}
<span class="p_header">diff --git a/drivers/scsi/sun_esp.c b/drivers/scsi/sun_esp.c</span>
<span class="p_header">index f2e68459f7ea..6585d75bf732 100644</span>
<span class="p_header">--- a/drivers/scsi/sun_esp.c</span>
<span class="p_header">+++ b/drivers/scsi/sun_esp.c</span>
<span class="p_chunk">@@ -566,6 +566,7 @@</span> <span class="p_context"> static int esp_sbus_probe(struct platform_device *op)</span>
 	struct device_node *dp = op-&gt;dev.of_node;
 	struct platform_device *dma_of = NULL;
 	int hme = 0;
<span class="p_add">+	int ret;</span>
 
 	if (dp-&gt;parent &amp;&amp;
 	    (!strcmp(dp-&gt;parent-&gt;name, &quot;espdma&quot;) ||
<span class="p_chunk">@@ -580,7 +581,11 @@</span> <span class="p_context"> static int esp_sbus_probe(struct platform_device *op)</span>
 	if (!dma_of)
 		return -ENODEV;
 
<span class="p_del">-	return esp_sbus_probe_one(op, dma_of, hme);</span>
<span class="p_add">+	ret = esp_sbus_probe_one(op, dma_of, hme);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		put_device(&amp;dma_of-&gt;dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int esp_sbus_remove(struct platform_device *op)
<span class="p_chunk">@@ -613,6 +618,8 @@</span> <span class="p_context"> static int esp_sbus_remove(struct platform_device *op)</span>
 
 	dev_set_drvdata(&amp;op-&gt;dev, NULL);
 
<span class="p_add">+	put_device(&amp;dma_of-&gt;dev);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/scsi/virtio_scsi.c b/drivers/scsi/virtio_scsi.c</span>
<span class="p_header">index 308256b5e4cb..42ecf4c18e2e 100644</span>
<span class="p_header">--- a/drivers/scsi/virtio_scsi.c</span>
<span class="p_header">+++ b/drivers/scsi/virtio_scsi.c</span>
<span class="p_chunk">@@ -686,6 +686,16 @@</span> <span class="p_context"> static void virtscsi_target_destroy(struct scsi_target *starget)</span>
 	kfree(tgt);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * The host guarantees to respond to each command, although I/O</span>
<span class="p_add">+ * latencies might be higher than on bare metal.  Reset the timer</span>
<span class="p_add">+ * unconditionally to give the host a chance to perform EH.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static enum blk_eh_timer_return virtscsi_eh_timed_out(struct scsi_cmnd *scmnd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return BLK_EH_RESET_TIMER;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct scsi_host_template virtscsi_host_template_single = {
 	.module = THIS_MODULE,
 	.name = &quot;Virtio SCSI HBA&quot;,
<span class="p_chunk">@@ -695,6 +705,7 @@</span> <span class="p_context"> static struct scsi_host_template virtscsi_host_template_single = {</span>
 	.queuecommand = virtscsi_queuecommand_single,
 	.eh_abort_handler = virtscsi_abort,
 	.eh_device_reset_handler = virtscsi_device_reset,
<span class="p_add">+	.eh_timed_out = virtscsi_eh_timed_out,</span>
 
 	.can_queue = 1024,
 	.dma_boundary = UINT_MAX,
<span class="p_chunk">@@ -712,6 +723,7 @@</span> <span class="p_context"> static struct scsi_host_template virtscsi_host_template_multi = {</span>
 	.queuecommand = virtscsi_queuecommand_multi,
 	.eh_abort_handler = virtscsi_abort,
 	.eh_device_reset_handler = virtscsi_device_reset,
<span class="p_add">+	.eh_timed_out = virtscsi_eh_timed_out,</span>
 
 	.can_queue = 1024,
 	.dma_boundary = UINT_MAX,
<span class="p_header">diff --git a/drivers/spi/spi-atmel.c b/drivers/spi/spi-atmel.c</span>
<span class="p_header">index bbf7c5e79b95..7bfd64f7d76b 100644</span>
<span class="p_header">--- a/drivers/spi/spi-atmel.c</span>
<span class="p_header">+++ b/drivers/spi/spi-atmel.c</span>
<span class="p_chunk">@@ -206,6 +206,7 @@</span> <span class="p_context"> struct atmel_spi_caps {</span>
 	bool	is_spi2;
 	bool	has_wdrbt;
 	bool	has_dma_support;
<span class="p_add">+	bool	has_pdc_support;</span>
 };
 
 /*
<span class="p_chunk">@@ -1278,7 +1279,28 @@</span> <span class="p_context"> static void atmel_get_caps(struct atmel_spi *as)</span>
 
 	as-&gt;caps.is_spi2 = version &gt; 0x121;
 	as-&gt;caps.has_wdrbt = version &gt;= 0x210;
<span class="p_add">+#ifdef CONFIG_SOC_SAM_V4_V5</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Atmel SoCs based on ARM9 (SAM9x) cores should not use spi_map_buf()</span>
<span class="p_add">+	 * since this later function tries to map buffers with dma_map_sg()</span>
<span class="p_add">+	 * even if they have not been allocated inside DMA-safe areas.</span>
<span class="p_add">+	 * On SoCs based on Cortex A5 (SAMA5Dx), it works anyway because for</span>
<span class="p_add">+	 * those ARM cores, the data cache follows the PIPT model.</span>
<span class="p_add">+	 * Also the L2 cache controller of SAMA5D2 uses the PIPT model too.</span>
<span class="p_add">+	 * In case of PIPT caches, there cannot be cache aliases.</span>
<span class="p_add">+	 * However on ARM9 cores, the data cache follows the VIVT model, hence</span>
<span class="p_add">+	 * the cache aliases issue can occur when buffers are allocated from</span>
<span class="p_add">+	 * DMA-unsafe areas, by vmalloc() for instance, where cache coherency is</span>
<span class="p_add">+	 * not taken into account or at least not handled completely (cache</span>
<span class="p_add">+	 * lines of aliases are not invalidated).</span>
<span class="p_add">+	 * This is not a theorical issue: it was reproduced when trying to mount</span>
<span class="p_add">+	 * a UBI file-system on a at91sam9g35ek board.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	as-&gt;caps.has_dma_support = false;</span>
<span class="p_add">+#else</span>
 	as-&gt;caps.has_dma_support = version &gt;= 0x212;
<span class="p_add">+#endif</span>
<span class="p_add">+	as-&gt;caps.has_pdc_support = version &lt; 0x212;</span>
 }
 
 /*-------------------------------------------------------------------------*/
<span class="p_chunk">@@ -1356,7 +1378,7 @@</span> <span class="p_context"> static int atmel_spi_probe(struct platform_device *pdev)</span>
 	if (as-&gt;caps.has_dma_support) {
 		if (atmel_spi_configure_dma(as) == 0)
 			as-&gt;use_dma = true;
<span class="p_del">-	} else {</span>
<span class="p_add">+	} else if (as-&gt;caps.has_pdc_support) {</span>
 		as-&gt;use_pdc = true;
 	}
 
<span class="p_header">diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c</span>
<span class="p_header">index 47a9a5cf3447..f3fb3d95dfd0 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/comedi_fops.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/comedi_fops.c</span>
<span class="p_chunk">@@ -2626,6 +2626,7 @@</span> <span class="p_context"> static int __init comedi_init(void)</span>
 		dev = comedi_alloc_board_minor(NULL);
 		if (IS_ERR(dev)) {
 			comedi_cleanup_board_minors();
<span class="p_add">+			class_destroy(comedi_class);</span>
 			cdev_del(&amp;comedi_cdev);
 			unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),
 						 COMEDI_NUM_MINORS);
<span class="p_header">diff --git a/drivers/staging/usbip/stub_main.c b/drivers/staging/usbip/stub_main.c</span>
<span class="p_header">index 9c5832abbdf1..7c08d6e47221 100644</span>
<span class="p_header">--- a/drivers/staging/usbip/stub_main.c</span>
<span class="p_header">+++ b/drivers/staging/usbip/stub_main.c</span>
<span class="p_chunk">@@ -266,7 +266,11 @@</span> <span class="p_context"> void stub_device_cleanup_urbs(struct stub_device *sdev)</span>
 		kmem_cache_free(stub_priv_cache, priv);
 
 		kfree(urb-&gt;transfer_buffer);
<span class="p_add">+		urb-&gt;transfer_buffer = NULL;</span>
<span class="p_add">+</span>
 		kfree(urb-&gt;setup_packet);
<span class="p_add">+		urb-&gt;setup_packet = NULL;</span>
<span class="p_add">+</span>
 		usb_free_urb(urb);
 	}
 }
<span class="p_header">diff --git a/drivers/staging/usbip/stub_tx.c b/drivers/staging/usbip/stub_tx.c</span>
<span class="p_header">index dbcabc9dbe0d..021003c4de53 100644</span>
<span class="p_header">--- a/drivers/staging/usbip/stub_tx.c</span>
<span class="p_header">+++ b/drivers/staging/usbip/stub_tx.c</span>
<span class="p_chunk">@@ -28,7 +28,11 @@</span> <span class="p_context"> static void stub_free_priv_and_urb(struct stub_priv *priv)</span>
 	struct urb *urb = priv-&gt;urb;
 
 	kfree(urb-&gt;setup_packet);
<span class="p_add">+	urb-&gt;setup_packet = NULL;</span>
<span class="p_add">+</span>
 	kfree(urb-&gt;transfer_buffer);
<span class="p_add">+	urb-&gt;transfer_buffer = NULL;</span>
<span class="p_add">+</span>
 	list_del(&amp;priv-&gt;list);
 	kmem_cache_free(stub_priv_cache, priv);
 	usb_free_urb(urb);
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_configfs.c b/drivers/target/iscsi/iscsi_target_configfs.c</span>
<span class="p_header">index e7785e29a858..425e4c7969e9 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_configfs.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_configfs.c</span>
<span class="p_chunk">@@ -1057,6 +1057,8 @@</span> <span class="p_context"> TPG_ATTR(default_erl, S_IRUGO | S_IWUSR);</span>
  */
 DEF_TPG_ATTRIB(t10_pi);
 TPG_ATTR(t10_pi, S_IRUGO | S_IWUSR);
<span class="p_add">+DEF_TPG_ATTRIB(login_keys_workaround);</span>
<span class="p_add">+TPG_ATTR(login_keys_workaround, S_IRUGO | S_IWUSR);</span>
 
 static struct configfs_attribute *lio_target_tpg_attrib_attrs[] = {
 	&amp;iscsi_tpg_attrib_authentication.attr,
<span class="p_chunk">@@ -1070,6 +1072,7 @@</span> <span class="p_context"> static struct configfs_attribute *lio_target_tpg_attrib_attrs[] = {</span>
 	&amp;iscsi_tpg_attrib_demo_mode_discovery.attr,
 	&amp;iscsi_tpg_attrib_default_erl.attr,
 	&amp;iscsi_tpg_attrib_t10_pi.attr,
<span class="p_add">+	&amp;iscsi_tpg_attrib_login_keys_workaround.attr,</span>
 	NULL,
 };
 
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_core.h b/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_header">index 1863de28ce46..f8e14dda29f6 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_chunk">@@ -60,6 +60,14 @@</span> <span class="p_context"></span>
 #define TA_CACHE_CORE_NPS		0
 /* T10 protection information disabled by default */
 #define TA_DEFAULT_T10_PI		0
<span class="p_add">+/*</span>
<span class="p_add">+ * Used to control the sending of keys with optional to respond state bit,</span>
<span class="p_add">+ * as a workaround for non RFC compliant initiators,that do not propose,</span>
<span class="p_add">+ * nor respond to specific keys required for login to complete.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * See iscsi_check_proposer_for_optional_reply() for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define TA_DEFAULT_LOGIN_KEYS_WORKAROUND 1</span>
 
 #define ISCSI_IOV_DATA_BUFFER		5
 
<span class="p_chunk">@@ -774,6 +782,7 @@</span> <span class="p_context"> struct iscsi_tpg_attrib {</span>
 	u32			demo_mode_discovery;
 	u32			default_erl;
 	u8			t10_pi;
<span class="p_add">+	u32			login_keys_workaround;</span>
 	struct iscsi_portal_group *tpg;
 };
 
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_nego.c b/drivers/target/iscsi/iscsi_target_nego.c</span>
<span class="p_header">index c15cfcb3fcc9..d2d4b5010447 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_nego.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_nego.c</span>
<span class="p_chunk">@@ -887,7 +887,8 @@</span> <span class="p_context"> static int iscsi_target_handle_csg_zero(</span>
 			SENDER_TARGET,
 			login-&gt;rsp_buf,
 			&amp;login-&gt;rsp_length,
<span class="p_del">-			conn-&gt;param_list);</span>
<span class="p_add">+			conn-&gt;param_list,</span>
<span class="p_add">+			conn-&gt;tpg-&gt;tpg_attrib.login_keys_workaround);</span>
 	if (ret &lt; 0)
 		return -1;
 
<span class="p_chunk">@@ -957,7 +958,8 @@</span> <span class="p_context"> static int iscsi_target_handle_csg_one(struct iscsi_conn *conn, struct iscsi_log</span>
 			SENDER_TARGET,
 			login-&gt;rsp_buf,
 			&amp;login-&gt;rsp_length,
<span class="p_del">-			conn-&gt;param_list);</span>
<span class="p_add">+			conn-&gt;param_list,</span>
<span class="p_add">+			conn-&gt;tpg-&gt;tpg_attrib.login_keys_workaround);</span>
 	if (ret &lt; 0) {
 		iscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,
 				ISCSI_LOGIN_STATUS_INIT_ERR);
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_parameters.c b/drivers/target/iscsi/iscsi_target_parameters.c</span>
<span class="p_header">index 578f5d03d84e..070dc042d250 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_parameters.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_parameters.c</span>
<span class="p_chunk">@@ -787,7 +787,8 @@</span> <span class="p_context"> static int iscsi_check_for_auth_key(char *key)</span>
 	return 0;
 }
 
<span class="p_del">-static void iscsi_check_proposer_for_optional_reply(struct iscsi_param *param)</span>
<span class="p_add">+static void iscsi_check_proposer_for_optional_reply(struct iscsi_param *param,</span>
<span class="p_add">+						    bool keys_workaround)</span>
 {
 	if (IS_TYPE_BOOL_AND(param)) {
 		if (!strcmp(param-&gt;value, NO))
<span class="p_chunk">@@ -795,19 +796,31 @@</span> <span class="p_context"> static void iscsi_check_proposer_for_optional_reply(struct iscsi_param *param)</span>
 	} else if (IS_TYPE_BOOL_OR(param)) {
 		if (!strcmp(param-&gt;value, YES))
 			SET_PSTATE_REPLY_OPTIONAL(param);
<span class="p_del">-		 /*</span>
<span class="p_del">-		  * Required for gPXE iSCSI boot client</span>
<span class="p_del">-		  */</span>
<span class="p_del">-		if (!strcmp(param-&gt;name, IMMEDIATEDATA))</span>
<span class="p_del">-			SET_PSTATE_REPLY_OPTIONAL(param);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (keys_workaround) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Required for gPXE iSCSI boot client</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (!strcmp(param-&gt;name, IMMEDIATEDATA))</span>
<span class="p_add">+				SET_PSTATE_REPLY_OPTIONAL(param);</span>
<span class="p_add">+		}</span>
 	} else if (IS_TYPE_NUMBER(param)) {
 		if (!strcmp(param-&gt;name, MAXRECVDATASEGMENTLENGTH))
 			SET_PSTATE_REPLY_OPTIONAL(param);
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Required for gPXE iSCSI boot client</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (!strcmp(param-&gt;name, MAXCONNECTIONS))</span>
<span class="p_del">-			SET_PSTATE_REPLY_OPTIONAL(param);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (keys_workaround) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Required for Mellanox Flexboot PXE boot ROM</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (!strcmp(param-&gt;name, FIRSTBURSTLENGTH))</span>
<span class="p_add">+				SET_PSTATE_REPLY_OPTIONAL(param);</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Required for gPXE iSCSI boot client</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (!strcmp(param-&gt;name, MAXCONNECTIONS))</span>
<span class="p_add">+				SET_PSTATE_REPLY_OPTIONAL(param);</span>
<span class="p_add">+		}</span>
 	} else if (IS_PHASE_DECLARATIVE(param))
 		SET_PSTATE_REPLY_OPTIONAL(param);
 }
<span class="p_chunk">@@ -1657,7 +1670,8 @@</span> <span class="p_context"> int iscsi_encode_text_output(</span>
 	u8 sender,
 	char *textbuf,
 	u32 *length,
<span class="p_del">-	struct iscsi_param_list *param_list)</span>
<span class="p_add">+	struct iscsi_param_list *param_list,</span>
<span class="p_add">+	bool keys_workaround)</span>
 {
 	char *output_buf = NULL;
 	struct iscsi_extra_response *er;
<span class="p_chunk">@@ -1693,7 +1707,8 @@</span> <span class="p_context"> int iscsi_encode_text_output(</span>
 			*length += 1;
 			output_buf = textbuf + *length;
 			SET_PSTATE_PROPOSER(param);
<span class="p_del">-			iscsi_check_proposer_for_optional_reply(param);</span>
<span class="p_add">+			iscsi_check_proposer_for_optional_reply(param,</span>
<span class="p_add">+							        keys_workaround);</span>
 			pr_debug(&quot;Sending key: %s=%s\n&quot;,
 				param-&gt;name, param-&gt;value);
 		}
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_parameters.h b/drivers/target/iscsi/iscsi_target_parameters.h</span>
<span class="p_header">index a47046a752aa..f430a0eba0f8 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_parameters.h</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_parameters.h</span>
<span class="p_chunk">@@ -40,7 +40,7 @@</span> <span class="p_context"> extern int iscsi_extract_key_value(char *, char **, char **);</span>
 extern int iscsi_update_param_value(struct iscsi_param *, char *);
 extern int iscsi_decode_text_input(u8, u8, char *, u32, struct iscsi_conn *);
 extern int iscsi_encode_text_output(u8, u8, char *, u32 *,
<span class="p_del">-			struct iscsi_param_list *);</span>
<span class="p_add">+			struct iscsi_param_list *, bool);</span>
 extern int iscsi_check_negotiated_keys(struct iscsi_param_list *);
 extern void iscsi_set_connection_parameters(struct iscsi_conn_ops *,
 			struct iscsi_param_list *);
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_tpg.c b/drivers/target/iscsi/iscsi_target_tpg.c</span>
<span class="p_header">index 48cd3cf741df..79ca361078b8 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_tpg.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_tpg.c</span>
<span class="p_chunk">@@ -228,6 +228,7 @@</span> <span class="p_context"> static void iscsit_set_default_tpg_attribs(struct iscsi_portal_group *tpg)</span>
 	a-&gt;demo_mode_discovery = TA_DEMO_MODE_DISCOVERY;
 	a-&gt;default_erl = TA_DEFAULT_ERL;
 	a-&gt;t10_pi = TA_DEFAULT_T10_PI;
<span class="p_add">+	a-&gt;login_keys_workaround = TA_DEFAULT_LOGIN_KEYS_WORKAROUND;</span>
 }
 
 int iscsit_tpg_add_portal_group(struct iscsi_tiqn *tiqn, struct iscsi_portal_group *tpg)
<span class="p_chunk">@@ -878,3 +879,21 @@</span> <span class="p_context"> int iscsit_ta_t10_pi(</span>
 
 	return 0;
 }
<span class="p_add">+</span>
<span class="p_add">+int iscsit_ta_login_keys_workaround(</span>
<span class="p_add">+	struct iscsi_portal_group *tpg,</span>
<span class="p_add">+	u32 flag)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct iscsi_tpg_attrib *a = &amp;tpg-&gt;tpg_attrib;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((flag != 0) &amp;&amp; (flag != 1)) {</span>
<span class="p_add">+		pr_err(&quot;Illegal value %d\n&quot;, flag);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	a-&gt;login_keys_workaround = flag;</span>
<span class="p_add">+	pr_debug(&quot;iSCSI_TPG[%hu] - TPG enabled bit for login keys workaround: %s &quot;,</span>
<span class="p_add">+		tpg-&gt;tpgt, (a-&gt;login_keys_workaround) ? &quot;ON&quot; : &quot;OFF&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_tpg.h b/drivers/target/iscsi/iscsi_target_tpg.h</span>
<span class="p_header">index e7265337bc43..49b869fab102 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_tpg.h</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_tpg.h</span>
<span class="p_chunk">@@ -39,5 +39,6 @@</span> <span class="p_context"> extern int iscsit_ta_prod_mode_write_protect(struct iscsi_portal_group *, u32);</span>
 extern int iscsit_ta_demo_mode_discovery(struct iscsi_portal_group *, u32);
 extern int iscsit_ta_default_erl(struct iscsi_portal_group *, u32);
 extern int iscsit_ta_t10_pi(struct iscsi_portal_group *, u32);
<span class="p_add">+extern int iscsit_ta_login_keys_workaround(struct iscsi_portal_group *, u32);</span>
 
 #endif /* ISCSI_TARGET_TPG_H */
<span class="p_header">diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c</span>
<span class="p_header">index 6c3b00ca4d20..da00938c6dfa 100644</span>
<span class="p_header">--- a/drivers/target/target_core_transport.c</span>
<span class="p_header">+++ b/drivers/target/target_core_transport.c</span>
<span class="p_chunk">@@ -689,6 +689,15 @@</span> <span class="p_context"> void target_complete_cmd(struct se_cmd *cmd, u8 scsi_status)</span>
 	if (cmd-&gt;transport_state &amp; CMD_T_ABORTED ||
 	    cmd-&gt;transport_state &amp; CMD_T_STOP) {
 		spin_unlock_irqrestore(&amp;cmd-&gt;t_state_lock, flags);
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If COMPARE_AND_WRITE was stopped by __transport_wait_for_tasks(),</span>
<span class="p_add">+		 * release se_device-&gt;caw_sem obtained by sbc_compare_and_write()</span>
<span class="p_add">+		 * since target_complete_ok_work() or target_complete_failure_work()</span>
<span class="p_add">+		 * won&#39;t be called to invoke the normal CAW completion callbacks.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) {</span>
<span class="p_add">+			up(&amp;dev-&gt;caw_sem);</span>
<span class="p_add">+		}</span>
 		complete_all(&amp;cmd-&gt;t_transport_stop_comp);
 		return;
 	} else if (!success) {
<span class="p_header">diff --git a/drivers/tty/serial/samsung.c b/drivers/tty/serial/samsung.c</span>
<span class="p_header">index 91f29f2975c1..5d1bfbe14f27 100644</span>
<span class="p_header">--- a/drivers/tty/serial/samsung.c</span>
<span class="p_header">+++ b/drivers/tty/serial/samsung.c</span>
<span class="p_chunk">@@ -757,6 +757,8 @@</span> <span class="p_context"> static void s3c24xx_serial_set_termios(struct uart_port *port,</span>
 	/* check to see if we need  to change clock source */
 
 	if (ourport-&gt;baudclk != clk) {
<span class="p_add">+		clk_prepare_enable(clk);</span>
<span class="p_add">+</span>
 		s3c24xx_serial_setsource(port, clk_sel);
 
 		if (!IS_ERR(ourport-&gt;baudclk)) {
<span class="p_chunk">@@ -764,8 +766,6 @@</span> <span class="p_context"> static void s3c24xx_serial_set_termios(struct uart_port *port,</span>
 			ourport-&gt;baudclk = ERR_PTR(-EINVAL);
 		}
 
<span class="p_del">-		clk_prepare_enable(clk);</span>
<span class="p_del">-</span>
 		ourport-&gt;baudclk = clk;
 		ourport-&gt;baudclk_rate = clk ? clk_get_rate(clk) : 0;
 	}
<span class="p_header">diff --git a/drivers/tty/serial/sccnxp.c b/drivers/tty/serial/sccnxp.c</span>
<span class="p_header">index e84b6a3bdd18..89677b9f82b9 100644</span>
<span class="p_header">--- a/drivers/tty/serial/sccnxp.c</span>
<span class="p_header">+++ b/drivers/tty/serial/sccnxp.c</span>
<span class="p_chunk">@@ -890,14 +890,19 @@</span> <span class="p_context"> static int sccnxp_probe(struct platform_device *pdev)</span>
 
 	clk = devm_clk_get(&amp;pdev-&gt;dev, NULL);
 	if (IS_ERR(clk)) {
<span class="p_del">-		if (PTR_ERR(clk) == -EPROBE_DEFER) {</span>
<span class="p_del">-			ret = -EPROBE_DEFER;</span>
<span class="p_add">+		ret = PTR_ERR(clk);</span>
<span class="p_add">+		if (ret == -EPROBE_DEFER)</span>
 			goto err_out;
<span class="p_del">-		}</span>
<span class="p_add">+		uartclk = 0;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		clk_prepare_enable(clk);</span>
<span class="p_add">+		uartclk = clk_get_rate(clk);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!uartclk) {</span>
 		dev_notice(&amp;pdev-&gt;dev, &quot;Using default clock frequency\n&quot;);
 		uartclk = s-&gt;chip-&gt;freq_std;
<span class="p_del">-	} else</span>
<span class="p_del">-		uartclk = clk_get_rate(clk);</span>
<span class="p_add">+	}</span>
 
 	/* Check input frequency */
 	if ((uartclk &lt; s-&gt;chip-&gt;freq_min) || (uartclk &gt; s-&gt;chip-&gt;freq_max)) {
<span class="p_header">diff --git a/drivers/tty/vt/vt.c b/drivers/tty/vt/vt.c</span>
<span class="p_header">index a57f3761ab47..322c4818dd0c 100644</span>
<span class="p_header">--- a/drivers/tty/vt/vt.c</span>
<span class="p_header">+++ b/drivers/tty/vt/vt.c</span>
<span class="p_chunk">@@ -2687,13 +2687,13 @@</span> <span class="p_context"> int tioclinux(struct tty_struct *tty, unsigned long arg)</span>
 	 * related to the kernel should not use this.
 	 */
 			data = vt_get_shift_state();
<span class="p_del">-			ret = __put_user(data, p);</span>
<span class="p_add">+			ret = put_user(data, p);</span>
 			break;
 		case TIOCL_GETMOUSEREPORTING:
 			console_lock();	/* May be overkill */
 			data = mouse_reporting();
 			console_unlock();
<span class="p_del">-			ret = __put_user(data, p);</span>
<span class="p_add">+			ret = put_user(data, p);</span>
 			break;
 		case TIOCL_SETVESABLANK:
 			console_lock();
<span class="p_chunk">@@ -2702,7 +2702,7 @@</span> <span class="p_context"> int tioclinux(struct tty_struct *tty, unsigned long arg)</span>
 			break;
 		case TIOCL_GETKMSGREDIRECT:
 			data = vt_get_kmsg_redirect();
<span class="p_del">-			ret = __put_user(data, p);</span>
<span class="p_add">+			ret = put_user(data, p);</span>
 			break;
 		case TIOCL_SETKMSGREDIRECT:
 			if (!capable(CAP_SYS_ADMIN)) {
<span class="p_header">diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c</span>
<span class="p_header">index 3a5a4f49e894..59106b01dc20 100644</span>
<span class="p_header">--- a/drivers/usb/core/quirks.c</span>
<span class="p_header">+++ b/drivers/usb/core/quirks.c</span>
<span class="p_chunk">@@ -220,6 +220,10 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	/* Blackmagic Design UltraStudio SDI */
 	{ USB_DEVICE(0x1edb, 0xbd4f), .driver_info = USB_QUIRK_NO_LPM },
 
<span class="p_add">+	/* Hauppauge HVR-950q */</span>
<span class="p_add">+	{ USB_DEVICE(0x2040, 0x7200), .driver_info =</span>
<span class="p_add">+			USB_QUIRK_CONFIG_INTF_STRINGS },</span>
<span class="p_add">+</span>
 	/* INTEL VALUE SSD */
 	{ USB_DEVICE(0x8086, 0xf1a5), .driver_info = USB_QUIRK_RESET_RESUME },
 
<span class="p_header">diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">index 56188f231de0..48562be0f07f 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-hub.c</span>
<span class="p_chunk">@@ -1209,6 +1209,9 @@</span> <span class="p_context"> int xhci_bus_suspend(struct usb_hcd *hcd)</span>
 				t2 |= PORT_WKOC_E | PORT_WKCONN_E;
 				t2 &amp;= ~PORT_WKDISC_E;
 			}
<span class="p_add">+			if ((xhci-&gt;quirks &amp; XHCI_U2_DISABLE_WAKE) &amp;&amp;</span>
<span class="p_add">+			    (hcd-&gt;speed &lt; HCD_USB3))</span>
<span class="p_add">+				t2 &amp;= ~PORT_WAKE_BITS;</span>
 		} else
 			t2 &amp;= ~PORT_WAKE_BITS;
 
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index 6e48fd8d673e..60edc9668935 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -47,6 +47,11 @@</span> <span class="p_context"></span>
 #define PCI_DEVICE_ID_INTEL_APL_XHCI			0x5aa8
 #define PCI_DEVICE_ID_INTEL_DNV_XHCI			0x19d0
 
<span class="p_add">+#define PCI_DEVICE_ID_AMD_PROMONTORYA_4			0x43b9</span>
<span class="p_add">+#define PCI_DEVICE_ID_AMD_PROMONTORYA_3			0x43ba</span>
<span class="p_add">+#define PCI_DEVICE_ID_AMD_PROMONTORYA_2			0x43bb</span>
<span class="p_add">+#define PCI_DEVICE_ID_AMD_PROMONTORYA_1			0x43bc</span>
<span class="p_add">+</span>
 static const char hcd_name[] = &quot;xhci_hcd&quot;;
 
 /* called after powerup, by probe or system-pm &quot;wakeup&quot; */
<span class="p_chunk">@@ -120,6 +125,13 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_AMD)
 		xhci-&gt;quirks |= XHCI_TRUST_TX_LENGTH;
 
<span class="p_add">+	if ((pdev-&gt;vendor == PCI_VENDOR_ID_AMD) &amp;&amp;</span>
<span class="p_add">+		((pdev-&gt;device == PCI_DEVICE_ID_AMD_PROMONTORYA_4) ||</span>
<span class="p_add">+		(pdev-&gt;device == PCI_DEVICE_ID_AMD_PROMONTORYA_3) ||</span>
<span class="p_add">+		(pdev-&gt;device == PCI_DEVICE_ID_AMD_PROMONTORYA_2) ||</span>
<span class="p_add">+		(pdev-&gt;device == PCI_DEVICE_ID_AMD_PROMONTORYA_1)))</span>
<span class="p_add">+		xhci-&gt;quirks |= XHCI_U2_DISABLE_WAKE;</span>
<span class="p_add">+</span>
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL) {
 		xhci-&gt;quirks |= XHCI_LPM_SUPPORT;
 		xhci-&gt;quirks |= XHCI_INTEL_HOST;
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index f117bacec41c..92e852cc3944 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -1569,6 +1569,7 @@</span> <span class="p_context"> struct xhci_hcd {</span>
 #define XHCI_BROKEN_STREAMS	(1 &lt;&lt; 19)
 #define XHCI_PME_STUCK_QUIRK	(1 &lt;&lt; 20)
 #define XHCI_MISSING_CAS	(1 &lt;&lt; 24)
<span class="p_add">+#define XHCI_U2_DISABLE_WAKE	(1 &lt;&lt; 27)</span>
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */
<span class="p_header">diff --git a/drivers/usb/musb/musb_cppi41.c b/drivers/usb/musb/musb_cppi41.c</span>
<span class="p_header">index 36f029b0d357..d8315638e825 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musb_cppi41.c</span>
<span class="p_header">+++ b/drivers/usb/musb/musb_cppi41.c</span>
<span class="p_chunk">@@ -9,9 +9,9 @@</span> <span class="p_context"></span>
 
 #define RNDIS_REG(x) (0x80 + ((x - 1) * 4))
 
<span class="p_del">-#define EP_MODE_AUTOREG_NONE		0</span>
<span class="p_del">-#define EP_MODE_AUTOREG_ALL_NEOP	1</span>
<span class="p_del">-#define EP_MODE_AUTOREG_ALWAYS		3</span>
<span class="p_add">+#define EP_MODE_AUTOREQ_NONE		0</span>
<span class="p_add">+#define EP_MODE_AUTOREQ_ALL_NEOP	1</span>
<span class="p_add">+#define EP_MODE_AUTOREQ_ALWAYS		3</span>
 
 #define EP_MODE_DMA_TRANSPARENT		0
 #define EP_MODE_DMA_RNDIS		1
<span class="p_chunk">@@ -426,19 +426,19 @@</span> <span class="p_context"> static bool cppi41_configure_channel(struct dma_channel *channel,</span>
 
 			/* auto req */
 			cppi41_set_autoreq_mode(cppi41_channel,
<span class="p_del">-					EP_MODE_AUTOREG_ALL_NEOP);</span>
<span class="p_add">+					EP_MODE_AUTOREQ_ALL_NEOP);</span>
 		} else {
 			musb_writel(musb-&gt;ctrl_base,
 					RNDIS_REG(cppi41_channel-&gt;port_num), 0);
 			cppi41_set_dma_mode(cppi41_channel,
 					EP_MODE_DMA_TRANSPARENT);
 			cppi41_set_autoreq_mode(cppi41_channel,
<span class="p_del">-					EP_MODE_AUTOREG_NONE);</span>
<span class="p_add">+					EP_MODE_AUTOREQ_NONE);</span>
 		}
 	} else {
 		/* fallback mode */
 		cppi41_set_dma_mode(cppi41_channel, EP_MODE_DMA_TRANSPARENT);
<span class="p_del">-		cppi41_set_autoreq_mode(cppi41_channel, EP_MODE_AUTOREG_NONE);</span>
<span class="p_add">+		cppi41_set_autoreq_mode(cppi41_channel, EP_MODE_AUTOREQ_NONE);</span>
 		len = min_t(u32, packet_sz, len);
 	}
 	cppi41_channel-&gt;prog_len = len;
<span class="p_chunk">@@ -570,10 +570,15 @@</span> <span class="p_context"> static int cppi41_dma_channel_abort(struct dma_channel *channel)</span>
 		csr &amp;= ~MUSB_TXCSR_DMAENAB;
 		musb_writew(epio, MUSB_TXCSR, csr);
 	} else {
<span class="p_add">+		cppi41_set_autoreq_mode(cppi41_channel, EP_MODE_AUTOREQ_NONE);</span>
<span class="p_add">+</span>
 		csr = musb_readw(epio, MUSB_RXCSR);
 		csr &amp;= ~(MUSB_RXCSR_H_REQPKT | MUSB_RXCSR_DMAENAB);
 		musb_writew(epio, MUSB_RXCSR, csr);
 
<span class="p_add">+		/* wait to drain cppi dma pipe line */</span>
<span class="p_add">+		udelay(50);</span>
<span class="p_add">+</span>
 		csr = musb_readw(epio, MUSB_RXCSR);
 		if (csr &amp; MUSB_RXCSR_RXPKTRDY) {
 			csr |= MUSB_RXCSR_FLUSHFIFO;
<span class="p_chunk">@@ -587,13 +592,14 @@</span> <span class="p_context"> static int cppi41_dma_channel_abort(struct dma_channel *channel)</span>
 		tdbit &lt;&lt;= 16;
 
 	do {
<span class="p_del">-		musb_writel(musb-&gt;ctrl_base, USB_TDOWN, tdbit);</span>
<span class="p_add">+		if (is_tx)</span>
<span class="p_add">+			musb_writel(musb-&gt;ctrl_base, USB_TDOWN, tdbit);</span>
 		ret = dmaengine_terminate_all(cppi41_channel-&gt;dc);
 	} while (ret == -EAGAIN);
 
<span class="p_del">-	musb_writel(musb-&gt;ctrl_base, USB_TDOWN, tdbit);</span>
<span class="p_del">-</span>
 	if (is_tx) {
<span class="p_add">+		musb_writel(musb-&gt;ctrl_base, USB_TDOWN, tdbit);</span>
<span class="p_add">+</span>
 		csr = musb_readw(epio, MUSB_TXCSR);
 		if (csr &amp; MUSB_TXCSR_TXPKTRDY) {
 			csr |= MUSB_TXCSR_FLUSHFIFO;
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 6b72aacdd779..0786281108f6 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -134,6 +134,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x10C4, 0x8977) },	/* CEL MeshWorks DevKit Device */
 	{ USB_DEVICE(0x10C4, 0x8998) }, /* KCF Technologies PRN */
 	{ USB_DEVICE(0x10C4, 0x8A2A) }, /* HubZ dual ZigBee and Z-Wave dongle */
<span class="p_add">+	{ USB_DEVICE(0x10C4, 0x8A5E) }, /* CEL EM3588 ZigBee USB Stick Long Range */</span>
 	{ USB_DEVICE(0x10C4, 0xEA60) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA61) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA70) }, /* Silicon Labs factory default */
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 58b13a537a7d..475104bb3395 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -1888,6 +1888,10 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	  .driver_info = (kernel_ulong_t)&amp;four_g_w100_blacklist
 	},
 	{ USB_DEVICE_INTERFACE_CLASS(LONGCHEER_VENDOR_ID, SPEEDUP_PRODUCT_SU9800, 0xff) },
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(LONGCHEER_VENDOR_ID, 0x9801, 0xff),</span>
<span class="p_add">+	  .driver_info = (kernel_ulong_t)&amp;net_intf3_blacklist },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(LONGCHEER_VENDOR_ID, 0x9803, 0xff),</span>
<span class="p_add">+	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },</span>
 	{ USB_DEVICE(LONGCHEER_VENDOR_ID, ZOOM_PRODUCT_4597) },
 	{ USB_DEVICE(LONGCHEER_VENDOR_ID, IBALL_3_5G_CONNECT) },
 	{ USB_DEVICE(HAIER_VENDOR_ID, HAIER_PRODUCT_CE100) },
<span class="p_header">diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c</span>
<span class="p_header">index 4f91868736a5..23c303b2a3a2 100644</span>
<span class="p_header">--- a/drivers/usb/serial/qcserial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/qcserial.c</span>
<span class="p_chunk">@@ -156,6 +156,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{DEVICE_SWI(0x1199, 0x9056)},	/* Sierra Wireless Modem */
 	{DEVICE_SWI(0x1199, 0x9060)},	/* Sierra Wireless Modem */
 	{DEVICE_SWI(0x1199, 0x9061)},	/* Sierra Wireless Modem */
<span class="p_add">+	{DEVICE_SWI(0x1199, 0x9063)},	/* Sierra Wireless EM7305 */</span>
 	{DEVICE_SWI(0x1199, 0x9070)},	/* Sierra Wireless MC74xx */
 	{DEVICE_SWI(0x1199, 0x9071)},	/* Sierra Wireless MC74xx */
 	{DEVICE_SWI(0x1199, 0x9078)},	/* Sierra Wireless EM74xx */
<span class="p_header">diff --git a/drivers/vfio/vfio.c b/drivers/vfio/vfio.c</span>
<span class="p_header">index f018d8d0f975..7b2f32726c1a 100644</span>
<span class="p_header">--- a/drivers/vfio/vfio.c</span>
<span class="p_header">+++ b/drivers/vfio/vfio.c</span>
<span class="p_chunk">@@ -278,6 +278,34 @@</span> <span class="p_context"> static void vfio_group_put(struct vfio_group *group)</span>
 	kref_put_mutex(&amp;group-&gt;kref, vfio_group_release, &amp;vfio.group_lock);
 }
 
<span class="p_add">+struct vfio_group_put_work {</span>
<span class="p_add">+	struct work_struct work;</span>
<span class="p_add">+	struct vfio_group *group;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static void vfio_group_put_bg(struct work_struct *work)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct vfio_group_put_work *do_work;</span>
<span class="p_add">+</span>
<span class="p_add">+	do_work = container_of(work, struct vfio_group_put_work, work);</span>
<span class="p_add">+</span>
<span class="p_add">+	vfio_group_put(do_work-&gt;group);</span>
<span class="p_add">+	kfree(do_work);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void vfio_group_schedule_put(struct vfio_group *group)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct vfio_group_put_work *do_work;</span>
<span class="p_add">+</span>
<span class="p_add">+	do_work = kmalloc(sizeof(*do_work), GFP_KERNEL);</span>
<span class="p_add">+	if (WARN_ON(!do_work))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	INIT_WORK(&amp;do_work-&gt;work, vfio_group_put_bg);</span>
<span class="p_add">+	do_work-&gt;group = group;</span>
<span class="p_add">+	schedule_work(&amp;do_work-&gt;work);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Assume group_lock or group reference is held */
 static void vfio_group_get(struct vfio_group *group)
 {
<span class="p_chunk">@@ -553,7 +581,14 @@</span> <span class="p_context"> static int vfio_iommu_group_notifier(struct notifier_block *nb,</span>
 		break;
 	}
 
<span class="p_del">-	vfio_group_put(group);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we&#39;re the last reference to the group, the group will be</span>
<span class="p_add">+	 * released, which includes unregistering the iommu group notifier.</span>
<span class="p_add">+	 * We hold a read-lock on that notifier list, unregistering needs</span>
<span class="p_add">+	 * a write-lock... deadlock.  Release our reference asynchronously</span>
<span class="p_add">+	 * to avoid that situation.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	vfio_group_schedule_put(group);</span>
 	return NOTIFY_OK;
 }
 
<span class="p_chunk">@@ -1401,6 +1436,15 @@</span> <span class="p_context"> void vfio_group_put_external_user(struct vfio_group *group)</span>
 }
 EXPORT_SYMBOL_GPL(vfio_group_put_external_user);
 
<span class="p_add">+bool vfio_external_group_match_file(struct vfio_group *test_group,</span>
<span class="p_add">+				    struct file *filep)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct vfio_group *group = filep-&gt;private_data;</span>
<span class="p_add">+</span>
<span class="p_add">+	return (filep-&gt;f_op == &amp;vfio_group_fops) &amp;&amp; (group == test_group);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(vfio_external_group_match_file);</span>
<span class="p_add">+</span>
 int vfio_external_user_iommu_id(struct vfio_group *group)
 {
 	return iommu_group_id(group-&gt;iommu_group);
<span class="p_header">diff --git a/drivers/video/fbdev/aty/atyfb_base.c b/drivers/video/fbdev/aty/atyfb_base.c</span>
<span class="p_header">index c3d0074a32db..fba5736acfd6 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/aty/atyfb_base.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/aty/atyfb_base.c</span>
<span class="p_chunk">@@ -1852,7 +1852,7 @@</span> <span class="p_context"> static int atyfb_ioctl(struct fb_info *info, u_int cmd, u_long arg)</span>
 #if defined(DEBUG) &amp;&amp; defined(CONFIG_FB_ATY_CT)
 	case ATYIO_CLKR:
 		if (M64_HAS(INTEGRATED)) {
<span class="p_del">-			struct atyclk clk;</span>
<span class="p_add">+			struct atyclk clk = { 0 };</span>
 			union aty_pll *pll = &amp;par-&gt;pll;
 			u32 dsp_config = pll-&gt;ct.dsp_config;
 			u32 dsp_on_off = pll-&gt;ct.dsp_on_off;
<span class="p_header">diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c</span>
<span class="p_header">index fb3e64d37cb4..6b16b8653d98 100644</span>
<span class="p_header">--- a/fs/btrfs/acl.c</span>
<span class="p_header">+++ b/fs/btrfs/acl.c</span>
<span class="p_chunk">@@ -82,12 +82,6 @@</span> <span class="p_context"> static int __btrfs_set_acl(struct btrfs_trans_handle *trans,</span>
 	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name = POSIX_ACL_XATTR_ACCESS;
<span class="p_del">-		if (acl) {</span>
<span class="p_del">-			ret = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_del">-			if (ret)</span>
<span class="p_del">-				return ret;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		ret = 0;</span>
 		break;
 	case ACL_TYPE_DEFAULT:
 		if (!S_ISDIR(inode-&gt;i_mode))
<span class="p_chunk">@@ -123,7 +117,18 @@</span> <span class="p_context"> static int __btrfs_set_acl(struct btrfs_trans_handle *trans,</span>
 
 int btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 {
<span class="p_del">-	return __btrfs_set_acl(NULL, inode, acl, type);</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	umode_t old_mode = inode-&gt;i_mode;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (type == ACL_TYPE_ACCESS &amp;&amp; acl) {</span>
<span class="p_add">+		ret = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	ret = __btrfs_set_acl(NULL, inode, acl, type);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		inode-&gt;i_mode = old_mode;</span>
<span class="p_add">+	return ret;</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c</span>
<span class="p_header">index 1f20c8e75e19..f55eee900557 100644</span>
<span class="p_header">--- a/fs/btrfs/extent-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/extent-tree.c</span>
<span class="p_chunk">@@ -4230,7 +4230,7 @@</span> <span class="p_context"> static int may_commit_transaction(struct btrfs_root *root,</span>
 
 	spin_lock(&amp;delayed_rsv-&gt;lock);
 	if (percpu_counter_compare(&amp;space_info-&gt;total_bytes_pinned,
<span class="p_del">-				   bytes - delayed_rsv-&gt;size) &gt;= 0) {</span>
<span class="p_add">+				   bytes - delayed_rsv-&gt;size) &lt; 0) {</span>
 		spin_unlock(&amp;delayed_rsv-&gt;lock);
 		return -ENOSPC;
 	}
<span class="p_header">diff --git a/fs/btrfs/file.c b/fs/btrfs/file.c</span>
<span class="p_header">index 085a90d0d2e4..e1553eb5ef61 100644</span>
<span class="p_header">--- a/fs/btrfs/file.c</span>
<span class="p_header">+++ b/fs/btrfs/file.c</span>
<span class="p_chunk">@@ -2177,10 +2177,13 @@</span> <span class="p_context"> static int fill_holes(struct btrfs_trans_handle *trans, struct inode *inode,</span>
  */
 static int find_first_non_hole(struct inode *inode, u64 *start, u64 *len)
 {
<span class="p_add">+	struct btrfs_root *root = BTRFS_I(inode)-&gt;root;</span>
 	struct extent_map *em;
 	int ret = 0;
 
<span class="p_del">-	em = btrfs_get_extent(inode, NULL, 0, *start, *len, 0);</span>
<span class="p_add">+	em = btrfs_get_extent(inode, NULL, 0,</span>
<span class="p_add">+			      round_down(*start, root-&gt;sectorsize),</span>
<span class="p_add">+			      round_up(*len, root-&gt;sectorsize), 0);</span>
 	if (IS_ERR_OR_NULL(em)) {
 		if (!em)
 			ret = -ENOMEM;
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index cde876a98fb8..04972508c98b 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -1681,7 +1681,7 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_create_transid(struct file *file,</span>
 
 		src_inode = file_inode(src.file);
 		if (src_inode-&gt;i_sb != file_inode(file)-&gt;i_sb) {
<span class="p_del">-			btrfs_info(BTRFS_I(src_inode)-&gt;root-&gt;fs_info,</span>
<span class="p_add">+			btrfs_info(BTRFS_I(file_inode(file))-&gt;root-&gt;fs_info,</span>
 				   &quot;Snapshot src from another FS&quot;);
 			ret = -EXDEV;
 		} else if (!inode_owner_or_capable(src_inode)) {
<span class="p_header">diff --git a/fs/cifs/cifs_fs_sb.h b/fs/cifs/cifs_fs_sb.h</span>
<span class="p_header">index 9409fa10bd5c..4893d86047a6 100644</span>
<span class="p_header">--- a/fs/cifs/cifs_fs_sb.h</span>
<span class="p_header">+++ b/fs/cifs/cifs_fs_sb.h</span>
<span class="p_chunk">@@ -45,6 +45,9 @@</span> <span class="p_context"></span>
 #define CIFS_MOUNT_POSIXACL	0x100000 /* mirror of MS_POSIXACL in mnt_cifs_flags */
 #define CIFS_MOUNT_CIFS_BACKUPUID 0x200000 /* backup intent bit for a user */
 #define CIFS_MOUNT_CIFS_BACKUPGID 0x400000 /* backup intent bit for a group */
<span class="p_add">+#define CIFS_MOUNT_USE_PREFIX_PATH 0x1000000 /* make subpath with unaccessible</span>
<span class="p_add">+					      * root mountable</span>
<span class="p_add">+					      */</span>
 
 struct cifs_sb_info {
 	struct rb_root tlink_tree;
<span class="p_chunk">@@ -66,5 +69,6 @@</span> <span class="p_context"> struct cifs_sb_info {</span>
 	struct backing_dev_info bdi;
 	struct delayed_work prune_tlinks;
 	struct rcu_head rcu;
<span class="p_add">+	char *prepath;</span>
 };
 #endif				/* _CIFS_FS_SB_H */
<span class="p_header">diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c</span>
<span class="p_header">index f16839ccf1eb..281358942b64 100644</span>
<span class="p_header">--- a/fs/cifs/cifsfs.c</span>
<span class="p_header">+++ b/fs/cifs/cifsfs.c</span>
<span class="p_chunk">@@ -584,6 +584,9 @@</span> <span class="p_context"> cifs_get_root(struct smb_vol *vol, struct super_block *sb)</span>
 	char *s, *p;
 	char sep;
 
<span class="p_add">+	if (cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_USE_PREFIX_PATH)</span>
<span class="p_add">+		return dget(sb-&gt;s_root);</span>
<span class="p_add">+</span>
 	full_path = cifs_build_path_to_root(vol, cifs_sb,
 					    cifs_sb_master_tcon(cifs_sb));
 	if (full_path == NULL)
<span class="p_chunk">@@ -663,10 +666,14 @@</span> <span class="p_context"> cifs_do_mount(struct file_system_type *fs_type,</span>
 	cifs_sb-&gt;mountdata = kstrndup(data, PAGE_SIZE, GFP_KERNEL);
 	if (cifs_sb-&gt;mountdata == NULL) {
 		root = ERR_PTR(-ENOMEM);
<span class="p_del">-		goto out_cifs_sb;</span>
<span class="p_add">+		goto out_free;</span>
 	}
 
<span class="p_del">-	cifs_setup_cifs_sb(volume_info, cifs_sb);</span>
<span class="p_add">+	rc = cifs_setup_cifs_sb(volume_info, cifs_sb);</span>
<span class="p_add">+	if (rc) {</span>
<span class="p_add">+		root = ERR_PTR(rc);</span>
<span class="p_add">+		goto out_free;</span>
<span class="p_add">+	}</span>
 
 	rc = cifs_mount(cifs_sb, volume_info);
 	if (rc) {
<span class="p_chunk">@@ -674,7 +681,7 @@</span> <span class="p_context"> cifs_do_mount(struct file_system_type *fs_type,</span>
 			cifs_dbg(VFS, &quot;cifs_mount failed w/return code = %d\n&quot;,
 				 rc);
 		root = ERR_PTR(rc);
<span class="p_del">-		goto out_mountdata;</span>
<span class="p_add">+		goto out_free;</span>
 	}
 
 	mnt_data.vol = volume_info;
<span class="p_chunk">@@ -717,9 +724,9 @@</span> <span class="p_context"> cifs_do_mount(struct file_system_type *fs_type,</span>
 	cifs_cleanup_volume_info(volume_info);
 	return root;
 
<span class="p_del">-out_mountdata:</span>
<span class="p_add">+out_free:</span>
<span class="p_add">+	kfree(cifs_sb-&gt;prepath);</span>
 	kfree(cifs_sb-&gt;mountdata);
<span class="p_del">-out_cifs_sb:</span>
 	kfree(cifs_sb);
 out_nls:
 	unload_nls(volume_info-&gt;local_nls);
<span class="p_header">diff --git a/fs/cifs/cifsproto.h b/fs/cifs/cifsproto.h</span>
<span class="p_header">index ea1cbff2932f..6e2d4581ceb2 100644</span>
<span class="p_header">--- a/fs/cifs/cifsproto.h</span>
<span class="p_header">+++ b/fs/cifs/cifsproto.h</span>
<span class="p_chunk">@@ -183,7 +183,7 @@</span> <span class="p_context"> extern int cifs_read_from_socket(struct TCP_Server_Info *server, char *buf,</span>
 extern int cifs_readv_from_socket(struct TCP_Server_Info *server,
 		struct kvec *iov_orig, unsigned int nr_segs,
 		unsigned int to_read);
<span class="p_del">-extern void cifs_setup_cifs_sb(struct smb_vol *pvolume_info,</span>
<span class="p_add">+extern int cifs_setup_cifs_sb(struct smb_vol *pvolume_info,</span>
 			       struct cifs_sb_info *cifs_sb);
 extern int cifs_match_super(struct super_block *, void *);
 extern void cifs_cleanup_volume_info(struct smb_vol *pvolume_info);
<span class="p_header">diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c</span>
<span class="p_header">index 95a9573f49e9..2959522238c5 100644</span>
<span class="p_header">--- a/fs/cifs/connect.c</span>
<span class="p_header">+++ b/fs/cifs/connect.c</span>
<span class="p_chunk">@@ -2751,6 +2751,22 @@</span> <span class="p_context"> compare_mount_options(struct super_block *sb, struct cifs_mnt_data *mnt_data)</span>
 	return 1;
 }
 
<span class="p_add">+static int</span>
<span class="p_add">+match_prepath(struct super_block *sb, struct cifs_mnt_data *mnt_data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cifs_sb_info *old = CIFS_SB(sb);</span>
<span class="p_add">+	struct cifs_sb_info *new = mnt_data-&gt;cifs_sb;</span>
<span class="p_add">+	bool old_set = old-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_USE_PREFIX_PATH;</span>
<span class="p_add">+	bool new_set = new-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_USE_PREFIX_PATH;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (old_set &amp;&amp; new_set &amp;&amp; !strcmp(new-&gt;prepath, old-&gt;prepath))</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	else if (!old_set &amp;&amp; !new_set)</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int
 cifs_match_super(struct super_block *sb, void *data)
 {
<span class="p_chunk">@@ -2778,7 +2794,8 @@</span> <span class="p_context"> cifs_match_super(struct super_block *sb, void *data)</span>
 
 	if (!match_server(tcp_srv, volume_info) ||
 	    !match_session(ses, volume_info) ||
<span class="p_del">-	    !match_tcon(tcon, volume_info-&gt;UNC)) {</span>
<span class="p_add">+	    !match_tcon(tcon, volume_info-&gt;UNC) ||</span>
<span class="p_add">+	    !match_prepath(sb, mnt_data)) {</span>
 		rc = 0;
 		goto out;
 	}
<span class="p_chunk">@@ -3194,7 +3211,7 @@</span> <span class="p_context"> void reset_cifs_unix_caps(unsigned int xid, struct cifs_tcon *tcon,</span>
 	}
 }
 
<span class="p_del">-void cifs_setup_cifs_sb(struct smb_vol *pvolume_info,</span>
<span class="p_add">+int cifs_setup_cifs_sb(struct smb_vol *pvolume_info,</span>
 			struct cifs_sb_info *cifs_sb)
 {
 	INIT_DELAYED_WORK(&amp;cifs_sb-&gt;prune_tlinks, cifs_prune_tlinks);
<span class="p_chunk">@@ -3276,6 +3293,14 @@</span> <span class="p_context"> void cifs_setup_cifs_sb(struct smb_vol *pvolume_info,</span>
 
 	if ((pvolume_info-&gt;cifs_acl) &amp;&amp; (pvolume_info-&gt;dynperm))
 		cifs_dbg(VFS, &quot;mount option dynperm ignored if cifsacl mount option supported\n&quot;);
<span class="p_add">+</span>
<span class="p_add">+	if (pvolume_info-&gt;prepath) {</span>
<span class="p_add">+		cifs_sb-&gt;prepath = kstrdup(pvolume_info-&gt;prepath, GFP_KERNEL);</span>
<span class="p_add">+		if (cifs_sb-&gt;prepath == NULL)</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 static void
<span class="p_chunk">@@ -3446,6 +3471,44 @@</span> <span class="p_context"> cifs_get_volume_info(char *mount_data, const char *devname)</span>
 	return volume_info;
 }
 
<span class="p_add">+static int</span>
<span class="p_add">+cifs_are_all_path_components_accessible(struct TCP_Server_Info *server,</span>
<span class="p_add">+					unsigned int xid,</span>
<span class="p_add">+					struct cifs_tcon *tcon,</span>
<span class="p_add">+					struct cifs_sb_info *cifs_sb,</span>
<span class="p_add">+					char *full_path)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+	char *s;</span>
<span class="p_add">+	char sep, tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	sep = CIFS_DIR_SEP(cifs_sb);</span>
<span class="p_add">+	s = full_path;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = server-&gt;ops-&gt;is_path_accessible(xid, tcon, cifs_sb, &quot;&quot;);</span>
<span class="p_add">+	while (rc == 0) {</span>
<span class="p_add">+		/* skip separators */</span>
<span class="p_add">+		while (*s == sep)</span>
<span class="p_add">+			s++;</span>
<span class="p_add">+		if (!*s)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		/* next separator */</span>
<span class="p_add">+		while (*s &amp;&amp; *s != sep)</span>
<span class="p_add">+			s++;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * temporarily null-terminate the path at the end of</span>
<span class="p_add">+		 * the current component</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		tmp = *s;</span>
<span class="p_add">+		*s = 0;</span>
<span class="p_add">+		rc = server-&gt;ops-&gt;is_path_accessible(xid, tcon, cifs_sb,</span>
<span class="p_add">+						     full_path);</span>
<span class="p_add">+		*s = tmp;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int
 cifs_mount(struct cifs_sb_info *cifs_sb, struct smb_vol *volume_info)
 {
<span class="p_chunk">@@ -3572,6 +3635,18 @@</span> <span class="p_context"> cifs_mount(struct cifs_sb_info *cifs_sb, struct smb_vol *volume_info)</span>
 			kfree(full_path);
 			goto mount_fail_check;
 		}
<span class="p_add">+</span>
<span class="p_add">+		if (rc != -EREMOTE) {</span>
<span class="p_add">+			rc = cifs_are_all_path_components_accessible(server,</span>
<span class="p_add">+							     xid, tcon, cifs_sb,</span>
<span class="p_add">+							     full_path);</span>
<span class="p_add">+			if (rc != 0) {</span>
<span class="p_add">+				cifs_dbg(VFS, &quot;cannot query dirs between root and final path, &quot;</span>
<span class="p_add">+					 &quot;enabling CIFS_MOUNT_USE_PREFIX_PATH\n&quot;);</span>
<span class="p_add">+				cifs_sb-&gt;mnt_cifs_flags |= CIFS_MOUNT_USE_PREFIX_PATH;</span>
<span class="p_add">+				rc = 0;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 		kfree(full_path);
 	}
 
<span class="p_chunk">@@ -3835,6 +3910,7 @@</span> <span class="p_context"> cifs_umount(struct cifs_sb_info *cifs_sb)</span>
 
 	bdi_destroy(&amp;cifs_sb-&gt;bdi);
 	kfree(cifs_sb-&gt;mountdata);
<span class="p_add">+	kfree(cifs_sb-&gt;prepath);</span>
 	call_rcu(&amp;cifs_sb-&gt;rcu, delayed_free);
 }
 
<span class="p_header">diff --git a/fs/cifs/dir.c b/fs/cifs/dir.c</span>
<span class="p_header">index 3f2dd87b899a..619e30f103d0 100644</span>
<span class="p_header">--- a/fs/cifs/dir.c</span>
<span class="p_header">+++ b/fs/cifs/dir.c</span>
<span class="p_chunk">@@ -84,6 +84,7 @@</span> <span class="p_context"> build_path_from_dentry(struct dentry *direntry)</span>
 	struct dentry *temp;
 	int namelen;
 	int dfsplen;
<span class="p_add">+	int pplen = 0;</span>
 	char *full_path;
 	char dirsep;
 	struct cifs_sb_info *cifs_sb = CIFS_SB(direntry-&gt;d_sb);
<span class="p_chunk">@@ -95,8 +96,12 @@</span> <span class="p_context"> build_path_from_dentry(struct dentry *direntry)</span>
 		dfsplen = strnlen(tcon-&gt;treeName, MAX_TREE_SIZE + 1);
 	else
 		dfsplen = 0;
<span class="p_add">+</span>
<span class="p_add">+	if (cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_USE_PREFIX_PATH)</span>
<span class="p_add">+		pplen = cifs_sb-&gt;prepath ? strlen(cifs_sb-&gt;prepath) + 1 : 0;</span>
<span class="p_add">+</span>
 cifs_bp_rename_retry:
<span class="p_del">-	namelen = dfsplen;</span>
<span class="p_add">+	namelen = dfsplen + pplen;</span>
 	seq = read_seqbegin(&amp;rename_lock);
 	rcu_read_lock();
 	for (temp = direntry; !IS_ROOT(temp);) {
<span class="p_chunk">@@ -137,7 +142,7 @@</span> <span class="p_context"> build_path_from_dentry(struct dentry *direntry)</span>
 		}
 	}
 	rcu_read_unlock();
<span class="p_del">-	if (namelen != dfsplen || read_seqretry(&amp;rename_lock, seq)) {</span>
<span class="p_add">+	if (namelen != dfsplen + pplen || read_seqretry(&amp;rename_lock, seq)) {</span>
 		cifs_dbg(FYI, &quot;did not end path lookup where expected. namelen=%ddfsplen=%d\n&quot;,
 			 namelen, dfsplen);
 		/* presumably this is only possible if racing with a rename
<span class="p_chunk">@@ -153,6 +158,17 @@</span> <span class="p_context"> build_path_from_dentry(struct dentry *direntry)</span>
 	   those safely to &#39;/&#39; if any are found in the middle of the prepath */
 	/* BB test paths to Windows with &#39;/&#39; in the midst of prepath */
 
<span class="p_add">+	if (pplen) {</span>
<span class="p_add">+		int i;</span>
<span class="p_add">+</span>
<span class="p_add">+		cifs_dbg(FYI, &quot;using cifs_sb prepath &lt;%s&gt;\n&quot;, cifs_sb-&gt;prepath);</span>
<span class="p_add">+		memcpy(full_path+dfsplen+1, cifs_sb-&gt;prepath, pplen-1);</span>
<span class="p_add">+		full_path[dfsplen] = &#39;\\&#39;;</span>
<span class="p_add">+		for (i = 0; i &lt; pplen-1; i++)</span>
<span class="p_add">+			if (full_path[dfsplen+1+i] == &#39;/&#39;)</span>
<span class="p_add">+				full_path[dfsplen+1+i] = CIFS_DIR_SEP(cifs_sb);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (dfsplen) {
 		strncpy(full_path, tcon-&gt;treeName, dfsplen);
 		if (cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_POSIX_PATHS) {
<span class="p_header">diff --git a/fs/cifs/file.c b/fs/cifs/file.c</span>
<span class="p_header">index 5f82e4905752..0ae3f55290e9 100644</span>
<span class="p_header">--- a/fs/cifs/file.c</span>
<span class="p_header">+++ b/fs/cifs/file.c</span>
<span class="p_chunk">@@ -2593,18 +2593,19 @@</span> <span class="p_context"> cifs_writev(struct kiocb *iocb, struct iov_iter *from)</span>
 	ssize_t rc = -EACCES;
 	loff_t lock_pos = iocb-&gt;ki_pos;
 
<span class="p_add">+	mutex_lock(&amp;inode-&gt;i_mutex);</span>
 	/*
 	 * We need to hold the sem to be sure nobody modifies lock list
 	 * with a brlock that prevents writing.
 	 */
 	down_read(&amp;cinode-&gt;lock_sem);
<span class="p_del">-	mutex_lock(&amp;inode-&gt;i_mutex);</span>
 	if (file-&gt;f_flags &amp; O_APPEND)
 		lock_pos = i_size_read(inode);
 	if (!cifs_find_lock_conflict(cfile, lock_pos, iov_iter_count(from),
 				     server-&gt;vals-&gt;exclusive_lock_type, NULL,
 				     CIFS_WRITE_OP)) {
 		rc = __generic_file_write_iter(iocb, from);
<span class="p_add">+		up_read(&amp;cinode-&gt;lock_sem);</span>
 		mutex_unlock(&amp;inode-&gt;i_mutex);
 
 		if (rc &gt; 0) {
<span class="p_chunk">@@ -2615,9 +2616,9 @@</span> <span class="p_context"> cifs_writev(struct kiocb *iocb, struct iov_iter *from)</span>
 				rc = err;
 		}
 	} else {
<span class="p_add">+		up_read(&amp;cinode-&gt;lock_sem);</span>
 		mutex_unlock(&amp;inode-&gt;i_mutex);
 	}
<span class="p_del">-	up_read(&amp;cinode-&gt;lock_sem);</span>
 	return rc;
 }
 
<span class="p_header">diff --git a/fs/cifs/inode.c b/fs/cifs/inode.c</span>
<span class="p_header">index 6a5ca969c301..a9a5bee1890e 100644</span>
<span class="p_header">--- a/fs/cifs/inode.c</span>
<span class="p_header">+++ b/fs/cifs/inode.c</span>
<span class="p_chunk">@@ -950,12 +950,29 @@</span> <span class="p_context"> struct inode *cifs_root_iget(struct super_block *sb)</span>
 	struct inode *inode = NULL;
 	long rc;
 	struct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);
<span class="p_add">+	char *path = NULL;</span>
<span class="p_add">+	int len;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_USE_PREFIX_PATH)</span>
<span class="p_add">+	    &amp;&amp; cifs_sb-&gt;prepath) {</span>
<span class="p_add">+		len = strlen(cifs_sb-&gt;prepath);</span>
<span class="p_add">+		path = kzalloc(len + 2 /* leading sep + null */, GFP_KERNEL);</span>
<span class="p_add">+		if (path == NULL)</span>
<span class="p_add">+			return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+		path[0] = &#39;/&#39;;</span>
<span class="p_add">+		memcpy(path+1, cifs_sb-&gt;prepath, len);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		path = kstrdup(&quot;&quot;, GFP_KERNEL);</span>
<span class="p_add">+		if (path == NULL)</span>
<span class="p_add">+			return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+	}</span>
 
 	xid = get_xid();
<span class="p_add">+	convert_delimiter(path, CIFS_DIR_SEP(cifs_sb));</span>
 	if (tcon-&gt;unix_ext)
<span class="p_del">-		rc = cifs_get_inode_info_unix(&amp;inode, &quot;&quot;, sb, xid);</span>
<span class="p_add">+		rc = cifs_get_inode_info_unix(&amp;inode, path, sb, xid);</span>
 	else
<span class="p_del">-		rc = cifs_get_inode_info(&amp;inode, &quot;&quot;, NULL, sb, xid, NULL);</span>
<span class="p_add">+		rc = cifs_get_inode_info(&amp;inode, path, NULL, sb, xid, NULL);</span>
 
 	if (!inode) {
 		inode = ERR_PTR(rc);
<span class="p_chunk">@@ -983,6 +1000,7 @@</span> <span class="p_context"> struct inode *cifs_root_iget(struct super_block *sb)</span>
 	}
 
 out:
<span class="p_add">+	kfree(path);</span>
 	/* can not call macro free_xid here since in a void func
 	 * TODO: This is no longer true
 	 */
<span class="p_header">diff --git a/fs/dcache.c b/fs/dcache.c</span>
<span class="p_header">index c35d0ee1a7da..8a84b99ea8d4 100644</span>
<span class="p_header">--- a/fs/dcache.c</span>
<span class="p_header">+++ b/fs/dcache.c</span>
<span class="p_chunk">@@ -1066,11 +1066,12 @@</span> <span class="p_context"> void shrink_dcache_sb(struct super_block *sb)</span>
 		LIST_HEAD(dispose);
 
 		freed = list_lru_walk(&amp;sb-&gt;s_dentry_lru,
<span class="p_del">-			dentry_lru_isolate_shrink, &amp;dispose, UINT_MAX);</span>
<span class="p_add">+			dentry_lru_isolate_shrink, &amp;dispose, 1024);</span>
 
 		this_cpu_sub(nr_dentry_unused, freed);
 		shrink_dentry_list(&amp;dispose);
<span class="p_del">-	} while (freed &gt; 0);</span>
<span class="p_add">+		cond_resched();</span>
<span class="p_add">+	} while (list_lru_count(&amp;sb-&gt;s_dentry_lru) &gt; 0);</span>
 }
 EXPORT_SYMBOL(shrink_dcache_sb);
 
<span class="p_header">diff --git a/fs/exec.c b/fs/exec.c</span>
<span class="p_header">index b5af6a256cf7..fa3604731bae 100644</span>
<span class="p_header">--- a/fs/exec.c</span>
<span class="p_header">+++ b/fs/exec.c</span>
<span class="p_chunk">@@ -1269,7 +1269,7 @@</span> <span class="p_context"> static void check_unsafe_exec(struct linux_binprm *bprm)</span>
 	 * This isn&#39;t strictly necessary, but it makes it harder for LSMs to
 	 * mess up.
 	 */
<span class="p_del">-	if (current-&gt;no_new_privs)</span>
<span class="p_add">+	if (task_no_new_privs(current))</span>
 		bprm-&gt;unsafe |= LSM_UNSAFE_NO_NEW_PRIVS;
 
 	t = p;
<span class="p_chunk">@@ -1303,7 +1303,7 @@</span> <span class="p_context"> static void bprm_fill_uid(struct linux_binprm *bprm)</span>
 	if (bprm-&gt;file-&gt;f_path.mnt-&gt;mnt_flags &amp; MNT_NOSUID)
 		return;
 
<span class="p_del">-	if (current-&gt;no_new_privs)</span>
<span class="p_add">+	if (task_no_new_privs(current))</span>
 		return;
 
 	inode = file_inode(bprm-&gt;file);
<span class="p_header">diff --git a/fs/ext2/acl.c b/fs/ext2/acl.c</span>
<span class="p_header">index d6aeb84e90b6..57f367e75838 100644</span>
<span class="p_header">--- a/fs/ext2/acl.c</span>
<span class="p_header">+++ b/fs/ext2/acl.c</span>
<span class="p_chunk">@@ -178,11 +178,8 @@</span> <span class="p_context"> ext2_get_acl(struct inode *inode, int type)</span>
 	return acl;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * inode-&gt;i_mutex: down</span>
<span class="p_del">- */</span>
<span class="p_del">-int</span>
<span class="p_del">-ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
<span class="p_add">+static int</span>
<span class="p_add">+__ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 {
 	int name_index;
 	void *value = NULL;
<span class="p_chunk">@@ -192,13 +189,6 @@</span> <span class="p_context"> ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 	switch(type) {
 		case ACL_TYPE_ACCESS:
 			name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;
<span class="p_del">-			if (acl) {</span>
<span class="p_del">-				error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_del">-				if (error)</span>
<span class="p_del">-					return error;</span>
<span class="p_del">-				inode-&gt;i_ctime = CURRENT_TIME_SEC;</span>
<span class="p_del">-				mark_inode_dirty(inode);</span>
<span class="p_del">-			}</span>
 			break;
 
 		case ACL_TYPE_DEFAULT:
<span class="p_chunk">@@ -224,6 +214,31 @@</span> <span class="p_context"> ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 	return error;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * inode-&gt;i_mutex: down</span>
<span class="p_add">+ */</span>
<span class="p_add">+int</span>
<span class="p_add">+ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int error;</span>
<span class="p_add">+	int update_mode = 0;</span>
<span class="p_add">+	umode_t mode = inode-&gt;i_mode;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (type == ACL_TYPE_ACCESS &amp;&amp; acl) {</span>
<span class="p_add">+		error = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			return error;</span>
<span class="p_add">+		update_mode = 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	error = __ext2_set_acl(inode, acl, type);</span>
<span class="p_add">+	if (!error &amp;&amp; update_mode) {</span>
<span class="p_add">+		inode-&gt;i_mode = mode;</span>
<span class="p_add">+		inode-&gt;i_ctime = CURRENT_TIME_SEC;</span>
<span class="p_add">+		mark_inode_dirty(inode);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return error;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Initialize the ACLs of a new inode. Called from ext2_new_inode.
  *
<span class="p_chunk">@@ -241,12 +256,12 @@</span> <span class="p_context"> ext2_init_acl(struct inode *inode, struct inode *dir)</span>
 		return error;
 
 	if (default_acl) {
<span class="p_del">-		error = ext2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);</span>
<span class="p_add">+		error = __ext2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);</span>
 		posix_acl_release(default_acl);
 	}
 	if (acl) {
 		if (!error)
<span class="p_del">-			error = ext2_set_acl(inode, acl, ACL_TYPE_ACCESS);</span>
<span class="p_add">+			error = __ext2_set_acl(inode, acl, ACL_TYPE_ACCESS);</span>
 		posix_acl_release(acl);
 	}
 	return error;
<span class="p_header">diff --git a/fs/ext3/acl.c b/fs/ext3/acl.c</span>
<span class="p_header">index c4509495a104..72e13c25e62a 100644</span>
<span class="p_header">--- a/fs/ext3/acl.c</span>
<span class="p_header">+++ b/fs/ext3/acl.c</span>
<span class="p_chunk">@@ -194,13 +194,6 @@</span> <span class="p_context"> __ext3_set_acl(handle_t *handle, struct inode *inode, int type,</span>
 	switch(type) {
 		case ACL_TYPE_ACCESS:
 			name_index = EXT3_XATTR_INDEX_POSIX_ACL_ACCESS;
<span class="p_del">-			if (acl) {</span>
<span class="p_del">-				error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_del">-				if (error)</span>
<span class="p_del">-					return error;</span>
<span class="p_del">-				inode-&gt;i_ctime = CURRENT_TIME_SEC;</span>
<span class="p_del">-				ext3_mark_inode_dirty(handle, inode);</span>
<span class="p_del">-			}</span>
 			break;
 
 		case ACL_TYPE_DEFAULT:
<span class="p_chunk">@@ -234,12 +227,26 @@</span> <span class="p_context"> ext3_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 {
 	handle_t *handle;
 	int error, retries = 0;
<span class="p_add">+	int update_mode = 0;</span>
<span class="p_add">+	umode_t mode = inode-&gt;i_mode;</span>
 
 retry:
 	handle = ext3_journal_start(inode, EXT3_DATA_TRANS_BLOCKS(inode-&gt;i_sb));
 	if (IS_ERR(handle))
 		return PTR_ERR(handle);
<span class="p_add">+	if (type == ACL_TYPE_ACCESS &amp;&amp; acl) {</span>
<span class="p_add">+		error = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			goto journal_stop;</span>
<span class="p_add">+		update_mode = 1;</span>
<span class="p_add">+	}</span>
 	error = __ext3_set_acl(handle, inode, type, acl);
<span class="p_add">+	if (!error &amp;&amp; update_mode) {</span>
<span class="p_add">+		inode-&gt;i_mode = mode;</span>
<span class="p_add">+		inode-&gt;i_ctime = CURRENT_TIME_SEC;</span>
<span class="p_add">+		ext3_mark_inode_dirty(handle, inode);</span>
<span class="p_add">+	}</span>
<span class="p_add">+journal_stop:</span>
 	ext3_journal_stop(handle);
 	if (error == -ENOSPC &amp;&amp; ext3_should_retry_alloc(inode-&gt;i_sb, &amp;retries))
 		goto retry;
<span class="p_header">diff --git a/fs/ext4/acl.c b/fs/ext4/acl.c</span>
<span class="p_header">index 87d9bbf6a53f..a3d322487a86 100644</span>
<span class="p_header">--- a/fs/ext4/acl.c</span>
<span class="p_header">+++ b/fs/ext4/acl.c</span>
<span class="p_chunk">@@ -200,13 +200,6 @@</span> <span class="p_context"> __ext4_set_acl(handle_t *handle, struct inode *inode, int type,</span>
 	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;
<span class="p_del">-		if (acl) {</span>
<span class="p_del">-			error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_del">-			if (error)</span>
<span class="p_del">-				return error;</span>
<span class="p_del">-			inode-&gt;i_ctime = ext4_current_time(inode);</span>
<span class="p_del">-			ext4_mark_inode_dirty(handle, inode);</span>
<span class="p_del">-		}</span>
 		break;
 
 	case ACL_TYPE_DEFAULT:
<span class="p_chunk">@@ -228,8 +221,9 @@</span> <span class="p_context"> __ext4_set_acl(handle_t *handle, struct inode *inode, int type,</span>
 				      value, size, 0);
 
 	kfree(value);
<span class="p_del">-	if (!error)</span>
<span class="p_add">+	if (!error) {</span>
 		set_cached_acl(inode, type, acl);
<span class="p_add">+	}</span>
 
 	return error;
 }
<span class="p_chunk">@@ -239,6 +233,8 @@</span> <span class="p_context"> ext4_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 {
 	handle_t *handle;
 	int error, retries = 0;
<span class="p_add">+	umode_t mode = inode-&gt;i_mode;</span>
<span class="p_add">+	int update_mode = 0;</span>
 
 retry:
 	handle = ext4_journal_start(inode, EXT4_HT_XATTR,
<span class="p_chunk">@@ -246,7 +242,20 @@</span> <span class="p_context"> ext4_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 	if (IS_ERR(handle))
 		return PTR_ERR(handle);
 
<span class="p_add">+	if ((type == ACL_TYPE_ACCESS) &amp;&amp; acl) {</span>
<span class="p_add">+		error = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			goto out_stop;</span>
<span class="p_add">+		update_mode = 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	error = __ext4_set_acl(handle, inode, type, acl);
<span class="p_add">+	if (!error &amp;&amp; update_mode) {</span>
<span class="p_add">+		inode-&gt;i_mode = mode;</span>
<span class="p_add">+		inode-&gt;i_ctime = ext4_current_time(inode);</span>
<span class="p_add">+		ext4_mark_inode_dirty(handle, inode);</span>
<span class="p_add">+	}</span>
<span class="p_add">+out_stop:</span>
 	ext4_journal_stop(handle);
 	if (error == -ENOSPC &amp;&amp; ext4_should_retry_alloc(inode-&gt;i_sb, &amp;retries))
 		goto retry;
<span class="p_header">diff --git a/fs/f2fs/acl.c b/fs/f2fs/acl.c</span>
<span class="p_header">index ff4737033823..e6e2dd4779f0 100644</span>
<span class="p_header">--- a/fs/f2fs/acl.c</span>
<span class="p_header">+++ b/fs/f2fs/acl.c</span>
<span class="p_chunk">@@ -202,6 +202,7 @@</span> <span class="p_context"> static int __f2fs_set_acl(struct inode *inode, int type,</span>
 	void *value = NULL;
 	size_t size = 0;
 	int error;
<span class="p_add">+	umode_t mode = inode-&gt;i_mode;</span>
 
 	if (acl) {
 		error = posix_acl_valid(acl);
<span class="p_chunk">@@ -212,11 +213,11 @@</span> <span class="p_context"> static int __f2fs_set_acl(struct inode *inode, int type,</span>
 	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;
<span class="p_del">-		if (acl) {</span>
<span class="p_del">-			error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+		if (acl &amp;&amp; !ipage) {</span>
<span class="p_add">+			error = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
 			if (error)
 				return error;
<span class="p_del">-			set_acl_inode(fi, inode-&gt;i_mode);</span>
<span class="p_add">+			set_acl_inode(fi, mode);</span>
 		}
 		break;
 
<span class="p_header">diff --git a/fs/f2fs/gc.c b/fs/f2fs/gc.c</span>
<span class="p_header">index 6267817dfe87..b3524f06fd82 100644</span>
<span class="p_header">--- a/fs/f2fs/gc.c</span>
<span class="p_header">+++ b/fs/f2fs/gc.c</span>
<span class="p_chunk">@@ -35,13 +35,14 @@</span> <span class="p_context"> static int gc_thread_func(void *data)</span>
 
 	wait_ms = gc_th-&gt;min_sleep_time;
 
<span class="p_add">+	set_freezable();</span>
 	do {
<span class="p_add">+		wait_event_interruptible_timeout(*wq,</span>
<span class="p_add">+				kthread_should_stop() || freezing(current),</span>
<span class="p_add">+				msecs_to_jiffies(wait_ms));</span>
<span class="p_add">+</span>
 		if (try_to_freeze())
 			continue;
<span class="p_del">-		else</span>
<span class="p_del">-			wait_event_interruptible_timeout(*wq,</span>
<span class="p_del">-						kthread_should_stop(),</span>
<span class="p_del">-						msecs_to_jiffies(wait_ms));</span>
 		if (kthread_should_stop())
 			break;
 
<span class="p_header">diff --git a/fs/f2fs/inode.c b/fs/f2fs/inode.c</span>
<span class="p_header">index 2cf6962f6cc8..4d333b643cc8 100644</span>
<span class="p_header">--- a/fs/f2fs/inode.c</span>
<span class="p_header">+++ b/fs/f2fs/inode.c</span>
<span class="p_chunk">@@ -168,6 +168,7 @@</span> <span class="p_context"> struct inode *f2fs_iget(struct super_block *sb, unsigned long ino)</span>
 		ret = -EIO;
 		goto bad_inode;
 	}
<span class="p_add">+	f2fs_set_inode_flags(inode);</span>
 	unlock_new_inode(inode);
 	trace_f2fs_iget(inode);
 	return inode;
<span class="p_header">diff --git a/fs/hfsplus/posix_acl.c b/fs/hfsplus/posix_acl.c</span>
<span class="p_header">index 71b3087b7e32..c3173d480636 100644</span>
<span class="p_header">--- a/fs/hfsplus/posix_acl.c</span>
<span class="p_header">+++ b/fs/hfsplus/posix_acl.c</span>
<span class="p_chunk">@@ -54,8 +54,8 @@</span> <span class="p_context"> struct posix_acl *hfsplus_get_posix_acl(struct inode *inode, int type)</span>
 	return acl;
 }
 
<span class="p_del">-int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,</span>
<span class="p_del">-		int type)</span>
<span class="p_add">+static int __hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,</span>
<span class="p_add">+				   int type)</span>
 {
 	int err;
 	char *xattr_name;
<span class="p_chunk">@@ -67,12 +67,6 @@</span> <span class="p_context"> int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,</span>
 	switch (type) {
 	case ACL_TYPE_ACCESS:
 		xattr_name = POSIX_ACL_XATTR_ACCESS;
<span class="p_del">-		if (acl) {</span>
<span class="p_del">-			err = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_del">-			if (err)</span>
<span class="p_del">-				return err;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		err = 0;</span>
 		break;
 
 	case ACL_TYPE_DEFAULT:
<span class="p_chunk">@@ -108,6 +102,18 @@</span> <span class="p_context"> int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,</span>
 	return err;
 }
 
<span class="p_add">+int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (type == ACL_TYPE_ACCESS &amp;&amp; acl) {</span>
<span class="p_add">+		err = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return __hfsplus_set_posix_acl(inode, acl, type);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int hfsplus_init_posix_acl(struct inode *inode, struct inode *dir)
 {
 	int err = 0;
<span class="p_chunk">@@ -125,15 +131,15 @@</span> <span class="p_context"> int hfsplus_init_posix_acl(struct inode *inode, struct inode *dir)</span>
 		return err;
 
 	if (default_acl) {
<span class="p_del">-		err = hfsplus_set_posix_acl(inode, default_acl,</span>
<span class="p_del">-					    ACL_TYPE_DEFAULT);</span>
<span class="p_add">+		err = __hfsplus_set_posix_acl(inode, default_acl,</span>
<span class="p_add">+					      ACL_TYPE_DEFAULT);</span>
 		posix_acl_release(default_acl);
 	}
 
 	if (acl) {
 		if (!err)
<span class="p_del">-			err = hfsplus_set_posix_acl(inode, acl,</span>
<span class="p_del">-						    ACL_TYPE_ACCESS);</span>
<span class="p_add">+			err = __hfsplus_set_posix_acl(inode, acl,</span>
<span class="p_add">+						      ACL_TYPE_ACCESS);</span>
 		posix_acl_release(acl);
 	}
 	return err;
<span class="p_header">diff --git a/fs/jfs/acl.c b/fs/jfs/acl.c</span>
<span class="p_header">index 9fad9f4fe883..30b70ad9fc1a 100644</span>
<span class="p_header">--- a/fs/jfs/acl.c</span>
<span class="p_header">+++ b/fs/jfs/acl.c</span>
<span class="p_chunk">@@ -83,13 +83,6 @@</span> <span class="p_context"> static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,</span>
 	switch (type) {
 	case ACL_TYPE_ACCESS:
 		ea_name = POSIX_ACL_XATTR_ACCESS;
<span class="p_del">-		if (acl) {</span>
<span class="p_del">-			rc = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_del">-			if (rc)</span>
<span class="p_del">-				return rc;</span>
<span class="p_del">-			inode-&gt;i_ctime = CURRENT_TIME;</span>
<span class="p_del">-			mark_inode_dirty(inode);</span>
<span class="p_del">-		}</span>
 		break;
 	case ACL_TYPE_DEFAULT:
 		ea_name = POSIX_ACL_XATTR_DEFAULT;
<span class="p_chunk">@@ -121,12 +114,27 @@</span> <span class="p_context"> int jfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 {
 	int rc;
 	tid_t tid;
<span class="p_add">+	int update_mode = 0;</span>
<span class="p_add">+	umode_t mode = inode-&gt;i_mode;</span>
 
 	tid = txBegin(inode-&gt;i_sb, 0);
 	mutex_lock(&amp;JFS_IP(inode)-&gt;commit_mutex);
<span class="p_add">+	if (type == ACL_TYPE_ACCESS &amp;&amp; acl) {</span>
<span class="p_add">+		rc = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_add">+		if (rc)</span>
<span class="p_add">+			goto end_tx;</span>
<span class="p_add">+		update_mode = 1;</span>
<span class="p_add">+	}</span>
 	rc = __jfs_set_acl(tid, inode, type, acl);
<span class="p_del">-	if (!rc)</span>
<span class="p_add">+	if (!rc) {</span>
<span class="p_add">+		if (update_mode) {</span>
<span class="p_add">+			inode-&gt;i_mode = mode;</span>
<span class="p_add">+			inode-&gt;i_ctime = CURRENT_TIME;</span>
<span class="p_add">+			mark_inode_dirty(inode);</span>
<span class="p_add">+		}</span>
 		rc = txCommit(tid, 1, &amp;inode, 0);
<span class="p_add">+	}</span>
<span class="p_add">+end_tx:</span>
 	txEnd(tid);
 	mutex_unlock(&amp;JFS_IP(inode)-&gt;commit_mutex);
 	return rc;
<span class="p_header">diff --git a/fs/proc/proc_sysctl.c b/fs/proc/proc_sysctl.c</span>
<span class="p_header">index 2475585f034b..75a00557cfea 100644</span>
<span class="p_header">--- a/fs/proc/proc_sysctl.c</span>
<span class="p_header">+++ b/fs/proc/proc_sysctl.c</span>
<span class="p_chunk">@@ -1030,7 +1030,7 @@</span> <span class="p_context"> static int sysctl_check_table(const char *path, struct ctl_table *table)</span>
 	int err = 0;
 	for (; table-&gt;procname; table++) {
 		if (table-&gt;child)
<span class="p_del">-			err = sysctl_err(path, table, &quot;Not a file&quot;);</span>
<span class="p_add">+			err |= sysctl_err(path, table, &quot;Not a file&quot;);</span>
 
 		if ((table-&gt;proc_handler == proc_dostring) ||
 		    (table-&gt;proc_handler == proc_dointvec) ||
<span class="p_chunk">@@ -1041,15 +1041,15 @@</span> <span class="p_context"> static int sysctl_check_table(const char *path, struct ctl_table *table)</span>
 		    (table-&gt;proc_handler == proc_doulongvec_minmax) ||
 		    (table-&gt;proc_handler == proc_doulongvec_ms_jiffies_minmax)) {
 			if (!table-&gt;data)
<span class="p_del">-				err = sysctl_err(path, table, &quot;No data&quot;);</span>
<span class="p_add">+				err |= sysctl_err(path, table, &quot;No data&quot;);</span>
 			if (!table-&gt;maxlen)
<span class="p_del">-				err = sysctl_err(path, table, &quot;No maxlen&quot;);</span>
<span class="p_add">+				err |= sysctl_err(path, table, &quot;No maxlen&quot;);</span>
 		}
 		if (!table-&gt;proc_handler)
<span class="p_del">-			err = sysctl_err(path, table, &quot;No proc_handler&quot;);</span>
<span class="p_add">+			err |= sysctl_err(path, table, &quot;No proc_handler&quot;);</span>
 
 		if ((table-&gt;mode &amp; (S_IRUGO|S_IWUGO)) != table-&gt;mode)
<span class="p_del">-			err = sysctl_err(path, table, &quot;bogus .mode 0%o&quot;,</span>
<span class="p_add">+			err |= sysctl_err(path, table, &quot;bogus .mode 0%o&quot;,</span>
 				table-&gt;mode);
 	}
 	return err;
<span class="p_header">diff --git a/fs/reiserfs/xattr_acl.c b/fs/reiserfs/xattr_acl.c</span>
<span class="p_header">index 7071c2230a92..095d0a52e5a6 100644</span>
<span class="p_header">--- a/fs/reiserfs/xattr_acl.c</span>
<span class="p_header">+++ b/fs/reiserfs/xattr_acl.c</span>
<span class="p_chunk">@@ -23,7 +23,8 @@</span> <span class="p_context"> reiserfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 	struct reiserfs_transaction_handle th;
 	size_t jcreate_blocks;
 	int size = acl ? posix_acl_xattr_size(acl-&gt;a_count) : 0;
<span class="p_del">-</span>
<span class="p_add">+	int update_mode = 0;</span>
<span class="p_add">+	umode_t mode = inode-&gt;i_mode;</span>
 
 	/*
 	 * Pessimism: We can&#39;t assume that anything from the xattr root up
<span class="p_chunk">@@ -37,7 +38,16 @@</span> <span class="p_context"> reiserfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 	error = journal_begin(&amp;th, inode-&gt;i_sb, jcreate_blocks);
 	reiserfs_write_unlock(inode-&gt;i_sb);
 	if (error == 0) {
<span class="p_add">+		if (type == ACL_TYPE_ACCESS &amp;&amp; acl) {</span>
<span class="p_add">+			error = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_add">+			if (error)</span>
<span class="p_add">+				goto unlock;</span>
<span class="p_add">+			update_mode = 1;</span>
<span class="p_add">+		}</span>
 		error = __reiserfs_set_acl(&amp;th, inode, type, acl);
<span class="p_add">+		if (!error &amp;&amp; update_mode)</span>
<span class="p_add">+			inode-&gt;i_mode = mode;</span>
<span class="p_add">+unlock:</span>
 		reiserfs_write_lock(inode-&gt;i_sb);
 		error2 = journal_end(&amp;th);
 		reiserfs_write_unlock(inode-&gt;i_sb);
<span class="p_chunk">@@ -245,11 +255,6 @@</span> <span class="p_context"> __reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,</span>
 	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name = POSIX_ACL_XATTR_ACCESS;
<span class="p_del">-		if (acl) {</span>
<span class="p_del">-			error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_del">-			if (error)</span>
<span class="p_del">-				return error;</span>
<span class="p_del">-		}</span>
 		break;
 	case ACL_TYPE_DEFAULT:
 		name = POSIX_ACL_XATTR_DEFAULT;
<span class="p_header">diff --git a/fs/ubifs/journal.c b/fs/ubifs/journal.c</span>
<span class="p_header">index 0e045e75abd8..2e93c33b1048 100644</span>
<span class="p_header">--- a/fs/ubifs/journal.c</span>
<span class="p_header">+++ b/fs/ubifs/journal.c</span>
<span class="p_chunk">@@ -573,7 +573,7 @@</span> <span class="p_context"> int ubifs_jnl_update(struct ubifs_info *c, const struct inode *dir,</span>
 	aligned_dlen = ALIGN(dlen, 8);
 	aligned_ilen = ALIGN(ilen, 8);
 	len = aligned_dlen + aligned_ilen + UBIFS_INO_NODE_SZ;
<span class="p_del">-	dent = kmalloc(len, GFP_NOFS);</span>
<span class="p_add">+	dent = kzalloc(len, GFP_NOFS);</span>
 	if (!dent)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -956,7 +956,7 @@</span> <span class="p_context"> int ubifs_jnl_rename(struct ubifs_info *c, const struct inode *old_dir,</span>
 	len = aligned_dlen1 + aligned_dlen2 + ALIGN(ilen, 8) + ALIGN(plen, 8);
 	if (old_dir != new_dir)
 		len += plen;
<span class="p_del">-	dent = kmalloc(len, GFP_NOFS);</span>
<span class="p_add">+	dent = kzalloc(len, GFP_NOFS);</span>
 	if (!dent)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -1303,7 +1303,7 @@</span> <span class="p_context"> int ubifs_jnl_delete_xattr(struct ubifs_info *c, const struct inode *host,</span>
 	hlen = host_ui-&gt;data_len + UBIFS_INO_NODE_SZ;
 	len = aligned_xlen + UBIFS_INO_NODE_SZ + ALIGN(hlen, 8);
 
<span class="p_del">-	xent = kmalloc(len, GFP_NOFS);</span>
<span class="p_add">+	xent = kzalloc(len, GFP_NOFS);</span>
 	if (!xent)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -1410,7 +1410,7 @@</span> <span class="p_context"> int ubifs_jnl_change_xattr(struct ubifs_info *c, const struct inode *inode,</span>
 	aligned_len1 = ALIGN(len1, 8);
 	aligned_len = aligned_len1 + ALIGN(len2, 8);
 
<span class="p_del">-	ino = kmalloc(aligned_len, GFP_NOFS);</span>
<span class="p_add">+	ino = kzalloc(aligned_len, GFP_NOFS);</span>
 	if (!ino)
 		return -ENOMEM;
 
<span class="p_header">diff --git a/fs/ubifs/tnc.c b/fs/ubifs/tnc.c</span>
<span class="p_header">index f07596463cde..cc2186990dbc 100644</span>
<span class="p_header">--- a/fs/ubifs/tnc.c</span>
<span class="p_header">+++ b/fs/ubifs/tnc.c</span>
<span class="p_chunk">@@ -2712,6 +2712,8 @@</span> <span class="p_context"> int ubifs_tnc_remove_ino(struct ubifs_info *c, ino_t inum)</span>
 		dbg_tnc(&quot;xent &#39;%s&#39;, ino %lu&quot;, xent-&gt;name,
 			(unsigned long)xattr_inum);
 
<span class="p_add">+		ubifs_evict_xattr_inode(c, xattr_inum);</span>
<span class="p_add">+</span>
 		nm.name = xent-&gt;name;
 		nm.len = le16_to_cpu(xent-&gt;nlen);
 		err = ubifs_tnc_remove_nm(c, &amp;key1, &amp;nm);
<span class="p_header">diff --git a/fs/ubifs/ubifs.h b/fs/ubifs/ubifs.h</span>
<span class="p_header">index 2a18270b02c0..8e764ac28f53 100644</span>
<span class="p_header">--- a/fs/ubifs/ubifs.h</span>
<span class="p_header">+++ b/fs/ubifs/ubifs.h</span>
<span class="p_chunk">@@ -1756,6 +1756,7 @@</span> <span class="p_context"> ssize_t ubifs_getxattr(struct dentry *dentry, const char *name, void *buf,</span>
 		       size_t size);
 ssize_t ubifs_listxattr(struct dentry *dentry, char *buffer, size_t size);
 int ubifs_removexattr(struct dentry *dentry, const char *name);
<span class="p_add">+void ubifs_evict_xattr_inode(struct ubifs_info *c, ino_t xattr_inum);</span>
 
 /* super.c */
 struct inode *ubifs_iget(struct super_block *sb, unsigned long inum);
<span class="p_header">diff --git a/fs/ubifs/xattr.c b/fs/ubifs/xattr.c</span>
<span class="p_header">index ce6c0d4aa48d..4b6e09615ed5 100644</span>
<span class="p_header">--- a/fs/ubifs/xattr.c</span>
<span class="p_header">+++ b/fs/ubifs/xattr.c</span>
<span class="p_chunk">@@ -481,6 +481,28 @@</span> <span class="p_context"> ssize_t ubifs_listxattr(struct dentry *dentry, char *buffer, size_t size)</span>
 	return written;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * ubifs_evict_xattr_inode - Evict an xattr inode.</span>
<span class="p_add">+ * @c: UBIFS file-system description object</span>
<span class="p_add">+ * @xattr_inum: xattr inode number</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * When an inode that hosts xattrs is being removed we have to make sure</span>
<span class="p_add">+ * that cached inodes of the xattrs also get removed from the inode cache</span>
<span class="p_add">+ * otherwise we&#39;d waste memory. This function looks up an inode from the</span>
<span class="p_add">+ * inode cache and clears the link counter such that iput() will evict</span>
<span class="p_add">+ * the inode.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void ubifs_evict_xattr_inode(struct ubifs_info *c, ino_t xattr_inum)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct inode *inode;</span>
<span class="p_add">+</span>
<span class="p_add">+	inode = ilookup(c-&gt;vfs_sb, xattr_inum);</span>
<span class="p_add">+	if (inode) {</span>
<span class="p_add">+		clear_nlink(inode);</span>
<span class="p_add">+		iput(inode);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int remove_xattr(struct ubifs_info *c, struct inode *host,
 			struct inode *inode, const struct qstr *nm)
 {
<span class="p_header">diff --git a/fs/udf/file.c b/fs/udf/file.c</span>
<span class="p_header">index 1aaf63a5f32f..8fc4135e514c 100644</span>
<span class="p_header">--- a/fs/udf/file.c</span>
<span class="p_header">+++ b/fs/udf/file.c</span>
<span class="p_chunk">@@ -44,10 +44,15 @@</span> <span class="p_context"> static void __udf_adinicb_readpage(struct page *page)</span>
 	struct inode *inode = page-&gt;mapping-&gt;host;
 	char *kaddr;
 	struct udf_inode_info *iinfo = UDF_I(inode);
<span class="p_add">+	loff_t isize = i_size_read(inode);</span>
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We have to be careful here as truncate can change i_size under us.</span>
<span class="p_add">+	 * So just sample it once and use the same value everywhere.</span>
<span class="p_add">+	 */</span>
 	kaddr = kmap(page);
<span class="p_del">-	memcpy(kaddr, iinfo-&gt;i_ext.i_data + iinfo-&gt;i_lenEAttr, inode-&gt;i_size);</span>
<span class="p_del">-	memset(kaddr + inode-&gt;i_size, 0, PAGE_CACHE_SIZE - inode-&gt;i_size);</span>
<span class="p_add">+	memcpy(kaddr, iinfo-&gt;i_ext.i_data + iinfo-&gt;i_lenEAttr, isize);</span>
<span class="p_add">+	memset(kaddr + isize, 0, PAGE_CACHE_SIZE - isize);</span>
 	flush_dcache_page(page);
 	SetPageUptodate(page);
 	kunmap(page);
<span class="p_header">diff --git a/fs/udf/inode.c b/fs/udf/inode.c</span>
<span class="p_header">index c2b1e6aa8dbd..28b5d30a7181 100644</span>
<span class="p_header">--- a/fs/udf/inode.c</span>
<span class="p_header">+++ b/fs/udf/inode.c</span>
<span class="p_chunk">@@ -1238,8 +1238,8 @@</span> <span class="p_context"> int udf_setsize(struct inode *inode, loff_t newsize)</span>
 			return err;
 		}
 set_size:
<span class="p_del">-		truncate_setsize(inode, newsize);</span>
 		up_write(&amp;iinfo-&gt;i_data_sem);
<span class="p_add">+		truncate_setsize(inode, newsize);</span>
 	} else {
 		if (iinfo-&gt;i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {
 			down_write(&amp;iinfo-&gt;i_data_sem);
<span class="p_chunk">@@ -1256,9 +1256,9 @@</span> <span class="p_context"> int udf_setsize(struct inode *inode, loff_t newsize)</span>
 					  udf_get_block);
 		if (err)
 			return err;
<span class="p_add">+		truncate_setsize(inode, newsize);</span>
 		down_write(&amp;iinfo-&gt;i_data_sem);
 		udf_clear_extent_cache(inode);
<span class="p_del">-		truncate_setsize(inode, newsize);</span>
 		udf_truncate_extents(inode);
 		up_write(&amp;iinfo-&gt;i_data_sem);
 	}
<span class="p_header">diff --git a/fs/xfs/xfs_acl.c b/fs/xfs/xfs_acl.c</span>
<span class="p_header">index 7d65e25eccc5..0ca1a03da0b3 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_acl.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_acl.c</span>
<span class="p_chunk">@@ -176,8 +176,8 @@</span> <span class="p_context"> xfs_get_acl(struct inode *inode, int type)</span>
 	return acl;
 }
 
<span class="p_del">-STATIC int</span>
<span class="p_del">-__xfs_set_acl(struct inode *inode, int type, struct posix_acl *acl)</span>
<span class="p_add">+int</span>
<span class="p_add">+__xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 {
 	struct xfs_inode *ip = XFS_I(inode);
 	unsigned char *ea_name;
<span class="p_chunk">@@ -297,5 +297,5 @@</span> <span class="p_context"> xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 	}
 
  set_acl:
<span class="p_del">-	return __xfs_set_acl(inode, type, acl);</span>
<span class="p_add">+	return __xfs_set_acl(inode, acl, type);</span>
 }
<span class="p_header">diff --git a/fs/xfs/xfs_acl.h b/fs/xfs/xfs_acl.h</span>
<span class="p_header">index 5dc163744511..19628001094d 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_acl.h</span>
<span class="p_header">+++ b/fs/xfs/xfs_acl.h</span>
<span class="p_chunk">@@ -61,6 +61,7 @@</span> <span class="p_context"> struct xfs_acl {</span>
 #ifdef CONFIG_XFS_POSIX_ACL
 extern struct posix_acl *xfs_get_acl(struct inode *inode, int type);
 extern int xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type);
<span class="p_add">+extern int __xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type);</span>
 extern int posix_acl_access_exists(struct inode *inode);
 extern int posix_acl_default_exists(struct inode *inode);
 #else
<span class="p_header">diff --git a/fs/xfs/xfs_dinode.h b/fs/xfs/xfs_dinode.h</span>
<span class="p_header">index 623bbe8fd921..a62b36731775 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_dinode.h</span>
<span class="p_header">+++ b/fs/xfs/xfs_dinode.h</span>
<span class="p_chunk">@@ -228,7 +228,14 @@</span> <span class="p_context"> static inline void xfs_dinode_put_rdev(struct xfs_dinode *dip, xfs_dev_t rdev)</span>
 #define XFS_DIFLAG_FILESTREAM    (1 &lt;&lt; XFS_DIFLAG_FILESTREAM_BIT)
 
 #ifdef CONFIG_XFS_RT
<span class="p_del">-#define XFS_IS_REALTIME_INODE(ip) ((ip)-&gt;i_d.di_flags &amp; XFS_DIFLAG_REALTIME)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * make sure we ignore the inode flag if the filesystem doesn&#39;t have a</span>
<span class="p_add">+ * configured realtime device.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define XFS_IS_REALTIME_INODE(ip)			\</span>
<span class="p_add">+	(((ip)-&gt;i_d.di_flags &amp; XFS_DIFLAG_REALTIME) &amp;&amp;	\</span>
<span class="p_add">+	 (ip)-&gt;i_mount-&gt;m_rtdev_targp)</span>
 #else
 #define XFS_IS_REALTIME_INODE(ip) (0)
 #endif
<span class="p_header">diff --git a/fs/xfs/xfs_iops.c b/fs/xfs/xfs_iops.c</span>
<span class="p_header">index 37f6884ae39a..ea5628fe1ff2 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_iops.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_iops.c</span>
<span class="p_chunk">@@ -173,12 +173,12 @@</span> <span class="p_context"> xfs_generic_create(</span>
 
 #ifdef CONFIG_XFS_POSIX_ACL
 	if (default_acl) {
<span class="p_del">-		error = -xfs_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);</span>
<span class="p_add">+		error = -__xfs_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);</span>
 		if (error)
 			goto out_cleanup_inode;
 	}
 	if (acl) {
<span class="p_del">-		error = -xfs_set_acl(inode, acl, ACL_TYPE_ACCESS);</span>
<span class="p_add">+		error = -__xfs_set_acl(inode, acl, ACL_TYPE_ACCESS);</span>
 		if (error)
 			goto out_cleanup_inode;
 	}
<span class="p_header">diff --git a/include/linux/cpumask.h b/include/linux/cpumask.h</span>
<span class="p_header">index 2997af6d2ccd..0e0f3a4e8844 100644</span>
<span class="p_header">--- a/include/linux/cpumask.h</span>
<span class="p_header">+++ b/include/linux/cpumask.h</span>
<span class="p_chunk">@@ -225,6 +225,23 @@</span> <span class="p_context"> int cpumask_set_cpu_local_first(int i, int numa_node, cpumask_t *dstp);</span>
 		(cpu) = cpumask_next_zero((cpu), (mask)),	\
 		(cpu) &lt; nr_cpu_ids;)
 
<span class="p_add">+extern int cpumask_next_wrap(int n, const struct cpumask *mask, int start, bool wrap);</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * for_each_cpu_wrap - iterate over every cpu in a mask, starting at a specified location</span>
<span class="p_add">+ * @cpu: the (optionally unsigned) integer iterator</span>
<span class="p_add">+ * @mask: the cpumask poiter</span>
<span class="p_add">+ * @start: the start location</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The implementation does not assume any bit in @mask is set (including @start).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * After the loop, cpu is &gt;= nr_cpu_ids.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define for_each_cpu_wrap(cpu, mask, start)					\</span>
<span class="p_add">+	for ((cpu) = cpumask_next_wrap((start)-1, (mask), (start), false);	\</span>
<span class="p_add">+	     (cpu) &lt; nr_cpumask_bits;						\</span>
<span class="p_add">+	     (cpu) = cpumask_next_wrap((cpu), (mask), (start), true))</span>
<span class="p_add">+</span>
 /**
  * for_each_cpu_and - iterate over every cpu in both masks
  * @cpu: the (optionally unsigned) integer iterator
<span class="p_header">diff --git a/include/linux/cpuset.h b/include/linux/cpuset.h</span>
<span class="p_header">index ade2390ffe92..6e39c9bb0dae 100644</span>
<span class="p_header">--- a/include/linux/cpuset.h</span>
<span class="p_header">+++ b/include/linux/cpuset.h</span>
<span class="p_chunk">@@ -93,12 +93,12 @@</span> <span class="p_context"> extern int cpuset_slab_spread_node(void);</span>
 
 static inline int cpuset_do_page_mem_spread(void)
 {
<span class="p_del">-	return current-&gt;flags &amp; PF_SPREAD_PAGE;</span>
<span class="p_add">+	return task_spread_page(current);</span>
 }
 
 static inline int cpuset_do_slab_mem_spread(void)
 {
<span class="p_del">-	return current-&gt;flags &amp; PF_SPREAD_SLAB;</span>
<span class="p_add">+	return task_spread_slab(current);</span>
 }
 
 extern int current_cpuset_is_being_rebound(void);
<span class="p_header">diff --git a/include/linux/net.h b/include/linux/net.h</span>
<span class="p_header">index 17d83393afcc..8751fe4e8038 100644</span>
<span class="p_header">--- a/include/linux/net.h</span>
<span class="p_header">+++ b/include/linux/net.h</span>
<span class="p_chunk">@@ -242,8 +242,25 @@</span> <span class="p_context"> do {								\</span>
 	net_ratelimited_function(pr_warn, fmt, ##__VA_ARGS__)
 #define net_info_ratelimited(fmt, ...)				\
 	net_ratelimited_function(pr_info, fmt, ##__VA_ARGS__)
<span class="p_add">+#if defined(CONFIG_DYNAMIC_DEBUG)</span>
<span class="p_add">+#define net_dbg_ratelimited(fmt, ...)					\</span>
<span class="p_add">+do {									\</span>
<span class="p_add">+	DEFINE_DYNAMIC_DEBUG_METADATA(descriptor, fmt);			\</span>
<span class="p_add">+	if (unlikely(descriptor.flags &amp; _DPRINTK_FLAGS_PRINT) &amp;&amp;	\</span>
<span class="p_add">+	    net_ratelimit())						\</span>
<span class="p_add">+		__dynamic_pr_debug(&amp;descriptor, pr_fmt(fmt),		\</span>
<span class="p_add">+		                   ##__VA_ARGS__);			\</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+#elif defined(DEBUG)</span>
 #define net_dbg_ratelimited(fmt, ...)				\
 	net_ratelimited_function(pr_debug, fmt, ##__VA_ARGS__)
<span class="p_add">+#else</span>
<span class="p_add">+#define net_dbg_ratelimited(fmt, ...)				\</span>
<span class="p_add">+	do {							\</span>
<span class="p_add">+		if (0)						\</span>
<span class="p_add">+			no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__); \</span>
<span class="p_add">+	} while (0)</span>
<span class="p_add">+#endif</span>
 
 bool __net_get_random_once(void *buf, int nbytes, bool *done,
 			   struct static_key *done_key);
<span class="p_header">diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h</span>
<span class="p_header">index 83a76633c03e..cf1846de8196 100644</span>
<span class="p_header">--- a/include/linux/pci_ids.h</span>
<span class="p_header">+++ b/include/linux/pci_ids.h</span>
<span class="p_chunk">@@ -2474,6 +2474,13 @@</span> <span class="p_context"></span>
 #define PCI_DEVICE_ID_KORENIX_JETCARDF2	0x1700
 #define PCI_DEVICE_ID_KORENIX_JETCARDF3	0x17ff
 
<span class="p_add">+#define PCI_VENDOR_ID_NETRONOME		0x19ee</span>
<span class="p_add">+#define PCI_DEVICE_ID_NETRONOME_NFP3200	0x3200</span>
<span class="p_add">+#define PCI_DEVICE_ID_NETRONOME_NFP3240	0x3240</span>
<span class="p_add">+#define PCI_DEVICE_ID_NETRONOME_NFP4000	0x4000</span>
<span class="p_add">+#define PCI_DEVICE_ID_NETRONOME_NFP6000	0x6000</span>
<span class="p_add">+#define PCI_DEVICE_ID_NETRONOME_NFP6000_VF	0x6003</span>
<span class="p_add">+</span>
 #define PCI_VENDOR_ID_QMI		0x1a32
 
 #define PCI_VENDOR_ID_AZWAVE		0x1a3b
<span class="p_header">diff --git a/include/linux/sched.h b/include/linux/sched.h</span>
<span class="p_header">index 504f5599463e..25ad8f0bbdcb 100644</span>
<span class="p_header">--- a/include/linux/sched.h</span>
<span class="p_header">+++ b/include/linux/sched.h</span>
<span class="p_chunk">@@ -1317,13 +1317,12 @@</span> <span class="p_context"> struct task_struct {</span>
 				 * execve */
 	unsigned in_iowait:1;
 
<span class="p_del">-	/* task may not gain privileges */</span>
<span class="p_del">-	unsigned no_new_privs:1;</span>
<span class="p_del">-</span>
 	/* Revert to default priority/policy when forking */
 	unsigned sched_reset_on_fork:1;
 	unsigned sched_contributes_to_load:1;
 
<span class="p_add">+	unsigned long atomic_flags; /* Flags needing atomic access. */</span>
<span class="p_add">+</span>
 	pid_t pid;
 	pid_t tgid;
 
<span class="p_chunk">@@ -1924,8 +1923,6 @@</span> <span class="p_context"> extern void thread_group_cputime_adjusted(struct task_struct *p, cputime_t *ut,</span>
 #define PF_KTHREAD	0x00200000	/* I am a kernel thread */
 #define PF_RANDOMIZE	0x00400000	/* randomize virtual address space */
 #define PF_SWAPWRITE	0x00800000	/* Allowed to write to swap */
<span class="p_del">-#define PF_SPREAD_PAGE	0x01000000	/* Spread page cache over cpuset */</span>
<span class="p_del">-#define PF_SPREAD_SLAB	0x02000000	/* Spread some slab caches over cpuset */</span>
 #define PF_NO_SETAFFINITY 0x04000000	/* Userland is not allowed to meddle with cpus_allowed */
 #define PF_MCE_EARLY    0x08000000      /* Early kill for mce process policy */
 #define PF_MUTEX_TESTER	0x20000000	/* Thread belongs to the rt mutex tester */
<span class="p_chunk">@@ -1979,6 +1976,33 @@</span> <span class="p_context"> static inline void memalloc_noio_restore(unsigned int flags)</span>
 	current-&gt;flags = (current-&gt;flags &amp; ~PF_MEMALLOC_NOIO) | flags;
 }
 
<span class="p_add">+/* Per-process atomic flags. */</span>
<span class="p_add">+#define PFA_NO_NEW_PRIVS 0	/* May not gain new privileges. */</span>
<span class="p_add">+#define PFA_SPREAD_PAGE  1      /* Spread page cache over cpuset */</span>
<span class="p_add">+#define PFA_SPREAD_SLAB  2      /* Spread some slab caches over cpuset */</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+#define TASK_PFA_TEST(name, func)					\</span>
<span class="p_add">+	static inline bool task_##func(struct task_struct *p)		\</span>
<span class="p_add">+	{ return test_bit(PFA_##name, &amp;p-&gt;atomic_flags); }</span>
<span class="p_add">+#define TASK_PFA_SET(name, func)					\</span>
<span class="p_add">+	static inline void task_set_##func(struct task_struct *p)	\</span>
<span class="p_add">+	{ set_bit(PFA_##name, &amp;p-&gt;atomic_flags); }</span>
<span class="p_add">+#define TASK_PFA_CLEAR(name, func)					\</span>
<span class="p_add">+	static inline void task_clear_##func(struct task_struct *p)	\</span>
<span class="p_add">+	{ clear_bit(PFA_##name, &amp;p-&gt;atomic_flags); }</span>
<span class="p_add">+</span>
<span class="p_add">+TASK_PFA_TEST(NO_NEW_PRIVS, no_new_privs)</span>
<span class="p_add">+TASK_PFA_SET(NO_NEW_PRIVS, no_new_privs)</span>
<span class="p_add">+</span>
<span class="p_add">+TASK_PFA_TEST(SPREAD_PAGE, spread_page)</span>
<span class="p_add">+TASK_PFA_SET(SPREAD_PAGE, spread_page)</span>
<span class="p_add">+TASK_PFA_CLEAR(SPREAD_PAGE, spread_page)</span>
<span class="p_add">+</span>
<span class="p_add">+TASK_PFA_TEST(SPREAD_SLAB, spread_slab)</span>
<span class="p_add">+TASK_PFA_SET(SPREAD_SLAB, spread_slab)</span>
<span class="p_add">+TASK_PFA_CLEAR(SPREAD_SLAB, spread_slab)</span>
<span class="p_add">+</span>
 /*
  * task-&gt;jobctl flags
  */
<span class="p_header">diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h</span>
<span class="p_header">index 6e98f62ea70d..5369c77607e5 100644</span>
<span class="p_header">--- a/include/linux/usb/hcd.h</span>
<span class="p_header">+++ b/include/linux/usb/hcd.h</span>
<span class="p_chunk">@@ -542,9 +542,9 @@</span> <span class="p_context"> extern void usb_ep0_reinit(struct usb_device *);</span>
 	((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_INTERFACE)&lt;&lt;8)
 
 #define EndpointRequest \
<span class="p_del">-	((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_INTERFACE)&lt;&lt;8)</span>
<span class="p_add">+	((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_ENDPOINT)&lt;&lt;8)</span>
 #define EndpointOutRequest \
<span class="p_del">-	((USB_DIR_OUT|USB_TYPE_STANDARD|USB_RECIP_INTERFACE)&lt;&lt;8)</span>
<span class="p_add">+	((USB_DIR_OUT|USB_TYPE_STANDARD|USB_RECIP_ENDPOINT)&lt;&lt;8)</span>
 
 /* class requests from the USB 2.0 hub spec, table 11-15 */
 /* GetBusState and SetHubDescriptor are optional, omitted */
<span class="p_header">diff --git a/include/linux/vfio.h b/include/linux/vfio.h</span>
<span class="p_header">index 8ec980b5e3af..e0074a2ed593 100644</span>
<span class="p_header">--- a/include/linux/vfio.h</span>
<span class="p_header">+++ b/include/linux/vfio.h</span>
<span class="p_chunk">@@ -94,6 +94,8 @@</span> <span class="p_context"> extern void vfio_unregister_iommu_driver(</span>
  */
 extern struct vfio_group *vfio_group_get_external_user(struct file *filep);
 extern void vfio_group_put_external_user(struct vfio_group *group);
<span class="p_add">+extern bool vfio_external_group_match_file(struct vfio_group *group,</span>
<span class="p_add">+					   struct file *filep);</span>
 extern int vfio_external_user_iommu_id(struct vfio_group *group);
 extern long vfio_external_check_extension(struct vfio_group *group,
 					  unsigned long arg);
<span class="p_header">diff --git a/include/rdma/ib_verbs.h b/include/rdma/ib_verbs.h</span>
<span class="p_header">index 7ccef342f724..7367f8c9aeeb 100644</span>
<span class="p_header">--- a/include/rdma/ib_verbs.h</span>
<span class="p_header">+++ b/include/rdma/ib_verbs.h</span>
<span class="p_chunk">@@ -1694,6 +1694,40 @@</span> <span class="p_context"> int ib_query_port(struct ib_device *device,</span>
 enum rdma_link_layer rdma_port_get_link_layer(struct ib_device *device,
 					       u8 port_num);
 
<span class="p_add">+/**</span>
<span class="p_add">+ * rdma_start_port - Return the first valid port number for the device</span>
<span class="p_add">+ * specified</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @device: Device to be checked</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return start port number</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline u8 rdma_start_port(const struct ib_device *device)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (device-&gt;node_type == RDMA_NODE_IB_SWITCH) ? 0 : 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * rdma_end_port - Return the last valid port number for the device</span>
<span class="p_add">+ * specified</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @device: Device to be checked</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return last port number</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline u8 rdma_end_port(const struct ib_device *device)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (device-&gt;node_type == RDMA_NODE_IB_SWITCH) ?</span>
<span class="p_add">+		0 : device-&gt;phys_port_cnt;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int rdma_is_port_valid(const struct ib_device *device,</span>
<span class="p_add">+				     unsigned int port)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (port &gt;= rdma_start_port(device) &amp;&amp;</span>
<span class="p_add">+		port &lt;= rdma_end_port(device));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int ib_query_gid(struct ib_device *device,
 		 u8 port_num, int index, union ib_gid *gid);
 
<span class="p_header">diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h</span>
<span class="p_header">index 72a1b3aba1a0..6868a5ca183c 100644</span>
<span class="p_header">--- a/include/scsi/scsi_device.h</span>
<span class="p_header">+++ b/include/scsi/scsi_device.h</span>
<span class="p_chunk">@@ -265,6 +265,7 @@</span> <span class="p_context"> enum scsi_target_state {</span>
 	STARGET_CREATED = 1,
 	STARGET_RUNNING,
 	STARGET_REMOVE,
<span class="p_add">+	STARGET_CREATED_REMOVE,</span>
 	STARGET_DEL,
 };
 
<span class="p_header">diff --git a/include/uapi/linux/v4l2-dv-timings.h b/include/uapi/linux/v4l2-dv-timings.h</span>
<span class="p_header">index 6c8f159e416e..63467ce7c3eb 100644</span>
<span class="p_header">--- a/include/uapi/linux/v4l2-dv-timings.h</span>
<span class="p_header">+++ b/include/uapi/linux/v4l2-dv-timings.h</span>
<span class="p_chunk">@@ -175,70 +175,80 @@</span> <span class="p_context"></span>
 
 #define V4L2_DV_BT_CEA_3840X2160P24 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		297000000, 1276, 88, 296, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, V4L2_DV_FL_CAN_REDUCE_FPS) \
 }
 
 #define V4L2_DV_BT_CEA_3840X2160P25 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		297000000, 1056, 88, 296, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, 0) \
 }
 
 #define V4L2_DV_BT_CEA_3840X2160P30 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		297000000, 176, 88, 296, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, V4L2_DV_FL_CAN_REDUCE_FPS) \
 }
 
 #define V4L2_DV_BT_CEA_3840X2160P50 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		594000000, 1056, 88, 296, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, 0) \
 }
 
 #define V4L2_DV_BT_CEA_3840X2160P60 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		594000000, 176, 88, 296, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, V4L2_DV_FL_CAN_REDUCE_FPS) \
 }
 
 #define V4L2_DV_BT_CEA_4096X2160P24 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		297000000, 1020, 88, 296, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, V4L2_DV_FL_CAN_REDUCE_FPS) \
 }
 
 #define V4L2_DV_BT_CEA_4096X2160P25 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		297000000, 968, 88, 128, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, 0) \
 }
 
 #define V4L2_DV_BT_CEA_4096X2160P30 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		297000000, 88, 88, 128, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, V4L2_DV_FL_CAN_REDUCE_FPS) \
 }
 
 #define V4L2_DV_BT_CEA_4096X2160P50 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		594000000, 968, 88, 128, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, 0) \
 }
 
 #define V4L2_DV_BT_CEA_4096X2160P60 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		594000000, 88, 88, 128, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, V4L2_DV_FL_CAN_REDUCE_FPS) \
 }
<span class="p_header">diff --git a/kernel/cpuset.c b/kernel/cpuset.c</span>
<span class="p_header">index 533494236c12..6dbc4bd416ec 100644</span>
<span class="p_header">--- a/kernel/cpuset.c</span>
<span class="p_header">+++ b/kernel/cpuset.c</span>
<span class="p_chunk">@@ -339,13 +339,14 @@</span> <span class="p_context"> static void cpuset_update_task_spread_flag(struct cpuset *cs,</span>
 					struct task_struct *tsk)
 {
 	if (is_spread_page(cs))
<span class="p_del">-		tsk-&gt;flags |= PF_SPREAD_PAGE;</span>
<span class="p_add">+		task_set_spread_page(tsk);</span>
 	else
<span class="p_del">-		tsk-&gt;flags &amp;= ~PF_SPREAD_PAGE;</span>
<span class="p_add">+		task_clear_spread_page(tsk);</span>
<span class="p_add">+</span>
 	if (is_spread_slab(cs))
<span class="p_del">-		tsk-&gt;flags |= PF_SPREAD_SLAB;</span>
<span class="p_add">+		task_set_spread_slab(tsk);</span>
 	else
<span class="p_del">-		tsk-&gt;flags &amp;= ~PF_SPREAD_SLAB;</span>
<span class="p_add">+		task_clear_spread_slab(tsk);</span>
 }
 
 /*
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index 847cf0d7428e..c1c6d24b5275 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -4755,9 +4755,6 @@</span> <span class="p_context"> static void perf_output_read_one(struct perf_output_handle *handle,</span>
 	__output_copy(handle, values, n * sizeof(u64));
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * XXX PERF_FORMAT_GROUP vs inherited events seems difficult.</span>
<span class="p_del">- */</span>
 static void perf_output_read_group(struct perf_output_handle *handle,
 			    struct perf_event *event,
 			    u64 enabled, u64 running)
<span class="p_chunk">@@ -4802,6 +4799,13 @@</span> <span class="p_context"> static void perf_output_read_group(struct perf_output_handle *handle,</span>
 #define PERF_FORMAT_TOTAL_TIMES (PERF_FORMAT_TOTAL_TIME_ENABLED|\
 				 PERF_FORMAT_TOTAL_TIME_RUNNING)
 
<span class="p_add">+/*</span>
<span class="p_add">+ * XXX PERF_SAMPLE_READ vs inherited events seems difficult.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The problem is that its both hard and excessively expensive to iterate the</span>
<span class="p_add">+ * child list, not to mention that its impossible to IPI the children running</span>
<span class="p_add">+ * on another CPU, from interrupt/NMI context.</span>
<span class="p_add">+ */</span>
 static void perf_output_read(struct perf_output_handle *handle,
 			     struct perf_event *event)
 {
<span class="p_chunk">@@ -7088,9 +7092,10 @@</span> <span class="p_context"> perf_event_alloc(struct perf_event_attr *attr, int cpu,</span>
 	local64_set(&amp;hwc-&gt;period_left, hwc-&gt;sample_period);
 
 	/*
<span class="p_del">-	 * we currently do not support PERF_FORMAT_GROUP on inherited events</span>
<span class="p_add">+	 * We currently do not support PERF_SAMPLE_READ on inherited events.</span>
<span class="p_add">+	 * See perf_output_read().</span>
 	 */
<span class="p_del">-	if (attr-&gt;inherit &amp;&amp; (attr-&gt;read_format &amp; PERF_FORMAT_GROUP))</span>
<span class="p_add">+	if (attr-&gt;inherit &amp;&amp; (attr-&gt;sample_type &amp; PERF_SAMPLE_READ))</span>
 		goto err_ns;
 
 	pmu = perf_init_event(event);
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 2fc44b2466f3..d6d34bbf921a 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -5298,6 +5298,7 @@</span> <span class="p_context"> early_initcall(migration_init);</span>
 #ifdef CONFIG_SMP
 
 static cpumask_var_t sched_domains_tmpmask; /* sched_domains_mutex */
<span class="p_add">+cpumask_var_t sched_domains_tmpmask2;</span>
 
 #ifdef CONFIG_SCHED_DEBUG
 
<span class="p_chunk">@@ -5775,21 +5776,39 @@</span> <span class="p_context"> enum s_alloc {</span>
  * and our sibling sd spans will be empty. Domains should always include the
  * cpu they&#39;re built on, so check that.
  *
<span class="p_add">+ * Only CPUs that can arrive at this group should be considered to continue</span>
<span class="p_add">+ * balancing.</span>
  */
<span class="p_del">-static void build_group_mask(struct sched_domain *sd, struct sched_group *sg)</span>
<span class="p_add">+static void</span>
<span class="p_add">+build_group_mask(struct sched_domain *sd, struct sched_group *sg, struct cpumask *mask)</span>
 {
 	const struct cpumask *span = sched_domain_span(sd);
 	struct sd_data *sdd = sd-&gt;private;
 	struct sched_domain *sibling;
 	int i;
 
<span class="p_add">+	cpumask_clear(mask);</span>
<span class="p_add">+</span>
 	for_each_cpu(i, span) {
 		sibling = *per_cpu_ptr(sdd-&gt;sd, i);
<span class="p_del">-		if (!cpumask_test_cpu(i, sched_domain_span(sibling)))</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Can happen in the asymmetric case, where these siblings are</span>
<span class="p_add">+		 * unused. The mask will not be empty because those CPUs that</span>
<span class="p_add">+		 * do have the top domain _should_ span the domain.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!sibling-&gt;child)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* If we would not end up here, we can&#39;t continue from here */</span>
<span class="p_add">+		if (!cpumask_equal(span, sched_domain_span(sibling-&gt;child)))</span>
 			continue;
 
<span class="p_del">-		cpumask_set_cpu(i, sched_group_mask(sg));</span>
<span class="p_add">+		cpumask_set_cpu(i, mask);</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	/* We must not have empty masks here */</span>
<span class="p_add">+	WARN_ON_ONCE(cpumask_empty(mask));</span>
 }
 
 /*
<span class="p_chunk">@@ -5801,6 +5820,52 @@</span> <span class="p_context"> int group_balance_cpu(struct sched_group *sg)</span>
 	return cpumask_first_and(sched_group_cpus(sg), sched_group_mask(sg));
 }
 
<span class="p_add">+static struct sched_group *</span>
<span class="p_add">+build_group_from_child_sched_domain(struct sched_domain *sd, int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sched_group *sg;</span>
<span class="p_add">+	struct cpumask *sg_span;</span>
<span class="p_add">+</span>
<span class="p_add">+	sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),</span>
<span class="p_add">+			GFP_KERNEL, cpu_to_node(cpu));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!sg)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	sg_span = sched_group_cpus(sg);</span>
<span class="p_add">+	if (sd-&gt;child)</span>
<span class="p_add">+		cpumask_copy(sg_span, sched_domain_span(sd-&gt;child));</span>
<span class="p_add">+	else</span>
<span class="p_add">+		cpumask_copy(sg_span, sched_domain_span(sd));</span>
<span class="p_add">+</span>
<span class="p_add">+	return sg;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void init_overlap_sched_group(struct sched_domain *sd,</span>
<span class="p_add">+				     struct sched_group *sg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cpumask *mask = sched_domains_tmpmask2;</span>
<span class="p_add">+	struct sd_data *sdd = sd-&gt;private;</span>
<span class="p_add">+	struct cpumask *sg_span;</span>
<span class="p_add">+	int cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	build_group_mask(sd, sg, mask);</span>
<span class="p_add">+	cpu = cpumask_first_and(sched_group_cpus(sg), mask);</span>
<span class="p_add">+</span>
<span class="p_add">+	sg-&gt;sgc = *per_cpu_ptr(sdd-&gt;sgc, cpu);</span>
<span class="p_add">+	if (atomic_inc_return(&amp;sg-&gt;sgc-&gt;ref) == 1)</span>
<span class="p_add">+		cpumask_copy(sched_group_mask(sg), mask);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Initialize sgc-&gt;capacity such that even if we mess up the</span>
<span class="p_add">+	 * domains and no possible iteration will get us here, we won&#39;t</span>
<span class="p_add">+	 * die on a /0 trap.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	sg_span = sched_group_cpus(sg);</span>
<span class="p_add">+	sg-&gt;sgc-&gt;capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sg_span);</span>
<span class="p_add">+	sg-&gt;sgc-&gt;capacity_orig = sg-&gt;sgc-&gt;capacity;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int
 build_overlap_sched_groups(struct sched_domain *sd, int cpu)
 {
<span class="p_chunk">@@ -5808,49 +5873,31 @@</span> <span class="p_context"> build_overlap_sched_groups(struct sched_domain *sd, int cpu)</span>
 	const struct cpumask *span = sched_domain_span(sd);
 	struct cpumask *covered = sched_domains_tmpmask;
 	struct sd_data *sdd = sd-&gt;private;
<span class="p_del">-	struct sched_domain *child;</span>
<span class="p_add">+	struct sched_domain *sibling;</span>
 	int i;
 
 	cpumask_clear(covered);
 
<span class="p_del">-	for_each_cpu(i, span) {</span>
<span class="p_add">+	for_each_cpu_wrap(i, span, cpu) {</span>
 		struct cpumask *sg_span;
 
 		if (cpumask_test_cpu(i, covered))
 			continue;
 
<span class="p_del">-		child = *per_cpu_ptr(sdd-&gt;sd, i);</span>
<span class="p_add">+		sibling = *per_cpu_ptr(sdd-&gt;sd, i);</span>
 
 		/* See the comment near build_group_mask(). */
<span class="p_del">-		if (!cpumask_test_cpu(i, sched_domain_span(child)))</span>
<span class="p_add">+		if (!cpumask_test_cpu(i, sched_domain_span(sibling)))</span>
 			continue;
 
<span class="p_del">-		sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),</span>
<span class="p_del">-				GFP_KERNEL, cpu_to_node(cpu));</span>
<span class="p_del">-</span>
<span class="p_add">+		sg = build_group_from_child_sched_domain(sibling, cpu);</span>
 		if (!sg)
 			goto fail;
 
 		sg_span = sched_group_cpus(sg);
<span class="p_del">-		if (child-&gt;child) {</span>
<span class="p_del">-			child = child-&gt;child;</span>
<span class="p_del">-			cpumask_copy(sg_span, sched_domain_span(child));</span>
<span class="p_del">-		} else</span>
<span class="p_del">-			cpumask_set_cpu(i, sg_span);</span>
<span class="p_del">-</span>
 		cpumask_or(covered, covered, sg_span);
 
<span class="p_del">-		sg-&gt;sgc = *per_cpu_ptr(sdd-&gt;sgc, i);</span>
<span class="p_del">-		if (atomic_inc_return(&amp;sg-&gt;sgc-&gt;ref) == 1)</span>
<span class="p_del">-			build_group_mask(sd, sg);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Initialize sgc-&gt;capacity such that even if we mess up the</span>
<span class="p_del">-		 * domains and no possible iteration will get us here, we won&#39;t</span>
<span class="p_del">-		 * die on a /0 trap.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		sg-&gt;sgc-&gt;capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sg_span);</span>
<span class="p_del">-		sg-&gt;sgc-&gt;capacity_orig = sg-&gt;sgc-&gt;capacity;</span>
<span class="p_add">+		init_overlap_sched_group(sd, sg);</span>
 
 		/*
 		 * Make sure the first group of this domain contains the
<span class="p_chunk">@@ -7109,6 +7156,7 @@</span> <span class="p_context"> void __init sched_init(void)</span>
 
 #ifdef CONFIG_SMP
 	zalloc_cpumask_var(&amp;sched_domains_tmpmask, GFP_NOWAIT);
<span class="p_add">+	zalloc_cpumask_var(&amp;sched_domains_tmpmask2, GFP_NOWAIT);</span>
 	/* May be allocated at isolcpus cmdline parse time */
 	if (cpu_isolated_map == NULL)
 		zalloc_cpumask_var(&amp;cpu_isolated_map, GFP_NOWAIT);
<span class="p_header">diff --git a/kernel/seccomp.c b/kernel/seccomp.c</span>
<span class="p_header">index 301bbc24739c..e2eb71b1e970 100644</span>
<span class="p_header">--- a/kernel/seccomp.c</span>
<span class="p_header">+++ b/kernel/seccomp.c</span>
<span class="p_chunk">@@ -224,7 +224,7 @@</span> <span class="p_context"> static long seccomp_attach_filter(struct sock_fprog *fprog)</span>
 	 * This avoids scenarios where unprivileged tasks can affect the
 	 * behavior of privileged children.
 	 */
<span class="p_del">-	if (!current-&gt;no_new_privs &amp;&amp;</span>
<span class="p_add">+	if (!task_no_new_privs(current) &amp;&amp;</span>
 	    security_capable_noaudit(current_cred(), current_user_ns(),
 				     CAP_SYS_ADMIN) != 0)
 		return -EACCES;
<span class="p_header">diff --git a/kernel/sys.c b/kernel/sys.c</span>
<span class="p_header">index 6fe6c5986c59..0cb192dc4a93 100644</span>
<span class="p_header">--- a/kernel/sys.c</span>
<span class="p_header">+++ b/kernel/sys.c</span>
<span class="p_chunk">@@ -1989,12 +1989,12 @@</span> <span class="p_context"> SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,</span>
 		if (arg2 != 1 || arg3 || arg4 || arg5)
 			return -EINVAL;
 
<span class="p_del">-		current-&gt;no_new_privs = 1;</span>
<span class="p_add">+		task_set_no_new_privs(current);</span>
 		break;
 	case PR_GET_NO_NEW_PRIVS:
 		if (arg2 || arg3 || arg4 || arg5)
 			return -EINVAL;
<span class="p_del">-		return current-&gt;no_new_privs ? 1 : 0;</span>
<span class="p_add">+		return task_no_new_privs(current) ? 1 : 0;</span>
 	case PR_GET_THP_DISABLE:
 		if (arg2 || arg3 || arg4 || arg5)
 			return -EINVAL;
<span class="p_header">diff --git a/lib/cpumask.c b/lib/cpumask.c</span>
<span class="p_header">index b6513a9f2892..78c13985a0a3 100644</span>
<span class="p_header">--- a/lib/cpumask.c</span>
<span class="p_header">+++ b/lib/cpumask.c</span>
<span class="p_chunk">@@ -63,6 +63,38 @@</span> <span class="p_context"> int cpumask_any_but(const struct cpumask *mask, unsigned int cpu)</span>
 	return i;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * cpumask_next_wrap - helper to implement for_each_cpu_wrap</span>
<span class="p_add">+ * @n: the cpu prior to the place to search</span>
<span class="p_add">+ * @mask: the cpumask pointer</span>
<span class="p_add">+ * @start: the start point of the iteration</span>
<span class="p_add">+ * @wrap: assume @n crossing @start terminates the iteration</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns &gt;= nr_cpu_ids on completion</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Note: the @wrap argument is required for the start condition when</span>
<span class="p_add">+ * we cannot assume @start is set in @mask.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int cpumask_next_wrap(int n, const struct cpumask *mask, int start, bool wrap)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int next;</span>
<span class="p_add">+</span>
<span class="p_add">+again:</span>
<span class="p_add">+	next = cpumask_next(n, mask);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (wrap &amp;&amp; n &lt; start &amp;&amp; next &gt;= start) {</span>
<span class="p_add">+		return nr_cpumask_bits;</span>
<span class="p_add">+</span>
<span class="p_add">+	} else if (next &gt;= nr_cpumask_bits) {</span>
<span class="p_add">+		wrap = true;</span>
<span class="p_add">+		n = -1;</span>
<span class="p_add">+		goto again;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return next;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(cpumask_next_wrap);</span>
<span class="p_add">+</span>
 /* These are not inline because of header tangles. */
 #ifdef CONFIG_CPUMASK_OFFSTACK
 /**
<span class="p_header">diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="p_header">index ea9698d1b865..e1bde862d6d3 100644</span>
<span class="p_header">--- a/mm/memory.c</span>
<span class="p_header">+++ b/mm/memory.c</span>
<span class="p_chunk">@@ -3274,8 +3274,18 @@</span> <span class="p_context"> static int __handle_mm_fault(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 	if (unlikely(pmd_none(*pmd)) &amp;&amp;
 	    unlikely(__pte_alloc(mm, vma, pmd, address)))
 		return VM_FAULT_OOM;
<span class="p_del">-	/* if an huge pmd materialized from under us just retry later */</span>
<span class="p_del">-	if (unlikely(pmd_trans_huge(*pmd)))</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If a huge pmd materialized under us just retry later.  Use</span>
<span class="p_add">+	 * pmd_trans_unstable() instead of pmd_trans_huge() to ensure the pmd</span>
<span class="p_add">+	 * didn&#39;t become pmd_trans_huge under us and then back to pmd_none, as</span>
<span class="p_add">+	 * a result of MADV_DONTNEED running immediately after a huge pmd fault</span>
<span class="p_add">+	 * in a different thread of this mm, in turn leading to a misleading</span>
<span class="p_add">+	 * pmd_trans_huge() retval.  All we have to ensure is that it is a</span>
<span class="p_add">+	 * regular pmd that we can walk with pte_offset_map() and we can do that</span>
<span class="p_add">+	 * through an atomic read in C, which is what pmd_trans_unstable()</span>
<span class="p_add">+	 * provides.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(pmd_trans_unstable(pmd)))</span>
 		return 0;
 	/*
 	 * A regular pmd is established and it can&#39;t morph into a huge pmd
<span class="p_header">diff --git a/mm/mmap.c b/mm/mmap.c</span>
<span class="p_header">index 03b34261aa08..44134131b8f1 100644</span>
<span class="p_header">--- a/mm/mmap.c</span>
<span class="p_header">+++ b/mm/mmap.c</span>
<span class="p_chunk">@@ -2141,7 +2141,7 @@</span> <span class="p_context"> int expand_upwards(struct vm_area_struct *vma, unsigned long address)</span>
 
 	/* Guard against exceeding limits of the address space. */
 	address &amp;= PAGE_MASK;
<span class="p_del">-	if (address &gt;= TASK_SIZE)</span>
<span class="p_add">+	if (address &gt;= (TASK_SIZE &amp; PAGE_MASK))</span>
 		return -ENOMEM;
 	address += PAGE_SIZE;
 
<span class="p_chunk">@@ -2153,7 +2153,8 @@</span> <span class="p_context"> int expand_upwards(struct vm_area_struct *vma, unsigned long address)</span>
 		gap_addr = TASK_SIZE;
 
 	next = vma-&gt;vm_next;
<span class="p_del">-	if (next &amp;&amp; next-&gt;vm_start &lt; gap_addr) {</span>
<span class="p_add">+	if (next &amp;&amp; next-&gt;vm_start &lt; gap_addr &amp;&amp;</span>
<span class="p_add">+			(next-&gt;vm_flags &amp; (VM_WRITE|VM_READ|VM_EXEC))) {</span>
 		if (!(next-&gt;vm_flags &amp; VM_GROWSUP))
 			return -ENOMEM;
 		/* Check that both stack segments have the same anon_vma? */
<span class="p_chunk">@@ -2233,7 +2234,8 @@</span> <span class="p_context"> int expand_downwards(struct vm_area_struct *vma,</span>
 	if (gap_addr &gt; address)
 		return -ENOMEM;
 	prev = vma-&gt;vm_prev;
<span class="p_del">-	if (prev &amp;&amp; prev-&gt;vm_end &gt; gap_addr) {</span>
<span class="p_add">+	if (prev &amp;&amp; prev-&gt;vm_end &gt; gap_addr &amp;&amp;</span>
<span class="p_add">+			(prev-&gt;vm_flags &amp; (VM_WRITE|VM_READ|VM_EXEC))) {</span>
 		if (!(prev-&gt;vm_flags &amp; VM_GROWSDOWN))
 			return -ENOMEM;
 		/* Check that both stack segments have the same anon_vma? */
<span class="p_header">diff --git a/mm/slab.c b/mm/slab.c</span>
<span class="p_header">index 084985404fec..a36735ae2366 100644</span>
<span class="p_header">--- a/mm/slab.c</span>
<span class="p_header">+++ b/mm/slab.c</span>
<span class="p_chunk">@@ -3112,7 +3112,7 @@</span> <span class="p_context"> static inline void *____cache_alloc(struct kmem_cache *cachep, gfp_t flags)</span>
 
 #ifdef CONFIG_NUMA
 /*
<span class="p_del">- * Try allocating on another node if PF_SPREAD_SLAB is a mempolicy is set.</span>
<span class="p_add">+ * Try allocating on another node if PFA_SPREAD_SLAB is a mempolicy is set.</span>
  *
  * If we are in_interrupt, then process context, including cpusets and
  * mempolicy, may not apply and should not be used for allocation policy.
<span class="p_chunk">@@ -3344,7 +3344,7 @@</span> <span class="p_context"> __do_cache_alloc(struct kmem_cache *cache, gfp_t flags)</span>
 {
 	void *objp;
 
<span class="p_del">-	if (current-&gt;mempolicy || unlikely(current-&gt;flags &amp; PF_SPREAD_SLAB)) {</span>
<span class="p_add">+	if (current-&gt;mempolicy || cpuset_do_slab_mem_spread()) {</span>
 		objp = alternate_node_alloc(cache, flags);
 		if (objp)
 			goto out;
<span class="p_header">diff --git a/mm/swap.c b/mm/swap.c</span>
<span class="p_header">index 9e8e3472248b..a4d58b5fc4be 100644</span>
<span class="p_header">--- a/mm/swap.c</span>
<span class="p_header">+++ b/mm/swap.c</span>
<span class="p_chunk">@@ -474,7 +474,7 @@</span> <span class="p_context"> void rotate_reclaimable_page(struct page *page)</span>
 		page_cache_get(page);
 		local_irq_save(flags);
 		pvec = this_cpu_ptr(&amp;lru_rotate_pvecs);
<span class="p_del">-		if (!pagevec_add(pvec, page))</span>
<span class="p_add">+		if (!pagevec_add(pvec, page) || PageCompound(page))</span>
 			pagevec_move_tail(pvec);
 		local_irq_restore(flags);
 	}
<span class="p_chunk">@@ -530,7 +530,7 @@</span> <span class="p_context"> void activate_page(struct page *page)</span>
 		struct pagevec *pvec = &amp;get_cpu_var(activate_page_pvecs);
 
 		page_cache_get(page);
<span class="p_del">-		if (!pagevec_add(pvec, page))</span>
<span class="p_add">+		if (!pagevec_add(pvec, page) || PageCompound(page))</span>
 			pagevec_lru_move_fn(pvec, __activate_page, NULL);
 		put_cpu_var(activate_page_pvecs);
 	}
<span class="p_chunk">@@ -630,9 +630,8 @@</span> <span class="p_context"> static void __lru_cache_add(struct page *page)</span>
 	struct pagevec *pvec = &amp;get_cpu_var(lru_add_pvec);
 
 	page_cache_get(page);
<span class="p_del">-	if (!pagevec_space(pvec))</span>
<span class="p_add">+	if (!pagevec_add(pvec, page) || PageCompound(page))</span>
 		__pagevec_lru_add(pvec);
<span class="p_del">-	pagevec_add(pvec, page);</span>
 	put_cpu_var(lru_add_pvec);
 }
 
<span class="p_chunk">@@ -811,7 +810,7 @@</span> <span class="p_context"> void deactivate_page(struct page *page)</span>
 	if (likely(get_page_unless_zero(page))) {
 		struct pagevec *pvec = &amp;get_cpu_var(lru_deactivate_pvecs);
 
<span class="p_del">-		if (!pagevec_add(pvec, page))</span>
<span class="p_add">+		if (!pagevec_add(pvec, page) || PageCompound(page))</span>
 			pagevec_lru_move_fn(pvec, lru_deactivate_fn, NULL);
 		put_cpu_var(lru_deactivate_pvecs);
 	}
<span class="p_header">diff --git a/net/bluetooth/l2cap_core.c b/net/bluetooth/l2cap_core.c</span>
<span class="p_header">index 84c0a21c1cda..0dbc437958ec 100644</span>
<span class="p_header">--- a/net/bluetooth/l2cap_core.c</span>
<span class="p_header">+++ b/net/bluetooth/l2cap_core.c</span>
<span class="p_chunk">@@ -59,7 +59,7 @@</span> <span class="p_context"> static struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,</span>
 				       u8 code, u8 ident, u16 dlen, void *data);
 static void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len,
 			   void *data);
<span class="p_del">-static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data);</span>
<span class="p_add">+static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data, size_t data_size);</span>
 static void l2cap_send_disconn_req(struct l2cap_chan *chan, int err);
 
 static void l2cap_tx(struct l2cap_chan *chan, struct l2cap_ctrl *control,
<span class="p_chunk">@@ -1401,7 +1401,7 @@</span> <span class="p_context"> static void l2cap_conn_start(struct l2cap_conn *conn)</span>
 
 			set_bit(CONF_REQ_SENT, &amp;chan-&gt;conf_state);
 			l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
<span class="p_del">-				       l2cap_build_conf_req(chan, buf), buf);</span>
<span class="p_add">+				       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);</span>
 			chan-&gt;num_conf_req++;
 		}
 
<span class="p_chunk">@@ -2978,12 +2978,15 @@</span> <span class="p_context"> static inline int l2cap_get_conf_opt(void **ptr, int *type, int *olen,</span>
 	return len;
 }
 
<span class="p_del">-static void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val)</span>
<span class="p_add">+static void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val, size_t size)</span>
 {
 	struct l2cap_conf_opt *opt = *ptr;
 
 	BT_DBG(&quot;type 0x%2.2x len %u val 0x%lx&quot;, type, len, val);
 
<span class="p_add">+	if (size &lt; L2CAP_CONF_OPT_SIZE + len)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	opt-&gt;type = type;
 	opt-&gt;len  = len;
 
<span class="p_chunk">@@ -3008,7 +3011,7 @@</span> <span class="p_context"> static void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val)</span>
 	*ptr += L2CAP_CONF_OPT_SIZE + len;
 }
 
<span class="p_del">-static void l2cap_add_opt_efs(void **ptr, struct l2cap_chan *chan)</span>
<span class="p_add">+static void l2cap_add_opt_efs(void **ptr, struct l2cap_chan *chan, size_t size)</span>
 {
 	struct l2cap_conf_efs efs;
 
<span class="p_chunk">@@ -3036,7 +3039,7 @@</span> <span class="p_context"> static void l2cap_add_opt_efs(void **ptr, struct l2cap_chan *chan)</span>
 	}
 
 	l2cap_add_conf_opt(ptr, L2CAP_CONF_EFS, sizeof(efs),
<span class="p_del">-			   (unsigned long) &amp;efs);</span>
<span class="p_add">+			   (unsigned long) &amp;efs, size);</span>
 }
 
 static void l2cap_ack_timeout(struct work_struct *work)
<span class="p_chunk">@@ -3180,11 +3183,12 @@</span> <span class="p_context"> static inline void l2cap_txwin_setup(struct l2cap_chan *chan)</span>
 	chan-&gt;ack_win = chan-&gt;tx_win;
 }
 
<span class="p_del">-static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
<span class="p_add">+static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data, size_t data_size)</span>
 {
 	struct l2cap_conf_req *req = data;
 	struct l2cap_conf_rfc rfc = { .mode = chan-&gt;mode };
 	void *ptr = req-&gt;data;
<span class="p_add">+	void *endptr = data + data_size;</span>
 	u16 size;
 
 	BT_DBG(&quot;chan %p&quot;, chan);
<span class="p_chunk">@@ -3209,7 +3213,7 @@</span> <span class="p_context"> static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
 
 done:
 	if (chan-&gt;imtu != L2CAP_DEFAULT_MTU)
<span class="p_del">-		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;imtu);</span>
<span class="p_add">+		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;imtu, endptr - ptr);</span>
 
 	switch (chan-&gt;mode) {
 	case L2CAP_MODE_BASIC:
<span class="p_chunk">@@ -3225,7 +3229,7 @@</span> <span class="p_context"> static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
 		rfc.max_pdu_size    = 0;
 
 		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC, sizeof(rfc),
<span class="p_del">-				   (unsigned long) &amp;rfc);</span>
<span class="p_add">+				   (unsigned long) &amp;rfc, endptr - ptr);</span>
 		break;
 
 	case L2CAP_MODE_ERTM:
<span class="p_chunk">@@ -3245,21 +3249,21 @@</span> <span class="p_context"> static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
 				       L2CAP_DEFAULT_TX_WINDOW);
 
 		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC, sizeof(rfc),
<span class="p_del">-				   (unsigned long) &amp;rfc);</span>
<span class="p_add">+				   (unsigned long) &amp;rfc, endptr - ptr);</span>
 
 		if (test_bit(FLAG_EFS_ENABLE, &amp;chan-&gt;flags))
<span class="p_del">-			l2cap_add_opt_efs(&amp;ptr, chan);</span>
<span class="p_add">+			l2cap_add_opt_efs(&amp;ptr, chan, endptr - ptr);</span>
 
 		if (test_bit(FLAG_EXT_CTRL, &amp;chan-&gt;flags))
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_EWS, 2,
<span class="p_del">-					   chan-&gt;tx_win);</span>
<span class="p_add">+					   chan-&gt;tx_win, endptr - ptr);</span>
 
 		if (chan-&gt;conn-&gt;feat_mask &amp; L2CAP_FEAT_FCS)
 			if (chan-&gt;fcs == L2CAP_FCS_NONE ||
 			    test_bit(CONF_RECV_NO_FCS, &amp;chan-&gt;conf_state)) {
 				chan-&gt;fcs = L2CAP_FCS_NONE;
 				l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_FCS, 1,
<span class="p_del">-						   chan-&gt;fcs);</span>
<span class="p_add">+						   chan-&gt;fcs, endptr - ptr);</span>
 			}
 		break;
 
<span class="p_chunk">@@ -3277,17 +3281,17 @@</span> <span class="p_context"> static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
 		rfc.max_pdu_size = cpu_to_le16(size);
 
 		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC, sizeof(rfc),
<span class="p_del">-				   (unsigned long) &amp;rfc);</span>
<span class="p_add">+				   (unsigned long) &amp;rfc, endptr - ptr);</span>
 
 		if (test_bit(FLAG_EFS_ENABLE, &amp;chan-&gt;flags))
<span class="p_del">-			l2cap_add_opt_efs(&amp;ptr, chan);</span>
<span class="p_add">+			l2cap_add_opt_efs(&amp;ptr, chan, endptr - ptr);</span>
 
 		if (chan-&gt;conn-&gt;feat_mask &amp; L2CAP_FEAT_FCS)
 			if (chan-&gt;fcs == L2CAP_FCS_NONE ||
 			    test_bit(CONF_RECV_NO_FCS, &amp;chan-&gt;conf_state)) {
 				chan-&gt;fcs = L2CAP_FCS_NONE;
 				l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_FCS, 1,
<span class="p_del">-						   chan-&gt;fcs);</span>
<span class="p_add">+						   chan-&gt;fcs, endptr - ptr);</span>
 			}
 		break;
 	}
<span class="p_chunk">@@ -3298,10 +3302,11 @@</span> <span class="p_context"> static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
 	return ptr - data;
 }
 
<span class="p_del">-static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
<span class="p_add">+static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data, size_t data_size)</span>
 {
 	struct l2cap_conf_rsp *rsp = data;
 	void *ptr = rsp-&gt;data;
<span class="p_add">+	void *endptr = data + data_size;</span>
 	void *req = chan-&gt;conf_req;
 	int len = chan-&gt;conf_len;
 	int type, hint, olen;
<span class="p_chunk">@@ -3403,7 +3408,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 			return -ECONNREFUSED;
 
 		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC, sizeof(rfc),
<span class="p_del">-				   (unsigned long) &amp;rfc);</span>
<span class="p_add">+				   (unsigned long) &amp;rfc, endptr - ptr);</span>
 	}
 
 	if (result == L2CAP_CONF_SUCCESS) {
<span class="p_chunk">@@ -3416,7 +3421,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 			chan-&gt;omtu = mtu;
 			set_bit(CONF_MTU_DONE, &amp;chan-&gt;conf_state);
 		}
<span class="p_del">-		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;omtu);</span>
<span class="p_add">+		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;omtu, endptr - ptr);</span>
 
 		if (remote_efs) {
 			if (chan-&gt;local_stype != L2CAP_SERV_NOTRAFIC &amp;&amp;
<span class="p_chunk">@@ -3430,7 +3435,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 
 				l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_EFS,
 						   sizeof(efs),
<span class="p_del">-						   (unsigned long) &amp;efs);</span>
<span class="p_add">+						   (unsigned long) &amp;efs, endptr - ptr);</span>
 			} else {
 				/* Send PENDING Conf Rsp */
 				result = L2CAP_CONF_PENDING;
<span class="p_chunk">@@ -3463,7 +3468,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 			set_bit(CONF_MODE_DONE, &amp;chan-&gt;conf_state);
 
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC,
<span class="p_del">-					   sizeof(rfc), (unsigned long) &amp;rfc);</span>
<span class="p_add">+					   sizeof(rfc), (unsigned long) &amp;rfc, endptr - ptr);</span>
 
 			if (test_bit(FLAG_EFS_ENABLE, &amp;chan-&gt;flags)) {
 				chan-&gt;remote_id = efs.id;
<span class="p_chunk">@@ -3477,7 +3482,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 					le32_to_cpu(efs.sdu_itime);
 				l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_EFS,
 						   sizeof(efs),
<span class="p_del">-						   (unsigned long) &amp;efs);</span>
<span class="p_add">+						   (unsigned long) &amp;efs, endptr - ptr);</span>
 			}
 			break;
 
<span class="p_chunk">@@ -3491,7 +3496,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 			set_bit(CONF_MODE_DONE, &amp;chan-&gt;conf_state);
 
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC, sizeof(rfc),
<span class="p_del">-					   (unsigned long) &amp;rfc);</span>
<span class="p_add">+					   (unsigned long) &amp;rfc, endptr - ptr);</span>
 
 			break;
 
<span class="p_chunk">@@ -3513,10 +3518,11 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 }
 
 static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,
<span class="p_del">-				void *data, u16 *result)</span>
<span class="p_add">+				void *data, size_t size, u16 *result)</span>
 {
 	struct l2cap_conf_req *req = data;
 	void *ptr = req-&gt;data;
<span class="p_add">+	void *endptr = data + size;</span>
 	int type, olen;
 	unsigned long val;
 	struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };
<span class="p_chunk">@@ -3534,13 +3540,13 @@</span> <span class="p_context"> static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,</span>
 				chan-&gt;imtu = L2CAP_DEFAULT_MIN_MTU;
 			} else
 				chan-&gt;imtu = val;
<span class="p_del">-			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;imtu);</span>
<span class="p_add">+			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;imtu, endptr - ptr);</span>
 			break;
 
 		case L2CAP_CONF_FLUSH_TO:
 			chan-&gt;flush_to = val;
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_FLUSH_TO,
<span class="p_del">-					   2, chan-&gt;flush_to);</span>
<span class="p_add">+					   2, chan-&gt;flush_to, endptr - ptr);</span>
 			break;
 
 		case L2CAP_CONF_RFC:
<span class="p_chunk">@@ -3554,13 +3560,13 @@</span> <span class="p_context"> static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,</span>
 			chan-&gt;fcs = 0;
 
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC,
<span class="p_del">-					   sizeof(rfc), (unsigned long) &amp;rfc);</span>
<span class="p_add">+					   sizeof(rfc), (unsigned long) &amp;rfc, endptr - ptr);</span>
 			break;
 
 		case L2CAP_CONF_EWS:
 			chan-&gt;ack_win = min_t(u16, val, chan-&gt;ack_win);
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_EWS, 2,
<span class="p_del">-					   chan-&gt;tx_win);</span>
<span class="p_add">+					   chan-&gt;tx_win, endptr - ptr);</span>
 			break;
 
 		case L2CAP_CONF_EFS:
<span class="p_chunk">@@ -3573,7 +3579,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,</span>
 				return -ECONNREFUSED;
 
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_EFS, sizeof(efs),
<span class="p_del">-					   (unsigned long) &amp;efs);</span>
<span class="p_add">+					   (unsigned long) &amp;efs, endptr - ptr);</span>
 			break;
 
 		case L2CAP_CONF_FCS:
<span class="p_chunk">@@ -3678,7 +3684,7 @@</span> <span class="p_context"> void __l2cap_connect_rsp_defer(struct l2cap_chan *chan)</span>
 		return;
 
 	l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
<span class="p_del">-		       l2cap_build_conf_req(chan, buf), buf);</span>
<span class="p_add">+		       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);</span>
 	chan-&gt;num_conf_req++;
 }
 
<span class="p_chunk">@@ -3885,7 +3891,7 @@</span> <span class="p_context"> static struct l2cap_chan *l2cap_connect(struct l2cap_conn *conn,</span>
 		u8 buf[128];
 		set_bit(CONF_REQ_SENT, &amp;chan-&gt;conf_state);
 		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
<span class="p_del">-			       l2cap_build_conf_req(chan, buf), buf);</span>
<span class="p_add">+			       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);</span>
 		chan-&gt;num_conf_req++;
 	}
 
<span class="p_chunk">@@ -3965,7 +3971,7 @@</span> <span class="p_context"> static int l2cap_connect_create_rsp(struct l2cap_conn *conn,</span>
 			break;
 
 		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
<span class="p_del">-			       l2cap_build_conf_req(chan, req), req);</span>
<span class="p_add">+			       l2cap_build_conf_req(chan, req, sizeof(req)), req);</span>
 		chan-&gt;num_conf_req++;
 		break;
 
<span class="p_chunk">@@ -4077,7 +4083,7 @@</span> <span class="p_context"> static inline int l2cap_config_req(struct l2cap_conn *conn,</span>
 	}
 
 	/* Complete config. */
<span class="p_del">-	len = l2cap_parse_conf_req(chan, rsp);</span>
<span class="p_add">+	len = l2cap_parse_conf_req(chan, rsp, sizeof(rsp));</span>
 	if (len &lt; 0) {
 		l2cap_send_disconn_req(chan, ECONNRESET);
 		goto unlock;
<span class="p_chunk">@@ -4111,7 +4117,7 @@</span> <span class="p_context"> static inline int l2cap_config_req(struct l2cap_conn *conn,</span>
 	if (!test_and_set_bit(CONF_REQ_SENT, &amp;chan-&gt;conf_state)) {
 		u8 buf[64];
 		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
<span class="p_del">-			       l2cap_build_conf_req(chan, buf), buf);</span>
<span class="p_add">+			       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);</span>
 		chan-&gt;num_conf_req++;
 	}
 
<span class="p_chunk">@@ -4171,7 +4177,7 @@</span> <span class="p_context"> static inline int l2cap_config_rsp(struct l2cap_conn *conn,</span>
 			char buf[64];
 
 			len = l2cap_parse_conf_rsp(chan, rsp-&gt;data, len,
<span class="p_del">-						   buf, &amp;result);</span>
<span class="p_add">+						   buf, sizeof(buf), &amp;result);</span>
 			if (len &lt; 0) {
 				l2cap_send_disconn_req(chan, ECONNRESET);
 				goto done;
<span class="p_chunk">@@ -4201,7 +4207,7 @@</span> <span class="p_context"> static inline int l2cap_config_rsp(struct l2cap_conn *conn,</span>
 			/* throw out any old stored conf requests */
 			result = L2CAP_CONF_SUCCESS;
 			len = l2cap_parse_conf_rsp(chan, rsp-&gt;data, len,
<span class="p_del">-						   req, &amp;result);</span>
<span class="p_add">+						   req, sizeof(req), &amp;result);</span>
 			if (len &lt; 0) {
 				l2cap_send_disconn_req(chan, ECONNRESET);
 				goto done;
<span class="p_chunk">@@ -4782,7 +4788,7 @@</span> <span class="p_context"> static void l2cap_do_create(struct l2cap_chan *chan, int result,</span>
 			set_bit(CONF_REQ_SENT, &amp;chan-&gt;conf_state);
 			l2cap_send_cmd(chan-&gt;conn, l2cap_get_ident(chan-&gt;conn),
 				       L2CAP_CONF_REQ,
<span class="p_del">-				       l2cap_build_conf_req(chan, buf), buf);</span>
<span class="p_add">+				       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);</span>
 			chan-&gt;num_conf_req++;
 		}
 	}
<span class="p_chunk">@@ -7361,7 +7367,7 @@</span> <span class="p_context"> int l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt)</span>
 				set_bit(CONF_REQ_SENT, &amp;chan-&gt;conf_state);
 				l2cap_send_cmd(conn, l2cap_get_ident(conn),
 					       L2CAP_CONF_REQ,
<span class="p_del">-					       l2cap_build_conf_req(chan, buf),</span>
<span class="p_add">+					       l2cap_build_conf_req(chan, buf, sizeof(buf)),</span>
 					       buf);
 				chan-&gt;num_conf_req++;
 			}
<span class="p_header">diff --git a/net/bluetooth/smp.c b/net/bluetooth/smp.c</span>
<span class="p_header">index 7b7f3de79db9..b7b6d387ef5d 100644</span>
<span class="p_header">--- a/net/bluetooth/smp.c</span>
<span class="p_header">+++ b/net/bluetooth/smp.c</span>
<span class="p_chunk">@@ -22,6 +22,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/crypto.h&gt;
 #include &lt;linux/scatterlist.h&gt;
<span class="p_add">+#include &lt;crypto/algapi.h&gt;</span>
 #include &lt;crypto/b128ops.h&gt;
 
 #include &lt;net/bluetooth/bluetooth.h&gt;
<span class="p_chunk">@@ -153,7 +154,7 @@</span> <span class="p_context"> bool smp_irk_matches(struct crypto_blkcipher *tfm, u8 irk[16],</span>
 	if (err)
 		return false;
 
<span class="p_del">-	return !memcmp(bdaddr-&gt;b, hash, 3);</span>
<span class="p_add">+	return !crypto_memneq(bdaddr-&gt;b, hash, 3);</span>
 }
 
 int smp_generate_rpa(struct crypto_blkcipher *tfm, u8 irk[16], bdaddr_t *rpa)
<span class="p_chunk">@@ -533,7 +534,7 @@</span> <span class="p_context"> static u8 smp_random(struct smp_chan *smp)</span>
 	if (ret)
 		return SMP_UNSPECIFIED;
 
<span class="p_del">-	if (memcmp(smp-&gt;pcnf, confirm, sizeof(smp-&gt;pcnf)) != 0) {</span>
<span class="p_add">+	if (crypto_memneq(smp-&gt;pcnf, confirm, sizeof(smp-&gt;pcnf))) {</span>
 		BT_ERR(&quot;Pairing failed (confirmation values mismatch)&quot;);
 		return SMP_CONFIRM_FAILED;
 	}
<span class="p_header">diff --git a/net/ipv4/fib_frontend.c b/net/ipv4/fib_frontend.c</span>
<span class="p_header">index 7d736cd3ee91..c232ededeaa2 100644</span>
<span class="p_header">--- a/net/ipv4/fib_frontend.c</span>
<span class="p_header">+++ b/net/ipv4/fib_frontend.c</span>
<span class="p_chunk">@@ -797,7 +797,11 @@</span> <span class="p_context"> void fib_del_ifaddr(struct in_ifaddr *ifa, struct in_ifaddr *iprim)</span>
 	if (ifa-&gt;ifa_flags &amp; IFA_F_SECONDARY) {
 		prim = inet_ifa_byprefix(in_dev, any, ifa-&gt;ifa_mask);
 		if (prim == NULL) {
<span class="p_del">-			pr_warn(&quot;%s: bug: prim == NULL\n&quot;, __func__);</span>
<span class="p_add">+			/* if the device has been deleted, we don&#39;t perform</span>
<span class="p_add">+			 * address promotion</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (!in_dev-&gt;dead)</span>
<span class="p_add">+				pr_warn(&quot;%s: bug: prim == NULL\n&quot;, __func__);</span>
 			return;
 		}
 		if (iprim &amp;&amp; iprim != prim) {
<span class="p_header">diff --git a/net/ipv4/fib_semantics.c b/net/ipv4/fib_semantics.c</span>
<span class="p_header">index 4a74ea85518f..b77a181cd450 100644</span>
<span class="p_header">--- a/net/ipv4/fib_semantics.c</span>
<span class="p_header">+++ b/net/ipv4/fib_semantics.c</span>
<span class="p_chunk">@@ -862,6 +862,8 @@</span> <span class="p_context"> struct fib_info *fib_create_info(struct fib_config *cfg)</span>
 					val = 65535 - 40;
 				if (type == RTAX_MTU &amp;&amp; val &gt; 65535 - 15)
 					val = 65535 - 15;
<span class="p_add">+				if (type == RTAX_HOPLIMIT &amp;&amp; val &gt; 255)</span>
<span class="p_add">+					val = 255;</span>
 				fi-&gt;fib_metrics[type - 1] = val;
 			}
 		}
<span class="p_header">diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c</span>
<span class="p_header">index 3cb23fb85a4a..6561c103e216 100644</span>
<span class="p_header">--- a/net/ipv4/ip_output.c</span>
<span class="p_header">+++ b/net/ipv4/ip_output.c</span>
<span class="p_chunk">@@ -158,7 +158,8 @@</span> <span class="p_context"> int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,</span>
 	}
 
 	skb-&gt;priority = sk-&gt;sk_priority;
<span class="p_del">-	skb-&gt;mark = sk-&gt;sk_mark;</span>
<span class="p_add">+	if (!skb-&gt;mark)</span>
<span class="p_add">+		skb-&gt;mark = sk-&gt;sk_mark;</span>
 
 	/* Send it out. */
 	return ip_local_out(skb);
<span class="p_header">diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c</span>
<span class="p_header">index f8ee2fc404cd..6ad29aa904bf 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_output.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_output.c</span>
<span class="p_chunk">@@ -2863,6 +2863,7 @@</span> <span class="p_context"> struct sk_buff *tcp_make_synack(struct sock *sk, struct dst_entry *dst,</span>
 	TCP_ECN_make_synack(req, th);
 	th-&gt;source = htons(ireq-&gt;ir_num);
 	th-&gt;dest = ireq-&gt;ir_rmt_port;
<span class="p_add">+	skb-&gt;mark = ireq-&gt;ir_mark;</span>
 	/* Setting of flags are superfluous here for callers (and ECE is
 	 * not even correctly set)
 	 */
<span class="p_header">diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c</span>
<span class="p_header">index d5fe33752ca6..9f48905cac9c 100644</span>
<span class="p_header">--- a/net/ipv6/addrconf.c</span>
<span class="p_header">+++ b/net/ipv6/addrconf.c</span>
<span class="p_chunk">@@ -1610,17 +1610,10 @@</span> <span class="p_context"> struct inet6_ifaddr *ipv6_get_ifaddr(struct net *net, const struct in6_addr *add</span>
 
 static void addrconf_dad_stop(struct inet6_ifaddr *ifp, int dad_failed)
 {
<span class="p_del">-	if (ifp-&gt;flags&amp;IFA_F_PERMANENT) {</span>
<span class="p_del">-		spin_lock_bh(&amp;ifp-&gt;lock);</span>
<span class="p_del">-		addrconf_del_dad_work(ifp);</span>
<span class="p_del">-		ifp-&gt;flags |= IFA_F_TENTATIVE;</span>
<span class="p_del">-		if (dad_failed)</span>
<span class="p_del">-			ifp-&gt;flags |= IFA_F_DADFAILED;</span>
<span class="p_del">-		spin_unlock_bh(&amp;ifp-&gt;lock);</span>
<span class="p_del">-		if (dad_failed)</span>
<span class="p_del">-			ipv6_ifa_notify(0, ifp);</span>
<span class="p_del">-		in6_ifa_put(ifp);</span>
<span class="p_del">-	} else if (ifp-&gt;flags&amp;IFA_F_TEMPORARY) {</span>
<span class="p_add">+	if (dad_failed)</span>
<span class="p_add">+		ifp-&gt;flags |= IFA_F_DADFAILED;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ifp-&gt;flags&amp;IFA_F_TEMPORARY) {</span>
 		struct inet6_ifaddr *ifpub;
 		spin_lock_bh(&amp;ifp-&gt;lock);
 		ifpub = ifp-&gt;ifpub;
<span class="p_chunk">@@ -1633,6 +1626,14 @@</span> <span class="p_context"> static void addrconf_dad_stop(struct inet6_ifaddr *ifp, int dad_failed)</span>
 			spin_unlock_bh(&amp;ifp-&gt;lock);
 		}
 		ipv6_del_addr(ifp);
<span class="p_add">+	} else if (ifp-&gt;flags&amp;IFA_F_PERMANENT || !dad_failed) {</span>
<span class="p_add">+		spin_lock_bh(&amp;ifp-&gt;lock);</span>
<span class="p_add">+		addrconf_del_dad_work(ifp);</span>
<span class="p_add">+		ifp-&gt;flags |= IFA_F_TENTATIVE;</span>
<span class="p_add">+		spin_unlock_bh(&amp;ifp-&gt;lock);</span>
<span class="p_add">+		if (dad_failed)</span>
<span class="p_add">+			ipv6_ifa_notify(0, ifp);</span>
<span class="p_add">+		in6_ifa_put(ifp);</span>
 	} else {
 		ipv6_del_addr(ifp);
 	}
<span class="p_header">diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c</span>
<span class="p_header">index f5e99a85bf92..36aadaeb7f44 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_fib.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_fib.c</span>
<span class="p_chunk">@@ -653,10 +653,14 @@</span> <span class="p_context"> static int fib6_commit_metrics(struct dst_entry *dst,</span>
 		int type = nla_type(nla);
 
 		if (type) {
<span class="p_add">+			u32 val = nla_get_u32(nla);</span>
<span class="p_add">+</span>
 			if (type &gt; RTAX_MAX)
 				return -EINVAL;
 
<span class="p_del">-			mp[type - 1] = nla_get_u32(nla);</span>
<span class="p_add">+			if (type == RTAX_HOPLIMIT &amp;&amp; val &gt; 255)</span>
<span class="p_add">+				val = 255;</span>
<span class="p_add">+			mp[type - 1] = val;</span>
 		}
 	}
 	return 0;
<span class="p_header">diff --git a/net/iucv/af_iucv.c b/net/iucv/af_iucv.c</span>
<span class="p_header">index f521848e26c7..086049f5abd3 100644</span>
<span class="p_header">--- a/net/iucv/af_iucv.c</span>
<span class="p_header">+++ b/net/iucv/af_iucv.c</span>
<span class="p_chunk">@@ -706,10 +706,8 @@</span> <span class="p_context"> static int iucv_sock_bind(struct socket *sock, struct sockaddr *addr,</span>
 	char uid[9];
 
 	/* Verify the input sockaddr */
<span class="p_del">-	if (!addr || addr-&gt;sa_family != AF_IUCV)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (addr_len &lt; sizeof(struct sockaddr_iucv))</span>
<span class="p_add">+	if (addr_len &lt; sizeof(struct sockaddr_iucv) ||</span>
<span class="p_add">+	    addr-&gt;sa_family != AF_IUCV)</span>
 		return -EINVAL;
 
 	lock_sock(sk);
<span class="p_chunk">@@ -853,7 +851,7 @@</span> <span class="p_context"> static int iucv_sock_connect(struct socket *sock, struct sockaddr *addr,</span>
 	struct iucv_sock *iucv = iucv_sk(sk);
 	int err;
 
<span class="p_del">-	if (addr-&gt;sa_family != AF_IUCV || alen &lt; sizeof(struct sockaddr_iucv))</span>
<span class="p_add">+	if (alen &lt; sizeof(struct sockaddr_iucv) || addr-&gt;sa_family != AF_IUCV)</span>
 		return -EINVAL;
 
 	if (sk-&gt;sk_state != IUCV_OPEN &amp;&amp; sk-&gt;sk_state != IUCV_BOUND)
<span class="p_header">diff --git a/net/l2tp/l2tp_ip.c b/net/l2tp/l2tp_ip.c</span>
<span class="p_header">index 1ecc71ce8cae..d30f5c03d72f 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ip.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ip.c</span>
<span class="p_chunk">@@ -390,7 +390,7 @@</span> <span class="p_context"> static int l2tp_ip_backlog_recv(struct sock *sk, struct sk_buff *skb)</span>
 drop:
 	IP_INC_STATS(sock_net(sk), IPSTATS_MIB_INDISCARDS);
 	kfree_skb(skb);
<span class="p_del">-	return -1;</span>
<span class="p_add">+	return 0;</span>
 }
 
 /* Userspace will call sendmsg() on the tunnel socket to send L2TP
<span class="p_header">diff --git a/net/nfc/core.c b/net/nfc/core.c</span>
<span class="p_header">index 819b87702b70..2ff3c924b64f 100644</span>
<span class="p_header">--- a/net/nfc/core.c</span>
<span class="p_header">+++ b/net/nfc/core.c</span>
<span class="p_chunk">@@ -950,6 +950,8 @@</span> <span class="p_context"> static void nfc_release(struct device *d)</span>
 			kfree(se);
 	}
 
<span class="p_add">+	ida_simple_remove(&amp;nfc_index_ida, dev-&gt;idx);</span>
<span class="p_add">+</span>
 	kfree(dev);
 }
 
<span class="p_chunk">@@ -1024,6 +1026,7 @@</span> <span class="p_context"> struct nfc_dev *nfc_allocate_device(struct nfc_ops *ops,</span>
 				    int tx_headroom, int tx_tailroom)
 {
 	struct nfc_dev *dev;
<span class="p_add">+	int rc;</span>
 
 	if (!ops-&gt;start_poll || !ops-&gt;stop_poll || !ops-&gt;activate_target ||
 	    !ops-&gt;deactivate_target || !ops-&gt;im_transceive)
<span class="p_chunk">@@ -1036,6 +1039,15 @@</span> <span class="p_context"> struct nfc_dev *nfc_allocate_device(struct nfc_ops *ops,</span>
 	if (!dev)
 		return NULL;
 
<span class="p_add">+	rc = ida_simple_get(&amp;nfc_index_ida, 0, 0, GFP_KERNEL);</span>
<span class="p_add">+	if (rc &lt; 0)</span>
<span class="p_add">+		goto err_free_dev;</span>
<span class="p_add">+	dev-&gt;idx = rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev-&gt;dev.class = &amp;nfc_class;</span>
<span class="p_add">+	dev_set_name(&amp;dev-&gt;dev, &quot;nfc%d&quot;, dev-&gt;idx);</span>
<span class="p_add">+	device_initialize(&amp;dev-&gt;dev);</span>
<span class="p_add">+</span>
 	dev-&gt;ops = ops;
 	dev-&gt;supported_protocols = supported_protocols;
 	dev-&gt;tx_headroom = tx_headroom;
<span class="p_chunk">@@ -1058,6 +1070,11 @@</span> <span class="p_context"> struct nfc_dev *nfc_allocate_device(struct nfc_ops *ops,</span>
 	}
 
 	return dev;
<span class="p_add">+</span>
<span class="p_add">+err_free_dev:</span>
<span class="p_add">+	kfree(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ERR_PTR(rc);</span>
 }
 EXPORT_SYMBOL(nfc_allocate_device);
 
<span class="p_chunk">@@ -1072,14 +1089,6 @@</span> <span class="p_context"> int nfc_register_device(struct nfc_dev *dev)</span>
 
 	pr_debug(&quot;dev_name=%s\n&quot;, dev_name(&amp;dev-&gt;dev));
 
<span class="p_del">-	dev-&gt;idx = ida_simple_get(&amp;nfc_index_ida, 0, 0, GFP_KERNEL);</span>
<span class="p_del">-	if (dev-&gt;idx &lt; 0)</span>
<span class="p_del">-		return dev-&gt;idx;</span>
<span class="p_del">-</span>
<span class="p_del">-	dev-&gt;dev.class = &amp;nfc_class;</span>
<span class="p_del">-	dev_set_name(&amp;dev-&gt;dev, &quot;nfc%d&quot;, dev-&gt;idx);</span>
<span class="p_del">-	device_initialize(&amp;dev-&gt;dev);</span>
<span class="p_del">-</span>
 	mutex_lock(&amp;nfc_devlist_mutex);
 	nfc_devlist_generation++;
 	rc = device_add(&amp;dev-&gt;dev);
<span class="p_chunk">@@ -1117,12 +1126,10 @@</span> <span class="p_context"> EXPORT_SYMBOL(nfc_register_device);</span>
  */
 void nfc_unregister_device(struct nfc_dev *dev)
 {
<span class="p_del">-	int rc, id;</span>
<span class="p_add">+	int rc;</span>
 
 	pr_debug(&quot;dev_name=%s\n&quot;, dev_name(&amp;dev-&gt;dev));
 
<span class="p_del">-	id = dev-&gt;idx;</span>
<span class="p_del">-</span>
 	if (dev-&gt;rfkill) {
 		rfkill_unregister(dev-&gt;rfkill);
 		rfkill_destroy(dev-&gt;rfkill);
<span class="p_chunk">@@ -1147,8 +1154,6 @@</span> <span class="p_context"> void nfc_unregister_device(struct nfc_dev *dev)</span>
 	nfc_devlist_generation++;
 	device_del(&amp;dev-&gt;dev);
 	mutex_unlock(&amp;nfc_devlist_mutex);
<span class="p_del">-</span>
<span class="p_del">-	ida_simple_remove(&amp;nfc_index_ida, id);</span>
 }
 EXPORT_SYMBOL(nfc_unregister_device);
 
<span class="p_header">diff --git a/net/sched/cls_api.c b/net/sched/cls_api.c</span>
<span class="p_header">index 7e4e15075c81..4878016ecc9c 100644</span>
<span class="p_header">--- a/net/sched/cls_api.c</span>
<span class="p_header">+++ b/net/sched/cls_api.c</span>
<span class="p_chunk">@@ -309,7 +309,8 @@</span> <span class="p_context"> static int tc_ctl_tfilter(struct sk_buff *skb, struct nlmsghdr *n)</span>
 		case RTM_DELTFILTER:
 			err = tp-&gt;ops-&gt;delete(tp, fh);
 			if (err == 0)
<span class="p_del">-				tfilter_notify(net, skb, n, tp, fh, RTM_DELTFILTER);</span>
<span class="p_add">+				tfilter_notify(net, skb, n, tp,</span>
<span class="p_add">+					       t-&gt;tcm_handle, RTM_DELTFILTER);</span>
 			goto errout;
 		case RTM_GETTFILTER:
 			err = tfilter_notify(net, skb, n, tp, fh, RTM_NEWTFILTER);
<span class="p_header">diff --git a/net/sunrpc/auth_gss/gss_krb5_crypto.c b/net/sunrpc/auth_gss/gss_krb5_crypto.c</span>
<span class="p_header">index 0f43e894bc0a..4ff1a3486937 100644</span>
<span class="p_header">--- a/net/sunrpc/auth_gss/gss_krb5_crypto.c</span>
<span class="p_header">+++ b/net/sunrpc/auth_gss/gss_krb5_crypto.c</span>
<span class="p_chunk">@@ -34,6 +34,7 @@</span> <span class="p_context"></span>
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
<span class="p_add">+#include &lt;crypto/algapi.h&gt;</span>
 #include &lt;linux/err.h&gt;
 #include &lt;linux/types.h&gt;
 #include &lt;linux/mm.h&gt;
<span class="p_chunk">@@ -838,7 +839,7 @@</span> <span class="p_context"> gss_krb5_aes_decrypt(struct krb5_ctx *kctx, u32 offset, struct xdr_buf *buf,</span>
 	if (ret)
 		goto out_err;
 
<span class="p_del">-	if (memcmp(pkt_hmac, our_hmac, kctx-&gt;gk5e-&gt;cksumlength) != 0) {</span>
<span class="p_add">+	if (crypto_memneq(pkt_hmac, our_hmac, kctx-&gt;gk5e-&gt;cksumlength) != 0) {</span>
 		ret = GSS_S_BAD_SIG;
 		goto out_err;
 	}
<span class="p_header">diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c</span>
<span class="p_header">index ec05ad8ade21..6fd21cab5ada 100644</span>
<span class="p_header">--- a/net/wireless/nl80211.c</span>
<span class="p_header">+++ b/net/wireless/nl80211.c</span>
<span class="p_chunk">@@ -299,8 +299,7 @@</span> <span class="p_context"> static const struct nla_policy nl80211_policy[NL80211_ATTR_MAX+1] = {</span>
 	[NL80211_ATTR_WPA_VERSIONS] = { .type = NLA_U32 },
 	[NL80211_ATTR_PID] = { .type = NLA_U32 },
 	[NL80211_ATTR_4ADDR] = { .type = NLA_U8 },
<span class="p_del">-	[NL80211_ATTR_PMKID] = { .type = NLA_BINARY,</span>
<span class="p_del">-				 .len = WLAN_PMKID_LEN },</span>
<span class="p_add">+	[NL80211_ATTR_PMKID] = { .len = WLAN_PMKID_LEN },</span>
 	[NL80211_ATTR_DURATION] = { .type = NLA_U32 },
 	[NL80211_ATTR_COOKIE] = { .type = NLA_U64 },
 	[NL80211_ATTR_TX_RATES] = { .type = NLA_NESTED },
<span class="p_chunk">@@ -355,6 +354,7 @@</span> <span class="p_context"> static const struct nla_policy nl80211_policy[NL80211_ATTR_MAX+1] = {</span>
 	[NL80211_ATTR_SCAN_FLAGS] = { .type = NLA_U32 },
 	[NL80211_ATTR_P2P_CTWINDOW] = { .type = NLA_U8 },
 	[NL80211_ATTR_P2P_OPPPS] = { .type = NLA_U8 },
<span class="p_add">+	[NL80211_ATTR_LOCAL_MESH_POWER_MODE] = {. type = NLA_U32 },</span>
 	[NL80211_ATTR_ACL_POLICY] = {. type = NLA_U32 },
 	[NL80211_ATTR_MAC_ADDRS] = { .type = NLA_NESTED },
 	[NL80211_ATTR_STA_CAPABILITY] = { .type = NLA_U16 },
<span class="p_chunk">@@ -5288,6 +5288,10 @@</span> <span class="p_context"> static int validate_scan_freqs(struct nlattr *freqs)</span>
 	struct nlattr *attr1, *attr2;
 	int n_channels = 0, tmp1, tmp2;
 
<span class="p_add">+	nla_for_each_nested(attr1, freqs, tmp1)</span>
<span class="p_add">+		if (nla_len(attr1) != sizeof(u32))</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
 	nla_for_each_nested(attr1, freqs, tmp1) {
 		n_channels++;
 		/*
<span class="p_chunk">@@ -8923,6 +8927,9 @@</span> <span class="p_context"> static int nl80211_set_rekey_data(struct sk_buff *skb, struct genl_info *info)</span>
 	if (err)
 		return err;
 
<span class="p_add">+	if (!tb[NL80211_REKEY_DATA_REPLAY_CTR] || !tb[NL80211_REKEY_DATA_KEK] ||</span>
<span class="p_add">+	    !tb[NL80211_REKEY_DATA_KCK])</span>
<span class="p_add">+		return -EINVAL;</span>
 	if (nla_len(tb[NL80211_REKEY_DATA_REPLAY_CTR]) != NL80211_REPLAY_CTR_LEN)
 		return -ERANGE;
 	if (nla_len(tb[NL80211_REKEY_DATA_KEK]) != NL80211_KEK_LEN)
<span class="p_header">diff --git a/scripts/tags.sh b/scripts/tags.sh</span>
<span class="p_header">index 140e5fad867d..c652a245aa18 100755</span>
<span class="p_header">--- a/scripts/tags.sh</span>
<span class="p_header">+++ b/scripts/tags.sh</span>
<span class="p_chunk">@@ -197,6 +197,9 @@</span> <span class="p_context"> exuberant()</span>
 	--regex-c++=&#39;/SETPCGFLAG\(([^,)]*).*/SetPageCgroup\1/&#39;		\
 	--regex-c++=&#39;/CLEARPCGFLAG\(([^,)]*).*/ClearPageCgroup\1/&#39;	\
 	--regex-c++=&#39;/TESTCLEARPCGFLAG\(([^,)]*).*/TestClearPageCgroup\1/&#39; \
<span class="p_add">+	--regex-c++=&#39;/TASK_PFA_TEST\([^,]*,\s*([^)]*)\)/task_\1/&#39;	\</span>
<span class="p_add">+	--regex-c++=&#39;/TASK_PFA_SET\([^,]*,\s*([^)]*)\)/task_set_\1/&#39;	\</span>
<span class="p_add">+	--regex-c++=&#39;/TASK_PFA_CLEAR\([^,]*,\s*([^)]*)\)/task_clear_\1/&#39;\</span>
 	--regex-c=&#39;/PCI_OP_READ\((\w*).*[1-4]\)/pci_bus_read_config_\1/&#39; \
 	--regex-c=&#39;/PCI_OP_WRITE\((\w*).*[1-4]\)/pci_bus_write_config_\1/&#39; \
 	--regex-c=&#39;/DEFINE_(MUTEX|SEMAPHORE|SPINLOCK)\((\w*)/\2/v/&#39;	\
<span class="p_chunk">@@ -259,6 +262,9 @@</span> <span class="p_context"> emacs()</span>
 	--regex=&#39;/SETPCGFLAG\(([^,)]*).*/SetPageCgroup\1/&#39;	\
 	--regex=&#39;/CLEARPCGFLAG\(([^,)]*).*/ClearPageCgroup\1/&#39;	\
 	--regex=&#39;/TESTCLEARPCGFLAG\(([^,)]*).*/TestClearPageCgroup\1/&#39; \
<span class="p_add">+	--regex=&#39;/TASK_PFA_TEST\([^,]*,\s*([^)]*)\)/task_\1/&#39;		\</span>
<span class="p_add">+	--regex=&#39;/TASK_PFA_SET\([^,]*,\s*([^)]*)\)/task_set_\1/&#39;	\</span>
<span class="p_add">+	--regex=&#39;/TASK_PFA_CLEAR\([^,]*,\s*([^)]*)\)/task_clear_\1/&#39;	\</span>
 	--regex=&#39;/_PE(\([^,)]*\).*/PEVENT_ERRNO__\1/&#39;		\
 	--regex=&#39;/PCI_OP_READ(\([a-z]*[a-z]\).*[1-4])/pci_bus_read_config_\1/&#39; \
 	--regex=&#39;/PCI_OP_WRITE(\([a-z]*[a-z]\).*[1-4])/pci_bus_write_config_\1/&#39;\
<span class="p_header">diff --git a/security/apparmor/domain.c b/security/apparmor/domain.c</span>
<span class="p_header">index c0ee04da93e6..24a21cd72b4c 100644</span>
<span class="p_header">--- a/security/apparmor/domain.c</span>
<span class="p_header">+++ b/security/apparmor/domain.c</span>
<span class="p_chunk">@@ -621,7 +621,7 @@</span> <span class="p_context"> int aa_change_hat(const char *hats[], int count, u64 token, bool permtest)</span>
 	 * There is no exception for unconfined as change_hat is not
 	 * available.
 	 */
<span class="p_del">-	if (current-&gt;no_new_privs)</span>
<span class="p_add">+	if (task_no_new_privs(current))</span>
 		return -EPERM;
 
 	/* released below */
<span class="p_chunk">@@ -778,7 +778,7 @@</span> <span class="p_context"> int aa_change_profile(const char *ns_name, const char *hname, bool onexec,</span>
 	 * no_new_privs is set because this aways results in a reduction
 	 * of permissions.
 	 */
<span class="p_del">-	if (current-&gt;no_new_privs &amp;&amp; !unconfined(profile)) {</span>
<span class="p_add">+	if (task_no_new_privs(current) &amp;&amp; !unconfined(profile)) {</span>
 		put_cred(cred);
 		return -EPERM;
 	}
<span class="p_header">diff --git a/sound/pci/oxygen/oxygen_mixer.c b/sound/pci/oxygen/oxygen_mixer.c</span>
<span class="p_header">index 5988e044c519..259bf54a9df0 100644</span>
<span class="p_header">--- a/sound/pci/oxygen/oxygen_mixer.c</span>
<span class="p_header">+++ b/sound/pci/oxygen/oxygen_mixer.c</span>
<span class="p_chunk">@@ -88,7 +88,7 @@</span> <span class="p_context"> static int dac_mute_put(struct snd_kcontrol *ctl,</span>
 	int changed;
 
 	mutex_lock(&amp;chip-&gt;mutex);
<span class="p_del">-	changed = !value-&gt;value.integer.value[0] != chip-&gt;dac_mute;</span>
<span class="p_add">+	changed = (!value-&gt;value.integer.value[0]) != chip-&gt;dac_mute;</span>
 	if (changed) {
 		chip-&gt;dac_mute = !value-&gt;value.integer.value[0];
 		chip-&gt;model.update_dac_mute(chip);
<span class="p_header">diff --git a/sound/soc/soc-compress.c b/sound/soc/soc-compress.c</span>
<span class="p_header">index 9ffd6009d0ec..31fa7cc3d462 100644</span>
<span class="p_header">--- a/sound/soc/soc-compress.c</span>
<span class="p_header">+++ b/sound/soc/soc-compress.c</span>
<span class="p_chunk">@@ -67,7 +67,8 @@</span> <span class="p_context"> static int soc_compr_open(struct snd_compr_stream *cstream)</span>
 static int soc_compr_open_fe(struct snd_compr_stream *cstream)
 {
 	struct snd_soc_pcm_runtime *fe = cstream-&gt;private_data;
<span class="p_del">-	struct snd_pcm_substream *fe_substream = fe-&gt;pcm-&gt;streams[0].substream;</span>
<span class="p_add">+	struct snd_pcm_substream *fe_substream =</span>
<span class="p_add">+		 fe-&gt;pcm-&gt;streams[cstream-&gt;direction].substream;</span>
 	struct snd_soc_platform *platform = fe-&gt;platform;
 	struct snd_soc_dpcm *dpcm;
 	struct snd_soc_dapm_widget_list *list;
<span class="p_chunk">@@ -411,7 +412,8 @@</span> <span class="p_context"> static int soc_compr_set_params_fe(struct snd_compr_stream *cstream,</span>
 					struct snd_compr_params *params)
 {
 	struct snd_soc_pcm_runtime *fe = cstream-&gt;private_data;
<span class="p_del">-	struct snd_pcm_substream *fe_substream = fe-&gt;pcm-&gt;streams[0].substream;</span>
<span class="p_add">+	struct snd_pcm_substream *fe_substream =</span>
<span class="p_add">+		 fe-&gt;pcm-&gt;streams[cstream-&gt;direction].substream;</span>
 	struct snd_soc_platform *platform = fe-&gt;platform;
 	int ret = 0, stream;
 
<span class="p_header">diff --git a/tools/lib/lockdep/uinclude/linux/lockdep.h b/tools/lib/lockdep/uinclude/linux/lockdep.h</span>
<span class="p_header">index c1552c28507e..908a9c6fecf0 100644</span>
<span class="p_header">--- a/tools/lib/lockdep/uinclude/linux/lockdep.h</span>
<span class="p_header">+++ b/tools/lib/lockdep/uinclude/linux/lockdep.h</span>
<span class="p_chunk">@@ -8,7 +8,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/utsname.h&gt;
 
 
<span class="p_del">-#define MAX_LOCK_DEPTH 2000UL</span>
<span class="p_add">+#define MAX_LOCK_DEPTH 255UL</span>
 
 #define asmlinkage
 #define __visible
<span class="p_header">diff --git a/virt/kvm/vfio.c b/virt/kvm/vfio.c</span>
<span class="p_header">index ba1a93f935c7..4884708fa0b4 100644</span>
<span class="p_header">--- a/virt/kvm/vfio.c</span>
<span class="p_header">+++ b/virt/kvm/vfio.c</span>
<span class="p_chunk">@@ -46,6 +46,22 @@</span> <span class="p_context"> static struct vfio_group *kvm_vfio_group_get_external_user(struct file *filep)</span>
 	return vfio_group;
 }
 
<span class="p_add">+static bool kvm_vfio_external_group_match_file(struct vfio_group *group,</span>
<span class="p_add">+					       struct file *filep)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bool ret, (*fn)(struct vfio_group *, struct file *);</span>
<span class="p_add">+</span>
<span class="p_add">+	fn = symbol_get(vfio_external_group_match_file);</span>
<span class="p_add">+	if (!fn)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = fn(group, filep);</span>
<span class="p_add">+</span>
<span class="p_add">+	symbol_put(vfio_external_group_match_file);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void kvm_vfio_group_put_external_user(struct vfio_group *vfio_group)
 {
 	void (*fn)(struct vfio_group *);
<span class="p_chunk">@@ -168,18 +184,13 @@</span> <span class="p_context"> static int kvm_vfio_set_group(struct kvm_device *dev, long attr, u64 arg)</span>
 		if (!f.file)
 			return -EBADF;
 
<span class="p_del">-		vfio_group = kvm_vfio_group_get_external_user(f.file);</span>
<span class="p_del">-		fdput(f);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (IS_ERR(vfio_group))</span>
<span class="p_del">-			return PTR_ERR(vfio_group);</span>
<span class="p_del">-</span>
 		ret = -ENOENT;
 
 		mutex_lock(&amp;kv-&gt;lock);
 
 		list_for_each_entry(kvg, &amp;kv-&gt;group_list, node) {
<span class="p_del">-			if (kvg-&gt;vfio_group != vfio_group)</span>
<span class="p_add">+			if (!kvm_vfio_external_group_match_file(kvg-&gt;vfio_group,</span>
<span class="p_add">+								f.file))</span>
 				continue;
 
 			list_del(&amp;kvg-&gt;node);
<span class="p_chunk">@@ -191,7 +202,7 @@</span> <span class="p_context"> static int kvm_vfio_set_group(struct kvm_device *dev, long attr, u64 arg)</span>
 
 		mutex_unlock(&amp;kv-&gt;lock);
 
<span class="p_del">-		kvm_vfio_group_put_external_user(vfio_group);</span>
<span class="p_add">+		fdput(f);</span>
 
 		kvm_vfio_update_coherency(dev);
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



