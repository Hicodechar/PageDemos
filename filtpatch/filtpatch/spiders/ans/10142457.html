
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.9.74 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.9.74</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 3, 2018, 2:17 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20180103141718.GB14867@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10142457/mbox/"
   >mbox</a>
|
   <a href="/patch/10142457/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10142457/">/patch/10142457/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	9FE386034B for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  3 Jan 2018 14:17:30 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 73CA028D71
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  3 Jan 2018 14:17:30 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 678C3290C3; Wed,  3 Jan 2018 14:17:30 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9919428D71
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  3 Jan 2018 14:17:25 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752892AbeACORV (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 3 Jan 2018 09:17:21 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:39350 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751185AbeACORP (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 3 Jan 2018 09:17:15 -0500
Received: from localhost (LFbn-1-12258-90.w90-92.abo.wanadoo.fr
	[90.92.71.90])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 0683EBAC;
	Wed,  3 Jan 2018 14:17:13 +0000 (UTC)
Date: Wed, 3 Jan 2018 15:17:18 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.9.74
Message-ID: &lt;20180103141718.GB14867@kroah.com&gt;
References: &lt;20180103141714.GA14867@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20180103141714.GA14867@kroah.com&gt;
User-Agent: Mutt/1.9.2 (2017-12-15)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Jan. 3, 2018, 2:17 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt</span>
<span class="p_header">index 86a6746f6833..152ec4e87b57 100644</span>
<span class="p_header">--- a/Documentation/kernel-parameters.txt</span>
<span class="p_header">+++ b/Documentation/kernel-parameters.txt</span>
<span class="p_chunk">@@ -2795,6 +2795,8 @@</span> <span class="p_context"> bytes respectively. Such letter suffixes can also be entirely omitted.</span>
 	nopat		[X86] Disable PAT (page attribute table extension of
 			pagetables) support.
 
<span class="p_add">+	nopcid		[X86-64] Disable the PCID cpu feature.</span>
<span class="p_add">+</span>
 	norandmaps	Don&#39;t use address space randomization.  Equivalent to
 			echo 0 &gt; /proc/sys/kernel/randomize_va_space
 
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 64eb0bf614ee..075e429732e7 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 9
<span class="p_del">-SUBLEVEL = 73</span>
<span class="p_add">+SUBLEVEL = 74</span>
 EXTRAVERSION =
 NAME = Roaring Lionus
 
<span class="p_chunk">@@ -788,6 +788,9 @@</span> <span class="p_context"> KBUILD_CFLAGS += $(call cc-disable-warning, pointer-sign)</span>
 # disable invalid &quot;can&#39;t wrap&quot; optimizations for signed / pointers
 KBUILD_CFLAGS	+= $(call cc-option,-fno-strict-overflow)
 
<span class="p_add">+# Make sure -fstack-check isn&#39;t enabled (like gentoo apparently did)</span>
<span class="p_add">+KBUILD_CFLAGS  += $(call cc-option,-fno-stack-check,)</span>
<span class="p_add">+</span>
 # conserve stack if available
 KBUILD_CFLAGS   += $(call cc-option,-fconserve-stack)
 
<span class="p_header">diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig</span>
<span class="p_header">index b9c546a305a4..da8156fd3d58 100644</span>
<span class="p_header">--- a/arch/x86/Kconfig</span>
<span class="p_header">+++ b/arch/x86/Kconfig</span>
<span class="p_chunk">@@ -45,7 +45,7 @@</span> <span class="p_context"> config X86</span>
 	select ARCH_USE_CMPXCHG_LOCKREF		if X86_64
 	select ARCH_USE_QUEUED_RWLOCKS
 	select ARCH_USE_QUEUED_SPINLOCKS
<span class="p_del">-	select ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH if SMP</span>
<span class="p_add">+	select ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH</span>
 	select ARCH_WANTS_DYNAMIC_TASK_STRUCT
 	select ARCH_WANT_FRAME_POINTERS
 	select ARCH_WANT_IPC_PARSE_VERSION	if X86_32
<span class="p_header">diff --git a/arch/x86/include/asm/disabled-features.h b/arch/x86/include/asm/disabled-features.h</span>
<span class="p_header">index 85599ad4d024..21c5ac15657b 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/disabled-features.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/disabled-features.h</span>
<span class="p_chunk">@@ -21,11 +21,13 @@</span> <span class="p_context"></span>
 # define DISABLE_K6_MTRR	(1&lt;&lt;(X86_FEATURE_K6_MTRR &amp; 31))
 # define DISABLE_CYRIX_ARR	(1&lt;&lt;(X86_FEATURE_CYRIX_ARR &amp; 31))
 # define DISABLE_CENTAUR_MCR	(1&lt;&lt;(X86_FEATURE_CENTAUR_MCR &amp; 31))
<span class="p_add">+# define DISABLE_PCID		0</span>
 #else
 # define DISABLE_VME		0
 # define DISABLE_K6_MTRR	0
 # define DISABLE_CYRIX_ARR	0
 # define DISABLE_CENTAUR_MCR	0
<span class="p_add">+# define DISABLE_PCID		(1&lt;&lt;(X86_FEATURE_PCID &amp; 31))</span>
 #endif /* CONFIG_X86_64 */
 
 #ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS
<span class="p_chunk">@@ -43,7 +45,7 @@</span> <span class="p_context"></span>
 #define DISABLED_MASK1	0
 #define DISABLED_MASK2	0
 #define DISABLED_MASK3	(DISABLE_CYRIX_ARR|DISABLE_CENTAUR_MCR|DISABLE_K6_MTRR)
<span class="p_del">-#define DISABLED_MASK4	0</span>
<span class="p_add">+#define DISABLED_MASK4	(DISABLE_PCID)</span>
 #define DISABLED_MASK5	0
 #define DISABLED_MASK6	0
 #define DISABLED_MASK7	0
<span class="p_header">diff --git a/arch/x86/include/asm/hardirq.h b/arch/x86/include/asm/hardirq.h</span>
<span class="p_header">index 59405a248fc2..9b76cd331990 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/hardirq.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/hardirq.h</span>
<span class="p_chunk">@@ -22,8 +22,8 @@</span> <span class="p_context"> typedef struct {</span>
 #ifdef CONFIG_SMP
 	unsigned int irq_resched_count;
 	unsigned int irq_call_count;
<span class="p_del">-	unsigned int irq_tlb_count;</span>
 #endif
<span class="p_add">+	unsigned int irq_tlb_count;</span>
 #ifdef CONFIG_X86_THERMAL_VECTOR
 	unsigned int irq_thermal_count;
 #endif
<span class="p_header">diff --git a/arch/x86/include/asm/mmu.h b/arch/x86/include/asm/mmu.h</span>
<span class="p_header">index 72198c64e646..8b272a08d1a8 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mmu.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mmu.h</span>
<span class="p_chunk">@@ -33,12 +33,6 @@</span> <span class="p_context"> typedef struct {</span>
 #endif
 } mm_context_t;
 
<span class="p_del">-#ifdef CONFIG_SMP</span>
 void leave_mm(int cpu);
<span class="p_del">-#else</span>
<span class="p_del">-static inline void leave_mm(int cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
 
 #endif /* _ASM_X86_MMU_H */
<span class="p_header">diff --git a/arch/x86/include/asm/mmu_context.h b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">index f9dd22469388..d23e35584f15 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -99,10 +99,8 @@</span> <span class="p_context"> static inline void load_mm_ldt(struct mm_struct *mm)</span>
 
 static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
 {
<span class="p_del">-#ifdef CONFIG_SMP</span>
 	if (this_cpu_read(cpu_tlbstate.state) == TLBSTATE_OK)
 		this_cpu_write(cpu_tlbstate.state, TLBSTATE_LAZY);
<span class="p_del">-#endif</span>
 }
 
 static inline int init_new_context(struct task_struct *tsk,
<span class="p_header">diff --git a/arch/x86/include/asm/tlbflush.h b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">index fc5abff9b7fd..7d2ea6b1f7d9 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -7,6 +7,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/processor.h&gt;
 #include &lt;asm/cpufeature.h&gt;
 #include &lt;asm/special_insns.h&gt;
<span class="p_add">+#include &lt;asm/smp.h&gt;</span>
 
 static inline void __invpcid(unsigned long pcid, unsigned long addr,
 			     unsigned long type)
<span class="p_chunk">@@ -65,10 +66,8 @@</span> <span class="p_context"> static inline void invpcid_flush_all_nonglobals(void)</span>
 #endif
 
 struct tlb_state {
<span class="p_del">-#ifdef CONFIG_SMP</span>
 	struct mm_struct *active_mm;
 	int state;
<span class="p_del">-#endif</span>
 
 	/*
 	 * Access to this CR4 shadow and to H/W CR4 is protected by
<span class="p_chunk">@@ -192,6 +191,14 @@</span> <span class="p_context"> static inline void __flush_tlb_all(void)</span>
 		__flush_tlb_global();
 	else
 		__flush_tlb();
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Note: if we somehow had PCID but not PGE, then this wouldn&#39;t work --</span>
<span class="p_add">+	 * we&#39;d end up flushing kernel translations for the current ASID but</span>
<span class="p_add">+	 * we might fail to flush kernel translations for other cached ASIDs.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * To avoid this issue, we force PCID off if PGE is off.</span>
<span class="p_add">+	 */</span>
 }
 
 static inline void __flush_tlb_one(unsigned long addr)
<span class="p_chunk">@@ -205,7 +212,6 @@</span> <span class="p_context"> static inline void __flush_tlb_one(unsigned long addr)</span>
 /*
  * TLB flushing:
  *
<span class="p_del">- *  - flush_tlb() flushes the current mm struct TLBs</span>
  *  - flush_tlb_all() flushes all processes TLBs
  *  - flush_tlb_mm(mm) flushes the specified mm context TLB&#39;s
  *  - flush_tlb_page(vma, vmaddr) flushes one page
<span class="p_chunk">@@ -217,84 +223,6 @@</span> <span class="p_context"> static inline void __flush_tlb_one(unsigned long addr)</span>
  * and page-granular flushes are available only on i486 and up.
  */
 
<span class="p_del">-#ifndef CONFIG_SMP</span>
<span class="p_del">-</span>
<span class="p_del">-/* &quot;_up&quot; is for UniProcessor.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This is a helper for other header functions.  *Not* intended to be called</span>
<span class="p_del">- * directly.  All global TLB flushes need to either call this, or to bump the</span>
<span class="p_del">- * vm statistics themselves.</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline void __flush_tlb_up(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);</span>
<span class="p_del">-	__flush_tlb();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void flush_tlb_all(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);</span>
<span class="p_del">-	__flush_tlb_all();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void flush_tlb(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	__flush_tlb_up();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void local_flush_tlb(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	__flush_tlb_up();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void flush_tlb_mm(struct mm_struct *mm)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (mm == current-&gt;active_mm)</span>
<span class="p_del">-		__flush_tlb_up();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void flush_tlb_page(struct vm_area_struct *vma,</span>
<span class="p_del">-				  unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (vma-&gt;vm_mm == current-&gt;active_mm)</span>
<span class="p_del">-		__flush_tlb_one(addr);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void flush_tlb_range(struct vm_area_struct *vma,</span>
<span class="p_del">-				   unsigned long start, unsigned long end)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (vma-&gt;vm_mm == current-&gt;active_mm)</span>
<span class="p_del">-		__flush_tlb_up();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void flush_tlb_mm_range(struct mm_struct *mm,</span>
<span class="p_del">-	   unsigned long start, unsigned long end, unsigned long vmflag)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (mm == current-&gt;active_mm)</span>
<span class="p_del">-		__flush_tlb_up();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void native_flush_tlb_others(const struct cpumask *cpumask,</span>
<span class="p_del">-					   struct mm_struct *mm,</span>
<span class="p_del">-					   unsigned long start,</span>
<span class="p_del">-					   unsigned long end)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void reset_lazy_tlbstate(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void flush_tlb_kernel_range(unsigned long start,</span>
<span class="p_del">-					  unsigned long end)</span>
<span class="p_del">-{</span>
<span class="p_del">-	flush_tlb_all();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#else  /* SMP */</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;asm/smp.h&gt;</span>
<span class="p_del">-</span>
 #define local_flush_tlb() __flush_tlb()
 
 #define flush_tlb_mm(mm)	flush_tlb_mm_range(mm, 0UL, TLB_FLUSH_ALL, 0UL)
<span class="p_chunk">@@ -303,13 +231,14 @@</span> <span class="p_context"> static inline void flush_tlb_kernel_range(unsigned long start,</span>
 		flush_tlb_mm_range(vma-&gt;vm_mm, start, end, vma-&gt;vm_flags)
 
 extern void flush_tlb_all(void);
<span class="p_del">-extern void flush_tlb_current_task(void);</span>
<span class="p_del">-extern void flush_tlb_page(struct vm_area_struct *, unsigned long);</span>
 extern void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,
 				unsigned long end, unsigned long vmflag);
 extern void flush_tlb_kernel_range(unsigned long start, unsigned long end);
 
<span class="p_del">-#define flush_tlb()	flush_tlb_current_task()</span>
<span class="p_add">+static inline void flush_tlb_page(struct vm_area_struct *vma, unsigned long a)</span>
<span class="p_add">+{</span>
<span class="p_add">+	flush_tlb_mm_range(vma-&gt;vm_mm, a, a + PAGE_SIZE, VM_NONE);</span>
<span class="p_add">+}</span>
 
 void native_flush_tlb_others(const struct cpumask *cpumask,
 				struct mm_struct *mm,
<span class="p_chunk">@@ -324,8 +253,6 @@</span> <span class="p_context"> static inline void reset_lazy_tlbstate(void)</span>
 	this_cpu_write(cpu_tlbstate.active_mm, &amp;init_mm);
 }
 
<span class="p_del">-#endif	/* SMP */</span>
<span class="p_del">-</span>
 #ifndef CONFIG_PARAVIRT
 #define flush_tlb_others(mask, mm, start, end)	\
 	native_flush_tlb_others(mask, mm, start, end)
<span class="p_header">diff --git a/arch/x86/kernel/cpu/bugs.c b/arch/x86/kernel/cpu/bugs.c</span>
<span class="p_header">index bd17db15a2c1..0b6124315441 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/bugs.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/bugs.c</span>
<span class="p_chunk">@@ -19,6 +19,14 @@</span> <span class="p_context"></span>
 
 void __init check_bugs(void)
 {
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Regardless of whether PCID is enumerated, the SDM says</span>
<span class="p_add">+	 * that it can&#39;t be enabled in 32-bit mode.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	setup_clear_cpu_cap(X86_FEATURE_PCID);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	identify_boot_cpu();
 #ifndef CONFIG_SMP
 	pr_info(&quot;CPU: &quot;);
<span class="p_header">diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">index 4eece91ada37..91588be529b9 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/common.c</span>
<span class="p_chunk">@@ -163,6 +163,24 @@</span> <span class="p_context"> static int __init x86_mpx_setup(char *s)</span>
 }
 __setup(&quot;nompx&quot;, x86_mpx_setup);
 
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+static int __init x86_pcid_setup(char *s)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* require an exact match without trailing characters */</span>
<span class="p_add">+	if (strlen(s))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* do not emit a message if the feature is not present */</span>
<span class="p_add">+	if (!boot_cpu_has(X86_FEATURE_PCID))</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	setup_clear_cpu_cap(X86_FEATURE_PCID);</span>
<span class="p_add">+	pr_info(&quot;nopcid: PCID feature disabled\n&quot;);</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+__setup(&quot;nopcid&quot;, x86_pcid_setup);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 static int __init x86_noinvpcid_setup(char *s)
 {
 	/* noinvpcid doesn&#39;t accept parameters */
<span class="p_chunk">@@ -306,6 +324,25 @@</span> <span class="p_context"> static __always_inline void setup_smap(struct cpuinfo_x86 *c)</span>
 	}
 }
 
<span class="p_add">+static void setup_pcid(struct cpuinfo_x86 *c)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (cpu_has(c, X86_FEATURE_PCID)) {</span>
<span class="p_add">+		if (cpu_has(c, X86_FEATURE_PGE)) {</span>
<span class="p_add">+			cr4_set_bits(X86_CR4_PCIDE);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * flush_tlb_all(), as currently implemented, won&#39;t</span>
<span class="p_add">+			 * work if PCID is on but PGE is not.  Since that</span>
<span class="p_add">+			 * combination doesn&#39;t exist on real hardware, there&#39;s</span>
<span class="p_add">+			 * no reason to try to fully support it, but it&#39;s</span>
<span class="p_add">+			 * polite to avoid corrupting data if we&#39;re on</span>
<span class="p_add">+			 * an improperly configured VM.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			clear_cpu_cap(c, X86_FEATURE_PCID);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Protection Keys are not available in 32-bit mode.
  */
<span class="p_chunk">@@ -1064,6 +1101,9 @@</span> <span class="p_context"> static void identify_cpu(struct cpuinfo_x86 *c)</span>
 	setup_smep(c);
 	setup_smap(c);
 
<span class="p_add">+	/* Set up PCID */</span>
<span class="p_add">+	setup_pcid(c);</span>
<span class="p_add">+</span>
 	/*
 	 * The vendor-specific functions might have changed features.
 	 * Now we do &quot;generic changes.&quot;
<span class="p_header">diff --git a/arch/x86/kernel/reboot.c b/arch/x86/kernel/reboot.c</span>
<span class="p_header">index 067f9813fd2c..ce020a69bba9 100644</span>
<span class="p_header">--- a/arch/x86/kernel/reboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/reboot.c</span>
<span class="p_chunk">@@ -106,6 +106,10 @@</span> <span class="p_context"> void __noreturn machine_real_restart(unsigned int type)</span>
 	load_cr3(initial_page_table);
 #else
 	write_cr3(real_mode_header-&gt;trampoline_pgd);
<span class="p_add">+</span>
<span class="p_add">+	/* Exiting long mode will fail if CR4.PCIDE is set. */</span>
<span class="p_add">+	if (static_cpu_has(X86_FEATURE_PCID))</span>
<span class="p_add">+		cr4_clear_bits(X86_CR4_PCIDE);</span>
 #endif
 
 	/* Jump to the identity-mapped low memory code */
<span class="p_header">diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c</span>
<span class="p_header">index 9fe7b9e1ae30..e803d72ef525 100644</span>
<span class="p_header">--- a/arch/x86/kernel/smpboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/smpboot.c</span>
<span class="p_chunk">@@ -115,25 +115,16 @@</span> <span class="p_context"> static inline void smpboot_setup_warm_reset_vector(unsigned long start_eip)</span>
 	spin_lock_irqsave(&amp;rtc_lock, flags);
 	CMOS_WRITE(0xa, 0xf);
 	spin_unlock_irqrestore(&amp;rtc_lock, flags);
<span class="p_del">-	local_flush_tlb();</span>
<span class="p_del">-	pr_debug(&quot;1.\n&quot;);</span>
 	*((volatile unsigned short *)phys_to_virt(TRAMPOLINE_PHYS_HIGH)) =
 							start_eip &gt;&gt; 4;
<span class="p_del">-	pr_debug(&quot;2.\n&quot;);</span>
 	*((volatile unsigned short *)phys_to_virt(TRAMPOLINE_PHYS_LOW)) =
 							start_eip &amp; 0xf;
<span class="p_del">-	pr_debug(&quot;3.\n&quot;);</span>
 }
 
 static inline void smpboot_restore_warm_reset_vector(void)
 {
 	unsigned long flags;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Install writable page 0 entry to set BIOS data area.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	local_flush_tlb();</span>
<span class="p_del">-</span>
 	/*
 	 * Paranoid:  Set warm reset code and vector here back
 	 * to default values.
<span class="p_header">diff --git a/arch/x86/kernel/vm86_32.c b/arch/x86/kernel/vm86_32.c</span>
<span class="p_header">index 01f30e56f99e..4b3012888ada 100644</span>
<span class="p_header">--- a/arch/x86/kernel/vm86_32.c</span>
<span class="p_header">+++ b/arch/x86/kernel/vm86_32.c</span>
<span class="p_chunk">@@ -191,7 +191,7 @@</span> <span class="p_context"> static void mark_screen_rdonly(struct mm_struct *mm)</span>
 	pte_unmap_unlock(pte, ptl);
 out:
 	up_write(&amp;mm-&gt;mmap_sem);
<span class="p_del">-	flush_tlb();</span>
<span class="p_add">+	flush_tlb_mm_range(mm, 0xA0000, 0xA0000 + 32*PAGE_SIZE, 0UL);</span>
 }
 
 
<span class="p_header">diff --git a/arch/x86/mm/init.c b/arch/x86/mm/init.c</span>
<span class="p_header">index 889e7619a091..0381638168d1 100644</span>
<span class="p_header">--- a/arch/x86/mm/init.c</span>
<span class="p_header">+++ b/arch/x86/mm/init.c</span>
<span class="p_chunk">@@ -764,10 +764,8 @@</span> <span class="p_context"> void __init zone_sizes_init(void)</span>
 }
 
 DEFINE_PER_CPU_SHARED_ALIGNED(struct tlb_state, cpu_tlbstate) = {
<span class="p_del">-#ifdef CONFIG_SMP</span>
 	.active_mm = &amp;init_mm,
 	.state = 0,
<span class="p_del">-#endif</span>
 	.cr4 = ~0UL,	/* fail hard if we screw up cr4 shadow initialization */
 };
 EXPORT_SYMBOL_GPL(cpu_tlbstate);
<span class="p_header">diff --git a/arch/x86/mm/tlb.c b/arch/x86/mm/tlb.c</span>
<span class="p_header">index 75fb01109f94..53b72fb4e781 100644</span>
<span class="p_header">--- a/arch/x86/mm/tlb.c</span>
<span class="p_header">+++ b/arch/x86/mm/tlb.c</span>
<span class="p_chunk">@@ -15,7 +15,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/debugfs.h&gt;
 
 /*
<span class="p_del">- *	Smarter SMP flushing macros.</span>
<span class="p_add">+ *	TLB flushing, formerly SMP-only</span>
  *		c/o Linus Torvalds.
  *
  *	These mean you can really definitely utterly forget about
<span class="p_chunk">@@ -28,8 +28,6 @@</span> <span class="p_context"></span>
  *	Implement flush IPI by CALL_FUNCTION_VECTOR, Alex Shi
  */
 
<span class="p_del">-#ifdef CONFIG_SMP</span>
<span class="p_del">-</span>
 struct flush_tlb_info {
 	struct mm_struct *flush_mm;
 	unsigned long flush_start;
<span class="p_chunk">@@ -59,8 +57,6 @@</span> <span class="p_context"> void leave_mm(int cpu)</span>
 }
 EXPORT_SYMBOL_GPL(leave_mm);
 
<span class="p_del">-#endif /* CONFIG_SMP */</span>
<span class="p_del">-</span>
 void switch_mm(struct mm_struct *prev, struct mm_struct *next,
 	       struct task_struct *tsk)
 {
<span class="p_chunk">@@ -91,10 +87,8 @@</span> <span class="p_context"> void switch_mm_irqs_off(struct mm_struct *prev, struct mm_struct *next,</span>
 				set_pgd(pgd, init_mm.pgd[stack_pgd_index]);
 		}
 
<span class="p_del">-#ifdef CONFIG_SMP</span>
 		this_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);
 		this_cpu_write(cpu_tlbstate.active_mm, next);
<span class="p_del">-#endif</span>
 
 		cpumask_set_cpu(cpu, mm_cpumask(next));
 
<span class="p_chunk">@@ -152,9 +146,7 @@</span> <span class="p_context"> void switch_mm_irqs_off(struct mm_struct *prev, struct mm_struct *next,</span>
 		if (unlikely(prev-&gt;context.ldt != next-&gt;context.ldt))
 			load_mm_ldt(next);
 #endif
<span class="p_del">-	}</span>
<span class="p_del">-#ifdef CONFIG_SMP</span>
<span class="p_del">-	  else {</span>
<span class="p_add">+	} else {</span>
 		this_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);
 		BUG_ON(this_cpu_read(cpu_tlbstate.active_mm) != next);
 
<span class="p_chunk">@@ -181,11 +173,8 @@</span> <span class="p_context"> void switch_mm_irqs_off(struct mm_struct *prev, struct mm_struct *next,</span>
 			load_mm_ldt(next);
 		}
 	}
<span class="p_del">-#endif</span>
 }
 
<span class="p_del">-#ifdef CONFIG_SMP</span>
<span class="p_del">-</span>
 /*
  * The flush IPI assumes that a thread switch happens in this order:
  * [cpu0: the cpu that switches]
<span class="p_chunk">@@ -287,23 +276,6 @@</span> <span class="p_context"> void native_flush_tlb_others(const struct cpumask *cpumask,</span>
 	smp_call_function_many(cpumask, flush_tlb_func, &amp;info, 1);
 }
 
<span class="p_del">-void flush_tlb_current_task(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mm_struct *mm = current-&gt;mm;</span>
<span class="p_del">-</span>
<span class="p_del">-	preempt_disable();</span>
<span class="p_del">-</span>
<span class="p_del">-	count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* This is an implicit full barrier that synchronizes with switch_mm. */</span>
<span class="p_del">-	local_flush_tlb();</span>
<span class="p_del">-</span>
<span class="p_del">-	trace_tlb_flush(TLB_LOCAL_SHOOTDOWN, TLB_FLUSH_ALL);</span>
<span class="p_del">-	if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) &lt; nr_cpu_ids)</span>
<span class="p_del">-		flush_tlb_others(mm_cpumask(mm), mm, 0UL, TLB_FLUSH_ALL);</span>
<span class="p_del">-	preempt_enable();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * See Documentation/x86/tlb.txt for details.  We choose 33
  * because it is large enough to cover the vast majority (at
<span class="p_chunk">@@ -324,6 +296,12 @@</span> <span class="p_context"> void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,</span>
 	unsigned long base_pages_to_flush = TLB_FLUSH_ALL;
 
 	preempt_disable();
<span class="p_add">+</span>
<span class="p_add">+	if ((end != TLB_FLUSH_ALL) &amp;&amp; !(vmflag &amp; VM_HUGETLB))</span>
<span class="p_add">+		base_pages_to_flush = (end - start) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	if (base_pages_to_flush &gt; tlb_single_page_flush_ceiling)</span>
<span class="p_add">+		base_pages_to_flush = TLB_FLUSH_ALL;</span>
<span class="p_add">+</span>
 	if (current-&gt;active_mm != mm) {
 		/* Synchronize with switch_mm. */
 		smp_mb();
<span class="p_chunk">@@ -340,15 +318,11 @@</span> <span class="p_context"> void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,</span>
 		goto out;
 	}
 
<span class="p_del">-	if ((end != TLB_FLUSH_ALL) &amp;&amp; !(vmflag &amp; VM_HUGETLB))</span>
<span class="p_del">-		base_pages_to_flush = (end - start) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_del">-</span>
 	/*
 	 * Both branches below are implicit full barriers (MOV to CR or
 	 * INVLPG) that synchronize with switch_mm.
 	 */
<span class="p_del">-	if (base_pages_to_flush &gt; tlb_single_page_flush_ceiling) {</span>
<span class="p_del">-		base_pages_to_flush = TLB_FLUSH_ALL;</span>
<span class="p_add">+	if (base_pages_to_flush == TLB_FLUSH_ALL) {</span>
 		count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);
 		local_flush_tlb();
 	} else {
<span class="p_chunk">@@ -369,33 +343,6 @@</span> <span class="p_context"> void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,</span>
 	preempt_enable();
 }
 
<span class="p_del">-void flush_tlb_page(struct vm_area_struct *vma, unsigned long start)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mm_struct *mm = vma-&gt;vm_mm;</span>
<span class="p_del">-</span>
<span class="p_del">-	preempt_disable();</span>
<span class="p_del">-</span>
<span class="p_del">-	if (current-&gt;active_mm == mm) {</span>
<span class="p_del">-		if (current-&gt;mm) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Implicit full barrier (INVLPG) that synchronizes</span>
<span class="p_del">-			 * with switch_mm.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			__flush_tlb_one(start);</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			leave_mm(smp_processor_id());</span>
<span class="p_del">-</span>
<span class="p_del">-			/* Synchronize with switch_mm. */</span>
<span class="p_del">-			smp_mb();</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) &lt; nr_cpu_ids)</span>
<span class="p_del">-		flush_tlb_others(mm_cpumask(mm), mm, start, start + PAGE_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-	preempt_enable();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void do_flush_tlb_all(void *info)
 {
 	count_vm_tlb_event(NR_TLB_REMOTE_FLUSH_RECEIVED);
<span class="p_chunk">@@ -480,5 +427,3 @@</span> <span class="p_context"> static int __init create_tlb_single_page_flush_ceiling(void)</span>
 	return 0;
 }
 late_initcall(create_tlb_single_page_flush_ceiling);
<span class="p_del">-</span>
<span class="p_del">-#endif /* CONFIG_SMP */</span>
<span class="p_header">diff --git a/arch/x86/xen/enlighten.c b/arch/x86/xen/enlighten.c</span>
<span class="p_header">index 8f1f7efa848c..2bea87cc0ff2 100644</span>
<span class="p_header">--- a/arch/x86/xen/enlighten.c</span>
<span class="p_header">+++ b/arch/x86/xen/enlighten.c</span>
<span class="p_chunk">@@ -444,6 +444,12 @@</span> <span class="p_context"> static void __init xen_init_cpuid_mask(void)</span>
 		~((1 &lt;&lt; X86_FEATURE_MTRR) |  /* disable MTRR */
 		  (1 &lt;&lt; X86_FEATURE_ACC));   /* thermal monitoring */
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Xen PV would need some work to support PCID: CR3 handling as well</span>
<span class="p_add">+	 * as xen_flush_tlb_others() would need updating.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	cpuid_leaf1_ecx_mask &amp;= ~(1 &lt;&lt; (X86_FEATURE_PCID % 32));  /* disable PCID */</span>
<span class="p_add">+</span>
 	if (!xen_initial_domain())
 		cpuid_leaf1_edx_mask &amp;=
 			~((1 &lt;&lt; X86_FEATURE_ACPI));  /* disable ACPI */
<span class="p_header">diff --git a/drivers/infiniband/hw/cxgb4/cq.c b/drivers/infiniband/hw/cxgb4/cq.c</span>
<span class="p_header">index 19c6477af19f..a856371bbe58 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/cxgb4/cq.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/cxgb4/cq.c</span>
<span class="p_chunk">@@ -575,10 +575,10 @@</span> <span class="p_context"> static int poll_cq(struct t4_wq *wq, struct t4_cq *cq, struct t4_cqe *cqe,</span>
 			ret = -EAGAIN;
 			goto skip_cqe;
 		}
<span class="p_del">-		if (unlikely((CQE_WRID_MSN(hw_cqe) != (wq-&gt;rq.msn)))) {</span>
<span class="p_add">+		if (unlikely(!CQE_STATUS(hw_cqe) &amp;&amp;</span>
<span class="p_add">+			     CQE_WRID_MSN(hw_cqe) != wq-&gt;rq.msn)) {</span>
 			t4_set_wq_in_error(wq);
<span class="p_del">-			hw_cqe-&gt;header |= htonl(CQE_STATUS_V(T4_ERR_MSN));</span>
<span class="p_del">-			goto proc_cqe;</span>
<span class="p_add">+			hw_cqe-&gt;header |= cpu_to_be32(CQE_STATUS_V(T4_ERR_MSN));</span>
 		}
 		goto proc_cqe;
 	}
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/tg3.c b/drivers/net/ethernet/broadcom/tg3.c</span>
<span class="p_header">index edae2dcc4927..bb22d325e965 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/tg3.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/tg3.c</span>
<span class="p_chunk">@@ -14226,7 +14226,9 @@</span> <span class="p_context"> static int tg3_change_mtu(struct net_device *dev, int new_mtu)</span>
 	/* Reset PHY, otherwise the read DMA engine will be in a mode that
 	 * breaks all requests to 256 bytes.
 	 */
<span class="p_del">-	if (tg3_asic_rev(tp) == ASIC_REV_57766)</span>
<span class="p_add">+	if (tg3_asic_rev(tp) == ASIC_REV_57766 ||</span>
<span class="p_add">+	    tg3_asic_rev(tp) == ASIC_REV_5717 ||</span>
<span class="p_add">+	    tg3_asic_rev(tp) == ASIC_REV_5719)</span>
 		reset_phy = true;
 
 	err = tg3_restart_hw(tp, reset_phy);
<span class="p_header">diff --git a/drivers/net/ethernet/freescale/fec_main.c b/drivers/net/ethernet/freescale/fec_main.c</span>
<span class="p_header">index 849b8712ec81..917091871259 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/freescale/fec_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/freescale/fec_main.c</span>
<span class="p_chunk">@@ -172,10 +172,12 @@</span> <span class="p_context"> MODULE_PARM_DESC(macaddr, &quot;FEC Ethernet MAC address&quot;);</span>
 #endif /* CONFIG_M5272 */
 
 /* The FEC stores dest/src/type/vlan, data, and checksum for receive packets.
<span class="p_add">+ *</span>
<span class="p_add">+ * 2048 byte skbufs are allocated. However, alignment requirements</span>
<span class="p_add">+ * varies between FEC variants. Worst case is 64, so round down by 64.</span>
  */
<span class="p_del">-#define PKT_MAXBUF_SIZE		1522</span>
<span class="p_add">+#define PKT_MAXBUF_SIZE		(round_down(2048 - 64, 64))</span>
 #define PKT_MINBUF_SIZE		64
<span class="p_del">-#define PKT_MAXBLR_SIZE		1536</span>
 
 /* FEC receive acceleration */
 #define FEC_RACC_IPDIS		(1 &lt;&lt; 1)
<span class="p_chunk">@@ -813,6 +815,12 @@</span> <span class="p_context"> static void fec_enet_bd_init(struct net_device *dev)</span>
 		for (i = 0; i &lt; txq-&gt;bd.ring_size; i++) {
 			/* Initialize the BD for every fragment in the page. */
 			bdp-&gt;cbd_sc = cpu_to_fec16(0);
<span class="p_add">+			if (bdp-&gt;cbd_bufaddr &amp;&amp;</span>
<span class="p_add">+			    !IS_TSO_HEADER(txq, fec32_to_cpu(bdp-&gt;cbd_bufaddr)))</span>
<span class="p_add">+				dma_unmap_single(&amp;fep-&gt;pdev-&gt;dev,</span>
<span class="p_add">+						 fec32_to_cpu(bdp-&gt;cbd_bufaddr),</span>
<span class="p_add">+						 fec16_to_cpu(bdp-&gt;cbd_datlen),</span>
<span class="p_add">+						 DMA_TO_DEVICE);</span>
 			if (txq-&gt;tx_skbuff[i]) {
 				dev_kfree_skb_any(txq-&gt;tx_skbuff[i]);
 				txq-&gt;tx_skbuff[i] = NULL;
<span class="p_chunk">@@ -847,7 +855,7 @@</span> <span class="p_context"> static void fec_enet_enable_ring(struct net_device *ndev)</span>
 	for (i = 0; i &lt; fep-&gt;num_rx_queues; i++) {
 		rxq = fep-&gt;rx_queue[i];
 		writel(rxq-&gt;bd.dma, fep-&gt;hwp + FEC_R_DES_START(i));
<span class="p_del">-		writel(PKT_MAXBLR_SIZE, fep-&gt;hwp + FEC_R_BUFF_SIZE(i));</span>
<span class="p_add">+		writel(PKT_MAXBUF_SIZE, fep-&gt;hwp + FEC_R_BUFF_SIZE(i));</span>
 
 		/* enable DMA1/2 */
 		if (i)
<span class="p_header">diff --git a/drivers/net/ethernet/marvell/mvmdio.c b/drivers/net/ethernet/marvell/mvmdio.c</span>
<span class="p_header">index a0d1b084ecec..7aeb7fedb364 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/marvell/mvmdio.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/marvell/mvmdio.c</span>
<span class="p_chunk">@@ -232,7 +232,8 @@</span> <span class="p_context"> static int orion_mdio_probe(struct platform_device *pdev)</span>
 			dev-&gt;regs + MVMDIO_ERR_INT_MASK);
 
 	} else if (dev-&gt;err_interrupt == -EPROBE_DEFER) {
<span class="p_del">-		return -EPROBE_DEFER;</span>
<span class="p_add">+		ret = -EPROBE_DEFER;</span>
<span class="p_add">+		goto out_mdio;</span>
 	}
 
 	mutex_init(&amp;dev-&gt;lock);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c</span>
<span class="p_header">index f7fabecc104f..4c3f1cb7e2c9 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c</span>
<span class="p_chunk">@@ -367,7 +367,7 @@</span> <span class="p_context"> static int mlx5_internal_err_ret_value(struct mlx5_core_dev *dev, u16 op,</span>
 	case MLX5_CMD_OP_QUERY_VPORT_COUNTER:
 	case MLX5_CMD_OP_ALLOC_Q_COUNTER:
 	case MLX5_CMD_OP_QUERY_Q_COUNTER:
<span class="p_del">-	case MLX5_CMD_OP_SET_RATE_LIMIT:</span>
<span class="p_add">+	case MLX5_CMD_OP_SET_PP_RATE_LIMIT:</span>
 	case MLX5_CMD_OP_QUERY_RATE_LIMIT:
 	case MLX5_CMD_OP_ALLOC_PD:
 	case MLX5_CMD_OP_ALLOC_UAR:
<span class="p_chunk">@@ -502,7 +502,7 @@</span> <span class="p_context"> const char *mlx5_command_str(int command)</span>
 	MLX5_COMMAND_STR_CASE(ALLOC_Q_COUNTER);
 	MLX5_COMMAND_STR_CASE(DEALLOC_Q_COUNTER);
 	MLX5_COMMAND_STR_CASE(QUERY_Q_COUNTER);
<span class="p_del">-	MLX5_COMMAND_STR_CASE(SET_RATE_LIMIT);</span>
<span class="p_add">+	MLX5_COMMAND_STR_CASE(SET_PP_RATE_LIMIT);</span>
 	MLX5_COMMAND_STR_CASE(QUERY_RATE_LIMIT);
 	MLX5_COMMAND_STR_CASE(ALLOC_PD);
 	MLX5_COMMAND_STR_CASE(DEALLOC_PD);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span>
<span class="p_header">index 9d3722930c95..38981db43bc3 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span>
<span class="p_chunk">@@ -3038,6 +3038,7 @@</span> <span class="p_context"> static netdev_features_t mlx5e_vxlan_features_check(struct mlx5e_priv *priv,</span>
 						    struct sk_buff *skb,
 						    netdev_features_t features)
 {
<span class="p_add">+	unsigned int offset = 0;</span>
 	struct udphdr *udph;
 	u16 proto;
 	u16 port = 0;
<span class="p_chunk">@@ -3047,7 +3048,7 @@</span> <span class="p_context"> static netdev_features_t mlx5e_vxlan_features_check(struct mlx5e_priv *priv,</span>
 		proto = ip_hdr(skb)-&gt;protocol;
 		break;
 	case htons(ETH_P_IPV6):
<span class="p_del">-		proto = ipv6_hdr(skb)-&gt;nexthdr;</span>
<span class="p_add">+		proto = ipv6_find_hdr(skb, &amp;offset, -1, NULL, NULL);</span>
 		break;
 	default:
 		goto out;
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/qp.c b/drivers/net/ethernet/mellanox/mlx5/core/qp.c</span>
<span class="p_header">index d0a4005fe63a..9346f3985edf 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/qp.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/qp.c</span>
<span class="p_chunk">@@ -303,8 +303,8 @@</span> <span class="p_context"> int mlx5_core_create_qp(struct mlx5_core_dev *dev,</span>
 err_cmd:
 	memset(din, 0, sizeof(din));
 	memset(dout, 0, sizeof(dout));
<span class="p_del">-	MLX5_SET(destroy_qp_in, in, opcode, MLX5_CMD_OP_DESTROY_QP);</span>
<span class="p_del">-	MLX5_SET(destroy_qp_in, in, qpn, qp-&gt;qpn);</span>
<span class="p_add">+	MLX5_SET(destroy_qp_in, din, opcode, MLX5_CMD_OP_DESTROY_QP);</span>
<span class="p_add">+	MLX5_SET(destroy_qp_in, din, qpn, qp-&gt;qpn);</span>
 	mlx5_cmd_exec(dev, din, sizeof(din), dout, sizeof(dout));
 	return err;
 }
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/rl.c b/drivers/net/ethernet/mellanox/mlx5/core/rl.c</span>
<span class="p_header">index 104902a93a0b..2be9ec5fd651 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/rl.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/rl.c</span>
<span class="p_chunk">@@ -60,16 +60,16 @@</span> <span class="p_context"> static struct mlx5_rl_entry *find_rl_entry(struct mlx5_rl_table *table,</span>
 	return ret_entry;
 }
 
<span class="p_del">-static int mlx5_set_rate_limit_cmd(struct mlx5_core_dev *dev,</span>
<span class="p_add">+static int mlx5_set_pp_rate_limit_cmd(struct mlx5_core_dev *dev,</span>
 				   u32 rate, u16 index)
 {
<span class="p_del">-	u32 in[MLX5_ST_SZ_DW(set_rate_limit_in)]   = {0};</span>
<span class="p_del">-	u32 out[MLX5_ST_SZ_DW(set_rate_limit_out)] = {0};</span>
<span class="p_add">+	u32 in[MLX5_ST_SZ_DW(set_pp_rate_limit_in)]   = {0};</span>
<span class="p_add">+	u32 out[MLX5_ST_SZ_DW(set_pp_rate_limit_out)] = {0};</span>
 
<span class="p_del">-	MLX5_SET(set_rate_limit_in, in, opcode,</span>
<span class="p_del">-		 MLX5_CMD_OP_SET_RATE_LIMIT);</span>
<span class="p_del">-	MLX5_SET(set_rate_limit_in, in, rate_limit_index, index);</span>
<span class="p_del">-	MLX5_SET(set_rate_limit_in, in, rate_limit, rate);</span>
<span class="p_add">+	MLX5_SET(set_pp_rate_limit_in, in, opcode,</span>
<span class="p_add">+		 MLX5_CMD_OP_SET_PP_RATE_LIMIT);</span>
<span class="p_add">+	MLX5_SET(set_pp_rate_limit_in, in, rate_limit_index, index);</span>
<span class="p_add">+	MLX5_SET(set_pp_rate_limit_in, in, rate_limit, rate);</span>
 	return mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));
 }
 
<span class="p_chunk">@@ -108,7 +108,7 @@</span> <span class="p_context"> int mlx5_rl_add_rate(struct mlx5_core_dev *dev, u32 rate, u16 *index)</span>
 		entry-&gt;refcount++;
 	} else {
 		/* new rate limit */
<span class="p_del">-		err = mlx5_set_rate_limit_cmd(dev, rate, entry-&gt;index);</span>
<span class="p_add">+		err = mlx5_set_pp_rate_limit_cmd(dev, rate, entry-&gt;index);</span>
 		if (err) {
 			mlx5_core_err(dev, &quot;Failed configuring rate: %u (%d)\n&quot;,
 				      rate, err);
<span class="p_chunk">@@ -144,7 +144,7 @@</span> <span class="p_context"> void mlx5_rl_remove_rate(struct mlx5_core_dev *dev, u32 rate)</span>
 	entry-&gt;refcount--;
 	if (!entry-&gt;refcount) {
 		/* need to remove rate */
<span class="p_del">-		mlx5_set_rate_limit_cmd(dev, 0, entry-&gt;index);</span>
<span class="p_add">+		mlx5_set_pp_rate_limit_cmd(dev, 0, entry-&gt;index);</span>
 		entry-&gt;rate = 0;
 	}
 
<span class="p_chunk">@@ -197,8 +197,8 @@</span> <span class="p_context"> void mlx5_cleanup_rl_table(struct mlx5_core_dev *dev)</span>
 	/* Clear all configured rates */
 	for (i = 0; i &lt; table-&gt;max_size; i++)
 		if (table-&gt;rl_entry[i].rate)
<span class="p_del">-			mlx5_set_rate_limit_cmd(dev, 0,</span>
<span class="p_del">-						table-&gt;rl_entry[i].index);</span>
<span class="p_add">+			mlx5_set_pp_rate_limit_cmd(dev, 0,</span>
<span class="p_add">+						   table-&gt;rl_entry[i].index);</span>
 
 	kfree(dev-&gt;priv.rl_table.rl_entry);
 }
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/vxlan.c b/drivers/net/ethernet/mellanox/mlx5/core/vxlan.c</span>
<span class="p_header">index 07a9ba6cfc70..2f74953e4561 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/vxlan.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/vxlan.c</span>
<span class="p_chunk">@@ -71,9 +71,9 @@</span> <span class="p_context"> struct mlx5e_vxlan *mlx5e_vxlan_lookup_port(struct mlx5e_priv *priv, u16 port)</span>
 	struct mlx5e_vxlan_db *vxlan_db = &amp;priv-&gt;vxlan;
 	struct mlx5e_vxlan *vxlan;
 
<span class="p_del">-	spin_lock(&amp;vxlan_db-&gt;lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;vxlan_db-&gt;lock);</span>
 	vxlan = radix_tree_lookup(&amp;vxlan_db-&gt;tree, port);
<span class="p_del">-	spin_unlock(&amp;vxlan_db-&gt;lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;vxlan_db-&gt;lock);</span>
 
 	return vxlan;
 }
<span class="p_chunk">@@ -88,8 +88,12 @@</span> <span class="p_context"> static void mlx5e_vxlan_add_port(struct work_struct *work)</span>
 	struct mlx5e_vxlan *vxlan;
 	int err;
 
<span class="p_del">-	if (mlx5e_vxlan_lookup_port(priv, port))</span>
<span class="p_add">+	mutex_lock(&amp;priv-&gt;state_lock);</span>
<span class="p_add">+	vxlan = mlx5e_vxlan_lookup_port(priv, port);</span>
<span class="p_add">+	if (vxlan) {</span>
<span class="p_add">+		atomic_inc(&amp;vxlan-&gt;refcount);</span>
 		goto free_work;
<span class="p_add">+	}</span>
 
 	if (mlx5e_vxlan_core_add_port_cmd(priv-&gt;mdev, port))
 		goto free_work;
<span class="p_chunk">@@ -99,10 +103,11 @@</span> <span class="p_context"> static void mlx5e_vxlan_add_port(struct work_struct *work)</span>
 		goto err_delete_port;
 
 	vxlan-&gt;udp_port = port;
<span class="p_add">+	atomic_set(&amp;vxlan-&gt;refcount, 1);</span>
 
<span class="p_del">-	spin_lock_irq(&amp;vxlan_db-&gt;lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;vxlan_db-&gt;lock);</span>
 	err = radix_tree_insert(&amp;vxlan_db-&gt;tree, vxlan-&gt;udp_port, vxlan);
<span class="p_del">-	spin_unlock_irq(&amp;vxlan_db-&gt;lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;vxlan_db-&gt;lock);</span>
 	if (err)
 		goto err_free;
 
<span class="p_chunk">@@ -113,35 +118,39 @@</span> <span class="p_context"> static void mlx5e_vxlan_add_port(struct work_struct *work)</span>
 err_delete_port:
 	mlx5e_vxlan_core_del_port_cmd(priv-&gt;mdev, port);
 free_work:
<span class="p_add">+	mutex_unlock(&amp;priv-&gt;state_lock);</span>
 	kfree(vxlan_work);
 }
 
<span class="p_del">-static void __mlx5e_vxlan_core_del_port(struct mlx5e_priv *priv, u16 port)</span>
<span class="p_add">+static void mlx5e_vxlan_del_port(struct work_struct *work)</span>
 {
<span class="p_add">+	struct mlx5e_vxlan_work *vxlan_work =</span>
<span class="p_add">+		container_of(work, struct mlx5e_vxlan_work, work);</span>
<span class="p_add">+	struct mlx5e_priv *priv         = vxlan_work-&gt;priv;</span>
 	struct mlx5e_vxlan_db *vxlan_db = &amp;priv-&gt;vxlan;
<span class="p_add">+	u16 port = vxlan_work-&gt;port;</span>
 	struct mlx5e_vxlan *vxlan;
<span class="p_add">+	bool remove = false;</span>
 
<span class="p_del">-	spin_lock_irq(&amp;vxlan_db-&gt;lock);</span>
<span class="p_del">-	vxlan = radix_tree_delete(&amp;vxlan_db-&gt;tree, port);</span>
<span class="p_del">-	spin_unlock_irq(&amp;vxlan_db-&gt;lock);</span>
<span class="p_del">-</span>
<span class="p_add">+	mutex_lock(&amp;priv-&gt;state_lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;vxlan_db-&gt;lock);</span>
<span class="p_add">+	vxlan = radix_tree_lookup(&amp;vxlan_db-&gt;tree, port);</span>
 	if (!vxlan)
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	mlx5e_vxlan_core_del_port_cmd(priv-&gt;mdev, vxlan-&gt;udp_port);</span>
<span class="p_del">-</span>
<span class="p_del">-	kfree(vxlan);</span>
<span class="p_del">-}</span>
<span class="p_add">+		goto out_unlock;</span>
 
<span class="p_del">-static void mlx5e_vxlan_del_port(struct work_struct *work)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mlx5e_vxlan_work *vxlan_work =</span>
<span class="p_del">-		container_of(work, struct mlx5e_vxlan_work, work);</span>
<span class="p_del">-	struct mlx5e_priv *priv = vxlan_work-&gt;priv;</span>
<span class="p_del">-	u16 port = vxlan_work-&gt;port;</span>
<span class="p_add">+	if (atomic_dec_and_test(&amp;vxlan-&gt;refcount)) {</span>
<span class="p_add">+		radix_tree_delete(&amp;vxlan_db-&gt;tree, port);</span>
<span class="p_add">+		remove = true;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	__mlx5e_vxlan_core_del_port(priv, port);</span>
<span class="p_add">+out_unlock:</span>
<span class="p_add">+	spin_unlock_bh(&amp;vxlan_db-&gt;lock);</span>
 
<span class="p_add">+	if (remove) {</span>
<span class="p_add">+		mlx5e_vxlan_core_del_port_cmd(priv-&gt;mdev, port);</span>
<span class="p_add">+		kfree(vxlan);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	mutex_unlock(&amp;priv-&gt;state_lock);</span>
 	kfree(vxlan_work);
 }
 
<span class="p_chunk">@@ -171,12 +180,11 @@</span> <span class="p_context"> void mlx5e_vxlan_cleanup(struct mlx5e_priv *priv)</span>
 	struct mlx5e_vxlan *vxlan;
 	unsigned int port = 0;
 
<span class="p_del">-	spin_lock_irq(&amp;vxlan_db-&gt;lock);</span>
<span class="p_add">+	/* Lockless since we are the only radix-tree consumers, wq is disabled */</span>
 	while (radix_tree_gang_lookup(&amp;vxlan_db-&gt;tree, (void **)&amp;vxlan, port, 1)) {
 		port = vxlan-&gt;udp_port;
<span class="p_del">-		spin_unlock_irq(&amp;vxlan_db-&gt;lock);</span>
<span class="p_del">-		__mlx5e_vxlan_core_del_port(priv, (u16)port);</span>
<span class="p_del">-		spin_lock_irq(&amp;vxlan_db-&gt;lock);</span>
<span class="p_add">+		radix_tree_delete(&amp;vxlan_db-&gt;tree, port);</span>
<span class="p_add">+		mlx5e_vxlan_core_del_port_cmd(priv-&gt;mdev, port);</span>
<span class="p_add">+		kfree(vxlan);</span>
 	}
<span class="p_del">-	spin_unlock_irq(&amp;vxlan_db-&gt;lock);</span>
 }
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/vxlan.h b/drivers/net/ethernet/mellanox/mlx5/core/vxlan.h</span>
<span class="p_header">index 5def12c048e3..5ef6ae7d568a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/vxlan.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/vxlan.h</span>
<span class="p_chunk">@@ -36,6 +36,7 @@</span> <span class="p_context"></span>
 #include &quot;en.h&quot;
 
 struct mlx5e_vxlan {
<span class="p_add">+	atomic_t refcount;</span>
 	u16 udp_port;
 };
 
<span class="p_header">diff --git a/drivers/net/phy/micrel.c b/drivers/net/phy/micrel.c</span>
<span class="p_header">index fbf5945ce00d..2032a6de026b 100644</span>
<span class="p_header">--- a/drivers/net/phy/micrel.c</span>
<span class="p_header">+++ b/drivers/net/phy/micrel.c</span>
<span class="p_chunk">@@ -624,6 +624,7 @@</span> <span class="p_context"> static int ksz9031_read_status(struct phy_device *phydev)</span>
 		phydev-&gt;link = 0;
 		if (phydev-&gt;drv-&gt;config_intr &amp;&amp; phy_interrupt_is_valid(phydev))
 			phydev-&gt;drv-&gt;config_intr(phydev);
<span class="p_add">+		return genphy_config_aneg(phydev);</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/drivers/net/usb/qmi_wwan.c b/drivers/net/usb/qmi_wwan.c</span>
<span class="p_header">index 105fbfb47e3a..db65d9ad4488 100644</span>
<span class="p_header">--- a/drivers/net/usb/qmi_wwan.c</span>
<span class="p_header">+++ b/drivers/net/usb/qmi_wwan.c</span>
<span class="p_chunk">@@ -907,6 +907,7 @@</span> <span class="p_context"> static const struct usb_device_id products[] = {</span>
 	{QMI_FIXED_INTF(0x1199, 0x9079, 10)},	/* Sierra Wireless EM74xx */
 	{QMI_FIXED_INTF(0x1199, 0x907b, 8)},	/* Sierra Wireless EM74xx */
 	{QMI_FIXED_INTF(0x1199, 0x907b, 10)},	/* Sierra Wireless EM74xx */
<span class="p_add">+	{QMI_FIXED_INTF(0x1199, 0x9091, 8)},	/* Sierra Wireless EM7565 */</span>
 	{QMI_FIXED_INTF(0x1bbb, 0x011e, 4)},	/* Telekom Speedstick LTE II (Alcatel One Touch L100V LTE) */
 	{QMI_FIXED_INTF(0x1bbb, 0x0203, 2)},	/* Alcatel L800MA */
 	{QMI_FIXED_INTF(0x2357, 0x0201, 4)},	/* TP-LINK HSUPA Modem MA180 */
<span class="p_header">diff --git a/drivers/s390/net/qeth_core.h b/drivers/s390/net/qeth_core.h</span>
<span class="p_header">index e72234efb648..9b5fc502f6a1 100644</span>
<span class="p_header">--- a/drivers/s390/net/qeth_core.h</span>
<span class="p_header">+++ b/drivers/s390/net/qeth_core.h</span>
<span class="p_chunk">@@ -576,9 +576,9 @@</span> <span class="p_context"> enum qeth_cq {</span>
 };
 
 struct qeth_ipato {
<span class="p_del">-	int enabled;</span>
<span class="p_del">-	int invert4;</span>
<span class="p_del">-	int invert6;</span>
<span class="p_add">+	bool enabled;</span>
<span class="p_add">+	bool invert4;</span>
<span class="p_add">+	bool invert6;</span>
 	struct list_head entries;
 };
 
<span class="p_header">diff --git a/drivers/s390/net/qeth_core_main.c b/drivers/s390/net/qeth_core_main.c</span>
<span class="p_header">index 838ed6213118..df8f74cb1406 100644</span>
<span class="p_header">--- a/drivers/s390/net/qeth_core_main.c</span>
<span class="p_header">+++ b/drivers/s390/net/qeth_core_main.c</span>
<span class="p_chunk">@@ -1475,9 +1475,9 @@</span> <span class="p_context"> static int qeth_setup_card(struct qeth_card *card)</span>
 	qeth_set_intial_options(card);
 	/* IP address takeover */
 	INIT_LIST_HEAD(&amp;card-&gt;ipato.entries);
<span class="p_del">-	card-&gt;ipato.enabled = 0;</span>
<span class="p_del">-	card-&gt;ipato.invert4 = 0;</span>
<span class="p_del">-	card-&gt;ipato.invert6 = 0;</span>
<span class="p_add">+	card-&gt;ipato.enabled = false;</span>
<span class="p_add">+	card-&gt;ipato.invert4 = false;</span>
<span class="p_add">+	card-&gt;ipato.invert6 = false;</span>
 	/* init QDIO stuff */
 	qeth_init_qdio_info(card);
 	INIT_DELAYED_WORK(&amp;card-&gt;buffer_reclaim_work, qeth_buffer_reclaim_work);
<span class="p_header">diff --git a/drivers/s390/net/qeth_l3.h b/drivers/s390/net/qeth_l3.h</span>
<span class="p_header">index 26f79533e62e..eedf9b01a496 100644</span>
<span class="p_header">--- a/drivers/s390/net/qeth_l3.h</span>
<span class="p_header">+++ b/drivers/s390/net/qeth_l3.h</span>
<span class="p_chunk">@@ -80,7 +80,7 @@</span> <span class="p_context"> void qeth_l3_del_vipa(struct qeth_card *, enum qeth_prot_versions, const u8 *);</span>
 int qeth_l3_add_rxip(struct qeth_card *, enum qeth_prot_versions, const u8 *);
 void qeth_l3_del_rxip(struct qeth_card *card, enum qeth_prot_versions,
 			const u8 *);
<span class="p_del">-int qeth_l3_is_addr_covered_by_ipato(struct qeth_card *, struct qeth_ipaddr *);</span>
<span class="p_add">+void qeth_l3_update_ipato(struct qeth_card *card);</span>
 struct qeth_ipaddr *qeth_l3_get_addr_buffer(enum qeth_prot_versions);
 int qeth_l3_add_ip(struct qeth_card *, struct qeth_ipaddr *);
 int qeth_l3_delete_ip(struct qeth_card *, struct qeth_ipaddr *);
<span class="p_header">diff --git a/drivers/s390/net/qeth_l3_main.c b/drivers/s390/net/qeth_l3_main.c</span>
<span class="p_header">index f91e70c369ed..1487f8a0c575 100644</span>
<span class="p_header">--- a/drivers/s390/net/qeth_l3_main.c</span>
<span class="p_header">+++ b/drivers/s390/net/qeth_l3_main.c</span>
<span class="p_chunk">@@ -168,8 +168,8 @@</span> <span class="p_context"> static void qeth_l3_convert_addr_to_bits(u8 *addr, u8 *bits, int len)</span>
 	}
 }
 
<span class="p_del">-int qeth_l3_is_addr_covered_by_ipato(struct qeth_card *card,</span>
<span class="p_del">-						struct qeth_ipaddr *addr)</span>
<span class="p_add">+static bool qeth_l3_is_addr_covered_by_ipato(struct qeth_card *card,</span>
<span class="p_add">+					     struct qeth_ipaddr *addr)</span>
 {
 	struct qeth_ipato_entry *ipatoe;
 	u8 addr_bits[128] = {0, };
<span class="p_chunk">@@ -178,6 +178,8 @@</span> <span class="p_context"> int qeth_l3_is_addr_covered_by_ipato(struct qeth_card *card,</span>
 
 	if (!card-&gt;ipato.enabled)
 		return 0;
<span class="p_add">+	if (addr-&gt;type != QETH_IP_TYPE_NORMAL)</span>
<span class="p_add">+		return 0;</span>
 
 	qeth_l3_convert_addr_to_bits((u8 *) &amp;addr-&gt;u, addr_bits,
 				  (addr-&gt;proto == QETH_PROT_IPV4)? 4:16);
<span class="p_chunk">@@ -293,8 +295,7 @@</span> <span class="p_context"> int qeth_l3_add_ip(struct qeth_card *card, struct qeth_ipaddr *tmp_addr)</span>
 		memcpy(addr, tmp_addr, sizeof(struct qeth_ipaddr));
 		addr-&gt;ref_counter = 1;
 
<span class="p_del">-		if (addr-&gt;type == QETH_IP_TYPE_NORMAL  &amp;&amp;</span>
<span class="p_del">-				qeth_l3_is_addr_covered_by_ipato(card, addr)) {</span>
<span class="p_add">+		if (qeth_l3_is_addr_covered_by_ipato(card, addr)) {</span>
 			QETH_CARD_TEXT(card, 2, &quot;tkovaddr&quot;);
 			addr-&gt;set_flags |= QETH_IPA_SETIP_TAKEOVER_FLAG;
 		}
<span class="p_chunk">@@ -607,6 +608,27 @@</span> <span class="p_context"> int qeth_l3_setrouting_v6(struct qeth_card *card)</span>
 /*
  * IP address takeover related functions
  */
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * qeth_l3_update_ipato() - Update &#39;takeover&#39; property, for all NORMAL IPs.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Caller must hold ip_lock.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void qeth_l3_update_ipato(struct qeth_card *card)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct qeth_ipaddr *addr;</span>
<span class="p_add">+	unsigned int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	hash_for_each(card-&gt;ip_htable, i, addr, hnode) {</span>
<span class="p_add">+		if (addr-&gt;type != QETH_IP_TYPE_NORMAL)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if (qeth_l3_is_addr_covered_by_ipato(card, addr))</span>
<span class="p_add">+			addr-&gt;set_flags |= QETH_IPA_SETIP_TAKEOVER_FLAG;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			addr-&gt;set_flags &amp;= ~QETH_IPA_SETIP_TAKEOVER_FLAG;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void qeth_l3_clear_ipato_list(struct qeth_card *card)
 {
 	struct qeth_ipato_entry *ipatoe, *tmp;
<span class="p_chunk">@@ -618,6 +640,7 @@</span> <span class="p_context"> static void qeth_l3_clear_ipato_list(struct qeth_card *card)</span>
 		kfree(ipatoe);
 	}
 
<span class="p_add">+	qeth_l3_update_ipato(card);</span>
 	spin_unlock_bh(&amp;card-&gt;ip_lock);
 }
 
<span class="p_chunk">@@ -642,8 +665,10 @@</span> <span class="p_context"> int qeth_l3_add_ipato_entry(struct qeth_card *card,</span>
 		}
 	}
 
<span class="p_del">-	if (!rc)</span>
<span class="p_add">+	if (!rc) {</span>
 		list_add_tail(&amp;new-&gt;entry, &amp;card-&gt;ipato.entries);
<span class="p_add">+		qeth_l3_update_ipato(card);</span>
<span class="p_add">+	}</span>
 
 	spin_unlock_bh(&amp;card-&gt;ip_lock);
 
<span class="p_chunk">@@ -666,6 +691,7 @@</span> <span class="p_context"> void qeth_l3_del_ipato_entry(struct qeth_card *card,</span>
 			    (proto == QETH_PROT_IPV4)? 4:16) &amp;&amp;
 		    (ipatoe-&gt;mask_bits == mask_bits)) {
 			list_del(&amp;ipatoe-&gt;entry);
<span class="p_add">+			qeth_l3_update_ipato(card);</span>
 			kfree(ipatoe);
 		}
 	}
<span class="p_header">diff --git a/drivers/s390/net/qeth_l3_sys.c b/drivers/s390/net/qeth_l3_sys.c</span>
<span class="p_header">index cffe42f5775d..d6bdfc6e905a 100644</span>
<span class="p_header">--- a/drivers/s390/net/qeth_l3_sys.c</span>
<span class="p_header">+++ b/drivers/s390/net/qeth_l3_sys.c</span>
<span class="p_chunk">@@ -372,8 +372,8 @@</span> <span class="p_context"> static ssize_t qeth_l3_dev_ipato_enable_store(struct device *dev,</span>
 		struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct qeth_card *card = dev_get_drvdata(dev);
<span class="p_del">-	struct qeth_ipaddr *addr;</span>
<span class="p_del">-	int i, rc = 0;</span>
<span class="p_add">+	bool enable;</span>
<span class="p_add">+	int rc = 0;</span>
 
 	if (!card)
 		return -EINVAL;
<span class="p_chunk">@@ -386,25 +386,18 @@</span> <span class="p_context"> static ssize_t qeth_l3_dev_ipato_enable_store(struct device *dev,</span>
 	}
 
 	if (sysfs_streq(buf, &quot;toggle&quot;)) {
<span class="p_del">-		card-&gt;ipato.enabled = (card-&gt;ipato.enabled)? 0 : 1;</span>
<span class="p_del">-	} else if (sysfs_streq(buf, &quot;1&quot;)) {</span>
<span class="p_del">-		card-&gt;ipato.enabled = 1;</span>
<span class="p_del">-		hash_for_each(card-&gt;ip_htable, i, addr, hnode) {</span>
<span class="p_del">-				if ((addr-&gt;type == QETH_IP_TYPE_NORMAL) &amp;&amp;</span>
<span class="p_del">-				qeth_l3_is_addr_covered_by_ipato(card, addr))</span>
<span class="p_del">-					addr-&gt;set_flags |=</span>
<span class="p_del">-					QETH_IPA_SETIP_TAKEOVER_FLAG;</span>
<span class="p_del">-			}</span>
<span class="p_del">-	} else if (sysfs_streq(buf, &quot;0&quot;)) {</span>
<span class="p_del">-		card-&gt;ipato.enabled = 0;</span>
<span class="p_del">-		hash_for_each(card-&gt;ip_htable, i, addr, hnode) {</span>
<span class="p_del">-			if (addr-&gt;set_flags &amp;</span>
<span class="p_del">-			QETH_IPA_SETIP_TAKEOVER_FLAG)</span>
<span class="p_del">-				addr-&gt;set_flags &amp;=</span>
<span class="p_del">-				~QETH_IPA_SETIP_TAKEOVER_FLAG;</span>
<span class="p_del">-			}</span>
<span class="p_del">-	} else</span>
<span class="p_add">+		enable = !card-&gt;ipato.enabled;</span>
<span class="p_add">+	} else if (kstrtobool(buf, &amp;enable)) {</span>
 		rc = -EINVAL;
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (card-&gt;ipato.enabled != enable) {</span>
<span class="p_add">+		card-&gt;ipato.enabled = enable;</span>
<span class="p_add">+		spin_lock_bh(&amp;card-&gt;ip_lock);</span>
<span class="p_add">+		qeth_l3_update_ipato(card);</span>
<span class="p_add">+		spin_unlock_bh(&amp;card-&gt;ip_lock);</span>
<span class="p_add">+	}</span>
 out:
 	mutex_unlock(&amp;card-&gt;conf_mutex);
 	return rc ? rc : count;
<span class="p_chunk">@@ -430,20 +423,27 @@</span> <span class="p_context"> static ssize_t qeth_l3_dev_ipato_invert4_store(struct device *dev,</span>
 				const char *buf, size_t count)
 {
 	struct qeth_card *card = dev_get_drvdata(dev);
<span class="p_add">+	bool invert;</span>
 	int rc = 0;
 
 	if (!card)
 		return -EINVAL;
 
 	mutex_lock(&amp;card-&gt;conf_mutex);
<span class="p_del">-	if (sysfs_streq(buf, &quot;toggle&quot;))</span>
<span class="p_del">-		card-&gt;ipato.invert4 = (card-&gt;ipato.invert4)? 0 : 1;</span>
<span class="p_del">-	else if (sysfs_streq(buf, &quot;1&quot;))</span>
<span class="p_del">-		card-&gt;ipato.invert4 = 1;</span>
<span class="p_del">-	else if (sysfs_streq(buf, &quot;0&quot;))</span>
<span class="p_del">-		card-&gt;ipato.invert4 = 0;</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (sysfs_streq(buf, &quot;toggle&quot;)) {</span>
<span class="p_add">+		invert = !card-&gt;ipato.invert4;</span>
<span class="p_add">+	} else if (kstrtobool(buf, &amp;invert)) {</span>
 		rc = -EINVAL;
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (card-&gt;ipato.invert4 != invert) {</span>
<span class="p_add">+		card-&gt;ipato.invert4 = invert;</span>
<span class="p_add">+		spin_lock_bh(&amp;card-&gt;ip_lock);</span>
<span class="p_add">+		qeth_l3_update_ipato(card);</span>
<span class="p_add">+		spin_unlock_bh(&amp;card-&gt;ip_lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+out:</span>
 	mutex_unlock(&amp;card-&gt;conf_mutex);
 	return rc ? rc : count;
 }
<span class="p_chunk">@@ -609,20 +609,27 @@</span> <span class="p_context"> static ssize_t qeth_l3_dev_ipato_invert6_store(struct device *dev,</span>
 		struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct qeth_card *card = dev_get_drvdata(dev);
<span class="p_add">+	bool invert;</span>
 	int rc = 0;
 
 	if (!card)
 		return -EINVAL;
 
 	mutex_lock(&amp;card-&gt;conf_mutex);
<span class="p_del">-	if (sysfs_streq(buf, &quot;toggle&quot;))</span>
<span class="p_del">-		card-&gt;ipato.invert6 = (card-&gt;ipato.invert6)? 0 : 1;</span>
<span class="p_del">-	else if (sysfs_streq(buf, &quot;1&quot;))</span>
<span class="p_del">-		card-&gt;ipato.invert6 = 1;</span>
<span class="p_del">-	else if (sysfs_streq(buf, &quot;0&quot;))</span>
<span class="p_del">-		card-&gt;ipato.invert6 = 0;</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (sysfs_streq(buf, &quot;toggle&quot;)) {</span>
<span class="p_add">+		invert = !card-&gt;ipato.invert6;</span>
<span class="p_add">+	} else if (kstrtobool(buf, &amp;invert)) {</span>
 		rc = -EINVAL;
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (card-&gt;ipato.invert6 != invert) {</span>
<span class="p_add">+		card-&gt;ipato.invert6 = invert;</span>
<span class="p_add">+		spin_lock_bh(&amp;card-&gt;ip_lock);</span>
<span class="p_add">+		qeth_l3_update_ipato(card);</span>
<span class="p_add">+		spin_unlock_bh(&amp;card-&gt;ip_lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+out:</span>
 	mutex_unlock(&amp;card-&gt;conf_mutex);
 	return rc ? rc : count;
 }
<span class="p_header">diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c</span>
<span class="p_header">index bdf0e6e89991..faf50df81622 100644</span>
<span class="p_header">--- a/drivers/tty/n_tty.c</span>
<span class="p_header">+++ b/drivers/tty/n_tty.c</span>
<span class="p_chunk">@@ -1764,7 +1764,7 @@</span> <span class="p_context"> static void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)</span>
 {
 	struct n_tty_data *ldata = tty-&gt;disc_data;
 
<span class="p_del">-	if (!old || (old-&gt;c_lflag ^ tty-&gt;termios.c_lflag) &amp; ICANON) {</span>
<span class="p_add">+	if (!old || (old-&gt;c_lflag ^ tty-&gt;termios.c_lflag) &amp; (ICANON | EXTPROC)) {</span>
 		bitmap_zero(ldata-&gt;read_flags, N_TTY_BUF_SIZE);
 		ldata-&gt;line_start = ldata-&gt;read_tail;
 		if (!L_ICANON(tty) || !read_cnt(ldata)) {
<span class="p_chunk">@@ -2427,7 +2427,7 @@</span> <span class="p_context"> static int n_tty_ioctl(struct tty_struct *tty, struct file *file,</span>
 		return put_user(tty_chars_in_buffer(tty), (int __user *) arg);
 	case TIOCINQ:
 		down_write(&amp;tty-&gt;termios_rwsem);
<span class="p_del">-		if (L_ICANON(tty))</span>
<span class="p_add">+		if (L_ICANON(tty) &amp;&amp; !L_EXTPROC(tty))</span>
 			retval = inq_canon(ldata);
 		else
 			retval = read_cnt(ldata);
<span class="p_header">diff --git a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c</span>
<span class="p_header">index c220c2c0893f..e99f1c5b1df6 100644</span>
<span class="p_header">--- a/drivers/tty/tty_buffer.c</span>
<span class="p_header">+++ b/drivers/tty/tty_buffer.c</span>
<span class="p_chunk">@@ -446,7 +446,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(tty_prepare_flip_string);</span>
  *	Callers other than flush_to_ldisc() need to exclude the kworker
  *	from concurrent use of the line discipline, see paste_selection().
  *
<span class="p_del">- *	Returns the number of bytes not processed</span>
<span class="p_add">+ *	Returns the number of bytes processed</span>
  */
 int tty_ldisc_receive_buf(struct tty_ldisc *ld, unsigned char *p,
 			  char *f, int count)
<span class="p_header">diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c</span>
<span class="p_header">index ba9b29bc441f..7c54a19b20e0 100644</span>
<span class="p_header">--- a/drivers/usb/core/config.c</span>
<span class="p_header">+++ b/drivers/usb/core/config.c</span>
<span class="p_chunk">@@ -1002,7 +1002,7 @@</span> <span class="p_context"> int usb_get_bos_descriptor(struct usb_device *dev)</span>
 		case USB_SSP_CAP_TYPE:
 			ssp_cap = (struct usb_ssp_cap_descriptor *)buffer;
 			ssac = (le32_to_cpu(ssp_cap-&gt;bmAttributes) &amp;
<span class="p_del">-				USB_SSP_SUBLINK_SPEED_ATTRIBS) + 1;</span>
<span class="p_add">+				USB_SSP_SUBLINK_SPEED_ATTRIBS);</span>
 			if (length &gt;= USB_DT_USB_SSP_CAP_SIZE(ssac))
 				dev-&gt;bos-&gt;ssp_cap = ssp_cap;
 			break;
<span class="p_header">diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c</span>
<span class="p_header">index 50010282c010..c05c4f877750 100644</span>
<span class="p_header">--- a/drivers/usb/core/quirks.c</span>
<span class="p_header">+++ b/drivers/usb/core/quirks.c</span>
<span class="p_chunk">@@ -57,10 +57,11 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	/* Microsoft LifeCam-VX700 v2.0 */
 	{ USB_DEVICE(0x045e, 0x0770), .driver_info = USB_QUIRK_RESET_RESUME },
 
<span class="p_del">-	/* Logitech HD Pro Webcams C920, C920-C and C930e */</span>
<span class="p_add">+	/* Logitech HD Pro Webcams C920, C920-C, C925e and C930e */</span>
 	{ USB_DEVICE(0x046d, 0x082d), .driver_info = USB_QUIRK_DELAY_INIT },
 	{ USB_DEVICE(0x046d, 0x0841), .driver_info = USB_QUIRK_DELAY_INIT },
 	{ USB_DEVICE(0x046d, 0x0843), .driver_info = USB_QUIRK_DELAY_INIT },
<span class="p_add">+	{ USB_DEVICE(0x046d, 0x085b), .driver_info = USB_QUIRK_DELAY_INIT },</span>
 
 	/* Logitech ConferenceCam CC3000e */
 	{ USB_DEVICE(0x046d, 0x0847), .driver_info = USB_QUIRK_DELAY_INIT },
<span class="p_chunk">@@ -154,6 +155,9 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	/* Genesys Logic hub, internally used by KY-688 USB 3.1 Type-C Hub */
 	{ USB_DEVICE(0x05e3, 0x0612), .driver_info = USB_QUIRK_NO_LPM },
 
<span class="p_add">+	/* ELSA MicroLink 56K */</span>
<span class="p_add">+	{ USB_DEVICE(0x05cc, 0x2267), .driver_info = USB_QUIRK_RESET_RESUME },</span>
<span class="p_add">+</span>
 	/* Genesys Logic hub, internally used by Moshi USB to Ethernet Adapter */
 	{ USB_DEVICE(0x05e3, 0x0616), .driver_info = USB_QUIRK_NO_LPM },
 
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index c87ef38e7416..f6782a347cde 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -189,6 +189,9 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 		xhci-&gt;quirks |= XHCI_TRUST_TX_LENGTH;
 		xhci-&gt;quirks |= XHCI_BROKEN_STREAMS;
 	}
<span class="p_add">+	if (pdev-&gt;vendor == PCI_VENDOR_ID_RENESAS &amp;&amp;</span>
<span class="p_add">+			pdev-&gt;device == 0x0014)</span>
<span class="p_add">+		xhci-&gt;quirks |= XHCI_TRUST_TX_LENGTH;</span>
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_RENESAS &amp;&amp;
 			pdev-&gt;device == 0x0015)
 		xhci-&gt;quirks |= XHCI_RESET_ON_RESUME;
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index 3249f42b4b93..0c743e4cca1e 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -1017,6 +1017,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 		.driver_info = (kernel_ulong_t)&amp;ftdi_jtag_quirk },
 	{ USB_DEVICE(CYPRESS_VID, CYPRESS_WICED_BT_USB_PID) },
 	{ USB_DEVICE(CYPRESS_VID, CYPRESS_WICED_WL_USB_PID) },
<span class="p_add">+	{ USB_DEVICE(AIRBUS_DS_VID, AIRBUS_DS_P8GR) },</span>
 	{ }					/* Terminating entry */
 };
 
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index f9d15bd62785..543d2801632b 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -913,6 +913,12 @@</span> <span class="p_context"></span>
 #define ICPDAS_I7561U_PID		0x0104
 #define ICPDAS_I7563U_PID		0x0105
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Airbus Defence and Space</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define AIRBUS_DS_VID			0x1e8e  /* Vendor ID */</span>
<span class="p_add">+#define AIRBUS_DS_P8GR			0x6001  /* Tetra P8GR */</span>
<span class="p_add">+</span>
 /*
  * RT Systems programming cables for various ham radios
  */
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index ffa8ec917ff5..a818c43a02ec 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -236,6 +236,8 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 /* These Quectel products use Qualcomm&#39;s vendor ID */
 #define QUECTEL_PRODUCT_UC20			0x9003
 #define QUECTEL_PRODUCT_UC15			0x9090
<span class="p_add">+/* These Yuga products use Qualcomm&#39;s vendor ID */</span>
<span class="p_add">+#define YUGA_PRODUCT_CLM920_NC5			0x9625</span>
 
 #define QUECTEL_VENDOR_ID			0x2c7c
 /* These Quectel products use Quectel&#39;s vendor ID */
<span class="p_chunk">@@ -283,6 +285,7 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define TELIT_PRODUCT_LE922_USBCFG3		0x1043
 #define TELIT_PRODUCT_LE922_USBCFG5		0x1045
 #define TELIT_PRODUCT_ME910			0x1100
<span class="p_add">+#define TELIT_PRODUCT_ME910_DUAL_MODEM		0x1101</span>
 #define TELIT_PRODUCT_LE920			0x1200
 #define TELIT_PRODUCT_LE910			0x1201
 #define TELIT_PRODUCT_LE910_USBCFG4		0x1206
<span class="p_chunk">@@ -648,6 +651,11 @@</span> <span class="p_context"> static const struct option_blacklist_info telit_me910_blacklist = {</span>
 	.reserved = BIT(1) | BIT(3),
 };
 
<span class="p_add">+static const struct option_blacklist_info telit_me910_dual_modem_blacklist = {</span>
<span class="p_add">+	.sendsetup = BIT(0),</span>
<span class="p_add">+	.reserved = BIT(3),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct option_blacklist_info telit_le910_blacklist = {
 	.sendsetup = BIT(0),
 	.reserved = BIT(1) | BIT(2),
<span class="p_chunk">@@ -677,6 +685,10 @@</span> <span class="p_context"> static const struct option_blacklist_info cinterion_rmnet2_blacklist = {</span>
 	.reserved = BIT(4) | BIT(5),
 };
 
<span class="p_add">+static const struct option_blacklist_info yuga_clm920_nc5_blacklist = {</span>
<span class="p_add">+	.reserved = BIT(1) | BIT(4),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) },
<span class="p_chunk">@@ -1181,6 +1193,9 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, QUECTEL_PRODUCT_UC15)},
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, QUECTEL_PRODUCT_UC20),
 	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
<span class="p_add">+	/* Yuga products use Qualcomm vendor ID */</span>
<span class="p_add">+	{ USB_DEVICE(QUALCOMM_VENDOR_ID, YUGA_PRODUCT_CLM920_NC5),</span>
<span class="p_add">+	  .driver_info = (kernel_ulong_t)&amp;yuga_clm920_nc5_blacklist },</span>
 	/* Quectel products using Quectel vendor ID */
 	{ USB_DEVICE(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EC21),
 	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
<span class="p_chunk">@@ -1247,6 +1262,8 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg0 },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_ME910),
 		.driver_info = (kernel_ulong_t)&amp;telit_me910_blacklist },
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_ME910_DUAL_MODEM),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_me910_dual_modem_blacklist },</span>
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE910),
 		.driver_info = (kernel_ulong_t)&amp;telit_le910_blacklist },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE910_USBCFG4),
<span class="p_header">diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c</span>
<span class="p_header">index 4516291df1b8..fb6dc16c754a 100644</span>
<span class="p_header">--- a/drivers/usb/serial/qcserial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/qcserial.c</span>
<span class="p_chunk">@@ -166,6 +166,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{DEVICE_SWI(0x1199, 0x9079)},	/* Sierra Wireless EM74xx */
 	{DEVICE_SWI(0x1199, 0x907a)},	/* Sierra Wireless EM74xx QDL */
 	{DEVICE_SWI(0x1199, 0x907b)},	/* Sierra Wireless EM74xx */
<span class="p_add">+	{DEVICE_SWI(0x1199, 0x9090)},	/* Sierra Wireless EM7565 QDL */</span>
<span class="p_add">+	{DEVICE_SWI(0x1199, 0x9091)},	/* Sierra Wireless EM7565 */</span>
 	{DEVICE_SWI(0x413c, 0x81a2)},	/* Dell Wireless 5806 Gobi(TM) 4G LTE Mobile Broadband Card */
 	{DEVICE_SWI(0x413c, 0x81a3)},	/* Dell Wireless 5570 HSPA+ (42Mbps) Mobile Broadband Card */
 	{DEVICE_SWI(0x413c, 0x81a4)},	/* Dell Wireless 5570e HSPA+ (42Mbps) Mobile Broadband Card */
<span class="p_chunk">@@ -346,6 +348,7 @@</span> <span class="p_context"> static int qcprobe(struct usb_serial *serial, const struct usb_device_id *id)</span>
 			break;
 		case 2:
 			dev_dbg(dev, &quot;NMEA GPS interface found\n&quot;);
<span class="p_add">+			sendsetup = true;</span>
 			break;
 		case 3:
 			dev_dbg(dev, &quot;Modem port found\n&quot;);
<span class="p_header">diff --git a/drivers/usb/usbip/stub_dev.c b/drivers/usb/usbip/stub_dev.c</span>
<span class="p_header">index c653ce533430..1886d8e4f14e 100644</span>
<span class="p_header">--- a/drivers/usb/usbip/stub_dev.c</span>
<span class="p_header">+++ b/drivers/usb/usbip/stub_dev.c</span>
<span class="p_chunk">@@ -163,8 +163,7 @@</span> <span class="p_context"> static void stub_shutdown_connection(struct usbip_device *ud)</span>
 	 * step 1?
 	 */
 	if (ud-&gt;tcp_socket) {
<span class="p_del">-		dev_dbg(&amp;sdev-&gt;udev-&gt;dev, &quot;shutdown tcp_socket %p\n&quot;,</span>
<span class="p_del">-			ud-&gt;tcp_socket);</span>
<span class="p_add">+		dev_dbg(&amp;sdev-&gt;udev-&gt;dev, &quot;shutdown sockfd\n&quot;);</span>
 		kernel_sock_shutdown(ud-&gt;tcp_socket, SHUT_RDWR);
 	}
 
<span class="p_header">diff --git a/drivers/usb/usbip/stub_main.c b/drivers/usb/usbip/stub_main.c</span>
<span class="p_header">index af10f7b131a4..325b4c05acdd 100644</span>
<span class="p_header">--- a/drivers/usb/usbip/stub_main.c</span>
<span class="p_header">+++ b/drivers/usb/usbip/stub_main.c</span>
<span class="p_chunk">@@ -252,11 +252,12 @@</span> <span class="p_context"> void stub_device_cleanup_urbs(struct stub_device *sdev)</span>
 	struct stub_priv *priv;
 	struct urb *urb;
 
<span class="p_del">-	dev_dbg(&amp;sdev-&gt;udev-&gt;dev, &quot;free sdev %p\n&quot;, sdev);</span>
<span class="p_add">+	dev_dbg(&amp;sdev-&gt;udev-&gt;dev, &quot;Stub device cleaning up urbs\n&quot;);</span>
 
 	while ((priv = stub_priv_pop(sdev))) {
 		urb = priv-&gt;urb;
<span class="p_del">-		dev_dbg(&amp;sdev-&gt;udev-&gt;dev, &quot;free urb %p\n&quot;, urb);</span>
<span class="p_add">+		dev_dbg(&amp;sdev-&gt;udev-&gt;dev, &quot;free urb seqnum %lu\n&quot;,</span>
<span class="p_add">+			priv-&gt;seqnum);</span>
 		usb_kill_urb(urb);
 
 		kmem_cache_free(stub_priv_cache, priv);
<span class="p_header">diff --git a/drivers/usb/usbip/stub_rx.c b/drivers/usb/usbip/stub_rx.c</span>
<span class="p_header">index 283a9be77a22..5b807185f79e 100644</span>
<span class="p_header">--- a/drivers/usb/usbip/stub_rx.c</span>
<span class="p_header">+++ b/drivers/usb/usbip/stub_rx.c</span>
<span class="p_chunk">@@ -225,9 +225,6 @@</span> <span class="p_context"> static int stub_recv_cmd_unlink(struct stub_device *sdev,</span>
 		if (priv-&gt;seqnum != pdu-&gt;u.cmd_unlink.seqnum)
 			continue;
 
<span class="p_del">-		dev_info(&amp;priv-&gt;urb-&gt;dev-&gt;dev, &quot;unlink urb %p\n&quot;,</span>
<span class="p_del">-			 priv-&gt;urb);</span>
<span class="p_del">-</span>
 		/*
 		 * This matched urb is not completed yet (i.e., be in
 		 * flight in usb hcd hardware/driver). Now we are
<span class="p_chunk">@@ -266,8 +263,8 @@</span> <span class="p_context"> static int stub_recv_cmd_unlink(struct stub_device *sdev,</span>
 		ret = usb_unlink_urb(priv-&gt;urb);
 		if (ret != -EINPROGRESS)
 			dev_err(&amp;priv-&gt;urb-&gt;dev-&gt;dev,
<span class="p_del">-				&quot;failed to unlink a urb %p, ret %d\n&quot;,</span>
<span class="p_del">-				priv-&gt;urb, ret);</span>
<span class="p_add">+				&quot;failed to unlink a urb # %lu, ret %d\n&quot;,</span>
<span class="p_add">+				priv-&gt;seqnum, ret);</span>
 
 		return 0;
 	}
<span class="p_header">diff --git a/drivers/usb/usbip/stub_tx.c b/drivers/usb/usbip/stub_tx.c</span>
<span class="p_header">index 87ff94be4235..96aa375b80d9 100644</span>
<span class="p_header">--- a/drivers/usb/usbip/stub_tx.c</span>
<span class="p_header">+++ b/drivers/usb/usbip/stub_tx.c</span>
<span class="p_chunk">@@ -102,7 +102,7 @@</span> <span class="p_context"> void stub_complete(struct urb *urb)</span>
 	/* link a urb to the queue of tx. */
 	spin_lock_irqsave(&amp;sdev-&gt;priv_lock, flags);
 	if (sdev-&gt;ud.tcp_socket == NULL) {
<span class="p_del">-		usbip_dbg_stub_tx(&quot;ignore urb for closed connection %p&quot;, urb);</span>
<span class="p_add">+		usbip_dbg_stub_tx(&quot;ignore urb for closed connection\n&quot;);</span>
 		/* It will be freed in stub_device_cleanup_urbs(). */
 	} else if (priv-&gt;unlinking) {
 		stub_enqueue_ret_unlink(sdev, priv-&gt;seqnum, urb-&gt;status);
<span class="p_chunk">@@ -204,8 +204,8 @@</span> <span class="p_context"> static int stub_send_ret_submit(struct stub_device *sdev)</span>
 
 		/* 1. setup usbip_header */
 		setup_ret_submit_pdu(&amp;pdu_header, urb);
<span class="p_del">-		usbip_dbg_stub_tx(&quot;setup txdata seqnum: %d urb: %p\n&quot;,</span>
<span class="p_del">-				  pdu_header.base.seqnum, urb);</span>
<span class="p_add">+		usbip_dbg_stub_tx(&quot;setup txdata seqnum: %d\n&quot;,</span>
<span class="p_add">+				  pdu_header.base.seqnum);</span>
 		usbip_header_correct_endian(&amp;pdu_header, 1);
 
 		iov[iovnum].iov_base = &amp;pdu_header;
<span class="p_header">diff --git a/drivers/usb/usbip/usbip_common.c b/drivers/usb/usbip/usbip_common.c</span>
<span class="p_header">index 8b232290be6b..e24b24fa0f16 100644</span>
<span class="p_header">--- a/drivers/usb/usbip/usbip_common.c</span>
<span class="p_header">+++ b/drivers/usb/usbip/usbip_common.c</span>
<span class="p_chunk">@@ -335,13 +335,10 @@</span> <span class="p_context"> int usbip_recv(struct socket *sock, void *buf, int size)</span>
 	char *bp = buf;
 	int osize = size;
 
<span class="p_del">-	usbip_dbg_xmit(&quot;enter\n&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!sock || !buf || !size) {</span>
<span class="p_del">-		pr_err(&quot;invalid arg, sock %p buff %p size %d\n&quot;, sock, buf,</span>
<span class="p_del">-		       size);</span>
<span class="p_add">+	if (!sock || !buf || !size)</span>
 		return -EINVAL;
<span class="p_del">-	}</span>
<span class="p_add">+</span>
<span class="p_add">+	usbip_dbg_xmit(&quot;enter\n&quot;);</span>
 
 	do {
 		sock-&gt;sk-&gt;sk_allocation = GFP_NOIO;
<span class="p_chunk">@@ -354,11 +351,8 @@</span> <span class="p_context"> int usbip_recv(struct socket *sock, void *buf, int size)</span>
 		msg.msg_flags      = MSG_NOSIGNAL;
 
 		result = kernel_recvmsg(sock, &amp;msg, &amp;iov, 1, size, MSG_WAITALL);
<span class="p_del">-		if (result &lt;= 0) {</span>
<span class="p_del">-			pr_debug(&quot;receive sock %p buf %p size %u ret %d total %d\n&quot;,</span>
<span class="p_del">-				 sock, buf, size, result, total);</span>
<span class="p_add">+		if (result &lt;= 0)</span>
 			goto err;
<span class="p_del">-		}</span>
 
 		size -= result;
 		buf += result;
<span class="p_header">diff --git a/drivers/usb/usbip/vhci_hcd.c b/drivers/usb/usbip/vhci_hcd.c</span>
<span class="p_header">index d6dc165e924b..7f161b095176 100644</span>
<span class="p_header">--- a/drivers/usb/usbip/vhci_hcd.c</span>
<span class="p_header">+++ b/drivers/usb/usbip/vhci_hcd.c</span>
<span class="p_chunk">@@ -506,9 +506,6 @@</span> <span class="p_context"> static int vhci_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,</span>
 	struct vhci_device *vdev;
 	unsigned long flags;
 
<span class="p_del">-	usbip_dbg_vhci_hc(&quot;enter, usb_hcd %p urb %p mem_flags %d\n&quot;,</span>
<span class="p_del">-			  hcd, urb, mem_flags);</span>
<span class="p_del">-</span>
 	if (portnum &gt; VHCI_HC_PORTS) {
 		pr_err(&quot;invalid port number %d\n&quot;, portnum);
 		return -ENODEV;
<span class="p_chunk">@@ -671,8 +668,6 @@</span> <span class="p_context"> static int vhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)</span>
 	struct vhci_device *vdev;
 	unsigned long flags;
 
<span class="p_del">-	pr_info(&quot;dequeue a urb %p\n&quot;, urb);</span>
<span class="p_del">-</span>
 	spin_lock_irqsave(&amp;vhci-&gt;lock, flags);
 
 	priv = urb-&gt;hcpriv;
<span class="p_chunk">@@ -700,7 +695,6 @@</span> <span class="p_context"> static int vhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)</span>
 		/* tcp connection is closed */
 		spin_lock(&amp;vdev-&gt;priv_lock);
 
<span class="p_del">-		pr_info(&quot;device %p seems to be disconnected\n&quot;, vdev);</span>
 		list_del(&amp;priv-&gt;list);
 		kfree(priv);
 		urb-&gt;hcpriv = NULL;
<span class="p_chunk">@@ -712,8 +706,6 @@</span> <span class="p_context"> static int vhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)</span>
 		 * vhci_rx will receive RET_UNLINK and give back the URB.
 		 * Otherwise, we give back it here.
 		 */
<span class="p_del">-		pr_info(&quot;gives back urb %p\n&quot;, urb);</span>
<span class="p_del">-</span>
 		usb_hcd_unlink_urb_from_ep(hcd, urb);
 
 		spin_unlock_irqrestore(&amp;vhci-&gt;lock, flags);
<span class="p_chunk">@@ -741,8 +733,6 @@</span> <span class="p_context"> static int vhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)</span>
 
 		unlink-&gt;unlink_seqnum = priv-&gt;seqnum;
 
<span class="p_del">-		pr_info(&quot;device %p seems to be still connected\n&quot;, vdev);</span>
<span class="p_del">-</span>
 		/* send cmd_unlink and try to cancel the pending URB in the
 		 * peer */
 		list_add_tail(&amp;unlink-&gt;list, &amp;vdev-&gt;unlink_tx);
<span class="p_chunk">@@ -823,7 +813,7 @@</span> <span class="p_context"> static void vhci_shutdown_connection(struct usbip_device *ud)</span>
 
 	/* need this? see stub_dev.c */
 	if (ud-&gt;tcp_socket) {
<span class="p_del">-		pr_debug(&quot;shutdown tcp_socket %p\n&quot;, ud-&gt;tcp_socket);</span>
<span class="p_add">+		pr_debug(&quot;shutdown tcp_socket\n&quot;);</span>
 		kernel_sock_shutdown(ud-&gt;tcp_socket, SHUT_RDWR);
 	}
 
<span class="p_header">diff --git a/drivers/usb/usbip/vhci_rx.c b/drivers/usb/usbip/vhci_rx.c</span>
<span class="p_header">index fc2d319e2360..5943deeec115 100644</span>
<span class="p_header">--- a/drivers/usb/usbip/vhci_rx.c</span>
<span class="p_header">+++ b/drivers/usb/usbip/vhci_rx.c</span>
<span class="p_chunk">@@ -37,24 +37,23 @@</span> <span class="p_context"> struct urb *pickup_urb_and_free_priv(struct vhci_device *vdev, __u32 seqnum)</span>
 		urb = priv-&gt;urb;
 		status = urb-&gt;status;
 
<span class="p_del">-		usbip_dbg_vhci_rx(&quot;find urb %p vurb %p seqnum %u\n&quot;,</span>
<span class="p_del">-				urb, priv, seqnum);</span>
<span class="p_add">+		usbip_dbg_vhci_rx(&quot;find urb seqnum %u\n&quot;, seqnum);</span>
 
 		switch (status) {
 		case -ENOENT:
 			/* fall through */
 		case -ECONNRESET:
<span class="p_del">-			dev_info(&amp;urb-&gt;dev-&gt;dev,</span>
<span class="p_del">-				 &quot;urb %p was unlinked %ssynchronuously.\n&quot;, urb,</span>
<span class="p_del">-				 status == -ENOENT ? &quot;&quot; : &quot;a&quot;);</span>
<span class="p_add">+			dev_dbg(&amp;urb-&gt;dev-&gt;dev,</span>
<span class="p_add">+				 &quot;urb seq# %u was unlinked %ssynchronuously\n&quot;,</span>
<span class="p_add">+				 seqnum, status == -ENOENT ? &quot;&quot; : &quot;a&quot;);</span>
 			break;
 		case -EINPROGRESS:
 			/* no info output */
 			break;
 		default:
<span class="p_del">-			dev_info(&amp;urb-&gt;dev-&gt;dev,</span>
<span class="p_del">-				 &quot;urb %p may be in a error, status %d\n&quot;, urb,</span>
<span class="p_del">-				 status);</span>
<span class="p_add">+			dev_dbg(&amp;urb-&gt;dev-&gt;dev,</span>
<span class="p_add">+				 &quot;urb seq# %u may be in a error, status %d\n&quot;,</span>
<span class="p_add">+				 seqnum, status);</span>
 		}
 
 		list_del(&amp;priv-&gt;list);
<span class="p_chunk">@@ -80,8 +79,8 @@</span> <span class="p_context"> static void vhci_recv_ret_submit(struct vhci_device *vdev,</span>
 	spin_unlock_irqrestore(&amp;vdev-&gt;priv_lock, flags);
 
 	if (!urb) {
<span class="p_del">-		pr_err(&quot;cannot find a urb of seqnum %u\n&quot;, pdu-&gt;base.seqnum);</span>
<span class="p_del">-		pr_info(&quot;max seqnum %d\n&quot;,</span>
<span class="p_add">+		pr_err(&quot;cannot find a urb of seqnum %u max seqnum %d\n&quot;,</span>
<span class="p_add">+			pdu-&gt;base.seqnum,</span>
 			atomic_read(&amp;vhci-&gt;seqnum));
 		usbip_event_add(ud, VDEV_EVENT_ERROR_TCP);
 		return;
<span class="p_chunk">@@ -104,7 +103,7 @@</span> <span class="p_context"> static void vhci_recv_ret_submit(struct vhci_device *vdev,</span>
 	if (usbip_dbg_flag_vhci_rx)
 		usbip_dump_urb(urb);
 
<span class="p_del">-	usbip_dbg_vhci_rx(&quot;now giveback urb %p\n&quot;, urb);</span>
<span class="p_add">+	usbip_dbg_vhci_rx(&quot;now giveback urb %u\n&quot;, pdu-&gt;base.seqnum);</span>
 
 	spin_lock_irqsave(&amp;vhci-&gt;lock, flags);
 	usb_hcd_unlink_urb_from_ep(vhci_to_hcd(vhci), urb);
<span class="p_chunk">@@ -170,7 +169,7 @@</span> <span class="p_context"> static void vhci_recv_ret_unlink(struct vhci_device *vdev,</span>
 		pr_info(&quot;the urb (seqnum %d) was already given back\n&quot;,
 			pdu-&gt;base.seqnum);
 	} else {
<span class="p_del">-		usbip_dbg_vhci_rx(&quot;now giveback urb %p\n&quot;, urb);</span>
<span class="p_add">+		usbip_dbg_vhci_rx(&quot;now giveback urb %d\n&quot;, pdu-&gt;base.seqnum);</span>
 
 		/* If unlink is successful, status is -ECONNRESET */
 		urb-&gt;status = pdu-&gt;u.ret_unlink.status;
<span class="p_header">diff --git a/drivers/usb/usbip/vhci_tx.c b/drivers/usb/usbip/vhci_tx.c</span>
<span class="p_header">index 3e7878fe2fd4..a9a663a578b6 100644</span>
<span class="p_header">--- a/drivers/usb/usbip/vhci_tx.c</span>
<span class="p_header">+++ b/drivers/usb/usbip/vhci_tx.c</span>
<span class="p_chunk">@@ -83,7 +83,8 @@</span> <span class="p_context"> static int vhci_send_cmd_submit(struct vhci_device *vdev)</span>
 		memset(&amp;msg, 0, sizeof(msg));
 		memset(&amp;iov, 0, sizeof(iov));
 
<span class="p_del">-		usbip_dbg_vhci_tx(&quot;setup txdata urb %p\n&quot;, urb);</span>
<span class="p_add">+		usbip_dbg_vhci_tx(&quot;setup txdata urb seqnum %lu\n&quot;,</span>
<span class="p_add">+				  priv-&gt;seqnum);</span>
 
 		/* 1. setup usbip_header */
 		setup_cmd_submit_pdu(&amp;pdu_header, urb);
<span class="p_header">diff --git a/include/linux/cpuhotplug.h b/include/linux/cpuhotplug.h</span>
<span class="p_header">index 965cc5693a46..c9447a689522 100644</span>
<span class="p_header">--- a/include/linux/cpuhotplug.h</span>
<span class="p_header">+++ b/include/linux/cpuhotplug.h</span>
<span class="p_chunk">@@ -48,7 +48,7 @@</span> <span class="p_context"> enum cpuhp_state {</span>
 	CPUHP_ARM_SHMOBILE_SCU_PREPARE,
 	CPUHP_SH_SH3X_PREPARE,
 	CPUHP_BLK_MQ_PREPARE,
<span class="p_del">-	CPUHP_TIMERS_DEAD,</span>
<span class="p_add">+	CPUHP_TIMERS_PREPARE,</span>
 	CPUHP_NOTF_ERR_INJ_PREPARE,
 	CPUHP_MIPS_SOC_PREPARE,
 	CPUHP_BRINGUP_CPU,
<span class="p_header">diff --git a/include/linux/ipv6.h b/include/linux/ipv6.h</span>
<span class="p_header">index a0649973ee5b..b9dfca557a6c 100644</span>
<span class="p_header">--- a/include/linux/ipv6.h</span>
<span class="p_header">+++ b/include/linux/ipv6.h</span>
<span class="p_chunk">@@ -246,7 +246,8 @@</span> <span class="p_context"> struct ipv6_pinfo {</span>
 						 * 100: prefer care-of address
 						 */
 				dontfrag:1,
<span class="p_del">-				autoflowlabel:1;</span>
<span class="p_add">+				autoflowlabel:1,</span>
<span class="p_add">+				autoflowlabel_set:1;</span>
 	__u8			min_hopcount;
 	__u8			tclass;
 	__be32			rcv_flowinfo;
<span class="p_header">diff --git a/include/linux/mlx5/mlx5_ifc.h b/include/linux/mlx5/mlx5_ifc.h</span>
<span class="p_header">index 6045d4d58065..25ed105bbcfb 100644</span>
<span class="p_header">--- a/include/linux/mlx5/mlx5_ifc.h</span>
<span class="p_header">+++ b/include/linux/mlx5/mlx5_ifc.h</span>
<span class="p_chunk">@@ -143,7 +143,7 @@</span> <span class="p_context"> enum {</span>
 	MLX5_CMD_OP_ALLOC_Q_COUNTER               = 0x771,
 	MLX5_CMD_OP_DEALLOC_Q_COUNTER             = 0x772,
 	MLX5_CMD_OP_QUERY_Q_COUNTER               = 0x773,
<span class="p_del">-	MLX5_CMD_OP_SET_RATE_LIMIT                = 0x780,</span>
<span class="p_add">+	MLX5_CMD_OP_SET_PP_RATE_LIMIT             = 0x780,</span>
 	MLX5_CMD_OP_QUERY_RATE_LIMIT              = 0x781,
 	MLX5_CMD_OP_ALLOC_PD                      = 0x800,
 	MLX5_CMD_OP_DEALLOC_PD                    = 0x801,
<span class="p_chunk">@@ -6689,7 +6689,7 @@</span> <span class="p_context"> struct mlx5_ifc_add_vxlan_udp_dport_in_bits {</span>
 	u8         vxlan_udp_port[0x10];
 };
 
<span class="p_del">-struct mlx5_ifc_set_rate_limit_out_bits {</span>
<span class="p_add">+struct mlx5_ifc_set_pp_rate_limit_out_bits {</span>
 	u8         status[0x8];
 	u8         reserved_at_8[0x18];
 
<span class="p_chunk">@@ -6698,7 +6698,7 @@</span> <span class="p_context"> struct mlx5_ifc_set_rate_limit_out_bits {</span>
 	u8         reserved_at_40[0x40];
 };
 
<span class="p_del">-struct mlx5_ifc_set_rate_limit_in_bits {</span>
<span class="p_add">+struct mlx5_ifc_set_pp_rate_limit_in_bits {</span>
 	u8         opcode[0x10];
 	u8         reserved_at_10[0x10];
 
<span class="p_chunk">@@ -6711,6 +6711,8 @@</span> <span class="p_context"> struct mlx5_ifc_set_rate_limit_in_bits {</span>
 	u8         reserved_at_60[0x20];
 
 	u8         rate_limit[0x20];
<span class="p_add">+</span>
<span class="p_add">+	u8         reserved_at_a0[0x160];</span>
 };
 
 struct mlx5_ifc_access_register_out_bits {
<span class="p_header">diff --git a/include/linux/ptr_ring.h b/include/linux/ptr_ring.h</span>
<span class="p_header">index b83507c0640c..e38f471a5402 100644</span>
<span class="p_header">--- a/include/linux/ptr_ring.h</span>
<span class="p_header">+++ b/include/linux/ptr_ring.h</span>
<span class="p_chunk">@@ -99,12 +99,18 @@</span> <span class="p_context"> static inline bool ptr_ring_full_bh(struct ptr_ring *r)</span>
 
 /* Note: callers invoking this in a loop must use a compiler barrier,
  * for example cpu_relax(). Callers must hold producer_lock.
<span class="p_add">+ * Callers are responsible for making sure pointer that is being queued</span>
<span class="p_add">+ * points to a valid data.</span>
  */
 static inline int __ptr_ring_produce(struct ptr_ring *r, void *ptr)
 {
 	if (unlikely(!r-&gt;size) || r-&gt;queue[r-&gt;producer])
 		return -ENOSPC;
 
<span class="p_add">+	/* Make sure the pointer we are storing points to a valid data. */</span>
<span class="p_add">+	/* Pairs with smp_read_barrier_depends in __ptr_ring_consume. */</span>
<span class="p_add">+	smp_wmb();</span>
<span class="p_add">+</span>
 	r-&gt;queue[r-&gt;producer++] = ptr;
 	if (unlikely(r-&gt;producer &gt;= r-&gt;size))
 		r-&gt;producer = 0;
<span class="p_chunk">@@ -244,6 +250,9 @@</span> <span class="p_context"> static inline void *__ptr_ring_consume(struct ptr_ring *r)</span>
 	if (ptr)
 		__ptr_ring_discard_one(r);
 
<span class="p_add">+	/* Make sure anyone accessing data through the pointer is up to date. */</span>
<span class="p_add">+	/* Pairs with smp_wmb in __ptr_ring_produce. */</span>
<span class="p_add">+	smp_read_barrier_depends();</span>
 	return ptr;
 }
 
<span class="p_header">diff --git a/include/linux/tcp.h b/include/linux/tcp.h</span>
<span class="p_header">index 647532b0eb03..f50b717ce644 100644</span>
<span class="p_header">--- a/include/linux/tcp.h</span>
<span class="p_header">+++ b/include/linux/tcp.h</span>
<span class="p_chunk">@@ -219,7 +219,8 @@</span> <span class="p_context"> struct tcp_sock {</span>
 	} rack;
 	u16	advmss;		/* Advertised MSS			*/
 	u8	rate_app_limited:1,  /* rate_{delivered,interval_us} limited? */
<span class="p_del">-		unused:7;</span>
<span class="p_add">+		is_sack_reneg:1,    /* in recovery from loss with SACK reneg? */</span>
<span class="p_add">+		unused:6;</span>
 	u8	nonagle     : 4,/* Disable Nagle algorithm?             */
 		thin_lto    : 1,/* Use linear timeouts for thin streams */
 		thin_dupack : 1,/* Fast retransmit on first dupack      */
<span class="p_header">diff --git a/include/linux/timer.h b/include/linux/timer.h</span>
<span class="p_header">index 51d601f192d4..ec86e4e55ea3 100644</span>
<span class="p_header">--- a/include/linux/timer.h</span>
<span class="p_header">+++ b/include/linux/timer.h</span>
<span class="p_chunk">@@ -274,9 +274,11 @@</span> <span class="p_context"> unsigned long round_jiffies_up(unsigned long j);</span>
 unsigned long round_jiffies_up_relative(unsigned long j);
 
 #ifdef CONFIG_HOTPLUG_CPU
<span class="p_add">+int timers_prepare_cpu(unsigned int cpu);</span>
 int timers_dead_cpu(unsigned int cpu);
 #else
<span class="p_del">-#define timers_dead_cpu NULL</span>
<span class="p_add">+#define timers_prepare_cpu	NULL</span>
<span class="p_add">+#define timers_dead_cpu		NULL</span>
 #endif
 
 #endif
<span class="p_header">diff --git a/include/linux/vm_event_item.h b/include/linux/vm_event_item.h</span>
<span class="p_header">index 4d6ec58a8d45..2edb150f1a4d 100644</span>
<span class="p_header">--- a/include/linux/vm_event_item.h</span>
<span class="p_header">+++ b/include/linux/vm_event_item.h</span>
<span class="p_chunk">@@ -89,10 +89,8 @@</span> <span class="p_context"> enum vm_event_item { PGPGIN, PGPGOUT, PSWPIN, PSWPOUT,</span>
 #endif
 #endif
 #ifdef CONFIG_DEBUG_TLBFLUSH
<span class="p_del">-#ifdef CONFIG_SMP</span>
 		NR_TLB_REMOTE_FLUSH,	/* cpu tried to flush others&#39; tlbs */
 		NR_TLB_REMOTE_FLUSH_RECEIVED,/* cpu received ipi for flush */
<span class="p_del">-#endif /* CONFIG_SMP */</span>
 		NR_TLB_LOCAL_FLUSH_ALL,
 		NR_TLB_LOCAL_FLUSH_ONE,
 #endif /* CONFIG_DEBUG_TLBFLUSH */
<span class="p_header">diff --git a/include/net/ip.h b/include/net/ip.h</span>
<span class="p_header">index 51c6b9786c46..0e3dcd5a134d 100644</span>
<span class="p_header">--- a/include/net/ip.h</span>
<span class="p_header">+++ b/include/net/ip.h</span>
<span class="p_chunk">@@ -33,6 +33,8 @@</span> <span class="p_context"></span>
 #include &lt;net/flow.h&gt;
 #include &lt;net/flow_dissector.h&gt;
 
<span class="p_add">+#define IPV4_MIN_MTU		68			/* RFC 791 */</span>
<span class="p_add">+</span>
 struct sock;
 
 struct inet_skb_parm {
<span class="p_header">diff --git a/include/net/tcp.h b/include/net/tcp.h</span>
<span class="p_header">index fba4fc46871d..caf35e062639 100644</span>
<span class="p_header">--- a/include/net/tcp.h</span>
<span class="p_header">+++ b/include/net/tcp.h</span>
<span class="p_chunk">@@ -1001,7 +1001,7 @@</span> <span class="p_context"> void tcp_rate_skb_sent(struct sock *sk, struct sk_buff *skb);</span>
 void tcp_rate_skb_delivered(struct sock *sk, struct sk_buff *skb,
 			    struct rate_sample *rs);
 void tcp_rate_gen(struct sock *sk, u32 delivered, u32 lost,
<span class="p_del">-		  struct skb_mstamp *now, struct rate_sample *rs);</span>
<span class="p_add">+		  bool is_sack_reneg, struct skb_mstamp *now, struct rate_sample *rs);</span>
 void tcp_rate_check_app_limited(struct sock *sk);
 
 /* These functions determine how the current flow behaves in respect of SACK
<span class="p_header">diff --git a/kernel/cpu.c b/kernel/cpu.c</span>
<span class="p_header">index e1436ca4aed0..802eb3361a0a 100644</span>
<span class="p_header">--- a/kernel/cpu.c</span>
<span class="p_header">+++ b/kernel/cpu.c</span>
<span class="p_chunk">@@ -1309,9 +1309,9 @@</span> <span class="p_context"> static struct cpuhp_step cpuhp_bp_states[] = {</span>
 	 * before blk_mq_queue_reinit_notify() from notify_dead(),
 	 * otherwise a RCU stall occurs.
 	 */
<span class="p_del">-	[CPUHP_TIMERS_DEAD] = {</span>
<span class="p_add">+	[CPUHP_TIMERS_PREPARE] = {</span>
 		.name			= &quot;timers:dead&quot;,
<span class="p_del">-		.startup.single		= NULL,</span>
<span class="p_add">+		.startup.single		= timers_prepare_cpu,</span>
 		.teardown.single	= timers_dead_cpu,
 	},
 	/* Kicks the plugged cpu into life */
<span class="p_header">diff --git a/kernel/time/tick-sched.c b/kernel/time/tick-sched.c</span>
<span class="p_header">index 3bcb61b52f6c..dae1a45be504 100644</span>
<span class="p_header">--- a/kernel/time/tick-sched.c</span>
<span class="p_header">+++ b/kernel/time/tick-sched.c</span>
<span class="p_chunk">@@ -663,6 +663,11 @@</span> <span class="p_context"> static void tick_nohz_restart(struct tick_sched *ts, ktime_t now)</span>
 		tick_program_event(hrtimer_get_expires(&amp;ts-&gt;sched_timer), 1);
 }
 
<span class="p_add">+static inline bool local_timer_softirq_pending(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return local_softirq_pending() &amp; TIMER_SOFTIRQ;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static ktime_t tick_nohz_stop_sched_tick(struct tick_sched *ts,
 					 ktime_t now, int cpu)
 {
<span class="p_chunk">@@ -679,8 +684,18 @@</span> <span class="p_context"> static ktime_t tick_nohz_stop_sched_tick(struct tick_sched *ts,</span>
 	} while (read_seqretry(&amp;jiffies_lock, seq));
 	ts-&gt;last_jiffies = basejiff;
 
<span class="p_del">-	if (rcu_needs_cpu(basemono, &amp;next_rcu) ||</span>
<span class="p_del">-	    arch_needs_cpu() || irq_work_needs_cpu()) {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Keep the periodic tick, when RCU, architecture or irq_work</span>
<span class="p_add">+	 * requests it.</span>
<span class="p_add">+	 * Aside of that check whether the local timer softirq is</span>
<span class="p_add">+	 * pending. If so its a bad idea to call get_next_timer_interrupt()</span>
<span class="p_add">+	 * because there is an already expired timer, so it will request</span>
<span class="p_add">+	 * immeditate expiry, which rearms the hardware timer with a</span>
<span class="p_add">+	 * minimal delta which brings us back to this place</span>
<span class="p_add">+	 * immediately. Lather, rinse and repeat...</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (rcu_needs_cpu(basemono, &amp;next_rcu) || arch_needs_cpu() ||</span>
<span class="p_add">+	    irq_work_needs_cpu() || local_timer_softirq_pending()) {</span>
 		next_tick = basemono + TICK_NSEC;
 	} else {
 		/*
<span class="p_header">diff --git a/kernel/time/timer.c b/kernel/time/timer.c</span>
<span class="p_header">index 7d670362891a..e872f7f05e8a 100644</span>
<span class="p_header">--- a/kernel/time/timer.c</span>
<span class="p_header">+++ b/kernel/time/timer.c</span>
<span class="p_chunk">@@ -849,11 +849,10 @@</span> <span class="p_context"> static inline struct timer_base *get_timer_cpu_base(u32 tflags, u32 cpu)</span>
 	struct timer_base *base = per_cpu_ptr(&amp;timer_bases[BASE_STD], cpu);
 
 	/*
<span class="p_del">-	 * If the timer is deferrable and nohz is active then we need to use</span>
<span class="p_del">-	 * the deferrable base.</span>
<span class="p_add">+	 * If the timer is deferrable and NO_HZ_COMMON is set then we need</span>
<span class="p_add">+	 * to use the deferrable base.</span>
 	 */
<span class="p_del">-	if (IS_ENABLED(CONFIG_NO_HZ_COMMON) &amp;&amp; base-&gt;nohz_active &amp;&amp;</span>
<span class="p_del">-	    (tflags &amp; TIMER_DEFERRABLE))</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_NO_HZ_COMMON) &amp;&amp; (tflags &amp; TIMER_DEFERRABLE))</span>
 		base = per_cpu_ptr(&amp;timer_bases[BASE_DEF], cpu);
 	return base;
 }
<span class="p_chunk">@@ -863,11 +862,10 @@</span> <span class="p_context"> static inline struct timer_base *get_timer_this_cpu_base(u32 tflags)</span>
 	struct timer_base *base = this_cpu_ptr(&amp;timer_bases[BASE_STD]);
 
 	/*
<span class="p_del">-	 * If the timer is deferrable and nohz is active then we need to use</span>
<span class="p_del">-	 * the deferrable base.</span>
<span class="p_add">+	 * If the timer is deferrable and NO_HZ_COMMON is set then we need</span>
<span class="p_add">+	 * to use the deferrable base.</span>
 	 */
<span class="p_del">-	if (IS_ENABLED(CONFIG_NO_HZ_COMMON) &amp;&amp; base-&gt;nohz_active &amp;&amp;</span>
<span class="p_del">-	    (tflags &amp; TIMER_DEFERRABLE))</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_NO_HZ_COMMON) &amp;&amp; (tflags &amp; TIMER_DEFERRABLE))</span>
 		base = this_cpu_ptr(&amp;timer_bases[BASE_DEF]);
 	return base;
 }
<span class="p_chunk">@@ -1021,8 +1019,6 @@</span> <span class="p_context"> __mod_timer(struct timer_list *timer, unsigned long expires, bool pending_only)</span>
 	if (!ret &amp;&amp; pending_only)
 		goto out_unlock;
 
<span class="p_del">-	debug_activate(timer, expires);</span>
<span class="p_del">-</span>
 	new_base = get_target_base(base, timer-&gt;flags);
 
 	if (base != new_base) {
<span class="p_chunk">@@ -1046,6 +1042,8 @@</span> <span class="p_context"> __mod_timer(struct timer_list *timer, unsigned long expires, bool pending_only)</span>
 		}
 	}
 
<span class="p_add">+	debug_activate(timer, expires);</span>
<span class="p_add">+</span>
 	timer-&gt;expires = expires;
 	/*
 	 * If &#39;idx&#39; was calculated above and the base time did not advance
<span class="p_chunk">@@ -1684,7 +1682,7 @@</span> <span class="p_context"> static __latent_entropy void run_timer_softirq(struct softirq_action *h)</span>
 	base-&gt;must_forward_clk = false;
 
 	__run_timers(base);
<span class="p_del">-	if (IS_ENABLED(CONFIG_NO_HZ_COMMON) &amp;&amp; base-&gt;nohz_active)</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_NO_HZ_COMMON))</span>
 		__run_timers(this_cpu_ptr(&amp;timer_bases[BASE_DEF]));
 }
 
<span class="p_chunk">@@ -1853,6 +1851,21 @@</span> <span class="p_context"> static void migrate_timer_list(struct timer_base *new_base, struct hlist_head *h</span>
 	}
 }
 
<span class="p_add">+int timers_prepare_cpu(unsigned int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct timer_base *base;</span>
<span class="p_add">+	int b;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (b = 0; b &lt; NR_BASES; b++) {</span>
<span class="p_add">+		base = per_cpu_ptr(&amp;timer_bases[b], cpu);</span>
<span class="p_add">+		base-&gt;clk = jiffies;</span>
<span class="p_add">+		base-&gt;next_expiry = base-&gt;clk + NEXT_TIMER_MAX_DELTA;</span>
<span class="p_add">+		base-&gt;is_idle = false;</span>
<span class="p_add">+		base-&gt;must_forward_clk = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int timers_dead_cpu(unsigned int cpu)
 {
 	struct timer_base *old_base;
<span class="p_header">diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c</span>
<span class="p_header">index f5c016e8fc88..3e1d11f4fe44 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer.c</span>
<span class="p_chunk">@@ -280,6 +280,8 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(ring_buffer_event_data);</span>
 /* Missed count stored at end */
 #define RB_MISSED_STORED	(1 &lt;&lt; 30)
 
<span class="p_add">+#define RB_MISSED_FLAGS		(RB_MISSED_EVENTS|RB_MISSED_STORED)</span>
<span class="p_add">+</span>
 struct buffer_data_page {
 	u64		 time_stamp;	/* page time stamp */
 	local_t		 commit;	/* write committed index */
<span class="p_chunk">@@ -331,7 +333,9 @@</span> <span class="p_context"> static void rb_init_page(struct buffer_data_page *bpage)</span>
  */
 size_t ring_buffer_page_len(void *page)
 {
<span class="p_del">-	return local_read(&amp;((struct buffer_data_page *)page)-&gt;commit)</span>
<span class="p_add">+	struct buffer_data_page *bpage = page;</span>
<span class="p_add">+</span>
<span class="p_add">+	return (local_read(&amp;bpage-&gt;commit) &amp; ~RB_MISSED_FLAGS)</span>
 		+ BUF_PAGE_HDR_SIZE;
 }
 
<span class="p_header">diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c</span>
<span class="p_header">index 4214cd960b8e..15b02645ce8b 100644</span>
<span class="p_header">--- a/kernel/trace/trace.c</span>
<span class="p_header">+++ b/kernel/trace/trace.c</span>
<span class="p_chunk">@@ -6181,7 +6181,7 @@</span> <span class="p_context"> tracing_buffers_splice_read(struct file *file, loff_t *ppos,</span>
 		.spd_release	= buffer_spd_release,
 	};
 	struct buffer_ref *ref;
<span class="p_del">-	int entries, size, i;</span>
<span class="p_add">+	int entries, i;</span>
 	ssize_t ret = 0;
 
 #ifdef CONFIG_TRACER_MAX_TRACE
<span class="p_chunk">@@ -6232,14 +6232,6 @@</span> <span class="p_context"> tracing_buffers_splice_read(struct file *file, loff_t *ppos,</span>
 			break;
 		}
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * zero out any left over data, this is going to</span>
<span class="p_del">-		 * user land.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		size = ring_buffer_page_len(ref-&gt;page);</span>
<span class="p_del">-		if (size &lt; PAGE_SIZE)</span>
<span class="p_del">-			memset(ref-&gt;page + size, 0, PAGE_SIZE - size);</span>
<span class="p_del">-</span>
 		page = virt_to_page(ref-&gt;page);
 
 		spd.pages[i] = page;
<span class="p_chunk">@@ -6963,6 +6955,7 @@</span> <span class="p_context"> allocate_trace_buffer(struct trace_array *tr, struct trace_buffer *buf, int size</span>
 	buf-&gt;data = alloc_percpu(struct trace_array_cpu);
 	if (!buf-&gt;data) {
 		ring_buffer_free(buf-&gt;buffer);
<span class="p_add">+		buf-&gt;buffer = NULL;</span>
 		return -ENOMEM;
 	}
 
<span class="p_chunk">@@ -6986,7 +6979,9 @@</span> <span class="p_context"> static int allocate_trace_buffers(struct trace_array *tr, int size)</span>
 				    allocate_snapshot ? size : 1);
 	if (WARN_ON(ret)) {
 		ring_buffer_free(tr-&gt;trace_buffer.buffer);
<span class="p_add">+		tr-&gt;trace_buffer.buffer = NULL;</span>
 		free_percpu(tr-&gt;trace_buffer.data);
<span class="p_add">+		tr-&gt;trace_buffer.data = NULL;</span>
 		return -ENOMEM;
 	}
 	tr-&gt;allocated_snapshot = allocate_snapshot;
<span class="p_header">diff --git a/net/bridge/br_netlink.c b/net/bridge/br_netlink.c</span>
<span class="p_header">index 5d4006e589cb..4f831225d34f 100644</span>
<span class="p_header">--- a/net/bridge/br_netlink.c</span>
<span class="p_header">+++ b/net/bridge/br_netlink.c</span>
<span class="p_chunk">@@ -1092,19 +1092,20 @@</span> <span class="p_context"> static int br_dev_newlink(struct net *src_net, struct net_device *dev,</span>
 	struct net_bridge *br = netdev_priv(dev);
 	int err;
 
<span class="p_add">+	err = register_netdevice(dev);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
 	if (tb[IFLA_ADDRESS]) {
 		spin_lock_bh(&amp;br-&gt;lock);
 		br_stp_change_bridge_id(br, nla_data(tb[IFLA_ADDRESS]));
 		spin_unlock_bh(&amp;br-&gt;lock);
 	}
 
<span class="p_del">-	err = register_netdevice(dev);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-</span>
 	err = br_changelink(dev, tb, data);
 	if (err)
<span class="p_del">-		unregister_netdevice(dev);</span>
<span class="p_add">+		br_dev_delete(dev, NULL);</span>
<span class="p_add">+</span>
 	return err;
 }
 
<span class="p_header">diff --git a/net/core/net_namespace.c b/net/core/net_namespace.c</span>
<span class="p_header">index 7001da910c6b..b7efe2f19f83 100644</span>
<span class="p_header">--- a/net/core/net_namespace.c</span>
<span class="p_header">+++ b/net/core/net_namespace.c</span>
<span class="p_chunk">@@ -263,7 +263,7 @@</span> <span class="p_context"> struct net *get_net_ns_by_id(struct net *net, int id)</span>
 	spin_lock_irqsave(&amp;net-&gt;nsid_lock, flags);
 	peer = idr_find(&amp;net-&gt;netns_ids, id);
 	if (peer)
<span class="p_del">-		get_net(peer);</span>
<span class="p_add">+		peer = maybe_get_net(peer);</span>
 	spin_unlock_irqrestore(&amp;net-&gt;nsid_lock, flags);
 	rcu_read_unlock();
 
<span class="p_header">diff --git a/net/core/skbuff.c b/net/core/skbuff.c</span>
<span class="p_header">index aec5605944d3..a64515583bc1 100644</span>
<span class="p_header">--- a/net/core/skbuff.c</span>
<span class="p_header">+++ b/net/core/skbuff.c</span>
<span class="p_chunk">@@ -3823,7 +3823,7 @@</span> <span class="p_context"> void skb_complete_tx_timestamp(struct sk_buff *skb,</span>
 	struct sock *sk = skb-&gt;sk;
 
 	if (!skb_may_tx_timestamp(sk, false))
<span class="p_del">-		return;</span>
<span class="p_add">+		goto err;</span>
 
 	/* Take a reference to prevent skb_orphan() from freeing the socket,
 	 * but only if the socket refcount is not zero.
<span class="p_chunk">@@ -3832,7 +3832,11 @@</span> <span class="p_context"> void skb_complete_tx_timestamp(struct sk_buff *skb,</span>
 		*skb_hwtstamps(skb) = *hwtstamps;
 		__skb_complete_tx_timestamp(skb, sk, SCM_TSTAMP_SND);
 		sock_put(sk);
<span class="p_add">+		return;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+err:</span>
<span class="p_add">+	kfree_skb(skb);</span>
 }
 EXPORT_SYMBOL_GPL(skb_complete_tx_timestamp);
 
<span class="p_header">diff --git a/net/ipv4/devinet.c b/net/ipv4/devinet.c</span>
<span class="p_header">index 062a67ca9a21..f08f984ebc56 100644</span>
<span class="p_header">--- a/net/ipv4/devinet.c</span>
<span class="p_header">+++ b/net/ipv4/devinet.c</span>
<span class="p_chunk">@@ -1380,7 +1380,7 @@</span> <span class="p_context"> static void inetdev_changename(struct net_device *dev, struct in_device *in_dev)</span>
 
 static bool inetdev_valid_mtu(unsigned int mtu)
 {
<span class="p_del">-	return mtu &gt;= 68;</span>
<span class="p_add">+	return mtu &gt;= IPV4_MIN_MTU;</span>
 }
 
 static void inetdev_send_gratuitous_arp(struct net_device *dev,
<span class="p_header">diff --git a/net/ipv4/fib_frontend.c b/net/ipv4/fib_frontend.c</span>
<span class="p_header">index 968d8e165e3d..ffae472e250a 100644</span>
<span class="p_header">--- a/net/ipv4/fib_frontend.c</span>
<span class="p_header">+++ b/net/ipv4/fib_frontend.c</span>
<span class="p_chunk">@@ -1253,14 +1253,19 @@</span> <span class="p_context"> static int __net_init ip_fib_net_init(struct net *net)</span>
 
 static void ip_fib_net_exit(struct net *net)
 {
<span class="p_del">-	unsigned int i;</span>
<span class="p_add">+	int i;</span>
 
 	rtnl_lock();
 #ifdef CONFIG_IP_MULTIPLE_TABLES
 	RCU_INIT_POINTER(net-&gt;ipv4.fib_main, NULL);
 	RCU_INIT_POINTER(net-&gt;ipv4.fib_default, NULL);
 #endif
<span class="p_del">-	for (i = 0; i &lt; FIB_TABLE_HASHSZ; i++) {</span>
<span class="p_add">+	/* Destroy the tables in reverse order to guarantee that the</span>
<span class="p_add">+	 * local table, ID 255, is destroyed before the main table, ID</span>
<span class="p_add">+	 * 254. This is necessary as the local table may contain</span>
<span class="p_add">+	 * references to data contained in the main table.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (i = FIB_TABLE_HASHSZ - 1; i &gt;= 0; i--) {</span>
 		struct hlist_head *head = &amp;net-&gt;ipv4.fib_table_hash[i];
 		struct hlist_node *tmp;
 		struct fib_table *tb;
<span class="p_header">diff --git a/net/ipv4/igmp.c b/net/ipv4/igmp.c</span>
<span class="p_header">index 08575e3bd135..7bff0c65046f 100644</span>
<span class="p_header">--- a/net/ipv4/igmp.c</span>
<span class="p_header">+++ b/net/ipv4/igmp.c</span>
<span class="p_chunk">@@ -89,6 +89,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/rtnetlink.h&gt;
 #include &lt;linux/times.h&gt;
 #include &lt;linux/pkt_sched.h&gt;
<span class="p_add">+#include &lt;linux/byteorder/generic.h&gt;</span>
 
 #include &lt;net/net_namespace.h&gt;
 #include &lt;net/arp.h&gt;
<span class="p_chunk">@@ -321,6 +322,23 @@</span> <span class="p_context"> igmp_scount(struct ip_mc_list *pmc, int type, int gdeleted, int sdeleted)</span>
 	return scount;
 }
 
<span class="p_add">+/* source address selection per RFC 3376 section 4.2.13 */</span>
<span class="p_add">+static __be32 igmpv3_get_srcaddr(struct net_device *dev,</span>
<span class="p_add">+				 const struct flowi4 *fl4)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct in_device *in_dev = __in_dev_get_rcu(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!in_dev)</span>
<span class="p_add">+		return htonl(INADDR_ANY);</span>
<span class="p_add">+</span>
<span class="p_add">+	for_ifa(in_dev) {</span>
<span class="p_add">+		if (inet_ifa_match(fl4-&gt;saddr, ifa))</span>
<span class="p_add">+			return fl4-&gt;saddr;</span>
<span class="p_add">+	} endfor_ifa(in_dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	return htonl(INADDR_ANY);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct sk_buff *igmpv3_newpack(struct net_device *dev, unsigned int mtu)
 {
 	struct sk_buff *skb;
<span class="p_chunk">@@ -368,7 +386,7 @@</span> <span class="p_context"> static struct sk_buff *igmpv3_newpack(struct net_device *dev, unsigned int mtu)</span>
 	pip-&gt;frag_off = htons(IP_DF);
 	pip-&gt;ttl      = 1;
 	pip-&gt;daddr    = fl4.daddr;
<span class="p_del">-	pip-&gt;saddr    = fl4.saddr;</span>
<span class="p_add">+	pip-&gt;saddr    = igmpv3_get_srcaddr(dev, &amp;fl4);</span>
 	pip-&gt;protocol = IPPROTO_IGMP;
 	pip-&gt;tot_len  = 0;	/* filled in later */
 	ip_select_ident(net, skb, NULL);
<span class="p_chunk">@@ -404,16 +422,17 @@</span> <span class="p_context"> static int grec_size(struct ip_mc_list *pmc, int type, int gdel, int sdel)</span>
 }
 
 static struct sk_buff *add_grhead(struct sk_buff *skb, struct ip_mc_list *pmc,
<span class="p_del">-	int type, struct igmpv3_grec **ppgr)</span>
<span class="p_add">+	int type, struct igmpv3_grec **ppgr, unsigned int mtu)</span>
 {
 	struct net_device *dev = pmc-&gt;interface-&gt;dev;
 	struct igmpv3_report *pih;
 	struct igmpv3_grec *pgr;
 
<span class="p_del">-	if (!skb)</span>
<span class="p_del">-		skb = igmpv3_newpack(dev, dev-&gt;mtu);</span>
<span class="p_del">-	if (!skb)</span>
<span class="p_del">-		return NULL;</span>
<span class="p_add">+	if (!skb) {</span>
<span class="p_add">+		skb = igmpv3_newpack(dev, mtu);</span>
<span class="p_add">+		if (!skb)</span>
<span class="p_add">+			return NULL;</span>
<span class="p_add">+	}</span>
 	pgr = (struct igmpv3_grec *)skb_put(skb, sizeof(struct igmpv3_grec));
 	pgr-&gt;grec_type = type;
 	pgr-&gt;grec_auxwords = 0;
<span class="p_chunk">@@ -436,12 +455,17 @@</span> <span class="p_context"> static struct sk_buff *add_grec(struct sk_buff *skb, struct ip_mc_list *pmc,</span>
 	struct igmpv3_grec *pgr = NULL;
 	struct ip_sf_list *psf, *psf_next, *psf_prev, **psf_list;
 	int scount, stotal, first, isquery, truncate;
<span class="p_add">+	unsigned int mtu;</span>
 
 	if (pmc-&gt;multiaddr == IGMP_ALL_HOSTS)
 		return skb;
 	if (ipv4_is_local_multicast(pmc-&gt;multiaddr) &amp;&amp; !net-&gt;ipv4.sysctl_igmp_llm_reports)
 		return skb;
 
<span class="p_add">+	mtu = READ_ONCE(dev-&gt;mtu);</span>
<span class="p_add">+	if (mtu &lt; IPV4_MIN_MTU)</span>
<span class="p_add">+		return skb;</span>
<span class="p_add">+</span>
 	isquery = type == IGMPV3_MODE_IS_INCLUDE ||
 		  type == IGMPV3_MODE_IS_EXCLUDE;
 	truncate = type == IGMPV3_MODE_IS_EXCLUDE ||
<span class="p_chunk">@@ -462,7 +486,7 @@</span> <span class="p_context"> static struct sk_buff *add_grec(struct sk_buff *skb, struct ip_mc_list *pmc,</span>
 		    AVAILABLE(skb) &lt; grec_size(pmc, type, gdeleted, sdeleted)) {
 			if (skb)
 				igmpv3_sendpack(skb);
<span class="p_del">-			skb = igmpv3_newpack(dev, dev-&gt;mtu);</span>
<span class="p_add">+			skb = igmpv3_newpack(dev, mtu);</span>
 		}
 	}
 	first = 1;
<span class="p_chunk">@@ -498,12 +522,12 @@</span> <span class="p_context"> static struct sk_buff *add_grec(struct sk_buff *skb, struct ip_mc_list *pmc,</span>
 				pgr-&gt;grec_nsrcs = htons(scount);
 			if (skb)
 				igmpv3_sendpack(skb);
<span class="p_del">-			skb = igmpv3_newpack(dev, dev-&gt;mtu);</span>
<span class="p_add">+			skb = igmpv3_newpack(dev, mtu);</span>
 			first = 1;
 			scount = 0;
 		}
 		if (first) {
<span class="p_del">-			skb = add_grhead(skb, pmc, type, &amp;pgr);</span>
<span class="p_add">+			skb = add_grhead(skb, pmc, type, &amp;pgr, mtu);</span>
 			first = 0;
 		}
 		if (!skb)
<span class="p_chunk">@@ -538,7 +562,7 @@</span> <span class="p_context"> static struct sk_buff *add_grec(struct sk_buff *skb, struct ip_mc_list *pmc,</span>
 				igmpv3_sendpack(skb);
 				skb = NULL; /* add_grhead will get a new one */
 			}
<span class="p_del">-			skb = add_grhead(skb, pmc, type, &amp;pgr);</span>
<span class="p_add">+			skb = add_grhead(skb, pmc, type, &amp;pgr, mtu);</span>
 		}
 	}
 	if (pgr)
<span class="p_header">diff --git a/net/ipv4/ip_tunnel.c b/net/ipv4/ip_tunnel.c</span>
<span class="p_header">index bd7f1836bb70..96536a0d6e2d 100644</span>
<span class="p_header">--- a/net/ipv4/ip_tunnel.c</span>
<span class="p_header">+++ b/net/ipv4/ip_tunnel.c</span>
<span class="p_chunk">@@ -346,8 +346,8 @@</span> <span class="p_context"> static int ip_tunnel_bind_dev(struct net_device *dev)</span>
 	dev-&gt;needed_headroom = t_hlen + hlen;
 	mtu -= (dev-&gt;hard_header_len + t_hlen);
 
<span class="p_del">-	if (mtu &lt; 68)</span>
<span class="p_del">-		mtu = 68;</span>
<span class="p_add">+	if (mtu &lt; IPV4_MIN_MTU)</span>
<span class="p_add">+		mtu = IPV4_MIN_MTU;</span>
 
 	return mtu;
 }
<span class="p_header">diff --git a/net/ipv4/raw.c b/net/ipv4/raw.c</span>
<span class="p_header">index 9879b73d5565..59d8770055ed 100644</span>
<span class="p_header">--- a/net/ipv4/raw.c</span>
<span class="p_header">+++ b/net/ipv4/raw.c</span>
<span class="p_chunk">@@ -502,11 +502,16 @@</span> <span class="p_context"> static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)</span>
 	int err;
 	struct ip_options_data opt_copy;
 	struct raw_frag_vec rfv;
<span class="p_add">+	int hdrincl;</span>
 
 	err = -EMSGSIZE;
 	if (len &gt; 0xFFFF)
 		goto out;
 
<span class="p_add">+	/* hdrincl should be READ_ONCE(inet-&gt;hdrincl)</span>
<span class="p_add">+	 * but READ_ONCE() doesn&#39;t work with bit fields</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	hdrincl = inet-&gt;hdrincl;</span>
 	/*
 	 *	Check the flags.
 	 */
<span class="p_chunk">@@ -582,7 +587,7 @@</span> <span class="p_context"> static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)</span>
 		/* Linux does not mangle headers on raw sockets,
 		 * so that IP options + IP_HDRINCL is non-sense.
 		 */
<span class="p_del">-		if (inet-&gt;hdrincl)</span>
<span class="p_add">+		if (hdrincl)</span>
 			goto done;
 		if (ipc.opt-&gt;opt.srr) {
 			if (!daddr)
<span class="p_chunk">@@ -604,12 +609,12 @@</span> <span class="p_context"> static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)</span>
 
 	flowi4_init_output(&amp;fl4, ipc.oif, sk-&gt;sk_mark, tos,
 			   RT_SCOPE_UNIVERSE,
<span class="p_del">-			   inet-&gt;hdrincl ? IPPROTO_RAW : sk-&gt;sk_protocol,</span>
<span class="p_add">+			   hdrincl ? IPPROTO_RAW : sk-&gt;sk_protocol,</span>
 			   inet_sk_flowi_flags(sk) |
<span class="p_del">-			    (inet-&gt;hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),</span>
<span class="p_add">+			    (hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),</span>
 			   daddr, saddr, 0, 0);
 
<span class="p_del">-	if (!inet-&gt;hdrincl) {</span>
<span class="p_add">+	if (!hdrincl) {</span>
 		rfv.msg = msg;
 		rfv.hlen = 0;
 
<span class="p_chunk">@@ -634,7 +639,7 @@</span> <span class="p_context"> static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)</span>
 		goto do_confirm;
 back_from_confirm:
 
<span class="p_del">-	if (inet-&gt;hdrincl)</span>
<span class="p_add">+	if (hdrincl)</span>
 		err = raw_send_hdrinc(sk, &amp;fl4, msg, len,
 				      &amp;rt, msg-&gt;msg_flags, &amp;ipc.sockc);
 
<span class="p_header">diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c</span>
<span class="p_header">index dd33c785ce16..05d2bde00864 100644</span>
<span class="p_header">--- a/net/ipv4/tcp.c</span>
<span class="p_header">+++ b/net/ipv4/tcp.c</span>
<span class="p_chunk">@@ -2297,6 +2297,7 @@</span> <span class="p_context"> int tcp_disconnect(struct sock *sk, int flags)</span>
 	tp-&gt;snd_cwnd_cnt = 0;
 	tp-&gt;window_clamp = 0;
 	tcp_set_ca_state(sk, TCP_CA_Open);
<span class="p_add">+	tp-&gt;is_sack_reneg = 0;</span>
 	tcp_clear_retrans(tp);
 	inet_csk_delack_init(sk);
 	/* Initialize rcv_mss to TCP_MIN_MSS to avoid division by 0
<span class="p_header">diff --git a/net/ipv4/tcp_bbr.c b/net/ipv4/tcp_bbr.c</span>
<span class="p_header">index cb8db347c680..97f9cac98348 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_bbr.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_bbr.c</span>
<span class="p_chunk">@@ -81,7 +81,8 @@</span> <span class="p_context"> struct bbr {</span>
 	u32	lt_last_lost;	     /* LT intvl start: tp-&gt;lost */
 	u32	pacing_gain:10,	/* current gain for setting pacing rate */
 		cwnd_gain:10,	/* current gain for setting cwnd */
<span class="p_del">-		full_bw_cnt:3,	/* number of rounds without large bw gains */</span>
<span class="p_add">+		full_bw_reached:1,   /* reached full bw in Startup? */</span>
<span class="p_add">+		full_bw_cnt:2,	/* number of rounds without large bw gains */</span>
 		cycle_idx:3,	/* current index in pacing_gain cycle array */
 		has_seen_rtt:1, /* have we seen an RTT sample yet? */
 		unused_b:5;
<span class="p_chunk">@@ -151,7 +152,7 @@</span> <span class="p_context"> static bool bbr_full_bw_reached(const struct sock *sk)</span>
 {
 	const struct bbr *bbr = inet_csk_ca(sk);
 
<span class="p_del">-	return bbr-&gt;full_bw_cnt &gt;= bbr_full_bw_cnt;</span>
<span class="p_add">+	return bbr-&gt;full_bw_reached;</span>
 }
 
 /* Return the windowed max recent bandwidth sample, in pkts/uS &lt;&lt; BW_SCALE. */
<span class="p_chunk">@@ -688,6 +689,7 @@</span> <span class="p_context"> static void bbr_check_full_bw_reached(struct sock *sk,</span>
 		return;
 	}
 	++bbr-&gt;full_bw_cnt;
<span class="p_add">+	bbr-&gt;full_bw_reached = bbr-&gt;full_bw_cnt &gt;= bbr_full_bw_cnt;</span>
 }
 
 /* If pipe is probably full, drain the queue and then enter steady-state. */
<span class="p_chunk">@@ -821,6 +823,7 @@</span> <span class="p_context"> static void bbr_init(struct sock *sk)</span>
 	bbr-&gt;restore_cwnd = 0;
 	bbr-&gt;round_start = 0;
 	bbr-&gt;idle_restart = 0;
<span class="p_add">+	bbr-&gt;full_bw_reached = 0;</span>
 	bbr-&gt;full_bw = 0;
 	bbr-&gt;full_bw_cnt = 0;
 	bbr-&gt;cycle_mstamp.v64 = 0;
<span class="p_header">diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c</span>
<span class="p_header">index 05255a286888..2f107e46355c 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_input.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_input.c</span>
<span class="p_chunk">@@ -1966,6 +1966,8 @@</span> <span class="p_context"> void tcp_enter_loss(struct sock *sk)</span>
 		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPSACKRENEGING);
 		tp-&gt;sacked_out = 0;
 		tp-&gt;fackets_out = 0;
<span class="p_add">+		/* Mark SACK reneging until we recover from this loss event. */</span>
<span class="p_add">+		tp-&gt;is_sack_reneg = 1;</span>
 	}
 	tcp_clear_all_retrans_hints(tp);
 
<span class="p_chunk">@@ -2463,6 +2465,7 @@</span> <span class="p_context"> static bool tcp_try_undo_recovery(struct sock *sk)</span>
 		return true;
 	}
 	tcp_set_ca_state(sk, TCP_CA_Open);
<span class="p_add">+	tp-&gt;is_sack_reneg = 0;</span>
 	return false;
 }
 
<span class="p_chunk">@@ -2494,8 +2497,10 @@</span> <span class="p_context"> static bool tcp_try_undo_loss(struct sock *sk, bool frto_undo)</span>
 			NET_INC_STATS(sock_net(sk),
 					LINUX_MIB_TCPSPURIOUSRTOS);
 		inet_csk(sk)-&gt;icsk_retransmits = 0;
<span class="p_del">-		if (frto_undo || tcp_is_sack(tp))</span>
<span class="p_add">+		if (frto_undo || tcp_is_sack(tp)) {</span>
 			tcp_set_ca_state(sk, TCP_CA_Open);
<span class="p_add">+			tp-&gt;is_sack_reneg = 0;</span>
<span class="p_add">+		}</span>
 		return true;
 	}
 	return false;
<span class="p_chunk">@@ -3589,6 +3594,7 @@</span> <span class="p_context"> static int tcp_ack(struct sock *sk, const struct sk_buff *skb, int flag)</span>
 	struct tcp_sacktag_state sack_state;
 	struct rate_sample rs = { .prior_delivered = 0 };
 	u32 prior_snd_una = tp-&gt;snd_una;
<span class="p_add">+	bool is_sack_reneg = tp-&gt;is_sack_reneg;</span>
 	u32 ack_seq = TCP_SKB_CB(skb)-&gt;seq;
 	u32 ack = TCP_SKB_CB(skb)-&gt;ack_seq;
 	bool is_dupack = false;
<span class="p_chunk">@@ -3711,7 +3717,7 @@</span> <span class="p_context"> static int tcp_ack(struct sock *sk, const struct sk_buff *skb, int flag)</span>
 		tcp_schedule_loss_probe(sk);
 	delivered = tp-&gt;delivered - delivered;	/* freshly ACKed or SACKed */
 	lost = tp-&gt;lost - lost;			/* freshly marked lost */
<span class="p_del">-	tcp_rate_gen(sk, delivered, lost, &amp;now, &amp;rs);</span>
<span class="p_add">+	tcp_rate_gen(sk, delivered, lost, is_sack_reneg, &amp;now, &amp;rs);</span>
 	tcp_cong_control(sk, ack, delivered, flag, &amp;rs);
 	tcp_xmit_recovery(sk, rexmit);
 	return 1;
<span class="p_header">diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c</span>
<span class="p_header">index d577ec07a0d8..b3960738464e 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_ipv4.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_ipv4.c</span>
<span class="p_chunk">@@ -828,7 +828,7 @@</span> <span class="p_context"> static void tcp_v4_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,</span>
 			tcp_time_stamp,
 			req-&gt;ts_recent,
 			0,
<span class="p_del">-			tcp_md5_do_lookup(sk, (union tcp_md5_addr *)&amp;ip_hdr(skb)-&gt;daddr,</span>
<span class="p_add">+			tcp_md5_do_lookup(sk, (union tcp_md5_addr *)&amp;ip_hdr(skb)-&gt;saddr,</span>
 					  AF_INET),
 			inet_rsk(req)-&gt;no_srccheck ? IP_REPLY_ARG_NOSRCCHECK : 0,
 			ip_hdr(skb)-&gt;tos);
<span class="p_header">diff --git a/net/ipv4/tcp_rate.c b/net/ipv4/tcp_rate.c</span>
<span class="p_header">index 9be1581a5a08..18309f58ab8d 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_rate.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_rate.c</span>
<span class="p_chunk">@@ -106,7 +106,7 @@</span> <span class="p_context"> void tcp_rate_skb_delivered(struct sock *sk, struct sk_buff *skb,</span>
 
 /* Update the connection delivery information and generate a rate sample. */
 void tcp_rate_gen(struct sock *sk, u32 delivered, u32 lost,
<span class="p_del">-		  struct skb_mstamp *now, struct rate_sample *rs)</span>
<span class="p_add">+		  bool is_sack_reneg, struct skb_mstamp *now, struct rate_sample *rs)</span>
 {
 	struct tcp_sock *tp = tcp_sk(sk);
 	u32 snd_us, ack_us;
<span class="p_chunk">@@ -124,8 +124,12 @@</span> <span class="p_context"> void tcp_rate_gen(struct sock *sk, u32 delivered, u32 lost,</span>
 
 	rs-&gt;acked_sacked = delivered;	/* freshly ACKed or SACKed */
 	rs-&gt;losses = lost;		/* freshly marked lost */
<span class="p_del">-	/* Return an invalid sample if no timing information is available. */</span>
<span class="p_del">-	if (!rs-&gt;prior_mstamp.v64) {</span>
<span class="p_add">+	/* Return an invalid sample if no timing information is available or</span>
<span class="p_add">+	 * in recovery from loss with SACK reneging. Rate samples taken during</span>
<span class="p_add">+	 * a SACK reneging event may overestimate bw by including packets that</span>
<span class="p_add">+	 * were SACKed before the reneg.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!rs-&gt;prior_mstamp.v64 || is_sack_reneg) {</span>
 		rs-&gt;delivered = -1;
 		rs-&gt;interval_us = -1;
 		return;
<span class="p_header">diff --git a/net/ipv6/af_inet6.c b/net/ipv6/af_inet6.c</span>
<span class="p_header">index 8285a1c108c9..5cad76f87536 100644</span>
<span class="p_header">--- a/net/ipv6/af_inet6.c</span>
<span class="p_header">+++ b/net/ipv6/af_inet6.c</span>
<span class="p_chunk">@@ -209,7 +209,6 @@</span> <span class="p_context"> static int inet6_create(struct net *net, struct socket *sock, int protocol,</span>
 	np-&gt;mcast_hops	= IPV6_DEFAULT_MCASTHOPS;
 	np-&gt;mc_loop	= 1;
 	np-&gt;pmtudisc	= IPV6_PMTUDISC_WANT;
<span class="p_del">-	np-&gt;autoflowlabel = ip6_default_np_autolabel(sock_net(sk));</span>
 	sk-&gt;sk_ipv6only	= net-&gt;ipv6.sysctl.bindv6only;
 
 	/* Init the ipv4 part of the socket since we can have sockets
<span class="p_header">diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c</span>
<span class="p_header">index 6e01c9a8dfd3..506efba33a89 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_output.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_output.c</span>
<span class="p_chunk">@@ -156,6 +156,14 @@</span> <span class="p_context"> int ip6_output(struct net *net, struct sock *sk, struct sk_buff *skb)</span>
 			    !(IP6CB(skb)-&gt;flags &amp; IP6SKB_REROUTED));
 }
 
<span class="p_add">+static bool ip6_autoflowlabel(struct net *net, const struct ipv6_pinfo *np)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!np-&gt;autoflowlabel_set)</span>
<span class="p_add">+		return ip6_default_np_autolabel(net);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return np-&gt;autoflowlabel;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * xmit an sk_buff (used by TCP, SCTP and DCCP)
  * Note : socket lock is not held for SYNACK packets, but might be modified
<span class="p_chunk">@@ -219,7 +227,7 @@</span> <span class="p_context"> int ip6_xmit(const struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6,</span>
 		hlimit = ip6_dst_hoplimit(dst);
 
 	ip6_flow_hdr(hdr, tclass, ip6_make_flowlabel(net, skb, fl6-&gt;flowlabel,
<span class="p_del">-						     np-&gt;autoflowlabel, fl6));</span>
<span class="p_add">+				ip6_autoflowlabel(net, np), fl6));</span>
 
 	hdr-&gt;payload_len = htons(seg_len);
 	hdr-&gt;nexthdr = proto;
<span class="p_chunk">@@ -1691,7 +1699,7 @@</span> <span class="p_context"> struct sk_buff *__ip6_make_skb(struct sock *sk,</span>
 
 	ip6_flow_hdr(hdr, v6_cork-&gt;tclass,
 		     ip6_make_flowlabel(net, skb, fl6-&gt;flowlabel,
<span class="p_del">-					np-&gt;autoflowlabel, fl6));</span>
<span class="p_add">+					ip6_autoflowlabel(net, np), fl6));</span>
 	hdr-&gt;hop_limit = v6_cork-&gt;hop_limit;
 	hdr-&gt;nexthdr = proto;
 	hdr-&gt;saddr = fl6-&gt;saddr;
<span class="p_header">diff --git a/net/ipv6/ip6_tunnel.c b/net/ipv6/ip6_tunnel.c</span>
<span class="p_header">index 12b2fd512f32..11d22d642488 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_tunnel.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_tunnel.c</span>
<span class="p_chunk">@@ -911,7 +911,7 @@</span> <span class="p_context"> static int ipxip6_rcv(struct sk_buff *skb, u8 ipproto,</span>
 		if (t-&gt;parms.collect_md) {
 			tun_dst = ipv6_tun_rx_dst(skb, 0, 0, 0);
 			if (!tun_dst)
<span class="p_del">-				return 0;</span>
<span class="p_add">+				goto drop;</span>
 		}
 		ret = __ip6_tnl_rcv(t, skb, tpi, tun_dst, dscp_ecn_decapsulate,
 				    log_ecn_error);
<span class="p_header">diff --git a/net/ipv6/ipv6_sockglue.c b/net/ipv6/ipv6_sockglue.c</span>
<span class="p_header">index 38bee173dc2b..6e3871c7f8f7 100644</span>
<span class="p_header">--- a/net/ipv6/ipv6_sockglue.c</span>
<span class="p_header">+++ b/net/ipv6/ipv6_sockglue.c</span>
<span class="p_chunk">@@ -874,6 +874,7 @@</span> <span class="p_context"> static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,</span>
 		break;
 	case IPV6_AUTOFLOWLABEL:
 		np-&gt;autoflowlabel = valbool;
<span class="p_add">+		np-&gt;autoflowlabel_set = 1;</span>
 		retv = 0;
 		break;
 	}
<span class="p_header">diff --git a/net/ipv6/mcast.c b/net/ipv6/mcast.c</span>
<span class="p_header">index 1bdc703cb966..ca8fac6e5a09 100644</span>
<span class="p_header">--- a/net/ipv6/mcast.c</span>
<span class="p_header">+++ b/net/ipv6/mcast.c</span>
<span class="p_chunk">@@ -1682,16 +1682,16 @@</span> <span class="p_context"> static int grec_size(struct ifmcaddr6 *pmc, int type, int gdel, int sdel)</span>
 }
 
 static struct sk_buff *add_grhead(struct sk_buff *skb, struct ifmcaddr6 *pmc,
<span class="p_del">-	int type, struct mld2_grec **ppgr)</span>
<span class="p_add">+	int type, struct mld2_grec **ppgr, unsigned int mtu)</span>
 {
<span class="p_del">-	struct net_device *dev = pmc-&gt;idev-&gt;dev;</span>
 	struct mld2_report *pmr;
 	struct mld2_grec *pgr;
 
<span class="p_del">-	if (!skb)</span>
<span class="p_del">-		skb = mld_newpack(pmc-&gt;idev, dev-&gt;mtu);</span>
<span class="p_del">-	if (!skb)</span>
<span class="p_del">-		return NULL;</span>
<span class="p_add">+	if (!skb) {</span>
<span class="p_add">+		skb = mld_newpack(pmc-&gt;idev, mtu);</span>
<span class="p_add">+		if (!skb)</span>
<span class="p_add">+			return NULL;</span>
<span class="p_add">+	}</span>
 	pgr = (struct mld2_grec *)skb_put(skb, sizeof(struct mld2_grec));
 	pgr-&gt;grec_type = type;
 	pgr-&gt;grec_auxwords = 0;
<span class="p_chunk">@@ -1714,10 +1714,15 @@</span> <span class="p_context"> static struct sk_buff *add_grec(struct sk_buff *skb, struct ifmcaddr6 *pmc,</span>
 	struct mld2_grec *pgr = NULL;
 	struct ip6_sf_list *psf, *psf_next, *psf_prev, **psf_list;
 	int scount, stotal, first, isquery, truncate;
<span class="p_add">+	unsigned int mtu;</span>
 
 	if (pmc-&gt;mca_flags &amp; MAF_NOREPORT)
 		return skb;
 
<span class="p_add">+	mtu = READ_ONCE(dev-&gt;mtu);</span>
<span class="p_add">+	if (mtu &lt; IPV6_MIN_MTU)</span>
<span class="p_add">+		return skb;</span>
<span class="p_add">+</span>
 	isquery = type == MLD2_MODE_IS_INCLUDE ||
 		  type == MLD2_MODE_IS_EXCLUDE;
 	truncate = type == MLD2_MODE_IS_EXCLUDE ||
<span class="p_chunk">@@ -1738,7 +1743,7 @@</span> <span class="p_context"> static struct sk_buff *add_grec(struct sk_buff *skb, struct ifmcaddr6 *pmc,</span>
 		    AVAILABLE(skb) &lt; grec_size(pmc, type, gdeleted, sdeleted)) {
 			if (skb)
 				mld_sendpack(skb);
<span class="p_del">-			skb = mld_newpack(idev, dev-&gt;mtu);</span>
<span class="p_add">+			skb = mld_newpack(idev, mtu);</span>
 		}
 	}
 	first = 1;
<span class="p_chunk">@@ -1774,12 +1779,12 @@</span> <span class="p_context"> static struct sk_buff *add_grec(struct sk_buff *skb, struct ifmcaddr6 *pmc,</span>
 				pgr-&gt;grec_nsrcs = htons(scount);
 			if (skb)
 				mld_sendpack(skb);
<span class="p_del">-			skb = mld_newpack(idev, dev-&gt;mtu);</span>
<span class="p_add">+			skb = mld_newpack(idev, mtu);</span>
 			first = 1;
 			scount = 0;
 		}
 		if (first) {
<span class="p_del">-			skb = add_grhead(skb, pmc, type, &amp;pgr);</span>
<span class="p_add">+			skb = add_grhead(skb, pmc, type, &amp;pgr, mtu);</span>
 			first = 0;
 		}
 		if (!skb)
<span class="p_chunk">@@ -1814,7 +1819,7 @@</span> <span class="p_context"> static struct sk_buff *add_grec(struct sk_buff *skb, struct ifmcaddr6 *pmc,</span>
 				mld_sendpack(skb);
 				skb = NULL; /* add_grhead will get a new one */
 			}
<span class="p_del">-			skb = add_grhead(skb, pmc, type, &amp;pgr);</span>
<span class="p_add">+			skb = add_grhead(skb, pmc, type, &amp;pgr, mtu);</span>
 		}
 	}
 	if (pgr)
<span class="p_header">diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">index 7ac2365aa6fb..eb624547382f 100644</span>
<span class="p_header">--- a/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">+++ b/net/ipv6/tcp_ipv6.c</span>
<span class="p_chunk">@@ -962,7 +962,7 @@</span> <span class="p_context"> static void tcp_v6_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,</span>
 			tcp_rsk(req)-&gt;rcv_nxt,
 			req-&gt;rsk_rcv_wnd &gt;&gt; inet_rsk(req)-&gt;rcv_wscale,
 			tcp_time_stamp, req-&gt;ts_recent, sk-&gt;sk_bound_dev_if,
<span class="p_del">-			tcp_v6_md5_do_lookup(sk, &amp;ipv6_hdr(skb)-&gt;daddr),</span>
<span class="p_add">+			tcp_v6_md5_do_lookup(sk, &amp;ipv6_hdr(skb)-&gt;saddr),</span>
 			0, 0);
 }
 
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index 1ff497bd9c20..e1c123d4cdda 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -261,6 +261,9 @@</span> <span class="p_context"> static int __netlink_deliver_tap_skb(struct sk_buff *skb,</span>
 	struct sock *sk = skb-&gt;sk;
 	int ret = -ENOMEM;
 
<span class="p_add">+	if (!net_eq(dev_net(dev), sock_net(sk)))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	dev_hold(dev);
 
 	if (is_vmalloc_addr(skb-&gt;head))
<span class="p_header">diff --git a/net/rds/send.c b/net/rds/send.c</span>
<span class="p_header">index ad247dc71ebb..ef53d164e146 100644</span>
<span class="p_header">--- a/net/rds/send.c</span>
<span class="p_header">+++ b/net/rds/send.c</span>
<span class="p_chunk">@@ -1006,6 +1006,9 @@</span> <span class="p_context"> static int rds_rdma_bytes(struct msghdr *msg, size_t *rdma_bytes)</span>
 			continue;
 
 		if (cmsg-&gt;cmsg_type == RDS_CMSG_RDMA_ARGS) {
<span class="p_add">+			if (cmsg-&gt;cmsg_len &lt;</span>
<span class="p_add">+			    CMSG_LEN(sizeof(struct rds_rdma_args)))</span>
<span class="p_add">+				return -EINVAL;</span>
 			args = CMSG_DATA(cmsg);
 			*rdma_bytes += args-&gt;remote_vec.bytes;
 		}
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index c2ab864da50d..7181ce6c62bf 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -4246,7 +4246,7 @@</span> <span class="p_context"> static int sctp_init_sock(struct sock *sk)</span>
 	SCTP_DBG_OBJCNT_INC(sock);
 
 	local_bh_disable();
<span class="p_del">-	percpu_counter_inc(&amp;sctp_sockets_allocated);</span>
<span class="p_add">+	sk_sockets_allocated_inc(sk);</span>
 	sock_prot_inuse_add(net, sk-&gt;sk_prot, 1);
 
 	/* Nothing can fail after this block, otherwise
<span class="p_chunk">@@ -4290,7 +4290,7 @@</span> <span class="p_context"> static void sctp_destroy_sock(struct sock *sk)</span>
 	}
 	sctp_endpoint_free(sp-&gt;ep);
 	local_bh_disable();
<span class="p_del">-	percpu_counter_dec(&amp;sctp_sockets_allocated);</span>
<span class="p_add">+	sk_sockets_allocated_dec(sk);</span>
 	sock_prot_inuse_add(sock_net(sk), sk-&gt;sk_prot, -1);
 	local_bh_enable();
 }
<span class="p_header">diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c</span>
<span class="p_header">index c9af022676c2..47c3e97c3136 100644</span>
<span class="p_header">--- a/sound/hda/hdac_i915.c</span>
<span class="p_header">+++ b/sound/hda/hdac_i915.c</span>
<span class="p_chunk">@@ -319,7 +319,7 @@</span> <span class="p_context"> static int hdac_component_master_match(struct device *dev, void *data)</span>
  */
 int snd_hdac_i915_register_notifier(const struct i915_audio_component_audio_ops *aops)
 {
<span class="p_del">-	if (WARN_ON(!hdac_acomp))</span>
<span class="p_add">+	if (!hdac_acomp)</span>
 		return -ENODEV;
 
 	hdac_acomp-&gt;audio_ops = aops;
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index ba40596b9d92..4ef3b0067876 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -5971,6 +5971,11 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
 		{0x1b, 0x01011020},
 		{0x21, 0x02211010}),
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0256, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
<span class="p_add">+		{0x12, 0x90a60130},</span>
<span class="p_add">+		{0x14, 0x90170110},</span>
<span class="p_add">+		{0x1b, 0x01011020},</span>
<span class="p_add">+		{0x21, 0x0221101f}),</span>
 	SND_HDA_PIN_QUIRK(0x10ec0256, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
 		{0x12, 0x90a60160},
 		{0x14, 0x90170120},
<span class="p_header">diff --git a/sound/soc/codecs/da7218.c b/sound/soc/codecs/da7218.c</span>
<span class="p_header">index c69e97654fc6..f88632426c0a 100644</span>
<span class="p_header">--- a/sound/soc/codecs/da7218.c</span>
<span class="p_header">+++ b/sound/soc/codecs/da7218.c</span>
<span class="p_chunk">@@ -2519,7 +2519,7 @@</span> <span class="p_context"> static struct da7218_pdata *da7218_of_to_pdata(struct snd_soc_codec *codec)</span>
 	}
 
 	if (da7218-&gt;dev_id == DA7218_DEV_ID) {
<span class="p_del">-		hpldet_np = of_find_node_by_name(np, &quot;da7218_hpldet&quot;);</span>
<span class="p_add">+		hpldet_np = of_get_child_by_name(np, &quot;da7218_hpldet&quot;);</span>
 		if (!hpldet_np)
 			return pdata;
 
<span class="p_header">diff --git a/sound/soc/codecs/tlv320aic31xx.h b/sound/soc/codecs/tlv320aic31xx.h</span>
<span class="p_header">index 5acd5b69fb83..f9b6c5a81b47 100644</span>
<span class="p_header">--- a/sound/soc/codecs/tlv320aic31xx.h</span>
<span class="p_header">+++ b/sound/soc/codecs/tlv320aic31xx.h</span>
<span class="p_chunk">@@ -115,7 +115,7 @@</span> <span class="p_context"> struct aic31xx_pdata {</span>
 /* INT2 interrupt control */
 #define AIC31XX_INT2CTRL	AIC31XX_REG(0, 49)
 /* GPIO1 control */
<span class="p_del">-#define AIC31XX_GPIO1		AIC31XX_REG(0, 50)</span>
<span class="p_add">+#define AIC31XX_GPIO1		AIC31XX_REG(0, 51)</span>
 
 #define AIC31XX_DACPRB		AIC31XX_REG(0, 60)
 /* ADC Instruction Set Register */
<span class="p_header">diff --git a/sound/soc/codecs/twl4030.c b/sound/soc/codecs/twl4030.c</span>
<span class="p_header">index a2104d68169d..26fd6a664b9b 100644</span>
<span class="p_header">--- a/sound/soc/codecs/twl4030.c</span>
<span class="p_header">+++ b/sound/soc/codecs/twl4030.c</span>
<span class="p_chunk">@@ -232,7 +232,7 @@</span> <span class="p_context"> static struct twl4030_codec_data *twl4030_get_pdata(struct snd_soc_codec *codec)</span>
 	struct twl4030_codec_data *pdata = dev_get_platdata(codec-&gt;dev);
 	struct device_node *twl4030_codec_node = NULL;
 
<span class="p_del">-	twl4030_codec_node = of_find_node_by_name(codec-&gt;dev-&gt;parent-&gt;of_node,</span>
<span class="p_add">+	twl4030_codec_node = of_get_child_by_name(codec-&gt;dev-&gt;parent-&gt;of_node,</span>
 						  &quot;codec&quot;);
 
 	if (!pdata &amp;&amp; twl4030_codec_node) {
<span class="p_chunk">@@ -241,9 +241,11 @@</span> <span class="p_context"> static struct twl4030_codec_data *twl4030_get_pdata(struct snd_soc_codec *codec)</span>
 				     GFP_KERNEL);
 		if (!pdata) {
 			dev_err(codec-&gt;dev, &quot;Can not allocate memory\n&quot;);
<span class="p_add">+			of_node_put(twl4030_codec_node);</span>
 			return NULL;
 		}
 		twl4030_setup_pdata_of(pdata, twl4030_codec_node);
<span class="p_add">+		of_node_put(twl4030_codec_node);</span>
 	}
 
 	return pdata;
<span class="p_header">diff --git a/sound/soc/codecs/wm_adsp.c b/sound/soc/codecs/wm_adsp.c</span>
<span class="p_header">index 757af795cebd..c03c9da076c2 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm_adsp.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm_adsp.c</span>
<span class="p_chunk">@@ -1465,7 +1465,7 @@</span> <span class="p_context"> static int wm_adsp_load(struct wm_adsp *dsp)</span>
 		 le64_to_cpu(footer-&gt;timestamp));
 
 	while (pos &lt; firmware-&gt;size &amp;&amp;
<span class="p_del">-	       pos - firmware-&gt;size &gt; sizeof(*region)) {</span>
<span class="p_add">+	       sizeof(*region) &lt; firmware-&gt;size - pos) {</span>
 		region = (void *)&amp;(firmware-&gt;data[pos]);
 		region_name = &quot;Unknown&quot;;
 		reg = 0;
<span class="p_chunk">@@ -1526,8 +1526,8 @@</span> <span class="p_context"> static int wm_adsp_load(struct wm_adsp *dsp)</span>
 			 regions, le32_to_cpu(region-&gt;len), offset,
 			 region_name);
 
<span class="p_del">-		if ((pos + le32_to_cpu(region-&gt;len) + sizeof(*region)) &gt;</span>
<span class="p_del">-		    firmware-&gt;size) {</span>
<span class="p_add">+		if (le32_to_cpu(region-&gt;len) &gt;</span>
<span class="p_add">+		    firmware-&gt;size - pos - sizeof(*region)) {</span>
 			adsp_err(dsp,
 				 &quot;%s.%d: %s region len %d bytes exceeds file length %zu\n&quot;,
 				 file, regions, region_name,
<span class="p_chunk">@@ -1992,7 +1992,7 @@</span> <span class="p_context"> static int wm_adsp_load_coeff(struct wm_adsp *dsp)</span>
 
 	blocks = 0;
 	while (pos &lt; firmware-&gt;size &amp;&amp;
<span class="p_del">-	       pos - firmware-&gt;size &gt; sizeof(*blk)) {</span>
<span class="p_add">+	       sizeof(*blk) &lt; firmware-&gt;size - pos) {</span>
 		blk = (void *)(&amp;firmware-&gt;data[pos]);
 
 		type = le16_to_cpu(blk-&gt;type);
<span class="p_chunk">@@ -2066,8 +2066,8 @@</span> <span class="p_context"> static int wm_adsp_load_coeff(struct wm_adsp *dsp)</span>
 		}
 
 		if (reg) {
<span class="p_del">-			if ((pos + le32_to_cpu(blk-&gt;len) + sizeof(*blk)) &gt;</span>
<span class="p_del">-			    firmware-&gt;size) {</span>
<span class="p_add">+			if (le32_to_cpu(blk-&gt;len) &gt;</span>
<span class="p_add">+			    firmware-&gt;size - pos - sizeof(*blk)) {</span>
 				adsp_err(dsp,
 					 &quot;%s.%d: %s region len %d bytes exceeds file length %zu\n&quot;,
 					 file, blocks, region_name,
<span class="p_header">diff --git a/sound/soc/fsl/fsl_ssi.c b/sound/soc/fsl/fsl_ssi.c</span>
<span class="p_header">index fde08660b63b..1c03490e1182 100644</span>
<span class="p_header">--- a/sound/soc/fsl/fsl_ssi.c</span>
<span class="p_header">+++ b/sound/soc/fsl/fsl_ssi.c</span>
<span class="p_chunk">@@ -1467,12 +1467,6 @@</span> <span class="p_context"> static int fsl_ssi_probe(struct platform_device *pdev)</span>
 				sizeof(fsl_ssi_ac97_dai));
 
 		fsl_ac97_data = ssi_private;
<span class="p_del">-</span>
<span class="p_del">-		ret = snd_soc_set_ac97_ops_of_reset(&amp;fsl_ssi_ac97_ops, pdev);</span>
<span class="p_del">-		if (ret) {</span>
<span class="p_del">-			dev_err(&amp;pdev-&gt;dev, &quot;could not set AC&#39;97 ops\n&quot;);</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-		}</span>
 	} else {
 		/* Initialize this copy of the CPU DAI driver structure */
 		memcpy(&amp;ssi_private-&gt;cpu_dai_drv, &amp;fsl_ssi_dai_template,
<span class="p_chunk">@@ -1583,6 +1577,14 @@</span> <span class="p_context"> static int fsl_ssi_probe(struct platform_device *pdev)</span>
 			return ret;
 	}
 
<span class="p_add">+	if (fsl_ssi_is_ac97(ssi_private)) {</span>
<span class="p_add">+		ret = snd_soc_set_ac97_ops_of_reset(&amp;fsl_ssi_ac97_ops, pdev);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			dev_err(&amp;pdev-&gt;dev, &quot;could not set AC&#39;97 ops\n&quot;);</span>
<span class="p_add">+			goto error_ac97_ops;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ret = devm_snd_soc_register_component(&amp;pdev-&gt;dev, &amp;fsl_ssi_component,
 					      &amp;ssi_private-&gt;cpu_dai_drv, 1);
 	if (ret) {
<span class="p_chunk">@@ -1666,6 +1668,10 @@</span> <span class="p_context"> static int fsl_ssi_probe(struct platform_device *pdev)</span>
 	fsl_ssi_debugfs_remove(&amp;ssi_private-&gt;dbg_stats);
 
 error_asoc_register:
<span class="p_add">+	if (fsl_ssi_is_ac97(ssi_private))</span>
<span class="p_add">+		snd_soc_set_ac97_ops(NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+error_ac97_ops:</span>
 	if (ssi_private-&gt;soc-&gt;imx)
 		fsl_ssi_imx_clean(pdev, ssi_private);
 
<span class="p_header">diff --git a/tools/objtool/arch/x86/insn/x86-opcode-map.txt b/tools/objtool/arch/x86/insn/x86-opcode-map.txt</span>
<span class="p_header">index 767be7c76034..1754e094bc28 100644</span>
<span class="p_header">--- a/tools/objtool/arch/x86/insn/x86-opcode-map.txt</span>
<span class="p_header">+++ b/tools/objtool/arch/x86/insn/x86-opcode-map.txt</span>
<span class="p_chunk">@@ -896,7 +896,7 @@</span> <span class="p_context"> EndTable</span>
 
 GrpTable: Grp3_1
 0: TEST Eb,Ib
<span class="p_del">-1:</span>
<span class="p_add">+1: TEST Eb,Ib</span>
 2: NOT Eb
 3: NEG Eb
 4: MUL AL,Eb
<span class="p_header">diff --git a/tools/usb/usbip/src/utils.c b/tools/usb/usbip/src/utils.c</span>
<span class="p_header">index 2b3d6d235015..3d7b42e77299 100644</span>
<span class="p_header">--- a/tools/usb/usbip/src/utils.c</span>
<span class="p_header">+++ b/tools/usb/usbip/src/utils.c</span>
<span class="p_chunk">@@ -30,6 +30,7 @@</span> <span class="p_context"> int modify_match_busid(char *busid, int add)</span>
 	char command[SYSFS_BUS_ID_SIZE + 4];
 	char match_busid_attr_path[SYSFS_PATH_MAX];
 	int rc;
<span class="p_add">+	int cmd_size;</span>
 
 	snprintf(match_busid_attr_path, sizeof(match_busid_attr_path),
 		 &quot;%s/%s/%s/%s/%s/%s&quot;, SYSFS_MNT_PATH, SYSFS_BUS_NAME,
<span class="p_chunk">@@ -37,12 +38,14 @@</span> <span class="p_context"> int modify_match_busid(char *busid, int add)</span>
 		 attr_name);
 
 	if (add)
<span class="p_del">-		snprintf(command, SYSFS_BUS_ID_SIZE + 4, &quot;add %s&quot;, busid);</span>
<span class="p_add">+		cmd_size = snprintf(command, SYSFS_BUS_ID_SIZE + 4, &quot;add %s&quot;,</span>
<span class="p_add">+				    busid);</span>
 	else
<span class="p_del">-		snprintf(command, SYSFS_BUS_ID_SIZE + 4, &quot;del %s&quot;, busid);</span>
<span class="p_add">+		cmd_size = snprintf(command, SYSFS_BUS_ID_SIZE + 4, &quot;del %s&quot;,</span>
<span class="p_add">+				    busid);</span>
 
 	rc = write_sysfs_attribute(match_busid_attr_path, command,
<span class="p_del">-				   sizeof(command));</span>
<span class="p_add">+				   cmd_size);</span>
 	if (rc &lt; 0) {
 		dbg(&quot;failed to write match_busid: %s&quot;, strerror(errno));
 		return -1;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



