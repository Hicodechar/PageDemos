
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v2] sparc64: Add support for Application Data Integrity (ADI) - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v2] sparc64: Add support for Application Data Integrity (ADI)</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>March 2, 2016, 8:39 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1456951177-23579-1-git-send-email-khalid.aziz@oracle.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8485421/mbox/"
   >mbox</a>
|
   <a href="/patch/8485421/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8485421/">/patch/8485421/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 3949D9F372
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  2 Mar 2016 20:40:04 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id CE9DA20351
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  2 Mar 2016 20:40:01 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 2FF932013D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  2 Mar 2016 20:39:59 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1755231AbcCBUju (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 2 Mar 2016 15:39:50 -0500
Received: from mailout.easymail.ca ([64.68.201.169]:50548 &quot;EHLO
	mailout.easymail.ca&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1753967AbcCBUjp (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 2 Mar 2016 15:39:45 -0500
Received: from localhost (localhost [127.0.0.1])
	by mailout.easymail.ca (Postfix) with ESMTP id A0DECEDCC;
	Wed,  2 Mar 2016 15:39:43 -0500 (EST)
X-Virus-Scanned: Debian amavisd-new at mailout.easymail.ca
X-Spam-Score: -3.707
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
Received: from mailout.easymail.ca ([127.0.0.1])
	by localhost (easymail-mailout.easydns.vpn [127.0.0.1]) (amavisd-new,
	port 10024)
	with ESMTP id j4Yl-YNRTvSC; Wed,  2 Mar 2016 15:39:42 -0500 (EST)
Received: from mail.gonehiking.org (c-73-181-52-62.hsd1.co.comcast.net
	[73.181.52.62])
	by mailout.easymail.ca (Postfix) with ESMTPA id 46085EDAE;
	Wed,  2 Mar 2016 15:39:42 -0500 (EST)
Received: from concerto.us.oracle.com (concerto-wl.internal [192.168.1.22])
	by mail.gonehiking.org (Postfix) with ESMTP id 340989F14A;
	Wed,  2 Mar 2016 13:39:41 -0700 (MST)
From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;
To: davem@davemloft.net, corbet@lwn.net, akpm@linux-foundation.org,
	dingel@linux.vnet.ibm.com, zhenzhang.zhang@huawei.com,
	bob.picco@oracle.com, kirill.shutemov@linux.intel.com,
	aneesh.kumar@linux.vnet.ibm.com, aarcange@redhat.com,
	arnd@arndb.de, sparclinux@vger.kernel.org
Cc: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;, rob.gardner@oracle.com,
	mhocko@suse.cz, chris.hyser@oracle.com, richard@nod.at,
	vbabka@suse.cz, koct9i@gmail.com, oleg@redhat.com,
	gthelen@google.com, jack@suse.cz, xiexiuqi@huawei.com,
	Vineet.Gupta1@synopsys.com, luto@kernel.org, ebiederm@xmission.com,
	bsegall@google.com, geert@linux-m68k.org, dave@stgolabs.net,
	adobriyan@gmail.com, linux-doc@vger.kernel.org,
	linux-kernel@vger.kernel.org, linux-mm@kvack.org,
	linux-arch@vger.kernel.org, linux-api@vger.kernel.org
Subject: [PATCH v2] sparc64: Add support for Application Data Integrity (ADI)
Date: Wed,  2 Mar 2016 13:39:37 -0700
Message-Id: &lt;1456951177-23579-1-git-send-email-khalid.aziz@oracle.com&gt;
X-Mailer: git-send-email 2.1.4
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 2, 2016, 8:39 p.m.</div>
<pre class="content">
Enable Application Data Integrity (ADI) support in the sparc
kernel for applications to use ADI in userspace. ADI is a new
feature supported on sparc M7 and newer processors. ADI is supported
for data fetches only and not instruction fetches. This patch adds
prctl commands to enable and disable ADI (TSTATE.mcde), return ADI
parameters to userspace, enable/disable MCD (Memory Corruption
Detection) on selected memory ranges and enable TTE.mcd in PTEs. It
also adds handlers for all traps related to MCD. ADI is not enabled
by default for any task and a task must explicitly enable ADI
(TSTATE.mcde), turn MCD on on a memory range and set version tag
for ADI to be effective for the task. This patch adds support for
ADI for hugepages only. Addresses passed into system calls must be
non-ADI tagged addresses.
<span class="signed-off-by">
Signed-off-by: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
---
NOTES: ADI is a new feature added to M7 processor to allow hardware
	to catch rogue accesses to memory. An app can enable ADI on
	its data pages, set version tags on them and use versioned
	addresses (bits 63-60 of the address contain a version tag)
	to access the data pages. If a rogue app attempts to access
	ADI enabled data pages, its access is blocked and processor
	generates an exception. Enabling this functionality for all
	data pages of an app requires adding infrastructure to save
	version tags for any data pages that get swapped out and
	restoring those tags when pages are swapped back in. In this
	first implementation I am enabling ADI for hugepages only
	since these pages are locked in memory and hence avoid the
	issue of saving and restoring tags. Once this core functionality
	is stable, ADI for other memory pages can be enabled more
	easily.

v2:
	- Fixed a build error

 Documentation/prctl/sparc_adi.txt     |  62 ++++++++++
 Documentation/sparc/adi.txt           | 206 +++++++++++++++++++++++++++++++
 arch/sparc/Kconfig                    |  12 ++
 arch/sparc/include/asm/hugetlb.h      |  14 +++
 arch/sparc/include/asm/hypervisor.h   |   2 +
 arch/sparc/include/asm/mmu_64.h       |   1 +
 arch/sparc/include/asm/pgtable_64.h   |  15 +++
 arch/sparc/include/asm/processor_64.h |  19 +++
 arch/sparc/include/asm/ttable.h       |  10 ++
 arch/sparc/include/uapi/asm/asi.h     |   3 +
 arch/sparc/include/uapi/asm/pstate.h  |  10 ++
 arch/sparc/kernel/entry.h             |   3 +
 arch/sparc/kernel/head_64.S           |   1 +
 arch/sparc/kernel/mdesc.c             |  81 +++++++++++++
 arch/sparc/kernel/process_64.c        | 222 ++++++++++++++++++++++++++++++++++
 arch/sparc/kernel/sun4v_mcd.S         |  16 +++
 arch/sparc/kernel/traps_64.c          |  96 ++++++++++++++-
 arch/sparc/kernel/ttable_64.S         |   6 +-
 include/linux/mm.h                    |   2 +
 include/uapi/asm-generic/siginfo.h    |   5 +-
 include/uapi/linux/prctl.h            |  16 +++
 kernel/sys.c                          |  30 +++++
 22 files changed, 826 insertions(+), 6 deletions(-)
 create mode 100644 Documentation/prctl/sparc_adi.txt
 create mode 100644 Documentation/sparc/adi.txt
 create mode 100644 arch/sparc/kernel/sun4v_mcd.S
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=545">Julian Calaby</a> - March 2, 2016, 11:08 p.m.</div>
<pre class="content">
Hi Khalid,

On Thu, Mar 3, 2016 at 7:39 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt; wrote:
<span class="quote">&gt;</span>
<span class="quote">&gt; Enable Application Data Integrity (ADI) support in the sparc</span>
<span class="quote">&gt; kernel for applications to use ADI in userspace. ADI is a new</span>
<span class="quote">&gt; feature supported on sparc M7 and newer processors. ADI is supported</span>
<span class="quote">&gt; for data fetches only and not instruction fetches. This patch adds</span>
<span class="quote">&gt; prctl commands to enable and disable ADI (TSTATE.mcde), return ADI</span>
<span class="quote">&gt; parameters to userspace, enable/disable MCD (Memory Corruption</span>
<span class="quote">&gt; Detection) on selected memory ranges and enable TTE.mcd in PTEs. It</span>
<span class="quote">&gt; also adds handlers for all traps related to MCD. ADI is not enabled</span>
<span class="quote">&gt; by default for any task and a task must explicitly enable ADI</span>
<span class="quote">&gt; (TSTATE.mcde), turn MCD on on a memory range and set version tag</span>
<span class="quote">&gt; for ADI to be effective for the task. This patch adds support for</span>
<span class="quote">&gt; ADI for hugepages only. Addresses passed into system calls must be</span>
<span class="quote">&gt; non-ADI tagged addresses.</span>

I can&#39;t comment on the actual functionality here, but I do see a few
minor style issues in your patch.

My big concern is that you&#39;re defining a lot of new code that is ADI
specific but isn&#39;t inside a CONFIG_SPARC_ADI ifdef. (That said,
handling ADI specific traps if ADI isn&#39;t enabled looks like a good
idea to me, however most of the other stuff is just dead code if
CONFIG_SPARC_ADI isn&#39;t enabled.)
<span class="quote">
&gt; Signed-off-by: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt; NOTES: ADI is a new feature added to M7 processor to allow hardware</span>
<span class="quote">&gt;         to catch rogue accesses to memory. An app can enable ADI on</span>
<span class="quote">&gt;         its data pages, set version tags on them and use versioned</span>
<span class="quote">&gt;         addresses (bits 63-60 of the address contain a version tag)</span>
<span class="quote">&gt;         to access the data pages. If a rogue app attempts to access</span>
<span class="quote">&gt;         ADI enabled data pages, its access is blocked and processor</span>
<span class="quote">&gt;         generates an exception. Enabling this functionality for all</span>
<span class="quote">&gt;         data pages of an app requires adding infrastructure to save</span>
<span class="quote">&gt;         version tags for any data pages that get swapped out and</span>
<span class="quote">&gt;         restoring those tags when pages are swapped back in. In this</span>
<span class="quote">&gt;         first implementation I am enabling ADI for hugepages only</span>
<span class="quote">&gt;         since these pages are locked in memory and hence avoid the</span>
<span class="quote">&gt;         issue of saving and restoring tags. Once this core functionality</span>
<span class="quote">&gt;         is stable, ADI for other memory pages can be enabled more</span>
<span class="quote">&gt;         easily.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; v2:</span>
<span class="quote">&gt;         - Fixed a build error</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  Documentation/prctl/sparc_adi.txt     |  62 ++++++++++</span>
<span class="quote">&gt;  Documentation/sparc/adi.txt           | 206 +++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  arch/sparc/Kconfig                    |  12 ++</span>
<span class="quote">&gt;  arch/sparc/include/asm/hugetlb.h      |  14 +++</span>
<span class="quote">&gt;  arch/sparc/include/asm/hypervisor.h   |   2 +</span>
<span class="quote">&gt;  arch/sparc/include/asm/mmu_64.h       |   1 +</span>
<span class="quote">&gt;  arch/sparc/include/asm/pgtable_64.h   |  15 +++</span>
<span class="quote">&gt;  arch/sparc/include/asm/processor_64.h |  19 +++</span>
<span class="quote">&gt;  arch/sparc/include/asm/ttable.h       |  10 ++</span>
<span class="quote">&gt;  arch/sparc/include/uapi/asm/asi.h     |   3 +</span>
<span class="quote">&gt;  arch/sparc/include/uapi/asm/pstate.h  |  10 ++</span>
<span class="quote">&gt;  arch/sparc/kernel/entry.h             |   3 +</span>
<span class="quote">&gt;  arch/sparc/kernel/head_64.S           |   1 +</span>
<span class="quote">&gt;  arch/sparc/kernel/mdesc.c             |  81 +++++++++++++</span>
<span class="quote">&gt;  arch/sparc/kernel/process_64.c        | 222 ++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  arch/sparc/kernel/sun4v_mcd.S         |  16 +++</span>
<span class="quote">&gt;  arch/sparc/kernel/traps_64.c          |  96 ++++++++++++++-</span>
<span class="quote">&gt;  arch/sparc/kernel/ttable_64.S         |   6 +-</span>
<span class="quote">&gt;  include/linux/mm.h                    |   2 +</span>
<span class="quote">&gt;  include/uapi/asm-generic/siginfo.h    |   5 +-</span>
<span class="quote">&gt;  include/uapi/linux/prctl.h            |  16 +++</span>
<span class="quote">&gt;  kernel/sys.c                          |  30 +++++</span>
<span class="quote">&gt;  22 files changed, 826 insertions(+), 6 deletions(-)</span>
<span class="quote">&gt;  create mode 100644 Documentation/prctl/sparc_adi.txt</span>
<span class="quote">&gt;  create mode 100644 Documentation/sparc/adi.txt</span>
<span class="quote">&gt;  create mode 100644 arch/sparc/kernel/sun4v_mcd.S</span>

I must admit that I&#39;m slightly impressed that the documentation is
over a quarter of the lines added. =)
<span class="quote">
&gt; diff --git a/arch/sparc/Kconfig b/arch/sparc/Kconfig</span>
<span class="quote">&gt; index 56442d2..0aac0ae 100644</span>
<span class="quote">&gt; --- a/arch/sparc/Kconfig</span>
<span class="quote">&gt; +++ b/arch/sparc/Kconfig</span>
<span class="quote">&gt; @@ -80,6 +80,7 @@ config SPARC64</span>
<span class="quote">&gt;         select NO_BOOTMEM</span>
<span class="quote">&gt;         select HAVE_ARCH_AUDITSYSCALL</span>
<span class="quote">&gt;         select ARCH_SUPPORTS_ATOMIC_RMW</span>
<span class="quote">&gt; +       select SPARC_ADI</span>

This doesn&#39;t look right.
<span class="quote">
&gt;  config ARCH_DEFCONFIG</span>
<span class="quote">&gt;         string</span>
<span class="quote">&gt; @@ -314,6 +315,17 @@ if SPARC64</span>
<span class="quote">&gt;  source &quot;kernel/power/Kconfig&quot;</span>
<span class="quote">&gt;  endif</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +config SPARC_ADI</span>
<span class="quote">&gt; +       bool &quot;Application Data Integrity support&quot;</span>
<span class="quote">&gt; +       def_bool y if SPARC64</span>

def_bool is for config options without names (i.e. &quot;this is a boolean
value and it&#39;s default is...&quot;)

So if you want people to be able to disable this option, then you
should remove the select above and just have:

bool &quot;Application Data Integrity support&quot;
default y if SPARC64

If you don&#39;t want people disabling it, then there&#39;s no point in having
a separate Kconfig symbol.
<span class="quote">
&gt; +       help</span>
<span class="quote">&gt; +         Support for Application Data Integrity (ADI). ADI feature allows</span>
<span class="quote">&gt; +         a process to tag memory blocks with version tags. Once ADI is</span>
<span class="quote">&gt; +         enabled and version tag is set on a memory block, any access to</span>
<span class="quote">&gt; +         it is allowed only if the correct version tag is presented by</span>
<span class="quote">&gt; +         a process. This feature is meant to help catch rogue accesses</span>
<span class="quote">&gt; +         to memory.</span>
<span class="quote">&gt; +</span>

You should probably mention that it&#39;s only available on newer
processors and recommend that it&#39;s enabled on them.

This code won&#39;t break anything on older processors, right? I haven&#39;t
looked very closely, but I don&#39;t see anything that specifically
disables the code if it&#39;s run on, say, a UltraSparc I.
<span class="quote">
&gt;  config SCHED_SMT</span>
<span class="quote">&gt;         bool &quot;SMT (Hyperthreading) scheduler support&quot;</span>
<span class="quote">&gt;         depends on SPARC64 &amp;&amp; SMP</span>
<span class="quote">&gt; diff --git a/arch/sparc/include/asm/processor_64.h b/arch/sparc/include/asm/processor_64.h</span>
<span class="quote">&gt; index 6924bde..9a71701 100644</span>
<span class="quote">&gt; --- a/arch/sparc/include/asm/processor_64.h</span>
<span class="quote">&gt; +++ b/arch/sparc/include/asm/processor_64.h</span>
<span class="quote">&gt; @@ -97,6 +97,25 @@ struct thread_struct {</span>
<span class="quote">&gt;  struct task_struct;</span>
<span class="quote">&gt;  unsigned long thread_saved_pc(struct task_struct *);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +#ifdef CONFIG_SPARC_ADI</span>
<span class="quote">&gt; +extern struct adi_caps *get_adi_caps(void);</span>
<span class="quote">&gt; +extern long get_sparc_adicaps(unsigned long);</span>
<span class="quote">&gt; +extern long set_sparc_pstate_mcde(unsigned long);</span>
<span class="quote">&gt; +extern long enable_sparc_adi(unsigned long, unsigned long);</span>
<span class="quote">&gt; +extern long disable_sparc_adi(unsigned long, unsigned long);</span>
<span class="quote">&gt; +extern long get_sparc_adi_status(unsigned long);</span>
<span class="quote">&gt; +extern bool adi_capable(void);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define GET_SPARC_ADICAPS(a)   get_sparc_adicaps(a)</span>
<span class="quote">&gt; +#define SET_SPARC_MCDE(a)      set_sparc_pstate_mcde(a)</span>
<span class="quote">&gt; +#define ENABLE_SPARC_ADI(a, b) enable_sparc_adi(a, b)</span>
<span class="quote">&gt; +#define DISABLE_SPARC_ADI(a, b)        disable_sparc_adi(a, b)</span>
<span class="quote">&gt; +#define GET_SPARC_ADI_STATUS(a)        get_sparc_adi_status(a)</span>
<span class="quote">&gt; +#define ADI_CAPABLE()          adi_capable()</span>

Get rid of the ADI_CAPABLE macro, the usual pattern here is to define
a static inline function for the entire API when the symbol is
disabled, i.e.

#ifdef CONFIG_SPARC_ADI
...
extern bool adi_capable(void);
#else
...
static inline bool adi_capable(void) {
    return false;
}
#endif

That way you get type checking on the arguments even if the option is
disabled and modern compilers are smart enough to optimise all the
no-op code away. (Not that the type checking is needed here.)

Also, in all but one place you use the ADI_CAPABLE() macro when the
adi_capable() function is defined and available.
<span class="quote">
&gt; +#else</span>
<span class="quote">&gt; +#define ADI_CAPABLE()          0</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  /* On Uniprocessor, even in RMO processes see TSO semantics */</span>
<span class="quote">&gt;  #ifdef CONFIG_SMP</span>
<span class="quote">&gt;  #define TSTATE_INITIAL_MM      TSTATE_TSO</span>
<span class="quote">&gt; diff --git a/arch/sparc/kernel/mdesc.c b/arch/sparc/kernel/mdesc.c</span>
<span class="quote">&gt; index 6f80936..79f981c 100644</span>
<span class="quote">&gt; --- a/arch/sparc/kernel/mdesc.c</span>
<span class="quote">&gt; +++ b/arch/sparc/kernel/mdesc.c</span>
<span class="quote">&gt; @@ -1007,6 +1013,80 @@ static int mdesc_open(struct inode *inode, struct file *file)</span>
<span class="quote">&gt;         return 0;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +bool adi_capable(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       return adi_state.enabled;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct adi_caps *get_adi_caps(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       return &amp;adi_state.caps;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +void __init</span>
<span class="quote">&gt; +init_adi(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mdesc_handle *hp = mdesc_grab();</span>
<span class="quote">&gt; +       const char *prop;</span>
<span class="quote">&gt; +       u64 pn, *val;</span>
<span class="quote">&gt; +       int len;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       adi_state.enabled = false;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (!hp)</span>
<span class="quote">&gt; +               return;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pn = mdesc_node_by_name(hp, MDESC_NODE_NULL, &quot;cpu&quot;);</span>
<span class="quote">&gt; +       if (pn == MDESC_NODE_NULL)</span>
<span class="quote">&gt; +               goto out;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       prop = mdesc_get_property(hp, pn, &quot;hwcap-list&quot;, &amp;len);</span>
<span class="quote">&gt; +       if (!prop)</span>
<span class="quote">&gt; +               goto out;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /*</span>
<span class="quote">&gt; +        * Look for &quot;adp&quot; keyword in hwcap-list which would indicate</span>
<span class="quote">&gt; +        * ADI support</span>
<span class="quote">&gt; +        */</span>
<span class="quote">&gt; +       while (len) {</span>
<span class="quote">&gt; +               int plen;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               if (!strcmp(prop, &quot;adp&quot;)) {</span>
<span class="quote">&gt; +                       adi_state.enabled = true;</span>
<span class="quote">&gt; +                       break;</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               plen = strlen(prop) + 1;</span>
<span class="quote">&gt; +               prop += plen;</span>
<span class="quote">&gt; +               len -= plen;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (!adi_state.enabled)</span>
<span class="quote">&gt; +               goto out;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pn = mdesc_node_by_name(hp, MDESC_NODE_NULL, &quot;platform&quot;);</span>
<span class="quote">&gt; +       if (pn == MDESC_NODE_NULL)</span>
<span class="quote">&gt; +               goto out;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       val = (u64 *) mdesc_get_property(hp, pn, &quot;adp-blksz&quot;, &amp;len);</span>
<span class="quote">&gt; +       if (!val)</span>
<span class="quote">&gt; +               goto out;</span>
<span class="quote">&gt; +       adi_state.caps.blksz = *val;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       val = (u64 *) mdesc_get_property(hp, pn, &quot;adp-nbits&quot;, &amp;len);</span>
<span class="quote">&gt; +       if (!val)</span>
<span class="quote">&gt; +               goto out;</span>
<span class="quote">&gt; +       adi_state.caps.nbits = *val;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       val = (u64 *) mdesc_get_property(hp, pn, &quot;ue-on-adp&quot;, &amp;len);</span>
<span class="quote">&gt; +       if (!val)</span>
<span class="quote">&gt; +               goto out;</span>
<span class="quote">&gt; +       adi_state.caps.ue_on_adi = *val;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +out:</span>
<span class="quote">&gt; +       mdesc_release(hp);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>

Should all the ADI related functions above be within a #ifdef CONFIG_SPARC_ADI?
<span class="quote">
&gt;  static ssize_t mdesc_read(struct file *file, char __user *buf,</span>
<span class="quote">&gt;                           size_t len, loff_t *offp)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; diff --git a/arch/sparc/kernel/traps_64.c b/arch/sparc/kernel/traps_64.c</span>
<span class="quote">&gt; index d21cd62..29db583 100644</span>
<span class="quote">&gt; --- a/arch/sparc/kernel/traps_64.c</span>
<span class="quote">&gt; +++ b/arch/sparc/kernel/traps_64.c</span>
<span class="quote">&gt; @@ -2531,6 +2589,38 @@ void sun4v_do_mna(struct pt_regs *regs, unsigned long addr, unsigned long type_c</span>
<span class="quote">&gt;         force_sig_info(SIGBUS, &amp;info, current);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +void sun4v_mem_corrupt_detect_precise(struct pt_regs *regs, unsigned long addr,</span>
<span class="quote">&gt; +                                     unsigned long context)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       siginfo_t info;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (!ADI_CAPABLE()) {</span>
<span class="quote">&gt; +               bad_trap(regs, 0x1a);</span>
<span class="quote">&gt; +               return;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (notify_die(DIE_TRAP, &quot;memory corruption precise exception&quot;, regs,</span>
<span class="quote">&gt; +                      0, 0x8, SIGSEGV) == NOTIFY_STOP)</span>
<span class="quote">&gt; +               return;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (regs-&gt;tstate &amp; TSTATE_PRIV) {</span>
<span class="quote">&gt; +               pr_emerg(&quot;sun4v_mem_corrupt_detect_precise: ADDR[%016lx] &quot;</span>
<span class="quote">&gt; +                       &quot;CTX[%lx], going.\n&quot;, addr, context);</span>
<span class="quote">&gt; +               die_if_kernel(&quot;MCD precise&quot;, regs);</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (test_thread_flag(TIF_32BIT)) {</span>
<span class="quote">&gt; +               regs-&gt;tpc &amp;= 0xffffffff;</span>
<span class="quote">&gt; +               regs-&gt;tnpc &amp;= 0xffffffff;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +       info.si_signo = SIGSEGV;</span>
<span class="quote">&gt; +       info.si_code = SEGV_ADIPERR;</span>
<span class="quote">&gt; +       info.si_errno = 0;</span>
<span class="quote">&gt; +       info.si_addr = (void __user *) addr;</span>
<span class="quote">&gt; +       info.si_trapno = 0;</span>
<span class="quote">&gt; +       force_sig_info(SIGSEGV, &amp;info, current);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>

Should this be ifdef&#39;d too?
<span class="quote">
&gt;  void do_privop(struct pt_regs *regs)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;         enum ctx_state prev_state = exception_enter();</span>
<span class="quote">&gt; diff --git a/kernel/sys.c b/kernel/sys.c</span>
<span class="quote">&gt; index 6af9212..fa7b5d9 100644</span>
<span class="quote">&gt; --- a/kernel/sys.c</span>
<span class="quote">&gt; +++ b/kernel/sys.c</span>
<span class="quote">&gt; @@ -103,6 +103,21 @@</span>
<span class="quote">&gt;  #ifndef SET_FP_MODE</span>
<span class="quote">&gt;  # define SET_FP_MODE(a,b)      (-EINVAL)</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt; +#ifndef GET_SPARC_ADICAPS</span>
<span class="quote">&gt; +# define GET_SPARC_ADICAPS(a)          (-EINVAL)</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt; +#ifndef SET_SPARC_MCDE</span>
<span class="quote">&gt; +# define SET_SPARC_MCDE(a)             (-EINVAL)</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt; +#ifndef ENABLE_SPARC_ADI</span>
<span class="quote">&gt; +# define ENABLE_SPARC_ADI(a, b)                (-EINVAL)</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt; +#ifndef DISABLE_SPARC_ADI</span>
<span class="quote">&gt; +# define DISABLE_SPARC_ADI(a, b)       (-EINVAL)</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt; +#ifndef GET_SPARC_ADI_STATUS</span>
<span class="quote">&gt; +# define GET_SPARC_ADI_STATUS(a)       (-EINVAL)</span>
<span class="quote">&gt; +#endif</span>

Ah, I was wondering why you were defining macros in processor_64.h.
<span class="quote">
&gt;  /*</span>
<span class="quote">&gt;   * this is where the system-wide overflow UID and GID are defined, for</span>

I&#39;ve got a couple more comments, I&#39;ll send another email with them shortly.

Thanks,
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 3, 2016, 12:25 a.m.</div>
<pre class="content">
Thanks, Julian! I really appreciate your feedback.

My comments below.

On 03/02/2016 04:08 PM, Julian Calaby wrote:
<span class="quote">&gt; Hi Khalid,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; On Thu, Mar 3, 2016 at 7:39 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt; wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Enable Application Data Integrity (ADI) support in the sparc</span>
<span class="quote">&gt;&gt; kernel for applications to use ADI in userspace. ADI is a new</span>
<span class="quote">&gt;&gt; feature supported on sparc M7 and newer processors. ADI is supported</span>
<span class="quote">&gt;&gt; for data fetches only and not instruction fetches. This patch adds</span>
<span class="quote">&gt;&gt; prctl commands to enable and disable ADI (TSTATE.mcde), return ADI</span>
<span class="quote">&gt;&gt; parameters to userspace, enable/disable MCD (Memory Corruption</span>
<span class="quote">&gt;&gt; Detection) on selected memory ranges and enable TTE.mcd in PTEs. It</span>
<span class="quote">&gt;&gt; also adds handlers for all traps related to MCD. ADI is not enabled</span>
<span class="quote">&gt;&gt; by default for any task and a task must explicitly enable ADI</span>
<span class="quote">&gt;&gt; (TSTATE.mcde), turn MCD on on a memory range and set version tag</span>
<span class="quote">&gt;&gt; for ADI to be effective for the task. This patch adds support for</span>
<span class="quote">&gt;&gt; ADI for hugepages only. Addresses passed into system calls must be</span>
<span class="quote">&gt;&gt; non-ADI tagged addresses.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I can&#39;t comment on the actual functionality here, but I do see a few</span>
<span class="quote">&gt; minor style issues in your patch.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; My big concern is that you&#39;re defining a lot of new code that is ADI</span>
<span class="quote">&gt; specific but isn&#39;t inside a CONFIG_SPARC_ADI ifdef. (That said,</span>
<span class="quote">&gt; handling ADI specific traps if ADI isn&#39;t enabled looks like a good</span>
<span class="quote">&gt; idea to me, however most of the other stuff is just dead code if</span>
<span class="quote">&gt; CONFIG_SPARC_ADI isn&#39;t enabled.)</span>

Some of the code will be executed when CONFIG_SPARC_ADI is not enabled, 
for instance init_adi() which will parse machine description to 
determine if platform supports ADI. On the other hand, it might still 
make sense to enclose this code in #ifdef. More on that below.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt;&gt; NOTES: ADI is a new feature added to M7 processor to allow hardware</span>
<span class="quote">&gt;&gt;          to catch rogue accesses to memory. An app can enable ADI on</span>
<span class="quote">&gt;&gt;          its data pages, set version tags on them and use versioned</span>
<span class="quote">&gt;&gt;          addresses (bits 63-60 of the address contain a version tag)</span>
<span class="quote">&gt;&gt;          to access the data pages. If a rogue app attempts to access</span>
<span class="quote">&gt;&gt;          ADI enabled data pages, its access is blocked and processor</span>
<span class="quote">&gt;&gt;          generates an exception. Enabling this functionality for all</span>
<span class="quote">&gt;&gt;          data pages of an app requires adding infrastructure to save</span>
<span class="quote">&gt;&gt;          version tags for any data pages that get swapped out and</span>
<span class="quote">&gt;&gt;          restoring those tags when pages are swapped back in. In this</span>
<span class="quote">&gt;&gt;          first implementation I am enabling ADI for hugepages only</span>
<span class="quote">&gt;&gt;          since these pages are locked in memory and hence avoid the</span>
<span class="quote">&gt;&gt;          issue of saving and restoring tags. Once this core functionality</span>
<span class="quote">&gt;&gt;          is stable, ADI for other memory pages can be enabled more</span>
<span class="quote">&gt;&gt;          easily.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; v2:</span>
<span class="quote">&gt;&gt;          - Fixed a build error</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;   Documentation/prctl/sparc_adi.txt     |  62 ++++++++++</span>
<span class="quote">&gt;&gt;   Documentation/sparc/adi.txt           | 206 +++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;   arch/sparc/Kconfig                    |  12 ++</span>
<span class="quote">&gt;&gt;   arch/sparc/include/asm/hugetlb.h      |  14 +++</span>
<span class="quote">&gt;&gt;   arch/sparc/include/asm/hypervisor.h   |   2 +</span>
<span class="quote">&gt;&gt;   arch/sparc/include/asm/mmu_64.h       |   1 +</span>
<span class="quote">&gt;&gt;   arch/sparc/include/asm/pgtable_64.h   |  15 +++</span>
<span class="quote">&gt;&gt;   arch/sparc/include/asm/processor_64.h |  19 +++</span>
<span class="quote">&gt;&gt;   arch/sparc/include/asm/ttable.h       |  10 ++</span>
<span class="quote">&gt;&gt;   arch/sparc/include/uapi/asm/asi.h     |   3 +</span>
<span class="quote">&gt;&gt;   arch/sparc/include/uapi/asm/pstate.h  |  10 ++</span>
<span class="quote">&gt;&gt;   arch/sparc/kernel/entry.h             |   3 +</span>
<span class="quote">&gt;&gt;   arch/sparc/kernel/head_64.S           |   1 +</span>
<span class="quote">&gt;&gt;   arch/sparc/kernel/mdesc.c             |  81 +++++++++++++</span>
<span class="quote">&gt;&gt;   arch/sparc/kernel/process_64.c        | 222 ++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;   arch/sparc/kernel/sun4v_mcd.S         |  16 +++</span>
<span class="quote">&gt;&gt;   arch/sparc/kernel/traps_64.c          |  96 ++++++++++++++-</span>
<span class="quote">&gt;&gt;   arch/sparc/kernel/ttable_64.S         |   6 +-</span>
<span class="quote">&gt;&gt;   include/linux/mm.h                    |   2 +</span>
<span class="quote">&gt;&gt;   include/uapi/asm-generic/siginfo.h    |   5 +-</span>
<span class="quote">&gt;&gt;   include/uapi/linux/prctl.h            |  16 +++</span>
<span class="quote">&gt;&gt;   kernel/sys.c                          |  30 +++++</span>
<span class="quote">&gt;&gt;   22 files changed, 826 insertions(+), 6 deletions(-)</span>
<span class="quote">&gt;&gt;   create mode 100644 Documentation/prctl/sparc_adi.txt</span>
<span class="quote">&gt;&gt;   create mode 100644 Documentation/sparc/adi.txt</span>
<span class="quote">&gt;&gt;   create mode 100644 arch/sparc/kernel/sun4v_mcd.S</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I must admit that I&#39;m slightly impressed that the documentation is</span>
<span class="quote">&gt; over a quarter of the lines added. =)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; diff --git a/arch/sparc/Kconfig b/arch/sparc/Kconfig</span>
<span class="quote">&gt;&gt; index 56442d2..0aac0ae 100644</span>
<span class="quote">&gt;&gt; --- a/arch/sparc/Kconfig</span>
<span class="quote">&gt;&gt; +++ b/arch/sparc/Kconfig</span>
<span class="quote">&gt;&gt; @@ -80,6 +80,7 @@ config SPARC64</span>
<span class="quote">&gt;&gt;          select NO_BOOTMEM</span>
<span class="quote">&gt;&gt;          select HAVE_ARCH_AUDITSYSCALL</span>
<span class="quote">&gt;&gt;          select ARCH_SUPPORTS_ATOMIC_RMW</span>
<span class="quote">&gt;&gt; +       select SPARC_ADI</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This doesn&#39;t look right.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;   config ARCH_DEFCONFIG</span>
<span class="quote">&gt;&gt;          string</span>
<span class="quote">&gt;&gt; @@ -314,6 +315,17 @@ if SPARC64</span>
<span class="quote">&gt;&gt;   source &quot;kernel/power/Kconfig&quot;</span>
<span class="quote">&gt;&gt;   endif</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +config SPARC_ADI</span>
<span class="quote">&gt;&gt; +       bool &quot;Application Data Integrity support&quot;</span>
<span class="quote">&gt;&gt; +       def_bool y if SPARC64</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; def_bool is for config options without names (i.e. &quot;this is a boolean</span>
<span class="quote">&gt; value and it&#39;s default is...&quot;)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; So if you want people to be able to disable this option, then you</span>
<span class="quote">&gt; should remove the select above and just have:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; bool &quot;Application Data Integrity support&quot;</span>
<span class="quote">&gt; default y if SPARC64</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; If you don&#39;t want people disabling it, then there&#39;s no point in having</span>
<span class="quote">&gt; a separate Kconfig symbol.</span>
<span class="quote">&gt;</span>

Ah, I see. I do not want people disabling it. I will make changes.
<span class="quote">
&gt;&gt; +       help</span>
<span class="quote">&gt;&gt; +         Support for Application Data Integrity (ADI). ADI feature allows</span>
<span class="quote">&gt;&gt; +         a process to tag memory blocks with version tags. Once ADI is</span>
<span class="quote">&gt;&gt; +         enabled and version tag is set on a memory block, any access to</span>
<span class="quote">&gt;&gt; +         it is allowed only if the correct version tag is presented by</span>
<span class="quote">&gt;&gt; +         a process. This feature is meant to help catch rogue accesses</span>
<span class="quote">&gt;&gt; +         to memory.</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; You should probably mention that it&#39;s only available on newer</span>
<span class="quote">&gt; processors and recommend that it&#39;s enabled on them.</span>

Good point.
<span class="quote">
&gt;</span>
<span class="quote">&gt; This code won&#39;t break anything on older processors, right? I haven&#39;t</span>
<span class="quote">&gt; looked very closely, but I don&#39;t see anything that specifically</span>
<span class="quote">&gt; disables the code if it&#39;s run on, say, a UltraSparc I.</span>

Right, this code does not break anything on older processors and has 
been tested on older machines. init_adi() will detect the platform does 
not support ADI when it parses machine description and will leave ADI 
disabled in that case (adi_state.enabled=false).
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt;   config SCHED_SMT</span>
<span class="quote">&gt;&gt;          bool &quot;SMT (Hyperthreading) scheduler support&quot;</span>
<span class="quote">&gt;&gt;          depends on SPARC64 &amp;&amp; SMP</span>
<span class="quote">&gt;&gt; diff --git a/arch/sparc/include/asm/processor_64.h b/arch/sparc/include/asm/processor_64.h</span>
<span class="quote">&gt;&gt; index 6924bde..9a71701 100644</span>
<span class="quote">&gt;&gt; --- a/arch/sparc/include/asm/processor_64.h</span>
<span class="quote">&gt;&gt; +++ b/arch/sparc/include/asm/processor_64.h</span>
<span class="quote">&gt;&gt; @@ -97,6 +97,25 @@ struct thread_struct {</span>
<span class="quote">&gt;&gt;   struct task_struct;</span>
<span class="quote">&gt;&gt;   unsigned long thread_saved_pc(struct task_struct *);</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +#ifdef CONFIG_SPARC_ADI</span>
<span class="quote">&gt;&gt; +extern struct adi_caps *get_adi_caps(void);</span>
<span class="quote">&gt;&gt; +extern long get_sparc_adicaps(unsigned long);</span>
<span class="quote">&gt;&gt; +extern long set_sparc_pstate_mcde(unsigned long);</span>
<span class="quote">&gt;&gt; +extern long enable_sparc_adi(unsigned long, unsigned long);</span>
<span class="quote">&gt;&gt; +extern long disable_sparc_adi(unsigned long, unsigned long);</span>
<span class="quote">&gt;&gt; +extern long get_sparc_adi_status(unsigned long);</span>
<span class="quote">&gt;&gt; +extern bool adi_capable(void);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +#define GET_SPARC_ADICAPS(a)   get_sparc_adicaps(a)</span>
<span class="quote">&gt;&gt; +#define SET_SPARC_MCDE(a)      set_sparc_pstate_mcde(a)</span>
<span class="quote">&gt;&gt; +#define ENABLE_SPARC_ADI(a, b) enable_sparc_adi(a, b)</span>
<span class="quote">&gt;&gt; +#define DISABLE_SPARC_ADI(a, b)        disable_sparc_adi(a, b)</span>
<span class="quote">&gt;&gt; +#define GET_SPARC_ADI_STATUS(a)        get_sparc_adi_status(a)</span>
<span class="quote">&gt;&gt; +#define ADI_CAPABLE()          adi_capable()</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Get rid of the ADI_CAPABLE macro, the usual pattern here is to define</span>
<span class="quote">&gt; a static inline function for the entire API when the symbol is</span>
<span class="quote">&gt; disabled, i.e.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; #ifdef CONFIG_SPARC_ADI</span>
<span class="quote">&gt; ...</span>
<span class="quote">&gt; extern bool adi_capable(void);</span>
<span class="quote">&gt; #else</span>
<span class="quote">&gt; ...</span>
<span class="quote">&gt; static inline bool adi_capable(void) {</span>
<span class="quote">&gt;      return false;</span>
<span class="quote">&gt; }</span>
<span class="quote">&gt; #endif</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; That way you get type checking on the arguments even if the option is</span>
<span class="quote">&gt; disabled and modern compilers are smart enough to optimise all the</span>
<span class="quote">&gt; no-op code away. (Not that the type checking is needed here.)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Also, in all but one place you use the ADI_CAPABLE() macro when the</span>
<span class="quote">&gt; adi_capable() function is defined and available.</span>

I defined ADI_CAPABLE() 0 for the case when CONFIG_SPARC_ADI is not set 
to help compiler optimize sun4v_mem_corrupt_detect_precise(). Since 
sun4v_mem_corrupt_detect_precise() is exception handler, optimizing it 
can be good for performance but perhaps compiler is smart enough to do 
that any way if adi_capable() is defined inline as you show above? I do 
like that doing it this way retains type checking.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +#else</span>
<span class="quote">&gt;&gt; +#define ADI_CAPABLE()          0</span>
<span class="quote">&gt;&gt; +#endif</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;   /* On Uniprocessor, even in RMO processes see TSO semantics */</span>
<span class="quote">&gt;&gt;   #ifdef CONFIG_SMP</span>
<span class="quote">&gt;&gt;   #define TSTATE_INITIAL_MM      TSTATE_TSO</span>
<span class="quote">&gt;&gt; diff --git a/arch/sparc/kernel/mdesc.c b/arch/sparc/kernel/mdesc.c</span>
<span class="quote">&gt;&gt; index 6f80936..79f981c 100644</span>
<span class="quote">&gt;&gt; --- a/arch/sparc/kernel/mdesc.c</span>
<span class="quote">&gt;&gt; +++ b/arch/sparc/kernel/mdesc.c</span>
<span class="quote">&gt;&gt; @@ -1007,6 +1013,80 @@ static int mdesc_open(struct inode *inode, struct file *file)</span>
<span class="quote">&gt;&gt;          return 0;</span>
<span class="quote">&gt;&gt;   }</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +bool adi_capable(void)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +       return adi_state.enabled;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +struct adi_caps *get_adi_caps(void)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +       return &amp;adi_state.caps;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +void __init</span>
<span class="quote">&gt;&gt; +init_adi(void)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +       struct mdesc_handle *hp = mdesc_grab();</span>
<span class="quote">&gt;&gt; +       const char *prop;</span>
<span class="quote">&gt;&gt; +       u64 pn, *val;</span>
<span class="quote">&gt;&gt; +       int len;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       adi_state.enabled = false;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       if (!hp)</span>
<span class="quote">&gt;&gt; +               return;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       pn = mdesc_node_by_name(hp, MDESC_NODE_NULL, &quot;cpu&quot;);</span>
<span class="quote">&gt;&gt; +       if (pn == MDESC_NODE_NULL)</span>
<span class="quote">&gt;&gt; +               goto out;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       prop = mdesc_get_property(hp, pn, &quot;hwcap-list&quot;, &amp;len);</span>
<span class="quote">&gt;&gt; +       if (!prop)</span>
<span class="quote">&gt;&gt; +               goto out;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       /*</span>
<span class="quote">&gt;&gt; +        * Look for &quot;adp&quot; keyword in hwcap-list which would indicate</span>
<span class="quote">&gt;&gt; +        * ADI support</span>
<span class="quote">&gt;&gt; +        */</span>
<span class="quote">&gt;&gt; +       while (len) {</span>
<span class="quote">&gt;&gt; +               int plen;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +               if (!strcmp(prop, &quot;adp&quot;)) {</span>
<span class="quote">&gt;&gt; +                       adi_state.enabled = true;</span>
<span class="quote">&gt;&gt; +                       break;</span>
<span class="quote">&gt;&gt; +               }</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +               plen = strlen(prop) + 1;</span>
<span class="quote">&gt;&gt; +               prop += plen;</span>
<span class="quote">&gt;&gt; +               len -= plen;</span>
<span class="quote">&gt;&gt; +       }</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       if (!adi_state.enabled)</span>
<span class="quote">&gt;&gt; +               goto out;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       pn = mdesc_node_by_name(hp, MDESC_NODE_NULL, &quot;platform&quot;);</span>
<span class="quote">&gt;&gt; +       if (pn == MDESC_NODE_NULL)</span>
<span class="quote">&gt;&gt; +               goto out;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       val = (u64 *) mdesc_get_property(hp, pn, &quot;adp-blksz&quot;, &amp;len);</span>
<span class="quote">&gt;&gt; +       if (!val)</span>
<span class="quote">&gt;&gt; +               goto out;</span>
<span class="quote">&gt;&gt; +       adi_state.caps.blksz = *val;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       val = (u64 *) mdesc_get_property(hp, pn, &quot;adp-nbits&quot;, &amp;len);</span>
<span class="quote">&gt;&gt; +       if (!val)</span>
<span class="quote">&gt;&gt; +               goto out;</span>
<span class="quote">&gt;&gt; +       adi_state.caps.nbits = *val;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       val = (u64 *) mdesc_get_property(hp, pn, &quot;ue-on-adp&quot;, &amp;len);</span>
<span class="quote">&gt;&gt; +       if (!val)</span>
<span class="quote">&gt;&gt; +               goto out;</span>
<span class="quote">&gt;&gt; +       adi_state.caps.ue_on_adi = *val;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +out:</span>
<span class="quote">&gt;&gt; +       mdesc_release(hp);</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Should all the ADI related functions above be within a #ifdef CONFIG_SPARC_ADI?</span>
<span class="quote">&gt;</span>

CONFIG_SPARC_ADI is selected for 64-bit kernels only since M7 is 64-bit 
only. init_adi() will do the right thing whether CONFIG_SPARC_ADI is 
enabled or not. It will parse machine description on 32-bit kernels, 
detect ADI is not supported by the platform and leave 
adi_state.enabled=false. I was considering adding something like 
/proc/sys/vm/sparc_adi_available at later point which would get its data 
from what init_adi() detects. On the other hand, since 32-bit processors 
do not support ADI, why have even this much code run on them. I can 
enclose this code as well inside #ifdef.
<span class="quote">
&gt;&gt;   static ssize_t mdesc_read(struct file *file, char __user *buf,</span>
<span class="quote">&gt;&gt;                            size_t len, loff_t *offp)</span>
<span class="quote">&gt;&gt;   {</span>
<span class="quote">&gt;&gt; diff --git a/arch/sparc/kernel/traps_64.c b/arch/sparc/kernel/traps_64.c</span>
<span class="quote">&gt;&gt; index d21cd62..29db583 100644</span>
<span class="quote">&gt;&gt; --- a/arch/sparc/kernel/traps_64.c</span>
<span class="quote">&gt;&gt; +++ b/arch/sparc/kernel/traps_64.c</span>
<span class="quote">&gt;&gt; @@ -2531,6 +2589,38 @@ void sun4v_do_mna(struct pt_regs *regs, unsigned long addr, unsigned long type_c</span>
<span class="quote">&gt;&gt;          force_sig_info(SIGBUS, &amp;info, current);</span>
<span class="quote">&gt;&gt;   }</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +void sun4v_mem_corrupt_detect_precise(struct pt_regs *regs, unsigned long addr,</span>
<span class="quote">&gt;&gt; +                                     unsigned long context)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +       siginfo_t info;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       if (!ADI_CAPABLE()) {</span>
<span class="quote">&gt;&gt; +               bad_trap(regs, 0x1a);</span>
<span class="quote">&gt;&gt; +               return;</span>
<span class="quote">&gt;&gt; +       }</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       if (notify_die(DIE_TRAP, &quot;memory corruption precise exception&quot;, regs,</span>
<span class="quote">&gt;&gt; +                      0, 0x8, SIGSEGV) == NOTIFY_STOP)</span>
<span class="quote">&gt;&gt; +               return;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       if (regs-&gt;tstate &amp; TSTATE_PRIV) {</span>
<span class="quote">&gt;&gt; +               pr_emerg(&quot;sun4v_mem_corrupt_detect_precise: ADDR[%016lx] &quot;</span>
<span class="quote">&gt;&gt; +                       &quot;CTX[%lx], going.\n&quot;, addr, context);</span>
<span class="quote">&gt;&gt; +               die_if_kernel(&quot;MCD precise&quot;, regs);</span>
<span class="quote">&gt;&gt; +       }</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       if (test_thread_flag(TIF_32BIT)) {</span>
<span class="quote">&gt;&gt; +               regs-&gt;tpc &amp;= 0xffffffff;</span>
<span class="quote">&gt;&gt; +               regs-&gt;tnpc &amp;= 0xffffffff;</span>
<span class="quote">&gt;&gt; +       }</span>
<span class="quote">&gt;&gt; +       info.si_signo = SIGSEGV;</span>
<span class="quote">&gt;&gt; +       info.si_code = SEGV_ADIPERR;</span>
<span class="quote">&gt;&gt; +       info.si_errno = 0;</span>
<span class="quote">&gt;&gt; +       info.si_addr = (void __user *) addr;</span>
<span class="quote">&gt;&gt; +       info.si_trapno = 0;</span>
<span class="quote">&gt;&gt; +       force_sig_info(SIGSEGV, &amp;info, current);</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Should this be ifdef&#39;d too?</span>

I would prefer to leave exception handlers in place any way unless there 
are strong objections.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt;   void do_privop(struct pt_regs *regs)</span>
<span class="quote">&gt;&gt;   {</span>
<span class="quote">&gt;&gt;          enum ctx_state prev_state = exception_enter();</span>
<span class="quote">&gt;&gt; diff --git a/kernel/sys.c b/kernel/sys.c</span>
<span class="quote">&gt;&gt; index 6af9212..fa7b5d9 100644</span>
<span class="quote">&gt;&gt; --- a/kernel/sys.c</span>
<span class="quote">&gt;&gt; +++ b/kernel/sys.c</span>
<span class="quote">&gt;&gt; @@ -103,6 +103,21 @@</span>
<span class="quote">&gt;&gt;   #ifndef SET_FP_MODE</span>
<span class="quote">&gt;&gt;   # define SET_FP_MODE(a,b)      (-EINVAL)</span>
<span class="quote">&gt;&gt;   #endif</span>
<span class="quote">&gt;&gt; +#ifndef GET_SPARC_ADICAPS</span>
<span class="quote">&gt;&gt; +# define GET_SPARC_ADICAPS(a)          (-EINVAL)</span>
<span class="quote">&gt;&gt; +#endif</span>
<span class="quote">&gt;&gt; +#ifndef SET_SPARC_MCDE</span>
<span class="quote">&gt;&gt; +# define SET_SPARC_MCDE(a)             (-EINVAL)</span>
<span class="quote">&gt;&gt; +#endif</span>
<span class="quote">&gt;&gt; +#ifndef ENABLE_SPARC_ADI</span>
<span class="quote">&gt;&gt; +# define ENABLE_SPARC_ADI(a, b)                (-EINVAL)</span>
<span class="quote">&gt;&gt; +#endif</span>
<span class="quote">&gt;&gt; +#ifndef DISABLE_SPARC_ADI</span>
<span class="quote">&gt;&gt; +# define DISABLE_SPARC_ADI(a, b)       (-EINVAL)</span>
<span class="quote">&gt;&gt; +#endif</span>
<span class="quote">&gt;&gt; +#ifndef GET_SPARC_ADI_STATUS</span>
<span class="quote">&gt;&gt; +# define GET_SPARC_ADI_STATUS(a)       (-EINVAL)</span>
<span class="quote">&gt;&gt; +#endif</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Ah, I was wondering why you were defining macros in processor_64.h.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;   /*</span>
<span class="quote">&gt;&gt;    * this is where the system-wide overflow UID and GID are defined, for</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I&#39;ve got a couple more comments, I&#39;ll send another email with them shortly.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Thanks,</span>
<span class="quote">&gt;</span>

Thanks,
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=545">Julian Calaby</a> - March 3, 2016, 12:48 a.m.</div>
<pre class="content">
Hi Khalid,

On Thu, Mar 3, 2016 at 11:25 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt; wrote:
<span class="quote">&gt; Thanks, Julian! I really appreciate your feedback.</span>

No problem!
<span class="quote">
&gt; My comments below.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; On 03/02/2016 04:08 PM, Julian Calaby wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Hi Khalid,</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On Thu, Mar 3, 2016 at 7:39 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt; wrote:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Enable Application Data Integrity (ADI) support in the sparc</span>
<span class="quote">&gt;&gt;&gt; kernel for applications to use ADI in userspace. ADI is a new</span>
<span class="quote">&gt;&gt;&gt; feature supported on sparc M7 and newer processors. ADI is supported</span>
<span class="quote">&gt;&gt;&gt; for data fetches only and not instruction fetches. This patch adds</span>
<span class="quote">&gt;&gt;&gt; prctl commands to enable and disable ADI (TSTATE.mcde), return ADI</span>
<span class="quote">&gt;&gt;&gt; parameters to userspace, enable/disable MCD (Memory Corruption</span>
<span class="quote">&gt;&gt;&gt; Detection) on selected memory ranges and enable TTE.mcd in PTEs. It</span>
<span class="quote">&gt;&gt;&gt; also adds handlers for all traps related to MCD. ADI is not enabled</span>
<span class="quote">&gt;&gt;&gt; by default for any task and a task must explicitly enable ADI</span>
<span class="quote">&gt;&gt;&gt; (TSTATE.mcde), turn MCD on on a memory range and set version tag</span>
<span class="quote">&gt;&gt;&gt; for ADI to be effective for the task. This patch adds support for</span>
<span class="quote">&gt;&gt;&gt; ADI for hugepages only. Addresses passed into system calls must be</span>
<span class="quote">&gt;&gt;&gt; non-ADI tagged addresses.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I can&#39;t comment on the actual functionality here, but I do see a few</span>
<span class="quote">&gt;&gt; minor style issues in your patch.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; My big concern is that you&#39;re defining a lot of new code that is ADI</span>
<span class="quote">&gt;&gt; specific but isn&#39;t inside a CONFIG_SPARC_ADI ifdef. (That said,</span>
<span class="quote">&gt;&gt; handling ADI specific traps if ADI isn&#39;t enabled looks like a good</span>
<span class="quote">&gt;&gt; idea to me, however most of the other stuff is just dead code if</span>
<span class="quote">&gt;&gt; CONFIG_SPARC_ADI isn&#39;t enabled.)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Some of the code will be executed when CONFIG_SPARC_ADI is not enabled, for</span>
<span class="quote">&gt; instance init_adi() which will parse machine description to determine if</span>
<span class="quote">&gt; platform supports ADI. On the other hand, it might still make sense to</span>
<span class="quote">&gt; enclose this code in #ifdef. More on that below.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Signed-off-by: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt;&gt; ---</span>
<span class="quote">&gt;&gt;&gt; NOTES: ADI is a new feature added to M7 processor to allow hardware</span>
<span class="quote">&gt;&gt;&gt;          to catch rogue accesses to memory. An app can enable ADI on</span>
<span class="quote">&gt;&gt;&gt;          its data pages, set version tags on them and use versioned</span>
<span class="quote">&gt;&gt;&gt;          addresses (bits 63-60 of the address contain a version tag)</span>
<span class="quote">&gt;&gt;&gt;          to access the data pages. If a rogue app attempts to access</span>
<span class="quote">&gt;&gt;&gt;          ADI enabled data pages, its access is blocked and processor</span>
<span class="quote">&gt;&gt;&gt;          generates an exception. Enabling this functionality for all</span>
<span class="quote">&gt;&gt;&gt;          data pages of an app requires adding infrastructure to save</span>
<span class="quote">&gt;&gt;&gt;          version tags for any data pages that get swapped out and</span>
<span class="quote">&gt;&gt;&gt;          restoring those tags when pages are swapped back in. In this</span>
<span class="quote">&gt;&gt;&gt;          first implementation I am enabling ADI for hugepages only</span>
<span class="quote">&gt;&gt;&gt;          since these pages are locked in memory and hence avoid the</span>
<span class="quote">&gt;&gt;&gt;          issue of saving and restoring tags. Once this core functionality</span>
<span class="quote">&gt;&gt;&gt;          is stable, ADI for other memory pages can be enabled more</span>
<span class="quote">&gt;&gt;&gt;          easily.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; v2:</span>
<span class="quote">&gt;&gt;&gt;          - Fixed a build error</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;   Documentation/prctl/sparc_adi.txt     |  62 ++++++++++</span>
<span class="quote">&gt;&gt;&gt;   Documentation/sparc/adi.txt           | 206</span>
<span class="quote">&gt;&gt;&gt; +++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/Kconfig                    |  12 ++</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/include/asm/hugetlb.h      |  14 +++</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/include/asm/hypervisor.h   |   2 +</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/include/asm/mmu_64.h       |   1 +</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/include/asm/pgtable_64.h   |  15 +++</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/include/asm/processor_64.h |  19 +++</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/include/asm/ttable.h       |  10 ++</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/include/uapi/asm/asi.h     |   3 +</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/include/uapi/asm/pstate.h  |  10 ++</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/kernel/entry.h             |   3 +</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/kernel/head_64.S           |   1 +</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/kernel/mdesc.c             |  81 +++++++++++++</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/kernel/process_64.c        | 222</span>
<span class="quote">&gt;&gt;&gt; ++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/kernel/sun4v_mcd.S         |  16 +++</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/kernel/traps_64.c          |  96 ++++++++++++++-</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/kernel/ttable_64.S         |   6 +-</span>
<span class="quote">&gt;&gt;&gt;   include/linux/mm.h                    |   2 +</span>
<span class="quote">&gt;&gt;&gt;   include/uapi/asm-generic/siginfo.h    |   5 +-</span>
<span class="quote">&gt;&gt;&gt;   include/uapi/linux/prctl.h            |  16 +++</span>
<span class="quote">&gt;&gt;&gt;   kernel/sys.c                          |  30 +++++</span>
<span class="quote">&gt;&gt;&gt;   22 files changed, 826 insertions(+), 6 deletions(-)</span>
<span class="quote">&gt;&gt;&gt;   create mode 100644 Documentation/prctl/sparc_adi.txt</span>
<span class="quote">&gt;&gt;&gt;   create mode 100644 Documentation/sparc/adi.txt</span>
<span class="quote">&gt;&gt;&gt;   create mode 100644 arch/sparc/kernel/sun4v_mcd.S</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I must admit that I&#39;m slightly impressed that the documentation is</span>
<span class="quote">&gt;&gt; over a quarter of the lines added. =)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; diff --git a/arch/sparc/Kconfig b/arch/sparc/Kconfig</span>
<span class="quote">&gt;&gt;&gt; index 56442d2..0aac0ae 100644</span>
<span class="quote">&gt;&gt;&gt; --- a/arch/sparc/Kconfig</span>
<span class="quote">&gt;&gt;&gt; +++ b/arch/sparc/Kconfig</span>
<span class="quote">&gt;&gt;&gt; @@ -80,6 +80,7 @@ config SPARC64</span>
<span class="quote">&gt;&gt;&gt;          select NO_BOOTMEM</span>
<span class="quote">&gt;&gt;&gt;          select HAVE_ARCH_AUDITSYSCALL</span>
<span class="quote">&gt;&gt;&gt;          select ARCH_SUPPORTS_ATOMIC_RMW</span>
<span class="quote">&gt;&gt;&gt; +       select SPARC_ADI</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This doesn&#39;t look right.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;   config ARCH_DEFCONFIG</span>
<span class="quote">&gt;&gt;&gt;          string</span>
<span class="quote">&gt;&gt;&gt; @@ -314,6 +315,17 @@ if SPARC64</span>
<span class="quote">&gt;&gt;&gt;   source &quot;kernel/power/Kconfig&quot;</span>
<span class="quote">&gt;&gt;&gt;   endif</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; +config SPARC_ADI</span>
<span class="quote">&gt;&gt;&gt; +       bool &quot;Application Data Integrity support&quot;</span>
<span class="quote">&gt;&gt;&gt; +       def_bool y if SPARC64</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; def_bool is for config options without names (i.e. &quot;this is a boolean</span>
<span class="quote">&gt;&gt; value and it&#39;s default is...&quot;)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; So if you want people to be able to disable this option, then you</span>
<span class="quote">&gt;&gt; should remove the select above and just have:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; bool &quot;Application Data Integrity support&quot;</span>
<span class="quote">&gt;&gt; default y if SPARC64</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; If you don&#39;t want people disabling it, then there&#39;s no point in having</span>
<span class="quote">&gt;&gt; a separate Kconfig symbol.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Ah, I see. I do not want people disabling it. I will make changes.</span>

Why don&#39;t you want people disabling it? I must acknowledge that it&#39;s
not a lot of code, but I can see people wanting to build &quot;minimal&quot;
kernels for processors without ADI or to run some specific thing that
doesn&#39;t use ADI. Providing the kernel responds appropriately if
there&#39;s an unexpected ADI fault I don&#39;t see why the code would be
needed if it&#39;ll never be used.
<span class="quote">
&gt;&gt;&gt; +       help</span>
<span class="quote">&gt;&gt;&gt; +         Support for Application Data Integrity (ADI). ADI feature</span>
<span class="quote">&gt;&gt;&gt; allows</span>
<span class="quote">&gt;&gt;&gt; +         a process to tag memory blocks with version tags. Once ADI is</span>
<span class="quote">&gt;&gt;&gt; +         enabled and version tag is set on a memory block, any access to</span>
<span class="quote">&gt;&gt;&gt; +         it is allowed only if the correct version tag is presented by</span>
<span class="quote">&gt;&gt;&gt; +         a process. This feature is meant to help catch rogue accesses</span>
<span class="quote">&gt;&gt;&gt; +         to memory.</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; You should probably mention that it&#39;s only available on newer</span>
<span class="quote">&gt;&gt; processors and recommend that it&#39;s enabled on them.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Good point.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This code won&#39;t break anything on older processors, right? I haven&#39;t</span>
<span class="quote">&gt;&gt; looked very closely, but I don&#39;t see anything that specifically</span>
<span class="quote">&gt;&gt; disables the code if it&#39;s run on, say, a UltraSparc I.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Right, this code does not break anything on older processors and has been</span>
<span class="quote">&gt; tested on older machines. init_adi() will detect the platform does not</span>
<span class="quote">&gt; support ADI when it parses machine description and will leave ADI disabled</span>
<span class="quote">&gt; in that case (adi_state.enabled=false).</span>

Awesome, I just wanted to check =)
<span class="quote">
&gt;&gt;&gt;   config SCHED_SMT</span>
<span class="quote">&gt;&gt;&gt;          bool &quot;SMT (Hyperthreading) scheduler support&quot;</span>
<span class="quote">&gt;&gt;&gt;          depends on SPARC64 &amp;&amp; SMP</span>
<span class="quote">&gt;&gt;&gt; diff --git a/arch/sparc/include/asm/processor_64.h</span>
<span class="quote">&gt;&gt;&gt; b/arch/sparc/include/asm/processor_64.h</span>
<span class="quote">&gt;&gt;&gt; index 6924bde..9a71701 100644</span>
<span class="quote">&gt;&gt;&gt; --- a/arch/sparc/include/asm/processor_64.h</span>
<span class="quote">&gt;&gt;&gt; +++ b/arch/sparc/include/asm/processor_64.h</span>
<span class="quote">&gt;&gt;&gt; @@ -97,6 +97,25 @@ struct thread_struct {</span>
<span class="quote">&gt;&gt;&gt;   struct task_struct;</span>
<span class="quote">&gt;&gt;&gt;   unsigned long thread_saved_pc(struct task_struct *);</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; +#ifdef CONFIG_SPARC_ADI</span>
<span class="quote">&gt;&gt;&gt; +extern struct adi_caps *get_adi_caps(void);</span>
<span class="quote">&gt;&gt;&gt; +extern long get_sparc_adicaps(unsigned long);</span>
<span class="quote">&gt;&gt;&gt; +extern long set_sparc_pstate_mcde(unsigned long);</span>
<span class="quote">&gt;&gt;&gt; +extern long enable_sparc_adi(unsigned long, unsigned long);</span>
<span class="quote">&gt;&gt;&gt; +extern long disable_sparc_adi(unsigned long, unsigned long);</span>
<span class="quote">&gt;&gt;&gt; +extern long get_sparc_adi_status(unsigned long);</span>
<span class="quote">&gt;&gt;&gt; +extern bool adi_capable(void);</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +#define GET_SPARC_ADICAPS(a)   get_sparc_adicaps(a)</span>
<span class="quote">&gt;&gt;&gt; +#define SET_SPARC_MCDE(a)      set_sparc_pstate_mcde(a)</span>
<span class="quote">&gt;&gt;&gt; +#define ENABLE_SPARC_ADI(a, b) enable_sparc_adi(a, b)</span>
<span class="quote">&gt;&gt;&gt; +#define DISABLE_SPARC_ADI(a, b)        disable_sparc_adi(a, b)</span>
<span class="quote">&gt;&gt;&gt; +#define GET_SPARC_ADI_STATUS(a)        get_sparc_adi_status(a)</span>
<span class="quote">&gt;&gt;&gt; +#define ADI_CAPABLE()          adi_capable()</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Get rid of the ADI_CAPABLE macro, the usual pattern here is to define</span>
<span class="quote">&gt;&gt; a static inline function for the entire API when the symbol is</span>
<span class="quote">&gt;&gt; disabled, i.e.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; #ifdef CONFIG_SPARC_ADI</span>
<span class="quote">&gt;&gt; ...</span>
<span class="quote">&gt;&gt; extern bool adi_capable(void);</span>
<span class="quote">&gt;&gt; #else</span>
<span class="quote">&gt;&gt; ...</span>
<span class="quote">&gt;&gt; static inline bool adi_capable(void) {</span>
<span class="quote">&gt;&gt;      return false;</span>
<span class="quote">&gt;&gt; }</span>
<span class="quote">&gt;&gt; #endif</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; That way you get type checking on the arguments even if the option is</span>
<span class="quote">&gt;&gt; disabled and modern compilers are smart enough to optimise all the</span>
<span class="quote">&gt;&gt; no-op code away. (Not that the type checking is needed here.)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Also, in all but one place you use the ADI_CAPABLE() macro when the</span>
<span class="quote">&gt;&gt; adi_capable() function is defined and available.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I defined ADI_CAPABLE() 0 for the case when CONFIG_SPARC_ADI is not set to</span>
<span class="quote">&gt; help compiler optimize sun4v_mem_corrupt_detect_precise(). Since</span>
<span class="quote">&gt; sun4v_mem_corrupt_detect_precise() is exception handler, optimizing it can</span>
<span class="quote">&gt; be good for performance but perhaps compiler is smart enough to do that any</span>
<span class="quote">&gt; way if adi_capable() is defined inline as you show above? I do like that</span>
<span class="quote">&gt; doing it this way retains type checking.</span>

Inlines can usually be treated as if they&#39;re macros from an optimising
perspective.
<span class="quote">
&gt;&gt;&gt; +#else</span>
<span class="quote">&gt;&gt;&gt; +#define ADI_CAPABLE()          0</span>
<span class="quote">&gt;&gt;&gt; +#endif</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;   /* On Uniprocessor, even in RMO processes see TSO semantics */</span>
<span class="quote">&gt;&gt;&gt;   #ifdef CONFIG_SMP</span>
<span class="quote">&gt;&gt;&gt;   #define TSTATE_INITIAL_MM      TSTATE_TSO</span>
<span class="quote">&gt;&gt;&gt; diff --git a/arch/sparc/kernel/mdesc.c b/arch/sparc/kernel/mdesc.c</span>
<span class="quote">&gt;&gt;&gt; index 6f80936..79f981c 100644</span>
<span class="quote">&gt;&gt;&gt; --- a/arch/sparc/kernel/mdesc.c</span>
<span class="quote">&gt;&gt;&gt; +++ b/arch/sparc/kernel/mdesc.c</span>
<span class="quote">&gt;&gt;&gt; @@ -1007,6 +1013,80 @@ static int mdesc_open(struct inode *inode, struct</span>
<span class="quote">&gt;&gt;&gt; file *file)</span>
<span class="quote">&gt;&gt;&gt;          return 0;</span>
<span class="quote">&gt;&gt;&gt;   }</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; +bool adi_capable(void)</span>
<span class="quote">&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt; +       return adi_state.enabled;</span>
<span class="quote">&gt;&gt;&gt; +}</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +struct adi_caps *get_adi_caps(void)</span>
<span class="quote">&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt; +       return &amp;adi_state.caps;</span>
<span class="quote">&gt;&gt;&gt; +}</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +void __init</span>
<span class="quote">&gt;&gt;&gt; +init_adi(void)</span>
<span class="quote">&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt; +       struct mdesc_handle *hp = mdesc_grab();</span>
<span class="quote">&gt;&gt;&gt; +       const char *prop;</span>
<span class="quote">&gt;&gt;&gt; +       u64 pn, *val;</span>
<span class="quote">&gt;&gt;&gt; +       int len;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +       adi_state.enabled = false;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +       if (!hp)</span>
<span class="quote">&gt;&gt;&gt; +               return;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +       pn = mdesc_node_by_name(hp, MDESC_NODE_NULL, &quot;cpu&quot;);</span>
<span class="quote">&gt;&gt;&gt; +       if (pn == MDESC_NODE_NULL)</span>
<span class="quote">&gt;&gt;&gt; +               goto out;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +       prop = mdesc_get_property(hp, pn, &quot;hwcap-list&quot;, &amp;len);</span>
<span class="quote">&gt;&gt;&gt; +       if (!prop)</span>
<span class="quote">&gt;&gt;&gt; +               goto out;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +       /*</span>
<span class="quote">&gt;&gt;&gt; +        * Look for &quot;adp&quot; keyword in hwcap-list which would indicate</span>
<span class="quote">&gt;&gt;&gt; +        * ADI support</span>
<span class="quote">&gt;&gt;&gt; +        */</span>
<span class="quote">&gt;&gt;&gt; +       while (len) {</span>
<span class="quote">&gt;&gt;&gt; +               int plen;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +               if (!strcmp(prop, &quot;adp&quot;)) {</span>
<span class="quote">&gt;&gt;&gt; +                       adi_state.enabled = true;</span>
<span class="quote">&gt;&gt;&gt; +                       break;</span>
<span class="quote">&gt;&gt;&gt; +               }</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +               plen = strlen(prop) + 1;</span>
<span class="quote">&gt;&gt;&gt; +               prop += plen;</span>
<span class="quote">&gt;&gt;&gt; +               len -= plen;</span>
<span class="quote">&gt;&gt;&gt; +       }</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +       if (!adi_state.enabled)</span>
<span class="quote">&gt;&gt;&gt; +               goto out;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +       pn = mdesc_node_by_name(hp, MDESC_NODE_NULL, &quot;platform&quot;);</span>
<span class="quote">&gt;&gt;&gt; +       if (pn == MDESC_NODE_NULL)</span>
<span class="quote">&gt;&gt;&gt; +               goto out;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +       val = (u64 *) mdesc_get_property(hp, pn, &quot;adp-blksz&quot;, &amp;len);</span>
<span class="quote">&gt;&gt;&gt; +       if (!val)</span>
<span class="quote">&gt;&gt;&gt; +               goto out;</span>
<span class="quote">&gt;&gt;&gt; +       adi_state.caps.blksz = *val;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +       val = (u64 *) mdesc_get_property(hp, pn, &quot;adp-nbits&quot;, &amp;len);</span>
<span class="quote">&gt;&gt;&gt; +       if (!val)</span>
<span class="quote">&gt;&gt;&gt; +               goto out;</span>
<span class="quote">&gt;&gt;&gt; +       adi_state.caps.nbits = *val;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +       val = (u64 *) mdesc_get_property(hp, pn, &quot;ue-on-adp&quot;, &amp;len);</span>
<span class="quote">&gt;&gt;&gt; +       if (!val)</span>
<span class="quote">&gt;&gt;&gt; +               goto out;</span>
<span class="quote">&gt;&gt;&gt; +       adi_state.caps.ue_on_adi = *val;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +out:</span>
<span class="quote">&gt;&gt;&gt; +       mdesc_release(hp);</span>
<span class="quote">&gt;&gt;&gt; +}</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Should all the ADI related functions above be within a #ifdef</span>
<span class="quote">&gt;&gt; CONFIG_SPARC_ADI?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; CONFIG_SPARC_ADI is selected for 64-bit kernels only since M7 is 64-bit</span>
<span class="quote">&gt; only. init_adi() will do the right thing whether CONFIG_SPARC_ADI is enabled</span>
<span class="quote">&gt; or not. It will parse machine description on 32-bit kernels, detect ADI is</span>
<span class="quote">&gt; not supported by the platform and leave adi_state.enabled=false. I was</span>
<span class="quote">&gt; considering adding something like /proc/sys/vm/sparc_adi_available at later</span>
<span class="quote">&gt; point which would get its data from what init_adi() detects. On the other</span>
<span class="quote">&gt; hand, since 32-bit processors do not support ADI, why have even this much</span>
<span class="quote">&gt; code run on them. I can enclose this code as well inside #ifdef.</span>

Precisely.
<span class="quote">
&gt;&gt;&gt;   static ssize_t mdesc_read(struct file *file, char __user *buf,</span>
<span class="quote">&gt;&gt;&gt;                            size_t len, loff_t *offp)</span>
<span class="quote">&gt;&gt;&gt;   {</span>
<span class="quote">&gt;&gt;&gt; diff --git a/arch/sparc/kernel/traps_64.c b/arch/sparc/kernel/traps_64.c</span>
<span class="quote">&gt;&gt;&gt; index d21cd62..29db583 100644</span>
<span class="quote">&gt;&gt;&gt; --- a/arch/sparc/kernel/traps_64.c</span>
<span class="quote">&gt;&gt;&gt; +++ b/arch/sparc/kernel/traps_64.c</span>
<span class="quote">&gt;&gt;&gt; @@ -2531,6 +2589,38 @@ void sun4v_do_mna(struct pt_regs *regs, unsigned</span>
<span class="quote">&gt;&gt;&gt; long addr, unsigned long type_c</span>
<span class="quote">&gt;&gt;&gt;          force_sig_info(SIGBUS, &amp;info, current);</span>
<span class="quote">&gt;&gt;&gt;   }</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; +void sun4v_mem_corrupt_detect_precise(struct pt_regs *regs, unsigned</span>
<span class="quote">&gt;&gt;&gt; long addr,</span>
<span class="quote">&gt;&gt;&gt; +                                     unsigned long context)</span>
<span class="quote">&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt; +       siginfo_t info;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +       if (!ADI_CAPABLE()) {</span>
<span class="quote">&gt;&gt;&gt; +               bad_trap(regs, 0x1a);</span>
<span class="quote">&gt;&gt;&gt; +               return;</span>
<span class="quote">&gt;&gt;&gt; +       }</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +       if (notify_die(DIE_TRAP, &quot;memory corruption precise exception&quot;,</span>
<span class="quote">&gt;&gt;&gt; regs,</span>
<span class="quote">&gt;&gt;&gt; +                      0, 0x8, SIGSEGV) == NOTIFY_STOP)</span>
<span class="quote">&gt;&gt;&gt; +               return;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +       if (regs-&gt;tstate &amp; TSTATE_PRIV) {</span>
<span class="quote">&gt;&gt;&gt; +               pr_emerg(&quot;sun4v_mem_corrupt_detect_precise: ADDR[%016lx]</span>
<span class="quote">&gt;&gt;&gt; &quot;</span>
<span class="quote">&gt;&gt;&gt; +                       &quot;CTX[%lx], going.\n&quot;, addr, context);</span>
<span class="quote">&gt;&gt;&gt; +               die_if_kernel(&quot;MCD precise&quot;, regs);</span>
<span class="quote">&gt;&gt;&gt; +       }</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +       if (test_thread_flag(TIF_32BIT)) {</span>
<span class="quote">&gt;&gt;&gt; +               regs-&gt;tpc &amp;= 0xffffffff;</span>
<span class="quote">&gt;&gt;&gt; +               regs-&gt;tnpc &amp;= 0xffffffff;</span>
<span class="quote">&gt;&gt;&gt; +       }</span>
<span class="quote">&gt;&gt;&gt; +       info.si_signo = SIGSEGV;</span>
<span class="quote">&gt;&gt;&gt; +       info.si_code = SEGV_ADIPERR;</span>
<span class="quote">&gt;&gt;&gt; +       info.si_errno = 0;</span>
<span class="quote">&gt;&gt;&gt; +       info.si_addr = (void __user *) addr;</span>
<span class="quote">&gt;&gt;&gt; +       info.si_trapno = 0;</span>
<span class="quote">&gt;&gt;&gt; +       force_sig_info(SIGSEGV, &amp;info, current);</span>
<span class="quote">&gt;&gt;&gt; +}</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Should this be ifdef&#39;d too?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I would prefer to leave exception handlers in place any way unless there are</span>
<span class="quote">&gt; strong objections.</span>

Thinking over it again, you&#39;re right. It&#39;s possible, however unlikely,
that this trap could occur without ADI being enabled anywhere, so we
should handle it unconditionally.
<span class="quote">
&gt;&gt;&gt;   void do_privop(struct pt_regs *regs)</span>
<span class="quote">&gt;&gt;&gt;   {</span>
<span class="quote">&gt;&gt;&gt;          enum ctx_state prev_state = exception_enter();</span>

Thanks,
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 3, 2016, 5:28 p.m.</div>
<pre class="content">
On 03/02/2016 05:48 PM, Julian Calaby wrote:
<span class="quote">&gt; Hi Khalid,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; On Thu, Mar 3, 2016 at 11:25 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt; wrote:</span>
<span class="quote">&gt;&gt; Thanks, Julian! I really appreciate your feedback.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; No problem!</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; My comments below.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On 03/02/2016 04:08 PM, Julian Calaby wrote:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Hi Khalid,</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; On Thu, Mar 3, 2016 at 7:39 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt;&gt; wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Enable Application Data Integrity (ADI) support in the sparc</span>
<span class="quote">&gt;&gt;&gt;&gt; kernel for applications to use ADI in userspace. ADI is a new</span>
<span class="quote">&gt;&gt;&gt;&gt; feature supported on sparc M7 and newer processors. ADI is supported</span>
<span class="quote">&gt;&gt;&gt;&gt; for data fetches only and not instruction fetches. This patch adds</span>
<span class="quote">&gt;&gt;&gt;&gt; prctl commands to enable and disable ADI (TSTATE.mcde), return ADI</span>
<span class="quote">&gt;&gt;&gt;&gt; parameters to userspace, enable/disable MCD (Memory Corruption</span>
<span class="quote">&gt;&gt;&gt;&gt; Detection) on selected memory ranges and enable TTE.mcd in PTEs. It</span>
<span class="quote">&gt;&gt;&gt;&gt; also adds handlers for all traps related to MCD. ADI is not enabled</span>
<span class="quote">&gt;&gt;&gt;&gt; by default for any task and a task must explicitly enable ADI</span>
<span class="quote">&gt;&gt;&gt;&gt; (TSTATE.mcde), turn MCD on on a memory range and set version tag</span>
<span class="quote">&gt;&gt;&gt;&gt; for ADI to be effective for the task. This patch adds support for</span>
<span class="quote">&gt;&gt;&gt;&gt; ADI for hugepages only. Addresses passed into system calls must be</span>
<span class="quote">&gt;&gt;&gt;&gt; non-ADI tagged addresses.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; I can&#39;t comment on the actual functionality here, but I do see a few</span>
<span class="quote">&gt;&gt;&gt; minor style issues in your patch.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; My big concern is that you&#39;re defining a lot of new code that is ADI</span>
<span class="quote">&gt;&gt;&gt; specific but isn&#39;t inside a CONFIG_SPARC_ADI ifdef. (That said,</span>
<span class="quote">&gt;&gt;&gt; handling ADI specific traps if ADI isn&#39;t enabled looks like a good</span>
<span class="quote">&gt;&gt;&gt; idea to me, however most of the other stuff is just dead code if</span>
<span class="quote">&gt;&gt;&gt; CONFIG_SPARC_ADI isn&#39;t enabled.)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Some of the code will be executed when CONFIG_SPARC_ADI is not enabled, for</span>
<span class="quote">&gt;&gt; instance init_adi() which will parse machine description to determine if</span>
<span class="quote">&gt;&gt; platform supports ADI. On the other hand, it might still make sense to</span>
<span class="quote">&gt;&gt; enclose this code in #ifdef. More on that below.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Signed-off-by: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; ---</span>
<span class="quote">&gt;&gt;&gt;&gt; NOTES: ADI is a new feature added to M7 processor to allow hardware</span>
<span class="quote">&gt;&gt;&gt;&gt;           to catch rogue accesses to memory. An app can enable ADI on</span>
<span class="quote">&gt;&gt;&gt;&gt;           its data pages, set version tags on them and use versioned</span>
<span class="quote">&gt;&gt;&gt;&gt;           addresses (bits 63-60 of the address contain a version tag)</span>
<span class="quote">&gt;&gt;&gt;&gt;           to access the data pages. If a rogue app attempts to access</span>
<span class="quote">&gt;&gt;&gt;&gt;           ADI enabled data pages, its access is blocked and processor</span>
<span class="quote">&gt;&gt;&gt;&gt;           generates an exception. Enabling this functionality for all</span>
<span class="quote">&gt;&gt;&gt;&gt;           data pages of an app requires adding infrastructure to save</span>
<span class="quote">&gt;&gt;&gt;&gt;           version tags for any data pages that get swapped out and</span>
<span class="quote">&gt;&gt;&gt;&gt;           restoring those tags when pages are swapped back in. In this</span>
<span class="quote">&gt;&gt;&gt;&gt;           first implementation I am enabling ADI for hugepages only</span>
<span class="quote">&gt;&gt;&gt;&gt;           since these pages are locked in memory and hence avoid the</span>
<span class="quote">&gt;&gt;&gt;&gt;           issue of saving and restoring tags. Once this core functionality</span>
<span class="quote">&gt;&gt;&gt;&gt;           is stable, ADI for other memory pages can be enabled more</span>
<span class="quote">&gt;&gt;&gt;&gt;           easily.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; v2:</span>
<span class="quote">&gt;&gt;&gt;&gt;           - Fixed a build error</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;    Documentation/prctl/sparc_adi.txt     |  62 ++++++++++</span>
<span class="quote">&gt;&gt;&gt;&gt;    Documentation/sparc/adi.txt           | 206</span>
<span class="quote">&gt;&gt;&gt;&gt; +++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/Kconfig                    |  12 ++</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/include/asm/hugetlb.h      |  14 +++</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/include/asm/hypervisor.h   |   2 +</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/include/asm/mmu_64.h       |   1 +</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/include/asm/pgtable_64.h   |  15 +++</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/include/asm/processor_64.h |  19 +++</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/include/asm/ttable.h       |  10 ++</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/include/uapi/asm/asi.h     |   3 +</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/include/uapi/asm/pstate.h  |  10 ++</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/kernel/entry.h             |   3 +</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/kernel/head_64.S           |   1 +</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/kernel/mdesc.c             |  81 +++++++++++++</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/kernel/process_64.c        | 222</span>
<span class="quote">&gt;&gt;&gt;&gt; ++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/kernel/sun4v_mcd.S         |  16 +++</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/kernel/traps_64.c          |  96 ++++++++++++++-</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/kernel/ttable_64.S         |   6 +-</span>
<span class="quote">&gt;&gt;&gt;&gt;    include/linux/mm.h                    |   2 +</span>
<span class="quote">&gt;&gt;&gt;&gt;    include/uapi/asm-generic/siginfo.h    |   5 +-</span>
<span class="quote">&gt;&gt;&gt;&gt;    include/uapi/linux/prctl.h            |  16 +++</span>
<span class="quote">&gt;&gt;&gt;&gt;    kernel/sys.c                          |  30 +++++</span>
<span class="quote">&gt;&gt;&gt;&gt;    22 files changed, 826 insertions(+), 6 deletions(-)</span>
<span class="quote">&gt;&gt;&gt;&gt;    create mode 100644 Documentation/prctl/sparc_adi.txt</span>
<span class="quote">&gt;&gt;&gt;&gt;    create mode 100644 Documentation/sparc/adi.txt</span>
<span class="quote">&gt;&gt;&gt;&gt;    create mode 100644 arch/sparc/kernel/sun4v_mcd.S</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; I must admit that I&#39;m slightly impressed that the documentation is</span>
<span class="quote">&gt;&gt;&gt; over a quarter of the lines added. =)</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; diff --git a/arch/sparc/Kconfig b/arch/sparc/Kconfig</span>
<span class="quote">&gt;&gt;&gt;&gt; index 56442d2..0aac0ae 100644</span>
<span class="quote">&gt;&gt;&gt;&gt; --- a/arch/sparc/Kconfig</span>
<span class="quote">&gt;&gt;&gt;&gt; +++ b/arch/sparc/Kconfig</span>
<span class="quote">&gt;&gt;&gt;&gt; @@ -80,6 +80,7 @@ config SPARC64</span>
<span class="quote">&gt;&gt;&gt;&gt;           select NO_BOOTMEM</span>
<span class="quote">&gt;&gt;&gt;&gt;           select HAVE_ARCH_AUDITSYSCALL</span>
<span class="quote">&gt;&gt;&gt;&gt;           select ARCH_SUPPORTS_ATOMIC_RMW</span>
<span class="quote">&gt;&gt;&gt;&gt; +       select SPARC_ADI</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; This doesn&#39;t look right.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;    config ARCH_DEFCONFIG</span>
<span class="quote">&gt;&gt;&gt;&gt;           string</span>
<span class="quote">&gt;&gt;&gt;&gt; @@ -314,6 +315,17 @@ if SPARC64</span>
<span class="quote">&gt;&gt;&gt;&gt;    source &quot;kernel/power/Kconfig&quot;</span>
<span class="quote">&gt;&gt;&gt;&gt;    endif</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; +config SPARC_ADI</span>
<span class="quote">&gt;&gt;&gt;&gt; +       bool &quot;Application Data Integrity support&quot;</span>
<span class="quote">&gt;&gt;&gt;&gt; +       def_bool y if SPARC64</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; def_bool is for config options without names (i.e. &quot;this is a boolean</span>
<span class="quote">&gt;&gt;&gt; value and it&#39;s default is...&quot;)</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; So if you want people to be able to disable this option, then you</span>
<span class="quote">&gt;&gt;&gt; should remove the select above and just have:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; bool &quot;Application Data Integrity support&quot;</span>
<span class="quote">&gt;&gt;&gt; default y if SPARC64</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; If you don&#39;t want people disabling it, then there&#39;s no point in having</span>
<span class="quote">&gt;&gt;&gt; a separate Kconfig symbol.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Ah, I see. I do not want people disabling it. I will make changes.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Why don&#39;t you want people disabling it? I must acknowledge that it&#39;s</span>
<span class="quote">&gt; not a lot of code, but I can see people wanting to build &quot;minimal&quot;</span>
<span class="quote">&gt; kernels for processors without ADI or to run some specific thing that</span>
<span class="quote">&gt; doesn&#39;t use ADI. Providing the kernel responds appropriately if</span>
<span class="quote">&gt; there&#39;s an unexpected ADI fault I don&#39;t see why the code would be</span>
<span class="quote">&gt; needed if it&#39;ll never be used.</span>
<span class="quote">&gt;</span>

Hi Julian,

My goal in making CONFIG_SPARC_ADI auto-selected was to not add yet 
another config option that end user has to understand and figure out 
what to do with, and make the kernel self-configuring where ADI simply 
becomes available if platform supports it. Kernel auto-detecting 
platform features is especially useful for distro kernels. I do see your 
point in being able to build a minimal kernel when building a custom 
kernel. Both options of making CONFIG_SPARC_ADI auto-selected or not, 
have pros and cons. I don&#39;t have a strong feeling about it one way or 
the other and can go either way.

Thanks,
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=129">David Miller</a> - March 6, 2016, 4:07 a.m.</div>
<pre class="content">
<span class="from">From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
Date: Wed,  2 Mar 2016 13:39:37 -0700
<span class="quote">
&gt; 	In this</span>
<span class="quote">&gt; 	first implementation I am enabling ADI for hugepages only</span>
<span class="quote">&gt; 	since these pages are locked in memory and hence avoid the</span>
<span class="quote">&gt; 	issue of saving and restoring tags.</span>

This makes the feature almost entire useless.

Non-hugepages must be in the initial implementation.
<span class="quote">
&gt; +	PR_ENABLE_SPARC_ADI - Enable ADI checking in all pages in the address</span>
<span class="quote">&gt; +		range specified. The pages in the range must be already</span>
<span class="quote">&gt; +		locked. This operation enables the TTE.mcd bit for the</span>
<span class="quote">&gt; +		pages specified. arg2 is the starting address for address</span>
<span class="quote">&gt; +		range and must be page aligned. arg3 is the length of</span>
<span class="quote">&gt; +		memory address range and must be a multiple of page size.</span>

I strongly dislike this interface, and it makes the prtctl cases look
extremely ugly and hide to the casual reader what the code is actually
doing.

This is an mprotect() operation, so add a new flag bit and implement
this via mprotect please.

Then since you are guarenteed to have a consistent ADI setting for
every single VMA region, you never &quot;lose&quot; the ADI state when you swap
out.  It&#39;s implicit in the VMA itself, because you&#39;ll store in the VMA
that this is an ADI region.

I also want this enabled unconditionally, without any Kconfig knobs.

Thanks.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 7, 2016, 3:07 p.m.</div>
<pre class="content">
On 03/05/2016 09:07 PM, David Miller wrote:
<span class="quote">&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt; Date: Wed,  2 Mar 2016 13:39:37 -0700</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; 	In this</span>
<span class="quote">&gt;&gt; 	first implementation I am enabling ADI for hugepages only</span>
<span class="quote">&gt;&gt; 	since these pages are locked in memory and hence avoid the</span>
<span class="quote">&gt;&gt; 	issue of saving and restoring tags.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This makes the feature almost entire useless.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Non-hugepages must be in the initial implementation.</span>

Hi David,

Thanks for the feedback. I will get this working for non-hugepages as 
well. ADI state of each VMA region is already stored in the VMA itself 
in my first implementation, so I do not lose it when the page is swapped 
out. The trouble is ADI version tags for each VMA region have to be 
stored on the swapped out pages since the ADI version tags are flushed 
when TLB entry for a page is flushed. When that page is brought back in, 
its version tags have to be set up again. Version tags are set on 
cacheline boundary and hence there can be multiple version tags for a 
single page. Version tags have to be stored in the swap space somehow 
along with the page. I can start out with allowing ADI to be enabled 
only on pages locked in memory.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +	PR_ENABLE_SPARC_ADI - Enable ADI checking in all pages in the address</span>
<span class="quote">&gt;&gt; +		range specified. The pages in the range must be already</span>
<span class="quote">&gt;&gt; +		locked. This operation enables the TTE.mcd bit for the</span>
<span class="quote">&gt;&gt; +		pages specified. arg2 is the starting address for address</span>
<span class="quote">&gt;&gt; +		range and must be page aligned. arg3 is the length of</span>
<span class="quote">&gt;&gt; +		memory address range and must be a multiple of page size.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I strongly dislike this interface, and it makes the prtctl cases look</span>
<span class="quote">&gt; extremely ugly and hide to the casual reader what the code is actually</span>
<span class="quote">&gt; doing.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This is an mprotect() operation, so add a new flag bit and implement</span>
<span class="quote">&gt; this via mprotect please.</span>

That is an interesting idea. Adding a PROT_ADI protection to mprotect() 
sounds cleaner. There are three steps to enabling ADI - (1) set 
PSTATE.mcde bit which is not tied to any VMA, (2) set TTE.mcd for each 
VMA, and (3) set the version tag on cacheline using MCD ASI. I can 
combine steps 1 and 2 in one mprotect() call. That will leave 
PR_GET_SPARC_ADICAPS and PR_GET_SPARC_ADI_STATUS prctl commands still to 
be implemented. PR_SET_SPARC_ADI is also used to check if the process 
has PSTATE.mcde bit set. I could use PR_GET_SPARC_ADI_STATUS to do that 
where return values of 0 and 1 mean the same as before and possibly add 
return value of 2 to mean PSTATE.mcde is not set?
<span class="quote">
&gt;</span>
<span class="quote">&gt; Then since you are guarenteed to have a consistent ADI setting for</span>
<span class="quote">&gt; every single VMA region, you never &quot;lose&quot; the ADI state when you swap</span>
<span class="quote">&gt; out.  It&#39;s implicit in the VMA itself, because you&#39;ll store in the VMA</span>
<span class="quote">&gt; that this is an ADI region.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I also want this enabled unconditionally, without any Kconfig knobs.</span>
<span class="quote">&gt;</span>

I can remove CONFIG_SPARC_ADI. It does mean this code will be built into 
32-bit kernels as well but it will be inactive code.

Thanks,
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=157521">Rob Gardner</a> - March 7, 2016, 3:30 p.m.</div>
<pre class="content">
On 03/07/2016 07:07 AM, Khalid Aziz wrote:
<span class="quote">&gt; On 03/05/2016 09:07 PM, David Miller wrote:</span>
<span class="quote">&gt;&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt; Date: Wed,  2 Mar 2016 13:39:37 -0700</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;     In this</span>
<span class="quote">&gt;&gt;&gt;     first implementation I am enabling ADI for hugepages only</span>
<span class="quote">&gt;&gt;&gt;     since these pages are locked in memory and hence avoid the</span>
<span class="quote">&gt;&gt;&gt;     issue of saving and restoring tags.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This makes the feature almost entire useless.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Non-hugepages must be in the initial implementation.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Hi David,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Thanks for the feedback. I will get this working for non-hugepages as </span>
<span class="quote">&gt; well. ADI state of each VMA region is already stored in the VMA itself </span>
<span class="quote">&gt; in my first implementation, so I do not lose it when the page is </span>
<span class="quote">&gt; swapped out. The trouble is ADI version tags for each VMA region have </span>
<span class="quote">&gt; to be stored on the swapped out pages since the ADI version tags are </span>
<span class="quote">&gt; flushed when TLB entry for a page is flushed. </span>


Khalid,

Are you sure about that last statement? My understanding is that the 
tags are stored in physical memory, and remain there until explicitly 
changed or removed, and so flushing a TLB entry has no effect on the ADI 
tags. If it worked the way you think, then somebody would have to 
potentially reload a long list of ADI tags on every TLB miss.

Rob
<span class="quote">


&gt; When that page is brought back in, its version tags have to be set up </span>
<span class="quote">&gt; again. Version tags are set on cacheline boundary and hence there can </span>
<span class="quote">&gt; be multiple version tags for a single page. Version tags have to be </span>
<span class="quote">&gt; stored in the swap space somehow along with the page. I can start out </span>
<span class="quote">&gt; with allowing ADI to be enabled only on pages locked in memory.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; +    PR_ENABLE_SPARC_ADI - Enable ADI checking in all pages in the </span>
<span class="quote">&gt;&gt;&gt; address</span>
<span class="quote">&gt;&gt;&gt; +        range specified. The pages in the range must be already</span>
<span class="quote">&gt;&gt;&gt; +        locked. This operation enables the TTE.mcd bit for the</span>
<span class="quote">&gt;&gt;&gt; +        pages specified. arg2 is the starting address for address</span>
<span class="quote">&gt;&gt;&gt; +        range and must be page aligned. arg3 is the length of</span>
<span class="quote">&gt;&gt;&gt; +        memory address range and must be a multiple of page size.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I strongly dislike this interface, and it makes the prtctl cases look</span>
<span class="quote">&gt;&gt; extremely ugly and hide to the casual reader what the code is actually</span>
<span class="quote">&gt;&gt; doing.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This is an mprotect() operation, so add a new flag bit and implement</span>
<span class="quote">&gt;&gt; this via mprotect please.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; That is an interesting idea. Adding a PROT_ADI protection to </span>
<span class="quote">&gt; mprotect() sounds cleaner. There are three steps to enabling ADI - (1) </span>
<span class="quote">&gt; set PSTATE.mcde bit which is not tied to any VMA, (2) set TTE.mcd for </span>
<span class="quote">&gt; each VMA, and (3) set the version tag on cacheline using MCD ASI. I </span>
<span class="quote">&gt; can combine steps 1 and 2 in one mprotect() call. That will leave </span>
<span class="quote">&gt; PR_GET_SPARC_ADICAPS and PR_GET_SPARC_ADI_STATUS prctl commands still </span>
<span class="quote">&gt; to be implemented. PR_SET_SPARC_ADI is also used to check if the </span>
<span class="quote">&gt; process has PSTATE.mcde bit set. I could use PR_GET_SPARC_ADI_STATUS </span>
<span class="quote">&gt; to do that where return values of 0 and 1 mean the same as before and </span>
<span class="quote">&gt; possibly add return value of 2 to mean PSTATE.mcde is not set?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Then since you are guarenteed to have a consistent ADI setting for</span>
<span class="quote">&gt;&gt; every single VMA region, you never &quot;lose&quot; the ADI state when you swap</span>
<span class="quote">&gt;&gt; out.  It&#39;s implicit in the VMA itself, because you&#39;ll store in the VMA</span>
<span class="quote">&gt;&gt; that this is an ADI region.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I also want this enabled unconditionally, without any Kconfig knobs.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I can remove CONFIG_SPARC_ADI. It does mean this code will be built </span>
<span class="quote">&gt; into 32-bit kernels as well but it will be inactive code.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Thanks,</span>
<span class="quote">&gt; Khalid</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41531">Andy Lutomirski</a> - March 7, 2016, 3:43 p.m.</div>
<pre class="content">
On Mon, Mar 7, 2016 at 7:30 AM, Rob Gardner &lt;rob.gardner@oracle.com&gt; wrote:
<span class="quote">&gt; On 03/07/2016 07:07 AM, Khalid Aziz wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On 03/05/2016 09:07 PM, David Miller wrote:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt;&gt; Date: Wed,  2 Mar 2016 13:39:37 -0700</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;     In this</span>
<span class="quote">&gt;&gt;&gt;&gt;     first implementation I am enabling ADI for hugepages only</span>
<span class="quote">&gt;&gt;&gt;&gt;     since these pages are locked in memory and hence avoid the</span>
<span class="quote">&gt;&gt;&gt;&gt;     issue of saving and restoring tags.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; This makes the feature almost entire useless.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Non-hugepages must be in the initial implementation.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Hi David,</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Thanks for the feedback. I will get this working for non-hugepages as</span>
<span class="quote">&gt;&gt; well. ADI state of each VMA region is already stored in the VMA itself in my</span>
<span class="quote">&gt;&gt; first implementation, so I do not lose it when the page is swapped out. The</span>
<span class="quote">&gt;&gt; trouble is ADI version tags for each VMA region have to be stored on the</span>
<span class="quote">&gt;&gt; swapped out pages since the ADI version tags are flushed when TLB entry for</span>
<span class="quote">&gt;&gt; a page is flushed.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Khalid,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Are you sure about that last statement? My understanding is that the tags</span>
<span class="quote">&gt; are stored in physical memory, and remain there until explicitly changed or</span>
<span class="quote">&gt; removed, and so flushing a TLB entry has no effect on the ADI tags. If it</span>
<span class="quote">&gt; worked the way you think, then somebody would have to potentially reload a</span>
<span class="quote">&gt; long list of ADI tags on every TLB miss.</span>
<span class="quote">&gt;</span>

I&#39;ll bite, since this was sent to linux-api:

Can someone explain what this feature does for the benefit of people
who haven&#39;t read the manual (and who don&#39;t even know where to find the
manual)?

Are the top few bits of a sparc64 virtual address currently
must-be-zero?  Does this feature change the semantics so that those
bits are ignored for address resolution and instead must match
whatever the ADI tag is determined to be during address resolution?

Is this enforced for both user and kernel accesses?

Is the actual ADI tag associated with a &quot;page&quot; associated with the
page of physical memory or is it associated with a mapping?  That is,
if there are two virtual aliases of the same physical page (in the
same process or otherwise), does the hardware require them to have the
same ADI tag?  If the answer is no, then IMO this is definitely
something that should use mprotect and you should seriously consider
using something like mprotect_key (new syscall, not in Linus&#39; tree
yet) for it.  In fact, you might consider a possible extra parameter
to that syscall for this purpose.

Cc: Dave Hansen.  It seems to be the zeitgeist to throw tag bits at
PTEs these days.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 7, 2016, 3:45 p.m.</div>
<pre class="content">
On 03/07/2016 08:30 AM, Rob Gardner wrote:
<span class="quote">&gt; On 03/07/2016 07:07 AM, Khalid Aziz wrote:</span>
<span class="quote">&gt;&gt; On 03/05/2016 09:07 PM, David Miller wrote:</span>
<span class="quote">&gt;&gt;&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt;&gt; Date: Wed,  2 Mar 2016 13:39:37 -0700</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;     In this</span>
<span class="quote">&gt;&gt;&gt;&gt;     first implementation I am enabling ADI for hugepages only</span>
<span class="quote">&gt;&gt;&gt;&gt;     since these pages are locked in memory and hence avoid the</span>
<span class="quote">&gt;&gt;&gt;&gt;     issue of saving and restoring tags.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; This makes the feature almost entire useless.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Non-hugepages must be in the initial implementation.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Hi David,</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Thanks for the feedback. I will get this working for non-hugepages as</span>
<span class="quote">&gt;&gt; well. ADI state of each VMA region is already stored in the VMA itself</span>
<span class="quote">&gt;&gt; in my first implementation, so I do not lose it when the page is</span>
<span class="quote">&gt;&gt; swapped out. The trouble is ADI version tags for each VMA region have</span>
<span class="quote">&gt;&gt; to be stored on the swapped out pages since the ADI version tags are</span>
<span class="quote">&gt;&gt; flushed when TLB entry for a page is flushed.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Khalid,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Are you sure about that last statement? My understanding is that the</span>
<span class="quote">&gt; tags are stored in physical memory, and remain there until explicitly</span>
<span class="quote">&gt; changed or removed, and so flushing a TLB entry has no effect on the ADI</span>
<span class="quote">&gt; tags. If it worked the way you think, then somebody would have to</span>
<span class="quote">&gt; potentially reload a long list of ADI tags on every TLB miss.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Rob</span>
<span class="quote">&gt;</span>

Hi Rob,

I am fairly sure that is the case. This is what I found from the 
processor guys and others working on ADI. I tested it out by setting up 
ADI on normal malloc&#39;d pages that got swapped out and I got MCD 
exceptions when those pages were swapped back in on access.

I mis-spoke when I said &quot;....ADI version tags are flushed when TLB entry 
for a page is flushed&quot;. I meant ADI version tags are flushed when 
mapping for a virtual address is removed from TSB, not when TLB entry is 
flushed. Yes, ADI tags are stored in physical memory and removed when 
mapping is removed.

Thanks,
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 7, 2016, 4:06 p.m.</div>
<pre class="content">
On 03/07/2016 08:43 AM, Andy Lutomirski wrote:
<span class="quote">&gt; On Mon, Mar 7, 2016 at 7:30 AM, Rob Gardner &lt;rob.gardner@oracle.com&gt; wrote:</span>
<span class="quote">&gt;&gt; On 03/07/2016 07:07 AM, Khalid Aziz wrote:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; On 03/05/2016 09:07 PM, David Miller wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Date: Wed,  2 Mar 2016 13:39:37 -0700</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;      In this</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;      first implementation I am enabling ADI for hugepages only</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;      since these pages are locked in memory and hence avoid the</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;      issue of saving and restoring tags.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; This makes the feature almost entire useless.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Non-hugepages must be in the initial implementation.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Hi David,</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Thanks for the feedback. I will get this working for non-hugepages as</span>
<span class="quote">&gt;&gt;&gt; well. ADI state of each VMA region is already stored in the VMA itself in my</span>
<span class="quote">&gt;&gt;&gt; first implementation, so I do not lose it when the page is swapped out. The</span>
<span class="quote">&gt;&gt;&gt; trouble is ADI version tags for each VMA region have to be stored on the</span>
<span class="quote">&gt;&gt;&gt; swapped out pages since the ADI version tags are flushed when TLB entry for</span>
<span class="quote">&gt;&gt;&gt; a page is flushed.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Khalid,</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Are you sure about that last statement? My understanding is that the tags</span>
<span class="quote">&gt;&gt; are stored in physical memory, and remain there until explicitly changed or</span>
<span class="quote">&gt;&gt; removed, and so flushing a TLB entry has no effect on the ADI tags. If it</span>
<span class="quote">&gt;&gt; worked the way you think, then somebody would have to potentially reload a</span>
<span class="quote">&gt;&gt; long list of ADI tags on every TLB miss.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I&#39;ll bite, since this was sent to linux-api:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Can someone explain what this feature does for the benefit of people</span>
<span class="quote">&gt; who haven&#39;t read the manual (and who don&#39;t even know where to find the</span>
<span class="quote">&gt; manual)?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Are the top few bits of a sparc64 virtual address currently</span>
<span class="quote">&gt; must-be-zero?  Does this feature change the semantics so that those</span>
<span class="quote">&gt; bits are ignored for address resolution and instead must match</span>
<span class="quote">&gt; whatever the ADI tag is determined to be during address resolution?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Is this enforced for both user and kernel accesses?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Is the actual ADI tag associated with a &quot;page&quot; associated with the</span>
<span class="quote">&gt; page of physical memory or is it associated with a mapping?  That is,</span>
<span class="quote">&gt; if there are two virtual aliases of the same physical page (in the</span>
<span class="quote">&gt; same process or otherwise), does the hardware require them to have the</span>
<span class="quote">&gt; same ADI tag?  If the answer is no, then IMO this is definitely</span>
<span class="quote">&gt; something that should use mprotect and you should seriously consider</span>
<span class="quote">&gt; using something like mprotect_key (new syscall, not in Linus&#39; tree</span>
<span class="quote">&gt; yet) for it.  In fact, you might consider a possible extra parameter</span>
<span class="quote">&gt; to that syscall for this purpose.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Cc: Dave Hansen.  It seems to be the zeitgeist to throw tag bits at</span>
<span class="quote">&gt; PTEs these days.</span>
<span class="quote">&gt;</span>

Hi Andy,

The primary purpose of this feature is to prevent rogue accesses to 
memory regions. If a database were to allocate memory pages to cache 
database, it can enable ADI on those pages and set version tags. Version 
tag for a memory address is encoded in bits 63-60 in the virtual 
address. When accessing an ADI enabled memory region, top 4 bits of the 
virtual address presented to the MMU must match the version tag set 
earlier. When these bits do not match a tag, an MCD (Memory Corruption 
Detected) exception is raised. Kernel sends a SIGBUS to the offending 
process in response. There is some more info on ADI at 
&lt;https://swisdev.oracle.com/_files/What-Is-ADI.html&gt;.

Top 4-bits of sparc64 virtual address are used for version tag only when 
a process has its PSTATE.mcde bit set and it is accessing a memory 
region that has ADI enabled on it (TTE.mcd set) and a version tag was 
set on the virtual address being accessed. These 4-bits retain their 
original semantics in all other cases.

ADI version tags are checked for data fetches only. My implementation 
enforces this for userspace addresses only. Expanding this to include 
kernel data addresses as well will be a good thing to do to protect 
kernel data but I want to try to do this incrementally - (1) ADI for 
userspace addresses only for mlock&#39;d pages, (2) expand support to 
swappable pages, (3) ADI for kernel data pages, (4)......whatever else 
makes sense...

ADI version tag applies to virtual addresses only. If two processes have 
virtual addresses mapping to the same physical page, they must use the 
same tag. Hardware will send MCD exception if the tags do not match. 
This was done to ensure a hack does not bypass ADI protection by simply 
inserting another VA-to-PA mapping. I do like the idea of mprotect() as 
David suggested and it can be done with existing mprotect() call. I will 
have to add a new key PROT_ADI to support this.

Thanks,
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=129">David Miller</a> - March 7, 2016, 4:45 p.m.</div>
<pre class="content">
<span class="from">From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
Date: Mon, 7 Mar 2016 08:07:53 -0700
<span class="quote">
&gt; I can remove CONFIG_SPARC_ADI. It does mean this code will be built</span>
<span class="quote">&gt; into 32-bit kernels as well but it will be inactive code.</span>

The code should be built only into obj-$(CONFIG_SPARC64) just like the
rest of the 64-bit specific code.  I don&#39;t know why in the world you
would build it into the 32-bit kernel.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=129">David Miller</a> - March 7, 2016, 4:56 p.m.</div>
<pre class="content">
<span class="from">From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
Date: Mon, 7 Mar 2016 08:07:53 -0700
<span class="quote">
&gt; PR_GET_SPARC_ADICAPS</span>

Put this into a new ELF auxiliary vector entry via ARCH_DLINFO.

So now all that&#39;s left is supposedly the TAG stuff, please explain
that to me so I can direct you to the correct existing interface to
provide that as well.

Really, try to avoid prtctl, it&#39;s poorly typed and almost worse than
ioctl().
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=65121">Dave Hansen</a> - March 7, 2016, 5:32 p.m.</div>
<pre class="content">
On 03/02/2016 12:39 PM, Khalid Aziz wrote:
<span class="quote">&gt; --- a/include/uapi/asm-generic/siginfo.h</span>
<span class="quote">&gt; +++ b/include/uapi/asm-generic/siginfo.h</span>
<span class="quote">&gt; @@ -206,7 +206,10 @@ typedef struct siginfo {</span>
<span class="quote">&gt;  #define SEGV_MAPERR	(__SI_FAULT|1)	/* address not mapped to object */</span>
<span class="quote">&gt;  #define SEGV_ACCERR	(__SI_FAULT|2)	/* invalid permissions for mapped object */</span>
<span class="quote">&gt;  #define SEGV_BNDERR	(__SI_FAULT|3)  /* failed address bound checks */</span>
<span class="quote">&gt; -#define NSIGSEGV	3</span>
<span class="quote">&gt; +#define SEGV_ACCADI	(__SI_FAULT|4)	/* ADI not enabled for mapped object */</span>
<span class="quote">&gt; +#define SEGV_ADIDERR	(__SI_FAULT|5)	/* Disrupting MCD error */</span>
<span class="quote">&gt; +#define SEGV_ADIPERR	(__SI_FAULT|6)	/* Precise MCD exception */</span>
<span class="quote">&gt; +#define NSIGSEGV	6</span>

FYI, this will conflict with code in -tip right now:
<span class="quote">
&gt; http://git.kernel.org/cgit/linux/kernel/git/tip/tip.git/commit/?h=mm/pkeys&amp;id=cd0ea35ff5511cde299a61c21a95889b4a71464e</span>

It&#39;s not a big deal to resolve, of course.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=65121">Dave Hansen</a> - March 7, 2016, 5:35 p.m.</div>
<pre class="content">
On 03/02/2016 12:39 PM, Khalid Aziz wrote:
<span class="quote">&gt; +long enable_sparc_adi(unsigned long addr, unsigned long len)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	unsigned long end, pagemask;</span>
<span class="quote">&gt; +	int error;</span>
<span class="quote">&gt; +	struct vm_area_struct *vma, *vma2;</span>
<span class="quote">&gt; +	struct mm_struct *mm;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!ADI_CAPABLE())</span>
<span class="quote">&gt; +		return -EINVAL;</span>
...

This whole thing with the VMA splitting and so forth looks pretty darn
arch-independent.  Are you sure you need that much arch-specific code
for it, or can you share more of the generic VMA management code?
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=64071">Dave Hansen</a> - March 7, 2016, 5:46 p.m.</div>
<pre class="content">
On 03/07/2016 08:06 AM, Khalid Aziz wrote:
<span class="quote">&gt; Top 4-bits of sparc64 virtual address are used for version tag only when</span>
<span class="quote">&gt; a process has its PSTATE.mcde bit set and it is accessing a memory</span>
<span class="quote">&gt; region that has ADI enabled on it (TTE.mcd set) and a version tag was</span>
<span class="quote">&gt; set on the virtual address being accessed. These 4-bits retain their</span>
<span class="quote">&gt; original semantics in all other cases.</span>

OK, so this effectively reduces the address space of a process using the
feature.  Do we need to do anything explicit to keep an app from using
that address space?  Do we make sure the kernel doesn&#39;t place VMAs
there?  Do we respect mmap() hints that try to place memory there?
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 7, 2016, 5:51 p.m.</div>
<pre class="content">
On 03/07/2016 09:45 AM, David Miller wrote:
<span class="quote">&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt; Date: Mon, 7 Mar 2016 08:07:53 -0700</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; I can remove CONFIG_SPARC_ADI. It does mean this code will be built</span>
<span class="quote">&gt;&gt; into 32-bit kernels as well but it will be inactive code.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The code should be built only into obj-$(CONFIG_SPARC64) just like the</span>
<span class="quote">&gt; rest of the 64-bit specific code.  I don&#39;t know why in the world you</span>
<span class="quote">&gt; would build it into the 32-bit kernel.</span>
<span class="quote">&gt;</span>

You are right. I did not understand you correctly the first time.

Thanks,
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41531">Andy Lutomirski</a> - March 7, 2016, 5:53 p.m.</div>
<pre class="content">
On Mon, Mar 7, 2016 at 9:46 AM, Dave Hansen &lt;dave.hansen@linux.intel.com&gt; wrote:
<span class="quote">&gt; On 03/07/2016 08:06 AM, Khalid Aziz wrote:</span>
<span class="quote">&gt;&gt; Top 4-bits of sparc64 virtual address are used for version tag only when</span>
<span class="quote">&gt;&gt; a process has its PSTATE.mcde bit set and it is accessing a memory</span>
<span class="quote">&gt;&gt; region that has ADI enabled on it (TTE.mcd set) and a version tag was</span>
<span class="quote">&gt;&gt; set on the virtual address being accessed. These 4-bits retain their</span>
<span class="quote">&gt;&gt; original semantics in all other cases.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; OK, so this effectively reduces the address space of a process using the</span>
<span class="quote">&gt; feature.  Do we need to do anything explicit to keep an app from using</span>
<span class="quote">&gt; that address space?  Do we make sure the kernel doesn&#39;t place VMAs</span>
<span class="quote">&gt; there?  Do we respect mmap() hints that try to place memory there?</span>

Also, what happens when someone does this to an aliased page?  This
could be a MAP_SHARED mapping or a not-yet-COWed MAP_ANONYMOUS
mapping.

Also, what am I missing?  Tying these tags to the physical page seems
like a poor design to me.  This seems really awkward to use.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 7, 2016, 6:04 p.m.</div>
<pre class="content">
On 03/07/2016 09:56 AM, David Miller wrote:
<span class="quote">&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt; Date: Mon, 7 Mar 2016 08:07:53 -0700</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; PR_GET_SPARC_ADICAPS</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Put this into a new ELF auxiliary vector entry via ARCH_DLINFO.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; So now all that&#39;s left is supposedly the TAG stuff, please explain</span>
<span class="quote">&gt; that to me so I can direct you to the correct existing interface to</span>
<span class="quote">&gt; provide that as well.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Really, try to avoid prtctl, it&#39;s poorly typed and almost worse than</span>
<span class="quote">&gt; ioctl().</span>
<span class="quote">&gt;</span>

The two remaining operations I am looking at are:

1. Is PSTATE.mcde bit set for the process? PR_SET_SPARC_ADI provides 
this in its return value in the patch I sent.

2. Is TTE.mcd set for a given virtual address? PR_GET_SPARC_ADI_STATUS 
provides this function in the patch I sent.

Setting and clearing version tags can be done entirely from userspace:

         while (addr &lt; end) {
                 asm volatile(
                         &quot;stxa %1, [%0]ASI_MCD_PRIMARY\n\t&quot;
                         :
                         : &quot;r&quot; (addr), &quot;r&quot; (version));
                 addr += adicap.blksz;
         }
so I do not have to add any kernel code for tags.

Thanks,
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41531">Andy Lutomirski</a> - March 7, 2016, 6:08 p.m.</div>
<pre class="content">
On Mon, Mar 7, 2016 at 10:04 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt; wrote:
<span class="quote">&gt; On 03/07/2016 09:56 AM, David Miller wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt; Date: Mon, 7 Mar 2016 08:07:53 -0700</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; PR_GET_SPARC_ADICAPS</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Put this into a new ELF auxiliary vector entry via ARCH_DLINFO.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; So now all that&#39;s left is supposedly the TAG stuff, please explain</span>
<span class="quote">&gt;&gt; that to me so I can direct you to the correct existing interface to</span>
<span class="quote">&gt;&gt; provide that as well.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Really, try to avoid prtctl, it&#39;s poorly typed and almost worse than</span>
<span class="quote">&gt;&gt; ioctl().</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The two remaining operations I am looking at are:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 1. Is PSTATE.mcde bit set for the process? PR_SET_SPARC_ADI provides this in</span>
<span class="quote">&gt; its return value in the patch I sent.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 2. Is TTE.mcd set for a given virtual address? PR_GET_SPARC_ADI_STATUS</span>
<span class="quote">&gt; provides this function in the patch I sent.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Setting and clearing version tags can be done entirely from userspace:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;         while (addr &lt; end) {</span>
<span class="quote">&gt;                 asm volatile(</span>
<span class="quote">&gt;                         &quot;stxa %1, [%0]ASI_MCD_PRIMARY\n\t&quot;</span>
<span class="quote">&gt;                         :</span>
<span class="quote">&gt;                         : &quot;r&quot; (addr), &quot;r&quot; (version));</span>
<span class="quote">&gt;                 addr += adicap.blksz;</span>
<span class="quote">&gt;         }</span>
<span class="quote">&gt; so I do not have to add any kernel code for tags.</span>

Is the effect of that to change the tag associated with a page to
which the caller has write access?

I sense DoS issues in your future.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=157521">Rob Gardner</a> - March 7, 2016, 6:09 p.m.</div>
<pre class="content">
On 03/07/2016 10:04 AM, Khalid Aziz wrote:
<span class="quote">&gt; On 03/07/2016 09:56 AM, David Miller wrote:</span>
<span class="quote">&gt;&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt; Date: Mon, 7 Mar 2016 08:07:53 -0700</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; PR_GET_SPARC_ADICAPS</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Put this into a new ELF auxiliary vector entry via ARCH_DLINFO.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; So now all that&#39;s left is supposedly the TAG stuff, please explain</span>
<span class="quote">&gt;&gt; that to me so I can direct you to the correct existing interface to</span>
<span class="quote">&gt;&gt; provide that as well.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Really, try to avoid prtctl, it&#39;s poorly typed and almost worse than</span>
<span class="quote">&gt;&gt; ioctl().</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The two remaining operations I am looking at are:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 1. Is PSTATE.mcde bit set for the process? PR_SET_SPARC_ADI provides </span>
<span class="quote">&gt; this in its return value in the patch I sent.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 2. Is TTE.mcd set for a given virtual address? PR_GET_SPARC_ADI_STATUS </span>
<span class="quote">&gt; provides this function in the patch I sent.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Setting and clearing version tags can be done entirely from userspace:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;         while (addr &lt; end) {</span>
<span class="quote">&gt;                 asm volatile(</span>
<span class="quote">&gt;                         &quot;stxa %1, [%0]ASI_MCD_PRIMARY\n\t&quot;</span>
<span class="quote">&gt;                         :</span>
<span class="quote">&gt;                         : &quot;r&quot; (addr), &quot;r&quot; (version));</span>
<span class="quote">&gt;                 addr += adicap.blksz;</span>
<span class="quote">&gt;         }</span>
<span class="quote">&gt; so I do not have to add any kernel code for tags.</span>
<span class="quote">&gt;</span>

What about clearing the tags when the user is done with the memory? You 
can&#39;t count on the user to do that, so doesn&#39;t the kernel have to do it 
someplace?

Rob
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=64071">Dave Hansen</a> - March 7, 2016, 6:12 p.m.</div>
<pre class="content">
On 03/07/2016 09:53 AM, Andy Lutomirski wrote:
<span class="quote">&gt; Also, what am I missing?  Tying these tags to the physical page seems</span>
<span class="quote">&gt; like a poor design to me.  This seems really awkward to use.</span>

Yeah, can you describe the structures that store these things?  Surely
the hardware has some kind of lookup tables for them and stores them in
memory _somewhere_.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 7, 2016, 6:15 p.m.</div>
<pre class="content">
On 03/07/2016 10:35 AM, Dave Hansen wrote:
<span class="quote">&gt; On 03/02/2016 12:39 PM, Khalid Aziz wrote:</span>
<span class="quote">&gt;&gt; +long enable_sparc_adi(unsigned long addr, unsigned long len)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	unsigned long end, pagemask;</span>
<span class="quote">&gt;&gt; +	int error;</span>
<span class="quote">&gt;&gt; +	struct vm_area_struct *vma, *vma2;</span>
<span class="quote">&gt;&gt; +	struct mm_struct *mm;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	if (!ADI_CAPABLE())</span>
<span class="quote">&gt;&gt; +		return -EINVAL;</span>
<span class="quote">&gt; ...</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This whole thing with the VMA splitting and so forth looks pretty darn</span>
<span class="quote">&gt; arch-independent.  Are you sure you need that much arch-specific code</span>
<span class="quote">&gt; for it, or can you share more of the generic VMA management code?</span>
<span class="quote">&gt;</span>

All of the VMA splitting/merging code is rather generic and is very 
similar to the code for mbind, mlock, madavise and mprotect. Currently 
there is no code sharing across all of these implementations. Maybe that 
should change. In any case, I am looking at changing the interface to go 
through mprotect instead as Dave suggested. I can share the code in 
mprotect in that case. The only arch dependent part will be to set the 
VM_SPARC_ADI flag on the VMA.

Thanks,
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 7, 2016, 6:22 p.m.</div>
<pre class="content">
On 03/07/2016 11:08 AM, Andy Lutomirski wrote:
<span class="quote">&gt; On Mon, Mar 7, 2016 at 10:04 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt; wrote:</span>
<span class="quote">&gt;&gt; On 03/07/2016 09:56 AM, David Miller wrote:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt;&gt; Date: Mon, 7 Mar 2016 08:07:53 -0700</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; PR_GET_SPARC_ADICAPS</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Put this into a new ELF auxiliary vector entry via ARCH_DLINFO.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; So now all that&#39;s left is supposedly the TAG stuff, please explain</span>
<span class="quote">&gt;&gt;&gt; that to me so I can direct you to the correct existing interface to</span>
<span class="quote">&gt;&gt;&gt; provide that as well.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Really, try to avoid prtctl, it&#39;s poorly typed and almost worse than</span>
<span class="quote">&gt;&gt;&gt; ioctl().</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The two remaining operations I am looking at are:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; 1. Is PSTATE.mcde bit set for the process? PR_SET_SPARC_ADI provides this in</span>
<span class="quote">&gt;&gt; its return value in the patch I sent.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; 2. Is TTE.mcd set for a given virtual address? PR_GET_SPARC_ADI_STATUS</span>
<span class="quote">&gt;&gt; provides this function in the patch I sent.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Setting and clearing version tags can be done entirely from userspace:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;          while (addr &lt; end) {</span>
<span class="quote">&gt;&gt;                  asm volatile(</span>
<span class="quote">&gt;&gt;                          &quot;stxa %1, [%0]ASI_MCD_PRIMARY\n\t&quot;</span>
<span class="quote">&gt;&gt;                          :</span>
<span class="quote">&gt;&gt;                          : &quot;r&quot; (addr), &quot;r&quot; (version));</span>
<span class="quote">&gt;&gt;                  addr += adicap.blksz;</span>
<span class="quote">&gt;&gt;          }</span>
<span class="quote">&gt;&gt; so I do not have to add any kernel code for tags.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Is the effect of that to change the tag associated with a page to</span>
<span class="quote">&gt; which the caller has write access?</span>

No, it changes the tag associated with the virtual address for the 
caller. Physical page backing this virtual address is unaffected. Tag 
checking is done for virtual addresses. The one restriction where 
physical address is relevant is when two processes map the same physical 
page, they both have to use the same tag for the virtual addresses that 
map on to the shared physical pages.
<span class="quote">
&gt;</span>
<span class="quote">&gt; I sense DoS issues in your future.</span>
<span class="quote">&gt;</span>

Are you concerned about DoS even if the tag is associated with virtual 
address, not physical address?

Thanks,
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 7, 2016, 6:24 p.m.</div>
<pre class="content">
On 03/07/2016 11:09 AM, Rob Gardner wrote:
<span class="quote">&gt; On 03/07/2016 10:04 AM, Khalid Aziz wrote:</span>
<span class="quote">&gt;&gt; On 03/07/2016 09:56 AM, David Miller wrote:</span>
<span class="quote">&gt;&gt;&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt;&gt; Date: Mon, 7 Mar 2016 08:07:53 -0700</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; PR_GET_SPARC_ADICAPS</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Put this into a new ELF auxiliary vector entry via ARCH_DLINFO.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; So now all that&#39;s left is supposedly the TAG stuff, please explain</span>
<span class="quote">&gt;&gt;&gt; that to me so I can direct you to the correct existing interface to</span>
<span class="quote">&gt;&gt;&gt; provide that as well.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Really, try to avoid prtctl, it&#39;s poorly typed and almost worse than</span>
<span class="quote">&gt;&gt;&gt; ioctl().</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The two remaining operations I am looking at are:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; 1. Is PSTATE.mcde bit set for the process? PR_SET_SPARC_ADI provides</span>
<span class="quote">&gt;&gt; this in its return value in the patch I sent.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; 2. Is TTE.mcd set for a given virtual address? PR_GET_SPARC_ADI_STATUS</span>
<span class="quote">&gt;&gt; provides this function in the patch I sent.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Setting and clearing version tags can be done entirely from userspace:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;         while (addr &lt; end) {</span>
<span class="quote">&gt;&gt;                 asm volatile(</span>
<span class="quote">&gt;&gt;                         &quot;stxa %1, [%0]ASI_MCD_PRIMARY\n\t&quot;</span>
<span class="quote">&gt;&gt;                         :</span>
<span class="quote">&gt;&gt;                         : &quot;r&quot; (addr), &quot;r&quot; (version));</span>
<span class="quote">&gt;&gt;                 addr += adicap.blksz;</span>
<span class="quote">&gt;&gt;         }</span>
<span class="quote">&gt;&gt; so I do not have to add any kernel code for tags.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; What about clearing the tags when the user is done with the memory? You</span>
<span class="quote">&gt; can&#39;t count on the user to do that, so doesn&#39;t the kernel have to do it</span>
<span class="quote">&gt; someplace?</span>
<span class="quote">&gt;</span>

Tags can be cleared by user by setting tag to 0. Tags are automatically 
cleared by the hardware when the mapping for a virtual address is 
removed from TSB (which is why swappable pages are a problem), so kernel 
does not have to do it as part of clean up.

Thanks,
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 7, 2016, 6:39 p.m.</div>
<pre class="content">
On 03/07/2016 11:12 AM, Dave Hansen wrote:
<span class="quote">&gt; On 03/07/2016 09:53 AM, Andy Lutomirski wrote:</span>
<span class="quote">&gt;&gt; Also, what am I missing?  Tying these tags to the physical page seems</span>
<span class="quote">&gt;&gt; like a poor design to me.  This seems really awkward to use.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Yeah, can you describe the structures that store these things?  Surely</span>
<span class="quote">&gt; the hardware has some kind of lookup tables for them and stores them in</span>
<span class="quote">&gt; memory _somewhere_.</span>
<span class="quote">&gt;</span>

Version tags are tied to virtual addresses, not physical pages.

Where exactly are the tags stored is part of processor architecture and 
I am not privy to that. MMU stores these lookup tables somewhere and 
uses it to authenticate access to virtual addresses. It really is 
irrelevant to kernel how MMU implements access controls as long as we 
have access to the knowledge of how to use it.

Thanks,
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41531">Andy Lutomirski</a> - March 7, 2016, 6:49 p.m.</div>
<pre class="content">
On Mon, Mar 7, 2016 at 10:22 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt; wrote:
<span class="quote">&gt; On 03/07/2016 11:08 AM, Andy Lutomirski wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On Mon, Mar 7, 2016 at 10:04 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt; wrote:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; On 03/07/2016 09:56 AM, David Miller wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Date: Mon, 7 Mar 2016 08:07:53 -0700</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; PR_GET_SPARC_ADICAPS</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Put this into a new ELF auxiliary vector entry via ARCH_DLINFO.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; So now all that&#39;s left is supposedly the TAG stuff, please explain</span>
<span class="quote">&gt;&gt;&gt;&gt; that to me so I can direct you to the correct existing interface to</span>
<span class="quote">&gt;&gt;&gt;&gt; provide that as well.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Really, try to avoid prtctl, it&#39;s poorly typed and almost worse than</span>
<span class="quote">&gt;&gt;&gt;&gt; ioctl().</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; The two remaining operations I am looking at are:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; 1. Is PSTATE.mcde bit set for the process? PR_SET_SPARC_ADI provides this</span>
<span class="quote">&gt;&gt;&gt; in</span>
<span class="quote">&gt;&gt;&gt; its return value in the patch I sent.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; 2. Is TTE.mcd set for a given virtual address? PR_GET_SPARC_ADI_STATUS</span>
<span class="quote">&gt;&gt;&gt; provides this function in the patch I sent.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Setting and clearing version tags can be done entirely from userspace:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;          while (addr &lt; end) {</span>
<span class="quote">&gt;&gt;&gt;                  asm volatile(</span>
<span class="quote">&gt;&gt;&gt;                          &quot;stxa %1, [%0]ASI_MCD_PRIMARY\n\t&quot;</span>
<span class="quote">&gt;&gt;&gt;                          :</span>
<span class="quote">&gt;&gt;&gt;                          : &quot;r&quot; (addr), &quot;r&quot; (version));</span>
<span class="quote">&gt;&gt;&gt;                  addr += adicap.blksz;</span>
<span class="quote">&gt;&gt;&gt;          }</span>
<span class="quote">&gt;&gt;&gt; so I do not have to add any kernel code for tags.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Is the effect of that to change the tag associated with a page to</span>
<span class="quote">&gt;&gt; which the caller has write access?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; No, it changes the tag associated with the virtual address for the caller.</span>
<span class="quote">&gt; Physical page backing this virtual address is unaffected. Tag checking is</span>
<span class="quote">&gt; done for virtual addresses. The one restriction where physical address is</span>
<span class="quote">&gt; relevant is when two processes map the same physical page, they both have to</span>
<span class="quote">&gt; use the same tag for the virtual addresses that map on to the shared</span>
<span class="quote">&gt; physical pages.</span>

Slow down, please.  *Why* do the tags for two different VAs that map
to the same PA have to match?  What goes wrong if they don&#39;t, and why
is requiring them to be the same a good idea?
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I sense DoS issues in your future.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Are you concerned about DoS even if the tag is associated with virtual</span>
<span class="quote">&gt; address, not physical address?</span>

Yes, absolutely.

fd = open(&quot;/lib/ld.so&quot;);
mmap(fd)
stxa to write the tag

*boom*, presumably, because the tags apparently have to match for all mappings.

What data structure or structures changes when this stxa instruction happens?

--Andy
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41531">Andy Lutomirski</a> - March 7, 2016, 6:53 p.m.</div>
<pre class="content">
On Mon, Mar 7, 2016 at 10:39 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt; wrote:
<span class="quote">&gt; On 03/07/2016 11:12 AM, Dave Hansen wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On 03/07/2016 09:53 AM, Andy Lutomirski wrote:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Also, what am I missing?  Tying these tags to the physical page seems</span>
<span class="quote">&gt;&gt;&gt; like a poor design to me.  This seems really awkward to use.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Yeah, can you describe the structures that store these things?  Surely</span>
<span class="quote">&gt;&gt; the hardware has some kind of lookup tables for them and stores them in</span>
<span class="quote">&gt;&gt; memory _somewhere_.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Version tags are tied to virtual addresses, not physical pages.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Where exactly are the tags stored is part of processor architecture and I am</span>
<span class="quote">&gt; not privy to that. MMU stores these lookup tables somewhere and uses it to</span>
<span class="quote">&gt; authenticate access to virtual addresses. It really is irrelevant to kernel</span>
<span class="quote">&gt; how MMU implements access controls as long as we have access to the</span>
<span class="quote">&gt; knowledge of how to use it.</span>
<span class="quote">&gt;</span>

Can you translate this for people who don&#39;t know all the SPARC acronyms?

x86 has an upcoming feature called protection keys.  A page of virtual
memory has a protection key, which is a number from 0 through 16.  The
master copy is in the PTE, i.e. page table entry, which is a
software-managed data structure in memory and is exactly the thing
that Linux calls &quot;pte&quot;.  The processor can cache that value in the TLB
(translation lookaside buffer), which is a hardware cache that caches
PTEs.  On access to a page of virtual memory, the processor does a
certain calculation involving a new register called PKRU and the
protection key and may deny access.

Hopefully that description makes sense even to people completely
unfamiliar with x86.

Can you try something similar for SPARC?  So far I&#39;m lost, because
you&#39;ve said that the ADI tag is associated with a VA, but it has to
match for aliases, and you&#39;ve mentioned a bunch of acronyms, and I
have no clue what&#39;s going on.

--Andy
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=129">David Miller</a> - March 7, 2016, 7:06 p.m.</div>
<pre class="content">
<span class="from">From: Dave Hansen &lt;dave.hansen@intel.com&gt;</span>
Date: Mon, 7 Mar 2016 09:35:57 -0800
<span class="quote">
&gt; On 03/02/2016 12:39 PM, Khalid Aziz wrote:</span>
<span class="quote">&gt;&gt; +long enable_sparc_adi(unsigned long addr, unsigned long len)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	unsigned long end, pagemask;</span>
<span class="quote">&gt;&gt; +	int error;</span>
<span class="quote">&gt;&gt; +	struct vm_area_struct *vma, *vma2;</span>
<span class="quote">&gt;&gt; +	struct mm_struct *mm;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	if (!ADI_CAPABLE())</span>
<span class="quote">&gt;&gt; +		return -EINVAL;</span>
<span class="quote">&gt; ...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This whole thing with the VMA splitting and so forth looks pretty darn</span>
<span class="quote">&gt; arch-independent.  Are you sure you need that much arch-specific code</span>
<span class="quote">&gt; for it, or can you share more of the generic VMA management code?</span>

This is exactly what I have suggested to him, and he has agreed to pursue.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=129">David Miller</a> - March 7, 2016, 7:09 p.m.</div>
<pre class="content">
<span class="from">From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
Date: Mon, 7 Mar 2016 11:04:38 -0700
<span class="quote">
&gt; On 03/07/2016 09:56 AM, David Miller wrote:</span>
<span class="quote">&gt;&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt; Date: Mon, 7 Mar 2016 08:07:53 -0700</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; PR_GET_SPARC_ADICAPS</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Put this into a new ELF auxiliary vector entry via ARCH_DLINFO.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; So now all that&#39;s left is supposedly the TAG stuff, please explain</span>
<span class="quote">&gt;&gt; that to me so I can direct you to the correct existing interface to</span>
<span class="quote">&gt;&gt; provide that as well.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Really, try to avoid prtctl, it&#39;s poorly typed and almost worse than</span>
<span class="quote">&gt;&gt; ioctl().</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The two remaining operations I am looking at are:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 1. Is PSTATE.mcde bit set for the process? PR_SET_SPARC_ADI provides</span>
<span class="quote">&gt; this in its return value in the patch I sent.</span>

Unnecessary.  If any ADI mappings exist then mcde is set, otherwise it is
clear.  This is internal state and the application has no need to every
set nor query it.

It is implicit from the mprotect() calls the user makes to enable ADI
regions.
<span class="quote">
&gt; 2. Is TTE.mcd set for a given virtual address? PR_GET_SPARC_ADI_STATUS</span>
<span class="quote">&gt; provides this function in the patch I sent.</span>

Again, implied by the mprotect() calls.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=129">David Miller</a> - March 7, 2016, 7:16 p.m.</div>
<pre class="content">
<span class="from">From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
Date: Mon, 7 Mar 2016 11:24:54 -0700
<span class="quote">
&gt; Tags can be cleared by user by setting tag to 0. Tags are</span>
<span class="quote">&gt; automatically cleared by the hardware when the mapping for a virtual</span>
<span class="quote">&gt; address is removed from TSB (which is why swappable pages are a</span>
<span class="quote">&gt; problem), so kernel does not have to do it as part of clean up.</span>

You might be able to crib some bits for the Tag in the swp_entry_t, it&#39;s
64-bit and you can therefore steal bits from the offset field.

That way you&#39;ll have the ADI tag in the page tables, ready to re-install
at swapin time.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=129">David Miller</a> - March 7, 2016, 7:19 p.m.</div>
<pre class="content">
<span class="from">From: Andy Lutomirski &lt;luto@amacapital.net&gt;</span>
Date: Mon, 7 Mar 2016 10:49:57 -0800
<span class="quote">
&gt; What data structure or structures changes when this stxa instruction happens?</span>

An internal table, maintained by the CPU and/or hypervisor, and if in physical
addresses then in a region which is only accessible by the hypervisor.

The table is not accessible by the kernel at all via loads or stores.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=129">David Miller</a> - March 7, 2016, 7:22 p.m.</div>
<pre class="content">
<span class="from">From: Andy Lutomirski &lt;luto@amacapital.net&gt;</span>
Date: Mon, 7 Mar 2016 10:53:23 -0800
<span class="quote">
&gt; x86 has an upcoming feature called protection keys.  A page of virtual</span>
<span class="quote">&gt; memory has a protection key, which is a number from 0 through 16.  The</span>
<span class="quote">&gt; master copy is in the PTE, i.e. page table entry, which is a</span>
<span class="quote">&gt; software-managed data structure in memory and is exactly the thing</span>
<span class="quote">&gt; that Linux calls &quot;pte&quot;.  The processor can cache that value in the TLB</span>
<span class="quote">&gt; (translation lookaside buffer), which is a hardware cache that caches</span>
<span class="quote">&gt; PTEs.  On access to a page of virtual memory, the processor does a</span>
<span class="quote">&gt; certain calculation involving a new register called PKRU and the</span>
<span class="quote">&gt; protection key and may deny access.</span>

ADI is similar, except the &quot;keys&quot; (or &quot;tags&quot;) are stored externally
rather than in the PTEs.  A bit in the PTE is used to enable tag match
checking.

The tags live in an external table, which is populated by ASI store
instructions.  The location of the table is implementation specific,
it could be hypervisor or CPU managed, but if stored in memory it is
to a region of memory accessible only to the hypervisor at best.

Khalid, maybe you should share notes with the folks working on x86
protection keys.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 7, 2016, 7:44 p.m.</div>
<pre class="content">
On 03/07/2016 11:49 AM, Andy Lutomirski wrote:
<span class="quote">&gt; On Mon, Mar 7, 2016 at 10:22 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt; wrote:</span>
<span class="quote">&gt;&gt; No, it changes the tag associated with the virtual address for the caller.</span>
<span class="quote">&gt;&gt; Physical page backing this virtual address is unaffected. Tag checking is</span>
<span class="quote">&gt;&gt; done for virtual addresses. The one restriction where physical address is</span>
<span class="quote">&gt;&gt; relevant is when two processes map the same physical page, they both have to</span>
<span class="quote">&gt;&gt; use the same tag for the virtual addresses that map on to the shared</span>
<span class="quote">&gt;&gt; physical pages.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Slow down, please.  *Why* do the tags for two different VAs that map</span>
<span class="quote">&gt; to the same PA have to match?  What goes wrong if they don&#39;t, and why</span>
<span class="quote">&gt; is requiring them to be the same a good idea?</span>
<span class="quote">&gt;</span>

Consider this scenario:

1. Process A creates a shm and attaches to it.
2. Process A fills shm with data it wants to share with only known 
processes. It enables ADI and sets tags on the shm.
3. Hacker triggers something like stack overflow on process A, exec&#39;s a 
new rogue binary and manages to attach to this shm. MMU knows tags were 
set on the virtual address mapping to the physical pages hosting the 
shm. If MMU does not require the rogue process to set the exact same 
tags on its mapping of the same shm, rogue process has defeated the ADI 
protection easily.

Does this make sense?
<span class="quote">
&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; I sense DoS issues in your future.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Are you concerned about DoS even if the tag is associated with virtual</span>
<span class="quote">&gt;&gt; address, not physical address?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Yes, absolutely.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; fd = open(&quot;/lib/ld.so&quot;);</span>
<span class="quote">&gt; mmap(fd)</span>
<span class="quote">&gt; stxa to write the tag</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; *boom*, presumably, because the tags apparently have to match for all mappings.</span>
<span class="quote">&gt;</span>

A process can not just write version tags and make the file inaccessible 
to others. It takes three steps to enable ADI:

1. Set PSTATE.mcde for the process.
2. Set TTE.mcd on all PTEs for the virtual addresses ADI is being 
enabled on.
3. Set version tags.

Unless all three steps are taken, tag checking will not be done. stxa 
will fail unless step 2 is completed. In your example, the step of 
setting TTE.mcd will force sharing to stop for the process through 
change_protection(), right?

Thanks for asking these tough questions. These are very helpful in 
refining my implementation and avoiding silly bugs.

--
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 7, 2016, 7:46 p.m.</div>
<pre class="content">
On 03/07/2016 12:22 PM, David Miller wrote:
<span class="quote">&gt; Khalid, maybe you should share notes with the folks working on x86</span>
<span class="quote">&gt; protection keys.</span>
<span class="quote">&gt;</span>

Good idea. Sparc ADI feature is indeed similar to x86 protection keys 
sounds like.

Thanks,
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41531">Andy Lutomirski</a> - March 7, 2016, 7:54 p.m.</div>
<pre class="content">
On Mon, Mar 7, 2016 at 11:44 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt; wrote:
<span class="quote">&gt; On 03/07/2016 11:49 AM, Andy Lutomirski wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On Mon, Mar 7, 2016 at 10:22 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt; wrote:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; No, it changes the tag associated with the virtual address for the</span>
<span class="quote">&gt;&gt;&gt; caller.</span>
<span class="quote">&gt;&gt;&gt; Physical page backing this virtual address is unaffected. Tag checking is</span>
<span class="quote">&gt;&gt;&gt; done for virtual addresses. The one restriction where physical address is</span>
<span class="quote">&gt;&gt;&gt; relevant is when two processes map the same physical page, they both have</span>
<span class="quote">&gt;&gt;&gt; to</span>
<span class="quote">&gt;&gt;&gt; use the same tag for the virtual addresses that map on to the shared</span>
<span class="quote">&gt;&gt;&gt; physical pages.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Slow down, please.  *Why* do the tags for two different VAs that map</span>
<span class="quote">&gt;&gt; to the same PA have to match?  What goes wrong if they don&#39;t, and why</span>
<span class="quote">&gt;&gt; is requiring them to be the same a good idea?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Consider this scenario:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 1. Process A creates a shm and attaches to it.</span>
<span class="quote">&gt; 2. Process A fills shm with data it wants to share with only known</span>
<span class="quote">&gt; processes. It enables ADI and sets tags on the shm.</span>
<span class="quote">&gt; 3. Hacker triggers something like stack overflow on process A, exec&#39;s a new</span>
<span class="quote">&gt; rogue binary and manages to attach to this shm. MMU knows tags were set on</span>
<span class="quote">&gt; the virtual address mapping to the physical pages hosting the shm. If MMU</span>
<span class="quote">&gt; does not require the rogue process to set the exact same tags on its mapping</span>
<span class="quote">&gt; of the same shm, rogue process has defeated the ADI protection easily.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Does this make sense?</span>

This makes sense, but I still think the design is poor.  If the hacker
gets code execution, then they can trivially brute force the ADI bits.

Also, if this is the use case in mind, shouldn&#39;t the ADI bits bet set
on the file, not the mapping?  E.g. have an ioctl on the shmfs file
that sets its ADI bits?
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; I sense DoS issues in your future.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Are you concerned about DoS even if the tag is associated with virtual</span>
<span class="quote">&gt;&gt;&gt; address, not physical address?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Yes, absolutely.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; fd = open(&quot;/lib/ld.so&quot;);</span>
<span class="quote">&gt;&gt; mmap(fd)</span>
<span class="quote">&gt;&gt; stxa to write the tag</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; *boom*, presumably, because the tags apparently have to match for all</span>
<span class="quote">&gt;&gt; mappings.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; A process can not just write version tags and make the file inaccessible to</span>
<span class="quote">&gt; others. It takes three steps to enable ADI:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 1. Set PSTATE.mcde for the process.</span>
<span class="quote">&gt; 2. Set TTE.mcd on all PTEs for the virtual addresses ADI is being enabled</span>
<span class="quote">&gt; on.</span>
<span class="quote">&gt; 3. Set version tags.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Unless all three steps are taken, tag checking will not be done. stxa will</span>
<span class="quote">&gt; fail unless step 2 is completed. In your example, the step of setting</span>
<span class="quote">&gt; TTE.mcd will force sharing to stop for the process through</span>
<span class="quote">&gt; change_protection(), right?</span>

OK, that makes some sense.

Can a shared page ever have TTE.mcd set?  How does one share a page,
even deliberately, between two processes with cmd set?

--Andy
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 7, 2016, 8:41 p.m.</div>
<pre class="content">
On 03/07/2016 12:54 PM, Andy Lutomirski wrote:
<span class="quote">&gt; On Mon, Mar 7, 2016 at 11:44 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt; wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Consider this scenario:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; 1. Process A creates a shm and attaches to it.</span>
<span class="quote">&gt;&gt; 2. Process A fills shm with data it wants to share with only known</span>
<span class="quote">&gt;&gt; processes. It enables ADI and sets tags on the shm.</span>
<span class="quote">&gt;&gt; 3. Hacker triggers something like stack overflow on process A, exec&#39;s a new</span>
<span class="quote">&gt;&gt; rogue binary and manages to attach to this shm. MMU knows tags were set on</span>
<span class="quote">&gt;&gt; the virtual address mapping to the physical pages hosting the shm. If MMU</span>
<span class="quote">&gt;&gt; does not require the rogue process to set the exact same tags on its mapping</span>
<span class="quote">&gt;&gt; of the same shm, rogue process has defeated the ADI protection easily.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Does this make sense?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This makes sense, but I still think the design is poor.  If the hacker</span>
<span class="quote">&gt; gets code execution, then they can trivially brute force the ADI bits.</span>

True, with only 16 possible tag values (actually only 14 since 0 and 15 
are reserved values), it is entirely possible to brute force the ADI 
tag. ADI is just another tool one can use to mitigate attacks. A process 
that accesses an ADI enabled memory with invalid tag gets a SIGBUS and 
is terminated. This can trigger alerts on the system and system policies 
could block the next attack. If a daemon is compromised and is forced to 
hand out data from memory it should not be reading (similar to 
heartbleed bug). the daemon itself is terminated with SIGBUS which 
should be enough to alert system admins. A rotating set of tags would 
reduce the risk from brute force attacks. Tags are set on cacheline 
(which is 64 bytes on M7). A single regular sized page can have 128 sets 
of tags. Allowing for 14 possible values for each set, that is a lot of 
possible combinations of tags making it very hard to brute force tags 
for more than a cacheline at a time. There are probably other better 
ways to make the tags harder to crack.
<span class="quote">
&gt;</span>
<span class="quote">&gt; Also, if this is the use case in mind, shouldn&#39;t the ADI bits bet set</span>
<span class="quote">&gt; on the file, not the mapping?  E.g. have an ioctl on the shmfs file</span>
<span class="quote">&gt; that sets its ADI bits?</span>

Shared data may not always be backed by a file. My understanding is one 
of the use cases is for in-memory databases. This shared space could 
also be used to hand off transactions in flight to other processes. 
These transactions in flight would not be backed by a file. Some of 
these use cases might not use shmfs even. Setting ADI bits at virtual 
address level catches all these cases since what backs the tagged 
virtual address can be anything - a mapped file, mmio space, just plain 
chunk of memory.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; A process can not just write version tags and make the file inaccessible to</span>
<span class="quote">&gt;&gt; others. It takes three steps to enable ADI:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; 1. Set PSTATE.mcde for the process.</span>
<span class="quote">&gt;&gt; 2. Set TTE.mcd on all PTEs for the virtual addresses ADI is being enabled</span>
<span class="quote">&gt;&gt; on.</span>
<span class="quote">&gt;&gt; 3. Set version tags.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Unless all three steps are taken, tag checking will not be done. stxa will</span>
<span class="quote">&gt;&gt; fail unless step 2 is completed. In your example, the step of setting</span>
<span class="quote">&gt;&gt; TTE.mcd will force sharing to stop for the process through</span>
<span class="quote">&gt;&gt; change_protection(), right?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; OK, that makes some sense.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Can a shared page ever have TTE.mcd set?  How does one share a page,</span>
<span class="quote">&gt; even deliberately, between two processes with cmd set?</span>

For two processes to share a page, their VMAs have to be identical as I 
understand it. If one process has TTE.mcd set (which means vma-&gt;vm_flags 
is different) while the other does not, they do not share a page.

Thanks,
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=129">David Miller</a> - March 7, 2016, 8:58 p.m.</div>
<pre class="content">
<span class="from">From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
Date: Mon, 7 Mar 2016 13:41:39 -0700
<span class="quote">
&gt; Shared data may not always be backed by a file. My understanding is</span>
<span class="quote">&gt; one of the use cases is for in-memory databases. This shared space</span>
<span class="quote">&gt; could also be used to hand off transactions in flight to other</span>
<span class="quote">&gt; processes. These transactions in flight would not be backed by a</span>
<span class="quote">&gt; file. Some of these use cases might not use shmfs even. Setting ADI</span>
<span class="quote">&gt; bits at virtual address level catches all these cases since what backs</span>
<span class="quote">&gt; the tagged virtual address can be anything - a mapped file, mmio</span>
<span class="quote">&gt; space, just plain chunk of memory.</span>

Frankly the most interesting use case to me is simply finding bugs
and memory scribbles, and for that we&#39;re want to be able to ADI
arbitrary memory returned from malloc() and friends.

I personally see ADI more as a debugging than a security feature,
but that&#39;s just my view.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41531">Andy Lutomirski</a> - March 7, 2016, 9:02 p.m.</div>
<pre class="content">
On Mon, Mar 7, 2016 at 12:58 PM, David Miller &lt;davem@davemloft.net&gt; wrote:
<span class="quote">&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt; Date: Mon, 7 Mar 2016 13:41:39 -0700</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; Shared data may not always be backed by a file. My understanding is</span>
<span class="quote">&gt;&gt; one of the use cases is for in-memory databases. This shared space</span>
<span class="quote">&gt;&gt; could also be used to hand off transactions in flight to other</span>
<span class="quote">&gt;&gt; processes. These transactions in flight would not be backed by a</span>
<span class="quote">&gt;&gt; file. Some of these use cases might not use shmfs even. Setting ADI</span>
<span class="quote">&gt;&gt; bits at virtual address level catches all these cases since what backs</span>
<span class="quote">&gt;&gt; the tagged virtual address can be anything - a mapped file, mmio</span>
<span class="quote">&gt;&gt; space, just plain chunk of memory.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Frankly the most interesting use case to me is simply finding bugs</span>
<span class="quote">&gt; and memory scribbles, and for that we&#39;re want to be able to ADI</span>
<span class="quote">&gt; arbitrary memory returned from malloc() and friends.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I personally see ADI more as a debugging than a security feature,</span>
<span class="quote">&gt; but that&#39;s just my view.</span>

The thing that seems awkward to me is that setting, say, ADI=1 seems
almost equivalent to remapping the memory up to 0x10...whatever, and
the latter is a heck of a lot simpler to think about.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 7, 2016, 9:06 p.m.</div>
<pre class="content">
On 03/07/2016 10:46 AM, Dave Hansen wrote:
<span class="quote">&gt; On 03/07/2016 08:06 AM, Khalid Aziz wrote:</span>
<span class="quote">&gt;&gt; Top 4-bits of sparc64 virtual address are used for version tag only when</span>
<span class="quote">&gt;&gt; a process has its PSTATE.mcde bit set and it is accessing a memory</span>
<span class="quote">&gt;&gt; region that has ADI enabled on it (TTE.mcd set) and a version tag was</span>
<span class="quote">&gt;&gt; set on the virtual address being accessed. These 4-bits retain their</span>
<span class="quote">&gt;&gt; original semantics in all other cases.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; OK, so this effectively reduces the address space of a process using the</span>
<span class="quote">&gt; feature.  Do we need to do anything explicit to keep an app from using</span>
<span class="quote">&gt; that address space?  Do we make sure the kernel doesn&#39;t place VMAs</span>
<span class="quote">&gt; there?  Do we respect mmap() hints that try to place memory there?</span>
<span class="quote">&gt;</span>

Good questions. Isn&#39;t set of valid VAs already constrained by VA_BITS 
(set to 44 in arch/sparc/include/asm/processor_64.h)? As I see it we are 
already not using the top 4 bits. Please correct me if I am wrong.

Thanks,
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 7, 2016, 9:09 p.m.</div>
<pre class="content">
On 03/07/2016 01:58 PM, David Miller wrote:
<span class="quote">&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt; Date: Mon, 7 Mar 2016 13:41:39 -0700</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; Shared data may not always be backed by a file. My understanding is</span>
<span class="quote">&gt;&gt; one of the use cases is for in-memory databases. This shared space</span>
<span class="quote">&gt;&gt; could also be used to hand off transactions in flight to other</span>
<span class="quote">&gt;&gt; processes. These transactions in flight would not be backed by a</span>
<span class="quote">&gt;&gt; file. Some of these use cases might not use shmfs even. Setting ADI</span>
<span class="quote">&gt;&gt; bits at virtual address level catches all these cases since what backs</span>
<span class="quote">&gt;&gt; the tagged virtual address can be anything - a mapped file, mmio</span>
<span class="quote">&gt;&gt; space, just plain chunk of memory.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Frankly the most interesting use case to me is simply finding bugs</span>
<span class="quote">&gt; and memory scribbles, and for that we&#39;re want to be able to ADI</span>
<span class="quote">&gt; arbitrary memory returned from malloc() and friends.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I personally see ADI more as a debugging than a security feature,</span>
<span class="quote">&gt; but that&#39;s just my view.</span>
<span class="quote">&gt;</span>

I think that is a very strong use case. It can be a very effective tool 
for debugging especially when it comes to catching wild writes.

--
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 7, 2016, 9:27 p.m.</div>
<pre class="content">
On 03/07/2016 12:09 PM, David Miller wrote:
<span class="quote">&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt; Date: Mon, 7 Mar 2016 11:04:38 -0700</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; On 03/07/2016 09:56 AM, David Miller wrote:</span>
<span class="quote">&gt;&gt;&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt;&gt; Date: Mon, 7 Mar 2016 08:07:53 -0700</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; PR_GET_SPARC_ADICAPS</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Put this into a new ELF auxiliary vector entry via ARCH_DLINFO.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; So now all that&#39;s left is supposedly the TAG stuff, please explain</span>
<span class="quote">&gt;&gt;&gt; that to me so I can direct you to the correct existing interface to</span>
<span class="quote">&gt;&gt;&gt; provide that as well.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Really, try to avoid prtctl, it&#39;s poorly typed and almost worse than</span>
<span class="quote">&gt;&gt;&gt; ioctl().</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The two remaining operations I am looking at are:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; 1. Is PSTATE.mcde bit set for the process? PR_SET_SPARC_ADI provides</span>
<span class="quote">&gt;&gt; this in its return value in the patch I sent.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Unnecessary.  If any ADI mappings exist then mcde is set, otherwise it is</span>
<span class="quote">&gt; clear.  This is internal state and the application has no need to every</span>
<span class="quote">&gt; set nor query it.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; It is implicit from the mprotect() calls the user makes to enable ADI</span>
<span class="quote">&gt; regions.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; 2. Is TTE.mcd set for a given virtual address? PR_GET_SPARC_ADI_STATUS</span>
<span class="quote">&gt;&gt; provides this function in the patch I sent.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Again, implied by the mprotect() calls.</span>
<span class="quote">&gt;</span>

Hi Dave,

I agree with your point of view. PSTATE.mcde and TTE.mcd are set in 
response to request from userspace. If userspace asked for them to be 
set, they already know but it was the database guys that asked for these 
two functions and they are the primary customers for the ADI feature. I 
am not crazy about this idea since this extends the mprotect API even 
further but would you consider using the return value from mprotect to 
indicate if PSTATE.mcde or TTE.mcd were already set on the given address?

Thanks,
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 7, 2016, 9:33 p.m.</div>
<pre class="content">
On 03/07/2016 12:16 PM, David Miller wrote:
<span class="quote">&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt; Date: Mon, 7 Mar 2016 11:24:54 -0700</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; Tags can be cleared by user by setting tag to 0. Tags are</span>
<span class="quote">&gt;&gt; automatically cleared by the hardware when the mapping for a virtual</span>
<span class="quote">&gt;&gt; address is removed from TSB (which is why swappable pages are a</span>
<span class="quote">&gt;&gt; problem), so kernel does not have to do it as part of clean up.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; You might be able to crib some bits for the Tag in the swp_entry_t, it&#39;s</span>
<span class="quote">&gt; 64-bit and you can therefore steal bits from the offset field.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; That way you&#39;ll have the ADI tag in the page tables, ready to re-install</span>
<span class="quote">&gt; at swapin time.</span>
<span class="quote">&gt;</span>

That is a possibility but limited in scope. An address range covered by 
a single TTE can have large number of tags. Version tags are set on 
cacheline. In extreme case, one could set a tag for each set of 64-bytes 
in a page. Also tags are set completely in userspace and no transition 
occurs to kernel space, so kernel has no idea of what tags have been 
set. I have not found a way to query the MMU on tags.

I will think some more about it.

Thanks,
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=129">David Miller</a> - March 7, 2016, 9:34 p.m.</div>
<pre class="content">
<span class="from">From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
Date: Mon, 7 Mar 2016 14:27:09 -0700
<span class="quote">
&gt; I agree with your point of view. PSTATE.mcde and TTE.mcd are set in</span>
<span class="quote">&gt; response to request from userspace. If userspace asked for them to be</span>
<span class="quote">&gt; set, they already know but it was the database guys that asked for</span>
<span class="quote">&gt; these two functions and they are the primary customers for the ADI</span>
<span class="quote">&gt; feature. I am not crazy about this idea since this extends the</span>
<span class="quote">&gt; mprotect API even further but would you consider using the return</span>
<span class="quote">&gt; value from mprotect to indicate if PSTATE.mcde or TTE.mcd were already</span>
<span class="quote">&gt; set on the given address?</span>

Well, that&#39;s the idea.

If the mprotect using MAP_ADI or whatever succeeds, then ADI is
enabled.

Users can thus also pass MAP_ADI as a flag to mmap() to get ADI
protection from the very beginning.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=129">David Miller</a> - March 7, 2016, 9:38 p.m.</div>
<pre class="content">
<span class="from">From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
Date: Mon, 7 Mar 2016 14:33:56 -0700
<span class="quote">
&gt; On 03/07/2016 12:16 PM, David Miller wrote:</span>
<span class="quote">&gt;&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt; Date: Mon, 7 Mar 2016 11:24:54 -0700</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Tags can be cleared by user by setting tag to 0. Tags are</span>
<span class="quote">&gt;&gt;&gt; automatically cleared by the hardware when the mapping for a virtual</span>
<span class="quote">&gt;&gt;&gt; address is removed from TSB (which is why swappable pages are a</span>
<span class="quote">&gt;&gt;&gt; problem), so kernel does not have to do it as part of clean up.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; You might be able to crib some bits for the Tag in the swp_entry_t,</span>
<span class="quote">&gt;&gt; it&#39;s</span>
<span class="quote">&gt;&gt; 64-bit and you can therefore steal bits from the offset field.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; That way you&#39;ll have the ADI tag in the page tables, ready to</span>
<span class="quote">&gt;&gt; re-install</span>
<span class="quote">&gt;&gt; at swapin time.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; That is a possibility but limited in scope. An address range covered</span>
<span class="quote">&gt; by a single TTE can have large number of tags. Version tags are set on</span>
<span class="quote">&gt; cacheline. In extreme case, one could set a tag for each set of</span>
<span class="quote">&gt; 64-bytes in a page. Also tags are set completely in userspace and no</span>
<span class="quote">&gt; transition occurs to kernel space, so kernel has no idea of what tags</span>
<span class="quote">&gt; have been set. I have not found a way to query the MMU on tags.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I will think some more about it.</span>

That would mean that ADI is impossible to use for swappable memory.

...

If that&#39;s true I&#39;m extremely disappointed that they devoted so much
silicon and engineering to this feature yet didn&#39;t take that one
critical step to make it generally useful. :(

We could have a way to do this via the kernel, wherein the user has a
contract with us.  Basically we have a call to pass the Tags (what
granularity to use for this is a design point, pages, cache lines,
etc.)  into the kernel and the user agrees not to change them behind
the kernel&#39;s back.

In return the kernel agrees to restore the tags upon swapin.

So we could support something for swappable pages, it would just be
more work.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 7, 2016, 10:30 p.m.</div>
<pre class="content">
On 03/07/2016 02:34 PM, David Miller wrote:
<span class="quote">&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt; Date: Mon, 7 Mar 2016 14:27:09 -0700</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; I agree with your point of view. PSTATE.mcde and TTE.mcd are set in</span>
<span class="quote">&gt;&gt; response to request from userspace. If userspace asked for them to be</span>
<span class="quote">&gt;&gt; set, they already know but it was the database guys that asked for</span>
<span class="quote">&gt;&gt; these two functions and they are the primary customers for the ADI</span>
<span class="quote">&gt;&gt; feature. I am not crazy about this idea since this extends the</span>
<span class="quote">&gt;&gt; mprotect API even further but would you consider using the return</span>
<span class="quote">&gt;&gt; value from mprotect to indicate if PSTATE.mcde or TTE.mcd were already</span>
<span class="quote">&gt;&gt; set on the given address?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Well, that&#39;s the idea.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; If the mprotect using MAP_ADI or whatever succeeds, then ADI is</span>
<span class="quote">&gt; enabled.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Users can thus also pass MAP_ADI as a flag to mmap() to get ADI</span>
<span class="quote">&gt; protection from the very beginning.</span>
<span class="quote">&gt;</span>

MAP_ADI has been sitting in my backlog for some time. Looks like you 
just raised its priority ;)

--
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=64071">Dave Hansen</a> - March 7, 2016, 10:40 p.m.</div>
<pre class="content">
On 03/07/2016 11:46 AM, Khalid Aziz wrote:
<span class="quote">&gt; On 03/07/2016 12:22 PM, David Miller wrote:</span>
<span class="quote">&gt;&gt; Khalid, maybe you should share notes with the folks working on x86</span>
<span class="quote">&gt;&gt; protection keys.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Good idea. Sparc ADI feature is indeed similar to x86 protection keys</span>
<span class="quote">&gt; sounds like.</span>

There are definitely some similarities.  But protection keys doesn&#39;t
have any additional tables in which to keep metadata.  It keeps all of
its data in the page tables.  It also doesn&#39;t have an impact on the
virtual address layout.

But, it does have metadata to store in the VMA, has a special
siginfo-&gt;si_code, and it uses mprotect() (although a new pkey_mprotect()
variant that takes an extra argument).

Protection Keys are described a bit more here:
<span class="quote">
&gt; http://git.kernel.org/cgit/linux/kernel/git/daveh/x86-pkeys.git/tree/Documentation/x86/protection-keys.txt?h=pkeys-v025&amp;id=1b5b8a8836de8eb667027178b4820665dea5a038</span>

MPX is another Intel feature separate from protection keys, but *it* has
some tables that it keep its metadata memory and special special
instructions to move metadata in and out of it.  It also has a prctl()
to enable/disable kernel assistance for the feature.  Unlike ADI, the
tables are exposed (and accessible) to user applications in normal
application memory.

MPX&#39;s documentation is here:
<span class="quote">
&gt; http://git.kernel.org/cgit/linux/kernel/git/daveh/x86-pkeys.git/tree/Documentation/x86/intel_mpx.txt</span>

Overall, I&#39;m not seeing much overlap at all between the features, honestly.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=157521">Rob Gardner</a> - March 7, 2016, 11:12 p.m.</div>
<pre class="content">
On 03/07/2016 01:33 PM, Khalid Aziz wrote:
<span class="quote">&gt;</span>
<span class="quote">&gt; That is a possibility but limited in scope. An address range covered </span>
<span class="quote">&gt; by a single TTE can have large number of tags. Version tags are set on </span>
<span class="quote">&gt; cacheline. In extreme case, one could set a tag for each set of </span>
<span class="quote">&gt; 64-bytes in a page. Also tags are set completely in userspace and no </span>
<span class="quote">&gt; transition occurs to kernel space, so kernel has no idea of what tags </span>
<span class="quote">&gt; have been set.</span>

   ...
<span class="quote">&gt; I have not found a way to query the MMU on tags.</span>
<span class="quote">&gt;</span>

To query the tag for a cache line, you just read it back with ldxa and 
ASI_MCD_PRIMARY (ie, asi 0x90), basically the same way you stored the 
tag in the first place.

Rob
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=157521">Rob Gardner</a> - March 7, 2016, 11:13 p.m.</div>
<pre class="content">
On 03/07/2016 01:38 PM, David Miller wrote:
<span class="quote">&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt; Date: Mon, 7 Mar 2016 14:33:56 -0700</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; On 03/07/2016 12:16 PM, David Miller wrote:</span>
<span class="quote">&gt;&gt;&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt;&gt; Date: Mon, 7 Mar 2016 11:24:54 -0700</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Tags can be cleared by user by setting tag to 0. Tags are</span>
<span class="quote">&gt;&gt;&gt;&gt; automatically cleared by the hardware when the mapping for a virtual</span>
<span class="quote">&gt;&gt;&gt;&gt; address is removed from TSB (which is why swappable pages are a</span>
<span class="quote">&gt;&gt;&gt;&gt; problem), so kernel does not have to do it as part of clean up.</span>
<span class="quote">&gt;&gt;&gt; You might be able to crib some bits for the Tag in the swp_entry_t,</span>
<span class="quote">&gt;&gt;&gt; it&#39;s</span>
<span class="quote">&gt;&gt;&gt; 64-bit and you can therefore steal bits from the offset field.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; That way you&#39;ll have the ADI tag in the page tables, ready to</span>
<span class="quote">&gt;&gt;&gt; re-install</span>
<span class="quote">&gt;&gt;&gt; at swapin time.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt; That is a possibility but limited in scope. An address range covered</span>
<span class="quote">&gt;&gt; by a single TTE can have large number of tags. Version tags are set on</span>
<span class="quote">&gt;&gt; cacheline. In extreme case, one could set a tag for each set of</span>
<span class="quote">&gt;&gt; 64-bytes in a page. Also tags are set completely in userspace and no</span>
<span class="quote">&gt;&gt; transition occurs to kernel space, so kernel has no idea of what tags</span>
<span class="quote">&gt;&gt; have been set. I have not found a way to query the MMU on tags.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I will think some more about it.</span>
<span class="quote">&gt; That would mean that ADI is impossible to use for swappable memory.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; ...</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; If that&#39;s true I&#39;m extremely disappointed that they devoted so much</span>
<span class="quote">&gt; silicon and engineering to this feature yet didn&#39;t take that one</span>
<span class="quote">&gt; critical step to make it generally useful. :(</span>

You can easily read ADI tags with a simple ldxa #ASI_MCD_PRIMARY 
instruction.

Rob
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 7, 2016, 11:27 p.m.</div>
<pre class="content">
On 03/07/2016 04:12 PM, Rob Gardner wrote:
<span class="quote">&gt; On 03/07/2016 01:33 PM, Khalid Aziz wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; That is a possibility but limited in scope. An address range covered</span>
<span class="quote">&gt;&gt; by a single TTE can have large number of tags. Version tags are set on</span>
<span class="quote">&gt;&gt; cacheline. In extreme case, one could set a tag for each set of</span>
<span class="quote">&gt;&gt; 64-bytes in a page. Also tags are set completely in userspace and no</span>
<span class="quote">&gt;&gt; transition occurs to kernel space, so kernel has no idea of what tags</span>
<span class="quote">&gt;&gt; have been set.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;    ...</span>
<span class="quote">&gt;&gt; I have not found a way to query the MMU on tags.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; To query the tag for a cache line, you just read it back with ldxa and</span>
<span class="quote">&gt; ASI_MCD_PRIMARY (ie, asi 0x90), basically the same way you stored the</span>
<span class="quote">&gt; tag in the first place.</span>
<span class="quote">&gt;</span>

Thanks, Rob. I just saw it while reading through the manual.

--
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=157521">Rob Gardner</a> - March 7, 2016, 11:32 p.m.</div>
<pre class="content">
On 03/07/2016 10:24 AM, Khalid Aziz wrote:
<span class="quote">&gt;</span>
<span class="quote">&gt; Tags can be cleared by user by setting tag to 0. Tags are </span>
<span class="quote">&gt; automatically cleared by the hardware when the mapping for a virtual </span>
<span class="quote">&gt; address is removed from TSB (which is why swappable pages are a </span>
<span class="quote">&gt; problem), so kernel does not have to do it as part of clean up.</span>
<span class="quote">&gt;</span>

I don&#39;t understand this. The hardware isn&#39;t involved  when a mapping for 
a virtual address is removed from the TSB, so how could it automatically 
clear tags?

Rob
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=157571">James Morris</a> - March 7, 2016, 11:34 p.m.</div>
<pre class="content">
On 03/08/2016 07:58 AM, David Miller wrote:
<span class="quote">&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt; Date: Mon, 7 Mar 2016 13:41:39 -0700</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; Shared data may not always be backed by a file. My understanding is</span>
<span class="quote">&gt;&gt; one of the use cases is for in-memory databases. This shared space</span>
<span class="quote">&gt;&gt; could also be used to hand off transactions in flight to other</span>
<span class="quote">&gt;&gt; processes. These transactions in flight would not be backed by a</span>
<span class="quote">&gt;&gt; file. Some of these use cases might not use shmfs even. Setting ADI</span>
<span class="quote">&gt;&gt; bits at virtual address level catches all these cases since what backs</span>
<span class="quote">&gt;&gt; the tagged virtual address can be anything - a mapped file, mmio</span>
<span class="quote">&gt;&gt; space, just plain chunk of memory.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Frankly the most interesting use case to me is simply finding bugs</span>
<span class="quote">&gt; and memory scribbles, and for that we&#39;re want to be able to ADI</span>
<span class="quote">&gt; arbitrary memory returned from malloc() and friends.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I personally see ADI more as a debugging than a security feature,</span>
<span class="quote">&gt; but that&#39;s just my view.</span>

This is certainly a major use of the feature. The Solaris folks have 
made some interesting use of it here:

https://docs.oracle.com/cd/E37069_01/html/E37085/gphwb.html
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=157571">James Morris</a> - March 7, 2016, 11:48 p.m.</div>
<pre class="content">
On 03/08/2016 06:54 AM, Andy Lutomirski wrote:
<span class="quote">&gt;</span>
<span class="quote">&gt; This makes sense, but I still think the design is poor.  If the hacker</span>
<span class="quote">&gt; gets code execution, then they can trivially brute force the ADI bits.</span>
<span class="quote">&gt;</span>

ADI in this scenario is intended to prevent the attacker from gaining 
code execution in the first place.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 8, 2016, 12:21 a.m.</div>
<pre class="content">
On 03/07/2016 12:16 PM, David Miller wrote:
<span class="quote">&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt; Date: Mon, 7 Mar 2016 11:24:54 -0700</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; Tags can be cleared by user by setting tag to 0. Tags are</span>
<span class="quote">&gt;&gt; automatically cleared by the hardware when the mapping for a virtual</span>
<span class="quote">&gt;&gt; address is removed from TSB (which is why swappable pages are a</span>
<span class="quote">&gt;&gt; problem), so kernel does not have to do it as part of clean up.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; You might be able to crib some bits for the Tag in the swp_entry_t, it&#39;s</span>
<span class="quote">&gt; 64-bit and you can therefore steal bits from the offset field.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; That way you&#39;ll have the ADI tag in the page tables, ready to re-install</span>
<span class="quote">&gt; at swapin time.</span>
<span class="quote">&gt;</span>

Hi Dave,

Can we enable ADI support for swappable pages in a subsequent update 
after the core functionality is stable on mlock&#39;d pages?

Thanks,
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=157521">Rob Gardner</a> - March 8, 2016, 1:31 a.m.</div>
<pre class="content">
On 03/07/2016 10:39 AM, Khalid Aziz wrote:
<span class="quote">&gt; On 03/07/2016 11:12 AM, Dave Hansen wrote:</span>
<span class="quote">&gt;&gt; On 03/07/2016 09:53 AM, Andy Lutomirski wrote:</span>
<span class="quote">&gt;&gt;&gt; Also, what am I missing?  Tying these tags to the physical page seems</span>
<span class="quote">&gt;&gt;&gt; like a poor design to me.  This seems really awkward to use.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Yeah, can you describe the structures that store these things? Surely</span>
<span class="quote">&gt;&gt; the hardware has some kind of lookup tables for them and stores them in</span>
<span class="quote">&gt;&gt; memory _somewhere_.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Version tags are tied to virtual addresses, not physical pages.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Where exactly are the tags stored is part of processor architecture </span>
<span class="quote">&gt; and I am not privy to that. MMU stores these lookup tables somewhere </span>
<span class="quote">&gt; and uses it to authenticate access to virtual addresses. It really is </span>
<span class="quote">&gt; irrelevant to kernel how MMU implements access controls as long as we </span>
<span class="quote">&gt; have access to the knowledge of how to use it.</span>

The tags are stored in physical memory, and you can write a tag directly 
to that memory via stxa with ASI_MCD_REAL and completely bypass the MMU. 
When you do that, the tag will still be seen by any virtual address that 
maps to that physical address.

Rob
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=129">David Miller</a> - March 8, 2016, 4:13 a.m.</div>
<pre class="content">
<span class="from">From: Rob Gardner &lt;rob.gardner@oracle.com&gt;</span>
Date: Mon, 7 Mar 2016 15:13:31 -0800
<span class="quote">
&gt; You can easily read ADI tags with a simple ldxa #ASI_MCD_PRIMARY</span>
<span class="quote">&gt; instruction.</span>

Awesome!
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=129">David Miller</a> - March 8, 2016, 4:24 a.m.</div>
<pre class="content">
<span class="from">From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
Date: Mon, 7 Mar 2016 17:21:05 -0700
<span class="quote">
&gt; Can we enable ADI support for swappable pages in a subsequent update</span>
<span class="quote">&gt; after the core functionality is stable on mlock&#39;d pages?</span>

I already said no.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=157571">James Morris</a> - March 8, 2016, 9:33 a.m.</div>
<pre class="content">
On 03/08/2016 10:48 AM, James Morris wrote:
<span class="quote">&gt; On 03/08/2016 06:54 AM, Andy Lutomirski wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This makes sense, but I still think the design is poor.  If the hacker</span>
<span class="quote">&gt;&gt; gets code execution, then they can trivially brute force the ADI bits.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; ADI in this scenario is intended to prevent the attacker from gaining</span>
<span class="quote">&gt; code execution in the first place.</span>

Here&#39;s some more background from Enrico Perla (who literally wrote the 
book on kernel exploitation):

https://blogs.oracle.com/enrico/entry/hardening_allocators_with_adi

Probably the most significant advantage from a security point of view is 
the ability to eliminate an entire class of vulnerability: adjacent heap 
overflows, as discussed above, where, for example, adjacent heap objects 
are tagged differently.  Classic linear buffer overflows can be eliminated.

As Kees Cook outlined at the 2015 kernel summit, it&#39;s best to mitigate 
classes of vulnerabilities rather than patch each instance:

https://outflux.net/slides/2011/defcon/kernel-exploitation.pdf

The Linux ADI implementation is currently very rudimentary, and we 
definitely welcome continued feedback from the community and ideas as it 
evolves.

- James
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=129">David Miller</a> - March 8, 2016, 7:57 p.m.</div>
<pre class="content">
<span class="from">From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
Date: Mon, 7 Mar 2016 14:06:43 -0700
<span class="quote">
&gt; Good questions. Isn&#39;t set of valid VAs already constrained by VA_BITS</span>
<span class="quote">&gt; (set to 44 in arch/sparc/include/asm/processor_64.h)? As I see it we</span>
<span class="quote">&gt; are already not using the top 4 bits. Please correct me if I am wrong.</span>

Another limiting constraint is the number of address bits coverable by
the 4-level page tables we use.  And this is sign extended so we have
a top-half and a bottom-half with a &quot;hole&quot; in the center of the VA
space.

I want some clarification on the top bits during ADI accesses.

If ADI is enabled, then the top bits of the virtual address are
intepreted as tag bits.  Once &quot;verified&quot; with the ADI settings, what
happense to these tag bits?  Are they dropped from the virtual address
before being passed down the TLB et al. for translations?

If not, then this means you have to map ADI memory to the correct
location so that the tags match up.

And if that&#39;s the case, if you really wanted to mix tags within a
single page, you&#39;d have to map that page several times, once for each
and every cacheline granular tag you&#39;d like to use within that page.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 8, 2016, 8:16 p.m.</div>
<pre class="content">
On 03/08/2016 12:57 PM, David Miller wrote:
<span class="quote">&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt; Date: Mon, 7 Mar 2016 14:06:43 -0700</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; Good questions. Isn&#39;t set of valid VAs already constrained by VA_BITS</span>
<span class="quote">&gt;&gt; (set to 44 in arch/sparc/include/asm/processor_64.h)? As I see it we</span>
<span class="quote">&gt;&gt; are already not using the top 4 bits. Please correct me if I am wrong.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Another limiting constraint is the number of address bits coverable by</span>
<span class="quote">&gt; the 4-level page tables we use.  And this is sign extended so we have</span>
<span class="quote">&gt; a top-half and a bottom-half with a &quot;hole&quot; in the center of the VA</span>
<span class="quote">&gt; space.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I want some clarification on the top bits during ADI accesses.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; If ADI is enabled, then the top bits of the virtual address are</span>
<span class="quote">&gt; intepreted as tag bits.  Once &quot;verified&quot; with the ADI settings, what</span>
<span class="quote">&gt; happense to these tag bits?  Are they dropped from the virtual address</span>
<span class="quote">&gt; before being passed down the TLB et al. for translations?</span>

Bits 63-60 (tag bits) are dropped from the virtual address before being 
passed down the TLB for translation when PSTATE.mcde = 1.

--
Khalid
<span class="quote">
&gt;</span>
<span class="quote">&gt; If not, then this means you have to map ADI memory to the correct</span>
<span class="quote">&gt; location so that the tags match up.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; And if that&#39;s the case, if you really wanted to mix tags within a</span>
<span class="quote">&gt; single page, you&#39;d have to map that page several times, once for each</span>
<span class="quote">&gt; and every cacheline granular tag you&#39;d like to use within that page.</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=129">David Miller</a> - March 8, 2016, 8:27 p.m.</div>
<pre class="content">
<span class="from">From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
Date: Tue, 8 Mar 2016 13:16:11 -0700
<span class="quote">
&gt; On 03/08/2016 12:57 PM, David Miller wrote:</span>
<span class="quote">&gt;&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt; Date: Mon, 7 Mar 2016 14:06:43 -0700</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Good questions. Isn&#39;t set of valid VAs already constrained by VA_BITS</span>
<span class="quote">&gt;&gt;&gt; (set to 44 in arch/sparc/include/asm/processor_64.h)? As I see it we</span>
<span class="quote">&gt;&gt;&gt; are already not using the top 4 bits. Please correct me if I am wrong.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Another limiting constraint is the number of address bits coverable by</span>
<span class="quote">&gt;&gt; the 4-level page tables we use.  And this is sign extended so we have</span>
<span class="quote">&gt;&gt; a top-half and a bottom-half with a &quot;hole&quot; in the center of the VA</span>
<span class="quote">&gt;&gt; space.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I want some clarification on the top bits during ADI accesses.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; If ADI is enabled, then the top bits of the virtual address are</span>
<span class="quote">&gt;&gt; intepreted as tag bits.  Once &quot;verified&quot; with the ADI settings, what</span>
<span class="quote">&gt;&gt; happense to these tag bits?  Are they dropped from the virtual address</span>
<span class="quote">&gt;&gt; before being passed down the TLB et al. for translations?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Bits 63-60 (tag bits) are dropped from the virtual address before</span>
<span class="quote">&gt; being passed down the TLB for translation when PSTATE.mcde = 1.</span>

Ok and you said that values 15 and 0 are special.

I&#39;m just wondering if this means you can&#39;t really use ADI mappings in
the top half of the 64-bit address space.  If the bits are dropped, they
will be zero, but they need to be all 1&#39;s for the top-half of the VA
space since it&#39;s sign extended.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 8, 2016, 8:59 p.m.</div>
<pre class="content">
On 03/08/2016 01:27 PM, David Miller wrote:
<span class="quote">&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt; Date: Tue, 8 Mar 2016 13:16:11 -0700</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; On 03/08/2016 12:57 PM, David Miller wrote:</span>
<span class="quote">&gt;&gt;&gt; From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt;&gt; Date: Mon, 7 Mar 2016 14:06:43 -0700</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Good questions. Isn&#39;t set of valid VAs already constrained by VA_BITS</span>
<span class="quote">&gt;&gt;&gt;&gt; (set to 44 in arch/sparc/include/asm/processor_64.h)? As I see it we</span>
<span class="quote">&gt;&gt;&gt;&gt; are already not using the top 4 bits. Please correct me if I am wrong.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Another limiting constraint is the number of address bits coverable by</span>
<span class="quote">&gt;&gt;&gt; the 4-level page tables we use.  And this is sign extended so we have</span>
<span class="quote">&gt;&gt;&gt; a top-half and a bottom-half with a &quot;hole&quot; in the center of the VA</span>
<span class="quote">&gt;&gt;&gt; space.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; I want some clarification on the top bits during ADI accesses.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; If ADI is enabled, then the top bits of the virtual address are</span>
<span class="quote">&gt;&gt;&gt; intepreted as tag bits.  Once &quot;verified&quot; with the ADI settings, what</span>
<span class="quote">&gt;&gt;&gt; happense to these tag bits?  Are they dropped from the virtual address</span>
<span class="quote">&gt;&gt;&gt; before being passed down the TLB et al. for translations?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Bits 63-60 (tag bits) are dropped from the virtual address before</span>
<span class="quote">&gt;&gt; being passed down the TLB for translation when PSTATE.mcde = 1.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Ok and you said that values 15 and 0 are special.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I&#39;m just wondering if this means you can&#39;t really use ADI mappings in</span>
<span class="quote">&gt; the top half of the 64-bit address space.  If the bits are dropped, they</span>
<span class="quote">&gt; will be zero, but they need to be all 1&#39;s for the top-half of the VA</span>
<span class="quote">&gt; space since it&#39;s sign extended.</span>
<span class="quote">&gt;</span>

According to the manual when PSTATE.mcde=1, bits 63:60 of the virtual 
address of any load or store (using virtual address) are masked before 
being sent to memory system which includes MMU. Hardware TSB walker 
masks bits 63:60 and then sign extends from bit 59 before generating TSB 
pointer and before comparison to TSB TTE VAs but the virtual address in 
the TTE tag that is written to DTLB is masked and not sign extended. 
Manual also states that for implementations that fully support 60 bits 
or more of virtual address, they must sign-extend virtual address in TSB 
TTE tag.

--
Khalid
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/prctl/sparc_adi.txt b/Documentation/prctl/sparc_adi.txt</span>
new file mode 100644
<span class="p_header">index 0000000..9cbdcae</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/Documentation/prctl/sparc_adi.txt</span>
<span class="p_chunk">@@ -0,0 +1,62 @@</span> <span class="p_context"></span>
<span class="p_add">+========</span>
<span class="p_add">+Overview</span>
<span class="p_add">+========</span>
<span class="p_add">+</span>
<span class="p_add">+SPARC M7 processor includes the feature Application Data Integrity (ADI).</span>
<span class="p_add">+ADI allows a tag to be associated with a virtual memory address range</span>
<span class="p_add">+and a process must access that memory range with the correct tag. ADI</span>
<span class="p_add">+tag is embedded in bits 63-60 of virtual address. Once ADI is enabled</span>
<span class="p_add">+on a range of memory addresses, the process can set a tag for blocks</span>
<span class="p_add">+in this memory range n the cache using ASI_MCD_PRIMARY or</span>
<span class="p_add">+ASI_MCD_ST_BLKINIT_PRIMARY. This tag is set for ADI block sized blocks</span>
<span class="p_add">+which is provided to the kernel by machine description table.</span>
<span class="p_add">+</span>
<span class="p_add">+Linux kernel supports an application enabling and setting the ADI tag</span>
<span class="p_add">+for a subset of its data pages. Those data pages have to be locked in</span>
<span class="p_add">+memory since saving ADI tags to swap is not supported.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+New prctl options for ADI</span>
<span class="p_add">+-------------------------</span>
<span class="p_add">+</span>
<span class="p_add">+Following new options to prctl() have been added to support ADI.</span>
<span class="p_add">+</span>
<span class="p_add">+	PR_GET_SPARC_ADICAPS - Get ADI capabilities for the processor.</span>
<span class="p_add">+		These capabilities are used to set up ADI correctly</span>
<span class="p_add">+		from userspace. Machine description table provides all</span>
<span class="p_add">+		of the ADI capabilities information. arg2 to prctl() is</span>
<span class="p_add">+		a pointer to struct adi_caps which is defined in</span>
<span class="p_add">+		linux/prctl.h.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	PR_SET_SPARC_ADI - Set the state of ADI in a user thread by</span>
<span class="p_add">+		setting PSTATE.mcde bit in the user mode PSTATE register</span>
<span class="p_add">+		of the calling thread based on the value passed in arg2:</span>
<span class="p_add">+			1 == enable, 0 == disable, other == no change</span>
<span class="p_add">+		Return the previous state of the PSTATE.mcde bit:</span>
<span class="p_add">+			0 == was disabled, 1 == was enabled.</span>
<span class="p_add">+		Set errno to EINVAL and return -1 if ADI is not available.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	PR_ENABLE_SPARC_ADI - Enable ADI checking in all pages in the address</span>
<span class="p_add">+		range specified. The pages in the range must be already</span>
<span class="p_add">+		locked. This operation enables the TTE.mcd bit for the</span>
<span class="p_add">+		pages specified. arg2 is the starting address for address</span>
<span class="p_add">+		range and must be page aligned. arg3 is the length of</span>
<span class="p_add">+		memory address range and must be a multiple of page size.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	PR_DISABLE_SPARC_ADI - Disable ADI checking on all the pages in the</span>
<span class="p_add">+		address range specified. This operation disables the</span>
<span class="p_add">+		TTE.mcd bit for the pages specified. arg2 is the</span>
<span class="p_add">+		starting address for address range and must be page</span>
<span class="p_add">+		aligned. arg3 is the length of memory address range and</span>
<span class="p_add">+		must be a multiple of page size.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	PR_GET_SPARC_ADI_STATUS - Check if ADI is enabled or not for a</span>
<span class="p_add">+		given virtual address. Returns 1 for enabled, else 0.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+All addresses passed to kernel must be non-ADI tagged addresses.</span>
<span class="p_add">+Kernel does not enable ADI for kernel code.</span>
<span class="p_header">diff --git a/Documentation/sparc/adi.txt b/Documentation/sparc/adi.txt</span>
new file mode 100644
<span class="p_header">index 0000000..ac4a9d9</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/Documentation/sparc/adi.txt</span>
<span class="p_chunk">@@ -0,0 +1,206 @@</span> <span class="p_context"></span>
<span class="p_add">+Application Data Integrity (ADI)</span>
<span class="p_add">+================================</span>
<span class="p_add">+</span>
<span class="p_add">+Sparc M7 processor adds the Application Data Integrity (ADI) feature.</span>
<span class="p_add">+ADI allows a task to set version tags on any subset of its address</span>
<span class="p_add">+space. Once ADI is enabled and version tags are set for ranges of</span>
<span class="p_add">+address space of a task, the processor will compare the tag in pointers</span>
<span class="p_add">+to memory in these ranges to the version set by the application</span>
<span class="p_add">+previously. Access to memory is granted only if the tag in given</span>
<span class="p_add">+pointer matches the tag set by the application. In case of mismatch,</span>
<span class="p_add">+processor raises an exception.  ADI can be enabled on pages that are</span>
<span class="p_add">+locked in memory, i.e.  are not swappable.</span>
<span class="p_add">+</span>
<span class="p_add">+Following steps must be taken by a task to enable ADI fully:</span>
<span class="p_add">+</span>
<span class="p_add">+1. Set the user mode PSTATE.mcde bit</span>
<span class="p_add">+</span>
<span class="p_add">+2. Set TTE.mcd bit on any TLB entries that correspond to the range of</span>
<span class="p_add">+addresses ADI is being enabled on.</span>
<span class="p_add">+</span>
<span class="p_add">+3. Set the version tag for memory addresses.</span>
<span class="p_add">+</span>
<span class="p_add">+Kernel provides prctl() calls to perform steps 1 (PR_SET_SPARC_ADI) and</span>
<span class="p_add">+2 (PR_ENABLE_SPARC_ADI). Please see Documentation/prctl/sparc_adi.txt</span>
<span class="p_add">+for more details on these prctl calls. Step 3 is performed with an</span>
<span class="p_add">+stxa instruction on the address using ASI_MCD_PRIMARY or</span>
<span class="p_add">+ASI_MCD_ST_BLKINIT_PRIMARY. Version tags are stoed in bits 63-60 of</span>
<span class="p_add">+address and are set on a cache line. Version tag values of 0x0 and 0xf</span>
<span class="p_add">+are reserved.</span>
<span class="p_add">+</span>
<span class="p_add">+NOTE:	ADI is supported on hugepage only. Hugepages are already locked</span>
<span class="p_add">+	in memory.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+ADI related traps</span>
<span class="p_add">+-----------------</span>
<span class="p_add">+</span>
<span class="p_add">+With ADI enabled, following new traps may occur:</span>
<span class="p_add">+</span>
<span class="p_add">+Disrupting memory corruption</span>
<span class="p_add">+</span>
<span class="p_add">+	When a store accesses a memory localtion that has TTE.mcd=1,</span>
<span class="p_add">+	the task is running with ADI enabled (PSTATE.mcde=1), and the ADI</span>
<span class="p_add">+	tag in the address used (bits 63:60) does not match the tag set on</span>
<span class="p_add">+	the corresponding cacheline, a memory corruption trap occurs. By</span>
<span class="p_add">+	default, it is a disrupting trap and is sent to the hypervisor</span>
<span class="p_add">+	first. Hypervisor creates a sun4v error report and sends a</span>
<span class="p_add">+	resumable error (TT=0x7e) trap to the kernel. The kernel sends</span>
<span class="p_add">+	a SIGSEGV to the task that resulted in this trap with the following</span>
<span class="p_add">+	info:</span>
<span class="p_add">+</span>
<span class="p_add">+		siginfo.si_signo = SIGSEGV;</span>
<span class="p_add">+		siginfo.errno = 0;</span>
<span class="p_add">+		siginfo.si_code = SEGV_ADIDERR;</span>
<span class="p_add">+		siginfo.si_addr = addr; /* address that caused trap */</span>
<span class="p_add">+		siginfo.si_trapno = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+Precise memory corruption</span>
<span class="p_add">+</span>
<span class="p_add">+	When a store accesses a memory location that has TTE.mcd=1,</span>
<span class="p_add">+	the task is running with ADI enabled (PSTATE.mcde=1), and the ADI</span>
<span class="p_add">+	tag in the address used (bits 63:60) does not match the tag set on</span>
<span class="p_add">+	the corresponding cacheline, a memory corruption trap occurs. If</span>
<span class="p_add">+	MCD precise exception is enabled (MCDPERR=1), a precise</span>
<span class="p_add">+	exception is sent to the kernel with TT=0x1a. The kernel sends</span>
<span class="p_add">+	a SIGSEGV to the task that resulted in this trap with the following</span>
<span class="p_add">+	info:</span>
<span class="p_add">+</span>
<span class="p_add">+		siginfo.si_signo = SIGSEGV;</span>
<span class="p_add">+		siginfo.errno = 0;</span>
<span class="p_add">+		siginfo.si_code = SEGV_ADIPERR;</span>
<span class="p_add">+		siginfo.si_addr = addr;	/* address that caused trap */</span>
<span class="p_add">+		siginfo.si_trapno = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	NOTE: ADI tag mismatch on a load always results in precise trap.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+MCD disabled</span>
<span class="p_add">+</span>
<span class="p_add">+	When a task has not enabled ADI and attempts to set ADI version</span>
<span class="p_add">+	on a memory address, processor sends an MCD disabled trap. This</span>
<span class="p_add">+	trap is handled by hypervisor first and the hypervisor vectors this</span>
<span class="p_add">+	trap through to the kernel as Data Access Exception trap with</span>
<span class="p_add">+	fault type set to 0xa (invalid ASI). When this occurs, the kernel</span>
<span class="p_add">+	sends the task SIGBUS signal with following info:</span>
<span class="p_add">+</span>
<span class="p_add">+		siginfo.si_signo = SIGBUS;</span>
<span class="p_add">+		siginfo.errno = 0;</span>
<span class="p_add">+		siginfo.si_code = SEGV_ACCADI;</span>
<span class="p_add">+		siginfo.si_addr = addr;	/* address that caused trap */</span>
<span class="p_add">+		siginfo.si_trapno = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+Sample program to use ADI</span>
<span class="p_add">+-------------------------</span>
<span class="p_add">+</span>
<span class="p_add">+Following sample program is meant to illustrate how to use the ADI</span>
<span class="p_add">+functionality with the default 8M hugepages.</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;unistd.h&gt;</span>
<span class="p_add">+#include &lt;stdio.h&gt;</span>
<span class="p_add">+#include &lt;stdlib.h&gt;</span>
<span class="p_add">+#include &lt;sys/ipc.h&gt;</span>
<span class="p_add">+#include &lt;sys/shm.h&gt;</span>
<span class="p_add">+#include &lt;asm/asi.h&gt;</span>
<span class="p_add">+#include &lt;linux/prctl.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define BUFFER_SIZE	32*1024*1024</span>
<span class="p_add">+</span>
<span class="p_add">+struct adi_caps adicap;</span>
<span class="p_add">+</span>
<span class="p_add">+main()</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long i, mcde;</span>
<span class="p_add">+	char *shmaddr, *tmp_addr, *end, *veraddr, *clraddr;</span>
<span class="p_add">+	int shmid, version;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((shmid = shmget(2, BUFFER_SIZE,</span>
<span class="p_add">+				SHM_HUGETLB | IPC_CREAT | SHM_R | SHM_W)) &lt; 0) {</span>
<span class="p_add">+		perror(&quot;shmget failed&quot;);</span>
<span class="p_add">+		exit(1);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	shmaddr = shmat(shmid, NULL, 0);</span>
<span class="p_add">+	if (shmaddr == (char *)-1) {</span>
<span class="p_add">+		perror(&quot;shm attach failed&quot;);</span>
<span class="p_add">+		shmctl(shmid, IPC_RMID, NULL);</span>
<span class="p_add">+		exit(1);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Get the values for various ADI capabilities bits. These will</span>
<span class="p_add">+	 * be used later for setting the ADI tag</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (prctl(PR_GET_SPARC_ADICAPS, &amp;adicap) &lt; 0) {</span>
<span class="p_add">+		perror(&quot;PR_GET_SPARC_ADICAPS failed&quot;);</span>
<span class="p_add">+		goto err_out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set PSTATE.mcde</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((mcde = prctl(PR_SET_SPARC_ADI, PR_SET_SPARC_ADI_SET)) &lt; 0) {</span>
<span class="p_add">+		perror(&quot;PR_SET_SPARC_ADI failed&quot;);</span>
<span class="p_add">+		goto err_out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set TTE.mcd on the address range for shm segment</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (prctl(PR_ENABLE_SPARC_ADI, shmaddr, BUFFER_SIZE) &lt; 0) {</span>
<span class="p_add">+		perror(&quot;prctl failed&quot;);</span>
<span class="p_add">+		goto err_out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set the ADI version tag on the shm segment</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	version = 10;</span>
<span class="p_add">+	tmp_addr = shmaddr;</span>
<span class="p_add">+	end = shmaddr + BUFFER_SIZE;</span>
<span class="p_add">+	while (tmp_addr &lt; end) {</span>
<span class="p_add">+		asm volatile(</span>
<span class="p_add">+			&quot;stxa %1, [%0]ASI_MCD_PRIMARY\n\t&quot;</span>
<span class="p_add">+			:</span>
<span class="p_add">+			: &quot;r&quot; (tmp_addr), &quot;r&quot; (version));</span>
<span class="p_add">+		tmp_addr += adicap.blksz;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Create a versioned address from the normal address</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	tmp_addr = (void *) ((unsigned long)shmaddr &lt;&lt; adicap.nbits);</span>
<span class="p_add">+	tmp_addr = (void *) ((unsigned long)tmp_addr &gt;&gt; adicap.nbits);</span>
<span class="p_add">+	veraddr = (void *) (((unsigned long)version &lt;&lt; (64-adicap.nbits))</span>
<span class="p_add">+			| (unsigned long)tmp_addr);</span>
<span class="p_add">+</span>
<span class="p_add">+	printf(&quot;Starting the writes:\n&quot;);</span>
<span class="p_add">+	for (i = 0; i &lt; BUFFER_SIZE; i++) {</span>
<span class="p_add">+		veraddr[i] = (char)(i);</span>
<span class="p_add">+		if (!(i % (1024 * 1024)))</span>
<span class="p_add">+			printf(&quot;.&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	printf(&quot;\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	printf(&quot;Verifying data...&quot;);</span>
<span class="p_add">+	for (i = 0; i &lt; BUFFER_SIZE; i++)</span>
<span class="p_add">+		if (veraddr[i] != (char)i)</span>
<span class="p_add">+			printf(&quot;\nIndex %lu mismatched\n&quot;, i);</span>
<span class="p_add">+	printf(&quot;Done.\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Disable ADI and clean up</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (prctl(PR_DISABLE_SPARC_ADI, shmaddr, BUFFER_SIZE) &lt; 0) {</span>
<span class="p_add">+		perror(&quot;prctl failed&quot;);</span>
<span class="p_add">+		goto err_out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (shmdt((const void *)shmaddr) != 0)</span>
<span class="p_add">+		perror(&quot;Detach failure&quot;);</span>
<span class="p_add">+	shmctl(shmid, IPC_RMID, NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	exit(0);</span>
<span class="p_add">+</span>
<span class="p_add">+err_out:</span>
<span class="p_add">+	if (shmdt((const void *)shmaddr) != 0)</span>
<span class="p_add">+		perror(&quot;Detach failure&quot;);</span>
<span class="p_add">+	shmctl(shmid, IPC_RMID, NULL);</span>
<span class="p_add">+	exit(1);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/sparc/Kconfig b/arch/sparc/Kconfig</span>
<span class="p_header">index 56442d2..0aac0ae 100644</span>
<span class="p_header">--- a/arch/sparc/Kconfig</span>
<span class="p_header">+++ b/arch/sparc/Kconfig</span>
<span class="p_chunk">@@ -80,6 +80,7 @@</span> <span class="p_context"> config SPARC64</span>
 	select NO_BOOTMEM
 	select HAVE_ARCH_AUDITSYSCALL
 	select ARCH_SUPPORTS_ATOMIC_RMW
<span class="p_add">+	select SPARC_ADI</span>
 
 config ARCH_DEFCONFIG
 	string
<span class="p_chunk">@@ -314,6 +315,17 @@</span> <span class="p_context"> if SPARC64</span>
 source &quot;kernel/power/Kconfig&quot;
 endif
 
<span class="p_add">+config SPARC_ADI</span>
<span class="p_add">+	bool &quot;Application Data Integrity support&quot;</span>
<span class="p_add">+	def_bool y if SPARC64</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Support for Application Data Integrity (ADI). ADI feature allows</span>
<span class="p_add">+	  a process to tag memory blocks with version tags. Once ADI is</span>
<span class="p_add">+	  enabled and version tag is set on a memory block, any access to</span>
<span class="p_add">+	  it is allowed only if the correct version tag is presented by</span>
<span class="p_add">+	  a process. This feature is meant to help catch rogue accesses</span>
<span class="p_add">+	  to memory.</span>
<span class="p_add">+</span>
 config SCHED_SMT
 	bool &quot;SMT (Hyperthreading) scheduler support&quot;
 	depends on SPARC64 &amp;&amp; SMP
<span class="p_header">diff --git a/arch/sparc/include/asm/hugetlb.h b/arch/sparc/include/asm/hugetlb.h</span>
<span class="p_header">index 139e711..5e7547c 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/hugetlb.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/hugetlb.h</span>
<span class="p_chunk">@@ -82,4 +82,18 @@</span> <span class="p_context"> static inline void arch_clear_hugepage_flags(struct page *page)</span>
 {
 }
 
<span class="p_add">+#ifdef CONFIG_SPARC_ADI</span>
<span class="p_add">+static inline pte_t arch_make_huge_pte(pte_t entry, struct vm_area_struct *vma,</span>
<span class="p_add">+			 struct page *page, int writeable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* If this vma has ADI enabled on it, turn on TTE.mcd</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_SPARC_ADI)</span>
<span class="p_add">+		return pte_mkmcd(entry);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return pte_mknotmcd(entry);</span>
<span class="p_add">+}</span>
<span class="p_add">+#define arch_make_huge_pte arch_make_huge_pte</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #endif /* _ASM_SPARC64_HUGETLB_H */
<span class="p_header">diff --git a/arch/sparc/include/asm/hypervisor.h b/arch/sparc/include/asm/hypervisor.h</span>
<span class="p_header">index f5b6537..2940bb3 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/hypervisor.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/hypervisor.h</span>
<span class="p_chunk">@@ -547,6 +547,8 @@</span> <span class="p_context"> struct hv_fault_status {</span>
 #define HV_FAULT_TYPE_RESV1	13
 #define HV_FAULT_TYPE_UNALIGNED	14
 #define HV_FAULT_TYPE_INV_PGSZ	15
<span class="p_add">+#define HV_FAULT_TYPE_MCD	17</span>
<span class="p_add">+#define HV_FAULT_TYPE_MCD_DIS	18</span>
 /* Values 16 --&gt; -2 are reserved.  */
 #define HV_FAULT_TYPE_MULTIPLE	-1
 
<span class="p_header">diff --git a/arch/sparc/include/asm/mmu_64.h b/arch/sparc/include/asm/mmu_64.h</span>
<span class="p_header">index 70067ce..8e98741 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/mmu_64.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/mmu_64.h</span>
<span class="p_chunk">@@ -95,6 +95,7 @@</span> <span class="p_context"> typedef struct {</span>
 	unsigned long		huge_pte_count;
 	struct tsb_config	tsb_block[MM_NUM_TSBS];
 	struct hv_tsb_descr	tsb_descr[MM_NUM_TSBS];
<span class="p_add">+	unsigned char		adi;</span>
 } mm_context_t;
 
 #endif /* !__ASSEMBLY__ */
<span class="p_header">diff --git a/arch/sparc/include/asm/pgtable_64.h b/arch/sparc/include/asm/pgtable_64.h</span>
<span class="p_header">index 131d36f..cddea30 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/pgtable_64.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/pgtable_64.h</span>
<span class="p_chunk">@@ -162,6 +162,9 @@</span> <span class="p_context"> bool kern_addr_valid(unsigned long addr);</span>
 #define _PAGE_E_4V	  _AC(0x0000000000000800,UL) /* side-Effect          */
 #define _PAGE_CP_4V	  _AC(0x0000000000000400,UL) /* Cacheable in P-Cache */
 #define _PAGE_CV_4V	  _AC(0x0000000000000200,UL) /* Cacheable in V-Cache */
<span class="p_add">+/* Bit 9 is used to enable MCD corruption detection instead on M7</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define _PAGE_MCD_4V	  _AC(0x0000000000000200,UL) /* Memory Corruption    */</span>
 #define _PAGE_P_4V	  _AC(0x0000000000000100,UL) /* Privileged Page      */
 #define _PAGE_EXEC_4V	  _AC(0x0000000000000080,UL) /* Executable Page      */
 #define _PAGE_W_4V	  _AC(0x0000000000000040,UL) /* Writable             */
<span class="p_chunk">@@ -541,6 +544,18 @@</span> <span class="p_context"> static inline pte_t pte_mkspecial(pte_t pte)</span>
 	return pte;
 }
 
<span class="p_add">+static inline pte_t pte_mkmcd(pte_t pte)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pte_val(pte) |= _PAGE_MCD_4V;</span>
<span class="p_add">+	return pte;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline pte_t pte_mknotmcd(pte_t pte)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pte_val(pte) &amp;= ~_PAGE_MCD_4V;</span>
<span class="p_add">+	return pte;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline unsigned long pte_young(pte_t pte)
 {
 	unsigned long mask;
<span class="p_header">diff --git a/arch/sparc/include/asm/processor_64.h b/arch/sparc/include/asm/processor_64.h</span>
<span class="p_header">index 6924bde..9a71701 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/processor_64.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/processor_64.h</span>
<span class="p_chunk">@@ -97,6 +97,25 @@</span> <span class="p_context"> struct thread_struct {</span>
 struct task_struct;
 unsigned long thread_saved_pc(struct task_struct *);
 
<span class="p_add">+#ifdef CONFIG_SPARC_ADI</span>
<span class="p_add">+extern struct adi_caps *get_adi_caps(void);</span>
<span class="p_add">+extern long get_sparc_adicaps(unsigned long);</span>
<span class="p_add">+extern long set_sparc_pstate_mcde(unsigned long);</span>
<span class="p_add">+extern long enable_sparc_adi(unsigned long, unsigned long);</span>
<span class="p_add">+extern long disable_sparc_adi(unsigned long, unsigned long);</span>
<span class="p_add">+extern long get_sparc_adi_status(unsigned long);</span>
<span class="p_add">+extern bool adi_capable(void);</span>
<span class="p_add">+</span>
<span class="p_add">+#define GET_SPARC_ADICAPS(a)	get_sparc_adicaps(a)</span>
<span class="p_add">+#define SET_SPARC_MCDE(a)	set_sparc_pstate_mcde(a)</span>
<span class="p_add">+#define ENABLE_SPARC_ADI(a, b)	enable_sparc_adi(a, b)</span>
<span class="p_add">+#define DISABLE_SPARC_ADI(a, b)	disable_sparc_adi(a, b)</span>
<span class="p_add">+#define GET_SPARC_ADI_STATUS(a)	get_sparc_adi_status(a)</span>
<span class="p_add">+#define ADI_CAPABLE()		adi_capable()</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define ADI_CAPABLE()		0</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /* On Uniprocessor, even in RMO processes see TSO semantics */
 #ifdef CONFIG_SMP
 #define TSTATE_INITIAL_MM	TSTATE_TSO
<span class="p_header">diff --git a/arch/sparc/include/asm/ttable.h b/arch/sparc/include/asm/ttable.h</span>
<span class="p_header">index 71b5a67..342b457 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/ttable.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/ttable.h</span>
<span class="p_chunk">@@ -212,6 +212,16 @@</span> <span class="p_context"></span>
 	nop;						\
 	nop;
 
<span class="p_add">+#define SUN4V_MCD_PRECISE				\</span>
<span class="p_add">+	ldxa	[%g0] ASI_SCRATCHPAD, %g2;		\</span>
<span class="p_add">+	ldx	[%g2 + HV_FAULT_D_ADDR_OFFSET], %g4;	\</span>
<span class="p_add">+	ldx	[%g2 + HV_FAULT_D_CTX_OFFSET], %g5;	\</span>
<span class="p_add">+	ba,pt	%xcc, sun4v_mcd_detect_precise;		\</span>
<span class="p_add">+	 nop;						\</span>
<span class="p_add">+	nop;						\</span>
<span class="p_add">+	nop;						\</span>
<span class="p_add">+	nop;</span>
<span class="p_add">+</span>
 /* Before touching these macros, you owe it to yourself to go and
  * see how arch/sparc64/kernel/winfixup.S works... -DaveM
  *
<span class="p_header">diff --git a/arch/sparc/include/uapi/asm/asi.h b/arch/sparc/include/uapi/asm/asi.h</span>
<span class="p_header">index 7ad7203d..7d099ac 100644</span>
<span class="p_header">--- a/arch/sparc/include/uapi/asm/asi.h</span>
<span class="p_header">+++ b/arch/sparc/include/uapi/asm/asi.h</span>
<span class="p_chunk">@@ -244,6 +244,9 @@</span> <span class="p_context"></span>
 #define ASI_UDBL_CONTROL_R	0x7f /* External UDB control regs rd low*/
 #define ASI_INTR_R		0x7f /* IRQ vector dispatch read	*/
 #define ASI_INTR_DATAN_R	0x7f /* (III) In irq vector data reg N	*/
<span class="p_add">+#define ASI_MCD_PRIMARY		0x90 /* (NG7) MCD version load/store	*/</span>
<span class="p_add">+#define ASI_MCD_ST_BLKINIT_PRIMARY	\</span>
<span class="p_add">+				0x92 /* (NG7) MCD store BLKINIT primary	*/</span>
 #define ASI_PIC			0xb0 /* (NG4) PIC registers		*/
 #define ASI_PST8_P		0xc0 /* Primary, 8 8-bit, partial	*/
 #define ASI_PST8_S		0xc1 /* Secondary, 8 8-bit, partial	*/
<span class="p_header">diff --git a/arch/sparc/include/uapi/asm/pstate.h b/arch/sparc/include/uapi/asm/pstate.h</span>
<span class="p_header">index cf832e1..d0521db 100644</span>
<span class="p_header">--- a/arch/sparc/include/uapi/asm/pstate.h</span>
<span class="p_header">+++ b/arch/sparc/include/uapi/asm/pstate.h</span>
<span class="p_chunk">@@ -10,7 +10,12 @@</span> <span class="p_context"></span>
  * -----------------------------------------------------------------------
  *  63  12  11   10    9     8    7   6   5     4     3     2     1    0
  */
<span class="p_add">+/* IG on V9 conflicts with MCDE on M7. PSTATE_MCDE will only be used on</span>
<span class="p_add">+ * processors that support ADI which do not use IG, hence there is no</span>
<span class="p_add">+ * functional conflict</span>
<span class="p_add">+ */</span>
 #define PSTATE_IG   _AC(0x0000000000000800,UL) /* Interrupt Globals.	*/
<span class="p_add">+#define PSTATE_MCDE _AC(0x0000000000000800,UL) /* MCD Enable		*/</span>
 #define PSTATE_MG   _AC(0x0000000000000400,UL) /* MMU Globals.		*/
 #define PSTATE_CLE  _AC(0x0000000000000200,UL) /* Current Little Endian.*/
 #define PSTATE_TLE  _AC(0x0000000000000100,UL) /* Trap Little Endian.	*/
<span class="p_chunk">@@ -47,7 +52,12 @@</span> <span class="p_context"></span>
 #define TSTATE_ASI	_AC(0x00000000ff000000,UL) /* AddrSpace ID.	*/
 #define TSTATE_PIL	_AC(0x0000000000f00000,UL) /* %pil (Linux traps)*/
 #define TSTATE_PSTATE	_AC(0x00000000000fff00,UL) /* PSTATE.		*/
<span class="p_add">+/* IG on V9 conflicts with MCDE on M7. TSTATE_MCDE will only be used on</span>
<span class="p_add">+ * processors that support ADI which do not support IG, hence there is</span>
<span class="p_add">+ * no functional conflict</span>
<span class="p_add">+ */</span>
 #define TSTATE_IG	_AC(0x0000000000080000,UL) /* Interrupt Globals.*/
<span class="p_add">+#define TSTATE_MCDE	_AC(0x0000000000080000,UL) /* MCD enable.       */</span>
 #define TSTATE_MG	_AC(0x0000000000040000,UL) /* MMU Globals.	*/
 #define TSTATE_CLE	_AC(0x0000000000020000,UL) /* CurrLittleEndian.	*/
 #define TSTATE_TLE	_AC(0x0000000000010000,UL) /* TrapLittleEndian.	*/
<span class="p_header">diff --git a/arch/sparc/kernel/entry.h b/arch/sparc/kernel/entry.h</span>
<span class="p_header">index 0f67942..2078468 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/entry.h</span>
<span class="p_header">+++ b/arch/sparc/kernel/entry.h</span>
<span class="p_chunk">@@ -159,6 +159,9 @@</span> <span class="p_context"> void sun4v_resum_overflow(struct pt_regs *regs);</span>
 void sun4v_nonresum_error(struct pt_regs *regs,
 			  unsigned long offset);
 void sun4v_nonresum_overflow(struct pt_regs *regs);
<span class="p_add">+void sun4v_mem_corrupt_detect_precise(struct pt_regs *regs,</span>
<span class="p_add">+				      unsigned long addr,</span>
<span class="p_add">+				      unsigned long context);</span>
 
 extern unsigned long sun4v_err_itlb_vaddr;
 extern unsigned long sun4v_err_itlb_ctx;
<span class="p_header">diff --git a/arch/sparc/kernel/head_64.S b/arch/sparc/kernel/head_64.S</span>
<span class="p_header">index f2d30ca..f4a880b 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/head_64.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/head_64.S</span>
<span class="p_chunk">@@ -878,6 +878,7 @@</span> <span class="p_context"> sparc64_boot_end:</span>
 #include &quot;helpers.S&quot;
 #include &quot;hvcalls.S&quot;
 #include &quot;sun4v_tlb_miss.S&quot;
<span class="p_add">+#include &quot;sun4v_mcd.S&quot;</span>
 #include &quot;sun4v_ivec.S&quot;
 #include &quot;ktlb.S&quot;
 #include &quot;tsb.S&quot;
<span class="p_header">diff --git a/arch/sparc/kernel/mdesc.c b/arch/sparc/kernel/mdesc.c</span>
<span class="p_header">index 6f80936..79f981c 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/mdesc.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/mdesc.c</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/miscdevice.h&gt;
 #include &lt;linux/bootmem.h&gt;
 #include &lt;linux/export.h&gt;
<span class="p_add">+#include &lt;linux/prctl.h&gt;</span>
 
 #include &lt;asm/cpudata.h&gt;
 #include &lt;asm/hypervisor.h&gt;
<span class="p_chunk">@@ -512,6 +513,11 @@</span> <span class="p_context"> EXPORT_SYMBOL(mdesc_node_name);</span>
 
 static u64 max_cpus = 64;
 
<span class="p_add">+static struct {</span>
<span class="p_add">+	bool enabled;</span>
<span class="p_add">+	struct adi_caps caps;</span>
<span class="p_add">+} adi_state;</span>
<span class="p_add">+</span>
 static void __init report_platform_properties(void)
 {
 	struct mdesc_handle *hp = mdesc_grab();
<span class="p_chunk">@@ -1007,6 +1013,80 @@</span> <span class="p_context"> static int mdesc_open(struct inode *inode, struct file *file)</span>
 	return 0;
 }
 
<span class="p_add">+bool adi_capable(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return adi_state.enabled;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+struct adi_caps *get_adi_caps(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return &amp;adi_state.caps;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init</span>
<span class="p_add">+init_adi(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mdesc_handle *hp = mdesc_grab();</span>
<span class="p_add">+	const char *prop;</span>
<span class="p_add">+	u64 pn, *val;</span>
<span class="p_add">+	int len;</span>
<span class="p_add">+</span>
<span class="p_add">+	adi_state.enabled = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!hp)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	pn = mdesc_node_by_name(hp, MDESC_NODE_NULL, &quot;cpu&quot;);</span>
<span class="p_add">+	if (pn == MDESC_NODE_NULL)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	prop = mdesc_get_property(hp, pn, &quot;hwcap-list&quot;, &amp;len);</span>
<span class="p_add">+	if (!prop)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Look for &quot;adp&quot; keyword in hwcap-list which would indicate</span>
<span class="p_add">+	 * ADI support</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	while (len) {</span>
<span class="p_add">+		int plen;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!strcmp(prop, &quot;adp&quot;)) {</span>
<span class="p_add">+			adi_state.enabled = true;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		plen = strlen(prop) + 1;</span>
<span class="p_add">+		prop += plen;</span>
<span class="p_add">+		len -= plen;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!adi_state.enabled)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	pn = mdesc_node_by_name(hp, MDESC_NODE_NULL, &quot;platform&quot;);</span>
<span class="p_add">+	if (pn == MDESC_NODE_NULL)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = (u64 *) mdesc_get_property(hp, pn, &quot;adp-blksz&quot;, &amp;len);</span>
<span class="p_add">+	if (!val)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	adi_state.caps.blksz = *val;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = (u64 *) mdesc_get_property(hp, pn, &quot;adp-nbits&quot;, &amp;len);</span>
<span class="p_add">+	if (!val)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	adi_state.caps.nbits = *val;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = (u64 *) mdesc_get_property(hp, pn, &quot;ue-on-adp&quot;, &amp;len);</span>
<span class="p_add">+	if (!val)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	adi_state.caps.ue_on_adi = *val;</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	mdesc_release(hp);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static ssize_t mdesc_read(struct file *file, char __user *buf,
 			  size_t len, loff_t *offp)
 {
<span class="p_chunk">@@ -1110,5 +1190,6 @@</span> <span class="p_context"> void __init sun4v_mdesc_init(void)</span>
 
 	cur_mdesc = hp;
 
<span class="p_add">+	init_adi();</span>
 	report_platform_properties();
 }
<span class="p_header">diff --git a/arch/sparc/kernel/process_64.c b/arch/sparc/kernel/process_64.c</span>
<span class="p_header">index 46a5964..d2a7cac 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/process_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/process_64.c</span>
<span class="p_chunk">@@ -32,6 +32,9 @@</span> <span class="p_context"></span>
 #include &lt;linux/sysrq.h&gt;
 #include &lt;linux/nmi.h&gt;
 #include &lt;linux/context_tracking.h&gt;
<span class="p_add">+#include &lt;linux/prctl.h&gt;</span>
<span class="p_add">+#include &lt;linux/hugetlb.h&gt;</span>
<span class="p_add">+#include &lt;linux/mempolicy.h&gt;</span>
 
 #include &lt;asm/uaccess.h&gt;
 #include &lt;asm/page.h&gt;
<span class="p_chunk">@@ -777,3 +780,222 @@</span> <span class="p_context"> unsigned long get_wchan(struct task_struct *task)</span>
 out:
 	return ret;
 }
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_SPARC_ADI</span>
<span class="p_add">+long get_sparc_adicaps(unsigned long val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct adi_caps *caps;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!ADI_CAPABLE())</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	caps = get_adi_caps();</span>
<span class="p_add">+	if (val)</span>
<span class="p_add">+		if (copy_to_user((void *)val, caps, sizeof(struct adi_caps)))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+long set_sparc_pstate_mcde(unsigned long val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long error;</span>
<span class="p_add">+	struct pt_regs *regs;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!ADI_CAPABLE())</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We do not allow anonymous tasks to enable ADI because they</span>
<span class="p_add">+	 * run in borrowed aadress space.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (current-&gt;mm == NULL)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	regs = task_pt_regs(current);</span>
<span class="p_add">+	if (regs-&gt;tstate &amp; TSTATE_MCDE)</span>
<span class="p_add">+		error = 1;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		error = 0;</span>
<span class="p_add">+	switch (val) {</span>
<span class="p_add">+	case 1:</span>
<span class="p_add">+		regs-&gt;tstate |= TSTATE_MCDE;</span>
<span class="p_add">+		current-&gt;mm-&gt;context.adi = 1;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0:</span>
<span class="p_add">+		regs-&gt;tstate &amp;= ~TSTATE_MCDE;</span>
<span class="p_add">+		current-&gt;mm-&gt;context.adi = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return error;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+long enable_sparc_adi(unsigned long addr, unsigned long len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long end, pagemask;</span>
<span class="p_add">+	int error;</span>
<span class="p_add">+	struct vm_area_struct *vma, *vma2;</span>
<span class="p_add">+	struct mm_struct *mm;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!ADI_CAPABLE())</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	vma = find_vma(current-&gt;mm, addr);</span>
<span class="p_add">+	if (unlikely(!vma) || (vma-&gt;vm_start &gt; addr))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* ADI is supported for hugepages only</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!is_vm_hugetlb_page(vma))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Is the start address page aligned and is the length multiple</span>
<span class="p_add">+	 * of page size?</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pagemask = ~(vma_kernel_pagesize(vma) - 1);</span>
<span class="p_add">+	if (addr &amp; ~pagemask)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	if (len &amp; ~pagemask)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	end = addr + len;</span>
<span class="p_add">+	if (end == addr)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Verify end of the region is not out of bounds</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	vma2 = find_vma(current-&gt;mm, end-1);</span>
<span class="p_add">+	if (unlikely(!vma2) || (vma2-&gt;vm_start &gt; end))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	error = 0;</span>
<span class="p_add">+	while (1) {</span>
<span class="p_add">+		/* If the address space ADI is to be enabled in, does not cover</span>
<span class="p_add">+		 * this vma in its entirety, we will need to split it.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		mm = vma-&gt;vm_mm;</span>
<span class="p_add">+		if (addr != vma-&gt;vm_start) {</span>
<span class="p_add">+			error = split_vma(mm, vma, addr, 1);</span>
<span class="p_add">+			if (error)</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (end &lt; vma-&gt;vm_end) {</span>
<span class="p_add">+			error = split_vma(mm, vma, end, 0);</span>
<span class="p_add">+			if (error)</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Update the ADI info in vma and PTE</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		vma-&gt;vm_flags |= VM_SPARC_ADI;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (end &gt; vma-&gt;vm_end) {</span>
<span class="p_add">+			change_protection(vma, addr, vma-&gt;vm_end,</span>
<span class="p_add">+					  vma-&gt;vm_page_prot,</span>
<span class="p_add">+					  vma_wants_writenotify(vma), 0);</span>
<span class="p_add">+			addr = vma-&gt;vm_end;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			change_protection(vma, addr, end, vma-&gt;vm_page_prot,</span>
<span class="p_add">+					vma_wants_writenotify(vma), 0);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		vma = find_vma(current-&gt;mm, addr);</span>
<span class="p_add">+		if (unlikely(!vma) || (vma-&gt;vm_start &gt; addr))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+out:</span>
<span class="p_add">+	if (error == -ENOMEM)</span>
<span class="p_add">+		error = -EAGAIN;</span>
<span class="p_add">+	return error;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+long disable_sparc_adi(unsigned long addr, unsigned long len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long end, pagemask;</span>
<span class="p_add">+	struct vm_area_struct *vma, *vma2, *prev;</span>
<span class="p_add">+	struct mm_struct *mm;</span>
<span class="p_add">+	pgoff_t pgoff;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!ADI_CAPABLE())</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	vma = find_vma(current-&gt;mm, addr);</span>
<span class="p_add">+	if (unlikely(!vma) || (vma-&gt;vm_start &gt; addr))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* ADI is supported for hugepages only</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!is_vm_hugetlb_page(vma))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Is the start address page aligned and is the length multiple</span>
<span class="p_add">+	 * of page size?</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pagemask = ~(vma_kernel_pagesize(vma) - 1);</span>
<span class="p_add">+	if (addr &amp; ~pagemask)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	if (len &amp; ~pagemask)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	end = addr + len;</span>
<span class="p_add">+	if (end == addr)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Verify end of the region is not out of bounds</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	vma2 = find_vma(current-&gt;mm, end-1);</span>
<span class="p_add">+	if (unlikely(!vma2) || (vma2-&gt;vm_start &gt; end))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (1) {</span>
<span class="p_add">+		mm = vma-&gt;vm_mm;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Update the ADI info in vma and check if this vma can</span>
<span class="p_add">+		 * be merged with adjacent ones</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		pgoff = vma-&gt;vm_pgoff + ((addr - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+		prev = vma_merge(mm, prev, addr, end, vma-&gt;vm_flags,</span>
<span class="p_add">+				 vma-&gt;anon_vma, vma-&gt;vm_file, pgoff,</span>
<span class="p_add">+				 vma_policy(vma), vma-&gt;vm_userfaultfd_ctx);</span>
<span class="p_add">+		if (prev)</span>
<span class="p_add">+			vma = prev;</span>
<span class="p_add">+</span>
<span class="p_add">+		vma-&gt;vm_flags &amp;= ~VM_SPARC_ADI;</span>
<span class="p_add">+		if (end &gt; vma-&gt;vm_end) {</span>
<span class="p_add">+			change_protection(vma, addr, vma-&gt;vm_end,</span>
<span class="p_add">+					  vma-&gt;vm_page_prot,</span>
<span class="p_add">+					  vma_wants_writenotify(vma), 0);</span>
<span class="p_add">+			addr = vma-&gt;vm_end;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			change_protection(vma, addr, end, vma-&gt;vm_page_prot,</span>
<span class="p_add">+					  vma_wants_writenotify(vma), 0);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		vma = find_vma_prev(current-&gt;mm, addr, &amp;prev);</span>
<span class="p_add">+		if (unlikely(!vma) || (vma-&gt;vm_start &gt; addr))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+long get_sparc_adi_status(unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct vm_area_struct *vma;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!ADI_CAPABLE())</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	vma = find_vma(current-&gt;mm, addr);</span>
<span class="p_add">+	if (unlikely(!vma) || (vma-&gt;vm_start &gt; addr))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_SPARC_ADI)</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/arch/sparc/kernel/sun4v_mcd.S b/arch/sparc/kernel/sun4v_mcd.S</span>
new file mode 100644
<span class="p_header">index 0000000..d1d1259</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/sparc/kernel/sun4v_mcd.S</span>
<span class="p_chunk">@@ -0,0 +1,16 @@</span> <span class="p_context"></span>
<span class="p_add">+/* sun4v_mcd.S: Sun4v memory corruption detected precise exception handler</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2015 Bob Picco &lt;bob.picco@oracle.com&gt;</span>
<span class="p_add">+ * Copyright (C) 2015 Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="p_add">+ */</span>
<span class="p_add">+	.text</span>
<span class="p_add">+	.align 32</span>
<span class="p_add">+</span>
<span class="p_add">+sun4v_mcd_detect_precise:</span>
<span class="p_add">+	ba,pt	%xcc, etrap</span>
<span class="p_add">+	rd	%pc, %g7</span>
<span class="p_add">+	or	%l4, %g0, %o1</span>
<span class="p_add">+	or 	%l5, %g0, %o2</span>
<span class="p_add">+	call	sun4v_mem_corrupt_detect_precise</span>
<span class="p_add">+	add	%sp, PTREGS_OFF, %o0</span>
<span class="p_add">+	ba,a,pt	%xcc, rtrap</span>
<span class="p_header">diff --git a/arch/sparc/kernel/traps_64.c b/arch/sparc/kernel/traps_64.c</span>
<span class="p_header">index d21cd62..29db583 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/traps_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/traps_64.c</span>
<span class="p_chunk">@@ -351,12 +351,31 @@</span> <span class="p_context"> void sun4v_data_access_exception(struct pt_regs *regs, unsigned long addr, unsig</span>
 		regs-&gt;tpc &amp;= 0xffffffff;
 		regs-&gt;tnpc &amp;= 0xffffffff;
 	}
<span class="p_del">-	info.si_signo = SIGSEGV;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* MCD (Memory Corruption Detection) disabled trap (TT=0x19) in HV</span>
<span class="p_add">+	 * is vectored thorugh data access exception trap with fault type</span>
<span class="p_add">+	 * set to HV_FAULT_TYPE_MCD_DIS. Check for MCD disabled trap</span>
<span class="p_add">+	 */</span>
 	info.si_errno = 0;
<span class="p_del">-	info.si_code = SEGV_MAPERR;</span>
 	info.si_addr = (void __user *) addr;
 	info.si_trapno = 0;
<span class="p_del">-	force_sig_info(SIGSEGV, &amp;info, current);</span>
<span class="p_add">+	switch (type) {</span>
<span class="p_add">+	case HV_FAULT_TYPE_INV_ASI:</span>
<span class="p_add">+		info.si_signo = SIGILL;</span>
<span class="p_add">+		info.si_code = ILL_ILLADR;</span>
<span class="p_add">+		force_sig_info(SIGILL, &amp;info, current);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HV_FAULT_TYPE_MCD_DIS:</span>
<span class="p_add">+		info.si_signo = SIGSEGV;</span>
<span class="p_add">+		info.si_code = SEGV_ACCADI;</span>
<span class="p_add">+		force_sig_info(SIGSEGV, &amp;info, current);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		info.si_signo = SIGSEGV;</span>
<span class="p_add">+		info.si_code = SEGV_MAPERR;</span>
<span class="p_add">+		force_sig_info(SIGSEGV, &amp;info, current);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 }
 
 void sun4v_data_access_exception_tl1(struct pt_regs *regs, unsigned long addr, unsigned long type_ctx)
<span class="p_chunk">@@ -1801,6 +1820,7 @@</span> <span class="p_context"> struct sun4v_error_entry {</span>
 #define SUN4V_ERR_ATTRS_ASI		0x00000080
 #define SUN4V_ERR_ATTRS_PRIV_REG	0x00000100
 #define SUN4V_ERR_ATTRS_SPSTATE_MSK	0x00000600
<span class="p_add">+#define SUN4V_ERR_ATTRS_MCD		0x00000800</span>
 #define SUN4V_ERR_ATTRS_SPSTATE_SHFT	9
 #define SUN4V_ERR_ATTRS_MODE_MSK	0x03000000
 #define SUN4V_ERR_ATTRS_MODE_SHFT	24
<span class="p_chunk">@@ -1998,6 +2018,36 @@</span> <span class="p_context"> static void sun4v_log_error(struct pt_regs *regs, struct sun4v_error_entry *ent,</span>
 	}
 }
 
<span class="p_add">+/* Handle memory corruption detected error which is vectored in</span>
<span class="p_add">+ * through resumable error trap.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void do_mcd_err(struct pt_regs *regs, struct sun4v_error_entry ent)</span>
<span class="p_add">+{</span>
<span class="p_add">+	siginfo_t info;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (notify_die(DIE_TRAP, &quot;MCD error&quot;, regs,</span>
<span class="p_add">+		       0, 0x34, SIGSEGV) == NOTIFY_STOP)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (regs-&gt;tstate &amp; TSTATE_PRIV) {</span>
<span class="p_add">+		/* ADI tag mismatch in kernel mode means illegal access to</span>
<span class="p_add">+		 * kernel memory through rogue means potentially.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		pr_emerg(&quot;mcd_err: ADI tag mismatch in kernel at &quot;</span>
<span class="p_add">+			&quot;ADDR[%016llx], going.\n&quot;, ent.err_raddr);</span>
<span class="p_add">+		die_if_kernel(&quot;MCD error&quot;, regs);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Send SIGSEGV to the userspace process with the right code</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	info.si_signo = SIGSEGV;</span>
<span class="p_add">+	info.si_errno = 0;</span>
<span class="p_add">+	info.si_code = SEGV_ADIDERR;</span>
<span class="p_add">+	info.si_addr = (void __user *)ent.err_raddr;</span>
<span class="p_add">+	info.si_trapno = 0;</span>
<span class="p_add">+	force_sig_info(SIGSEGV, &amp;info, current);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* We run with %pil set to PIL_NORMAL_MAX and PSTATE_IE enabled in %pstate.
  * Log the event and clear the first word of the entry.
  */
<span class="p_chunk">@@ -2035,6 +2085,14 @@</span> <span class="p_context"> void sun4v_resum_error(struct pt_regs *regs, unsigned long offset)</span>
 		goto out;
 	}
 
<span class="p_add">+	/* If this is a memory corruption detected error, call the</span>
<span class="p_add">+	 * handler</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (local_copy.err_attrs &amp; SUN4V_ERR_ATTRS_MCD) {</span>
<span class="p_add">+		do_mcd_err(regs, local_copy);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	sun4v_log_error(regs, &amp;local_copy, cpu,
 			KERN_ERR &quot;RESUMABLE ERROR&quot;,
 			&amp;sun4v_resum_oflow_cnt);
<span class="p_chunk">@@ -2531,6 +2589,38 @@</span> <span class="p_context"> void sun4v_do_mna(struct pt_regs *regs, unsigned long addr, unsigned long type_c</span>
 	force_sig_info(SIGBUS, &amp;info, current);
 }
 
<span class="p_add">+void sun4v_mem_corrupt_detect_precise(struct pt_regs *regs, unsigned long addr,</span>
<span class="p_add">+				      unsigned long context)</span>
<span class="p_add">+{</span>
<span class="p_add">+	siginfo_t info;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!ADI_CAPABLE()) {</span>
<span class="p_add">+		bad_trap(regs, 0x1a);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (notify_die(DIE_TRAP, &quot;memory corruption precise exception&quot;, regs,</span>
<span class="p_add">+		       0, 0x8, SIGSEGV) == NOTIFY_STOP)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (regs-&gt;tstate &amp; TSTATE_PRIV) {</span>
<span class="p_add">+		pr_emerg(&quot;sun4v_mem_corrupt_detect_precise: ADDR[%016lx] &quot;</span>
<span class="p_add">+			&quot;CTX[%lx], going.\n&quot;, addr, context);</span>
<span class="p_add">+		die_if_kernel(&quot;MCD precise&quot;, regs);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (test_thread_flag(TIF_32BIT)) {</span>
<span class="p_add">+		regs-&gt;tpc &amp;= 0xffffffff;</span>
<span class="p_add">+		regs-&gt;tnpc &amp;= 0xffffffff;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	info.si_signo = SIGSEGV;</span>
<span class="p_add">+	info.si_code = SEGV_ADIPERR;</span>
<span class="p_add">+	info.si_errno = 0;</span>
<span class="p_add">+	info.si_addr = (void __user *) addr;</span>
<span class="p_add">+	info.si_trapno = 0;</span>
<span class="p_add">+	force_sig_info(SIGSEGV, &amp;info, current);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void do_privop(struct pt_regs *regs)
 {
 	enum ctx_state prev_state = exception_enter();
<span class="p_header">diff --git a/arch/sparc/kernel/ttable_64.S b/arch/sparc/kernel/ttable_64.S</span>
<span class="p_header">index c6dfdaa..2343bf0 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/ttable_64.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/ttable_64.S</span>
<span class="p_chunk">@@ -25,8 +25,10 @@</span> <span class="p_context"> tl0_ill:	membar #Sync</span>
 		TRAP_7INSNS(do_illegal_instruction)
 tl0_privop:	TRAP(do_privop)
 tl0_resv012:	BTRAP(0x12) BTRAP(0x13) BTRAP(0x14) BTRAP(0x15) BTRAP(0x16) BTRAP(0x17)
<span class="p_del">-tl0_resv018:	BTRAP(0x18) BTRAP(0x19) BTRAP(0x1a) BTRAP(0x1b) BTRAP(0x1c) BTRAP(0x1d)</span>
<span class="p_del">-tl0_resv01e:	BTRAP(0x1e) BTRAP(0x1f)</span>
<span class="p_add">+tl0_resv018:	BTRAP(0x18) BTRAP(0x19)</span>
<span class="p_add">+tl0_mcd:	SUN4V_MCD_PRECISE</span>
<span class="p_add">+tl0_resv01b:	BTRAP(0x1b)</span>
<span class="p_add">+tl0_resv01c:	BTRAP(0x1c) BTRAP(0x1d)	BTRAP(0x1e) BTRAP(0x1f)</span>
 tl0_fpdis:	TRAP_NOSAVE(do_fpdis)
 tl0_fpieee:	TRAP_SAVEFPU(do_fpieee)
 tl0_fpother:	TRAP_NOSAVE(do_fpother_check_fitos)
<span class="p_header">diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="p_header">index 00bad77..5a80219 100644</span>
<span class="p_header">--- a/include/linux/mm.h</span>
<span class="p_header">+++ b/include/linux/mm.h</span>
<span class="p_chunk">@@ -168,6 +168,8 @@</span> <span class="p_context"> extern unsigned int kobjsize(const void *objp);</span>
 # define VM_GROWSUP	VM_ARCH_1
 #elif defined(CONFIG_IA64)
 # define VM_GROWSUP	VM_ARCH_1
<span class="p_add">+#elif defined(CONFIG_SPARC64)</span>
<span class="p_add">+# define VM_SPARC_ADI	VM_ARCH_1	/* Uses ADI tag for access control */</span>
 #elif !defined(CONFIG_MMU)
 # define VM_MAPPED_COPY	VM_ARCH_1	/* T if mapped copy of data (nommu mmap) */
 #endif
<span class="p_header">diff --git a/include/uapi/asm-generic/siginfo.h b/include/uapi/asm-generic/siginfo.h</span>
<span class="p_header">index 1e35520..8235d6e 100644</span>
<span class="p_header">--- a/include/uapi/asm-generic/siginfo.h</span>
<span class="p_header">+++ b/include/uapi/asm-generic/siginfo.h</span>
<span class="p_chunk">@@ -206,7 +206,10 @@</span> <span class="p_context"> typedef struct siginfo {</span>
 #define SEGV_MAPERR	(__SI_FAULT|1)	/* address not mapped to object */
 #define SEGV_ACCERR	(__SI_FAULT|2)	/* invalid permissions for mapped object */
 #define SEGV_BNDERR	(__SI_FAULT|3)  /* failed address bound checks */
<span class="p_del">-#define NSIGSEGV	3</span>
<span class="p_add">+#define SEGV_ACCADI	(__SI_FAULT|4)	/* ADI not enabled for mapped object */</span>
<span class="p_add">+#define SEGV_ADIDERR	(__SI_FAULT|5)	/* Disrupting MCD error */</span>
<span class="p_add">+#define SEGV_ADIPERR	(__SI_FAULT|6)	/* Precise MCD exception */</span>
<span class="p_add">+#define NSIGSEGV	6</span>
 
 /*
  * SIGBUS si_codes
<span class="p_header">diff --git a/include/uapi/linux/prctl.h b/include/uapi/linux/prctl.h</span>
<span class="p_header">index a8d0759..422c246 100644</span>
<span class="p_header">--- a/include/uapi/linux/prctl.h</span>
<span class="p_header">+++ b/include/uapi/linux/prctl.h</span>
<span class="p_chunk">@@ -197,4 +197,20 @@</span> <span class="p_context"> struct prctl_mm_map {</span>
 # define PR_CAP_AMBIENT_LOWER		3
 # define PR_CAP_AMBIENT_CLEAR_ALL	4
 
<span class="p_add">+/* SPARC ADI operations, see Documentation/prctl/sparc_adi.txt for details */</span>
<span class="p_add">+#define PR_GET_SPARC_ADICAPS	48</span>
<span class="p_add">+#define PR_SET_SPARC_ADI	49</span>
<span class="p_add">+# define PR_SET_SPARC_ADI_CLEAR	0</span>
<span class="p_add">+# define PR_SET_SPARC_ADI_SET	1</span>
<span class="p_add">+#define PR_ENABLE_SPARC_ADI	50</span>
<span class="p_add">+#define PR_DISABLE_SPARC_ADI	51</span>
<span class="p_add">+#define PR_GET_SPARC_ADI_STATUS	52</span>
<span class="p_add">+</span>
<span class="p_add">+/* Data structure returned by PR_GET_SPARC_ADICAPS */</span>
<span class="p_add">+struct adi_caps {</span>
<span class="p_add">+	__u64 blksz;</span>
<span class="p_add">+	__u64 nbits;</span>
<span class="p_add">+	__u64 ue_on_adi;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 #endif /* _LINUX_PRCTL_H */
<span class="p_header">diff --git a/kernel/sys.c b/kernel/sys.c</span>
<span class="p_header">index 6af9212..fa7b5d9 100644</span>
<span class="p_header">--- a/kernel/sys.c</span>
<span class="p_header">+++ b/kernel/sys.c</span>
<span class="p_chunk">@@ -103,6 +103,21 @@</span> <span class="p_context"></span>
 #ifndef SET_FP_MODE
 # define SET_FP_MODE(a,b)	(-EINVAL)
 #endif
<span class="p_add">+#ifndef GET_SPARC_ADICAPS</span>
<span class="p_add">+# define GET_SPARC_ADICAPS(a)		(-EINVAL)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifndef SET_SPARC_MCDE</span>
<span class="p_add">+# define SET_SPARC_MCDE(a)		(-EINVAL)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifndef ENABLE_SPARC_ADI</span>
<span class="p_add">+# define ENABLE_SPARC_ADI(a, b)		(-EINVAL)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifndef DISABLE_SPARC_ADI</span>
<span class="p_add">+# define DISABLE_SPARC_ADI(a, b)	(-EINVAL)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifndef GET_SPARC_ADI_STATUS</span>
<span class="p_add">+# define GET_SPARC_ADI_STATUS(a)	(-EINVAL)</span>
<span class="p_add">+#endif</span>
 
 /*
  * this is where the system-wide overflow UID and GID are defined, for
<span class="p_chunk">@@ -2266,6 +2281,21 @@</span> <span class="p_context"> SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,</span>
 	case PR_GET_FP_MODE:
 		error = GET_FP_MODE(me);
 		break;
<span class="p_add">+	case PR_GET_SPARC_ADICAPS:</span>
<span class="p_add">+		error = GET_SPARC_ADICAPS(arg2);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case PR_SET_SPARC_ADI:</span>
<span class="p_add">+		error = SET_SPARC_MCDE(arg2);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case PR_ENABLE_SPARC_ADI:</span>
<span class="p_add">+		error = ENABLE_SPARC_ADI(arg2, arg3);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case PR_DISABLE_SPARC_ADI:</span>
<span class="p_add">+		error = DISABLE_SPARC_ADI(arg2, arg3);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case PR_GET_SPARC_ADI_STATUS:</span>
<span class="p_add">+		error = GET_SPARC_ADI_STATUS(arg2);</span>
<span class="p_add">+		break;</span>
 	default:
 		error = -EINVAL;
 		break;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



