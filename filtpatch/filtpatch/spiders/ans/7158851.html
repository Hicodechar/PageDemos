
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3.16.y-ckt,stable] Linux 3.16.7-ckt17 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3.16.y-ckt,stable] Linux 3.16.7-ckt17</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=45061">Luis Henriques</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Sept. 11, 2015, 9:14 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1441962864-29610-2-git-send-email-luis.henriques@canonical.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7158851/mbox/"
   >mbox</a>
|
   <a href="/patch/7158851/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7158851/">/patch/7158851/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 0CB50BEEC1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 11 Sep 2015 09:15:20 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id C61F82085E
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 11 Sep 2015 09:15:09 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 007422085D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 11 Sep 2015 09:14:58 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752043AbbIKJOx (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 11 Sep 2015 05:14:53 -0400
Received: from youngberry.canonical.com ([91.189.89.112]:37901 &quot;EHLO
	youngberry.canonical.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751464AbbIKJO3 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 11 Sep 2015 05:14:29 -0400
Received: from av-217-129-142-138.netvisao.pt ([217.129.142.138]
	helo=localhost) by youngberry.canonical.com with esmtpsa
	(TLS1.0:RSA_AES_128_CBC_SHA1:16) (Exim 4.76)
	(envelope-from &lt;luis.henriques@canonical.com&gt;)
	id 1ZaKPa-0003GK-La; Fri, 11 Sep 2015 09:14:27 +0000
From: Luis Henriques &lt;luis.henriques@canonical.com&gt;
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org,
	kernel-team@lists.ubuntu.com
Cc: lwn@lwn.net
Subject: Re: [3.16.y-ckt stable] Linux 3.16.7-ckt17
Date: Fri, 11 Sep 2015 10:14:24 +0100
Message-Id: &lt;1441962864-29610-2-git-send-email-luis.henriques@canonical.com&gt;
X-Mailer: git-send-email 2.1.4
In-Reply-To: &lt;1441962864-29610-1-git-send-email-luis.henriques@canonical.com&gt;
References: &lt;1441962864-29610-1-git-send-email-luis.henriques@canonical.com&gt;
X-Extended-Stable: 3.16
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=45061">Luis Henriques</a> - Sept. 11, 2015, 9:14 a.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/ABI/testing/ima_policy b/Documentation/ABI/testing/ima_policy</span>
<span class="p_header">index 4c3efe434806..750ab970fa95 100644</span>
<span class="p_header">--- a/Documentation/ABI/testing/ima_policy</span>
<span class="p_header">+++ b/Documentation/ABI/testing/ima_policy</span>
<span class="p_chunk">@@ -20,16 +20,18 @@</span> <span class="p_context"> Description:</span>
 		action: measure | dont_measure | appraise | dont_appraise | audit
 		condition:= base | lsm  [option]
 			base:	[[func=] [mask=] [fsmagic=] [fsuuid=] [uid=]
<span class="p_del">-				 [fowner]]</span>
<span class="p_add">+				[euid=] [fowner=]]</span>
 			lsm:	[[subj_user=] [subj_role=] [subj_type=]
 				 [obj_user=] [obj_role=] [obj_type=]]
 			option:	[[appraise_type=]] [permit_directio]
 
 		base: 	func:= [BPRM_CHECK][MMAP_CHECK][FILE_CHECK][MODULE_CHECK]
<span class="p_del">-			mask:= [MAY_READ] [MAY_WRITE] [MAY_APPEND] [MAY_EXEC]</span>
<span class="p_add">+			mask:= [[^]MAY_READ] [[^]MAY_WRITE] [[^]MAY_APPEND]</span>
<span class="p_add">+			       [[^]MAY_EXEC]</span>
 			fsmagic:= hex value
 			fsuuid:= file system UUID (e.g 8bcbe394-4f13-4144-be8e-5aa9ea2ce2f6)
 			uid:= decimal value
<span class="p_add">+			euid:= decimal value</span>
 			fowner:=decimal value
 		lsm:  	are LSM specific
 		option:	appraise_type:= [imasig]
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 093419a63d5c..eca4145020db 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 16
 SUBLEVEL = 7
<span class="p_del">-EXTRAVERSION =-ckt16</span>
<span class="p_add">+EXTRAVERSION =-ckt17</span>
 NAME = Museum of Fishiegoodies
 
 # *DOCUMENTATION*
<span class="p_header">diff --git a/arch/arm/boot/dts/imx35.dtsi b/arch/arm/boot/dts/imx35.dtsi</span>
<span class="p_header">index 4759abb49436..60988489faf1 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx35.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx35.dtsi</span>
<span class="p_chunk">@@ -277,8 +277,8 @@</span> <span class="p_context"></span>
 			can1: can@53fe4000 {
 				compatible = &quot;fsl,imx35-flexcan&quot;, &quot;fsl,p1010-flexcan&quot;;
 				reg = &lt;0x53fe4000 0x1000&gt;;
<span class="p_del">-				clocks = &lt;&amp;clks 33&gt;;</span>
<span class="p_del">-				clock-names = &quot;ipg&quot;;</span>
<span class="p_add">+				clocks = &lt;&amp;clks 33&gt;, &lt;&amp;clks 33&gt;;</span>
<span class="p_add">+				clock-names = &quot;ipg&quot;, &quot;per&quot;;</span>
 				interrupts = &lt;43&gt;;
 				status = &quot;disabled&quot;;
 			};
<span class="p_chunk">@@ -286,8 +286,8 @@</span> <span class="p_context"></span>
 			can2: can@53fe8000 {
 				compatible = &quot;fsl,imx35-flexcan&quot;, &quot;fsl,p1010-flexcan&quot;;
 				reg = &lt;0x53fe8000 0x1000&gt;;
<span class="p_del">-				clocks = &lt;&amp;clks 34&gt;;</span>
<span class="p_del">-				clock-names = &quot;ipg&quot;;</span>
<span class="p_add">+				clocks = &lt;&amp;clks 34&gt;, &lt;&amp;clks 34&gt;;</span>
<span class="p_add">+				clock-names = &quot;ipg&quot;, &quot;per&quot;;</span>
 				interrupts = &lt;44&gt;;
 				status = &quot;disabled&quot;;
 			};
<span class="p_header">diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_header">index 8fd87a3055bf..4711dd06d7b5 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_chunk">@@ -2452,6 +2452,9 @@</span> <span class="p_context"> static int of_dev_hwmod_lookup(struct device_node *np,</span>
  * registers.  This address is needed early so the OCP registers that
  * are part of the device&#39;s address space can be ioremapped properly.
  *
<span class="p_add">+ * If SYSC access is not needed, the registers will not be remapped</span>
<span class="p_add">+ * and non-availability of MPU access is not treated as an error.</span>
<span class="p_add">+ *</span>
  * Returns 0 on success, -EINVAL if an invalid hwmod is passed, and
  * -ENXIO on absent or invalid register target address space.
  */
<span class="p_chunk">@@ -2466,6 +2469,11 @@</span> <span class="p_context"> static int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data,</span>
 
 	_save_mpu_port_index(oh);
 
<span class="p_add">+	/* if we don&#39;t need sysc access we don&#39;t need to ioremap */</span>
<span class="p_add">+	if (!oh-&gt;class-&gt;sysc)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* we can&#39;t continue without MPU PORT if we need sysc access */</span>
 	if (oh-&gt;_int_flags &amp; _HWMOD_NO_MPU_PORT)
 		return -ENXIO;
 
<span class="p_chunk">@@ -2475,8 +2483,10 @@</span> <span class="p_context"> static int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data,</span>
 			 oh-&gt;name);
 
 		/* Extract the IO space from device tree blob */
<span class="p_del">-		if (!np)</span>
<span class="p_add">+		if (!np) {</span>
<span class="p_add">+			pr_err(&quot;omap_hwmod: %s: no dt node\n&quot;, oh-&gt;name);</span>
 			return -ENXIO;
<span class="p_add">+		}</span>
 
 		va_start = of_iomap(np, index + oh-&gt;mpu_rt_idx);
 	} else {
<span class="p_chunk">@@ -2535,13 +2545,11 @@</span> <span class="p_context"> static int __init _init(struct omap_hwmod *oh, void *data)</span>
 				oh-&gt;name, np-&gt;name);
 	}
 
<span class="p_del">-	if (oh-&gt;class-&gt;sysc) {</span>
<span class="p_del">-		r = _init_mpu_rt_base(oh, NULL, index, np);</span>
<span class="p_del">-		if (r &lt; 0) {</span>
<span class="p_del">-			WARN(1, &quot;omap_hwmod: %s: doesn&#39;t have mpu register target base\n&quot;,</span>
<span class="p_del">-			     oh-&gt;name);</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	r = _init_mpu_rt_base(oh, NULL, index, np);</span>
<span class="p_add">+	if (r &lt; 0) {</span>
<span class="p_add">+		WARN(1, &quot;omap_hwmod: %s: doesn&#39;t have mpu register target base\n&quot;,</span>
<span class="p_add">+		     oh-&gt;name);</span>
<span class="p_add">+		return 0;</span>
 	}
 
 	r = _init_clocks(oh, NULL);
<span class="p_header">diff --git a/arch/arm64/kernel/efi.c b/arch/arm64/kernel/efi.c</span>
<span class="p_header">index 6b6bc795f72d..ddc7e78b51d8 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/efi.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/efi.c</span>
<span class="p_chunk">@@ -98,7 +98,7 @@</span> <span class="p_context"> static int __init uefi_init(void)</span>
 
 	/* Show what we know for posterity */
 	c16 = early_memremap(efi.systab-&gt;fw_vendor,
<span class="p_del">-			     sizeof(vendor));</span>
<span class="p_add">+			     sizeof(vendor) * sizeof(efi_char16_t));</span>
 	if (c16) {
 		for (i = 0; i &lt; (int) sizeof(vendor) - 1 &amp;&amp; *c16; ++i)
 			vendor[i] = c16[i];
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> static int __init uefi_init(void)</span>
 	if (retval == 0)
 		set_bit(EFI_CONFIG_TABLES, &amp;efi.flags);
 
<span class="p_del">-	early_memunmap(c16, sizeof(vendor));</span>
<span class="p_add">+	early_memunmap(c16, sizeof(vendor) * sizeof(efi_char16_t));</span>
 	early_memunmap(efi.systab,  sizeof(efi_system_table_t));
 
 	return retval;
<span class="p_header">diff --git a/arch/arm64/kernel/signal32.c b/arch/arm64/kernel/signal32.c</span>
<span class="p_header">index 070de43fb3b5..3e6ea07a0b0f 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/signal32.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/signal32.c</span>
<span class="p_chunk">@@ -168,7 +168,8 @@</span> <span class="p_context"> int copy_siginfo_to_user32(compat_siginfo_t __user *to, const siginfo_t *from)</span>
 		 * Other callers might not initialize the si_lsb field,
 		 * so check explicitely for the right codes here.
 		 */
<span class="p_del">-		if (from-&gt;si_code == BUS_MCEERR_AR || from-&gt;si_code == BUS_MCEERR_AO)</span>
<span class="p_add">+		if (from-&gt;si_signo == SIGBUS &amp;&amp;</span>
<span class="p_add">+		    (from-&gt;si_code == BUS_MCEERR_AR || from-&gt;si_code == BUS_MCEERR_AO))</span>
 			err |= __put_user(from-&gt;si_addr_lsb, &amp;to-&gt;si_addr_lsb);
 #endif
 		break;
<span class="p_chunk">@@ -195,8 +196,6 @@</span> <span class="p_context"> int copy_siginfo_to_user32(compat_siginfo_t __user *to, const siginfo_t *from)</span>
 
 int copy_siginfo_from_user32(siginfo_t *to, compat_siginfo_t __user *from)
 {
<span class="p_del">-	memset(to, 0, sizeof *to);</span>
<span class="p_del">-</span>
 	if (copy_from_user(to, from, __ARCH_SI_PREAMBLE_SIZE) ||
 	    copy_from_user(to-&gt;_sifields._pad,
 			   from-&gt;_sifields._pad, SI_PAD_SIZE))
<span class="p_header">diff --git a/arch/arm64/kvm/inject_fault.c b/arch/arm64/kvm/inject_fault.c</span>
<span class="p_header">index 81a02a8762b0..86825f8883de 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/inject_fault.c</span>
<span class="p_header">+++ b/arch/arm64/kvm/inject_fault.c</span>
<span class="p_chunk">@@ -168,8 +168,8 @@</span> <span class="p_context"> void kvm_inject_dabt(struct kvm_vcpu *vcpu, unsigned long addr)</span>
 {
 	if (!(vcpu-&gt;arch.hcr_el2 &amp; HCR_RW))
 		inject_abt32(vcpu, false, addr);
<span class="p_del">-</span>
<span class="p_del">-	inject_abt64(vcpu, false, addr);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		inject_abt64(vcpu, false, addr);</span>
 }
 
 /**
<span class="p_chunk">@@ -184,8 +184,8 @@</span> <span class="p_context"> void kvm_inject_pabt(struct kvm_vcpu *vcpu, unsigned long addr)</span>
 {
 	if (!(vcpu-&gt;arch.hcr_el2 &amp; HCR_RW))
 		inject_abt32(vcpu, true, addr);
<span class="p_del">-</span>
<span class="p_del">-	inject_abt64(vcpu, true, addr);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		inject_abt64(vcpu, true, addr);</span>
 }
 
 /**
<span class="p_chunk">@@ -198,6 +198,6 @@</span> <span class="p_context"> void kvm_inject_undefined(struct kvm_vcpu *vcpu)</span>
 {
 	if (!(vcpu-&gt;arch.hcr_el2 &amp; HCR_RW))
 		inject_undef32(vcpu);
<span class="p_del">-</span>
<span class="p_del">-	inject_undef64(vcpu);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		inject_undef64(vcpu);</span>
 }
<span class="p_header">diff --git a/arch/avr32/mach-at32ap/clock.c b/arch/avr32/mach-at32ap/clock.c</span>
<span class="p_header">index 23b1a97fae7a..52c179bec0cc 100644</span>
<span class="p_header">--- a/arch/avr32/mach-at32ap/clock.c</span>
<span class="p_header">+++ b/arch/avr32/mach-at32ap/clock.c</span>
<span class="p_chunk">@@ -80,6 +80,9 @@</span> <span class="p_context"> int clk_enable(struct clk *clk)</span>
 {
 	unsigned long flags;
 
<span class="p_add">+	if (!clk)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;clk_lock, flags);
 	__clk_enable(clk);
 	spin_unlock_irqrestore(&amp;clk_lock, flags);
<span class="p_chunk">@@ -106,6 +109,9 @@</span> <span class="p_context"> void clk_disable(struct clk *clk)</span>
 {
 	unsigned long flags;
 
<span class="p_add">+	if (IS_ERR_OR_NULL(clk))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;clk_lock, flags);
 	__clk_disable(clk);
 	spin_unlock_irqrestore(&amp;clk_lock, flags);
<span class="p_chunk">@@ -117,6 +123,9 @@</span> <span class="p_context"> unsigned long clk_get_rate(struct clk *clk)</span>
 	unsigned long flags;
 	unsigned long rate;
 
<span class="p_add">+	if (!clk)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;clk_lock, flags);
 	rate = clk-&gt;get_rate(clk);
 	spin_unlock_irqrestore(&amp;clk_lock, flags);
<span class="p_chunk">@@ -129,6 +138,9 @@</span> <span class="p_context"> long clk_round_rate(struct clk *clk, unsigned long rate)</span>
 {
 	unsigned long flags, actual_rate;
 
<span class="p_add">+	if (!clk)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	if (!clk-&gt;set_rate)
 		return -ENOSYS;
 
<span class="p_chunk">@@ -145,6 +157,9 @@</span> <span class="p_context"> int clk_set_rate(struct clk *clk, unsigned long rate)</span>
 	unsigned long flags;
 	long ret;
 
<span class="p_add">+	if (!clk)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	if (!clk-&gt;set_rate)
 		return -ENOSYS;
 
<span class="p_chunk">@@ -161,6 +176,9 @@</span> <span class="p_context"> int clk_set_parent(struct clk *clk, struct clk *parent)</span>
 	unsigned long flags;
 	int ret;
 
<span class="p_add">+	if (!clk)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	if (!clk-&gt;set_parent)
 		return -ENOSYS;
 
<span class="p_chunk">@@ -174,7 +192,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(clk_set_parent);</span>
 
 struct clk *clk_get_parent(struct clk *clk)
 {
<span class="p_del">-	return clk-&gt;parent;</span>
<span class="p_add">+	return !clk ? NULL : clk-&gt;parent;</span>
 }
 EXPORT_SYMBOL(clk_get_parent);
 
<span class="p_header">diff --git a/arch/mips/include/asm/pgtable.h b/arch/mips/include/asm/pgtable.h</span>
<span class="p_header">index 539ddd148bbb..784b58cdab3e 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -152,8 +152,39 @@</span> <span class="p_context"> static inline void set_pte(pte_t *ptep, pte_t pteval)</span>
 		 * Make sure the buddy is global too (if it&#39;s !none,
 		 * it better already be global)
 		 */
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * For SMP, multiple CPUs can race, so we need to do</span>
<span class="p_add">+		 * this atomically.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+#ifdef CONFIG_64BIT</span>
<span class="p_add">+#define LL_INSN &quot;lld&quot;</span>
<span class="p_add">+#define SC_INSN &quot;scd&quot;</span>
<span class="p_add">+#else /* CONFIG_32BIT */</span>
<span class="p_add">+#define LL_INSN &quot;ll&quot;</span>
<span class="p_add">+#define SC_INSN &quot;sc&quot;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+		unsigned long page_global = _PAGE_GLOBAL;</span>
<span class="p_add">+		unsigned long tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+		__asm__ __volatile__ (</span>
<span class="p_add">+			&quot;	.set	push\n&quot;</span>
<span class="p_add">+			&quot;	.set	noreorder\n&quot;</span>
<span class="p_add">+			&quot;1:	&quot; LL_INSN &quot;	%[tmp], %[buddy]\n&quot;</span>
<span class="p_add">+			&quot;	bnez	%[tmp], 2f\n&quot;</span>
<span class="p_add">+			&quot;	 or	%[tmp], %[tmp], %[global]\n&quot;</span>
<span class="p_add">+			&quot;	&quot; SC_INSN &quot;	%[tmp], %[buddy]\n&quot;</span>
<span class="p_add">+			&quot;	beqz	%[tmp], 1b\n&quot;</span>
<span class="p_add">+			&quot;	 nop\n&quot;</span>
<span class="p_add">+			&quot;2:\n&quot;</span>
<span class="p_add">+			&quot;	.set pop&quot;</span>
<span class="p_add">+			: [buddy] &quot;+m&quot; (buddy-&gt;pte),</span>
<span class="p_add">+			  [tmp] &quot;=&amp;r&quot; (tmp)</span>
<span class="p_add">+			: [global] &quot;r&quot; (page_global));</span>
<span class="p_add">+#else /* !CONFIG_SMP */</span>
 		if (pte_none(*buddy))
 			pte_val(*buddy) = pte_val(*buddy) | _PAGE_GLOBAL;
<span class="p_add">+#endif /* CONFIG_SMP */</span>
 	}
 #endif
 }
<span class="p_header">diff --git a/arch/mips/include/asm/stackframe.h b/arch/mips/include/asm/stackframe.h</span>
<span class="p_header">index b188c797565c..0562a24dc615 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/stackframe.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/stackframe.h</span>
<span class="p_chunk">@@ -152,6 +152,31 @@</span> <span class="p_context"></span>
 		.set	noreorder
 		bltz	k0, 8f
 		 move	k1, sp
<span class="p_add">+#ifdef CONFIG_EVA</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Flush interAptiv&#39;s Return Prediction Stack (RPS) by writing</span>
<span class="p_add">+		 * EntryHi. Toggling Config7.RPS is slower and less portable.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * The RPS isn&#39;t automatically flushed when exceptions are</span>
<span class="p_add">+		 * taken, which can result in kernel mode speculative accesses</span>
<span class="p_add">+		 * to user addresses if the RPS mispredicts. That&#39;s harmless</span>
<span class="p_add">+		 * when user and kernel share the same address space, but with</span>
<span class="p_add">+		 * EVA the same user segments may be unmapped to kernel mode,</span>
<span class="p_add">+		 * even containing sensitive MMIO regions or invalid memory.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * This can happen when the kernel sets the return address to</span>
<span class="p_add">+		 * ret_from_* and jr&#39;s to the exception handler, which looks</span>
<span class="p_add">+		 * more like a tail call than a function call. If nested calls</span>
<span class="p_add">+		 * don&#39;t evict the last user address in the RPS, it will</span>
<span class="p_add">+		 * mispredict the return and fetch from a user controlled</span>
<span class="p_add">+		 * address into the icache.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * More recent EVA-capable cores with MAAR to restrict</span>
<span class="p_add">+		 * speculative accesses aren&#39;t affected.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		MFC0	k0, CP0_ENTRYHI</span>
<span class="p_add">+		MTC0	k0, CP0_ENTRYHI</span>
<span class="p_add">+#endif</span>
 		.set	reorder
 		/* Called from user mode, new stack. */
 		get_saved_sp
<span class="p_header">diff --git a/arch/mips/kernel/mips-mt-fpaff.c b/arch/mips/kernel/mips-mt-fpaff.c</span>
<span class="p_header">index 362bb3707e62..116c67a5320a 100644</span>
<span class="p_header">--- a/arch/mips/kernel/mips-mt-fpaff.c</span>
<span class="p_header">+++ b/arch/mips/kernel/mips-mt-fpaff.c</span>
<span class="p_chunk">@@ -154,7 +154,7 @@</span> <span class="p_context"> asmlinkage long mipsmt_sys_sched_getaffinity(pid_t pid, unsigned int len,</span>
 				      unsigned long __user *user_mask_ptr)
 {
 	unsigned int real_len;
<span class="p_del">-	cpumask_t mask;</span>
<span class="p_add">+	cpumask_t allowed, mask;</span>
 	int retval;
 	struct task_struct *p;
 
<span class="p_chunk">@@ -173,7 +173,8 @@</span> <span class="p_context"> asmlinkage long mipsmt_sys_sched_getaffinity(pid_t pid, unsigned int len,</span>
 	if (retval)
 		goto out_unlock;
 
<span class="p_del">-	cpumask_and(&amp;mask, &amp;p-&gt;thread.user_cpus_allowed, cpu_possible_mask);</span>
<span class="p_add">+	cpumask_or(&amp;allowed, &amp;p-&gt;thread.user_cpus_allowed, &amp;p-&gt;cpus_allowed);</span>
<span class="p_add">+	cpumask_and(&amp;mask, &amp;allowed, cpu_active_mask);</span>
 
 out_unlock:
 	read_unlock(&amp;tasklist_lock);
<span class="p_header">diff --git a/arch/mips/kernel/scall64-64.S b/arch/mips/kernel/scall64-64.S</span>
<span class="p_header">index be2fedd4ae33..b204352a7d56 100644</span>
<span class="p_header">--- a/arch/mips/kernel/scall64-64.S</span>
<span class="p_header">+++ b/arch/mips/kernel/scall64-64.S</span>
<span class="p_chunk">@@ -80,7 +80,7 @@</span> <span class="p_context"> syscall_trace_entry:</span>
 	SAVE_STATIC
 	move	s0, t2
 	move	a0, sp
<span class="p_del">-	daddiu	a1, v0, __NR_64_Linux</span>
<span class="p_add">+	move	a1, v0</span>
 	jal	syscall_trace_enter
 
 	bltz	v0, 2f			# seccomp failed? Skip syscall
<span class="p_header">diff --git a/arch/mips/kernel/scall64-n32.S b/arch/mips/kernel/scall64-n32.S</span>
<span class="p_header">index c1dbcda4b816..47dd5f9016c1 100644</span>
<span class="p_header">--- a/arch/mips/kernel/scall64-n32.S</span>
<span class="p_header">+++ b/arch/mips/kernel/scall64-n32.S</span>
<span class="p_chunk">@@ -72,7 +72,7 @@</span> <span class="p_context"> n32_syscall_trace_entry:</span>
 	SAVE_STATIC
 	move	s0, t2
 	move	a0, sp
<span class="p_del">-	daddiu	a1, v0, __NR_N32_Linux</span>
<span class="p_add">+	move	a1, v0</span>
 	jal	syscall_trace_enter
 
 	bltz	v0, 2f			# seccomp failed? Skip syscall
<span class="p_header">diff --git a/arch/mips/kernel/signal32.c b/arch/mips/kernel/signal32.c</span>
<span class="p_header">index bae2e6ee2109..6999c461d844 100644</span>
<span class="p_header">--- a/arch/mips/kernel/signal32.c</span>
<span class="p_header">+++ b/arch/mips/kernel/signal32.c</span>
<span class="p_chunk">@@ -409,8 +409,6 @@</span> <span class="p_context"> int copy_siginfo_to_user32(compat_siginfo_t __user *to, const siginfo_t *from)</span>
 
 int copy_siginfo_from_user32(siginfo_t *to, compat_siginfo_t __user *from)
 {
<span class="p_del">-	memset(to, 0, sizeof *to);</span>
<span class="p_del">-</span>
 	if (copy_from_user(to, from, 3*sizeof(int)) ||
 	    copy_from_user(to-&gt;_sifields._pad,
 			   from-&gt;_sifields._pad, SI_PAD_SIZE32))
<span class="p_header">diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c</span>
<span class="p_header">index c65062a6ff23..027fefba8b96 100644</span>
<span class="p_header">--- a/arch/mips/kernel/traps.c</span>
<span class="p_header">+++ b/arch/mips/kernel/traps.c</span>
<span class="p_chunk">@@ -189,6 +189,7 @@</span> <span class="p_context"> static void show_stacktrace(struct task_struct *task,</span>
 void show_stack(struct task_struct *task, unsigned long *sp)
 {
 	struct pt_regs regs;
<span class="p_add">+	mm_segment_t old_fs = get_fs();</span>
 	if (sp) {
 		regs.regs[29] = (unsigned long)sp;
 		regs.regs[31] = 0;
<span class="p_chunk">@@ -207,7 +208,13 @@</span> <span class="p_context"> void show_stack(struct task_struct *task, unsigned long *sp)</span>
 			prepare_frametrace(&amp;regs);
 		}
 	}
<span class="p_add">+	/*</span>
<span class="p_add">+	 * show_stack() deals exclusively with kernel mode, so be sure to access</span>
<span class="p_add">+	 * the stack in the kernel (not user) address space.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	set_fs(KERNEL_DS);</span>
 	show_stacktrace(task, &amp;regs);
<span class="p_add">+	set_fs(old_fs);</span>
 }
 
 static void show_code(unsigned int __user *pc)
<span class="p_chunk">@@ -1338,6 +1345,7 @@</span> <span class="p_context"> asmlinkage void do_mcheck(struct pt_regs *regs)</span>
 	const int field = 2 * sizeof(unsigned long);
 	int multi_match = regs-&gt;cp0_status &amp; ST0_TS;
 	enum ctx_state prev_state;
<span class="p_add">+	mm_segment_t old_fs = get_fs();</span>
 
 	prev_state = exception_enter();
 	show_regs(regs);
<span class="p_chunk">@@ -1352,8 +1360,13 @@</span> <span class="p_context"> asmlinkage void do_mcheck(struct pt_regs *regs)</span>
 		dump_tlb_all();
 	}
 
<span class="p_add">+	if (!user_mode(regs))</span>
<span class="p_add">+		set_fs(KERNEL_DS);</span>
<span class="p_add">+</span>
 	show_code((unsigned int __user *) regs-&gt;cp0_epc);
 
<span class="p_add">+	set_fs(old_fs);</span>
<span class="p_add">+</span>
 	/*
 	 * Some chips may have other causes of machine check (e.g. SB1
 	 * graduation timer)
<span class="p_header">diff --git a/arch/mips/mti-malta/malta-time.c b/arch/mips/mti-malta/malta-time.c</span>
<span class="p_header">index 3778a359f3ad..38748da2a9d6 100644</span>
<span class="p_header">--- a/arch/mips/mti-malta/malta-time.c</span>
<span class="p_header">+++ b/arch/mips/mti-malta/malta-time.c</span>
<span class="p_chunk">@@ -158,14 +158,17 @@</span> <span class="p_context"> unsigned int get_c0_compare_int(void)</span>
 
 static void __init init_rtc(void)
 {
<span class="p_del">-	/* stop the clock whilst setting it up */</span>
<span class="p_del">-	CMOS_WRITE(RTC_SET | RTC_24H, RTC_CONTROL);</span>
<span class="p_add">+	unsigned char freq, ctrl;</span>
 
<span class="p_del">-	/* 32KHz time base */</span>
<span class="p_del">-	CMOS_WRITE(RTC_REF_CLCK_32KHZ, RTC_FREQ_SELECT);</span>
<span class="p_add">+	/* Set 32KHz time base if not already set */</span>
<span class="p_add">+	freq = CMOS_READ(RTC_FREQ_SELECT);</span>
<span class="p_add">+	if ((freq &amp; RTC_DIV_CTL) != RTC_REF_CLCK_32KHZ)</span>
<span class="p_add">+		CMOS_WRITE(RTC_REF_CLCK_32KHZ, RTC_FREQ_SELECT);</span>
 
<span class="p_del">-	/* start the clock */</span>
<span class="p_del">-	CMOS_WRITE(RTC_24H, RTC_CONTROL);</span>
<span class="p_add">+	/* Ensure SET bit is clear so RTC can run */</span>
<span class="p_add">+	ctrl = CMOS_READ(RTC_CONTROL);</span>
<span class="p_add">+	if (ctrl &amp; RTC_SET)</span>
<span class="p_add">+		CMOS_WRITE(ctrl &amp; ~RTC_SET, RTC_CONTROL);</span>
 }
 
 void __init plat_time_init(void)
<span class="p_header">diff --git a/arch/powerpc/kernel/signal_32.c b/arch/powerpc/kernel/signal_32.c</span>
<span class="p_header">index 1bc5a1755ed4..84d9e9bc6415 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/signal_32.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/signal_32.c</span>
<span class="p_chunk">@@ -966,8 +966,6 @@</span> <span class="p_context"> int copy_siginfo_to_user32(struct compat_siginfo __user *d, const siginfo_t *s)</span>
 
 int copy_siginfo_from_user32(siginfo_t *to, struct compat_siginfo __user *from)
 {
<span class="p_del">-	memset(to, 0, sizeof *to);</span>
<span class="p_del">-</span>
 	if (copy_from_user(to, from, 3*sizeof(int)) ||
 	    copy_from_user(to-&gt;_sifields._pad,
 			   from-&gt;_sifields._pad, SI_PAD_SIZE32))
<span class="p_header">diff --git a/arch/s390/hypfs/inode.c b/arch/s390/hypfs/inode.c</span>
<span class="p_header">index c952b981e4f2..e86bbf105bdb 100644</span>
<span class="p_header">--- a/arch/s390/hypfs/inode.c</span>
<span class="p_header">+++ b/arch/s390/hypfs/inode.c</span>
<span class="p_chunk">@@ -461,8 +461,6 @@</span> <span class="p_context"> static const struct super_operations hypfs_s_ops = {</span>
 	.show_options	= hypfs_show_options,
 };
 
<span class="p_del">-static struct kobject *s390_kobj;</span>
<span class="p_del">-</span>
 static int __init hypfs_init(void)
 {
 	int rc;
<span class="p_chunk">@@ -482,18 +480,16 @@</span> <span class="p_context"> static int __init hypfs_init(void)</span>
 		rc = -ENODATA;
 		goto fail_hypfs_vm_exit;
 	}
<span class="p_del">-	s390_kobj = kobject_create_and_add(&quot;s390&quot;, hypervisor_kobj);</span>
<span class="p_del">-	if (!s390_kobj) {</span>
<span class="p_del">-		rc = -ENOMEM;</span>
<span class="p_add">+	rc = sysfs_create_mount_point(hypervisor_kobj, &quot;s390&quot;);</span>
<span class="p_add">+	if (rc)</span>
 		goto fail_hypfs_sprp_exit;
<span class="p_del">-	}</span>
 	rc = register_filesystem(&amp;hypfs_type);
 	if (rc)
 		goto fail_filesystem;
 	return 0;
 
 fail_filesystem:
<span class="p_del">-	kobject_put(s390_kobj);</span>
<span class="p_add">+	sysfs_remove_mount_point(hypervisor_kobj, &quot;s390&quot;);</span>
 fail_hypfs_sprp_exit:
 	hypfs_sprp_exit();
 fail_hypfs_vm_exit:
<span class="p_chunk">@@ -509,7 +505,7 @@</span> <span class="p_context"> fail_dbfs_exit:</span>
 static void __exit hypfs_exit(void)
 {
 	unregister_filesystem(&amp;hypfs_type);
<span class="p_del">-	kobject_put(s390_kobj);</span>
<span class="p_add">+	sysfs_remove_mount_point(hypervisor_kobj, &quot;s390&quot;);</span>
 	hypfs_sprp_exit();
 	hypfs_vm_exit();
 	hypfs_diag_exit();
<span class="p_header">diff --git a/arch/sparc/include/asm/visasm.h b/arch/sparc/include/asm/visasm.h</span>
<span class="p_header">index 1f0aa2024e94..6424249d5f78 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/visasm.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/visasm.h</span>
<span class="p_chunk">@@ -28,16 +28,10 @@</span> <span class="p_context"></span>
  * Must preserve %o5 between VISEntryHalf and VISExitHalf */
 
 #define VISEntryHalf					\
<span class="p_del">-	rd		%fprs, %o5;			\</span>
<span class="p_del">-	andcc		%o5, FPRS_FEF, %g0;		\</span>
<span class="p_del">-	be,pt		%icc, 297f;			\</span>
<span class="p_del">-	 sethi		%hi(298f), %g7;			\</span>
<span class="p_del">-	sethi		%hi(VISenterhalf), %g1;		\</span>
<span class="p_del">-	jmpl		%g1 + %lo(VISenterhalf), %g0;	\</span>
<span class="p_del">-	 or		%g7, %lo(298f), %g7;		\</span>
<span class="p_del">-	clr		%o5;				\</span>
<span class="p_del">-297:	wr		%o5, FPRS_FEF, %fprs;		\</span>
<span class="p_del">-298:</span>
<span class="p_add">+	VISEntry</span>
<span class="p_add">+</span>
<span class="p_add">+#define VISExitHalf					\</span>
<span class="p_add">+	VISExit</span>
 
 #define VISEntryHalfFast(fail_label)			\
 	rd		%fprs, %o5;			\
<span class="p_chunk">@@ -47,7 +41,7 @@</span> <span class="p_context"></span>
 	ba,a,pt		%xcc, fail_label;		\
 297:	wr		%o5, FPRS_FEF, %fprs;
 
<span class="p_del">-#define VISExitHalf					\</span>
<span class="p_add">+#define VISExitHalfFast					\</span>
 	wr		%o5, 0, %fprs;
 
 #ifndef __ASSEMBLY__
<span class="p_header">diff --git a/arch/sparc/lib/NG4memcpy.S b/arch/sparc/lib/NG4memcpy.S</span>
<span class="p_header">index 140527a20e7d..83aeeb1dffdb 100644</span>
<span class="p_header">--- a/arch/sparc/lib/NG4memcpy.S</span>
<span class="p_header">+++ b/arch/sparc/lib/NG4memcpy.S</span>
<span class="p_chunk">@@ -240,8 +240,11 @@</span> <span class="p_context"> FUNC_NAME:	/* %o0=dst, %o1=src, %o2=len */</span>
 	add		%o0, 0x40, %o0
 	bne,pt		%icc, 1b
 	 LOAD(prefetch, %g1 + 0x200, #n_reads_strong)
<span class="p_add">+#ifdef NON_USER_COPY</span>
<span class="p_add">+	VISExitHalfFast</span>
<span class="p_add">+#else</span>
 	VISExitHalf
<span class="p_del">-</span>
<span class="p_add">+#endif</span>
 	brz,pn		%o2, .Lexit
 	 cmp		%o2, 19
 	ble,pn		%icc, .Lsmall_unaligned
<span class="p_header">diff --git a/arch/sparc/lib/VISsave.S b/arch/sparc/lib/VISsave.S</span>
<span class="p_header">index b320ae9e2e2e..a063d84336d6 100644</span>
<span class="p_header">--- a/arch/sparc/lib/VISsave.S</span>
<span class="p_header">+++ b/arch/sparc/lib/VISsave.S</span>
<span class="p_chunk">@@ -44,9 +44,8 @@</span> <span class="p_context"> vis1:	ldub		[%g6 + TI_FPSAVED], %g3</span>
 
 	 stx		%g3, [%g6 + TI_GSR]
 2:	add		%g6, %g1, %g3
<span class="p_del">-	cmp		%o5, FPRS_DU</span>
<span class="p_del">-	be,pn		%icc, 6f</span>
<span class="p_del">-	 sll		%g1, 3, %g1</span>
<span class="p_add">+	mov		FPRS_DU | FPRS_DL | FPRS_FEF, %o5</span>
<span class="p_add">+	sll		%g1, 3, %g1</span>
 	stb		%o5, [%g3 + TI_FPSAVED]
 	rd		%gsr, %g2
 	add		%g6, %g1, %g3
<span class="p_chunk">@@ -80,65 +79,3 @@</span> <span class="p_context"> vis1:	ldub		[%g6 + TI_FPSAVED], %g3</span>
 	.align		32
 80:	jmpl		%g7 + %g0, %g0
 	 nop
<span class="p_del">-</span>
<span class="p_del">-6:	ldub		[%g3 + TI_FPSAVED], %o5</span>
<span class="p_del">-	or		%o5, FPRS_DU, %o5</span>
<span class="p_del">-	add		%g6, TI_FPREGS+0x80, %g2</span>
<span class="p_del">-	stb		%o5, [%g3 + TI_FPSAVED]</span>
<span class="p_del">-</span>
<span class="p_del">-	sll		%g1, 5, %g1</span>
<span class="p_del">-	add		%g6, TI_FPREGS+0xc0, %g3</span>
<span class="p_del">-	wr		%g0, FPRS_FEF, %fprs</span>
<span class="p_del">-	membar		#Sync</span>
<span class="p_del">-	stda		%f32, [%g2 + %g1] ASI_BLK_P</span>
<span class="p_del">-	stda		%f48, [%g3 + %g1] ASI_BLK_P</span>
<span class="p_del">-	membar		#Sync</span>
<span class="p_del">-	ba,pt		%xcc, 80f</span>
<span class="p_del">-	 nop</span>
<span class="p_del">-</span>
<span class="p_del">-	.align		32</span>
<span class="p_del">-80:	jmpl		%g7 + %g0, %g0</span>
<span class="p_del">-	 nop</span>
<span class="p_del">-</span>
<span class="p_del">-	.align		32</span>
<span class="p_del">-VISenterhalf:</span>
<span class="p_del">-	ldub		[%g6 + TI_FPDEPTH], %g1</span>
<span class="p_del">-	brnz,a,pn	%g1, 1f</span>
<span class="p_del">-	 cmp		%g1, 1</span>
<span class="p_del">-	stb		%g0, [%g6 + TI_FPSAVED]</span>
<span class="p_del">-	stx		%fsr, [%g6 + TI_XFSR]</span>
<span class="p_del">-	clr		%o5</span>
<span class="p_del">-	jmpl		%g7 + %g0, %g0</span>
<span class="p_del">-	 wr		%g0, FPRS_FEF, %fprs</span>
<span class="p_del">-</span>
<span class="p_del">-1:	bne,pn		%icc, 2f</span>
<span class="p_del">-	 srl		%g1, 1, %g1</span>
<span class="p_del">-	ba,pt		%xcc, vis1</span>
<span class="p_del">-	 sub		%g7, 8, %g7</span>
<span class="p_del">-2:	addcc		%g6, %g1, %g3</span>
<span class="p_del">-	sll		%g1, 3, %g1</span>
<span class="p_del">-	andn		%o5, FPRS_DU, %g2</span>
<span class="p_del">-	stb		%g2, [%g3 + TI_FPSAVED]</span>
<span class="p_del">-</span>
<span class="p_del">-	rd		%gsr, %g2</span>
<span class="p_del">-	add		%g6, %g1, %g3</span>
<span class="p_del">-	stx		%g2, [%g3 + TI_GSR]</span>
<span class="p_del">-	add		%g6, %g1, %g2</span>
<span class="p_del">-	stx		%fsr, [%g2 + TI_XFSR]</span>
<span class="p_del">-	sll		%g1, 5, %g1</span>
<span class="p_del">-3:	andcc		%o5, FPRS_DL, %g0</span>
<span class="p_del">-	be,pn		%icc, 4f</span>
<span class="p_del">-	 add		%g6, TI_FPREGS, %g2</span>
<span class="p_del">-</span>
<span class="p_del">-	add		%g6, TI_FPREGS+0x40, %g3</span>
<span class="p_del">-	membar		#Sync</span>
<span class="p_del">-	stda		%f0, [%g2 + %g1] ASI_BLK_P</span>
<span class="p_del">-	stda		%f16, [%g3 + %g1] ASI_BLK_P</span>
<span class="p_del">-	membar		#Sync</span>
<span class="p_del">-	ba,pt		%xcc, 4f</span>
<span class="p_del">-	 nop</span>
<span class="p_del">-</span>
<span class="p_del">-	.align		32</span>
<span class="p_del">-4:	and		%o5, FPRS_DU, %o5</span>
<span class="p_del">-	jmpl		%g7 + %g0, %g0</span>
<span class="p_del">-	 wr		%o5, FPRS_FEF, %fprs</span>
<span class="p_header">diff --git a/arch/sparc/lib/ksyms.c b/arch/sparc/lib/ksyms.c</span>
<span class="p_header">index 323335b9cd2b..ac094de28ccf 100644</span>
<span class="p_header">--- a/arch/sparc/lib/ksyms.c</span>
<span class="p_header">+++ b/arch/sparc/lib/ksyms.c</span>
<span class="p_chunk">@@ -126,10 +126,6 @@</span> <span class="p_context"> EXPORT_SYMBOL(copy_user_page);</span>
 void VISenter(void);
 EXPORT_SYMBOL(VISenter);
 
<span class="p_del">-/* CRYPTO code needs this */</span>
<span class="p_del">-void VISenterhalf(void);</span>
<span class="p_del">-EXPORT_SYMBOL(VISenterhalf);</span>
<span class="p_del">-</span>
 extern void xor_vis_2(unsigned long, unsigned long *, unsigned long *);
 extern void xor_vis_3(unsigned long, unsigned long *, unsigned long *,
 		unsigned long *);
<span class="p_header">diff --git a/arch/x86/boot/compressed/eboot.c b/arch/x86/boot/compressed/eboot.c</span>
<span class="p_header">index bfb3908493f8..c4784a052461 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/eboot.c</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/eboot.c</span>
<span class="p_chunk">@@ -1159,6 +1159,10 @@</span> <span class="p_context"> static efi_status_t setup_e820(struct boot_params *params,</span>
 		unsigned int e820_type = 0;
 		unsigned long m = efi-&gt;efi_memmap;
 
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+		m |= (u64)efi-&gt;efi_memmap_hi &lt;&lt; 32;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 		d = (efi_memory_desc_t *)(m + (i * efi-&gt;efi_memdesc_size));
 		switch (d-&gt;type) {
 		case EFI_RESERVED_TYPE:
<span class="p_header">diff --git a/arch/x86/include/asm/desc.h b/arch/x86/include/asm/desc.h</span>
<span class="p_header">index a94b82e8f156..69126184c609 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/desc.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/desc.h</span>
<span class="p_chunk">@@ -280,21 +280,6 @@</span> <span class="p_context"> static inline void clear_LDT(void)</span>
 	set_ldt(NULL, 0);
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * load one particular LDT into the current CPU</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline void load_LDT_nolock(mm_context_t *pc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	set_ldt(pc-&gt;ldt, pc-&gt;size);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void load_LDT(mm_context_t *pc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	preempt_disable();</span>
<span class="p_del">-	load_LDT_nolock(pc);</span>
<span class="p_del">-	preempt_enable();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline unsigned long get_desc_base(const struct desc_struct *desc)
 {
 	return (unsigned)(desc-&gt;base0 | ((desc-&gt;base1) &lt;&lt; 16) | ((desc-&gt;base2) &lt;&lt; 24));
<span class="p_header">diff --git a/arch/x86/include/asm/mmu.h b/arch/x86/include/asm/mmu.h</span>
<span class="p_header">index 876e74e8eec7..b6b7bc3f5d26 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mmu.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mmu.h</span>
<span class="p_chunk">@@ -9,8 +9,7 @@</span> <span class="p_context"></span>
  * we put the segment information here.
  */
 typedef struct {
<span class="p_del">-	void *ldt;</span>
<span class="p_del">-	int size;</span>
<span class="p_add">+	struct ldt_struct *ldt;</span>
 
 #ifdef CONFIG_X86_64
 	/* True if mm supports a task running in 32 bit compatibility mode. */
<span class="p_header">diff --git a/arch/x86/include/asm/mmu_context.h b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">index be12c534fd59..86fef96f4eca 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -16,6 +16,50 @@</span> <span class="p_context"> static inline void paravirt_activate_mm(struct mm_struct *prev,</span>
 #endif	/* !CONFIG_PARAVIRT */
 
 /*
<span class="p_add">+ * ldt_structs can be allocated, used, and freed, but they are never</span>
<span class="p_add">+ * modified while live.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct ldt_struct {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Xen requires page-aligned LDTs with special permissions.  This is</span>
<span class="p_add">+	 * needed to prevent us from installing evil descriptors such as</span>
<span class="p_add">+	 * call gates.  On native, we could merge the ldt_struct and LDT</span>
<span class="p_add">+	 * allocations, but it&#39;s not worth trying to optimize.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	struct desc_struct *entries;</span>
<span class="p_add">+	int size;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void load_mm_ldt(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ldt_struct *ldt;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* lockless_dereference synchronizes with smp_store_release */</span>
<span class="p_add">+	ldt = lockless_dereference(mm-&gt;context.ldt);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Any change to mm-&gt;context.ldt is followed by an IPI to all</span>
<span class="p_add">+	 * CPUs with the mm active.  The LDT will not be freed until</span>
<span class="p_add">+	 * after the IPI is handled by all such CPUs.  This means that,</span>
<span class="p_add">+	 * if the ldt_struct changes before we return, the values we see</span>
<span class="p_add">+	 * will be safe, and the new values will be loaded before we run</span>
<span class="p_add">+	 * any user code.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * NB: don&#39;t try to convert this to use RCU without extreme care.</span>
<span class="p_add">+	 * We would still need IRQs off, because we don&#39;t want to change</span>
<span class="p_add">+	 * the local LDT after an IPI loaded a newer value than the one</span>
<span class="p_add">+	 * that we can see.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(ldt))</span>
<span class="p_add">+		set_ldt(ldt-&gt;entries, ldt-&gt;size);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		clear_LDT();</span>
<span class="p_add">+</span>
<span class="p_add">+	DEBUG_LOCKS_WARN_ON(preemptible());</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Used for LDT copy/destruction.
  */
 int init_new_context(struct task_struct *tsk, struct mm_struct *mm);
<span class="p_chunk">@@ -50,7 +94,7 @@</span> <span class="p_context"> static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
 
 		/* Load the LDT, if the LDT is different: */
 		if (unlikely(prev-&gt;context.ldt != next-&gt;context.ldt))
<span class="p_del">-			load_LDT_nolock(&amp;next-&gt;context);</span>
<span class="p_add">+			load_mm_ldt(next);</span>
 	}
 #ifdef CONFIG_SMP
 	  else {
<span class="p_chunk">@@ -71,7 +115,7 @@</span> <span class="p_context"> static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
 			 * to make sure to use no freed page tables.
 			 */
 			load_cr3(next-&gt;pgd);
<span class="p_del">-			load_LDT_nolock(&amp;next-&gt;context);</span>
<span class="p_add">+			load_mm_ldt(next);</span>
 		}
 	}
 #endif
<span class="p_header">diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">index 1f3a8885f836..8fc57acf86f4 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/common.c</span>
<span class="p_chunk">@@ -1355,7 +1355,7 @@</span> <span class="p_context"> void cpu_init(void)</span>
 	load_sp0(t, &amp;current-&gt;thread);
 	set_tss_desc(cpu, t);
 	load_TR_desc();
<span class="p_del">-	load_LDT(&amp;init_mm.context);</span>
<span class="p_add">+	load_mm_ldt(&amp;init_mm);</span>
 
 	clear_all_debug_regs();
 	dbg_restore_debug_regs();
<span class="p_chunk">@@ -1402,7 +1402,7 @@</span> <span class="p_context"> void cpu_init(void)</span>
 	load_sp0(t, thread);
 	set_tss_desc(cpu, t);
 	load_TR_desc();
<span class="p_del">-	load_LDT(&amp;init_mm.context);</span>
<span class="p_add">+	load_mm_ldt(&amp;init_mm);</span>
 
 	t-&gt;x86_tss.io_bitmap_base = offsetof(struct tss_struct, io_bitmap);
 
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event.c b/arch/x86/kernel/cpu/perf_event.c</span>
<span class="p_header">index 2879ecdaac43..2a6c3859e8a1 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event.c</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/nmi.h&gt;
 #include &lt;asm/smp.h&gt;
 #include &lt;asm/alternative.h&gt;
<span class="p_add">+#include &lt;asm/mmu_context.h&gt;</span>
 #include &lt;asm/timer.h&gt;
 #include &lt;asm/desc.h&gt;
 #include &lt;asm/ldt.h&gt;
<span class="p_chunk">@@ -1984,21 +1985,25 @@</span> <span class="p_context"> static unsigned long get_segment_base(unsigned int segment)</span>
 	int idx = segment &gt;&gt; 3;
 
 	if ((segment &amp; SEGMENT_TI_MASK) == SEGMENT_LDT) {
<span class="p_add">+		struct ldt_struct *ldt;</span>
<span class="p_add">+</span>
 		if (idx &gt; LDT_ENTRIES)
 			return 0;
 
<span class="p_del">-		if (idx &gt; current-&gt;active_mm-&gt;context.size)</span>
<span class="p_add">+		/* IRQs are off, so this synchronizes with smp_store_release */</span>
<span class="p_add">+		ldt = lockless_dereference(current-&gt;active_mm-&gt;context.ldt);</span>
<span class="p_add">+		if (!ldt || idx &gt; ldt-&gt;size)</span>
 			return 0;
 
<span class="p_del">-		desc = current-&gt;active_mm-&gt;context.ldt;</span>
<span class="p_add">+		desc = &amp;ldt-&gt;entries[idx];</span>
 	} else {
 		if (idx &gt; GDT_ENTRIES)
 			return 0;
 
<span class="p_del">-		desc = __this_cpu_ptr(&amp;gdt_page.gdt[0]);</span>
<span class="p_add">+		desc = __this_cpu_ptr(&amp;gdt_page.gdt[0]) + idx;</span>
 	}
 
<span class="p_del">-	return get_desc_base(desc + idx);</span>
<span class="p_add">+	return get_desc_base(desc);</span>
 }
 
 #ifdef CONFIG_COMPAT
<span class="p_header">diff --git a/arch/x86/kernel/ldt.c b/arch/x86/kernel/ldt.c</span>
<span class="p_header">index c37886d759cc..2bcc0525f1c1 100644</span>
<span class="p_header">--- a/arch/x86/kernel/ldt.c</span>
<span class="p_header">+++ b/arch/x86/kernel/ldt.c</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/string.h&gt;
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/smp.h&gt;
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
 #include &lt;linux/vmalloc.h&gt;
 #include &lt;linux/uaccess.h&gt;
 
<span class="p_chunk">@@ -20,82 +21,82 @@</span> <span class="p_context"></span>
 #include &lt;asm/mmu_context.h&gt;
 #include &lt;asm/syscalls.h&gt;
 
<span class="p_del">-#ifdef CONFIG_SMP</span>
<span class="p_add">+/* context.lock is held for us, so we don&#39;t need any locking. */</span>
 static void flush_ldt(void *current_mm)
 {
<span class="p_del">-	if (current-&gt;active_mm == current_mm)</span>
<span class="p_del">-		load_LDT(&amp;current-&gt;active_mm-&gt;context);</span>
<span class="p_add">+	mm_context_t *pc;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (current-&gt;active_mm != current_mm)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	pc = &amp;current-&gt;active_mm-&gt;context;</span>
<span class="p_add">+	set_ldt(pc-&gt;ldt-&gt;entries, pc-&gt;ldt-&gt;size);</span>
 }
<span class="p_del">-#endif</span>
 
<span class="p_del">-static int alloc_ldt(mm_context_t *pc, int mincount, int reload)</span>
<span class="p_add">+/* The caller must call finalize_ldt_struct on the result. LDT starts zeroed. */</span>
<span class="p_add">+static struct ldt_struct *alloc_ldt_struct(int size)</span>
 {
<span class="p_del">-	void *oldldt, *newldt;</span>
<span class="p_del">-	int oldsize;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (mincount &lt;= pc-&gt;size)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	oldsize = pc-&gt;size;</span>
<span class="p_del">-	mincount = (mincount + (PAGE_SIZE / LDT_ENTRY_SIZE - 1)) &amp;</span>
<span class="p_del">-			(~(PAGE_SIZE / LDT_ENTRY_SIZE - 1));</span>
<span class="p_del">-	if (mincount * LDT_ENTRY_SIZE &gt; PAGE_SIZE)</span>
<span class="p_del">-		newldt = vmalloc(mincount * LDT_ENTRY_SIZE);</span>
<span class="p_add">+	struct ldt_struct *new_ldt;</span>
<span class="p_add">+	int alloc_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (size &gt; LDT_ENTRIES)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	new_ldt = kmalloc(sizeof(struct ldt_struct), GFP_KERNEL);</span>
<span class="p_add">+	if (!new_ldt)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUILD_BUG_ON(LDT_ENTRY_SIZE != sizeof(struct desc_struct));</span>
<span class="p_add">+	alloc_size = size * LDT_ENTRY_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Xen is very picky: it requires a page-aligned LDT that has no</span>
<span class="p_add">+	 * trailing nonzero bytes in any page that contains LDT descriptors.</span>
<span class="p_add">+	 * Keep it simple: zero the whole allocation and never allocate less</span>
<span class="p_add">+	 * than PAGE_SIZE.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (alloc_size &gt; PAGE_SIZE)</span>
<span class="p_add">+		new_ldt-&gt;entries = vzalloc(alloc_size);</span>
 	else
<span class="p_del">-		newldt = (void *)__get_free_page(GFP_KERNEL);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!newldt)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+		new_ldt-&gt;entries = kzalloc(PAGE_SIZE, GFP_KERNEL);</span>
 
<span class="p_del">-	if (oldsize)</span>
<span class="p_del">-		memcpy(newldt, pc-&gt;ldt, oldsize * LDT_ENTRY_SIZE);</span>
<span class="p_del">-	oldldt = pc-&gt;ldt;</span>
<span class="p_del">-	memset(newldt + oldsize * LDT_ENTRY_SIZE, 0,</span>
<span class="p_del">-	       (mincount - oldsize) * LDT_ENTRY_SIZE);</span>
<span class="p_add">+	if (!new_ldt-&gt;entries) {</span>
<span class="p_add">+		kfree(new_ldt);</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	paravirt_alloc_ldt(newldt, mincount);</span>
<span class="p_add">+	new_ldt-&gt;size = size;</span>
<span class="p_add">+	return new_ldt;</span>
<span class="p_add">+}</span>
 
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	/* CHECKME: Do we really need this ? */</span>
<span class="p_del">-	wmb();</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	pc-&gt;ldt = newldt;</span>
<span class="p_del">-	wmb();</span>
<span class="p_del">-	pc-&gt;size = mincount;</span>
<span class="p_del">-	wmb();</span>
<span class="p_del">-</span>
<span class="p_del">-	if (reload) {</span>
<span class="p_del">-#ifdef CONFIG_SMP</span>
<span class="p_del">-		preempt_disable();</span>
<span class="p_del">-		load_LDT(pc);</span>
<span class="p_del">-		if (!cpumask_equal(mm_cpumask(current-&gt;mm),</span>
<span class="p_del">-				   cpumask_of(smp_processor_id())))</span>
<span class="p_del">-			smp_call_function(flush_ldt, current-&gt;mm, 1);</span>
<span class="p_del">-		preempt_enable();</span>
<span class="p_del">-#else</span>
<span class="p_del">-		load_LDT(pc);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (oldsize) {</span>
<span class="p_del">-		paravirt_free_ldt(oldldt, oldsize);</span>
<span class="p_del">-		if (oldsize * LDT_ENTRY_SIZE &gt; PAGE_SIZE)</span>
<span class="p_del">-			vfree(oldldt);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			put_page(virt_to_page(oldldt));</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+/* After calling this, the LDT is immutable. */</span>
<span class="p_add">+static void finalize_ldt_struct(struct ldt_struct *ldt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	paravirt_alloc_ldt(ldt-&gt;entries, ldt-&gt;size);</span>
 }
 
<span class="p_del">-static inline int copy_ldt(mm_context_t *new, mm_context_t *old)</span>
<span class="p_add">+/* context.lock is held */</span>
<span class="p_add">+static void install_ldt(struct mm_struct *current_mm,</span>
<span class="p_add">+			struct ldt_struct *ldt)</span>
 {
<span class="p_del">-	int err = alloc_ldt(new, old-&gt;size, 0);</span>
<span class="p_del">-	int i;</span>
<span class="p_add">+	/* Synchronizes with lockless_dereference in load_mm_ldt. */</span>
<span class="p_add">+	smp_store_release(&amp;current_mm-&gt;context.ldt, ldt);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Activate the LDT for all CPUs using current_mm. */</span>
<span class="p_add">+	on_each_cpu_mask(mm_cpumask(current_mm), flush_ldt, current_mm, true);</span>
<span class="p_add">+}</span>
 
<span class="p_del">-	if (err &lt; 0)</span>
<span class="p_del">-		return err;</span>
<span class="p_add">+static void free_ldt_struct(struct ldt_struct *ldt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (likely(!ldt))</span>
<span class="p_add">+		return;</span>
 
<span class="p_del">-	for (i = 0; i &lt; old-&gt;size; i++)</span>
<span class="p_del">-		write_ldt_entry(new-&gt;ldt, i, old-&gt;ldt + i * LDT_ENTRY_SIZE);</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	paravirt_free_ldt(ldt-&gt;entries, ldt-&gt;size);</span>
<span class="p_add">+	if (ldt-&gt;size * LDT_ENTRY_SIZE &gt; PAGE_SIZE)</span>
<span class="p_add">+		vfree(ldt-&gt;entries);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		kfree(ldt-&gt;entries);</span>
<span class="p_add">+	kfree(ldt);</span>
 }
 
 /*
<span class="p_chunk">@@ -104,17 +105,37 @@</span> <span class="p_context"> static inline int copy_ldt(mm_context_t *new, mm_context_t *old)</span>
  */
 int init_new_context(struct task_struct *tsk, struct mm_struct *mm)
 {
<span class="p_add">+	struct ldt_struct *new_ldt;</span>
 	struct mm_struct *old_mm;
 	int retval = 0;
 
 	mutex_init(&amp;mm-&gt;context.lock);
<span class="p_del">-	mm-&gt;context.size = 0;</span>
 	old_mm = current-&gt;mm;
<span class="p_del">-	if (old_mm &amp;&amp; old_mm-&gt;context.size &gt; 0) {</span>
<span class="p_del">-		mutex_lock(&amp;old_mm-&gt;context.lock);</span>
<span class="p_del">-		retval = copy_ldt(&amp;mm-&gt;context, &amp;old_mm-&gt;context);</span>
<span class="p_del">-		mutex_unlock(&amp;old_mm-&gt;context.lock);</span>
<span class="p_add">+	if (!old_mm) {</span>
<span class="p_add">+		mm-&gt;context.ldt = NULL;</span>
<span class="p_add">+		return 0;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;old_mm-&gt;context.lock);</span>
<span class="p_add">+	if (!old_mm-&gt;context.ldt) {</span>
<span class="p_add">+		mm-&gt;context.ldt = NULL;</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	new_ldt = alloc_ldt_struct(old_mm-&gt;context.ldt-&gt;size);</span>
<span class="p_add">+	if (!new_ldt) {</span>
<span class="p_add">+		retval = -ENOMEM;</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span>
<span class="p_add">+	       new_ldt-&gt;size * LDT_ENTRY_SIZE);</span>
<span class="p_add">+	finalize_ldt_struct(new_ldt);</span>
<span class="p_add">+</span>
<span class="p_add">+	mm-&gt;context.ldt = new_ldt;</span>
<span class="p_add">+</span>
<span class="p_add">+out_unlock:</span>
<span class="p_add">+	mutex_unlock(&amp;old_mm-&gt;context.lock);</span>
 	return retval;
 }
 
<span class="p_chunk">@@ -125,53 +146,47 @@</span> <span class="p_context"> int init_new_context(struct task_struct *tsk, struct mm_struct *mm)</span>
  */
 void destroy_context(struct mm_struct *mm)
 {
<span class="p_del">-	if (mm-&gt;context.size) {</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-		/* CHECKME: Can this ever happen ? */</span>
<span class="p_del">-		if (mm == current-&gt;active_mm)</span>
<span class="p_del">-			clear_LDT();</span>
<span class="p_del">-#endif</span>
<span class="p_del">-		paravirt_free_ldt(mm-&gt;context.ldt, mm-&gt;context.size);</span>
<span class="p_del">-		if (mm-&gt;context.size * LDT_ENTRY_SIZE &gt; PAGE_SIZE)</span>
<span class="p_del">-			vfree(mm-&gt;context.ldt);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			put_page(virt_to_page(mm-&gt;context.ldt));</span>
<span class="p_del">-		mm-&gt;context.size = 0;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	free_ldt_struct(mm-&gt;context.ldt);</span>
<span class="p_add">+	mm-&gt;context.ldt = NULL;</span>
 }
 
 static int read_ldt(void __user *ptr, unsigned long bytecount)
 {
<span class="p_del">-	int err;</span>
<span class="p_add">+	int retval;</span>
 	unsigned long size;
 	struct mm_struct *mm = current-&gt;mm;
 
<span class="p_del">-	if (!mm-&gt;context.size)</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+	mutex_lock(&amp;mm-&gt;context.lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mm-&gt;context.ldt) {</span>
<span class="p_add">+		retval = 0;</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (bytecount &gt; LDT_ENTRY_SIZE * LDT_ENTRIES)
 		bytecount = LDT_ENTRY_SIZE * LDT_ENTRIES;
 
<span class="p_del">-	mutex_lock(&amp;mm-&gt;context.lock);</span>
<span class="p_del">-	size = mm-&gt;context.size * LDT_ENTRY_SIZE;</span>
<span class="p_add">+	size = mm-&gt;context.ldt-&gt;size * LDT_ENTRY_SIZE;</span>
 	if (size &gt; bytecount)
 		size = bytecount;
 
<span class="p_del">-	err = 0;</span>
<span class="p_del">-	if (copy_to_user(ptr, mm-&gt;context.ldt, size))</span>
<span class="p_del">-		err = -EFAULT;</span>
<span class="p_del">-	mutex_unlock(&amp;mm-&gt;context.lock);</span>
<span class="p_del">-	if (err &lt; 0)</span>
<span class="p_del">-		goto error_return;</span>
<span class="p_add">+	if (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, size)) {</span>
<span class="p_add">+		retval = -EFAULT;</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (size != bytecount) {
<span class="p_del">-		/* zero-fill the rest */</span>
<span class="p_del">-		if (clear_user(ptr + size, bytecount - size) != 0) {</span>
<span class="p_del">-			err = -EFAULT;</span>
<span class="p_del">-			goto error_return;</span>
<span class="p_add">+		/* Zero-fill the rest and pretend we read bytecount bytes. */</span>
<span class="p_add">+		if (clear_user(ptr + size, bytecount - size)) {</span>
<span class="p_add">+			retval = -EFAULT;</span>
<span class="p_add">+			goto out_unlock;</span>
 		}
 	}
<span class="p_del">-	return bytecount;</span>
<span class="p_del">-error_return:</span>
<span class="p_del">-	return err;</span>
<span class="p_add">+	retval = bytecount;</span>
<span class="p_add">+</span>
<span class="p_add">+out_unlock:</span>
<span class="p_add">+	mutex_unlock(&amp;mm-&gt;context.lock);</span>
<span class="p_add">+	return retval;</span>
 }
 
 static int read_default_ldt(void __user *ptr, unsigned long bytecount)
<span class="p_chunk">@@ -195,6 +210,8 @@</span> <span class="p_context"> static int write_ldt(void __user *ptr, unsigned long bytecount, int oldmode)</span>
 	struct desc_struct ldt;
 	int error;
 	struct user_desc ldt_info;
<span class="p_add">+	int oldsize, newsize;</span>
<span class="p_add">+	struct ldt_struct *new_ldt, *old_ldt;</span>
 
 	error = -EINVAL;
 	if (bytecount != sizeof(ldt_info))
<span class="p_chunk">@@ -213,34 +230,39 @@</span> <span class="p_context"> static int write_ldt(void __user *ptr, unsigned long bytecount, int oldmode)</span>
 			goto out;
 	}
 
<span class="p_del">-	mutex_lock(&amp;mm-&gt;context.lock);</span>
<span class="p_del">-	if (ldt_info.entry_number &gt;= mm-&gt;context.size) {</span>
<span class="p_del">-		error = alloc_ldt(&amp;current-&gt;mm-&gt;context,</span>
<span class="p_del">-				  ldt_info.entry_number + 1, 1);</span>
<span class="p_del">-		if (error &lt; 0)</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Allow LDTs to be cleared by the user. */</span>
<span class="p_del">-	if (ldt_info.base_addr == 0 &amp;&amp; ldt_info.limit == 0) {</span>
<span class="p_del">-		if (oldmode || LDT_empty(&amp;ldt_info)) {</span>
<span class="p_del">-			memset(&amp;ldt, 0, sizeof(ldt));</span>
<span class="p_del">-			goto install;</span>
<span class="p_add">+	if ((oldmode &amp;&amp; !ldt_info.base_addr &amp;&amp; !ldt_info.limit) ||</span>
<span class="p_add">+	    LDT_empty(&amp;ldt_info)) {</span>
<span class="p_add">+		/* The user wants to clear the entry. */</span>
<span class="p_add">+		memset(&amp;ldt, 0, sizeof(ldt));</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (!IS_ENABLED(CONFIG_X86_16BIT) &amp;&amp; !ldt_info.seg_32bit) {</span>
<span class="p_add">+			error = -EINVAL;</span>
<span class="p_add">+			goto out;</span>
 		}
<span class="p_add">+</span>
<span class="p_add">+		fill_ldt(&amp;ldt, &amp;ldt_info);</span>
<span class="p_add">+		if (oldmode)</span>
<span class="p_add">+			ldt.avl = 0;</span>
 	}
 
<span class="p_del">-	if (!IS_ENABLED(CONFIG_X86_16BIT) &amp;&amp; !ldt_info.seg_32bit) {</span>
<span class="p_del">-		error = -EINVAL;</span>
<span class="p_add">+	mutex_lock(&amp;mm-&gt;context.lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	old_ldt = mm-&gt;context.ldt;</span>
<span class="p_add">+	oldsize = old_ldt ? old_ldt-&gt;size : 0;</span>
<span class="p_add">+	newsize = max((int)(ldt_info.entry_number + 1), oldsize);</span>
<span class="p_add">+</span>
<span class="p_add">+	error = -ENOMEM;</span>
<span class="p_add">+	new_ldt = alloc_ldt_struct(newsize);</span>
<span class="p_add">+	if (!new_ldt)</span>
 		goto out_unlock;
<span class="p_del">-	}</span>
 
<span class="p_del">-	fill_ldt(&amp;ldt, &amp;ldt_info);</span>
<span class="p_del">-	if (oldmode)</span>
<span class="p_del">-		ldt.avl = 0;</span>
<span class="p_add">+	if (old_ldt)</span>
<span class="p_add">+		memcpy(new_ldt-&gt;entries, old_ldt-&gt;entries, oldsize * LDT_ENTRY_SIZE);</span>
<span class="p_add">+	new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span>
<span class="p_add">+	finalize_ldt_struct(new_ldt);</span>
 
<span class="p_del">-	/* Install the new entry ...  */</span>
<span class="p_del">-install:</span>
<span class="p_del">-	write_ldt_entry(mm-&gt;context.ldt, ldt_info.entry_number, &amp;ldt);</span>
<span class="p_add">+	install_ldt(mm, new_ldt);</span>
<span class="p_add">+	free_ldt_struct(old_ldt);</span>
 	error = 0;
 
 out_unlock:
<span class="p_header">diff --git a/arch/x86/kernel/process_64.c b/arch/x86/kernel/process_64.c</span>
<span class="p_header">index 166119618afb..e84487aa2fd2 100644</span>
<span class="p_header">--- a/arch/x86/kernel/process_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/process_64.c</span>
<span class="p_chunk">@@ -122,11 +122,11 @@</span> <span class="p_context"> void __show_regs(struct pt_regs *regs, int all)</span>
 void release_thread(struct task_struct *dead_task)
 {
 	if (dead_task-&gt;mm) {
<span class="p_del">-		if (dead_task-&gt;mm-&gt;context.size) {</span>
<span class="p_add">+		if (dead_task-&gt;mm-&gt;context.ldt) {</span>
 			pr_warn(&quot;WARNING: dead process %s still has LDT? &lt;%p/%d&gt;\n&quot;,
 				dead_task-&gt;comm,
 				dead_task-&gt;mm-&gt;context.ldt,
<span class="p_del">-				dead_task-&gt;mm-&gt;context.size);</span>
<span class="p_add">+				dead_task-&gt;mm-&gt;context.ldt-&gt;size);</span>
 			BUG();
 		}
 	}
<span class="p_header">diff --git a/arch/x86/kernel/step.c b/arch/x86/kernel/step.c</span>
<span class="p_header">index 9b4d51d0c0d0..0ccb53a9fcd9 100644</span>
<span class="p_header">--- a/arch/x86/kernel/step.c</span>
<span class="p_header">+++ b/arch/x86/kernel/step.c</span>
<span class="p_chunk">@@ -5,6 +5,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/ptrace.h&gt;
 #include &lt;asm/desc.h&gt;
<span class="p_add">+#include &lt;asm/mmu_context.h&gt;</span>
 
 unsigned long convert_ip_to_linear(struct task_struct *child, struct pt_regs *regs)
 {
<span class="p_chunk">@@ -27,13 +28,14 @@</span> <span class="p_context"> unsigned long convert_ip_to_linear(struct task_struct *child, struct pt_regs *re</span>
 		struct desc_struct *desc;
 		unsigned long base;
 
<span class="p_del">-		seg &amp;= ~7UL;</span>
<span class="p_add">+		seg &gt;&gt;= 3;</span>
 
 		mutex_lock(&amp;child-&gt;mm-&gt;context.lock);
<span class="p_del">-		if (unlikely((seg &gt;&gt; 3) &gt;= child-&gt;mm-&gt;context.size))</span>
<span class="p_add">+		if (unlikely(!child-&gt;mm-&gt;context.ldt ||</span>
<span class="p_add">+			     seg &gt;= child-&gt;mm-&gt;context.ldt-&gt;size))</span>
 			addr = -1L; /* bogus selector, access would fault */
 		else {
<span class="p_del">-			desc = child-&gt;mm-&gt;context.ldt + seg;</span>
<span class="p_add">+			desc = &amp;child-&gt;mm-&gt;context.ldt-&gt;entries[seg];</span>
 			base = get_desc_base(desc);
 
 			/* 16-bit code segment? */
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index e05ef62906f4..27a8d4f9bce5 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -2099,7 +2099,7 @@</span> <span class="p_context"> int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)</span>
 		if (guest_cpuid_has_tsc_adjust(vcpu)) {
 			if (!msr_info-&gt;host_initiated) {
 				u64 adj = data - vcpu-&gt;arch.ia32_tsc_adjust_msr;
<span class="p_del">-				kvm_x86_ops-&gt;adjust_tsc_offset(vcpu, adj, true);</span>
<span class="p_add">+				adjust_tsc_offset_guest(vcpu, adj);</span>
 			}
 			vcpu-&gt;arch.ia32_tsc_adjust_msr = data;
 		}
<span class="p_header">diff --git a/arch/x86/math-emu/fpu_entry.c b/arch/x86/math-emu/fpu_entry.c</span>
<span class="p_header">index 9b868124128d..274a52b1183e 100644</span>
<span class="p_header">--- a/arch/x86/math-emu/fpu_entry.c</span>
<span class="p_header">+++ b/arch/x86/math-emu/fpu_entry.c</span>
<span class="p_chunk">@@ -29,7 +29,6 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/uaccess.h&gt;
 #include &lt;asm/traps.h&gt;
<span class="p_del">-#include &lt;asm/desc.h&gt;</span>
 #include &lt;asm/user.h&gt;
 #include &lt;asm/i387.h&gt;
 
<span class="p_chunk">@@ -185,7 +184,7 @@</span> <span class="p_context"> void math_emulate(struct math_emu_info *info)</span>
 			math_abort(FPU_info, SIGILL);
 		}
 
<span class="p_del">-		code_descriptor = LDT_DESCRIPTOR(FPU_CS);</span>
<span class="p_add">+		code_descriptor = FPU_get_ldt_descriptor(FPU_CS);</span>
 		if (SEG_D_SIZE(code_descriptor)) {
 			/* The above test may be wrong, the book is not clear */
 			/* Segmented 32 bit protected mode */
<span class="p_header">diff --git a/arch/x86/math-emu/fpu_system.h b/arch/x86/math-emu/fpu_system.h</span>
<span class="p_header">index 2c614410a5f3..d342fce49447 100644</span>
<span class="p_header">--- a/arch/x86/math-emu/fpu_system.h</span>
<span class="p_header">+++ b/arch/x86/math-emu/fpu_system.h</span>
<span class="p_chunk">@@ -16,9 +16,24 @@</span> <span class="p_context"></span>
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/mm.h&gt;
 
<span class="p_del">-/* s is always from a cpu register, and the cpu does bounds checking</span>
<span class="p_del">- * during register load --&gt; no further bounds checks needed */</span>
<span class="p_del">-#define LDT_DESCRIPTOR(s)	(((struct desc_struct *)current-&gt;mm-&gt;context.ldt)[(s) &gt;&gt; 3])</span>
<span class="p_add">+#include &lt;asm/desc.h&gt;</span>
<span class="p_add">+#include &lt;asm/mmu_context.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static inline struct desc_struct FPU_get_ldt_descriptor(unsigned seg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static struct desc_struct zero_desc;</span>
<span class="p_add">+	struct desc_struct ret = zero_desc;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_MODIFY_LDT_SYSCALL</span>
<span class="p_add">+	seg &gt;&gt;= 3;</span>
<span class="p_add">+	mutex_lock(&amp;current-&gt;mm-&gt;context.lock);</span>
<span class="p_add">+	if (current-&gt;mm-&gt;context.ldt &amp;&amp; seg &lt; current-&gt;mm-&gt;context.ldt-&gt;size)</span>
<span class="p_add">+		ret = current-&gt;mm-&gt;context.ldt-&gt;entries[seg];</span>
<span class="p_add">+	mutex_unlock(&amp;current-&gt;mm-&gt;context.lock);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define SEG_D_SIZE(x)		((x).b &amp; (3 &lt;&lt; 21))
 #define SEG_G_BIT(x)		((x).b &amp; (1 &lt;&lt; 23))
 #define SEG_GRANULARITY(x)	(((x).b &amp; (1 &lt;&lt; 23)) ? 4096 : 1)
<span class="p_header">diff --git a/arch/x86/math-emu/get_address.c b/arch/x86/math-emu/get_address.c</span>
<span class="p_header">index 6ef5e99380f9..8300db71c2a6 100644</span>
<span class="p_header">--- a/arch/x86/math-emu/get_address.c</span>
<span class="p_header">+++ b/arch/x86/math-emu/get_address.c</span>
<span class="p_chunk">@@ -20,7 +20,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/stddef.h&gt;
 
 #include &lt;asm/uaccess.h&gt;
<span class="p_del">-#include &lt;asm/desc.h&gt;</span>
 
 #include &quot;fpu_system.h&quot;
 #include &quot;exception.h&quot;
<span class="p_chunk">@@ -158,7 +157,7 @@</span> <span class="p_context"> static long pm_address(u_char FPU_modrm, u_char segment,</span>
 		addr-&gt;selector = PM_REG_(segment);
 	}
 
<span class="p_del">-	descriptor = LDT_DESCRIPTOR(PM_REG_(segment));</span>
<span class="p_add">+	descriptor = FPU_get_ldt_descriptor(addr-&gt;selector);</span>
 	base_address = SEG_BASE_ADDR(descriptor);
 	address = base_address + offset;
 	limit = base_address
<span class="p_header">diff --git a/arch/x86/power/cpu.c b/arch/x86/power/cpu.c</span>
<span class="p_header">index 424f4c97a44d..6c8e2f5ce056 100644</span>
<span class="p_header">--- a/arch/x86/power/cpu.c</span>
<span class="p_header">+++ b/arch/x86/power/cpu.c</span>
<span class="p_chunk">@@ -23,6 +23,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/debugreg.h&gt;
 #include &lt;asm/fpu-internal.h&gt; /* pcntxt_mask */
 #include &lt;asm/cpu.h&gt;
<span class="p_add">+#include &lt;asm/mmu_context.h&gt;</span>
 
 #ifdef CONFIG_X86_32
 __visible unsigned long saved_context_ebx;
<span class="p_chunk">@@ -157,7 +158,7 @@</span> <span class="p_context"> static void fix_processor_context(void)</span>
 	syscall_init();				/* This sets MSR_*STAR and related */
 #endif
 	load_TR_desc();				/* This does ltr */
<span class="p_del">-	load_LDT(&amp;current-&gt;active_mm-&gt;context);	/* This does lldt */</span>
<span class="p_add">+	load_mm_ldt(current-&gt;active_mm);	/* This does lldt */</span>
 }
 
 /**
<span class="p_header">diff --git a/arch/x86/xen/enlighten.c b/arch/x86/xen/enlighten.c</span>
<span class="p_header">index ffb101e45731..9429bdf1b41a 100644</span>
<span class="p_header">--- a/arch/x86/xen/enlighten.c</span>
<span class="p_header">+++ b/arch/x86/xen/enlighten.c</span>
<span class="p_chunk">@@ -481,6 +481,7 @@</span> <span class="p_context"> static void set_aliased_prot(void *v, pgprot_t prot)</span>
 	pte_t pte;
 	unsigned long pfn;
 	struct page *page;
<span class="p_add">+	unsigned char dummy;</span>
 
 	ptep = lookup_address((unsigned long)v, &amp;level);
 	BUG_ON(ptep == NULL);
<span class="p_chunk">@@ -490,6 +491,32 @@</span> <span class="p_context"> static void set_aliased_prot(void *v, pgprot_t prot)</span>
 
 	pte = pfn_pte(pfn, prot);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Careful: update_va_mapping() will fail if the virtual address</span>
<span class="p_add">+	 * we&#39;re poking isn&#39;t populated in the page tables.  We don&#39;t</span>
<span class="p_add">+	 * need to worry about the direct map (that&#39;s always in the page</span>
<span class="p_add">+	 * tables), but we need to be careful about vmap space.  In</span>
<span class="p_add">+	 * particular, the top level page table can lazily propagate</span>
<span class="p_add">+	 * entries between processes, so if we&#39;ve switched mms since we</span>
<span class="p_add">+	 * vmapped the target in the first place, we might not have the</span>
<span class="p_add">+	 * top-level page table entry populated.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We disable preemption because we want the same mm active when</span>
<span class="p_add">+	 * we probe the target and when we issue the hypercall.  We&#39;ll</span>
<span class="p_add">+	 * have the same nominal mm, but if we&#39;re a kernel thread, lazy</span>
<span class="p_add">+	 * mm dropping could change our pgd.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Out of an abundance of caution, this uses __get_user() to fault</span>
<span class="p_add">+	 * in the target address just in case there&#39;s some obscure case</span>
<span class="p_add">+	 * in which the target address isn&#39;t readable.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	preempt_disable();</span>
<span class="p_add">+</span>
<span class="p_add">+	pagefault_disable();	/* Avoid warnings due to being atomic. */</span>
<span class="p_add">+	__get_user(dummy, (unsigned char __user __force *)v);</span>
<span class="p_add">+	pagefault_enable();</span>
<span class="p_add">+</span>
 	if (HYPERVISOR_update_va_mapping((unsigned long)v, pte, 0))
 		BUG();
 
<span class="p_chunk">@@ -501,6 +528,8 @@</span> <span class="p_context"> static void set_aliased_prot(void *v, pgprot_t prot)</span>
 				BUG();
 	} else
 		kmap_flush_unused();
<span class="p_add">+</span>
<span class="p_add">+	preempt_enable();</span>
 }
 
 static void xen_alloc_ldt(struct desc_struct *ldt, unsigned entries)
<span class="p_chunk">@@ -508,6 +537,17 @@</span> <span class="p_context"> static void xen_alloc_ldt(struct desc_struct *ldt, unsigned entries)</span>
 	const unsigned entries_per_page = PAGE_SIZE / LDT_ENTRY_SIZE;
 	int i;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to mark the all aliases of the LDT pages RO.  We</span>
<span class="p_add">+	 * don&#39;t need to call vm_flush_aliases(), though, since that&#39;s</span>
<span class="p_add">+	 * only responsible for flushing aliases out the TLBs, not the</span>
<span class="p_add">+	 * page tables, and Xen will flush the TLB for us if needed.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * To avoid confusing future readers: none of this is necessary</span>
<span class="p_add">+	 * to load the LDT.  The hypervisor only checks this when the</span>
<span class="p_add">+	 * LDT is faulted in due to subsequent descriptor access.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
 	for(i = 0; i &lt; entries; i += entries_per_page)
 		set_aliased_prot(ldt + i, PAGE_KERNEL_RO);
 }
<span class="p_header">diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c</span>
<span class="p_header">index c9707bcf430c..cfa2982d7286 100644</span>
<span class="p_header">--- a/drivers/ata/libata-core.c</span>
<span class="p_header">+++ b/drivers/ata/libata-core.c</span>
<span class="p_chunk">@@ -4231,6 +4231,7 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 	{ &quot;Crucial_CT*M550*&quot;,		&quot;MU01&quot;,	ATA_HORKAGE_NO_NCQ_TRIM, },
 	{ &quot;Crucial_CT*MX100*&quot;,		&quot;MU01&quot;, ATA_HORKAGE_NO_NCQ_TRIM, },
 	{ &quot;Samsung SSD 8*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },
<span class="p_add">+	{ &quot;FCCT*M500*&quot;,			NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },</span>
 
 	/* devices that don&#39;t properly handle TRIM commands */
 	{ &quot;SuperSSpeed S238*&quot;,		NULL,	ATA_HORKAGE_NOTRIM, },
<span class="p_header">diff --git a/drivers/base/firmware_class.c b/drivers/base/firmware_class.c</span>
<span class="p_header">index 2a1d1ae5c11d..d8e585a62caa 100644</span>
<span class="p_header">--- a/drivers/base/firmware_class.c</span>
<span class="p_header">+++ b/drivers/base/firmware_class.c</span>
<span class="p_chunk">@@ -544,10 +544,8 @@</span> <span class="p_context"> static void fw_dev_release(struct device *dev)</span>
 	kfree(fw_priv);
 }
 
<span class="p_del">-static int firmware_uevent(struct device *dev, struct kobj_uevent_env *env)</span>
<span class="p_add">+static int do_firmware_uevent(struct firmware_priv *fw_priv, struct kobj_uevent_env *env)</span>
 {
<span class="p_del">-	struct firmware_priv *fw_priv = to_firmware_priv(dev);</span>
<span class="p_del">-</span>
 	if (add_uevent_var(env, &quot;FIRMWARE=%s&quot;, fw_priv-&gt;buf-&gt;fw_id))
 		return -ENOMEM;
 	if (add_uevent_var(env, &quot;TIMEOUT=%i&quot;, loading_timeout))
<span class="p_chunk">@@ -558,6 +556,18 @@</span> <span class="p_context"> static int firmware_uevent(struct device *dev, struct kobj_uevent_env *env)</span>
 	return 0;
 }
 
<span class="p_add">+static int firmware_uevent(struct device *dev, struct kobj_uevent_env *env)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct firmware_priv *fw_priv = to_firmware_priv(dev);</span>
<span class="p_add">+	int err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;fw_lock);</span>
<span class="p_add">+	if (fw_priv-&gt;buf)</span>
<span class="p_add">+		err = do_firmware_uevent(fw_priv, env);</span>
<span class="p_add">+	mutex_unlock(&amp;fw_lock);</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct class firmware_class = {
 	.name		= &quot;firmware&quot;,
 	.class_attrs	= firmware_class_attrs,
<span class="p_header">diff --git a/drivers/base/regmap/regcache-rbtree.c b/drivers/base/regmap/regcache-rbtree.c</span>
<span class="p_header">index 9d09c5bb5874..bb39181e4c33 100644</span>
<span class="p_header">--- a/drivers/base/regmap/regcache-rbtree.c</span>
<span class="p_header">+++ b/drivers/base/regmap/regcache-rbtree.c</span>
<span class="p_chunk">@@ -296,11 +296,20 @@</span> <span class="p_context"> static int regcache_rbtree_insert_to_block(struct regmap *map,</span>
 	if (!blk)
 		return -ENOMEM;
 
<span class="p_del">-	present = krealloc(rbnode-&gt;cache_present,</span>
<span class="p_del">-		    BITS_TO_LONGS(blklen) * sizeof(*present), GFP_KERNEL);</span>
<span class="p_del">-	if (!present) {</span>
<span class="p_del">-		kfree(blk);</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+	if (BITS_TO_LONGS(blklen) &gt; BITS_TO_LONGS(rbnode-&gt;blklen)) {</span>
<span class="p_add">+		present = krealloc(rbnode-&gt;cache_present,</span>
<span class="p_add">+				   BITS_TO_LONGS(blklen) * sizeof(*present),</span>
<span class="p_add">+				   GFP_KERNEL);</span>
<span class="p_add">+		if (!present) {</span>
<span class="p_add">+			kfree(blk);</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		memset(present + BITS_TO_LONGS(rbnode-&gt;blklen), 0,</span>
<span class="p_add">+		       (BITS_TO_LONGS(blklen) - BITS_TO_LONGS(rbnode-&gt;blklen))</span>
<span class="p_add">+		       * sizeof(*present));</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		present = rbnode-&gt;cache_present;</span>
 	}
 
 	/* insert the register value in the correct place in the rbnode block */
<span class="p_header">diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c</span>
<span class="p_header">index b3fdc1b7ea76..4242da3b09da 100644</span>
<span class="p_header">--- a/drivers/block/rbd.c</span>
<span class="p_header">+++ b/drivers/block/rbd.c</span>
<span class="p_chunk">@@ -512,6 +512,7 @@</span> <span class="p_context"> void rbd_warn(struct rbd_device *rbd_dev, const char *fmt, ...)</span>
 #  define rbd_assert(expr)	((void) 0)
 #endif /* !RBD_DEBUG */
 
<span class="p_add">+static void rbd_osd_copyup_callback(struct rbd_obj_request *obj_request);</span>
 static int rbd_img_obj_request_submit(struct rbd_obj_request *obj_request);
 static void rbd_img_parent_read(struct rbd_obj_request *obj_request);
 static void rbd_dev_remove_parent(struct rbd_device *rbd_dev);
<span class="p_chunk">@@ -1720,6 +1721,16 @@</span> <span class="p_context"> static void rbd_osd_stat_callback(struct rbd_obj_request *obj_request)</span>
 	obj_request_done_set(obj_request);
 }
 
<span class="p_add">+static void rbd_osd_call_callback(struct rbd_obj_request *obj_request)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dout(&quot;%s: obj %p\n&quot;, __func__, obj_request);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (obj_request_img_data_test(obj_request))</span>
<span class="p_add">+		rbd_osd_copyup_callback(obj_request);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		obj_request_done_set(obj_request);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void rbd_osd_req_callback(struct ceph_osd_request *osd_req,
 				struct ceph_msg *msg)
 {
<span class="p_chunk">@@ -1762,6 +1773,8 @@</span> <span class="p_context"> static void rbd_osd_req_callback(struct ceph_osd_request *osd_req,</span>
 		rbd_osd_stat_callback(obj_request);
 		break;
 	case CEPH_OSD_OP_CALL:
<span class="p_add">+		rbd_osd_call_callback(obj_request);</span>
<span class="p_add">+		break;</span>
 	case CEPH_OSD_OP_NOTIFY_ACK:
 	case CEPH_OSD_OP_WATCH:
 		rbd_osd_trivial_callback(obj_request);
<span class="p_chunk">@@ -2366,13 +2379,15 @@</span> <span class="p_context"> out_unwind:</span>
 }
 
 static void
<span class="p_del">-rbd_img_obj_copyup_callback(struct rbd_obj_request *obj_request)</span>
<span class="p_add">+rbd_osd_copyup_callback(struct rbd_obj_request *obj_request)</span>
 {
 	struct rbd_img_request *img_request;
 	struct rbd_device *rbd_dev;
 	struct page **pages;
 	u32 page_count;
 
<span class="p_add">+	dout(&quot;%s: obj %p\n&quot;, __func__, obj_request);</span>
<span class="p_add">+</span>
 	rbd_assert(obj_request-&gt;type == OBJ_REQUEST_BIO);
 	rbd_assert(obj_request_img_data_test(obj_request));
 	img_request = obj_request-&gt;img_request;
<span class="p_chunk">@@ -2398,9 +2413,7 @@</span> <span class="p_context"> rbd_img_obj_copyup_callback(struct rbd_obj_request *obj_request)</span>
 	if (!obj_request-&gt;result)
 		obj_request-&gt;xferred = obj_request-&gt;length;
 
<span class="p_del">-	/* Finish up with the normal image object callback */</span>
<span class="p_del">-</span>
<span class="p_del">-	rbd_img_obj_callback(obj_request);</span>
<span class="p_add">+	obj_request_done_set(obj_request);</span>
 }
 
 static void
<span class="p_chunk">@@ -2502,7 +2515,6 @@</span> <span class="p_context"> rbd_img_obj_parent_read_full_callback(struct rbd_img_request *img_request)</span>
 
 	/* All set, send it off. */
 
<span class="p_del">-	orig_request-&gt;callback = rbd_img_obj_copyup_callback;</span>
 	osdc = &amp;rbd_dev-&gt;rbd_client-&gt;client-&gt;osdc;
 	img_result = rbd_obj_request_submit(osdc, orig_request);
 	if (!img_result)
<span class="p_header">diff --git a/drivers/block/xen-blkback/blkback.c b/drivers/block/xen-blkback/blkback.c</span>
<span class="p_header">index 63fc7f06a014..02004e101678 100644</span>
<span class="p_header">--- a/drivers/block/xen-blkback/blkback.c</span>
<span class="p_header">+++ b/drivers/block/xen-blkback/blkback.c</span>
<span class="p_chunk">@@ -350,8 +350,8 @@</span> <span class="p_context"> static void purge_persistent_gnt(struct xen_blkif *blkif)</span>
 		return;
 	}
 
<span class="p_del">-	if (work_pending(&amp;blkif-&gt;persistent_purge_work)) {</span>
<span class="p_del">-		pr_alert_ratelimited(DRV_PFX &quot;Scheduled work from previous purge is still pending, cannot purge list\n&quot;);</span>
<span class="p_add">+	if (work_busy(&amp;blkif-&gt;persistent_purge_work)) {</span>
<span class="p_add">+		pr_alert_ratelimited(DRV_PFX &quot;Scheduled work from previous purge is still busy, cannot purge list\n&quot;);</span>
 		return;
 	}
 
<span class="p_header">diff --git a/drivers/block/xen-blkfront.c b/drivers/block/xen-blkfront.c</span>
<span class="p_header">index 5deb235bd18f..2a29cf69cd73 100644</span>
<span class="p_header">--- a/drivers/block/xen-blkfront.c</span>
<span class="p_header">+++ b/drivers/block/xen-blkfront.c</span>
<span class="p_chunk">@@ -1093,8 +1093,10 @@</span> <span class="p_context"> static void blkif_completion(struct blk_shadow *s, struct blkfront_info *info,</span>
 				 * Add the used indirect page back to the list of
 				 * available pages for indirect grefs.
 				 */
<span class="p_del">-				indirect_page = pfn_to_page(s-&gt;indirect_grants[i]-&gt;pfn);</span>
<span class="p_del">-				list_add(&amp;indirect_page-&gt;lru, &amp;info-&gt;indirect_pages);</span>
<span class="p_add">+				if (!info-&gt;feature_persistent) {</span>
<span class="p_add">+					indirect_page = pfn_to_page(s-&gt;indirect_grants[i]-&gt;pfn);</span>
<span class="p_add">+					list_add(&amp;indirect_page-&gt;lru, &amp;info-&gt;indirect_pages);</span>
<span class="p_add">+				}</span>
 				s-&gt;indirect_grants[i]-&gt;gref = GRANT_INVALID_REF;
 				list_add_tail(&amp;s-&gt;indirect_grants[i]-&gt;node, &amp;info-&gt;grants);
 			}
<span class="p_header">diff --git a/drivers/crypto/caam/caamhash.c b/drivers/crypto/caam/caamhash.c</span>
<span class="p_header">index 7e050b85b4f2..a22f9b473c22 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/caamhash.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/caamhash.c</span>
<span class="p_chunk">@@ -890,13 +890,14 @@</span> <span class="p_context"> static int ahash_final_ctx(struct ahash_request *req)</span>
 			  state-&gt;buflen_1;
 	u32 *sh_desc = ctx-&gt;sh_desc_fin, *desc;
 	dma_addr_t ptr = ctx-&gt;sh_desc_fin_dma;
<span class="p_del">-	int sec4_sg_bytes;</span>
<span class="p_add">+	int sec4_sg_bytes, sec4_sg_src_index;</span>
 	int digestsize = crypto_ahash_digestsize(ahash);
 	struct ahash_edesc *edesc;
 	int ret = 0;
 	int sh_len;
 
<span class="p_del">-	sec4_sg_bytes = (1 + (buflen ? 1 : 0)) * sizeof(struct sec4_sg_entry);</span>
<span class="p_add">+	sec4_sg_src_index = 1 + (buflen ? 1 : 0);</span>
<span class="p_add">+	sec4_sg_bytes = sec4_sg_src_index * sizeof(struct sec4_sg_entry);</span>
 
 	/* allocate space for base edesc and hw desc commands, link tables */
 	edesc = kmalloc(sizeof(struct ahash_edesc) + DESC_JOB_IO_LEN +
<span class="p_chunk">@@ -923,7 +924,7 @@</span> <span class="p_context"> static int ahash_final_ctx(struct ahash_request *req)</span>
 	state-&gt;buf_dma = try_buf_map_to_sec4_sg(jrdev, edesc-&gt;sec4_sg + 1,
 						buf, state-&gt;buf_dma, buflen,
 						last_buflen);
<span class="p_del">-	(edesc-&gt;sec4_sg + sec4_sg_bytes - 1)-&gt;len |= SEC4_SG_LEN_FIN;</span>
<span class="p_add">+	(edesc-&gt;sec4_sg + sec4_sg_src_index - 1)-&gt;len |= SEC4_SG_LEN_FIN;</span>
 
 	append_seq_in_ptr(desc, edesc-&gt;sec4_sg_dma, ctx-&gt;ctx_len + buflen,
 			  LDST_SGF);
<span class="p_header">diff --git a/drivers/crypto/ixp4xx_crypto.c b/drivers/crypto/ixp4xx_crypto.c</span>
<span class="p_header">index f757a0f428bd..3beed38d306a 100644</span>
<span class="p_header">--- a/drivers/crypto/ixp4xx_crypto.c</span>
<span class="p_header">+++ b/drivers/crypto/ixp4xx_crypto.c</span>
<span class="p_chunk">@@ -904,7 +904,6 @@</span> <span class="p_context"> static int ablk_perform(struct ablkcipher_request *req, int encrypt)</span>
 		crypt-&gt;mode |= NPE_OP_NOT_IN_PLACE;
 		/* This was never tested by Intel
 		 * for more than one dst buffer, I think. */
<span class="p_del">-		BUG_ON(req-&gt;dst-&gt;length &lt; nbytes);</span>
 		req_ctx-&gt;dst = NULL;
 		if (!chainup_buffers(dev, req-&gt;dst, nbytes, &amp;dst_hook,
 					flags, DMA_FROM_DEVICE))
<span class="p_header">diff --git a/drivers/edac/ppc4xx_edac.c b/drivers/edac/ppc4xx_edac.c</span>
<span class="p_header">index ef6b7e08f485..5c361f3c66aa 100644</span>
<span class="p_header">--- a/drivers/edac/ppc4xx_edac.c</span>
<span class="p_header">+++ b/drivers/edac/ppc4xx_edac.c</span>
<span class="p_chunk">@@ -921,7 +921,7 @@</span> <span class="p_context"> static int ppc4xx_edac_init_csrows(struct mem_ctl_info *mci, u32 mcopt1)</span>
 	 */
 
 	for (row = 0; row &lt; mci-&gt;nr_csrows; row++) {
<span class="p_del">-		struct csrow_info *csi = &amp;mci-&gt;csrows[row];</span>
<span class="p_add">+		struct csrow_info *csi = mci-&gt;csrows[row];</span>
 
 		/*
 		 * Get the configuration settings for this
<span class="p_header">diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c</span>
<span class="p_header">index dc79346689e6..583ef8d17e07 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/efi.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/efi.c</span>
<span class="p_chunk">@@ -41,7 +41,6 @@</span> <span class="p_context"> struct efi __read_mostly efi = {</span>
 EXPORT_SYMBOL(efi);
 
 static struct kobject *efi_kobj;
<span class="p_del">-static struct kobject *efivars_kobj;</span>
 
 /*
  * Let&#39;s not leave out systab information that snuck into
<span class="p_chunk">@@ -174,10 +173,9 @@</span> <span class="p_context"> static int __init efisubsys_init(void)</span>
 		goto err_remove_group;
 
 	/* and the standard mountpoint for efivarfs */
<span class="p_del">-	efivars_kobj = kobject_create_and_add(&quot;efivars&quot;, efi_kobj);</span>
<span class="p_del">-	if (!efivars_kobj) {</span>
<span class="p_add">+	error = sysfs_create_mount_point(efi_kobj, &quot;efivars&quot;);</span>
<span class="p_add">+	if (error) {</span>
 		pr_err(&quot;efivars: Subsystem registration failed.\n&quot;);
<span class="p_del">-		error = -ENOMEM;</span>
 		goto err_remove_group;
 	}
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_header">index 28c7afdfffbc..67f72fa5a769 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_chunk">@@ -2682,15 +2682,14 @@</span> <span class="p_context"> int vlv_freq_opcode(struct drm_i915_private *dev_priv, int val);</span>
 #define I915_READ64(reg)	dev_priv-&gt;uncore.funcs.mmio_readq(dev_priv, (reg), true)
 
 #define I915_READ64_2x32(lower_reg, upper_reg) ({			\
<span class="p_del">-		u32 upper = I915_READ(upper_reg);			\</span>
<span class="p_del">-		u32 lower = I915_READ(lower_reg);			\</span>
<span class="p_del">-		u32 tmp = I915_READ(upper_reg);				\</span>
<span class="p_del">-		if (upper != tmp) {					\</span>
<span class="p_del">-			upper = tmp;					\</span>
<span class="p_del">-			lower = I915_READ(lower_reg);			\</span>
<span class="p_del">-			WARN_ON(I915_READ(upper_reg) != upper);		\</span>
<span class="p_del">-		}							\</span>
<span class="p_del">-		(u64)upper &lt;&lt; 32 | lower; })</span>
<span class="p_add">+	u32 upper, lower, tmp;						\</span>
<span class="p_add">+	tmp = I915_READ(upper_reg);					\</span>
<span class="p_add">+	do {								\</span>
<span class="p_add">+		upper = tmp;						\</span>
<span class="p_add">+		lower = I915_READ(lower_reg);				\</span>
<span class="p_add">+		tmp = I915_READ(upper_reg);				\</span>
<span class="p_add">+	} while (upper != tmp);						\</span>
<span class="p_add">+	(u64)upper &lt;&lt; 32 | lower; })</span>
 
 #define POSTING_READ(reg)	(void)I915_READ_NOTRACE(reg)
 #define POSTING_READ16(reg)	(void)I915_READ16_NOTRACE(reg)
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_combios.c b/drivers/gpu/drm/radeon/radeon_combios.c</span>
<span class="p_header">index 6651177110f0..79a266934327 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_combios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_combios.c</span>
<span class="p_chunk">@@ -1255,10 +1255,15 @@</span> <span class="p_context"> struct radeon_encoder_lvds *radeon_combios_get_lvds_info(struct radeon_encoder</span>
 
 			if ((RBIOS16(tmp) == lvds-&gt;native_mode.hdisplay) &amp;&amp;
 			    (RBIOS16(tmp + 2) == lvds-&gt;native_mode.vdisplay)) {
<span class="p_add">+				u32 hss = (RBIOS16(tmp + 21) - RBIOS16(tmp + 19) - 1) * 8;</span>
<span class="p_add">+</span>
<span class="p_add">+				if (hss &gt; lvds-&gt;native_mode.hdisplay)</span>
<span class="p_add">+					hss = (10 - 1) * 8;</span>
<span class="p_add">+</span>
 				lvds-&gt;native_mode.htotal = lvds-&gt;native_mode.hdisplay +
 					(RBIOS16(tmp + 17) - RBIOS16(tmp + 19)) * 8;
 				lvds-&gt;native_mode.hsync_start = lvds-&gt;native_mode.hdisplay +
<span class="p_del">-					(RBIOS16(tmp + 21) - RBIOS16(tmp + 19) - 1) * 8;</span>
<span class="p_add">+					hss;</span>
 				lvds-&gt;native_mode.hsync_end = lvds-&gt;native_mode.hsync_start +
 					(RBIOS8(tmp + 23) * 8);
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_irq_kms.c b/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_header">index dd49f8c61878..4ae8c2c49d52 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_chunk">@@ -79,6 +79,11 @@</span> <span class="p_context"> static void radeon_hotplug_work_func(struct work_struct *work)</span>
 	struct drm_mode_config *mode_config = &amp;dev-&gt;mode_config;
 	struct drm_connector *connector;
 
<span class="p_add">+	/* we can race here at startup, some boards seem to trigger</span>
<span class="p_add">+	 * hotplug irqs when they shouldn&#39;t. */</span>
<span class="p_add">+	if (!rdev-&gt;mode_info.mode_config_initialized)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;mode_config-&gt;mutex);
 	if (mode_config-&gt;num_connector) {
 		list_for_each_entry(connector, &amp;mode_config-&gt;connector_list, head)
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c b/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_header">index 6f6fa7d2db47..3a21633eba2f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_chunk">@@ -2467,7 +2467,7 @@</span> <span class="p_context"> int vmw_execbuf_process(struct drm_file *file_priv,</span>
 
 	ret = ttm_eu_reserve_buffers(&amp;ticket, &amp;sw_context-&gt;validate_nodes);
 	if (unlikely(ret != 0))
<span class="p_del">-		goto out_err;</span>
<span class="p_add">+		goto out_err_nores;</span>
 
 	ret = vmw_validate_buffers(dev_priv, sw_context);
 	if (unlikely(ret != 0))
<span class="p_chunk">@@ -2511,6 +2511,7 @@</span> <span class="p_context"> int vmw_execbuf_process(struct drm_file *file_priv,</span>
 	vmw_resource_relocations_free(&amp;sw_context-&gt;res_relocations);
 
 	vmw_fifo_commit(dev_priv, command_size);
<span class="p_add">+	mutex_unlock(&amp;dev_priv-&gt;binding_mutex);</span>
 
 	vmw_query_bo_switch_commit(dev_priv, sw_context);
 	ret = vmw_execbuf_fence_commands(file_priv, dev_priv,
<span class="p_chunk">@@ -2526,7 +2527,6 @@</span> <span class="p_context"> int vmw_execbuf_process(struct drm_file *file_priv,</span>
 		DRM_ERROR(&quot;Fence submission error. Syncing.\n&quot;);
 
 	vmw_resource_list_unreserve(&amp;sw_context-&gt;resource_list, false);
<span class="p_del">-	mutex_unlock(&amp;dev_priv-&gt;binding_mutex);</span>
 
 	ttm_eu_fence_buffer_objects(&amp;ticket, &amp;sw_context-&gt;validate_nodes,
 				    (void *) fence);
<span class="p_header">diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h</span>
<span class="p_header">index e9aad0c8f2f7..2c04d93cacbd 100644</span>
<span class="p_header">--- a/drivers/hid/hid-ids.h</span>
<span class="p_header">+++ b/drivers/hid/hid-ids.h</span>
<span class="p_chunk">@@ -221,6 +221,7 @@</span> <span class="p_context"></span>
 #define USB_DEVICE_ID_CHICONY_TACTICAL_PAD	0x0418
 #define USB_DEVICE_ID_CHICONY_MULTI_TOUCH	0xb19d
 #define USB_DEVICE_ID_CHICONY_WIRELESS	0x0618
<span class="p_add">+#define USB_DEVICE_ID_CHICONY_PIXART_USB_OPTICAL_MOUSE	0x1053</span>
 #define USB_DEVICE_ID_CHICONY_WIRELESS2	0x1123
 #define USB_DEVICE_ID_CHICONY_AK1D	0x1125
 
<span class="p_header">diff --git a/drivers/hid/usbhid/hid-quirks.c b/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_header">index ba05afc22eb5..6579a71095da 100644</span>
<span class="p_header">--- a/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_header">+++ b/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_chunk">@@ -69,6 +69,7 @@</span> <span class="p_context"> static const struct hid_blacklist {</span>
 	{ USB_VENDOR_ID_CH, USB_DEVICE_ID_CH_PRO_PEDALS, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_CH, USB_DEVICE_ID_CH_3AXIS_5BUTTON_STICK, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_CH, USB_DEVICE_ID_CH_AXIS_295, HID_QUIRK_NOGET },
<span class="p_add">+	{ USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_PIXART_USB_OPTICAL_MOUSE, HID_QUIRK_ALWAYS_POLL },</span>
 	{ USB_VENDOR_ID_DMI, USB_DEVICE_ID_DMI_ENC, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_ELAN, USB_DEVICE_ID_ELAN_TOUCHSCREEN, HID_QUIRK_ALWAYS_POLL },
 	{ USB_VENDOR_ID_ELAN, USB_DEVICE_ID_ELAN_TOUCHSCREEN_009B, HID_QUIRK_ALWAYS_POLL },
<span class="p_header">diff --git a/drivers/md/bitmap.c b/drivers/md/bitmap.c</span>
<span class="p_header">index da3604e73e8a..cced062cab4b 100644</span>
<span class="p_header">--- a/drivers/md/bitmap.c</span>
<span class="p_header">+++ b/drivers/md/bitmap.c</span>
<span class="p_chunk">@@ -564,6 +564,8 @@</span> <span class="p_context"> static int bitmap_read_sb(struct bitmap *bitmap)</span>
 	if (err)
 		return err;
 
<span class="p_add">+	err = -EINVAL;</span>
<span class="p_add">+</span>
 	sb = kmap_atomic(sb_page);
 
 	chunksize = le32_to_cpu(sb-&gt;chunksize);
<span class="p_header">diff --git a/drivers/md/dm-thin-metadata.c b/drivers/md/dm-thin-metadata.c</span>
<span class="p_header">index e9d33ad59df5..3412b86e79fd 100644</span>
<span class="p_header">--- a/drivers/md/dm-thin-metadata.c</span>
<span class="p_header">+++ b/drivers/md/dm-thin-metadata.c</span>
<span class="p_chunk">@@ -1295,8 +1295,8 @@</span> <span class="p_context"> static int __release_metadata_snap(struct dm_pool_metadata *pmd)</span>
 		return r;
 
 	disk_super = dm_block_data(copy);
<span class="p_del">-	dm_sm_dec_block(pmd-&gt;metadata_sm, le64_to_cpu(disk_super-&gt;data_mapping_root));</span>
<span class="p_del">-	dm_sm_dec_block(pmd-&gt;metadata_sm, le64_to_cpu(disk_super-&gt;device_details_root));</span>
<span class="p_add">+	dm_btree_del(&amp;pmd-&gt;info, le64_to_cpu(disk_super-&gt;data_mapping_root));</span>
<span class="p_add">+	dm_btree_del(&amp;pmd-&gt;details_info, le64_to_cpu(disk_super-&gt;device_details_root));</span>
 	dm_sm_dec_block(pmd-&gt;metadata_sm, held_root);
 
 	return dm_tm_unlock(pmd-&gt;tm, copy);
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index 8276c3b29ab4..b6eddaf97541 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -5624,7 +5624,7 @@</span> <span class="p_context"> static int get_bitmap_file(struct mddev * mddev, void __user * arg)</span>
 	char *ptr, *buf = NULL;
 	int err = -ENOMEM;
 
<span class="p_del">-	file = kmalloc(sizeof(*file), GFP_NOIO);</span>
<span class="p_add">+	file = kzalloc(sizeof(*file), GFP_NOIO);</span>
 
 	if (!file)
 		goto out;
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree-internal.h b/drivers/md/persistent-data/dm-btree-internal.h</span>
<span class="p_header">index bf2b80d5c470..8731b6ea026b 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree-internal.h</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree-internal.h</span>
<span class="p_chunk">@@ -138,4 +138,10 @@</span> <span class="p_context"> int lower_bound(struct btree_node *n, uint64_t key);</span>
 
 extern struct dm_block_validator btree_node_validator;
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Value type for upper levels of multi-level btrees.</span>
<span class="p_add">+ */</span>
<span class="p_add">+extern void init_le64_type(struct dm_transaction_manager *tm,</span>
<span class="p_add">+			   struct dm_btree_value_type *vt);</span>
<span class="p_add">+</span>
 #endif	/* DM_BTREE_INTERNAL_H */
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree-remove.c b/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_header">index a03178e91a79..7c0d75547ccf 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_chunk">@@ -544,14 +544,6 @@</span> <span class="p_context"> static int remove_raw(struct shadow_spine *s, struct dm_btree_info *info,</span>
 	return r;
 }
 
<span class="p_del">-static struct dm_btree_value_type le64_type = {</span>
<span class="p_del">-	.context = NULL,</span>
<span class="p_del">-	.size = sizeof(__le64),</span>
<span class="p_del">-	.inc = NULL,</span>
<span class="p_del">-	.dec = NULL,</span>
<span class="p_del">-	.equal = NULL</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 int dm_btree_remove(struct dm_btree_info *info, dm_block_t root,
 		    uint64_t *keys, dm_block_t *new_root)
 {
<span class="p_chunk">@@ -559,12 +551,14 @@</span> <span class="p_context"> int dm_btree_remove(struct dm_btree_info *info, dm_block_t root,</span>
 	int index = 0, r = 0;
 	struct shadow_spine spine;
 	struct btree_node *n;
<span class="p_add">+	struct dm_btree_value_type le64_vt;</span>
 
<span class="p_add">+	init_le64_type(info-&gt;tm, &amp;le64_vt);</span>
 	init_shadow_spine(&amp;spine, info);
 	for (level = 0; level &lt; info-&gt;levels; level++) {
 		r = remove_raw(&amp;spine, info,
 			       (level == last_level ?
<span class="p_del">-				&amp;info-&gt;value_type : &amp;le64_type),</span>
<span class="p_add">+				&amp;info-&gt;value_type : &amp;le64_vt),</span>
 			       root, keys[level], (unsigned *)&amp;index);
 		if (r &lt; 0)
 			break;
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree-spine.c b/drivers/md/persistent-data/dm-btree-spine.c</span>
<span class="p_header">index 1b5e13ec7f96..0dee514ba4c5 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree-spine.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree-spine.c</span>
<span class="p_chunk">@@ -249,3 +249,40 @@</span> <span class="p_context"> int shadow_root(struct shadow_spine *s)</span>
 {
 	return s-&gt;root;
 }
<span class="p_add">+</span>
<span class="p_add">+static void le64_inc(void *context, const void *value_le)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct dm_transaction_manager *tm = context;</span>
<span class="p_add">+	__le64 v_le;</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy(&amp;v_le, value_le, sizeof(v_le));</span>
<span class="p_add">+	dm_tm_inc(tm, le64_to_cpu(v_le));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void le64_dec(void *context, const void *value_le)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct dm_transaction_manager *tm = context;</span>
<span class="p_add">+	__le64 v_le;</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy(&amp;v_le, value_le, sizeof(v_le));</span>
<span class="p_add">+	dm_tm_dec(tm, le64_to_cpu(v_le));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int le64_equal(void *context, const void *value1_le, const void *value2_le)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__le64 v1_le, v2_le;</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy(&amp;v1_le, value1_le, sizeof(v1_le));</span>
<span class="p_add">+	memcpy(&amp;v2_le, value2_le, sizeof(v2_le));</span>
<span class="p_add">+	return v1_le == v2_le;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void init_le64_type(struct dm_transaction_manager *tm,</span>
<span class="p_add">+		    struct dm_btree_value_type *vt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	vt-&gt;context = tm;</span>
<span class="p_add">+	vt-&gt;size = sizeof(__le64);</span>
<span class="p_add">+	vt-&gt;inc = le64_inc;</span>
<span class="p_add">+	vt-&gt;dec = le64_dec;</span>
<span class="p_add">+	vt-&gt;equal = le64_equal;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree.c b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">index fdd3793e22f9..c7726cebc495 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_chunk">@@ -667,12 +667,7 @@</span> <span class="p_context"> static int insert(struct dm_btree_info *info, dm_block_t root,</span>
 	struct btree_node *n;
 	struct dm_btree_value_type le64_type;
 
<span class="p_del">-	le64_type.context = NULL;</span>
<span class="p_del">-	le64_type.size = sizeof(__le64);</span>
<span class="p_del">-	le64_type.inc = NULL;</span>
<span class="p_del">-	le64_type.dec = NULL;</span>
<span class="p_del">-	le64_type.equal = NULL;</span>
<span class="p_del">-</span>
<span class="p_add">+	init_le64_type(info-&gt;tm, &amp;le64_type);</span>
 	init_shadow_spine(&amp;spine, info);
 
 	for (level = 0; level &lt; (info-&gt;levels - 1); level++) {
<span class="p_header">diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c</span>
<span class="p_header">index 9be97e0bd149..47b7c3136807 100644</span>
<span class="p_header">--- a/drivers/md/raid1.c</span>
<span class="p_header">+++ b/drivers/md/raid1.c</span>
<span class="p_chunk">@@ -1477,6 +1477,7 @@</span> <span class="p_context"> static void error(struct mddev *mddev, struct md_rdev *rdev)</span>
 {
 	char b[BDEVNAME_SIZE];
 	struct r1conf *conf = mddev-&gt;private;
<span class="p_add">+	unsigned long flags;</span>
 
 	/*
 	 * If it is not operational, then we have already marked it as dead
<span class="p_chunk">@@ -1496,14 +1497,13 @@</span> <span class="p_context"> static void error(struct mddev *mddev, struct md_rdev *rdev)</span>
 		return;
 	}
 	set_bit(Blocked, &amp;rdev-&gt;flags);
<span class="p_add">+	spin_lock_irqsave(&amp;conf-&gt;device_lock, flags);</span>
 	if (test_and_clear_bit(In_sync, &amp;rdev-&gt;flags)) {
<span class="p_del">-		unsigned long flags;</span>
<span class="p_del">-		spin_lock_irqsave(&amp;conf-&gt;device_lock, flags);</span>
 		mddev-&gt;degraded++;
 		set_bit(Faulty, &amp;rdev-&gt;flags);
<span class="p_del">-		spin_unlock_irqrestore(&amp;conf-&gt;device_lock, flags);</span>
 	} else
 		set_bit(Faulty, &amp;rdev-&gt;flags);
<span class="p_add">+	spin_unlock_irqrestore(&amp;conf-&gt;device_lock, flags);</span>
 	/*
 	 * if recovery is running, make sure it aborts.
 	 */
<span class="p_chunk">@@ -1569,7 +1569,10 @@</span> <span class="p_context"> static int raid1_spare_active(struct mddev *mddev)</span>
 	 * Find all failed disks within the RAID1 configuration 
 	 * and mark them readable.
 	 * Called under mddev lock, so rcu protection not needed.
<span class="p_add">+	 * device_lock used to avoid races with raid1_end_read_request</span>
<span class="p_add">+	 * which expects &#39;In_sync&#39; flags and -&gt;degraded to be consistent.</span>
 	 */
<span class="p_add">+	spin_lock_irqsave(&amp;conf-&gt;device_lock, flags);</span>
 	for (i = 0; i &lt; conf-&gt;raid_disks; i++) {
 		struct md_rdev *rdev = conf-&gt;mirrors[i].rdev;
 		struct md_rdev *repl = conf-&gt;mirrors[conf-&gt;raid_disks + i].rdev;
<span class="p_chunk">@@ -1599,7 +1602,6 @@</span> <span class="p_context"> static int raid1_spare_active(struct mddev *mddev)</span>
 			sysfs_notify_dirent_safe(rdev-&gt;sysfs_state);
 		}
 	}
<span class="p_del">-	spin_lock_irqsave(&amp;conf-&gt;device_lock, flags);</span>
 	mddev-&gt;degraded -= count;
 	spin_unlock_irqrestore(&amp;conf-&gt;device_lock, flags);
 
<span class="p_header">diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c</span>
<span class="p_header">index cfc191abae4a..1577e6418306 100644</span>
<span class="p_header">--- a/drivers/mfd/arizona-core.c</span>
<span class="p_header">+++ b/drivers/mfd/arizona-core.c</span>
<span class="p_chunk">@@ -867,10 +867,6 @@</span> <span class="p_context"> int arizona_dev_init(struct arizona *arizona)</span>
 			     arizona-&gt;pdata.gpio_defaults[i]);
 	}
 
<span class="p_del">-	pm_runtime_set_autosuspend_delay(arizona-&gt;dev, 100);</span>
<span class="p_del">-	pm_runtime_use_autosuspend(arizona-&gt;dev);</span>
<span class="p_del">-	pm_runtime_enable(arizona-&gt;dev);</span>
<span class="p_del">-</span>
 	/* Chip default */
 	if (!arizona-&gt;pdata.clk32k_src)
 		arizona-&gt;pdata.clk32k_src = ARIZONA_32KZ_MCLK2;
<span class="p_chunk">@@ -966,11 +962,17 @@</span> <span class="p_context"> int arizona_dev_init(struct arizona *arizona)</span>
 					   arizona-&gt;pdata.spk_fmt[i]);
 	}
 
<span class="p_add">+	pm_runtime_set_active(arizona-&gt;dev);</span>
<span class="p_add">+	pm_runtime_enable(arizona-&gt;dev);</span>
<span class="p_add">+</span>
 	/* Set up for interrupts */
 	ret = arizona_irq_init(arizona);
 	if (ret != 0)
 		goto err_reset;
 
<span class="p_add">+	pm_runtime_set_autosuspend_delay(arizona-&gt;dev, 100);</span>
<span class="p_add">+	pm_runtime_use_autosuspend(arizona-&gt;dev);</span>
<span class="p_add">+</span>
 	arizona_request_irq(arizona, ARIZONA_IRQ_CLKGEN_ERR, &quot;CLKGEN error&quot;,
 			    arizona_clkgen_err, arizona);
 	arizona_request_irq(arizona, ARIZONA_IRQ_OVERCLOCKED, &quot;Overclocked&quot;,
<span class="p_chunk">@@ -998,10 +1000,6 @@</span> <span class="p_context"> int arizona_dev_init(struct arizona *arizona)</span>
 		goto err_irq;
 	}
 
<span class="p_del">-#ifdef CONFIG_PM_RUNTIME</span>
<span class="p_del">-	regulator_disable(arizona-&gt;dcvdd);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 	return 0;
 
 err_irq:
<span class="p_header">diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c</span>
<span class="p_header">index e7421fa1d103..ddb2e2564470 100644</span>
<span class="p_header">--- a/drivers/net/bonding/bond_main.c</span>
<span class="p_header">+++ b/drivers/net/bonding/bond_main.c</span>
<span class="p_chunk">@@ -636,6 +636,23 @@</span> <span class="p_context"> static void bond_set_dev_addr(struct net_device *bond_dev,</span>
 	call_netdevice_notifiers(NETDEV_CHANGEADDR, bond_dev);
 }
 
<span class="p_add">+static struct slave *bond_get_old_active(struct bonding *bond,</span>
<span class="p_add">+					 struct slave *new_active)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct slave *slave;</span>
<span class="p_add">+	struct list_head *iter;</span>
<span class="p_add">+</span>
<span class="p_add">+	bond_for_each_slave(bond, slave, iter) {</span>
<span class="p_add">+		if (slave == new_active)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ether_addr_equal(bond-&gt;dev-&gt;dev_addr, slave-&gt;dev-&gt;dev_addr))</span>
<span class="p_add">+			return slave;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * bond_do_fail_over_mac
  *
<span class="p_chunk">@@ -672,6 +689,9 @@</span> <span class="p_context"> static void bond_do_fail_over_mac(struct bonding *bond,</span>
 
 		write_unlock_bh(&amp;bond-&gt;curr_slave_lock);
 
<span class="p_add">+		if (!old_active)</span>
<span class="p_add">+			old_active = bond_get_old_active(bond, new_active);</span>
<span class="p_add">+</span>
 		if (old_active) {
 			ether_addr_copy(tmp_mac, new_active-&gt;dev-&gt;dev_addr);
 			ether_addr_copy(saddr.sa_data,
<span class="p_header">diff --git a/drivers/net/ethernet/brocade/bna/bnad.c b/drivers/net/ethernet/brocade/bna/bnad.c</span>
<span class="p_header">index 556aab75f490..04c4d4d85008 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/brocade/bna/bnad.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/brocade/bna/bnad.c</span>
<span class="p_chunk">@@ -674,6 +674,7 @@</span> <span class="p_context"> bnad_cq_process(struct bnad *bnad, struct bna_ccb *ccb, int budget)</span>
 			if (!next_cmpl-&gt;valid)
 				break;
 		}
<span class="p_add">+		packets++;</span>
 
 		/* TODO: BNA_CQ_EF_LOCAL ? */
 		if (unlikely(flags &amp; (BNA_CQ_EF_MAC_ERROR |
<span class="p_chunk">@@ -690,7 +691,6 @@</span> <span class="p_context"> bnad_cq_process(struct bnad *bnad, struct bna_ccb *ccb, int budget)</span>
 		else
 			bnad_cq_setup_skb_frags(rcb, skb, sop_ci, nvecs, len);
 
<span class="p_del">-		packets++;</span>
 		rcb-&gt;rxq-&gt;rx_packets++;
 		rcb-&gt;rxq-&gt;rx_bytes += totlen;
 		ccb-&gt;bytes_per_intr += totlen;
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/eq.c b/drivers/net/ethernet/mellanox/mlx4/eq.c</span>
<span class="p_header">index 2a004b347e1d..1a4df2ff2b6a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/eq.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/eq.c</span>
<span class="p_chunk">@@ -564,7 +564,7 @@</span> <span class="p_context"> static int mlx4_eq_int(struct mlx4_dev *dev, struct mlx4_eq *eq)</span>
 							continue;
 						mlx4_dbg(dev, &quot;%s: Sending MLX4_PORT_CHANGE_SUBTYPE_DOWN to slave: %d, port:%d\n&quot;,
 							 __func__, i, port);
<span class="p_del">-						s_info = &amp;priv-&gt;mfunc.master.vf_oper[slave].vport[port].state;</span>
<span class="p_add">+						s_info = &amp;priv-&gt;mfunc.master.vf_oper[i].vport[port].state;</span>
 						if (IFLA_VF_LINK_STATE_AUTO == s_info-&gt;link_state) {
 							eqe-&gt;event.port_change.port =
 								cpu_to_be32(
<span class="p_chunk">@@ -597,7 +597,7 @@</span> <span class="p_context"> static int mlx4_eq_int(struct mlx4_dev *dev, struct mlx4_eq *eq)</span>
 							continue;
 						if (i == mlx4_master_func_num(dev))
 							continue;
<span class="p_del">-						s_info = &amp;priv-&gt;mfunc.master.vf_oper[slave].vport[port].state;</span>
<span class="p_add">+						s_info = &amp;priv-&gt;mfunc.master.vf_oper[i].vport[port].state;</span>
 						if (IFLA_VF_LINK_STATE_AUTO == s_info-&gt;link_state) {
 							eqe-&gt;event.port_change.port =
 								cpu_to_be32(
<span class="p_header">diff --git a/drivers/net/ethernet/sun/niu.c b/drivers/net/ethernet/sun/niu.c</span>
<span class="p_header">index 79606f47a08e..59624eb70308 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sun/niu.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sun/niu.c</span>
<span class="p_chunk">@@ -6665,10 +6665,8 @@</span> <span class="p_context"> static netdev_tx_t niu_start_xmit(struct sk_buff *skb,</span>
 		struct sk_buff *skb_new;
 
 		skb_new = skb_realloc_headroom(skb, len);
<span class="p_del">-		if (!skb_new) {</span>
<span class="p_del">-			rp-&gt;tx_errors++;</span>
<span class="p_add">+		if (!skb_new)</span>
 			goto out_drop;
<span class="p_del">-		}</span>
 		kfree_skb(skb);
 		skb = skb_new;
 	} else
<span class="p_header">diff --git a/drivers/s390/char/sclp_early.c b/drivers/s390/char/sclp_early.c</span>
<span class="p_header">index 1918d9dff45d..45c3d7041c81 100644</span>
<span class="p_header">--- a/drivers/s390/char/sclp_early.c</span>
<span class="p_header">+++ b/drivers/s390/char/sclp_early.c</span>
<span class="p_chunk">@@ -7,6 +7,7 @@</span> <span class="p_context"></span>
 #define KMSG_COMPONENT &quot;sclp_early&quot;
 #define pr_fmt(fmt) KMSG_COMPONENT &quot;: &quot; fmt
 
<span class="p_add">+#include &lt;linux/errno.h&gt;</span>
 #include &lt;asm/ctl_reg.h&gt;
 #include &lt;asm/sclp.h&gt;
 #include &lt;asm/ipl.h&gt;
<span class="p_header">diff --git a/drivers/scsi/ipr.c b/drivers/scsi/ipr.c</span>
<span class="p_header">index 748ed71dd92b..d2c3fdcf90ba 100644</span>
<span class="p_header">--- a/drivers/scsi/ipr.c</span>
<span class="p_header">+++ b/drivers/scsi/ipr.c</span>
<span class="p_chunk">@@ -592,9 +592,10 @@</span> <span class="p_context"> static void ipr_trc_hook(struct ipr_cmnd *ipr_cmd,</span>
 {
 	struct ipr_trace_entry *trace_entry;
 	struct ipr_ioa_cfg *ioa_cfg = ipr_cmd-&gt;ioa_cfg;
<span class="p_add">+	unsigned int trace_index;</span>
 
<span class="p_del">-	trace_entry = &amp;ioa_cfg-&gt;trace[atomic_add_return</span>
<span class="p_del">-			(1, &amp;ioa_cfg-&gt;trace_index)%IPR_NUM_TRACE_ENTRIES];</span>
<span class="p_add">+	trace_index = atomic_add_return(1, &amp;ioa_cfg-&gt;trace_index) &amp; IPR_TRACE_INDEX_MASK;</span>
<span class="p_add">+	trace_entry = &amp;ioa_cfg-&gt;trace[trace_index];</span>
 	trace_entry-&gt;time = jiffies;
 	trace_entry-&gt;op_code = ipr_cmd-&gt;ioarcb.cmd_pkt.cdb[0];
 	trace_entry-&gt;type = type;
<span class="p_chunk">@@ -1044,10 +1045,15 @@</span> <span class="p_context"> static void ipr_send_blocking_cmd(struct ipr_cmnd *ipr_cmd,</span>
 
 static int ipr_get_hrrq_index(struct ipr_ioa_cfg *ioa_cfg)
 {
<span class="p_add">+	unsigned int hrrq;</span>
<span class="p_add">+</span>
 	if (ioa_cfg-&gt;hrrq_num == 1)
<span class="p_del">-		return 0;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		return (atomic_add_return(1, &amp;ioa_cfg-&gt;hrrq_index) % (ioa_cfg-&gt;hrrq_num - 1)) + 1;</span>
<span class="p_add">+		hrrq = 0;</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		hrrq = atomic_add_return(1, &amp;ioa_cfg-&gt;hrrq_index);</span>
<span class="p_add">+		hrrq = (hrrq % (ioa_cfg-&gt;hrrq_num - 1)) + 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return hrrq;</span>
 }
 
 /**
<span class="p_chunk">@@ -6217,21 +6223,23 @@</span> <span class="p_context"> static void ipr_scsi_done(struct ipr_cmnd *ipr_cmd)</span>
 	struct ipr_ioa_cfg *ioa_cfg = ipr_cmd-&gt;ioa_cfg;
 	struct scsi_cmnd *scsi_cmd = ipr_cmd-&gt;scsi_cmd;
 	u32 ioasc = be32_to_cpu(ipr_cmd-&gt;s.ioasa.hdr.ioasc);
<span class="p_del">-	unsigned long hrrq_flags;</span>
<span class="p_add">+	unsigned long lock_flags;</span>
 
 	scsi_set_resid(scsi_cmd, be32_to_cpu(ipr_cmd-&gt;s.ioasa.hdr.residual_data_len));
 
 	if (likely(IPR_IOASC_SENSE_KEY(ioasc) == 0)) {
 		scsi_dma_unmap(scsi_cmd);
 
<span class="p_del">-		spin_lock_irqsave(ipr_cmd-&gt;hrrq-&gt;lock, hrrq_flags);</span>
<span class="p_add">+		spin_lock_irqsave(ipr_cmd-&gt;hrrq-&gt;lock, lock_flags);</span>
 		list_add_tail(&amp;ipr_cmd-&gt;queue, &amp;ipr_cmd-&gt;hrrq-&gt;hrrq_free_q);
 		scsi_cmd-&gt;scsi_done(scsi_cmd);
<span class="p_del">-		spin_unlock_irqrestore(ipr_cmd-&gt;hrrq-&gt;lock, hrrq_flags);</span>
<span class="p_add">+		spin_unlock_irqrestore(ipr_cmd-&gt;hrrq-&gt;lock, lock_flags);</span>
 	} else {
<span class="p_del">-		spin_lock_irqsave(ipr_cmd-&gt;hrrq-&gt;lock, hrrq_flags);</span>
<span class="p_add">+		spin_lock_irqsave(ioa_cfg-&gt;host-&gt;host_lock, lock_flags);</span>
<span class="p_add">+		spin_lock(&amp;ipr_cmd-&gt;hrrq-&gt;_lock);</span>
 		ipr_erp_start(ioa_cfg, ipr_cmd);
<span class="p_del">-		spin_unlock_irqrestore(ipr_cmd-&gt;hrrq-&gt;lock, hrrq_flags);</span>
<span class="p_add">+		spin_unlock(&amp;ipr_cmd-&gt;hrrq-&gt;_lock);</span>
<span class="p_add">+		spin_unlock_irqrestore(ioa_cfg-&gt;host-&gt;host_lock, lock_flags);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/scsi/ipr.h b/drivers/scsi/ipr.h</span>
<span class="p_header">index b22b23586f93..2459391105fc 100644</span>
<span class="p_header">--- a/drivers/scsi/ipr.h</span>
<span class="p_header">+++ b/drivers/scsi/ipr.h</span>
<span class="p_chunk">@@ -1480,6 +1480,7 @@</span> <span class="p_context"> struct ipr_ioa_cfg {</span>
 
 #define IPR_NUM_TRACE_INDEX_BITS	8
 #define IPR_NUM_TRACE_ENTRIES		(1 &lt;&lt; IPR_NUM_TRACE_INDEX_BITS)
<span class="p_add">+#define IPR_TRACE_INDEX_MASK		(IPR_NUM_TRACE_ENTRIES - 1)</span>
 #define IPR_TRACE_SIZE	(sizeof(struct ipr_trace_entry) * IPR_NUM_TRACE_ENTRIES)
 	char trace_start[8];
 #define IPR_TRACE_START_LABEL			&quot;trace&quot;
<span class="p_header">diff --git a/drivers/scsi/libfc/fc_exch.c b/drivers/scsi/libfc/fc_exch.c</span>
<span class="p_header">index 1b3a09473452..30f9ef0c0d4f 100644</span>
<span class="p_header">--- a/drivers/scsi/libfc/fc_exch.c</span>
<span class="p_header">+++ b/drivers/scsi/libfc/fc_exch.c</span>
<span class="p_chunk">@@ -733,8 +733,6 @@</span> <span class="p_context"> static bool fc_invoke_resp(struct fc_exch *ep, struct fc_seq *sp,</span>
 	if (resp) {
 		resp(sp, fp, arg);
 		res = true;
<span class="p_del">-	} else if (!IS_ERR(fp)) {</span>
<span class="p_del">-		fc_frame_free(fp);</span>
 	}
 
 	spin_lock_bh(&amp;ep-&gt;ex_lock);
<span class="p_chunk">@@ -1596,7 +1594,8 @@</span> <span class="p_context"> static void fc_exch_recv_seq_resp(struct fc_exch_mgr *mp, struct fc_frame *fp)</span>
 	 * If new exch resp handler is valid then call that
 	 * first.
 	 */
<span class="p_del">-	fc_invoke_resp(ep, sp, fp);</span>
<span class="p_add">+	if (!fc_invoke_resp(ep, sp, fp))</span>
<span class="p_add">+		fc_frame_free(fp);</span>
 
 	fc_exch_release(ep);
 	return;
<span class="p_chunk">@@ -1695,7 +1694,8 @@</span> <span class="p_context"> static void fc_exch_abts_resp(struct fc_exch *ep, struct fc_frame *fp)</span>
 	fc_exch_hold(ep);
 	if (!rc)
 		fc_exch_delete(ep);
<span class="p_del">-	fc_invoke_resp(ep, sp, fp);</span>
<span class="p_add">+	if (!fc_invoke_resp(ep, sp, fp))</span>
<span class="p_add">+		fc_frame_free(fp);</span>
 	if (has_rec)
 		fc_exch_timer_set(ep, ep-&gt;r_a_tov);
 	fc_exch_release(ep);
<span class="p_header">diff --git a/drivers/scsi/libfc/fc_fcp.c b/drivers/scsi/libfc/fc_fcp.c</span>
<span class="p_header">index 1d7e76e8b447..ae6fc1a94568 100644</span>
<span class="p_header">--- a/drivers/scsi/libfc/fc_fcp.c</span>
<span class="p_header">+++ b/drivers/scsi/libfc/fc_fcp.c</span>
<span class="p_chunk">@@ -1039,11 +1039,26 @@</span> <span class="p_context"> restart:</span>
 		fc_fcp_pkt_hold(fsp);
 		spin_unlock_irqrestore(&amp;si-&gt;scsi_queue_lock, flags);
 
<span class="p_del">-		if (!fc_fcp_lock_pkt(fsp)) {</span>
<span class="p_add">+		spin_lock_bh(&amp;fsp-&gt;scsi_pkt_lock);</span>
<span class="p_add">+		if (!(fsp-&gt;state &amp; FC_SRB_COMPL)) {</span>
<span class="p_add">+			fsp-&gt;state |= FC_SRB_COMPL;</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * TODO: dropping scsi_pkt_lock and then reacquiring</span>
<span class="p_add">+			 * again around fc_fcp_cleanup_cmd() is required,</span>
<span class="p_add">+			 * since fc_fcp_cleanup_cmd() calls into</span>
<span class="p_add">+			 * fc_seq_set_resp() and that func preempts cpu using</span>
<span class="p_add">+			 * schedule. May be schedule and related code should be</span>
<span class="p_add">+			 * removed instead of unlocking here to avoid scheduling</span>
<span class="p_add">+			 * while atomic bug.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			spin_unlock_bh(&amp;fsp-&gt;scsi_pkt_lock);</span>
<span class="p_add">+</span>
 			fc_fcp_cleanup_cmd(fsp, error);
<span class="p_add">+</span>
<span class="p_add">+			spin_lock_bh(&amp;fsp-&gt;scsi_pkt_lock);</span>
 			fc_io_compl(fsp);
<span class="p_del">-			fc_fcp_unlock_pkt(fsp);</span>
 		}
<span class="p_add">+		spin_unlock_bh(&amp;fsp-&gt;scsi_pkt_lock);</span>
 
 		fc_fcp_pkt_release(fsp);
 		spin_lock_irqsave(&amp;si-&gt;scsi_queue_lock, flags);
<span class="p_header">diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c</span>
<span class="p_header">index 874bc950b9f6..cd4d4b1f371d 100644</span>
<span class="p_header">--- a/drivers/scsi/libiscsi.c</span>
<span class="p_header">+++ b/drivers/scsi/libiscsi.c</span>
<span class="p_chunk">@@ -2960,10 +2960,10 @@</span> <span class="p_context"> void iscsi_conn_teardown(struct iscsi_cls_conn *cls_conn)</span>
 {
 	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
 	struct iscsi_session *session = conn-&gt;session;
<span class="p_del">-	unsigned long flags;</span>
 
 	del_timer_sync(&amp;conn-&gt;transport_timer);
 
<span class="p_add">+	mutex_lock(&amp;session-&gt;eh_mutex);</span>
 	spin_lock_bh(&amp;session-&gt;frwd_lock);
 	conn-&gt;c_stage = ISCSI_CONN_CLEANUP_WAIT;
 	if (session-&gt;leadconn == conn) {
<span class="p_chunk">@@ -2975,28 +2975,6 @@</span> <span class="p_context"> void iscsi_conn_teardown(struct iscsi_cls_conn *cls_conn)</span>
 	}
 	spin_unlock_bh(&amp;session-&gt;frwd_lock);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Block until all in-progress commands for this connection</span>
<span class="p_del">-	 * time out or fail.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	for (;;) {</span>
<span class="p_del">-		spin_lock_irqsave(session-&gt;host-&gt;host_lock, flags);</span>
<span class="p_del">-		if (!session-&gt;host-&gt;host_busy) { /* OK for ERL == 0 */</span>
<span class="p_del">-			spin_unlock_irqrestore(session-&gt;host-&gt;host_lock, flags);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		spin_unlock_irqrestore(session-&gt;host-&gt;host_lock, flags);</span>
<span class="p_del">-		msleep_interruptible(500);</span>
<span class="p_del">-		iscsi_conn_printk(KERN_INFO, conn, &quot;iscsi conn_destroy(): &quot;</span>
<span class="p_del">-				  &quot;host_busy %d host_failed %d\n&quot;,</span>
<span class="p_del">-				  session-&gt;host-&gt;host_busy,</span>
<span class="p_del">-				  session-&gt;host-&gt;host_failed);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * force eh_abort() to unblock</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		wake_up(&amp;conn-&gt;ehwait);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	/* flush queued up work because we free the connection below */
 	iscsi_suspend_tx(conn);
 
<span class="p_chunk">@@ -3013,6 +2991,7 @@</span> <span class="p_context"> void iscsi_conn_teardown(struct iscsi_cls_conn *cls_conn)</span>
 	if (session-&gt;leadconn == conn)
 		session-&gt;leadconn = NULL;
 	spin_unlock_bh(&amp;session-&gt;frwd_lock);
<span class="p_add">+	mutex_unlock(&amp;session-&gt;eh_mutex);</span>
 
 	iscsi_destroy_conn(cls_conn);
 }
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_fusion.c b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">index 9872ccb28f1f..f16764bf9964 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_chunk">@@ -1500,11 +1500,11 @@</span> <span class="p_context"> megasas_build_ldio_fusion(struct megasas_instance *instance,</span>
 			fp_possible = io_info.fpOkForIo;
 	}
 
<span class="p_del">-	/* Use smp_processor_id() for now until cmd-&gt;request-&gt;cpu is CPU</span>
<span class="p_add">+	/* Use raw_smp_processor_id() for now until cmd-&gt;request-&gt;cpu is CPU</span>
 	   id by default, not CPU group id, otherwise all MSI-X queues won&#39;t
 	   be utilized */
 	cmd-&gt;request_desc-&gt;SCSIIO.MSIxIndex = instance-&gt;msix_vectors ?
<span class="p_del">-		smp_processor_id() % instance-&gt;msix_vectors : 0;</span>
<span class="p_add">+		raw_smp_processor_id() % instance-&gt;msix_vectors : 0;</span>
 
 	if (fp_possible) {
 		megasas_set_pd_lba(io_request, scp-&gt;cmd_len, &amp;io_info, scp,
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_isr.c b/drivers/scsi/qla2xxx/qla_isr.c</span>
<span class="p_header">index a56825c73c31..e87f4a62af0c 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_isr.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_isr.c</span>
<span class="p_chunk">@@ -573,8 +573,9 @@</span> <span class="p_context"> qla2x00_async_event(scsi_qla_host_t *vha, struct rsp_que *rsp, uint16_t *mb)</span>
 	struct device_reg_2xxx __iomem *reg = &amp;ha-&gt;iobase-&gt;isp;
 	struct device_reg_24xx __iomem *reg24 = &amp;ha-&gt;iobase-&gt;isp24;
 	struct device_reg_82xx __iomem *reg82 = &amp;ha-&gt;iobase-&gt;isp82;
<span class="p_del">-	uint32_t	rscn_entry, host_pid;</span>
<span class="p_add">+	uint32_t	rscn_entry, host_pid, tmp_pid;</span>
 	unsigned long	flags;
<span class="p_add">+	fc_port_t	*fcport = NULL;</span>
 
 	/* Setup to process RIO completion. */
 	handle_cnt = 0;
<span class="p_chunk">@@ -969,6 +970,20 @@</span> <span class="p_context"> skip_rio:</span>
 		if (qla2x00_is_a_vp_did(vha, rscn_entry))
 			break;
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Search for the rport related to this RSCN entry and mark it</span>
<span class="p_add">+		 * as lost.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		list_for_each_entry(fcport, &amp;vha-&gt;vp_fcports, list) {</span>
<span class="p_add">+			if (atomic_read(&amp;fcport-&gt;state) != FCS_ONLINE)</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			tmp_pid = fcport-&gt;d_id.b24;</span>
<span class="p_add">+			if (fcport-&gt;d_id.b24 == rscn_entry) {</span>
<span class="p_add">+				qla2x00_mark_device_lost(vha, fcport, 0, 0);</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		atomic_set(&amp;vha-&gt;loop_down_timer, 0);
 		vha-&gt;flags.management_server_logged_in = 0;
 
<span class="p_header">diff --git a/drivers/scsi/scsi_pm.c b/drivers/scsi/scsi_pm.c</span>
<span class="p_header">index 7454498c4091..a2dcf6a54ec6 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_pm.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_pm.c</span>
<span class="p_chunk">@@ -219,15 +219,15 @@</span> <span class="p_context"> static int sdev_runtime_suspend(struct device *dev)</span>
 {
 	const struct dev_pm_ops *pm = dev-&gt;driver ? dev-&gt;driver-&gt;pm : NULL;
 	struct scsi_device *sdev = to_scsi_device(dev);
<span class="p_del">-	int err;</span>
<span class="p_add">+	int err = 0;</span>
 
<span class="p_del">-	err = blk_pre_runtime_suspend(sdev-&gt;request_queue);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-	if (pm &amp;&amp; pm-&gt;runtime_suspend)</span>
<span class="p_add">+	if (pm &amp;&amp; pm-&gt;runtime_suspend) {</span>
<span class="p_add">+		err = blk_pre_runtime_suspend(sdev-&gt;request_queue);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			return err;</span>
 		err = pm-&gt;runtime_suspend(dev);
<span class="p_del">-	blk_post_runtime_suspend(sdev-&gt;request_queue, err);</span>
<span class="p_del">-</span>
<span class="p_add">+		blk_post_runtime_suspend(sdev-&gt;request_queue, err);</span>
<span class="p_add">+	}</span>
 	return err;
 }
 
<span class="p_chunk">@@ -250,11 +250,11 @@</span> <span class="p_context"> static int sdev_runtime_resume(struct device *dev)</span>
 	const struct dev_pm_ops *pm = dev-&gt;driver ? dev-&gt;driver-&gt;pm : NULL;
 	int err = 0;
 
<span class="p_del">-	blk_pre_runtime_resume(sdev-&gt;request_queue);</span>
<span class="p_del">-	if (pm &amp;&amp; pm-&gt;runtime_resume)</span>
<span class="p_add">+	if (pm &amp;&amp; pm-&gt;runtime_resume) {</span>
<span class="p_add">+		blk_pre_runtime_resume(sdev-&gt;request_queue);</span>
 		err = pm-&gt;runtime_resume(dev);
<span class="p_del">-	blk_post_runtime_resume(sdev-&gt;request_queue, err);</span>
<span class="p_del">-</span>
<span class="p_add">+		blk_post_runtime_resume(sdev-&gt;request_queue, err);</span>
<span class="p_add">+	}</span>
 	return err;
 }
 
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">index 8932cb2e9165..9f299c7fe73f 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_chunk">@@ -966,7 +966,7 @@</span> <span class="p_context"> int iscsit_setup_scsi_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,</span>
 		if (cmd-&gt;targ_xfer_tag == 0xFFFFFFFF)
 			cmd-&gt;targ_xfer_tag = conn-&gt;sess-&gt;targ_xfer_tag++;
 		spin_unlock_bh(&amp;conn-&gt;sess-&gt;ttt_lock);
<span class="p_del">-	} else if (hdr-&gt;flags &amp; ISCSI_FLAG_CMD_WRITE)</span>
<span class="p_add">+	} else</span>
 		cmd-&gt;targ_xfer_tag = 0xFFFFFFFF;
 	cmd-&gt;cmd_sn		= be32_to_cpu(hdr-&gt;cmdsn);
 	cmd-&gt;exp_stat_sn	= be32_to_cpu(hdr-&gt;exp_statsn);
<span class="p_chunk">@@ -3964,7 +3964,13 @@</span> <span class="p_context"> get_immediate:</span>
 	}
 
 transport_err:
<span class="p_del">-	iscsit_take_action_for_connection_exit(conn);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Avoid the normal connection failure code-path if this connection</span>
<span class="p_add">+	 * is still within LOGIN mode, and iscsi_np process context is</span>
<span class="p_add">+	 * responsible for cleaning up the early connection failure.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (conn-&gt;conn_state != TARG_CONN_STATE_IN_LOGIN)</span>
<span class="p_add">+		iscsit_take_action_for_connection_exit(conn);</span>
 out:
 	return 0;
 }
<span class="p_chunk">@@ -4050,7 +4056,7 @@</span> <span class="p_context"> reject:</span>
 
 int iscsi_target_rx_thread(void *arg)
 {
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret, rc;</span>
 	u8 buffer[ISCSI_HDR_LEN], opcode;
 	u32 checksum = 0, digest = 0;
 	struct iscsi_conn *conn = arg;
<span class="p_chunk">@@ -4060,10 +4066,16 @@</span> <span class="p_context"> int iscsi_target_rx_thread(void *arg)</span>
 	 * connection recovery / failure event can be triggered externally.
 	 */
 	allow_signal(SIGINT);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Wait for iscsi_post_login_handler() to complete before allowing</span>
<span class="p_add">+	 * incoming iscsi/tcp socket I/O, and/or failing the connection.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	rc = wait_for_completion_interruptible(&amp;conn-&gt;rx_login_comp);</span>
<span class="p_add">+	if (rc &lt; 0)</span>
<span class="p_add">+		return 0;</span>
 
 	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_INFINIBAND) {
 		struct completion comp;
<span class="p_del">-		int rc;</span>
 
 		init_completion(&amp;comp);
 		rc = wait_for_completion_interruptible(&amp;comp);
<span class="p_chunk">@@ -4503,7 +4515,18 @@</span> <span class="p_context"> static void iscsit_logout_post_handler_closesession(</span>
 	struct iscsi_conn *conn)
 {
 	struct iscsi_session *sess = conn-&gt;sess;
<span class="p_del">-	int sleep = cmpxchg(&amp;conn-&gt;tx_thread_active, true, false);</span>
<span class="p_add">+	int sleep = 1;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Traditional iscsi/tcp will invoke this logic from TX thread</span>
<span class="p_add">+	 * context during session logout, so clear tx_thread_active and</span>
<span class="p_add">+	 * sleep if iscsit_close_connection() has not already occured.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Since iser-target invokes this logic from it&#39;s own workqueue,</span>
<span class="p_add">+	 * always sleep waiting for RX/TX thread shutdown to complete</span>
<span class="p_add">+	 * within iscsit_close_connection().</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_TCP)</span>
<span class="p_add">+		sleep = cmpxchg(&amp;conn-&gt;tx_thread_active, true, false);</span>
 
 	atomic_set(&amp;conn-&gt;conn_logout_remove, 0);
 	complete(&amp;conn-&gt;conn_logout_comp);
<span class="p_chunk">@@ -4517,7 +4540,10 @@</span> <span class="p_context"> static void iscsit_logout_post_handler_closesession(</span>
 static void iscsit_logout_post_handler_samecid(
 	struct iscsi_conn *conn)
 {
<span class="p_del">-	int sleep = cmpxchg(&amp;conn-&gt;tx_thread_active, true, false);</span>
<span class="p_add">+	int sleep = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_TCP)</span>
<span class="p_add">+		sleep = cmpxchg(&amp;conn-&gt;tx_thread_active, true, false);</span>
 
 	atomic_set(&amp;conn-&gt;conn_logout_remove, 0);
 	complete(&amp;conn-&gt;conn_logout_comp);
<span class="p_chunk">@@ -4736,6 +4762,7 @@</span> <span class="p_context"> int iscsit_release_sessions_for_tpg(struct iscsi_portal_group *tpg, int force)</span>
 	struct iscsi_session *sess;
 	struct se_portal_group *se_tpg = &amp;tpg-&gt;tpg_se_tpg;
 	struct se_session *se_sess, *se_sess_tmp;
<span class="p_add">+	LIST_HEAD(free_list);</span>
 	int session_count = 0;
 
 	spin_lock_bh(&amp;se_tpg-&gt;session_lock);
<span class="p_chunk">@@ -4757,14 +4784,17 @@</span> <span class="p_context"> int iscsit_release_sessions_for_tpg(struct iscsi_portal_group *tpg, int force)</span>
 		}
 		atomic_set(&amp;sess-&gt;session_reinstatement, 1);
 		spin_unlock(&amp;sess-&gt;conn_lock);
<span class="p_del">-		spin_unlock_bh(&amp;se_tpg-&gt;session_lock);</span>
 
<span class="p_del">-		iscsit_free_session(sess);</span>
<span class="p_del">-		spin_lock_bh(&amp;se_tpg-&gt;session_lock);</span>
<span class="p_add">+		list_move_tail(&amp;se_sess-&gt;sess_list, &amp;free_list);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_bh(&amp;se_tpg-&gt;session_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry_safe(se_sess, se_sess_tmp, &amp;free_list, sess_list) {</span>
<span class="p_add">+		sess = (struct iscsi_session *)se_sess-&gt;fabric_sess_ptr;</span>
 
<span class="p_add">+		iscsit_free_session(sess);</span>
 		session_count++;
 	}
<span class="p_del">-	spin_unlock_bh(&amp;se_tpg-&gt;session_lock);</span>
 
 	pr_debug(&quot;Released %d iSCSI Session(s) from Target Portal&quot;
 			&quot; Group: %hu\n&quot;, session_count, tpg-&gt;tpgt);
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_core.h b/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_header">index 2423f27e4670..62eb11329c71 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_chunk">@@ -605,6 +605,7 @@</span> <span class="p_context"> struct iscsi_conn {</span>
 	int			bitmap_id;
 	int			rx_thread_active;
 	struct task_struct	*rx_thread;
<span class="p_add">+	struct completion	rx_login_comp;</span>
 	int			tx_thread_active;
 	struct task_struct	*tx_thread;
 	/* list_head for session connection list */
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_login.c b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">index cb45313182b7..09dac9ac305e 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_chunk">@@ -83,6 +83,7 @@</span> <span class="p_context"> static struct iscsi_login *iscsi_login_init_conn(struct iscsi_conn *conn)</span>
 	init_completion(&amp;conn-&gt;conn_logout_comp);
 	init_completion(&amp;conn-&gt;rx_half_close_comp);
 	init_completion(&amp;conn-&gt;tx_half_close_comp);
<span class="p_add">+	init_completion(&amp;conn-&gt;rx_login_comp);</span>
 	spin_lock_init(&amp;conn-&gt;cmd_lock);
 	spin_lock_init(&amp;conn-&gt;conn_usage_lock);
 	spin_lock_init(&amp;conn-&gt;immed_queue_lock);
<span class="p_chunk">@@ -734,6 +735,7 @@</span> <span class="p_context"> int iscsit_start_kthreads(struct iscsi_conn *conn)</span>
 
 	return 0;
 out_tx:
<span class="p_add">+	send_sig(SIGINT, conn-&gt;tx_thread, 1);</span>
 	kthread_stop(conn-&gt;tx_thread);
 	conn-&gt;tx_thread_active = false;
 out_bitmap:
<span class="p_chunk">@@ -744,7 +746,7 @@</span> <span class="p_context"> out_bitmap:</span>
 	return ret;
 }
 
<span class="p_del">-int iscsi_post_login_handler(</span>
<span class="p_add">+void iscsi_post_login_handler(</span>
 	struct iscsi_np *np,
 	struct iscsi_conn *conn,
 	u8 zero_tsih)
<span class="p_chunk">@@ -754,7 +756,6 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 	struct se_session *se_sess = sess-&gt;se_sess;
 	struct iscsi_portal_group *tpg = sess-&gt;tpg;
 	struct se_portal_group *se_tpg = &amp;tpg-&gt;tpg_se_tpg;
<span class="p_del">-	int rc;</span>
 
 	iscsit_inc_conn_usage_count(conn);
 
<span class="p_chunk">@@ -795,10 +796,6 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 			sess-&gt;sess_ops-&gt;InitiatorName);
 		spin_unlock_bh(&amp;sess-&gt;conn_lock);
 
<span class="p_del">-		rc = iscsit_start_kthreads(conn);</span>
<span class="p_del">-		if (rc)</span>
<span class="p_del">-			return rc;</span>
<span class="p_del">-</span>
 		iscsi_post_login_start_timers(conn);
 		/*
 		 * Determine CPU mask to ensure connection&#39;s RX and TX kthreads
<span class="p_chunk">@@ -807,15 +804,20 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 		iscsit_thread_get_cpumask(conn);
 		conn-&gt;conn_rx_reset_cpumask = 1;
 		conn-&gt;conn_tx_reset_cpumask = 1;
<span class="p_del">-</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Wakeup the sleeping iscsi_target_rx_thread() now that</span>
<span class="p_add">+		 * iscsi_conn is in TARG_CONN_STATE_LOGGED_IN state.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		complete(&amp;conn-&gt;rx_login_comp);</span>
 		iscsit_dec_conn_usage_count(conn);
<span class="p_add">+</span>
 		if (stop_timer) {
 			spin_lock_bh(&amp;se_tpg-&gt;session_lock);
 			iscsit_stop_time2retain_timer(sess);
 			spin_unlock_bh(&amp;se_tpg-&gt;session_lock);
 		}
 		iscsit_dec_session_usage_count(sess);
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return;</span>
 	}
 
 	iscsi_set_session_parameters(sess-&gt;sess_ops, conn-&gt;param_list, 1);
<span class="p_chunk">@@ -856,10 +858,6 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 		&quot; iSCSI Target Portal Group: %hu\n&quot;, tpg-&gt;nsessions, tpg-&gt;tpgt);
 	spin_unlock_bh(&amp;se_tpg-&gt;session_lock);
 
<span class="p_del">-	rc = iscsit_start_kthreads(conn);</span>
<span class="p_del">-	if (rc)</span>
<span class="p_del">-		return rc;</span>
<span class="p_del">-</span>
 	iscsi_post_login_start_timers(conn);
 	/*
 	 * Determine CPU mask to ensure connection&#39;s RX and TX kthreads
<span class="p_chunk">@@ -868,10 +866,12 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 	iscsit_thread_get_cpumask(conn);
 	conn-&gt;conn_rx_reset_cpumask = 1;
 	conn-&gt;conn_tx_reset_cpumask = 1;
<span class="p_del">-</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Wakeup the sleeping iscsi_target_rx_thread() now that</span>
<span class="p_add">+	 * iscsi_conn is in TARG_CONN_STATE_LOGGED_IN state.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	complete(&amp;conn-&gt;rx_login_comp);</span>
 	iscsit_dec_conn_usage_count(conn);
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
 }
 
 static void iscsi_handle_login_thread_timeout(unsigned long data)
<span class="p_chunk">@@ -1439,23 +1439,12 @@</span> <span class="p_context"> static int __iscsi_target_login_thread(struct iscsi_np *np)</span>
 	if (ret &lt; 0)
 		goto new_sess_out;
 
<span class="p_del">-	if (!conn-&gt;sess) {</span>
<span class="p_del">-		pr_err(&quot;struct iscsi_conn session pointer is NULL!\n&quot;);</span>
<span class="p_del">-		goto new_sess_out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	iscsi_stop_login_thread_timer(np);
 
<span class="p_del">-	if (signal_pending(current))</span>
<span class="p_del">-		goto new_sess_out;</span>
<span class="p_del">-</span>
 	if (ret == 1) {
 		tpg_np = conn-&gt;tpg_np;
 
<span class="p_del">-		ret = iscsi_post_login_handler(np, conn, zero_tsih);</span>
<span class="p_del">-		if (ret &lt; 0)</span>
<span class="p_del">-			goto new_sess_out;</span>
<span class="p_del">-</span>
<span class="p_add">+		iscsi_post_login_handler(np, conn, zero_tsih);</span>
 		iscsit_deaccess_np(np, tpg, tpg_np);
 	}
 
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_login.h b/drivers/target/iscsi/iscsi_target_login.h</span>
<span class="p_header">index 29d098324b7f..55cbf4533544 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_login.h</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_login.h</span>
<span class="p_chunk">@@ -12,7 +12,8 @@</span> <span class="p_context"> extern int iscsit_accept_np(struct iscsi_np *, struct iscsi_conn *);</span>
 extern int iscsit_get_login_rx(struct iscsi_conn *, struct iscsi_login *);
 extern int iscsit_put_login_tx(struct iscsi_conn *, struct iscsi_login *, u32);
 extern void iscsit_free_conn(struct iscsi_np *, struct iscsi_conn *);
<span class="p_del">-extern int iscsi_post_login_handler(struct iscsi_np *, struct iscsi_conn *, u8);</span>
<span class="p_add">+extern int iscsit_start_kthreads(struct iscsi_conn *);</span>
<span class="p_add">+extern void iscsi_post_login_handler(struct iscsi_np *, struct iscsi_conn *, u8);</span>
 extern void iscsi_target_login_sess_out(struct iscsi_conn *, struct iscsi_np *,
 				bool, bool);
 extern int iscsi_target_login_thread(void *);
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_nego.c b/drivers/target/iscsi/iscsi_target_nego.c</span>
<span class="p_header">index 62a095f36bf2..092112e5e1a6 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_nego.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_nego.c</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
  ******************************************************************************/
 
 #include &lt;linux/ctype.h&gt;
<span class="p_add">+#include &lt;linux/kthread.h&gt;</span>
 #include &lt;scsi/iscsi_proto.h&gt;
 #include &lt;target/target_core_base.h&gt;
 #include &lt;target/target_core_fabric.h&gt;
<span class="p_chunk">@@ -361,10 +362,24 @@</span> <span class="p_context"> static int iscsi_target_do_tx_login_io(struct iscsi_conn *conn, struct iscsi_log</span>
 		ntohl(login_rsp-&gt;statsn), login-&gt;rsp_length);
 
 	padding = ((-login-&gt;rsp_length) &amp; 3);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Before sending the last login response containing the transition</span>
<span class="p_add">+	 * bit for full-feature-phase, go ahead and start up TX/RX threads</span>
<span class="p_add">+	 * now to avoid potential resource allocation failures after the</span>
<span class="p_add">+	 * final login response has been sent.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (login-&gt;login_complete) {</span>
<span class="p_add">+		int rc = iscsit_start_kthreads(conn);</span>
<span class="p_add">+		if (rc) {</span>
<span class="p_add">+			iscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,</span>
<span class="p_add">+					    ISCSI_LOGIN_STATUS_NO_RESOURCES);</span>
<span class="p_add">+			return -1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
 	if (conn-&gt;conn_transport-&gt;iscsit_put_login_tx(conn, login,
 					login-&gt;rsp_length + padding) &lt; 0)
<span class="p_del">-		return -1;</span>
<span class="p_add">+		goto err;</span>
 
 	login-&gt;rsp_length		= 0;
 	mutex_lock(&amp;sess-&gt;cmdsn_mutex);
<span class="p_chunk">@@ -373,6 +388,23 @@</span> <span class="p_context"> static int iscsi_target_do_tx_login_io(struct iscsi_conn *conn, struct iscsi_log</span>
 	mutex_unlock(&amp;sess-&gt;cmdsn_mutex);
 
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+err:</span>
<span class="p_add">+	if (login-&gt;login_complete) {</span>
<span class="p_add">+		if (conn-&gt;rx_thread &amp;&amp; conn-&gt;rx_thread_active) {</span>
<span class="p_add">+			send_sig(SIGINT, conn-&gt;rx_thread, 1);</span>
<span class="p_add">+			kthread_stop(conn-&gt;rx_thread);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (conn-&gt;tx_thread &amp;&amp; conn-&gt;tx_thread_active) {</span>
<span class="p_add">+			send_sig(SIGINT, conn-&gt;tx_thread, 1);</span>
<span class="p_add">+			kthread_stop(conn-&gt;tx_thread);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		spin_lock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+		bitmap_release_region(iscsit_global-&gt;ts_bitmap, conn-&gt;bitmap_id,</span>
<span class="p_add">+				      get_order(1));</span>
<span class="p_add">+		spin_unlock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return -1;</span>
 }
 
 static void iscsi_target_sk_data_ready(struct sock *sk)
<span class="p_header">diff --git a/drivers/target/target_core_spc.c b/drivers/target/target_core_spc.c</span>
<span class="p_header">index 2f1c928210b3..a897f4a51a51 100644</span>
<span class="p_header">--- a/drivers/target/target_core_spc.c</span>
<span class="p_header">+++ b/drivers/target/target_core_spc.c</span>
<span class="p_chunk">@@ -1238,11 +1238,8 @@</span> <span class="p_context"> sense_reason_t spc_emulate_report_luns(struct se_cmd *cmd)</span>
 	 * coming via a target_core_mod PASSTHROUGH op, and not through
 	 * a $FABRIC_MOD.  In that case, report LUN=0 only.
 	 */
<span class="p_del">-	if (!sess) {</span>
<span class="p_del">-		int_to_scsilun(0, (struct scsi_lun *)&amp;buf[offset]);</span>
<span class="p_del">-		lun_count = 1;</span>
<span class="p_add">+	if (!sess)</span>
 		goto done;
<span class="p_del">-	}</span>
 
 	spin_lock_irq(&amp;sess-&gt;se_node_acl-&gt;device_list_lock);
 	for (i = 0; i &lt; TRANSPORT_MAX_LUNS_PER_TPG; i++) {
<span class="p_chunk">@@ -1267,6 +1264,14 @@</span> <span class="p_context"> sense_reason_t spc_emulate_report_luns(struct se_cmd *cmd)</span>
 	 * See SPC3 r07, page 159.
 	 */
 done:
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If no LUNs are accessible, report virtual LUN 0.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (lun_count == 0) {</span>
<span class="p_add">+		int_to_scsilun(0, (struct scsi_lun *)&amp;buf[offset]);</span>
<span class="p_add">+		lun_count = 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	lun_count *= 8;
 	buf[0] = ((lun_count &gt;&gt; 24) &amp; 0xff);
 	buf[1] = ((lun_count &gt;&gt; 16) &amp; 0xff);
<span class="p_header">diff --git a/drivers/thermal/samsung/exynos_tmu.c b/drivers/thermal/samsung/exynos_tmu.c</span>
<span class="p_header">index d7ca9f49c9cb..efed4eedf47f 100644</span>
<span class="p_header">--- a/drivers/thermal/samsung/exynos_tmu.c</span>
<span class="p_header">+++ b/drivers/thermal/samsung/exynos_tmu.c</span>
<span class="p_chunk">@@ -752,6 +752,8 @@</span> <span class="p_context"> err_clk:</span>
 err_clk_sec:
 	if (!IS_ERR(data-&gt;clk_sec))
 		clk_unprepare(data-&gt;clk_sec);
<span class="p_add">+	if (!IS_ERR_OR_NULL(data-&gt;regulator))</span>
<span class="p_add">+		regulator_disable(data-&gt;regulator);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">index 5c68f227b8bf..d06f2a336b0c 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-mem.c</span>
<span class="p_chunk">@@ -1796,7 +1796,8 @@</span> <span class="p_context"> void xhci_mem_cleanup(struct xhci_hcd *xhci)</span>
 	int size;
 	int i, j, num_ports;
 
<span class="p_del">-	del_timer_sync(&amp;xhci-&gt;cmd_timer);</span>
<span class="p_add">+	if (timer_pending(&amp;xhci-&gt;cmd_timer))</span>
<span class="p_add">+		del_timer_sync(&amp;xhci-&gt;cmd_timer);</span>
 
 	/* Free the Event Ring Segment Table and the actual Event Ring */
 	size = sizeof(struct xhci_erst_entry)*(xhci-&gt;erst.num_entries);
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index 3f40772962ec..735659f69599 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -82,7 +82,7 @@</span> <span class="p_context"> dma_addr_t xhci_trb_virt_to_dma(struct xhci_segment *seg,</span>
 		return 0;
 	/* offset in TRBs */
 	segment_offset = trb - seg-&gt;trbs;
<span class="p_del">-	if (segment_offset &gt; TRBS_PER_SEGMENT)</span>
<span class="p_add">+	if (segment_offset &gt;= TRBS_PER_SEGMENT)</span>
 		return 0;
 	return seg-&gt;dma + (segment_offset * sizeof(*trb));
 }
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index eebe0b72db51..e92357d19c47 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -1106,6 +1106,8 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x9000)}, /* SIMCom SIM5218 */
 	{ USB_DEVICE_INTERFACE_CLASS(SIERRA_VENDOR_ID, 0x68c0, 0xff),
 	  .driver_info = (kernel_ulong_t)&amp;sierra_mc73xx_blacklist }, /* MC73xx */
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(SIERRA_VENDOR_ID, 0x9041, 0xff),</span>
<span class="p_add">+	  .driver_info = (kernel_ulong_t)&amp;sierra_mc73xx_blacklist }, /* MC7305/MC7355 */</span>
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_6001) },
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_CMU_300) },
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_6003),
<span class="p_header">diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c</span>
<span class="p_header">index 9c63897b3a56..d156545728c2 100644</span>
<span class="p_header">--- a/drivers/usb/serial/qcserial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/qcserial.c</span>
<span class="p_chunk">@@ -145,7 +145,6 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{DEVICE_SWI(0x1199, 0x901c)},	/* Sierra Wireless EM7700 */
 	{DEVICE_SWI(0x1199, 0x901f)},	/* Sierra Wireless EM7355 */
 	{DEVICE_SWI(0x1199, 0x9040)},	/* Sierra Wireless Modem */
<span class="p_del">-	{DEVICE_SWI(0x1199, 0x9041)},	/* Sierra Wireless MC7305/MC7355 */</span>
 	{DEVICE_SWI(0x1199, 0x9051)},	/* Netgear AirCard 340U */
 	{DEVICE_SWI(0x1199, 0x9053)},	/* Sierra Wireless Modem */
 	{DEVICE_SWI(0x1199, 0x9054)},	/* Sierra Wireless Modem */
<span class="p_chunk">@@ -158,6 +157,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{DEVICE_SWI(0x413c, 0x81a4)},	/* Dell Wireless 5570e HSPA+ (42Mbps) Mobile Broadband Card */
 	{DEVICE_SWI(0x413c, 0x81a8)},	/* Dell Wireless 5808 Gobi(TM) 4G LTE Mobile Broadband Card */
 	{DEVICE_SWI(0x413c, 0x81a9)},	/* Dell Wireless 5808e Gobi(TM) 4G LTE Mobile Broadband Card */
<span class="p_add">+	{DEVICE_SWI(0x413c, 0x81b1)},	/* Dell Wireless 5809e Gobi(TM) 4G LTE Mobile Broadband Card */</span>
 
 	/* Huawei devices */
 	{DEVICE_HWI(0x03f0, 0x581d)},	/* HP lt4112 LTE/HSPA+ Gobi 4G Modem (Huawei me906e) */
<span class="p_header">diff --git a/drivers/usb/serial/sierra.c b/drivers/usb/serial/sierra.c</span>
<span class="p_header">index 46179a0828eb..07d1ecd564f7 100644</span>
<span class="p_header">--- a/drivers/usb/serial/sierra.c</span>
<span class="p_header">+++ b/drivers/usb/serial/sierra.c</span>
<span class="p_chunk">@@ -289,6 +289,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x1199, 0x68AA, 0xFF, 0xFF, 0xFF),
 	  .driver_info = (kernel_ulong_t)&amp;direct_ip_interface_blacklist
 	},
<span class="p_add">+	{ USB_DEVICE(0x1199, 0x68AB) }, /* Sierra Wireless AR8550 */</span>
 	/* AT&amp;T Direct IP LTE modems */
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x0F3D, 0x68AA, 0xFF, 0xFF, 0xFF),
 	  .driver_info = (kernel_ulong_t)&amp;direct_ip_interface_blacklist
<span class="p_header">diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c</span>
<span class="p_header">index c90f4374442a..1fe2c8115be0 100644</span>
<span class="p_header">--- a/drivers/vhost/vhost.c</span>
<span class="p_header">+++ b/drivers/vhost/vhost.c</span>
<span class="p_chunk">@@ -882,6 +882,7 @@</span> <span class="p_context"> long vhost_dev_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *argp)</span>
 		}
 		if (eventfp != d-&gt;log_file) {
 			filep = d-&gt;log_file;
<span class="p_add">+			d-&gt;log_file = eventfp;</span>
 			ctx = d-&gt;log_ctx;
 			d-&gt;log_ctx = eventfp ?
 				eventfd_ctx_fileget(eventfp) : NULL;
<span class="p_header">diff --git a/drivers/xen/gntdev.c b/drivers/xen/gntdev.c</span>
<span class="p_header">index 073b4a19a8b0..91cc44611062 100644</span>
<span class="p_header">--- a/drivers/xen/gntdev.c</span>
<span class="p_header">+++ b/drivers/xen/gntdev.c</span>
<span class="p_chunk">@@ -67,7 +67,7 @@</span> <span class="p_context"> struct gntdev_priv {</span>
 	 * Only populated if populate_freeable_maps == 1 */
 	struct list_head freeable_maps;
 	/* lock protects maps and freeable_maps */
<span class="p_del">-	spinlock_t lock;</span>
<span class="p_add">+	struct mutex lock;</span>
 	struct mm_struct *mm;
 	struct mmu_notifier mn;
 };
<span class="p_chunk">@@ -216,9 +216,9 @@</span> <span class="p_context"> static void gntdev_put_map(struct gntdev_priv *priv, struct grant_map *map)</span>
 	}
 
 	if (populate_freeable_maps &amp;&amp; priv) {
<span class="p_del">-		spin_lock(&amp;priv-&gt;lock);</span>
<span class="p_add">+		mutex_lock(&amp;priv-&gt;lock);</span>
 		list_del(&amp;map-&gt;next);
<span class="p_del">-		spin_unlock(&amp;priv-&gt;lock);</span>
<span class="p_add">+		mutex_unlock(&amp;priv-&gt;lock);</span>
 	}
 
 	if (map-&gt;pages &amp;&amp; !use_ptemod)
<span class="p_chunk">@@ -387,9 +387,9 @@</span> <span class="p_context"> static void gntdev_vma_close(struct vm_area_struct *vma)</span>
 		 * not do any unmapping, since that has been done prior to
 		 * closing the vma, but it may still iterate the unmap_ops list.
 		 */
<span class="p_del">-		spin_lock(&amp;priv-&gt;lock);</span>
<span class="p_add">+		mutex_lock(&amp;priv-&gt;lock);</span>
 		map-&gt;vma = NULL;
<span class="p_del">-		spin_unlock(&amp;priv-&gt;lock);</span>
<span class="p_add">+		mutex_unlock(&amp;priv-&gt;lock);</span>
 	}
 	vma-&gt;vm_private_data = NULL;
 	gntdev_put_map(priv, map);
<span class="p_chunk">@@ -433,14 +433,14 @@</span> <span class="p_context"> static void mn_invl_range_start(struct mmu_notifier *mn,</span>
 	struct gntdev_priv *priv = container_of(mn, struct gntdev_priv, mn);
 	struct grant_map *map;
 
<span class="p_del">-	spin_lock(&amp;priv-&gt;lock);</span>
<span class="p_add">+	mutex_lock(&amp;priv-&gt;lock);</span>
 	list_for_each_entry(map, &amp;priv-&gt;maps, next) {
 		unmap_if_in_range(map, start, end);
 	}
 	list_for_each_entry(map, &amp;priv-&gt;freeable_maps, next) {
 		unmap_if_in_range(map, start, end);
 	}
<span class="p_del">-	spin_unlock(&amp;priv-&gt;lock);</span>
<span class="p_add">+	mutex_unlock(&amp;priv-&gt;lock);</span>
 }
 
 static void mn_invl_page(struct mmu_notifier *mn,
<span class="p_chunk">@@ -457,7 +457,7 @@</span> <span class="p_context"> static void mn_release(struct mmu_notifier *mn,</span>
 	struct grant_map *map;
 	int err;
 
<span class="p_del">-	spin_lock(&amp;priv-&gt;lock);</span>
<span class="p_add">+	mutex_lock(&amp;priv-&gt;lock);</span>
 	list_for_each_entry(map, &amp;priv-&gt;maps, next) {
 		if (!map-&gt;vma)
 			continue;
<span class="p_chunk">@@ -476,7 +476,7 @@</span> <span class="p_context"> static void mn_release(struct mmu_notifier *mn,</span>
 		err = unmap_grant_pages(map, /* offset */ 0, map-&gt;count);
 		WARN_ON(err);
 	}
<span class="p_del">-	spin_unlock(&amp;priv-&gt;lock);</span>
<span class="p_add">+	mutex_unlock(&amp;priv-&gt;lock);</span>
 }
 
 static struct mmu_notifier_ops gntdev_mmu_ops = {
<span class="p_chunk">@@ -498,7 +498,7 @@</span> <span class="p_context"> static int gntdev_open(struct inode *inode, struct file *flip)</span>
 
 	INIT_LIST_HEAD(&amp;priv-&gt;maps);
 	INIT_LIST_HEAD(&amp;priv-&gt;freeable_maps);
<span class="p_del">-	spin_lock_init(&amp;priv-&gt;lock);</span>
<span class="p_add">+	mutex_init(&amp;priv-&gt;lock);</span>
 
 	if (use_ptemod) {
 		priv-&gt;mm = get_task_mm(current);
<span class="p_chunk">@@ -529,12 +529,14 @@</span> <span class="p_context"> static int gntdev_release(struct inode *inode, struct file *flip)</span>
 
 	pr_debug(&quot;priv %p\n&quot;, priv);
 
<span class="p_add">+	mutex_lock(&amp;priv-&gt;lock);</span>
 	while (!list_empty(&amp;priv-&gt;maps)) {
 		map = list_entry(priv-&gt;maps.next, struct grant_map, next);
 		list_del(&amp;map-&gt;next);
 		gntdev_put_map(NULL /* already removed */, map);
 	}
 	WARN_ON(!list_empty(&amp;priv-&gt;freeable_maps));
<span class="p_add">+	mutex_unlock(&amp;priv-&gt;lock);</span>
 
 	if (use_ptemod)
 		mmu_notifier_unregister(&amp;priv-&gt;mn, priv-&gt;mm);
<span class="p_chunk">@@ -572,10 +574,10 @@</span> <span class="p_context"> static long gntdev_ioctl_map_grant_ref(struct gntdev_priv *priv,</span>
 		return -EFAULT;
 	}
 
<span class="p_del">-	spin_lock(&amp;priv-&gt;lock);</span>
<span class="p_add">+	mutex_lock(&amp;priv-&gt;lock);</span>
 	gntdev_add_map(priv, map);
 	op.index = map-&gt;index &lt;&lt; PAGE_SHIFT;
<span class="p_del">-	spin_unlock(&amp;priv-&gt;lock);</span>
<span class="p_add">+	mutex_unlock(&amp;priv-&gt;lock);</span>
 
 	if (copy_to_user(u, &amp;op, sizeof(op)) != 0)
 		return -EFAULT;
<span class="p_chunk">@@ -594,7 +596,7 @@</span> <span class="p_context"> static long gntdev_ioctl_unmap_grant_ref(struct gntdev_priv *priv,</span>
 		return -EFAULT;
 	pr_debug(&quot;priv %p, del %d+%d\n&quot;, priv, (int)op.index, (int)op.count);
 
<span class="p_del">-	spin_lock(&amp;priv-&gt;lock);</span>
<span class="p_add">+	mutex_lock(&amp;priv-&gt;lock);</span>
 	map = gntdev_find_map_index(priv, op.index &gt;&gt; PAGE_SHIFT, op.count);
 	if (map) {
 		list_del(&amp;map-&gt;next);
<span class="p_chunk">@@ -602,7 +604,7 @@</span> <span class="p_context"> static long gntdev_ioctl_unmap_grant_ref(struct gntdev_priv *priv,</span>
 			list_add_tail(&amp;map-&gt;next, &amp;priv-&gt;freeable_maps);
 		err = 0;
 	}
<span class="p_del">-	spin_unlock(&amp;priv-&gt;lock);</span>
<span class="p_add">+	mutex_unlock(&amp;priv-&gt;lock);</span>
 	if (map)
 		gntdev_put_map(priv, map);
 	return err;
<span class="p_chunk">@@ -670,7 +672,7 @@</span> <span class="p_context"> static long gntdev_ioctl_notify(struct gntdev_priv *priv, void __user *u)</span>
 	out_flags = op.action;
 	out_event = op.event_channel_port;
 
<span class="p_del">-	spin_lock(&amp;priv-&gt;lock);</span>
<span class="p_add">+	mutex_lock(&amp;priv-&gt;lock);</span>
 
 	list_for_each_entry(map, &amp;priv-&gt;maps, next) {
 		uint64_t begin = map-&gt;index &lt;&lt; PAGE_SHIFT;
<span class="p_chunk">@@ -698,7 +700,7 @@</span> <span class="p_context"> static long gntdev_ioctl_notify(struct gntdev_priv *priv, void __user *u)</span>
 	rc = 0;
 
  unlock_out:
<span class="p_del">-	spin_unlock(&amp;priv-&gt;lock);</span>
<span class="p_add">+	mutex_unlock(&amp;priv-&gt;lock);</span>
 
 	/* Drop the reference to the event channel we did not save in the map */
 	if (out_flags &amp; UNMAP_NOTIFY_SEND_EVENT)
<span class="p_chunk">@@ -748,7 +750,7 @@</span> <span class="p_context"> static int gntdev_mmap(struct file *flip, struct vm_area_struct *vma)</span>
 	pr_debug(&quot;map %d+%d at %lx (pgoff %lx)\n&quot;,
 			index, count, vma-&gt;vm_start, vma-&gt;vm_pgoff);
 
<span class="p_del">-	spin_lock(&amp;priv-&gt;lock);</span>
<span class="p_add">+	mutex_lock(&amp;priv-&gt;lock);</span>
 	map = gntdev_find_map_index(priv, index, count);
 	if (!map)
 		goto unlock_out;
<span class="p_chunk">@@ -783,7 +785,7 @@</span> <span class="p_context"> static int gntdev_mmap(struct file *flip, struct vm_area_struct *vma)</span>
 			map-&gt;flags |= GNTMAP_readonly;
 	}
 
<span class="p_del">-	spin_unlock(&amp;priv-&gt;lock);</span>
<span class="p_add">+	mutex_unlock(&amp;priv-&gt;lock);</span>
 
 	if (use_ptemod) {
 		err = apply_to_page_range(vma-&gt;vm_mm, vma-&gt;vm_start,
<span class="p_chunk">@@ -811,11 +813,11 @@</span> <span class="p_context"> static int gntdev_mmap(struct file *flip, struct vm_area_struct *vma)</span>
 	return 0;
 
 unlock_out:
<span class="p_del">-	spin_unlock(&amp;priv-&gt;lock);</span>
<span class="p_add">+	mutex_unlock(&amp;priv-&gt;lock);</span>
 	return err;
 
 out_unlock_put:
<span class="p_del">-	spin_unlock(&amp;priv-&gt;lock);</span>
<span class="p_add">+	mutex_unlock(&amp;priv-&gt;lock);</span>
 out_put_map:
 	if (use_ptemod)
 		map-&gt;vma = NULL;
<span class="p_header">diff --git a/fs/buffer.c b/fs/buffer.c</span>
<span class="p_header">index 4752094053f9..cdd0320e8f84 100644</span>
<span class="p_header">--- a/fs/buffer.c</span>
<span class="p_header">+++ b/fs/buffer.c</span>
<span class="p_chunk">@@ -1000,7 +1000,7 @@</span> <span class="p_context"> init_page_buffers(struct page *page, struct block_device *bdev,</span>
  */
 static int
 grow_dev_page(struct block_device *bdev, sector_t block,
<span class="p_del">-		pgoff_t index, int size, int sizebits)</span>
<span class="p_add">+	      pgoff_t index, int size, int sizebits, gfp_t gfp)</span>
 {
 	struct inode *inode = bdev-&gt;bd_inode;
 	struct page *page;
<span class="p_chunk">@@ -1009,8 +1009,8 @@</span> <span class="p_context"> grow_dev_page(struct block_device *bdev, sector_t block,</span>
 	int ret = 0;		/* Will call free_more_memory() */
 	gfp_t gfp_mask;
 
<span class="p_del">-	gfp_mask = mapping_gfp_mask(inode-&gt;i_mapping) &amp; ~__GFP_FS;</span>
<span class="p_del">-	gfp_mask |= __GFP_MOVABLE;</span>
<span class="p_add">+	gfp_mask = (mapping_gfp_mask(inode-&gt;i_mapping) &amp; ~__GFP_FS) | gfp;</span>
<span class="p_add">+</span>
 	/*
 	 * XXX: __getblk_slow() can not really deal with failure and
 	 * will endlessly loop on improvised global reclaim.  Prefer
<span class="p_chunk">@@ -1067,7 +1067,7 @@</span> <span class="p_context"> failed:</span>
  * that page was dirty, the buffers are set dirty also.
  */
 static int
<span class="p_del">-grow_buffers(struct block_device *bdev, sector_t block, int size)</span>
<span class="p_add">+grow_buffers(struct block_device *bdev, sector_t block, int size, gfp_t gfp)</span>
 {
 	pgoff_t index;
 	int sizebits;
<span class="p_chunk">@@ -1094,11 +1094,12 @@</span> <span class="p_context"> grow_buffers(struct block_device *bdev, sector_t block, int size)</span>
 	}
 
 	/* Create a page with the proper size buffers.. */
<span class="p_del">-	return grow_dev_page(bdev, block, index, size, sizebits);</span>
<span class="p_add">+	return grow_dev_page(bdev, block, index, size, sizebits, gfp);</span>
 }
 
<span class="p_del">-static struct buffer_head *</span>
<span class="p_del">-__getblk_slow(struct block_device *bdev, sector_t block, int size)</span>
<span class="p_add">+struct buffer_head *</span>
<span class="p_add">+__getblk_slow(struct block_device *bdev, sector_t block,</span>
<span class="p_add">+	     unsigned size, gfp_t gfp)</span>
 {
 	/* Size must be multiple of hard sectorsize */
 	if (unlikely(size &amp; (bdev_logical_block_size(bdev)-1) ||
<span class="p_chunk">@@ -1120,13 +1121,14 @@</span> <span class="p_context"> __getblk_slow(struct block_device *bdev, sector_t block, int size)</span>
 		if (bh)
 			return bh;
 
<span class="p_del">-		ret = grow_buffers(bdev, block, size);</span>
<span class="p_add">+		ret = grow_buffers(bdev, block, size, gfp);</span>
 		if (ret &lt; 0)
 			return NULL;
 		if (ret == 0)
 			free_more_memory();
 	}
 }
<span class="p_add">+EXPORT_SYMBOL(__getblk_slow);</span>
 
 /*
  * The relationship between dirty buffers and dirty pages:
<span class="p_chunk">@@ -1380,24 +1382,25 @@</span> <span class="p_context"> __find_get_block(struct block_device *bdev, sector_t block, unsigned size)</span>
 EXPORT_SYMBOL(__find_get_block);
 
 /*
<span class="p_del">- * __getblk will locate (and, if necessary, create) the buffer_head</span>
<span class="p_add">+ * __getblk_gfp() will locate (and, if necessary, create) the buffer_head</span>
  * which corresponds to the passed block_device, block and size. The
  * returned buffer has its reference count incremented.
  *
<span class="p_del">- * __getblk() will lock up the machine if grow_dev_page&#39;s try_to_free_buffers()</span>
<span class="p_del">- * attempt is failing.  FIXME, perhaps?</span>
<span class="p_add">+ * __getblk_gfp() will lock up the machine if grow_dev_page&#39;s</span>
<span class="p_add">+ * try_to_free_buffers() attempt is failing.  FIXME, perhaps?</span>
  */
 struct buffer_head *
<span class="p_del">-__getblk(struct block_device *bdev, sector_t block, unsigned size)</span>
<span class="p_add">+__getblk_gfp(struct block_device *bdev, sector_t block,</span>
<span class="p_add">+	     unsigned size, gfp_t gfp)</span>
 {
 	struct buffer_head *bh = __find_get_block(bdev, block, size);
 
 	might_sleep();
 	if (bh == NULL)
<span class="p_del">-		bh = __getblk_slow(bdev, block, size);</span>
<span class="p_add">+		bh = __getblk_slow(bdev, block, size, gfp);</span>
 	return bh;
 }
<span class="p_del">-EXPORT_SYMBOL(__getblk);</span>
<span class="p_add">+EXPORT_SYMBOL(__getblk_gfp);</span>
 
 /*
  * Do async read-ahead on a buffer..
<span class="p_chunk">@@ -1413,24 +1416,28 @@</span> <span class="p_context"> void __breadahead(struct block_device *bdev, sector_t block, unsigned size)</span>
 EXPORT_SYMBOL(__breadahead);
 
 /**
<span class="p_del">- *  __bread() - reads a specified block and returns the bh</span>
<span class="p_add">+ *  __bread_gfp() - reads a specified block and returns the bh</span>
  *  @bdev: the block_device to read from
  *  @block: number of block
  *  @size: size (in bytes) to read
<span class="p_del">- * </span>
<span class="p_add">+ *  @gfp: page allocation flag</span>
<span class="p_add">+ *</span>
  *  Reads a specified block, and returns buffer head that contains it.
<span class="p_add">+ *  The page cache can be allocated from non-movable area</span>
<span class="p_add">+ *  not to prevent page migration if you set gfp to zero.</span>
  *  It returns NULL if the block was unreadable.
  */
 struct buffer_head *
<span class="p_del">-__bread(struct block_device *bdev, sector_t block, unsigned size)</span>
<span class="p_add">+__bread_gfp(struct block_device *bdev, sector_t block,</span>
<span class="p_add">+		   unsigned size, gfp_t gfp)</span>
 {
<span class="p_del">-	struct buffer_head *bh = __getblk(bdev, block, size);</span>
<span class="p_add">+	struct buffer_head *bh = __getblk_gfp(bdev, block, size, gfp);</span>
 
 	if (likely(bh) &amp;&amp; !buffer_uptodate(bh))
 		bh = __bread_slow(bh);
 	return bh;
 }
<span class="p_del">-EXPORT_SYMBOL(__bread);</span>
<span class="p_add">+EXPORT_SYMBOL(__bread_gfp);</span>
 
 /*
  * invalidate_bh_lrus() is called rarely - but not only at unmount.
<span class="p_header">diff --git a/fs/configfs/mount.c b/fs/configfs/mount.c</span>
<span class="p_header">index f6c285833390..e9aa82098c39 100644</span>
<span class="p_header">--- a/fs/configfs/mount.c</span>
<span class="p_header">+++ b/fs/configfs/mount.c</span>
<span class="p_chunk">@@ -129,8 +129,6 @@</span> <span class="p_context"> void configfs_release_fs(void)</span>
 }
 
 
<span class="p_del">-static struct kobject *config_kobj;</span>
<span class="p_del">-</span>
 static int __init configfs_init(void)
 {
 	int err = -ENOMEM;
<span class="p_chunk">@@ -141,8 +139,8 @@</span> <span class="p_context"> static int __init configfs_init(void)</span>
 	if (!configfs_dir_cachep)
 		goto out;
 
<span class="p_del">-	config_kobj = kobject_create_and_add(&quot;config&quot;, kernel_kobj);</span>
<span class="p_del">-	if (!config_kobj)</span>
<span class="p_add">+	err = sysfs_create_mount_point(kernel_kobj, &quot;config&quot;);</span>
<span class="p_add">+	if (err)</span>
 		goto out2;
 
 	err = configfs_inode_init();
<span class="p_chunk">@@ -158,7 +156,7 @@</span> <span class="p_context"> out4:</span>
 	pr_err(&quot;Unable to register filesystem!\n&quot;);
 	configfs_inode_exit();
 out3:
<span class="p_del">-	kobject_put(config_kobj);</span>
<span class="p_add">+	sysfs_remove_mount_point(kernel_kobj, &quot;config&quot;);</span>
 out2:
 	kmem_cache_destroy(configfs_dir_cachep);
 	configfs_dir_cachep = NULL;
<span class="p_chunk">@@ -169,7 +167,7 @@</span> <span class="p_context"> out:</span>
 static void __exit configfs_exit(void)
 {
 	unregister_filesystem(&amp;configfs_fs_type);
<span class="p_del">-	kobject_put(config_kobj);</span>
<span class="p_add">+	sysfs_remove_mount_point(kernel_kobj, &quot;config&quot;);</span>
 	kmem_cache_destroy(configfs_dir_cachep);
 	configfs_dir_cachep = NULL;
 	configfs_inode_exit();
<span class="p_header">diff --git a/fs/debugfs/inode.c b/fs/debugfs/inode.c</span>
<span class="p_header">index 0c6ba4ef00a0..75c865bd376d 100644</span>
<span class="p_header">--- a/fs/debugfs/inode.c</span>
<span class="p_header">+++ b/fs/debugfs/inode.c</span>
<span class="p_chunk">@@ -668,20 +668,17 @@</span> <span class="p_context"> bool debugfs_initialized(void)</span>
 }
 EXPORT_SYMBOL_GPL(debugfs_initialized);
 
<span class="p_del">-</span>
<span class="p_del">-static struct kobject *debug_kobj;</span>
<span class="p_del">-</span>
 static int __init debugfs_init(void)
 {
 	int retval;
 
<span class="p_del">-	debug_kobj = kobject_create_and_add(&quot;debug&quot;, kernel_kobj);</span>
<span class="p_del">-	if (!debug_kobj)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	retval = sysfs_create_mount_point(kernel_kobj, &quot;debug&quot;);</span>
<span class="p_add">+	if (retval)</span>
<span class="p_add">+		return retval;</span>
 
 	retval = register_filesystem(&amp;debug_fs_type);
 	if (retval)
<span class="p_del">-		kobject_put(debug_kobj);</span>
<span class="p_add">+		sysfs_remove_mount_point(kernel_kobj, &quot;debug&quot;);</span>
 	else
 		debugfs_registered = true;
 
<span class="p_header">diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c</span>
<span class="p_header">index a2c5bb7e71bb..ba5d7dc47b3e 100644</span>
<span class="p_header">--- a/fs/ext4/extents.c</span>
<span class="p_header">+++ b/fs/ext4/extents.c</span>
<span class="p_chunk">@@ -487,7 +487,7 @@</span> <span class="p_context"> __read_extent_tree_block(const char *function, unsigned int line,</span>
 	struct buffer_head		*bh;
 	int				err;
 
<span class="p_del">-	bh = sb_getblk(inode-&gt;i_sb, pblk);</span>
<span class="p_add">+	bh = sb_getblk_gfp(inode-&gt;i_sb, pblk, __GFP_MOVABLE | GFP_NOFS);</span>
 	if (unlikely(!bh))
 		return ERR_PTR(-ENOMEM);
 
<span class="p_chunk">@@ -1061,7 +1061,7 @@</span> <span class="p_context"> static int ext4_ext_split(handle_t *handle, struct inode *inode,</span>
 		err = -EIO;
 		goto cleanup;
 	}
<span class="p_del">-	bh = sb_getblk(inode-&gt;i_sb, newblock);</span>
<span class="p_add">+	bh = sb_getblk_gfp(inode-&gt;i_sb, newblock, __GFP_MOVABLE | GFP_NOFS);</span>
 	if (unlikely(!bh)) {
 		err = -ENOMEM;
 		goto cleanup;
<span class="p_chunk">@@ -1247,7 +1247,7 @@</span> <span class="p_context"> static int ext4_ext_grow_indepth(handle_t *handle, struct inode *inode,</span>
 	if (newblock == 0)
 		return err;
 
<span class="p_del">-	bh = sb_getblk(inode-&gt;i_sb, newblock);</span>
<span class="p_add">+	bh = sb_getblk_gfp(inode-&gt;i_sb, newblock, __GFP_MOVABLE | GFP_NOFS);</span>
 	if (unlikely(!bh))
 		return -ENOMEM;
 	lock_buffer(bh);
<span class="p_header">diff --git a/fs/fuse/inode.c b/fs/fuse/inode.c</span>
<span class="p_header">index 9e3f6cfee2fb..6abafb11f214 100644</span>
<span class="p_header">--- a/fs/fuse/inode.c</span>
<span class="p_header">+++ b/fs/fuse/inode.c</span>
<span class="p_chunk">@@ -1261,7 +1261,6 @@</span> <span class="p_context"> static void fuse_fs_cleanup(void)</span>
 }
 
 static struct kobject *fuse_kobj;
<span class="p_del">-static struct kobject *connections_kobj;</span>
 
 static int fuse_sysfs_init(void)
 {
<span class="p_chunk">@@ -1273,11 +1272,9 @@</span> <span class="p_context"> static int fuse_sysfs_init(void)</span>
 		goto out_err;
 	}
 
<span class="p_del">-	connections_kobj = kobject_create_and_add(&quot;connections&quot;, fuse_kobj);</span>
<span class="p_del">-	if (!connections_kobj) {</span>
<span class="p_del">-		err = -ENOMEM;</span>
<span class="p_add">+	err = sysfs_create_mount_point(fuse_kobj, &quot;connections&quot;);</span>
<span class="p_add">+	if (err)</span>
 		goto out_fuse_unregister;
<span class="p_del">-	}</span>
 
 	return 0;
 
<span class="p_chunk">@@ -1289,7 +1286,7 @@</span> <span class="p_context"> static int fuse_sysfs_init(void)</span>
 
 static void fuse_sysfs_cleanup(void)
 {
<span class="p_del">-	kobject_put(connections_kobj);</span>
<span class="p_add">+	sysfs_remove_mount_point(fuse_kobj, &quot;connections&quot;);</span>
 	kobject_put(fuse_kobj);
 }
 
<span class="p_header">diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c</span>
<span class="p_header">index aa6daf535dec..fa8d1b632d49 100644</span>
<span class="p_header">--- a/fs/nfs/inode.c</span>
<span class="p_header">+++ b/fs/nfs/inode.c</span>
<span class="p_chunk">@@ -1179,9 +1179,11 @@</span> <span class="p_context"> static int nfs_check_inode_attributes(struct inode *inode, struct nfs_fattr *fat</span>
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_SIZE) {
 		cur_size = i_size_read(inode);
 		new_isize = nfs_size_to_loff_t(fattr-&gt;size);
<span class="p_del">-		if (cur_size != new_isize &amp;&amp; nfsi-&gt;npages == 0)</span>
<span class="p_add">+		if (cur_size != new_isize)</span>
 			invalid |= NFS_INO_INVALID_ATTR|NFS_INO_REVAL_PAGECACHE;
 	}
<span class="p_add">+	if (nfsi-&gt;npages != 0)</span>
<span class="p_add">+		invalid &amp;= ~NFS_INO_REVAL_PAGECACHE;</span>
 
 	/* Have any file permissions changed? */
 	if ((fattr-&gt;valid &amp; NFS_ATTR_FATTR_MODE) &amp;&amp; (inode-&gt;i_mode &amp; S_IALLUGO) != (fattr-&gt;mode &amp; S_IALLUGO))
<span class="p_chunk">@@ -1576,8 +1578,7 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 			invalid |= NFS_INO_INVALID_ATTR
 				| NFS_INO_INVALID_DATA
 				| NFS_INO_INVALID_ACCESS
<span class="p_del">-				| NFS_INO_INVALID_ACL</span>
<span class="p_del">-				| NFS_INO_REVAL_PAGECACHE;</span>
<span class="p_add">+				| NFS_INO_INVALID_ACL;</span>
 			if (S_ISDIR(inode-&gt;i_mode))
 				nfs_force_lookup_revalidate(inode);
 			inode-&gt;i_version = fattr-&gt;change_attr;
<span class="p_chunk">@@ -1609,7 +1610,6 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 			if ((nfsi-&gt;npages == 0) || new_isize &gt; cur_isize) {
 				i_size_write(inode, new_isize);
 				invalid |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA;
<span class="p_del">-				invalid &amp;= ~NFS_INO_REVAL_PAGECACHE;</span>
 			}
 			dprintk(&quot;NFS: isize change on server for file %s/%ld &quot;
 					&quot;(%Ld to %Ld)\n&quot;,
<span class="p_header">diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c</span>
<span class="p_header">index dda2e4d91a25..90db0c9faec1 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4xdr.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4xdr.c</span>
<span class="p_chunk">@@ -1956,6 +1956,7 @@</span> <span class="p_context"> nfsd4_encode_aclname(struct xdr_stream *xdr, struct svc_rqst *rqstp,</span>
 #define WORD0_ABSENT_FS_ATTRS (FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_FSID | \
 			      FATTR4_WORD0_RDATTR_ERROR)
 #define WORD1_ABSENT_FS_ATTRS FATTR4_WORD1_MOUNTED_ON_FILEID
<span class="p_add">+#define WORD2_ABSENT_FS_ATTRS 0</span>
 
 #ifdef CONFIG_NFSD_V4_SECURITY_LABEL
 static inline __be32
<span class="p_chunk">@@ -1984,7 +1985,7 @@</span> <span class="p_context"> nfsd4_encode_security_label(struct xdr_stream *xdr, struct svc_rqst *rqstp,</span>
 { return 0; }
 #endif
 
<span class="p_del">-static __be32 fattr_handle_absent_fs(u32 *bmval0, u32 *bmval1, u32 *rdattr_err)</span>
<span class="p_add">+static __be32 fattr_handle_absent_fs(u32 *bmval0, u32 *bmval1, u32 *bmval2, u32 *rdattr_err)</span>
 {
 	/* As per referral draft:  */
 	if (*bmval0 &amp; ~WORD0_ABSENT_FS_ATTRS ||
<span class="p_chunk">@@ -1997,6 +1998,7 @@</span> <span class="p_context"> static __be32 fattr_handle_absent_fs(u32 *bmval0, u32 *bmval1, u32 *rdattr_err)</span>
 	}
 	*bmval0 &amp;= WORD0_ABSENT_FS_ATTRS;
 	*bmval1 &amp;= WORD1_ABSENT_FS_ATTRS;
<span class="p_add">+	*bmval2 &amp;= WORD2_ABSENT_FS_ATTRS;</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -2060,8 +2062,7 @@</span> <span class="p_context"> nfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,</span>
 	BUG_ON(bmval2 &amp; ~nfsd_suppattrs2(minorversion));
 
 	if (exp-&gt;ex_fslocs.migrated) {
<span class="p_del">-		BUG_ON(bmval[2]);</span>
<span class="p_del">-		status = fattr_handle_absent_fs(&amp;bmval0, &amp;bmval1, &amp;rdattr_err);</span>
<span class="p_add">+		status = fattr_handle_absent_fs(&amp;bmval0, &amp;bmval1, &amp;bmval2, &amp;rdattr_err);</span>
 		if (status)
 			goto out;
 	}
<span class="p_chunk">@@ -2104,8 +2105,8 @@</span> <span class="p_context"> nfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,</span>
 	}
 
 #ifdef CONFIG_NFSD_V4_SECURITY_LABEL
<span class="p_del">-	if ((bmval[2] &amp; FATTR4_WORD2_SECURITY_LABEL) ||</span>
<span class="p_del">-			bmval[0] &amp; FATTR4_WORD0_SUPPORTED_ATTRS) {</span>
<span class="p_add">+	if ((bmval2 &amp; FATTR4_WORD2_SECURITY_LABEL) ||</span>
<span class="p_add">+	     bmval0 &amp; FATTR4_WORD0_SUPPORTED_ATTRS) {</span>
 		err = security_inode_getsecctx(dentry-&gt;d_inode,
 						&amp;context, &amp;contextlen);
 		contextsupport = (err == 0);
<span class="p_header">diff --git a/fs/notify/mark.c b/fs/notify/mark.c</span>
<span class="p_header">index d90deaa08e78..e7b1ca99d82d 100644</span>
<span class="p_header">--- a/fs/notify/mark.c</span>
<span class="p_header">+++ b/fs/notify/mark.c</span>
<span class="p_chunk">@@ -293,16 +293,36 @@</span> <span class="p_context"> void fsnotify_clear_marks_by_group_flags(struct fsnotify_group *group,</span>
 					 unsigned int flags)
 {
 	struct fsnotify_mark *lmark, *mark;
<span class="p_add">+	LIST_HEAD(to_free);</span>
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We have to be really careful here. Anytime we drop mark_mutex, e.g.</span>
<span class="p_add">+	 * fsnotify_clear_marks_by_inode() can come and free marks. Even in our</span>
<span class="p_add">+	 * to_free list so we have to use mark_mutex even when accessing that</span>
<span class="p_add">+	 * list. And freeing mark requires us to drop mark_mutex. So we can</span>
<span class="p_add">+	 * reliably free only the first mark in the list. That&#39;s why we first</span>
<span class="p_add">+	 * move marks to free to to_free list in one go and then free marks in</span>
<span class="p_add">+	 * to_free list one by one.</span>
<span class="p_add">+	 */</span>
 	mutex_lock_nested(&amp;group-&gt;mark_mutex, SINGLE_DEPTH_NESTING);
 	list_for_each_entry_safe(mark, lmark, &amp;group-&gt;marks_list, g_list) {
<span class="p_del">-		if (mark-&gt;flags &amp; flags) {</span>
<span class="p_del">-			fsnotify_get_mark(mark);</span>
<span class="p_del">-			fsnotify_destroy_mark_locked(mark, group);</span>
<span class="p_del">-			fsnotify_put_mark(mark);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (mark-&gt;flags &amp; flags)</span>
<span class="p_add">+			list_move(&amp;mark-&gt;g_list, &amp;to_free);</span>
 	}
 	mutex_unlock(&amp;group-&gt;mark_mutex);
<span class="p_add">+</span>
<span class="p_add">+	while (1) {</span>
<span class="p_add">+		mutex_lock_nested(&amp;group-&gt;mark_mutex, SINGLE_DEPTH_NESTING);</span>
<span class="p_add">+		if (list_empty(&amp;to_free)) {</span>
<span class="p_add">+			mutex_unlock(&amp;group-&gt;mark_mutex);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		mark = list_first_entry(&amp;to_free, struct fsnotify_mark, g_list);</span>
<span class="p_add">+		fsnotify_get_mark(mark);</span>
<span class="p_add">+		fsnotify_destroy_mark_locked(mark, group);</span>
<span class="p_add">+		mutex_unlock(&amp;group-&gt;mark_mutex);</span>
<span class="p_add">+		fsnotify_put_mark(mark);</span>
<span class="p_add">+	}</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/ocfs2/dlmglue.c b/fs/ocfs2/dlmglue.c</span>
<span class="p_header">index 52cfe99ae056..d0b8b66e3cfb 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlmglue.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlmglue.c</span>
<span class="p_chunk">@@ -4006,9 +4006,13 @@</span> <span class="p_context"> static void ocfs2_downconvert_thread_do_work(struct ocfs2_super *osb)</span>
 	osb-&gt;dc_work_sequence = osb-&gt;dc_wake_sequence;
 
 	processed = osb-&gt;blocked_lock_count;
<span class="p_del">-	while (processed) {</span>
<span class="p_del">-		BUG_ON(list_empty(&amp;osb-&gt;blocked_lock_list));</span>
<span class="p_del">-</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * blocked lock processing in this loop might call iput which can</span>
<span class="p_add">+	 * remove items off osb-&gt;blocked_lock_list. Downconvert up to</span>
<span class="p_add">+	 * &#39;processed&#39; number of locks, but stop short if we had some</span>
<span class="p_add">+	 * removed in ocfs2_mark_lockres_freeing when downconverting.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	while (processed &amp;&amp; !list_empty(&amp;osb-&gt;blocked_lock_list)) {</span>
 		lockres = list_entry(osb-&gt;blocked_lock_list.next,
 				     struct ocfs2_lock_res, l_blocked_list);
 		list_del_init(&amp;lockres-&gt;l_blocked_list);
<span class="p_header">diff --git a/fs/pstore/inode.c b/fs/pstore/inode.c</span>
<span class="p_header">index fafb7a02a5d6..3b172f651894 100644</span>
<span class="p_header">--- a/fs/pstore/inode.c</span>
<span class="p_header">+++ b/fs/pstore/inode.c</span>
<span class="p_chunk">@@ -430,22 +430,18 @@</span> <span class="p_context"> static struct file_system_type pstore_fs_type = {</span>
 	.kill_sb	= pstore_kill_sb,
 };
 
<span class="p_del">-static struct kobject *pstore_kobj;</span>
<span class="p_del">-</span>
 static int __init init_pstore_fs(void)
 {
<span class="p_del">-	int err = 0;</span>
<span class="p_add">+	int err;</span>
 
 	/* Create a convenient mount point for people to access pstore */
<span class="p_del">-	pstore_kobj = kobject_create_and_add(&quot;pstore&quot;, fs_kobj);</span>
<span class="p_del">-	if (!pstore_kobj) {</span>
<span class="p_del">-		err = -ENOMEM;</span>
<span class="p_add">+	err = sysfs_create_mount_point(fs_kobj, &quot;pstore&quot;);</span>
<span class="p_add">+	if (err)</span>
 		goto out;
<span class="p_del">-	}</span>
 
 	err = register_filesystem(&amp;pstore_fs_type);
 	if (err &lt; 0)
<span class="p_del">-		kobject_put(pstore_kobj);</span>
<span class="p_add">+		sysfs_remove_mount_point(fs_kobj, &quot;pstore&quot;);</span>
 
 out:
 	return err;
<span class="p_header">diff --git a/fs/signalfd.c b/fs/signalfd.c</span>
<span class="p_header">index 424b7b65321f..148f8e7af882 100644</span>
<span class="p_header">--- a/fs/signalfd.c</span>
<span class="p_header">+++ b/fs/signalfd.c</span>
<span class="p_chunk">@@ -121,8 +121,9 @@</span> <span class="p_context"> static int signalfd_copyinfo(struct signalfd_siginfo __user *uinfo,</span>
 		 * Other callers might not initialize the si_lsb field,
 		 * so check explicitly for the right codes here.
 		 */
<span class="p_del">-		if (kinfo-&gt;si_code == BUS_MCEERR_AR ||</span>
<span class="p_del">-		    kinfo-&gt;si_code == BUS_MCEERR_AO)</span>
<span class="p_add">+		if (kinfo-&gt;si_signo == SIGBUS &amp;&amp;</span>
<span class="p_add">+		    (kinfo-&gt;si_code == BUS_MCEERR_AR ||</span>
<span class="p_add">+		     kinfo-&gt;si_code == BUS_MCEERR_AO))</span>
 			err |= __put_user((short) kinfo-&gt;si_addr_lsb,
 					  &amp;uinfo-&gt;ssi_addr_lsb);
 #endif
<span class="p_header">diff --git a/fs/xfs/xfs_attr_remote.c b/fs/xfs/xfs_attr_remote.c</span>
<span class="p_header">index b5adfecbb8ee..a46b19e2b4ce 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_attr_remote.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_attr_remote.c</span>
<span class="p_chunk">@@ -161,11 +161,10 @@</span> <span class="p_context"> xfs_attr3_rmt_write_verify(</span>
 	struct xfs_buf	*bp)
 {
 	struct xfs_mount *mp = bp-&gt;b_target-&gt;bt_mount;
<span class="p_del">-	struct xfs_buf_log_item	*bip = bp-&gt;b_fspriv;</span>
<span class="p_add">+	int		blksize = mp-&gt;m_attr_geo-&gt;blksize;</span>
 	char		*ptr;
 	int		len;
 	xfs_daddr_t	bno;
<span class="p_del">-	int		blksize = mp-&gt;m_attr_geo-&gt;blksize;</span>
 
 	/* no verification of non-crc buffers */
 	if (!xfs_sb_version_hascrc(&amp;mp-&gt;m_sb))
<span class="p_chunk">@@ -177,16 +176,22 @@</span> <span class="p_context"> xfs_attr3_rmt_write_verify(</span>
 	ASSERT(len &gt;= blksize);
 
 	while (len &gt; 0) {
<span class="p_add">+		struct xfs_attr3_rmt_hdr *rmt = (struct xfs_attr3_rmt_hdr *)ptr;</span>
<span class="p_add">+</span>
 		if (!xfs_attr3_rmt_verify(mp, ptr, blksize, bno)) {
 			xfs_buf_ioerror(bp, EFSCORRUPTED);
 			xfs_verifier_error(bp);
 			return;
 		}
<span class="p_del">-		if (bip) {</span>
<span class="p_del">-			struct xfs_attr3_rmt_hdr *rmt;</span>
 
<span class="p_del">-			rmt = (struct xfs_attr3_rmt_hdr *)ptr;</span>
<span class="p_del">-			rmt-&gt;rm_lsn = cpu_to_be64(bip-&gt;bli_item.li_lsn);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Ensure we aren&#39;t writing bogus LSNs to disk. See</span>
<span class="p_add">+		 * xfs_attr3_rmt_hdr_set() for the explanation.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (rmt-&gt;rm_lsn != cpu_to_be64(NULLCOMMITLSN)) {</span>
<span class="p_add">+			xfs_buf_ioerror(bp, EFSCORRUPTED);</span>
<span class="p_add">+			xfs_verifier_error(bp);</span>
<span class="p_add">+			return;</span>
 		}
 		xfs_update_cksum(ptr, blksize, XFS_ATTR3_RMT_CRC_OFF);
 
<span class="p_chunk">@@ -223,6 +228,18 @@</span> <span class="p_context"> xfs_attr3_rmt_hdr_set(</span>
 	rmt-&gt;rm_owner = cpu_to_be64(ino);
 	rmt-&gt;rm_blkno = cpu_to_be64(bno);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Remote attribute blocks are written synchronously, so we don&#39;t</span>
<span class="p_add">+	 * have an LSN that we can stamp in them that makes any sense to log</span>
<span class="p_add">+	 * recovery. To ensure that log recovery handles overwrites of these</span>
<span class="p_add">+	 * blocks sanely (i.e. once they&#39;ve been freed and reallocated as some</span>
<span class="p_add">+	 * other type of metadata) we need to ensure that the LSN has a value</span>
<span class="p_add">+	 * that tells log recovery to ignore the LSN and overwrite the buffer</span>
<span class="p_add">+	 * with whatever is in it&#39;s log. To do this, we use the magic</span>
<span class="p_add">+	 * NULLCOMMITLSN to indicate that the LSN is invalid.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	rmt-&gt;rm_lsn = cpu_to_be64(NULLCOMMITLSN);</span>
<span class="p_add">+</span>
 	return sizeof(struct xfs_attr3_rmt_hdr);
 }
 
<span class="p_chunk">@@ -436,14 +453,21 @@</span> <span class="p_context"> xfs_attr_rmtval_set(</span>
 
 		/*
 		 * Allocate a single extent, up to the size of the value.
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Note that we have to consider this a data allocation as we</span>
<span class="p_add">+		 * write the remote attribute without logging the contents.</span>
<span class="p_add">+		 * Hence we must ensure that we aren&#39;t using blocks that are on</span>
<span class="p_add">+		 * the busy list so that we don&#39;t overwrite blocks which have</span>
<span class="p_add">+		 * recently been freed but their transactions are not yet</span>
<span class="p_add">+		 * committed to disk. If we overwrite the contents of a busy</span>
<span class="p_add">+		 * extent and then crash then the block may not contain the</span>
<span class="p_add">+		 * correct metadata after log recovery occurs.</span>
 		 */
 		xfs_bmap_init(args-&gt;flist, args-&gt;firstblock);
 		nmap = 1;
 		error = xfs_bmapi_write(args-&gt;trans, dp, (xfs_fileoff_t)lblkno,
<span class="p_del">-				  blkcnt,</span>
<span class="p_del">-				  XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,</span>
<span class="p_del">-				  args-&gt;firstblock, args-&gt;total, &amp;map, &amp;nmap,</span>
<span class="p_del">-				  args-&gt;flist);</span>
<span class="p_add">+				  blkcnt, XFS_BMAPI_ATTRFORK, args-&gt;firstblock,</span>
<span class="p_add">+				  args-&gt;total, &amp;map, &amp;nmap, args-&gt;flist);</span>
 		if (!error) {
 			error = xfs_bmap_finish(&amp;args-&gt;trans, args-&gt;flist,
 						&amp;committed);
<span class="p_header">diff --git a/fs/xfs/xfs_log_recover.c b/fs/xfs/xfs_log_recover.c</span>
<span class="p_header">index 8c962890fe17..dae4723a02bf 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_log_recover.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_log_recover.c</span>
<span class="p_chunk">@@ -2044,9 +2044,14 @@</span> <span class="p_context"> xlog_recover_get_buf_lsn(</span>
 		uuid = &amp;((struct xfs_dir3_blk_hdr *)blk)-&gt;uuid;
 		break;
 	case XFS_ATTR3_RMT_MAGIC:
<span class="p_del">-		lsn = be64_to_cpu(((struct xfs_attr3_rmt_hdr *)blk)-&gt;rm_lsn);</span>
<span class="p_del">-		uuid = &amp;((struct xfs_attr3_rmt_hdr *)blk)-&gt;rm_uuid;</span>
<span class="p_del">-		break;</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Remote attr blocks are written synchronously, rather than</span>
<span class="p_add">+		 * being logged. That means they do not contain a valid LSN</span>
<span class="p_add">+		 * (i.e. transactionally ordered) in them, and hence any time we</span>
<span class="p_add">+		 * see a buffer to replay over the top of a remote attribute</span>
<span class="p_add">+		 * block we should simply do so.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		goto recover_immediately;</span>
 	case XFS_SB_MAGIC:
 		lsn = be64_to_cpu(((struct xfs_dsb *)blk)-&gt;sb_lsn);
 		uuid = &amp;((struct xfs_dsb *)blk)-&gt;sb_uuid;
<span class="p_header">diff --git a/include/drm/drm_pciids.h b/include/drm/drm_pciids.h</span>
<span class="p_header">index 45c39a37f924..8bc073d297db 100644</span>
<span class="p_header">--- a/include/drm/drm_pciids.h</span>
<span class="p_header">+++ b/include/drm/drm_pciids.h</span>
<span class="p_chunk">@@ -172,6 +172,7 @@</span> <span class="p_context"></span>
 	{0x1002, 0x6610, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x6611, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x6613, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_NEW_MEMMAP}, \
<span class="p_add">+	{0x1002, 0x6617, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \</span>
 	{0x1002, 0x6620, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x6621, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x6623, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
<span class="p_header">diff --git a/include/linux/buffer_head.h b/include/linux/buffer_head.h</span>
<span class="p_header">index 324329ceea1e..e6797ded700e 100644</span>
<span class="p_header">--- a/include/linux/buffer_head.h</span>
<span class="p_header">+++ b/include/linux/buffer_head.h</span>
<span class="p_chunk">@@ -175,12 +175,13 @@</span> <span class="p_context"> void __wait_on_buffer(struct buffer_head *);</span>
 wait_queue_head_t *bh_waitq_head(struct buffer_head *bh);
 struct buffer_head *__find_get_block(struct block_device *bdev, sector_t block,
 			unsigned size);
<span class="p_del">-struct buffer_head *__getblk(struct block_device *bdev, sector_t block,</span>
<span class="p_del">-			unsigned size);</span>
<span class="p_add">+struct buffer_head *__getblk_gfp(struct block_device *bdev, sector_t block,</span>
<span class="p_add">+				  unsigned size, gfp_t gfp);</span>
 void __brelse(struct buffer_head *);
 void __bforget(struct buffer_head *);
 void __breadahead(struct block_device *, sector_t block, unsigned int size);
<span class="p_del">-struct buffer_head *__bread(struct block_device *, sector_t block, unsigned size);</span>
<span class="p_add">+struct buffer_head *__bread_gfp(struct block_device *,</span>
<span class="p_add">+				sector_t block, unsigned size, gfp_t gfp);</span>
 void invalidate_bh_lrus(void);
 struct buffer_head *alloc_buffer_head(gfp_t gfp_flags);
 void free_buffer_head(struct buffer_head * bh);
<span class="p_chunk">@@ -295,7 +296,13 @@</span> <span class="p_context"> static inline void bforget(struct buffer_head *bh)</span>
 static inline struct buffer_head *
 sb_bread(struct super_block *sb, sector_t block)
 {
<span class="p_del">-	return __bread(sb-&gt;s_bdev, block, sb-&gt;s_blocksize);</span>
<span class="p_add">+	return __bread_gfp(sb-&gt;s_bdev, block, sb-&gt;s_blocksize, __GFP_MOVABLE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline struct buffer_head *</span>
<span class="p_add">+sb_bread_unmovable(struct super_block *sb, sector_t block)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __bread_gfp(sb-&gt;s_bdev, block, sb-&gt;s_blocksize, 0);</span>
 }
 
 static inline void
<span class="p_chunk">@@ -307,7 +314,14 @@</span> <span class="p_context"> sb_breadahead(struct super_block *sb, sector_t block)</span>
 static inline struct buffer_head *
 sb_getblk(struct super_block *sb, sector_t block)
 {
<span class="p_del">-	return __getblk(sb-&gt;s_bdev, block, sb-&gt;s_blocksize);</span>
<span class="p_add">+	return __getblk_gfp(sb-&gt;s_bdev, block, sb-&gt;s_blocksize, __GFP_MOVABLE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static inline struct buffer_head *</span>
<span class="p_add">+sb_getblk_gfp(struct super_block *sb, sector_t block, gfp_t gfp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __getblk_gfp(sb-&gt;s_bdev, block, sb-&gt;s_blocksize, gfp);</span>
 }
 
 static inline struct buffer_head *
<span class="p_chunk">@@ -344,6 +358,36 @@</span> <span class="p_context"> static inline void lock_buffer(struct buffer_head *bh)</span>
 		__lock_buffer(bh);
 }
 
<span class="p_add">+static inline struct buffer_head *getblk_unmovable(struct block_device *bdev,</span>
<span class="p_add">+						   sector_t block,</span>
<span class="p_add">+						   unsigned size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __getblk_gfp(bdev, block, size, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline struct buffer_head *__getblk(struct block_device *bdev,</span>
<span class="p_add">+					   sector_t block,</span>
<span class="p_add">+					   unsigned size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __getblk_gfp(bdev, block, size, __GFP_MOVABLE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ *  __bread() - reads a specified block and returns the bh</span>
<span class="p_add">+ *  @bdev: the block_device to read from</span>
<span class="p_add">+ *  @block: number of block</span>
<span class="p_add">+ *  @size: size (in bytes) to read</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  Reads a specified block, and returns buffer head that contains it.</span>
<span class="p_add">+ *  The page cache is allocated from movable area so that it can be migrated.</span>
<span class="p_add">+ *  It returns NULL if the block was unreadable.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline struct buffer_head *</span>
<span class="p_add">+__bread(struct block_device *bdev, sector_t block, unsigned size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __bread_gfp(bdev, block, size, __GFP_MOVABLE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 extern int __set_page_dirty_buffers(struct page *page);
 
 #else /* CONFIG_BLOCK */
<span class="p_header">diff --git a/include/linux/compiler.h b/include/linux/compiler.h</span>
<span class="p_header">index d5ad7b1118fc..da293bf86575 100644</span>
<span class="p_header">--- a/include/linux/compiler.h</span>
<span class="p_header">+++ b/include/linux/compiler.h</span>
<span class="p_chunk">@@ -380,6 +380,21 @@</span> <span class="p_context"> void ftrace_likely_update(struct ftrace_branch_data *f, int val, int expect);</span>
  */
 #define ACCESS_ONCE(x) (*(volatile typeof(x) *)&amp;(x))
 
<span class="p_add">+/**</span>
<span class="p_add">+ * lockless_dereference() - safely load a pointer for later dereference</span>
<span class="p_add">+ * @p: The pointer to load</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Similar to rcu_dereference(), but for situations where the pointed-to</span>
<span class="p_add">+ * object&#39;s lifetime is managed by something other than RCU.  That</span>
<span class="p_add">+ * &quot;something other&quot; might be reference counting or simple immortality.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define lockless_dereference(p) \</span>
<span class="p_add">+({ \</span>
<span class="p_add">+	typeof(p) _________p1 = ACCESS_ONCE(p); \</span>
<span class="p_add">+	smp_read_barrier_depends(); /* Dependency order vs. p above. */ \</span>
<span class="p_add">+	(_________p1); \</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
 /* Ignore/forbid kprobes attach on very low level functions marked by this attribute: */
 #ifdef CONFIG_KPROBES
 # define __kprobes	__attribute__((__section__(&quot;.kprobes.text&quot;)))
<span class="p_header">diff --git a/include/net/act_api.h b/include/net/act_api.h</span>
<span class="p_header">index 3ee4c92afd1b..931738bc5bba 100644</span>
<span class="p_header">--- a/include/net/act_api.h</span>
<span class="p_header">+++ b/include/net/act_api.h</span>
<span class="p_chunk">@@ -99,7 +99,6 @@</span> <span class="p_context"> struct tc_action_ops {</span>
 
 int tcf_hash_search(struct tc_action *a, u32 index);
 void tcf_hash_destroy(struct tc_action *a);
<span class="p_del">-int tcf_hash_release(struct tc_action *a, int bind);</span>
 u32 tcf_hash_new_index(struct tcf_hashinfo *hinfo);
 int tcf_hash_check(u32 index, struct tc_action *a, int bind);
 int tcf_hash_create(u32 index, struct nlattr *est, struct tc_action *a,
<span class="p_chunk">@@ -107,6 +106,13 @@</span> <span class="p_context"> int tcf_hash_create(u32 index, struct nlattr *est, struct tc_action *a,</span>
 void tcf_hash_cleanup(struct tc_action *a, struct nlattr *est);
 void tcf_hash_insert(struct tc_action *a);
 
<span class="p_add">+int __tcf_hash_release(struct tc_action *a, bool bind, bool strict);</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int tcf_hash_release(struct tc_action *a, bool bind)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __tcf_hash_release(a, bind, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int tcf_register_action(struct tc_action_ops *a, unsigned int mask);
 int tcf_unregister_action(struct tc_action_ops *a);
 int tcf_action_destroy(struct list_head *actions, int bind);
<span class="p_header">diff --git a/include/net/ip.h b/include/net/ip.h</span>
<span class="p_header">index f2254fe1a39c..3d389a86a7e2 100644</span>
<span class="p_header">--- a/include/net/ip.h</span>
<span class="p_header">+++ b/include/net/ip.h</span>
<span class="p_chunk">@@ -159,6 +159,7 @@</span> <span class="p_context"> static inline __u8 get_rtconn_flags(struct ipcm_cookie* ipc, struct sock* sk)</span>
 }
 
 /* datagram.c */
<span class="p_add">+int __ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);</span>
 int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);
 
 void ip4_datagram_release_cb(struct sock *sk);
<span class="p_header">diff --git a/include/uapi/linux/pci_regs.h b/include/uapi/linux/pci_regs.h</span>
<span class="p_header">index 30db069bce62..788c5aa055d7 100644</span>
<span class="p_header">--- a/include/uapi/linux/pci_regs.h</span>
<span class="p_header">+++ b/include/uapi/linux/pci_regs.h</span>
<span class="p_chunk">@@ -319,6 +319,7 @@</span> <span class="p_context"></span>
 #define PCI_MSIX_PBA		8	/* Pending Bit Array offset */
 #define  PCI_MSIX_PBA_BIR	0x00000007 /* BAR index */
 #define  PCI_MSIX_PBA_OFFSET	0xfffffff8 /* Offset into specified BAR */
<span class="p_add">+#define PCI_MSIX_FLAGS_BIRMASK	PCI_MSIX_PBA_BIR /* deprecated */</span>
 #define PCI_CAP_MSIX_SIZEOF	12	/* size of MSIX registers */
 
 /* MSI-X Table entry format */
<span class="p_header">diff --git a/ipc/mqueue.c b/ipc/mqueue.c</span>
<span class="p_header">index 4fcf39af1776..f65a044d66c5 100644</span>
<span class="p_header">--- a/ipc/mqueue.c</span>
<span class="p_header">+++ b/ipc/mqueue.c</span>
<span class="p_chunk">@@ -143,7 +143,6 @@</span> <span class="p_context"> static int msg_insert(struct msg_msg *msg, struct mqueue_inode_info *info)</span>
 		if (!leaf)
 			return -ENOMEM;
 		INIT_LIST_HEAD(&amp;leaf-&gt;msg_list);
<span class="p_del">-		info-&gt;qsize += sizeof(*leaf);</span>
 	}
 	leaf-&gt;priority = msg-&gt;m_type;
 	rb_link_node(&amp;leaf-&gt;rb_node, parent, p);
<span class="p_chunk">@@ -188,7 +187,6 @@</span> <span class="p_context"> try_again:</span>
 			     &quot;lazy leaf delete!\n&quot;);
 		rb_erase(&amp;leaf-&gt;rb_node, &amp;info-&gt;msg_tree);
 		if (info-&gt;node_cache) {
<span class="p_del">-			info-&gt;qsize -= sizeof(*leaf);</span>
 			kfree(leaf);
 		} else {
 			info-&gt;node_cache = leaf;
<span class="p_chunk">@@ -201,7 +199,6 @@</span> <span class="p_context"> try_again:</span>
 		if (list_empty(&amp;leaf-&gt;msg_list)) {
 			rb_erase(&amp;leaf-&gt;rb_node, &amp;info-&gt;msg_tree);
 			if (info-&gt;node_cache) {
<span class="p_del">-				info-&gt;qsize -= sizeof(*leaf);</span>
 				kfree(leaf);
 			} else {
 				info-&gt;node_cache = leaf;
<span class="p_chunk">@@ -1026,7 +1023,6 @@</span> <span class="p_context"> SYSCALL_DEFINE5(mq_timedsend, mqd_t, mqdes, const char __user *, u_msg_ptr,</span>
 		/* Save our speculative allocation into the cache */
 		INIT_LIST_HEAD(&amp;new_leaf-&gt;msg_list);
 		info-&gt;node_cache = new_leaf;
<span class="p_del">-		info-&gt;qsize += sizeof(*new_leaf);</span>
 		new_leaf = NULL;
 	} else {
 		kfree(new_leaf);
<span class="p_chunk">@@ -1133,7 +1129,6 @@</span> <span class="p_context"> SYSCALL_DEFINE5(mq_timedreceive, mqd_t, mqdes, char __user *, u_msg_ptr,</span>
 		/* Save our speculative allocation into the cache */
 		INIT_LIST_HEAD(&amp;new_leaf-&gt;msg_list);
 		info-&gt;node_cache = new_leaf;
<span class="p_del">-		info-&gt;qsize += sizeof(*new_leaf);</span>
 	} else {
 		kfree(new_leaf);
 	}
<span class="p_header">diff --git a/ipc/sem.c b/ipc/sem.c</span>
<span class="p_header">index 454f6c6020a8..0e6504c9e907 100644</span>
<span class="p_header">--- a/ipc/sem.c</span>
<span class="p_header">+++ b/ipc/sem.c</span>
<span class="p_chunk">@@ -253,6 +253,16 @@</span> <span class="p_context"> static void sem_rcu_free(struct rcu_head *head)</span>
 }
 
 /*
<span class="p_add">+ * spin_unlock_wait() and !spin_is_locked() are not memory barriers, they</span>
<span class="p_add">+ * are only control barriers.</span>
<span class="p_add">+ * The code must pair with spin_unlock(&amp;sem-&gt;lock) or</span>
<span class="p_add">+ * spin_unlock(&amp;sem_perm.lock), thus just the control barrier is insufficient.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * smp_rmb() is sufficient, as writes cannot pass the control barrier.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define ipc_smp_acquire__after_spin_is_unlocked()	smp_rmb()</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Wait until all currently ongoing simple ops have completed.
  * Caller must own sem_perm.lock.
  * New simple ops cannot start, because simple ops first check
<span class="p_chunk">@@ -275,6 +285,7 @@</span> <span class="p_context"> static void sem_wait_array(struct sem_array *sma)</span>
 		sem = sma-&gt;sem_base + i;
 		spin_unlock_wait(&amp;sem-&gt;lock);
 	}
<span class="p_add">+	ipc_smp_acquire__after_spin_is_unlocked();</span>
 }
 
 /*
<span class="p_chunk">@@ -326,10 +337,16 @@</span> <span class="p_context"> static inline int sem_lock(struct sem_array *sma, struct sembuf *sops,</span>
 
 		/* Then check that the global lock is free */
 		if (!spin_is_locked(&amp;sma-&gt;sem_perm.lock)) {
<span class="p_del">-			/* spin_is_locked() is not a memory barrier */</span>
<span class="p_del">-			smp_mb();</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * We need a memory barrier with acquire semantics,</span>
<span class="p_add">+			 * otherwise we can race with another thread that does:</span>
<span class="p_add">+			 *	complex_count++;</span>
<span class="p_add">+			 *	spin_unlock(sem_perm.lock);</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			ipc_smp_acquire__after_spin_is_unlocked();</span>
 
<span class="p_del">-			/* Now repeat the test of complex_count:</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Now repeat the test of complex_count:</span>
 			 * It can&#39;t change anymore until we drop sem-&gt;lock.
 			 * Thus: if is now 0, then it will stay 0.
 			 */
<span class="p_chunk">@@ -2066,17 +2083,28 @@</span> <span class="p_context"> void exit_sem(struct task_struct *tsk)</span>
 		rcu_read_lock();
 		un = list_entry_rcu(ulp-&gt;list_proc.next,
 				    struct sem_undo, list_proc);
<span class="p_del">-		if (&amp;un-&gt;list_proc == &amp;ulp-&gt;list_proc)</span>
<span class="p_del">-			semid = -1;</span>
<span class="p_del">-		 else</span>
<span class="p_del">-			semid = un-&gt;semid;</span>
<span class="p_add">+		if (&amp;un-&gt;list_proc == &amp;ulp-&gt;list_proc) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * We must wait for freeary() before freeing this ulp,</span>
<span class="p_add">+			 * in case we raced with last sem_undo. There is a small</span>
<span class="p_add">+			 * possibility where we exit while freeary() didn&#39;t</span>
<span class="p_add">+			 * finish unlocking sem_undo_list.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			spin_unlock_wait(&amp;ulp-&gt;lock);</span>
<span class="p_add">+			rcu_read_unlock();</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		spin_lock(&amp;ulp-&gt;lock);</span>
<span class="p_add">+		semid = un-&gt;semid;</span>
<span class="p_add">+		spin_unlock(&amp;ulp-&gt;lock);</span>
 
<span class="p_add">+		/* exit_sem raced with IPC_RMID, nothing to do */</span>
 		if (semid == -1) {
 			rcu_read_unlock();
<span class="p_del">-			break;</span>
<span class="p_add">+			continue;</span>
 		}
 
<span class="p_del">-		sma = sem_obtain_object_check(tsk-&gt;nsproxy-&gt;ipc_ns, un-&gt;semid);</span>
<span class="p_add">+		sma = sem_obtain_object_check(tsk-&gt;nsproxy-&gt;ipc_ns, semid);</span>
 		/* exit_sem raced with IPC_RMID, nothing to do */
 		if (IS_ERR(sma)) {
 			rcu_read_unlock();
<span class="p_header">diff --git a/kernel/cgroup.c b/kernel/cgroup.c</span>
<span class="p_header">index 0a46b2aa9dfb..44fadfb287bf 100644</span>
<span class="p_header">--- a/kernel/cgroup.c</span>
<span class="p_header">+++ b/kernel/cgroup.c</span>
<span class="p_chunk">@@ -1848,8 +1848,6 @@</span> <span class="p_context"> static struct file_system_type cgroup_fs_type = {</span>
 	.kill_sb = cgroup_kill_sb,
 };
 
<span class="p_del">-static struct kobject *cgroup_kobj;</span>
<span class="p_del">-</span>
 /**
  * task_cgroup_path - cgroup path of a task in the first cgroup hierarchy
  * @task: target task
<span class="p_chunk">@@ -4822,13 +4820,13 @@</span> <span class="p_context"> int __init cgroup_init(void)</span>
 		}
 	}
 
<span class="p_del">-	cgroup_kobj = kobject_create_and_add(&quot;cgroup&quot;, fs_kobj);</span>
<span class="p_del">-	if (!cgroup_kobj)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+	err = sysfs_create_mount_point(fs_kobj, &quot;cgroup&quot;);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
 
 	err = register_filesystem(&amp;cgroup_fs_type);
 	if (err &lt; 0) {
<span class="p_del">-		kobject_put(cgroup_kobj);</span>
<span class="p_add">+		sysfs_remove_mount_point(fs_kobj, &quot;cgroup&quot;);</span>
 		return err;
 	}
 
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index 40338799dcb0..b9305281ede8 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -3616,28 +3616,21 @@</span> <span class="p_context"> static void perf_event_for_each(struct perf_event *event,</span>
 	mutex_unlock(&amp;ctx-&gt;mutex);
 }
 
<span class="p_del">-static int perf_event_period(struct perf_event *event, u64 __user *arg)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct perf_event_context *ctx = event-&gt;ctx;</span>
<span class="p_del">-	int ret = 0, active;</span>
<span class="p_add">+struct period_event {</span>
<span class="p_add">+	struct perf_event *event;</span>
 	u64 value;
<span class="p_add">+};</span>
 
<span class="p_del">-	if (!is_sampling_event(event))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (copy_from_user(&amp;value, arg, sizeof(value)))</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!value)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+static int __perf_event_period(void *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct period_event *pe = info;</span>
<span class="p_add">+	struct perf_event *event = pe-&gt;event;</span>
<span class="p_add">+	struct perf_event_context *ctx = event-&gt;ctx;</span>
<span class="p_add">+	u64 value = pe-&gt;value;</span>
<span class="p_add">+	bool active;</span>
 
<span class="p_del">-	raw_spin_lock_irq(&amp;ctx-&gt;lock);</span>
<span class="p_add">+	raw_spin_lock(&amp;ctx-&gt;lock);</span>
 	if (event-&gt;attr.freq) {
<span class="p_del">-		if (value &gt; sysctl_perf_event_sample_rate) {</span>
<span class="p_del">-			ret = -EINVAL;</span>
<span class="p_del">-			goto unlock;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
 		event-&gt;attr.sample_freq = value;
 	} else {
 		event-&gt;attr.sample_period = value;
<span class="p_chunk">@@ -3656,11 +3649,53 @@</span> <span class="p_context"> static int perf_event_period(struct perf_event *event, u64 __user *arg)</span>
 		event-&gt;pmu-&gt;start(event, PERF_EF_RELOAD);
 		perf_pmu_enable(ctx-&gt;pmu);
 	}
<span class="p_add">+	raw_spin_unlock(&amp;ctx-&gt;lock);</span>
 
<span class="p_del">-unlock:</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int perf_event_period(struct perf_event *event, u64 __user *arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct period_event pe = { .event = event, };</span>
<span class="p_add">+	struct perf_event_context *ctx = event-&gt;ctx;</span>
<span class="p_add">+	struct task_struct *task;</span>
<span class="p_add">+	u64 value;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!is_sampling_event(event))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (copy_from_user(&amp;value, arg, sizeof(value)))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!value)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (event-&gt;attr.freq &amp;&amp; value &gt; sysctl_perf_event_sample_rate)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	task = ctx-&gt;task;</span>
<span class="p_add">+	pe.value = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!task) {</span>
<span class="p_add">+		cpu_function_call(event-&gt;cpu, __perf_event_period, &amp;pe);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+retry:</span>
<span class="p_add">+	if (!task_function_call(task, __perf_event_period, &amp;pe))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	raw_spin_lock_irq(&amp;ctx-&gt;lock);</span>
<span class="p_add">+	if (ctx-&gt;is_active) {</span>
<span class="p_add">+		raw_spin_unlock_irq(&amp;ctx-&gt;lock);</span>
<span class="p_add">+		task = ctx-&gt;task;</span>
<span class="p_add">+		goto retry;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	__perf_event_period(&amp;pe);</span>
 	raw_spin_unlock_irq(&amp;ctx-&gt;lock);
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return 0;</span>
 }
 
 static const struct file_operations perf_fops;
<span class="p_chunk">@@ -4285,12 +4320,20 @@</span> <span class="p_context"> static const struct file_operations perf_fops = {</span>
  * to user-space before waking everybody up.
  */
 
<span class="p_add">+static inline struct fasync_struct **perf_event_fasync(struct perf_event *event)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* only the parent has fasync state */</span>
<span class="p_add">+	if (event-&gt;parent)</span>
<span class="p_add">+		event = event-&gt;parent;</span>
<span class="p_add">+	return &amp;event-&gt;fasync;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void perf_event_wakeup(struct perf_event *event)
 {
 	ring_buffer_wakeup(event);
 
 	if (event-&gt;pending_kill) {
<span class="p_del">-		kill_fasync(&amp;event-&gt;fasync, SIGIO, event-&gt;pending_kill);</span>
<span class="p_add">+		kill_fasync(perf_event_fasync(event), SIGIO, event-&gt;pending_kill);</span>
 		event-&gt;pending_kill = 0;
 	}
 }
<span class="p_chunk">@@ -5519,7 +5562,7 @@</span> <span class="p_context"> static int __perf_event_overflow(struct perf_event *event,</span>
 	else
 		perf_event_output(event, data, regs);
 
<span class="p_del">-	if (event-&gt;fasync &amp;&amp; event-&gt;pending_kill) {</span>
<span class="p_add">+	if (*perf_event_fasync(event) &amp;&amp; event-&gt;pending_kill) {</span>
 		event-&gt;pending_wakeup = 1;
 		irq_work_queue(&amp;event-&gt;pending);
 	}
<span class="p_header">diff --git a/kernel/signal.c b/kernel/signal.c</span>
<span class="p_header">index a4077e90f19f..720fad0817e4 100644</span>
<span class="p_header">--- a/kernel/signal.c</span>
<span class="p_header">+++ b/kernel/signal.c</span>
<span class="p_chunk">@@ -2745,7 +2745,8 @@</span> <span class="p_context"> int copy_siginfo_to_user(siginfo_t __user *to, const siginfo_t *from)</span>
 		 * Other callers might not initialize the si_lsb field,
 		 * so check explicitly for the right codes here.
 		 */
<span class="p_del">-		if (from-&gt;si_code == BUS_MCEERR_AR || from-&gt;si_code == BUS_MCEERR_AO)</span>
<span class="p_add">+		if (from-&gt;si_signo == SIGBUS &amp;&amp;</span>
<span class="p_add">+		    (from-&gt;si_code == BUS_MCEERR_AR || from-&gt;si_code == BUS_MCEERR_AO))</span>
 			err |= __put_user(from-&gt;si_addr_lsb, &amp;to-&gt;si_addr_lsb);
 #endif
 		break;
<span class="p_chunk">@@ -3012,7 +3013,7 @@</span> <span class="p_context"> COMPAT_SYSCALL_DEFINE3(rt_sigqueueinfo,</span>
 			int, sig,
 			struct compat_siginfo __user *, uinfo)
 {
<span class="p_del">-	siginfo_t info;</span>
<span class="p_add">+	siginfo_t info = {};</span>
 	int ret = copy_siginfo_from_user32(&amp;info, uinfo);
 	if (unlikely(ret))
 		return ret;
<span class="p_chunk">@@ -3058,7 +3059,7 @@</span> <span class="p_context"> COMPAT_SYSCALL_DEFINE4(rt_tgsigqueueinfo,</span>
 			int, sig,
 			struct compat_siginfo __user *, uinfo)
 {
<span class="p_del">-	siginfo_t info;</span>
<span class="p_add">+	siginfo_t info = {};</span>
 
 	if (copy_siginfo_from_user32(&amp;info, uinfo))
 		return -EFAULT;
<span class="p_header">diff --git a/mm/memory-failure.c b/mm/memory-failure.c</span>
<span class="p_header">index fad245565616..3fd99140bd6c 100644</span>
<span class="p_header">--- a/mm/memory-failure.c</span>
<span class="p_header">+++ b/mm/memory-failure.c</span>
<span class="p_chunk">@@ -1514,6 +1514,8 @@</span> <span class="p_context"> static int get_any_page(struct page *page, unsigned long pfn, int flags)</span>
 		 */
 		ret = __get_any_page(page, pfn, 0);
 		if (!PageLRU(page)) {
<span class="p_add">+			/* Drop page reference which is from __get_any_page() */</span>
<span class="p_add">+			put_page(page);</span>
 			pr_info(&quot;soft_offline: %#lx: unknown non LRU page type %lx\n&quot;,
 				pfn, page-&gt;flags);
 			return -EIO;
<span class="p_header">diff --git a/mm/vmscan.c b/mm/vmscan.c</span>
<span class="p_header">index 4e4e0b893ca6..d75349d574a3 100644</span>
<span class="p_header">--- a/mm/vmscan.c</span>
<span class="p_header">+++ b/mm/vmscan.c</span>
<span class="p_chunk">@@ -890,21 +890,17 @@</span> <span class="p_context"> static unsigned long shrink_page_list(struct list_head *page_list,</span>
 		 *
 		 * 2) Global reclaim encounters a page, memcg encounters a
 		 *    page that is not marked for immediate reclaim or
<span class="p_del">-		 *    the caller does not have __GFP_IO. In this case mark</span>
<span class="p_add">+		 *    the caller does not have __GFP_FS (or __GFP_IO if it&#39;s</span>
<span class="p_add">+		 *    simply going to swap, not to fs). In this case mark</span>
 		 *    the page for immediate reclaim and continue scanning.
 		 *
<span class="p_del">-		 *    __GFP_IO is checked  because a loop driver thread might</span>
<span class="p_add">+		 *    Require may_enter_fs because we would wait on fs, which</span>
<span class="p_add">+		 *    may not have submitted IO yet. And the loop driver might</span>
 		 *    enter reclaim, and deadlock if it waits on a page for
 		 *    which it is needed to do the write (loop masks off
 		 *    __GFP_IO|__GFP_FS for this reason); but more thought
 		 *    would probably show more reasons.
 		 *
<span class="p_del">-		 *    Don&#39;t require __GFP_FS, since we&#39;re not going into the</span>
<span class="p_del">-		 *    FS, just waiting on its writeback completion. Worryingly,</span>
<span class="p_del">-		 *    ext4 gfs2 and xfs allocate pages with</span>
<span class="p_del">-		 *    grab_cache_page_write_begin(,,AOP_FLAG_NOFS), so testing</span>
<span class="p_del">-		 *    may_enter_fs here is liable to OOM on them.</span>
<span class="p_del">-		 *</span>
 		 * 3) memcg encounters a page that is not already marked
 		 *    PageReclaim. memcg does not have any dirty pages
 		 *    throttling so we could easily OOM just because too many
<span class="p_chunk">@@ -921,7 +917,7 @@</span> <span class="p_context"> static unsigned long shrink_page_list(struct list_head *page_list,</span>
 
 			/* Case 2 above */
 			} else if (global_reclaim(sc) ||
<span class="p_del">-			    !PageReclaim(page) || !(sc-&gt;gfp_mask &amp; __GFP_IO)) {</span>
<span class="p_add">+			    !PageReclaim(page) || !may_enter_fs) {</span>
 				/*
 				 * This is slightly racy - end_page_writeback()
 				 * might have just cleared PageReclaim, then
<span class="p_header">diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c</span>
<span class="p_header">index cbd677f48c00..713498c378c7 100644</span>
<span class="p_header">--- a/net/batman-adv/soft-interface.c</span>
<span class="p_header">+++ b/net/batman-adv/soft-interface.c</span>
<span class="p_chunk">@@ -450,6 +450,9 @@</span> <span class="p_context"> out:</span>
  */
 void batadv_softif_vlan_free_ref(struct batadv_softif_vlan *vlan)
 {
<span class="p_add">+	if (!vlan)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	if (atomic_dec_and_test(&amp;vlan-&gt;refcount)) {
 		spin_lock_bh(&amp;vlan-&gt;bat_priv-&gt;softif_vlan_list_lock);
 		hlist_del_rcu(&amp;vlan-&gt;list);
<span class="p_header">diff --git a/net/batman-adv/translation-table.c b/net/batman-adv/translation-table.c</span>
<span class="p_header">index 5f59e7f899a0..4503069e29b5 100644</span>
<span class="p_header">--- a/net/batman-adv/translation-table.c</span>
<span class="p_header">+++ b/net/batman-adv/translation-table.c</span>
<span class="p_chunk">@@ -575,6 +575,9 @@</span> <span class="p_context"> bool batadv_tt_local_add(struct net_device *soft_iface, const uint8_t *addr,</span>
 
 	/* increase the refcounter of the related vlan */
 	vlan = batadv_softif_vlan_get(bat_priv, vid);
<span class="p_add">+	if (WARN(!vlan, &quot;adding TT local entry %pM to non-existent VLAN %d&quot;,</span>
<span class="p_add">+		 addr, BATADV_PRINT_VID(vid)))</span>
<span class="p_add">+		goto out;</span>
 
 	batadv_dbg(BATADV_DBG_TT, bat_priv,
 		   &quot;Creating new local tt entry: %pM (vid: %d, ttvn: %d)\n&quot;,
<span class="p_chunk">@@ -1015,6 +1018,7 @@</span> <span class="p_context"> uint16_t batadv_tt_local_remove(struct batadv_priv *bat_priv,</span>
 	struct batadv_tt_local_entry *tt_local_entry;
 	uint16_t flags, curr_flags = BATADV_NO_FLAGS;
 	struct batadv_softif_vlan *vlan;
<span class="p_add">+	void *tt_entry_exists;</span>
 
 	tt_local_entry = batadv_tt_local_hash_find(bat_priv, addr, vid);
 	if (!tt_local_entry)
<span class="p_chunk">@@ -1042,11 +1046,22 @@</span> <span class="p_context"> uint16_t batadv_tt_local_remove(struct batadv_priv *bat_priv,</span>
 	 * immediately purge it
 	 */
 	batadv_tt_local_event(bat_priv, tt_local_entry, BATADV_TT_CLIENT_DEL);
<span class="p_del">-	hlist_del_rcu(&amp;tt_local_entry-&gt;common.hash_entry);</span>
<span class="p_add">+</span>
<span class="p_add">+	tt_entry_exists = batadv_hash_remove(bat_priv-&gt;tt.local_hash,</span>
<span class="p_add">+					     batadv_compare_tt,</span>
<span class="p_add">+					     batadv_choose_tt,</span>
<span class="p_add">+					     &amp;tt_local_entry-&gt;common);</span>
<span class="p_add">+	if (!tt_entry_exists)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* extra call to free the local tt entry */</span>
 	batadv_tt_local_entry_free_ref(tt_local_entry);
 
 	/* decrease the reference held for this vlan */
 	vlan = batadv_softif_vlan_get(bat_priv, vid);
<span class="p_add">+	if (!vlan)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	batadv_softif_vlan_free_ref(vlan);
 	batadv_softif_vlan_free_ref(vlan);
 
<span class="p_chunk">@@ -1147,8 +1162,10 @@</span> <span class="p_context"> static void batadv_tt_local_table_free(struct batadv_priv *bat_priv)</span>
 			/* decrease the reference held for this vlan */
 			vlan = batadv_softif_vlan_get(bat_priv,
 						      tt_common_entry-&gt;vid);
<span class="p_del">-			batadv_softif_vlan_free_ref(vlan);</span>
<span class="p_del">-			batadv_softif_vlan_free_ref(vlan);</span>
<span class="p_add">+			if (vlan) {</span>
<span class="p_add">+				batadv_softif_vlan_free_ref(vlan);</span>
<span class="p_add">+				batadv_softif_vlan_free_ref(vlan);</span>
<span class="p_add">+			}</span>
 
 			batadv_tt_local_entry_free_ref(tt_local);
 		}
<span class="p_chunk">@@ -3190,8 +3207,10 @@</span> <span class="p_context"> static void batadv_tt_local_purge_pending_clients(struct batadv_priv *bat_priv)</span>
 
 			/* decrease the reference held for this vlan */
 			vlan = batadv_softif_vlan_get(bat_priv, tt_common-&gt;vid);
<span class="p_del">-			batadv_softif_vlan_free_ref(vlan);</span>
<span class="p_del">-			batadv_softif_vlan_free_ref(vlan);</span>
<span class="p_add">+			if (vlan) {</span>
<span class="p_add">+				batadv_softif_vlan_free_ref(vlan);</span>
<span class="p_add">+				batadv_softif_vlan_free_ref(vlan);</span>
<span class="p_add">+			}</span>
 
 			batadv_tt_local_entry_free_ref(tt_local);
 		}
<span class="p_header">diff --git a/net/bridge/br_mdb.c b/net/bridge/br_mdb.c</span>
<span class="p_header">index f426da78054b..568c441e4212 100644</span>
<span class="p_header">--- a/net/bridge/br_mdb.c</span>
<span class="p_header">+++ b/net/bridge/br_mdb.c</span>
<span class="p_chunk">@@ -451,6 +451,7 @@</span> <span class="p_context"> static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)</span>
 		if (p-&gt;port-&gt;state == BR_STATE_DISABLED)
 			goto unlock;
 
<span class="p_add">+		entry-&gt;state = p-&gt;state;</span>
 		rcu_assign_pointer(*pp, p-&gt;next);
 		hlist_del_init(&amp;p-&gt;mglist);
 		del_timer(&amp;p-&gt;timer);
<span class="p_header">diff --git a/net/core/datagram.c b/net/core/datagram.c</span>
<span class="p_header">index 488dd1a825c0..3c69a464595e 100644</span>
<span class="p_header">--- a/net/core/datagram.c</span>
<span class="p_header">+++ b/net/core/datagram.c</span>
<span class="p_chunk">@@ -130,6 +130,35 @@</span> <span class="p_context"> out_noerr:</span>
 	goto out;
 }
 
<span class="p_add">+static struct sk_buff *skb_set_peeked(struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sk_buff *nskb;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (skb-&gt;peeked)</span>
<span class="p_add">+		return skb;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We have to unshare an skb before modifying it. */</span>
<span class="p_add">+	if (!skb_shared(skb))</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+</span>
<span class="p_add">+	nskb = skb_clone(skb, GFP_ATOMIC);</span>
<span class="p_add">+	if (!nskb)</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+</span>
<span class="p_add">+	skb-&gt;prev-&gt;next = nskb;</span>
<span class="p_add">+	skb-&gt;next-&gt;prev = nskb;</span>
<span class="p_add">+	nskb-&gt;prev = skb-&gt;prev;</span>
<span class="p_add">+	nskb-&gt;next = skb-&gt;next;</span>
<span class="p_add">+</span>
<span class="p_add">+	consume_skb(skb);</span>
<span class="p_add">+	skb = nskb;</span>
<span class="p_add">+</span>
<span class="p_add">+done:</span>
<span class="p_add">+	skb-&gt;peeked = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	return skb;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  *	__skb_recv_datagram - Receive a datagram skbuff
  *	@sk: socket
<span class="p_chunk">@@ -164,7 +193,9 @@</span> <span class="p_context"> out_noerr:</span>
 struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,
 				    int *peeked, int *off, int *err)
 {
<span class="p_add">+	struct sk_buff_head *queue = &amp;sk-&gt;sk_receive_queue;</span>
 	struct sk_buff *skb, *last;
<span class="p_add">+	unsigned long cpu_flags;</span>
 	long timeo;
 	/*
 	 * Caller is allowed not to check sk-&gt;sk_err before skb_recv_datagram()
<span class="p_chunk">@@ -183,8 +214,6 @@</span> <span class="p_context"> struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,</span>
 		 * Look at current nfs client by the way...
 		 * However, this function was correct in any case. 8)
 		 */
<span class="p_del">-		unsigned long cpu_flags;</span>
<span class="p_del">-		struct sk_buff_head *queue = &amp;sk-&gt;sk_receive_queue;</span>
 		int _off = *off;
 
 		last = (struct sk_buff *)queue;
<span class="p_chunk">@@ -198,7 +227,12 @@</span> <span class="p_context"> struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,</span>
 					_off -= skb-&gt;len;
 					continue;
 				}
<span class="p_del">-				skb-&gt;peeked = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+				skb = skb_set_peeked(skb);</span>
<span class="p_add">+				error = PTR_ERR(skb);</span>
<span class="p_add">+				if (IS_ERR(skb))</span>
<span class="p_add">+					goto unlock_err;</span>
<span class="p_add">+</span>
 				atomic_inc(&amp;skb-&gt;users);
 			} else
 				__skb_unlink(skb, queue);
<span class="p_chunk">@@ -222,6 +256,8 @@</span> <span class="p_context"> struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,</span>
 
 	return NULL;
 
<span class="p_add">+unlock_err:</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;queue-&gt;lock, cpu_flags);</span>
 no_packet:
 	*err = error;
 	return NULL;
<span class="p_chunk">@@ -744,7 +780,8 @@</span> <span class="p_context"> __sum16 __skb_checksum_complete_head(struct sk_buff *skb, int len)</span>
 		    !skb-&gt;csum_complete_sw)
 			netdev_rx_csum_fault(skb-&gt;dev);
 	}
<span class="p_del">-	skb-&gt;csum_valid = !sum;</span>
<span class="p_add">+	if (!skb_shared(skb))</span>
<span class="p_add">+		skb-&gt;csum_valid = !sum;</span>
 	return sum;
 }
 EXPORT_SYMBOL(__skb_checksum_complete_head);
<span class="p_chunk">@@ -764,11 +801,13 @@</span> <span class="p_context"> __sum16 __skb_checksum_complete(struct sk_buff *skb)</span>
 			netdev_rx_csum_fault(skb-&gt;dev);
 	}
 
<span class="p_del">-	/* Save full packet checksum */</span>
<span class="p_del">-	skb-&gt;csum = csum;</span>
<span class="p_del">-	skb-&gt;ip_summed = CHECKSUM_COMPLETE;</span>
<span class="p_del">-	skb-&gt;csum_complete_sw = 1;</span>
<span class="p_del">-	skb-&gt;csum_valid = !sum;</span>
<span class="p_add">+	if (!skb_shared(skb)) {</span>
<span class="p_add">+		/* Save full packet checksum */</span>
<span class="p_add">+		skb-&gt;csum = csum;</span>
<span class="p_add">+		skb-&gt;ip_summed = CHECKSUM_COMPLETE;</span>
<span class="p_add">+		skb-&gt;csum_complete_sw = 1;</span>
<span class="p_add">+		skb-&gt;csum_valid = !sum;</span>
<span class="p_add">+	}</span>
 
 	return sum;
 }
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index 395830206d73..e12823e68bb0 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -3594,8 +3594,6 @@</span> <span class="p_context"> static int __netif_receive_skb_core(struct sk_buff *skb, bool pfmemalloc)</span>
 
 	pt_prev = NULL;
 
<span class="p_del">-	rcu_read_lock();</span>
<span class="p_del">-</span>
 another_round:
 	skb-&gt;skb_iif = skb-&gt;dev-&gt;ifindex;
 
<span class="p_chunk">@@ -3605,7 +3603,7 @@</span> <span class="p_context"> another_round:</span>
 	    skb-&gt;protocol == cpu_to_be16(ETH_P_8021AD)) {
 		skb = skb_vlan_untag(skb);
 		if (unlikely(!skb))
<span class="p_del">-			goto unlock;</span>
<span class="p_add">+			goto out;</span>
 	}
 
 #ifdef CONFIG_NET_CLS_ACT
<span class="p_chunk">@@ -3630,7 +3628,7 @@</span> <span class="p_context"> skip_taps:</span>
 #ifdef CONFIG_NET_CLS_ACT
 	skb = handle_ing(skb, &amp;pt_prev, &amp;ret, orig_dev);
 	if (!skb)
<span class="p_del">-		goto unlock;</span>
<span class="p_add">+		goto out;</span>
 ncls:
 #endif
 
<span class="p_chunk">@@ -3645,7 +3643,7 @@</span> <span class="p_context"> ncls:</span>
 		if (vlan_do_receive(&amp;skb))
 			goto another_round;
 		else if (unlikely(!skb))
<span class="p_del">-			goto unlock;</span>
<span class="p_add">+			goto out;</span>
 	}
 
 	rx_handler = rcu_dereference(skb-&gt;dev-&gt;rx_handler);
<span class="p_chunk">@@ -3657,7 +3655,7 @@</span> <span class="p_context"> ncls:</span>
 		switch (rx_handler(&amp;skb)) {
 		case RX_HANDLER_CONSUMED:
 			ret = NET_RX_SUCCESS;
<span class="p_del">-			goto unlock;</span>
<span class="p_add">+			goto out;</span>
 		case RX_HANDLER_ANOTHER:
 			goto another_round;
 		case RX_HANDLER_EXACT:
<span class="p_chunk">@@ -3709,8 +3707,7 @@</span> <span class="p_context"> drop:</span>
 		ret = NET_RX_DROP;
 	}
 
<span class="p_del">-unlock:</span>
<span class="p_del">-	rcu_read_unlock();</span>
<span class="p_add">+out:</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -3741,29 +3738,30 @@</span> <span class="p_context"> static int __netif_receive_skb(struct sk_buff *skb)</span>
 
 static int netif_receive_skb_internal(struct sk_buff *skb)
 {
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
 	net_timestamp_check(netdev_tstamp_prequeue, skb);
 
 	if (skb_defer_rx_timestamp(skb))
 		return NET_RX_SUCCESS;
 
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+</span>
 #ifdef CONFIG_RPS
 	if (static_key_false(&amp;rps_needed)) {
 		struct rps_dev_flow voidflow, *rflow = &amp;voidflow;
<span class="p_del">-		int cpu, ret;</span>
<span class="p_del">-</span>
<span class="p_del">-		rcu_read_lock();</span>
<span class="p_del">-</span>
<span class="p_del">-		cpu = get_rps_cpu(skb-&gt;dev, skb, &amp;rflow);</span>
<span class="p_add">+		int cpu = get_rps_cpu(skb-&gt;dev, skb, &amp;rflow);</span>
 
 		if (cpu &gt;= 0) {
 			ret = enqueue_to_backlog(skb, cpu, &amp;rflow-&gt;last_qtail);
 			rcu_read_unlock();
 			return ret;
 		}
<span class="p_del">-		rcu_read_unlock();</span>
 	}
 #endif
<span class="p_del">-	return __netif_receive_skb(skb);</span>
<span class="p_add">+	ret = __netif_receive_skb(skb);</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+	return ret;</span>
 }
 
 /**
<span class="p_chunk">@@ -4255,8 +4253,10 @@</span> <span class="p_context"> static int process_backlog(struct napi_struct *napi, int quota)</span>
 		struct sk_buff *skb;
 
 		while ((skb = __skb_dequeue(&amp;sd-&gt;process_queue))) {
<span class="p_add">+			rcu_read_lock();</span>
 			local_irq_enable();
 			__netif_receive_skb(skb);
<span class="p_add">+			rcu_read_unlock();</span>
 			local_irq_disable();
 			input_queue_head_incr(sd);
 			if (++work &gt;= quota) {
<span class="p_header">diff --git a/net/core/pktgen.c b/net/core/pktgen.c</span>
<span class="p_header">index 0e5719c20d61..0234ae038a62 100644</span>
<span class="p_header">--- a/net/core/pktgen.c</span>
<span class="p_header">+++ b/net/core/pktgen.c</span>
<span class="p_chunk">@@ -3470,8 +3470,10 @@</span> <span class="p_context"> static int pktgen_thread_worker(void *arg)</span>
 	pktgen_rem_thread(t);
 
 	/* Wait for kthread_stop */
<span class="p_del">-	while (!kthread_should_stop()) {</span>
<span class="p_add">+	for (;;) {</span>
 		set_current_state(TASK_INTERRUPTIBLE);
<span class="p_add">+		if (kthread_should_stop())</span>
<span class="p_add">+			break;</span>
 		schedule();
 	}
 	__set_current_state(TASK_RUNNING);
<span class="p_header">diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c</span>
<span class="p_header">index 0d2119ff2875..147c63784052 100644</span>
<span class="p_header">--- a/net/core/rtnetlink.c</span>
<span class="p_header">+++ b/net/core/rtnetlink.c</span>
<span class="p_chunk">@@ -1202,10 +1202,6 @@</span> <span class="p_context"> static const struct nla_policy ifla_info_policy[IFLA_INFO_MAX+1] = {</span>
 	[IFLA_INFO_SLAVE_DATA]	= { .type = NLA_NESTED },
 };
 
<span class="p_del">-static const struct nla_policy ifla_vfinfo_policy[IFLA_VF_INFO_MAX+1] = {</span>
<span class="p_del">-	[IFLA_VF_INFO]		= { .type = NLA_NESTED },</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 static const struct nla_policy ifla_vf_policy[IFLA_VF_MAX+1] = {
 	[IFLA_VF_MAC]		= { .len = sizeof(struct ifla_vf_mac) },
 	[IFLA_VF_VLAN]		= { .len = sizeof(struct ifla_vf_vlan) },
<span class="p_chunk">@@ -1353,85 +1349,86 @@</span> <span class="p_context"> static int validate_linkmsg(struct net_device *dev, struct nlattr *tb[])</span>
 	return 0;
 }
 
<span class="p_del">-static int do_setvfinfo(struct net_device *dev, struct nlattr *attr)</span>
<span class="p_add">+static int do_setvfinfo(struct net_device *dev, struct nlattr **tb)</span>
 {
<span class="p_del">-	int rem, err = -EINVAL;</span>
<span class="p_del">-	struct nlattr *vf;</span>
 	const struct net_device_ops *ops = dev-&gt;netdev_ops;
<span class="p_add">+	int err = -EINVAL;</span>
 
<span class="p_del">-	nla_for_each_nested(vf, attr, rem) {</span>
<span class="p_del">-		switch (nla_type(vf)) {</span>
<span class="p_del">-		case IFLA_VF_MAC: {</span>
<span class="p_del">-			struct ifla_vf_mac *ivm;</span>
<span class="p_del">-			ivm = nla_data(vf);</span>
<span class="p_del">-			err = -EOPNOTSUPP;</span>
<span class="p_del">-			if (ops-&gt;ndo_set_vf_mac)</span>
<span class="p_del">-				err = ops-&gt;ndo_set_vf_mac(dev, ivm-&gt;vf,</span>
<span class="p_del">-							  ivm-&gt;mac);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		case IFLA_VF_VLAN: {</span>
<span class="p_del">-			struct ifla_vf_vlan *ivv;</span>
<span class="p_del">-			ivv = nla_data(vf);</span>
<span class="p_del">-			err = -EOPNOTSUPP;</span>
<span class="p_del">-			if (ops-&gt;ndo_set_vf_vlan)</span>
<span class="p_del">-				err = ops-&gt;ndo_set_vf_vlan(dev, ivv-&gt;vf,</span>
<span class="p_del">-							   ivv-&gt;vlan,</span>
<span class="p_del">-							   ivv-&gt;qos);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		case IFLA_VF_TX_RATE: {</span>
<span class="p_del">-			struct ifla_vf_tx_rate *ivt;</span>
<span class="p_del">-			struct ifla_vf_info ivf;</span>
<span class="p_del">-			ivt = nla_data(vf);</span>
<span class="p_del">-			err = -EOPNOTSUPP;</span>
<span class="p_del">-			if (ops-&gt;ndo_get_vf_config)</span>
<span class="p_del">-				err = ops-&gt;ndo_get_vf_config(dev, ivt-&gt;vf,</span>
<span class="p_del">-							     &amp;ivf);</span>
<span class="p_del">-			if (err)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			err = -EOPNOTSUPP;</span>
<span class="p_del">-			if (ops-&gt;ndo_set_vf_rate)</span>
<span class="p_del">-				err = ops-&gt;ndo_set_vf_rate(dev, ivt-&gt;vf,</span>
<span class="p_del">-							   ivf.min_tx_rate,</span>
<span class="p_del">-							   ivt-&gt;rate);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		case IFLA_VF_RATE: {</span>
<span class="p_del">-			struct ifla_vf_rate *ivt;</span>
<span class="p_del">-			ivt = nla_data(vf);</span>
<span class="p_del">-			err = -EOPNOTSUPP;</span>
<span class="p_del">-			if (ops-&gt;ndo_set_vf_rate)</span>
<span class="p_del">-				err = ops-&gt;ndo_set_vf_rate(dev, ivt-&gt;vf,</span>
<span class="p_del">-							   ivt-&gt;min_tx_rate,</span>
<span class="p_del">-							   ivt-&gt;max_tx_rate);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		case IFLA_VF_SPOOFCHK: {</span>
<span class="p_del">-			struct ifla_vf_spoofchk *ivs;</span>
<span class="p_del">-			ivs = nla_data(vf);</span>
<span class="p_del">-			err = -EOPNOTSUPP;</span>
<span class="p_del">-			if (ops-&gt;ndo_set_vf_spoofchk)</span>
<span class="p_del">-				err = ops-&gt;ndo_set_vf_spoofchk(dev, ivs-&gt;vf,</span>
<span class="p_del">-							       ivs-&gt;setting);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		case IFLA_VF_LINK_STATE: {</span>
<span class="p_del">-			struct ifla_vf_link_state *ivl;</span>
<span class="p_del">-			ivl = nla_data(vf);</span>
<span class="p_del">-			err = -EOPNOTSUPP;</span>
<span class="p_del">-			if (ops-&gt;ndo_set_vf_link_state)</span>
<span class="p_del">-				err = ops-&gt;ndo_set_vf_link_state(dev, ivl-&gt;vf,</span>
<span class="p_del">-								 ivl-&gt;link_state);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		default:</span>
<span class="p_del">-			err = -EINVAL;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (err)</span>
<span class="p_del">-			break;</span>
<span class="p_add">+	if (tb[IFLA_VF_MAC]) {</span>
<span class="p_add">+		struct ifla_vf_mac *ivm = nla_data(tb[IFLA_VF_MAC]);</span>
<span class="p_add">+</span>
<span class="p_add">+		err = -EOPNOTSUPP;</span>
<span class="p_add">+		if (ops-&gt;ndo_set_vf_mac)</span>
<span class="p_add">+			err = ops-&gt;ndo_set_vf_mac(dev, ivm-&gt;vf,</span>
<span class="p_add">+						  ivm-&gt;mac);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tb[IFLA_VF_VLAN]) {</span>
<span class="p_add">+		struct ifla_vf_vlan *ivv = nla_data(tb[IFLA_VF_VLAN]);</span>
<span class="p_add">+</span>
<span class="p_add">+		err = -EOPNOTSUPP;</span>
<span class="p_add">+		if (ops-&gt;ndo_set_vf_vlan)</span>
<span class="p_add">+			err = ops-&gt;ndo_set_vf_vlan(dev, ivv-&gt;vf, ivv-&gt;vlan,</span>
<span class="p_add">+						   ivv-&gt;qos);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tb[IFLA_VF_TX_RATE]) {</span>
<span class="p_add">+		struct ifla_vf_tx_rate *ivt = nla_data(tb[IFLA_VF_TX_RATE]);</span>
<span class="p_add">+		struct ifla_vf_info ivf;</span>
<span class="p_add">+</span>
<span class="p_add">+		err = -EOPNOTSUPP;</span>
<span class="p_add">+		if (ops-&gt;ndo_get_vf_config)</span>
<span class="p_add">+			err = ops-&gt;ndo_get_vf_config(dev, ivt-&gt;vf, &amp;ivf);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+</span>
<span class="p_add">+		err = -EOPNOTSUPP;</span>
<span class="p_add">+		if (ops-&gt;ndo_set_vf_rate)</span>
<span class="p_add">+			err = ops-&gt;ndo_set_vf_rate(dev, ivt-&gt;vf,</span>
<span class="p_add">+						   ivf.min_tx_rate,</span>
<span class="p_add">+						   ivt-&gt;rate);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			return err;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (tb[IFLA_VF_RATE]) {</span>
<span class="p_add">+		struct ifla_vf_rate *ivt = nla_data(tb[IFLA_VF_RATE]);</span>
<span class="p_add">+</span>
<span class="p_add">+		err = -EOPNOTSUPP;</span>
<span class="p_add">+		if (ops-&gt;ndo_set_vf_rate)</span>
<span class="p_add">+			err = ops-&gt;ndo_set_vf_rate(dev, ivt-&gt;vf,</span>
<span class="p_add">+						   ivt-&gt;min_tx_rate,</span>
<span class="p_add">+						   ivt-&gt;max_tx_rate);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tb[IFLA_VF_SPOOFCHK]) {</span>
<span class="p_add">+		struct ifla_vf_spoofchk *ivs = nla_data(tb[IFLA_VF_SPOOFCHK]);</span>
<span class="p_add">+</span>
<span class="p_add">+		err = -EOPNOTSUPP;</span>
<span class="p_add">+		if (ops-&gt;ndo_set_vf_spoofchk)</span>
<span class="p_add">+			err = ops-&gt;ndo_set_vf_spoofchk(dev, ivs-&gt;vf,</span>
<span class="p_add">+						       ivs-&gt;setting);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tb[IFLA_VF_LINK_STATE]) {</span>
<span class="p_add">+		struct ifla_vf_link_state *ivl = nla_data(tb[IFLA_VF_LINK_STATE]);</span>
<span class="p_add">+</span>
<span class="p_add">+		err = -EOPNOTSUPP;</span>
<span class="p_add">+		if (ops-&gt;ndo_set_vf_link_state)</span>
<span class="p_add">+			err = ops-&gt;ndo_set_vf_link_state(dev, ivl-&gt;vf,</span>
<span class="p_add">+							 ivl-&gt;link_state);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return err;
 }
 
<span class="p_chunk">@@ -1614,14 +1611,21 @@</span> <span class="p_context"> static int do_setlink(const struct sk_buff *skb,</span>
 	}
 
 	if (tb[IFLA_VFINFO_LIST]) {
<span class="p_add">+		struct nlattr *vfinfo[IFLA_VF_MAX + 1];</span>
 		struct nlattr *attr;
 		int rem;
<span class="p_add">+</span>
 		nla_for_each_nested(attr, tb[IFLA_VFINFO_LIST], rem) {
<span class="p_del">-			if (nla_type(attr) != IFLA_VF_INFO) {</span>
<span class="p_add">+			if (nla_type(attr) != IFLA_VF_INFO ||</span>
<span class="p_add">+			    nla_len(attr) &lt; NLA_HDRLEN) {</span>
 				err = -EINVAL;
 				goto errout;
 			}
<span class="p_del">-			err = do_setvfinfo(dev, attr);</span>
<span class="p_add">+			err = nla_parse_nested(vfinfo, IFLA_VF_MAX, attr,</span>
<span class="p_add">+					       ifla_vf_policy);</span>
<span class="p_add">+			if (err &lt; 0)</span>
<span class="p_add">+				goto errout;</span>
<span class="p_add">+			err = do_setvfinfo(dev, vfinfo);</span>
 			if (err &lt; 0)
 				goto errout;
 			modified = 1;
<span class="p_header">diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c</span>
<span class="p_header">index 13fa803ff549..6ebb8f6235c9 100644</span>
<span class="p_header">--- a/net/ipv4/af_inet.c</span>
<span class="p_header">+++ b/net/ipv4/af_inet.c</span>
<span class="p_chunk">@@ -1286,7 +1286,7 @@</span> <span class="p_context"> static struct sk_buff *inet_gso_segment(struct sk_buff *skb,</span>
 
 	encap = SKB_GSO_CB(skb)-&gt;encap_level &gt; 0;
 	if (encap)
<span class="p_del">-		features = skb-&gt;dev-&gt;hw_enc_features &amp; netif_skb_features(skb);</span>
<span class="p_add">+		features &amp;= skb-&gt;dev-&gt;hw_enc_features;</span>
 	SKB_GSO_CB(skb)-&gt;encap_level += ihl;
 
 	skb_reset_transport_header(skb);
<span class="p_header">diff --git a/net/ipv4/datagram.c b/net/ipv4/datagram.c</span>
<span class="p_header">index a3095fdefbed..f0c307cb6196 100644</span>
<span class="p_header">--- a/net/ipv4/datagram.c</span>
<span class="p_header">+++ b/net/ipv4/datagram.c</span>
<span class="p_chunk">@@ -20,7 +20,7 @@</span> <span class="p_context"></span>
 #include &lt;net/route.h&gt;
 #include &lt;net/tcp_states.h&gt;
 
<span class="p_del">-int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
<span class="p_add">+int __ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 {
 	struct inet_sock *inet = inet_sk(sk);
 	struct sockaddr_in *usin = (struct sockaddr_in *) uaddr;
<span class="p_chunk">@@ -39,8 +39,6 @@</span> <span class="p_context"> int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 
 	sk_dst_reset(sk);
 
<span class="p_del">-	lock_sock(sk);</span>
<span class="p_del">-</span>
 	oif = sk-&gt;sk_bound_dev_if;
 	saddr = inet-&gt;inet_saddr;
 	if (ipv4_is_multicast(usin-&gt;sin_addr.s_addr)) {
<span class="p_chunk">@@ -81,9 +79,19 @@</span> <span class="p_context"> int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 	sk_dst_set(sk, &amp;rt-&gt;dst);
 	err = 0;
 out:
<span class="p_del">-	release_sock(sk);</span>
 	return err;
 }
<span class="p_add">+EXPORT_SYMBOL(__ip4_datagram_connect);</span>
<span class="p_add">+</span>
<span class="p_add">+int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int res;</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+	res = __ip4_datagram_connect(sk, uaddr, addr_len);</span>
<span class="p_add">+	release_sock(sk);</span>
<span class="p_add">+	return res;</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL(ip4_datagram_connect);
 
 /* Because UDP xmit path can manipulate sk_dst_cache without holding
<span class="p_header">diff --git a/net/ipv4/gre_offload.c b/net/ipv4/gre_offload.c</span>
<span class="p_header">index 4ae6b52751e9..d7a1f450653d 100644</span>
<span class="p_header">--- a/net/ipv4/gre_offload.c</span>
<span class="p_header">+++ b/net/ipv4/gre_offload.c</span>
<span class="p_chunk">@@ -72,7 +72,7 @@</span> <span class="p_context"> static struct sk_buff *gre_gso_segment(struct sk_buff *skb,</span>
 	skb-&gt;mac_len = skb_inner_network_offset(skb);
 
 	/* segment inner packet. */
<span class="p_del">-	enc_features = skb-&gt;dev-&gt;hw_enc_features &amp; netif_skb_features(skb);</span>
<span class="p_add">+	enc_features = skb-&gt;dev-&gt;hw_enc_features &amp; features;</span>
 	segs = skb_mac_gso_segment(skb, enc_features);
 	if (!segs || IS_ERR(segs)) {
 		skb_gso_error_unwind(skb, protocol, ghl, mac_offset, mac_len);
<span class="p_header">diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c</span>
<span class="p_header">index 4d94056ce452..10c1530ba978 100644</span>
<span class="p_header">--- a/net/ipv4/udp.c</span>
<span class="p_header">+++ b/net/ipv4/udp.c</span>
<span class="p_chunk">@@ -1988,12 +1988,19 @@</span> <span class="p_context"> void udp_v4_early_demux(struct sk_buff *skb)</span>
 
 	skb-&gt;sk = sk;
 	skb-&gt;destructor = sock_edemux;
<span class="p_del">-	dst = sk-&gt;sk_rx_dst;</span>
<span class="p_add">+	dst = ACCESS_ONCE(sk-&gt;sk_rx_dst);</span>
 
 	if (dst)
 		dst = dst_check(dst, 0);
<span class="p_del">-	if (dst)</span>
<span class="p_del">-		skb_dst_set_noref(skb, dst);</span>
<span class="p_add">+	if (dst) {</span>
<span class="p_add">+		/* DST_NOCACHE can not be used without taking a reference */</span>
<span class="p_add">+		if (dst-&gt;flags &amp; DST_NOCACHE) {</span>
<span class="p_add">+			if (likely(atomic_inc_not_zero(&amp;dst-&gt;__refcnt)))</span>
<span class="p_add">+				skb_dst_set(skb, dst);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			skb_dst_set_noref(skb, dst);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 }
 
 int udp_rcv(struct sk_buff *skb)
<span class="p_chunk">@@ -2567,7 +2574,7 @@</span> <span class="p_context"> struct sk_buff *skb_udp_tunnel_segment(struct sk_buff *skb,</span>
 		skb-&gt;encap_hdr_csum = 1;
 
 	/* segment inner packet. */
<span class="p_del">-	enc_features = skb-&gt;dev-&gt;hw_enc_features &amp; netif_skb_features(skb);</span>
<span class="p_add">+	enc_features = skb-&gt;dev-&gt;hw_enc_features &amp; features;</span>
 	segs = skb_mac_gso_segment(skb, enc_features);
 	if (!segs || IS_ERR(segs)) {
 		skb_gso_error_unwind(skb, protocol, tnl_hlen, mac_offset,
<span class="p_header">diff --git a/net/ipv6/datagram.c b/net/ipv6/datagram.c</span>
<span class="p_header">index 841cfa2c4600..6b89b2a1ac74 100644</span>
<span class="p_header">--- a/net/ipv6/datagram.c</span>
<span class="p_header">+++ b/net/ipv6/datagram.c</span>
<span class="p_chunk">@@ -40,7 +40,7 @@</span> <span class="p_context"> static bool ipv6_mapped_addr_any(const struct in6_addr *a)</span>
 	return ipv6_addr_v4mapped(a) &amp;&amp; (a-&gt;s6_addr32[3] == 0);
 }
 
<span class="p_del">-int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
<span class="p_add">+static int __ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 {
 	struct sockaddr_in6	*usin = (struct sockaddr_in6 *) uaddr;
 	struct inet_sock      	*inet = inet_sk(sk);
<span class="p_chunk">@@ -56,7 +56,7 @@</span> <span class="p_context"> int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 	if (usin-&gt;sin6_family == AF_INET) {
 		if (__ipv6_only_sock(sk))
 			return -EAFNOSUPPORT;
<span class="p_del">-		err = ip4_datagram_connect(sk, uaddr, addr_len);</span>
<span class="p_add">+		err = __ip4_datagram_connect(sk, uaddr, addr_len);</span>
 		goto ipv4_connected;
 	}
 
<span class="p_chunk">@@ -98,9 +98,9 @@</span> <span class="p_context"> int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 		sin.sin_addr.s_addr = daddr-&gt;s6_addr32[3];
 		sin.sin_port = usin-&gt;sin6_port;
 
<span class="p_del">-		err = ip4_datagram_connect(sk,</span>
<span class="p_del">-					   (struct sockaddr *) &amp;sin,</span>
<span class="p_del">-					   sizeof(sin));</span>
<span class="p_add">+		err = __ip4_datagram_connect(sk,</span>
<span class="p_add">+					     (struct sockaddr *) &amp;sin,</span>
<span class="p_add">+					     sizeof(sin));</span>
 
 ipv4_connected:
 		if (err)
<span class="p_chunk">@@ -203,6 +203,16 @@</span> <span class="p_context"> out:</span>
 	fl6_sock_release(flowlabel);
 	return err;
 }
<span class="p_add">+</span>
<span class="p_add">+int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int res;</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+	res = __ip6_datagram_connect(sk, uaddr, addr_len);</span>
<span class="p_add">+	release_sock(sk);</span>
<span class="p_add">+	return res;</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL_GPL(ip6_datagram_connect);
 
 int ip6_datagram_connect_v6_only(struct sock *sk, struct sockaddr *uaddr,
<span class="p_header">diff --git a/net/ipv6/ip6_gre.c b/net/ipv6/ip6_gre.c</span>
<span class="p_header">index 07506e7a8917..f5ea5aaf75f9 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_gre.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_gre.c</span>
<span class="p_chunk">@@ -358,6 +358,7 @@</span> <span class="p_context"> static void ip6gre_tunnel_uninit(struct net_device *dev)</span>
 	struct ip6gre_net *ign = net_generic(t-&gt;net, ip6gre_net_id);
 
 	ip6gre_tunnel_unlink(ign, t);
<span class="p_add">+	ip6_tnl_dst_reset(t);</span>
 	dev_put(dev);
 }
 
<span class="p_header">diff --git a/net/ipv6/ip6_offload.c b/net/ipv6/ip6_offload.c</span>
<span class="p_header">index 65eda2a8af48..ef590d4e0171 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_offload.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_offload.c</span>
<span class="p_chunk">@@ -114,7 +114,7 @@</span> <span class="p_context"> static struct sk_buff *ipv6_gso_segment(struct sk_buff *skb,</span>
 
 	encap = SKB_GSO_CB(skb)-&gt;encap_level &gt; 0;
 	if (encap)
<span class="p_del">-		features = skb-&gt;dev-&gt;hw_enc_features &amp; netif_skb_features(skb);</span>
<span class="p_add">+		features &amp;= skb-&gt;dev-&gt;hw_enc_features;</span>
 	SKB_GSO_CB(skb)-&gt;encap_level += sizeof(*ipv6h);
 
 	ipv6h = ipv6_hdr(skb);
<span class="p_header">diff --git a/net/key/af_key.c b/net/key/af_key.c</span>
<span class="p_header">index ba2a2f95911c..a9f25fdeeb4b 100644</span>
<span class="p_header">--- a/net/key/af_key.c</span>
<span class="p_header">+++ b/net/key/af_key.c</span>
<span class="p_chunk">@@ -219,7 +219,7 @@</span> <span class="p_context"> static int pfkey_broadcast_one(struct sk_buff *skb, struct sk_buff **skb2,</span>
 #define BROADCAST_ONE		1
 #define BROADCAST_REGISTERED	2
 #define BROADCAST_PROMISC_ONLY	4
<span class="p_del">-static int pfkey_broadcast(struct sk_buff *skb, gfp_t allocation,</span>
<span class="p_add">+static int pfkey_broadcast(struct sk_buff *skb,</span>
 			   int broadcast_flags, struct sock *one_sk,
 			   struct net *net)
 {
<span class="p_chunk">@@ -244,7 +244,7 @@</span> <span class="p_context"> static int pfkey_broadcast(struct sk_buff *skb, gfp_t allocation,</span>
 		 * socket.
 		 */
 		if (pfk-&gt;promisc)
<span class="p_del">-			pfkey_broadcast_one(skb, &amp;skb2, allocation, sk);</span>
<span class="p_add">+			pfkey_broadcast_one(skb, &amp;skb2, GFP_ATOMIC, sk);</span>
 
 		/* the exact target will be processed later */
 		if (sk == one_sk)
<span class="p_chunk">@@ -259,7 +259,7 @@</span> <span class="p_context"> static int pfkey_broadcast(struct sk_buff *skb, gfp_t allocation,</span>
 				continue;
 		}
 
<span class="p_del">-		err2 = pfkey_broadcast_one(skb, &amp;skb2, allocation, sk);</span>
<span class="p_add">+		err2 = pfkey_broadcast_one(skb, &amp;skb2, GFP_ATOMIC, sk);</span>
 
 		/* Error is cleare after succecful sending to at least one
 		 * registered KM */
<span class="p_chunk">@@ -269,7 +269,7 @@</span> <span class="p_context"> static int pfkey_broadcast(struct sk_buff *skb, gfp_t allocation,</span>
 	rcu_read_unlock();
 
 	if (one_sk != NULL)
<span class="p_del">-		err = pfkey_broadcast_one(skb, &amp;skb2, allocation, one_sk);</span>
<span class="p_add">+		err = pfkey_broadcast_one(skb, &amp;skb2, GFP_KERNEL, one_sk);</span>
 
 	kfree_skb(skb2);
 	kfree_skb(skb);
<span class="p_chunk">@@ -292,7 +292,7 @@</span> <span class="p_context"> static int pfkey_do_dump(struct pfkey_sock *pfk)</span>
 		hdr = (struct sadb_msg *) pfk-&gt;dump.skb-&gt;data;
 		hdr-&gt;sadb_msg_seq = 0;
 		hdr-&gt;sadb_msg_errno = rc;
<span class="p_del">-		pfkey_broadcast(pfk-&gt;dump.skb, GFP_ATOMIC, BROADCAST_ONE,</span>
<span class="p_add">+		pfkey_broadcast(pfk-&gt;dump.skb, BROADCAST_ONE,</span>
 				&amp;pfk-&gt;sk, sock_net(&amp;pfk-&gt;sk));
 		pfk-&gt;dump.skb = NULL;
 	}
<span class="p_chunk">@@ -333,7 +333,7 @@</span> <span class="p_context"> static int pfkey_error(const struct sadb_msg *orig, int err, struct sock *sk)</span>
 	hdr-&gt;sadb_msg_len = (sizeof(struct sadb_msg) /
 			     sizeof(uint64_t));
 
<span class="p_del">-	pfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ONE, sk, sock_net(sk));</span>
<span class="p_add">+	pfkey_broadcast(skb, BROADCAST_ONE, sk, sock_net(sk));</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1367,7 +1367,7 @@</span> <span class="p_context"> static int pfkey_getspi(struct sock *sk, struct sk_buff *skb, const struct sadb_</span>
 
 	xfrm_state_put(x);
 
<span class="p_del">-	pfkey_broadcast(resp_skb, GFP_KERNEL, BROADCAST_ONE, sk, net);</span>
<span class="p_add">+	pfkey_broadcast(resp_skb, BROADCAST_ONE, sk, net);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1454,7 +1454,7 @@</span> <span class="p_context"> static int key_notify_sa(struct xfrm_state *x, const struct km_event *c)</span>
 	hdr-&gt;sadb_msg_seq = c-&gt;seq;
 	hdr-&gt;sadb_msg_pid = c-&gt;portid;
 
<span class="p_del">-	pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xs_net(x));</span>
<span class="p_add">+	pfkey_broadcast(skb, BROADCAST_ALL, NULL, xs_net(x));</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1567,7 +1567,7 @@</span> <span class="p_context"> static int pfkey_get(struct sock *sk, struct sk_buff *skb, const struct sadb_msg</span>
 	out_hdr-&gt;sadb_msg_reserved = 0;
 	out_hdr-&gt;sadb_msg_seq = hdr-&gt;sadb_msg_seq;
 	out_hdr-&gt;sadb_msg_pid = hdr-&gt;sadb_msg_pid;
<span class="p_del">-	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));</span>
<span class="p_add">+	pfkey_broadcast(out_skb, BROADCAST_ONE, sk, sock_net(sk));</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1672,7 +1672,7 @@</span> <span class="p_context"> static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sad</span>
 		return -ENOBUFS;
 	}
 
<span class="p_del">-	pfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk, sock_net(sk));</span>
<span class="p_add">+	pfkey_broadcast(supp_skb, BROADCAST_REGISTERED, sk, sock_net(sk));</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1691,7 +1691,7 @@</span> <span class="p_context"> static int unicast_flush_resp(struct sock *sk, const struct sadb_msg *ihdr)</span>
 	hdr-&gt;sadb_msg_errno = (uint8_t) 0;
 	hdr-&gt;sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 
<span class="p_del">-	return pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));</span>
<span class="p_add">+	return pfkey_broadcast(skb, BROADCAST_ONE, sk, sock_net(sk));</span>
 }
 
 static int key_notify_sa_flush(const struct km_event *c)
<span class="p_chunk">@@ -1712,7 +1712,7 @@</span> <span class="p_context"> static int key_notify_sa_flush(const struct km_event *c)</span>
 	hdr-&gt;sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 	hdr-&gt;sadb_msg_reserved = 0;
 
<span class="p_del">-	pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c-&gt;net);</span>
<span class="p_add">+	pfkey_broadcast(skb, BROADCAST_ALL, NULL, c-&gt;net);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1769,7 +1769,7 @@</span> <span class="p_context"> static int dump_sa(struct xfrm_state *x, int count, void *ptr)</span>
 	out_hdr-&gt;sadb_msg_pid = pfk-&gt;dump.msg_portid;
 
 	if (pfk-&gt;dump.skb)
<span class="p_del">-		pfkey_broadcast(pfk-&gt;dump.skb, GFP_ATOMIC, BROADCAST_ONE,</span>
<span class="p_add">+		pfkey_broadcast(pfk-&gt;dump.skb, BROADCAST_ONE,</span>
 				&amp;pfk-&gt;sk, sock_net(&amp;pfk-&gt;sk));
 	pfk-&gt;dump.skb = out_skb;
 
<span class="p_chunk">@@ -1849,7 +1849,7 @@</span> <span class="p_context"> static int pfkey_promisc(struct sock *sk, struct sk_buff *skb, const struct sadb</span>
 		new_hdr-&gt;sadb_msg_errno = 0;
 	}
 
<span class="p_del">-	pfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ALL, NULL, sock_net(sk));</span>
<span class="p_add">+	pfkey_broadcast(skb, BROADCAST_ALL, NULL, sock_net(sk));</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -2183,7 +2183,7 @@</span> <span class="p_context"> static int key_notify_policy(struct xfrm_policy *xp, int dir, const struct km_ev</span>
 	out_hdr-&gt;sadb_msg_errno = 0;
 	out_hdr-&gt;sadb_msg_seq = c-&gt;seq;
 	out_hdr-&gt;sadb_msg_pid = c-&gt;portid;
<span class="p_del">-	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xp_net(xp));</span>
<span class="p_add">+	pfkey_broadcast(out_skb, BROADCAST_ALL, NULL, xp_net(xp));</span>
 	return 0;
 
 }
<span class="p_chunk">@@ -2403,7 +2403,7 @@</span> <span class="p_context"> static int key_pol_get_resp(struct sock *sk, struct xfrm_policy *xp, const struc</span>
 	out_hdr-&gt;sadb_msg_errno = 0;
 	out_hdr-&gt;sadb_msg_seq = hdr-&gt;sadb_msg_seq;
 	out_hdr-&gt;sadb_msg_pid = hdr-&gt;sadb_msg_pid;
<span class="p_del">-	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, xp_net(xp));</span>
<span class="p_add">+	pfkey_broadcast(out_skb, BROADCAST_ONE, sk, xp_net(xp));</span>
 	err = 0;
 
 out:
<span class="p_chunk">@@ -2657,7 +2657,7 @@</span> <span class="p_context"> static int dump_sp(struct xfrm_policy *xp, int dir, int count, void *ptr)</span>
 	out_hdr-&gt;sadb_msg_pid = pfk-&gt;dump.msg_portid;
 
 	if (pfk-&gt;dump.skb)
<span class="p_del">-		pfkey_broadcast(pfk-&gt;dump.skb, GFP_ATOMIC, BROADCAST_ONE,</span>
<span class="p_add">+		pfkey_broadcast(pfk-&gt;dump.skb, BROADCAST_ONE,</span>
 				&amp;pfk-&gt;sk, sock_net(&amp;pfk-&gt;sk));
 	pfk-&gt;dump.skb = out_skb;
 
<span class="p_chunk">@@ -2710,7 +2710,7 @@</span> <span class="p_context"> static int key_notify_policy_flush(const struct km_event *c)</span>
 	hdr-&gt;sadb_msg_satype = SADB_SATYPE_UNSPEC;
 	hdr-&gt;sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 	hdr-&gt;sadb_msg_reserved = 0;
<span class="p_del">-	pfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c-&gt;net);</span>
<span class="p_add">+	pfkey_broadcast(skb_out, BROADCAST_ALL, NULL, c-&gt;net);</span>
 	return 0;
 
 }
<span class="p_chunk">@@ -2772,7 +2772,7 @@</span> <span class="p_context"> static int pfkey_process(struct sock *sk, struct sk_buff *skb, const struct sadb</span>
 	void *ext_hdrs[SADB_EXT_MAX];
 	int err;
 
<span class="p_del">-	pfkey_broadcast(skb_clone(skb, GFP_KERNEL), GFP_KERNEL,</span>
<span class="p_add">+	pfkey_broadcast(skb_clone(skb, GFP_KERNEL),</span>
 			BROADCAST_PROMISC_ONLY, NULL, sock_net(sk));
 
 	memset(ext_hdrs, 0, sizeof(ext_hdrs));
<span class="p_chunk">@@ -2994,7 +2994,7 @@</span> <span class="p_context"> static int key_notify_sa_expire(struct xfrm_state *x, const struct km_event *c)</span>
 	out_hdr-&gt;sadb_msg_seq = 0;
 	out_hdr-&gt;sadb_msg_pid = 0;
 
<span class="p_del">-	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL, xs_net(x));</span>
<span class="p_add">+	pfkey_broadcast(out_skb, BROADCAST_REGISTERED, NULL, xs_net(x));</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -3184,7 +3184,7 @@</span> <span class="p_context"> static int pfkey_send_acquire(struct xfrm_state *x, struct xfrm_tmpl *t, struct</span>
 		       xfrm_ctx-&gt;ctx_len);
 	}
 
<span class="p_del">-	return pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL, xs_net(x));</span>
<span class="p_add">+	return pfkey_broadcast(skb, BROADCAST_REGISTERED, NULL, xs_net(x));</span>
 }
 
 static struct xfrm_policy *pfkey_compile_policy(struct sock *sk, int opt,
<span class="p_chunk">@@ -3382,7 +3382,7 @@</span> <span class="p_context"> static int pfkey_send_new_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr,</span>
 	n_port-&gt;sadb_x_nat_t_port_port = sport;
 	n_port-&gt;sadb_x_nat_t_port_reserved = 0;
 
<span class="p_del">-	return pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL, xs_net(x));</span>
<span class="p_add">+	return pfkey_broadcast(skb, BROADCAST_REGISTERED, NULL, xs_net(x));</span>
 }
 
 #ifdef CONFIG_NET_KEY_MIGRATE
<span class="p_chunk">@@ -3574,7 +3574,7 @@</span> <span class="p_context"> static int pfkey_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,</span>
 	}
 
 	/* broadcast migrate message to sockets */
<span class="p_del">-	pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, &amp;init_net);</span>
<span class="p_add">+	pfkey_broadcast(skb, BROADCAST_ALL, NULL, &amp;init_net);</span>
 
 	return 0;
 
<span class="p_header">diff --git a/net/mpls/mpls_gso.c b/net/mpls/mpls_gso.c</span>
<span class="p_header">index 6b38d083e1c9..fefda6cc61fa 100644</span>
<span class="p_header">--- a/net/mpls/mpls_gso.c</span>
<span class="p_header">+++ b/net/mpls/mpls_gso.c</span>
<span class="p_chunk">@@ -48,7 +48,7 @@</span> <span class="p_context"> static struct sk_buff *mpls_gso_segment(struct sk_buff *skb,</span>
 	__skb_push(skb, skb-&gt;mac_len);
 
 	/* Segment inner packet. */
<span class="p_del">-	mpls_features = skb-&gt;dev-&gt;mpls_features &amp; netif_skb_features(skb);</span>
<span class="p_add">+	mpls_features = skb-&gt;dev-&gt;mpls_features &amp; features;</span>
 	segs = skb_mac_gso_segment(skb, mpls_features);
 
 
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_core.c b/net/netfilter/ipvs/ip_vs_core.c</span>
<span class="p_header">index 74de7655faf8..4ae958906a6b 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_core.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_core.c</span>
<span class="p_chunk">@@ -313,7 +313,13 @@</span> <span class="p_context"> ip_vs_sched_persist(struct ip_vs_service *svc,</span>
 		 * return *ignored=0 i.e. ICMP and NF_DROP
 		 */
 		sched = rcu_dereference(svc-&gt;scheduler);
<span class="p_del">-		dest = sched-&gt;schedule(svc, skb, iph);</span>
<span class="p_add">+		if (sched) {</span>
<span class="p_add">+			/* read svc-&gt;sched_data after svc-&gt;scheduler */</span>
<span class="p_add">+			smp_rmb();</span>
<span class="p_add">+			dest = sched-&gt;schedule(svc, skb, iph);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			dest = NULL;</span>
<span class="p_add">+		}</span>
 		if (!dest) {
 			IP_VS_DBG(1, &quot;p-schedule: no dest found.\n&quot;);
 			kfree(param.pe_data);
<span class="p_chunk">@@ -460,7 +466,13 @@</span> <span class="p_context"> ip_vs_schedule(struct ip_vs_service *svc, struct sk_buff *skb,</span>
 	}
 
 	sched = rcu_dereference(svc-&gt;scheduler);
<span class="p_del">-	dest = sched-&gt;schedule(svc, skb, iph);</span>
<span class="p_add">+	if (sched) {</span>
<span class="p_add">+		/* read svc-&gt;sched_data after svc-&gt;scheduler */</span>
<span class="p_add">+		smp_rmb();</span>
<span class="p_add">+		dest = sched-&gt;schedule(svc, skb, iph);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		dest = NULL;</span>
<span class="p_add">+	}</span>
 	if (dest == NULL) {
 		IP_VS_DBG(1, &quot;Schedule: no dest found.\n&quot;);
 		return NULL;
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_ctl.c b/net/netfilter/ipvs/ip_vs_ctl.c</span>
<span class="p_header">index 285ae0dc1e03..7311cc206d0f 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_ctl.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_ctl.c</span>
<span class="p_chunk">@@ -820,15 +820,16 @@</span> <span class="p_context"> __ip_vs_update_dest(struct ip_vs_service *svc, struct ip_vs_dest *dest,</span>
 	__ip_vs_dst_cache_reset(dest);
 	spin_unlock_bh(&amp;dest-&gt;dst_lock);
 
<span class="p_del">-	sched = rcu_dereference_protected(svc-&gt;scheduler, 1);</span>
 	if (add) {
 		ip_vs_start_estimator(svc-&gt;net, &amp;dest-&gt;stats);
 		list_add_rcu(&amp;dest-&gt;n_list, &amp;svc-&gt;destinations);
 		svc-&gt;num_dests++;
<span class="p_del">-		if (sched-&gt;add_dest)</span>
<span class="p_add">+		sched = rcu_dereference_protected(svc-&gt;scheduler, 1);</span>
<span class="p_add">+		if (sched &amp;&amp; sched-&gt;add_dest)</span>
 			sched-&gt;add_dest(svc, dest);
 	} else {
<span class="p_del">-		if (sched-&gt;upd_dest)</span>
<span class="p_add">+		sched = rcu_dereference_protected(svc-&gt;scheduler, 1);</span>
<span class="p_add">+		if (sched &amp;&amp; sched-&gt;upd_dest)</span>
 			sched-&gt;upd_dest(svc, dest);
 	}
 }
<span class="p_chunk">@@ -1059,7 +1060,7 @@</span> <span class="p_context"> static void __ip_vs_unlink_dest(struct ip_vs_service *svc,</span>
 		struct ip_vs_scheduler *sched;
 
 		sched = rcu_dereference_protected(svc-&gt;scheduler, 1);
<span class="p_del">-		if (sched-&gt;del_dest)</span>
<span class="p_add">+		if (sched &amp;&amp; sched-&gt;del_dest)</span>
 			sched-&gt;del_dest(svc, dest);
 	}
 }
<span class="p_chunk">@@ -1150,11 +1151,14 @@</span> <span class="p_context"> ip_vs_add_service(struct net *net, struct ip_vs_service_user_kern *u,</span>
 	ip_vs_use_count_inc();
 
 	/* Lookup the scheduler by &#39;u-&gt;sched_name&#39; */
<span class="p_del">-	sched = ip_vs_scheduler_get(u-&gt;sched_name);</span>
<span class="p_del">-	if (sched == NULL) {</span>
<span class="p_del">-		pr_info(&quot;Scheduler module ip_vs_%s not found\n&quot;, u-&gt;sched_name);</span>
<span class="p_del">-		ret = -ENOENT;</span>
<span class="p_del">-		goto out_err;</span>
<span class="p_add">+	if (strcmp(u-&gt;sched_name, &quot;none&quot;)) {</span>
<span class="p_add">+		sched = ip_vs_scheduler_get(u-&gt;sched_name);</span>
<span class="p_add">+		if (!sched) {</span>
<span class="p_add">+			pr_info(&quot;Scheduler module ip_vs_%s not found\n&quot;,</span>
<span class="p_add">+				u-&gt;sched_name);</span>
<span class="p_add">+			ret = -ENOENT;</span>
<span class="p_add">+			goto out_err;</span>
<span class="p_add">+		}</span>
 	}
 
 	if (u-&gt;pe_name &amp;&amp; *u-&gt;pe_name) {
<span class="p_chunk">@@ -1215,10 +1219,12 @@</span> <span class="p_context"> ip_vs_add_service(struct net *net, struct ip_vs_service_user_kern *u,</span>
 	spin_lock_init(&amp;svc-&gt;stats.lock);
 
 	/* Bind the scheduler */
<span class="p_del">-	ret = ip_vs_bind_scheduler(svc, sched);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto out_err;</span>
<span class="p_del">-	sched = NULL;</span>
<span class="p_add">+	if (sched) {</span>
<span class="p_add">+		ret = ip_vs_bind_scheduler(svc, sched);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto out_err;</span>
<span class="p_add">+		sched = NULL;</span>
<span class="p_add">+	}</span>
 
 	/* Bind the ct retriever */
 	RCU_INIT_POINTER(svc-&gt;pe, pe);
<span class="p_chunk">@@ -1266,17 +1272,20 @@</span> <span class="p_context"> ip_vs_add_service(struct net *net, struct ip_vs_service_user_kern *u,</span>
 static int
 ip_vs_edit_service(struct ip_vs_service *svc, struct ip_vs_service_user_kern *u)
 {
<span class="p_del">-	struct ip_vs_scheduler *sched, *old_sched;</span>
<span class="p_add">+	struct ip_vs_scheduler *sched = NULL, *old_sched;</span>
 	struct ip_vs_pe *pe = NULL, *old_pe = NULL;
 	int ret = 0;
 
 	/*
 	 * Lookup the scheduler, by &#39;u-&gt;sched_name&#39;
 	 */
<span class="p_del">-	sched = ip_vs_scheduler_get(u-&gt;sched_name);</span>
<span class="p_del">-	if (sched == NULL) {</span>
<span class="p_del">-		pr_info(&quot;Scheduler module ip_vs_%s not found\n&quot;, u-&gt;sched_name);</span>
<span class="p_del">-		return -ENOENT;</span>
<span class="p_add">+	if (strcmp(u-&gt;sched_name, &quot;none&quot;)) {</span>
<span class="p_add">+		sched = ip_vs_scheduler_get(u-&gt;sched_name);</span>
<span class="p_add">+		if (!sched) {</span>
<span class="p_add">+			pr_info(&quot;Scheduler module ip_vs_%s not found\n&quot;,</span>
<span class="p_add">+				u-&gt;sched_name);</span>
<span class="p_add">+			return -ENOENT;</span>
<span class="p_add">+		}</span>
 	}
 	old_sched = sched;
 
<span class="p_chunk">@@ -1304,14 +1313,20 @@</span> <span class="p_context"> ip_vs_edit_service(struct ip_vs_service *svc, struct ip_vs_service_user_kern *u)</span>
 
 	old_sched = rcu_dereference_protected(svc-&gt;scheduler, 1);
 	if (sched != old_sched) {
<span class="p_add">+		if (old_sched) {</span>
<span class="p_add">+			ip_vs_unbind_scheduler(svc, old_sched);</span>
<span class="p_add">+			RCU_INIT_POINTER(svc-&gt;scheduler, NULL);</span>
<span class="p_add">+			/* Wait all svc-&gt;sched_data users */</span>
<span class="p_add">+			synchronize_rcu();</span>
<span class="p_add">+		}</span>
 		/* Bind the new scheduler */
<span class="p_del">-		ret = ip_vs_bind_scheduler(svc, sched);</span>
<span class="p_del">-		if (ret) {</span>
<span class="p_del">-			old_sched = sched;</span>
<span class="p_del">-			goto out;</span>
<span class="p_add">+		if (sched) {</span>
<span class="p_add">+			ret = ip_vs_bind_scheduler(svc, sched);</span>
<span class="p_add">+			if (ret) {</span>
<span class="p_add">+				ip_vs_scheduler_put(sched);</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+			}</span>
 		}
<span class="p_del">-		/* Unbind the old scheduler on success */</span>
<span class="p_del">-		ip_vs_unbind_scheduler(svc, old_sched);</span>
 	}
 
 	/*
<span class="p_chunk">@@ -2037,6 +2052,7 @@</span> <span class="p_context"> static int ip_vs_info_seq_show(struct seq_file *seq, void *v)</span>
 		const struct ip_vs_iter *iter = seq-&gt;private;
 		const struct ip_vs_dest *dest;
 		struct ip_vs_scheduler *sched = rcu_dereference(svc-&gt;scheduler);
<span class="p_add">+		char *sched_name = sched ? sched-&gt;name : &quot;none&quot;;</span>
 
 		if (iter-&gt;table == ip_vs_svc_table) {
 #ifdef CONFIG_IP_VS_IPV6
<span class="p_chunk">@@ -2045,18 +2061,18 @@</span> <span class="p_context"> static int ip_vs_info_seq_show(struct seq_file *seq, void *v)</span>
 					   ip_vs_proto_name(svc-&gt;protocol),
 					   &amp;svc-&gt;addr.in6,
 					   ntohs(svc-&gt;port),
<span class="p_del">-					   sched-&gt;name);</span>
<span class="p_add">+					   sched_name);</span>
 			else
 #endif
 				seq_printf(seq, &quot;%s  %08X:%04X %s %s &quot;,
 					   ip_vs_proto_name(svc-&gt;protocol),
 					   ntohl(svc-&gt;addr.ip),
 					   ntohs(svc-&gt;port),
<span class="p_del">-					   sched-&gt;name,</span>
<span class="p_add">+					   sched_name,</span>
 					   (svc-&gt;flags &amp; IP_VS_SVC_F_ONEPACKET)?&quot;ops &quot;:&quot;&quot;);
 		} else {
 			seq_printf(seq, &quot;FWM  %08X %s %s&quot;,
<span class="p_del">-				   svc-&gt;fwmark, sched-&gt;name,</span>
<span class="p_add">+				   svc-&gt;fwmark, sched_name,</span>
 				   (svc-&gt;flags &amp; IP_VS_SVC_F_ONEPACKET)?&quot;ops &quot;:&quot;&quot;);
 		}
 
<span class="p_chunk">@@ -2471,13 +2487,15 @@</span> <span class="p_context"> static void</span>
 ip_vs_copy_service(struct ip_vs_service_entry *dst, struct ip_vs_service *src)
 {
 	struct ip_vs_scheduler *sched;
<span class="p_add">+	char *sched_name;</span>
 
 	sched = rcu_dereference_protected(src-&gt;scheduler, 1);
<span class="p_add">+	sched_name = sched ? sched-&gt;name : &quot;none&quot;;</span>
 	dst-&gt;protocol = src-&gt;protocol;
 	dst-&gt;addr = src-&gt;addr.ip;
 	dst-&gt;port = src-&gt;port;
 	dst-&gt;fwmark = src-&gt;fwmark;
<span class="p_del">-	strlcpy(dst-&gt;sched_name, sched-&gt;name, sizeof(dst-&gt;sched_name));</span>
<span class="p_add">+	strlcpy(dst-&gt;sched_name, sched_name, sizeof(dst-&gt;sched_name));</span>
 	dst-&gt;flags = src-&gt;flags;
 	dst-&gt;timeout = src-&gt;timeout / HZ;
 	dst-&gt;netmask = src-&gt;netmask;
<span class="p_chunk">@@ -2903,6 +2921,7 @@</span> <span class="p_context"> static int ip_vs_genl_fill_service(struct sk_buff *skb,</span>
 	struct nlattr *nl_service;
 	struct ip_vs_flags flags = { .flags = svc-&gt;flags,
 				     .mask = ~0 };
<span class="p_add">+	char *sched_name;</span>
 
 	nl_service = nla_nest_start(skb, IPVS_CMD_ATTR_SERVICE);
 	if (!nl_service)
<span class="p_chunk">@@ -2921,8 +2940,9 @@</span> <span class="p_context"> static int ip_vs_genl_fill_service(struct sk_buff *skb,</span>
 	}
 
 	sched = rcu_dereference_protected(svc-&gt;scheduler, 1);
<span class="p_add">+	sched_name = sched ? sched-&gt;name : &quot;none&quot;;</span>
 	pe = rcu_dereference_protected(svc-&gt;pe, 1);
<span class="p_del">-	if (nla_put_string(skb, IPVS_SVC_ATTR_SCHED_NAME, sched-&gt;name) ||</span>
<span class="p_add">+	if (nla_put_string(skb, IPVS_SVC_ATTR_SCHED_NAME, sched_name) ||</span>
 	    (pe &amp;&amp; nla_put_string(skb, IPVS_SVC_ATTR_PE_NAME, pe-&gt;name)) ||
 	    nla_put(skb, IPVS_SVC_ATTR_FLAGS, sizeof(flags), &amp;flags) ||
 	    nla_put_u32(skb, IPVS_SVC_ATTR_TIMEOUT, svc-&gt;timeout / HZ) ||
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_sched.c b/net/netfilter/ipvs/ip_vs_sched.c</span>
<span class="p_header">index 4dbcda6258bc..21b6b515a09c 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_sched.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_sched.c</span>
<span class="p_chunk">@@ -74,7 +74,7 @@</span> <span class="p_context"> void ip_vs_unbind_scheduler(struct ip_vs_service *svc,</span>
 
 	if (sched-&gt;done_service)
 		sched-&gt;done_service(svc);
<span class="p_del">-	/* svc-&gt;scheduler can not be set to NULL */</span>
<span class="p_add">+	/* svc-&gt;scheduler can be set to NULL only by caller */</span>
 }
 
 
<span class="p_chunk">@@ -148,21 +148,21 @@</span> <span class="p_context"> void ip_vs_scheduler_put(struct ip_vs_scheduler *scheduler)</span>
 
 void ip_vs_scheduler_err(struct ip_vs_service *svc, const char *msg)
 {
<span class="p_del">-	struct ip_vs_scheduler *sched;</span>
<span class="p_add">+	struct ip_vs_scheduler *sched = rcu_dereference(svc-&gt;scheduler);</span>
<span class="p_add">+	char *sched_name = sched ? sched-&gt;name : &quot;none&quot;;</span>
 
<span class="p_del">-	sched = rcu_dereference(svc-&gt;scheduler);</span>
 	if (svc-&gt;fwmark) {
 		IP_VS_ERR_RL(&quot;%s: FWM %u 0x%08X - %s\n&quot;,
<span class="p_del">-			     sched-&gt;name, svc-&gt;fwmark, svc-&gt;fwmark, msg);</span>
<span class="p_add">+			     sched_name, svc-&gt;fwmark, svc-&gt;fwmark, msg);</span>
 #ifdef CONFIG_IP_VS_IPV6
 	} else if (svc-&gt;af == AF_INET6) {
 		IP_VS_ERR_RL(&quot;%s: %s [%pI6c]:%d - %s\n&quot;,
<span class="p_del">-			     sched-&gt;name, ip_vs_proto_name(svc-&gt;protocol),</span>
<span class="p_add">+			     sched_name, ip_vs_proto_name(svc-&gt;protocol),</span>
 			     &amp;svc-&gt;addr.in6, ntohs(svc-&gt;port), msg);
 #endif
 	} else {
 		IP_VS_ERR_RL(&quot;%s: %s %pI4:%d - %s\n&quot;,
<span class="p_del">-			     sched-&gt;name, ip_vs_proto_name(svc-&gt;protocol),</span>
<span class="p_add">+			     sched_name, ip_vs_proto_name(svc-&gt;protocol),</span>
 			     &amp;svc-&gt;addr.ip, ntohs(svc-&gt;port), msg);
 	}
 }
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_sync.c b/net/netfilter/ipvs/ip_vs_sync.c</span>
<span class="p_header">index a8027e73b6a2..a108953a8c2c 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_sync.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_sync.c</span>
<span class="p_chunk">@@ -612,7 +612,7 @@</span> <span class="p_context"> static void ip_vs_sync_conn_v0(struct net *net, struct ip_vs_conn *cp,</span>
 			pkts = atomic_add_return(1, &amp;cp-&gt;in_pkts);
 		else
 			pkts = sysctl_sync_threshold(ipvs);
<span class="p_del">-		ip_vs_sync_conn(net, cp-&gt;control, pkts);</span>
<span class="p_add">+		ip_vs_sync_conn(net, cp, pkts);</span>
 	}
 }
 
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_xmit.c b/net/netfilter/ipvs/ip_vs_xmit.c</span>
<span class="p_header">index 6f70bdd3a90a..180f7624bcd4 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_xmit.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_xmit.c</span>
<span class="p_chunk">@@ -129,7 +129,6 @@</span> <span class="p_context"> static struct rtable *do_output_route4(struct net *net, __be32 daddr,</span>
 
 	memset(&amp;fl4, 0, sizeof(fl4));
 	fl4.daddr = daddr;
<span class="p_del">-	fl4.saddr = (rt_mode &amp; IP_VS_RT_MODE_CONNECT) ? *saddr : 0;</span>
 	fl4.flowi4_flags = (rt_mode &amp; IP_VS_RT_MODE_KNOWN_NH) ?
 			   FLOWI_FLAG_KNOWN_NH : 0;
 
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_expect.c b/net/netfilter/nf_conntrack_expect.c</span>
<span class="p_header">index f87e8f68ad45..c45186f91cc8 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_expect.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_expect.c</span>
<span class="p_chunk">@@ -218,7 +218,8 @@</span> <span class="p_context"> static inline int expect_clash(const struct nf_conntrack_expect *a,</span>
 			a-&gt;mask.src.u3.all[count] &amp; b-&gt;mask.src.u3.all[count];
 	}
 
<span class="p_del">-	return nf_ct_tuple_mask_cmp(&amp;a-&gt;tuple, &amp;b-&gt;tuple, &amp;intersect_mask);</span>
<span class="p_add">+	return nf_ct_tuple_mask_cmp(&amp;a-&gt;tuple, &amp;b-&gt;tuple, &amp;intersect_mask) &amp;&amp;</span>
<span class="p_add">+	       nf_ct_zone(a-&gt;master) == nf_ct_zone(b-&gt;master);</span>
 }
 
 static inline int expect_matches(const struct nf_conntrack_expect *a,
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_header">index 300ed1eec729..3f96dbd25389 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_chunk">@@ -2957,11 +2957,6 @@</span> <span class="p_context"> ctnetlink_create_expect(struct net *net, u16 zone,</span>
 	}
 
 	err = nf_ct_expect_related_report(exp, portid, report);
<span class="p_del">-	if (err &lt; 0)</span>
<span class="p_del">-		goto err_exp;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-err_exp:</span>
 	nf_ct_expect_put(exp);
 err_ct:
 	nf_ct_put(ct);
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index 5dcb2baaf2c2..a64b8eec3640 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -350,25 +350,52 @@</span> <span class="p_context"> err1:</span>
 	return NULL;
 }
 
<span class="p_add">+</span>
<span class="p_add">+static void</span>
<span class="p_add">+__netlink_set_ring(struct sock *sk, struct nl_mmap_req *req, bool tx_ring, void **pg_vec,</span>
<span class="p_add">+		   unsigned int order)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct netlink_sock *nlk = nlk_sk(sk);</span>
<span class="p_add">+	struct sk_buff_head *queue;</span>
<span class="p_add">+	struct netlink_ring *ring;</span>
<span class="p_add">+</span>
<span class="p_add">+	queue = tx_ring ? &amp;sk-&gt;sk_write_queue : &amp;sk-&gt;sk_receive_queue;</span>
<span class="p_add">+	ring  = tx_ring ? &amp;nlk-&gt;tx_ring : &amp;nlk-&gt;rx_ring;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_bh(&amp;queue-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	ring-&gt;frame_max		= req-&gt;nm_frame_nr - 1;</span>
<span class="p_add">+	ring-&gt;head		= 0;</span>
<span class="p_add">+	ring-&gt;frame_size	= req-&gt;nm_frame_size;</span>
<span class="p_add">+	ring-&gt;pg_vec_pages	= req-&gt;nm_block_size / PAGE_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	swap(ring-&gt;pg_vec_len, req-&gt;nm_block_nr);</span>
<span class="p_add">+	swap(ring-&gt;pg_vec_order, order);</span>
<span class="p_add">+	swap(ring-&gt;pg_vec, pg_vec);</span>
<span class="p_add">+</span>
<span class="p_add">+	__skb_queue_purge(queue);</span>
<span class="p_add">+	spin_unlock_bh(&amp;queue-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	WARN_ON(atomic_read(&amp;nlk-&gt;mapped));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pg_vec)</span>
<span class="p_add">+		free_pg_vec(pg_vec, order, req-&gt;nm_block_nr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int netlink_set_ring(struct sock *sk, struct nl_mmap_req *req,
<span class="p_del">-			    bool closing, bool tx_ring)</span>
<span class="p_add">+			    bool tx_ring)</span>
 {
 	struct netlink_sock *nlk = nlk_sk(sk);
 	struct netlink_ring *ring;
<span class="p_del">-	struct sk_buff_head *queue;</span>
 	void **pg_vec = NULL;
 	unsigned int order = 0;
<span class="p_del">-	int err;</span>
 
 	ring  = tx_ring ? &amp;nlk-&gt;tx_ring : &amp;nlk-&gt;rx_ring;
<span class="p_del">-	queue = tx_ring ? &amp;sk-&gt;sk_write_queue : &amp;sk-&gt;sk_receive_queue;</span>
 
<span class="p_del">-	if (!closing) {</span>
<span class="p_del">-		if (atomic_read(&amp;nlk-&gt;mapped))</span>
<span class="p_del">-			return -EBUSY;</span>
<span class="p_del">-		if (atomic_read(&amp;ring-&gt;pending))</span>
<span class="p_del">-			return -EBUSY;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (atomic_read(&amp;nlk-&gt;mapped))</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+	if (atomic_read(&amp;ring-&gt;pending))</span>
<span class="p_add">+		return -EBUSY;</span>
 
 	if (req-&gt;nm_block_nr) {
 		if (ring-&gt;pg_vec != NULL)
<span class="p_chunk">@@ -400,31 +427,19 @@</span> <span class="p_context"> static int netlink_set_ring(struct sock *sk, struct nl_mmap_req *req,</span>
 			return -EINVAL;
 	}
 
<span class="p_del">-	err = -EBUSY;</span>
 	mutex_lock(&amp;nlk-&gt;pg_vec_lock);
<span class="p_del">-	if (closing || atomic_read(&amp;nlk-&gt;mapped) == 0) {</span>
<span class="p_del">-		err = 0;</span>
<span class="p_del">-		spin_lock_bh(&amp;queue-&gt;lock);</span>
<span class="p_del">-</span>
<span class="p_del">-		ring-&gt;frame_max		= req-&gt;nm_frame_nr - 1;</span>
<span class="p_del">-		ring-&gt;head		= 0;</span>
<span class="p_del">-		ring-&gt;frame_size	= req-&gt;nm_frame_size;</span>
<span class="p_del">-		ring-&gt;pg_vec_pages	= req-&gt;nm_block_size / PAGE_SIZE;</span>
<span class="p_del">-</span>
<span class="p_del">-		swap(ring-&gt;pg_vec_len, req-&gt;nm_block_nr);</span>
<span class="p_del">-		swap(ring-&gt;pg_vec_order, order);</span>
<span class="p_del">-		swap(ring-&gt;pg_vec, pg_vec);</span>
<span class="p_del">-</span>
<span class="p_del">-		__skb_queue_purge(queue);</span>
<span class="p_del">-		spin_unlock_bh(&amp;queue-&gt;lock);</span>
<span class="p_del">-</span>
<span class="p_del">-		WARN_ON(atomic_read(&amp;nlk-&gt;mapped));</span>
<span class="p_add">+	if (atomic_read(&amp;nlk-&gt;mapped) == 0) {</span>
<span class="p_add">+		__netlink_set_ring(sk, req, tx_ring, pg_vec, order);</span>
<span class="p_add">+		mutex_unlock(&amp;nlk-&gt;pg_vec_lock);</span>
<span class="p_add">+		return 0;</span>
 	}
<span class="p_add">+</span>
 	mutex_unlock(&amp;nlk-&gt;pg_vec_lock);
 
 	if (pg_vec)
 		free_pg_vec(pg_vec, order, req-&gt;nm_block_nr);
<span class="p_del">-	return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return -EBUSY;</span>
 }
 
 static void netlink_mm_open(struct vm_area_struct *vma)
<span class="p_chunk">@@ -893,10 +908,10 @@</span> <span class="p_context"> static void netlink_sock_destruct(struct sock *sk)</span>
 
 		memset(&amp;req, 0, sizeof(req));
 		if (nlk-&gt;rx_ring.pg_vec)
<span class="p_del">-			netlink_set_ring(sk, &amp;req, true, false);</span>
<span class="p_add">+			__netlink_set_ring(sk, &amp;req, false, NULL, 0);</span>
 		memset(&amp;req, 0, sizeof(req));
 		if (nlk-&gt;tx_ring.pg_vec)
<span class="p_del">-			netlink_set_ring(sk, &amp;req, true, true);</span>
<span class="p_add">+			__netlink_set_ring(sk, &amp;req, true, NULL, 0);</span>
 	}
 #endif /* CONFIG_NETLINK_MMAP */
 
<span class="p_chunk">@@ -2220,7 +2235,7 @@</span> <span class="p_context"> static int netlink_setsockopt(struct socket *sock, int level, int optname,</span>
 			return -EINVAL;
 		if (copy_from_user(&amp;req, optval, sizeof(req)))
 			return -EFAULT;
<span class="p_del">-		err = netlink_set_ring(sk, &amp;req, false,</span>
<span class="p_add">+		err = netlink_set_ring(sk, &amp;req,</span>
 				       optname == NETLINK_TX_RING);
 		break;
 	}
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index fb0c09f85ff2..1f2e7d341781 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -2284,7 +2284,8 @@</span> <span class="p_context"> static int tpacket_snd(struct packet_sock *po, struct msghdr *msg)</span>
 
 		tp_len = tpacket_fill_skb(po, skb, ph, dev, size_max, proto,
 					  addr, hlen);
<span class="p_del">-		if (tp_len &gt; dev-&gt;mtu + dev-&gt;hard_header_len) {</span>
<span class="p_add">+		if (likely(tp_len &gt;= 0) &amp;&amp;</span>
<span class="p_add">+		    tp_len &gt; dev-&gt;mtu + dev-&gt;hard_header_len) {</span>
 			struct ethhdr *ehdr;
 			/* Earlier code assumed this would be a VLAN pkt,
 			 * double-check this now that we have the actual
<span class="p_chunk">@@ -2655,7 +2656,7 @@</span> <span class="p_context"> static int packet_release(struct socket *sock)</span>
 static int packet_do_bind(struct sock *sk, struct net_device *dev, __be16 proto)
 {
 	struct packet_sock *po = pkt_sk(sk);
<span class="p_del">-	const struct net_device *dev_curr;</span>
<span class="p_add">+	struct net_device *dev_curr;</span>
 	__be16 proto_curr;
 	bool need_rehook;
 
<span class="p_chunk">@@ -2679,15 +2680,13 @@</span> <span class="p_context"> static int packet_do_bind(struct sock *sk, struct net_device *dev, __be16 proto)</span>
 
 		po-&gt;num = proto;
 		po-&gt;prot_hook.type = proto;
<span class="p_del">-</span>
<span class="p_del">-		if (po-&gt;prot_hook.dev)</span>
<span class="p_del">-			dev_put(po-&gt;prot_hook.dev);</span>
<span class="p_del">-</span>
 		po-&gt;prot_hook.dev = dev;
 
 		po-&gt;ifindex = dev ? dev-&gt;ifindex : 0;
 		packet_cached_dev_assign(po, dev);
 	}
<span class="p_add">+	if (dev_curr)</span>
<span class="p_add">+		dev_put(dev_curr);</span>
 
 	if (proto == 0 || !need_rehook)
 		goto out_unlock;
<span class="p_header">diff --git a/net/rds/info.c b/net/rds/info.c</span>
<span class="p_header">index 9a6b4f66187c..140a44a5f7b7 100644</span>
<span class="p_header">--- a/net/rds/info.c</span>
<span class="p_header">+++ b/net/rds/info.c</span>
<span class="p_chunk">@@ -176,7 +176,7 @@</span> <span class="p_context"> int rds_info_getsockopt(struct socket *sock, int optname, char __user *optval,</span>
 
 	/* check for all kinds of wrapping and the like */
 	start = (unsigned long)optval;
<span class="p_del">-	if (len &lt; 0 || len + PAGE_SIZE - 1 &lt; len || start + len &lt; start) {</span>
<span class="p_add">+	if (len &lt; 0 || len &gt; INT_MAX - PAGE_SIZE + 1 || start + len &lt; start) {</span>
 		ret = -EINVAL;
 		goto out;
 	}
<span class="p_header">diff --git a/net/sched/act_api.c b/net/sched/act_api.c</span>
<span class="p_header">index 648778aef1a2..55307ccf4453 100644</span>
<span class="p_header">--- a/net/sched/act_api.c</span>
<span class="p_header">+++ b/net/sched/act_api.c</span>
<span class="p_chunk">@@ -45,7 +45,7 @@</span> <span class="p_context"> void tcf_hash_destroy(struct tc_action *a)</span>
 }
 EXPORT_SYMBOL(tcf_hash_destroy);
 
<span class="p_del">-int tcf_hash_release(struct tc_action *a, int bind)</span>
<span class="p_add">+int __tcf_hash_release(struct tc_action *a, bool bind, bool strict)</span>
 {
 	struct tcf_common *p = a-&gt;priv;
 	int ret = 0;
<span class="p_chunk">@@ -53,7 +53,7 @@</span> <span class="p_context"> int tcf_hash_release(struct tc_action *a, int bind)</span>
 	if (p) {
 		if (bind)
 			p-&gt;tcfc_bindcnt--;
<span class="p_del">-		else if (p-&gt;tcfc_bindcnt &gt; 0)</span>
<span class="p_add">+		else if (strict &amp;&amp; p-&gt;tcfc_bindcnt &gt; 0)</span>
 			return -EPERM;
 
 		p-&gt;tcfc_refcnt--;
<span class="p_chunk">@@ -64,9 +64,10 @@</span> <span class="p_context"> int tcf_hash_release(struct tc_action *a, int bind)</span>
 			ret = 1;
 		}
 	}
<span class="p_add">+</span>
 	return ret;
 }
<span class="p_del">-EXPORT_SYMBOL(tcf_hash_release);</span>
<span class="p_add">+EXPORT_SYMBOL(__tcf_hash_release);</span>
 
 static int tcf_dump_walker(struct sk_buff *skb, struct netlink_callback *cb,
 			   struct tc_action *a)
<span class="p_chunk">@@ -136,7 +137,7 @@</span> <span class="p_context"> static int tcf_del_walker(struct sk_buff *skb, struct tc_action *a)</span>
 		head = &amp;hinfo-&gt;htab[tcf_hash(i, hinfo-&gt;hmask)];
 		hlist_for_each_entry_safe(p, n, head, tcfc_head) {
 			a-&gt;priv = p;
<span class="p_del">-			ret = tcf_hash_release(a, 0);</span>
<span class="p_add">+			ret = __tcf_hash_release(a, false, true);</span>
 			if (ret == ACT_P_DELETED) {
 				module_put(a-&gt;ops-&gt;owner);
 				n_i++;
<span class="p_chunk">@@ -412,7 +413,7 @@</span> <span class="p_context"> int tcf_action_destroy(struct list_head *actions, int bind)</span>
 	int ret = 0;
 
 	list_for_each_entry_safe(a, tmp, actions, list) {
<span class="p_del">-		ret = tcf_hash_release(a, bind);</span>
<span class="p_add">+		ret = __tcf_hash_release(a, bind, true);</span>
 		if (ret == ACT_P_DELETED)
 			module_put(a-&gt;ops-&gt;owner);
 		else if (ret &lt; 0)
<span class="p_header">diff --git a/net/sched/act_pedit.c b/net/sched/act_pedit.c</span>
<span class="p_header">index 5f9bcb2e080b..27662e19c3bd 100644</span>
<span class="p_header">--- a/net/sched/act_pedit.c</span>
<span class="p_header">+++ b/net/sched/act_pedit.c</span>
<span class="p_chunk">@@ -68,13 +68,12 @@</span> <span class="p_context"> static int tcf_pedit_init(struct net *net, struct nlattr *nla,</span>
 		}
 		ret = ACT_P_CREATED;
 	} else {
<span class="p_del">-		p = to_pedit(a);</span>
<span class="p_del">-		tcf_hash_release(a, bind);</span>
 		if (bind)
 			return 0;
<span class="p_add">+		tcf_hash_release(a, bind);</span>
 		if (!ovr)
 			return -EEXIST;
<span class="p_del">-</span>
<span class="p_add">+		p = to_pedit(a);</span>
 		if (p-&gt;tcfp_nkeys &amp;&amp; p-&gt;tcfp_nkeys != parm-&gt;nkeys) {
 			keys = kmalloc(ksize, GFP_KERNEL);
 			if (keys == NULL)
<span class="p_header">diff --git a/net/tipc/socket.c b/net/tipc/socket.c</span>
<span class="p_header">index 4093fd81edd5..9dee1aabcfc0 100644</span>
<span class="p_header">--- a/net/tipc/socket.c</span>
<span class="p_header">+++ b/net/tipc/socket.c</span>
<span class="p_chunk">@@ -1696,6 +1696,7 @@</span> <span class="p_context"> static int tipc_accept(struct socket *sock, struct socket *new_sock, int flags)</span>
 	res = tipc_sk_create(sock_net(sock-&gt;sk), new_sock, 0, 1);
 	if (res)
 		goto exit;
<span class="p_add">+	security_sk_clone(sock-&gt;sk, new_sock-&gt;sk);</span>
 
 	new_sk = new_sock-&gt;sk;
 	new_port = &amp;tipc_sk(new_sk)-&gt;port;
<span class="p_header">diff --git a/scripts/kconfig/streamline_config.pl b/scripts/kconfig/streamline_config.pl</span>
<span class="p_header">index 9cb8522d8d22..f3d3fb42b873 100644</span>
<span class="p_header">--- a/scripts/kconfig/streamline_config.pl</span>
<span class="p_header">+++ b/scripts/kconfig/streamline_config.pl</span>
<span class="p_chunk">@@ -137,7 +137,7 @@</span> <span class="p_context"> my $ksource = ($ARGV[0] ? $ARGV[0] : &#39;.&#39;);</span>
 my $kconfig = $ARGV[1];
 my $lsmod_file = $ENV{&#39;LSMOD&#39;};
 
<span class="p_del">-my @makefiles = `find $ksource -name Makefile 2&gt;/dev/null`;</span>
<span class="p_add">+my @makefiles = `find $ksource -name Makefile -or -name Kbuild 2&gt;/dev/null`;</span>
 chomp @makefiles;
 
 my %depends;
<span class="p_header">diff --git a/security/inode.c b/security/inode.c</span>
<span class="p_header">index 43ce6e19015f..617c7ce219e8 100644</span>
<span class="p_header">--- a/security/inode.c</span>
<span class="p_header">+++ b/security/inode.c</span>
<span class="p_chunk">@@ -215,19 +215,17 @@</span> <span class="p_context"> void securityfs_remove(struct dentry *dentry)</span>
 }
 EXPORT_SYMBOL_GPL(securityfs_remove);
 
<span class="p_del">-static struct kobject *security_kobj;</span>
<span class="p_del">-</span>
 static int __init securityfs_init(void)
 {
 	int retval;
 
<span class="p_del">-	security_kobj = kobject_create_and_add(&quot;security&quot;, kernel_kobj);</span>
<span class="p_del">-	if (!security_kobj)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	retval = sysfs_create_mount_point(kernel_kobj, &quot;security&quot;);</span>
<span class="p_add">+	if (retval)</span>
<span class="p_add">+		return retval;</span>
 
 	retval = register_filesystem(&amp;fs_type);
 	if (retval)
<span class="p_del">-		kobject_put(security_kobj);</span>
<span class="p_add">+		sysfs_remove_mount_point(kernel_kobj, &quot;security&quot;);</span>
 	return retval;
 }
 
<span class="p_header">diff --git a/security/integrity/ima/ima_policy.c b/security/integrity/ima/ima_policy.c</span>
<span class="p_header">index 40a7488f6721..b402bab98f54 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_policy.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_policy.c</span>
<span class="p_chunk">@@ -27,6 +27,8 @@</span> <span class="p_context"></span>
 #define IMA_UID		0x0008
 #define IMA_FOWNER	0x0010
 #define IMA_FSUUID	0x0020
<span class="p_add">+#define IMA_INMASK	0x0040</span>
<span class="p_add">+#define IMA_EUID	0x0080</span>
 
 #define UNKNOWN		0
 #define MEASURE		0x0001	/* same as IMA_MEASURE */
<span class="p_chunk">@@ -173,6 +175,9 @@</span> <span class="p_context"> static bool ima_match_rules(struct ima_rule_entry *rule,</span>
 	if ((rule-&gt;flags &amp; IMA_MASK) &amp;&amp;
 	    (rule-&gt;mask != mask &amp;&amp; func != POST_SETATTR))
 		return false;
<span class="p_add">+	if ((rule-&gt;flags &amp; IMA_INMASK) &amp;&amp;</span>
<span class="p_add">+	    (!(rule-&gt;mask &amp; mask) &amp;&amp; func != POST_SETATTR))</span>
<span class="p_add">+		return false;</span>
 	if ((rule-&gt;flags &amp; IMA_FSMAGIC)
 	    &amp;&amp; rule-&gt;fsmagic != inode-&gt;i_sb-&gt;s_magic)
 		return false;
<span class="p_chunk">@@ -181,6 +186,16 @@</span> <span class="p_context"> static bool ima_match_rules(struct ima_rule_entry *rule,</span>
 		return false;
 	if ((rule-&gt;flags &amp; IMA_UID) &amp;&amp; !uid_eq(rule-&gt;uid, cred-&gt;uid))
 		return false;
<span class="p_add">+	if (rule-&gt;flags &amp; IMA_EUID) {</span>
<span class="p_add">+		if (has_capability_noaudit(current, CAP_SETUID)) {</span>
<span class="p_add">+			if (!uid_eq(rule-&gt;uid, cred-&gt;euid)</span>
<span class="p_add">+			    &amp;&amp; !uid_eq(rule-&gt;uid, cred-&gt;suid)</span>
<span class="p_add">+			    &amp;&amp; !uid_eq(rule-&gt;uid, cred-&gt;uid))</span>
<span class="p_add">+				return false;</span>
<span class="p_add">+		} else if (!uid_eq(rule-&gt;uid, cred-&gt;euid))</span>
<span class="p_add">+			return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if ((rule-&gt;flags &amp; IMA_FOWNER) &amp;&amp; !uid_eq(rule-&gt;fowner, inode-&gt;i_uid))
 		return false;
 	for (i = 0; i &lt; MAX_LSM_RULES; i++) {
<span class="p_chunk">@@ -352,7 +367,8 @@</span> <span class="p_context"> enum {</span>
 	Opt_audit,
 	Opt_obj_user, Opt_obj_role, Opt_obj_type,
 	Opt_subj_user, Opt_subj_role, Opt_subj_type,
<span class="p_del">-	Opt_func, Opt_mask, Opt_fsmagic, Opt_uid, Opt_fowner,</span>
<span class="p_add">+	Opt_func, Opt_mask, Opt_fsmagic,</span>
<span class="p_add">+	Opt_uid, Opt_euid, Opt_fowner,</span>
 	Opt_appraise_type, Opt_fsuuid, Opt_permit_directio
 };
 
<span class="p_chunk">@@ -373,6 +389,7 @@</span> <span class="p_context"> static match_table_t policy_tokens = {</span>
 	{Opt_fsmagic, &quot;fsmagic=%s&quot;},
 	{Opt_fsuuid, &quot;fsuuid=%s&quot;},
 	{Opt_uid, &quot;uid=%s&quot;},
<span class="p_add">+	{Opt_euid, &quot;euid=%s&quot;},</span>
 	{Opt_fowner, &quot;fowner=%s&quot;},
 	{Opt_appraise_type, &quot;appraise_type=%s&quot;},
 	{Opt_permit_directio, &quot;permit_directio&quot;},
<span class="p_chunk">@@ -414,6 +431,7 @@</span> <span class="p_context"> static void ima_log_string(struct audit_buffer *ab, char *key, char *value)</span>
 static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)
 {
 	struct audit_buffer *ab;
<span class="p_add">+	char *from;</span>
 	char *p;
 	int result = 0;
 
<span class="p_chunk">@@ -502,18 +520,23 @@</span> <span class="p_context"> static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)</span>
 			if (entry-&gt;mask)
 				result = -EINVAL;
 
<span class="p_del">-			if ((strcmp(args[0].from, &quot;MAY_EXEC&quot;)) == 0)</span>
<span class="p_add">+			from = args[0].from;</span>
<span class="p_add">+			if (*from == &#39;^&#39;)</span>
<span class="p_add">+				from++;</span>
<span class="p_add">+</span>
<span class="p_add">+			if ((strcmp(from, &quot;MAY_EXEC&quot;)) == 0)</span>
 				entry-&gt;mask = MAY_EXEC;
<span class="p_del">-			else if (strcmp(args[0].from, &quot;MAY_WRITE&quot;) == 0)</span>
<span class="p_add">+			else if (strcmp(from, &quot;MAY_WRITE&quot;) == 0)</span>
 				entry-&gt;mask = MAY_WRITE;
<span class="p_del">-			else if (strcmp(args[0].from, &quot;MAY_READ&quot;) == 0)</span>
<span class="p_add">+			else if (strcmp(from, &quot;MAY_READ&quot;) == 0)</span>
 				entry-&gt;mask = MAY_READ;
<span class="p_del">-			else if (strcmp(args[0].from, &quot;MAY_APPEND&quot;) == 0)</span>
<span class="p_add">+			else if (strcmp(from, &quot;MAY_APPEND&quot;) == 0)</span>
 				entry-&gt;mask = MAY_APPEND;
 			else
 				result = -EINVAL;
 			if (!result)
<span class="p_del">-				entry-&gt;flags |= IMA_MASK;</span>
<span class="p_add">+				entry-&gt;flags |= (*args[0].from == &#39;^&#39;)</span>
<span class="p_add">+				     ? IMA_INMASK : IMA_MASK;</span>
 			break;
 		case Opt_fsmagic:
 			ima_log_string(ab, &quot;fsmagic&quot;, args[0].from);
<span class="p_chunk">@@ -543,6 +566,9 @@</span> <span class="p_context"> static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)</span>
 			break;
 		case Opt_uid:
 			ima_log_string(ab, &quot;uid&quot;, args[0].from);
<span class="p_add">+		case Opt_euid:</span>
<span class="p_add">+			if (token == Opt_euid)</span>
<span class="p_add">+				ima_log_string(ab, &quot;euid&quot;, args[0].from);</span>
 
 			if (uid_valid(entry-&gt;uid)) {
 				result = -EINVAL;
<span class="p_chunk">@@ -551,11 +577,14 @@</span> <span class="p_context"> static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)</span>
 
 			result = kstrtoul(args[0].from, 10, &amp;lnum);
 			if (!result) {
<span class="p_del">-				entry-&gt;uid = make_kuid(current_user_ns(), (uid_t)lnum);</span>
<span class="p_del">-				if (!uid_valid(entry-&gt;uid) || (((uid_t)lnum) != lnum))</span>
<span class="p_add">+				entry-&gt;uid = make_kuid(current_user_ns(),</span>
<span class="p_add">+						       (uid_t) lnum);</span>
<span class="p_add">+				if (!uid_valid(entry-&gt;uid) ||</span>
<span class="p_add">+				    (uid_t)lnum != lnum)</span>
 					result = -EINVAL;
 				else
<span class="p_del">-					entry-&gt;flags |= IMA_UID;</span>
<span class="p_add">+					entry-&gt;flags |= (token == Opt_uid)</span>
<span class="p_add">+					    ? IMA_UID : IMA_EUID;</span>
 			}
 			break;
 		case Opt_fowner:
<span class="p_header">diff --git a/security/selinux/selinuxfs.c b/security/selinux/selinuxfs.c</span>
<span class="p_header">index 138949a31eab..181fcd3994a8 100644</span>
<span class="p_header">--- a/security/selinux/selinuxfs.c</span>
<span class="p_header">+++ b/security/selinux/selinuxfs.c</span>
<span class="p_chunk">@@ -1899,7 +1899,6 @@</span> <span class="p_context"> static struct file_system_type sel_fs_type = {</span>
 };
 
 struct vfsmount *selinuxfs_mount;
<span class="p_del">-static struct kobject *selinuxfs_kobj;</span>
 
 static int __init init_sel_fs(void)
 {
<span class="p_chunk">@@ -1908,13 +1907,13 @@</span> <span class="p_context"> static int __init init_sel_fs(void)</span>
 	if (!selinux_enabled)
 		return 0;
 
<span class="p_del">-	selinuxfs_kobj = kobject_create_and_add(&quot;selinux&quot;, fs_kobj);</span>
<span class="p_del">-	if (!selinuxfs_kobj)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+	err = sysfs_create_mount_point(fs_kobj, &quot;selinux&quot;);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
 
 	err = register_filesystem(&amp;sel_fs_type);
 	if (err) {
<span class="p_del">-		kobject_put(selinuxfs_kobj);</span>
<span class="p_add">+		sysfs_remove_mount_point(fs_kobj, &quot;selinux&quot;);</span>
 		return err;
 	}
 
<span class="p_chunk">@@ -1933,7 +1932,7 @@</span> <span class="p_context"> __initcall(init_sel_fs);</span>
 #ifdef CONFIG_SECURITY_SELINUX_DISABLE
 void exit_sel_fs(void)
 {
<span class="p_del">-	kobject_put(selinuxfs_kobj);</span>
<span class="p_add">+	sysfs_remove_mount_point(fs_kobj, &quot;selinux&quot;);</span>
 	kern_unmount(selinuxfs_mount);
 	unregister_filesystem(&amp;sel_fs_type);
 }
<span class="p_header">diff --git a/security/smack/smackfs.c b/security/smack/smackfs.c</span>
<span class="p_header">index 32b248820840..8608fd72580a 100644</span>
<span class="p_header">--- a/security/smack/smackfs.c</span>
<span class="p_header">+++ b/security/smack/smackfs.c</span>
<span class="p_chunk">@@ -2136,16 +2136,16 @@</span> <span class="p_context"> static const struct file_operations smk_revoke_subj_ops = {</span>
 	.llseek		= generic_file_llseek,
 };
 
<span class="p_del">-static struct kset *smackfs_kset;</span>
 /**
  * smk_init_sysfs - initialize /sys/fs/smackfs
  *
  */
 static int smk_init_sysfs(void)
 {
<span class="p_del">-	smackfs_kset = kset_create_and_add(&quot;smackfs&quot;, NULL, fs_kobj);</span>
<span class="p_del">-	if (!smackfs_kset)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+	err = sysfs_create_mount_point(fs_kobj, &quot;smackfs&quot;);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/sound/firewire/amdtp.c b/sound/firewire/amdtp.c</span>
<span class="p_header">index 95fc2eaf11dc..b960b7f26664 100644</span>
<span class="p_header">--- a/sound/firewire/amdtp.c</span>
<span class="p_header">+++ b/sound/firewire/amdtp.c</span>
<span class="p_chunk">@@ -678,8 +678,9 @@</span> <span class="p_context"> static void handle_in_packet(struct amdtp_stream *s,</span>
 	    s-&gt;data_block_counter != UINT_MAX)
 		data_block_counter = s-&gt;data_block_counter;
 
<span class="p_del">-	if (((s-&gt;flags &amp; CIP_SKIP_DBC_ZERO_CHECK) &amp;&amp; data_block_counter == 0) ||</span>
<span class="p_del">-	    (s-&gt;data_block_counter == UINT_MAX)) {</span>
<span class="p_add">+	if (((s-&gt;flags &amp; CIP_SKIP_DBC_ZERO_CHECK) &amp;&amp;</span>
<span class="p_add">+	     data_block_counter == s-&gt;tx_first_dbc) ||</span>
<span class="p_add">+	    s-&gt;data_block_counter == UINT_MAX) {</span>
 		lost = false;
 	} else if (!(s-&gt;flags &amp; CIP_DBC_IS_END_EVENT)) {
 		lost = data_block_counter != s-&gt;data_block_counter;
<span class="p_header">diff --git a/sound/firewire/amdtp.h b/sound/firewire/amdtp.h</span>
<span class="p_header">index 4823c08196ac..6ce95b05ba2e 100644</span>
<span class="p_header">--- a/sound/firewire/amdtp.h</span>
<span class="p_header">+++ b/sound/firewire/amdtp.h</span>
<span class="p_chunk">@@ -131,6 +131,8 @@</span> <span class="p_context"> struct amdtp_stream {</span>
 
 	/* quirk: fixed interval of dbc between previos/current packets. */
 	unsigned int tx_dbc_interval;
<span class="p_add">+	/* quirk: indicate the value of dbc field in a first packet. */</span>
<span class="p_add">+	unsigned int tx_first_dbc;</span>
 
 	/* quirk: the first count of data blocks in an rx packet for MIDI */
 	unsigned int rx_blocks_for_midi;
<span class="p_header">diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c</span>
<span class="p_header">index 3e2ed8e82cbc..6813b0f6f185 100644</span>
<span class="p_header">--- a/sound/firewire/fireworks/fireworks.c</span>
<span class="p_header">+++ b/sound/firewire/fireworks/fireworks.c</span>
<span class="p_chunk">@@ -237,8 +237,16 @@</span> <span class="p_context"> efw_probe(struct fw_unit *unit,</span>
 	err = get_hardware_info(efw);
 	if (err &lt; 0)
 		goto error;
<span class="p_add">+	/* AudioFire8 (since 2009) and AudioFirePre8 */</span>
 	if (entry-&gt;model_id == MODEL_ECHO_AUDIOFIRE_9)
 		efw-&gt;is_af9 = true;
<span class="p_add">+	/* These models uses the same firmware. */</span>
<span class="p_add">+	if (entry-&gt;model_id == MODEL_ECHO_AUDIOFIRE_2 ||</span>
<span class="p_add">+	    entry-&gt;model_id == MODEL_ECHO_AUDIOFIRE_4 ||</span>
<span class="p_add">+	    entry-&gt;model_id == MODEL_ECHO_AUDIOFIRE_9 ||</span>
<span class="p_add">+	    entry-&gt;model_id == MODEL_GIBSON_RIP ||</span>
<span class="p_add">+	    entry-&gt;model_id == MODEL_GIBSON_GOLDTOP)</span>
<span class="p_add">+		efw-&gt;is_fireworks3 = true;</span>
 
 	snd_efw_proc_init(efw);
 
<span class="p_header">diff --git a/sound/firewire/fireworks/fireworks.h b/sound/firewire/fireworks/fireworks.h</span>
<span class="p_header">index 4f0201a95222..084d414b228c 100644</span>
<span class="p_header">--- a/sound/firewire/fireworks/fireworks.h</span>
<span class="p_header">+++ b/sound/firewire/fireworks/fireworks.h</span>
<span class="p_chunk">@@ -71,6 +71,7 @@</span> <span class="p_context"> struct snd_efw {</span>
 
 	/* for quirks */
 	bool is_af9;
<span class="p_add">+	bool is_fireworks3;</span>
 	u32 firmware_version;
 
 	unsigned int midi_in_ports;
<span class="p_header">diff --git a/sound/firewire/fireworks/fireworks_stream.c b/sound/firewire/fireworks/fireworks_stream.c</span>
<span class="p_header">index b985fc5ebdc6..30c4042524d0 100644</span>
<span class="p_header">--- a/sound/firewire/fireworks/fireworks_stream.c</span>
<span class="p_header">+++ b/sound/firewire/fireworks/fireworks_stream.c</span>
<span class="p_chunk">@@ -167,6 +167,15 @@</span> <span class="p_context"> int snd_efw_stream_init_duplex(struct snd_efw *efw)</span>
 	efw-&gt;tx_stream.flags |= CIP_DBC_IS_END_EVENT;
 	/* Fireworks reset dbc at bus reset. */
 	efw-&gt;tx_stream.flags |= CIP_SKIP_DBC_ZERO_CHECK;
<span class="p_add">+	/*</span>
<span class="p_add">+	 * But Recent firmwares starts packets with non-zero dbc.</span>
<span class="p_add">+	 * Driver version 5.7.6 installs firmware version 5.7.3.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (efw-&gt;is_fireworks3 &amp;&amp;</span>
<span class="p_add">+	    (efw-&gt;firmware_version == 0x5070000 ||</span>
<span class="p_add">+	     efw-&gt;firmware_version == 0x5070300 ||</span>
<span class="p_add">+	     efw-&gt;firmware_version == 0x5080000))</span>
<span class="p_add">+		efw-&gt;tx_stream.tx_first_dbc = 0x02;</span>
 	/* AudioFire9 always reports wrong dbs. */
 	if (efw-&gt;is_af9)
 		efw-&gt;tx_stream.flags |= CIP_WRONG_DBS;
<span class="p_header">diff --git a/sound/pci/hda/patch_cirrus.c b/sound/pci/hda/patch_cirrus.c</span>
<span class="p_header">index 6928c3290163..e5a2dccceea1 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_cirrus.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_cirrus.c</span>
<span class="p_chunk">@@ -1001,9 +1001,7 @@</span> <span class="p_context"> static void cs4210_spdif_automute(struct hda_codec *codec,</span>
 
 	spec-&gt;spdif_present = spdif_present;
 	/* SPDIF TX on/off */
<span class="p_del">-	if (spdif_present)</span>
<span class="p_del">-		snd_hda_set_pin_ctl(codec, spdif_pin,</span>
<span class="p_del">-				    spdif_present ? PIN_OUT : 0);</span>
<span class="p_add">+	snd_hda_set_pin_ctl(codec, spdif_pin, spdif_present ? PIN_OUT : 0);</span>
 
 	cs_automute(codec);
 }
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 78d333c4a526..95ad148ddb6c 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -2301,7 +2301,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc882_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x106b, 0x4300, &quot;iMac 9,1&quot;, ALC889_FIXUP_IMAC91_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4600, &quot;MacbookPro 5,2&quot;, ALC889_FIXUP_IMAC91_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4900, &quot;iMac 9,1 Aluminum&quot;, ALC889_FIXUP_IMAC91_VREF),
<span class="p_del">-	SND_PCI_QUIRK(0x106b, 0x4a00, &quot;Macbook 5,2&quot;, ALC889_FIXUP_IMAC91_VREF),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x106b, 0x4a00, &quot;Macbook 5,2&quot;, ALC889_FIXUP_MBA11_VREF),</span>
 
 	SND_PCI_QUIRK(0x1071, 0x8258, &quot;Evesham Voyaeger&quot;, ALC882_FIXUP_EAPD),
 	SND_PCI_QUIRK(0x1462, 0x7350, &quot;MSI-7350&quot;, ALC889_FIXUP_CD),
<span class="p_chunk">@@ -4822,6 +4822,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x063f, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x064a, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x064b, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x069a, &quot;Dell Vostro 5480&quot;, ALC290_FIXUP_SUBWOOFER_HSJACK),</span>
 	SND_PCI_QUIRK(0x1028, 0x06c7, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x0668, &quot;Dell&quot;, ALC255_FIXUP_DELL2_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x0669, &quot;Dell&quot;, ALC255_FIXUP_DELL2_MIC_NO_PRESENCE),
<span class="p_header">diff --git a/sound/pci/hda/patch_sigmatel.c b/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_header">index ede3fa19f801..78e0c83993d5 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_chunk">@@ -2951,7 +2951,8 @@</span> <span class="p_context"> static const struct snd_pci_quirk stac92hd83xxx_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(PCI_VENDOR_ID_HP, 0x148a,
 		      &quot;HP Mini&quot;, STAC_92HD83XXX_HP_LED),
 	SND_PCI_QUIRK_VENDOR(PCI_VENDOR_ID_HP, &quot;HP&quot;, STAC_92HD83XXX_HP),
<span class="p_del">-	SND_PCI_QUIRK(PCI_VENDOR_ID_TOSHIBA, 0xfa91,</span>
<span class="p_add">+	/* match both for 0xfa91 and 0xfa93 */</span>
<span class="p_add">+	SND_PCI_QUIRK_MASK(PCI_VENDOR_ID_TOSHIBA, 0xfffd, 0xfa91,</span>
 		      &quot;Toshiba Satellite S50D&quot;, STAC_92HD83XXX_GPIO10_EAPD),
 	{} /* terminator */
 };
<span class="p_header">diff --git a/sound/soc/codecs/pcm1681.c b/sound/soc/codecs/pcm1681.c</span>
<span class="p_header">index 477e13d30971..e7ba557979cb 100644</span>
<span class="p_header">--- a/sound/soc/codecs/pcm1681.c</span>
<span class="p_header">+++ b/sound/soc/codecs/pcm1681.c</span>
<span class="p_chunk">@@ -102,7 +102,7 @@</span> <span class="p_context"> static int pcm1681_set_deemph(struct snd_soc_codec *codec)</span>
 
 	if (val != -1) {
 		regmap_update_bits(priv-&gt;regmap, PCM1681_DEEMPH_CONTROL,
<span class="p_del">-					PCM1681_DEEMPH_RATE_MASK, val);</span>
<span class="p_add">+				   PCM1681_DEEMPH_RATE_MASK, val &lt;&lt; 3);</span>
 		enable = 1;
 	} else
 		enable = 0;
<span class="p_header">diff --git a/sound/usb/card.c b/sound/usb/card.c</span>
<span class="p_header">index 8df7e1d14603..34f934095ddd 100644</span>
<span class="p_header">--- a/sound/usb/card.c</span>
<span class="p_header">+++ b/sound/usb/card.c</span>
<span class="p_chunk">@@ -663,7 +663,7 @@</span> <span class="p_context"> int snd_usb_autoresume(struct snd_usb_audio *chip)</span>
 	int err = -ENODEV;
 
 	down_read(&amp;chip-&gt;shutdown_rwsem);
<span class="p_del">-	if (chip-&gt;probing &amp;&amp; chip-&gt;in_pm)</span>
<span class="p_add">+	if (chip-&gt;probing || chip-&gt;in_pm)</span>
 		err = 0;
 	else if (!chip-&gt;shutdown)
 		err = usb_autopm_get_interface(chip-&gt;pm_intf);
<span class="p_header">diff --git a/sound/usb/mixer_maps.c b/sound/usb/mixer_maps.c</span>
<span class="p_header">index b16be3944213..9a3e1076a5b1 100644</span>
<span class="p_header">--- a/sound/usb/mixer_maps.c</span>
<span class="p_header">+++ b/sound/usb/mixer_maps.c</span>
<span class="p_chunk">@@ -336,6 +336,20 @@</span> <span class="p_context"> static const struct usbmix_name_map scms_usb3318_map[] = {</span>
 	{ 0 }
 };
 
<span class="p_add">+/* Bose companion 5, the dB conversion factor is 16 instead of 256 */</span>
<span class="p_add">+static struct usbmix_dB_map bose_companion5_dB = {-5006, -6};</span>
<span class="p_add">+static struct usbmix_name_map bose_companion5_map[] = {</span>
<span class="p_add">+	{ 3, NULL, .dB = &amp;bose_companion5_dB },</span>
<span class="p_add">+	{ 0 }	/* terminator */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* Dragonfly DAC 1.2, the dB conversion factor is 1 instead of 256 */</span>
<span class="p_add">+static struct usbmix_dB_map dragonfly_1_2_dB = {0, 5000};</span>
<span class="p_add">+static struct usbmix_name_map dragonfly_1_2_map[] = {</span>
<span class="p_add">+	{ 7, NULL, .dB = &amp;dragonfly_1_2_dB },</span>
<span class="p_add">+	{ 0 }	/* terminator */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /*
  * Control map entries
  */
<span class="p_chunk">@@ -442,6 +456,16 @@</span> <span class="p_context"> static struct usbmix_ctl_map usbmix_ctl_maps[] = {</span>
 		.id = USB_ID(0x25c4, 0x0003),
 		.map = scms_usb3318_map,
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		/* Bose Companion 5 */</span>
<span class="p_add">+		.id = USB_ID(0x05a7, 0x1020),</span>
<span class="p_add">+		.map = bose_companion5_map,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		/* Dragonfly DAC 1.2 */</span>
<span class="p_add">+		.id = USB_ID(0x21b4, 0x0081),</span>
<span class="p_add">+		.map = dragonfly_1_2_map,</span>
<span class="p_add">+	},</span>
 	{ 0 } /* terminator */
 };
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



