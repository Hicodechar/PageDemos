
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v2] treewide: fix a bunch of typos - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v2] treewide: fix a bunch of typos</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=125921">Masahiro Yamada</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 30, 2016, 11:57 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1472601465-3009-1-git-send-email-yamada.masahiro@socionext.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9306183/mbox/"
   >mbox</a>
|
   <a href="/patch/9306183/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9306183/">/patch/9306183/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	1402D607F0 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 31 Aug 2016 00:00:40 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id DEB7A28D99
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 31 Aug 2016 00:00:39 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id D0CB628DBB; Wed, 31 Aug 2016 00:00:39 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 1DE9228D99
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 31 Aug 2016 00:00:26 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751873AbcHaAAS (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 30 Aug 2016 20:00:18 -0400
Received: from conuserg-10.nifty.com ([210.131.2.77]:51828 &quot;EHLO
	conuserg-10.nifty.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751143AbcHaAAE (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 30 Aug 2016 20:00:04 -0400
Received: from grover.sesame (FL1-111-169-71-157.osk.mesh.ad.jp
	[111.169.71.157]) (authenticated)
	by conuserg-10.nifty.com with ESMTP id u7UNvp5Q025873;
	Wed, 31 Aug 2016 08:57:55 +0900
DKIM-Filter: OpenDKIM Filter v2.10.3 conuserg-10.nifty.com u7UNvp5Q025873
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=nifty.com;
	s=dec2015msa; t=1472601475;
	bh=Dll9EDVBRmefzUef4jwMsaWxo7GmHCp3opPZEyOUWtE=;
	h=From:To:Cc:Subject:Date:From;
	b=jo3OXgM6Aa4W9bPrIqnSMjOZjp4qGSUwtArXBqw3oMp0HN/KTfPb5MUysVGB4Yy6L
	CeosLwGEoAbJqbh0VhrcsDPX5TefLcX99eaeSYExlYUz7jnlCCu0RKDAEIARWv+i9/
	KLs+C/cHdAIrTJ/Ggm6TRPJTFVf9S9u2N4+TVQR/6FjLVitUmBcBEN0m8psy/z8adl
	FGFUW0wrAOHJMBr2/CS3vfImV5q+PCzOuK1Lk9gmhlyLpbrsy0hiRbEJkGN4IVqd1T
	uQrBQQS/ec/Ajo4jofhDgren0tMDMtRcLdW/SFyP+hZG1CYurQPQ9PYCn9DbanI08c
	eroFrFaXvUTfg==
X-Nifty-SrcIP: [111.169.71.157]
From: Masahiro Yamada &lt;yamada.masahiro@socionext.com&gt;
To: Jiri Kosina &lt;trivial@kernel.org&gt;
Cc: Geert Uytterhoeven &lt;geert@linux-m68k.org&gt;,
	Randy Dunlap &lt;rdunlap@infradead.org&gt;, linux-kernel@vger.kernel.org,
	Masahiro Yamada &lt;yamada.masahiro@socionext.com&gt;
Subject: [PATCH v2] treewide: fix a bunch of typos
Date: Wed, 31 Aug 2016 08:57:45 +0900
Message-Id: &lt;1472601465-3009-1-git-send-email-yamada.masahiro@socionext.com&gt;
X-Mailer: git-send-email 1.9.1
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=125921">Masahiro Yamada</a> - Aug. 30, 2016, 11:57 p.m.</div>
<pre class="content">
Spelling corrections for (among other things):
  * according
  * across
  * additional
  * address
  * against
  * algorithm
  * align
  * alignment
  * application
  * appropriate
  * associate
  * capability
  * chosen
  * communication
  * compatibility
  * compatible
  * configuration
  * controlled
  * controller
  * effective
  * enable
  * environment
  * especially
  * explicit
  * filesystem
  * following
  * guarantee
  * implementation
  * implemented
  * initial
  * initialize
  * occur
  * omitting
  * overridden
  * override
  * partition
  * propagate
  * resource
  * split
  * support
  * switch
  * variable
  * width
<span class="signed-off-by">
Signed-off-by: Masahiro Yamada &lt;yamada.masahiro@socionext.com&gt;</span>
<span class="reviewed-by">Reviewed-by: Randy Dunlap &lt;rdunlap@infradead.org&gt;</span>
<span class="reviewed-by">Reviewed-by: Geert Uytterhoeven &lt;geert@linux-m68k.org&gt;</span>
---
Hi Jiri,

This patch can be cleanly applied to v4.8-rc1.
(Then, it can be merged with next-20160825 without any conflict)


Changes in v2:
  - Fixes pointed out by Randy:
     https://lkml.org/lkml/2016/8/8/1
     https://lkml.org/lkml/2016/8/8/6
  - s/extened/extended/
     in drivers/usb/host/xhci.h

 .../testing/sysfs-bus-event_source-devices-events  |  2 +-
 Documentation/DocBook/libata.tmpl                  |  2 +-
 Documentation/acpi/method-customizing.txt          |  2 +-
 Documentation/acpi/method-tracing.txt              |  2 +-
 Documentation/devicetree/bindings/mfd/qcom-rpm.txt |  2 +-
 .../devicetree/bindings/pci/pci-armada8k.txt       |  2 +-
 .../bindings/pinctrl/allwinner,sunxi-pinctrl.txt   |  2 +-
 .../devicetree/bindings/power/pd-samsung.txt       |  2 +-
 .../bindings/regulator/ti-abb-regulator.txt        |  2 +-
 .../devicetree/bindings/soc/rockchip/grf.txt       |  4 +-
 .../devicetree/bindings/sound/rockchip-i2s.txt     |  2 +-
 .../devicetree/bindings/sound/sun4i-i2s.txt        |  2 +-
 Documentation/filesystems/autofs4.txt              |  2 +-
 Documentation/filesystems/orangefs.txt             |  2 +-
 Documentation/media/dvb-drivers/dvb-usb.rst        |  2 +-
 Documentation/media/uapi/v4l/vidioc-g-parm.rst     |  2 +-
 Documentation/memory-hotplug.txt                   |  4 +-
 Documentation/scsi/ChangeLog.lpfc                  |  2 +-
 Documentation/scsi/ChangeLog.megaraid_sas          |  2 +-
 Documentation/xtensa/atomctl.txt                   |  2 +-
 arch/arc/kernel/unwind.c                           |  4 +-
 arch/arc/mm/tlb.c                                  |  6 +--
 arch/arm/boot/compressed/head.S                    |  2 +-
 arch/arm/boot/dts/r8a7779.dtsi                     |  2 +-
 arch/arm/boot/dts/r8a7790.dtsi                     |  2 +-
 arch/arm/boot/dts/r8a7791.dtsi                     |  2 +-
 arch/arm/boot/dts/r8a7794.dtsi                     |  2 +-
 arch/arm/include/asm/mach/flash.h                  |  2 +-
 arch/arm/include/asm/xen/page-coherent.h           |  2 +-
 arch/arm/mach-omap2/dma.c                          |  2 +-
 arch/arm/mach-omap2/omap_twl.c                     |  2 +-
 arch/arm/mach-w90x900/dev.c                        |  2 +-
 arch/arm/mm/cache-v7.S                             |  2 +-
 arch/arm/plat-omap/dmtimer.c                       |  2 +-
 arch/arm/plat-samsung/include/plat/gpio-cfg.h      |  2 +-
 arch/arm64/Kconfig                                 |  2 +-
 arch/ia64/sn/kernel/sn2/sn_hwperf.c                |  2 +-
 arch/m68k/ifpsp060/src/isp.S                       |  2 +-
 arch/m68k/math-emu/fp_util.S                       |  8 ++--
 arch/mips/Kconfig                                  |  4 +-
 arch/openrisc/kernel/entry.S                       |  4 +-
 arch/openrisc/kernel/head.S                        |  7 ++--
 arch/openrisc/kernel/vmlinux.lds.S                 |  4 +-
 arch/powerpc/boot/dts/fsl/mpc8569mds.dts           |  2 +-
 arch/powerpc/include/asm/book3s/64/mmu.h           |  2 +-
 arch/powerpc/include/asm/fsl_hcalls.h              |  2 +-
 arch/powerpc/kernel/entry_64.S                     |  3 +-
 arch/powerpc/platforms/powernv/pci-ioda.c          |  2 +-
 arch/powerpc/platforms/pseries/iommu.c             |  2 +-
 arch/sh/kernel/irq.c                               |  2 +-
 arch/sparc/include/asm/hypervisor.h                |  2 +-
 arch/sparc/kernel/visemul.c                        |  2 +-
 arch/sparc/mm/srmmu.c                              |  2 +-
 arch/x86/crypto/cast5_avx_glue.c                   |  2 +-
 arch/x86/crypto/cast6_avx_glue.c                   |  2 +-
 arch/x86/kvm/vmx.c                                 |  2 +-
 .../intel-mid/device_libs/platform_pcal9555a.c     |  2 +-
 .../intel-mid/device_libs/platform_spidev.c        |  2 +-
 arch/xtensa/include/asm/initialize_mmu.h           |  2 +-
 block/blk-merge.c                                  |  2 +-
 block/blk-throttle.c                               |  2 +-
 block/cfq-iosched.c                                |  4 +-
 block/scsi_ioctl.c                                 |  2 +-
 drivers/acpi/Kconfig                               |  2 +-
 drivers/acpi/acpica/acmacros.h                     |  2 +-
 drivers/acpi/acpica/nsload.c                       |  2 +-
 drivers/acpi/resource.c                            |  4 +-
 drivers/ata/libata-eh.c                            |  2 +-
 drivers/atm/iphase.c                               |  4 +-
 drivers/atm/iphase.h                               |  4 +-
 drivers/block/loop.c                               |  2 +-
 drivers/block/mtip32xx/mtip32xx.h                  |  4 +-
 drivers/block/paride/pcd.c                         |  2 +-
 drivers/block/paride/pd.c                          |  2 +-
 drivers/block/paride/pf.c                          |  2 +-
 drivers/block/paride/pg.c                          |  2 +-
 drivers/block/paride/pt.c                          |  2 +-
 drivers/bus/mvebu-mbus.c                           |  2 +-
 drivers/cdrom/gdrom.c                              |  2 +-
 drivers/char/agp/i460-agp.c                        |  2 +-
 drivers/char/lp.c                                  |  2 +-
 drivers/char/pcmcia/cm4000_cs.c                    |  2 +-
 drivers/char/sonypi.c                              |  2 +-
 drivers/clocksource/tcb_clksrc.c                   |  2 +-
 drivers/crypto/caam/ctrl.c                         | 10 ++---
 drivers/crypto/caam/desc.h                         |  2 +-
 drivers/devfreq/devfreq-event.c                    |  2 +-
 drivers/devfreq/devfreq.c                          |  2 +-
 drivers/dma/iop-adma.c                             |  2 +-
 drivers/dma/mv_xor.c                               |  2 +-
 drivers/dma/zx296702_dma.c                         |  2 +-
 drivers/edac/ppc4xx_edac.c                         |  2 +-
 drivers/extcon/extcon-rt8973a.c                    |  2 +-
 drivers/firewire/core-device.c                     |  4 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_powerplay.c      |  2 +-
 drivers/gpu/drm/amd/amdgpu/fiji_smc.c              |  2 +-
 drivers/gpu/drm/amd/amdgpu/iceland_smc.c           |  2 +-
 drivers/gpu/drm/amd/amdgpu/tonga_smc.c             |  2 +-
 drivers/gpu/drm/amd/include/atombios.h             | 46 +++++++++++-----------
 drivers/gpu/drm/amd/powerplay/hwmgr/tonga_hwmgr.c  |  6 +--
 .../gpu/drm/amd/powerplay/inc/hardwaremanager.h    |  2 +-
 drivers/gpu/drm/amd/powerplay/smumgr/fiji_smumgr.c |  2 +-
 .../drm/amd/powerplay/smumgr/polaris10_smumgr.c    |  6 +--
 drivers/gpu/drm/drm_drv.c                          |  2 +-
 drivers/gpu/drm/drm_ioctl.c                        |  4 +-
 drivers/gpu/drm/drm_probe_helper.c                 |  6 +--
 drivers/gpu/drm/i915/i915_gem_render_state.c       |  2 +-
 drivers/gpu/drm/i915/i915_pci.c                    |  4 +-
 drivers/gpu/drm/i915/intel_display.c               |  2 +-
 drivers/gpu/drm/i915/intel_lrc.c                   |  2 +-
 drivers/gpu/drm/nouveau/nouveau_bios.c             |  2 +-
 drivers/gpu/drm/nouveau/nvkm/engine/gr/ctxnv50.c   |  2 +-
 drivers/gpu/drm/radeon/atombios.h                  | 30 +++++++-------
 drivers/hid/hid-appleir.c                          |  2 +-
 drivers/hid/hid-logitech-hidpp.c                   |  4 +-
 drivers/hsi/controllers/omap_ssi_port.c            |  2 +-
 drivers/hwmon/abituguru.c                          |  4 +-
 drivers/i2c/busses/i2c-nomadik.c                   |  2 +-
 drivers/infiniband/core/uverbs_main.c              |  2 +-
 drivers/infiniband/hw/mlx5/odp.c                   |  2 +-
 drivers/infiniband/hw/qib/qib_common.h             |  2 +-
 drivers/infiniband/hw/qib/qib_sd7220.c             |  2 +-
 drivers/infiniband/ulp/iser/iscsi_iser.c           | 10 ++---
 drivers/iommu/dmar.c                               |  2 +-
 drivers/isdn/mISDN/dsp_core.c                      |  2 +-
 drivers/macintosh/via-pmu.c                        |  2 +-
 drivers/mailbox/pl320-ipc.c                        |  2 +-
 drivers/md/Kconfig                                 |  2 +-
 drivers/md/bcache/stats.c                          |  2 +-
 .../media/dvb-frontends/drx39xyj/drx_dap_fasi.h    |  2 +-
 drivers/media/dvb-frontends/drx39xyj/drx_driver.h  | 14 +++----
 drivers/media/i2c/adv7183_regs.h                   |  2 +-
 drivers/media/pci/bt8xx/bttv-audio-hook.c          |  2 +-
 drivers/media/pci/bt8xx/bttv-audio-hook.h          |  2 +-
 drivers/media/pci/bt8xx/bttv-risc.c                |  2 +-
 drivers/media/pci/ivtv/ivtv-yuv.c                  |  2 +-
 drivers/media/platform/exynos4-is/fimc-core.h      |  2 +-
 drivers/media/rc/img-ir/img-ir-hw.c                |  2 +-
 drivers/media/usb/dvb-usb-v2/mxl111sf-i2c.c        |  4 +-
 drivers/media/usb/gspca/sonixj.c                   |  2 +-
 drivers/media/usb/gspca/t613.c                     | 10 +++--
 drivers/media/usb/ttusb-budget/dvb-ttusb-budget.c  |  2 +-
 drivers/media/usb/usbvision/usbvision-core.c       |  2 +-
 drivers/media/usb/uvc/uvc_video.c                  |  5 ++-
 drivers/mfd/max77620.c                             |  2 +-
 drivers/misc/pti.c                                 |  4 +-
 drivers/misc/vmw_vmci/vmci_queue_pair.h            |  2 +-
 drivers/mmc/card/block.c                           |  2 +-
 drivers/mmc/host/mmci_qcom_dml.c                   |  2 +-
 drivers/mtd/nand/denali.c                          |  2 +-
 drivers/mtd/nand/fsl_ifc_nand.c                    |  2 +-
 drivers/mtd/nand/gpmi-nand/gpmi-nand.c             |  2 +-
 drivers/mtd/nand/pxa3xx_nand.c                     |  6 +--
 drivers/net/ethernet/broadcom/bcm63xx_enet.c       |  2 +-
 drivers/net/ethernet/broadcom/bnx2x/bnx2x.h        |  2 +-
 drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c   | 10 ++---
 drivers/net/ethernet/chelsio/cxgb4vf/sge.c         |  2 +-
 drivers/net/ethernet/emulex/benet/be_cmds.h        |  2 +-
 drivers/net/ethernet/freescale/fman/mac.c          |  2 +-
 drivers/net/ethernet/hp/hp100.c                    |  2 +-
 drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c |  4 +-
 drivers/net/ethernet/intel/igb/igb_main.c          |  2 +-
 drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c       |  2 +-
 drivers/net/ethernet/micrel/ksz884x.c              | 10 ++---
 drivers/net/ethernet/nuvoton/w90p910_ether.c       |  2 +-
 drivers/net/ethernet/qlogic/qed/qed_vf.c           |  3 +-
 drivers/net/ethernet/qlogic/qlcnic/qlcnic.h        |  2 +-
 .../net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c    |  2 +-
 drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c   |  4 +-
 drivers/net/ethernet/qlogic/qlge/qlge.h            |  4 +-
 drivers/net/ethernet/samsung/sxgbe/sxgbe_main.c    |  8 ++--
 drivers/net/ethernet/stmicro/stmmac/stmmac_main.c  |  2 +-
 drivers/net/ethernet/tehuti/tehuti.c               |  4 +-
 drivers/net/fddi/skfp/cfm.c                        |  2 +-
 drivers/net/fddi/skfp/ecm.c                        |  2 +-
 drivers/net/fddi/skfp/pcmplc.c                     |  2 +-
 drivers/net/fddi/skfp/rmt.c                        |  2 +-
 drivers/net/irda/donauboe.c                        |  2 +-
 drivers/net/usb/cdc_ncm.c                          |  3 +-
 drivers/net/usb/kalmia.c                           |  2 +-
 drivers/net/wimax/i2400m/driver.c                  |  2 +-
 drivers/net/wimax/i2400m/usb-fw.c                  |  2 +-
 drivers/net/wireless/ath/ath10k/wmi.h              | 24 +++++------
 drivers/net/wireless/ath/ath6kl/main.c             |  2 +-
 drivers/net/wireless/ath/ath9k/ani.c               |  4 +-
 .../wireless/broadcom/brcm80211/brcmfmac/chip.c    |  2 +-
 .../net/wireless/broadcom/brcm80211/brcmfmac/p2p.c |  2 +-
 .../wireless/broadcom/brcm80211/brcmfmac/pcie.c    |  2 +-
 .../wireless/broadcom/brcm80211/brcmsmac/aiutils.c |  2 +-
 .../wireless/broadcom/brcm80211/brcmsmac/channel.c |  4 +-
 drivers/net/wireless/intel/ipw2x00/ipw2100.c       |  8 ++--
 drivers/net/wireless/intel/ipw2x00/ipw2200.c       |  8 ++--
 drivers/net/wireless/intersil/hostap/hostap_hw.c   |  2 +-
 drivers/net/wireless/marvell/mwifiex/init.c        |  3 +-
 drivers/net/wireless/marvell/mwifiex/wmm.c         |  8 ++--
 drivers/net/wireless/ralink/rt2x00/rt2400pci.c     |  2 +-
 drivers/net/wireless/ralink/rt2x00/rt2500pci.c     |  2 +-
 drivers/net/wireless/ralink/rt2x00/rt2500usb.c     |  2 +-
 drivers/net/wireless/ralink/rt2x00/rt2x00config.c  |  2 +-
 drivers/net/wireless/ralink/rt2x00/rt61pci.c       |  2 +-
 drivers/net/wireless/ralink/rt2x00/rt73usb.c       |  2 +-
 .../net/wireless/realtek/rtlwifi/rtl8192se/fw.c    |  4 +-
 .../net/wireless/realtek/rtlwifi/rtl8821ae/fw.c    |  4 +-
 drivers/net/wireless/rsi/rsi_91x_main.c            |  2 +-
 drivers/net/wireless/rsi/rsi_91x_usb.c             |  4 +-
 drivers/net/wireless/st/cw1200/cw1200_sdio.c       |  2 +-
 drivers/net/wireless/ti/wl1251/acx.h               |  2 +-
 drivers/net/wireless/ti/wl1251/reg.h               |  2 +-
 drivers/net/wireless/ti/wl12xx/reg.h               |  2 +-
 drivers/net/wireless/ti/wlcore/init.c              |  2 +-
 drivers/nfc/pn533/pn533.c                          |  2 +-
 drivers/nvme/host/rdma.c                           |  2 +-
 drivers/pci/pci.c                                  |  2 +-
 drivers/pinctrl/bcm/Kconfig                        |  2 +-
 drivers/pinctrl/pinconf.c                          |  2 +-
 drivers/platform/x86/thinkpad_acpi.c               |  4 +-
 drivers/power/avs/smartreflex.c                    |  8 ++--
 drivers/regulator/ti-abb-regulator.c               |  4 +-
 drivers/scsi/aic7xxx/aic79xx.h                     |  6 +--
 drivers/scsi/aic7xxx/aic79xx_osm.c                 |  2 +-
 drivers/scsi/bfa/bfa_defs.h                        |  2 +-
 drivers/scsi/bfa/bfa_defs_svc.h                    |  2 +-
 drivers/scsi/bfa/bfa_ioc_ct.c                      |  2 +-
 drivers/scsi/bfa/bfi_ms.h                          |  2 +-
 drivers/scsi/csiostor/csio_mb.c                    |  2 +-
 drivers/scsi/ipr.c                                 |  2 +-
 drivers/scsi/lpfc/lpfc_sli.c                       | 28 ++++++-------
 drivers/scsi/mpt3sas/Kconfig                       |  2 +-
 drivers/scsi/mpt3sas/mpt3sas_ctl.c                 |  8 ++--
 drivers/scsi/mpt3sas/mpt3sas_scsih.c               | 18 ++++-----
 drivers/scsi/osd/osd_initiator.c                   |  2 +-
 drivers/scsi/pm8001/pm8001_init.c                  |  2 +-
 drivers/scsi/pmcraid.c                             |  6 +--
 drivers/scsi/qla2xxx/qla_os.c                      |  2 +-
 drivers/scsi/qla2xxx/qla_target.c                  |  6 +--
 drivers/scsi/qla2xxx/tcm_qla2xxx.c                 |  8 ++--
 drivers/scsi/scsi_transport_sas.c                  |  2 +-
 drivers/scsi/storvsc_drv.c                         |  2 +-
 drivers/scsi/sym53c8xx_2/sym53c8xx.h               |  2 +-
 drivers/spi/spi-omap2-mcspi.c                      |  2 +-
 drivers/staging/gs_fpgaboot/gs_fpgaboot.h          |  2 +-
 drivers/staging/ks7010/ks7010_sdio.c               |  2 +-
 .../staging/lustre/lnet/klnds/o2iblnd/o2iblnd.c    |  4 +-
 .../staging/media/davinci_vpfe/vpfe_mc_capture.c   |  2 +-
 drivers/staging/rtl8192u/ieee80211/ieee80211.h     |  4 +-
 .../staging/rtl8192u/ieee80211/ieee80211_softmac.c |  2 +-
 drivers/staging/rtl8192u/ieee80211/ieee80211_wx.c  |  2 +-
 drivers/staging/rtl8192u/r819xU_cmdpkt.h           |  2 +-
 drivers/staging/wilc1000/linux_wlan.c              |  2 +-
 drivers/staging/wilc1000/wilc_wfi_cfgoperations.c  |  2 +-
 drivers/target/iscsi/iscsi_target.c                |  2 +-
 drivers/target/iscsi/iscsi_target_login.c          |  2 +-
 drivers/target/iscsi/iscsi_target_tpg.c            |  2 +-
 drivers/target/loopback/tcm_loop.c                 |  4 +-
 drivers/target/tcm_fc/tfc_io.c                     |  2 +-
 drivers/tty/n_gsm.c                                |  2 +-
 drivers/tty/serial/crisv10.c                       |  4 +-
 drivers/tty/serial/mpc52xx_uart.c                  |  2 +-
 drivers/tty/serial/serial_core.c                   |  2 +-
 drivers/usb/dwc2/core.c                            |  2 +-
 drivers/usb/gadget/udc/fsl_udc_core.c              | 10 ++---
 drivers/usb/gadget/udc/renesas_usb3.c              |  4 +-
 drivers/usb/host/xhci.h                            |  2 +-
 drivers/vhost/scsi.c                               |  2 +-
 drivers/video/fbdev/intelfb/intelfbdrv.c           |  4 +-
 drivers/video/fbdev/mmp/hw/mmp_spi.c               |  2 +-
 drivers/video/fbdev/tridentfb.c                    |  2 +-
 drivers/watchdog/bcm2835_wdt.c                     |  6 +--
 fs/attr.c                                          |  2 +-
 fs/compat_ioctl.c                                  |  2 +-
 fs/dcache.c                                        |  2 +-
 fs/debugfs/inode.c                                 |  2 +-
 fs/dlm/ast.c                                       |  2 +-
 fs/dlm/lock.c                                      |  2 +-
 fs/ext2/super.c                                    |  2 +-
 fs/ext4/extents.c                                  |  6 +--
 fs/ext4/file.c                                     |  2 +-
 fs/fuse/file.c                                     |  2 +-
 fs/inode.c                                         |  4 +-
 fs/namespace.c                                     |  4 +-
 fs/nfsd/nfs4callback.c                             |  2 +-
 fs/ntfs/logfile.c                                  |  4 +-
 fs/orangefs/file.c                                 |  2 +-
 fs/read_write.c                                    |  2 +-
 fs/reiserfs/fix_node.c                             | 10 ++---
 fs/tracefs/inode.c                                 |  2 +-
 fs/xfs/libxfs/xfs_fs.h                             |  2 +-
 fs/xfs/xfs_log_recover.c                           |  2 +-
 fs/xfs/xfs_trans_ail.c                             |  6 +--
 include/linux/cgroup-defs.h                        |  2 +-
 include/linux/irqchip.h                            |  4 +-
 include/linux/kconfig.h                            |  2 +-
 include/linux/mfd/max77693-private.h               |  2 +-
 include/linux/msi.h                                |  2 +-
 include/linux/mtd/qinfo.h                          |  2 +-
 include/linux/pci.h                                |  2 +-
 include/linux/reboot.h                             |  2 +-
 include/linux/spi/flash.h                          |  2 +-
 include/linux/vmalloc.h                            |  2 +-
 include/net/cfg80211.h                             |  6 +--
 include/net/ip_tunnels.h                           |  2 +-
 include/net/irda/timer.h                           |  2 +-
 include/net/iw_handler.h                           |  4 +-
 include/net/sctp/structs.h                         |  2 +-
 include/target/iscsi/iscsi_target_core.h           |  2 +-
 include/uapi/linux/atmbr2684.h                     |  2 +-
 include/uapi/linux/nfsd/nfsfh.h                    |  2 +-
 include/uapi/linux/pmu.h                           |  2 +-
 include/uapi/linux/raid/md_p.h                     |  4 +-
 include/uapi/linux/x25.h                           |  2 +-
 ipc/shm.c                                          |  2 +-
 kernel/cpu.c                                       |  2 +-
 kernel/debug/debug_core.c                          |  2 +-
 kernel/irq/manage.c                                |  2 +-
 kernel/irq/spurious.c                              |  4 +-
 kernel/relay.c                                     |  2 +-
 kernel/torture.c                                   |  2 +-
 kernel/trace/trace_stack.c                         |  2 +-
 lib/Kconfig.ubsan                                  |  2 +-
 lib/radix-tree.c                                   |  2 +-
 lib/xz/xz_dec_lzma2.c                              |  4 +-
 mm/memcontrol.c                                    |  6 +--
 mm/page_alloc.c                                    |  2 +-
 mm/percpu.c                                        |  4 +-
 net/ipv4/tcp.c                                     |  2 +-
 net/ipv6/route.c                                   |  2 +-
 net/netfilter/nf_conntrack_proto_tcp.c             |  2 +-
 net/netfilter/x_tables.c                           |  3 +-
 net/sctp/transport.c                               |  4 +-
 net/wireless/wext-compat.c                         |  2 +-
 scripts/kconfig/streamline_config.pl               |  2 +-
 scripts/recordmcount.pl                            |  2 +-
 security/apparmor/procattr.c                       |  4 +-
 security/integrity/ima/ima_template_lib.c          |  2 +-
 security/selinux/hooks.c                           |  2 +-
 security/selinux/selinuxfs.c                       |  2 +-
 security/smack/smack_lsm.c                         |  2 +-
 security/smack/smackfs.c                           |  2 +-
 sound/pci/ac97/ac97_codec.c                        |  2 +-
 sound/pci/ac97/ac97_patch.c                        |  4 +-
 sound/pci/hda/hda_sysfs.c                          |  2 +-
 sound/pci/hda/patch_ca0132.c                       |  2 +-
 sound/ppc/snd_ps3.c                                |  2 +-
 sound/soc/amd/acp-pcm-dma.c                        |  4 +-
 sound/soc/codecs/wm_hubs.c                         |  2 +-
 sound/soc/davinci/davinci-i2s.c                    |  2 +-
 sound/soc/fsl/fsl_asrc.c                           |  2 +-
 sound/soc/qcom/lpass.h                             |  2 +-
 sound/soc/soc-ac97.c                               |  2 +-
 sound/soc/soc-topology.c                           |  4 +-
 sound/usb/mixer.c                                  |  2 +-
 tools/hv/hv_kvp_daemon.c                           |  2 +-
 tools/lguest/lguest.c                              |  2 +-
 tools/lib/bpf/Makefile                             |  2 +-
 tools/lib/bpf/bpf.c                                |  2 +-
 tools/lib/traceevent/Makefile                      |  2 +-
 tools/perf/Documentation/perf-list.txt             |  2 +-
 tools/perf/util/probe-event.c                      |  2 +-
 tools/testing/ktest/sample.conf                    |  4 +-
 tools/testing/selftests/net/psock_tpacket.c        |  2 +-
 tools/testing/selftests/powerpc/vphn/test-vphn.c   |  2 +-
 361 files changed, 570 insertions(+), 569 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=325">Joe Perches</a> - Aug. 31, 2016, 1:16 a.m.</div>
<pre class="content">
On Wed, 2016-08-31 at 08:57 +0900, Masahiro Yamada wrote:
<span class="quote">&gt; Spelling corrections for (among other things):</span>
<span class="quote">&gt;   * according</span>
[]
<span class="quote">&gt;   * width</span>

When possible and appropriate, can you please
update scripts/spelling.txt too?

Thanks, Joe
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=125921">Masahiro Yamada</a> - Sept. 8, 2016, 12:27 a.m.</div>
<pre class="content">
2016-08-31 10:16 GMT+09:00 Joe Perches &lt;joe@perches.com&gt;:
<span class="quote">&gt; On Wed, 2016-08-31 at 08:57 +0900, Masahiro Yamada wrote:</span>
<span class="quote">&gt;&gt; Spelling corrections for (among other things):</span>
<span class="quote">&gt;&gt;   * according</span>
<span class="quote">&gt; []</span>
<span class="quote">&gt;&gt;   * width</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; When possible and appropriate, can you please</span>
<span class="quote">&gt; update scripts/spelling.txt too?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Thanks, Joe</span>


Hi Joe,

Yes, I will do so in a follow-up patch.



Jiri,
BTW, is this patch acceptable for your tree?
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=139651">Jiri Kosina</a> - Sept. 29, 2016, 8:17 a.m.</div>
<pre class="content">
On Thu, 8 Sep 2016, Masahiro Yamada wrote:
<span class="quote">
&gt; BTW, is this patch acceptable for your tree?</span>

Huge cross-subsystems patches like this are usually pain to carry, as they 
are likely to produce conflicts left and right. The best course of action 
here probably is to send this to Linus after -rc1 (preferrably as a 
script).
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/ABI/testing/sysfs-bus-event_source-devices-events b/Documentation/ABI/testing/sysfs-bus-event_source-devices-events</span>
<span class="p_header">index 505f080..2e1d153 100644</span>
<span class="p_header">--- a/Documentation/ABI/testing/sysfs-bus-event_source-devices-events</span>
<span class="p_header">+++ b/Documentation/ABI/testing/sysfs-bus-event_source-devices-events</span>
<span class="p_chunk">@@ -47,7 +47,7 @@</span> <span class="p_context"> Description:	Per-pmu performance monitoring events specific to the running syste</span>
 		If a &lt;term&gt; is specified alone (without an assigned value), it
 		is implied that 0x1 is assigned to that &lt;term&gt;.
 
<span class="p_del">-		Examples (each of these lines would be in a seperate file):</span>
<span class="p_add">+		Examples (each of these lines would be in a separate file):</span>
 
 			event=0x2abc
 			event=0x423,inv,cmask=0x3
<span class="p_header">diff --git a/Documentation/DocBook/libata.tmpl b/Documentation/DocBook/libata.tmpl</span>
<span class="p_header">index d7fcdc5..0320910 100644</span>
<span class="p_header">--- a/Documentation/DocBook/libata.tmpl</span>
<span class="p_header">+++ b/Documentation/DocBook/libata.tmpl</span>
<span class="p_chunk">@@ -1020,7 +1020,7 @@</span> <span class="p_context"> and other resources, etc.</span>
 	&lt;/itemizedlist&gt;
 
 	&lt;para&gt;
<span class="p_del">-	Of errors detected as above, the followings are not ATA/ATAPI</span>
<span class="p_add">+	Of errors detected as above, the following are not ATA/ATAPI</span>
 	device errors but ATA bus errors and should be handled
 	according to &lt;xref linkend=&quot;excatATAbusErr&quot;/&gt;.
 	&lt;/para&gt;
<span class="p_header">diff --git a/Documentation/acpi/method-customizing.txt b/Documentation/acpi/method-customizing.txt</span>
<span class="p_header">index 5f55373..a3f598e 100644</span>
<span class="p_header">--- a/Documentation/acpi/method-customizing.txt</span>
<span class="p_header">+++ b/Documentation/acpi/method-customizing.txt</span>
<span class="p_chunk">@@ -57,7 +57,7 @@</span> <span class="p_context"> Note: To get the ACPI debug object output (Store (AAAA, Debug)),</span>
 3. undo your changes
    The &quot;undo&quot; operation is not supported for a new inserted method
    right now, i.e. we can not remove a method currently.
<span class="p_del">-   For an overrided method, in order to undo your changes, please</span>
<span class="p_add">+   For an overridden method, in order to undo your changes, please</span>
    save a copy of the method original ASL code in step c) section 1,
    and redo step c) ~ g) to override the method with the original one.
 
<span class="p_header">diff --git a/Documentation/acpi/method-tracing.txt b/Documentation/acpi/method-tracing.txt</span>
<span class="p_header">index c2505ee..0aba14c 100644</span>
<span class="p_header">--- a/Documentation/acpi/method-tracing.txt</span>
<span class="p_header">+++ b/Documentation/acpi/method-tracing.txt</span>
<span class="p_chunk">@@ -152,7 +152,7 @@</span> <span class="p_context"> tracing facility.</span>
 	Users can enable/disable this debug tracing feature by executing
 	the following command:
 	    # echo string &gt; /sys/module/acpi/parameters/trace_state
<span class="p_del">-	Where &quot;string&quot; should be one of the followings:</span>
<span class="p_add">+	Where &quot;string&quot; should be one of the following:</span>
 	&quot;disable&quot;
 	    Disable the method tracing feature.
 	&quot;enable&quot;
<span class="p_header">diff --git a/Documentation/devicetree/bindings/mfd/qcom-rpm.txt b/Documentation/devicetree/bindings/mfd/qcom-rpm.txt</span>
<span class="p_header">index b98b291..761ed93 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/mfd/qcom-rpm.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/mfd/qcom-rpm.txt</span>
<span class="p_chunk">@@ -219,7 +219,7 @@</span> <span class="p_context"> see regulator.txt - with additional custom properties described below:</span>
 - qcom,switch-mode-frequency:
 	Usage: required
 	Value type: &lt;u32&gt;
<span class="p_del">-	Definition: Frequency (Hz) of the swith mode power supply;</span>
<span class="p_add">+	Definition: Frequency (Hz) of the switch mode power supply;</span>
 		    must be one of:
 		    19200000, 9600000, 6400000, 4800000, 3840000, 3200000,
 		    2740000, 2400000, 2130000, 1920000, 1750000, 1600000,
<span class="p_header">diff --git a/Documentation/devicetree/bindings/pci/pci-armada8k.txt b/Documentation/devicetree/bindings/pci/pci-armada8k.txt</span>
<span class="p_header">index 598533a..655b33b 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/pci/pci-armada8k.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/pci/pci-armada8k.txt</span>
<span class="p_chunk">@@ -11,7 +11,7 @@</span> <span class="p_context"> Required properties:</span>
 - reg-names:
    - &quot;ctrl&quot; for the control register region
    - &quot;config&quot; for the config space region
<span class="p_del">-- interrupts: Interrupt specifier for the PCIe controler</span>
<span class="p_add">+- interrupts: Interrupt specifier for the PCIe controller</span>
 - clocks: reference to the PCIe controller clock
 
 Example:
<span class="p_header">diff --git a/Documentation/devicetree/bindings/pinctrl/allwinner,sunxi-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/allwinner,sunxi-pinctrl.txt</span>
<span class="p_header">index 6961722..a462dc3 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/pinctrl/allwinner,sunxi-pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/pinctrl/allwinner,sunxi-pinctrl.txt</span>
<span class="p_chunk">@@ -6,7 +6,7 @@</span> <span class="p_context"> the first two functions being GPIO in and out. The configuration on</span>
 the pins includes drive strength and pull-up.
 
 Required properties:
<span class="p_del">-- compatible: Should be one of the followings (depending on you SoC):</span>
<span class="p_add">+- compatible: Should be one of the following (depending on your SoC):</span>
   &quot;allwinner,sun4i-a10-pinctrl&quot;
   &quot;allwinner,sun5i-a10s-pinctrl&quot;
   &quot;allwinner,sun5i-a13-pinctrl&quot;
<span class="p_header">diff --git a/Documentation/devicetree/bindings/power/pd-samsung.txt b/Documentation/devicetree/bindings/power/pd-samsung.txt</span>
<span class="p_header">index 4e94737..76df656b 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/power/pd-samsung.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/power/pd-samsung.txt</span>
<span class="p_chunk">@@ -20,7 +20,7 @@</span> <span class="p_context"> Optional Properties:</span>
 - clock-names: The following clocks can be specified:
 	- oscclk: Oscillator clock.
 	- clkN: Input clocks to the devices in this power domain. These clocks
<span class="p_del">-		will be reparented to oscclk before swithing power domain off.</span>
<span class="p_add">+		will be reparented to oscclk before switching power domain off.</span>
 		Their original parent will be brought back after turning on
 		the domain. Maximum of 4 clocks (N = 0 to 3) are supported.
 	- asbN: Clocks required by asynchronous bridges (ASB) present in
<span class="p_header">diff --git a/Documentation/devicetree/bindings/regulator/ti-abb-regulator.txt b/Documentation/devicetree/bindings/regulator/ti-abb-regulator.txt</span>
<span class="p_header">index c3f6546..6a23ad9 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/regulator/ti-abb-regulator.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/regulator/ti-abb-regulator.txt</span>
<span class="p_chunk">@@ -45,7 +45,7 @@</span> <span class="p_context"> Required Properties:</span>
 Optional Properties:
 - reg-names: In addition to the required properties, the following are optional
   - &quot;efuse-address&quot;	- Contains efuse base address used to pick up ABB info.
<span class="p_del">-  - &quot;ldo-address&quot;	- Contains address of ABB LDO overide register address.</span>
<span class="p_add">+  - &quot;ldo-address&quot;	- Contains address of ABB LDO override register.</span>
 	&quot;efuse-address&quot; is required for this.
 - ti,ldovbb-vset-mask	- Required if ldo-address is set, mask for LDO override
 	register to provide override vset value.
<span class="p_header">diff --git a/Documentation/devicetree/bindings/soc/rockchip/grf.txt b/Documentation/devicetree/bindings/soc/rockchip/grf.txt</span>
<span class="p_header">index 013e71a..76d6ccf6 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/soc/rockchip/grf.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/soc/rockchip/grf.txt</span>
<span class="p_chunk">@@ -9,14 +9,14 @@</span> <span class="p_context"> From RK3368 SoCs, the GRF is divided into two sections,</span>
 
 Required Properties:
 
<span class="p_del">-- compatible: GRF should be one of the followings</span>
<span class="p_add">+- compatible: GRF should be one of the following:</span>
    - &quot;rockchip,rk3066-grf&quot;, &quot;syscon&quot;: for rk3066
    - &quot;rockchip,rk3188-grf&quot;, &quot;syscon&quot;: for rk3188
    - &quot;rockchip,rk3228-grf&quot;, &quot;syscon&quot;: for rk3228
    - &quot;rockchip,rk3288-grf&quot;, &quot;syscon&quot;: for rk3288
    - &quot;rockchip,rk3368-grf&quot;, &quot;syscon&quot;: for rk3368
    - &quot;rockchip,rk3399-grf&quot;, &quot;syscon&quot;: for rk3399
<span class="p_del">-- compatible: PMUGRF should be one of the followings</span>
<span class="p_add">+- compatible: PMUGRF should be one of the following:</span>
    - &quot;rockchip,rk3368-pmugrf&quot;, &quot;syscon&quot;: for rk3368
    - &quot;rockchip,rk3399-pmugrf&quot;, &quot;syscon&quot;: for rk3399
 - reg: physical base address of the controller and length of memory mapped
<span class="p_header">diff --git a/Documentation/devicetree/bindings/sound/rockchip-i2s.txt b/Documentation/devicetree/bindings/sound/rockchip-i2s.txt</span>
<span class="p_header">index 4ea29aa..d5b9d58 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/sound/rockchip-i2s.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/sound/rockchip-i2s.txt</span>
<span class="p_chunk">@@ -5,7 +5,7 @@</span> <span class="p_context"> audio data transfer between devices in the system.</span>
 
 Required properties:
 
<span class="p_del">-- compatible: should be one of the followings</span>
<span class="p_add">+- compatible: should be one of the following:</span>
    - &quot;rockchip,rk3066-i2s&quot;: for rk3066
    - &quot;rockchip,rk3188-i2s&quot;, &quot;rockchip,rk3066-i2s&quot;: for rk3188
    - &quot;rockchip,rk3288-i2s&quot;, &quot;rockchip,rk3066-i2s&quot;: for rk3288
<span class="p_header">diff --git a/Documentation/devicetree/bindings/sound/sun4i-i2s.txt b/Documentation/devicetree/bindings/sound/sun4i-i2s.txt</span>
<span class="p_header">index 7b526ec..29fdd8e 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/sound/sun4i-i2s.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/sound/sun4i-i2s.txt</span>
<span class="p_chunk">@@ -5,7 +5,7 @@</span> <span class="p_context"> audio data transfer between devices in the system.</span>
 
 Required properties:
 
<span class="p_del">-- compatible: should be one of the followings</span>
<span class="p_add">+- compatible: should be one of the following:</span>
    - &quot;allwinner,sun4i-a10-i2s&quot;
 - reg: physical base address of the controller and length of memory mapped
   region.
<span class="p_header">diff --git a/Documentation/filesystems/autofs4.txt b/Documentation/filesystems/autofs4.txt</span>
<span class="p_header">index 39d02e1..4c4e1dd 100644</span>
<span class="p_header">--- a/Documentation/filesystems/autofs4.txt</span>
<span class="p_header">+++ b/Documentation/filesystems/autofs4.txt</span>
<span class="p_chunk">@@ -255,7 +255,7 @@</span> <span class="p_context"> up.</span>
 
 There is an option with indirect mounts to consider each of the leaves
 that has been mounted on instead of considering the top-level names.
<span class="p_del">-This is intended for compatability with version 4 of autofs and should</span>
<span class="p_add">+This is intended for compatibility with version 4 of autofs and should</span>
 be considered as deprecated.
 
 When autofs considers a directory it checks the `last_used` time and
<span class="p_header">diff --git a/Documentation/filesystems/orangefs.txt b/Documentation/filesystems/orangefs.txt</span>
<span class="p_header">index 1dfdec7..c7b21b1 100644</span>
<span class="p_header">--- a/Documentation/filesystems/orangefs.txt</span>
<span class="p_header">+++ b/Documentation/filesystems/orangefs.txt</span>
<span class="p_chunk">@@ -182,7 +182,7 @@</span> <span class="p_context"> then contains:</span>
     of kcalloced memory. This memory is used as an array of pointers
     to each of the pages in the IO buffer through a call to get_user_pages.
   * desc_array - a pointer to desc_count * (sizeof(struct orangefs_bufmap_desc))
<span class="p_del">-    bytes of kcalloced memory. This memory is further intialized:</span>
<span class="p_add">+    bytes of kcalloced memory. This memory is further initialized:</span>
 
       user_desc is the kernel&#39;s copy of the IO buffer&#39;s ORANGEFS_dev_map_desc
       structure. user_desc-&gt;ptr points to the IO buffer.
<span class="p_header">diff --git a/Documentation/media/dvb-drivers/dvb-usb.rst b/Documentation/media/dvb-drivers/dvb-usb.rst</span>
<span class="p_header">index eec99cd..aa2c503 100644</span>
<span class="p_header">--- a/Documentation/media/dvb-drivers/dvb-usb.rst</span>
<span class="p_header">+++ b/Documentation/media/dvb-drivers/dvb-usb.rst</span>
<span class="p_chunk">@@ -123,7 +123,7 @@</span> <span class="p_context"> https://linuxtv.org/wiki/index.php/DVB_USB</span>
 
   2004-12-26
 
<span class="p_del">-  - refactored the dibusb-driver, splitted into separate files</span>
<span class="p_add">+  - refactored the dibusb-driver, split into separate files</span>
   - i2c-probing enabled
 
   2004-12-06
<span class="p_header">diff --git a/Documentation/media/uapi/v4l/vidioc-g-parm.rst b/Documentation/media/uapi/v4l/vidioc-g-parm.rst</span>
<span class="p_header">index 7116e0d..2a268f5 100644</span>
<span class="p_header">--- a/Documentation/media/uapi/v4l/vidioc-g-parm.rst</span>
<span class="p_header">+++ b/Documentation/media/uapi/v4l/vidioc-g-parm.rst</span>
<span class="p_chunk">@@ -280,7 +280,7 @@</span> <span class="p_context"> union holding separate parameters for input and output devices.</span>
 
 .. _parm-caps:
 
<span class="p_del">-.. flat-table:: Streaming Parameters Capabilites</span>
<span class="p_add">+.. flat-table:: Streaming Parameters Capabilities</span>
     :header-rows:  0
     :stub-columns: 0
     :widths:       3 1 4
<span class="p_header">diff --git a/Documentation/memory-hotplug.txt b/Documentation/memory-hotplug.txt</span>
<span class="p_header">index 0d7cb95..4bb5704 100644</span>
<span class="p_header">--- a/Documentation/memory-hotplug.txt</span>
<span class="p_header">+++ b/Documentation/memory-hotplug.txt</span>
<span class="p_chunk">@@ -114,11 +114,11 @@</span> <span class="p_context"> config options.</span>
     Memory model -&gt; Sparse Memory  (CONFIG_SPARSEMEM)
     Allow for memory hot-add       (CONFIG_MEMORY_HOTPLUG)
 
<span class="p_del">-- To enable memory removal, the followings are also necessary</span>
<span class="p_add">+- To enable memory removal, the following are also necessary</span>
     Allow for memory hot remove    (CONFIG_MEMORY_HOTREMOVE)
     Page Migration                 (CONFIG_MIGRATION)
 
<span class="p_del">-- For ACPI memory hotplug, the followings are also necessary</span>
<span class="p_add">+- For ACPI memory hotplug, the following are also necessary</span>
     Memory hotplug (under ACPI Support menu) (CONFIG_ACPI_HOTPLUG_MEMORY)
     This option can be kernel module.
 
<span class="p_header">diff --git a/Documentation/scsi/ChangeLog.lpfc b/Documentation/scsi/ChangeLog.lpfc</span>
<span class="p_header">index 2f6d595..755ec66 100644</span>
<span class="p_header">--- a/Documentation/scsi/ChangeLog.lpfc</span>
<span class="p_header">+++ b/Documentation/scsi/ChangeLog.lpfc</span>
<span class="p_chunk">@@ -182,7 +182,7 @@</span> <span class="p_context"> Changes from 20050201 to 20050208</span>
 	* Integrated Christoph Hellwig&#39;s patch from 1/30: Some fixes in
 	  the evt handling area.
 	* Integrated Christoph Hellwig&#39;s patch from 1/30: Remove usage of
<span class="p_del">-	  intr_inited variable. The interrupt initilization from OS side</span>
<span class="p_add">+	  intr_inited variable. The interrupt initialization from OS side</span>
 	  now happens in lpfc_probe_one().
 	* Integrated Christoph Hellwig&#39;s patch from 1/30: remove shim
 	  lpfc_alloc_transport_attr - remove shim lpfc_alloc_shost_attrs -
<span class="p_header">diff --git a/Documentation/scsi/ChangeLog.megaraid_sas b/Documentation/scsi/ChangeLog.megaraid_sas</span>
<span class="p_header">index 00ffdf18..234ddab 100644</span>
<span class="p_header">--- a/Documentation/scsi/ChangeLog.megaraid_sas</span>
<span class="p_header">+++ b/Documentation/scsi/ChangeLog.megaraid_sas</span>
<span class="p_chunk">@@ -549,7 +549,7 @@</span> <span class="p_context"> ii.	Reduced by 1 max cmds sent to FW from Driver to make the reply_q_sz same</span>
 3 Older Version   : 00.00.03.02
 
 i.	Send stop adapter to FW &amp; Dump pending FW cmds before declaring adapter dead.
<span class="p_del">-	New varible added to set dbg level.</span>
<span class="p_add">+	New variable added to set dbg level.</span>
 ii.	Disable interrupt made as fn pointer as they are different for 1068 / 1078
 iii.	Frame count optimization. Main frame can contain 2 SGE for 64 bit SGLs and
 	3 SGE for 32 bit SGL
<span class="p_header">diff --git a/Documentation/xtensa/atomctl.txt b/Documentation/xtensa/atomctl.txt</span>
<span class="p_header">index 1da783a..f1e7457 100644</span>
<span class="p_header">--- a/Documentation/xtensa/atomctl.txt</span>
<span class="p_header">+++ b/Documentation/xtensa/atomctl.txt</span>
<span class="p_chunk">@@ -19,7 +19,7 @@</span> <span class="p_context"> doing a Cached (WB) transaction and use the Memory RCW for un-cached</span>
 operations.
 
 For systems without an coherent cache controller, non-MX, we always
<span class="p_del">-use the memory controllers RCW, thought non-MX controlers likely</span>
<span class="p_add">+use the memory controllers RCW, though non-MX controllers likely</span>
 support the Internal Operation.
 
 CUSTOMER-WARNING:
<span class="p_header">diff --git a/arch/arc/kernel/unwind.c b/arch/arc/kernel/unwind.c</span>
<span class="p_header">index 0587bf1..c1e99f0 100644</span>
<span class="p_header">--- a/arch/arc/kernel/unwind.c</span>
<span class="p_header">+++ b/arch/arc/kernel/unwind.c</span>
<span class="p_chunk">@@ -1041,9 +1041,9 @@</span> <span class="p_context"> int arc_unwind(struct unwind_frame_info *frame)</span>
 		++ptr;
 	}
 	if (cie != NULL) {
<span class="p_del">-		/* get code aligment factor */</span>
<span class="p_add">+		/* get code alignment factor */</span>
 		state.codeAlign = get_uleb128(&amp;ptr, end);
<span class="p_del">-		/* get data aligment factor */</span>
<span class="p_add">+		/* get data alignment factor */</span>
 		state.dataAlign = get_sleb128(&amp;ptr, end);
 		if (state.codeAlign == 0 || state.dataAlign == 0 || ptr &gt;= end)
 			cie = NULL;
<span class="p_header">diff --git a/arch/arc/mm/tlb.c b/arch/arc/mm/tlb.c</span>
<span class="p_header">index ec868a9..4e00954 100644</span>
<span class="p_header">--- a/arch/arc/mm/tlb.c</span>
<span class="p_header">+++ b/arch/arc/mm/tlb.c</span>
<span class="p_chunk">@@ -33,7 +33,7 @@</span> <span class="p_context"></span>
  *  -Changes related to MMU v2 (Rel 4.8)
  *
  * Vineetg: Aug 29th 2008
<span class="p_del">- *  -In TLB Flush operations (Metal Fix MMU) there is a explict command to</span>
<span class="p_add">+ *  -In TLB Flush operations (Metal Fix MMU) there is an explicit command to</span>
  *    flush Micro-TLBS. If TLB Index Reg is invalid prior to TLBIVUTLB cmd,
  *    it fails. Thus need to load it with ANY valid value before invoking
  *    TLBIVUTLB cmd
<span class="p_chunk">@@ -151,7 +151,7 @@</span> <span class="p_context"> static void tlb_entry_erase(unsigned int vaddr_n_asid)</span>
 /****************************************************************************
  * ARC700 MMU caches recently used J-TLB entries (RAM) as uTLBs (FLOPs)
  *
<span class="p_del">- * New IVUTLB cmd in MMU v2 explictly invalidates the uTLB</span>
<span class="p_add">+ * New IVUTLB cmd in MMU v2 explicitly invalidates the uTLB</span>
  *
  * utlb_invalidate ( )
  *  -For v2 MMU calls Flush uTLB Cmd
<span class="p_chunk">@@ -318,7 +318,7 @@</span> <span class="p_context"> noinline void local_flush_tlb_mm(struct mm_struct *mm)</span>
  * Difference between this and Kernel Range Flush is
  *  -Here the fastest way (if range is too large) is to move to next ASID
  *      without doing any explicit Shootdown
<span class="p_del">- *  -In case of kernel Flush, entry has to be shot down explictly</span>
<span class="p_add">+ *  -In case of kernel Flush, entry has to be shot down explicitly</span>
  */
 void local_flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
 			   unsigned long end)
<span class="p_header">diff --git a/arch/arm/boot/compressed/head.S b/arch/arm/boot/compressed/head.S</span>
<span class="p_header">index af11c2f..50d8297 100644</span>
<span class="p_header">--- a/arch/arm/boot/compressed/head.S</span>
<span class="p_header">+++ b/arch/arm/boot/compressed/head.S</span>
<span class="p_chunk">@@ -1196,7 +1196,7 @@</span> <span class="p_context"> skip:</span>
 		bgt	loop1
 finished:
 		ldmfd	sp!, {r0-r7, r9-r11}
<span class="p_del">-		mov	r10, #0			@ swith back to cache level 0</span>
<span class="p_add">+		mov	r10, #0			@ switch back to cache level 0</span>
 		mcr	p15, 2, r10, c0, c0, 0	@ select current cache level in cssr
 iflush:
 		mcr	p15, 0, r10, c7, c10, 4	@ DSB
<span class="p_header">diff --git a/arch/arm/boot/dts/r8a7779.dtsi b/arch/arm/boot/dts/r8a7779.dtsi</span>
<span class="p_header">index b9bbcce..8ebf7f6 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/r8a7779.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/r8a7779.dtsi</span>
<span class="p_chunk">@@ -452,7 +452,7 @@</span> <span class="p_context"></span>
 		extal_clk: extal {
 			compatible = &quot;fixed-clock&quot;;
 			#clock-cells = &lt;0&gt;;
<span class="p_del">-			/* This value must be overriden by the board. */</span>
<span class="p_add">+			/* This value must be overridden by the board. */</span>
 			clock-frequency = &lt;0&gt;;
 		};
 
<span class="p_header">diff --git a/arch/arm/boot/dts/r8a7790.dtsi b/arch/arm/boot/dts/r8a7790.dtsi</span>
<span class="p_header">index d18558f..4bdf4ba 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/r8a7790.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/r8a7790.dtsi</span>
<span class="p_chunk">@@ -1071,7 +1071,7 @@</span> <span class="p_context"></span>
 		extal_clk: extal {
 			compatible = &quot;fixed-clock&quot;;
 			#clock-cells = &lt;0&gt;;
<span class="p_del">-			/* This value must be overriden by the board. */</span>
<span class="p_add">+			/* This value must be overridden by the board. */</span>
 			clock-frequency = &lt;0&gt;;
 		};
 
<span class="p_header">diff --git a/arch/arm/boot/dts/r8a7791.dtsi b/arch/arm/boot/dts/r8a7791.dtsi</span>
<span class="p_header">index 8f0086b..8e230c9 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/r8a7791.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/r8a7791.dtsi</span>
<span class="p_chunk">@@ -1088,7 +1088,7 @@</span> <span class="p_context"></span>
 		extal_clk: extal {
 			compatible = &quot;fixed-clock&quot;;
 			#clock-cells = &lt;0&gt;;
<span class="p_del">-			/* This value must be overriden by the board. */</span>
<span class="p_add">+			/* This value must be overridden by the board. */</span>
 			clock-frequency = &lt;0&gt;;
 		};
 
<span class="p_header">diff --git a/arch/arm/boot/dts/r8a7794.dtsi b/arch/arm/boot/dts/r8a7794.dtsi</span>
<span class="p_header">index 685f986..cc7f298 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/r8a7794.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/r8a7794.dtsi</span>
<span class="p_chunk">@@ -925,7 +925,7 @@</span> <span class="p_context"></span>
 		extal_clk: extal {
 			compatible = &quot;fixed-clock&quot;;
 			#clock-cells = &lt;0&gt;;
<span class="p_del">-			/* This value must be overriden by the board. */</span>
<span class="p_add">+			/* This value must be overridden by the board. */</span>
 			clock-frequency = &lt;0&gt;;
 		};
 
<span class="p_header">diff --git a/arch/arm/include/asm/mach/flash.h b/arch/arm/include/asm/mach/flash.h</span>
<span class="p_header">index 4ca69fe..bada3f8 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/mach/flash.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/mach/flash.h</span>
<span class="p_chunk">@@ -22,7 +22,7 @@</span> <span class="p_context"> struct mtd_info;</span>
  * set_vpp:	method called to enable or disable VPP
  * mmcontrol:	method called to enable or disable Sync. Burst Read in OneNAND
  * parts:	optional array of mtd_partitions for static partitioning
<span class="p_del">- * nr_parts:	number of mtd_partitions for static partitoning</span>
<span class="p_add">+ * nr_parts:	number of mtd_partitions for static partitioning</span>
  */
 struct flash_platform_data {
 	const char	*map_name;
<span class="p_header">diff --git a/arch/arm/include/asm/xen/page-coherent.h b/arch/arm/include/asm/xen/page-coherent.h</span>
<span class="p_header">index 95ce6ac..95167c0 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/xen/page-coherent.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/xen/page-coherent.h</span>
<span class="p_chunk">@@ -59,7 +59,7 @@</span> <span class="p_context"> static inline void xen_dma_unmap_page(struct device *hwdev, dma_addr_t handle,</span>
 {
 	unsigned long pfn = PFN_DOWN(handle);
 	/*
<span class="p_del">-	 * Dom0 is mapped 1:1, while the Linux page can be spanned accross</span>
<span class="p_add">+	 * Dom0 is mapped 1:1, while the Linux page can be spanned across</span>
 	 * multiple Xen page, it&#39;s not possible to have a mix of local and
 	 * foreign Xen page. Dom0 is mapped 1:1, so calling pfn_valid on a
 	 * foreign mfn will always return false. If the page is local we can
<span class="p_header">diff --git a/arch/arm/mach-omap2/dma.c b/arch/arm/mach-omap2/dma.c</span>
<span class="p_header">index e58c13a..e87065c 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/dma.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/dma.c</span>
<span class="p_chunk">@@ -160,7 +160,7 @@</span> <span class="p_context"> static unsigned configure_dma_errata(void)</span>
 	/*
 	 * Erratum ID: i378: OMAP2+: sDMA Channel is not disabled
 	 * after a transaction error.
<span class="p_del">-	 * Workaround: SW should explicitely disable the channel.</span>
<span class="p_add">+	 * Workaround: SW should explicitly disable the channel.</span>
 	 */
 	if (cpu_class_is_omap2())
 		SET_DMA_ERRATA(DMA_ERRATA_i378);
<span class="p_header">diff --git a/arch/arm/mach-omap2/omap_twl.c b/arch/arm/mach-omap2/omap_twl.c</span>
<span class="p_header">index 6bf6267..1346b3a 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/omap_twl.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/omap_twl.c</span>
<span class="p_chunk">@@ -1,5 +1,5 @@</span> <span class="p_context"></span>
 /**
<span class="p_del">- * OMAP and TWL PMIC specific intializations.</span>
<span class="p_add">+ * OMAP and TWL PMIC specific initializations.</span>
  *
  * Copyright (C) 2010 Texas Instruments Incorporated.
  * Thara Gopinath
<span class="p_header">diff --git a/arch/arm/mach-w90x900/dev.c b/arch/arm/mach-w90x900/dev.c</span>
<span class="p_header">index e65a80a..b379883 100644</span>
<span class="p_header">--- a/arch/arm/mach-w90x900/dev.c</span>
<span class="p_header">+++ b/arch/arm/mach-w90x900/dev.c</span>
<span class="p_chunk">@@ -514,7 +514,7 @@</span> <span class="p_context"> struct platform_device nuc900_device_ac97 = {</span>
 	}
 };
 
<span class="p_del">-/*Here should be your evb resourse,such as LCD*/</span>
<span class="p_add">+/* Here should be your evb resource, such as LCD */</span>
 
 static struct platform_device *nuc900_public_dev[] __initdata = {
 	&amp;nuc900_serial_device,
<span class="p_header">diff --git a/arch/arm/mm/cache-v7.S b/arch/arm/mm/cache-v7.S</span>
<span class="p_header">index a134d8a..de78109 100644</span>
<span class="p_header">--- a/arch/arm/mm/cache-v7.S</span>
<span class="p_header">+++ b/arch/arm/mm/cache-v7.S</span>
<span class="p_chunk">@@ -164,7 +164,7 @@</span> <span class="p_context"> skip:</span>
 	cmp	r3, r10
 	bgt	flush_levels
 finished:
<span class="p_del">-	mov	r10, #0				@ swith back to cache level 0</span>
<span class="p_add">+	mov	r10, #0				@ switch back to cache level 0</span>
 	mcr	p15, 2, r10, c0, c0, 0		@ select current cache level in cssr
 	dsb	st
 	isb
<span class="p_header">diff --git a/arch/arm/plat-omap/dmtimer.c b/arch/arm/plat-omap/dmtimer.c</span>
<span class="p_header">index 7a327bd..1f90aa4 100644</span>
<span class="p_header">--- a/arch/arm/plat-omap/dmtimer.c</span>
<span class="p_header">+++ b/arch/arm/plat-omap/dmtimer.c</span>
<span class="p_chunk">@@ -255,7 +255,7 @@</span> <span class="p_context"> static struct omap_dm_timer *_omap_dm_timer_request(int req_type, void *data)</span>
 				/*
 				 * If timer is not NULL, we have already found
 				 * one timer but it was not an exact match
<span class="p_del">-				 * because it had more capabilites that what</span>
<span class="p_add">+				 * because it had more capabilities that what</span>
 				 * was required. Therefore, unreserve the last
 				 * timer found and see if this one is a better
 				 * match.
<span class="p_header">diff --git a/arch/arm/plat-samsung/include/plat/gpio-cfg.h b/arch/arm/plat-samsung/include/plat/gpio-cfg.h</span>
<span class="p_header">index 21391fa..56a4bed 100644</span>
<span class="p_header">--- a/arch/arm/plat-samsung/include/plat/gpio-cfg.h</span>
<span class="p_header">+++ b/arch/arm/plat-samsung/include/plat/gpio-cfg.h</span>
<span class="p_chunk">@@ -40,7 +40,7 @@</span> <span class="p_context"> struct samsung_gpio_chip;</span>
  * @get_config: Read the current configuration for the GPIO
  *
  * Each chip can have more than one type of GPIO bank available and some
<span class="p_del">- * have different capabilites even when they have the same control register</span>
<span class="p_add">+ * have different capabilities even when they have the same control register</span>
  * layouts. Provide an point to vector control routine and provide any
  * per-bank configuration information that other systems such as the
  * external interrupt code will need.
<span class="p_header">diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig</span>
<span class="p_header">index bc3f00f..d8b43bb 100644</span>
<span class="p_header">--- a/arch/arm64/Kconfig</span>
<span class="p_header">+++ b/arch/arm64/Kconfig</span>
<span class="p_chunk">@@ -853,7 +853,7 @@</span> <span class="p_context"> config ARM64_UAO</span>
 	help
 	  User Access Override (UAO; part of the ARMv8.2 Extensions)
 	  causes the &#39;unprivileged&#39; variant of the load/store instructions to
<span class="p_del">-	  be overriden to be privileged.</span>
<span class="p_add">+	  be overridden to be privileged.</span>
 
 	  This option changes get_user() and friends to use the &#39;unprivileged&#39;
 	  variant of the load/store instructions. This ensures that user-space
<span class="p_header">diff --git a/arch/ia64/sn/kernel/sn2/sn_hwperf.c b/arch/ia64/sn/kernel/sn2/sn_hwperf.c</span>
<span class="p_header">index b999257..ccbf33e 100644</span>
<span class="p_header">--- a/arch/ia64/sn/kernel/sn2/sn_hwperf.c</span>
<span class="p_header">+++ b/arch/ia64/sn/kernel/sn2/sn_hwperf.c</span>
<span class="p_chunk">@@ -525,7 +525,7 @@</span> <span class="p_context"> static int sn_topology_show(struct seq_file *s, void *d)</span>
 				/* both ends local to this partition */
 				seq_puts(s, &quot; local&quot;);
 			else if (SN_HWPERF_FOREIGN(p))
<span class="p_del">-				/* both ends of the link in foreign partiton */</span>
<span class="p_add">+				/* both ends of the link in foreign partition */</span>
 				seq_puts(s, &quot; foreign&quot;);
 			else
 				/* link straddles a partition */
<span class="p_header">diff --git a/arch/m68k/ifpsp060/src/isp.S b/arch/m68k/ifpsp060/src/isp.S</span>
<span class="p_header">index 6dccda7..b865c1a 100644</span>
<span class="p_header">--- a/arch/m68k/ifpsp060/src/isp.S</span>
<span class="p_header">+++ b/arch/m68k/ifpsp060/src/isp.S</span>
<span class="p_chunk">@@ -3814,7 +3814,7 @@</span> <span class="p_context"> CAS2W2_FILLER:</span>
 #	(3) Save current DFC/SFC (ASSUMED TO BE EQUAL!!!); Then set	#
 #	    SFC/DFC according to whether exception occurred in user or	#
 #	    supervisor mode.						#
<span class="p_del">-#	(4) Use &quot;plpaw&quot; instruction to pre-load ATC with efective	#</span>
<span class="p_add">+#	(4) Use &quot;plpaw&quot; instruction to pre-load ATC with effective	#</span>
 #	    address page(s). THIS SHOULD NOT FAULT!!! The relevant	#
 #	    page(s) should have been made resident prior to entering	#
 #	    this routine.						#
<span class="p_header">diff --git a/arch/m68k/math-emu/fp_util.S b/arch/m68k/math-emu/fp_util.S</span>
<span class="p_header">index b093b85..6837a6b 100644</span>
<span class="p_header">--- a/arch/m68k/math-emu/fp_util.S</span>
<span class="p_header">+++ b/arch/m68k/math-emu/fp_util.S</span>
<span class="p_chunk">@@ -351,7 +351,7 @@</span> <span class="p_context"> fp_e2e_small2:</span>
 	bfins	%d0,(%a0){%d1,#8}
 #endif
 	jra	fp_e2e_checkround
<span class="p_del">-1:	neg.w	%d1			| lower lword is splitted between</span>
<span class="p_add">+1:	neg.w	%d1			| lower lword is split between</span>
 	bfins	%d0,(%a0){%d1,#32}	| higher and lower lword
 #ifndef CONFIG_M68KFPU_EMU_EXTRAPREC
 	jra	fp_e2e_checkround
<span class="p_chunk">@@ -390,7 +390,7 @@</span> <span class="p_context"> fp_e2e_small3:</span>
 	move.b	%d0,(7,%a0)
 	jra	fp_e2e_checkround
 #endif
<span class="p_del">-1:	move.l	%d0,%d1			| lower lword is splitted between</span>
<span class="p_add">+1:	move.l	%d0,%d1			| lower lword is split between</span>
 	lsl.l	%d2,%d0			| higher and lower lword
 	move.l	%d0,(%a0)
 	move.l	%d1,%d0
<span class="p_chunk">@@ -577,7 +577,7 @@</span> <span class="p_context"> fp_ne_small2:</span>
 	bfins	%d0,(%a0){%d1,#8}
 #endif
 	jra	fp_ne_checkround
<span class="p_del">-1:	neg.w	%d1			| lower lword is splitted between</span>
<span class="p_add">+1:	neg.w	%d1			| lower lword is split between</span>
 	bfins	%d0,(%a0){%d1,#32}	| higher and lower lword
 #ifndef CONFIG_M68KFPU_EMU_EXTRAPREC
 	jra	fp_ne_checkround
<span class="p_chunk">@@ -1012,7 +1012,7 @@</span> <span class="p_context"> fp_ns_huge:</span>
 	| fp_normalize_single_fast:
 	| normalize an extended with single (23-bit) precision
 	| this is only used by fsgldiv/fsgdlmul, where the
<span class="p_del">-	| operand is not completly normalized.</span>
<span class="p_add">+	| operand is not completely normalized.</span>
 	| args:	 %a0 (struct fp_ext *)
 
 fp_normalize_single_fast:
<span class="p_header">diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig</span>
<span class="p_header">index 2638856..4932e28 100644</span>
<span class="p_header">--- a/arch/mips/Kconfig</span>
<span class="p_header">+++ b/arch/mips/Kconfig</span>
<span class="p_chunk">@@ -2846,7 +2846,7 @@</span> <span class="p_context"> config MIPS_O32_FP64_SUPPORT</span>
 
 	  Although binutils currently supports use of this flag the details
 	  concerning its effect upon the O32 ABI in userland are still being
<span class="p_del">-	  worked on. In order to avoid userland becoming dependant upon current</span>
<span class="p_add">+	  worked on. In order to avoid userland becoming dependent upon current</span>
 	  behaviour before the details have been finalised, this option should
 	  be considered experimental and only enabled by those working upon
 	  said details.
<span class="p_chunk">@@ -2881,7 +2881,7 @@</span> <span class="p_context"> choice</span>
 
 		    objcopy --update-section .appended_dtb=&lt;filename&gt;.dtb vmlinux
 
<span class="p_del">-		  This is meant as a backward compatiblity convenience for those</span>
<span class="p_add">+		  This is meant as a backward compatibility convenience for those</span>
 		  systems with a bootloader that can&#39;t be upgraded to accommodate
 		  the documented boot protocol using a device tree.
 
<span class="p_header">diff --git a/arch/openrisc/kernel/entry.S b/arch/openrisc/kernel/entry.S</span>
<span class="p_header">index fec8bf9..0413bc6 100644</span>
<span class="p_header">--- a/arch/openrisc/kernel/entry.S</span>
<span class="p_header">+++ b/arch/openrisc/kernel/entry.S</span>
<span class="p_chunk">@@ -310,7 +310,7 @@</span> <span class="p_context"> EXCEPTION_ENTRY(_timer_handler)</span>
 	l.j    _ret_from_intr
 	 l.nop
 
<span class="p_del">-/* ---[ 0x600: Aligment exception ]-------------------------------------- */</span>
<span class="p_add">+/* ---[ 0x600: Alignment exception ]-------------------------------------- */</span>
 
 EXCEPTION_ENTRY(_alignment_handler)
 	/* r4: EA of fault (set by EXCEPTION_HANDLE) */
<span class="p_chunk">@@ -322,7 +322,7 @@</span> <span class="p_context"> EXCEPTION_ENTRY(_alignment_handler)</span>
 
 #if 0
 EXCEPTION_ENTRY(_aligment_handler)
<span class="p_del">-//        l.mfspr r2,r0,SPR_EEAR_BASE     /* Load the efective addres */</span>
<span class="p_add">+//        l.mfspr r2,r0,SPR_EEAR_BASE     /* Load the effective address */</span>
 	l.addi	r2,r4,0
 //        l.mfspr r5,r0,SPR_EPCR_BASE     /* Load the insn address */
 	l.lwz   r5,PT_PC(r1)
<span class="p_header">diff --git a/arch/openrisc/kernel/head.S b/arch/openrisc/kernel/head.S</span>
<span class="p_header">index f147933..1f6a998 100644</span>
<span class="p_header">--- a/arch/openrisc/kernel/head.S</span>
<span class="p_header">+++ b/arch/openrisc/kernel/head.S</span>
<span class="p_chunk">@@ -324,7 +324,7 @@</span> <span class="p_context"> _dispatch_do_ipage_fault:</span>
     .org 0x500
 	EXCEPTION_HANDLE(_timer_handler)
 
<span class="p_del">-/* ---[ 0x600: Aligment exception ]-------------------------------------- */</span>
<span class="p_add">+/* ---[ 0x600: Alignment exception ]-------------------------------------- */</span>
     .org 0x600
 	EXCEPTION_HANDLE(_alignment_handler)
 
<span class="p_chunk">@@ -629,8 +629,9 @@</span> <span class="p_context"> jump_start_kernel:</span>
 
 /* ========================================[ cache ]=== */
 
<span class="p_del">-	/* aligment here so we don&#39;t change memory offsets with</span>
<span class="p_del">-	 * memory controler defined</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * alignment here so we don&#39;t change memory offsets with</span>
<span class="p_add">+	 * memory controller defined</span>
 	 */
 	.align 0x2000
 
<span class="p_header">diff --git a/arch/openrisc/kernel/vmlinux.lds.S b/arch/openrisc/kernel/vmlinux.lds.S</span>
<span class="p_header">index d936de4..950ff34 100644</span>
<span class="p_header">--- a/arch/openrisc/kernel/vmlinux.lds.S</span>
<span class="p_header">+++ b/arch/openrisc/kernel/vmlinux.lds.S</span>
<span class="p_chunk">@@ -19,8 +19,8 @@</span> <span class="p_context"></span>
 
 /* TODO
  *		- clean up __offset &amp; stuff
<span class="p_del">- *		- change all 8192 aligment to PAGE !!!</span>
<span class="p_del">- *		- recheck if all aligments are really needed</span>
<span class="p_add">+ *		- change all 8192 alignment to PAGE !!!</span>
<span class="p_add">+ *		- recheck if all alignments are really needed</span>
  */
 
 #  define LOAD_OFFSET  PAGE_OFFSET
<span class="p_header">diff --git a/arch/powerpc/boot/dts/fsl/mpc8569mds.dts b/arch/powerpc/boot/dts/fsl/mpc8569mds.dts</span>
<span class="p_header">index 8e94448..76b2bd6 100644</span>
<span class="p_header">--- a/arch/powerpc/boot/dts/fsl/mpc8569mds.dts</span>
<span class="p_header">+++ b/arch/powerpc/boot/dts/fsl/mpc8569mds.dts</span>
<span class="p_chunk">@@ -55,7 +55,7 @@</span> <span class="p_context"></span>
 				label = &quot;kernel&quot;;
 				reg = &lt;0x01c00000 0x002e0000&gt;;
 			};
<span class="p_del">-			partiton@1ee0000 {</span>
<span class="p_add">+			partition@1ee0000 {</span>
 				label = &quot;dtb&quot;;
 				reg = &lt;0x01ee0000 0x00020000&gt;;
 			};
<span class="p_header">diff --git a/arch/powerpc/include/asm/book3s/64/mmu.h b/arch/powerpc/include/asm/book3s/64/mmu.h</span>
<span class="p_header">index 8afb0e0..cc450fa 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/book3s/64/mmu.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/book3s/64/mmu.h</span>
<span class="p_chunk">@@ -30,7 +30,7 @@</span> <span class="p_context"> extern struct mmu_psize_def mmu_psize_defs[MMU_PAGE_COUNT];</span>
 
 #ifndef __ASSEMBLY__
 /*
<span class="p_del">- * ISA 3.0 partiton and process table entry format</span>
<span class="p_add">+ * ISA 3.0 partition and process table entry format</span>
  */
 struct prtb_entry {
 	__be64 prtb0;
<span class="p_header">diff --git a/arch/powerpc/include/asm/fsl_hcalls.h b/arch/powerpc/include/asm/fsl_hcalls.h</span>
<span class="p_header">index 3abb583..b889d13 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/fsl_hcalls.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/fsl_hcalls.h</span>
<span class="p_chunk">@@ -109,7 +109,7 @@</span> <span class="p_context"> static inline unsigned int fh_send_nmi(unsigned int vcpu_mask)</span>
 #define FH_DTPROP_MAX_PROPLEN 32768
 
 /**
<span class="p_del">- * fh_partiton_get_dtprop - get a property from a guest device tree.</span>
<span class="p_add">+ * fh_partition_get_dtprop - get a property from a guest device tree.</span>
  * @handle: handle of partition whose device tree is to be accessed
  * @dtpath_addr: physical address of device tree path to access
  * @propname_addr: physical address of name of property
<span class="p_header">diff --git a/arch/powerpc/kernel/entry_64.S b/arch/powerpc/kernel/entry_64.S</span>
<span class="p_header">index 5afd03e..221d8bc 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/entry_64.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/entry_64.S</span>
<span class="p_chunk">@@ -519,7 +519,8 @@</span> <span class="p_context"> BEGIN_FTR_SECTION</span>
 END_FTR_SECTION_IFSET(CPU_FTR_ARCH_300)
 
 #ifdef CONFIG_PPC_BOOK3S
<span class="p_del">-/* Cancel all explict user streams as they will have no use after context</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Cancel all explicit user streams as they will have no use after context</span>
  * switch and will stop the HW from creating streams itself
  */
 	DCBT_STOP_ALL_STREAM_IDS(r6)
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/pci-ioda.c b/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_header">index 1321826..9ebc16e 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_chunk">@@ -2994,7 +2994,7 @@</span> <span class="p_context"> static void pnv_ioda_setup_pe_res(struct pnv_ioda_pe *pe,</span>
 /*
  * This function is supposed to be called on basis of PE from top
  * to bottom style. So the the I/O or MMIO segment assigned to
<span class="p_del">- * parent PE could be overrided by its child PEs if necessary.</span>
<span class="p_add">+ * parent PE could be overridden by its child PEs if necessary.</span>
  */
 static void pnv_ioda_setup_pe_seg(struct pnv_ioda_pe *pe)
 {
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/iommu.c b/arch/powerpc/platforms/pseries/iommu.c</span>
<span class="p_header">index 0024e45..4d757ea 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/iommu.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/iommu.c</span>
<span class="p_chunk">@@ -1020,7 +1020,7 @@</span> <span class="p_context"> static u64 enable_ddw(struct pci_dev *dev, struct device_node *pdn)</span>
 	/* check largest block * page size &gt; max memory hotplug addr */
 	max_addr = memory_hotplug_max();
 	if (query.largest_available_block &lt; (max_addr &gt;&gt; page_shift)) {
<span class="p_del">-		dev_dbg(&amp;dev-&gt;dev, &quot;can&#39;t map partiton max 0x%llx with %u &quot;</span>
<span class="p_add">+		dev_dbg(&amp;dev-&gt;dev, &quot;can&#39;t map partition max 0x%llx with %u &quot;</span>
 			  &quot;%llu-sized pages\n&quot;, max_addr,  query.largest_available_block,
 			  1ULL &lt;&lt; page_shift);
 		goto out_failed;
<span class="p_header">diff --git a/arch/sh/kernel/irq.c b/arch/sh/kernel/irq.c</span>
<span class="p_header">index 6c0378c..5b8ddcc 100644</span>
<span class="p_header">--- a/arch/sh/kernel/irq.c</span>
<span class="p_header">+++ b/arch/sh/kernel/irq.c</span>
<span class="p_chunk">@@ -99,7 +99,7 @@</span> <span class="p_context"> static inline void handle_one_irq(unsigned int irq)</span>
 			&quot;mov	%0, r4		\n&quot;
 			&quot;mov	r15, r8		\n&quot;
 			&quot;jsr	@%1		\n&quot;
<span class="p_del">-			/* swith to the irq stack */</span>
<span class="p_add">+			/* switch to the irq stack */</span>
 			&quot; mov	%2, r15		\n&quot;
 			/* restore the stack (ring zero) */
 			&quot;mov	r8, r15		\n&quot;
<span class="p_header">diff --git a/arch/sparc/include/asm/hypervisor.h b/arch/sparc/include/asm/hypervisor.h</span>
<span class="p_header">index f5b6537..03e5674 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/hypervisor.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/hypervisor.h</span>
<span class="p_chunk">@@ -167,7 +167,7 @@</span> <span class="p_context"> void sun4v_mach_sir(void);</span>
  * Service Processor, and/or automatically restarting the gues.
  *
  * The &#39;timeout&#39; parameter is specified in milliseconds, however the
<span class="p_del">- * implementated granularity is given by the &#39;watchdog-resolution&#39;</span>
<span class="p_add">+ * implemented granularity is given by the &#39;watchdog-resolution&#39;</span>
  * property in the &#39;platform&#39; node of the guest&#39;s machine description.
  * The largest allowed timeout value is specified by the
  * &#39;watchdog-max-timeout&#39; property of the &#39;platform&#39; node.
<span class="p_header">diff --git a/arch/sparc/kernel/visemul.c b/arch/sparc/kernel/visemul.c</span>
<span class="p_header">index c096c62..1d5ecbed 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/visemul.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/visemul.c</span>
<span class="p_chunk">@@ -30,7 +30,7 @@</span> <span class="p_context"></span>
 /* 001001011 - two 32-bit merges */
 #define FPMERGE_OPF	0x04b
 
<span class="p_del">-/* 000110001 - 8-by-16-bit partitoned product  */</span>
<span class="p_add">+/* 000110001 - 8-by-16-bit partitioned product  */</span>
 #define FMUL8x16_OPF	0x031
 
 /* 000110011 - 8-by-16-bit upper alpha partitioned product  */
<span class="p_header">diff --git a/arch/sparc/mm/srmmu.c b/arch/sparc/mm/srmmu.c</span>
<span class="p_header">index c7f2a52..f139457 100644</span>
<span class="p_header">--- a/arch/sparc/mm/srmmu.c</span>
<span class="p_header">+++ b/arch/sparc/mm/srmmu.c</span>
<span class="p_chunk">@@ -1470,7 +1470,7 @@</span> <span class="p_context"> static struct sparc32_cachetlb_ops viking_ops = {</span>
  * flush resulting in corruption.
  *
  * Our workaround is to take a global spinlock around the TLB flushes,
<span class="p_del">- * which guarentees we won&#39;t ever have too many pending.  It&#39;s a big</span>
<span class="p_add">+ * which guarantees we won&#39;t ever have too many pending.  It&#39;s a big</span>
  * hammer, but a semaphore like system to make sure we only have N TLB
  * flushes going at once will require SMP locking anyways so there&#39;s
  * no real value in trying any harder than this.
<span class="p_header">diff --git a/arch/x86/crypto/cast5_avx_glue.c b/arch/x86/crypto/cast5_avx_glue.c</span>
<span class="p_header">index 8648158..33f34ec 100644</span>
<span class="p_header">--- a/arch/x86/crypto/cast5_avx_glue.c</span>
<span class="p_header">+++ b/arch/x86/crypto/cast5_avx_glue.c</span>
<span class="p_chunk">@@ -1,5 +1,5 @@</span> <span class="p_context"></span>
 /*
<span class="p_del">- * Glue Code for the AVX assembler implemention of the Cast5 Cipher</span>
<span class="p_add">+ * Glue Code for the AVX assembler implementation of the Cast5 Cipher</span>
  *
  * Copyright (C) 2012 Johannes Goetzfried
  *     &lt;Johannes.Goetzfried@informatik.stud.uni-erlangen.de&gt;
<span class="p_header">diff --git a/arch/x86/crypto/cast6_avx_glue.c b/arch/x86/crypto/cast6_avx_glue.c</span>
<span class="p_header">index 50e6847..8569238 100644</span>
<span class="p_header">--- a/arch/x86/crypto/cast6_avx_glue.c</span>
<span class="p_header">+++ b/arch/x86/crypto/cast6_avx_glue.c</span>
<span class="p_chunk">@@ -1,5 +1,5 @@</span> <span class="p_context"></span>
 /*
<span class="p_del">- * Glue Code for the AVX assembler implemention of the Cast6 Cipher</span>
<span class="p_add">+ * Glue Code for the AVX assembler implementation of the Cast6 Cipher</span>
  *
  * Copyright (C) 2012 Johannes Goetzfried
  *     &lt;Johannes.Goetzfried@informatik.stud.uni-erlangen.de&gt;
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 5cede40..c02dd04 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -256,7 +256,7 @@</span> <span class="p_context"> struct __packed vmcs12 {</span>
 	/*
 	 * To allow migration of L1 (complete with its L2 guests) between
 	 * machines of different natural widths (32 or 64 bit), we cannot have
<span class="p_del">-	 * unsigned long fields with no explict size. We use u64 (aliased</span>
<span class="p_add">+	 * unsigned long fields with no explicit size. We use u64 (aliased</span>
 	 * natural_width) instead. Luckily, x86 is little-endian.
 	 */
 	natural_width cr0_guest_host_mask;
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/platform_pcal9555a.c b/arch/x86/platform/intel-mid/device_libs/platform_pcal9555a.c</span>
<span class="p_header">index 429a941..8344d5a 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/device_libs/platform_pcal9555a.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/device_libs/platform_pcal9555a.c</span>
<span class="p_chunk">@@ -1,5 +1,5 @@</span> <span class="p_context"></span>
 /*
<span class="p_del">- * PCAL9555a platform data initilization file</span>
<span class="p_add">+ * PCAL9555a platform data initialization file</span>
  *
  * Copyright (C) 2016, Intel Corporation
  *
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/platform_spidev.c b/arch/x86/platform/intel-mid/device_libs/platform_spidev.c</span>
<span class="p_header">index 30c601b..fea8ffe 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/device_libs/platform_spidev.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/device_libs/platform_spidev.c</span>
<span class="p_chunk">@@ -1,5 +1,5 @@</span> <span class="p_context"></span>
 /*
<span class="p_del">- * spidev platform data initilization file</span>
<span class="p_add">+ * spidev platform data initialization file</span>
  *
  * (C) Copyright 2014, 2016 Intel Corporation
  * Authors: Andy Shevchenko &lt;andriy.shevchenko@linux.intel.com&gt;
<span class="p_header">diff --git a/arch/xtensa/include/asm/initialize_mmu.h b/arch/xtensa/include/asm/initialize_mmu.h</span>
<span class="p_header">index 7a1e075..853cb6f 100644</span>
<span class="p_header">--- a/arch/xtensa/include/asm/initialize_mmu.h</span>
<span class="p_header">+++ b/arch/xtensa/include/asm/initialize_mmu.h</span>
<span class="p_chunk">@@ -54,7 +54,7 @@</span> <span class="p_context"></span>
 				 */
 #else
 	movi	a3, 0x29	/* non-MX -- Most cores use Std Memory
<span class="p_del">-				 * Controlers which usually can&#39;t use RCW</span>
<span class="p_add">+				 * Controllers which usually can&#39;t use RCW</span>
 				 */
 #endif
 	wsr	a3, atomctl
<span class="p_header">diff --git a/block/blk-merge.c b/block/blk-merge.c</span>
<span class="p_header">index 2642e5f..cf2a739 100644</span>
<span class="p_header">--- a/block/blk-merge.c</span>
<span class="p_header">+++ b/block/blk-merge.c</span>
<span class="p_chunk">@@ -213,7 +213,7 @@</span> <span class="p_context"> void blk_queue_split(struct request_queue *q, struct bio **bio,</span>
 	bio_set_flag(res, BIO_SEG_VALID);
 
 	if (split) {
<span class="p_del">-		/* there isn&#39;t chance to merge the splitted bio */</span>
<span class="p_add">+		/* there isn&#39;t chance to merge the split bio */</span>
 		split-&gt;bi_opf |= REQ_NOMERGE;
 
 		bio_chain(split, *bio);
<span class="p_header">diff --git a/block/blk-throttle.c b/block/blk-throttle.c</span>
<span class="p_header">index f1aba26..cc7ef73 100644</span>
<span class="p_header">--- a/block/blk-throttle.c</span>
<span class="p_header">+++ b/block/blk-throttle.c</span>
<span class="p_chunk">@@ -185,7 +185,7 @@</span> <span class="p_context"> static struct throtl_grp *sq_to_tg(struct throtl_service_queue *sq)</span>
  * sq_to_td - return throtl_data the specified service queue belongs to
  * @sq: the throtl_service_queue of interest
  *
<span class="p_del">- * A service_queue can be embeded in either a throtl_grp or throtl_data.</span>
<span class="p_add">+ * A service_queue can be embedded in either a throtl_grp or throtl_data.</span>
  * Determine the associated throtl_data accordingly and return it.
  */
 static struct throtl_data *sq_to_td(struct throtl_service_queue *sq)
<span class="p_header">diff --git a/block/cfq-iosched.c b/block/cfq-iosched.c</span>
<span class="p_header">index cc2f6db..1c7f218 100644</span>
<span class="p_header">--- a/block/cfq-iosched.c</span>
<span class="p_header">+++ b/block/cfq-iosched.c</span>
<span class="p_chunk">@@ -419,7 +419,7 @@</span> <span class="p_context"> enum cfqq_state_flags {</span>
 	CFQ_CFQQ_FLAG_slice_new,	/* no requests dispatched in slice */
 	CFQ_CFQQ_FLAG_sync,		/* synchronous queue */
 	CFQ_CFQQ_FLAG_coop,		/* cfqq is shared */
<span class="p_del">-	CFQ_CFQQ_FLAG_split_coop,	/* shared cfqq will be splitted */</span>
<span class="p_add">+	CFQ_CFQQ_FLAG_split_coop,	/* shared cfqq will be split */</span>
 	CFQ_CFQQ_FLAG_deep,		/* sync cfqq experienced large depth */
 	CFQ_CFQQ_FLAG_wait_busy,	/* Waiting for next request */
 };
<span class="p_chunk">@@ -1459,7 +1459,7 @@</span> <span class="p_context"> static inline u64 cfq_cfqq_slice_usage(struct cfq_queue *cfqq,</span>
 	if (!cfqq-&gt;slice_start || cfqq-&gt;slice_start == now) {
 		/*
 		 * Also charge the seek time incurred to the group, otherwise
<span class="p_del">-		 * if there are mutiple queues in the group, each can dispatch</span>
<span class="p_add">+		 * if there are multiple queues in the group, each can dispatch</span>
 		 * a single request on seeky media and cause lots of seek time
 		 * and group will never know it.
 		 */
<span class="p_header">diff --git a/block/scsi_ioctl.c b/block/scsi_ioctl.c</span>
<span class="p_header">index 0774799..6f87e75 100644</span>
<span class="p_header">--- a/block/scsi_ioctl.c</span>
<span class="p_header">+++ b/block/scsi_ioctl.c</span>
<span class="p_chunk">@@ -468,7 +468,7 @@</span> <span class="p_context"> int sg_scsi_ioctl(struct request_queue *q, struct gendisk *disk, fmode_t mode,</span>
 	if (err)
 		goto error;
 
<span class="p_del">-	/* default.  possible overriden later */</span>
<span class="p_add">+	/* default.  possibly overridden later */</span>
 	rq-&gt;retries = 5;
 
 	switch (opcode) {
<span class="p_header">diff --git a/drivers/acpi/Kconfig b/drivers/acpi/Kconfig</span>
<span class="p_header">index 445ce28..cda6b8c 100644</span>
<span class="p_header">--- a/drivers/acpi/Kconfig</span>
<span class="p_header">+++ b/drivers/acpi/Kconfig</span>
<span class="p_chunk">@@ -101,7 +101,7 @@</span> <span class="p_context"> config ACPI_PROCFS_POWER</span>
 	  Say N to delete power /proc/acpi/ directories that have moved to /sys/
 
 config ACPI_REV_OVERRIDE_POSSIBLE
<span class="p_del">-	bool &quot;Allow supported ACPI revision to be overriden&quot;</span>
<span class="p_add">+	bool &quot;Allow supported ACPI revision to be overridden&quot;</span>
 	depends on X86
 	default y
 	help
<span class="p_header">diff --git a/drivers/acpi/acpica/acmacros.h b/drivers/acpi/acpica/acmacros.h</span>
<span class="p_header">index a3b9543..736672c 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/acmacros.h</span>
<span class="p_header">+++ b/drivers/acpi/acpica/acmacros.h</span>
<span class="p_chunk">@@ -46,7 +46,7 @@</span> <span class="p_context"></span>
 
 /*
  * Extract data using a pointer. Any more than a byte and we
<span class="p_del">- * get into potential aligment issues -- see the STORE macros below.</span>
<span class="p_add">+ * get into potential alignment issues -- see the STORE macros below.</span>
  * Use with care.
  */
 #define ACPI_CAST8(ptr)                 ACPI_CAST_PTR (u8, (ptr))
<span class="p_header">diff --git a/drivers/acpi/acpica/nsload.c b/drivers/acpi/acpica/nsload.c</span>
<span class="p_header">index b5e2b0a..38b8514 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/nsload.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/nsload.c</span>
<span class="p_chunk">@@ -114,7 +114,7 @@</span> <span class="p_context"> acpi_ns_load_table(u32 table_index, struct acpi_namespace_node *node)</span>
 		/*
 		 * On error, delete any namespace objects created by this table.
 		 * We cannot initialize these objects, so delete them. There are
<span class="p_del">-		 * a couple of expecially bad cases:</span>
<span class="p_add">+		 * a couple of especially bad cases:</span>
 		 * AE_ALREADY_EXISTS - namespace collision.
 		 * AE_NOT_FOUND - the target of a Scope operator does not
 		 * exist. This target of Scope must already exist in the
<span class="p_header">diff --git a/drivers/acpi/resource.c b/drivers/acpi/resource.c</span>
<span class="p_header">index 56241eb..2ad13fe 100644</span>
<span class="p_header">--- a/drivers/acpi/resource.c</span>
<span class="p_header">+++ b/drivers/acpi/resource.c</span>
<span class="p_chunk">@@ -393,7 +393,7 @@</span> <span class="p_context"> static void acpi_dev_get_irqresource(struct resource *res, u32 gsi,</span>
 	}
 
 	/*
<span class="p_del">-	 * In IO-APIC mode, use overrided attribute. Two reasons:</span>
<span class="p_add">+	 * In IO-APIC mode, use overridden attribute. Two reasons:</span>
 	 * 1. BIOS bug in DSDT
 	 * 2. BIOS uses IO-APIC mode Interrupt Source Override
 	 *
<span class="p_chunk">@@ -565,7 +565,7 @@</span> <span class="p_context"> static acpi_status acpi_dev_process_resource(struct acpi_resource *ares,</span>
  * @preproc_data: Pointer passed to the caller&#39;s preprocessing routine.
  *
  * Evaluate the _CRS method for the given device node and process its output by
<span class="p_del">- * (1) executing the @preproc() rountine provided by the caller, passing the</span>
<span class="p_add">+ * (1) executing the @preproc() routine provided by the caller, passing the</span>
  * resource pointer and @preproc_data to it as arguments, for each ACPI resource
  * returned and (2) converting all of the returned ACPI resources into struct
  * resource objects if possible.  If the return value of @preproc() in step (1)
<span class="p_header">diff --git a/drivers/ata/libata-eh.c b/drivers/ata/libata-eh.c</span>
<span class="p_header">index 0e1ec37..01ba149 100644</span>
<span class="p_header">--- a/drivers/ata/libata-eh.c</span>
<span class="p_header">+++ b/drivers/ata/libata-eh.c</span>
<span class="p_chunk">@@ -2033,7 +2033,7 @@</span> <span class="p_context"> static int speed_down_verdict_cb(struct ata_ering_entry *ent, void *void_arg)</span>
  *	This is to expedite speed down decisions right after device is
  *	initially configured.
  *
<span class="p_del">- *	The followings are speed down rules.  #1 and #2 deal with</span>
<span class="p_add">+ *	The following are speed down rules.  #1 and #2 deal with</span>
  *	DUBIOUS errors.
  *
  *	1. If more than one DUBIOUS_ATA_BUS or DUBIOUS_TOUT_HSM errors
<span class="p_header">diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c</span>
<span class="p_header">index 809dd1e..44153cb 100644</span>
<span class="p_header">--- a/drivers/atm/iphase.c</span>
<span class="p_header">+++ b/drivers/atm/iphase.c</span>
<span class="p_chunk">@@ -18,10 +18,10 @@</span> <span class="p_context"></span>
       
       Modified from an incomplete driver for Interphase 5575 1KVC 1M card which 
       was originally written by Monalisa Agrawal at UNH. Now this driver 
<span class="p_del">-      supports a variety of varients of Interphase ATM PCI (i)Chip adapter </span>
<span class="p_add">+      supports a variety of variants of Interphase ATM PCI (i)Chip adapter</span>
       card family (See www.iphase.com/products/ClassSheet.cfm?ClassID=ATM) 
       in terms of PHY type, the size of control memory and the size of 
<span class="p_del">-      packet memory. The followings are the change log and history:</span>
<span class="p_add">+      packet memory. The following are the change log and history:</span>
      
           Bugfix the Mona&#39;s UBR driver.
           Modify the basic memory allocation and dma logic.
<span class="p_header">diff --git a/drivers/atm/iphase.h b/drivers/atm/iphase.h</span>
<span class="p_header">index 53ecac5..1b74bd0 100644</span>
<span class="p_header">--- a/drivers/atm/iphase.h</span>
<span class="p_header">+++ b/drivers/atm/iphase.h</span>
<span class="p_chunk">@@ -18,10 +18,10 @@</span> <span class="p_context"></span>
       
       Modified from an incomplete driver for Interphase 5575 1KVC 1M card which 
       was originally written by Monalisa Agrawal at UNH. Now this driver 
<span class="p_del">-      supports a variety of varients of Interphase ATM PCI (i)Chip adapter </span>
<span class="p_add">+      supports a variety of variants of Interphase ATM PCI (i)Chip adapter</span>
       card family (See www.iphase.com/products/ClassSheet.cfm?ClassID=ATM) 
       in terms of PHY type, the size of control memory and the size of 
<span class="p_del">-      packet memory. The followings are the change log and history:</span>
<span class="p_add">+      packet memory. The following are the change log and history:</span>
      
           Bugfix the Mona&#39;s UBR driver.
           Modify the basic memory allocation and dma logic.
<span class="p_header">diff --git a/drivers/block/loop.c b/drivers/block/loop.c</span>
<span class="p_header">index c9f2107..36c554f 100644</span>
<span class="p_header">--- a/drivers/block/loop.c</span>
<span class="p_header">+++ b/drivers/block/loop.c</span>
<span class="p_chunk">@@ -186,7 +186,7 @@</span> <span class="p_context"> static void __loop_update_dio(struct loop_device *lo, bool dio)</span>
 	 *
 	 * TODO: the above condition may be loosed in the future, and
 	 * direct I/O may be switched runtime at that time because most
<span class="p_del">-	 * of requests in sane appplications should be PAGE_SIZE algined</span>
<span class="p_add">+	 * of requests in sane applications should be PAGE_SIZE aligned</span>
 	 */
 	if (dio) {
 		if (queue_logical_block_size(lo-&gt;lo_queue) &gt;= sb_bsize &amp;&amp;
<span class="p_header">diff --git a/drivers/block/mtip32xx/mtip32xx.h b/drivers/block/mtip32xx/mtip32xx.h</span>
<span class="p_header">index 7617888..fe10980 100644</span>
<span class="p_header">--- a/drivers/block/mtip32xx/mtip32xx.h</span>
<span class="p_header">+++ b/drivers/block/mtip32xx/mtip32xx.h</span>
<span class="p_chunk">@@ -27,10 +27,10 @@</span> <span class="p_context"></span>
 #include &lt;linux/interrupt.h&gt;
 #include &lt;linux/genhd.h&gt;
 
<span class="p_del">-/* Offset of Subsystem Device ID in pci confoguration space */</span>
<span class="p_add">+/* Offset of Subsystem Device ID in pci configuration space */</span>
 #define PCI_SUBSYSTEM_DEVICEID	0x2E
 
<span class="p_del">-/* offset of Device Control register in PCIe extended capabilites space */</span>
<span class="p_add">+/* offset of Device Control register in PCIe extended capabilities space */</span>
 #define PCIE_CONFIG_EXT_DEVICE_CONTROL_OFFSET	0x48
 
 /* check for erase mode support during secure erase */
<span class="p_header">diff --git a/drivers/block/paride/pcd.c b/drivers/block/paride/pcd.c</span>
<span class="p_header">index 9336236..e5b4ac4 100644</span>
<span class="p_header">--- a/drivers/block/paride/pcd.c</span>
<span class="p_header">+++ b/drivers/block/paride/pcd.c</span>
<span class="p_chunk">@@ -50,7 +50,7 @@</span> <span class="p_context"></span>
                         the slower the port i/o.  In some cases, setting
                         this to zero will speed up the device. (default -1)
                         
<span class="p_del">-            major       You may use this parameter to overide the</span>
<span class="p_add">+            major       You may use this parameter to override the</span>
                         default major number (46) that this driver
                         will use.  Be sure to change the device
                         name as well.
<span class="p_header">diff --git a/drivers/block/paride/pd.c b/drivers/block/paride/pd.c</span>
<span class="p_header">index 78a39f7..c00c3c6 100644</span>
<span class="p_header">--- a/drivers/block/paride/pd.c</span>
<span class="p_header">+++ b/drivers/block/paride/pd.c</span>
<span class="p_chunk">@@ -61,7 +61,7 @@</span> <span class="p_context"></span>
                         first drive found.
 			
 
<span class="p_del">-            major       You may use this parameter to overide the</span>
<span class="p_add">+            major       You may use this parameter to override the</span>
                         default major number (45) that this driver
                         will use.  Be sure to change the device
                         name as well.
<span class="p_header">diff --git a/drivers/block/paride/pf.c b/drivers/block/paride/pf.c</span>
<span class="p_header">index 7a7d977..e26a987 100644</span>
<span class="p_header">--- a/drivers/block/paride/pf.c</span>
<span class="p_header">+++ b/drivers/block/paride/pf.c</span>
<span class="p_chunk">@@ -59,7 +59,7 @@</span> <span class="p_context"></span>
                         the slower the port i/o.  In some cases, setting
                         this to zero will speed up the device. (default -1)
 
<span class="p_del">-	    major	You may use this parameter to overide the</span>
<span class="p_add">+	    major	You may use this parameter to override the</span>
 			default major number (47) that this driver
 			will use.  Be sure to change the device
 			name as well.
<span class="p_header">diff --git a/drivers/block/paride/pg.c b/drivers/block/paride/pg.c</span>
<span class="p_header">index bfbd4c8..e4054e3 100644</span>
<span class="p_header">--- a/drivers/block/paride/pg.c</span>
<span class="p_header">+++ b/drivers/block/paride/pg.c</span>
<span class="p_chunk">@@ -84,7 +84,7 @@</span> <span class="p_context"></span>
 			the slower the port i/o.  In some cases, setting
 			this to zero will speed up the device. (default -1)
 
<span class="p_del">-	    major	You may use this parameter to overide the</span>
<span class="p_add">+	    major	You may use this parameter to override the</span>
 			default major number (97) that this driver
 			will use.  Be sure to change the device
 			name as well.
<span class="p_header">diff --git a/drivers/block/paride/pt.c b/drivers/block/paride/pt.c</span>
<span class="p_header">index 216a94f..30661d2 100644</span>
<span class="p_header">--- a/drivers/block/paride/pt.c</span>
<span class="p_header">+++ b/drivers/block/paride/pt.c</span>
<span class="p_chunk">@@ -61,7 +61,7 @@</span> <span class="p_context"></span>
                         the slower the port i/o.  In some cases, setting
                         this to zero will speed up the device. (default -1)
 
<span class="p_del">-	    major	You may use this parameter to overide the</span>
<span class="p_add">+	    major	You may use this parameter to override the</span>
 			default major number (96) that this driver
 			will use.  Be sure to change the device
 			name as well.
<span class="p_header">diff --git a/drivers/bus/mvebu-mbus.c b/drivers/bus/mvebu-mbus.c</span>
<span class="p_header">index c7f3969..e8f8ae9 100644</span>
<span class="p_header">--- a/drivers/bus/mvebu-mbus.c</span>
<span class="p_header">+++ b/drivers/bus/mvebu-mbus.c</span>
<span class="p_chunk">@@ -123,7 +123,7 @@</span> <span class="p_context"> struct mvebu_mbus_soc_data {</span>
 };
 
 /*
<span class="p_del">- * Used to store the state of one MBus window accross suspend/resume.</span>
<span class="p_add">+ * Used to store the state of one MBus window across suspend/resume.</span>
  */
 struct mvebu_mbus_win_data {
 	u32 ctrl;
<span class="p_header">diff --git a/drivers/cdrom/gdrom.c b/drivers/cdrom/gdrom.c</span>
<span class="p_header">index 584bc31..19ef951 100644</span>
<span class="p_header">--- a/drivers/cdrom/gdrom.c</span>
<span class="p_header">+++ b/drivers/cdrom/gdrom.c</span>
<span class="p_chunk">@@ -463,7 +463,7 @@</span> <span class="p_context"> static int gdrom_getsense(short *bufstring)</span>
 		pr_info(&quot;%s\n&quot;, sense_texts[sense_key].text);
 	else
 		pr_err(&quot;Unknown sense key: %d\n&quot;, sense_key);
<span class="p_del">-	if (bufstring) /* return addional sense data */</span>
<span class="p_add">+	if (bufstring) /* return additional sense data */</span>
 		memcpy(bufstring, &amp;sense[4], 2);
 	if (sense_key &lt; 2)
 		err = 0;
<span class="p_header">diff --git a/drivers/char/agp/i460-agp.c b/drivers/char/agp/i460-agp.c</span>
<span class="p_header">index 15b240e..77b7f6b 100644</span>
<span class="p_header">--- a/drivers/char/agp/i460-agp.c</span>
<span class="p_header">+++ b/drivers/char/agp/i460-agp.c</span>
<span class="p_chunk">@@ -495,7 +495,7 @@</span> <span class="p_context"> static int i460_remove_memory_large_io_page (struct agp_memory *mem,</span>
 	return 0;
 }
 
<span class="p_del">-/* Wrapper routines to call the approriate {small_io_page,large_io_page} function */</span>
<span class="p_add">+/* Wrapper routines to call the appropriate {small_io_page,large_io_page} function */</span>
 
 static int i460_insert_memory (struct agp_memory *mem,
 				off_t pg_start, int type)
<span class="p_header">diff --git a/drivers/char/lp.c b/drivers/char/lp.c</span>
<span class="p_header">index c4094c4..3609a4e 100644</span>
<span class="p_header">--- a/drivers/char/lp.c</span>
<span class="p_header">+++ b/drivers/char/lp.c</span>
<span class="p_chunk">@@ -29,7 +29,7 @@</span> <span class="p_context"></span>
  * CAREFUL will block a bit after in lp_check_status().
  *				Andrea Arcangeli, 15 Oct 1998
  * Obsoleted and removed all the lowlevel stuff implemented in the last
<span class="p_del">- * month to use the IEEE1284 functions (that handle the _new_ compatibilty</span>
<span class="p_add">+ * month to use the IEEE1284 functions (that handle the _new_ compatibility</span>
  * mode fine).
  */
 
<span class="p_header">diff --git a/drivers/char/pcmcia/cm4000_cs.c b/drivers/char/pcmcia/cm4000_cs.c</span>
<span class="p_header">index c115217..453a248 100644</span>
<span class="p_header">--- a/drivers/char/pcmcia/cm4000_cs.c</span>
<span class="p_header">+++ b/drivers/char/pcmcia/cm4000_cs.c</span>
<span class="p_chunk">@@ -655,7 +655,7 @@</span> <span class="p_context"> static void terminate_monitor(struct cm4000_dev *dev)</span>
  * monitor the card every 50msec. as a side-effect, retrieve the
  * atr once a card is inserted. another side-effect of retrieving the
  * atr is that the card will be powered on, so there is no need to
<span class="p_del">- * power on the card explictely from the application: the driver</span>
<span class="p_add">+ * power on the card explicitly from the application: the driver</span>
  * is already doing that for you.
  */
 
<span class="p_header">diff --git a/drivers/char/sonypi.c b/drivers/char/sonypi.c</span>
<span class="p_header">index e496dae..0767c81 100644</span>
<span class="p_header">--- a/drivers/char/sonypi.c</span>
<span class="p_header">+++ b/drivers/char/sonypi.c</span>
<span class="p_chunk">@@ -603,7 +603,7 @@</span> <span class="p_context"> static void sonypi_type3_srs(void)</span>
 	u16 v16;
 	u8  v8;
 
<span class="p_del">-	/* This model type uses the same initialiazation of</span>
<span class="p_add">+	/* This model type uses the same initialization of</span>
 	 * the embedded controller as the type2 models. */
 	sonypi_type2_srs();
 
<span class="p_header">diff --git a/drivers/clocksource/tcb_clksrc.c b/drivers/clocksource/tcb_clksrc.c</span>
<span class="p_header">index 4da2af9..e1bc655 100644</span>
<span class="p_header">--- a/drivers/clocksource/tcb_clksrc.c</span>
<span class="p_header">+++ b/drivers/clocksource/tcb_clksrc.c</span>
<span class="p_chunk">@@ -335,7 +335,7 @@</span> <span class="p_context"> static int __init tcb_clksrc_init(void)</span>
 			((divided_rate + 500000) % 1000000) / 1000);
 
 	if (tc-&gt;tcb_config &amp;&amp; tc-&gt;tcb_config-&gt;counter_width == 32) {
<span class="p_del">-		/* use apropriate function to read 32 bit counter */</span>
<span class="p_add">+		/* use appropriate function to read 32 bit counter */</span>
 		clksrc.read = tc_get_cycles32;
 		/* setup ony channel 0 */
 		tcb_setup_single_chan(tc, best_divisor_idx);
<span class="p_header">diff --git a/drivers/crypto/caam/ctrl.c b/drivers/crypto/caam/ctrl.c</span>
<span class="p_header">index 0ec112e..d1c8769 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/ctrl.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/ctrl.c</span>
<span class="p_chunk">@@ -63,7 +63,7 @@</span> <span class="p_context"> static void build_instantiation_desc(u32 *desc, int handle, int do_sk)</span>
 
 		/*
 		 * load 1 to clear written reg:
<span class="p_del">-		 * resets the done interrrupt and returns the RNG to idle.</span>
<span class="p_add">+		 * resets the done interrupt and returns the RNG to idle.</span>
 		 */
 		append_load_imm_u32(desc, 1, LDST_SRCDST_WORD_CLRW);
 
<span class="p_chunk">@@ -148,7 +148,7 @@</span> <span class="p_context"> static inline int run_descriptor_deco0(struct device *ctrldev, u32 *desc,</span>
 	do {
 		deco_dbg_reg = rd_reg32(&amp;deco-&gt;desc_dbg);
 		/*
<span class="p_del">-		 * If an error occured in the descriptor, then</span>
<span class="p_add">+		 * If an error occurred in the descriptor, then</span>
 		 * the DECO status field will be set to 0x0D
 		 */
 		if ((deco_dbg_reg &amp; DESC_DBG_DECO_STAT_MASK) ==
<span class="p_chunk">@@ -269,7 +269,7 @@</span> <span class="p_context"> static int deinstantiate_rng(struct device *ctrldev, int state_handle_mask)</span>
 		/*
 		 * If the corresponding bit is set, then it means the state
 		 * handle was initialized by us, and thus it needs to be
<span class="p_del">-		 * deintialized as well</span>
<span class="p_add">+		 * deinitialized as well</span>
 		 */
 		if ((1 &lt;&lt; sh_idx) &amp; state_handle_mask) {
 			/*
<span class="p_chunk">@@ -393,7 +393,7 @@</span> <span class="p_context"> static void kick_trng(struct platform_device *pdev, int ent_delay)</span>
 
 /**
  * caam_get_era() - Return the ERA of the SEC on SoC, based
<span class="p_del">- * on &quot;sec-era&quot; propery in the DTS. This property is updated by u-boot.</span>
<span class="p_add">+ * on &quot;sec-era&quot; property in the DTS. This property is updated by u-boot.</span>
  **/
 int caam_get_era(void)
 {
<span class="p_chunk">@@ -562,7 +562,7 @@</span> <span class="p_context"> static int caam_probe(struct platform_device *pdev)</span>
 		      (sizeof(dma_addr_t) == sizeof(u64) ? MCFGR_LONG_PTR : 0));
 
 	/*
<span class="p_del">-	 *  Read the Compile Time paramters and SCFGR to determine</span>
<span class="p_add">+	 *  Read the Compile Time parameters and SCFGR to determine</span>
 	 * if Virtualization is enabled for this platform
 	 */
 	scfgr = rd_reg32(&amp;ctrl-&gt;scfgr);
<span class="p_header">diff --git a/drivers/crypto/caam/desc.h b/drivers/crypto/caam/desc.h</span>
<span class="p_header">index 26427c1..69e971b 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/desc.h</span>
<span class="p_header">+++ b/drivers/crypto/caam/desc.h</span>
<span class="p_chunk">@@ -123,7 +123,7 @@</span> <span class="p_context"> struct sec4_sg_entry {</span>
  */
 #define HDR_REVERSE		0x00000800
 
<span class="p_del">-/* Propogate DNR property to SharedDesc */</span>
<span class="p_add">+/* Propagate DNR property to SharedDesc */</span>
 #define HDR_PROP_DNR		0x00000800
 
 /* JobDesc/SharedDesc share property */
<span class="p_header">diff --git a/drivers/devfreq/devfreq-event.c b/drivers/devfreq/devfreq-event.c</span>
<span class="p_header">index 9aea2c7..aa8912c 100644</span>
<span class="p_header">--- a/drivers/devfreq/devfreq-event.c</span>
<span class="p_header">+++ b/drivers/devfreq/devfreq-event.c</span>
<span class="p_chunk">@@ -103,7 +103,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(devfreq_event_disable_edev);</span>
  * @edev	: the devfreq-event device
  *
  * Note that this function check whether devfreq-event dev is enabled or not.
<span class="p_del">- * If return true, the devfreq-event dev is enabeld. If return false, the</span>
<span class="p_add">+ * If return true, the devfreq-event dev is enabled. If return false, the</span>
  * devfreq-event dev is disabled.
  */
 bool devfreq_event_is_enabled(struct devfreq_event_dev *edev)
<span class="p_header">diff --git a/drivers/devfreq/devfreq.c b/drivers/devfreq/devfreq.c</span>
<span class="p_header">index 478006b..de4220f 100644</span>
<span class="p_header">--- a/drivers/devfreq/devfreq.c</span>
<span class="p_header">+++ b/drivers/devfreq/devfreq.c</span>
<span class="p_chunk">@@ -1202,7 +1202,7 @@</span> <span class="p_context"> static int __init devfreq_init(void)</span>
 subsys_initcall(devfreq_init);
 
 /*
<span class="p_del">- * The followings are helper functions for devfreq user device drivers with</span>
<span class="p_add">+ * The following are helper functions for devfreq user device drivers with</span>
  * OPP framework.
  */
 
<span class="p_header">diff --git a/drivers/dma/iop-adma.c b/drivers/dma/iop-adma.c</span>
<span class="p_header">index f039cfa..55caa0b 100644</span>
<span class="p_header">--- a/drivers/dma/iop-adma.c</span>
<span class="p_header">+++ b/drivers/dma/iop-adma.c</span>
<span class="p_chunk">@@ -1315,7 +1315,7 @@</span> <span class="p_context"> static int iop_adma_probe(struct platform_device *pdev)</span>
 
 	adev-&gt;id = plat_data-&gt;hw_id;
 
<span class="p_del">-	/* discover transaction capabilites from the platform data */</span>
<span class="p_add">+	/* discover transaction capabilities from the platform data */</span>
 	dma_dev-&gt;cap_mask = plat_data-&gt;cap_mask;
 
 	adev-&gt;pdev = pdev;
<span class="p_header">diff --git a/drivers/dma/mv_xor.c b/drivers/dma/mv_xor.c</span>
<span class="p_header">index f4c9f98..817e80d 100644</span>
<span class="p_header">--- a/drivers/dma/mv_xor.c</span>
<span class="p_header">+++ b/drivers/dma/mv_xor.c</span>
<span class="p_chunk">@@ -980,7 +980,7 @@</span> <span class="p_context"> mv_xor_channel_add(struct mv_xor_device *xordev,</span>
 	if (!mv_chan-&gt;dma_desc_pool_virt)
 		return ERR_PTR(-ENOMEM);
 
<span class="p_del">-	/* discover transaction capabilites from the platform data */</span>
<span class="p_add">+	/* discover transaction capabilities from the platform data */</span>
 	dma_dev-&gt;cap_mask = cap_mask;
 
 	INIT_LIST_HEAD(&amp;dma_dev-&gt;channels);
<span class="p_header">diff --git a/drivers/dma/zx296702_dma.c b/drivers/dma/zx296702_dma.c</span>
<span class="p_header">index 245d759..ce3458c 100644</span>
<span class="p_header">--- a/drivers/dma/zx296702_dma.c</span>
<span class="p_header">+++ b/drivers/dma/zx296702_dma.c</span>
<span class="p_chunk">@@ -885,7 +885,7 @@</span> <span class="p_context"> static int zx_dma_remove(struct platform_device *op)</span>
 	struct zx_dma_chan *c, *cn;
 	struct zx_dma_dev *d = platform_get_drvdata(op);
 
<span class="p_del">-	/* explictly free the irq */</span>
<span class="p_add">+	/* explicitly free the irq */</span>
 	devm_free_irq(&amp;op-&gt;dev, d-&gt;irq, d);
 
 	dma_async_device_unregister(&amp;d-&gt;slave);
<span class="p_header">diff --git a/drivers/edac/ppc4xx_edac.c b/drivers/edac/ppc4xx_edac.c</span>
<span class="p_header">index d3a64ba..efdda090 100644</span>
<span class="p_header">--- a/drivers/edac/ppc4xx_edac.c</span>
<span class="p_header">+++ b/drivers/edac/ppc4xx_edac.c</span>
<span class="p_chunk">@@ -1045,7 +1045,7 @@</span> <span class="p_context"> static int ppc4xx_edac_mc_init(struct mem_ctl_info *mci,</span>
 	mci-&gt;scrub_mode		= SCRUB_NONE;
 
 	/*
<span class="p_del">-	 * Update the actual capabilites based on the MCOPT1[MCHK]</span>
<span class="p_add">+	 * Update the actual capabilities based on the MCOPT1[MCHK]</span>
 	 * settings. Scrubbing is only useful if reporting is enabled.
 	 */
 
<span class="p_header">diff --git a/drivers/extcon/extcon-rt8973a.c b/drivers/extcon/extcon-rt8973a.c</span>
<span class="p_header">index 97e074d..8a0f04b 100644</span>
<span class="p_header">--- a/drivers/extcon/extcon-rt8973a.c</span>
<span class="p_header">+++ b/drivers/extcon/extcon-rt8973a.c</span>
<span class="p_chunk">@@ -535,7 +535,7 @@</span> <span class="p_context"> static void rt8973a_init_dev_type(struct rt8973a_muic_info *info)</span>
 		regmap_update_bits(info-&gt;regmap, reg, mask, val);
 	}
 
<span class="p_del">-	/* Check whether RT8973A is auto swithcing mode or not */</span>
<span class="p_add">+	/* Check whether RT8973A is auto switching mode or not */</span>
 	ret = regmap_read(info-&gt;regmap, RT8973A_REG_CONTROL1, &amp;data);
 	if (ret) {
 		dev_err(info-&gt;dev,
<span class="p_header">diff --git a/drivers/firewire/core-device.c b/drivers/firewire/core-device.c</span>
<span class="p_header">index f9e3aee..7c2eed7 100644</span>
<span class="p_header">--- a/drivers/firewire/core-device.c</span>
<span class="p_header">+++ b/drivers/firewire/core-device.c</span>
<span class="p_chunk">@@ -1068,7 +1068,7 @@</span> <span class="p_context"> static void fw_device_init(struct work_struct *work)</span>
 
 	/*
 	 * Transition the device to running state.  If it got pulled
<span class="p_del">-	 * out from under us while we did the intialization work, we</span>
<span class="p_add">+	 * out from under us while we did the initialization work, we</span>
 	 * have to shut down the device again here.  Normally, though,
 	 * fw_node_event will be responsible for shutting it down when
 	 * necessary.  We have to use the atomic cmpxchg here to avoid
<span class="p_chunk">@@ -1231,7 +1231,7 @@</span> <span class="p_context"> void fw_node_event(struct fw_card *card, struct fw_node *node, int event)</span>
 			break;
 
 		/*
<span class="p_del">-		 * Do minimal intialization of the device here, the</span>
<span class="p_add">+		 * Do minimal initialization of the device here, the</span>
 		 * rest will happen in fw_device_init().
 		 *
 		 * Attention:  A lot of things, even fw_device_get(),
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_powerplay.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_powerplay.c</span>
<span class="p_header">index c5738a22..684ffa3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_powerplay.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_powerplay.c</span>
<span class="p_chunk">@@ -112,7 +112,7 @@</span> <span class="p_context"> static int amdgpu_pp_early_init(void *handle)</span>
 	case CHIP_STONEY:
 		adev-&gt;pp_enabled = (amdgpu_powerplay &gt; 0) ? true : false;
 		break;
<span class="p_del">-	/* These chips don&#39;t have powerplay implemenations */</span>
<span class="p_add">+	/* These chips don&#39;t have powerplay implementations */</span>
 	case CHIP_BONAIRE:
 	case CHIP_HAWAII:
 	case CHIP_KABINI:
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/fiji_smc.c b/drivers/gpu/drm/amd/amdgpu/fiji_smc.c</span>
<span class="p_header">index b3e19ba..2bf1e37 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/fiji_smc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/fiji_smc.c</span>
<span class="p_chunk">@@ -71,7 +71,7 @@</span> <span class="p_context"> static int fiji_copy_bytes_to_smc(struct amdgpu_device *adev, uint32_t smc_start</span>
 
 	spin_lock_irqsave(&amp;adev-&gt;smc_idx_lock, flags);
 	while (byte_count &gt;= 4) {
<span class="p_del">-		/* Bytes are written into the SMC addres space with the MSB first */</span>
<span class="p_add">+		/* Bytes are written into the SMC address space with the MSB first */</span>
 		data = (src[0] &lt;&lt; 24) + (src[1] &lt;&lt; 16) + (src[2] &lt;&lt; 8) + src[3];
 
 		result = fiji_set_smc_sram_address(adev, addr, limit);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/iceland_smc.c b/drivers/gpu/drm/amd/amdgpu/iceland_smc.c</span>
<span class="p_header">index 2118399..008eeb2 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/iceland_smc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/iceland_smc.c</span>
<span class="p_chunk">@@ -75,7 +75,7 @@</span> <span class="p_context"> static int iceland_copy_bytes_to_smc(struct amdgpu_device *adev,</span>
 
 	spin_lock_irqsave(&amp;adev-&gt;smc_idx_lock, flags);
 	while (byte_count &gt;= 4) {
<span class="p_del">-		/* Bytes are written into the SMC addres space with the MSB first */</span>
<span class="p_add">+		/* Bytes are written into the SMC address space with the MSB first */</span>
 		data = (src[0] &lt;&lt; 24) + (src[1] &lt;&lt; 16) + (src[2] &lt;&lt; 8) + src[3];
 
 		result = iceland_set_smc_sram_address(adev, addr, limit);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/tonga_smc.c b/drivers/gpu/drm/amd/amdgpu/tonga_smc.c</span>
<span class="p_header">index 940de18..2943447 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/tonga_smc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/tonga_smc.c</span>
<span class="p_chunk">@@ -71,7 +71,7 @@</span> <span class="p_context"> static int tonga_copy_bytes_to_smc(struct amdgpu_device *adev, uint32_t smc_star</span>
 
 	spin_lock_irqsave(&amp;adev-&gt;smc_idx_lock, flags);
 	while (byte_count &gt;= 4) {
<span class="p_del">-		/* Bytes are written into the SMC addres space with the MSB first */</span>
<span class="p_add">+		/* Bytes are written into the SMC address space with the MSB first */</span>
 		data = (src[0] &lt;&lt; 24) + (src[1] &lt;&lt; 16) + (src[2] &lt;&lt; 8) + src[3];
 
 		result = tonga_set_smc_sram_address(adev, addr, limit);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/include/atombios.h b/drivers/gpu/drm/amd/include/atombios.h</span>
<span class="p_header">index 3493da5..5ffa9e4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/include/atombios.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/include/atombios.h</span>
<span class="p_chunk">@@ -188,7 +188,7 @@</span> <span class="p_context"></span>
 #define HW_ASSISTED_I2C_STATUS_FAILURE     2
 #define HW_ASSISTED_I2C_STATUS_SUCCESS     1
 
<span class="p_del">-#pragma pack(1)                                       // BIOS data must use byte aligment</span>
<span class="p_add">+#pragma pack(1)                                       // BIOS data must use byte alignment</span>
 
 // Define offset to location of ROM header.
 #define OFFSET_TO_POINTER_TO_ATOM_ROM_HEADER         0x00000048L
<span class="p_chunk">@@ -1978,9 +1978,9 @@</span> <span class="p_context"> typedef struct _PIXEL_CLOCK_PARAMETERS_V6</span>
 #define PIXEL_CLOCK_V6_MISC_HDMI_BPP_MASK           0x0c
 #define PIXEL_CLOCK_V6_MISC_HDMI_24BPP              0x00
 #define PIXEL_CLOCK_V6_MISC_HDMI_36BPP              0x04
<span class="p_del">-#define PIXEL_CLOCK_V6_MISC_HDMI_36BPP_V6           0x08    //for V6, the correct defintion for 36bpp should be 2 for 36bpp(2:1)</span>
<span class="p_add">+#define PIXEL_CLOCK_V6_MISC_HDMI_36BPP_V6           0x08    //for V6, the correct definition for 36bpp should be 2 for 36bpp(2:1)</span>
 #define PIXEL_CLOCK_V6_MISC_HDMI_30BPP              0x08
<span class="p_del">-#define PIXEL_CLOCK_V6_MISC_HDMI_30BPP_V6           0x04    //for V6, the correct defintion for 30bpp should be 1 for 36bpp(5:4)</span>
<span class="p_add">+#define PIXEL_CLOCK_V6_MISC_HDMI_30BPP_V6           0x04    //for V6, the correct definition for 30bpp should be 1 for 36bpp(5:4)</span>
 #define PIXEL_CLOCK_V6_MISC_HDMI_48BPP              0x0c
 #define PIXEL_CLOCK_V6_MISC_REF_DIV_SRC             0x10
 #define PIXEL_CLOCK_V6_MISC_GEN_DPREFCLK            0x40
<span class="p_chunk">@@ -2191,7 +2191,7 @@</span> <span class="p_context"> typedef struct _GET_ENGINE_CLOCK_PARAMETERS</span>
 // Following Structures and constant may be obsolete
 /****************************************************************************/
 //Maxium 8 bytes,the data read in will be placed in the parameter space.
<span class="p_del">-//Read operaion successeful when the paramter space is non-zero, otherwise read operation failed</span>
<span class="p_add">+//Read operaion successeful when the parameter space is non-zero, otherwise read operation failed</span>
 typedef struct _READ_EDID_FROM_HW_I2C_DATA_PARAMETERS
 {
   USHORT    usPrescale;         //Ratio between Engine clock and I2C clock
<span class="p_chunk">@@ -2411,7 +2411,7 @@</span> <span class="p_context"> typedef struct _LVDS_ENCODER_CONTROL_PARAMETERS</span>
 typedef struct _LVDS_ENCODER_CONTROL_PARAMETERS_V2
 {
   USHORT usPixelClock;  // in 10KHz; for bios convenient
<span class="p_del">-  UCHAR  ucMisc;        // see PANEL_ENCODER_MISC_xx defintions below</span>
<span class="p_add">+  UCHAR  ucMisc;        // see PANEL_ENCODER_MISC_xx definitions below</span>
   UCHAR  ucAction;      // 0: turn off encoder
                         // 1: setup and turn on encoder
   UCHAR  ucTruncate;    // bit0=0: Disable truncate
<span class="p_chunk">@@ -2636,10 +2636,10 @@</span> <span class="p_context"> typedef struct   _SET_VOLTAGE_PARAMETERS_V1_3</span>
 #define ATOM_INIT_VOLTAGE_REGULATOR          3        //Init Regulator
 #define ATOM_SET_VOLTAGE_PHASE               4        //Set Vregulator Phase, only for SVID/PVID regulator
 #define ATOM_GET_MAX_VOLTAGE                 6        //Get Max Voltage, not used from SetVoltageTable v1.3
<span class="p_del">-#define ATOM_GET_VOLTAGE_LEVEL               6        //Get Voltage level from vitual voltage ID, not used for SetVoltage v1.4</span>
<span class="p_add">+#define ATOM_GET_VOLTAGE_LEVEL               6        //Get Voltage level from virtual voltage ID, not used for SetVoltage v1.4</span>
 #define ATOM_GET_LEAKAGE_ID                  8        //Get Leakage Voltage Id ( starting from SMU7x IP ), SetVoltage v1.4
 
<span class="p_del">-// define vitual voltage id in usVoltageLevel</span>
<span class="p_add">+// define virtual voltage id in usVoltageLevel</span>
 #define ATOM_VIRTUAL_VOLTAGE_ID0             0xff01
 #define ATOM_VIRTUAL_VOLTAGE_ID1             0xff02
 #define ATOM_VIRTUAL_VOLTAGE_ID2             0xff03
<span class="p_chunk">@@ -4081,7 +4081,7 @@</span> <span class="p_context"> typedef struct  _ATOM_LCD_RTS_RECORD</span>
   UCHAR     ucRTSValue;
 }ATOM_LCD_RTS_RECORD;
 
<span class="p_del">-//!! If the record below exits, it shoud always be the first record for easy use in command table!!!</span>
<span class="p_add">+//!! If the record below exits, it should always be the first record for easy use in command table!!!</span>
 // The record below is only used when LVDS_Info is present. From ATOM_LVDS_INFO_V12, use ucLCDPanel_SpecialHandlingCap instead.
 typedef struct  _ATOM_LCD_MODE_CONTROL_CAP
 {
<span class="p_chunk">@@ -4097,7 +4097,7 @@</span> <span class="p_context"> typedef struct  _ATOM_LCD_MODE_CONTROL_CAP</span>
 typedef struct _ATOM_FAKE_EDID_PATCH_RECORD
 {
   UCHAR ucRecordType;
<span class="p_del">-  UCHAR ucFakeEDIDLength;       // = 128 means EDID lenght is 128 bytes, otherwise the EDID length = ucFakeEDIDLength*128</span>
<span class="p_add">+  UCHAR ucFakeEDIDLength;       // = 128 means EDID length is 128 bytes, otherwise the EDID length = ucFakeEDIDLength*128</span>
   UCHAR ucFakeEDIDString[1];    // This actually has ucFakeEdidLength elements.
 } ATOM_FAKE_EDID_PATCH_RECORD;
 
<span class="p_chunk">@@ -4359,7 +4359,7 @@</span> <span class="p_context"> typedef struct _ATOM_GPIO_PIN_ASSIGNMENT</span>
 // GPIO use to control PCIE_VDDC in certain SLT board
 #define PCIE_VDDC_CONTROL_GPIO_PINID        56
 
<span class="p_del">-//from SMU7.x, if ucGPIO_ID=PP_AC_DC_SWITCH_GPIO_PINID in GPIO_LUTTable, AC/DC swithing feature is enable</span>
<span class="p_add">+//from SMU7.x, if ucGPIO_ID=PP_AC_DC_SWITCH_GPIO_PINID in GPIO_LUTTable, AC/DC switching feature is enable</span>
 #define PP_AC_DC_SWITCH_GPIO_PINID          60
 //from SMU7.x, if ucGPIO_ID=VDDC_REGULATOR_VRHOT_GPIO_PINID in GPIO_LUTable, VRHot feature is enable
 #define VDDC_VRHOT_GPIO_PINID               61
<span class="p_chunk">@@ -5105,7 +5105,7 @@</span> <span class="p_context"> typedef struct _ATOM_VOLTAGE_OBJECT_HEADER_V3{</span>
 
 // ATOM_VOLTAGE_OBJECT_HEADER_V3.ucVoltageMode
 #define VOLTAGE_OBJ_GPIO_LUT                 0        //VOLTAGE and GPIO Lookup table -&gt;ATOM_GPIO_VOLTAGE_OBJECT_V3
<span class="p_del">-#define VOLTAGE_OBJ_VR_I2C_INIT_SEQ          3        //VOLTAGE REGULATOR INIT sequece through I2C -&gt; ATOM_I2C_VOLTAGE_OBJECT_V3</span>
<span class="p_add">+#define VOLTAGE_OBJ_VR_I2C_INIT_SEQ          3        //VOLTAGE REGULATOR INIT sequence through I2C -&gt; ATOM_I2C_VOLTAGE_OBJECT_V3</span>
 #define VOLTAGE_OBJ_PHASE_LUT                4        //Set Vregulator Phase lookup table -&gt;ATOM_GPIO_VOLTAGE_OBJECT_V3
 #define VOLTAGE_OBJ_SVID2                    7        //Indicate voltage control by SVID2 -&gt;ATOM_SVID2_VOLTAGE_OBJECT_V3
 #define VOLTAGE_OBJ_EVV                      8
<span class="p_chunk">@@ -5147,7 +5147,7 @@</span> <span class="p_context"> typedef struct  _ATOM_GPIO_VOLTAGE_OBJECT_V3</span>
 {
    ATOM_VOLTAGE_OBJECT_HEADER_V3 sHeader;    // voltage mode = VOLTAGE_OBJ_GPIO_LUT or VOLTAGE_OBJ_PHASE_LUT
    UCHAR  ucVoltageGpioCntlId;               // default is 0 which indicate control through CG VID mode
<span class="p_del">-   UCHAR  ucGpioEntryNum;                    // indiate the entry numbers of Votlage/Gpio value Look up table</span>
<span class="p_add">+   UCHAR  ucGpioEntryNum;                    // indicate the entry numbers of Votlage/Gpio value Look up table</span>
    UCHAR  ucPhaseDelay;                      // phase delay in unit of micro second
    UCHAR  ucReserved;
    ULONG  ulGpioMaskVal;                     // GPIO Mask value
<span class="p_chunk">@@ -5843,7 +5843,7 @@</span> <span class="p_context"> ucUMAChannelNumber:                 System memory channel numbers.</span>
 ulCSR_M3_ARB_CNTL_DEFAULT[10]:    Arrays with values for CSR M3 arbiter for default
 ulCSR_M3_ARB_CNTL_UVD[10]:        Arrays with values for CSR M3 arbiter for UVD playback.
 ulCSR_M3_ARB_CNTL_FS3D[10]:       Arrays with values for CSR M3 arbiter for Full Screen 3D applications.
<span class="p_del">-sAvail_SCLK[5]:                   Arrays to provide availabe list of SLCK and corresponding voltage, order from low to high</span>
<span class="p_add">+sAvail_SCLK[5]:                   Arrays to provide available list of SLCK and corresponding voltage, order from low to high</span>
 ulGMCRestoreResetTime:            GMC power restore and GMC reset time to calculate data reconnection latency. Unit in ns.
 ulMinimumNClk:                    Minimum NCLK speed among all NB-Pstates to calcualte data reconnection latency. Unit in 10kHz.
 ulIdleNClk:                       NCLK speed while memory runs in self-refresh state. Unit in 10kHz.
<span class="p_chunk">@@ -6074,7 +6074,7 @@</span> <span class="p_context"> ucUMAChannelNumber:                 System memory channel numbers.</span>
 ulCSR_M3_ARB_CNTL_DEFAULT[10]:    Arrays with values for CSR M3 arbiter for default
 ulCSR_M3_ARB_CNTL_UVD[10]:        Arrays with values for CSR M3 arbiter for UVD playback.
 ulCSR_M3_ARB_CNTL_FS3D[10]:       Arrays with values for CSR M3 arbiter for Full Screen 3D applications.
<span class="p_del">-sAvail_SCLK[5]:                   Arrays to provide availabe list of SLCK and corresponding voltage, order from low to high</span>
<span class="p_add">+sAvail_SCLK[5]:                   Arrays to provide available list of SLCK and corresponding voltage, order from low to high</span>
 ulGMCRestoreResetTime:            GMC power restore and GMC reset time to calculate data reconnection latency. Unit in ns.
 ulMinimumNClk:                    Minimum NCLK speed among all NB-Pstates to calcualte data reconnection latency. Unit in 10kHz.
 ulIdleNClk:                       NCLK speed while memory runs in self-refresh state. Unit in 10kHz.
<span class="p_chunk">@@ -6274,7 +6274,7 @@</span> <span class="p_context"> ucUMAChannelNumber:                 System memory channel numbers.</span>
 
 strVBIOSMsg[40]:                  VBIOS boot up customized message string
 
<span class="p_del">-sAvail_SCLK[5]:                   Arrays to provide availabe list of SLCK and corresponding voltage, order from low to high</span>
<span class="p_add">+sAvail_SCLK[5]:                   Arrays to provide available list of SLCK and corresponding voltage, order from low to high</span>
 
 ulGMCRestoreResetTime:            GMC power restore and GMC reset time to calculate data reconnection latency. Unit in ns.
 ulIdleNClk:                       NCLK speed while memory runs in self-refresh state, used to calculate self-refresh latency. Unit in 10kHz.
<span class="p_chunk">@@ -6743,7 +6743,7 @@</span> <span class="p_context"> typedef struct _ATOM_ASIC_INTERNAL_SS_INFO_V3</span>
 #define ATOM_S0_SYSTEM_POWER_STATE_VALUE_LITEAC 3
 #define ATOM_S0_SYSTEM_POWER_STATE_VALUE_LIT2AC 4
 
<span class="p_del">-//Byte aligned defintion for BIOS usage</span>
<span class="p_add">+//Byte aligned definition for BIOS usage</span>
 #define ATOM_S0_CRT1_MONOb0             0x01
 #define ATOM_S0_CRT1_COLORb0            0x02
 #define ATOM_S0_CRT1_MASKb0             (ATOM_S0_CRT1_MONOb0+ATOM_S0_CRT1_COLORb0)
<span class="p_chunk">@@ -6809,7 +6809,7 @@</span> <span class="p_context"> typedef struct _ATOM_ASIC_INTERNAL_SS_INFO_V3</span>
 #define ATOM_S2_DISPLAY_ROTATION_ANGLE_MASK   0xC0000000L
 
 
<span class="p_del">-//Byte aligned defintion for BIOS usage</span>
<span class="p_add">+//Byte aligned definition for BIOS usage</span>
 #define ATOM_S2_TV1_STANDARD_MASKb0     0x0F
 #define ATOM_S2_CURRENT_BL_LEVEL_MASKb1 0xFF
 #define ATOM_S2_DEVICE_DPMS_STATEb2     0x01
<span class="p_chunk">@@ -6861,7 +6861,7 @@</span> <span class="p_context"> typedef struct _ATOM_ASIC_INTERNAL_SS_INFO_V3</span>
 
 
 
<span class="p_del">-//Byte aligned defintion for BIOS usage</span>
<span class="p_add">+//Byte aligned definition for BIOS usage</span>
 #define ATOM_S3_CRT1_ACTIVEb0           0x01
 #define ATOM_S3_LCD1_ACTIVEb0           0x02
 #define ATOM_S3_TV1_ACTIVEb0            0x04
<span class="p_chunk">@@ -6900,7 +6900,7 @@</span> <span class="p_context"> typedef struct _ATOM_ASIC_INTERNAL_SS_INFO_V3</span>
 #define ATOM_S4_LCD1_REFRESH_MASK       0x0000FF00L
 #define ATOM_S4_LCD1_REFRESH_SHIFT      8
 
<span class="p_del">-//Byte aligned defintion for BIOS usage</span>
<span class="p_add">+//Byte aligned definition for BIOS usage</span>
 #define ATOM_S4_LCD1_PANEL_ID_MASKb0    0x0FF
 #define ATOM_S4_LCD1_REFRESH_MASKb1     ATOM_S4_LCD1_PANEL_ID_MASKb0
 #define ATOM_S4_VRAM_INFO_MASKb2        ATOM_S4_LCD1_PANEL_ID_MASKb0
<span class="p_chunk">@@ -6979,7 +6979,7 @@</span> <span class="p_context"> typedef struct _ATOM_ASIC_INTERNAL_SS_INFO_V3</span>
 #define ATOM_S6_VRI_BRIGHTNESS_CHANGE       0x40000000L
 #define ATOM_S6_CONFIG_DISPLAY_CHANGE_MASK  0x80000000L
 
<span class="p_del">-//Byte aligned defintion for BIOS usage</span>
<span class="p_add">+//Byte aligned definition for BIOS usage</span>
 #define ATOM_S6_DEVICE_CHANGEb0         0x01
 #define ATOM_S6_SCALER_CHANGEb0         0x02
 #define ATOM_S6_LID_CHANGEb0            0x04
<span class="p_chunk">@@ -9064,7 +9064,7 @@</span> <span class="p_context"> typedef struct  _ATOM_POWERPLAY_INFO_V3</span>
 /**************************************************************************/
 
 
<span class="p_del">-// Following definitions are for compatiblity issue in different SW components.</span>
<span class="p_add">+// Following definitions are for compatibility issue in different SW components.</span>
 #define ATOM_MASTER_DATA_TABLE_REVISION   0x01
 #define Object_Info                       Object_Header
 #define AdjustARB_SEQ                     MC_InitParameter
<span class="p_chunk">@@ -9178,7 +9178,7 @@</span> <span class="p_context"> typedef struct  _ATOM_POWERPLAY_INFO_V3</span>
 
 /*********************************************************************************/
 
<span class="p_del">-#pragma pack() // BIOS data must use byte aligment</span>
<span class="p_add">+#pragma pack() // BIOS data must use byte alignment</span>
 
 #pragma pack(1)
 
<span class="p_chunk">@@ -9209,7 +9209,7 @@</span> <span class="p_context"> typedef struct _ATOM_SERVICE_INFO</span>
 
 
 
<span class="p_del">-#pragma pack() // BIOS data must use byte aligment</span>
<span class="p_add">+#pragma pack() // BIOS data must use byte alignment</span>
 
 //
 // AMD ACPI Table
<span class="p_header">diff --git a/drivers/gpu/drm/amd/powerplay/hwmgr/tonga_hwmgr.c b/drivers/gpu/drm/amd/powerplay/hwmgr/tonga_hwmgr.c</span>
<span class="p_header">index c7dc111..aed0c95 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/powerplay/hwmgr/tonga_hwmgr.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/powerplay/hwmgr/tonga_hwmgr.c</span>
<span class="p_chunk">@@ -1146,7 +1146,7 @@</span> <span class="p_context"> int tonga_construct_voltage_tables(struct pp_hwmgr *hwmgr)</span>
 		result = tonga_get_svi2_vdd_ci_voltage_table(hwmgr,
 					pptable_info-&gt;vdd_dep_on_mclk);
 		PP_ASSERT_WITH_CODE((0 == result),
<span class="p_del">-			&quot;Failed to retrieve SVI2 VDDCI table from dependancy table.&quot;, return result;);</span>
<span class="p_add">+			&quot;Failed to retrieve SVI2 VDDCI table from dependency table.&quot;, return result;);</span>
 	}
 
 	if (TONGA_VOLTAGE_CONTROL_BY_SVID2 == data-&gt;vdd_gfx_control) {
<span class="p_chunk">@@ -1442,7 +1442,7 @@</span> <span class="p_context"> static int tonga_populate_vr_config(struct pp_hwmgr *hwmgr,</span>
 			config = VR_SVI2_PLANE_2;
 			table-&gt;VRConfig |= config;
 		} else {
<span class="p_del">-			printk(KERN_ERR &quot;[ powerplay ] VDDC and VDDGFX should be both on SVI2 control in splitted mode! \n&quot;);</span>
<span class="p_add">+			printk(KERN_ERR &quot;[ powerplay ] VDDC and VDDGFX should be both on SVI2 control in split mode! \n&quot;);</span>
 		}
 	} else {
 		/* Merged mode  */
<span class="p_chunk">@@ -2786,7 +2786,7 @@</span> <span class="p_context"> static int tonga_setup_default_pcie_tables(struct pp_hwmgr *hwmgr)</span>
 }
 
 /*
<span class="p_del">- * This function is to initalize all DPM state tables for SMU7 based on the dependency table.</span>
<span class="p_add">+ * This function is to initialize all DPM state tables for SMU7 based on the dependency table.</span>
  * Dynamic state patching function will then trim these state tables to the allowed range based
  * on the power policy or external client requests, such as UVD request, etc.
  */
<span class="p_header">diff --git a/drivers/gpu/drm/amd/powerplay/inc/hardwaremanager.h b/drivers/gpu/drm/amd/powerplay/inc/hardwaremanager.h</span>
<span class="p_header">index 962cb53..9aa8ef4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/powerplay/inc/hardwaremanager.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/powerplay/inc/hardwaremanager.h</span>
<span class="p_chunk">@@ -89,7 +89,7 @@</span> <span class="p_context"> enum phm_platform_caps {</span>
 	PHM_PlatformCaps_EnableSideportControl,                 /* indicates Sideport can be controlled */
 	PHM_PlatformCaps_VideoPlaybackEEUNotification,          /* indicates EEU notification of video start/stop is required */
 	PHM_PlatformCaps_TurnOffPll_ASPML1,                     /* PCIE Turn Off PLL in ASPM L1 */
<span class="p_del">-	PHM_PlatformCaps_EnableHTLinkControl,                   /* indicates HT Link can be controlled by ACPI or CLMC overrided/automated mode. */</span>
<span class="p_add">+	PHM_PlatformCaps_EnableHTLinkControl,                   /* indicates HT Link can be controlled by ACPI or CLMC overridden/automated mode. */</span>
 	PHM_PlatformCaps_PerformanceStateOnly,                  /* indicates only performance power state to be used on current system. */
 	PHM_PlatformCaps_ExclusiveModeAlwaysHigh,               /* In Exclusive (3D) mode always stay in High state. */
 	PHM_PlatformCaps_DisableMGClockGating,                  /* to disable Medium Grain Clock Gating or not */
<span class="p_header">diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/fiji_smumgr.c b/drivers/gpu/drm/amd/powerplay/smumgr/fiji_smumgr.c</span>
<span class="p_header">index 8e52a2e..3449edb 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/powerplay/smumgr/fiji_smumgr.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/powerplay/smumgr/fiji_smumgr.c</span>
<span class="p_chunk">@@ -141,7 +141,7 @@</span> <span class="p_context"> int fiji_copy_bytes_to_smc(struct pp_smumgr *smumgr,</span>
 	addr = smcStartAddress;
 
 	while (byteCount &gt;= 4) {
<span class="p_del">-		/* Bytes are written into the SMC addres space with the MSB first. */</span>
<span class="p_add">+		/* Bytes are written into the SMC address space with the MSB first. */</span>
 		data = src[0] * 0x1000000 + src[1] * 0x10000 + src[2] * 0x100 + src[3];
 
 		result = fiji_set_smc_sram_address(smumgr, addr, limit);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/polaris10_smumgr.c b/drivers/gpu/drm/amd/powerplay/smumgr/polaris10_smumgr.c</span>
<span class="p_header">index 5dba7c5..1a79a9e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/powerplay/smumgr/polaris10_smumgr.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/powerplay/smumgr/polaris10_smumgr.c</span>
<span class="p_chunk">@@ -147,7 +147,7 @@</span> <span class="p_context"> int polaris10_copy_bytes_to_smc(struct pp_smumgr *smumgr, uint32_t smc_start_add</span>
 	addr = smc_start_address;
 
 	while (byte_count &gt;= 4) {
<span class="p_del">-	/* Bytes are written into the SMC addres space with the MSB first. */</span>
<span class="p_add">+	/* Bytes are written into the SMC address space with the MSB first. */</span>
 		data = src[0] * 0x1000000 + src[1] * 0x10000 + src[2] * 0x100 + src[3];
 
 		result = polaris10_set_smc_sram_address(smumgr, addr, limit);
<span class="p_chunk">@@ -177,7 +177,7 @@</span> <span class="p_context"> int polaris10_copy_bytes_to_smc(struct pp_smumgr *smumgr, uint32_t smc_start_add</span>
 		extra_shift = 8 * (4 - byte_count);
 
 		while (byte_count &gt; 0) {
<span class="p_del">-			/* Bytes are written into the SMC addres space with the MSB first. */</span>
<span class="p_add">+			/* Bytes are written into the SMC address space with the MSB first. */</span>
 			data = (0x100 * data) + *src++;
 			byte_count--;
 		}
<span class="p_chunk">@@ -728,7 +728,7 @@</span> <span class="p_context"> int polaris10_setup_graphics_level_structure(struct pp_smumgr *smumgr)</span>
 				&quot;[AVFS][Polaris10_SetupGfxLvlStruct] Copying of MCLK DPM table failed!&quot;,
 			return -1);
 
<span class="p_del">-	/* MVDD Boot value - neccessary for getting rid of the hang that occurs during Mclk DPM enablement */</span>
<span class="p_add">+	/* MVDD Boot value - necessary for getting rid of the hang that occurs during Mclk DPM enablement */</span>
 
 	graphics_level_address = dpm_table_start + offsetof(SMU74_Discrete_DpmTable, BootMVdd);
 
<span class="p_header">diff --git a/drivers/gpu/drm/drm_drv.c b/drivers/gpu/drm/drm_drv.c</span>
<span class="p_header">index be27ed3..b0afa60 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_drv.c</span>
<span class="p_chunk">@@ -298,7 +298,7 @@</span> <span class="p_context"> void drm_minor_release(struct drm_minor *minor)</span>
  * is allocated with drm_dev_alloc(), usually from bus-specific -&gt;probe()
  * callbacks implemented by the driver. The driver then needs to initialize all
  * the various subsystems for the drm device like memory management, vblank
<span class="p_del">- * handling, modesetting support and intial output configuration plus obviously</span>
<span class="p_add">+ * handling, modesetting support and initial output configuration plus obviously</span>
  * initialize all the corresponding hardware bits. Finally when everything is up
  * and running and ready for userspace the device instance can be published
  * using drm_dev_register().
<span class="p_header">diff --git a/drivers/gpu/drm/drm_ioctl.c b/drivers/gpu/drm/drm_ioctl.c</span>
<span class="p_header">index 33af4a5..b2a3e95 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_ioctl.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_ioctl.c</span>
<span class="p_chunk">@@ -364,7 +364,7 @@</span> <span class="p_context"> done:</span>
 }
 
 /**
<span class="p_del">- * drm_noop - DRM no-op ioctl implemntation</span>
<span class="p_add">+ * drm_noop - DRM no-op ioctl implementation</span>
  * @dev: DRM device for the ioctl
  * @data: data pointer for the ioctl
  * @file_priv: DRM file for the ioctl call
<span class="p_chunk">@@ -384,7 +384,7 @@</span> <span class="p_context"> int drm_noop(struct drm_device *dev, void *data,</span>
 EXPORT_SYMBOL(drm_noop);
 
 /**
<span class="p_del">- * drm_invalid_op - DRM invalid ioctl implemntation</span>
<span class="p_add">+ * drm_invalid_op - DRM invalid ioctl implementation</span>
  * @dev: DRM device for the ioctl
  * @data: data pointer for the ioctl
  * @file_priv: DRM file for the ioctl call
<span class="p_header">diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c</span>
<span class="p_header">index a0df377..0c27320 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_probe_helper.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_probe_helper.c</span>
<span class="p_chunk">@@ -190,8 +190,8 @@</span> <span class="p_context"> EXPORT_SYMBOL(drm_kms_helper_poll_enable_locked);</span>
  *    - drm_mode_validate_basic() performs basic sanity checks
  *    - drm_mode_validate_size() filters out modes larger than @maxX and @maxY
  *      (if specified)
<span class="p_del">- *    - drm_mode_validate_flag() checks the modes againt basic connector</span>
<span class="p_del">- *      capabilites (interlace_allowed,doublescan_allowed,stereo_allowed)</span>
<span class="p_add">+ *    - drm_mode_validate_flag() checks the modes against basic connector</span>
<span class="p_add">+ *      capabilities (interlace_allowed,doublescan_allowed,stereo_allowed)</span>
  *    - the optional connector -&gt;mode_valid() helper can perform driver and/or
  *      hardware specific checks
  *
<span class="p_chunk">@@ -484,7 +484,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(drm_kms_helper_poll_enable);</span>
  * drm_kms_helper_poll_init - initialize and enable output polling
  * @dev: drm_device
  *
<span class="p_del">- * This function intializes and then also enables output polling support for</span>
<span class="p_add">+ * This function initializes and then also enables output polling support for</span>
  * @dev. Drivers which do not have reliable hotplug support in hardware can use
  * this helper infrastructure to regularly poll such connectors for changes in
  * their connection state.
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem_render_state.c b/drivers/gpu/drm/i915/i915_gem_render_state.c</span>
<span class="p_header">index f75bbd6..46742d1 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem_render_state.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem_render_state.c</span>
<span class="p_chunk">@@ -80,7 +80,7 @@</span> <span class="p_context"> free_gem:</span>
  * this is sufficient as the null state generator makes the final batch
  * with two passes to build command and state separately. At this point
  * the size of both are known and it compacts them by relocating the state
<span class="p_del">- * right after the commands taking care of aligment so we should sufficient</span>
<span class="p_add">+ * right after the commands taking care of alignment so we should sufficient</span>
  * space below them for adding new commands.
  */
 #define OUT_BATCH(batch, i, val)				\
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_pci.c b/drivers/gpu/drm/i915/i915_pci.c</span>
<span class="p_header">index 949c016..7c7c71f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_pci.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_pci.c</span>
<span class="p_chunk">@@ -465,8 +465,8 @@</span> <span class="p_context"> static int __init i915_init(void)</span>
 	bool use_kms = true;
 
 	/*
<span class="p_del">-	 * Enable KMS by default, unless explicitly overriden by</span>
<span class="p_del">-	 * either the i915.modeset prarameter or by the</span>
<span class="p_add">+	 * Enable KMS by default, unless explicitly overridden by</span>
<span class="p_add">+	 * either the i915.modeset parameter or by the</span>
 	 * vga_text_mode_force boot option.
 	 */
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index 175595f..eeb9688 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -5862,7 +5862,7 @@</span> <span class="p_context"> static void skl_sanitize_cdclk(struct drm_i915_private *dev_priv)</span>
 	uint32_t cdctl, expected;
 
 	/*
<span class="p_del">-	 * check if the pre-os intialized the display</span>
<span class="p_add">+	 * check if the pre-os initialized the display</span>
 	 * There is SWF18 scratchpad register defined which is set by the
 	 * pre-os which can be used by the OS drivers to check the status
 	 */
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_lrc.c b/drivers/gpu/drm/i915/intel_lrc.c</span>
<span class="p_header">index 414ddda..4a60e86 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_lrc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_lrc.c</span>
<span class="p_chunk">@@ -1968,7 +1968,7 @@</span> <span class="p_context"> void intel_logical_ring_cleanup(struct intel_engine_cs *engine)</span>
 static void
 logical_ring_default_vfuncs(struct intel_engine_cs *engine)
 {
<span class="p_del">-	/* Default vfuncs which can be overriden by each engine. */</span>
<span class="p_add">+	/* Default vfuncs which can be overridden by each engine. */</span>
 	engine-&gt;init_hw = gen8_init_common_ring;
 	engine-&gt;emit_request = gen8_emit_request;
 	engine-&gt;emit_flush = gen8_emit_flush;
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nouveau_bios.c b/drivers/gpu/drm/nouveau/nouveau_bios.c</span>
<span class="p_header">index a1570b1..79308b9 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nouveau_bios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nouveau_bios.c</span>
<span class="p_chunk">@@ -324,7 +324,7 @@</span> <span class="p_context"> get_fp_strap(struct drm_device *dev, struct nvbios *bios)</span>
 	/*
 	 * The fp strap is normally dictated by the &quot;User Strap&quot; in
 	 * PEXTDEV_BOOT_0[20:16], but on BMP cards when bit 2 of the
<span class="p_del">-	 * Internal_Flags struct at 0x48 is set, the user strap gets overriden</span>
<span class="p_add">+	 * Internal_Flags struct at 0x48 is set, the user strap gets overridden</span>
 	 * by the PCI subsystem ID during POST, but not before the previous user
 	 * strap has been committed to CR58 for CR57=0xf on head A, which may be
 	 * read and used instead
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/ctxnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/ctxnv50.c</span>
<span class="p_header">index 1e13278..5c0685a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/ctxnv50.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/ctxnv50.c</span>
<span class="p_chunk">@@ -138,7 +138,7 @@</span> <span class="p_context"></span>
  * The ctxprog is written in its own kind of microcode, with very small and
  * crappy set of available commands. You upload it to a small [512 insns]
  * area of memory on PGRAPH, and it&#39;ll be run when PFIFO wants PGRAPH to
<span class="p_del">- * switch channel. or when the driver explicitely requests it. Stuff visible</span>
<span class="p_add">+ * switch channel. or when the driver explicitly requests it. Stuff visible</span>
  * to ctxprog consists of: PGRAPH MMIO registers, PGRAPH context strands,
  * the per-channel context save area in VRAM [known as ctxvals or grctx],
  * 4 flags registers, a scratch register, two grctx pointers, plus many
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios.h b/drivers/gpu/drm/radeon/atombios.h</span>
<span class="p_header">index ab89eed..1a32194 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios.h</span>
<span class="p_chunk">@@ -181,7 +181,7 @@</span> <span class="p_context"></span>
 #define HW_ASSISTED_I2C_STATUS_FAILURE          2
 #define HW_ASSISTED_I2C_STATUS_SUCCESS          1
 
<span class="p_del">-#pragma pack(1)                                       /* BIOS data must use byte aligment */</span>
<span class="p_add">+#pragma pack(1)                                       /* BIOS data must use byte alignment */</span>
 
 /*  Define offset to location of ROM header. */
 
<span class="p_chunk">@@ -1711,9 +1711,9 @@</span> <span class="p_context"> typedef struct _PIXEL_CLOCK_PARAMETERS_V6</span>
 #define PIXEL_CLOCK_V6_MISC_HDMI_BPP_MASK           0x0c
 #define PIXEL_CLOCK_V6_MISC_HDMI_24BPP              0x00
 #define PIXEL_CLOCK_V6_MISC_HDMI_36BPP              0x04
<span class="p_del">-#define PIXEL_CLOCK_V6_MISC_HDMI_36BPP_V6           0x08    //for V6, the correct defintion for 36bpp should be 2 for 36bpp(2:1)</span>
<span class="p_add">+#define PIXEL_CLOCK_V6_MISC_HDMI_36BPP_V6           0x08    //for V6, the correct definition for 36bpp should be 2 for 36bpp(2:1)</span>
 #define PIXEL_CLOCK_V6_MISC_HDMI_30BPP              0x08
<span class="p_del">-#define PIXEL_CLOCK_V6_MISC_HDMI_30BPP_V6           0x04    //for V6, the correct defintion for 30bpp should be 1 for 36bpp(5:4)</span>
<span class="p_add">+#define PIXEL_CLOCK_V6_MISC_HDMI_30BPP_V6           0x04    //for V6, the correct definition for 30bpp should be 1 for 36bpp(5:4)</span>
 #define PIXEL_CLOCK_V6_MISC_HDMI_48BPP              0x0c
 #define PIXEL_CLOCK_V6_MISC_REF_DIV_SRC             0x10
 #define PIXEL_CLOCK_V6_MISC_GEN_DPREFCLK            0x40
<span class="p_chunk">@@ -1827,7 +1827,7 @@</span> <span class="p_context"> typedef struct _GET_ENGINE_CLOCK_PARAMETERS</span>
 // Following Structures and constant may be obsolete
 /****************************************************************************/	
 //Maxium 8 bytes,the data read in will be placed in the parameter space.
<span class="p_del">-//Read operaion successeful when the paramter space is non-zero, otherwise read operation failed</span>
<span class="p_add">+//Read operaion successeful when the parameter space is non-zero, otherwise read operation failed</span>
 typedef struct _READ_EDID_FROM_HW_I2C_DATA_PARAMETERS
 {
   USHORT    usPrescale;         //Ratio between Engine clock and I2C clock
<span class="p_chunk">@@ -2036,7 +2036,7 @@</span> <span class="p_context"> typedef struct _LVDS_ENCODER_CONTROL_PARAMETERS</span>
 typedef struct _LVDS_ENCODER_CONTROL_PARAMETERS_V2
 {
   USHORT usPixelClock;  // in 10KHz; for bios convenient
<span class="p_del">-  UCHAR  ucMisc;        // see PANEL_ENCODER_MISC_xx defintions below</span>
<span class="p_add">+  UCHAR  ucMisc;        // see PANEL_ENCODER_MISC_xx definitions below</span>
   UCHAR  ucAction;      // 0: turn off encoder
                         // 1: setup and turn on encoder
   UCHAR  ucTruncate;    // bit0=0: Disable truncate
<span class="p_chunk">@@ -2244,10 +2244,10 @@</span> <span class="p_context"> typedef struct	_SET_VOLTAGE_PARAMETERS_V1_3</span>
 #define ATOM_INIT_VOLTAGE_REGULATOR          3        //Init Regulator
 #define ATOM_SET_VOLTAGE_PHASE               4        //Set Vregulator Phase, only for SVID/PVID regulator
 #define ATOM_GET_MAX_VOLTAGE                 6        //Get Max Voltage, not used from SetVoltageTable v1.3
<span class="p_del">-#define ATOM_GET_VOLTAGE_LEVEL               6        //Get Voltage level from vitual voltage ID, not used for SetVoltage v1.4</span>
<span class="p_add">+#define ATOM_GET_VOLTAGE_LEVEL               6        //Get Voltage level from virtual voltage ID, not used for SetVoltage v1.4</span>
 #define ATOM_GET_LEAKAGE_ID                  8        //Get Leakage Voltage Id ( starting from SMU7x IP ), SetVoltage v1.4 
 
<span class="p_del">-// define vitual voltage id in usVoltageLevel</span>
<span class="p_add">+// define virtual voltage id in usVoltageLevel</span>
 #define ATOM_VIRTUAL_VOLTAGE_ID0             0xff01
 #define ATOM_VIRTUAL_VOLTAGE_ID1             0xff02
 #define ATOM_VIRTUAL_VOLTAGE_ID2             0xff03
<span class="p_chunk">@@ -3599,7 +3599,7 @@</span> <span class="p_context"> typedef struct  _ATOM_LCD_RTS_RECORD</span>
   UCHAR     ucRTSValue;
 }ATOM_LCD_RTS_RECORD;
 
<span class="p_del">-//!! If the record below exits, it shoud always be the first record for easy use in command table!!! </span>
<span class="p_add">+//!! If the record below exits, it should always be the first record for easy use in command table!!!</span>
 // The record below is only used when LVDS_Info is present. From ATOM_LVDS_INFO_V12, use ucLCDPanel_SpecialHandlingCap instead.
 typedef struct  _ATOM_LCD_MODE_CONTROL_CAP
 {
<span class="p_chunk">@@ -3883,7 +3883,7 @@</span> <span class="p_context"> typedef struct _ATOM_GPIO_PIN_ASSIGNMENT</span>
 }ATOM_GPIO_PIN_ASSIGNMENT;
 
 //ucGPIO_ID pre-define id for multiple usage
<span class="p_del">-//from SMU7.x, if ucGPIO_ID=PP_AC_DC_SWITCH_GPIO_PINID in GPIO_LUTTable, AC/DC swithing feature is enable</span>
<span class="p_add">+//from SMU7.x, if ucGPIO_ID=PP_AC_DC_SWITCH_GPIO_PINID in GPIO_LUTTable, AC/DC switching feature is enable</span>
 #define PP_AC_DC_SWITCH_GPIO_PINID          60
 //from SMU7.x, if ucGPIO_ID=VDDC_REGULATOR_VRHOT_GPIO_PINID in GPIO_LUTable, VRHot feature is enable
 #define VDDC_VRHOT_GPIO_PINID               61
<span class="p_chunk">@@ -4571,7 +4571,7 @@</span> <span class="p_context"> typedef struct _ATOM_VOLTAGE_OBJECT_HEADER_V3{</span>
 
 // ATOM_VOLTAGE_OBJECT_HEADER_V3.ucVoltageMode
 #define VOLTAGE_OBJ_GPIO_LUT                 0        //VOLTAGE and GPIO Lookup table -&gt;ATOM_GPIO_VOLTAGE_OBJECT_V3
<span class="p_del">-#define VOLTAGE_OBJ_VR_I2C_INIT_SEQ          3        //VOLTAGE REGULATOR INIT sequece through I2C -&gt; ATOM_I2C_VOLTAGE_OBJECT_V3</span>
<span class="p_add">+#define VOLTAGE_OBJ_VR_I2C_INIT_SEQ          3        //VOLTAGE REGULATOR INIT sequence through I2C -&gt; ATOM_I2C_VOLTAGE_OBJECT_V3</span>
 #define VOLTAGE_OBJ_PHASE_LUT                4        //Set Vregulator Phase lookup table -&gt;ATOM_GPIO_VOLTAGE_OBJECT_V3
 #define VOLTAGE_OBJ_SVID2                    7        //Indicate voltage control by SVID2 -&gt;ATOM_SVID2_VOLTAGE_OBJECT_V3
 #define VOLTAGE_OBJ_EVV                      8 
<span class="p_chunk">@@ -4611,7 +4611,7 @@</span> <span class="p_context"> typedef struct  _ATOM_GPIO_VOLTAGE_OBJECT_V3</span>
 {
    ATOM_VOLTAGE_OBJECT_HEADER_V3 sHeader;   // voltage mode = VOLTAGE_OBJ_GPIO_LUT or VOLTAGE_OBJ_PHASE_LUT
    UCHAR    ucVoltageGpioCntlId;         // default is 0 which indicate control through CG VID mode 
<span class="p_del">-   UCHAR    ucGpioEntryNum;              // indiate the entry numbers of Votlage/Gpio value Look up table</span>
<span class="p_add">+   UCHAR    ucGpioEntryNum;              // indicate the entry numbers of Votlage/Gpio value Look up table</span>
    UCHAR    ucPhaseDelay;                // phase delay in unit of micro second
    UCHAR    ucReserved;   
    ULONG    ulGpioMaskVal;               // GPIO Mask value
<span class="p_chunk">@@ -4926,7 +4926,7 @@</span> <span class="p_context"> ucUMAChannelNumber:      	        System memory channel numbers.</span>
 ulCSR_M3_ARB_CNTL_DEFAULT[10]:    Arrays with values for CSR M3 arbiter for default
 ulCSR_M3_ARB_CNTL_UVD[10]:        Arrays with values for CSR M3 arbiter for UVD playback.
 ulCSR_M3_ARB_CNTL_FS3D[10]:       Arrays with values for CSR M3 arbiter for Full Screen 3D applications.
<span class="p_del">-sAvail_SCLK[5]:                   Arrays to provide availabe list of SLCK and corresponding voltage, order from low to high  </span>
<span class="p_add">+sAvail_SCLK[5]:                   Arrays to provide available list of SLCK and corresponding voltage, order from low to high</span>
 ulGMCRestoreResetTime:            GMC power restore and GMC reset time to calculate data reconnection latency. Unit in ns. 
 ulMinimumNClk:                    Minimum NCLK speed among all NB-Pstates to calcualte data reconnection latency. Unit in 10kHz. 
 ulIdleNClk:                       NCLK speed while memory runs in self-refresh state. Unit in 10kHz.
<span class="p_chunk">@@ -5152,7 +5152,7 @@</span> <span class="p_context"> ucUMAChannelNumber:      	        System memory channel numbers.</span>
 ulCSR_M3_ARB_CNTL_DEFAULT[10]:    Arrays with values for CSR M3 arbiter for default
 ulCSR_M3_ARB_CNTL_UVD[10]:        Arrays with values for CSR M3 arbiter for UVD playback.
 ulCSR_M3_ARB_CNTL_FS3D[10]:       Arrays with values for CSR M3 arbiter for Full Screen 3D applications.
<span class="p_del">-sAvail_SCLK[5]:                   Arrays to provide availabe list of SLCK and corresponding voltage, order from low to high  </span>
<span class="p_add">+sAvail_SCLK[5]:                   Arrays to provide available list of SLCK and corresponding voltage, order from low to high</span>
 ulGMCRestoreResetTime:            GMC power restore and GMC reset time to calculate data reconnection latency. Unit in ns. 
 ulMinimumNClk:                    Minimum NCLK speed among all NB-Pstates to calcualte data reconnection latency. Unit in 10kHz. 
 ulIdleNClk:                       NCLK speed while memory runs in self-refresh state. Unit in 10kHz.
<span class="p_chunk">@@ -5351,7 +5351,7 @@</span> <span class="p_context"> ucUMAChannelNumber:      	        System memory channel numbers.</span>
 
 strVBIOSMsg[40]:                  VBIOS boot up customized message string 
 
<span class="p_del">-sAvail_SCLK[5]:                   Arrays to provide availabe list of SLCK and corresponding voltage, order from low to high  </span>
<span class="p_add">+sAvail_SCLK[5]:                   Arrays to provide available list of SLCK and corresponding voltage, order from low to high</span>
 
 ulGMCRestoreResetTime:            GMC power restore and GMC reset time to calculate data reconnection latency. Unit in ns. 
 ulIdleNClk:                       NCLK speed while memory runs in self-refresh state, used to calculate self-refresh latency. Unit in 10kHz.
<span class="p_chunk">@@ -7909,7 +7909,7 @@</span> <span class="p_context"> typedef struct  _ATOM_POWERPLAY_INFO_V3</span>
 
 /*********************************************************************************/
 
<span class="p_del">-#pragma pack() // BIOS data must use byte aligment</span>
<span class="p_add">+#pragma pack() /* BIOS data must use byte alignment */</span>
 
 //
 // AMD ACPI Table
<span class="p_header">diff --git a/drivers/hid/hid-appleir.c b/drivers/hid/hid-appleir.c</span>
<span class="p_header">index 07cbc70..53eb434 100644</span>
<span class="p_header">--- a/drivers/hid/hid-appleir.c</span>
<span class="p_header">+++ b/drivers/hid/hid-appleir.c</span>
<span class="p_chunk">@@ -125,7 +125,7 @@</span> <span class="p_context"> struct appleir {</span>
 static int get_key(int data)
 {
 	/*
<span class="p_del">-	 * The key is coded accross bits 2..9:</span>
<span class="p_add">+	 * The key is coded across bits 2..9:</span>
 	 *
 	 * 0x00 or 0x01 (        )	key:  0		-&gt; KEY_RESERVED
 	 * 0x02 or 0x03 (  menu  )	key:  1		-&gt; KEY_MENU
<span class="p_header">diff --git a/drivers/hid/hid-logitech-hidpp.c b/drivers/hid/hid-logitech-hidpp.c</span>
<span class="p_header">index 2e2515a..e621c56 100644</span>
<span class="p_header">--- a/drivers/hid/hid-logitech-hidpp.c</span>
<span class="p_header">+++ b/drivers/hid/hid-logitech-hidpp.c</span>
<span class="p_chunk">@@ -75,7 +75,7 @@</span> <span class="p_context"> MODULE_PARM_DESC(disable_tap_to_click,</span>
  * where as most newer devices use the FAP protocol. Both protocols are
  * compatible with the underlying transport, which could be usb, Unifiying, or
  * bluetooth. The message lengths are defined by the hid vendor specific report
<span class="p_del">- * descriptor for the HIDPP_SHORT report type (total message lenth 7 bytes) and</span>
<span class="p_add">+ * descriptor for the HIDPP_SHORT report type (total message length 7 bytes) and</span>
  * the HIDPP_LONG report type (total message length 20 bytes)
  *
  * The RAP protocol uses both report types, whereas the FAP only uses HIDPP_LONG
<span class="p_chunk">@@ -1822,7 +1822,7 @@</span> <span class="p_context"> static int m560_input_mapping(struct hid_device *hdev, struct hid_input *hi,</span>
 /*
  * The Logitech K400 keyboard has an embedded touchpad which is seen
  * as a mouse from the OS point of view. There is a hardware shortcut to disable
<span class="p_del">- * tap-to-click but the setting is not remembered accross reset, annoying some</span>
<span class="p_add">+ * tap-to-click but the setting is not remembered across reset, annoying some</span>
  * users.
  *
  * We can toggle this feature from the host by using the feature 0x6010:
<span class="p_header">diff --git a/drivers/hsi/controllers/omap_ssi_port.c b/drivers/hsi/controllers/omap_ssi_port.c</span>
<span class="p_header">index 7765de2..7dd37f0 100644</span>
<span class="p_header">--- a/drivers/hsi/controllers/omap_ssi_port.c</span>
<span class="p_header">+++ b/drivers/hsi/controllers/omap_ssi_port.c</span>
<span class="p_chunk">@@ -1028,7 +1028,7 @@</span> <span class="p_context"> static irqreturn_t ssi_wake_thread(int irq __maybe_unused, void *ssi_port)</span>
 		 * In such a case if we have long interrupt latencies,
 		 * we can miss the low event or get twice a high event.
 		 * This workaround will avoid breaking the clock reference
<span class="p_del">-		 * count when such a situation ocurrs.</span>
<span class="p_add">+		 * count when such a situation occurs.</span>
 		 */
 		if (!test_and_set_bit(SSI_WAKE_EN, &amp;omap_port-&gt;flags))
 			pm_runtime_get_sync(omap_port-&gt;pdev);
<span class="p_header">diff --git a/drivers/hwmon/abituguru.c b/drivers/hwmon/abituguru.c</span>
<span class="p_header">index 7a09c16..00125b7 100644</span>
<span class="p_header">--- a/drivers/hwmon/abituguru.c</span>
<span class="p_header">+++ b/drivers/hwmon/abituguru.c</span>
<span class="p_chunk">@@ -488,7 +488,7 @@</span> <span class="p_context"> abituguru_detect_bank1_sensor_type(struct abituguru_data *data,</span>
 	u8 val, test_flag, buf[3];
 	int i, ret = -ENODEV; /* error is the most common used retval :| */
 
<span class="p_del">-	/* If overriden by the user return the user selected type */</span>
<span class="p_add">+	/* If overridden by the user return the user selected type */</span>
 	if (bank1_types[sensor_addr] &gt;= ABIT_UGURU_IN_SENSOR &amp;&amp;
 			bank1_types[sensor_addr] &lt;= ABIT_UGURU_NC) {
 		ABIT_UGURU_DEBUG(2, &quot;assuming sensor type %d for bank1 sensor &quot;
<span class="p_chunk">@@ -1275,7 +1275,7 @@</span> <span class="p_context"> static int abituguru_probe(struct platform_device *pdev)</span>
 
 	/*
 	 * El weirdo probe order, to keep the sysfs order identical to the
<span class="p_del">-	 * BIOS and window-appliction listing order.</span>
<span class="p_add">+	 * BIOS and window-application listing order.</span>
 	 */
 	const u8 probe_order[ABIT_UGURU_MAX_BANK1_SENSORS] = {
 		0x00, 0x01, 0x03, 0x04, 0x0A, 0x08, 0x0E, 0x02,
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-nomadik.c b/drivers/i2c/busses/i2c-nomadik.c</span>
<span class="p_header">index bcd17e8..dabe496 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-nomadik.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-nomadik.c</span>
<span class="p_chunk">@@ -166,7 +166,7 @@</span> <span class="p_context"> struct i2c_nmk_client {</span>
  * @sm: speed mode
  * @stop: stop condition.
  * @xfer_complete: acknowledge completion for a I2C message.
<span class="p_del">- * @result: controller propogated result.</span>
<span class="p_add">+ * @result: controller propagated result.</span>
  */
 struct nmk_i2c_dev {
 	struct i2c_vendor_data		*vendor;
<span class="p_header">diff --git a/drivers/infiniband/core/uverbs_main.c b/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_header">index 0012fa5..5d8c66a 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_chunk">@@ -393,7 +393,7 @@</span> <span class="p_context"> static ssize_t ib_uverbs_event_read(struct file *filp, char __user *buf,</span>
 		if (wait_event_interruptible(file-&gt;poll_wait,
 					     (!list_empty(&amp;file-&gt;event_list) ||
 			/* The barriers built into wait_event_interruptible()
<span class="p_del">-			 * and wake_up() guarentee this will see the null set</span>
<span class="p_add">+			 * and wake_up() guarantee this will see the null set</span>
 			 * without using RCU
 			 */
 					     !file-&gt;uverbs_file-&gt;device-&gt;ib_dev)))
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/odp.c b/drivers/infiniband/hw/mlx5/odp.c</span>
<span class="p_header">index 34e79e7..33e1bb3 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/odp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/odp.c</span>
<span class="p_chunk">@@ -711,7 +711,7 @@</span> <span class="p_context"> void mlx5_ib_qp_disable_pagefaults(struct mlx5_ib_qp *qp)</span>
 	spin_unlock_irqrestore(&amp;qp-&gt;disable_page_faults_lock, flags);
 
 	/*
<span class="p_del">-	 * Note that at this point, we are guarenteed that no more</span>
<span class="p_add">+	 * Note that at this point, we are guaranteed that no more</span>
 	 * work queue elements will be posted to the work queue with
 	 * the QP we are closing.
 	 */
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_common.h b/drivers/infiniband/hw/qib/qib_common.h</span>
<span class="p_header">index 1d6e63e..4c80ba3 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_common.h</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_common.h</span>
<span class="p_chunk">@@ -123,7 +123,7 @@</span> <span class="p_context"> enum qib_ureg {</span>
  * open to get implementation-specific info, and info specific to this
  * instance.
  *
<span class="p_del">- * This struct must have explict pad fields where type sizes</span>
<span class="p_add">+ * This struct must have explicit pad fields where type sizes</span>
  * may result in different alignments between 32 and 64 bit
  * programs, since the 64 bit * bit kernel requires the user code
  * to have matching offsets
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_sd7220.c b/drivers/infiniband/hw/qib/qib_sd7220.c</span>
<span class="p_header">index c72775f..7c356f6 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_sd7220.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_sd7220.c</span>
<span class="p_chunk">@@ -1128,7 +1128,7 @@</span> <span class="p_context"> static int qib_sd_setvals(struct qib_devdata *dd)</span>
  * be the location in some channel of the register to be modified
  * The caller can specify use of the &quot;gang write&quot; option of EPB,
  * in which case we use the specified channel data for any fields
<span class="p_del">- * not explicitely written.</span>
<span class="p_add">+ * not explicitly written.</span>
  */
 static int ibsd_mod_allchnls(struct qib_devdata *dd, int loc, int val,
 			     int mask)
<span class="p_header">diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.c b/drivers/infiniband/ulp/iser/iscsi_iser.c</span>
<span class="p_header">index 64b3d11..cf3e2d1 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/iser/iscsi_iser.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c</span>
<span class="p_chunk">@@ -395,10 +395,10 @@</span> <span class="p_context"> static void iscsi_iser_cleanup_task(struct iscsi_task *task)</span>
  * @task:     iscsi task
  * @sector:   error sector if exsists (output)
  *
<span class="p_del">- * Return: zero if no data-integrity errors have occured</span>
<span class="p_del">- *         0x1: data-integrity error occured in the guard-block</span>
<span class="p_del">- *         0x2: data-integrity error occured in the reference tag</span>
<span class="p_del">- *         0x3: data-integrity error occured in the application tag</span>
<span class="p_add">+ * Return: zero if no data-integrity errors have occurred</span>
<span class="p_add">+ *         0x1: data-integrity error occurred in the guard-block</span>
<span class="p_add">+ *         0x2: data-integrity error occurred in the reference tag</span>
<span class="p_add">+ *         0x3: data-integrity error occurred in the application tag</span>
  *
  *         In addition the error sector is marked.
  */
<span class="p_chunk">@@ -509,7 +509,7 @@</span> <span class="p_context"> out:</span>
  * iscsi_iser_conn_start() - start iscsi-iser connection
  * @cls_conn: iscsi class connection
  *
<span class="p_del">- * Notes: Here iser intialize (or re-initialize) stop_completion as</span>
<span class="p_add">+ * Notes: Here iser initialize (or re-initialize) stop_completion as</span>
  *        from this point iscsi must call conn_stop in session/connection
  *        teardown so iser transport must wait for it.
  */
<span class="p_header">diff --git a/drivers/iommu/dmar.c b/drivers/iommu/dmar.c</span>
<span class="p_header">index 58470f5..c2db414 100644</span>
<span class="p_header">--- a/drivers/iommu/dmar.c</span>
<span class="p_header">+++ b/drivers/iommu/dmar.c</span>
<span class="p_chunk">@@ -54,7 +54,7 @@</span> <span class="p_context"> struct dmar_res_callback {</span>
 
 /*
  * Assumptions:
<span class="p_del">- * 1) The hotplug framework guarentees that DMAR unit will be hot-added</span>
<span class="p_add">+ * 1) The hotplug framework guarantees that DMAR unit will be hot-added</span>
  *    before IO devices managed by that unit.
  * 2) The hotplug framework guarantees that DMAR unit will be hot-removed
  *    after IO devices managed by that unit.
<span class="p_header">diff --git a/drivers/isdn/mISDN/dsp_core.c b/drivers/isdn/mISDN/dsp_core.c</span>
<span class="p_header">index 0222b1a..9b85295 100644</span>
<span class="p_header">--- a/drivers/isdn/mISDN/dsp_core.c</span>
<span class="p_header">+++ b/drivers/isdn/mISDN/dsp_core.c</span>
<span class="p_chunk">@@ -115,7 +115,7 @@</span> <span class="p_context"></span>
  *
  * The CMX has special functions for conferences with one, two and more
  * members. It will allow different types of data flow. Receive and transmit
<span class="p_del">- * data to/form upper layer may be swithed on/off individually without losing</span>
<span class="p_add">+ * data to/form upper layer may be switched on/off individually without losing</span>
  * features of CMX, Tones and DTMF.
  *
  * Echo Cancellation: Sometimes we like to cancel echo from the interface.
<span class="p_header">diff --git a/drivers/macintosh/via-pmu.c b/drivers/macintosh/via-pmu.c</span>
<span class="p_header">index f8b6d14..307b1d9 100644</span>
<span class="p_header">--- a/drivers/macintosh/via-pmu.c</span>
<span class="p_header">+++ b/drivers/macintosh/via-pmu.c</span>
<span class="p_chunk">@@ -443,7 +443,7 @@</span> <span class="p_context"> static int __init via_pmu_start(void)</span>
 	/* Make sure PMU settle down before continuing. This is _very_ important
 	 * since the IDE probe may shut interrupts down for quite a bit of time. If
 	 * a PMU communication is pending while this happens, the PMU may timeout
<span class="p_del">-	 * Not that on Core99 machines, the PMU keeps sending us environement</span>
<span class="p_add">+	 * Not that on Core99 machines, the PMU keeps sending us environment</span>
 	 * messages, we should find a way to either fix IDE or make it call
 	 * pmu_suspend() before masking interrupts. This can also happens while
 	 * scolling with some fbdevs.
<span class="p_header">diff --git a/drivers/mailbox/pl320-ipc.c b/drivers/mailbox/pl320-ipc.c</span>
<span class="p_header">index 2dbed87..66d0f5f 100644</span>
<span class="p_header">--- a/drivers/mailbox/pl320-ipc.c</span>
<span class="p_header">+++ b/drivers/mailbox/pl320-ipc.c</span>
<span class="p_chunk">@@ -84,7 +84,7 @@</span> <span class="p_context"> static u32 __ipc_rcv(int mbox, u32 *data)</span>
 	return data[1];
 }
 
<span class="p_del">-/* blocking implmentation from the A9 side, not usuable in interrupts! */</span>
<span class="p_add">+/* blocking implementation from the A9 side, not usuable in interrupts! */</span>
 int pl320_ipc_transmit(u32 *data)
 {
 	int ret;
<span class="p_header">diff --git a/drivers/md/Kconfig b/drivers/md/Kconfig</span>
<span class="p_header">index 02a5345..3980ba8 100644</span>
<span class="p_header">--- a/drivers/md/Kconfig</span>
<span class="p_header">+++ b/drivers/md/Kconfig</span>
<span class="p_chunk">@@ -220,7 +220,7 @@</span> <span class="p_context"> config DM_MQ_DEFAULT</span>
 	  This option enables the blk-mq based I/O path for request-based
 	  DM devices by default.  With the option the dm_mod.use_blk_mq
 	  module/boot option defaults to Y, without it to N, but it can
<span class="p_del">-	  still be overriden either way.</span>
<span class="p_add">+	  still be overridden either way.</span>
 
 	  If unsure say N.
 
<span class="p_header">diff --git a/drivers/md/bcache/stats.c b/drivers/md/bcache/stats.c</span>
<span class="p_header">index 0ca072c..140f6b1 100644</span>
<span class="p_header">--- a/drivers/md/bcache/stats.c</span>
<span class="p_header">+++ b/drivers/md/bcache/stats.c</span>
<span class="p_chunk">@@ -10,7 +10,7 @@</span> <span class="p_context"></span>
 #include &quot;sysfs.h&quot;
 
 /*
<span class="p_del">- * We keep absolute totals of various statistics, and addionally a set of three</span>
<span class="p_add">+ * We keep absolute totals of various statistics, and additionally a set of three</span>
  * rolling averages.
  *
  * Every so often, a timer goes off and rescales the rolling averages.
<span class="p_header">diff --git a/drivers/media/dvb-frontends/drx39xyj/drx_dap_fasi.h b/drivers/media/dvb-frontends/drx39xyj/drx_dap_fasi.h</span>
<span class="p_header">index 354ec07..4f9b299 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/drx39xyj/drx_dap_fasi.h</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/drx39xyj/drx_dap_fasi.h</span>
<span class="p_chunk">@@ -112,7 +112,7 @@</span> <span class="p_context"></span>
 *  + single master mode means no use of repeated starts
 *  + multi master mode means use of repeated starts
 *  Default is single master.
<span class="p_del">-*  Default can be overriden by setting the compile switch DRXDAP_SINGLE_MASTER.</span>
<span class="p_add">+*  Default can be overridden by setting the compile switch DRXDAP_SINGLE_MASTER.</span>
 *
 * Slave:
 * Single/multi master selected via the flags in the FASI protocol.
<span class="p_header">diff --git a/drivers/media/dvb-frontends/drx39xyj/drx_driver.h b/drivers/media/dvb-frontends/drx39xyj/drx_driver.h</span>
<span class="p_header">index 9076bf2..b630834 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/drx39xyj/drx_driver.h</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/drx39xyj/drx_driver.h</span>
<span class="p_chunk">@@ -256,8 +256,7 @@</span> <span class="p_context"> int drxbsp_tuner_default_i2c_write_read(struct tuner_instance *tuner,</span>
 *
 * The actual DAP implementation may be restricted to only one of the modes.
 * A compiler warning or error will be generated if the DAP implementation
<span class="p_del">-* overides or cannot handle the mode defined below.</span>
<span class="p_del">-*</span>
<span class="p_add">+* overrides or cannot handle the mode defined below.</span>
 */
 #ifndef DRXDAP_SINGLE_MASTER
 #define DRXDAP_SINGLE_MASTER 1
<span class="p_chunk">@@ -272,7 +271,7 @@</span> <span class="p_context"> int drxbsp_tuner_default_i2c_write_read(struct tuner_instance *tuner,</span>
 *
 * This maximum size may be restricted by the actual DAP implementation.
 * A compiler warning or error will be generated if the DAP implementation
<span class="p_del">-* overides or cannot handle the chunksize defined below.</span>
<span class="p_add">+* overrides or cannot handle the chunksize defined below.</span>
 *
 * Beware that the DAP uses  DRXDAP_MAX_WCHUNKSIZE to create a temporary data
 * buffer. Do not undefine or choose too large, unless your system is able to
<span class="p_chunk">@@ -292,8 +291,7 @@</span> <span class="p_context"> int drxbsp_tuner_default_i2c_write_read(struct tuner_instance *tuner,</span>
 *
 * This maximum size may be restricted by the actual DAP implementation.
 * A compiler warning or error will be generated if the DAP implementation
<span class="p_del">-* overides or cannot handle the chunksize defined below.</span>
<span class="p_del">-*</span>
<span class="p_add">+* overrides or cannot handle the chunksize defined below.</span>
 */
 #ifndef DRXDAP_MAX_RCHUNKSIZE
 #define  DRXDAP_MAX_RCHUNKSIZE 60
<span class="p_chunk">@@ -1001,7 +999,7 @@</span> <span class="p_context"> struct drx_filter_info {</span>
 * \struct struct drx_channel * \brief The set of parameters describing a single channel.
 *
 * Used by DRX_CTRL_SET_CHANNEL and DRX_CTRL_GET_CHANNEL.
<span class="p_del">-* Only certain fields need to be used for a specfic standard.</span>
<span class="p_add">+* Only certain fields need to be used for a specific standard.</span>
 *
 */
 struct drx_channel {
<span class="p_chunk">@@ -1317,9 +1315,9 @@</span> <span class="p_context"> struct drx_version_list {</span>
 		DRX_MPEG_STR_WIDTH_8
 	};
 
<span class="p_del">-/* CTRL CFG MPEG ouput */</span>
<span class="p_add">+/* CTRL CFG MPEG output */</span>
 /**
<span class="p_del">-* \struct struct drx_cfg_mpeg_output * \brief Configuartion parameters for MPEG output control.</span>
<span class="p_add">+* \struct struct drx_cfg_mpeg_output * \brief Configuration parameters for MPEG output control.</span>
 *
 * Used by DRX_CFG_MPEG_OUTPUT, in combination with DRX_CTRL_SET_CFG and
 * DRX_CTRL_GET_CFG.
<span class="p_header">diff --git a/drivers/media/i2c/adv7183_regs.h b/drivers/media/i2c/adv7183_regs.h</span>
<span class="p_header">index b253d40..abe8599 100644</span>
<span class="p_header">--- a/drivers/media/i2c/adv7183_regs.h</span>
<span class="p_header">+++ b/drivers/media/i2c/adv7183_regs.h</span>
<span class="p_chunk">@@ -87,7 +87,7 @@</span> <span class="p_context"></span>
 #define ADV7183_LETTERBOX_3        0x9D /* Letterbox 3 */
 #define ADV7183_CRC_EN             0xB2 /* CRC enable */
 #define ADV7183_ADC_SWITCH_1       0xC3 /* ADC switch 1 */
<span class="p_del">-#define ADV7183_ADC_SWITCH_2       0xC4 /* ADC swithc 2 */</span>
<span class="p_add">+#define ADV7183_ADC_SWITCH_2       0xC4 /* ADC switch 2 */</span>
 #define ADV7183_LETTERBOX_CTRL_1   0xDC /* Letterbox control 1 */
 #define ADV7183_LETTERBOX_CTRL_2   0xDD /* Letterbox control 2 */
 #define ADV7183_SD_OFFSET_CB       0xE1 /* SD offset Cb */
<span class="p_header">diff --git a/drivers/media/pci/bt8xx/bttv-audio-hook.c b/drivers/media/pci/bt8xx/bttv-audio-hook.c</span>
<span class="p_header">index 9f1f9169..38fe3cd 100644</span>
<span class="p_header">--- a/drivers/media/pci/bt8xx/bttv-audio-hook.c</span>
<span class="p_header">+++ b/drivers/media/pci/bt8xx/bttv-audio-hook.c</span>
<span class="p_chunk">@@ -1,5 +1,5 @@</span> <span class="p_context"></span>
 /*
<span class="p_del">- * Handlers for board audio hooks, splitted from bttv-cards</span>
<span class="p_add">+ * Handlers for board audio hooks, split from bttv-cards</span>
  *
  * Copyright (c) 2006 Mauro Carvalho Chehab (mchehab@infradead.org)
  * This code is placed under the terms of the GNU General Public License
<span class="p_header">diff --git a/drivers/media/pci/bt8xx/bttv-audio-hook.h b/drivers/media/pci/bt8xx/bttv-audio-hook.h</span>
<span class="p_header">index 159d07a..008a481 100644</span>
<span class="p_header">--- a/drivers/media/pci/bt8xx/bttv-audio-hook.h</span>
<span class="p_header">+++ b/drivers/media/pci/bt8xx/bttv-audio-hook.h</span>
<span class="p_chunk">@@ -1,5 +1,5 @@</span> <span class="p_context"></span>
 /*
<span class="p_del">- * Handlers for board audio hooks, splitted from bttv-cards</span>
<span class="p_add">+ * Handlers for board audio hooks, split from bttv-cards</span>
  *
  * Copyright (c) 2006 Mauro Carvalho Chehab (mchehab@infradead.org)
  * This code is placed under the terms of the GNU General Public License
<span class="p_header">diff --git a/drivers/media/pci/bt8xx/bttv-risc.c b/drivers/media/pci/bt8xx/bttv-risc.c</span>
<span class="p_header">index 3859dde..b264832 100644</span>
<span class="p_header">--- a/drivers/media/pci/bt8xx/bttv-risc.c</span>
<span class="p_header">+++ b/drivers/media/pci/bt8xx/bttv-risc.c</span>
<span class="p_chunk">@@ -93,7 +93,7 @@</span> <span class="p_context"> bttv_risc_packed(struct bttv *btv, struct btcx_riscmem *risc,</span>
 			*(rp++)=cpu_to_le32(sg_dma_address(sg)+offset);
 			offset+=bpl;
 		} else {
<span class="p_del">-			/* scanline needs to be splitted */</span>
<span class="p_add">+			/* scanline needs to be split */</span>
 			todo = bpl;
 			*(rp++)=cpu_to_le32(BT848_RISC_WRITE|BT848_RISC_SOL|
 					    (sg_dma_len(sg)-offset));
<span class="p_header">diff --git a/drivers/media/pci/ivtv/ivtv-yuv.c b/drivers/media/pci/ivtv/ivtv-yuv.c</span>
<span class="p_header">index b094054..0d4c47c 100644</span>
<span class="p_header">--- a/drivers/media/pci/ivtv/ivtv-yuv.c</span>
<span class="p_header">+++ b/drivers/media/pci/ivtv/ivtv-yuv.c</span>
<span class="p_chunk">@@ -109,7 +109,7 @@</span> <span class="p_context"> static int ivtv_yuv_prep_user_dma(struct ivtv *itv, struct ivtv_user_dma *dma,</span>
 			/*
 			 * Inherit the -EFAULT from rc&#39;s
 			 * initialization, but allow it to be
<span class="p_del">-			 * overriden by uv_pages above if it was an</span>
<span class="p_add">+			 * overridden by uv_pages above if it was an</span>
 			 * actual errno.
 			 */
 		} else {
<span class="p_header">diff --git a/drivers/media/platform/exynos4-is/fimc-core.h b/drivers/media/platform/exynos4-is/fimc-core.h</span>
<span class="p_header">index 5615fef..c0373ae 100644</span>
<span class="p_header">--- a/drivers/media/platform/exynos4-is/fimc-core.h</span>
<span class="p_header">+++ b/drivers/media/platform/exynos4-is/fimc-core.h</span>
<span class="p_chunk">@@ -358,7 +358,7 @@</span> <span class="p_context"> struct fimc_pix_limit {</span>
  * @pix_limit: pixel size constraints for the scaler
  * @min_inp_pixsize: minimum input pixel size
  * @min_out_pixsize: minimum output pixel size
<span class="p_del">- * @hor_offs_align: horizontal pixel offset aligment</span>
<span class="p_add">+ * @hor_offs_align: horizontal pixel offset alignment</span>
  * @min_vsize_align: minimum vertical pixel size alignment
  */
 struct fimc_variant {
<span class="p_header">diff --git a/drivers/media/rc/img-ir/img-ir-hw.c b/drivers/media/rc/img-ir/img-ir-hw.c</span>
<span class="p_header">index 7bb71bc..70d4610 100644</span>
<span class="p_header">--- a/drivers/media/rc/img-ir/img-ir-hw.c</span>
<span class="p_header">+++ b/drivers/media/rc/img-ir/img-ir-hw.c</span>
<span class="p_chunk">@@ -612,7 +612,7 @@</span> <span class="p_context"> unlock:</span>
 }
 
 /**
<span class="p_del">- * img_ir_decoder_compatable() - Find whether a decoder will work with a device.</span>
<span class="p_add">+ * img_ir_decoder_compatible() - Find whether a decoder will work with a device.</span>
  * @priv:	IR private data.
  * @dec:	Decoder to check.
  *
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb-v2/mxl111sf-i2c.c b/drivers/media/usb/dvb-usb-v2/mxl111sf-i2c.c</span>
<span class="p_header">index 283495c..01d98d6 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb-v2/mxl111sf-i2c.c</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb-v2/mxl111sf-i2c.c</span>
<span class="p_chunk">@@ -770,7 +770,7 @@</span> <span class="p_context"> exit:</span>
 	buf[0] = USB_WRITE_I2C_CMD;
 	buf[1] = 0x00;
 
<span class="p_del">-	/* de-initilize I2C BUS */</span>
<span class="p_add">+	/* de-initialize I2C BUS */</span>
 	buf[5] = USB_END_I2C_CMD;
 	mxl111sf_i2c_send_data(state, 0, buf);
 
<span class="p_chunk">@@ -784,7 +784,7 @@</span> <span class="p_context"> exit:</span>
 	buf[6] = 0x00;
 	buf[7] = 0x00;
 
<span class="p_del">-	/* de-initilize I2C BUS */</span>
<span class="p_add">+	/* de-initialize I2C BUS */</span>
 	buf[8] = USB_END_I2C_CMD;
 	mxl111sf_i2c_send_data(state, 0, buf);
 
<span class="p_header">diff --git a/drivers/media/usb/gspca/sonixj.c b/drivers/media/usb/gspca/sonixj.c</span>
<span class="p_header">index fd1c870..3fcbe04 100644</span>
<span class="p_header">--- a/drivers/media/usb/gspca/sonixj.c</span>
<span class="p_header">+++ b/drivers/media/usb/gspca/sonixj.c</span>
<span class="p_chunk">@@ -2684,7 +2684,7 @@</span> <span class="p_context"> static void sd_pkt_scan(struct gspca_dev *gspca_dev,</span>
 	 * which is 62 bytes long and is followed by various information
 	 * including statuses and luminosity.
 	 *
<span class="p_del">-	 * A marker may be splitted on two packets.</span>
<span class="p_add">+	 * A marker may be split on two packets.</span>
 	 *
 	 * The 6th byte of a marker contains the bits:
 	 *	0x08: USB full
<span class="p_header">diff --git a/drivers/media/usb/gspca/t613.c b/drivers/media/usb/gspca/t613.c</span>
<span class="p_header">index bb52fc1..4753ccb 100644</span>
<span class="p_header">--- a/drivers/media/usb/gspca/t613.c</span>
<span class="p_header">+++ b/drivers/media/usb/gspca/t613.c</span>
<span class="p_chunk">@@ -574,10 +574,12 @@</span> <span class="p_context"> static void setfreq(struct gspca_dev *gspca_dev, s32 val)</span>
 /* this function is called at probe and resume time */
 static int sd_init(struct gspca_dev *gspca_dev)
 {
<span class="p_del">-	/* some of this registers are not really neded, because</span>
<span class="p_del">-	 * they are overriden by setbrigthness, setcontrast, etc,</span>
<span class="p_del">-	 * but wont hurt anyway, and can help someone with similar webcam</span>
<span class="p_del">-	 * to see the initial parameters.*/</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * some of this registers are not really needed, because</span>
<span class="p_add">+	 * they are overridden by setbrightness, setcontrast, etc,</span>
<span class="p_add">+	 * but won&#39;t hurt anyway, and can help someone with similar webcam</span>
<span class="p_add">+	 * to see the initial parameters.</span>
<span class="p_add">+	 */</span>
 	struct sd *sd = (struct sd *) gspca_dev;
 	const struct additional_sensor_data *sensor;
 	int i;
<span class="p_header">diff --git a/drivers/media/usb/ttusb-budget/dvb-ttusb-budget.c b/drivers/media/usb/ttusb-budget/dvb-ttusb-budget.c</span>
<span class="p_header">index d52d4a8..966573c 100644</span>
<span class="p_header">--- a/drivers/media/usb/ttusb-budget/dvb-ttusb-budget.c</span>
<span class="p_header">+++ b/drivers/media/usb/ttusb-budget/dvb-ttusb-budget.c</span>
<span class="p_chunk">@@ -307,7 +307,7 @@</span> <span class="p_context"> static int ttusb_boot_dsp(struct ttusb *ttusb)</span>
 	b[3] = 28;
 
 	/* upload dsp code in 32 byte steps (36 didn&#39;t work for me ...) */
<span class="p_del">-	/* 32 is max packet size, no messages should be splitted. */</span>
<span class="p_add">+	/* 32 is max packet size, no messages should be split. */</span>
 	for (i = 0; i &lt; fw-&gt;size; i += 28) {
 		memcpy(&amp;b[4], &amp;fw-&gt;data[i], 28);
 
<span class="p_header">diff --git a/drivers/media/usb/usbvision/usbvision-core.c b/drivers/media/usb/usbvision/usbvision-core.c</span>
<span class="p_header">index 52ac439..0c98417 100644</span>
<span class="p_header">--- a/drivers/media/usb/usbvision/usbvision-core.c</span>
<span class="p_header">+++ b/drivers/media/usb/usbvision/usbvision-core.c</span>
<span class="p_chunk">@@ -904,7 +904,7 @@</span> <span class="p_context"> static enum parse_state usbvision_parse_lines_420(struct usb_usbvision *usbvisio</span>
 	if ((frame-&gt;curline + 1) &gt;= frame-&gt;frmheight)
 		return parse_state_next_frame;
 
<span class="p_del">-	block_split = (pixel_per_line%y_block_size) ? 1 : 0;	/* are some blocks splitted into different lines? */</span>
<span class="p_add">+	block_split = (pixel_per_line%y_block_size) ? 1 : 0;	/* are some blocks split into different lines? */</span>
 
 	y_odd_offset = (pixel_per_line / y_block_size) * (y_block_size + uv_block_size)
 			+ block_split * uv_block_size;
<span class="p_header">diff --git a/drivers/media/usb/uvc/uvc_video.c b/drivers/media/usb/uvc/uvc_video.c</span>
<span class="p_header">index b5589d5..1642e7c 100644</span>
<span class="p_header">--- a/drivers/media/usb/uvc/uvc_video.c</span>
<span class="p_header">+++ b/drivers/media/usb/uvc/uvc_video.c</span>
<span class="p_chunk">@@ -1787,8 +1787,9 @@</span> <span class="p_context"> int uvc_video_init(struct uvc_streaming *stream)</span>
 	 */
 	usb_set_interface(stream-&gt;dev-&gt;udev, stream-&gt;intfnum, 0);
 
<span class="p_del">-	/* Set the streaming probe control with default streaming parameters</span>
<span class="p_del">-	 * retrieved from the device. Webcams that don&#39;t suport GET_DEF</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Set the streaming probe control with default streaming parameters</span>
<span class="p_add">+	 * retrieved from the device. Webcams that don&#39;t support GET_DEF</span>
 	 * requests on the probe control will just keep their current streaming
 	 * parameters.
 	 */
<span class="p_header">diff --git a/drivers/mfd/max77620.c b/drivers/mfd/max77620.c</span>
<span class="p_header">index 258757e..b1700b5 100644</span>
<span class="p_header">--- a/drivers/mfd/max77620.c</span>
<span class="p_header">+++ b/drivers/mfd/max77620.c</span>
<span class="p_chunk">@@ -461,7 +461,7 @@</span> <span class="p_context"> static int max77620_probe(struct i2c_client *client,</span>
 	chip-&gt;rmap = devm_regmap_init_i2c(client, rmap_config);
 	if (IS_ERR(chip-&gt;rmap)) {
 		ret = PTR_ERR(chip-&gt;rmap);
<span class="p_del">-		dev_err(chip-&gt;dev, &quot;Failed to intialise regmap: %d\n&quot;, ret);</span>
<span class="p_add">+		dev_err(chip-&gt;dev, &quot;Failed to initialise regmap: %d\n&quot;, ret);</span>
 		return ret;
 	}
 
<span class="p_header">diff --git a/drivers/misc/pti.c b/drivers/misc/pti.c</span>
<span class="p_header">index eda38cb..d07383a 100644</span>
<span class="p_header">--- a/drivers/misc/pti.c</span>
<span class="p_header">+++ b/drivers/misc/pti.c</span>
<span class="p_chunk">@@ -572,7 +572,7 @@</span> <span class="p_context"> static int pti_char_open(struct inode *inode, struct file *filp)</span>
  * pti_char_release()-  Close a char channel to the PTI device. Part
  * of the misc device implementation.
  *
<span class="p_del">- * @inode: Not used in this implementaiton.</span>
<span class="p_add">+ * @inode: Not used in this implementation.</span>
  * @filp:  Contains private_data that contains the master, channel
  *         ID to be released by the PTI device.
  *
<span class="p_chunk">@@ -671,7 +671,7 @@</span> <span class="p_context"> static struct miscdevice pti_char_driver = {</span>
 /**
  * pti_console_write()-  Write to the console that has been acquired.
  *
<span class="p_del">- * @c:   Not used in this implementaiton.</span>
<span class="p_add">+ * @c:   Not used in this implementation.</span>
  * @buf: Data to be written.
  * @len: Length of buf.
  */
<span class="p_header">diff --git a/drivers/misc/vmw_vmci/vmci_queue_pair.h b/drivers/misc/vmw_vmci/vmci_queue_pair.h</span>
<span class="p_header">index ed177f0..22e2657 100644</span>
<span class="p_header">--- a/drivers/misc/vmw_vmci/vmci_queue_pair.h</span>
<span class="p_header">+++ b/drivers/misc/vmw_vmci/vmci_queue_pair.h</span>
<span class="p_chunk">@@ -112,7 +112,7 @@</span> <span class="p_context"> struct vmci_qp_dtch_info {</span>
 struct vmci_qp_page_store {
 	/* Reference to pages backing the queue pair. */
 	u64 pages;
<span class="p_del">-	/* Length of pageList/virtual addres range (in pages). */</span>
<span class="p_add">+	/* Length of pageList/virtual address range (in pages). */</span>
 	u32 len;
 };
 
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index 2206d44..215c153 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -71,7 +71,7 @@</span> <span class="p_context"> MODULE_ALIAS(&quot;mmc:block&quot;);</span>
 static DEFINE_MUTEX(block_mutex);
 
 /*
<span class="p_del">- * The defaults come from config options but can be overriden by module</span>
<span class="p_add">+ * The defaults come from config options but can be overridden by module</span>
  * or bootarg options.
  */
 static int perdev_minors = CONFIG_MMC_BLOCK_MINORS;
<span class="p_header">diff --git a/drivers/mmc/host/mmci_qcom_dml.c b/drivers/mmc/host/mmci_qcom_dml.c</span>
<span class="p_header">index 2b7fc37..00750c9 100644</span>
<span class="p_header">--- a/drivers/mmc/host/mmci_qcom_dml.c</span>
<span class="p_header">+++ b/drivers/mmc/host/mmci_qcom_dml.c</span>
<span class="p_chunk">@@ -170,7 +170,7 @@</span> <span class="p_context"> int dml_hw_init(struct mmci_host *host, struct device_node *np)</span>
 	writel_relaxed(producer_id | (consumer_id &lt;&lt; CONSUMER_PIPE_ID_SHFT),
 		       base + DML_PIPE_ID);
 
<span class="p_del">-	/* Make sure dml intialization is finished */</span>
<span class="p_add">+	/* Make sure dml initialization is finished */</span>
 	mb();
 
 	return 0;
<span class="p_header">diff --git a/drivers/mtd/nand/denali.c b/drivers/mtd/nand/denali.c</span>
<span class="p_header">index 0476ae8..0c26b4c 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/denali.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/denali.c</span>
<span class="p_chunk">@@ -1487,7 +1487,7 @@</span> <span class="p_context"> int denali_init(struct denali_nand_info *denali)</span>
 
 	/*
 	 * denali_isr register is done after all the hardware
<span class="p_del">-	 * initilization is finished</span>
<span class="p_add">+	 * initialization is finished</span>
 	 */
 	if (request_irq(denali-&gt;irq, denali_isr, IRQF_SHARED,
 			DENALI_NAND_NAME, denali)) {
<span class="p_header">diff --git a/drivers/mtd/nand/fsl_ifc_nand.c b/drivers/mtd/nand/fsl_ifc_nand.c</span>
<span class="p_header">index 4e9e5fd..8f15c03 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/fsl_ifc_nand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/fsl_ifc_nand.c</span>
<span class="p_chunk">@@ -593,7 +593,7 @@</span> <span class="p_context"> static uint8_t fsl_ifc_read_byte(struct mtd_info *mtd)</span>
 
 /*
  * Read two bytes from the IFC hardware buffer
<span class="p_del">- * read function for 16-bit buswith</span>
<span class="p_add">+ * read function for 16-bit buswidth</span>
  */
 static uint8_t fsl_ifc_read_byte16(struct mtd_info *mtd)
 {
<span class="p_header">diff --git a/drivers/mtd/nand/gpmi-nand/gpmi-nand.c b/drivers/mtd/nand/gpmi-nand/gpmi-nand.c</span>
<span class="p_header">index 6e46156..33cf2f4 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/gpmi-nand/gpmi-nand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/gpmi-nand/gpmi-nand.c</span>
<span class="p_chunk">@@ -1903,7 +1903,7 @@</span> <span class="p_context"> static int nand_boot_init(struct gpmi_nand_data  *this)</span>
 {
 	nand_boot_set_geometry(this);
 
<span class="p_del">-	/* This is ROM arch-specific initilization before the BBT scanning. */</span>
<span class="p_add">+	/* This is ROM arch-specific initialization before the BBT scanning. */</span>
 	if (GPMI_IS_MX23(this))
 		return mx23_boot_init(this);
 	return 0;
<span class="p_header">diff --git a/drivers/mtd/nand/pxa3xx_nand.c b/drivers/mtd/nand/pxa3xx_nand.c</span>
<span class="p_header">index 436dd6d..c33c94d 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/pxa3xx_nand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/pxa3xx_nand.c</span>
<span class="p_chunk">@@ -1305,7 +1305,7 @@</span> <span class="p_context"> static void nand_cmdfunc_extended(struct mtd_info *mtd,</span>
 			break;
 
 		/*
<span class="p_del">-		 * After a splitted program command sequence has issued</span>
<span class="p_add">+		 * After a split program command sequence has issued</span>
 		 * the command dispatch, the command sequence is complete.
 		 */
 		if (info-&gt;cur_chunk == (info-&gt;ntotalchunks + 1) &amp;&amp;
<span class="p_chunk">@@ -1321,7 +1321,7 @@</span> <span class="p_context"> static void nand_cmdfunc_extended(struct mtd_info *mtd,</span>
 				ext_cmd_type = EXT_CMD_TYPE_NAKED_RW;
 
 		/*
<span class="p_del">-		 * If a splitted program command has no more data to transfer,</span>
<span class="p_add">+		 * If a split program command has no more data to transfer,</span>
 		 * the command dispatch must be issued to complete.
 		 */
 		} else if (command == NAND_CMD_PAGEPROG &amp;&amp;
<span class="p_chunk">@@ -1705,7 +1705,7 @@</span> <span class="p_context"> static int pxa3xx_nand_scan(struct mtd_info *mtd)</span>
 	/*
 	 * If the page size is bigger than the FIFO size, let&#39;s check
 	 * we are given the right variant and then switch to the extended
<span class="p_del">-	 * (aka splitted) command handling,</span>
<span class="p_add">+	 * (aka split) command handling,</span>
 	 */
 	if (mtd-&gt;writesize &gt; PAGE_CHUNK_SIZE) {
 		if (info-&gt;variant == PXA3XX_NAND_VARIANT_ARMADA370) {
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bcm63xx_enet.c b/drivers/net/ethernet/broadcom/bcm63xx_enet.c</span>
<span class="p_header">index 6c8bc5f..dbaac5d 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bcm63xx_enet.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bcm63xx_enet.c</span>
<span class="p_chunk">@@ -817,7 +817,7 @@</span> <span class="p_context"> static void bcm_enet_adjust_phy_link(struct net_device *dev)</span>
 			rx_pause_en = 1;
 			tx_pause_en = 1;
 		} else if (!priv-&gt;pause_auto) {
<span class="p_del">-			/* pause setting overrided by user */</span>
<span class="p_add">+			/* pause setting overridden by user */</span>
 			rx_pause_en = priv-&gt;pause_rx;
 			tx_pause_en = priv-&gt;pause_tx;
 		} else {
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x.h b/drivers/net/ethernet/broadcom/bnx2x/bnx2x.h</span>
<span class="p_header">index 7dd7490..7dc7a87 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x.h</span>
<span class="p_chunk">@@ -654,7 +654,7 @@</span> <span class="p_context"> struct bnx2x_fastpath {</span>
 				 MAX_TX_DESC_CNT * NEXT_PAGE_TX_DESC_CNT)
 /* max BDs per tx packet w/o next_pages:
  * START_BD		- describes packed
<span class="p_del">- * START_BD(splitted)	- includes unpaged data segment for GSO</span>
<span class="p_add">+ * START_BD(split)	- includes unpaged data segment for GSO</span>
  * PARSING_BD		- for TSO and CSUM data
  * PARSING_BD2		- for encapsulation data
  * Frag BDs		- describes pages for frags
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c</span>
<span class="p_header">index 1fb8010..5a0f18e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c</span>
<span class="p_chunk">@@ -2546,7 +2546,7 @@</span> <span class="p_context"> static int bnx2x_pbf_update(struct link_params *params, u32 flow_ctrl,</span>
 }
 
 /**
<span class="p_del">- * bnx2x_get_emac_base - retrive emac base address</span>
<span class="p_add">+ * bnx2x_get_emac_base - retrieve emac base address</span>
  *
  * @bp:			driver handle
  * @mdc_mdio_access:	access type
<span class="p_chunk">@@ -3599,7 +3599,7 @@</span> <span class="p_context"> static u8 bnx2x_ext_phy_resolve_fc(struct bnx2x_phy *phy,</span>
 	u8 ret = 0;
 	vars-&gt;flow_ctrl = BNX2X_FLOW_CTRL_NONE;
 	if (phy-&gt;req_flow_ctrl != BNX2X_FLOW_CTRL_AUTO) {
<span class="p_del">-		/* Update the advertised flow-controled of LD/LP in AN */</span>
<span class="p_add">+		/* Update the advertised flow-controlled of LD/LP in AN */</span>
 		if (phy-&gt;req_line_speed == SPEED_AUTO_NEG)
 			bnx2x_ext_phy_update_adv_fc(phy, params, vars);
 		/* But set the flow-control result as the requested one */
<span class="p_chunk">@@ -3749,7 +3749,7 @@</span> <span class="p_context"> static void bnx2x_warpcore_enable_AN_KR(struct bnx2x_phy *phy,</span>
 		{MDIO_WC_DEVAD, MDIO_WC_REG_CL72_USERB0_CL72_TX_FIR_TAP, 0},
 	};
 	DP(NETIF_MSG_LINK, &quot;Enable Auto Negotiation for KR\n&quot;);
<span class="p_del">-	/* Set to default registers that may be overriden by 10G force */</span>
<span class="p_add">+	/* Set to default registers that may be overridden by 10G force */</span>
 	for (i = 0; i &lt; ARRAY_SIZE(reg_set); i++)
 		bnx2x_cl45_write(bp, phy, reg_set[i].devad, reg_set[i].reg,
 				 reg_set[i].val);
<span class="p_chunk">@@ -5431,7 +5431,7 @@</span> <span class="p_context"> static void bnx2x_flow_ctrl_resolve(struct bnx2x_phy *phy,</span>
 
 	/* Resolve from gp_status in case of AN complete and not sgmii */
 	if (phy-&gt;req_flow_ctrl != BNX2X_FLOW_CTRL_AUTO) {
<span class="p_del">-		/* Update the advertised flow-controled of LD/LP in AN */</span>
<span class="p_add">+		/* Update the advertised flow-controlled of LD/LP in AN */</span>
 		if (phy-&gt;req_line_speed == SPEED_AUTO_NEG)
 			bnx2x_update_adv_fc(phy, params, vars, gp_status);
 		/* But set the flow-control result as the requested one */
<span class="p_chunk">@@ -6963,7 +6963,7 @@</span> <span class="p_context"> int bnx2x_link_update(struct link_params *params, struct link_vars *vars)</span>
 			 * hence its link is expected to be down
 			 * - SECOND_PHY means that first phy should not be able
 			 * to link up by itself (using configuration)
<span class="p_del">-			 * - DEFAULT should be overriden during initialiazation</span>
<span class="p_add">+			 * - DEFAULT should be overridden during initialization</span>
 			 */
 				DP(NETIF_MSG_LINK, &quot;Invalid link indication&quot;
 					   &quot;mpc=0x%x. DISABLING LINK !!!\n&quot;,
<span class="p_header">diff --git a/drivers/net/ethernet/chelsio/cxgb4vf/sge.c b/drivers/net/ethernet/chelsio/cxgb4vf/sge.c</span>
<span class="p_header">index c8fd4f8..1788829 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/chelsio/cxgb4vf/sge.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/chelsio/cxgb4vf/sge.c</span>
<span class="p_chunk">@@ -2191,7 +2191,7 @@</span> <span class="p_context"> static void __iomem *bar2_address(struct adapter *adapter,</span>
  *	@rspq: pointer to to the new rxq&#39;s Response Queue to be filled in
  *	@iqasynch: if 0, a normal rspq; if 1, an asynchronous event queue
  *	@dev: the network device associated with the new rspq
<span class="p_del">- *	@intr_dest: MSI-X vector index (overriden in MSI mode)</span>
<span class="p_add">+ *	@intr_dest: MSI-X vector index (overridden in MSI mode)</span>
  *	@fl: pointer to the new rxq&#39;s Free List to be filled in
  *	@hnd: the interrupt handler to invoke for the rspq
  */
<span class="p_header">diff --git a/drivers/net/ethernet/emulex/benet/be_cmds.h b/drivers/net/ethernet/emulex/benet/be_cmds.h</span>
<span class="p_header">index 0d6be22..38469eaf 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/emulex/benet/be_cmds.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/emulex/benet/be_cmds.h</span>
<span class="p_chunk">@@ -2067,7 +2067,7 @@</span> <span class="p_context"> struct be_cmd_resp_get_stats_v2 {</span>
 	struct be_hw_stats_v2 hw_stats;
 };
 
<span class="p_del">-/************** get fat capabilites *******************/</span>
<span class="p_add">+/************** get fat capabilities *******************/</span>
 #define MAX_MODULES 27
 #define MAX_MODES 4
 #define MODE_UART 0
<span class="p_header">diff --git a/drivers/net/ethernet/freescale/fman/mac.c b/drivers/net/ethernet/freescale/fman/mac.c</span>
<span class="p_header">index e33d9d2..fd2f450 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/freescale/fman/mac.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/freescale/fman/mac.c</span>
<span class="p_chunk">@@ -933,7 +933,7 @@</span> <span class="p_context"> static int mac_probe(struct platform_device *_of_dev)</span>
 	/* pause frame autonegotiation enabled */
 	mac_dev-&gt;autoneg_pause = true;
 
<span class="p_del">-	/* By intializing the values to false, force FMD to enable PAUSE frames</span>
<span class="p_add">+	/* By initializing the values to false, force FMD to enable PAUSE frames</span>
 	 * on RX and TX
 	 */
 	mac_dev-&gt;rx_pause_req = true;
<span class="p_header">diff --git a/drivers/net/ethernet/hp/hp100.c b/drivers/net/ethernet/hp/hp100.c</span>
<span class="p_header">index 631dbc7..fbad3c3 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/hp/hp100.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/hp/hp100.c</span>
<span class="p_chunk">@@ -2465,7 +2465,7 @@</span> <span class="p_context"> static int hp100_sense_lan(struct net_device *dev)</span>
 
 	if (val_10 &amp; HP100_AUI_ST) {	/* have we BNC or AUI onboard? */
 		/*
<span class="p_del">-		 * This can be overriden by dos utility, so if this has no effect,</span>
<span class="p_add">+		 * This can be overridden by dos utility, so if this has no effect,</span>
 		 * perhaps you need to download that utility from HP and set card
 		 * back to &quot;auto detect&quot;.
 		 */
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c</span>
<span class="p_header">index 6fcbf76..8f7dd02 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c</span>
<span class="p_chunk">@@ -833,9 +833,7 @@</span> <span class="p_context"> static void i40e_free_vf_res(struct i40e_vf *vf)</span>
 		wr32(hw, reg_idx, reg);
 		i40e_flush(hw);
 	}
<span class="p_del">-	/* reset some of the state varibles keeping</span>
<span class="p_del">-	 * track of the resources</span>
<span class="p_del">-	 */</span>
<span class="p_add">+	/* reset some of the state variables keeping track of the resources */</span>
 	vf-&gt;num_queue_pairs = 0;
 	vf-&gt;vf_states = 0;
 	clear_bit(I40E_VF_STAT_INIT, &amp;vf-&gt;vf_states);
<span class="p_header">diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_header">index 942a89f..b9acd49 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_chunk">@@ -1236,7 +1236,7 @@</span> <span class="p_context"> static int igb_alloc_q_vector(struct igb_adapter *adapter,</span>
 	/* initialize pointer to rings */
 	ring = q_vector-&gt;ring;
 
<span class="p_del">-	/* intialize ITR */</span>
<span class="p_add">+	/* initialize ITR */</span>
 	if (rxr_count) {
 		/* rx or rx/tx vector */
 		if (!adapter-&gt;rx_itr_setting || adapter-&gt;rx_itr_setting &gt; 3)
<span class="p_header">diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c</span>
<span class="p_header">index bcdc884..8b7e627 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c</span>
<span class="p_chunk">@@ -862,7 +862,7 @@</span> <span class="p_context"> static int ixgbe_alloc_q_vector(struct ixgbe_adapter *adapter,</span>
 	/* initialize pointer to rings */
 	ring = q_vector-&gt;ring;
 
<span class="p_del">-	/* intialize ITR */</span>
<span class="p_add">+	/* initialize ITR */</span>
 	if (txr_count &amp;&amp; !rxr_count) {
 		/* tx only vector */
 		if (adapter-&gt;tx_itr_setting == 1)
<span class="p_header">diff --git a/drivers/net/ethernet/micrel/ksz884x.c b/drivers/net/ethernet/micrel/ksz884x.c</span>
<span class="p_header">index 280e761..44dd85e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/micrel/ksz884x.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/micrel/ksz884x.c</span>
<span class="p_chunk">@@ -1242,7 +1242,7 @@</span> <span class="p_context"> struct ksz_port_info {</span>
  * @tx_cfg:		Cached transmit control settings.
  * @rx_cfg:		Cached receive control settings.
  * @intr_mask:		Current interrupt mask.
<span class="p_del">- * @intr_set:		Current interrup set.</span>
<span class="p_add">+ * @intr_set:		Current interrupt set.</span>
  * @intr_blocked:	Interrupt blocked.
  * @rx_desc_info:	Receive descriptor information.
  * @tx_desc_info:	Transmit descriptor information.
<span class="p_chunk">@@ -1251,10 +1251,10 @@</span> <span class="p_context"> struct ksz_port_info {</span>
  * @tx_size:		Transmit data size.  Used for TX optimization.
  * 			The maximum is defined by MAX_TX_HELD_SIZE.
  * @perm_addr:		Permanent MAC address.
<span class="p_del">- * @override_addr:	Overrided MAC address.</span>
<span class="p_add">+ * @override_addr:	Overridden MAC address.</span>
  * @address:		Additional MAC address entries.
  * @addr_list_size:	Additional MAC address list size.
<span class="p_del">- * @mac_override:	Indication of MAC address overrided.</span>
<span class="p_add">+ * @mac_override:	Indication of MAC address overridden.</span>
  * @promiscuous:	Counter to keep track of promiscuous mode set.
  * @all_multi:		Counter to keep track of all multicast mode set.
  * @multi_list:		Multicast address entries.
<span class="p_chunk">@@ -4042,7 +4042,7 @@</span> <span class="p_context"> static int empty_addr(u8 *addr)</span>
  * @hw: 	The hardware instance.
  *
  * This routine programs the MAC address of the hardware when the address is
<span class="p_del">- * overrided.</span>
<span class="p_add">+ * overridden.</span>
  */
 static void hw_set_addr(struct ksz_hw *hw)
 {
<span class="p_chunk">@@ -7034,7 +7034,7 @@</span> <span class="p_context"> static int pcidev_init(struct pci_dev *pdev, const struct pci_device_id *id)</span>
 	if (macaddr[0] != &#39;:&#39;)
 		get_mac_addr(hw_priv, macaddr, MAIN_PORT);
 
<span class="p_del">-	/* Read MAC address and initialize override address if not overrided. */</span>
<span class="p_add">+	/* Read MAC address and initialize override address if not overridden. */</span>
 	hw_read_addr(hw);
 
 	/* Multiple device interfaces mode requires a second MAC address. */
<span class="p_header">diff --git a/drivers/net/ethernet/nuvoton/w90p910_ether.c b/drivers/net/ethernet/nuvoton/w90p910_ether.c</span>
<span class="p_header">index 87b7b81..712d8bc 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/nuvoton/w90p910_ether.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/nuvoton/w90p910_ether.c</span>
<span class="p_chunk">@@ -751,7 +751,7 @@</span> <span class="p_context"> static void netdev_rx(struct net_device *dev)</span>
 				dev_err(&amp;pdev-&gt;dev, &quot;rx crc err\n&quot;);
 				ether-&gt;stats.rx_crc_errors++;
 			} else if (status &amp; RXDS_ALIE) {
<span class="p_del">-				dev_err(&amp;pdev-&gt;dev, &quot;rx aligment err\n&quot;);</span>
<span class="p_add">+				dev_err(&amp;pdev-&gt;dev, &quot;rx alignment err\n&quot;);</span>
 				ether-&gt;stats.rx_frame_errors++;
 			} else if (status &amp; RXDS_PTLE) {
 				dev_err(&amp;pdev-&gt;dev, &quot;rx longer err\n&quot;);
<span class="p_header">diff --git a/drivers/net/ethernet/qlogic/qed/qed_vf.c b/drivers/net/ethernet/qlogic/qed/qed_vf.c</span>
<span class="p_header">index 9b780b3..2e75f20 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/qlogic/qed/qed_vf.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/qlogic/qed/qed_vf.c</span>
<span class="p_chunk">@@ -268,7 +268,8 @@</span> <span class="p_context"> int qed_vf_hw_prepare(struct qed_hwfn *p_hwfn)</span>
 	struct qed_vf_iov *p_iov;
 	u32 reg;
 
<span class="p_del">-	/* Set number of hwfns - might be overriden once leading hwfn learns</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Set number of hwfns - might be overridden once leading hwfn learns</span>
 	 * actual configuration from PF.
 	 */
 	if (IS_LEAD_HWFN(p_hwfn))
<span class="p_header">diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic.h b/drivers/net/ethernet/qlogic/qlcnic/qlcnic.h</span>
<span class="p_header">index 49bad00..cc7a5df3 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic.h</span>
<span class="p_chunk">@@ -912,7 +912,7 @@</span> <span class="p_context"> struct qlcnic_mac_vlan_list {</span>
 
 #define QLCNIC_LRO_REQUEST_CLEANUP	4
 
<span class="p_del">-/* Capabilites received */</span>
<span class="p_add">+/* Capabilities received */</span>
 #define QLCNIC_FW_CAPABILITY_TSO		BIT_1
 #define QLCNIC_FW_CAPABILITY_BDG		BIT_8
 #define QLCNIC_FW_CAPABILITY_FVLANTX		BIT_9
<span class="p_header">diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c</span>
<span class="p_header">index bdbcd2b..d77845e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c</span>
<span class="p_chunk">@@ -178,7 +178,7 @@</span> <span class="p_context"> const u32 qlcnic_83xx_reg_tbl[] = {</span>
 	0x3540,		/* Device state, DRV_REG1 */
 	0x3544,		/* Driver state, DRV_REG2 */
 	0x3548,		/* Driver scratch, DRV_REG3 */
<span class="p_del">-	0x354C,		/* Device partiton info, DRV_REG4 */</span>
<span class="p_add">+	0x354C,		/* Device partition info, DRV_REG4 */</span>
 	0x3524,		/* Driver IDC ver, DRV_REG5 */
 	0x3550,		/* FW_VER_MAJOR */
 	0x3554,		/* FW_VER_MINOR */
<span class="p_header">diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c</span>
<span class="p_header">index 3ebef27..4f8c823 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c</span>
<span class="p_chunk">@@ -667,7 +667,7 @@</span> <span class="p_context"> static int qlcnic_max_rings(struct qlcnic_adapter *adapter, u8 ring_cnt,</span>
 
 void qlcnic_set_tx_ring_count(struct qlcnic_adapter *adapter, u8 tx_cnt)
 {
<span class="p_del">-	/* 83xx adapter does not have max_tx_rings intialized in probe */</span>
<span class="p_add">+	/* 83xx adapter does not have max_tx_rings initialized in probe */</span>
 	if (adapter-&gt;max_tx_rings)
 		adapter-&gt;drv_tx_rings = qlcnic_max_rings(adapter, tx_cnt,
 							 QLCNIC_TX_QUEUE);
<span class="p_chunk">@@ -677,7 +677,7 @@</span> <span class="p_context"> void qlcnic_set_tx_ring_count(struct qlcnic_adapter *adapter, u8 tx_cnt)</span>
 
 void qlcnic_set_sds_ring_count(struct qlcnic_adapter *adapter, u8 rx_cnt)
 {
<span class="p_del">-	/* 83xx adapter does not have max_sds_rings intialized in probe */</span>
<span class="p_add">+	/* 83xx adapter does not have max_sds_rings initialized in probe */</span>
 	if (adapter-&gt;max_sds_rings)
 		adapter-&gt;drv_sds_rings = qlcnic_max_rings(adapter, rx_cnt,
 							  QLCNIC_RX_QUEUE);
<span class="p_header">diff --git a/drivers/net/ethernet/qlogic/qlge/qlge.h b/drivers/net/ethernet/qlogic/qlge/qlge.h</span>
<span class="p_header">index 6d31f92..84ac50f 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/qlogic/qlge/qlge.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/qlogic/qlge/qlge.h</span>
<span class="p_chunk">@@ -1162,8 +1162,8 @@</span> <span class="p_context"> struct ob_mac_tso_iocb_rsp {</span>
 struct ib_mac_iocb_rsp {
 	u8 opcode;		/* 0x20 */
 	u8 flags1;
<span class="p_del">-#define IB_MAC_IOCB_RSP_OI	0x01	/* Overide intr delay */</span>
<span class="p_del">-#define IB_MAC_IOCB_RSP_I	0x02	/* Disble Intr Generation */</span>
<span class="p_add">+#define IB_MAC_IOCB_RSP_OI	0x01	/* Override intr delay */</span>
<span class="p_add">+#define IB_MAC_IOCB_RSP_I	0x02	/* Disable Intr Generation */</span>
 #define IB_MAC_CSUM_ERR_MASK 0x1c	/* A mask to use for csum errs */
 #define IB_MAC_IOCB_RSP_TE	0x04	/* Checksum error */
 #define IB_MAC_IOCB_RSP_NU	0x08	/* No checksum rcvd */
<span class="p_header">diff --git a/drivers/net/ethernet/samsung/sxgbe/sxgbe_main.c b/drivers/net/ethernet/samsung/sxgbe/sxgbe_main.c</span>
<span class="p_header">index ea44a24..fecaaea 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/samsung/sxgbe/sxgbe_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/samsung/sxgbe/sxgbe_main.c</span>
<span class="p_chunk">@@ -387,7 +387,7 @@</span> <span class="p_context"> static void sxgbe_free_rx_buffers(struct net_device *dev,</span>
 /**
  * init_tx_ring - init the TX descriptor ring
  * @dev: net device structure
<span class="p_del">- * @tx_ring: ring to be intialised</span>
<span class="p_add">+ * @tx_ring: ring to be initialised</span>
  * @tx_rsize: ring size
  * Description:  this function initializes the DMA TX descriptor
  */
<span class="p_chunk">@@ -440,7 +440,7 @@</span> <span class="p_context"> dmamem_err:</span>
 /**
  * free_rx_ring - free the RX descriptor ring
  * @dev: net device structure
<span class="p_del">- * @rx_ring: ring to be intialised</span>
<span class="p_add">+ * @rx_ring: ring to be initialised</span>
  * @rx_rsize: ring size
  * Description:  this function initializes the DMA RX descriptor
  */
<span class="p_chunk">@@ -456,7 +456,7 @@</span> <span class="p_context"> static void free_rx_ring(struct device *dev, struct sxgbe_rx_queue *rx_ring,</span>
 /**
  * init_rx_ring - init the RX descriptor ring
  * @dev: net device structure
<span class="p_del">- * @rx_ring: ring to be intialised</span>
<span class="p_add">+ * @rx_ring: ring to be initialised</span>
  * @rx_rsize: ring size
  * Description:  this function initializes the DMA RX descriptor
  */
<span class="p_chunk">@@ -542,7 +542,7 @@</span> <span class="p_context"> err_free_dma_rx:</span>
 /**
  * free_tx_ring - free the TX descriptor ring
  * @dev: net device structure
<span class="p_del">- * @tx_ring: ring to be intialised</span>
<span class="p_add">+ * @tx_ring: ring to be initialised</span>
  * @tx_rsize: ring size
  * Description:  this function initializes the DMA TX descriptor
  */
<span class="p_header">diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c</span>
<span class="p_header">index 4c8c60a..0b841e9 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c</span>
<span class="p_chunk">@@ -216,7 +216,7 @@</span> <span class="p_context"> static inline u32 stmmac_rx_dirty(struct stmmac_priv *priv)</span>
 /**
  * stmmac_hw_fix_mac_speed - callback for speed selection
  * @priv: driver private structure
<span class="p_del">- * Description: on some platforms (e.g. ST), some HW system configuraton</span>
<span class="p_add">+ * Description: on some platforms (e.g. ST), some HW system configuration</span>
  * registers have to be set according to the link speed negotiated.
  */
 static inline void stmmac_hw_fix_mac_speed(struct stmmac_priv *priv)
<span class="p_header">diff --git a/drivers/net/ethernet/tehuti/tehuti.c b/drivers/net/ethernet/tehuti/tehuti.c</span>
<span class="p_header">index 7108c68..d4c7e39 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/tehuti/tehuti.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/tehuti/tehuti.c</span>
<span class="p_chunk">@@ -1201,7 +1201,7 @@</span> <span class="p_context"> static void bdx_recycle_skb(struct bdx_priv *priv, struct rxd_desc *rxdd)</span>
  * @budget: maximum number of packets to receive
  */
 
<span class="p_del">-/* TBD: replace memcpy func call by explicite inline asm */</span>
<span class="p_add">+/* TBD: replace memcpy func call by explicit inline asm */</span>
 
 static int bdx_rx_receive(struct bdx_priv *priv, struct rxd_fifo *f, int budget)
 {
<span class="p_chunk">@@ -1342,7 +1342,7 @@</span> <span class="p_context"> static void print_rxfd(struct rxf_desc *rxfd)</span>
  * 1) TX Free Fifo - TXF - holds ack descriptors for sent packets
  * 2) TX Data Fifo - TXD - holds descriptors of full buffers.
  *
<span class="p_del">- * Currently NIC supports TSO, checksuming and gather DMA</span>
<span class="p_add">+ * Currently NIC supports TSO, checksumming and gather DMA</span>
  * UFO and IP fragmentation is on the way
  *
  * RX SW Data Structures
<span class="p_header">diff --git a/drivers/net/fddi/skfp/cfm.c b/drivers/net/fddi/skfp/cfm.c</span>
<span class="p_header">index e395ace..1bcc6a7 100644</span>
<span class="p_header">--- a/drivers/net/fddi/skfp/cfm.c</span>
<span class="p_header">+++ b/drivers/net/fddi/skfp/cfm.c</span>
<span class="p_chunk">@@ -21,7 +21,7 @@</span> <span class="p_context"></span>
 */
 
 /*
<span class="p_del">- *	Hardware independent state machine implemantation</span>
<span class="p_add">+ *	Hardware independent state machine implementation</span>
  *	The following external SMT functions are referenced :
  *
  *		queue_event()
<span class="p_header">diff --git a/drivers/net/fddi/skfp/ecm.c b/drivers/net/fddi/skfp/ecm.c</span>
<span class="p_header">index 47d922c..cbee3d6 100644</span>
<span class="p_header">--- a/drivers/net/fddi/skfp/ecm.c</span>
<span class="p_header">+++ b/drivers/net/fddi/skfp/ecm.c</span>
<span class="p_chunk">@@ -21,7 +21,7 @@</span> <span class="p_context"></span>
 */
 
 /*
<span class="p_del">- * Hardware independent state machine implemantation</span>
<span class="p_add">+ * Hardware independent state machine implementation</span>
  * The following external SMT functions are referenced :
  *
  * 		queue_event()
<span class="p_header">diff --git a/drivers/net/fddi/skfp/pcmplc.c b/drivers/net/fddi/skfp/pcmplc.c</span>
<span class="p_header">index 88d02d0..c56f26e 100644</span>
<span class="p_header">--- a/drivers/net/fddi/skfp/pcmplc.c</span>
<span class="p_header">+++ b/drivers/net/fddi/skfp/pcmplc.c</span>
<span class="p_chunk">@@ -20,7 +20,7 @@</span> <span class="p_context"></span>
 */
 
 /*
<span class="p_del">- * Hardware independent state machine implemantation</span>
<span class="p_add">+ * Hardware independent state machine implementation</span>
  * The following external SMT functions are referenced :
  *
  * 		queue_event()
<span class="p_header">diff --git a/drivers/net/fddi/skfp/rmt.c b/drivers/net/fddi/skfp/rmt.c</span>
<span class="p_header">index ef8d567..a88f0b8 100644</span>
<span class="p_header">--- a/drivers/net/fddi/skfp/rmt.c</span>
<span class="p_header">+++ b/drivers/net/fddi/skfp/rmt.c</span>
<span class="p_chunk">@@ -20,7 +20,7 @@</span> <span class="p_context"></span>
 */
 
 /*
<span class="p_del">- * Hardware independent state machine implemantation</span>
<span class="p_add">+ * Hardware independent state machine implementation</span>
  * The following external SMT functions are referenced :
  *
  * 		queue_event()
<span class="p_header">diff --git a/drivers/net/irda/donauboe.c b/drivers/net/irda/donauboe.c</span>
<span class="p_header">index b337e6d..5311053 100644</span>
<span class="p_header">--- a/drivers/net/irda/donauboe.c</span>
<span class="p_header">+++ b/drivers/net/irda/donauboe.c</span>
<span class="p_chunk">@@ -1281,7 +1281,7 @@</span> <span class="p_context"> dumpbufs(self-&gt;rx_bufs[self-&gt;rxs],len,&#39;&lt;&#39;);</span>
             /* TODO: =========================================== */
             /*  if OBOE_CTL_RX_LENGTH, our buffers are too small */
             /* (MIR or FIR) data is lost. */
<span class="p_del">-            /* (SIR) data is splitted in several slots. */</span>
<span class="p_add">+            /* (SIR) data is split in several slots. */</span>
             /* we have to join all the received buffers received */
             /*in a large buffer before checking CRC. */
 		    pr_debug(&quot;%s.err:%x(%x)\n&quot;, __func__
<span class="p_header">diff --git a/drivers/net/usb/cdc_ncm.c b/drivers/net/usb/cdc_ncm.c</span>
<span class="p_header">index 877c951..163673c 100644</span>
<span class="p_header">--- a/drivers/net/usb/cdc_ncm.c</span>
<span class="p_header">+++ b/drivers/net/usb/cdc_ncm.c</span>
<span class="p_chunk">@@ -653,7 +653,8 @@</span> <span class="p_context"> static int cdc_ncm_setup(struct usbnet *dev)</span>
 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev-&gt;data[0];
 	u32 def_rx, def_tx;
 
<span class="p_del">-	/* be conservative when selecting intial buffer size to</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * be conservative when selecting initial buffer size to</span>
 	 * increase the number of hosts this will work for
 	 */
 	def_rx = min_t(u32, CDC_NCM_NTB_DEF_SIZE_RX,
<span class="p_header">diff --git a/drivers/net/usb/kalmia.c b/drivers/net/usb/kalmia.c</span>
<span class="p_header">index 5662bab..772e3ee 100644</span>
<span class="p_header">--- a/drivers/net/usb/kalmia.c</span>
<span class="p_header">+++ b/drivers/net/usb/kalmia.c</span>
<span class="p_chunk">@@ -343,7 +343,7 @@</span> <span class="p_context"> static const struct driver_info kalmia_info = {</span>
 static const struct usb_device_id products[] = {
 	/* The unswitched USB ID, to get the module auto loaded: */
 	{ USB_DEVICE(0x04e8, 0x689a) },
<span class="p_del">-	/* The stick swithed into modem (by e.g. usb_modeswitch): */</span>
<span class="p_add">+	/* The stick switched into modem (by e.g. usb_modeswitch): */</span>
 	{ USB_DEVICE(0x04e8, 0x6889),
 		.driver_info = (unsigned long) &amp;kalmia_info, },
 	{ /* EMPTY == end of list */} };
<span class="p_header">diff --git a/drivers/net/wimax/i2400m/driver.c b/drivers/net/wimax/i2400m/driver.c</span>
<span class="p_header">index 9c78090..c5457dc 100644</span>
<span class="p_header">--- a/drivers/net/wimax/i2400m/driver.c</span>
<span class="p_header">+++ b/drivers/net/wimax/i2400m/driver.c</span>
<span class="p_chunk">@@ -852,7 +852,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(i2400m_reset);</span>
  *
  * Returns: 0 if ok, &lt; 0 errno code on error.
  *
<span class="p_del">- * Sets up basic device comunication infrastructure, boots the ROM to</span>
<span class="p_add">+ * Sets up basic device communication infrastructure, boots the ROM to</span>
  * read the MAC address, registers with the WiMAX and network stacks
  * and then brings up the device.
  */
<span class="p_header">diff --git a/drivers/net/wimax/i2400m/usb-fw.c b/drivers/net/wimax/i2400m/usb-fw.c</span>
<span class="p_header">index e74664b..502c346 100644</span>
<span class="p_header">--- a/drivers/net/wimax/i2400m/usb-fw.c</span>
<span class="p_header">+++ b/drivers/net/wimax/i2400m/usb-fw.c</span>
<span class="p_chunk">@@ -237,7 +237,7 @@</span> <span class="p_context"> void __i2400mu_bm_notif_cb(struct urb *urb)</span>
  *
  * @i2400m: device descriptor
  * @urb: urb to use
<span class="p_del">- * @completion: completion varible to complete when done</span>
<span class="p_add">+ * @completion: completion variable to complete when done</span>
  *
  * Data is always read to i2400m-&gt;bm_ack_buf
  */
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/wmi.h b/drivers/net/wireless/ath/ath10k/wmi.h</span>
<span class="p_header">index 3ef4688..388b389 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/wmi.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/wmi.h</span>
<span class="p_chunk">@@ -55,7 +55,7 @@</span> <span class="p_context"></span>
  *    type.
  *
  * 6. Comment each parameter part of the WMI command/event structure by
<span class="p_del">- *    using the 2 stars at the begining of C comment instead of one star to</span>
<span class="p_add">+ *    using the 2 stars at the beginning of C comment instead of one star to</span>
  *    enable HTML document generation using Doxygen.
  *
  */
<span class="p_chunk">@@ -2082,7 +2082,7 @@</span> <span class="p_context"> struct wmi_resource_config {</span>
 	 * In offload mode target supports features like WOW, chatter and
 	 * other protocol offloads. In order to support them some
 	 * functionalities like reorder buffering, PN checking need to be
<span class="p_del">-	 * done in target. This determines maximum number of peers suported</span>
<span class="p_add">+	 * done in target. This determines maximum number of peers supported</span>
 	 * by target in offload mode
 	 */
 	__le32 num_offload_peers;
<span class="p_chunk">@@ -2263,7 +2263,7 @@</span> <span class="p_context"> struct wmi_resource_config {</span>
 	 * Max. number of Tx fragments per MSDU
 	 *  This parameter controls the max number of Tx fragments per MSDU.
 	 *  This is sent by the target as part of the WMI_SERVICE_READY event
<span class="p_del">-	 *  and is overriden by the OS shim as required.</span>
<span class="p_add">+	 *  and is overridden by the OS shim as required.</span>
 	 */
 	__le32 max_frag_entries;
 } __packed;
<span class="p_chunk">@@ -2445,7 +2445,7 @@</span> <span class="p_context"> struct wmi_resource_config_10x {</span>
 	 * Max. number of Tx fragments per MSDU
 	 *  This parameter controls the max number of Tx fragments per MSDU.
 	 *  This is sent by the target as part of the WMI_SERVICE_READY event
<span class="p_del">-	 *  and is overriden by the OS shim as required.</span>
<span class="p_add">+	 *  and is overridden by the OS shim as required.</span>
 	 */
 	__le32 max_frag_entries;
 } __packed;
<span class="p_chunk">@@ -2739,7 +2739,7 @@</span> <span class="p_context"> struct wmi_init_cmd {</span>
 	struct wmi_host_mem_chunks mem_chunks;
 } __packed;
 
<span class="p_del">-/* _10x stucture is from 10.X FW API */</span>
<span class="p_add">+/* _10x structure is from 10.X FW API */</span>
 struct wmi_init_cmd_10x {
 	struct wmi_resource_config_10x resource_config;
 	struct wmi_host_mem_chunks mem_chunks;
<span class="p_chunk">@@ -3962,10 +3962,10 @@</span> <span class="p_context"> struct wmi_pdev_stats_tx {</span>
 	/* illegal rate phy errors  */
 	__le32 illgl_rate_phy_err;
 
<span class="p_del">-	/* wal pdev continous xretry */</span>
<span class="p_add">+	/* wal pdev continuous xretry */</span>
 	__le32 pdev_cont_xretry;
 
<span class="p_del">-	/* wal pdev continous xretry */</span>
<span class="p_add">+	/* wal pdev continuous xretry */</span>
 	__le32 pdev_tx_timeout;
 
 	/* wal pdev resets  */
<span class="p_chunk">@@ -4456,9 +4456,9 @@</span> <span class="p_context"> struct wmi_vdev_start_request_cmd {</span>
 	__le32 flags;
 	/* ssid field. Only valid for AP/GO/IBSS/BTAmp VDEV type. */
 	struct wmi_ssid ssid;
<span class="p_del">-	/* beacon/probe reponse xmit rate. Applicable for SoftAP. */</span>
<span class="p_add">+	/* beacon/probe response xmit rate. Applicable for SoftAP. */</span>
 	__le32 bcn_tx_rate;
<span class="p_del">-	/* beacon/probe reponse xmit power. Applicable for SoftAP. */</span>
<span class="p_add">+	/* beacon/probe response xmit power. Applicable for SoftAP. */</span>
 	__le32 bcn_tx_power;
 	/* number of p2p NOA descriptor(s) from scan entry */
 	__le32 num_noa_descriptors;
<span class="p_chunk">@@ -4686,7 +4686,7 @@</span> <span class="p_context"> enum wmi_vdev_param {</span>
 	WMI_VDEV_PARAM_BEACON_INTERVAL,
 	/* Listen interval in TUs */
 	WMI_VDEV_PARAM_LISTEN_INTERVAL,
<span class="p_del">-	/* muticast rate in Mbps */</span>
<span class="p_add">+	/* multicast rate in Mbps */</span>
 	WMI_VDEV_PARAM_MULTICAST_RATE,
 	/* management frame rate in Mbps */
 	WMI_VDEV_PARAM_MGMT_TX_RATE,
<span class="p_chunk">@@ -4817,7 +4817,7 @@</span> <span class="p_context"> enum wmi_10x_vdev_param {</span>
 	WMI_10X_VDEV_PARAM_BEACON_INTERVAL,
 	/* Listen interval in TUs */
 	WMI_10X_VDEV_PARAM_LISTEN_INTERVAL,
<span class="p_del">-	/* muticast rate in Mbps */</span>
<span class="p_add">+	/* multicast rate in Mbps */</span>
 	WMI_10X_VDEV_PARAM_MULTICAST_RATE,
 	/* management frame rate in Mbps */
 	WMI_10X_VDEV_PARAM_MGMT_TX_RATE,
<span class="p_chunk">@@ -5062,7 +5062,7 @@</span> <span class="p_context"> struct wmi_vdev_simple_event {</span>
 } __packed;
 
 /* VDEV start response status codes */
<span class="p_del">-/* VDEV succesfully started */</span>
<span class="p_add">+/* VDEV successfully started */</span>
 #define WMI_INIFIED_VDEV_START_RESPONSE_STATUS_SUCCESS	0x0
 
 /* requested VDEV not found */
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath6kl/main.c b/drivers/net/wireless/ath/ath6kl/main.c</span>
<span class="p_header">index 1af3fed..bb8dc89 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath6kl/main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath6kl/main.c</span>
<span class="p_chunk">@@ -577,7 +577,7 @@</span> <span class="p_context"> static int ath6kl_commit_ch_switch(struct ath6kl_vif *vif, u16 channel)</span>
 	switch (vif-&gt;nw_type) {
 	case AP_NETWORK:
 		/*
<span class="p_del">-		 * reconfigure any saved RSN IE capabilites in the beacon /</span>
<span class="p_add">+		 * reconfigure any saved RSN IE capabilities in the beacon /</span>
 		 * probe response to stay in sync with the supplicant.
 		 */
 		if (vif-&gt;rsn_capab &amp;&amp;
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/ani.c b/drivers/net/wireless/ath/ath9k/ani.c</span>
<span class="p_header">index 815efe9..5214dd7 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/ani.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/ani.c</span>
<span class="p_chunk">@@ -59,13 +59,13 @@</span> <span class="p_context"> static const struct ani_ofdm_level_entry ofdm_level_table[] = {</span>
 /*
  * MRC (Maximal Ratio Combining) has always been used with multi-antenna ofdm.
  * With OFDM for single stream you just add up all antenna inputs, you&#39;re
<span class="p_del">- * only interested in what you get after FFT. Signal aligment is also not</span>
<span class="p_add">+ * only interested in what you get after FFT. Signal alignment is also not</span>
  * required for OFDM because any phase difference adds up in the frequency
  * domain.
  *
  * MRC requires extra work for use with CCK. You need to align the antenna
  * signals from the different antenna before you can add the signals together.
<span class="p_del">- * You need aligment of signals as CCK is in time domain, so addition can cancel</span>
<span class="p_add">+ * You need alignment of signals as CCK is in time domain, so addition can cancel</span>
  * your signal completely if phase is 180 degrees (think of adding sine waves).
  * You also need to remove noise before the addition and this is where ANI
  * MRC CCK comes into play. One of the antenna inputs may be stronger but
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c</span>
<span class="p_header">index 05f22ff..c813a76 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c</span>
<span class="p_chunk">@@ -1025,7 +1025,7 @@</span> <span class="p_context"> static int brcmf_chip_setup(struct brcmf_chip_priv *chip)</span>
 	cc = list_first_entry(&amp;chip-&gt;cores, struct brcmf_core_priv, list);
 	base = cc-&gt;pub.base;
 
<span class="p_del">-	/* get chipcommon capabilites */</span>
<span class="p_add">+	/* get chipcommon capabilities */</span>
 	pub-&gt;cc_caps = chip-&gt;ops-&gt;read32(chip-&gt;ctx,
 					 CORE_CC_REG(base, capabilities));
 	pub-&gt;cc_caps_ext = chip-&gt;ops-&gt;read32(chip-&gt;ctx,
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c</span>
<span class="p_header">index 66f942f..bd95a55 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c</span>
<span class="p_chunk">@@ -660,7 +660,7 @@</span> <span class="p_context"> static s32 brcmf_p2p_escan(struct brcmf_p2p_info *p2p, u32 num_chans,</span>
 	switch (search_state) {
 	case WL_P2P_DISC_ST_SEARCH:
 		/*
<span class="p_del">-		 * If we in SEARCH STATE, we don&#39;t need to set SSID explictly</span>
<span class="p_add">+		 * If we in SEARCH STATE, we don&#39;t need to set SSID explicitly</span>
 		 * because dongle use P2P WILDCARD internally by default, use
 		 * null ssid, which it is already due to kzalloc.
 		 */
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c</span>
<span class="p_header">index 3deba90..c597b25 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c</span>
<span class="p_chunk">@@ -82,7 +82,7 @@</span> <span class="p_context"> static struct brcmf_firmware_mapping brcmf_pcie_fwnames[] = {</span>
 
 #define BRCMF_PCIE_REG_MAP_SIZE			(32 * 1024)
 
<span class="p_del">-/* backplane addres space accessed by BAR0 */</span>
<span class="p_add">+/* backplane address space accessed by BAR0 */</span>
 #define	BRCMF_PCIE_BAR0_WINDOW			0x80
 #define BRCMF_PCIE_BAR0_REG_SIZE		0x1000
 #define	BRCMF_PCIE_BAR0_WRAPPERBASE		0x70
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/aiutils.c b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/aiutils.c</span>
<span class="p_header">index 5336597..b18f670 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/aiutils.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/aiutils.c</span>
<span class="p_chunk">@@ -453,7 +453,7 @@</span> <span class="p_context"> ai_buscore_setup(struct si_info *sii, struct bcma_device *cc)</span>
 	/* get chipcommon chipstatus */
 	sii-&gt;chipst = bcma_read32(cc, CHIPCREGOFFS(chipstatus));
 
<span class="p_del">-	/* get chipcommon capabilites */</span>
<span class="p_add">+	/* get chipcommon capabilities */</span>
 	sii-&gt;pub.cccaps = bcma_read32(cc, CHIPCREGOFFS(capabilities));
 
 	/* get pmu rev and caps */
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/channel.c b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/channel.c</span>
<span class="p_header">index 3a03287..936f0ac 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/channel.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/channel.c</span>
<span class="p_chunk">@@ -445,7 +445,7 @@</span> <span class="p_context"> brcms_c_channel_reg_limits(struct brcms_cm_info *wlc_cm, u16 chanspec,</span>
 
 		/*
 		 * OFDM 40 MHz SISO has the same power as the corresponding
<span class="p_del">-		 * MCS0-7 rate unless overriden by the locale specific code.</span>
<span class="p_add">+		 * MCS0-7 rate unless overridden by the locale specific code.</span>
 		 * We set this value to 0 as a flag (presumably 0 dBm isn&#39;t
 		 * a possibility) and then copy the MCS0-7 value to the 40 MHz
 		 * value if it wasn&#39;t explicitly set.
<span class="p_chunk">@@ -479,7 +479,7 @@</span> <span class="p_context"> brcms_c_channel_reg_limits(struct brcms_cm_info *wlc_cm, u16 chanspec,</span>
 
 		/*
 		 * 20 MHz has the same power as the corresponding OFDM rate
<span class="p_del">-		 * unless overriden by the locale specific code.</span>
<span class="p_add">+		 * unless overridden by the locale specific code.</span>
 		 */
 		txpwr-&gt;mcs_20_siso[i] = txpwr-&gt;ofdm[i];
 		txpwr-&gt;mcs_40_siso[i] = 0;
<span class="p_header">diff --git a/drivers/net/wireless/intel/ipw2x00/ipw2100.c b/drivers/net/wireless/intel/ipw2x00/ipw2100.c</span>
<span class="p_header">index bfa542c..1c22bba 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/ipw2x00/ipw2100.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/ipw2x00/ipw2100.c</span>
<span class="p_chunk">@@ -1238,7 +1238,7 @@</span> <span class="p_context"> static int ipw2100_get_hw_features(struct ipw2100_priv *priv)</span>
 }
 
 /*
<span class="p_del">- * Start firmware execution after power on and intialization</span>
<span class="p_add">+ * Start firmware execution after power on and initialization</span>
  * The sequence is:
  *  1. Release ARC
  *  2. Wait for f/w initialization completes;
<span class="p_chunk">@@ -1277,7 +1277,7 @@</span> <span class="p_context"> static int ipw2100_start_adapter(struct ipw2100_priv *priv)</span>
 	/* Release ARC - clear reset bit */
 	write_register(priv-&gt;net_dev, IPW_REG_RESET_REG, 0);
 
<span class="p_del">-	/* wait for f/w intialization complete */</span>
<span class="p_add">+	/* wait for f/w initialization complete */</span>
 	IPW_DEBUG_FW(&quot;Waiting for f/w initialization to complete...\n&quot;);
 	i = 5000;
 	do {
<span class="p_chunk">@@ -5652,7 +5652,7 @@</span> <span class="p_context"> static void shim__set_security(struct net_device *dev,</span>
 
 /* As a temporary work around to enable WPA until we figure out why
  * wpa_supplicant toggles the security capability of the driver, which
<span class="p_del">- * forces a disassocation with force_update...</span>
<span class="p_add">+ * forces a disassociation with force_update...</span>
  *
  *	if (force_update || !(priv-&gt;status &amp; STATUS_ASSOCIATED))*/
 	if (!(priv-&gt;status &amp; (STATUS_ASSOCIATED | STATUS_ASSOCIATING)))
<span class="p_chunk">@@ -8164,7 +8164,7 @@</span> <span class="p_context"> static struct iw_statistics *ipw2100_wx_wireless_stats(struct net_device *dev)</span>
 	/* if hw is disabled, then ipw2100_get_ordinal() can&#39;t be called.
 	 * ipw2100_wx_wireless_stats seems to be called before fw is
 	 * initialized.  STATUS_ASSOCIATED will only be set if the hw is up
<span class="p_del">-	 * and associated; if not associcated, the values are all meaningless</span>
<span class="p_add">+	 * and associated; if not associated, the values are all meaningless</span>
 	 * anyway, so set them all to NULL and INVALID */
 	if (!(priv-&gt;status &amp; STATUS_ASSOCIATED)) {
 		wstats-&gt;miss.beacon = 0;
<span class="p_header">diff --git a/drivers/net/wireless/intel/ipw2x00/ipw2200.c b/drivers/net/wireless/intel/ipw2x00/ipw2200.c</span>
<span class="p_header">index bfd6861..9a8fa31 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/ipw2x00/ipw2200.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/ipw2x00/ipw2200.c</span>
<span class="p_chunk">@@ -774,7 +774,7 @@</span> <span class="p_context"> static int ipw_get_ordinal(struct ipw_priv *priv, u32 ord, void *val, u32 * len)</span>
 		 *
 		 * This table consist of six values, each containing
 		 *     - dword containing the starting offset of the data
<span class="p_del">-		 *     - dword containing the lengh in the first 16bits</span>
<span class="p_add">+		 *     - dword containing the length in the first 16bits</span>
 		 *       and the count in the second 16bits
 		 */
 
<span class="p_chunk">@@ -3974,7 +3974,7 @@</span> <span class="p_context"> static void ipw_send_disassociate(struct ipw_priv *priv, int quiet)</span>
 		return;
 	}
 
<span class="p_del">-	IPW_DEBUG_ASSOC(&quot;Disassocation attempt from %pM &quot;</span>
<span class="p_add">+	IPW_DEBUG_ASSOC(&quot;Disassociation attempt from %pM &quot;</span>
 			&quot;on channel %d.\n&quot;,
 			priv-&gt;assoc_request.bssid,
 			priv-&gt;assoc_request.channel);
<span class="p_chunk">@@ -5196,7 +5196,7 @@</span> <span class="p_context"> static void ipw_rx_queue_restock(struct ipw_priv *priv)</span>
  * Move all used packet from rx_used to rx_free, allocating a new SKB for each.
  * Also restock the Rx queue via ipw_rx_queue_restock.
  *
<span class="p_del">- * This is called as a scheduled work item (except for during intialization)</span>
<span class="p_add">+ * This is called as a scheduled work item (except for during initialization)</span>
  */
 static void ipw_rx_queue_replenish(void *data)
 {
<span class="p_chunk">@@ -10038,7 +10038,7 @@</span> <span class="p_context"> static struct iw_statistics *ipw_get_wireless_stats(struct net_device *dev)</span>
 	/* if hw is disabled, then ipw_get_ordinal() can&#39;t be called.
 	 * netdev-&gt;get_wireless_stats seems to be called before fw is
 	 * initialized.  STATUS_ASSOCIATED will only be set if the hw is up
<span class="p_del">-	 * and associated; if not associcated, the values are all meaningless</span>
<span class="p_add">+	 * and associated; if not associated, the values are all meaningless</span>
 	 * anyway, so set them all to NULL and INVALID */
 	if (!(priv-&gt;status &amp; STATUS_ASSOCIATED)) {
 		wstats-&gt;miss.beacon = 0;
<span class="p_header">diff --git a/drivers/net/wireless/intersil/hostap/hostap_hw.c b/drivers/net/wireless/intersil/hostap/hostap_hw.c</span>
<span class="p_header">index a8a9bd8..5c2916e 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intersil/hostap/hostap_hw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intersil/hostap/hostap_hw.c</span>
<span class="p_chunk">@@ -3183,7 +3183,7 @@</span> <span class="p_context"> prism2_init_local_data(struct prism2_helper_functions *funcs, int card_idx,</span>
 	local-&gt;manual_retry_count = -1;
 	local-&gt;rts_threshold = 2347;
 	local-&gt;fragm_threshold = 2346;
<span class="p_del">-	local-&gt;rssi_to_dBm = 100; /* default; to be overriden by</span>
<span class="p_add">+	local-&gt;rssi_to_dBm = 100; /* default; to be overridden by</span>
 				   * cnfDbmAdjust, if available */
 	local-&gt;auth_algs = PRISM2_AUTH_OPEN | PRISM2_AUTH_SHARED_KEY;
 	local-&gt;sram_type = -1;
<span class="p_header">diff --git a/drivers/net/wireless/marvell/mwifiex/init.c b/drivers/net/wireless/marvell/mwifiex/init.c</span>
<span class="p_header">index 1489c90..6dedd66 100644</span>
<span class="p_header">--- a/drivers/net/wireless/marvell/mwifiex/init.c</span>
<span class="p_header">+++ b/drivers/net/wireless/marvell/mwifiex/init.c</span>
<span class="p_chunk">@@ -447,8 +447,7 @@</span> <span class="p_context"> mwifiex_adapter_cleanup(struct mwifiex_adapter *adapter)</span>
 }
 
 /*
<span class="p_del">- *  This function intializes the lock variables and</span>
<span class="p_del">- *  the list heads.</span>
<span class="p_add">+ *  This function initializes the lock variables and the list heads.</span>
  */
 int mwifiex_init_lock_list(struct mwifiex_adapter *adapter)
 {
<span class="p_header">diff --git a/drivers/net/wireless/marvell/mwifiex/wmm.c b/drivers/net/wireless/marvell/mwifiex/wmm.c</span>
<span class="p_header">index 0eb2465..f6446ec 100644</span>
<span class="p_header">--- a/drivers/net/wireless/marvell/mwifiex/wmm.c</span>
<span class="p_header">+++ b/drivers/net/wireless/marvell/mwifiex/wmm.c</span>
<span class="p_chunk">@@ -667,8 +667,9 @@</span> <span class="p_context"> void mwifiex_update_ralist_tx_pause(struct mwifiex_private *priv, u8 *mac,</span>
 	spin_unlock_irqrestore(&amp;priv-&gt;wmm.ra_list_spinlock, flags);
 }
 
<span class="p_del">-/* This function update non-tdls peer ralist tx_pause while</span>
<span class="p_del">- * tdls channel swithing</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This function updates non-tdls peer ralist tx_pause while</span>
<span class="p_add">+ * tdls channel switching</span>
  */
 void mwifiex_update_ralist_tx_pause_in_tdls_cs(struct mwifiex_private *priv,
 					       u8 *mac, u8 tx_pause)
<span class="p_chunk">@@ -1152,7 +1153,8 @@</span> <span class="p_context"> found:</span>
 	return ptr;
 }
 
<span class="p_del">-/* This functions rotates ra and bss lists so packets are picked round robin.</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This function rotates ra and bss lists so packets are picked round robin.</span>
  *
  * After a packet is successfully transmitted, rotate the ra list, so the ra
  * next to the one transmitted, will come first in the list. This way we pick
<span class="p_header">diff --git a/drivers/net/wireless/ralink/rt2x00/rt2400pci.c b/drivers/net/wireless/ralink/rt2x00/rt2400pci.c</span>
<span class="p_header">index 155f343..a57b1b2 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ralink/rt2x00/rt2400pci.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ralink/rt2x00/rt2400pci.c</span>
<span class="p_chunk">@@ -403,7 +403,7 @@</span> <span class="p_context"> static void rt2400pci_config_ant(struct rt2x00_dev *rt2x00dev,</span>
 
 	/*
 	 * We should never come here because rt2x00lib is supposed
<span class="p_del">-	 * to catch this and send us the correct antenna explicitely.</span>
<span class="p_add">+	 * to catch this and send us the correct antenna explicitly.</span>
 	 */
 	BUG_ON(ant-&gt;rx == ANTENNA_SW_DIVERSITY ||
 	       ant-&gt;tx == ANTENNA_SW_DIVERSITY);
<span class="p_header">diff --git a/drivers/net/wireless/ralink/rt2x00/rt2500pci.c b/drivers/net/wireless/ralink/rt2x00/rt2500pci.c</span>
<span class="p_header">index 2553cdd..22e4a57 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ralink/rt2x00/rt2500pci.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ralink/rt2x00/rt2500pci.c</span>
<span class="p_chunk">@@ -410,7 +410,7 @@</span> <span class="p_context"> static void rt2500pci_config_ant(struct rt2x00_dev *rt2x00dev,</span>
 
 	/*
 	 * We should never come here because rt2x00lib is supposed
<span class="p_del">-	 * to catch this and send us the correct antenna explicitely.</span>
<span class="p_add">+	 * to catch this and send us the correct antenna explicitly.</span>
 	 */
 	BUG_ON(ant-&gt;rx == ANTENNA_SW_DIVERSITY ||
 	       ant-&gt;tx == ANTENNA_SW_DIVERSITY);
<span class="p_header">diff --git a/drivers/net/wireless/ralink/rt2x00/rt2500usb.c b/drivers/net/wireless/ralink/rt2x00/rt2500usb.c</span>
<span class="p_header">index 2d64611..5ab6c6f 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ralink/rt2x00/rt2500usb.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ralink/rt2x00/rt2500usb.c</span>
<span class="p_chunk">@@ -530,7 +530,7 @@</span> <span class="p_context"> static void rt2500usb_config_ant(struct rt2x00_dev *rt2x00dev,</span>
 
 	/*
 	 * We should never come here because rt2x00lib is supposed
<span class="p_del">-	 * to catch this and send us the correct antenna explicitely.</span>
<span class="p_add">+	 * to catch this and send us the correct antenna explicitly.</span>
 	 */
 	BUG_ON(ant-&gt;rx == ANTENNA_SW_DIVERSITY ||
 	       ant-&gt;tx == ANTENNA_SW_DIVERSITY);
<span class="p_header">diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00config.c b/drivers/net/wireless/ralink/rt2x00/rt2x00config.c</span>
<span class="p_header">index 6a1f508..62f1fb8 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ralink/rt2x00/rt2x00config.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00config.c</span>
<span class="p_chunk">@@ -123,7 +123,7 @@</span> <span class="p_context"> void rt2x00lib_config_antenna(struct rt2x00_dev *rt2x00dev,</span>
 	 * we must update the ANTENNA_RX_DIVERSITY flag to
 	 * enable the antenna diversity in the link tuner.
 	 *
<span class="p_del">-	 * Secondly, we must guarentee we never send the</span>
<span class="p_add">+	 * Secondly, we must guarantee we never send the</span>
 	 * software antenna diversity command to the driver.
 	 */
 	if (!(ant-&gt;flags &amp; ANTENNA_RX_DIVERSITY)) {
<span class="p_header">diff --git a/drivers/net/wireless/ralink/rt2x00/rt61pci.c b/drivers/net/wireless/ralink/rt2x00/rt61pci.c</span>
<span class="p_header">index 03013eb..b49b927f0 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ralink/rt2x00/rt61pci.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ralink/rt2x00/rt61pci.c</span>
<span class="p_chunk">@@ -803,7 +803,7 @@</span> <span class="p_context"> static void rt61pci_config_ant(struct rt2x00_dev *rt2x00dev,</span>
 
 	/*
 	 * We should never come here because rt2x00lib is supposed
<span class="p_del">-	 * to catch this and send us the correct antenna explicitely.</span>
<span class="p_add">+	 * to catch this and send us the correct antenna explicitly.</span>
 	 */
 	BUG_ON(ant-&gt;rx == ANTENNA_SW_DIVERSITY ||
 	       ant-&gt;tx == ANTENNA_SW_DIVERSITY);
<span class="p_header">diff --git a/drivers/net/wireless/ralink/rt2x00/rt73usb.c b/drivers/net/wireless/ralink/rt2x00/rt73usb.c</span>
<span class="p_header">index c1397a6..293d2da 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ralink/rt2x00/rt73usb.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ralink/rt2x00/rt73usb.c</span>
<span class="p_chunk">@@ -699,7 +699,7 @@</span> <span class="p_context"> static void rt73usb_config_ant(struct rt2x00_dev *rt2x00dev,</span>
 
 	/*
 	 * We should never come here because rt2x00lib is supposed
<span class="p_del">-	 * to catch this and send us the correct antenna explicitely.</span>
<span class="p_add">+	 * to catch this and send us the correct antenna explicitly.</span>
 	 */
 	BUG_ON(ant-&gt;rx == ANTENNA_SW_DIVERSITY ||
 	       ant-&gt;tx == ANTENNA_SW_DIVERSITY);
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtlwifi/rtl8192se/fw.c b/drivers/net/wireless/realtek/rtlwifi/rtl8192se/fw.c</span>
<span class="p_header">index 331b158..0630145 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtlwifi/rtl8192se/fw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtlwifi/rtl8192se/fw.c</span>
<span class="p_chunk">@@ -471,7 +471,7 @@</span> <span class="p_context"> static u32 _rtl92s_fill_h2c_cmd(struct sk_buff *skb, u32 h2cbufferlen,</span>
 	u8 i = 0;
 
 	do {
<span class="p_del">-		/* 8 - Byte aligment */</span>
<span class="p_add">+		/* 8 - Byte alignment */</span>
 		len = H2C_TX_CMD_HDR_LEN + N_BYTE_ALIGMENT(pcmd_len[i], 8);
 
 		/* Buffer length is not enough */
<span class="p_chunk">@@ -520,7 +520,7 @@</span> <span class="p_context"> static u32 _rtl92s_get_h2c_cmdlen(u32 h2cbufferlen, u32 cmd_num, u32 *pcmd_len)</span>
 	u8 i = 0;
 
 	do {
<span class="p_del">-		/* 8 - Byte aligment */</span>
<span class="p_add">+		/* 8 - Byte alignment */</span>
 		len = H2C_TX_CMD_HDR_LEN + N_BYTE_ALIGMENT(pcmd_len[i], 8);
 
 		/* Buffer length is not enough */
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtlwifi/rtl8821ae/fw.c b/drivers/net/wireless/realtek/rtlwifi/rtl8821ae/fw.c</span>
<span class="p_header">index a4fc70e..5d4b468 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtlwifi/rtl8821ae/fw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtlwifi/rtl8821ae/fw.c</span>
<span class="p_chunk">@@ -157,7 +157,7 @@</span> <span class="p_context"> static int _rtl8821ae_fw_free_to_go(struct ieee80211_hw *hw)</span>
 
 	if (counter &gt;= FW_8821AE_POLLING_TIMEOUT_COUNT) {
 		RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD,
<span class="p_del">-			 &quot;chksum report faill ! REG_MCUFWDL:0x%08x .\n&quot;,</span>
<span class="p_add">+			 &quot;chksum report fail ! REG_MCUFWDL:0x%08x .\n&quot;,</span>
 			  value32);
 		goto exit;
 	}
<span class="p_chunk">@@ -688,7 +688,7 @@</span> <span class="p_context"> void rtl8821ae_set_fw_keep_alive_cmd(struct ieee80211_hw *hw,</span>
 	RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, &quot;Enable(%d)\n&quot;, func_en);
 
 	SET_8812_H2CCMD_KEEP_ALIVE_ENABLE(keep_alive_info, func_en);
<span class="p_del">-	/* 1: the period is controled by driver, 0: by Fw default */</span>
<span class="p_add">+	/* 1: the period is controlled by driver, 0: by Fw default */</span>
 	SET_8812_H2CCMD_KEEP_ALIVE_ACCPEPT_USER_DEFINED(keep_alive_info, 1);
 	SET_8812_H2CCMD_KEEP_ALIVE_PERIOD(keep_alive_info, 10); /* 10 sec */
 
<span class="p_header">diff --git a/drivers/net/wireless/rsi/rsi_91x_main.c b/drivers/net/wireless/rsi/rsi_91x_main.c</span>
<span class="p_header">index 8810862..c96185e 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rsi/rsi_91x_main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rsi/rsi_91x_main.c</span>
<span class="p_chunk">@@ -234,7 +234,7 @@</span> <span class="p_context"> err:</span>
 EXPORT_SYMBOL_GPL(rsi_91x_init);
 
 /**
<span class="p_del">- * rsi_91x_deinit() - This function de-intializes os intf operations.</span>
<span class="p_add">+ * rsi_91x_deinit() - This function de-initializes os intf operations.</span>
  * @adapter: Pointer to the adapter structure.
  *
  * Return: None.
<span class="p_header">diff --git a/drivers/net/wireless/rsi/rsi_91x_usb.c b/drivers/net/wireless/rsi/rsi_91x_usb.c</span>
<span class="p_header">index ef5d394..a5b09f3 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rsi/rsi_91x_usb.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rsi/rsi_91x_usb.c</span>
<span class="p_chunk">@@ -229,7 +229,7 @@</span> <span class="p_context"> static int rsi_usb_reg_write(struct usb_device *usbdev,</span>
 
 /**
  * rsi_rx_done_handler() - This function is called when a packet is received
<span class="p_del">- *			   from USB stack. This is callback to recieve done.</span>
<span class="p_add">+ *			   from USB stack. This is callback to receive done.</span>
  * @urb: Received URB.
  *
  * Return: None.
<span class="p_chunk">@@ -516,7 +516,7 @@</span> <span class="p_context"> err:</span>
 
 /**
  * rsi_disconnect() - This function performs the reverse of the probe function,
<span class="p_del">- *		      it deintialize the driver structure.</span>
<span class="p_add">+ *		      it deinitialize the driver structure.</span>
  * @pfunction: Pointer to the USB interface structure.
  *
  * Return: None.
<span class="p_header">diff --git a/drivers/net/wireless/st/cw1200/cw1200_sdio.c b/drivers/net/wireless/st/cw1200/cw1200_sdio.c</span>
<span class="p_header">index d3acc85..0fdc1f1 100644</span>
<span class="p_header">--- a/drivers/net/wireless/st/cw1200/cw1200_sdio.c</span>
<span class="p_header">+++ b/drivers/net/wireless/st/cw1200/cw1200_sdio.c</span>
<span class="p_chunk">@@ -63,7 +63,7 @@</span> <span class="p_context"> static const struct sdio_device_id cw1200_sdio_ids[] = {</span>
 	{ /* end: all zeroes */			},
 };
 
<span class="p_del">-/* hwbus_ops implemetation */</span>
<span class="p_add">+/* hwbus_ops implementation */</span>
 
 static int cw1200_sdio_memcpy_fromio(struct hwbus_priv *self,
 				     unsigned int addr,
<span class="p_header">diff --git a/drivers/net/wireless/ti/wl1251/acx.h b/drivers/net/wireless/ti/wl1251/acx.h</span>
<span class="p_header">index 2bdec38..9dea667 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wl1251/acx.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wl1251/acx.h</span>
<span class="p_chunk">@@ -243,7 +243,7 @@</span> <span class="p_context"> struct acx_rx_msdu_lifetime {</span>
  * ===		==========
  * 31:12		Reserved - Always equal to 0.
  * 11		Association - When set, the WiLink receives all association
<span class="p_del">- * 	 	related frames (association request/response, reassocation</span>
<span class="p_add">+ * 	 	related frames (association request/response, reassociation</span>
  *		request/response, and disassociation). When clear, these frames
  *		are discarded.
  * 10		Auth/De auth - When set, the WiLink receives all authentication
<span class="p_header">diff --git a/drivers/net/wireless/ti/wl1251/reg.h b/drivers/net/wireless/ti/wl1251/reg.h</span>
<span class="p_header">index a580901..6df05a6 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wl1251/reg.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wl1251/reg.h</span>
<span class="p_chunk">@@ -188,7 +188,7 @@</span> <span class="p_context"> enum wl12xx_acx_int_reg {</span>
  register to clear (acknowledge) the corresp.
  interrupt status bits in the HINT_STS_CLR and
  HINT_STS_ND registers, thus making the
<span class="p_del">- assotiated interrupt inactive. (0-no effect)</span>
<span class="p_add">+ associated interrupt inactive. (0-no effect)</span>
 ==============================================*/
 	ACX_REG_INTERRUPT_ACK,
 
<span class="p_header">diff --git a/drivers/net/wireless/ti/wl12xx/reg.h b/drivers/net/wireless/ti/wl12xx/reg.h</span>
<span class="p_header">index 79ede02..de23840 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wl12xx/reg.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wl12xx/reg.h</span>
<span class="p_chunk">@@ -138,7 +138,7 @@</span> <span class="p_context"></span>
  register to clear (acknowledge) the corresp.
  interrupt status bits in the HINT_STS_CLR and
  HINT_STS_ND registers, thus making the
<span class="p_del">- assotiated interrupt inactive. (0-no effect)</span>
<span class="p_add">+ associated interrupt inactive. (0-no effect)</span>
 ==============================================*/
 #define WL12XX_REG_INTERRUPT_ACK          (REGISTERS_BASE + 0x04F0)
 
<span class="p_header">diff --git a/drivers/net/wireless/ti/wlcore/init.c b/drivers/net/wireless/ti/wlcore/init.c</span>
<span class="p_header">index d0b7734..58898b9 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wlcore/init.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wlcore/init.c</span>
<span class="p_chunk">@@ -544,7 +544,7 @@</span> <span class="p_context"> static int wl12xx_init_sta_role(struct wl1271 *wl, struct wl12xx_vif *wlvif)</span>
 	return 0;
 }
 
<span class="p_del">-/* vif-specific intialization */</span>
<span class="p_add">+/* vif-specific initialization */</span>
 static int wl12xx_init_ap_role(struct wl1271 *wl, struct wl12xx_vif *wlvif)
 {
 	int ret;
<span class="p_header">diff --git a/drivers/nfc/pn533/pn533.c b/drivers/nfc/pn533/pn533.c</span>
<span class="p_header">index d9c5583..a966c6a 100644</span>
<span class="p_header">--- a/drivers/nfc/pn533/pn533.c</span>
<span class="p_header">+++ b/drivers/nfc/pn533/pn533.c</span>
<span class="p_chunk">@@ -487,7 +487,7 @@</span> <span class="p_context"> static int pn533_send_cmd_async(struct pn533 *dev, u8 cmd_code,</span>
 /*
  * pn533_send_cmd_direct_async
  *
<span class="p_del">- * The function sends a piority cmd directly to the chip omiting the cmd</span>
<span class="p_add">+ * The function sends a piority cmd directly to the chip omitting the cmd</span>
  * queue. It&#39;s intended to be used by chaining mechanism of received responses
  * where the host has to request every single chunk of data before scheduling
  * next cmd from the queue.
<span class="p_header">diff --git a/drivers/nvme/host/rdma.c b/drivers/nvme/host/rdma.c</span>
<span class="p_header">index 8d2875b..88024e6 100644</span>
<span class="p_header">--- a/drivers/nvme/host/rdma.c</span>
<span class="p_header">+++ b/drivers/nvme/host/rdma.c</span>
<span class="p_chunk">@@ -1035,7 +1035,7 @@</span> <span class="p_context"> static int nvme_rdma_post_send(struct nvme_rdma_queue *queue,</span>
 	 * sequencer is not allocated in our driver&#39;s tagset and it&#39;s
 	 * triggered to be freed by blk_cleanup_queue(). So we need to
 	 * always mark it as signaled to ensure that the &quot;wr_cqe&quot;, which is
<span class="p_del">-	 * embeded in request&#39;s payload, is not freed when __ib_process_cq()</span>
<span class="p_add">+	 * embedded in request&#39;s payload, is not freed when __ib_process_cq()</span>
 	 * calls wr_cqe-&gt;done().
 	 */
 	if ((++queue-&gt;sig_count % 32) == 0 || flush)
<span class="p_header">diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c</span>
<span class="p_header">index aab9d51..560b09c 100644</span>
<span class="p_header">--- a/drivers/pci/pci.c</span>
<span class="p_header">+++ b/drivers/pci/pci.c</span>
<span class="p_chunk">@@ -2725,7 +2725,7 @@</span> <span class="p_context"> void pci_request_acs(void)</span>
 }
 
 /**
<span class="p_del">- * pci_std_enable_acs - enable ACS on devices using standard ACS capabilites</span>
<span class="p_add">+ * pci_std_enable_acs - enable ACS on devices using standard ACS capabilities</span>
  * @dev: the PCI device
  */
 static void pci_std_enable_acs(struct pci_dev *dev)
<span class="p_header">diff --git a/drivers/pinctrl/bcm/Kconfig b/drivers/pinctrl/bcm/Kconfig</span>
<span class="p_header">index 6324677..5691311 100644</span>
<span class="p_header">--- a/drivers/pinctrl/bcm/Kconfig</span>
<span class="p_header">+++ b/drivers/pinctrl/bcm/Kconfig</span>
<span class="p_chunk">@@ -69,7 +69,7 @@</span> <span class="p_context"> config PINCTRL_CYGNUS_MUX</span>
 
 	  The Broadcom Cygnus IOMUX driver supports group based IOMUX
 	  configuration, with the exception that certain individual pins
<span class="p_del">-	  can be overrided to GPIO function</span>
<span class="p_add">+	  can be overridden to GPIO function</span>
 
 config PINCTRL_NSP_GPIO
 	bool &quot;Broadcom NSP GPIO (with PINCONF) driver&quot;
<span class="p_header">diff --git a/drivers/pinctrl/pinconf.c b/drivers/pinctrl/pinconf.c</span>
<span class="p_header">index 799048f..286d739 100644</span>
<span class="p_header">--- a/drivers/pinctrl/pinconf.c</span>
<span class="p_header">+++ b/drivers/pinctrl/pinconf.c</span>
<span class="p_chunk">@@ -272,7 +272,7 @@</span> <span class="p_context"> void pinconf_show_setting(struct seq_file *s,</span>
 	}
 
 	/*
<span class="p_del">-	 * FIXME: We should really get the pin controler to dump the config</span>
<span class="p_add">+	 * FIXME: We should really get the pin controller to dump the config</span>
 	 * values, so they can be decoded to something meaningful.
 	 */
 	pinconf_show_config(s, pctldev, setting-&gt;data.configs.configs,
<span class="p_header">diff --git a/drivers/platform/x86/thinkpad_acpi.c b/drivers/platform/x86/thinkpad_acpi.c</span>
<span class="p_header">index b65ce75..29cba31 100644</span>
<span class="p_header">--- a/drivers/platform/x86/thinkpad_acpi.c</span>
<span class="p_header">+++ b/drivers/platform/x86/thinkpad_acpi.c</span>
<span class="p_chunk">@@ -7040,7 +7040,7 @@</span> <span class="p_context"> static bool software_mute_active;</span>
 static int software_mute_orig_mode;
 
 /*
<span class="p_del">- * Used to syncronize writers to TP_EC_AUDIO and</span>
<span class="p_add">+ * Used to synchronize writers to TP_EC_AUDIO and</span>
  * TP_NVRAM_ADDR_MIXER, as we need to do read-modify-write
  */
 static struct mutex volume_mutex;
<span class="p_chunk">@@ -9586,7 +9586,7 @@</span> <span class="p_context"> MODULE_PARM_DESC(volume_mode,</span>
 
 module_param_named(volume_capabilities, volume_capabilities, uint, 0444);
 MODULE_PARM_DESC(volume_capabilities,
<span class="p_del">-		 &quot;Selects the mixer capabilites: &quot;</span>
<span class="p_add">+		 &quot;Selects the mixer capabilities: &quot;</span>
 		 &quot;0=auto, 1=volume and mute, 2=mute only&quot;);
 
 module_param_named(volume_control, volume_control_allowed, bool, 0444);
<span class="p_header">diff --git a/drivers/power/avs/smartreflex.c b/drivers/power/avs/smartreflex.c</span>
<span class="p_header">index db9973b..6299601 100644</span>
<span class="p_header">--- a/drivers/power/avs/smartreflex.c</span>
<span class="p_header">+++ b/drivers/power/avs/smartreflex.c</span>
<span class="p_chunk">@@ -195,10 +195,10 @@</span> <span class="p_context"> static void sr_stop_vddautocomp(struct omap_sr *sr)</span>
 }
 
 /*
<span class="p_del">- * This function handles the intializations which have to be done</span>
<span class="p_add">+ * This function handles the initializations which have to be done</span>
  * only when both sr device and class driver regiter has
  * completed. This will be attempted to be called from both sr class
<span class="p_del">- * driver register and sr device intializtion API&#39;s. Only one call</span>
<span class="p_add">+ * driver register and sr device initializtion API&#39;s. Only one call</span>
  * will ultimately succeed.
  *
  * Currently this function registers interrupt handler for a particular SR
<span class="p_chunk">@@ -672,7 +672,7 @@</span> <span class="p_context"> int sr_register_class(struct omap_sr_class_data *class_data)</span>
 	sr_class = class_data;
 
 	/*
<span class="p_del">-	 * Call into late init to do intializations that require</span>
<span class="p_add">+	 * Call into late init to do initializations that require</span>
 	 * both sr driver and sr class driver to be initiallized.
 	 */
 	list_for_each_entry(sr_info, &amp;sr_list, node)
<span class="p_chunk">@@ -906,7 +906,7 @@</span> <span class="p_context"> static int __init omap_sr_probe(struct platform_device *pdev)</span>
 	list_add(&amp;sr_info-&gt;node, &amp;sr_list);
 
 	/*
<span class="p_del">-	 * Call into late init to do intializations that require</span>
<span class="p_add">+	 * Call into late init to do initializations that require</span>
 	 * both sr driver and sr class driver to be initiallized.
 	 */
 	if (sr_class) {
<span class="p_header">diff --git a/drivers/regulator/ti-abb-regulator.c b/drivers/regulator/ti-abb-regulator.c</span>
<span class="p_header">index d2f9942..f8343e6 100644</span>
<span class="p_header">--- a/drivers/regulator/ti-abb-regulator.c</span>
<span class="p_header">+++ b/drivers/regulator/ti-abb-regulator.c</span>
<span class="p_chunk">@@ -42,7 +42,7 @@</span> <span class="p_context"></span>
 /**
  * struct ti_abb_info - ABB information per voltage setting
  * @opp_sel:	one of TI_ABB macro
<span class="p_del">- * @vset:	(optional) vset value that LDOVBB needs to be overriden with.</span>
<span class="p_add">+ * @vset:	(optional) vset value that LDOVBB needs to be overridden with.</span>
  *
  * Array of per voltage entries organized in the same order as regulator_desc&#39;s
  * volt_table list. (selector is used to index from this array)
<span class="p_chunk">@@ -688,7 +688,7 @@</span> <span class="p_context"> MODULE_DEVICE_TABLE(of, ti_abb_of_match);</span>
  * @pdev: ABB platform device
  *
  * Initializes an individual ABB LDO for required Body-Bias. ABB is used to
<span class="p_del">- * addional bias supply to SoC modules for power savings or mandatory stability</span>
<span class="p_add">+ * additional bias supply to SoC modules for power savings or mandatory stability</span>
  * configuration at certain Operating Performance Points(OPPs).
  *
  * Return: 0 on success or appropriate error value when fails
<span class="p_header">diff --git a/drivers/scsi/aic7xxx/aic79xx.h b/drivers/scsi/aic7xxx/aic79xx.h</span>
<span class="p_header">index d47b527..20e6449 100644</span>
<span class="p_header">--- a/drivers/scsi/aic7xxx/aic79xx.h</span>
<span class="p_header">+++ b/drivers/scsi/aic7xxx/aic79xx.h</span>
<span class="p_chunk">@@ -840,8 +840,8 @@</span> <span class="p_context"> struct seeprom_config {</span>
  * BIOS Control Bits
  */
 	uint16_t bios_control;		/* word 16 */
<span class="p_del">-#define		CFSUPREM	0x0001	/* support all removeable drives */</span>
<span class="p_del">-#define		CFSUPREMB	0x0002	/* support removeable boot drives */</span>
<span class="p_add">+#define		CFSUPREM	0x0001	/* support all removable drives */</span>
<span class="p_add">+#define		CFSUPREMB	0x0002	/* support removable boot drives */</span>
 #define		CFBIOSSTATE	0x000C	/* BIOS Action State */
 #define		    CFBS_DISABLED	0x00
 #define		    CFBS_ENABLED	0x04
<span class="p_chunk">@@ -1184,7 +1184,7 @@</span> <span class="p_context"> struct ahd_softc {</span>
 	uint8_t			  tqinfifonext;
 
 	/*
<span class="p_del">-	 * Cached verson of the hs_mailbox so we can avoid</span>
<span class="p_add">+	 * Cached version of the hs_mailbox so we can avoid</span>
 	 * pausing the sequencer during mailbox updates.
 	 */
 	uint8_t			  hs_mailbox;
<span class="p_header">diff --git a/drivers/scsi/aic7xxx/aic79xx_osm.c b/drivers/scsi/aic7xxx/aic79xx_osm.c</span>
<span class="p_header">index 2588b8f..ff811fb 100644</span>
<span class="p_header">--- a/drivers/scsi/aic7xxx/aic79xx_osm.c</span>
<span class="p_header">+++ b/drivers/scsi/aic7xxx/aic79xx_osm.c</span>
<span class="p_chunk">@@ -173,7 +173,7 @@</span> <span class="p_context"> static adapter_tag_info_t aic79xx_tag_info[] =</span>
 
 /*
  * The I/O cell on the chip is very configurable in respect to its analog
<span class="p_del">- * characteristics.  Set the defaults here; they can be overriden with</span>
<span class="p_add">+ * characteristics.  Set the defaults here; they can be overridden with</span>
  * the proper insmod parameters.
  */
 struct ahd_linux_iocell_opts
<span class="p_header">diff --git a/drivers/scsi/bfa/bfa_defs.h b/drivers/scsi/bfa/bfa_defs.h</span>
<span class="p_header">index 5dc3782..5480f6b 100644</span>
<span class="p_header">--- a/drivers/scsi/bfa/bfa_defs.h</span>
<span class="p_header">+++ b/drivers/scsi/bfa/bfa_defs.h</span>
<span class="p_chunk">@@ -715,7 +715,7 @@</span> <span class="p_context"> struct bfa_boot_bootlun_s {</span>
 #pragma pack()
 
 /*
<span class="p_del">- * BOOT boot configuraton</span>
<span class="p_add">+ * BOOT boot configuration</span>
  */
 struct bfa_boot_cfg_s {
 	u8		version;
<span class="p_header">diff --git a/drivers/scsi/bfa/bfa_defs_svc.h b/drivers/scsi/bfa/bfa_defs_svc.h</span>
<span class="p_header">index e81707f..14d6b43 100644</span>
<span class="p_header">--- a/drivers/scsi/bfa/bfa_defs_svc.h</span>
<span class="p_header">+++ b/drivers/scsi/bfa/bfa_defs_svc.h</span>
<span class="p_chunk">@@ -40,7 +40,7 @@</span> <span class="p_context"> struct bfa_iocfc_intr_attr_s {</span>
 };
 
 /*
<span class="p_del">- * IOC firmware configuraton</span>
<span class="p_add">+ * IOC firmware configuration</span>
  */
 struct bfa_iocfc_fwcfg_s {
 	u16		num_fabrics;	/*  number of fabrics		*/
<span class="p_header">diff --git a/drivers/scsi/bfa/bfa_ioc_ct.c b/drivers/scsi/bfa/bfa_ioc_ct.c</span>
<span class="p_header">index 651a8fb..326f325 100644</span>
<span class="p_header">--- a/drivers/scsi/bfa/bfa_ioc_ct.c</span>
<span class="p_header">+++ b/drivers/scsi/bfa/bfa_ioc_ct.c</span>
<span class="p_chunk">@@ -668,7 +668,7 @@</span> <span class="p_context"> bfa_ioc_ct2_sclk_init(void __iomem *rb)</span>
 
 	/*
 	 * Ignore mode and program for the max clock (which is FC16)
<span class="p_del">-	 * Firmware/NFC will do the PLL init appropiately</span>
<span class="p_add">+	 * Firmware/NFC will do the PLL init appropriately</span>
 	 */
 	r32 = readl((rb + CT2_APP_PLL_SCLK_CTL_REG));
 	r32 &amp;= ~(__APP_PLL_SCLK_REFCLK_SEL | __APP_PLL_SCLK_CLK_DIV2);
<span class="p_header">diff --git a/drivers/scsi/bfa/bfi_ms.h b/drivers/scsi/bfa/bfi_ms.h</span>
<span class="p_header">index ae5bfe0..ccbd9e3 100644</span>
<span class="p_header">--- a/drivers/scsi/bfa/bfi_ms.h</span>
<span class="p_header">+++ b/drivers/scsi/bfa/bfi_ms.h</span>
<span class="p_chunk">@@ -680,7 +680,7 @@</span> <span class="p_context"> struct bfi_ioim_req_s {</span>
 
 	/*
 	 * SG elements array within the IO request must be double word
<span class="p_del">-	 * aligned. This aligment is required to optimize SGM setup for the IO.</span>
<span class="p_add">+	 * aligned. This alignment is required to optimize SGM setup for the IO.</span>
 	 */
 	struct bfi_sge_s	sges[BFI_SGE_INLINE_MAX];
 	u8	io_timeout;
<span class="p_header">diff --git a/drivers/scsi/csiostor/csio_mb.c b/drivers/scsi/csiostor/csio_mb.c</span>
<span class="p_header">index 9451787..4c30238 100644</span>
<span class="p_header">--- a/drivers/scsi/csiostor/csio_mb.c</span>
<span class="p_header">+++ b/drivers/scsi/csiostor/csio_mb.c</span>
<span class="p_chunk">@@ -338,7 +338,7 @@</span> <span class="p_context"> csio_mb_caps_config(struct csio_hw *hw, struct csio_mb *mbp, uint32_t tmo,</span>
  * @portid: Port ID to get/set info
  * @wr: Write/Read PORT information.
  * @fc: Flow control
<span class="p_del">- * @caps: Port capabilites to set.</span>
<span class="p_add">+ * @caps: Port capabilities to set.</span>
  * @cbfn: Callback, if any.
  *
  */
<span class="p_header">diff --git a/drivers/scsi/ipr.c b/drivers/scsi/ipr.c</span>
<span class="p_header">index 17d04c7..8e66747 100644</span>
<span class="p_header">--- a/drivers/scsi/ipr.c</span>
<span class="p_header">+++ b/drivers/scsi/ipr.c</span>
<span class="p_chunk">@@ -9247,7 +9247,7 @@</span> <span class="p_context"> static pci_ers_result_t ipr_pci_error_detected(struct pci_dev *pdev,</span>
  * ipr_probe_ioa_part2 - Initializes IOAs found in ipr_probe_ioa(..)
  * @ioa_cfg:	ioa cfg struct
  *
<span class="p_del">- * Description: This is the second phase of adapter intialization</span>
<span class="p_add">+ * Description: This is the second phase of adapter initialization</span>
  * This function takes care of initilizing the adapter to the point
  * where it can accept new commands.
 
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_sli.c b/drivers/scsi/lpfc/lpfc_sli.c</span>
<span class="p_header">index 7080ce2..152c0c3 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_sli.c</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_sli.c</span>
<span class="p_chunk">@@ -821,7 +821,7 @@</span> <span class="p_context"> lpfc_test_rrq_active(struct lpfc_hba *phba, struct lpfc_nodelist *ndlp,</span>
  *
  * This function takes the hbalock.
  * The active bit is always set in the active rrq xri_bitmap even
<span class="p_del">- * if there is no slot avaiable for the other rrq information.</span>
<span class="p_add">+ * if there is no slot available for the other rrq information.</span>
  *
  * returns 0 rrq actived for this xri
  *         &lt; 0 No memory or invalid ndlp.
<span class="p_chunk">@@ -4503,7 +4503,7 @@</span> <span class="p_context"> lpfc_sli4_rb_setup(struct lpfc_hba *phba)</span>
  * @phba: Pointer to HBA context object.
  * @sli_mode: sli mode - 2/3
  *
<span class="p_del">- * This function is called by the sli intialization code path</span>
<span class="p_add">+ * This function is called by the sli initialization code path</span>
  * to issue config_port mailbox command. This function restarts the
  * HBA firmware and issues a config_port mailbox command to configure
  * the SLI interface in the sli mode specified by sli_mode
<span class="p_chunk">@@ -4643,11 +4643,11 @@</span> <span class="p_context"> do_prep_failed:</span>
 
 
 /**
<span class="p_del">- * lpfc_sli_hba_setup - SLI intialization function</span>
<span class="p_add">+ * lpfc_sli_hba_setup - SLI initialization function</span>
  * @phba: Pointer to HBA context object.
  *
<span class="p_del">- * This function is the main SLI intialization function. This function</span>
<span class="p_del">- * is called by the HBA intialization code, HBA reset code and HBA</span>
<span class="p_add">+ * This function is the main SLI initialization function. This function</span>
<span class="p_add">+ * is called by the HBA initialization code, HBA reset code and HBA</span>
  * error attention handler code. Caller is not required to hold any
  * locks. This function issues config_port mailbox command to configure
  * the SLI, setup iocb rings and HBQ rings. In the end the function
<span class="p_chunk">@@ -6273,7 +6273,7 @@</span> <span class="p_context"> lpfc_sli4_repost_els_sgl_list(struct lpfc_hba *phba)</span>
 	/* free the els sgls failed to post */
 	lpfc_free_sgl_list(phba, &amp;free_sgl_list);
 
<span class="p_del">-	/* push els sgls posted to the availble list */</span>
<span class="p_add">+	/* push els sgls posted to the available list */</span>
 	if (!list_empty(&amp;post_sgl_list)) {
 		spin_lock_irq(&amp;phba-&gt;hbalock);
 		spin_lock(&amp;pring-&gt;ring_lock);
<span class="p_chunk">@@ -6290,11 +6290,11 @@</span> <span class="p_context"> lpfc_sli4_repost_els_sgl_list(struct lpfc_hba *phba)</span>
 }
 
 /**
<span class="p_del">- * lpfc_sli4_hba_setup - SLI4 device intialization PCI function</span>
<span class="p_add">+ * lpfc_sli4_hba_setup - SLI4 device initialization PCI function</span>
  * @phba: Pointer to HBA context object.
  *
<span class="p_del">- * This function is the main SLI4 device intialization PCI function. This</span>
<span class="p_del">- * function is called by the HBA intialization code, HBA reset code and</span>
<span class="p_add">+ * This function is the main SLI4 device initialization PCI function. This</span>
<span class="p_add">+ * function is called by the HBA initialization code, HBA reset code and</span>
  * HBA error attention handler code. Caller is not required to hold any
  * locks.
  **/
<span class="p_chunk">@@ -8134,7 +8134,7 @@</span> <span class="p_context"> __lpfc_sli_issue_iocb_s3(struct lpfc_hba *phba, uint32_t ring_number,</span>
  * If the IOCB contains a BPL then the list of BDE&#39;s is
  * converted to sli4_sge&#39;s. If the IOCB contains a single
  * BDE then it is converted to a single sli_sge.
<span class="p_del">- * The IOCB is still in cpu endianess so the contents of</span>
<span class="p_add">+ * The IOCB is still in cpu endianness so the contents of</span>
  * the bpl can be used without byte swapping.
  *
  * Returns valid XRI = Success, NO_XRI = Failure.
<span class="p_chunk">@@ -11384,7 +11384,7 @@</span> <span class="p_context"> unplug_error:</span>
  * device-level interrupt handler. When the PCI slot is in error recovery
  * or the HBA is undergoing initialization, the interrupt handler will not
  * process the interrupt. The SCSI FCP fast-path ring event are handled in
<span class="p_del">- * the intrrupt context. This function is called without any lock held.</span>
<span class="p_add">+ * the interrupt context. This function is called without any lock held.</span>
  * It gets the hbalock to access and update SLI data structures.
  *
  * This function returns IRQ_HANDLED when interrupt is handled else it
<span class="p_chunk">@@ -12675,7 +12675,7 @@</span> <span class="p_context"> lpfc_sli4_fof_handle_eqe(struct lpfc_hba *phba, struct lpfc_eqe *eqe)</span>
  * device-level interrupt handler. When the PCI slot is in error recovery
  * or the HBA is undergoing initialization, the interrupt handler will not
  * process the interrupt. The Flash Optimized Fabric ring event are handled in
<span class="p_del">- * the intrrupt context. This function is called without any lock held.</span>
<span class="p_add">+ * the interrupt context. This function is called without any lock held.</span>
  * It gets the hbalock to access and update SLI data structures. Note that,
  * the EQ to CQ are one-to-one map such that the EQ index is
  * equal to that of CQ index.
<span class="p_chunk">@@ -12764,7 +12764,7 @@</span> <span class="p_context"> lpfc_sli4_fof_intr_handler(int irq, void *dev_id)</span>
  * device-level interrupt handler. When the PCI slot is in error recovery
  * or the HBA is undergoing initialization, the interrupt handler will not
  * process the interrupt. The SCSI FCP fast-path ring event are handled in
<span class="p_del">- * the intrrupt context. This function is called without any lock held.</span>
<span class="p_add">+ * the interrupt context. This function is called without any lock held.</span>
  * It gets the hbalock to access and update SLI data structures. Note that,
  * the FCP EQ to FCP CQ are one-to-one map such that the FCP EQ index is
  * equal to that of FCP CQ index.
<span class="p_chunk">@@ -16521,7 +16521,7 @@</span> <span class="p_context"> next_priority:</span>
 		/*
 		 * If next fcf index is not found check if there are lower
 		 * Priority level fcf&#39;s in the fcf_priority list.
<span class="p_del">-		 * Set up the rr_bmask with all of the avaiable fcf bits</span>
<span class="p_add">+		 * Set up the rr_bmask with all of the available fcf bits</span>
 		 * at that level and continue the selection process.
 		 */
 		if (lpfc_check_next_fcf_pri_level(phba))
<span class="p_header">diff --git a/drivers/scsi/mpt3sas/Kconfig b/drivers/scsi/mpt3sas/Kconfig</span>
<span class="p_header">index b736dbc..bb09d60 100644</span>
<span class="p_header">--- a/drivers/scsi/mpt3sas/Kconfig</span>
<span class="p_header">+++ b/drivers/scsi/mpt3sas/Kconfig</span>
<span class="p_chunk">@@ -78,5 +78,5 @@</span> <span class="p_context"> config SCSI_MPT2SAS</span>
 	select SCSI_MPT3SAS
 	depends on PCI &amp;&amp; SCSI
 	---help---
<span class="p_del">-	Dummy config option for backwards compatiblity: configure the MPT3SAS</span>
<span class="p_add">+	Dummy config option for backwards compatibility: configure the MPT3SAS</span>
 	driver instead.
<span class="p_header">diff --git a/drivers/scsi/mpt3sas/mpt3sas_ctl.c b/drivers/scsi/mpt3sas/mpt3sas_ctl.c</span>
<span class="p_header">index 7d00f09..713498a 100644</span>
<span class="p_header">--- a/drivers/scsi/mpt3sas/mpt3sas_ctl.c</span>
<span class="p_header">+++ b/drivers/scsi/mpt3sas/mpt3sas_ctl.c</span>
<span class="p_chunk">@@ -2603,7 +2603,7 @@</span> <span class="p_context"> static DEVICE_ATTR(board_tracer, S_IRUGO, _ctl_board_tracer_show, NULL);</span>
  * @cdev - pointer to embedded class device
  * @buf - the buffer returned
  *
<span class="p_del">- * This is for firmware implemention for deboucing device</span>
<span class="p_add">+ * This is for firmware implementation for deboucing device</span>
  * removal events.
  *
  * A sysfs &#39;read-only&#39; shost attribute.
<span class="p_chunk">@@ -2624,7 +2624,7 @@</span> <span class="p_context"> static DEVICE_ATTR(io_delay, S_IRUGO, _ctl_io_delay_show, NULL);</span>
  * @cdev - pointer to embedded class device
  * @buf - the buffer returned
  *
<span class="p_del">- * This is for firmware implemention for deboucing device</span>
<span class="p_add">+ * This is for firmware implementation for deboucing device</span>
  * removal events.
  *
  * A sysfs &#39;read-only&#39; shost attribute.
<span class="p_chunk">@@ -3082,7 +3082,7 @@</span> <span class="p_context"> static DEVICE_ATTR(host_trace_buffer_enable, S_IRUGO | S_IWUSR,</span>
 	_ctl_host_trace_buffer_enable_show,
 	_ctl_host_trace_buffer_enable_store);
 
<span class="p_del">-/*********** diagnostic trigger suppport *********************************/</span>
<span class="p_add">+/*********** diagnostic trigger support *********************************/</span>
 
 /**
  * _ctl_diag_trigger_master_show - show the diag_trigger_master attribute
<span class="p_chunk">@@ -3299,7 +3299,7 @@</span> <span class="p_context"> _ctl_diag_trigger_mpi_store(struct device *cdev,</span>
 static DEVICE_ATTR(diag_trigger_mpi, S_IRUGO | S_IWUSR,
 	_ctl_diag_trigger_mpi_show, _ctl_diag_trigger_mpi_store);
 
<span class="p_del">-/*********** diagnostic trigger suppport *** END ****************************/</span>
<span class="p_add">+/*********** diagnostic trigger support *** END ****************************/</span>
 
 
 
<span class="p_header">diff --git a/drivers/scsi/mpt3sas/mpt3sas_scsih.c b/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_header">index cd91a68..21a672a 100644</span>
<span class="p_header">--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_header">+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_chunk">@@ -423,7 +423,7 @@</span> <span class="p_context"> _scsih_get_sas_address(struct MPT3SAS_ADAPTER *ioc, u16 handle,</span>
 		return 0;
 	}
 
<span class="p_del">-	/* we hit this becuase the given parent handle doesn&#39;t exist */</span>
<span class="p_add">+	/* we hit this because the given parent handle doesn&#39;t exist */</span>
 	if (ioc_status == MPI2_IOCSTATUS_CONFIG_INVALID_PAGE)
 		return -ENXIO;
 
<span class="p_chunk">@@ -2951,7 +2951,7 @@</span> <span class="p_context"> _scsih_ublock_io_device(struct MPT3SAS_ADAPTER *ioc, u64 sas_address)</span>
  * @ioc: per adapter object
  * @handle: device handle
  *
<span class="p_del">- * During device pull we need to appropiately set the sdev state.</span>
<span class="p_add">+ * During device pull we need to appropriately set the sdev state.</span>
  */
 static void
 _scsih_block_io_all_device(struct MPT3SAS_ADAPTER *ioc)
<span class="p_chunk">@@ -2980,7 +2980,7 @@</span> <span class="p_context"> _scsih_block_io_all_device(struct MPT3SAS_ADAPTER *ioc)</span>
  * @ioc: per adapter object
  * @handle: device handle
  *
<span class="p_del">- * During device pull we need to appropiately set the sdev state.</span>
<span class="p_add">+ * During device pull we need to appropriately set the sdev state.</span>
  */
 static void
 _scsih_block_io_device(struct MPT3SAS_ADAPTER *ioc, u16 handle)
<span class="p_chunk">@@ -4080,7 +4080,7 @@</span> <span class="p_context"> scsih_qcmd(struct Scsi_Host *shost, struct scsi_cmnd *scmd)</span>
 		scmd-&gt;result = DID_NO_CONNECT &lt;&lt; 16;
 		scmd-&gt;scsi_done(scmd);
 		return 0;
<span class="p_del">-	/* device busy with task managment */</span>
<span class="p_add">+	/* device busy with task management */</span>
 	} else if (sas_target_priv_data-&gt;tm_busy ||
 	    sas_device_priv_data-&gt;block)
 		return SCSI_MLQUEUE_DEVICE_BUSY;
<span class="p_chunk">@@ -8448,7 +8448,7 @@</span> <span class="p_context"> _scsih_probe_devices(struct MPT3SAS_ADAPTER *ioc)</span>
  * @shost: SCSI host pointer
  *
  * The shost has the ability to discover targets on its own instead
<span class="p_del">- * of scanning the entire bus.  In our implemention, we will kick off</span>
<span class="p_add">+ * of scanning the entire bus.  In our implementation, we will kick off</span>
  * firmware discovery.
  */
 void
<span class="p_chunk">@@ -8474,8 +8474,8 @@</span> <span class="p_context"> scsih_scan_start(struct Scsi_Host *shost)</span>
  * @shost: SCSI host pointer
  * @time: elapsed time of the scan in jiffies
  *
<span class="p_del">- * This function will be called periodicallyn until it returns 1 with the</span>
<span class="p_del">- * scsi_host and the elapsed time of the scan in jiffies. In our implemention,</span>
<span class="p_add">+ * This function will be called periodically until it returns 1 with the</span>
<span class="p_add">+ * scsi_host and the elapsed time of the scan in jiffies. In our implementation,</span>
  * we wait for firmware discovery to complete, then return 1.
  */
 int
<span class="p_chunk">@@ -9160,10 +9160,10 @@</span> <span class="p_context"> scsih_init(void)</span>
 
 	mpt3sas_base_initialize_callback_handler();
 
<span class="p_del">-	 /* queuecommand callback hander */</span>
<span class="p_add">+	 /* queuecommand callback handler */</span>
 	scsi_io_cb_idx = mpt3sas_base_register_callback_handler(_scsih_io_done);
 
<span class="p_del">-	/* task managment callback handler */</span>
<span class="p_add">+	/* task management callback handler */</span>
 	tm_cb_idx = mpt3sas_base_register_callback_handler(_scsih_tm_done);
 
 	/* base internal commands callback handler */
<span class="p_header">diff --git a/drivers/scsi/osd/osd_initiator.c b/drivers/scsi/osd/osd_initiator.c</span>
<span class="p_header">index 2f2a991..4dc3999 100644</span>
<span class="p_header">--- a/drivers/scsi/osd/osd_initiator.c</span>
<span class="p_header">+++ b/drivers/scsi/osd/osd_initiator.c</span>
<span class="p_chunk">@@ -1675,7 +1675,7 @@</span> <span class="p_context"> int osd_finalize_request(struct osd_request *or,</span>
 		}
 	} else {
 		/* TODO: I think that for the GET_ATTR command these 2 should
<span class="p_del">-		 * be reversed to keep them in execution order (for embeded</span>
<span class="p_add">+		 * be reversed to keep them in execution order (for embedded</span>
 		 * targets with low memory footprint)
 		 */
 		ret = _osd_req_finalize_set_attr_list(or);
<span class="p_header">diff --git a/drivers/scsi/pm8001/pm8001_init.c b/drivers/scsi/pm8001/pm8001_init.c</span>
<span class="p_header">index 9fc675f..4754bd2 100644</span>
<span class="p_header">--- a/drivers/scsi/pm8001/pm8001_init.c</span>
<span class="p_header">+++ b/drivers/scsi/pm8001/pm8001_init.c</span>
<span class="p_chunk">@@ -973,7 +973,7 @@</span> <span class="p_context"> intx:</span>
  * @ent: pci device id
  *
  * This function is the main initialization function, when register a new
<span class="p_del">- * pci driver it is invoked, all struct an hardware initilization should be done</span>
<span class="p_add">+ * pci driver it is invoked, all struct an hardware initialization should be done</span>
  * here, also, register interrupt
  */
 static int pm8001_pci_probe(struct pci_dev *pdev,
<span class="p_header">diff --git a/drivers/scsi/pmcraid.c b/drivers/scsi/pmcraid.c</span>
<span class="p_header">index b2a8820..0de762d 100644</span>
<span class="p_header">--- a/drivers/scsi/pmcraid.c</span>
<span class="p_header">+++ b/drivers/scsi/pmcraid.c</span>
<span class="p_chunk">@@ -887,7 +887,7 @@</span> <span class="p_context"> static void _pmcraid_fire_command(struct pmcraid_cmd *cmd)</span>
 	unsigned long lock_flags;
 
 	/* Add this command block to pending cmd pool. We do this prior to
<span class="p_del">-	 * writting IOARCB to ioarrin because IOA might complete the command</span>
<span class="p_add">+	 * writing IOARCB to ioarrin because IOA might complete the command</span>
 	 * by the time we are about to add it to the list. Response handler
 	 * (isr/tasklet) looks for cmd block in the pending pending list.
 	 */
<span class="p_chunk">@@ -1473,7 +1473,7 @@</span> <span class="p_context"> static int pmcraid_notify_aen(</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	/* send genetlink multicast message to notify appplications */</span>
<span class="p_add">+	/* send genetlink multicast message to notify applications */</span>
 	genlmsg_end(skb, msg_header);
 
 	result = genlmsg_multicast(&amp;pmcraid_event_family, skb,
<span class="p_chunk">@@ -2500,7 +2500,7 @@</span> <span class="p_context"> static void pmcraid_request_sense(struct pmcraid_cmd *cmd)</span>
 
 	/* request sense might be called as part of error response processing
 	 * which runs in tasklets context. It is possible that mid-layer might
<span class="p_del">-	 * schedule queuecommand during this time, hence, writting to IOARRIN</span>
<span class="p_add">+	 * schedule queuecommand during this time, hence, writing to IOARRIN</span>
 	 * must be protect by host_lock
 	 */
 	pmcraid_send_cmd(cmd, pmcraid_erp_done,
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_os.c b/drivers/scsi/qla2xxx/qla_os.c</span>
<span class="p_header">index 2674f4c..e8369a7 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_os.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_os.c</span>
<span class="p_chunk">@@ -6014,7 +6014,7 @@</span> <span class="p_context"> qla2x00_module_init(void)</span>
 		return ret;
 	} else if (ret &gt; 0) {
 		/*
<span class="p_del">-		 * If initiator mode is explictly disabled by qlt_init(),</span>
<span class="p_add">+		 * If initiator mode is explicitly disabled by qlt_init(),</span>
 		 * prevent scsi_transport_fc.c:fc_scsi_scan_rport() from
 		 * performing scsi_scan_target() during LOOP UP event.
 		 */
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_target.c b/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_header">index bff9689..f66b611 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_chunk">@@ -987,7 +987,7 @@</span> <span class="p_context"> static struct qla_tgt_sess *qlt_create_sess(</span>
 
 	/*
 	 * Determine if this fc_port-&gt;port_name is allowed to access
<span class="p_del">-	 * target mode using explict NodeACLs+MappedLUNs, or using</span>
<span class="p_add">+	 * target mode using explicit NodeACLs+MappedLUNs, or using</span>
 	 * TPG demo mode.  If this is successful a target mode FC nexus
 	 * is created.
 	 */
<span class="p_chunk">@@ -2798,7 +2798,7 @@</span> <span class="p_context"> int qlt_xmit_response(struct qla_tgt_cmd *cmd, int xmit_type,</span>
 			    CTIO7_FLAGS_DONT_RET_CTIO);
 
 			/* qlt_24xx_init_ctio_to_isp will correct
<span class="p_del">-			 * all neccessary fields that&#39;s part of CTIO7.</span>
<span class="p_add">+			 * all necessary fields that&#39;s part of CTIO7.</span>
 			 * There should be no residual of CTIO-CRC2 data.
 			 */
 			qlt_24xx_init_ctio_to_isp((struct ctio7_to_24xx *)ctio,
<span class="p_chunk">@@ -5657,7 +5657,7 @@</span> <span class="p_context"> static void qlt_response_pkt(struct scsi_qla_host *vha, response_t *pkt)</span>
 					 * received and processed.
 					 * Unfortunately, the firmware has a
 					 * silly requirement that all aborted
<span class="p_del">-					 * exchanges must be explicitely</span>
<span class="p_add">+					 * exchanges must be explicitly</span>
 					 * terminated, otherwise it refuses to
 					 * send responses for the abort
 					 * requests. So, we have to
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/tcm_qla2xxx.c b/drivers/scsi/qla2xxx/tcm_qla2xxx.c</span>
<span class="p_header">index 6643f6f..010a90d 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.c</span>
<span class="p_chunk">@@ -1459,13 +1459,13 @@</span> <span class="p_context"> static int tcm_qla2xxx_check_initiator_node_acl(</span>
 		return -EINVAL;
 	}
 	/*
<span class="p_del">-	 * Format the FCP Initiator port_name into colon seperated values to</span>
<span class="p_del">-	 * match the format by tcm_qla2xxx explict ConfigFS NodeACLs.</span>
<span class="p_add">+	 * Format the FCP Initiator port_name into colon separated values to</span>
<span class="p_add">+	 * match the format by tcm_qla2xxx explicit ConfigFS NodeACLs.</span>
 	 */
 	memset(&amp;port_name, 0, 36);
 	snprintf(port_name, sizeof(port_name), &quot;%8phC&quot;, fc_wwpn);
 	/*
<span class="p_del">-	 * Locate our struct se_node_acl either from an explict NodeACL created</span>
<span class="p_add">+	 * Locate our struct se_node_acl either from an explicit NodeACL created</span>
 	 * via ConfigFS, or via running in TPG demo mode.
 	 */
 	se_sess = target_alloc_session(&amp;tpg-&gt;se_tpg, num_tags,
<span class="p_chunk">@@ -1738,7 +1738,7 @@</span> <span class="p_context"> static struct se_wwn *tcm_qla2xxx_npiv_make_lport(</span>
 
 	p = strchr(tmp, &#39;@&#39;);
 	if (!p) {
<span class="p_del">-		pr_err(&quot;Unable to locate NPIV &#39;@&#39; seperator\n&quot;);</span>
<span class="p_add">+		pr_err(&quot;Unable to locate NPIV &#39;@&#39; separator\n&quot;);</span>
 		return ERR_PTR(-EINVAL);
 	}
 	*p++ = &#39;\0&#39;;
<span class="p_header">diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c</span>
<span class="p_header">index 3f0ff07..2011fbd 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_transport_sas.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_transport_sas.c</span>
<span class="p_chunk">@@ -1478,7 +1478,7 @@</span> <span class="p_context"> static void sas_end_device_release(struct device *dev)</span>
 }
 
 /**
<span class="p_del">- * sas_rphy_initialize - common rphy intialization</span>
<span class="p_add">+ * sas_rphy_initialize - common rphy initialization</span>
  * @rphy:	rphy to initialise
  *
  * Used by both sas_end_device_alloc() and sas_expander_alloc() to
<span class="p_header">diff --git a/drivers/scsi/storvsc_drv.c b/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">index 8ccfc9e..d7d2a5b 100644</span>
<span class="p_header">--- a/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">+++ b/drivers/scsi/storvsc_drv.c</span>
<span class="p_chunk">@@ -278,7 +278,7 @@</span> <span class="p_context"> static const struct vmstor_protocol vmstor_protocols[] = {</span>
 
 
 /*
<span class="p_del">- * This structure is sent during the intialization phase to get the different</span>
<span class="p_add">+ * This structure is sent during the initialization phase to get the different</span>
  * properties of the channel.
  */
 
<span class="p_header">diff --git a/drivers/scsi/sym53c8xx_2/sym53c8xx.h b/drivers/scsi/sym53c8xx_2/sym53c8xx.h</span>
<span class="p_header">index 62d29cf..03eb00d 100644</span>
<span class="p_header">--- a/drivers/scsi/sym53c8xx_2/sym53c8xx.h</span>
<span class="p_header">+++ b/drivers/scsi/sym53c8xx_2/sym53c8xx.h</span>
<span class="p_chunk">@@ -141,7 +141,7 @@</span> <span class="p_context"> struct sym_driver_setup {</span>
 /*
  *  Initial setup.
  *
<span class="p_del">- *  Can be overriden at startup by a command line.</span>
<span class="p_add">+ *  Can be overridden at startup by a command line.</span>
  */
 #define SYM_LINUX_DRIVER_SETUP	{				\
 	.max_tag	= CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS,	\
<span class="p_header">diff --git a/drivers/spi/spi-omap2-mcspi.c b/drivers/spi/spi-omap2-mcspi.c</span>
<span class="p_header">index d5157b2..72b9063 100644</span>
<span class="p_header">--- a/drivers/spi/spi-omap2-mcspi.c</span>
<span class="p_header">+++ b/drivers/spi/spi-omap2-mcspi.c</span>
<span class="p_chunk">@@ -1217,7 +1217,7 @@</span> <span class="p_context"> static int omap2_mcspi_transfer_one(struct spi_master *master,</span>
 		omap2_mcspi_set_fifo(spi, t, 0);
 
 out:
<span class="p_del">-	/* Restore defaults if they were overriden */</span>
<span class="p_add">+	/* Restore defaults if they were overridden */</span>
 	if (par_override) {
 		par_override = 0;
 		status = omap2_mcspi_setup_transfer(spi, NULL);
<span class="p_header">diff --git a/drivers/staging/gs_fpgaboot/gs_fpgaboot.h b/drivers/staging/gs_fpgaboot/gs_fpgaboot.h</span>
<span class="p_header">index 8cc3255..98437fe 100644</span>
<span class="p_header">--- a/drivers/staging/gs_fpgaboot/gs_fpgaboot.h</span>
<span class="p_header">+++ b/drivers/staging/gs_fpgaboot/gs_fpgaboot.h</span>
<span class="p_chunk">@@ -44,7 +44,7 @@</span> <span class="p_context"> struct fpgaimage {</span>
 	const struct	firmware	*fw_entry;
 
 	/*
<span class="p_del">-	 * the followings can be read from bitstream,</span>
<span class="p_add">+	 * the following can be read from bitstream,</span>
 	 * but other image format should have as well
 	 */
 	char	filename[MAX_STR];
<span class="p_header">diff --git a/drivers/staging/ks7010/ks7010_sdio.c b/drivers/staging/ks7010/ks7010_sdio.c</span>
<span class="p_header">index b7337fd..0f71252 100644</span>
<span class="p_header">--- a/drivers/staging/ks7010/ks7010_sdio.c</span>
<span class="p_header">+++ b/drivers/staging/ks7010/ks7010_sdio.c</span>
<span class="p_chunk">@@ -980,7 +980,7 @@</span> <span class="p_context"> static int ks7010_sdio_probe(struct sdio_func *func,</span>
 	priv = NULL;
 	netdev = NULL;
 
<span class="p_del">-	/* initilize ks_sdio_card */</span>
<span class="p_add">+	/* initialize ks_sdio_card */</span>
 	card = kzalloc(sizeof(struct ks_sdio_card), GFP_KERNEL);
 	if (!card)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.c b/drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.c</span>
<span class="p_header">index 4f5978b..5e1141f 100644</span>
<span class="p_header">--- a/drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.c</span>
<span class="p_header">+++ b/drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.c</span>
<span class="p_chunk">@@ -1487,7 +1487,7 @@</span> <span class="p_context"> out_fpo:</span>
 static void kiblnd_fail_fmr_poolset(struct kib_fmr_poolset *fps,
 				    struct list_head *zombies)
 {
<span class="p_del">-	if (!fps-&gt;fps_net) /* intialized? */</span>
<span class="p_add">+	if (!fps-&gt;fps_net) /* initialized? */</span>
 		return;
 
 	spin_lock(&amp;fps-&gt;fps_lock);
<span class="p_chunk">@@ -1810,7 +1810,7 @@</span> <span class="p_context"> static void kiblnd_destroy_pool_list(struct list_head *head)</span>
 
 static void kiblnd_fail_poolset(struct kib_poolset *ps, struct list_head *zombies)
 {
<span class="p_del">-	if (!ps-&gt;ps_net) /* intialized? */</span>
<span class="p_add">+	if (!ps-&gt;ps_net) /* initialized? */</span>
 		return;
 
 	spin_lock(&amp;ps-&gt;ps_lock);
<span class="p_header">diff --git a/drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c b/drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c</span>
<span class="p_header">index bf077f8..dfdcc90 100644</span>
<span class="p_header">--- a/drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c</span>
<span class="p_header">+++ b/drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c</span>
<span class="p_chunk">@@ -531,7 +531,7 @@</span> <span class="p_context"> static void vpfe_cleanup_modules(struct vpfe_device *vpfe_dev,</span>
  * @vpfe_dev - ptr to vpfe capture device
  * @pdev - pointer to platform device
  *
<span class="p_del">- * intialize all v4l2 subdevs and media entities</span>
<span class="p_add">+ * initialize all v4l2 subdevs and media entities</span>
  */
 static int vpfe_initialize_modules(struct vpfe_device *vpfe_dev,
 				   struct platform_device *pdev)
<span class="p_header">diff --git a/drivers/staging/rtl8192u/ieee80211/ieee80211.h b/drivers/staging/rtl8192u/ieee80211/ieee80211.h</span>
<span class="p_header">index 09e9499..2afd93f 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8192u/ieee80211/ieee80211.h</span>
<span class="p_header">+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211.h</span>
<span class="p_chunk">@@ -1943,7 +1943,7 @@</span> <span class="p_context"> struct ieee80211_device {</span>
 
 	/* ask to the driver to retune the radio .
 	 * This function can sleep. the driver should ensure
<span class="p_del">-	 * the radio has been swithced before return.</span>
<span class="p_add">+	 * the radio has been switched before return.</span>
 	 */
 	void (*set_chan)(struct net_device *dev, short ch);
 
<span class="p_chunk">@@ -1954,7 +1954,7 @@</span> <span class="p_context"> struct ieee80211_device {</span>
 	 * The syncro version is similar to the start_scan but
 	 * does not return until all channels has been scanned.
 	 * this is called in user context and should sleep,
<span class="p_del">-	 * it is called in a work_queue when swithcing to ad-hoc mode</span>
<span class="p_add">+	 * it is called in a work_queue when switching to ad-hoc mode</span>
 	 * or in behalf of iwlist scan when the card is associated
 	 * and root user ask for a scan.
 	 * the function stop_scan should stop both the syncro and
<span class="p_header">diff --git a/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c b/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c</span>
<span class="p_header">index 49db1b7..7f627ae 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c</span>
<span class="p_chunk">@@ -2355,7 +2355,7 @@</span> <span class="p_context"> static void ieee80211_start_ibss_wq(struct work_struct *work)</span>
 //	if((IS_DOT11D_ENABLE(ieee)) &amp;&amp; (ieee-&gt;state == IEEE80211_NOLINK))
 	if (ieee-&gt;state == IEEE80211_NOLINK)
 		ieee-&gt;current_network.channel = 6;
<span class="p_del">-	/* if not then the state is not linked. Maybe the user swithced to</span>
<span class="p_add">+	/* if not then the state is not linked. Maybe the user switched to</span>
 	 * ad-hoc mode just after being in monitor mode, or just after
 	 * being very few time in managed mode (so the card have had no
 	 * time to scan all the chans..) or we have just run up the iface
<span class="p_header">diff --git a/drivers/staging/rtl8192u/ieee80211/ieee80211_wx.c b/drivers/staging/rtl8192u/ieee80211/ieee80211_wx.c</span>
<span class="p_header">index 563d7fe..c50e73b 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_wx.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_wx.c</span>
<span class="p_chunk">@@ -399,7 +399,7 @@</span> <span class="p_context"> int ieee80211_wx_set_encode(struct ieee80211_device *ieee,</span>
 				       (*crypt)-&gt;priv);
 		sec.flags |= (1 &lt;&lt; key);
 		/* This ensures a key will be activated if no key is
<span class="p_del">-		 * explicitely set */</span>
<span class="p_add">+		 * explicitly set */</span>
 		if (key == sec.active_key)
 			sec.flags |= SEC_ACTIVE_KEY;
 		ieee-&gt;tx_keyidx = key;
<span class="p_header">diff --git a/drivers/staging/rtl8192u/r819xU_cmdpkt.h b/drivers/staging/rtl8192u/r819xU_cmdpkt.h</span>
<span class="p_header">index f490e25..ed3b389 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8192u/r819xU_cmdpkt.h</span>
<span class="p_header">+++ b/drivers/staging/rtl8192u/r819xU_cmdpkt.h</span>
<span class="p_chunk">@@ -82,7 +82,7 @@</span> <span class="p_context"> typedef struct tag_cmd_pkt_set_configuration {</span>
 	u32	mask;
 } cmpk_set_cfg_t;
 
<span class="p_del">-/* 4. Both side : TX/RX query configuraton packet. The query structure is the</span>
<span class="p_add">+/* 4. Both side : TX/RX query configuration packet. The query structure is the</span>
       same as set configuration. */
 #define		cmpk_query_cfg_t	cmpk_set_cfg_t
 
<span class="p_header">diff --git a/drivers/staging/wilc1000/linux_wlan.c b/drivers/staging/wilc1000/linux_wlan.c</span>
<span class="p_header">index 3a66255..2ae4bc7 100644</span>
<span class="p_header">--- a/drivers/staging/wilc1000/linux_wlan.c</span>
<span class="p_header">+++ b/drivers/staging/wilc1000/linux_wlan.c</span>
<span class="p_chunk">@@ -212,7 +212,7 @@</span> <span class="p_context"> static void deinit_irq(struct net_device *dev)</span>
 	vif = netdev_priv(dev);
 	wilc = vif-&gt;wilc;
 
<span class="p_del">-	/* Deintialize IRQ */</span>
<span class="p_add">+	/* Deinitialize IRQ */</span>
 	if (wilc-&gt;dev_irq_num) {
 		free_irq(wilc-&gt;dev_irq_num, wilc);
 		gpio_free(wilc-&gt;gpio);
<span class="p_header">diff --git a/drivers/staging/wilc1000/wilc_wfi_cfgoperations.c b/drivers/staging/wilc1000/wilc_wfi_cfgoperations.c</span>
<span class="p_header">index 9092600..5955e74 100644</span>
<span class="p_header">--- a/drivers/staging/wilc1000/wilc_wfi_cfgoperations.c</span>
<span class="p_header">+++ b/drivers/staging/wilc1000/wilc_wfi_cfgoperations.c</span>
<span class="p_chunk">@@ -2359,7 +2359,7 @@</span> <span class="p_context"> int wilc_deinit_host_int(struct net_device *net)</span>
 		del_timer_sync(&amp;wilc_during_ip_timer);
 
 	if (s32Error)
<span class="p_del">-		netdev_err(net, &quot;Error while deintializing host interface\n&quot;);</span>
<span class="p_add">+		netdev_err(net, &quot;Error while deinitializing host interface\n&quot;);</span>
 
 	return s32Error;
 }
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">index 39b928c..6e66016 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_chunk">@@ -112,7 +112,7 @@</span> <span class="p_context"> void iscsit_put_tiqn_for_login(struct iscsi_tiqn *tiqn)</span>
 
 /*
  * Note that IQN formatting is expected to be done in userspace, and
<span class="p_del">- * no explict IQN format checks are done here.</span>
<span class="p_add">+ * no explicit IQN format checks are done here.</span>
  */
 struct iscsi_tiqn *iscsit_add_tiqn(unsigned char *buf)
 {
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_login.c b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">index adf419f..f958812 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_chunk">@@ -606,7 +606,7 @@</span> <span class="p_context"> int iscsi_login_post_auth_non_zero_tsih(</span>
 	 * We use the original ExpStatSN sent in the first login request
 	 * to acknowledge commands for the failed connection.
 	 *
<span class="p_del">-	 * Also note that an explict logout may have already been sent,</span>
<span class="p_add">+	 * Also note that an explicit logout may have already been sent,</span>
 	 * but the response may not be sent due to additional connection
 	 * loss.
 	 */
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_tpg.c b/drivers/target/iscsi/iscsi_target_tpg.c</span>
<span class="p_header">index 0814e58..b53fcb9 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_tpg.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_tpg.c</span>
<span class="p_chunk">@@ -321,7 +321,7 @@</span> <span class="p_context"> int iscsit_tpg_enable_portal_group(struct iscsi_portal_group *tpg)</span>
 	}
 	/*
 	 * Make sure that AuthMethod does not contain None as an option
<span class="p_del">-	 * unless explictly disabled.  Set the default to CHAP if authentication</span>
<span class="p_add">+	 * unless explicitly disabled.  Set the default to CHAP if authentication</span>
 	 * is enforced (as per default), and remove the NONE option.
 	 */
 	param = iscsi_find_param_from_key(AUTHMETHOD, tpg-&gt;param_list);
<span class="p_header">diff --git a/drivers/target/loopback/tcm_loop.c b/drivers/target/loopback/tcm_loop.c</span>
<span class="p_header">index 5091b31..ee1a71e 100644</span>
<span class="p_header">--- a/drivers/target/loopback/tcm_loop.c</span>
<span class="p_header">+++ b/drivers/target/loopback/tcm_loop.c</span>
<span class="p_chunk">@@ -553,7 +553,7 @@</span> <span class="p_context"> static int tcm_loop_check_demo_mode_cache(struct se_portal_group *se_tpg)</span>
 }
 
 /*
<span class="p_del">- * Allow I_T Nexus full READ-WRITE access without explict Initiator Node ACLs for</span>
<span class="p_add">+ * Allow I_T Nexus full READ-WRITE access without explicit Initiator Node ACLs for</span>
  * local virtual Linux/SCSI LLD passthrough into VM hypervisor guest
  */
 static int tcm_loop_check_demo_mode_write_protect(struct se_portal_group *se_tpg)
<span class="p_chunk">@@ -562,7 +562,7 @@</span> <span class="p_context"> static int tcm_loop_check_demo_mode_write_protect(struct se_portal_group *se_tpg</span>
 }
 
 /*
<span class="p_del">- * Because TCM_Loop does not use explict ACLs and MappedLUNs, this will</span>
<span class="p_add">+ * Because TCM_Loop does not use explicit ACLs and MappedLUNs, this will</span>
  * never be called for TCM_Loop by target_core_fabric_configfs.c code.
  * It has been added here as a nop for target_fabric_tf_ops_check()
  */
<span class="p_header">diff --git a/drivers/target/tcm_fc/tfc_io.c b/drivers/target/tcm_fc/tfc_io.c</span>
<span class="p_header">index 6f7c65a..ab97fe5 100644</span>
<span class="p_header">--- a/drivers/target/tcm_fc/tfc_io.c</span>
<span class="p_header">+++ b/drivers/target/tcm_fc/tfc_io.c</span>
<span class="p_chunk">@@ -263,7 +263,7 @@</span> <span class="p_context"> void ft_recv_write_data(struct ft_cmd *cmd, struct fc_frame *fp)</span>
 		 * header is posted in receive queue.
 		 *
 		 * If &quot;Sequence Initiative (TSI)&quot; bit is not set, means error
<span class="p_del">-		 * condition w.r.t. DDP, hence drop the packet and let explict</span>
<span class="p_add">+		 * condition w.r.t. DDP, hence drop the packet and let explicit</span>
 		 * ABORTS from other end of exchange timer trigger the recovery.
 		 */
 		if (f_ctl &amp; FC_FC_SEQ_INIT)
<span class="p_header">diff --git a/drivers/tty/n_gsm.c b/drivers/tty/n_gsm.c</span>
<span class="p_header">index 54cab59..dae3540 100644</span>
<span class="p_header">--- a/drivers/tty/n_gsm.c</span>
<span class="p_header">+++ b/drivers/tty/n_gsm.c</span>
<span class="p_chunk">@@ -3104,7 +3104,7 @@</span> <span class="p_context"> static void gsmtty_set_termios(struct tty_struct *tty, struct ktermios *old)</span>
 	if (dlci-&gt;state == DLCI_CLOSED)
 		return;
 	/* For the moment its fixed. In actual fact the speed information
<span class="p_del">-	   for the virtual channel can be propogated in both directions by</span>
<span class="p_add">+	   for the virtual channel can be propagated in both directions by</span>
 	   the RPN control message. This however rapidly gets nasty as we
 	   then have to remap modem signals each way according to whether
 	   our virtual cable is null modem etc .. */
<span class="p_header">diff --git a/drivers/tty/serial/crisv10.c b/drivers/tty/serial/crisv10.c</span>
<span class="p_header">index 315c849..c470d50 100644</span>
<span class="p_header">--- a/drivers/tty/serial/crisv10.c</span>
<span class="p_header">+++ b/drivers/tty/serial/crisv10.c</span>
<span class="p_chunk">@@ -57,7 +57,7 @@</span> <span class="p_context"> static char *serial_version = &quot;$Revision: 1.25 $&quot;;</span>
 #endif
 
 /*
<span class="p_del">- * All of the compatibilty code so we can compile serial.c against</span>
<span class="p_add">+ * All of the compatibility code so we can compile serial.c against</span>
  * older kernels is hidden in serial_compat.h
  */
 #if defined(LOCAL_HEADERS)
<span class="p_chunk">@@ -2496,7 +2496,7 @@</span> <span class="p_context"> ser_interrupt(int irq, void *dev_id)</span>
 	 *  - async data will be handled above (sync will be ignored).
 	 *  - tx_started flag will prevent us from trying to send again and
 	 *    we will exit fast - no need to unblock serial irq.
<span class="p_del">-	 *  - Next (sync) serial interrupt handler will be runned with</span>
<span class="p_add">+	 *  - Next (sync) serial interrupt handler will be run with</span>
 	 *    disabled interrupt due to restore_flags() at end of function,
 	 *    so sync handler will not be preempted or reentered.
 	 */
<span class="p_header">diff --git a/drivers/tty/serial/mpc52xx_uart.c b/drivers/tty/serial/mpc52xx_uart.c</span>
<span class="p_header">index 3970d6a..d80298c 100644</span>
<span class="p_header">--- a/drivers/tty/serial/mpc52xx_uart.c</span>
<span class="p_header">+++ b/drivers/tty/serial/mpc52xx_uart.c</span>
<span class="p_chunk">@@ -1666,7 +1666,7 @@</span> <span class="p_context"> mpc52xx_console_setup(struct console *co, char *options)</span>
 		 (void *)port-&gt;mapbase, port-&gt;membase,
 		 port-&gt;irq, port-&gt;uartclk);
 
<span class="p_del">-	/* Setup the port parameters accoding to options */</span>
<span class="p_add">+	/* Setup the port parameters according to options */</span>
 	if (options)
 		uart_parse_options(options, &amp;baud, &amp;parity, &amp;bits, &amp;flow);
 	else
<span class="p_header">diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c</span>
<span class="p_header">index 9fc1533..fba8523 100644</span>
<span class="p_header">--- a/drivers/tty/serial/serial_core.c</span>
<span class="p_header">+++ b/drivers/tty/serial/serial_core.c</span>
<span class="p_chunk">@@ -1439,7 +1439,7 @@</span> <span class="p_context"> static void uart_set_termios(struct tty_struct *tty,</span>
 	}
 
 	uart_change_speed(tty, state, old_termios);
<span class="p_del">-	/* reload cflag from termios; port driver may have overriden flags */</span>
<span class="p_add">+	/* reload cflag from termios; port driver may have overridden flags */</span>
 	cflag = tty-&gt;termios.c_cflag;
 
 	/* Handle transition to B0 status */
<span class="p_header">diff --git a/drivers/usb/dwc2/core.c b/drivers/usb/dwc2/core.c</span>
<span class="p_header">index 4135a5f..611bb61 100644</span>
<span class="p_header">--- a/drivers/usb/dwc2/core.c</span>
<span class="p_header">+++ b/drivers/usb/dwc2/core.c</span>
<span class="p_chunk">@@ -1277,7 +1277,7 @@</span> <span class="p_context"> static void dwc2_set_param_hibernation(struct dwc2_hsotg *hsotg,</span>
 }
 
 /*
<span class="p_del">- * This function is called during module intialization to pass module parameters</span>
<span class="p_add">+ * This function is called during module initialization to pass module parameters</span>
  * for the DWC_otg core.
  */
 void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
<span class="p_header">diff --git a/drivers/usb/gadget/udc/fsl_udc_core.c b/drivers/usb/gadget/udc/fsl_udc_core.c</span>
<span class="p_header">index aab5221..15e08bf 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/fsl_udc_core.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/fsl_udc_core.c</span>
<span class="p_chunk">@@ -478,7 +478,7 @@</span> <span class="p_context"> static int dr_ep_get_stall(unsigned char ep_num, unsigned char dir)</span>
 ********************************************************************/
 
 /*------------------------------------------------------------------
<span class="p_del">-* struct_ep_qh_setup(): set the Endpoint Capabilites field of QH</span>
<span class="p_add">+* struct_ep_qh_setup(): set the Endpoint Capabilities field of QH</span>
  * @zlt: Zero Length Termination Select (1: disable; 0: enable)
  * @mult: Mult field
  ------------------------------------------------------------------*/
<span class="p_chunk">@@ -490,7 +490,7 @@</span> <span class="p_context"> static void struct_ep_qh_setup(struct fsl_udc *udc, unsigned char ep_num,</span>
 	struct ep_queue_head *p_QH = &amp;udc-&gt;ep_qh[2 * ep_num + dir];
 	unsigned int tmp = 0;
 
<span class="p_del">-	/* set the Endpoint Capabilites in QH */</span>
<span class="p_add">+	/* set the Endpoint Capabilities in QH */</span>
 	switch (ep_type) {
 	case USB_ENDPOINT_XFER_CONTROL:
 		/* Interrupt On Setup (IOS). for control ep  */
<span class="p_chunk">@@ -520,7 +520,7 @@</span> <span class="p_context"> static void struct_ep_qh_setup(struct fsl_udc *udc, unsigned char ep_num,</span>
 /* Setup qh structure and ep register for ep0. */
 static void ep0_setup(struct fsl_udc *udc)
 {
<span class="p_del">-	/* the intialization of an ep includes: fields in QH, Regs,</span>
<span class="p_add">+	/* the initialization of an ep includes: fields in QH, Regs,</span>
 	 * fsl_ep struct */
 	struct_ep_qh_setup(udc, 0, USB_RECV, USB_ENDPOINT_XFER_CONTROL,
 			USB_MAX_CTRL_PAYLOAD, 0, 0);
<span class="p_chunk">@@ -601,7 +601,7 @@</span> <span class="p_context"> static int fsl_ep_enable(struct usb_ep *_ep,</span>
 	ep-&gt;stopped = 0;
 
 	/* Controller related setup */
<span class="p_del">-	/* Init EPx Queue Head (Ep Capabilites field in QH</span>
<span class="p_add">+	/* Init EPx Queue Head (Ep Capabilities field in QH</span>
 	 * according to max, zlt, mult) */
 	struct_ep_qh_setup(udc, (unsigned char) ep_index(ep),
 			(unsigned char) ((desc-&gt;bEndpointAddress &amp; USB_DIR_IN)
<span class="p_chunk">@@ -2344,7 +2344,7 @@</span> <span class="p_context"> static int struct_ep_setup(struct fsl_udc *udc, unsigned char index,</span>
 }
 
 /* Driver probe function
<span class="p_del">- * all intialization operations implemented here except enabling usb_intr reg</span>
<span class="p_add">+ * all initialization operations implemented here except enabling usb_intr reg</span>
  * board setup should have been done in the platform code
  */
 static int fsl_udc_probe(struct platform_device *pdev)
<span class="p_header">diff --git a/drivers/usb/gadget/udc/renesas_usb3.c b/drivers/usb/gadget/udc/renesas_usb3.c</span>
<span class="p_header">index 93a3bec..ac883ce 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/renesas_usb3.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/renesas_usb3.c</span>
<span class="p_chunk">@@ -1789,7 +1789,7 @@</span> <span class="p_context"> static int renesas_usb3_init_ep(struct renesas_usb3 *usb3, struct device *dev,</span>
 
 	dev_dbg(dev, &quot;%s: num_usb3_eps = %d\n&quot;, __func__, usb3-&gt;num_usb3_eps);
 	/*
<span class="p_del">-	 * This driver prepares pipes as the followings:</span>
<span class="p_add">+	 * This driver prepares pipes as follows:</span>
 	 *  - odd pipes = IN pipe
 	 *  - even pipes = OUT pipe (except pipe 0)
 	 */
<span class="p_chunk">@@ -1839,7 +1839,7 @@</span> <span class="p_context"> static void renesas_usb3_init_ram(struct renesas_usb3 *usb3, struct device *dev,</span>
 	memset(basead, 0, sizeof(basead));
 
 	/*
<span class="p_del">-	 * This driver prepares pipes as the followings:</span>
<span class="p_add">+	 * This driver prepares pipes as follows:</span>
 	 *  - all pipes = the same size as &quot;ramsize_per_pipe&quot;
 	 * Please refer to the &quot;Method of Specifying RAM Mapping&quot;
 	 */
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index b2c1dc5..7a3980e 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -1671,7 +1671,7 @@</span> <span class="p_context"> struct xhci_hcd {</span>
 	unsigned		sw_lpm_support:1;
 	/* support xHCI 1.0 spec USB2 hardware LPM */
 	unsigned		hw_lpm_support:1;
<span class="p_del">-	/* cached usb2 extened protocol capabilites */</span>
<span class="p_add">+	/* cached usb2 extended protocol capabilities */</span>
 	u32                     *ext_caps;
 	unsigned int            num_ext_caps;
 	/* Compliance Mode Recovery Data */
<span class="p_header">diff --git a/drivers/vhost/scsi.c b/drivers/vhost/scsi.c</span>
<span class="p_header">index 6e29d05..b1317f2 100644</span>
<span class="p_header">--- a/drivers/vhost/scsi.c</span>
<span class="p_header">+++ b/drivers/vhost/scsi.c</span>
<span class="p_chunk">@@ -117,7 +117,7 @@</span> <span class="p_context"> struct vhost_scsi_nexus {</span>
 struct vhost_scsi_tpg {
 	/* Vhost port target portal group tag for TCM */
 	u16 tport_tpgt;
<span class="p_del">-	/* Used to track number of TPG Port/Lun Links wrt to explict I_T Nexus shutdown */</span>
<span class="p_add">+	/* Used to track number of TPG Port/Lun Links wrt to explicit I_T Nexus shutdown */</span>
 	int tv_tpg_port_count;
 	/* Used for vhost_scsi device reference to tpg_nexus, protected by tv_tpg_mutex */
 	int tv_tpg_vhost_count;
<span class="p_header">diff --git a/drivers/video/fbdev/intelfb/intelfbdrv.c b/drivers/video/fbdev/intelfb/intelfbdrv.c</span>
<span class="p_header">index bf20744..d025171 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/intelfb/intelfbdrv.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/intelfb/intelfbdrv.c</span>
<span class="p_chunk">@@ -933,9 +933,7 @@</span> <span class="p_context"> static __inline__ int var_to_refresh(const struct fb_var_screeninfo *var)</span>
 	return (1000000000 / var-&gt;pixclock * 1000 + 500) / xtot / ytot;
 }
 
<span class="p_del">-/***************************************************************</span>
<span class="p_del">- *                Various intialisation functions              *</span>
<span class="p_del">- ***************************************************************/</span>
<span class="p_add">+/* Various initialisation functions */</span>
 
 static void get_initial_mode(struct intelfb_info *dinfo)
 {
<span class="p_header">diff --git a/drivers/video/fbdev/mmp/hw/mmp_spi.c b/drivers/video/fbdev/mmp/hw/mmp_spi.c</span>
<span class="p_header">index e62ca7b..4dd5f54 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/mmp/hw/mmp_spi.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/mmp/hw/mmp_spi.c</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 /*
  * linux/drivers/video/mmp/hw/mmp_spi.c
<span class="p_del">- * using the spi in LCD controler for commands send</span>
<span class="p_add">+ * using the spi in LCD controller for commands send</span>
  *
  * Copyright (C) 2012 Marvell Technology Group Ltd.
  * Authors:  Guoqing Li &lt;ligq@marvell.com&gt;
<span class="p_header">diff --git a/drivers/video/fbdev/tridentfb.c b/drivers/video/fbdev/tridentfb.c</span>
<span class="p_header">index 8a5bbc1..bf03025 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/tridentfb.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/tridentfb.c</span>
<span class="p_chunk">@@ -56,7 +56,7 @@</span> <span class="p_context"> static struct fb_fix_screeninfo tridentfb_fix = {</span>
 	.accel = FB_ACCEL_NONE,
 };
 
<span class="p_del">-/* defaults which are normally overriden by user values */</span>
<span class="p_add">+/* defaults which are normally overridden by user values */</span>
 
 /* video mode */
 static char *mode_option;
<span class="p_header">diff --git a/drivers/watchdog/bcm2835_wdt.c b/drivers/watchdog/bcm2835_wdt.c</span>
<span class="p_header">index 4dddd82..7a10817 100644</span>
<span class="p_header">--- a/drivers/watchdog/bcm2835_wdt.c</span>
<span class="p_header">+++ b/drivers/watchdog/bcm2835_wdt.c</span>
<span class="p_chunk">@@ -37,9 +37,9 @@</span> <span class="p_context"></span>
 #define PM_RSTC_RESET			0x00000102
 
 /*
<span class="p_del">- * The Raspberry Pi firmware uses the RSTS register to know which partiton</span>
<span class="p_del">- * to boot from. The partiton value is spread into bits 0, 2, 4, 6, 8, 10.</span>
<span class="p_del">- * Partiton 63 is a special partition used by the firmware to indicate halt.</span>
<span class="p_add">+ * The Raspberry Pi firmware uses the RSTS register to know which partition</span>
<span class="p_add">+ * to boot from. The partition value is spread into bits 0, 2, 4, 6, 8, 10.</span>
<span class="p_add">+ * Partition 63 is a special partition used by the firmware to indicate halt.</span>
  */
 #define PM_RSTS_RASPBERRYPI_HALT	0x555
 
<span class="p_header">diff --git a/fs/attr.c b/fs/attr.c</span>
<span class="p_header">index 42bb42b..5c168a0 100644</span>
<span class="p_header">--- a/fs/attr.c</span>
<span class="p_header">+++ b/fs/attr.c</span>
<span class="p_chunk">@@ -33,7 +33,7 @@</span> <span class="p_context"> int inode_change_ok(const struct inode *inode, struct iattr *attr)</span>
 	unsigned int ia_valid = attr-&gt;ia_valid;
 
 	/*
<span class="p_del">-	 * First check size constraints.  These can&#39;t be overriden using</span>
<span class="p_add">+	 * First check size constraints.  These can&#39;t be overridden using</span>
 	 * ATTR_FORCE.
 	 */
 	if (ia_valid &amp; ATTR_SIZE) {
<span class="p_header">diff --git a/fs/compat_ioctl.c b/fs/compat_ioctl.c</span>
<span class="p_header">index c1e9f29..9a2ea1c 100644</span>
<span class="p_header">--- a/fs/compat_ioctl.c</span>
<span class="p_header">+++ b/fs/compat_ioctl.c</span>
<span class="p_chunk">@@ -1403,7 +1403,7 @@</span> <span class="p_context"> COMPATIBLE_IOCTL(TIOCSLTC)</span>
 #ifdef TIOCSTART
 /*
  * For these two we have definitions in ioctls.h and/or termios.h on
<span class="p_del">- * some architectures but no actual implemention.  Some applications</span>
<span class="p_add">+ * some architectures but no actual implementation.  Some applications</span>
  * like bash call them if they are defined in the headers, so we provide
  * entries here to avoid syslog message spew.
  */
<span class="p_header">diff --git a/fs/dcache.c b/fs/dcache.c</span>
<span class="p_header">index 5c7cc95..0ba1b1a 100644</span>
<span class="p_header">--- a/fs/dcache.c</span>
<span class="p_header">+++ b/fs/dcache.c</span>
<span class="p_chunk">@@ -3365,7 +3365,7 @@</span> <span class="p_context"> char *dentry_path(struct dentry *dentry, char *buf, int buflen)</span>
 	}
 	retval = __dentry_path(dentry, buf, buflen);
 	if (!IS_ERR(retval) &amp;&amp; p)
<span class="p_del">-		*p = &#39;/&#39;;	/* restore &#39;/&#39; overriden with &#39;\0&#39; */</span>
<span class="p_add">+		*p = &#39;/&#39;;	/* restore &#39;/&#39; overridden with &#39;\0&#39; */</span>
 	return retval;
 Elong:
 	return ERR_PTR(-ENAMETOOLONG);
<span class="p_header">diff --git a/fs/debugfs/inode.c b/fs/debugfs/inode.c</span>
<span class="p_header">index 72361ba..c3dd76d 100644</span>
<span class="p_header">--- a/fs/debugfs/inode.c</span>
<span class="p_header">+++ b/fs/debugfs/inode.c</span>
<span class="p_chunk">@@ -679,7 +679,7 @@</span> <span class="p_context"> void debugfs_remove_recursive(struct dentry *dentry)</span>
 			simple_release_fs(&amp;debugfs_mount, &amp;debugfs_mount_count);
 
 		/*
<span class="p_del">-		 * The parent-&gt;d_lock protects agaist child from unlinking</span>
<span class="p_add">+		 * The parent-&gt;d_lock protects against child from unlinking</span>
 		 * from d_subdirs. When releasing the parent-&gt;d_lock we can
 		 * no longer trust that the next pointer is valid.
 		 * Restart the loop. We&#39;ll skip this one with the
<span class="p_header">diff --git a/fs/dlm/ast.c b/fs/dlm/ast.c</span>
<span class="p_header">index dcea1e3..f7a8abf 100644</span>
<span class="p_header">--- a/fs/dlm/ast.c</span>
<span class="p_header">+++ b/fs/dlm/ast.c</span>
<span class="p_chunk">@@ -66,7 +66,7 @@</span> <span class="p_context"> int dlm_add_lkb_callback(struct dlm_lkb *lkb, uint32_t flags, int mode,</span>
 		 * Suppress some redundant basts here, do more on removal.
 		 * Don&#39;t even add a bast if the callback just before it
 		 * is a bast for the same mode or a more restrictive mode.
<span class="p_del">-		 * (the addional &gt; PR check is needed for PR/CW inversion)</span>
<span class="p_add">+		 * (the additional &gt; PR check is needed for PR/CW inversion)</span>
 		 */
 
 		if ((i &gt; 0) &amp;&amp; (flags &amp; DLM_CB_BAST) &amp;&amp;
<span class="p_header">diff --git a/fs/dlm/lock.c b/fs/dlm/lock.c</span>
<span class="p_header">index 35502d4..b873a44 100644</span>
<span class="p_header">--- a/fs/dlm/lock.c</span>
<span class="p_header">+++ b/fs/dlm/lock.c</span>
<span class="p_chunk">@@ -93,7 +93,7 @@</span> <span class="p_context"> static void del_timeout(struct dlm_lkb *lkb);</span>
 static void toss_rsb(struct kref *kref);
 
 /*
<span class="p_del">- * Lock compatibilty matrix - thanks Steve</span>
<span class="p_add">+ * Lock compatibility matrix - thanks Steve</span>
  * UN = Unlocked state. Not really a state, used as a flag
  * PD = Padding. Used to make the matrix a nice power of two in size
  * Other states are the same as the VMS DLM.
<span class="p_header">diff --git a/fs/ext2/super.c b/fs/ext2/super.c</span>
<span class="p_header">index 1d93795..97af01e 100644</span>
<span class="p_header">--- a/fs/ext2/super.c</span>
<span class="p_header">+++ b/fs/ext2/super.c</span>
<span class="p_chunk">@@ -1071,7 +1071,7 @@</span> <span class="p_context"> static int ext2_fill_super(struct super_block *sb, void *data, int silent)</span>
 	get_random_bytes(&amp;sbi-&gt;s_next_generation, sizeof(u32));
 	spin_lock_init(&amp;sbi-&gt;s_next_gen_lock);
 
<span class="p_del">-	/* per fileystem reservation list head &amp; lock */</span>
<span class="p_add">+	/* per filesystem reservation list head &amp; lock */</span>
 	spin_lock_init(&amp;sbi-&gt;s_rsv_window_lock);
 	sbi-&gt;s_rsv_window_root = RB_ROOT;
 	/*
<span class="p_header">diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c</span>
<span class="p_header">index d7ccb7f..3c73b8e 100644</span>
<span class="p_header">--- a/fs/ext4/extents.c</span>
<span class="p_header">+++ b/fs/ext4/extents.c</span>
<span class="p_chunk">@@ -3154,17 +3154,17 @@</span> <span class="p_context"> static int ext4_ext_zeroout(struct inode *inode, struct ext4_extent *ex)</span>
  * @handle: the journal handle
  * @inode: the file inode
  * @path: the path to the extent
<span class="p_del">- * @split: the logical block where the extent is splitted.</span>
<span class="p_add">+ * @split: the logical block where the extent is split.</span>
  * @split_flags: indicates if the extent could be zeroout if split fails, and
  *		 the states(init or unwritten) of new extents.
  * @flags: flags used to insert new extent to extent tree.
  *
  *
  * Splits extent [a, b] into two extents [a, @split) and [@split, b], states
<span class="p_del">- * of which are deterimined by split_flag.</span>
<span class="p_add">+ * of which are determined by split_flag.</span>
  *
  * There are two cases:
<span class="p_del">- *  a&gt; the extent are splitted into two extent.</span>
<span class="p_add">+ *  a&gt; the extent are split into two extents.</span>
  *  b&gt; split is not needed, and just mark the extent.
  *
  * return 0 on success.
<span class="p_header">diff --git a/fs/ext4/file.c b/fs/ext4/file.c</span>
<span class="p_header">index 261ac37..390af1a 100644</span>
<span class="p_header">--- a/fs/ext4/file.c</span>
<span class="p_header">+++ b/fs/ext4/file.c</span>
<span class="p_chunk">@@ -253,7 +253,7 @@</span> <span class="p_context"> static int ext4_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,</span>
 
 /*
  * Handle write fault for VM_MIXEDMAP mappings. Similarly to ext4_dax_fault()
<span class="p_del">- * handler we check for races agaist truncate. Note that since we cycle through</span>
<span class="p_add">+ * handler we check for races against truncate. Note that since we cycle through</span>
  * i_mmap_sem, we are sure that also any hole punching that began before we
  * were called is finished by now and so if it included part of the file we
  * are working on, our pte will get unmapped and the check for pte_same() in
<span class="p_header">diff --git a/fs/fuse/file.c b/fs/fuse/file.c</span>
<span class="p_header">index f394aff..d48b682 100644</span>
<span class="p_header">--- a/fs/fuse/file.c</span>
<span class="p_header">+++ b/fs/fuse/file.c</span>
<span class="p_chunk">@@ -564,7 +564,7 @@</span> <span class="p_context"> static ssize_t fuse_get_res_by_io(struct fuse_io_priv *io)</span>
  * == bytes_transferred or rw == WRITE, the caller sets &#39;pos&#39; to -1.
  *
  * An example:
<span class="p_del">- * User requested DIO read of 64K. It was splitted into two 32K fuse requests,</span>
<span class="p_add">+ * User requested DIO read of 64K. It was split into two 32K fuse requests,</span>
  * both submitted asynchronously. The first of them was ACKed by userspace as
  * fully completed (req-&gt;out.args[0].size == 32K) resulting in pos == -1. The
  * second request was ACKed as short, e.g. only 1K was read, resulting in
<span class="p_header">diff --git a/fs/inode.c b/fs/inode.c</span>
<span class="p_header">index 7e3ef3a..00395d3 100644</span>
<span class="p_header">--- a/fs/inode.c</span>
<span class="p_header">+++ b/fs/inode.c</span>
<span class="p_chunk">@@ -119,7 +119,7 @@</span> <span class="p_context"> static int no_open(struct inode *inode, struct file *file)</span>
 }
 
 /**
<span class="p_del">- * inode_init_always - perform inode structure intialisation</span>
<span class="p_add">+ * inode_init_always - perform inode structure initialisation</span>
  * @sb: superblock inode belongs to
  * @inode: inode to initialise
  *
<span class="p_chunk">@@ -1317,7 +1317,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(ilookup);</span>
  * function must never block --- find_inode() can block in
  * __wait_on_freeing_inode() --- or when the caller can not increment
  * the reference count because the resulting iput() might cause an
<span class="p_del">- * inode eviction.  The tradeoff is that the @match funtion must be</span>
<span class="p_add">+ * inode eviction.  The tradeoff is that the @match function must be</span>
  * very carefully implemented.
  */
 struct inode *find_inode_nowait(struct super_block *sb,
<span class="p_header">diff --git a/fs/namespace.c b/fs/namespace.c</span>
<span class="p_header">index 7bb2cda..87dbdfe 100644</span>
<span class="p_header">--- a/fs/namespace.c</span>
<span class="p_header">+++ b/fs/namespace.c</span>
<span class="p_chunk">@@ -1414,7 +1414,7 @@</span> <span class="p_context"> static void umount_tree(struct mount *mnt, enum umount_tree_flags how)</span>
 		list_del_init(&amp;p-&gt;mnt_child);
 	}
 
<span class="p_del">-	/* Add propogated mounts to the tmp_list */</span>
<span class="p_add">+	/* Add propagated mounts to the tmp_list */</span>
 	if (how &amp; UMOUNT_PROPAGATE)
 		propagate_umount(&amp;tmp_list);
 
<span class="p_chunk">@@ -2670,7 +2670,7 @@</span> <span class="p_context"> long do_mount(const char *dev_name, const char __user *dir_name,</span>
 	if (retval)
 		goto dput_out;
 
<span class="p_del">-	/* Default to relatime unless overriden */</span>
<span class="p_add">+	/* Default to relatime unless overridden */</span>
 	if (!(flags &amp; MS_NOATIME))
 		mnt_flags |= MNT_RELATIME;
 
<span class="p_header">diff --git a/fs/nfsd/nfs4callback.c b/fs/nfsd/nfs4callback.c</span>
<span class="p_header">index 04c68d9..349a36f 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4callback.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4callback.c</span>
<span class="p_chunk">@@ -389,7 +389,7 @@</span> <span class="p_context"> static void encode_cb_sequence4args(struct xdr_stream *xdr,</span>
  *		void;
  *	};
  *
<span class="p_del">- * Our current back channel implmentation supports a single backchannel</span>
<span class="p_add">+ * Our current back channel implementation supports a single backchannel</span>
  * with a single slot.
  */
 static int decode_cb_sequence4resok(struct xdr_stream *xdr,
<span class="p_header">diff --git a/fs/ntfs/logfile.c b/fs/ntfs/logfile.c</span>
<span class="p_header">index 761f12f..d1072d5 100644</span>
<span class="p_header">--- a/fs/ntfs/logfile.c</span>
<span class="p_header">+++ b/fs/ntfs/logfile.c</span>
<span class="p_chunk">@@ -422,7 +422,7 @@</span> <span class="p_context"> static int ntfs_check_and_load_restart_page(struct inode *vi,</span>
 			&amp;&amp; post_read_mst_fixup((NTFS_RECORD*)trp,
 			le32_to_cpu(rp-&gt;system_page_size))) {
 		/*
<span class="p_del">-		 * A multi sector tranfer error was detected.  We only need to</span>
<span class="p_add">+		 * A multi sector transfer error was detected.  We only need to</span>
 		 * abort if the restart page contents exceed the multi sector
 		 * transfer fixup of the first sector.
 		 */
<span class="p_chunk">@@ -535,7 +535,7 @@</span> <span class="p_context"> bool ntfs_check_logfile(struct inode *log_vi, RESTART_PAGE_HEADER **rp)</span>
 	 * page header is at the beginning of a page we only need to search at
 	 * what could be the beginning of a page (for each page size) rather
 	 * than scanning the whole file byte by byte.  If all potential places
<span class="p_del">-	 * contain empty and uninitialzed records, the log file can be assumed</span>
<span class="p_add">+	 * contain empty and uninitialized records, the log file can be assumed</span>
 	 * to be empty.
 	 */
 	for (pos = 0; pos &lt; size; pos &lt;&lt;= 1) {
<span class="p_header">diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c</span>
<span class="p_header">index 526040e..cb60ac2 100644</span>
<span class="p_header">--- a/fs/orangefs/file.c</span>
<span class="p_header">+++ b/fs/orangefs/file.c</span>
<span class="p_chunk">@@ -641,7 +641,7 @@</span> <span class="p_context"> static int orangefs_fsync(struct file *file,</span>
 /*
  * Change the file pointer position for an instance of an open file.
  *
<span class="p_del">- * \note If .llseek is overriden, we must acquire lock as described in</span>
<span class="p_add">+ * \note If .llseek is overridden, we must acquire lock as described in</span>
  *       Documentation/filesystems/Locking.
  *
  * Future upgrade could support SEEK_DATA and SEEK_HOLE but would
<span class="p_header">diff --git a/fs/read_write.c b/fs/read_write.c</span>
<span class="p_header">index 66215a7..bee3097 100644</span>
<span class="p_header">--- a/fs/read_write.c</span>
<span class="p_header">+++ b/fs/read_write.c</span>
<span class="p_chunk">@@ -138,7 +138,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(generic_file_llseek_size);</span>
  * @offset:	file offset to seek to
  * @whence:	type of seek
  *
<span class="p_del">- * This is a generic implemenation of -&gt;llseek useable for all normal local</span>
<span class="p_add">+ * This is a generic implementation of -&gt;llseek useable for all normal local</span>
  * filesystems.  It just updates the file offset to the value specified by
  * @offset and @whence.
  */
<span class="p_header">diff --git a/fs/reiserfs/fix_node.c b/fs/reiserfs/fix_node.c</span>
<span class="p_header">index 6b0ddb2..fb10459 100644</span>
<span class="p_header">--- a/fs/reiserfs/fix_node.c</span>
<span class="p_header">+++ b/fs/reiserfs/fix_node.c</span>
<span class="p_chunk">@@ -610,8 +610,8 @@</span> <span class="p_context"> static int get_num_ver(int mode, struct tree_balance *tb, int h,</span>
  *	h	current level of the node;
  *	lnum	number of items from S[h] that must be shifted to L[h];
  *	rnum	number of items from S[h] that must be shifted to R[h];
<span class="p_del">- *	blk_num	number of blocks that S[h] will be splitted into;</span>
<span class="p_del">- *	s012	number of items that fall into splitted nodes.</span>
<span class="p_add">+ *	blk_num	number of blocks that S[h] will be split into;</span>
<span class="p_add">+ *	s012	number of items that fall into split nodes.</span>
  *	lbytes	number of bytes which flow to the left neighbor from the
  *              item that is not not shifted entirely
  *	rbytes	number of bytes which flow to the right neighbor from the
<span class="p_chunk">@@ -1545,7 +1545,7 @@</span> <span class="p_context"> static int ip_check_balance(struct tree_balance *tb, int h)</span>
 		 * l_shift_num first items and l_shift_bytes of the right
 		 * most liquid item to be shifted are shifted to the left
 		 * neighbor, as well as number of items in each part of the
<span class="p_del">-		 * splitted node (s012 numbers), and number of bytes</span>
<span class="p_add">+		 * split node (s012 numbers), and number of bytes</span>
 		 * (s1bytes) of the shared drop which flow to S1 if any
 		 */
 		lset = LEFT_SHIFT_NO_FLOW;
<span class="p_chunk">@@ -1569,7 +1569,7 @@</span> <span class="p_context"> static int ip_check_balance(struct tree_balance *tb, int h)</span>
 		 * calculate number of blocks S[h] must be split into when
 		 * r_shift_num first items and r_shift_bytes of the left most
 		 * liquid item to be shifted are shifted to the right neighbor,
<span class="p_del">-		 * as well as number of items in each part of the splitted</span>
<span class="p_add">+		 * as well as number of items in each part of the split</span>
 		 * node (s012 numbers), and number of bytes (s1bytes) of the
 		 * shared drop which flow to S1 if any
 		 */
<span class="p_chunk">@@ -1599,7 +1599,7 @@</span> <span class="p_context"> static int ip_check_balance(struct tree_balance *tb, int h)</span>
 		/*
 		 * calculate number of blocks S[h] must be split into when
 		 * items are shifted in both directions, as well as number
<span class="p_del">-		 * of items in each part of the splitted node (s012 numbers),</span>
<span class="p_add">+		 * of items in each part of the split node (s012 numbers),</span>
 		 * and number of bytes (s1bytes) of the shared drop which
 		 * flow to S1 if any
 		 */
<span class="p_header">diff --git a/fs/tracefs/inode.c b/fs/tracefs/inode.c</span>
<span class="p_header">index ad40b64..8e9b8f8 100644</span>
<span class="p_header">--- a/fs/tracefs/inode.c</span>
<span class="p_header">+++ b/fs/tracefs/inode.c</span>
<span class="p_chunk">@@ -591,7 +591,7 @@</span> <span class="p_context"> void tracefs_remove_recursive(struct dentry *dentry)</span>
 			simple_release_fs(&amp;tracefs_mount, &amp;tracefs_mount_count);
 
 		/*
<span class="p_del">-		 * The parent-&gt;d_lock protects agaist child from unlinking</span>
<span class="p_add">+		 * The parent-&gt;d_lock protects against child from unlinking</span>
 		 * from d_subdirs. When releasing the parent-&gt;d_lock we can
 		 * no longer trust that the next pointer is valid.
 		 * Restart the loop. We&#39;ll skip this one with the
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_fs.h b/fs/xfs/libxfs/xfs_fs.h</span>
<span class="p_header">index 7945505..db92f2f 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_fs.h</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_fs.h</span>
<span class="p_chunk">@@ -283,7 +283,7 @@</span> <span class="p_context"> typedef struct xfs_bstat {</span>
 
 /*
  * Project quota id helpers (previously projid was 16bit only
<span class="p_del">- * and using two 16bit values to hold new 32bit projid was choosen</span>
<span class="p_add">+ * and using two 16bit values to hold new 32bit projid was chosen</span>
  * to retain compatibility with &quot;old&quot; filesystems).
  */
 static inline __uint32_t
<span class="p_header">diff --git a/fs/xfs/xfs_log_recover.c b/fs/xfs/xfs_log_recover.c</span>
<span class="p_header">index e8638fd..abaf8bd 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_log_recover.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_log_recover.c</span>
<span class="p_chunk">@@ -3518,7 +3518,7 @@</span> <span class="p_context"> xlog_recover_rud_pass2(</span>
  * This routine is called when an inode create format structure is found in a
  * committed transaction in the log.  It&#39;s purpose is to initialise the inodes
  * being allocated on disk. This requires us to get inode cluster buffers that
<span class="p_del">- * match the range to be intialised, stamped with inode templates and written</span>
<span class="p_add">+ * match the range to be initialised, stamped with inode templates and written</span>
  * by delayed write so that subsequent modifications will hit the cached buffer
  * and only need writing out at the end of recovery.
  */
<span class="p_header">diff --git a/fs/xfs/xfs_trans_ail.c b/fs/xfs/xfs_trans_ail.c</span>
<span class="p_header">index d6c9c3e..3ed0147 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_trans_ail.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_trans_ail.c</span>
<span class="p_chunk">@@ -399,9 +399,9 @@</span> <span class="p_context"> xfsaild_push(</span>
 			 * updates to it as part of inode clustering.
 			 *
 			 * We do not want to to stop flushing just because lots
<span class="p_del">-			 * of items are already beeing flushed, but we need to</span>
<span class="p_add">+			 * of items are already being flushed, but we need to</span>
 			 * re-try the flushing relatively soon if most of the
<span class="p_del">-			 * AIL is beeing flushed.</span>
<span class="p_add">+			 * AIL is being flushed.</span>
 			 */
 			XFS_STATS_INC(mp, xs_push_ail_flushing);
 			trace_xfs_ail_flushing(lip);
<span class="p_chunk">@@ -547,7 +547,7 @@</span> <span class="p_context"> xfsaild(</span>
  * The push is run asynchronously in a workqueue, which means the caller needs
  * to handle waiting on the async flush for space to become available.
  * We don&#39;t want to interrupt any push that is in progress, hence we only queue
<span class="p_del">- * work if we set the pushing bit approriately.</span>
<span class="p_add">+ * work if we set the pushing bit appropriately.</span>
  *
  * We do this unlocked - we only need to know whether there is anything in the
  * AIL at the time we are called. We don&#39;t need to access the contents of
<span class="p_header">diff --git a/include/linux/cgroup-defs.h b/include/linux/cgroup-defs.h</span>
<span class="p_header">index 5b17de6..f7d324b 100644</span>
<span class="p_header">--- a/include/linux/cgroup-defs.h</span>
<span class="p_header">+++ b/include/linux/cgroup-defs.h</span>
<span class="p_chunk">@@ -568,7 +568,7 @@</span> <span class="p_context"> static inline void cgroup_threadgroup_change_end(struct task_struct *tsk) {}</span>
  * sock_cgroup_data overloads (prioidx, classid) and the cgroup pointer.
  * On boot, sock_cgroup_data records the cgroup that the sock was created
  * in so that cgroup2 matches can be made; however, once either net_prio or
<span class="p_del">- * net_cls starts being used, the area is overriden to carry prioidx and/or</span>
<span class="p_add">+ * net_cls starts being used, the area is overridden to carry prioidx and/or</span>
  * classid.  The two modes are distinguished by whether the lowest bit is
  * set.  Clear bit indicates cgroup pointer while set bit prioidx and
  * classid.
<span class="p_header">diff --git a/include/linux/irqchip.h b/include/linux/irqchip.h</span>
<span class="p_header">index 89c34b2..950e4b2 100644</span>
<span class="p_header">--- a/include/linux/irqchip.h</span>
<span class="p_header">+++ b/include/linux/irqchip.h</span>
<span class="p_chunk">@@ -19,7 +19,7 @@</span> <span class="p_context"></span>
  * the association between their DT compatible string and their
  * initialization function.
  *
<span class="p_del">- * @name: name that must be unique accross all IRQCHIP_DECLARE of the</span>
<span class="p_add">+ * @name: name that must be unique across all IRQCHIP_DECLARE of the</span>
  * same file.
  * @compstr: compatible string of the irqchip driver
  * @fn: initialization function
<span class="p_chunk">@@ -30,7 +30,7 @@</span> <span class="p_context"></span>
  * This macro must be used by the different irqchip drivers to declare
  * the association between their version and their initialization function.
  *
<span class="p_del">- * @name: name that must be unique accross all IRQCHIP_ACPI_DECLARE of the</span>
<span class="p_add">+ * @name: name that must be unique across all IRQCHIP_ACPI_DECLARE of the</span>
  * same file.
  * @subtable: Subtable to be identified in MADT
  * @validate: Function to be called on that subtable to check its validity.
<span class="p_header">diff --git a/include/linux/kconfig.h b/include/linux/kconfig.h</span>
<span class="p_header">index 15ec117..7279f68 100644</span>
<span class="p_header">--- a/include/linux/kconfig.h</span>
<span class="p_header">+++ b/include/linux/kconfig.h</span>
<span class="p_chunk">@@ -8,7 +8,7 @@</span> <span class="p_context"></span>
 
 /*
  * The use of &quot;&amp;&amp;&quot; / &quot;||&quot; is limited in certain expressions.
<span class="p_del">- * The followings enable to calculate &quot;and&quot; / &quot;or&quot; with macro expansion only.</span>
<span class="p_add">+ * The following enable to calculate &quot;and&quot; / &quot;or&quot; with macro expansion only.</span>
  */
 #define __and(x, y)			___and(x, y)
 #define ___and(x, y)			____and(__ARG_PLACEHOLDER_##x, y)
<span class="p_header">diff --git a/include/linux/mfd/max77693-private.h b/include/linux/mfd/max77693-private.h</span>
<span class="p_header">index 3c7a63b..0a71e4a 100644</span>
<span class="p_header">--- a/include/linux/mfd/max77693-private.h</span>
<span class="p_header">+++ b/include/linux/mfd/max77693-private.h</span>
<span class="p_chunk">@@ -418,7 +418,7 @@</span> <span class="p_context"> enum max77693_haptic_reg {</span>
 	MAX77693_HAPTIC_REG_END,
 };
 
<span class="p_del">-/* max77693-pmic LSCNFG configuraton register */</span>
<span class="p_add">+/* max77693-pmic LSCNFG configuration register */</span>
 #define MAX77693_PMIC_LOW_SYS_MASK      0x80
 #define MAX77693_PMIC_LOW_SYS_SHIFT     7
 
<span class="p_header">diff --git a/include/linux/msi.h b/include/linux/msi.h</span>
<span class="p_header">index e8c81fb..e001ad9 100644</span>
<span class="p_header">--- a/include/linux/msi.h</span>
<span class="p_header">+++ b/include/linux/msi.h</span>
<span class="p_chunk">@@ -154,7 +154,7 @@</span> <span class="p_context"> static inline void unmask_msi_irq(struct irq_data *data)</span>
 
 /*
  * The arch hooks to setup up msi irqs. Those functions are
<span class="p_del">- * implemented as weak symbols so that they /can/ be overriden by</span>
<span class="p_add">+ * implemented as weak symbols so that they /can/ be overridden by</span>
  * architecture specific code if needed.
  */
 int arch_setup_msi_irq(struct pci_dev *dev, struct msi_desc *desc);
<span class="p_header">diff --git a/include/linux/mtd/qinfo.h b/include/linux/mtd/qinfo.h</span>
<span class="p_header">index 7b3d487..b532ce5 100644</span>
<span class="p_header">--- a/include/linux/mtd/qinfo.h</span>
<span class="p_header">+++ b/include/linux/mtd/qinfo.h</span>
<span class="p_chunk">@@ -14,7 +14,7 @@</span> <span class="p_context"></span>
  * @DevId - Chip Device ID
  * @qinfo - pointer to qinfo records describing the chip
  * @numchips - number of chips including virual RWW partitions
<span class="p_del">- * @chipshift - Chip/partiton size 2^chipshift</span>
<span class="p_add">+ * @chipshift - Chip/partition size 2^chipshift</span>
  * @chips - per-chip data structure
  */
 struct lpddr_private {
<span class="p_header">diff --git a/include/linux/pci.h b/include/linux/pci.h</span>
<span class="p_header">index fbc1fa6..9628f2e 100644</span>
<span class="p_header">--- a/include/linux/pci.h</span>
<span class="p_header">+++ b/include/linux/pci.h</span>
<span class="p_chunk">@@ -802,7 +802,7 @@</span> <span class="p_context"> resource_size_t pcibios_align_resource(void *, const struct resource *,</span>
 				resource_size_t);
 void pcibios_update_irq(struct pci_dev *, int irq);
 
<span class="p_del">-/* Weak but can be overriden by arch */</span>
<span class="p_add">+/* Weak but can be overridden by arch */</span>
 void pci_fixup_cardbus(struct pci_bus *);
 
 /* Generic PCI functions used internally */
<span class="p_header">diff --git a/include/linux/reboot.h b/include/linux/reboot.h</span>
<span class="p_header">index a7ff409..f6c198a 100644</span>
<span class="p_header">--- a/include/linux/reboot.h</span>
<span class="p_header">+++ b/include/linux/reboot.h</span>
<span class="p_chunk">@@ -56,7 +56,7 @@</span> <span class="p_context"> struct pt_regs;</span>
 extern void machine_crash_shutdown(struct pt_regs *);
 
 /*
<span class="p_del">- * Architecture independent implemenations of sys_reboot commands.</span>
<span class="p_add">+ * Architecture independent implementations of sys_reboot commands.</span>
  */
 
 extern void kernel_restart_prepare(char *cmd);
<span class="p_header">diff --git a/include/linux/spi/flash.h b/include/linux/spi/flash.h</span>
<span class="p_header">index 3f22932..f4199e7 100644</span>
<span class="p_header">--- a/include/linux/spi/flash.h</span>
<span class="p_header">+++ b/include/linux/spi/flash.h</span>
<span class="p_chunk">@@ -7,7 +7,7 @@</span> <span class="p_context"> struct mtd_partition;</span>
  * struct flash_platform_data: board-specific flash data
  * @name: optional flash device name (eg, as used with mtdparts=)
  * @parts: optional array of mtd_partitions for static partitioning
<span class="p_del">- * @nr_parts: number of mtd_partitions for static partitoning</span>
<span class="p_add">+ * @nr_parts: number of mtd_partitions for static partitioning</span>
  * @type: optional flash device type (e.g. m25p80 vs m25p64), for use
  *	with chips that can&#39;t be queried for JEDEC or other IDs
  *
<span class="p_header">diff --git a/include/linux/vmalloc.h b/include/linux/vmalloc.h</span>
<span class="p_header">index 3d9d786..d218849 100644</span>
<span class="p_header">--- a/include/linux/vmalloc.h</span>
<span class="p_header">+++ b/include/linux/vmalloc.h</span>
<span class="p_chunk">@@ -23,7 +23,7 @@</span> <span class="p_context"> struct notifier_block;		/* in notifier.h */</span>
 
 /*
  * Maximum alignment for ioremap() regions.
<span class="p_del">- * Can be overriden by arch-specific value.</span>
<span class="p_add">+ * Can be overridden by arch-specific value.</span>
  */
 #ifndef IOREMAP_MAX_ORDER
 #define IOREMAP_MAX_ORDER	(7 + PAGE_SHIFT)	/* 128 pages */
<span class="p_header">diff --git a/include/net/cfg80211.h b/include/net/cfg80211.h</span>
<span class="p_header">index 9c23f4d3..48bc053 100644</span>
<span class="p_header">--- a/include/net/cfg80211.h</span>
<span class="p_header">+++ b/include/net/cfg80211.h</span>
<span class="p_chunk">@@ -1820,7 +1820,7 @@</span> <span class="p_context"> struct cfg80211_deauth_request {</span>
  * struct cfg80211_disassoc_request - Disassociation request data
  *
  * This structure provides information needed to complete IEEE 802.11
<span class="p_del">- * disassocation.</span>
<span class="p_add">+ * disassociation.</span>
  *
  * @bss: the BSS to disassociate from
  * @ie: Extra IEs to add to Disassociation frame or %NULL
<span class="p_chunk">@@ -2227,7 +2227,7 @@</span> <span class="p_context"> struct cfg80211_update_ft_ies_params {</span>
  * This structure provides information needed to transmit a mgmt frame
  *
  * @chan: channel to use
<span class="p_del">- * @offchan: indicates wether off channel operation is required</span>
<span class="p_add">+ * @offchan: indicates whether off channel operation is required</span>
  * @wait: duration for ROC
  * @buf: buffer to transmit
  * @len: buffer length
<span class="p_chunk">@@ -4450,7 +4450,7 @@</span> <span class="p_context"> void cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,</span>
  * @dev: network device
  * @macaddr: the MAC address of the new candidate
  * @ie: information elements advertised by the peer candidate
<span class="p_del">- * @ie_len: lenght of the information elements buffer</span>
<span class="p_add">+ * @ie_len: length of the information elements buffer</span>
  * @gfp: allocation flags
  *
  * This function notifies cfg80211 that the mesh peer candidate has been
<span class="p_header">diff --git a/include/net/ip_tunnels.h b/include/net/ip_tunnels.h</span>
<span class="p_header">index a5e7035..1526dd6 100644</span>
<span class="p_header">--- a/include/net/ip_tunnels.h</span>
<span class="p_header">+++ b/include/net/ip_tunnels.h</span>
<span class="p_chunk">@@ -328,7 +328,7 @@</span> <span class="p_context"> static inline u8 ip_tunnel_get_dsfield(const struct iphdr *iph,</span>
 		return 0;
 }
 
<span class="p_del">-/* Propogate ECN bits out */</span>
<span class="p_add">+/* Propagate ECN bits out */</span>
 static inline u8 ip_tunnel_ecn_encap(u8 tos, const struct iphdr *iph,
 				     const struct sk_buff *skb)
 {
<span class="p_header">diff --git a/include/net/irda/timer.h b/include/net/irda/timer.h</span>
<span class="p_header">index cb2615c..d784f24 100644</span>
<span class="p_header">--- a/include/net/irda/timer.h</span>
<span class="p_header">+++ b/include/net/irda/timer.h</span>
<span class="p_chunk">@@ -59,7 +59,7 @@</span> <span class="p_context"> struct lap_cb;</span>
  *  Slot timer must never exceed 85 ms, and must always be at least 25 ms, 
  *  suggested to  75-85 msec by IrDA lite. This doesn&#39;t work with a lot of
  *  devices, and other stackes uses a lot more, so it&#39;s best we do it as well
<span class="p_del">- *  (Note : this is the default value and sysctl overides it - Jean II)</span>
<span class="p_add">+ *  (Note : this is the default value and sysctl overrides it - Jean II)</span>
  */
 #define SLOT_TIMEOUT            (90*HZ/1000)
 
<span class="p_header">diff --git a/include/net/iw_handler.h b/include/net/iw_handler.h</span>
<span class="p_header">index e0f4109..5b1073e 100644</span>
<span class="p_header">--- a/include/net/iw_handler.h</span>
<span class="p_header">+++ b/include/net/iw_handler.h</span>
<span class="p_chunk">@@ -37,7 +37,7 @@</span> <span class="p_context"></span>
  * -------------------------------
  * The new driver API is just a bunch of standard functions (handlers),
  * each handling a specific Wireless Extension. The driver just export
<span class="p_del">- * the list of handler it supports, and those will be called apropriately.</span>
<span class="p_add">+ * the list of handler it supports, and those will be called appropriately.</span>
  *
  * I tried to keep the main advantage of the previous API (simplicity,
  * efficiency and light weight), and also I provide a good dose of backward
<span class="p_chunk">@@ -139,7 +139,7 @@</span> <span class="p_context"></span>
  * example to distinguish setting max rate and basic rate), I would
  * break the prototype. Using iwreq_data is more flexible.
  * 3) Also, the above form is not generic (see above).
<span class="p_del">- * 4) I don&#39;t expect driver developper using the wrong field of the</span>
<span class="p_add">+ * 4) I don&#39;t expect driver developer using the wrong field of the</span>
  * union (Doh !), so static typechecking doesn&#39;t add much value.
  * 5) Lastly, you can skip the union by doing :
  *	static int mydriver_ioctl_setrate(struct net_device *dev,
<span class="p_header">diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h</span>
<span class="p_header">index ce93c4b..82dd085 100644</span>
<span class="p_header">--- a/include/net/sctp/structs.h</span>
<span class="p_header">+++ b/include/net/sctp/structs.h</span>
<span class="p_chunk">@@ -1175,7 +1175,7 @@</span> <span class="p_context"> typedef enum {</span>
 } sctp_endpoint_type_t;
 
 /*
<span class="p_del">- * A common base class to bridge the implmentation view of a</span>
<span class="p_add">+ * A common base class to bridge the implementation view of a</span>
  * socket (usually listening) endpoint versus an association&#39;s
  * local endpoint.
  * This common structure is useful for several purposes:
<span class="p_header">diff --git a/include/target/iscsi/iscsi_target_core.h b/include/target/iscsi/iscsi_target_core.h</span>
<span class="p_header">index 4ac24f5..c45af45 100644</span>
<span class="p_header">--- a/include/target/iscsi/iscsi_target_core.h</span>
<span class="p_header">+++ b/include/target/iscsi/iscsi_target_core.h</span>
<span class="p_chunk">@@ -54,7 +54,7 @@</span> <span class="p_context"></span>
 #define TA_CACHE_DYNAMIC_ACLS		0
 /* Enabled by default in demo mode (generic_node_acls=1) */
 #define TA_DEMO_MODE_WRITE_PROTECT	1
<span class="p_del">-/* Disabled by default in production mode w/ explict ACLs */</span>
<span class="p_add">+/* Disabled by default in production mode w/ explicit ACLs */</span>
 #define TA_PROD_MODE_WRITE_PROTECT	0
 #define TA_DEMO_MODE_DISCOVERY		1
 #define TA_DEFAULT_ERL			0
<span class="p_header">diff --git a/include/uapi/linux/atmbr2684.h b/include/uapi/linux/atmbr2684.h</span>
<span class="p_header">index fdb2629..d6dbf43 100644</span>
<span class="p_header">--- a/include/uapi/linux/atmbr2684.h</span>
<span class="p_header">+++ b/include/uapi/linux/atmbr2684.h</span>
<span class="p_chunk">@@ -37,7 +37,7 @@</span> <span class="p_context"></span>
  */
 #define BR2684_ENCAPS_VC	(0)	/* VC-mux */
 #define BR2684_ENCAPS_LLC	(1)
<span class="p_del">-#define BR2684_ENCAPS_AUTODETECT (2)	/* Unsuported */</span>
<span class="p_add">+#define BR2684_ENCAPS_AUTODETECT (2)	/* Unsupported */</span>
 
 /*
  * Is this VC bridged or routed?
<span class="p_header">diff --git a/include/uapi/linux/nfsd/nfsfh.h b/include/uapi/linux/nfsd/nfsfh.h</span>
<span class="p_header">index 2039123..46858f1 100644</span>
<span class="p_header">--- a/include/uapi/linux/nfsd/nfsfh.h</span>
<span class="p_header">+++ b/include/uapi/linux/nfsd/nfsfh.h</span>
<span class="p_chunk">@@ -98,7 +98,7 @@</span> <span class="p_context"> struct knfsd_fh {</span>
 #define	fh_fileid_type		fh_base.fh_new.fb_fileid_type
 #define	fh_fsid			fh_base.fh_new.fb_auth
 
<span class="p_del">-/* Do not use, provided for userspace compatiblity. */</span>
<span class="p_add">+/* Do not use, provided for userspace compatibility. */</span>
 #define	fh_auth			fh_base.fh_new.fb_auth
 
 #endif /* _UAPI_LINUX_NFSD_FH_H */
<span class="p_header">diff --git a/include/uapi/linux/pmu.h b/include/uapi/linux/pmu.h</span>
<span class="p_header">index caead36..7cf6eb9 100644</span>
<span class="p_header">--- a/include/uapi/linux/pmu.h</span>
<span class="p_header">+++ b/include/uapi/linux/pmu.h</span>
<span class="p_chunk">@@ -67,7 +67,7 @@</span> <span class="p_context"></span>
 #define PMU_INT_WAITING_CHARGER	0x01	/* ??? */
 #define PMU_INT_AUTO_SRQ_POLL	0x02	/* ??? */
 
<span class="p_del">-/* Bits in the environement message (either obtained via PMU_GET_COVER,</span>
<span class="p_add">+/* Bits in the environment message (either obtained via PMU_GET_COVER,</span>
  * or via PMU_INT_ENVIRONMENT on core99 */
 #define PMU_ENV_LID_CLOSED	0x01	/* The lid is closed */
 
<span class="p_header">diff --git a/include/uapi/linux/raid/md_p.h b/include/uapi/linux/raid/md_p.h</span>
<span class="p_header">index c3e654c..259a84c 100644</span>
<span class="p_header">--- a/include/uapi/linux/raid/md_p.h</span>
<span class="p_header">+++ b/include/uapi/linux/raid/md_p.h</span>
<span class="p_chunk">@@ -79,10 +79,10 @@</span> <span class="p_context"></span>
 #define MD_DISK_SYNC		2 /* disk is in sync with the raid set */
 #define MD_DISK_REMOVED		3 /* disk is in sync with the raid set */
 #define MD_DISK_CLUSTER_ADD     4 /* Initiate a disk add across the cluster
<span class="p_del">-				   * For clustered enviroments only.</span>
<span class="p_add">+				   * For clustered environments only.</span>
 				   */
 #define MD_DISK_CANDIDATE	5 /* disk is added as spare (local) until confirmed
<span class="p_del">-				   * For clustered enviroments only.</span>
<span class="p_add">+				   * For clustered environments only.</span>
 				   */
 
 #define	MD_DISK_WRITEMOSTLY	9 /* disk is &quot;write-mostly&quot; is RAID1 config.
<span class="p_header">diff --git a/include/uapi/linux/x25.h b/include/uapi/linux/x25.h</span>
<span class="p_header">index 810cce6..10c1c72 100644</span>
<span class="p_header">--- a/include/uapi/linux/x25.h</span>
<span class="p_header">+++ b/include/uapi/linux/x25.h</span>
<span class="p_chunk">@@ -66,7 +66,7 @@</span> <span class="p_context"> struct sockaddr_x25 {</span>
  *	DTE/DCE subscription options.
  *
  *      As this is missing lots of options, user should expect major
<span class="p_del">- *	changes of this structure in 2.5.x which might break compatibilty.</span>
<span class="p_add">+ *	changes of this structure in 2.5.x which might break compatibility.</span>
  *      The somewhat ugly dimension 200-sizeof() is needed to maintain
  *	backward compatibility.
  */
<span class="p_header">diff --git a/ipc/shm.c b/ipc/shm.c</span>
<span class="p_header">index dbac886..002afa7 100644</span>
<span class="p_header">--- a/ipc/shm.c</span>
<span class="p_header">+++ b/ipc/shm.c</span>
<span class="p_chunk">@@ -415,7 +415,7 @@</span> <span class="p_context"> static int shm_mmap(struct file *file, struct vm_area_struct *vma)</span>
 
 	/*
 	 * In case of remap_file_pages() emulation, the file can represent
<span class="p_del">-	 * removed IPC ID: propogate shm_lock() error to caller.</span>
<span class="p_add">+	 * removed IPC ID: propagate shm_lock() error to caller.</span>
 	 */
 	ret =__shm_open(vma);
 	if (ret)
<span class="p_header">diff --git a/kernel/cpu.c b/kernel/cpu.c</span>
<span class="p_header">index 341bf80..16208b5 100644</span>
<span class="p_header">--- a/kernel/cpu.c</span>
<span class="p_header">+++ b/kernel/cpu.c</span>
<span class="p_chunk">@@ -1360,7 +1360,7 @@</span> <span class="p_context"> static bool cpuhp_is_ap_state(enum cpuhp_state state)</span>
 {
 	/*
 	 * The extra check for CPUHP_TEARDOWN_CPU is only for documentation
<span class="p_del">-	 * purposes as that state is handled explicitely in cpu_down.</span>
<span class="p_add">+	 * purposes as that state is handled explicitly in cpu_down.</span>
 	 */
 	return state &gt; CPUHP_BRINGUP_CPU &amp;&amp; state != CPUHP_TEARDOWN_CPU;
 }
<span class="p_header">diff --git a/kernel/debug/debug_core.c b/kernel/debug/debug_core.c</span>
<span class="p_header">index 0874e2e..801007a 100644</span>
<span class="p_header">--- a/kernel/debug/debug_core.c</span>
<span class="p_header">+++ b/kernel/debug/debug_core.c</span>
<span class="p_chunk">@@ -163,7 +163,7 @@</span> <span class="p_context"> early_param(&quot;nokgdbroundup&quot;, opt_nokgdbroundup);</span>
 
 /*
  * Weak aliases for breakpoint management,
<span class="p_del">- * can be overriden by architectures when needed:</span>
<span class="p_add">+ * can be overridden by architectures when needed:</span>
  */
 int __weak kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt)
 {
<span class="p_header">diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c</span>
<span class="p_header">index 9530fcd..0fd0d44 100644</span>
<span class="p_header">--- a/kernel/irq/manage.c</span>
<span class="p_header">+++ b/kernel/irq/manage.c</span>
<span class="p_chunk">@@ -866,7 +866,7 @@</span> <span class="p_context"> irq_thread_check_affinity(struct irq_desc *desc, struct irqaction *action) { }</span>
 #endif
 
 /*
<span class="p_del">- * Interrupts which are not explicitely requested as threaded</span>
<span class="p_add">+ * Interrupts which are not explicitly requested as threaded</span>
  * interrupts rely on the implicit bh/preempt disable of the hard irq
  * context. So we need to disable bh here to avoid deadlocks and other
  * side effects.
<span class="p_header">diff --git a/kernel/irq/spurious.c b/kernel/irq/spurious.c</span>
<span class="p_header">index 5707f97..4994197 100644</span>
<span class="p_header">--- a/kernel/irq/spurious.c</span>
<span class="p_header">+++ b/kernel/irq/spurious.c</span>
<span class="p_chunk">@@ -68,7 +68,7 @@</span> <span class="p_context"> static int try_one_irq(struct irq_desc *desc, bool force)</span>
 	raw_spin_lock(&amp;desc-&gt;lock);
 
 	/*
<span class="p_del">-	 * PER_CPU, nested thread interrupts and interrupts explicitely</span>
<span class="p_add">+	 * PER_CPU, nested thread interrupts and interrupts explicitly</span>
 	 * marked polled are excluded from polling.
 	 */
 	if (irq_settings_is_per_cpu(desc) ||
<span class="p_chunk">@@ -78,7 +78,7 @@</span> <span class="p_context"> static int try_one_irq(struct irq_desc *desc, bool force)</span>
 
 	/*
 	 * Do not poll disabled interrupts unless the spurious
<span class="p_del">-	 * disabled poller asks explicitely.</span>
<span class="p_add">+	 * disabled poller asks explicitly.</span>
 	 */
 	if (irqd_irq_disabled(&amp;desc-&gt;irq_data) &amp;&amp; !force)
 		goto out;
<span class="p_header">diff --git a/kernel/relay.c b/kernel/relay.c</span>
<span class="p_header">index d797502..a58f539 100644</span>
<span class="p_header">--- a/kernel/relay.c</span>
<span class="p_header">+++ b/kernel/relay.c</span>
<span class="p_chunk">@@ -926,7 +926,7 @@</span> <span class="p_context"> static int relay_file_mmap(struct file *filp, struct vm_area_struct *vma)</span>
  *	@filp: the file
  *	@wait: poll table
  *
<span class="p_del">- *	Poll implemention.</span>
<span class="p_add">+ *	Poll implementation.</span>
  */
 static unsigned int relay_file_poll(struct file *filp, poll_table *wait)
 {
<span class="p_header">diff --git a/kernel/torture.c b/kernel/torture.c</span>
<span class="p_header">index 75961b3..fa2e4de 100644</span>
<span class="p_header">--- a/kernel/torture.c</span>
<span class="p_header">+++ b/kernel/torture.c</span>
<span class="p_chunk">@@ -310,7 +310,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(torture_random);</span>
 /*
  * Variables for shuffling.  The idea is to ensure that each CPU stays
  * idle for an extended period to test interactions with dyntick idle,
<span class="p_del">- * as well as interactions with any per-CPU varibles.</span>
<span class="p_add">+ * as well as interactions with any per-CPU variables.</span>
  */
 struct shuffle_task {
 	struct list_head st_l;
<span class="p_header">diff --git a/kernel/trace/trace_stack.c b/kernel/trace/trace_stack.c</span>
<span class="p_header">index 2a1abba..93a88d5 100644</span>
<span class="p_header">--- a/kernel/trace/trace_stack.c</span>
<span class="p_header">+++ b/kernel/trace/trace_stack.c</span>
<span class="p_chunk">@@ -64,7 +64,7 @@</span> <span class="p_context"> void stack_trace_print(void)</span>
 }
 
 /*
<span class="p_del">- * When arch-specific code overides this function, the following</span>
<span class="p_add">+ * When arch-specific code overrides this function, the following</span>
  * data should be filled up, assuming stack_trace_max_lock is held to
  * prevent concurrent updates.
  *     stack_trace_index[]
<span class="p_header">diff --git a/lib/Kconfig.ubsan b/lib/Kconfig.ubsan</span>
<span class="p_header">index 39494af..c3f6659 100644</span>
<span class="p_header">--- a/lib/Kconfig.ubsan</span>
<span class="p_header">+++ b/lib/Kconfig.ubsan</span>
<span class="p_chunk">@@ -15,7 +15,7 @@</span> <span class="p_context"> config UBSAN_SANITIZE_ALL</span>
 	depends on ARCH_HAS_UBSAN_SANITIZE_ALL
 
 	# We build with -Wno-maybe-uninitilzed, but we still want to
<span class="p_del">-	# use -Wmaybe-uninitilized in allmodconfig builds.</span>
<span class="p_add">+	# use -Wmaybe-uninitialized in allmodconfig builds.</span>
 	# So dependsy bellow used to disable this option in allmodconfig
 	depends on !COMPILE_TEST
 	default y
<span class="p_header">diff --git a/lib/radix-tree.c b/lib/radix-tree.c</span>
<span class="p_header">index 1b7bf73..0548856 100644</span>
<span class="p_header">--- a/lib/radix-tree.c</span>
<span class="p_header">+++ b/lib/radix-tree.c</span>
<span class="p_chunk">@@ -927,7 +927,7 @@</span> <span class="p_context"> void **radix_tree_next_chunk(struct radix_tree_root *root,</span>
 	 * because RADIX_TREE_MAP_SHIFT &lt; BITS_PER_LONG.
 	 *
 	 * This condition also used by radix_tree_next_slot() to stop
<span class="p_del">-	 * contiguous iterating, and forbid swithing to the next chunk.</span>
<span class="p_add">+	 * contiguous iterating, and forbid switching to the next chunk.</span>
 	 */
 	index = iter-&gt;next_index;
 	if (!index &amp;&amp; iter-&gt;index)
<span class="p_header">diff --git a/lib/xz/xz_dec_lzma2.c b/lib/xz/xz_dec_lzma2.c</span>
<span class="p_header">index 08c3c80..9abed55 100644</span>
<span class="p_header">--- a/lib/xz/xz_dec_lzma2.c</span>
<span class="p_header">+++ b/lib/xz/xz_dec_lzma2.c</span>
<span class="p_chunk">@@ -484,11 +484,11 @@</span> <span class="p_context"> static __always_inline void rc_normalize(struct rc_dec *rc)</span>
 }
 
 /*
<span class="p_del">- * Decode one bit. In some versions, this function has been splitted in three</span>
<span class="p_add">+ * Decode one bit. In some versions, this function has been split in three</span>
  * functions so that the compiler is supposed to be able to more easily avoid
  * an extra branch. In this particular version of the LZMA decoder, this
  * doesn&#39;t seem to be a good idea (tested with GCC 3.3.6, 3.4.6, and 4.3.3
<span class="p_del">- * on x86). Using a non-splitted version results in nicer looking code too.</span>
<span class="p_add">+ * on x86). Using a non-split version results in nicer looking code too.</span>
  *
  * NOTE: This must return an int. Do not make it return a bool or the speed
  * of the code generated by GCC 3.x decreases 10-15 %. (GCC 4.3 doesn&#39;t care,
<span class="p_header">diff --git a/mm/memcontrol.c b/mm/memcontrol.c</span>
<span class="p_header">index 9a6a51a..d01730d4 100644</span>
<span class="p_header">--- a/mm/memcontrol.c</span>
<span class="p_header">+++ b/mm/memcontrol.c</span>
<span class="p_chunk">@@ -1633,7 +1633,7 @@</span> <span class="p_context"> bool mem_cgroup_oom_synchronize(bool handle)</span>
 		/*
 		 * There is no guarantee that an OOM-lock contender
 		 * sees the wakeups triggered by the OOM kill
<span class="p_del">-		 * uncharges.  Wake any sleepers explicitely.</span>
<span class="p_add">+		 * uncharges.  Wake any sleepers explicitly.</span>
 		 */
 		memcg_oom_recover(memcg);
 	}
<span class="p_chunk">@@ -4243,7 +4243,7 @@</span> <span class="p_context"> mem_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)</span>
 		page_counter_init(&amp;memcg-&gt;kmem, NULL);
 		page_counter_init(&amp;memcg-&gt;tcpmem, NULL);
 		/*
<span class="p_del">-		 * Deeper hierachy with use_hierarchy == false doesn&#39;t make</span>
<span class="p_add">+		 * Deeper hierarchy with use_hierarchy == false doesn&#39;t make</span>
 		 * much sense so let cgroup subsystem know about this
 		 * unfortunate state in our controller.
 		 */
<span class="p_chunk">@@ -4805,7 +4805,7 @@</span> <span class="p_context"> static int mem_cgroup_can_attach(struct cgroup_taskset *tset)</span>
 		return 0;
 
 	/*
<span class="p_del">-	 * We are now commited to this value whatever it is. Changes in this</span>
<span class="p_add">+	 * We are now committed to this value whatever it is. Changes in this</span>
 	 * tunable will only affect upcoming migrations, not the current one.
 	 * So we need to save it, and keep it going.
 	 */
<span class="p_header">diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="p_header">index 3fbe73a..25d1f25 100644</span>
<span class="p_header">--- a/mm/page_alloc.c</span>
<span class="p_header">+++ b/mm/page_alloc.c</span>
<span class="p_chunk">@@ -5788,7 +5788,7 @@</span> <span class="p_context"> static unsigned long __paginginit calc_memmap_size(unsigned long spanned_pages,</span>
 	 * the zone and SPARSEMEM is in use. If there are holes within the
 	 * zone, each populated memory region may cost us one or two extra
 	 * memmap pages due to alignment because memmap pages for each
<span class="p_del">-	 * populated regions may not naturally algined on page boundary.</span>
<span class="p_add">+	 * populated regions may not be naturally aligned on page boundary.</span>
 	 * So the (present_pages &gt;&gt; 4) heuristic is a tradeoff for that.
 	 */
 	if (spanned_pages &gt; present_pages + (present_pages &gt;&gt; 4) &amp;&amp;
<span class="p_header">diff --git a/mm/percpu.c b/mm/percpu.c</span>
<span class="p_header">index 9903830..8f13edb 100644</span>
<span class="p_header">--- a/mm/percpu.c</span>
<span class="p_header">+++ b/mm/percpu.c</span>
<span class="p_chunk">@@ -43,7 +43,7 @@</span> <span class="p_context"></span>
  * Chunks can be determined from the address using the index field
  * in the page struct. The index field contains a pointer to the chunk.
  *
<span class="p_del">- * To use this allocator, arch code should do the followings.</span>
<span class="p_add">+ * To use this allocator, arch code should do the following:</span>
  *
  * - define __addr_to_pcpu_ptr() and __pcpu_ptr_to_addr() to translate
  *   regular address to percpu pointer and back if they need to be
<span class="p_chunk">@@ -385,7 +385,7 @@</span> <span class="p_context"> static void pcpu_chunk_relocate(struct pcpu_chunk *chunk, int oslot)</span>
  * considered; however, async extension is scheduled if the left amount is
  * low.  If !@is_atomic, it aims for more empty space.  Combined, this
  * ensures that the map is likely to have enough available space to
<span class="p_del">- * accomodate atomic allocations which can&#39;t extend maps directly.</span>
<span class="p_add">+ * accommodate atomic allocations which can&#39;t extend maps directly.</span>
  *
  * CONTEXT:
  * pcpu_lock.
<span class="p_header">diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c</span>
<span class="p_header">index ffbb218..9348c80 100644</span>
<span class="p_header">--- a/net/ipv4/tcp.c</span>
<span class="p_header">+++ b/net/ipv4/tcp.c</span>
<span class="p_chunk">@@ -1479,7 +1479,7 @@</span> <span class="p_context"> static struct sk_buff *tcp_recv_skb(struct sock *sk, u32 seq, u32 *off)</span>
 			return skb;
 		}
 		/* This looks weird, but this can happen if TCP collapsing
<span class="p_del">-		 * splitted a fat GRO packet, while we released socket lock</span>
<span class="p_add">+		 * split a fat GRO packet, while we released socket lock</span>
 		 * in skb_splice_bits()
 		 */
 		sk_eat_skb(sk, skb);
<span class="p_header">diff --git a/net/ipv6/route.c b/net/ipv6/route.c</span>
<span class="p_header">index 4981755..25f6aca 100644</span>
<span class="p_header">--- a/net/ipv6/route.c</span>
<span class="p_header">+++ b/net/ipv6/route.c</span>
<span class="p_chunk">@@ -1452,7 +1452,7 @@</span> <span class="p_context"> static struct rt6_info *__ip6_route_redirect(struct net *net,</span>
 	struct fib6_node *fn;
 
 	/* Get the &quot;current&quot; route for this destination and
<span class="p_del">-	 * check if the redirect has come from approriate router.</span>
<span class="p_add">+	 * check if the redirect has come from appropriate router.</span>
 	 *
 	 * RFC 4861 specifies that redirects should only be
 	 * accepted if they come from the nexthop to the target.
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_proto_tcp.c b/net/netfilter/nf_conntrack_proto_tcp.c</span>
<span class="p_header">index 70c8381..a890388 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_proto_tcp.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_proto_tcp.c</span>
<span class="p_chunk">@@ -746,7 +746,7 @@</span> <span class="p_context"> static const u8 tcp_valid_flags[(TCPHDR_FIN|TCPHDR_SYN|TCPHDR_RST|TCPHDR_ACK|</span>
 	[TCPHDR_ACK|TCPHDR_URG]			= 1,
 };
 
<span class="p_del">-/* Protect conntrack agaist broken packets. Code taken from ipt_unclean.c.  */</span>
<span class="p_add">+/* Protect conntrack against broken packets. Code taken from ipt_unclean.c.  */</span>
 static int tcp_error(struct net *net, struct nf_conn *tmpl,
 		     struct sk_buff *skb,
 		     unsigned int dataoff,
<span class="p_header">diff --git a/net/netfilter/x_tables.c b/net/netfilter/x_tables.c</span>
<span class="p_header">index e0aa7c1..c677bd9 100644</span>
<span class="p_header">--- a/net/netfilter/x_tables.c</span>
<span class="p_header">+++ b/net/netfilter/x_tables.c</span>
<span class="p_chunk">@@ -615,7 +615,8 @@</span> <span class="p_context"> int xt_compat_check_entry_offsets(const void *base, const char *elems,</span>
 	    COMPAT_XT_ALIGN(target_offset + sizeof(struct compat_xt_standard_target)) != next_offset)
 		return -EINVAL;
 
<span class="p_del">-	/* compat_xt_entry match has less strict aligment requirements,</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * compat_xt_entry match has less strict alignment requirements,</span>
 	 * otherwise they are identical.  In case of padding differences
 	 * we need to add compat version of xt_check_entry_match.
 	 */
<span class="p_header">diff --git a/net/sctp/transport.c b/net/sctp/transport.c</span>
<span class="p_header">index 81b8667..2a2556d 100644</span>
<span class="p_header">--- a/net/sctp/transport.c</span>
<span class="p_header">+++ b/net/sctp/transport.c</span>
<span class="p_chunk">@@ -630,9 +630,7 @@</span> <span class="p_context"> void sctp_transport_reset(struct sctp_transport *t)</span>
 	t-&gt;srtt = 0;
 	t-&gt;rttvar = 0;
 
<span class="p_del">-	/* Reset these additional varibles so that we have a clean</span>
<span class="p_del">-	 * slate.</span>
<span class="p_del">-	 */</span>
<span class="p_add">+	/* Reset these additional variables so that we have a clean slate. */</span>
 	t-&gt;partial_bytes_acked = 0;
 	t-&gt;flight_size = 0;
 	t-&gt;error_count = 0;
<span class="p_header">diff --git a/net/wireless/wext-compat.c b/net/wireless/wext-compat.c</span>
<span class="p_header">index 9f27221..bf85ab2 100644</span>
<span class="p_header">--- a/net/wireless/wext-compat.c</span>
<span class="p_header">+++ b/net/wireless/wext-compat.c</span>
<span class="p_chunk">@@ -1103,7 +1103,7 @@</span> <span class="p_context"> static int cfg80211_wext_siwpower(struct net_device *dev,</span>
 		switch (wrq-&gt;flags &amp; IW_POWER_MODE) {
 		case IW_POWER_ON:       /* If not specified */
 		case IW_POWER_MODE:     /* If set all mask */
<span class="p_del">-		case IW_POWER_ALL_R:    /* If explicitely state all */</span>
<span class="p_add">+		case IW_POWER_ALL_R:    /* If explicitly state all */</span>
 			ps = true;
 			break;
 		default:                /* Otherwise we ignore */
<span class="p_header">diff --git a/scripts/kconfig/streamline_config.pl b/scripts/kconfig/streamline_config.pl</span>
<span class="p_header">index b8c7b29..7eb508f 100755</span>
<span class="p_header">--- a/scripts/kconfig/streamline_config.pl</span>
<span class="p_header">+++ b/scripts/kconfig/streamline_config.pl</span>
<span class="p_chunk">@@ -21,7 +21,7 @@</span> <span class="p_context"></span>
 #  1. Boot up the kernel that you want to stream line the config on.
 #  2. Change directory to the directory holding the source of the
 #       kernel that you just booted.
<span class="p_del">-#  3. Copy the configuraton file to this directory as .config</span>
<span class="p_add">+#  3. Copy the configuration file to this directory as .config</span>
 #  4. Have all your devices that you need modules for connected and
 #      operational (make sure that their corresponding modules are loaded)
 #  5. Run this script redirecting the output to some other file
<span class="p_header">diff --git a/scripts/recordmcount.pl b/scripts/recordmcount.pl</span>
<span class="p_header">index 96e2486..21640c7 100755</span>
<span class="p_header">--- a/scripts/recordmcount.pl</span>
<span class="p_header">+++ b/scripts/recordmcount.pl</span>
<span class="p_chunk">@@ -316,7 +316,7 @@</span> <span class="p_context"> if ($arch eq &quot;x86_64&quot;) {</span>
     # instruction or the addiu one. herein, we record the address of the
     # first one, and then we can replace this instruction by a branch
     # instruction to jump over the profiling function to filter the
<span class="p_del">-    # indicated functions, or swith back to the lui instruction to trace</span>
<span class="p_add">+    # indicated functions, or switch back to the lui instruction to trace</span>
     # them, which means dynamic tracing.
     #
     #       c:	3c030000 	lui	v1,0x0
<span class="p_header">diff --git a/security/apparmor/procattr.c b/security/apparmor/procattr.c</span>
<span class="p_header">index b125acc..3d6d1ae 100644</span>
<span class="p_header">--- a/security/apparmor/procattr.c</span>
<span class="p_header">+++ b/security/apparmor/procattr.c</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> int aa_getprocattr(struct aa_profile *profile, char **string)</span>
 	ns_name = aa_ns_name(current_ns, ns);
 	ns_len = strlen(ns_name);
 
<span class="p_del">-	/* if the visible ns_name is &gt; 0 increase size for : :// seperator */</span>
<span class="p_add">+	/* if the visible ns_name is &gt; 0 increase size for : :// separator */</span>
 	if (ns_len)
 		ns_len += 4;
 
<span class="p_chunk">@@ -150,7 +150,7 @@</span> <span class="p_context"> int aa_setprocattr_changehat(char *args, size_t size, int test)</span>
 
 /**
  * aa_setprocattr_changeprofile - handle procattr interface to changeprofile
<span class="p_del">- * @fqname: args received from writting to /proc/&lt;pid&gt;/attr/current (NOT NULL)</span>
<span class="p_add">+ * @fqname: args received from writing to /proc/&lt;pid&gt;/attr/current (NOT NULL)</span>
  * @onexec: true if change_profile should be delayed until exec
  * @test: true if this is a test of change_profile permissions
  *
<span class="p_header">diff --git a/security/integrity/ima/ima_template_lib.c b/security/integrity/ima/ima_template_lib.c</span>
<span class="p_header">index f9bae04..28d2eb0 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_template_lib.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_template_lib.c</span>
<span class="p_chunk">@@ -163,7 +163,7 @@</span> <span class="p_context"> static int ima_eventdigest_init_common(u8 *digest, u32 digestsize, u8 hash_algo,</span>
 	 * digest formats:
 	 *  - DATA_FMT_DIGEST: digest
 	 *  - DATA_FMT_DIGEST_WITH_ALGO: [&lt;hash algo&gt;] + &#39;:&#39; + &#39;\0&#39; + digest,
<span class="p_del">-	 *    where &lt;hash algo&gt; is provided if the hash algoritm is not</span>
<span class="p_add">+	 *    where &lt;hash algo&gt; is provided if the hash algorithm is not</span>
 	 *    SHA1 or MD5
 	 */
 	u8 buffer[CRYPTO_MAX_ALG_NAME + 2 + IMA_MAX_DIGEST_SIZE] = { 0 };
<span class="p_header">diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c</span>
<span class="p_header">index 13185a6..3b404f1 100644</span>
<span class="p_header">--- a/security/selinux/hooks.c</span>
<span class="p_header">+++ b/security/selinux/hooks.c</span>
<span class="p_chunk">@@ -729,7 +729,7 @@</span> <span class="p_context"> static int selinux_set_mnt_opts(struct super_block *sb,</span>
 	 * we need to skip the double mount verification.
 	 *
 	 * This does open a hole in which we will not notice if the first
<span class="p_del">-	 * mount using this sb set explict options and a second mount using</span>
<span class="p_add">+	 * mount using this sb set explicit options and a second mount using</span>
 	 * this sb does not set any security options.  (The first options
 	 * will be used for both mounts)
 	 */
<span class="p_header">diff --git a/security/selinux/selinuxfs.c b/security/selinux/selinuxfs.c</span>
<span class="p_header">index 0765c5b..fb46af1 100644</span>
<span class="p_header">--- a/security/selinux/selinuxfs.c</span>
<span class="p_header">+++ b/security/selinux/selinuxfs.c</span>
<span class="p_chunk">@@ -849,7 +849,7 @@</span> <span class="p_context"> static ssize_t sel_write_create(struct file *file, char *buf, size_t size)</span>
 		 * either whitespace or multibyte characters, they shall be
 		 * encoded based on the percentage-encoding rule.
 		 * If not encoded, the sscanf logic picks up only left-half
<span class="p_del">-		 * of the supplied name; splitted by a whitespace unexpectedly.</span>
<span class="p_add">+		 * of the supplied name; split by a whitespace unexpectedly.</span>
 		 */
 		char   *r, *w;
 		int     c1, c2;
<span class="p_header">diff --git a/security/smack/smack_lsm.c b/security/smack/smack_lsm.c</span>
<span class="p_header">index 87a9741..85a7369 100644</span>
<span class="p_header">--- a/security/smack/smack_lsm.c</span>
<span class="p_header">+++ b/security/smack/smack_lsm.c</span>
<span class="p_chunk">@@ -1855,7 +1855,7 @@</span> <span class="p_context"> static int smack_file_send_sigiotask(struct task_struct *tsk,</span>
 	 */
 	file = container_of(fown, struct file, f_owner);
 
<span class="p_del">-	/* we don&#39;t log here as rc can be overriden */</span>
<span class="p_add">+	/* we don&#39;t log here as rc can be overridden */</span>
 	skp = file-&gt;f_security;
 	rc = smk_access(skp, tkp, MAY_WRITE, NULL);
 	rc = smk_bu_note(&quot;sigiotask&quot;, skp, tkp, MAY_WRITE, rc);
<span class="p_header">diff --git a/security/smack/smackfs.c b/security/smack/smackfs.c</span>
<span class="p_header">index e249a66..332da95 100644</span>
<span class="p_header">--- a/security/smack/smackfs.c</span>
<span class="p_header">+++ b/security/smack/smackfs.c</span>
<span class="p_chunk">@@ -114,7 +114,7 @@</span> <span class="p_context"> struct smack_known *smack_syslog_label;</span>
 /*
  * Ptrace current rule
  * SMACK_PTRACE_DEFAULT    regular smack ptrace rules (/proc based)
<span class="p_del">- * SMACK_PTRACE_EXACT      labels must match, but can be overriden with</span>
<span class="p_add">+ * SMACK_PTRACE_EXACT      labels must match, but can be overridden with</span>
  *			   CAP_SYS_PTRACE
  * SMACK_PTRACE_DRACONIAN  lables must match, CAP_SYS_PTRACE has no effect
  */
<span class="p_header">diff --git a/sound/pci/ac97/ac97_codec.c b/sound/pci/ac97/ac97_codec.c</span>
<span class="p_header">index 82259ca..4db1836 100644</span>
<span class="p_header">--- a/sound/pci/ac97/ac97_codec.c</span>
<span class="p_header">+++ b/sound/pci/ac97/ac97_codec.c</span>
<span class="p_chunk">@@ -2907,7 +2907,7 @@</span> <span class="p_context"> int snd_ac97_tune_hardware(struct snd_ac97 *ac97,</span>
 {
 	int result;
 
<span class="p_del">-	/* quirk overriden? */</span>
<span class="p_add">+	/* quirk overridden? */</span>
 	if (override &amp;&amp; strcmp(override, &quot;-1&quot;) &amp;&amp; strcmp(override, &quot;default&quot;)) {
 		result = apply_quirk_str(ac97, override);
 		if (result &lt; 0)
<span class="p_header">diff --git a/sound/pci/ac97/ac97_patch.c b/sound/pci/ac97/ac97_patch.c</span>
<span class="p_header">index f4234ed..21f87d8 100644</span>
<span class="p_header">--- a/sound/pci/ac97/ac97_patch.c</span>
<span class="p_header">+++ b/sound/pci/ac97/ac97_patch.c</span>
<span class="p_chunk">@@ -446,7 +446,7 @@</span> <span class="p_context"> static int patch_yamaha_ymf753(struct snd_ac97 * ac97)</span>
 	/* Patch for Yamaha YMF753, Copyright (c) by David Shust, dshust@shustring.com.
 	   This chip has nonstandard and extended behaviour with regard to its S/PDIF output.
 	   The AC&#39;97 spec states that the S/PDIF signal is to be output at pin 48.
<span class="p_del">-	   The YMF753 will ouput the S/PDIF signal to pin 43, 47 (EAPD), or 48.</span>
<span class="p_add">+	   The YMF753 will output the S/PDIF signal to pin 43, 47 (EAPD), or 48.</span>
 	   By default, no output pin is selected, and the S/PDIF signal is not output.
 	   There is also a bit to mute S/PDIF output in a vendor-specific register.
 	*/
<span class="p_chunk">@@ -3093,7 +3093,7 @@</span> <span class="p_context"> static int patch_cm9739(struct snd_ac97 * ac97)</span>
 	/* set-up multi channel */
 	/* bit 14: 0 = SPDIF, 1 = EAPD */
 	/* bit 13: enable internal vref output for mic */
<span class="p_del">-	/* bit 12: disable center/lfe (swithable) */</span>
<span class="p_add">+	/* bit 12: disable center/lfe (switchable) */</span>
 	/* bit 10: disable surround/line (switchable) */
 	/* bit 9: mix 2 surround off */
 	/* bit 4: undocumented; 0 mutes the CM9739A, which defaults to 1 */
<span class="p_header">diff --git a/sound/pci/hda/hda_sysfs.c b/sound/pci/hda/hda_sysfs.c</span>
<span class="p_header">index 9739fce..0971474 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_sysfs.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_sysfs.c</span>
<span class="p_chunk">@@ -652,7 +652,7 @@</span> <span class="p_context"> static struct hda_patch_item patch_items[NUM_LINE_MODES] = {</span>
 	},
 };
 
<span class="p_del">-/* check the line starting with &#39;[&#39; -- change the parser mode accodingly */</span>
<span class="p_add">+/* check the line starting with &#39;[&#39; -- change the parser mode accordingly */</span>
 static int parse_line_mode(char *buf, struct hda_bus *bus)
 {
 	int i;
<span class="p_header">diff --git a/sound/pci/hda/patch_ca0132.c b/sound/pci/hda/patch_ca0132.c</span>
<span class="p_header">index 9ceb2bc..ea46e9c 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_ca0132.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_ca0132.c</span>
<span class="p_chunk">@@ -2862,7 +2862,7 @@</span> <span class="p_context"> static unsigned int ca0132_capture_pcm_delay(struct hda_pcm_stream *info,</span>
 #define CA0132_CODEC_MUTE(xname, nid, dir) \
 	CA0132_CODEC_MUTE_MONO(xname, nid, 3, dir)
 
<span class="p_del">-/* The followings are for tuning of products */</span>
<span class="p_add">+/* The following are for tuning of products */</span>
 #ifdef ENABLE_TUNING_CONTROLS
 
 static unsigned int voice_focus_vals_lookup[] = {
<span class="p_header">diff --git a/sound/ppc/snd_ps3.c b/sound/ppc/snd_ps3.c</span>
<span class="p_header">index 3682425..a183475 100644</span>
<span class="p_header">--- a/sound/ppc/snd_ps3.c</span>
<span class="p_header">+++ b/sound/ppc/snd_ps3.c</span>
<span class="p_chunk">@@ -885,7 +885,7 @@</span> <span class="p_context"> static void snd_ps3_audio_set_base_addr(uint64_t ioaddr_start)</span>
 static void snd_ps3_audio_fixup(struct snd_ps3_card_info *card)
 {
 	/*
<span class="p_del">-	 * avsetting driver seems to never change the followings</span>
<span class="p_add">+	 * avsetting driver seems to never change the following</span>
 	 * so, init them here once
 	 */
 
<span class="p_header">diff --git a/sound/soc/amd/acp-pcm-dma.c b/sound/soc/amd/acp-pcm-dma.c</span>
<span class="p_header">index d1fb035..3ad6da1 100644</span>
<span class="p_header">--- a/sound/soc/amd/acp-pcm-dma.c</span>
<span class="p_header">+++ b/sound/soc/amd/acp-pcm-dma.c</span>
<span class="p_chunk">@@ -506,7 +506,7 @@</span> <span class="p_context"> static int acp_init(void __iomem *acp_mmio)</span>
 	return 0;
 }
 
<span class="p_del">-/* Deintialize ACP */</span>
<span class="p_add">+/* Deinitialize ACP */</span>
 static int acp_deinit(void __iomem *acp_mmio)
 {
 	u32 val;
<span class="p_chunk">@@ -776,7 +776,7 @@</span> <span class="p_context"> static int acp_dma_prepare(struct snd_pcm_substream *substream)</span>
 		*/
 		acp_dma_start(rtd-&gt;acp_mmio, SYSRAM_TO_ACP_CH_NUM, false);
 
<span class="p_del">-		/* ACP SRAM (2 periods of buffer size) is intially filled with</span>
<span class="p_add">+		/* ACP SRAM (2 periods of buffer size) is initially filled with</span>
 		 * zeros. Before rendering starts, 2nd half of SRAM will be
 		 * filled with valid audio data DMA&#39;ed from first half of system
 		 * RAM and 1st half of SRAM will be filled with Zeros. This is
<span class="p_header">diff --git a/sound/soc/codecs/wm_hubs.c b/sound/soc/codecs/wm_hubs.c</span>
<span class="p_header">index 624b3b9..63b2745 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm_hubs.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm_hubs.c</span>
<span class="p_chunk">@@ -1269,7 +1269,7 @@</span> <span class="p_context"> void wm_hubs_set_bias_level(struct snd_soc_codec *codec,</span>
 		break;
 
 	case SND_SOC_BIAS_ON:
<span class="p_del">-		/* Turn off any unneded single ended outputs */</span>
<span class="p_add">+		/* Turn off any unneeded single ended outputs */</span>
 		val = 0;
 		mask = 0;
 
<span class="p_header">diff --git a/sound/soc/davinci/davinci-i2s.c b/sound/soc/davinci/davinci-i2s.c</span>
<span class="p_header">index 3849616..eb60f97 100644</span>
<span class="p_header">--- a/sound/soc/davinci/davinci-i2s.c</span>
<span class="p_header">+++ b/sound/soc/davinci/davinci-i2s.c</span>
<span class="p_chunk">@@ -52,7 +52,7 @@</span> <span class="p_context"></span>
  *    incompatible with ASP and with either McBSP.
  *
  * In short:  this uses ASP to implement I2S, not McBSP.
<span class="p_del">- * And it won&#39;t be the only DaVinci implemention of I2S.</span>
<span class="p_add">+ * And it won&#39;t be the only DaVinci implementation of I2S.</span>
  */
 #define DAVINCI_MCBSP_DRR_REG	0x00
 #define DAVINCI_MCBSP_DXR_REG	0x04
<span class="p_header">diff --git a/sound/soc/fsl/fsl_asrc.c b/sound/soc/fsl/fsl_asrc.c</span>
<span class="p_header">index c1a0e01..cac4804 100644</span>
<span class="p_header">--- a/sound/soc/fsl/fsl_asrc.c</span>
<span class="p_header">+++ b/sound/soc/fsl/fsl_asrc.c</span>
<span class="p_chunk">@@ -368,7 +368,7 @@</span> <span class="p_context"> static int fsl_asrc_config_pair(struct fsl_asrc_pair *pair)</span>
 	fsl_asrc_set_watermarks(pair, ASRC_INPUTFIFO_THRESHOLD,
 				ASRC_INPUTFIFO_THRESHOLD);
 
<span class="p_del">-	/* Configure the followings only for Ideal Ratio mode */</span>
<span class="p_add">+	/* Configure the following only for Ideal Ratio mode */</span>
 	if (!ideal)
 		return 0;
 
<span class="p_header">diff --git a/sound/soc/qcom/lpass.h b/sound/soc/qcom/lpass.h</span>
<span class="p_header">index 30714ad..7319d02 100644</span>
<span class="p_header">--- a/sound/soc/qcom/lpass.h</span>
<span class="p_header">+++ b/sound/soc/qcom/lpass.h</span>
<span class="p_chunk">@@ -81,7 +81,7 @@</span> <span class="p_context"> struct lpass_variant {</span>
 	 **/
 	u32	dmactl_audif_start;
 	u32	wrdma_channel_start;
<span class="p_del">-	/* SOC specific intialization like clocks */</span>
<span class="p_add">+	/* SOC specific initialization like clocks */</span>
 	int (*init)(struct platform_device *pdev);
 	int (*exit)(struct platform_device *pdev);
 	int (*alloc_dma_channel)(struct lpass_data *data, int direction);
<span class="p_header">diff --git a/sound/soc/soc-ac97.c b/sound/soc/soc-ac97.c</span>
<span class="p_header">index bc4a55b..0fc6a8c 100644</span>
<span class="p_header">--- a/sound/soc/soc-ac97.c</span>
<span class="p_header">+++ b/sound/soc/soc-ac97.c</span>
<span class="p_chunk">@@ -169,7 +169,7 @@</span> <span class="p_context"> static void snd_soc_ac97_free_gpio(struct snd_ac97 *ac97)</span>
  * snd_soc_alloc_ac97_codec() - Allocate new a AC&#39;97 device
  * @codec: The CODEC for which to create the AC&#39;97 device
  *
<span class="p_del">- * Allocated a new snd_ac97 device and intializes it, but does not yet register</span>
<span class="p_add">+ * Allocates a new snd_ac97 device and initializes it, but does not yet register</span>
  * it. The caller is responsible to either call device_add(&amp;ac97-&gt;dev) to
  * register the device, or to call put_device(&amp;ac97-&gt;dev) to free the device.
  *
<span class="p_header">diff --git a/sound/soc/soc-topology.c b/sound/soc/soc-topology.c</span>
<span class="p_header">index ee7f15a..cb46798 100644</span>
<span class="p_header">--- a/sound/soc/soc-topology.c</span>
<span class="p_header">+++ b/sound/soc/soc-topology.c</span>
<span class="p_chunk">@@ -285,7 +285,7 @@</span> <span class="p_context"> static int soc_tplg_widget_load(struct soc_tplg *tplg,</span>
 	return 0;
 }
 
<span class="p_del">-/* pass DAI configurations to component driver for extra intialization */</span>
<span class="p_add">+/* pass DAI configurations to component driver for extra initialization */</span>
 static int soc_tplg_dai_load(struct soc_tplg *tplg,
 	struct snd_soc_dai_driver *dai_drv)
 {
<span class="p_chunk">@@ -295,7 +295,7 @@</span> <span class="p_context"> static int soc_tplg_dai_load(struct soc_tplg *tplg,</span>
 	return 0;
 }
 
<span class="p_del">-/* pass link configurations to component driver for extra intialization */</span>
<span class="p_add">+/* pass link configurations to component driver for extra initialization */</span>
 static int soc_tplg_dai_link_load(struct soc_tplg *tplg,
 	struct snd_soc_dai_link *link)
 {
<span class="p_header">diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c</span>
<span class="p_header">index 2f8c388..c838701 100644</span>
<span class="p_header">--- a/sound/usb/mixer.c</span>
<span class="p_header">+++ b/sound/usb/mixer.c</span>
<span class="p_chunk">@@ -728,7 +728,7 @@</span> <span class="p_context"> static int check_input_term(struct mixer_build *state, int id,</span>
 					return err;
 
 				/* save input term properties after recursion,
<span class="p_del">-				 * to ensure they are not overriden by the</span>
<span class="p_add">+				 * to ensure they are not overridden by the</span>
 				 * recursion calls */
 				term-&gt;id = id;
 				term-&gt;type = le16_to_cpu(d-&gt;wTerminalType);
<span class="p_header">diff --git a/tools/hv/hv_kvp_daemon.c b/tools/hv/hv_kvp_daemon.c</span>
<span class="p_header">index 0d9f48e..0daed40 100644</span>
<span class="p_header">--- a/tools/hv/hv_kvp_daemon.c</span>
<span class="p_header">+++ b/tools/hv/hv_kvp_daemon.c</span>
<span class="p_chunk">@@ -1098,7 +1098,7 @@</span> <span class="p_context"> static int parse_ip_val_buffer(char *in_buf, int *offset,</span>
 	char *start;
 
 	/*
<span class="p_del">-	 * in_buf has sequence of characters that are seperated by</span>
<span class="p_add">+	 * in_buf has sequence of characters that are separated by</span>
 	 * the character &#39;;&#39;. The last sequence does not have the
 	 * terminating &quot;;&quot; character.
 	 */
<span class="p_header">diff --git a/tools/lguest/lguest.c b/tools/lguest/lguest.c</span>
<span class="p_header">index d9836c5..5678449 100644</span>
<span class="p_header">--- a/tools/lguest/lguest.c</span>
<span class="p_header">+++ b/tools/lguest/lguest.c</span>
<span class="p_chunk">@@ -1387,7 +1387,7 @@</span> <span class="p_context"> static bool pci_data_iowrite(u16 port, u32 mask, u32 val)</span>
 		/* Allow writing to any other BAR, or expansion ROM */
 		iowrite(portoff, val, mask, &amp;d-&gt;config_words[reg]);
 		return true;
<span class="p_del">-		/* We let them overide latency timer and cacheline size */</span>
<span class="p_add">+		/* We let them override latency timer and cacheline size */</span>
 	} else if (&amp;d-&gt;config_words[reg] == (void *)&amp;d-&gt;config.cacheline_size) {
 		/* Only let them change the first two fields. */
 		if (mask == 0xFFFFFFFF)
<span class="p_header">diff --git a/tools/lib/bpf/Makefile b/tools/lib/bpf/Makefile</span>
<span class="p_header">index 62d89d5..1902caf 100644</span>
<span class="p_header">--- a/tools/lib/bpf/Makefile</span>
<span class="p_header">+++ b/tools/lib/bpf/Makefile</span>
<span class="p_chunk">@@ -132,7 +132,7 @@</span> <span class="p_context"> else</span>
   Q = @
 endif
 
<span class="p_del">-# Disable command line variables (CFLAGS) overide from top</span>
<span class="p_add">+# Disable command line variables (CFLAGS) override from top</span>
 # level Makefile (perf), otherwise build Makefile will get
 # the same command line setup.
 MAKEOVERRIDES=
<span class="p_header">diff --git a/tools/lib/bpf/bpf.c b/tools/lib/bpf/bpf.c</span>
<span class="p_header">index 4212ed6..87a9c62 100644</span>
<span class="p_header">--- a/tools/lib/bpf/bpf.c</span>
<span class="p_header">+++ b/tools/lib/bpf/bpf.c</span>
<span class="p_chunk">@@ -27,7 +27,7 @@</span> <span class="p_context"></span>
 #include &quot;bpf.h&quot;
 
 /*
<span class="p_del">- * When building perf, unistd.h is overrided. __NR_bpf is</span>
<span class="p_add">+ * When building perf, unistd.h is overridden. __NR_bpf is</span>
  * required to be defined explicitly.
  */
 #ifndef __NR_bpf
<span class="p_header">diff --git a/tools/lib/traceevent/Makefile b/tools/lib/traceevent/Makefile</span>
<span class="p_header">index 7851df1..8b23a7c 100644</span>
<span class="p_header">--- a/tools/lib/traceevent/Makefile</span>
<span class="p_header">+++ b/tools/lib/traceevent/Makefile</span>
<span class="p_chunk">@@ -134,7 +134,7 @@</span> <span class="p_context"> else</span>
   Q = @
 endif
 
<span class="p_del">-# Disable command line variables (CFLAGS) overide from top</span>
<span class="p_add">+# Disable command line variables (CFLAGS) override from top</span>
 # level Makefile (perf), otherwise build Makefile will get
 # the same command line setup.
 MAKEOVERRIDES=
<span class="p_header">diff --git a/tools/perf/Documentation/perf-list.txt b/tools/perf/Documentation/perf-list.txt</span>
<span class="p_header">index a126e97..078e8a9 100644</span>
<span class="p_header">--- a/tools/perf/Documentation/perf-list.txt</span>
<span class="p_header">+++ b/tools/perf/Documentation/perf-list.txt</span>
<span class="p_chunk">@@ -140,7 +140,7 @@</span> <span class="p_context"> like cycles and instructions and some software events.</span>
 Other PMUs and global measurements are normally root only.
 Some event qualifiers, such as &quot;any&quot;, are also root only.
 
<span class="p_del">-This can be overriden by setting the kernel.perf_event_paranoid</span>
<span class="p_add">+This can be overridden by setting the kernel.perf_event_paranoid</span>
 sysctl to -1, which allows non root to use these events.
 
 For accessing trace point events perf needs to have read access to
<span class="p_header">diff --git a/tools/perf/util/probe-event.c b/tools/perf/util/probe-event.c</span>
<span class="p_header">index 2873396..0c6318f 100644</span>
<span class="p_header">--- a/tools/perf/util/probe-event.c</span>
<span class="p_header">+++ b/tools/perf/util/probe-event.c</span>
<span class="p_chunk">@@ -629,7 +629,7 @@</span> <span class="p_context"> static int add_exec_to_probe_trace_events(struct probe_trace_event *tevs,</span>
 		return ret;
 
 	for (i = 0; i &lt; ntevs &amp;&amp; ret &gt;= 0; i++) {
<span class="p_del">-		/* point.address is the addres of point.symbol + point.offset */</span>
<span class="p_add">+		/* point.address is the address of point.symbol + point.offset */</span>
 		tevs[i].point.address -= stext;
 		tevs[i].point.module = strdup(exec);
 		if (!tevs[i].point.module) {
<span class="p_header">diff --git a/tools/testing/ktest/sample.conf b/tools/testing/ktest/sample.conf</span>
<span class="p_header">index 6c58cd8..0b26ef0 100644</span>
<span class="p_header">--- a/tools/testing/ktest/sample.conf</span>
<span class="p_header">+++ b/tools/testing/ktest/sample.conf</span>
<span class="p_chunk">@@ -5,7 +5,7 @@</span> <span class="p_context"></span>
 #
 
 # Options set in the beginning of the file are considered to be
<span class="p_del">-# default options. These options can be overriden by test specific</span>
<span class="p_add">+# default options. These options can be overridden by test specific</span>
 # options, with the following exceptions:
 #
 #  LOG_FILE
<span class="p_chunk">@@ -199,7 +199,7 @@</span> <span class="p_context"></span>
 #
 # This config file can also contain &quot;config variables&quot;.
 # These are assigned with &quot;:=&quot; instead of the ktest option
<span class="p_del">-# assigment &quot;=&quot;.</span>
<span class="p_add">+# assignment &quot;=&quot;.</span>
 #
 # The difference between ktest options and config variables
 # is that config variables can be used multiple times,
<span class="p_header">diff --git a/tools/testing/selftests/net/psock_tpacket.c b/tools/testing/selftests/net/psock_tpacket.c</span>
<span class="p_header">index 24adf70..3c0ed3a 100644</span>
<span class="p_header">--- a/tools/testing/selftests/net/psock_tpacket.c</span>
<span class="p_header">+++ b/tools/testing/selftests/net/psock_tpacket.c</span>
<span class="p_chunk">@@ -11,7 +11,7 @@</span> <span class="p_context"></span>
  *
  * Datapath:
  *   Open a pair of packet sockets and send resp. receive an a priori known
<span class="p_del">- *   packet pattern accross the sockets and check if it was received resp.</span>
<span class="p_add">+ *   packet pattern across the sockets and check if it was received resp.</span>
  *   sent correctly. Fanout in combination with RX_RING is currently not
  *   tested here.
  *
<span class="p_header">diff --git a/tools/testing/selftests/powerpc/vphn/test-vphn.c b/tools/testing/selftests/powerpc/vphn/test-vphn.c</span>
<span class="p_header">index 5742f68..0c63464 100644</span>
<span class="p_header">--- a/tools/testing/selftests/powerpc/vphn/test-vphn.c</span>
<span class="p_header">+++ b/tools/testing/selftests/powerpc/vphn/test-vphn.c</span>
<span class="p_chunk">@@ -274,7 +274,7 @@</span> <span class="p_context"> static struct test {</span>
 		}
 	},
 	{
<span class="p_del">-		/* Parse a 32-bit value split accross two consecutives 64-bit</span>
<span class="p_add">+		/* Parse a 32-bit value split across two consecutive 64-bit</span>
 		 * input values.
 		 */
 		&quot;vphn: 16-bit value followed by 2 x 32-bit values&quot;,

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



