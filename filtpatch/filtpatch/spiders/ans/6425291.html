
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.14.43 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.14.43</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 17, 2015, 6:39 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20150517183921.GB32633@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6425291/mbox/"
   >mbox</a>
|
   <a href="/patch/6425291/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6425291/">/patch/6425291/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 116759F1CC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 17 May 2015 18:39:58 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 5CDD82060A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 17 May 2015 18:39:53 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 6EC90205EF
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 17 May 2015 18:39:48 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751277AbbEQSjg (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 17 May 2015 14:39:36 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:58604 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1750765AbbEQSjX (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 17 May 2015 14:39:23 -0400
Received: from localhost (c-50-170-35-168.hsd1.wa.comcast.net
	[50.170.35.168])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 9A10426;
	Sun, 17 May 2015 18:39:21 +0000 (UTC)
Date: Sun, 17 May 2015 11:39:21 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 3.14.43
Message-ID: &lt;20150517183921.GB32633@kroah.com&gt;
References: &lt;20150517183909.GA32633@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20150517183909.GA32633@kroah.com&gt;
User-Agent: Mutt/1.5.23 (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - May 17, 2015, 6:39 p.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/dma/fsl-mxs-dma.txt b/Documentation/devicetree/bindings/dma/fsl-mxs-dma.txt</span>
<span class="p_header">index a4873e5e3e36..e30e184f50c7 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/dma/fsl-mxs-dma.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/dma/fsl-mxs-dma.txt</span>
<span class="p_chunk">@@ -38,7 +38,7 @@</span> <span class="p_context"> dma_apbx: dma-apbx@80024000 {</span>
 		      80 81 68 69
 		      70 71 72 73
 		      74 75 76 77&gt;;
<span class="p_del">-	interrupt-names = &quot;auart4-rx&quot;, &quot;aurat4-tx&quot;, &quot;spdif-tx&quot;, &quot;empty&quot;,</span>
<span class="p_add">+	interrupt-names = &quot;auart4-rx&quot;, &quot;auart4-tx&quot;, &quot;spdif-tx&quot;, &quot;empty&quot;,</span>
 			  &quot;saif0&quot;, &quot;saif1&quot;, &quot;i2c0&quot;, &quot;i2c1&quot;,
 			  &quot;auart0-rx&quot;, &quot;auart0-tx&quot;, &quot;auart1-rx&quot;, &quot;auart1-tx&quot;,
 			  &quot;auart2-rx&quot;, &quot;auart2-tx&quot;, &quot;auart3-rx&quot;, &quot;auart3-tx&quot;;
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index b9d850d86366..ae5f1e62812f 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 14
<span class="p_del">-SUBLEVEL = 42</span>
<span class="p_add">+SUBLEVEL = 43</span>
 EXTRAVERSION =
 NAME = Remembering Coco
 
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-xp-openblocks-ax3-4.dts b/arch/arm/boot/dts/armada-xp-openblocks-ax3-4.dts</span>
<span class="p_header">index 1c6bd83bde5e..2ade35703d72 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-xp-openblocks-ax3-4.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-xp-openblocks-ax3-4.dts</span>
<span class="p_chunk">@@ -69,6 +69,10 @@</span> <span class="p_context"></span>
 		};
 
 		internal-regs {
<span class="p_add">+			rtc@10300 {</span>
<span class="p_add">+				/* No crystal connected to the internal RTC */</span>
<span class="p_add">+				status = &quot;disabled&quot;;</span>
<span class="p_add">+			};</span>
 			serial@12000 {
 				clock-frequency = &lt;250000000&gt;;
 				status = &quot;okay&quot;;
<span class="p_header">diff --git a/arch/arm/boot/dts/imx23-olinuxino.dts b/arch/arm/boot/dts/imx23-olinuxino.dts</span>
<span class="p_header">index 526bfdbd87f9..f8922fb9bf50 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx23-olinuxino.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx23-olinuxino.dts</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"></span>
  */
 
 /dts-v1/;
<span class="p_add">+#include &lt;dt-bindings/gpio/gpio.h&gt;</span>
 #include &quot;imx23.dtsi&quot;
 
 / {
<span class="p_chunk">@@ -93,6 +94,7 @@</span> <span class="p_context"></span>
 
 	ahb@80080000 {
 		usb0: usb@80080000 {
<span class="p_add">+			dr_mode = &quot;host&quot;;</span>
 			vbus-supply = &lt;&amp;reg_usb0_vbus&gt;;
 			status = &quot;okay&quot;;
 		};
<span class="p_chunk">@@ -119,7 +121,7 @@</span> <span class="p_context"></span>
 
 		user {
 			label = &quot;green&quot;;
<span class="p_del">-			gpios = &lt;&amp;gpio2 1 1&gt;;</span>
<span class="p_add">+			gpios = &lt;&amp;gpio2 1 GPIO_ACTIVE_HIGH&gt;;</span>
 		};
 	};
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx25.dtsi b/arch/arm/boot/dts/imx25.dtsi</span>
<span class="p_header">index cf3300a3071d..bfc327ff70af 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx25.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx25.dtsi</span>
<span class="p_chunk">@@ -411,6 +411,7 @@</span> <span class="p_context"></span>
 
 			pwm4: pwm@53fc8000 {
 				compatible = &quot;fsl,imx25-pwm&quot;, &quot;fsl,imx27-pwm&quot;;
<span class="p_add">+				#pwm-cells = &lt;2&gt;;</span>
 				reg = &lt;0x53fc8000 0x4000&gt;;
 				clocks = &lt;&amp;clks 108&gt;, &lt;&amp;clks 52&gt;;
 				clock-names = &quot;ipg&quot;, &quot;per&quot;;
<span class="p_header">diff --git a/arch/arm/boot/dts/imx28.dtsi b/arch/arm/boot/dts/imx28.dtsi</span>
<span class="p_header">index f8e9b20f6982..ee1a4da35cc4 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx28.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx28.dtsi</span>
<span class="p_chunk">@@ -803,7 +803,7 @@</span> <span class="p_context"></span>
 					      80 81 68 69
 					      70 71 72 73
 					      74 75 76 77&gt;;
<span class="p_del">-				interrupt-names = &quot;auart4-rx&quot;, &quot;aurat4-tx&quot;, &quot;spdif-tx&quot;, &quot;empty&quot;,</span>
<span class="p_add">+				interrupt-names = &quot;auart4-rx&quot;, &quot;auart4-tx&quot;, &quot;spdif-tx&quot;, &quot;empty&quot;,</span>
 						  &quot;saif0&quot;, &quot;saif1&quot;, &quot;i2c0&quot;, &quot;i2c1&quot;,
 						  &quot;auart0-rx&quot;, &quot;auart0-tx&quot;, &quot;auart1-rx&quot;, &quot;auart1-tx&quot;,
 						  &quot;auart2-rx&quot;, &quot;auart2-tx&quot;, &quot;auart3-rx&quot;, &quot;auart3-tx&quot;;
<span class="p_header">diff --git a/arch/arm/boot/dts/ste-dbx5x0.dtsi b/arch/arm/boot/dts/ste-dbx5x0.dtsi</span>
<span class="p_header">index e0853ea02df2..75e748efa9c2 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/ste-dbx5x0.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/ste-dbx5x0.dtsi</span>
<span class="p_chunk">@@ -985,23 +985,6 @@</span> <span class="p_context"></span>
 			status = &quot;disabled&quot;;
 		};
 
<span class="p_del">-		vmmci: regulator-gpio {</span>
<span class="p_del">-			compatible = &quot;regulator-gpio&quot;;</span>
<span class="p_del">-</span>
<span class="p_del">-			regulator-min-microvolt = &lt;1800000&gt;;</span>
<span class="p_del">-			regulator-max-microvolt = &lt;2900000&gt;;</span>
<span class="p_del">-			regulator-name = &quot;mmci-reg&quot;;</span>
<span class="p_del">-			regulator-type = &quot;voltage&quot;;</span>
<span class="p_del">-</span>
<span class="p_del">-			startup-delay-us = &lt;100&gt;;</span>
<span class="p_del">-			enable-active-high;</span>
<span class="p_del">-</span>
<span class="p_del">-			states = &lt;1800000 0x1</span>
<span class="p_del">-				  2900000 0x0&gt;;</span>
<span class="p_del">-</span>
<span class="p_del">-			status = &quot;disabled&quot;;</span>
<span class="p_del">-		};</span>
<span class="p_del">-</span>
 		mcde@a0350000 {
 			compatible = &quot;stericsson,mcde&quot;;
 			reg = &lt;0xa0350000 0x1000&gt;, /* MCDE */
<span class="p_header">diff --git a/arch/arm/boot/dts/ste-href.dtsi b/arch/arm/boot/dts/ste-href.dtsi</span>
<span class="p_header">index 6cb9b68e2188..0b668f87dd40 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/ste-href.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/ste-href.dtsi</span>
<span class="p_chunk">@@ -111,6 +111,21 @@</span> <span class="p_context"></span>
 			pinctrl-1 = &lt;&amp;i2c3_sleep_mode&gt;;
 		};
 
<span class="p_add">+		vmmci: regulator-gpio {</span>
<span class="p_add">+			compatible = &quot;regulator-gpio&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+			regulator-min-microvolt = &lt;1800000&gt;;</span>
<span class="p_add">+			regulator-max-microvolt = &lt;2900000&gt;;</span>
<span class="p_add">+			regulator-name = &quot;mmci-reg&quot;;</span>
<span class="p_add">+			regulator-type = &quot;voltage&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+			startup-delay-us = &lt;100&gt;;</span>
<span class="p_add">+			enable-active-high;</span>
<span class="p_add">+</span>
<span class="p_add">+			states = &lt;1800000 0x1</span>
<span class="p_add">+				  2900000 0x0&gt;;</span>
<span class="p_add">+		};</span>
<span class="p_add">+</span>
 		// External Micro SD slot
 		sdi0_per1@80126000 {
 			arm,primecell-periphid = &lt;0x10480180&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/ste-snowball.dts b/arch/arm/boot/dts/ste-snowball.dts</span>
<span class="p_header">index 97d5d21b7db7..5deaf3c1292f 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/ste-snowball.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/ste-snowball.dts</span>
<span class="p_chunk">@@ -146,8 +146,21 @@</span> <span class="p_context"></span>
 		};
 
 		vmmci: regulator-gpio {
<span class="p_add">+			compatible = &quot;regulator-gpio&quot;;</span>
<span class="p_add">+</span>
 			gpios = &lt;&amp;gpio7 4 0x4&gt;;
 			enable-gpio = &lt;&amp;gpio6 25 0x4&gt;;
<span class="p_add">+</span>
<span class="p_add">+			regulator-min-microvolt = &lt;1800000&gt;;</span>
<span class="p_add">+			regulator-max-microvolt = &lt;2900000&gt;;</span>
<span class="p_add">+			regulator-name = &quot;mmci-reg&quot;;</span>
<span class="p_add">+			regulator-type = &quot;voltage&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+			startup-delay-us = &lt;100&gt;;</span>
<span class="p_add">+			enable-active-high;</span>
<span class="p_add">+</span>
<span class="p_add">+			states = &lt;1800000 0x1</span>
<span class="p_add">+				  2900000 0x0&gt;;</span>
 		};
 
 		// External Micro SD slot
<span class="p_header">diff --git a/arch/arm/include/asm/kvm_arm.h b/arch/arm/include/asm/kvm_arm.h</span>
<span class="p_header">index 1d3153c7eb41..816db0bf2dd8 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/kvm_arm.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/kvm_arm.h</span>
<span class="p_chunk">@@ -55,6 +55,7 @@</span> <span class="p_context"></span>
  * The bits we set in HCR:
  * TAC:		Trap ACTLR
  * TSC:		Trap SMC
<span class="p_add">+ * TVM:		Trap VM ops (until MMU and caches are on)</span>
  * TSW:		Trap cache operations by set/way
  * TWI:		Trap WFI
  * TWE:		Trap WFE
<span class="p_chunk">@@ -68,8 +69,7 @@</span> <span class="p_context"></span>
  */
 #define HCR_GUEST_MASK (HCR_TSC | HCR_TSW | HCR_TWI | HCR_VM | HCR_BSU_IS | \
 			HCR_FB | HCR_TAC | HCR_AMO | HCR_IMO | HCR_FMO | \
<span class="p_del">-			HCR_TWE | HCR_SWIO | HCR_TIDCP)</span>
<span class="p_del">-#define HCR_VIRT_EXCP_MASK (HCR_VA | HCR_VI | HCR_VF)</span>
<span class="p_add">+			HCR_TVM | HCR_TWE | HCR_SWIO | HCR_TIDCP)</span>
 
 /* System Control Register (SCTLR) bits */
 #define SCTLR_TE	(1 &lt;&lt; 30)
<span class="p_header">diff --git a/arch/arm/include/asm/kvm_asm.h b/arch/arm/include/asm/kvm_asm.h</span>
<span class="p_header">index 661da11f76f4..53b3c4a50d5c 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/kvm_asm.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/kvm_asm.h</span>
<span class="p_chunk">@@ -48,7 +48,9 @@</span> <span class="p_context"></span>
 #define c13_TID_URO	26	/* Thread ID, User R/O */
 #define c13_TID_PRIV	27	/* Thread ID, Privileged */
 #define c14_CNTKCTL	28	/* Timer Control Register (PL1) */
<span class="p_del">-#define NR_CP15_REGS	29	/* Number of regs (incl. invalid) */</span>
<span class="p_add">+#define c10_AMAIR0	29	/* Auxilary Memory Attribute Indirection Reg0 */</span>
<span class="p_add">+#define c10_AMAIR1	30	/* Auxilary Memory Attribute Indirection Reg1 */</span>
<span class="p_add">+#define NR_CP15_REGS	31	/* Number of regs (incl. invalid) */</span>
 
 #define ARM_EXCEPTION_RESET	  0
 #define ARM_EXCEPTION_UNDEFINED   1
<span class="p_header">diff --git a/arch/arm/include/asm/kvm_host.h b/arch/arm/include/asm/kvm_host.h</span>
<span class="p_header">index 098f7dd6d564..09af14999c9b 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -101,6 +101,12 @@</span> <span class="p_context"> struct kvm_vcpu_arch {</span>
 	/* The CPU type we expose to the VM */
 	u32 midr;
 
<span class="p_add">+	/* HYP trapping configuration */</span>
<span class="p_add">+	u32 hcr;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Interrupt related fields */</span>
<span class="p_add">+	u32 irq_lines;		/* IRQ and FIQ levels */</span>
<span class="p_add">+</span>
 	/* Exception Information */
 	struct kvm_vcpu_fault_info fault;
 
<span class="p_chunk">@@ -128,9 +134,6 @@</span> <span class="p_context"> struct kvm_vcpu_arch {</span>
 	/* IO related fields */
 	struct kvm_decode mmio_decode;
 
<span class="p_del">-	/* Interrupt related fields */</span>
<span class="p_del">-	u32 irq_lines;		/* IRQ and FIQ levels */</span>
<span class="p_del">-</span>
 	/* Cache some mmu pages needed inside spinlock regions */
 	struct kvm_mmu_memory_cache mmu_page_cache;
 
<span class="p_header">diff --git a/arch/arm/include/asm/kvm_mmu.h b/arch/arm/include/asm/kvm_mmu.h</span>
<span class="p_header">index 2d122adcdb22..7b362bc9c09a 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/kvm_mmu.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/kvm_mmu.h</span>
<span class="p_chunk">@@ -114,11 +114,34 @@</span> <span class="p_context"> static inline void kvm_set_s2pmd_writable(pmd_t *pmd)</span>
 	pmd_val(*pmd) |= L_PMD_S2_RDWR;
 }
 
<span class="p_add">+/* Open coded p*d_addr_end that can deal with 64bit addresses */</span>
<span class="p_add">+#define kvm_pgd_addr_end(addr, end)					\</span>
<span class="p_add">+({	u64 __boundary = ((addr) + PGDIR_SIZE) &amp; PGDIR_MASK;		\</span>
<span class="p_add">+	(__boundary - 1 &lt; (end) - 1)? __boundary: (end);		\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
<span class="p_add">+#define kvm_pud_addr_end(addr,end)		(end)</span>
<span class="p_add">+</span>
<span class="p_add">+#define kvm_pmd_addr_end(addr, end)					\</span>
<span class="p_add">+({	u64 __boundary = ((addr) + PMD_SIZE) &amp; PMD_MASK;		\</span>
<span class="p_add">+	(__boundary - 1 &lt; (end) - 1)? __boundary: (end);		\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
 struct kvm;
 
<span class="p_del">-static inline void coherent_icache_guest_page(struct kvm *kvm, hva_t hva,</span>
<span class="p_del">-					      unsigned long size)</span>
<span class="p_add">+#define kvm_flush_dcache_to_poc(a,l)	__cpuc_flush_dcache_area((a), (l))</span>
<span class="p_add">+</span>
<span class="p_add">+static inline bool vcpu_has_cache_enabled(struct kvm_vcpu *vcpu)</span>
 {
<span class="p_add">+	return (vcpu-&gt;arch.cp15[c1_SCTLR] &amp; 0b101) == 0b101;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void coherent_cache_guest_page(struct kvm_vcpu *vcpu, hva_t hva,</span>
<span class="p_add">+					     unsigned long size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!vcpu_has_cache_enabled(vcpu))</span>
<span class="p_add">+		kvm_flush_dcache_to_poc((void *)hva, size);</span>
<span class="p_add">+</span>
 	/*
 	 * If we are going to insert an instruction page and the icache is
 	 * either VIPT or PIPT, there is a potential problem where the host
<span class="p_chunk">@@ -139,9 +162,10 @@</span> <span class="p_context"> static inline void coherent_icache_guest_page(struct kvm *kvm, hva_t hva,</span>
 	}
 }
 
<span class="p_del">-#define kvm_flush_dcache_to_poc(a,l)	__cpuc_flush_dcache_area((a), (l))</span>
 #define kvm_virt_to_phys(x)		virt_to_idmap((unsigned long)(x))
 
<span class="p_add">+void stage2_flush_vm(struct kvm *kvm);</span>
<span class="p_add">+</span>
 #endif	/* !__ASSEMBLY__ */
 
 #endif /* __ARM_KVM_MMU_H__ */
<span class="p_header">diff --git a/arch/arm/kernel/asm-offsets.c b/arch/arm/kernel/asm-offsets.c</span>
<span class="p_header">index ded041711beb..85598b5d1efd 100644</span>
<span class="p_header">--- a/arch/arm/kernel/asm-offsets.c</span>
<span class="p_header">+++ b/arch/arm/kernel/asm-offsets.c</span>
<span class="p_chunk">@@ -174,6 +174,7 @@</span> <span class="p_context"> int main(void)</span>
   DEFINE(VCPU_FIQ_REGS,		offsetof(struct kvm_vcpu, arch.regs.fiq_regs));
   DEFINE(VCPU_PC,		offsetof(struct kvm_vcpu, arch.regs.usr_regs.ARM_pc));
   DEFINE(VCPU_CPSR,		offsetof(struct kvm_vcpu, arch.regs.usr_regs.ARM_cpsr));
<span class="p_add">+  DEFINE(VCPU_HCR,		offsetof(struct kvm_vcpu, arch.hcr));</span>
   DEFINE(VCPU_IRQ_LINES,	offsetof(struct kvm_vcpu, arch.irq_lines));
   DEFINE(VCPU_HSR,		offsetof(struct kvm_vcpu, arch.fault.hsr));
   DEFINE(VCPU_HxFAR,		offsetof(struct kvm_vcpu, arch.fault.hxfar));
<span class="p_header">diff --git a/arch/arm/kvm/coproc.c b/arch/arm/kvm/coproc.c</span>
<span class="p_header">index 78c0885d6501..c58a35116f63 100644</span>
<span class="p_header">--- a/arch/arm/kvm/coproc.c</span>
<span class="p_header">+++ b/arch/arm/kvm/coproc.c</span>
<span class="p_chunk">@@ -23,6 +23,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/kvm_host.h&gt;
 #include &lt;asm/kvm_emulate.h&gt;
 #include &lt;asm/kvm_coproc.h&gt;
<span class="p_add">+#include &lt;asm/kvm_mmu.h&gt;</span>
 #include &lt;asm/cacheflush.h&gt;
 #include &lt;asm/cputype.h&gt;
 #include &lt;trace/events/kvm.h&gt;
<span class="p_chunk">@@ -205,6 +206,44 @@</span> <span class="p_context"> done:</span>
 }
 
 /*
<span class="p_add">+ * Generic accessor for VM registers. Only called as long as HCR_TVM</span>
<span class="p_add">+ * is set.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool access_vm_reg(struct kvm_vcpu *vcpu,</span>
<span class="p_add">+			  const struct coproc_params *p,</span>
<span class="p_add">+			  const struct coproc_reg *r)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(!p-&gt;is_write);</span>
<span class="p_add">+</span>
<span class="p_add">+	vcpu-&gt;arch.cp15[r-&gt;reg] = *vcpu_reg(vcpu, p-&gt;Rt1);</span>
<span class="p_add">+	if (p-&gt;is_64bit)</span>
<span class="p_add">+		vcpu-&gt;arch.cp15[r-&gt;reg + 1] = *vcpu_reg(vcpu, p-&gt;Rt2);</span>
<span class="p_add">+</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * SCTLR accessor. Only called as long as HCR_TVM is set.  If the</span>
<span class="p_add">+ * guest enables the MMU, we stop trapping the VM sys_regs and leave</span>
<span class="p_add">+ * it in complete control of the caches.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Used by the cpu-specific code.</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool access_sctlr(struct kvm_vcpu *vcpu,</span>
<span class="p_add">+		  const struct coproc_params *p,</span>
<span class="p_add">+		  const struct coproc_reg *r)</span>
<span class="p_add">+{</span>
<span class="p_add">+	access_vm_reg(vcpu, p, r);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (vcpu_has_cache_enabled(vcpu)) {	/* MMU+Caches enabled? */</span>
<span class="p_add">+		vcpu-&gt;arch.hcr &amp;= ~HCR_TVM;</span>
<span class="p_add">+		stage2_flush_vm(vcpu-&gt;kvm);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * We could trap ID_DFR0 and tell the guest we don&#39;t support performance
  * monitoring.  Unfortunately the patch to make the kernel check ID_DFR0 was
  * NAKed, so it will read the PMCR anyway.
<span class="p_chunk">@@ -261,33 +300,36 @@</span> <span class="p_context"> static const struct coproc_reg cp15_regs[] = {</span>
 	{ CRn( 1), CRm( 0), Op1( 0), Op2( 2), is32,
 			NULL, reset_val, c1_CPACR, 0x00000000 },
 
<span class="p_del">-	/* TTBR0/TTBR1: swapped by interrupt.S. */</span>
<span class="p_del">-	{ CRm64( 2), Op1( 0), is64, NULL, reset_unknown64, c2_TTBR0 },</span>
<span class="p_del">-	{ CRm64( 2), Op1( 1), is64, NULL, reset_unknown64, c2_TTBR1 },</span>
<span class="p_del">-</span>
<span class="p_del">-	/* TTBCR: swapped by interrupt.S. */</span>
<span class="p_add">+	/* TTBR0/TTBR1/TTBCR: swapped by interrupt.S. */</span>
<span class="p_add">+	{ CRm64( 2), Op1( 0), is64, access_vm_reg, reset_unknown64, c2_TTBR0 },</span>
<span class="p_add">+	{ CRn(2), CRm( 0), Op1( 0), Op2( 0), is32,</span>
<span class="p_add">+			access_vm_reg, reset_unknown, c2_TTBR0 },</span>
<span class="p_add">+	{ CRn(2), CRm( 0), Op1( 0), Op2( 1), is32,</span>
<span class="p_add">+			access_vm_reg, reset_unknown, c2_TTBR1 },</span>
 	{ CRn( 2), CRm( 0), Op1( 0), Op2( 2), is32,
<span class="p_del">-			NULL, reset_val, c2_TTBCR, 0x00000000 },</span>
<span class="p_add">+			access_vm_reg, reset_val, c2_TTBCR, 0x00000000 },</span>
<span class="p_add">+	{ CRm64( 2), Op1( 1), is64, access_vm_reg, reset_unknown64, c2_TTBR1 },</span>
<span class="p_add">+</span>
 
 	/* DACR: swapped by interrupt.S. */
 	{ CRn( 3), CRm( 0), Op1( 0), Op2( 0), is32,
<span class="p_del">-			NULL, reset_unknown, c3_DACR },</span>
<span class="p_add">+			access_vm_reg, reset_unknown, c3_DACR },</span>
 
 	/* DFSR/IFSR/ADFSR/AIFSR: swapped by interrupt.S. */
 	{ CRn( 5), CRm( 0), Op1( 0), Op2( 0), is32,
<span class="p_del">-			NULL, reset_unknown, c5_DFSR },</span>
<span class="p_add">+			access_vm_reg, reset_unknown, c5_DFSR },</span>
 	{ CRn( 5), CRm( 0), Op1( 0), Op2( 1), is32,
<span class="p_del">-			NULL, reset_unknown, c5_IFSR },</span>
<span class="p_add">+			access_vm_reg, reset_unknown, c5_IFSR },</span>
 	{ CRn( 5), CRm( 1), Op1( 0), Op2( 0), is32,
<span class="p_del">-			NULL, reset_unknown, c5_ADFSR },</span>
<span class="p_add">+			access_vm_reg, reset_unknown, c5_ADFSR },</span>
 	{ CRn( 5), CRm( 1), Op1( 0), Op2( 1), is32,
<span class="p_del">-			NULL, reset_unknown, c5_AIFSR },</span>
<span class="p_add">+			access_vm_reg, reset_unknown, c5_AIFSR },</span>
 
 	/* DFAR/IFAR: swapped by interrupt.S. */
 	{ CRn( 6), CRm( 0), Op1( 0), Op2( 0), is32,
<span class="p_del">-			NULL, reset_unknown, c6_DFAR },</span>
<span class="p_add">+			access_vm_reg, reset_unknown, c6_DFAR },</span>
 	{ CRn( 6), CRm( 0), Op1( 0), Op2( 2), is32,
<span class="p_del">-			NULL, reset_unknown, c6_IFAR },</span>
<span class="p_add">+			access_vm_reg, reset_unknown, c6_IFAR },</span>
 
 	/* PAR swapped by interrupt.S */
 	{ CRm64( 7), Op1( 0), is64, NULL, reset_unknown64, c7_PAR },
<span class="p_chunk">@@ -324,9 +366,15 @@</span> <span class="p_context"> static const struct coproc_reg cp15_regs[] = {</span>
 
 	/* PRRR/NMRR (aka MAIR0/MAIR1): swapped by interrupt.S. */
 	{ CRn(10), CRm( 2), Op1( 0), Op2( 0), is32,
<span class="p_del">-			NULL, reset_unknown, c10_PRRR},</span>
<span class="p_add">+			access_vm_reg, reset_unknown, c10_PRRR},</span>
 	{ CRn(10), CRm( 2), Op1( 0), Op2( 1), is32,
<span class="p_del">-			NULL, reset_unknown, c10_NMRR},</span>
<span class="p_add">+			access_vm_reg, reset_unknown, c10_NMRR},</span>
<span class="p_add">+</span>
<span class="p_add">+	/* AMAIR0/AMAIR1: swapped by interrupt.S. */</span>
<span class="p_add">+	{ CRn(10), CRm( 3), Op1( 0), Op2( 0), is32,</span>
<span class="p_add">+			access_vm_reg, reset_unknown, c10_AMAIR0},</span>
<span class="p_add">+	{ CRn(10), CRm( 3), Op1( 0), Op2( 1), is32,</span>
<span class="p_add">+			access_vm_reg, reset_unknown, c10_AMAIR1},</span>
 
 	/* VBAR: swapped by interrupt.S. */
 	{ CRn(12), CRm( 0), Op1( 0), Op2( 0), is32,
<span class="p_chunk">@@ -334,7 +382,7 @@</span> <span class="p_context"> static const struct coproc_reg cp15_regs[] = {</span>
 
 	/* CONTEXTIDR/TPIDRURW/TPIDRURO/TPIDRPRW: swapped by interrupt.S. */
 	{ CRn(13), CRm( 0), Op1( 0), Op2( 1), is32,
<span class="p_del">-			NULL, reset_val, c13_CID, 0x00000000 },</span>
<span class="p_add">+			access_vm_reg, reset_val, c13_CID, 0x00000000 },</span>
 	{ CRn(13), CRm( 0), Op1( 0), Op2( 2), is32,
 			NULL, reset_unknown, c13_TID_URW },
 	{ CRn(13), CRm( 0), Op1( 0), Op2( 3), is32,
<span class="p_chunk">@@ -443,7 +491,7 @@</span> <span class="p_context"> int kvm_handle_cp15_64(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 {
 	struct coproc_params params;
 
<span class="p_del">-	params.CRm = (kvm_vcpu_get_hsr(vcpu) &gt;&gt; 1) &amp; 0xf;</span>
<span class="p_add">+	params.CRn = (kvm_vcpu_get_hsr(vcpu) &gt;&gt; 1) &amp; 0xf;</span>
 	params.Rt1 = (kvm_vcpu_get_hsr(vcpu) &gt;&gt; 5) &amp; 0xf;
 	params.is_write = ((kvm_vcpu_get_hsr(vcpu) &amp; 1) == 0);
 	params.is_64bit = true;
<span class="p_chunk">@@ -451,7 +499,7 @@</span> <span class="p_context"> int kvm_handle_cp15_64(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 	params.Op1 = (kvm_vcpu_get_hsr(vcpu) &gt;&gt; 16) &amp; 0xf;
 	params.Op2 = 0;
 	params.Rt2 = (kvm_vcpu_get_hsr(vcpu) &gt;&gt; 10) &amp; 0xf;
<span class="p_del">-	params.CRn = 0;</span>
<span class="p_add">+	params.CRm = 0;</span>
 
 	return emulate_cp15(vcpu, &amp;params);
 }
<span class="p_header">diff --git a/arch/arm/kvm/coproc.h b/arch/arm/kvm/coproc.h</span>
<span class="p_header">index 0461d5c8d3de..1a44bbe39643 100644</span>
<span class="p_header">--- a/arch/arm/kvm/coproc.h</span>
<span class="p_header">+++ b/arch/arm/kvm/coproc.h</span>
<span class="p_chunk">@@ -58,8 +58,8 @@</span> <span class="p_context"> static inline void print_cp_instr(const struct coproc_params *p)</span>
 {
 	/* Look, we even formatted it for you to paste into the table! */
 	if (p-&gt;is_64bit) {
<span class="p_del">-		kvm_pr_unimpl(&quot; { CRm(%2lu), Op1(%2lu), is64, func_%s },\n&quot;,</span>
<span class="p_del">-			      p-&gt;CRm, p-&gt;Op1, p-&gt;is_write ? &quot;write&quot; : &quot;read&quot;);</span>
<span class="p_add">+		kvm_pr_unimpl(&quot; { CRm64(%2lu), Op1(%2lu), is64, func_%s },\n&quot;,</span>
<span class="p_add">+			      p-&gt;CRn, p-&gt;Op1, p-&gt;is_write ? &quot;write&quot; : &quot;read&quot;);</span>
 	} else {
 		kvm_pr_unimpl(&quot; { CRn(%2lu), CRm(%2lu), Op1(%2lu), Op2(%2lu), is32,&quot;
 			      &quot; func_%s },\n&quot;,
<span class="p_chunk">@@ -135,13 +135,13 @@</span> <span class="p_context"> static inline int cmp_reg(const struct coproc_reg *i1,</span>
 		return -1;
 	if (i1-&gt;CRn != i2-&gt;CRn)
 		return i1-&gt;CRn - i2-&gt;CRn;
<span class="p_del">-	if (i1-&gt;is_64 != i2-&gt;is_64)</span>
<span class="p_del">-		return i2-&gt;is_64 - i1-&gt;is_64;</span>
 	if (i1-&gt;CRm != i2-&gt;CRm)
 		return i1-&gt;CRm - i2-&gt;CRm;
 	if (i1-&gt;Op1 != i2-&gt;Op1)
 		return i1-&gt;Op1 - i2-&gt;Op1;
<span class="p_del">-	return i1-&gt;Op2 - i2-&gt;Op2;</span>
<span class="p_add">+	if (i1-&gt;Op2 != i2-&gt;Op2)</span>
<span class="p_add">+		return i1-&gt;Op2 - i2-&gt;Op2;</span>
<span class="p_add">+	return i2-&gt;is_64 - i1-&gt;is_64;</span>
 }
 
 
<span class="p_chunk">@@ -153,4 +153,8 @@</span> <span class="p_context"> static inline int cmp_reg(const struct coproc_reg *i1,</span>
 #define is64		.is_64 = true
 #define is32		.is_64 = false
 
<span class="p_add">+bool access_sctlr(struct kvm_vcpu *vcpu,</span>
<span class="p_add">+		  const struct coproc_params *p,</span>
<span class="p_add">+		  const struct coproc_reg *r);</span>
<span class="p_add">+</span>
 #endif /* __ARM_KVM_COPROC_LOCAL_H__ */
<span class="p_header">diff --git a/arch/arm/kvm/coproc_a15.c b/arch/arm/kvm/coproc_a15.c</span>
<span class="p_header">index bb0cac1410cc..e6f4ae48bda9 100644</span>
<span class="p_header">--- a/arch/arm/kvm/coproc_a15.c</span>
<span class="p_header">+++ b/arch/arm/kvm/coproc_a15.c</span>
<span class="p_chunk">@@ -34,7 +34,7 @@</span> <span class="p_context"></span>
 static const struct coproc_reg a15_regs[] = {
 	/* SCTLR: swapped by interrupt.S. */
 	{ CRn( 1), CRm( 0), Op1( 0), Op2( 0), is32,
<span class="p_del">-			NULL, reset_val, c1_SCTLR, 0x00C50078 },</span>
<span class="p_add">+			access_sctlr, reset_val, c1_SCTLR, 0x00C50078 },</span>
 };
 
 static struct kvm_coproc_target_table a15_target_table = {
<span class="p_header">diff --git a/arch/arm/kvm/coproc_a7.c b/arch/arm/kvm/coproc_a7.c</span>
<span class="p_header">index 1df767331588..17fc7cd479d3 100644</span>
<span class="p_header">--- a/arch/arm/kvm/coproc_a7.c</span>
<span class="p_header">+++ b/arch/arm/kvm/coproc_a7.c</span>
<span class="p_chunk">@@ -37,7 +37,7 @@</span> <span class="p_context"></span>
 static const struct coproc_reg a7_regs[] = {
 	/* SCTLR: swapped by interrupt.S. */
 	{ CRn( 1), CRm( 0), Op1( 0), Op2( 0), is32,
<span class="p_del">-			NULL, reset_val, c1_SCTLR, 0x00C50878 },</span>
<span class="p_add">+			access_sctlr, reset_val, c1_SCTLR, 0x00C50878 },</span>
 };
 
 static struct kvm_coproc_target_table a7_target_table = {
<span class="p_header">diff --git a/arch/arm/kvm/guest.c b/arch/arm/kvm/guest.c</span>
<span class="p_header">index 2786eae10c0d..b23a59c1c522 100644</span>
<span class="p_header">--- a/arch/arm/kvm/guest.c</span>
<span class="p_header">+++ b/arch/arm/kvm/guest.c</span>
<span class="p_chunk">@@ -38,6 +38,7 @@</span> <span class="p_context"> struct kvm_stats_debugfs_item debugfs_entries[] = {</span>
 
 int kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)
 {
<span class="p_add">+	vcpu-&gt;arch.hcr = HCR_GUEST_MASK;</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/arch/arm/kvm/interrupts_head.S b/arch/arm/kvm/interrupts_head.S</span>
<span class="p_header">index 6f18695a09cb..76af93025574 100644</span>
<span class="p_header">--- a/arch/arm/kvm/interrupts_head.S</span>
<span class="p_header">+++ b/arch/arm/kvm/interrupts_head.S</span>
<span class="p_chunk">@@ -303,13 +303,17 @@</span> <span class="p_context"> vcpu	.req	r0		@ vcpu pointer always in r0</span>
 
 	mrc	p15, 0, r2, c14, c1, 0	@ CNTKCTL
 	mrrc	p15, 0, r4, r5, c7	@ PAR
<span class="p_add">+	mrc	p15, 0, r6, c10, c3, 0	@ AMAIR0</span>
<span class="p_add">+	mrc	p15, 0, r7, c10, c3, 1	@ AMAIR1</span>
 
 	.if \store_to_vcpu == 0
<span class="p_del">-	push	{r2,r4-r5}</span>
<span class="p_add">+	push	{r2,r4-r7}</span>
 	.else
 	str	r2, [vcpu, #CP15_OFFSET(c14_CNTKCTL)]
 	add	r12, vcpu, #CP15_OFFSET(c7_PAR)
 	strd	r4, r5, [r12]
<span class="p_add">+	str	r6, [vcpu, #CP15_OFFSET(c10_AMAIR0)]</span>
<span class="p_add">+	str	r7, [vcpu, #CP15_OFFSET(c10_AMAIR1)]</span>
 	.endif
 .endm
 
<span class="p_chunk">@@ -322,15 +326,19 @@</span> <span class="p_context"> vcpu	.req	r0		@ vcpu pointer always in r0</span>
  */
 .macro write_cp15_state read_from_vcpu
 	.if \read_from_vcpu == 0
<span class="p_del">-	pop	{r2,r4-r5}</span>
<span class="p_add">+	pop	{r2,r4-r7}</span>
 	.else
 	ldr	r2, [vcpu, #CP15_OFFSET(c14_CNTKCTL)]
 	add	r12, vcpu, #CP15_OFFSET(c7_PAR)
 	ldrd	r4, r5, [r12]
<span class="p_add">+	ldr	r6, [vcpu, #CP15_OFFSET(c10_AMAIR0)]</span>
<span class="p_add">+	ldr	r7, [vcpu, #CP15_OFFSET(c10_AMAIR1)]</span>
 	.endif
 
 	mcr	p15, 0, r2, c14, c1, 0	@ CNTKCTL
 	mcrr	p15, 0, r4, r5, c7	@ PAR
<span class="p_add">+	mcr	p15, 0, r6, c10, c3, 0	@ AMAIR0</span>
<span class="p_add">+	mcr	p15, 0, r7, c10, c3, 1	@ AMAIR1</span>
 
 	.if \read_from_vcpu == 0
 	pop	{r2-r12}
<span class="p_chunk">@@ -597,17 +605,14 @@</span> <span class="p_context"> vcpu	.req	r0		@ vcpu pointer always in r0</span>
 
 /* Enable/Disable: stage-2 trans., trap interrupts, trap wfi, trap smc */
 .macro configure_hyp_role operation
<span class="p_del">-	mrc	p15, 4, r2, c1, c1, 0	@ HCR</span>
<span class="p_del">-	bic	r2, r2, #HCR_VIRT_EXCP_MASK</span>
<span class="p_del">-	ldr	r3, =HCR_GUEST_MASK</span>
 	.if \operation == vmentry
<span class="p_del">-	orr	r2, r2, r3</span>
<span class="p_add">+	ldr	r2, [vcpu, #VCPU_HCR]</span>
 	ldr	r3, [vcpu, #VCPU_IRQ_LINES]
 	orr	r2, r2, r3
 	.else
<span class="p_del">-	bic	r2, r2, r3</span>
<span class="p_add">+	mov	r2, #0</span>
 	.endif
<span class="p_del">-	mcr	p15, 4, r2, c1, c1, 0</span>
<span class="p_add">+	mcr	p15, 4, r2, c1, c1, 0	@ HCR</span>
 .endm
 
 .macro load_vcpu
<span class="p_header">diff --git a/arch/arm/kvm/mmu.c b/arch/arm/kvm/mmu.c</span>
<span class="p_header">index 575d7904305b..c93ef38f9cb0 100644</span>
<span class="p_header">--- a/arch/arm/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/kvm/mmu.c</span>
<span class="p_chunk">@@ -147,7 +147,7 @@</span> <span class="p_context"> static void unmap_range(struct kvm *kvm, pgd_t *pgdp,</span>
 		pgd = pgdp + pgd_index(addr);
 		pud = pud_offset(pgd, addr);
 		if (pud_none(*pud)) {
<span class="p_del">-			addr = pud_addr_end(addr, end);</span>
<span class="p_add">+			addr = kvm_pud_addr_end(addr, end);</span>
 			continue;
 		}
 
<span class="p_chunk">@@ -157,13 +157,13 @@</span> <span class="p_context"> static void unmap_range(struct kvm *kvm, pgd_t *pgdp,</span>
 			 * move on.
 			 */
 			clear_pud_entry(kvm, pud, addr);
<span class="p_del">-			addr = pud_addr_end(addr, end);</span>
<span class="p_add">+			addr = kvm_pud_addr_end(addr, end);</span>
 			continue;
 		}
 
 		pmd = pmd_offset(pud, addr);
 		if (pmd_none(*pmd)) {
<span class="p_del">-			addr = pmd_addr_end(addr, end);</span>
<span class="p_add">+			addr = kvm_pmd_addr_end(addr, end);</span>
 			continue;
 		}
 
<span class="p_chunk">@@ -178,10 +178,10 @@</span> <span class="p_context"> static void unmap_range(struct kvm *kvm, pgd_t *pgdp,</span>
 		 */
 		if (kvm_pmd_huge(*pmd) || page_empty(pte)) {
 			clear_pmd_entry(kvm, pmd, addr);
<span class="p_del">-			next = pmd_addr_end(addr, end);</span>
<span class="p_add">+			next = kvm_pmd_addr_end(addr, end);</span>
 			if (page_empty(pmd) &amp;&amp; !page_empty(pud)) {
 				clear_pud_entry(kvm, pud, addr);
<span class="p_del">-				next = pud_addr_end(addr, end);</span>
<span class="p_add">+				next = kvm_pud_addr_end(addr, end);</span>
 			}
 		}
 
<span class="p_chunk">@@ -189,6 +189,99 @@</span> <span class="p_context"> static void unmap_range(struct kvm *kvm, pgd_t *pgdp,</span>
 	}
 }
 
<span class="p_add">+static void stage2_flush_ptes(struct kvm *kvm, pmd_t *pmd,</span>
<span class="p_add">+			      phys_addr_t addr, phys_addr_t end)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pte_t *pte;</span>
<span class="p_add">+</span>
<span class="p_add">+	pte = pte_offset_kernel(pmd, addr);</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		if (!pte_none(*pte)) {</span>
<span class="p_add">+			hva_t hva = gfn_to_hva(kvm, addr &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+			kvm_flush_dcache_to_poc((void*)hva, PAGE_SIZE);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while (pte++, addr += PAGE_SIZE, addr != end);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void stage2_flush_pmds(struct kvm *kvm, pud_t *pud,</span>
<span class="p_add">+			      phys_addr_t addr, phys_addr_t end)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pmd_t *pmd;</span>
<span class="p_add">+	phys_addr_t next;</span>
<span class="p_add">+</span>
<span class="p_add">+	pmd = pmd_offset(pud, addr);</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		next = kvm_pmd_addr_end(addr, end);</span>
<span class="p_add">+		if (!pmd_none(*pmd)) {</span>
<span class="p_add">+			if (kvm_pmd_huge(*pmd)) {</span>
<span class="p_add">+				hva_t hva = gfn_to_hva(kvm, addr &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+				kvm_flush_dcache_to_poc((void*)hva, PMD_SIZE);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				stage2_flush_ptes(kvm, pmd, addr, next);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while (pmd++, addr = next, addr != end);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void stage2_flush_puds(struct kvm *kvm, pgd_t *pgd,</span>
<span class="p_add">+			      phys_addr_t addr, phys_addr_t end)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pud_t *pud;</span>
<span class="p_add">+	phys_addr_t next;</span>
<span class="p_add">+</span>
<span class="p_add">+	pud = pud_offset(pgd, addr);</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		next = kvm_pud_addr_end(addr, end);</span>
<span class="p_add">+		if (!pud_none(*pud)) {</span>
<span class="p_add">+			if (pud_huge(*pud)) {</span>
<span class="p_add">+				hva_t hva = gfn_to_hva(kvm, addr &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+				kvm_flush_dcache_to_poc((void*)hva, PUD_SIZE);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				stage2_flush_pmds(kvm, pud, addr, next);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while (pud++, addr = next, addr != end);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void stage2_flush_memslot(struct kvm *kvm,</span>
<span class="p_add">+				 struct kvm_memory_slot *memslot)</span>
<span class="p_add">+{</span>
<span class="p_add">+	phys_addr_t addr = memslot-&gt;base_gfn &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+	phys_addr_t end = addr + PAGE_SIZE * memslot-&gt;npages;</span>
<span class="p_add">+	phys_addr_t next;</span>
<span class="p_add">+	pgd_t *pgd;</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd = kvm-&gt;arch.pgd + pgd_index(addr);</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		next = kvm_pgd_addr_end(addr, end);</span>
<span class="p_add">+		stage2_flush_puds(kvm, pgd, addr, next);</span>
<span class="p_add">+	} while (pgd++, addr = next, addr != end);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * stage2_flush_vm - Invalidate cache for pages mapped in stage 2</span>
<span class="p_add">+ * @kvm: The struct kvm pointer</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Go through the stage 2 page tables and invalidate any cache lines</span>
<span class="p_add">+ * backing memory already mapped to the VM.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void stage2_flush_vm(struct kvm *kvm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct kvm_memslots *slots;</span>
<span class="p_add">+	struct kvm_memory_slot *memslot;</span>
<span class="p_add">+	int idx;</span>
<span class="p_add">+</span>
<span class="p_add">+	idx = srcu_read_lock(&amp;kvm-&gt;srcu);</span>
<span class="p_add">+	spin_lock(&amp;kvm-&gt;mmu_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	slots = kvm_memslots(kvm);</span>
<span class="p_add">+	kvm_for_each_memslot(memslot, slots)</span>
<span class="p_add">+		stage2_flush_memslot(kvm, memslot);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock(&amp;kvm-&gt;mmu_lock);</span>
<span class="p_add">+	srcu_read_unlock(&amp;kvm-&gt;srcu, idx);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * free_boot_hyp_pgd - free HYP boot page tables
  *
<span class="p_chunk">@@ -717,7 +810,7 @@</span> <span class="p_context"> static int user_mem_abort(struct kvm_vcpu *vcpu, phys_addr_t fault_ipa,</span>
 			kvm_set_s2pmd_writable(&amp;new_pmd);
 			kvm_set_pfn_dirty(pfn);
 		}
<span class="p_del">-		coherent_icache_guest_page(kvm, hva &amp; PMD_MASK, PMD_SIZE);</span>
<span class="p_add">+		coherent_cache_guest_page(vcpu, hva &amp; PMD_MASK, PMD_SIZE);</span>
 		ret = stage2_set_pmd_huge(kvm, memcache, fault_ipa, &amp;new_pmd);
 	} else {
 		pte_t new_pte = pfn_pte(pfn, PAGE_S2);
<span class="p_chunk">@@ -725,7 +818,7 @@</span> <span class="p_context"> static int user_mem_abort(struct kvm_vcpu *vcpu, phys_addr_t fault_ipa,</span>
 			kvm_set_s2pte_writable(&amp;new_pte);
 			kvm_set_pfn_dirty(pfn);
 		}
<span class="p_del">-		coherent_icache_guest_page(kvm, hva, PAGE_SIZE);</span>
<span class="p_add">+		coherent_cache_guest_page(vcpu, hva, PAGE_SIZE);</span>
 		ret = stage2_set_pte(kvm, memcache, fault_ipa, &amp;new_pte, false);
 	}
 
<span class="p_header">diff --git a/arch/arm/net/bpf_jit_32.c b/arch/arm/net/bpf_jit_32.c</span>
<span class="p_header">index 271b5e971568..6adf5913a7ac 100644</span>
<span class="p_header">--- a/arch/arm/net/bpf_jit_32.c</span>
<span class="p_header">+++ b/arch/arm/net/bpf_jit_32.c</span>
<span class="p_chunk">@@ -449,10 +449,21 @@</span> <span class="p_context"> static inline void emit_udiv(u8 rd, u8 rm, u8 rn, struct jit_ctx *ctx)</span>
 		return;
 	}
 #endif
<span class="p_del">-	if (rm != ARM_R0)</span>
<span class="p_del">-		emit(ARM_MOV_R(ARM_R0, rm), ctx);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * For BPF_ALU | BPF_DIV | BPF_K instructions, rm is ARM_R4</span>
<span class="p_add">+	 * (r_A) and rn is ARM_R0 (r_scratch) so load rn first into</span>
<span class="p_add">+	 * ARM_R1 to avoid accidentally overwriting ARM_R0 with rm</span>
<span class="p_add">+	 * before using it as a source for ARM_R1.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * For BPF_ALU | BPF_DIV | BPF_X rm is ARM_R4 (r_A) and rn is</span>
<span class="p_add">+	 * ARM_R5 (r_X) so there is no particular register overlap</span>
<span class="p_add">+	 * issues.</span>
<span class="p_add">+	 */</span>
 	if (rn != ARM_R1)
 		emit(ARM_MOV_R(ARM_R1, rn), ctx);
<span class="p_add">+	if (rm != ARM_R0)</span>
<span class="p_add">+		emit(ARM_MOV_R(ARM_R0, rm), ctx);</span>
 
 	ctx-&gt;seen |= SEEN_CALL;
 	emit_mov_i(ARM_R3, (u32)jit_udiv, ctx);
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_arm.h b/arch/arm64/include/asm/kvm_arm.h</span>
<span class="p_header">index 0eb398655378..00fbaa75dc7b 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_arm.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_arm.h</span>
<span class="p_chunk">@@ -62,6 +62,7 @@</span> <span class="p_context"></span>
  * RW:		64bit by default, can be overriden for 32bit VMs
  * TAC:		Trap ACTLR
  * TSC:		Trap SMC
<span class="p_add">+ * TVM:		Trap VM ops (until M+C set in SCTLR_EL1)</span>
  * TSW:		Trap cache operations by set/way
  * TWE:		Trap WFE
  * TWI:		Trap WFI
<span class="p_chunk">@@ -74,7 +75,7 @@</span> <span class="p_context"></span>
  * SWIO:	Turn set/way invalidates into set/way clean+invalidate
  */
 #define HCR_GUEST_FLAGS (HCR_TSC | HCR_TSW | HCR_TWE | HCR_TWI | HCR_VM | \
<span class="p_del">-			 HCR_BSU_IS | HCR_FB | HCR_TAC | \</span>
<span class="p_add">+			 HCR_TVM | HCR_BSU_IS | HCR_FB | HCR_TAC | \</span>
 			 HCR_AMO | HCR_IMO | HCR_FMO | \
 			 HCR_SWIO | HCR_TIDCP | HCR_RW)
 #define HCR_VIRT_EXCP_MASK (HCR_VA | HCR_VI | HCR_VF)
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_asm.h b/arch/arm64/include/asm/kvm_asm.h</span>
<span class="p_header">index b25763bc0ec4..9fcd54b1e16d 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_asm.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_asm.h</span>
<span class="p_chunk">@@ -79,7 +79,8 @@</span> <span class="p_context"></span>
 #define c13_TID_URW	(TPIDR_EL0 * 2)	/* Thread ID, User R/W */
 #define c13_TID_URO	(TPIDRRO_EL0 * 2)/* Thread ID, User R/O */
 #define c13_TID_PRIV	(TPIDR_EL1 * 2)	/* Thread ID, Privileged */
<span class="p_del">-#define c10_AMAIR	(AMAIR_EL1 * 2)	/* Aux Memory Attr Indirection Reg */</span>
<span class="p_add">+#define c10_AMAIR0	(AMAIR_EL1 * 2)	/* Aux Memory Attr Indirection Reg */</span>
<span class="p_add">+#define c10_AMAIR1	(c10_AMAIR0 + 1)/* Aux Memory Attr Indirection Reg */</span>
 #define c14_CNTKCTL	(CNTKCTL_EL1 * 2) /* Timer Control Register (PL1) */
 #define NR_CP15_REGS	(NR_SYS_REGS * 2)
 
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_mmu.h b/arch/arm64/include/asm/kvm_mmu.h</span>
<span class="p_header">index 7f1f9408ff66..7d29847a893b 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_mmu.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_mmu.h</span>
<span class="p_chunk">@@ -106,7 +106,6 @@</span> <span class="p_context"> static inline bool kvm_is_write_fault(unsigned long esr)</span>
 	return true;
 }
 
<span class="p_del">-static inline void kvm_clean_dcache_area(void *addr, size_t size) {}</span>
 static inline void kvm_clean_pgd(pgd_t *pgd) {}
 static inline void kvm_clean_pmd_entry(pmd_t *pmd) {}
 static inline void kvm_clean_pte(pte_t *pte) {}
<span class="p_chunk">@@ -122,11 +121,25 @@</span> <span class="p_context"> static inline void kvm_set_s2pmd_writable(pmd_t *pmd)</span>
 	pmd_val(*pmd) |= PMD_S2_RDWR;
 }
 
<span class="p_add">+#define kvm_pgd_addr_end(addr, end)	pgd_addr_end(addr, end)</span>
<span class="p_add">+#define kvm_pud_addr_end(addr, end)	pud_addr_end(addr, end)</span>
<span class="p_add">+#define kvm_pmd_addr_end(addr, end)	pmd_addr_end(addr, end)</span>
<span class="p_add">+</span>
 struct kvm;
 
<span class="p_del">-static inline void coherent_icache_guest_page(struct kvm *kvm, hva_t hva,</span>
<span class="p_del">-					      unsigned long size)</span>
<span class="p_add">+#define kvm_flush_dcache_to_poc(a,l)	__flush_dcache_area((a), (l))</span>
<span class="p_add">+</span>
<span class="p_add">+static inline bool vcpu_has_cache_enabled(struct kvm_vcpu *vcpu)</span>
 {
<span class="p_add">+	return (vcpu_sys_reg(vcpu, SCTLR_EL1) &amp; 0b101) == 0b101;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void coherent_cache_guest_page(struct kvm_vcpu *vcpu, hva_t hva,</span>
<span class="p_add">+					     unsigned long size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!vcpu_has_cache_enabled(vcpu))</span>
<span class="p_add">+		kvm_flush_dcache_to_poc((void *)hva, size);</span>
<span class="p_add">+</span>
 	if (!icache_is_aliasing()) {		/* PIPT */
 		flush_icache_range(hva, hva + size);
 	} else if (!icache_is_aivivt()) {	/* non ASID-tagged VIVT */
<span class="p_chunk">@@ -135,8 +148,9 @@</span> <span class="p_context"> static inline void coherent_icache_guest_page(struct kvm *kvm, hva_t hva,</span>
 	}
 }
 
<span class="p_del">-#define kvm_flush_dcache_to_poc(a,l)	__flush_dcache_area((a), (l))</span>
 #define kvm_virt_to_phys(x)		__virt_to_phys((unsigned long)(x))
 
<span class="p_add">+void stage2_flush_vm(struct kvm *kvm);</span>
<span class="p_add">+</span>
 #endif /* __ASSEMBLY__ */
 #endif /* __ARM64_KVM_MMU_H__ */
<span class="p_header">diff --git a/arch/arm64/kvm/hyp.S b/arch/arm64/kvm/hyp.S</span>
<span class="p_header">index 2c56012cb2d2..b0d1512acf08 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/hyp.S</span>
<span class="p_header">+++ b/arch/arm64/kvm/hyp.S</span>
<span class="p_chunk">@@ -630,9 +630,15 @@</span> <span class="p_context"> ENTRY(__kvm_tlb_flush_vmid_ipa)</span>
 	 * whole of Stage-1. Weep...
 	 */
 	tlbi	ipas2e1is, x1
<span class="p_del">-	dsb	sy</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We have to ensure completion of the invalidation at Stage-2,</span>
<span class="p_add">+	 * since a table walk on another CPU could refill a TLB with a</span>
<span class="p_add">+	 * complete (S1 + S2) walk based on the old Stage-2 mapping if</span>
<span class="p_add">+	 * the Stage-1 invalidation happened first.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	dsb	ish</span>
 	tlbi	vmalle1is
<span class="p_del">-	dsb	sy</span>
<span class="p_add">+	dsb	ish</span>
 	isb
 
 	msr	vttbr_el2, xzr
<span class="p_chunk">@@ -643,7 +649,7 @@</span> <span class="p_context"> ENTRY(__kvm_flush_vm_context)</span>
 	dsb	ishst
 	tlbi	alle1is
 	ic	ialluis
<span class="p_del">-	dsb	sy</span>
<span class="p_add">+	dsb	ish</span>
 	ret
 ENDPROC(__kvm_flush_vm_context)
 
<span class="p_header">diff --git a/arch/arm64/kvm/sys_regs.c b/arch/arm64/kvm/sys_regs.c</span>
<span class="p_header">index 02e9d09e1d80..03244582bc55 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/sys_regs.c</span>
<span class="p_header">+++ b/arch/arm64/kvm/sys_regs.c</span>
<span class="p_chunk">@@ -27,6 +27,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/kvm_host.h&gt;
 #include &lt;asm/kvm_emulate.h&gt;
 #include &lt;asm/kvm_coproc.h&gt;
<span class="p_add">+#include &lt;asm/kvm_mmu.h&gt;</span>
 #include &lt;asm/cacheflush.h&gt;
 #include &lt;asm/cputype.h&gt;
 #include &lt;trace/events/kvm.h&gt;
<span class="p_chunk">@@ -121,6 +122,48 @@</span> <span class="p_context"> done:</span>
 }
 
 /*
<span class="p_add">+ * Generic accessor for VM registers. Only called as long as HCR_TVM</span>
<span class="p_add">+ * is set.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool access_vm_reg(struct kvm_vcpu *vcpu,</span>
<span class="p_add">+			  const struct sys_reg_params *p,</span>
<span class="p_add">+			  const struct sys_reg_desc *r)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long val;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(!p-&gt;is_write);</span>
<span class="p_add">+</span>
<span class="p_add">+	val = *vcpu_reg(vcpu, p-&gt;Rt);</span>
<span class="p_add">+	if (!p-&gt;is_aarch32) {</span>
<span class="p_add">+		vcpu_sys_reg(vcpu, r-&gt;reg) = val;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		vcpu_cp15(vcpu, r-&gt;reg) = val &amp; 0xffffffffUL;</span>
<span class="p_add">+		if (!p-&gt;is_32bit)</span>
<span class="p_add">+			vcpu_cp15(vcpu, r-&gt;reg + 1) = val &gt;&gt; 32;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * SCTLR_EL1 accessor. Only called as long as HCR_TVM is set.  If the</span>
<span class="p_add">+ * guest enables the MMU, we stop trapping the VM sys_regs and leave</span>
<span class="p_add">+ * it in complete control of the caches.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool access_sctlr(struct kvm_vcpu *vcpu,</span>
<span class="p_add">+			 const struct sys_reg_params *p,</span>
<span class="p_add">+			 const struct sys_reg_desc *r)</span>
<span class="p_add">+{</span>
<span class="p_add">+	access_vm_reg(vcpu, p, r);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (vcpu_has_cache_enabled(vcpu)) {	/* MMU+Caches enabled? */</span>
<span class="p_add">+		vcpu-&gt;arch.hcr_el2 &amp;= ~HCR_TVM;</span>
<span class="p_add">+		stage2_flush_vm(vcpu-&gt;kvm);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * We could trap ID_DFR0 and tell the guest we don&#39;t support performance
  * monitoring.  Unfortunately the patch to make the kernel check ID_DFR0 was
  * NAKed, so it will read the PMCR anyway.
<span class="p_chunk">@@ -185,32 +228,32 @@</span> <span class="p_context"> static const struct sys_reg_desc sys_reg_descs[] = {</span>
 	  NULL, reset_mpidr, MPIDR_EL1 },
 	/* SCTLR_EL1 */
 	{ Op0(0b11), Op1(0b000), CRn(0b0001), CRm(0b0000), Op2(0b000),
<span class="p_del">-	  NULL, reset_val, SCTLR_EL1, 0x00C50078 },</span>
<span class="p_add">+	  access_sctlr, reset_val, SCTLR_EL1, 0x00C50078 },</span>
 	/* CPACR_EL1 */
 	{ Op0(0b11), Op1(0b000), CRn(0b0001), CRm(0b0000), Op2(0b010),
 	  NULL, reset_val, CPACR_EL1, 0 },
 	/* TTBR0_EL1 */
 	{ Op0(0b11), Op1(0b000), CRn(0b0010), CRm(0b0000), Op2(0b000),
<span class="p_del">-	  NULL, reset_unknown, TTBR0_EL1 },</span>
<span class="p_add">+	  access_vm_reg, reset_unknown, TTBR0_EL1 },</span>
 	/* TTBR1_EL1 */
 	{ Op0(0b11), Op1(0b000), CRn(0b0010), CRm(0b0000), Op2(0b001),
<span class="p_del">-	  NULL, reset_unknown, TTBR1_EL1 },</span>
<span class="p_add">+	  access_vm_reg, reset_unknown, TTBR1_EL1 },</span>
 	/* TCR_EL1 */
 	{ Op0(0b11), Op1(0b000), CRn(0b0010), CRm(0b0000), Op2(0b010),
<span class="p_del">-	  NULL, reset_val, TCR_EL1, 0 },</span>
<span class="p_add">+	  access_vm_reg, reset_val, TCR_EL1, 0 },</span>
 
 	/* AFSR0_EL1 */
 	{ Op0(0b11), Op1(0b000), CRn(0b0101), CRm(0b0001), Op2(0b000),
<span class="p_del">-	  NULL, reset_unknown, AFSR0_EL1 },</span>
<span class="p_add">+	  access_vm_reg, reset_unknown, AFSR0_EL1 },</span>
 	/* AFSR1_EL1 */
 	{ Op0(0b11), Op1(0b000), CRn(0b0101), CRm(0b0001), Op2(0b001),
<span class="p_del">-	  NULL, reset_unknown, AFSR1_EL1 },</span>
<span class="p_add">+	  access_vm_reg, reset_unknown, AFSR1_EL1 },</span>
 	/* ESR_EL1 */
 	{ Op0(0b11), Op1(0b000), CRn(0b0101), CRm(0b0010), Op2(0b000),
<span class="p_del">-	  NULL, reset_unknown, ESR_EL1 },</span>
<span class="p_add">+	  access_vm_reg, reset_unknown, ESR_EL1 },</span>
 	/* FAR_EL1 */
 	{ Op0(0b11), Op1(0b000), CRn(0b0110), CRm(0b0000), Op2(0b000),
<span class="p_del">-	  NULL, reset_unknown, FAR_EL1 },</span>
<span class="p_add">+	  access_vm_reg, reset_unknown, FAR_EL1 },</span>
 	/* PAR_EL1 */
 	{ Op0(0b11), Op1(0b000), CRn(0b0111), CRm(0b0100), Op2(0b000),
 	  NULL, reset_unknown, PAR_EL1 },
<span class="p_chunk">@@ -224,17 +267,17 @@</span> <span class="p_context"> static const struct sys_reg_desc sys_reg_descs[] = {</span>
 
 	/* MAIR_EL1 */
 	{ Op0(0b11), Op1(0b000), CRn(0b1010), CRm(0b0010), Op2(0b000),
<span class="p_del">-	  NULL, reset_unknown, MAIR_EL1 },</span>
<span class="p_add">+	  access_vm_reg, reset_unknown, MAIR_EL1 },</span>
 	/* AMAIR_EL1 */
 	{ Op0(0b11), Op1(0b000), CRn(0b1010), CRm(0b0011), Op2(0b000),
<span class="p_del">-	  NULL, reset_amair_el1, AMAIR_EL1 },</span>
<span class="p_add">+	  access_vm_reg, reset_amair_el1, AMAIR_EL1 },</span>
 
 	/* VBAR_EL1 */
 	{ Op0(0b11), Op1(0b000), CRn(0b1100), CRm(0b0000), Op2(0b000),
 	  NULL, reset_val, VBAR_EL1, 0 },
 	/* CONTEXTIDR_EL1 */
 	{ Op0(0b11), Op1(0b000), CRn(0b1101), CRm(0b0000), Op2(0b001),
<span class="p_del">-	  NULL, reset_val, CONTEXTIDR_EL1, 0 },</span>
<span class="p_add">+	  access_vm_reg, reset_val, CONTEXTIDR_EL1, 0 },</span>
 	/* TPIDR_EL1 */
 	{ Op0(0b11), Op1(0b000), CRn(0b1101), CRm(0b0000), Op2(0b100),
 	  NULL, reset_unknown, TPIDR_EL1 },
<span class="p_chunk">@@ -305,14 +348,32 @@</span> <span class="p_context"> static const struct sys_reg_desc sys_reg_descs[] = {</span>
 	  NULL, reset_val, FPEXC32_EL2, 0x70 },
 };
 
<span class="p_del">-/* Trapped cp15 registers */</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Trapped cp15 registers. TTBR0/TTBR1 get a double encoding,</span>
<span class="p_add">+ * depending on the way they are accessed (as a 32bit or a 64bit</span>
<span class="p_add">+ * register).</span>
<span class="p_add">+ */</span>
 static const struct sys_reg_desc cp15_regs[] = {
<span class="p_add">+	{ Op1( 0), CRn( 0), CRm( 2), Op2( 0), access_vm_reg, NULL, c2_TTBR0 },</span>
<span class="p_add">+	{ Op1( 0), CRn( 1), CRm( 0), Op2( 0), access_sctlr, NULL, c1_SCTLR },</span>
<span class="p_add">+	{ Op1( 0), CRn( 2), CRm( 0), Op2( 0), access_vm_reg, NULL, c2_TTBR0 },</span>
<span class="p_add">+	{ Op1( 0), CRn( 2), CRm( 0), Op2( 1), access_vm_reg, NULL, c2_TTBR1 },</span>
<span class="p_add">+	{ Op1( 0), CRn( 2), CRm( 0), Op2( 2), access_vm_reg, NULL, c2_TTBCR },</span>
<span class="p_add">+	{ Op1( 0), CRn( 3), CRm( 0), Op2( 0), access_vm_reg, NULL, c3_DACR },</span>
<span class="p_add">+	{ Op1( 0), CRn( 5), CRm( 0), Op2( 0), access_vm_reg, NULL, c5_DFSR },</span>
<span class="p_add">+	{ Op1( 0), CRn( 5), CRm( 0), Op2( 1), access_vm_reg, NULL, c5_IFSR },</span>
<span class="p_add">+	{ Op1( 0), CRn( 5), CRm( 1), Op2( 0), access_vm_reg, NULL, c5_ADFSR },</span>
<span class="p_add">+	{ Op1( 0), CRn( 5), CRm( 1), Op2( 1), access_vm_reg, NULL, c5_AIFSR },</span>
<span class="p_add">+	{ Op1( 0), CRn( 6), CRm( 0), Op2( 0), access_vm_reg, NULL, c6_DFAR },</span>
<span class="p_add">+	{ Op1( 0), CRn( 6), CRm( 0), Op2( 2), access_vm_reg, NULL, c6_IFAR },</span>
<span class="p_add">+</span>
 	/*
 	 * DC{C,I,CI}SW operations:
 	 */
 	{ Op1( 0), CRn( 7), CRm( 6), Op2( 2), access_dcsw },
 	{ Op1( 0), CRn( 7), CRm(10), Op2( 2), access_dcsw },
 	{ Op1( 0), CRn( 7), CRm(14), Op2( 2), access_dcsw },
<span class="p_add">+</span>
 	{ Op1( 0), CRn( 9), CRm(12), Op2( 0), pm_fake },
 	{ Op1( 0), CRn( 9), CRm(12), Op2( 1), pm_fake },
 	{ Op1( 0), CRn( 9), CRm(12), Op2( 2), pm_fake },
<span class="p_chunk">@@ -326,6 +387,14 @@</span> <span class="p_context"> static const struct sys_reg_desc cp15_regs[] = {</span>
 	{ Op1( 0), CRn( 9), CRm(14), Op2( 0), pm_fake },
 	{ Op1( 0), CRn( 9), CRm(14), Op2( 1), pm_fake },
 	{ Op1( 0), CRn( 9), CRm(14), Op2( 2), pm_fake },
<span class="p_add">+</span>
<span class="p_add">+	{ Op1( 0), CRn(10), CRm( 2), Op2( 0), access_vm_reg, NULL, c10_PRRR },</span>
<span class="p_add">+	{ Op1( 0), CRn(10), CRm( 2), Op2( 1), access_vm_reg, NULL, c10_NMRR },</span>
<span class="p_add">+	{ Op1( 0), CRn(10), CRm( 3), Op2( 0), access_vm_reg, NULL, c10_AMAIR0 },</span>
<span class="p_add">+	{ Op1( 0), CRn(10), CRm( 3), Op2( 1), access_vm_reg, NULL, c10_AMAIR1 },</span>
<span class="p_add">+	{ Op1( 0), CRn(13), CRm( 0), Op2( 1), access_vm_reg, NULL, c13_CID },</span>
<span class="p_add">+</span>
<span class="p_add">+	{ Op1( 1), CRn( 0), CRm( 2), Op2( 0), access_vm_reg, NULL, c2_TTBR1 },</span>
 };
 
 /* Target specific emulation tables */
<span class="p_chunk">@@ -437,6 +506,8 @@</span> <span class="p_context"> int kvm_handle_cp15_64(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 	u32 hsr = kvm_vcpu_get_hsr(vcpu);
 	int Rt2 = (hsr &gt;&gt; 10) &amp; 0xf;
 
<span class="p_add">+	params.is_aarch32 = true;</span>
<span class="p_add">+	params.is_32bit = false;</span>
 	params.CRm = (hsr &gt;&gt; 1) &amp; 0xf;
 	params.Rt = (hsr &gt;&gt; 5) &amp; 0xf;
 	params.is_write = ((hsr &amp; 1) == 0);
<span class="p_chunk">@@ -480,6 +551,8 @@</span> <span class="p_context"> int kvm_handle_cp15_32(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 	struct sys_reg_params params;
 	u32 hsr = kvm_vcpu_get_hsr(vcpu);
 
<span class="p_add">+	params.is_aarch32 = true;</span>
<span class="p_add">+	params.is_32bit = true;</span>
 	params.CRm = (hsr &gt;&gt; 1) &amp; 0xf;
 	params.Rt  = (hsr &gt;&gt; 5) &amp; 0xf;
 	params.is_write = ((hsr &amp; 1) == 0);
<span class="p_chunk">@@ -549,6 +622,8 @@</span> <span class="p_context"> int kvm_handle_sys_reg(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 	struct sys_reg_params params;
 	unsigned long esr = kvm_vcpu_get_hsr(vcpu);
 
<span class="p_add">+	params.is_aarch32 = false;</span>
<span class="p_add">+	params.is_32bit = false;</span>
 	params.Op0 = (esr &gt;&gt; 20) &amp; 3;
 	params.Op1 = (esr &gt;&gt; 14) &amp; 0x7;
 	params.CRn = (esr &gt;&gt; 10) &amp; 0xf;
<span class="p_header">diff --git a/arch/arm64/kvm/sys_regs.h b/arch/arm64/kvm/sys_regs.h</span>
<span class="p_header">index d50d3722998e..d411e251412c 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/sys_regs.h</span>
<span class="p_header">+++ b/arch/arm64/kvm/sys_regs.h</span>
<span class="p_chunk">@@ -30,6 +30,8 @@</span> <span class="p_context"> struct sys_reg_params {</span>
 	u8	Op2;
 	u8	Rt;
 	bool	is_write;
<span class="p_add">+	bool	is_aarch32;</span>
<span class="p_add">+	bool	is_32bit;	/* Only valid if is_aarch32 is true */</span>
 };
 
 struct sys_reg_desc {
<span class="p_header">diff --git a/drivers/acpi/acpica/acmacros.h b/drivers/acpi/acpica/acmacros.h</span>
<span class="p_header">index 2a86c65d873b..97c7a52dfb4a 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/acmacros.h</span>
<span class="p_header">+++ b/drivers/acpi/acpica/acmacros.h</span>
<span class="p_chunk">@@ -63,19 +63,15 @@</span> <span class="p_context"></span>
 #define ACPI_SET64(ptr, val)            (*ACPI_CAST64 (ptr) = (u64) (val))
 
 /*
<span class="p_del">- * printf() format helpers</span>
<span class="p_add">+ * printf() format helper. This macros is a workaround for the difficulties</span>
<span class="p_add">+ * with emitting 64-bit integers and 64-bit pointers with the same code</span>
<span class="p_add">+ * for both 32-bit and 64-bit hosts.</span>
  */
 
 /* Split 64-bit integer into two 32-bit values. Use with %8.8X%8.8X */
 
 #define ACPI_FORMAT_UINT64(i)           ACPI_HIDWORD(i), ACPI_LODWORD(i)
 
<span class="p_del">-#if ACPI_MACHINE_WIDTH == 64</span>
<span class="p_del">-#define ACPI_FORMAT_NATIVE_UINT(i)      ACPI_FORMAT_UINT64(i)</span>
<span class="p_del">-#else</span>
<span class="p_del">-#define ACPI_FORMAT_NATIVE_UINT(i)      0, (i)</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 /*
  * Macros for moving data around to/from buffers that are possibly unaligned.
  * If the hardware supports the transfer of unaligned data, just do the store.
<span class="p_header">diff --git a/drivers/acpi/acpica/dsopcode.c b/drivers/acpi/acpica/dsopcode.c</span>
<span class="p_header">index 5205edcf2c01..fe79296fdd9e 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/dsopcode.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/dsopcode.c</span>
<span class="p_chunk">@@ -446,7 +446,7 @@</span> <span class="p_context"> acpi_ds_eval_region_operands(struct acpi_walk_state *walk_state,</span>
 
 	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, &quot;RgnObj %p Addr %8.8X%8.8X Len %X\n&quot;,
 			  obj_desc,
<span class="p_del">-			  ACPI_FORMAT_NATIVE_UINT(obj_desc-&gt;region.address),</span>
<span class="p_add">+			  ACPI_FORMAT_UINT64(obj_desc-&gt;region.address),</span>
 			  obj_desc-&gt;region.length));
 
 	/* Now the address and length are valid for this opregion */
<span class="p_chunk">@@ -539,13 +539,12 @@</span> <span class="p_context"> acpi_ds_eval_table_region_operands(struct acpi_walk_state *walk_state,</span>
 		return_ACPI_STATUS(AE_NOT_EXIST);
 	}
 
<span class="p_del">-	obj_desc-&gt;region.address =</span>
<span class="p_del">-	    (acpi_physical_address) ACPI_TO_INTEGER(table);</span>
<span class="p_add">+	obj_desc-&gt;region.address = ACPI_PTR_TO_PHYSADDR(table);</span>
 	obj_desc-&gt;region.length = table-&gt;length;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, &quot;RgnObj %p Addr %8.8X%8.8X Len %X\n&quot;,
 			  obj_desc,
<span class="p_del">-			  ACPI_FORMAT_NATIVE_UINT(obj_desc-&gt;region.address),</span>
<span class="p_add">+			  ACPI_FORMAT_UINT64(obj_desc-&gt;region.address),</span>
 			  obj_desc-&gt;region.length));
 
 	/* Now the address and length are valid for this opregion */
<span class="p_header">diff --git a/drivers/acpi/acpica/evregion.c b/drivers/acpi/acpica/evregion.c</span>
<span class="p_header">index cd4b231ae760..ee8ec4bf0611 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/evregion.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/evregion.c</span>
<span class="p_chunk">@@ -272,7 +272,7 @@</span> <span class="p_context"> acpi_ev_address_space_dispatch(union acpi_operand_object *region_obj,</span>
 	ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
 			  &quot;Handler %p (@%p) Address %8.8X%8.8X [%s]\n&quot;,
 			  &amp;region_obj-&gt;region.handler-&gt;address_space, handler,
<span class="p_del">-			  ACPI_FORMAT_NATIVE_UINT(address),</span>
<span class="p_add">+			  ACPI_FORMAT_UINT64(address),</span>
 			  acpi_ut_get_region_name(region_obj-&gt;region.
 						  space_id)));
 
<span class="p_header">diff --git a/drivers/acpi/acpica/exdump.c b/drivers/acpi/acpica/exdump.c</span>
<span class="p_header">index 4d046faac48c..b64fb68aa5d3 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/exdump.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/exdump.c</span>
<span class="p_chunk">@@ -622,8 +622,8 @@</span> <span class="p_context"> void acpi_ex_dump_operand(union acpi_operand_object *obj_desc, u32 depth)</span>
 			acpi_os_printf(&quot;\n&quot;);
 		} else {
 			acpi_os_printf(&quot; base %8.8X%8.8X Length %X\n&quot;,
<span class="p_del">-				       ACPI_FORMAT_NATIVE_UINT(obj_desc-&gt;region.</span>
<span class="p_del">-							       address),</span>
<span class="p_add">+				       ACPI_FORMAT_UINT64(obj_desc-&gt;region.</span>
<span class="p_add">+							  address),</span>
 				       obj_desc-&gt;region.length);
 		}
 		break;
<span class="p_header">diff --git a/drivers/acpi/acpica/exfldio.c b/drivers/acpi/acpica/exfldio.c</span>
<span class="p_header">index 49fb742d61b9..98af39f0d677 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/exfldio.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/exfldio.c</span>
<span class="p_chunk">@@ -263,17 +263,15 @@</span> <span class="p_context"> acpi_ex_access_region(union acpi_operand_object *obj_desc,</span>
 	}
 
 	ACPI_DEBUG_PRINT_RAW((ACPI_DB_BFIELD,
<span class="p_del">-			      &quot; Region [%s:%X], Width %X, ByteBase %X, Offset %X at %p\n&quot;,</span>
<span class="p_add">+			      &quot; Region [%s:%X], Width %X, ByteBase %X, Offset %X at %8.8X%8.8X\n&quot;,</span>
 			      acpi_ut_get_region_name(rgn_desc-&gt;region.
 						      space_id),
 			      rgn_desc-&gt;region.space_id,
 			      obj_desc-&gt;common_field.access_byte_width,
 			      obj_desc-&gt;common_field.base_byte_offset,
<span class="p_del">-			      field_datum_byte_offset, ACPI_CAST_PTR(void,</span>
<span class="p_del">-								     (rgn_desc-&gt;</span>
<span class="p_del">-								      region.</span>
<span class="p_del">-								      address +</span>
<span class="p_del">-								      region_offset))));</span>
<span class="p_add">+			      field_datum_byte_offset,</span>
<span class="p_add">+			      ACPI_FORMAT_UINT64(rgn_desc-&gt;region.address +</span>
<span class="p_add">+						 region_offset)));</span>
 
 	/* Invoke the appropriate address_space/op_region handler */
 
<span class="p_header">diff --git a/drivers/acpi/acpica/exregion.c b/drivers/acpi/acpica/exregion.c</span>
<span class="p_header">index 9d28867e60dc..cf4022359dc7 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/exregion.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/exregion.c</span>
<span class="p_chunk">@@ -181,7 +181,7 @@</span> <span class="p_context"> acpi_ex_system_memory_space_handler(u32 function,</span>
 		if (!mem_info-&gt;mapped_logical_address) {
 			ACPI_ERROR((AE_INFO,
 				    &quot;Could not map memory at 0x%8.8X%8.8X, size %u&quot;,
<span class="p_del">-				    ACPI_FORMAT_NATIVE_UINT(address),</span>
<span class="p_add">+				    ACPI_FORMAT_UINT64(address),</span>
 				    (u32) map_length));
 			mem_info-&gt;mapped_length = 0;
 			return_ACPI_STATUS(AE_NO_MEMORY);
<span class="p_chunk">@@ -202,8 +202,7 @@</span> <span class="p_context"> acpi_ex_system_memory_space_handler(u32 function,</span>
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			  &quot;System-Memory (width %u) R/W %u Address=%8.8X%8.8X\n&quot;,
<span class="p_del">-			  bit_width, function,</span>
<span class="p_del">-			  ACPI_FORMAT_NATIVE_UINT(address)));</span>
<span class="p_add">+			  bit_width, function, ACPI_FORMAT_UINT64(address)));</span>
 
 	/*
 	 * Perform the memory read or write
<span class="p_chunk">@@ -318,8 +317,7 @@</span> <span class="p_context"> acpi_ex_system_io_space_handler(u32 function,</span>
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			  &quot;System-IO (width %u) R/W %u Address=%8.8X%8.8X\n&quot;,
<span class="p_del">-			  bit_width, function,</span>
<span class="p_del">-			  ACPI_FORMAT_NATIVE_UINT(address)));</span>
<span class="p_add">+			  bit_width, function, ACPI_FORMAT_UINT64(address)));</span>
 
 	/* Decode the function parameter */
 
<span class="p_header">diff --git a/drivers/acpi/acpica/hwvalid.c b/drivers/acpi/acpica/hwvalid.c</span>
<span class="p_header">index eab70d58852a..fae57584a182 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/hwvalid.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/hwvalid.c</span>
<span class="p_chunk">@@ -142,17 +142,17 @@</span> <span class="p_context"> acpi_hw_validate_io_request(acpi_io_address address, u32 bit_width)</span>
 	byte_width = ACPI_DIV_8(bit_width);
 	last_address = address + byte_width - 1;
 
<span class="p_del">-	ACPI_DEBUG_PRINT((ACPI_DB_IO, &quot;Address %p LastAddress %p Length %X&quot;,</span>
<span class="p_del">-			  ACPI_CAST_PTR(void, address), ACPI_CAST_PTR(void,</span>
<span class="p_del">-								      last_address),</span>
<span class="p_del">-			  byte_width));</span>
<span class="p_add">+	ACPI_DEBUG_PRINT((ACPI_DB_IO,</span>
<span class="p_add">+			  &quot;Address %8.8X%8.8X LastAddress %8.8X%8.8X Length %X&quot;,</span>
<span class="p_add">+			  ACPI_FORMAT_UINT64(address),</span>
<span class="p_add">+			  ACPI_FORMAT_UINT64(last_address), byte_width));</span>
 
 	/* Maximum 16-bit address in I/O space */
 
 	if (last_address &gt; ACPI_UINT16_MAX) {
 		ACPI_ERROR((AE_INFO,
<span class="p_del">-			    &quot;Illegal I/O port address/length above 64K: %p/0x%X&quot;,</span>
<span class="p_del">-			    ACPI_CAST_PTR(void, address), byte_width));</span>
<span class="p_add">+			    &quot;Illegal I/O port address/length above 64K: %8.8X%8.8X/0x%X&quot;,</span>
<span class="p_add">+			    ACPI_FORMAT_UINT64(address), byte_width));</span>
 		return_ACPI_STATUS(AE_LIMIT);
 	}
 
<span class="p_chunk">@@ -181,8 +181,8 @@</span> <span class="p_context"> acpi_hw_validate_io_request(acpi_io_address address, u32 bit_width)</span>
 
 			if (acpi_gbl_osi_data &gt;= port_info-&gt;osi_dependency) {
 				ACPI_DEBUG_PRINT((ACPI_DB_IO,
<span class="p_del">-						  &quot;Denied AML access to port 0x%p/%X (%s 0x%.4X-0x%.4X)&quot;,</span>
<span class="p_del">-						  ACPI_CAST_PTR(void, address),</span>
<span class="p_add">+						  &quot;Denied AML access to port 0x%8.8X%8.8X/%X (%s 0x%.4X-0x%.4X)&quot;,</span>
<span class="p_add">+						  ACPI_FORMAT_UINT64(address),</span>
 						  byte_width, port_info-&gt;name,
 						  port_info-&gt;start,
 						  port_info-&gt;end));
<span class="p_header">diff --git a/drivers/acpi/acpica/nsdump.c b/drivers/acpi/acpica/nsdump.c</span>
<span class="p_header">index 48b9c6f12643..fc82c532090f 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/nsdump.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/nsdump.c</span>
<span class="p_chunk">@@ -271,12 +271,11 @@</span> <span class="p_context"> acpi_ns_dump_one_object(acpi_handle obj_handle,</span>
 		switch (type) {
 		case ACPI_TYPE_PROCESSOR:
 
<span class="p_del">-			acpi_os_printf(&quot;ID %02X Len %02X Addr %p\n&quot;,</span>
<span class="p_add">+			acpi_os_printf(&quot;ID %02X Len %02X Addr %8.8X%8.8X\n&quot;,</span>
 				       obj_desc-&gt;processor.proc_id,
 				       obj_desc-&gt;processor.length,
<span class="p_del">-				       ACPI_CAST_PTR(void,</span>
<span class="p_del">-						     obj_desc-&gt;processor.</span>
<span class="p_del">-						     address));</span>
<span class="p_add">+				       ACPI_FORMAT_UINT64(obj_desc-&gt;processor.</span>
<span class="p_add">+							  address));</span>
 			break;
 
 		case ACPI_TYPE_DEVICE:
<span class="p_chunk">@@ -347,8 +346,9 @@</span> <span class="p_context"> acpi_ns_dump_one_object(acpi_handle obj_handle,</span>
 							       space_id));
 			if (obj_desc-&gt;region.flags &amp; AOPOBJ_DATA_VALID) {
 				acpi_os_printf(&quot; Addr %8.8X%8.8X Len %.4X\n&quot;,
<span class="p_del">-					       ACPI_FORMAT_NATIVE_UINT</span>
<span class="p_del">-					       (obj_desc-&gt;region.address),</span>
<span class="p_add">+					       ACPI_FORMAT_UINT64(obj_desc-&gt;</span>
<span class="p_add">+								  region.</span>
<span class="p_add">+								  address),</span>
 					       obj_desc-&gt;region.length);
 			} else {
 				acpi_os_printf
<span class="p_header">diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c</span>
<span class="p_header">index 634357d51fe9..c4d097700a86 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbinstal.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbinstal.c</span>
<span class="p_chunk">@@ -294,8 +294,7 @@</span> <span class="p_context"> struct acpi_table_header *acpi_tb_table_override(struct acpi_table_header</span>
 			ACPI_EXCEPTION((AE_INFO, AE_NO_MEMORY,
 					&quot;%4.4s %p Attempted physical table override failed&quot;,
 					table_header-&gt;signature,
<span class="p_del">-					ACPI_CAST_PTR(void,</span>
<span class="p_del">-						      table_desc-&gt;address)));</span>
<span class="p_add">+					ACPI_PHYSADDR_TO_PTR(table_desc-&gt;address)));</span>
 			return (NULL);
 		}
 
<span class="p_chunk">@@ -311,7 +310,7 @@</span> <span class="p_context"> finish_override:</span>
 	ACPI_INFO((AE_INFO,
 		   &quot;%4.4s %p %s table override, new table: %p&quot;,
 		   table_header-&gt;signature,
<span class="p_del">-		   ACPI_CAST_PTR(void, table_desc-&gt;address),</span>
<span class="p_add">+		   ACPI_PHYSADDR_TO_PTR(table_desc-&gt;address),</span>
 		   override_type, new_table));
 
 	/* We can now unmap/delete the original table (if fully mapped) */
<span class="p_header">diff --git a/drivers/acpi/acpica/tbprint.c b/drivers/acpi/acpica/tbprint.c</span>
<span class="p_header">index 6866e767ba90..2957ed50b552 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbprint.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbprint.c</span>
<span class="p_chunk">@@ -127,16 +127,12 @@</span> <span class="p_context"> acpi_tb_print_table_header(acpi_physical_address address,</span>
 {
 	struct acpi_table_header local_header;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The reason that the Address is cast to a void pointer is so that we</span>
<span class="p_del">-	 * can use %p which will work properly on both 32-bit and 64-bit hosts.</span>
<span class="p_del">-	 */</span>
 	if (ACPI_COMPARE_NAME(header-&gt;signature, ACPI_SIG_FACS)) {
 
 		/* FACS only has signature and length fields */
 
<span class="p_del">-		ACPI_INFO((AE_INFO, &quot;%4.4s %p %06X&quot;,</span>
<span class="p_del">-			   header-&gt;signature, ACPI_CAST_PTR(void, address),</span>
<span class="p_add">+		ACPI_INFO((AE_INFO, &quot;%-4.4s 0x%8.8X%8.8X %06X&quot;,</span>
<span class="p_add">+			   header-&gt;signature, ACPI_FORMAT_UINT64(address),</span>
 			   header-&gt;length));
 	} else if (ACPI_VALIDATE_RSDP_SIG(header-&gt;signature)) {
 
<span class="p_chunk">@@ -147,8 +143,8 @@</span> <span class="p_context"> acpi_tb_print_table_header(acpi_physical_address address,</span>
 					  header)-&gt;oem_id, ACPI_OEM_ID_SIZE);
 		acpi_tb_fix_string(local_header.oem_id, ACPI_OEM_ID_SIZE);
 
<span class="p_del">-		ACPI_INFO((AE_INFO, &quot;RSDP %p %06X (v%.2d %6.6s)&quot;,</span>
<span class="p_del">-			   ACPI_CAST_PTR(void, address),</span>
<span class="p_add">+		ACPI_INFO((AE_INFO, &quot;RSDP 0x%8.8X%8.8X %06X (v%.2d %-6.6s)&quot;,</span>
<span class="p_add">+			   ACPI_FORMAT_UINT64(address),</span>
 			   (ACPI_CAST_PTR(struct acpi_table_rsdp, header)-&gt;
 			    revision &gt;
 			    0) ? ACPI_CAST_PTR(struct acpi_table_rsdp,
<span class="p_chunk">@@ -162,8 +158,9 @@</span> <span class="p_context"> acpi_tb_print_table_header(acpi_physical_address address,</span>
 		acpi_tb_cleanup_table_header(&amp;local_header, header);
 
 		ACPI_INFO((AE_INFO,
<span class="p_del">-			   &quot;%4.4s %p %06X (v%.2d %6.6s %8.8s %08X %4.4s %08X)&quot;,</span>
<span class="p_del">-			   local_header.signature, ACPI_CAST_PTR(void, address),</span>
<span class="p_add">+			   &quot;%-4.4s 0x%8.8X%8.8X&quot;</span>
<span class="p_add">+			   &quot; %06X (v%.2d %-6.6s %-8.8s %08X %-4.4s %08X)&quot;,</span>
<span class="p_add">+			   local_header.signature, ACPI_FORMAT_UINT64(address),</span>
 			   local_header.length, local_header.revision,
 			   local_header.oem_id, local_header.oem_table_id,
 			   local_header.oem_revision,
<span class="p_header">diff --git a/drivers/acpi/acpica/tbutils.c b/drivers/acpi/acpica/tbutils.c</span>
<span class="p_header">index 1bc879ec83d4..4cca6b797808 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbutils.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbutils.c</span>
<span class="p_chunk">@@ -227,8 +227,8 @@</span> <span class="p_context"> acpi_tb_install_table(acpi_physical_address address,</span>
 	table = acpi_os_map_memory(address, sizeof(struct acpi_table_header));
 	if (!table) {
 		ACPI_ERROR((AE_INFO,
<span class="p_del">-			    &quot;Could not map memory for table [%s] at %p&quot;,</span>
<span class="p_del">-			    signature, ACPI_CAST_PTR(void, address)));</span>
<span class="p_add">+			    &quot;Could not map memory for table [%s] at %8.8X%8.8X&quot;,</span>
<span class="p_add">+			    signature, ACPI_FORMAT_UINT64(address)));</span>
 		return;
 	}
 
<span class="p_header">diff --git a/drivers/acpi/acpica/tbxfload.c b/drivers/acpi/acpica/tbxfload.c</span>
<span class="p_header">index 60b5a871833c..daad59d76e67 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbxfload.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbxfload.c</span>
<span class="p_chunk">@@ -184,11 +184,10 @@</span> <span class="p_context"> static acpi_status acpi_tb_load_namespace(void)</span>
 		 * be useful for debugging ACPI problems on some machines.
 		 */
 		if (acpi_gbl_disable_ssdt_table_load) {
<span class="p_del">-			ACPI_INFO((AE_INFO, &quot;Ignoring %4.4s at %p&quot;,</span>
<span class="p_add">+			ACPI_INFO((AE_INFO, &quot;Ignoring %4.4s at %8.8X%8.8X&quot;,</span>
 				   acpi_gbl_root_table_list.tables[i].signature.
<span class="p_del">-				   ascii, ACPI_CAST_PTR(void,</span>
<span class="p_del">-							acpi_gbl_root_table_list.</span>
<span class="p_del">-							tables[i].address)));</span>
<span class="p_add">+				   ascii, ACPI_FORMAT_UINT64(acpi_gbl_root_table_list.</span>
<span class="p_add">+							     tables[i].address)));</span>
 			continue;
 		}
 
<span class="p_header">diff --git a/drivers/acpi/acpica/tbxfroot.c b/drivers/acpi/acpica/tbxfroot.c</span>
<span class="p_header">index e4e1468877c3..01bf7ebef7a4 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbxfroot.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbxfroot.c</span>
<span class="p_chunk">@@ -111,7 +111,7 @@</span> <span class="p_context"> acpi_status acpi_tb_validate_rsdp(struct acpi_table_rsdp *rsdp)</span>
  *
  ******************************************************************************/
 
<span class="p_del">-acpi_status __init acpi_find_root_pointer(acpi_size *table_address)</span>
<span class="p_add">+acpi_status __init acpi_find_root_pointer(acpi_physical_address * table_address)</span>
 {
 	u8 *table_ptr;
 	u8 *mem_rover;
<span class="p_chunk">@@ -169,7 +169,8 @@</span> <span class="p_context"> acpi_status __init acpi_find_root_pointer(acpi_size *table_address)</span>
 			physical_address +=
 			    (u32) ACPI_PTR_DIFF(mem_rover, table_ptr);
 
<span class="p_del">-			*table_address = physical_address;</span>
<span class="p_add">+			*table_address =</span>
<span class="p_add">+			    (acpi_physical_address) physical_address;</span>
 			return_ACPI_STATUS(AE_OK);
 		}
 	}
<span class="p_chunk">@@ -202,7 +203,7 @@</span> <span class="p_context"> acpi_status __init acpi_find_root_pointer(acpi_size *table_address)</span>
 		    (ACPI_HI_RSDP_WINDOW_BASE +
 		     ACPI_PTR_DIFF(mem_rover, table_ptr));
 
<span class="p_del">-		*table_address = physical_address;</span>
<span class="p_add">+		*table_address = (acpi_physical_address) physical_address;</span>
 		return_ACPI_STATUS(AE_OK);
 	}
 
<span class="p_header">diff --git a/drivers/acpi/acpica/utaddress.c b/drivers/acpi/acpica/utaddress.c</span>
<span class="p_header">index 2c2b6ae5dfc4..3a02b65a1d9e 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/utaddress.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/utaddress.c</span>
<span class="p_chunk">@@ -107,10 +107,10 @@</span> <span class="p_context"> acpi_ut_add_address_range(acpi_adr_space_type space_id,</span>
 	acpi_gbl_address_range_list[space_id] = range_info;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
<span class="p_del">-			  &quot;\nAdded [%4.4s] address range: 0x%p-0x%p\n&quot;,</span>
<span class="p_add">+			  &quot;\nAdded [%4.4s] address range: 0x%8.8X%8.8X-0x%8.8X%8.8X\n&quot;,</span>
 			  acpi_ut_get_node_name(range_info-&gt;region_node),
<span class="p_del">-			  ACPI_CAST_PTR(void, address),</span>
<span class="p_del">-			  ACPI_CAST_PTR(void, range_info-&gt;end_address)));</span>
<span class="p_add">+			  ACPI_FORMAT_UINT64(address),</span>
<span class="p_add">+			  ACPI_FORMAT_UINT64(range_info-&gt;end_address)));</span>
 
 	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
 	return_ACPI_STATUS(AE_OK);
<span class="p_chunk">@@ -160,15 +160,13 @@</span> <span class="p_context"> acpi_ut_remove_address_range(acpi_adr_space_type space_id,</span>
 			}
 
 			ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
<span class="p_del">-					  &quot;\nRemoved [%4.4s] address range: 0x%p-0x%p\n&quot;,</span>
<span class="p_add">+					  &quot;\nRemoved [%4.4s] address range: 0x%8.8X%8.8X-0x%8.8X%8.8X\n&quot;,</span>
 					  acpi_ut_get_node_name(range_info-&gt;
 								region_node),
<span class="p_del">-					  ACPI_CAST_PTR(void,</span>
<span class="p_del">-							range_info-&gt;</span>
<span class="p_del">-							start_address),</span>
<span class="p_del">-					  ACPI_CAST_PTR(void,</span>
<span class="p_del">-							range_info-&gt;</span>
<span class="p_del">-							end_address)));</span>
<span class="p_add">+					  ACPI_FORMAT_UINT64(range_info-&gt;</span>
<span class="p_add">+							     start_address),</span>
<span class="p_add">+					  ACPI_FORMAT_UINT64(range_info-&gt;</span>
<span class="p_add">+							     end_address)));</span>
 
 			ACPI_FREE(range_info);
 			return_VOID;
<span class="p_chunk">@@ -245,16 +243,14 @@</span> <span class="p_context"> acpi_ut_check_address_range(acpi_adr_space_type space_id,</span>
 								  region_node);
 
 				ACPI_WARNING((AE_INFO,
<span class="p_del">-					      &quot;%s range 0x%p-0x%p conflicts with OpRegion 0x%p-0x%p (%s)&quot;,</span>
<span class="p_add">+					      &quot;%s range 0x%8.8X%8.8X-0x%8.8X%8.8X conflicts with OpRegion 0x%8.8X%8.8X-0x%8.8X%8.8X (%s)&quot;,</span>
 					      acpi_ut_get_region_name(space_id),
<span class="p_del">-					      ACPI_CAST_PTR(void, address),</span>
<span class="p_del">-					      ACPI_CAST_PTR(void, end_address),</span>
<span class="p_del">-					      ACPI_CAST_PTR(void,</span>
<span class="p_del">-							    range_info-&gt;</span>
<span class="p_del">-							    start_address),</span>
<span class="p_del">-					      ACPI_CAST_PTR(void,</span>
<span class="p_del">-							    range_info-&gt;</span>
<span class="p_del">-							    end_address),</span>
<span class="p_add">+					      ACPI_FORMAT_UINT64(address),</span>
<span class="p_add">+					      ACPI_FORMAT_UINT64(end_address),</span>
<span class="p_add">+					      ACPI_FORMAT_UINT64(range_info-&gt;</span>
<span class="p_add">+								 start_address),</span>
<span class="p_add">+					      ACPI_FORMAT_UINT64(range_info-&gt;</span>
<span class="p_add">+								 end_address),</span>
 					      pathname));
 				ACPI_FREE(pathname);
 			}
<span class="p_header">diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c</span>
<span class="p_header">index f1fc14c33be5..a03e18f5e562 100644</span>
<span class="p_header">--- a/drivers/gpio/gpiolib.c</span>
<span class="p_header">+++ b/drivers/gpio/gpiolib.c</span>
<span class="p_chunk">@@ -800,6 +800,7 @@</span> <span class="p_context"> static struct class gpio_class = {</span>
  */
 int gpiod_export(struct gpio_desc *desc, bool direction_may_change)
 {
<span class="p_add">+	struct gpio_chip	*chip;</span>
 	unsigned long		flags;
 	int			status;
 	const char		*ioname = NULL;
<span class="p_chunk">@@ -817,8 +818,16 @@</span> <span class="p_context"> int gpiod_export(struct gpio_desc *desc, bool direction_may_change)</span>
 		return -EINVAL;
 	}
 
<span class="p_add">+	chip = desc-&gt;chip;</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;sysfs_lock);
 
<span class="p_add">+	/* check if chip is being removed */</span>
<span class="p_add">+	if (!chip || !chip-&gt;exported) {</span>
<span class="p_add">+		status = -ENODEV;</span>
<span class="p_add">+		goto fail_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;gpio_lock, flags);
 	if (!test_bit(FLAG_REQUESTED, &amp;desc-&gt;flags) ||
 	     test_bit(FLAG_EXPORT, &amp;desc-&gt;flags)) {
<span class="p_chunk">@@ -1057,12 +1066,15 @@</span> <span class="p_context"> static void gpiochip_unexport(struct gpio_chip *chip)</span>
 {
 	int			status;
 	struct device		*dev;
<span class="p_add">+	struct gpio_desc *desc;</span>
<span class="p_add">+	unsigned int i;</span>
 
 	mutex_lock(&amp;sysfs_lock);
 	dev = class_find_device(&amp;gpio_class, NULL, chip, match_export);
 	if (dev) {
 		put_device(dev);
 		device_unregister(dev);
<span class="p_add">+		/* prevent further gpiod exports */</span>
 		chip-&gt;exported = false;
 		status = 0;
 	} else
<span class="p_chunk">@@ -1071,6 +1083,13 @@</span> <span class="p_context"> static void gpiochip_unexport(struct gpio_chip *chip)</span>
 
 	if (status)
 		chip_dbg(chip, &quot;%s: status %d\n&quot;, __func__, status);
<span class="p_add">+</span>
<span class="p_add">+	/* unregister gpiod class devices owned by sysfs */</span>
<span class="p_add">+	for (i = 0; i &lt; chip-&gt;ngpio; i++) {</span>
<span class="p_add">+		desc = &amp;chip-&gt;desc[i];</span>
<span class="p_add">+		if (test_and_clear_bit(FLAG_SYSFS, &amp;desc-&gt;flags))</span>
<span class="p_add">+			gpiod_free(desc);</span>
<span class="p_add">+	}</span>
 }
 
 static int __init gpiolib_sysfs_init(void)
<span class="p_chunk">@@ -1265,6 +1284,8 @@</span> <span class="p_context"> int gpiochip_remove(struct gpio_chip *chip)</span>
 	int		status = 0;
 	unsigned	id;
 
<span class="p_add">+	gpiochip_unexport(chip);</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;gpio_lock, flags);
 
 	gpiochip_remove_pin_ranges(chip);
<span class="p_chunk">@@ -1286,9 +1307,6 @@</span> <span class="p_context"> int gpiochip_remove(struct gpio_chip *chip)</span>
 
 	spin_unlock_irqrestore(&amp;gpio_lock, flags);
 
<span class="p_del">-	if (status == 0)</span>
<span class="p_del">-		gpiochip_unexport(chip);</span>
<span class="p_del">-</span>
 	return status;
 }
 EXPORT_SYMBOL_GPL(gpiochip_remove);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_lvds.c b/drivers/gpu/drm/i915/intel_lvds.c</span>
<span class="p_header">index af49b24d14cb..1eb49941faff 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_lvds.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_lvds.c</span>
<span class="p_chunk">@@ -815,12 +815,28 @@</span> <span class="p_context"> static int intel_dual_link_lvds_callback(const struct dmi_system_id *id)</span>
 static const struct dmi_system_id intel_dual_link_lvds[] = {
 	{
 		.callback = intel_dual_link_lvds_callback,
<span class="p_del">-		.ident = &quot;Apple MacBook Pro (Core i5/i7 Series)&quot;,</span>
<span class="p_add">+		.ident = &quot;Apple MacBook Pro 15\&quot; (2010)&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Apple Inc.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;MacBookPro6,2&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = intel_dual_link_lvds_callback,</span>
<span class="p_add">+		.ident = &quot;Apple MacBook Pro 15\&quot; (2011)&quot;,</span>
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, &quot;Apple Inc.&quot;),
 			DMI_MATCH(DMI_PRODUCT_NAME, &quot;MacBookPro8,2&quot;),
 		},
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = intel_dual_link_lvds_callback,</span>
<span class="p_add">+		.ident = &quot;Apple MacBook Pro 15\&quot; (2012)&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Apple Inc.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;MacBookPro9,1&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 	{ }	/* terminating entry */
 };
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_asic.c b/drivers/gpu/drm/radeon/radeon_asic.c</span>
<span class="p_header">index 64d6cfba9952..d625a14ec038 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_asic.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_asic.c</span>
<span class="p_chunk">@@ -1173,7 +1173,7 @@</span> <span class="p_context"> static struct radeon_asic rs780_asic = {</span>
 static struct radeon_asic_ring rv770_uvd_ring = {
 	.ib_execute = &amp;uvd_v1_0_ib_execute,
 	.emit_fence = &amp;uvd_v2_2_fence_emit,
<span class="p_del">-	.emit_semaphore = &amp;uvd_v1_0_semaphore_emit,</span>
<span class="p_add">+	.emit_semaphore = &amp;uvd_v2_2_semaphore_emit,</span>
 	.cs_parse = &amp;radeon_uvd_cs_parse,
 	.ring_test = &amp;uvd_v1_0_ring_test,
 	.ib_test = &amp;uvd_v1_0_ib_test,
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_asic.h b/drivers/gpu/drm/radeon/radeon_asic.h</span>
<span class="p_header">index ae637cfda783..f6e19edb1166 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_asic.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_asic.h</span>
<span class="p_chunk">@@ -853,6 +853,10 @@</span> <span class="p_context"> void uvd_v1_0_ib_execute(struct radeon_device *rdev, struct radeon_ib *ib);</span>
 int uvd_v2_2_resume(struct radeon_device *rdev);
 void uvd_v2_2_fence_emit(struct radeon_device *rdev,
 			 struct radeon_fence *fence);
<span class="p_add">+bool uvd_v2_2_semaphore_emit(struct radeon_device *rdev,</span>
<span class="p_add">+			     struct radeon_ring *ring,</span>
<span class="p_add">+			     struct radeon_semaphore *semaphore,</span>
<span class="p_add">+			     bool emit_wait);</span>
 
 /* uvd v3.1 */
 bool uvd_v3_1_semaphore_emit(struct radeon_device *rdev,
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_uvd.c b/drivers/gpu/drm/radeon/radeon_uvd.c</span>
<span class="p_header">index 414e07928693..bcfac7624550 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_uvd.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_uvd.c</span>
<span class="p_chunk">@@ -350,6 +350,29 @@</span> <span class="p_context"> static int radeon_uvd_cs_msg_decode(uint32_t *msg, unsigned buf_sizes[])</span>
 	return 0;
 }
 
<span class="p_add">+static int radeon_uvd_validate_codec(struct radeon_cs_parser *p,</span>
<span class="p_add">+				     unsigned stream_type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (stream_type) {</span>
<span class="p_add">+	case 0: /* H264 */</span>
<span class="p_add">+	case 1: /* VC1 */</span>
<span class="p_add">+		/* always supported */</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	case 3: /* MPEG2 */</span>
<span class="p_add">+	case 4: /* MPEG4 */</span>
<span class="p_add">+		/* only since UVD 3 */</span>
<span class="p_add">+		if (p-&gt;rdev-&gt;family &gt;= CHIP_PALM)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* fall through */</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		DRM_ERROR(&quot;UVD codec not supported by hardware %d!\n&quot;,</span>
<span class="p_add">+			  stream_type);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int radeon_uvd_cs_msg(struct radeon_cs_parser *p, struct radeon_bo *bo,
 			     unsigned offset, unsigned buf_sizes[])
 {
<span class="p_chunk">@@ -388,50 +411,70 @@</span> <span class="p_context"> static int radeon_uvd_cs_msg(struct radeon_cs_parser *p, struct radeon_bo *bo,</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	if (msg_type == 1) {</span>
<span class="p_del">-		/* it&#39;s a decode msg, calc buffer sizes */</span>
<span class="p_del">-		r = radeon_uvd_cs_msg_decode(msg, buf_sizes);</span>
<span class="p_del">-		/* calc image size (width * height) */</span>
<span class="p_del">-		img_size = msg[6] * msg[7];</span>
<span class="p_add">+	switch (msg_type) {</span>
<span class="p_add">+	case 0:</span>
<span class="p_add">+		/* it&#39;s a create msg, calc image size (width * height) */</span>
<span class="p_add">+		img_size = msg[7] * msg[8];</span>
<span class="p_add">+</span>
<span class="p_add">+		r = radeon_uvd_validate_codec(p, msg[4]);</span>
<span class="p_add">+		radeon_bo_kunmap(bo);</span>
<span class="p_add">+		if (r)</span>
<span class="p_add">+			return r;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* try to alloc a new handle */</span>
<span class="p_add">+		for (i = 0; i &lt; RADEON_MAX_UVD_HANDLES; ++i) {</span>
<span class="p_add">+			if (atomic_read(&amp;p-&gt;rdev-&gt;uvd.handles[i]) == handle) {</span>
<span class="p_add">+				DRM_ERROR(&quot;Handle 0x%x already in use!\n&quot;, handle);</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (!atomic_cmpxchg(&amp;p-&gt;rdev-&gt;uvd.handles[i], 0, handle)) {</span>
<span class="p_add">+				p-&gt;rdev-&gt;uvd.filp[i] = p-&gt;filp;</span>
<span class="p_add">+				p-&gt;rdev-&gt;uvd.img_size[i] = img_size;</span>
<span class="p_add">+				return 0;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		DRM_ERROR(&quot;No more free UVD handles!\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	case 1:</span>
<span class="p_add">+		/* it&#39;s a decode msg, validate codec and calc buffer sizes */</span>
<span class="p_add">+		r = radeon_uvd_validate_codec(p, msg[4]);</span>
<span class="p_add">+		if (!r)</span>
<span class="p_add">+			r = radeon_uvd_cs_msg_decode(msg, buf_sizes);</span>
 		radeon_bo_kunmap(bo);
 		if (r)
 			return r;
 
<span class="p_del">-	} else if (msg_type == 2) {</span>
<span class="p_add">+		/* validate the handle */</span>
<span class="p_add">+		for (i = 0; i &lt; RADEON_MAX_UVD_HANDLES; ++i) {</span>
<span class="p_add">+			if (atomic_read(&amp;p-&gt;rdev-&gt;uvd.handles[i]) == handle) {</span>
<span class="p_add">+				if (p-&gt;rdev-&gt;uvd.filp[i] != p-&gt;filp) {</span>
<span class="p_add">+					DRM_ERROR(&quot;UVD handle collision detected!\n&quot;);</span>
<span class="p_add">+					return -EINVAL;</span>
<span class="p_add">+				}</span>
<span class="p_add">+				return 0;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		DRM_ERROR(&quot;Invalid UVD handle 0x%x!\n&quot;, handle);</span>
<span class="p_add">+		return -ENOENT;</span>
<span class="p_add">+</span>
<span class="p_add">+	case 2:</span>
 		/* it&#39;s a destroy msg, free the handle */
 		for (i = 0; i &lt; RADEON_MAX_UVD_HANDLES; ++i)
 			atomic_cmpxchg(&amp;p-&gt;rdev-&gt;uvd.handles[i], handle, 0);
 		radeon_bo_kunmap(bo);
 		return 0;
<span class="p_del">-	} else {</span>
<span class="p_del">-		/* it&#39;s a create msg, calc image size (width * height) */</span>
<span class="p_del">-		img_size = msg[7] * msg[8];</span>
<span class="p_del">-		radeon_bo_kunmap(bo);</span>
 
<span class="p_del">-		if (msg_type != 0) {</span>
<span class="p_del">-			DRM_ERROR(&quot;Illegal UVD message type (%d)!\n&quot;, msg_type);</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/* it&#39;s a create msg, no special handling needed */</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* create or decode, validate the handle */</span>
<span class="p_del">-	for (i = 0; i &lt; RADEON_MAX_UVD_HANDLES; ++i) {</span>
<span class="p_del">-		if (atomic_read(&amp;p-&gt;rdev-&gt;uvd.handles[i]) == handle)</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	default:</span>
 
<span class="p_del">-	/* handle not found try to alloc a new one */</span>
<span class="p_del">-	for (i = 0; i &lt; RADEON_MAX_UVD_HANDLES; ++i) {</span>
<span class="p_del">-		if (!atomic_cmpxchg(&amp;p-&gt;rdev-&gt;uvd.handles[i], 0, handle)) {</span>
<span class="p_del">-			p-&gt;rdev-&gt;uvd.filp[i] = p-&gt;filp;</span>
<span class="p_del">-			p-&gt;rdev-&gt;uvd.img_size[i] = img_size;</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		DRM_ERROR(&quot;Illegal UVD message type (%d)!\n&quot;, msg_type);</span>
<span class="p_add">+		return -EINVAL;</span>
 	}
 
<span class="p_del">-	DRM_ERROR(&quot;No more free UVD handles!\n&quot;);</span>
<span class="p_add">+	BUG();</span>
 	return -EINVAL;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/rv770d.h b/drivers/gpu/drm/radeon/rv770d.h</span>
<span class="p_header">index 3cf1e2921545..9ef2064b1c9c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/rv770d.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/rv770d.h</span>
<span class="p_chunk">@@ -989,6 +989,9 @@</span> <span class="p_context"></span>
 			 ((n) &amp; 0x3FFF) &lt;&lt; 16)
 
 /* UVD */
<span class="p_add">+#define UVD_SEMA_ADDR_LOW				0xef00</span>
<span class="p_add">+#define UVD_SEMA_ADDR_HIGH				0xef04</span>
<span class="p_add">+#define UVD_SEMA_CMD					0xef08</span>
 #define UVD_GPCOM_VCPU_CMD				0xef0c
 #define UVD_GPCOM_VCPU_DATA0				0xef10
 #define UVD_GPCOM_VCPU_DATA1				0xef14
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/uvd_v1_0.c b/drivers/gpu/drm/radeon/uvd_v1_0.c</span>
<span class="p_header">index c310a0aeebb9..0fa9009fef64 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/uvd_v1_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/uvd_v1_0.c</span>
<span class="p_chunk">@@ -365,18 +365,8 @@</span> <span class="p_context"> bool uvd_v1_0_semaphore_emit(struct radeon_device *rdev,</span>
 			     struct radeon_semaphore *semaphore,
 			     bool emit_wait)
 {
<span class="p_del">-	uint64_t addr = semaphore-&gt;gpu_addr;</span>
<span class="p_del">-</span>
<span class="p_del">-	radeon_ring_write(ring, PACKET0(UVD_SEMA_ADDR_LOW, 0));</span>
<span class="p_del">-	radeon_ring_write(ring, (addr &gt;&gt; 3) &amp; 0x000FFFFF);</span>
<span class="p_del">-</span>
<span class="p_del">-	radeon_ring_write(ring, PACKET0(UVD_SEMA_ADDR_HIGH, 0));</span>
<span class="p_del">-	radeon_ring_write(ring, (addr &gt;&gt; 23) &amp; 0x000FFFFF);</span>
<span class="p_del">-</span>
<span class="p_del">-	radeon_ring_write(ring, PACKET0(UVD_SEMA_CMD, 0));</span>
<span class="p_del">-	radeon_ring_write(ring, emit_wait ? 1 : 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	return true;</span>
<span class="p_add">+	/* disable semaphores for UVD V1 hardware */</span>
<span class="p_add">+	return false;</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/uvd_v2_2.c b/drivers/gpu/drm/radeon/uvd_v2_2.c</span>
<span class="p_header">index d1771004cb52..19ccb2ae7a5d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/uvd_v2_2.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/uvd_v2_2.c</span>
<span class="p_chunk">@@ -60,6 +60,35 @@</span> <span class="p_context"> void uvd_v2_2_fence_emit(struct radeon_device *rdev,</span>
 }
 
 /**
<span class="p_add">+ * uvd_v2_2_semaphore_emit - emit semaphore command</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @rdev: radeon_device pointer</span>
<span class="p_add">+ * @ring: radeon_ring pointer</span>
<span class="p_add">+ * @semaphore: semaphore to emit commands for</span>
<span class="p_add">+ * @emit_wait: true if we should emit a wait command</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Emit a semaphore command (either wait or signal) to the UVD ring.</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool uvd_v2_2_semaphore_emit(struct radeon_device *rdev,</span>
<span class="p_add">+			     struct radeon_ring *ring,</span>
<span class="p_add">+			     struct radeon_semaphore *semaphore,</span>
<span class="p_add">+			     bool emit_wait)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint64_t addr = semaphore-&gt;gpu_addr;</span>
<span class="p_add">+</span>
<span class="p_add">+	radeon_ring_write(ring, PACKET0(UVD_SEMA_ADDR_LOW, 0));</span>
<span class="p_add">+	radeon_ring_write(ring, (addr &gt;&gt; 3) &amp; 0x000FFFFF);</span>
<span class="p_add">+</span>
<span class="p_add">+	radeon_ring_write(ring, PACKET0(UVD_SEMA_ADDR_HIGH, 0));</span>
<span class="p_add">+	radeon_ring_write(ring, (addr &gt;&gt; 23) &amp; 0x000FFFFF);</span>
<span class="p_add">+</span>
<span class="p_add">+	radeon_ring_write(ring, PACKET0(UVD_SEMA_CMD, 0));</span>
<span class="p_add">+	radeon_ring_write(ring, emit_wait ? 1 : 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * uvd_v2_2_resume - memory controller programming
  *
  * @rdev: radeon_device pointer
<span class="p_header">diff --git a/drivers/infiniband/core/cma.c b/drivers/infiniband/core/cma.c</span>
<span class="p_header">index 42c3058e6e9c..dbd7d66977c9 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/cma.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/cma.c</span>
<span class="p_chunk">@@ -859,19 +859,27 @@</span> <span class="p_context"> static void cma_save_ib_info(struct rdma_cm_id *id, struct rdma_cm_id *listen_id</span>
 	memcpy(&amp;ib-&gt;sib_addr, &amp;path-&gt;dgid, 16);
 }
 
<span class="p_add">+static __be16 ss_get_port(const struct sockaddr_storage *ss)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (ss-&gt;ss_family == AF_INET)</span>
<span class="p_add">+		return ((struct sockaddr_in *)ss)-&gt;sin_port;</span>
<span class="p_add">+	else if (ss-&gt;ss_family == AF_INET6)</span>
<span class="p_add">+		return ((struct sockaddr_in6 *)ss)-&gt;sin6_port;</span>
<span class="p_add">+	BUG();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void cma_save_ip4_info(struct rdma_cm_id *id, struct rdma_cm_id *listen_id,
 			      struct cma_hdr *hdr)
 {
<span class="p_del">-	struct sockaddr_in *listen4, *ip4;</span>
<span class="p_add">+	struct sockaddr_in *ip4;</span>
 
<span class="p_del">-	listen4 = (struct sockaddr_in *) &amp;listen_id-&gt;route.addr.src_addr;</span>
 	ip4 = (struct sockaddr_in *) &amp;id-&gt;route.addr.src_addr;
<span class="p_del">-	ip4-&gt;sin_family = listen4-&gt;sin_family;</span>
<span class="p_add">+	ip4-&gt;sin_family = AF_INET;</span>
 	ip4-&gt;sin_addr.s_addr = hdr-&gt;dst_addr.ip4.addr;
<span class="p_del">-	ip4-&gt;sin_port = listen4-&gt;sin_port;</span>
<span class="p_add">+	ip4-&gt;sin_port = ss_get_port(&amp;listen_id-&gt;route.addr.src_addr);</span>
 
 	ip4 = (struct sockaddr_in *) &amp;id-&gt;route.addr.dst_addr;
<span class="p_del">-	ip4-&gt;sin_family = listen4-&gt;sin_family;</span>
<span class="p_add">+	ip4-&gt;sin_family = AF_INET;</span>
 	ip4-&gt;sin_addr.s_addr = hdr-&gt;src_addr.ip4.addr;
 	ip4-&gt;sin_port = hdr-&gt;port;
 }
<span class="p_chunk">@@ -879,16 +887,15 @@</span> <span class="p_context"> static void cma_save_ip4_info(struct rdma_cm_id *id, struct rdma_cm_id *listen_i</span>
 static void cma_save_ip6_info(struct rdma_cm_id *id, struct rdma_cm_id *listen_id,
 			      struct cma_hdr *hdr)
 {
<span class="p_del">-	struct sockaddr_in6 *listen6, *ip6;</span>
<span class="p_add">+	struct sockaddr_in6 *ip6;</span>
 
<span class="p_del">-	listen6 = (struct sockaddr_in6 *) &amp;listen_id-&gt;route.addr.src_addr;</span>
 	ip6 = (struct sockaddr_in6 *) &amp;id-&gt;route.addr.src_addr;
<span class="p_del">-	ip6-&gt;sin6_family = listen6-&gt;sin6_family;</span>
<span class="p_add">+	ip6-&gt;sin6_family = AF_INET6;</span>
 	ip6-&gt;sin6_addr = hdr-&gt;dst_addr.ip6;
<span class="p_del">-	ip6-&gt;sin6_port = listen6-&gt;sin6_port;</span>
<span class="p_add">+	ip6-&gt;sin6_port = ss_get_port(&amp;listen_id-&gt;route.addr.src_addr);</span>
 
 	ip6 = (struct sockaddr_in6 *) &amp;id-&gt;route.addr.dst_addr;
<span class="p_del">-	ip6-&gt;sin6_family = listen6-&gt;sin6_family;</span>
<span class="p_add">+	ip6-&gt;sin6_family = AF_INET6;</span>
 	ip6-&gt;sin6_addr = hdr-&gt;src_addr.ip6;
 	ip6-&gt;sin6_port = hdr-&gt;port;
 }
<span class="p_header">diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c</span>
<span class="p_header">index 5a4cda24e302..4a8d19d0a5a4 100644</span>
<span class="p_header">--- a/drivers/md/dm-crypt.c</span>
<span class="p_header">+++ b/drivers/md/dm-crypt.c</span>
<span class="p_chunk">@@ -915,10 +915,11 @@</span> <span class="p_context"> static int crypt_convert(struct crypt_config *cc,</span>
 
 		switch (r) {
 		/* async */
<span class="p_del">-		case -EINPROGRESS:</span>
 		case -EBUSY:
 			wait_for_completion(&amp;ctx-&gt;restart);
 			reinit_completion(&amp;ctx-&gt;restart);
<span class="p_add">+			/* fall through*/</span>
<span class="p_add">+		case -EINPROGRESS:</span>
 			ctx-&gt;req = NULL;
 			ctx-&gt;cc_sector++;
 			continue;
<span class="p_chunk">@@ -1313,8 +1314,10 @@</span> <span class="p_context"> static void kcryptd_async_done(struct crypto_async_request *async_req,</span>
 	struct dm_crypt_io *io = container_of(ctx, struct dm_crypt_io, ctx);
 	struct crypt_config *cc = io-&gt;cc;
 
<span class="p_del">-	if (error == -EINPROGRESS)</span>
<span class="p_add">+	if (error == -EINPROGRESS) {</span>
<span class="p_add">+		complete(&amp;ctx-&gt;restart);</span>
 		return;
<span class="p_add">+	}</span>
 
 	if (!error &amp;&amp; cc-&gt;iv_gen_ops &amp;&amp; cc-&gt;iv_gen_ops-&gt;post)
 		error = cc-&gt;iv_gen_ops-&gt;post(cc, iv_of_dmreq(cc, dmreq), dmreq);
<span class="p_chunk">@@ -1325,15 +1328,12 @@</span> <span class="p_context"> static void kcryptd_async_done(struct crypto_async_request *async_req,</span>
 	mempool_free(req_of_dmreq(cc, dmreq), cc-&gt;req_pool);
 
 	if (!atomic_dec_and_test(&amp;ctx-&gt;cc_pending))
<span class="p_del">-		goto done;</span>
<span class="p_add">+		return;</span>
 
 	if (bio_data_dir(io-&gt;base_bio) == READ)
 		kcryptd_crypt_read_done(io);
 	else
 		kcryptd_crypt_write_io_submit(io, 1);
<span class="p_del">-done:</span>
<span class="p_del">-	if (!completion_done(&amp;ctx-&gt;restart))</span>
<span class="p_del">-		complete(&amp;ctx-&gt;restart);</span>
 }
 
 static void kcryptd_crypt(struct work_struct *work)
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index df72c478c5a2..b1e21fc869c3 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -951,6 +951,18 @@</span> <span class="p_context"> static inline void mmc_blk_reset_success(struct mmc_blk_data *md, int type)</span>
 	md-&gt;reset_done &amp;= ~type;
 }
 
<span class="p_add">+int mmc_access_rpmb(struct mmc_queue *mq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mmc_blk_data *md = mq-&gt;data;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If this is a RPMB partition access, return ture</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (md &amp;&amp; md-&gt;part_type == EXT_CSD_PART_CONFIG_ACC_RPMB)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int mmc_blk_issue_discard_rq(struct mmc_queue *mq, struct request *req)
 {
 	struct mmc_blk_data *md = mq-&gt;data;
<span class="p_header">diff --git a/drivers/mmc/card/queue.c b/drivers/mmc/card/queue.c</span>
<span class="p_header">index 3e049c13429c..6ceede0a0bf7 100644</span>
<span class="p_header">--- a/drivers/mmc/card/queue.c</span>
<span class="p_header">+++ b/drivers/mmc/card/queue.c</span>
<span class="p_chunk">@@ -38,7 +38,7 @@</span> <span class="p_context"> static int mmc_prep_request(struct request_queue *q, struct request *req)</span>
 		return BLKPREP_KILL;
 	}
 
<span class="p_del">-	if (mq &amp;&amp; mmc_card_removed(mq-&gt;card))</span>
<span class="p_add">+	if (mq &amp;&amp; (mmc_card_removed(mq-&gt;card) || mmc_access_rpmb(mq)))</span>
 		return BLKPREP_KILL;
 
 	req-&gt;cmd_flags |= REQ_DONTPREP;
<span class="p_header">diff --git a/drivers/mmc/card/queue.h b/drivers/mmc/card/queue.h</span>
<span class="p_header">index 5752d50049a3..99e6521e6169 100644</span>
<span class="p_header">--- a/drivers/mmc/card/queue.h</span>
<span class="p_header">+++ b/drivers/mmc/card/queue.h</span>
<span class="p_chunk">@@ -73,4 +73,6 @@</span> <span class="p_context"> extern void mmc_queue_bounce_post(struct mmc_queue_req *);</span>
 extern int mmc_packed_init(struct mmc_queue *, struct mmc_card *);
 extern void mmc_packed_clean(struct mmc_queue *);
 
<span class="p_add">+extern int mmc_access_rpmb(struct mmc_queue *);</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c</span>
<span class="p_header">index 098374b1ab2b..6a881ebe5b02 100644</span>
<span class="p_header">--- a/drivers/mmc/core/core.c</span>
<span class="p_header">+++ b/drivers/mmc/core/core.c</span>
<span class="p_chunk">@@ -2657,6 +2657,7 @@</span> <span class="p_context"> int mmc_pm_notify(struct notifier_block *notify_block,</span>
 	switch (mode) {
 	case PM_HIBERNATION_PREPARE:
 	case PM_SUSPEND_PREPARE:
<span class="p_add">+	case PM_RESTORE_PREPARE:</span>
 		spin_lock_irqsave(&amp;host-&gt;lock, flags);
 		host-&gt;rescan_disable = 1;
 		spin_unlock_irqrestore(&amp;host-&gt;lock, flags);
<span class="p_header">diff --git a/drivers/mmc/host/sh_mmcif.c b/drivers/mmc/host/sh_mmcif.c</span>
<span class="p_header">index 54730f4aac87..9c208fdf43ab 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sh_mmcif.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sh_mmcif.c</span>
<span class="p_chunk">@@ -1401,7 +1401,7 @@</span> <span class="p_context"> static int sh_mmcif_probe(struct platform_device *pdev)</span>
 	host		= mmc_priv(mmc);
 	host-&gt;mmc	= mmc;
 	host-&gt;addr	= reg;
<span class="p_del">-	host-&gt;timeout	= msecs_to_jiffies(1000);</span>
<span class="p_add">+	host-&gt;timeout	= msecs_to_jiffies(10000);</span>
 	host-&gt;ccs_enable = !pd || !pd-&gt;ccs_unsupported;
 	host-&gt;clk_ctrl2_enable = pd &amp;&amp; pd-&gt;clk_ctrl2_present;
 
<span class="p_header">diff --git a/drivers/pinctrl/core.c b/drivers/pinctrl/core.c</span>
<span class="p_header">index 988f5e18763a..a2a79c737b1b 100644</span>
<span class="p_header">--- a/drivers/pinctrl/core.c</span>
<span class="p_header">+++ b/drivers/pinctrl/core.c</span>
<span class="p_chunk">@@ -1121,7 +1121,7 @@</span> <span class="p_context"> void devm_pinctrl_put(struct pinctrl *p)</span>
 EXPORT_SYMBOL_GPL(devm_pinctrl_put);
 
 int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,
<span class="p_del">-			 bool dup, bool locked)</span>
<span class="p_add">+			 bool dup)</span>
 {
 	int i, ret;
 	struct pinctrl_maps *maps_node;
<span class="p_chunk">@@ -1189,11 +1189,9 @@</span> <span class="p_context"> int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,</span>
 		maps_node-&gt;maps = maps;
 	}
 
<span class="p_del">-	if (!locked)</span>
<span class="p_del">-		mutex_lock(&amp;pinctrl_maps_mutex);</span>
<span class="p_add">+	mutex_lock(&amp;pinctrl_maps_mutex);</span>
 	list_add_tail(&amp;maps_node-&gt;node, &amp;pinctrl_maps);
<span class="p_del">-	if (!locked)</span>
<span class="p_del">-		mutex_unlock(&amp;pinctrl_maps_mutex);</span>
<span class="p_add">+	mutex_unlock(&amp;pinctrl_maps_mutex);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1208,7 +1206,7 @@</span> <span class="p_context"> int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,</span>
 int pinctrl_register_mappings(struct pinctrl_map const *maps,
 			      unsigned num_maps)
 {
<span class="p_del">-	return pinctrl_register_map(maps, num_maps, true, false);</span>
<span class="p_add">+	return pinctrl_register_map(maps, num_maps, true);</span>
 }
 
 void pinctrl_unregister_map(struct pinctrl_map const *map)
<span class="p_header">diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h</span>
<span class="p_header">index 75476b3d87da..b24ea846c867 100644</span>
<span class="p_header">--- a/drivers/pinctrl/core.h</span>
<span class="p_header">+++ b/drivers/pinctrl/core.h</span>
<span class="p_chunk">@@ -183,7 +183,7 @@</span> <span class="p_context"> static inline struct pin_desc *pin_desc_get(struct pinctrl_dev *pctldev,</span>
 }
 
 int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,
<span class="p_del">-			 bool dup, bool locked);</span>
<span class="p_add">+			 bool dup);</span>
 void pinctrl_unregister_map(struct pinctrl_map const *map);
 
 extern int pinctrl_force_sleep(struct pinctrl_dev *pctldev);
<span class="p_header">diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c</span>
<span class="p_header">index 340fb4e6c600..fd91c4c31f6b 100644</span>
<span class="p_header">--- a/drivers/pinctrl/devicetree.c</span>
<span class="p_header">+++ b/drivers/pinctrl/devicetree.c</span>
<span class="p_chunk">@@ -92,7 +92,7 @@</span> <span class="p_context"> static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,</span>
 	dt_map-&gt;num_maps = num_maps;
 	list_add_tail(&amp;dt_map-&gt;node, &amp;p-&gt;dt_maps);
 
<span class="p_del">-	return pinctrl_register_map(map, num_maps, false, true);</span>
<span class="p_add">+	return pinctrl_register_map(map, num_maps, false);</span>
 }
 
 struct pinctrl_dev *of_pinctrl_get(struct device_node *np)
<span class="p_header">diff --git a/drivers/tty/hvc/hvc_xen.c b/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_header">index 2dc2831840ca..8eb65f26fcae 100644</span>
<span class="p_header">--- a/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_header">+++ b/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_chunk">@@ -299,11 +299,27 @@</span> <span class="p_context"> static int xen_initial_domain_console_init(void)</span>
 	return 0;
 }
 
<span class="p_add">+static void xen_console_update_evtchn(struct xencons_info *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (xen_hvm_domain()) {</span>
<span class="p_add">+		uint64_t v;</span>
<span class="p_add">+		int err;</span>
<span class="p_add">+</span>
<span class="p_add">+		err = hvm_get_parameter(HVM_PARAM_CONSOLE_EVTCHN, &amp;v);</span>
<span class="p_add">+		if (!err &amp;&amp; v)</span>
<span class="p_add">+			info-&gt;evtchn = v;</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		info-&gt;evtchn = xen_start_info-&gt;console.domU.evtchn;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void xen_console_resume(void)
 {
 	struct xencons_info *info = vtermno_to_xencons(HVC_COOKIE);
<span class="p_del">-	if (info != NULL &amp;&amp; info-&gt;irq)</span>
<span class="p_add">+	if (info != NULL &amp;&amp; info-&gt;irq) {</span>
<span class="p_add">+		if (!xen_initial_domain())</span>
<span class="p_add">+			xen_console_update_evtchn(info);</span>
 		rebind_evtchn_irq(info-&gt;evtchn, info-&gt;irq);
<span class="p_add">+	}</span>
 }
 
 static void xencons_disconnect_backend(struct xencons_info *info)
<span class="p_header">diff --git a/drivers/xen/events/events_2l.c b/drivers/xen/events/events_2l.c</span>
<span class="p_header">index d7ff91757307..843e5d8538bd 100644</span>
<span class="p_header">--- a/drivers/xen/events/events_2l.c</span>
<span class="p_header">+++ b/drivers/xen/events/events_2l.c</span>
<span class="p_chunk">@@ -352,6 +352,15 @@</span> <span class="p_context"> irqreturn_t xen_debug_interrupt(int irq, void *dev_id)</span>
 	return IRQ_HANDLED;
 }
 
<span class="p_add">+static void evtchn_2l_resume(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for_each_online_cpu(i)</span>
<span class="p_add">+		memset(per_cpu(cpu_evtchn_mask, i), 0, sizeof(xen_ulong_t) *</span>
<span class="p_add">+				EVTCHN_2L_NR_CHANNELS/BITS_PER_EVTCHN_WORD);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct evtchn_ops evtchn_ops_2l = {
 	.max_channels      = evtchn_2l_max_channels,
 	.nr_channels       = evtchn_2l_max_channels,
<span class="p_chunk">@@ -363,6 +372,7 @@</span> <span class="p_context"> static const struct evtchn_ops evtchn_ops_2l = {</span>
 	.mask              = evtchn_2l_mask,
 	.unmask            = evtchn_2l_unmask,
 	.handle_events     = evtchn_2l_handle_events,
<span class="p_add">+	.resume	           = evtchn_2l_resume,</span>
 };
 
 void __init xen_evtchn_2l_init(void)
<span class="p_header">diff --git a/drivers/xen/events/events_base.c b/drivers/xen/events/events_base.c</span>
<span class="p_header">index c8860a8757ac..a5cc476256f1 100644</span>
<span class="p_header">--- a/drivers/xen/events/events_base.c</span>
<span class="p_header">+++ b/drivers/xen/events/events_base.c</span>
<span class="p_chunk">@@ -550,8 +550,8 @@</span> <span class="p_context"> static unsigned int __startup_pirq(unsigned int irq)</span>
 	if (rc)
 		goto err;
 
<span class="p_del">-	bind_evtchn_to_cpu(evtchn, 0);</span>
 	info-&gt;evtchn = evtchn;
<span class="p_add">+	bind_evtchn_to_cpu(evtchn, 0);</span>
 
 	rc = xen_evtchn_port_setup(info);
 	if (rc)
<span class="p_chunk">@@ -1294,8 +1294,9 @@</span> <span class="p_context"> void rebind_evtchn_irq(int evtchn, int irq)</span>
 
 	mutex_unlock(&amp;irq_mapping_update_lock);
 
<span class="p_del">-	/* new event channels are always bound to cpu 0 */</span>
<span class="p_del">-	irq_set_affinity(irq, cpumask_of(0));</span>
<span class="p_add">+        bind_evtchn_to_cpu(evtchn, info-&gt;cpu);</span>
<span class="p_add">+	/* This will be deferred until interrupt is processed */</span>
<span class="p_add">+	irq_set_affinity(irq, cpumask_of(info-&gt;cpu));</span>
 
 	/* Unmask the event channel. */
 	enable_irq(irq);
<span class="p_header">diff --git a/fs/dcache.c b/fs/dcache.c</span>
<span class="p_header">index c345f5f2b508..a9231c872342 100644</span>
<span class="p_header">--- a/fs/dcache.c</span>
<span class="p_header">+++ b/fs/dcache.c</span>
<span class="p_chunk">@@ -435,7 +435,7 @@</span> <span class="p_context"> static struct dentry *d_kill(struct dentry *dentry, struct dentry *parent)</span>
 	__releases(parent-&gt;d_lock)
 	__releases(dentry-&gt;d_inode-&gt;i_lock)
 {
<span class="p_del">-	list_del(&amp;dentry-&gt;d_child);</span>
<span class="p_add">+	__list_del_entry(&amp;dentry-&gt;d_child);</span>
 	/*
 	 * Inform d_walk() that we are no longer attached to the
 	 * dentry tree
<span class="p_chunk">@@ -1123,33 +1123,31 @@</span> <span class="p_context"> resume:</span>
 	/*
 	 * All done at this level ... ascend and resume the search.
 	 */
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+ascend:</span>
 	if (this_parent != parent) {
 		struct dentry *child = this_parent;
 		this_parent = child-&gt;d_parent;
 
<span class="p_del">-		rcu_read_lock();</span>
 		spin_unlock(&amp;child-&gt;d_lock);
 		spin_lock(&amp;this_parent-&gt;d_lock);
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * might go back up the wrong parent if we have had a rename</span>
<span class="p_del">-		 * or deletion</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (this_parent != child-&gt;d_parent ||</span>
<span class="p_del">-			 (child-&gt;d_flags &amp; DCACHE_DENTRY_KILLED) ||</span>
<span class="p_del">-			 need_seqretry(&amp;rename_lock, seq)) {</span>
<span class="p_del">-			spin_unlock(&amp;this_parent-&gt;d_lock);</span>
<span class="p_del">-			rcu_read_unlock();</span>
<span class="p_add">+		/* might go back up the wrong parent if we have had a rename. */</span>
<span class="p_add">+		if (need_seqretry(&amp;rename_lock, seq))</span>
 			goto rename_retry;
<span class="p_add">+		next = child-&gt;d_child.next;</span>
<span class="p_add">+		while (unlikely(child-&gt;d_flags &amp; DCACHE_DENTRY_KILLED)) {</span>
<span class="p_add">+			if (next == &amp;this_parent-&gt;d_subdirs)</span>
<span class="p_add">+				goto ascend;</span>
<span class="p_add">+			child = list_entry(next, struct dentry, d_child);</span>
<span class="p_add">+			next = next-&gt;next;</span>
 		}
 		rcu_read_unlock();
<span class="p_del">-		next = child-&gt;d_child.next;</span>
 		goto resume;
 	}
<span class="p_del">-	if (need_seqretry(&amp;rename_lock, seq)) {</span>
<span class="p_del">-		spin_unlock(&amp;this_parent-&gt;d_lock);</span>
<span class="p_add">+	if (need_seqretry(&amp;rename_lock, seq))</span>
 		goto rename_retry;
<span class="p_del">-	}</span>
<span class="p_add">+	rcu_read_unlock();</span>
 	if (finish)
 		finish(data);
 
<span class="p_chunk">@@ -1159,6 +1157,9 @@</span> <span class="p_context"> out_unlock:</span>
 	return;
 
 rename_retry:
<span class="p_add">+	spin_unlock(&amp;this_parent-&gt;d_lock);</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+	BUG_ON(seq &amp; 1);</span>
 	if (!retry)
 		return;
 	seq = 1;
<span class="p_header">diff --git a/fs/namespace.c b/fs/namespace.c</span>
<span class="p_header">index 039f3802d70e..2faa7eacb62b 100644</span>
<span class="p_header">--- a/fs/namespace.c</span>
<span class="p_header">+++ b/fs/namespace.c</span>
<span class="p_chunk">@@ -3025,6 +3025,12 @@</span> <span class="p_context"> bool fs_fully_visible(struct file_system_type *type)</span>
 		if (mnt-&gt;mnt.mnt_sb-&gt;s_type != type)
 			continue;
 
<span class="p_add">+		/* This mount is not fully visible if it&#39;s root directory</span>
<span class="p_add">+		 * is not the root directory of the filesystem.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (mnt-&gt;mnt.mnt_root != mnt-&gt;mnt.mnt_sb-&gt;s_root)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		/* This mount is not fully visible if there are any child mounts
 		 * that cover anything except for empty directories.
 		 */
<span class="p_header">diff --git a/fs/nilfs2/btree.c b/fs/nilfs2/btree.c</span>
<span class="p_header">index ecdbae19a766..090d8ce25bd1 100644</span>
<span class="p_header">--- a/fs/nilfs2/btree.c</span>
<span class="p_header">+++ b/fs/nilfs2/btree.c</span>
<span class="p_chunk">@@ -388,7 +388,7 @@</span> <span class="p_context"> static int nilfs_btree_root_broken(const struct nilfs_btree_node *node,</span>
 	nchildren = nilfs_btree_node_get_nchildren(node);
 
 	if (unlikely(level &lt; NILFS_BTREE_LEVEL_NODE_MIN ||
<span class="p_del">-		     level &gt; NILFS_BTREE_LEVEL_MAX ||</span>
<span class="p_add">+		     level &gt;= NILFS_BTREE_LEVEL_MAX ||</span>
 		     nchildren &lt; 0 ||
 		     nchildren &gt; NILFS_BTREE_ROOT_NCHILDREN_MAX)) {
 		pr_crit(&quot;NILFS: bad btree root (inode number=%lu): level = %d, flags = 0x%x, nchildren = %d\n&quot;,
<span class="p_header">diff --git a/fs/ocfs2/dlm/dlmmaster.c b/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_header">index 1be3398c96f6..1dd0bcc75536 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_chunk">@@ -726,6 +726,19 @@</span> <span class="p_context"> lookup:</span>
 	if (tmpres) {
 		spin_unlock(&amp;dlm-&gt;spinlock);
 		spin_lock(&amp;tmpres-&gt;spinlock);
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Right after dlm spinlock was released, dlm_thread could have</span>
<span class="p_add">+		 * purged the lockres. Check if lockres got unhashed. If so</span>
<span class="p_add">+		 * start over.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (hlist_unhashed(&amp;tmpres-&gt;hash_node)) {</span>
<span class="p_add">+			spin_unlock(&amp;tmpres-&gt;spinlock);</span>
<span class="p_add">+			dlm_lockres_put(tmpres);</span>
<span class="p_add">+			tmpres = NULL;</span>
<span class="p_add">+			goto lookup;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		/* Wait on the thread that is mastering the resource */
 		if (tmpres-&gt;owner == DLM_LOCK_RES_OWNER_UNKNOWN) {
 			__dlm_wait_on_lockres(tmpres);
<span class="p_header">diff --git a/include/acpi/acpixf.h b/include/acpi/acpixf.h</span>
<span class="p_header">index fea6773f87fc..5d51f27549cc 100644</span>
<span class="p_header">--- a/include/acpi/acpixf.h</span>
<span class="p_header">+++ b/include/acpi/acpixf.h</span>
<span class="p_chunk">@@ -175,7 +175,7 @@</span> <span class="p_context"> acpi_status __init acpi_load_tables(void);</span>
  */
 acpi_status __init acpi_reallocate_root_table(void);
 
<span class="p_del">-acpi_status __init acpi_find_root_pointer(acpi_size *rsdp_address);</span>
<span class="p_add">+acpi_status __init acpi_find_root_pointer(acpi_physical_address * rsdp_address);</span>
 
 acpi_status acpi_unload_table_id(acpi_owner_id id);
 
<span class="p_header">diff --git a/include/linux/nilfs2_fs.h b/include/linux/nilfs2_fs.h</span>
<span class="p_header">index 98755767c7b0..1108acaacfc6 100644</span>
<span class="p_header">--- a/include/linux/nilfs2_fs.h</span>
<span class="p_header">+++ b/include/linux/nilfs2_fs.h</span>
<span class="p_chunk">@@ -458,7 +458,7 @@</span> <span class="p_context"> struct nilfs_btree_node {</span>
 /* level */
 #define NILFS_BTREE_LEVEL_DATA          0
 #define NILFS_BTREE_LEVEL_NODE_MIN      (NILFS_BTREE_LEVEL_DATA + 1)
<span class="p_del">-#define NILFS_BTREE_LEVEL_MAX           14</span>
<span class="p_add">+#define NILFS_BTREE_LEVEL_MAX           14	/* Max level (exclusive) */</span>
 
 /**
  * struct nilfs_palloc_group_desc - block group descriptor
<span class="p_header">diff --git a/mm/memory-failure.c b/mm/memory-failure.c</span>
<span class="p_header">index ffc7bf0458fb..9502057c3c54 100644</span>
<span class="p_header">--- a/mm/memory-failure.c</span>
<span class="p_header">+++ b/mm/memory-failure.c</span>
<span class="p_chunk">@@ -1149,10 +1149,10 @@</span> <span class="p_context"> int memory_failure(unsigned long pfn, int trapno, int flags)</span>
 	 * The check (unnecessarily) ignores LRU pages being isolated and
 	 * walked by the page reclaim code, however that&#39;s not a big loss.
 	 */
<span class="p_del">-	if (!PageHuge(p) &amp;&amp; !PageTransTail(p)) {</span>
<span class="p_del">-		if (!PageLRU(p))</span>
<span class="p_del">-			shake_page(p, 0);</span>
<span class="p_del">-		if (!PageLRU(p)) {</span>
<span class="p_add">+	if (!PageHuge(p)) {</span>
<span class="p_add">+		if (!PageLRU(hpage))</span>
<span class="p_add">+			shake_page(hpage, 0);</span>
<span class="p_add">+		if (!PageLRU(hpage)) {</span>
 			/*
 			 * shake_page could have turned it free.
 			 */
<span class="p_chunk">@@ -1723,12 +1723,12 @@</span> <span class="p_context"> int soft_offline_page(struct page *page, int flags)</span>
 	} else if (ret == 0) { /* for free pages */
 		if (PageHuge(page)) {
 			set_page_hwpoison_huge_page(hpage);
<span class="p_del">-			dequeue_hwpoisoned_huge_page(hpage);</span>
<span class="p_del">-			atomic_long_add(1 &lt;&lt; compound_order(hpage),</span>
<span class="p_add">+			if (!dequeue_hwpoisoned_huge_page(hpage))</span>
<span class="p_add">+				atomic_long_add(1 &lt;&lt; compound_order(hpage),</span>
 					&amp;num_poisoned_pages);
 		} else {
<span class="p_del">-			SetPageHWPoison(page);</span>
<span class="p_del">-			atomic_long_inc(&amp;num_poisoned_pages);</span>
<span class="p_add">+			if (!TestSetPageHWPoison(page))</span>
<span class="p_add">+				atomic_long_inc(&amp;num_poisoned_pages);</span>
 		}
 	}
 	unset_migratetype_isolate(page, MIGRATE_MOVABLE);
<span class="p_header">diff --git a/mm/page-writeback.c b/mm/page-writeback.c</span>
<span class="p_header">index 51d8d15f48d7..656a5490f693 100644</span>
<span class="p_header">--- a/mm/page-writeback.c</span>
<span class="p_header">+++ b/mm/page-writeback.c</span>
<span class="p_chunk">@@ -601,7 +601,7 @@</span> <span class="p_context"> static long long pos_ratio_polynom(unsigned long setpoint,</span>
 	long x;
 
 	x = div64_s64(((s64)setpoint - (s64)dirty) &lt;&lt; RATELIMIT_CALC_SHIFT,
<span class="p_del">-		    limit - setpoint + 1);</span>
<span class="p_add">+		      (limit - setpoint) | 1);</span>
 	pos_ratio = x;
 	pos_ratio = pos_ratio * x &gt;&gt; RATELIMIT_CALC_SHIFT;
 	pos_ratio = pos_ratio * x &gt;&gt; RATELIMIT_CALC_SHIFT;
<span class="p_chunk">@@ -828,7 +828,7 @@</span> <span class="p_context"> static unsigned long bdi_position_ratio(struct backing_dev_info *bdi,</span>
 	 * scale global setpoint to bdi&#39;s:
 	 *	bdi_setpoint = setpoint * bdi_thresh / thresh
 	 */
<span class="p_del">-	x = div_u64((u64)bdi_thresh &lt;&lt; 16, thresh + 1);</span>
<span class="p_add">+	x = div_u64((u64)bdi_thresh &lt;&lt; 16, thresh | 1);</span>
 	bdi_setpoint = setpoint * (u64)x &gt;&gt; 16;
 	/*
 	 * Use span=(8*write_bw) in single bdi case as indicated by
<span class="p_chunk">@@ -843,7 +843,7 @@</span> <span class="p_context"> static unsigned long bdi_position_ratio(struct backing_dev_info *bdi,</span>
 
 	if (bdi_dirty &lt; x_intercept - span / 4) {
 		pos_ratio = div64_u64(pos_ratio * (x_intercept - bdi_dirty),
<span class="p_del">-				    x_intercept - bdi_setpoint + 1);</span>
<span class="p_add">+				      (x_intercept - bdi_setpoint) | 1);</span>
 	} else
 		pos_ratio /= 4;
 
<span class="p_header">diff --git a/sound/oss/sequencer.c b/sound/oss/sequencer.c</span>
<span class="p_header">index 9b9f7d385134..1010ca1c9994 100644</span>
<span class="p_header">--- a/sound/oss/sequencer.c</span>
<span class="p_header">+++ b/sound/oss/sequencer.c</span>
<span class="p_chunk">@@ -683,13 +683,8 @@</span> <span class="p_context"> static int seq_timing_event(unsigned char *event_rec)</span>
 			break;
 
 		case TMR_ECHO:
<span class="p_del">-			if (seq_mode == SEQ_2)</span>
<span class="p_del">-				seq_copy_to_input(event_rec, 8);</span>
<span class="p_del">-			else</span>
<span class="p_del">-			{</span>
<span class="p_del">-				parm = (parm &lt;&lt; 8 | SEQ_ECHO);</span>
<span class="p_del">-				seq_copy_to_input((unsigned char *) &amp;parm, 4);</span>
<span class="p_del">-			}</span>
<span class="p_add">+			parm = (parm &lt;&lt; 8 | SEQ_ECHO);</span>
<span class="p_add">+			seq_copy_to_input((unsigned char *) &amp;parm, 4);</span>
 			break;
 
 		default:;
<span class="p_chunk">@@ -1330,7 +1325,6 @@</span> <span class="p_context"> int sequencer_ioctl(int dev, struct file *file, unsigned int cmd, void __user *a</span>
 	int mode = translate_mode(file);
 	struct synth_info inf;
 	struct seq_event_rec event_rec;
<span class="p_del">-	unsigned long flags;</span>
 	int __user *p = arg;
 
 	orig_dev = dev = dev &gt;&gt; 4;
<span class="p_chunk">@@ -1485,9 +1479,7 @@</span> <span class="p_context"> int sequencer_ioctl(int dev, struct file *file, unsigned int cmd, void __user *a</span>
 		case SNDCTL_SEQ_OUTOFBAND:
 			if (copy_from_user(&amp;event_rec, arg, sizeof(event_rec)))
 				return -EFAULT;
<span class="p_del">-			spin_lock_irqsave(&amp;lock,flags);</span>
 			play_event(event_rec.arr);
<span class="p_del">-			spin_unlock_irqrestore(&amp;lock,flags);</span>
 			return 0;
 
 		case SNDCTL_MIDI_INFO:
<span class="p_header">diff --git a/virt/kvm/arm/vgic.c b/virt/kvm/arm/vgic.c</span>
<span class="p_header">index 26954a7d9b03..4eec2d436109 100644</span>
<span class="p_header">--- a/virt/kvm/arm/vgic.c</span>
<span class="p_header">+++ b/virt/kvm/arm/vgic.c</span>
<span class="p_chunk">@@ -548,11 +548,10 @@</span> <span class="p_context"> static bool handle_mmio_cfg_reg(struct kvm_vcpu *vcpu,</span>
 	u32 val;
 	u32 *reg;
 
<span class="p_del">-	offset &gt;&gt;= 1;</span>
 	reg = vgic_bitmap_get_reg(&amp;vcpu-&gt;kvm-&gt;arch.vgic.irq_cfg,
<span class="p_del">-				  vcpu-&gt;vcpu_id, offset);</span>
<span class="p_add">+				  vcpu-&gt;vcpu_id, offset &gt;&gt; 1);</span>
 
<span class="p_del">-	if (offset &amp; 2)</span>
<span class="p_add">+	if (offset &amp; 4)</span>
 		val = *reg &gt;&gt; 16;
 	else
 		val = *reg &amp; 0xffff;
<span class="p_chunk">@@ -561,13 +560,13 @@</span> <span class="p_context"> static bool handle_mmio_cfg_reg(struct kvm_vcpu *vcpu,</span>
 	vgic_reg_access(mmio, &amp;val, offset,
 			ACCESS_READ_VALUE | ACCESS_WRITE_VALUE);
 	if (mmio-&gt;is_write) {
<span class="p_del">-		if (offset &lt; 4) {</span>
<span class="p_add">+		if (offset &lt; 8) {</span>
 			*reg = ~0U; /* Force PPIs/SGIs to 1 */
 			return false;
 		}
 
 		val = vgic_cfg_compress(val);
<span class="p_del">-		if (offset &amp; 2) {</span>
<span class="p_add">+		if (offset &amp; 4) {</span>
 			*reg &amp;= 0xffff;
 			*reg |= val &lt;&lt; 16;
 		} else {
<span class="p_chunk">@@ -1527,17 +1526,33 @@</span> <span class="p_context"> int kvm_vgic_hyp_init(void)</span>
 		goto out_unmap;
 	}
 
<span class="p_del">-	kvm_info(&quot;%s@%llx IRQ%d\n&quot;, vgic_node-&gt;name,</span>
<span class="p_del">-		 vctrl_res.start, vgic_maint_irq);</span>
<span class="p_del">-	on_each_cpu(vgic_init_maintenance_interrupt, NULL, 1);</span>
<span class="p_del">-</span>
 	if (of_address_to_resource(vgic_node, 3, &amp;vcpu_res)) {
 		kvm_err(&quot;Cannot obtain VCPU resource\n&quot;);
 		ret = -ENXIO;
 		goto out_unmap;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (!PAGE_ALIGNED(vcpu_res.start)) {</span>
<span class="p_add">+		kvm_err(&quot;GICV physical address 0x%llx not page aligned\n&quot;,</span>
<span class="p_add">+			(unsigned long long)vcpu_res.start);</span>
<span class="p_add">+		ret = -ENXIO;</span>
<span class="p_add">+		goto out_unmap;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!PAGE_ALIGNED(resource_size(&amp;vcpu_res))) {</span>
<span class="p_add">+		kvm_err(&quot;GICV size 0x%llx not a multiple of page size 0x%lx\n&quot;,</span>
<span class="p_add">+			(unsigned long long)resource_size(&amp;vcpu_res),</span>
<span class="p_add">+			PAGE_SIZE);</span>
<span class="p_add">+		ret = -ENXIO;</span>
<span class="p_add">+		goto out_unmap;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	vgic_vcpu_base = vcpu_res.start;
 
<span class="p_add">+	kvm_info(&quot;%s@%llx IRQ%d\n&quot;, vgic_node-&gt;name,</span>
<span class="p_add">+		 vctrl_res.start, vgic_maint_irq);</span>
<span class="p_add">+	on_each_cpu(vgic_init_maintenance_interrupt, NULL, 1);</span>
<span class="p_add">+</span>
 	goto out;
 
 out_unmap:
<span class="p_chunk">@@ -1668,10 +1683,11 @@</span> <span class="p_context"> static int vgic_ioaddr_assign(struct kvm *kvm, phys_addr_t *ioaddr,</span>
 	if (addr + size &lt; addr)
 		return -EINVAL;
 
<span class="p_add">+	*ioaddr = addr;</span>
 	ret = vgic_ioaddr_overlap(kvm);
 	if (ret)
<span class="p_del">-		return ret;</span>
<span class="p_del">-	*ioaddr = addr;</span>
<span class="p_add">+		*ioaddr = VGIC_ADDR_UNDEF;</span>
<span class="p_add">+</span>
 	return ret;
 }
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



