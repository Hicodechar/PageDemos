
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[4.2.y-ckt,stable] Linux 4.2.8-ckt3 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [4.2.y-ckt,stable] Linux 4.2.8-ckt3</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=7718">Kamal Mostafa</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Feb. 1, 2016, 6:28 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1454351328-23497-2-git-send-email-kamal@canonical.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8182771/mbox/"
   >mbox</a>
|
   <a href="/patch/8182771/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8182771/">/patch/8182771/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id C29449FC36
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  1 Feb 2016 18:30:40 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id CCC85203AC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  1 Feb 2016 18:30:24 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 9B8E5202BE
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  1 Feb 2016 18:30:08 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753513AbcBASaB (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 1 Feb 2016 13:30:01 -0500
Received: from youngberry.canonical.com ([91.189.89.112]:57224 &quot;EHLO
	youngberry.canonical.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752231AbcBAS25 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 1 Feb 2016 13:28:57 -0500
Received: from 1.general.kamal.us.vpn ([10.172.68.52] helo=fourier)
	by youngberry.canonical.com with esmtpsa
	(TLS1.0:DHE_RSA_AES_128_CBC_SHA1:16) (Exim 4.76)
	(envelope-from &lt;kamal@canonical.com&gt;)
	id 1aQJDZ-0007i0-S0; Mon, 01 Feb 2016 18:28:54 +0000
Received: from kamal by fourier with local (Exim 4.82)
	(envelope-from &lt;kamal@whence.com&gt;)
	id 1aQJDX-00067c-4Q; Mon, 01 Feb 2016 10:28:51 -0800
From: Kamal Mostafa &lt;kamal@canonical.com&gt;
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org,
	kernel-team@lists.ubuntu.com
Cc: lwn@lwn.net
Subject: Re: [4.2.y-ckt stable] Linux 4.2.8-ckt3
Date: Mon,  1 Feb 2016 10:28:48 -0800
Message-Id: &lt;1454351328-23497-2-git-send-email-kamal@canonical.com&gt;
X-Mailer: git-send-email 1.9.1
In-Reply-To: &lt;1454351328-23497-1-git-send-email-kamal@canonical.com&gt;
References: &lt;1454351328-23497-1-git-send-email-kamal@canonical.com&gt;
X-Extended-Stable: 4.2
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.4 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7718">Kamal Mostafa</a> - Feb. 1, 2016, 6:28 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/MAINTAINERS b/MAINTAINERS</span>
<span class="p_header">index 5ac682d..66a6649 100644</span>
<span class="p_header">--- a/MAINTAINERS</span>
<span class="p_header">+++ b/MAINTAINERS</span>
<span class="p_chunk">@@ -2331,7 +2331,7 @@</span> <span class="p_context"> N:	bcm113*</span>
 
 BROADCOM BRCMSTB GPIO DRIVER
 M:	Gregory Fong &lt;gregory.0xf0@gmail.com&gt;
<span class="p_del">-L:	bcm-kernel-feedback-list@broadcom.com&gt;</span>
<span class="p_add">+L:	bcm-kernel-feedback-list@broadcom.com</span>
 S:	Supported
 F:	drivers/gpio/gpio-brcmstb.c
 F:	Documentation/devicetree/bindings/gpio/brcm,brcmstb-gpio.txt
<span class="p_chunk">@@ -9837,9 +9837,11 @@</span> <span class="p_context"> S:	Maintained</span>
 F:	drivers/net/ethernet/dlink/sundance.c
 
 SUPERH
<span class="p_add">+M:	Yoshinori Sato &lt;ysato@users.sourceforge.jp&gt;</span>
<span class="p_add">+M:	Rich Felker &lt;dalias@libc.org&gt;</span>
 L:	linux-sh@vger.kernel.org
 Q:	http://patchwork.kernel.org/project/linux-sh/list/
<span class="p_del">-S:	Orphan</span>
<span class="p_add">+S:	Maintained</span>
 F:	Documentation/sh/
 F:	arch/sh/
 F:	drivers/sh/
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 16da77c..36edbc4 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 2
 SUBLEVEL = 8
<span class="p_del">-EXTRAVERSION = -ckt2</span>
<span class="p_add">+EXTRAVERSION = -ckt3</span>
 NAME = Hare&#39;s hurried rump
 
 # *DOCUMENTATION*
<span class="p_header">diff --git a/arch/arm/Kconfig.debug b/arch/arm/Kconfig.debug</span>
<span class="p_header">index a2e16f9..55ef850 100644</span>
<span class="p_header">--- a/arch/arm/Kconfig.debug</span>
<span class="p_header">+++ b/arch/arm/Kconfig.debug</span>
<span class="p_chunk">@@ -162,10 +162,9 @@</span> <span class="p_context"> choice</span>
 		  mobile SoCs in the Kona family of chips (e.g. bcm28155,
 		  bcm11351, etc...)
 
<span class="p_del">-	config DEBUG_BCM63XX</span>
<span class="p_add">+	config DEBUG_BCM63XX_UART</span>
 		bool &quot;Kernel low-level debugging on BCM63XX UART&quot;
 		depends on ARCH_BCM_63XX
<span class="p_del">-		select DEBUG_UART_BCM63XX</span>
 
 	config DEBUG_BERLIN_UART
 		bool &quot;Marvell Berlin SoC Debug UART&quot;
<span class="p_chunk">@@ -1343,7 +1342,7 @@</span> <span class="p_context"> config DEBUG_LL_INCLUDE</span>
 	default &quot;debug/vf.S&quot; if DEBUG_VF_UART
 	default &quot;debug/vt8500.S&quot; if DEBUG_VT8500_UART0
 	default &quot;debug/zynq.S&quot; if DEBUG_ZYNQ_UART0 || DEBUG_ZYNQ_UART1
<span class="p_del">-	default &quot;debug/bcm63xx.S&quot; if DEBUG_UART_BCM63XX</span>
<span class="p_add">+	default &quot;debug/bcm63xx.S&quot; if DEBUG_BCM63XX_UART</span>
 	default &quot;debug/digicolor.S&quot; if DEBUG_DIGICOLOR_UA0
 	default &quot;mach/debug-macro.S&quot;
 
<span class="p_chunk">@@ -1359,10 +1358,6 @@</span> <span class="p_context"> config DEBUG_UART_8250</span>
 		ARCH_IOP33X || ARCH_IXP4XX || \
 		ARCH_LPC32XX || ARCH_MV78XX0 || ARCH_ORION5X || ARCH_RPC
 
<span class="p_del">-# Compatibility options for BCM63xx</span>
<span class="p_del">-config DEBUG_UART_BCM63XX</span>
<span class="p_del">-	def_bool ARCH_BCM_63XX</span>
<span class="p_del">-</span>
 config DEBUG_UART_PHYS
 	hex &quot;Physical base address of debug UART&quot;
 	default 0x00100a00 if DEBUG_NETX_UART
<span class="p_chunk">@@ -1457,7 +1452,7 @@</span> <span class="p_context"> config DEBUG_UART_PHYS</span>
 	default 0xfffb0000 if DEBUG_OMAP1UART1 || DEBUG_OMAP7XXUART1
 	default 0xfffb0800 if DEBUG_OMAP1UART2 || DEBUG_OMAP7XXUART2
 	default 0xfffb9800 if DEBUG_OMAP1UART3 || DEBUG_OMAP7XXUART3
<span class="p_del">-	default 0xfffe8600 if DEBUG_UART_BCM63XX</span>
<span class="p_add">+	default 0xfffe8600 if DEBUG_BCM63XX_UART</span>
 	default 0xfffff700 if ARCH_IOP33X
 	depends on ARCH_EP93XX || \
 	        DEBUG_LL_UART_8250 || DEBUG_LL_UART_PL01X || \
<span class="p_chunk">@@ -1469,7 +1464,7 @@</span> <span class="p_context"> config DEBUG_UART_PHYS</span>
 		DEBUG_RCAR_GEN2_SCIF0 || DEBUG_RCAR_GEN2_SCIF2 || \
 		DEBUG_RMOBILE_SCIFA0 || DEBUG_RMOBILE_SCIFA1 || \
 		DEBUG_RMOBILE_SCIFA4 || DEBUG_S3C24XX_UART || \
<span class="p_del">-		DEBUG_UART_BCM63XX || DEBUG_ASM9260_UART || \</span>
<span class="p_add">+		DEBUG_BCM63XX_UART || DEBUG_ASM9260_UART || \</span>
 		DEBUG_SIRFSOC_UART || DEBUG_DIGICOLOR_UA0
 
 config DEBUG_UART_VIRT
<span class="p_chunk">@@ -1509,7 +1504,7 @@</span> <span class="p_context"> config DEBUG_UART_VIRT</span>
 	default 0xfb10c000 if DEBUG_REALVIEW_PB1176_PORT
 	default 0xfc40ab00 if DEBUG_BRCMSTB_UART
 	default 0xfc705000 if DEBUG_ZTE_ZX
<span class="p_del">-	default 0xfcfe8600 if DEBUG_UART_BCM63XX</span>
<span class="p_add">+	default 0xfcfe8600 if DEBUG_BCM63XX_UART</span>
 	default 0xfd000000 if ARCH_SPEAR3XX || ARCH_SPEAR6XX
 	default 0xfd000000 if ARCH_SPEAR13XX
 	default 0xfd012000 if ARCH_MV78XX0
<span class="p_chunk">@@ -1560,7 +1555,7 @@</span> <span class="p_context"> config DEBUG_UART_VIRT</span>
 		DEBUG_UART_8250 || DEBUG_UART_PL01X || DEBUG_MESON_UARTAO || \
 		DEBUG_NETX_UART || \
 		DEBUG_QCOM_UARTDM || DEBUG_S3C24XX_UART || \
<span class="p_del">-		DEBUG_UART_BCM63XX || DEBUG_ASM9260_UART || \</span>
<span class="p_add">+		DEBUG_BCM63XX_UART || DEBUG_ASM9260_UART || \</span>
 		DEBUG_SIRFSOC_UART || DEBUG_DIGICOLOR_UA0
 
 config DEBUG_UART_8250_SHIFT
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-388-gp.dts b/arch/arm/boot/dts/armada-388-gp.dts</span>
<span class="p_header">index fd4f6fd..c79ca20 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-388-gp.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-388-gp.dts</span>
<span class="p_chunk">@@ -288,16 +288,6 @@</span> <span class="p_context"></span>
 		gpio = &lt;&amp;expander0 4 GPIO_ACTIVE_HIGH&gt;;
 	};
 
<span class="p_del">-	reg_usb2_1_vbus: v5-vbus1 {</span>
<span class="p_del">-		compatible = &quot;regulator-fixed&quot;;</span>
<span class="p_del">-		regulator-name = &quot;v5.0-vbus1&quot;;</span>
<span class="p_del">-		regulator-min-microvolt = &lt;5000000&gt;;</span>
<span class="p_del">-		regulator-max-microvolt = &lt;5000000&gt;;</span>
<span class="p_del">-		enable-active-high;</span>
<span class="p_del">-		regulator-always-on;</span>
<span class="p_del">-		gpio = &lt;&amp;expander0 4 GPIO_ACTIVE_HIGH&gt;;</span>
<span class="p_del">-	};</span>
<span class="p_del">-</span>
 	reg_sata0: pwr-sata0 {
 		compatible = &quot;regulator-fixed&quot;;
 		regulator-name = &quot;pwr_en_sata0&quot;;
<span class="p_header">diff --git a/arch/arm/boot/dts/r8a7740-armadillo800eva.dts b/arch/arm/boot/dts/r8a7740-armadillo800eva.dts</span>
<span class="p_header">index 2e31d8c..8595b0d 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/r8a7740-armadillo800eva.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/r8a7740-armadillo800eva.dts</span>
<span class="p_chunk">@@ -180,7 +180,7 @@</span> <span class="p_context"></span>
 };
 
 &amp;extal1_clk {
<span class="p_del">-	clock-frequency = &lt;25000000&gt;;</span>
<span class="p_add">+	clock-frequency = &lt;24000000&gt;;</span>
 };
 &amp;extal2_clk {
 	clock-frequency = &lt;48000000&gt;;
<span class="p_header">diff --git a/arch/arm/mach-imx/Kconfig b/arch/arm/mach-imx/Kconfig</span>
<span class="p_header">index 573536f..27d084b 100644</span>
<span class="p_header">--- a/arch/arm/mach-imx/Kconfig</span>
<span class="p_header">+++ b/arch/arm/mach-imx/Kconfig</span>
<span class="p_chunk">@@ -554,6 +554,7 @@</span> <span class="p_context"> config SOC_IMX7D</span>
 	select ARM_GIC
 	select HAVE_IMX_ANATOP
 	select HAVE_IMX_MMDC
<span class="p_add">+	select HAVE_IMX_SRC</span>
 	help
 		This enables support for Freescale i.MX7 Dual processor.
 
<span class="p_header">diff --git a/arch/arm64/kernel/perf_event.c b/arch/arm64/kernel/perf_event.c</span>
<span class="p_header">index b31e9a4..b6c1301 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/perf_event.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/perf_event.c</span>
<span class="p_chunk">@@ -1242,9 +1242,6 @@</span> <span class="p_context"> static void armv8pmu_reset(void *info)</span>
 
 	/* Initialize &amp; Reset PMNC: C and P bits. */
 	armv8pmu_pmcr_write(ARMV8_PMCR_P | ARMV8_PMCR_C);
<span class="p_del">-</span>
<span class="p_del">-	/* Disable access from userspace. */</span>
<span class="p_del">-	asm volatile(&quot;msr pmuserenr_el0, %0&quot; :: &quot;r&quot; (0));</span>
 }
 
 static int armv8_pmuv3_map_event(struct perf_event *event)
<span class="p_header">diff --git a/arch/arm64/kernel/ptrace.c b/arch/arm64/kernel/ptrace.c</span>
<span class="p_header">index d882b83..608ac6a 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/ptrace.c</span>
<span class="p_chunk">@@ -58,6 +58,12 @@</span> <span class="p_context"></span>
  */
 void ptrace_disable(struct task_struct *child)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This would be better off in core code, but PTRACE_DETACH has</span>
<span class="p_add">+	 * grown its fair share of arch-specific worts and changing it</span>
<span class="p_add">+	 * is likely to cause regressions on obscure architectures.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	user_disable_single_step(child);</span>
 }
 
 #ifdef CONFIG_HAVE_HW_BREAKPOINT
<span class="p_header">diff --git a/arch/arm64/mm/mmu.c b/arch/arm64/mm/mmu.c</span>
<span class="p_header">index 6a0dc30..3d016b9 100644</span>
<span class="p_header">--- a/arch/arm64/mm/mmu.c</span>
<span class="p_header">+++ b/arch/arm64/mm/mmu.c</span>
<span class="p_chunk">@@ -451,6 +451,9 @@</span> <span class="p_context"> void __init paging_init(void)</span>
 
 	empty_zero_page = virt_to_page(zero_page);
 
<span class="p_add">+	/* Ensure the zero page is visible to the page table walker */</span>
<span class="p_add">+	dsb(ishst);</span>
<span class="p_add">+</span>
 	/*
 	 * TTBR0 is only used for the identity mapping at this stage. Make it
 	 * point to zero page to avoid speculatively fetching new entries.
<span class="p_header">diff --git a/arch/arm64/mm/proc.S b/arch/arm64/mm/proc.S</span>
<span class="p_header">index 39139a3..4730e39 100644</span>
<span class="p_header">--- a/arch/arm64/mm/proc.S</span>
<span class="p_header">+++ b/arch/arm64/mm/proc.S</span>
<span class="p_chunk">@@ -119,6 +119,7 @@</span> <span class="p_context"> ENTRY(cpu_do_resume)</span>
 	 */
 	ubfx	x11, x11, #1, #1
 	msr	oslar_el1, x11
<span class="p_add">+	msr	pmuserenr_el0, xzr		// Disable PMU access from EL0</span>
 	mov	x0, x12
 	dsb	nsh		// Make sure local tlb invalidation completed
 	isb
<span class="p_chunk">@@ -156,7 +157,9 @@</span> <span class="p_context"> ENTRY(__cpu_setup)</span>
 
 	mov	x0, #3 &lt;&lt; 20
 	msr	cpacr_el1, x0			// Enable FP/ASIMD
<span class="p_del">-	msr	mdscr_el1, xzr			// Reset mdscr_el1</span>
<span class="p_add">+	mov	x0, #1 &lt;&lt; 12			// Reset mdscr_el1 and disable</span>
<span class="p_add">+	msr	mdscr_el1, x0			// access to the DCC from EL0</span>
<span class="p_add">+	msr	pmuserenr_el0, xzr		// Disable PMU access from EL0</span>
 	/*
 	 * Memory region attributes for LPAE:
 	 *
<span class="p_header">diff --git a/arch/m32r/kernel/setup.c b/arch/m32r/kernel/setup.c</span>
<span class="p_header">index 0392112..a5ecef7 100644</span>
<span class="p_header">--- a/arch/m32r/kernel/setup.c</span>
<span class="p_header">+++ b/arch/m32r/kernel/setup.c</span>
<span class="p_chunk">@@ -81,7 +81,10 @@</span> <span class="p_context"> static struct resource code_resource = {</span>
 };
 
 unsigned long memory_start;
<span class="p_add">+EXPORT_SYMBOL(memory_start);</span>
<span class="p_add">+</span>
 unsigned long memory_end;
<span class="p_add">+EXPORT_SYMBOL(memory_end);</span>
 
 void __init setup_arch(char **);
 int get_cpuinfo(char *);
<span class="p_header">diff --git a/arch/m68k/atari/config.c b/arch/m68k/atari/config.c</span>
<span class="p_header">index 192b00f..cbd5991 100644</span>
<span class="p_header">--- a/arch/m68k/atari/config.c</span>
<span class="p_header">+++ b/arch/m68k/atari/config.c</span>
<span class="p_chunk">@@ -858,7 +858,7 @@</span> <span class="p_context"> static struct platform_device *atari_netusbee_devices[] __initdata = {</span>
 };
 #endif /* CONFIG_ATARI_ETHERNEC */
 
<span class="p_del">-#ifdef CONFIG_ATARI_SCSI</span>
<span class="p_add">+#if IS_ENABLED(CONFIG_ATARI_SCSI)</span>
 static const struct resource atari_scsi_st_rsrc[] __initconst = {
 	{
 		.flags = IORESOURCE_IRQ,
<span class="p_chunk">@@ -910,7 +910,7 @@</span> <span class="p_context"> int __init atari_platform_init(void)</span>
 	}
 #endif
 
<span class="p_del">-#ifdef CONFIG_ATARI_SCSI</span>
<span class="p_add">+#if IS_ENABLED(CONFIG_ATARI_SCSI)</span>
 	if (ATARIHW_PRESENT(ST_SCSI))
 		platform_device_register_simple(&quot;atari_scsi&quot;, -1,
 			atari_scsi_st_rsrc, ARRAY_SIZE(atari_scsi_st_rsrc));
<span class="p_header">diff --git a/arch/m68k/sun3/config.c b/arch/m68k/sun3/config.c</span>
<span class="p_header">index a8b942b..3f06a5d 100644</span>
<span class="p_header">--- a/arch/m68k/sun3/config.c</span>
<span class="p_header">+++ b/arch/m68k/sun3/config.c</span>
<span class="p_chunk">@@ -171,7 +171,7 @@</span> <span class="p_context"> static void __init sun3_sched_init(irq_handler_t timer_routine)</span>
         intersil_clear();
 }
 
<span class="p_del">-#ifdef CONFIG_SUN3_SCSI</span>
<span class="p_add">+#if IS_ENABLED(CONFIG_SUN3_SCSI)</span>
 
 static const struct resource sun3_scsi_vme_rsrc[] __initconst = {
 	{
<span class="p_header">diff --git a/arch/mips/include/asm/pgtable.h b/arch/mips/include/asm/pgtable.h</span>
<span class="p_header">index ae85694..6bc427f 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -353,7 +353,7 @@</span> <span class="p_context"> static inline pte_t pte_mkdirty(pte_t pte)</span>
 static inline pte_t pte_mkyoung(pte_t pte)
 {
 	pte_val(pte) |= _PAGE_ACCESSED;
<span class="p_del">-#ifdef CONFIG_CPU_MIPSR2</span>
<span class="p_add">+#if defined(CONFIG_CPU_MIPSR2) || defined(CONFIG_CPU_MIPSR6)</span>
 	if (!(pte_val(pte) &amp; _PAGE_NO_READ))
 		pte_val(pte) |= _PAGE_SILENT_READ;
 	else
<span class="p_chunk">@@ -558,7 +558,7 @@</span> <span class="p_context"> static inline pmd_t pmd_mkyoung(pmd_t pmd)</span>
 {
 	pmd_val(pmd) |= _PAGE_ACCESSED;
 
<span class="p_del">-#ifdef CONFIG_CPU_MIPSR2</span>
<span class="p_add">+#if defined(CONFIG_CPU_MIPSR2) || defined(CONFIG_CPU_MIPSR6)</span>
 	if (!(pmd_val(pmd) &amp; _PAGE_NO_READ))
 		pmd_val(pmd) |= _PAGE_SILENT_READ;
 	else
<span class="p_header">diff --git a/arch/mips/loongson64/loongson-3/hpet.c b/arch/mips/loongson64/loongson-3/hpet.c</span>
<span class="p_header">index 5c21cd3..b2888d5 100644</span>
<span class="p_header">--- a/arch/mips/loongson64/loongson-3/hpet.c</span>
<span class="p_header">+++ b/arch/mips/loongson64/loongson-3/hpet.c</span>
<span class="p_chunk">@@ -13,6 +13,9 @@</span> <span class="p_context"></span>
 #define SMBUS_PCI_REG64		0x64
 #define SMBUS_PCI_REGB4		0xb4
 
<span class="p_add">+#define HPET_MIN_CYCLES		64</span>
<span class="p_add">+#define HPET_MIN_PROG_DELTA	(HPET_MIN_CYCLES + (HPET_MIN_CYCLES &gt;&gt; 1))</span>
<span class="p_add">+</span>
 static DEFINE_SPINLOCK(hpet_lock);
 DEFINE_PER_CPU(struct clock_event_device, hpet_clockevent_device);
 
<span class="p_chunk">@@ -139,8 +142,9 @@</span> <span class="p_context"> static int hpet_next_event(unsigned long delta,</span>
 	cnt += delta;
 	hpet_write(HPET_T0_CMP, cnt);
 
<span class="p_del">-	res = ((int)(hpet_read(HPET_COUNTER) - cnt) &gt; 0) ? -ETIME : 0;</span>
<span class="p_del">-	return res;</span>
<span class="p_add">+	res = (int)(cnt - hpet_read(HPET_COUNTER));</span>
<span class="p_add">+</span>
<span class="p_add">+	return res &lt; HPET_MIN_CYCLES ? -ETIME : 0;</span>
 }
 
 static irqreturn_t hpet_irq_handler(int irq, void *data)
<span class="p_chunk">@@ -212,7 +216,7 @@</span> <span class="p_context"> void __init setup_hpet_timer(void)</span>
 	cd-&gt;cpumask = cpumask_of(cpu);
 	clockevent_set_clock(cd, HPET_FREQ);
 	cd-&gt;max_delta_ns = clockevent_delta2ns(0x7fffffff, cd);
<span class="p_del">-	cd-&gt;min_delta_ns = 5000;</span>
<span class="p_add">+	cd-&gt;min_delta_ns = clockevent_delta2ns(HPET_MIN_PROG_DELTA, cd);</span>
 
 	clockevents_register_device(cd);
 	setup_irq(HPET_T0_IRQ, &amp;hpet_irq);
<span class="p_header">diff --git a/arch/mips/loongson64/loongson-3/smp.c b/arch/mips/loongson64/loongson-3/smp.c</span>
<span class="p_header">index 1a4738a..509832a9 100644</span>
<span class="p_header">--- a/arch/mips/loongson64/loongson-3/smp.c</span>
<span class="p_header">+++ b/arch/mips/loongson64/loongson-3/smp.c</span>
<span class="p_chunk">@@ -30,13 +30,13 @@</span> <span class="p_context"></span>
 #include &quot;smp.h&quot;
 
 DEFINE_PER_CPU(int, cpu_state);
<span class="p_del">-DEFINE_PER_CPU(uint32_t, core0_c0count);</span>
 
 static void *ipi_set0_regs[16];
 static void *ipi_clear0_regs[16];
 static void *ipi_status0_regs[16];
 static void *ipi_en0_regs[16];
 static void *ipi_mailbox_buf[16];
<span class="p_add">+static uint32_t core0_c0count[NR_CPUS];</span>
 
 /* read a 32bit value from ipi register */
 #define loongson3_ipi_read32(addr) readl(addr)
<span class="p_chunk">@@ -275,12 +275,14 @@</span> <span class="p_context"> void loongson3_ipi_interrupt(struct pt_regs *regs)</span>
 	if (action &amp; SMP_ASK_C0COUNT) {
 		BUG_ON(cpu != 0);
 		c0count = read_c0_count();
<span class="p_del">-		for (i = 1; i &lt; num_possible_cpus(); i++)</span>
<span class="p_del">-			per_cpu(core0_c0count, i) = c0count;</span>
<span class="p_add">+		c0count = c0count ? c0count : 1;</span>
<span class="p_add">+		for (i = 1; i &lt; nr_cpu_ids; i++)</span>
<span class="p_add">+			core0_c0count[i] = c0count;</span>
<span class="p_add">+		__wbflush(); /* Let others see the result ASAP */</span>
 	}
 }
 
<span class="p_del">-#define MAX_LOOPS 1111</span>
<span class="p_add">+#define MAX_LOOPS 800</span>
 /*
  * SMP init and finish on secondary CPUs
  */
<span class="p_chunk">@@ -305,16 +307,20 @@</span> <span class="p_context"> static void loongson3_init_secondary(void)</span>
 		cpu_logical_map(cpu) / loongson_sysconf.cores_per_package;
 
 	i = 0;
<span class="p_del">-	__this_cpu_write(core0_c0count, 0);</span>
<span class="p_add">+	core0_c0count[cpu] = 0;</span>
 	loongson3_send_ipi_single(0, SMP_ASK_C0COUNT);
<span class="p_del">-	while (!__this_cpu_read(core0_c0count)) {</span>
<span class="p_add">+	while (!core0_c0count[cpu]) {</span>
 		i++;
 		cpu_relax();
 	}
 
 	if (i &gt; MAX_LOOPS)
 		i = MAX_LOOPS;
<span class="p_del">-	initcount = __this_cpu_read(core0_c0count) + i;</span>
<span class="p_add">+	if (cpu_data[cpu].package)</span>
<span class="p_add">+		initcount = core0_c0count[cpu] + i;</span>
<span class="p_add">+	else /* Local access is faster for loops */</span>
<span class="p_add">+		initcount = core0_c0count[cpu] + i/2;</span>
<span class="p_add">+</span>
 	write_c0_count(initcount);
 }
 
<span class="p_header">diff --git a/arch/mips/mm/tlbex.c b/arch/mips/mm/tlbex.c</span>
<span class="p_header">index 323d1d3..99e3bd3 100644</span>
<span class="p_header">--- a/arch/mips/mm/tlbex.c</span>
<span class="p_header">+++ b/arch/mips/mm/tlbex.c</span>
<span class="p_chunk">@@ -242,7 +242,7 @@</span> <span class="p_context"> static void output_pgtable_bits_defines(void)</span>
 	pr_define(&quot;_PAGE_HUGE_SHIFT %d\n&quot;, _PAGE_HUGE_SHIFT);
 	pr_define(&quot;_PAGE_SPLITTING_SHIFT %d\n&quot;, _PAGE_SPLITTING_SHIFT);
 #endif
<span class="p_del">-#ifdef CONFIG_CPU_MIPSR2</span>
<span class="p_add">+#if defined(CONFIG_CPU_MIPSR2) || defined(CONFIG_CPU_MIPSR6)</span>
 	if (cpu_has_rixi) {
 #ifdef _PAGE_NO_EXEC_SHIFT
 		pr_define(&quot;_PAGE_NO_EXEC_SHIFT %d\n&quot;, _PAGE_NO_EXEC_SHIFT);
<span class="p_header">diff --git a/arch/parisc/include/uapi/asm/siginfo.h b/arch/parisc/include/uapi/asm/siginfo.h</span>
<span class="p_header">index d703472..1c75565 100644</span>
<span class="p_header">--- a/arch/parisc/include/uapi/asm/siginfo.h</span>
<span class="p_header">+++ b/arch/parisc/include/uapi/asm/siginfo.h</span>
<span class="p_chunk">@@ -1,6 +1,10 @@</span> <span class="p_context"></span>
 #ifndef _PARISC_SIGINFO_H
 #define _PARISC_SIGINFO_H
 
<span class="p_add">+#if defined(__LP64__)</span>
<span class="p_add">+#define __ARCH_SI_PREAMBLE_SIZE   (4 * sizeof(int))</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #include &lt;asm-generic/siginfo.h&gt;
 
 #undef NSIGTRAP
<span class="p_header">diff --git a/arch/powerpc/include/asm/cmpxchg.h b/arch/powerpc/include/asm/cmpxchg.h</span>
<span class="p_header">index ad6263c..d1a8d93 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/cmpxchg.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/cmpxchg.h</span>
<span class="p_chunk">@@ -18,12 +18,12 @@</span> <span class="p_context"> __xchg_u32(volatile void *p, unsigned long val)</span>
 	unsigned long prev;
 
 	__asm__ __volatile__(
<span class="p_del">-	PPC_RELEASE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_ENTRY_BARRIER</span>
 &quot;1:	lwarx	%0,0,%2 \n&quot;
 	PPC405_ERR77(0,%2)
 &quot;	stwcx.	%3,0,%2 \n\
 	bne-	1b&quot;
<span class="p_del">-	PPC_ACQUIRE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_EXIT_BARRIER</span>
 	: &quot;=&amp;r&quot; (prev), &quot;+m&quot; (*(volatile unsigned int *)p)
 	: &quot;r&quot; (p), &quot;r&quot; (val)
 	: &quot;cc&quot;, &quot;memory&quot;);
<span class="p_chunk">@@ -61,12 +61,12 @@</span> <span class="p_context"> __xchg_u64(volatile void *p, unsigned long val)</span>
 	unsigned long prev;
 
 	__asm__ __volatile__(
<span class="p_del">-	PPC_RELEASE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_ENTRY_BARRIER</span>
 &quot;1:	ldarx	%0,0,%2 \n&quot;
 	PPC405_ERR77(0,%2)
 &quot;	stdcx.	%3,0,%2 \n\
 	bne-	1b&quot;
<span class="p_del">-	PPC_ACQUIRE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_EXIT_BARRIER</span>
 	: &quot;=&amp;r&quot; (prev), &quot;+m&quot; (*(volatile unsigned long *)p)
 	: &quot;r&quot; (p), &quot;r&quot; (val)
 	: &quot;cc&quot;, &quot;memory&quot;);
<span class="p_chunk">@@ -151,14 +151,14 @@</span> <span class="p_context"> __cmpxchg_u32(volatile unsigned int *p, unsigned long old, unsigned long new)</span>
 	unsigned int prev;
 
 	__asm__ __volatile__ (
<span class="p_del">-	PPC_RELEASE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_ENTRY_BARRIER</span>
 &quot;1:	lwarx	%0,0,%2		# __cmpxchg_u32\n\
 	cmpw	0,%0,%3\n\
 	bne-	2f\n&quot;
 	PPC405_ERR77(0,%2)
 &quot;	stwcx.	%4,0,%2\n\
 	bne-	1b&quot;
<span class="p_del">-	PPC_ACQUIRE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_EXIT_BARRIER</span>
 	&quot;\n\
 2:&quot;
 	: &quot;=&amp;r&quot; (prev), &quot;+m&quot; (*p)
<span class="p_chunk">@@ -197,13 +197,13 @@</span> <span class="p_context"> __cmpxchg_u64(volatile unsigned long *p, unsigned long old, unsigned long new)</span>
 	unsigned long prev;
 
 	__asm__ __volatile__ (
<span class="p_del">-	PPC_RELEASE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_ENTRY_BARRIER</span>
 &quot;1:	ldarx	%0,0,%2		# __cmpxchg_u64\n\
 	cmpd	0,%0,%3\n\
 	bne-	2f\n\
 	stdcx.	%4,0,%2\n\
 	bne-	1b&quot;
<span class="p_del">-	PPC_ACQUIRE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_EXIT_BARRIER</span>
 	&quot;\n\
 2:&quot;
 	: &quot;=&amp;r&quot; (prev), &quot;+m&quot; (*p)
<span class="p_header">diff --git a/arch/powerpc/include/asm/synch.h b/arch/powerpc/include/asm/synch.h</span>
<span class="p_header">index e682a71..c508686 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/synch.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/synch.h</span>
<span class="p_chunk">@@ -44,7 +44,7 @@</span> <span class="p_context"> static inline void isync(void)</span>
 	MAKE_LWSYNC_SECTION_ENTRY(97, __lwsync_fixup);
 #define PPC_ACQUIRE_BARRIER	 &quot;\n&quot; stringify_in_c(__PPC_ACQUIRE_BARRIER)
 #define PPC_RELEASE_BARRIER	 stringify_in_c(LWSYNC) &quot;\n&quot;
<span class="p_del">-#define PPC_ATOMIC_ENTRY_BARRIER &quot;\n&quot; stringify_in_c(LWSYNC) &quot;\n&quot;</span>
<span class="p_add">+#define PPC_ATOMIC_ENTRY_BARRIER &quot;\n&quot; stringify_in_c(sync) &quot;\n&quot;</span>
 #define PPC_ATOMIC_EXIT_BARRIER	 &quot;\n&quot; stringify_in_c(sync) &quot;\n&quot;
 #else
 #define PPC_ACQUIRE_BARRIER
<span class="p_header">diff --git a/arch/powerpc/include/uapi/asm/elf.h b/arch/powerpc/include/uapi/asm/elf.h</span>
<span class="p_header">index 59dad11..c2d21d1 100644</span>
<span class="p_header">--- a/arch/powerpc/include/uapi/asm/elf.h</span>
<span class="p_header">+++ b/arch/powerpc/include/uapi/asm/elf.h</span>
<span class="p_chunk">@@ -295,6 +295,8 @@</span> <span class="p_context"> do {									\</span>
 #define R_PPC64_TLSLD		108
 #define R_PPC64_TOCSAVE		109
 
<span class="p_add">+#define R_PPC64_ENTRY		118</span>
<span class="p_add">+</span>
 #define R_PPC64_REL16		249
 #define R_PPC64_REL16_LO	250
 #define R_PPC64_REL16_HI	251
<span class="p_header">diff --git a/arch/powerpc/kernel/module_64.c b/arch/powerpc/kernel/module_64.c</span>
<span class="p_header">index 6838451..59663af 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/module_64.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/module_64.c</span>
<span class="p_chunk">@@ -635,6 +635,33 @@</span> <span class="p_context"> int apply_relocate_add(Elf64_Shdr *sechdrs,</span>
 			 */
 			break;
 
<span class="p_add">+		case R_PPC64_ENTRY:</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Optimize ELFv2 large code model entry point if</span>
<span class="p_add">+			 * the TOC is within 2GB range of current location.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			value = my_r2(sechdrs, me) - (unsigned long)location;</span>
<span class="p_add">+			if (value + 0x80008000 &gt; 0xffffffff)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Check for the large code model prolog sequence:</span>
<span class="p_add">+		         *	ld r2, ...(r12)</span>
<span class="p_add">+			 *	add r2, r2, r12</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if ((((uint32_t *)location)[0] &amp; ~0xfffc)</span>
<span class="p_add">+			    != 0xe84c0000)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			if (((uint32_t *)location)[1] != 0x7c426214)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * If found, replace it with:</span>
<span class="p_add">+			 *	addis r2, r12, (.TOC.-func)@ha</span>
<span class="p_add">+			 *	addi r2, r12, (.TOC.-func)@l</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			((uint32_t *)location)[0] = 0x3c4c0000 + PPC_HA(value);</span>
<span class="p_add">+			((uint32_t *)location)[1] = 0x38420000 + PPC_LO(value);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
 		case R_PPC64_REL16_HA:
 			/* Subtract location pointer */
 			value -= (unsigned long)location;
<span class="p_header">diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c</span>
<span class="p_header">index efc3fa5..42e02a2 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/pci_of_scan.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/pci_of_scan.c</span>
<span class="p_chunk">@@ -191,9 +191,6 @@</span> <span class="p_context"> struct pci_dev *of_create_pci_dev(struct device_node *node,</span>
 
 	pci_device_add(dev, bus);
 
<span class="p_del">-	/* Setup MSI caps &amp; disable MSI/MSI-X interrupts */</span>
<span class="p_del">-	pci_msi_setup_pci_dev(dev);</span>
<span class="p_del">-</span>
 	return dev;
 }
 EXPORT_SYMBOL(of_create_pci_dev);
<span class="p_header">diff --git a/arch/s390/mm/extable.c b/arch/s390/mm/extable.c</span>
<span class="p_header">index 4d1ee88..18c8b81 100644</span>
<span class="p_header">--- a/arch/s390/mm/extable.c</span>
<span class="p_header">+++ b/arch/s390/mm/extable.c</span>
<span class="p_chunk">@@ -52,12 +52,16 @@</span> <span class="p_context"> void sort_extable(struct exception_table_entry *start,</span>
 	int i;
 
 	/* Normalize entries to being relative to the start of the section */
<span class="p_del">-	for (p = start, i = 0; p &lt; finish; p++, i += 8)</span>
<span class="p_add">+	for (p = start, i = 0; p &lt; finish; p++, i += 8) {</span>
 		p-&gt;insn += i;
<span class="p_add">+		p-&gt;fixup += i + 4;</span>
<span class="p_add">+	}</span>
 	sort(start, finish - start, sizeof(*start), cmp_ex, NULL);
 	/* Denormalize all entries */
<span class="p_del">-	for (p = start, i = 0; p &lt; finish; p++, i += 8)</span>
<span class="p_add">+	for (p = start, i = 0; p &lt; finish; p++, i += 8) {</span>
 		p-&gt;insn -= i;
<span class="p_add">+		p-&gt;fixup -= i + 4;</span>
<span class="p_add">+	}</span>
 }
 
 #ifdef CONFIG_MODULES
<span class="p_header">diff --git a/arch/sparc/kernel/sys_sparc_64.c b/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_header">index 30e7ddb..c690c8e 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_chunk">@@ -413,7 +413,7 @@</span> <span class="p_context"> out:</span>
 
 SYSCALL_DEFINE1(sparc64_personality, unsigned long, personality)
 {
<span class="p_del">-	int ret;</span>
<span class="p_add">+	long ret;</span>
 
 	if (personality(current-&gt;personality) == PER_LINUX32 &amp;&amp;
 	    personality(personality) == PER_LINUX)
<span class="p_header">diff --git a/arch/um/os-Linux/start_up.c b/arch/um/os-Linux/start_up.c</span>
<span class="p_header">index 47f1ff0..22a358e 100644</span>
<span class="p_header">--- a/arch/um/os-Linux/start_up.c</span>
<span class="p_header">+++ b/arch/um/os-Linux/start_up.c</span>
<span class="p_chunk">@@ -94,6 +94,8 @@</span> <span class="p_context"> static int start_ptraced_child(void)</span>
 {
 	int pid, n, status;
 
<span class="p_add">+	fflush(stdout);</span>
<span class="p_add">+</span>
 	pid = fork();
 	if (pid == 0)
 		ptrace_child();
<span class="p_header">diff --git a/arch/x86/include/asm/boot.h b/arch/x86/include/asm/boot.h</span>
<span class="p_header">index 4fa687a..6b8d6e8 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/boot.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/boot.h</span>
<span class="p_chunk">@@ -27,7 +27,7 @@</span> <span class="p_context"></span>
 #define BOOT_HEAP_SIZE             0x400000
 #else /* !CONFIG_KERNEL_BZIP2 */
 
<span class="p_del">-#define BOOT_HEAP_SIZE	0x8000</span>
<span class="p_add">+#define BOOT_HEAP_SIZE	0x10000</span>
 
 #endif /* !CONFIG_KERNEL_BZIP2 */
 
<span class="p_header">diff --git a/arch/x86/include/asm/mmu_context.h b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">index 984abfe..a009082 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -104,8 +104,36 @@</span> <span class="p_context"> static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
 #endif
 		cpumask_set_cpu(cpu, mm_cpumask(next));
 
<span class="p_del">-		/* Re-load page tables */</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Re-load page tables.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * This logic has an ordering constraint:</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 *  CPU 0: Write to a PTE for &#39;next&#39;</span>
<span class="p_add">+		 *  CPU 0: load bit 1 in mm_cpumask.  if nonzero, send IPI.</span>
<span class="p_add">+		 *  CPU 1: set bit 1 in next&#39;s mm_cpumask</span>
<span class="p_add">+		 *  CPU 1: load from the PTE that CPU 0 writes (implicit)</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * We need to prevent an outcome in which CPU 1 observes</span>
<span class="p_add">+		 * the new PTE value and CPU 0 observes bit 1 clear in</span>
<span class="p_add">+		 * mm_cpumask.  (If that occurs, then the IPI will never</span>
<span class="p_add">+		 * be sent, and CPU 0&#39;s TLB will contain a stale entry.)</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * The bad outcome can occur if either CPU&#39;s load is</span>
<span class="p_add">+		 * reordered before that CPU&#39;s store, so both CPUs must</span>
<span class="p_add">+		 * execute full barriers to prevent this from happening.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Thus, switch_mm needs a full barrier between the</span>
<span class="p_add">+		 * store to mm_cpumask and any operation that could load</span>
<span class="p_add">+		 * from next-&gt;pgd.  TLB fills are special and can happen</span>
<span class="p_add">+		 * due to instruction fetches or for no reason at all,</span>
<span class="p_add">+		 * and neither LOCK nor MFENCE orders them.</span>
<span class="p_add">+		 * Fortunately, load_cr3() is serializing and gives the</span>
<span class="p_add">+		 * ordering guarantee we need.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 */</span>
 		load_cr3(next-&gt;pgd);
<span class="p_add">+</span>
 		trace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);
 
 		/* Stop flush ipis for the previous mm */
<span class="p_chunk">@@ -142,10 +170,14 @@</span> <span class="p_context"> static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
 			 * schedule, protecting us from simultaneous changes.
 			 */
 			cpumask_set_cpu(cpu, mm_cpumask(next));
<span class="p_add">+</span>
 			/*
 			 * We were in lazy tlb mode and leave_mm disabled
 			 * tlb flush IPI delivery. We must reload CR3
 			 * to make sure to use no freed page tables.
<span class="p_add">+			 *</span>
<span class="p_add">+			 * As above, load_cr3() is serializing and orders TLB</span>
<span class="p_add">+			 * fills with respect to the mm_cpumask write.</span>
 			 */
 			load_cr3(next-&gt;pgd);
 			trace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event.c b/arch/x86/kernel/cpu/perf_event.c</span>
<span class="p_header">index 9469dfa..a27d738 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event.c</span>
<span class="p_chunk">@@ -1531,6 +1531,7 @@</span> <span class="p_context"> static void __init filter_events(struct attribute **attrs)</span>
 {
 	struct device_attribute *d;
 	struct perf_pmu_events_attr *pmu_attr;
<span class="p_add">+	int offset = 0;</span>
 	int i, j;
 
 	for (i = 0; attrs[i]; i++) {
<span class="p_chunk">@@ -1539,7 +1540,7 @@</span> <span class="p_context"> static void __init filter_events(struct attribute **attrs)</span>
 		/* str trumps id */
 		if (pmu_attr-&gt;event_str)
 			continue;
<span class="p_del">-		if (x86_pmu.event_map(i))</span>
<span class="p_add">+		if (x86_pmu.event_map(i + offset))</span>
 			continue;
 
 		for (j = i; attrs[j]; j++)
<span class="p_chunk">@@ -1547,6 +1548,14 @@</span> <span class="p_context"> static void __init filter_events(struct attribute **attrs)</span>
 
 		/* Check the shifted attr. */
 		i--;
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * event_map() is index based, the attrs array is organized</span>
<span class="p_add">+		 * by increasing event index. If we shift the events, then</span>
<span class="p_add">+		 * we need to compensate for the event_map(), otherwise</span>
<span class="p_add">+		 * we are looking up the wrong event in the map</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		offset++;</span>
 	}
 }
 
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event_intel_ds.c b/arch/x86/kernel/cpu/perf_event_intel_ds.c</span>
<span class="p_header">index 71fc402..dbe8d89 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event_intel_ds.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event_intel_ds.c</span>
<span class="p_chunk">@@ -1027,6 +1027,13 @@</span> <span class="p_context"> get_next_pebs_record_by_bit(void *base, void *top, int bit)</span>
 	void *at;
 	u64 pebs_status;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * fmt0 does not have a status bitfield (does not use</span>
<span class="p_add">+	 * perf_record_nhm format)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (x86_pmu.intel_cap.pebs_format &lt; 1)</span>
<span class="p_add">+		return base;</span>
<span class="p_add">+</span>
 	if (base == NULL)
 		return NULL;
 
<span class="p_chunk">@@ -1112,7 +1119,7 @@</span> <span class="p_context"> static void intel_pmu_drain_pebs_core(struct pt_regs *iregs)</span>
 	if (!event-&gt;attr.precise_ip)
 		return;
 
<span class="p_del">-	n = (top - at) / x86_pmu.pebs_record_size;</span>
<span class="p_add">+	n = top - at;</span>
 	if (n &lt;= 0)
 		return;
 
<span class="p_header">diff --git a/arch/x86/kernel/process_64.c b/arch/x86/kernel/process_64.c</span>
<span class="p_header">index a90ac95..adff851 100644</span>
<span class="p_header">--- a/arch/x86/kernel/process_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/process_64.c</span>
<span class="p_chunk">@@ -124,7 +124,7 @@</span> <span class="p_context"> void release_thread(struct task_struct *dead_task)</span>
 		if (dead_task-&gt;mm-&gt;context.ldt) {
 			pr_warn(&quot;WARNING: dead process %s still has LDT? &lt;%p/%d&gt;\n&quot;,
 				dead_task-&gt;comm,
<span class="p_del">-				dead_task-&gt;mm-&gt;context.ldt,</span>
<span class="p_add">+				dead_task-&gt;mm-&gt;context.ldt-&gt;entries,</span>
 				dead_task-&gt;mm-&gt;context.ldt-&gt;size);
 			BUG();
 		}
<span class="p_header">diff --git a/arch/x86/kernel/reboot.c b/arch/x86/kernel/reboot.c</span>
<span class="p_header">index 86db4bc..0549ae3 100644</span>
<span class="p_header">--- a/arch/x86/kernel/reboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/reboot.c</span>
<span class="p_chunk">@@ -182,6 +182,14 @@</span> <span class="p_context"> static struct dmi_system_id __initdata reboot_dmi_table[] = {</span>
 			DMI_MATCH(DMI_PRODUCT_NAME, &quot;iMac9,1&quot;),
 		},
 	},
<span class="p_add">+	{	/* Handle problems with rebooting on the iMac10,1. */</span>
<span class="p_add">+		.callback = set_pci_reboot,</span>
<span class="p_add">+		.ident = &quot;Apple iMac10,1&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+		    DMI_MATCH(DMI_SYS_VENDOR, &quot;Apple Inc.&quot;),</span>
<span class="p_add">+		    DMI_MATCH(DMI_PRODUCT_NAME, &quot;iMac10,1&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 
 	/* ASRock */
 	{	/* Handle problems with rebooting on ASRock Q1900DC-ITX */
<span class="p_header">diff --git a/arch/x86/kvm/trace.h b/arch/x86/kvm/trace.h</span>
<span class="p_header">index 4eae7c3..08b668c 100644</span>
<span class="p_header">--- a/arch/x86/kvm/trace.h</span>
<span class="p_header">+++ b/arch/x86/kvm/trace.h</span>
<span class="p_chunk">@@ -250,7 +250,7 @@</span> <span class="p_context"> TRACE_EVENT(kvm_inj_virq,</span>
 #define kvm_trace_sym_exc						\
 	EXS(DE), EXS(DB), EXS(BP), EXS(OF), EXS(BR), EXS(UD), EXS(NM),	\
 	EXS(DF), EXS(TS), EXS(NP), EXS(SS), EXS(GP), EXS(PF),		\
<span class="p_del">-	EXS(MF), EXS(MC)</span>
<span class="p_add">+	EXS(MF), EXS(AC), EXS(MC)</span>
 
 /*
  * Tracepoint for kvm interrupt injection:
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index d022b73..35b6bd2 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -941,7 +941,7 @@</span> <span class="p_context"> static u32 msrs_to_save[] = {</span>
 	MSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,
 #endif
 	MSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,
<span class="p_del">-	MSR_IA32_FEATURE_CONTROL, MSR_IA32_BNDCFGS</span>
<span class="p_add">+	MSR_IA32_FEATURE_CONTROL, MSR_IA32_BNDCFGS, MSR_TSC_AUX,</span>
 };
 
 static unsigned num_msrs_to_save;
<span class="p_chunk">@@ -4053,16 +4053,17 @@</span> <span class="p_context"> static void kvm_init_msr_list(void)</span>
 
 		/*
 		 * Even MSRs that are valid in the host may not be exposed
<span class="p_del">-		 * to the guests in some cases.  We could work around this</span>
<span class="p_del">-		 * in VMX with the generic MSR save/load machinery, but it</span>
<span class="p_del">-		 * is not really worthwhile since it will really only</span>
<span class="p_del">-		 * happen with nested virtualization.</span>
<span class="p_add">+		 * to the guests in some cases.</span>
 		 */
 		switch (msrs_to_save[i]) {
 		case MSR_IA32_BNDCFGS:
 			if (!kvm_x86_ops-&gt;mpx_supported())
 				continue;
 			break;
<span class="p_add">+		case MSR_TSC_AUX:</span>
<span class="p_add">+			if (!kvm_x86_ops-&gt;rdtscp_supported())</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			break;</span>
 		default:
 			break;
 		}
<span class="p_header">diff --git a/arch/x86/mm/tlb.c b/arch/x86/mm/tlb.c</span>
<span class="p_header">index 90b924a..061e011 100644</span>
<span class="p_header">--- a/arch/x86/mm/tlb.c</span>
<span class="p_header">+++ b/arch/x86/mm/tlb.c</span>
<span class="p_chunk">@@ -160,7 +160,10 @@</span> <span class="p_context"> void flush_tlb_current_task(void)</span>
 	preempt_disable();
 
 	count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);
<span class="p_add">+</span>
<span class="p_add">+	/* This is an implicit full barrier that synchronizes with switch_mm. */</span>
 	local_flush_tlb();
<span class="p_add">+</span>
 	trace_tlb_flush(TLB_LOCAL_SHOOTDOWN, TLB_FLUSH_ALL);
 	if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) &lt; nr_cpu_ids)
 		flush_tlb_others(mm_cpumask(mm), mm, 0UL, TLB_FLUSH_ALL);
<span class="p_chunk">@@ -187,17 +190,29 @@</span> <span class="p_context"> void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,</span>
 	unsigned long base_pages_to_flush = TLB_FLUSH_ALL;
 
 	preempt_disable();
<span class="p_del">-	if (current-&gt;active_mm != mm)</span>
<span class="p_add">+	if (current-&gt;active_mm != mm) {</span>
<span class="p_add">+		/* Synchronize with switch_mm. */</span>
<span class="p_add">+		smp_mb();</span>
<span class="p_add">+</span>
 		goto out;
<span class="p_add">+	}</span>
 
 	if (!current-&gt;mm) {
 		leave_mm(smp_processor_id());
<span class="p_add">+</span>
<span class="p_add">+		/* Synchronize with switch_mm. */</span>
<span class="p_add">+		smp_mb();</span>
<span class="p_add">+</span>
 		goto out;
 	}
 
 	if ((end != TLB_FLUSH_ALL) &amp;&amp; !(vmflag &amp; VM_HUGETLB))
 		base_pages_to_flush = (end - start) &gt;&gt; PAGE_SHIFT;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Both branches below are implicit full barriers (MOV to CR or</span>
<span class="p_add">+	 * INVLPG) that synchronize with switch_mm.</span>
<span class="p_add">+	 */</span>
 	if (base_pages_to_flush &gt; tlb_single_page_flush_ceiling) {
 		base_pages_to_flush = TLB_FLUSH_ALL;
 		count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);
<span class="p_chunk">@@ -227,10 +242,18 @@</span> <span class="p_context"> void flush_tlb_page(struct vm_area_struct *vma, unsigned long start)</span>
 	preempt_disable();
 
 	if (current-&gt;active_mm == mm) {
<span class="p_del">-		if (current-&gt;mm)</span>
<span class="p_add">+		if (current-&gt;mm) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Implicit full barrier (INVLPG) that synchronizes</span>
<span class="p_add">+			 * with switch_mm.</span>
<span class="p_add">+			 */</span>
 			__flush_tlb_one(start);
<span class="p_del">-		else</span>
<span class="p_add">+		} else {</span>
 			leave_mm(smp_processor_id());
<span class="p_add">+</span>
<span class="p_add">+			/* Synchronize with switch_mm. */</span>
<span class="p_add">+			smp_mb();</span>
<span class="p_add">+		}</span>
 	}
 
 	if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) &lt; nr_cpu_ids)
<span class="p_header">diff --git a/arch/x86/um/Makefile b/arch/x86/um/Makefile</span>
<span class="p_header">index a8fecc2..3ee2bb6 100644</span>
<span class="p_header">--- a/arch/x86/um/Makefile</span>
<span class="p_header">+++ b/arch/x86/um/Makefile</span>
<span class="p_chunk">@@ -17,7 +17,7 @@</span> <span class="p_context"> obj-y = bug.o bugs_$(BITS).o delay.o fault.o ksyms.o ldt.o \</span>
 ifeq ($(CONFIG_X86_32),y)
 
 obj-y += checksum_32.o
<span class="p_del">-obj-$(CONFIG_BINFMT_ELF) += elfcore.o</span>
<span class="p_add">+obj-$(CONFIG_ELF_CORE) += elfcore.o</span>
 
 subarch-y = ../lib/string_32.o ../lib/atomic64_32.o ../lib/atomic64_cx8_32.o
 subarch-$(CONFIG_RWSEM_XCHGADD_ALGORITHM) += ../lib/rwsem.o
<span class="p_header">diff --git a/arch/x86/xen/suspend.c b/arch/x86/xen/suspend.c</span>
<span class="p_header">index 53b4c08..6d34151 100644</span>
<span class="p_header">--- a/arch/x86/xen/suspend.c</span>
<span class="p_header">+++ b/arch/x86/xen/suspend.c</span>
<span class="p_chunk">@@ -32,7 +32,8 @@</span> <span class="p_context"> static void xen_hvm_post_suspend(int suspend_cancelled)</span>
 {
 #ifdef CONFIG_XEN_PVHVM
 	int cpu;
<span class="p_del">-	xen_hvm_init_shared_info();</span>
<span class="p_add">+	if (!suspend_cancelled)</span>
<span class="p_add">+	    xen_hvm_init_shared_info();</span>
 	xen_callback_vector();
 	xen_unplug_emulated_devices();
 	if (xen_feature(XENFEAT_hvm_safe_pvclock)) {
<span class="p_header">diff --git a/crypto/af_alg.c b/crypto/af_alg.c</span>
<span class="p_header">index a8e7aa3..f5e18c2 100644</span>
<span class="p_header">--- a/crypto/af_alg.c</span>
<span class="p_header">+++ b/crypto/af_alg.c</span>
<span class="p_chunk">@@ -76,6 +76,8 @@</span> <span class="p_context"> int af_alg_register_type(const struct af_alg_type *type)</span>
 		goto unlock;
 
 	type-&gt;ops-&gt;owner = THIS_MODULE;
<span class="p_add">+	if (type-&gt;ops_nokey)</span>
<span class="p_add">+		type-&gt;ops_nokey-&gt;owner = THIS_MODULE;</span>
 	node-&gt;type = type;
 	list_add(&amp;node-&gt;list, &amp;alg_types);
 	err = 0;
<span class="p_chunk">@@ -125,6 +127,26 @@</span> <span class="p_context"> int af_alg_release(struct socket *sock)</span>
 }
 EXPORT_SYMBOL_GPL(af_alg_release);
 
<span class="p_add">+void af_alg_release_parent(struct sock *sk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct alg_sock *ask = alg_sk(sk);</span>
<span class="p_add">+	unsigned int nokey = ask-&gt;nokey_refcnt;</span>
<span class="p_add">+	bool last = nokey &amp;&amp; !ask-&gt;refcnt;</span>
<span class="p_add">+</span>
<span class="p_add">+	sk = ask-&gt;parent;</span>
<span class="p_add">+	ask = alg_sk(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+	ask-&gt;nokey_refcnt -= nokey;</span>
<span class="p_add">+	if (!last)</span>
<span class="p_add">+		last = !--ask-&gt;refcnt;</span>
<span class="p_add">+	release_sock(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (last)</span>
<span class="p_add">+		sock_put(sk);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(af_alg_release_parent);</span>
<span class="p_add">+</span>
 static int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
 {
 	const u32 forbidden = CRYPTO_ALG_INTERNAL;
<span class="p_chunk">@@ -133,6 +155,7 @@</span> <span class="p_context"> static int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)</span>
 	struct sockaddr_alg *sa = (void *)uaddr;
 	const struct af_alg_type *type;
 	void *private;
<span class="p_add">+	int err;</span>
 
 	if (sock-&gt;state == SS_CONNECTED)
 		return -EINVAL;
<span class="p_chunk">@@ -160,16 +183,22 @@</span> <span class="p_context"> static int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)</span>
 		return PTR_ERR(private);
 	}
 
<span class="p_add">+	err = -EBUSY;</span>
 	lock_sock(sk);
<span class="p_add">+	if (ask-&gt;refcnt | ask-&gt;nokey_refcnt)</span>
<span class="p_add">+		goto unlock;</span>
 
 	swap(ask-&gt;type, type);
 	swap(ask-&gt;private, private);
 
<span class="p_add">+	err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+unlock:</span>
 	release_sock(sk);
 
 	alg_do_release(type, private);
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return err;</span>
 }
 
 static int alg_setkey(struct sock *sk, char __user *ukey,
<span class="p_chunk">@@ -202,11 +231,15 @@</span> <span class="p_context"> static int alg_setsockopt(struct socket *sock, int level, int optname,</span>
 	struct sock *sk = sock-&gt;sk;
 	struct alg_sock *ask = alg_sk(sk);
 	const struct af_alg_type *type;
<span class="p_del">-	int err = -ENOPROTOOPT;</span>
<span class="p_add">+	int err = -EBUSY;</span>
 
 	lock_sock(sk);
<span class="p_add">+	if (ask-&gt;refcnt)</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+</span>
 	type = ask-&gt;type;
 
<span class="p_add">+	err = -ENOPROTOOPT;</span>
 	if (level != SOL_ALG || !type)
 		goto unlock;
 
<span class="p_chunk">@@ -238,6 +271,7 @@</span> <span class="p_context"> int af_alg_accept(struct sock *sk, struct socket *newsock)</span>
 	struct alg_sock *ask = alg_sk(sk);
 	const struct af_alg_type *type;
 	struct sock *sk2;
<span class="p_add">+	unsigned int nokey;</span>
 	int err;
 
 	lock_sock(sk);
<span class="p_chunk">@@ -257,20 +291,29 @@</span> <span class="p_context"> int af_alg_accept(struct sock *sk, struct socket *newsock)</span>
 	security_sk_clone(sk, sk2);
 
 	err = type-&gt;accept(ask-&gt;private, sk2);
<span class="p_del">-	if (err) {</span>
<span class="p_del">-		sk_free(sk2);</span>
<span class="p_add">+</span>
<span class="p_add">+	nokey = err == -ENOKEY;</span>
<span class="p_add">+	if (nokey &amp;&amp; type-&gt;accept_nokey)</span>
<span class="p_add">+		err = type-&gt;accept_nokey(ask-&gt;private, sk2);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (err)</span>
 		goto unlock;
<span class="p_del">-	}</span>
 
 	sk2-&gt;sk_family = PF_ALG;
 
<span class="p_del">-	sock_hold(sk);</span>
<span class="p_add">+	if (nokey || !ask-&gt;refcnt++)</span>
<span class="p_add">+		sock_hold(sk);</span>
<span class="p_add">+	ask-&gt;nokey_refcnt += nokey;</span>
 	alg_sk(sk2)-&gt;parent = sk;
 	alg_sk(sk2)-&gt;type = type;
<span class="p_add">+	alg_sk(sk2)-&gt;nokey_refcnt = nokey;</span>
 
 	newsock-&gt;ops = type-&gt;ops;
 	newsock-&gt;state = SS_CONNECTED;
 
<span class="p_add">+	if (nokey)</span>
<span class="p_add">+		newsock-&gt;ops = type-&gt;ops_nokey;</span>
<span class="p_add">+</span>
 	err = 0;
 
 unlock:
<span class="p_header">diff --git a/crypto/ahash.c b/crypto/ahash.c</span>
<span class="p_header">index 9c1dc8d..d19b523 100644</span>
<span class="p_header">--- a/crypto/ahash.c</span>
<span class="p_header">+++ b/crypto/ahash.c</span>
<span class="p_chunk">@@ -451,6 +451,7 @@</span> <span class="p_context"> static int crypto_ahash_init_tfm(struct crypto_tfm *tfm)</span>
 	struct ahash_alg *alg = crypto_ahash_alg(hash);
 
 	hash-&gt;setkey = ahash_nosetkey;
<span class="p_add">+	hash-&gt;has_setkey = false;</span>
 	hash-&gt;export = ahash_no_export;
 	hash-&gt;import = ahash_no_import;
 
<span class="p_chunk">@@ -463,8 +464,10 @@</span> <span class="p_context"> static int crypto_ahash_init_tfm(struct crypto_tfm *tfm)</span>
 	hash-&gt;finup = alg-&gt;finup ?: ahash_def_finup;
 	hash-&gt;digest = alg-&gt;digest;
 
<span class="p_del">-	if (alg-&gt;setkey)</span>
<span class="p_add">+	if (alg-&gt;setkey) {</span>
 		hash-&gt;setkey = alg-&gt;setkey;
<span class="p_add">+		hash-&gt;has_setkey = true;</span>
<span class="p_add">+	}</span>
 	if (alg-&gt;export)
 		hash-&gt;export = alg-&gt;export;
 	if (alg-&gt;import)
<span class="p_header">diff --git a/crypto/algif_hash.c b/crypto/algif_hash.c</span>
<span class="p_header">index b4c24fe..608a756 100644</span>
<span class="p_header">--- a/crypto/algif_hash.c</span>
<span class="p_header">+++ b/crypto/algif_hash.c</span>
<span class="p_chunk">@@ -34,6 +34,11 @@</span> <span class="p_context"> struct hash_ctx {</span>
 	struct ahash_request req;
 };
 
<span class="p_add">+struct algif_hash_tfm {</span>
<span class="p_add">+	struct crypto_ahash *hash;</span>
<span class="p_add">+	bool has_key;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int hash_sendmsg(struct socket *sock, struct msghdr *msg,
 			size_t ignored)
 {
<span class="p_chunk">@@ -235,19 +240,151 @@</span> <span class="p_context"> static struct proto_ops algif_hash_ops = {</span>
 	.accept		=	hash_accept,
 };
 
<span class="p_add">+static int hash_check_key(struct socket *sock)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err = 0;</span>
<span class="p_add">+	struct sock *psk;</span>
<span class="p_add">+	struct alg_sock *pask;</span>
<span class="p_add">+	struct algif_hash_tfm *tfm;</span>
<span class="p_add">+	struct sock *sk = sock-&gt;sk;</span>
<span class="p_add">+	struct alg_sock *ask = alg_sk(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+	if (ask-&gt;refcnt)</span>
<span class="p_add">+		goto unlock_child;</span>
<span class="p_add">+</span>
<span class="p_add">+	psk = ask-&gt;parent;</span>
<span class="p_add">+	pask = alg_sk(ask-&gt;parent);</span>
<span class="p_add">+	tfm = pask-&gt;private;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = -ENOKEY;</span>
<span class="p_add">+	lock_sock_nested(psk, SINGLE_DEPTH_NESTING);</span>
<span class="p_add">+	if (!tfm-&gt;has_key)</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pask-&gt;refcnt++)</span>
<span class="p_add">+		sock_hold(psk);</span>
<span class="p_add">+</span>
<span class="p_add">+	ask-&gt;refcnt = 1;</span>
<span class="p_add">+	sock_put(psk);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+unlock:</span>
<span class="p_add">+	release_sock(psk);</span>
<span class="p_add">+unlock_child:</span>
<span class="p_add">+	release_sock(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hash_sendmsg_nokey(struct socket *sock, struct msghdr *msg,</span>
<span class="p_add">+			      size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = hash_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hash_sendmsg(sock, msg, size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static ssize_t hash_sendpage_nokey(struct socket *sock, struct page *page,</span>
<span class="p_add">+				   int offset, size_t size, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = hash_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hash_sendpage(sock, page, offset, size, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hash_recvmsg_nokey(struct socket *sock, struct msghdr *msg,</span>
<span class="p_add">+			      size_t ignored, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = hash_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hash_recvmsg(sock, msg, ignored, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hash_accept_nokey(struct socket *sock, struct socket *newsock,</span>
<span class="p_add">+			     int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = hash_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hash_accept(sock, newsock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct proto_ops algif_hash_ops_nokey = {</span>
<span class="p_add">+	.family		=	PF_ALG,</span>
<span class="p_add">+</span>
<span class="p_add">+	.connect	=	sock_no_connect,</span>
<span class="p_add">+	.socketpair	=	sock_no_socketpair,</span>
<span class="p_add">+	.getname	=	sock_no_getname,</span>
<span class="p_add">+	.ioctl		=	sock_no_ioctl,</span>
<span class="p_add">+	.listen		=	sock_no_listen,</span>
<span class="p_add">+	.shutdown	=	sock_no_shutdown,</span>
<span class="p_add">+	.getsockopt	=	sock_no_getsockopt,</span>
<span class="p_add">+	.mmap		=	sock_no_mmap,</span>
<span class="p_add">+	.bind		=	sock_no_bind,</span>
<span class="p_add">+	.setsockopt	=	sock_no_setsockopt,</span>
<span class="p_add">+	.poll		=	sock_no_poll,</span>
<span class="p_add">+</span>
<span class="p_add">+	.release	=	af_alg_release,</span>
<span class="p_add">+	.sendmsg	=	hash_sendmsg_nokey,</span>
<span class="p_add">+	.sendpage	=	hash_sendpage_nokey,</span>
<span class="p_add">+	.recvmsg	=	hash_recvmsg_nokey,</span>
<span class="p_add">+	.accept		=	hash_accept_nokey,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static void *hash_bind(const char *name, u32 type, u32 mask)
 {
<span class="p_del">-	return crypto_alloc_ahash(name, type, mask);</span>
<span class="p_add">+	struct algif_hash_tfm *tfm;</span>
<span class="p_add">+	struct crypto_ahash *hash;</span>
<span class="p_add">+</span>
<span class="p_add">+	tfm = kzalloc(sizeof(*tfm), GFP_KERNEL);</span>
<span class="p_add">+	if (!tfm)</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+</span>
<span class="p_add">+	hash = crypto_alloc_ahash(name, type, mask);</span>
<span class="p_add">+	if (IS_ERR(hash)) {</span>
<span class="p_add">+		kfree(tfm);</span>
<span class="p_add">+		return ERR_CAST(hash);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	tfm-&gt;hash = hash;</span>
<span class="p_add">+</span>
<span class="p_add">+	return tfm;</span>
 }
 
 static void hash_release(void *private)
 {
<span class="p_del">-	crypto_free_ahash(private);</span>
<span class="p_add">+	struct algif_hash_tfm *tfm = private;</span>
<span class="p_add">+</span>
<span class="p_add">+	crypto_free_ahash(tfm-&gt;hash);</span>
<span class="p_add">+	kfree(tfm);</span>
 }
 
 static int hash_setkey(void *private, const u8 *key, unsigned int keylen)
 {
<span class="p_del">-	return crypto_ahash_setkey(private, key, keylen);</span>
<span class="p_add">+	struct algif_hash_tfm *tfm = private;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = crypto_ahash_setkey(tfm-&gt;hash, key, keylen);</span>
<span class="p_add">+	tfm-&gt;has_key = !err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
 }
 
 static void hash_sock_destruct(struct sock *sk)
<span class="p_chunk">@@ -261,12 +398,14 @@</span> <span class="p_context"> static void hash_sock_destruct(struct sock *sk)</span>
 	af_alg_release_parent(sk);
 }
 
<span class="p_del">-static int hash_accept_parent(void *private, struct sock *sk)</span>
<span class="p_add">+static int hash_accept_parent_nokey(void *private, struct sock *sk)</span>
 {
 	struct hash_ctx *ctx;
 	struct alg_sock *ask = alg_sk(sk);
<span class="p_del">-	unsigned len = sizeof(*ctx) + crypto_ahash_reqsize(private);</span>
<span class="p_del">-	unsigned ds = crypto_ahash_digestsize(private);</span>
<span class="p_add">+	struct algif_hash_tfm *tfm = private;</span>
<span class="p_add">+	struct crypto_ahash *hash = tfm-&gt;hash;</span>
<span class="p_add">+	unsigned len = sizeof(*ctx) + crypto_ahash_reqsize(hash);</span>
<span class="p_add">+	unsigned ds = crypto_ahash_digestsize(hash);</span>
 
 	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
 	if (!ctx)
<span class="p_chunk">@@ -286,7 +425,7 @@</span> <span class="p_context"> static int hash_accept_parent(void *private, struct sock *sk)</span>
 
 	ask-&gt;private = ctx;
 
<span class="p_del">-	ahash_request_set_tfm(&amp;ctx-&gt;req, private);</span>
<span class="p_add">+	ahash_request_set_tfm(&amp;ctx-&gt;req, hash);</span>
 	ahash_request_set_callback(&amp;ctx-&gt;req, CRYPTO_TFM_REQ_MAY_BACKLOG,
 				   af_alg_complete, &amp;ctx-&gt;completion);
 
<span class="p_chunk">@@ -295,12 +434,24 @@</span> <span class="p_context"> static int hash_accept_parent(void *private, struct sock *sk)</span>
 	return 0;
 }
 
<span class="p_add">+static int hash_accept_parent(void *private, struct sock *sk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct algif_hash_tfm *tfm = private;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tfm-&gt;has_key &amp;&amp; crypto_ahash_has_setkey(tfm-&gt;hash))</span>
<span class="p_add">+		return -ENOKEY;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hash_accept_parent_nokey(private, sk);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct af_alg_type algif_type_hash = {
 	.bind		=	hash_bind,
 	.release	=	hash_release,
 	.setkey		=	hash_setkey,
 	.accept		=	hash_accept_parent,
<span class="p_add">+	.accept_nokey	=	hash_accept_parent_nokey,</span>
 	.ops		=	&amp;algif_hash_ops,
<span class="p_add">+	.ops_nokey	=	&amp;algif_hash_ops_nokey,</span>
 	.name		=	&quot;hash&quot;,
 	.owner		=	THIS_MODULE
 };
<span class="p_header">diff --git a/crypto/algif_skcipher.c b/crypto/algif_skcipher.c</span>
<span class="p_header">index 9450752..9565568 100644</span>
<span class="p_header">--- a/crypto/algif_skcipher.c</span>
<span class="p_header">+++ b/crypto/algif_skcipher.c</span>
<span class="p_chunk">@@ -31,6 +31,11 @@</span> <span class="p_context"> struct skcipher_sg_list {</span>
 	struct scatterlist sg[0];
 };
 
<span class="p_add">+struct skcipher_tfm {</span>
<span class="p_add">+	struct crypto_ablkcipher *skcipher;</span>
<span class="p_add">+	bool has_key;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 struct skcipher_ctx {
 	struct list_head tsgl;
 	struct af_alg_sgl rsgl;
<span class="p_chunk">@@ -387,7 +392,8 @@</span> <span class="p_context"> static int skcipher_sendmsg(struct socket *sock, struct msghdr *msg,</span>
 
 		sgl = list_entry(ctx-&gt;tsgl.prev, struct skcipher_sg_list, list);
 		sg = sgl-&gt;sg;
<span class="p_del">-		sg_unmark_end(sg + sgl-&gt;cur);</span>
<span class="p_add">+		if (sgl-&gt;cur)</span>
<span class="p_add">+			sg_unmark_end(sg + sgl-&gt;cur - 1);</span>
 		do {
 			i = sgl-&gt;cur;
 			plen = min_t(int, len, PAGE_SIZE);
<span class="p_chunk">@@ -642,13 +648,6 @@</span> <span class="p_context"> static int skcipher_recvmsg_sync(struct socket *sock, struct msghdr *msg,</span>
 
 	lock_sock(sk);
 	while (msg_data_left(msg)) {
<span class="p_del">-		sgl = list_first_entry(&amp;ctx-&gt;tsgl,</span>
<span class="p_del">-				       struct skcipher_sg_list, list);</span>
<span class="p_del">-		sg = sgl-&gt;sg;</span>
<span class="p_del">-</span>
<span class="p_del">-		while (!sg-&gt;length)</span>
<span class="p_del">-			sg++;</span>
<span class="p_del">-</span>
 		if (!ctx-&gt;used) {
 			err = skcipher_wait_for_data(sk, flags);
 			if (err)
<span class="p_chunk">@@ -669,6 +668,13 @@</span> <span class="p_context"> static int skcipher_recvmsg_sync(struct socket *sock, struct msghdr *msg,</span>
 		if (!used)
 			goto free;
 
<span class="p_add">+		sgl = list_first_entry(&amp;ctx-&gt;tsgl,</span>
<span class="p_add">+				       struct skcipher_sg_list, list);</span>
<span class="p_add">+		sg = sgl-&gt;sg;</span>
<span class="p_add">+</span>
<span class="p_add">+		while (!sg-&gt;length)</span>
<span class="p_add">+			sg++;</span>
<span class="p_add">+</span>
 		ablkcipher_request_set_crypt(&amp;ctx-&gt;req, sg,
 					     ctx-&gt;rsgl.sg, used,
 					     ctx-&gt;iv);
<span class="p_chunk">@@ -749,19 +755,139 @@</span> <span class="p_context"> static struct proto_ops algif_skcipher_ops = {</span>
 	.poll		=	skcipher_poll,
 };
 
<span class="p_add">+static int skcipher_check_key(struct socket *sock)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err = 0;</span>
<span class="p_add">+	struct sock *psk;</span>
<span class="p_add">+	struct alg_sock *pask;</span>
<span class="p_add">+	struct skcipher_tfm *tfm;</span>
<span class="p_add">+	struct sock *sk = sock-&gt;sk;</span>
<span class="p_add">+	struct alg_sock *ask = alg_sk(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+	if (ask-&gt;refcnt)</span>
<span class="p_add">+		goto unlock_child;</span>
<span class="p_add">+</span>
<span class="p_add">+	psk = ask-&gt;parent;</span>
<span class="p_add">+	pask = alg_sk(ask-&gt;parent);</span>
<span class="p_add">+	tfm = pask-&gt;private;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = -ENOKEY;</span>
<span class="p_add">+	lock_sock_nested(psk, SINGLE_DEPTH_NESTING);</span>
<span class="p_add">+	if (!tfm-&gt;has_key)</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pask-&gt;refcnt++)</span>
<span class="p_add">+		sock_hold(psk);</span>
<span class="p_add">+</span>
<span class="p_add">+	ask-&gt;refcnt = 1;</span>
<span class="p_add">+	sock_put(psk);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+unlock:</span>
<span class="p_add">+	release_sock(psk);</span>
<span class="p_add">+unlock_child:</span>
<span class="p_add">+	release_sock(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int skcipher_sendmsg_nokey(struct socket *sock, struct msghdr *msg,</span>
<span class="p_add">+				  size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = skcipher_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return skcipher_sendmsg(sock, msg, size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static ssize_t skcipher_sendpage_nokey(struct socket *sock, struct page *page,</span>
<span class="p_add">+				       int offset, size_t size, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = skcipher_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return skcipher_sendpage(sock, page, offset, size, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int skcipher_recvmsg_nokey(struct socket *sock, struct msghdr *msg,</span>
<span class="p_add">+				  size_t ignored, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = skcipher_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return skcipher_recvmsg(sock, msg, ignored, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct proto_ops algif_skcipher_ops_nokey = {</span>
<span class="p_add">+	.family		=	PF_ALG,</span>
<span class="p_add">+</span>
<span class="p_add">+	.connect	=	sock_no_connect,</span>
<span class="p_add">+	.socketpair	=	sock_no_socketpair,</span>
<span class="p_add">+	.getname	=	sock_no_getname,</span>
<span class="p_add">+	.ioctl		=	sock_no_ioctl,</span>
<span class="p_add">+	.listen		=	sock_no_listen,</span>
<span class="p_add">+	.shutdown	=	sock_no_shutdown,</span>
<span class="p_add">+	.getsockopt	=	sock_no_getsockopt,</span>
<span class="p_add">+	.mmap		=	sock_no_mmap,</span>
<span class="p_add">+	.bind		=	sock_no_bind,</span>
<span class="p_add">+	.accept		=	sock_no_accept,</span>
<span class="p_add">+	.setsockopt	=	sock_no_setsockopt,</span>
<span class="p_add">+</span>
<span class="p_add">+	.release	=	af_alg_release,</span>
<span class="p_add">+	.sendmsg	=	skcipher_sendmsg_nokey,</span>
<span class="p_add">+	.sendpage	=	skcipher_sendpage_nokey,</span>
<span class="p_add">+	.recvmsg	=	skcipher_recvmsg_nokey,</span>
<span class="p_add">+	.poll		=	skcipher_poll,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static void *skcipher_bind(const char *name, u32 type, u32 mask)
 {
<span class="p_del">-	return crypto_alloc_ablkcipher(name, type, mask);</span>
<span class="p_add">+	struct skcipher_tfm *tfm;</span>
<span class="p_add">+	struct crypto_ablkcipher *skcipher;</span>
<span class="p_add">+</span>
<span class="p_add">+	tfm = kzalloc(sizeof(*tfm), GFP_KERNEL);</span>
<span class="p_add">+	if (!tfm)</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+</span>
<span class="p_add">+	skcipher = crypto_alloc_ablkcipher(name, type, mask);</span>
<span class="p_add">+	if (IS_ERR(skcipher)) {</span>
<span class="p_add">+		kfree(tfm);</span>
<span class="p_add">+		return ERR_CAST(skcipher);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	tfm-&gt;skcipher = skcipher;</span>
<span class="p_add">+</span>
<span class="p_add">+	return tfm;</span>
 }
 
 static void skcipher_release(void *private)
 {
<span class="p_del">-	crypto_free_ablkcipher(private);</span>
<span class="p_add">+	struct skcipher_tfm *tfm = private;</span>
<span class="p_add">+</span>
<span class="p_add">+	crypto_free_ablkcipher(tfm-&gt;skcipher);</span>
<span class="p_add">+	kfree(tfm);</span>
 }
 
 static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
 {
<span class="p_del">-	return crypto_ablkcipher_setkey(private, key, keylen);</span>
<span class="p_add">+	struct skcipher_tfm *tfm = private;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = crypto_ablkcipher_setkey(tfm-&gt;skcipher, key, keylen);</span>
<span class="p_add">+	tfm-&gt;has_key = !err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
 }
 
 static void skcipher_wait(struct sock *sk)
<span class="p_chunk">@@ -789,24 +915,26 @@</span> <span class="p_context"> static void skcipher_sock_destruct(struct sock *sk)</span>
 	af_alg_release_parent(sk);
 }
 
<span class="p_del">-static int skcipher_accept_parent(void *private, struct sock *sk)</span>
<span class="p_add">+static int skcipher_accept_parent_nokey(void *private, struct sock *sk)</span>
 {
 	struct skcipher_ctx *ctx;
 	struct alg_sock *ask = alg_sk(sk);
<span class="p_del">-	unsigned int len = sizeof(*ctx) + crypto_ablkcipher_reqsize(private);</span>
<span class="p_add">+	struct skcipher_tfm *tfm = private;</span>
<span class="p_add">+	struct crypto_ablkcipher *skcipher = tfm-&gt;skcipher;</span>
<span class="p_add">+	unsigned int len = sizeof(*ctx) + crypto_ablkcipher_reqsize(skcipher);</span>
 
 	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
 	if (!ctx)
 		return -ENOMEM;
 
<span class="p_del">-	ctx-&gt;iv = sock_kmalloc(sk, crypto_ablkcipher_ivsize(private),</span>
<span class="p_add">+	ctx-&gt;iv = sock_kmalloc(sk, crypto_ablkcipher_ivsize(skcipher),</span>
 			       GFP_KERNEL);
 	if (!ctx-&gt;iv) {
 		sock_kfree_s(sk, ctx, len);
 		return -ENOMEM;
 	}
 
<span class="p_del">-	memset(ctx-&gt;iv, 0, crypto_ablkcipher_ivsize(private));</span>
<span class="p_add">+	memset(ctx-&gt;iv, 0, crypto_ablkcipher_ivsize(skcipher));</span>
 
 	INIT_LIST_HEAD(&amp;ctx-&gt;tsgl);
 	ctx-&gt;len = len;
<span class="p_chunk">@@ -819,7 +947,7 @@</span> <span class="p_context"> static int skcipher_accept_parent(void *private, struct sock *sk)</span>
 
 	ask-&gt;private = ctx;
 
<span class="p_del">-	ablkcipher_request_set_tfm(&amp;ctx-&gt;req, private);</span>
<span class="p_add">+	ablkcipher_request_set_tfm(&amp;ctx-&gt;req, skcipher);</span>
 	ablkcipher_request_set_callback(&amp;ctx-&gt;req, CRYPTO_TFM_REQ_MAY_BACKLOG,
 					af_alg_complete, &amp;ctx-&gt;completion);
 
<span class="p_chunk">@@ -828,12 +956,24 @@</span> <span class="p_context"> static int skcipher_accept_parent(void *private, struct sock *sk)</span>
 	return 0;
 }
 
<span class="p_add">+static int skcipher_accept_parent(void *private, struct sock *sk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct skcipher_tfm *tfm = private;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tfm-&gt;has_key)</span>
<span class="p_add">+		return -ENOKEY;</span>
<span class="p_add">+</span>
<span class="p_add">+	return skcipher_accept_parent_nokey(private, sk);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct af_alg_type algif_type_skcipher = {
 	.bind		=	skcipher_bind,
 	.release	=	skcipher_release,
 	.setkey		=	skcipher_setkey,
 	.accept		=	skcipher_accept_parent,
<span class="p_add">+	.accept_nokey	=	skcipher_accept_parent_nokey,</span>
 	.ops		=	&amp;algif_skcipher_ops,
<span class="p_add">+	.ops_nokey	=	&amp;algif_skcipher_ops_nokey,</span>
 	.name		=	&quot;skcipher&quot;,
 	.owner		=	THIS_MODULE
 };
<span class="p_header">diff --git a/crypto/crc32c_generic.c b/crypto/crc32c_generic.c</span>
<span class="p_header">index 06f1b60..4c0a0e2 100644</span>
<span class="p_header">--- a/crypto/crc32c_generic.c</span>
<span class="p_header">+++ b/crypto/crc32c_generic.c</span>
<span class="p_chunk">@@ -172,4 +172,3 @@</span> <span class="p_context"> MODULE_DESCRIPTION(&quot;CRC32c (Castagnoli) calculations wrapper for lib/crc32c&quot;);</span>
 MODULE_LICENSE(&quot;GPL&quot;);
 MODULE_ALIAS_CRYPTO(&quot;crc32c&quot;);
 MODULE_ALIAS_CRYPTO(&quot;crc32c-generic&quot;);
<span class="p_del">-MODULE_SOFTDEP(&quot;pre: crc32c&quot;);</span>
<span class="p_header">diff --git a/crypto/shash.c b/crypto/shash.c</span>
<span class="p_header">index ecb1e3d..88a27de 100644</span>
<span class="p_header">--- a/crypto/shash.c</span>
<span class="p_header">+++ b/crypto/shash.c</span>
<span class="p_chunk">@@ -355,8 +355,10 @@</span> <span class="p_context"> int crypto_init_shash_ops_async(struct crypto_tfm *tfm)</span>
 	crt-&gt;finup = shash_async_finup;
 	crt-&gt;digest = shash_async_digest;
 
<span class="p_del">-	if (alg-&gt;setkey)</span>
<span class="p_add">+	if (alg-&gt;setkey) {</span>
 		crt-&gt;setkey = shash_async_setkey;
<span class="p_add">+		crt-&gt;has_setkey = true;</span>
<span class="p_add">+	}</span>
 	if (alg-&gt;export)
 		crt-&gt;export = shash_async_export;
 	if (alg-&gt;import)
<span class="p_header">diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c</span>
<span class="p_header">index 46b58ab..087cb7d 100644</span>
<span class="p_header">--- a/drivers/acpi/acpi_lpss.c</span>
<span class="p_header">+++ b/drivers/acpi/acpi_lpss.c</span>
<span class="p_chunk">@@ -680,8 +680,13 @@</span> <span class="p_context"> static int acpi_lpss_platform_notify(struct notifier_block *nb,</span>
 	}
 
 	switch (action) {
<span class="p_del">-	case BUS_NOTIFY_ADD_DEVICE:</span>
<span class="p_add">+	case BUS_NOTIFY_BOUND_DRIVER:</span>
 		pdev-&gt;dev.pm_domain = &amp;acpi_lpss_pm_domain;
<span class="p_add">+		break;</span>
<span class="p_add">+	case BUS_NOTIFY_UNBOUND_DRIVER:</span>
<span class="p_add">+		pdev-&gt;dev.pm_domain = NULL;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case BUS_NOTIFY_ADD_DEVICE:</span>
 		if (pdata-&gt;dev_desc-&gt;flags &amp; LPSS_LTR)
 			return sysfs_create_group(&amp;pdev-&gt;dev.kobj,
 						  &amp;lpss_attr_group);
<span class="p_chunk">@@ -689,7 +694,6 @@</span> <span class="p_context"> static int acpi_lpss_platform_notify(struct notifier_block *nb,</span>
 	case BUS_NOTIFY_DEL_DEVICE:
 		if (pdata-&gt;dev_desc-&gt;flags &amp; LPSS_LTR)
 			sysfs_remove_group(&amp;pdev-&gt;dev.kobj, &amp;lpss_attr_group);
<span class="p_del">-		pdev-&gt;dev.pm_domain = NULL;</span>
 		break;
 	default:
 		break;
<span class="p_header">diff --git a/drivers/acpi/acpi_video.c b/drivers/acpi/acpi_video.c</span>
<span class="p_header">index 8c2fe2f..586a87b 100644</span>
<span class="p_header">--- a/drivers/acpi/acpi_video.c</span>
<span class="p_header">+++ b/drivers/acpi/acpi_video.c</span>
<span class="p_chunk">@@ -451,6 +451,15 @@</span> <span class="p_context"> static struct dmi_system_id video_dmi_table[] = {</span>
 	 * as brightness control does not work.
 	 */
 	{
<span class="p_add">+	 /* https://bugzilla.kernel.org/show_bug.cgi?id=21012 */</span>
<span class="p_add">+	 .callback = video_disable_backlight_sysfs_if,</span>
<span class="p_add">+	 .ident = &quot;Toshiba Portege R700&quot;,</span>
<span class="p_add">+	 .matches = {</span>
<span class="p_add">+		DMI_MATCH(DMI_SYS_VENDOR, &quot;TOSHIBA&quot;),</span>
<span class="p_add">+		DMI_MATCH(DMI_PRODUCT_NAME, &quot;PORTEGE R700&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 	 /* https://bugs.freedesktop.org/show_bug.cgi?id=82634 */
 	 .callback = video_disable_backlight_sysfs_if,
 	 .ident = &quot;Toshiba Portege R830&quot;,
<span class="p_chunk">@@ -459,6 +468,15 @@</span> <span class="p_context"> static struct dmi_system_id video_dmi_table[] = {</span>
 		DMI_MATCH(DMI_PRODUCT_NAME, &quot;PORTEGE R830&quot;),
 		},
 	},
<span class="p_add">+	{</span>
<span class="p_add">+	 /* https://bugzilla.kernel.org/show_bug.cgi?id=21012 */</span>
<span class="p_add">+	 .callback = video_disable_backlight_sysfs_if,</span>
<span class="p_add">+	 .ident = &quot;Toshiba Satellite R830&quot;,</span>
<span class="p_add">+	 .matches = {</span>
<span class="p_add">+		DMI_MATCH(DMI_SYS_VENDOR, &quot;TOSHIBA&quot;),</span>
<span class="p_add">+		DMI_MATCH(DMI_PRODUCT_NAME, &quot;SATELLITE R830&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 	{}
 };
 
<span class="p_header">diff --git a/drivers/base/firmware_class.c b/drivers/base/firmware_class.c</span>
<span class="p_header">index 894bda1..fdddf26 100644</span>
<span class="p_header">--- a/drivers/base/firmware_class.c</span>
<span class="p_header">+++ b/drivers/base/firmware_class.c</span>
<span class="p_chunk">@@ -1118,15 +1118,17 @@</span> <span class="p_context"> static int</span>
 _request_firmware(const struct firmware **firmware_p, const char *name,
 		  struct device *device, unsigned int opt_flags)
 {
<span class="p_del">-	struct firmware *fw;</span>
<span class="p_add">+	struct firmware *fw = NULL;</span>
 	long timeout;
 	int ret;
 
 	if (!firmware_p)
 		return -EINVAL;
 
<span class="p_del">-	if (!name || name[0] == &#39;\0&#39;)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	if (!name || name[0] == &#39;\0&#39;) {</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 	ret = _request_firmware_prepare(&amp;fw, name, device);
 	if (ret &lt;= 0) /* error or already assigned */
<span class="p_header">diff --git a/drivers/block/zram/zcomp.c b/drivers/block/zram/zcomp.c</span>
<span class="p_header">index 5cb13ca..c536177 100644</span>
<span class="p_header">--- a/drivers/block/zram/zcomp.c</span>
<span class="p_header">+++ b/drivers/block/zram/zcomp.c</span>
<span class="p_chunk">@@ -76,7 +76,7 @@</span> <span class="p_context"> static void zcomp_strm_free(struct zcomp *comp, struct zcomp_strm *zstrm)</span>
  */
 static struct zcomp_strm *zcomp_strm_alloc(struct zcomp *comp)
 {
<span class="p_del">-	struct zcomp_strm *zstrm = kmalloc(sizeof(*zstrm), GFP_KERNEL);</span>
<span class="p_add">+	struct zcomp_strm *zstrm = kmalloc(sizeof(*zstrm), GFP_NOIO);</span>
 	if (!zstrm)
 		return NULL;
 
<span class="p_chunk">@@ -85,7 +85,7 @@</span> <span class="p_context"> static struct zcomp_strm *zcomp_strm_alloc(struct zcomp *comp)</span>
 	 * allocate 2 pages. 1 for compressed data, plus 1 extra for the
 	 * case when compressed size is larger than the original one
 	 */
<span class="p_del">-	zstrm-&gt;buffer = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, 1);</span>
<span class="p_add">+	zstrm-&gt;buffer = (void *)__get_free_pages(GFP_NOIO | __GFP_ZERO, 1);</span>
 	if (!zstrm-&gt;private || !zstrm-&gt;buffer) {
 		zcomp_strm_free(comp, zstrm);
 		zstrm = NULL;
<span class="p_header">diff --git a/drivers/block/zram/zcomp_lz4.c b/drivers/block/zram/zcomp_lz4.c</span>
<span class="p_header">index f2afb7e..dd60831 100644</span>
<span class="p_header">--- a/drivers/block/zram/zcomp_lz4.c</span>
<span class="p_header">+++ b/drivers/block/zram/zcomp_lz4.c</span>
<span class="p_chunk">@@ -10,17 +10,36 @@</span> <span class="p_context"></span>
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/lz4.h&gt;
<span class="p_add">+#include &lt;linux/vmalloc.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
 
 #include &quot;zcomp_lz4.h&quot;
 
 static void *zcomp_lz4_create(void)
 {
<span class="p_del">-	return kzalloc(LZ4_MEM_COMPRESS, GFP_KERNEL);</span>
<span class="p_add">+	void *ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This function can be called in swapout/fs write path</span>
<span class="p_add">+	 * so we can&#39;t use GFP_FS|IO. And it assumes we already</span>
<span class="p_add">+	 * have at least one stream in zram initialization so we</span>
<span class="p_add">+	 * don&#39;t do best effort to allocate more stream in here.</span>
<span class="p_add">+	 * A default stream will work well without further multiple</span>
<span class="p_add">+	 * streams. That&#39;s why we use NORETRY | NOWARN.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ret = kzalloc(LZ4_MEM_COMPRESS, GFP_NOIO | __GFP_NORETRY |</span>
<span class="p_add">+					__GFP_NOWARN);</span>
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		ret = __vmalloc(LZ4_MEM_COMPRESS,</span>
<span class="p_add">+				GFP_NOIO | __GFP_NORETRY | __GFP_NOWARN |</span>
<span class="p_add">+				__GFP_ZERO | __GFP_HIGHMEM,</span>
<span class="p_add">+				PAGE_KERNEL);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static void zcomp_lz4_destroy(void *private)
 {
<span class="p_del">-	kfree(private);</span>
<span class="p_add">+	kvfree(private);</span>
 }
 
 static int zcomp_lz4_compress(const unsigned char *src, unsigned char *dst,
<span class="p_header">diff --git a/drivers/block/zram/zcomp_lzo.c b/drivers/block/zram/zcomp_lzo.c</span>
<span class="p_header">index da1bc47..edc5499 100644</span>
<span class="p_header">--- a/drivers/block/zram/zcomp_lzo.c</span>
<span class="p_header">+++ b/drivers/block/zram/zcomp_lzo.c</span>
<span class="p_chunk">@@ -10,17 +10,36 @@</span> <span class="p_context"></span>
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/lzo.h&gt;
<span class="p_add">+#include &lt;linux/vmalloc.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
 
 #include &quot;zcomp_lzo.h&quot;
 
 static void *lzo_create(void)
 {
<span class="p_del">-	return kzalloc(LZO1X_MEM_COMPRESS, GFP_KERNEL);</span>
<span class="p_add">+	void *ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This function can be called in swapout/fs write path</span>
<span class="p_add">+	 * so we can&#39;t use GFP_FS|IO. And it assumes we already</span>
<span class="p_add">+	 * have at least one stream in zram initialization so we</span>
<span class="p_add">+	 * don&#39;t do best effort to allocate more stream in here.</span>
<span class="p_add">+	 * A default stream will work well without further multiple</span>
<span class="p_add">+	 * streams. That&#39;s why we use NORETRY | NOWARN.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ret = kzalloc(LZO1X_MEM_COMPRESS, GFP_NOIO | __GFP_NORETRY |</span>
<span class="p_add">+					__GFP_NOWARN);</span>
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		ret = __vmalloc(LZO1X_MEM_COMPRESS,</span>
<span class="p_add">+				GFP_NOIO | __GFP_NORETRY | __GFP_NOWARN |</span>
<span class="p_add">+				__GFP_ZERO | __GFP_HIGHMEM,</span>
<span class="p_add">+				PAGE_KERNEL);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static void lzo_destroy(void *private)
 {
<span class="p_del">-	kfree(private);</span>
<span class="p_add">+	kvfree(private);</span>
 }
 
 static int lzo_compress(const unsigned char *src, unsigned char *dst,
<span class="p_header">diff --git a/drivers/block/zram/zram_drv.c b/drivers/block/zram/zram_drv.c</span>
<span class="p_header">index 763301c..6a706f5 100644</span>
<span class="p_header">--- a/drivers/block/zram/zram_drv.c</span>
<span class="p_header">+++ b/drivers/block/zram/zram_drv.c</span>
<span class="p_chunk">@@ -1319,7 +1319,6 @@</span> <span class="p_context"> static int zram_remove(struct zram *zram)</span>
 
 	pr_info(&quot;Removed device: %s\n&quot;, zram-&gt;disk-&gt;disk_name);
 
<span class="p_del">-	idr_remove(&amp;zram_index_idr, zram-&gt;disk-&gt;first_minor);</span>
 	blk_cleanup_queue(zram-&gt;disk-&gt;queue);
 	del_gendisk(zram-&gt;disk);
 	put_disk(zram-&gt;disk);
<span class="p_chunk">@@ -1361,10 +1360,12 @@</span> <span class="p_context"> static ssize_t hot_remove_store(struct class *class,</span>
 	mutex_lock(&amp;zram_index_mutex);
 
 	zram = idr_find(&amp;zram_index_idr, dev_id);
<span class="p_del">-	if (zram)</span>
<span class="p_add">+	if (zram) {</span>
 		ret = zram_remove(zram);
<span class="p_del">-	else</span>
<span class="p_add">+		idr_remove(&amp;zram_index_idr, dev_id);</span>
<span class="p_add">+	} else {</span>
 		ret = -ENODEV;
<span class="p_add">+	}</span>
 
 	mutex_unlock(&amp;zram_index_mutex);
 	return ret ? ret : count;
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index 7d9b09f..f869fb1 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -145,6 +145,10 @@</span> <span class="p_context"> static const struct usb_device_id btusb_table[] = {</span>
 	{ USB_VENDOR_AND_INTERFACE_INFO(0x13d3, 0xff, 0x01, 0x01),
 	  .driver_info = BTUSB_BCM_PATCHRAM },
 
<span class="p_add">+	/* Toshiba Corp - Broadcom based */</span>
<span class="p_add">+	{ USB_VENDOR_AND_INTERFACE_INFO(0x0930, 0xff, 0x01, 0x01),</span>
<span class="p_add">+	  .driver_info = BTUSB_BCM_PATCHRAM },</span>
<span class="p_add">+</span>
 	/* Intel Bluetooth USB Bootloader (RAM module) */
 	{ USB_DEVICE(0x8087, 0x0a5a),
 	  .driver_info = BTUSB_INTEL_BOOT | BTUSB_BROKEN_ISOC },
<span class="p_header">diff --git a/drivers/char/tpm/tpm_tis.c b/drivers/char/tpm/tpm_tis.c</span>
<span class="p_header">index 19f9c7dc..60267d7 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_tis.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_tis.c</span>
<span class="p_chunk">@@ -401,7 +401,7 @@</span> <span class="p_context"> static void disable_interrupts(struct tpm_chip *chip)</span>
 	iowrite32(intmask,
 		  chip-&gt;vendor.iobase +
 		  TPM_INT_ENABLE(chip-&gt;vendor.locality));
<span class="p_del">-	free_irq(chip-&gt;vendor.irq, chip);</span>
<span class="p_add">+	devm_free_irq(chip-&gt;pdev, chip-&gt;vendor.irq, chip);</span>
 	chip-&gt;vendor.irq = 0;
 }
 
<span class="p_header">diff --git a/drivers/clk/clk-xgene.c b/drivers/clk/clk-xgene.c</span>
<span class="p_header">index f26b3ac..2f9668b 100644</span>
<span class="p_header">--- a/drivers/clk/clk-xgene.c</span>
<span class="p_header">+++ b/drivers/clk/clk-xgene.c</span>
<span class="p_chunk">@@ -353,7 +353,8 @@</span> <span class="p_context"> static int xgene_clk_set_rate(struct clk_hw *hw, unsigned long rate,</span>
 		/* Set new divider */
 		data = xgene_clk_read(pclk-&gt;param.divider_reg +
 				pclk-&gt;param.reg_divider_offset);
<span class="p_del">-		data &amp;= ~((1 &lt;&lt; pclk-&gt;param.reg_divider_width) - 1);</span>
<span class="p_add">+		data &amp;= ~((1 &lt;&lt; pclk-&gt;param.reg_divider_width) - 1)</span>
<span class="p_add">+				&lt;&lt; pclk-&gt;param.reg_divider_shift;</span>
 		data |= divider;
 		xgene_clk_write(data, pclk-&gt;param.divider_reg +
 					pclk-&gt;param.reg_divider_offset);
<span class="p_header">diff --git a/drivers/clk/samsung/clk-cpu.c b/drivers/clk/samsung/clk-cpu.c</span>
<span class="p_header">index dd02356..ae5b9c4 100644</span>
<span class="p_header">--- a/drivers/clk/samsung/clk-cpu.c</span>
<span class="p_header">+++ b/drivers/clk/samsung/clk-cpu.c</span>
<span class="p_chunk">@@ -145,6 +145,7 @@</span> <span class="p_context"> static int exynos_cpuclk_pre_rate_change(struct clk_notifier_data *ndata,</span>
 	unsigned long alt_prate = clk_get_rate(cpuclk-&gt;alt_parent);
 	unsigned long alt_div = 0, alt_div_mask = DIV_MASK;
 	unsigned long div0, div1 = 0, mux_reg;
<span class="p_add">+	unsigned long flags;</span>
 
 	/* find out the divider values to use for clock data */
 	while ((cfg_data-&gt;prate * 1000) != ndata-&gt;new_rate) {
<span class="p_chunk">@@ -153,7 +154,7 @@</span> <span class="p_context"> static int exynos_cpuclk_pre_rate_change(struct clk_notifier_data *ndata,</span>
 		cfg_data++;
 	}
 
<span class="p_del">-	spin_lock(cpuclk-&gt;lock);</span>
<span class="p_add">+	spin_lock_irqsave(cpuclk-&gt;lock, flags);</span>
 
 	/*
 	 * For the selected PLL clock frequency, get the pre-defined divider
<span class="p_chunk">@@ -209,7 +210,7 @@</span> <span class="p_context"> static int exynos_cpuclk_pre_rate_change(struct clk_notifier_data *ndata,</span>
 				DIV_MASK_ALL);
 	}
 
<span class="p_del">-	spin_unlock(cpuclk-&gt;lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(cpuclk-&gt;lock, flags);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -220,6 +221,7 @@</span> <span class="p_context"> static int exynos_cpuclk_post_rate_change(struct clk_notifier_data *ndata,</span>
 	const struct exynos_cpuclk_cfg_data *cfg_data = cpuclk-&gt;cfg;
 	unsigned long div = 0, div_mask = DIV_MASK;
 	unsigned long mux_reg;
<span class="p_add">+	unsigned long flags;</span>
 
 	/* find out the divider values to use for clock data */
 	if (cpuclk-&gt;flags &amp; CLK_CPU_NEEDS_DEBUG_ALT_DIV) {
<span class="p_chunk">@@ -230,7 +232,7 @@</span> <span class="p_context"> static int exynos_cpuclk_post_rate_change(struct clk_notifier_data *ndata,</span>
 		}
 	}
 
<span class="p_del">-	spin_lock(cpuclk-&gt;lock);</span>
<span class="p_add">+	spin_lock_irqsave(cpuclk-&gt;lock, flags);</span>
 
 	/* select mout_apll as the alternate parent */
 	mux_reg = readl(base + E4210_SRC_CPU);
<span class="p_chunk">@@ -243,7 +245,7 @@</span> <span class="p_context"> static int exynos_cpuclk_post_rate_change(struct clk_notifier_data *ndata,</span>
 	}
 
 	exynos_set_safe_div(base, div, div_mask);
<span class="p_del">-	spin_unlock(cpuclk-&gt;lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(cpuclk-&gt;lock, flags);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/clk/st/clkgen-fsyn.c b/drivers/clk/st/clkgen-fsyn.c</span>
<span class="p_header">index d9eb2e1..a7a8cdd 100644</span>
<span class="p_header">--- a/drivers/clk/st/clkgen-fsyn.c</span>
<span class="p_header">+++ b/drivers/clk/st/clkgen-fsyn.c</span>
<span class="p_chunk">@@ -548,19 +548,20 @@</span> <span class="p_context"> static int clk_fs660c32_vco_get_params(unsigned long input,</span>
 	return 0;
 }
 
<span class="p_del">-static long quadfs_pll_fs660c32_round_rate(struct clk_hw *hw, unsigned long rate</span>
<span class="p_del">-		, unsigned long *prate)</span>
<span class="p_add">+static long quadfs_pll_fs660c32_round_rate(struct clk_hw *hw,</span>
<span class="p_add">+					   unsigned long rate,</span>
<span class="p_add">+					   unsigned long *prate)</span>
 {
 	struct stm_fs params;
 
<span class="p_del">-	if (!clk_fs660c32_vco_get_params(*prate, rate, &amp;params))</span>
<span class="p_del">-		clk_fs660c32_vco_get_rate(*prate, &amp;params, &amp;rate);</span>
<span class="p_add">+	if (clk_fs660c32_vco_get_params(*prate, rate, &amp;params))</span>
<span class="p_add">+		return rate;</span>
 
<span class="p_del">-	pr_debug(&quot;%s: %s new rate %ld [sdiv=0x%x,md=0x%x,pe=0x%x,nsdiv3=%u]\n&quot;,</span>
<span class="p_add">+	clk_fs660c32_vco_get_rate(*prate, &amp;params, &amp;rate);</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;%s: %s new rate %ld [ndiv=%u]\n&quot;,</span>
 		 __func__, __clk_get_name(hw-&gt;clk),
<span class="p_del">-		 rate, (unsigned int)params.sdiv,</span>
<span class="p_del">-		 (unsigned int)params.mdiv,</span>
<span class="p_del">-		 (unsigned int)params.pe, (unsigned int)params.nsdiv);</span>
<span class="p_add">+		 rate, (unsigned int)params.ndiv);</span>
 
 	return rate;
 }
<span class="p_header">diff --git a/drivers/clocksource/vt8500_timer.c b/drivers/clocksource/vt8500_timer.c</span>
<span class="p_header">index 1098ed3..dc45ddb 100644</span>
<span class="p_header">--- a/drivers/clocksource/vt8500_timer.c</span>
<span class="p_header">+++ b/drivers/clocksource/vt8500_timer.c</span>
<span class="p_chunk">@@ -50,6 +50,8 @@</span> <span class="p_context"></span>
 
 #define msecs_to_loops(t) (loops_per_jiffy / 1000 * HZ * t)
 
<span class="p_add">+#define MIN_OSCR_DELTA		16</span>
<span class="p_add">+</span>
 static void __iomem *regbase;
 
 static cycle_t vt8500_timer_read(struct clocksource *cs)
<span class="p_chunk">@@ -80,7 +82,7 @@</span> <span class="p_context"> static int vt8500_timer_set_next_event(unsigned long cycles,</span>
 		cpu_relax();
 	writel((unsigned long)alarm, regbase + TIMER_MATCH_VAL);
 
<span class="p_del">-	if ((signed)(alarm - clocksource.read(&amp;clocksource)) &lt;= 16)</span>
<span class="p_add">+	if ((signed)(alarm - clocksource.read(&amp;clocksource)) &lt;= MIN_OSCR_DELTA)</span>
 		return -ETIME;
 
 	writel(1, regbase + TIMER_IER_VAL);
<span class="p_chunk">@@ -160,7 +162,7 @@</span> <span class="p_context"> static void __init vt8500_timer_init(struct device_node *np)</span>
 		pr_err(&quot;%s: setup_irq failed for %s\n&quot;, __func__,
 							clockevent.name);
 	clockevents_config_and_register(&amp;clockevent, VT8500_TIMER_HZ,
<span class="p_del">-					4, 0xf0000000);</span>
<span class="p_add">+					MIN_OSCR_DELTA * 2, 0xf0000000);</span>
 }
 
 CLOCKSOURCE_OF_DECLARE(vt8500, &quot;via,vt8500-timer&quot;, vt8500_timer_init);
<span class="p_header">diff --git a/drivers/connector/connector.c b/drivers/connector/connector.c</span>
<span class="p_header">index 30f5228..c19e7fc 100644</span>
<span class="p_header">--- a/drivers/connector/connector.c</span>
<span class="p_header">+++ b/drivers/connector/connector.c</span>
<span class="p_chunk">@@ -178,26 +178,21 @@</span> <span class="p_context"> static int cn_call_callback(struct sk_buff *skb)</span>
  *
  * It checks skb, netlink header and msg sizes, and calls callback helper.
  */
<span class="p_del">-static void cn_rx_skb(struct sk_buff *__skb)</span>
<span class="p_add">+static void cn_rx_skb(struct sk_buff *skb)</span>
 {
 	struct nlmsghdr *nlh;
<span class="p_del">-	struct sk_buff *skb;</span>
 	int len, err;
 
<span class="p_del">-	skb = skb_get(__skb);</span>
<span class="p_del">-</span>
 	if (skb-&gt;len &gt;= NLMSG_HDRLEN) {
 		nlh = nlmsg_hdr(skb);
 		len = nlmsg_len(nlh);
 
 		if (len &lt; (int)sizeof(struct cn_msg) ||
 		    skb-&gt;len &lt; nlh-&gt;nlmsg_len ||
<span class="p_del">-		    len &gt; CONNECTOR_MAX_MSG_SIZE) {</span>
<span class="p_del">-			kfree_skb(skb);</span>
<span class="p_add">+		    len &gt; CONNECTOR_MAX_MSG_SIZE)</span>
 			return;
<span class="p_del">-		}</span>
 
<span class="p_del">-		err = cn_call_callback(skb);</span>
<span class="p_add">+		err = cn_call_callback(skb_get(skb));</span>
 		if (err &lt; 0)
 			kfree_skb(skb);
 	}
<span class="p_header">diff --git a/drivers/dma/at_xdmac.c b/drivers/dma/at_xdmac.c</span>
<span class="p_header">index c01cdec..756210a 100644</span>
<span class="p_header">--- a/drivers/dma/at_xdmac.c</span>
<span class="p_header">+++ b/drivers/dma/at_xdmac.c</span>
<span class="p_chunk">@@ -1524,6 +1524,7 @@</span> <span class="p_context"> static int at_xdmac_device_terminate_all(struct dma_chan *chan)</span>
 	list_for_each_entry_safe(desc, _desc, &amp;atchan-&gt;xfers_list, xfer_node)
 		at_xdmac_remove_xfer(atchan, desc);
 
<span class="p_add">+	clear_bit(AT_XDMAC_CHAN_IS_PAUSED, &amp;atchan-&gt;status);</span>
 	clear_bit(AT_XDMAC_CHAN_IS_CYCLIC, &amp;atchan-&gt;status);
 	spin_unlock_irqrestore(&amp;atchan-&gt;lock, flags);
 
<span class="p_chunk">@@ -1656,6 +1657,8 @@</span> <span class="p_context"> static int atmel_xdmac_resume(struct device *dev)</span>
 		atchan = to_at_xdmac_chan(chan);
 		at_xdmac_chan_write(atchan, AT_XDMAC_CC, atchan-&gt;save_cc);
 		if (at_xdmac_chan_is_cyclic(atchan)) {
<span class="p_add">+			if (at_xdmac_chan_is_paused(atchan))</span>
<span class="p_add">+				at_xdmac_device_resume(chan);</span>
 			at_xdmac_chan_write(atchan, AT_XDMAC_CNDA, atchan-&gt;save_cnda);
 			at_xdmac_chan_write(atchan, AT_XDMAC_CNDC, atchan-&gt;save_cndc);
 			at_xdmac_chan_write(atchan, AT_XDMAC_CIE, atchan-&gt;save_cim);
<span class="p_header">diff --git a/drivers/dma/dw/core.c b/drivers/dma/dw/core.c</span>
<span class="p_header">index 4287c7c..a00d72f 100644</span>
<span class="p_header">--- a/drivers/dma/dw/core.c</span>
<span class="p_header">+++ b/drivers/dma/dw/core.c</span>
<span class="p_chunk">@@ -156,6 +156,7 @@</span> <span class="p_context"> static void dwc_initialize(struct dw_dma_chan *dwc)</span>
 
 	/* Enable interrupts */
 	channel_set_bit(dw, MASK.XFER, dwc-&gt;mask);
<span class="p_add">+	channel_set_bit(dw, MASK.BLOCK, dwc-&gt;mask);</span>
 	channel_set_bit(dw, MASK.ERROR, dwc-&gt;mask);
 
 	dwc-&gt;initialized = true;
<span class="p_chunk">@@ -536,16 +537,17 @@</span> <span class="p_context"> EXPORT_SYMBOL(dw_dma_get_dst_addr);</span>
 
 /* Called with dwc-&gt;lock held and all DMAC interrupts disabled */
 static void dwc_handle_cyclic(struct dw_dma *dw, struct dw_dma_chan *dwc,
<span class="p_del">-		u32 status_err, u32 status_xfer)</span>
<span class="p_add">+		u32 status_block, u32 status_err, u32 status_xfer)</span>
 {
 	unsigned long flags;
 
<span class="p_del">-	if (dwc-&gt;mask) {</span>
<span class="p_add">+	if (status_block &amp; dwc-&gt;mask) {</span>
 		void (*callback)(void *param);
 		void *callback_param;
 
 		dev_vdbg(chan2dev(&amp;dwc-&gt;chan), &quot;new cyclic period llp 0x%08x\n&quot;,
 				channel_readl(dwc, LLP));
<span class="p_add">+		dma_writel(dw, CLEAR.BLOCK, dwc-&gt;mask);</span>
 
 		callback = dwc-&gt;cdesc-&gt;period_callback;
 		callback_param = dwc-&gt;cdesc-&gt;period_callback_param;
<span class="p_chunk">@@ -577,6 +579,7 @@</span> <span class="p_context"> static void dwc_handle_cyclic(struct dw_dma *dw, struct dw_dma_chan *dwc,</span>
 		channel_writel(dwc, CTL_LO, 0);
 		channel_writel(dwc, CTL_HI, 0);
 
<span class="p_add">+		dma_writel(dw, CLEAR.BLOCK, dwc-&gt;mask);</span>
 		dma_writel(dw, CLEAR.ERROR, dwc-&gt;mask);
 		dma_writel(dw, CLEAR.XFER, dwc-&gt;mask);
 
<span class="p_chunk">@@ -593,10 +596,12 @@</span> <span class="p_context"> static void dw_dma_tasklet(unsigned long data)</span>
 {
 	struct dw_dma *dw = (struct dw_dma *)data;
 	struct dw_dma_chan *dwc;
<span class="p_add">+	u32 status_block;</span>
 	u32 status_xfer;
 	u32 status_err;
 	int i;
 
<span class="p_add">+	status_block = dma_readl(dw, RAW.BLOCK);</span>
 	status_xfer = dma_readl(dw, RAW.XFER);
 	status_err = dma_readl(dw, RAW.ERROR);
 
<span class="p_chunk">@@ -605,7 +610,8 @@</span> <span class="p_context"> static void dw_dma_tasklet(unsigned long data)</span>
 	for (i = 0; i &lt; dw-&gt;dma.chancnt; i++) {
 		dwc = &amp;dw-&gt;chan[i];
 		if (test_bit(DW_DMA_IS_CYCLIC, &amp;dwc-&gt;flags))
<span class="p_del">-			dwc_handle_cyclic(dw, dwc, status_err, status_xfer);</span>
<span class="p_add">+			dwc_handle_cyclic(dw, dwc, status_block, status_err,</span>
<span class="p_add">+					status_xfer);</span>
 		else if (status_err &amp; (1 &lt;&lt; i))
 			dwc_handle_error(dw, dwc);
 		else if (status_xfer &amp; (1 &lt;&lt; i))
<span class="p_chunk">@@ -616,6 +622,7 @@</span> <span class="p_context"> static void dw_dma_tasklet(unsigned long data)</span>
 	 * Re-enable interrupts.
 	 */
 	channel_set_bit(dw, MASK.XFER, dw-&gt;all_chan_mask);
<span class="p_add">+	channel_set_bit(dw, MASK.BLOCK, dw-&gt;all_chan_mask);</span>
 	channel_set_bit(dw, MASK.ERROR, dw-&gt;all_chan_mask);
 }
 
<span class="p_chunk">@@ -635,6 +642,7 @@</span> <span class="p_context"> static irqreturn_t dw_dma_interrupt(int irq, void *dev_id)</span>
 	 * softirq handler.
 	 */
 	channel_clear_bit(dw, MASK.XFER, dw-&gt;all_chan_mask);
<span class="p_add">+	channel_clear_bit(dw, MASK.BLOCK, dw-&gt;all_chan_mask);</span>
 	channel_clear_bit(dw, MASK.ERROR, dw-&gt;all_chan_mask);
 
 	status = dma_readl(dw, STATUS_INT);
<span class="p_chunk">@@ -645,6 +653,7 @@</span> <span class="p_context"> static irqreturn_t dw_dma_interrupt(int irq, void *dev_id)</span>
 
 		/* Try to recover */
 		channel_clear_bit(dw, MASK.XFER, (1 &lt;&lt; 8) - 1);
<span class="p_add">+		channel_clear_bit(dw, MASK.BLOCK, (1 &lt;&lt; 8) - 1);</span>
 		channel_clear_bit(dw, MASK.SRC_TRAN, (1 &lt;&lt; 8) - 1);
 		channel_clear_bit(dw, MASK.DST_TRAN, (1 &lt;&lt; 8) - 1);
 		channel_clear_bit(dw, MASK.ERROR, (1 &lt;&lt; 8) - 1);
<span class="p_chunk">@@ -1111,6 +1120,7 @@</span> <span class="p_context"> static void dw_dma_off(struct dw_dma *dw)</span>
 	dma_writel(dw, CFG, 0);
 
 	channel_clear_bit(dw, MASK.XFER, dw-&gt;all_chan_mask);
<span class="p_add">+	channel_clear_bit(dw, MASK.BLOCK, dw-&gt;all_chan_mask);</span>
 	channel_clear_bit(dw, MASK.SRC_TRAN, dw-&gt;all_chan_mask);
 	channel_clear_bit(dw, MASK.DST_TRAN, dw-&gt;all_chan_mask);
 	channel_clear_bit(dw, MASK.ERROR, dw-&gt;all_chan_mask);
<span class="p_chunk">@@ -1216,6 +1226,7 @@</span> <span class="p_context"> static void dwc_free_chan_resources(struct dma_chan *chan)</span>
 
 	/* Disable interrupts */
 	channel_clear_bit(dw, MASK.XFER, dwc-&gt;mask);
<span class="p_add">+	channel_clear_bit(dw, MASK.BLOCK, dwc-&gt;mask);</span>
 	channel_clear_bit(dw, MASK.ERROR, dwc-&gt;mask);
 
 	spin_unlock_irqrestore(&amp;dwc-&gt;lock, flags);
<span class="p_chunk">@@ -1245,7 +1256,6 @@</span> <span class="p_context"> static void dwc_free_chan_resources(struct dma_chan *chan)</span>
 int dw_dma_cyclic_start(struct dma_chan *chan)
 {
 	struct dw_dma_chan	*dwc = to_dw_dma_chan(chan);
<span class="p_del">-	struct dw_dma		*dw = to_dw_dma(dwc-&gt;chan.device);</span>
 	unsigned long		flags;
 
 	if (!test_bit(DW_DMA_IS_CYCLIC, &amp;dwc-&gt;flags)) {
<span class="p_chunk">@@ -1254,27 +1264,7 @@</span> <span class="p_context"> int dw_dma_cyclic_start(struct dma_chan *chan)</span>
 	}
 
 	spin_lock_irqsave(&amp;dwc-&gt;lock, flags);
<span class="p_del">-</span>
<span class="p_del">-	/* Assert channel is idle */</span>
<span class="p_del">-	if (dma_readl(dw, CH_EN) &amp; dwc-&gt;mask) {</span>
<span class="p_del">-		dev_err(chan2dev(&amp;dwc-&gt;chan),</span>
<span class="p_del">-			&quot;%s: BUG: Attempted to start non-idle channel\n&quot;,</span>
<span class="p_del">-			__func__);</span>
<span class="p_del">-		dwc_dump_chan_regs(dwc);</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;dwc-&gt;lock, flags);</span>
<span class="p_del">-		return -EBUSY;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	dma_writel(dw, CLEAR.ERROR, dwc-&gt;mask);</span>
<span class="p_del">-	dma_writel(dw, CLEAR.XFER, dwc-&gt;mask);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Setup DMAC channel registers */</span>
<span class="p_del">-	channel_writel(dwc, LLP, dwc-&gt;cdesc-&gt;desc[0]-&gt;txd.phys);</span>
<span class="p_del">-	channel_writel(dwc, CTL_LO, DWC_CTLL_LLP_D_EN | DWC_CTLL_LLP_S_EN);</span>
<span class="p_del">-	channel_writel(dwc, CTL_HI, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	channel_set_bit(dw, CH_EN, dwc-&gt;mask);</span>
<span class="p_del">-</span>
<span class="p_add">+	dwc_dostart(dwc, dwc-&gt;cdesc-&gt;desc[0]);</span>
 	spin_unlock_irqrestore(&amp;dwc-&gt;lock, flags);
 
 	return 0;
<span class="p_chunk">@@ -1479,6 +1469,7 @@</span> <span class="p_context"> void dw_dma_cyclic_free(struct dma_chan *chan)</span>
 
 	dwc_chan_disable(dw, dwc);
 
<span class="p_add">+	dma_writel(dw, CLEAR.BLOCK, dwc-&gt;mask);</span>
 	dma_writel(dw, CLEAR.ERROR, dwc-&gt;mask);
 	dma_writel(dw, CLEAR.XFER, dwc-&gt;mask);
 
<span class="p_chunk">@@ -1569,9 +1560,6 @@</span> <span class="p_context"> int dw_dma_probe(struct dw_dma_chip *chip, struct dw_dma_platform_data *pdata)</span>
 	/* Force dma off, just in case */
 	dw_dma_off(dw);
 
<span class="p_del">-	/* Disable BLOCK interrupts as well */</span>
<span class="p_del">-	channel_clear_bit(dw, MASK.BLOCK, dw-&gt;all_chan_mask);</span>
<span class="p_del">-</span>
 	/* Create a pool of consistent memory blocks for hardware descriptors */
 	dw-&gt;desc_pool = dmam_pool_create(&quot;dw_dmac_desc_pool&quot;, chip-&gt;dev,
 					 sizeof(struct dw_desc), 4, 0);
<span class="p_header">diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c</span>
<span class="p_header">index 592af5f..5358737 100644</span>
<span class="p_header">--- a/drivers/edac/edac_device.c</span>
<span class="p_header">+++ b/drivers/edac/edac_device.c</span>
<span class="p_chunk">@@ -435,16 +435,13 @@</span> <span class="p_context"> void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,</span>
  */
 void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev)
 {
<span class="p_del">-	int status;</span>
<span class="p_del">-</span>
 	if (!edac_dev-&gt;edac_check)
 		return;
 
<span class="p_del">-	status = cancel_delayed_work(&amp;edac_dev-&gt;work);</span>
<span class="p_del">-	if (status == 0) {</span>
<span class="p_del">-		/* workq instance might be running, wait for it */</span>
<span class="p_del">-		flush_workqueue(edac_workqueue);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	edac_dev-&gt;op_state = OP_OFFLINE;</span>
<span class="p_add">+</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;edac_dev-&gt;work);</span>
<span class="p_add">+	flush_workqueue(edac_workqueue);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/edac/edac_mc.c b/drivers/edac/edac_mc.c</span>
<span class="p_header">index 943ed8c..e315e5e 100644</span>
<span class="p_header">--- a/drivers/edac/edac_mc.c</span>
<span class="p_header">+++ b/drivers/edac/edac_mc.c</span>
<span class="p_chunk">@@ -586,18 +586,10 @@</span> <span class="p_context"> static void edac_mc_workq_setup(struct mem_ctl_info *mci, unsigned msec,</span>
  */
 static void edac_mc_workq_teardown(struct mem_ctl_info *mci)
 {
<span class="p_del">-	int status;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (mci-&gt;op_state != OP_RUNNING_POLL)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	status = cancel_delayed_work(&amp;mci-&gt;work);</span>
<span class="p_del">-	if (status == 0) {</span>
<span class="p_del">-		edac_dbg(0, &quot;not canceled, flush the queue\n&quot;);</span>
<span class="p_add">+	mci-&gt;op_state = OP_OFFLINE;</span>
 
<span class="p_del">-		/* workq instance might be running, wait for it */</span>
<span class="p_del">-		flush_workqueue(edac_workqueue);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;mci-&gt;work);</span>
<span class="p_add">+	flush_workqueue(edac_workqueue);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/edac/edac_mc_sysfs.c b/drivers/edac/edac_mc_sysfs.c</span>
<span class="p_header">index 33df7d9..c3711ae 100644</span>
<span class="p_header">--- a/drivers/edac/edac_mc_sysfs.c</span>
<span class="p_header">+++ b/drivers/edac/edac_mc_sysfs.c</span>
<span class="p_chunk">@@ -972,21 +972,26 @@</span> <span class="p_context"> nomem:</span>
 int edac_create_sysfs_mci_device(struct mem_ctl_info *mci,
 				 const struct attribute_group **groups)
 {
<span class="p_add">+	char *name;</span>
 	int i, err;
 
 	/*
 	 * The memory controller needs its own bus, in order to avoid
 	 * namespace conflicts at /sys/bus/edac.
 	 */
<span class="p_del">-	mci-&gt;bus-&gt;name = kasprintf(GFP_KERNEL, &quot;mc%d&quot;, mci-&gt;mc_idx);</span>
<span class="p_del">-	if (!mci-&gt;bus-&gt;name)</span>
<span class="p_add">+	name = kasprintf(GFP_KERNEL, &quot;mc%d&quot;, mci-&gt;mc_idx);</span>
<span class="p_add">+	if (!name)</span>
 		return -ENOMEM;
 
<span class="p_add">+	mci-&gt;bus-&gt;name = name;</span>
<span class="p_add">+</span>
 	edac_dbg(0, &quot;creating bus %s\n&quot;, mci-&gt;bus-&gt;name);
 
 	err = bus_register(mci-&gt;bus);
<span class="p_del">-	if (err &lt; 0)</span>
<span class="p_del">-		goto fail_free_name;</span>
<span class="p_add">+	if (err &lt; 0) {</span>
<span class="p_add">+		kfree(name);</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+	}</span>
 
 	/* get the /sys/devices/system/edac subsys reference */
 	mci-&gt;dev.type = &amp;mci_attr_type;
<span class="p_chunk">@@ -1055,8 +1060,8 @@</span> <span class="p_context"> fail_unregister_dimm:</span>
 	device_unregister(&amp;mci-&gt;dev);
 fail_unregister_bus:
 	bus_unregister(mci-&gt;bus);
<span class="p_del">-fail_free_name:</span>
<span class="p_del">-	kfree(mci-&gt;bus-&gt;name);</span>
<span class="p_add">+	kfree(name);</span>
<span class="p_add">+</span>
 	return err;
 }
 
<span class="p_chunk">@@ -1087,10 +1092,12 @@</span> <span class="p_context"> void edac_remove_sysfs_mci_device(struct mem_ctl_info *mci)</span>
 
 void edac_unregister_sysfs(struct mem_ctl_info *mci)
 {
<span class="p_add">+	const char *name = mci-&gt;bus-&gt;name;</span>
<span class="p_add">+</span>
 	edac_dbg(1, &quot;Unregistering device %s\n&quot;, dev_name(&amp;mci-&gt;dev));
 	device_unregister(&amp;mci-&gt;dev);
 	bus_unregister(mci-&gt;bus);
<span class="p_del">-	kfree(mci-&gt;bus-&gt;name);</span>
<span class="p_add">+	kfree(name);</span>
 }
 
 static void mc_attr_release(struct device *dev)
<span class="p_header">diff --git a/drivers/edac/edac_pci.c b/drivers/edac/edac_pci.c</span>
<span class="p_header">index 2cf44b4d..b4b3860 100644</span>
<span class="p_header">--- a/drivers/edac/edac_pci.c</span>
<span class="p_header">+++ b/drivers/edac/edac_pci.c</span>
<span class="p_chunk">@@ -274,13 +274,12 @@</span> <span class="p_context"> static void edac_pci_workq_setup(struct edac_pci_ctl_info *pci,</span>
  */
 static void edac_pci_workq_teardown(struct edac_pci_ctl_info *pci)
 {
<span class="p_del">-	int status;</span>
<span class="p_del">-</span>
 	edac_dbg(0, &quot;\n&quot;);
 
<span class="p_del">-	status = cancel_delayed_work(&amp;pci-&gt;work);</span>
<span class="p_del">-	if (status == 0)</span>
<span class="p_del">-		flush_workqueue(edac_workqueue);</span>
<span class="p_add">+	pci-&gt;op_state = OP_OFFLINE;</span>
<span class="p_add">+</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;pci-&gt;work);</span>
<span class="p_add">+	flush_workqueue(edac_workqueue);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_header">index 99f158e..e12f490 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_chunk">@@ -1757,6 +1757,7 @@</span> <span class="p_context"> int amdgpu_resume_kms(struct drm_device *dev, bool resume, bool fbcon)</span>
 	}
 
 	drm_kms_helper_poll_enable(dev);
<span class="p_add">+	drm_helper_hpd_irq_event(dev);</span>
 
 	if (fbcon) {
 		amdgpu_fbdev_set_suspend(adev, 0);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c</span>
<span class="p_header">index b07402f..453c00b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c</span>
<span class="p_chunk">@@ -954,15 +954,15 @@</span> <span class="p_context"> int amdgpu_vm_bo_map(struct amdgpu_device *adev,</span>
 	}
 
 	/* make sure object fit at this offset */
<span class="p_del">-	eaddr = saddr + size;</span>
<span class="p_add">+	eaddr = saddr + size - 1;</span>
 	if ((saddr &gt;= eaddr) || (offset + size &gt; amdgpu_bo_size(bo_va-&gt;bo))) {
 		amdgpu_bo_unreserve(bo_va-&gt;bo);
 		return -EINVAL;
 	}
 
 	last_pfn = eaddr / AMDGPU_GPU_PAGE_SIZE;
<span class="p_del">-	if (last_pfn &gt; adev-&gt;vm_manager.max_pfn) {</span>
<span class="p_del">-		dev_err(adev-&gt;dev, &quot;va above limit (0x%08X &gt; 0x%08X)\n&quot;,</span>
<span class="p_add">+	if (last_pfn &gt;= adev-&gt;vm_manager.max_pfn) {</span>
<span class="p_add">+		dev_err(adev-&gt;dev, &quot;va above limit (0x%08X &gt;= 0x%08X)\n&quot;,</span>
 			last_pfn, adev-&gt;vm_manager.max_pfn);
 		amdgpu_bo_unreserve(bo_va-&gt;bo);
 		return -EINVAL;
<span class="p_chunk">@@ -973,7 +973,7 @@</span> <span class="p_context"> int amdgpu_vm_bo_map(struct amdgpu_device *adev,</span>
 	saddr /= AMDGPU_GPU_PAGE_SIZE;
 	eaddr /= AMDGPU_GPU_PAGE_SIZE;
 
<span class="p_del">-	it = interval_tree_iter_first(&amp;vm-&gt;va, saddr, eaddr - 1);</span>
<span class="p_add">+	it = interval_tree_iter_first(&amp;vm-&gt;va, saddr, eaddr);</span>
 	if (it) {
 		struct amdgpu_bo_va_mapping *tmp;
 		tmp = container_of(it, struct amdgpu_bo_va_mapping, it);
<span class="p_chunk">@@ -995,7 +995,7 @@</span> <span class="p_context"> int amdgpu_vm_bo_map(struct amdgpu_device *adev,</span>
 
 	INIT_LIST_HEAD(&amp;mapping-&gt;list);
 	mapping-&gt;it.start = saddr;
<span class="p_del">-	mapping-&gt;it.last = eaddr - 1;</span>
<span class="p_add">+	mapping-&gt;it.last = eaddr;</span>
 	mapping-&gt;offset = offset;
 	mapping-&gt;flags = flags;
 
<span class="p_header">diff --git a/drivers/gpu/drm/drm_dp_mst_topology.c b/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_header">index 1f94219..3f8b30f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_chunk">@@ -973,17 +973,17 @@</span> <span class="p_context"> static struct drm_dp_mst_port *drm_dp_get_port(struct drm_dp_mst_branch *mstb, u</span>
 static u8 drm_dp_calculate_rad(struct drm_dp_mst_port *port,
 				 u8 *rad)
 {
<span class="p_del">-	int lct = port-&gt;parent-&gt;lct;</span>
<span class="p_add">+	int parent_lct = port-&gt;parent-&gt;lct;</span>
 	int shift = 4;
<span class="p_del">-	int idx = lct / 2;</span>
<span class="p_del">-	if (lct &gt; 1) {</span>
<span class="p_del">-		memcpy(rad, port-&gt;parent-&gt;rad, idx);</span>
<span class="p_del">-		shift = (lct % 2) ? 4 : 0;</span>
<span class="p_add">+	int idx = (parent_lct - 1) / 2;</span>
<span class="p_add">+	if (parent_lct &gt; 1) {</span>
<span class="p_add">+		memcpy(rad, port-&gt;parent-&gt;rad, idx + 1);</span>
<span class="p_add">+		shift = (parent_lct % 2) ? 4 : 0;</span>
 	} else
 		rad[0] = 0;
 
 	rad[idx] |= port-&gt;port_num &lt;&lt; shift;
<span class="p_del">-	return lct + 1;</span>
<span class="p_add">+	return parent_lct + 1;</span>
 }
 
 /*
<span class="p_chunk">@@ -1039,7 +1039,7 @@</span> <span class="p_context"> static void build_mst_prop_path(struct drm_dp_mst_port *port,</span>
 	snprintf(proppath, proppath_size, &quot;mst:%d&quot;, mstb-&gt;mgr-&gt;conn_base_id);
 	for (i = 0; i &lt; (mstb-&gt;lct - 1); i++) {
 		int shift = (i % 2) ? 0 : 4;
<span class="p_del">-		int port_num = mstb-&gt;rad[i / 2] &gt;&gt; shift;</span>
<span class="p_add">+		int port_num = (mstb-&gt;rad[i / 2] &gt;&gt; shift) &amp; 0xf;</span>
 		snprintf(temp, sizeof(temp), &quot;-%d&quot;, port_num);
 		strlcat(proppath, temp, proppath_size);
 	}
<span class="p_chunk">@@ -1189,7 +1189,7 @@</span> <span class="p_context"> static struct drm_dp_mst_branch *drm_dp_get_mst_branch_device(struct drm_dp_mst_</span>
 
 	for (i = 0; i &lt; lct - 1; i++) {
 		int shift = (i % 2) ? 0 : 4;
<span class="p_del">-		int port_num = rad[i / 2] &gt;&gt; shift;</span>
<span class="p_add">+		int port_num = (rad[i / 2] &gt;&gt; shift) &amp; 0xf;</span>
 
 		list_for_each_entry(port, &amp;mstb-&gt;ports, next) {
 			if (port-&gt;port_num == port_num) {
<span class="p_chunk">@@ -1209,6 +1209,50 @@</span> <span class="p_context"> out:</span>
 	return mstb;
 }
 
<span class="p_add">+static struct drm_dp_mst_branch *get_mst_branch_device_by_guid_helper(</span>
<span class="p_add">+	struct drm_dp_mst_branch *mstb,</span>
<span class="p_add">+	uint8_t *guid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_dp_mst_branch *found_mstb;</span>
<span class="p_add">+	struct drm_dp_mst_port *port;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(port, &amp;mstb-&gt;ports, next) {</span>
<span class="p_add">+		if (!port-&gt;mstb)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (port-&gt;guid_valid &amp;&amp; memcmp(port-&gt;guid, guid, 16) == 0)</span>
<span class="p_add">+			return port-&gt;mstb;</span>
<span class="p_add">+</span>
<span class="p_add">+		found_mstb = get_mst_branch_device_by_guid_helper(port-&gt;mstb, guid);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (found_mstb)</span>
<span class="p_add">+			return found_mstb;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct drm_dp_mst_branch *drm_dp_get_mst_branch_device_by_guid(</span>
<span class="p_add">+	struct drm_dp_mst_topology_mgr *mgr,</span>
<span class="p_add">+	uint8_t *guid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_dp_mst_branch *mstb;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* find the port by iterating down */</span>
<span class="p_add">+	mutex_lock(&amp;mgr-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mgr-&gt;guid_valid &amp;&amp; memcmp(mgr-&gt;guid, guid, 16) == 0)</span>
<span class="p_add">+		mstb = mgr-&gt;mst_primary;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		mstb = get_mst_branch_device_by_guid_helper(mgr-&gt;mst_primary, guid);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mstb)</span>
<span class="p_add">+		kref_get(&amp;mstb-&gt;kref);</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;mgr-&gt;lock);</span>
<span class="p_add">+	return mstb;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void drm_dp_check_and_send_link_address(struct drm_dp_mst_topology_mgr *mgr,
 					       struct drm_dp_mst_branch *mstb)
 {
<span class="p_chunk">@@ -1320,6 +1364,7 @@</span> <span class="p_context"> static int set_hdr_from_dst_qlock(struct drm_dp_sideband_msg_hdr *hdr,</span>
 				  struct drm_dp_sideband_msg_tx *txmsg)
 {
 	struct drm_dp_mst_branch *mstb = txmsg-&gt;dst;
<span class="p_add">+	u8 req_type;</span>
 
 	/* both msg slots are full */
 	if (txmsg-&gt;seqno == -1) {
<span class="p_chunk">@@ -1336,7 +1381,13 @@</span> <span class="p_context"> static int set_hdr_from_dst_qlock(struct drm_dp_sideband_msg_hdr *hdr,</span>
 			txmsg-&gt;seqno = 1;
 		mstb-&gt;tx_slots[txmsg-&gt;seqno] = txmsg;
 	}
<span class="p_del">-	hdr-&gt;broadcast = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	req_type = txmsg-&gt;msg[0] &amp; 0x7f;</span>
<span class="p_add">+	if (req_type == DP_CONNECTION_STATUS_NOTIFY ||</span>
<span class="p_add">+		req_type == DP_RESOURCE_STATUS_NOTIFY)</span>
<span class="p_add">+		hdr-&gt;broadcast = 1;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		hdr-&gt;broadcast = 0;</span>
 	hdr-&gt;path_msg = txmsg-&gt;path_msg;
 	hdr-&gt;lct = mstb-&gt;lct;
 	hdr-&gt;lcr = mstb-&gt;lct - 1;
<span class="p_chunk">@@ -1438,26 +1489,18 @@</span> <span class="p_context"> static void process_single_down_tx_qlock(struct drm_dp_mst_topology_mgr *mgr)</span>
 }
 
 /* called holding qlock */
<span class="p_del">-static void process_single_up_tx_qlock(struct drm_dp_mst_topology_mgr *mgr)</span>
<span class="p_add">+static void process_single_up_tx_qlock(struct drm_dp_mst_topology_mgr *mgr,</span>
<span class="p_add">+				       struct drm_dp_sideband_msg_tx *txmsg)</span>
 {
<span class="p_del">-	struct drm_dp_sideband_msg_tx *txmsg;</span>
 	int ret;
 
 	/* construct a chunk from the first msg in the tx_msg queue */
<span class="p_del">-	if (list_empty(&amp;mgr-&gt;tx_msg_upq)) {</span>
<span class="p_del">-		mgr-&gt;tx_up_in_progress = false;</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	txmsg = list_first_entry(&amp;mgr-&gt;tx_msg_upq, struct drm_dp_sideband_msg_tx, next);</span>
 	ret = process_single_tx_qlock(mgr, txmsg, true);
<span class="p_del">-	if (ret == 1) {</span>
<span class="p_del">-		/* up txmsgs aren&#39;t put in slots - so free after we send it */</span>
<span class="p_del">-		list_del(&amp;txmsg-&gt;next);</span>
<span class="p_del">-		kfree(txmsg);</span>
<span class="p_del">-	} else if (ret)</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret != 1)</span>
 		DRM_DEBUG_KMS(&quot;failed to send msg in q %d\n&quot;, ret);
<span class="p_del">-	mgr-&gt;tx_up_in_progress = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	txmsg-&gt;dst-&gt;tx_slots[txmsg-&gt;seqno] = NULL;</span>
 }
 
 static void drm_dp_queue_down_tx(struct drm_dp_mst_topology_mgr *mgr,
<span class="p_chunk">@@ -1842,11 +1885,12 @@</span> <span class="p_context"> static int drm_dp_send_up_ack_reply(struct drm_dp_mst_topology_mgr *mgr,</span>
 	drm_dp_encode_up_ack_reply(txmsg, req_type);
 
 	mutex_lock(&amp;mgr-&gt;qlock);
<span class="p_del">-	list_add_tail(&amp;txmsg-&gt;next, &amp;mgr-&gt;tx_msg_upq);</span>
<span class="p_del">-	if (!mgr-&gt;tx_up_in_progress) {</span>
<span class="p_del">-		process_single_up_tx_qlock(mgr);</span>
<span class="p_del">-	}</span>
<span class="p_add">+</span>
<span class="p_add">+	process_single_up_tx_qlock(mgr, txmsg);</span>
<span class="p_add">+</span>
 	mutex_unlock(&amp;mgr-&gt;qlock);
<span class="p_add">+</span>
<span class="p_add">+	kfree(txmsg);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -2143,28 +2187,50 @@</span> <span class="p_context"> static int drm_dp_mst_handle_up_req(struct drm_dp_mst_topology_mgr *mgr)</span>
 
 	if (mgr-&gt;up_req_recv.have_eomt) {
 		struct drm_dp_sideband_msg_req_body msg;
<span class="p_del">-		struct drm_dp_mst_branch *mstb;</span>
<span class="p_add">+		struct drm_dp_mst_branch *mstb = NULL;</span>
 		bool seqno;
<span class="p_del">-		mstb = drm_dp_get_mst_branch_device(mgr,</span>
<span class="p_del">-						    mgr-&gt;up_req_recv.initial_hdr.lct,</span>
<span class="p_del">-						    mgr-&gt;up_req_recv.initial_hdr.rad);</span>
<span class="p_del">-		if (!mstb) {</span>
<span class="p_del">-			DRM_DEBUG_KMS(&quot;Got MST reply from unknown device %d\n&quot;, mgr-&gt;up_req_recv.initial_hdr.lct);</span>
<span class="p_del">-			memset(&amp;mgr-&gt;up_req_recv, 0, sizeof(struct drm_dp_sideband_msg_rx));</span>
<span class="p_del">-			return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!mgr-&gt;up_req_recv.initial_hdr.broadcast) {</span>
<span class="p_add">+			mstb = drm_dp_get_mst_branch_device(mgr,</span>
<span class="p_add">+							    mgr-&gt;up_req_recv.initial_hdr.lct,</span>
<span class="p_add">+							    mgr-&gt;up_req_recv.initial_hdr.rad);</span>
<span class="p_add">+			if (!mstb) {</span>
<span class="p_add">+				DRM_DEBUG_KMS(&quot;Got MST reply from unknown device %d\n&quot;, mgr-&gt;up_req_recv.initial_hdr.lct);</span>
<span class="p_add">+				memset(&amp;mgr-&gt;up_req_recv, 0, sizeof(struct drm_dp_sideband_msg_rx));</span>
<span class="p_add">+				return 0;</span>
<span class="p_add">+			}</span>
 		}
 
 		seqno = mgr-&gt;up_req_recv.initial_hdr.seqno;
 		drm_dp_sideband_parse_req(&amp;mgr-&gt;up_req_recv, &amp;msg);
 
 		if (msg.req_type == DP_CONNECTION_STATUS_NOTIFY) {
<span class="p_del">-			drm_dp_send_up_ack_reply(mgr, mstb, msg.req_type, seqno, false);</span>
<span class="p_add">+			drm_dp_send_up_ack_reply(mgr, mgr-&gt;mst_primary, msg.req_type, seqno, false);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (!mstb)</span>
<span class="p_add">+				mstb = drm_dp_get_mst_branch_device_by_guid(mgr, msg.u.conn_stat.guid);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (!mstb) {</span>
<span class="p_add">+				DRM_DEBUG_KMS(&quot;Got MST reply from unknown device %d\n&quot;, mgr-&gt;up_req_recv.initial_hdr.lct);</span>
<span class="p_add">+				memset(&amp;mgr-&gt;up_req_recv, 0, sizeof(struct drm_dp_sideband_msg_rx));</span>
<span class="p_add">+				return 0;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			drm_dp_update_port(mstb, &amp;msg.u.conn_stat);
 			DRM_DEBUG_KMS(&quot;Got CSN: pn: %d ldps:%d ddps: %d mcs: %d ip: %d pdt: %d\n&quot;, msg.u.conn_stat.port_number, msg.u.conn_stat.legacy_device_plug_status, msg.u.conn_stat.displayport_device_plug_status, msg.u.conn_stat.message_capability_status, msg.u.conn_stat.input_port, msg.u.conn_stat.peer_device_type);
 			(*mgr-&gt;cbs-&gt;hotplug)(mgr);
 
 		} else if (msg.req_type == DP_RESOURCE_STATUS_NOTIFY) {
<span class="p_del">-			drm_dp_send_up_ack_reply(mgr, mstb, msg.req_type, seqno, false);</span>
<span class="p_add">+			drm_dp_send_up_ack_reply(mgr, mgr-&gt;mst_primary, msg.req_type, seqno, false);</span>
<span class="p_add">+			if (!mstb)</span>
<span class="p_add">+				mstb = drm_dp_get_mst_branch_device_by_guid(mgr, msg.u.resource_stat.guid);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (!mstb) {</span>
<span class="p_add">+				DRM_DEBUG_KMS(&quot;Got MST reply from unknown device %d\n&quot;, mgr-&gt;up_req_recv.initial_hdr.lct);</span>
<span class="p_add">+				memset(&amp;mgr-&gt;up_req_recv, 0, sizeof(struct drm_dp_sideband_msg_rx));</span>
<span class="p_add">+				return 0;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			DRM_DEBUG_KMS(&quot;Got RSN: pn: %d avail_pbn %d\n&quot;, msg.u.resource_stat.port_number, msg.u.resource_stat.available_pbn);
 		}
 
<span class="p_chunk">@@ -2724,7 +2790,6 @@</span> <span class="p_context"> int drm_dp_mst_topology_mgr_init(struct drm_dp_mst_topology_mgr *mgr,</span>
 	mutex_init(&amp;mgr-&gt;qlock);
 	mutex_init(&amp;mgr-&gt;payload_lock);
 	mutex_init(&amp;mgr-&gt;destroy_connector_lock);
<span class="p_del">-	INIT_LIST_HEAD(&amp;mgr-&gt;tx_msg_upq);</span>
 	INIT_LIST_HEAD(&amp;mgr-&gt;tx_msg_downq);
 	INIT_LIST_HEAD(&amp;mgr-&gt;destroy_connector_list);
 	INIT_WORK(&amp;mgr-&gt;work, drm_dp_mst_link_probe_work);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem_context.c b/drivers/gpu/drm/i915/i915_gem_context.c</span>
<span class="p_header">index 48afa77..2d96da6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem_context.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem_context.c</span>
<span class="p_chunk">@@ -317,6 +317,10 @@</span> <span class="p_context"> void i915_gem_context_reset(struct drm_device *dev)</span>
 			i915_gem_context_unreference(lctx);
 			ring-&gt;last_context = NULL;
 		}
<span class="p_add">+</span>
<span class="p_add">+		/* Force the GPU state to be reinitialised on enabling */</span>
<span class="p_add">+		if (ring-&gt;default_context)</span>
<span class="p_add">+			ring-&gt;default_context-&gt;legacy_hw_ctx.initialized = false;</span>
 	}
 }
 
<span class="p_chunk">@@ -685,7 +689,7 @@</span> <span class="p_context"> static int do_switch(struct intel_engine_cs *ring,</span>
 	if (ret)
 		goto unpin_out;
 
<span class="p_del">-	if (!to-&gt;legacy_hw_ctx.initialized) {</span>
<span class="p_add">+	if (!to-&gt;legacy_hw_ctx.initialized || i915_gem_context_is_default(to)) {</span>
 		hw_flags |= MI_RESTORE_INHIBIT;
 		/* NB: If we inhibit the restore, the context is not allowed to
 		 * die because future work may end up depending on valid address
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_irq.c b/drivers/gpu/drm/i915/i915_irq.c</span>
<span class="p_header">index 984e2fe..6a51bc6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_irq.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_irq.c</span>
<span class="p_chunk">@@ -4447,9 +4447,14 @@</span> <span class="p_context"> void intel_hpd_init(struct drm_i915_private *dev_priv)</span>
 	list_for_each_entry(connector, &amp;mode_config-&gt;connector_list, head) {
 		struct intel_connector *intel_connector = to_intel_connector(connector);
 		connector-&gt;polled = intel_connector-&gt;polled;
<span class="p_del">-		if (connector-&gt;encoder &amp;&amp; !connector-&gt;polled &amp;&amp; I915_HAS_HOTPLUG(dev) &amp;&amp; intel_connector-&gt;encoder-&gt;hpd_pin &gt; HPD_NONE)</span>
<span class="p_del">-			connector-&gt;polled = DRM_CONNECTOR_POLL_HPD;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* MST has a dynamic intel_connector-&gt;encoder and it&#39;s reprobing</span>
<span class="p_add">+		 * is all handled by the MST helpers. */</span>
 		if (intel_connector-&gt;mst_port)
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!connector-&gt;polled &amp;&amp; I915_HAS_HOTPLUG(dev) &amp;&amp;</span>
<span class="p_add">+		    intel_connector-&gt;encoder-&gt;hpd_pin &gt; HPD_NONE)</span>
 			connector-&gt;polled = DRM_CONNECTOR_POLL_HPD;
 	}
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index 05bf98d..8bd37dd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -9817,20 +9817,17 @@</span> <span class="p_context"> __intel_framebuffer_create(struct drm_device *dev,</span>
 	int ret;
 
 	intel_fb = kzalloc(sizeof(*intel_fb), GFP_KERNEL);
<span class="p_del">-	if (!intel_fb) {</span>
<span class="p_del">-		drm_gem_object_unreference(&amp;obj-&gt;base);</span>
<span class="p_add">+	if (!intel_fb)</span>
 		return ERR_PTR(-ENOMEM);
<span class="p_del">-	}</span>
 
 	ret = intel_framebuffer_init(dev, intel_fb, mode_cmd, obj);
 	if (ret)
 		goto err;
 
 	return &amp;intel_fb-&gt;base;
<span class="p_add">+</span>
 err:
<span class="p_del">-	drm_gem_object_unreference(&amp;obj-&gt;base);</span>
 	kfree(intel_fb);
<span class="p_del">-</span>
 	return ERR_PTR(ret);
 }
 
<span class="p_chunk">@@ -9870,6 +9867,7 @@</span> <span class="p_context"> intel_framebuffer_create_for_mode(struct drm_device *dev,</span>
 				  struct drm_display_mode *mode,
 				  int depth, int bpp)
 {
<span class="p_add">+	struct drm_framebuffer *fb;</span>
 	struct drm_i915_gem_object *obj;
 	struct drm_mode_fb_cmd2 mode_cmd = { 0 };
 
<span class="p_chunk">@@ -9884,7 +9882,11 @@</span> <span class="p_context"> intel_framebuffer_create_for_mode(struct drm_device *dev,</span>
 								bpp);
 	mode_cmd.pixel_format = drm_mode_legacy_fb_format(bpp, depth);
 
<span class="p_del">-	return intel_framebuffer_create(dev, &amp;mode_cmd, obj);</span>
<span class="p_add">+	fb = intel_framebuffer_create(dev, &amp;mode_cmd, obj);</span>
<span class="p_add">+	if (IS_ERR(fb))</span>
<span class="p_add">+		drm_gem_object_unreference_unlocked(&amp;obj-&gt;base);</span>
<span class="p_add">+</span>
<span class="p_add">+	return fb;</span>
 }
 
 static struct drm_framebuffer *
<span class="p_chunk">@@ -14267,6 +14269,7 @@</span> <span class="p_context"> intel_user_framebuffer_create(struct drm_device *dev,</span>
 			      struct drm_file *filp,
 			      struct drm_mode_fb_cmd2 *user_mode_cmd)
 {
<span class="p_add">+	struct drm_framebuffer *fb;</span>
 	struct drm_i915_gem_object *obj;
 	struct drm_mode_fb_cmd2 mode_cmd = *user_mode_cmd;
 
<span class="p_chunk">@@ -14275,7 +14278,11 @@</span> <span class="p_context"> intel_user_framebuffer_create(struct drm_device *dev,</span>
 	if (&amp;obj-&gt;base == NULL)
 		return ERR_PTR(-ENOENT);
 
<span class="p_del">-	return intel_framebuffer_create(dev, &amp;mode_cmd, obj);</span>
<span class="p_add">+	fb = intel_framebuffer_create(dev, &amp;mode_cmd, obj);</span>
<span class="p_add">+	if (IS_ERR(fb))</span>
<span class="p_add">+		drm_gem_object_unreference_unlocked(&amp;obj-&gt;base);</span>
<span class="p_add">+</span>
<span class="p_add">+	return fb;</span>
 }
 
 #ifndef CONFIG_DRM_I915_FBDEV
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.c b/drivers/gpu/drm/nouveau/nouveau_connector.c</span>
<span class="p_header">index 3162040..05490ef 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nouveau_connector.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nouveau_connector.c</span>
<span class="p_chunk">@@ -969,10 +969,13 @@</span> <span class="p_context"> nouveau_connector_hotplug(struct nvif_notify *notify)</span>
 
 		NV_DEBUG(drm, &quot;%splugged %s\n&quot;, plugged ? &quot;&quot; : &quot;un&quot;, name);
 
<span class="p_add">+		mutex_lock(&amp;drm-&gt;dev-&gt;mode_config.mutex);</span>
 		if (plugged)
 			drm_helper_connector_dpms(connector, DRM_MODE_DPMS_ON);
 		else
 			drm_helper_connector_dpms(connector, DRM_MODE_DPMS_OFF);
<span class="p_add">+		mutex_unlock(&amp;drm-&gt;dev-&gt;mode_config.mutex);</span>
<span class="p_add">+</span>
 		drm_helper_hpd_irq_event(connector-&gt;dev);
 	}
 
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/nv40.c</span>
<span class="p_header">index c630136..b4ad791 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/nv40.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/nv40.c</span>
<span class="p_chunk">@@ -265,7 +265,7 @@</span> <span class="p_context"> nv40_identify(struct nvkm_device *device)</span>
 		device-&gt;oclass[NVDEV_SUBDEV_CLK    ] = &amp;nv40_clk_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_THERM  ] = &amp;nv40_therm_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_DEVINIT] =  nv1a_devinit_oclass;
<span class="p_del">-		device-&gt;oclass[NVDEV_SUBDEV_MC     ] =  nv44_mc_oclass;</span>
<span class="p_add">+		device-&gt;oclass[NVDEV_SUBDEV_MC     ] =  nv4c_mc_oclass;</span>
 		device-&gt;oclass[NVDEV_SUBDEV_BUS    ] =  nv31_bus_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_TIMER  ] = &amp;nv04_timer_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_FB     ] =  nv46_fb_oclass;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/dce6_afmt.c b/drivers/gpu/drm/radeon/dce6_afmt.c</span>
<span class="p_header">index 44480c1..883dce6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/dce6_afmt.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/dce6_afmt.c</span>
<span class="p_chunk">@@ -282,6 +282,22 @@</span> <span class="p_context"> void dce6_dp_audio_set_dto(struct radeon_device *rdev,</span>
 	 * is the numerator, DCCG_AUDIO_DTOx_MODULE is the denominator
 	 */
 	if (ASIC_IS_DCE8(rdev)) {
<span class="p_add">+		unsigned int div = (RREG32(DENTIST_DISPCLK_CNTL) &amp;</span>
<span class="p_add">+			DENTIST_DPREFCLK_WDIVIDER_MASK) &gt;&gt;</span>
<span class="p_add">+			DENTIST_DPREFCLK_WDIVIDER_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (div &lt; 128 &amp;&amp; div &gt;= 96)</span>
<span class="p_add">+			div -= 64;</span>
<span class="p_add">+		else if (div &gt;= 64)</span>
<span class="p_add">+			div = div / 2 - 16;</span>
<span class="p_add">+		else if (div &gt;= 8)</span>
<span class="p_add">+			div /= 4;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			div = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (div)</span>
<span class="p_add">+			clock = rdev-&gt;clock.gpupll_outputfreq * 10 / div;</span>
<span class="p_add">+</span>
 		WREG32(DCE8_DCCG_AUDIO_DTO1_PHASE, 24000);
 		WREG32(DCE8_DCCG_AUDIO_DTO1_MODULE, clock);
 	} else {
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon.h b/drivers/gpu/drm/radeon/radeon.h</span>
<span class="p_header">index b6cbd81..f0b0b6f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon.h</span>
<span class="p_chunk">@@ -268,6 +268,7 @@</span> <span class="p_context"> struct radeon_clock {</span>
 	uint32_t current_dispclk;
 	uint32_t dp_extclk;
 	uint32_t max_pixel_clock;
<span class="p_add">+	uint32_t gpupll_outputfreq;</span>
 };
 
 /*
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_atombios.c b/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_header">index 8f28524..08fc1b5 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_chunk">@@ -437,7 +437,9 @@</span> <span class="p_context"> static bool radeon_atom_apply_quirks(struct drm_device *dev,</span>
 	}
 
 	/* Fujitsu D3003-S2 board lists DVI-I as DVI-D and VGA */
<span class="p_del">-	if (((dev-&gt;pdev-&gt;device == 0x9802) || (dev-&gt;pdev-&gt;device == 0x9806)) &amp;&amp;</span>
<span class="p_add">+	if (((dev-&gt;pdev-&gt;device == 0x9802) ||</span>
<span class="p_add">+	     (dev-&gt;pdev-&gt;device == 0x9805) ||</span>
<span class="p_add">+	     (dev-&gt;pdev-&gt;device == 0x9806)) &amp;&amp;</span>
 	    (dev-&gt;pdev-&gt;subsystem_vendor == 0x1734) &amp;&amp;
 	    (dev-&gt;pdev-&gt;subsystem_device == 0x11bd)) {
 		if (*connector_type == DRM_MODE_CONNECTOR_VGA) {
<span class="p_chunk">@@ -448,14 +450,6 @@</span> <span class="p_context"> static bool radeon_atom_apply_quirks(struct drm_device *dev,</span>
 		}
 	}
 
<span class="p_del">-	/* Fujitsu D3003-S2 board lists DVI-I as DVI-I and VGA */</span>
<span class="p_del">-	if ((dev-&gt;pdev-&gt;device == 0x9805) &amp;&amp;</span>
<span class="p_del">-	    (dev-&gt;pdev-&gt;subsystem_vendor == 0x1734) &amp;&amp;</span>
<span class="p_del">-	    (dev-&gt;pdev-&gt;subsystem_device == 0x11bd)) {</span>
<span class="p_del">-		if (*connector_type == DRM_MODE_CONNECTOR_VGA)</span>
<span class="p_del">-			return false;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	return true;
 }
 
<span class="p_chunk">@@ -1263,6 +1257,13 @@</span> <span class="p_context"> bool radeon_atom_get_clock_info(struct drm_device *dev)</span>
 		rdev-&gt;mode_info.firmware_flags =
 			le16_to_cpu(firmware_info-&gt;info.usFirmwareCapability.susAccess);
 
<span class="p_add">+		if (ASIC_IS_DCE8(rdev)) {</span>
<span class="p_add">+			rdev-&gt;clock.gpupll_outputfreq =</span>
<span class="p_add">+				le32_to_cpu(firmware_info-&gt;info_22.ulGPUPLL_OutputFreq);</span>
<span class="p_add">+			if (rdev-&gt;clock.gpupll_outputfreq == 0)</span>
<span class="p_add">+				rdev-&gt;clock.gpupll_outputfreq = 360000;	/* 3.6 GHz */</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		return true;
 	}
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_device.c b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">index d8319da..fa98309 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_chunk">@@ -1740,6 +1740,7 @@</span> <span class="p_context"> int radeon_resume_kms(struct drm_device *dev, bool resume, bool fbcon)</span>
 	}
 
 	drm_kms_helper_poll_enable(dev);
<span class="p_add">+	drm_helper_hpd_irq_event(dev);</span>
 
 	/* set the power state here in case we are a PX system or headless */
 	if ((rdev-&gt;pm.pm_method == PM_METHOD_DPM) &amp;&amp; rdev-&gt;pm.dpm_enabled)
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_vm.c b/drivers/gpu/drm/radeon/radeon_vm.c</span>
<span class="p_header">index 48d97c0..3979632 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_vm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_vm.c</span>
<span class="p_chunk">@@ -455,15 +455,15 @@</span> <span class="p_context"> int radeon_vm_bo_set_addr(struct radeon_device *rdev,</span>
 
 	if (soffset) {
 		/* make sure object fit at this offset */
<span class="p_del">-		eoffset = soffset + size;</span>
<span class="p_add">+		eoffset = soffset + size - 1;</span>
 		if (soffset &gt;= eoffset) {
 			r = -EINVAL;
 			goto error_unreserve;
 		}
 
 		last_pfn = eoffset / RADEON_GPU_PAGE_SIZE;
<span class="p_del">-		if (last_pfn &gt; rdev-&gt;vm_manager.max_pfn) {</span>
<span class="p_del">-			dev_err(rdev-&gt;dev, &quot;va above limit (0x%08X &gt; 0x%08X)\n&quot;,</span>
<span class="p_add">+		if (last_pfn &gt;= rdev-&gt;vm_manager.max_pfn) {</span>
<span class="p_add">+			dev_err(rdev-&gt;dev, &quot;va above limit (0x%08X &gt;= 0x%08X)\n&quot;,</span>
 				last_pfn, rdev-&gt;vm_manager.max_pfn);
 			r = -EINVAL;
 			goto error_unreserve;
<span class="p_chunk">@@ -478,7 +478,7 @@</span> <span class="p_context"> int radeon_vm_bo_set_addr(struct radeon_device *rdev,</span>
 	eoffset /= RADEON_GPU_PAGE_SIZE;
 	if (soffset || eoffset) {
 		struct interval_tree_node *it;
<span class="p_del">-		it = interval_tree_iter_first(&amp;vm-&gt;va, soffset, eoffset - 1);</span>
<span class="p_add">+		it = interval_tree_iter_first(&amp;vm-&gt;va, soffset, eoffset);</span>
 		if (it &amp;&amp; it != &amp;bo_va-&gt;it) {
 			struct radeon_bo_va *tmp;
 			tmp = container_of(it, struct radeon_bo_va, it);
<span class="p_chunk">@@ -518,7 +518,7 @@</span> <span class="p_context"> int radeon_vm_bo_set_addr(struct radeon_device *rdev,</span>
 	if (soffset || eoffset) {
 		spin_lock(&amp;vm-&gt;status_lock);
 		bo_va-&gt;it.start = soffset;
<span class="p_del">-		bo_va-&gt;it.last = eoffset - 1;</span>
<span class="p_add">+		bo_va-&gt;it.last = eoffset;</span>
 		list_add(&amp;bo_va-&gt;vm_status, &amp;vm-&gt;cleared);
 		spin_unlock(&amp;vm-&gt;status_lock);
 		interval_tree_insert(&amp;bo_va-&gt;it, &amp;vm-&gt;va);
<span class="p_chunk">@@ -888,7 +888,7 @@</span> <span class="p_context"> static void radeon_vm_fence_pts(struct radeon_vm *vm,</span>
 	unsigned i;
 
 	start &gt;&gt;= radeon_vm_block_size;
<span class="p_del">-	end &gt;&gt;= radeon_vm_block_size;</span>
<span class="p_add">+	end = (end - 1) &gt;&gt; radeon_vm_block_size;</span>
 
 	for (i = start; i &lt;= end; ++i)
 		radeon_bo_fence(vm-&gt;page_tables[i].bo, fence, true);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/sid.h b/drivers/gpu/drm/radeon/sid.h</span>
<span class="p_header">index 4c4a721..d1a7b58 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/sid.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/sid.h</span>
<span class="p_chunk">@@ -915,6 +915,11 @@</span> <span class="p_context"></span>
 #define DCCG_AUDIO_DTO1_PHASE                           0x05c0
 #define DCCG_AUDIO_DTO1_MODULE                          0x05c4
 
<span class="p_add">+#define DENTIST_DISPCLK_CNTL				0x0490</span>
<span class="p_add">+#	define DENTIST_DPREFCLK_WDIVIDER(x)		(((x) &amp; 0x7f) &lt;&lt; 24)</span>
<span class="p_add">+#	define DENTIST_DPREFCLK_WDIVIDER_MASK		(0x7f &lt;&lt; 24)</span>
<span class="p_add">+#	define DENTIST_DPREFCLK_WDIVIDER_SHIFT		24</span>
<span class="p_add">+</span>
 #define AFMT_AUDIO_SRC_CONTROL                          0x713c
 #define		AFMT_AUDIO_SRC_SELECT(x)		(((x) &amp; 7) &lt;&lt; 0)
 /* AFMT_AUDIO_SRC_SELECT
<span class="p_header">diff --git a/drivers/hv/channel.c b/drivers/hv/channel.c</span>
<span class="p_header">index 603ce97..cede914 100644</span>
<span class="p_header">--- a/drivers/hv/channel.c</span>
<span class="p_header">+++ b/drivers/hv/channel.c</span>
<span class="p_chunk">@@ -628,10 +628,19 @@</span> <span class="p_context"> int vmbus_sendpacket_ctl(struct vmbus_channel *channel, void *buffer,</span>
 	 *    on the ring. We will not signal if more data is
 	 *    to be placed.
 	 *
<span class="p_add">+	 * Based on the channel signal state, we will decide</span>
<span class="p_add">+	 * which signaling policy will be applied.</span>
<span class="p_add">+	 *</span>
 	 * If we cannot write to the ring-buffer; signal the host
 	 * even if we may not have written anything. This is a rare
 	 * enough condition that it should not matter.
 	 */
<span class="p_add">+</span>
<span class="p_add">+	if (channel-&gt;signal_policy)</span>
<span class="p_add">+		signal = true;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		kick_q = true;</span>
<span class="p_add">+</span>
 	if (((ret == 0) &amp;&amp; kick_q &amp;&amp; signal) || (ret))
 		vmbus_setevent(channel);
 
<span class="p_chunk">@@ -731,10 +740,19 @@</span> <span class="p_context"> int vmbus_sendpacket_pagebuffer_ctl(struct vmbus_channel *channel,</span>
 	 *    on the ring. We will not signal if more data is
 	 *    to be placed.
 	 *
<span class="p_add">+	 * Based on the channel signal state, we will decide</span>
<span class="p_add">+	 * which signaling policy will be applied.</span>
<span class="p_add">+	 *</span>
 	 * If we cannot write to the ring-buffer; signal the host
 	 * even if we may not have written anything. This is a rare
 	 * enough condition that it should not matter.
 	 */
<span class="p_add">+</span>
<span class="p_add">+	if (channel-&gt;signal_policy)</span>
<span class="p_add">+		signal = true;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		kick_q = true;</span>
<span class="p_add">+</span>
 	if (((ret == 0) &amp;&amp; kick_q &amp;&amp; signal) || (ret))
 		vmbus_setevent(channel);
 
<span class="p_header">diff --git a/drivers/hv/hv_utils_transport.c b/drivers/hv/hv_utils_transport.c</span>
<span class="p_header">index 6a9d80a..24b2766 100644</span>
<span class="p_header">--- a/drivers/hv/hv_utils_transport.c</span>
<span class="p_header">+++ b/drivers/hv/hv_utils_transport.c</span>
<span class="p_chunk">@@ -80,11 +80,10 @@</span> <span class="p_context"> static ssize_t hvt_op_write(struct file *file, const char __user *buf,</span>
 
 	hvt = container_of(file-&gt;f_op, struct hvutil_transport, fops);
 
<span class="p_del">-	inmsg = kzalloc(count, GFP_KERNEL);</span>
<span class="p_del">-	if (copy_from_user(inmsg, buf, count)) {</span>
<span class="p_del">-		kfree(inmsg);</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	inmsg = memdup_user(buf, count);</span>
<span class="p_add">+	if (IS_ERR(inmsg))</span>
<span class="p_add">+		return PTR_ERR(inmsg);</span>
<span class="p_add">+</span>
 	if (hvt-&gt;on_msg(inmsg, count))
 		return -EFAULT;
 	kfree(inmsg);
<span class="p_chunk">@@ -204,9 +203,12 @@</span> <span class="p_context"> int hvutil_transport_send(struct hvutil_transport *hvt, void *msg, int len)</span>
 		goto out_unlock;
 	}
 	hvt-&gt;outmsg = kzalloc(len, GFP_KERNEL);
<span class="p_del">-	memcpy(hvt-&gt;outmsg, msg, len);</span>
<span class="p_del">-	hvt-&gt;outmsg_len = len;</span>
<span class="p_del">-	wake_up_interruptible(&amp;hvt-&gt;outmsg_q);</span>
<span class="p_add">+	if (hvt-&gt;outmsg) {</span>
<span class="p_add">+		memcpy(hvt-&gt;outmsg, msg, len);</span>
<span class="p_add">+		hvt-&gt;outmsg_len = len;</span>
<span class="p_add">+		wake_up_interruptible(&amp;hvt-&gt;outmsg_q);</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		ret = -ENOMEM;</span>
 out_unlock:
 	mutex_unlock(&amp;hvt-&gt;outmsg_lock);
 	return ret;
<span class="p_header">diff --git a/drivers/hwtracing/coresight/coresight.c b/drivers/hwtracing/coresight/coresight.c</span>
<span class="p_header">index 894531d..046144f 100644</span>
<span class="p_header">--- a/drivers/hwtracing/coresight/coresight.c</span>
<span class="p_header">+++ b/drivers/hwtracing/coresight/coresight.c</span>
<span class="p_chunk">@@ -543,7 +543,7 @@</span> <span class="p_context"> static int coresight_name_match(struct device *dev, void *data)</span>
 	to_match = data;
 	i_csdev = to_coresight_device(dev);
 
<span class="p_del">-	if (!strcmp(to_match, dev_name(&amp;i_csdev-&gt;dev)))</span>
<span class="p_add">+	if (to_match &amp;&amp; !strcmp(to_match, dev_name(&amp;i_csdev-&gt;dev)))</span>
 		return 1;
 
 	return 0;
<span class="p_header">diff --git a/drivers/infiniband/core/cm.c b/drivers/infiniband/core/cm.c</span>
<span class="p_header">index 8be7352..27919bb 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/cm.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/cm.c</span>
<span class="p_chunk">@@ -826,11 +826,11 @@</span> <span class="p_context"> static void cm_enter_timewait(struct cm_id_private *cm_id_priv)</span>
 	wait_time = cm_convert_to_ms(cm_id_priv-&gt;av.timeout);
 
 	/* Check if the device started its remove_one */
<span class="p_del">-	spin_lock_irq(&amp;cm.lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;cm.lock, flags);</span>
 	if (!cm_dev-&gt;going_down)
 		queue_delayed_work(cm.wq, &amp;cm_id_priv-&gt;timewait_info-&gt;work.work,
 				   msecs_to_jiffies(wait_time));
<span class="p_del">-	spin_unlock_irq(&amp;cm.lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;cm.lock, flags);</span>
 
 	cm_id_priv-&gt;timewait_info = NULL;
 }
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/ah.c b/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_header">index 33fdd50..de1a28d 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_chunk">@@ -91,6 +91,7 @@</span> <span class="p_context"> static struct ib_ah *create_iboe_ah(struct ib_pd *pd, struct ib_ah_attr *ah_attr</span>
 	ah-&gt;av.eth.port_pd = cpu_to_be32(to_mpd(pd)-&gt;pdn | (ah_attr-&gt;port_num &lt;&lt; 24));
 	ah-&gt;av.eth.gid_index = ah_attr-&gt;grh.sgid_index;
 	ah-&gt;av.eth.vlan = cpu_to_be16(vlan_tag);
<span class="p_add">+	ah-&gt;av.eth.hop_limit = ah_attr-&gt;grh.hop_limit;</span>
 	if (ah_attr-&gt;static_rate) {
 		ah-&gt;av.eth.stat_rate = ah_attr-&gt;static_rate + MLX4_STAT_RATE_OFFSET;
 		while (ah-&gt;av.eth.stat_rate &gt; IB_RATE_2_5_GBPS + MLX4_STAT_RATE_OFFSET &amp;&amp;
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">index 085c24b..aa64c7b 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_chunk">@@ -274,7 +274,7 @@</span> <span class="p_context"> static int mlx5_ib_query_device(struct ib_device *ibdev,</span>
 		     sizeof(struct mlx5_wqe_data_seg);
 	props-&gt;max_sge = min(max_rq_sg, max_sq_sg);
 	props-&gt;max_cq		   = 1 &lt;&lt; MLX5_CAP_GEN(mdev, log_max_cq);
<span class="p_del">-	props-&gt;max_cqe = (1 &lt;&lt; MLX5_CAP_GEN(mdev, log_max_eq_sz)) - 1;</span>
<span class="p_add">+	props-&gt;max_cqe = (1 &lt;&lt; MLX5_CAP_GEN(mdev, log_max_cq_sz)) - 1;</span>
 	props-&gt;max_mr		   = 1 &lt;&lt; MLX5_CAP_GEN(mdev, log_max_mkey);
 	props-&gt;max_pd		   = 1 &lt;&lt; MLX5_CAP_GEN(mdev, log_max_pd);
 	props-&gt;max_qp_rd_atom	   = 1 &lt;&lt; MLX5_CAP_GEN(mdev, log_max_ra_req_qp);
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_qp.c b/drivers/infiniband/hw/qib/qib_qp.c</span>
<span class="p_header">index 4fa88ba..1319943 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_qp.c</span>
<span class="p_chunk">@@ -100,9 +100,10 @@</span> <span class="p_context"> static u32 credit_table[31] = {</span>
 	32768                   /* 1E */
 };
 
<span class="p_del">-static void get_map_page(struct qib_qpn_table *qpt, struct qpn_map *map)</span>
<span class="p_add">+static void get_map_page(struct qib_qpn_table *qpt, struct qpn_map *map,</span>
<span class="p_add">+			 gfp_t gfp)</span>
 {
<span class="p_del">-	unsigned long page = get_zeroed_page(GFP_KERNEL);</span>
<span class="p_add">+	unsigned long page = get_zeroed_page(gfp);</span>
 
 	/*
 	 * Free the page if someone raced with us installing it.
<span class="p_chunk">@@ -121,7 +122,7 @@</span> <span class="p_context"> static void get_map_page(struct qib_qpn_table *qpt, struct qpn_map *map)</span>
  * zero/one for QP type IB_QPT_SMI/IB_QPT_GSI.
  */
 static int alloc_qpn(struct qib_devdata *dd, struct qib_qpn_table *qpt,
<span class="p_del">-		     enum ib_qp_type type, u8 port)</span>
<span class="p_add">+		     enum ib_qp_type type, u8 port, gfp_t gfp)</span>
 {
 	u32 i, offset, max_scan, qpn;
 	struct qpn_map *map;
<span class="p_chunk">@@ -151,7 +152,7 @@</span> <span class="p_context"> static int alloc_qpn(struct qib_devdata *dd, struct qib_qpn_table *qpt,</span>
 	max_scan = qpt-&gt;nmaps - !offset;
 	for (i = 0;;) {
 		if (unlikely(!map-&gt;page)) {
<span class="p_del">-			get_map_page(qpt, map);</span>
<span class="p_add">+			get_map_page(qpt, map, gfp);</span>
 			if (unlikely(!map-&gt;page))
 				break;
 		}
<span class="p_chunk">@@ -983,13 +984,21 @@</span> <span class="p_context"> struct ib_qp *qib_create_qp(struct ib_pd *ibpd,</span>
 	size_t sz;
 	size_t sg_list_sz;
 	struct ib_qp *ret;
<span class="p_add">+	gfp_t gfp;</span>
<span class="p_add">+</span>
 
 	if (init_attr-&gt;cap.max_send_sge &gt; ib_qib_max_sges ||
 	    init_attr-&gt;cap.max_send_wr &gt; ib_qib_max_qp_wrs ||
<span class="p_del">-	    init_attr-&gt;create_flags) {</span>
<span class="p_del">-		ret = ERR_PTR(-EINVAL);</span>
<span class="p_del">-		goto bail;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	    init_attr-&gt;create_flags &amp; ~(IB_QP_CREATE_USE_GFP_NOIO))</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* GFP_NOIO is applicable in RC QPs only */</span>
<span class="p_add">+	if (init_attr-&gt;create_flags &amp; IB_QP_CREATE_USE_GFP_NOIO &amp;&amp;</span>
<span class="p_add">+	    init_attr-&gt;qp_type != IB_QPT_RC)</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
<span class="p_add">+	gfp = init_attr-&gt;create_flags &amp; IB_QP_CREATE_USE_GFP_NOIO ?</span>
<span class="p_add">+			GFP_NOIO : GFP_KERNEL;</span>
 
 	/* Check receive queue parameters if no SRQ is specified. */
 	if (!init_attr-&gt;srq) {
<span class="p_chunk">@@ -1021,7 +1030,8 @@</span> <span class="p_context"> struct ib_qp *qib_create_qp(struct ib_pd *ibpd,</span>
 		sz = sizeof(struct qib_sge) *
 			init_attr-&gt;cap.max_send_sge +
 			sizeof(struct qib_swqe);
<span class="p_del">-		swq = vmalloc((init_attr-&gt;cap.max_send_wr + 1) * sz);</span>
<span class="p_add">+		swq = __vmalloc((init_attr-&gt;cap.max_send_wr + 1) * sz,</span>
<span class="p_add">+				gfp, PAGE_KERNEL);</span>
 		if (swq == NULL) {
 			ret = ERR_PTR(-ENOMEM);
 			goto bail;
<span class="p_chunk">@@ -1037,13 +1047,13 @@</span> <span class="p_context"> struct ib_qp *qib_create_qp(struct ib_pd *ibpd,</span>
 		} else if (init_attr-&gt;cap.max_recv_sge &gt; 1)
 			sg_list_sz = sizeof(*qp-&gt;r_sg_list) *
 				(init_attr-&gt;cap.max_recv_sge - 1);
<span class="p_del">-		qp = kzalloc(sz + sg_list_sz, GFP_KERNEL);</span>
<span class="p_add">+		qp = kzalloc(sz + sg_list_sz, gfp);</span>
 		if (!qp) {
 			ret = ERR_PTR(-ENOMEM);
 			goto bail_swq;
 		}
 		RCU_INIT_POINTER(qp-&gt;next, NULL);
<span class="p_del">-		qp-&gt;s_hdr = kzalloc(sizeof(*qp-&gt;s_hdr), GFP_KERNEL);</span>
<span class="p_add">+		qp-&gt;s_hdr = kzalloc(sizeof(*qp-&gt;s_hdr), gfp);</span>
 		if (!qp-&gt;s_hdr) {
 			ret = ERR_PTR(-ENOMEM);
 			goto bail_qp;
<span class="p_chunk">@@ -1058,8 +1068,16 @@</span> <span class="p_context"> struct ib_qp *qib_create_qp(struct ib_pd *ibpd,</span>
 			qp-&gt;r_rq.max_sge = init_attr-&gt;cap.max_recv_sge;
 			sz = (sizeof(struct ib_sge) * qp-&gt;r_rq.max_sge) +
 				sizeof(struct qib_rwqe);
<span class="p_del">-			qp-&gt;r_rq.wq = vmalloc_user(sizeof(struct qib_rwq) +</span>
<span class="p_del">-						   qp-&gt;r_rq.size * sz);</span>
<span class="p_add">+			if (gfp != GFP_NOIO)</span>
<span class="p_add">+				qp-&gt;r_rq.wq = vmalloc_user(</span>
<span class="p_add">+						sizeof(struct qib_rwq) +</span>
<span class="p_add">+						qp-&gt;r_rq.size * sz);</span>
<span class="p_add">+			else</span>
<span class="p_add">+				qp-&gt;r_rq.wq = __vmalloc(</span>
<span class="p_add">+						sizeof(struct qib_rwq) +</span>
<span class="p_add">+						qp-&gt;r_rq.size * sz,</span>
<span class="p_add">+						gfp, PAGE_KERNEL);</span>
<span class="p_add">+</span>
 			if (!qp-&gt;r_rq.wq) {
 				ret = ERR_PTR(-ENOMEM);
 				goto bail_qp;
<span class="p_chunk">@@ -1090,7 +1108,7 @@</span> <span class="p_context"> struct ib_qp *qib_create_qp(struct ib_pd *ibpd,</span>
 		dev = to_idev(ibpd-&gt;device);
 		dd = dd_from_dev(dev);
 		err = alloc_qpn(dd, &amp;dev-&gt;qpn_table, init_attr-&gt;qp_type,
<span class="p_del">-				init_attr-&gt;port_num);</span>
<span class="p_add">+				init_attr-&gt;port_num, gfp);</span>
 		if (err &lt; 0) {
 			ret = ERR_PTR(err);
 			vfree(qp-&gt;r_rq.wq);
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_verbs_mcast.c b/drivers/infiniband/hw/qib/qib_verbs_mcast.c</span>
<span class="p_header">index f8ea069..b2fb528 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_verbs_mcast.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_verbs_mcast.c</span>
<span class="p_chunk">@@ -286,15 +286,13 @@</span> <span class="p_context"> int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)</span>
 	struct qib_ibdev *dev = to_idev(ibqp-&gt;device);
 	struct qib_ibport *ibp = to_iport(ibqp-&gt;device, qp-&gt;port_num);
 	struct qib_mcast *mcast = NULL;
<span class="p_del">-	struct qib_mcast_qp *p, *tmp;</span>
<span class="p_add">+	struct qib_mcast_qp *p, *tmp, *delp = NULL;</span>
 	struct rb_node *n;
 	int last = 0;
 	int ret;
 
<span class="p_del">-	if (ibqp-&gt;qp_num &lt;= 1 || qp-&gt;state == IB_QPS_RESET) {</span>
<span class="p_del">-		ret = -EINVAL;</span>
<span class="p_del">-		goto bail;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (ibqp-&gt;qp_num &lt;= 1 || qp-&gt;state == IB_QPS_RESET)</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	spin_lock_irq(&amp;ibp-&gt;lock);
 
<span class="p_chunk">@@ -303,8 +301,7 @@</span> <span class="p_context"> int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)</span>
 	while (1) {
 		if (n == NULL) {
 			spin_unlock_irq(&amp;ibp-&gt;lock);
<span class="p_del">-			ret = -EINVAL;</span>
<span class="p_del">-			goto bail;</span>
<span class="p_add">+			return -EINVAL;</span>
 		}
 
 		mcast = rb_entry(n, struct qib_mcast, rb_node);
<span class="p_chunk">@@ -328,6 +325,7 @@</span> <span class="p_context"> int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)</span>
 		 */
 		list_del_rcu(&amp;p-&gt;list);
 		mcast-&gt;n_attached--;
<span class="p_add">+		delp = p;</span>
 
 		/* If this was the last attached QP, remove the GID too. */
 		if (list_empty(&amp;mcast-&gt;qp_list)) {
<span class="p_chunk">@@ -338,15 +336,16 @@</span> <span class="p_context"> int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)</span>
 	}
 
 	spin_unlock_irq(&amp;ibp-&gt;lock);
<span class="p_add">+	/* QP not attached */</span>
<span class="p_add">+	if (!delp)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Wait for any list walkers to finish before freeing the</span>
<span class="p_add">+	 * list element.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	wait_event(mcast-&gt;wait, atomic_read(&amp;mcast-&gt;refcount) &lt;= 1);</span>
<span class="p_add">+	qib_mcast_qp_free(delp);</span>
 
<span class="p_del">-	if (p) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Wait for any list walkers to finish before freeing the</span>
<span class="p_del">-		 * list element.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		wait_event(mcast-&gt;wait, atomic_read(&amp;mcast-&gt;refcount) &lt;= 1);</span>
<span class="p_del">-		qib_mcast_qp_free(p);</span>
<span class="p_del">-	}</span>
 	if (last) {
 		atomic_dec(&amp;mcast-&gt;refcount);
 		wait_event(mcast-&gt;wait, !atomic_read(&amp;mcast-&gt;refcount));
<span class="p_chunk">@@ -355,11 +354,7 @@</span> <span class="p_context"> int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)</span>
 		dev-&gt;n_mcast_grps_allocated--;
 		spin_unlock_irq(&amp;dev-&gt;n_mcast_grps_lock);
 	}
<span class="p_del">-</span>
<span class="p_del">-	ret = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-bail:</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return 0;</span>
 }
 
 int qib_mcast_tree_empty(struct qib_ibport *ibp)
<span class="p_header">diff --git a/drivers/input/mouse/elantech.c b/drivers/input/mouse/elantech.c</span>
<span class="p_header">index 537ebb0..78f93cf 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.c</span>
<span class="p_chunk">@@ -1222,7 +1222,7 @@</span> <span class="p_context"> static int elantech_set_input_params(struct psmouse *psmouse)</span>
 			input_set_abs_params(dev, ABS_TOOL_WIDTH, ETP_WMIN_V2,
 					     ETP_WMAX_V2, 0, 0);
 		}
<span class="p_del">-		input_mt_init_slots(dev, 2, 0);</span>
<span class="p_add">+		input_mt_init_slots(dev, 2, INPUT_MT_SEMI_MT);</span>
 		input_set_abs_params(dev, ABS_MT_POSITION_X, x_min, x_max, 0, 0);
 		input_set_abs_params(dev, ABS_MT_POSITION_Y, y_min, y_max, 0, 0);
 		break;
<span class="p_header">diff --git a/drivers/input/serio/i8042-x86ia64io.h b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">index c115565..68f5f4a 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_chunk">@@ -258,6 +258,13 @@</span> <span class="p_context"> static const struct dmi_system_id __initconst i8042_dmi_nomux_table[] = {</span>
 		},
 	},
 	{
<span class="p_add">+		/* Fujitsu Lifebook U745 */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;LIFEBOOK U745&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		/* Fujitsu T70H */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),
<span class="p_header">diff --git a/drivers/iommu/io-pgtable-arm.c b/drivers/iommu/io-pgtable-arm.c</span>
<span class="p_header">index e29d5d7..937832c 100644</span>
<span class="p_header">--- a/drivers/iommu/io-pgtable-arm.c</span>
<span class="p_header">+++ b/drivers/iommu/io-pgtable-arm.c</span>
<span class="p_chunk">@@ -341,17 +341,18 @@</span> <span class="p_context"> static void __arm_lpae_free_pgtable(struct arm_lpae_io_pgtable *data, int lvl,</span>
 	arm_lpae_iopte *start, *end;
 	unsigned long table_size;
 
<span class="p_del">-	/* Only leaf entries at the last level */</span>
<span class="p_del">-	if (lvl == ARM_LPAE_MAX_LEVELS - 1)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	if (lvl == ARM_LPAE_START_LVL(data))
 		table_size = data-&gt;pgd_size;
 	else
 		table_size = 1UL &lt;&lt; data-&gt;pg_shift;
 
 	start = ptep;
<span class="p_del">-	end = (void *)ptep + table_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Only leaf entries at the last level */</span>
<span class="p_add">+	if (lvl == ARM_LPAE_MAX_LEVELS - 1)</span>
<span class="p_add">+		end = ptep;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		end = (void *)ptep + table_size;</span>
 
 	while (ptep != end) {
 		arm_lpae_iopte pte = *ptep++;
<span class="p_header">diff --git a/drivers/md/bcache/btree.c b/drivers/md/bcache/btree.c</span>
<span class="p_header">index 00cde40..43829d9 100644</span>
<span class="p_header">--- a/drivers/md/bcache/btree.c</span>
<span class="p_header">+++ b/drivers/md/bcache/btree.c</span>
<span class="p_chunk">@@ -1741,6 +1741,7 @@</span> <span class="p_context"> static void bch_btree_gc(struct cache_set *c)</span>
 	do {
 		ret = btree_root(gc_root, c, &amp;op, &amp;writes, &amp;stats);
 		closure_sync(&amp;writes);
<span class="p_add">+		cond_resched();</span>
 
 		if (ret &amp;&amp; ret != -EAGAIN)
 			pr_warn(&quot;gc failed!&quot;);
<span class="p_chunk">@@ -2162,8 +2163,10 @@</span> <span class="p_context"> int bch_btree_insert_check_key(struct btree *b, struct btree_op *op,</span>
 		rw_lock(true, b, b-&gt;level);
 
 		if (b-&gt;key.ptr[0] != btree_ptr ||
<span class="p_del">-		    b-&gt;seq != seq + 1)</span>
<span class="p_add">+                   b-&gt;seq != seq + 1) {</span>
<span class="p_add">+                       op-&gt;lock = b-&gt;level;</span>
 			goto out;
<span class="p_add">+               }</span>
 	}
 
 	SET_KEY_PTRS(check_key, 1);
<span class="p_header">diff --git a/drivers/md/bcache/super.c b/drivers/md/bcache/super.c</span>
<span class="p_header">index 94980bf..90bd95b 100644</span>
<span class="p_header">--- a/drivers/md/bcache/super.c</span>
<span class="p_header">+++ b/drivers/md/bcache/super.c</span>
<span class="p_chunk">@@ -708,6 +708,8 @@</span> <span class="p_context"> static void bcache_device_link(struct bcache_device *d, struct cache_set *c,</span>
 	WARN(sysfs_create_link(&amp;d-&gt;kobj, &amp;c-&gt;kobj, &quot;cache&quot;) ||
 	     sysfs_create_link(&amp;c-&gt;kobj, &amp;d-&gt;kobj, d-&gt;name),
 	     &quot;Couldn&#39;t create device &lt;-&gt; cache set symlinks&quot;);
<span class="p_add">+</span>
<span class="p_add">+	clear_bit(BCACHE_DEV_UNLINK_DONE, &amp;d-&gt;flags);</span>
 }
 
 static void bcache_device_detach(struct bcache_device *d)
<span class="p_chunk">@@ -872,8 +874,11 @@</span> <span class="p_context"> void bch_cached_dev_run(struct cached_dev *dc)</span>
 	buf[SB_LABEL_SIZE] = &#39;\0&#39;;
 	env[2] = kasprintf(GFP_KERNEL, &quot;CACHED_LABEL=%s&quot;, buf);
 
<span class="p_del">-	if (atomic_xchg(&amp;dc-&gt;running, 1))</span>
<span class="p_add">+	if (atomic_xchg(&amp;dc-&gt;running, 1)) {</span>
<span class="p_add">+		kfree(env[1]);</span>
<span class="p_add">+		kfree(env[2]);</span>
 		return;
<span class="p_add">+	}</span>
 
 	if (!d-&gt;c &amp;&amp;
 	    BDEV_STATE(&amp;dc-&gt;sb) != BDEV_STATE_NONE) {
<span class="p_chunk">@@ -1961,6 +1966,8 @@</span> <span class="p_context"> static ssize_t register_bcache(struct kobject *k, struct kobj_attribute *attr,</span>
 			else
 				err = &quot;device busy&quot;;
 			mutex_unlock(&amp;bch_register_lock);
<span class="p_add">+			if (attr == &amp;ksysfs_register_quiet)</span>
<span class="p_add">+				goto out;</span>
 		}
 		goto err;
 	}
<span class="p_chunk">@@ -1999,8 +2006,7 @@</span> <span class="p_context"> out:</span>
 err_close:
 	blkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);
 err:
<span class="p_del">-	if (attr != &amp;ksysfs_register_quiet)</span>
<span class="p_del">-		pr_info(&quot;error opening %s: %s&quot;, path, err);</span>
<span class="p_add">+	pr_info(&quot;error opening %s: %s&quot;, path, err);</span>
 	ret = -EINVAL;
 	goto out;
 }
<span class="p_chunk">@@ -2094,8 +2100,10 @@</span> <span class="p_context"> static int __init bcache_init(void)</span>
 	closure_debug_init();
 
 	bcache_major = register_blkdev(0, &quot;bcache&quot;);
<span class="p_del">-	if (bcache_major &lt; 0)</span>
<span class="p_add">+	if (bcache_major &lt; 0) {</span>
<span class="p_add">+		unregister_reboot_notifier(&amp;reboot);</span>
 		return bcache_major;
<span class="p_add">+	}</span>
 
 	if (!(bcache_wq = create_workqueue(&quot;bcache&quot;)) ||
 	    !(bcache_kobj = kobject_create_and_add(&quot;bcache&quot;, fs_kobj)) ||
<span class="p_header">diff --git a/drivers/md/bcache/writeback.c b/drivers/md/bcache/writeback.c</span>
<span class="p_header">index f1986bc..540256a 100644</span>
<span class="p_header">--- a/drivers/md/bcache/writeback.c</span>
<span class="p_header">+++ b/drivers/md/bcache/writeback.c</span>
<span class="p_chunk">@@ -323,6 +323,10 @@</span> <span class="p_context"> void bcache_dev_sectors_dirty_add(struct cache_set *c, unsigned inode,</span>
 
 static bool dirty_pred(struct keybuf *buf, struct bkey *k)
 {
<span class="p_add">+	struct cached_dev *dc = container_of(buf, struct cached_dev, writeback_keys);</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(KEY_INODE(k) != dc-&gt;disk.id);</span>
<span class="p_add">+</span>
 	return KEY_DIRTY(k);
 }
 
<span class="p_chunk">@@ -372,11 +376,24 @@</span> <span class="p_context"> next:</span>
 	}
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Returns true if we scanned the entire disk</span>
<span class="p_add">+ */</span>
 static bool refill_dirty(struct cached_dev *dc)
 {
 	struct keybuf *buf = &amp;dc-&gt;writeback_keys;
<span class="p_add">+	struct bkey start = KEY(dc-&gt;disk.id, 0, 0);</span>
 	struct bkey end = KEY(dc-&gt;disk.id, MAX_KEY_OFFSET, 0);
<span class="p_del">-	bool searched_from_start = false;</span>
<span class="p_add">+	struct bkey start_pos;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * make sure keybuf pos is inside the range for this disk - at bringup</span>
<span class="p_add">+	 * we might not be attached yet so this disk&#39;s inode nr isn&#39;t</span>
<span class="p_add">+	 * initialized then</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (bkey_cmp(&amp;buf-&gt;last_scanned, &amp;start) &lt; 0 ||</span>
<span class="p_add">+	    bkey_cmp(&amp;buf-&gt;last_scanned, &amp;end) &gt; 0)</span>
<span class="p_add">+		buf-&gt;last_scanned = start;</span>
 
 	if (dc-&gt;partial_stripes_expensive) {
 		refill_full_stripes(dc);
<span class="p_chunk">@@ -384,14 +401,20 @@</span> <span class="p_context"> static bool refill_dirty(struct cached_dev *dc)</span>
 			return false;
 	}
 
<span class="p_del">-	if (bkey_cmp(&amp;buf-&gt;last_scanned, &amp;end) &gt;= 0) {</span>
<span class="p_del">-		buf-&gt;last_scanned = KEY(dc-&gt;disk.id, 0, 0);</span>
<span class="p_del">-		searched_from_start = true;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_add">+	start_pos = buf-&gt;last_scanned;</span>
 	bch_refill_keybuf(dc-&gt;disk.c, buf, &amp;end, dirty_pred);
 
<span class="p_del">-	return bkey_cmp(&amp;buf-&gt;last_scanned, &amp;end) &gt;= 0 &amp;&amp; searched_from_start;</span>
<span class="p_add">+	if (bkey_cmp(&amp;buf-&gt;last_scanned, &amp;end) &lt; 0)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we get to the end start scanning again from the beginning, and</span>
<span class="p_add">+	 * only scan up to where we initially started scanning from:</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	buf-&gt;last_scanned = start;</span>
<span class="p_add">+	bch_refill_keybuf(dc-&gt;disk.c, buf, &amp;start_pos, dirty_pred);</span>
<span class="p_add">+</span>
<span class="p_add">+	return bkey_cmp(&amp;buf-&gt;last_scanned, &amp;start_pos) &gt;= 0;</span>
 }
 
 static int bch_writeback_thread(void *arg)
<span class="p_header">diff --git a/drivers/md/bcache/writeback.h b/drivers/md/bcache/writeback.h</span>
<span class="p_header">index 0a9dab1..073a042 100644</span>
<span class="p_header">--- a/drivers/md/bcache/writeback.h</span>
<span class="p_header">+++ b/drivers/md/bcache/writeback.h</span>
<span class="p_chunk">@@ -63,7 +63,8 @@</span> <span class="p_context"> static inline bool should_writeback(struct cached_dev *dc, struct bio *bio,</span>
 
 static inline void bch_writeback_queue(struct cached_dev *dc)
 {
<span class="p_del">-	wake_up_process(dc-&gt;writeback_thread);</span>
<span class="p_add">+	if (!IS_ERR_OR_NULL(dc-&gt;writeback_thread))</span>
<span class="p_add">+		wake_up_process(dc-&gt;writeback_thread);</span>
 }
 
 static inline void bch_writeback_add(struct cached_dev *dc)
<span class="p_header">diff --git a/drivers/md/dm-exception-store.h b/drivers/md/dm-exception-store.h</span>
<span class="p_header">index 0b25362..84e2770 100644</span>
<span class="p_header">--- a/drivers/md/dm-exception-store.h</span>
<span class="p_header">+++ b/drivers/md/dm-exception-store.h</span>
<span class="p_chunk">@@ -70,7 +70,7 @@</span> <span class="p_context"> struct dm_exception_store_type {</span>
 	 * Update the metadata with this exception.
 	 */
 	void (*commit_exception) (struct dm_exception_store *store,
<span class="p_del">-				  struct dm_exception *e,</span>
<span class="p_add">+				  struct dm_exception *e, int valid,</span>
 				  void (*callback) (void *, int success),
 				  void *callback_context);
 
<span class="p_header">diff --git a/drivers/md/dm-snap-persistent.c b/drivers/md/dm-snap-persistent.c</span>
<span class="p_header">index 808b841..9feb894 100644</span>
<span class="p_header">--- a/drivers/md/dm-snap-persistent.c</span>
<span class="p_header">+++ b/drivers/md/dm-snap-persistent.c</span>
<span class="p_chunk">@@ -694,7 +694,7 @@</span> <span class="p_context"> static int persistent_prepare_exception(struct dm_exception_store *store,</span>
 }
 
 static void persistent_commit_exception(struct dm_exception_store *store,
<span class="p_del">-					struct dm_exception *e,</span>
<span class="p_add">+					struct dm_exception *e, int valid,</span>
 					void (*callback) (void *, int success),
 					void *callback_context)
 {
<span class="p_chunk">@@ -703,6 +703,9 @@</span> <span class="p_context"> static void persistent_commit_exception(struct dm_exception_store *store,</span>
 	struct core_exception ce;
 	struct commit_callback *cb;
 
<span class="p_add">+	if (!valid)</span>
<span class="p_add">+		ps-&gt;valid = 0;</span>
<span class="p_add">+</span>
 	ce.old_chunk = e-&gt;old_chunk;
 	ce.new_chunk = e-&gt;new_chunk;
 	write_exception(ps, ps-&gt;current_committed++, &amp;ce);
<span class="p_header">diff --git a/drivers/md/dm-snap-transient.c b/drivers/md/dm-snap-transient.c</span>
<span class="p_header">index 1ce9a25..31439d5 100644</span>
<span class="p_header">--- a/drivers/md/dm-snap-transient.c</span>
<span class="p_header">+++ b/drivers/md/dm-snap-transient.c</span>
<span class="p_chunk">@@ -52,12 +52,12 @@</span> <span class="p_context"> static int transient_prepare_exception(struct dm_exception_store *store,</span>
 }
 
 static void transient_commit_exception(struct dm_exception_store *store,
<span class="p_del">-				       struct dm_exception *e,</span>
<span class="p_add">+				       struct dm_exception *e, int valid,</span>
 				       void (*callback) (void *, int success),
 				       void *callback_context)
 {
 	/* Just succeed */
<span class="p_del">-	callback(callback_context, 1);</span>
<span class="p_add">+	callback(callback_context, valid);</span>
 }
 
 static void transient_usage(struct dm_exception_store *store,
<span class="p_header">diff --git a/drivers/md/dm-snap.c b/drivers/md/dm-snap.c</span>
<span class="p_header">index 7c82d3c..75e1297 100644</span>
<span class="p_header">--- a/drivers/md/dm-snap.c</span>
<span class="p_header">+++ b/drivers/md/dm-snap.c</span>
<span class="p_chunk">@@ -1428,8 +1428,9 @@</span> <span class="p_context"> static void __invalidate_snapshot(struct dm_snapshot *s, int err)</span>
 	dm_table_event(s-&gt;ti-&gt;table);
 }
 
<span class="p_del">-static void pending_complete(struct dm_snap_pending_exception *pe, int success)</span>
<span class="p_add">+static void pending_complete(void *context, int success)</span>
 {
<span class="p_add">+	struct dm_snap_pending_exception *pe = context;</span>
 	struct dm_exception *e;
 	struct dm_snapshot *s = pe-&gt;snap;
 	struct bio *origin_bios = NULL;
<span class="p_chunk">@@ -1499,24 +1500,13 @@</span> <span class="p_context"> out:</span>
 	free_pending_exception(pe);
 }
 
<span class="p_del">-static void commit_callback(void *context, int success)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct dm_snap_pending_exception *pe = context;</span>
<span class="p_del">-</span>
<span class="p_del">-	pending_complete(pe, success);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void complete_exception(struct dm_snap_pending_exception *pe)
 {
 	struct dm_snapshot *s = pe-&gt;snap;
 
<span class="p_del">-	if (unlikely(pe-&gt;copy_error))</span>
<span class="p_del">-		pending_complete(pe, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	else</span>
<span class="p_del">-		/* Update the metadata if we are persistent */</span>
<span class="p_del">-		s-&gt;store-&gt;type-&gt;commit_exception(s-&gt;store, &amp;pe-&gt;e,</span>
<span class="p_del">-						 commit_callback, pe);</span>
<span class="p_add">+	/* Update the metadata if we are persistent */</span>
<span class="p_add">+	s-&gt;store-&gt;type-&gt;commit_exception(s-&gt;store, &amp;pe-&gt;e, !pe-&gt;copy_error,</span>
<span class="p_add">+					 pending_complete, pe);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/md/dm-thin.c b/drivers/md/dm-thin.c</span>
<span class="p_header">index 3efdddb..d6602ed 100644</span>
<span class="p_header">--- a/drivers/md/dm-thin.c</span>
<span class="p_header">+++ b/drivers/md/dm-thin.c</span>
<span class="p_chunk">@@ -3507,8 +3507,8 @@</span> <span class="p_context"> static void pool_postsuspend(struct dm_target *ti)</span>
 	struct pool_c *pt = ti-&gt;private;
 	struct pool *pool = pt-&gt;pool;
 
<span class="p_del">-	cancel_delayed_work(&amp;pool-&gt;waker);</span>
<span class="p_del">-	cancel_delayed_work(&amp;pool-&gt;no_space_timeout);</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;pool-&gt;waker);</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;pool-&gt;no_space_timeout);</span>
 	flush_workqueue(pool-&gt;wq);
 	(void) commit(pool);
 }
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-space-map-metadata.c b/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_header">index fca6dbc..7e44005 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_chunk">@@ -152,12 +152,9 @@</span> <span class="p_context"> static int brb_peek(struct bop_ring_buffer *brb, struct block_op *result)</span>
 
 static int brb_pop(struct bop_ring_buffer *brb)
 {
<span class="p_del">-	struct block_op *bop;</span>
<span class="p_del">-</span>
 	if (brb_empty(brb))
 		return -ENODATA;
 
<span class="p_del">-	bop = brb-&gt;bops + brb-&gt;begin;</span>
 	brb-&gt;begin = brb_next(brb, brb-&gt;begin);
 
 	return 0;
<span class="p_header">diff --git a/drivers/media/dvb-core/dvb_frontend.c b/drivers/media/dvb-core/dvb_frontend.c</span>
<span class="p_header">index 842b9c8..565b615 100644</span>
<span class="p_header">--- a/drivers/media/dvb-core/dvb_frontend.c</span>
<span class="p_header">+++ b/drivers/media/dvb-core/dvb_frontend.c</span>
<span class="p_chunk">@@ -2314,9 +2314,9 @@</span> <span class="p_context"> static int dvb_frontend_ioctl_legacy(struct file *file,</span>
 		dev_dbg(fe-&gt;dvb-&gt;device, &quot;%s: current delivery system on cache: %d, V3 type: %d\n&quot;,
 				 __func__, c-&gt;delivery_system, fe-&gt;ops.info.type);
 
<span class="p_del">-		/* Force the CAN_INVERSION_AUTO bit on. If the frontend doesn&#39;t</span>
<span class="p_del">-		 * do it, it is done for it. */</span>
<span class="p_del">-		info-&gt;caps |= FE_CAN_INVERSION_AUTO;</span>
<span class="p_add">+		/* Set CAN_INVERSION_AUTO bit on in other than oneshot mode */</span>
<span class="p_add">+		if (!(fepriv-&gt;tune_mode_flags &amp; FE_TUNE_MODE_ONESHOT))</span>
<span class="p_add">+			info-&gt;caps |= FE_CAN_INVERSION_AUTO;</span>
 		err = 0;
 		break;
 	}
<span class="p_header">diff --git a/drivers/media/rc/rc-main.c b/drivers/media/rc/rc-main.c</span>
<span class="p_header">index f3b6b2c..ddc6fa8 100644</span>
<span class="p_header">--- a/drivers/media/rc/rc-main.c</span>
<span class="p_header">+++ b/drivers/media/rc/rc-main.c</span>
<span class="p_chunk">@@ -60,7 +60,7 @@</span> <span class="p_context"> struct rc_map *rc_map_get(const char *name)</span>
 	struct rc_map_list *map;
 
 	map = seek_rc_map(name);
<span class="p_del">-#ifdef MODULE</span>
<span class="p_add">+#ifdef CONFIG_MODULES</span>
 	if (!map) {
 		int rc = request_module(&quot;%s&quot;, name);
 		if (rc &lt; 0) {
<span class="p_header">diff --git a/drivers/media/rc/sunxi-cir.c b/drivers/media/rc/sunxi-cir.c</span>
<span class="p_header">index 7830aef..40f7768 100644</span>
<span class="p_header">--- a/drivers/media/rc/sunxi-cir.c</span>
<span class="p_header">+++ b/drivers/media/rc/sunxi-cir.c</span>
<span class="p_chunk">@@ -153,6 +153,8 @@</span> <span class="p_context"> static int sunxi_ir_probe(struct platform_device *pdev)</span>
 	if (!ir)
 		return -ENOMEM;
 
<span class="p_add">+	spin_lock_init(&amp;ir-&gt;ir_lock);</span>
<span class="p_add">+</span>
 	if (of_device_is_compatible(dn, &quot;allwinner,sun5i-a13-ir&quot;))
 		ir-&gt;fifo_size = 64;
 	else
<span class="p_header">diff --git a/drivers/media/tuners/si2157.c b/drivers/media/tuners/si2157.c</span>
<span class="p_header">index 416c865..27241de 100644</span>
<span class="p_header">--- a/drivers/media/tuners/si2157.c</span>
<span class="p_header">+++ b/drivers/media/tuners/si2157.c</span>
<span class="p_chunk">@@ -168,6 +168,7 @@</span> <span class="p_context"> static int si2157_init(struct dvb_frontend *fe)</span>
 		len = fw-&gt;data[fw-&gt;size - remaining];
 		if (len &gt; SI2157_ARGLEN) {
 			dev_err(&amp;client-&gt;dev, &quot;Bad firmware length\n&quot;);
<span class="p_add">+			ret = -EINVAL;</span>
 			goto err_release_firmware;
 		}
 		memcpy(cmd.args, &amp;fw-&gt;data[(fw-&gt;size - remaining) + 1], len);
<span class="p_header">diff --git a/drivers/media/usb/gspca/ov534.c b/drivers/media/usb/gspca/ov534.c</span>
<span class="p_header">index 146071b..bfff1d1 100644</span>
<span class="p_header">--- a/drivers/media/usb/gspca/ov534.c</span>
<span class="p_header">+++ b/drivers/media/usb/gspca/ov534.c</span>
<span class="p_chunk">@@ -1491,8 +1491,13 @@</span> <span class="p_context"> static void sd_set_streamparm(struct gspca_dev *gspca_dev,</span>
 	struct v4l2_fract *tpf = &amp;cp-&gt;timeperframe;
 	struct sd *sd = (struct sd *) gspca_dev;
 
<span class="p_del">-	/* Set requested framerate */</span>
<span class="p_del">-	sd-&gt;frame_rate = tpf-&gt;denominator / tpf-&gt;numerator;</span>
<span class="p_add">+	if (tpf-&gt;numerator == 0 || tpf-&gt;denominator == 0)</span>
<span class="p_add">+		/* Set default framerate */</span>
<span class="p_add">+		sd-&gt;frame_rate = 30;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		/* Set requested framerate */</span>
<span class="p_add">+		sd-&gt;frame_rate = tpf-&gt;denominator / tpf-&gt;numerator;</span>
<span class="p_add">+</span>
 	if (gspca_dev-&gt;streaming)
 		set_frame_rate(gspca_dev);
 
<span class="p_header">diff --git a/drivers/media/usb/gspca/topro.c b/drivers/media/usb/gspca/topro.c</span>
<span class="p_header">index c70ff40..c028a5c 100644</span>
<span class="p_header">--- a/drivers/media/usb/gspca/topro.c</span>
<span class="p_header">+++ b/drivers/media/usb/gspca/topro.c</span>
<span class="p_chunk">@@ -4802,7 +4802,11 @@</span> <span class="p_context"> static void sd_set_streamparm(struct gspca_dev *gspca_dev,</span>
 	struct v4l2_fract *tpf = &amp;cp-&gt;timeperframe;
 	int fr, i;
 
<span class="p_del">-	sd-&gt;framerate = tpf-&gt;denominator / tpf-&gt;numerator;</span>
<span class="p_add">+	if (tpf-&gt;numerator == 0 || tpf-&gt;denominator == 0)</span>
<span class="p_add">+		sd-&gt;framerate = 30;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		sd-&gt;framerate = tpf-&gt;denominator / tpf-&gt;numerator;</span>
<span class="p_add">+</span>
 	if (gspca_dev-&gt;streaming)
 		setframerate(gspca_dev, v4l2_ctrl_g_ctrl(gspca_dev-&gt;exposure));
 
<span class="p_header">diff --git a/drivers/media/v4l2-core/videobuf2-core.c b/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_header">index a14c428..340f9ff 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_chunk">@@ -2686,10 +2686,10 @@</span> <span class="p_context"> unsigned int vb2_poll(struct vb2_queue *q, struct file *file, poll_table *wait)</span>
 		return res | POLLERR;
 
 	/*
<span class="p_del">-	 * For output streams you can write as long as there are fewer buffers</span>
<span class="p_del">-	 * queued than there are buffers available.</span>
<span class="p_add">+	 * For output streams you can call write() as long as there are fewer</span>
<span class="p_add">+	 * buffers queued than there are buffers available.</span>
 	 */
<span class="p_del">-	if (V4L2_TYPE_IS_OUTPUT(q-&gt;type) &amp;&amp; q-&gt;queued_count &lt; q-&gt;num_buffers)</span>
<span class="p_add">+	if (V4L2_TYPE_IS_OUTPUT(q-&gt;type) &amp;&amp; q-&gt;fileio &amp;&amp; q-&gt;queued_count &lt; q-&gt;num_buffers)</span>
 		return res | POLLOUT | POLLWRNORM;
 
 	if (list_empty(&amp;q-&gt;done_list)) {
<span class="p_header">diff --git a/drivers/misc/cxl/vphb.c b/drivers/misc/cxl/vphb.c</span>
<span class="p_header">index 2eba002..15f154e 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/vphb.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/vphb.c</span>
<span class="p_chunk">@@ -171,7 +171,7 @@</span> <span class="p_context"> static int cxl_pcie_write_config(struct pci_bus *bus, unsigned int devfn,</span>
 	mask &lt;&lt;= shift;
 	val &lt;&lt;= shift;
 
<span class="p_del">-	v = (in_le32(ioaddr) &amp; ~mask) || (val &amp; mask);</span>
<span class="p_add">+	v = (in_le32(ioaddr) &amp; ~mask) | (val &amp; mask);</span>
 
 	out_le32(ioaddr, v);
 	return PCIBIOS_SUCCESSFUL;
<span class="p_header">diff --git a/drivers/mmc/core/debugfs.c b/drivers/mmc/core/debugfs.c</span>
<span class="p_header">index e914210..7115489 100644</span>
<span class="p_header">--- a/drivers/mmc/core/debugfs.c</span>
<span class="p_header">+++ b/drivers/mmc/core/debugfs.c</span>
<span class="p_chunk">@@ -164,7 +164,7 @@</span> <span class="p_context"> static int mmc_ios_show(struct seq_file *s, void *data)</span>
 		str = &quot;invalid&quot;;
 		break;
 	}
<span class="p_del">-	seq_printf(s, &quot;signal voltage:\t%u (%s)\n&quot;, ios-&gt;chip_select, str);</span>
<span class="p_add">+	seq_printf(s, &quot;signal voltage:\t%u (%s)\n&quot;, ios-&gt;signal_voltage, str);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c</span>
<span class="p_header">index 748eddf..c3c48b1 100644</span>
<span class="p_header">--- a/drivers/mmc/core/mmc.c</span>
<span class="p_header">+++ b/drivers/mmc/core/mmc.c</span>
<span class="p_chunk">@@ -1076,8 +1076,7 @@</span> <span class="p_context"> static int mmc_select_hs400(struct mmc_card *card)</span>
 	mmc_set_clock(host, max_dtr);
 
 	/* Switch card to HS mode */
<span class="p_del">-	val = EXT_CSD_TIMING_HS |</span>
<span class="p_del">-	      card-&gt;drive_strength &lt;&lt; EXT_CSD_DRV_STR_SHIFT;</span>
<span class="p_add">+	val = EXT_CSD_TIMING_HS;</span>
 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 			   EXT_CSD_HS_TIMING, val,
 			   card-&gt;ext_csd.generic_cmd6_time,
<span class="p_chunk">@@ -1160,8 +1159,7 @@</span> <span class="p_context"> int mmc_hs400_to_hs200(struct mmc_card *card)</span>
 	mmc_set_clock(host, max_dtr);
 
 	/* Switch HS400 to HS DDR */
<span class="p_del">-	val = EXT_CSD_TIMING_HS |</span>
<span class="p_del">-	      card-&gt;drive_strength &lt;&lt; EXT_CSD_DRV_STR_SHIFT;</span>
<span class="p_add">+	val = EXT_CSD_TIMING_HS;</span>
 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING,
 			   val, card-&gt;ext_csd.generic_cmd6_time,
 			   true, send_status, true);
<span class="p_header">diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c</span>
<span class="p_header">index 4e7366a..525de8c 100644</span>
<span class="p_header">--- a/drivers/mmc/core/sd.c</span>
<span class="p_header">+++ b/drivers/mmc/core/sd.c</span>
<span class="p_chunk">@@ -329,6 +329,7 @@</span> <span class="p_context"> static int mmc_read_switch(struct mmc_card *card)</span>
 		card-&gt;sw_caps.sd3_bus_mode = status[13];
 		/* Driver Strengths supported by the card */
 		card-&gt;sw_caps.sd3_drv_type = status[9];
<span class="p_add">+		card-&gt;sw_caps.sd3_curr_limit = status[7] | status[6] &lt;&lt; 8;</span>
 	}
 
 out:
<span class="p_chunk">@@ -547,14 +548,25 @@</span> <span class="p_context"> static int sd_set_current_limit(struct mmc_card *card, u8 *status)</span>
 	 * when we set current limit to 200ma, the card will draw 200ma, and
 	 * when we set current limit to 400/600/800ma, the card will draw its
 	 * maximum 300ma from the host.
<span class="p_add">+	 *</span>
<span class="p_add">+	 * The above is incorrect: if we try to set a current limit that is</span>
<span class="p_add">+	 * not supported by the card, the card can rightfully error out the</span>
<span class="p_add">+	 * attempt, and remain at the default current limit.  This results</span>
<span class="p_add">+	 * in a 300mA card being limited to 200mA even though the host</span>
<span class="p_add">+	 * supports 800mA. Failures seen with SanDisk 8GB UHS cards with</span>
<span class="p_add">+	 * an iMX6 host. --rmk</span>
 	 */
<span class="p_del">-	if (max_current &gt;= 800)</span>
<span class="p_add">+	if (max_current &gt;= 800 &amp;&amp;</span>
<span class="p_add">+	    card-&gt;sw_caps.sd3_curr_limit &amp; SD_MAX_CURRENT_800)</span>
 		current_limit = SD_SET_CURRENT_LIMIT_800;
<span class="p_del">-	else if (max_current &gt;= 600)</span>
<span class="p_add">+	else if (max_current &gt;= 600 &amp;&amp;</span>
<span class="p_add">+		 card-&gt;sw_caps.sd3_curr_limit &amp; SD_MAX_CURRENT_600)</span>
 		current_limit = SD_SET_CURRENT_LIMIT_600;
<span class="p_del">-	else if (max_current &gt;= 400)</span>
<span class="p_add">+	else if (max_current &gt;= 400 &amp;&amp;</span>
<span class="p_add">+		 card-&gt;sw_caps.sd3_curr_limit &amp; SD_MAX_CURRENT_400)</span>
 		current_limit = SD_SET_CURRENT_LIMIT_400;
<span class="p_del">-	else if (max_current &gt;= 200)</span>
<span class="p_add">+	else if (max_current &gt;= 200 &amp;&amp;</span>
<span class="p_add">+		 card-&gt;sw_caps.sd3_curr_limit &amp; SD_MAX_CURRENT_200)</span>
 		current_limit = SD_SET_CURRENT_LIMIT_200;
 
 	if (current_limit != SD_SET_CURRENT_NO_CHANGE) {
<span class="p_header">diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c</span>
<span class="p_header">index b91abed..5c9b344 100644</span>
<span class="p_header">--- a/drivers/mmc/core/sdio.c</span>
<span class="p_header">+++ b/drivers/mmc/core/sdio.c</span>
<span class="p_chunk">@@ -630,7 +630,7 @@</span> <span class="p_context"> try_again:</span>
 	 */
 	if (!powered_resume &amp;&amp; (rocr &amp; ocr &amp; R4_18V_PRESENT)) {
 		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180,
<span class="p_del">-					ocr);</span>
<span class="p_add">+					ocr_card);</span>
 		if (err == -EAGAIN) {
 			sdio_reset(host);
 			mmc_go_idle(host);
<span class="p_header">diff --git a/drivers/mmc/host/mmci.c b/drivers/mmc/host/mmci.c</span>
<span class="p_header">index fb26674..acece32 100644</span>
<span class="p_header">--- a/drivers/mmc/host/mmci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/mmci.c</span>
<span class="p_chunk">@@ -1886,7 +1886,7 @@</span> <span class="p_context"> static struct amba_id mmci_ids[] = {</span>
 	{
 		.id     = 0x00280180,
 		.mask   = 0x00ffffff,
<span class="p_del">-		.data	= &amp;variant_u300,</span>
<span class="p_add">+		.data	= &amp;variant_nomadik,</span>
 	},
 	{
 		.id     = 0x00480180,
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-pci.c b/drivers/mmc/host/sdhci-pci.c</span>
<span class="p_header">index b3b0a3e..5d2e222 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-pci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-pci.c</span>
<span class="p_chunk">@@ -277,7 +277,7 @@</span> <span class="p_context"> static int spt_select_drive_strength(struct sdhci_host *host,</span>
 	if (sdhci_pci_spt_drive_strength &gt; 0)
 		drive_strength = sdhci_pci_spt_drive_strength &amp; 0xf;
 	else
<span class="p_del">-		drive_strength = 1; /* 33-ohm */</span>
<span class="p_add">+		drive_strength = 0; /* Default 50-ohm */</span>
 
 	if ((mmc_driver_type_mask(drive_strength) &amp; card_drv) == 0)
 		drive_strength = 0; /* Default 50-ohm */
<span class="p_header">diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c</span>
<span class="p_header">index b0c915a..939438f 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci.c</span>
<span class="p_chunk">@@ -541,9 +541,12 @@</span> <span class="p_context"> static int sdhci_adma_table_pre(struct sdhci_host *host,</span>
 
 		BUG_ON(len &gt; 65536);
 
<span class="p_del">-		/* tran, valid */</span>
<span class="p_del">-		sdhci_adma_write_desc(host, desc, addr, len, ADMA2_TRAN_VALID);</span>
<span class="p_del">-		desc += host-&gt;desc_sz;</span>
<span class="p_add">+		if (len) {</span>
<span class="p_add">+			/* tran, valid */</span>
<span class="p_add">+			sdhci_adma_write_desc(host, desc, addr, len,</span>
<span class="p_add">+					      ADMA2_TRAN_VALID);</span>
<span class="p_add">+			desc += host-&gt;desc_sz;</span>
<span class="p_add">+		}</span>
 
 		/*
 		 * If this triggers then we have a calculation bug
<span class="p_chunk">@@ -1259,19 +1262,6 @@</span> <span class="p_context"> static void sdhci_set_power(struct sdhci_host *host, unsigned char mode,</span>
 	struct mmc_host *mmc = host-&gt;mmc;
 	u8 pwr = 0;
 
<span class="p_del">-	if (!IS_ERR(mmc-&gt;supply.vmmc)) {</span>
<span class="p_del">-		spin_unlock_irq(&amp;host-&gt;lock);</span>
<span class="p_del">-		mmc_regulator_set_ocr(mmc, mmc-&gt;supply.vmmc, vdd);</span>
<span class="p_del">-		spin_lock_irq(&amp;host-&gt;lock);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (mode != MMC_POWER_OFF)</span>
<span class="p_del">-			sdhci_writeb(host, SDHCI_POWER_ON, SDHCI_POWER_CONTROL);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			sdhci_writeb(host, 0, SDHCI_POWER_CONTROL);</span>
<span class="p_del">-</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	if (mode != MMC_POWER_OFF) {
 		switch (1 &lt;&lt; vdd) {
 		case MMC_VDD_165_195:
<span class="p_chunk">@@ -1330,6 +1320,12 @@</span> <span class="p_context"> static void sdhci_set_power(struct sdhci_host *host, unsigned char mode,</span>
 		if (host-&gt;quirks &amp; SDHCI_QUIRK_DELAY_AFTER_POWER)
 			mdelay(10);
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (!IS_ERR(mmc-&gt;supply.vmmc)) {</span>
<span class="p_add">+		spin_unlock_irq(&amp;host-&gt;lock);</span>
<span class="p_add">+		mmc_regulator_set_ocr(mmc, mmc-&gt;supply.vmmc, vdd);</span>
<span class="p_add">+		spin_lock_irq(&amp;host-&gt;lock);</span>
<span class="p_add">+	}</span>
 }
 
 /*****************************************************************************\
<span class="p_chunk">@@ -2738,7 +2734,7 @@</span> <span class="p_context"> static int sdhci_runtime_pm_put(struct sdhci_host *host)</span>
 
 static void sdhci_runtime_pm_bus_on(struct sdhci_host *host)
 {
<span class="p_del">-	if (host-&gt;runtime_suspended || host-&gt;bus_on)</span>
<span class="p_add">+	if (host-&gt;bus_on)</span>
 		return;
 	host-&gt;bus_on = true;
 	pm_runtime_get_noresume(host-&gt;mmc-&gt;parent);
<span class="p_chunk">@@ -2746,7 +2742,7 @@</span> <span class="p_context"> static void sdhci_runtime_pm_bus_on(struct sdhci_host *host)</span>
 
 static void sdhci_runtime_pm_bus_off(struct sdhci_host *host)
 {
<span class="p_del">-	if (host-&gt;runtime_suspended || !host-&gt;bus_on)</span>
<span class="p_add">+	if (!host-&gt;bus_on)</span>
 		return;
 	host-&gt;bus_on = false;
 	pm_runtime_put_noidle(host-&gt;mmc-&gt;parent);
<span class="p_header">diff --git a/drivers/mtd/nand/denali.c b/drivers/mtd/nand/denali.c</span>
<span class="p_header">index 870c7fc..f229554 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/denali.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/denali.c</span>
<span class="p_chunk">@@ -1613,9 +1613,16 @@</span> <span class="p_context"> EXPORT_SYMBOL(denali_init);</span>
 /* driver exit point */
 void denali_remove(struct denali_nand_info *denali)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Pre-compute DMA buffer size to avoid any problems in case</span>
<span class="p_add">+	 * nand_release() ever changes in a way that mtd-&gt;writesize and</span>
<span class="p_add">+	 * mtd-&gt;oobsize are not reliable after this call.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	int bufsize = denali-&gt;mtd.writesize + denali-&gt;mtd.oobsize;</span>
<span class="p_add">+</span>
<span class="p_add">+	nand_release(&amp;denali-&gt;mtd);</span>
 	denali_irq_cleanup(denali-&gt;irq, denali);
<span class="p_del">-	dma_unmap_single(denali-&gt;dev, denali-&gt;buf.dma_buf,</span>
<span class="p_del">-			 denali-&gt;mtd.writesize + denali-&gt;mtd.oobsize,</span>
<span class="p_add">+	dma_unmap_single(denali-&gt;dev, denali-&gt;buf.dma_buf, bufsize,</span>
 			 DMA_BIDIRECTIONAL);
 }
 EXPORT_SYMBOL(denali_remove);
<span class="p_header">diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c</span>
<span class="p_header">index cbbb1c9..593dc28 100644</span>
<span class="p_header">--- a/drivers/net/bonding/bond_main.c</span>
<span class="p_header">+++ b/drivers/net/bonding/bond_main.c</span>
<span class="p_chunk">@@ -1209,7 +1209,6 @@</span> <span class="p_context"> static int bond_master_upper_dev_link(struct net_device *bond_dev,</span>
 	err = netdev_master_upper_dev_link_private(slave_dev, bond_dev, slave);
 	if (err)
 		return err;
<span class="p_del">-	slave_dev-&gt;flags |= IFF_SLAVE;</span>
 	rtmsg_ifinfo(RTM_NEWLINK, slave_dev, IFF_SLAVE, GFP_KERNEL);
 	return 0;
 }
<span class="p_chunk">@@ -1467,6 +1466,9 @@</span> <span class="p_context"> int bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev)</span>
 		}
 	}
 
<span class="p_add">+	/* set slave flag before open to prevent IPv6 addrconf */</span>
<span class="p_add">+	slave_dev-&gt;flags |= IFF_SLAVE;</span>
<span class="p_add">+</span>
 	/* open the slave since the application closed it */
 	res = dev_open(slave_dev);
 	if (res) {
<span class="p_chunk">@@ -1727,6 +1729,7 @@</span> <span class="p_context"> err_close:</span>
 	dev_close(slave_dev);
 
 err_restore_mac:
<span class="p_add">+	slave_dev-&gt;flags &amp;= ~IFF_SLAVE;</span>
 	if (!bond-&gt;params.fail_over_mac ||
 	    BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP) {
 		/* XXX TODO - fom follow mode needs to change master&#39;s
<span class="p_header">diff --git a/drivers/net/phy/micrel.c b/drivers/net/phy/micrel.c</span>
<span class="p_header">index 4bb8149..6f719b3 100644</span>
<span class="p_header">--- a/drivers/net/phy/micrel.c</span>
<span class="p_header">+++ b/drivers/net/phy/micrel.c</span>
<span class="p_chunk">@@ -470,9 +470,17 @@</span> <span class="p_context"> static int ksz9031_config_init(struct phy_device *phydev)</span>
 		&quot;txd2-skew-ps&quot;, &quot;txd3-skew-ps&quot;
 	};
 	static const char *control_skews[2] = {&quot;txen-skew-ps&quot;, &quot;rxdv-skew-ps&quot;};
<span class="p_add">+	const struct device *dev_walker;</span>
 
<span class="p_del">-	if (!of_node &amp;&amp; dev-&gt;parent-&gt;of_node)</span>
<span class="p_del">-		of_node = dev-&gt;parent-&gt;of_node;</span>
<span class="p_add">+	/* The Micrel driver has a deprecated option to place phy OF</span>
<span class="p_add">+	 * properties in the MAC node. Walk up the tree of devices to</span>
<span class="p_add">+	 * find a device with an OF node.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	dev_walker = &amp;phydev-&gt;dev;</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		of_node = dev_walker-&gt;of_node;</span>
<span class="p_add">+		dev_walker = dev_walker-&gt;parent;</span>
<span class="p_add">+	} while (!of_node &amp;&amp; dev_walker);</span>
 
 	if (of_node) {
 		ksz9031_of_load_skew_values(phydev, of_node,
<span class="p_header">diff --git a/drivers/net/team/team.c b/drivers/net/team/team.c</span>
<span class="p_header">index daa054b..88058480 100644</span>
<span class="p_header">--- a/drivers/net/team/team.c</span>
<span class="p_header">+++ b/drivers/net/team/team.c</span>
<span class="p_chunk">@@ -1845,10 +1845,10 @@</span> <span class="p_context"> static int team_vlan_rx_kill_vid(struct net_device *dev, __be16 proto, u16 vid)</span>
 	struct team *team = netdev_priv(dev);
 	struct team_port *port;
 
<span class="p_del">-	rcu_read_lock();</span>
<span class="p_del">-	list_for_each_entry_rcu(port, &amp;team-&gt;port_list, list)</span>
<span class="p_add">+	mutex_lock(&amp;team-&gt;lock);</span>
<span class="p_add">+	list_for_each_entry(port, &amp;team-&gt;port_list, list)</span>
 		vlan_vid_del(port-&gt;dev, proto, vid);
<span class="p_del">-	rcu_read_unlock();</span>
<span class="p_add">+	mutex_unlock(&amp;team-&gt;lock);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/net/usb/cdc_mbim.c b/drivers/net/usb/cdc_mbim.c</span>
<span class="p_header">index b6ea6ff..d87b4ac 100644</span>
<span class="p_header">--- a/drivers/net/usb/cdc_mbim.c</span>
<span class="p_header">+++ b/drivers/net/usb/cdc_mbim.c</span>
<span class="p_chunk">@@ -100,7 +100,7 @@</span> <span class="p_context"> static const struct net_device_ops cdc_mbim_netdev_ops = {</span>
 	.ndo_stop             = usbnet_stop,
 	.ndo_start_xmit       = usbnet_start_xmit,
 	.ndo_tx_timeout       = usbnet_tx_timeout,
<span class="p_del">-	.ndo_change_mtu       = usbnet_change_mtu,</span>
<span class="p_add">+	.ndo_change_mtu       = cdc_ncm_change_mtu,</span>
 	.ndo_set_mac_address  = eth_mac_addr,
 	.ndo_validate_addr    = eth_validate_addr,
 	.ndo_vlan_rx_add_vid  = cdc_mbim_rx_add_vid,
<span class="p_header">diff --git a/drivers/net/usb/cdc_ncm.c b/drivers/net/usb/cdc_ncm.c</span>
<span class="p_header">index fa41a6d..e278a7a 100644</span>
<span class="p_header">--- a/drivers/net/usb/cdc_ncm.c</span>
<span class="p_header">+++ b/drivers/net/usb/cdc_ncm.c</span>
<span class="p_chunk">@@ -41,6 +41,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/module.h&gt;
 #include &lt;linux/netdevice.h&gt;
 #include &lt;linux/ctype.h&gt;
<span class="p_add">+#include &lt;linux/etherdevice.h&gt;</span>
 #include &lt;linux/ethtool.h&gt;
 #include &lt;linux/workqueue.h&gt;
 #include &lt;linux/mii.h&gt;
<span class="p_chunk">@@ -689,6 +690,33 @@</span> <span class="p_context"> static void cdc_ncm_free(struct cdc_ncm_ctx *ctx)</span>
 	kfree(ctx);
 }
 
<span class="p_add">+/* we need to override the usbnet change_mtu ndo for two reasons:</span>
<span class="p_add">+ *  - respect the negotiated maximum datagram size</span>
<span class="p_add">+ *  - avoid unwanted changes to rx and tx buffers</span>
<span class="p_add">+ */</span>
<span class="p_add">+int cdc_ncm_change_mtu(struct net_device *net, int new_mtu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct usbnet *dev = netdev_priv(net);</span>
<span class="p_add">+	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev-&gt;data[0];</span>
<span class="p_add">+	int maxmtu = ctx-&gt;max_datagram_size - cdc_ncm_eth_hlen(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (new_mtu &lt;= 0 || new_mtu &gt; maxmtu)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	net-&gt;mtu = new_mtu;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(cdc_ncm_change_mtu);</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct net_device_ops cdc_ncm_netdev_ops = {</span>
<span class="p_add">+	.ndo_open	     = usbnet_open,</span>
<span class="p_add">+	.ndo_stop	     = usbnet_stop,</span>
<span class="p_add">+	.ndo_start_xmit	     = usbnet_start_xmit,</span>
<span class="p_add">+	.ndo_tx_timeout	     = usbnet_tx_timeout,</span>
<span class="p_add">+	.ndo_change_mtu	     = cdc_ncm_change_mtu,</span>
<span class="p_add">+	.ndo_set_mac_address = eth_mac_addr,</span>
<span class="p_add">+	.ndo_validate_addr   = eth_validate_addr,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 int cdc_ncm_bind_common(struct usbnet *dev, struct usb_interface *intf, u8 data_altsetting, int drvflags)
 {
 	const struct usb_cdc_union_desc *union_desc = NULL;
<span class="p_chunk">@@ -874,6 +902,9 @@</span> <span class="p_context"> advance:</span>
 	/* add our sysfs attrs */
 	dev-&gt;net-&gt;sysfs_groups[0] = &amp;cdc_ncm_sysfs_attr_group;
 
<span class="p_add">+	/* must handle MTU changes */</span>
<span class="p_add">+	dev-&gt;net-&gt;netdev_ops = &amp;cdc_ncm_netdev_ops;</span>
<span class="p_add">+</span>
 	return 0;
 
 error2:
<span class="p_header">diff --git a/drivers/net/veth.c b/drivers/net/veth.c</span>
<span class="p_header">index c8186ff..2e61a79 100644</span>
<span class="p_header">--- a/drivers/net/veth.c</span>
<span class="p_header">+++ b/drivers/net/veth.c</span>
<span class="p_chunk">@@ -117,12 +117,6 @@</span> <span class="p_context"> static netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 		kfree_skb(skb);
 		goto drop;
 	}
<span class="p_del">-	/* don&#39;t change ip_summed == CHECKSUM_PARTIAL, as that</span>
<span class="p_del">-	 * will cause bad checksum on forwarded packets</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (skb-&gt;ip_summed == CHECKSUM_NONE &amp;&amp;</span>
<span class="p_del">-	    rcv-&gt;features &amp; NETIF_F_RXCSUM)</span>
<span class="p_del">-		skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;</span>
 
 	if (likely(dev_forward_skb(rcv, skb) == NET_RX_SUCCESS)) {
 		struct pcpu_vstats *stats = this_cpu_ptr(dev-&gt;vstats);
<span class="p_header">diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c</span>
<span class="p_header">index 025250b..f819d51 100644</span>
<span class="p_header">--- a/drivers/net/vxlan.c</span>
<span class="p_header">+++ b/drivers/net/vxlan.c</span>
<span class="p_chunk">@@ -2581,7 +2581,7 @@</span> <span class="p_context"> static int vxlan_newlink(struct net *src_net, struct net_device *dev,</span>
 			 struct nlattr *tb[], struct nlattr *data[])
 {
 	struct vxlan_net *vn = net_generic(src_net, vxlan_net_id);
<span class="p_del">-	struct vxlan_dev *vxlan = netdev_priv(dev);</span>
<span class="p_add">+	struct vxlan_dev *vxlan = netdev_priv(dev), *tmp;</span>
 	struct vxlan_rdst *dst = &amp;vxlan-&gt;default_dst;
 	__u32 vni;
 	int err;
<span class="p_chunk">@@ -2718,9 +2718,13 @@</span> <span class="p_context"> static int vxlan_newlink(struct net *src_net, struct net_device *dev,</span>
 	if (data[IFLA_VXLAN_REMCSUM_NOPARTIAL])
 		vxlan-&gt;flags |= VXLAN_F_REMCSUM_NOPARTIAL;
 
<span class="p_del">-	if (vxlan_find_vni(src_net, vni, use_ipv6 ? AF_INET6 : AF_INET,</span>
<span class="p_del">-			   vxlan-&gt;dst_port, vxlan-&gt;flags)) {</span>
<span class="p_del">-		pr_info(&quot;duplicate VNI %u\n&quot;, vni);</span>
<span class="p_add">+	list_for_each_entry(tmp, &amp;vn-&gt;vxlan_list, next) {</span>
<span class="p_add">+		if (tmp-&gt;default_dst.remote_vni == vni &amp;&amp;</span>
<span class="p_add">+		    (tmp-&gt;default_dst.remote_ip.sa.sa_family == AF_INET6 ||</span>
<span class="p_add">+		     tmp-&gt;saddr.sa.sa_family == AF_INET6) == use_ipv6 &amp;&amp;</span>
<span class="p_add">+		    tmp-&gt;dst_port == vxlan-&gt;dst_port &amp;&amp;</span>
<span class="p_add">+		    (tmp-&gt;flags &amp; VXLAN_F_RCV_FLAGS) ==</span>
<span class="p_add">+		    (vxlan-&gt;flags &amp; VXLAN_F_RCV_FLAGS))</span>
 		return -EEXIST;
 	}
 
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/htc_hst.c b/drivers/net/wireless/ath/ath9k/htc_hst.c</span>
<span class="p_header">index d2408da..1b41a23 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/htc_hst.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/htc_hst.c</span>
<span class="p_chunk">@@ -411,7 +411,7 @@</span> <span class="p_context"> void ath9k_htc_rx_msg(struct htc_target *htc_handle,</span>
 		return;
 	}
 
<span class="p_del">-	if (epid &gt;= ENDPOINT_MAX) {</span>
<span class="p_add">+	if (epid &lt; 0 || epid &gt;= ENDPOINT_MAX) {</span>
 		if (pipe_id != USB_REG_IN_PIPE)
 			dev_kfree_skb_any(skb);
 		else
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/pcie/drv.c b/drivers/net/wireless/iwlwifi/pcie/drv.c</span>
<span class="p_header">index fd6aef7..c670196 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/pcie/drv.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/pcie/drv.c</span>
<span class="p_chunk">@@ -384,6 +384,7 @@</span> <span class="p_context"> static const struct pci_device_id iwl_hw_card_ids[] = {</span>
 	{IWL_PCI_DEVICE(0x095B, 0x5310, iwl7265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x095B, 0x5302, iwl7265_n_cfg)},
 	{IWL_PCI_DEVICE(0x095B, 0x5210, iwl7265_2ac_cfg)},
<span class="p_add">+	{IWL_PCI_DEVICE(0x095A, 0x5C10, iwl7265_2ac_cfg)},</span>
 	{IWL_PCI_DEVICE(0x095A, 0x5012, iwl7265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x095A, 0x5412, iwl7265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x095A, 0x5410, iwl7265_2ac_cfg)},
<span class="p_chunk">@@ -401,10 +402,10 @@</span> <span class="p_context"> static const struct pci_device_id iwl_hw_card_ids[] = {</span>
 	{IWL_PCI_DEVICE(0x095A, 0x900A, iwl7265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x095A, 0x9110, iwl7265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x095A, 0x9112, iwl7265_2ac_cfg)},
<span class="p_del">-	{IWL_PCI_DEVICE(0x095A, 0x9210, iwl7265_2ac_cfg)},</span>
<span class="p_add">+	{IWL_PCI_DEVICE(0x095B, 0x9210, iwl7265_2ac_cfg)},</span>
 	{IWL_PCI_DEVICE(0x095B, 0x9200, iwl7265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x095A, 0x9510, iwl7265_2ac_cfg)},
<span class="p_del">-	{IWL_PCI_DEVICE(0x095A, 0x9310, iwl7265_2ac_cfg)},</span>
<span class="p_add">+	{IWL_PCI_DEVICE(0x095B, 0x9310, iwl7265_2ac_cfg)},</span>
 	{IWL_PCI_DEVICE(0x095A, 0x9410, iwl7265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x095A, 0x5020, iwl7265_2n_cfg)},
 	{IWL_PCI_DEVICE(0x095A, 0x502A, iwl7265_2n_cfg)},
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/pcie/trans.c b/drivers/net/wireless/iwlwifi/pcie/trans.c</span>
<span class="p_header">index dab9b91..444cdb9 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/pcie/trans.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/pcie/trans.c</span>
<span class="p_chunk">@@ -7,6 +7,7 @@</span> <span class="p_context"></span>
  *
  * Copyright(c) 2007 - 2015 Intel Corporation. All rights reserved.
  * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH
<span class="p_add">+ * Copyright(c) 2016 Intel Deutschland GmbH</span>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
<span class="p_chunk">@@ -33,6 +34,7 @@</span> <span class="p_context"></span>
  *
  * Copyright(c) 2005 - 2015 Intel Corporation. All rights reserved.
  * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH
<span class="p_add">+ * Copyright(c) 2016 Intel Deutschland GmbH</span>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
<span class="p_chunk">@@ -901,9 +903,16 @@</span> <span class="p_context"> static void iwl_pcie_apply_destination(struct iwl_trans *trans)</span>
 	if (dest-&gt;monitor_mode == EXTERNAL_MODE &amp;&amp; trans_pcie-&gt;fw_mon_size) {
 		iwl_write_prph(trans, le32_to_cpu(dest-&gt;base_reg),
 			       trans_pcie-&gt;fw_mon_phys &gt;&gt; dest-&gt;base_shift);
<span class="p_del">-		iwl_write_prph(trans, le32_to_cpu(dest-&gt;end_reg),</span>
<span class="p_del">-			       (trans_pcie-&gt;fw_mon_phys +</span>
<span class="p_del">-				trans_pcie-&gt;fw_mon_size) &gt;&gt; dest-&gt;end_shift);</span>
<span class="p_add">+		if (trans-&gt;cfg-&gt;device_family == IWL_DEVICE_FAMILY_8000)</span>
<span class="p_add">+			iwl_write_prph(trans, le32_to_cpu(dest-&gt;end_reg),</span>
<span class="p_add">+				       (trans_pcie-&gt;fw_mon_phys +</span>
<span class="p_add">+					trans_pcie-&gt;fw_mon_size - 256) &gt;&gt;</span>
<span class="p_add">+						dest-&gt;end_shift);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			iwl_write_prph(trans, le32_to_cpu(dest-&gt;end_reg),</span>
<span class="p_add">+				       (trans_pcie-&gt;fw_mon_phys +</span>
<span class="p_add">+					trans_pcie-&gt;fw_mon_size) &gt;&gt;</span>
<span class="p_add">+						dest-&gt;end_shift);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/pci.c b/drivers/net/wireless/rtlwifi/pci.c</span>
<span class="p_header">index f46c9d7..7f471bf 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/pci.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/pci.c</span>
<span class="p_chunk">@@ -801,7 +801,9 @@</span> <span class="p_context"> static void _rtl_pci_rx_interrupt(struct ieee80211_hw *hw)</span>
 								      hw_queue);
 			if (rx_remained_cnt == 0)
 				return;
<span class="p_del">-</span>
<span class="p_add">+			buffer_desc = &amp;rtlpci-&gt;rx_ring[rxring_idx].buffer_desc[</span>
<span class="p_add">+				rtlpci-&gt;rx_ring[rxring_idx].idx];</span>
<span class="p_add">+			pdesc = (struct rtl_rx_desc *)skb-&gt;data;</span>
 		} else {	/* rx descriptor */
 			pdesc = &amp;rtlpci-&gt;rx_ring[rxring_idx].desc[
 				rtlpci-&gt;rx_ring[rxring_idx].idx];
<span class="p_chunk">@@ -824,13 +826,6 @@</span> <span class="p_context"> static void _rtl_pci_rx_interrupt(struct ieee80211_hw *hw)</span>
 		new_skb = dev_alloc_skb(rtlpci-&gt;rxbuffersize);
 		if (unlikely(!new_skb))
 			goto no_new;
<span class="p_del">-		if (rtlpriv-&gt;use_new_trx_flow) {</span>
<span class="p_del">-			buffer_desc =</span>
<span class="p_del">-			  &amp;rtlpci-&gt;rx_ring[rxring_idx].buffer_desc</span>
<span class="p_del">-				[rtlpci-&gt;rx_ring[rxring_idx].idx];</span>
<span class="p_del">-			/*means rx wifi info*/</span>
<span class="p_del">-			pdesc = (struct rtl_rx_desc *)skb-&gt;data;</span>
<span class="p_del">-		}</span>
 		memset(&amp;rx_status , 0 , sizeof(rx_status));
 		rtlpriv-&gt;cfg-&gt;ops-&gt;query_rx_desc(hw, &amp;stats,
 						 &amp;rx_status, (u8 *)pdesc, skb);
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8188ee/sw.c b/drivers/net/wireless/rtlwifi/rtl8188ee/sw.c</span>
<span class="p_header">index 1134412..47e32cb 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8188ee/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8188ee/sw.c</span>
<span class="p_chunk">@@ -88,8 +88,6 @@</span> <span class="p_context"> int rtl88e_init_sw_vars(struct ieee80211_hw *hw)</span>
 	u8 tid;
 
 	rtl8188ee_bt_reg_init(hw);
<span class="p_del">-	rtlpci-&gt;msi_support = rtlpriv-&gt;cfg-&gt;mod_params-&gt;msi_support;</span>
<span class="p_del">-</span>
 	rtlpriv-&gt;dm.dm_initialgain_enable = 1;
 	rtlpriv-&gt;dm.dm_flag = 0;
 	rtlpriv-&gt;dm.disable_framebursting = 0;
<span class="p_chunk">@@ -138,6 +136,11 @@</span> <span class="p_context"> int rtl88e_init_sw_vars(struct ieee80211_hw *hw)</span>
 	rtlpriv-&gt;psc.inactiveps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;inactiveps;
 	rtlpriv-&gt;psc.swctrl_lps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;swctrl_lps;
 	rtlpriv-&gt;psc.fwctrl_lps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;fwctrl_lps;
<span class="p_add">+	rtlpci-&gt;msi_support = rtlpriv-&gt;cfg-&gt;mod_params-&gt;msi_support;</span>
<span class="p_add">+	rtlpriv-&gt;cfg-&gt;mod_params-&gt;sw_crypto =</span>
<span class="p_add">+		rtlpriv-&gt;cfg-&gt;mod_params-&gt;sw_crypto;</span>
<span class="p_add">+	rtlpriv-&gt;cfg-&gt;mod_params-&gt;disable_watchdog =</span>
<span class="p_add">+		rtlpriv-&gt;cfg-&gt;mod_params-&gt;disable_watchdog;</span>
 	if (rtlpriv-&gt;cfg-&gt;mod_params-&gt;disable_watchdog)
 		pr_info(&quot;watchdog disabled\n&quot;);
 	if (!rtlpriv-&gt;psc.inactiveps)
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8192ce/sw.c b/drivers/net/wireless/rtlwifi/rtl8192ce/sw.c</span>
<span class="p_header">index de6cb6c..4780bdc 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8192ce/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8192ce/sw.c</span>
<span class="p_chunk">@@ -139,6 +139,8 @@</span> <span class="p_context"> int rtl92c_init_sw_vars(struct ieee80211_hw *hw)</span>
 	rtlpriv-&gt;psc.inactiveps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;inactiveps;
 	rtlpriv-&gt;psc.swctrl_lps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;swctrl_lps;
 	rtlpriv-&gt;psc.fwctrl_lps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;fwctrl_lps;
<span class="p_add">+	rtlpriv-&gt;cfg-&gt;mod_params-&gt;sw_crypto =</span>
<span class="p_add">+		rtlpriv-&gt;cfg-&gt;mod_params-&gt;sw_crypto;</span>
 	if (!rtlpriv-&gt;psc.inactiveps)
 		pr_info(&quot;rtl8192ce: Power Save off (module option)\n&quot;);
 	if (!rtlpriv-&gt;psc.fwctrl_lps)
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_header">index fd4a535..7c6f7f0 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_chunk">@@ -65,6 +65,8 @@</span> <span class="p_context"> static int rtl92cu_init_sw_vars(struct ieee80211_hw *hw)</span>
 	rtlpriv-&gt;dm.disable_framebursting = false;
 	rtlpriv-&gt;dm.thermalvalue = 0;
 	rtlpriv-&gt;dbg.global_debuglevel = rtlpriv-&gt;cfg-&gt;mod_params-&gt;debug;
<span class="p_add">+	rtlpriv-&gt;cfg-&gt;mod_params-&gt;sw_crypto =</span>
<span class="p_add">+		rtlpriv-&gt;cfg-&gt;mod_params-&gt;sw_crypto;</span>
 
 	/* for firmware buf */
 	rtlpriv-&gt;rtlhal.pfirmware = vzalloc(0x4000);
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8192de/sw.c b/drivers/net/wireless/rtlwifi/rtl8192de/sw.c</span>
<span class="p_header">index b19d039..c6e09a1 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8192de/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8192de/sw.c</span>
<span class="p_chunk">@@ -376,8 +376,8 @@</span> <span class="p_context"> module_param_named(swlps, rtl92de_mod_params.swctrl_lps, bool, 0444);</span>
 module_param_named(fwlps, rtl92de_mod_params.fwctrl_lps, bool, 0444);
 MODULE_PARM_DESC(swenc, &quot;Set to 1 for software crypto (default 0)\n&quot;);
 MODULE_PARM_DESC(ips, &quot;Set to 0 to not use link power save (default 1)\n&quot;);
<span class="p_del">-MODULE_PARM_DESC(swlps, &quot;Set to 1 to use SW control power save (default 0)\n&quot;);</span>
<span class="p_del">-MODULE_PARM_DESC(fwlps, &quot;Set to 1 to use FW control power save (default 1)\n&quot;);</span>
<span class="p_add">+MODULE_PARM_DESC(swlps, &quot;Set to 1 to use SW control power save (default 1)\n&quot;);</span>
<span class="p_add">+MODULE_PARM_DESC(fwlps, &quot;Set to 1 to use FW control power save (default 0)\n&quot;);</span>
 MODULE_PARM_DESC(debug, &quot;Set debug level (0-5) (default 0)&quot;);
 
 static SIMPLE_DEV_PM_OPS(rtlwifi_pm_ops, rtl_pci_suspend, rtl_pci_resume);
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8192se/sw.c b/drivers/net/wireless/rtlwifi/rtl8192se/sw.c</span>
<span class="p_header">index e1fd27c..31baca41 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8192se/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8192se/sw.c</span>
<span class="p_chunk">@@ -187,6 +187,8 @@</span> <span class="p_context"> static int rtl92s_init_sw_vars(struct ieee80211_hw *hw)</span>
 	rtlpriv-&gt;psc.inactiveps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;inactiveps;
 	rtlpriv-&gt;psc.swctrl_lps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;swctrl_lps;
 	rtlpriv-&gt;psc.fwctrl_lps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;fwctrl_lps;
<span class="p_add">+	rtlpriv-&gt;cfg-&gt;mod_params-&gt;sw_crypto =</span>
<span class="p_add">+		rtlpriv-&gt;cfg-&gt;mod_params-&gt;sw_crypto;</span>
 	if (!rtlpriv-&gt;psc.inactiveps)
 		pr_info(&quot;Power Save off (module option)\n&quot;);
 	if (!rtlpriv-&gt;psc.fwctrl_lps)
<span class="p_chunk">@@ -425,8 +427,8 @@</span> <span class="p_context"> module_param_named(swlps, rtl92se_mod_params.swctrl_lps, bool, 0444);</span>
 module_param_named(fwlps, rtl92se_mod_params.fwctrl_lps, bool, 0444);
 MODULE_PARM_DESC(swenc, &quot;Set to 1 for software crypto (default 0)\n&quot;);
 MODULE_PARM_DESC(ips, &quot;Set to 0 to not use link power save (default 1)\n&quot;);
<span class="p_del">-MODULE_PARM_DESC(swlps, &quot;Set to 1 to use SW control power save (default 0)\n&quot;);</span>
<span class="p_del">-MODULE_PARM_DESC(fwlps, &quot;Set to 1 to use FW control power save (default 1)\n&quot;);</span>
<span class="p_add">+MODULE_PARM_DESC(swlps, &quot;Set to 1 to use SW control power save (default 1)\n&quot;);</span>
<span class="p_add">+MODULE_PARM_DESC(fwlps, &quot;Set to 1 to use FW control power save (default 0)\n&quot;);</span>
 MODULE_PARM_DESC(debug, &quot;Set debug level (0-5) (default 0)&quot;);
 
 static SIMPLE_DEV_PM_OPS(rtlwifi_pm_ops, rtl_pci_suspend, rtl_pci_resume);
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8723ae/sw.c b/drivers/net/wireless/rtlwifi/rtl8723ae/sw.c</span>
<span class="p_header">index 8280bab..9647164 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8723ae/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8723ae/sw.c</span>
<span class="p_chunk">@@ -150,6 +150,11 @@</span> <span class="p_context"> int rtl8723e_init_sw_vars(struct ieee80211_hw *hw)</span>
 	rtlpriv-&gt;psc.inactiveps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;inactiveps;
 	rtlpriv-&gt;psc.swctrl_lps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;swctrl_lps;
 	rtlpriv-&gt;psc.fwctrl_lps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;fwctrl_lps;
<span class="p_add">+	rtlpci-&gt;msi_support = rtlpriv-&gt;cfg-&gt;mod_params-&gt;msi_support;</span>
<span class="p_add">+	rtlpriv-&gt;cfg-&gt;mod_params-&gt;sw_crypto =</span>
<span class="p_add">+		rtlpriv-&gt;cfg-&gt;mod_params-&gt;sw_crypto;</span>
<span class="p_add">+	rtlpriv-&gt;cfg-&gt;mod_params-&gt;disable_watchdog =</span>
<span class="p_add">+		rtlpriv-&gt;cfg-&gt;mod_params-&gt;disable_watchdog;</span>
 	if (rtlpriv-&gt;cfg-&gt;mod_params-&gt;disable_watchdog)
 		pr_info(&quot;watchdog disabled\n&quot;);
 	rtlpriv-&gt;psc.reg_fwctrl_lps = 3;
<span class="p_chunk">@@ -267,6 +272,8 @@</span> <span class="p_context"> static struct rtl_mod_params rtl8723e_mod_params = {</span>
 	.swctrl_lps = false,
 	.fwctrl_lps = true,
 	.debug = DBG_EMERG,
<span class="p_add">+	.msi_support = false,</span>
<span class="p_add">+	.disable_watchdog = false,</span>
 };
 
 static struct rtl_hal_cfg rtl8723e_hal_cfg = {
<span class="p_chunk">@@ -383,12 +390,14 @@</span> <span class="p_context"> module_param_named(debug, rtl8723e_mod_params.debug, int, 0444);</span>
 module_param_named(ips, rtl8723e_mod_params.inactiveps, bool, 0444);
 module_param_named(swlps, rtl8723e_mod_params.swctrl_lps, bool, 0444);
 module_param_named(fwlps, rtl8723e_mod_params.fwctrl_lps, bool, 0444);
<span class="p_add">+module_param_named(msi, rtl8723e_mod_params.msi_support, bool, 0444);</span>
 module_param_named(disable_watchdog, rtl8723e_mod_params.disable_watchdog,
 		   bool, 0444);
 MODULE_PARM_DESC(swenc, &quot;Set to 1 for software crypto (default 0)\n&quot;);
 MODULE_PARM_DESC(ips, &quot;Set to 0 to not use link power save (default 1)\n&quot;);
 MODULE_PARM_DESC(swlps, &quot;Set to 1 to use SW control power save (default 0)\n&quot;);
 MODULE_PARM_DESC(fwlps, &quot;Set to 1 to use FW control power save (default 1)\n&quot;);
<span class="p_add">+MODULE_PARM_DESC(msi, &quot;Set to 1 to use MSI interrupts mode (default 0)\n&quot;);</span>
 MODULE_PARM_DESC(debug, &quot;Set debug level (0-5) (default 0)&quot;);
 MODULE_PARM_DESC(disable_watchdog, &quot;Set to 1 to disable the watchdog (default 0)\n&quot;);
 
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8723be/sw.c b/drivers/net/wireless/rtlwifi/rtl8723be/sw.c</span>
<span class="p_header">index 7bf88d9..9df94b2 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8723be/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8723be/sw.c</span>
<span class="p_chunk">@@ -93,7 +93,6 @@</span> <span class="p_context"> int rtl8723be_init_sw_vars(struct ieee80211_hw *hw)</span>
 	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
 
 	rtl8723be_bt_reg_init(hw);
<span class="p_del">-	rtlpci-&gt;msi_support = rtlpriv-&gt;cfg-&gt;mod_params-&gt;msi_support;</span>
 	rtlpriv-&gt;btcoexist.btc_ops = rtl_btc_get_ops_pointer();
 
 	rtlpriv-&gt;dm.dm_initialgain_enable = 1;
<span class="p_chunk">@@ -151,6 +150,10 @@</span> <span class="p_context"> int rtl8723be_init_sw_vars(struct ieee80211_hw *hw)</span>
 	rtlpriv-&gt;psc.swctrl_lps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;swctrl_lps;
 	rtlpriv-&gt;psc.fwctrl_lps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;fwctrl_lps;
 	rtlpci-&gt;msi_support = rtlpriv-&gt;cfg-&gt;mod_params-&gt;msi_support;
<span class="p_add">+	rtlpriv-&gt;cfg-&gt;mod_params-&gt;sw_crypto =</span>
<span class="p_add">+		 rtlpriv-&gt;cfg-&gt;mod_params-&gt;sw_crypto;</span>
<span class="p_add">+	rtlpriv-&gt;cfg-&gt;mod_params-&gt;disable_watchdog =</span>
<span class="p_add">+		 rtlpriv-&gt;cfg-&gt;mod_params-&gt;disable_watchdog;</span>
 	if (rtlpriv-&gt;cfg-&gt;mod_params-&gt;disable_watchdog)
 		pr_info(&quot;watchdog disabled\n&quot;);
 	rtlpriv-&gt;psc.reg_fwctrl_lps = 3;
<span class="p_chunk">@@ -267,6 +270,9 @@</span> <span class="p_context"> static struct rtl_mod_params rtl8723be_mod_params = {</span>
 	.inactiveps = true,
 	.swctrl_lps = false,
 	.fwctrl_lps = true,
<span class="p_add">+	.msi_support = false,</span>
<span class="p_add">+	.disable_watchdog = false,</span>
<span class="p_add">+	.debug = DBG_EMERG,</span>
 };
 
 static struct rtl_hal_cfg rtl8723be_hal_cfg = {
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8821ae/sw.c b/drivers/net/wireless/rtlwifi/rtl8821ae/sw.c</span>
<span class="p_header">index 142bdff..4159f9b 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8821ae/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8821ae/sw.c</span>
<span class="p_chunk">@@ -95,8 +95,6 @@</span> <span class="p_context"> int rtl8821ae_init_sw_vars(struct ieee80211_hw *hw)</span>
 	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
 
 	rtl8821ae_bt_reg_init(hw);
<span class="p_del">-	rtlpci-&gt;msi_support = rtlpriv-&gt;cfg-&gt;mod_params-&gt;msi_support;</span>
<span class="p_del">-	rtlpci-&gt;int_clear = rtlpriv-&gt;cfg-&gt;mod_params-&gt;int_clear;</span>
 	rtlpriv-&gt;btcoexist.btc_ops = rtl_btc_get_ops_pointer();
 
 	rtlpriv-&gt;dm.dm_initialgain_enable = 1;
<span class="p_chunk">@@ -168,12 +166,15 @@</span> <span class="p_context"> int rtl8821ae_init_sw_vars(struct ieee80211_hw *hw)</span>
 	rtlpriv-&gt;psc.swctrl_lps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;swctrl_lps;
 	rtlpriv-&gt;psc.fwctrl_lps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;fwctrl_lps;
 	rtlpci-&gt;msi_support = rtlpriv-&gt;cfg-&gt;mod_params-&gt;msi_support;
<span class="p_del">-	rtlpci-&gt;msi_support = rtlpriv-&gt;cfg-&gt;mod_params-&gt;int_clear;</span>
<span class="p_add">+	rtlpci-&gt;int_clear = rtlpriv-&gt;cfg-&gt;mod_params-&gt;int_clear;</span>
<span class="p_add">+	rtlpriv-&gt;cfg-&gt;mod_params-&gt;sw_crypto =</span>
<span class="p_add">+		rtlpriv-&gt;cfg-&gt;mod_params-&gt;sw_crypto;</span>
<span class="p_add">+	rtlpriv-&gt;cfg-&gt;mod_params-&gt;disable_watchdog =</span>
<span class="p_add">+		rtlpriv-&gt;cfg-&gt;mod_params-&gt;disable_watchdog;</span>
 	if (rtlpriv-&gt;cfg-&gt;mod_params-&gt;disable_watchdog)
 		pr_info(&quot;watchdog disabled\n&quot;);
 	rtlpriv-&gt;psc.reg_fwctrl_lps = 3;
 	rtlpriv-&gt;psc.reg_max_lps_awakeintvl = 5;
<span class="p_del">-	rtlpci-&gt;msi_support = rtlpriv-&gt;cfg-&gt;mod_params-&gt;msi_support;</span>
 
 	/* for ASPM, you can close aspm through
 	 * set const_support_pciaspm = 0
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/usb.c b/drivers/net/wireless/rtlwifi/usb.c</span>
<span class="p_header">index 2721cf8..aac1ed3 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/usb.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/usb.c</span>
<span class="p_chunk">@@ -531,6 +531,8 @@</span> <span class="p_context"> static void _rtl_usb_rx_process_noagg(struct ieee80211_hw *hw,</span>
 			ieee80211_rx(hw, skb);
 		else
 			dev_kfree_skb_any(skb);
<span class="p_add">+	} else {</span>
<span class="p_add">+		dev_kfree_skb_any(skb);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/net/wireless/ti/wlcore/io.h b/drivers/net/wireless/ti/wlcore/io.h</span>
<span class="p_header">index 0305729..10cf374 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wlcore/io.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wlcore/io.h</span>
<span class="p_chunk">@@ -207,19 +207,23 @@</span> <span class="p_context"> static inline int __must_check wlcore_write_reg(struct wl1271 *wl, int reg,</span>
 
 static inline void wl1271_power_off(struct wl1271 *wl)
 {
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = 0;</span>
 
 	if (!test_bit(WL1271_FLAG_GPIO_POWER, &amp;wl-&gt;flags))
 		return;
 
<span class="p_del">-	ret = wl-&gt;if_ops-&gt;power(wl-&gt;dev, false);</span>
<span class="p_add">+	if (wl-&gt;if_ops-&gt;power)</span>
<span class="p_add">+		ret = wl-&gt;if_ops-&gt;power(wl-&gt;dev, false);</span>
 	if (!ret)
 		clear_bit(WL1271_FLAG_GPIO_POWER, &amp;wl-&gt;flags);
 }
 
 static inline int wl1271_power_on(struct wl1271 *wl)
 {
<span class="p_del">-	int ret = wl-&gt;if_ops-&gt;power(wl-&gt;dev, true);</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (wl-&gt;if_ops-&gt;power)</span>
<span class="p_add">+		ret = wl-&gt;if_ops-&gt;power(wl-&gt;dev, true);</span>
 	if (ret == 0)
 		set_bit(WL1271_FLAG_GPIO_POWER, &amp;wl-&gt;flags);
 
<span class="p_header">diff --git a/drivers/net/wireless/ti/wlcore/spi.c b/drivers/net/wireless/ti/wlcore/spi.c</span>
<span class="p_header">index f1ac283..720e4e4 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wlcore/spi.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wlcore/spi.c</span>
<span class="p_chunk">@@ -73,7 +73,10 @@</span> <span class="p_context"></span>
  */
 #define SPI_AGGR_BUFFER_SIZE (4 * PAGE_SIZE)
 
<span class="p_del">-#define WSPI_MAX_NUM_OF_CHUNKS (SPI_AGGR_BUFFER_SIZE / WSPI_MAX_CHUNK_SIZE)</span>
<span class="p_add">+/* Maximum number of SPI write chunks */</span>
<span class="p_add">+#define WSPI_MAX_NUM_OF_CHUNKS \</span>
<span class="p_add">+	((SPI_AGGR_BUFFER_SIZE / WSPI_MAX_CHUNK_SIZE) + 1)</span>
<span class="p_add">+</span>
 
 struct wl12xx_spi_glue {
 	struct device *dev;
<span class="p_chunk">@@ -268,9 +271,10 @@</span> <span class="p_context"> static int __must_check wl12xx_spi_raw_write(struct device *child, int addr,</span>
 					     void *buf, size_t len, bool fixed)
 {
 	struct wl12xx_spi_glue *glue = dev_get_drvdata(child-&gt;parent);
<span class="p_del">-	struct spi_transfer t[2 * (WSPI_MAX_NUM_OF_CHUNKS + 1)];</span>
<span class="p_add">+	/* SPI write buffers - 2 for each chunk */</span>
<span class="p_add">+	struct spi_transfer t[2 * WSPI_MAX_NUM_OF_CHUNKS];</span>
 	struct spi_message m;
<span class="p_del">-	u32 commands[WSPI_MAX_NUM_OF_CHUNKS];</span>
<span class="p_add">+	u32 commands[WSPI_MAX_NUM_OF_CHUNKS]; /* 1 command per chunk */</span>
 	u32 *cmd;
 	u32 chunk_len;
 	int i;
<span class="p_header">diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c</span>
<span class="p_header">index d3346d2..89b3bef 100644</span>
<span class="p_header">--- a/drivers/pci/bus.c</span>
<span class="p_header">+++ b/drivers/pci/bus.c</span>
<span class="p_chunk">@@ -140,6 +140,8 @@</span> <span class="p_context"> static int pci_bus_alloc_from_region(struct pci_bus *bus, struct resource *res,</span>
 	type_mask |= IORESOURCE_TYPE_BITS;
 
 	pci_bus_for_each_resource(bus, r, i) {
<span class="p_add">+		resource_size_t min_used = min;</span>
<span class="p_add">+</span>
 		if (!r)
 			continue;
 
<span class="p_chunk">@@ -163,12 +165,12 @@</span> <span class="p_context"> static int pci_bus_alloc_from_region(struct pci_bus *bus, struct resource *res,</span>
 		 * overrides &quot;min&quot;.
 		 */
 		if (avail.start)
<span class="p_del">-			min = avail.start;</span>
<span class="p_add">+			min_used = avail.start;</span>
 
 		max = avail.end;
 
 		/* Ok, try it out.. */
<span class="p_del">-		ret = allocate_resource(r, res, size, min, max,</span>
<span class="p_add">+		ret = allocate_resource(r, res, size, min_used, max,</span>
 					align, alignf, alignf_data);
 		if (ret == 0)
 			return 0;
<span class="p_header">diff --git a/drivers/pci/host/pci-dra7xx.c b/drivers/pci/host/pci-dra7xx.c</span>
<span class="p_header">index 80db09e..66aa928 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-dra7xx.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-dra7xx.c</span>
<span class="p_chunk">@@ -284,7 +284,8 @@</span> <span class="p_context"> static int __init dra7xx_add_pcie_port(struct dra7xx_pcie *dra7xx,</span>
 	}
 
 	ret = devm_request_irq(&amp;pdev-&gt;dev, pp-&gt;irq,
<span class="p_del">-			       dra7xx_pcie_msi_irq_handler, IRQF_SHARED,</span>
<span class="p_add">+			       dra7xx_pcie_msi_irq_handler,</span>
<span class="p_add">+			       IRQF_SHARED | IRQF_NO_THREAD,</span>
 			       &quot;dra7-pcie-msi&quot;,	pp);
 	if (ret) {
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to request irq\n&quot;);
<span class="p_header">diff --git a/drivers/pci/host/pci-exynos.c b/drivers/pci/host/pci-exynos.c</span>
<span class="p_header">index f9f468d..7b6be77 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-exynos.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-exynos.c</span>
<span class="p_chunk">@@ -523,7 +523,8 @@</span> <span class="p_context"> static int __init exynos_add_pcie_port(struct pcie_port *pp,</span>
 
 		ret = devm_request_irq(&amp;pdev-&gt;dev, pp-&gt;msi_irq,
 					exynos_pcie_msi_irq_handler,
<span class="p_del">-					IRQF_SHARED, &quot;exynos-pcie&quot;, pp);</span>
<span class="p_add">+					IRQF_SHARED | IRQF_NO_THREAD,</span>
<span class="p_add">+					&quot;exynos-pcie&quot;, pp);</span>
 		if (ret) {
 			dev_err(&amp;pdev-&gt;dev, &quot;failed to request msi irq\n&quot;);
 			return ret;
<span class="p_header">diff --git a/drivers/pci/host/pci-imx6.c b/drivers/pci/host/pci-imx6.c</span>
<span class="p_header">index 233a196..fd5eb2e 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-imx6.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-imx6.c</span>
<span class="p_chunk">@@ -544,7 +544,8 @@</span> <span class="p_context"> static int __init imx6_add_pcie_port(struct pcie_port *pp,</span>
 
 		ret = devm_request_irq(&amp;pdev-&gt;dev, pp-&gt;msi_irq,
 				       imx6_pcie_msi_handler,
<span class="p_del">-				       IRQF_SHARED, &quot;mx6-pcie-msi&quot;, pp);</span>
<span class="p_add">+				       IRQF_SHARED | IRQF_NO_THREAD,</span>
<span class="p_add">+				       &quot;mx6-pcie-msi&quot;, pp);</span>
 		if (ret) {
 			dev_err(&amp;pdev-&gt;dev, &quot;failed to request MSI irq\n&quot;);
 			return -ENODEV;
<span class="p_header">diff --git a/drivers/pci/host/pci-tegra.c b/drivers/pci/host/pci-tegra.c</span>
<span class="p_header">index 10c0571..60e3c46 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-tegra.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-tegra.c</span>
<span class="p_chunk">@@ -1289,7 +1289,7 @@</span> <span class="p_context"> static int tegra_pcie_enable_msi(struct tegra_pcie *pcie)</span>
 
 	msi-&gt;irq = err;
 
<span class="p_del">-	err = request_irq(msi-&gt;irq, tegra_pcie_msi_irq, 0,</span>
<span class="p_add">+	err = request_irq(msi-&gt;irq, tegra_pcie_msi_irq, IRQF_NO_THREAD,</span>
 			  tegra_msi_irq_chip.name, pcie);
 	if (err &lt; 0) {
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to request IRQ: %d\n&quot;, err);
<span class="p_header">diff --git a/drivers/pci/host/pcie-rcar.c b/drivers/pci/host/pcie-rcar.c</span>
<span class="p_header">index c086210..56ce564 100644</span>
<span class="p_header">--- a/drivers/pci/host/pcie-rcar.c</span>
<span class="p_header">+++ b/drivers/pci/host/pcie-rcar.c</span>
<span class="p_chunk">@@ -695,14 +695,16 @@</span> <span class="p_context"> static int rcar_pcie_enable_msi(struct rcar_pcie *pcie)</span>
 
 	/* Two irqs are for MSI, but they are also used for non-MSI irqs */
 	err = devm_request_irq(&amp;pdev-&gt;dev, msi-&gt;irq1, rcar_pcie_msi_irq,
<span class="p_del">-			       IRQF_SHARED, rcar_msi_irq_chip.name, pcie);</span>
<span class="p_add">+			       IRQF_SHARED | IRQF_NO_THREAD,</span>
<span class="p_add">+			       rcar_msi_irq_chip.name, pcie);</span>
 	if (err &lt; 0) {
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to request IRQ: %d\n&quot;, err);
 		goto err;
 	}
 
 	err = devm_request_irq(&amp;pdev-&gt;dev, msi-&gt;irq2, rcar_pcie_msi_irq,
<span class="p_del">-			       IRQF_SHARED, rcar_msi_irq_chip.name, pcie);</span>
<span class="p_add">+			       IRQF_SHARED | IRQF_NO_THREAD,</span>
<span class="p_add">+			       rcar_msi_irq_chip.name, pcie);</span>
 	if (err &lt; 0) {
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to request IRQ: %d\n&quot;, err);
 		goto err;
<span class="p_header">diff --git a/drivers/pci/host/pcie-spear13xx.c b/drivers/pci/host/pcie-spear13xx.c</span>
<span class="p_header">index 4086268..d877c3b 100644</span>
<span class="p_header">--- a/drivers/pci/host/pcie-spear13xx.c</span>
<span class="p_header">+++ b/drivers/pci/host/pcie-spear13xx.c</span>
<span class="p_chunk">@@ -282,7 +282,8 @@</span> <span class="p_context"> static int spear13xx_add_pcie_port(struct pcie_port *pp,</span>
 		return -ENODEV;
 	}
 	ret = devm_request_irq(dev, pp-&gt;irq, spear13xx_pcie_irq_handler,
<span class="p_del">-			       IRQF_SHARED, &quot;spear1340-pcie&quot;, pp);</span>
<span class="p_add">+			       IRQF_SHARED | IRQF_NO_THREAD,</span>
<span class="p_add">+			       &quot;spear1340-pcie&quot;, pp);</span>
 	if (ret) {
 		dev_err(dev, &quot;failed to request irq %d\n&quot;, pp-&gt;irq);
 		return ret;
<span class="p_header">diff --git a/drivers/pci/host/pcie-xilinx.c b/drivers/pci/host/pcie-xilinx.c</span>
<span class="p_header">index f1a06a0..577fe5b 100644</span>
<span class="p_header">--- a/drivers/pci/host/pcie-xilinx.c</span>
<span class="p_header">+++ b/drivers/pci/host/pcie-xilinx.c</span>
<span class="p_chunk">@@ -776,7 +776,8 @@</span> <span class="p_context"> static int xilinx_pcie_parse_dt(struct xilinx_pcie_port *port)</span>
 
 	port-&gt;irq = irq_of_parse_and_map(node, 0);
 	err = devm_request_irq(dev, port-&gt;irq, xilinx_pcie_intr_handler,
<span class="p_del">-			       IRQF_SHARED, &quot;xilinx-pcie&quot;, port);</span>
<span class="p_add">+			       IRQF_SHARED | IRQF_NO_THREAD,</span>
<span class="p_add">+			       &quot;xilinx-pcie&quot;, port);</span>
 	if (err) {
 		dev_err(dev, &quot;unable to request irq %d\n&quot;, port-&gt;irq);
 		return err;
<span class="p_header">diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c</span>
<span class="p_header">index f6ae0d0..8e4ad97 100644</span>
<span class="p_header">--- a/drivers/pci/probe.c</span>
<span class="p_header">+++ b/drivers/pci/probe.c</span>
<span class="p_chunk">@@ -1108,7 +1108,7 @@</span> <span class="p_context"> int pci_cfg_space_size(struct pci_dev *dev)</span>
 
 #define LEGACY_IO_RESOURCE	(IORESOURCE_IO | IORESOURCE_PCI_FIXED)
 
<span class="p_del">-void pci_msi_setup_pci_dev(struct pci_dev *dev)</span>
<span class="p_add">+static void pci_msi_setup_pci_dev(struct pci_dev *dev)</span>
 {
 	/*
 	 * Disable the MSI hardware to avoid screaming interrupts
<span class="p_chunk">@@ -1179,8 +1179,6 @@</span> <span class="p_context"> int pci_setup_device(struct pci_dev *dev)</span>
 	/* &quot;Unknown power state&quot; */
 	dev-&gt;current_state = PCI_UNKNOWN;
 
<span class="p_del">-	pci_msi_setup_pci_dev(dev);</span>
<span class="p_del">-</span>
 	/* Early fixups, before probing the BARs */
 	pci_fixup_device(pci_fixup_early, dev);
 	/* device class may be changed after fixup */
<span class="p_chunk">@@ -1530,6 +1528,9 @@</span> <span class="p_context"> static void pci_init_capabilities(struct pci_dev *dev)</span>
 	/* MSI/MSI-X list */
 	pci_msi_init_pci_dev(dev);
 
<span class="p_add">+	/* Setup MSI caps &amp; disable MSI/MSI-X interrupts */</span>
<span class="p_add">+	pci_msi_setup_pci_dev(dev);</span>
<span class="p_add">+</span>
 	/* Buffers for saving PCIe and PCI-X capabilities */
 	pci_allocate_cap_save_buffers(dev);
 
<span class="p_header">diff --git a/drivers/pinctrl/bcm/pinctrl-bcm2835.c b/drivers/pinctrl/bcm/pinctrl-bcm2835.c</span>
<span class="p_header">index 7a2d53c..8f93ec3 100644</span>
<span class="p_header">--- a/drivers/pinctrl/bcm/pinctrl-bcm2835.c</span>
<span class="p_header">+++ b/drivers/pinctrl/bcm/pinctrl-bcm2835.c</span>
<span class="p_chunk">@@ -805,7 +805,7 @@</span> <span class="p_context"> static int bcm2835_pctl_dt_node_to_map(struct pinctrl_dev *pctldev,</span>
 	return 0;
 
 out:
<span class="p_del">-	kfree(maps);</span>
<span class="p_add">+	bcm2835_pctl_dt_free_map(pctldev, maps, num_pins * maps_per_pin);</span>
 	return err;
 }
 
<span class="p_header">diff --git a/drivers/platform/x86/ideapad-laptop.c b/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_header">index db567b7..e2b3743 100644</span>
<span class="p_header">--- a/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_chunk">@@ -846,6 +846,13 @@</span> <span class="p_context"> static const struct dmi_system_id no_hw_rfkill_list[] = {</span>
 		},
 	},
 	{
<span class="p_add">+		.ident = &quot;Lenovo ideapad Y700-17ISK&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;LENOVO&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_VERSION, &quot;Lenovo ideapad Y700-17ISK&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		.ident = &quot;Lenovo Yoga 2 11 / 13 / Pro&quot;,
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, &quot;LENOVO&quot;),
<span class="p_chunk">@@ -867,6 +874,13 @@</span> <span class="p_context"> static const struct dmi_system_id no_hw_rfkill_list[] = {</span>
 		},
 	},
 	{
<span class="p_add">+		.ident = &quot;Lenovo Yoga 700&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;LENOVO&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_VERSION, &quot;Lenovo YOGA 700&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		.ident = &quot;Lenovo Yoga 900&quot;,
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, &quot;LENOVO&quot;),
<span class="p_header">diff --git a/drivers/power/test_power.c b/drivers/power/test_power.c</span>
<span class="p_header">index 83c42ea..57246cd 100644</span>
<span class="p_header">--- a/drivers/power/test_power.c</span>
<span class="p_header">+++ b/drivers/power/test_power.c</span>
<span class="p_chunk">@@ -301,6 +301,8 @@</span> <span class="p_context"> static int map_get_value(struct battery_property_map *map, const char *key,</span>
 	buf[MAX_KEYLENGTH-1] = &#39;\0&#39;;
 
 	cr = strnlen(buf, MAX_KEYLENGTH) - 1;
<span class="p_add">+	if (cr &lt; 0)</span>
<span class="p_add">+		return def_val;</span>
 	if (buf[cr] == &#39;\n&#39;)
 		buf[cr] = &#39;\0&#39;;
 
<span class="p_header">diff --git a/drivers/regulator/axp20x-regulator.c b/drivers/regulator/axp20x-regulator.c</span>
<span class="p_header">index 1dea0e8..168b5c3 100644</span>
<span class="p_header">--- a/drivers/regulator/axp20x-regulator.c</span>
<span class="p_header">+++ b/drivers/regulator/axp20x-regulator.c</span>
<span class="p_chunk">@@ -27,8 +27,8 @@</span> <span class="p_context"></span>
 #define AXP20X_IO_ENABLED		0x03
 #define AXP20X_IO_DISABLED		0x07
 
<span class="p_del">-#define AXP22X_IO_ENABLED		0x04</span>
<span class="p_del">-#define AXP22X_IO_DISABLED		0x03</span>
<span class="p_add">+#define AXP22X_IO_ENABLED		0x03</span>
<span class="p_add">+#define AXP22X_IO_DISABLED		0x04</span>
 
 #define AXP20X_WORKMODE_DCDC2_MASK	BIT(2)
 #define AXP20X_WORKMODE_DCDC3_MASK	BIT(1)
<span class="p_header">diff --git a/drivers/scsi/initio.c b/drivers/scsi/initio.c</span>
<span class="p_header">index 6a926ba..7a91cf3 100644</span>
<span class="p_header">--- a/drivers/scsi/initio.c</span>
<span class="p_header">+++ b/drivers/scsi/initio.c</span>
<span class="p_chunk">@@ -110,11 +110,6 @@</span> <span class="p_context"></span>
 #define i91u_MAXQUEUE		2
 #define i91u_REVID &quot;Initio INI-9X00U/UW SCSI device driver; Revision: 1.04a&quot;
 
<span class="p_del">-#define I950_DEVICE_ID	0x9500	/* Initio&#39;s inic-950 product ID   */</span>
<span class="p_del">-#define I940_DEVICE_ID	0x9400	/* Initio&#39;s inic-940 product ID   */</span>
<span class="p_del">-#define I935_DEVICE_ID	0x9401	/* Initio&#39;s inic-935 product ID   */</span>
<span class="p_del">-#define I920_DEVICE_ID	0x0002	/* Initio&#39;s other product ID      */</span>
<span class="p_del">-</span>
 #ifdef DEBUG_i91u
 static unsigned int i91u_debug = DEBUG_DEFAULT;
 #endif
<span class="p_chunk">@@ -127,17 +122,6 @@</span> <span class="p_context"> static int setup_debug = 0;</span>
 
 static void i91uSCBPost(u8 * pHcb, u8 * pScb);
 
<span class="p_del">-/* PCI Devices supported by this driver */</span>
<span class="p_del">-static struct pci_device_id i91u_pci_devices[] = {</span>
<span class="p_del">-	{ PCI_VENDOR_ID_INIT,  I950_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},</span>
<span class="p_del">-	{ PCI_VENDOR_ID_INIT,  I940_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},</span>
<span class="p_del">-	{ PCI_VENDOR_ID_INIT,  I935_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},</span>
<span class="p_del">-	{ PCI_VENDOR_ID_INIT,  I920_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},</span>
<span class="p_del">-	{ PCI_VENDOR_ID_DOMEX, I920_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},</span>
<span class="p_del">-	{ }</span>
<span class="p_del">-};</span>
<span class="p_del">-MODULE_DEVICE_TABLE(pci, i91u_pci_devices);</span>
<span class="p_del">-</span>
 #define DEBUG_INTERRUPT 0
 #define DEBUG_QUEUE     0
 #define DEBUG_STATE     0
<span class="p_header">diff --git a/drivers/scsi/scsi_devinfo.c b/drivers/scsi/scsi_devinfo.c</span>
<span class="p_header">index 9f77d23..64ed88a 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_devinfo.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_devinfo.c</span>
<span class="p_chunk">@@ -227,6 +227,7 @@</span> <span class="p_context"> static struct {</span>
 	{&quot;Promise&quot;, &quot;VTrak E610f&quot;, NULL, BLIST_SPARSELUN | BLIST_NO_RSOC},
 	{&quot;Promise&quot;, &quot;&quot;, NULL, BLIST_SPARSELUN},
 	{&quot;QNAP&quot;, &quot;iSCSI Storage&quot;, NULL, BLIST_MAX_1024},
<span class="p_add">+	{&quot;SYNOLOGY&quot;, &quot;iSCSI Storage&quot;, NULL, BLIST_MAX_1024},</span>
 	{&quot;QUANTUM&quot;, &quot;XP34301&quot;, &quot;1071&quot;, BLIST_NOTQ},
 	{&quot;REGAL&quot;, &quot;CDC-4X&quot;, NULL, BLIST_MAX5LUN | BLIST_SINGLELUN},
 	{&quot;SanDisk&quot;, &quot;ImageMate CF-SD1&quot;, NULL, BLIST_FORCELUN},
<span class="p_header">diff --git a/drivers/staging/media/lirc/lirc_imon.c b/drivers/staging/media/lirc/lirc_imon.c</span>
<span class="p_header">index 62ec9f7..45b6443 100644</span>
<span class="p_header">--- a/drivers/staging/media/lirc/lirc_imon.c</span>
<span class="p_header">+++ b/drivers/staging/media/lirc/lirc_imon.c</span>
<span class="p_chunk">@@ -885,12 +885,14 @@</span> <span class="p_context"> static int imon_probe(struct usb_interface *interface,</span>
 		vendor, product, ifnum, usbdev-&gt;bus-&gt;busnum, usbdev-&gt;devnum);
 
 	/* Everything went fine. Just unlock and return retval (with is 0) */
<span class="p_add">+	mutex_unlock(&amp;context-&gt;ctx_lock);</span>
 	goto driver_unlock;
 
 unregister_lirc:
 	lirc_unregister_driver(driver-&gt;minor);
 
 free_tx_urb:
<span class="p_add">+	mutex_unlock(&amp;context-&gt;ctx_lock);</span>
 	usb_free_urb(tx_urb);
 
 free_rx_urb:
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_configfs.c b/drivers/target/iscsi/iscsi_target_configfs.c</span>
<span class="p_header">index db3b9b9..a13d59e 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_configfs.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_configfs.c</span>
<span class="p_chunk">@@ -1834,7 +1834,8 @@</span> <span class="p_context"> static int lio_tpg_check_prot_fabric_only(</span>
 }
 
 /*
<span class="p_del">- * Called with spin_lock_bh(struct se_portal_group-&gt;session_lock) held..</span>
<span class="p_add">+ * Called with spin_lock_irq(struct se_portal_group-&gt;session_lock) held</span>
<span class="p_add">+ * or not held.</span>
  *
  * Also, this function calls iscsit_inc_session_usage_count() on the
  * struct iscsi_session in question.
<span class="p_chunk">@@ -1842,19 +1843,32 @@</span> <span class="p_context"> static int lio_tpg_check_prot_fabric_only(</span>
 static int lio_tpg_shutdown_session(struct se_session *se_sess)
 {
 	struct iscsi_session *sess = se_sess-&gt;fabric_sess_ptr;
<span class="p_add">+	struct se_portal_group *se_tpg = se_sess-&gt;se_tpg;</span>
<span class="p_add">+	bool local_lock = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!spin_is_locked(&amp;se_tpg-&gt;session_lock)) {</span>
<span class="p_add">+		spin_lock_irq(&amp;se_tpg-&gt;session_lock);</span>
<span class="p_add">+		local_lock = true;</span>
<span class="p_add">+	}</span>
 
 	spin_lock(&amp;sess-&gt;conn_lock);
 	if (atomic_read(&amp;sess-&gt;session_fall_back_to_erl0) ||
 	    atomic_read(&amp;sess-&gt;session_logout) ||
 	    (sess-&gt;time2retain_timer_flags &amp; ISCSI_TF_EXPIRED)) {
 		spin_unlock(&amp;sess-&gt;conn_lock);
<span class="p_add">+		if (local_lock)</span>
<span class="p_add">+			spin_unlock_irq(&amp;sess-&gt;conn_lock);</span>
 		return 0;
 	}
 	atomic_set(&amp;sess-&gt;session_reinstatement, 1);
 	spin_unlock(&amp;sess-&gt;conn_lock);
 
 	iscsit_stop_time2retain_timer(sess);
<span class="p_add">+	spin_unlock_irq(&amp;se_tpg-&gt;session_lock);</span>
<span class="p_add">+</span>
 	iscsit_stop_session(sess, 1, 1);
<span class="p_add">+	if (!local_lock)</span>
<span class="p_add">+		spin_lock_irq(&amp;se_tpg-&gt;session_lock);</span>
 
 	return 1;
 }
<span class="p_header">diff --git a/drivers/target/target_core_configfs.c b/drivers/target/target_core_configfs.c</span>
<span class="p_header">index 860e840..e19da34 100644</span>
<span class="p_header">--- a/drivers/target/target_core_configfs.c</span>
<span class="p_header">+++ b/drivers/target/target_core_configfs.c</span>
<span class="p_chunk">@@ -2137,14 +2137,14 @@</span> <span class="p_context"> static ssize_t target_core_store_dev_lba_map(</span>
 	struct se_device *dev = p;
 	struct t10_alua_lba_map *lba_map = NULL;
 	struct list_head lba_list;
<span class="p_del">-	char *map_entries, *ptr;</span>
<span class="p_add">+	char *map_entries, *orig, *ptr;</span>
 	char state;
 	int pg_num = -1, pg;
 	int ret = 0, num = 0, pg_id, alua_state;
 	unsigned long start_lba = -1, end_lba = -1;
 	unsigned long segment_size = -1, segment_mult = -1;
 
<span class="p_del">-	map_entries = kstrdup(page, GFP_KERNEL);</span>
<span class="p_add">+	orig = map_entries = kstrdup(page, GFP_KERNEL);</span>
 	if (!map_entries)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -2242,7 +2242,7 @@</span> <span class="p_context"> out:</span>
 	} else
 		core_alua_set_lba_map(dev, &amp;lba_list,
 				      segment_size, segment_mult);
<span class="p_del">-	kfree(map_entries);</span>
<span class="p_add">+	kfree(orig);</span>
 	return count;
 }
 
<span class="p_header">diff --git a/drivers/thermal/step_wise.c b/drivers/thermal/step_wise.c</span>
<span class="p_header">index 5a0f12d..ec4ea59 100644</span>
<span class="p_header">--- a/drivers/thermal/step_wise.c</span>
<span class="p_header">+++ b/drivers/thermal/step_wise.c</span>
<span class="p_chunk">@@ -63,6 +63,19 @@</span> <span class="p_context"> static unsigned long get_target_state(struct thermal_instance *instance,</span>
 	next_target = instance-&gt;target;
 	dev_dbg(&amp;cdev-&gt;device, &quot;cur_state=%ld\n&quot;, cur_state);
 
<span class="p_add">+	if (!instance-&gt;initialized) {</span>
<span class="p_add">+		if (throttle) {</span>
<span class="p_add">+			next_target = (cur_state + 1) &gt;= instance-&gt;upper ?</span>
<span class="p_add">+					instance-&gt;upper :</span>
<span class="p_add">+					((cur_state + 1) &lt; instance-&gt;lower ?</span>
<span class="p_add">+					instance-&gt;lower : (cur_state + 1));</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			next_target = THERMAL_NO_TARGET;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		return next_target;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	switch (trend) {
 	case THERMAL_TREND_RAISING:
 		if (throttle) {
<span class="p_chunk">@@ -149,7 +162,7 @@</span> <span class="p_context"> static void thermal_zone_trip_update(struct thermal_zone_device *tz, int trip)</span>
 		dev_dbg(&amp;instance-&gt;cdev-&gt;device, &quot;old_target=%d, target=%d\n&quot;,
 					old_target, (int)instance-&gt;target);
 
<span class="p_del">-		if (old_target == instance-&gt;target)</span>
<span class="p_add">+		if (instance-&gt;initialized &amp;&amp; old_target == instance-&gt;target)</span>
 			continue;
 
 		/* Activate a passive thermal instance */
<span class="p_chunk">@@ -161,7 +174,7 @@</span> <span class="p_context"> static void thermal_zone_trip_update(struct thermal_zone_device *tz, int trip)</span>
 			instance-&gt;target == THERMAL_NO_TARGET)
 			update_passive_instance(tz, trip_type, -1);
 
<span class="p_del">-</span>
<span class="p_add">+		instance-&gt;initialized = true;</span>
 		instance-&gt;cdev-&gt;updated = false; /* cdev needs update */
 	}
 
<span class="p_header">diff --git a/drivers/thermal/thermal_core.c b/drivers/thermal/thermal_core.c</span>
<span class="p_header">index 4ca211b..090da0c 100644</span>
<span class="p_header">--- a/drivers/thermal/thermal_core.c</span>
<span class="p_header">+++ b/drivers/thermal/thermal_core.c</span>
<span class="p_chunk">@@ -37,6 +37,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/of.h&gt;
 #include &lt;net/netlink.h&gt;
 #include &lt;net/genetlink.h&gt;
<span class="p_add">+#include &lt;linux/suspend.h&gt;</span>
 
 #define CREATE_TRACE_POINTS
 #include &lt;trace/events/thermal.h&gt;
<span class="p_chunk">@@ -59,6 +60,8 @@</span> <span class="p_context"> static LIST_HEAD(thermal_governor_list);</span>
 static DEFINE_MUTEX(thermal_list_lock);
 static DEFINE_MUTEX(thermal_governor_lock);
 
<span class="p_add">+static atomic_t in_suspend;</span>
<span class="p_add">+</span>
 static struct thermal_governor *def_governor;
 
 static struct thermal_governor *__find_governor(const char *name)
<span class="p_chunk">@@ -534,14 +537,31 @@</span> <span class="p_context"> static void update_temperature(struct thermal_zone_device *tz)</span>
 	mutex_unlock(&amp;tz-&gt;lock);
 
 	trace_thermal_temperature(tz);
<span class="p_del">-	dev_dbg(&amp;tz-&gt;device, &quot;last_temperature=%d, current_temperature=%d\n&quot;,</span>
<span class="p_del">-				tz-&gt;last_temperature, tz-&gt;temperature);</span>
<span class="p_add">+	if (tz-&gt;last_temperature == THERMAL_TEMP_INVALID)</span>
<span class="p_add">+		dev_dbg(&amp;tz-&gt;device, &quot;last_temperature N/A, current_temperature=%d\n&quot;,</span>
<span class="p_add">+			tz-&gt;temperature);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		dev_dbg(&amp;tz-&gt;device, &quot;last_temperature=%d, current_temperature=%d\n&quot;,</span>
<span class="p_add">+			tz-&gt;last_temperature, tz-&gt;temperature);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void thermal_zone_device_reset(struct thermal_zone_device *tz)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct thermal_instance *pos;</span>
<span class="p_add">+</span>
<span class="p_add">+	tz-&gt;temperature = THERMAL_TEMP_INVALID;</span>
<span class="p_add">+	tz-&gt;passive = 0;</span>
<span class="p_add">+	list_for_each_entry(pos, &amp;tz-&gt;thermal_instances, tz_node)</span>
<span class="p_add">+		pos-&gt;initialized = false;</span>
 }
 
 void thermal_zone_device_update(struct thermal_zone_device *tz)
 {
 	int count;
 
<span class="p_add">+	if (atomic_read(&amp;in_suspend))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	if (!tz-&gt;ops-&gt;get_temp)
 		return;
 
<span class="p_chunk">@@ -1276,6 +1296,7 @@</span> <span class="p_context"> int thermal_zone_bind_cooling_device(struct thermal_zone_device *tz,</span>
 	if (!result) {
 		list_add_tail(&amp;dev-&gt;tz_node, &amp;tz-&gt;thermal_instances);
 		list_add_tail(&amp;dev-&gt;cdev_node, &amp;cdev-&gt;thermal_instances);
<span class="p_add">+		atomic_set(&amp;tz-&gt;need_update, 1);</span>
 	}
 	mutex_unlock(&amp;cdev-&gt;lock);
 	mutex_unlock(&amp;tz-&gt;lock);
<span class="p_chunk">@@ -1385,6 +1406,7 @@</span> <span class="p_context"> __thermal_cooling_device_register(struct device_node *np,</span>
 				  const struct thermal_cooling_device_ops *ops)
 {
 	struct thermal_cooling_device *cdev;
<span class="p_add">+	struct thermal_zone_device *pos = NULL;</span>
 	int result;
 
 	if (type &amp;&amp; strlen(type) &gt;= THERMAL_NAME_LENGTH)
<span class="p_chunk">@@ -1429,6 +1451,12 @@</span> <span class="p_context"> __thermal_cooling_device_register(struct device_node *np,</span>
 	/* Update binding information for &#39;this&#39; new cdev */
 	bind_cdev(cdev);
 
<span class="p_add">+	mutex_lock(&amp;thermal_list_lock);</span>
<span class="p_add">+	list_for_each_entry(pos, &amp;thermal_tz_list, node)</span>
<span class="p_add">+		if (atomic_cmpxchg(&amp;pos-&gt;need_update, 1, 0))</span>
<span class="p_add">+			thermal_zone_device_update(pos);</span>
<span class="p_add">+	mutex_unlock(&amp;thermal_list_lock);</span>
<span class="p_add">+</span>
 	return cdev;
 }
 
<span class="p_chunk">@@ -1761,6 +1789,8 @@</span> <span class="p_context"> struct thermal_zone_device *thermal_zone_device_register(const char *type,</span>
 	tz-&gt;trips = trips;
 	tz-&gt;passive_delay = passive_delay;
 	tz-&gt;polling_delay = polling_delay;
<span class="p_add">+	/* A new thermal zone needs to be updated anyway. */</span>
<span class="p_add">+	atomic_set(&amp;tz-&gt;need_update, 1);</span>
 
 	dev_set_name(&amp;tz-&gt;device, &quot;thermal_zone%d&quot;, tz-&gt;id);
 	result = device_register(&amp;tz-&gt;device);
<span class="p_chunk">@@ -1852,7 +1882,10 @@</span> <span class="p_context"> struct thermal_zone_device *thermal_zone_device_register(const char *type,</span>
 	if (!tz-&gt;ops-&gt;get_temp)
 		thermal_zone_device_set_polling(tz, 0);
 
<span class="p_del">-	thermal_zone_device_update(tz);</span>
<span class="p_add">+	thermal_zone_device_reset(tz);</span>
<span class="p_add">+	/* Update the new thermal zone and mark it as already updated. */</span>
<span class="p_add">+	if (atomic_cmpxchg(&amp;tz-&gt;need_update, 1, 0))</span>
<span class="p_add">+		thermal_zone_device_update(tz);</span>
 
 	return tz;
 
<span class="p_chunk">@@ -2091,6 +2124,36 @@</span> <span class="p_context"> static void thermal_unregister_governors(void)</span>
 	thermal_gov_power_allocator_unregister();
 }
 
<span class="p_add">+static int thermal_pm_notify(struct notifier_block *nb,</span>
<span class="p_add">+				unsigned long mode, void *_unused)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct thermal_zone_device *tz;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (mode) {</span>
<span class="p_add">+	case PM_HIBERNATION_PREPARE:</span>
<span class="p_add">+	case PM_RESTORE_PREPARE:</span>
<span class="p_add">+	case PM_SUSPEND_PREPARE:</span>
<span class="p_add">+		atomic_set(&amp;in_suspend, 1);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case PM_POST_HIBERNATION:</span>
<span class="p_add">+	case PM_POST_RESTORE:</span>
<span class="p_add">+	case PM_POST_SUSPEND:</span>
<span class="p_add">+		atomic_set(&amp;in_suspend, 0);</span>
<span class="p_add">+		list_for_each_entry(tz, &amp;thermal_tz_list, node) {</span>
<span class="p_add">+			thermal_zone_device_reset(tz);</span>
<span class="p_add">+			thermal_zone_device_update(tz);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct notifier_block thermal_pm_nb = {</span>
<span class="p_add">+	.notifier_call = thermal_pm_notify,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int __init thermal_init(void)
 {
 	int result;
<span class="p_chunk">@@ -2111,6 +2174,11 @@</span> <span class="p_context"> static int __init thermal_init(void)</span>
 	if (result)
 		goto exit_netlink;
 
<span class="p_add">+	result = register_pm_notifier(&amp;thermal_pm_nb);</span>
<span class="p_add">+	if (result)</span>
<span class="p_add">+		pr_warn(&quot;Thermal: Can not register suspend notifier, return %d\n&quot;,</span>
<span class="p_add">+			result);</span>
<span class="p_add">+</span>
 	return 0;
 
 exit_netlink:
<span class="p_chunk">@@ -2130,6 +2198,7 @@</span> <span class="p_context"> error:</span>
 
 static void __exit thermal_exit(void)
 {
<span class="p_add">+	unregister_pm_notifier(&amp;thermal_pm_nb);</span>
 	of_thermal_destroy_zones();
 	genetlink_exit();
 	class_unregister(&amp;thermal_class);
<span class="p_header">diff --git a/drivers/thermal/thermal_core.h b/drivers/thermal/thermal_core.h</span>
<span class="p_header">index d7ac1fc..749d41a 100644</span>
<span class="p_header">--- a/drivers/thermal/thermal_core.h</span>
<span class="p_header">+++ b/drivers/thermal/thermal_core.h</span>
<span class="p_chunk">@@ -41,6 +41,7 @@</span> <span class="p_context"> struct thermal_instance {</span>
 	struct thermal_zone_device *tz;
 	struct thermal_cooling_device *cdev;
 	int trip;
<span class="p_add">+	bool initialized;</span>
 	unsigned long upper;	/* Highest cooling state for this trip point */
 	unsigned long lower;	/* Lowest cooling state for this trip point */
 	unsigned long target;	/* expected cooling state */
<span class="p_header">diff --git a/drivers/tty/sysrq.c b/drivers/tty/sysrq.c</span>
<span class="p_header">index b5b4278..e54c7c7 100644</span>
<span class="p_header">--- a/drivers/tty/sysrq.c</span>
<span class="p_header">+++ b/drivers/tty/sysrq.c</span>
<span class="p_chunk">@@ -133,6 +133,12 @@</span> <span class="p_context"> static void sysrq_handle_crash(int key)</span>
 {
 	char *killer = NULL;
 
<span class="p_add">+	/* we need to release the RCU read lock here,</span>
<span class="p_add">+	 * otherwise we get an annoying</span>
<span class="p_add">+	 * &#39;BUG: sleeping function called from invalid context&#39;</span>
<span class="p_add">+	 * complaint from the kernel before the panic.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	rcu_read_unlock();</span>
 	panic_on_oops = 1;	/* force panic */
 	wmb();
 	*killer = 1;
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index b30f55e..8fe947c 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -5046,6 +5046,10 @@</span> <span class="p_context"> static int __init xhci_hcd_init(void)</span>
 	BUILD_BUG_ON(sizeof(struct xhci_intr_reg) != 8*32/8);
 	/* xhci_run_regs has eight fields and embeds 128 xhci_intr_regs */
 	BUILD_BUG_ON(sizeof(struct xhci_run_regs) != (8+8*128)*32/8);
<span class="p_add">+</span>
<span class="p_add">+	if (usb_disabled())</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 7d4f51a..59b2126 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -160,6 +160,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x17F4, 0xAAAA) }, /* Wavesense Jazz blood glucose meter */
 	{ USB_DEVICE(0x1843, 0x0200) }, /* Vaisala USB Instrument Cable */
 	{ USB_DEVICE(0x18EF, 0xE00F) }, /* ELV USB-I2C-Interface */
<span class="p_add">+	{ USB_DEVICE(0x18EF, 0xE025) }, /* ELV Marble Sound Board 1 */</span>
 	{ USB_DEVICE(0x1ADB, 0x0001) }, /* Schweitzer Engineering C662 Cable */
 	{ USB_DEVICE(0x1B1C, 0x1C00) }, /* Corsair USB Dongle */
 	{ USB_DEVICE(0x1BA4, 0x0002) },	/* Silicon Labs 358x factory default */
<span class="p_header">diff --git a/drivers/virtio/virtio_balloon.c b/drivers/virtio/virtio_balloon.c</span>
<span class="p_header">index 82e80e0..18fd1b2 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_balloon.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio_balloon.c</span>
<span class="p_chunk">@@ -205,8 +205,8 @@</span> <span class="p_context"> static unsigned leak_balloon(struct virtio_balloon *vb, size_t num)</span>
 	 */
 	if (vb-&gt;num_pfns != 0)
 		tell_host(vb, vb-&gt;deflate_vq);
<span class="p_del">-	mutex_unlock(&amp;vb-&gt;balloon_lock);</span>
 	release_pages_by_pfn(vb-&gt;pfns, vb-&gt;num_pfns);
<span class="p_add">+	mutex_unlock(&amp;vb-&gt;balloon_lock);</span>
 	return num_freed_pages;
 }
 
<span class="p_header">diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.h</span>
<span class="p_header">index bb25b8d..6bd8ea5 100644</span>
<span class="p_header">--- a/fs/btrfs/ctree.h</span>
<span class="p_header">+++ b/fs/btrfs/ctree.h</span>
<span class="p_chunk">@@ -1544,7 +1544,7 @@</span> <span class="p_context"> struct btrfs_fs_info {</span>
 
 	spinlock_t delayed_iput_lock;
 	struct list_head delayed_iputs;
<span class="p_del">-	struct rw_semaphore delayed_iput_sem;</span>
<span class="p_add">+	struct mutex cleaner_delayed_iput_mutex;</span>
 
 	/* this protects tree_mod_seq_list */
 	spinlock_t tree_mod_seq_lock;
<span class="p_header">diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c</span>
<span class="p_header">index f556c37..36dd336 100644</span>
<span class="p_header">--- a/fs/btrfs/disk-io.c</span>
<span class="p_header">+++ b/fs/btrfs/disk-io.c</span>
<span class="p_chunk">@@ -1772,7 +1772,10 @@</span> <span class="p_context"> static int cleaner_kthread(void *arg)</span>
 			goto sleep;
 		}
 
<span class="p_add">+		mutex_lock(&amp;root-&gt;fs_info-&gt;cleaner_delayed_iput_mutex);</span>
 		btrfs_run_delayed_iputs(root);
<span class="p_add">+		mutex_unlock(&amp;root-&gt;fs_info-&gt;cleaner_delayed_iput_mutex);</span>
<span class="p_add">+</span>
 		again = btrfs_clean_one_deleted_snapshot(root);
 		mutex_unlock(&amp;root-&gt;fs_info-&gt;cleaner_mutex);
 
<span class="p_chunk">@@ -2533,8 +2536,8 @@</span> <span class="p_context"> int open_ctree(struct super_block *sb,</span>
 	mutex_init(&amp;fs_info-&gt;delete_unused_bgs_mutex);
 	mutex_init(&amp;fs_info-&gt;reloc_mutex);
 	mutex_init(&amp;fs_info-&gt;delalloc_root_mutex);
<span class="p_add">+	mutex_init(&amp;fs_info-&gt;cleaner_delayed_iput_mutex);</span>
 	seqlock_init(&amp;fs_info-&gt;profiles_lock);
<span class="p_del">-	init_rwsem(&amp;fs_info-&gt;delayed_iput_sem);</span>
 
 	INIT_LIST_HEAD(&amp;fs_info-&gt;dirty_cowonly_roots);
 	INIT_LIST_HEAD(&amp;fs_info-&gt;space_info);
<span class="p_header">diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c</span>
<span class="p_header">index 5d870c4..c96fa08 100644</span>
<span class="p_header">--- a/fs/btrfs/extent-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/extent-tree.c</span>
<span class="p_chunk">@@ -3950,11 +3950,12 @@</span> <span class="p_context"> commit_trans:</span>
 				if (ret)
 					return ret;
 				/*
<span class="p_del">-				 * make sure that all running delayed iput are</span>
<span class="p_del">-				 * done</span>
<span class="p_add">+				 * The cleaner kthread might still be doing iput</span>
<span class="p_add">+				 * operations. Wait for it to finish so that</span>
<span class="p_add">+				 * more space is released.</span>
 				 */
<span class="p_del">-				down_write(&amp;root-&gt;fs_info-&gt;delayed_iput_sem);</span>
<span class="p_del">-				up_write(&amp;root-&gt;fs_info-&gt;delayed_iput_sem);</span>
<span class="p_add">+				mutex_lock(&amp;root-&gt;fs_info-&gt;cleaner_delayed_iput_mutex);</span>
<span class="p_add">+				mutex_unlock(&amp;root-&gt;fs_info-&gt;cleaner_delayed_iput_mutex);</span>
 				goto again;
 			} else {
 				btrfs_end_transaction(trans, root);
<span class="p_chunk">@@ -10035,7 +10036,7 @@</span> <span class="p_context"> int btrfs_init_space_info(struct btrfs_fs_info *fs_info)</span>
 
 	disk_super = fs_info-&gt;super_copy;
 	if (!btrfs_super_root(disk_super))
<span class="p_del">-		return 1;</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	features = btrfs_super_incompat_flags(disk_super);
 	if (features &amp; BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS)
<span class="p_header">diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c</span>
<span class="p_header">index 9aabff2..f3b2661 100644</span>
<span class="p_header">--- a/fs/btrfs/inode.c</span>
<span class="p_header">+++ b/fs/btrfs/inode.c</span>
<span class="p_chunk">@@ -3116,8 +3116,6 @@</span> <span class="p_context"> void btrfs_run_delayed_iputs(struct btrfs_root *root)</span>
 	if (empty)
 		return;
 
<span class="p_del">-	down_read(&amp;fs_info-&gt;delayed_iput_sem);</span>
<span class="p_del">-</span>
 	spin_lock(&amp;fs_info-&gt;delayed_iput_lock);
 	list_splice_init(&amp;fs_info-&gt;delayed_iputs, &amp;list);
 	spin_unlock(&amp;fs_info-&gt;delayed_iput_lock);
<span class="p_chunk">@@ -3128,8 +3126,6 @@</span> <span class="p_context"> void btrfs_run_delayed_iputs(struct btrfs_root *root)</span>
 		iput(delayed-&gt;inode);
 		kfree(delayed);
 	}
<span class="p_del">-</span>
<span class="p_del">-	up_read(&amp;root-&gt;fs_info-&gt;delayed_iput_sem);</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c</span>
<span class="p_header">index fbe7c10..f3f0cff 100644</span>
<span class="p_header">--- a/fs/btrfs/volumes.c</span>
<span class="p_header">+++ b/fs/btrfs/volumes.c</span>
<span class="p_chunk">@@ -156,6 +156,7 @@</span> <span class="p_context"> static struct btrfs_device *__alloc_device(void)</span>
 	spin_lock_init(&amp;dev-&gt;reada_lock);
 	atomic_set(&amp;dev-&gt;reada_in_flight, 0);
 	atomic_set(&amp;dev-&gt;dev_stats_ccnt, 0);
<span class="p_add">+	btrfs_device_data_ordered_init(dev);</span>
 	INIT_RADIX_TREE(&amp;dev-&gt;reada_zones, GFP_NOFS &amp; ~__GFP_WAIT);
 	INIT_RADIX_TREE(&amp;dev-&gt;reada_extents, GFP_NOFS &amp; ~__GFP_WAIT);
 
<span class="p_chunk">@@ -6476,6 +6477,14 @@</span> <span class="p_context"> int btrfs_read_sys_array(struct btrfs_root *root)</span>
 				goto out_short_read;
 
 			num_stripes = btrfs_chunk_num_stripes(sb, chunk);
<span class="p_add">+			if (!num_stripes) {</span>
<span class="p_add">+				printk(KERN_ERR</span>
<span class="p_add">+	    &quot;BTRFS: invalid number of stripes %u in sys_array at offset %u\n&quot;,</span>
<span class="p_add">+					num_stripes, cur_offset);</span>
<span class="p_add">+				ret = -EIO;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			len = btrfs_chunk_item_size(num_stripes);
 			if (cur_offset + len &gt; array_size)
 				goto out_short_read;
<span class="p_header">diff --git a/fs/cifs/cifs_debug.c b/fs/cifs/cifs_debug.c</span>
<span class="p_header">index 7febcf2..50b2684 100644</span>
<span class="p_header">--- a/fs/cifs/cifs_debug.c</span>
<span class="p_header">+++ b/fs/cifs/cifs_debug.c</span>
<span class="p_chunk">@@ -50,7 +50,7 @@</span> <span class="p_context"> void cifs_vfs_err(const char *fmt, ...)</span>
 	vaf.fmt = fmt;
 	vaf.va = &amp;args;
 
<span class="p_del">-	pr_err(&quot;CIFS VFS: %pV&quot;, &amp;vaf);</span>
<span class="p_add">+	pr_err_ratelimited(&quot;CIFS VFS: %pV&quot;, &amp;vaf);</span>
 
 	va_end(args);
 }
<span class="p_header">diff --git a/fs/cifs/cifs_debug.h b/fs/cifs/cifs_debug.h</span>
<span class="p_header">index f40fbac..66cf0f9 100644</span>
<span class="p_header">--- a/fs/cifs/cifs_debug.h</span>
<span class="p_header">+++ b/fs/cifs/cifs_debug.h</span>
<span class="p_chunk">@@ -51,14 +51,13 @@</span> <span class="p_context"> __printf(1, 2) void cifs_vfs_err(const char *fmt, ...);</span>
 /* information message: e.g., configuration, major event */
 #define cifs_dbg(type, fmt, ...)					\
 do {									\
<span class="p_del">-	if (type == FYI) {						\</span>
<span class="p_del">-		if (cifsFYI &amp; CIFS_INFO) {				\</span>
<span class="p_del">-			pr_debug(&quot;%s: &quot; fmt, __FILE__, ##__VA_ARGS__);	\</span>
<span class="p_del">-		}							\</span>
<span class="p_add">+	if (type == FYI &amp;&amp; cifsFYI &amp; CIFS_INFO) {			\</span>
<span class="p_add">+		pr_debug_ratelimited(&quot;%s: &quot;				\</span>
<span class="p_add">+			    fmt, __FILE__, ##__VA_ARGS__);		\</span>
 	} else if (type == VFS) {					\
 		cifs_vfs_err(fmt, ##__VA_ARGS__);			\
 	} else if (type == NOISY &amp;&amp; type != 0) {			\
<span class="p_del">-		pr_debug(fmt, ##__VA_ARGS__);				\</span>
<span class="p_add">+		pr_debug_ratelimited(fmt, ##__VA_ARGS__);		\</span>
 	}								\
 } while (0)
 
<span class="p_header">diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c</span>
<span class="p_header">index 773f4dc..f72a8a1 100644</span>
<span class="p_header">--- a/fs/cifs/connect.c</span>
<span class="p_header">+++ b/fs/cifs/connect.c</span>
<span class="p_chunk">@@ -362,7 +362,6 @@</span> <span class="p_context"> cifs_reconnect(struct TCP_Server_Info *server)</span>
 	server-&gt;session_key.response = NULL;
 	server-&gt;session_key.len = 0;
 	server-&gt;lstrp = jiffies;
<span class="p_del">-	mutex_unlock(&amp;server-&gt;srv_mutex);</span>
 
 	/* mark submitted MIDs for retry and issue callback */
 	INIT_LIST_HEAD(&amp;retry_list);
<span class="p_chunk">@@ -375,6 +374,7 @@</span> <span class="p_context"> cifs_reconnect(struct TCP_Server_Info *server)</span>
 		list_move(&amp;mid_entry-&gt;qhead, &amp;retry_list);
 	}
 	spin_unlock(&amp;GlobalMid_Lock);
<span class="p_add">+	mutex_unlock(&amp;server-&gt;srv_mutex);</span>
 
 	cifs_dbg(FYI, &quot;%s: issuing mid callbacks\n&quot;, __func__);
 	list_for_each_safe(tmp, tmp2, &amp;retry_list) {
<span class="p_header">diff --git a/fs/cifs/readdir.c b/fs/cifs/readdir.c</span>
<span class="p_header">index b1eede3..3634c7a 100644</span>
<span class="p_header">--- a/fs/cifs/readdir.c</span>
<span class="p_header">+++ b/fs/cifs/readdir.c</span>
<span class="p_chunk">@@ -847,6 +847,7 @@</span> <span class="p_context"> int cifs_readdir(struct file *file, struct dir_context *ctx)</span>
 		 * if buggy server returns . and .. late do we want to
 		 * check for that here?
 		 */
<span class="p_add">+		*tmp_buf = 0;</span>
 		rc = cifs_filldir(current_entry, file, ctx,
 				  tmp_buf, max_len);
 		if (rc) {
<span class="p_header">diff --git a/fs/cifs/transport.c b/fs/cifs/transport.c</span>
<span class="p_header">index 126f46b..66106f6 100644</span>
<span class="p_header">--- a/fs/cifs/transport.c</span>
<span class="p_header">+++ b/fs/cifs/transport.c</span>
<span class="p_chunk">@@ -576,14 +576,16 @@</span> <span class="p_context"> cifs_call_async(struct TCP_Server_Info *server, struct smb_rqst *rqst,</span>
 	cifs_in_send_dec(server);
 	cifs_save_when_sent(mid);
 
<span class="p_del">-	if (rc &lt; 0)</span>
<span class="p_add">+	if (rc &lt; 0) {</span>
 		server-&gt;sequence_number -= 2;
<span class="p_add">+		cifs_delete_mid(mid);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	mutex_unlock(&amp;server-&gt;srv_mutex);
 
 	if (rc == 0)
 		return 0;
 
<span class="p_del">-	cifs_delete_mid(mid);</span>
 	add_credits_and_wake_if(server, credits, optype);
 	return rc;
 }
<span class="p_header">diff --git a/fs/ext4/crypto_key.c b/fs/ext4/crypto_key.c</span>
<span class="p_header">index 9bad113..5c13735 100644</span>
<span class="p_header">--- a/fs/ext4/crypto_key.c</span>
<span class="p_header">+++ b/fs/ext4/crypto_key.c</span>
<span class="p_chunk">@@ -213,9 +213,11 @@</span> <span class="p_context"> retry:</span>
 		res = -ENOKEY;
 		goto out;
 	}
<span class="p_add">+	down_read(&amp;keyring_key-&gt;sem);</span>
 	ukp = ((struct user_key_payload *)keyring_key-&gt;payload.data);
 	if (ukp-&gt;datalen != sizeof(struct ext4_encryption_key)) {
 		res = -EINVAL;
<span class="p_add">+		up_read(&amp;keyring_key-&gt;sem);</span>
 		goto out;
 	}
 	master_key = (struct ext4_encryption_key *)ukp-&gt;data;
<span class="p_chunk">@@ -226,10 +228,14 @@</span> <span class="p_context"> retry:</span>
 			    &quot;ext4: key size incorrect: %d\n&quot;,
 			    master_key-&gt;size);
 		res = -ENOKEY;
<span class="p_add">+		up_read(&amp;keyring_key-&gt;sem);</span>
 		goto out;
 	}
 	res = ext4_derive_key_aes(ctx.nonce, master_key-&gt;raw,
 				  raw_key);
<span class="p_add">+	up_read(&amp;keyring_key-&gt;sem);</span>
<span class="p_add">+	if (res)</span>
<span class="p_add">+		goto out;</span>
 got_key:
 	ctfm = crypto_alloc_ablkcipher(cipher_str, 0, 0);
 	if (!ctfm || IS_ERR(ctfm)) {
<span class="p_header">diff --git a/fs/hostfs/hostfs_kern.c b/fs/hostfs/hostfs_kern.c</span>
<span class="p_header">index 2ac99db..5a7b322 100644</span>
<span class="p_header">--- a/fs/hostfs/hostfs_kern.c</span>
<span class="p_header">+++ b/fs/hostfs/hostfs_kern.c</span>
<span class="p_chunk">@@ -730,15 +730,13 @@</span> <span class="p_context"> static int hostfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,</span>
 
 	init_special_inode(inode, mode, dev);
 	err = do_mknod(name, mode, MAJOR(dev), MINOR(dev));
<span class="p_del">-	if (!err)</span>
<span class="p_add">+	if (err)</span>
 		goto out_free;
 
 	err = read_name(inode, name);
 	__putname(name);
 	if (err)
 		goto out_put;
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto out_put;</span>
 
 	d_instantiate(dentry, inode);
 	return 0;
<span class="p_header">diff --git a/fs/locks.c b/fs/locks.c</span>
<span class="p_header">index d3d558b..8501eec 100644</span>
<span class="p_header">--- a/fs/locks.c</span>
<span class="p_header">+++ b/fs/locks.c</span>
<span class="p_chunk">@@ -2154,7 +2154,6 @@</span> <span class="p_context"> int fcntl_setlk(unsigned int fd, struct file *filp, unsigned int cmd,</span>
 		goto out;
 	}
 
<span class="p_del">-again:</span>
 	error = flock_to_posix_lock(filp, file_lock, &amp;flock);
 	if (error)
 		goto out;
<span class="p_chunk">@@ -2196,19 +2195,22 @@</span> <span class="p_context"> again:</span>
 	 * Attempt to detect a close/fcntl race and recover by
 	 * releasing the lock that was just acquired.
 	 */
<span class="p_del">-	/*</span>
<span class="p_del">-	 * we need that spin_lock here - it prevents reordering between</span>
<span class="p_del">-	 * update of i_flctx-&gt;flc_posix and check for it done in close().</span>
<span class="p_del">-	 * rcu_read_lock() wouldn&#39;t do.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	spin_lock(&amp;current-&gt;files-&gt;file_lock);</span>
<span class="p_del">-	f = fcheck(fd);</span>
<span class="p_del">-	spin_unlock(&amp;current-&gt;files-&gt;file_lock);</span>
<span class="p_del">-	if (!error &amp;&amp; f != filp &amp;&amp; flock.l_type != F_UNLCK) {</span>
<span class="p_del">-		flock.l_type = F_UNLCK;</span>
<span class="p_del">-		goto again;</span>
<span class="p_add">+	if (!error &amp;&amp; file_lock-&gt;fl_type != F_UNLCK) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We need that spin_lock here - it prevents reordering between</span>
<span class="p_add">+		 * update of i_flctx-&gt;flc_posix and check for it done in</span>
<span class="p_add">+		 * close(). rcu_read_lock() wouldn&#39;t do.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		spin_lock(&amp;current-&gt;files-&gt;file_lock);</span>
<span class="p_add">+		f = fcheck(fd);</span>
<span class="p_add">+		spin_unlock(&amp;current-&gt;files-&gt;file_lock);</span>
<span class="p_add">+		if (f != filp) {</span>
<span class="p_add">+			file_lock-&gt;fl_type = F_UNLCK;</span>
<span class="p_add">+			error = do_lock_file_wait(filp, cmd, file_lock);</span>
<span class="p_add">+			WARN_ON_ONCE(error);</span>
<span class="p_add">+			error = -EBADF;</span>
<span class="p_add">+		}</span>
 	}
<span class="p_del">-</span>
 out:
 	locks_free_lock(file_lock);
 	return error;
<span class="p_chunk">@@ -2294,7 +2296,6 @@</span> <span class="p_context"> int fcntl_setlk64(unsigned int fd, struct file *filp, unsigned int cmd,</span>
 		goto out;
 	}
 
<span class="p_del">-again:</span>
 	error = flock64_to_posix_lock(filp, file_lock, &amp;flock);
 	if (error)
 		goto out;
<span class="p_chunk">@@ -2336,14 +2337,22 @@</span> <span class="p_context"> again:</span>
 	 * Attempt to detect a close/fcntl race and recover by
 	 * releasing the lock that was just acquired.
 	 */
<span class="p_del">-	spin_lock(&amp;current-&gt;files-&gt;file_lock);</span>
<span class="p_del">-	f = fcheck(fd);</span>
<span class="p_del">-	spin_unlock(&amp;current-&gt;files-&gt;file_lock);</span>
<span class="p_del">-	if (!error &amp;&amp; f != filp &amp;&amp; flock.l_type != F_UNLCK) {</span>
<span class="p_del">-		flock.l_type = F_UNLCK;</span>
<span class="p_del">-		goto again;</span>
<span class="p_add">+	if (!error &amp;&amp; file_lock-&gt;fl_type != F_UNLCK) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We need that spin_lock here - it prevents reordering between</span>
<span class="p_add">+		 * update of i_flctx-&gt;flc_posix and check for it done in</span>
<span class="p_add">+		 * close(). rcu_read_lock() wouldn&#39;t do.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		spin_lock(&amp;current-&gt;files-&gt;file_lock);</span>
<span class="p_add">+		f = fcheck(fd);</span>
<span class="p_add">+		spin_unlock(&amp;current-&gt;files-&gt;file_lock);</span>
<span class="p_add">+		if (f != filp) {</span>
<span class="p_add">+			file_lock-&gt;fl_type = F_UNLCK;</span>
<span class="p_add">+			error = do_lock_file_wait(filp, cmd, file_lock);</span>
<span class="p_add">+			WARN_ON_ONCE(error);</span>
<span class="p_add">+			error = -EBADF;</span>
<span class="p_add">+		}</span>
 	}
<span class="p_del">-</span>
 out:
 	locks_free_lock(file_lock);
 	return error;
<span class="p_header">diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c</span>
<span class="p_header">index 547308a..fccbda7 100644</span>
<span class="p_header">--- a/fs/nfs/dir.c</span>
<span class="p_header">+++ b/fs/nfs/dir.c</span>
<span class="p_chunk">@@ -2443,6 +2443,20 @@</span> <span class="p_context"> int nfs_may_open(struct inode *inode, struct rpc_cred *cred, int openflags)</span>
 }
 EXPORT_SYMBOL_GPL(nfs_may_open);
 
<span class="p_add">+static int nfs_execute_ok(struct inode *inode, int mask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct nfs_server *server = NFS_SERVER(inode);</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mask &amp; MAY_NOT_BLOCK)</span>
<span class="p_add">+		ret = nfs_revalidate_inode_rcu(server, inode);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ret = nfs_revalidate_inode(server, inode);</span>
<span class="p_add">+	if (ret == 0 &amp;&amp; !execute_ok(inode))</span>
<span class="p_add">+		ret = -EACCES;</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int nfs_permission(struct inode *inode, int mask)
 {
 	struct rpc_cred *cred;
<span class="p_chunk">@@ -2460,6 +2474,9 @@</span> <span class="p_context"> int nfs_permission(struct inode *inode, int mask)</span>
 		case S_IFLNK:
 			goto out;
 		case S_IFREG:
<span class="p_add">+			if ((mask &amp; MAY_OPEN) &amp;&amp;</span>
<span class="p_add">+			   nfs_server_capable(inode, NFS_CAP_ATOMIC_OPEN))</span>
<span class="p_add">+				return 0;</span>
 			break;
 		case S_IFDIR:
 			/*
<span class="p_chunk">@@ -2492,8 +2509,8 @@</span> <span class="p_context"> force_lookup:</span>
 			res = PTR_ERR(cred);
 	}
 out:
<span class="p_del">-	if (!res &amp;&amp; (mask &amp; MAY_EXEC) &amp;&amp; !execute_ok(inode))</span>
<span class="p_del">-		res = -EACCES;</span>
<span class="p_add">+	if (!res &amp;&amp; (mask &amp; MAY_EXEC))</span>
<span class="p_add">+		res = nfs_execute_ok(inode, mask);</span>
 
 	dfprintk(VFS, &quot;NFS: permission(%s/%lu), mask=0x%x, res=%d\n&quot;,
 		inode-&gt;i_sb-&gt;s_id, inode-&gt;i_ino, mask, res);
<span class="p_header">diff --git a/fs/nfs/flexfilelayout/flexfilelayout.c b/fs/nfs/flexfilelayout/flexfilelayout.c</span>
<span class="p_header">index 14e3b1e..c5f37bb 100644</span>
<span class="p_header">--- a/fs/nfs/flexfilelayout/flexfilelayout.c</span>
<span class="p_header">+++ b/fs/nfs/flexfilelayout/flexfilelayout.c</span>
<span class="p_chunk">@@ -1683,11 +1683,9 @@</span> <span class="p_context"> ff_layout_encode_layoutreturn(struct pnfs_layout_hdr *lo,</span>
 	start = xdr_reserve_space(xdr, 4);
 	BUG_ON(!start);
 
<span class="p_del">-	if (ff_layout_encode_ioerr(flo, xdr, args))</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_add">+	ff_layout_encode_ioerr(flo, xdr, args);</span>
 	ff_layout_encode_iostats(flo, xdr, args);
<span class="p_del">-out:</span>
<span class="p_add">+</span>
 	*start = cpu_to_be32((xdr-&gt;p - start - 1) * 4);
 	dprintk(&quot;%s: Return\n&quot;, __func__);
 }
<span class="p_header">diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c</span>
<span class="p_header">index 1c65e3f..7bf2c65 100644</span>
<span class="p_header">--- a/fs/nfs/inode.c</span>
<span class="p_header">+++ b/fs/nfs/inode.c</span>
<span class="p_chunk">@@ -1630,6 +1630,7 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 	unsigned long invalid = 0;
 	unsigned long now = jiffies;
 	unsigned long save_cache_validity;
<span class="p_add">+	bool cache_revalidated = true;</span>
 
 	dfprintk(VFS, &quot;NFS: %s(%s/%lu fh_crc=0x%08x ct=%d info=0x%x)\n&quot;,
 			__func__, inode-&gt;i_sb-&gt;s_id, inode-&gt;i_ino,
<span class="p_chunk">@@ -1691,22 +1692,28 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 				nfs_force_lookup_revalidate(inode);
 			inode-&gt;i_version = fattr-&gt;change_attr;
 		}
<span class="p_del">-	} else</span>
<span class="p_add">+	} else {</span>
 		nfsi-&gt;cache_validity |= save_cache_validity;
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_MTIME) {
 		memcpy(&amp;inode-&gt;i_mtime, &amp;fattr-&gt;mtime, sizeof(inode-&gt;i_mtime));
<span class="p_del">-	} else if (server-&gt;caps &amp; NFS_CAP_MTIME)</span>
<span class="p_add">+	} else if (server-&gt;caps &amp; NFS_CAP_MTIME) {</span>
 		nfsi-&gt;cache_validity |= save_cache_validity &amp;
 				(NFS_INO_INVALID_ATTR
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_CTIME) {
 		memcpy(&amp;inode-&gt;i_ctime, &amp;fattr-&gt;ctime, sizeof(inode-&gt;i_ctime));
<span class="p_del">-	} else if (server-&gt;caps &amp; NFS_CAP_CTIME)</span>
<span class="p_add">+	} else if (server-&gt;caps &amp; NFS_CAP_CTIME) {</span>
 		nfsi-&gt;cache_validity |= save_cache_validity &amp;
 				(NFS_INO_INVALID_ATTR
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	/* Check if our cached file size is stale */
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_SIZE) {
<span class="p_chunk">@@ -1726,19 +1733,23 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 					(long long)cur_isize,
 					(long long)new_isize);
 		}
<span class="p_del">-	} else</span>
<span class="p_add">+	} else {</span>
 		nfsi-&gt;cache_validity |= save_cache_validity &amp;
 				(NFS_INO_INVALID_ATTR
 				| NFS_INO_REVAL_PAGECACHE
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_ATIME)
 		memcpy(&amp;inode-&gt;i_atime, &amp;fattr-&gt;atime, sizeof(inode-&gt;i_atime));
<span class="p_del">-	else if (server-&gt;caps &amp; NFS_CAP_ATIME)</span>
<span class="p_add">+	else if (server-&gt;caps &amp; NFS_CAP_ATIME) {</span>
 		nfsi-&gt;cache_validity |= save_cache_validity &amp;
 				(NFS_INO_INVALID_ATIME
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_MODE) {
 		if ((inode-&gt;i_mode &amp; S_IALLUGO) != (fattr-&gt;mode &amp; S_IALLUGO)) {
<span class="p_chunk">@@ -1747,36 +1758,42 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 			inode-&gt;i_mode = newmode;
 			invalid |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL;
 		}
<span class="p_del">-	} else if (server-&gt;caps &amp; NFS_CAP_MODE)</span>
<span class="p_add">+	} else if (server-&gt;caps &amp; NFS_CAP_MODE) {</span>
 		nfsi-&gt;cache_validity |= save_cache_validity &amp;
 				(NFS_INO_INVALID_ATTR
 				| NFS_INO_INVALID_ACCESS
 				| NFS_INO_INVALID_ACL
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_OWNER) {
 		if (!uid_eq(inode-&gt;i_uid, fattr-&gt;uid)) {
 			invalid |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL;
 			inode-&gt;i_uid = fattr-&gt;uid;
 		}
<span class="p_del">-	} else if (server-&gt;caps &amp; NFS_CAP_OWNER)</span>
<span class="p_add">+	} else if (server-&gt;caps &amp; NFS_CAP_OWNER) {</span>
 		nfsi-&gt;cache_validity |= save_cache_validity &amp;
 				(NFS_INO_INVALID_ATTR
 				| NFS_INO_INVALID_ACCESS
 				| NFS_INO_INVALID_ACL
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_GROUP) {
 		if (!gid_eq(inode-&gt;i_gid, fattr-&gt;gid)) {
 			invalid |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL;
 			inode-&gt;i_gid = fattr-&gt;gid;
 		}
<span class="p_del">-	} else if (server-&gt;caps &amp; NFS_CAP_OWNER_GROUP)</span>
<span class="p_add">+	} else if (server-&gt;caps &amp; NFS_CAP_OWNER_GROUP) {</span>
 		nfsi-&gt;cache_validity |= save_cache_validity &amp;
 				(NFS_INO_INVALID_ATTR
 				| NFS_INO_INVALID_ACCESS
 				| NFS_INO_INVALID_ACL
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_NLINK) {
 		if (inode-&gt;i_nlink != fattr-&gt;nlink) {
<span class="p_chunk">@@ -1785,19 +1802,22 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 				invalid |= NFS_INO_INVALID_DATA;
 			set_nlink(inode, fattr-&gt;nlink);
 		}
<span class="p_del">-	} else if (server-&gt;caps &amp; NFS_CAP_NLINK)</span>
<span class="p_add">+	} else if (server-&gt;caps &amp; NFS_CAP_NLINK) {</span>
 		nfsi-&gt;cache_validity |= save_cache_validity &amp;
 				(NFS_INO_INVALID_ATTR
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_SPACE_USED) {
 		/*
 		 * report the blocks in 512byte units
 		 */
 		inode-&gt;i_blocks = nfs_calc_block_size(fattr-&gt;du.nfs3.used);
<span class="p_del">- 	}</span>
<span class="p_del">-	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_BLOCKS_USED)</span>
<span class="p_add">+	} else if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_BLOCKS_USED)</span>
 		inode-&gt;i_blocks = fattr-&gt;du.nfs2.blocks;
<span class="p_add">+	else</span>
<span class="p_add">+		cache_revalidated = false;</span>
 
 	/* Update attrtimeo value if we&#39;re out of the unstable period */
 	if (invalid &amp; NFS_INO_INVALID_ATTR) {
<span class="p_chunk">@@ -1807,9 +1827,13 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 		/* Set barrier to be more recent than all outstanding updates */
 		nfsi-&gt;attr_gencount = nfs_inc_attr_generation_counter();
 	} else {
<span class="p_del">-		if (!time_in_range_open(now, nfsi-&gt;attrtimeo_timestamp, nfsi-&gt;attrtimeo_timestamp + nfsi-&gt;attrtimeo)) {</span>
<span class="p_del">-			if ((nfsi-&gt;attrtimeo &lt;&lt;= 1) &gt; NFS_MAXATTRTIMEO(inode))</span>
<span class="p_del">-				nfsi-&gt;attrtimeo = NFS_MAXATTRTIMEO(inode);</span>
<span class="p_add">+		if (cache_revalidated) {</span>
<span class="p_add">+			if (!time_in_range_open(now, nfsi-&gt;attrtimeo_timestamp,</span>
<span class="p_add">+				nfsi-&gt;attrtimeo_timestamp + nfsi-&gt;attrtimeo)) {</span>
<span class="p_add">+				nfsi-&gt;attrtimeo &lt;&lt;= 1;</span>
<span class="p_add">+				if (nfsi-&gt;attrtimeo &gt; NFS_MAXATTRTIMEO(inode))</span>
<span class="p_add">+					nfsi-&gt;attrtimeo = NFS_MAXATTRTIMEO(inode);</span>
<span class="p_add">+			}</span>
 			nfsi-&gt;attrtimeo_timestamp = now;
 		}
 		/* Set the barrier to be more recent than this fattr */
<span class="p_chunk">@@ -1818,7 +1842,7 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 	}
 
 	/* Don&#39;t declare attrcache up to date if there were no attrs! */
<span class="p_del">-	if (fattr-&gt;valid != 0)</span>
<span class="p_add">+	if (cache_revalidated)</span>
 		invalid &amp;= ~NFS_INO_INVALID_ATTR;
 
 	/* Don&#39;t invalidate the data if we were to blame */
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index d2daaca..71e6b1b 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -1303,6 +1303,7 @@</span> <span class="p_context"> static void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_s</span>
 	 * Protect the call to nfs4_state_set_mode_locked and
 	 * serialise the stateid update
 	 */
<span class="p_add">+	spin_lock(&amp;state-&gt;owner-&gt;so_lock);</span>
 	write_seqlock(&amp;state-&gt;seqlock);
 	if (deleg_stateid != NULL) {
 		nfs4_stateid_copy(&amp;state-&gt;stateid, deleg_stateid);
<span class="p_chunk">@@ -1311,7 +1312,6 @@</span> <span class="p_context"> static void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_s</span>
 	if (open_stateid != NULL)
 		nfs_set_open_stateid_locked(state, open_stateid, fmode);
 	write_sequnlock(&amp;state-&gt;seqlock);
<span class="p_del">-	spin_lock(&amp;state-&gt;owner-&gt;so_lock);</span>
 	update_open_stateflags(state, fmode);
 	spin_unlock(&amp;state-&gt;owner-&gt;so_lock);
 }
<span class="p_header">diff --git a/fs/ocfs2/dlm/dlmmaster.c b/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_header">index 482cfd3..523e485 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_chunk">@@ -2518,6 +2518,11 @@</span> <span class="p_context"> static int dlm_migrate_lockres(struct dlm_ctxt *dlm,</span>
 	spin_lock(&amp;dlm-&gt;master_lock);
 	ret = dlm_add_migration_mle(dlm, res, mle, &amp;oldmle, name,
 				    namelen, target, dlm-&gt;node_num);
<span class="p_add">+	/* get an extra reference on the mle.</span>
<span class="p_add">+	 * otherwise the assert_master from the new</span>
<span class="p_add">+	 * master will destroy this.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	dlm_get_mle_inuse(mle);</span>
 	spin_unlock(&amp;dlm-&gt;master_lock);
 	spin_unlock(&amp;dlm-&gt;spinlock);
 
<span class="p_chunk">@@ -2553,6 +2558,7 @@</span> <span class="p_context"> fail:</span>
 		if (mle_added) {
 			dlm_mle_detach_hb_events(dlm, mle);
 			dlm_put_mle(mle);
<span class="p_add">+			dlm_put_mle_inuse(mle);</span>
 		} else if (mle) {
 			kmem_cache_free(dlm_mle_cache, mle);
 			mle = NULL;
<span class="p_chunk">@@ -2570,17 +2576,6 @@</span> <span class="p_context"> fail:</span>
 	 * ensure that all assert_master work is flushed. */
 	flush_workqueue(dlm-&gt;dlm_worker);
 
<span class="p_del">-	/* get an extra reference on the mle.</span>
<span class="p_del">-	 * otherwise the assert_master from the new</span>
<span class="p_del">-	 * master will destroy this.</span>
<span class="p_del">-	 * also, make sure that all callers of dlm_get_mle</span>
<span class="p_del">-	 * take both dlm-&gt;spinlock and dlm-&gt;master_lock */</span>
<span class="p_del">-	spin_lock(&amp;dlm-&gt;spinlock);</span>
<span class="p_del">-	spin_lock(&amp;dlm-&gt;master_lock);</span>
<span class="p_del">-	dlm_get_mle_inuse(mle);</span>
<span class="p_del">-	spin_unlock(&amp;dlm-&gt;master_lock);</span>
<span class="p_del">-	spin_unlock(&amp;dlm-&gt;spinlock);</span>
<span class="p_del">-</span>
 	/* notify new node and send all lock state */
 	/* call send_one_lockres with migration flag.
 	 * this serves as notice to the target node that a
<span class="p_chunk">@@ -3309,6 +3304,15 @@</span> <span class="p_context"> top:</span>
 			    mle-&gt;new_master != dead_node)
 				continue;
 
<span class="p_add">+			if (mle-&gt;new_master == dead_node &amp;&amp; mle-&gt;inuse) {</span>
<span class="p_add">+				mlog(ML_NOTICE, &quot;%s: target %u died during &quot;</span>
<span class="p_add">+						&quot;migration from %u, the MLE is &quot;</span>
<span class="p_add">+						&quot;still keep used, ignore it!\n&quot;,</span>
<span class="p_add">+						dlm-&gt;name, dead_node,</span>
<span class="p_add">+						mle-&gt;master);</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			/* If we have reached this point, this mle needs to be
 			 * removed from the list and freed. */
 			dlm_clean_migration_mle(dlm, mle);
<span class="p_header">diff --git a/fs/ocfs2/dlmglue.c b/fs/ocfs2/dlmglue.c</span>
<span class="p_header">index 23157e4..3623ab6 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlmglue.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlmglue.c</span>
<span class="p_chunk">@@ -1390,6 +1390,7 @@</span> <span class="p_context"> static int __ocfs2_cluster_lock(struct ocfs2_super *osb,</span>
 	unsigned int gen;
 	int noqueue_attempted = 0;
 	int dlm_locked = 0;
<span class="p_add">+	int kick_dc = 0;</span>
 
 	if (!(lockres-&gt;l_flags &amp; OCFS2_LOCK_INITIALIZED)) {
 		mlog_errno(-EINVAL);
<span class="p_chunk">@@ -1524,7 +1525,12 @@</span> <span class="p_context"> update_holders:</span>
 unlock:
 	lockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);
 
<span class="p_add">+	/* ocfs2_unblock_lock reques on seeing OCFS2_LOCK_UPCONVERT_FINISHING */</span>
<span class="p_add">+	kick_dc = (lockres-&gt;l_flags &amp; OCFS2_LOCK_BLOCKED);</span>
<span class="p_add">+</span>
 	spin_unlock_irqrestore(&amp;lockres-&gt;l_lock, flags);
<span class="p_add">+	if (kick_dc)</span>
<span class="p_add">+		ocfs2_wake_downconvert_thread(osb);</span>
 out:
 	/*
 	 * This is helping work around a lock inversion between the page lock
<span class="p_header">diff --git a/fs/overlayfs/copy_up.c b/fs/overlayfs/copy_up.c</span>
<span class="p_header">index 871fcb6..758012b 100644</span>
<span class="p_header">--- a/fs/overlayfs/copy_up.c</span>
<span class="p_header">+++ b/fs/overlayfs/copy_up.c</span>
<span class="p_chunk">@@ -22,9 +22,9 @@</span> <span class="p_context"></span>
 
 int ovl_copy_xattr(struct dentry *old, struct dentry *new)
 {
<span class="p_del">-	ssize_t list_size, size;</span>
<span class="p_del">-	char *buf, *name, *value;</span>
<span class="p_del">-	int error;</span>
<span class="p_add">+	ssize_t list_size, size, value_size = 0;</span>
<span class="p_add">+	char *buf, *name, *value = NULL;</span>
<span class="p_add">+	int uninitialized_var(error);</span>
 
 	if (!old-&gt;d_inode-&gt;i_op-&gt;getxattr ||
 	    !new-&gt;d_inode-&gt;i_op-&gt;getxattr)
<span class="p_chunk">@@ -41,29 +41,40 @@</span> <span class="p_context"> int ovl_copy_xattr(struct dentry *old, struct dentry *new)</span>
 	if (!buf)
 		return -ENOMEM;
 
<span class="p_del">-	error = -ENOMEM;</span>
<span class="p_del">-	value = kmalloc(XATTR_SIZE_MAX, GFP_KERNEL);</span>
<span class="p_del">-	if (!value)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
 	list_size = vfs_listxattr(old, buf, list_size);
 	if (list_size &lt;= 0) {
 		error = list_size;
<span class="p_del">-		goto out_free_value;</span>
<span class="p_add">+		goto out;</span>
 	}
 
 	for (name = buf; name &lt; (buf + list_size); name += strlen(name) + 1) {
<span class="p_del">-		size = vfs_getxattr(old, name, value, XATTR_SIZE_MAX);</span>
<span class="p_del">-		if (size &lt;= 0) {</span>
<span class="p_add">+retry:</span>
<span class="p_add">+		size = vfs_getxattr(old, name, value, value_size);</span>
<span class="p_add">+		if (size == -ERANGE)</span>
<span class="p_add">+			size = vfs_getxattr(old, name, NULL, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (size &lt; 0) {</span>
 			error = size;
<span class="p_del">-			goto out_free_value;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (size &gt; value_size) {</span>
<span class="p_add">+			void *new;</span>
<span class="p_add">+</span>
<span class="p_add">+			new = krealloc(value, size, GFP_KERNEL);</span>
<span class="p_add">+			if (!new) {</span>
<span class="p_add">+				error = -ENOMEM;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			value = new;</span>
<span class="p_add">+			value_size = size;</span>
<span class="p_add">+			goto retry;</span>
 		}
<span class="p_add">+</span>
 		error = vfs_setxattr(new, name, value, size, 0);
 		if (error)
<span class="p_del">-			goto out_free_value;</span>
<span class="p_add">+			break;</span>
 	}
<span class="p_del">-</span>
<span class="p_del">-out_free_value:</span>
 	kfree(value);
 out:
 	kfree(buf);
<span class="p_header">diff --git a/fs/overlayfs/inode.c b/fs/overlayfs/inode.c</span>
<span class="p_header">index 9612849..34300c2 100644</span>
<span class="p_header">--- a/fs/overlayfs/inode.c</span>
<span class="p_header">+++ b/fs/overlayfs/inode.c</span>
<span class="p_chunk">@@ -45,6 +45,19 @@</span> <span class="p_context"> int ovl_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	int err;
 	struct dentry *upperdentry;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check for permissions before trying to copy-up.  This is redundant</span>
<span class="p_add">+	 * since it will be rechecked later by -&gt;setattr() on upper dentry.  But</span>
<span class="p_add">+	 * without this, copy-up can be triggered by just about anybody.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We don&#39;t initialize inode-&gt;size, which just means that</span>
<span class="p_add">+	 * inode_newsize_ok() will always check against MAX_LFS_FILESIZE and not</span>
<span class="p_add">+	 * check for a swapfile (which this won&#39;t be anyway).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	err = inode_change_ok(dentry-&gt;d_inode, attr);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
 	err = ovl_want_write(dentry);
 	if (err)
 		goto out;
<span class="p_header">diff --git a/fs/overlayfs/readdir.c b/fs/overlayfs/readdir.c</span>
<span class="p_header">index 70e9af5..adcb139 100644</span>
<span class="p_header">--- a/fs/overlayfs/readdir.c</span>
<span class="p_header">+++ b/fs/overlayfs/readdir.c</span>
<span class="p_chunk">@@ -571,7 +571,8 @@</span> <span class="p_context"> void ovl_cleanup_whiteouts(struct dentry *upper, struct list_head *list)</span>
 			       (int) PTR_ERR(dentry));
 			continue;
 		}
<span class="p_del">-		ovl_cleanup(upper-&gt;d_inode, dentry);</span>
<span class="p_add">+		if (dentry-&gt;d_inode)</span>
<span class="p_add">+			ovl_cleanup(upper-&gt;d_inode, dentry);</span>
 		dput(dentry);
 	}
 	mutex_unlock(&amp;upper-&gt;d_inode-&gt;i_mutex);
<span class="p_header">diff --git a/fs/overlayfs/super.c b/fs/overlayfs/super.c</span>
<span class="p_header">index e38ee0f..f42c940 100644</span>
<span class="p_header">--- a/fs/overlayfs/super.c</span>
<span class="p_header">+++ b/fs/overlayfs/super.c</span>
<span class="p_chunk">@@ -9,6 +9,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/fs.h&gt;
 #include &lt;linux/namei.h&gt;
<span class="p_add">+#include &lt;linux/pagemap.h&gt;</span>
 #include &lt;linux/xattr.h&gt;
 #include &lt;linux/security.h&gt;
 #include &lt;linux/mount.h&gt;
<span class="p_chunk">@@ -910,6 +911,7 @@</span> <span class="p_context"> static int ovl_fill_super(struct super_block *sb, void *data, int silent)</span>
 	}
 
 	sb-&gt;s_stack_depth = 0;
<span class="p_add">+	sb-&gt;s_maxbytes = MAX_LFS_FILESIZE;</span>
 	if (ufs-&gt;config.upperdir) {
 		if (!ufs-&gt;config.workdir) {
 			pr_err(&quot;overlayfs: missing &#39;workdir&#39;\n&quot;);
<span class="p_chunk">@@ -1053,6 +1055,9 @@</span> <span class="p_context"> static int ovl_fill_super(struct super_block *sb, void *data, int silent)</span>
 
 	root_dentry-&gt;d_fsdata = oe;
 
<span class="p_add">+	ovl_copyattr(ovl_dentry_real(root_dentry)-&gt;d_inode,</span>
<span class="p_add">+		     root_dentry-&gt;d_inode);</span>
<span class="p_add">+</span>
 	sb-&gt;s_magic = OVERLAYFS_SUPER_MAGIC;
 	sb-&gt;s_op = &amp;ovl_super_operations;
 	sb-&gt;s_root = root_dentry;
<span class="p_header">diff --git a/fs/udf/inode.c b/fs/udf/inode.c</span>
<span class="p_header">index 8d0b3ad..566df9b 100644</span>
<span class="p_header">--- a/fs/udf/inode.c</span>
<span class="p_header">+++ b/fs/udf/inode.c</span>
<span class="p_chunk">@@ -2047,14 +2047,29 @@</span> <span class="p_context"> void udf_write_aext(struct inode *inode, struct extent_position *epos,</span>
 		epos-&gt;offset += adsize;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Only 1 indirect extent in a row really makes sense but allow upto 16 in case</span>
<span class="p_add">+ * someone does some weird stuff.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define UDF_MAX_INDIR_EXTS 16</span>
<span class="p_add">+</span>
 int8_t udf_next_aext(struct inode *inode, struct extent_position *epos,
 		     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)
 {
 	int8_t etype;
<span class="p_add">+	unsigned int indirections = 0;</span>
 
 	while ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==
 	       (EXT_NEXT_EXTENT_ALLOCDECS &gt;&gt; 30)) {
 		int block;
<span class="p_add">+</span>
<span class="p_add">+		if (++indirections &gt; UDF_MAX_INDIR_EXTS) {</span>
<span class="p_add">+			udf_err(inode-&gt;i_sb,</span>
<span class="p_add">+				&quot;too many indirect extents in inode %lu\n&quot;,</span>
<span class="p_add">+				inode-&gt;i_ino);</span>
<span class="p_add">+			return -1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		epos-&gt;block = *eloc;
 		epos-&gt;offset = sizeof(struct allocExtDesc);
 		brelse(epos-&gt;bh);
<span class="p_header">diff --git a/fs/udf/unicode.c b/fs/udf/unicode.c</span>
<span class="p_header">index ab478e6..e788a05 100644</span>
<span class="p_header">--- a/fs/udf/unicode.c</span>
<span class="p_header">+++ b/fs/udf/unicode.c</span>
<span class="p_chunk">@@ -128,11 +128,15 @@</span> <span class="p_context"> int udf_CS0toUTF8(struct ustr *utf_o, const struct ustr *ocu_i)</span>
 		if (c &lt; 0x80U)
 			utf_o-&gt;u_name[utf_o-&gt;u_len++] = (uint8_t)c;
 		else if (c &lt; 0x800U) {
<span class="p_add">+			if (utf_o-&gt;u_len &gt; (UDF_NAME_LEN - 4))</span>
<span class="p_add">+				break;</span>
 			utf_o-&gt;u_name[utf_o-&gt;u_len++] =
 						(uint8_t)(0xc0 | (c &gt;&gt; 6));
 			utf_o-&gt;u_name[utf_o-&gt;u_len++] =
 						(uint8_t)(0x80 | (c &amp; 0x3f));
 		} else {
<span class="p_add">+			if (utf_o-&gt;u_len &gt; (UDF_NAME_LEN - 5))</span>
<span class="p_add">+				break;</span>
 			utf_o-&gt;u_name[utf_o-&gt;u_len++] =
 						(uint8_t)(0xe0 | (c &gt;&gt; 12));
 			utf_o-&gt;u_name[utf_o-&gt;u_len++] =
<span class="p_chunk">@@ -173,17 +177,22 @@</span> <span class="p_context"> int udf_CS0toUTF8(struct ustr *utf_o, const struct ustr *ocu_i)</span>
 static int udf_UTF8toCS0(dstring *ocu, struct ustr *utf, int length)
 {
 	unsigned c, i, max_val, utf_char;
<span class="p_del">-	int utf_cnt, u_len;</span>
<span class="p_add">+	int utf_cnt, u_len, u_ch;</span>
 
 	memset(ocu, 0, sizeof(dstring) * length);
 	ocu[0] = 8;
 	max_val = 0xffU;
<span class="p_add">+	u_ch = 1;</span>
 
 try_again:
 	u_len = 0U;
 	utf_char = 0U;
 	utf_cnt = 0U;
 	for (i = 0U; i &lt; utf-&gt;u_len; i++) {
<span class="p_add">+		/* Name didn&#39;t fit? */</span>
<span class="p_add">+		if (u_len + 1 + u_ch &gt;= length)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
 		c = (uint8_t)utf-&gt;u_name[i];
 
 		/* Complete a multi-byte UTF-8 character */
<span class="p_chunk">@@ -225,6 +234,7 @@</span> <span class="p_context"> try_again:</span>
 			if (max_val == 0xffU) {
 				max_val = 0xffffU;
 				ocu[0] = (uint8_t)0x10U;
<span class="p_add">+				u_ch = 2;</span>
 				goto try_again;
 			}
 			goto error_out;
<span class="p_chunk">@@ -277,7 +287,7 @@</span> <span class="p_context"> static int udf_CS0toNLS(struct nls_table *nls, struct ustr *utf_o,</span>
 			c = (c &lt;&lt; 8) | ocu[i++];
 
 		len = nls-&gt;uni2char(c, &amp;utf_o-&gt;u_name[utf_o-&gt;u_len],
<span class="p_del">-				    UDF_NAME_LEN - utf_o-&gt;u_len);</span>
<span class="p_add">+				    UDF_NAME_LEN - 2 - utf_o-&gt;u_len);</span>
 		/* Valid character? */
 		if (len &gt;= 0)
 			utf_o-&gt;u_len += len;
<span class="p_chunk">@@ -295,15 +305,19 @@</span> <span class="p_context"> static int udf_NLStoCS0(struct nls_table *nls, dstring *ocu, struct ustr *uni,</span>
 	int len;
 	unsigned i, max_val;
 	uint16_t uni_char;
<span class="p_del">-	int u_len;</span>
<span class="p_add">+	int u_len, u_ch;</span>
 
 	memset(ocu, 0, sizeof(dstring) * length);
 	ocu[0] = 8;
 	max_val = 0xffU;
<span class="p_add">+	u_ch = 1;</span>
 
 try_again:
 	u_len = 0U;
 	for (i = 0U; i &lt; uni-&gt;u_len; i++) {
<span class="p_add">+		/* Name didn&#39;t fit? */</span>
<span class="p_add">+		if (u_len + 1 + u_ch &gt;= length)</span>
<span class="p_add">+			return 0;</span>
 		len = nls-&gt;char2uni(&amp;uni-&gt;u_name[i], uni-&gt;u_len - i, &amp;uni_char);
 		if (!len)
 			continue;
<span class="p_chunk">@@ -316,6 +330,7 @@</span> <span class="p_context"> try_again:</span>
 		if (uni_char &gt; max_val) {
 			max_val = 0xffffU;
 			ocu[0] = (uint8_t)0x10U;
<span class="p_add">+			u_ch = 2;</span>
 			goto try_again;
 		}
 
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_dquot_buf.c b/fs/xfs/libxfs/xfs_dquot_buf.c</span>
<span class="p_header">index 6fbf2d8..48aff07 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_dquot_buf.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_dquot_buf.c</span>
<span class="p_chunk">@@ -54,7 +54,7 @@</span> <span class="p_context"> xfs_dqcheck(</span>
 	xfs_dqid_t	 id,
 	uint		 type,	  /* used only when IO_dorepair is true */
 	uint		 flags,
<span class="p_del">-	char		 *str)</span>
<span class="p_add">+	const char	 *str)</span>
 {
 	xfs_dqblk_t	 *d = (xfs_dqblk_t *)ddq;
 	int		errs = 0;
<span class="p_chunk">@@ -207,7 +207,8 @@</span> <span class="p_context"> xfs_dquot_buf_verify_crc(</span>
 STATIC bool
 xfs_dquot_buf_verify(
 	struct xfs_mount	*mp,
<span class="p_del">-	struct xfs_buf		*bp)</span>
<span class="p_add">+	struct xfs_buf		*bp,</span>
<span class="p_add">+	int			warn)</span>
 {
 	struct xfs_dqblk	*d = (struct xfs_dqblk *)bp-&gt;b_addr;
 	xfs_dqid_t		id = 0;
<span class="p_chunk">@@ -240,8 +241,7 @@</span> <span class="p_context"> xfs_dquot_buf_verify(</span>
 		if (i == 0)
 			id = be32_to_cpu(ddq-&gt;d_id);
 
<span class="p_del">-		error = xfs_dqcheck(mp, ddq, id + i, 0, XFS_QMOPT_DOWARN,</span>
<span class="p_del">-				       &quot;xfs_dquot_buf_verify&quot;);</span>
<span class="p_add">+		error = xfs_dqcheck(mp, ddq, id + i, 0, warn, __func__);</span>
 		if (error)
 			return false;
 	}
<span class="p_chunk">@@ -256,7 +256,7 @@</span> <span class="p_context"> xfs_dquot_buf_read_verify(</span>
 
 	if (!xfs_dquot_buf_verify_crc(mp, bp))
 		xfs_buf_ioerror(bp, -EFSBADCRC);
<span class="p_del">-	else if (!xfs_dquot_buf_verify(mp, bp))</span>
<span class="p_add">+	else if (!xfs_dquot_buf_verify(mp, bp, XFS_QMOPT_DOWARN))</span>
 		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 
 	if (bp-&gt;b_error)
<span class="p_chunk">@@ -264,6 +264,25 @@</span> <span class="p_context"> xfs_dquot_buf_read_verify(</span>
 }
 
 /*
<span class="p_add">+ * readahead errors are silent and simply leave the buffer as !done so a real</span>
<span class="p_add">+ * read will then be run with the xfs_dquot_buf_ops verifier. See</span>
<span class="p_add">+ * xfs_inode_buf_verify() for why we use EIO and ~XBF_DONE here rather than</span>
<span class="p_add">+ * reporting the failure.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void</span>
<span class="p_add">+xfs_dquot_buf_readahead_verify(</span>
<span class="p_add">+	struct xfs_buf	*bp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct xfs_mount	*mp = bp-&gt;b_target-&gt;bt_mount;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!xfs_dquot_buf_verify_crc(mp, bp) ||</span>
<span class="p_add">+	    !xfs_dquot_buf_verify(mp, bp, 0)) {</span>
<span class="p_add">+		xfs_buf_ioerror(bp, -EIO);</span>
<span class="p_add">+		bp-&gt;b_flags &amp;= ~XBF_DONE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * we don&#39;t calculate the CRC here as that is done when the dquot is flushed to
  * the buffer after the update is done. This ensures that the dquot in the
  * buffer always has an up-to-date CRC value.
<span class="p_chunk">@@ -274,7 +293,7 @@</span> <span class="p_context"> xfs_dquot_buf_write_verify(</span>
 {
 	struct xfs_mount	*mp = bp-&gt;b_target-&gt;bt_mount;
 
<span class="p_del">-	if (!xfs_dquot_buf_verify(mp, bp)) {</span>
<span class="p_add">+	if (!xfs_dquot_buf_verify(mp, bp, XFS_QMOPT_DOWARN)) {</span>
 		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 		xfs_verifier_error(bp);
 		return;
<span class="p_chunk">@@ -286,3 +305,7 @@</span> <span class="p_context"> const struct xfs_buf_ops xfs_dquot_buf_ops = {</span>
 	.verify_write = xfs_dquot_buf_write_verify,
 };
 
<span class="p_add">+const struct xfs_buf_ops xfs_dquot_buf_ra_ops = {</span>
<span class="p_add">+	.verify_read = xfs_dquot_buf_readahead_verify,</span>
<span class="p_add">+	.verify_write = xfs_dquot_buf_write_verify,</span>
<span class="p_add">+};</span>
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_format.h b/fs/xfs/libxfs/xfs_format.h</span>
<span class="p_header">index a0ae572..cfb8dd6 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_format.h</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_format.h</span>
<span class="p_chunk">@@ -762,7 +762,7 @@</span> <span class="p_context"> typedef struct xfs_agfl {</span>
 	__be64		agfl_lsn;
 	__be32		agfl_crc;
 	__be32		agfl_bno[];	/* actually XFS_AGFL_SIZE(mp) */
<span class="p_del">-} xfs_agfl_t;</span>
<span class="p_add">+} __attribute__((packed)) xfs_agfl_t;</span>
 
 #define XFS_AGFL_CRC_OFF	offsetof(struct xfs_agfl, agfl_crc)
 
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_inode_buf.c b/fs/xfs/libxfs/xfs_inode_buf.c</span>
<span class="p_header">index 6526e76..a7064be 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_inode_buf.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_inode_buf.c</span>
<span class="p_chunk">@@ -62,11 +62,14 @@</span> <span class="p_context"> xfs_inobp_check(</span>
  * has not had the inode cores stamped into it. Hence for readahead, the buffer
  * may be potentially invalid.
  *
<span class="p_del">- * If the readahead buffer is invalid, we don&#39;t want to mark it with an error,</span>
<span class="p_del">- * but we do want to clear the DONE status of the buffer so that a followup read</span>
<span class="p_del">- * will re-read it from disk. This will ensure that we don&#39;t get an unnecessary</span>
<span class="p_del">- * warnings during log recovery and we don&#39;t get unnecssary panics on debug</span>
<span class="p_del">- * kernels.</span>
<span class="p_add">+ * If the readahead buffer is invalid, we need to mark it with an error and</span>
<span class="p_add">+ * clear the DONE status of the buffer so that a followup read will re-read it</span>
<span class="p_add">+ * from disk. We don&#39;t report the error otherwise to avoid warnings during log</span>
<span class="p_add">+ * recovery and we don&#39;t get unnecssary panics on debug kernels. We use EIO here</span>
<span class="p_add">+ * because all we want to do is say readahead failed; there is no-one to report</span>
<span class="p_add">+ * the error to, so this will distinguish it from a non-ra verifier failure.</span>
<span class="p_add">+ * Changes to this readahead error behavour also need to be reflected in</span>
<span class="p_add">+ * xfs_dquot_buf_readahead_verify().</span>
  */
 static void
 xfs_inode_buf_verify(
<span class="p_chunk">@@ -93,6 +96,7 @@</span> <span class="p_context"> xfs_inode_buf_verify(</span>
 						XFS_RANDOM_ITOBP_INOTOBP))) {
 			if (readahead) {
 				bp-&gt;b_flags &amp;= ~XBF_DONE;
<span class="p_add">+				xfs_buf_ioerror(bp, -EIO);</span>
 				return;
 			}
 
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_quota_defs.h b/fs/xfs/libxfs/xfs_quota_defs.h</span>
<span class="p_header">index 1b0a083..f51078f 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_quota_defs.h</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_quota_defs.h</span>
<span class="p_chunk">@@ -153,7 +153,7 @@</span> <span class="p_context"> typedef __uint16_t	xfs_qwarncnt_t;</span>
 #define XFS_QMOPT_RESBLK_MASK	(XFS_QMOPT_RES_REGBLKS | XFS_QMOPT_RES_RTBLKS)
 
 extern int xfs_dqcheck(struct xfs_mount *mp, xfs_disk_dquot_t *ddq,
<span class="p_del">-		       xfs_dqid_t id, uint type, uint flags, char *str);</span>
<span class="p_add">+		       xfs_dqid_t id, uint type, uint flags, const char *str);</span>
 extern int xfs_calc_dquots_per_chunk(unsigned int nbblks);
 
 #endif	/* __XFS_QUOTA_H__ */
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_shared.h b/fs/xfs/libxfs/xfs_shared.h</span>
<span class="p_header">index 5be5297..15c3ceb 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_shared.h</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_shared.h</span>
<span class="p_chunk">@@ -49,6 +49,7 @@</span> <span class="p_context"> extern const struct xfs_buf_ops xfs_inobt_buf_ops;</span>
 extern const struct xfs_buf_ops xfs_inode_buf_ops;
 extern const struct xfs_buf_ops xfs_inode_buf_ra_ops;
 extern const struct xfs_buf_ops xfs_dquot_buf_ops;
<span class="p_add">+extern const struct xfs_buf_ops xfs_dquot_buf_ra_ops;</span>
 extern const struct xfs_buf_ops xfs_sb_buf_ops;
 extern const struct xfs_buf_ops xfs_sb_quiet_buf_ops;
 extern const struct xfs_buf_ops xfs_symlink_buf_ops;
<span class="p_header">diff --git a/fs/xfs/xfs_buf.c b/fs/xfs/xfs_buf.c</span>
<span class="p_header">index a4b7d92..7cc9cf4 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_buf.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_buf.c</span>
<span class="p_chunk">@@ -605,6 +605,13 @@</span> <span class="p_context"> found:</span>
 		}
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Clear b_error if this is a lookup from a caller that doesn&#39;t expect</span>
<span class="p_add">+	 * valid data to be found in the buffer.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!(flags &amp; XBF_READ))</span>
<span class="p_add">+		xfs_buf_ioerror(bp, 0);</span>
<span class="p_add">+</span>
 	XFS_STATS_INC(xb_get);
 	trace_xfs_buf_get(bp, flags, _RET_IP_);
 	return bp;
<span class="p_chunk">@@ -1522,6 +1529,16 @@</span> <span class="p_context"> xfs_wait_buftarg(</span>
 	LIST_HEAD(dispose);
 	int loop = 0;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to flush the buffer workqueue to ensure that all IO</span>
<span class="p_add">+	 * completion processing is 100% done. Just waiting on buffer locks is</span>
<span class="p_add">+	 * not sufficient for async IO as the reference count held over IO is</span>
<span class="p_add">+	 * not released until after the buffer lock is dropped. Hence we need to</span>
<span class="p_add">+	 * ensure here that all reference counts have been dropped before we</span>
<span class="p_add">+	 * start walking the LRU list.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	drain_workqueue(btp-&gt;bt_mount-&gt;m_buf_workqueue);</span>
<span class="p_add">+</span>
 	/* loop until there is nothing left on the lru list. */
 	while (list_lru_count(&amp;btp-&gt;bt_lru)) {
 		list_lru_walk(&amp;btp-&gt;bt_lru, xfs_buftarg_wait_rele,
<span class="p_header">diff --git a/fs/xfs/xfs_log_recover.c b/fs/xfs/xfs_log_recover.c</span>
<span class="p_header">index 480ebba..3e34d84 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_log_recover.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_log_recover.c</span>
<span class="p_chunk">@@ -3163,6 +3163,7 @@</span> <span class="p_context"> xlog_recover_dquot_ra_pass2(</span>
 	struct xfs_disk_dquot	*recddq;
 	struct xfs_dq_logformat	*dq_f;
 	uint			type;
<span class="p_add">+	int			len;</span>
 
 
 	if (mp-&gt;m_qflags == 0)
<span class="p_chunk">@@ -3183,8 +3184,12 @@</span> <span class="p_context"> xlog_recover_dquot_ra_pass2(</span>
 	ASSERT(dq_f);
 	ASSERT(dq_f-&gt;qlf_len == 1);
 
<span class="p_del">-	xfs_buf_readahead(mp-&gt;m_ddev_targp, dq_f-&gt;qlf_blkno,</span>
<span class="p_del">-			  XFS_FSB_TO_BB(mp, dq_f-&gt;qlf_len), NULL);</span>
<span class="p_add">+	len = XFS_FSB_TO_BB(mp, dq_f-&gt;qlf_len);</span>
<span class="p_add">+	if (xlog_peek_buffer_cancelled(log, dq_f-&gt;qlf_blkno, len, 0))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	xfs_buf_readahead(mp-&gt;m_ddev_targp, dq_f-&gt;qlf_blkno, len,</span>
<span class="p_add">+			  &amp;xfs_dquot_buf_ra_ops);</span>
 }
 
 STATIC void
<span class="p_header">diff --git a/include/crypto/hash.h b/include/crypto/hash.h</span>
<span class="p_header">index 57c8a6e..07c3a93 100644</span>
<span class="p_header">--- a/include/crypto/hash.h</span>
<span class="p_header">+++ b/include/crypto/hash.h</span>
<span class="p_chunk">@@ -199,6 +199,7 @@</span> <span class="p_context"> struct crypto_ahash {</span>
 		      unsigned int keylen);
 
 	unsigned int reqsize;
<span class="p_add">+	bool has_setkey;</span>
 	struct crypto_tfm base;
 };
 
<span class="p_chunk">@@ -356,6 +357,11 @@</span> <span class="p_context"> static inline void *ahash_request_ctx(struct ahash_request *req)</span>
 int crypto_ahash_setkey(struct crypto_ahash *tfm, const u8 *key,
 			unsigned int keylen);
 
<span class="p_add">+static inline bool crypto_ahash_has_setkey(struct crypto_ahash *tfm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return tfm-&gt;has_setkey;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * crypto_ahash_finup() - update and finalize message digest
  * @req: reference to the ahash_request handle that holds all information
<span class="p_header">diff --git a/include/crypto/if_alg.h b/include/crypto/if_alg.h</span>
<span class="p_header">index 018afb2..a2bfd78 100644</span>
<span class="p_header">--- a/include/crypto/if_alg.h</span>
<span class="p_header">+++ b/include/crypto/if_alg.h</span>
<span class="p_chunk">@@ -30,6 +30,9 @@</span> <span class="p_context"> struct alg_sock {</span>
 
 	struct sock *parent;
 
<span class="p_add">+	unsigned int refcnt;</span>
<span class="p_add">+	unsigned int nokey_refcnt;</span>
<span class="p_add">+</span>
 	const struct af_alg_type *type;
 	void *private;
 };
<span class="p_chunk">@@ -50,9 +53,11 @@</span> <span class="p_context"> struct af_alg_type {</span>
 	void (*release)(void *private);
 	int (*setkey)(void *private, const u8 *key, unsigned int keylen);
 	int (*accept)(void *private, struct sock *sk);
<span class="p_add">+	int (*accept_nokey)(void *private, struct sock *sk);</span>
 	int (*setauthsize)(void *private, unsigned int authsize);
 
 	struct proto_ops *ops;
<span class="p_add">+	struct proto_ops *ops_nokey;</span>
 	struct module *owner;
 	char name[14];
 };
<span class="p_chunk">@@ -67,6 +72,7 @@</span> <span class="p_context"> int af_alg_register_type(const struct af_alg_type *type);</span>
 int af_alg_unregister_type(const struct af_alg_type *type);
 
 int af_alg_release(struct socket *sock);
<span class="p_add">+void af_alg_release_parent(struct sock *sk);</span>
 int af_alg_accept(struct sock *sk, struct socket *newsock);
 
 int af_alg_make_sg(struct af_alg_sgl *sgl, struct iov_iter *iter, int len);
<span class="p_chunk">@@ -83,11 +89,6 @@</span> <span class="p_context"> static inline struct alg_sock *alg_sk(struct sock *sk)</span>
 	return (struct alg_sock *)sk;
 }
 
<span class="p_del">-static inline void af_alg_release_parent(struct sock *sk)</span>
<span class="p_del">-{</span>
<span class="p_del">-	sock_put(alg_sk(sk)-&gt;parent);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline void af_alg_init_completion(struct af_alg_completion *completion)
 {
 	init_completion(&amp;completion-&gt;completion);
<span class="p_header">diff --git a/include/drm/drm_dp_mst_helper.h b/include/drm/drm_dp_mst_helper.h</span>
<span class="p_header">index a89f505..c7f01d1 100644</span>
<span class="p_header">--- a/include/drm/drm_dp_mst_helper.h</span>
<span class="p_header">+++ b/include/drm/drm_dp_mst_helper.h</span>
<span class="p_chunk">@@ -449,9 +449,7 @@</span> <span class="p_context"> struct drm_dp_mst_topology_mgr {</span>
 	   the mstb tx_slots and txmsg-&gt;state once they are queued */
 	struct mutex qlock;
 	struct list_head tx_msg_downq;
<span class="p_del">-	struct list_head tx_msg_upq;</span>
 	bool tx_down_in_progress;
<span class="p_del">-	bool tx_up_in_progress;</span>
 
 	/* payload info + lock for it */
 	struct mutex payload_lock;
<span class="p_header">diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h</span>
<span class="p_header">index 3775327..1f043da 100644</span>
<span class="p_header">--- a/include/linux/ceph/messenger.h</span>
<span class="p_header">+++ b/include/linux/ceph/messenger.h</span>
<span class="p_chunk">@@ -226,6 +226,7 @@</span> <span class="p_context"> struct ceph_connection {</span>
 	struct ceph_entity_addr actual_peer_addr;
 
 	/* message out temps */
<span class="p_add">+	struct ceph_msg_header out_hdr;</span>
 	struct ceph_msg *out_msg;        /* sending message (== tail of
 					    out_sent) */
 	bool out_msg_done;
<span class="p_chunk">@@ -235,7 +236,6 @@</span> <span class="p_context"> struct ceph_connection {</span>
 	int out_kvec_left;   /* kvec&#39;s left in out_kvec */
 	int out_skip;        /* skip this many bytes */
 	int out_kvec_bytes;  /* total bytes left */
<span class="p_del">-	bool out_kvec_is_msg; /* kvec refers to out_msg */</span>
 	int out_more;        /* there is more data after the kvecs */
 	__le64 out_temp_ack; /* for writing an ack */
 
<span class="p_header">diff --git a/include/linux/console.h b/include/linux/console.h</span>
<span class="p_header">index bd19434..ea731af 100644</span>
<span class="p_header">--- a/include/linux/console.h</span>
<span class="p_header">+++ b/include/linux/console.h</span>
<span class="p_chunk">@@ -150,6 +150,7 @@</span> <span class="p_context"> extern int console_trylock(void);</span>
 extern void console_unlock(void);
 extern void console_conditional_schedule(void);
 extern void console_unblank(void);
<span class="p_add">+extern void console_flush_on_panic(void);</span>
 extern struct tty_driver *console_device(int *);
 extern void console_stop(struct console *);
 extern void console_start(struct console *);
<span class="p_header">diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h</span>
<span class="p_header">index 30d3a1f..115d8f5 100644</span>
<span class="p_header">--- a/include/linux/hyperv.h</span>
<span class="p_header">+++ b/include/linux/hyperv.h</span>
<span class="p_chunk">@@ -629,6 +629,11 @@</span> <span class="p_context"> struct hv_input_signal_event_buffer {</span>
 	struct hv_input_signal_event event;
 };
 
<span class="p_add">+enum hv_signal_policy {</span>
<span class="p_add">+	HV_SIGNAL_POLICY_DEFAULT = 0,</span>
<span class="p_add">+	HV_SIGNAL_POLICY_EXPLICIT,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 struct vmbus_channel {
 	/* Unique channel id */
 	int id;
<span class="p_chunk">@@ -756,8 +761,21 @@</span> <span class="p_context"> struct vmbus_channel {</span>
 	 * link up channels based on their CPU affinity.
 	 */
 	struct list_head percpu_list;
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Host signaling policy: The default policy will be</span>
<span class="p_add">+	 * based on the ring buffer state. We will also support</span>
<span class="p_add">+	 * a policy where the client driver can have explicit</span>
<span class="p_add">+	 * signaling control.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	enum hv_signal_policy  signal_policy;</span>
 };
 
<span class="p_add">+static inline void set_channel_signal_state(struct vmbus_channel *c,</span>
<span class="p_add">+					    enum hv_signal_policy policy)</span>
<span class="p_add">+{</span>
<span class="p_add">+	c-&gt;signal_policy = policy;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void set_channel_read_state(struct vmbus_channel *c, bool state)
 {
 	c-&gt;batched_reading = state;
<span class="p_header">diff --git a/include/linux/memblock.h b/include/linux/memblock.h</span>
<span class="p_header">index cc4b019..f0ccf80 100644</span>
<span class="p_header">--- a/include/linux/memblock.h</span>
<span class="p_header">+++ b/include/linux/memblock.h</span>
<span class="p_chunk">@@ -211,10 +211,10 @@</span> <span class="p_context"> void __next_mem_pfn_range(int *idx, int nid, unsigned long *out_start_pfn,</span>
  * for_each_free_mem_range - iterate through free memblock areas
  * @i: u64 used as loop variable
  * @nid: node selector, %NUMA_NO_NODE for all nodes
<span class="p_add">+ * @flags: pick from blocks based on memory attributes</span>
  * @p_start: ptr to phys_addr_t for start address of the range, can be %NULL
  * @p_end: ptr to phys_addr_t for end address of the range, can be %NULL
  * @p_nid: ptr to int for nid of the range, can be %NULL
<span class="p_del">- * @flags: pick from blocks based on memory attributes</span>
  *
  * Walks over free (memory &amp;&amp; !reserved) areas of memblock.  Available as
  * soon as memblock is initialized.
<span class="p_chunk">@@ -227,10 +227,10 @@</span> <span class="p_context"> void __next_mem_pfn_range(int *idx, int nid, unsigned long *out_start_pfn,</span>
  * for_each_free_mem_range_reverse - rev-iterate through free memblock areas
  * @i: u64 used as loop variable
  * @nid: node selector, %NUMA_NO_NODE for all nodes
<span class="p_add">+ * @flags: pick from blocks based on memory attributes</span>
  * @p_start: ptr to phys_addr_t for start address of the range, can be %NULL
  * @p_end: ptr to phys_addr_t for end address of the range, can be %NULL
  * @p_nid: ptr to int for nid of the range, can be %NULL
<span class="p_del">- * @flags: pick from blocks based on memory attributes</span>
  *
  * Walks over free (memory &amp;&amp; !reserved) areas of memblock in reverse
  * order.  Available as soon as memblock is initialized.
<span class="p_header">diff --git a/include/linux/mlx4/device.h b/include/linux/mlx4/device.h</span>
<span class="p_header">index fd13c1c..24a877f 100644</span>
<span class="p_header">--- a/include/linux/mlx4/device.h</span>
<span class="p_header">+++ b/include/linux/mlx4/device.h</span>
<span class="p_chunk">@@ -961,10 +961,6 @@</span> <span class="p_context"> struct mlx4_mad_ifc {</span>
 	for ((port) = 1; (port) &lt;= (dev)-&gt;caps.num_ports; (port)++)	\
 		if ((type) == (dev)-&gt;caps.port_mask[(port)])
 
<span class="p_del">-#define mlx4_foreach_non_ib_transport_port(port, dev)                     \</span>
<span class="p_del">-	for ((port) = 1; (port) &lt;= (dev)-&gt;caps.num_ports; (port)++)	  \</span>
<span class="p_del">-		if (((dev)-&gt;caps.port_mask[port] != MLX4_PORT_TYPE_IB))</span>
<span class="p_del">-</span>
 #define mlx4_foreach_ib_transport_port(port, dev)                         \
 	for ((port) = 1; (port) &lt;= (dev)-&gt;caps.num_ports; (port)++)	  \
 		if (((dev)-&gt;caps.port_mask[port] == MLX4_PORT_TYPE_IB) || \
<span class="p_header">diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h</span>
<span class="p_header">index 272f429..bb2fd9a 100644</span>
<span class="p_header">--- a/include/linux/mtd/nand.h</span>
<span class="p_header">+++ b/include/linux/mtd/nand.h</span>
<span class="p_chunk">@@ -276,7 +276,7 @@</span> <span class="p_context"> struct nand_onfi_params {</span>
 	__le16 t_r;
 	__le16 t_ccs;
 	__le16 src_sync_timing_mode;
<span class="p_del">-	__le16 src_ssync_features;</span>
<span class="p_add">+	u8 src_ssync_features;</span>
 	__le16 clk_pin_capacitance_typ;
 	__le16 io_pin_capacitance_typ;
 	__le16 input_pin_capacitance_typ;
<span class="p_chunk">@@ -284,7 +284,7 @@</span> <span class="p_context"> struct nand_onfi_params {</span>
 	u8 driver_strength_support;
 	__le16 t_int_r;
 	__le16 t_ald;
<span class="p_del">-	u8 reserved4[7];</span>
<span class="p_add">+	u8 reserved4[8];</span>
 
 	/* vendor */
 	__le16 vendor_revision;
<span class="p_header">diff --git a/include/linux/pci.h b/include/linux/pci.h</span>
<span class="p_header">index 1d4eb60..5b098ed 100644</span>
<span class="p_header">--- a/include/linux/pci.h</span>
<span class="p_header">+++ b/include/linux/pci.h</span>
<span class="p_chunk">@@ -1204,8 +1204,6 @@</span> <span class="p_context"> struct msix_entry {</span>
 	u16	entry;	/* driver uses to specify entry, OS writes */
 };
 
<span class="p_del">-void pci_msi_setup_pci_dev(struct pci_dev *dev);</span>
<span class="p_del">-</span>
 #ifdef CONFIG_PCI_MSI
 int pci_msi_vec_count(struct pci_dev *dev);
 void pci_msi_shutdown(struct pci_dev *dev);
<span class="p_header">diff --git a/include/linux/printk.h b/include/linux/printk.h</span>
<span class="p_header">index a6298b2..acbcd43 100644</span>
<span class="p_header">--- a/include/linux/printk.h</span>
<span class="p_header">+++ b/include/linux/printk.h</span>
<span class="p_chunk">@@ -106,13 +106,13 @@</span> <span class="p_context"> struct va_format {</span>
 
 /*
  * Dummy printk for disabled debugging statements to use whilst maintaining
<span class="p_del">- * gcc&#39;s format and side-effect checking.</span>
<span class="p_add">+ * gcc&#39;s format checking.</span>
  */
<span class="p_del">-static inline __printf(1, 2)</span>
<span class="p_del">-int no_printk(const char *fmt, ...)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_add">+#define no_printk(fmt, ...)			\</span>
<span class="p_add">+do {						\</span>
<span class="p_add">+	if (0)					\</span>
<span class="p_add">+		printk(fmt, ##__VA_ARGS__);	\</span>
<span class="p_add">+} while (0)</span>
 
 #ifdef CONFIG_EARLY_PRINTK
 extern asmlinkage __printf(1, 2)
<span class="p_header">diff --git a/include/linux/sched.h b/include/linux/sched.h</span>
<span class="p_header">index bfca8aa..8097d58 100644</span>
<span class="p_header">--- a/include/linux/sched.h</span>
<span class="p_header">+++ b/include/linux/sched.h</span>
<span class="p_chunk">@@ -822,6 +822,7 @@</span> <span class="p_context"> struct user_struct {</span>
 	unsigned long mq_bytes;	/* How many bytes can be allocated to mqueue? */
 #endif
 	unsigned long locked_shm; /* How many pages of mlocked shm ? */
<span class="p_add">+	unsigned long unix_inflight;	/* How many files in flight in unix sockets */</span>
 
 #ifdef CONFIG_KEYS
 	struct key *uid_keyring;	/* UID specific keyring */
<span class="p_header">diff --git a/include/linux/shmem_fs.h b/include/linux/shmem_fs.h</span>
<span class="p_header">index 50777b5..92d112a 100644</span>
<span class="p_header">--- a/include/linux/shmem_fs.h</span>
<span class="p_header">+++ b/include/linux/shmem_fs.h</span>
<span class="p_chunk">@@ -15,10 +15,7 @@</span> <span class="p_context"> struct shmem_inode_info {</span>
 	unsigned int		seals;		/* shmem seals */
 	unsigned long		flags;
 	unsigned long		alloced;	/* data pages alloced to file */
<span class="p_del">-	union {</span>
<span class="p_del">-		unsigned long	swapped;	/* subtotal assigned to swap */</span>
<span class="p_del">-		char		*symlink;	/* unswappable short symlink */</span>
<span class="p_del">-	};</span>
<span class="p_add">+	unsigned long		swapped;	/* subtotal assigned to swap */</span>
 	struct shared_policy	policy;		/* NUMA memory alloc policy */
 	struct list_head	swaplist;	/* chain of maybes on swap */
 	struct simple_xattrs	xattrs;		/* list of xattrs */
<span class="p_header">diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h</span>
<span class="p_header">index 2751588..8b2a698 100644</span>
<span class="p_header">--- a/include/linux/skbuff.h</span>
<span class="p_header">+++ b/include/linux/skbuff.h</span>
<span class="p_chunk">@@ -3337,7 +3337,8 @@</span> <span class="p_context"> struct skb_gso_cb {</span>
 	int	encap_level;
 	__u16	csum_start;
 };
<span class="p_del">-#define SKB_GSO_CB(skb) ((struct skb_gso_cb *)(skb)-&gt;cb)</span>
<span class="p_add">+#define SKB_SGO_CB_OFFSET	32</span>
<span class="p_add">+#define SKB_GSO_CB(skb) ((struct skb_gso_cb *)((skb)-&gt;cb + SKB_SGO_CB_OFFSET))</span>
 
 static inline int skb_tnl_header_len(const struct sk_buff *inner_skb)
 {
<span class="p_header">diff --git a/include/linux/thermal.h b/include/linux/thermal.h</span>
<span class="p_header">index b5ea8e0..601c4f8 100644</span>
<span class="p_header">--- a/include/linux/thermal.h</span>
<span class="p_header">+++ b/include/linux/thermal.h</span>
<span class="p_chunk">@@ -43,6 +43,9 @@</span> <span class="p_context"></span>
 /* Default weight of a bound cooling device */
 #define THERMAL_WEIGHT_DEFAULT 0
 
<span class="p_add">+/* use value, which &lt; 0K, to indicate an invalid/uninitialized temperature */</span>
<span class="p_add">+#define THERMAL_TEMP_INVALID	-274000</span>
<span class="p_add">+</span>
 /* Unit conversion macros */
 #define KELVIN_TO_CELSIUS(t)	(long)(((long)t-2732 &gt;= 0) ?	\
 				((long)t-2732+5)/10 : ((long)t-2732-5)/10)
<span class="p_chunk">@@ -169,6 +172,7 @@</span> <span class="p_context"> struct thermal_attr {</span>
  * @forced_passive:	If &gt; 0, temperature at which to switch on all ACPI
  *			processor cooling devices.  Currently only used by the
  *			step-wise governor.
<span class="p_add">+ * @need_update:	if equals 1, thermal_zone_device_update needs to be invoked.</span>
  * @ops:	operations this &amp;thermal_zone_device supports
  * @tzp:	thermal zone parameters
  * @governor:	pointer to the governor for this thermal zone
<span class="p_chunk">@@ -196,6 +200,7 @@</span> <span class="p_context"> struct thermal_zone_device {</span>
 	int emul_temperature;
 	int passive;
 	unsigned int forced_passive;
<span class="p_add">+	atomic_t need_update;</span>
 	struct thermal_zone_device_ops *ops;
 	struct thermal_zone_params *tzp;
 	struct thermal_governor *governor;
<span class="p_header">diff --git a/include/linux/usb/cdc_ncm.h b/include/linux/usb/cdc_ncm.h</span>
<span class="p_header">index 1f6526c..3a375d0 100644</span>
<span class="p_header">--- a/include/linux/usb/cdc_ncm.h</span>
<span class="p_header">+++ b/include/linux/usb/cdc_ncm.h</span>
<span class="p_chunk">@@ -138,6 +138,7 @@</span> <span class="p_context"> struct cdc_ncm_ctx {</span>
 };
 
 u8 cdc_ncm_select_altsetting(struct usb_interface *intf);
<span class="p_add">+int cdc_ncm_change_mtu(struct net_device *net, int new_mtu);</span>
 int cdc_ncm_bind_common(struct usbnet *dev, struct usb_interface *intf, u8 data_altsetting, int drvflags);
 void cdc_ncm_unbind(struct usbnet *dev, struct usb_interface *intf);
 struct sk_buff *cdc_ncm_fill_tx_frame(struct usbnet *dev, struct sk_buff *skb, __le32 sign);
<span class="p_header">diff --git a/include/linux/vmstat.h b/include/linux/vmstat.h</span>
<span class="p_header">index 82e7db7..c013b8d 100644</span>
<span class="p_header">--- a/include/linux/vmstat.h</span>
<span class="p_header">+++ b/include/linux/vmstat.h</span>
<span class="p_chunk">@@ -211,6 +211,7 @@</span> <span class="p_context"> extern void __inc_zone_state(struct zone *, enum zone_stat_item);</span>
 extern void dec_zone_state(struct zone *, enum zone_stat_item);
 extern void __dec_zone_state(struct zone *, enum zone_stat_item);
 
<span class="p_add">+void quiet_vmstat(void);</span>
 void cpu_vm_stats_fold(int cpu);
 void refresh_zone_stat_thresholds(void);
 
<span class="p_chunk">@@ -272,6 +273,7 @@</span> <span class="p_context"> static inline void __dec_zone_page_state(struct page *page,</span>
 static inline void refresh_cpu_vm_stats(int cpu) { }
 static inline void refresh_zone_stat_thresholds(void) { }
 static inline void cpu_vm_stats_fold(int cpu) { }
<span class="p_add">+static inline void quiet_vmstat(void) { }</span>
 
 static inline void drain_zonestat(struct zone *zone,
 			struct per_cpu_pageset *pset) { }
<span class="p_header">diff --git a/include/net/inet_ecn.h b/include/net/inet_ecn.h</span>
<span class="p_header">index 84b2083..0dc0a51 100644</span>
<span class="p_header">--- a/include/net/inet_ecn.h</span>
<span class="p_header">+++ b/include/net/inet_ecn.h</span>
<span class="p_chunk">@@ -111,11 +111,24 @@</span> <span class="p_context"> static inline void ipv4_copy_dscp(unsigned int dscp, struct iphdr *inner)</span>
 
 struct ipv6hdr;
 
<span class="p_del">-static inline int IP6_ECN_set_ce(struct ipv6hdr *iph)</span>
<span class="p_add">+/* Note:</span>
<span class="p_add">+ * IP_ECN_set_ce() has to tweak IPV4 checksum when setting CE,</span>
<span class="p_add">+ * meaning both changes have no effect on skb-&gt;csum if/when CHECKSUM_COMPLETE</span>
<span class="p_add">+ * In IPv6 case, no checksum compensates the change in IPv6 header,</span>
<span class="p_add">+ * so we have to update skb-&gt;csum.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline int IP6_ECN_set_ce(struct sk_buff *skb, struct ipv6hdr *iph)</span>
 {
<span class="p_add">+	__be32 from, to;</span>
<span class="p_add">+</span>
 	if (INET_ECN_is_not_ect(ipv6_get_dsfield(iph)))
 		return 0;
<span class="p_del">-	*(__be32*)iph |= htonl(INET_ECN_CE &lt;&lt; 20);</span>
<span class="p_add">+</span>
<span class="p_add">+	from = *(__be32 *)iph;</span>
<span class="p_add">+	to = from | htonl(INET_ECN_CE &lt;&lt; 20);</span>
<span class="p_add">+	*(__be32 *)iph = to;</span>
<span class="p_add">+	if (skb-&gt;ip_summed == CHECKSUM_COMPLETE)</span>
<span class="p_add">+		skb-&gt;csum = csum_add(csum_sub(skb-&gt;csum, from), to);</span>
 	return 1;
 }
 
<span class="p_chunk">@@ -142,7 +155,7 @@</span> <span class="p_context"> static inline int INET_ECN_set_ce(struct sk_buff *skb)</span>
 	case cpu_to_be16(ETH_P_IPV6):
 		if (skb_network_header(skb) + sizeof(struct ipv6hdr) &lt;=
 		    skb_tail_pointer(skb))
<span class="p_del">-			return IP6_ECN_set_ce(ipv6_hdr(skb));</span>
<span class="p_add">+			return IP6_ECN_set_ce(skb, ipv6_hdr(skb));</span>
 		break;
 	}
 
<span class="p_header">diff --git a/include/net/sock.h b/include/net/sock.h</span>
<span class="p_header">index 639138b..591d303 100644</span>
<span class="p_header">--- a/include/net/sock.h</span>
<span class="p_header">+++ b/include/net/sock.h</span>
<span class="p_chunk">@@ -1209,11 +1209,13 @@</span> <span class="p_context"> static inline void memcg_memory_allocated_add(struct cg_proto *prot,</span>
 					      unsigned long amt,
 					      int *parent_status)
 {
<span class="p_del">-	page_counter_charge(&amp;prot-&gt;memory_allocated, amt);</span>
<span class="p_add">+	struct page_counter *counter;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (page_counter_try_charge(&amp;prot-&gt;memory_allocated, amt, &amp;counter))</span>
<span class="p_add">+		return;</span>
 
<span class="p_del">-	if (page_counter_read(&amp;prot-&gt;memory_allocated) &gt;</span>
<span class="p_del">-	    prot-&gt;memory_allocated.limit)</span>
<span class="p_del">-		*parent_status = OVER_LIMIT;</span>
<span class="p_add">+	page_counter_charge(&amp;prot-&gt;memory_allocated, amt);</span>
<span class="p_add">+	*parent_status = OVER_LIMIT;</span>
 }
 
 static inline void memcg_memory_allocated_sub(struct cg_proto *prot,
<span class="p_header">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c</span>
<span class="p_header">index 039d866..4d19a8c 100644</span>
<span class="p_header">--- a/kernel/bpf/verifier.c</span>
<span class="p_header">+++ b/kernel/bpf/verifier.c</span>
<span class="p_chunk">@@ -1036,6 +1036,16 @@</span> <span class="p_context"> static int check_alu_op(struct reg_state *regs, struct bpf_insn *insn)</span>
 			return -EINVAL;
 		}
 
<span class="p_add">+		if ((opcode == BPF_LSH || opcode == BPF_RSH ||</span>
<span class="p_add">+		     opcode == BPF_ARSH) &amp;&amp; BPF_SRC(insn-&gt;code) == BPF_K) {</span>
<span class="p_add">+			int size = BPF_CLASS(insn-&gt;code) == BPF_ALU64 ? 64 : 32;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (insn-&gt;imm &lt; 0 || insn-&gt;imm &gt;= size) {</span>
<span class="p_add">+				verbose(&quot;invalid shift %d\n&quot;, insn-&gt;imm);</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		/* pattern match &#39;bpf_add Rx, imm&#39; instruction */
 		if (opcode == BPF_ADD &amp;&amp; BPF_CLASS(insn-&gt;code) == BPF_ALU64 &amp;&amp;
 		    regs[insn-&gt;dst_reg].type == FRAME_PTR &amp;&amp;
<span class="p_header">diff --git a/kernel/futex.c b/kernel/futex.c</span>
<span class="p_header">index c4a182f..f73be13 100644</span>
<span class="p_header">--- a/kernel/futex.c</span>
<span class="p_header">+++ b/kernel/futex.c</span>
<span class="p_chunk">@@ -2656,6 +2656,11 @@</span> <span class="p_context"> static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,</span>
 		if (q.pi_state &amp;&amp; (q.pi_state-&gt;owner != current)) {
 			spin_lock(q.lock_ptr);
 			ret = fixup_pi_state_owner(uaddr2, &amp;q, current);
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Drop the reference to the pi state which</span>
<span class="p_add">+			 * the requeue_pi() code acquired for us.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			free_pi_state(q.pi_state);</span>
 			spin_unlock(q.lock_ptr);
 		}
 	} else {
<span class="p_header">diff --git a/kernel/panic.c b/kernel/panic.c</span>
<span class="p_header">index 04e91ff..41e2b54 100644</span>
<span class="p_header">--- a/kernel/panic.c</span>
<span class="p_header">+++ b/kernel/panic.c</span>
<span class="p_chunk">@@ -23,6 +23,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/sysrq.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/nmi.h&gt;
<span class="p_add">+#include &lt;linux/console.h&gt;</span>
 
 #define PANIC_TIMER_STEP 100
 #define PANIC_BLINK_SPD 18
<span class="p_chunk">@@ -147,6 +148,17 @@</span> <span class="p_context"> void panic(const char *fmt, ...)</span>
 
 	bust_spinlocks(0);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We may have ended up stopping the CPU holding the lock (in</span>
<span class="p_add">+	 * smp_send_stop()) while still having some valuable data in the console</span>
<span class="p_add">+	 * buffer.  Try to acquire the lock then release it regardless of the</span>
<span class="p_add">+	 * result.  The release will also print the buffers out.  Locks debug</span>
<span class="p_add">+	 * should be disabled to avoid reporting bad unlock balance when</span>
<span class="p_add">+	 * panic() is not being callled from OOPS.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	debug_locks_off();</span>
<span class="p_add">+	console_flush_on_panic();</span>
<span class="p_add">+</span>
 	if (!panic_blink)
 		panic_blink = no_blink;
 
<span class="p_header">diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c</span>
<span class="p_header">index 2b0819b..66bfe91 100644</span>
<span class="p_header">--- a/kernel/printk/printk.c</span>
<span class="p_header">+++ b/kernel/printk/printk.c</span>
<span class="p_chunk">@@ -2232,13 +2232,24 @@</span> <span class="p_context"> void console_unlock(void)</span>
 	static u64 seen_seq;
 	unsigned long flags;
 	bool wake_klogd = false;
<span class="p_del">-	bool retry;</span>
<span class="p_add">+	bool do_cond_resched, retry;</span>
 
 	if (console_suspended) {
 		up_console_sem();
 		return;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Console drivers are called under logbuf_lock, so</span>
<span class="p_add">+	 * @console_may_schedule should be cleared before; however, we may</span>
<span class="p_add">+	 * end up dumping a lot of lines, for example, if called from</span>
<span class="p_add">+	 * console registration path, and should invoke cond_resched()</span>
<span class="p_add">+	 * between lines if allowable.  Not doing so can cause a very long</span>
<span class="p_add">+	 * scheduling stall on a slow console leading to RCU stall and</span>
<span class="p_add">+	 * softlockup warnings which exacerbate the issue with more</span>
<span class="p_add">+	 * messages practically incapacitating the system.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	do_cond_resched = console_may_schedule;</span>
 	console_may_schedule = 0;
 
 	/* flush buffered message fragment immediately to console */
<span class="p_chunk">@@ -2310,6 +2321,9 @@</span> <span class="p_context"> skip:</span>
 		call_console_drivers(level, ext_text, ext_len, text, len);
 		start_critical_timings();
 		local_irq_restore(flags);
<span class="p_add">+</span>
<span class="p_add">+		if (do_cond_resched)</span>
<span class="p_add">+			cond_resched();</span>
 	}
 	console_locked = 0;
 
<span class="p_chunk">@@ -2377,6 +2391,25 @@</span> <span class="p_context"> void console_unblank(void)</span>
 	console_unlock();
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * console_flush_on_panic - flush console content on panic</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Immediately output all pending messages no matter what.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void console_flush_on_panic(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If someone else is holding the console lock, trylock will fail</span>
<span class="p_add">+	 * and may_schedule may be set.  Ignore and proceed to unlock so</span>
<span class="p_add">+	 * that messages are flushed out.  As this can be called from any</span>
<span class="p_add">+	 * context and we don&#39;t want to get preempted while flushing,</span>
<span class="p_add">+	 * ensure may_schedule is cleared.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	console_trylock();</span>
<span class="p_add">+	console_may_schedule = 0;</span>
<span class="p_add">+	console_unlock();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Return the console tty driver structure and its associated index
  */
<span class="p_header">diff --git a/kernel/sched/idle.c b/kernel/sched/idle.c</span>
<span class="p_header">index 594275e..6d9b4c9 100644</span>
<span class="p_header">--- a/kernel/sched/idle.c</span>
<span class="p_header">+++ b/kernel/sched/idle.c</span>
<span class="p_chunk">@@ -221,6 +221,7 @@</span> <span class="p_context"> static void cpu_idle_loop(void)</span>
 		 */
 
 		__current_set_polling();
<span class="p_add">+		quiet_vmstat();</span>
 		tick_nohz_idle_enter();
 
 		while (!need_resched()) {
<span class="p_header">diff --git a/kernel/sys.c b/kernel/sys.c</span>
<span class="p_header">index 259fda2..af8c0b55 100644</span>
<span class="p_header">--- a/kernel/sys.c</span>
<span class="p_header">+++ b/kernel/sys.c</span>
<span class="p_chunk">@@ -1854,11 +1854,13 @@</span> <span class="p_context"> static int prctl_set_mm_map(int opt, const void __user *addr, unsigned long data</span>
 		user_auxv[AT_VECTOR_SIZE - 1] = AT_NULL;
 	}
 
<span class="p_del">-	if (prctl_map.exe_fd != (u32)-1)</span>
<span class="p_add">+	if (prctl_map.exe_fd != (u32)-1) {</span>
 		error = prctl_set_mm_exe_file(mm, prctl_map.exe_fd);
<span class="p_del">-	down_read(&amp;mm-&gt;mmap_sem);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			return error;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	down_write(&amp;mm-&gt;mmap_sem);</span>
 
 	/*
 	 * We don&#39;t validate if these members are pointing to
<span class="p_chunk">@@ -1895,10 +1897,8 @@</span> <span class="p_context"> static int prctl_set_mm_map(int opt, const void __user *addr, unsigned long data</span>
 	if (prctl_map.auxv_size)
 		memcpy(mm-&gt;saved_auxv, user_auxv, sizeof(user_auxv));
 
<span class="p_del">-	error = 0;</span>
<span class="p_del">-out:</span>
<span class="p_del">-	up_read(&amp;mm-&gt;mmap_sem);</span>
<span class="p_del">-	return error;</span>
<span class="p_add">+	up_write(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+	return 0;</span>
 }
 #endif /* CONFIG_CHECKPOINT_RESTORE */
 
<span class="p_chunk">@@ -1964,7 +1964,7 @@</span> <span class="p_context"> static int prctl_set_mm(int opt, unsigned long addr,</span>
 
 	error = -EINVAL;
 
<span class="p_del">-	down_read(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+	down_write(&amp;mm-&gt;mmap_sem);</span>
 	vma = find_vma(mm, addr);
 
 	prctl_map.start_code	= mm-&gt;start_code;
<span class="p_chunk">@@ -2057,7 +2057,7 @@</span> <span class="p_context"> static int prctl_set_mm(int opt, unsigned long addr,</span>
 
 	error = 0;
 out:
<span class="p_del">-	up_read(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+	up_write(&amp;mm-&gt;mmap_sem);</span>
 	return error;
 }
 
<span class="p_header">diff --git a/kernel/time/posix-clock.c b/kernel/time/posix-clock.c</span>
<span class="p_header">index ce033c7..9cff0ab 100644</span>
<span class="p_header">--- a/kernel/time/posix-clock.c</span>
<span class="p_header">+++ b/kernel/time/posix-clock.c</span>
<span class="p_chunk">@@ -69,10 +69,10 @@</span> <span class="p_context"> static ssize_t posix_clock_read(struct file *fp, char __user *buf,</span>
 static unsigned int posix_clock_poll(struct file *fp, poll_table *wait)
 {
 	struct posix_clock *clk = get_posix_clock(fp);
<span class="p_del">-	int result = 0;</span>
<span class="p_add">+	unsigned int result = 0;</span>
 
 	if (!clk)
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+		return POLLERR;</span>
 
 	if (clk-&gt;ops.poll)
 		result = clk-&gt;ops.poll(clk, fp, wait);
<span class="p_header">diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c</span>
<span class="p_header">index 3688f1e..afb50be 100644</span>
<span class="p_header">--- a/kernel/time/timekeeping.c</span>
<span class="p_header">+++ b/kernel/time/timekeeping.c</span>
<span class="p_chunk">@@ -305,8 +305,7 @@</span> <span class="p_context"> static inline s64 timekeeping_get_ns(struct tk_read_base *tkr)</span>
 
 	delta = timekeeping_get_delta(tkr);
 
<span class="p_del">-	nsec = delta * tkr-&gt;mult + tkr-&gt;xtime_nsec;</span>
<span class="p_del">-	nsec &gt;&gt;= tkr-&gt;shift;</span>
<span class="p_add">+	nsec = (delta * tkr-&gt;mult + tkr-&gt;xtime_nsec) &gt;&gt; tkr-&gt;shift;</span>
 
 	/* If arch requires, add in get_arch_timeoffset() */
 	return nsec + arch_gettimeoffset();
<span class="p_header">diff --git a/lib/Kconfig b/lib/Kconfig</span>
<span class="p_header">index 3a2ef67..7ceb4ca 100644</span>
<span class="p_header">--- a/lib/Kconfig</span>
<span class="p_header">+++ b/lib/Kconfig</span>
<span class="p_chunk">@@ -213,9 +213,11 @@</span> <span class="p_context"> config RANDOM32_SELFTEST</span>
 # compression support is select&#39;ed if needed
 #
 config 842_COMPRESS
<span class="p_add">+	select CRC32</span>
 	tristate
 
 config 842_DECOMPRESS
<span class="p_add">+	select CRC32</span>
 	tristate
 
 config ZLIB_INFLATE
<span class="p_header">diff --git a/lib/dma-debug.c b/lib/dma-debug.c</span>
<span class="p_header">index c5fddeb..d8b4df8 100644</span>
<span class="p_header">--- a/lib/dma-debug.c</span>
<span class="p_header">+++ b/lib/dma-debug.c</span>
<span class="p_chunk">@@ -1181,7 +1181,7 @@</span> <span class="p_context"> static inline bool overlap(void *addr, unsigned long len, void *start, void *end</span>
 
 static void check_for_illegal_area(struct device *dev, void *addr, unsigned long len)
 {
<span class="p_del">-	if (overlap(addr, len, _text, _etext) ||</span>
<span class="p_add">+	if (overlap(addr, len, _stext, _etext) ||</span>
 	    overlap(addr, len, __start_rodata, __end_rodata))
 		err_printk(dev, NULL, &quot;DMA-API: device driver maps memory from kernel text or rodata [addr=%p] [len=%lu]\n&quot;, addr, len);
 }
<span class="p_header">diff --git a/lib/libcrc32c.c b/lib/libcrc32c.c</span>
<span class="p_header">index 6a08ce7..acf9da4 100644</span>
<span class="p_header">--- a/lib/libcrc32c.c</span>
<span class="p_header">+++ b/lib/libcrc32c.c</span>
<span class="p_chunk">@@ -74,3 +74,4 @@</span> <span class="p_context"> module_exit(libcrc32c_mod_fini);</span>
 MODULE_AUTHOR(&quot;Clay Haapala &lt;chaapala@cisco.com&gt;&quot;);
 MODULE_DESCRIPTION(&quot;CRC32c (Castagnoli) calculations&quot;);
 MODULE_LICENSE(&quot;GPL&quot;);
<span class="p_add">+MODULE_SOFTDEP(&quot;pre: crc32c&quot;);</span>
<span class="p_header">diff --git a/mm/balloon_compaction.c b/mm/balloon_compaction.c</span>
<span class="p_header">index fcad832..b640609 100644</span>
<span class="p_header">--- a/mm/balloon_compaction.c</span>
<span class="p_header">+++ b/mm/balloon_compaction.c</span>
<span class="p_chunk">@@ -61,6 +61,7 @@</span> <span class="p_context"> struct page *balloon_page_dequeue(struct balloon_dev_info *b_dev_info)</span>
 	bool dequeued_page;
 
 	dequeued_page = false;
<span class="p_add">+	spin_lock_irqsave(&amp;b_dev_info-&gt;pages_lock, flags);</span>
 	list_for_each_entry_safe(page, tmp, &amp;b_dev_info-&gt;pages, lru) {
 		/*
 		 * Block others from accessing the &#39;page&#39; while we get around
<span class="p_chunk">@@ -75,15 +76,14 @@</span> <span class="p_context"> struct page *balloon_page_dequeue(struct balloon_dev_info *b_dev_info)</span>
 				continue;
 			}
 #endif
<span class="p_del">-			spin_lock_irqsave(&amp;b_dev_info-&gt;pages_lock, flags);</span>
 			balloon_page_delete(page);
 			__count_vm_event(BALLOON_DEFLATE);
<span class="p_del">-			spin_unlock_irqrestore(&amp;b_dev_info-&gt;pages_lock, flags);</span>
 			unlock_page(page);
 			dequeued_page = true;
 			break;
 		}
 	}
<span class="p_add">+	spin_unlock_irqrestore(&amp;b_dev_info-&gt;pages_lock, flags);</span>
 
 	if (!dequeued_page) {
 		/*
<span class="p_header">diff --git a/mm/memcontrol.c b/mm/memcontrol.c</span>
<span class="p_header">index 364f972..48540e5 100644</span>
<span class="p_header">--- a/mm/memcontrol.c</span>
<span class="p_header">+++ b/mm/memcontrol.c</span>
<span class="p_chunk">@@ -3833,16 +3833,17 @@</span> <span class="p_context"> static void __mem_cgroup_usage_unregister_event(struct mem_cgroup *memcg,</span>
 swap_buffers:
 	/* Swap primary and spare array */
 	thresholds-&gt;spare = thresholds-&gt;primary;
<span class="p_del">-	/* If all events are unregistered, free the spare array */</span>
<span class="p_del">-	if (!new) {</span>
<span class="p_del">-		kfree(thresholds-&gt;spare);</span>
<span class="p_del">-		thresholds-&gt;spare = NULL;</span>
<span class="p_del">-	}</span>
 
 	rcu_assign_pointer(thresholds-&gt;primary, new);
 
 	/* To be sure that nobody uses thresholds */
 	synchronize_rcu();
<span class="p_add">+</span>
<span class="p_add">+	/* If all events are unregistered, free the spare array */</span>
<span class="p_add">+	if (!new) {</span>
<span class="p_add">+		kfree(thresholds-&gt;spare);</span>
<span class="p_add">+		thresholds-&gt;spare = NULL;</span>
<span class="p_add">+	}</span>
 unlock:
 	mutex_unlock(&amp;memcg-&gt;thresholds_lock);
 }
<span class="p_header">diff --git a/mm/memory-failure.c b/mm/memory-failure.c</span>
<span class="p_header">index 1f4446a..20cc5b7 100644</span>
<span class="p_header">--- a/mm/memory-failure.c</span>
<span class="p_header">+++ b/mm/memory-failure.c</span>
<span class="p_chunk">@@ -1540,7 +1540,7 @@</span> <span class="p_context"> static int get_any_page(struct page *page, unsigned long pfn, int flags)</span>
 		 * Did it turn free?
 		 */
 		ret = __get_any_page(page, pfn, 0);
<span class="p_del">-		if (!PageLRU(page)) {</span>
<span class="p_add">+		if (ret == 1 &amp;&amp; !PageLRU(page)) {</span>
 			/* Drop page reference which is from __get_any_page() */
 			put_page(page);
 			pr_info(&quot;soft_offline: %#lx: unknown non LRU page type %lx\n&quot;,
<span class="p_header">diff --git a/mm/shmem.c b/mm/shmem.c</span>
<span class="p_header">index dbe0c1e..b2890af 100644</span>
<span class="p_header">--- a/mm/shmem.c</span>
<span class="p_header">+++ b/mm/shmem.c</span>
<span class="p_chunk">@@ -597,8 +597,7 @@</span> <span class="p_context"> static void shmem_evict_inode(struct inode *inode)</span>
 			list_del_init(&amp;info-&gt;swaplist);
 			mutex_unlock(&amp;shmem_swaplist_mutex);
 		}
<span class="p_del">-	} else</span>
<span class="p_del">-		kfree(info-&gt;symlink);</span>
<span class="p_add">+	}</span>
 
 	simple_xattrs_free(&amp;info-&gt;xattrs);
 	WARN_ON(inode-&gt;i_blocks);
<span class="p_chunk">@@ -2445,13 +2444,12 @@</span> <span class="p_context"> static int shmem_symlink(struct inode *dir, struct dentry *dentry, const char *s</span>
 	info = SHMEM_I(inode);
 	inode-&gt;i_size = len-1;
 	if (len &lt;= SHORT_SYMLINK_LEN) {
<span class="p_del">-		info-&gt;symlink = kmemdup(symname, len, GFP_KERNEL);</span>
<span class="p_del">-		if (!info-&gt;symlink) {</span>
<span class="p_add">+		inode-&gt;i_link = kmemdup(symname, len, GFP_KERNEL);</span>
<span class="p_add">+		if (!inode-&gt;i_link) {</span>
 			iput(inode);
 			return -ENOMEM;
 		}
 		inode-&gt;i_op = &amp;shmem_short_symlink_operations;
<span class="p_del">-		inode-&gt;i_link = info-&gt;symlink;</span>
 	} else {
 		error = shmem_getpage(inode, 0, &amp;page, SGP_WRITE, NULL);
 		if (error) {
<span class="p_chunk">@@ -3066,6 +3064,7 @@</span> <span class="p_context"> static struct inode *shmem_alloc_inode(struct super_block *sb)</span>
 static void shmem_destroy_callback(struct rcu_head *head)
 {
 	struct inode *inode = container_of(head, struct inode, i_rcu);
<span class="p_add">+	kfree(inode-&gt;i_link);</span>
 	kmem_cache_free(shmem_inode_cachep, SHMEM_I(inode));
 }
 
<span class="p_header">diff --git a/mm/vmstat.c b/mm/vmstat.c</span>
<span class="p_header">index 705d4a1..2139b23 100644</span>
<span class="p_header">--- a/mm/vmstat.c</span>
<span class="p_header">+++ b/mm/vmstat.c</span>
<span class="p_chunk">@@ -460,7 +460,7 @@</span> <span class="p_context"> static int fold_diff(int *diff)</span>
  *
  * The function returns the number of global counters updated.
  */
<span class="p_del">-static int refresh_cpu_vm_stats(void)</span>
<span class="p_add">+static int refresh_cpu_vm_stats(bool do_pagesets)</span>
 {
 	struct zone *zone;
 	int i;
<span class="p_chunk">@@ -484,33 +484,35 @@</span> <span class="p_context"> static int refresh_cpu_vm_stats(void)</span>
 #endif
 			}
 		}
<span class="p_del">-		cond_resched();</span>
 #ifdef CONFIG_NUMA
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Deal with draining the remote pageset of this</span>
<span class="p_del">-		 * processor</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * Check if there are pages remaining in this pageset</span>
<span class="p_del">-		 * if not then there is nothing to expire.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (!__this_cpu_read(p-&gt;expire) ||</span>
<span class="p_add">+		if (do_pagesets) {</span>
<span class="p_add">+			cond_resched();</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Deal with draining the remote pageset of this</span>
<span class="p_add">+			 * processor</span>
<span class="p_add">+			 *</span>
<span class="p_add">+			 * Check if there are pages remaining in this pageset</span>
<span class="p_add">+			 * if not then there is nothing to expire.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (!__this_cpu_read(p-&gt;expire) ||</span>
 			       !__this_cpu_read(p-&gt;pcp.count))
<span class="p_del">-			continue;</span>
<span class="p_add">+				continue;</span>
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * We never drain zones local to this processor.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (zone_to_nid(zone) == numa_node_id()) {</span>
<span class="p_del">-			__this_cpu_write(p-&gt;expire, 0);</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		}</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * We never drain zones local to this processor.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (zone_to_nid(zone) == numa_node_id()) {</span>
<span class="p_add">+				__this_cpu_write(p-&gt;expire, 0);</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
 
<span class="p_del">-		if (__this_cpu_dec_return(p-&gt;expire))</span>
<span class="p_del">-			continue;</span>
<span class="p_add">+			if (__this_cpu_dec_return(p-&gt;expire))</span>
<span class="p_add">+				continue;</span>
 
<span class="p_del">-		if (__this_cpu_read(p-&gt;pcp.count)) {</span>
<span class="p_del">-			drain_zone_pages(zone, this_cpu_ptr(&amp;p-&gt;pcp));</span>
<span class="p_del">-			changes++;</span>
<span class="p_add">+			if (__this_cpu_read(p-&gt;pcp.count)) {</span>
<span class="p_add">+				drain_zone_pages(zone, this_cpu_ptr(&amp;p-&gt;pcp));</span>
<span class="p_add">+				changes++;</span>
<span class="p_add">+			}</span>
 		}
 #endif
 	}
<span class="p_chunk">@@ -1364,7 +1366,7 @@</span> <span class="p_context"> static cpumask_var_t cpu_stat_off;</span>
 
 static void vmstat_update(struct work_struct *w)
 {
<span class="p_del">-	if (refresh_cpu_vm_stats())</span>
<span class="p_add">+	if (refresh_cpu_vm_stats(true))</span>
 		/*
 		 * Counters were updated so we expect more updates
 		 * to occur in the future. Keep on running the
<span class="p_chunk">@@ -1396,6 +1398,23 @@</span> <span class="p_context"> static void vmstat_update(struct work_struct *w)</span>
 }
 
 /*
<span class="p_add">+ * Switch off vmstat processing and then fold all the remaining differentials</span>
<span class="p_add">+ * until the diffs stay at zero. The function is used by NOHZ and can only be</span>
<span class="p_add">+ * invoked when tick processing is not active.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void quiet_vmstat(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (system_state != SYSTEM_RUNNING)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		if (!cpumask_test_and_set_cpu(smp_processor_id(), cpu_stat_off))</span>
<span class="p_add">+			cancel_delayed_work(this_cpu_ptr(&amp;vmstat_work));</span>
<span class="p_add">+</span>
<span class="p_add">+	} while (refresh_cpu_vm_stats(false));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Check if the diffs for a certain cpu indicate that
  * an update is needed.
  */
<span class="p_chunk">@@ -1427,7 +1446,7 @@</span> <span class="p_context"> static bool need_update(int cpu)</span>
  */
 static void vmstat_shepherd(struct work_struct *w);
 
<span class="p_del">-static DECLARE_DELAYED_WORK(shepherd, vmstat_shepherd);</span>
<span class="p_add">+static DECLARE_DEFERRABLE_WORK(shepherd, vmstat_shepherd);</span>
 
 static void vmstat_shepherd(struct work_struct *w)
 {
<span class="p_header">diff --git a/mm/zsmalloc.c b/mm/zsmalloc.c</span>
<span class="p_header">index 0a7f81a..88fbc8b 100644</span>
<span class="p_header">--- a/mm/zsmalloc.c</span>
<span class="p_header">+++ b/mm/zsmalloc.c</span>
<span class="p_chunk">@@ -302,7 +302,12 @@</span> <span class="p_context"> static void free_handle(struct zs_pool *pool, unsigned long handle)</span>
 
 static void record_obj(unsigned long handle, unsigned long obj)
 {
<span class="p_del">-	*(unsigned long *)handle = obj;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * lsb of @obj represents handle lock while other bits</span>
<span class="p_add">+	 * represent object value the handle is pointing so</span>
<span class="p_add">+	 * updating shouldn&#39;t do store tearing.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	WRITE_ONCE(*(unsigned long *)handle, obj);</span>
 }
 
 /* zpool driver */
<span class="p_chunk">@@ -1638,6 +1643,13 @@</span> <span class="p_context"> static int migrate_zspage(struct zs_pool *pool, struct size_class *class,</span>
 		free_obj = obj_malloc(d_page, class, handle);
 		zs_object_copy(used_obj, free_obj, class);
 		index++;
<span class="p_add">+		/*</span>
<span class="p_add">+		 * record_obj updates handle&#39;s value to free_obj and it will</span>
<span class="p_add">+		 * invalidate lock bit(ie, HANDLE_PIN_BIT) of handle, which</span>
<span class="p_add">+		 * breaks synchronization using pin_tag(e,g, zs_free) so</span>
<span class="p_add">+		 * let&#39;s keep the lock bit.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		free_obj |= BIT(HANDLE_PIN_BIT);</span>
 		record_obj(handle, free_obj);
 		unpin_tag(handle);
 		obj_free(pool, class, used_obj);
<span class="p_header">diff --git a/net/batman-adv/bridge_loop_avoidance.c b/net/batman-adv/bridge_loop_avoidance.c</span>
<span class="p_header">index ba06092..7b521e7 100644</span>
<span class="p_header">--- a/net/batman-adv/bridge_loop_avoidance.c</span>
<span class="p_header">+++ b/net/batman-adv/bridge_loop_avoidance.c</span>
<span class="p_chunk">@@ -126,21 +126,17 @@</span> <span class="p_context"> batadv_backbone_gw_free_ref(struct batadv_bla_backbone_gw *backbone_gw)</span>
 }
 
 /* finally deinitialize the claim */
<span class="p_del">-static void batadv_claim_free_rcu(struct rcu_head *rcu)</span>
<span class="p_add">+static void batadv_claim_release(struct batadv_bla_claim *claim)</span>
 {
<span class="p_del">-	struct batadv_bla_claim *claim;</span>
<span class="p_del">-</span>
<span class="p_del">-	claim = container_of(rcu, struct batadv_bla_claim, rcu);</span>
<span class="p_del">-</span>
 	batadv_backbone_gw_free_ref(claim-&gt;backbone_gw);
<span class="p_del">-	kfree(claim);</span>
<span class="p_add">+	kfree_rcu(claim, rcu);</span>
 }
 
 /* free a claim, call claim_free_rcu if its the last reference */
 static void batadv_claim_free_ref(struct batadv_bla_claim *claim)
 {
 	if (atomic_dec_and_test(&amp;claim-&gt;refcount))
<span class="p_del">-		call_rcu(&amp;claim-&gt;rcu, batadv_claim_free_rcu);</span>
<span class="p_add">+		batadv_claim_release(claim);</span>
 }
 
 /**
<span class="p_header">diff --git a/net/batman-adv/hard-interface.h b/net/batman-adv/hard-interface.h</span>
<span class="p_header">index 5a31420..7b12ea8 100644</span>
<span class="p_header">--- a/net/batman-adv/hard-interface.h</span>
<span class="p_header">+++ b/net/batman-adv/hard-interface.h</span>
<span class="p_chunk">@@ -75,18 +75,6 @@</span> <span class="p_context"> batadv_hardif_free_ref(struct batadv_hard_iface *hard_iface)</span>
 		call_rcu(&amp;hard_iface-&gt;rcu, batadv_hardif_free_rcu);
 }
 
<span class="p_del">-/**</span>
<span class="p_del">- * batadv_hardif_free_ref_now - decrement the hard interface refcounter and</span>
<span class="p_del">- *  possibly free it (without rcu callback)</span>
<span class="p_del">- * @hard_iface: the hard interface to free</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline void</span>
<span class="p_del">-batadv_hardif_free_ref_now(struct batadv_hard_iface *hard_iface)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (atomic_dec_and_test(&amp;hard_iface-&gt;refcount))</span>
<span class="p_del">-		batadv_hardif_free_rcu(&amp;hard_iface-&gt;rcu);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline struct batadv_hard_iface *
 batadv_primary_if_get_selected(struct batadv_priv *bat_priv)
 {
<span class="p_header">diff --git a/net/batman-adv/network-coding.c b/net/batman-adv/network-coding.c</span>
<span class="p_header">index 4660401..3e750c5 100644</span>
<span class="p_header">--- a/net/batman-adv/network-coding.c</span>
<span class="p_header">+++ b/net/batman-adv/network-coding.c</span>
<span class="p_chunk">@@ -204,28 +204,25 @@</span> <span class="p_context"> void batadv_nc_init_orig(struct batadv_orig_node *orig_node)</span>
 }
 
 /**
<span class="p_del">- * batadv_nc_node_free_rcu - rcu callback to free an nc node and remove</span>
<span class="p_del">- *  its refcount on the orig_node</span>
<span class="p_del">- * @rcu: rcu pointer of the nc node</span>
<span class="p_add">+ * batadv_nc_node_release - release nc_node from lists and queue for free after</span>
<span class="p_add">+ *  rcu grace period</span>
<span class="p_add">+ * @nc_node: the nc node to free</span>
  */
<span class="p_del">-static void batadv_nc_node_free_rcu(struct rcu_head *rcu)</span>
<span class="p_add">+static void batadv_nc_node_release(struct batadv_nc_node *nc_node)</span>
 {
<span class="p_del">-	struct batadv_nc_node *nc_node;</span>
<span class="p_del">-</span>
<span class="p_del">-	nc_node = container_of(rcu, struct batadv_nc_node, rcu);</span>
 	batadv_orig_node_free_ref(nc_node-&gt;orig_node);
<span class="p_del">-	kfree(nc_node);</span>
<span class="p_add">+	kfree_rcu(nc_node, rcu);</span>
 }
 
 /**
<span class="p_del">- * batadv_nc_node_free_ref - decrements the nc node refcounter and possibly</span>
<span class="p_del">- * frees it</span>
<span class="p_add">+ * batadv_nc_node_free_ref - decrement the nc node refcounter and possibly</span>
<span class="p_add">+ *  release it</span>
  * @nc_node: the nc node to free
  */
 static void batadv_nc_node_free_ref(struct batadv_nc_node *nc_node)
 {
 	if (atomic_dec_and_test(&amp;nc_node-&gt;refcount))
<span class="p_del">-		call_rcu(&amp;nc_node-&gt;rcu, batadv_nc_node_free_rcu);</span>
<span class="p_add">+		batadv_nc_node_release(nc_node);</span>
 }
 
 /**
<span class="p_header">diff --git a/net/batman-adv/originator.c b/net/batman-adv/originator.c</span>
<span class="p_header">index 32a0fcf..ae69e32 100644</span>
<span class="p_header">--- a/net/batman-adv/originator.c</span>
<span class="p_header">+++ b/net/batman-adv/originator.c</span>
<span class="p_chunk">@@ -162,92 +162,66 @@</span> <span class="p_context"> err:</span>
 }
 
 /**
<span class="p_del">- * batadv_neigh_ifinfo_free_rcu - free the neigh_ifinfo object</span>
<span class="p_del">- * @rcu: rcu pointer of the neigh_ifinfo object</span>
<span class="p_del">- */</span>
<span class="p_del">-static void batadv_neigh_ifinfo_free_rcu(struct rcu_head *rcu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct batadv_neigh_ifinfo *neigh_ifinfo;</span>
<span class="p_del">-</span>
<span class="p_del">-	neigh_ifinfo = container_of(rcu, struct batadv_neigh_ifinfo, rcu);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (neigh_ifinfo-&gt;if_outgoing != BATADV_IF_DEFAULT)</span>
<span class="p_del">-		batadv_hardif_free_ref_now(neigh_ifinfo-&gt;if_outgoing);</span>
<span class="p_del">-</span>
<span class="p_del">-	kfree(neigh_ifinfo);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * batadv_neigh_ifinfo_free_now - decrement the refcounter and possibly free</span>
<span class="p_del">- *  the neigh_ifinfo (without rcu callback)</span>
<span class="p_add">+ * batadv_neigh_ifinfo_release - release neigh_ifinfo from lists and queue for</span>
<span class="p_add">+ *  free after rcu grace period</span>
  * @neigh_ifinfo: the neigh_ifinfo object to release
  */
 static void
<span class="p_del">-batadv_neigh_ifinfo_free_ref_now(struct batadv_neigh_ifinfo *neigh_ifinfo)</span>
<span class="p_add">+batadv_neigh_ifinfo_release(struct batadv_neigh_ifinfo *neigh_ifinfo)</span>
 {
<span class="p_del">-	if (atomic_dec_and_test(&amp;neigh_ifinfo-&gt;refcount))</span>
<span class="p_del">-		batadv_neigh_ifinfo_free_rcu(&amp;neigh_ifinfo-&gt;rcu);</span>
<span class="p_add">+	if (neigh_ifinfo-&gt;if_outgoing != BATADV_IF_DEFAULT)</span>
<span class="p_add">+		batadv_hardif_free_ref(neigh_ifinfo-&gt;if_outgoing);</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree_rcu(neigh_ifinfo, rcu);</span>
 }
 
 /**
<span class="p_del">- * batadv_neigh_ifinfo_free_ref - decrement the refcounter and possibly free</span>
<span class="p_add">+ * batadv_neigh_ifinfo_free_ref - decrement the refcounter and possibly release</span>
  *  the neigh_ifinfo
  * @neigh_ifinfo: the neigh_ifinfo object to release
  */
 void batadv_neigh_ifinfo_free_ref(struct batadv_neigh_ifinfo *neigh_ifinfo)
 {
 	if (atomic_dec_and_test(&amp;neigh_ifinfo-&gt;refcount))
<span class="p_del">-		call_rcu(&amp;neigh_ifinfo-&gt;rcu, batadv_neigh_ifinfo_free_rcu);</span>
<span class="p_add">+		batadv_neigh_ifinfo_release(neigh_ifinfo);</span>
 }
 
 /**
  * batadv_neigh_node_free_rcu - free the neigh_node
<span class="p_del">- * @rcu: rcu pointer of the neigh_node</span>
<span class="p_add">+ * batadv_neigh_node_release - release neigh_node from lists and queue for</span>
<span class="p_add">+ *  free after rcu grace period</span>
<span class="p_add">+ * @neigh_node: neigh neighbor to free</span>
  */
<span class="p_del">-static void batadv_neigh_node_free_rcu(struct rcu_head *rcu)</span>
<span class="p_add">+static void batadv_neigh_node_release(struct batadv_neigh_node *neigh_node)</span>
 {
 	struct hlist_node *node_tmp;
<span class="p_del">-	struct batadv_neigh_node *neigh_node;</span>
 	struct batadv_neigh_ifinfo *neigh_ifinfo;
 	struct batadv_algo_ops *bao;
 
<span class="p_del">-	neigh_node = container_of(rcu, struct batadv_neigh_node, rcu);</span>
 	bao = neigh_node-&gt;orig_node-&gt;bat_priv-&gt;bat_algo_ops;
 
 	hlist_for_each_entry_safe(neigh_ifinfo, node_tmp,
 				  &amp;neigh_node-&gt;ifinfo_list, list) {
<span class="p_del">-		batadv_neigh_ifinfo_free_ref_now(neigh_ifinfo);</span>
<span class="p_add">+		batadv_neigh_ifinfo_free_ref(neigh_ifinfo);</span>
 	}
 
 	if (bao-&gt;bat_neigh_free)
 		bao-&gt;bat_neigh_free(neigh_node);
 
<span class="p_del">-	batadv_hardif_free_ref_now(neigh_node-&gt;if_incoming);</span>
<span class="p_add">+	batadv_hardif_free_ref(neigh_node-&gt;if_incoming);</span>
 
<span class="p_del">-	kfree(neigh_node);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * batadv_neigh_node_free_ref_now - decrement the neighbors refcounter</span>
<span class="p_del">- *  and possibly free it (without rcu callback)</span>
<span class="p_del">- * @neigh_node: neigh neighbor to free</span>
<span class="p_del">- */</span>
<span class="p_del">-static void</span>
<span class="p_del">-batadv_neigh_node_free_ref_now(struct batadv_neigh_node *neigh_node)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (atomic_dec_and_test(&amp;neigh_node-&gt;refcount))</span>
<span class="p_del">-		batadv_neigh_node_free_rcu(&amp;neigh_node-&gt;rcu);</span>
<span class="p_add">+	kfree_rcu(neigh_node, rcu);</span>
 }
 
 /**
  * batadv_neigh_node_free_ref - decrement the neighbors refcounter
<span class="p_del">- *  and possibly free it</span>
<span class="p_add">+ *  and possibly release it</span>
  * @neigh_node: neigh neighbor to free
  */
 void batadv_neigh_node_free_ref(struct batadv_neigh_node *neigh_node)
 {
 	if (atomic_dec_and_test(&amp;neigh_node-&gt;refcount))
<span class="p_del">-		call_rcu(&amp;neigh_node-&gt;rcu, batadv_neigh_node_free_rcu);</span>
<span class="p_add">+		batadv_neigh_node_release(neigh_node);</span>
 }
 
 /**
<span class="p_chunk">@@ -513,108 +487,99 @@</span> <span class="p_context"> batadv_neigh_node_get(const struct batadv_orig_node *orig_node,</span>
 }
 
 /**
<span class="p_del">- * batadv_orig_ifinfo_free_rcu - free the orig_ifinfo object</span>
<span class="p_del">- * @rcu: rcu pointer of the orig_ifinfo object</span>
<span class="p_add">+ * batadv_orig_ifinfo_release - release orig_ifinfo from lists and queue for</span>
<span class="p_add">+ *  free after rcu grace period</span>
<span class="p_add">+ * @orig_ifinfo: the orig_ifinfo object to release</span>
  */
<span class="p_del">-static void batadv_orig_ifinfo_free_rcu(struct rcu_head *rcu)</span>
<span class="p_add">+static void batadv_orig_ifinfo_release(struct batadv_orig_ifinfo *orig_ifinfo)</span>
 {
<span class="p_del">-	struct batadv_orig_ifinfo *orig_ifinfo;</span>
 	struct batadv_neigh_node *router;
 
<span class="p_del">-	orig_ifinfo = container_of(rcu, struct batadv_orig_ifinfo, rcu);</span>
<span class="p_del">-</span>
 	if (orig_ifinfo-&gt;if_outgoing != BATADV_IF_DEFAULT)
<span class="p_del">-		batadv_hardif_free_ref_now(orig_ifinfo-&gt;if_outgoing);</span>
<span class="p_add">+		batadv_hardif_free_ref(orig_ifinfo-&gt;if_outgoing);</span>
 
 	/* this is the last reference to this object */
 	router = rcu_dereference_protected(orig_ifinfo-&gt;router, true);
 	if (router)
<span class="p_del">-		batadv_neigh_node_free_ref_now(router);</span>
<span class="p_del">-	kfree(orig_ifinfo);</span>
<span class="p_add">+		batadv_neigh_node_free_ref(router);</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree_rcu(orig_ifinfo, rcu);</span>
 }
 
 /**
<span class="p_del">- * batadv_orig_ifinfo_free_ref - decrement the refcounter and possibly free</span>
<span class="p_del">- *  the orig_ifinfo (without rcu callback)</span>
<span class="p_add">+ * batadv_orig_ifinfo_free_ref - decrement the refcounter and possibly release</span>
<span class="p_add">+ *  the orig_ifinfo</span>
  * @orig_ifinfo: the orig_ifinfo object to release
  */
<span class="p_del">-static void</span>
<span class="p_del">-batadv_orig_ifinfo_free_ref_now(struct batadv_orig_ifinfo *orig_ifinfo)</span>
<span class="p_add">+void batadv_orig_ifinfo_free_ref(struct batadv_orig_ifinfo *orig_ifinfo)</span>
 {
 	if (atomic_dec_and_test(&amp;orig_ifinfo-&gt;refcount))
<span class="p_del">-		batadv_orig_ifinfo_free_rcu(&amp;orig_ifinfo-&gt;rcu);</span>
<span class="p_add">+		batadv_orig_ifinfo_release(orig_ifinfo);</span>
 }
 
 /**
<span class="p_del">- * batadv_orig_ifinfo_free_ref - decrement the refcounter and possibly free</span>
<span class="p_del">- *  the orig_ifinfo</span>
<span class="p_del">- * @orig_ifinfo: the orig_ifinfo object to release</span>
<span class="p_add">+ * batadv_orig_node_free_rcu - free the orig_node</span>
<span class="p_add">+ * @rcu: rcu pointer of the orig_node</span>
  */
<span class="p_del">-void batadv_orig_ifinfo_free_ref(struct batadv_orig_ifinfo *orig_ifinfo)</span>
<span class="p_add">+static void batadv_orig_node_free_rcu(struct rcu_head *rcu)</span>
 {
<span class="p_del">-	if (atomic_dec_and_test(&amp;orig_ifinfo-&gt;refcount))</span>
<span class="p_del">-		call_rcu(&amp;orig_ifinfo-&gt;rcu, batadv_orig_ifinfo_free_rcu);</span>
<span class="p_add">+	struct batadv_orig_node *orig_node;</span>
<span class="p_add">+</span>
<span class="p_add">+	orig_node = container_of(rcu, struct batadv_orig_node, rcu);</span>
<span class="p_add">+</span>
<span class="p_add">+	batadv_mcast_purge_orig(orig_node);</span>
<span class="p_add">+</span>
<span class="p_add">+	batadv_frag_purge_orig(orig_node, NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (orig_node-&gt;bat_priv-&gt;bat_algo_ops-&gt;bat_orig_free)</span>
<span class="p_add">+		orig_node-&gt;bat_priv-&gt;bat_algo_ops-&gt;bat_orig_free(orig_node);</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(orig_node-&gt;tt_buff);</span>
<span class="p_add">+	kfree(orig_node);</span>
 }
 
<span class="p_del">-static void batadv_orig_node_free_rcu(struct rcu_head *rcu)</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * batadv_orig_node_release - release orig_node from lists and queue for</span>
<span class="p_add">+ *  free after rcu grace period</span>
<span class="p_add">+ * @orig_node: the orig node to free</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void batadv_orig_node_release(struct batadv_orig_node *orig_node)</span>
 {
 	struct hlist_node *node_tmp;
 	struct batadv_neigh_node *neigh_node;
<span class="p_del">-	struct batadv_orig_node *orig_node;</span>
 	struct batadv_orig_ifinfo *orig_ifinfo;
 
<span class="p_del">-	orig_node = container_of(rcu, struct batadv_orig_node, rcu);</span>
<span class="p_del">-</span>
 	spin_lock_bh(&amp;orig_node-&gt;neigh_list_lock);
 
 	/* for all neighbors towards this originator ... */
 	hlist_for_each_entry_safe(neigh_node, node_tmp,
 				  &amp;orig_node-&gt;neigh_list, list) {
 		hlist_del_rcu(&amp;neigh_node-&gt;list);
<span class="p_del">-		batadv_neigh_node_free_ref_now(neigh_node);</span>
<span class="p_add">+		batadv_neigh_node_free_ref(neigh_node);</span>
 	}
 
 	hlist_for_each_entry_safe(orig_ifinfo, node_tmp,
 				  &amp;orig_node-&gt;ifinfo_list, list) {
 		hlist_del_rcu(&amp;orig_ifinfo-&gt;list);
<span class="p_del">-		batadv_orig_ifinfo_free_ref_now(orig_ifinfo);</span>
<span class="p_add">+		batadv_orig_ifinfo_free_ref(orig_ifinfo);</span>
 	}
 	spin_unlock_bh(&amp;orig_node-&gt;neigh_list_lock);
 
<span class="p_del">-	batadv_mcast_purge_orig(orig_node);</span>
<span class="p_del">-</span>
 	/* Free nc_nodes */
 	batadv_nc_purge_orig(orig_node-&gt;bat_priv, orig_node, NULL);
 
<span class="p_del">-	batadv_frag_purge_orig(orig_node, NULL);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (orig_node-&gt;bat_priv-&gt;bat_algo_ops-&gt;bat_orig_free)</span>
<span class="p_del">-		orig_node-&gt;bat_priv-&gt;bat_algo_ops-&gt;bat_orig_free(orig_node);</span>
<span class="p_del">-</span>
<span class="p_del">-	kfree(orig_node-&gt;tt_buff);</span>
<span class="p_del">-	kfree(orig_node);</span>
<span class="p_add">+	call_rcu(&amp;orig_node-&gt;rcu, batadv_orig_node_free_rcu);</span>
 }
 
 /**
  * batadv_orig_node_free_ref - decrement the orig node refcounter and possibly
<span class="p_del">- * schedule an rcu callback for freeing it</span>
<span class="p_add">+ *  release it</span>
  * @orig_node: the orig node to free
  */
 void batadv_orig_node_free_ref(struct batadv_orig_node *orig_node)
 {
 	if (atomic_dec_and_test(&amp;orig_node-&gt;refcount))
<span class="p_del">-		call_rcu(&amp;orig_node-&gt;rcu, batadv_orig_node_free_rcu);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * batadv_orig_node_free_ref_now - decrement the orig node refcounter and</span>
<span class="p_del">- * possibly free it (without rcu callback)</span>
<span class="p_del">- * @orig_node: the orig node to free</span>
<span class="p_del">- */</span>
<span class="p_del">-void batadv_orig_node_free_ref_now(struct batadv_orig_node *orig_node)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (atomic_dec_and_test(&amp;orig_node-&gt;refcount))</span>
<span class="p_del">-		batadv_orig_node_free_rcu(&amp;orig_node-&gt;rcu);</span>
<span class="p_add">+		batadv_orig_node_release(orig_node);</span>
 }
 
 void batadv_originator_free(struct batadv_priv *bat_priv)
<span class="p_header">diff --git a/net/batman-adv/originator.h b/net/batman-adv/originator.h</span>
<span class="p_header">index 79734d3..39c9906 100644</span>
<span class="p_header">--- a/net/batman-adv/originator.h</span>
<span class="p_header">+++ b/net/batman-adv/originator.h</span>
<span class="p_chunk">@@ -38,7 +38,6 @@</span> <span class="p_context"> int batadv_originator_init(struct batadv_priv *bat_priv);</span>
 void batadv_originator_free(struct batadv_priv *bat_priv);
 void batadv_purge_orig_ref(struct batadv_priv *bat_priv);
 void batadv_orig_node_free_ref(struct batadv_orig_node *orig_node);
<span class="p_del">-void batadv_orig_node_free_ref_now(struct batadv_orig_node *orig_node);</span>
 struct batadv_orig_node *batadv_orig_node_new(struct batadv_priv *bat_priv,
 					      const uint8_t *addr);
 struct batadv_neigh_node *
<span class="p_header">diff --git a/net/batman-adv/translation-table.c b/net/batman-adv/translation-table.c</span>
<span class="p_header">index c9b2629..5d4644a 100644</span>
<span class="p_header">--- a/net/batman-adv/translation-table.c</span>
<span class="p_header">+++ b/net/batman-adv/translation-table.c</span>
<span class="p_chunk">@@ -238,20 +238,6 @@</span> <span class="p_context"> int batadv_tt_global_hash_count(struct batadv_priv *bat_priv,</span>
 	return count;
 }
 
<span class="p_del">-static void batadv_tt_orig_list_entry_free_rcu(struct rcu_head *rcu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct batadv_tt_orig_list_entry *orig_entry;</span>
<span class="p_del">-</span>
<span class="p_del">-	orig_entry = container_of(rcu, struct batadv_tt_orig_list_entry, rcu);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We are in an rcu callback here, therefore we cannot use</span>
<span class="p_del">-	 * batadv_orig_node_free_ref() and its call_rcu():</span>
<span class="p_del">-	 * An rcu_barrier() wouldn&#39;t wait for that to finish</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	batadv_orig_node_free_ref_now(orig_entry-&gt;orig_node);</span>
<span class="p_del">-	kfree(orig_entry);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /**
  * batadv_tt_local_size_mod - change the size by v of the local table identified
  *  by vid
<span class="p_chunk">@@ -347,13 +333,25 @@</span> <span class="p_context"> static void batadv_tt_global_size_dec(struct batadv_orig_node *orig_node,</span>
 	batadv_tt_global_size_mod(orig_node, vid, -1);
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * batadv_tt_orig_list_entry_release - release tt orig entry from lists and</span>
<span class="p_add">+ *  queue for free after rcu grace period</span>
<span class="p_add">+ * @orig_entry: tt orig entry to be free&#39;d</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void</span>
<span class="p_add">+batadv_tt_orig_list_entry_release(struct batadv_tt_orig_list_entry *orig_entry)</span>
<span class="p_add">+{</span>
<span class="p_add">+	batadv_orig_node_free_ref(orig_entry-&gt;orig_node);</span>
<span class="p_add">+	kfree_rcu(orig_entry, rcu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void
 batadv_tt_orig_list_entry_free_ref(struct batadv_tt_orig_list_entry *orig_entry)
 {
 	if (!atomic_dec_and_test(&amp;orig_entry-&gt;refcount))
 		return;
 
<span class="p_del">-	call_rcu(&amp;orig_entry-&gt;rcu, batadv_tt_orig_list_entry_free_rcu);</span>
<span class="p_add">+	batadv_tt_orig_list_entry_release(orig_entry);</span>
 }
 
 /**
<span class="p_header">diff --git a/net/bridge/br_device.c b/net/bridge/br_device.c</span>
<span class="p_header">index 4ff77a1..3d6c8e2 100644</span>
<span class="p_header">--- a/net/bridge/br_device.c</span>
<span class="p_header">+++ b/net/bridge/br_device.c</span>
<span class="p_chunk">@@ -28,6 +28,8 @@</span> <span class="p_context"></span>
 const struct nf_br_ops __rcu *nf_br_ops __read_mostly;
 EXPORT_SYMBOL_GPL(nf_br_ops);
 
<span class="p_add">+static struct lock_class_key bridge_netdev_addr_lock_key;</span>
<span class="p_add">+</span>
 /* net device transmit always called with BH disabled */
 netdev_tx_t br_dev_xmit(struct sk_buff *skb, struct net_device *dev)
 {
<span class="p_chunk">@@ -87,6 +89,11 @@</span> <span class="p_context"> out:</span>
 	return NETDEV_TX_OK;
 }
 
<span class="p_add">+static void br_set_lockdep_class(struct net_device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	lockdep_set_class(&amp;dev-&gt;addr_list_lock, &amp;bridge_netdev_addr_lock_key);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int br_dev_init(struct net_device *dev)
 {
 	struct net_bridge *br = netdev_priv(dev);
<span class="p_chunk">@@ -99,6 +106,7 @@</span> <span class="p_context"> static int br_dev_init(struct net_device *dev)</span>
 	err = br_vlan_init(br);
 	if (err)
 		free_percpu(br-&gt;stats);
<span class="p_add">+	br_set_lockdep_class(dev);</span>
 
 	return err;
 }
<span class="p_header">diff --git a/net/bridge/br_stp_if.c b/net/bridge/br_stp_if.c</span>
<span class="p_header">index 4ca449a..49d8d28 100644</span>
<span class="p_header">--- a/net/bridge/br_stp_if.c</span>
<span class="p_header">+++ b/net/bridge/br_stp_if.c</span>
<span class="p_chunk">@@ -130,7 +130,10 @@</span> <span class="p_context"> static void br_stp_start(struct net_bridge *br)</span>
 	char *envp[] = { NULL };
 	struct net_bridge_port *p;
 
<span class="p_del">-	r = call_usermodehelper(BR_STP_PROG, argv, envp, UMH_WAIT_PROC);</span>
<span class="p_add">+	if (net_eq(dev_net(br-&gt;dev), &amp;init_net))</span>
<span class="p_add">+		r = call_usermodehelper(BR_STP_PROG, argv, envp, UMH_WAIT_PROC);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		r = -ENOENT;</span>
 
 	spin_lock_bh(&amp;br-&gt;lock);
 
<span class="p_header">diff --git a/net/ceph/messenger.c b/net/ceph/messenger.c</span>
<span class="p_header">index e3be1d2..ec564c5 100644</span>
<span class="p_header">--- a/net/ceph/messenger.c</span>
<span class="p_header">+++ b/net/ceph/messenger.c</span>
<span class="p_chunk">@@ -675,6 +675,8 @@</span> <span class="p_context"> static void reset_connection(struct ceph_connection *con)</span>
 	}
 	con-&gt;in_seq = 0;
 	con-&gt;in_seq_acked = 0;
<span class="p_add">+</span>
<span class="p_add">+	con-&gt;out_skip = 0;</span>
 }
 
 /*
<span class="p_chunk">@@ -774,6 +776,8 @@</span> <span class="p_context"> static u32 get_global_seq(struct ceph_messenger *msgr, u32 gt)</span>
 
 static void con_out_kvec_reset(struct ceph_connection *con)
 {
<span class="p_add">+	BUG_ON(con-&gt;out_skip);</span>
<span class="p_add">+</span>
 	con-&gt;out_kvec_left = 0;
 	con-&gt;out_kvec_bytes = 0;
 	con-&gt;out_kvec_cur = &amp;con-&gt;out_kvec[0];
<span class="p_chunk">@@ -782,9 +786,9 @@</span> <span class="p_context"> static void con_out_kvec_reset(struct ceph_connection *con)</span>
 static void con_out_kvec_add(struct ceph_connection *con,
 				size_t size, void *data)
 {
<span class="p_del">-	int index;</span>
<span class="p_add">+	int index = con-&gt;out_kvec_left;</span>
 
<span class="p_del">-	index = con-&gt;out_kvec_left;</span>
<span class="p_add">+	BUG_ON(con-&gt;out_skip);</span>
 	BUG_ON(index &gt;= ARRAY_SIZE(con-&gt;out_kvec));
 
 	con-&gt;out_kvec[index].iov_len = size;
<span class="p_chunk">@@ -793,6 +797,27 @@</span> <span class="p_context"> static void con_out_kvec_add(struct ceph_connection *con,</span>
 	con-&gt;out_kvec_bytes += size;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Chop off a kvec from the end.  Return residual number of bytes for</span>
<span class="p_add">+ * that kvec, i.e. how many bytes would have been written if the kvec</span>
<span class="p_add">+ * hadn&#39;t been nuked.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int con_out_kvec_skip(struct ceph_connection *con)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int off = con-&gt;out_kvec_cur - con-&gt;out_kvec;</span>
<span class="p_add">+	int skip = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (con-&gt;out_kvec_bytes &gt; 0) {</span>
<span class="p_add">+		skip = con-&gt;out_kvec[off + con-&gt;out_kvec_left - 1].iov_len;</span>
<span class="p_add">+		BUG_ON(con-&gt;out_kvec_bytes &lt; skip);</span>
<span class="p_add">+		BUG_ON(!con-&gt;out_kvec_left);</span>
<span class="p_add">+		con-&gt;out_kvec_bytes -= skip;</span>
<span class="p_add">+		con-&gt;out_kvec_left--;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return skip;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #ifdef CONFIG_BLOCK
 
 /*
<span class="p_chunk">@@ -1200,7 +1225,6 @@</span> <span class="p_context"> static void prepare_write_message_footer(struct ceph_connection *con)</span>
 	m-&gt;footer.flags |= CEPH_MSG_FOOTER_COMPLETE;
 
 	dout(&quot;prepare_write_message_footer %p\n&quot;, con);
<span class="p_del">-	con-&gt;out_kvec_is_msg = true;</span>
 	con-&gt;out_kvec[v].iov_base = &amp;m-&gt;footer;
 	if (con-&gt;peer_features &amp; CEPH_FEATURE_MSG_AUTH) {
 		if (con-&gt;ops-&gt;sign_message)
<span class="p_chunk">@@ -1228,7 +1252,6 @@</span> <span class="p_context"> static void prepare_write_message(struct ceph_connection *con)</span>
 	u32 crc;
 
 	con_out_kvec_reset(con);
<span class="p_del">-	con-&gt;out_kvec_is_msg = true;</span>
 	con-&gt;out_msg_done = false;
 
 	/* Sneak an ack in there first?  If we can get it into the same
<span class="p_chunk">@@ -1268,18 +1291,19 @@</span> <span class="p_context"> static void prepare_write_message(struct ceph_connection *con)</span>
 
 	/* tag + hdr + front + middle */
 	con_out_kvec_add(con, sizeof (tag_msg), &amp;tag_msg);
<span class="p_del">-	con_out_kvec_add(con, sizeof (m-&gt;hdr), &amp;m-&gt;hdr);</span>
<span class="p_add">+	con_out_kvec_add(con, sizeof(con-&gt;out_hdr), &amp;con-&gt;out_hdr);</span>
 	con_out_kvec_add(con, m-&gt;front.iov_len, m-&gt;front.iov_base);
 
 	if (m-&gt;middle)
 		con_out_kvec_add(con, m-&gt;middle-&gt;vec.iov_len,
 			m-&gt;middle-&gt;vec.iov_base);
 
<span class="p_del">-	/* fill in crc (except data pages), footer */</span>
<span class="p_add">+	/* fill in hdr crc and finalize hdr */</span>
 	crc = crc32c(0, &amp;m-&gt;hdr, offsetof(struct ceph_msg_header, crc));
 	con-&gt;out_msg-&gt;hdr.crc = cpu_to_le32(crc);
<span class="p_del">-	con-&gt;out_msg-&gt;footer.flags = 0;</span>
<span class="p_add">+	memcpy(&amp;con-&gt;out_hdr, &amp;con-&gt;out_msg-&gt;hdr, sizeof(con-&gt;out_hdr));</span>
 
<span class="p_add">+	/* fill in front and middle crc, footer */</span>
 	crc = crc32c(0, m-&gt;front.iov_base, m-&gt;front.iov_len);
 	con-&gt;out_msg-&gt;footer.front_crc = cpu_to_le32(crc);
 	if (m-&gt;middle) {
<span class="p_chunk">@@ -1291,6 +1315,7 @@</span> <span class="p_context"> static void prepare_write_message(struct ceph_connection *con)</span>
 	dout(&quot;%s front_crc %u middle_crc %u\n&quot;, __func__,
 	     le32_to_cpu(con-&gt;out_msg-&gt;footer.front_crc),
 	     le32_to_cpu(con-&gt;out_msg-&gt;footer.middle_crc));
<span class="p_add">+	con-&gt;out_msg-&gt;footer.flags = 0;</span>
 
 	/* is there a data payload? */
 	con-&gt;out_msg-&gt;footer.data_crc = 0;
<span class="p_chunk">@@ -1485,7 +1510,6 @@</span> <span class="p_context"> static int write_partial_kvec(struct ceph_connection *con)</span>
 		}
 	}
 	con-&gt;out_kvec_left = 0;
<span class="p_del">-	con-&gt;out_kvec_is_msg = false;</span>
 	ret = 1;
 out:
 	dout(&quot;write_partial_kvec %p %d left in %d kvecs ret = %d\n&quot;, con,
<span class="p_chunk">@@ -1577,6 +1601,7 @@</span> <span class="p_context"> static int write_partial_skip(struct ceph_connection *con)</span>
 {
 	int ret;
 
<span class="p_add">+	dout(&quot;%s %p %d left\n&quot;, __func__, con, con-&gt;out_skip);</span>
 	while (con-&gt;out_skip &gt; 0) {
 		size_t size = min(con-&gt;out_skip, (int) PAGE_CACHE_SIZE);
 
<span class="p_chunk">@@ -2493,13 +2518,13 @@</span> <span class="p_context"> more:</span>
 
 more_kvec:
 	/* kvec data queued? */
<span class="p_del">-	if (con-&gt;out_skip) {</span>
<span class="p_del">-		ret = write_partial_skip(con);</span>
<span class="p_add">+	if (con-&gt;out_kvec_left) {</span>
<span class="p_add">+		ret = write_partial_kvec(con);</span>
 		if (ret &lt;= 0)
 			goto out;
 	}
<span class="p_del">-	if (con-&gt;out_kvec_left) {</span>
<span class="p_del">-		ret = write_partial_kvec(con);</span>
<span class="p_add">+	if (con-&gt;out_skip) {</span>
<span class="p_add">+		ret = write_partial_skip(con);</span>
 		if (ret &lt;= 0)
 			goto out;
 	}
<span class="p_chunk">@@ -3033,16 +3058,31 @@</span> <span class="p_context"> void ceph_msg_revoke(struct ceph_msg *msg)</span>
 		ceph_msg_put(msg);
 	}
 	if (con-&gt;out_msg == msg) {
<span class="p_del">-		dout(&quot;%s %p msg %p - was sending\n&quot;, __func__, con, msg);</span>
<span class="p_del">-		con-&gt;out_msg = NULL;</span>
<span class="p_del">-		if (con-&gt;out_kvec_is_msg) {</span>
<span class="p_del">-			con-&gt;out_skip = con-&gt;out_kvec_bytes;</span>
<span class="p_del">-			con-&gt;out_kvec_is_msg = false;</span>
<span class="p_add">+		BUG_ON(con-&gt;out_skip);</span>
<span class="p_add">+		/* footer */</span>
<span class="p_add">+		if (con-&gt;out_msg_done) {</span>
<span class="p_add">+			con-&gt;out_skip += con_out_kvec_skip(con);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			BUG_ON(!msg-&gt;data_length);</span>
<span class="p_add">+			if (con-&gt;peer_features &amp; CEPH_FEATURE_MSG_AUTH)</span>
<span class="p_add">+				con-&gt;out_skip += sizeof(msg-&gt;footer);</span>
<span class="p_add">+			else</span>
<span class="p_add">+				con-&gt;out_skip += sizeof(msg-&gt;old_footer);</span>
 		}
<span class="p_add">+		/* data, middle, front */</span>
<span class="p_add">+		if (msg-&gt;data_length)</span>
<span class="p_add">+			con-&gt;out_skip += msg-&gt;cursor.total_resid;</span>
<span class="p_add">+		if (msg-&gt;middle)</span>
<span class="p_add">+			con-&gt;out_skip += con_out_kvec_skip(con);</span>
<span class="p_add">+		con-&gt;out_skip += con_out_kvec_skip(con);</span>
<span class="p_add">+</span>
<span class="p_add">+		dout(&quot;%s %p msg %p - was sending, will write %d skip %d\n&quot;,</span>
<span class="p_add">+		     __func__, con, msg, con-&gt;out_kvec_bytes, con-&gt;out_skip);</span>
 		msg-&gt;hdr.seq = 0;
<span class="p_del">-</span>
<span class="p_add">+		con-&gt;out_msg = NULL;</span>
 		ceph_msg_put(msg);
 	}
<span class="p_add">+</span>
 	mutex_unlock(&amp;con-&gt;mutex);
 }
 
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index a8e4dd4..f1f1dd8 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -2512,6 +2512,8 @@</span> <span class="p_context"> static inline bool skb_needs_check(struct sk_buff *skb, bool tx_path)</span>
  *
  *	It may return NULL if the skb requires no segmentation.  This is
  *	only possible when GSO is used for verifying header integrity.
<span class="p_add">+ *</span>
<span class="p_add">+ *	Segmentation preserves SKB_SGO_CB_OFFSET bytes of previous skb cb.</span>
  */
 struct sk_buff *__skb_gso_segment(struct sk_buff *skb,
 				  netdev_features_t features, bool tx_path)
<span class="p_chunk">@@ -2526,6 +2528,9 @@</span> <span class="p_context"> struct sk_buff *__skb_gso_segment(struct sk_buff *skb,</span>
 			return ERR_PTR(err);
 	}
 
<span class="p_add">+	BUILD_BUG_ON(SKB_SGO_CB_OFFSET +</span>
<span class="p_add">+		     sizeof(*SKB_GSO_CB(skb)) &gt; sizeof(skb-&gt;cb));</span>
<span class="p_add">+</span>
 	SKB_GSO_CB(skb)-&gt;mac_offset = skb_headroom(skb);
 	SKB_GSO_CB(skb)-&gt;encap_level = 0;
 
<span class="p_header">diff --git a/net/core/filter.c b/net/core/filter.c</span>
<span class="p_header">index 8dcdd86..515b50b 100644</span>
<span class="p_header">--- a/net/core/filter.c</span>
<span class="p_header">+++ b/net/core/filter.c</span>
<span class="p_chunk">@@ -779,6 +779,11 @@</span> <span class="p_context"> static int bpf_check_classic(const struct sock_filter *filter,</span>
 			if (ftest-&gt;k == 0)
 				return -EINVAL;
 			break;
<span class="p_add">+		case BPF_ALU | BPF_LSH | BPF_K:</span>
<span class="p_add">+		case BPF_ALU | BPF_RSH | BPF_K:</span>
<span class="p_add">+			if (ftest-&gt;k &gt;= 32)</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			break;</span>
 		case BPF_LD | BPF_MEM:
 		case BPF_LDX | BPF_MEM:
 		case BPF_ST:
<span class="p_header">diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c</span>
<span class="p_header">index 23fcc82..56b5daa 100644</span>
<span class="p_header">--- a/net/ipv4/ip_output.c</span>
<span class="p_header">+++ b/net/ipv4/ip_output.c</span>
<span class="p_chunk">@@ -240,6 +240,7 @@</span> <span class="p_context"> static int ip_finish_output_gso(struct sock *sk, struct sk_buff *skb,</span>
 	 * from host network stack.
 	 */
 	features = netif_skb_features(skb);
<span class="p_add">+	BUILD_BUG_ON(sizeof(*IPCB(skb)) &gt; SKB_SGO_CB_OFFSET);</span>
 	segs = skb_gso_segment(skb, features &amp; ~NETIF_F_GSO_MASK);
 	if (IS_ERR_OR_NULL(segs)) {
 		kfree_skb(skb);
<span class="p_chunk">@@ -918,7 +919,7 @@</span> <span class="p_context"> static int __ip_append_data(struct sock *sk,</span>
 	if (((length &gt; mtu) || (skb &amp;&amp; skb_is_gso(skb))) &amp;&amp;
 	    (sk-&gt;sk_protocol == IPPROTO_UDP) &amp;&amp;
 	    (rt-&gt;dst.dev-&gt;features &amp; NETIF_F_UFO) &amp;&amp; !rt-&gt;dst.header_len &amp;&amp;
<span class="p_del">-	    (sk-&gt;sk_type == SOCK_DGRAM)) {</span>
<span class="p_add">+	    (sk-&gt;sk_type == SOCK_DGRAM) &amp;&amp; !sk-&gt;sk_no_check_tx) {</span>
 		err = ip_ufo_append_data(sk, queue, getfrag, from, length,
 					 hh_len, fragheaderlen, transhdrlen,
 					 maxfraglen, flags);
<span class="p_header">diff --git a/net/ipv4/tcp_yeah.c b/net/ipv4/tcp_yeah.c</span>
<span class="p_header">index 17d3566..3e6a472 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_yeah.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_yeah.c</span>
<span class="p_chunk">@@ -219,7 +219,7 @@</span> <span class="p_context"> static u32 tcp_yeah_ssthresh(struct sock *sk)</span>
 	yeah-&gt;fast_count = 0;
 	yeah-&gt;reno_count = max(yeah-&gt;reno_count&gt;&gt;1, 2U);
 
<span class="p_del">-	return tp-&gt;snd_cwnd - reduction;</span>
<span class="p_add">+	return max_t(int, tp-&gt;snd_cwnd - reduction, 2);</span>
 }
 
 static struct tcp_congestion_ops tcp_yeah __read_mostly = {
<span class="p_header">diff --git a/net/ipv4/xfrm4_policy.c b/net/ipv4/xfrm4_policy.c</span>
<span class="p_header">index bff6974..7852608 100644</span>
<span class="p_header">--- a/net/ipv4/xfrm4_policy.c</span>
<span class="p_header">+++ b/net/ipv4/xfrm4_policy.c</span>
<span class="p_chunk">@@ -230,7 +230,7 @@</span> <span class="p_context"> static void xfrm4_dst_ifdown(struct dst_entry *dst, struct net_device *dev,</span>
 	xfrm_dst_ifdown(dst, dev);
 }
 
<span class="p_del">-static struct dst_ops xfrm4_dst_ops = {</span>
<span class="p_add">+static struct dst_ops xfrm4_dst_ops_template = {</span>
 	.family =		AF_INET,
 	.gc =			xfrm4_garbage_collect,
 	.update_pmtu =		xfrm4_update_pmtu,
<span class="p_chunk">@@ -244,7 +244,7 @@</span> <span class="p_context"> static struct dst_ops xfrm4_dst_ops = {</span>
 
 static struct xfrm_policy_afinfo xfrm4_policy_afinfo = {
 	.family = 		AF_INET,
<span class="p_del">-	.dst_ops =		&amp;xfrm4_dst_ops,</span>
<span class="p_add">+	.dst_ops =		&amp;xfrm4_dst_ops_template,</span>
 	.dst_lookup =		xfrm4_dst_lookup,
 	.get_saddr =		xfrm4_get_saddr,
 	.decode_session =	_decode_session4,
<span class="p_chunk">@@ -266,7 +266,7 @@</span> <span class="p_context"> static struct ctl_table xfrm4_policy_table[] = {</span>
 	{ }
 };
 
<span class="p_del">-static int __net_init xfrm4_net_init(struct net *net)</span>
<span class="p_add">+static int __net_init xfrm4_net_sysctl_init(struct net *net)</span>
 {
 	struct ctl_table *table;
 	struct ctl_table_header *hdr;
<span class="p_chunk">@@ -294,7 +294,7 @@</span> <span class="p_context"> err_alloc:</span>
 	return -ENOMEM;
 }
 
<span class="p_del">-static void __net_exit xfrm4_net_exit(struct net *net)</span>
<span class="p_add">+static void __net_exit xfrm4_net_sysctl_exit(struct net *net)</span>
 {
 	struct ctl_table *table;
 
<span class="p_chunk">@@ -306,12 +306,44 @@</span> <span class="p_context"> static void __net_exit xfrm4_net_exit(struct net *net)</span>
 	if (!net_eq(net, &amp;init_net))
 		kfree(table);
 }
<span class="p_add">+#else /* CONFIG_SYSCTL */</span>
<span class="p_add">+static int inline xfrm4_net_sysctl_init(struct net *net)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void inline xfrm4_net_sysctl_exit(struct net *net)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static int __net_init xfrm4_net_init(struct net *net)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy(&amp;net-&gt;xfrm.xfrm4_dst_ops, &amp;xfrm4_dst_ops_template,</span>
<span class="p_add">+	       sizeof(xfrm4_dst_ops_template));</span>
<span class="p_add">+	ret = dst_entries_init(&amp;net-&gt;xfrm.xfrm4_dst_ops);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = xfrm4_net_sysctl_init(net);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		dst_entries_destroy(&amp;net-&gt;xfrm.xfrm4_dst_ops);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __net_exit xfrm4_net_exit(struct net *net)</span>
<span class="p_add">+{</span>
<span class="p_add">+	xfrm4_net_sysctl_exit(net);</span>
<span class="p_add">+	dst_entries_destroy(&amp;net-&gt;xfrm.xfrm4_dst_ops);</span>
<span class="p_add">+}</span>
 
 static struct pernet_operations __net_initdata xfrm4_net_ops = {
 	.init	= xfrm4_net_init,
 	.exit	= xfrm4_net_exit,
 };
<span class="p_del">-#endif</span>
 
 static void __init xfrm4_policy_init(void)
 {
<span class="p_chunk">@@ -320,13 +352,9 @@</span> <span class="p_context"> static void __init xfrm4_policy_init(void)</span>
 
 void __init xfrm4_init(void)
 {
<span class="p_del">-	dst_entries_init(&amp;xfrm4_dst_ops);</span>
<span class="p_del">-</span>
 	xfrm4_state_init();
 	xfrm4_policy_init();
 	xfrm4_protocol_init();
<span class="p_del">-#ifdef CONFIG_SYSCTL</span>
 	register_pernet_subsys(&amp;xfrm4_net_ops);
<span class="p_del">-#endif</span>
 }
 
<span class="p_header">diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c</span>
<span class="p_header">index ba1a9ac..18382b0 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_output.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_output.c</span>
<span class="p_chunk">@@ -1331,7 +1331,7 @@</span> <span class="p_context"> emsgsize:</span>
 	     (skb &amp;&amp; skb_is_gso(skb))) &amp;&amp;
 	    (sk-&gt;sk_protocol == IPPROTO_UDP) &amp;&amp;
 	    (rt-&gt;dst.dev-&gt;features &amp; NETIF_F_UFO) &amp;&amp;
<span class="p_del">-	    (sk-&gt;sk_type == SOCK_DGRAM)) {</span>
<span class="p_add">+	    (sk-&gt;sk_type == SOCK_DGRAM) &amp;&amp; !udp_get_no_check6_tx(sk)) {</span>
 		err = ip6_ufo_append_data(sk, queue, getfrag, from, length,
 					  hh_len, fragheaderlen,
 					  transhdrlen, mtu, flags, fl6);
<span class="p_header">diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">index 682756c..8a51c16 100644</span>
<span class="p_header">--- a/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">+++ b/net/ipv6/tcp_ipv6.c</span>
<span class="p_chunk">@@ -462,8 +462,10 @@</span> <span class="p_context"> static int tcp_v6_send_synack(struct sock *sk, struct dst_entry *dst,</span>
 			fl6-&gt;flowlabel = ip6_flowlabel(ipv6_hdr(ireq-&gt;pktopts));
 
 		skb_set_queue_mapping(skb, queue_mapping);
<span class="p_add">+		rcu_read_lock();</span>
 		err = ip6_xmit(sk, skb, fl6, rcu_dereference(np-&gt;opt),
 			       np-&gt;tclass);
<span class="p_add">+		rcu_read_unlock();</span>
 		err = net_xmit_eval(err);
 	}
 
<span class="p_header">diff --git a/net/ipv6/xfrm6_mode_tunnel.c b/net/ipv6/xfrm6_mode_tunnel.c</span>
<span class="p_header">index 901ef6f..5266ad2 100644</span>
<span class="p_header">--- a/net/ipv6/xfrm6_mode_tunnel.c</span>
<span class="p_header">+++ b/net/ipv6/xfrm6_mode_tunnel.c</span>
<span class="p_chunk">@@ -24,7 +24,7 @@</span> <span class="p_context"> static inline void ipip6_ecn_decapsulate(struct sk_buff *skb)</span>
 	struct ipv6hdr *inner_iph = ipipv6_hdr(skb);
 
 	if (INET_ECN_is_ce(ipv6_get_dsfield(outer_iph)))
<span class="p_del">-		IP6_ECN_set_ce(inner_iph);</span>
<span class="p_add">+		IP6_ECN_set_ce(skb, inner_iph);</span>
 }
 
 /* Add encapsulation header.
<span class="p_header">diff --git a/net/ipv6/xfrm6_policy.c b/net/ipv6/xfrm6_policy.c</span>
<span class="p_header">index ed0583c..f4ae5dc 100644</span>
<span class="p_header">--- a/net/ipv6/xfrm6_policy.c</span>
<span class="p_header">+++ b/net/ipv6/xfrm6_policy.c</span>
<span class="p_chunk">@@ -274,7 +274,7 @@</span> <span class="p_context"> static void xfrm6_dst_ifdown(struct dst_entry *dst, struct net_device *dev,</span>
 	xfrm_dst_ifdown(dst, dev);
 }
 
<span class="p_del">-static struct dst_ops xfrm6_dst_ops = {</span>
<span class="p_add">+static struct dst_ops xfrm6_dst_ops_template = {</span>
 	.family =		AF_INET6,
 	.gc =			xfrm6_garbage_collect,
 	.update_pmtu =		xfrm6_update_pmtu,
<span class="p_chunk">@@ -288,7 +288,7 @@</span> <span class="p_context"> static struct dst_ops xfrm6_dst_ops = {</span>
 
 static struct xfrm_policy_afinfo xfrm6_policy_afinfo = {
 	.family =		AF_INET6,
<span class="p_del">-	.dst_ops =		&amp;xfrm6_dst_ops,</span>
<span class="p_add">+	.dst_ops =		&amp;xfrm6_dst_ops_template,</span>
 	.dst_lookup =		xfrm6_dst_lookup,
 	.get_saddr =		xfrm6_get_saddr,
 	.decode_session =	_decode_session6,
<span class="p_chunk">@@ -320,7 +320,7 @@</span> <span class="p_context"> static struct ctl_table xfrm6_policy_table[] = {</span>
 	{ }
 };
 
<span class="p_del">-static int __net_init xfrm6_net_init(struct net *net)</span>
<span class="p_add">+static int __net_init xfrm6_net_sysctl_init(struct net *net)</span>
 {
 	struct ctl_table *table;
 	struct ctl_table_header *hdr;
<span class="p_chunk">@@ -348,7 +348,7 @@</span> <span class="p_context"> err_alloc:</span>
 	return -ENOMEM;
 }
 
<span class="p_del">-static void __net_exit xfrm6_net_exit(struct net *net)</span>
<span class="p_add">+static void __net_exit xfrm6_net_sysctl_exit(struct net *net)</span>
 {
 	struct ctl_table *table;
 
<span class="p_chunk">@@ -360,24 +360,52 @@</span> <span class="p_context"> static void __net_exit xfrm6_net_exit(struct net *net)</span>
 	if (!net_eq(net, &amp;init_net))
 		kfree(table);
 }
<span class="p_add">+#else /* CONFIG_SYSCTL */</span>
<span class="p_add">+static int inline xfrm6_net_sysctl_init(struct net *net)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void inline xfrm6_net_sysctl_exit(struct net *net)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static int __net_init xfrm6_net_init(struct net *net)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy(&amp;net-&gt;xfrm.xfrm6_dst_ops, &amp;xfrm6_dst_ops_template,</span>
<span class="p_add">+	       sizeof(xfrm6_dst_ops_template));</span>
<span class="p_add">+	ret = dst_entries_init(&amp;net-&gt;xfrm.xfrm6_dst_ops);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = xfrm6_net_sysctl_init(net);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		dst_entries_destroy(&amp;net-&gt;xfrm.xfrm6_dst_ops);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __net_exit xfrm6_net_exit(struct net *net)</span>
<span class="p_add">+{</span>
<span class="p_add">+	xfrm6_net_sysctl_exit(net);</span>
<span class="p_add">+	dst_entries_destroy(&amp;net-&gt;xfrm.xfrm6_dst_ops);</span>
<span class="p_add">+}</span>
 
 static struct pernet_operations xfrm6_net_ops = {
 	.init	= xfrm6_net_init,
 	.exit	= xfrm6_net_exit,
 };
<span class="p_del">-#endif</span>
 
 int __init xfrm6_init(void)
 {
 	int ret;
 
<span class="p_del">-	dst_entries_init(&amp;xfrm6_dst_ops);</span>
<span class="p_del">-</span>
 	ret = xfrm6_policy_init();
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		dst_entries_destroy(&amp;xfrm6_dst_ops);</span>
<span class="p_add">+	if (ret)</span>
 		goto out;
<span class="p_del">-	}</span>
 	ret = xfrm6_state_init();
 	if (ret)
 		goto out_policy;
<span class="p_chunk">@@ -386,9 +414,7 @@</span> <span class="p_context"> int __init xfrm6_init(void)</span>
 	if (ret)
 		goto out_state;
 
<span class="p_del">-#ifdef CONFIG_SYSCTL</span>
 	register_pernet_subsys(&amp;xfrm6_net_ops);
<span class="p_del">-#endif</span>
 out:
 	return ret;
 out_state:
<span class="p_chunk">@@ -400,11 +426,8 @@</span> <span class="p_context"> out_policy:</span>
 
 void xfrm6_fini(void)
 {
<span class="p_del">-#ifdef CONFIG_SYSCTL</span>
 	unregister_pernet_subsys(&amp;xfrm6_net_ops);
<span class="p_del">-#endif</span>
 	xfrm6_protocol_fini();
 	xfrm6_policy_fini();
 	xfrm6_state_fini();
<span class="p_del">-	dst_entries_destroy(&amp;xfrm6_dst_ops);</span>
 }
<span class="p_header">diff --git a/net/mac80211/offchannel.c b/net/mac80211/offchannel.c</span>
<span class="p_header">index f2c75cf..0dc4291 100644</span>
<span class="p_header">--- a/net/mac80211/offchannel.c</span>
<span class="p_header">+++ b/net/mac80211/offchannel.c</span>
<span class="p_chunk">@@ -308,11 +308,10 @@</span> <span class="p_context"> void ieee80211_roc_notify_destroy(struct ieee80211_roc_work *roc, bool free)</span>
 
 	/* was never transmitted */
 	if (roc-&gt;frame) {
<span class="p_del">-		cfg80211_mgmt_tx_status(&amp;roc-&gt;sdata-&gt;wdev,</span>
<span class="p_del">-					(unsigned long)roc-&gt;frame,</span>
<span class="p_add">+		cfg80211_mgmt_tx_status(&amp;roc-&gt;sdata-&gt;wdev, roc-&gt;mgmt_tx_cookie,</span>
 					roc-&gt;frame-&gt;data, roc-&gt;frame-&gt;len,
 					false, GFP_KERNEL);
<span class="p_del">-		kfree_skb(roc-&gt;frame);</span>
<span class="p_add">+		ieee80211_free_txskb(&amp;roc-&gt;sdata-&gt;local-&gt;hw, roc-&gt;frame);</span>
 	}
 
 	if (!roc-&gt;mgmt_tx_cookie)
<span class="p_header">diff --git a/net/openvswitch/datapath.c b/net/openvswitch/datapath.c</span>
<span class="p_header">index ff332d1..1964ce5 100644</span>
<span class="p_header">--- a/net/openvswitch/datapath.c</span>
<span class="p_header">+++ b/net/openvswitch/datapath.c</span>
<span class="p_chunk">@@ -336,12 +336,10 @@</span> <span class="p_context"> static int queue_gso_packets(struct datapath *dp, struct sk_buff *skb,</span>
 	unsigned short gso_type = skb_shinfo(skb)-&gt;gso_type;
 	struct sw_flow_key later_key;
 	struct sk_buff *segs, *nskb;
<span class="p_del">-	struct ovs_skb_cb ovs_cb;</span>
 	int err;
 
<span class="p_del">-	ovs_cb = *OVS_CB(skb);</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(*OVS_CB(skb)) &gt; SKB_SGO_CB_OFFSET);</span>
 	segs = __skb_gso_segment(skb, NETIF_F_SG, false);
<span class="p_del">-	*OVS_CB(skb) = ovs_cb;</span>
 	if (IS_ERR(segs))
 		return PTR_ERR(segs);
 	if (segs == NULL)
<span class="p_chunk">@@ -359,7 +357,6 @@</span> <span class="p_context"> static int queue_gso_packets(struct datapath *dp, struct sk_buff *skb,</span>
 	/* Queue all of the segments. */
 	skb = segs;
 	do {
<span class="p_del">-		*OVS_CB(skb) = ovs_cb;</span>
 		if (gso_type &amp; SKB_GSO_UDP &amp;&amp; skb != segs)
 			key = &amp;later_key;
 
<span class="p_header">diff --git a/net/phonet/af_phonet.c b/net/phonet/af_phonet.c</span>
<span class="p_header">index 10d42f3..f925753 100644</span>
<span class="p_header">--- a/net/phonet/af_phonet.c</span>
<span class="p_header">+++ b/net/phonet/af_phonet.c</span>
<span class="p_chunk">@@ -377,6 +377,10 @@</span> <span class="p_context"> static int phonet_rcv(struct sk_buff *skb, struct net_device *dev,</span>
 	struct sockaddr_pn sa;
 	u16 len;
 
<span class="p_add">+	skb = skb_share_check(skb, GFP_ATOMIC);</span>
<span class="p_add">+	if (!skb)</span>
<span class="p_add">+		return NET_RX_DROP;</span>
<span class="p_add">+</span>
 	/* check we have at least a full Phonet header */
 	if (!pskb_pull(skb, sizeof(struct phonethdr)))
 		goto out;
<span class="p_header">diff --git a/net/sched/cls_flower.c b/net/sched/cls_flower.c</span>
<span class="p_header">index 2f3d03f..ec9b8ee 100644</span>
<span class="p_header">--- a/net/sched/cls_flower.c</span>
<span class="p_header">+++ b/net/sched/cls_flower.c</span>
<span class="p_chunk">@@ -252,23 +252,28 @@</span> <span class="p_context"> static int fl_set_key(struct net *net, struct nlattr **tb,</span>
 	fl_set_key_val(tb, key-&gt;eth.src, TCA_FLOWER_KEY_ETH_SRC,
 		       mask-&gt;eth.src, TCA_FLOWER_KEY_ETH_SRC_MASK,
 		       sizeof(key-&gt;eth.src));
<span class="p_add">+</span>
 	fl_set_key_val(tb, &amp;key-&gt;basic.n_proto, TCA_FLOWER_KEY_ETH_TYPE,
 		       &amp;mask-&gt;basic.n_proto, TCA_FLOWER_UNSPEC,
 		       sizeof(key-&gt;basic.n_proto));
<span class="p_add">+</span>
 	if (key-&gt;basic.n_proto == htons(ETH_P_IP) ||
 	    key-&gt;basic.n_proto == htons(ETH_P_IPV6)) {
 		fl_set_key_val(tb, &amp;key-&gt;basic.ip_proto, TCA_FLOWER_KEY_IP_PROTO,
 			       &amp;mask-&gt;basic.ip_proto, TCA_FLOWER_UNSPEC,
 			       sizeof(key-&gt;basic.ip_proto));
 	}
<span class="p_del">-	if (key-&gt;control.addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS) {</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tb[TCA_FLOWER_KEY_IPV4_SRC] || tb[TCA_FLOWER_KEY_IPV4_DST]) {</span>
<span class="p_add">+		key-&gt;control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;</span>
 		fl_set_key_val(tb, &amp;key-&gt;ipv4.src, TCA_FLOWER_KEY_IPV4_SRC,
 			       &amp;mask-&gt;ipv4.src, TCA_FLOWER_KEY_IPV4_SRC_MASK,
 			       sizeof(key-&gt;ipv4.src));
 		fl_set_key_val(tb, &amp;key-&gt;ipv4.dst, TCA_FLOWER_KEY_IPV4_DST,
 			       &amp;mask-&gt;ipv4.dst, TCA_FLOWER_KEY_IPV4_DST_MASK,
 			       sizeof(key-&gt;ipv4.dst));
<span class="p_del">-	} else if (key-&gt;control.addr_type == FLOW_DISSECTOR_KEY_IPV6_ADDRS) {</span>
<span class="p_add">+	} else if (tb[TCA_FLOWER_KEY_IPV6_SRC] || tb[TCA_FLOWER_KEY_IPV6_DST]) {</span>
<span class="p_add">+		key-&gt;control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;</span>
 		fl_set_key_val(tb, &amp;key-&gt;ipv6.src, TCA_FLOWER_KEY_IPV6_SRC,
 			       &amp;mask-&gt;ipv6.src, TCA_FLOWER_KEY_IPV6_SRC_MASK,
 			       sizeof(key-&gt;ipv6.src));
<span class="p_chunk">@@ -276,6 +281,7 @@</span> <span class="p_context"> static int fl_set_key(struct net *net, struct nlattr **tb,</span>
 			       &amp;mask-&gt;ipv6.dst, TCA_FLOWER_KEY_IPV6_DST_MASK,
 			       sizeof(key-&gt;ipv6.dst));
 	}
<span class="p_add">+</span>
 	if (key-&gt;basic.ip_proto == IPPROTO_TCP) {
 		fl_set_key_val(tb, &amp;key-&gt;tp.src, TCA_FLOWER_KEY_TCP_SRC,
 			       &amp;mask-&gt;tp.src, TCA_FLOWER_UNSPEC,
<span class="p_header">diff --git a/net/sctp/sm_statefuns.c b/net/sctp/sm_statefuns.c</span>
<span class="p_header">index 3809a74..68056f8 100644</span>
<span class="p_header">--- a/net/sctp/sm_statefuns.c</span>
<span class="p_header">+++ b/net/sctp/sm_statefuns.c</span>
<span class="p_chunk">@@ -4829,7 +4829,8 @@</span> <span class="p_context"> sctp_disposition_t sctp_sf_do_9_1_prm_abort(</span>
 
 	retval = SCTP_DISPOSITION_CONSUME;
 
<span class="p_del">-	sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));</span>
<span class="p_add">+	if (abort)</span>
<span class="p_add">+		sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));</span>
 
 	/* Even if we can&#39;t send the ABORT due to low memory delete the
 	 * TCB.  This is a departure from our typical NOMEM handling.
<span class="p_chunk">@@ -4966,7 +4967,8 @@</span> <span class="p_context"> sctp_disposition_t sctp_sf_cookie_wait_prm_abort(</span>
 			SCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));
 	retval = SCTP_DISPOSITION_CONSUME;
 
<span class="p_del">-	sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));</span>
<span class="p_add">+	if (abort)</span>
<span class="p_add">+		sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));</span>
 
 	sctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,
 			SCTP_STATE(SCTP_STATE_CLOSED));
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index 84b1b50..9dee804 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -1513,8 +1513,7 @@</span> <span class="p_context"> static void sctp_close(struct sock *sk, long timeout)</span>
 			struct sctp_chunk *chunk;
 
 			chunk = sctp_make_abort_user(asoc, NULL, 0);
<span class="p_del">-			if (chunk)</span>
<span class="p_del">-				sctp_primitive_ABORT(net, asoc, chunk);</span>
<span class="p_add">+			sctp_primitive_ABORT(net, asoc, chunk);</span>
 		} else
 			sctp_primitive_SHUTDOWN(net, asoc, NULL);
 	}
<span class="p_header">diff --git a/net/sctp/sysctl.c b/net/sctp/sysctl.c</span>
<span class="p_header">index 26d50c5..3e0fc51 100644</span>
<span class="p_header">--- a/net/sctp/sysctl.c</span>
<span class="p_header">+++ b/net/sctp/sysctl.c</span>
<span class="p_chunk">@@ -320,7 +320,7 @@</span> <span class="p_context"> static int proc_sctp_do_hmac_alg(struct ctl_table *ctl, int write,</span>
 	struct ctl_table tbl;
 	bool changed = false;
 	char *none = &quot;none&quot;;
<span class="p_del">-	char tmp[8];</span>
<span class="p_add">+	char tmp[8] = {0};</span>
 	int ret;
 
 	memset(&amp;tbl, 0, sizeof(struct ctl_table));
<span class="p_header">diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c</span>
<span class="p_header">index 0fc6dba..7926de1 100644</span>
<span class="p_header">--- a/net/unix/af_unix.c</span>
<span class="p_header">+++ b/net/unix/af_unix.c</span>
<span class="p_chunk">@@ -952,32 +952,20 @@</span> <span class="p_context"> fail:</span>
 	return NULL;
 }
 
<span class="p_del">-static int unix_mknod(const char *sun_path, umode_t mode, struct path *res)</span>
<span class="p_add">+static int unix_mknod(struct dentry *dentry, struct path *path, umode_t mode,</span>
<span class="p_add">+		      struct path *res)</span>
 {
<span class="p_del">-	struct dentry *dentry;</span>
<span class="p_del">-	struct path path;</span>
<span class="p_del">-	int err = 0;</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Get the parent directory, calculate the hash for last</span>
<span class="p_del">-	 * component.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	dentry = kern_path_create(AT_FDCWD, sun_path, &amp;path, 0);</span>
<span class="p_del">-	err = PTR_ERR(dentry);</span>
<span class="p_del">-	if (IS_ERR(dentry))</span>
<span class="p_del">-		return err;</span>
<span class="p_add">+	int err;</span>
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * All right, let&#39;s create it.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	err = security_path_mknod(&amp;path, dentry, mode, 0);</span>
<span class="p_add">+	err = security_path_mknod(path, dentry, mode, 0);</span>
 	if (!err) {
<span class="p_del">-		err = vfs_mknod(d_inode(path.dentry), dentry, mode, 0);</span>
<span class="p_add">+		err = vfs_mknod(d_inode(path-&gt;dentry), dentry, mode, 0);</span>
 		if (!err) {
<span class="p_del">-			res-&gt;mnt = mntget(path.mnt);</span>
<span class="p_add">+			res-&gt;mnt = mntget(path-&gt;mnt);</span>
 			res-&gt;dentry = dget(dentry);
 		}
 	}
<span class="p_del">-	done_path_create(&amp;path, dentry);</span>
<span class="p_add">+</span>
 	return err;
 }
 
<span class="p_chunk">@@ -988,10 +976,12 @@</span> <span class="p_context"> static int unix_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)</span>
 	struct unix_sock *u = unix_sk(sk);
 	struct sockaddr_un *sunaddr = (struct sockaddr_un *)uaddr;
 	char *sun_path = sunaddr-&gt;sun_path;
<span class="p_del">-	int err;</span>
<span class="p_add">+	int err, name_err;</span>
 	unsigned int hash;
 	struct unix_address *addr;
 	struct hlist_head *list;
<span class="p_add">+	struct path path;</span>
<span class="p_add">+	struct dentry *dentry;</span>
 
 	err = -EINVAL;
 	if (sunaddr-&gt;sun_family != AF_UNIX)
<span class="p_chunk">@@ -1007,14 +997,34 @@</span> <span class="p_context"> static int unix_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)</span>
 		goto out;
 	addr_len = err;
 
<span class="p_add">+	name_err = 0;</span>
<span class="p_add">+	dentry = NULL;</span>
<span class="p_add">+	if (sun_path[0]) {</span>
<span class="p_add">+		/* Get the parent directory, calculate the hash for last</span>
<span class="p_add">+		 * component.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		dentry = kern_path_create(AT_FDCWD, sun_path, &amp;path, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (IS_ERR(dentry)) {</span>
<span class="p_add">+			/* delay report until after &#39;already bound&#39; check */</span>
<span class="p_add">+			name_err = PTR_ERR(dentry);</span>
<span class="p_add">+			dentry = NULL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	err = mutex_lock_interruptible(&amp;u-&gt;readlock);
 	if (err)
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto out_path;</span>
 
 	err = -EINVAL;
 	if (u-&gt;addr)
 		goto out_up;
 
<span class="p_add">+	if (name_err) {</span>
<span class="p_add">+		err = name_err == -EEXIST ? -EADDRINUSE : name_err;</span>
<span class="p_add">+		goto out_up;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	err = -ENOMEM;
 	addr = kmalloc(sizeof(*addr)+addr_len, GFP_KERNEL);
 	if (!addr)
<span class="p_chunk">@@ -1025,11 +1035,11 @@</span> <span class="p_context"> static int unix_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)</span>
 	addr-&gt;hash = hash ^ sk-&gt;sk_type;
 	atomic_set(&amp;addr-&gt;refcnt, 1);
 
<span class="p_del">-	if (sun_path[0]) {</span>
<span class="p_del">-		struct path path;</span>
<span class="p_add">+	if (dentry) {</span>
<span class="p_add">+		struct path u_path;</span>
 		umode_t mode = S_IFSOCK |
 		       (SOCK_INODE(sock)-&gt;i_mode &amp; ~current_umask());
<span class="p_del">-		err = unix_mknod(sun_path, mode, &amp;path);</span>
<span class="p_add">+		err = unix_mknod(dentry, &amp;path, mode, &amp;u_path);</span>
 		if (err) {
 			if (err == -EEXIST)
 				err = -EADDRINUSE;
<span class="p_chunk">@@ -1037,9 +1047,9 @@</span> <span class="p_context"> static int unix_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)</span>
 			goto out_up;
 		}
 		addr-&gt;hash = UNIX_HASH_SIZE;
<span class="p_del">-		hash = d_backing_inode(path.dentry)-&gt;i_ino &amp; (UNIX_HASH_SIZE-1);</span>
<span class="p_add">+		hash = d_backing_inode(dentry)-&gt;i_ino &amp; (UNIX_HASH_SIZE - 1);</span>
 		spin_lock(&amp;unix_table_lock);
<span class="p_del">-		u-&gt;path = path;</span>
<span class="p_add">+		u-&gt;path = u_path;</span>
 		list = &amp;unix_socket_table[hash];
 	} else {
 		spin_lock(&amp;unix_table_lock);
<span class="p_chunk">@@ -1062,6 +1072,10 @@</span> <span class="p_context"> out_unlock:</span>
 	spin_unlock(&amp;unix_table_lock);
 out_up:
 	mutex_unlock(&amp;u-&gt;readlock);
<span class="p_add">+out_path:</span>
<span class="p_add">+	if (dentry)</span>
<span class="p_add">+		done_path_create(&amp;path, dentry);</span>
<span class="p_add">+</span>
 out:
 	return err;
 }
<span class="p_chunk">@@ -1498,6 +1512,21 @@</span> <span class="p_context"> static void unix_destruct_scm(struct sk_buff *skb)</span>
 	sock_wfree(skb);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * The &quot;user-&gt;unix_inflight&quot; variable is protected by the garbage</span>
<span class="p_add">+ * collection lock, and we just read it locklessly here. If you go</span>
<span class="p_add">+ * over the limit, there might be a tiny race in actually noticing</span>
<span class="p_add">+ * it across threads. Tough.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline bool too_many_unix_fds(struct task_struct *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct user_struct *user = current_user();</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(user-&gt;unix_inflight &gt; task_rlimit(p, RLIMIT_NOFILE)))</span>
<span class="p_add">+		return !capable(CAP_SYS_RESOURCE) &amp;&amp; !capable(CAP_SYS_ADMIN);</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define MAX_RECURSION_LEVEL 4
 
 static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)
<span class="p_chunk">@@ -1506,6 +1535,9 @@</span> <span class="p_context"> static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)</span>
 	unsigned char max_level = 0;
 	int unix_sock_count = 0;
 
<span class="p_add">+	if (too_many_unix_fds(current))</span>
<span class="p_add">+		return -ETOOMANYREFS;</span>
<span class="p_add">+</span>
 	for (i = scm-&gt;fp-&gt;count - 1; i &gt;= 0; i--) {
 		struct sock *sk = unix_get_socket(scm-&gt;fp-&gt;fp[i]);
 
<span class="p_chunk">@@ -1527,10 +1559,8 @@</span> <span class="p_context"> static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)</span>
 	if (!UNIXCB(skb).fp)
 		return -ENOMEM;
 
<span class="p_del">-	if (unix_sock_count) {</span>
<span class="p_del">-		for (i = scm-&gt;fp-&gt;count - 1; i &gt;= 0; i--)</span>
<span class="p_del">-			unix_inflight(scm-&gt;fp-&gt;fp[i]);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	for (i = scm-&gt;fp-&gt;count - 1; i &gt;= 0; i--)</span>
<span class="p_add">+		unix_inflight(scm-&gt;fp-&gt;fp[i]);</span>
 	return max_level;
 }
 
<span class="p_header">diff --git a/net/unix/garbage.c b/net/unix/garbage.c</span>
<span class="p_header">index a73a226..8fcdc22 100644</span>
<span class="p_header">--- a/net/unix/garbage.c</span>
<span class="p_header">+++ b/net/unix/garbage.c</span>
<span class="p_chunk">@@ -120,11 +120,11 @@</span> <span class="p_context"> void unix_inflight(struct file *fp)</span>
 {
 	struct sock *s = unix_get_socket(fp);
 
<span class="p_add">+	spin_lock(&amp;unix_gc_lock);</span>
<span class="p_add">+</span>
 	if (s) {
 		struct unix_sock *u = unix_sk(s);
 
<span class="p_del">-		spin_lock(&amp;unix_gc_lock);</span>
<span class="p_del">-</span>
 		if (atomic_long_inc_return(&amp;u-&gt;inflight) == 1) {
 			BUG_ON(!list_empty(&amp;u-&gt;link));
 			list_add_tail(&amp;u-&gt;link, &amp;gc_inflight_list);
<span class="p_chunk">@@ -132,25 +132,28 @@</span> <span class="p_context"> void unix_inflight(struct file *fp)</span>
 			BUG_ON(list_empty(&amp;u-&gt;link));
 		}
 		unix_tot_inflight++;
<span class="p_del">-		spin_unlock(&amp;unix_gc_lock);</span>
 	}
<span class="p_add">+	fp-&gt;f_cred-&gt;user-&gt;unix_inflight++;</span>
<span class="p_add">+	spin_unlock(&amp;unix_gc_lock);</span>
 }
 
 void unix_notinflight(struct file *fp)
 {
 	struct sock *s = unix_get_socket(fp);
 
<span class="p_add">+	spin_lock(&amp;unix_gc_lock);</span>
<span class="p_add">+</span>
 	if (s) {
 		struct unix_sock *u = unix_sk(s);
 
<span class="p_del">-		spin_lock(&amp;unix_gc_lock);</span>
 		BUG_ON(list_empty(&amp;u-&gt;link));
 
 		if (atomic_long_dec_and_test(&amp;u-&gt;inflight))
 			list_del_init(&amp;u-&gt;link);
 		unix_tot_inflight--;
<span class="p_del">-		spin_unlock(&amp;unix_gc_lock);</span>
 	}
<span class="p_add">+	fp-&gt;f_cred-&gt;user-&gt;unix_inflight--;</span>
<span class="p_add">+	spin_unlock(&amp;unix_gc_lock);</span>
 }
 
 static void scan_inflight(struct sock *x, void (*func)(struct unix_sock *),
<span class="p_header">diff --git a/net/xfrm/xfrm_output.c b/net/xfrm/xfrm_output.c</span>
<span class="p_header">index 68ada2c..443f78c 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_output.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_output.c</span>
<span class="p_chunk">@@ -165,6 +165,8 @@</span> <span class="p_context"> static int xfrm_output_gso(struct sock *sk, struct sk_buff *skb)</span>
 {
 	struct sk_buff *segs;
 
<span class="p_add">+	BUILD_BUG_ON(sizeof(*IPCB(skb)) &gt; SKB_SGO_CB_OFFSET);</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(*IP6CB(skb)) &gt; SKB_SGO_CB_OFFSET);</span>
 	segs = skb_gso_segment(skb, 0);
 	kfree_skb(skb);
 	if (IS_ERR(segs))
<span class="p_header">diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c</span>
<span class="p_header">index 2718184..b5680ad 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_policy.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_policy.c</span>
<span class="p_chunk">@@ -2816,7 +2816,6 @@</span> <span class="p_context"> static struct neighbour *xfrm_neigh_lookup(const struct dst_entry *dst,</span>
 
 int xfrm_policy_register_afinfo(struct xfrm_policy_afinfo *afinfo)
 {
<span class="p_del">-	struct net *net;</span>
 	int err = 0;
 	if (unlikely(afinfo == NULL))
 		return -EINVAL;
<span class="p_chunk">@@ -2847,26 +2846,6 @@</span> <span class="p_context"> int xfrm_policy_register_afinfo(struct xfrm_policy_afinfo *afinfo)</span>
 	}
 	spin_unlock(&amp;xfrm_policy_afinfo_lock);
 
<span class="p_del">-	rtnl_lock();</span>
<span class="p_del">-	for_each_net(net) {</span>
<span class="p_del">-		struct dst_ops *xfrm_dst_ops;</span>
<span class="p_del">-</span>
<span class="p_del">-		switch (afinfo-&gt;family) {</span>
<span class="p_del">-		case AF_INET:</span>
<span class="p_del">-			xfrm_dst_ops = &amp;net-&gt;xfrm.xfrm4_dst_ops;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-#if IS_ENABLED(CONFIG_IPV6)</span>
<span class="p_del">-		case AF_INET6:</span>
<span class="p_del">-			xfrm_dst_ops = &amp;net-&gt;xfrm.xfrm6_dst_ops;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-		default:</span>
<span class="p_del">-			BUG();</span>
<span class="p_del">-		}</span>
<span class="p_del">-		*xfrm_dst_ops = *afinfo-&gt;dst_ops;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	rtnl_unlock();</span>
<span class="p_del">-</span>
 	return err;
 }
 EXPORT_SYMBOL(xfrm_policy_register_afinfo);
<span class="p_chunk">@@ -2902,22 +2881,6 @@</span> <span class="p_context"> int xfrm_policy_unregister_afinfo(struct xfrm_policy_afinfo *afinfo)</span>
 }
 EXPORT_SYMBOL(xfrm_policy_unregister_afinfo);
 
<span class="p_del">-static void __net_init xfrm_dst_ops_init(struct net *net)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct xfrm_policy_afinfo *afinfo;</span>
<span class="p_del">-</span>
<span class="p_del">-	rcu_read_lock();</span>
<span class="p_del">-	afinfo = rcu_dereference(xfrm_policy_afinfo[AF_INET]);</span>
<span class="p_del">-	if (afinfo)</span>
<span class="p_del">-		net-&gt;xfrm.xfrm4_dst_ops = *afinfo-&gt;dst_ops;</span>
<span class="p_del">-#if IS_ENABLED(CONFIG_IPV6)</span>
<span class="p_del">-	afinfo = rcu_dereference(xfrm_policy_afinfo[AF_INET6]);</span>
<span class="p_del">-	if (afinfo)</span>
<span class="p_del">-		net-&gt;xfrm.xfrm6_dst_ops = *afinfo-&gt;dst_ops;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	rcu_read_unlock();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int xfrm_dev_event(struct notifier_block *this, unsigned long event, void *ptr)
 {
 	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
<span class="p_chunk">@@ -3066,7 +3029,6 @@</span> <span class="p_context"> static int __net_init xfrm_net_init(struct net *net)</span>
 	rv = xfrm_policy_init(net);
 	if (rv &lt; 0)
 		goto out_policy;
<span class="p_del">-	xfrm_dst_ops_init(net);</span>
 	rv = xfrm_sysctl_init(net);
 	if (rv &lt; 0)
 		goto out_sysctl;
<span class="p_header">diff --git a/scripts/Makefile.extrawarn b/scripts/Makefile.extrawarn</span>
<span class="p_header">index f734033..0f8ba77 100644</span>
<span class="p_header">--- a/scripts/Makefile.extrawarn</span>
<span class="p_header">+++ b/scripts/Makefile.extrawarn</span>
<span class="p_chunk">@@ -25,6 +25,7 @@</span> <span class="p_context"> warning-1 += -Wold-style-definition</span>
 warning-1 += $(call cc-option, -Wmissing-include-dirs)
 warning-1 += $(call cc-option, -Wunused-but-set-variable)
 warning-1 += $(call cc-disable-warning, missing-field-initializers)
<span class="p_add">+warning-1 += $(call cc-disable-warning, sign-compare)</span>
 
 warning-2 := -Waggregate-return
 warning-2 += -Wcast-align
<span class="p_chunk">@@ -33,6 +34,7 @@</span> <span class="p_context"> warning-2 += -Wnested-externs</span>
 warning-2 += -Wshadow
 warning-2 += $(call cc-option, -Wlogical-op)
 warning-2 += $(call cc-option, -Wmissing-field-initializers)
<span class="p_add">+warning-2 += $(call cc-option, -Wsign-compare)</span>
 
 warning-3 := -Wbad-function-cast
 warning-3 += -Wcast-qual
<span class="p_header">diff --git a/scripts/bloat-o-meter b/scripts/bloat-o-meter</span>
<span class="p_header">index 23e78dc..38b64f4 100755</span>
<span class="p_header">--- a/scripts/bloat-o-meter</span>
<span class="p_header">+++ b/scripts/bloat-o-meter</span>
<span class="p_chunk">@@ -58,8 +58,8 @@</span> <span class="p_context"> for name in common:</span>
 delta.sort()
 delta.reverse()
 
<span class="p_del">-print &quot;add/remove: %s/%s grow/shrink: %s/%s up/down: %s/%s (%s)&quot; % \</span>
<span class="p_del">-      (add, remove, grow, shrink, up, -down, up-down)</span>
<span class="p_del">-print &quot;%-40s %7s %7s %+7s&quot; % (&quot;function&quot;, &quot;old&quot;, &quot;new&quot;, &quot;delta&quot;)</span>
<span class="p_add">+print(&quot;add/remove: %s/%s grow/shrink: %s/%s up/down: %s/%s (%s)&quot; % \</span>
<span class="p_add">+      (add, remove, grow, shrink, up, -down, up-down))</span>
<span class="p_add">+print(&quot;%-40s %7s %7s %+7s&quot; % (&quot;function&quot;, &quot;old&quot;, &quot;new&quot;, &quot;delta&quot;))</span>
 for d, n in delta:
<span class="p_del">-    if d: print &quot;%-40s %7s %7s %+7d&quot; % (n, old.get(n,&quot;-&quot;), new.get(n,&quot;-&quot;), d)</span>
<span class="p_add">+    if d: print(&quot;%-40s %7s %7s %+7d&quot; % (n, old.get(n,&quot;-&quot;), new.get(n,&quot;-&quot;), d))</span>
<span class="p_header">diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c</span>
<span class="p_header">index b05cc3d..aed678e 100644</span>
<span class="p_header">--- a/scripts/kconfig/menu.c</span>
<span class="p_header">+++ b/scripts/kconfig/menu.c</span>
<span class="p_chunk">@@ -477,7 +477,7 @@</span> <span class="p_context"> bool menu_is_visible(struct menu *menu)</span>
 
 	if (menu-&gt;visibility) {
 		if (expr_calc_value(menu-&gt;visibility) == no)
<span class="p_del">-			return no;</span>
<span class="p_add">+			return false;</span>
 	}
 
 	sym = menu-&gt;sym;
<span class="p_header">diff --git a/scripts/recordmcount.pl b/scripts/recordmcount.pl</span>
<span class="p_header">index 826470d..96e2486 100755</span>
<span class="p_header">--- a/scripts/recordmcount.pl</span>
<span class="p_header">+++ b/scripts/recordmcount.pl</span>
<span class="p_chunk">@@ -263,7 +263,8 @@</span> <span class="p_context"> if ($arch eq &quot;x86_64&quot;) {</span>
 
 } elsif ($arch eq &quot;powerpc&quot;) {
     $local_regex = &quot;^[0-9a-fA-F]+\\s+t\\s+(\\.?\\S+)&quot;;
<span class="p_del">-    $function_regex = &quot;^([0-9a-fA-F]+)\\s+&lt;(\\.?.*?)&gt;:&quot;;</span>
<span class="p_add">+    # See comment in the sparc64 section for why we use &#39;\w&#39;.</span>
<span class="p_add">+    $function_regex = &quot;^([0-9a-fA-F]+)\\s+&lt;(\\.?\\w*?)&gt;:&quot;;</span>
     $mcount_regex = &quot;^\\s*([0-9a-fA-F]+):.*\\s\\.?_mcount\$&quot;;
 
     if ($bits == 64) {
<span class="p_header">diff --git a/sound/core/control.c b/sound/core/control.c</span>
<span class="p_header">index 196a6fe..a85d455 100644</span>
<span class="p_header">--- a/sound/core/control.c</span>
<span class="p_header">+++ b/sound/core/control.c</span>
<span class="p_chunk">@@ -1405,6 +1405,8 @@</span> <span class="p_context"> static int snd_ctl_tlv_ioctl(struct snd_ctl_file *file,</span>
 		return -EFAULT;
 	if (tlv.length &lt; sizeof(unsigned int) * 2)
 		return -EINVAL;
<span class="p_add">+	if (!tlv.numid)</span>
<span class="p_add">+		return -EINVAL;</span>
 	down_read(&amp;card-&gt;controls_rwsem);
 	kctl = snd_ctl_find_numid(card, tlv.numid);
 	if (kctl == NULL) {
<span class="p_header">diff --git a/sound/core/hrtimer.c b/sound/core/hrtimer.c</span>
<span class="p_header">index f845ecf..656d9a9 100644</span>
<span class="p_header">--- a/sound/core/hrtimer.c</span>
<span class="p_header">+++ b/sound/core/hrtimer.c</span>
<span class="p_chunk">@@ -90,7 +90,7 @@</span> <span class="p_context"> static int snd_hrtimer_start(struct snd_timer *t)</span>
 	struct snd_hrtimer *stime = t-&gt;private_data;
 
 	atomic_set(&amp;stime-&gt;running, 0);
<span class="p_del">-	hrtimer_cancel(&amp;stime-&gt;hrt);</span>
<span class="p_add">+	hrtimer_try_to_cancel(&amp;stime-&gt;hrt);</span>
 	hrtimer_start(&amp;stime-&gt;hrt, ns_to_ktime(t-&gt;sticks * resolution),
 		      HRTIMER_MODE_REL);
 	atomic_set(&amp;stime-&gt;running, 1);
<span class="p_chunk">@@ -101,6 +101,7 @@</span> <span class="p_context"> static int snd_hrtimer_stop(struct snd_timer *t)</span>
 {
 	struct snd_hrtimer *stime = t-&gt;private_data;
 	atomic_set(&amp;stime-&gt;running, 0);
<span class="p_add">+	hrtimer_try_to_cancel(&amp;stime-&gt;hrt);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/sound/core/pcm_compat.c b/sound/core/pcm_compat.c</span>
<span class="p_header">index b48b434..9630e9f 100644</span>
<span class="p_header">--- a/sound/core/pcm_compat.c</span>
<span class="p_header">+++ b/sound/core/pcm_compat.c</span>
<span class="p_chunk">@@ -255,10 +255,15 @@</span> <span class="p_context"> static int snd_pcm_ioctl_hw_params_compat(struct snd_pcm_substream *substream,</span>
 	if (! (runtime = substream-&gt;runtime))
 		return -ENOTTY;
 
<span class="p_del">-	/* only fifo_size is different, so just copy all */</span>
<span class="p_del">-	data = memdup_user(data32, sizeof(*data32));</span>
<span class="p_del">-	if (IS_ERR(data))</span>
<span class="p_del">-		return PTR_ERR(data);</span>
<span class="p_add">+	data = kmalloc(sizeof(*data), GFP_KERNEL);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* only fifo_size (RO from userspace) is different, so just copy all */</span>
<span class="p_add">+	if (copy_from_user(data, data32, sizeof(*data32))) {</span>
<span class="p_add">+		err = -EFAULT;</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	}</span>
 
 	if (refine)
 		err = snd_pcm_hw_refine(substream, data);
<span class="p_header">diff --git a/sound/core/seq/seq_clientmgr.c b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">index b64f20d..13cfa81 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_chunk">@@ -1962,7 +1962,7 @@</span> <span class="p_context"> static int snd_seq_ioctl_remove_events(struct snd_seq_client *client,</span>
 		 * No restrictions so for a user client we can clear
 		 * the whole fifo
 		 */
<span class="p_del">-		if (client-&gt;type == USER_CLIENT)</span>
<span class="p_add">+		if (client-&gt;type == USER_CLIENT &amp;&amp; client-&gt;data.user.fifo)</span>
 			snd_seq_fifo_clear(client-&gt;data.user.fifo);
 	}
 
<span class="p_header">diff --git a/sound/core/seq/seq_compat.c b/sound/core/seq/seq_compat.c</span>
<span class="p_header">index 81f7c10..6517590 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_compat.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_compat.c</span>
<span class="p_chunk">@@ -49,11 +49,12 @@</span> <span class="p_context"> static int snd_seq_call_port_info_ioctl(struct snd_seq_client *client, unsigned</span>
 	struct snd_seq_port_info *data;
 	mm_segment_t fs;
 
<span class="p_del">-	data = memdup_user(data32, sizeof(*data32));</span>
<span class="p_del">-	if (IS_ERR(data))</span>
<span class="p_del">-		return PTR_ERR(data);</span>
<span class="p_add">+	data = kmalloc(sizeof(*data), GFP_KERNEL);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
<span class="p_del">-	if (get_user(data-&gt;flags, &amp;data32-&gt;flags) ||</span>
<span class="p_add">+	if (copy_from_user(data, data32, sizeof(*data32)) ||</span>
<span class="p_add">+	    get_user(data-&gt;flags, &amp;data32-&gt;flags) ||</span>
 	    get_user(data-&gt;time_queue, &amp;data32-&gt;time_queue))
 		goto error;
 	data-&gt;kernel = NULL;
<span class="p_header">diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c</span>
<span class="p_header">index 7dfd0f4..0bec02e 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_queue.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_queue.c</span>
<span class="p_chunk">@@ -142,8 +142,10 @@</span> <span class="p_context"> static struct snd_seq_queue *queue_new(int owner, int locked)</span>
 static void queue_delete(struct snd_seq_queue *q)
 {
 	/* stop and release the timer */
<span class="p_add">+	mutex_lock(&amp;q-&gt;timer_mutex);</span>
 	snd_seq_timer_stop(q-&gt;timer);
 	snd_seq_timer_close(q);
<span class="p_add">+	mutex_unlock(&amp;q-&gt;timer_mutex);</span>
 	/* wait until access free */
 	snd_use_lock_sync(&amp;q-&gt;use_lock);
 	/* release resources... */
<span class="p_header">diff --git a/sound/core/timer.c b/sound/core/timer.c</span>
<span class="p_header">index 31f40f0..0a049c4 100644</span>
<span class="p_header">--- a/sound/core/timer.c</span>
<span class="p_header">+++ b/sound/core/timer.c</span>
<span class="p_chunk">@@ -65,6 +65,7 @@</span> <span class="p_context"> struct snd_timer_user {</span>
 	int qtail;
 	int qused;
 	int queue_size;
<span class="p_add">+	bool disconnected;</span>
 	struct snd_timer_read *queue;
 	struct snd_timer_tread *tqueue;
 	spinlock_t qlock;
<span class="p_chunk">@@ -73,7 +74,7 @@</span> <span class="p_context"> struct snd_timer_user {</span>
 	struct timespec tstamp;		/* trigger tstamp */
 	wait_queue_head_t qchange_sleep;
 	struct fasync_struct *fasync;
<span class="p_del">-	struct mutex tread_sem;</span>
<span class="p_add">+	struct mutex ioctl_lock;</span>
 };
 
 /* list of timers */
<span class="p_chunk">@@ -215,11 +216,13 @@</span> <span class="p_context"> static void snd_timer_check_master(struct snd_timer_instance *master)</span>
 		    slave-&gt;slave_id == master-&gt;slave_id) {
 			list_move_tail(&amp;slave-&gt;open_list, &amp;master-&gt;slave_list_head);
 			spin_lock_irq(&amp;slave_active_lock);
<span class="p_add">+			spin_lock(&amp;master-&gt;timer-&gt;lock);</span>
 			slave-&gt;master = master;
 			slave-&gt;timer = master-&gt;timer;
 			if (slave-&gt;flags &amp; SNDRV_TIMER_IFLG_RUNNING)
 				list_add_tail(&amp;slave-&gt;active_list,
 					      &amp;master-&gt;slave_active_head);
<span class="p_add">+			spin_unlock(&amp;master-&gt;timer-&gt;lock);</span>
 			spin_unlock_irq(&amp;slave_active_lock);
 		}
 	}
<span class="p_chunk">@@ -288,6 +291,9 @@</span> <span class="p_context"> int snd_timer_open(struct snd_timer_instance **ti,</span>
 		mutex_unlock(&amp;register_mutex);
 		return -ENOMEM;
 	}
<span class="p_add">+	/* take a card refcount for safe disconnection */</span>
<span class="p_add">+	if (timer-&gt;card)</span>
<span class="p_add">+		get_device(&amp;timer-&gt;card-&gt;card_dev);</span>
 	timeri-&gt;slave_class = tid-&gt;dev_sclass;
 	timeri-&gt;slave_id = slave_id;
 	if (list_empty(&amp;timer-&gt;open_list_head) &amp;&amp; timer-&gt;hw.open)
<span class="p_chunk">@@ -346,15 +352,21 @@</span> <span class="p_context"> int snd_timer_close(struct snd_timer_instance *timeri)</span>
 		    timer-&gt;hw.close)
 			timer-&gt;hw.close(timer);
 		/* remove slave links */
<span class="p_add">+		spin_lock_irq(&amp;slave_active_lock);</span>
<span class="p_add">+		spin_lock(&amp;timer-&gt;lock);</span>
 		list_for_each_entry_safe(slave, tmp, &amp;timeri-&gt;slave_list_head,
 					 open_list) {
<span class="p_del">-			spin_lock_irq(&amp;slave_active_lock);</span>
<span class="p_del">-			_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);</span>
 			list_move_tail(&amp;slave-&gt;open_list, &amp;snd_timer_slave_list);
 			slave-&gt;master = NULL;
 			slave-&gt;timer = NULL;
<span class="p_del">-			spin_unlock_irq(&amp;slave_active_lock);</span>
<span class="p_add">+			list_del_init(&amp;slave-&gt;ack_list);</span>
<span class="p_add">+			list_del_init(&amp;slave-&gt;active_list);</span>
 		}
<span class="p_add">+		spin_unlock(&amp;timer-&gt;lock);</span>
<span class="p_add">+		spin_unlock_irq(&amp;slave_active_lock);</span>
<span class="p_add">+		/* release a card refcount for safe disconnection */</span>
<span class="p_add">+		if (timer-&gt;card)</span>
<span class="p_add">+			put_device(&amp;timer-&gt;card-&gt;card_dev);</span>
 		mutex_unlock(&amp;register_mutex);
 	}
  out:
<span class="p_chunk">@@ -441,9 +453,12 @@</span> <span class="p_context"> static int snd_timer_start_slave(struct snd_timer_instance *timeri)</span>
 
 	spin_lock_irqsave(&amp;slave_active_lock, flags);
 	timeri-&gt;flags |= SNDRV_TIMER_IFLG_RUNNING;
<span class="p_del">-	if (timeri-&gt;master)</span>
<span class="p_add">+	if (timeri-&gt;master &amp;&amp; timeri-&gt;timer) {</span>
<span class="p_add">+		spin_lock(&amp;timeri-&gt;timer-&gt;lock);</span>
 		list_add_tail(&amp;timeri-&gt;active_list,
 			      &amp;timeri-&gt;master-&gt;slave_active_head);
<span class="p_add">+		spin_unlock(&amp;timeri-&gt;timer-&gt;lock);</span>
<span class="p_add">+	}</span>
 	spin_unlock_irqrestore(&amp;slave_active_lock, flags);
 	return 1; /* delayed start */
 }
<span class="p_chunk">@@ -467,6 +482,8 @@</span> <span class="p_context"> int snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks)</span>
 	timer = timeri-&gt;timer;
 	if (timer == NULL)
 		return -EINVAL;
<span class="p_add">+	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown)</span>
<span class="p_add">+		return -ENODEV;</span>
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
 	timeri-&gt;ticks = timeri-&gt;cticks = ticks;
 	timeri-&gt;pticks = 0;
<span class="p_chunk">@@ -489,6 +506,8 @@</span> <span class="p_context"> static int _snd_timer_stop(struct snd_timer_instance * timeri,</span>
 		if (!keep_flag) {
 			spin_lock_irqsave(&amp;slave_active_lock, flags);
 			timeri-&gt;flags &amp;= ~SNDRV_TIMER_IFLG_RUNNING;
<span class="p_add">+			list_del_init(&amp;timeri-&gt;ack_list);</span>
<span class="p_add">+			list_del_init(&amp;timeri-&gt;active_list);</span>
 			spin_unlock_irqrestore(&amp;slave_active_lock, flags);
 		}
 		goto __end;
<span class="p_chunk">@@ -499,6 +518,10 @@</span> <span class="p_context"> static int _snd_timer_stop(struct snd_timer_instance * timeri,</span>
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
 	list_del_init(&amp;timeri-&gt;ack_list);
 	list_del_init(&amp;timeri-&gt;active_list);
<span class="p_add">+	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown) {</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;timer-&gt;lock, flags);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
 	if ((timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_RUNNING) &amp;&amp;
 	    !(--timer-&gt;running)) {
 		timer-&gt;hw.stop(timer);
<span class="p_chunk">@@ -561,6 +584,8 @@</span> <span class="p_context"> int snd_timer_continue(struct snd_timer_instance *timeri)</span>
 	timer = timeri-&gt;timer;
 	if (! timer)
 		return -EINVAL;
<span class="p_add">+	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown)</span>
<span class="p_add">+		return -ENODEV;</span>
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
 	if (!timeri-&gt;cticks)
 		timeri-&gt;cticks = 1;
<span class="p_chunk">@@ -624,6 +649,9 @@</span> <span class="p_context"> static void snd_timer_tasklet(unsigned long arg)</span>
 	unsigned long resolution, ticks;
 	unsigned long flags;
 
<span class="p_add">+	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
 	/* now process all callbacks */
 	while (!list_empty(&amp;timer-&gt;sack_list_head)) {
<span class="p_chunk">@@ -664,6 +692,9 @@</span> <span class="p_context"> void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)</span>
 	if (timer == NULL)
 		return;
 
<span class="p_add">+	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
 
 	/* remember the current resolution */
<span class="p_chunk">@@ -694,7 +725,7 @@</span> <span class="p_context"> void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)</span>
 		} else {
 			ti-&gt;flags &amp;= ~SNDRV_TIMER_IFLG_RUNNING;
 			if (--timer-&gt;running)
<span class="p_del">-				list_del(&amp;ti-&gt;active_list);</span>
<span class="p_add">+				list_del_init(&amp;ti-&gt;active_list);</span>
 		}
 		if ((timer-&gt;hw.flags &amp; SNDRV_TIMER_HW_TASKLET) ||
 		    (ti-&gt;flags &amp; SNDRV_TIMER_IFLG_FAST))
<span class="p_chunk">@@ -874,11 +905,28 @@</span> <span class="p_context"> static int snd_timer_dev_register(struct snd_device *dev)</span>
 	return 0;
 }
 
<span class="p_add">+/* just for reference in snd_timer_dev_disconnect() below */</span>
<span class="p_add">+static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,</span>
<span class="p_add">+				     int event, struct timespec *tstamp,</span>
<span class="p_add">+				     unsigned long resolution);</span>
<span class="p_add">+</span>
 static int snd_timer_dev_disconnect(struct snd_device *device)
 {
 	struct snd_timer *timer = device-&gt;device_data;
<span class="p_add">+	struct snd_timer_instance *ti;</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;register_mutex);
 	list_del_init(&amp;timer-&gt;device_list);
<span class="p_add">+	/* wake up pending sleepers */</span>
<span class="p_add">+	list_for_each_entry(ti, &amp;timer-&gt;open_list_head, open_list) {</span>
<span class="p_add">+		/* FIXME: better to have a ti.disconnect() op */</span>
<span class="p_add">+		if (ti-&gt;ccallback == snd_timer_user_ccallback) {</span>
<span class="p_add">+			struct snd_timer_user *tu = ti-&gt;callback_data;</span>
<span class="p_add">+</span>
<span class="p_add">+			tu-&gt;disconnected = true;</span>
<span class="p_add">+			wake_up(&amp;tu-&gt;qchange_sleep);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 	mutex_unlock(&amp;register_mutex);
 	return 0;
 }
<span class="p_chunk">@@ -889,6 +937,8 @@</span> <span class="p_context"> void snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstam</span>
 	unsigned long resolution = 0;
 	struct snd_timer_instance *ti, *ts;
 
<span class="p_add">+	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown)</span>
<span class="p_add">+		return;</span>
 	if (! (timer-&gt;hw.flags &amp; SNDRV_TIMER_HW_SLAVE))
 		return;
 	if (snd_BUG_ON(event &lt; SNDRV_TIMER_EVENT_MSTART ||
<span class="p_chunk">@@ -1047,6 +1097,8 @@</span> <span class="p_context"> static void snd_timer_proc_read(struct snd_info_entry *entry,</span>
 
 	mutex_lock(&amp;register_mutex);
 	list_for_each_entry(timer, &amp;snd_timer_list, device_list) {
<span class="p_add">+		if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown)</span>
<span class="p_add">+			continue;</span>
 		switch (timer-&gt;tmr_class) {
 		case SNDRV_TIMER_CLASS_GLOBAL:
 			snd_iprintf(buffer, &quot;G%i: &quot;, timer-&gt;tmr_device);
<span class="p_chunk">@@ -1253,7 +1305,7 @@</span> <span class="p_context"> static int snd_timer_user_open(struct inode *inode, struct file *file)</span>
 		return -ENOMEM;
 	spin_lock_init(&amp;tu-&gt;qlock);
 	init_waitqueue_head(&amp;tu-&gt;qchange_sleep);
<span class="p_del">-	mutex_init(&amp;tu-&gt;tread_sem);</span>
<span class="p_add">+	mutex_init(&amp;tu-&gt;ioctl_lock);</span>
 	tu-&gt;ticks = 1;
 	tu-&gt;queue_size = 128;
 	tu-&gt;queue = kmalloc(tu-&gt;queue_size * sizeof(struct snd_timer_read),
<span class="p_chunk">@@ -1273,8 +1325,10 @@</span> <span class="p_context"> static int snd_timer_user_release(struct inode *inode, struct file *file)</span>
 	if (file-&gt;private_data) {
 		tu = file-&gt;private_data;
 		file-&gt;private_data = NULL;
<span class="p_add">+		mutex_lock(&amp;tu-&gt;ioctl_lock);</span>
 		if (tu-&gt;timeri)
 			snd_timer_close(tu-&gt;timeri);
<span class="p_add">+		mutex_unlock(&amp;tu-&gt;ioctl_lock);</span>
 		kfree(tu-&gt;queue);
 		kfree(tu-&gt;tqueue);
 		kfree(tu);
<span class="p_chunk">@@ -1512,7 +1566,6 @@</span> <span class="p_context"> static int snd_timer_user_tselect(struct file *file,</span>
 	int err = 0;
 
 	tu = file-&gt;private_data;
<span class="p_del">-	mutex_lock(&amp;tu-&gt;tread_sem);</span>
 	if (tu-&gt;timeri) {
 		snd_timer_close(tu-&gt;timeri);
 		tu-&gt;timeri = NULL;
<span class="p_chunk">@@ -1556,7 +1609,6 @@</span> <span class="p_context"> static int snd_timer_user_tselect(struct file *file,</span>
 	}
 
       __err:
<span class="p_del">-      	mutex_unlock(&amp;tu-&gt;tread_sem);</span>
 	return err;
 }
 
<span class="p_chunk">@@ -1769,7 +1821,7 @@</span> <span class="p_context"> enum {</span>
 	SNDRV_TIMER_IOCTL_PAUSE_OLD = _IO(&#39;T&#39;, 0x23),
 };
 
<span class="p_del">-static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,</span>
<span class="p_add">+static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,</span>
 				 unsigned long arg)
 {
 	struct snd_timer_user *tu;
<span class="p_chunk">@@ -1786,17 +1838,11 @@</span> <span class="p_context"> static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,</span>
 	{
 		int xarg;
 
<span class="p_del">-		mutex_lock(&amp;tu-&gt;tread_sem);</span>
<span class="p_del">-		if (tu-&gt;timeri)	{	/* too late */</span>
<span class="p_del">-			mutex_unlock(&amp;tu-&gt;tread_sem);</span>
<span class="p_add">+		if (tu-&gt;timeri)	/* too late */</span>
 			return -EBUSY;
<span class="p_del">-		}</span>
<span class="p_del">-		if (get_user(xarg, p)) {</span>
<span class="p_del">-			mutex_unlock(&amp;tu-&gt;tread_sem);</span>
<span class="p_add">+		if (get_user(xarg, p))</span>
 			return -EFAULT;
<span class="p_del">-		}</span>
 		tu-&gt;tread = xarg ? 1 : 0;
<span class="p_del">-		mutex_unlock(&amp;tu-&gt;tread_sem);</span>
 		return 0;
 	}
 	case SNDRV_TIMER_IOCTL_GINFO:
<span class="p_chunk">@@ -1829,6 +1875,18 @@</span> <span class="p_context"> static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,</span>
 	return -ENOTTY;
 }
 
<span class="p_add">+static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,</span>
<span class="p_add">+				 unsigned long arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct snd_timer_user *tu = file-&gt;private_data;</span>
<span class="p_add">+	long ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;tu-&gt;ioctl_lock);</span>
<span class="p_add">+	ret = __snd_timer_user_ioctl(file, cmd, arg);</span>
<span class="p_add">+	mutex_unlock(&amp;tu-&gt;ioctl_lock);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int snd_timer_user_fasync(int fd, struct file * file, int on)
 {
 	struct snd_timer_user *tu;
<span class="p_chunk">@@ -1866,6 +1924,10 @@</span> <span class="p_context"> static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,</span>
 
 			remove_wait_queue(&amp;tu-&gt;qchange_sleep, &amp;wait);
 
<span class="p_add">+			if (tu-&gt;disconnected) {</span>
<span class="p_add">+				err = -ENODEV;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
 			if (signal_pending(current)) {
 				err = -ERESTARTSYS;
 				break;
<span class="p_chunk">@@ -1915,6 +1977,8 @@</span> <span class="p_context"> static unsigned int snd_timer_user_poll(struct file *file, poll_table * wait)</span>
 	mask = 0;
 	if (tu-&gt;qused)
 		mask |= POLLIN | POLLRDNORM;
<span class="p_add">+	if (tu-&gt;disconnected)</span>
<span class="p_add">+		mask |= POLLERR;</span>
 
 	return mask;
 }
<span class="p_header">diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c</span>
<span class="p_header">index 1fdd92b6..096fd58 100644</span>
<span class="p_header">--- a/sound/pci/fm801.c</span>
<span class="p_header">+++ b/sound/pci/fm801.c</span>
<span class="p_chunk">@@ -1080,26 +1080,20 @@</span> <span class="p_context"> static int wait_for_codec(struct fm801 *chip, unsigned int codec_id,</span>
 	return -EIO;
 }
 
<span class="p_del">-static int snd_fm801_chip_init(struct fm801 *chip, int resume)</span>
<span class="p_add">+static int reset_codec(struct fm801 *chip)</span>
 {
<span class="p_del">-	unsigned short cmdw;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (chip-&gt;tea575x_tuner &amp; TUNER_ONLY)</span>
<span class="p_del">-		goto __ac97_ok;</span>
<span class="p_del">-</span>
 	/* codec cold reset + AC&#39;97 warm reset */
 	fm801_writew(chip, CODEC_CTRL, (1 &lt;&lt; 5) | (1 &lt;&lt; 6));
 	fm801_readw(chip, CODEC_CTRL); /* flush posting data */
 	udelay(100);
 	fm801_writew(chip, CODEC_CTRL, 0);
 
<span class="p_del">-	if (wait_for_codec(chip, 0, AC97_RESET, msecs_to_jiffies(750)) &lt; 0)</span>
<span class="p_del">-		if (!resume) {</span>
<span class="p_del">-			dev_info(chip-&gt;card-&gt;dev,</span>
<span class="p_del">-				 &quot;Primary AC&#39;97 codec not found, assume SF64-PCR (tuner-only)\n&quot;);</span>
<span class="p_del">-			chip-&gt;tea575x_tuner = 3 | TUNER_ONLY;</span>
<span class="p_del">-			goto __ac97_ok;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	return wait_for_codec(chip, 0, AC97_RESET, msecs_to_jiffies(750));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void snd_fm801_chip_multichannel_init(struct fm801 *chip)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned short cmdw;</span>
 
 	if (chip-&gt;multichannel) {
 		if (chip-&gt;secondary_addr) {
<span class="p_chunk">@@ -1126,8 +1120,11 @@</span> <span class="p_context"> static int snd_fm801_chip_init(struct fm801 *chip, int resume)</span>
 		/* cause timeout problems */
 		wait_for_codec(chip, 0, AC97_VENDOR_ID1, msecs_to_jiffies(750));
 	}
<span class="p_add">+}</span>
 
<span class="p_del">-      __ac97_ok:</span>
<span class="p_add">+static void snd_fm801_chip_init(struct fm801 *chip)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned short cmdw;</span>
 
 	/* init volume */
 	fm801_writew(chip, PCM_VOL, 0x0808);
<span class="p_chunk">@@ -1148,11 +1145,8 @@</span> <span class="p_context"> static int snd_fm801_chip_init(struct fm801 *chip, int resume)</span>
 	/* interrupt clear */
 	fm801_writew(chip, IRQ_STATUS,
 		     FM801_IRQ_PLAYBACK | FM801_IRQ_CAPTURE | FM801_IRQ_MPU);
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
 }
 
<span class="p_del">-</span>
 static int snd_fm801_free(struct fm801 *chip)
 {
 	unsigned short cmdw;
<span class="p_chunk">@@ -1165,6 +1159,8 @@</span> <span class="p_context"> static int snd_fm801_free(struct fm801 *chip)</span>
 	cmdw |= 0x00c3;
 	fm801_writew(chip, IRQ_MASK, cmdw);
 
<span class="p_add">+	devm_free_irq(&amp;chip-&gt;pci-&gt;dev, chip-&gt;irq, chip);</span>
<span class="p_add">+</span>
       __end_hw:
 #ifdef CONFIG_SND_FM801_TEA575X_BOOL
 	if (!(chip-&gt;tea575x_tuner &amp; TUNER_DISABLED)) {
<span class="p_chunk">@@ -1207,7 +1203,23 @@</span> <span class="p_context"> static int snd_fm801_create(struct snd_card *card,</span>
 	if ((err = pci_request_regions(pci, &quot;FM801&quot;)) &lt; 0)
 		return err;
 	chip-&gt;port = pci_resource_start(pci, 0);
<span class="p_del">-	if ((tea575x_tuner &amp; TUNER_ONLY) == 0) {</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pci-&gt;revision &gt;= 0xb1)	/* FM801-AU */</span>
<span class="p_add">+		chip-&gt;multichannel = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(chip-&gt;tea575x_tuner &amp; TUNER_ONLY)) {</span>
<span class="p_add">+		if (reset_codec(chip) &lt; 0) {</span>
<span class="p_add">+			dev_info(chip-&gt;card-&gt;dev,</span>
<span class="p_add">+				 &quot;Primary AC&#39;97 codec not found, assume SF64-PCR (tuner-only)\n&quot;);</span>
<span class="p_add">+			chip-&gt;tea575x_tuner = 3 | TUNER_ONLY;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			snd_fm801_chip_multichannel_init(chip);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	snd_fm801_chip_init(chip);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((chip-&gt;tea575x_tuner &amp; TUNER_ONLY) == 0) {</span>
 		if (devm_request_irq(&amp;pci-&gt;dev, pci-&gt;irq, snd_fm801_interrupt,
 				IRQF_SHARED, KBUILD_MODNAME, chip)) {
 			dev_err(card-&gt;dev, &quot;unable to grab IRQ %d\n&quot;, pci-&gt;irq);
<span class="p_chunk">@@ -1218,13 +1230,6 @@</span> <span class="p_context"> static int snd_fm801_create(struct snd_card *card,</span>
 		pci_set_master(pci);
 	}
 
<span class="p_del">-	if (pci-&gt;revision &gt;= 0xb1)	/* FM801-AU */</span>
<span class="p_del">-		chip-&gt;multichannel = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	snd_fm801_chip_init(chip, 0);</span>
<span class="p_del">-	/* init might set tuner access method */</span>
<span class="p_del">-	tea575x_tuner = chip-&gt;tea575x_tuner;</span>
<span class="p_del">-</span>
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &amp;ops)) &lt; 0) {
 		snd_fm801_free(chip);
 		return err;
<span class="p_chunk">@@ -1241,14 +1246,16 @@</span> <span class="p_context"> static int snd_fm801_create(struct snd_card *card,</span>
 	chip-&gt;tea.private_data = chip;
 	chip-&gt;tea.ops = &amp;snd_fm801_tea_ops;
 	sprintf(chip-&gt;tea.bus_info, &quot;PCI:%s&quot;, pci_name(pci));
<span class="p_del">-	if ((tea575x_tuner &amp; TUNER_TYPE_MASK) &gt; 0 &amp;&amp;</span>
<span class="p_del">-	    (tea575x_tuner &amp; TUNER_TYPE_MASK) &lt; 4) {</span>
<span class="p_add">+	if ((chip-&gt;tea575x_tuner &amp; TUNER_TYPE_MASK) &gt; 0 &amp;&amp;</span>
<span class="p_add">+	    (chip-&gt;tea575x_tuner &amp; TUNER_TYPE_MASK) &lt; 4) {</span>
 		if (snd_tea575x_init(&amp;chip-&gt;tea, THIS_MODULE)) {
 			dev_err(card-&gt;dev, &quot;TEA575x radio not found\n&quot;);
 			snd_fm801_free(chip);
 			return -ENODEV;
 		}
<span class="p_del">-	} else if ((tea575x_tuner &amp; TUNER_TYPE_MASK) == 0) {</span>
<span class="p_add">+	} else if ((chip-&gt;tea575x_tuner &amp; TUNER_TYPE_MASK) == 0) {</span>
<span class="p_add">+		unsigned int tuner_only = chip-&gt;tea575x_tuner &amp; TUNER_ONLY;</span>
<span class="p_add">+</span>
 		/* autodetect tuner connection */
 		for (tea575x_tuner = 1; tea575x_tuner &lt;= 3; tea575x_tuner++) {
 			chip-&gt;tea575x_tuner = tea575x_tuner;
<span class="p_chunk">@@ -1263,6 +1270,8 @@</span> <span class="p_context"> static int snd_fm801_create(struct snd_card *card,</span>
 			dev_err(card-&gt;dev, &quot;TEA575x radio not found\n&quot;);
 			chip-&gt;tea575x_tuner = TUNER_DISABLED;
 		}
<span class="p_add">+</span>
<span class="p_add">+		chip-&gt;tea575x_tuner |= tuner_only;</span>
 	}
 	if (!(chip-&gt;tea575x_tuner &amp; TUNER_DISABLED)) {
 		strlcpy(chip-&gt;tea.card, get_tea575x_gpio(chip)-&gt;name,
<span class="p_chunk">@@ -1381,7 +1390,13 @@</span> <span class="p_context"> static int snd_fm801_resume(struct device *dev)</span>
 	struct fm801 *chip = card-&gt;private_data;
 	int i;
 
<span class="p_del">-	snd_fm801_chip_init(chip, 1);</span>
<span class="p_add">+	if (chip-&gt;tea575x_tuner &amp; TUNER_ONLY) {</span>
<span class="p_add">+		snd_fm801_chip_init(chip);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		reset_codec(chip);</span>
<span class="p_add">+		snd_fm801_chip_multichannel_init(chip);</span>
<span class="p_add">+		snd_fm801_chip_init(chip);</span>
<span class="p_add">+	}</span>
 	snd_ac97_resume(chip-&gt;ac97);
 	snd_ac97_resume(chip-&gt;ac97_sec);
 	for (i = 0; i &lt; ARRAY_SIZE(saved_regs); i++)
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index de2b2e2..e61fbf4 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -2100,9 +2100,17 @@</span> <span class="p_context"> i915_power_fail:</span>
 static void azx_remove(struct pci_dev *pci)
 {
 	struct snd_card *card = pci_get_drvdata(pci);
<span class="p_add">+	struct azx *chip;</span>
<span class="p_add">+	struct hda_intel *hda;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (card) {</span>
<span class="p_add">+		/* flush the pending probing work */</span>
<span class="p_add">+		chip = card-&gt;private_data;</span>
<span class="p_add">+		hda = container_of(chip, struct hda_intel, chip);</span>
<span class="p_add">+		flush_work(&amp;hda-&gt;probe_work);</span>
 
<span class="p_del">-	if (card)</span>
 		snd_card_free(card);
<span class="p_add">+	}</span>
 }
 
 static void azx_shutdown(struct pci_dev *pci)
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 1e5627b..7cace05 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -4676,6 +4676,7 @@</span> <span class="p_context"> enum {</span>
 	ALC290_FIXUP_SUBWOOFER,
 	ALC290_FIXUP_SUBWOOFER_HSJACK,
 	ALC269_FIXUP_THINKPAD_ACPI,
<span class="p_add">+	ALC269_FIXUP_DMIC_THINKPAD_ACPI,</span>
 	ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
 	ALC255_FIXUP_DELL2_MIC_NO_PRESENCE,
 	ALC255_FIXUP_HEADSET_MODE,
<span class="p_chunk">@@ -5113,6 +5114,12 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 		.type = HDA_FIXUP_FUNC,
 		.v.func = hda_fixup_thinkpad_acpi,
 	},
<span class="p_add">+	[ALC269_FIXUP_DMIC_THINKPAD_ACPI] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc_fixup_inv_dmic,</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC269_FIXUP_THINKPAD_ACPI,</span>
<span class="p_add">+	},</span>
 	[ALC255_FIXUP_DELL1_MIC_NO_PRESENCE] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
<span class="p_chunk">@@ -5334,6 +5341,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x0470, &quot;Dell M101z&quot;, ALC269_FIXUP_DELL_M101Z),
 	SND_PCI_QUIRK(0x1028, 0x054b, &quot;Dell XPS one 2710&quot;, ALC275_FIXUP_DELL_XPS),
 	SND_PCI_QUIRK(0x1028, 0x05bd, &quot;Dell Latitude E6440&quot;, ALC292_FIXUP_DELL_E7X),
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x05be, &quot;Dell Latitude E6540&quot;, ALC292_FIXUP_DELL_E7X),</span>
 	SND_PCI_QUIRK(0x1028, 0x05ca, &quot;Dell Latitude E7240&quot;, ALC292_FIXUP_DELL_E7X),
 	SND_PCI_QUIRK(0x1028, 0x05cb, &quot;Dell Latitude E7440&quot;, ALC292_FIXUP_DELL_E7X),
 	SND_PCI_QUIRK(0x1028, 0x05da, &quot;Dell Vostro 5460&quot;, ALC290_FIXUP_SUBWOOFER),
<span class="p_chunk">@@ -5342,6 +5350,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x05f6, &quot;Dell&quot;, ALC269_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x0615, &quot;Dell Vostro 5470&quot;, ALC290_FIXUP_SUBWOOFER_HSJACK),
 	SND_PCI_QUIRK(0x1028, 0x0616, &quot;Dell Vostro 5470&quot;, ALC290_FIXUP_SUBWOOFER_HSJACK),
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x062c, &quot;Dell Latitude E5550&quot;, ALC292_FIXUP_DELL_E7X),</span>
 	SND_PCI_QUIRK(0x1028, 0x062e, &quot;Dell Latitude E7450&quot;, ALC292_FIXUP_DELL_E7X),
 	SND_PCI_QUIRK(0x1028, 0x0638, &quot;Dell Inspiron 5439&quot;, ALC290_FIXUP_MONO_SPEAKERS_HSJACK),
 	SND_PCI_QUIRK(0x1028, 0x064a, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
<span class="p_chunk">@@ -5467,6 +5476,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x2226, &quot;ThinkPad X250&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2233, &quot;Thinkpad&quot;, ALC293_FIXUP_LENOVO_SPK_NOISE),
 	SND_PCI_QUIRK(0x17aa, 0x30bb, &quot;ThinkCentre AIO&quot;, ALC233_FIXUP_LENOVO_LINE2_MIC_HOTKEY),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x3902, &quot;Lenovo E50-80&quot;, ALC269_FIXUP_DMIC_THINKPAD_ACPI),</span>
 	SND_PCI_QUIRK(0x17aa, 0x3977, &quot;IdeaPad S210&quot;, ALC283_FIXUP_INT_MIC),
 	SND_PCI_QUIRK(0x17aa, 0x3978, &quot;IdeaPad Y410P&quot;, ALC269_FIXUP_NO_SHUTUP),
 	SND_PCI_QUIRK(0x17aa, 0x5013, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
<span class="p_chunk">@@ -5710,6 +5720,10 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
 		ALC255_STANDARD_PINS,
 		{0x12, 0x90a60170},
<span class="p_add">+		{0x14, 0x90171130},</span>
<span class="p_add">+		{0x21, 0x02211040}),</span>
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
<span class="p_add">+		{0x12, 0x90a60170},</span>
 		{0x14, 0x90170140},
 		{0x17, 0x40000000},
 		{0x1d, 0x40700001},
<span class="p_chunk">@@ -6760,6 +6774,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc662_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x069f, &quot;Dell&quot;, ALC668_FIXUP_DELL_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x103c, 0x1632, &quot;HP RP5800&quot;, ALC662_FIXUP_HP_RP5800),
 	SND_PCI_QUIRK(0x1043, 0x11cd, &quot;Asus N550&quot;, ALC662_FIXUP_BASS_1A),
<span class="p_add">+	SND_PCI_QUIRK(0x1043, 0x13df, &quot;Asus N550JX&quot;, ALC662_FIXUP_BASS_1A),</span>
 	SND_PCI_QUIRK(0x1043, 0x1477, &quot;ASUS N56VZ&quot;, ALC662_FIXUP_BASS_MODE4_CHMAP),
 	SND_PCI_QUIRK(0x1043, 0x15a7, &quot;ASUS UX51VZH&quot;, ALC662_FIXUP_BASS_16),
 	SND_PCI_QUIRK(0x1043, 0x1b73, &quot;ASUS N55SF&quot;, ALC662_FIXUP_BASS_16),
<span class="p_header">diff --git a/sound/soc/intel/atom/sst/sst_stream.c b/sound/soc/intel/atom/sst/sst_stream.c</span>
<span class="p_header">index a74c64c..4ccc80e 100644</span>
<span class="p_header">--- a/sound/soc/intel/atom/sst/sst_stream.c</span>
<span class="p_header">+++ b/sound/soc/intel/atom/sst/sst_stream.c</span>
<span class="p_chunk">@@ -108,7 +108,7 @@</span> <span class="p_context"> int sst_alloc_stream_mrfld(struct intel_sst_drv *sst_drv_ctx, void *params)</span>
 			str_id, pipe_id);
 	ret = sst_prepare_and_post_msg(sst_drv_ctx, task_id, IPC_CMD,
 			IPC_IA_ALLOC_STREAM_MRFLD, pipe_id, sizeof(alloc_param),
<span class="p_del">-			&amp;alloc_param, data, true, true, false, true);</span>
<span class="p_add">+			&amp;alloc_param, &amp;data, true, true, false, true);</span>
 
 	if (ret &lt; 0) {
 		dev_err(sst_drv_ctx-&gt;dev, &quot;FW alloc failed ret %d\n&quot;, ret);
<span class="p_header">diff --git a/sound/soc/soc-compress.c b/sound/soc/soc-compress.c</span>
<span class="p_header">index 025c38f..1874cf0 100644</span>
<span class="p_header">--- a/sound/soc/soc-compress.c</span>
<span class="p_header">+++ b/sound/soc/soc-compress.c</span>
<span class="p_chunk">@@ -623,6 +623,7 @@</span> <span class="p_context"> int soc_new_compress(struct snd_soc_pcm_runtime *rtd, int num)</span>
 	struct snd_pcm *be_pcm;
 	char new_name[64];
 	int ret = 0, direction = 0;
<span class="p_add">+	int playback = 0, capture = 0;</span>
 
 	if (rtd-&gt;num_codecs &gt; 1) {
 		dev_err(rtd-&gt;card-&gt;dev, &quot;Multicodec not supported for compressed stream\n&quot;);
<span class="p_chunk">@@ -634,11 +635,27 @@</span> <span class="p_context"> int soc_new_compress(struct snd_soc_pcm_runtime *rtd, int num)</span>
 			rtd-&gt;dai_link-&gt;stream_name, codec_dai-&gt;name, num);
 
 	if (codec_dai-&gt;driver-&gt;playback.channels_min)
<span class="p_add">+		playback = 1;</span>
<span class="p_add">+	if (codec_dai-&gt;driver-&gt;capture.channels_min)</span>
<span class="p_add">+		capture = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	capture = capture &amp;&amp; cpu_dai-&gt;driver-&gt;capture.channels_min;</span>
<span class="p_add">+	playback = playback &amp;&amp; cpu_dai-&gt;driver-&gt;playback.channels_min;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Compress devices are unidirectional so only one of the directions</span>
<span class="p_add">+	 * should be set, check for that (xor)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (playback + capture != 1) {</span>
<span class="p_add">+		dev_err(rtd-&gt;card-&gt;dev, &quot;Invalid direction for compress P %d, C %d\n&quot;,</span>
<span class="p_add">+				playback, capture);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if(playback)</span>
 		direction = SND_COMPRESS_PLAYBACK;
<span class="p_del">-	else if (codec_dai-&gt;driver-&gt;capture.channels_min)</span>
<span class="p_del">-		direction = SND_COMPRESS_CAPTURE;</span>
 	else
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		direction = SND_COMPRESS_CAPTURE;</span>
 
 	compr = kzalloc(sizeof(*compr), GFP_KERNEL);
 	if (compr == NULL) {
<span class="p_header">diff --git a/sound/soc/tegra/tegra_alc5632.c b/sound/soc/tegra/tegra_alc5632.c</span>
<span class="p_header">index ba272e2..deb597f 100644</span>
<span class="p_header">--- a/sound/soc/tegra/tegra_alc5632.c</span>
<span class="p_header">+++ b/sound/soc/tegra/tegra_alc5632.c</span>
<span class="p_chunk">@@ -101,12 +101,16 @@</span> <span class="p_context"> static const struct snd_kcontrol_new tegra_alc5632_controls[] = {</span>
 
 static int tegra_alc5632_asoc_init(struct snd_soc_pcm_runtime *rtd)
 {
<span class="p_add">+	int ret;</span>
 	struct tegra_alc5632 *machine = snd_soc_card_get_drvdata(rtd-&gt;card);
 
<span class="p_del">-	snd_soc_card_jack_new(rtd-&gt;card, &quot;Headset Jack&quot;, SND_JACK_HEADSET,</span>
<span class="p_del">-			      &amp;tegra_alc5632_hs_jack,</span>
<span class="p_del">-			      tegra_alc5632_hs_jack_pins,</span>
<span class="p_del">-			      ARRAY_SIZE(tegra_alc5632_hs_jack_pins));</span>
<span class="p_add">+	ret = snd_soc_card_jack_new(rtd-&gt;card, &quot;Headset Jack&quot;,</span>
<span class="p_add">+				    SND_JACK_HEADSET,</span>
<span class="p_add">+				    &amp;tegra_alc5632_hs_jack,</span>
<span class="p_add">+				    tegra_alc5632_hs_jack_pins,</span>
<span class="p_add">+				    ARRAY_SIZE(tegra_alc5632_hs_jack_pins));</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	if (gpio_is_valid(machine-&gt;gpio_hp_det)) {
 		tegra_alc5632_hp_jack_gpio.gpio = machine-&gt;gpio_hp_det;
<span class="p_header">diff --git a/sound/usb/mixer_quirks.c b/sound/usb/mixer_quirks.c</span>
<span class="p_header">index 48a7450..db9547d 100644</span>
<span class="p_header">--- a/sound/usb/mixer_quirks.c</span>
<span class="p_header">+++ b/sound/usb/mixer_quirks.c</span>
<span class="p_chunk">@@ -803,7 +803,7 @@</span> <span class="p_context"> static int snd_nativeinstruments_control_put(struct snd_kcontrol *kcontrol,</span>
 		return 0;
 
 	kcontrol-&gt;private_value &amp;= ~(0xff &lt;&lt; 24);
<span class="p_del">-	kcontrol-&gt;private_value |= newval;</span>
<span class="p_add">+	kcontrol-&gt;private_value |= (unsigned int)newval &lt;&lt; 24;</span>
 	err = snd_ni_update_cur_val(list);
 	return err &lt; 0 ? err : 1;
 }
<span class="p_header">diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c</span>
<span class="p_header">index c73c379..fb9a8a5 100644</span>
<span class="p_header">--- a/sound/usb/quirks.c</span>
<span class="p_header">+++ b/sound/usb/quirks.c</span>
<span class="p_chunk">@@ -1266,6 +1266,7 @@</span> <span class="p_context"> u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,</span>
 	case USB_ID(0x20b1, 0x3008): /* iFi Audio micro/nano iDSD */
 	case USB_ID(0x20b1, 0x2008): /* Matrix Audio X-Sabre */
 	case USB_ID(0x20b1, 0x300a): /* Matrix Audio Mini-i Pro */
<span class="p_add">+	case USB_ID(0x22d8, 0x0416): /* OPPO HA-1*/</span>
 		if (fp-&gt;altsetting == 2)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;
<span class="p_header">diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c</span>
<span class="p_header">index 96234b6..5d51d6f 100644</span>
<span class="p_header">--- a/tools/hv/hv_vss_daemon.c</span>
<span class="p_header">+++ b/tools/hv/hv_vss_daemon.c</span>
<span class="p_chunk">@@ -254,7 +254,7 @@</span> <span class="p_context"> int main(int argc, char *argv[])</span>
 			syslog(LOG_ERR, &quot;Illegal op:%d\n&quot;, op);
 		}
 		vss_msg-&gt;error = error;
<span class="p_del">-		len = write(vss_fd, &amp;error, sizeof(struct hv_vss_msg));</span>
<span class="p_add">+		len = write(vss_fd, vss_msg, sizeof(struct hv_vss_msg));</span>
 		if (len != sizeof(struct hv_vss_msg)) {
 			syslog(LOG_ERR, &quot;write failed; error: %d %s&quot;, errno,
 			       strerror(errno));
<span class="p_header">diff --git a/tools/lib/traceevent/event-parse.c b/tools/lib/traceevent/event-parse.c</span>
<span class="p_header">index a843bee..bcd5be7 100644</span>
<span class="p_header">--- a/tools/lib/traceevent/event-parse.c</span>
<span class="p_header">+++ b/tools/lib/traceevent/event-parse.c</span>
<span class="p_chunk">@@ -4841,13 +4841,12 @@</span> <span class="p_context"> static void pretty_print(struct trace_seq *s, void *data, int size, struct event</span>
 				    sizeof(long) != 8) {
 					char *p;
 
<span class="p_del">-					ls = 2;</span>
 					/* make %l into %ll */
<span class="p_del">-					p = strchr(format, &#39;l&#39;);</span>
<span class="p_del">-					if (p)</span>
<span class="p_add">+					if (ls == 1 &amp;&amp; (p = strchr(format, &#39;l&#39;)))</span>
 						memmove(p+1, p, strlen(p)+1);
 					else if (strcmp(format, &quot;%p&quot;) == 0)
 						strcpy(format, &quot;0x%llx&quot;);
<span class="p_add">+					ls = 2;</span>
 				}
 				switch (ls) {
 				case -2:

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



