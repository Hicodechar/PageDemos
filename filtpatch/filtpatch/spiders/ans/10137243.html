
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.14.10 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.14.10</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 29, 2017, 5:11 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171229171114.GB8641@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10137243/mbox/"
   >mbox</a>
|
   <a href="/patch/10137243/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10137243/">/patch/10137243/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	50D3660233 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 29 Dec 2017 17:12:57 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id D5E8D2DB07
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 29 Dec 2017 17:12:56 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id C87262DC34; Fri, 29 Dec 2017 17:12:56 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 6A2932DB07
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 29 Dec 2017 17:12:41 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751571AbdL2RMf (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 29 Dec 2017 12:12:35 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:35582 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751186AbdL2RM2 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 29 Dec 2017 12:12:28 -0500
Received: from localhost (unknown [185.156.173.27])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 4811949B;
	Fri, 29 Dec 2017 17:11:56 +0000 (UTC)
Date: Fri, 29 Dec 2017 18:11:14 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.14.10
Message-ID: &lt;20171229171114.GB8641@kroah.com&gt;
References: &lt;20171229171043.GA8641@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20171229171043.GA8641@kroah.com&gt;
User-Agent: Mutt/1.9.2 (2017-12-15)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Dec. 29, 2017, 5:11 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/x86/x86_64/mm.txt b/Documentation/x86/x86_64/mm.txt</span>
<span class="p_header">index 3448e675b462..51101708a03a 100644</span>
<span class="p_header">--- a/Documentation/x86/x86_64/mm.txt</span>
<span class="p_header">+++ b/Documentation/x86/x86_64/mm.txt</span>
<span class="p_chunk">@@ -1,6 +1,4 @@</span> <span class="p_context"></span>
 
<span class="p_del">-&lt;previous description obsolete, deleted&gt;</span>
<span class="p_del">-</span>
 Virtual memory map with 4 level page tables:
 
 0000000000000000 - 00007fffffffffff (=47 bits) user space, different per mm
<span class="p_chunk">@@ -14,13 +12,15 @@</span> <span class="p_context"> ffffea0000000000 - ffffeaffffffffff (=40 bits) virtual memory map (1TB)</span>
 ... unused hole ...
 ffffec0000000000 - fffffbffffffffff (=44 bits) kasan shadow memory (16TB)
 ... unused hole ...
<span class="p_add">+fffffe8000000000 - fffffeffffffffff (=39 bits) cpu_entry_area mapping</span>
 ffffff0000000000 - ffffff7fffffffff (=39 bits) %esp fixup stacks
 ... unused hole ...
 ffffffef00000000 - fffffffeffffffff (=64 GB) EFI region mapping space
 ... unused hole ...
 ffffffff80000000 - ffffffff9fffffff (=512 MB)  kernel text mapping, from phys 0
<span class="p_del">-ffffffffa0000000 - ffffffffff5fffff (=1526 MB) module mapping space (variable)</span>
<span class="p_del">-ffffffffff600000 - ffffffffffdfffff (=8 MB) vsyscalls</span>
<span class="p_add">+ffffffffa0000000 - [fixmap start]   (~1526 MB) module mapping space (variable)</span>
<span class="p_add">+[fixmap start]   - ffffffffff5fffff kernel-internal fixmap range</span>
<span class="p_add">+ffffffffff600000 - ffffffffff600fff (=4 kB) legacy vsyscall ABI</span>
 ffffffffffe00000 - ffffffffffffffff (=2 MB) unused hole
 
 Virtual memory map with 5 level page tables:
<span class="p_chunk">@@ -36,19 +36,22 @@</span> <span class="p_context"> ffd4000000000000 - ffd5ffffffffffff (=49 bits) virtual memory map (512TB)</span>
 ... unused hole ...
 ffdf000000000000 - fffffc0000000000 (=53 bits) kasan shadow memory (8PB)
 ... unused hole ...
<span class="p_add">+fffffe8000000000 - fffffeffffffffff (=39 bits) cpu_entry_area mapping</span>
 ffffff0000000000 - ffffff7fffffffff (=39 bits) %esp fixup stacks
 ... unused hole ...
 ffffffef00000000 - fffffffeffffffff (=64 GB) EFI region mapping space
 ... unused hole ...
 ffffffff80000000 - ffffffff9fffffff (=512 MB)  kernel text mapping, from phys 0
<span class="p_del">-ffffffffa0000000 - ffffffffff5fffff (=1526 MB) module mapping space</span>
<span class="p_del">-ffffffffff600000 - ffffffffffdfffff (=8 MB) vsyscalls</span>
<span class="p_add">+ffffffffa0000000 - [fixmap start]   (~1526 MB) module mapping space</span>
<span class="p_add">+[fixmap start]   - ffffffffff5fffff kernel-internal fixmap range</span>
<span class="p_add">+ffffffffff600000 - ffffffffff600fff (=4 kB) legacy vsyscall ABI</span>
 ffffffffffe00000 - ffffffffffffffff (=2 MB) unused hole
 
 Architecture defines a 64-bit virtual address. Implementations can support
 less. Currently supported are 48- and 57-bit virtual addresses. Bits 63
<span class="p_del">-through to the most-significant implemented bit are set to either all ones</span>
<span class="p_del">-or all zero. This causes hole between user space and kernel addresses.</span>
<span class="p_add">+through to the most-significant implemented bit are sign extended.</span>
<span class="p_add">+This causes hole between user space and kernel addresses if you interpret them</span>
<span class="p_add">+as unsigned.</span>
 
 The direct mapping covers all memory in the system up to the highest
 memory address (this means in some cases it can also include PCI memory
<span class="p_chunk">@@ -58,9 +61,6 @@</span> <span class="p_context"> vmalloc space is lazily synchronized into the different PML4/PML5 pages of</span>
 the processes using the page fault handler, with init_top_pgt as
 reference.
 
<span class="p_del">-Current X86-64 implementations support up to 46 bits of address space (64 TB),</span>
<span class="p_del">-which is our current limit. This expands into MBZ space in the page tables.</span>
<span class="p_del">-</span>
 We map EFI runtime services in the &#39;efi_pgd&#39; PGD in a 64Gb large virtual
 memory window (this size is arbitrary, it can be raised later if needed).
 The mappings are not part of any other kernel PGD and are only available
<span class="p_chunk">@@ -72,5 +72,3 @@</span> <span class="p_context"> following fixmap section.</span>
 Note that if CONFIG_RANDOMIZE_MEMORY is enabled, the direct mapping of all
 physical memory, vmalloc/ioremap space and virtual memory map are randomized.
 Their order is preserved but their base will be offset early at boot time.
<span class="p_del">-</span>
<span class="p_del">--Andi Kleen, Jul 2004</span>
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index ed2132c6d286..9edfb78836a9 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 # SPDX-License-Identifier: GPL-2.0
 VERSION = 4
 PATCHLEVEL = 14
<span class="p_del">-SUBLEVEL = 9</span>
<span class="p_add">+SUBLEVEL = 10</span>
 EXTRAVERSION =
 NAME = Petit Gorille
 
<span class="p_header">diff --git a/arch/arm64/kvm/hyp/debug-sr.c b/arch/arm64/kvm/hyp/debug-sr.c</span>
<span class="p_header">index f5154ed3da6c..2add22699764 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/hyp/debug-sr.c</span>
<span class="p_header">+++ b/arch/arm64/kvm/hyp/debug-sr.c</span>
<span class="p_chunk">@@ -84,6 +84,9 @@</span> <span class="p_context"> static void __hyp_text __debug_save_spe_nvhe(u64 *pmscr_el1)</span>
 {
 	u64 reg;
 
<span class="p_add">+	/* Clear pmscr in case of early return */</span>
<span class="p_add">+	*pmscr_el1 = 0;</span>
<span class="p_add">+</span>
 	/* SPE present on this CPU? */
 	if (!cpuid_feature_extract_unsigned_field(read_sysreg(id_aa64dfr0_el1),
 						  ID_AA64DFR0_PMSVER_SHIFT))
<span class="p_header">diff --git a/arch/parisc/boot/compressed/misc.c b/arch/parisc/boot/compressed/misc.c</span>
<span class="p_header">index 9345b44b86f0..f57118e1f6b4 100644</span>
<span class="p_header">--- a/arch/parisc/boot/compressed/misc.c</span>
<span class="p_header">+++ b/arch/parisc/boot/compressed/misc.c</span>
<span class="p_chunk">@@ -123,8 +123,8 @@</span> <span class="p_context"> int puts(const char *s)</span>
 	while ((nuline = strchr(s, &#39;\n&#39;)) != NULL) {
 		if (nuline != s)
 			pdc_iodc_print(s, nuline - s);
<span class="p_del">-			pdc_iodc_print(&quot;\r\n&quot;, 2);</span>
<span class="p_del">-			s = nuline + 1;</span>
<span class="p_add">+		pdc_iodc_print(&quot;\r\n&quot;, 2);</span>
<span class="p_add">+		s = nuline + 1;</span>
 	}
 	if (*s != &#39;\0&#39;)
 		pdc_iodc_print(s, strlen(s));
<span class="p_header">diff --git a/arch/parisc/kernel/entry.S b/arch/parisc/kernel/entry.S</span>
<span class="p_header">index a4fd296c958e..f3cecf5117cf 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/entry.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/entry.S</span>
<span class="p_chunk">@@ -878,9 +878,6 @@</span> <span class="p_context"> ENTRY_CFI(syscall_exit_rfi)</span>
 	STREG   %r19,PT_SR7(%r16)
 
 intr_return:
<span class="p_del">-	/* NOTE: Need to enable interrupts incase we schedule. */</span>
<span class="p_del">-	ssm     PSW_SM_I, %r0</span>
<span class="p_del">-</span>
 	/* check for reschedule */
 	mfctl   %cr30,%r1
 	LDREG   TI_FLAGS(%r1),%r19	/* sched.h: TIF_NEED_RESCHED */
<span class="p_chunk">@@ -907,6 +904,11 @@</span> <span class="p_context"> intr_check_sig:</span>
 	LDREG	PT_IASQ1(%r16), %r20
 	cmpib,COND(=),n 0,%r20,intr_restore /* backward */
 
<span class="p_add">+	/* NOTE: We need to enable interrupts if we have to deliver</span>
<span class="p_add">+	 * signals. We used to do this earlier but it caused kernel</span>
<span class="p_add">+	 * stack overflows. */</span>
<span class="p_add">+	ssm     PSW_SM_I, %r0</span>
<span class="p_add">+</span>
 	copy	%r0, %r25			/* long in_syscall = 0 */
 #ifdef CONFIG_64BIT
 	ldo	-16(%r30),%r29			/* Reference param save area */
<span class="p_chunk">@@ -958,6 +960,10 @@</span> <span class="p_context"> intr_do_resched:</span>
 	cmpib,COND(=)	0, %r20, intr_do_preempt
 	nop
 
<span class="p_add">+	/* NOTE: We need to enable interrupts if we schedule.  We used</span>
<span class="p_add">+	 * to do this earlier but it caused kernel stack overflows. */</span>
<span class="p_add">+	ssm     PSW_SM_I, %r0</span>
<span class="p_add">+</span>
 #ifdef CONFIG_64BIT
 	ldo	-16(%r30),%r29		/* Reference param save area */
 #endif
<span class="p_header">diff --git a/arch/parisc/kernel/hpmc.S b/arch/parisc/kernel/hpmc.S</span>
<span class="p_header">index e3a8e5e4d5de..8d072c44f300 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/hpmc.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/hpmc.S</span>
<span class="p_chunk">@@ -305,6 +305,7 @@</span> <span class="p_context"> ENDPROC_CFI(os_hpmc)</span>
 
 
 	__INITRODATA
<span class="p_add">+	.align 4</span>
 	.export os_hpmc_size
 os_hpmc_size:
 	.word .os_hpmc_end-.os_hpmc
<span class="p_header">diff --git a/arch/powerpc/include/asm/mmu_context.h b/arch/powerpc/include/asm/mmu_context.h</span>
<span class="p_header">index 492d8140a395..44fdf4786638 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -114,9 +114,10 @@</span> <span class="p_context"> static inline void enter_lazy_tlb(struct mm_struct *mm,</span>
 #endif
 }
 
<span class="p_del">-static inline void arch_dup_mmap(struct mm_struct *oldmm,</span>
<span class="p_del">-				 struct mm_struct *mm)</span>
<span class="p_add">+static inline int arch_dup_mmap(struct mm_struct *oldmm,</span>
<span class="p_add">+				struct mm_struct *mm)</span>
 {
<span class="p_add">+	return 0;</span>
 }
 
 static inline void arch_exit_mmap(struct mm_struct *mm)
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_xive.c b/arch/powerpc/kvm/book3s_xive.c</span>
<span class="p_header">index bf457843e032..0d750d274c4e 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_xive.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_xive.c</span>
<span class="p_chunk">@@ -725,7 +725,8 @@</span> <span class="p_context"> u64 kvmppc_xive_get_icp(struct kvm_vcpu *vcpu)</span>
 
 	/* Return the per-cpu state for state saving/migration */
 	return (u64)xc-&gt;cppr &lt;&lt; KVM_REG_PPC_ICP_CPPR_SHIFT |
<span class="p_del">-	       (u64)xc-&gt;mfrr &lt;&lt; KVM_REG_PPC_ICP_MFRR_SHIFT;</span>
<span class="p_add">+	       (u64)xc-&gt;mfrr &lt;&lt; KVM_REG_PPC_ICP_MFRR_SHIFT |</span>
<span class="p_add">+	       (u64)0xff &lt;&lt; KVM_REG_PPC_ICP_PPRI_SHIFT;</span>
 }
 
 int kvmppc_xive_set_icp(struct kvm_vcpu *vcpu, u64 icpval)
<span class="p_chunk">@@ -1558,7 +1559,7 @@</span> <span class="p_context"> static int xive_set_source(struct kvmppc_xive *xive, long irq, u64 addr)</span>
 
 	/*
 	 * Restore P and Q. If the interrupt was pending, we
<span class="p_del">-	 * force both P and Q, which will trigger a resend.</span>
<span class="p_add">+	 * force Q and !P, which will trigger a resend.</span>
 	 *
 	 * That means that a guest that had both an interrupt
 	 * pending (queued) and Q set will restore with only
<span class="p_chunk">@@ -1566,7 +1567,7 @@</span> <span class="p_context"> static int xive_set_source(struct kvmppc_xive *xive, long irq, u64 addr)</span>
 	 * is perfectly fine as coalescing interrupts that haven&#39;t
 	 * been presented yet is always allowed.
 	 */
<span class="p_del">-	if (val &amp; KVM_XICS_PRESENTED || val &amp; KVM_XICS_PENDING)</span>
<span class="p_add">+	if (val &amp; KVM_XICS_PRESENTED &amp;&amp; !(val &amp; KVM_XICS_PENDING))</span>
 		state-&gt;old_p = true;
 	if (val &amp; KVM_XICS_QUEUED || val &amp; KVM_XICS_PENDING)
 		state-&gt;old_q = true;
<span class="p_header">diff --git a/arch/powerpc/perf/core-book3s.c b/arch/powerpc/perf/core-book3s.c</span>
<span class="p_header">index 9e3da168d54c..b4209a68b85d 100644</span>
<span class="p_header">--- a/arch/powerpc/perf/core-book3s.c</span>
<span class="p_header">+++ b/arch/powerpc/perf/core-book3s.c</span>
<span class="p_chunk">@@ -410,8 +410,12 @@</span> <span class="p_context"> static __u64 power_pmu_bhrb_to(u64 addr)</span>
 	int ret;
 	__u64 target;
 
<span class="p_del">-	if (is_kernel_addr(addr))</span>
<span class="p_del">-		return branch_target((unsigned int *)addr);</span>
<span class="p_add">+	if (is_kernel_addr(addr)) {</span>
<span class="p_add">+		if (probe_kernel_read(&amp;instr, (void *)addr, sizeof(instr)))</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		return branch_target(&amp;instr);</span>
<span class="p_add">+	}</span>
 
 	/* Userspace: need copy instruction here then translate it */
 	pagefault_disable();
<span class="p_header">diff --git a/arch/um/include/asm/mmu_context.h b/arch/um/include/asm/mmu_context.h</span>
<span class="p_header">index b668e351fd6c..fca34b2177e2 100644</span>
<span class="p_header">--- a/arch/um/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/um/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -15,9 +15,10 @@</span> <span class="p_context"> extern void uml_setup_stubs(struct mm_struct *mm);</span>
 /*
  * Needed since we do not use the asm-generic/mm_hooks.h:
  */
<span class="p_del">-static inline void arch_dup_mmap(struct mm_struct *oldmm, struct mm_struct *mm)</span>
<span class="p_add">+static inline int arch_dup_mmap(struct mm_struct *oldmm, struct mm_struct *mm)</span>
 {
 	uml_setup_stubs(mm);
<span class="p_add">+	return 0;</span>
 }
 extern void arch_exit_mmap(struct mm_struct *mm);
 static inline void arch_unmap(struct mm_struct *mm,
<span class="p_header">diff --git a/arch/unicore32/include/asm/mmu_context.h b/arch/unicore32/include/asm/mmu_context.h</span>
<span class="p_header">index 59b06b48f27d..5c205a9cb5a6 100644</span>
<span class="p_header">--- a/arch/unicore32/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/unicore32/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -81,9 +81,10 @@</span> <span class="p_context"> do { \</span>
 	} \
 } while (0)
 
<span class="p_del">-static inline void arch_dup_mmap(struct mm_struct *oldmm,</span>
<span class="p_del">-				 struct mm_struct *mm)</span>
<span class="p_add">+static inline int arch_dup_mmap(struct mm_struct *oldmm,</span>
<span class="p_add">+				struct mm_struct *mm)</span>
 {
<span class="p_add">+	return 0;</span>
 }
 
 static inline void arch_unmap(struct mm_struct *mm,
<span class="p_header">diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig</span>
<span class="p_header">index 48646160eb83..592c974d4558 100644</span>
<span class="p_header">--- a/arch/x86/Kconfig</span>
<span class="p_header">+++ b/arch/x86/Kconfig</span>
<span class="p_chunk">@@ -925,7 +925,8 @@</span> <span class="p_context"> config MAXSMP</span>
 config NR_CPUS
 	int &quot;Maximum number of CPUs&quot; if SMP &amp;&amp; !MAXSMP
 	range 2 8 if SMP &amp;&amp; X86_32 &amp;&amp; !X86_BIGSMP
<span class="p_del">-	range 2 512 if SMP &amp;&amp; !MAXSMP &amp;&amp; !CPUMASK_OFFSTACK</span>
<span class="p_add">+	range 2 64 if SMP &amp;&amp; X86_32 &amp;&amp; X86_BIGSMP</span>
<span class="p_add">+	range 2 512 if SMP &amp;&amp; !MAXSMP &amp;&amp; !CPUMASK_OFFSTACK &amp;&amp; X86_64</span>
 	range 2 8192 if SMP &amp;&amp; !MAXSMP &amp;&amp; CPUMASK_OFFSTACK &amp;&amp; X86_64
 	default &quot;1&quot; if !SMP
 	default &quot;8192&quot; if MAXSMP
<span class="p_header">diff --git a/arch/x86/entry/entry_32.S b/arch/x86/entry/entry_32.S</span>
<span class="p_header">index bd8b57a5c874..ace8f321a5a1 100644</span>
<span class="p_header">--- a/arch/x86/entry/entry_32.S</span>
<span class="p_header">+++ b/arch/x86/entry/entry_32.S</span>
<span class="p_chunk">@@ -942,9 +942,9 @@</span> <span class="p_context"> ENTRY(debug)</span>
 
 	/* Are we currently on the SYSENTER stack? */
 	movl	PER_CPU_VAR(cpu_entry_area), %ecx
<span class="p_del">-	addl	$CPU_ENTRY_AREA_SYSENTER_stack + SIZEOF_SYSENTER_stack, %ecx</span>
<span class="p_del">-	subl	%eax, %ecx	/* ecx = (end of SYSENTER_stack) - esp */</span>
<span class="p_del">-	cmpl	$SIZEOF_SYSENTER_stack, %ecx</span>
<span class="p_add">+	addl	$CPU_ENTRY_AREA_entry_stack + SIZEOF_entry_stack, %ecx</span>
<span class="p_add">+	subl	%eax, %ecx	/* ecx = (end of entry_stack) - esp */</span>
<span class="p_add">+	cmpl	$SIZEOF_entry_stack, %ecx</span>
 	jb	.Ldebug_from_sysenter_stack
 
 	TRACE_IRQS_OFF
<span class="p_chunk">@@ -986,9 +986,9 @@</span> <span class="p_context"> ENTRY(nmi)</span>
 
 	/* Are we currently on the SYSENTER stack? */
 	movl	PER_CPU_VAR(cpu_entry_area), %ecx
<span class="p_del">-	addl	$CPU_ENTRY_AREA_SYSENTER_stack + SIZEOF_SYSENTER_stack, %ecx</span>
<span class="p_del">-	subl	%eax, %ecx	/* ecx = (end of SYSENTER_stack) - esp */</span>
<span class="p_del">-	cmpl	$SIZEOF_SYSENTER_stack, %ecx</span>
<span class="p_add">+	addl	$CPU_ENTRY_AREA_entry_stack + SIZEOF_entry_stack, %ecx</span>
<span class="p_add">+	subl	%eax, %ecx	/* ecx = (end of entry_stack) - esp */</span>
<span class="p_add">+	cmpl	$SIZEOF_entry_stack, %ecx</span>
 	jb	.Lnmi_from_sysenter_stack
 
 	/* Not on SYSENTER stack. */
<span class="p_header">diff --git a/arch/x86/entry/entry_64.S b/arch/x86/entry/entry_64.S</span>
<span class="p_header">index 6abe3fcaece9..22c891c3b78d 100644</span>
<span class="p_header">--- a/arch/x86/entry/entry_64.S</span>
<span class="p_header">+++ b/arch/x86/entry/entry_64.S</span>
<span class="p_chunk">@@ -154,8 +154,8 @@</span> <span class="p_context"> END(native_usergs_sysret64)</span>
 	_entry_trampoline - CPU_ENTRY_AREA_entry_trampoline(%rip)
 
 /* The top word of the SYSENTER stack is hot and is usable as scratch space. */
<span class="p_del">-#define RSP_SCRATCH	CPU_ENTRY_AREA_SYSENTER_stack + \</span>
<span class="p_del">-			SIZEOF_SYSENTER_stack - 8 + CPU_ENTRY_AREA</span>
<span class="p_add">+#define RSP_SCRATCH	CPU_ENTRY_AREA_entry_stack + \</span>
<span class="p_add">+			SIZEOF_entry_stack - 8 + CPU_ENTRY_AREA</span>
 
 ENTRY(entry_SYSCALL_64_trampoline)
 	UNWIND_HINT_EMPTY
<span class="p_header">diff --git a/arch/x86/entry/vsyscall/vsyscall_64.c b/arch/x86/entry/vsyscall/vsyscall_64.c</span>
<span class="p_header">index f279ba2643dc..1faf40f2dda9 100644</span>
<span class="p_header">--- a/arch/x86/entry/vsyscall/vsyscall_64.c</span>
<span class="p_header">+++ b/arch/x86/entry/vsyscall/vsyscall_64.c</span>
<span class="p_chunk">@@ -37,6 +37,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/unistd.h&gt;
 #include &lt;asm/fixmap.h&gt;
 #include &lt;asm/traps.h&gt;
<span class="p_add">+#include &lt;asm/paravirt.h&gt;</span>
 
 #define CREATE_TRACE_POINTS
 #include &quot;vsyscall_trace.h&quot;
<span class="p_chunk">@@ -138,6 +139,10 @@</span> <span class="p_context"> bool emulate_vsyscall(struct pt_regs *regs, unsigned long address)</span>
 
 	WARN_ON_ONCE(address != regs-&gt;ip);
 
<span class="p_add">+	/* This should be unreachable in NATIVE mode. */</span>
<span class="p_add">+	if (WARN_ON(vsyscall_mode == NATIVE))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
 	if (vsyscall_mode == NONE) {
 		warn_bad_vsyscall(KERN_INFO, regs,
 				  &quot;vsyscall attempted with vsyscall=none&quot;);
<span class="p_chunk">@@ -329,16 +334,47 @@</span> <span class="p_context"> int in_gate_area_no_mm(unsigned long addr)</span>
 	return vsyscall_mode != NONE &amp;&amp; (addr &amp; PAGE_MASK) == VSYSCALL_ADDR;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * The VSYSCALL page is the only user-accessible page in the kernel address</span>
<span class="p_add">+ * range.  Normally, the kernel page tables can have _PAGE_USER clear, but</span>
<span class="p_add">+ * the tables covering VSYSCALL_ADDR need _PAGE_USER set if vsyscalls</span>
<span class="p_add">+ * are enabled.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Some day we may create a &quot;minimal&quot; vsyscall mode in which we emulate</span>
<span class="p_add">+ * vsyscalls but leave the page not present.  If so, we skip calling</span>
<span class="p_add">+ * this.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void __init set_vsyscall_pgtable_user_bits(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pgd_t *pgd;</span>
<span class="p_add">+	p4d_t *p4d;</span>
<span class="p_add">+	pud_t *pud;</span>
<span class="p_add">+	pmd_t *pmd;</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd = pgd_offset_k(VSYSCALL_ADDR);</span>
<span class="p_add">+	set_pgd(pgd, __pgd(pgd_val(*pgd) | _PAGE_USER));</span>
<span class="p_add">+	p4d = p4d_offset(pgd, VSYSCALL_ADDR);</span>
<span class="p_add">+#if CONFIG_PGTABLE_LEVELS &gt;= 5</span>
<span class="p_add">+	p4d-&gt;p4d |= _PAGE_USER;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	pud = pud_offset(p4d, VSYSCALL_ADDR);</span>
<span class="p_add">+	set_pud(pud, __pud(pud_val(*pud) | _PAGE_USER));</span>
<span class="p_add">+	pmd = pmd_offset(pud, VSYSCALL_ADDR);</span>
<span class="p_add">+	set_pmd(pmd, __pmd(pmd_val(*pmd) | _PAGE_USER));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void __init map_vsyscall(void)
 {
 	extern char __vsyscall_page;
 	unsigned long physaddr_vsyscall = __pa_symbol(&amp;__vsyscall_page);
 
<span class="p_del">-	if (vsyscall_mode != NONE)</span>
<span class="p_add">+	if (vsyscall_mode != NONE) {</span>
 		__set_fixmap(VSYSCALL_PAGE, physaddr_vsyscall,
 			     vsyscall_mode == NATIVE
 			     ? PAGE_KERNEL_VSYSCALL
 			     : PAGE_KERNEL_VVAR);
<span class="p_add">+		set_vsyscall_pgtable_user_bits();</span>
<span class="p_add">+	}</span>
 
 	BUILD_BUG_ON((unsigned long)__fix_to_virt(VSYSCALL_PAGE) !=
 		     (unsigned long)VSYSCALL_ADDR);
<span class="p_header">diff --git a/arch/x86/include/asm/cpu_entry_area.h b/arch/x86/include/asm/cpu_entry_area.h</span>
new file mode 100644
<span class="p_header">index 000000000000..2fbc69a0916e</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/include/asm/cpu_entry_area.h</span>
<span class="p_chunk">@@ -0,0 +1,68 @@</span> <span class="p_context"></span>
<span class="p_add">+// SPDX-License-Identifier: GPL-2.0</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef _ASM_X86_CPU_ENTRY_AREA_H</span>
<span class="p_add">+#define _ASM_X86_CPU_ENTRY_AREA_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/percpu-defs.h&gt;</span>
<span class="p_add">+#include &lt;asm/processor.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * cpu_entry_area is a percpu region that contains things needed by the CPU</span>
<span class="p_add">+ * and early entry/exit code.  Real types aren&#39;t used for all fields here</span>
<span class="p_add">+ * to avoid circular header dependencies.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Every field is a virtual alias of some other allocated backing store.</span>
<span class="p_add">+ * There is no direct allocation of a struct cpu_entry_area.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct cpu_entry_area {</span>
<span class="p_add">+	char gdt[PAGE_SIZE];</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The GDT is just below entry_stack and thus serves (on x86_64) as</span>
<span class="p_add">+	 * a a read-only guard page.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	struct entry_stack_page entry_stack_page;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * On x86_64, the TSS is mapped RO.  On x86_32, it&#39;s mapped RW because</span>
<span class="p_add">+	 * we need task switches to work, and task switches write to the TSS.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	struct tss_struct tss;</span>
<span class="p_add">+</span>
<span class="p_add">+	char entry_trampoline[PAGE_SIZE];</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Exception stacks used for IST entries.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * In the future, this should have a separate slot for each stack</span>
<span class="p_add">+	 * with guard pages between them.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	char exception_stacks[(N_EXCEPTION_STACKS - 1) * EXCEPTION_STKSZ + DEBUG_STKSZ];</span>
<span class="p_add">+#endif</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#define CPU_ENTRY_AREA_SIZE	(sizeof(struct cpu_entry_area))</span>
<span class="p_add">+#define CPU_ENTRY_AREA_TOT_SIZE	(CPU_ENTRY_AREA_SIZE * NR_CPUS)</span>
<span class="p_add">+</span>
<span class="p_add">+DECLARE_PER_CPU(struct cpu_entry_area *, cpu_entry_area);</span>
<span class="p_add">+</span>
<span class="p_add">+extern void setup_cpu_entry_areas(void);</span>
<span class="p_add">+extern void cea_set_pte(void *cea_vaddr, phys_addr_t pa, pgprot_t flags);</span>
<span class="p_add">+</span>
<span class="p_add">+#define	CPU_ENTRY_AREA_RO_IDT		CPU_ENTRY_AREA_BASE</span>
<span class="p_add">+#define CPU_ENTRY_AREA_PER_CPU		(CPU_ENTRY_AREA_RO_IDT + PAGE_SIZE)</span>
<span class="p_add">+</span>
<span class="p_add">+#define CPU_ENTRY_AREA_RO_IDT_VADDR	((void *)CPU_ENTRY_AREA_RO_IDT)</span>
<span class="p_add">+</span>
<span class="p_add">+#define CPU_ENTRY_AREA_MAP_SIZE			\</span>
<span class="p_add">+	(CPU_ENTRY_AREA_PER_CPU + CPU_ENTRY_AREA_TOT_SIZE - CPU_ENTRY_AREA_BASE)</span>
<span class="p_add">+</span>
<span class="p_add">+extern struct cpu_entry_area *get_cpu_entry_area(int cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+static inline struct entry_stack *cpu_entry_stack(int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return &amp;get_cpu_entry_area(cpu)-&gt;entry_stack_page.stack;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/arch/x86/include/asm/desc.h b/arch/x86/include/asm/desc.h</span>
<span class="p_header">index 2ace1f90d138..bc359dd2f7f6 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/desc.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/desc.h</span>
<span class="p_chunk">@@ -7,6 +7,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/mmu.h&gt;
 #include &lt;asm/fixmap.h&gt;
 #include &lt;asm/irq_vectors.h&gt;
<span class="p_add">+#include &lt;asm/cpu_entry_area.h&gt;</span>
 
 #include &lt;linux/smp.h&gt;
 #include &lt;linux/percpu.h&gt;
<span class="p_header">diff --git a/arch/x86/include/asm/espfix.h b/arch/x86/include/asm/espfix.h</span>
<span class="p_header">index 0211029076ea..6777480d8a42 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/espfix.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/espfix.h</span>
<span class="p_chunk">@@ -2,7 +2,7 @@</span> <span class="p_context"></span>
 #ifndef _ASM_X86_ESPFIX_H
 #define _ASM_X86_ESPFIX_H
 
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_add">+#ifdef CONFIG_X86_ESPFIX64</span>
 
 #include &lt;asm/percpu.h&gt;
 
<span class="p_chunk">@@ -11,7 +11,8 @@</span> <span class="p_context"> DECLARE_PER_CPU_READ_MOSTLY(unsigned long, espfix_waddr);</span>
 
 extern void init_espfix_bsp(void);
 extern void init_espfix_ap(int cpu);
<span class="p_del">-</span>
<span class="p_del">-#endif /* CONFIG_X86_64 */</span>
<span class="p_add">+#else</span>
<span class="p_add">+static inline void init_espfix_ap(int cpu) { }</span>
<span class="p_add">+#endif</span>
 
 #endif /* _ASM_X86_ESPFIX_H */
<span class="p_header">diff --git a/arch/x86/include/asm/fixmap.h b/arch/x86/include/asm/fixmap.h</span>
<span class="p_header">index 94fc4fa14127..64c4a30e0d39 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/fixmap.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/fixmap.h</span>
<span class="p_chunk">@@ -44,46 +44,6 @@</span> <span class="p_context"> extern unsigned long __FIXADDR_TOP;</span>
 			 PAGE_SIZE)
 #endif
 
<span class="p_del">-/*</span>
<span class="p_del">- * cpu_entry_area is a percpu region in the fixmap that contains things</span>
<span class="p_del">- * needed by the CPU and early entry/exit code.  Real types aren&#39;t used</span>
<span class="p_del">- * for all fields here to avoid circular header dependencies.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Every field is a virtual alias of some other allocated backing store.</span>
<span class="p_del">- * There is no direct allocation of a struct cpu_entry_area.</span>
<span class="p_del">- */</span>
<span class="p_del">-struct cpu_entry_area {</span>
<span class="p_del">-	char gdt[PAGE_SIZE];</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The GDT is just below SYSENTER_stack and thus serves (on x86_64) as</span>
<span class="p_del">-	 * a a read-only guard page.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	struct SYSENTER_stack_page SYSENTER_stack_page;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * On x86_64, the TSS is mapped RO.  On x86_32, it&#39;s mapped RW because</span>
<span class="p_del">-	 * we need task switches to work, and task switches write to the TSS.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	struct tss_struct tss;</span>
<span class="p_del">-</span>
<span class="p_del">-	char entry_trampoline[PAGE_SIZE];</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Exception stacks used for IST entries.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * In the future, this should have a separate slot for each stack</span>
<span class="p_del">-	 * with guard pages between them.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	char exception_stacks[(N_EXCEPTION_STACKS - 1) * EXCEPTION_STKSZ + DEBUG_STKSZ];</span>
<span class="p_del">-#endif</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-#define CPU_ENTRY_AREA_PAGES (sizeof(struct cpu_entry_area) / PAGE_SIZE)</span>
<span class="p_del">-</span>
<span class="p_del">-extern void setup_cpu_entry_areas(void);</span>
<span class="p_del">-</span>
 /*
  * Here we define all the compile-time &#39;special&#39; virtual
  * addresses. The point is to have a constant address at
<span class="p_chunk">@@ -123,7 +83,6 @@</span> <span class="p_context"> enum fixed_addresses {</span>
 	FIX_IO_APIC_BASE_0,
 	FIX_IO_APIC_BASE_END = FIX_IO_APIC_BASE_0 + MAX_IO_APICS - 1,
 #endif
<span class="p_del">-	FIX_RO_IDT,	/* Virtual mapping for read-only IDT */</span>
 #ifdef CONFIG_X86_32
 	FIX_KMAP_BEGIN,	/* reserved pte&#39;s for temporary kernel mappings */
 	FIX_KMAP_END = FIX_KMAP_BEGIN+(KM_TYPE_NR*NR_CPUS)-1,
<span class="p_chunk">@@ -139,9 +98,6 @@</span> <span class="p_context"> enum fixed_addresses {</span>
 #ifdef	CONFIG_X86_INTEL_MID
 	FIX_LNW_VRTC,
 #endif
<span class="p_del">-	/* Fixmap entries to remap the GDTs, one per processor. */</span>
<span class="p_del">-	FIX_CPU_ENTRY_AREA_TOP,</span>
<span class="p_del">-	FIX_CPU_ENTRY_AREA_BOTTOM = FIX_CPU_ENTRY_AREA_TOP + (CPU_ENTRY_AREA_PAGES * NR_CPUS) - 1,</span>
 
 #ifdef CONFIG_ACPI_APEI_GHES
 	/* Used for GHES mapping from assorted contexts */
<span class="p_chunk">@@ -182,7 +138,7 @@</span> <span class="p_context"> enum fixed_addresses {</span>
 extern void reserve_top_address(unsigned long reserve);
 
 #define FIXADDR_SIZE	(__end_of_permanent_fixed_addresses &lt;&lt; PAGE_SHIFT)
<span class="p_del">-#define FIXADDR_START		(FIXADDR_TOP - FIXADDR_SIZE)</span>
<span class="p_add">+#define FIXADDR_START	(FIXADDR_TOP - FIXADDR_SIZE)</span>
 
 extern int fixmaps_set;
 
<span class="p_chunk">@@ -230,30 +186,5 @@</span> <span class="p_context"> void __init *early_memremap_decrypted_wp(resource_size_t phys_addr,</span>
 void __early_set_fixmap(enum fixed_addresses idx,
 			phys_addr_t phys, pgprot_t flags);
 
<span class="p_del">-static inline unsigned int __get_cpu_entry_area_page_index(int cpu, int page)</span>
<span class="p_del">-{</span>
<span class="p_del">-	BUILD_BUG_ON(sizeof(struct cpu_entry_area) % PAGE_SIZE != 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	return FIX_CPU_ENTRY_AREA_BOTTOM - cpu*CPU_ENTRY_AREA_PAGES - page;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#define __get_cpu_entry_area_offset_index(cpu, offset) ({		\</span>
<span class="p_del">-	BUILD_BUG_ON(offset % PAGE_SIZE != 0);				\</span>
<span class="p_del">-	__get_cpu_entry_area_page_index(cpu, offset / PAGE_SIZE);	\</span>
<span class="p_del">-	})</span>
<span class="p_del">-</span>
<span class="p_del">-#define get_cpu_entry_area_index(cpu, field)				\</span>
<span class="p_del">-	__get_cpu_entry_area_offset_index((cpu), offsetof(struct cpu_entry_area, field))</span>
<span class="p_del">-</span>
<span class="p_del">-static inline struct cpu_entry_area *get_cpu_entry_area(int cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (struct cpu_entry_area *)__fix_to_virt(__get_cpu_entry_area_page_index(cpu, 0));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline struct SYSENTER_stack *cpu_SYSENTER_stack(int cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return &amp;get_cpu_entry_area(cpu)-&gt;SYSENTER_stack_page.stack;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 #endif /* !__ASSEMBLY__ */
 #endif /* _ASM_X86_FIXMAP_H */
<span class="p_header">diff --git a/arch/x86/include/asm/inat.h b/arch/x86/include/asm/inat.h</span>
<span class="p_header">index 02aff0867211..1c78580e58be 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/inat.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/inat.h</span>
<span class="p_chunk">@@ -97,6 +97,16 @@</span> <span class="p_context"></span>
 #define INAT_MAKE_GROUP(grp)	((grp &lt;&lt; INAT_GRP_OFFS) | INAT_MODRM)
 #define INAT_MAKE_IMM(imm)	(imm &lt;&lt; INAT_IMM_OFFS)
 
<span class="p_add">+/* Identifiers for segment registers */</span>
<span class="p_add">+#define INAT_SEG_REG_IGNORE	0</span>
<span class="p_add">+#define INAT_SEG_REG_DEFAULT	1</span>
<span class="p_add">+#define INAT_SEG_REG_CS		2</span>
<span class="p_add">+#define INAT_SEG_REG_SS		3</span>
<span class="p_add">+#define INAT_SEG_REG_DS		4</span>
<span class="p_add">+#define INAT_SEG_REG_ES		5</span>
<span class="p_add">+#define INAT_SEG_REG_FS		6</span>
<span class="p_add">+#define INAT_SEG_REG_GS		7</span>
<span class="p_add">+</span>
 /* Attribute search APIs */
 extern insn_attr_t inat_get_opcode_attribute(insn_byte_t opcode);
 extern int inat_get_last_prefix_id(insn_byte_t last_pfx);
<span class="p_header">diff --git a/arch/x86/include/asm/invpcid.h b/arch/x86/include/asm/invpcid.h</span>
new file mode 100644
<span class="p_header">index 000000000000..989cfa86de85</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/include/asm/invpcid.h</span>
<span class="p_chunk">@@ -0,0 +1,53 @@</span> <span class="p_context"></span>
<span class="p_add">+/* SPDX-License-Identifier: GPL-2.0 */</span>
<span class="p_add">+#ifndef _ASM_X86_INVPCID</span>
<span class="p_add">+#define _ASM_X86_INVPCID</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void __invpcid(unsigned long pcid, unsigned long addr,</span>
<span class="p_add">+			     unsigned long type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct { u64 d[2]; } desc = { { pcid, addr } };</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The memory clobber is because the whole point is to invalidate</span>
<span class="p_add">+	 * stale TLB entries and, especially if we&#39;re flushing global</span>
<span class="p_add">+	 * mappings, we don&#39;t want the compiler to reorder any subsequent</span>
<span class="p_add">+	 * memory accesses before the TLB flush.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * The hex opcode is invpcid (%ecx), %eax in 32-bit mode and</span>
<span class="p_add">+	 * invpcid (%rcx), %rax in long mode.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	asm volatile (&quot;.byte 0x66, 0x0f, 0x38, 0x82, 0x01&quot;</span>
<span class="p_add">+		      : : &quot;m&quot; (desc), &quot;a&quot; (type), &quot;c&quot; (&amp;desc) : &quot;memory&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define INVPCID_TYPE_INDIV_ADDR		0</span>
<span class="p_add">+#define INVPCID_TYPE_SINGLE_CTXT	1</span>
<span class="p_add">+#define INVPCID_TYPE_ALL_INCL_GLOBAL	2</span>
<span class="p_add">+#define INVPCID_TYPE_ALL_NON_GLOBAL	3</span>
<span class="p_add">+</span>
<span class="p_add">+/* Flush all mappings for a given pcid and addr, not including globals. */</span>
<span class="p_add">+static inline void invpcid_flush_one(unsigned long pcid,</span>
<span class="p_add">+				     unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__invpcid(pcid, addr, INVPCID_TYPE_INDIV_ADDR);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Flush all mappings for a given PCID, not including globals. */</span>
<span class="p_add">+static inline void invpcid_flush_single_context(unsigned long pcid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__invpcid(pcid, 0, INVPCID_TYPE_SINGLE_CTXT);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Flush all mappings, including globals, for all PCIDs. */</span>
<span class="p_add">+static inline void invpcid_flush_all(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__invpcid(0, 0, INVPCID_TYPE_ALL_INCL_GLOBAL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Flush all mappings for all PCIDs except globals. */</span>
<span class="p_add">+static inline void invpcid_flush_all_nonglobals(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__invpcid(0, 0, INVPCID_TYPE_ALL_NON_GLOBAL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _ASM_X86_INVPCID */</span>
<span class="p_header">diff --git a/arch/x86/include/asm/mmu.h b/arch/x86/include/asm/mmu.h</span>
<span class="p_header">index 9ea26f167497..5ff3e8af2c20 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mmu.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mmu.h</span>
<span class="p_chunk">@@ -3,6 +3,7 @@</span> <span class="p_context"></span>
 #define _ASM_X86_MMU_H
 
 #include &lt;linux/spinlock.h&gt;
<span class="p_add">+#include &lt;linux/rwsem.h&gt;</span>
 #include &lt;linux/mutex.h&gt;
 #include &lt;linux/atomic.h&gt;
 
<span class="p_chunk">@@ -27,7 +28,8 @@</span> <span class="p_context"> typedef struct {</span>
 	atomic64_t tlb_gen;
 
 #ifdef CONFIG_MODIFY_LDT_SYSCALL
<span class="p_del">-	struct ldt_struct *ldt;</span>
<span class="p_add">+	struct rw_semaphore	ldt_usr_sem;</span>
<span class="p_add">+	struct ldt_struct	*ldt;</span>
 #endif
 
 #ifdef CONFIG_X86_64
<span class="p_header">diff --git a/arch/x86/include/asm/mmu_context.h b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">index 6d16d15d09a0..5ede7cae1d67 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -57,11 +57,17 @@</span> <span class="p_context"> struct ldt_struct {</span>
 /*
  * Used for LDT copy/destruction.
  */
<span class="p_del">-int init_new_context_ldt(struct task_struct *tsk, struct mm_struct *mm);</span>
<span class="p_add">+static inline void init_new_context_ldt(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mm-&gt;context.ldt = NULL;</span>
<span class="p_add">+	init_rwsem(&amp;mm-&gt;context.ldt_usr_sem);</span>
<span class="p_add">+}</span>
<span class="p_add">+int ldt_dup_context(struct mm_struct *oldmm, struct mm_struct *mm);</span>
 void destroy_context_ldt(struct mm_struct *mm);
 #else	/* CONFIG_MODIFY_LDT_SYSCALL */
<span class="p_del">-static inline int init_new_context_ldt(struct task_struct *tsk,</span>
<span class="p_del">-				       struct mm_struct *mm)</span>
<span class="p_add">+static inline void init_new_context_ldt(struct mm_struct *mm) { }</span>
<span class="p_add">+static inline int ldt_dup_context(struct mm_struct *oldmm,</span>
<span class="p_add">+				  struct mm_struct *mm)</span>
 {
 	return 0;
 }
<span class="p_chunk">@@ -132,18 +138,21 @@</span> <span class="p_context"> void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk);</span>
 static inline int init_new_context(struct task_struct *tsk,
 				   struct mm_struct *mm)
 {
<span class="p_add">+	mutex_init(&amp;mm-&gt;context.lock);</span>
<span class="p_add">+</span>
 	mm-&gt;context.ctx_id = atomic64_inc_return(&amp;last_mm_ctx_id);
 	atomic64_set(&amp;mm-&gt;context.tlb_gen, 0);
 
<span class="p_del">-	#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS</span>
<span class="p_add">+#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS</span>
 	if (cpu_feature_enabled(X86_FEATURE_OSPKE)) {
 		/* pkey 0 is the default and always allocated */
 		mm-&gt;context.pkey_allocation_map = 0x1;
 		/* -1 means unallocated or invalid */
 		mm-&gt;context.execute_only_pkey = -1;
 	}
<span class="p_del">-	#endif</span>
<span class="p_del">-	return init_new_context_ldt(tsk, mm);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	init_new_context_ldt(mm);</span>
<span class="p_add">+	return 0;</span>
 }
 static inline void destroy_context(struct mm_struct *mm)
 {
<span class="p_chunk">@@ -176,10 +185,10 @@</span> <span class="p_context"> do {						\</span>
 } while (0)
 #endif
 
<span class="p_del">-static inline void arch_dup_mmap(struct mm_struct *oldmm,</span>
<span class="p_del">-				 struct mm_struct *mm)</span>
<span class="p_add">+static inline int arch_dup_mmap(struct mm_struct *oldmm, struct mm_struct *mm)</span>
 {
 	paravirt_arch_dup_mmap(oldmm, mm);
<span class="p_add">+	return ldt_dup_context(oldmm, mm);</span>
 }
 
 static inline void arch_exit_mmap(struct mm_struct *mm)
<span class="p_chunk">@@ -281,33 +290,6 @@</span> <span class="p_context"> static inline bool arch_vma_access_permitted(struct vm_area_struct *vma,</span>
 	return __pkru_allows_pkey(vma_pkey(vma), write);
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * If PCID is on, ASID-aware code paths put the ASID+1 into the PCID</span>
<span class="p_del">- * bits.  This serves two purposes.  It prevents a nasty situation in</span>
<span class="p_del">- * which PCID-unaware code saves CR3, loads some other value (with PCID</span>
<span class="p_del">- * == 0), and then restores CR3, thus corrupting the TLB for ASID 0 if</span>
<span class="p_del">- * the saved ASID was nonzero.  It also means that any bugs involving</span>
<span class="p_del">- * loading a PCID-enabled CR3 with CR4.PCIDE off will trigger</span>
<span class="p_del">- * deterministically.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-static inline unsigned long build_cr3(struct mm_struct *mm, u16 asid)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (static_cpu_has(X86_FEATURE_PCID)) {</span>
<span class="p_del">-		VM_WARN_ON_ONCE(asid &gt; 4094);</span>
<span class="p_del">-		return __sme_pa(mm-&gt;pgd) | (asid + 1);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		VM_WARN_ON_ONCE(asid != 0);</span>
<span class="p_del">-		return __sme_pa(mm-&gt;pgd);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline unsigned long build_cr3_noflush(struct mm_struct *mm, u16 asid)</span>
<span class="p_del">-{</span>
<span class="p_del">-	VM_WARN_ON_ONCE(asid &gt; 4094);</span>
<span class="p_del">-	return __sme_pa(mm-&gt;pgd) | (asid + 1) | CR3_NOFLUSH;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * This can be used from process context to figure out what the value of
  * CR3 is without needing to do a (slow) __read_cr3().
<span class="p_chunk">@@ -317,7 +299,7 @@</span> <span class="p_context"> static inline unsigned long build_cr3_noflush(struct mm_struct *mm, u16 asid)</span>
  */
 static inline unsigned long __get_current_cr3_fast(void)
 {
<span class="p_del">-	unsigned long cr3 = build_cr3(this_cpu_read(cpu_tlbstate.loaded_mm),</span>
<span class="p_add">+	unsigned long cr3 = build_cr3(this_cpu_read(cpu_tlbstate.loaded_mm)-&gt;pgd,</span>
 		this_cpu_read(cpu_tlbstate.loaded_mm_asid));
 
 	/* For now, be very restrictive about when this can be called. */
<span class="p_header">diff --git a/arch/x86/include/asm/pgtable_32_types.h b/arch/x86/include/asm/pgtable_32_types.h</span>
<span class="p_header">index f2ca9b28fd68..ce245b0cdfca 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/pgtable_32_types.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/pgtable_32_types.h</span>
<span class="p_chunk">@@ -38,13 +38,22 @@</span> <span class="p_context"> extern bool __vmalloc_start_set; /* set once high_memory is set */</span>
 #define LAST_PKMAP 1024
 #endif
 
<span class="p_del">-#define PKMAP_BASE ((FIXADDR_START - PAGE_SIZE * (LAST_PKMAP + 1))	\</span>
<span class="p_del">-		    &amp; PMD_MASK)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Define this here and validate with BUILD_BUG_ON() in pgtable_32.c</span>
<span class="p_add">+ * to avoid include recursion hell</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define CPU_ENTRY_AREA_PAGES	(NR_CPUS * 40)</span>
<span class="p_add">+</span>
<span class="p_add">+#define CPU_ENTRY_AREA_BASE				\</span>
<span class="p_add">+	((FIXADDR_START - PAGE_SIZE * (CPU_ENTRY_AREA_PAGES + 1)) &amp; PMD_MASK)</span>
<span class="p_add">+</span>
<span class="p_add">+#define PKMAP_BASE		\</span>
<span class="p_add">+	((CPU_ENTRY_AREA_BASE - PAGE_SIZE) &amp; PMD_MASK)</span>
 
 #ifdef CONFIG_HIGHMEM
 # define VMALLOC_END	(PKMAP_BASE - 2 * PAGE_SIZE)
 #else
<span class="p_del">-# define VMALLOC_END	(FIXADDR_START - 2 * PAGE_SIZE)</span>
<span class="p_add">+# define VMALLOC_END	(CPU_ENTRY_AREA_BASE - 2 * PAGE_SIZE)</span>
 #endif
 
 #define MODULES_VADDR	VMALLOC_START
<span class="p_header">diff --git a/arch/x86/include/asm/pgtable_64_types.h b/arch/x86/include/asm/pgtable_64_types.h</span>
<span class="p_header">index 6d5f45dcd4a1..3d27831bc58d 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/pgtable_64_types.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/pgtable_64_types.h</span>
<span class="p_chunk">@@ -76,32 +76,41 @@</span> <span class="p_context"> typedef struct { pteval_t pte; } pte_t;</span>
 #define PGDIR_MASK	(~(PGDIR_SIZE - 1))
 
 /* See Documentation/x86/x86_64/mm.txt for a description of the memory map. */
<span class="p_del">-#define MAXMEM		_AC(__AC(1, UL) &lt;&lt; MAX_PHYSMEM_BITS, UL)</span>
<span class="p_add">+#define MAXMEM			_AC(__AC(1, UL) &lt;&lt; MAX_PHYSMEM_BITS, UL)</span>
<span class="p_add">+</span>
 #ifdef CONFIG_X86_5LEVEL
<span class="p_del">-#define VMALLOC_SIZE_TB _AC(16384, UL)</span>
<span class="p_del">-#define __VMALLOC_BASE	_AC(0xff92000000000000, UL)</span>
<span class="p_del">-#define __VMEMMAP_BASE	_AC(0xffd4000000000000, UL)</span>
<span class="p_add">+# define VMALLOC_SIZE_TB	_AC(16384, UL)</span>
<span class="p_add">+# define __VMALLOC_BASE		_AC(0xff92000000000000, UL)</span>
<span class="p_add">+# define __VMEMMAP_BASE		_AC(0xffd4000000000000, UL)</span>
 #else
<span class="p_del">-#define VMALLOC_SIZE_TB	_AC(32, UL)</span>
<span class="p_del">-#define __VMALLOC_BASE	_AC(0xffffc90000000000, UL)</span>
<span class="p_del">-#define __VMEMMAP_BASE	_AC(0xffffea0000000000, UL)</span>
<span class="p_add">+# define VMALLOC_SIZE_TB	_AC(32, UL)</span>
<span class="p_add">+# define __VMALLOC_BASE		_AC(0xffffc90000000000, UL)</span>
<span class="p_add">+# define __VMEMMAP_BASE		_AC(0xffffea0000000000, UL)</span>
 #endif
<span class="p_add">+</span>
 #ifdef CONFIG_RANDOMIZE_MEMORY
<span class="p_del">-#define VMALLOC_START	vmalloc_base</span>
<span class="p_del">-#define VMEMMAP_START	vmemmap_base</span>
<span class="p_add">+# define VMALLOC_START		vmalloc_base</span>
<span class="p_add">+# define VMEMMAP_START		vmemmap_base</span>
 #else
<span class="p_del">-#define VMALLOC_START	__VMALLOC_BASE</span>
<span class="p_del">-#define VMEMMAP_START	__VMEMMAP_BASE</span>
<span class="p_add">+# define VMALLOC_START		__VMALLOC_BASE</span>
<span class="p_add">+# define VMEMMAP_START		__VMEMMAP_BASE</span>
 #endif /* CONFIG_RANDOMIZE_MEMORY */
<span class="p_del">-#define VMALLOC_END	(VMALLOC_START + _AC((VMALLOC_SIZE_TB &lt;&lt; 40) - 1, UL))</span>
<span class="p_del">-#define MODULES_VADDR    (__START_KERNEL_map + KERNEL_IMAGE_SIZE)</span>
<span class="p_add">+</span>
<span class="p_add">+#define VMALLOC_END		(VMALLOC_START + _AC((VMALLOC_SIZE_TB &lt;&lt; 40) - 1, UL))</span>
<span class="p_add">+</span>
<span class="p_add">+#define MODULES_VADDR		(__START_KERNEL_map + KERNEL_IMAGE_SIZE)</span>
 /* The module sections ends with the start of the fixmap */
<span class="p_del">-#define MODULES_END   __fix_to_virt(__end_of_fixed_addresses + 1)</span>
<span class="p_del">-#define MODULES_LEN   (MODULES_END - MODULES_VADDR)</span>
<span class="p_del">-#define ESPFIX_PGD_ENTRY _AC(-2, UL)</span>
<span class="p_del">-#define ESPFIX_BASE_ADDR (ESPFIX_PGD_ENTRY &lt;&lt; P4D_SHIFT)</span>
<span class="p_del">-#define EFI_VA_START	 ( -4 * (_AC(1, UL) &lt;&lt; 30))</span>
<span class="p_del">-#define EFI_VA_END	 (-68 * (_AC(1, UL) &lt;&lt; 30))</span>
<span class="p_add">+#define MODULES_END		__fix_to_virt(__end_of_fixed_addresses + 1)</span>
<span class="p_add">+#define MODULES_LEN		(MODULES_END - MODULES_VADDR)</span>
<span class="p_add">+</span>
<span class="p_add">+#define ESPFIX_PGD_ENTRY	_AC(-2, UL)</span>
<span class="p_add">+#define ESPFIX_BASE_ADDR	(ESPFIX_PGD_ENTRY &lt;&lt; P4D_SHIFT)</span>
<span class="p_add">+</span>
<span class="p_add">+#define CPU_ENTRY_AREA_PGD	_AC(-3, UL)</span>
<span class="p_add">+#define CPU_ENTRY_AREA_BASE	(CPU_ENTRY_AREA_PGD &lt;&lt; P4D_SHIFT)</span>
<span class="p_add">+</span>
<span class="p_add">+#define EFI_VA_START		( -4 * (_AC(1, UL) &lt;&lt; 30))</span>
<span class="p_add">+#define EFI_VA_END		(-68 * (_AC(1, UL) &lt;&lt; 30))</span>
 
 #define EARLY_DYNAMIC_PAGE_TABLES	64
 
<span class="p_header">diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h</span>
<span class="p_header">index da943411d3d8..9e482d8b0b97 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/processor.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/processor.h</span>
<span class="p_chunk">@@ -336,12 +336,12 @@</span> <span class="p_context"> struct x86_hw_tss {</span>
 #define IO_BITMAP_OFFSET		(offsetof(struct tss_struct, io_bitmap) - offsetof(struct tss_struct, x86_tss))
 #define INVALID_IO_BITMAP_OFFSET	0x8000
 
<span class="p_del">-struct SYSENTER_stack {</span>
<span class="p_add">+struct entry_stack {</span>
 	unsigned long		words[64];
 };
 
<span class="p_del">-struct SYSENTER_stack_page {</span>
<span class="p_del">-	struct SYSENTER_stack stack;</span>
<span class="p_add">+struct entry_stack_page {</span>
<span class="p_add">+	struct entry_stack stack;</span>
 } __aligned(PAGE_SIZE);
 
 struct tss_struct {
<span class="p_header">diff --git a/arch/x86/include/asm/stacktrace.h b/arch/x86/include/asm/stacktrace.h</span>
<span class="p_header">index f8062bfd43a0..f73706878772 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/stacktrace.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/stacktrace.h</span>
<span class="p_chunk">@@ -16,7 +16,7 @@</span> <span class="p_context"> enum stack_type {</span>
 	STACK_TYPE_TASK,
 	STACK_TYPE_IRQ,
 	STACK_TYPE_SOFTIRQ,
<span class="p_del">-	STACK_TYPE_SYSENTER,</span>
<span class="p_add">+	STACK_TYPE_ENTRY,</span>
 	STACK_TYPE_EXCEPTION,
 	STACK_TYPE_EXCEPTION_LAST = STACK_TYPE_EXCEPTION + N_EXCEPTION_STACKS-1,
 };
<span class="p_chunk">@@ -29,7 +29,7 @@</span> <span class="p_context"> struct stack_info {</span>
 bool in_task_stack(unsigned long *stack, struct task_struct *task,
 		   struct stack_info *info);
 
<span class="p_del">-bool in_sysenter_stack(unsigned long *stack, struct stack_info *info);</span>
<span class="p_add">+bool in_entry_stack(unsigned long *stack, struct stack_info *info);</span>
 
 int get_stack_info(unsigned long *stack, struct task_struct *task,
 		   struct stack_info *info, unsigned long *visit_mask);
<span class="p_header">diff --git a/arch/x86/include/asm/tlbflush.h b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">index 509046cfa5ce..171b429f43a2 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -9,70 +9,66 @@</span> <span class="p_context"></span>
 #include &lt;asm/cpufeature.h&gt;
 #include &lt;asm/special_insns.h&gt;
 #include &lt;asm/smp.h&gt;
<span class="p_add">+#include &lt;asm/invpcid.h&gt;</span>
 
<span class="p_del">-static inline void __invpcid(unsigned long pcid, unsigned long addr,</span>
<span class="p_del">-			     unsigned long type)</span>
<span class="p_add">+static inline u64 inc_mm_tlb_gen(struct mm_struct *mm)</span>
 {
<span class="p_del">-	struct { u64 d[2]; } desc = { { pcid, addr } };</span>
<span class="p_del">-</span>
 	/*
<span class="p_del">-	 * The memory clobber is because the whole point is to invalidate</span>
<span class="p_del">-	 * stale TLB entries and, especially if we&#39;re flushing global</span>
<span class="p_del">-	 * mappings, we don&#39;t want the compiler to reorder any subsequent</span>
<span class="p_del">-	 * memory accesses before the TLB flush.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * The hex opcode is invpcid (%ecx), %eax in 32-bit mode and</span>
<span class="p_del">-	 * invpcid (%rcx), %rax in long mode.</span>
<span class="p_add">+	 * Bump the generation count.  This also serves as a full barrier</span>
<span class="p_add">+	 * that synchronizes with switch_mm(): callers are required to order</span>
<span class="p_add">+	 * their read of mm_cpumask after their writes to the paging</span>
<span class="p_add">+	 * structures.</span>
 	 */
<span class="p_del">-	asm volatile (&quot;.byte 0x66, 0x0f, 0x38, 0x82, 0x01&quot;</span>
<span class="p_del">-		      : : &quot;m&quot; (desc), &quot;a&quot; (type), &quot;c&quot; (&amp;desc) : &quot;memory&quot;);</span>
<span class="p_add">+	return atomic64_inc_return(&amp;mm-&gt;context.tlb_gen);</span>
 }
 
<span class="p_del">-#define INVPCID_TYPE_INDIV_ADDR		0</span>
<span class="p_del">-#define INVPCID_TYPE_SINGLE_CTXT	1</span>
<span class="p_del">-#define INVPCID_TYPE_ALL_INCL_GLOBAL	2</span>
<span class="p_del">-#define INVPCID_TYPE_ALL_NON_GLOBAL	3</span>
<span class="p_del">-</span>
<span class="p_del">-/* Flush all mappings for a given pcid and addr, not including globals. */</span>
<span class="p_del">-static inline void invpcid_flush_one(unsigned long pcid,</span>
<span class="p_del">-				     unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	__invpcid(pcid, addr, INVPCID_TYPE_INDIV_ADDR);</span>
<span class="p_del">-}</span>
<span class="p_add">+/* There are 12 bits of space for ASIDS in CR3 */</span>
<span class="p_add">+#define CR3_HW_ASID_BITS		12</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * When enabled, PAGE_TABLE_ISOLATION consumes a single bit for</span>
<span class="p_add">+ * user/kernel switches</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define PTI_CONSUMED_ASID_BITS		0</span>
 
<span class="p_del">-/* Flush all mappings for a given PCID, not including globals. */</span>
<span class="p_del">-static inline void invpcid_flush_single_context(unsigned long pcid)</span>
<span class="p_del">-{</span>
<span class="p_del">-	__invpcid(pcid, 0, INVPCID_TYPE_SINGLE_CTXT);</span>
<span class="p_del">-}</span>
<span class="p_add">+#define CR3_AVAIL_ASID_BITS (CR3_HW_ASID_BITS - PTI_CONSUMED_ASID_BITS)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * ASIDs are zero-based: 0-&gt;MAX_AVAIL_ASID are valid.  -1 below to account</span>
<span class="p_add">+ * for them being zero-based.  Another -1 is because ASID 0 is reserved for</span>
<span class="p_add">+ * use by non-PCID-aware users.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define MAX_ASID_AVAILABLE ((1 &lt;&lt; CR3_AVAIL_ASID_BITS) - 2)</span>
 
<span class="p_del">-/* Flush all mappings, including globals, for all PCIDs. */</span>
<span class="p_del">-static inline void invpcid_flush_all(void)</span>
<span class="p_add">+static inline u16 kern_pcid(u16 asid)</span>
 {
<span class="p_del">-	__invpcid(0, 0, INVPCID_TYPE_ALL_INCL_GLOBAL);</span>
<span class="p_add">+	VM_WARN_ON_ONCE(asid &gt; MAX_ASID_AVAILABLE);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If PCID is on, ASID-aware code paths put the ASID+1 into the</span>
<span class="p_add">+	 * PCID bits.  This serves two purposes.  It prevents a nasty</span>
<span class="p_add">+	 * situation in which PCID-unaware code saves CR3, loads some other</span>
<span class="p_add">+	 * value (with PCID == 0), and then restores CR3, thus corrupting</span>
<span class="p_add">+	 * the TLB for ASID 0 if the saved ASID was nonzero.  It also means</span>
<span class="p_add">+	 * that any bugs involving loading a PCID-enabled CR3 with</span>
<span class="p_add">+	 * CR4.PCIDE off will trigger deterministically.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return asid + 1;</span>
 }
 
<span class="p_del">-/* Flush all mappings for all PCIDs except globals. */</span>
<span class="p_del">-static inline void invpcid_flush_all_nonglobals(void)</span>
<span class="p_add">+struct pgd_t;</span>
<span class="p_add">+static inline unsigned long build_cr3(pgd_t *pgd, u16 asid)</span>
 {
<span class="p_del">-	__invpcid(0, 0, INVPCID_TYPE_ALL_NON_GLOBAL);</span>
<span class="p_add">+	if (static_cpu_has(X86_FEATURE_PCID)) {</span>
<span class="p_add">+		return __sme_pa(pgd) | kern_pcid(asid);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		VM_WARN_ON_ONCE(asid != 0);</span>
<span class="p_add">+		return __sme_pa(pgd);</span>
<span class="p_add">+	}</span>
 }
 
<span class="p_del">-static inline u64 inc_mm_tlb_gen(struct mm_struct *mm)</span>
<span class="p_add">+static inline unsigned long build_cr3_noflush(pgd_t *pgd, u16 asid)</span>
 {
<span class="p_del">-	u64 new_tlb_gen;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Bump the generation count.  This also serves as a full barrier</span>
<span class="p_del">-	 * that synchronizes with switch_mm(): callers are required to order</span>
<span class="p_del">-	 * their read of mm_cpumask after their writes to the paging</span>
<span class="p_del">-	 * structures.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	smp_mb__before_atomic();</span>
<span class="p_del">-	new_tlb_gen = atomic64_inc_return(&amp;mm-&gt;context.tlb_gen);</span>
<span class="p_del">-	smp_mb__after_atomic();</span>
<span class="p_del">-</span>
<span class="p_del">-	return new_tlb_gen;</span>
<span class="p_add">+	VM_WARN_ON_ONCE(asid &gt; MAX_ASID_AVAILABLE);</span>
<span class="p_add">+	VM_WARN_ON_ONCE(!this_cpu_has(X86_FEATURE_PCID));</span>
<span class="p_add">+	return __sme_pa(pgd) | kern_pcid(asid) | CR3_NOFLUSH;</span>
 }
 
 #ifdef CONFIG_PARAVIRT
<span class="p_chunk">@@ -234,6 +230,9 @@</span> <span class="p_context"> static inline void cr4_set_bits_and_update_boot(unsigned long mask)</span>
 
 extern void initialize_tlbstate_and_flush(void);
 
<span class="p_add">+/*</span>
<span class="p_add">+ * flush the entire current user mapping</span>
<span class="p_add">+ */</span>
 static inline void __native_flush_tlb(void)
 {
 	/*
<span class="p_chunk">@@ -246,20 +245,12 @@</span> <span class="p_context"> static inline void __native_flush_tlb(void)</span>
 	preempt_enable();
 }
 
<span class="p_del">-static inline void __native_flush_tlb_global_irq_disabled(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long cr4;</span>
<span class="p_del">-</span>
<span class="p_del">-	cr4 = this_cpu_read(cpu_tlbstate.cr4);</span>
<span class="p_del">-	/* clear PGE */</span>
<span class="p_del">-	native_write_cr4(cr4 &amp; ~X86_CR4_PGE);</span>
<span class="p_del">-	/* write old PGE again and flush TLBs */</span>
<span class="p_del">-	native_write_cr4(cr4);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * flush everything</span>
<span class="p_add">+ */</span>
 static inline void __native_flush_tlb_global(void)
 {
<span class="p_del">-	unsigned long flags;</span>
<span class="p_add">+	unsigned long cr4, flags;</span>
 
 	if (static_cpu_has(X86_FEATURE_INVPCID)) {
 		/*
<span class="p_chunk">@@ -277,22 +268,36 @@</span> <span class="p_context"> static inline void __native_flush_tlb_global(void)</span>
 	 */
 	raw_local_irq_save(flags);
 
<span class="p_del">-	__native_flush_tlb_global_irq_disabled();</span>
<span class="p_add">+	cr4 = this_cpu_read(cpu_tlbstate.cr4);</span>
<span class="p_add">+	/* toggle PGE */</span>
<span class="p_add">+	native_write_cr4(cr4 ^ X86_CR4_PGE);</span>
<span class="p_add">+	/* write old PGE again and flush TLBs */</span>
<span class="p_add">+	native_write_cr4(cr4);</span>
 
 	raw_local_irq_restore(flags);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * flush one page in the user mapping</span>
<span class="p_add">+ */</span>
 static inline void __native_flush_tlb_single(unsigned long addr)
 {
 	asm volatile(&quot;invlpg (%0)&quot; ::&quot;r&quot; (addr) : &quot;memory&quot;);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * flush everything</span>
<span class="p_add">+ */</span>
 static inline void __flush_tlb_all(void)
 {
<span class="p_del">-	if (boot_cpu_has(X86_FEATURE_PGE))</span>
<span class="p_add">+	if (boot_cpu_has(X86_FEATURE_PGE)) {</span>
 		__flush_tlb_global();
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * !PGE -&gt; !PCID (setup_pcid()), thus every flush is total.</span>
<span class="p_add">+		 */</span>
 		__flush_tlb();
<span class="p_add">+	}</span>
 
 	/*
 	 * Note: if we somehow had PCID but not PGE, then this wouldn&#39;t work --
<span class="p_chunk">@@ -303,6 +308,9 @@</span> <span class="p_context"> static inline void __flush_tlb_all(void)</span>
 	 */
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * flush one page in the kernel mapping</span>
<span class="p_add">+ */</span>
 static inline void __flush_tlb_one(unsigned long addr)
 {
 	count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ONE);
<span class="p_header">diff --git a/arch/x86/kernel/asm-offsets.c b/arch/x86/kernel/asm-offsets.c</span>
<span class="p_header">index cd360a5e0dca..676b7cf4b62b 100644</span>
<span class="p_header">--- a/arch/x86/kernel/asm-offsets.c</span>
<span class="p_header">+++ b/arch/x86/kernel/asm-offsets.c</span>
<span class="p_chunk">@@ -97,6 +97,6 @@</span> <span class="p_context"> void common(void) {</span>
 	/* Layout info for cpu_entry_area */
 	OFFSET(CPU_ENTRY_AREA_tss, cpu_entry_area, tss);
 	OFFSET(CPU_ENTRY_AREA_entry_trampoline, cpu_entry_area, entry_trampoline);
<span class="p_del">-	OFFSET(CPU_ENTRY_AREA_SYSENTER_stack, cpu_entry_area, SYSENTER_stack_page);</span>
<span class="p_del">-	DEFINE(SIZEOF_SYSENTER_stack, sizeof(struct SYSENTER_stack));</span>
<span class="p_add">+	OFFSET(CPU_ENTRY_AREA_entry_stack, cpu_entry_area, entry_stack_page);</span>
<span class="p_add">+	DEFINE(SIZEOF_entry_stack, sizeof(struct entry_stack));</span>
 }
<span class="p_header">diff --git a/arch/x86/kernel/asm-offsets_32.c b/arch/x86/kernel/asm-offsets_32.c</span>
<span class="p_header">index 7d20d9c0b3d6..fa1261eefa16 100644</span>
<span class="p_header">--- a/arch/x86/kernel/asm-offsets_32.c</span>
<span class="p_header">+++ b/arch/x86/kernel/asm-offsets_32.c</span>
<span class="p_chunk">@@ -48,7 +48,7 @@</span> <span class="p_context"> void foo(void)</span>
 
 	/* Offset from the sysenter stack to tss.sp0 */
 	DEFINE(TSS_sysenter_sp0, offsetof(struct cpu_entry_area, tss.x86_tss.sp0) -
<span class="p_del">-	       offsetofend(struct cpu_entry_area, SYSENTER_stack_page.stack));</span>
<span class="p_add">+	       offsetofend(struct cpu_entry_area, entry_stack_page.stack));</span>
 
 #ifdef CONFIG_CC_STACKPROTECTOR
 	BLANK();
<span class="p_header">diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">index 034900623adf..8ddcfa4d4165 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/common.c</span>
<span class="p_chunk">@@ -482,102 +482,8 @@</span> <span class="p_context"> static const unsigned int exception_stack_sizes[N_EXCEPTION_STACKS] = {</span>
 	  [0 ... N_EXCEPTION_STACKS - 1]	= EXCEPTION_STKSZ,
 	  [DEBUG_STACK - 1]			= DEBUG_STKSZ
 };
<span class="p_del">-</span>
<span class="p_del">-static DEFINE_PER_CPU_PAGE_ALIGNED(char, exception_stacks</span>
<span class="p_del">-	[(N_EXCEPTION_STACKS - 1) * EXCEPTION_STKSZ + DEBUG_STKSZ]);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-static DEFINE_PER_CPU_PAGE_ALIGNED(struct SYSENTER_stack_page,</span>
<span class="p_del">-				   SYSENTER_stack_storage);</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init</span>
<span class="p_del">-set_percpu_fixmap_pages(int idx, void *ptr, int pages, pgprot_t prot)</span>
<span class="p_del">-{</span>
<span class="p_del">-	for ( ; pages; pages--, idx--, ptr += PAGE_SIZE)</span>
<span class="p_del">-		__set_fixmap(idx, per_cpu_ptr_to_phys(ptr), prot);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Setup the fixmap mappings only once per-processor */</span>
<span class="p_del">-static void __init setup_cpu_entry_area(int cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	extern char _entry_trampoline[];</span>
<span class="p_del">-</span>
<span class="p_del">-	/* On 64-bit systems, we use a read-only fixmap GDT and TSS. */</span>
<span class="p_del">-	pgprot_t gdt_prot = PAGE_KERNEL_RO;</span>
<span class="p_del">-	pgprot_t tss_prot = PAGE_KERNEL_RO;</span>
<span class="p_del">-#else</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * On native 32-bit systems, the GDT cannot be read-only because</span>
<span class="p_del">-	 * our double fault handler uses a task gate, and entering through</span>
<span class="p_del">-	 * a task gate needs to change an available TSS to busy.  If the</span>
<span class="p_del">-	 * GDT is read-only, that will triple fault.  The TSS cannot be</span>
<span class="p_del">-	 * read-only because the CPU writes to it on task switches.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * On Xen PV, the GDT must be read-only because the hypervisor</span>
<span class="p_del">-	 * requires it.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	pgprot_t gdt_prot = boot_cpu_has(X86_FEATURE_XENPV) ?</span>
<span class="p_del">-		PAGE_KERNEL_RO : PAGE_KERNEL;</span>
<span class="p_del">-	pgprot_t tss_prot = PAGE_KERNEL;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	__set_fixmap(get_cpu_entry_area_index(cpu, gdt), get_cpu_gdt_paddr(cpu), gdt_prot);</span>
<span class="p_del">-	set_percpu_fixmap_pages(get_cpu_entry_area_index(cpu, SYSENTER_stack_page),</span>
<span class="p_del">-				per_cpu_ptr(&amp;SYSENTER_stack_storage, cpu), 1,</span>
<span class="p_del">-				PAGE_KERNEL);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The Intel SDM says (Volume 3, 7.2.1):</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *  Avoid placing a page boundary in the part of the TSS that the</span>
<span class="p_del">-	 *  processor reads during a task switch (the first 104 bytes). The</span>
<span class="p_del">-	 *  processor may not correctly perform address translations if a</span>
<span class="p_del">-	 *  boundary occurs in this area. During a task switch, the processor</span>
<span class="p_del">-	 *  reads and writes into the first 104 bytes of each TSS (using</span>
<span class="p_del">-	 *  contiguous physical addresses beginning with the physical address</span>
<span class="p_del">-	 *  of the first byte of the TSS). So, after TSS access begins, if</span>
<span class="p_del">-	 *  part of the 104 bytes is not physically contiguous, the processor</span>
<span class="p_del">-	 *  will access incorrect information without generating a page-fault</span>
<span class="p_del">-	 *  exception.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * There are also a lot of errata involving the TSS spanning a page</span>
<span class="p_del">-	 * boundary.  Assert that we&#39;re not doing that.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	BUILD_BUG_ON((offsetof(struct tss_struct, x86_tss) ^</span>
<span class="p_del">-		      offsetofend(struct tss_struct, x86_tss)) &amp; PAGE_MASK);</span>
<span class="p_del">-	BUILD_BUG_ON(sizeof(struct tss_struct) % PAGE_SIZE != 0);</span>
<span class="p_del">-	set_percpu_fixmap_pages(get_cpu_entry_area_index(cpu, tss),</span>
<span class="p_del">-				&amp;per_cpu(cpu_tss_rw, cpu),</span>
<span class="p_del">-				sizeof(struct tss_struct) / PAGE_SIZE,</span>
<span class="p_del">-				tss_prot);</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	per_cpu(cpu_entry_area, cpu) = get_cpu_entry_area(cpu);</span>
 #endif
 
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	BUILD_BUG_ON(sizeof(exception_stacks) % PAGE_SIZE != 0);</span>
<span class="p_del">-	BUILD_BUG_ON(sizeof(exception_stacks) !=</span>
<span class="p_del">-		     sizeof(((struct cpu_entry_area *)0)-&gt;exception_stacks));</span>
<span class="p_del">-	set_percpu_fixmap_pages(get_cpu_entry_area_index(cpu, exception_stacks),</span>
<span class="p_del">-				&amp;per_cpu(exception_stacks, cpu),</span>
<span class="p_del">-				sizeof(exception_stacks) / PAGE_SIZE,</span>
<span class="p_del">-				PAGE_KERNEL);</span>
<span class="p_del">-</span>
<span class="p_del">-	__set_fixmap(get_cpu_entry_area_index(cpu, entry_trampoline),</span>
<span class="p_del">-		     __pa_symbol(_entry_trampoline), PAGE_KERNEL_RX);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void __init setup_cpu_entry_areas(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int cpu;</span>
<span class="p_del">-</span>
<span class="p_del">-	for_each_possible_cpu(cpu)</span>
<span class="p_del">-		setup_cpu_entry_area(cpu);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* Load the original GDT from the per-cpu structure */
 void load_direct_gdt(int cpu)
 {
<span class="p_chunk">@@ -1323,7 +1229,7 @@</span> <span class="p_context"> void enable_sep_cpu(void)</span>
 
 	tss-&gt;x86_tss.ss1 = __KERNEL_CS;
 	wrmsr(MSR_IA32_SYSENTER_CS, tss-&gt;x86_tss.ss1, 0);
<span class="p_del">-	wrmsr(MSR_IA32_SYSENTER_ESP, (unsigned long)(cpu_SYSENTER_stack(cpu) + 1), 0);</span>
<span class="p_add">+	wrmsr(MSR_IA32_SYSENTER_ESP, (unsigned long)(cpu_entry_stack(cpu) + 1), 0);</span>
 	wrmsr(MSR_IA32_SYSENTER_EIP, (unsigned long)entry_SYSENTER_32, 0);
 
 	put_cpu();
<span class="p_chunk">@@ -1440,7 +1346,7 @@</span> <span class="p_context"> void syscall_init(void)</span>
 	 * AMD doesn&#39;t allow SYSENTER in long mode (either 32- or 64-bit).
 	 */
 	wrmsrl_safe(MSR_IA32_SYSENTER_CS, (u64)__KERNEL_CS);
<span class="p_del">-	wrmsrl_safe(MSR_IA32_SYSENTER_ESP, (unsigned long)(cpu_SYSENTER_stack(cpu) + 1));</span>
<span class="p_add">+	wrmsrl_safe(MSR_IA32_SYSENTER_ESP, (unsigned long)(cpu_entry_stack(cpu) + 1));</span>
 	wrmsrl_safe(MSR_IA32_SYSENTER_EIP, (u64)entry_SYSENTER_compat);
 #else
 	wrmsrl(MSR_CSTAR, (unsigned long)ignore_sysret);
<span class="p_chunk">@@ -1655,7 +1561,7 @@</span> <span class="p_context"> void cpu_init(void)</span>
 	 */
 	set_tss_desc(cpu, &amp;get_cpu_entry_area(cpu)-&gt;tss.x86_tss);
 	load_TR_desc();
<span class="p_del">-	load_sp0((unsigned long)(cpu_SYSENTER_stack(cpu) + 1));</span>
<span class="p_add">+	load_sp0((unsigned long)(cpu_entry_stack(cpu) + 1));</span>
 
 	load_mm_ldt(&amp;init_mm);
 
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/intel.c b/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_header">index 7dbcb7adf797..8ccdca6d3f9e 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_chunk">@@ -565,15 +565,6 @@</span> <span class="p_context"> static void print_ucode(struct ucode_cpu_info *uci)</span>
 }
 #else
 
<span class="p_del">-/*</span>
<span class="p_del">- * Flush global tlb. We only do this in x86_64 where paging has been enabled</span>
<span class="p_del">- * already and PGE should be enabled as well.</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline void flush_tlb_early(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	__native_flush_tlb_global_irq_disabled();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline void print_ucode(struct ucode_cpu_info *uci)
 {
 	struct microcode_intel *mc;
<span class="p_chunk">@@ -602,10 +593,6 @@</span> <span class="p_context"> static int apply_microcode_early(struct ucode_cpu_info *uci, bool early)</span>
 	if (rev != mc-&gt;hdr.rev)
 		return -1;
 
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	/* Flush global tlb. This is precaution. */</span>
<span class="p_del">-	flush_tlb_early();</span>
<span class="p_del">-#endif</span>
 	uci-&gt;cpu_sig.rev = rev;
 
 	if (early)
<span class="p_header">diff --git a/arch/x86/kernel/dumpstack.c b/arch/x86/kernel/dumpstack.c</span>
<span class="p_header">index bbd6d986e2d0..36b17e0febe8 100644</span>
<span class="p_header">--- a/arch/x86/kernel/dumpstack.c</span>
<span class="p_header">+++ b/arch/x86/kernel/dumpstack.c</span>
<span class="p_chunk">@@ -18,6 +18,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/nmi.h&gt;
 #include &lt;linux/sysfs.h&gt;
 
<span class="p_add">+#include &lt;asm/cpu_entry_area.h&gt;</span>
 #include &lt;asm/stacktrace.h&gt;
 #include &lt;asm/unwind.h&gt;
 
<span class="p_chunk">@@ -43,9 +44,9 @@</span> <span class="p_context"> bool in_task_stack(unsigned long *stack, struct task_struct *task,</span>
 	return true;
 }
 
<span class="p_del">-bool in_sysenter_stack(unsigned long *stack, struct stack_info *info)</span>
<span class="p_add">+bool in_entry_stack(unsigned long *stack, struct stack_info *info)</span>
 {
<span class="p_del">-	struct SYSENTER_stack *ss = cpu_SYSENTER_stack(smp_processor_id());</span>
<span class="p_add">+	struct entry_stack *ss = cpu_entry_stack(smp_processor_id());</span>
 
 	void *begin = ss;
 	void *end = ss + 1;
<span class="p_chunk">@@ -53,7 +54,7 @@</span> <span class="p_context"> bool in_sysenter_stack(unsigned long *stack, struct stack_info *info)</span>
 	if ((void *)stack &lt; begin || (void *)stack &gt;= end)
 		return false;
 
<span class="p_del">-	info-&gt;type	= STACK_TYPE_SYSENTER;</span>
<span class="p_add">+	info-&gt;type	= STACK_TYPE_ENTRY;</span>
 	info-&gt;begin	= begin;
 	info-&gt;end	= end;
 	info-&gt;next_sp	= NULL;
<span class="p_chunk">@@ -111,13 +112,13 @@</span> <span class="p_context"> void show_trace_log_lvl(struct task_struct *task, struct pt_regs *regs,</span>
 	 * - task stack
 	 * - interrupt stack
 	 * - HW exception stacks (double fault, nmi, debug, mce)
<span class="p_del">-	 * - SYSENTER stack</span>
<span class="p_add">+	 * - entry stack</span>
 	 *
 	 * x86-32 can have up to four stacks:
 	 * - task stack
 	 * - softirq stack
 	 * - hardirq stack
<span class="p_del">-	 * - SYSENTER stack</span>
<span class="p_add">+	 * - entry stack</span>
 	 */
 	for (regs = NULL; stack; stack = PTR_ALIGN(stack_info.next_sp, sizeof(long))) {
 		const char *stack_name;
<span class="p_header">diff --git a/arch/x86/kernel/dumpstack_32.c b/arch/x86/kernel/dumpstack_32.c</span>
<span class="p_header">index 5ff13a6b3680..04170f63e3a1 100644</span>
<span class="p_header">--- a/arch/x86/kernel/dumpstack_32.c</span>
<span class="p_header">+++ b/arch/x86/kernel/dumpstack_32.c</span>
<span class="p_chunk">@@ -26,8 +26,8 @@</span> <span class="p_context"> const char *stack_type_name(enum stack_type type)</span>
 	if (type == STACK_TYPE_SOFTIRQ)
 		return &quot;SOFTIRQ&quot;;
 
<span class="p_del">-	if (type == STACK_TYPE_SYSENTER)</span>
<span class="p_del">-		return &quot;SYSENTER&quot;;</span>
<span class="p_add">+	if (type == STACK_TYPE_ENTRY)</span>
<span class="p_add">+		return &quot;ENTRY_TRAMPOLINE&quot;;</span>
 
 	return NULL;
 }
<span class="p_chunk">@@ -96,7 +96,7 @@</span> <span class="p_context"> int get_stack_info(unsigned long *stack, struct task_struct *task,</span>
 	if (task != current)
 		goto unknown;
 
<span class="p_del">-	if (in_sysenter_stack(stack, info))</span>
<span class="p_add">+	if (in_entry_stack(stack, info))</span>
 		goto recursion_check;
 
 	if (in_hardirq_stack(stack, info))
<span class="p_header">diff --git a/arch/x86/kernel/dumpstack_64.c b/arch/x86/kernel/dumpstack_64.c</span>
<span class="p_header">index abc828f8c297..563e28d14f2c 100644</span>
<span class="p_header">--- a/arch/x86/kernel/dumpstack_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/dumpstack_64.c</span>
<span class="p_chunk">@@ -37,8 +37,14 @@</span> <span class="p_context"> const char *stack_type_name(enum stack_type type)</span>
 	if (type == STACK_TYPE_IRQ)
 		return &quot;IRQ&quot;;
 
<span class="p_del">-	if (type == STACK_TYPE_SYSENTER)</span>
<span class="p_del">-		return &quot;SYSENTER&quot;;</span>
<span class="p_add">+	if (type == STACK_TYPE_ENTRY) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * On 64-bit, we have a generic entry stack that we</span>
<span class="p_add">+		 * use for all the kernel entry points, including</span>
<span class="p_add">+		 * SYSENTER.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		return &quot;ENTRY_TRAMPOLINE&quot;;</span>
<span class="p_add">+	}</span>
 
 	if (type &gt;= STACK_TYPE_EXCEPTION &amp;&amp; type &lt;= STACK_TYPE_EXCEPTION_LAST)
 		return exception_stack_names[type - STACK_TYPE_EXCEPTION];
<span class="p_chunk">@@ -118,7 +124,7 @@</span> <span class="p_context"> int get_stack_info(unsigned long *stack, struct task_struct *task,</span>
 	if (in_irq_stack(stack, info))
 		goto recursion_check;
 
<span class="p_del">-	if (in_sysenter_stack(stack, info))</span>
<span class="p_add">+	if (in_entry_stack(stack, info))</span>
 		goto recursion_check;
 
 	goto unknown;
<span class="p_header">diff --git a/arch/x86/kernel/ldt.c b/arch/x86/kernel/ldt.c</span>
<span class="p_header">index 1c1eae961340..a6b5d62f45a7 100644</span>
<span class="p_header">--- a/arch/x86/kernel/ldt.c</span>
<span class="p_header">+++ b/arch/x86/kernel/ldt.c</span>
<span class="p_chunk">@@ -5,6 +5,11 @@</span> <span class="p_context"></span>
  * Copyright (C) 2002 Andi Kleen
  *
  * This handles calls from both 32bit and 64bit mode.
<span class="p_add">+ *</span>
<span class="p_add">+ * Lock order:</span>
<span class="p_add">+ *	contex.ldt_usr_sem</span>
<span class="p_add">+ *	  mmap_sem</span>
<span class="p_add">+ *	    context.lock</span>
  */
 
 #include &lt;linux/errno.h&gt;
<span class="p_chunk">@@ -42,7 +47,7 @@</span> <span class="p_context"> static void refresh_ldt_segments(void)</span>
 #endif
 }
 
<span class="p_del">-/* context.lock is held for us, so we don&#39;t need any locking. */</span>
<span class="p_add">+/* context.lock is held by the task which issued the smp function call */</span>
 static void flush_ldt(void *__mm)
 {
 	struct mm_struct *mm = __mm;
<span class="p_chunk">@@ -99,15 +104,17 @@</span> <span class="p_context"> static void finalize_ldt_struct(struct ldt_struct *ldt)</span>
 	paravirt_alloc_ldt(ldt-&gt;entries, ldt-&gt;nr_entries);
 }
 
<span class="p_del">-/* context.lock is held */</span>
<span class="p_del">-static void install_ldt(struct mm_struct *current_mm,</span>
<span class="p_del">-			struct ldt_struct *ldt)</span>
<span class="p_add">+static void install_ldt(struct mm_struct *mm, struct ldt_struct *ldt)</span>
 {
<span class="p_add">+	mutex_lock(&amp;mm-&gt;context.lock);</span>
<span class="p_add">+</span>
 	/* Synchronizes with READ_ONCE in load_mm_ldt. */
<span class="p_del">-	smp_store_release(&amp;current_mm-&gt;context.ldt, ldt);</span>
<span class="p_add">+	smp_store_release(&amp;mm-&gt;context.ldt, ldt);</span>
 
<span class="p_del">-	/* Activate the LDT for all CPUs using current_mm. */</span>
<span class="p_del">-	on_each_cpu_mask(mm_cpumask(current_mm), flush_ldt, current_mm, true);</span>
<span class="p_add">+	/* Activate the LDT for all CPUs using currents mm. */</span>
<span class="p_add">+	on_each_cpu_mask(mm_cpumask(mm), flush_ldt, mm, true);</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;mm-&gt;context.lock);</span>
 }
 
 static void free_ldt_struct(struct ldt_struct *ldt)
<span class="p_chunk">@@ -124,27 +131,20 @@</span> <span class="p_context"> static void free_ldt_struct(struct ldt_struct *ldt)</span>
 }
 
 /*
<span class="p_del">- * we do not have to muck with descriptors here, that is</span>
<span class="p_del">- * done in switch_mm() as needed.</span>
<span class="p_add">+ * Called on fork from arch_dup_mmap(). Just copy the current LDT state,</span>
<span class="p_add">+ * the new task is not running, so nothing can be installed.</span>
  */
<span class="p_del">-int init_new_context_ldt(struct task_struct *tsk, struct mm_struct *mm)</span>
<span class="p_add">+int ldt_dup_context(struct mm_struct *old_mm, struct mm_struct *mm)</span>
 {
 	struct ldt_struct *new_ldt;
<span class="p_del">-	struct mm_struct *old_mm;</span>
 	int retval = 0;
 
<span class="p_del">-	mutex_init(&amp;mm-&gt;context.lock);</span>
<span class="p_del">-	old_mm = current-&gt;mm;</span>
<span class="p_del">-	if (!old_mm) {</span>
<span class="p_del">-		mm-&gt;context.ldt = NULL;</span>
<span class="p_add">+	if (!old_mm)</span>
 		return 0;
<span class="p_del">-	}</span>
 
 	mutex_lock(&amp;old_mm-&gt;context.lock);
<span class="p_del">-	if (!old_mm-&gt;context.ldt) {</span>
<span class="p_del">-		mm-&gt;context.ldt = NULL;</span>
<span class="p_add">+	if (!old_mm-&gt;context.ldt)</span>
 		goto out_unlock;
<span class="p_del">-	}</span>
 
 	new_ldt = alloc_ldt_struct(old_mm-&gt;context.ldt-&gt;nr_entries);
 	if (!new_ldt) {
<span class="p_chunk">@@ -180,7 +180,7 @@</span> <span class="p_context"> static int read_ldt(void __user *ptr, unsigned long bytecount)</span>
 	unsigned long entries_size;
 	int retval;
 
<span class="p_del">-	mutex_lock(&amp;mm-&gt;context.lock);</span>
<span class="p_add">+	down_read(&amp;mm-&gt;context.ldt_usr_sem);</span>
 
 	if (!mm-&gt;context.ldt) {
 		retval = 0;
<span class="p_chunk">@@ -209,7 +209,7 @@</span> <span class="p_context"> static int read_ldt(void __user *ptr, unsigned long bytecount)</span>
 	retval = bytecount;
 
 out_unlock:
<span class="p_del">-	mutex_unlock(&amp;mm-&gt;context.lock);</span>
<span class="p_add">+	up_read(&amp;mm-&gt;context.ldt_usr_sem);</span>
 	return retval;
 }
 
<span class="p_chunk">@@ -269,7 +269,8 @@</span> <span class="p_context"> static int write_ldt(void __user *ptr, unsigned long bytecount, int oldmode)</span>
 			ldt.avl = 0;
 	}
 
<span class="p_del">-	mutex_lock(&amp;mm-&gt;context.lock);</span>
<span class="p_add">+	if (down_write_killable(&amp;mm-&gt;context.ldt_usr_sem))</span>
<span class="p_add">+		return -EINTR;</span>
 
 	old_ldt       = mm-&gt;context.ldt;
 	old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : 0;
<span class="p_chunk">@@ -291,7 +292,7 @@</span> <span class="p_context"> static int write_ldt(void __user *ptr, unsigned long bytecount, int oldmode)</span>
 	error = 0;
 
 out_unlock:
<span class="p_del">-	mutex_unlock(&amp;mm-&gt;context.lock);</span>
<span class="p_add">+	up_write(&amp;mm-&gt;context.ldt_usr_sem);</span>
 out:
 	return error;
 }
<span class="p_header">diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c</span>
<span class="p_header">index 142126ab5aae..12bf07d44dfe 100644</span>
<span class="p_header">--- a/arch/x86/kernel/smpboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/smpboot.c</span>
<span class="p_chunk">@@ -990,12 +990,8 @@</span> <span class="p_context"> static int do_boot_cpu(int apicid, int cpu, struct task_struct *idle,</span>
 	initial_code = (unsigned long)start_secondary;
 	initial_stack  = idle-&gt;thread.sp;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Enable the espfix hack for this CPU</span>
<span class="p_del">-	*/</span>
<span class="p_del">-#ifdef CONFIG_X86_ESPFIX64</span>
<span class="p_add">+	/* Enable the espfix hack for this CPU */</span>
 	init_espfix_ap(cpu);
<span class="p_del">-#endif</span>
 
 	/* So we see what&#39;s up */
 	announce_cpu(cpu, apicid);
<span class="p_header">diff --git a/arch/x86/kernel/traps.c b/arch/x86/kernel/traps.c</span>
<span class="p_header">index 74136fd16f49..7c16fe0b60c2 100644</span>
<span class="p_header">--- a/arch/x86/kernel/traps.c</span>
<span class="p_header">+++ b/arch/x86/kernel/traps.c</span>
<span class="p_chunk">@@ -52,6 +52,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/traps.h&gt;
 #include &lt;asm/desc.h&gt;
 #include &lt;asm/fpu/internal.h&gt;
<span class="p_add">+#include &lt;asm/cpu_entry_area.h&gt;</span>
 #include &lt;asm/mce.h&gt;
 #include &lt;asm/fixmap.h&gt;
 #include &lt;asm/mach_traps.h&gt;
<span class="p_chunk">@@ -950,8 +951,9 @@</span> <span class="p_context"> void __init trap_init(void)</span>
 	 * &quot;sidt&quot; instruction will not leak the location of the kernel, and
 	 * to defend the IDT against arbitrary memory write vulnerabilities.
 	 * It will be reloaded in cpu_init() */
<span class="p_del">-	__set_fixmap(FIX_RO_IDT, __pa_symbol(idt_table), PAGE_KERNEL_RO);</span>
<span class="p_del">-	idt_descr.address = fix_to_virt(FIX_RO_IDT);</span>
<span class="p_add">+	cea_set_pte(CPU_ENTRY_AREA_RO_IDT_VADDR, __pa_symbol(idt_table),</span>
<span class="p_add">+		    PAGE_KERNEL_RO);</span>
<span class="p_add">+	idt_descr.address = CPU_ENTRY_AREA_RO_IDT;</span>
 
 	/*
 	 * Should be a barrier for any external CPU state:
<span class="p_header">diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c</span>
<span class="p_header">index d90cdc77e077..7bbb5da2b49d 100644</span>
<span class="p_header">--- a/arch/x86/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/x86/kvm/emulate.c</span>
<span class="p_chunk">@@ -2404,9 +2404,21 @@</span> <span class="p_context"> static int rsm_load_seg_64(struct x86_emulate_ctxt *ctxt, u64 smbase, int n)</span>
 }
 
 static int rsm_enter_protected_mode(struct x86_emulate_ctxt *ctxt,
<span class="p_del">-				     u64 cr0, u64 cr4)</span>
<span class="p_add">+				    u64 cr0, u64 cr3, u64 cr4)</span>
 {
 	int bad;
<span class="p_add">+	u64 pcid;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* In order to later set CR4.PCIDE, CR3[11:0] must be zero.  */</span>
<span class="p_add">+	pcid = 0;</span>
<span class="p_add">+	if (cr4 &amp; X86_CR4_PCIDE) {</span>
<span class="p_add">+		pcid = cr3 &amp; 0xfff;</span>
<span class="p_add">+		cr3 &amp;= ~0xfff;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	bad = ctxt-&gt;ops-&gt;set_cr(ctxt, 3, cr3);</span>
<span class="p_add">+	if (bad)</span>
<span class="p_add">+		return X86EMUL_UNHANDLEABLE;</span>
 
 	/*
 	 * First enable PAE, long mode needs it before CR0.PG = 1 is set.
<span class="p_chunk">@@ -2425,6 +2437,12 @@</span> <span class="p_context"> static int rsm_enter_protected_mode(struct x86_emulate_ctxt *ctxt,</span>
 		bad = ctxt-&gt;ops-&gt;set_cr(ctxt, 4, cr4);
 		if (bad)
 			return X86EMUL_UNHANDLEABLE;
<span class="p_add">+		if (pcid) {</span>
<span class="p_add">+			bad = ctxt-&gt;ops-&gt;set_cr(ctxt, 3, cr3 | pcid);</span>
<span class="p_add">+			if (bad)</span>
<span class="p_add">+				return X86EMUL_UNHANDLEABLE;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 	}
 
 	return X86EMUL_CONTINUE;
<span class="p_chunk">@@ -2435,11 +2453,11 @@</span> <span class="p_context"> static int rsm_load_state_32(struct x86_emulate_ctxt *ctxt, u64 smbase)</span>
 	struct desc_struct desc;
 	struct desc_ptr dt;
 	u16 selector;
<span class="p_del">-	u32 val, cr0, cr4;</span>
<span class="p_add">+	u32 val, cr0, cr3, cr4;</span>
 	int i;
 
 	cr0 =                      GET_SMSTATE(u32, smbase, 0x7ffc);
<span class="p_del">-	ctxt-&gt;ops-&gt;set_cr(ctxt, 3, GET_SMSTATE(u32, smbase, 0x7ff8));</span>
<span class="p_add">+	cr3 =                      GET_SMSTATE(u32, smbase, 0x7ff8);</span>
 	ctxt-&gt;eflags =             GET_SMSTATE(u32, smbase, 0x7ff4) | X86_EFLAGS_FIXED;
 	ctxt-&gt;_eip =               GET_SMSTATE(u32, smbase, 0x7ff0);
 
<span class="p_chunk">@@ -2481,14 +2499,14 @@</span> <span class="p_context"> static int rsm_load_state_32(struct x86_emulate_ctxt *ctxt, u64 smbase)</span>
 
 	ctxt-&gt;ops-&gt;set_smbase(ctxt, GET_SMSTATE(u32, smbase, 0x7ef8));
 
<span class="p_del">-	return rsm_enter_protected_mode(ctxt, cr0, cr4);</span>
<span class="p_add">+	return rsm_enter_protected_mode(ctxt, cr0, cr3, cr4);</span>
 }
 
 static int rsm_load_state_64(struct x86_emulate_ctxt *ctxt, u64 smbase)
 {
 	struct desc_struct desc;
 	struct desc_ptr dt;
<span class="p_del">-	u64 val, cr0, cr4;</span>
<span class="p_add">+	u64 val, cr0, cr3, cr4;</span>
 	u32 base3;
 	u16 selector;
 	int i, r;
<span class="p_chunk">@@ -2505,7 +2523,7 @@</span> <span class="p_context"> static int rsm_load_state_64(struct x86_emulate_ctxt *ctxt, u64 smbase)</span>
 	ctxt-&gt;ops-&gt;set_dr(ctxt, 7, (val &amp; DR7_VOLATILE) | DR7_FIXED_1);
 
 	cr0 =                       GET_SMSTATE(u64, smbase, 0x7f58);
<span class="p_del">-	ctxt-&gt;ops-&gt;set_cr(ctxt, 3,  GET_SMSTATE(u64, smbase, 0x7f50));</span>
<span class="p_add">+	cr3 =                       GET_SMSTATE(u64, smbase, 0x7f50);</span>
 	cr4 =                       GET_SMSTATE(u64, smbase, 0x7f48);
 	ctxt-&gt;ops-&gt;set_smbase(ctxt, GET_SMSTATE(u32, smbase, 0x7f00));
 	val =                       GET_SMSTATE(u64, smbase, 0x7ed0);
<span class="p_chunk">@@ -2533,7 +2551,7 @@</span> <span class="p_context"> static int rsm_load_state_64(struct x86_emulate_ctxt *ctxt, u64 smbase)</span>
 	dt.address =                GET_SMSTATE(u64, smbase, 0x7e68);
 	ctxt-&gt;ops-&gt;set_gdt(ctxt, &amp;dt);
 
<span class="p_del">-	r = rsm_enter_protected_mode(ctxt, cr0, cr4);</span>
<span class="p_add">+	r = rsm_enter_protected_mode(ctxt, cr0, cr3, cr4);</span>
 	if (r != X86EMUL_CONTINUE)
 		return r;
 
<span class="p_header">diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c</span>
<span class="p_header">index 13ebeedcec07..0fce8d73403c 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mmu.c</span>
<span class="p_chunk">@@ -3382,7 +3382,7 @@</span> <span class="p_context"> static int mmu_alloc_direct_roots(struct kvm_vcpu *vcpu)</span>
 		spin_lock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);
 		if(make_mmu_pages_available(vcpu) &lt; 0) {
 			spin_unlock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);
<span class="p_del">-			return 1;</span>
<span class="p_add">+			return -ENOSPC;</span>
 		}
 		sp = kvm_mmu_get_page(vcpu, 0, 0,
 				vcpu-&gt;arch.mmu.shadow_root_level, 1, ACC_ALL);
<span class="p_chunk">@@ -3397,7 +3397,7 @@</span> <span class="p_context"> static int mmu_alloc_direct_roots(struct kvm_vcpu *vcpu)</span>
 			spin_lock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);
 			if (make_mmu_pages_available(vcpu) &lt; 0) {
 				spin_unlock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);
<span class="p_del">-				return 1;</span>
<span class="p_add">+				return -ENOSPC;</span>
 			}
 			sp = kvm_mmu_get_page(vcpu, i &lt;&lt; (30 - PAGE_SHIFT),
 					i &lt;&lt; 30, PT32_ROOT_LEVEL, 1, ACC_ALL);
<span class="p_chunk">@@ -3437,7 +3437,7 @@</span> <span class="p_context"> static int mmu_alloc_shadow_roots(struct kvm_vcpu *vcpu)</span>
 		spin_lock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);
 		if (make_mmu_pages_available(vcpu) &lt; 0) {
 			spin_unlock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);
<span class="p_del">-			return 1;</span>
<span class="p_add">+			return -ENOSPC;</span>
 		}
 		sp = kvm_mmu_get_page(vcpu, root_gfn, 0,
 				vcpu-&gt;arch.mmu.shadow_root_level, 0, ACC_ALL);
<span class="p_chunk">@@ -3474,7 +3474,7 @@</span> <span class="p_context"> static int mmu_alloc_shadow_roots(struct kvm_vcpu *vcpu)</span>
 		spin_lock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);
 		if (make_mmu_pages_available(vcpu) &lt; 0) {
 			spin_unlock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);
<span class="p_del">-			return 1;</span>
<span class="p_add">+			return -ENOSPC;</span>
 		}
 		sp = kvm_mmu_get_page(vcpu, root_gfn, i &lt;&lt; 30, PT32_ROOT_LEVEL,
 				      0, ACC_ALL);
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index df62cdc7a258..075619a92ce7 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -7359,7 +7359,7 @@</span> <span class="p_context"> int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)</span>
 #endif
 
 	kvm_rip_write(vcpu, regs-&gt;rip);
<span class="p_del">-	kvm_set_rflags(vcpu, regs-&gt;rflags);</span>
<span class="p_add">+	kvm_set_rflags(vcpu, regs-&gt;rflags | X86_EFLAGS_FIXED);</span>
 
 	vcpu-&gt;arch.exception.pending = false;
 
<span class="p_header">diff --git a/arch/x86/lib/x86-opcode-map.txt b/arch/x86/lib/x86-opcode-map.txt</span>
<span class="p_header">index c4d55919fac1..e0b85930dd77 100644</span>
<span class="p_header">--- a/arch/x86/lib/x86-opcode-map.txt</span>
<span class="p_header">+++ b/arch/x86/lib/x86-opcode-map.txt</span>
<span class="p_chunk">@@ -607,7 +607,7 @@</span> <span class="p_context"> fb: psubq Pq,Qq | vpsubq Vx,Hx,Wx (66),(v1)</span>
 fc: paddb Pq,Qq | vpaddb Vx,Hx,Wx (66),(v1)
 fd: paddw Pq,Qq | vpaddw Vx,Hx,Wx (66),(v1)
 fe: paddd Pq,Qq | vpaddd Vx,Hx,Wx (66),(v1)
<span class="p_del">-ff:</span>
<span class="p_add">+ff: UD0</span>
 EndTable
 
 Table: 3-byte opcode 1 (0x0f 0x38)
<span class="p_chunk">@@ -717,7 +717,7 @@</span> <span class="p_context"> AVXcode: 2</span>
 7e: vpermt2d/q Vx,Hx,Wx (66),(ev)
 7f: vpermt2ps/d Vx,Hx,Wx (66),(ev)
 80: INVEPT Gy,Mdq (66)
<span class="p_del">-81: INVPID Gy,Mdq (66)</span>
<span class="p_add">+81: INVVPID Gy,Mdq (66)</span>
 82: INVPCID Gy,Mdq (66)
 83: vpmultishiftqb Vx,Hx,Wx (66),(ev)
 88: vexpandps/d Vpd,Wpd (66),(ev)
<span class="p_chunk">@@ -970,6 +970,15 @@</span> <span class="p_context"> GrpTable: Grp9</span>
 EndTable
 
 GrpTable: Grp10
<span class="p_add">+# all are UD1</span>
<span class="p_add">+0: UD1</span>
<span class="p_add">+1: UD1</span>
<span class="p_add">+2: UD1</span>
<span class="p_add">+3: UD1</span>
<span class="p_add">+4: UD1</span>
<span class="p_add">+5: UD1</span>
<span class="p_add">+6: UD1</span>
<span class="p_add">+7: UD1</span>
 EndTable
 
 # Grp11A and Grp11B are expressed as Grp11 in Intel SDM
<span class="p_header">diff --git a/arch/x86/mm/Makefile b/arch/x86/mm/Makefile</span>
<span class="p_header">index 7ba7f3d7f477..2e0017af8f9b 100644</span>
<span class="p_header">--- a/arch/x86/mm/Makefile</span>
<span class="p_header">+++ b/arch/x86/mm/Makefile</span>
<span class="p_chunk">@@ -10,7 +10,7 @@</span> <span class="p_context"> CFLAGS_REMOVE_mem_encrypt.o	= -pg</span>
 endif
 
 obj-y	:=  init.o init_$(BITS).o fault.o ioremap.o extable.o pageattr.o mmap.o \
<span class="p_del">-	    pat.o pgtable.o physaddr.o setup_nx.o tlb.o</span>
<span class="p_add">+	    pat.o pgtable.o physaddr.o setup_nx.o tlb.o cpu_entry_area.o</span>
 
 # Make sure __phys_addr has no stackprotector
 nostackp := $(call cc-option, -fno-stack-protector)
<span class="p_header">diff --git a/arch/x86/mm/cpu_entry_area.c b/arch/x86/mm/cpu_entry_area.c</span>
new file mode 100644
<span class="p_header">index 000000000000..fe814fd5e014</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/mm/cpu_entry_area.c</span>
<span class="p_chunk">@@ -0,0 +1,139 @@</span> <span class="p_context"></span>
<span class="p_add">+// SPDX-License-Identifier: GPL-2.0</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/spinlock.h&gt;</span>
<span class="p_add">+#include &lt;linux/percpu.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/cpu_entry_area.h&gt;</span>
<span class="p_add">+#include &lt;asm/pgtable.h&gt;</span>
<span class="p_add">+#include &lt;asm/fixmap.h&gt;</span>
<span class="p_add">+#include &lt;asm/desc.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static DEFINE_PER_CPU_PAGE_ALIGNED(struct entry_stack_page, entry_stack_storage);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+static DEFINE_PER_CPU_PAGE_ALIGNED(char, exception_stacks</span>
<span class="p_add">+	[(N_EXCEPTION_STACKS - 1) * EXCEPTION_STKSZ + DEBUG_STKSZ]);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+struct cpu_entry_area *get_cpu_entry_area(int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long va = CPU_ENTRY_AREA_PER_CPU + cpu * CPU_ENTRY_AREA_SIZE;</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(struct cpu_entry_area) % PAGE_SIZE != 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	return (struct cpu_entry_area *) va;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(get_cpu_entry_area);</span>
<span class="p_add">+</span>
<span class="p_add">+void cea_set_pte(void *cea_vaddr, phys_addr_t pa, pgprot_t flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long va = (unsigned long) cea_vaddr;</span>
<span class="p_add">+</span>
<span class="p_add">+	set_pte_vaddr(va, pfn_pte(pa &gt;&gt; PAGE_SHIFT, flags));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init</span>
<span class="p_add">+cea_map_percpu_pages(void *cea_vaddr, void *ptr, int pages, pgprot_t prot)</span>
<span class="p_add">+{</span>
<span class="p_add">+	for ( ; pages; pages--, cea_vaddr+= PAGE_SIZE, ptr += PAGE_SIZE)</span>
<span class="p_add">+		cea_set_pte(cea_vaddr, per_cpu_ptr_to_phys(ptr), prot);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Setup the fixmap mappings only once per-processor */</span>
<span class="p_add">+static void __init setup_cpu_entry_area(int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	extern char _entry_trampoline[];</span>
<span class="p_add">+</span>
<span class="p_add">+	/* On 64-bit systems, we use a read-only fixmap GDT and TSS. */</span>
<span class="p_add">+	pgprot_t gdt_prot = PAGE_KERNEL_RO;</span>
<span class="p_add">+	pgprot_t tss_prot = PAGE_KERNEL_RO;</span>
<span class="p_add">+#else</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * On native 32-bit systems, the GDT cannot be read-only because</span>
<span class="p_add">+	 * our double fault handler uses a task gate, and entering through</span>
<span class="p_add">+	 * a task gate needs to change an available TSS to busy.  If the</span>
<span class="p_add">+	 * GDT is read-only, that will triple fault.  The TSS cannot be</span>
<span class="p_add">+	 * read-only because the CPU writes to it on task switches.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * On Xen PV, the GDT must be read-only because the hypervisor</span>
<span class="p_add">+	 * requires it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pgprot_t gdt_prot = boot_cpu_has(X86_FEATURE_XENPV) ?</span>
<span class="p_add">+		PAGE_KERNEL_RO : PAGE_KERNEL;</span>
<span class="p_add">+	pgprot_t tss_prot = PAGE_KERNEL;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	cea_set_pte(&amp;get_cpu_entry_area(cpu)-&gt;gdt, get_cpu_gdt_paddr(cpu),</span>
<span class="p_add">+		    gdt_prot);</span>
<span class="p_add">+</span>
<span class="p_add">+	cea_map_percpu_pages(&amp;get_cpu_entry_area(cpu)-&gt;entry_stack_page,</span>
<span class="p_add">+			     per_cpu_ptr(&amp;entry_stack_storage, cpu), 1,</span>
<span class="p_add">+			     PAGE_KERNEL);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The Intel SDM says (Volume 3, 7.2.1):</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *  Avoid placing a page boundary in the part of the TSS that the</span>
<span class="p_add">+	 *  processor reads during a task switch (the first 104 bytes). The</span>
<span class="p_add">+	 *  processor may not correctly perform address translations if a</span>
<span class="p_add">+	 *  boundary occurs in this area. During a task switch, the processor</span>
<span class="p_add">+	 *  reads and writes into the first 104 bytes of each TSS (using</span>
<span class="p_add">+	 *  contiguous physical addresses beginning with the physical address</span>
<span class="p_add">+	 *  of the first byte of the TSS). So, after TSS access begins, if</span>
<span class="p_add">+	 *  part of the 104 bytes is not physically contiguous, the processor</span>
<span class="p_add">+	 *  will access incorrect information without generating a page-fault</span>
<span class="p_add">+	 *  exception.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * There are also a lot of errata involving the TSS spanning a page</span>
<span class="p_add">+	 * boundary.  Assert that we&#39;re not doing that.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	BUILD_BUG_ON((offsetof(struct tss_struct, x86_tss) ^</span>
<span class="p_add">+		      offsetofend(struct tss_struct, x86_tss)) &amp; PAGE_MASK);</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(struct tss_struct) % PAGE_SIZE != 0);</span>
<span class="p_add">+	cea_map_percpu_pages(&amp;get_cpu_entry_area(cpu)-&gt;tss,</span>
<span class="p_add">+			     &amp;per_cpu(cpu_tss_rw, cpu),</span>
<span class="p_add">+			     sizeof(struct tss_struct) / PAGE_SIZE, tss_prot);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	per_cpu(cpu_entry_area, cpu) = get_cpu_entry_area(cpu);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(exception_stacks) % PAGE_SIZE != 0);</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(exception_stacks) !=</span>
<span class="p_add">+		     sizeof(((struct cpu_entry_area *)0)-&gt;exception_stacks));</span>
<span class="p_add">+	cea_map_percpu_pages(&amp;get_cpu_entry_area(cpu)-&gt;exception_stacks,</span>
<span class="p_add">+			     &amp;per_cpu(exception_stacks, cpu),</span>
<span class="p_add">+			     sizeof(exception_stacks) / PAGE_SIZE, PAGE_KERNEL);</span>
<span class="p_add">+</span>
<span class="p_add">+	cea_set_pte(&amp;get_cpu_entry_area(cpu)-&gt;entry_trampoline,</span>
<span class="p_add">+		     __pa_symbol(_entry_trampoline), PAGE_KERNEL_RX);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static __init void setup_cpu_entry_area_ptes(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	unsigned long start, end;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUILD_BUG_ON(CPU_ENTRY_AREA_PAGES * PAGE_SIZE &lt; CPU_ENTRY_AREA_MAP_SIZE);</span>
<span class="p_add">+	BUG_ON(CPU_ENTRY_AREA_BASE &amp; ~PMD_MASK);</span>
<span class="p_add">+</span>
<span class="p_add">+	start = CPU_ENTRY_AREA_BASE;</span>
<span class="p_add">+	end = start + CPU_ENTRY_AREA_MAP_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Careful here: start + PMD_SIZE might wrap around */</span>
<span class="p_add">+	for (; start &lt; end &amp;&amp; start &gt;= CPU_ENTRY_AREA_BASE; start += PMD_SIZE)</span>
<span class="p_add">+		populate_extra_pte(start);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init setup_cpu_entry_areas(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	setup_cpu_entry_area_ptes();</span>
<span class="p_add">+</span>
<span class="p_add">+	for_each_possible_cpu(cpu)</span>
<span class="p_add">+		setup_cpu_entry_area(cpu);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/x86/mm/dump_pagetables.c b/arch/x86/mm/dump_pagetables.c</span>
<span class="p_header">index 5e3ac6fe6c9e..43dedbfb7257 100644</span>
<span class="p_header">--- a/arch/x86/mm/dump_pagetables.c</span>
<span class="p_header">+++ b/arch/x86/mm/dump_pagetables.c</span>
<span class="p_chunk">@@ -44,10 +44,12 @@</span> <span class="p_context"> struct addr_marker {</span>
 	unsigned long max_lines;
 };
 
<span class="p_del">-/* indices for address_markers; keep sync&#39;d w/ address_markers below */</span>
<span class="p_add">+/* Address space markers hints */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+</span>
 enum address_markers_idx {
 	USER_SPACE_NR = 0,
<span class="p_del">-#ifdef CONFIG_X86_64</span>
 	KERNEL_SPACE_NR,
 	LOW_KERNEL_NR,
 	VMALLOC_START_NR,
<span class="p_chunk">@@ -56,56 +58,74 @@</span> <span class="p_context"> enum address_markers_idx {</span>
 	KASAN_SHADOW_START_NR,
 	KASAN_SHADOW_END_NR,
 #endif
<span class="p_del">-# ifdef CONFIG_X86_ESPFIX64</span>
<span class="p_add">+	CPU_ENTRY_AREA_NR,</span>
<span class="p_add">+#ifdef CONFIG_X86_ESPFIX64</span>
 	ESPFIX_START_NR,
<span class="p_del">-# endif</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifdef CONFIG_EFI</span>
<span class="p_add">+	EFI_END_NR,</span>
<span class="p_add">+#endif</span>
 	HIGH_KERNEL_NR,
 	MODULES_VADDR_NR,
 	MODULES_END_NR,
<span class="p_del">-#else</span>
<span class="p_add">+	FIXADDR_START_NR,</span>
<span class="p_add">+	END_OF_SPACE_NR,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct addr_marker address_markers[] = {</span>
<span class="p_add">+	[USER_SPACE_NR]		= { 0,			&quot;User Space&quot; },</span>
<span class="p_add">+	[KERNEL_SPACE_NR]	= { (1UL &lt;&lt; 63),	&quot;Kernel Space&quot; },</span>
<span class="p_add">+	[LOW_KERNEL_NR]		= { 0UL,		&quot;Low Kernel Mapping&quot; },</span>
<span class="p_add">+	[VMALLOC_START_NR]	= { 0UL,		&quot;vmalloc() Area&quot; },</span>
<span class="p_add">+	[VMEMMAP_START_NR]	= { 0UL,		&quot;Vmemmap&quot; },</span>
<span class="p_add">+#ifdef CONFIG_KASAN</span>
<span class="p_add">+	[KASAN_SHADOW_START_NR]	= { KASAN_SHADOW_START,	&quot;KASAN shadow&quot; },</span>
<span class="p_add">+	[KASAN_SHADOW_END_NR]	= { KASAN_SHADOW_END,	&quot;KASAN shadow end&quot; },</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	[CPU_ENTRY_AREA_NR]	= { CPU_ENTRY_AREA_BASE,&quot;CPU entry Area&quot; },</span>
<span class="p_add">+#ifdef CONFIG_X86_ESPFIX64</span>
<span class="p_add">+	[ESPFIX_START_NR]	= { ESPFIX_BASE_ADDR,	&quot;ESPfix Area&quot;, 16 },</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifdef CONFIG_EFI</span>
<span class="p_add">+	[EFI_END_NR]		= { EFI_VA_END,		&quot;EFI Runtime Services&quot; },</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	[HIGH_KERNEL_NR]	= { __START_KERNEL_map,	&quot;High Kernel Mapping&quot; },</span>
<span class="p_add">+	[MODULES_VADDR_NR]	= { MODULES_VADDR,	&quot;Modules&quot; },</span>
<span class="p_add">+	[MODULES_END_NR]	= { MODULES_END,	&quot;End Modules&quot; },</span>
<span class="p_add">+	[FIXADDR_START_NR]	= { FIXADDR_START,	&quot;Fixmap Area&quot; },</span>
<span class="p_add">+	[END_OF_SPACE_NR]	= { -1,			NULL }</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#else /* CONFIG_X86_64 */</span>
<span class="p_add">+</span>
<span class="p_add">+enum address_markers_idx {</span>
<span class="p_add">+	USER_SPACE_NR = 0,</span>
 	KERNEL_SPACE_NR,
 	VMALLOC_START_NR,
 	VMALLOC_END_NR,
<span class="p_del">-# ifdef CONFIG_HIGHMEM</span>
<span class="p_add">+#ifdef CONFIG_HIGHMEM</span>
 	PKMAP_BASE_NR,
<span class="p_del">-# endif</span>
<span class="p_del">-	FIXADDR_START_NR,</span>
 #endif
<span class="p_add">+	CPU_ENTRY_AREA_NR,</span>
<span class="p_add">+	FIXADDR_START_NR,</span>
<span class="p_add">+	END_OF_SPACE_NR,</span>
 };
 
<span class="p_del">-/* Address space markers hints */</span>
 static struct addr_marker address_markers[] = {
<span class="p_del">-	{ 0, &quot;User Space&quot; },</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	{ 0x8000000000000000UL, &quot;Kernel Space&quot; },</span>
<span class="p_del">-	{ 0/* PAGE_OFFSET */,   &quot;Low Kernel Mapping&quot; },</span>
<span class="p_del">-	{ 0/* VMALLOC_START */, &quot;vmalloc() Area&quot; },</span>
<span class="p_del">-	{ 0/* VMEMMAP_START */, &quot;Vmemmap&quot; },</span>
<span class="p_del">-#ifdef CONFIG_KASAN</span>
<span class="p_del">-	{ KASAN_SHADOW_START,	&quot;KASAN shadow&quot; },</span>
<span class="p_del">-	{ KASAN_SHADOW_END,	&quot;KASAN shadow end&quot; },</span>
<span class="p_add">+	[USER_SPACE_NR]		= { 0,			&quot;User Space&quot; },</span>
<span class="p_add">+	[KERNEL_SPACE_NR]	= { PAGE_OFFSET,	&quot;Kernel Mapping&quot; },</span>
<span class="p_add">+	[VMALLOC_START_NR]	= { 0UL,		&quot;vmalloc() Area&quot; },</span>
<span class="p_add">+	[VMALLOC_END_NR]	= { 0UL,		&quot;vmalloc() End&quot; },</span>
<span class="p_add">+#ifdef CONFIG_HIGHMEM</span>
<span class="p_add">+	[PKMAP_BASE_NR]		= { 0UL,		&quot;Persistent kmap() Area&quot; },</span>
 #endif
<span class="p_del">-# ifdef CONFIG_X86_ESPFIX64</span>
<span class="p_del">-	{ ESPFIX_BASE_ADDR,	&quot;ESPfix Area&quot;, 16 },</span>
<span class="p_del">-# endif</span>
<span class="p_del">-# ifdef CONFIG_EFI</span>
<span class="p_del">-	{ EFI_VA_END,		&quot;EFI Runtime Services&quot; },</span>
<span class="p_del">-# endif</span>
<span class="p_del">-	{ __START_KERNEL_map,   &quot;High Kernel Mapping&quot; },</span>
<span class="p_del">-	{ MODULES_VADDR,        &quot;Modules&quot; },</span>
<span class="p_del">-	{ MODULES_END,          &quot;End Modules&quot; },</span>
<span class="p_del">-#else</span>
<span class="p_del">-	{ PAGE_OFFSET,          &quot;Kernel Mapping&quot; },</span>
<span class="p_del">-	{ 0/* VMALLOC_START */, &quot;vmalloc() Area&quot; },</span>
<span class="p_del">-	{ 0/*VMALLOC_END*/,     &quot;vmalloc() End&quot; },</span>
<span class="p_del">-# ifdef CONFIG_HIGHMEM</span>
<span class="p_del">-	{ 0/*PKMAP_BASE*/,      &quot;Persistent kmap() Area&quot; },</span>
<span class="p_del">-# endif</span>
<span class="p_del">-	{ 0/*FIXADDR_START*/,   &quot;Fixmap Area&quot; },</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	{ -1, NULL }		/* End of list */</span>
<span class="p_add">+	[CPU_ENTRY_AREA_NR]	= { 0UL,		&quot;CPU entry area&quot; },</span>
<span class="p_add">+	[FIXADDR_START_NR]	= { 0UL,		&quot;Fixmap area&quot; },</span>
<span class="p_add">+	[END_OF_SPACE_NR]	= { -1,			NULL }</span>
 };
 
<span class="p_add">+#endif /* !CONFIG_X86_64 */</span>
<span class="p_add">+</span>
 /* Multipliers for offsets within the PTEs */
 #define PTE_LEVEL_MULT (PAGE_SIZE)
 #define PMD_LEVEL_MULT (PTRS_PER_PTE * PTE_LEVEL_MULT)
<span class="p_chunk">@@ -140,7 +160,7 @@</span> <span class="p_context"> static void printk_prot(struct seq_file *m, pgprot_t prot, int level, bool dmsg)</span>
 	static const char * const level_name[] =
 		{ &quot;cr3&quot;, &quot;pgd&quot;, &quot;p4d&quot;, &quot;pud&quot;, &quot;pmd&quot;, &quot;pte&quot; };
 
<span class="p_del">-	if (!pgprot_val(prot)) {</span>
<span class="p_add">+	if (!(pr &amp; _PAGE_PRESENT)) {</span>
 		/* Not present */
 		pt_dump_cont_printf(m, dmsg, &quot;                              &quot;);
 	} else {
<span class="p_chunk">@@ -525,8 +545,8 @@</span> <span class="p_context"> static int __init pt_dump_init(void)</span>
 	address_markers[PKMAP_BASE_NR].start_address = PKMAP_BASE;
 # endif
 	address_markers[FIXADDR_START_NR].start_address = FIXADDR_START;
<span class="p_add">+	address_markers[CPU_ENTRY_AREA_NR].start_address = CPU_ENTRY_AREA_BASE;</span>
 #endif
<span class="p_del">-</span>
 	return 0;
 }
 __initcall(pt_dump_init);
<span class="p_header">diff --git a/arch/x86/mm/init_32.c b/arch/x86/mm/init_32.c</span>
<span class="p_header">index 8a64a6f2848d..135c9a7898c7 100644</span>
<span class="p_header">--- a/arch/x86/mm/init_32.c</span>
<span class="p_header">+++ b/arch/x86/mm/init_32.c</span>
<span class="p_chunk">@@ -50,6 +50,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/setup.h&gt;
 #include &lt;asm/set_memory.h&gt;
 #include &lt;asm/page_types.h&gt;
<span class="p_add">+#include &lt;asm/cpu_entry_area.h&gt;</span>
 #include &lt;asm/init.h&gt;
 
 #include &quot;mm_internal.h&quot;
<span class="p_chunk">@@ -766,6 +767,7 @@</span> <span class="p_context"> void __init mem_init(void)</span>
 	mem_init_print_info(NULL);
 	printk(KERN_INFO &quot;virtual kernel memory layout:\n&quot;
 		&quot;    fixmap  : 0x%08lx - 0x%08lx   (%4ld kB)\n&quot;
<span class="p_add">+		&quot;  cpu_entry : 0x%08lx - 0x%08lx   (%4ld kB)\n&quot;</span>
 #ifdef CONFIG_HIGHMEM
 		&quot;    pkmap   : 0x%08lx - 0x%08lx   (%4ld kB)\n&quot;
 #endif
<span class="p_chunk">@@ -777,6 +779,10 @@</span> <span class="p_context"> void __init mem_init(void)</span>
 		FIXADDR_START, FIXADDR_TOP,
 		(FIXADDR_TOP - FIXADDR_START) &gt;&gt; 10,
 
<span class="p_add">+		CPU_ENTRY_AREA_BASE,</span>
<span class="p_add">+		CPU_ENTRY_AREA_BASE + CPU_ENTRY_AREA_MAP_SIZE,</span>
<span class="p_add">+		CPU_ENTRY_AREA_MAP_SIZE &gt;&gt; 10,</span>
<span class="p_add">+</span>
 #ifdef CONFIG_HIGHMEM
 		PKMAP_BASE, PKMAP_BASE+LAST_PKMAP*PAGE_SIZE,
 		(LAST_PKMAP*PAGE_SIZE) &gt;&gt; 10,
<span class="p_header">diff --git a/arch/x86/mm/kasan_init_64.c b/arch/x86/mm/kasan_init_64.c</span>
<span class="p_header">index 9ec70d780f1f..47388f0c0e59 100644</span>
<span class="p_header">--- a/arch/x86/mm/kasan_init_64.c</span>
<span class="p_header">+++ b/arch/x86/mm/kasan_init_64.c</span>
<span class="p_chunk">@@ -15,6 +15,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/tlbflush.h&gt;
 #include &lt;asm/sections.h&gt;
 #include &lt;asm/pgtable.h&gt;
<span class="p_add">+#include &lt;asm/cpu_entry_area.h&gt;</span>
 
 extern struct range pfn_mapped[E820_MAX_ENTRIES];
 
<span class="p_chunk">@@ -322,31 +323,33 @@</span> <span class="p_context"> void __init kasan_init(void)</span>
 		map_range(&amp;pfn_mapped[i]);
 	}
 
<span class="p_del">-	kasan_populate_zero_shadow(</span>
<span class="p_del">-		kasan_mem_to_shadow((void *)PAGE_OFFSET + MAXMEM),</span>
<span class="p_del">-		kasan_mem_to_shadow((void *)__START_KERNEL_map));</span>
<span class="p_del">-</span>
<span class="p_del">-	kasan_populate_shadow((unsigned long)kasan_mem_to_shadow(_stext),</span>
<span class="p_del">-			      (unsigned long)kasan_mem_to_shadow(_end),</span>
<span class="p_del">-			      early_pfn_to_nid(__pa(_stext)));</span>
<span class="p_del">-</span>
<span class="p_del">-	shadow_cpu_entry_begin = (void *)__fix_to_virt(FIX_CPU_ENTRY_AREA_BOTTOM);</span>
<span class="p_add">+	shadow_cpu_entry_begin = (void *)CPU_ENTRY_AREA_BASE;</span>
 	shadow_cpu_entry_begin = kasan_mem_to_shadow(shadow_cpu_entry_begin);
 	shadow_cpu_entry_begin = (void *)round_down((unsigned long)shadow_cpu_entry_begin,
 						PAGE_SIZE);
 
<span class="p_del">-	shadow_cpu_entry_end = (void *)(__fix_to_virt(FIX_CPU_ENTRY_AREA_TOP) + PAGE_SIZE);</span>
<span class="p_add">+	shadow_cpu_entry_end = (void *)(CPU_ENTRY_AREA_BASE +</span>
<span class="p_add">+					CPU_ENTRY_AREA_MAP_SIZE);</span>
 	shadow_cpu_entry_end = kasan_mem_to_shadow(shadow_cpu_entry_end);
 	shadow_cpu_entry_end = (void *)round_up((unsigned long)shadow_cpu_entry_end,
 					PAGE_SIZE);
 
<span class="p_del">-	kasan_populate_zero_shadow(kasan_mem_to_shadow((void *)MODULES_END),</span>
<span class="p_del">-				   shadow_cpu_entry_begin);</span>
<span class="p_add">+	kasan_populate_zero_shadow(</span>
<span class="p_add">+		kasan_mem_to_shadow((void *)PAGE_OFFSET + MAXMEM),</span>
<span class="p_add">+		shadow_cpu_entry_begin);</span>
 
 	kasan_populate_shadow((unsigned long)shadow_cpu_entry_begin,
 			      (unsigned long)shadow_cpu_entry_end, 0);
 
<span class="p_del">-	kasan_populate_zero_shadow(shadow_cpu_entry_end, (void *)KASAN_SHADOW_END);</span>
<span class="p_add">+	kasan_populate_zero_shadow(shadow_cpu_entry_end,</span>
<span class="p_add">+				kasan_mem_to_shadow((void *)__START_KERNEL_map));</span>
<span class="p_add">+</span>
<span class="p_add">+	kasan_populate_shadow((unsigned long)kasan_mem_to_shadow(_stext),</span>
<span class="p_add">+			      (unsigned long)kasan_mem_to_shadow(_end),</span>
<span class="p_add">+			      early_pfn_to_nid(__pa(_stext)));</span>
<span class="p_add">+</span>
<span class="p_add">+	kasan_populate_zero_shadow(kasan_mem_to_shadow((void *)MODULES_END),</span>
<span class="p_add">+				(void *)KASAN_SHADOW_END);</span>
 
 	load_cr3(init_top_pgt);
 	__flush_tlb_all();
<span class="p_header">diff --git a/arch/x86/mm/pgtable_32.c b/arch/x86/mm/pgtable_32.c</span>
<span class="p_header">index 6b9bf023a700..c3c5274410a9 100644</span>
<span class="p_header">--- a/arch/x86/mm/pgtable_32.c</span>
<span class="p_header">+++ b/arch/x86/mm/pgtable_32.c</span>
<span class="p_chunk">@@ -10,6 +10,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/pagemap.h&gt;
 #include &lt;linux/spinlock.h&gt;
 
<span class="p_add">+#include &lt;asm/cpu_entry_area.h&gt;</span>
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/pgalloc.h&gt;
 #include &lt;asm/fixmap.h&gt;
<span class="p_header">diff --git a/arch/x86/mm/tlb.c b/arch/x86/mm/tlb.c</span>
<span class="p_header">index 3118392cdf75..0a1be3adc97e 100644</span>
<span class="p_header">--- a/arch/x86/mm/tlb.c</span>
<span class="p_header">+++ b/arch/x86/mm/tlb.c</span>
<span class="p_chunk">@@ -128,7 +128,7 @@</span> <span class="p_context"> void switch_mm_irqs_off(struct mm_struct *prev, struct mm_struct *next,</span>
 	 * isn&#39;t free.
 	 */
 #ifdef CONFIG_DEBUG_VM
<span class="p_del">-	if (WARN_ON_ONCE(__read_cr3() != build_cr3(real_prev, prev_asid))) {</span>
<span class="p_add">+	if (WARN_ON_ONCE(__read_cr3() != build_cr3(real_prev-&gt;pgd, prev_asid))) {</span>
 		/*
 		 * If we were to BUG here, we&#39;d be very likely to kill
 		 * the system so hard that we don&#39;t see the call trace.
<span class="p_chunk">@@ -195,7 +195,7 @@</span> <span class="p_context"> void switch_mm_irqs_off(struct mm_struct *prev, struct mm_struct *next,</span>
 		if (need_flush) {
 			this_cpu_write(cpu_tlbstate.ctxs[new_asid].ctx_id, next-&gt;context.ctx_id);
 			this_cpu_write(cpu_tlbstate.ctxs[new_asid].tlb_gen, next_tlb_gen);
<span class="p_del">-			write_cr3(build_cr3(next, new_asid));</span>
<span class="p_add">+			write_cr3(build_cr3(next-&gt;pgd, new_asid));</span>
 
 			/*
 			 * NB: This gets called via leave_mm() in the idle path
<span class="p_chunk">@@ -208,7 +208,7 @@</span> <span class="p_context"> void switch_mm_irqs_off(struct mm_struct *prev, struct mm_struct *next,</span>
 			trace_tlb_flush_rcuidle(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);
 		} else {
 			/* The new ASID is already up to date. */
<span class="p_del">-			write_cr3(build_cr3_noflush(next, new_asid));</span>
<span class="p_add">+			write_cr3(build_cr3_noflush(next-&gt;pgd, new_asid));</span>
 
 			/* See above wrt _rcuidle. */
 			trace_tlb_flush_rcuidle(TLB_FLUSH_ON_TASK_SWITCH, 0);
<span class="p_chunk">@@ -288,7 +288,7 @@</span> <span class="p_context"> void initialize_tlbstate_and_flush(void)</span>
 		!(cr4_read_shadow() &amp; X86_CR4_PCIDE));
 
 	/* Force ASID 0 and force a TLB flush. */
<span class="p_del">-	write_cr3(build_cr3(mm, 0));</span>
<span class="p_add">+	write_cr3(build_cr3(mm-&gt;pgd, 0));</span>
 
 	/* Reinitialize tlbstate. */
 	this_cpu_write(cpu_tlbstate.loaded_mm_asid, 0);
<span class="p_chunk">@@ -551,7 +551,7 @@</span> <span class="p_context"> static void do_kernel_range_flush(void *info)</span>
 
 	/* flush range by one by one &#39;invlpg&#39; */
 	for (addr = f-&gt;start; addr &lt; f-&gt;end; addr += PAGE_SIZE)
<span class="p_del">-		__flush_tlb_single(addr);</span>
<span class="p_add">+		__flush_tlb_one(addr);</span>
 }
 
 void flush_tlb_kernel_range(unsigned long start, unsigned long end)
<span class="p_header">diff --git a/arch/x86/platform/uv/tlb_uv.c b/arch/x86/platform/uv/tlb_uv.c</span>
<span class="p_header">index f44c0bc95aa2..8538a6723171 100644</span>
<span class="p_header">--- a/arch/x86/platform/uv/tlb_uv.c</span>
<span class="p_header">+++ b/arch/x86/platform/uv/tlb_uv.c</span>
<span class="p_chunk">@@ -299,7 +299,7 @@</span> <span class="p_context"> static void bau_process_message(struct msg_desc *mdp, struct bau_control *bcp,</span>
 		local_flush_tlb();
 		stat-&gt;d_alltlb++;
 	} else {
<span class="p_del">-		__flush_tlb_one(msg-&gt;address);</span>
<span class="p_add">+		__flush_tlb_single(msg-&gt;address);</span>
 		stat-&gt;d_onetlb++;
 	}
 	stat-&gt;d_requestee++;
<span class="p_header">diff --git a/arch/x86/xen/mmu_pv.c b/arch/x86/xen/mmu_pv.c</span>
<span class="p_header">index c2454237fa67..a0e2b8c6e5c7 100644</span>
<span class="p_header">--- a/arch/x86/xen/mmu_pv.c</span>
<span class="p_header">+++ b/arch/x86/xen/mmu_pv.c</span>
<span class="p_chunk">@@ -2261,7 +2261,6 @@</span> <span class="p_context"> static void xen_set_fixmap(unsigned idx, phys_addr_t phys, pgprot_t prot)</span>
 
 	switch (idx) {
 	case FIX_BTMAP_END ... FIX_BTMAP_BEGIN:
<span class="p_del">-	case FIX_RO_IDT:</span>
 #ifdef CONFIG_X86_32
 	case FIX_WP_TEST:
 # ifdef CONFIG_HIGHMEM
<span class="p_chunk">@@ -2272,7 +2271,6 @@</span> <span class="p_context"> static void xen_set_fixmap(unsigned idx, phys_addr_t phys, pgprot_t prot)</span>
 #endif
 	case FIX_TEXT_POKE0:
 	case FIX_TEXT_POKE1:
<span class="p_del">-	case FIX_CPU_ENTRY_AREA_TOP ... FIX_CPU_ENTRY_AREA_BOTTOM:</span>
 		/* All local page mappings */
 		pte = pfn_pte(phys, prot);
 		break;
<span class="p_header">diff --git a/block/bio.c b/block/bio.c</span>
<span class="p_header">index 33fa6b4af312..7f978eac9a7a 100644</span>
<span class="p_header">--- a/block/bio.c</span>
<span class="p_header">+++ b/block/bio.c</span>
<span class="p_chunk">@@ -599,6 +599,8 @@</span> <span class="p_context"> void __bio_clone_fast(struct bio *bio, struct bio *bio_src)</span>
 	bio-&gt;bi_disk = bio_src-&gt;bi_disk;
 	bio-&gt;bi_partno = bio_src-&gt;bi_partno;
 	bio_set_flag(bio, BIO_CLONED);
<span class="p_add">+	if (bio_flagged(bio_src, BIO_THROTTLED))</span>
<span class="p_add">+		bio_set_flag(bio, BIO_THROTTLED);</span>
 	bio-&gt;bi_opf = bio_src-&gt;bi_opf;
 	bio-&gt;bi_write_hint = bio_src-&gt;bi_write_hint;
 	bio-&gt;bi_iter = bio_src-&gt;bi_iter;
<span class="p_header">diff --git a/block/blk-throttle.c b/block/blk-throttle.c</span>
<span class="p_header">index 8631763866c6..a8cd7b3d9647 100644</span>
<span class="p_header">--- a/block/blk-throttle.c</span>
<span class="p_header">+++ b/block/blk-throttle.c</span>
<span class="p_chunk">@@ -2223,13 +2223,7 @@</span> <span class="p_context"> bool blk_throtl_bio(struct request_queue *q, struct blkcg_gq *blkg,</span>
 out_unlock:
 	spin_unlock_irq(q-&gt;queue_lock);
 out:
<span class="p_del">-	/*</span>
<span class="p_del">-	 * As multiple blk-throtls may stack in the same issue path, we</span>
<span class="p_del">-	 * don&#39;t want bios to leave with the flag set.  Clear the flag if</span>
<span class="p_del">-	 * being issued.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!throttled)</span>
<span class="p_del">-		bio_clear_flag(bio, BIO_THROTTLED);</span>
<span class="p_add">+	bio_set_flag(bio, BIO_THROTTLED);</span>
 
 #ifdef CONFIG_BLK_DEV_THROTTLING_LOW
 	if (throttled || !td-&gt;track_bio_latency)
<span class="p_header">diff --git a/crypto/af_alg.c b/crypto/af_alg.c</span>
<span class="p_header">index e181073ef64d..6ec360213107 100644</span>
<span class="p_header">--- a/crypto/af_alg.c</span>
<span class="p_header">+++ b/crypto/af_alg.c</span>
<span class="p_chunk">@@ -1165,12 +1165,6 @@</span> <span class="p_context"> int af_alg_get_rsgl(struct sock *sk, struct msghdr *msg, int flags,</span>
 		if (!af_alg_readable(sk))
 			break;
 
<span class="p_del">-		if (!ctx-&gt;used) {</span>
<span class="p_del">-			err = af_alg_wait_for_data(sk, flags);</span>
<span class="p_del">-			if (err)</span>
<span class="p_del">-				return err;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
 		seglen = min_t(size_t, (maxsize - len),
 			       msg_data_left(msg));
 
<span class="p_header">diff --git a/crypto/algif_aead.c b/crypto/algif_aead.c</span>
<span class="p_header">index 3d793bc2aa82..782cb8fec323 100644</span>
<span class="p_header">--- a/crypto/algif_aead.c</span>
<span class="p_header">+++ b/crypto/algif_aead.c</span>
<span class="p_chunk">@@ -111,6 +111,12 @@</span> <span class="p_context"> static int _aead_recvmsg(struct socket *sock, struct msghdr *msg,</span>
 	size_t usedpages = 0;		/* [in]  RX bufs to be used from user */
 	size_t processed = 0;		/* [in]  TX bufs to be consumed */
 
<span class="p_add">+	if (!ctx-&gt;used) {</span>
<span class="p_add">+		err = af_alg_wait_for_data(sk, flags);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * Data length provided by caller via sendmsg/sendpage that has not
 	 * yet been processed.
<span class="p_chunk">@@ -285,6 +291,10 @@</span> <span class="p_context"> static int _aead_recvmsg(struct socket *sock, struct msghdr *msg,</span>
 		/* AIO operation */
 		sock_hold(sk);
 		areq-&gt;iocb = msg-&gt;msg_iocb;
<span class="p_add">+</span>
<span class="p_add">+		/* Remember output size that will be generated. */</span>
<span class="p_add">+		areq-&gt;outlen = outlen;</span>
<span class="p_add">+</span>
 		aead_request_set_callback(&amp;areq-&gt;cra_u.aead_req,
 					  CRYPTO_TFM_REQ_MAY_BACKLOG,
 					  af_alg_async_cb, areq);
<span class="p_chunk">@@ -292,12 +302,8 @@</span> <span class="p_context"> static int _aead_recvmsg(struct socket *sock, struct msghdr *msg,</span>
 				 crypto_aead_decrypt(&amp;areq-&gt;cra_u.aead_req);
 
 		/* AIO operation in progress */
<span class="p_del">-		if (err == -EINPROGRESS || err == -EBUSY) {</span>
<span class="p_del">-			/* Remember output size that will be generated. */</span>
<span class="p_del">-			areq-&gt;outlen = outlen;</span>
<span class="p_del">-</span>
<span class="p_add">+		if (err == -EINPROGRESS || err == -EBUSY)</span>
 			return -EIOCBQUEUED;
<span class="p_del">-		}</span>
 
 		sock_put(sk);
 	} else {
<span class="p_header">diff --git a/crypto/algif_skcipher.c b/crypto/algif_skcipher.c</span>
<span class="p_header">index 30ee2a8e8f42..7a3e663d54d5 100644</span>
<span class="p_header">--- a/crypto/algif_skcipher.c</span>
<span class="p_header">+++ b/crypto/algif_skcipher.c</span>
<span class="p_chunk">@@ -72,6 +72,12 @@</span> <span class="p_context"> static int _skcipher_recvmsg(struct socket *sock, struct msghdr *msg,</span>
 	int err = 0;
 	size_t len = 0;
 
<span class="p_add">+	if (!ctx-&gt;used) {</span>
<span class="p_add">+		err = af_alg_wait_for_data(sk, flags);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* Allocate cipher request for current operation. */
 	areq = af_alg_alloc_areq(sk, sizeof(struct af_alg_async_req) +
 				     crypto_skcipher_reqsize(tfm));
<span class="p_chunk">@@ -119,6 +125,10 @@</span> <span class="p_context"> static int _skcipher_recvmsg(struct socket *sock, struct msghdr *msg,</span>
 		/* AIO operation */
 		sock_hold(sk);
 		areq-&gt;iocb = msg-&gt;msg_iocb;
<span class="p_add">+</span>
<span class="p_add">+		/* Remember output size that will be generated. */</span>
<span class="p_add">+		areq-&gt;outlen = len;</span>
<span class="p_add">+</span>
 		skcipher_request_set_callback(&amp;areq-&gt;cra_u.skcipher_req,
 					      CRYPTO_TFM_REQ_MAY_SLEEP,
 					      af_alg_async_cb, areq);
<span class="p_chunk">@@ -127,12 +137,8 @@</span> <span class="p_context"> static int _skcipher_recvmsg(struct socket *sock, struct msghdr *msg,</span>
 			crypto_skcipher_decrypt(&amp;areq-&gt;cra_u.skcipher_req);
 
 		/* AIO operation in progress */
<span class="p_del">-		if (err == -EINPROGRESS || err == -EBUSY) {</span>
<span class="p_del">-			/* Remember output size that will be generated. */</span>
<span class="p_del">-			areq-&gt;outlen = len;</span>
<span class="p_del">-</span>
<span class="p_add">+		if (err == -EINPROGRESS || err == -EBUSY)</span>
 			return -EIOCBQUEUED;
<span class="p_del">-		}</span>
 
 		sock_put(sk);
 	} else {
<span class="p_header">diff --git a/crypto/mcryptd.c b/crypto/mcryptd.c</span>
<span class="p_header">index 4e6472658852..eca04d3729b3 100644</span>
<span class="p_header">--- a/crypto/mcryptd.c</span>
<span class="p_header">+++ b/crypto/mcryptd.c</span>
<span class="p_chunk">@@ -81,6 +81,7 @@</span> <span class="p_context"> static int mcryptd_init_queue(struct mcryptd_queue *queue,</span>
 		pr_debug(&quot;cpu_queue #%d %p\n&quot;, cpu, queue-&gt;cpu_queue);
 		crypto_init_queue(&amp;cpu_queue-&gt;queue, max_cpu_qlen);
 		INIT_WORK(&amp;cpu_queue-&gt;work, mcryptd_queue_worker);
<span class="p_add">+		spin_lock_init(&amp;cpu_queue-&gt;q_lock);</span>
 	}
 	return 0;
 }
<span class="p_chunk">@@ -104,15 +105,16 @@</span> <span class="p_context"> static int mcryptd_enqueue_request(struct mcryptd_queue *queue,</span>
 	int cpu, err;
 	struct mcryptd_cpu_queue *cpu_queue;
 
<span class="p_del">-	cpu = get_cpu();</span>
<span class="p_del">-	cpu_queue = this_cpu_ptr(queue-&gt;cpu_queue);</span>
<span class="p_del">-	rctx-&gt;tag.cpu = cpu;</span>
<span class="p_add">+	cpu_queue = raw_cpu_ptr(queue-&gt;cpu_queue);</span>
<span class="p_add">+	spin_lock(&amp;cpu_queue-&gt;q_lock);</span>
<span class="p_add">+	cpu = smp_processor_id();</span>
<span class="p_add">+	rctx-&gt;tag.cpu = smp_processor_id();</span>
 
 	err = crypto_enqueue_request(&amp;cpu_queue-&gt;queue, request);
 	pr_debug(&quot;enqueue request: cpu %d cpu_queue %p request %p\n&quot;,
 		 cpu, cpu_queue, request);
<span class="p_add">+	spin_unlock(&amp;cpu_queue-&gt;q_lock);</span>
 	queue_work_on(cpu, kcrypto_wq, &amp;cpu_queue-&gt;work);
<span class="p_del">-	put_cpu();</span>
 
 	return err;
 }
<span class="p_chunk">@@ -161,16 +163,11 @@</span> <span class="p_context"> static void mcryptd_queue_worker(struct work_struct *work)</span>
 	cpu_queue = container_of(work, struct mcryptd_cpu_queue, work);
 	i = 0;
 	while (i &lt; MCRYPTD_BATCH || single_task_running()) {
<span class="p_del">-		/*</span>
<span class="p_del">-		 * preempt_disable/enable is used to prevent</span>
<span class="p_del">-		 * being preempted by mcryptd_enqueue_request()</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		local_bh_disable();</span>
<span class="p_del">-		preempt_disable();</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock_bh(&amp;cpu_queue-&gt;q_lock);</span>
 		backlog = crypto_get_backlog(&amp;cpu_queue-&gt;queue);
 		req = crypto_dequeue_request(&amp;cpu_queue-&gt;queue);
<span class="p_del">-		preempt_enable();</span>
<span class="p_del">-		local_bh_enable();</span>
<span class="p_add">+		spin_unlock_bh(&amp;cpu_queue-&gt;q_lock);</span>
 
 		if (!req) {
 			mcryptd_opportunistic_flush();
<span class="p_chunk">@@ -185,7 +182,7 @@</span> <span class="p_context"> static void mcryptd_queue_worker(struct work_struct *work)</span>
 		++i;
 	}
 	if (cpu_queue-&gt;queue.qlen)
<span class="p_del">-		queue_work(kcrypto_wq, &amp;cpu_queue-&gt;work);</span>
<span class="p_add">+		queue_work_on(smp_processor_id(), kcrypto_wq, &amp;cpu_queue-&gt;work);</span>
 }
 
 void mcryptd_flusher(struct work_struct *__work)
<span class="p_header">diff --git a/crypto/skcipher.c b/crypto/skcipher.c</span>
<span class="p_header">index 778e0ff42bfa..11af5fd6a443 100644</span>
<span class="p_header">--- a/crypto/skcipher.c</span>
<span class="p_header">+++ b/crypto/skcipher.c</span>
<span class="p_chunk">@@ -449,6 +449,8 @@</span> <span class="p_context"> static int skcipher_walk_skcipher(struct skcipher_walk *walk,</span>
 
 	walk-&gt;total = req-&gt;cryptlen;
 	walk-&gt;nbytes = 0;
<span class="p_add">+	walk-&gt;iv = req-&gt;iv;</span>
<span class="p_add">+	walk-&gt;oiv = req-&gt;iv;</span>
 
 	if (unlikely(!walk-&gt;total))
 		return 0;
<span class="p_chunk">@@ -456,9 +458,6 @@</span> <span class="p_context"> static int skcipher_walk_skcipher(struct skcipher_walk *walk,</span>
 	scatterwalk_start(&amp;walk-&gt;in, req-&gt;src);
 	scatterwalk_start(&amp;walk-&gt;out, req-&gt;dst);
 
<span class="p_del">-	walk-&gt;iv = req-&gt;iv;</span>
<span class="p_del">-	walk-&gt;oiv = req-&gt;iv;</span>
<span class="p_del">-</span>
 	walk-&gt;flags &amp;= ~SKCIPHER_WALK_SLEEP;
 	walk-&gt;flags |= req-&gt;base.flags &amp; CRYPTO_TFM_REQ_MAY_SLEEP ?
 		       SKCIPHER_WALK_SLEEP : 0;
<span class="p_chunk">@@ -510,6 +509,8 @@</span> <span class="p_context"> static int skcipher_walk_aead_common(struct skcipher_walk *walk,</span>
 	int err;
 
 	walk-&gt;nbytes = 0;
<span class="p_add">+	walk-&gt;iv = req-&gt;iv;</span>
<span class="p_add">+	walk-&gt;oiv = req-&gt;iv;</span>
 
 	if (unlikely(!walk-&gt;total))
 		return 0;
<span class="p_chunk">@@ -525,9 +526,6 @@</span> <span class="p_context"> static int skcipher_walk_aead_common(struct skcipher_walk *walk,</span>
 	scatterwalk_done(&amp;walk-&gt;in, 0, walk-&gt;total);
 	scatterwalk_done(&amp;walk-&gt;out, 0, walk-&gt;total);
 
<span class="p_del">-	walk-&gt;iv = req-&gt;iv;</span>
<span class="p_del">-	walk-&gt;oiv = req-&gt;iv;</span>
<span class="p_del">-</span>
 	if (req-&gt;base.flags &amp; CRYPTO_TFM_REQ_MAY_SLEEP)
 		walk-&gt;flags |= SKCIPHER_WALK_SLEEP;
 	else
<span class="p_header">diff --git a/drivers/acpi/apei/erst.c b/drivers/acpi/apei/erst.c</span>
<span class="p_header">index 2c462beee551..a943cf17faa7 100644</span>
<span class="p_header">--- a/drivers/acpi/apei/erst.c</span>
<span class="p_header">+++ b/drivers/acpi/apei/erst.c</span>
<span class="p_chunk">@@ -1007,7 +1007,7 @@</span> <span class="p_context"> static ssize_t erst_reader(struct pstore_record *record)</span>
 	/* The record may be cleared by others, try read next record */
 	if (len == -ENOENT)
 		goto skip;
<span class="p_del">-	else if (len &lt; sizeof(*rcd)) {</span>
<span class="p_add">+	else if (len &lt; 0 || len &lt; sizeof(*rcd)) {</span>
 		rc = -EIO;
 		goto out;
 	}
<span class="p_header">diff --git a/drivers/acpi/nfit/core.c b/drivers/acpi/nfit/core.c</span>
<span class="p_header">index 9c2c49b6a240..dea0fb3d6f64 100644</span>
<span class="p_header">--- a/drivers/acpi/nfit/core.c</span>
<span class="p_header">+++ b/drivers/acpi/nfit/core.c</span>
<span class="p_chunk">@@ -1457,6 +1457,11 @@</span> <span class="p_context"> static int acpi_nfit_add_dimm(struct acpi_nfit_desc *acpi_desc,</span>
 				dev_name(&amp;adev_dimm-&gt;dev));
 		return -ENXIO;
 	}
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Record nfit_mem for the notification path to track back to</span>
<span class="p_add">+	 * the nfit sysfs attributes for this dimm device object.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	dev_set_drvdata(&amp;adev_dimm-&gt;dev, nfit_mem);</span>
 
 	/*
 	 * Until standardization materializes we need to consider 4
<span class="p_chunk">@@ -1516,9 +1521,11 @@</span> <span class="p_context"> static void shutdown_dimm_notify(void *data)</span>
 			sysfs_put(nfit_mem-&gt;flags_attr);
 			nfit_mem-&gt;flags_attr = NULL;
 		}
<span class="p_del">-		if (adev_dimm)</span>
<span class="p_add">+		if (adev_dimm) {</span>
 			acpi_remove_notify_handler(adev_dimm-&gt;handle,
 					ACPI_DEVICE_NOTIFY, acpi_nvdimm_notify);
<span class="p_add">+			dev_set_drvdata(&amp;adev_dimm-&gt;dev, NULL);</span>
<span class="p_add">+		}</span>
 	}
 	mutex_unlock(&amp;acpi_desc-&gt;init_mutex);
 }
<span class="p_header">diff --git a/drivers/char/ipmi/ipmi_si_intf.c b/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_header">index e1cbb78c6806..c04aa11f0e21 100644</span>
<span class="p_header">--- a/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_header">+++ b/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_chunk">@@ -3469,7 +3469,6 @@</span> <span class="p_context"> static int add_smi(struct smi_info *new_smi)</span>
 				 ipmi_addr_src_to_str(new_smi-&gt;addr_source),
 				 si_to_str[new_smi-&gt;si_type]);
 			rv = -EBUSY;
<span class="p_del">-			kfree(new_smi);</span>
 			goto out_err;
 		}
 	}
<span class="p_header">diff --git a/drivers/clk/sunxi/clk-sun9i-mmc.c b/drivers/clk/sunxi/clk-sun9i-mmc.c</span>
<span class="p_header">index 6041bdba2e97..f69f9e8c6f38 100644</span>
<span class="p_header">--- a/drivers/clk/sunxi/clk-sun9i-mmc.c</span>
<span class="p_header">+++ b/drivers/clk/sunxi/clk-sun9i-mmc.c</span>
<span class="p_chunk">@@ -16,6 +16,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/clk.h&gt;
 #include &lt;linux/clk-provider.h&gt;
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
 #include &lt;linux/init.h&gt;
 #include &lt;linux/of.h&gt;
 #include &lt;linux/of_device.h&gt;
<span class="p_chunk">@@ -83,9 +84,20 @@</span> <span class="p_context"> static int sun9i_mmc_reset_deassert(struct reset_controller_dev *rcdev,</span>
 	return 0;
 }
 
<span class="p_add">+static int sun9i_mmc_reset_reset(struct reset_controller_dev *rcdev,</span>
<span class="p_add">+				 unsigned long id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	sun9i_mmc_reset_assert(rcdev, id);</span>
<span class="p_add">+	udelay(10);</span>
<span class="p_add">+	sun9i_mmc_reset_deassert(rcdev, id);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct reset_control_ops sun9i_mmc_reset_ops = {
 	.assert		= sun9i_mmc_reset_assert,
 	.deassert	= sun9i_mmc_reset_deassert,
<span class="p_add">+	.reset		= sun9i_mmc_reset_reset,</span>
 };
 
 static int sun9i_a80_mmc_config_clk_probe(struct platform_device *pdev)
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c</span>
<span class="p_header">index dc1faa49687d..3b2c0538e48d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem.c</span>
<span class="p_chunk">@@ -325,17 +325,10 @@</span> <span class="p_context"> int i915_gem_object_unbind(struct drm_i915_gem_object *obj)</span>
 	 * must wait for all rendering to complete to the object (as unbinding
 	 * must anyway), and retire the requests.
 	 */
<span class="p_del">-	ret = i915_gem_object_wait(obj,</span>
<span class="p_del">-				   I915_WAIT_INTERRUPTIBLE |</span>
<span class="p_del">-				   I915_WAIT_LOCKED |</span>
<span class="p_del">-				   I915_WAIT_ALL,</span>
<span class="p_del">-				   MAX_SCHEDULE_TIMEOUT,</span>
<span class="p_del">-				   NULL);</span>
<span class="p_add">+	ret = i915_gem_object_set_to_cpu_domain(obj, false);</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	i915_gem_retire_requests(to_i915(obj-&gt;base.dev));</span>
<span class="p_del">-</span>
 	while ((vma = list_first_entry_or_null(&amp;obj-&gt;vma_list,
 					       struct i915_vma,
 					       obj_link))) {
<span class="p_header">diff --git a/drivers/gpu/drm/sun4i/sun4i_tcon.c b/drivers/gpu/drm/sun4i/sun4i_tcon.c</span>
<span class="p_header">index d9791292553e..7b909d814d38 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/sun4i/sun4i_tcon.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/sun4i/sun4i_tcon.c</span>
<span class="p_chunk">@@ -567,12 +567,12 @@</span> <span class="p_context"> static int sun4i_tcon_bind(struct device *dev, struct device *master,</span>
 	if (IS_ERR(tcon-&gt;crtc)) {
 		dev_err(dev, &quot;Couldn&#39;t create our CRTC\n&quot;);
 		ret = PTR_ERR(tcon-&gt;crtc);
<span class="p_del">-		goto err_free_clocks;</span>
<span class="p_add">+		goto err_free_dotclock;</span>
 	}
 
 	ret = sun4i_rgb_init(drm, tcon);
 	if (ret &lt; 0)
<span class="p_del">-		goto err_free_clocks;</span>
<span class="p_add">+		goto err_free_dotclock;</span>
 
 	list_add_tail(&amp;tcon-&gt;list, &amp;drv-&gt;tcon_list);
 
<span class="p_header">diff --git a/drivers/mfd/cros_ec_spi.c b/drivers/mfd/cros_ec_spi.c</span>
<span class="p_header">index c9714072e224..a14196e95e9b 100644</span>
<span class="p_header">--- a/drivers/mfd/cros_ec_spi.c</span>
<span class="p_header">+++ b/drivers/mfd/cros_ec_spi.c</span>
<span class="p_chunk">@@ -667,6 +667,7 @@</span> <span class="p_context"> static int cros_ec_spi_probe(struct spi_device *spi)</span>
 			   sizeof(struct ec_response_get_protocol_info);
 	ec_dev-&gt;dout_size = sizeof(struct ec_host_request);
 
<span class="p_add">+	ec_spi-&gt;last_transfer_ns = ktime_get_ns();</span>
 
 	err = cros_ec_register(ec_dev);
 	if (err) {
<span class="p_header">diff --git a/drivers/mfd/twl4030-audio.c b/drivers/mfd/twl4030-audio.c</span>
<span class="p_header">index da16bf45fab4..dc94ffc6321a 100644</span>
<span class="p_header">--- a/drivers/mfd/twl4030-audio.c</span>
<span class="p_header">+++ b/drivers/mfd/twl4030-audio.c</span>
<span class="p_chunk">@@ -159,13 +159,18 @@</span> <span class="p_context"> unsigned int twl4030_audio_get_mclk(void)</span>
 EXPORT_SYMBOL_GPL(twl4030_audio_get_mclk);
 
 static bool twl4030_audio_has_codec(struct twl4030_audio_data *pdata,
<span class="p_del">-			      struct device_node *node)</span>
<span class="p_add">+			      struct device_node *parent)</span>
 {
<span class="p_add">+	struct device_node *node;</span>
<span class="p_add">+</span>
 	if (pdata &amp;&amp; pdata-&gt;codec)
 		return true;
 
<span class="p_del">-	if (of_find_node_by_name(node, &quot;codec&quot;))</span>
<span class="p_add">+	node = of_get_child_by_name(parent, &quot;codec&quot;);</span>
<span class="p_add">+	if (node) {</span>
<span class="p_add">+		of_node_put(node);</span>
 		return true;
<span class="p_add">+	}</span>
 
 	return false;
 }
<span class="p_header">diff --git a/drivers/mfd/twl6040.c b/drivers/mfd/twl6040.c</span>
<span class="p_header">index d66502d36ba0..dd19f17a1b63 100644</span>
<span class="p_header">--- a/drivers/mfd/twl6040.c</span>
<span class="p_header">+++ b/drivers/mfd/twl6040.c</span>
<span class="p_chunk">@@ -97,12 +97,16 @@</span> <span class="p_context"> static struct reg_sequence twl6040_patch[] = {</span>
 };
 
 
<span class="p_del">-static bool twl6040_has_vibra(struct device_node *node)</span>
<span class="p_add">+static bool twl6040_has_vibra(struct device_node *parent)</span>
 {
<span class="p_del">-#ifdef CONFIG_OF</span>
<span class="p_del">-	if (of_find_node_by_name(node, &quot;vibra&quot;))</span>
<span class="p_add">+	struct device_node *node;</span>
<span class="p_add">+</span>
<span class="p_add">+	node = of_get_child_by_name(parent, &quot;vibra&quot;);</span>
<span class="p_add">+	if (node) {</span>
<span class="p_add">+		of_node_put(node);</span>
 		return true;
<span class="p_del">-#endif</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return false;
 }
 
<span class="p_header">diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">index bc93b69cfd1e..a539263cd79c 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_chunk">@@ -1214,6 +1214,10 @@</span> <span class="p_context"> static void mvneta_port_disable(struct mvneta_port *pp)</span>
 	val &amp;= ~MVNETA_GMAC0_PORT_ENABLE;
 	mvreg_write(pp, MVNETA_GMAC_CTRL_0, val);
 
<span class="p_add">+	pp-&gt;link = 0;</span>
<span class="p_add">+	pp-&gt;duplex = -1;</span>
<span class="p_add">+	pp-&gt;speed = 0;</span>
<span class="p_add">+</span>
 	udelay(200);
 }
 
<span class="p_chunk">@@ -1958,9 +1962,9 @@</span> <span class="p_context"> static int mvneta_rx_swbm(struct mvneta_port *pp, int rx_todo,</span>
 
 		if (!mvneta_rxq_desc_is_first_last(rx_status) ||
 		    (rx_status &amp; MVNETA_RXD_ERR_SUMMARY)) {
<span class="p_add">+			mvneta_rx_error(pp, rx_desc);</span>
 err_drop_frame:
 			dev-&gt;stats.rx_errors++;
<span class="p_del">-			mvneta_rx_error(pp, rx_desc);</span>
 			/* leave the descriptor untouched */
 			continue;
 		}
<span class="p_chunk">@@ -3011,7 +3015,7 @@</span> <span class="p_context"> static void mvneta_cleanup_rxqs(struct mvneta_port *pp)</span>
 {
 	int queue;
 
<span class="p_del">-	for (queue = 0; queue &lt; txq_number; queue++)</span>
<span class="p_add">+	for (queue = 0; queue &lt; rxq_number; queue++)</span>
 		mvneta_rxq_deinit(pp, &amp;pp-&gt;rxqs[queue]);
 }
 
<span class="p_header">diff --git a/drivers/nvdimm/btt.c b/drivers/nvdimm/btt.c</span>
<span class="p_header">index d5612bd1cc81..09428ebd315b 100644</span>
<span class="p_header">--- a/drivers/nvdimm/btt.c</span>
<span class="p_header">+++ b/drivers/nvdimm/btt.c</span>
<span class="p_chunk">@@ -210,12 +210,12 @@</span> <span class="p_context"> static int btt_map_read(struct arena_info *arena, u32 lba, u32 *mapping,</span>
 	return ret;
 }
 
<span class="p_del">-static int btt_log_read_pair(struct arena_info *arena, u32 lane,</span>
<span class="p_del">-			struct log_entry *ent)</span>
<span class="p_add">+static int btt_log_group_read(struct arena_info *arena, u32 lane,</span>
<span class="p_add">+			struct log_group *log)</span>
 {
 	return arena_read_bytes(arena,
<span class="p_del">-			arena-&gt;logoff + (2 * lane * LOG_ENT_SIZE), ent,</span>
<span class="p_del">-			2 * LOG_ENT_SIZE, 0);</span>
<span class="p_add">+			arena-&gt;logoff + (lane * LOG_GRP_SIZE), log,</span>
<span class="p_add">+			LOG_GRP_SIZE, 0);</span>
 }
 
 static struct dentry *debugfs_root;
<span class="p_chunk">@@ -255,6 +255,8 @@</span> <span class="p_context"> static void arena_debugfs_init(struct arena_info *a, struct dentry *parent,</span>
 	debugfs_create_x64(&quot;logoff&quot;, S_IRUGO, d, &amp;a-&gt;logoff);
 	debugfs_create_x64(&quot;info2off&quot;, S_IRUGO, d, &amp;a-&gt;info2off);
 	debugfs_create_x32(&quot;flags&quot;, S_IRUGO, d, &amp;a-&gt;flags);
<span class="p_add">+	debugfs_create_u32(&quot;log_index_0&quot;, S_IRUGO, d, &amp;a-&gt;log_index[0]);</span>
<span class="p_add">+	debugfs_create_u32(&quot;log_index_1&quot;, S_IRUGO, d, &amp;a-&gt;log_index[1]);</span>
 }
 
 static void btt_debugfs_init(struct btt *btt)
<span class="p_chunk">@@ -273,6 +275,11 @@</span> <span class="p_context"> static void btt_debugfs_init(struct btt *btt)</span>
 	}
 }
 
<span class="p_add">+static u32 log_seq(struct log_group *log, int log_idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return le32_to_cpu(log-&gt;ent[log_idx].seq);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * This function accepts two log entries, and uses the
  * sequence number to find the &#39;older&#39; entry.
<span class="p_chunk">@@ -282,8 +289,10 @@</span> <span class="p_context"> static void btt_debugfs_init(struct btt *btt)</span>
  *
  * TODO The logic feels a bit kludge-y. make it better..
  */
<span class="p_del">-static int btt_log_get_old(struct log_entry *ent)</span>
<span class="p_add">+static int btt_log_get_old(struct arena_info *a, struct log_group *log)</span>
 {
<span class="p_add">+	int idx0 = a-&gt;log_index[0];</span>
<span class="p_add">+	int idx1 = a-&gt;log_index[1];</span>
 	int old;
 
 	/*
<span class="p_chunk">@@ -291,23 +300,23 @@</span> <span class="p_context"> static int btt_log_get_old(struct log_entry *ent)</span>
 	 * the next time, the following logic works out to put this
 	 * (next) entry into [1]
 	 */
<span class="p_del">-	if (ent[0].seq == 0) {</span>
<span class="p_del">-		ent[0].seq = cpu_to_le32(1);</span>
<span class="p_add">+	if (log_seq(log, idx0) == 0) {</span>
<span class="p_add">+		log-&gt;ent[idx0].seq = cpu_to_le32(1);</span>
 		return 0;
 	}
 
<span class="p_del">-	if (ent[0].seq == ent[1].seq)</span>
<span class="p_add">+	if (log_seq(log, idx0) == log_seq(log, idx1))</span>
 		return -EINVAL;
<span class="p_del">-	if (le32_to_cpu(ent[0].seq) + le32_to_cpu(ent[1].seq) &gt; 5)</span>
<span class="p_add">+	if (log_seq(log, idx0) + log_seq(log, idx1) &gt; 5)</span>
 		return -EINVAL;
 
<span class="p_del">-	if (le32_to_cpu(ent[0].seq) &lt; le32_to_cpu(ent[1].seq)) {</span>
<span class="p_del">-		if (le32_to_cpu(ent[1].seq) - le32_to_cpu(ent[0].seq) == 1)</span>
<span class="p_add">+	if (log_seq(log, idx0) &lt; log_seq(log, idx1)) {</span>
<span class="p_add">+		if ((log_seq(log, idx1) - log_seq(log, idx0)) == 1)</span>
 			old = 0;
 		else
 			old = 1;
 	} else {
<span class="p_del">-		if (le32_to_cpu(ent[0].seq) - le32_to_cpu(ent[1].seq) == 1)</span>
<span class="p_add">+		if ((log_seq(log, idx0) - log_seq(log, idx1)) == 1)</span>
 			old = 1;
 		else
 			old = 0;
<span class="p_chunk">@@ -327,17 +336,18 @@</span> <span class="p_context"> static int btt_log_read(struct arena_info *arena, u32 lane,</span>
 {
 	int ret;
 	int old_ent, ret_ent;
<span class="p_del">-	struct log_entry log[2];</span>
<span class="p_add">+	struct log_group log;</span>
 
<span class="p_del">-	ret = btt_log_read_pair(arena, lane, log);</span>
<span class="p_add">+	ret = btt_log_group_read(arena, lane, &amp;log);</span>
 	if (ret)
 		return -EIO;
 
<span class="p_del">-	old_ent = btt_log_get_old(log);</span>
<span class="p_add">+	old_ent = btt_log_get_old(arena, &amp;log);</span>
 	if (old_ent &lt; 0 || old_ent &gt; 1) {
 		dev_err(to_dev(arena),
 				&quot;log corruption (%d): lane %d seq [%d, %d]\n&quot;,
<span class="p_del">-			old_ent, lane, log[0].seq, log[1].seq);</span>
<span class="p_add">+				old_ent, lane, log.ent[arena-&gt;log_index[0]].seq,</span>
<span class="p_add">+				log.ent[arena-&gt;log_index[1]].seq);</span>
 		/* TODO set error state? */
 		return -EIO;
 	}
<span class="p_chunk">@@ -345,7 +355,7 @@</span> <span class="p_context"> static int btt_log_read(struct arena_info *arena, u32 lane,</span>
 	ret_ent = (old_flag ? old_ent : (1 - old_ent));
 
 	if (ent != NULL)
<span class="p_del">-		memcpy(ent, &amp;log[ret_ent], LOG_ENT_SIZE);</span>
<span class="p_add">+		memcpy(ent, &amp;log.ent[arena-&gt;log_index[ret_ent]], LOG_ENT_SIZE);</span>
 
 	return ret_ent;
 }
<span class="p_chunk">@@ -359,17 +369,13 @@</span> <span class="p_context"> static int __btt_log_write(struct arena_info *arena, u32 lane,</span>
 			u32 sub, struct log_entry *ent, unsigned long flags)
 {
 	int ret;
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Ignore the padding in log_entry for calculating log_half.</span>
<span class="p_del">-	 * The entry is &#39;committed&#39; when we write the sequence number,</span>
<span class="p_del">-	 * and we want to ensure that that is the last thing written.</span>
<span class="p_del">-	 * We don&#39;t bother writing the padding as that would be extra</span>
<span class="p_del">-	 * media wear and write amplification</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	unsigned int log_half = (LOG_ENT_SIZE - 2 * sizeof(u64)) / 2;</span>
<span class="p_del">-	u64 ns_off = arena-&gt;logoff + (((2 * lane) + sub) * LOG_ENT_SIZE);</span>
<span class="p_add">+	u32 group_slot = arena-&gt;log_index[sub];</span>
<span class="p_add">+	unsigned int log_half = LOG_ENT_SIZE / 2;</span>
 	void *src = ent;
<span class="p_add">+	u64 ns_off;</span>
 
<span class="p_add">+	ns_off = arena-&gt;logoff + (lane * LOG_GRP_SIZE) +</span>
<span class="p_add">+		(group_slot * LOG_ENT_SIZE);</span>
 	/* split the 16B write into atomic, durable halves */
 	ret = arena_write_bytes(arena, ns_off, src, log_half, flags);
 	if (ret)
<span class="p_chunk">@@ -452,7 +458,7 @@</span> <span class="p_context"> static int btt_log_init(struct arena_info *arena)</span>
 {
 	size_t logsize = arena-&gt;info2off - arena-&gt;logoff;
 	size_t chunk_size = SZ_4K, offset = 0;
<span class="p_del">-	struct log_entry log;</span>
<span class="p_add">+	struct log_entry ent;</span>
 	void *zerobuf;
 	int ret;
 	u32 i;
<span class="p_chunk">@@ -484,11 +490,11 @@</span> <span class="p_context"> static int btt_log_init(struct arena_info *arena)</span>
 	}
 
 	for (i = 0; i &lt; arena-&gt;nfree; i++) {
<span class="p_del">-		log.lba = cpu_to_le32(i);</span>
<span class="p_del">-		log.old_map = cpu_to_le32(arena-&gt;external_nlba + i);</span>
<span class="p_del">-		log.new_map = cpu_to_le32(arena-&gt;external_nlba + i);</span>
<span class="p_del">-		log.seq = cpu_to_le32(LOG_SEQ_INIT);</span>
<span class="p_del">-		ret = __btt_log_write(arena, i, 0, &amp;log, 0);</span>
<span class="p_add">+		ent.lba = cpu_to_le32(i);</span>
<span class="p_add">+		ent.old_map = cpu_to_le32(arena-&gt;external_nlba + i);</span>
<span class="p_add">+		ent.new_map = cpu_to_le32(arena-&gt;external_nlba + i);</span>
<span class="p_add">+		ent.seq = cpu_to_le32(LOG_SEQ_INIT);</span>
<span class="p_add">+		ret = __btt_log_write(arena, i, 0, &amp;ent, 0);</span>
 		if (ret)
 			goto free;
 	}
<span class="p_chunk">@@ -593,6 +599,123 @@</span> <span class="p_context"> static int btt_freelist_init(struct arena_info *arena)</span>
 	return 0;
 }
 
<span class="p_add">+static bool ent_is_padding(struct log_entry *ent)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (ent-&gt;lba == 0) &amp;&amp; (ent-&gt;old_map == 0) &amp;&amp; (ent-&gt;new_map == 0)</span>
<span class="p_add">+		&amp;&amp; (ent-&gt;seq == 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Detecting valid log indices: We read a log group (see the comments in btt.h</span>
<span class="p_add">+ * for a description of a &#39;log_group&#39; and its &#39;slots&#39;), and iterate over its</span>
<span class="p_add">+ * four slots. We expect that a padding slot will be all-zeroes, and use this</span>
<span class="p_add">+ * to detect a padding slot vs. an actual entry.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * If a log_group is in the initial state, i.e. hasn&#39;t been used since the</span>
<span class="p_add">+ * creation of this BTT layout, it will have three of the four slots with</span>
<span class="p_add">+ * zeroes. We skip over these log_groups for the detection of log_index. If</span>
<span class="p_add">+ * all log_groups are in the initial state (i.e. the BTT has never been</span>
<span class="p_add">+ * written to), it is safe to assume the &#39;new format&#39; of log entries in slots</span>
<span class="p_add">+ * (0, 1).</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int log_set_indices(struct arena_info *arena)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bool idx_set = false, initial_state = true;</span>
<span class="p_add">+	int ret, log_index[2] = {-1, -1};</span>
<span class="p_add">+	u32 i, j, next_idx = 0;</span>
<span class="p_add">+	struct log_group log;</span>
<span class="p_add">+	u32 pad_count = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; arena-&gt;nfree; i++) {</span>
<span class="p_add">+		ret = btt_log_group_read(arena, i, &amp;log);</span>
<span class="p_add">+		if (ret &lt; 0)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		for (j = 0; j &lt; 4; j++) {</span>
<span class="p_add">+			if (!idx_set) {</span>
<span class="p_add">+				if (ent_is_padding(&amp;log.ent[j])) {</span>
<span class="p_add">+					pad_count++;</span>
<span class="p_add">+					continue;</span>
<span class="p_add">+				} else {</span>
<span class="p_add">+					/* Skip if index has been recorded */</span>
<span class="p_add">+					if ((next_idx == 1) &amp;&amp;</span>
<span class="p_add">+						(j == log_index[0]))</span>
<span class="p_add">+						continue;</span>
<span class="p_add">+					/* valid entry, record index */</span>
<span class="p_add">+					log_index[next_idx] = j;</span>
<span class="p_add">+					next_idx++;</span>
<span class="p_add">+				}</span>
<span class="p_add">+				if (next_idx == 2) {</span>
<span class="p_add">+					/* two valid entries found */</span>
<span class="p_add">+					idx_set = true;</span>
<span class="p_add">+				} else if (next_idx &gt; 2) {</span>
<span class="p_add">+					/* too many valid indices */</span>
<span class="p_add">+					return -ENXIO;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * once the indices have been set, just verify</span>
<span class="p_add">+				 * that all subsequent log groups are either in</span>
<span class="p_add">+				 * their initial state or follow the same</span>
<span class="p_add">+				 * indices.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				if (j == log_index[0]) {</span>
<span class="p_add">+					/* entry must be &#39;valid&#39; */</span>
<span class="p_add">+					if (ent_is_padding(&amp;log.ent[j]))</span>
<span class="p_add">+						return -ENXIO;</span>
<span class="p_add">+				} else if (j == log_index[1]) {</span>
<span class="p_add">+					;</span>
<span class="p_add">+					/*</span>
<span class="p_add">+					 * log_index[1] can be padding if the</span>
<span class="p_add">+					 * lane never got used and it is still</span>
<span class="p_add">+					 * in the initial state (three &#39;padding&#39;</span>
<span class="p_add">+					 * entries)</span>
<span class="p_add">+					 */</span>
<span class="p_add">+				} else {</span>
<span class="p_add">+					/* entry must be invalid (padding) */</span>
<span class="p_add">+					if (!ent_is_padding(&amp;log.ent[j]))</span>
<span class="p_add">+						return -ENXIO;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If any of the log_groups have more than one valid,</span>
<span class="p_add">+		 * non-padding entry, then the we are no longer in the</span>
<span class="p_add">+		 * initial_state</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (pad_count &lt; 3)</span>
<span class="p_add">+			initial_state = false;</span>
<span class="p_add">+		pad_count = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!initial_state &amp;&amp; !idx_set)</span>
<span class="p_add">+		return -ENXIO;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If all the entries in the log were in the initial state,</span>
<span class="p_add">+	 * assume new padding scheme</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (initial_state)</span>
<span class="p_add">+		log_index[1] = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Only allow the known permutations of log/padding indices,</span>
<span class="p_add">+	 * i.e. (0, 1), and (0, 2)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((log_index[0] == 0) &amp;&amp; ((log_index[1] == 1) || (log_index[1] == 2)))</span>
<span class="p_add">+		; /* known index possibilities */</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		dev_err(to_dev(arena), &quot;Found an unknown padding scheme\n&quot;);</span>
<span class="p_add">+		return -ENXIO;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	arena-&gt;log_index[0] = log_index[0];</span>
<span class="p_add">+	arena-&gt;log_index[1] = log_index[1];</span>
<span class="p_add">+	dev_dbg(to_dev(arena), &quot;log_index_0 = %d\n&quot;, log_index[0]);</span>
<span class="p_add">+	dev_dbg(to_dev(arena), &quot;log_index_1 = %d\n&quot;, log_index[1]);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int btt_rtt_init(struct arena_info *arena)
 {
 	arena-&gt;rtt = kcalloc(arena-&gt;nfree, sizeof(u32), GFP_KERNEL);
<span class="p_chunk">@@ -649,8 +772,7 @@</span> <span class="p_context"> static struct arena_info *alloc_arena(struct btt *btt, size_t size,</span>
 	available -= 2 * BTT_PG_SIZE;
 
 	/* The log takes a fixed amount of space based on nfree */
<span class="p_del">-	logsize = roundup(2 * arena-&gt;nfree * sizeof(struct log_entry),</span>
<span class="p_del">-				BTT_PG_SIZE);</span>
<span class="p_add">+	logsize = roundup(arena-&gt;nfree * LOG_GRP_SIZE, BTT_PG_SIZE);</span>
 	available -= logsize;
 
 	/* Calculate optimal split between map and data area */
<span class="p_chunk">@@ -667,6 +789,10 @@</span> <span class="p_context"> static struct arena_info *alloc_arena(struct btt *btt, size_t size,</span>
 	arena-&gt;mapoff = arena-&gt;dataoff + datasize;
 	arena-&gt;logoff = arena-&gt;mapoff + mapsize;
 	arena-&gt;info2off = arena-&gt;logoff + logsize;
<span class="p_add">+</span>
<span class="p_add">+	/* Default log indices are (0,1) */</span>
<span class="p_add">+	arena-&gt;log_index[0] = 0;</span>
<span class="p_add">+	arena-&gt;log_index[1] = 1;</span>
 	return arena;
 }
 
<span class="p_chunk">@@ -757,6 +883,13 @@</span> <span class="p_context"> static int discover_arenas(struct btt *btt)</span>
 		arena-&gt;external_lba_start = cur_nlba;
 		parse_arena_meta(arena, super, cur_off);
 
<span class="p_add">+		ret = log_set_indices(arena);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			dev_err(to_dev(arena),</span>
<span class="p_add">+				&quot;Unable to deduce log/padding indices\n&quot;);</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		mutex_init(&amp;arena-&gt;err_lock);
 		ret = btt_freelist_init(arena);
 		if (ret)
<span class="p_header">diff --git a/drivers/nvdimm/btt.h b/drivers/nvdimm/btt.h</span>
<span class="p_header">index 578c2057524d..2609683c4167 100644</span>
<span class="p_header">--- a/drivers/nvdimm/btt.h</span>
<span class="p_header">+++ b/drivers/nvdimm/btt.h</span>
<span class="p_chunk">@@ -27,6 +27,7 @@</span> <span class="p_context"></span>
 #define MAP_ERR_MASK (1 &lt;&lt; MAP_ERR_SHIFT)
 #define MAP_LBA_MASK (~((1 &lt;&lt; MAP_TRIM_SHIFT) | (1 &lt;&lt; MAP_ERR_SHIFT)))
 #define MAP_ENT_NORMAL 0xC0000000
<span class="p_add">+#define LOG_GRP_SIZE sizeof(struct log_group)</span>
 #define LOG_ENT_SIZE sizeof(struct log_entry)
 #define ARENA_MIN_SIZE (1UL &lt;&lt; 24)	/* 16 MB */
 #define ARENA_MAX_SIZE (1ULL &lt;&lt; 39)	/* 512 GB */
<span class="p_chunk">@@ -50,12 +51,52 @@</span> <span class="p_context"> enum btt_init_state {</span>
 	INIT_READY
 };
 
<span class="p_add">+/*</span>
<span class="p_add">+ * A log group represents one log &#39;lane&#39;, and consists of four log entries.</span>
<span class="p_add">+ * Two of the four entries are valid entries, and the remaining two are</span>
<span class="p_add">+ * padding. Due to an old bug in the padding location, we need to perform a</span>
<span class="p_add">+ * test to determine the padding scheme being used, and use that scheme</span>
<span class="p_add">+ * thereafter.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * In kernels prior to 4.15, &#39;log group&#39; would have actual log entries at</span>
<span class="p_add">+ * indices (0, 2) and padding at indices (1, 3), where as the correct/updated</span>
<span class="p_add">+ * format has log entries at indices (0, 1) and padding at indices (2, 3).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Old (pre 4.15) format:</span>
<span class="p_add">+ * +-----------------+-----------------+</span>
<span class="p_add">+ * |      ent[0]     |      ent[1]     |</span>
<span class="p_add">+ * |       16B       |       16B       |</span>
<span class="p_add">+ * | lba/old/new/seq |       pad       |</span>
<span class="p_add">+ * +-----------------------------------+</span>
<span class="p_add">+ * |      ent[2]     |      ent[3]     |</span>
<span class="p_add">+ * |       16B       |       16B       |</span>
<span class="p_add">+ * | lba/old/new/seq |       pad       |</span>
<span class="p_add">+ * +-----------------+-----------------+</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * New format:</span>
<span class="p_add">+ * +-----------------+-----------------+</span>
<span class="p_add">+ * |      ent[0]     |      ent[1]     |</span>
<span class="p_add">+ * |       16B       |       16B       |</span>
<span class="p_add">+ * | lba/old/new/seq | lba/old/new/seq |</span>
<span class="p_add">+ * +-----------------------------------+</span>
<span class="p_add">+ * |      ent[2]     |      ent[3]     |</span>
<span class="p_add">+ * |       16B       |       16B       |</span>
<span class="p_add">+ * |       pad       |       pad       |</span>
<span class="p_add">+ * +-----------------+-----------------+</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * We detect during start-up which format is in use, and set</span>
<span class="p_add">+ * arena-&gt;log_index[(0, 1)] with the detected format.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
 struct log_entry {
 	__le32 lba;
 	__le32 old_map;
 	__le32 new_map;
 	__le32 seq;
<span class="p_del">-	__le64 padding[2];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct log_group {</span>
<span class="p_add">+	struct log_entry ent[4];</span>
 };
 
 struct btt_sb {
<span class="p_chunk">@@ -125,6 +166,7 @@</span> <span class="p_context"> struct aligned_lock {</span>
  * @list:		List head for list of arenas
  * @debugfs_dir:	Debugfs dentry
  * @flags:		Arena flags - may signify error states.
<span class="p_add">+ * @log_index:		Indices of the valid log entries in a log_group</span>
  *
  * arena_info is a per-arena handle. Once an arena is narrowed down for an
  * IO, this struct is passed around for the duration of the IO.
<span class="p_chunk">@@ -157,6 +199,7 @@</span> <span class="p_context"> struct arena_info {</span>
 	/* Arena flags */
 	u32 flags;
 	struct mutex err_lock;
<span class="p_add">+	int log_index[2];</span>
 };
 
 /**
<span class="p_header">diff --git a/drivers/nvdimm/pfn_devs.c b/drivers/nvdimm/pfn_devs.c</span>
<span class="p_header">index 65cc171c721d..2adada1a5855 100644</span>
<span class="p_header">--- a/drivers/nvdimm/pfn_devs.c</span>
<span class="p_header">+++ b/drivers/nvdimm/pfn_devs.c</span>
<span class="p_chunk">@@ -364,9 +364,9 @@</span> <span class="p_context"> struct device *nd_pfn_create(struct nd_region *nd_region)</span>
 int nd_pfn_validate(struct nd_pfn *nd_pfn, const char *sig)
 {
 	u64 checksum, offset;
<span class="p_del">-	unsigned long align;</span>
 	enum nd_pfn_mode mode;
 	struct nd_namespace_io *nsio;
<span class="p_add">+	unsigned long align, start_pad;</span>
 	struct nd_pfn_sb *pfn_sb = nd_pfn-&gt;pfn_sb;
 	struct nd_namespace_common *ndns = nd_pfn-&gt;ndns;
 	const u8 *parent_uuid = nd_dev_to_uuid(&amp;ndns-&gt;dev);
<span class="p_chunk">@@ -410,6 +410,7 @@</span> <span class="p_context"> int nd_pfn_validate(struct nd_pfn *nd_pfn, const char *sig)</span>
 
 	align = le32_to_cpu(pfn_sb-&gt;align);
 	offset = le64_to_cpu(pfn_sb-&gt;dataoff);
<span class="p_add">+	start_pad = le32_to_cpu(pfn_sb-&gt;start_pad);</span>
 	if (align == 0)
 		align = 1UL &lt;&lt; ilog2(offset);
 	mode = le32_to_cpu(pfn_sb-&gt;mode);
<span class="p_chunk">@@ -468,7 +469,7 @@</span> <span class="p_context"> int nd_pfn_validate(struct nd_pfn *nd_pfn, const char *sig)</span>
 		return -EBUSY;
 	}
 
<span class="p_del">-	if ((align &amp;&amp; !IS_ALIGNED(offset, align))</span>
<span class="p_add">+	if ((align &amp;&amp; !IS_ALIGNED(nsio-&gt;res.start + offset + start_pad, align))</span>
 			|| !IS_ALIGNED(offset, PAGE_SIZE)) {
 		dev_err(&amp;nd_pfn-&gt;dev,
 				&quot;bad offset: %#llx dax disabled align: %#lx\n&quot;,
<span class="p_chunk">@@ -582,6 +583,12 @@</span> <span class="p_context"> static struct vmem_altmap *__nvdimm_setup_pfn(struct nd_pfn *nd_pfn,</span>
 	return altmap;
 }
 
<span class="p_add">+static u64 phys_pmem_align_down(struct nd_pfn *nd_pfn, u64 phys)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return min_t(u64, PHYS_SECTION_ALIGN_DOWN(phys),</span>
<span class="p_add">+			ALIGN_DOWN(phys, nd_pfn-&gt;align));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int nd_pfn_init(struct nd_pfn *nd_pfn)
 {
 	u32 dax_label_reserve = is_nd_dax(&amp;nd_pfn-&gt;dev) ? SZ_128K : 0;
<span class="p_chunk">@@ -637,13 +644,16 @@</span> <span class="p_context"> static int nd_pfn_init(struct nd_pfn *nd_pfn)</span>
 	start = nsio-&gt;res.start;
 	size = PHYS_SECTION_ALIGN_UP(start + size) - start;
 	if (region_intersects(start, size, IORESOURCE_SYSTEM_RAM,
<span class="p_del">-				IORES_DESC_NONE) == REGION_MIXED) {</span>
<span class="p_add">+				IORES_DESC_NONE) == REGION_MIXED</span>
<span class="p_add">+			|| !IS_ALIGNED(start + resource_size(&amp;nsio-&gt;res),</span>
<span class="p_add">+				nd_pfn-&gt;align)) {</span>
 		size = resource_size(&amp;nsio-&gt;res);
<span class="p_del">-		end_trunc = start + size - PHYS_SECTION_ALIGN_DOWN(start + size);</span>
<span class="p_add">+		end_trunc = start + size - phys_pmem_align_down(nd_pfn,</span>
<span class="p_add">+				start + size);</span>
 	}
 
 	if (start_pad + end_trunc)
<span class="p_del">-		dev_info(&amp;nd_pfn-&gt;dev, &quot;%s section collision, truncate %d bytes\n&quot;,</span>
<span class="p_add">+		dev_info(&amp;nd_pfn-&gt;dev, &quot;%s alignment collision, truncate %d bytes\n&quot;,</span>
 				dev_name(&amp;ndns-&gt;dev), start_pad + end_trunc);
 
 	/*
<span class="p_header">diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c</span>
<span class="p_header">index a25fed52f7e9..41b740aed3a3 100644</span>
<span class="p_header">--- a/drivers/parisc/lba_pci.c</span>
<span class="p_header">+++ b/drivers/parisc/lba_pci.c</span>
<span class="p_chunk">@@ -1692,3 +1692,36 @@</span> <span class="p_context"> void lba_set_iregs(struct parisc_device *lba, u32 ibase, u32 imask)</span>
 	iounmap(base_addr);
 }
 
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * The design of the Diva management card in rp34x0 machines (rp3410, rp3440)</span>
<span class="p_add">+ * seems rushed, so that many built-in components simply don&#39;t work.</span>
<span class="p_add">+ * The following quirks disable the serial AUX port and the built-in ATI RV100</span>
<span class="p_add">+ * Radeon 7000 graphics card which both don&#39;t have any external connectors and</span>
<span class="p_add">+ * thus are useless, and even worse, e.g. the AUX port occupies ttyS0 and as</span>
<span class="p_add">+ * such makes those machines the only PARISC machines on which we can&#39;t use</span>
<span class="p_add">+ * ttyS0 as boot console.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void quirk_diva_ati_card(struct pci_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (dev-&gt;subsystem_vendor != PCI_VENDOR_ID_HP ||</span>
<span class="p_add">+	    dev-&gt;subsystem_device != 0x1292)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_info(&amp;dev-&gt;dev, &quot;Hiding Diva built-in ATI card&quot;);</span>
<span class="p_add">+	dev-&gt;device = 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_QY,</span>
<span class="p_add">+	quirk_diva_ati_card);</span>
<span class="p_add">+</span>
<span class="p_add">+static void quirk_diva_aux_disable(struct pci_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (dev-&gt;subsystem_vendor != PCI_VENDOR_ID_HP ||</span>
<span class="p_add">+	    dev-&gt;subsystem_device != 0x1291)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_info(&amp;dev-&gt;dev, &quot;Hiding Diva built-in AUX serial device&quot;);</span>
<span class="p_add">+	dev-&gt;device = 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_DIVA_AUX,</span>
<span class="p_add">+	quirk_diva_aux_disable);</span>
<span class="p_header">diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c</span>
<span class="p_header">index 11bd267fc137..bb0927de79dd 100644</span>
<span class="p_header">--- a/drivers/pci/pci-driver.c</span>
<span class="p_header">+++ b/drivers/pci/pci-driver.c</span>
<span class="p_chunk">@@ -968,7 +968,12 @@</span> <span class="p_context"> static int pci_pm_thaw_noirq(struct device *dev)</span>
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume_early(dev);
 
<span class="p_del">-	pci_update_current_state(pci_dev, PCI_D0);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * pci_restore_state() requires the device to be in D0 (because of MSI</span>
<span class="p_add">+	 * restoration among other things), so force it into D0 in case the</span>
<span class="p_add">+	 * driver&#39;s &quot;freeze&quot; callbacks put it into a low-power state directly.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pci_set_power_state(pci_dev, PCI_D0);</span>
 	pci_restore_state(pci_dev);
 
 	if (drv &amp;&amp; drv-&gt;pm &amp;&amp; drv-&gt;pm-&gt;thaw_noirq)
<span class="p_header">diff --git a/drivers/pinctrl/intel/pinctrl-cherryview.c b/drivers/pinctrl/intel/pinctrl-cherryview.c</span>
<span class="p_header">index fadbca907c7c..0907531a02ca 100644</span>
<span class="p_header">--- a/drivers/pinctrl/intel/pinctrl-cherryview.c</span>
<span class="p_header">+++ b/drivers/pinctrl/intel/pinctrl-cherryview.c</span>
<span class="p_chunk">@@ -1620,6 +1620,22 @@</span> <span class="p_context"> static int chv_gpio_probe(struct chv_pinctrl *pctrl, int irq)</span>
 			clear_bit(i, chip-&gt;irq_valid_mask);
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The same set of machines in chv_no_valid_mask[] have incorrectly</span>
<span class="p_add">+	 * configured GPIOs that generate spurious interrupts so we use</span>
<span class="p_add">+	 * this same list to apply another quirk for them.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * See also https://bugzilla.kernel.org/show_bug.cgi?id=197953.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!need_valid_mask) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Mask all interrupts the community is able to generate</span>
<span class="p_add">+		 * but leave the ones that can only generate GPEs unmasked.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		chv_writel(GENMASK(31, pctrl-&gt;community-&gt;nirqs),</span>
<span class="p_add">+			   pctrl-&gt;regs + CHV_INTMASK);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* Clear all interrupts */
 	chv_writel(0xffff, pctrl-&gt;regs + CHV_INTSTAT);
 
<span class="p_header">diff --git a/drivers/spi/spi-armada-3700.c b/drivers/spi/spi-armada-3700.c</span>
<span class="p_header">index 568e1c65aa82..fe3fa1e8517a 100644</span>
<span class="p_header">--- a/drivers/spi/spi-armada-3700.c</span>
<span class="p_header">+++ b/drivers/spi/spi-armada-3700.c</span>
<span class="p_chunk">@@ -79,6 +79,7 @@</span> <span class="p_context"></span>
 #define A3700_SPI_BYTE_LEN		BIT(5)
 #define A3700_SPI_CLK_PRESCALE		BIT(0)
 #define A3700_SPI_CLK_PRESCALE_MASK	(0x1f)
<span class="p_add">+#define A3700_SPI_CLK_EVEN_OFFS		(0x10)</span>
 
 #define A3700_SPI_WFIFO_THRS_BIT	28
 #define A3700_SPI_RFIFO_THRS_BIT	24
<span class="p_chunk">@@ -220,6 +221,13 @@</span> <span class="p_context"> static void a3700_spi_clock_set(struct a3700_spi *a3700_spi,</span>
 
 	prescale = DIV_ROUND_UP(clk_get_rate(a3700_spi-&gt;clk), speed_hz);
 
<span class="p_add">+	/* For prescaler values over 15, we can only set it by steps of 2.</span>
<span class="p_add">+	 * Starting from A3700_SPI_CLK_EVEN_OFFS, we set values from 0 up to</span>
<span class="p_add">+	 * 30. We only use this range from 16 to 30.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (prescale &gt; 15)</span>
<span class="p_add">+		prescale = A3700_SPI_CLK_EVEN_OFFS + DIV_ROUND_UP(prescale, 2);</span>
<span class="p_add">+</span>
 	val = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);
 	val = val &amp; ~A3700_SPI_CLK_PRESCALE_MASK;
 
<span class="p_header">diff --git a/drivers/spi/spi-xilinx.c b/drivers/spi/spi-xilinx.c</span>
<span class="p_header">index bc7100b93dfc..e0b9fe1d0e37 100644</span>
<span class="p_header">--- a/drivers/spi/spi-xilinx.c</span>
<span class="p_header">+++ b/drivers/spi/spi-xilinx.c</span>
<span class="p_chunk">@@ -271,6 +271,7 @@</span> <span class="p_context"> static int xilinx_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)</span>
 	while (remaining_words) {
 		int n_words, tx_words, rx_words;
 		u32 sr;
<span class="p_add">+		int stalled;</span>
 
 		n_words = min(remaining_words, xspi-&gt;buffer_size);
 
<span class="p_chunk">@@ -299,7 +300,17 @@</span> <span class="p_context"> static int xilinx_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)</span>
 
 		/* Read out all the data from the Rx FIFO */
 		rx_words = n_words;
<span class="p_add">+		stalled = 10;</span>
 		while (rx_words) {
<span class="p_add">+			if (rx_words == n_words &amp;&amp; !(stalled--) &amp;&amp;</span>
<span class="p_add">+			    !(sr &amp; XSPI_SR_TX_EMPTY_MASK) &amp;&amp;</span>
<span class="p_add">+			    (sr &amp; XSPI_SR_RX_EMPTY_MASK)) {</span>
<span class="p_add">+				dev_err(&amp;spi-&gt;dev,</span>
<span class="p_add">+					&quot;Detected stall. Check C_SPI_MODE and C_SPI_MEMORY\n&quot;);</span>
<span class="p_add">+				xspi_init_hw(xspi);</span>
<span class="p_add">+				return -EIO;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			if ((sr &amp; XSPI_SR_TX_EMPTY_MASK) &amp;&amp; (rx_words &gt; 1)) {
 				xilinx_spi_rx(xspi);
 				rx_words--;
<span class="p_header">diff --git a/include/asm-generic/mm_hooks.h b/include/asm-generic/mm_hooks.h</span>
<span class="p_header">index ea189d88a3cc..8ac4e68a12f0 100644</span>
<span class="p_header">--- a/include/asm-generic/mm_hooks.h</span>
<span class="p_header">+++ b/include/asm-generic/mm_hooks.h</span>
<span class="p_chunk">@@ -7,9 +7,10 @@</span> <span class="p_context"></span>
 #ifndef _ASM_GENERIC_MM_HOOKS_H
 #define _ASM_GENERIC_MM_HOOKS_H
 
<span class="p_del">-static inline void arch_dup_mmap(struct mm_struct *oldmm,</span>
<span class="p_del">-				 struct mm_struct *mm)</span>
<span class="p_add">+static inline int arch_dup_mmap(struct mm_struct *oldmm,</span>
<span class="p_add">+				struct mm_struct *mm)</span>
 {
<span class="p_add">+	return 0;</span>
 }
 
 static inline void arch_exit_mmap(struct mm_struct *mm)
<span class="p_header">diff --git a/include/asm-generic/pgtable.h b/include/asm-generic/pgtable.h</span>
<span class="p_header">index 1ac457511f4e..045a7f52ab3a 100644</span>
<span class="p_header">--- a/include/asm-generic/pgtable.h</span>
<span class="p_header">+++ b/include/asm-generic/pgtable.h</span>
<span class="p_chunk">@@ -1025,6 +1025,11 @@</span> <span class="p_context"> static inline int pmd_clear_huge(pmd_t *pmd)</span>
 struct file;
 int phys_mem_access_prot_allowed(struct file *file, unsigned long pfn,
 			unsigned long size, pgprot_t *vma_prot);
<span class="p_add">+</span>
<span class="p_add">+#ifndef CONFIG_X86_ESPFIX64</span>
<span class="p_add">+static inline void init_espfix_bsp(void) { }</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #endif /* !__ASSEMBLY__ */
 
 #ifndef io_remap_pfn_range
<span class="p_header">diff --git a/include/crypto/mcryptd.h b/include/crypto/mcryptd.h</span>
<span class="p_header">index cceafa01f907..b67404fc4b34 100644</span>
<span class="p_header">--- a/include/crypto/mcryptd.h</span>
<span class="p_header">+++ b/include/crypto/mcryptd.h</span>
<span class="p_chunk">@@ -27,6 +27,7 @@</span> <span class="p_context"> static inline struct mcryptd_ahash *__mcryptd_ahash_cast(</span>
 
 struct mcryptd_cpu_queue {
 	struct crypto_queue queue;
<span class="p_add">+	spinlock_t q_lock;</span>
 	struct work_struct work;
 };
 
<span class="p_header">diff --git a/include/linux/bio.h b/include/linux/bio.h</span>
<span class="p_header">index 275c91c99516..45f00dd6323c 100644</span>
<span class="p_header">--- a/include/linux/bio.h</span>
<span class="p_header">+++ b/include/linux/bio.h</span>
<span class="p_chunk">@@ -504,6 +504,8 @@</span> <span class="p_context"> extern unsigned int bvec_nr_vecs(unsigned short idx);</span>
 
 #define bio_set_dev(bio, bdev) 			\
 do {						\
<span class="p_add">+	if ((bio)-&gt;bi_disk != (bdev)-&gt;bd_disk)	\</span>
<span class="p_add">+		bio_clear_flag(bio, BIO_THROTTLED);\</span>
 	(bio)-&gt;bi_disk = (bdev)-&gt;bd_disk;	\
 	(bio)-&gt;bi_partno = (bdev)-&gt;bd_partno;	\
 } while (0)
<span class="p_header">diff --git a/include/linux/blk_types.h b/include/linux/blk_types.h</span>
<span class="p_header">index 96ac3815542c..1c8a8a2aedf7 100644</span>
<span class="p_header">--- a/include/linux/blk_types.h</span>
<span class="p_header">+++ b/include/linux/blk_types.h</span>
<span class="p_chunk">@@ -50,8 +50,6 @@</span> <span class="p_context"> struct blk_issue_stat {</span>
 struct bio {
 	struct bio		*bi_next;	/* request queue link */
 	struct gendisk		*bi_disk;
<span class="p_del">-	u8			bi_partno;</span>
<span class="p_del">-	blk_status_t		bi_status;</span>
 	unsigned int		bi_opf;		/* bottom bits req flags,
 						 * top bits REQ_OP. Use
 						 * accessors.
<span class="p_chunk">@@ -59,8 +57,8 @@</span> <span class="p_context"> struct bio {</span>
 	unsigned short		bi_flags;	/* status, etc and bvec pool number */
 	unsigned short		bi_ioprio;
 	unsigned short		bi_write_hint;
<span class="p_del">-</span>
<span class="p_del">-	struct bvec_iter	bi_iter;</span>
<span class="p_add">+	blk_status_t		bi_status;</span>
<span class="p_add">+	u8			bi_partno;</span>
 
 	/* Number of segments in this BIO after
 	 * physical address coalescing is performed.
<span class="p_chunk">@@ -74,8 +72,9 @@</span> <span class="p_context"> struct bio {</span>
 	unsigned int		bi_seg_front_size;
 	unsigned int		bi_seg_back_size;
 
<span class="p_del">-	atomic_t		__bi_remaining;</span>
<span class="p_add">+	struct bvec_iter	bi_iter;</span>
 
<span class="p_add">+	atomic_t		__bi_remaining;</span>
 	bio_end_io_t		*bi_end_io;
 
 	void			*bi_private;
<span class="p_header">diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h</span>
<span class="p_header">index 8da66379f7ea..fd47bd96b5d3 100644</span>
<span class="p_header">--- a/include/linux/blkdev.h</span>
<span class="p_header">+++ b/include/linux/blkdev.h</span>
<span class="p_chunk">@@ -135,7 +135,7 @@</span> <span class="p_context"> typedef __u32 __bitwise req_flags_t;</span>
 struct request {
 	struct list_head queuelist;
 	union {
<span class="p_del">-		call_single_data_t csd;</span>
<span class="p_add">+		struct __call_single_data csd;</span>
 		u64 fifo_time;
 	};
 
<span class="p_header">diff --git a/init/main.c b/init/main.c</span>
<span class="p_header">index 0ee9c6866ada..8a390f60ec81 100644</span>
<span class="p_header">--- a/init/main.c</span>
<span class="p_header">+++ b/init/main.c</span>
<span class="p_chunk">@@ -504,6 +504,8 @@</span> <span class="p_context"> static void __init mm_init(void)</span>
 	pgtable_init();
 	vmalloc_init();
 	ioremap_huge_init();
<span class="p_add">+	/* Should be run before the first non-init thread is created */</span>
<span class="p_add">+	init_espfix_bsp();</span>
 }
 
 asmlinkage __visible void __init start_kernel(void)
<span class="p_chunk">@@ -673,10 +675,6 @@</span> <span class="p_context"> asmlinkage __visible void __init start_kernel(void)</span>
 #ifdef CONFIG_X86
 	if (efi_enabled(EFI_RUNTIME_SERVICES))
 		efi_enter_virtual_mode();
<span class="p_del">-#endif</span>
<span class="p_del">-#ifdef CONFIG_X86_ESPFIX64</span>
<span class="p_del">-	/* Should be run before the first non-init thread is created */</span>
<span class="p_del">-	init_espfix_bsp();</span>
 #endif
 	thread_stack_cache_init();
 	cred_init();
<span class="p_header">diff --git a/kernel/fork.c b/kernel/fork.c</span>
<span class="p_header">index 07cc743698d3..500ce64517d9 100644</span>
<span class="p_header">--- a/kernel/fork.c</span>
<span class="p_header">+++ b/kernel/fork.c</span>
<span class="p_chunk">@@ -721,8 +721,7 @@</span> <span class="p_context"> static __latent_entropy int dup_mmap(struct mm_struct *mm,</span>
 			goto out;
 	}
 	/* a new mm has just been created */
<span class="p_del">-	arch_dup_mmap(oldmm, mm);</span>
<span class="p_del">-	retval = 0;</span>
<span class="p_add">+	retval = arch_dup_mmap(oldmm, mm);</span>
 out:
 	up_write(&amp;mm-&gt;mmap_sem);
 	flush_tlb_mm(oldmm);
<span class="p_header">diff --git a/net/ipv6/route.c b/net/ipv6/route.c</span>
<span class="p_header">index 76b47682f77f..598efa8cfe25 100644</span>
<span class="p_header">--- a/net/ipv6/route.c</span>
<span class="p_header">+++ b/net/ipv6/route.c</span>
<span class="p_chunk">@@ -1055,6 +1055,7 @@</span> <span class="p_context"> static struct rt6_info *rt6_get_pcpu_route(struct rt6_info *rt)</span>
 
 static struct rt6_info *rt6_make_pcpu_route(struct rt6_info *rt)
 {
<span class="p_add">+	struct fib6_table *table = rt-&gt;rt6i_table;</span>
 	struct rt6_info *pcpu_rt, *prev, **p;
 
 	pcpu_rt = ip6_rt_pcpu_alloc(rt);
<span class="p_chunk">@@ -1065,20 +1066,28 @@</span> <span class="p_context"> static struct rt6_info *rt6_make_pcpu_route(struct rt6_info *rt)</span>
 		return net-&gt;ipv6.ip6_null_entry;
 	}
 
<span class="p_del">-	dst_hold(&amp;pcpu_rt-&gt;dst);</span>
<span class="p_del">-	p = this_cpu_ptr(rt-&gt;rt6i_pcpu);</span>
<span class="p_del">-	prev = cmpxchg(p, NULL, pcpu_rt);</span>
<span class="p_del">-	if (prev) {</span>
<span class="p_del">-		/* If someone did it before us, return prev instead */</span>
<span class="p_del">-		/* release refcnt taken by ip6_rt_pcpu_alloc() */</span>
<span class="p_del">-		dst_release_immediate(&amp;pcpu_rt-&gt;dst);</span>
<span class="p_del">-		/* release refcnt taken by above dst_hold() */</span>
<span class="p_add">+	read_lock_bh(&amp;table-&gt;tb6_lock);</span>
<span class="p_add">+	if (rt-&gt;rt6i_pcpu) {</span>
<span class="p_add">+		p = this_cpu_ptr(rt-&gt;rt6i_pcpu);</span>
<span class="p_add">+		prev = cmpxchg(p, NULL, pcpu_rt);</span>
<span class="p_add">+		if (prev) {</span>
<span class="p_add">+			/* If someone did it before us, return prev instead */</span>
<span class="p_add">+			dst_release_immediate(&amp;pcpu_rt-&gt;dst);</span>
<span class="p_add">+			pcpu_rt = prev;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* rt has been removed from the fib6 tree</span>
<span class="p_add">+		 * before we have a chance to acquire the read_lock.</span>
<span class="p_add">+		 * In this case, don&#39;t brother to create a pcpu rt</span>
<span class="p_add">+		 * since rt is going away anyway.  The next</span>
<span class="p_add">+		 * dst_check() will trigger a re-lookup.</span>
<span class="p_add">+		 */</span>
 		dst_release_immediate(&amp;pcpu_rt-&gt;dst);
<span class="p_del">-		dst_hold(&amp;prev-&gt;dst);</span>
<span class="p_del">-		pcpu_rt = prev;</span>
<span class="p_add">+		pcpu_rt = rt;</span>
 	}
<span class="p_del">-</span>
<span class="p_add">+	dst_hold(&amp;pcpu_rt-&gt;dst);</span>
 	rt6_dst_from_metrics_check(pcpu_rt);
<span class="p_add">+	read_unlock_bh(&amp;table-&gt;tb6_lock);</span>
 	return pcpu_rt;
 }
 
<span class="p_chunk">@@ -1168,28 +1177,19 @@</span> <span class="p_context"> struct rt6_info *ip6_pol_route(struct net *net, struct fib6_table *table,</span>
 		if (pcpu_rt) {
 			read_unlock_bh(&amp;table-&gt;tb6_lock);
 		} else {
<span class="p_del">-			/* atomic_inc_not_zero() is needed when using rcu */</span>
<span class="p_del">-			if (atomic_inc_not_zero(&amp;rt-&gt;rt6i_ref)) {</span>
<span class="p_del">-				/* We have to do the read_unlock first</span>
<span class="p_del">-				 * because rt6_make_pcpu_route() may trigger</span>
<span class="p_del">-				 * ip6_dst_gc() which will take the write_lock.</span>
<span class="p_del">-				 *</span>
<span class="p_del">-				 * No dst_hold() on rt is needed because grabbing</span>
<span class="p_del">-				 * rt-&gt;rt6i_ref makes sure rt can&#39;t be released.</span>
<span class="p_del">-				 */</span>
<span class="p_del">-				read_unlock_bh(&amp;table-&gt;tb6_lock);</span>
<span class="p_del">-				pcpu_rt = rt6_make_pcpu_route(rt);</span>
<span class="p_del">-				rt6_release(rt);</span>
<span class="p_del">-			} else {</span>
<span class="p_del">-				/* rt is already removed from tree */</span>
<span class="p_del">-				read_unlock_bh(&amp;table-&gt;tb6_lock);</span>
<span class="p_del">-				pcpu_rt = net-&gt;ipv6.ip6_null_entry;</span>
<span class="p_del">-				dst_hold(&amp;pcpu_rt-&gt;dst);</span>
<span class="p_del">-			}</span>
<span class="p_add">+			/* We have to do the read_unlock first</span>
<span class="p_add">+			 * because rt6_make_pcpu_route() may trigger</span>
<span class="p_add">+			 * ip6_dst_gc() which will take the write_lock.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			dst_hold(&amp;rt-&gt;dst);</span>
<span class="p_add">+			read_unlock_bh(&amp;table-&gt;tb6_lock);</span>
<span class="p_add">+			pcpu_rt = rt6_make_pcpu_route(rt);</span>
<span class="p_add">+			dst_release(&amp;rt-&gt;dst);</span>
 		}
 
 		trace_fib6_table_lookup(net, pcpu_rt, table-&gt;tb6_id, fl6);
 		return pcpu_rt;
<span class="p_add">+</span>
 	}
 }
 EXPORT_SYMBOL_GPL(ip6_pol_route);
<span class="p_header">diff --git a/sound/core/rawmidi.c b/sound/core/rawmidi.c</span>
<span class="p_header">index b3b353d72527..f055ca10bbc1 100644</span>
<span class="p_header">--- a/sound/core/rawmidi.c</span>
<span class="p_header">+++ b/sound/core/rawmidi.c</span>
<span class="p_chunk">@@ -579,15 +579,14 @@</span> <span class="p_context"> static int snd_rawmidi_info_user(struct snd_rawmidi_substream *substream,</span>
 	return 0;
 }
 
<span class="p_del">-int snd_rawmidi_info_select(struct snd_card *card, struct snd_rawmidi_info *info)</span>
<span class="p_add">+static int __snd_rawmidi_info_select(struct snd_card *card,</span>
<span class="p_add">+				     struct snd_rawmidi_info *info)</span>
 {
 	struct snd_rawmidi *rmidi;
 	struct snd_rawmidi_str *pstr;
 	struct snd_rawmidi_substream *substream;
 
<span class="p_del">-	mutex_lock(&amp;register_mutex);</span>
 	rmidi = snd_rawmidi_search(card, info-&gt;device);
<span class="p_del">-	mutex_unlock(&amp;register_mutex);</span>
 	if (!rmidi)
 		return -ENXIO;
 	if (info-&gt;stream &lt; 0 || info-&gt;stream &gt; 1)
<span class="p_chunk">@@ -603,6 +602,16 @@</span> <span class="p_context"> int snd_rawmidi_info_select(struct snd_card *card, struct snd_rawmidi_info *info</span>
 	}
 	return -ENXIO;
 }
<span class="p_add">+</span>
<span class="p_add">+int snd_rawmidi_info_select(struct snd_card *card, struct snd_rawmidi_info *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;register_mutex);</span>
<span class="p_add">+	ret = __snd_rawmidi_info_select(card, info);</span>
<span class="p_add">+	mutex_unlock(&amp;register_mutex);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL(snd_rawmidi_info_select);
 
 static int snd_rawmidi_info_select_user(struct snd_card *card,
<span class="p_header">diff --git a/sound/pci/hda/patch_hdmi.c b/sound/pci/hda/patch_hdmi.c</span>
<span class="p_header">index c19c81d230bd..b4f1b6e88305 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_hdmi.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_hdmi.c</span>
<span class="p_chunk">@@ -55,10 +55,11 @@</span> <span class="p_context"> MODULE_PARM_DESC(static_hdmi_pcm, &quot;Don&#39;t restrict PCM parameters per ELD info&quot;);</span>
 #define is_kabylake(codec) ((codec)-&gt;core.vendor_id == 0x8086280b)
 #define is_geminilake(codec) (((codec)-&gt;core.vendor_id == 0x8086280d) || \
 				((codec)-&gt;core.vendor_id == 0x80862800))
<span class="p_add">+#define is_cannonlake(codec) ((codec)-&gt;core.vendor_id == 0x8086280c)</span>
 #define is_haswell_plus(codec) (is_haswell(codec) || is_broadwell(codec) \
 				|| is_skylake(codec) || is_broxton(codec) \
<span class="p_del">-				|| is_kabylake(codec)) || is_geminilake(codec)</span>
<span class="p_del">-</span>
<span class="p_add">+				|| is_kabylake(codec)) || is_geminilake(codec) \</span>
<span class="p_add">+				|| is_cannonlake(codec)</span>
 #define is_valleyview(codec) ((codec)-&gt;core.vendor_id == 0x80862882)
 #define is_cherryview(codec) ((codec)-&gt;core.vendor_id == 0x80862883)
 #define is_valleyview_plus(codec) (is_valleyview(codec) || is_cherryview(codec))
<span class="p_chunk">@@ -3841,6 +3842,7 @@</span> <span class="p_context"> HDA_CODEC_ENTRY(0x80862808, &quot;Broadwell HDMI&quot;,	patch_i915_hsw_hdmi),</span>
 HDA_CODEC_ENTRY(0x80862809, &quot;Skylake HDMI&quot;,	patch_i915_hsw_hdmi),
 HDA_CODEC_ENTRY(0x8086280a, &quot;Broxton HDMI&quot;,	patch_i915_hsw_hdmi),
 HDA_CODEC_ENTRY(0x8086280b, &quot;Kabylake HDMI&quot;,	patch_i915_hsw_hdmi),
<span class="p_add">+HDA_CODEC_ENTRY(0x8086280c, &quot;Cannonlake HDMI&quot;,	patch_i915_glk_hdmi),</span>
 HDA_CODEC_ENTRY(0x8086280d, &quot;Geminilake HDMI&quot;,	patch_i915_glk_hdmi),
 HDA_CODEC_ENTRY(0x80862800, &quot;Geminilake HDMI&quot;,	patch_i915_glk_hdmi),
 HDA_CODEC_ENTRY(0x80862880, &quot;CedarTrail HDMI&quot;,	patch_generic_hdmi),
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index b076386c8952..9ac4b9076ee2 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -5162,6 +5162,22 @@</span> <span class="p_context"> static void alc233_alc662_fixup_lenovo_dual_codecs(struct hda_codec *codec,</span>
 	}
 }
 
<span class="p_add">+/* Forcibly assign NID 0x03 to HP/LO while NID 0x02 to SPK for EQ */</span>
<span class="p_add">+static void alc274_fixup_bind_dacs(struct hda_codec *codec,</span>
<span class="p_add">+				    const struct hda_fixup *fix, int action)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct alc_spec *spec = codec-&gt;spec;</span>
<span class="p_add">+	static hda_nid_t preferred_pairs[] = {</span>
<span class="p_add">+		0x21, 0x03, 0x1b, 0x03, 0x16, 0x02,</span>
<span class="p_add">+		0</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	if (action != HDA_FIXUP_ACT_PRE_PROBE)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	spec-&gt;gen.preferred_dacs = preferred_pairs;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* for hda_fixup_thinkpad_acpi() */
 #include &quot;thinkpad_helper.c&quot;
 
<span class="p_chunk">@@ -5279,6 +5295,8 @@</span> <span class="p_context"> enum {</span>
 	ALC233_FIXUP_LENOVO_MULTI_CODECS,
 	ALC294_FIXUP_LENOVO_MIC_LOCATION,
 	ALC700_FIXUP_INTEL_REFERENCE,
<span class="p_add">+	ALC274_FIXUP_DELL_BIND_DACS,</span>
<span class="p_add">+	ALC274_FIXUP_DELL_AIO_LINEOUT_VERB,</span>
 };
 
 static const struct hda_fixup alc269_fixups[] = {
<span class="p_chunk">@@ -6089,6 +6107,21 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 			{}
 		}
 	},
<span class="p_add">+	[ALC274_FIXUP_DELL_BIND_DACS] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc274_fixup_bind_dacs,</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC269_FIXUP_DELL1_MIC_NO_PRESENCE</span>
<span class="p_add">+	},</span>
<span class="p_add">+	[ALC274_FIXUP_DELL_AIO_LINEOUT_VERB] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_PINS,</span>
<span class="p_add">+		.v.pins = (const struct hda_pintbl[]) {</span>
<span class="p_add">+			{ 0x1b, 0x0401102f },</span>
<span class="p_add">+			{ }</span>
<span class="p_add">+		},</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC274_FIXUP_DELL_BIND_DACS</span>
<span class="p_add">+	},</span>
 };
 
 static const struct snd_pci_quirk alc269_fixup_tbl[] = {
<span class="p_chunk">@@ -6550,7 +6583,7 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 		{0x14, 0x90170110},
 		{0x1b, 0x90a70130},
 		{0x21, 0x03211020}),
<span class="p_del">-	SND_HDA_PIN_QUIRK(0x10ec0274, 0x1028, &quot;Dell&quot;, ALC269_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0274, 0x1028, &quot;Dell&quot;, ALC274_FIXUP_DELL_AIO_LINEOUT_VERB,</span>
 		{0x12, 0xb7a60130},
 		{0x13, 0xb8a61140},
 		{0x16, 0x90170110},
<span class="p_header">diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c</span>
<span class="p_header">index 4fde4f8d4444..75bce127d768 100644</span>
<span class="p_header">--- a/sound/usb/mixer.c</span>
<span class="p_header">+++ b/sound/usb/mixer.c</span>
<span class="p_chunk">@@ -2173,20 +2173,25 @@</span> <span class="p_context"> static int parse_audio_selector_unit(struct mixer_build *state, int unitid,</span>
 	kctl-&gt;private_value = (unsigned long)namelist;
 	kctl-&gt;private_free = usb_mixer_selector_elem_free;
 
<span class="p_del">-	nameid = uac_selector_unit_iSelector(desc);</span>
<span class="p_add">+	/* check the static mapping table at first */</span>
 	len = check_mapped_name(map, kctl-&gt;id.name, sizeof(kctl-&gt;id.name));
<span class="p_del">-	if (len)</span>
<span class="p_del">-		;</span>
<span class="p_del">-	else if (nameid)</span>
<span class="p_del">-		len = snd_usb_copy_string_desc(state, nameid, kctl-&gt;id.name,</span>
<span class="p_del">-					 sizeof(kctl-&gt;id.name));</span>
<span class="p_del">-	else</span>
<span class="p_del">-		len = get_term_name(state, &amp;state-&gt;oterm,</span>
<span class="p_del">-				    kctl-&gt;id.name, sizeof(kctl-&gt;id.name), 0);</span>
<span class="p_del">-</span>
 	if (!len) {
<span class="p_del">-		strlcpy(kctl-&gt;id.name, &quot;USB&quot;, sizeof(kctl-&gt;id.name));</span>
<span class="p_add">+		/* no mapping ? */</span>
<span class="p_add">+		/* if iSelector is given, use it */</span>
<span class="p_add">+		nameid = uac_selector_unit_iSelector(desc);</span>
<span class="p_add">+		if (nameid)</span>
<span class="p_add">+			len = snd_usb_copy_string_desc(state, nameid,</span>
<span class="p_add">+						       kctl-&gt;id.name,</span>
<span class="p_add">+						       sizeof(kctl-&gt;id.name));</span>
<span class="p_add">+		/* ... or pick up the terminal name at next */</span>
<span class="p_add">+		if (!len)</span>
<span class="p_add">+			len = get_term_name(state, &amp;state-&gt;oterm,</span>
<span class="p_add">+				    kctl-&gt;id.name, sizeof(kctl-&gt;id.name), 0);</span>
<span class="p_add">+		/* ... or use the fixed string &quot;USB&quot; as the last resort */</span>
<span class="p_add">+		if (!len)</span>
<span class="p_add">+			strlcpy(kctl-&gt;id.name, &quot;USB&quot;, sizeof(kctl-&gt;id.name));</span>
 
<span class="p_add">+		/* and add the proper suffix */</span>
 		if (desc-&gt;bDescriptorSubtype == UAC2_CLOCK_SELECTOR)
 			append_ctl_name(kctl, &quot; Clock Source&quot;);
 		else if ((state-&gt;oterm.type &amp; 0xff00) == 0x0100)
<span class="p_header">diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c</span>
<span class="p_header">index 20624320b753..8d7db7cd4f88 100644</span>
<span class="p_header">--- a/sound/usb/quirks.c</span>
<span class="p_header">+++ b/sound/usb/quirks.c</span>
<span class="p_chunk">@@ -1172,10 +1172,11 @@</span> <span class="p_context"> static bool is_marantz_denon_dac(unsigned int id)</span>
 /* TEAC UD-501/UD-503/NT-503 USB DACs need a vendor cmd to switch
  * between PCM/DOP and native DSD mode
  */
<span class="p_del">-static bool is_teac_50X_dac(unsigned int id)</span>
<span class="p_add">+static bool is_teac_dsd_dac(unsigned int id)</span>
 {
 	switch (id) {
 	case USB_ID(0x0644, 0x8043): /* TEAC UD-501/UD-503/NT-503 */
<span class="p_add">+	case USB_ID(0x0644, 0x8044): /* Esoteric D-05X */</span>
 		return true;
 	}
 	return false;
<span class="p_chunk">@@ -1208,7 +1209,7 @@</span> <span class="p_context"> int snd_usb_select_mode_quirk(struct snd_usb_substream *subs,</span>
 			break;
 		}
 		mdelay(20);
<span class="p_del">-	} else if (is_teac_50X_dac(subs-&gt;stream-&gt;chip-&gt;usb_id)) {</span>
<span class="p_add">+	} else if (is_teac_dsd_dac(subs-&gt;stream-&gt;chip-&gt;usb_id)) {</span>
 		/* Vendor mode switch cmd is required. */
 		switch (fmt-&gt;altsetting) {
 		case 3: /* DSD mode (DSD_U32) requested */
<span class="p_chunk">@@ -1398,7 +1399,7 @@</span> <span class="p_context"> u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,</span>
 	}
 
 	/* TEAC devices with USB DAC functionality */
<span class="p_del">-	if (is_teac_50X_dac(chip-&gt;usb_id)) {</span>
<span class="p_add">+	if (is_teac_dsd_dac(chip-&gt;usb_id)) {</span>
 		if (fp-&gt;altsetting == 3)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 	}
<span class="p_header">diff --git a/tools/objtool/.gitignore b/tools/objtool/.gitignore</span>
<span class="p_header">index d3102c865a95..914cff12899b 100644</span>
<span class="p_header">--- a/tools/objtool/.gitignore</span>
<span class="p_header">+++ b/tools/objtool/.gitignore</span>
<span class="p_chunk">@@ -1,3 +1,3 @@</span> <span class="p_context"></span>
<span class="p_del">-arch/x86/insn/inat-tables.c</span>
<span class="p_add">+arch/x86/lib/inat-tables.c</span>
 objtool
 fixdep
<span class="p_header">diff --git a/tools/objtool/Makefile b/tools/objtool/Makefile</span>
<span class="p_header">index 424b1965d06f..ae0272f9a091 100644</span>
<span class="p_header">--- a/tools/objtool/Makefile</span>
<span class="p_header">+++ b/tools/objtool/Makefile</span>
<span class="p_chunk">@@ -7,9 +7,11 @@</span> <span class="p_context"> ARCH := x86</span>
 endif
 
 # always use the host compiler
<span class="p_del">-CC = gcc</span>
<span class="p_del">-LD = ld</span>
<span class="p_del">-AR = ar</span>
<span class="p_add">+HOSTCC	?= gcc</span>
<span class="p_add">+HOSTLD	?= ld</span>
<span class="p_add">+CC	 = $(HOSTCC)</span>
<span class="p_add">+LD	 = $(HOSTLD)</span>
<span class="p_add">+AR	 = ar</span>
 
 ifeq ($(srctree),)
 srctree := $(patsubst %/,%,$(dir $(CURDIR)))
<span class="p_chunk">@@ -25,7 +27,9 @@</span> <span class="p_context"> OBJTOOL_IN := $(OBJTOOL)-in.o</span>
 
 all: $(OBJTOOL)
 
<span class="p_del">-INCLUDES := -I$(srctree)/tools/include -I$(srctree)/tools/arch/$(HOSTARCH)/include/uapi</span>
<span class="p_add">+INCLUDES := -I$(srctree)/tools/include \</span>
<span class="p_add">+	    -I$(srctree)/tools/arch/$(HOSTARCH)/include/uapi \</span>
<span class="p_add">+	    -I$(srctree)/tools/objtool/arch/$(ARCH)/include</span>
 WARNINGS := $(EXTRA_WARNINGS) -Wno-switch-default -Wno-switch-enum -Wno-packed
 CFLAGS   += -Wall -Werror $(WARNINGS) -fomit-frame-pointer -O2 -g $(INCLUDES)
 LDFLAGS  += -lelf $(LIBSUBCMD)
<span class="p_chunk">@@ -41,22 +45,8 @@</span> <span class="p_context"> include $(srctree)/tools/build/Makefile.include</span>
 $(OBJTOOL_IN): fixdep FORCE
 	@$(MAKE) $(build)=objtool
 
<span class="p_del">-# Busybox&#39;s diff doesn&#39;t have -I, avoid warning in that case</span>
<span class="p_del">-#</span>
 $(OBJTOOL): $(LIBSUBCMD) $(OBJTOOL_IN)
<span class="p_del">-	@(diff -I 2&gt;&amp;1 | grep -q &#39;option requires an argument&#39; &amp;&amp; \</span>
<span class="p_del">-	test -d ../../kernel -a -d ../../tools -a -d ../objtool &amp;&amp; (( \</span>
<span class="p_del">-	diff -I&#39;^#include&#39; arch/x86/insn/insn.c ../../arch/x86/lib/insn.c &gt;/dev/null &amp;&amp; \</span>
<span class="p_del">-	diff -I&#39;^#include&#39; arch/x86/insn/inat.c ../../arch/x86/lib/inat.c &gt;/dev/null &amp;&amp; \</span>
<span class="p_del">-	diff arch/x86/insn/x86-opcode-map.txt ../../arch/x86/lib/x86-opcode-map.txt &gt;/dev/null &amp;&amp; \</span>
<span class="p_del">-	diff arch/x86/insn/gen-insn-attr-x86.awk ../../arch/x86/tools/gen-insn-attr-x86.awk &gt;/dev/null &amp;&amp; \</span>
<span class="p_del">-	diff -I&#39;^#include&#39; arch/x86/insn/insn.h ../../arch/x86/include/asm/insn.h &gt;/dev/null &amp;&amp; \</span>
<span class="p_del">-	diff -I&#39;^#include&#39; arch/x86/insn/inat.h ../../arch/x86/include/asm/inat.h &gt;/dev/null &amp;&amp; \</span>
<span class="p_del">-	diff -I&#39;^#include&#39; arch/x86/insn/inat_types.h ../../arch/x86/include/asm/inat_types.h &gt;/dev/null) \</span>
<span class="p_del">-	|| echo &quot;warning: objtool: x86 instruction decoder differs from kernel&quot; &gt;&amp;2 )) || true</span>
<span class="p_del">-	@(test -d ../../kernel -a -d ../../tools -a -d ../objtool &amp;&amp; (( \</span>
<span class="p_del">-	diff ../../arch/x86/include/asm/orc_types.h orc_types.h &gt;/dev/null) \</span>
<span class="p_del">-	|| echo &quot;warning: objtool: orc_types.h differs from kernel&quot; &gt;&amp;2 )) || true</span>
<span class="p_add">+	@./sync-check.sh</span>
 	$(QUIET_LINK)$(CC) $(OBJTOOL_IN) $(LDFLAGS) -o $@
 
 
<span class="p_chunk">@@ -66,7 +56,7 @@</span> <span class="p_context"> $(LIBSUBCMD): fixdep FORCE</span>
 clean:
 	$(call QUIET_CLEAN, objtool) $(RM) $(OBJTOOL)
 	$(Q)find $(OUTPUT) -name &#39;*.o&#39; -delete -o -name &#39;\.*.cmd&#39; -delete -o -name &#39;\.*.d&#39; -delete
<span class="p_del">-	$(Q)$(RM) $(OUTPUT)arch/x86/insn/inat-tables.c $(OUTPUT)fixdep</span>
<span class="p_add">+	$(Q)$(RM) $(OUTPUT)arch/x86/lib/inat-tables.c $(OUTPUT)fixdep</span>
 
 FORCE:
 
<span class="p_header">diff --git a/tools/objtool/arch/x86/Build b/tools/objtool/arch/x86/Build</span>
<span class="p_header">index debbdb0b5c43..b998412c017d 100644</span>
<span class="p_header">--- a/tools/objtool/arch/x86/Build</span>
<span class="p_header">+++ b/tools/objtool/arch/x86/Build</span>
<span class="p_chunk">@@ -1,12 +1,12 @@</span> <span class="p_context"></span>
 objtool-y += decode.o
 
<span class="p_del">-inat_tables_script = arch/x86/insn/gen-insn-attr-x86.awk</span>
<span class="p_del">-inat_tables_maps = arch/x86/insn/x86-opcode-map.txt</span>
<span class="p_add">+inat_tables_script = arch/x86/tools/gen-insn-attr-x86.awk</span>
<span class="p_add">+inat_tables_maps = arch/x86/lib/x86-opcode-map.txt</span>
 
<span class="p_del">-$(OUTPUT)arch/x86/insn/inat-tables.c: $(inat_tables_script) $(inat_tables_maps)</span>
<span class="p_add">+$(OUTPUT)arch/x86/lib/inat-tables.c: $(inat_tables_script) $(inat_tables_maps)</span>
 	$(call rule_mkdir)
 	$(Q)$(call echo-cmd,gen)$(AWK) -f $(inat_tables_script) $(inat_tables_maps) &gt; $@
 
<span class="p_del">-$(OUTPUT)arch/x86/decode.o: $(OUTPUT)arch/x86/insn/inat-tables.c</span>
<span class="p_add">+$(OUTPUT)arch/x86/decode.o: $(OUTPUT)arch/x86/lib/inat-tables.c</span>
 
<span class="p_del">-CFLAGS_decode.o += -I$(OUTPUT)arch/x86/insn</span>
<span class="p_add">+CFLAGS_decode.o += -I$(OUTPUT)arch/x86/lib</span>
<span class="p_header">diff --git a/tools/objtool/arch/x86/decode.c b/tools/objtool/arch/x86/decode.c</span>
<span class="p_header">index 34a579f806e3..8acfc47af70e 100644</span>
<span class="p_header">--- a/tools/objtool/arch/x86/decode.c</span>
<span class="p_header">+++ b/tools/objtool/arch/x86/decode.c</span>
<span class="p_chunk">@@ -19,9 +19,9 @@</span> <span class="p_context"></span>
 #include &lt;stdlib.h&gt;
 
 #define unlikely(cond) (cond)
<span class="p_del">-#include &quot;insn/insn.h&quot;</span>
<span class="p_del">-#include &quot;insn/inat.c&quot;</span>
<span class="p_del">-#include &quot;insn/insn.c&quot;</span>
<span class="p_add">+#include &lt;asm/insn.h&gt;</span>
<span class="p_add">+#include &quot;lib/inat.c&quot;</span>
<span class="p_add">+#include &quot;lib/insn.c&quot;</span>
 
 #include &quot;../../elf.h&quot;
 #include &quot;../../arch.h&quot;
<span class="p_header">diff --git a/tools/objtool/arch/x86/include/asm/inat.h b/tools/objtool/arch/x86/include/asm/inat.h</span>
new file mode 100644
<span class="p_header">index 000000000000..1c78580e58be</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/objtool/arch/x86/include/asm/inat.h</span>
<span class="p_chunk">@@ -0,0 +1,244 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _ASM_X86_INAT_H</span>
<span class="p_add">+#define _ASM_X86_INAT_H</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * x86 instruction attributes</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Written by Masami Hiramatsu &lt;mhiramat@redhat.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License as published by</span>
<span class="p_add">+ * the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_add">+ * (at your option) any later version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program; if not, write to the Free Software</span>
<span class="p_add">+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
<span class="p_add">+#include &lt;asm/inat_types.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Internal bits. Don&#39;t use bitmasks directly, because these bits are</span>
<span class="p_add">+ * unstable. You should use checking functions.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define INAT_OPCODE_TABLE_SIZE 256</span>
<span class="p_add">+#define INAT_GROUP_TABLE_SIZE 8</span>
<span class="p_add">+</span>
<span class="p_add">+/* Legacy last prefixes */</span>
<span class="p_add">+#define INAT_PFX_OPNDSZ	1	/* 0x66 */ /* LPFX1 */</span>
<span class="p_add">+#define INAT_PFX_REPE	2	/* 0xF3 */ /* LPFX2 */</span>
<span class="p_add">+#define INAT_PFX_REPNE	3	/* 0xF2 */ /* LPFX3 */</span>
<span class="p_add">+/* Other Legacy prefixes */</span>
<span class="p_add">+#define INAT_PFX_LOCK	4	/* 0xF0 */</span>
<span class="p_add">+#define INAT_PFX_CS	5	/* 0x2E */</span>
<span class="p_add">+#define INAT_PFX_DS	6	/* 0x3E */</span>
<span class="p_add">+#define INAT_PFX_ES	7	/* 0x26 */</span>
<span class="p_add">+#define INAT_PFX_FS	8	/* 0x64 */</span>
<span class="p_add">+#define INAT_PFX_GS	9	/* 0x65 */</span>
<span class="p_add">+#define INAT_PFX_SS	10	/* 0x36 */</span>
<span class="p_add">+#define INAT_PFX_ADDRSZ	11	/* 0x67 */</span>
<span class="p_add">+/* x86-64 REX prefix */</span>
<span class="p_add">+#define INAT_PFX_REX	12	/* 0x4X */</span>
<span class="p_add">+/* AVX VEX prefixes */</span>
<span class="p_add">+#define INAT_PFX_VEX2	13	/* 2-bytes VEX prefix */</span>
<span class="p_add">+#define INAT_PFX_VEX3	14	/* 3-bytes VEX prefix */</span>
<span class="p_add">+#define INAT_PFX_EVEX	15	/* EVEX prefix */</span>
<span class="p_add">+</span>
<span class="p_add">+#define INAT_LSTPFX_MAX	3</span>
<span class="p_add">+#define INAT_LGCPFX_MAX	11</span>
<span class="p_add">+</span>
<span class="p_add">+/* Immediate size */</span>
<span class="p_add">+#define INAT_IMM_BYTE		1</span>
<span class="p_add">+#define INAT_IMM_WORD		2</span>
<span class="p_add">+#define INAT_IMM_DWORD		3</span>
<span class="p_add">+#define INAT_IMM_QWORD		4</span>
<span class="p_add">+#define INAT_IMM_PTR		5</span>
<span class="p_add">+#define INAT_IMM_VWORD32	6</span>
<span class="p_add">+#define INAT_IMM_VWORD		7</span>
<span class="p_add">+</span>
<span class="p_add">+/* Legacy prefix */</span>
<span class="p_add">+#define INAT_PFX_OFFS	0</span>
<span class="p_add">+#define INAT_PFX_BITS	4</span>
<span class="p_add">+#define INAT_PFX_MAX    ((1 &lt;&lt; INAT_PFX_BITS) - 1)</span>
<span class="p_add">+#define INAT_PFX_MASK	(INAT_PFX_MAX &lt;&lt; INAT_PFX_OFFS)</span>
<span class="p_add">+/* Escape opcodes */</span>
<span class="p_add">+#define INAT_ESC_OFFS	(INAT_PFX_OFFS + INAT_PFX_BITS)</span>
<span class="p_add">+#define INAT_ESC_BITS	2</span>
<span class="p_add">+#define INAT_ESC_MAX	((1 &lt;&lt; INAT_ESC_BITS) - 1)</span>
<span class="p_add">+#define INAT_ESC_MASK	(INAT_ESC_MAX &lt;&lt; INAT_ESC_OFFS)</span>
<span class="p_add">+/* Group opcodes (1-16) */</span>
<span class="p_add">+#define INAT_GRP_OFFS	(INAT_ESC_OFFS + INAT_ESC_BITS)</span>
<span class="p_add">+#define INAT_GRP_BITS	5</span>
<span class="p_add">+#define INAT_GRP_MAX	((1 &lt;&lt; INAT_GRP_BITS) - 1)</span>
<span class="p_add">+#define INAT_GRP_MASK	(INAT_GRP_MAX &lt;&lt; INAT_GRP_OFFS)</span>
<span class="p_add">+/* Immediates */</span>
<span class="p_add">+#define INAT_IMM_OFFS	(INAT_GRP_OFFS + INAT_GRP_BITS)</span>
<span class="p_add">+#define INAT_IMM_BITS	3</span>
<span class="p_add">+#define INAT_IMM_MASK	(((1 &lt;&lt; INAT_IMM_BITS) - 1) &lt;&lt; INAT_IMM_OFFS)</span>
<span class="p_add">+/* Flags */</span>
<span class="p_add">+#define INAT_FLAG_OFFS	(INAT_IMM_OFFS + INAT_IMM_BITS)</span>
<span class="p_add">+#define INAT_MODRM	(1 &lt;&lt; (INAT_FLAG_OFFS))</span>
<span class="p_add">+#define INAT_FORCE64	(1 &lt;&lt; (INAT_FLAG_OFFS + 1))</span>
<span class="p_add">+#define INAT_SCNDIMM	(1 &lt;&lt; (INAT_FLAG_OFFS + 2))</span>
<span class="p_add">+#define INAT_MOFFSET	(1 &lt;&lt; (INAT_FLAG_OFFS + 3))</span>
<span class="p_add">+#define INAT_VARIANT	(1 &lt;&lt; (INAT_FLAG_OFFS + 4))</span>
<span class="p_add">+#define INAT_VEXOK	(1 &lt;&lt; (INAT_FLAG_OFFS + 5))</span>
<span class="p_add">+#define INAT_VEXONLY	(1 &lt;&lt; (INAT_FLAG_OFFS + 6))</span>
<span class="p_add">+#define INAT_EVEXONLY	(1 &lt;&lt; (INAT_FLAG_OFFS + 7))</span>
<span class="p_add">+/* Attribute making macros for attribute tables */</span>
<span class="p_add">+#define INAT_MAKE_PREFIX(pfx)	(pfx &lt;&lt; INAT_PFX_OFFS)</span>
<span class="p_add">+#define INAT_MAKE_ESCAPE(esc)	(esc &lt;&lt; INAT_ESC_OFFS)</span>
<span class="p_add">+#define INAT_MAKE_GROUP(grp)	((grp &lt;&lt; INAT_GRP_OFFS) | INAT_MODRM)</span>
<span class="p_add">+#define INAT_MAKE_IMM(imm)	(imm &lt;&lt; INAT_IMM_OFFS)</span>
<span class="p_add">+</span>
<span class="p_add">+/* Identifiers for segment registers */</span>
<span class="p_add">+#define INAT_SEG_REG_IGNORE	0</span>
<span class="p_add">+#define INAT_SEG_REG_DEFAULT	1</span>
<span class="p_add">+#define INAT_SEG_REG_CS		2</span>
<span class="p_add">+#define INAT_SEG_REG_SS		3</span>
<span class="p_add">+#define INAT_SEG_REG_DS		4</span>
<span class="p_add">+#define INAT_SEG_REG_ES		5</span>
<span class="p_add">+#define INAT_SEG_REG_FS		6</span>
<span class="p_add">+#define INAT_SEG_REG_GS		7</span>
<span class="p_add">+</span>
<span class="p_add">+/* Attribute search APIs */</span>
<span class="p_add">+extern insn_attr_t inat_get_opcode_attribute(insn_byte_t opcode);</span>
<span class="p_add">+extern int inat_get_last_prefix_id(insn_byte_t last_pfx);</span>
<span class="p_add">+extern insn_attr_t inat_get_escape_attribute(insn_byte_t opcode,</span>
<span class="p_add">+					     int lpfx_id,</span>
<span class="p_add">+					     insn_attr_t esc_attr);</span>
<span class="p_add">+extern insn_attr_t inat_get_group_attribute(insn_byte_t modrm,</span>
<span class="p_add">+					    int lpfx_id,</span>
<span class="p_add">+					    insn_attr_t esc_attr);</span>
<span class="p_add">+extern insn_attr_t inat_get_avx_attribute(insn_byte_t opcode,</span>
<span class="p_add">+					  insn_byte_t vex_m,</span>
<span class="p_add">+					  insn_byte_t vex_pp);</span>
<span class="p_add">+</span>
<span class="p_add">+/* Attribute checking functions */</span>
<span class="p_add">+static inline int inat_is_legacy_prefix(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	attr &amp;= INAT_PFX_MASK;</span>
<span class="p_add">+	return attr &amp;&amp; attr &lt;= INAT_LGCPFX_MAX;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int inat_is_address_size_prefix(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (attr &amp; INAT_PFX_MASK) == INAT_PFX_ADDRSZ;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int inat_is_operand_size_prefix(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (attr &amp; INAT_PFX_MASK) == INAT_PFX_OPNDSZ;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int inat_is_rex_prefix(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (attr &amp; INAT_PFX_MASK) == INAT_PFX_REX;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int inat_last_prefix_id(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if ((attr &amp; INAT_PFX_MASK) &gt; INAT_LSTPFX_MAX)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return attr &amp; INAT_PFX_MASK;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int inat_is_vex_prefix(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	attr &amp;= INAT_PFX_MASK;</span>
<span class="p_add">+	return attr == INAT_PFX_VEX2 || attr == INAT_PFX_VEX3 ||</span>
<span class="p_add">+	       attr == INAT_PFX_EVEX;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int inat_is_evex_prefix(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (attr &amp; INAT_PFX_MASK) == INAT_PFX_EVEX;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int inat_is_vex3_prefix(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (attr &amp; INAT_PFX_MASK) == INAT_PFX_VEX3;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int inat_is_escape(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return attr &amp; INAT_ESC_MASK;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int inat_escape_id(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (attr &amp; INAT_ESC_MASK) &gt;&gt; INAT_ESC_OFFS;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int inat_is_group(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return attr &amp; INAT_GRP_MASK;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int inat_group_id(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (attr &amp; INAT_GRP_MASK) &gt;&gt; INAT_GRP_OFFS;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int inat_group_common_attribute(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return attr &amp; ~INAT_GRP_MASK;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int inat_has_immediate(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return attr &amp; INAT_IMM_MASK;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int inat_immediate_size(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (attr &amp; INAT_IMM_MASK) &gt;&gt; INAT_IMM_OFFS;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int inat_has_modrm(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return attr &amp; INAT_MODRM;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int inat_is_force64(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return attr &amp; INAT_FORCE64;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int inat_has_second_immediate(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return attr &amp; INAT_SCNDIMM;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int inat_has_moffset(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return attr &amp; INAT_MOFFSET;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int inat_has_variant(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return attr &amp; INAT_VARIANT;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int inat_accept_vex(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return attr &amp; INAT_VEXOK;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int inat_must_vex(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return attr &amp; (INAT_VEXONLY | INAT_EVEXONLY);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int inat_must_evex(insn_attr_t attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return attr &amp; INAT_EVEXONLY;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/tools/objtool/arch/x86/include/asm/inat_types.h b/tools/objtool/arch/x86/include/asm/inat_types.h</span>
new file mode 100644
<span class="p_header">index 000000000000..cb3c20ce39cf</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/objtool/arch/x86/include/asm/inat_types.h</span>
<span class="p_chunk">@@ -0,0 +1,29 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _ASM_X86_INAT_TYPES_H</span>
<span class="p_add">+#define _ASM_X86_INAT_TYPES_H</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * x86 instruction attributes</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Written by Masami Hiramatsu &lt;mhiramat@redhat.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License as published by</span>
<span class="p_add">+ * the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_add">+ * (at your option) any later version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program; if not, write to the Free Software</span>
<span class="p_add">+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+/* Instruction attributes */</span>
<span class="p_add">+typedef unsigned int insn_attr_t;</span>
<span class="p_add">+typedef unsigned char insn_byte_t;</span>
<span class="p_add">+typedef signed int insn_value_t;</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/tools/objtool/arch/x86/include/asm/insn.h b/tools/objtool/arch/x86/include/asm/insn.h</span>
new file mode 100644
<span class="p_header">index 000000000000..b3e32b010ab1</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/objtool/arch/x86/include/asm/insn.h</span>
<span class="p_chunk">@@ -0,0 +1,211 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _ASM_X86_INSN_H</span>
<span class="p_add">+#define _ASM_X86_INSN_H</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * x86 instruction analysis</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License as published by</span>
<span class="p_add">+ * the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_add">+ * (at your option) any later version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program; if not, write to the Free Software</span>
<span class="p_add">+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) IBM Corporation, 2009</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+/* insn_attr_t is defined in inat.h */</span>
<span class="p_add">+#include &lt;asm/inat.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+struct insn_field {</span>
<span class="p_add">+	union {</span>
<span class="p_add">+		insn_value_t value;</span>
<span class="p_add">+		insn_byte_t bytes[4];</span>
<span class="p_add">+	};</span>
<span class="p_add">+	/* !0 if we&#39;ve run insn_get_xxx() for this field */</span>
<span class="p_add">+	unsigned char got;</span>
<span class="p_add">+	unsigned char nbytes;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct insn {</span>
<span class="p_add">+	struct insn_field prefixes;	/*</span>
<span class="p_add">+					 * Prefixes</span>
<span class="p_add">+					 * prefixes.bytes[3]: last prefix</span>
<span class="p_add">+					 */</span>
<span class="p_add">+	struct insn_field rex_prefix;	/* REX prefix */</span>
<span class="p_add">+	struct insn_field vex_prefix;	/* VEX prefix */</span>
<span class="p_add">+	struct insn_field opcode;	/*</span>
<span class="p_add">+					 * opcode.bytes[0]: opcode1</span>
<span class="p_add">+					 * opcode.bytes[1]: opcode2</span>
<span class="p_add">+					 * opcode.bytes[2]: opcode3</span>
<span class="p_add">+					 */</span>
<span class="p_add">+	struct insn_field modrm;</span>
<span class="p_add">+	struct insn_field sib;</span>
<span class="p_add">+	struct insn_field displacement;</span>
<span class="p_add">+	union {</span>
<span class="p_add">+		struct insn_field immediate;</span>
<span class="p_add">+		struct insn_field moffset1;	/* for 64bit MOV */</span>
<span class="p_add">+		struct insn_field immediate1;	/* for 64bit imm or off16/32 */</span>
<span class="p_add">+	};</span>
<span class="p_add">+	union {</span>
<span class="p_add">+		struct insn_field moffset2;	/* for 64bit MOV */</span>
<span class="p_add">+		struct insn_field immediate2;	/* for 64bit imm or seg16 */</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	insn_attr_t attr;</span>
<span class="p_add">+	unsigned char opnd_bytes;</span>
<span class="p_add">+	unsigned char addr_bytes;</span>
<span class="p_add">+	unsigned char length;</span>
<span class="p_add">+	unsigned char x86_64;</span>
<span class="p_add">+</span>
<span class="p_add">+	const insn_byte_t *kaddr;	/* kernel address of insn to analyze */</span>
<span class="p_add">+	const insn_byte_t *end_kaddr;	/* kernel address of last insn in buffer */</span>
<span class="p_add">+	const insn_byte_t *next_byte;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#define MAX_INSN_SIZE	15</span>
<span class="p_add">+</span>
<span class="p_add">+#define X86_MODRM_MOD(modrm) (((modrm) &amp; 0xc0) &gt;&gt; 6)</span>
<span class="p_add">+#define X86_MODRM_REG(modrm) (((modrm) &amp; 0x38) &gt;&gt; 3)</span>
<span class="p_add">+#define X86_MODRM_RM(modrm) ((modrm) &amp; 0x07)</span>
<span class="p_add">+</span>
<span class="p_add">+#define X86_SIB_SCALE(sib) (((sib) &amp; 0xc0) &gt;&gt; 6)</span>
<span class="p_add">+#define X86_SIB_INDEX(sib) (((sib) &amp; 0x38) &gt;&gt; 3)</span>
<span class="p_add">+#define X86_SIB_BASE(sib) ((sib) &amp; 0x07)</span>
<span class="p_add">+</span>
<span class="p_add">+#define X86_REX_W(rex) ((rex) &amp; 8)</span>
<span class="p_add">+#define X86_REX_R(rex) ((rex) &amp; 4)</span>
<span class="p_add">+#define X86_REX_X(rex) ((rex) &amp; 2)</span>
<span class="p_add">+#define X86_REX_B(rex) ((rex) &amp; 1)</span>
<span class="p_add">+</span>
<span class="p_add">+/* VEX bit flags  */</span>
<span class="p_add">+#define X86_VEX_W(vex)	((vex) &amp; 0x80)	/* VEX3 Byte2 */</span>
<span class="p_add">+#define X86_VEX_R(vex)	((vex) &amp; 0x80)	/* VEX2/3 Byte1 */</span>
<span class="p_add">+#define X86_VEX_X(vex)	((vex) &amp; 0x40)	/* VEX3 Byte1 */</span>
<span class="p_add">+#define X86_VEX_B(vex)	((vex) &amp; 0x20)	/* VEX3 Byte1 */</span>
<span class="p_add">+#define X86_VEX_L(vex)	((vex) &amp; 0x04)	/* VEX3 Byte2, VEX2 Byte1 */</span>
<span class="p_add">+/* VEX bit fields */</span>
<span class="p_add">+#define X86_EVEX_M(vex)	((vex) &amp; 0x03)		/* EVEX Byte1 */</span>
<span class="p_add">+#define X86_VEX3_M(vex)	((vex) &amp; 0x1f)		/* VEX3 Byte1 */</span>
<span class="p_add">+#define X86_VEX2_M	1			/* VEX2.M always 1 */</span>
<span class="p_add">+#define X86_VEX_V(vex)	(((vex) &amp; 0x78) &gt;&gt; 3)	/* VEX3 Byte2, VEX2 Byte1 */</span>
<span class="p_add">+#define X86_VEX_P(vex)	((vex) &amp; 0x03)		/* VEX3 Byte2, VEX2 Byte1 */</span>
<span class="p_add">+#define X86_VEX_M_MAX	0x1f			/* VEX3.M Maximum value */</span>
<span class="p_add">+</span>
<span class="p_add">+extern void insn_init(struct insn *insn, const void *kaddr, int buf_len, int x86_64);</span>
<span class="p_add">+extern void insn_get_prefixes(struct insn *insn);</span>
<span class="p_add">+extern void insn_get_opcode(struct insn *insn);</span>
<span class="p_add">+extern void insn_get_modrm(struct insn *insn);</span>
<span class="p_add">+extern void insn_get_sib(struct insn *insn);</span>
<span class="p_add">+extern void insn_get_displacement(struct insn *insn);</span>
<span class="p_add">+extern void insn_get_immediate(struct insn *insn);</span>
<span class="p_add">+extern void insn_get_length(struct insn *insn);</span>
<span class="p_add">+</span>
<span class="p_add">+/* Attribute will be determined after getting ModRM (for opcode groups) */</span>
<span class="p_add">+static inline void insn_get_attribute(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	insn_get_modrm(insn);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Instruction uses RIP-relative addressing */</span>
<span class="p_add">+extern int insn_rip_relative(struct insn *insn);</span>
<span class="p_add">+</span>
<span class="p_add">+/* Init insn for kernel text */</span>
<span class="p_add">+static inline void kernel_insn_init(struct insn *insn,</span>
<span class="p_add">+				    const void *kaddr, int buf_len)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	insn_init(insn, kaddr, buf_len, 1);</span>
<span class="p_add">+#else /* CONFIG_X86_32 */</span>
<span class="p_add">+	insn_init(insn, kaddr, buf_len, 0);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int insn_is_avx(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!insn-&gt;prefixes.got)</span>
<span class="p_add">+		insn_get_prefixes(insn);</span>
<span class="p_add">+	return (insn-&gt;vex_prefix.value != 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int insn_is_evex(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!insn-&gt;prefixes.got)</span>
<span class="p_add">+		insn_get_prefixes(insn);</span>
<span class="p_add">+	return (insn-&gt;vex_prefix.nbytes == 4);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Ensure this instruction is decoded completely */</span>
<span class="p_add">+static inline int insn_complete(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return insn-&gt;opcode.got &amp;&amp; insn-&gt;modrm.got &amp;&amp; insn-&gt;sib.got &amp;&amp;</span>
<span class="p_add">+		insn-&gt;displacement.got &amp;&amp; insn-&gt;immediate.got;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline insn_byte_t insn_vex_m_bits(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (insn-&gt;vex_prefix.nbytes == 2)	/* 2 bytes VEX */</span>
<span class="p_add">+		return X86_VEX2_M;</span>
<span class="p_add">+	else if (insn-&gt;vex_prefix.nbytes == 3)	/* 3 bytes VEX */</span>
<span class="p_add">+		return X86_VEX3_M(insn-&gt;vex_prefix.bytes[1]);</span>
<span class="p_add">+	else					/* EVEX */</span>
<span class="p_add">+		return X86_EVEX_M(insn-&gt;vex_prefix.bytes[1]);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline insn_byte_t insn_vex_p_bits(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (insn-&gt;vex_prefix.nbytes == 2)	/* 2 bytes VEX */</span>
<span class="p_add">+		return X86_VEX_P(insn-&gt;vex_prefix.bytes[1]);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return X86_VEX_P(insn-&gt;vex_prefix.bytes[2]);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Get the last prefix id from last prefix or VEX prefix */</span>
<span class="p_add">+static inline int insn_last_prefix_id(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (insn_is_avx(insn))</span>
<span class="p_add">+		return insn_vex_p_bits(insn);	/* VEX_p is a SIMD prefix id */</span>
<span class="p_add">+</span>
<span class="p_add">+	if (insn-&gt;prefixes.bytes[3])</span>
<span class="p_add">+		return inat_get_last_prefix_id(insn-&gt;prefixes.bytes[3]);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Offset of each field from kaddr */</span>
<span class="p_add">+static inline int insn_offset_rex_prefix(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return insn-&gt;prefixes.nbytes;</span>
<span class="p_add">+}</span>
<span class="p_add">+static inline int insn_offset_vex_prefix(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return insn_offset_rex_prefix(insn) + insn-&gt;rex_prefix.nbytes;</span>
<span class="p_add">+}</span>
<span class="p_add">+static inline int insn_offset_opcode(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return insn_offset_vex_prefix(insn) + insn-&gt;vex_prefix.nbytes;</span>
<span class="p_add">+}</span>
<span class="p_add">+static inline int insn_offset_modrm(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return insn_offset_opcode(insn) + insn-&gt;opcode.nbytes;</span>
<span class="p_add">+}</span>
<span class="p_add">+static inline int insn_offset_sib(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return insn_offset_modrm(insn) + insn-&gt;modrm.nbytes;</span>
<span class="p_add">+}</span>
<span class="p_add">+static inline int insn_offset_displacement(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return insn_offset_sib(insn) + insn-&gt;sib.nbytes;</span>
<span class="p_add">+}</span>
<span class="p_add">+static inline int insn_offset_immediate(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return insn_offset_displacement(insn) + insn-&gt;displacement.nbytes;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _ASM_X86_INSN_H */</span>
<span class="p_header">diff --git a/tools/objtool/arch/x86/include/asm/orc_types.h b/tools/objtool/arch/x86/include/asm/orc_types.h</span>
new file mode 100644
<span class="p_header">index 000000000000..9c9dc579bd7d</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/objtool/arch/x86/include/asm/orc_types.h</span>
<span class="p_chunk">@@ -0,0 +1,107 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2017 Josh Poimboeuf &lt;jpoimboe@redhat.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ * modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ * as published by the Free Software Foundation; either version 2</span>
<span class="p_add">+ * of the License, or (at your option) any later version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef _ORC_TYPES_H</span>
<span class="p_add">+#define _ORC_TYPES_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+#include &lt;linux/compiler.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * The ORC_REG_* registers are base registers which are used to find other</span>
<span class="p_add">+ * registers on the stack.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * ORC_REG_PREV_SP, also known as DWARF Call Frame Address (CFA), is the</span>
<span class="p_add">+ * address of the previous frame: the caller&#39;s SP before it called the current</span>
<span class="p_add">+ * function.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * ORC_REG_UNDEFINED means the corresponding register&#39;s value didn&#39;t change in</span>
<span class="p_add">+ * the current frame.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The most commonly used base registers are SP and BP -- which the previous SP</span>
<span class="p_add">+ * is usually based on -- and PREV_SP and UNDEFINED -- which the previous BP is</span>
<span class="p_add">+ * usually based on.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The rest of the base registers are needed for special cases like entry code</span>
<span class="p_add">+ * and GCC realigned stacks.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define ORC_REG_UNDEFINED		0</span>
<span class="p_add">+#define ORC_REG_PREV_SP			1</span>
<span class="p_add">+#define ORC_REG_DX			2</span>
<span class="p_add">+#define ORC_REG_DI			3</span>
<span class="p_add">+#define ORC_REG_BP			4</span>
<span class="p_add">+#define ORC_REG_SP			5</span>
<span class="p_add">+#define ORC_REG_R10			6</span>
<span class="p_add">+#define ORC_REG_R13			7</span>
<span class="p_add">+#define ORC_REG_BP_INDIRECT		8</span>
<span class="p_add">+#define ORC_REG_SP_INDIRECT		9</span>
<span class="p_add">+#define ORC_REG_MAX			15</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * ORC_TYPE_CALL: Indicates that sp_reg+sp_offset resolves to PREV_SP (the</span>
<span class="p_add">+ * caller&#39;s SP right before it made the call).  Used for all callable</span>
<span class="p_add">+ * functions, i.e. all C code and all callable asm functions.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * ORC_TYPE_REGS: Used in entry code to indicate that sp_reg+sp_offset points</span>
<span class="p_add">+ * to a fully populated pt_regs from a syscall, interrupt, or exception.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * ORC_TYPE_REGS_IRET: Used in entry code to indicate that sp_reg+sp_offset</span>
<span class="p_add">+ * points to the iret return frame.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The UNWIND_HINT macros are used only for the unwind_hint struct.  They</span>
<span class="p_add">+ * aren&#39;t used in struct orc_entry due to size and complexity constraints.</span>
<span class="p_add">+ * Objtool converts them to real types when it converts the hints to orc</span>
<span class="p_add">+ * entries.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define ORC_TYPE_CALL			0</span>
<span class="p_add">+#define ORC_TYPE_REGS			1</span>
<span class="p_add">+#define ORC_TYPE_REGS_IRET		2</span>
<span class="p_add">+#define UNWIND_HINT_TYPE_SAVE		3</span>
<span class="p_add">+#define UNWIND_HINT_TYPE_RESTORE	4</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASSEMBLY__</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This struct is more or less a vastly simplified version of the DWARF Call</span>
<span class="p_add">+ * Frame Information standard.  It contains only the necessary parts of DWARF</span>
<span class="p_add">+ * CFI, simplified for ease of access by the in-kernel unwinder.  It tells the</span>
<span class="p_add">+ * unwinder how to find the previous SP and BP (and sometimes entry regs) on</span>
<span class="p_add">+ * the stack for a given code address.  Each instance of the struct corresponds</span>
<span class="p_add">+ * to one or more code locations.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct orc_entry {</span>
<span class="p_add">+	s16		sp_offset;</span>
<span class="p_add">+	s16		bp_offset;</span>
<span class="p_add">+	unsigned	sp_reg:4;</span>
<span class="p_add">+	unsigned	bp_reg:4;</span>
<span class="p_add">+	unsigned	type:2;</span>
<span class="p_add">+} __packed;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This struct is used by asm and inline asm code to manually annotate the</span>
<span class="p_add">+ * location of registers on the stack for the ORC unwinder.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Type can be either ORC_TYPE_* or UNWIND_HINT_TYPE_*.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct unwind_hint {</span>
<span class="p_add">+	u32		ip;</span>
<span class="p_add">+	s16		sp_offset;</span>
<span class="p_add">+	u8		sp_reg;</span>
<span class="p_add">+	u8		type;</span>
<span class="p_add">+};</span>
<span class="p_add">+#endif /* __ASSEMBLY__ */</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _ORC_TYPES_H */</span>
<span class="p_header">diff --git a/tools/objtool/arch/x86/insn/gen-insn-attr-x86.awk b/tools/objtool/arch/x86/insn/gen-insn-attr-x86.awk</span>
deleted file mode 100644
<span class="p_header">index b02a36b2c14f..000000000000</span>
<span class="p_header">--- a/tools/objtool/arch/x86/insn/gen-insn-attr-x86.awk</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,393 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-#!/bin/awk -f</span>
<span class="p_del">-# SPDX-License-Identifier: GPL-2.0</span>
<span class="p_del">-# gen-insn-attr-x86.awk: Instruction attribute table generator</span>
<span class="p_del">-# Written by Masami Hiramatsu &lt;mhiramat@redhat.com&gt;</span>
<span class="p_del">-#</span>
<span class="p_del">-# Usage: awk -f gen-insn-attr-x86.awk x86-opcode-map.txt &gt; inat-tables.c</span>
<span class="p_del">-</span>
<span class="p_del">-# Awk implementation sanity check</span>
<span class="p_del">-function check_awk_implement() {</span>
<span class="p_del">-	if (sprintf(&quot;%x&quot;, 0) != &quot;0&quot;)</span>
<span class="p_del">-		return &quot;Your awk has a printf-format problem.&quot;</span>
<span class="p_del">-	return &quot;&quot;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-# Clear working vars</span>
<span class="p_del">-function clear_vars() {</span>
<span class="p_del">-	delete table</span>
<span class="p_del">-	delete lptable2</span>
<span class="p_del">-	delete lptable1</span>
<span class="p_del">-	delete lptable3</span>
<span class="p_del">-	eid = -1 # escape id</span>
<span class="p_del">-	gid = -1 # group id</span>
<span class="p_del">-	aid = -1 # AVX id</span>
<span class="p_del">-	tname = &quot;&quot;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-BEGIN {</span>
<span class="p_del">-	# Implementation error checking</span>
<span class="p_del">-	awkchecked = check_awk_implement()</span>
<span class="p_del">-	if (awkchecked != &quot;&quot;) {</span>
<span class="p_del">-		print &quot;Error: &quot; awkchecked &gt; &quot;/dev/stderr&quot;</span>
<span class="p_del">-		print &quot;Please try to use gawk.&quot; &gt; &quot;/dev/stderr&quot;</span>
<span class="p_del">-		exit 1</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	# Setup generating tables</span>
<span class="p_del">-	print &quot;/* x86 opcode map generated from x86-opcode-map.txt */&quot;</span>
<span class="p_del">-	print &quot;/* Do not change this code. */\n&quot;</span>
<span class="p_del">-	ggid = 1</span>
<span class="p_del">-	geid = 1</span>
<span class="p_del">-	gaid = 0</span>
<span class="p_del">-	delete etable</span>
<span class="p_del">-	delete gtable</span>
<span class="p_del">-	delete atable</span>
<span class="p_del">-</span>
<span class="p_del">-	opnd_expr = &quot;^[A-Za-z/]&quot;</span>
<span class="p_del">-	ext_expr = &quot;^\\(&quot;</span>
<span class="p_del">-	sep_expr = &quot;^\\|$&quot;</span>
<span class="p_del">-	group_expr = &quot;^Grp[0-9A-Za-z]+&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-	imm_expr = &quot;^[IJAOL][a-z]&quot;</span>
<span class="p_del">-	imm_flag[&quot;Ib&quot;] = &quot;INAT_MAKE_IMM(INAT_IMM_BYTE)&quot;</span>
<span class="p_del">-	imm_flag[&quot;Jb&quot;] = &quot;INAT_MAKE_IMM(INAT_IMM_BYTE)&quot;</span>
<span class="p_del">-	imm_flag[&quot;Iw&quot;] = &quot;INAT_MAKE_IMM(INAT_IMM_WORD)&quot;</span>
<span class="p_del">-	imm_flag[&quot;Id&quot;] = &quot;INAT_MAKE_IMM(INAT_IMM_DWORD)&quot;</span>
<span class="p_del">-	imm_flag[&quot;Iq&quot;] = &quot;INAT_MAKE_IMM(INAT_IMM_QWORD)&quot;</span>
<span class="p_del">-	imm_flag[&quot;Ap&quot;] = &quot;INAT_MAKE_IMM(INAT_IMM_PTR)&quot;</span>
<span class="p_del">-	imm_flag[&quot;Iz&quot;] = &quot;INAT_MAKE_IMM(INAT_IMM_VWORD32)&quot;</span>
<span class="p_del">-	imm_flag[&quot;Jz&quot;] = &quot;INAT_MAKE_IMM(INAT_IMM_VWORD32)&quot;</span>
<span class="p_del">-	imm_flag[&quot;Iv&quot;] = &quot;INAT_MAKE_IMM(INAT_IMM_VWORD)&quot;</span>
<span class="p_del">-	imm_flag[&quot;Ob&quot;] = &quot;INAT_MOFFSET&quot;</span>
<span class="p_del">-	imm_flag[&quot;Ov&quot;] = &quot;INAT_MOFFSET&quot;</span>
<span class="p_del">-	imm_flag[&quot;Lx&quot;] = &quot;INAT_MAKE_IMM(INAT_IMM_BYTE)&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-	modrm_expr = &quot;^([CDEGMNPQRSUVW/][a-z]+|NTA|T[012])&quot;</span>
<span class="p_del">-	force64_expr = &quot;\\([df]64\\)&quot;</span>
<span class="p_del">-	rex_expr = &quot;^REX(\\.[XRWB]+)*&quot;</span>
<span class="p_del">-	fpu_expr = &quot;^ESC&quot; # TODO</span>
<span class="p_del">-</span>
<span class="p_del">-	lprefix1_expr = &quot;\\((66|!F3)\\)&quot;</span>
<span class="p_del">-	lprefix2_expr = &quot;\\(F3\\)&quot;</span>
<span class="p_del">-	lprefix3_expr = &quot;\\((F2|!F3|66\\&amp;F2)\\)&quot;</span>
<span class="p_del">-	lprefix_expr = &quot;\\((66|F2|F3)\\)&quot;</span>
<span class="p_del">-	max_lprefix = 4</span>
<span class="p_del">-</span>
<span class="p_del">-	# All opcodes starting with lower-case &#39;v&#39;, &#39;k&#39; or with (v1) superscript</span>
<span class="p_del">-	# accepts VEX prefix</span>
<span class="p_del">-	vexok_opcode_expr = &quot;^[vk].*&quot;</span>
<span class="p_del">-	vexok_expr = &quot;\\(v1\\)&quot;</span>
<span class="p_del">-	# All opcodes with (v) superscript supports *only* VEX prefix</span>
<span class="p_del">-	vexonly_expr = &quot;\\(v\\)&quot;</span>
<span class="p_del">-	# All opcodes with (ev) superscript supports *only* EVEX prefix</span>
<span class="p_del">-	evexonly_expr = &quot;\\(ev\\)&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-	prefix_expr = &quot;\\(Prefix\\)&quot;</span>
<span class="p_del">-	prefix_num[&quot;Operand-Size&quot;] = &quot;INAT_PFX_OPNDSZ&quot;</span>
<span class="p_del">-	prefix_num[&quot;REPNE&quot;] = &quot;INAT_PFX_REPNE&quot;</span>
<span class="p_del">-	prefix_num[&quot;REP/REPE&quot;] = &quot;INAT_PFX_REPE&quot;</span>
<span class="p_del">-	prefix_num[&quot;XACQUIRE&quot;] = &quot;INAT_PFX_REPNE&quot;</span>
<span class="p_del">-	prefix_num[&quot;XRELEASE&quot;] = &quot;INAT_PFX_REPE&quot;</span>
<span class="p_del">-	prefix_num[&quot;LOCK&quot;] = &quot;INAT_PFX_LOCK&quot;</span>
<span class="p_del">-	prefix_num[&quot;SEG=CS&quot;] = &quot;INAT_PFX_CS&quot;</span>
<span class="p_del">-	prefix_num[&quot;SEG=DS&quot;] = &quot;INAT_PFX_DS&quot;</span>
<span class="p_del">-	prefix_num[&quot;SEG=ES&quot;] = &quot;INAT_PFX_ES&quot;</span>
<span class="p_del">-	prefix_num[&quot;SEG=FS&quot;] = &quot;INAT_PFX_FS&quot;</span>
<span class="p_del">-	prefix_num[&quot;SEG=GS&quot;] = &quot;INAT_PFX_GS&quot;</span>
<span class="p_del">-	prefix_num[&quot;SEG=SS&quot;] = &quot;INAT_PFX_SS&quot;</span>
<span class="p_del">-	prefix_num[&quot;Address-Size&quot;] = &quot;INAT_PFX_ADDRSZ&quot;</span>
<span class="p_del">-	prefix_num[&quot;VEX+1byte&quot;] = &quot;INAT_PFX_VEX2&quot;</span>
<span class="p_del">-	prefix_num[&quot;VEX+2byte&quot;] = &quot;INAT_PFX_VEX3&quot;</span>
<span class="p_del">-	prefix_num[&quot;EVEX&quot;] = &quot;INAT_PFX_EVEX&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-	clear_vars()</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-function semantic_error(msg) {</span>
<span class="p_del">-	print &quot;Semantic error at &quot; NR &quot;: &quot; msg &gt; &quot;/dev/stderr&quot;</span>
<span class="p_del">-	exit 1</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-function debug(msg) {</span>
<span class="p_del">-	print &quot;DEBUG: &quot; msg</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-function array_size(arr,   i,c) {</span>
<span class="p_del">-	c = 0</span>
<span class="p_del">-	for (i in arr)</span>
<span class="p_del">-		c++</span>
<span class="p_del">-	return c</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/^Table:/ {</span>
<span class="p_del">-	print &quot;/* &quot; $0 &quot; */&quot;</span>
<span class="p_del">-	if (tname != &quot;&quot;)</span>
<span class="p_del">-		semantic_error(&quot;Hit Table: before EndTable:.&quot;);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/^Referrer:/ {</span>
<span class="p_del">-	if (NF != 1) {</span>
<span class="p_del">-		# escape opcode table</span>
<span class="p_del">-		ref = &quot;&quot;</span>
<span class="p_del">-		for (i = 2; i &lt;= NF; i++)</span>
<span class="p_del">-			ref = ref $i</span>
<span class="p_del">-		eid = escape[ref]</span>
<span class="p_del">-		tname = sprintf(&quot;inat_escape_table_%d&quot;, eid)</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/^AVXcode:/ {</span>
<span class="p_del">-	if (NF != 1) {</span>
<span class="p_del">-		# AVX/escape opcode table</span>
<span class="p_del">-		aid = $2</span>
<span class="p_del">-		if (gaid &lt;= aid)</span>
<span class="p_del">-			gaid = aid + 1</span>
<span class="p_del">-		if (tname == &quot;&quot;)	# AVX only opcode table</span>
<span class="p_del">-			tname = sprintf(&quot;inat_avx_table_%d&quot;, $2)</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (aid == -1 &amp;&amp; eid == -1)	# primary opcode table</span>
<span class="p_del">-		tname = &quot;inat_primary_table&quot;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/^GrpTable:/ {</span>
<span class="p_del">-	print &quot;/* &quot; $0 &quot; */&quot;</span>
<span class="p_del">-	if (!($2 in group))</span>
<span class="p_del">-		semantic_error(&quot;No group: &quot; $2 )</span>
<span class="p_del">-	gid = group[$2]</span>
<span class="p_del">-	tname = &quot;inat_group_table_&quot; gid</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-function print_table(tbl,name,fmt,n)</span>
<span class="p_del">-{</span>
<span class="p_del">-	print &quot;const insn_attr_t &quot; name &quot; = {&quot;</span>
<span class="p_del">-	for (i = 0; i &lt; n; i++) {</span>
<span class="p_del">-		id = sprintf(fmt, i)</span>
<span class="p_del">-		if (tbl[id])</span>
<span class="p_del">-			print &quot;	[&quot; id &quot;] = &quot; tbl[id] &quot;,&quot;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	print &quot;};&quot;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/^EndTable/ {</span>
<span class="p_del">-	if (gid != -1) {</span>
<span class="p_del">-		# print group tables</span>
<span class="p_del">-		if (array_size(table) != 0) {</span>
<span class="p_del">-			print_table(table, tname &quot;[INAT_GROUP_TABLE_SIZE]&quot;,</span>
<span class="p_del">-				    &quot;0x%x&quot;, 8)</span>
<span class="p_del">-			gtable[gid,0] = tname</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (array_size(lptable1) != 0) {</span>
<span class="p_del">-			print_table(lptable1, tname &quot;_1[INAT_GROUP_TABLE_SIZE]&quot;,</span>
<span class="p_del">-				    &quot;0x%x&quot;, 8)</span>
<span class="p_del">-			gtable[gid,1] = tname &quot;_1&quot;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (array_size(lptable2) != 0) {</span>
<span class="p_del">-			print_table(lptable2, tname &quot;_2[INAT_GROUP_TABLE_SIZE]&quot;,</span>
<span class="p_del">-				    &quot;0x%x&quot;, 8)</span>
<span class="p_del">-			gtable[gid,2] = tname &quot;_2&quot;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (array_size(lptable3) != 0) {</span>
<span class="p_del">-			print_table(lptable3, tname &quot;_3[INAT_GROUP_TABLE_SIZE]&quot;,</span>
<span class="p_del">-				    &quot;0x%x&quot;, 8)</span>
<span class="p_del">-			gtable[gid,3] = tname &quot;_3&quot;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		# print primary/escaped tables</span>
<span class="p_del">-		if (array_size(table) != 0) {</span>
<span class="p_del">-			print_table(table, tname &quot;[INAT_OPCODE_TABLE_SIZE]&quot;,</span>
<span class="p_del">-				    &quot;0x%02x&quot;, 256)</span>
<span class="p_del">-			etable[eid,0] = tname</span>
<span class="p_del">-			if (aid &gt;= 0)</span>
<span class="p_del">-				atable[aid,0] = tname</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (array_size(lptable1) != 0) {</span>
<span class="p_del">-			print_table(lptable1,tname &quot;_1[INAT_OPCODE_TABLE_SIZE]&quot;,</span>
<span class="p_del">-				    &quot;0x%02x&quot;, 256)</span>
<span class="p_del">-			etable[eid,1] = tname &quot;_1&quot;</span>
<span class="p_del">-			if (aid &gt;= 0)</span>
<span class="p_del">-				atable[aid,1] = tname &quot;_1&quot;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (array_size(lptable2) != 0) {</span>
<span class="p_del">-			print_table(lptable2,tname &quot;_2[INAT_OPCODE_TABLE_SIZE]&quot;,</span>
<span class="p_del">-				    &quot;0x%02x&quot;, 256)</span>
<span class="p_del">-			etable[eid,2] = tname &quot;_2&quot;</span>
<span class="p_del">-			if (aid &gt;= 0)</span>
<span class="p_del">-				atable[aid,2] = tname &quot;_2&quot;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (array_size(lptable3) != 0) {</span>
<span class="p_del">-			print_table(lptable3,tname &quot;_3[INAT_OPCODE_TABLE_SIZE]&quot;,</span>
<span class="p_del">-				    &quot;0x%02x&quot;, 256)</span>
<span class="p_del">-			etable[eid,3] = tname &quot;_3&quot;</span>
<span class="p_del">-			if (aid &gt;= 0)</span>
<span class="p_del">-				atable[aid,3] = tname &quot;_3&quot;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	print &quot;&quot;</span>
<span class="p_del">-	clear_vars()</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-function add_flags(old,new) {</span>
<span class="p_del">-	if (old &amp;&amp; new)</span>
<span class="p_del">-		return old &quot; | &quot; new</span>
<span class="p_del">-	else if (old)</span>
<span class="p_del">-		return old</span>
<span class="p_del">-	else</span>
<span class="p_del">-		return new</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-# convert operands to flags.</span>
<span class="p_del">-function convert_operands(count,opnd,       i,j,imm,mod)</span>
<span class="p_del">-{</span>
<span class="p_del">-	imm = null</span>
<span class="p_del">-	mod = null</span>
<span class="p_del">-	for (j = 1; j &lt;= count; j++) {</span>
<span class="p_del">-		i = opnd[j]</span>
<span class="p_del">-		if (match(i, imm_expr) == 1) {</span>
<span class="p_del">-			if (!imm_flag[i])</span>
<span class="p_del">-				semantic_error(&quot;Unknown imm opnd: &quot; i)</span>
<span class="p_del">-			if (imm) {</span>
<span class="p_del">-				if (i != &quot;Ib&quot;)</span>
<span class="p_del">-					semantic_error(&quot;Second IMM error&quot;)</span>
<span class="p_del">-				imm = add_flags(imm, &quot;INAT_SCNDIMM&quot;)</span>
<span class="p_del">-			} else</span>
<span class="p_del">-				imm = imm_flag[i]</span>
<span class="p_del">-		} else if (match(i, modrm_expr))</span>
<span class="p_del">-			mod = &quot;INAT_MODRM&quot;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return add_flags(imm, mod)</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/^[0-9a-f]+\:/ {</span>
<span class="p_del">-	if (NR == 1)</span>
<span class="p_del">-		next</span>
<span class="p_del">-	# get index</span>
<span class="p_del">-	idx = &quot;0x&quot; substr($1, 1, index($1,&quot;:&quot;) - 1)</span>
<span class="p_del">-	if (idx in table)</span>
<span class="p_del">-		semantic_error(&quot;Redefine &quot; idx &quot; in &quot; tname)</span>
<span class="p_del">-</span>
<span class="p_del">-	# check if escaped opcode</span>
<span class="p_del">-	if (&quot;escape&quot; == $2) {</span>
<span class="p_del">-		if ($3 != &quot;#&quot;)</span>
<span class="p_del">-			semantic_error(&quot;No escaped name&quot;)</span>
<span class="p_del">-		ref = &quot;&quot;</span>
<span class="p_del">-		for (i = 4; i &lt;= NF; i++)</span>
<span class="p_del">-			ref = ref $i</span>
<span class="p_del">-		if (ref in escape)</span>
<span class="p_del">-			semantic_error(&quot;Redefine escape (&quot; ref &quot;)&quot;)</span>
<span class="p_del">-		escape[ref] = geid</span>
<span class="p_del">-		geid++</span>
<span class="p_del">-		table[idx] = &quot;INAT_MAKE_ESCAPE(&quot; escape[ref] &quot;)&quot;</span>
<span class="p_del">-		next</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	variant = null</span>
<span class="p_del">-	# converts</span>
<span class="p_del">-	i = 2</span>
<span class="p_del">-	while (i &lt;= NF) {</span>
<span class="p_del">-		opcode = $(i++)</span>
<span class="p_del">-		delete opnds</span>
<span class="p_del">-		ext = null</span>
<span class="p_del">-		flags = null</span>
<span class="p_del">-		opnd = null</span>
<span class="p_del">-		# parse one opcode</span>
<span class="p_del">-		if (match($i, opnd_expr)) {</span>
<span class="p_del">-			opnd = $i</span>
<span class="p_del">-			count = split($(i++), opnds, &quot;,&quot;)</span>
<span class="p_del">-			flags = convert_operands(count, opnds)</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (match($i, ext_expr))</span>
<span class="p_del">-			ext = $(i++)</span>
<span class="p_del">-		if (match($i, sep_expr))</span>
<span class="p_del">-			i++</span>
<span class="p_del">-		else if (i &lt; NF)</span>
<span class="p_del">-			semantic_error($i &quot; is not a separator&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-		# check if group opcode</span>
<span class="p_del">-		if (match(opcode, group_expr)) {</span>
<span class="p_del">-			if (!(opcode in group)) {</span>
<span class="p_del">-				group[opcode] = ggid</span>
<span class="p_del">-				ggid++</span>
<span class="p_del">-			}</span>
<span class="p_del">-			flags = add_flags(flags, &quot;INAT_MAKE_GROUP(&quot; group[opcode] &quot;)&quot;)</span>
<span class="p_del">-		}</span>
<span class="p_del">-		# check force(or default) 64bit</span>
<span class="p_del">-		if (match(ext, force64_expr))</span>
<span class="p_del">-			flags = add_flags(flags, &quot;INAT_FORCE64&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-		# check REX prefix</span>
<span class="p_del">-		if (match(opcode, rex_expr))</span>
<span class="p_del">-			flags = add_flags(flags, &quot;INAT_MAKE_PREFIX(INAT_PFX_REX)&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-		# check coprocessor escape : TODO</span>
<span class="p_del">-		if (match(opcode, fpu_expr))</span>
<span class="p_del">-			flags = add_flags(flags, &quot;INAT_MODRM&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-		# check VEX codes</span>
<span class="p_del">-		if (match(ext, evexonly_expr))</span>
<span class="p_del">-			flags = add_flags(flags, &quot;INAT_VEXOK | INAT_EVEXONLY&quot;)</span>
<span class="p_del">-		else if (match(ext, vexonly_expr))</span>
<span class="p_del">-			flags = add_flags(flags, &quot;INAT_VEXOK | INAT_VEXONLY&quot;)</span>
<span class="p_del">-		else if (match(ext, vexok_expr) || match(opcode, vexok_opcode_expr))</span>
<span class="p_del">-			flags = add_flags(flags, &quot;INAT_VEXOK&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-		# check prefixes</span>
<span class="p_del">-		if (match(ext, prefix_expr)) {</span>
<span class="p_del">-			if (!prefix_num[opcode])</span>
<span class="p_del">-				semantic_error(&quot;Unknown prefix: &quot; opcode)</span>
<span class="p_del">-			flags = add_flags(flags, &quot;INAT_MAKE_PREFIX(&quot; prefix_num[opcode] &quot;)&quot;)</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (length(flags) == 0)</span>
<span class="p_del">-			continue</span>
<span class="p_del">-		# check if last prefix</span>
<span class="p_del">-		if (match(ext, lprefix1_expr)) {</span>
<span class="p_del">-			lptable1[idx] = add_flags(lptable1[idx],flags)</span>
<span class="p_del">-			variant = &quot;INAT_VARIANT&quot;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (match(ext, lprefix2_expr)) {</span>
<span class="p_del">-			lptable2[idx] = add_flags(lptable2[idx],flags)</span>
<span class="p_del">-			variant = &quot;INAT_VARIANT&quot;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (match(ext, lprefix3_expr)) {</span>
<span class="p_del">-			lptable3[idx] = add_flags(lptable3[idx],flags)</span>
<span class="p_del">-			variant = &quot;INAT_VARIANT&quot;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (!match(ext, lprefix_expr)){</span>
<span class="p_del">-			table[idx] = add_flags(table[idx],flags)</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (variant)</span>
<span class="p_del">-		table[idx] = add_flags(table[idx],variant)</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-END {</span>
<span class="p_del">-	if (awkchecked != &quot;&quot;)</span>
<span class="p_del">-		exit 1</span>
<span class="p_del">-	# print escape opcode map&#39;s array</span>
<span class="p_del">-	print &quot;/* Escape opcode map array */&quot;</span>
<span class="p_del">-	print &quot;const insn_attr_t * const inat_escape_tables[INAT_ESC_MAX + 1]&quot; \</span>
<span class="p_del">-	      &quot;[INAT_LSTPFX_MAX + 1] = {&quot;</span>
<span class="p_del">-	for (i = 0; i &lt; geid; i++)</span>
<span class="p_del">-		for (j = 0; j &lt; max_lprefix; j++)</span>
<span class="p_del">-			if (etable[i,j])</span>
<span class="p_del">-				print &quot;	[&quot;i&quot;][&quot;j&quot;] = &quot;etable[i,j]&quot;,&quot;</span>
<span class="p_del">-	print &quot;};\n&quot;</span>
<span class="p_del">-	# print group opcode map&#39;s array</span>
<span class="p_del">-	print &quot;/* Group opcode map array */&quot;</span>
<span class="p_del">-	print &quot;const insn_attr_t * const inat_group_tables[INAT_GRP_MAX + 1]&quot;\</span>
<span class="p_del">-	      &quot;[INAT_LSTPFX_MAX + 1] = {&quot;</span>
<span class="p_del">-	for (i = 0; i &lt; ggid; i++)</span>
<span class="p_del">-		for (j = 0; j &lt; max_lprefix; j++)</span>
<span class="p_del">-			if (gtable[i,j])</span>
<span class="p_del">-				print &quot;	[&quot;i&quot;][&quot;j&quot;] = &quot;gtable[i,j]&quot;,&quot;</span>
<span class="p_del">-	print &quot;};\n&quot;</span>
<span class="p_del">-	# print AVX opcode map&#39;s array</span>
<span class="p_del">-	print &quot;/* AVX opcode map array */&quot;</span>
<span class="p_del">-	print &quot;const insn_attr_t * const inat_avx_tables[X86_VEX_M_MAX + 1]&quot;\</span>
<span class="p_del">-	      &quot;[INAT_LSTPFX_MAX + 1] = {&quot;</span>
<span class="p_del">-	for (i = 0; i &lt; gaid; i++)</span>
<span class="p_del">-		for (j = 0; j &lt; max_lprefix; j++)</span>
<span class="p_del">-			if (atable[i,j])</span>
<span class="p_del">-				print &quot;	[&quot;i&quot;][&quot;j&quot;] = &quot;atable[i,j]&quot;,&quot;</span>
<span class="p_del">-	print &quot;};&quot;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_header">diff --git a/tools/objtool/arch/x86/insn/inat.c b/tools/objtool/arch/x86/insn/inat.c</span>
deleted file mode 100644
<span class="p_header">index e4bf28e6f4c7..000000000000</span>
<span class="p_header">--- a/tools/objtool/arch/x86/insn/inat.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,97 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- * x86 instruction attribute tables</span>
<span class="p_del">- *</span>
<span class="p_del">- * Written by Masami Hiramatsu &lt;mhiramat@redhat.com&gt;</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is free software; you can redistribute it and/or modify</span>
<span class="p_del">- * it under the terms of the GNU General Public License as published by</span>
<span class="p_del">- * the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_del">- * (at your option) any later version.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is distributed in the hope that it will be useful,</span>
<span class="p_del">- * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_del">- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_del">- * GNU General Public License for more details.</span>
<span class="p_del">- *</span>
<span class="p_del">- * You should have received a copy of the GNU General Public License</span>
<span class="p_del">- * along with this program; if not, write to the Free Software</span>
<span class="p_del">- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="p_del">- *</span>
<span class="p_del">- */</span>
<span class="p_del">-#include &quot;insn.h&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-/* Attribute tables are generated from opcode map */</span>
<span class="p_del">-#include &quot;inat-tables.c&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-/* Attribute search APIs */</span>
<span class="p_del">-insn_attr_t inat_get_opcode_attribute(insn_byte_t opcode)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return inat_primary_table[opcode];</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int inat_get_last_prefix_id(insn_byte_t last_pfx)</span>
<span class="p_del">-{</span>
<span class="p_del">-	insn_attr_t lpfx_attr;</span>
<span class="p_del">-</span>
<span class="p_del">-	lpfx_attr = inat_get_opcode_attribute(last_pfx);</span>
<span class="p_del">-	return inat_last_prefix_id(lpfx_attr);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-insn_attr_t inat_get_escape_attribute(insn_byte_t opcode, int lpfx_id,</span>
<span class="p_del">-				      insn_attr_t esc_attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	const insn_attr_t *table;</span>
<span class="p_del">-	int n;</span>
<span class="p_del">-</span>
<span class="p_del">-	n = inat_escape_id(esc_attr);</span>
<span class="p_del">-</span>
<span class="p_del">-	table = inat_escape_tables[n][0];</span>
<span class="p_del">-	if (!table)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	if (inat_has_variant(table[opcode]) &amp;&amp; lpfx_id) {</span>
<span class="p_del">-		table = inat_escape_tables[n][lpfx_id];</span>
<span class="p_del">-		if (!table)</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return table[opcode];</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-insn_attr_t inat_get_group_attribute(insn_byte_t modrm, int lpfx_id,</span>
<span class="p_del">-				     insn_attr_t grp_attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	const insn_attr_t *table;</span>
<span class="p_del">-	int n;</span>
<span class="p_del">-</span>
<span class="p_del">-	n = inat_group_id(grp_attr);</span>
<span class="p_del">-</span>
<span class="p_del">-	table = inat_group_tables[n][0];</span>
<span class="p_del">-	if (!table)</span>
<span class="p_del">-		return inat_group_common_attribute(grp_attr);</span>
<span class="p_del">-	if (inat_has_variant(table[X86_MODRM_REG(modrm)]) &amp;&amp; lpfx_id) {</span>
<span class="p_del">-		table = inat_group_tables[n][lpfx_id];</span>
<span class="p_del">-		if (!table)</span>
<span class="p_del">-			return inat_group_common_attribute(grp_attr);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return table[X86_MODRM_REG(modrm)] |</span>
<span class="p_del">-	       inat_group_common_attribute(grp_attr);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-insn_attr_t inat_get_avx_attribute(insn_byte_t opcode, insn_byte_t vex_m,</span>
<span class="p_del">-				   insn_byte_t vex_p)</span>
<span class="p_del">-{</span>
<span class="p_del">-	const insn_attr_t *table;</span>
<span class="p_del">-	if (vex_m &gt; X86_VEX_M_MAX || vex_p &gt; INAT_LSTPFX_MAX)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	/* At first, this checks the master table */</span>
<span class="p_del">-	table = inat_avx_tables[vex_m][0];</span>
<span class="p_del">-	if (!table)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	if (!inat_is_group(table[opcode]) &amp;&amp; vex_p) {</span>
<span class="p_del">-		/* If this is not a group, get attribute directly */</span>
<span class="p_del">-		table = inat_avx_tables[vex_m][vex_p];</span>
<span class="p_del">-		if (!table)</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return table[opcode];</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_header">diff --git a/tools/objtool/arch/x86/insn/inat.h b/tools/objtool/arch/x86/insn/inat.h</span>
deleted file mode 100644
<span class="p_header">index 125ecd2a300d..000000000000</span>
<span class="p_header">--- a/tools/objtool/arch/x86/insn/inat.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,234 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-#ifndef _ASM_X86_INAT_H</span>
<span class="p_del">-#define _ASM_X86_INAT_H</span>
<span class="p_del">-/*</span>
<span class="p_del">- * x86 instruction attributes</span>
<span class="p_del">- *</span>
<span class="p_del">- * Written by Masami Hiramatsu &lt;mhiramat@redhat.com&gt;</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is free software; you can redistribute it and/or modify</span>
<span class="p_del">- * it under the terms of the GNU General Public License as published by</span>
<span class="p_del">- * the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_del">- * (at your option) any later version.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is distributed in the hope that it will be useful,</span>
<span class="p_del">- * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_del">- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_del">- * GNU General Public License for more details.</span>
<span class="p_del">- *</span>
<span class="p_del">- * You should have received a copy of the GNU General Public License</span>
<span class="p_del">- * along with this program; if not, write to the Free Software</span>
<span class="p_del">- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="p_del">- *</span>
<span class="p_del">- */</span>
<span class="p_del">-#include &quot;inat_types.h&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Internal bits. Don&#39;t use bitmasks directly, because these bits are</span>
<span class="p_del">- * unstable. You should use checking functions.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-#define INAT_OPCODE_TABLE_SIZE 256</span>
<span class="p_del">-#define INAT_GROUP_TABLE_SIZE 8</span>
<span class="p_del">-</span>
<span class="p_del">-/* Legacy last prefixes */</span>
<span class="p_del">-#define INAT_PFX_OPNDSZ	1	/* 0x66 */ /* LPFX1 */</span>
<span class="p_del">-#define INAT_PFX_REPE	2	/* 0xF3 */ /* LPFX2 */</span>
<span class="p_del">-#define INAT_PFX_REPNE	3	/* 0xF2 */ /* LPFX3 */</span>
<span class="p_del">-/* Other Legacy prefixes */</span>
<span class="p_del">-#define INAT_PFX_LOCK	4	/* 0xF0 */</span>
<span class="p_del">-#define INAT_PFX_CS	5	/* 0x2E */</span>
<span class="p_del">-#define INAT_PFX_DS	6	/* 0x3E */</span>
<span class="p_del">-#define INAT_PFX_ES	7	/* 0x26 */</span>
<span class="p_del">-#define INAT_PFX_FS	8	/* 0x64 */</span>
<span class="p_del">-#define INAT_PFX_GS	9	/* 0x65 */</span>
<span class="p_del">-#define INAT_PFX_SS	10	/* 0x36 */</span>
<span class="p_del">-#define INAT_PFX_ADDRSZ	11	/* 0x67 */</span>
<span class="p_del">-/* x86-64 REX prefix */</span>
<span class="p_del">-#define INAT_PFX_REX	12	/* 0x4X */</span>
<span class="p_del">-/* AVX VEX prefixes */</span>
<span class="p_del">-#define INAT_PFX_VEX2	13	/* 2-bytes VEX prefix */</span>
<span class="p_del">-#define INAT_PFX_VEX3	14	/* 3-bytes VEX prefix */</span>
<span class="p_del">-#define INAT_PFX_EVEX	15	/* EVEX prefix */</span>
<span class="p_del">-</span>
<span class="p_del">-#define INAT_LSTPFX_MAX	3</span>
<span class="p_del">-#define INAT_LGCPFX_MAX	11</span>
<span class="p_del">-</span>
<span class="p_del">-/* Immediate size */</span>
<span class="p_del">-#define INAT_IMM_BYTE		1</span>
<span class="p_del">-#define INAT_IMM_WORD		2</span>
<span class="p_del">-#define INAT_IMM_DWORD		3</span>
<span class="p_del">-#define INAT_IMM_QWORD		4</span>
<span class="p_del">-#define INAT_IMM_PTR		5</span>
<span class="p_del">-#define INAT_IMM_VWORD32	6</span>
<span class="p_del">-#define INAT_IMM_VWORD		7</span>
<span class="p_del">-</span>
<span class="p_del">-/* Legacy prefix */</span>
<span class="p_del">-#define INAT_PFX_OFFS	0</span>
<span class="p_del">-#define INAT_PFX_BITS	4</span>
<span class="p_del">-#define INAT_PFX_MAX    ((1 &lt;&lt; INAT_PFX_BITS) - 1)</span>
<span class="p_del">-#define INAT_PFX_MASK	(INAT_PFX_MAX &lt;&lt; INAT_PFX_OFFS)</span>
<span class="p_del">-/* Escape opcodes */</span>
<span class="p_del">-#define INAT_ESC_OFFS	(INAT_PFX_OFFS + INAT_PFX_BITS)</span>
<span class="p_del">-#define INAT_ESC_BITS	2</span>
<span class="p_del">-#define INAT_ESC_MAX	((1 &lt;&lt; INAT_ESC_BITS) - 1)</span>
<span class="p_del">-#define INAT_ESC_MASK	(INAT_ESC_MAX &lt;&lt; INAT_ESC_OFFS)</span>
<span class="p_del">-/* Group opcodes (1-16) */</span>
<span class="p_del">-#define INAT_GRP_OFFS	(INAT_ESC_OFFS + INAT_ESC_BITS)</span>
<span class="p_del">-#define INAT_GRP_BITS	5</span>
<span class="p_del">-#define INAT_GRP_MAX	((1 &lt;&lt; INAT_GRP_BITS) - 1)</span>
<span class="p_del">-#define INAT_GRP_MASK	(INAT_GRP_MAX &lt;&lt; INAT_GRP_OFFS)</span>
<span class="p_del">-/* Immediates */</span>
<span class="p_del">-#define INAT_IMM_OFFS	(INAT_GRP_OFFS + INAT_GRP_BITS)</span>
<span class="p_del">-#define INAT_IMM_BITS	3</span>
<span class="p_del">-#define INAT_IMM_MASK	(((1 &lt;&lt; INAT_IMM_BITS) - 1) &lt;&lt; INAT_IMM_OFFS)</span>
<span class="p_del">-/* Flags */</span>
<span class="p_del">-#define INAT_FLAG_OFFS	(INAT_IMM_OFFS + INAT_IMM_BITS)</span>
<span class="p_del">-#define INAT_MODRM	(1 &lt;&lt; (INAT_FLAG_OFFS))</span>
<span class="p_del">-#define INAT_FORCE64	(1 &lt;&lt; (INAT_FLAG_OFFS + 1))</span>
<span class="p_del">-#define INAT_SCNDIMM	(1 &lt;&lt; (INAT_FLAG_OFFS + 2))</span>
<span class="p_del">-#define INAT_MOFFSET	(1 &lt;&lt; (INAT_FLAG_OFFS + 3))</span>
<span class="p_del">-#define INAT_VARIANT	(1 &lt;&lt; (INAT_FLAG_OFFS + 4))</span>
<span class="p_del">-#define INAT_VEXOK	(1 &lt;&lt; (INAT_FLAG_OFFS + 5))</span>
<span class="p_del">-#define INAT_VEXONLY	(1 &lt;&lt; (INAT_FLAG_OFFS + 6))</span>
<span class="p_del">-#define INAT_EVEXONLY	(1 &lt;&lt; (INAT_FLAG_OFFS + 7))</span>
<span class="p_del">-/* Attribute making macros for attribute tables */</span>
<span class="p_del">-#define INAT_MAKE_PREFIX(pfx)	(pfx &lt;&lt; INAT_PFX_OFFS)</span>
<span class="p_del">-#define INAT_MAKE_ESCAPE(esc)	(esc &lt;&lt; INAT_ESC_OFFS)</span>
<span class="p_del">-#define INAT_MAKE_GROUP(grp)	((grp &lt;&lt; INAT_GRP_OFFS) | INAT_MODRM)</span>
<span class="p_del">-#define INAT_MAKE_IMM(imm)	(imm &lt;&lt; INAT_IMM_OFFS)</span>
<span class="p_del">-</span>
<span class="p_del">-/* Attribute search APIs */</span>
<span class="p_del">-extern insn_attr_t inat_get_opcode_attribute(insn_byte_t opcode);</span>
<span class="p_del">-extern int inat_get_last_prefix_id(insn_byte_t last_pfx);</span>
<span class="p_del">-extern insn_attr_t inat_get_escape_attribute(insn_byte_t opcode,</span>
<span class="p_del">-					     int lpfx_id,</span>
<span class="p_del">-					     insn_attr_t esc_attr);</span>
<span class="p_del">-extern insn_attr_t inat_get_group_attribute(insn_byte_t modrm,</span>
<span class="p_del">-					    int lpfx_id,</span>
<span class="p_del">-					    insn_attr_t esc_attr);</span>
<span class="p_del">-extern insn_attr_t inat_get_avx_attribute(insn_byte_t opcode,</span>
<span class="p_del">-					  insn_byte_t vex_m,</span>
<span class="p_del">-					  insn_byte_t vex_pp);</span>
<span class="p_del">-</span>
<span class="p_del">-/* Attribute checking functions */</span>
<span class="p_del">-static inline int inat_is_legacy_prefix(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	attr &amp;= INAT_PFX_MASK;</span>
<span class="p_del">-	return attr &amp;&amp; attr &lt;= INAT_LGCPFX_MAX;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int inat_is_address_size_prefix(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (attr &amp; INAT_PFX_MASK) == INAT_PFX_ADDRSZ;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int inat_is_operand_size_prefix(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (attr &amp; INAT_PFX_MASK) == INAT_PFX_OPNDSZ;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int inat_is_rex_prefix(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (attr &amp; INAT_PFX_MASK) == INAT_PFX_REX;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int inat_last_prefix_id(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if ((attr &amp; INAT_PFX_MASK) &gt; INAT_LSTPFX_MAX)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		return attr &amp; INAT_PFX_MASK;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int inat_is_vex_prefix(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	attr &amp;= INAT_PFX_MASK;</span>
<span class="p_del">-	return attr == INAT_PFX_VEX2 || attr == INAT_PFX_VEX3 ||</span>
<span class="p_del">-	       attr == INAT_PFX_EVEX;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int inat_is_evex_prefix(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (attr &amp; INAT_PFX_MASK) == INAT_PFX_EVEX;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int inat_is_vex3_prefix(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (attr &amp; INAT_PFX_MASK) == INAT_PFX_VEX3;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int inat_is_escape(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return attr &amp; INAT_ESC_MASK;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int inat_escape_id(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (attr &amp; INAT_ESC_MASK) &gt;&gt; INAT_ESC_OFFS;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int inat_is_group(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return attr &amp; INAT_GRP_MASK;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int inat_group_id(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (attr &amp; INAT_GRP_MASK) &gt;&gt; INAT_GRP_OFFS;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int inat_group_common_attribute(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return attr &amp; ~INAT_GRP_MASK;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int inat_has_immediate(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return attr &amp; INAT_IMM_MASK;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int inat_immediate_size(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (attr &amp; INAT_IMM_MASK) &gt;&gt; INAT_IMM_OFFS;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int inat_has_modrm(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return attr &amp; INAT_MODRM;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int inat_is_force64(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return attr &amp; INAT_FORCE64;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int inat_has_second_immediate(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return attr &amp; INAT_SCNDIMM;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int inat_has_moffset(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return attr &amp; INAT_MOFFSET;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int inat_has_variant(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return attr &amp; INAT_VARIANT;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int inat_accept_vex(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return attr &amp; INAT_VEXOK;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int inat_must_vex(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return attr &amp; (INAT_VEXONLY | INAT_EVEXONLY);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int inat_must_evex(insn_attr_t attr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return attr &amp; INAT_EVEXONLY;</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_header">diff --git a/tools/objtool/arch/x86/insn/inat_types.h b/tools/objtool/arch/x86/insn/inat_types.h</span>
deleted file mode 100644
<span class="p_header">index cb3c20ce39cf..000000000000</span>
<span class="p_header">--- a/tools/objtool/arch/x86/insn/inat_types.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,29 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-#ifndef _ASM_X86_INAT_TYPES_H</span>
<span class="p_del">-#define _ASM_X86_INAT_TYPES_H</span>
<span class="p_del">-/*</span>
<span class="p_del">- * x86 instruction attributes</span>
<span class="p_del">- *</span>
<span class="p_del">- * Written by Masami Hiramatsu &lt;mhiramat@redhat.com&gt;</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is free software; you can redistribute it and/or modify</span>
<span class="p_del">- * it under the terms of the GNU General Public License as published by</span>
<span class="p_del">- * the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_del">- * (at your option) any later version.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is distributed in the hope that it will be useful,</span>
<span class="p_del">- * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_del">- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_del">- * GNU General Public License for more details.</span>
<span class="p_del">- *</span>
<span class="p_del">- * You should have received a copy of the GNU General Public License</span>
<span class="p_del">- * along with this program; if not, write to the Free Software</span>
<span class="p_del">- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="p_del">- *</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-/* Instruction attributes */</span>
<span class="p_del">-typedef unsigned int insn_attr_t;</span>
<span class="p_del">-typedef unsigned char insn_byte_t;</span>
<span class="p_del">-typedef signed int insn_value_t;</span>
<span class="p_del">-</span>
<span class="p_del">-#endif</span>
<span class="p_header">diff --git a/tools/objtool/arch/x86/insn/insn.c b/tools/objtool/arch/x86/insn/insn.c</span>
deleted file mode 100644
<span class="p_header">index ca983e2bea8b..000000000000</span>
<span class="p_header">--- a/tools/objtool/arch/x86/insn/insn.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,606 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- * x86 instruction analysis</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is free software; you can redistribute it and/or modify</span>
<span class="p_del">- * it under the terms of the GNU General Public License as published by</span>
<span class="p_del">- * the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_del">- * (at your option) any later version.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is distributed in the hope that it will be useful,</span>
<span class="p_del">- * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_del">- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_del">- * GNU General Public License for more details.</span>
<span class="p_del">- *</span>
<span class="p_del">- * You should have received a copy of the GNU General Public License</span>
<span class="p_del">- * along with this program; if not, write to the Free Software</span>
<span class="p_del">- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Copyright (C) IBM Corporation, 2002, 2004, 2009</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef __KERNEL__</span>
<span class="p_del">-#include &lt;linux/string.h&gt;</span>
<span class="p_del">-#else</span>
<span class="p_del">-#include &lt;string.h&gt;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-#include &quot;inat.h&quot;</span>
<span class="p_del">-#include &quot;insn.h&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-/* Verify next sizeof(t) bytes can be on the same instruction */</span>
<span class="p_del">-#define validate_next(t, insn, n)	\</span>
<span class="p_del">-	((insn)-&gt;next_byte + sizeof(t) + n &lt;= (insn)-&gt;end_kaddr)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __get_next(t, insn)	\</span>
<span class="p_del">-	({ t r = *(t*)insn-&gt;next_byte; insn-&gt;next_byte += sizeof(t); r; })</span>
<span class="p_del">-</span>
<span class="p_del">-#define __peek_nbyte_next(t, insn, n)	\</span>
<span class="p_del">-	({ t r = *(t*)((insn)-&gt;next_byte + n); r; })</span>
<span class="p_del">-</span>
<span class="p_del">-#define get_next(t, insn)	\</span>
<span class="p_del">-	({ if (unlikely(!validate_next(t, insn, 0))) goto err_out; __get_next(t, insn); })</span>
<span class="p_del">-</span>
<span class="p_del">-#define peek_nbyte_next(t, insn, n)	\</span>
<span class="p_del">-	({ if (unlikely(!validate_next(t, insn, n))) goto err_out; __peek_nbyte_next(t, insn, n); })</span>
<span class="p_del">-</span>
<span class="p_del">-#define peek_next(t, insn)	peek_nbyte_next(t, insn, 0)</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * insn_init() - initialize struct insn</span>
<span class="p_del">- * @insn:	&amp;struct insn to be initialized</span>
<span class="p_del">- * @kaddr:	address (in kernel memory) of instruction (or copy thereof)</span>
<span class="p_del">- * @x86_64:	!0 for 64-bit kernel or 64-bit app</span>
<span class="p_del">- */</span>
<span class="p_del">-void insn_init(struct insn *insn, const void *kaddr, int buf_len, int x86_64)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Instructions longer than MAX_INSN_SIZE (15 bytes) are invalid</span>
<span class="p_del">-	 * even if the input buffer is long enough to hold them.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (buf_len &gt; MAX_INSN_SIZE)</span>
<span class="p_del">-		buf_len = MAX_INSN_SIZE;</span>
<span class="p_del">-</span>
<span class="p_del">-	memset(insn, 0, sizeof(*insn));</span>
<span class="p_del">-	insn-&gt;kaddr = kaddr;</span>
<span class="p_del">-	insn-&gt;end_kaddr = kaddr + buf_len;</span>
<span class="p_del">-	insn-&gt;next_byte = kaddr;</span>
<span class="p_del">-	insn-&gt;x86_64 = x86_64 ? 1 : 0;</span>
<span class="p_del">-	insn-&gt;opnd_bytes = 4;</span>
<span class="p_del">-	if (x86_64)</span>
<span class="p_del">-		insn-&gt;addr_bytes = 8;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		insn-&gt;addr_bytes = 4;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * insn_get_prefixes - scan x86 instruction prefix bytes</span>
<span class="p_del">- * @insn:	&amp;struct insn containing instruction</span>
<span class="p_del">- *</span>
<span class="p_del">- * Populates the @insn-&gt;prefixes bitmap, and updates @insn-&gt;next_byte</span>
<span class="p_del">- * to point to the (first) opcode.  No effect if @insn-&gt;prefixes.got</span>
<span class="p_del">- * is already set.</span>
<span class="p_del">- */</span>
<span class="p_del">-void insn_get_prefixes(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct insn_field *prefixes = &amp;insn-&gt;prefixes;</span>
<span class="p_del">-	insn_attr_t attr;</span>
<span class="p_del">-	insn_byte_t b, lb;</span>
<span class="p_del">-	int i, nb;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (prefixes-&gt;got)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	nb = 0;</span>
<span class="p_del">-	lb = 0;</span>
<span class="p_del">-	b = peek_next(insn_byte_t, insn);</span>
<span class="p_del">-	attr = inat_get_opcode_attribute(b);</span>
<span class="p_del">-	while (inat_is_legacy_prefix(attr)) {</span>
<span class="p_del">-		/* Skip if same prefix */</span>
<span class="p_del">-		for (i = 0; i &lt; nb; i++)</span>
<span class="p_del">-			if (prefixes-&gt;bytes[i] == b)</span>
<span class="p_del">-				goto found;</span>
<span class="p_del">-		if (nb == 4)</span>
<span class="p_del">-			/* Invalid instruction */</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		prefixes-&gt;bytes[nb++] = b;</span>
<span class="p_del">-		if (inat_is_address_size_prefix(attr)) {</span>
<span class="p_del">-			/* address size switches 2/4 or 4/8 */</span>
<span class="p_del">-			if (insn-&gt;x86_64)</span>
<span class="p_del">-				insn-&gt;addr_bytes ^= 12;</span>
<span class="p_del">-			else</span>
<span class="p_del">-				insn-&gt;addr_bytes ^= 6;</span>
<span class="p_del">-		} else if (inat_is_operand_size_prefix(attr)) {</span>
<span class="p_del">-			/* oprand size switches 2/4 */</span>
<span class="p_del">-			insn-&gt;opnd_bytes ^= 6;</span>
<span class="p_del">-		}</span>
<span class="p_del">-found:</span>
<span class="p_del">-		prefixes-&gt;nbytes++;</span>
<span class="p_del">-		insn-&gt;next_byte++;</span>
<span class="p_del">-		lb = b;</span>
<span class="p_del">-		b = peek_next(insn_byte_t, insn);</span>
<span class="p_del">-		attr = inat_get_opcode_attribute(b);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	/* Set the last prefix */</span>
<span class="p_del">-	if (lb &amp;&amp; lb != insn-&gt;prefixes.bytes[3]) {</span>
<span class="p_del">-		if (unlikely(insn-&gt;prefixes.bytes[3])) {</span>
<span class="p_del">-			/* Swap the last prefix */</span>
<span class="p_del">-			b = insn-&gt;prefixes.bytes[3];</span>
<span class="p_del">-			for (i = 0; i &lt; nb; i++)</span>
<span class="p_del">-				if (prefixes-&gt;bytes[i] == lb)</span>
<span class="p_del">-					prefixes-&gt;bytes[i] = b;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		insn-&gt;prefixes.bytes[3] = lb;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Decode REX prefix */</span>
<span class="p_del">-	if (insn-&gt;x86_64) {</span>
<span class="p_del">-		b = peek_next(insn_byte_t, insn);</span>
<span class="p_del">-		attr = inat_get_opcode_attribute(b);</span>
<span class="p_del">-		if (inat_is_rex_prefix(attr)) {</span>
<span class="p_del">-			insn-&gt;rex_prefix.value = b;</span>
<span class="p_del">-			insn-&gt;rex_prefix.nbytes = 1;</span>
<span class="p_del">-			insn-&gt;next_byte++;</span>
<span class="p_del">-			if (X86_REX_W(b))</span>
<span class="p_del">-				/* REX.W overrides opnd_size */</span>
<span class="p_del">-				insn-&gt;opnd_bytes = 8;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	insn-&gt;rex_prefix.got = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Decode VEX prefix */</span>
<span class="p_del">-	b = peek_next(insn_byte_t, insn);</span>
<span class="p_del">-	attr = inat_get_opcode_attribute(b);</span>
<span class="p_del">-	if (inat_is_vex_prefix(attr)) {</span>
<span class="p_del">-		insn_byte_t b2 = peek_nbyte_next(insn_byte_t, insn, 1);</span>
<span class="p_del">-		if (!insn-&gt;x86_64) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * In 32-bits mode, if the [7:6] bits (mod bits of</span>
<span class="p_del">-			 * ModRM) on the second byte are not 11b, it is</span>
<span class="p_del">-			 * LDS or LES or BOUND.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (X86_MODRM_MOD(b2) != 3)</span>
<span class="p_del">-				goto vex_end;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		insn-&gt;vex_prefix.bytes[0] = b;</span>
<span class="p_del">-		insn-&gt;vex_prefix.bytes[1] = b2;</span>
<span class="p_del">-		if (inat_is_evex_prefix(attr)) {</span>
<span class="p_del">-			b2 = peek_nbyte_next(insn_byte_t, insn, 2);</span>
<span class="p_del">-			insn-&gt;vex_prefix.bytes[2] = b2;</span>
<span class="p_del">-			b2 = peek_nbyte_next(insn_byte_t, insn, 3);</span>
<span class="p_del">-			insn-&gt;vex_prefix.bytes[3] = b2;</span>
<span class="p_del">-			insn-&gt;vex_prefix.nbytes = 4;</span>
<span class="p_del">-			insn-&gt;next_byte += 4;</span>
<span class="p_del">-			if (insn-&gt;x86_64 &amp;&amp; X86_VEX_W(b2))</span>
<span class="p_del">-				/* VEX.W overrides opnd_size */</span>
<span class="p_del">-				insn-&gt;opnd_bytes = 8;</span>
<span class="p_del">-		} else if (inat_is_vex3_prefix(attr)) {</span>
<span class="p_del">-			b2 = peek_nbyte_next(insn_byte_t, insn, 2);</span>
<span class="p_del">-			insn-&gt;vex_prefix.bytes[2] = b2;</span>
<span class="p_del">-			insn-&gt;vex_prefix.nbytes = 3;</span>
<span class="p_del">-			insn-&gt;next_byte += 3;</span>
<span class="p_del">-			if (insn-&gt;x86_64 &amp;&amp; X86_VEX_W(b2))</span>
<span class="p_del">-				/* VEX.W overrides opnd_size */</span>
<span class="p_del">-				insn-&gt;opnd_bytes = 8;</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * For VEX2, fake VEX3-like byte#2.</span>
<span class="p_del">-			 * Makes it easier to decode vex.W, vex.vvvv,</span>
<span class="p_del">-			 * vex.L and vex.pp. Masking with 0x7f sets vex.W == 0.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			insn-&gt;vex_prefix.bytes[2] = b2 &amp; 0x7f;</span>
<span class="p_del">-			insn-&gt;vex_prefix.nbytes = 2;</span>
<span class="p_del">-			insn-&gt;next_byte += 2;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-vex_end:</span>
<span class="p_del">-	insn-&gt;vex_prefix.got = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	prefixes-&gt;got = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-err_out:</span>
<span class="p_del">-	return;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * insn_get_opcode - collect opcode(s)</span>
<span class="p_del">- * @insn:	&amp;struct insn containing instruction</span>
<span class="p_del">- *</span>
<span class="p_del">- * Populates @insn-&gt;opcode, updates @insn-&gt;next_byte to point past the</span>
<span class="p_del">- * opcode byte(s), and set @insn-&gt;attr (except for groups).</span>
<span class="p_del">- * If necessary, first collects any preceding (prefix) bytes.</span>
<span class="p_del">- * Sets @insn-&gt;opcode.value = opcode1.  No effect if @insn-&gt;opcode.got</span>
<span class="p_del">- * is already 1.</span>
<span class="p_del">- */</span>
<span class="p_del">-void insn_get_opcode(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct insn_field *opcode = &amp;insn-&gt;opcode;</span>
<span class="p_del">-	insn_byte_t op;</span>
<span class="p_del">-	int pfx_id;</span>
<span class="p_del">-	if (opcode-&gt;got)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	if (!insn-&gt;prefixes.got)</span>
<span class="p_del">-		insn_get_prefixes(insn);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Get first opcode */</span>
<span class="p_del">-	op = get_next(insn_byte_t, insn);</span>
<span class="p_del">-	opcode-&gt;bytes[0] = op;</span>
<span class="p_del">-	opcode-&gt;nbytes = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Check if there is VEX prefix or not */</span>
<span class="p_del">-	if (insn_is_avx(insn)) {</span>
<span class="p_del">-		insn_byte_t m, p;</span>
<span class="p_del">-		m = insn_vex_m_bits(insn);</span>
<span class="p_del">-		p = insn_vex_p_bits(insn);</span>
<span class="p_del">-		insn-&gt;attr = inat_get_avx_attribute(op, m, p);</span>
<span class="p_del">-		if ((inat_must_evex(insn-&gt;attr) &amp;&amp; !insn_is_evex(insn)) ||</span>
<span class="p_del">-		    (!inat_accept_vex(insn-&gt;attr) &amp;&amp;</span>
<span class="p_del">-		     !inat_is_group(insn-&gt;attr)))</span>
<span class="p_del">-			insn-&gt;attr = 0;	/* This instruction is bad */</span>
<span class="p_del">-		goto end;	/* VEX has only 1 byte for opcode */</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	insn-&gt;attr = inat_get_opcode_attribute(op);</span>
<span class="p_del">-	while (inat_is_escape(insn-&gt;attr)) {</span>
<span class="p_del">-		/* Get escaped opcode */</span>
<span class="p_del">-		op = get_next(insn_byte_t, insn);</span>
<span class="p_del">-		opcode-&gt;bytes[opcode-&gt;nbytes++] = op;</span>
<span class="p_del">-		pfx_id = insn_last_prefix_id(insn);</span>
<span class="p_del">-		insn-&gt;attr = inat_get_escape_attribute(op, pfx_id, insn-&gt;attr);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (inat_must_vex(insn-&gt;attr))</span>
<span class="p_del">-		insn-&gt;attr = 0;	/* This instruction is bad */</span>
<span class="p_del">-end:</span>
<span class="p_del">-	opcode-&gt;got = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-err_out:</span>
<span class="p_del">-	return;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * insn_get_modrm - collect ModRM byte, if any</span>
<span class="p_del">- * @insn:	&amp;struct insn containing instruction</span>
<span class="p_del">- *</span>
<span class="p_del">- * Populates @insn-&gt;modrm and updates @insn-&gt;next_byte to point past the</span>
<span class="p_del">- * ModRM byte, if any.  If necessary, first collects the preceding bytes</span>
<span class="p_del">- * (prefixes and opcode(s)).  No effect if @insn-&gt;modrm.got is already 1.</span>
<span class="p_del">- */</span>
<span class="p_del">-void insn_get_modrm(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct insn_field *modrm = &amp;insn-&gt;modrm;</span>
<span class="p_del">-	insn_byte_t pfx_id, mod;</span>
<span class="p_del">-	if (modrm-&gt;got)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	if (!insn-&gt;opcode.got)</span>
<span class="p_del">-		insn_get_opcode(insn);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (inat_has_modrm(insn-&gt;attr)) {</span>
<span class="p_del">-		mod = get_next(insn_byte_t, insn);</span>
<span class="p_del">-		modrm-&gt;value = mod;</span>
<span class="p_del">-		modrm-&gt;nbytes = 1;</span>
<span class="p_del">-		if (inat_is_group(insn-&gt;attr)) {</span>
<span class="p_del">-			pfx_id = insn_last_prefix_id(insn);</span>
<span class="p_del">-			insn-&gt;attr = inat_get_group_attribute(mod, pfx_id,</span>
<span class="p_del">-							      insn-&gt;attr);</span>
<span class="p_del">-			if (insn_is_avx(insn) &amp;&amp; !inat_accept_vex(insn-&gt;attr))</span>
<span class="p_del">-				insn-&gt;attr = 0;	/* This is bad */</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (insn-&gt;x86_64 &amp;&amp; inat_is_force64(insn-&gt;attr))</span>
<span class="p_del">-		insn-&gt;opnd_bytes = 8;</span>
<span class="p_del">-	modrm-&gt;got = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-err_out:</span>
<span class="p_del">-	return;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * insn_rip_relative() - Does instruction use RIP-relative addressing mode?</span>
<span class="p_del">- * @insn:	&amp;struct insn containing instruction</span>
<span class="p_del">- *</span>
<span class="p_del">- * If necessary, first collects the instruction up to and including the</span>
<span class="p_del">- * ModRM byte.  No effect if @insn-&gt;x86_64 is 0.</span>
<span class="p_del">- */</span>
<span class="p_del">-int insn_rip_relative(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct insn_field *modrm = &amp;insn-&gt;modrm;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!insn-&gt;x86_64)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	if (!modrm-&gt;got)</span>
<span class="p_del">-		insn_get_modrm(insn);</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * For rip-relative instructions, the mod field (top 2 bits)</span>
<span class="p_del">-	 * is zero and the r/m field (bottom 3 bits) is 0x5.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	return (modrm-&gt;nbytes &amp;&amp; (modrm-&gt;value &amp; 0xc7) == 0x5);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * insn_get_sib() - Get the SIB byte of instruction</span>
<span class="p_del">- * @insn:	&amp;struct insn containing instruction</span>
<span class="p_del">- *</span>
<span class="p_del">- * If necessary, first collects the instruction up to and including the</span>
<span class="p_del">- * ModRM byte.</span>
<span class="p_del">- */</span>
<span class="p_del">-void insn_get_sib(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	insn_byte_t modrm;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (insn-&gt;sib.got)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	if (!insn-&gt;modrm.got)</span>
<span class="p_del">-		insn_get_modrm(insn);</span>
<span class="p_del">-	if (insn-&gt;modrm.nbytes) {</span>
<span class="p_del">-		modrm = (insn_byte_t)insn-&gt;modrm.value;</span>
<span class="p_del">-		if (insn-&gt;addr_bytes != 2 &amp;&amp;</span>
<span class="p_del">-		    X86_MODRM_MOD(modrm) != 3 &amp;&amp; X86_MODRM_RM(modrm) == 4) {</span>
<span class="p_del">-			insn-&gt;sib.value = get_next(insn_byte_t, insn);</span>
<span class="p_del">-			insn-&gt;sib.nbytes = 1;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	insn-&gt;sib.got = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-err_out:</span>
<span class="p_del">-	return;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * insn_get_displacement() - Get the displacement of instruction</span>
<span class="p_del">- * @insn:	&amp;struct insn containing instruction</span>
<span class="p_del">- *</span>
<span class="p_del">- * If necessary, first collects the instruction up to and including the</span>
<span class="p_del">- * SIB byte.</span>
<span class="p_del">- * Displacement value is sign-expanded.</span>
<span class="p_del">- */</span>
<span class="p_del">-void insn_get_displacement(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	insn_byte_t mod, rm, base;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (insn-&gt;displacement.got)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	if (!insn-&gt;sib.got)</span>
<span class="p_del">-		insn_get_sib(insn);</span>
<span class="p_del">-	if (insn-&gt;modrm.nbytes) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Interpreting the modrm byte:</span>
<span class="p_del">-		 * mod = 00 - no displacement fields (exceptions below)</span>
<span class="p_del">-		 * mod = 01 - 1-byte displacement field</span>
<span class="p_del">-		 * mod = 10 - displacement field is 4 bytes, or 2 bytes if</span>
<span class="p_del">-		 * 	address size = 2 (0x67 prefix in 32-bit mode)</span>
<span class="p_del">-		 * mod = 11 - no memory operand</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * If address size = 2...</span>
<span class="p_del">-		 * mod = 00, r/m = 110 - displacement field is 2 bytes</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * If address size != 2...</span>
<span class="p_del">-		 * mod != 11, r/m = 100 - SIB byte exists</span>
<span class="p_del">-		 * mod = 00, SIB base = 101 - displacement field is 4 bytes</span>
<span class="p_del">-		 * mod = 00, r/m = 101 - rip-relative addressing, displacement</span>
<span class="p_del">-		 * 	field is 4 bytes</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		mod = X86_MODRM_MOD(insn-&gt;modrm.value);</span>
<span class="p_del">-		rm = X86_MODRM_RM(insn-&gt;modrm.value);</span>
<span class="p_del">-		base = X86_SIB_BASE(insn-&gt;sib.value);</span>
<span class="p_del">-		if (mod == 3)</span>
<span class="p_del">-			goto out;</span>
<span class="p_del">-		if (mod == 1) {</span>
<span class="p_del">-			insn-&gt;displacement.value = get_next(signed char, insn);</span>
<span class="p_del">-			insn-&gt;displacement.nbytes = 1;</span>
<span class="p_del">-		} else if (insn-&gt;addr_bytes == 2) {</span>
<span class="p_del">-			if ((mod == 0 &amp;&amp; rm == 6) || mod == 2) {</span>
<span class="p_del">-				insn-&gt;displacement.value =</span>
<span class="p_del">-					 get_next(short, insn);</span>
<span class="p_del">-				insn-&gt;displacement.nbytes = 2;</span>
<span class="p_del">-			}</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			if ((mod == 0 &amp;&amp; rm == 5) || mod == 2 ||</span>
<span class="p_del">-			    (mod == 0 &amp;&amp; base == 5)) {</span>
<span class="p_del">-				insn-&gt;displacement.value = get_next(int, insn);</span>
<span class="p_del">-				insn-&gt;displacement.nbytes = 4;</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-out:</span>
<span class="p_del">-	insn-&gt;displacement.got = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-err_out:</span>
<span class="p_del">-	return;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Decode moffset16/32/64. Return 0 if failed */</span>
<span class="p_del">-static int __get_moffset(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	switch (insn-&gt;addr_bytes) {</span>
<span class="p_del">-	case 2:</span>
<span class="p_del">-		insn-&gt;moffset1.value = get_next(short, insn);</span>
<span class="p_del">-		insn-&gt;moffset1.nbytes = 2;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case 4:</span>
<span class="p_del">-		insn-&gt;moffset1.value = get_next(int, insn);</span>
<span class="p_del">-		insn-&gt;moffset1.nbytes = 4;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case 8:</span>
<span class="p_del">-		insn-&gt;moffset1.value = get_next(int, insn);</span>
<span class="p_del">-		insn-&gt;moffset1.nbytes = 4;</span>
<span class="p_del">-		insn-&gt;moffset2.value = get_next(int, insn);</span>
<span class="p_del">-		insn-&gt;moffset2.nbytes = 4;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:	/* opnd_bytes must be modified manually */</span>
<span class="p_del">-		goto err_out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	insn-&gt;moffset1.got = insn-&gt;moffset2.got = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 1;</span>
<span class="p_del">-</span>
<span class="p_del">-err_out:</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Decode imm v32(Iz). Return 0 if failed */</span>
<span class="p_del">-static int __get_immv32(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	switch (insn-&gt;opnd_bytes) {</span>
<span class="p_del">-	case 2:</span>
<span class="p_del">-		insn-&gt;immediate.value = get_next(short, insn);</span>
<span class="p_del">-		insn-&gt;immediate.nbytes = 2;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case 4:</span>
<span class="p_del">-	case 8:</span>
<span class="p_del">-		insn-&gt;immediate.value = get_next(int, insn);</span>
<span class="p_del">-		insn-&gt;immediate.nbytes = 4;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:	/* opnd_bytes must be modified manually */</span>
<span class="p_del">-		goto err_out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return 1;</span>
<span class="p_del">-</span>
<span class="p_del">-err_out:</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Decode imm v64(Iv/Ov), Return 0 if failed */</span>
<span class="p_del">-static int __get_immv(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	switch (insn-&gt;opnd_bytes) {</span>
<span class="p_del">-	case 2:</span>
<span class="p_del">-		insn-&gt;immediate1.value = get_next(short, insn);</span>
<span class="p_del">-		insn-&gt;immediate1.nbytes = 2;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case 4:</span>
<span class="p_del">-		insn-&gt;immediate1.value = get_next(int, insn);</span>
<span class="p_del">-		insn-&gt;immediate1.nbytes = 4;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case 8:</span>
<span class="p_del">-		insn-&gt;immediate1.value = get_next(int, insn);</span>
<span class="p_del">-		insn-&gt;immediate1.nbytes = 4;</span>
<span class="p_del">-		insn-&gt;immediate2.value = get_next(int, insn);</span>
<span class="p_del">-		insn-&gt;immediate2.nbytes = 4;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:	/* opnd_bytes must be modified manually */</span>
<span class="p_del">-		goto err_out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	insn-&gt;immediate1.got = insn-&gt;immediate2.got = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 1;</span>
<span class="p_del">-err_out:</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Decode ptr16:16/32(Ap) */</span>
<span class="p_del">-static int __get_immptr(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	switch (insn-&gt;opnd_bytes) {</span>
<span class="p_del">-	case 2:</span>
<span class="p_del">-		insn-&gt;immediate1.value = get_next(short, insn);</span>
<span class="p_del">-		insn-&gt;immediate1.nbytes = 2;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case 4:</span>
<span class="p_del">-		insn-&gt;immediate1.value = get_next(int, insn);</span>
<span class="p_del">-		insn-&gt;immediate1.nbytes = 4;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case 8:</span>
<span class="p_del">-		/* ptr16:64 is not exist (no segment) */</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	default:	/* opnd_bytes must be modified manually */</span>
<span class="p_del">-		goto err_out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	insn-&gt;immediate2.value = get_next(unsigned short, insn);</span>
<span class="p_del">-	insn-&gt;immediate2.nbytes = 2;</span>
<span class="p_del">-	insn-&gt;immediate1.got = insn-&gt;immediate2.got = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 1;</span>
<span class="p_del">-err_out:</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * insn_get_immediate() - Get the immediates of instruction</span>
<span class="p_del">- * @insn:	&amp;struct insn containing instruction</span>
<span class="p_del">- *</span>
<span class="p_del">- * If necessary, first collects the instruction up to and including the</span>
<span class="p_del">- * displacement bytes.</span>
<span class="p_del">- * Basically, most of immediates are sign-expanded. Unsigned-value can be</span>
<span class="p_del">- * get by bit masking with ((1 &lt;&lt; (nbytes * 8)) - 1)</span>
<span class="p_del">- */</span>
<span class="p_del">-void insn_get_immediate(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (insn-&gt;immediate.got)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	if (!insn-&gt;displacement.got)</span>
<span class="p_del">-		insn_get_displacement(insn);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (inat_has_moffset(insn-&gt;attr)) {</span>
<span class="p_del">-		if (!__get_moffset(insn))</span>
<span class="p_del">-			goto err_out;</span>
<span class="p_del">-		goto done;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!inat_has_immediate(insn-&gt;attr))</span>
<span class="p_del">-		/* no immediates */</span>
<span class="p_del">-		goto done;</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (inat_immediate_size(insn-&gt;attr)) {</span>
<span class="p_del">-	case INAT_IMM_BYTE:</span>
<span class="p_del">-		insn-&gt;immediate.value = get_next(signed char, insn);</span>
<span class="p_del">-		insn-&gt;immediate.nbytes = 1;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case INAT_IMM_WORD:</span>
<span class="p_del">-		insn-&gt;immediate.value = get_next(short, insn);</span>
<span class="p_del">-		insn-&gt;immediate.nbytes = 2;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case INAT_IMM_DWORD:</span>
<span class="p_del">-		insn-&gt;immediate.value = get_next(int, insn);</span>
<span class="p_del">-		insn-&gt;immediate.nbytes = 4;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case INAT_IMM_QWORD:</span>
<span class="p_del">-		insn-&gt;immediate1.value = get_next(int, insn);</span>
<span class="p_del">-		insn-&gt;immediate1.nbytes = 4;</span>
<span class="p_del">-		insn-&gt;immediate2.value = get_next(int, insn);</span>
<span class="p_del">-		insn-&gt;immediate2.nbytes = 4;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case INAT_IMM_PTR:</span>
<span class="p_del">-		if (!__get_immptr(insn))</span>
<span class="p_del">-			goto err_out;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case INAT_IMM_VWORD32:</span>
<span class="p_del">-		if (!__get_immv32(insn))</span>
<span class="p_del">-			goto err_out;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case INAT_IMM_VWORD:</span>
<span class="p_del">-		if (!__get_immv(insn))</span>
<span class="p_del">-			goto err_out;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		/* Here, insn must have an immediate, but failed */</span>
<span class="p_del">-		goto err_out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (inat_has_second_immediate(insn-&gt;attr)) {</span>
<span class="p_del">-		insn-&gt;immediate2.value = get_next(signed char, insn);</span>
<span class="p_del">-		insn-&gt;immediate2.nbytes = 1;</span>
<span class="p_del">-	}</span>
<span class="p_del">-done:</span>
<span class="p_del">-	insn-&gt;immediate.got = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-err_out:</span>
<span class="p_del">-	return;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * insn_get_length() - Get the length of instruction</span>
<span class="p_del">- * @insn:	&amp;struct insn containing instruction</span>
<span class="p_del">- *</span>
<span class="p_del">- * If necessary, first collects the instruction up to and including the</span>
<span class="p_del">- * immediates bytes.</span>
<span class="p_del">- */</span>
<span class="p_del">-void insn_get_length(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (insn-&gt;length)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	if (!insn-&gt;immediate.got)</span>
<span class="p_del">-		insn_get_immediate(insn);</span>
<span class="p_del">-	insn-&gt;length = (unsigned char)((unsigned long)insn-&gt;next_byte</span>
<span class="p_del">-				     - (unsigned long)insn-&gt;kaddr);</span>
<span class="p_del">-}</span>
<span class="p_header">diff --git a/tools/objtool/arch/x86/insn/insn.h b/tools/objtool/arch/x86/insn/insn.h</span>
deleted file mode 100644
<span class="p_header">index e23578c7b1be..000000000000</span>
<span class="p_header">--- a/tools/objtool/arch/x86/insn/insn.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,211 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-#ifndef _ASM_X86_INSN_H</span>
<span class="p_del">-#define _ASM_X86_INSN_H</span>
<span class="p_del">-/*</span>
<span class="p_del">- * x86 instruction analysis</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is free software; you can redistribute it and/or modify</span>
<span class="p_del">- * it under the terms of the GNU General Public License as published by</span>
<span class="p_del">- * the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_del">- * (at your option) any later version.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is distributed in the hope that it will be useful,</span>
<span class="p_del">- * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_del">- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_del">- * GNU General Public License for more details.</span>
<span class="p_del">- *</span>
<span class="p_del">- * You should have received a copy of the GNU General Public License</span>
<span class="p_del">- * along with this program; if not, write to the Free Software</span>
<span class="p_del">- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Copyright (C) IBM Corporation, 2009</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-/* insn_attr_t is defined in inat.h */</span>
<span class="p_del">-#include &quot;inat.h&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-struct insn_field {</span>
<span class="p_del">-	union {</span>
<span class="p_del">-		insn_value_t value;</span>
<span class="p_del">-		insn_byte_t bytes[4];</span>
<span class="p_del">-	};</span>
<span class="p_del">-	/* !0 if we&#39;ve run insn_get_xxx() for this field */</span>
<span class="p_del">-	unsigned char got;</span>
<span class="p_del">-	unsigned char nbytes;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-struct insn {</span>
<span class="p_del">-	struct insn_field prefixes;	/*</span>
<span class="p_del">-					 * Prefixes</span>
<span class="p_del">-					 * prefixes.bytes[3]: last prefix</span>
<span class="p_del">-					 */</span>
<span class="p_del">-	struct insn_field rex_prefix;	/* REX prefix */</span>
<span class="p_del">-	struct insn_field vex_prefix;	/* VEX prefix */</span>
<span class="p_del">-	struct insn_field opcode;	/*</span>
<span class="p_del">-					 * opcode.bytes[0]: opcode1</span>
<span class="p_del">-					 * opcode.bytes[1]: opcode2</span>
<span class="p_del">-					 * opcode.bytes[2]: opcode3</span>
<span class="p_del">-					 */</span>
<span class="p_del">-	struct insn_field modrm;</span>
<span class="p_del">-	struct insn_field sib;</span>
<span class="p_del">-	struct insn_field displacement;</span>
<span class="p_del">-	union {</span>
<span class="p_del">-		struct insn_field immediate;</span>
<span class="p_del">-		struct insn_field moffset1;	/* for 64bit MOV */</span>
<span class="p_del">-		struct insn_field immediate1;	/* for 64bit imm or off16/32 */</span>
<span class="p_del">-	};</span>
<span class="p_del">-	union {</span>
<span class="p_del">-		struct insn_field moffset2;	/* for 64bit MOV */</span>
<span class="p_del">-		struct insn_field immediate2;	/* for 64bit imm or seg16 */</span>
<span class="p_del">-	};</span>
<span class="p_del">-</span>
<span class="p_del">-	insn_attr_t attr;</span>
<span class="p_del">-	unsigned char opnd_bytes;</span>
<span class="p_del">-	unsigned char addr_bytes;</span>
<span class="p_del">-	unsigned char length;</span>
<span class="p_del">-	unsigned char x86_64;</span>
<span class="p_del">-</span>
<span class="p_del">-	const insn_byte_t *kaddr;	/* kernel address of insn to analyze */</span>
<span class="p_del">-	const insn_byte_t *end_kaddr;	/* kernel address of last insn in buffer */</span>
<span class="p_del">-	const insn_byte_t *next_byte;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-#define MAX_INSN_SIZE	15</span>
<span class="p_del">-</span>
<span class="p_del">-#define X86_MODRM_MOD(modrm) (((modrm) &amp; 0xc0) &gt;&gt; 6)</span>
<span class="p_del">-#define X86_MODRM_REG(modrm) (((modrm) &amp; 0x38) &gt;&gt; 3)</span>
<span class="p_del">-#define X86_MODRM_RM(modrm) ((modrm) &amp; 0x07)</span>
<span class="p_del">-</span>
<span class="p_del">-#define X86_SIB_SCALE(sib) (((sib) &amp; 0xc0) &gt;&gt; 6)</span>
<span class="p_del">-#define X86_SIB_INDEX(sib) (((sib) &amp; 0x38) &gt;&gt; 3)</span>
<span class="p_del">-#define X86_SIB_BASE(sib) ((sib) &amp; 0x07)</span>
<span class="p_del">-</span>
<span class="p_del">-#define X86_REX_W(rex) ((rex) &amp; 8)</span>
<span class="p_del">-#define X86_REX_R(rex) ((rex) &amp; 4)</span>
<span class="p_del">-#define X86_REX_X(rex) ((rex) &amp; 2)</span>
<span class="p_del">-#define X86_REX_B(rex) ((rex) &amp; 1)</span>
<span class="p_del">-</span>
<span class="p_del">-/* VEX bit flags  */</span>
<span class="p_del">-#define X86_VEX_W(vex)	((vex) &amp; 0x80)	/* VEX3 Byte2 */</span>
<span class="p_del">-#define X86_VEX_R(vex)	((vex) &amp; 0x80)	/* VEX2/3 Byte1 */</span>
<span class="p_del">-#define X86_VEX_X(vex)	((vex) &amp; 0x40)	/* VEX3 Byte1 */</span>
<span class="p_del">-#define X86_VEX_B(vex)	((vex) &amp; 0x20)	/* VEX3 Byte1 */</span>
<span class="p_del">-#define X86_VEX_L(vex)	((vex) &amp; 0x04)	/* VEX3 Byte2, VEX2 Byte1 */</span>
<span class="p_del">-/* VEX bit fields */</span>
<span class="p_del">-#define X86_EVEX_M(vex)	((vex) &amp; 0x03)		/* EVEX Byte1 */</span>
<span class="p_del">-#define X86_VEX3_M(vex)	((vex) &amp; 0x1f)		/* VEX3 Byte1 */</span>
<span class="p_del">-#define X86_VEX2_M	1			/* VEX2.M always 1 */</span>
<span class="p_del">-#define X86_VEX_V(vex)	(((vex) &amp; 0x78) &gt;&gt; 3)	/* VEX3 Byte2, VEX2 Byte1 */</span>
<span class="p_del">-#define X86_VEX_P(vex)	((vex) &amp; 0x03)		/* VEX3 Byte2, VEX2 Byte1 */</span>
<span class="p_del">-#define X86_VEX_M_MAX	0x1f			/* VEX3.M Maximum value */</span>
<span class="p_del">-</span>
<span class="p_del">-extern void insn_init(struct insn *insn, const void *kaddr, int buf_len, int x86_64);</span>
<span class="p_del">-extern void insn_get_prefixes(struct insn *insn);</span>
<span class="p_del">-extern void insn_get_opcode(struct insn *insn);</span>
<span class="p_del">-extern void insn_get_modrm(struct insn *insn);</span>
<span class="p_del">-extern void insn_get_sib(struct insn *insn);</span>
<span class="p_del">-extern void insn_get_displacement(struct insn *insn);</span>
<span class="p_del">-extern void insn_get_immediate(struct insn *insn);</span>
<span class="p_del">-extern void insn_get_length(struct insn *insn);</span>
<span class="p_del">-</span>
<span class="p_del">-/* Attribute will be determined after getting ModRM (for opcode groups) */</span>
<span class="p_del">-static inline void insn_get_attribute(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	insn_get_modrm(insn);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Instruction uses RIP-relative addressing */</span>
<span class="p_del">-extern int insn_rip_relative(struct insn *insn);</span>
<span class="p_del">-</span>
<span class="p_del">-/* Init insn for kernel text */</span>
<span class="p_del">-static inline void kernel_insn_init(struct insn *insn,</span>
<span class="p_del">-				    const void *kaddr, int buf_len)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	insn_init(insn, kaddr, buf_len, 1);</span>
<span class="p_del">-#else /* CONFIG_X86_32 */</span>
<span class="p_del">-	insn_init(insn, kaddr, buf_len, 0);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int insn_is_avx(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (!insn-&gt;prefixes.got)</span>
<span class="p_del">-		insn_get_prefixes(insn);</span>
<span class="p_del">-	return (insn-&gt;vex_prefix.value != 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int insn_is_evex(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (!insn-&gt;prefixes.got)</span>
<span class="p_del">-		insn_get_prefixes(insn);</span>
<span class="p_del">-	return (insn-&gt;vex_prefix.nbytes == 4);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Ensure this instruction is decoded completely */</span>
<span class="p_del">-static inline int insn_complete(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return insn-&gt;opcode.got &amp;&amp; insn-&gt;modrm.got &amp;&amp; insn-&gt;sib.got &amp;&amp;</span>
<span class="p_del">-		insn-&gt;displacement.got &amp;&amp; insn-&gt;immediate.got;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline insn_byte_t insn_vex_m_bits(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (insn-&gt;vex_prefix.nbytes == 2)	/* 2 bytes VEX */</span>
<span class="p_del">-		return X86_VEX2_M;</span>
<span class="p_del">-	else if (insn-&gt;vex_prefix.nbytes == 3)	/* 3 bytes VEX */</span>
<span class="p_del">-		return X86_VEX3_M(insn-&gt;vex_prefix.bytes[1]);</span>
<span class="p_del">-	else					/* EVEX */</span>
<span class="p_del">-		return X86_EVEX_M(insn-&gt;vex_prefix.bytes[1]);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline insn_byte_t insn_vex_p_bits(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (insn-&gt;vex_prefix.nbytes == 2)	/* 2 bytes VEX */</span>
<span class="p_del">-		return X86_VEX_P(insn-&gt;vex_prefix.bytes[1]);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		return X86_VEX_P(insn-&gt;vex_prefix.bytes[2]);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Get the last prefix id from last prefix or VEX prefix */</span>
<span class="p_del">-static inline int insn_last_prefix_id(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (insn_is_avx(insn))</span>
<span class="p_del">-		return insn_vex_p_bits(insn);	/* VEX_p is a SIMD prefix id */</span>
<span class="p_del">-</span>
<span class="p_del">-	if (insn-&gt;prefixes.bytes[3])</span>
<span class="p_del">-		return inat_get_last_prefix_id(insn-&gt;prefixes.bytes[3]);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Offset of each field from kaddr */</span>
<span class="p_del">-static inline int insn_offset_rex_prefix(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return insn-&gt;prefixes.nbytes;</span>
<span class="p_del">-}</span>
<span class="p_del">-static inline int insn_offset_vex_prefix(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return insn_offset_rex_prefix(insn) + insn-&gt;rex_prefix.nbytes;</span>
<span class="p_del">-}</span>
<span class="p_del">-static inline int insn_offset_opcode(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return insn_offset_vex_prefix(insn) + insn-&gt;vex_prefix.nbytes;</span>
<span class="p_del">-}</span>
<span class="p_del">-static inline int insn_offset_modrm(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return insn_offset_opcode(insn) + insn-&gt;opcode.nbytes;</span>
<span class="p_del">-}</span>
<span class="p_del">-static inline int insn_offset_sib(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return insn_offset_modrm(insn) + insn-&gt;modrm.nbytes;</span>
<span class="p_del">-}</span>
<span class="p_del">-static inline int insn_offset_displacement(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return insn_offset_sib(insn) + insn-&gt;sib.nbytes;</span>
<span class="p_del">-}</span>
<span class="p_del">-static inline int insn_offset_immediate(struct insn *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return insn_offset_displacement(insn) + insn-&gt;displacement.nbytes;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#endif /* _ASM_X86_INSN_H */</span>
<span class="p_header">diff --git a/tools/objtool/arch/x86/insn/x86-opcode-map.txt b/tools/objtool/arch/x86/insn/x86-opcode-map.txt</span>
deleted file mode 100644
<span class="p_header">index 12e377184ee4..000000000000</span>
<span class="p_header">--- a/tools/objtool/arch/x86/insn/x86-opcode-map.txt</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,1063 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-# x86 Opcode Maps</span>
<span class="p_del">-#</span>
<span class="p_del">-# This is (mostly) based on following documentations.</span>
<span class="p_del">-# - Intel(R) 64 and IA-32 Architectures Software Developer&#39;s Manual Vol.2C</span>
<span class="p_del">-#   (#326018-047US, June 2013)</span>
<span class="p_del">-#</span>
<span class="p_del">-#&lt;Opcode maps&gt;</span>
<span class="p_del">-# Table: table-name</span>
<span class="p_del">-# Referrer: escaped-name</span>
<span class="p_del">-# AVXcode: avx-code</span>
<span class="p_del">-# opcode: mnemonic|GrpXXX [operand1[,operand2...]] [(extra1)[,(extra2)...] [| 2nd-mnemonic ...]</span>
<span class="p_del">-# (or)</span>
<span class="p_del">-# opcode: escape # escaped-name</span>
<span class="p_del">-# EndTable</span>
<span class="p_del">-#</span>
<span class="p_del">-# mnemonics that begin with lowercase &#39;v&#39; accept a VEX or EVEX prefix</span>
<span class="p_del">-# mnemonics that begin with lowercase &#39;k&#39; accept a VEX prefix</span>
<span class="p_del">-#</span>
<span class="p_del">-#&lt;group maps&gt;</span>
<span class="p_del">-# GrpTable: GrpXXX</span>
<span class="p_del">-# reg:  mnemonic [operand1[,operand2...]] [(extra1)[,(extra2)...] [| 2nd-mnemonic ...]</span>
<span class="p_del">-# EndTable</span>
<span class="p_del">-#</span>
<span class="p_del">-# AVX Superscripts</span>
<span class="p_del">-#  (ev): this opcode requires EVEX prefix.</span>
<span class="p_del">-#  (evo): this opcode is changed by EVEX prefix (EVEX opcode)</span>
<span class="p_del">-#  (v): this opcode requires VEX prefix.</span>
<span class="p_del">-#  (v1): this opcode only supports 128bit VEX.</span>
<span class="p_del">-#</span>
<span class="p_del">-# Last Prefix Superscripts</span>
<span class="p_del">-#  - (66): the last prefix is 0x66</span>
<span class="p_del">-#  - (F3): the last prefix is 0xF3</span>
<span class="p_del">-#  - (F2): the last prefix is 0xF2</span>
<span class="p_del">-#  - (!F3) : the last prefix is not 0xF3 (including non-last prefix case)</span>
<span class="p_del">-#  - (66&amp;F2): Both 0x66 and 0xF2 prefixes are specified.</span>
<span class="p_del">-</span>
<span class="p_del">-Table: one byte opcode</span>
<span class="p_del">-Referrer:</span>
<span class="p_del">-AVXcode:</span>
<span class="p_del">-# 0x00 - 0x0f</span>
<span class="p_del">-00: ADD Eb,Gb</span>
<span class="p_del">-01: ADD Ev,Gv</span>
<span class="p_del">-02: ADD Gb,Eb</span>
<span class="p_del">-03: ADD Gv,Ev</span>
<span class="p_del">-04: ADD AL,Ib</span>
<span class="p_del">-05: ADD rAX,Iz</span>
<span class="p_del">-06: PUSH ES (i64)</span>
<span class="p_del">-07: POP ES (i64)</span>
<span class="p_del">-08: OR Eb,Gb</span>
<span class="p_del">-09: OR Ev,Gv</span>
<span class="p_del">-0a: OR Gb,Eb</span>
<span class="p_del">-0b: OR Gv,Ev</span>
<span class="p_del">-0c: OR AL,Ib</span>
<span class="p_del">-0d: OR rAX,Iz</span>
<span class="p_del">-0e: PUSH CS (i64)</span>
<span class="p_del">-0f: escape # 2-byte escape</span>
<span class="p_del">-# 0x10 - 0x1f</span>
<span class="p_del">-10: ADC Eb,Gb</span>
<span class="p_del">-11: ADC Ev,Gv</span>
<span class="p_del">-12: ADC Gb,Eb</span>
<span class="p_del">-13: ADC Gv,Ev</span>
<span class="p_del">-14: ADC AL,Ib</span>
<span class="p_del">-15: ADC rAX,Iz</span>
<span class="p_del">-16: PUSH SS (i64)</span>
<span class="p_del">-17: POP SS (i64)</span>
<span class="p_del">-18: SBB Eb,Gb</span>
<span class="p_del">-19: SBB Ev,Gv</span>
<span class="p_del">-1a: SBB Gb,Eb</span>
<span class="p_del">-1b: SBB Gv,Ev</span>
<span class="p_del">-1c: SBB AL,Ib</span>
<span class="p_del">-1d: SBB rAX,Iz</span>
<span class="p_del">-1e: PUSH DS (i64)</span>
<span class="p_del">-1f: POP DS (i64)</span>
<span class="p_del">-# 0x20 - 0x2f</span>
<span class="p_del">-20: AND Eb,Gb</span>
<span class="p_del">-21: AND Ev,Gv</span>
<span class="p_del">-22: AND Gb,Eb</span>
<span class="p_del">-23: AND Gv,Ev</span>
<span class="p_del">-24: AND AL,Ib</span>
<span class="p_del">-25: AND rAx,Iz</span>
<span class="p_del">-26: SEG=ES (Prefix)</span>
<span class="p_del">-27: DAA (i64)</span>
<span class="p_del">-28: SUB Eb,Gb</span>
<span class="p_del">-29: SUB Ev,Gv</span>
<span class="p_del">-2a: SUB Gb,Eb</span>
<span class="p_del">-2b: SUB Gv,Ev</span>
<span class="p_del">-2c: SUB AL,Ib</span>
<span class="p_del">-2d: SUB rAX,Iz</span>
<span class="p_del">-2e: SEG=CS (Prefix)</span>
<span class="p_del">-2f: DAS (i64)</span>
<span class="p_del">-# 0x30 - 0x3f</span>
<span class="p_del">-30: XOR Eb,Gb</span>
<span class="p_del">-31: XOR Ev,Gv</span>
<span class="p_del">-32: XOR Gb,Eb</span>
<span class="p_del">-33: XOR Gv,Ev</span>
<span class="p_del">-34: XOR AL,Ib</span>
<span class="p_del">-35: XOR rAX,Iz</span>
<span class="p_del">-36: SEG=SS (Prefix)</span>
<span class="p_del">-37: AAA (i64)</span>
<span class="p_del">-38: CMP Eb,Gb</span>
<span class="p_del">-39: CMP Ev,Gv</span>
<span class="p_del">-3a: CMP Gb,Eb</span>
<span class="p_del">-3b: CMP Gv,Ev</span>
<span class="p_del">-3c: CMP AL,Ib</span>
<span class="p_del">-3d: CMP rAX,Iz</span>
<span class="p_del">-3e: SEG=DS (Prefix)</span>
<span class="p_del">-3f: AAS (i64)</span>
<span class="p_del">-# 0x40 - 0x4f</span>
<span class="p_del">-40: INC eAX (i64) | REX (o64)</span>
<span class="p_del">-41: INC eCX (i64) | REX.B (o64)</span>
<span class="p_del">-42: INC eDX (i64) | REX.X (o64)</span>
<span class="p_del">-43: INC eBX (i64) | REX.XB (o64)</span>
<span class="p_del">-44: INC eSP (i64) | REX.R (o64)</span>
<span class="p_del">-45: INC eBP (i64) | REX.RB (o64)</span>
<span class="p_del">-46: INC eSI (i64) | REX.RX (o64)</span>
<span class="p_del">-47: INC eDI (i64) | REX.RXB (o64)</span>
<span class="p_del">-48: DEC eAX (i64) | REX.W (o64)</span>
<span class="p_del">-49: DEC eCX (i64) | REX.WB (o64)</span>
<span class="p_del">-4a: DEC eDX (i64) | REX.WX (o64)</span>
<span class="p_del">-4b: DEC eBX (i64) | REX.WXB (o64)</span>
<span class="p_del">-4c: DEC eSP (i64) | REX.WR (o64)</span>
<span class="p_del">-4d: DEC eBP (i64) | REX.WRB (o64)</span>
<span class="p_del">-4e: DEC eSI (i64) | REX.WRX (o64)</span>
<span class="p_del">-4f: DEC eDI (i64) | REX.WRXB (o64)</span>
<span class="p_del">-# 0x50 - 0x5f</span>
<span class="p_del">-50: PUSH rAX/r8 (d64)</span>
<span class="p_del">-51: PUSH rCX/r9 (d64)</span>
<span class="p_del">-52: PUSH rDX/r10 (d64)</span>
<span class="p_del">-53: PUSH rBX/r11 (d64)</span>
<span class="p_del">-54: PUSH rSP/r12 (d64)</span>
<span class="p_del">-55: PUSH rBP/r13 (d64)</span>
<span class="p_del">-56: PUSH rSI/r14 (d64)</span>
<span class="p_del">-57: PUSH rDI/r15 (d64)</span>
<span class="p_del">-58: POP rAX/r8 (d64)</span>
<span class="p_del">-59: POP rCX/r9 (d64)</span>
<span class="p_del">-5a: POP rDX/r10 (d64)</span>
<span class="p_del">-5b: POP rBX/r11 (d64)</span>
<span class="p_del">-5c: POP rSP/r12 (d64)</span>
<span class="p_del">-5d: POP rBP/r13 (d64)</span>
<span class="p_del">-5e: POP rSI/r14 (d64)</span>
<span class="p_del">-5f: POP rDI/r15 (d64)</span>
<span class="p_del">-# 0x60 - 0x6f</span>
<span class="p_del">-60: PUSHA/PUSHAD (i64)</span>
<span class="p_del">-61: POPA/POPAD (i64)</span>
<span class="p_del">-62: BOUND Gv,Ma (i64) | EVEX (Prefix)</span>
<span class="p_del">-63: ARPL Ew,Gw (i64) | MOVSXD Gv,Ev (o64)</span>
<span class="p_del">-64: SEG=FS (Prefix)</span>
<span class="p_del">-65: SEG=GS (Prefix)</span>
<span class="p_del">-66: Operand-Size (Prefix)</span>
<span class="p_del">-67: Address-Size (Prefix)</span>
<span class="p_del">-68: PUSH Iz (d64)</span>
<span class="p_del">-69: IMUL Gv,Ev,Iz</span>
<span class="p_del">-6a: PUSH Ib (d64)</span>
<span class="p_del">-6b: IMUL Gv,Ev,Ib</span>
<span class="p_del">-6c: INS/INSB Yb,DX</span>
<span class="p_del">-6d: INS/INSW/INSD Yz,DX</span>
<span class="p_del">-6e: OUTS/OUTSB DX,Xb</span>
<span class="p_del">-6f: OUTS/OUTSW/OUTSD DX,Xz</span>
<span class="p_del">-# 0x70 - 0x7f</span>
<span class="p_del">-70: JO Jb</span>
<span class="p_del">-71: JNO Jb</span>
<span class="p_del">-72: JB/JNAE/JC Jb</span>
<span class="p_del">-73: JNB/JAE/JNC Jb</span>
<span class="p_del">-74: JZ/JE Jb</span>
<span class="p_del">-75: JNZ/JNE Jb</span>
<span class="p_del">-76: JBE/JNA Jb</span>
<span class="p_del">-77: JNBE/JA Jb</span>
<span class="p_del">-78: JS Jb</span>
<span class="p_del">-79: JNS Jb</span>
<span class="p_del">-7a: JP/JPE Jb</span>
<span class="p_del">-7b: JNP/JPO Jb</span>
<span class="p_del">-7c: JL/JNGE Jb</span>
<span class="p_del">-7d: JNL/JGE Jb</span>
<span class="p_del">-7e: JLE/JNG Jb</span>
<span class="p_del">-7f: JNLE/JG Jb</span>
<span class="p_del">-# 0x80 - 0x8f</span>
<span class="p_del">-80: Grp1 Eb,Ib (1A)</span>
<span class="p_del">-81: Grp1 Ev,Iz (1A)</span>
<span class="p_del">-82: Grp1 Eb,Ib (1A),(i64)</span>
<span class="p_del">-83: Grp1 Ev,Ib (1A)</span>
<span class="p_del">-84: TEST Eb,Gb</span>
<span class="p_del">-85: TEST Ev,Gv</span>
<span class="p_del">-86: XCHG Eb,Gb</span>
<span class="p_del">-87: XCHG Ev,Gv</span>
<span class="p_del">-88: MOV Eb,Gb</span>
<span class="p_del">-89: MOV Ev,Gv</span>
<span class="p_del">-8a: MOV Gb,Eb</span>
<span class="p_del">-8b: MOV Gv,Ev</span>
<span class="p_del">-8c: MOV Ev,Sw</span>
<span class="p_del">-8d: LEA Gv,M</span>
<span class="p_del">-8e: MOV Sw,Ew</span>
<span class="p_del">-8f: Grp1A (1A) | POP Ev (d64)</span>
<span class="p_del">-# 0x90 - 0x9f</span>
<span class="p_del">-90: NOP | PAUSE (F3) | XCHG r8,rAX</span>
<span class="p_del">-91: XCHG rCX/r9,rAX</span>
<span class="p_del">-92: XCHG rDX/r10,rAX</span>
<span class="p_del">-93: XCHG rBX/r11,rAX</span>
<span class="p_del">-94: XCHG rSP/r12,rAX</span>
<span class="p_del">-95: XCHG rBP/r13,rAX</span>
<span class="p_del">-96: XCHG rSI/r14,rAX</span>
<span class="p_del">-97: XCHG rDI/r15,rAX</span>
<span class="p_del">-98: CBW/CWDE/CDQE</span>
<span class="p_del">-99: CWD/CDQ/CQO</span>
<span class="p_del">-9a: CALLF Ap (i64)</span>
<span class="p_del">-9b: FWAIT/WAIT</span>
<span class="p_del">-9c: PUSHF/D/Q Fv (d64)</span>
<span class="p_del">-9d: POPF/D/Q Fv (d64)</span>
<span class="p_del">-9e: SAHF</span>
<span class="p_del">-9f: LAHF</span>
<span class="p_del">-# 0xa0 - 0xaf</span>
<span class="p_del">-a0: MOV AL,Ob</span>
<span class="p_del">-a1: MOV rAX,Ov</span>
<span class="p_del">-a2: MOV Ob,AL</span>
<span class="p_del">-a3: MOV Ov,rAX</span>
<span class="p_del">-a4: MOVS/B Yb,Xb</span>
<span class="p_del">-a5: MOVS/W/D/Q Yv,Xv</span>
<span class="p_del">-a6: CMPS/B Xb,Yb</span>
<span class="p_del">-a7: CMPS/W/D Xv,Yv</span>
<span class="p_del">-a8: TEST AL,Ib</span>
<span class="p_del">-a9: TEST rAX,Iz</span>
<span class="p_del">-aa: STOS/B Yb,AL</span>
<span class="p_del">-ab: STOS/W/D/Q Yv,rAX</span>
<span class="p_del">-ac: LODS/B AL,Xb</span>
<span class="p_del">-ad: LODS/W/D/Q rAX,Xv</span>
<span class="p_del">-ae: SCAS/B AL,Yb</span>
<span class="p_del">-# Note: The May 2011 Intel manual shows Xv for the second parameter of the</span>
<span class="p_del">-# next instruction but Yv is correct</span>
<span class="p_del">-af: SCAS/W/D/Q rAX,Yv</span>
<span class="p_del">-# 0xb0 - 0xbf</span>
<span class="p_del">-b0: MOV AL/R8L,Ib</span>
<span class="p_del">-b1: MOV CL/R9L,Ib</span>
<span class="p_del">-b2: MOV DL/R10L,Ib</span>
<span class="p_del">-b3: MOV BL/R11L,Ib</span>
<span class="p_del">-b4: MOV AH/R12L,Ib</span>
<span class="p_del">-b5: MOV CH/R13L,Ib</span>
<span class="p_del">-b6: MOV DH/R14L,Ib</span>
<span class="p_del">-b7: MOV BH/R15L,Ib</span>
<span class="p_del">-b8: MOV rAX/r8,Iv</span>
<span class="p_del">-b9: MOV rCX/r9,Iv</span>
<span class="p_del">-ba: MOV rDX/r10,Iv</span>
<span class="p_del">-bb: MOV rBX/r11,Iv</span>
<span class="p_del">-bc: MOV rSP/r12,Iv</span>
<span class="p_del">-bd: MOV rBP/r13,Iv</span>
<span class="p_del">-be: MOV rSI/r14,Iv</span>
<span class="p_del">-bf: MOV rDI/r15,Iv</span>
<span class="p_del">-# 0xc0 - 0xcf</span>
<span class="p_del">-c0: Grp2 Eb,Ib (1A)</span>
<span class="p_del">-c1: Grp2 Ev,Ib (1A)</span>
<span class="p_del">-c2: RETN Iw (f64)</span>
<span class="p_del">-c3: RETN</span>
<span class="p_del">-c4: LES Gz,Mp (i64) | VEX+2byte (Prefix)</span>
<span class="p_del">-c5: LDS Gz,Mp (i64) | VEX+1byte (Prefix)</span>
<span class="p_del">-c6: Grp11A Eb,Ib (1A)</span>
<span class="p_del">-c7: Grp11B Ev,Iz (1A)</span>
<span class="p_del">-c8: ENTER Iw,Ib</span>
<span class="p_del">-c9: LEAVE (d64)</span>
<span class="p_del">-ca: RETF Iw</span>
<span class="p_del">-cb: RETF</span>
<span class="p_del">-cc: INT3</span>
<span class="p_del">-cd: INT Ib</span>
<span class="p_del">-ce: INTO (i64)</span>
<span class="p_del">-cf: IRET/D/Q</span>
<span class="p_del">-# 0xd0 - 0xdf</span>
<span class="p_del">-d0: Grp2 Eb,1 (1A)</span>
<span class="p_del">-d1: Grp2 Ev,1 (1A)</span>
<span class="p_del">-d2: Grp2 Eb,CL (1A)</span>
<span class="p_del">-d3: Grp2 Ev,CL (1A)</span>
<span class="p_del">-d4: AAM Ib (i64)</span>
<span class="p_del">-d5: AAD Ib (i64)</span>
<span class="p_del">-d6:</span>
<span class="p_del">-d7: XLAT/XLATB</span>
<span class="p_del">-d8: ESC</span>
<span class="p_del">-d9: ESC</span>
<span class="p_del">-da: ESC</span>
<span class="p_del">-db: ESC</span>
<span class="p_del">-dc: ESC</span>
<span class="p_del">-dd: ESC</span>
<span class="p_del">-de: ESC</span>
<span class="p_del">-df: ESC</span>
<span class="p_del">-# 0xe0 - 0xef</span>
<span class="p_del">-# Note: &quot;forced64&quot; is Intel CPU behavior: they ignore 0x66 prefix</span>
<span class="p_del">-# in 64-bit mode. AMD CPUs accept 0x66 prefix, it causes RIP truncation</span>
<span class="p_del">-# to 16 bits. In 32-bit mode, 0x66 is accepted by both Intel and AMD.</span>
<span class="p_del">-e0: LOOPNE/LOOPNZ Jb (f64)</span>
<span class="p_del">-e1: LOOPE/LOOPZ Jb (f64)</span>
<span class="p_del">-e2: LOOP Jb (f64)</span>
<span class="p_del">-e3: JrCXZ Jb (f64)</span>
<span class="p_del">-e4: IN AL,Ib</span>
<span class="p_del">-e5: IN eAX,Ib</span>
<span class="p_del">-e6: OUT Ib,AL</span>
<span class="p_del">-e7: OUT Ib,eAX</span>
<span class="p_del">-# With 0x66 prefix in 64-bit mode, for AMD CPUs immediate offset</span>
<span class="p_del">-# in &quot;near&quot; jumps and calls is 16-bit. For CALL,</span>
<span class="p_del">-# push of return address is 16-bit wide, RSP is decremented by 2</span>
<span class="p_del">-# but is not truncated to 16 bits, unlike RIP.</span>
<span class="p_del">-e8: CALL Jz (f64)</span>
<span class="p_del">-e9: JMP-near Jz (f64)</span>
<span class="p_del">-ea: JMP-far Ap (i64)</span>
<span class="p_del">-eb: JMP-short Jb (f64)</span>
<span class="p_del">-ec: IN AL,DX</span>
<span class="p_del">-ed: IN eAX,DX</span>
<span class="p_del">-ee: OUT DX,AL</span>
<span class="p_del">-ef: OUT DX,eAX</span>
<span class="p_del">-# 0xf0 - 0xff</span>
<span class="p_del">-f0: LOCK (Prefix)</span>
<span class="p_del">-f1:</span>
<span class="p_del">-f2: REPNE (Prefix) | XACQUIRE (Prefix)</span>
<span class="p_del">-f3: REP/REPE (Prefix) | XRELEASE (Prefix)</span>
<span class="p_del">-f4: HLT</span>
<span class="p_del">-f5: CMC</span>
<span class="p_del">-f6: Grp3_1 Eb (1A)</span>
<span class="p_del">-f7: Grp3_2 Ev (1A)</span>
<span class="p_del">-f8: CLC</span>
<span class="p_del">-f9: STC</span>
<span class="p_del">-fa: CLI</span>
<span class="p_del">-fb: STI</span>
<span class="p_del">-fc: CLD</span>
<span class="p_del">-fd: STD</span>
<span class="p_del">-fe: Grp4 (1A)</span>
<span class="p_del">-ff: Grp5 (1A)</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-Table: 2-byte opcode (0x0f)</span>
<span class="p_del">-Referrer: 2-byte escape</span>
<span class="p_del">-AVXcode: 1</span>
<span class="p_del">-# 0x0f 0x00-0x0f</span>
<span class="p_del">-00: Grp6 (1A)</span>
<span class="p_del">-01: Grp7 (1A)</span>
<span class="p_del">-02: LAR Gv,Ew</span>
<span class="p_del">-03: LSL Gv,Ew</span>
<span class="p_del">-04:</span>
<span class="p_del">-05: SYSCALL (o64)</span>
<span class="p_del">-06: CLTS</span>
<span class="p_del">-07: SYSRET (o64)</span>
<span class="p_del">-08: INVD</span>
<span class="p_del">-09: WBINVD</span>
<span class="p_del">-0a:</span>
<span class="p_del">-0b: UD2 (1B)</span>
<span class="p_del">-0c:</span>
<span class="p_del">-# AMD&#39;s prefetch group. Intel supports prefetchw(/1) only.</span>
<span class="p_del">-0d: GrpP</span>
<span class="p_del">-0e: FEMMS</span>
<span class="p_del">-# 3DNow! uses the last imm byte as opcode extension.</span>
<span class="p_del">-0f: 3DNow! Pq,Qq,Ib</span>
<span class="p_del">-# 0x0f 0x10-0x1f</span>
<span class="p_del">-# NOTE: According to Intel SDM opcode map, vmovups and vmovupd has no operands</span>
<span class="p_del">-# but it actually has operands. And also, vmovss and vmovsd only accept 128bit.</span>
<span class="p_del">-# MOVSS/MOVSD has too many forms(3) on SDM. This map just shows a typical form.</span>
<span class="p_del">-# Many AVX instructions lack v1 superscript, according to Intel AVX-Prgramming</span>
<span class="p_del">-# Reference A.1</span>
<span class="p_del">-10: vmovups Vps,Wps | vmovupd Vpd,Wpd (66) | vmovss Vx,Hx,Wss (F3),(v1) | vmovsd Vx,Hx,Wsd (F2),(v1)</span>
<span class="p_del">-11: vmovups Wps,Vps | vmovupd Wpd,Vpd (66) | vmovss Wss,Hx,Vss (F3),(v1) | vmovsd Wsd,Hx,Vsd (F2),(v1)</span>
<span class="p_del">-12: vmovlps Vq,Hq,Mq (v1) | vmovhlps Vq,Hq,Uq (v1) | vmovlpd Vq,Hq,Mq (66),(v1) | vmovsldup Vx,Wx (F3) | vmovddup Vx,Wx (F2)</span>
<span class="p_del">-13: vmovlps Mq,Vq (v1) | vmovlpd Mq,Vq (66),(v1)</span>
<span class="p_del">-14: vunpcklps Vx,Hx,Wx | vunpcklpd Vx,Hx,Wx (66)</span>
<span class="p_del">-15: vunpckhps Vx,Hx,Wx | vunpckhpd Vx,Hx,Wx (66)</span>
<span class="p_del">-16: vmovhps Vdq,Hq,Mq (v1) | vmovlhps Vdq,Hq,Uq (v1) | vmovhpd Vdq,Hq,Mq (66),(v1) | vmovshdup Vx,Wx (F3)</span>
<span class="p_del">-17: vmovhps Mq,Vq (v1) | vmovhpd Mq,Vq (66),(v1)</span>
<span class="p_del">-18: Grp16 (1A)</span>
<span class="p_del">-19:</span>
<span class="p_del">-# Intel SDM opcode map does not list MPX instructions. For now using Gv for</span>
<span class="p_del">-# bnd registers and Ev for everything else is OK because the instruction</span>
<span class="p_del">-# decoder does not use the information except as an indication that there is</span>
<span class="p_del">-# a ModR/M byte.</span>
<span class="p_del">-1a: BNDCL Gv,Ev (F3) | BNDCU Gv,Ev (F2) | BNDMOV Gv,Ev (66) | BNDLDX Gv,Ev</span>
<span class="p_del">-1b: BNDCN Gv,Ev (F2) | BNDMOV Ev,Gv (66) | BNDMK Gv,Ev (F3) | BNDSTX Ev,Gv</span>
<span class="p_del">-1c:</span>
<span class="p_del">-1d:</span>
<span class="p_del">-1e:</span>
<span class="p_del">-1f: NOP Ev</span>
<span class="p_del">-# 0x0f 0x20-0x2f</span>
<span class="p_del">-20: MOV Rd,Cd</span>
<span class="p_del">-21: MOV Rd,Dd</span>
<span class="p_del">-22: MOV Cd,Rd</span>
<span class="p_del">-23: MOV Dd,Rd</span>
<span class="p_del">-24:</span>
<span class="p_del">-25:</span>
<span class="p_del">-26:</span>
<span class="p_del">-27:</span>
<span class="p_del">-28: vmovaps Vps,Wps | vmovapd Vpd,Wpd (66)</span>
<span class="p_del">-29: vmovaps Wps,Vps | vmovapd Wpd,Vpd (66)</span>
<span class="p_del">-2a: cvtpi2ps Vps,Qpi | cvtpi2pd Vpd,Qpi (66) | vcvtsi2ss Vss,Hss,Ey (F3),(v1) | vcvtsi2sd Vsd,Hsd,Ey (F2),(v1)</span>
<span class="p_del">-2b: vmovntps Mps,Vps | vmovntpd Mpd,Vpd (66)</span>
<span class="p_del">-2c: cvttps2pi Ppi,Wps | cvttpd2pi Ppi,Wpd (66) | vcvttss2si Gy,Wss (F3),(v1) | vcvttsd2si Gy,Wsd (F2),(v1)</span>
<span class="p_del">-2d: cvtps2pi Ppi,Wps | cvtpd2pi Qpi,Wpd (66) | vcvtss2si Gy,Wss (F3),(v1) | vcvtsd2si Gy,Wsd (F2),(v1)</span>
<span class="p_del">-2e: vucomiss Vss,Wss (v1) | vucomisd  Vsd,Wsd (66),(v1)</span>
<span class="p_del">-2f: vcomiss Vss,Wss (v1) | vcomisd  Vsd,Wsd (66),(v1)</span>
<span class="p_del">-# 0x0f 0x30-0x3f</span>
<span class="p_del">-30: WRMSR</span>
<span class="p_del">-31: RDTSC</span>
<span class="p_del">-32: RDMSR</span>
<span class="p_del">-33: RDPMC</span>
<span class="p_del">-34: SYSENTER</span>
<span class="p_del">-35: SYSEXIT</span>
<span class="p_del">-36:</span>
<span class="p_del">-37: GETSEC</span>
<span class="p_del">-38: escape # 3-byte escape 1</span>
<span class="p_del">-39:</span>
<span class="p_del">-3a: escape # 3-byte escape 2</span>
<span class="p_del">-3b:</span>
<span class="p_del">-3c:</span>
<span class="p_del">-3d:</span>
<span class="p_del">-3e:</span>
<span class="p_del">-3f:</span>
<span class="p_del">-# 0x0f 0x40-0x4f</span>
<span class="p_del">-40: CMOVO Gv,Ev</span>
<span class="p_del">-41: CMOVNO Gv,Ev | kandw/q Vk,Hk,Uk | kandb/d Vk,Hk,Uk (66)</span>
<span class="p_del">-42: CMOVB/C/NAE Gv,Ev | kandnw/q Vk,Hk,Uk | kandnb/d Vk,Hk,Uk (66)</span>
<span class="p_del">-43: CMOVAE/NB/NC Gv,Ev</span>
<span class="p_del">-44: CMOVE/Z Gv,Ev | knotw/q Vk,Uk | knotb/d Vk,Uk (66)</span>
<span class="p_del">-45: CMOVNE/NZ Gv,Ev | korw/q Vk,Hk,Uk | korb/d Vk,Hk,Uk (66)</span>
<span class="p_del">-46: CMOVBE/NA Gv,Ev | kxnorw/q Vk,Hk,Uk | kxnorb/d Vk,Hk,Uk (66)</span>
<span class="p_del">-47: CMOVA/NBE Gv,Ev | kxorw/q Vk,Hk,Uk | kxorb/d Vk,Hk,Uk (66)</span>
<span class="p_del">-48: CMOVS Gv,Ev</span>
<span class="p_del">-49: CMOVNS Gv,Ev</span>
<span class="p_del">-4a: CMOVP/PE Gv,Ev | kaddw/q Vk,Hk,Uk | kaddb/d Vk,Hk,Uk (66)</span>
<span class="p_del">-4b: CMOVNP/PO Gv,Ev | kunpckbw Vk,Hk,Uk (66) | kunpckwd/dq Vk,Hk,Uk</span>
<span class="p_del">-4c: CMOVL/NGE Gv,Ev</span>
<span class="p_del">-4d: CMOVNL/GE Gv,Ev</span>
<span class="p_del">-4e: CMOVLE/NG Gv,Ev</span>
<span class="p_del">-4f: CMOVNLE/G Gv,Ev</span>
<span class="p_del">-# 0x0f 0x50-0x5f</span>
<span class="p_del">-50: vmovmskps Gy,Ups | vmovmskpd Gy,Upd (66)</span>
<span class="p_del">-51: vsqrtps Vps,Wps | vsqrtpd Vpd,Wpd (66) | vsqrtss Vss,Hss,Wss (F3),(v1) | vsqrtsd Vsd,Hsd,Wsd (F2),(v1)</span>
<span class="p_del">-52: vrsqrtps Vps,Wps | vrsqrtss Vss,Hss,Wss (F3),(v1)</span>
<span class="p_del">-53: vrcpps Vps,Wps | vrcpss Vss,Hss,Wss (F3),(v1)</span>
<span class="p_del">-54: vandps Vps,Hps,Wps | vandpd Vpd,Hpd,Wpd (66)</span>
<span class="p_del">-55: vandnps Vps,Hps,Wps | vandnpd Vpd,Hpd,Wpd (66)</span>
<span class="p_del">-56: vorps Vps,Hps,Wps | vorpd Vpd,Hpd,Wpd (66)</span>
<span class="p_del">-57: vxorps Vps,Hps,Wps | vxorpd Vpd,Hpd,Wpd (66)</span>
<span class="p_del">-58: vaddps Vps,Hps,Wps | vaddpd Vpd,Hpd,Wpd (66) | vaddss Vss,Hss,Wss (F3),(v1) | vaddsd Vsd,Hsd,Wsd (F2),(v1)</span>
<span class="p_del">-59: vmulps Vps,Hps,Wps | vmulpd Vpd,Hpd,Wpd (66) | vmulss Vss,Hss,Wss (F3),(v1) | vmulsd Vsd,Hsd,Wsd (F2),(v1)</span>
<span class="p_del">-5a: vcvtps2pd Vpd,Wps | vcvtpd2ps Vps,Wpd (66) | vcvtss2sd Vsd,Hx,Wss (F3),(v1) | vcvtsd2ss Vss,Hx,Wsd (F2),(v1)</span>
<span class="p_del">-5b: vcvtdq2ps Vps,Wdq | vcvtqq2ps Vps,Wqq (evo) | vcvtps2dq Vdq,Wps (66) | vcvttps2dq Vdq,Wps (F3)</span>
<span class="p_del">-5c: vsubps Vps,Hps,Wps | vsubpd Vpd,Hpd,Wpd (66) | vsubss Vss,Hss,Wss (F3),(v1) | vsubsd Vsd,Hsd,Wsd (F2),(v1)</span>
<span class="p_del">-5d: vminps Vps,Hps,Wps | vminpd Vpd,Hpd,Wpd (66) | vminss Vss,Hss,Wss (F3),(v1) | vminsd Vsd,Hsd,Wsd (F2),(v1)</span>
<span class="p_del">-5e: vdivps Vps,Hps,Wps | vdivpd Vpd,Hpd,Wpd (66) | vdivss Vss,Hss,Wss (F3),(v1) | vdivsd Vsd,Hsd,Wsd (F2),(v1)</span>
<span class="p_del">-5f: vmaxps Vps,Hps,Wps | vmaxpd Vpd,Hpd,Wpd (66) | vmaxss Vss,Hss,Wss (F3),(v1) | vmaxsd Vsd,Hsd,Wsd (F2),(v1)</span>
<span class="p_del">-# 0x0f 0x60-0x6f</span>
<span class="p_del">-60: punpcklbw Pq,Qd | vpunpcklbw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-61: punpcklwd Pq,Qd | vpunpcklwd Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-62: punpckldq Pq,Qd | vpunpckldq Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-63: packsswb Pq,Qq | vpacksswb Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-64: pcmpgtb Pq,Qq | vpcmpgtb Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-65: pcmpgtw Pq,Qq | vpcmpgtw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-66: pcmpgtd Pq,Qq | vpcmpgtd Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-67: packuswb Pq,Qq | vpackuswb Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-68: punpckhbw Pq,Qd | vpunpckhbw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-69: punpckhwd Pq,Qd | vpunpckhwd Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-6a: punpckhdq Pq,Qd | vpunpckhdq Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-6b: packssdw Pq,Qd | vpackssdw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-6c: vpunpcklqdq Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-6d: vpunpckhqdq Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-6e: movd/q Pd,Ey | vmovd/q Vy,Ey (66),(v1)</span>
<span class="p_del">-6f: movq Pq,Qq | vmovdqa Vx,Wx (66) | vmovdqa32/64 Vx,Wx (66),(evo) | vmovdqu Vx,Wx (F3) | vmovdqu32/64 Vx,Wx (F3),(evo) | vmovdqu8/16 Vx,Wx (F2),(ev)</span>
<span class="p_del">-# 0x0f 0x70-0x7f</span>
<span class="p_del">-70: pshufw Pq,Qq,Ib | vpshufd Vx,Wx,Ib (66),(v1) | vpshufhw Vx,Wx,Ib (F3),(v1) | vpshuflw Vx,Wx,Ib (F2),(v1)</span>
<span class="p_del">-71: Grp12 (1A)</span>
<span class="p_del">-72: Grp13 (1A)</span>
<span class="p_del">-73: Grp14 (1A)</span>
<span class="p_del">-74: pcmpeqb Pq,Qq | vpcmpeqb Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-75: pcmpeqw Pq,Qq | vpcmpeqw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-76: pcmpeqd Pq,Qq | vpcmpeqd Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-# Note: Remove (v), because vzeroall and vzeroupper becomes emms without VEX.</span>
<span class="p_del">-77: emms | vzeroupper | vzeroall</span>
<span class="p_del">-78: VMREAD Ey,Gy | vcvttps2udq/pd2udq Vx,Wpd (evo) | vcvttsd2usi Gv,Wx (F2),(ev) | vcvttss2usi Gv,Wx (F3),(ev) | vcvttps2uqq/pd2uqq Vx,Wx (66),(ev)</span>
<span class="p_del">-79: VMWRITE Gy,Ey | vcvtps2udq/pd2udq Vx,Wpd (evo) | vcvtsd2usi Gv,Wx (F2),(ev) | vcvtss2usi Gv,Wx (F3),(ev) | vcvtps2uqq/pd2uqq Vx,Wx (66),(ev)</span>
<span class="p_del">-7a: vcvtudq2pd/uqq2pd Vpd,Wx (F3),(ev) | vcvtudq2ps/uqq2ps Vpd,Wx (F2),(ev) | vcvttps2qq/pd2qq Vx,Wx (66),(ev)</span>
<span class="p_del">-7b: vcvtusi2sd Vpd,Hpd,Ev (F2),(ev) | vcvtusi2ss Vps,Hps,Ev (F3),(ev) | vcvtps2qq/pd2qq Vx,Wx (66),(ev)</span>
<span class="p_del">-7c: vhaddpd Vpd,Hpd,Wpd (66) | vhaddps Vps,Hps,Wps (F2)</span>
<span class="p_del">-7d: vhsubpd Vpd,Hpd,Wpd (66) | vhsubps Vps,Hps,Wps (F2)</span>
<span class="p_del">-7e: movd/q Ey,Pd | vmovd/q Ey,Vy (66),(v1) | vmovq Vq,Wq (F3),(v1)</span>
<span class="p_del">-7f: movq Qq,Pq | vmovdqa Wx,Vx (66) | vmovdqa32/64 Wx,Vx (66),(evo) | vmovdqu Wx,Vx (F3) | vmovdqu32/64 Wx,Vx (F3),(evo) | vmovdqu8/16 Wx,Vx (F2),(ev)</span>
<span class="p_del">-# 0x0f 0x80-0x8f</span>
<span class="p_del">-# Note: &quot;forced64&quot; is Intel CPU behavior (see comment about CALL insn).</span>
<span class="p_del">-80: JO Jz (f64)</span>
<span class="p_del">-81: JNO Jz (f64)</span>
<span class="p_del">-82: JB/JC/JNAE Jz (f64)</span>
<span class="p_del">-83: JAE/JNB/JNC Jz (f64)</span>
<span class="p_del">-84: JE/JZ Jz (f64)</span>
<span class="p_del">-85: JNE/JNZ Jz (f64)</span>
<span class="p_del">-86: JBE/JNA Jz (f64)</span>
<span class="p_del">-87: JA/JNBE Jz (f64)</span>
<span class="p_del">-88: JS Jz (f64)</span>
<span class="p_del">-89: JNS Jz (f64)</span>
<span class="p_del">-8a: JP/JPE Jz (f64)</span>
<span class="p_del">-8b: JNP/JPO Jz (f64)</span>
<span class="p_del">-8c: JL/JNGE Jz (f64)</span>
<span class="p_del">-8d: JNL/JGE Jz (f64)</span>
<span class="p_del">-8e: JLE/JNG Jz (f64)</span>
<span class="p_del">-8f: JNLE/JG Jz (f64)</span>
<span class="p_del">-# 0x0f 0x90-0x9f</span>
<span class="p_del">-90: SETO Eb | kmovw/q Vk,Wk | kmovb/d Vk,Wk (66)</span>
<span class="p_del">-91: SETNO Eb | kmovw/q Mv,Vk | kmovb/d Mv,Vk (66)</span>
<span class="p_del">-92: SETB/C/NAE Eb | kmovw Vk,Rv | kmovb Vk,Rv (66) | kmovq/d Vk,Rv (F2)</span>
<span class="p_del">-93: SETAE/NB/NC Eb | kmovw Gv,Uk | kmovb Gv,Uk (66) | kmovq/d Gv,Uk (F2)</span>
<span class="p_del">-94: SETE/Z Eb</span>
<span class="p_del">-95: SETNE/NZ Eb</span>
<span class="p_del">-96: SETBE/NA Eb</span>
<span class="p_del">-97: SETA/NBE Eb</span>
<span class="p_del">-98: SETS Eb | kortestw/q Vk,Uk | kortestb/d Vk,Uk (66)</span>
<span class="p_del">-99: SETNS Eb | ktestw/q Vk,Uk | ktestb/d Vk,Uk (66)</span>
<span class="p_del">-9a: SETP/PE Eb</span>
<span class="p_del">-9b: SETNP/PO Eb</span>
<span class="p_del">-9c: SETL/NGE Eb</span>
<span class="p_del">-9d: SETNL/GE Eb</span>
<span class="p_del">-9e: SETLE/NG Eb</span>
<span class="p_del">-9f: SETNLE/G Eb</span>
<span class="p_del">-# 0x0f 0xa0-0xaf</span>
<span class="p_del">-a0: PUSH FS (d64)</span>
<span class="p_del">-a1: POP FS (d64)</span>
<span class="p_del">-a2: CPUID</span>
<span class="p_del">-a3: BT Ev,Gv</span>
<span class="p_del">-a4: SHLD Ev,Gv,Ib</span>
<span class="p_del">-a5: SHLD Ev,Gv,CL</span>
<span class="p_del">-a6: GrpPDLK</span>
<span class="p_del">-a7: GrpRNG</span>
<span class="p_del">-a8: PUSH GS (d64)</span>
<span class="p_del">-a9: POP GS (d64)</span>
<span class="p_del">-aa: RSM</span>
<span class="p_del">-ab: BTS Ev,Gv</span>
<span class="p_del">-ac: SHRD Ev,Gv,Ib</span>
<span class="p_del">-ad: SHRD Ev,Gv,CL</span>
<span class="p_del">-ae: Grp15 (1A),(1C)</span>
<span class="p_del">-af: IMUL Gv,Ev</span>
<span class="p_del">-# 0x0f 0xb0-0xbf</span>
<span class="p_del">-b0: CMPXCHG Eb,Gb</span>
<span class="p_del">-b1: CMPXCHG Ev,Gv</span>
<span class="p_del">-b2: LSS Gv,Mp</span>
<span class="p_del">-b3: BTR Ev,Gv</span>
<span class="p_del">-b4: LFS Gv,Mp</span>
<span class="p_del">-b5: LGS Gv,Mp</span>
<span class="p_del">-b6: MOVZX Gv,Eb</span>
<span class="p_del">-b7: MOVZX Gv,Ew</span>
<span class="p_del">-b8: JMPE (!F3) | POPCNT Gv,Ev (F3)</span>
<span class="p_del">-b9: Grp10 (1A)</span>
<span class="p_del">-ba: Grp8 Ev,Ib (1A)</span>
<span class="p_del">-bb: BTC Ev,Gv</span>
<span class="p_del">-bc: BSF Gv,Ev (!F3) | TZCNT Gv,Ev (F3)</span>
<span class="p_del">-bd: BSR Gv,Ev (!F3) | LZCNT Gv,Ev (F3)</span>
<span class="p_del">-be: MOVSX Gv,Eb</span>
<span class="p_del">-bf: MOVSX Gv,Ew</span>
<span class="p_del">-# 0x0f 0xc0-0xcf</span>
<span class="p_del">-c0: XADD Eb,Gb</span>
<span class="p_del">-c1: XADD Ev,Gv</span>
<span class="p_del">-c2: vcmpps Vps,Hps,Wps,Ib | vcmppd Vpd,Hpd,Wpd,Ib (66) | vcmpss Vss,Hss,Wss,Ib (F3),(v1) | vcmpsd Vsd,Hsd,Wsd,Ib (F2),(v1)</span>
<span class="p_del">-c3: movnti My,Gy</span>
<span class="p_del">-c4: pinsrw Pq,Ry/Mw,Ib | vpinsrw Vdq,Hdq,Ry/Mw,Ib (66),(v1)</span>
<span class="p_del">-c5: pextrw Gd,Nq,Ib | vpextrw Gd,Udq,Ib (66),(v1)</span>
<span class="p_del">-c6: vshufps Vps,Hps,Wps,Ib | vshufpd Vpd,Hpd,Wpd,Ib (66)</span>
<span class="p_del">-c7: Grp9 (1A)</span>
<span class="p_del">-c8: BSWAP RAX/EAX/R8/R8D</span>
<span class="p_del">-c9: BSWAP RCX/ECX/R9/R9D</span>
<span class="p_del">-ca: BSWAP RDX/EDX/R10/R10D</span>
<span class="p_del">-cb: BSWAP RBX/EBX/R11/R11D</span>
<span class="p_del">-cc: BSWAP RSP/ESP/R12/R12D</span>
<span class="p_del">-cd: BSWAP RBP/EBP/R13/R13D</span>
<span class="p_del">-ce: BSWAP RSI/ESI/R14/R14D</span>
<span class="p_del">-cf: BSWAP RDI/EDI/R15/R15D</span>
<span class="p_del">-# 0x0f 0xd0-0xdf</span>
<span class="p_del">-d0: vaddsubpd Vpd,Hpd,Wpd (66) | vaddsubps Vps,Hps,Wps (F2)</span>
<span class="p_del">-d1: psrlw Pq,Qq | vpsrlw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-d2: psrld Pq,Qq | vpsrld Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-d3: psrlq Pq,Qq | vpsrlq Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-d4: paddq Pq,Qq | vpaddq Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-d5: pmullw Pq,Qq | vpmullw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-d6: vmovq Wq,Vq (66),(v1) | movq2dq Vdq,Nq (F3) | movdq2q Pq,Uq (F2)</span>
<span class="p_del">-d7: pmovmskb Gd,Nq | vpmovmskb Gd,Ux (66),(v1)</span>
<span class="p_del">-d8: psubusb Pq,Qq | vpsubusb Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-d9: psubusw Pq,Qq | vpsubusw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-da: pminub Pq,Qq | vpminub Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-db: pand Pq,Qq | vpand Vx,Hx,Wx (66),(v1) | vpandd/q Vx,Hx,Wx (66),(evo)</span>
<span class="p_del">-dc: paddusb Pq,Qq | vpaddusb Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-dd: paddusw Pq,Qq | vpaddusw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-de: pmaxub Pq,Qq | vpmaxub Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-df: pandn Pq,Qq | vpandn Vx,Hx,Wx (66),(v1) | vpandnd/q Vx,Hx,Wx (66),(evo)</span>
<span class="p_del">-# 0x0f 0xe0-0xef</span>
<span class="p_del">-e0: pavgb Pq,Qq | vpavgb Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-e1: psraw Pq,Qq | vpsraw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-e2: psrad Pq,Qq | vpsrad Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-e3: pavgw Pq,Qq | vpavgw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-e4: pmulhuw Pq,Qq | vpmulhuw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-e5: pmulhw Pq,Qq | vpmulhw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-e6: vcvttpd2dq Vx,Wpd (66) | vcvtdq2pd Vx,Wdq (F3) | vcvtdq2pd/qq2pd Vx,Wdq (F3),(evo) | vcvtpd2dq Vx,Wpd (F2)</span>
<span class="p_del">-e7: movntq Mq,Pq | vmovntdq Mx,Vx (66)</span>
<span class="p_del">-e8: psubsb Pq,Qq | vpsubsb Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-e9: psubsw Pq,Qq | vpsubsw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-ea: pminsw Pq,Qq | vpminsw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-eb: por Pq,Qq | vpor Vx,Hx,Wx (66),(v1) | vpord/q Vx,Hx,Wx (66),(evo)</span>
<span class="p_del">-ec: paddsb Pq,Qq | vpaddsb Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-ed: paddsw Pq,Qq | vpaddsw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-ee: pmaxsw Pq,Qq | vpmaxsw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-ef: pxor Pq,Qq | vpxor Vx,Hx,Wx (66),(v1) | vpxord/q Vx,Hx,Wx (66),(evo)</span>
<span class="p_del">-# 0x0f 0xf0-0xff</span>
<span class="p_del">-f0: vlddqu Vx,Mx (F2)</span>
<span class="p_del">-f1: psllw Pq,Qq | vpsllw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-f2: pslld Pq,Qq | vpslld Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-f3: psllq Pq,Qq | vpsllq Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-f4: pmuludq Pq,Qq | vpmuludq Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-f5: pmaddwd Pq,Qq | vpmaddwd Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-f6: psadbw Pq,Qq | vpsadbw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-f7: maskmovq Pq,Nq | vmaskmovdqu Vx,Ux (66),(v1)</span>
<span class="p_del">-f8: psubb Pq,Qq | vpsubb Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-f9: psubw Pq,Qq | vpsubw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-fa: psubd Pq,Qq | vpsubd Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-fb: psubq Pq,Qq | vpsubq Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-fc: paddb Pq,Qq | vpaddb Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-fd: paddw Pq,Qq | vpaddw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-fe: paddd Pq,Qq | vpaddd Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-ff:</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-Table: 3-byte opcode 1 (0x0f 0x38)</span>
<span class="p_del">-Referrer: 3-byte escape 1</span>
<span class="p_del">-AVXcode: 2</span>
<span class="p_del">-# 0x0f 0x38 0x00-0x0f</span>
<span class="p_del">-00: pshufb Pq,Qq | vpshufb Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-01: phaddw Pq,Qq | vphaddw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-02: phaddd Pq,Qq | vphaddd Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-03: phaddsw Pq,Qq | vphaddsw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-04: pmaddubsw Pq,Qq | vpmaddubsw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-05: phsubw Pq,Qq | vphsubw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-06: phsubd Pq,Qq | vphsubd Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-07: phsubsw Pq,Qq | vphsubsw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-08: psignb Pq,Qq | vpsignb Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-09: psignw Pq,Qq | vpsignw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-0a: psignd Pq,Qq | vpsignd Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-0b: pmulhrsw Pq,Qq | vpmulhrsw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-0c: vpermilps Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-0d: vpermilpd Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-0e: vtestps Vx,Wx (66),(v)</span>
<span class="p_del">-0f: vtestpd Vx,Wx (66),(v)</span>
<span class="p_del">-# 0x0f 0x38 0x10-0x1f</span>
<span class="p_del">-10: pblendvb Vdq,Wdq (66) | vpsrlvw Vx,Hx,Wx (66),(evo) | vpmovuswb Wx,Vx (F3),(ev)</span>
<span class="p_del">-11: vpmovusdb Wx,Vd (F3),(ev) | vpsravw Vx,Hx,Wx (66),(ev)</span>
<span class="p_del">-12: vpmovusqb Wx,Vq (F3),(ev) | vpsllvw Vx,Hx,Wx (66),(ev)</span>
<span class="p_del">-13: vcvtph2ps Vx,Wx (66),(v) | vpmovusdw Wx,Vd (F3),(ev)</span>
<span class="p_del">-14: blendvps Vdq,Wdq (66) | vpmovusqw Wx,Vq (F3),(ev) | vprorvd/q Vx,Hx,Wx (66),(evo)</span>
<span class="p_del">-15: blendvpd Vdq,Wdq (66) | vpmovusqd Wx,Vq (F3),(ev) | vprolvd/q Vx,Hx,Wx (66),(evo)</span>
<span class="p_del">-16: vpermps Vqq,Hqq,Wqq (66),(v) | vpermps/d Vqq,Hqq,Wqq (66),(evo)</span>
<span class="p_del">-17: vptest Vx,Wx (66)</span>
<span class="p_del">-18: vbroadcastss Vx,Wd (66),(v)</span>
<span class="p_del">-19: vbroadcastsd Vqq,Wq (66),(v) | vbroadcastf32x2 Vqq,Wq (66),(evo)</span>
<span class="p_del">-1a: vbroadcastf128 Vqq,Mdq (66),(v) | vbroadcastf32x4/64x2 Vqq,Wq (66),(evo)</span>
<span class="p_del">-1b: vbroadcastf32x8/64x4 Vqq,Mdq (66),(ev)</span>
<span class="p_del">-1c: pabsb Pq,Qq | vpabsb Vx,Wx (66),(v1)</span>
<span class="p_del">-1d: pabsw Pq,Qq | vpabsw Vx,Wx (66),(v1)</span>
<span class="p_del">-1e: pabsd Pq,Qq | vpabsd Vx,Wx (66),(v1)</span>
<span class="p_del">-1f: vpabsq Vx,Wx (66),(ev)</span>
<span class="p_del">-# 0x0f 0x38 0x20-0x2f</span>
<span class="p_del">-20: vpmovsxbw Vx,Ux/Mq (66),(v1) | vpmovswb Wx,Vx (F3),(ev)</span>
<span class="p_del">-21: vpmovsxbd Vx,Ux/Md (66),(v1) | vpmovsdb Wx,Vd (F3),(ev)</span>
<span class="p_del">-22: vpmovsxbq Vx,Ux/Mw (66),(v1) | vpmovsqb Wx,Vq (F3),(ev)</span>
<span class="p_del">-23: vpmovsxwd Vx,Ux/Mq (66),(v1) | vpmovsdw Wx,Vd (F3),(ev)</span>
<span class="p_del">-24: vpmovsxwq Vx,Ux/Md (66),(v1) | vpmovsqw Wx,Vq (F3),(ev)</span>
<span class="p_del">-25: vpmovsxdq Vx,Ux/Mq (66),(v1) | vpmovsqd Wx,Vq (F3),(ev)</span>
<span class="p_del">-26: vptestmb/w Vk,Hx,Wx (66),(ev) | vptestnmb/w Vk,Hx,Wx (F3),(ev)</span>
<span class="p_del">-27: vptestmd/q Vk,Hx,Wx (66),(ev) | vptestnmd/q Vk,Hx,Wx (F3),(ev)</span>
<span class="p_del">-28: vpmuldq Vx,Hx,Wx (66),(v1) | vpmovm2b/w Vx,Uk (F3),(ev)</span>
<span class="p_del">-29: vpcmpeqq Vx,Hx,Wx (66),(v1) | vpmovb2m/w2m Vk,Ux (F3),(ev)</span>
<span class="p_del">-2a: vmovntdqa Vx,Mx (66),(v1) | vpbroadcastmb2q Vx,Uk (F3),(ev)</span>
<span class="p_del">-2b: vpackusdw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-2c: vmaskmovps Vx,Hx,Mx (66),(v) | vscalefps/d Vx,Hx,Wx (66),(evo)</span>
<span class="p_del">-2d: vmaskmovpd Vx,Hx,Mx (66),(v) | vscalefss/d Vx,Hx,Wx (66),(evo)</span>
<span class="p_del">-2e: vmaskmovps Mx,Hx,Vx (66),(v)</span>
<span class="p_del">-2f: vmaskmovpd Mx,Hx,Vx (66),(v)</span>
<span class="p_del">-# 0x0f 0x38 0x30-0x3f</span>
<span class="p_del">-30: vpmovzxbw Vx,Ux/Mq (66),(v1) | vpmovwb Wx,Vx (F3),(ev)</span>
<span class="p_del">-31: vpmovzxbd Vx,Ux/Md (66),(v1) | vpmovdb Wx,Vd (F3),(ev)</span>
<span class="p_del">-32: vpmovzxbq Vx,Ux/Mw (66),(v1) | vpmovqb Wx,Vq (F3),(ev)</span>
<span class="p_del">-33: vpmovzxwd Vx,Ux/Mq (66),(v1) | vpmovdw Wx,Vd (F3),(ev)</span>
<span class="p_del">-34: vpmovzxwq Vx,Ux/Md (66),(v1) | vpmovqw Wx,Vq (F3),(ev)</span>
<span class="p_del">-35: vpmovzxdq Vx,Ux/Mq (66),(v1) | vpmovqd Wx,Vq (F3),(ev)</span>
<span class="p_del">-36: vpermd Vqq,Hqq,Wqq (66),(v) | vpermd/q Vqq,Hqq,Wqq (66),(evo)</span>
<span class="p_del">-37: vpcmpgtq Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-38: vpminsb Vx,Hx,Wx (66),(v1) | vpmovm2d/q Vx,Uk (F3),(ev)</span>
<span class="p_del">-39: vpminsd Vx,Hx,Wx (66),(v1) | vpminsd/q Vx,Hx,Wx (66),(evo) | vpmovd2m/q2m Vk,Ux (F3),(ev)</span>
<span class="p_del">-3a: vpminuw Vx,Hx,Wx (66),(v1) | vpbroadcastmw2d Vx,Uk (F3),(ev)</span>
<span class="p_del">-3b: vpminud Vx,Hx,Wx (66),(v1) | vpminud/q Vx,Hx,Wx (66),(evo)</span>
<span class="p_del">-3c: vpmaxsb Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-3d: vpmaxsd Vx,Hx,Wx (66),(v1) | vpmaxsd/q Vx,Hx,Wx (66),(evo)</span>
<span class="p_del">-3e: vpmaxuw Vx,Hx,Wx (66),(v1)</span>
<span class="p_del">-3f: vpmaxud Vx,Hx,Wx (66),(v1) | vpmaxud/q Vx,Hx,Wx (66),(evo)</span>
<span class="p_del">-# 0x0f 0x38 0x40-0x8f</span>
<span class="p_del">-40: vpmulld Vx,Hx,Wx (66),(v1) | vpmulld/q Vx,Hx,Wx (66),(evo)</span>
<span class="p_del">-41: vphminposuw Vdq,Wdq (66),(v1)</span>
<span class="p_del">-42: vgetexpps/d Vx,Wx (66),(ev)</span>
<span class="p_del">-43: vgetexpss/d Vx,Hx,Wx (66),(ev)</span>
<span class="p_del">-44: vplzcntd/q Vx,Wx (66),(ev)</span>
<span class="p_del">-45: vpsrlvd/q Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-46: vpsravd Vx,Hx,Wx (66),(v) | vpsravd/q Vx,Hx,Wx (66),(evo)</span>
<span class="p_del">-47: vpsllvd/q Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-# Skip 0x48-0x4b</span>
<span class="p_del">-4c: vrcp14ps/d Vpd,Wpd (66),(ev)</span>
<span class="p_del">-4d: vrcp14ss/d Vsd,Hpd,Wsd (66),(ev)</span>
<span class="p_del">-4e: vrsqrt14ps/d Vpd,Wpd (66),(ev)</span>
<span class="p_del">-4f: vrsqrt14ss/d Vsd,Hsd,Wsd (66),(ev)</span>
<span class="p_del">-# Skip 0x50-0x57</span>
<span class="p_del">-58: vpbroadcastd Vx,Wx (66),(v)</span>
<span class="p_del">-59: vpbroadcastq Vx,Wx (66),(v) | vbroadcasti32x2 Vx,Wx (66),(evo)</span>
<span class="p_del">-5a: vbroadcasti128 Vqq,Mdq (66),(v) | vbroadcasti32x4/64x2 Vx,Wx (66),(evo)</span>
<span class="p_del">-5b: vbroadcasti32x8/64x4 Vqq,Mdq (66),(ev)</span>
<span class="p_del">-# Skip 0x5c-0x63</span>
<span class="p_del">-64: vpblendmd/q Vx,Hx,Wx (66),(ev)</span>
<span class="p_del">-65: vblendmps/d Vx,Hx,Wx (66),(ev)</span>
<span class="p_del">-66: vpblendmb/w Vx,Hx,Wx (66),(ev)</span>
<span class="p_del">-# Skip 0x67-0x74</span>
<span class="p_del">-75: vpermi2b/w Vx,Hx,Wx (66),(ev)</span>
<span class="p_del">-76: vpermi2d/q Vx,Hx,Wx (66),(ev)</span>
<span class="p_del">-77: vpermi2ps/d Vx,Hx,Wx (66),(ev)</span>
<span class="p_del">-78: vpbroadcastb Vx,Wx (66),(v)</span>
<span class="p_del">-79: vpbroadcastw Vx,Wx (66),(v)</span>
<span class="p_del">-7a: vpbroadcastb Vx,Rv (66),(ev)</span>
<span class="p_del">-7b: vpbroadcastw Vx,Rv (66),(ev)</span>
<span class="p_del">-7c: vpbroadcastd/q Vx,Rv (66),(ev)</span>
<span class="p_del">-7d: vpermt2b/w Vx,Hx,Wx (66),(ev)</span>
<span class="p_del">-7e: vpermt2d/q Vx,Hx,Wx (66),(ev)</span>
<span class="p_del">-7f: vpermt2ps/d Vx,Hx,Wx (66),(ev)</span>
<span class="p_del">-80: INVEPT Gy,Mdq (66)</span>
<span class="p_del">-81: INVPID Gy,Mdq (66)</span>
<span class="p_del">-82: INVPCID Gy,Mdq (66)</span>
<span class="p_del">-83: vpmultishiftqb Vx,Hx,Wx (66),(ev)</span>
<span class="p_del">-88: vexpandps/d Vpd,Wpd (66),(ev)</span>
<span class="p_del">-89: vpexpandd/q Vx,Wx (66),(ev)</span>
<span class="p_del">-8a: vcompressps/d Wx,Vx (66),(ev)</span>
<span class="p_del">-8b: vpcompressd/q Wx,Vx (66),(ev)</span>
<span class="p_del">-8c: vpmaskmovd/q Vx,Hx,Mx (66),(v)</span>
<span class="p_del">-8d: vpermb/w Vx,Hx,Wx (66),(ev)</span>
<span class="p_del">-8e: vpmaskmovd/q Mx,Vx,Hx (66),(v)</span>
<span class="p_del">-# 0x0f 0x38 0x90-0xbf (FMA)</span>
<span class="p_del">-90: vgatherdd/q Vx,Hx,Wx (66),(v) | vpgatherdd/q Vx,Wx (66),(evo)</span>
<span class="p_del">-91: vgatherqd/q Vx,Hx,Wx (66),(v) | vpgatherqd/q Vx,Wx (66),(evo)</span>
<span class="p_del">-92: vgatherdps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-93: vgatherqps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-94:</span>
<span class="p_del">-95:</span>
<span class="p_del">-96: vfmaddsub132ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-97: vfmsubadd132ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-98: vfmadd132ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-99: vfmadd132ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_del">-9a: vfmsub132ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-9b: vfmsub132ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_del">-9c: vfnmadd132ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-9d: vfnmadd132ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_del">-9e: vfnmsub132ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-9f: vfnmsub132ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_del">-a0: vpscatterdd/q Wx,Vx (66),(ev)</span>
<span class="p_del">-a1: vpscatterqd/q Wx,Vx (66),(ev)</span>
<span class="p_del">-a2: vscatterdps/d Wx,Vx (66),(ev)</span>
<span class="p_del">-a3: vscatterqps/d Wx,Vx (66),(ev)</span>
<span class="p_del">-a6: vfmaddsub213ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-a7: vfmsubadd213ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-a8: vfmadd213ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-a9: vfmadd213ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_del">-aa: vfmsub213ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-ab: vfmsub213ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_del">-ac: vfnmadd213ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-ad: vfnmadd213ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_del">-ae: vfnmsub213ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-af: vfnmsub213ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_del">-b4: vpmadd52luq Vx,Hx,Wx (66),(ev)</span>
<span class="p_del">-b5: vpmadd52huq Vx,Hx,Wx (66),(ev)</span>
<span class="p_del">-b6: vfmaddsub231ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-b7: vfmsubadd231ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-b8: vfmadd231ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-b9: vfmadd231ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_del">-ba: vfmsub231ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-bb: vfmsub231ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_del">-bc: vfnmadd231ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-bd: vfnmadd231ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_del">-be: vfnmsub231ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_del">-bf: vfnmsub231ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_del">-# 0x0f 0x38 0xc0-0xff</span>
<span class="p_del">-c4: vpconflictd/q Vx,Wx (66),(ev)</span>
<span class="p_del">-c6: Grp18 (1A)</span>
<span class="p_del">-c7: Grp19 (1A)</span>
<span class="p_del">-c8: sha1nexte Vdq,Wdq | vexp2ps/d Vx,Wx (66),(ev)</span>
<span class="p_del">-c9: sha1msg1 Vdq,Wdq</span>
<span class="p_del">-ca: sha1msg2 Vdq,Wdq | vrcp28ps/d Vx,Wx (66),(ev)</span>
<span class="p_del">-cb: sha256rnds2 Vdq,Wdq | vrcp28ss/d Vx,Hx,Wx (66),(ev)</span>
<span class="p_del">-cc: sha256msg1 Vdq,Wdq | vrsqrt28ps/d Vx,Wx (66),(ev)</span>
<span class="p_del">-cd: sha256msg2 Vdq,Wdq | vrsqrt28ss/d Vx,Hx,Wx (66),(ev)</span>
<span class="p_del">-db: VAESIMC Vdq,Wdq (66),(v1)</span>
<span class="p_del">-dc: VAESENC Vdq,Hdq,Wdq (66),(v1)</span>
<span class="p_del">-dd: VAESENCLAST Vdq,Hdq,Wdq (66),(v1)</span>
<span class="p_del">-de: VAESDEC Vdq,Hdq,Wdq (66),(v1)</span>
<span class="p_del">-df: VAESDECLAST Vdq,Hdq,Wdq (66),(v1)</span>
<span class="p_del">-f0: MOVBE Gy,My | MOVBE Gw,Mw (66) | CRC32 Gd,Eb (F2) | CRC32 Gd,Eb (66&amp;F2)</span>
<span class="p_del">-f1: MOVBE My,Gy | MOVBE Mw,Gw (66) | CRC32 Gd,Ey (F2) | CRC32 Gd,Ew (66&amp;F2)</span>
<span class="p_del">-f2: ANDN Gy,By,Ey (v)</span>
<span class="p_del">-f3: Grp17 (1A)</span>
<span class="p_del">-f5: BZHI Gy,Ey,By (v) | PEXT Gy,By,Ey (F3),(v) | PDEP Gy,By,Ey (F2),(v)</span>
<span class="p_del">-f6: ADCX Gy,Ey (66) | ADOX Gy,Ey (F3) | MULX By,Gy,rDX,Ey (F2),(v)</span>
<span class="p_del">-f7: BEXTR Gy,Ey,By (v) | SHLX Gy,Ey,By (66),(v) | SARX Gy,Ey,By (F3),(v) | SHRX Gy,Ey,By (F2),(v)</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-Table: 3-byte opcode 2 (0x0f 0x3a)</span>
<span class="p_del">-Referrer: 3-byte escape 2</span>
<span class="p_del">-AVXcode: 3</span>
<span class="p_del">-# 0x0f 0x3a 0x00-0xff</span>
<span class="p_del">-00: vpermq Vqq,Wqq,Ib (66),(v)</span>
<span class="p_del">-01: vpermpd Vqq,Wqq,Ib (66),(v)</span>
<span class="p_del">-02: vpblendd Vx,Hx,Wx,Ib (66),(v)</span>
<span class="p_del">-03: valignd/q Vx,Hx,Wx,Ib (66),(ev)</span>
<span class="p_del">-04: vpermilps Vx,Wx,Ib (66),(v)</span>
<span class="p_del">-05: vpermilpd Vx,Wx,Ib (66),(v)</span>
<span class="p_del">-06: vperm2f128 Vqq,Hqq,Wqq,Ib (66),(v)</span>
<span class="p_del">-07:</span>
<span class="p_del">-08: vroundps Vx,Wx,Ib (66) | vrndscaleps Vx,Wx,Ib (66),(evo)</span>
<span class="p_del">-09: vroundpd Vx,Wx,Ib (66) | vrndscalepd Vx,Wx,Ib (66),(evo)</span>
<span class="p_del">-0a: vroundss Vss,Wss,Ib (66),(v1) | vrndscaless Vx,Hx,Wx,Ib (66),(evo)</span>
<span class="p_del">-0b: vroundsd Vsd,Wsd,Ib (66),(v1) | vrndscalesd Vx,Hx,Wx,Ib (66),(evo)</span>
<span class="p_del">-0c: vblendps Vx,Hx,Wx,Ib (66)</span>
<span class="p_del">-0d: vblendpd Vx,Hx,Wx,Ib (66)</span>
<span class="p_del">-0e: vpblendw Vx,Hx,Wx,Ib (66),(v1)</span>
<span class="p_del">-0f: palignr Pq,Qq,Ib | vpalignr Vx,Hx,Wx,Ib (66),(v1)</span>
<span class="p_del">-14: vpextrb Rd/Mb,Vdq,Ib (66),(v1)</span>
<span class="p_del">-15: vpextrw Rd/Mw,Vdq,Ib (66),(v1)</span>
<span class="p_del">-16: vpextrd/q Ey,Vdq,Ib (66),(v1)</span>
<span class="p_del">-17: vextractps Ed,Vdq,Ib (66),(v1)</span>
<span class="p_del">-18: vinsertf128 Vqq,Hqq,Wqq,Ib (66),(v) | vinsertf32x4/64x2 Vqq,Hqq,Wqq,Ib (66),(evo)</span>
<span class="p_del">-19: vextractf128 Wdq,Vqq,Ib (66),(v) | vextractf32x4/64x2 Wdq,Vqq,Ib (66),(evo)</span>
<span class="p_del">-1a: vinsertf32x8/64x4 Vqq,Hqq,Wqq,Ib (66),(ev)</span>
<span class="p_del">-1b: vextractf32x8/64x4 Wdq,Vqq,Ib (66),(ev)</span>
<span class="p_del">-1d: vcvtps2ph Wx,Vx,Ib (66),(v)</span>
<span class="p_del">-1e: vpcmpud/q Vk,Hd,Wd,Ib (66),(ev)</span>
<span class="p_del">-1f: vpcmpd/q Vk,Hd,Wd,Ib (66),(ev)</span>
<span class="p_del">-20: vpinsrb Vdq,Hdq,Ry/Mb,Ib (66),(v1)</span>
<span class="p_del">-21: vinsertps Vdq,Hdq,Udq/Md,Ib (66),(v1)</span>
<span class="p_del">-22: vpinsrd/q Vdq,Hdq,Ey,Ib (66),(v1)</span>
<span class="p_del">-23: vshuff32x4/64x2 Vx,Hx,Wx,Ib (66),(ev)</span>
<span class="p_del">-25: vpternlogd/q Vx,Hx,Wx,Ib (66),(ev)</span>
<span class="p_del">-26: vgetmantps/d Vx,Wx,Ib (66),(ev)</span>
<span class="p_del">-27: vgetmantss/d Vx,Hx,Wx,Ib (66),(ev)</span>
<span class="p_del">-30: kshiftrb/w Vk,Uk,Ib (66),(v)</span>
<span class="p_del">-31: kshiftrd/q Vk,Uk,Ib (66),(v)</span>
<span class="p_del">-32: kshiftlb/w Vk,Uk,Ib (66),(v)</span>
<span class="p_del">-33: kshiftld/q Vk,Uk,Ib (66),(v)</span>
<span class="p_del">-38: vinserti128 Vqq,Hqq,Wqq,Ib (66),(v) | vinserti32x4/64x2 Vqq,Hqq,Wqq,Ib (66),(evo)</span>
<span class="p_del">-39: vextracti128 Wdq,Vqq,Ib (66),(v) | vextracti32x4/64x2 Wdq,Vqq,Ib (66),(evo)</span>
<span class="p_del">-3a: vinserti32x8/64x4 Vqq,Hqq,Wqq,Ib (66),(ev)</span>
<span class="p_del">-3b: vextracti32x8/64x4 Wdq,Vqq,Ib (66),(ev)</span>
<span class="p_del">-3e: vpcmpub/w Vk,Hk,Wx,Ib (66),(ev)</span>
<span class="p_del">-3f: vpcmpb/w Vk,Hk,Wx,Ib (66),(ev)</span>
<span class="p_del">-40: vdpps Vx,Hx,Wx,Ib (66)</span>
<span class="p_del">-41: vdppd Vdq,Hdq,Wdq,Ib (66),(v1)</span>
<span class="p_del">-42: vmpsadbw Vx,Hx,Wx,Ib (66),(v1) | vdbpsadbw Vx,Hx,Wx,Ib (66),(evo)</span>
<span class="p_del">-43: vshufi32x4/64x2 Vx,Hx,Wx,Ib (66),(ev)</span>
<span class="p_del">-44: vpclmulqdq Vdq,Hdq,Wdq,Ib (66),(v1)</span>
<span class="p_del">-46: vperm2i128 Vqq,Hqq,Wqq,Ib (66),(v)</span>
<span class="p_del">-4a: vblendvps Vx,Hx,Wx,Lx (66),(v)</span>
<span class="p_del">-4b: vblendvpd Vx,Hx,Wx,Lx (66),(v)</span>
<span class="p_del">-4c: vpblendvb Vx,Hx,Wx,Lx (66),(v1)</span>
<span class="p_del">-50: vrangeps/d Vx,Hx,Wx,Ib (66),(ev)</span>
<span class="p_del">-51: vrangess/d Vx,Hx,Wx,Ib (66),(ev)</span>
<span class="p_del">-54: vfixupimmps/d Vx,Hx,Wx,Ib (66),(ev)</span>
<span class="p_del">-55: vfixupimmss/d Vx,Hx,Wx,Ib (66),(ev)</span>
<span class="p_del">-56: vreduceps/d Vx,Wx,Ib (66),(ev)</span>
<span class="p_del">-57: vreducess/d Vx,Hx,Wx,Ib (66),(ev)</span>
<span class="p_del">-60: vpcmpestrm Vdq,Wdq,Ib (66),(v1)</span>
<span class="p_del">-61: vpcmpestri Vdq,Wdq,Ib (66),(v1)</span>
<span class="p_del">-62: vpcmpistrm Vdq,Wdq,Ib (66),(v1)</span>
<span class="p_del">-63: vpcmpistri Vdq,Wdq,Ib (66),(v1)</span>
<span class="p_del">-66: vfpclassps/d Vk,Wx,Ib (66),(ev)</span>
<span class="p_del">-67: vfpclassss/d Vk,Wx,Ib (66),(ev)</span>
<span class="p_del">-cc: sha1rnds4 Vdq,Wdq,Ib</span>
<span class="p_del">-df: VAESKEYGEN Vdq,Wdq,Ib (66),(v1)</span>
<span class="p_del">-f0: RORX Gy,Ey,Ib (F2),(v)</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: Grp1</span>
<span class="p_del">-0: ADD</span>
<span class="p_del">-1: OR</span>
<span class="p_del">-2: ADC</span>
<span class="p_del">-3: SBB</span>
<span class="p_del">-4: AND</span>
<span class="p_del">-5: SUB</span>
<span class="p_del">-6: XOR</span>
<span class="p_del">-7: CMP</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: Grp1A</span>
<span class="p_del">-0: POP</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: Grp2</span>
<span class="p_del">-0: ROL</span>
<span class="p_del">-1: ROR</span>
<span class="p_del">-2: RCL</span>
<span class="p_del">-3: RCR</span>
<span class="p_del">-4: SHL/SAL</span>
<span class="p_del">-5: SHR</span>
<span class="p_del">-6:</span>
<span class="p_del">-7: SAR</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: Grp3_1</span>
<span class="p_del">-0: TEST Eb,Ib</span>
<span class="p_del">-1:</span>
<span class="p_del">-2: NOT Eb</span>
<span class="p_del">-3: NEG Eb</span>
<span class="p_del">-4: MUL AL,Eb</span>
<span class="p_del">-5: IMUL AL,Eb</span>
<span class="p_del">-6: DIV AL,Eb</span>
<span class="p_del">-7: IDIV AL,Eb</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: Grp3_2</span>
<span class="p_del">-0: TEST Ev,Iz</span>
<span class="p_del">-1:</span>
<span class="p_del">-2: NOT Ev</span>
<span class="p_del">-3: NEG Ev</span>
<span class="p_del">-4: MUL rAX,Ev</span>
<span class="p_del">-5: IMUL rAX,Ev</span>
<span class="p_del">-6: DIV rAX,Ev</span>
<span class="p_del">-7: IDIV rAX,Ev</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: Grp4</span>
<span class="p_del">-0: INC Eb</span>
<span class="p_del">-1: DEC Eb</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: Grp5</span>
<span class="p_del">-0: INC Ev</span>
<span class="p_del">-1: DEC Ev</span>
<span class="p_del">-# Note: &quot;forced64&quot; is Intel CPU behavior (see comment about CALL insn).</span>
<span class="p_del">-2: CALLN Ev (f64)</span>
<span class="p_del">-3: CALLF Ep</span>
<span class="p_del">-4: JMPN Ev (f64)</span>
<span class="p_del">-5: JMPF Mp</span>
<span class="p_del">-6: PUSH Ev (d64)</span>
<span class="p_del">-7:</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: Grp6</span>
<span class="p_del">-0: SLDT Rv/Mw</span>
<span class="p_del">-1: STR Rv/Mw</span>
<span class="p_del">-2: LLDT Ew</span>
<span class="p_del">-3: LTR Ew</span>
<span class="p_del">-4: VERR Ew</span>
<span class="p_del">-5: VERW Ew</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: Grp7</span>
<span class="p_del">-0: SGDT Ms | VMCALL (001),(11B) | VMLAUNCH (010),(11B) | VMRESUME (011),(11B) | VMXOFF (100),(11B)</span>
<span class="p_del">-1: SIDT Ms | MONITOR (000),(11B) | MWAIT (001),(11B) | CLAC (010),(11B) | STAC (011),(11B)</span>
<span class="p_del">-2: LGDT Ms | XGETBV (000),(11B) | XSETBV (001),(11B) | VMFUNC (100),(11B) | XEND (101)(11B) | XTEST (110)(11B)</span>
<span class="p_del">-3: LIDT Ms</span>
<span class="p_del">-4: SMSW Mw/Rv</span>
<span class="p_del">-5: rdpkru (110),(11B) | wrpkru (111),(11B)</span>
<span class="p_del">-6: LMSW Ew</span>
<span class="p_del">-7: INVLPG Mb | SWAPGS (o64),(000),(11B) | RDTSCP (001),(11B)</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: Grp8</span>
<span class="p_del">-4: BT</span>
<span class="p_del">-5: BTS</span>
<span class="p_del">-6: BTR</span>
<span class="p_del">-7: BTC</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: Grp9</span>
<span class="p_del">-1: CMPXCHG8B/16B Mq/Mdq</span>
<span class="p_del">-3: xrstors</span>
<span class="p_del">-4: xsavec</span>
<span class="p_del">-5: xsaves</span>
<span class="p_del">-6: VMPTRLD Mq | VMCLEAR Mq (66) | VMXON Mq (F3) | RDRAND Rv (11B)</span>
<span class="p_del">-7: VMPTRST Mq | VMPTRST Mq (F3) | RDSEED Rv (11B)</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: Grp10</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-# Grp11A and Grp11B are expressed as Grp11 in Intel SDM</span>
<span class="p_del">-GrpTable: Grp11A</span>
<span class="p_del">-0: MOV Eb,Ib</span>
<span class="p_del">-7: XABORT Ib (000),(11B)</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: Grp11B</span>
<span class="p_del">-0: MOV Eb,Iz</span>
<span class="p_del">-7: XBEGIN Jz (000),(11B)</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: Grp12</span>
<span class="p_del">-2: psrlw Nq,Ib (11B) | vpsrlw Hx,Ux,Ib (66),(11B),(v1)</span>
<span class="p_del">-4: psraw Nq,Ib (11B) | vpsraw Hx,Ux,Ib (66),(11B),(v1)</span>
<span class="p_del">-6: psllw Nq,Ib (11B) | vpsllw Hx,Ux,Ib (66),(11B),(v1)</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: Grp13</span>
<span class="p_del">-0: vprord/q Hx,Wx,Ib (66),(ev)</span>
<span class="p_del">-1: vprold/q Hx,Wx,Ib (66),(ev)</span>
<span class="p_del">-2: psrld Nq,Ib (11B) | vpsrld Hx,Ux,Ib (66),(11B),(v1)</span>
<span class="p_del">-4: psrad Nq,Ib (11B) | vpsrad Hx,Ux,Ib (66),(11B),(v1) | vpsrad/q Hx,Ux,Ib (66),(evo)</span>
<span class="p_del">-6: pslld Nq,Ib (11B) | vpslld Hx,Ux,Ib (66),(11B),(v1)</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: Grp14</span>
<span class="p_del">-2: psrlq Nq,Ib (11B) | vpsrlq Hx,Ux,Ib (66),(11B),(v1)</span>
<span class="p_del">-3: vpsrldq Hx,Ux,Ib (66),(11B),(v1)</span>
<span class="p_del">-6: psllq Nq,Ib (11B) | vpsllq Hx,Ux,Ib (66),(11B),(v1)</span>
<span class="p_del">-7: vpslldq Hx,Ux,Ib (66),(11B),(v1)</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: Grp15</span>
<span class="p_del">-0: fxsave | RDFSBASE Ry (F3),(11B)</span>
<span class="p_del">-1: fxstor | RDGSBASE Ry (F3),(11B)</span>
<span class="p_del">-2: vldmxcsr Md (v1) | WRFSBASE Ry (F3),(11B)</span>
<span class="p_del">-3: vstmxcsr Md (v1) | WRGSBASE Ry (F3),(11B)</span>
<span class="p_del">-4: XSAVE | ptwrite Ey (F3),(11B)</span>
<span class="p_del">-5: XRSTOR | lfence (11B)</span>
<span class="p_del">-6: XSAVEOPT | clwb (66) | mfence (11B)</span>
<span class="p_del">-7: clflush | clflushopt (66) | sfence (11B)</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: Grp16</span>
<span class="p_del">-0: prefetch NTA</span>
<span class="p_del">-1: prefetch T0</span>
<span class="p_del">-2: prefetch T1</span>
<span class="p_del">-3: prefetch T2</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: Grp17</span>
<span class="p_del">-1: BLSR By,Ey (v)</span>
<span class="p_del">-2: BLSMSK By,Ey (v)</span>
<span class="p_del">-3: BLSI By,Ey (v)</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: Grp18</span>
<span class="p_del">-1: vgatherpf0dps/d Wx (66),(ev)</span>
<span class="p_del">-2: vgatherpf1dps/d Wx (66),(ev)</span>
<span class="p_del">-5: vscatterpf0dps/d Wx (66),(ev)</span>
<span class="p_del">-6: vscatterpf1dps/d Wx (66),(ev)</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: Grp19</span>
<span class="p_del">-1: vgatherpf0qps/d Wx (66),(ev)</span>
<span class="p_del">-2: vgatherpf1qps/d Wx (66),(ev)</span>
<span class="p_del">-5: vscatterpf0qps/d Wx (66),(ev)</span>
<span class="p_del">-6: vscatterpf1qps/d Wx (66),(ev)</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-# AMD&#39;s Prefetch Group</span>
<span class="p_del">-GrpTable: GrpP</span>
<span class="p_del">-0: PREFETCH</span>
<span class="p_del">-1: PREFETCHW</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: GrpPDLK</span>
<span class="p_del">-0: MONTMUL</span>
<span class="p_del">-1: XSHA1</span>
<span class="p_del">-2: XSHA2</span>
<span class="p_del">-EndTable</span>
<span class="p_del">-</span>
<span class="p_del">-GrpTable: GrpRNG</span>
<span class="p_del">-0: xstore-rng</span>
<span class="p_del">-1: xcrypt-ecb</span>
<span class="p_del">-2: xcrypt-cbc</span>
<span class="p_del">-4: xcrypt-cfb</span>
<span class="p_del">-5: xcrypt-ofb</span>
<span class="p_del">-EndTable</span>
<span class="p_header">diff --git a/tools/objtool/arch/x86/lib/inat.c b/tools/objtool/arch/x86/lib/inat.c</span>
new file mode 100644
<span class="p_header">index 000000000000..c1f01a8e9f65</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/objtool/arch/x86/lib/inat.c</span>
<span class="p_chunk">@@ -0,0 +1,97 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * x86 instruction attribute tables</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Written by Masami Hiramatsu &lt;mhiramat@redhat.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License as published by</span>
<span class="p_add">+ * the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_add">+ * (at your option) any later version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program; if not, write to the Free Software</span>
<span class="p_add">+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
<span class="p_add">+#include &lt;asm/insn.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/* Attribute tables are generated from opcode map */</span>
<span class="p_add">+#include &quot;inat-tables.c&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+/* Attribute search APIs */</span>
<span class="p_add">+insn_attr_t inat_get_opcode_attribute(insn_byte_t opcode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return inat_primary_table[opcode];</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int inat_get_last_prefix_id(insn_byte_t last_pfx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	insn_attr_t lpfx_attr;</span>
<span class="p_add">+</span>
<span class="p_add">+	lpfx_attr = inat_get_opcode_attribute(last_pfx);</span>
<span class="p_add">+	return inat_last_prefix_id(lpfx_attr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+insn_attr_t inat_get_escape_attribute(insn_byte_t opcode, int lpfx_id,</span>
<span class="p_add">+				      insn_attr_t esc_attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const insn_attr_t *table;</span>
<span class="p_add">+	int n;</span>
<span class="p_add">+</span>
<span class="p_add">+	n = inat_escape_id(esc_attr);</span>
<span class="p_add">+</span>
<span class="p_add">+	table = inat_escape_tables[n][0];</span>
<span class="p_add">+	if (!table)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	if (inat_has_variant(table[opcode]) &amp;&amp; lpfx_id) {</span>
<span class="p_add">+		table = inat_escape_tables[n][lpfx_id];</span>
<span class="p_add">+		if (!table)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return table[opcode];</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+insn_attr_t inat_get_group_attribute(insn_byte_t modrm, int lpfx_id,</span>
<span class="p_add">+				     insn_attr_t grp_attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const insn_attr_t *table;</span>
<span class="p_add">+	int n;</span>
<span class="p_add">+</span>
<span class="p_add">+	n = inat_group_id(grp_attr);</span>
<span class="p_add">+</span>
<span class="p_add">+	table = inat_group_tables[n][0];</span>
<span class="p_add">+	if (!table)</span>
<span class="p_add">+		return inat_group_common_attribute(grp_attr);</span>
<span class="p_add">+	if (inat_has_variant(table[X86_MODRM_REG(modrm)]) &amp;&amp; lpfx_id) {</span>
<span class="p_add">+		table = inat_group_tables[n][lpfx_id];</span>
<span class="p_add">+		if (!table)</span>
<span class="p_add">+			return inat_group_common_attribute(grp_attr);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return table[X86_MODRM_REG(modrm)] |</span>
<span class="p_add">+	       inat_group_common_attribute(grp_attr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+insn_attr_t inat_get_avx_attribute(insn_byte_t opcode, insn_byte_t vex_m,</span>
<span class="p_add">+				   insn_byte_t vex_p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const insn_attr_t *table;</span>
<span class="p_add">+	if (vex_m &gt; X86_VEX_M_MAX || vex_p &gt; INAT_LSTPFX_MAX)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	/* At first, this checks the master table */</span>
<span class="p_add">+	table = inat_avx_tables[vex_m][0];</span>
<span class="p_add">+	if (!table)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	if (!inat_is_group(table[opcode]) &amp;&amp; vex_p) {</span>
<span class="p_add">+		/* If this is not a group, get attribute directly */</span>
<span class="p_add">+		table = inat_avx_tables[vex_m][vex_p];</span>
<span class="p_add">+		if (!table)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return table[opcode];</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_header">diff --git a/tools/objtool/arch/x86/lib/insn.c b/tools/objtool/arch/x86/lib/insn.c</span>
new file mode 100644
<span class="p_header">index 000000000000..1088eb8f3a5f</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/objtool/arch/x86/lib/insn.c</span>
<span class="p_chunk">@@ -0,0 +1,606 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * x86 instruction analysis</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License as published by</span>
<span class="p_add">+ * the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_add">+ * (at your option) any later version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program; if not, write to the Free Software</span>
<span class="p_add">+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) IBM Corporation, 2002, 2004, 2009</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef __KERNEL__</span>
<span class="p_add">+#include &lt;linux/string.h&gt;</span>
<span class="p_add">+#else</span>
<span class="p_add">+#include &lt;string.h&gt;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#include &lt;asm/inat.h&gt;</span>
<span class="p_add">+#include &lt;asm/insn.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/* Verify next sizeof(t) bytes can be on the same instruction */</span>
<span class="p_add">+#define validate_next(t, insn, n)	\</span>
<span class="p_add">+	((insn)-&gt;next_byte + sizeof(t) + n &lt;= (insn)-&gt;end_kaddr)</span>
<span class="p_add">+</span>
<span class="p_add">+#define __get_next(t, insn)	\</span>
<span class="p_add">+	({ t r = *(t*)insn-&gt;next_byte; insn-&gt;next_byte += sizeof(t); r; })</span>
<span class="p_add">+</span>
<span class="p_add">+#define __peek_nbyte_next(t, insn, n)	\</span>
<span class="p_add">+	({ t r = *(t*)((insn)-&gt;next_byte + n); r; })</span>
<span class="p_add">+</span>
<span class="p_add">+#define get_next(t, insn)	\</span>
<span class="p_add">+	({ if (unlikely(!validate_next(t, insn, 0))) goto err_out; __get_next(t, insn); })</span>
<span class="p_add">+</span>
<span class="p_add">+#define peek_nbyte_next(t, insn, n)	\</span>
<span class="p_add">+	({ if (unlikely(!validate_next(t, insn, n))) goto err_out; __peek_nbyte_next(t, insn, n); })</span>
<span class="p_add">+</span>
<span class="p_add">+#define peek_next(t, insn)	peek_nbyte_next(t, insn, 0)</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * insn_init() - initialize struct insn</span>
<span class="p_add">+ * @insn:	&amp;struct insn to be initialized</span>
<span class="p_add">+ * @kaddr:	address (in kernel memory) of instruction (or copy thereof)</span>
<span class="p_add">+ * @x86_64:	!0 for 64-bit kernel or 64-bit app</span>
<span class="p_add">+ */</span>
<span class="p_add">+void insn_init(struct insn *insn, const void *kaddr, int buf_len, int x86_64)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Instructions longer than MAX_INSN_SIZE (15 bytes) are invalid</span>
<span class="p_add">+	 * even if the input buffer is long enough to hold them.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (buf_len &gt; MAX_INSN_SIZE)</span>
<span class="p_add">+		buf_len = MAX_INSN_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(insn, 0, sizeof(*insn));</span>
<span class="p_add">+	insn-&gt;kaddr = kaddr;</span>
<span class="p_add">+	insn-&gt;end_kaddr = kaddr + buf_len;</span>
<span class="p_add">+	insn-&gt;next_byte = kaddr;</span>
<span class="p_add">+	insn-&gt;x86_64 = x86_64 ? 1 : 0;</span>
<span class="p_add">+	insn-&gt;opnd_bytes = 4;</span>
<span class="p_add">+	if (x86_64)</span>
<span class="p_add">+		insn-&gt;addr_bytes = 8;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		insn-&gt;addr_bytes = 4;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * insn_get_prefixes - scan x86 instruction prefix bytes</span>
<span class="p_add">+ * @insn:	&amp;struct insn containing instruction</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Populates the @insn-&gt;prefixes bitmap, and updates @insn-&gt;next_byte</span>
<span class="p_add">+ * to point to the (first) opcode.  No effect if @insn-&gt;prefixes.got</span>
<span class="p_add">+ * is already set.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void insn_get_prefixes(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct insn_field *prefixes = &amp;insn-&gt;prefixes;</span>
<span class="p_add">+	insn_attr_t attr;</span>
<span class="p_add">+	insn_byte_t b, lb;</span>
<span class="p_add">+	int i, nb;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (prefixes-&gt;got)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	nb = 0;</span>
<span class="p_add">+	lb = 0;</span>
<span class="p_add">+	b = peek_next(insn_byte_t, insn);</span>
<span class="p_add">+	attr = inat_get_opcode_attribute(b);</span>
<span class="p_add">+	while (inat_is_legacy_prefix(attr)) {</span>
<span class="p_add">+		/* Skip if same prefix */</span>
<span class="p_add">+		for (i = 0; i &lt; nb; i++)</span>
<span class="p_add">+			if (prefixes-&gt;bytes[i] == b)</span>
<span class="p_add">+				goto found;</span>
<span class="p_add">+		if (nb == 4)</span>
<span class="p_add">+			/* Invalid instruction */</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		prefixes-&gt;bytes[nb++] = b;</span>
<span class="p_add">+		if (inat_is_address_size_prefix(attr)) {</span>
<span class="p_add">+			/* address size switches 2/4 or 4/8 */</span>
<span class="p_add">+			if (insn-&gt;x86_64)</span>
<span class="p_add">+				insn-&gt;addr_bytes ^= 12;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				insn-&gt;addr_bytes ^= 6;</span>
<span class="p_add">+		} else if (inat_is_operand_size_prefix(attr)) {</span>
<span class="p_add">+			/* oprand size switches 2/4 */</span>
<span class="p_add">+			insn-&gt;opnd_bytes ^= 6;</span>
<span class="p_add">+		}</span>
<span class="p_add">+found:</span>
<span class="p_add">+		prefixes-&gt;nbytes++;</span>
<span class="p_add">+		insn-&gt;next_byte++;</span>
<span class="p_add">+		lb = b;</span>
<span class="p_add">+		b = peek_next(insn_byte_t, insn);</span>
<span class="p_add">+		attr = inat_get_opcode_attribute(b);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* Set the last prefix */</span>
<span class="p_add">+	if (lb &amp;&amp; lb != insn-&gt;prefixes.bytes[3]) {</span>
<span class="p_add">+		if (unlikely(insn-&gt;prefixes.bytes[3])) {</span>
<span class="p_add">+			/* Swap the last prefix */</span>
<span class="p_add">+			b = insn-&gt;prefixes.bytes[3];</span>
<span class="p_add">+			for (i = 0; i &lt; nb; i++)</span>
<span class="p_add">+				if (prefixes-&gt;bytes[i] == lb)</span>
<span class="p_add">+					prefixes-&gt;bytes[i] = b;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		insn-&gt;prefixes.bytes[3] = lb;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Decode REX prefix */</span>
<span class="p_add">+	if (insn-&gt;x86_64) {</span>
<span class="p_add">+		b = peek_next(insn_byte_t, insn);</span>
<span class="p_add">+		attr = inat_get_opcode_attribute(b);</span>
<span class="p_add">+		if (inat_is_rex_prefix(attr)) {</span>
<span class="p_add">+			insn-&gt;rex_prefix.value = b;</span>
<span class="p_add">+			insn-&gt;rex_prefix.nbytes = 1;</span>
<span class="p_add">+			insn-&gt;next_byte++;</span>
<span class="p_add">+			if (X86_REX_W(b))</span>
<span class="p_add">+				/* REX.W overrides opnd_size */</span>
<span class="p_add">+				insn-&gt;opnd_bytes = 8;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	insn-&gt;rex_prefix.got = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Decode VEX prefix */</span>
<span class="p_add">+	b = peek_next(insn_byte_t, insn);</span>
<span class="p_add">+	attr = inat_get_opcode_attribute(b);</span>
<span class="p_add">+	if (inat_is_vex_prefix(attr)) {</span>
<span class="p_add">+		insn_byte_t b2 = peek_nbyte_next(insn_byte_t, insn, 1);</span>
<span class="p_add">+		if (!insn-&gt;x86_64) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * In 32-bits mode, if the [7:6] bits (mod bits of</span>
<span class="p_add">+			 * ModRM) on the second byte are not 11b, it is</span>
<span class="p_add">+			 * LDS or LES or BOUND.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (X86_MODRM_MOD(b2) != 3)</span>
<span class="p_add">+				goto vex_end;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		insn-&gt;vex_prefix.bytes[0] = b;</span>
<span class="p_add">+		insn-&gt;vex_prefix.bytes[1] = b2;</span>
<span class="p_add">+		if (inat_is_evex_prefix(attr)) {</span>
<span class="p_add">+			b2 = peek_nbyte_next(insn_byte_t, insn, 2);</span>
<span class="p_add">+			insn-&gt;vex_prefix.bytes[2] = b2;</span>
<span class="p_add">+			b2 = peek_nbyte_next(insn_byte_t, insn, 3);</span>
<span class="p_add">+			insn-&gt;vex_prefix.bytes[3] = b2;</span>
<span class="p_add">+			insn-&gt;vex_prefix.nbytes = 4;</span>
<span class="p_add">+			insn-&gt;next_byte += 4;</span>
<span class="p_add">+			if (insn-&gt;x86_64 &amp;&amp; X86_VEX_W(b2))</span>
<span class="p_add">+				/* VEX.W overrides opnd_size */</span>
<span class="p_add">+				insn-&gt;opnd_bytes = 8;</span>
<span class="p_add">+		} else if (inat_is_vex3_prefix(attr)) {</span>
<span class="p_add">+			b2 = peek_nbyte_next(insn_byte_t, insn, 2);</span>
<span class="p_add">+			insn-&gt;vex_prefix.bytes[2] = b2;</span>
<span class="p_add">+			insn-&gt;vex_prefix.nbytes = 3;</span>
<span class="p_add">+			insn-&gt;next_byte += 3;</span>
<span class="p_add">+			if (insn-&gt;x86_64 &amp;&amp; X86_VEX_W(b2))</span>
<span class="p_add">+				/* VEX.W overrides opnd_size */</span>
<span class="p_add">+				insn-&gt;opnd_bytes = 8;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * For VEX2, fake VEX3-like byte#2.</span>
<span class="p_add">+			 * Makes it easier to decode vex.W, vex.vvvv,</span>
<span class="p_add">+			 * vex.L and vex.pp. Masking with 0x7f sets vex.W == 0.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			insn-&gt;vex_prefix.bytes[2] = b2 &amp; 0x7f;</span>
<span class="p_add">+			insn-&gt;vex_prefix.nbytes = 2;</span>
<span class="p_add">+			insn-&gt;next_byte += 2;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+vex_end:</span>
<span class="p_add">+	insn-&gt;vex_prefix.got = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	prefixes-&gt;got = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+err_out:</span>
<span class="p_add">+	return;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * insn_get_opcode - collect opcode(s)</span>
<span class="p_add">+ * @insn:	&amp;struct insn containing instruction</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Populates @insn-&gt;opcode, updates @insn-&gt;next_byte to point past the</span>
<span class="p_add">+ * opcode byte(s), and set @insn-&gt;attr (except for groups).</span>
<span class="p_add">+ * If necessary, first collects any preceding (prefix) bytes.</span>
<span class="p_add">+ * Sets @insn-&gt;opcode.value = opcode1.  No effect if @insn-&gt;opcode.got</span>
<span class="p_add">+ * is already 1.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void insn_get_opcode(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct insn_field *opcode = &amp;insn-&gt;opcode;</span>
<span class="p_add">+	insn_byte_t op;</span>
<span class="p_add">+	int pfx_id;</span>
<span class="p_add">+	if (opcode-&gt;got)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	if (!insn-&gt;prefixes.got)</span>
<span class="p_add">+		insn_get_prefixes(insn);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Get first opcode */</span>
<span class="p_add">+	op = get_next(insn_byte_t, insn);</span>
<span class="p_add">+	opcode-&gt;bytes[0] = op;</span>
<span class="p_add">+	opcode-&gt;nbytes = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check if there is VEX prefix or not */</span>
<span class="p_add">+	if (insn_is_avx(insn)) {</span>
<span class="p_add">+		insn_byte_t m, p;</span>
<span class="p_add">+		m = insn_vex_m_bits(insn);</span>
<span class="p_add">+		p = insn_vex_p_bits(insn);</span>
<span class="p_add">+		insn-&gt;attr = inat_get_avx_attribute(op, m, p);</span>
<span class="p_add">+		if ((inat_must_evex(insn-&gt;attr) &amp;&amp; !insn_is_evex(insn)) ||</span>
<span class="p_add">+		    (!inat_accept_vex(insn-&gt;attr) &amp;&amp;</span>
<span class="p_add">+		     !inat_is_group(insn-&gt;attr)))</span>
<span class="p_add">+			insn-&gt;attr = 0;	/* This instruction is bad */</span>
<span class="p_add">+		goto end;	/* VEX has only 1 byte for opcode */</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	insn-&gt;attr = inat_get_opcode_attribute(op);</span>
<span class="p_add">+	while (inat_is_escape(insn-&gt;attr)) {</span>
<span class="p_add">+		/* Get escaped opcode */</span>
<span class="p_add">+		op = get_next(insn_byte_t, insn);</span>
<span class="p_add">+		opcode-&gt;bytes[opcode-&gt;nbytes++] = op;</span>
<span class="p_add">+		pfx_id = insn_last_prefix_id(insn);</span>
<span class="p_add">+		insn-&gt;attr = inat_get_escape_attribute(op, pfx_id, insn-&gt;attr);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (inat_must_vex(insn-&gt;attr))</span>
<span class="p_add">+		insn-&gt;attr = 0;	/* This instruction is bad */</span>
<span class="p_add">+end:</span>
<span class="p_add">+	opcode-&gt;got = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+err_out:</span>
<span class="p_add">+	return;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * insn_get_modrm - collect ModRM byte, if any</span>
<span class="p_add">+ * @insn:	&amp;struct insn containing instruction</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Populates @insn-&gt;modrm and updates @insn-&gt;next_byte to point past the</span>
<span class="p_add">+ * ModRM byte, if any.  If necessary, first collects the preceding bytes</span>
<span class="p_add">+ * (prefixes and opcode(s)).  No effect if @insn-&gt;modrm.got is already 1.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void insn_get_modrm(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct insn_field *modrm = &amp;insn-&gt;modrm;</span>
<span class="p_add">+	insn_byte_t pfx_id, mod;</span>
<span class="p_add">+	if (modrm-&gt;got)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	if (!insn-&gt;opcode.got)</span>
<span class="p_add">+		insn_get_opcode(insn);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (inat_has_modrm(insn-&gt;attr)) {</span>
<span class="p_add">+		mod = get_next(insn_byte_t, insn);</span>
<span class="p_add">+		modrm-&gt;value = mod;</span>
<span class="p_add">+		modrm-&gt;nbytes = 1;</span>
<span class="p_add">+		if (inat_is_group(insn-&gt;attr)) {</span>
<span class="p_add">+			pfx_id = insn_last_prefix_id(insn);</span>
<span class="p_add">+			insn-&gt;attr = inat_get_group_attribute(mod, pfx_id,</span>
<span class="p_add">+							      insn-&gt;attr);</span>
<span class="p_add">+			if (insn_is_avx(insn) &amp;&amp; !inat_accept_vex(insn-&gt;attr))</span>
<span class="p_add">+				insn-&gt;attr = 0;	/* This is bad */</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (insn-&gt;x86_64 &amp;&amp; inat_is_force64(insn-&gt;attr))</span>
<span class="p_add">+		insn-&gt;opnd_bytes = 8;</span>
<span class="p_add">+	modrm-&gt;got = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+err_out:</span>
<span class="p_add">+	return;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * insn_rip_relative() - Does instruction use RIP-relative addressing mode?</span>
<span class="p_add">+ * @insn:	&amp;struct insn containing instruction</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * If necessary, first collects the instruction up to and including the</span>
<span class="p_add">+ * ModRM byte.  No effect if @insn-&gt;x86_64 is 0.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int insn_rip_relative(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct insn_field *modrm = &amp;insn-&gt;modrm;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!insn-&gt;x86_64)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	if (!modrm-&gt;got)</span>
<span class="p_add">+		insn_get_modrm(insn);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * For rip-relative instructions, the mod field (top 2 bits)</span>
<span class="p_add">+	 * is zero and the r/m field (bottom 3 bits) is 0x5.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return (modrm-&gt;nbytes &amp;&amp; (modrm-&gt;value &amp; 0xc7) == 0x5);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * insn_get_sib() - Get the SIB byte of instruction</span>
<span class="p_add">+ * @insn:	&amp;struct insn containing instruction</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * If necessary, first collects the instruction up to and including the</span>
<span class="p_add">+ * ModRM byte.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void insn_get_sib(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	insn_byte_t modrm;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (insn-&gt;sib.got)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	if (!insn-&gt;modrm.got)</span>
<span class="p_add">+		insn_get_modrm(insn);</span>
<span class="p_add">+	if (insn-&gt;modrm.nbytes) {</span>
<span class="p_add">+		modrm = (insn_byte_t)insn-&gt;modrm.value;</span>
<span class="p_add">+		if (insn-&gt;addr_bytes != 2 &amp;&amp;</span>
<span class="p_add">+		    X86_MODRM_MOD(modrm) != 3 &amp;&amp; X86_MODRM_RM(modrm) == 4) {</span>
<span class="p_add">+			insn-&gt;sib.value = get_next(insn_byte_t, insn);</span>
<span class="p_add">+			insn-&gt;sib.nbytes = 1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	insn-&gt;sib.got = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+err_out:</span>
<span class="p_add">+	return;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * insn_get_displacement() - Get the displacement of instruction</span>
<span class="p_add">+ * @insn:	&amp;struct insn containing instruction</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * If necessary, first collects the instruction up to and including the</span>
<span class="p_add">+ * SIB byte.</span>
<span class="p_add">+ * Displacement value is sign-expanded.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void insn_get_displacement(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	insn_byte_t mod, rm, base;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (insn-&gt;displacement.got)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	if (!insn-&gt;sib.got)</span>
<span class="p_add">+		insn_get_sib(insn);</span>
<span class="p_add">+	if (insn-&gt;modrm.nbytes) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Interpreting the modrm byte:</span>
<span class="p_add">+		 * mod = 00 - no displacement fields (exceptions below)</span>
<span class="p_add">+		 * mod = 01 - 1-byte displacement field</span>
<span class="p_add">+		 * mod = 10 - displacement field is 4 bytes, or 2 bytes if</span>
<span class="p_add">+		 * 	address size = 2 (0x67 prefix in 32-bit mode)</span>
<span class="p_add">+		 * mod = 11 - no memory operand</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * If address size = 2...</span>
<span class="p_add">+		 * mod = 00, r/m = 110 - displacement field is 2 bytes</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * If address size != 2...</span>
<span class="p_add">+		 * mod != 11, r/m = 100 - SIB byte exists</span>
<span class="p_add">+		 * mod = 00, SIB base = 101 - displacement field is 4 bytes</span>
<span class="p_add">+		 * mod = 00, r/m = 101 - rip-relative addressing, displacement</span>
<span class="p_add">+		 * 	field is 4 bytes</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		mod = X86_MODRM_MOD(insn-&gt;modrm.value);</span>
<span class="p_add">+		rm = X86_MODRM_RM(insn-&gt;modrm.value);</span>
<span class="p_add">+		base = X86_SIB_BASE(insn-&gt;sib.value);</span>
<span class="p_add">+		if (mod == 3)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		if (mod == 1) {</span>
<span class="p_add">+			insn-&gt;displacement.value = get_next(signed char, insn);</span>
<span class="p_add">+			insn-&gt;displacement.nbytes = 1;</span>
<span class="p_add">+		} else if (insn-&gt;addr_bytes == 2) {</span>
<span class="p_add">+			if ((mod == 0 &amp;&amp; rm == 6) || mod == 2) {</span>
<span class="p_add">+				insn-&gt;displacement.value =</span>
<span class="p_add">+					 get_next(short, insn);</span>
<span class="p_add">+				insn-&gt;displacement.nbytes = 2;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if ((mod == 0 &amp;&amp; rm == 5) || mod == 2 ||</span>
<span class="p_add">+			    (mod == 0 &amp;&amp; base == 5)) {</span>
<span class="p_add">+				insn-&gt;displacement.value = get_next(int, insn);</span>
<span class="p_add">+				insn-&gt;displacement.nbytes = 4;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+out:</span>
<span class="p_add">+	insn-&gt;displacement.got = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+err_out:</span>
<span class="p_add">+	return;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Decode moffset16/32/64. Return 0 if failed */</span>
<span class="p_add">+static int __get_moffset(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (insn-&gt;addr_bytes) {</span>
<span class="p_add">+	case 2:</span>
<span class="p_add">+		insn-&gt;moffset1.value = get_next(short, insn);</span>
<span class="p_add">+		insn-&gt;moffset1.nbytes = 2;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 4:</span>
<span class="p_add">+		insn-&gt;moffset1.value = get_next(int, insn);</span>
<span class="p_add">+		insn-&gt;moffset1.nbytes = 4;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 8:</span>
<span class="p_add">+		insn-&gt;moffset1.value = get_next(int, insn);</span>
<span class="p_add">+		insn-&gt;moffset1.nbytes = 4;</span>
<span class="p_add">+		insn-&gt;moffset2.value = get_next(int, insn);</span>
<span class="p_add">+		insn-&gt;moffset2.nbytes = 4;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:	/* opnd_bytes must be modified manually */</span>
<span class="p_add">+		goto err_out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	insn-&gt;moffset1.got = insn-&gt;moffset2.got = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+</span>
<span class="p_add">+err_out:</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Decode imm v32(Iz). Return 0 if failed */</span>
<span class="p_add">+static int __get_immv32(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (insn-&gt;opnd_bytes) {</span>
<span class="p_add">+	case 2:</span>
<span class="p_add">+		insn-&gt;immediate.value = get_next(short, insn);</span>
<span class="p_add">+		insn-&gt;immediate.nbytes = 2;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 4:</span>
<span class="p_add">+	case 8:</span>
<span class="p_add">+		insn-&gt;immediate.value = get_next(int, insn);</span>
<span class="p_add">+		insn-&gt;immediate.nbytes = 4;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:	/* opnd_bytes must be modified manually */</span>
<span class="p_add">+		goto err_out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+</span>
<span class="p_add">+err_out:</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Decode imm v64(Iv/Ov), Return 0 if failed */</span>
<span class="p_add">+static int __get_immv(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (insn-&gt;opnd_bytes) {</span>
<span class="p_add">+	case 2:</span>
<span class="p_add">+		insn-&gt;immediate1.value = get_next(short, insn);</span>
<span class="p_add">+		insn-&gt;immediate1.nbytes = 2;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 4:</span>
<span class="p_add">+		insn-&gt;immediate1.value = get_next(int, insn);</span>
<span class="p_add">+		insn-&gt;immediate1.nbytes = 4;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 8:</span>
<span class="p_add">+		insn-&gt;immediate1.value = get_next(int, insn);</span>
<span class="p_add">+		insn-&gt;immediate1.nbytes = 4;</span>
<span class="p_add">+		insn-&gt;immediate2.value = get_next(int, insn);</span>
<span class="p_add">+		insn-&gt;immediate2.nbytes = 4;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:	/* opnd_bytes must be modified manually */</span>
<span class="p_add">+		goto err_out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	insn-&gt;immediate1.got = insn-&gt;immediate2.got = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+err_out:</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Decode ptr16:16/32(Ap) */</span>
<span class="p_add">+static int __get_immptr(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (insn-&gt;opnd_bytes) {</span>
<span class="p_add">+	case 2:</span>
<span class="p_add">+		insn-&gt;immediate1.value = get_next(short, insn);</span>
<span class="p_add">+		insn-&gt;immediate1.nbytes = 2;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 4:</span>
<span class="p_add">+		insn-&gt;immediate1.value = get_next(int, insn);</span>
<span class="p_add">+		insn-&gt;immediate1.nbytes = 4;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 8:</span>
<span class="p_add">+		/* ptr16:64 is not exist (no segment) */</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	default:	/* opnd_bytes must be modified manually */</span>
<span class="p_add">+		goto err_out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	insn-&gt;immediate2.value = get_next(unsigned short, insn);</span>
<span class="p_add">+	insn-&gt;immediate2.nbytes = 2;</span>
<span class="p_add">+	insn-&gt;immediate1.got = insn-&gt;immediate2.got = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+err_out:</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * insn_get_immediate() - Get the immediates of instruction</span>
<span class="p_add">+ * @insn:	&amp;struct insn containing instruction</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * If necessary, first collects the instruction up to and including the</span>
<span class="p_add">+ * displacement bytes.</span>
<span class="p_add">+ * Basically, most of immediates are sign-expanded. Unsigned-value can be</span>
<span class="p_add">+ * get by bit masking with ((1 &lt;&lt; (nbytes * 8)) - 1)</span>
<span class="p_add">+ */</span>
<span class="p_add">+void insn_get_immediate(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (insn-&gt;immediate.got)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	if (!insn-&gt;displacement.got)</span>
<span class="p_add">+		insn_get_displacement(insn);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (inat_has_moffset(insn-&gt;attr)) {</span>
<span class="p_add">+		if (!__get_moffset(insn))</span>
<span class="p_add">+			goto err_out;</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!inat_has_immediate(insn-&gt;attr))</span>
<span class="p_add">+		/* no immediates */</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (inat_immediate_size(insn-&gt;attr)) {</span>
<span class="p_add">+	case INAT_IMM_BYTE:</span>
<span class="p_add">+		insn-&gt;immediate.value = get_next(signed char, insn);</span>
<span class="p_add">+		insn-&gt;immediate.nbytes = 1;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case INAT_IMM_WORD:</span>
<span class="p_add">+		insn-&gt;immediate.value = get_next(short, insn);</span>
<span class="p_add">+		insn-&gt;immediate.nbytes = 2;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case INAT_IMM_DWORD:</span>
<span class="p_add">+		insn-&gt;immediate.value = get_next(int, insn);</span>
<span class="p_add">+		insn-&gt;immediate.nbytes = 4;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case INAT_IMM_QWORD:</span>
<span class="p_add">+		insn-&gt;immediate1.value = get_next(int, insn);</span>
<span class="p_add">+		insn-&gt;immediate1.nbytes = 4;</span>
<span class="p_add">+		insn-&gt;immediate2.value = get_next(int, insn);</span>
<span class="p_add">+		insn-&gt;immediate2.nbytes = 4;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case INAT_IMM_PTR:</span>
<span class="p_add">+		if (!__get_immptr(insn))</span>
<span class="p_add">+			goto err_out;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case INAT_IMM_VWORD32:</span>
<span class="p_add">+		if (!__get_immv32(insn))</span>
<span class="p_add">+			goto err_out;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case INAT_IMM_VWORD:</span>
<span class="p_add">+		if (!__get_immv(insn))</span>
<span class="p_add">+			goto err_out;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		/* Here, insn must have an immediate, but failed */</span>
<span class="p_add">+		goto err_out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (inat_has_second_immediate(insn-&gt;attr)) {</span>
<span class="p_add">+		insn-&gt;immediate2.value = get_next(signed char, insn);</span>
<span class="p_add">+		insn-&gt;immediate2.nbytes = 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+done:</span>
<span class="p_add">+	insn-&gt;immediate.got = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+err_out:</span>
<span class="p_add">+	return;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * insn_get_length() - Get the length of instruction</span>
<span class="p_add">+ * @insn:	&amp;struct insn containing instruction</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * If necessary, first collects the instruction up to and including the</span>
<span class="p_add">+ * immediates bytes.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void insn_get_length(struct insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (insn-&gt;length)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	if (!insn-&gt;immediate.got)</span>
<span class="p_add">+		insn_get_immediate(insn);</span>
<span class="p_add">+	insn-&gt;length = (unsigned char)((unsigned long)insn-&gt;next_byte</span>
<span class="p_add">+				     - (unsigned long)insn-&gt;kaddr);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/tools/objtool/arch/x86/lib/x86-opcode-map.txt b/tools/objtool/arch/x86/lib/x86-opcode-map.txt</span>
new file mode 100644
<span class="p_header">index 000000000000..e0b85930dd77</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/objtool/arch/x86/lib/x86-opcode-map.txt</span>
<span class="p_chunk">@@ -0,0 +1,1072 @@</span> <span class="p_context"></span>
<span class="p_add">+# x86 Opcode Maps</span>
<span class="p_add">+#</span>
<span class="p_add">+# This is (mostly) based on following documentations.</span>
<span class="p_add">+# - Intel(R) 64 and IA-32 Architectures Software Developer&#39;s Manual Vol.2C</span>
<span class="p_add">+#   (#326018-047US, June 2013)</span>
<span class="p_add">+#</span>
<span class="p_add">+#&lt;Opcode maps&gt;</span>
<span class="p_add">+# Table: table-name</span>
<span class="p_add">+# Referrer: escaped-name</span>
<span class="p_add">+# AVXcode: avx-code</span>
<span class="p_add">+# opcode: mnemonic|GrpXXX [operand1[,operand2...]] [(extra1)[,(extra2)...] [| 2nd-mnemonic ...]</span>
<span class="p_add">+# (or)</span>
<span class="p_add">+# opcode: escape # escaped-name</span>
<span class="p_add">+# EndTable</span>
<span class="p_add">+#</span>
<span class="p_add">+# mnemonics that begin with lowercase &#39;v&#39; accept a VEX or EVEX prefix</span>
<span class="p_add">+# mnemonics that begin with lowercase &#39;k&#39; accept a VEX prefix</span>
<span class="p_add">+#</span>
<span class="p_add">+#&lt;group maps&gt;</span>
<span class="p_add">+# GrpTable: GrpXXX</span>
<span class="p_add">+# reg:  mnemonic [operand1[,operand2...]] [(extra1)[,(extra2)...] [| 2nd-mnemonic ...]</span>
<span class="p_add">+# EndTable</span>
<span class="p_add">+#</span>
<span class="p_add">+# AVX Superscripts</span>
<span class="p_add">+#  (ev): this opcode requires EVEX prefix.</span>
<span class="p_add">+#  (evo): this opcode is changed by EVEX prefix (EVEX opcode)</span>
<span class="p_add">+#  (v): this opcode requires VEX prefix.</span>
<span class="p_add">+#  (v1): this opcode only supports 128bit VEX.</span>
<span class="p_add">+#</span>
<span class="p_add">+# Last Prefix Superscripts</span>
<span class="p_add">+#  - (66): the last prefix is 0x66</span>
<span class="p_add">+#  - (F3): the last prefix is 0xF3</span>
<span class="p_add">+#  - (F2): the last prefix is 0xF2</span>
<span class="p_add">+#  - (!F3) : the last prefix is not 0xF3 (including non-last prefix case)</span>
<span class="p_add">+#  - (66&amp;F2): Both 0x66 and 0xF2 prefixes are specified.</span>
<span class="p_add">+</span>
<span class="p_add">+Table: one byte opcode</span>
<span class="p_add">+Referrer:</span>
<span class="p_add">+AVXcode:</span>
<span class="p_add">+# 0x00 - 0x0f</span>
<span class="p_add">+00: ADD Eb,Gb</span>
<span class="p_add">+01: ADD Ev,Gv</span>
<span class="p_add">+02: ADD Gb,Eb</span>
<span class="p_add">+03: ADD Gv,Ev</span>
<span class="p_add">+04: ADD AL,Ib</span>
<span class="p_add">+05: ADD rAX,Iz</span>
<span class="p_add">+06: PUSH ES (i64)</span>
<span class="p_add">+07: POP ES (i64)</span>
<span class="p_add">+08: OR Eb,Gb</span>
<span class="p_add">+09: OR Ev,Gv</span>
<span class="p_add">+0a: OR Gb,Eb</span>
<span class="p_add">+0b: OR Gv,Ev</span>
<span class="p_add">+0c: OR AL,Ib</span>
<span class="p_add">+0d: OR rAX,Iz</span>
<span class="p_add">+0e: PUSH CS (i64)</span>
<span class="p_add">+0f: escape # 2-byte escape</span>
<span class="p_add">+# 0x10 - 0x1f</span>
<span class="p_add">+10: ADC Eb,Gb</span>
<span class="p_add">+11: ADC Ev,Gv</span>
<span class="p_add">+12: ADC Gb,Eb</span>
<span class="p_add">+13: ADC Gv,Ev</span>
<span class="p_add">+14: ADC AL,Ib</span>
<span class="p_add">+15: ADC rAX,Iz</span>
<span class="p_add">+16: PUSH SS (i64)</span>
<span class="p_add">+17: POP SS (i64)</span>
<span class="p_add">+18: SBB Eb,Gb</span>
<span class="p_add">+19: SBB Ev,Gv</span>
<span class="p_add">+1a: SBB Gb,Eb</span>
<span class="p_add">+1b: SBB Gv,Ev</span>
<span class="p_add">+1c: SBB AL,Ib</span>
<span class="p_add">+1d: SBB rAX,Iz</span>
<span class="p_add">+1e: PUSH DS (i64)</span>
<span class="p_add">+1f: POP DS (i64)</span>
<span class="p_add">+# 0x20 - 0x2f</span>
<span class="p_add">+20: AND Eb,Gb</span>
<span class="p_add">+21: AND Ev,Gv</span>
<span class="p_add">+22: AND Gb,Eb</span>
<span class="p_add">+23: AND Gv,Ev</span>
<span class="p_add">+24: AND AL,Ib</span>
<span class="p_add">+25: AND rAx,Iz</span>
<span class="p_add">+26: SEG=ES (Prefix)</span>
<span class="p_add">+27: DAA (i64)</span>
<span class="p_add">+28: SUB Eb,Gb</span>
<span class="p_add">+29: SUB Ev,Gv</span>
<span class="p_add">+2a: SUB Gb,Eb</span>
<span class="p_add">+2b: SUB Gv,Ev</span>
<span class="p_add">+2c: SUB AL,Ib</span>
<span class="p_add">+2d: SUB rAX,Iz</span>
<span class="p_add">+2e: SEG=CS (Prefix)</span>
<span class="p_add">+2f: DAS (i64)</span>
<span class="p_add">+# 0x30 - 0x3f</span>
<span class="p_add">+30: XOR Eb,Gb</span>
<span class="p_add">+31: XOR Ev,Gv</span>
<span class="p_add">+32: XOR Gb,Eb</span>
<span class="p_add">+33: XOR Gv,Ev</span>
<span class="p_add">+34: XOR AL,Ib</span>
<span class="p_add">+35: XOR rAX,Iz</span>
<span class="p_add">+36: SEG=SS (Prefix)</span>
<span class="p_add">+37: AAA (i64)</span>
<span class="p_add">+38: CMP Eb,Gb</span>
<span class="p_add">+39: CMP Ev,Gv</span>
<span class="p_add">+3a: CMP Gb,Eb</span>
<span class="p_add">+3b: CMP Gv,Ev</span>
<span class="p_add">+3c: CMP AL,Ib</span>
<span class="p_add">+3d: CMP rAX,Iz</span>
<span class="p_add">+3e: SEG=DS (Prefix)</span>
<span class="p_add">+3f: AAS (i64)</span>
<span class="p_add">+# 0x40 - 0x4f</span>
<span class="p_add">+40: INC eAX (i64) | REX (o64)</span>
<span class="p_add">+41: INC eCX (i64) | REX.B (o64)</span>
<span class="p_add">+42: INC eDX (i64) | REX.X (o64)</span>
<span class="p_add">+43: INC eBX (i64) | REX.XB (o64)</span>
<span class="p_add">+44: INC eSP (i64) | REX.R (o64)</span>
<span class="p_add">+45: INC eBP (i64) | REX.RB (o64)</span>
<span class="p_add">+46: INC eSI (i64) | REX.RX (o64)</span>
<span class="p_add">+47: INC eDI (i64) | REX.RXB (o64)</span>
<span class="p_add">+48: DEC eAX (i64) | REX.W (o64)</span>
<span class="p_add">+49: DEC eCX (i64) | REX.WB (o64)</span>
<span class="p_add">+4a: DEC eDX (i64) | REX.WX (o64)</span>
<span class="p_add">+4b: DEC eBX (i64) | REX.WXB (o64)</span>
<span class="p_add">+4c: DEC eSP (i64) | REX.WR (o64)</span>
<span class="p_add">+4d: DEC eBP (i64) | REX.WRB (o64)</span>
<span class="p_add">+4e: DEC eSI (i64) | REX.WRX (o64)</span>
<span class="p_add">+4f: DEC eDI (i64) | REX.WRXB (o64)</span>
<span class="p_add">+# 0x50 - 0x5f</span>
<span class="p_add">+50: PUSH rAX/r8 (d64)</span>
<span class="p_add">+51: PUSH rCX/r9 (d64)</span>
<span class="p_add">+52: PUSH rDX/r10 (d64)</span>
<span class="p_add">+53: PUSH rBX/r11 (d64)</span>
<span class="p_add">+54: PUSH rSP/r12 (d64)</span>
<span class="p_add">+55: PUSH rBP/r13 (d64)</span>
<span class="p_add">+56: PUSH rSI/r14 (d64)</span>
<span class="p_add">+57: PUSH rDI/r15 (d64)</span>
<span class="p_add">+58: POP rAX/r8 (d64)</span>
<span class="p_add">+59: POP rCX/r9 (d64)</span>
<span class="p_add">+5a: POP rDX/r10 (d64)</span>
<span class="p_add">+5b: POP rBX/r11 (d64)</span>
<span class="p_add">+5c: POP rSP/r12 (d64)</span>
<span class="p_add">+5d: POP rBP/r13 (d64)</span>
<span class="p_add">+5e: POP rSI/r14 (d64)</span>
<span class="p_add">+5f: POP rDI/r15 (d64)</span>
<span class="p_add">+# 0x60 - 0x6f</span>
<span class="p_add">+60: PUSHA/PUSHAD (i64)</span>
<span class="p_add">+61: POPA/POPAD (i64)</span>
<span class="p_add">+62: BOUND Gv,Ma (i64) | EVEX (Prefix)</span>
<span class="p_add">+63: ARPL Ew,Gw (i64) | MOVSXD Gv,Ev (o64)</span>
<span class="p_add">+64: SEG=FS (Prefix)</span>
<span class="p_add">+65: SEG=GS (Prefix)</span>
<span class="p_add">+66: Operand-Size (Prefix)</span>
<span class="p_add">+67: Address-Size (Prefix)</span>
<span class="p_add">+68: PUSH Iz (d64)</span>
<span class="p_add">+69: IMUL Gv,Ev,Iz</span>
<span class="p_add">+6a: PUSH Ib (d64)</span>
<span class="p_add">+6b: IMUL Gv,Ev,Ib</span>
<span class="p_add">+6c: INS/INSB Yb,DX</span>
<span class="p_add">+6d: INS/INSW/INSD Yz,DX</span>
<span class="p_add">+6e: OUTS/OUTSB DX,Xb</span>
<span class="p_add">+6f: OUTS/OUTSW/OUTSD DX,Xz</span>
<span class="p_add">+# 0x70 - 0x7f</span>
<span class="p_add">+70: JO Jb</span>
<span class="p_add">+71: JNO Jb</span>
<span class="p_add">+72: JB/JNAE/JC Jb</span>
<span class="p_add">+73: JNB/JAE/JNC Jb</span>
<span class="p_add">+74: JZ/JE Jb</span>
<span class="p_add">+75: JNZ/JNE Jb</span>
<span class="p_add">+76: JBE/JNA Jb</span>
<span class="p_add">+77: JNBE/JA Jb</span>
<span class="p_add">+78: JS Jb</span>
<span class="p_add">+79: JNS Jb</span>
<span class="p_add">+7a: JP/JPE Jb</span>
<span class="p_add">+7b: JNP/JPO Jb</span>
<span class="p_add">+7c: JL/JNGE Jb</span>
<span class="p_add">+7d: JNL/JGE Jb</span>
<span class="p_add">+7e: JLE/JNG Jb</span>
<span class="p_add">+7f: JNLE/JG Jb</span>
<span class="p_add">+# 0x80 - 0x8f</span>
<span class="p_add">+80: Grp1 Eb,Ib (1A)</span>
<span class="p_add">+81: Grp1 Ev,Iz (1A)</span>
<span class="p_add">+82: Grp1 Eb,Ib (1A),(i64)</span>
<span class="p_add">+83: Grp1 Ev,Ib (1A)</span>
<span class="p_add">+84: TEST Eb,Gb</span>
<span class="p_add">+85: TEST Ev,Gv</span>
<span class="p_add">+86: XCHG Eb,Gb</span>
<span class="p_add">+87: XCHG Ev,Gv</span>
<span class="p_add">+88: MOV Eb,Gb</span>
<span class="p_add">+89: MOV Ev,Gv</span>
<span class="p_add">+8a: MOV Gb,Eb</span>
<span class="p_add">+8b: MOV Gv,Ev</span>
<span class="p_add">+8c: MOV Ev,Sw</span>
<span class="p_add">+8d: LEA Gv,M</span>
<span class="p_add">+8e: MOV Sw,Ew</span>
<span class="p_add">+8f: Grp1A (1A) | POP Ev (d64)</span>
<span class="p_add">+# 0x90 - 0x9f</span>
<span class="p_add">+90: NOP | PAUSE (F3) | XCHG r8,rAX</span>
<span class="p_add">+91: XCHG rCX/r9,rAX</span>
<span class="p_add">+92: XCHG rDX/r10,rAX</span>
<span class="p_add">+93: XCHG rBX/r11,rAX</span>
<span class="p_add">+94: XCHG rSP/r12,rAX</span>
<span class="p_add">+95: XCHG rBP/r13,rAX</span>
<span class="p_add">+96: XCHG rSI/r14,rAX</span>
<span class="p_add">+97: XCHG rDI/r15,rAX</span>
<span class="p_add">+98: CBW/CWDE/CDQE</span>
<span class="p_add">+99: CWD/CDQ/CQO</span>
<span class="p_add">+9a: CALLF Ap (i64)</span>
<span class="p_add">+9b: FWAIT/WAIT</span>
<span class="p_add">+9c: PUSHF/D/Q Fv (d64)</span>
<span class="p_add">+9d: POPF/D/Q Fv (d64)</span>
<span class="p_add">+9e: SAHF</span>
<span class="p_add">+9f: LAHF</span>
<span class="p_add">+# 0xa0 - 0xaf</span>
<span class="p_add">+a0: MOV AL,Ob</span>
<span class="p_add">+a1: MOV rAX,Ov</span>
<span class="p_add">+a2: MOV Ob,AL</span>
<span class="p_add">+a3: MOV Ov,rAX</span>
<span class="p_add">+a4: MOVS/B Yb,Xb</span>
<span class="p_add">+a5: MOVS/W/D/Q Yv,Xv</span>
<span class="p_add">+a6: CMPS/B Xb,Yb</span>
<span class="p_add">+a7: CMPS/W/D Xv,Yv</span>
<span class="p_add">+a8: TEST AL,Ib</span>
<span class="p_add">+a9: TEST rAX,Iz</span>
<span class="p_add">+aa: STOS/B Yb,AL</span>
<span class="p_add">+ab: STOS/W/D/Q Yv,rAX</span>
<span class="p_add">+ac: LODS/B AL,Xb</span>
<span class="p_add">+ad: LODS/W/D/Q rAX,Xv</span>
<span class="p_add">+ae: SCAS/B AL,Yb</span>
<span class="p_add">+# Note: The May 2011 Intel manual shows Xv for the second parameter of the</span>
<span class="p_add">+# next instruction but Yv is correct</span>
<span class="p_add">+af: SCAS/W/D/Q rAX,Yv</span>
<span class="p_add">+# 0xb0 - 0xbf</span>
<span class="p_add">+b0: MOV AL/R8L,Ib</span>
<span class="p_add">+b1: MOV CL/R9L,Ib</span>
<span class="p_add">+b2: MOV DL/R10L,Ib</span>
<span class="p_add">+b3: MOV BL/R11L,Ib</span>
<span class="p_add">+b4: MOV AH/R12L,Ib</span>
<span class="p_add">+b5: MOV CH/R13L,Ib</span>
<span class="p_add">+b6: MOV DH/R14L,Ib</span>
<span class="p_add">+b7: MOV BH/R15L,Ib</span>
<span class="p_add">+b8: MOV rAX/r8,Iv</span>
<span class="p_add">+b9: MOV rCX/r9,Iv</span>
<span class="p_add">+ba: MOV rDX/r10,Iv</span>
<span class="p_add">+bb: MOV rBX/r11,Iv</span>
<span class="p_add">+bc: MOV rSP/r12,Iv</span>
<span class="p_add">+bd: MOV rBP/r13,Iv</span>
<span class="p_add">+be: MOV rSI/r14,Iv</span>
<span class="p_add">+bf: MOV rDI/r15,Iv</span>
<span class="p_add">+# 0xc0 - 0xcf</span>
<span class="p_add">+c0: Grp2 Eb,Ib (1A)</span>
<span class="p_add">+c1: Grp2 Ev,Ib (1A)</span>
<span class="p_add">+c2: RETN Iw (f64)</span>
<span class="p_add">+c3: RETN</span>
<span class="p_add">+c4: LES Gz,Mp (i64) | VEX+2byte (Prefix)</span>
<span class="p_add">+c5: LDS Gz,Mp (i64) | VEX+1byte (Prefix)</span>
<span class="p_add">+c6: Grp11A Eb,Ib (1A)</span>
<span class="p_add">+c7: Grp11B Ev,Iz (1A)</span>
<span class="p_add">+c8: ENTER Iw,Ib</span>
<span class="p_add">+c9: LEAVE (d64)</span>
<span class="p_add">+ca: RETF Iw</span>
<span class="p_add">+cb: RETF</span>
<span class="p_add">+cc: INT3</span>
<span class="p_add">+cd: INT Ib</span>
<span class="p_add">+ce: INTO (i64)</span>
<span class="p_add">+cf: IRET/D/Q</span>
<span class="p_add">+# 0xd0 - 0xdf</span>
<span class="p_add">+d0: Grp2 Eb,1 (1A)</span>
<span class="p_add">+d1: Grp2 Ev,1 (1A)</span>
<span class="p_add">+d2: Grp2 Eb,CL (1A)</span>
<span class="p_add">+d3: Grp2 Ev,CL (1A)</span>
<span class="p_add">+d4: AAM Ib (i64)</span>
<span class="p_add">+d5: AAD Ib (i64)</span>
<span class="p_add">+d6:</span>
<span class="p_add">+d7: XLAT/XLATB</span>
<span class="p_add">+d8: ESC</span>
<span class="p_add">+d9: ESC</span>
<span class="p_add">+da: ESC</span>
<span class="p_add">+db: ESC</span>
<span class="p_add">+dc: ESC</span>
<span class="p_add">+dd: ESC</span>
<span class="p_add">+de: ESC</span>
<span class="p_add">+df: ESC</span>
<span class="p_add">+# 0xe0 - 0xef</span>
<span class="p_add">+# Note: &quot;forced64&quot; is Intel CPU behavior: they ignore 0x66 prefix</span>
<span class="p_add">+# in 64-bit mode. AMD CPUs accept 0x66 prefix, it causes RIP truncation</span>
<span class="p_add">+# to 16 bits. In 32-bit mode, 0x66 is accepted by both Intel and AMD.</span>
<span class="p_add">+e0: LOOPNE/LOOPNZ Jb (f64)</span>
<span class="p_add">+e1: LOOPE/LOOPZ Jb (f64)</span>
<span class="p_add">+e2: LOOP Jb (f64)</span>
<span class="p_add">+e3: JrCXZ Jb (f64)</span>
<span class="p_add">+e4: IN AL,Ib</span>
<span class="p_add">+e5: IN eAX,Ib</span>
<span class="p_add">+e6: OUT Ib,AL</span>
<span class="p_add">+e7: OUT Ib,eAX</span>
<span class="p_add">+# With 0x66 prefix in 64-bit mode, for AMD CPUs immediate offset</span>
<span class="p_add">+# in &quot;near&quot; jumps and calls is 16-bit. For CALL,</span>
<span class="p_add">+# push of return address is 16-bit wide, RSP is decremented by 2</span>
<span class="p_add">+# but is not truncated to 16 bits, unlike RIP.</span>
<span class="p_add">+e8: CALL Jz (f64)</span>
<span class="p_add">+e9: JMP-near Jz (f64)</span>
<span class="p_add">+ea: JMP-far Ap (i64)</span>
<span class="p_add">+eb: JMP-short Jb (f64)</span>
<span class="p_add">+ec: IN AL,DX</span>
<span class="p_add">+ed: IN eAX,DX</span>
<span class="p_add">+ee: OUT DX,AL</span>
<span class="p_add">+ef: OUT DX,eAX</span>
<span class="p_add">+# 0xf0 - 0xff</span>
<span class="p_add">+f0: LOCK (Prefix)</span>
<span class="p_add">+f1:</span>
<span class="p_add">+f2: REPNE (Prefix) | XACQUIRE (Prefix)</span>
<span class="p_add">+f3: REP/REPE (Prefix) | XRELEASE (Prefix)</span>
<span class="p_add">+f4: HLT</span>
<span class="p_add">+f5: CMC</span>
<span class="p_add">+f6: Grp3_1 Eb (1A)</span>
<span class="p_add">+f7: Grp3_2 Ev (1A)</span>
<span class="p_add">+f8: CLC</span>
<span class="p_add">+f9: STC</span>
<span class="p_add">+fa: CLI</span>
<span class="p_add">+fb: STI</span>
<span class="p_add">+fc: CLD</span>
<span class="p_add">+fd: STD</span>
<span class="p_add">+fe: Grp4 (1A)</span>
<span class="p_add">+ff: Grp5 (1A)</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+Table: 2-byte opcode (0x0f)</span>
<span class="p_add">+Referrer: 2-byte escape</span>
<span class="p_add">+AVXcode: 1</span>
<span class="p_add">+# 0x0f 0x00-0x0f</span>
<span class="p_add">+00: Grp6 (1A)</span>
<span class="p_add">+01: Grp7 (1A)</span>
<span class="p_add">+02: LAR Gv,Ew</span>
<span class="p_add">+03: LSL Gv,Ew</span>
<span class="p_add">+04:</span>
<span class="p_add">+05: SYSCALL (o64)</span>
<span class="p_add">+06: CLTS</span>
<span class="p_add">+07: SYSRET (o64)</span>
<span class="p_add">+08: INVD</span>
<span class="p_add">+09: WBINVD</span>
<span class="p_add">+0a:</span>
<span class="p_add">+0b: UD2 (1B)</span>
<span class="p_add">+0c:</span>
<span class="p_add">+# AMD&#39;s prefetch group. Intel supports prefetchw(/1) only.</span>
<span class="p_add">+0d: GrpP</span>
<span class="p_add">+0e: FEMMS</span>
<span class="p_add">+# 3DNow! uses the last imm byte as opcode extension.</span>
<span class="p_add">+0f: 3DNow! Pq,Qq,Ib</span>
<span class="p_add">+# 0x0f 0x10-0x1f</span>
<span class="p_add">+# NOTE: According to Intel SDM opcode map, vmovups and vmovupd has no operands</span>
<span class="p_add">+# but it actually has operands. And also, vmovss and vmovsd only accept 128bit.</span>
<span class="p_add">+# MOVSS/MOVSD has too many forms(3) on SDM. This map just shows a typical form.</span>
<span class="p_add">+# Many AVX instructions lack v1 superscript, according to Intel AVX-Prgramming</span>
<span class="p_add">+# Reference A.1</span>
<span class="p_add">+10: vmovups Vps,Wps | vmovupd Vpd,Wpd (66) | vmovss Vx,Hx,Wss (F3),(v1) | vmovsd Vx,Hx,Wsd (F2),(v1)</span>
<span class="p_add">+11: vmovups Wps,Vps | vmovupd Wpd,Vpd (66) | vmovss Wss,Hx,Vss (F3),(v1) | vmovsd Wsd,Hx,Vsd (F2),(v1)</span>
<span class="p_add">+12: vmovlps Vq,Hq,Mq (v1) | vmovhlps Vq,Hq,Uq (v1) | vmovlpd Vq,Hq,Mq (66),(v1) | vmovsldup Vx,Wx (F3) | vmovddup Vx,Wx (F2)</span>
<span class="p_add">+13: vmovlps Mq,Vq (v1) | vmovlpd Mq,Vq (66),(v1)</span>
<span class="p_add">+14: vunpcklps Vx,Hx,Wx | vunpcklpd Vx,Hx,Wx (66)</span>
<span class="p_add">+15: vunpckhps Vx,Hx,Wx | vunpckhpd Vx,Hx,Wx (66)</span>
<span class="p_add">+16: vmovhps Vdq,Hq,Mq (v1) | vmovlhps Vdq,Hq,Uq (v1) | vmovhpd Vdq,Hq,Mq (66),(v1) | vmovshdup Vx,Wx (F3)</span>
<span class="p_add">+17: vmovhps Mq,Vq (v1) | vmovhpd Mq,Vq (66),(v1)</span>
<span class="p_add">+18: Grp16 (1A)</span>
<span class="p_add">+19:</span>
<span class="p_add">+# Intel SDM opcode map does not list MPX instructions. For now using Gv for</span>
<span class="p_add">+# bnd registers and Ev for everything else is OK because the instruction</span>
<span class="p_add">+# decoder does not use the information except as an indication that there is</span>
<span class="p_add">+# a ModR/M byte.</span>
<span class="p_add">+1a: BNDCL Gv,Ev (F3) | BNDCU Gv,Ev (F2) | BNDMOV Gv,Ev (66) | BNDLDX Gv,Ev</span>
<span class="p_add">+1b: BNDCN Gv,Ev (F2) | BNDMOV Ev,Gv (66) | BNDMK Gv,Ev (F3) | BNDSTX Ev,Gv</span>
<span class="p_add">+1c:</span>
<span class="p_add">+1d:</span>
<span class="p_add">+1e:</span>
<span class="p_add">+1f: NOP Ev</span>
<span class="p_add">+# 0x0f 0x20-0x2f</span>
<span class="p_add">+20: MOV Rd,Cd</span>
<span class="p_add">+21: MOV Rd,Dd</span>
<span class="p_add">+22: MOV Cd,Rd</span>
<span class="p_add">+23: MOV Dd,Rd</span>
<span class="p_add">+24:</span>
<span class="p_add">+25:</span>
<span class="p_add">+26:</span>
<span class="p_add">+27:</span>
<span class="p_add">+28: vmovaps Vps,Wps | vmovapd Vpd,Wpd (66)</span>
<span class="p_add">+29: vmovaps Wps,Vps | vmovapd Wpd,Vpd (66)</span>
<span class="p_add">+2a: cvtpi2ps Vps,Qpi | cvtpi2pd Vpd,Qpi (66) | vcvtsi2ss Vss,Hss,Ey (F3),(v1) | vcvtsi2sd Vsd,Hsd,Ey (F2),(v1)</span>
<span class="p_add">+2b: vmovntps Mps,Vps | vmovntpd Mpd,Vpd (66)</span>
<span class="p_add">+2c: cvttps2pi Ppi,Wps | cvttpd2pi Ppi,Wpd (66) | vcvttss2si Gy,Wss (F3),(v1) | vcvttsd2si Gy,Wsd (F2),(v1)</span>
<span class="p_add">+2d: cvtps2pi Ppi,Wps | cvtpd2pi Qpi,Wpd (66) | vcvtss2si Gy,Wss (F3),(v1) | vcvtsd2si Gy,Wsd (F2),(v1)</span>
<span class="p_add">+2e: vucomiss Vss,Wss (v1) | vucomisd  Vsd,Wsd (66),(v1)</span>
<span class="p_add">+2f: vcomiss Vss,Wss (v1) | vcomisd  Vsd,Wsd (66),(v1)</span>
<span class="p_add">+# 0x0f 0x30-0x3f</span>
<span class="p_add">+30: WRMSR</span>
<span class="p_add">+31: RDTSC</span>
<span class="p_add">+32: RDMSR</span>
<span class="p_add">+33: RDPMC</span>
<span class="p_add">+34: SYSENTER</span>
<span class="p_add">+35: SYSEXIT</span>
<span class="p_add">+36:</span>
<span class="p_add">+37: GETSEC</span>
<span class="p_add">+38: escape # 3-byte escape 1</span>
<span class="p_add">+39:</span>
<span class="p_add">+3a: escape # 3-byte escape 2</span>
<span class="p_add">+3b:</span>
<span class="p_add">+3c:</span>
<span class="p_add">+3d:</span>
<span class="p_add">+3e:</span>
<span class="p_add">+3f:</span>
<span class="p_add">+# 0x0f 0x40-0x4f</span>
<span class="p_add">+40: CMOVO Gv,Ev</span>
<span class="p_add">+41: CMOVNO Gv,Ev | kandw/q Vk,Hk,Uk | kandb/d Vk,Hk,Uk (66)</span>
<span class="p_add">+42: CMOVB/C/NAE Gv,Ev | kandnw/q Vk,Hk,Uk | kandnb/d Vk,Hk,Uk (66)</span>
<span class="p_add">+43: CMOVAE/NB/NC Gv,Ev</span>
<span class="p_add">+44: CMOVE/Z Gv,Ev | knotw/q Vk,Uk | knotb/d Vk,Uk (66)</span>
<span class="p_add">+45: CMOVNE/NZ Gv,Ev | korw/q Vk,Hk,Uk | korb/d Vk,Hk,Uk (66)</span>
<span class="p_add">+46: CMOVBE/NA Gv,Ev | kxnorw/q Vk,Hk,Uk | kxnorb/d Vk,Hk,Uk (66)</span>
<span class="p_add">+47: CMOVA/NBE Gv,Ev | kxorw/q Vk,Hk,Uk | kxorb/d Vk,Hk,Uk (66)</span>
<span class="p_add">+48: CMOVS Gv,Ev</span>
<span class="p_add">+49: CMOVNS Gv,Ev</span>
<span class="p_add">+4a: CMOVP/PE Gv,Ev | kaddw/q Vk,Hk,Uk | kaddb/d Vk,Hk,Uk (66)</span>
<span class="p_add">+4b: CMOVNP/PO Gv,Ev | kunpckbw Vk,Hk,Uk (66) | kunpckwd/dq Vk,Hk,Uk</span>
<span class="p_add">+4c: CMOVL/NGE Gv,Ev</span>
<span class="p_add">+4d: CMOVNL/GE Gv,Ev</span>
<span class="p_add">+4e: CMOVLE/NG Gv,Ev</span>
<span class="p_add">+4f: CMOVNLE/G Gv,Ev</span>
<span class="p_add">+# 0x0f 0x50-0x5f</span>
<span class="p_add">+50: vmovmskps Gy,Ups | vmovmskpd Gy,Upd (66)</span>
<span class="p_add">+51: vsqrtps Vps,Wps | vsqrtpd Vpd,Wpd (66) | vsqrtss Vss,Hss,Wss (F3),(v1) | vsqrtsd Vsd,Hsd,Wsd (F2),(v1)</span>
<span class="p_add">+52: vrsqrtps Vps,Wps | vrsqrtss Vss,Hss,Wss (F3),(v1)</span>
<span class="p_add">+53: vrcpps Vps,Wps | vrcpss Vss,Hss,Wss (F3),(v1)</span>
<span class="p_add">+54: vandps Vps,Hps,Wps | vandpd Vpd,Hpd,Wpd (66)</span>
<span class="p_add">+55: vandnps Vps,Hps,Wps | vandnpd Vpd,Hpd,Wpd (66)</span>
<span class="p_add">+56: vorps Vps,Hps,Wps | vorpd Vpd,Hpd,Wpd (66)</span>
<span class="p_add">+57: vxorps Vps,Hps,Wps | vxorpd Vpd,Hpd,Wpd (66)</span>
<span class="p_add">+58: vaddps Vps,Hps,Wps | vaddpd Vpd,Hpd,Wpd (66) | vaddss Vss,Hss,Wss (F3),(v1) | vaddsd Vsd,Hsd,Wsd (F2),(v1)</span>
<span class="p_add">+59: vmulps Vps,Hps,Wps | vmulpd Vpd,Hpd,Wpd (66) | vmulss Vss,Hss,Wss (F3),(v1) | vmulsd Vsd,Hsd,Wsd (F2),(v1)</span>
<span class="p_add">+5a: vcvtps2pd Vpd,Wps | vcvtpd2ps Vps,Wpd (66) | vcvtss2sd Vsd,Hx,Wss (F3),(v1) | vcvtsd2ss Vss,Hx,Wsd (F2),(v1)</span>
<span class="p_add">+5b: vcvtdq2ps Vps,Wdq | vcvtqq2ps Vps,Wqq (evo) | vcvtps2dq Vdq,Wps (66) | vcvttps2dq Vdq,Wps (F3)</span>
<span class="p_add">+5c: vsubps Vps,Hps,Wps | vsubpd Vpd,Hpd,Wpd (66) | vsubss Vss,Hss,Wss (F3),(v1) | vsubsd Vsd,Hsd,Wsd (F2),(v1)</span>
<span class="p_add">+5d: vminps Vps,Hps,Wps | vminpd Vpd,Hpd,Wpd (66) | vminss Vss,Hss,Wss (F3),(v1) | vminsd Vsd,Hsd,Wsd (F2),(v1)</span>
<span class="p_add">+5e: vdivps Vps,Hps,Wps | vdivpd Vpd,Hpd,Wpd (66) | vdivss Vss,Hss,Wss (F3),(v1) | vdivsd Vsd,Hsd,Wsd (F2),(v1)</span>
<span class="p_add">+5f: vmaxps Vps,Hps,Wps | vmaxpd Vpd,Hpd,Wpd (66) | vmaxss Vss,Hss,Wss (F3),(v1) | vmaxsd Vsd,Hsd,Wsd (F2),(v1)</span>
<span class="p_add">+# 0x0f 0x60-0x6f</span>
<span class="p_add">+60: punpcklbw Pq,Qd | vpunpcklbw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+61: punpcklwd Pq,Qd | vpunpcklwd Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+62: punpckldq Pq,Qd | vpunpckldq Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+63: packsswb Pq,Qq | vpacksswb Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+64: pcmpgtb Pq,Qq | vpcmpgtb Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+65: pcmpgtw Pq,Qq | vpcmpgtw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+66: pcmpgtd Pq,Qq | vpcmpgtd Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+67: packuswb Pq,Qq | vpackuswb Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+68: punpckhbw Pq,Qd | vpunpckhbw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+69: punpckhwd Pq,Qd | vpunpckhwd Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+6a: punpckhdq Pq,Qd | vpunpckhdq Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+6b: packssdw Pq,Qd | vpackssdw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+6c: vpunpcklqdq Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+6d: vpunpckhqdq Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+6e: movd/q Pd,Ey | vmovd/q Vy,Ey (66),(v1)</span>
<span class="p_add">+6f: movq Pq,Qq | vmovdqa Vx,Wx (66) | vmovdqa32/64 Vx,Wx (66),(evo) | vmovdqu Vx,Wx (F3) | vmovdqu32/64 Vx,Wx (F3),(evo) | vmovdqu8/16 Vx,Wx (F2),(ev)</span>
<span class="p_add">+# 0x0f 0x70-0x7f</span>
<span class="p_add">+70: pshufw Pq,Qq,Ib | vpshufd Vx,Wx,Ib (66),(v1) | vpshufhw Vx,Wx,Ib (F3),(v1) | vpshuflw Vx,Wx,Ib (F2),(v1)</span>
<span class="p_add">+71: Grp12 (1A)</span>
<span class="p_add">+72: Grp13 (1A)</span>
<span class="p_add">+73: Grp14 (1A)</span>
<span class="p_add">+74: pcmpeqb Pq,Qq | vpcmpeqb Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+75: pcmpeqw Pq,Qq | vpcmpeqw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+76: pcmpeqd Pq,Qq | vpcmpeqd Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+# Note: Remove (v), because vzeroall and vzeroupper becomes emms without VEX.</span>
<span class="p_add">+77: emms | vzeroupper | vzeroall</span>
<span class="p_add">+78: VMREAD Ey,Gy | vcvttps2udq/pd2udq Vx,Wpd (evo) | vcvttsd2usi Gv,Wx (F2),(ev) | vcvttss2usi Gv,Wx (F3),(ev) | vcvttps2uqq/pd2uqq Vx,Wx (66),(ev)</span>
<span class="p_add">+79: VMWRITE Gy,Ey | vcvtps2udq/pd2udq Vx,Wpd (evo) | vcvtsd2usi Gv,Wx (F2),(ev) | vcvtss2usi Gv,Wx (F3),(ev) | vcvtps2uqq/pd2uqq Vx,Wx (66),(ev)</span>
<span class="p_add">+7a: vcvtudq2pd/uqq2pd Vpd,Wx (F3),(ev) | vcvtudq2ps/uqq2ps Vpd,Wx (F2),(ev) | vcvttps2qq/pd2qq Vx,Wx (66),(ev)</span>
<span class="p_add">+7b: vcvtusi2sd Vpd,Hpd,Ev (F2),(ev) | vcvtusi2ss Vps,Hps,Ev (F3),(ev) | vcvtps2qq/pd2qq Vx,Wx (66),(ev)</span>
<span class="p_add">+7c: vhaddpd Vpd,Hpd,Wpd (66) | vhaddps Vps,Hps,Wps (F2)</span>
<span class="p_add">+7d: vhsubpd Vpd,Hpd,Wpd (66) | vhsubps Vps,Hps,Wps (F2)</span>
<span class="p_add">+7e: movd/q Ey,Pd | vmovd/q Ey,Vy (66),(v1) | vmovq Vq,Wq (F3),(v1)</span>
<span class="p_add">+7f: movq Qq,Pq | vmovdqa Wx,Vx (66) | vmovdqa32/64 Wx,Vx (66),(evo) | vmovdqu Wx,Vx (F3) | vmovdqu32/64 Wx,Vx (F3),(evo) | vmovdqu8/16 Wx,Vx (F2),(ev)</span>
<span class="p_add">+# 0x0f 0x80-0x8f</span>
<span class="p_add">+# Note: &quot;forced64&quot; is Intel CPU behavior (see comment about CALL insn).</span>
<span class="p_add">+80: JO Jz (f64)</span>
<span class="p_add">+81: JNO Jz (f64)</span>
<span class="p_add">+82: JB/JC/JNAE Jz (f64)</span>
<span class="p_add">+83: JAE/JNB/JNC Jz (f64)</span>
<span class="p_add">+84: JE/JZ Jz (f64)</span>
<span class="p_add">+85: JNE/JNZ Jz (f64)</span>
<span class="p_add">+86: JBE/JNA Jz (f64)</span>
<span class="p_add">+87: JA/JNBE Jz (f64)</span>
<span class="p_add">+88: JS Jz (f64)</span>
<span class="p_add">+89: JNS Jz (f64)</span>
<span class="p_add">+8a: JP/JPE Jz (f64)</span>
<span class="p_add">+8b: JNP/JPO Jz (f64)</span>
<span class="p_add">+8c: JL/JNGE Jz (f64)</span>
<span class="p_add">+8d: JNL/JGE Jz (f64)</span>
<span class="p_add">+8e: JLE/JNG Jz (f64)</span>
<span class="p_add">+8f: JNLE/JG Jz (f64)</span>
<span class="p_add">+# 0x0f 0x90-0x9f</span>
<span class="p_add">+90: SETO Eb | kmovw/q Vk,Wk | kmovb/d Vk,Wk (66)</span>
<span class="p_add">+91: SETNO Eb | kmovw/q Mv,Vk | kmovb/d Mv,Vk (66)</span>
<span class="p_add">+92: SETB/C/NAE Eb | kmovw Vk,Rv | kmovb Vk,Rv (66) | kmovq/d Vk,Rv (F2)</span>
<span class="p_add">+93: SETAE/NB/NC Eb | kmovw Gv,Uk | kmovb Gv,Uk (66) | kmovq/d Gv,Uk (F2)</span>
<span class="p_add">+94: SETE/Z Eb</span>
<span class="p_add">+95: SETNE/NZ Eb</span>
<span class="p_add">+96: SETBE/NA Eb</span>
<span class="p_add">+97: SETA/NBE Eb</span>
<span class="p_add">+98: SETS Eb | kortestw/q Vk,Uk | kortestb/d Vk,Uk (66)</span>
<span class="p_add">+99: SETNS Eb | ktestw/q Vk,Uk | ktestb/d Vk,Uk (66)</span>
<span class="p_add">+9a: SETP/PE Eb</span>
<span class="p_add">+9b: SETNP/PO Eb</span>
<span class="p_add">+9c: SETL/NGE Eb</span>
<span class="p_add">+9d: SETNL/GE Eb</span>
<span class="p_add">+9e: SETLE/NG Eb</span>
<span class="p_add">+9f: SETNLE/G Eb</span>
<span class="p_add">+# 0x0f 0xa0-0xaf</span>
<span class="p_add">+a0: PUSH FS (d64)</span>
<span class="p_add">+a1: POP FS (d64)</span>
<span class="p_add">+a2: CPUID</span>
<span class="p_add">+a3: BT Ev,Gv</span>
<span class="p_add">+a4: SHLD Ev,Gv,Ib</span>
<span class="p_add">+a5: SHLD Ev,Gv,CL</span>
<span class="p_add">+a6: GrpPDLK</span>
<span class="p_add">+a7: GrpRNG</span>
<span class="p_add">+a8: PUSH GS (d64)</span>
<span class="p_add">+a9: POP GS (d64)</span>
<span class="p_add">+aa: RSM</span>
<span class="p_add">+ab: BTS Ev,Gv</span>
<span class="p_add">+ac: SHRD Ev,Gv,Ib</span>
<span class="p_add">+ad: SHRD Ev,Gv,CL</span>
<span class="p_add">+ae: Grp15 (1A),(1C)</span>
<span class="p_add">+af: IMUL Gv,Ev</span>
<span class="p_add">+# 0x0f 0xb0-0xbf</span>
<span class="p_add">+b0: CMPXCHG Eb,Gb</span>
<span class="p_add">+b1: CMPXCHG Ev,Gv</span>
<span class="p_add">+b2: LSS Gv,Mp</span>
<span class="p_add">+b3: BTR Ev,Gv</span>
<span class="p_add">+b4: LFS Gv,Mp</span>
<span class="p_add">+b5: LGS Gv,Mp</span>
<span class="p_add">+b6: MOVZX Gv,Eb</span>
<span class="p_add">+b7: MOVZX Gv,Ew</span>
<span class="p_add">+b8: JMPE (!F3) | POPCNT Gv,Ev (F3)</span>
<span class="p_add">+b9: Grp10 (1A)</span>
<span class="p_add">+ba: Grp8 Ev,Ib (1A)</span>
<span class="p_add">+bb: BTC Ev,Gv</span>
<span class="p_add">+bc: BSF Gv,Ev (!F3) | TZCNT Gv,Ev (F3)</span>
<span class="p_add">+bd: BSR Gv,Ev (!F3) | LZCNT Gv,Ev (F3)</span>
<span class="p_add">+be: MOVSX Gv,Eb</span>
<span class="p_add">+bf: MOVSX Gv,Ew</span>
<span class="p_add">+# 0x0f 0xc0-0xcf</span>
<span class="p_add">+c0: XADD Eb,Gb</span>
<span class="p_add">+c1: XADD Ev,Gv</span>
<span class="p_add">+c2: vcmpps Vps,Hps,Wps,Ib | vcmppd Vpd,Hpd,Wpd,Ib (66) | vcmpss Vss,Hss,Wss,Ib (F3),(v1) | vcmpsd Vsd,Hsd,Wsd,Ib (F2),(v1)</span>
<span class="p_add">+c3: movnti My,Gy</span>
<span class="p_add">+c4: pinsrw Pq,Ry/Mw,Ib | vpinsrw Vdq,Hdq,Ry/Mw,Ib (66),(v1)</span>
<span class="p_add">+c5: pextrw Gd,Nq,Ib | vpextrw Gd,Udq,Ib (66),(v1)</span>
<span class="p_add">+c6: vshufps Vps,Hps,Wps,Ib | vshufpd Vpd,Hpd,Wpd,Ib (66)</span>
<span class="p_add">+c7: Grp9 (1A)</span>
<span class="p_add">+c8: BSWAP RAX/EAX/R8/R8D</span>
<span class="p_add">+c9: BSWAP RCX/ECX/R9/R9D</span>
<span class="p_add">+ca: BSWAP RDX/EDX/R10/R10D</span>
<span class="p_add">+cb: BSWAP RBX/EBX/R11/R11D</span>
<span class="p_add">+cc: BSWAP RSP/ESP/R12/R12D</span>
<span class="p_add">+cd: BSWAP RBP/EBP/R13/R13D</span>
<span class="p_add">+ce: BSWAP RSI/ESI/R14/R14D</span>
<span class="p_add">+cf: BSWAP RDI/EDI/R15/R15D</span>
<span class="p_add">+# 0x0f 0xd0-0xdf</span>
<span class="p_add">+d0: vaddsubpd Vpd,Hpd,Wpd (66) | vaddsubps Vps,Hps,Wps (F2)</span>
<span class="p_add">+d1: psrlw Pq,Qq | vpsrlw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+d2: psrld Pq,Qq | vpsrld Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+d3: psrlq Pq,Qq | vpsrlq Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+d4: paddq Pq,Qq | vpaddq Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+d5: pmullw Pq,Qq | vpmullw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+d6: vmovq Wq,Vq (66),(v1) | movq2dq Vdq,Nq (F3) | movdq2q Pq,Uq (F2)</span>
<span class="p_add">+d7: pmovmskb Gd,Nq | vpmovmskb Gd,Ux (66),(v1)</span>
<span class="p_add">+d8: psubusb Pq,Qq | vpsubusb Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+d9: psubusw Pq,Qq | vpsubusw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+da: pminub Pq,Qq | vpminub Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+db: pand Pq,Qq | vpand Vx,Hx,Wx (66),(v1) | vpandd/q Vx,Hx,Wx (66),(evo)</span>
<span class="p_add">+dc: paddusb Pq,Qq | vpaddusb Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+dd: paddusw Pq,Qq | vpaddusw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+de: pmaxub Pq,Qq | vpmaxub Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+df: pandn Pq,Qq | vpandn Vx,Hx,Wx (66),(v1) | vpandnd/q Vx,Hx,Wx (66),(evo)</span>
<span class="p_add">+# 0x0f 0xe0-0xef</span>
<span class="p_add">+e0: pavgb Pq,Qq | vpavgb Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+e1: psraw Pq,Qq | vpsraw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+e2: psrad Pq,Qq | vpsrad Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+e3: pavgw Pq,Qq | vpavgw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+e4: pmulhuw Pq,Qq | vpmulhuw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+e5: pmulhw Pq,Qq | vpmulhw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+e6: vcvttpd2dq Vx,Wpd (66) | vcvtdq2pd Vx,Wdq (F3) | vcvtdq2pd/qq2pd Vx,Wdq (F3),(evo) | vcvtpd2dq Vx,Wpd (F2)</span>
<span class="p_add">+e7: movntq Mq,Pq | vmovntdq Mx,Vx (66)</span>
<span class="p_add">+e8: psubsb Pq,Qq | vpsubsb Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+e9: psubsw Pq,Qq | vpsubsw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+ea: pminsw Pq,Qq | vpminsw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+eb: por Pq,Qq | vpor Vx,Hx,Wx (66),(v1) | vpord/q Vx,Hx,Wx (66),(evo)</span>
<span class="p_add">+ec: paddsb Pq,Qq | vpaddsb Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+ed: paddsw Pq,Qq | vpaddsw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+ee: pmaxsw Pq,Qq | vpmaxsw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+ef: pxor Pq,Qq | vpxor Vx,Hx,Wx (66),(v1) | vpxord/q Vx,Hx,Wx (66),(evo)</span>
<span class="p_add">+# 0x0f 0xf0-0xff</span>
<span class="p_add">+f0: vlddqu Vx,Mx (F2)</span>
<span class="p_add">+f1: psllw Pq,Qq | vpsllw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+f2: pslld Pq,Qq | vpslld Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+f3: psllq Pq,Qq | vpsllq Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+f4: pmuludq Pq,Qq | vpmuludq Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+f5: pmaddwd Pq,Qq | vpmaddwd Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+f6: psadbw Pq,Qq | vpsadbw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+f7: maskmovq Pq,Nq | vmaskmovdqu Vx,Ux (66),(v1)</span>
<span class="p_add">+f8: psubb Pq,Qq | vpsubb Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+f9: psubw Pq,Qq | vpsubw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+fa: psubd Pq,Qq | vpsubd Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+fb: psubq Pq,Qq | vpsubq Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+fc: paddb Pq,Qq | vpaddb Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+fd: paddw Pq,Qq | vpaddw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+fe: paddd Pq,Qq | vpaddd Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+ff: UD0</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+Table: 3-byte opcode 1 (0x0f 0x38)</span>
<span class="p_add">+Referrer: 3-byte escape 1</span>
<span class="p_add">+AVXcode: 2</span>
<span class="p_add">+# 0x0f 0x38 0x00-0x0f</span>
<span class="p_add">+00: pshufb Pq,Qq | vpshufb Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+01: phaddw Pq,Qq | vphaddw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+02: phaddd Pq,Qq | vphaddd Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+03: phaddsw Pq,Qq | vphaddsw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+04: pmaddubsw Pq,Qq | vpmaddubsw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+05: phsubw Pq,Qq | vphsubw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+06: phsubd Pq,Qq | vphsubd Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+07: phsubsw Pq,Qq | vphsubsw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+08: psignb Pq,Qq | vpsignb Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+09: psignw Pq,Qq | vpsignw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+0a: psignd Pq,Qq | vpsignd Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+0b: pmulhrsw Pq,Qq | vpmulhrsw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+0c: vpermilps Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+0d: vpermilpd Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+0e: vtestps Vx,Wx (66),(v)</span>
<span class="p_add">+0f: vtestpd Vx,Wx (66),(v)</span>
<span class="p_add">+# 0x0f 0x38 0x10-0x1f</span>
<span class="p_add">+10: pblendvb Vdq,Wdq (66) | vpsrlvw Vx,Hx,Wx (66),(evo) | vpmovuswb Wx,Vx (F3),(ev)</span>
<span class="p_add">+11: vpmovusdb Wx,Vd (F3),(ev) | vpsravw Vx,Hx,Wx (66),(ev)</span>
<span class="p_add">+12: vpmovusqb Wx,Vq (F3),(ev) | vpsllvw Vx,Hx,Wx (66),(ev)</span>
<span class="p_add">+13: vcvtph2ps Vx,Wx (66),(v) | vpmovusdw Wx,Vd (F3),(ev)</span>
<span class="p_add">+14: blendvps Vdq,Wdq (66) | vpmovusqw Wx,Vq (F3),(ev) | vprorvd/q Vx,Hx,Wx (66),(evo)</span>
<span class="p_add">+15: blendvpd Vdq,Wdq (66) | vpmovusqd Wx,Vq (F3),(ev) | vprolvd/q Vx,Hx,Wx (66),(evo)</span>
<span class="p_add">+16: vpermps Vqq,Hqq,Wqq (66),(v) | vpermps/d Vqq,Hqq,Wqq (66),(evo)</span>
<span class="p_add">+17: vptest Vx,Wx (66)</span>
<span class="p_add">+18: vbroadcastss Vx,Wd (66),(v)</span>
<span class="p_add">+19: vbroadcastsd Vqq,Wq (66),(v) | vbroadcastf32x2 Vqq,Wq (66),(evo)</span>
<span class="p_add">+1a: vbroadcastf128 Vqq,Mdq (66),(v) | vbroadcastf32x4/64x2 Vqq,Wq (66),(evo)</span>
<span class="p_add">+1b: vbroadcastf32x8/64x4 Vqq,Mdq (66),(ev)</span>
<span class="p_add">+1c: pabsb Pq,Qq | vpabsb Vx,Wx (66),(v1)</span>
<span class="p_add">+1d: pabsw Pq,Qq | vpabsw Vx,Wx (66),(v1)</span>
<span class="p_add">+1e: pabsd Pq,Qq | vpabsd Vx,Wx (66),(v1)</span>
<span class="p_add">+1f: vpabsq Vx,Wx (66),(ev)</span>
<span class="p_add">+# 0x0f 0x38 0x20-0x2f</span>
<span class="p_add">+20: vpmovsxbw Vx,Ux/Mq (66),(v1) | vpmovswb Wx,Vx (F3),(ev)</span>
<span class="p_add">+21: vpmovsxbd Vx,Ux/Md (66),(v1) | vpmovsdb Wx,Vd (F3),(ev)</span>
<span class="p_add">+22: vpmovsxbq Vx,Ux/Mw (66),(v1) | vpmovsqb Wx,Vq (F3),(ev)</span>
<span class="p_add">+23: vpmovsxwd Vx,Ux/Mq (66),(v1) | vpmovsdw Wx,Vd (F3),(ev)</span>
<span class="p_add">+24: vpmovsxwq Vx,Ux/Md (66),(v1) | vpmovsqw Wx,Vq (F3),(ev)</span>
<span class="p_add">+25: vpmovsxdq Vx,Ux/Mq (66),(v1) | vpmovsqd Wx,Vq (F3),(ev)</span>
<span class="p_add">+26: vptestmb/w Vk,Hx,Wx (66),(ev) | vptestnmb/w Vk,Hx,Wx (F3),(ev)</span>
<span class="p_add">+27: vptestmd/q Vk,Hx,Wx (66),(ev) | vptestnmd/q Vk,Hx,Wx (F3),(ev)</span>
<span class="p_add">+28: vpmuldq Vx,Hx,Wx (66),(v1) | vpmovm2b/w Vx,Uk (F3),(ev)</span>
<span class="p_add">+29: vpcmpeqq Vx,Hx,Wx (66),(v1) | vpmovb2m/w2m Vk,Ux (F3),(ev)</span>
<span class="p_add">+2a: vmovntdqa Vx,Mx (66),(v1) | vpbroadcastmb2q Vx,Uk (F3),(ev)</span>
<span class="p_add">+2b: vpackusdw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+2c: vmaskmovps Vx,Hx,Mx (66),(v) | vscalefps/d Vx,Hx,Wx (66),(evo)</span>
<span class="p_add">+2d: vmaskmovpd Vx,Hx,Mx (66),(v) | vscalefss/d Vx,Hx,Wx (66),(evo)</span>
<span class="p_add">+2e: vmaskmovps Mx,Hx,Vx (66),(v)</span>
<span class="p_add">+2f: vmaskmovpd Mx,Hx,Vx (66),(v)</span>
<span class="p_add">+# 0x0f 0x38 0x30-0x3f</span>
<span class="p_add">+30: vpmovzxbw Vx,Ux/Mq (66),(v1) | vpmovwb Wx,Vx (F3),(ev)</span>
<span class="p_add">+31: vpmovzxbd Vx,Ux/Md (66),(v1) | vpmovdb Wx,Vd (F3),(ev)</span>
<span class="p_add">+32: vpmovzxbq Vx,Ux/Mw (66),(v1) | vpmovqb Wx,Vq (F3),(ev)</span>
<span class="p_add">+33: vpmovzxwd Vx,Ux/Mq (66),(v1) | vpmovdw Wx,Vd (F3),(ev)</span>
<span class="p_add">+34: vpmovzxwq Vx,Ux/Md (66),(v1) | vpmovqw Wx,Vq (F3),(ev)</span>
<span class="p_add">+35: vpmovzxdq Vx,Ux/Mq (66),(v1) | vpmovqd Wx,Vq (F3),(ev)</span>
<span class="p_add">+36: vpermd Vqq,Hqq,Wqq (66),(v) | vpermd/q Vqq,Hqq,Wqq (66),(evo)</span>
<span class="p_add">+37: vpcmpgtq Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+38: vpminsb Vx,Hx,Wx (66),(v1) | vpmovm2d/q Vx,Uk (F3),(ev)</span>
<span class="p_add">+39: vpminsd Vx,Hx,Wx (66),(v1) | vpminsd/q Vx,Hx,Wx (66),(evo) | vpmovd2m/q2m Vk,Ux (F3),(ev)</span>
<span class="p_add">+3a: vpminuw Vx,Hx,Wx (66),(v1) | vpbroadcastmw2d Vx,Uk (F3),(ev)</span>
<span class="p_add">+3b: vpminud Vx,Hx,Wx (66),(v1) | vpminud/q Vx,Hx,Wx (66),(evo)</span>
<span class="p_add">+3c: vpmaxsb Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+3d: vpmaxsd Vx,Hx,Wx (66),(v1) | vpmaxsd/q Vx,Hx,Wx (66),(evo)</span>
<span class="p_add">+3e: vpmaxuw Vx,Hx,Wx (66),(v1)</span>
<span class="p_add">+3f: vpmaxud Vx,Hx,Wx (66),(v1) | vpmaxud/q Vx,Hx,Wx (66),(evo)</span>
<span class="p_add">+# 0x0f 0x38 0x40-0x8f</span>
<span class="p_add">+40: vpmulld Vx,Hx,Wx (66),(v1) | vpmulld/q Vx,Hx,Wx (66),(evo)</span>
<span class="p_add">+41: vphminposuw Vdq,Wdq (66),(v1)</span>
<span class="p_add">+42: vgetexpps/d Vx,Wx (66),(ev)</span>
<span class="p_add">+43: vgetexpss/d Vx,Hx,Wx (66),(ev)</span>
<span class="p_add">+44: vplzcntd/q Vx,Wx (66),(ev)</span>
<span class="p_add">+45: vpsrlvd/q Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+46: vpsravd Vx,Hx,Wx (66),(v) | vpsravd/q Vx,Hx,Wx (66),(evo)</span>
<span class="p_add">+47: vpsllvd/q Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+# Skip 0x48-0x4b</span>
<span class="p_add">+4c: vrcp14ps/d Vpd,Wpd (66),(ev)</span>
<span class="p_add">+4d: vrcp14ss/d Vsd,Hpd,Wsd (66),(ev)</span>
<span class="p_add">+4e: vrsqrt14ps/d Vpd,Wpd (66),(ev)</span>
<span class="p_add">+4f: vrsqrt14ss/d Vsd,Hsd,Wsd (66),(ev)</span>
<span class="p_add">+# Skip 0x50-0x57</span>
<span class="p_add">+58: vpbroadcastd Vx,Wx (66),(v)</span>
<span class="p_add">+59: vpbroadcastq Vx,Wx (66),(v) | vbroadcasti32x2 Vx,Wx (66),(evo)</span>
<span class="p_add">+5a: vbroadcasti128 Vqq,Mdq (66),(v) | vbroadcasti32x4/64x2 Vx,Wx (66),(evo)</span>
<span class="p_add">+5b: vbroadcasti32x8/64x4 Vqq,Mdq (66),(ev)</span>
<span class="p_add">+# Skip 0x5c-0x63</span>
<span class="p_add">+64: vpblendmd/q Vx,Hx,Wx (66),(ev)</span>
<span class="p_add">+65: vblendmps/d Vx,Hx,Wx (66),(ev)</span>
<span class="p_add">+66: vpblendmb/w Vx,Hx,Wx (66),(ev)</span>
<span class="p_add">+# Skip 0x67-0x74</span>
<span class="p_add">+75: vpermi2b/w Vx,Hx,Wx (66),(ev)</span>
<span class="p_add">+76: vpermi2d/q Vx,Hx,Wx (66),(ev)</span>
<span class="p_add">+77: vpermi2ps/d Vx,Hx,Wx (66),(ev)</span>
<span class="p_add">+78: vpbroadcastb Vx,Wx (66),(v)</span>
<span class="p_add">+79: vpbroadcastw Vx,Wx (66),(v)</span>
<span class="p_add">+7a: vpbroadcastb Vx,Rv (66),(ev)</span>
<span class="p_add">+7b: vpbroadcastw Vx,Rv (66),(ev)</span>
<span class="p_add">+7c: vpbroadcastd/q Vx,Rv (66),(ev)</span>
<span class="p_add">+7d: vpermt2b/w Vx,Hx,Wx (66),(ev)</span>
<span class="p_add">+7e: vpermt2d/q Vx,Hx,Wx (66),(ev)</span>
<span class="p_add">+7f: vpermt2ps/d Vx,Hx,Wx (66),(ev)</span>
<span class="p_add">+80: INVEPT Gy,Mdq (66)</span>
<span class="p_add">+81: INVVPID Gy,Mdq (66)</span>
<span class="p_add">+82: INVPCID Gy,Mdq (66)</span>
<span class="p_add">+83: vpmultishiftqb Vx,Hx,Wx (66),(ev)</span>
<span class="p_add">+88: vexpandps/d Vpd,Wpd (66),(ev)</span>
<span class="p_add">+89: vpexpandd/q Vx,Wx (66),(ev)</span>
<span class="p_add">+8a: vcompressps/d Wx,Vx (66),(ev)</span>
<span class="p_add">+8b: vpcompressd/q Wx,Vx (66),(ev)</span>
<span class="p_add">+8c: vpmaskmovd/q Vx,Hx,Mx (66),(v)</span>
<span class="p_add">+8d: vpermb/w Vx,Hx,Wx (66),(ev)</span>
<span class="p_add">+8e: vpmaskmovd/q Mx,Vx,Hx (66),(v)</span>
<span class="p_add">+# 0x0f 0x38 0x90-0xbf (FMA)</span>
<span class="p_add">+90: vgatherdd/q Vx,Hx,Wx (66),(v) | vpgatherdd/q Vx,Wx (66),(evo)</span>
<span class="p_add">+91: vgatherqd/q Vx,Hx,Wx (66),(v) | vpgatherqd/q Vx,Wx (66),(evo)</span>
<span class="p_add">+92: vgatherdps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+93: vgatherqps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+94:</span>
<span class="p_add">+95:</span>
<span class="p_add">+96: vfmaddsub132ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+97: vfmsubadd132ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+98: vfmadd132ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+99: vfmadd132ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_add">+9a: vfmsub132ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+9b: vfmsub132ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_add">+9c: vfnmadd132ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+9d: vfnmadd132ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_add">+9e: vfnmsub132ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+9f: vfnmsub132ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_add">+a0: vpscatterdd/q Wx,Vx (66),(ev)</span>
<span class="p_add">+a1: vpscatterqd/q Wx,Vx (66),(ev)</span>
<span class="p_add">+a2: vscatterdps/d Wx,Vx (66),(ev)</span>
<span class="p_add">+a3: vscatterqps/d Wx,Vx (66),(ev)</span>
<span class="p_add">+a6: vfmaddsub213ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+a7: vfmsubadd213ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+a8: vfmadd213ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+a9: vfmadd213ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_add">+aa: vfmsub213ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+ab: vfmsub213ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_add">+ac: vfnmadd213ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+ad: vfnmadd213ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_add">+ae: vfnmsub213ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+af: vfnmsub213ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_add">+b4: vpmadd52luq Vx,Hx,Wx (66),(ev)</span>
<span class="p_add">+b5: vpmadd52huq Vx,Hx,Wx (66),(ev)</span>
<span class="p_add">+b6: vfmaddsub231ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+b7: vfmsubadd231ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+b8: vfmadd231ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+b9: vfmadd231ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_add">+ba: vfmsub231ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+bb: vfmsub231ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_add">+bc: vfnmadd231ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+bd: vfnmadd231ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_add">+be: vfnmsub231ps/d Vx,Hx,Wx (66),(v)</span>
<span class="p_add">+bf: vfnmsub231ss/d Vx,Hx,Wx (66),(v),(v1)</span>
<span class="p_add">+# 0x0f 0x38 0xc0-0xff</span>
<span class="p_add">+c4: vpconflictd/q Vx,Wx (66),(ev)</span>
<span class="p_add">+c6: Grp18 (1A)</span>
<span class="p_add">+c7: Grp19 (1A)</span>
<span class="p_add">+c8: sha1nexte Vdq,Wdq | vexp2ps/d Vx,Wx (66),(ev)</span>
<span class="p_add">+c9: sha1msg1 Vdq,Wdq</span>
<span class="p_add">+ca: sha1msg2 Vdq,Wdq | vrcp28ps/d Vx,Wx (66),(ev)</span>
<span class="p_add">+cb: sha256rnds2 Vdq,Wdq | vrcp28ss/d Vx,Hx,Wx (66),(ev)</span>
<span class="p_add">+cc: sha256msg1 Vdq,Wdq | vrsqrt28ps/d Vx,Wx (66),(ev)</span>
<span class="p_add">+cd: sha256msg2 Vdq,Wdq | vrsqrt28ss/d Vx,Hx,Wx (66),(ev)</span>
<span class="p_add">+db: VAESIMC Vdq,Wdq (66),(v1)</span>
<span class="p_add">+dc: VAESENC Vdq,Hdq,Wdq (66),(v1)</span>
<span class="p_add">+dd: VAESENCLAST Vdq,Hdq,Wdq (66),(v1)</span>
<span class="p_add">+de: VAESDEC Vdq,Hdq,Wdq (66),(v1)</span>
<span class="p_add">+df: VAESDECLAST Vdq,Hdq,Wdq (66),(v1)</span>
<span class="p_add">+f0: MOVBE Gy,My | MOVBE Gw,Mw (66) | CRC32 Gd,Eb (F2) | CRC32 Gd,Eb (66&amp;F2)</span>
<span class="p_add">+f1: MOVBE My,Gy | MOVBE Mw,Gw (66) | CRC32 Gd,Ey (F2) | CRC32 Gd,Ew (66&amp;F2)</span>
<span class="p_add">+f2: ANDN Gy,By,Ey (v)</span>
<span class="p_add">+f3: Grp17 (1A)</span>
<span class="p_add">+f5: BZHI Gy,Ey,By (v) | PEXT Gy,By,Ey (F3),(v) | PDEP Gy,By,Ey (F2),(v)</span>
<span class="p_add">+f6: ADCX Gy,Ey (66) | ADOX Gy,Ey (F3) | MULX By,Gy,rDX,Ey (F2),(v)</span>
<span class="p_add">+f7: BEXTR Gy,Ey,By (v) | SHLX Gy,Ey,By (66),(v) | SARX Gy,Ey,By (F3),(v) | SHRX Gy,Ey,By (F2),(v)</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+Table: 3-byte opcode 2 (0x0f 0x3a)</span>
<span class="p_add">+Referrer: 3-byte escape 2</span>
<span class="p_add">+AVXcode: 3</span>
<span class="p_add">+# 0x0f 0x3a 0x00-0xff</span>
<span class="p_add">+00: vpermq Vqq,Wqq,Ib (66),(v)</span>
<span class="p_add">+01: vpermpd Vqq,Wqq,Ib (66),(v)</span>
<span class="p_add">+02: vpblendd Vx,Hx,Wx,Ib (66),(v)</span>
<span class="p_add">+03: valignd/q Vx,Hx,Wx,Ib (66),(ev)</span>
<span class="p_add">+04: vpermilps Vx,Wx,Ib (66),(v)</span>
<span class="p_add">+05: vpermilpd Vx,Wx,Ib (66),(v)</span>
<span class="p_add">+06: vperm2f128 Vqq,Hqq,Wqq,Ib (66),(v)</span>
<span class="p_add">+07:</span>
<span class="p_add">+08: vroundps Vx,Wx,Ib (66) | vrndscaleps Vx,Wx,Ib (66),(evo)</span>
<span class="p_add">+09: vroundpd Vx,Wx,Ib (66) | vrndscalepd Vx,Wx,Ib (66),(evo)</span>
<span class="p_add">+0a: vroundss Vss,Wss,Ib (66),(v1) | vrndscaless Vx,Hx,Wx,Ib (66),(evo)</span>
<span class="p_add">+0b: vroundsd Vsd,Wsd,Ib (66),(v1) | vrndscalesd Vx,Hx,Wx,Ib (66),(evo)</span>
<span class="p_add">+0c: vblendps Vx,Hx,Wx,Ib (66)</span>
<span class="p_add">+0d: vblendpd Vx,Hx,Wx,Ib (66)</span>
<span class="p_add">+0e: vpblendw Vx,Hx,Wx,Ib (66),(v1)</span>
<span class="p_add">+0f: palignr Pq,Qq,Ib | vpalignr Vx,Hx,Wx,Ib (66),(v1)</span>
<span class="p_add">+14: vpextrb Rd/Mb,Vdq,Ib (66),(v1)</span>
<span class="p_add">+15: vpextrw Rd/Mw,Vdq,Ib (66),(v1)</span>
<span class="p_add">+16: vpextrd/q Ey,Vdq,Ib (66),(v1)</span>
<span class="p_add">+17: vextractps Ed,Vdq,Ib (66),(v1)</span>
<span class="p_add">+18: vinsertf128 Vqq,Hqq,Wqq,Ib (66),(v) | vinsertf32x4/64x2 Vqq,Hqq,Wqq,Ib (66),(evo)</span>
<span class="p_add">+19: vextractf128 Wdq,Vqq,Ib (66),(v) | vextractf32x4/64x2 Wdq,Vqq,Ib (66),(evo)</span>
<span class="p_add">+1a: vinsertf32x8/64x4 Vqq,Hqq,Wqq,Ib (66),(ev)</span>
<span class="p_add">+1b: vextractf32x8/64x4 Wdq,Vqq,Ib (66),(ev)</span>
<span class="p_add">+1d: vcvtps2ph Wx,Vx,Ib (66),(v)</span>
<span class="p_add">+1e: vpcmpud/q Vk,Hd,Wd,Ib (66),(ev)</span>
<span class="p_add">+1f: vpcmpd/q Vk,Hd,Wd,Ib (66),(ev)</span>
<span class="p_add">+20: vpinsrb Vdq,Hdq,Ry/Mb,Ib (66),(v1)</span>
<span class="p_add">+21: vinsertps Vdq,Hdq,Udq/Md,Ib (66),(v1)</span>
<span class="p_add">+22: vpinsrd/q Vdq,Hdq,Ey,Ib (66),(v1)</span>
<span class="p_add">+23: vshuff32x4/64x2 Vx,Hx,Wx,Ib (66),(ev)</span>
<span class="p_add">+25: vpternlogd/q Vx,Hx,Wx,Ib (66),(ev)</span>
<span class="p_add">+26: vgetmantps/d Vx,Wx,Ib (66),(ev)</span>
<span class="p_add">+27: vgetmantss/d Vx,Hx,Wx,Ib (66),(ev)</span>
<span class="p_add">+30: kshiftrb/w Vk,Uk,Ib (66),(v)</span>
<span class="p_add">+31: kshiftrd/q Vk,Uk,Ib (66),(v)</span>
<span class="p_add">+32: kshiftlb/w Vk,Uk,Ib (66),(v)</span>
<span class="p_add">+33: kshiftld/q Vk,Uk,Ib (66),(v)</span>
<span class="p_add">+38: vinserti128 Vqq,Hqq,Wqq,Ib (66),(v) | vinserti32x4/64x2 Vqq,Hqq,Wqq,Ib (66),(evo)</span>
<span class="p_add">+39: vextracti128 Wdq,Vqq,Ib (66),(v) | vextracti32x4/64x2 Wdq,Vqq,Ib (66),(evo)</span>
<span class="p_add">+3a: vinserti32x8/64x4 Vqq,Hqq,Wqq,Ib (66),(ev)</span>
<span class="p_add">+3b: vextracti32x8/64x4 Wdq,Vqq,Ib (66),(ev)</span>
<span class="p_add">+3e: vpcmpub/w Vk,Hk,Wx,Ib (66),(ev)</span>
<span class="p_add">+3f: vpcmpb/w Vk,Hk,Wx,Ib (66),(ev)</span>
<span class="p_add">+40: vdpps Vx,Hx,Wx,Ib (66)</span>
<span class="p_add">+41: vdppd Vdq,Hdq,Wdq,Ib (66),(v1)</span>
<span class="p_add">+42: vmpsadbw Vx,Hx,Wx,Ib (66),(v1) | vdbpsadbw Vx,Hx,Wx,Ib (66),(evo)</span>
<span class="p_add">+43: vshufi32x4/64x2 Vx,Hx,Wx,Ib (66),(ev)</span>
<span class="p_add">+44: vpclmulqdq Vdq,Hdq,Wdq,Ib (66),(v1)</span>
<span class="p_add">+46: vperm2i128 Vqq,Hqq,Wqq,Ib (66),(v)</span>
<span class="p_add">+4a: vblendvps Vx,Hx,Wx,Lx (66),(v)</span>
<span class="p_add">+4b: vblendvpd Vx,Hx,Wx,Lx (66),(v)</span>
<span class="p_add">+4c: vpblendvb Vx,Hx,Wx,Lx (66),(v1)</span>
<span class="p_add">+50: vrangeps/d Vx,Hx,Wx,Ib (66),(ev)</span>
<span class="p_add">+51: vrangess/d Vx,Hx,Wx,Ib (66),(ev)</span>
<span class="p_add">+54: vfixupimmps/d Vx,Hx,Wx,Ib (66),(ev)</span>
<span class="p_add">+55: vfixupimmss/d Vx,Hx,Wx,Ib (66),(ev)</span>
<span class="p_add">+56: vreduceps/d Vx,Wx,Ib (66),(ev)</span>
<span class="p_add">+57: vreducess/d Vx,Hx,Wx,Ib (66),(ev)</span>
<span class="p_add">+60: vpcmpestrm Vdq,Wdq,Ib (66),(v1)</span>
<span class="p_add">+61: vpcmpestri Vdq,Wdq,Ib (66),(v1)</span>
<span class="p_add">+62: vpcmpistrm Vdq,Wdq,Ib (66),(v1)</span>
<span class="p_add">+63: vpcmpistri Vdq,Wdq,Ib (66),(v1)</span>
<span class="p_add">+66: vfpclassps/d Vk,Wx,Ib (66),(ev)</span>
<span class="p_add">+67: vfpclassss/d Vk,Wx,Ib (66),(ev)</span>
<span class="p_add">+cc: sha1rnds4 Vdq,Wdq,Ib</span>
<span class="p_add">+df: VAESKEYGEN Vdq,Wdq,Ib (66),(v1)</span>
<span class="p_add">+f0: RORX Gy,Ey,Ib (F2),(v)</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: Grp1</span>
<span class="p_add">+0: ADD</span>
<span class="p_add">+1: OR</span>
<span class="p_add">+2: ADC</span>
<span class="p_add">+3: SBB</span>
<span class="p_add">+4: AND</span>
<span class="p_add">+5: SUB</span>
<span class="p_add">+6: XOR</span>
<span class="p_add">+7: CMP</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: Grp1A</span>
<span class="p_add">+0: POP</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: Grp2</span>
<span class="p_add">+0: ROL</span>
<span class="p_add">+1: ROR</span>
<span class="p_add">+2: RCL</span>
<span class="p_add">+3: RCR</span>
<span class="p_add">+4: SHL/SAL</span>
<span class="p_add">+5: SHR</span>
<span class="p_add">+6:</span>
<span class="p_add">+7: SAR</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: Grp3_1</span>
<span class="p_add">+0: TEST Eb,Ib</span>
<span class="p_add">+1: TEST Eb,Ib</span>
<span class="p_add">+2: NOT Eb</span>
<span class="p_add">+3: NEG Eb</span>
<span class="p_add">+4: MUL AL,Eb</span>
<span class="p_add">+5: IMUL AL,Eb</span>
<span class="p_add">+6: DIV AL,Eb</span>
<span class="p_add">+7: IDIV AL,Eb</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: Grp3_2</span>
<span class="p_add">+0: TEST Ev,Iz</span>
<span class="p_add">+1:</span>
<span class="p_add">+2: NOT Ev</span>
<span class="p_add">+3: NEG Ev</span>
<span class="p_add">+4: MUL rAX,Ev</span>
<span class="p_add">+5: IMUL rAX,Ev</span>
<span class="p_add">+6: DIV rAX,Ev</span>
<span class="p_add">+7: IDIV rAX,Ev</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: Grp4</span>
<span class="p_add">+0: INC Eb</span>
<span class="p_add">+1: DEC Eb</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: Grp5</span>
<span class="p_add">+0: INC Ev</span>
<span class="p_add">+1: DEC Ev</span>
<span class="p_add">+# Note: &quot;forced64&quot; is Intel CPU behavior (see comment about CALL insn).</span>
<span class="p_add">+2: CALLN Ev (f64)</span>
<span class="p_add">+3: CALLF Ep</span>
<span class="p_add">+4: JMPN Ev (f64)</span>
<span class="p_add">+5: JMPF Mp</span>
<span class="p_add">+6: PUSH Ev (d64)</span>
<span class="p_add">+7:</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: Grp6</span>
<span class="p_add">+0: SLDT Rv/Mw</span>
<span class="p_add">+1: STR Rv/Mw</span>
<span class="p_add">+2: LLDT Ew</span>
<span class="p_add">+3: LTR Ew</span>
<span class="p_add">+4: VERR Ew</span>
<span class="p_add">+5: VERW Ew</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: Grp7</span>
<span class="p_add">+0: SGDT Ms | VMCALL (001),(11B) | VMLAUNCH (010),(11B) | VMRESUME (011),(11B) | VMXOFF (100),(11B)</span>
<span class="p_add">+1: SIDT Ms | MONITOR (000),(11B) | MWAIT (001),(11B) | CLAC (010),(11B) | STAC (011),(11B)</span>
<span class="p_add">+2: LGDT Ms | XGETBV (000),(11B) | XSETBV (001),(11B) | VMFUNC (100),(11B) | XEND (101)(11B) | XTEST (110)(11B)</span>
<span class="p_add">+3: LIDT Ms</span>
<span class="p_add">+4: SMSW Mw/Rv</span>
<span class="p_add">+5: rdpkru (110),(11B) | wrpkru (111),(11B)</span>
<span class="p_add">+6: LMSW Ew</span>
<span class="p_add">+7: INVLPG Mb | SWAPGS (o64),(000),(11B) | RDTSCP (001),(11B)</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: Grp8</span>
<span class="p_add">+4: BT</span>
<span class="p_add">+5: BTS</span>
<span class="p_add">+6: BTR</span>
<span class="p_add">+7: BTC</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: Grp9</span>
<span class="p_add">+1: CMPXCHG8B/16B Mq/Mdq</span>
<span class="p_add">+3: xrstors</span>
<span class="p_add">+4: xsavec</span>
<span class="p_add">+5: xsaves</span>
<span class="p_add">+6: VMPTRLD Mq | VMCLEAR Mq (66) | VMXON Mq (F3) | RDRAND Rv (11B)</span>
<span class="p_add">+7: VMPTRST Mq | VMPTRST Mq (F3) | RDSEED Rv (11B)</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: Grp10</span>
<span class="p_add">+# all are UD1</span>
<span class="p_add">+0: UD1</span>
<span class="p_add">+1: UD1</span>
<span class="p_add">+2: UD1</span>
<span class="p_add">+3: UD1</span>
<span class="p_add">+4: UD1</span>
<span class="p_add">+5: UD1</span>
<span class="p_add">+6: UD1</span>
<span class="p_add">+7: UD1</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+# Grp11A and Grp11B are expressed as Grp11 in Intel SDM</span>
<span class="p_add">+GrpTable: Grp11A</span>
<span class="p_add">+0: MOV Eb,Ib</span>
<span class="p_add">+7: XABORT Ib (000),(11B)</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: Grp11B</span>
<span class="p_add">+0: MOV Eb,Iz</span>
<span class="p_add">+7: XBEGIN Jz (000),(11B)</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: Grp12</span>
<span class="p_add">+2: psrlw Nq,Ib (11B) | vpsrlw Hx,Ux,Ib (66),(11B),(v1)</span>
<span class="p_add">+4: psraw Nq,Ib (11B) | vpsraw Hx,Ux,Ib (66),(11B),(v1)</span>
<span class="p_add">+6: psllw Nq,Ib (11B) | vpsllw Hx,Ux,Ib (66),(11B),(v1)</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: Grp13</span>
<span class="p_add">+0: vprord/q Hx,Wx,Ib (66),(ev)</span>
<span class="p_add">+1: vprold/q Hx,Wx,Ib (66),(ev)</span>
<span class="p_add">+2: psrld Nq,Ib (11B) | vpsrld Hx,Ux,Ib (66),(11B),(v1)</span>
<span class="p_add">+4: psrad Nq,Ib (11B) | vpsrad Hx,Ux,Ib (66),(11B),(v1) | vpsrad/q Hx,Ux,Ib (66),(evo)</span>
<span class="p_add">+6: pslld Nq,Ib (11B) | vpslld Hx,Ux,Ib (66),(11B),(v1)</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: Grp14</span>
<span class="p_add">+2: psrlq Nq,Ib (11B) | vpsrlq Hx,Ux,Ib (66),(11B),(v1)</span>
<span class="p_add">+3: vpsrldq Hx,Ux,Ib (66),(11B),(v1)</span>
<span class="p_add">+6: psllq Nq,Ib (11B) | vpsllq Hx,Ux,Ib (66),(11B),(v1)</span>
<span class="p_add">+7: vpslldq Hx,Ux,Ib (66),(11B),(v1)</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: Grp15</span>
<span class="p_add">+0: fxsave | RDFSBASE Ry (F3),(11B)</span>
<span class="p_add">+1: fxstor | RDGSBASE Ry (F3),(11B)</span>
<span class="p_add">+2: vldmxcsr Md (v1) | WRFSBASE Ry (F3),(11B)</span>
<span class="p_add">+3: vstmxcsr Md (v1) | WRGSBASE Ry (F3),(11B)</span>
<span class="p_add">+4: XSAVE | ptwrite Ey (F3),(11B)</span>
<span class="p_add">+5: XRSTOR | lfence (11B)</span>
<span class="p_add">+6: XSAVEOPT | clwb (66) | mfence (11B)</span>
<span class="p_add">+7: clflush | clflushopt (66) | sfence (11B)</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: Grp16</span>
<span class="p_add">+0: prefetch NTA</span>
<span class="p_add">+1: prefetch T0</span>
<span class="p_add">+2: prefetch T1</span>
<span class="p_add">+3: prefetch T2</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: Grp17</span>
<span class="p_add">+1: BLSR By,Ey (v)</span>
<span class="p_add">+2: BLSMSK By,Ey (v)</span>
<span class="p_add">+3: BLSI By,Ey (v)</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: Grp18</span>
<span class="p_add">+1: vgatherpf0dps/d Wx (66),(ev)</span>
<span class="p_add">+2: vgatherpf1dps/d Wx (66),(ev)</span>
<span class="p_add">+5: vscatterpf0dps/d Wx (66),(ev)</span>
<span class="p_add">+6: vscatterpf1dps/d Wx (66),(ev)</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: Grp19</span>
<span class="p_add">+1: vgatherpf0qps/d Wx (66),(ev)</span>
<span class="p_add">+2: vgatherpf1qps/d Wx (66),(ev)</span>
<span class="p_add">+5: vscatterpf0qps/d Wx (66),(ev)</span>
<span class="p_add">+6: vscatterpf1qps/d Wx (66),(ev)</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+# AMD&#39;s Prefetch Group</span>
<span class="p_add">+GrpTable: GrpP</span>
<span class="p_add">+0: PREFETCH</span>
<span class="p_add">+1: PREFETCHW</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: GrpPDLK</span>
<span class="p_add">+0: MONTMUL</span>
<span class="p_add">+1: XSHA1</span>
<span class="p_add">+2: XSHA2</span>
<span class="p_add">+EndTable</span>
<span class="p_add">+</span>
<span class="p_add">+GrpTable: GrpRNG</span>
<span class="p_add">+0: xstore-rng</span>
<span class="p_add">+1: xcrypt-ecb</span>
<span class="p_add">+2: xcrypt-cbc</span>
<span class="p_add">+4: xcrypt-cfb</span>
<span class="p_add">+5: xcrypt-ofb</span>
<span class="p_add">+EndTable</span>
<span class="p_header">diff --git a/tools/objtool/arch/x86/tools/gen-insn-attr-x86.awk b/tools/objtool/arch/x86/tools/gen-insn-attr-x86.awk</span>
new file mode 100644
<span class="p_header">index 000000000000..b02a36b2c14f</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/objtool/arch/x86/tools/gen-insn-attr-x86.awk</span>
<span class="p_chunk">@@ -0,0 +1,393 @@</span> <span class="p_context"></span>
<span class="p_add">+#!/bin/awk -f</span>
<span class="p_add">+# SPDX-License-Identifier: GPL-2.0</span>
<span class="p_add">+# gen-insn-attr-x86.awk: Instruction attribute table generator</span>
<span class="p_add">+# Written by Masami Hiramatsu &lt;mhiramat@redhat.com&gt;</span>
<span class="p_add">+#</span>
<span class="p_add">+# Usage: awk -f gen-insn-attr-x86.awk x86-opcode-map.txt &gt; inat-tables.c</span>
<span class="p_add">+</span>
<span class="p_add">+# Awk implementation sanity check</span>
<span class="p_add">+function check_awk_implement() {</span>
<span class="p_add">+	if (sprintf(&quot;%x&quot;, 0) != &quot;0&quot;)</span>
<span class="p_add">+		return &quot;Your awk has a printf-format problem.&quot;</span>
<span class="p_add">+	return &quot;&quot;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+# Clear working vars</span>
<span class="p_add">+function clear_vars() {</span>
<span class="p_add">+	delete table</span>
<span class="p_add">+	delete lptable2</span>
<span class="p_add">+	delete lptable1</span>
<span class="p_add">+	delete lptable3</span>
<span class="p_add">+	eid = -1 # escape id</span>
<span class="p_add">+	gid = -1 # group id</span>
<span class="p_add">+	aid = -1 # AVX id</span>
<span class="p_add">+	tname = &quot;&quot;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+BEGIN {</span>
<span class="p_add">+	# Implementation error checking</span>
<span class="p_add">+	awkchecked = check_awk_implement()</span>
<span class="p_add">+	if (awkchecked != &quot;&quot;) {</span>
<span class="p_add">+		print &quot;Error: &quot; awkchecked &gt; &quot;/dev/stderr&quot;</span>
<span class="p_add">+		print &quot;Please try to use gawk.&quot; &gt; &quot;/dev/stderr&quot;</span>
<span class="p_add">+		exit 1</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	# Setup generating tables</span>
<span class="p_add">+	print &quot;/* x86 opcode map generated from x86-opcode-map.txt */&quot;</span>
<span class="p_add">+	print &quot;/* Do not change this code. */\n&quot;</span>
<span class="p_add">+	ggid = 1</span>
<span class="p_add">+	geid = 1</span>
<span class="p_add">+	gaid = 0</span>
<span class="p_add">+	delete etable</span>
<span class="p_add">+	delete gtable</span>
<span class="p_add">+	delete atable</span>
<span class="p_add">+</span>
<span class="p_add">+	opnd_expr = &quot;^[A-Za-z/]&quot;</span>
<span class="p_add">+	ext_expr = &quot;^\\(&quot;</span>
<span class="p_add">+	sep_expr = &quot;^\\|$&quot;</span>
<span class="p_add">+	group_expr = &quot;^Grp[0-9A-Za-z]+&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+	imm_expr = &quot;^[IJAOL][a-z]&quot;</span>
<span class="p_add">+	imm_flag[&quot;Ib&quot;] = &quot;INAT_MAKE_IMM(INAT_IMM_BYTE)&quot;</span>
<span class="p_add">+	imm_flag[&quot;Jb&quot;] = &quot;INAT_MAKE_IMM(INAT_IMM_BYTE)&quot;</span>
<span class="p_add">+	imm_flag[&quot;Iw&quot;] = &quot;INAT_MAKE_IMM(INAT_IMM_WORD)&quot;</span>
<span class="p_add">+	imm_flag[&quot;Id&quot;] = &quot;INAT_MAKE_IMM(INAT_IMM_DWORD)&quot;</span>
<span class="p_add">+	imm_flag[&quot;Iq&quot;] = &quot;INAT_MAKE_IMM(INAT_IMM_QWORD)&quot;</span>
<span class="p_add">+	imm_flag[&quot;Ap&quot;] = &quot;INAT_MAKE_IMM(INAT_IMM_PTR)&quot;</span>
<span class="p_add">+	imm_flag[&quot;Iz&quot;] = &quot;INAT_MAKE_IMM(INAT_IMM_VWORD32)&quot;</span>
<span class="p_add">+	imm_flag[&quot;Jz&quot;] = &quot;INAT_MAKE_IMM(INAT_IMM_VWORD32)&quot;</span>
<span class="p_add">+	imm_flag[&quot;Iv&quot;] = &quot;INAT_MAKE_IMM(INAT_IMM_VWORD)&quot;</span>
<span class="p_add">+	imm_flag[&quot;Ob&quot;] = &quot;INAT_MOFFSET&quot;</span>
<span class="p_add">+	imm_flag[&quot;Ov&quot;] = &quot;INAT_MOFFSET&quot;</span>
<span class="p_add">+	imm_flag[&quot;Lx&quot;] = &quot;INAT_MAKE_IMM(INAT_IMM_BYTE)&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+	modrm_expr = &quot;^([CDEGMNPQRSUVW/][a-z]+|NTA|T[012])&quot;</span>
<span class="p_add">+	force64_expr = &quot;\\([df]64\\)&quot;</span>
<span class="p_add">+	rex_expr = &quot;^REX(\\.[XRWB]+)*&quot;</span>
<span class="p_add">+	fpu_expr = &quot;^ESC&quot; # TODO</span>
<span class="p_add">+</span>
<span class="p_add">+	lprefix1_expr = &quot;\\((66|!F3)\\)&quot;</span>
<span class="p_add">+	lprefix2_expr = &quot;\\(F3\\)&quot;</span>
<span class="p_add">+	lprefix3_expr = &quot;\\((F2|!F3|66\\&amp;F2)\\)&quot;</span>
<span class="p_add">+	lprefix_expr = &quot;\\((66|F2|F3)\\)&quot;</span>
<span class="p_add">+	max_lprefix = 4</span>
<span class="p_add">+</span>
<span class="p_add">+	# All opcodes starting with lower-case &#39;v&#39;, &#39;k&#39; or with (v1) superscript</span>
<span class="p_add">+	# accepts VEX prefix</span>
<span class="p_add">+	vexok_opcode_expr = &quot;^[vk].*&quot;</span>
<span class="p_add">+	vexok_expr = &quot;\\(v1\\)&quot;</span>
<span class="p_add">+	# All opcodes with (v) superscript supports *only* VEX prefix</span>
<span class="p_add">+	vexonly_expr = &quot;\\(v\\)&quot;</span>
<span class="p_add">+	# All opcodes with (ev) superscript supports *only* EVEX prefix</span>
<span class="p_add">+	evexonly_expr = &quot;\\(ev\\)&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+	prefix_expr = &quot;\\(Prefix\\)&quot;</span>
<span class="p_add">+	prefix_num[&quot;Operand-Size&quot;] = &quot;INAT_PFX_OPNDSZ&quot;</span>
<span class="p_add">+	prefix_num[&quot;REPNE&quot;] = &quot;INAT_PFX_REPNE&quot;</span>
<span class="p_add">+	prefix_num[&quot;REP/REPE&quot;] = &quot;INAT_PFX_REPE&quot;</span>
<span class="p_add">+	prefix_num[&quot;XACQUIRE&quot;] = &quot;INAT_PFX_REPNE&quot;</span>
<span class="p_add">+	prefix_num[&quot;XRELEASE&quot;] = &quot;INAT_PFX_REPE&quot;</span>
<span class="p_add">+	prefix_num[&quot;LOCK&quot;] = &quot;INAT_PFX_LOCK&quot;</span>
<span class="p_add">+	prefix_num[&quot;SEG=CS&quot;] = &quot;INAT_PFX_CS&quot;</span>
<span class="p_add">+	prefix_num[&quot;SEG=DS&quot;] = &quot;INAT_PFX_DS&quot;</span>
<span class="p_add">+	prefix_num[&quot;SEG=ES&quot;] = &quot;INAT_PFX_ES&quot;</span>
<span class="p_add">+	prefix_num[&quot;SEG=FS&quot;] = &quot;INAT_PFX_FS&quot;</span>
<span class="p_add">+	prefix_num[&quot;SEG=GS&quot;] = &quot;INAT_PFX_GS&quot;</span>
<span class="p_add">+	prefix_num[&quot;SEG=SS&quot;] = &quot;INAT_PFX_SS&quot;</span>
<span class="p_add">+	prefix_num[&quot;Address-Size&quot;] = &quot;INAT_PFX_ADDRSZ&quot;</span>
<span class="p_add">+	prefix_num[&quot;VEX+1byte&quot;] = &quot;INAT_PFX_VEX2&quot;</span>
<span class="p_add">+	prefix_num[&quot;VEX+2byte&quot;] = &quot;INAT_PFX_VEX3&quot;</span>
<span class="p_add">+	prefix_num[&quot;EVEX&quot;] = &quot;INAT_PFX_EVEX&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+	clear_vars()</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+function semantic_error(msg) {</span>
<span class="p_add">+	print &quot;Semantic error at &quot; NR &quot;: &quot; msg &gt; &quot;/dev/stderr&quot;</span>
<span class="p_add">+	exit 1</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+function debug(msg) {</span>
<span class="p_add">+	print &quot;DEBUG: &quot; msg</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+function array_size(arr,   i,c) {</span>
<span class="p_add">+	c = 0</span>
<span class="p_add">+	for (i in arr)</span>
<span class="p_add">+		c++</span>
<span class="p_add">+	return c</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/^Table:/ {</span>
<span class="p_add">+	print &quot;/* &quot; $0 &quot; */&quot;</span>
<span class="p_add">+	if (tname != &quot;&quot;)</span>
<span class="p_add">+		semantic_error(&quot;Hit Table: before EndTable:.&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/^Referrer:/ {</span>
<span class="p_add">+	if (NF != 1) {</span>
<span class="p_add">+		# escape opcode table</span>
<span class="p_add">+		ref = &quot;&quot;</span>
<span class="p_add">+		for (i = 2; i &lt;= NF; i++)</span>
<span class="p_add">+			ref = ref $i</span>
<span class="p_add">+		eid = escape[ref]</span>
<span class="p_add">+		tname = sprintf(&quot;inat_escape_table_%d&quot;, eid)</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/^AVXcode:/ {</span>
<span class="p_add">+	if (NF != 1) {</span>
<span class="p_add">+		# AVX/escape opcode table</span>
<span class="p_add">+		aid = $2</span>
<span class="p_add">+		if (gaid &lt;= aid)</span>
<span class="p_add">+			gaid = aid + 1</span>
<span class="p_add">+		if (tname == &quot;&quot;)	# AVX only opcode table</span>
<span class="p_add">+			tname = sprintf(&quot;inat_avx_table_%d&quot;, $2)</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (aid == -1 &amp;&amp; eid == -1)	# primary opcode table</span>
<span class="p_add">+		tname = &quot;inat_primary_table&quot;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/^GrpTable:/ {</span>
<span class="p_add">+	print &quot;/* &quot; $0 &quot; */&quot;</span>
<span class="p_add">+	if (!($2 in group))</span>
<span class="p_add">+		semantic_error(&quot;No group: &quot; $2 )</span>
<span class="p_add">+	gid = group[$2]</span>
<span class="p_add">+	tname = &quot;inat_group_table_&quot; gid</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+function print_table(tbl,name,fmt,n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	print &quot;const insn_attr_t &quot; name &quot; = {&quot;</span>
<span class="p_add">+	for (i = 0; i &lt; n; i++) {</span>
<span class="p_add">+		id = sprintf(fmt, i)</span>
<span class="p_add">+		if (tbl[id])</span>
<span class="p_add">+			print &quot;	[&quot; id &quot;] = &quot; tbl[id] &quot;,&quot;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	print &quot;};&quot;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/^EndTable/ {</span>
<span class="p_add">+	if (gid != -1) {</span>
<span class="p_add">+		# print group tables</span>
<span class="p_add">+		if (array_size(table) != 0) {</span>
<span class="p_add">+			print_table(table, tname &quot;[INAT_GROUP_TABLE_SIZE]&quot;,</span>
<span class="p_add">+				    &quot;0x%x&quot;, 8)</span>
<span class="p_add">+			gtable[gid,0] = tname</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (array_size(lptable1) != 0) {</span>
<span class="p_add">+			print_table(lptable1, tname &quot;_1[INAT_GROUP_TABLE_SIZE]&quot;,</span>
<span class="p_add">+				    &quot;0x%x&quot;, 8)</span>
<span class="p_add">+			gtable[gid,1] = tname &quot;_1&quot;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (array_size(lptable2) != 0) {</span>
<span class="p_add">+			print_table(lptable2, tname &quot;_2[INAT_GROUP_TABLE_SIZE]&quot;,</span>
<span class="p_add">+				    &quot;0x%x&quot;, 8)</span>
<span class="p_add">+			gtable[gid,2] = tname &quot;_2&quot;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (array_size(lptable3) != 0) {</span>
<span class="p_add">+			print_table(lptable3, tname &quot;_3[INAT_GROUP_TABLE_SIZE]&quot;,</span>
<span class="p_add">+				    &quot;0x%x&quot;, 8)</span>
<span class="p_add">+			gtable[gid,3] = tname &quot;_3&quot;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		# print primary/escaped tables</span>
<span class="p_add">+		if (array_size(table) != 0) {</span>
<span class="p_add">+			print_table(table, tname &quot;[INAT_OPCODE_TABLE_SIZE]&quot;,</span>
<span class="p_add">+				    &quot;0x%02x&quot;, 256)</span>
<span class="p_add">+			etable[eid,0] = tname</span>
<span class="p_add">+			if (aid &gt;= 0)</span>
<span class="p_add">+				atable[aid,0] = tname</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (array_size(lptable1) != 0) {</span>
<span class="p_add">+			print_table(lptable1,tname &quot;_1[INAT_OPCODE_TABLE_SIZE]&quot;,</span>
<span class="p_add">+				    &quot;0x%02x&quot;, 256)</span>
<span class="p_add">+			etable[eid,1] = tname &quot;_1&quot;</span>
<span class="p_add">+			if (aid &gt;= 0)</span>
<span class="p_add">+				atable[aid,1] = tname &quot;_1&quot;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (array_size(lptable2) != 0) {</span>
<span class="p_add">+			print_table(lptable2,tname &quot;_2[INAT_OPCODE_TABLE_SIZE]&quot;,</span>
<span class="p_add">+				    &quot;0x%02x&quot;, 256)</span>
<span class="p_add">+			etable[eid,2] = tname &quot;_2&quot;</span>
<span class="p_add">+			if (aid &gt;= 0)</span>
<span class="p_add">+				atable[aid,2] = tname &quot;_2&quot;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (array_size(lptable3) != 0) {</span>
<span class="p_add">+			print_table(lptable3,tname &quot;_3[INAT_OPCODE_TABLE_SIZE]&quot;,</span>
<span class="p_add">+				    &quot;0x%02x&quot;, 256)</span>
<span class="p_add">+			etable[eid,3] = tname &quot;_3&quot;</span>
<span class="p_add">+			if (aid &gt;= 0)</span>
<span class="p_add">+				atable[aid,3] = tname &quot;_3&quot;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	print &quot;&quot;</span>
<span class="p_add">+	clear_vars()</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+function add_flags(old,new) {</span>
<span class="p_add">+	if (old &amp;&amp; new)</span>
<span class="p_add">+		return old &quot; | &quot; new</span>
<span class="p_add">+	else if (old)</span>
<span class="p_add">+		return old</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return new</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+# convert operands to flags.</span>
<span class="p_add">+function convert_operands(count,opnd,       i,j,imm,mod)</span>
<span class="p_add">+{</span>
<span class="p_add">+	imm = null</span>
<span class="p_add">+	mod = null</span>
<span class="p_add">+	for (j = 1; j &lt;= count; j++) {</span>
<span class="p_add">+		i = opnd[j]</span>
<span class="p_add">+		if (match(i, imm_expr) == 1) {</span>
<span class="p_add">+			if (!imm_flag[i])</span>
<span class="p_add">+				semantic_error(&quot;Unknown imm opnd: &quot; i)</span>
<span class="p_add">+			if (imm) {</span>
<span class="p_add">+				if (i != &quot;Ib&quot;)</span>
<span class="p_add">+					semantic_error(&quot;Second IMM error&quot;)</span>
<span class="p_add">+				imm = add_flags(imm, &quot;INAT_SCNDIMM&quot;)</span>
<span class="p_add">+			} else</span>
<span class="p_add">+				imm = imm_flag[i]</span>
<span class="p_add">+		} else if (match(i, modrm_expr))</span>
<span class="p_add">+			mod = &quot;INAT_MODRM&quot;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return add_flags(imm, mod)</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/^[0-9a-f]+\:/ {</span>
<span class="p_add">+	if (NR == 1)</span>
<span class="p_add">+		next</span>
<span class="p_add">+	# get index</span>
<span class="p_add">+	idx = &quot;0x&quot; substr($1, 1, index($1,&quot;:&quot;) - 1)</span>
<span class="p_add">+	if (idx in table)</span>
<span class="p_add">+		semantic_error(&quot;Redefine &quot; idx &quot; in &quot; tname)</span>
<span class="p_add">+</span>
<span class="p_add">+	# check if escaped opcode</span>
<span class="p_add">+	if (&quot;escape&quot; == $2) {</span>
<span class="p_add">+		if ($3 != &quot;#&quot;)</span>
<span class="p_add">+			semantic_error(&quot;No escaped name&quot;)</span>
<span class="p_add">+		ref = &quot;&quot;</span>
<span class="p_add">+		for (i = 4; i &lt;= NF; i++)</span>
<span class="p_add">+			ref = ref $i</span>
<span class="p_add">+		if (ref in escape)</span>
<span class="p_add">+			semantic_error(&quot;Redefine escape (&quot; ref &quot;)&quot;)</span>
<span class="p_add">+		escape[ref] = geid</span>
<span class="p_add">+		geid++</span>
<span class="p_add">+		table[idx] = &quot;INAT_MAKE_ESCAPE(&quot; escape[ref] &quot;)&quot;</span>
<span class="p_add">+		next</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	variant = null</span>
<span class="p_add">+	# converts</span>
<span class="p_add">+	i = 2</span>
<span class="p_add">+	while (i &lt;= NF) {</span>
<span class="p_add">+		opcode = $(i++)</span>
<span class="p_add">+		delete opnds</span>
<span class="p_add">+		ext = null</span>
<span class="p_add">+		flags = null</span>
<span class="p_add">+		opnd = null</span>
<span class="p_add">+		# parse one opcode</span>
<span class="p_add">+		if (match($i, opnd_expr)) {</span>
<span class="p_add">+			opnd = $i</span>
<span class="p_add">+			count = split($(i++), opnds, &quot;,&quot;)</span>
<span class="p_add">+			flags = convert_operands(count, opnds)</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (match($i, ext_expr))</span>
<span class="p_add">+			ext = $(i++)</span>
<span class="p_add">+		if (match($i, sep_expr))</span>
<span class="p_add">+			i++</span>
<span class="p_add">+		else if (i &lt; NF)</span>
<span class="p_add">+			semantic_error($i &quot; is not a separator&quot;)</span>
<span class="p_add">+</span>
<span class="p_add">+		# check if group opcode</span>
<span class="p_add">+		if (match(opcode, group_expr)) {</span>
<span class="p_add">+			if (!(opcode in group)) {</span>
<span class="p_add">+				group[opcode] = ggid</span>
<span class="p_add">+				ggid++</span>
<span class="p_add">+			}</span>
<span class="p_add">+			flags = add_flags(flags, &quot;INAT_MAKE_GROUP(&quot; group[opcode] &quot;)&quot;)</span>
<span class="p_add">+		}</span>
<span class="p_add">+		# check force(or default) 64bit</span>
<span class="p_add">+		if (match(ext, force64_expr))</span>
<span class="p_add">+			flags = add_flags(flags, &quot;INAT_FORCE64&quot;)</span>
<span class="p_add">+</span>
<span class="p_add">+		# check REX prefix</span>
<span class="p_add">+		if (match(opcode, rex_expr))</span>
<span class="p_add">+			flags = add_flags(flags, &quot;INAT_MAKE_PREFIX(INAT_PFX_REX)&quot;)</span>
<span class="p_add">+</span>
<span class="p_add">+		# check coprocessor escape : TODO</span>
<span class="p_add">+		if (match(opcode, fpu_expr))</span>
<span class="p_add">+			flags = add_flags(flags, &quot;INAT_MODRM&quot;)</span>
<span class="p_add">+</span>
<span class="p_add">+		# check VEX codes</span>
<span class="p_add">+		if (match(ext, evexonly_expr))</span>
<span class="p_add">+			flags = add_flags(flags, &quot;INAT_VEXOK | INAT_EVEXONLY&quot;)</span>
<span class="p_add">+		else if (match(ext, vexonly_expr))</span>
<span class="p_add">+			flags = add_flags(flags, &quot;INAT_VEXOK | INAT_VEXONLY&quot;)</span>
<span class="p_add">+		else if (match(ext, vexok_expr) || match(opcode, vexok_opcode_expr))</span>
<span class="p_add">+			flags = add_flags(flags, &quot;INAT_VEXOK&quot;)</span>
<span class="p_add">+</span>
<span class="p_add">+		# check prefixes</span>
<span class="p_add">+		if (match(ext, prefix_expr)) {</span>
<span class="p_add">+			if (!prefix_num[opcode])</span>
<span class="p_add">+				semantic_error(&quot;Unknown prefix: &quot; opcode)</span>
<span class="p_add">+			flags = add_flags(flags, &quot;INAT_MAKE_PREFIX(&quot; prefix_num[opcode] &quot;)&quot;)</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (length(flags) == 0)</span>
<span class="p_add">+			continue</span>
<span class="p_add">+		# check if last prefix</span>
<span class="p_add">+		if (match(ext, lprefix1_expr)) {</span>
<span class="p_add">+			lptable1[idx] = add_flags(lptable1[idx],flags)</span>
<span class="p_add">+			variant = &quot;INAT_VARIANT&quot;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (match(ext, lprefix2_expr)) {</span>
<span class="p_add">+			lptable2[idx] = add_flags(lptable2[idx],flags)</span>
<span class="p_add">+			variant = &quot;INAT_VARIANT&quot;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (match(ext, lprefix3_expr)) {</span>
<span class="p_add">+			lptable3[idx] = add_flags(lptable3[idx],flags)</span>
<span class="p_add">+			variant = &quot;INAT_VARIANT&quot;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (!match(ext, lprefix_expr)){</span>
<span class="p_add">+			table[idx] = add_flags(table[idx],flags)</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (variant)</span>
<span class="p_add">+		table[idx] = add_flags(table[idx],variant)</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+END {</span>
<span class="p_add">+	if (awkchecked != &quot;&quot;)</span>
<span class="p_add">+		exit 1</span>
<span class="p_add">+	# print escape opcode map&#39;s array</span>
<span class="p_add">+	print &quot;/* Escape opcode map array */&quot;</span>
<span class="p_add">+	print &quot;const insn_attr_t * const inat_escape_tables[INAT_ESC_MAX + 1]&quot; \</span>
<span class="p_add">+	      &quot;[INAT_LSTPFX_MAX + 1] = {&quot;</span>
<span class="p_add">+	for (i = 0; i &lt; geid; i++)</span>
<span class="p_add">+		for (j = 0; j &lt; max_lprefix; j++)</span>
<span class="p_add">+			if (etable[i,j])</span>
<span class="p_add">+				print &quot;	[&quot;i&quot;][&quot;j&quot;] = &quot;etable[i,j]&quot;,&quot;</span>
<span class="p_add">+	print &quot;};\n&quot;</span>
<span class="p_add">+	# print group opcode map&#39;s array</span>
<span class="p_add">+	print &quot;/* Group opcode map array */&quot;</span>
<span class="p_add">+	print &quot;const insn_attr_t * const inat_group_tables[INAT_GRP_MAX + 1]&quot;\</span>
<span class="p_add">+	      &quot;[INAT_LSTPFX_MAX + 1] = {&quot;</span>
<span class="p_add">+	for (i = 0; i &lt; ggid; i++)</span>
<span class="p_add">+		for (j = 0; j &lt; max_lprefix; j++)</span>
<span class="p_add">+			if (gtable[i,j])</span>
<span class="p_add">+				print &quot;	[&quot;i&quot;][&quot;j&quot;] = &quot;gtable[i,j]&quot;,&quot;</span>
<span class="p_add">+	print &quot;};\n&quot;</span>
<span class="p_add">+	# print AVX opcode map&#39;s array</span>
<span class="p_add">+	print &quot;/* AVX opcode map array */&quot;</span>
<span class="p_add">+	print &quot;const insn_attr_t * const inat_avx_tables[X86_VEX_M_MAX + 1]&quot;\</span>
<span class="p_add">+	      &quot;[INAT_LSTPFX_MAX + 1] = {&quot;</span>
<span class="p_add">+	for (i = 0; i &lt; gaid; i++)</span>
<span class="p_add">+		for (j = 0; j &lt; max_lprefix; j++)</span>
<span class="p_add">+			if (atable[i,j])</span>
<span class="p_add">+				print &quot;	[&quot;i&quot;][&quot;j&quot;] = &quot;atable[i,j]&quot;,&quot;</span>
<span class="p_add">+	print &quot;};&quot;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_header">diff --git a/tools/objtool/orc.h b/tools/objtool/orc.h</span>
<span class="p_header">index a4139e386ef3..b0e92a6d0903 100644</span>
<span class="p_header">--- a/tools/objtool/orc.h</span>
<span class="p_header">+++ b/tools/objtool/orc.h</span>
<span class="p_chunk">@@ -18,7 +18,7 @@</span> <span class="p_context"></span>
 #ifndef _ORC_H
 #define _ORC_H
 
<span class="p_del">-#include &quot;orc_types.h&quot;</span>
<span class="p_add">+#include &lt;asm/orc_types.h&gt;</span>
 
 struct objtool_file;
 
<span class="p_header">diff --git a/tools/objtool/orc_dump.c b/tools/objtool/orc_dump.c</span>
<span class="p_header">index 36c5bf6a2675..c3343820916a 100644</span>
<span class="p_header">--- a/tools/objtool/orc_dump.c</span>
<span class="p_header">+++ b/tools/objtool/orc_dump.c</span>
<span class="p_chunk">@@ -76,7 +76,8 @@</span> <span class="p_context"> int orc_dump(const char *_objname)</span>
 	int fd, nr_entries, i, *orc_ip = NULL, orc_size = 0;
 	struct orc_entry *orc = NULL;
 	char *name;
<span class="p_del">-	unsigned long nr_sections, orc_ip_addr = 0;</span>
<span class="p_add">+	size_t nr_sections;</span>
<span class="p_add">+	Elf64_Addr orc_ip_addr = 0;</span>
 	size_t shstrtab_idx;
 	Elf *elf;
 	Elf_Scn *scn;
<span class="p_chunk">@@ -187,10 +188,10 @@</span> <span class="p_context"> int orc_dump(const char *_objname)</span>
 				return -1;
 			}
 
<span class="p_del">-			printf(&quot;%s+%lx:&quot;, name, rela.r_addend);</span>
<span class="p_add">+			printf(&quot;%s+%llx:&quot;, name, (unsigned long long)rela.r_addend);</span>
 
 		} else {
<span class="p_del">-			printf(&quot;%lx:&quot;, orc_ip_addr + (i * sizeof(int)) + orc_ip[i]);</span>
<span class="p_add">+			printf(&quot;%llx:&quot;, (unsigned long long)(orc_ip_addr + (i * sizeof(int)) + orc_ip[i]));</span>
 		}
 
 
<span class="p_header">diff --git a/tools/objtool/orc_types.h b/tools/objtool/orc_types.h</span>
deleted file mode 100644
<span class="p_header">index 9c9dc579bd7d..000000000000</span>
<span class="p_header">--- a/tools/objtool/orc_types.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,107 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- * Copyright (C) 2017 Josh Poimboeuf &lt;jpoimboe@redhat.com&gt;</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is free software; you can redistribute it and/or</span>
<span class="p_del">- * modify it under the terms of the GNU General Public License</span>
<span class="p_del">- * as published by the Free Software Foundation; either version 2</span>
<span class="p_del">- * of the License, or (at your option) any later version.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is distributed in the hope that it will be useful,</span>
<span class="p_del">- * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_del">- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_del">- * GNU General Public License for more details.</span>
<span class="p_del">- *</span>
<span class="p_del">- * You should have received a copy of the GNU General Public License</span>
<span class="p_del">- * along with this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-#ifndef _ORC_TYPES_H</span>
<span class="p_del">-#define _ORC_TYPES_H</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;linux/types.h&gt;</span>
<span class="p_del">-#include &lt;linux/compiler.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * The ORC_REG_* registers are base registers which are used to find other</span>
<span class="p_del">- * registers on the stack.</span>
<span class="p_del">- *</span>
<span class="p_del">- * ORC_REG_PREV_SP, also known as DWARF Call Frame Address (CFA), is the</span>
<span class="p_del">- * address of the previous frame: the caller&#39;s SP before it called the current</span>
<span class="p_del">- * function.</span>
<span class="p_del">- *</span>
<span class="p_del">- * ORC_REG_UNDEFINED means the corresponding register&#39;s value didn&#39;t change in</span>
<span class="p_del">- * the current frame.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The most commonly used base registers are SP and BP -- which the previous SP</span>
<span class="p_del">- * is usually based on -- and PREV_SP and UNDEFINED -- which the previous BP is</span>
<span class="p_del">- * usually based on.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The rest of the base registers are needed for special cases like entry code</span>
<span class="p_del">- * and GCC realigned stacks.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define ORC_REG_UNDEFINED		0</span>
<span class="p_del">-#define ORC_REG_PREV_SP			1</span>
<span class="p_del">-#define ORC_REG_DX			2</span>
<span class="p_del">-#define ORC_REG_DI			3</span>
<span class="p_del">-#define ORC_REG_BP			4</span>
<span class="p_del">-#define ORC_REG_SP			5</span>
<span class="p_del">-#define ORC_REG_R10			6</span>
<span class="p_del">-#define ORC_REG_R13			7</span>
<span class="p_del">-#define ORC_REG_BP_INDIRECT		8</span>
<span class="p_del">-#define ORC_REG_SP_INDIRECT		9</span>
<span class="p_del">-#define ORC_REG_MAX			15</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * ORC_TYPE_CALL: Indicates that sp_reg+sp_offset resolves to PREV_SP (the</span>
<span class="p_del">- * caller&#39;s SP right before it made the call).  Used for all callable</span>
<span class="p_del">- * functions, i.e. all C code and all callable asm functions.</span>
<span class="p_del">- *</span>
<span class="p_del">- * ORC_TYPE_REGS: Used in entry code to indicate that sp_reg+sp_offset points</span>
<span class="p_del">- * to a fully populated pt_regs from a syscall, interrupt, or exception.</span>
<span class="p_del">- *</span>
<span class="p_del">- * ORC_TYPE_REGS_IRET: Used in entry code to indicate that sp_reg+sp_offset</span>
<span class="p_del">- * points to the iret return frame.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The UNWIND_HINT macros are used only for the unwind_hint struct.  They</span>
<span class="p_del">- * aren&#39;t used in struct orc_entry due to size and complexity constraints.</span>
<span class="p_del">- * Objtool converts them to real types when it converts the hints to orc</span>
<span class="p_del">- * entries.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define ORC_TYPE_CALL			0</span>
<span class="p_del">-#define ORC_TYPE_REGS			1</span>
<span class="p_del">-#define ORC_TYPE_REGS_IRET		2</span>
<span class="p_del">-#define UNWIND_HINT_TYPE_SAVE		3</span>
<span class="p_del">-#define UNWIND_HINT_TYPE_RESTORE	4</span>
<span class="p_del">-</span>
<span class="p_del">-#ifndef __ASSEMBLY__</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This struct is more or less a vastly simplified version of the DWARF Call</span>
<span class="p_del">- * Frame Information standard.  It contains only the necessary parts of DWARF</span>
<span class="p_del">- * CFI, simplified for ease of access by the in-kernel unwinder.  It tells the</span>
<span class="p_del">- * unwinder how to find the previous SP and BP (and sometimes entry regs) on</span>
<span class="p_del">- * the stack for a given code address.  Each instance of the struct corresponds</span>
<span class="p_del">- * to one or more code locations.</span>
<span class="p_del">- */</span>
<span class="p_del">-struct orc_entry {</span>
<span class="p_del">-	s16		sp_offset;</span>
<span class="p_del">-	s16		bp_offset;</span>
<span class="p_del">-	unsigned	sp_reg:4;</span>
<span class="p_del">-	unsigned	bp_reg:4;</span>
<span class="p_del">-	unsigned	type:2;</span>
<span class="p_del">-} __packed;</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This struct is used by asm and inline asm code to manually annotate the</span>
<span class="p_del">- * location of registers on the stack for the ORC unwinder.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Type can be either ORC_TYPE_* or UNWIND_HINT_TYPE_*.</span>
<span class="p_del">- */</span>
<span class="p_del">-struct unwind_hint {</span>
<span class="p_del">-	u32		ip;</span>
<span class="p_del">-	s16		sp_offset;</span>
<span class="p_del">-	u8		sp_reg;</span>
<span class="p_del">-	u8		type;</span>
<span class="p_del">-};</span>
<span class="p_del">-#endif /* __ASSEMBLY__ */</span>
<span class="p_del">-</span>
<span class="p_del">-#endif /* _ORC_TYPES_H */</span>
<span class="p_header">diff --git a/tools/objtool/sync-check.sh b/tools/objtool/sync-check.sh</span>
new file mode 100755
<span class="p_header">index 000000000000..1470e74e9d66</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/objtool/sync-check.sh</span>
<span class="p_chunk">@@ -0,0 +1,29 @@</span> <span class="p_context"></span>
<span class="p_add">+#!/bin/sh</span>
<span class="p_add">+# SPDX-License-Identifier: GPL-2.0</span>
<span class="p_add">+</span>
<span class="p_add">+FILES=&#39;</span>
<span class="p_add">+arch/x86/lib/insn.c</span>
<span class="p_add">+arch/x86/lib/inat.c</span>
<span class="p_add">+arch/x86/lib/x86-opcode-map.txt</span>
<span class="p_add">+arch/x86/tools/gen-insn-attr-x86.awk</span>
<span class="p_add">+arch/x86/include/asm/insn.h</span>
<span class="p_add">+arch/x86/include/asm/inat.h</span>
<span class="p_add">+arch/x86/include/asm/inat_types.h</span>
<span class="p_add">+arch/x86/include/asm/orc_types.h</span>
<span class="p_add">+&#39;</span>
<span class="p_add">+</span>
<span class="p_add">+check()</span>
<span class="p_add">+{</span>
<span class="p_add">+	local file=$1</span>
<span class="p_add">+</span>
<span class="p_add">+	diff $file ../../$file &gt; /dev/null ||</span>
<span class="p_add">+		echo &quot;Warning: synced file at &#39;tools/objtool/$file&#39; differs from latest kernel version at &#39;$file&#39;&quot;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+if [ ! -d ../../kernel ] || [ ! -d ../../tools ] || [ ! -d ../objtool ]; then</span>
<span class="p_add">+	exit 0</span>
<span class="p_add">+fi</span>
<span class="p_add">+</span>
<span class="p_add">+for i in $FILES; do</span>
<span class="p_add">+  check $i</span>
<span class="p_add">+done</span>
<span class="p_header">diff --git a/tools/perf/util/intel-pt-decoder/x86-opcode-map.txt b/tools/perf/util/intel-pt-decoder/x86-opcode-map.txt</span>
<span class="p_header">index 12e377184ee4..e0b85930dd77 100644</span>
<span class="p_header">--- a/tools/perf/util/intel-pt-decoder/x86-opcode-map.txt</span>
<span class="p_header">+++ b/tools/perf/util/intel-pt-decoder/x86-opcode-map.txt</span>
<span class="p_chunk">@@ -607,7 +607,7 @@</span> <span class="p_context"> fb: psubq Pq,Qq | vpsubq Vx,Hx,Wx (66),(v1)</span>
 fc: paddb Pq,Qq | vpaddb Vx,Hx,Wx (66),(v1)
 fd: paddw Pq,Qq | vpaddw Vx,Hx,Wx (66),(v1)
 fe: paddd Pq,Qq | vpaddd Vx,Hx,Wx (66),(v1)
<span class="p_del">-ff:</span>
<span class="p_add">+ff: UD0</span>
 EndTable
 
 Table: 3-byte opcode 1 (0x0f 0x38)
<span class="p_chunk">@@ -717,7 +717,7 @@</span> <span class="p_context"> AVXcode: 2</span>
 7e: vpermt2d/q Vx,Hx,Wx (66),(ev)
 7f: vpermt2ps/d Vx,Hx,Wx (66),(ev)
 80: INVEPT Gy,Mdq (66)
<span class="p_del">-81: INVPID Gy,Mdq (66)</span>
<span class="p_add">+81: INVVPID Gy,Mdq (66)</span>
 82: INVPCID Gy,Mdq (66)
 83: vpmultishiftqb Vx,Hx,Wx (66),(ev)
 88: vexpandps/d Vpd,Wpd (66),(ev)
<span class="p_chunk">@@ -896,7 +896,7 @@</span> <span class="p_context"> EndTable</span>
 
 GrpTable: Grp3_1
 0: TEST Eb,Ib
<span class="p_del">-1:</span>
<span class="p_add">+1: TEST Eb,Ib</span>
 2: NOT Eb
 3: NEG Eb
 4: MUL AL,Eb
<span class="p_chunk">@@ -970,6 +970,15 @@</span> <span class="p_context"> GrpTable: Grp9</span>
 EndTable
 
 GrpTable: Grp10
<span class="p_add">+# all are UD1</span>
<span class="p_add">+0: UD1</span>
<span class="p_add">+1: UD1</span>
<span class="p_add">+2: UD1</span>
<span class="p_add">+3: UD1</span>
<span class="p_add">+4: UD1</span>
<span class="p_add">+5: UD1</span>
<span class="p_add">+6: UD1</span>
<span class="p_add">+7: UD1</span>
 EndTable
 
 # Grp11A and Grp11B are expressed as Grp11 in Intel SDM
<span class="p_header">diff --git a/tools/testing/selftests/x86/ldt_gdt.c b/tools/testing/selftests/x86/ldt_gdt.c</span>
<span class="p_header">index 66e5ce5b91f0..0304ffb714f2 100644</span>
<span class="p_header">--- a/tools/testing/selftests/x86/ldt_gdt.c</span>
<span class="p_header">+++ b/tools/testing/selftests/x86/ldt_gdt.c</span>
<span class="p_chunk">@@ -627,13 +627,10 @@</span> <span class="p_context"> static void do_multicpu_tests(void)</span>
 static int finish_exec_test(void)
 {
 	/*
<span class="p_del">-	 * In a sensible world, this would be check_invalid_segment(0, 1);</span>
<span class="p_del">-	 * For better or for worse, though, the LDT is inherited across exec.</span>
<span class="p_del">-	 * We can probably change this safely, but for now we test it.</span>
<span class="p_add">+	 * Older kernel versions did inherit the LDT on exec() which is</span>
<span class="p_add">+	 * wrong because exec() starts from a clean state.</span>
 	 */
<span class="p_del">-	check_valid_segment(0, 1,</span>
<span class="p_del">-			    AR_DPL3 | AR_TYPE_XRCODE | AR_S | AR_P | AR_DB,</span>
<span class="p_del">-			    42, true);</span>
<span class="p_add">+	check_invalid_segment(0, 1);</span>
 
 	return nerrs ? 1 : 0;
 }
<span class="p_header">diff --git a/virt/kvm/arm/mmu.c b/virt/kvm/arm/mmu.c</span>
<span class="p_header">index b36945d49986..b4b69c2d1012 100644</span>
<span class="p_header">--- a/virt/kvm/arm/mmu.c</span>
<span class="p_header">+++ b/virt/kvm/arm/mmu.c</span>
<span class="p_chunk">@@ -509,8 +509,6 @@</span> <span class="p_context"> static void unmap_hyp_range(pgd_t *pgdp, phys_addr_t start, u64 size)</span>
  */
 void free_hyp_pgds(void)
 {
<span class="p_del">-	unsigned long addr;</span>
<span class="p_del">-</span>
 	mutex_lock(&amp;kvm_hyp_pgd_mutex);
 
 	if (boot_hyp_pgd) {
<span class="p_chunk">@@ -521,10 +519,10 @@</span> <span class="p_context"> void free_hyp_pgds(void)</span>
 
 	if (hyp_pgd) {
 		unmap_hyp_range(hyp_pgd, hyp_idmap_start, PAGE_SIZE);
<span class="p_del">-		for (addr = PAGE_OFFSET; virt_addr_valid(addr); addr += PGDIR_SIZE)</span>
<span class="p_del">-			unmap_hyp_range(hyp_pgd, kern_hyp_va(addr), PGDIR_SIZE);</span>
<span class="p_del">-		for (addr = VMALLOC_START; is_vmalloc_addr((void*)addr); addr += PGDIR_SIZE)</span>
<span class="p_del">-			unmap_hyp_range(hyp_pgd, kern_hyp_va(addr), PGDIR_SIZE);</span>
<span class="p_add">+		unmap_hyp_range(hyp_pgd, kern_hyp_va(PAGE_OFFSET),</span>
<span class="p_add">+				(uintptr_t)high_memory - PAGE_OFFSET);</span>
<span class="p_add">+		unmap_hyp_range(hyp_pgd, kern_hyp_va(VMALLOC_START),</span>
<span class="p_add">+				VMALLOC_END - VMALLOC_START);</span>
 
 		free_pages((unsigned long)hyp_pgd, hyp_pgd_order);
 		hyp_pgd = NULL;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



