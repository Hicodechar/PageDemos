
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3.13.y-ckt,stable] Linux 3.13.11-ckt21 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3.13.y-ckt,stable] Linux 3.13.11-ckt21</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=7718">Kamal Mostafa</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 1, 2015, 7 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1433185237-29362-2-git-send-email-kamal@canonical.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6524121/mbox/"
   >mbox</a>
|
   <a href="/patch/6524121/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6524121/">/patch/6524121/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 1BC95C0020
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  1 Jun 2015 19:01:44 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 547EB20503
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  1 Jun 2015 19:01:36 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 03F2120494
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  1 Jun 2015 19:01:29 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932095AbbFATBP (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 1 Jun 2015 15:01:15 -0400
Received: from youngberry.canonical.com ([91.189.89.112]:41689 &quot;EHLO
	youngberry.canonical.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751319AbbFATAn (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 1 Jun 2015 15:00:43 -0400
Received: from 1.general.kamal.us.vpn ([10.172.68.52] helo=fourier)
	by youngberry.canonical.com with esmtpsa
	(TLS1.0:DHE_RSA_AES_128_CBC_SHA1:16) (Exim 4.76)
	(envelope-from &lt;kamal@canonical.com&gt;)
	id 1YzUwy-0004Oe-Ss; Mon, 01 Jun 2015 19:00:41 +0000
Received: from kamal by fourier with local (Exim 4.82)
	(envelope-from &lt;kamal@whence.com&gt;)
	id 1YzUww-0007eC-Ky; Mon, 01 Jun 2015 12:00:38 -0700
From: Kamal Mostafa &lt;kamal@canonical.com&gt;
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org,
	kernel-team@lists.ubuntu.com
Cc: lwn@lwn.net
Subject: Re: [3.13.y-ckt stable] Linux 3.13.11-ckt21
Date: Mon,  1 Jun 2015 12:00:37 -0700
Message-Id: &lt;1433185237-29362-2-git-send-email-kamal@canonical.com&gt;
X-Mailer: git-send-email 1.9.1
In-Reply-To: &lt;1433185237-29362-1-git-send-email-kamal@canonical.com&gt;
References: &lt;1433185237-29362-1-git-send-email-kamal@canonical.com&gt;
X-Extended-Stable: 3.13
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7718">Kamal Mostafa</a> - June 1, 2015, 7 p.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 35d9566..1b0c93c 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 13
 SUBLEVEL = 11
<span class="p_del">-EXTRAVERSION = -ckt20</span>
<span class="p_add">+EXTRAVERSION = -ckt21</span>
 NAME = King of Alienated Frog Porn
 
 # *DOCUMENTATION*
<span class="p_header">diff --git a/arch/arm/boot/dts/dove.dtsi b/arch/arm/boot/dts/dove.dtsi</span>
<span class="p_header">index 113a8bc..42e501e 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/dove.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/dove.dtsi</span>
<span class="p_chunk">@@ -176,7 +176,7 @@</span> <span class="p_context"></span>
 
 			uart2: serial@12200 {
 				compatible = &quot;ns16550a&quot;;
<span class="p_del">-				reg = &lt;0x12000 0x100&gt;;</span>
<span class="p_add">+				reg = &lt;0x12200 0x100&gt;;</span>
 				reg-shift = &lt;2&gt;;
 				interrupts = &lt;9&gt;;
 				clocks = &lt;&amp;core_clk 0&gt;;
<span class="p_chunk">@@ -185,7 +185,7 @@</span> <span class="p_context"></span>
 
 			uart3: serial@12300 {
 				compatible = &quot;ns16550a&quot;;
<span class="p_del">-				reg = &lt;0x12100 0x100&gt;;</span>
<span class="p_add">+				reg = &lt;0x12300 0x100&gt;;</span>
 				reg-shift = &lt;2&gt;;
 				interrupts = &lt;10&gt;;
 				clocks = &lt;&amp;core_clk 0&gt;;
<span class="p_header">diff --git a/arch/arm/include/asm/elf.h b/arch/arm/include/asm/elf.h</span>
<span class="p_header">index f4b46d3..051b726 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/elf.h</span>
<span class="p_chunk">@@ -114,7 +114,7 @@</span> <span class="p_context"> int dump_task_regs(struct task_struct *t, elf_gregset_t *elfregs);</span>
    the loader.  We need to make sure that it is out of the way of the program
    that it will &quot;exec&quot;, and that there is sufficient room for the brk.  */
 
<span class="p_del">-#define ELF_ET_DYN_BASE	(2 * TASK_SIZE / 3)</span>
<span class="p_add">+#define ELF_ET_DYN_BASE	(TASK_SIZE / 3 * 2)</span>
 
 /* When the program starts, a1 contains a pointer to a function to be 
    registered with atexit, as per the SVR4 ABI.  A value of 0 means we 
<span class="p_header">diff --git a/arch/arm/mach-s3c64xx/crag6410.h b/arch/arm/mach-s3c64xx/crag6410.h</span>
<span class="p_header">index 4c3c999..81dc722 100644</span>
<span class="p_header">--- a/arch/arm/mach-s3c64xx/crag6410.h</span>
<span class="p_header">+++ b/arch/arm/mach-s3c64xx/crag6410.h</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/gpio.h&gt;
 
 #define GLENFARCLAS_PMIC_IRQ_BASE	IRQ_BOARD_START
<span class="p_add">+#define BANFF_PMIC_IRQ_BASE		(IRQ_BOARD_START + 64)</span>
 
 #define PCA935X_GPIO_BASE		GPIO_BOARD_START
 #define CODEC_GPIO_BASE			(GPIO_BOARD_START + 8)
<span class="p_header">diff --git a/arch/arm/mach-s3c64xx/mach-crag6410.c b/arch/arm/mach-s3c64xx/mach-crag6410.c</span>
<span class="p_header">index 758e31b..12ddbff 100644</span>
<span class="p_header">--- a/arch/arm/mach-s3c64xx/mach-crag6410.c</span>
<span class="p_header">+++ b/arch/arm/mach-s3c64xx/mach-crag6410.c</span>
<span class="p_chunk">@@ -555,6 +555,7 @@</span> <span class="p_context"> static struct wm831x_touch_pdata touch_pdata = {</span>
 
 static struct wm831x_pdata crag_pmic_pdata = {
 	.wm831x_num = 1,
<span class="p_add">+	.irq_base = BANFF_PMIC_IRQ_BASE,</span>
 	.gpio_base = BANFF_PMIC_GPIO_BASE,
 	.soft_shutdown = true,
 
<span class="p_header">diff --git a/arch/c6x/kernel/time.c b/arch/c6x/kernel/time.c</span>
<span class="p_header">index 356ee84..04845aa 100644</span>
<span class="p_header">--- a/arch/c6x/kernel/time.c</span>
<span class="p_header">+++ b/arch/c6x/kernel/time.c</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> u64 sched_clock(void)</span>
 	return (tsc * sched_clock_multiplier) &gt;&gt; SCHED_CLOCK_SHIFT;
 }
 
<span class="p_del">-void time_init(void)</span>
<span class="p_add">+void __init time_init(void)</span>
 {
 	u64 tmp = (u64)NSEC_PER_SEC &lt;&lt; SCHED_CLOCK_SHIFT;
 
<span class="p_header">diff --git a/arch/mips/power/hibernate.S b/arch/mips/power/hibernate.S</span>
<span class="p_header">index 32a7c82..e7567c8 100644</span>
<span class="p_header">--- a/arch/mips/power/hibernate.S</span>
<span class="p_header">+++ b/arch/mips/power/hibernate.S</span>
<span class="p_chunk">@@ -30,6 +30,8 @@</span> <span class="p_context"> LEAF(swsusp_arch_suspend)</span>
 END(swsusp_arch_suspend)
 
 LEAF(swsusp_arch_resume)
<span class="p_add">+	/* Avoid TLB mismatch during and after kernel resume */</span>
<span class="p_add">+	jal local_flush_tlb_all</span>
 	PTR_L t0, restore_pblist
 0:
 	PTR_L t1, PBE_ADDRESS(t0)   /* source */
<span class="p_chunk">@@ -43,7 +45,6 @@</span> <span class="p_context"> LEAF(swsusp_arch_resume)</span>
 	bne t1, t3, 1b
 	PTR_L t0, PBE_NEXT(t0)
 	bnez t0, 0b
<span class="p_del">-	jal local_flush_tlb_all /* Avoid TLB mismatch after kernel resume */</span>
 	PTR_LA t0, saved_regs
 	PTR_L ra, PT_R31(t0)
 	PTR_L sp, PT_R29(t0)
<span class="p_header">diff --git a/arch/powerpc/kernel/cacheinfo.c b/arch/powerpc/kernel/cacheinfo.c</span>
<span class="p_header">index bfb8236..c26b935 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/cacheinfo.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/cacheinfo.c</span>
<span class="p_chunk">@@ -62,12 +62,22 @@</span> <span class="p_context"> struct cache_type_info {</span>
 };
 
 /* These are used to index the cache_type_info array. */
<span class="p_del">-#define CACHE_TYPE_UNIFIED     0</span>
<span class="p_del">-#define CACHE_TYPE_INSTRUCTION 1</span>
<span class="p_del">-#define CACHE_TYPE_DATA        2</span>
<span class="p_add">+#define CACHE_TYPE_UNIFIED     0 /* cache-size, cache-block-size, etc. */</span>
<span class="p_add">+#define CACHE_TYPE_UNIFIED_D   1 /* d-cache-size, d-cache-block-size, etc */</span>
<span class="p_add">+#define CACHE_TYPE_INSTRUCTION 2</span>
<span class="p_add">+#define CACHE_TYPE_DATA        3</span>
 
 static const struct cache_type_info cache_type_info[] = {
 	{
<span class="p_add">+		/* Embedded systems that use cache-size, cache-block-size,</span>
<span class="p_add">+		 * etc. for the Unified (typically L2) cache. */</span>
<span class="p_add">+		.name            = &quot;Unified&quot;,</span>
<span class="p_add">+		.size_prop       = &quot;cache-size&quot;,</span>
<span class="p_add">+		.line_size_props = { &quot;cache-line-size&quot;,</span>
<span class="p_add">+				     &quot;cache-block-size&quot;, },</span>
<span class="p_add">+		.nr_sets_prop    = &quot;cache-sets&quot;,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		/* PowerPC Processor binding says the [di]-cache-*
 		 * must be equal on unified caches, so just use
 		 * d-cache properties. */
<span class="p_chunk">@@ -294,7 +304,8 @@</span> <span class="p_context"> static struct cache *cache_find_first_sibling(struct cache *cache)</span>
 {
 	struct cache *iter;
 
<span class="p_del">-	if (cache-&gt;type == CACHE_TYPE_UNIFIED)</span>
<span class="p_add">+	if (cache-&gt;type == CACHE_TYPE_UNIFIED ||</span>
<span class="p_add">+	    cache-&gt;type == CACHE_TYPE_UNIFIED_D)</span>
 		return cache;
 
 	list_for_each_entry(iter, &amp;cache_list, list)
<span class="p_chunk">@@ -325,16 +336,29 @@</span> <span class="p_context"> static bool cache_node_is_unified(const struct device_node *np)</span>
 	return of_get_property(np, &quot;cache-unified&quot;, NULL);
 }
 
<span class="p_del">-static struct cache *cache_do_one_devnode_unified(struct device_node *node,</span>
<span class="p_del">-						  int level)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Unified caches can have two different sets of tags.  Most embedded</span>
<span class="p_add">+ * use cache-size, etc. for the unified cache size, but open firmware systems</span>
<span class="p_add">+ * use d-cache-size, etc.   Check on initialization for which type we have, and</span>
<span class="p_add">+ * return the appropriate structure type.  Assume it&#39;s embedded if it isn&#39;t</span>
<span class="p_add">+ * open firmware.  If it&#39;s yet a 3rd type, then there will be missing entries</span>
<span class="p_add">+ * in /sys/devices/system/cpu/cpu0/cache/index2/, and this code will need</span>
<span class="p_add">+ * to be extended further.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int cache_is_unified_d(const struct device_node *np)</span>
 {
<span class="p_del">-	struct cache *cache;</span>
<span class="p_add">+	return of_get_property(np,</span>
<span class="p_add">+		cache_type_info[CACHE_TYPE_UNIFIED_D].size_prop, NULL) ?</span>
<span class="p_add">+		CACHE_TYPE_UNIFIED_D : CACHE_TYPE_UNIFIED;</span>
<span class="p_add">+}</span>
 
<span class="p_add">+/*</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct cache *cache_do_one_devnode_unified(struct device_node *node, int level)</span>
<span class="p_add">+{</span>
 	pr_debug(&quot;creating L%d ucache for %s\n&quot;, level, node-&gt;full_name);
 
<span class="p_del">-	cache = new_cache(CACHE_TYPE_UNIFIED, level, node);</span>
<span class="p_del">-</span>
<span class="p_del">-	return cache;</span>
<span class="p_add">+	return new_cache(cache_is_unified_d(node), level, node);</span>
 }
 
 static struct cache *cache_do_one_devnode_split(struct device_node *node,
<span class="p_header">diff --git a/arch/powerpc/lib/crtsavres.S b/arch/powerpc/lib/crtsavres.S</span>
<span class="p_header">index b2c68ce..a5b30c7 100644</span>
<span class="p_header">--- a/arch/powerpc/lib/crtsavres.S</span>
<span class="p_header">+++ b/arch/powerpc/lib/crtsavres.S</span>
<span class="p_chunk">@@ -231,6 +231,87 @@</span> <span class="p_context"> _GLOBAL(_rest32gpr_31_x)</span>
 	mr	1,11
 	blr
 
<span class="p_add">+#ifdef CONFIG_ALTIVEC</span>
<span class="p_add">+/* Called with r0 pointing just beyond the end of the vector save area.  */</span>
<span class="p_add">+</span>
<span class="p_add">+_GLOBAL(_savevr_20)</span>
<span class="p_add">+	li	r11,-192</span>
<span class="p_add">+	stvx	vr20,r11,r0</span>
<span class="p_add">+_GLOBAL(_savevr_21)</span>
<span class="p_add">+	li	r11,-176</span>
<span class="p_add">+	stvx	vr21,r11,r0</span>
<span class="p_add">+_GLOBAL(_savevr_22)</span>
<span class="p_add">+	li	r11,-160</span>
<span class="p_add">+	stvx	vr22,r11,r0</span>
<span class="p_add">+_GLOBAL(_savevr_23)</span>
<span class="p_add">+	li	r11,-144</span>
<span class="p_add">+	stvx	vr23,r11,r0</span>
<span class="p_add">+_GLOBAL(_savevr_24)</span>
<span class="p_add">+	li	r11,-128</span>
<span class="p_add">+	stvx	vr24,r11,r0</span>
<span class="p_add">+_GLOBAL(_savevr_25)</span>
<span class="p_add">+	li	r11,-112</span>
<span class="p_add">+	stvx	vr25,r11,r0</span>
<span class="p_add">+_GLOBAL(_savevr_26)</span>
<span class="p_add">+	li	r11,-96</span>
<span class="p_add">+	stvx	vr26,r11,r0</span>
<span class="p_add">+_GLOBAL(_savevr_27)</span>
<span class="p_add">+	li	r11,-80</span>
<span class="p_add">+	stvx	vr27,r11,r0</span>
<span class="p_add">+_GLOBAL(_savevr_28)</span>
<span class="p_add">+	li	r11,-64</span>
<span class="p_add">+	stvx	vr28,r11,r0</span>
<span class="p_add">+_GLOBAL(_savevr_29)</span>
<span class="p_add">+	li	r11,-48</span>
<span class="p_add">+	stvx	vr29,r11,r0</span>
<span class="p_add">+_GLOBAL(_savevr_30)</span>
<span class="p_add">+	li	r11,-32</span>
<span class="p_add">+	stvx	vr30,r11,r0</span>
<span class="p_add">+_GLOBAL(_savevr_31)</span>
<span class="p_add">+	li	r11,-16</span>
<span class="p_add">+	stvx	vr31,r11,r0</span>
<span class="p_add">+	blr</span>
<span class="p_add">+</span>
<span class="p_add">+_GLOBAL(_restvr_20)</span>
<span class="p_add">+	li	r11,-192</span>
<span class="p_add">+	lvx	vr20,r11,r0</span>
<span class="p_add">+_GLOBAL(_restvr_21)</span>
<span class="p_add">+	li	r11,-176</span>
<span class="p_add">+	lvx	vr21,r11,r0</span>
<span class="p_add">+_GLOBAL(_restvr_22)</span>
<span class="p_add">+	li	r11,-160</span>
<span class="p_add">+	lvx	vr22,r11,r0</span>
<span class="p_add">+_GLOBAL(_restvr_23)</span>
<span class="p_add">+	li	r11,-144</span>
<span class="p_add">+	lvx	vr23,r11,r0</span>
<span class="p_add">+_GLOBAL(_restvr_24)</span>
<span class="p_add">+	li	r11,-128</span>
<span class="p_add">+	lvx	vr24,r11,r0</span>
<span class="p_add">+_GLOBAL(_restvr_25)</span>
<span class="p_add">+	li	r11,-112</span>
<span class="p_add">+	lvx	vr25,r11,r0</span>
<span class="p_add">+_GLOBAL(_restvr_26)</span>
<span class="p_add">+	li	r11,-96</span>
<span class="p_add">+	lvx	vr26,r11,r0</span>
<span class="p_add">+_GLOBAL(_restvr_27)</span>
<span class="p_add">+	li	r11,-80</span>
<span class="p_add">+	lvx	vr27,r11,r0</span>
<span class="p_add">+_GLOBAL(_restvr_28)</span>
<span class="p_add">+	li	r11,-64</span>
<span class="p_add">+	lvx	vr28,r11,r0</span>
<span class="p_add">+_GLOBAL(_restvr_29)</span>
<span class="p_add">+	li	r11,-48</span>
<span class="p_add">+	lvx	vr29,r11,r0</span>
<span class="p_add">+_GLOBAL(_restvr_30)</span>
<span class="p_add">+	li	r11,-32</span>
<span class="p_add">+	lvx	vr30,r11,r0</span>
<span class="p_add">+_GLOBAL(_restvr_31)</span>
<span class="p_add">+	li	r11,-16</span>
<span class="p_add">+	lvx	vr31,r11,r0</span>
<span class="p_add">+	blr</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* CONFIG_ALTIVEC */</span>
<span class="p_add">+</span>
 #else /* CONFIG_PPC64 */
 
 	.section &quot;.text.save.restore&quot;,&quot;ax&quot;,@progbits
<span class="p_chunk">@@ -356,6 +437,111 @@</span> <span class="p_context"> _restgpr0_31:</span>
 	mtlr	r0
 	blr
 
<span class="p_add">+#ifdef CONFIG_ALTIVEC</span>
<span class="p_add">+/* Called with r0 pointing just beyond the end of the vector save area.  */</span>
<span class="p_add">+</span>
<span class="p_add">+.globl	_savevr_20</span>
<span class="p_add">+_savevr_20:</span>
<span class="p_add">+	li	r12,-192</span>
<span class="p_add">+	stvx	vr20,r12,r0</span>
<span class="p_add">+.globl	_savevr_21</span>
<span class="p_add">+_savevr_21:</span>
<span class="p_add">+	li	r12,-176</span>
<span class="p_add">+	stvx	vr21,r12,r0</span>
<span class="p_add">+.globl	_savevr_22</span>
<span class="p_add">+_savevr_22:</span>
<span class="p_add">+	li	r12,-160</span>
<span class="p_add">+	stvx	vr22,r12,r0</span>
<span class="p_add">+.globl	_savevr_23</span>
<span class="p_add">+_savevr_23:</span>
<span class="p_add">+	li	r12,-144</span>
<span class="p_add">+	stvx	vr23,r12,r0</span>
<span class="p_add">+.globl	_savevr_24</span>
<span class="p_add">+_savevr_24:</span>
<span class="p_add">+	li	r12,-128</span>
<span class="p_add">+	stvx	vr24,r12,r0</span>
<span class="p_add">+.globl	_savevr_25</span>
<span class="p_add">+_savevr_25:</span>
<span class="p_add">+	li	r12,-112</span>
<span class="p_add">+	stvx	vr25,r12,r0</span>
<span class="p_add">+.globl	_savevr_26</span>
<span class="p_add">+_savevr_26:</span>
<span class="p_add">+	li	r12,-96</span>
<span class="p_add">+	stvx	vr26,r12,r0</span>
<span class="p_add">+.globl	_savevr_27</span>
<span class="p_add">+_savevr_27:</span>
<span class="p_add">+	li	r12,-80</span>
<span class="p_add">+	stvx	vr27,r12,r0</span>
<span class="p_add">+.globl	_savevr_28</span>
<span class="p_add">+_savevr_28:</span>
<span class="p_add">+	li	r12,-64</span>
<span class="p_add">+	stvx	vr28,r12,r0</span>
<span class="p_add">+.globl	_savevr_29</span>
<span class="p_add">+_savevr_29:</span>
<span class="p_add">+	li	r12,-48</span>
<span class="p_add">+	stvx	vr29,r12,r0</span>
<span class="p_add">+.globl	_savevr_30</span>
<span class="p_add">+_savevr_30:</span>
<span class="p_add">+	li	r12,-32</span>
<span class="p_add">+	stvx	vr30,r12,r0</span>
<span class="p_add">+.globl	_savevr_31</span>
<span class="p_add">+_savevr_31:</span>
<span class="p_add">+	li	r12,-16</span>
<span class="p_add">+	stvx	vr31,r12,r0</span>
<span class="p_add">+	blr</span>
<span class="p_add">+</span>
<span class="p_add">+.globl	_restvr_20</span>
<span class="p_add">+_restvr_20:</span>
<span class="p_add">+	li	r12,-192</span>
<span class="p_add">+	lvx	vr20,r12,r0</span>
<span class="p_add">+.globl	_restvr_21</span>
<span class="p_add">+_restvr_21:</span>
<span class="p_add">+	li	r12,-176</span>
<span class="p_add">+	lvx	vr21,r12,r0</span>
<span class="p_add">+.globl	_restvr_22</span>
<span class="p_add">+_restvr_22:</span>
<span class="p_add">+	li	r12,-160</span>
<span class="p_add">+	lvx	vr22,r12,r0</span>
<span class="p_add">+.globl	_restvr_23</span>
<span class="p_add">+_restvr_23:</span>
<span class="p_add">+	li	r12,-144</span>
<span class="p_add">+	lvx	vr23,r12,r0</span>
<span class="p_add">+.globl	_restvr_24</span>
<span class="p_add">+_restvr_24:</span>
<span class="p_add">+	li	r12,-128</span>
<span class="p_add">+	lvx	vr24,r12,r0</span>
<span class="p_add">+.globl	_restvr_25</span>
<span class="p_add">+_restvr_25:</span>
<span class="p_add">+	li	r12,-112</span>
<span class="p_add">+	lvx	vr25,r12,r0</span>
<span class="p_add">+.globl	_restvr_26</span>
<span class="p_add">+_restvr_26:</span>
<span class="p_add">+	li	r12,-96</span>
<span class="p_add">+	lvx	vr26,r12,r0</span>
<span class="p_add">+.globl	_restvr_27</span>
<span class="p_add">+_restvr_27:</span>
<span class="p_add">+	li	r12,-80</span>
<span class="p_add">+	lvx	vr27,r12,r0</span>
<span class="p_add">+.globl	_restvr_28</span>
<span class="p_add">+_restvr_28:</span>
<span class="p_add">+	li	r12,-64</span>
<span class="p_add">+	lvx	vr28,r12,r0</span>
<span class="p_add">+.globl	_restvr_29</span>
<span class="p_add">+_restvr_29:</span>
<span class="p_add">+	li	r12,-48</span>
<span class="p_add">+	lvx	vr29,r12,r0</span>
<span class="p_add">+.globl	_restvr_30</span>
<span class="p_add">+_restvr_30:</span>
<span class="p_add">+	li	r12,-32</span>
<span class="p_add">+	lvx	vr30,r12,r0</span>
<span class="p_add">+.globl	_restvr_31</span>
<span class="p_add">+_restvr_31:</span>
<span class="p_add">+	li	r12,-16</span>
<span class="p_add">+	lvx	vr31,r12,r0</span>
<span class="p_add">+	blr</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* CONFIG_ALTIVEC */</span>
<span class="p_add">+</span>
 #endif /* CONFIG_PPC64 */
 
 #endif
<span class="p_header">diff --git a/arch/powerpc/perf/callchain.c b/arch/powerpc/perf/callchain.c</span>
<span class="p_header">index 74d1e78..63bc981 100644</span>
<span class="p_header">--- a/arch/powerpc/perf/callchain.c</span>
<span class="p_header">+++ b/arch/powerpc/perf/callchain.c</span>
<span class="p_chunk">@@ -243,7 +243,7 @@</span> <span class="p_context"> static void perf_callchain_user_64(struct perf_callchain_entry *entry,</span>
 	sp = regs-&gt;gpr[1];
 	perf_callchain_store(entry, next_ip);
 
<span class="p_del">-	for (;;) {</span>
<span class="p_add">+	while (entry-&gt;nr &lt; PERF_MAX_STACK_DEPTH) {</span>
 		fp = (unsigned long __user *) sp;
 		if (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &amp;next_sp))
 			return;
<span class="p_header">diff --git a/arch/s390/kernel/suspend.c b/arch/s390/kernel/suspend.c</span>
<span class="p_header">index a7a7537..cd9f503 100644</span>
<span class="p_header">--- a/arch/s390/kernel/suspend.c</span>
<span class="p_header">+++ b/arch/s390/kernel/suspend.c</span>
<span class="p_chunk">@@ -142,6 +142,8 @@</span> <span class="p_context"> int pfn_is_nosave(unsigned long pfn)</span>
 {
 	unsigned long nosave_begin_pfn = PFN_DOWN(__pa(&amp;__nosave_begin));
 	unsigned long nosave_end_pfn = PFN_DOWN(__pa(&amp;__nosave_end));
<span class="p_add">+	unsigned long eshared_pfn = PFN_DOWN(__pa(&amp;_eshared)) - 1;</span>
<span class="p_add">+	unsigned long stext_pfn = PFN_DOWN(__pa(&amp;_stext));</span>
 
 	/* Always save lowcore pages (LC protection might be enabled). */
 	if (pfn &lt;= LC_PAGES)
<span class="p_chunk">@@ -149,6 +151,8 @@</span> <span class="p_context"> int pfn_is_nosave(unsigned long pfn)</span>
 	if (pfn &gt;= nosave_begin_pfn &amp;&amp; pfn &lt; nosave_end_pfn)
 		return 1;
 	/* Skip memory holes and read-only pages (NSS, DCSS, ...). */
<span class="p_add">+	if (pfn &gt;= stext_pfn &amp;&amp; pfn &lt;= eshared_pfn)</span>
<span class="p_add">+		return ipl_info.type == IPL_TYPE_NSS ? 1 : 0;</span>
 	if (tprot(PFN_PHYS(pfn)))
 		return 1;
 	return 0;
<span class="p_header">diff --git a/arch/s390/kvm/priv.c b/arch/s390/kvm/priv.c</span>
<span class="p_header">index 8821ac8..bff713f 100644</span>
<span class="p_header">--- a/arch/s390/kvm/priv.c</span>
<span class="p_header">+++ b/arch/s390/kvm/priv.c</span>
<span class="p_chunk">@@ -414,6 +414,7 @@</span> <span class="p_context"> static void handle_stsi_3_2_2(struct kvm_vcpu *vcpu, struct sysinfo_3_2_2 *mem)</span>
 	for (n = mem-&gt;count - 1; n &gt; 0 ; n--)
 		memcpy(&amp;mem-&gt;vm[n], &amp;mem-&gt;vm[n - 1], sizeof(mem-&gt;vm[0]));
 
<span class="p_add">+	memset(&amp;mem-&gt;vm[0], 0, sizeof(mem-&gt;vm[0]));</span>
 	mem-&gt;vm[0].cpus_total = cpus;
 	mem-&gt;vm[0].cpus_configured = cpus;
 	mem-&gt;vm[0].cpus_standby = 0;
<span class="p_header">diff --git a/arch/x86/include/asm/pvclock.h b/arch/x86/include/asm/pvclock.h</span>
<span class="p_header">index d6b078e..25b1cc0 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/pvclock.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/pvclock.h</span>
<span class="p_chunk">@@ -95,6 +95,7 @@</span> <span class="p_context"> unsigned __pvclock_read_cycles(const struct pvclock_vcpu_time_info *src,</span>
 
 struct pvclock_vsyscall_time_info {
 	struct pvclock_vcpu_time_info pvti;
<span class="p_add">+	u32 migrate_count;</span>
 } __attribute__((__aligned__(SMP_CACHE_BYTES)));
 
 #define PVTI_SIZE sizeof(struct pvclock_vsyscall_time_info)
<span class="p_header">diff --git a/arch/x86/kernel/process.c b/arch/x86/kernel/process.c</span>
<span class="p_header">index 3fb8d95..c5db2a4 100644</span>
<span class="p_header">--- a/arch/x86/kernel/process.c</span>
<span class="p_header">+++ b/arch/x86/kernel/process.c</span>
<span class="p_chunk">@@ -398,6 +398,52 @@</span> <span class="p_context"> static void amd_e400_idle(void)</span>
 		default_idle();
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Intel Core2 and older machines prefer MWAIT over HALT for C1.</span>
<span class="p_add">+ * We can&#39;t rely on cpuidle installing MWAIT, because it will not load</span>
<span class="p_add">+ * on systems that support only C1 -- so the boot default must be MWAIT.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Some AMD machines are the opposite, they depend on using HALT.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * So for default C1, which is used during boot until cpuidle loads,</span>
<span class="p_add">+ * use MWAIT-C1 on Intel HW that has it, else use HALT.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int prefer_mwait_c1_over_halt(const struct cpuinfo_x86 *c)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (c-&gt;x86_vendor != X86_VENDOR_INTEL)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!cpu_has(c, X86_FEATURE_MWAIT))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * MONITOR/MWAIT with no hints, used for default default C1 state.</span>
<span class="p_add">+ * This invokes MWAIT with interrutps enabled and no flags,</span>
<span class="p_add">+ * which is backwards compatible with the original MWAIT implementation.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+static void mwait_idle(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!current_set_polling_and_test()) {</span>
<span class="p_add">+		if (static_cpu_has(X86_FEATURE_CLFLUSH_MONITOR)) {</span>
<span class="p_add">+			mb();</span>
<span class="p_add">+			clflush((void *)&amp;current_thread_info()-&gt;flags);</span>
<span class="p_add">+			mb();</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		__monitor((void *)&amp;current_thread_info()-&gt;flags, 0, 0);</span>
<span class="p_add">+		if (!need_resched())</span>
<span class="p_add">+			__sti_mwait(0, 0);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			local_irq_enable();</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		local_irq_enable();</span>
<span class="p_add">+	__current_clr_polling();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void select_idle_routine(const struct cpuinfo_x86 *c)
 {
 #ifdef CONFIG_SMP
<span class="p_chunk">@@ -411,6 +457,9 @@</span> <span class="p_context"> void select_idle_routine(const struct cpuinfo_x86 *c)</span>
 		/* E400: APIC timer interrupt does not wake up CPU from C1e */
 		pr_info(&quot;using AMD E400 aware idle routine\n&quot;);
 		x86_idle = amd_e400_idle;
<span class="p_add">+	} else if (prefer_mwait_c1_over_halt(c)) {</span>
<span class="p_add">+		pr_info(&quot;using mwait in idle threads\n&quot;);</span>
<span class="p_add">+		x86_idle = mwait_idle;</span>
 	} else
 		x86_idle = default_idle;
 }
<span class="p_header">diff --git a/arch/x86/kernel/pvclock.c b/arch/x86/kernel/pvclock.c</span>
<span class="p_header">index 2f355d2..e5ecd20 100644</span>
<span class="p_header">--- a/arch/x86/kernel/pvclock.c</span>
<span class="p_header">+++ b/arch/x86/kernel/pvclock.c</span>
<span class="p_chunk">@@ -141,7 +141,46 @@</span> <span class="p_context"> void pvclock_read_wallclock(struct pvclock_wall_clock *wall_clock,</span>
 	set_normalized_timespec(ts, now.tv_sec, now.tv_nsec);
 }
 
<span class="p_add">+static struct pvclock_vsyscall_time_info *pvclock_vdso_info;</span>
<span class="p_add">+</span>
<span class="p_add">+static struct pvclock_vsyscall_time_info *</span>
<span class="p_add">+pvclock_get_vsyscall_user_time_info(int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!pvclock_vdso_info) {</span>
<span class="p_add">+		BUG();</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return &amp;pvclock_vdso_info[cpu];</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+struct pvclock_vcpu_time_info *pvclock_get_vsyscall_time_info(int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return &amp;pvclock_get_vsyscall_user_time_info(cpu)-&gt;pvti;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #ifdef CONFIG_X86_64
<span class="p_add">+static int pvclock_task_migrate(struct notifier_block *nb, unsigned long l,</span>
<span class="p_add">+			        void *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct task_migration_notifier *mn = v;</span>
<span class="p_add">+	struct pvclock_vsyscall_time_info *pvti;</span>
<span class="p_add">+</span>
<span class="p_add">+	pvti = pvclock_get_vsyscall_user_time_info(mn-&gt;from_cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* this is NULL when pvclock vsyscall is not initialized */</span>
<span class="p_add">+	if (unlikely(pvti == NULL))</span>
<span class="p_add">+		return NOTIFY_DONE;</span>
<span class="p_add">+</span>
<span class="p_add">+	pvti-&gt;migrate_count++;</span>
<span class="p_add">+</span>
<span class="p_add">+	return NOTIFY_DONE;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct notifier_block pvclock_migrate = {</span>
<span class="p_add">+	.notifier_call = pvclock_task_migrate,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /*
  * Initialize the generic pvclock vsyscall state.  This will allocate
  * a/some page(s) for the per-vcpu pvclock information, set up a
<span class="p_chunk">@@ -155,12 +194,17 @@</span> <span class="p_context"> int __init pvclock_init_vsyscall(struct pvclock_vsyscall_time_info *i,</span>
 
 	WARN_ON (size != PVCLOCK_VSYSCALL_NR_PAGES*PAGE_SIZE);
 
<span class="p_add">+	pvclock_vdso_info = i;</span>
<span class="p_add">+</span>
 	for (idx = 0; idx &lt;= (PVCLOCK_FIXMAP_END-PVCLOCK_FIXMAP_BEGIN); idx++) {
 		__set_fixmap(PVCLOCK_FIXMAP_BEGIN + idx,
 			     __pa(i) + (idx*PAGE_SIZE),
 			     PAGE_KERNEL_VVAR);
 	}
 
<span class="p_add">+</span>
<span class="p_add">+	register_task_migration_notifier(&amp;pvclock_migrate);</span>
<span class="p_add">+</span>
 	return 0;
 }
 #endif
<span class="p_header">diff --git a/arch/x86/vdso/vclock_gettime.c b/arch/x86/vdso/vclock_gettime.c</span>
<span class="p_header">index eb5d7a5..e2310bb 100644</span>
<span class="p_header">--- a/arch/x86/vdso/vclock_gettime.c</span>
<span class="p_header">+++ b/arch/x86/vdso/vclock_gettime.c</span>
<span class="p_chunk">@@ -85,18 +85,15 @@</span> <span class="p_context"> static notrace cycle_t vread_pvclock(int *mode)</span>
 	cycle_t ret;
 	u64 last;
 	u32 version;
<span class="p_add">+	u32 migrate_count;</span>
 	u8 flags;
 	unsigned cpu, cpu1;
 
 
 	/*
<span class="p_del">-	 * Note: hypervisor must guarantee that:</span>
<span class="p_del">-	 * 1. cpu ID number maps 1:1 to per-CPU pvclock time info.</span>
<span class="p_del">-	 * 2. that per-CPU pvclock time info is updated if the</span>
<span class="p_del">-	 *    underlying CPU changes.</span>
<span class="p_del">-	 * 3. that version is increased whenever underlying CPU</span>
<span class="p_del">-	 *    changes.</span>
<span class="p_del">-	 *</span>
<span class="p_add">+	 * When looping to get a consistent (time-info, tsc) pair, we</span>
<span class="p_add">+	 * also need to deal with the possibility we can switch vcpus,</span>
<span class="p_add">+	 * so make sure we always re-fetch time-info for the current vcpu.</span>
 	 */
 	do {
 		cpu = __getcpu() &amp; VGETCPU_CPU_MASK;
<span class="p_chunk">@@ -105,20 +102,27 @@</span> <span class="p_context"> static notrace cycle_t vread_pvclock(int *mode)</span>
 		 * __getcpu() calls (Gleb).
 		 */
 
<span class="p_del">-		pvti = get_pvti(cpu);</span>
<span class="p_add">+		/* Make sure migrate_count will change if we leave the VCPU. */</span>
<span class="p_add">+		do {</span>
<span class="p_add">+			pvti = get_pvti(cpu);</span>
<span class="p_add">+			migrate_count = pvti-&gt;migrate_count;</span>
<span class="p_add">+</span>
<span class="p_add">+			cpu1 = cpu;</span>
<span class="p_add">+			cpu = __getcpu() &amp; VGETCPU_CPU_MASK;</span>
<span class="p_add">+		} while (unlikely(cpu != cpu1));</span>
 
 		version = __pvclock_read_cycles(&amp;pvti-&gt;pvti, &amp;ret, &amp;flags);
 
 		/*
 		 * Test we&#39;re still on the cpu as well as the version.
<span class="p_del">-		 * We could have been migrated just after the first</span>
<span class="p_del">-		 * vgetcpu but before fetching the version, so we</span>
<span class="p_del">-		 * wouldn&#39;t notice a version change.</span>
<span class="p_add">+		 * - We must read TSC of pvti&#39;s VCPU.</span>
<span class="p_add">+		 * - KVM doesn&#39;t follow the versioning protocol, so data could</span>
<span class="p_add">+		 *   change before version if we left the VCPU.</span>
 		 */
<span class="p_del">-		cpu1 = __getcpu() &amp; VGETCPU_CPU_MASK;</span>
<span class="p_del">-	} while (unlikely(cpu != cpu1 ||</span>
<span class="p_del">-			  (pvti-&gt;pvti.version &amp; 1) ||</span>
<span class="p_del">-			  pvti-&gt;pvti.version != version));</span>
<span class="p_add">+		smp_rmb();</span>
<span class="p_add">+	} while (unlikely((pvti-&gt;pvti.version &amp; 1) ||</span>
<span class="p_add">+			  pvti-&gt;pvti.version != version ||</span>
<span class="p_add">+			  pvti-&gt;migrate_count != migrate_count));</span>
 
 	if (unlikely(!(flags &amp; PVCLOCK_TSC_STABLE_BIT)))
 		*mode = VCLOCK_NONE;
<span class="p_header">diff --git a/arch/xtensa/Kconfig b/arch/xtensa/Kconfig</span>
<span class="p_header">index 8d24dcb..ad2fcfb 100644</span>
<span class="p_header">--- a/arch/xtensa/Kconfig</span>
<span class="p_header">+++ b/arch/xtensa/Kconfig</span>
<span class="p_chunk">@@ -283,6 +283,36 @@</span> <span class="p_context"> source &quot;drivers/pcmcia/Kconfig&quot;</span>
 
 source &quot;drivers/pci/hotplug/Kconfig&quot;
 
<span class="p_add">+config XTFPGA_LCD</span>
<span class="p_add">+	bool &quot;Enable XTFPGA LCD driver&quot;</span>
<span class="p_add">+	depends on XTENSA_PLATFORM_XTFPGA</span>
<span class="p_add">+	default n</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  There&#39;s a 2x16 LCD on most of XTFPGA boards, kernel may output</span>
<span class="p_add">+	  progress messages there during bootup/shutdown. It may be useful</span>
<span class="p_add">+	  during board bringup.</span>
<span class="p_add">+</span>
<span class="p_add">+	  If unsure, say N.</span>
<span class="p_add">+</span>
<span class="p_add">+config XTFPGA_LCD_BASE_ADDR</span>
<span class="p_add">+	hex &quot;XTFPGA LCD base address&quot;</span>
<span class="p_add">+	depends on XTFPGA_LCD</span>
<span class="p_add">+	default &quot;0x0d0c0000&quot;</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Base address of the LCD controller inside KIO region.</span>
<span class="p_add">+	  Different boards from XTFPGA family have LCD controller at different</span>
<span class="p_add">+	  addresses. Please consult prototyping user guide for your board for</span>
<span class="p_add">+	  the correct address. Wrong address here may lead to hardware lockup.</span>
<span class="p_add">+</span>
<span class="p_add">+config XTFPGA_LCD_8BIT_ACCESS</span>
<span class="p_add">+	bool &quot;Use 8-bit access to XTFPGA LCD&quot;</span>
<span class="p_add">+	depends on XTFPGA_LCD</span>
<span class="p_add">+	default n</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  LCD may be connected with 4- or 8-bit interface, 8-bit access may</span>
<span class="p_add">+	  only be used with 8-bit interface. Please consult prototyping user</span>
<span class="p_add">+	  guide for your board for the correct interface width.</span>
<span class="p_add">+</span>
 endmenu
 
 menu &quot;Executable file formats&quot;
<span class="p_header">diff --git a/arch/xtensa/include/uapi/asm/unistd.h b/arch/xtensa/include/uapi/asm/unistd.h</span>
<span class="p_header">index 513effd..d07c188 100644</span>
<span class="p_header">--- a/arch/xtensa/include/uapi/asm/unistd.h</span>
<span class="p_header">+++ b/arch/xtensa/include/uapi/asm/unistd.h</span>
<span class="p_chunk">@@ -715,7 +715,7 @@</span> <span class="p_context"> __SYSCALL(323, sys_process_vm_writev, 6)</span>
 __SYSCALL(324, sys_name_to_handle_at, 5)
 #define __NR_open_by_handle_at			325
 __SYSCALL(325, sys_open_by_handle_at, 3)
<span class="p_del">-#define __NR_sync_file_range			326</span>
<span class="p_add">+#define __NR_sync_file_range2			326</span>
 __SYSCALL(326, sys_sync_file_range2, 6)
 #define __NR_perf_event_open			327
 __SYSCALL(327, sys_perf_event_open, 5)
<span class="p_header">diff --git a/arch/xtensa/platforms/iss/network.c b/arch/xtensa/platforms/iss/network.c</span>
<span class="p_header">index e9e1aad..37141c8 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/iss/network.c</span>
<span class="p_header">+++ b/arch/xtensa/platforms/iss/network.c</span>
<span class="p_chunk">@@ -395,10 +395,10 @@</span> <span class="p_context"> static void iss_net_timer(unsigned long priv)</span>
 {
 	struct iss_net_private* lp = (struct iss_net_private*) priv;
 
<span class="p_del">-	spin_lock(&amp;lp-&gt;lock);</span>
<span class="p_del">-</span>
 	iss_net_poll();
 
<span class="p_add">+	spin_lock(&amp;lp-&gt;lock);</span>
<span class="p_add">+</span>
 	mod_timer(&amp;lp-&gt;timer, jiffies + lp-&gt;timer_val);
 
 	spin_unlock(&amp;lp-&gt;lock);
<span class="p_chunk">@@ -411,7 +411,7 @@</span> <span class="p_context"> static int iss_net_open(struct net_device *dev)</span>
 	char addr[sizeof &quot;255.255.255.255\0&quot;];
 	int err;
 
<span class="p_del">-	spin_lock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;lp-&gt;lock);</span>
 
 	if ((err = lp-&gt;tp.open(lp)) &lt; 0)
 		goto out;
<span class="p_chunk">@@ -430,9 +430,11 @@</span> <span class="p_context"> static int iss_net_open(struct net_device *dev)</span>
 	while ((err = iss_net_rx(dev)) &gt; 0)
 		;
 
<span class="p_del">-	spin_lock(&amp;opened_lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;opened_lock);</span>
 	list_add(&amp;lp-&gt;opened_list, &amp;opened);
<span class="p_del">-	spin_unlock(&amp;opened_lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;opened_lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;lp-&gt;lock);</span>
 
 	init_timer(&amp;lp-&gt;timer);
 	lp-&gt;timer_val = ISS_NET_TIMER_VALUE;
<span class="p_chunk">@@ -441,7 +443,7 @@</span> <span class="p_context"> static int iss_net_open(struct net_device *dev)</span>
 	mod_timer(&amp;lp-&gt;timer, jiffies + lp-&gt;timer_val);
 
 out:
<span class="p_del">-	spin_unlock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;lp-&gt;lock);</span>
 	return err;
 }
 
<span class="p_chunk">@@ -450,7 +452,7 @@</span> <span class="p_context"> static int iss_net_close(struct net_device *dev)</span>
 	struct iss_net_private *lp = netdev_priv(dev);
 printk(&quot;iss_net_close!\n&quot;);
 	netif_stop_queue(dev);
<span class="p_del">-	spin_lock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;lp-&gt;lock);</span>
 
 	spin_lock(&amp;opened_lock);
 	list_del(&amp;opened);
<span class="p_chunk">@@ -460,18 +462,17 @@</span> <span class="p_context"> printk(&quot;iss_net_close!\n&quot;);</span>
 
 	lp-&gt;tp.close(lp);
 
<span class="p_del">-	spin_unlock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;lp-&gt;lock);</span>
 	return 0;
 }
 
 static int iss_net_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct iss_net_private *lp = netdev_priv(dev);
<span class="p_del">-	unsigned long flags;</span>
 	int len;
 
 	netif_stop_queue(dev);
<span class="p_del">-	spin_lock_irqsave(&amp;lp-&gt;lock, flags);</span>
<span class="p_add">+	spin_lock_bh(&amp;lp-&gt;lock);</span>
 
 	len = lp-&gt;tp.write(lp, &amp;skb);
 
<span class="p_chunk">@@ -493,7 +494,7 @@</span> <span class="p_context"> static int iss_net_start_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 		printk(KERN_ERR &quot;iss_net_start_xmit: failed(%d)\n&quot;, len);
 	}
 
<span class="p_del">-	spin_unlock_irqrestore(&amp;lp-&gt;lock, flags);</span>
<span class="p_add">+	spin_unlock_bh(&amp;lp-&gt;lock);</span>
 
 	dev_kfree_skb(skb);
 	return NETDEV_TX_OK;
<span class="p_chunk">@@ -532,9 +533,9 @@</span> <span class="p_context"> static int iss_net_set_mac(struct net_device *dev, void *addr)</span>
 	struct iss_net_private *lp = netdev_priv(dev);
 	struct sockaddr *hwaddr = addr;
 
<span class="p_del">-	spin_lock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;lp-&gt;lock);</span>
 	memcpy(dev-&gt;dev_addr, hwaddr-&gt;sa_data, ETH_ALEN);
<span class="p_del">-	spin_unlock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;lp-&gt;lock);</span>
 #endif
 
 	return 0;
<span class="p_chunk">@@ -604,14 +605,14 @@</span> <span class="p_context"> static int iss_net_configure(int index, char *init)</span>
 	*lp = ((struct iss_net_private) {
 		.device_list		= LIST_HEAD_INIT(lp-&gt;device_list),
 		.opened_list		= LIST_HEAD_INIT(lp-&gt;opened_list),
<span class="p_del">-		.lock			= __SPIN_LOCK_UNLOCKED(lp.lock),</span>
 		.dev			= dev,
 		.index			= index,
 		//.fd                   = -1,
 		.mac			= { 0xfe, 0xfd, 0x0, 0x0, 0x0, 0x0 },
 		.have_mac		= 0,
<span class="p_del">-		});</span>
<span class="p_add">+	});</span>
 
<span class="p_add">+	spin_lock_init(&amp;lp-&gt;lock);</span>
 	/*
 	 * Try all transport protocols.
 	 * Note: more protocols can be added by adding &#39;&amp;&amp; !X_init(lp, eth)&#39;.
<span class="p_header">diff --git a/arch/xtensa/platforms/xtfpga/Makefile b/arch/xtensa/platforms/xtfpga/Makefile</span>
<span class="p_header">index b9ae206..7839d38 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xtfpga/Makefile</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xtfpga/Makefile</span>
<span class="p_chunk">@@ -6,4 +6,5 @@</span> <span class="p_context"></span>
 #
 # Note 2! The CFLAGS definitions are in the main makefile...
 
<span class="p_del">-obj-y			= setup.o lcd.o</span>
<span class="p_add">+obj-y			+= setup.o</span>
<span class="p_add">+obj-$(CONFIG_XTFPGA_LCD) += lcd.o</span>
<span class="p_header">diff --git a/arch/xtensa/platforms/xtfpga/include/platform/hardware.h b/arch/xtensa/platforms/xtfpga/include/platform/hardware.h</span>
<span class="p_header">index 4416773..b39fbcf 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xtfpga/include/platform/hardware.h</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xtfpga/include/platform/hardware.h</span>
<span class="p_chunk">@@ -44,9 +44,6 @@</span> <span class="p_context"></span>
 
 /* UART */
 #define DUART16552_PADDR	(XCHAL_KIO_PADDR + 0x0D050020)
<span class="p_del">-/* LCD instruction and data addresses. */</span>
<span class="p_del">-#define LCD_INSTR_ADDR		((char *)IOADDR(0x0D040000))</span>
<span class="p_del">-#define LCD_DATA_ADDR		((char *)IOADDR(0x0D040004))</span>
 
 /* Misc. */
 #define XTFPGA_FPGAREGS_VADDR	IOADDR(0x0D020000)
<span class="p_header">diff --git a/arch/xtensa/platforms/xtfpga/include/platform/lcd.h b/arch/xtensa/platforms/xtfpga/include/platform/lcd.h</span>
<span class="p_header">index 0e43564..4c8541e 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xtfpga/include/platform/lcd.h</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xtfpga/include/platform/lcd.h</span>
<span class="p_chunk">@@ -11,10 +11,25 @@</span> <span class="p_context"></span>
 #ifndef __XTENSA_XTAVNET_LCD_H
 #define __XTENSA_XTAVNET_LCD_H
 
<span class="p_add">+#ifdef CONFIG_XTFPGA_LCD</span>
 /* Display string STR at position POS on the LCD. */
 void lcd_disp_at_pos(char *str, unsigned char pos);
 
 /* Shift the contents of the LCD display left or right. */
 void lcd_shiftleft(void);
 void lcd_shiftright(void);
<span class="p_add">+#else</span>
<span class="p_add">+static inline void lcd_disp_at_pos(char *str, unsigned char pos)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void lcd_shiftleft(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void lcd_shiftright(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/arch/xtensa/platforms/xtfpga/lcd.c b/arch/xtensa/platforms/xtfpga/lcd.c</span>
<span class="p_header">index 2872301..4dc0c1b 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xtfpga/lcd.c</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xtfpga/lcd.c</span>
<span class="p_chunk">@@ -1,50 +1,63 @@</span> <span class="p_context"></span>
 /*
<span class="p_del">- * Driver for the LCD display on the Tensilica LX60 Board.</span>
<span class="p_add">+ * Driver for the LCD display on the Tensilica XTFPGA board family.</span>
<span class="p_add">+ * http://www.mytechcorp.com/cfdata/productFile/File1/MOC-16216B-B-A0A04.pdf</span>
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file &quot;COPYING&quot; in the main directory of this archive
  * for more details.
  *
  * Copyright (C) 2001, 2006 Tensilica Inc.
<span class="p_add">+ * Copyright (C) 2015 Cadence Design Systems Inc.</span>
  */
 
<span class="p_del">-/*</span>
<span class="p_del">- *</span>
<span class="p_del">- * FIXME: this code is from the examples from the LX60 user guide.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The lcd_pause function does busy waiting, which is probably not</span>
<span class="p_del">- * great. Maybe the code could be changed to use kernel timers, or</span>
<span class="p_del">- * change the hardware to not need to wait.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
 #include &lt;linux/init.h&gt;
 #include &lt;linux/io.h&gt;
 
 #include &lt;platform/hardware.h&gt;
 #include &lt;platform/lcd.h&gt;
<span class="p_del">-#include &lt;linux/delay.h&gt;</span>
 
<span class="p_del">-#define LCD_PAUSE_ITERATIONS	4000</span>
<span class="p_add">+/* LCD instruction and data addresses. */</span>
<span class="p_add">+#define LCD_INSTR_ADDR		((char *)IOADDR(CONFIG_XTFPGA_LCD_BASE_ADDR))</span>
<span class="p_add">+#define LCD_DATA_ADDR		(LCD_INSTR_ADDR + 4)</span>
<span class="p_add">+</span>
 #define LCD_CLEAR		0x1
 #define LCD_DISPLAY_ON		0xc
 
 /* 8bit and 2 lines display */
 #define LCD_DISPLAY_MODE8BIT	0x38
<span class="p_add">+#define LCD_DISPLAY_MODE4BIT	0x28</span>
 #define LCD_DISPLAY_POS		0x80
 #define LCD_SHIFT_LEFT		0x18
 #define LCD_SHIFT_RIGHT		0x1c
 
<span class="p_add">+static void lcd_put_byte(u8 *addr, u8 data)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_XTFPGA_LCD_8BIT_ACCESS</span>
<span class="p_add">+	ACCESS_ONCE(*addr) = data;</span>
<span class="p_add">+#else</span>
<span class="p_add">+	ACCESS_ONCE(*addr) = data &amp; 0xf0;</span>
<span class="p_add">+	ACCESS_ONCE(*addr) = (data &lt;&lt; 4) &amp; 0xf0;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int __init lcd_init(void)
 {
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE8BIT;</span>
 	mdelay(5);
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE8BIT;</span>
 	udelay(200);
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	udelay(50);</span>
<span class="p_add">+#ifndef CONFIG_XTFPGA_LCD_8BIT_ACCESS</span>
<span class="p_add">+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE4BIT;</span>
<span class="p_add">+	udelay(50);</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_DISPLAY_MODE4BIT);</span>
 	udelay(50);
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_ON;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_DISPLAY_ON);</span>
 	udelay(50);
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_CLEAR;</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_CLEAR);</span>
 	mdelay(10);
 	lcd_disp_at_pos(&quot;XTENSA LINUX&quot;, 0);
 	return 0;
<span class="p_chunk">@@ -52,10 +65,10 @@</span> <span class="p_context"> static int __init lcd_init(void)</span>
 
 void lcd_disp_at_pos(char *str, unsigned char pos)
 {
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_POS | pos;</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_DISPLAY_POS | pos);</span>
 	udelay(100);
 	while (*str != 0) {
<span class="p_del">-		*LCD_DATA_ADDR = *str;</span>
<span class="p_add">+		lcd_put_byte(LCD_DATA_ADDR, *str);</span>
 		udelay(200);
 		str++;
 	}
<span class="p_chunk">@@ -63,13 +76,13 @@</span> <span class="p_context"> void lcd_disp_at_pos(char *str, unsigned char pos)</span>
 
 void lcd_shiftleft(void)
 {
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_SHIFT_LEFT;</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_SHIFT_LEFT);</span>
 	udelay(50);
 }
 
 void lcd_shiftright(void)
 {
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_SHIFT_RIGHT;</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_SHIFT_RIGHT);</span>
 	udelay(50);
 }
 
<span class="p_header">diff --git a/drivers/base/bus.c b/drivers/base/bus.c</span>
<span class="p_header">index a7ce942..ad0b4b5 100644</span>
<span class="p_header">--- a/drivers/base/bus.c</span>
<span class="p_header">+++ b/drivers/base/bus.c</span>
<span class="p_chunk">@@ -504,11 +504,11 @@</span> <span class="p_context"> int bus_add_device(struct device *dev)</span>
 			goto out_put;
 		error = device_add_groups(dev, bus-&gt;dev_groups);
 		if (error)
<span class="p_del">-			goto out_groups;</span>
<span class="p_add">+			goto out_id;</span>
 		error = sysfs_create_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj,
 						&amp;dev-&gt;kobj, dev_name(dev));
 		if (error)
<span class="p_del">-			goto out_id;</span>
<span class="p_add">+			goto out_groups;</span>
 		error = sysfs_create_link(&amp;dev-&gt;kobj,
 				&amp;dev-&gt;bus-&gt;p-&gt;subsys.kobj, &quot;subsystem&quot;);
 		if (error)
<span class="p_header">diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c</span>
<span class="p_header">index 0fd0537..3266347 100644</span>
<span class="p_header">--- a/drivers/bluetooth/ath3k.c</span>
<span class="p_header">+++ b/drivers/bluetooth/ath3k.c</span>
<span class="p_chunk">@@ -64,6 +64,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_table[] = {</span>
 	/* Atheros AR3011 with sflash firmware*/
 	{ USB_DEVICE(0x0489, 0xE027) },
 	{ USB_DEVICE(0x0489, 0xE03D) },
<span class="p_add">+	{ USB_DEVICE(0x04F2, 0xAFF1) },</span>
 	{ USB_DEVICE(0x0930, 0x0215) },
 	{ USB_DEVICE(0x0CF3, 0x3002) },
 	{ USB_DEVICE(0x0CF3, 0xE019) },
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index 6e6c597..3171710 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -142,6 +142,7 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 	/* Atheros 3011 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xe027), .driver_info = BTUSB_IGNORE },
 	{ USB_DEVICE(0x0489, 0xe03d), .driver_info = BTUSB_IGNORE },
<span class="p_add">+	{ USB_DEVICE(0x04f2, 0xaff1), .driver_info = BTUSB_IGNORE },</span>
 	{ USB_DEVICE(0x0930, 0x0215), .driver_info = BTUSB_IGNORE },
 	{ USB_DEVICE(0x0cf3, 0x3002), .driver_info = BTUSB_IGNORE },
 	{ USB_DEVICE(0x0cf3, 0xe019), .driver_info = BTUSB_IGNORE },
<span class="p_header">diff --git a/drivers/crypto/omap-aes.c b/drivers/crypto/omap-aes.c</span>
<span class="p_header">index a9ccbf1..97ba5bd 100644</span>
<span class="p_header">--- a/drivers/crypto/omap-aes.c</span>
<span class="p_header">+++ b/drivers/crypto/omap-aes.c</span>
<span class="p_chunk">@@ -554,15 +554,23 @@</span> <span class="p_context"> static int omap_aes_crypt_dma_stop(struct omap_aes_dev *dd)</span>
 	return err;
 }
 
<span class="p_del">-static int omap_aes_check_aligned(struct scatterlist *sg)</span>
<span class="p_add">+static int omap_aes_check_aligned(struct scatterlist *sg, int total)</span>
 {
<span class="p_add">+	int len = 0;</span>
<span class="p_add">+</span>
 	while (sg) {
 		if (!IS_ALIGNED(sg-&gt;offset, 4))
 			return -1;
 		if (!IS_ALIGNED(sg-&gt;length, AES_BLOCK_SIZE))
 			return -1;
<span class="p_add">+</span>
<span class="p_add">+		len += sg-&gt;length;</span>
 		sg = sg_next(sg);
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (len != total)</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -633,8 +641,8 @@</span> <span class="p_context"> static int omap_aes_handle_queue(struct omap_aes_dev *dd,</span>
 	dd-&gt;in_sg = req-&gt;src;
 	dd-&gt;out_sg = req-&gt;dst;
 
<span class="p_del">-	if (omap_aes_check_aligned(dd-&gt;in_sg) ||</span>
<span class="p_del">-	    omap_aes_check_aligned(dd-&gt;out_sg)) {</span>
<span class="p_add">+	if (omap_aes_check_aligned(dd-&gt;in_sg, dd-&gt;total) ||</span>
<span class="p_add">+	    omap_aes_check_aligned(dd-&gt;out_sg, dd-&gt;total)) {</span>
 		if (omap_aes_copy_sgs(dd))
 			pr_err(&quot;Failed to copy SGs for unaligned cases\n&quot;);
 		dd-&gt;sgs_copied = 1;
<span class="p_header">diff --git a/drivers/gpio/gpio-mvebu.c b/drivers/gpio/gpio-mvebu.c</span>
<span class="p_header">index db31290..5eaafc8 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-mvebu.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-mvebu.c</span>
<span class="p_chunk">@@ -304,11 +304,13 @@</span> <span class="p_context"> static void mvebu_gpio_edge_irq_mask(struct irq_data *d)</span>
 {
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct mvebu_gpio_chip *mvchip = gc-&gt;private;
<span class="p_add">+	struct irq_chip_type *ct = irq_data_get_chip_type(d);</span>
 	u32 mask = 1 &lt;&lt; (d-&gt;irq - gc-&gt;irq_base);
 
 	irq_gc_lock(gc);
<span class="p_del">-	gc-&gt;mask_cache &amp;= ~mask;</span>
<span class="p_del">-	writel_relaxed(gc-&gt;mask_cache, mvebu_gpioreg_edge_mask(mvchip));</span>
<span class="p_add">+	ct-&gt;mask_cache_priv &amp;= ~mask;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(ct-&gt;mask_cache_priv, mvebu_gpioreg_edge_mask(mvchip));</span>
 	irq_gc_unlock(gc);
 }
 
<span class="p_chunk">@@ -316,11 +318,13 @@</span> <span class="p_context"> static void mvebu_gpio_edge_irq_unmask(struct irq_data *d)</span>
 {
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct mvebu_gpio_chip *mvchip = gc-&gt;private;
<span class="p_add">+	struct irq_chip_type *ct = irq_data_get_chip_type(d);</span>
<span class="p_add">+</span>
 	u32 mask = 1 &lt;&lt; (d-&gt;irq - gc-&gt;irq_base);
 
 	irq_gc_lock(gc);
<span class="p_del">-	gc-&gt;mask_cache |= mask;</span>
<span class="p_del">-	writel_relaxed(gc-&gt;mask_cache, mvebu_gpioreg_edge_mask(mvchip));</span>
<span class="p_add">+	ct-&gt;mask_cache_priv |= mask;</span>
<span class="p_add">+	writel_relaxed(ct-&gt;mask_cache_priv, mvebu_gpioreg_edge_mask(mvchip));</span>
 	irq_gc_unlock(gc);
 }
 
<span class="p_chunk">@@ -328,11 +332,13 @@</span> <span class="p_context"> static void mvebu_gpio_level_irq_mask(struct irq_data *d)</span>
 {
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct mvebu_gpio_chip *mvchip = gc-&gt;private;
<span class="p_add">+	struct irq_chip_type *ct = irq_data_get_chip_type(d);</span>
<span class="p_add">+</span>
 	u32 mask = 1 &lt;&lt; (d-&gt;irq - gc-&gt;irq_base);
 
 	irq_gc_lock(gc);
<span class="p_del">-	gc-&gt;mask_cache &amp;= ~mask;</span>
<span class="p_del">-	writel_relaxed(gc-&gt;mask_cache, mvebu_gpioreg_level_mask(mvchip));</span>
<span class="p_add">+	ct-&gt;mask_cache_priv &amp;= ~mask;</span>
<span class="p_add">+	writel_relaxed(ct-&gt;mask_cache_priv, mvebu_gpioreg_level_mask(mvchip));</span>
 	irq_gc_unlock(gc);
 }
 
<span class="p_chunk">@@ -340,11 +346,13 @@</span> <span class="p_context"> static void mvebu_gpio_level_irq_unmask(struct irq_data *d)</span>
 {
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct mvebu_gpio_chip *mvchip = gc-&gt;private;
<span class="p_add">+	struct irq_chip_type *ct = irq_data_get_chip_type(d);</span>
<span class="p_add">+</span>
 	u32 mask = 1 &lt;&lt; (d-&gt;irq - gc-&gt;irq_base);
 
 	irq_gc_lock(gc);
<span class="p_del">-	gc-&gt;mask_cache |= mask;</span>
<span class="p_del">-	writel_relaxed(gc-&gt;mask_cache, mvebu_gpioreg_level_mask(mvchip));</span>
<span class="p_add">+	ct-&gt;mask_cache_priv |= mask;</span>
<span class="p_add">+	writel_relaxed(ct-&gt;mask_cache_priv, mvebu_gpioreg_level_mask(mvchip));</span>
 	irq_gc_unlock(gc);
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_irq.c b/drivers/gpu/drm/i915/i915_irq.c</span>
<span class="p_header">index 5d28e06..dc79f38 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_irq.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_irq.c</span>
<span class="p_chunk">@@ -3130,14 +3130,12 @@</span> <span class="p_context"> static int i8xx_irq_postinstall(struct drm_device *dev)</span>
 		~(I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |
 		  I915_DISPLAY_PIPE_B_EVENT_INTERRUPT |
 		  I915_DISPLAY_PLANE_A_FLIP_PENDING_INTERRUPT |
<span class="p_del">-		  I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT |</span>
<span class="p_del">-		  I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT);</span>
<span class="p_add">+		  I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT);</span>
 	I915_WRITE16(IMR, dev_priv-&gt;irq_mask);
 
 	I915_WRITE16(IER,
 		     I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |
 		     I915_DISPLAY_PIPE_B_EVENT_INTERRUPT |
<span class="p_del">-		     I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT |</span>
 		     I915_USER_INTERRUPT);
 	POSTING_READ16(IER);
 
<span class="p_chunk">@@ -3301,14 +3299,12 @@</span> <span class="p_context"> static int i915_irq_postinstall(struct drm_device *dev)</span>
 		  I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |
 		  I915_DISPLAY_PIPE_B_EVENT_INTERRUPT |
 		  I915_DISPLAY_PLANE_A_FLIP_PENDING_INTERRUPT |
<span class="p_del">-		  I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT |</span>
<span class="p_del">-		  I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT);</span>
<span class="p_add">+		  I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT);</span>
 
 	enable_mask =
 		I915_ASLE_INTERRUPT |
 		I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |
 		I915_DISPLAY_PIPE_B_EVENT_INTERRUPT |
<span class="p_del">-		I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT |</span>
 		I915_USER_INTERRUPT;
 
 	if (I915_HAS_HOTPLUG(dev)) {
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_reg.h b/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_header">index 1711e36..b4fde80 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_chunk">@@ -1181,6 +1181,7 @@</span> <span class="p_context"></span>
 #define   GMBUS_CYCLE_INDEX	(2&lt;&lt;25)
 #define   GMBUS_CYCLE_STOP	(4&lt;&lt;25)
 #define   GMBUS_BYTE_COUNT_SHIFT 16
<span class="p_add">+#define   GMBUS_BYTE_COUNT_MAX   256U</span>
 #define   GMBUS_SLAVE_INDEX_SHIFT 8
 #define   GMBUS_SLAVE_ADDR_SHIFT 1
 #define   GMBUS_SLAVE_READ	(1&lt;&lt;0)
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_i2c.c b/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_header">index 2ca17b1..e38c5d3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_chunk">@@ -340,18 +340,17 @@</span> <span class="p_context"> gmbus_wait_idle(struct drm_i915_private *dev_priv)</span>
 }
 
 static int
<span class="p_del">-gmbus_xfer_read(struct drm_i915_private *dev_priv, struct i2c_msg *msg,</span>
<span class="p_del">-		u32 gmbus1_index)</span>
<span class="p_add">+gmbus_xfer_read_chunk(struct drm_i915_private *dev_priv,</span>
<span class="p_add">+		      unsigned short addr, u8 *buf, unsigned int len,</span>
<span class="p_add">+		      u32 gmbus1_index)</span>
 {
 	int reg_offset = dev_priv-&gt;gpio_mmio_base;
<span class="p_del">-	u16 len = msg-&gt;len;</span>
<span class="p_del">-	u8 *buf = msg-&gt;buf;</span>
 
 	I915_WRITE(GMBUS1 + reg_offset,
 		   gmbus1_index |
 		   GMBUS_CYCLE_WAIT |
 		   (len &lt;&lt; GMBUS_BYTE_COUNT_SHIFT) |
<span class="p_del">-		   (msg-&gt;addr &lt;&lt; GMBUS_SLAVE_ADDR_SHIFT) |</span>
<span class="p_add">+		   (addr &lt;&lt; GMBUS_SLAVE_ADDR_SHIFT) |</span>
 		   GMBUS_SLAVE_READ | GMBUS_SW_RDY);
 	while (len) {
 		int ret;
<span class="p_chunk">@@ -373,11 +372,35 @@</span> <span class="p_context"> gmbus_xfer_read(struct drm_i915_private *dev_priv, struct i2c_msg *msg,</span>
 }
 
 static int
<span class="p_del">-gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)</span>
<span class="p_add">+gmbus_xfer_read(struct drm_i915_private *dev_priv, struct i2c_msg *msg,</span>
<span class="p_add">+		u32 gmbus1_index)</span>
 {
<span class="p_del">-	int reg_offset = dev_priv-&gt;gpio_mmio_base;</span>
<span class="p_del">-	u16 len = msg-&gt;len;</span>
 	u8 *buf = msg-&gt;buf;
<span class="p_add">+	unsigned int rx_size = msg-&gt;len;</span>
<span class="p_add">+	unsigned int len;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		len = min(rx_size, GMBUS_BYTE_COUNT_MAX);</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = gmbus_xfer_read_chunk(dev_priv, msg-&gt;addr,</span>
<span class="p_add">+					    buf, len, gmbus1_index);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		rx_size -= len;</span>
<span class="p_add">+		buf += len;</span>
<span class="p_add">+	} while (rx_size != 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int</span>
<span class="p_add">+gmbus_xfer_write_chunk(struct drm_i915_private *dev_priv,</span>
<span class="p_add">+		       unsigned short addr, u8 *buf, unsigned int len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int reg_offset = dev_priv-&gt;gpio_mmio_base;</span>
<span class="p_add">+	unsigned int chunk_size = len;</span>
 	u32 val, loop;
 
 	val = loop = 0;
<span class="p_chunk">@@ -389,8 +412,8 @@</span> <span class="p_context"> gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)</span>
 	I915_WRITE(GMBUS3 + reg_offset, val);
 	I915_WRITE(GMBUS1 + reg_offset,
 		   GMBUS_CYCLE_WAIT |
<span class="p_del">-		   (msg-&gt;len &lt;&lt; GMBUS_BYTE_COUNT_SHIFT) |</span>
<span class="p_del">-		   (msg-&gt;addr &lt;&lt; GMBUS_SLAVE_ADDR_SHIFT) |</span>
<span class="p_add">+		   (chunk_size &lt;&lt; GMBUS_BYTE_COUNT_SHIFT) |</span>
<span class="p_add">+		   (addr &lt;&lt; GMBUS_SLAVE_ADDR_SHIFT) |</span>
 		   GMBUS_SLAVE_WRITE | GMBUS_SW_RDY);
 	while (len) {
 		int ret;
<span class="p_chunk">@@ -407,6 +430,29 @@</span> <span class="p_context"> gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)</span>
 		if (ret)
 			return ret;
 	}
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int</span>
<span class="p_add">+gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 *buf = msg-&gt;buf;</span>
<span class="p_add">+	unsigned int tx_size = msg-&gt;len;</span>
<span class="p_add">+	unsigned int len;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		len = min(tx_size, GMBUS_BYTE_COUNT_MAX);</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = gmbus_xfer_write_chunk(dev_priv, msg-&gt;addr, buf, len);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		buf += len;</span>
<span class="p_add">+		tx_size -= len;</span>
<span class="p_add">+	} while (tx_size != 0);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_crtc.c b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">index b9b5834..b119329 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_chunk">@@ -330,8 +330,10 @@</span> <span class="p_context"> atombios_set_crtc_dtd_timing(struct drm_crtc *crtc,</span>
 		misc |= ATOM_COMPOSITESYNC;
 	if (mode-&gt;flags &amp; DRM_MODE_FLAG_INTERLACE)
 		misc |= ATOM_INTERLACE;
<span class="p_del">-	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLCLK)</span>
 		misc |= ATOM_DOUBLE_CLOCK_MODE;
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+		misc |= ATOM_H_REPLICATIONBY2 | ATOM_V_REPLICATIONBY2;</span>
 
 	args.susModeMiscInfo.usAccess = cpu_to_le16(misc);
 	args.ucCRTC = radeon_crtc-&gt;crtc_id;
<span class="p_chunk">@@ -374,8 +376,10 @@</span> <span class="p_context"> static void atombios_crtc_set_timing(struct drm_crtc *crtc,</span>
 		misc |= ATOM_COMPOSITESYNC;
 	if (mode-&gt;flags &amp; DRM_MODE_FLAG_INTERLACE)
 		misc |= ATOM_INTERLACE;
<span class="p_del">-	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLCLK)</span>
 		misc |= ATOM_DOUBLE_CLOCK_MODE;
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+		misc |= ATOM_H_REPLICATIONBY2 | ATOM_V_REPLICATIONBY2;</span>
 
 	args.susModeMiscInfo.usAccess = cpu_to_le16(misc);
 	args.ucCRTC = radeon_crtc-&gt;crtc_id;
<span class="p_header">diff --git a/drivers/hv/channel.c b/drivers/hv/channel.c</span>
<span class="p_header">index cf1e49b..433f780 100644</span>
<span class="p_header">--- a/drivers/hv/channel.c</span>
<span class="p_header">+++ b/drivers/hv/channel.c</span>
<span class="p_chunk">@@ -134,7 +134,7 @@</span> <span class="p_context"> int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,</span>
 			   GFP_KERNEL);
 	if (!open_info) {
 		err = -ENOMEM;
<span class="p_del">-		goto error0;</span>
<span class="p_add">+		goto error_gpadl;</span>
 	}
 
 	init_completion(&amp;open_info-&gt;waitevent);
<span class="p_chunk">@@ -150,7 +150,7 @@</span> <span class="p_context"> int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,</span>
 
 	if (userdatalen &gt; MAX_USER_DEFINED_BYTES) {
 		err = -EINVAL;
<span class="p_del">-		goto error0;</span>
<span class="p_add">+		goto error_gpadl;</span>
 	}
 
 	if (userdatalen)
<span class="p_chunk">@@ -194,6 +194,9 @@</span> <span class="p_context"> error1:</span>
 	list_del(&amp;open_info-&gt;msglistentry);
 	spin_unlock_irqrestore(&amp;vmbus_connection.channelmsg_lock, flags);
 
<span class="p_add">+error_gpadl:</span>
<span class="p_add">+	vmbus_teardown_gpadl(newchannel, newchannel-&gt;ringbuffer_gpadlhandle);</span>
<span class="p_add">+</span>
 error0:
 	free_pages((unsigned long)out,
 		get_order(send_ringbuffer_size + recv_ringbuffer_size));
<span class="p_header">diff --git a/drivers/hv/channel_mgmt.c b/drivers/hv/channel_mgmt.c</span>
<span class="p_header">index 505fe29..8c24881 100644</span>
<span class="p_header">--- a/drivers/hv/channel_mgmt.c</span>
<span class="p_header">+++ b/drivers/hv/channel_mgmt.c</span>
<span class="p_chunk">@@ -716,7 +716,7 @@</span> <span class="p_context"> int vmbus_request_offers(void)</span>
 {
 	struct vmbus_channel_message_header *msg;
 	struct vmbus_channel_msginfo *msginfo;
<span class="p_del">-	int ret, t;</span>
<span class="p_add">+	int ret;</span>
 
 	msginfo = kmalloc(sizeof(*msginfo) +
 			  sizeof(struct vmbus_channel_message_header),
<span class="p_chunk">@@ -724,8 +724,6 @@</span> <span class="p_context"> int vmbus_request_offers(void)</span>
 	if (!msginfo)
 		return -ENOMEM;
 
<span class="p_del">-	init_completion(&amp;msginfo-&gt;waitevent);</span>
<span class="p_del">-</span>
 	msg = (struct vmbus_channel_message_header *)msginfo-&gt;msg;
 
 	msg-&gt;msgtype = CHANNELMSG_REQUESTOFFERS;
<span class="p_chunk">@@ -739,14 +737,6 @@</span> <span class="p_context"> int vmbus_request_offers(void)</span>
 		goto cleanup;
 	}
 
<span class="p_del">-	t = wait_for_completion_timeout(&amp;msginfo-&gt;waitevent, 5*HZ);</span>
<span class="p_del">-	if (t == 0) {</span>
<span class="p_del">-		ret = -ETIMEDOUT;</span>
<span class="p_del">-		goto cleanup;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
 cleanup:
 	kfree(msginfo);
 
<span class="p_header">diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c</span>
<span class="p_header">index d74c0b3..8f5f11a 100644</span>
<span class="p_header">--- a/drivers/i2c/i2c-core.c</span>
<span class="p_header">+++ b/drivers/i2c/i2c-core.c</span>
<span class="p_chunk">@@ -212,6 +212,7 @@</span> <span class="p_context"> int i2c_generic_scl_recovery(struct i2c_adapter *adap)</span>
 	adap-&gt;bus_recovery_info-&gt;set_scl(adap, 1);
 	return i2c_generic_recovery(adap);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(i2c_generic_scl_recovery);</span>
 
 int i2c_generic_gpio_recovery(struct i2c_adapter *adap)
 {
<span class="p_chunk">@@ -226,6 +227,7 @@</span> <span class="p_context"> int i2c_generic_gpio_recovery(struct i2c_adapter *adap)</span>
 
 	return ret;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(i2c_generic_gpio_recovery);</span>
 
 int i2c_recover_bus(struct i2c_adapter *adap)
 {
<span class="p_chunk">@@ -235,6 +237,7 @@</span> <span class="p_context"> int i2c_recover_bus(struct i2c_adapter *adap)</span>
 	dev_dbg(&amp;adap-&gt;dev, &quot;Trying i2c bus recovery\n&quot;);
 	return adap-&gt;bus_recovery_info-&gt;recover_bus(adap);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(i2c_recover_bus);</span>
 
 static int i2c_device_probe(struct device *dev)
 {
<span class="p_header">diff --git a/drivers/infiniband/core/umem.c b/drivers/infiniband/core/umem.c</span>
<span class="p_header">index 055ebeb..c1fef27 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/umem.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/umem.c</span>
<span class="p_chunk">@@ -94,12 +94,15 @@</span> <span class="p_context"> struct ib_umem *ib_umem_get(struct ib_ucontext *context, unsigned long addr,</span>
 	if (dmasync)
 		dma_set_attr(DMA_ATTR_WRITE_BARRIER, &amp;attrs);
 
<span class="p_add">+	if (!size)</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
 	/*
 	 * If the combination of the addr and size requested for this memory
 	 * region causes an integer overflow, return error.
 	 */
<span class="p_del">-	if ((PAGE_ALIGN(addr + size) &lt;= size) ||</span>
<span class="p_del">-	    (PAGE_ALIGN(addr + size) &lt;= addr))</span>
<span class="p_add">+	if (((addr + size) &lt; addr) ||</span>
<span class="p_add">+	    PAGE_ALIGN(addr + size) &lt; (addr + size))</span>
 		return ERR_PTR(-EINVAL);
 
 	if (!can_do_mlock())
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">index 4f10af2..262a184 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_chunk">@@ -2174,8 +2174,7 @@</span> <span class="p_context"> static int build_lso_seg(struct mlx4_wqe_lso_seg *wqe, struct ib_send_wr *wr,</span>
 
 	memcpy(wqe-&gt;header, wr-&gt;wr.ud.header, wr-&gt;wr.ud.hlen);
 
<span class="p_del">-	*lso_hdr_sz  = cpu_to_be32((wr-&gt;wr.ud.mss - wr-&gt;wr.ud.hlen) &lt;&lt; 16 |</span>
<span class="p_del">-				   wr-&gt;wr.ud.hlen);</span>
<span class="p_add">+	*lso_hdr_sz  = cpu_to_be32(wr-&gt;wr.ud.mss &lt;&lt; 16 | wr-&gt;wr.ud.hlen);</span>
 	*lso_seg_len = halign;
 	return 0;
 }
<span class="p_header">diff --git a/drivers/infiniband/ulp/isert/ib_isert.c b/drivers/infiniband/ulp/isert/ib_isert.c</span>
<span class="p_header">index a1f194b..bd470fd 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/isert/ib_isert.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/isert/ib_isert.c</span>
<span class="p_chunk">@@ -206,7 +206,7 @@</span> <span class="p_context"> fail:</span>
 static void
 isert_free_rx_descriptors(struct isert_conn *isert_conn)
 {
<span class="p_del">-	struct ib_device *ib_dev = isert_conn-&gt;conn_cm_id-&gt;device;</span>
<span class="p_add">+	struct ib_device *ib_dev = isert_conn-&gt;conn_device-&gt;ib_device;</span>
 	struct iser_rx_desc *rx_desc;
 	int i;
 
<span class="p_chunk">@@ -629,8 +629,8 @@</span> <span class="p_context"> out:</span>
 static void
 isert_connect_release(struct isert_conn *isert_conn)
 {
<span class="p_del">-	struct ib_device *ib_dev = isert_conn-&gt;conn_cm_id-&gt;device;</span>
 	struct isert_device *device = isert_conn-&gt;conn_device;
<span class="p_add">+	struct ib_device *ib_dev = device-&gt;ib_device;</span>
 	int cq_index;
 
 	pr_debug(&quot;Entering isert_connect_release(): &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n&quot;);
<span class="p_chunk">@@ -639,7 +639,8 @@</span> <span class="p_context"> isert_connect_release(struct isert_conn *isert_conn)</span>
 		isert_conn_free_frwr_pool(isert_conn);
 
 	isert_free_rx_descriptors(isert_conn);
<span class="p_del">-	rdma_destroy_id(isert_conn-&gt;conn_cm_id);</span>
<span class="p_add">+	if (isert_conn-&gt;conn_cm_id)</span>
<span class="p_add">+		rdma_destroy_id(isert_conn-&gt;conn_cm_id);</span>
 
 	if (isert_conn-&gt;conn_qp) {
 		cq_index = ((struct isert_cq_desc *)
<span class="p_chunk">@@ -794,12 +795,15 @@</span> <span class="p_context"> isert_disconnected_handler(struct rdma_cm_id *cma_id,</span>
 	return 0;
 }
 
<span class="p_del">-static void</span>
<span class="p_add">+static int</span>
 isert_connect_error(struct rdma_cm_id *cma_id)
 {
 	struct isert_conn *isert_conn = cma_id-&gt;qp-&gt;qp_context;
 
<span class="p_add">+	isert_conn-&gt;conn_cm_id = NULL;</span>
 	isert_put_conn(isert_conn);
<span class="p_add">+</span>
<span class="p_add">+	return -1;</span>
 }
 
 static int
<span class="p_chunk">@@ -829,7 +833,7 @@</span> <span class="p_context"> isert_cma_handler(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)</span>
 	case RDMA_CM_EVENT_REJECTED:       /* FALLTHRU */
 	case RDMA_CM_EVENT_UNREACHABLE:    /* FALLTHRU */
 	case RDMA_CM_EVENT_CONNECT_ERROR:
<span class="p_del">-		isert_connect_error(cma_id);</span>
<span class="p_add">+		ret = isert_connect_error(cma_id);</span>
 		break;
 	default:
 		pr_err(&quot;Unhandled RDMA CMA event: %d\n&quot;, event-&gt;event);
<span class="p_header">diff --git a/drivers/input/mouse/elantech.c b/drivers/input/mouse/elantech.c</span>
<span class="p_header">index e66780e..29365c6 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.c</span>
<span class="p_chunk">@@ -814,6 +814,21 @@</span> <span class="p_context"> static psmouse_ret_t elantech_process_byte(struct psmouse *psmouse)</span>
 }
 
 /*
<span class="p_add">+ * This writes the reg_07 value again to the hardware at the end of every</span>
<span class="p_add">+ * set_rate call because the register loses its value. reg_07 allows setting</span>
<span class="p_add">+ * absolute mode on v4 hardware</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void elantech_set_rate_restore_reg_07(struct psmouse *psmouse,</span>
<span class="p_add">+		unsigned int rate)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct elantech_data *etd = psmouse-&gt;private;</span>
<span class="p_add">+</span>
<span class="p_add">+	etd-&gt;original_set_rate(psmouse, rate);</span>
<span class="p_add">+	if (elantech_write_reg(psmouse, 0x07, etd-&gt;reg_07))</span>
<span class="p_add">+		psmouse_err(psmouse, &quot;restoring reg_07 failed\n&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Put the touchpad into absolute mode
  */
 static int elantech_set_absolute_mode(struct psmouse *psmouse)
<span class="p_chunk">@@ -1015,6 +1030,8 @@</span> <span class="p_context"> static int elantech_get_resolution_v4(struct psmouse *psmouse,</span>
  * Asus K53SV              0x450f01        78, 15, 0c      2 hw buttons
  * Asus G46VW              0x460f02        00, 18, 0c      2 hw buttons
  * Asus G750JX             0x360f00        00, 16, 0c      2 hw buttons
<span class="p_add">+ * Asus TP500LN            0x381f17        10, 14, 0e      clickpad</span>
<span class="p_add">+ * Asus X750JN             0x381f17        10, 14, 0e      clickpad</span>
  * Asus UX31               0x361f00        20, 15, 0e      clickpad
  * Asus UX32VD             0x361f02        00, 15, 0e      clickpad
  * Avatar AVIU-145A2       0x361f00        ?               clickpad
<span class="p_chunk">@@ -1493,6 +1510,11 @@</span> <span class="p_context"> int elantech_init(struct psmouse *psmouse)</span>
 		goto init_fail;
 	}
 
<span class="p_add">+	if (etd-&gt;fw_version == 0x381f17) {</span>
<span class="p_add">+		etd-&gt;original_set_rate = psmouse-&gt;set_rate;</span>
<span class="p_add">+		psmouse-&gt;set_rate = elantech_set_rate_restore_reg_07;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (elantech_set_input_params(psmouse)) {
 		psmouse_err(psmouse, &quot;failed to query touchpad range.\n&quot;);
 		goto init_fail;
<span class="p_header">diff --git a/drivers/input/mouse/elantech.h b/drivers/input/mouse/elantech.h</span>
<span class="p_header">index 9e0e2a1..59263a3 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.h</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.h</span>
<span class="p_chunk">@@ -139,6 +139,7 @@</span> <span class="p_context"> struct elantech_data {</span>
 	struct finger_pos mt[ETP_MAX_FINGERS];
 	unsigned char parity[256];
 	int (*send_cmd)(struct psmouse *psmouse, unsigned char c, unsigned char *param);
<span class="p_add">+	void (*original_set_rate)(struct psmouse *psmouse, unsigned int rate);</span>
 };
 
 #ifdef CONFIG_MOUSE_PS2_ELANTECH
<span class="p_header">diff --git a/drivers/media/usb/stk1160/stk1160-v4l.c b/drivers/media/usb/stk1160/stk1160-v4l.c</span>
<span class="p_header">index c45c988..4572530 100644</span>
<span class="p_header">--- a/drivers/media/usb/stk1160/stk1160-v4l.c</span>
<span class="p_header">+++ b/drivers/media/usb/stk1160/stk1160-v4l.c</span>
<span class="p_chunk">@@ -244,6 +244,11 @@</span> <span class="p_context"> static int stk1160_stop_streaming(struct stk1160 *dev)</span>
 	if (mutex_lock_interruptible(&amp;dev-&gt;v4l_lock))
 		return -ERESTARTSYS;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Once URBs are cancelled, the URB complete handler</span>
<span class="p_add">+	 * won&#39;t be running. This is required to safely release the</span>
<span class="p_add">+	 * current buffer (dev-&gt;isoc_ctl.buf).</span>
<span class="p_add">+	 */</span>
 	stk1160_cancel_isoc(dev);
 
 	/*
<span class="p_chunk">@@ -624,8 +629,16 @@</span> <span class="p_context"> void stk1160_clear_queue(struct stk1160 *dev)</span>
 		stk1160_info(&quot;buffer [%p/%d] aborted\n&quot;,
 				buf, buf-&gt;vb.v4l2_buf.index);
 	}
<span class="p_del">-	/* It&#39;s important to clear current buffer */</span>
<span class="p_del">-	dev-&gt;isoc_ctl.buf = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* It&#39;s important to release the current buffer */</span>
<span class="p_add">+	if (dev-&gt;isoc_ctl.buf) {</span>
<span class="p_add">+		buf = dev-&gt;isoc_ctl.buf;</span>
<span class="p_add">+		dev-&gt;isoc_ctl.buf = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+		vb2_buffer_done(&amp;buf-&gt;vb, VB2_BUF_STATE_ERROR);</span>
<span class="p_add">+		stk1160_info(&quot;buffer [%p/%d] aborted\n&quot;,</span>
<span class="p_add">+				buf, buf-&gt;vb.v4l2_buf.index);</span>
<span class="p_add">+	}</span>
 	spin_unlock_irqrestore(&amp;dev-&gt;buf_lock, flags);
 }
 
<span class="p_header">diff --git a/drivers/memstick/core/mspro_block.c b/drivers/memstick/core/mspro_block.c</span>
<span class="p_header">index fc145d2..922a750 100644</span>
<span class="p_header">--- a/drivers/memstick/core/mspro_block.c</span>
<span class="p_header">+++ b/drivers/memstick/core/mspro_block.c</span>
<span class="p_chunk">@@ -758,7 +758,7 @@</span> <span class="p_context"> static int mspro_block_complete_req(struct memstick_dev *card, int error)</span>
 
 		if (error || (card-&gt;current_mrq.tpc == MSPRO_CMD_STOP)) {
 			if (msb-&gt;data_dir == READ) {
<span class="p_del">-				for (cnt = 0; cnt &lt; msb-&gt;current_seg; cnt++)</span>
<span class="p_add">+				for (cnt = 0; cnt &lt; msb-&gt;current_seg; cnt++) {</span>
 					t_len += msb-&gt;req_sg[cnt].length
 						 / msb-&gt;page_size;
 
<span class="p_chunk">@@ -766,6 +766,7 @@</span> <span class="p_context"> static int mspro_block_complete_req(struct memstick_dev *card, int error)</span>
 						t_len += msb-&gt;current_page - 1;
 
 					t_len *= msb-&gt;page_size;
<span class="p_add">+				}</span>
 			}
 		} else
 			t_len = blk_rq_bytes(msb-&gt;block_req);
<span class="p_header">diff --git a/drivers/mtd/ubi/attach.c b/drivers/mtd/ubi/attach.c</span>
<span class="p_header">index 33bb1f2..208d86b 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/attach.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/attach.c</span>
<span class="p_chunk">@@ -408,7 +408,7 @@</span> <span class="p_context"> int ubi_compare_lebs(struct ubi_device *ubi, const struct ubi_ainf_peb *aeb,</span>
 		second_is_newer = !second_is_newer;
 	} else {
 		dbg_bld(&quot;PEB %d CRC is OK&quot;, pnum);
<span class="p_del">-		bitflips = !!err;</span>
<span class="p_add">+		bitflips |= !!err;</span>
 	}
 	mutex_unlock(&amp;ubi-&gt;buf_mutex);
 
<span class="p_header">diff --git a/drivers/mtd/ubi/cdev.c b/drivers/mtd/ubi/cdev.c</span>
<span class="p_header">index 8ca49f2..4cbbd55 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/cdev.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/cdev.c</span>
<span class="p_chunk">@@ -451,7 +451,7 @@</span> <span class="p_context"> static long vol_cdev_ioctl(struct file *file, unsigned int cmd,</span>
 		/* Validate the request */
 		err = -EINVAL;
 		if (req.lnum &lt; 0 || req.lnum &gt;= vol-&gt;reserved_pebs ||
<span class="p_del">-		    req.bytes &lt; 0 || req.lnum &gt;= vol-&gt;usable_leb_size)</span>
<span class="p_add">+		    req.bytes &lt; 0 || req.bytes &gt; vol-&gt;usable_leb_size)</span>
 			break;
 
 		err = get_exclusive(desc);
<span class="p_header">diff --git a/drivers/mtd/ubi/eba.c b/drivers/mtd/ubi/eba.c</span>
<span class="p_header">index 0e11671d..930cf2c 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/eba.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/eba.c</span>
<span class="p_chunk">@@ -1362,7 +1362,8 @@</span> <span class="p_context"> int ubi_eba_init(struct ubi_device *ubi, struct ubi_attach_info *ai)</span>
 				 * during re-size.
 				 */
 				ubi_move_aeb_to_list(av, aeb, &amp;ai-&gt;erase);
<span class="p_del">-			vol-&gt;eba_tbl[aeb-&gt;lnum] = aeb-&gt;pnum;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				vol-&gt;eba_tbl[aeb-&gt;lnum] = aeb-&gt;pnum;</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/mtd/ubi/wl.c b/drivers/mtd/ubi/wl.c</span>
<span class="p_header">index 68b924e..c6b0b07 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/wl.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/wl.c</span>
<span class="p_chunk">@@ -995,7 +995,7 @@</span> <span class="p_context"> static int wear_leveling_worker(struct ubi_device *ubi, struct ubi_work *wrk,</span>
 				int cancel)
 {
 	int err, scrubbing = 0, torture = 0, protect = 0, erroneous = 0;
<span class="p_del">-	int vol_id = -1, uninitialized_var(lnum);</span>
<span class="p_add">+	int vol_id = -1, lnum = -1;</span>
 #ifdef CONFIG_MTD_UBI_FASTMAP
 	int anchor = wrk-&gt;anchor;
 #endif
<span class="p_header">diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c</span>
<span class="p_header">index fd66535..b14d790 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/freescale/gianfar.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/freescale/gianfar.c</span>
<span class="p_chunk">@@ -2139,13 +2139,13 @@</span> <span class="p_context"> static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 		skb_new = skb_realloc_headroom(skb, fcb_len);
 		if (!skb_new) {
 			dev-&gt;stats.tx_errors++;
<span class="p_del">-			dev_kfree_skb_any(skb);</span>
<span class="p_add">+			kfree_skb(skb);</span>
 			return NETDEV_TX_OK;
 		}
 
 		if (skb-&gt;sk)
 			skb_set_owner_w(skb_new, skb-&gt;sk);
<span class="p_del">-		dev_consume_skb_any(skb);</span>
<span class="p_add">+		consume_skb(skb);</span>
 		skb = skb_new;
 	}
 
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000/e1000_main.c b/drivers/net/ethernet/intel/e1000/e1000_main.c</span>
<span class="p_header">index 46e6544..b655fe4 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000/e1000_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000/e1000_main.c</span>
<span class="p_chunk">@@ -144,6 +144,11 @@</span> <span class="p_context"> static bool e1000_clean_rx_irq(struct e1000_adapter *adapter,</span>
 static bool e1000_clean_jumbo_rx_irq(struct e1000_adapter *adapter,
 				     struct e1000_rx_ring *rx_ring,
 				     int *work_done, int work_to_do);
<span class="p_add">+static void e1000_alloc_dummy_rx_buffers(struct e1000_adapter *adapter,</span>
<span class="p_add">+					 struct e1000_rx_ring *rx_ring,</span>
<span class="p_add">+					 int cleaned_count)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
 static void e1000_alloc_rx_buffers(struct e1000_adapter *adapter,
 				   struct e1000_rx_ring *rx_ring,
 				   int cleaned_count);
<span class="p_chunk">@@ -3531,8 +3536,11 @@</span> <span class="p_context"> static int e1000_change_mtu(struct net_device *netdev, int new_mtu)</span>
 		msleep(1);
 	/* e1000_down has a dependency on max_frame_size */
 	hw-&gt;max_frame_size = max_frame;
<span class="p_del">-	if (netif_running(netdev))</span>
<span class="p_add">+	if (netif_running(netdev)) {</span>
<span class="p_add">+		/* prevent buffers from being reallocated */</span>
<span class="p_add">+		adapter-&gt;alloc_rx_buf = e1000_alloc_dummy_rx_buffers;</span>
 		e1000_down(adapter);
<span class="p_add">+	}</span>
 
 	/* NOTE: netdev_alloc_skb reserves 16 bytes, and typically NET_IP_ALIGN
 	 * means we reserve 2 more, this pushes us to allocate from the next
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/pagealloc.c b/drivers/net/ethernet/mellanox/mlx5/core/pagealloc.c</span>
<span class="p_header">index 37b6ad1..b3202b3 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/pagealloc.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/pagealloc.c</span>
<span class="p_chunk">@@ -99,7 +99,7 @@</span> <span class="p_context"> enum {</span>
 
 enum {
 	MLX5_MAX_RECLAIM_TIME_MILI	= 5000,
<span class="p_del">-	MLX5_NUM_4K_IN_PAGE		= PAGE_SIZE / 4096,</span>
<span class="p_add">+	MLX5_NUM_4K_IN_PAGE		= PAGE_SIZE / MLX5_ADAPTER_PAGE_SIZE,</span>
 };
 
 static int insert_page(struct mlx5_core_dev *dev, u64 addr, struct page *page, u16 func_id)
<span class="p_chunk">@@ -208,30 +208,33 @@</span> <span class="p_context"> static int alloc_4k(struct mlx5_core_dev *dev, u64 *addr)</span>
 	if (!fp-&gt;free_count)
 		list_del(&amp;fp-&gt;list);
 
<span class="p_del">-	*addr = fp-&gt;addr + n * 4096;</span>
<span class="p_add">+	*addr = fp-&gt;addr + n * MLX5_ADAPTER_PAGE_SIZE;</span>
 
 	return 0;
 }
 
<span class="p_add">+#define MLX5_U64_4K_PAGE_MASK ((~(u64)0U) &lt;&lt; PAGE_SHIFT)</span>
<span class="p_add">+</span>
 static void free_4k(struct mlx5_core_dev *dev, u64 addr)
 {
 	struct fw_page *fwp;
 	int n;
 
<span class="p_del">-	fwp = find_fw_page(dev, addr &amp; PAGE_MASK);</span>
<span class="p_add">+	fwp = find_fw_page(dev, addr &amp; MLX5_U64_4K_PAGE_MASK);</span>
 	if (!fwp) {
 		mlx5_core_warn(dev, &quot;page not found\n&quot;);
 		return;
 	}
 
<span class="p_del">-	n = (addr &amp; ~PAGE_MASK) % 4096;</span>
<span class="p_add">+	n = (addr &amp; ~MLX5_U64_4K_PAGE_MASK) &gt;&gt; MLX5_ADAPTER_PAGE_SHIFT;</span>
 	fwp-&gt;free_count++;
 	set_bit(n, &amp;fwp-&gt;bitmask);
 	if (fwp-&gt;free_count == MLX5_NUM_4K_IN_PAGE) {
 		rb_erase(&amp;fwp-&gt;rb_node, &amp;dev-&gt;priv.page_root);
 		if (fwp-&gt;free_count != 1)
 			list_del(&amp;fwp-&gt;list);
<span class="p_del">-		dma_unmap_page(&amp;dev-&gt;pdev-&gt;dev, addr, PAGE_SIZE, DMA_BIDIRECTIONAL);</span>
<span class="p_add">+		dma_unmap_page(&amp;dev-&gt;pdev-&gt;dev, addr &amp; MLX5_U64_4K_PAGE_MASK,</span>
<span class="p_add">+			       PAGE_SIZE, DMA_BIDIRECTIONAL);</span>
 		__free_page(fwp-&gt;page);
 		kfree(fwp);
 	} else if (fwp-&gt;free_count == 1) {
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_header">index f583167..93cd505 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_chunk">@@ -370,6 +370,7 @@</span> <span class="p_context"> static struct usb_device_id rtl8192c_usb_ids[] = {</span>
 	{RTL_USB_DEVICE(0x2001, 0x3307, rtl92cu_hal_cfg)}, /*D-Link-Cameo*/
 	{RTL_USB_DEVICE(0x2001, 0x3309, rtl92cu_hal_cfg)}, /*D-Link-Alpha*/
 	{RTL_USB_DEVICE(0x2001, 0x330a, rtl92cu_hal_cfg)}, /*D-Link-Alpha*/
<span class="p_add">+	{RTL_USB_DEVICE(0x2001, 0x330d, rtl92cu_hal_cfg)}, /*D-Link DWA-131 */</span>
 	{RTL_USB_DEVICE(0x2019, 0xab2b, rtl92cu_hal_cfg)}, /*Planex -Abocom*/
 	{RTL_USB_DEVICE(0x20f4, 0x624d, rtl92cu_hal_cfg)}, /*TRENDNet*/
 	{RTL_USB_DEVICE(0x2357, 0x0100, rtl92cu_hal_cfg)}, /*TP-Link WN8200ND*/
<span class="p_header">diff --git a/drivers/net/wireless/ti/wl18xx/debugfs.c b/drivers/net/wireless/ti/wl18xx/debugfs.c</span>
<span class="p_header">index 7f1669c..779dc2b 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wl18xx/debugfs.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wl18xx/debugfs.c</span>
<span class="p_chunk">@@ -136,7 +136,7 @@</span> <span class="p_context"> WL18XX_DEBUGFS_FWSTATS_FILE(rx_filter, protection_filter, &quot;%u&quot;);</span>
 WL18XX_DEBUGFS_FWSTATS_FILE(rx_filter, accum_arp_pend_requests, &quot;%u&quot;);
 WL18XX_DEBUGFS_FWSTATS_FILE(rx_filter, max_arp_queue_dep, &quot;%u&quot;);
 
<span class="p_del">-WL18XX_DEBUGFS_FWSTATS_FILE(rx_rate, rx_frames_per_rates, &quot;%u&quot;);</span>
<span class="p_add">+WL18XX_DEBUGFS_FWSTATS_FILE_ARRAY(rx_rate, rx_frames_per_rates, 50);</span>
 
 WL18XX_DEBUGFS_FWSTATS_FILE_ARRAY(aggr_size, tx_agg_vs_rate,
 				  AGGR_STATS_TX_AGG*AGGR_STATS_TX_RATE);
<span class="p_header">diff --git a/drivers/net/wireless/ti/wlcore/debugfs.h b/drivers/net/wireless/ti/wlcore/debugfs.h</span>
<span class="p_header">index f7381dd..1bce432 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wlcore/debugfs.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wlcore/debugfs.h</span>
<span class="p_chunk">@@ -26,8 +26,8 @@</span> <span class="p_context"></span>
 
 #include &quot;wlcore.h&quot;
 
<span class="p_del">-int wl1271_format_buffer(char __user *userbuf, size_t count,</span>
<span class="p_del">-			 loff_t *ppos, char *fmt, ...);</span>
<span class="p_add">+__printf(4, 5) int wl1271_format_buffer(char __user *userbuf, size_t count,</span>
<span class="p_add">+					loff_t *ppos, char *fmt, ...);</span>
 
 int wl1271_debugfs_init(struct wl1271 *wl);
 void wl1271_debugfs_exit(struct wl1271 *wl);
<span class="p_header">diff --git a/drivers/platform/x86/compal-laptop.c b/drivers/platform/x86/compal-laptop.c</span>
<span class="p_header">index eaa78ed..b978cd3 100644</span>
<span class="p_header">--- a/drivers/platform/x86/compal-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/compal-laptop.c</span>
<span class="p_chunk">@@ -1049,7 +1049,13 @@</span> <span class="p_context"> static int compal_probe(struct platform_device *pdev)</span>
 
 	/* Power supply */
 	initialize_power_supply_data(data);
<span class="p_del">-	power_supply_register(&amp;compal_device-&gt;dev, &amp;data-&gt;psy);</span>
<span class="p_add">+	err = power_supply_register(&amp;compal_device-&gt;dev, &amp;data-&gt;psy);</span>
<span class="p_add">+	if (err &lt; 0) {</span>
<span class="p_add">+		hwmon_device_unregister(data-&gt;hwmon_dev);</span>
<span class="p_add">+		sysfs_remove_group(&amp;pdev-&gt;dev.kobj, &amp;compal_attribute_group);</span>
<span class="p_add">+		kfree(data);</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+	}</span>
 
 	platform_set_drvdata(pdev, data);
 
<span class="p_header">diff --git a/drivers/power/lp8788-charger.c b/drivers/power/lp8788-charger.c</span>
<span class="p_header">index ed49b50..72da2a6 100644</span>
<span class="p_header">--- a/drivers/power/lp8788-charger.c</span>
<span class="p_header">+++ b/drivers/power/lp8788-charger.c</span>
<span class="p_chunk">@@ -417,8 +417,10 @@</span> <span class="p_context"> static int lp8788_psy_register(struct platform_device *pdev,</span>
 	pchg-&gt;battery.num_properties = ARRAY_SIZE(lp8788_battery_prop);
 	pchg-&gt;battery.get_property = lp8788_battery_get_property;
 
<span class="p_del">-	if (power_supply_register(&amp;pdev-&gt;dev, &amp;pchg-&gt;battery))</span>
<span class="p_add">+	if (power_supply_register(&amp;pdev-&gt;dev, &amp;pchg-&gt;battery)) {</span>
<span class="p_add">+		power_supply_unregister(&amp;pchg-&gt;charger);</span>
 		return -EPERM;
<span class="p_add">+	}</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/power/twl4030_madc_battery.c b/drivers/power/twl4030_madc_battery.c</span>
<span class="p_header">index 7ef445a..cf90760 100644</span>
<span class="p_header">--- a/drivers/power/twl4030_madc_battery.c</span>
<span class="p_header">+++ b/drivers/power/twl4030_madc_battery.c</span>
<span class="p_chunk">@@ -192,6 +192,7 @@</span> <span class="p_context"> static int twl4030_madc_battery_probe(struct platform_device *pdev)</span>
 {
 	struct twl4030_madc_battery *twl4030_madc_bat;
 	struct twl4030_madc_bat_platform_data *pdata = pdev-&gt;dev.platform_data;
<span class="p_add">+	int ret = 0;</span>
 
 	twl4030_madc_bat = kzalloc(sizeof(*twl4030_madc_bat), GFP_KERNEL);
 	if (!twl4030_madc_bat)
<span class="p_chunk">@@ -216,9 +217,11 @@</span> <span class="p_context"> static int twl4030_madc_battery_probe(struct platform_device *pdev)</span>
 
 	twl4030_madc_bat-&gt;pdata = pdata;
 	platform_set_drvdata(pdev, twl4030_madc_bat);
<span class="p_del">-	power_supply_register(&amp;pdev-&gt;dev, &amp;twl4030_madc_bat-&gt;psy);</span>
<span class="p_add">+	ret = power_supply_register(&amp;pdev-&gt;dev, &amp;twl4030_madc_bat-&gt;psy);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		kfree(twl4030_madc_bat);</span>
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int twl4030_madc_battery_remove(struct platform_device *pdev)
<span class="p_header">diff --git a/drivers/scsi/mvsas/mv_sas.c b/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_header">index 6c1f223..4c0b8b4 100644</span>
<span class="p_header">--- a/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_header">+++ b/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_chunk">@@ -441,14 +441,11 @@</span> <span class="p_context"> static u32 mvs_get_ncq_tag(struct sas_task *task, u32 *tag)</span>
 static int mvs_task_prep_ata(struct mvs_info *mvi,
 			     struct mvs_task_exec_info *tei)
 {
<span class="p_del">-	struct sas_ha_struct *sha = mvi-&gt;sas;</span>
 	struct sas_task *task = tei-&gt;task;
 	struct domain_device *dev = task-&gt;dev;
 	struct mvs_device *mvi_dev = dev-&gt;lldd_dev;
 	struct mvs_cmd_hdr *hdr = tei-&gt;hdr;
 	struct asd_sas_port *sas_port = dev-&gt;port;
<span class="p_del">-	struct sas_phy *sphy = dev-&gt;phy;</span>
<span class="p_del">-	struct asd_sas_phy *sas_phy = sha-&gt;sas_phy[sphy-&gt;number];</span>
 	struct mvs_slot_info *slot;
 	void *buf_prd;
 	u32 tag = tei-&gt;tag, hdr_tag;
<span class="p_chunk">@@ -468,7 +465,7 @@</span> <span class="p_context"> static int mvs_task_prep_ata(struct mvs_info *mvi,</span>
 	slot-&gt;tx = mvi-&gt;tx_prod;
 	del_q = TXQ_MODE_I | tag |
 		(TXQ_CMD_STP &lt;&lt; TXQ_CMD_SHIFT) |
<span class="p_del">-		(MVS_PHY_ID &lt;&lt; TXQ_PHY_SHIFT) |</span>
<span class="p_add">+		((sas_port-&gt;phy_mask &amp; TXQ_PHY_MASK) &lt;&lt; TXQ_PHY_SHIFT) |</span>
 		(mvi_dev-&gt;taskfileset &lt;&lt; TXQ_SRS_SHIFT);
 	mvi-&gt;tx[mvi-&gt;tx_prod] = cpu_to_le32(del_q);
 
<span class="p_header">diff --git a/drivers/scsi/storvsc_drv.c b/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">index 86b0515..97892f2 100644</span>
<span class="p_header">--- a/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">+++ b/drivers/scsi/storvsc_drv.c</span>
<span class="p_chunk">@@ -739,21 +739,22 @@</span> <span class="p_context"> static unsigned int copy_to_bounce_buffer(struct scatterlist *orig_sgl,</span>
 			if (bounce_sgl[j].length == PAGE_SIZE) {
 				/* full..move to next entry */
 				sg_kunmap_atomic(bounce_addr);
<span class="p_add">+				bounce_addr = 0;</span>
 				j++;
<span class="p_add">+			}</span>
 
<span class="p_del">-				/* if we need to use another bounce buffer */</span>
<span class="p_del">-				if (srclen || i != orig_sgl_count - 1)</span>
<span class="p_del">-					bounce_addr = sg_kmap_atomic(bounce_sgl,j);</span>
<span class="p_add">+			/* if we need to use another bounce buffer */</span>
<span class="p_add">+			if (srclen &amp;&amp; bounce_addr == 0)</span>
<span class="p_add">+				bounce_addr = sg_kmap_atomic(bounce_sgl, j);</span>
 
<span class="p_del">-			} else if (srclen == 0 &amp;&amp; i == orig_sgl_count - 1) {</span>
<span class="p_del">-				/* unmap the last bounce that is &lt; PAGE_SIZE */</span>
<span class="p_del">-				sg_kunmap_atomic(bounce_addr);</span>
<span class="p_del">-			}</span>
 		}
 
 		sg_kunmap_atomic(src_addr - orig_sgl[i].offset);
 	}
 
<span class="p_add">+	if (bounce_addr)</span>
<span class="p_add">+		sg_kunmap_atomic(bounce_addr);</span>
<span class="p_add">+</span>
 	local_irq_restore(flags);
 
 	return total_copied;
<span class="p_header">diff --git a/drivers/staging/dwc2/hcd.c b/drivers/staging/dwc2/hcd.c</span>
<span class="p_header">index 3cfd2d5..ce32219 100644</span>
<span class="p_header">--- a/drivers/staging/dwc2/hcd.c</span>
<span class="p_header">+++ b/drivers/staging/dwc2/hcd.c</span>
<span class="p_chunk">@@ -1487,7 +1487,7 @@</span> <span class="p_context"> static int dwc2_hcd_hub_control(struct dwc2_hsotg *hsotg, u16 typereq,</span>
 			dev_dbg(hsotg-&gt;dev,
 				&quot;ClearPortFeature USB_PORT_FEAT_SUSPEND\n&quot;);
 			writel(0, hsotg-&gt;regs + PCGCTL);
<span class="p_del">-			usleep_range(20000, 40000);</span>
<span class="p_add">+			msleep(USB_RESUME_TIMEOUT);</span>
 
 			hprt0 = dwc2_read_hprt0(hsotg);
 			hprt0 |= HPRT0_RES;
<span class="p_header">diff --git a/drivers/staging/panel/panel.c b/drivers/staging/panel/panel.c</span>
<span class="p_header">index cbc15c1..04758f9 100644</span>
<span class="p_header">--- a/drivers/staging/panel/panel.c</span>
<span class="p_header">+++ b/drivers/staging/panel/panel.c</span>
<span class="p_chunk">@@ -275,11 +275,11 @@</span> <span class="p_context"> static unsigned char lcd_bits[LCD_PORTS][LCD_BITS][BIT_STATES];</span>
  * LCD types
  */
 #define LCD_TYPE_NONE		0
<span class="p_del">-#define LCD_TYPE_OLD		1</span>
<span class="p_del">-#define LCD_TYPE_KS0074		2</span>
<span class="p_del">-#define LCD_TYPE_HANTRONIX	3</span>
<span class="p_del">-#define LCD_TYPE_NEXCOM		4</span>
<span class="p_del">-#define LCD_TYPE_CUSTOM		5</span>
<span class="p_add">+#define LCD_TYPE_CUSTOM		1</span>
<span class="p_add">+#define LCD_TYPE_OLD		2</span>
<span class="p_add">+#define LCD_TYPE_KS0074		3</span>
<span class="p_add">+#define LCD_TYPE_HANTRONIX	4</span>
<span class="p_add">+#define LCD_TYPE_NEXCOM		5</span>
 
 /*
  * keypad types
<span class="p_chunk">@@ -457,8 +457,7 @@</span> <span class="p_context"> MODULE_PARM_DESC(keypad_enabled, &quot;Deprecated option, use keypad_type instead&quot;);</span>
 static int lcd_type = -1;
 module_param(lcd_type, int, 0000);
 MODULE_PARM_DESC(lcd_type,
<span class="p_del">-		 &quot;LCD type: 0=none, 1=old //, 2=serial ks0074, &quot;</span>
<span class="p_del">-		 &quot;3=hantronix //, 4=nexcom //, 5=compiled-in&quot;);</span>
<span class="p_add">+		 &quot;LCD type: 0=none, 1=compiled-in, 2=old, 3=serial ks0074, 4=hantronix, 5=nexcom&quot;);</span>
 
 static int lcd_proto = -1;
 module_param(lcd_proto, int, 0000);
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">index 505aa4e..8da53d7 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_chunk">@@ -517,7 +517,7 @@</span> <span class="p_context"> static struct iscsit_transport iscsi_target_transport = {</span>
 
 static int __init iscsi_target_init_module(void)
 {
<span class="p_del">-	int ret = 0;</span>
<span class="p_add">+	int ret = 0, size;</span>
 
 	pr_debug(&quot;iSCSI-Target &quot;ISCSIT_VERSION&quot;\n&quot;);
 
<span class="p_chunk">@@ -526,6 +526,7 @@</span> <span class="p_context"> static int __init iscsi_target_init_module(void)</span>
 		pr_err(&quot;Unable to allocate memory for iscsit_global\n&quot;);
 		return -1;
 	}
<span class="p_add">+	spin_lock_init(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
 	mutex_init(&amp;auth_id_lock);
 	spin_lock_init(&amp;sess_idr_lock);
 	idr_init(&amp;tiqn_idr);
<span class="p_chunk">@@ -535,15 +536,11 @@</span> <span class="p_context"> static int __init iscsi_target_init_module(void)</span>
 	if (ret &lt; 0)
 		goto out;
 
<span class="p_del">-	ret = iscsi_thread_set_init();</span>
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_add">+	size = BITS_TO_LONGS(ISCSIT_BITMAP_BITS) * sizeof(long);</span>
<span class="p_add">+	iscsit_global-&gt;ts_bitmap = vzalloc(size);</span>
<span class="p_add">+	if (!iscsit_global-&gt;ts_bitmap) {</span>
<span class="p_add">+		pr_err(&quot;Unable to allocate iscsit_global-&gt;ts_bitmap\n&quot;);</span>
 		goto configfs_out;
<span class="p_del">-</span>
<span class="p_del">-	if (iscsi_allocate_thread_sets(TARGET_THREAD_SET_COUNT) !=</span>
<span class="p_del">-			TARGET_THREAD_SET_COUNT) {</span>
<span class="p_del">-		pr_err(&quot;iscsi_allocate_thread_sets() returned&quot;</span>
<span class="p_del">-			&quot; unexpected value!\n&quot;);</span>
<span class="p_del">-		goto ts_out1;</span>
 	}
 
 	lio_qr_cache = kmem_cache_create(&quot;lio_qr_cache&quot;,
<span class="p_chunk">@@ -552,7 +549,7 @@</span> <span class="p_context"> static int __init iscsi_target_init_module(void)</span>
 	if (!lio_qr_cache) {
 		pr_err(&quot;nable to kmem_cache_create() for&quot;
 				&quot; lio_qr_cache\n&quot;);
<span class="p_del">-		goto ts_out2;</span>
<span class="p_add">+		goto bitmap_out;</span>
 	}
 
 	lio_dr_cache = kmem_cache_create(&quot;lio_dr_cache&quot;,
<span class="p_chunk">@@ -596,10 +593,8 @@</span> <span class="p_context"> dr_out:</span>
 	kmem_cache_destroy(lio_dr_cache);
 qr_out:
 	kmem_cache_destroy(lio_qr_cache);
<span class="p_del">-ts_out2:</span>
<span class="p_del">-	iscsi_deallocate_thread_sets();</span>
<span class="p_del">-ts_out1:</span>
<span class="p_del">-	iscsi_thread_set_free();</span>
<span class="p_add">+bitmap_out:</span>
<span class="p_add">+	vfree(iscsit_global-&gt;ts_bitmap);</span>
 configfs_out:
 	iscsi_target_deregister_configfs();
 out:
<span class="p_chunk">@@ -609,8 +604,6 @@</span> <span class="p_context"> out:</span>
 
 static void __exit iscsi_target_cleanup_module(void)
 {
<span class="p_del">-	iscsi_deallocate_thread_sets();</span>
<span class="p_del">-	iscsi_thread_set_free();</span>
 	iscsit_release_discovery_tpg();
 	iscsit_unregister_transport(&amp;iscsi_target_transport);
 	kmem_cache_destroy(lio_qr_cache);
<span class="p_chunk">@@ -620,6 +613,7 @@</span> <span class="p_context"> static void __exit iscsi_target_cleanup_module(void)</span>
 
 	iscsi_target_deregister_configfs();
 
<span class="p_add">+	vfree(iscsit_global-&gt;ts_bitmap);</span>
 	kfree(iscsit_global);
 }
 
<span class="p_chunk">@@ -3652,17 +3646,16 @@</span> <span class="p_context"> static int iscsit_send_reject(</span>
 
 void iscsit_thread_get_cpumask(struct iscsi_conn *conn)
 {
<span class="p_del">-	struct iscsi_thread_set *ts = conn-&gt;thread_set;</span>
 	int ord, cpu;
 	/*
<span class="p_del">-	 * thread_id is assigned from iscsit_global-&gt;ts_bitmap from</span>
<span class="p_del">-	 * within iscsi_thread_set.c:iscsi_allocate_thread_sets()</span>
<span class="p_add">+	 * bitmap_id is assigned from iscsit_global-&gt;ts_bitmap from</span>
<span class="p_add">+	 * within iscsit_start_kthreads()</span>
 	 *
<span class="p_del">-	 * Here we use thread_id to determine which CPU that this</span>
<span class="p_del">-	 * iSCSI connection&#39;s iscsi_thread_set will be scheduled to</span>
<span class="p_add">+	 * Here we use bitmap_id to determine which CPU that this</span>
<span class="p_add">+	 * iSCSI connection&#39;s RX/TX threads will be scheduled to</span>
 	 * execute upon.
 	 */
<span class="p_del">-	ord = ts-&gt;thread_id % cpumask_weight(cpu_online_mask);</span>
<span class="p_add">+	ord = conn-&gt;bitmap_id % cpumask_weight(cpu_online_mask);</span>
 	for_each_online_cpu(cpu) {
 		if (ord-- == 0) {
 			cpumask_set_cpu(cpu, conn-&gt;conn_cpumask);
<span class="p_chunk">@@ -3854,7 +3847,7 @@</span> <span class="p_context"> check_rsp_state:</span>
 	switch (state) {
 	case ISTATE_SEND_LOGOUTRSP:
 		if (!iscsit_logout_post_handler(cmd, conn))
<span class="p_del">-			goto restart;</span>
<span class="p_add">+			return -ECONNRESET;</span>
 		/* fall through */
 	case ISTATE_SEND_STATUS:
 	case ISTATE_SEND_ASYNCMSG:
<span class="p_chunk">@@ -3882,8 +3875,6 @@</span> <span class="p_context"> check_rsp_state:</span>
 
 err:
 	return -1;
<span class="p_del">-restart:</span>
<span class="p_del">-	return -EAGAIN;</span>
 }
 
 static int iscsit_handle_response_queue(struct iscsi_conn *conn)
<span class="p_chunk">@@ -3910,21 +3901,13 @@</span> <span class="p_context"> static int iscsit_handle_response_queue(struct iscsi_conn *conn)</span>
 int iscsi_target_tx_thread(void *arg)
 {
 	int ret = 0;
<span class="p_del">-	struct iscsi_conn *conn;</span>
<span class="p_del">-	struct iscsi_thread_set *ts = arg;</span>
<span class="p_add">+	struct iscsi_conn *conn = arg;</span>
 	/*
 	 * Allow ourselves to be interrupted by SIGINT so that a
 	 * connection recovery / failure event can be triggered externally.
 	 */
 	allow_signal(SIGINT);
 
<span class="p_del">-restart:</span>
<span class="p_del">-	conn = iscsi_tx_thread_pre_handler(ts);</span>
<span class="p_del">-	if (!conn)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = 0;</span>
<span class="p_del">-</span>
 	while (!kthread_should_stop()) {
 		/*
 		 * Ensure that both TX and RX per connection kthreads
<span class="p_chunk">@@ -3933,11 +3916,9 @@</span> <span class="p_context"> restart:</span>
 		iscsit_thread_check_cpumask(conn, current, 1);
 
 		wait_event_interruptible(conn-&gt;queues_wq,
<span class="p_del">-					 !iscsit_conn_all_queues_empty(conn) ||</span>
<span class="p_del">-					 ts-&gt;status == ISCSI_THREAD_SET_RESET);</span>
<span class="p_add">+					 !iscsit_conn_all_queues_empty(conn));</span>
 
<span class="p_del">-		if ((ts-&gt;status == ISCSI_THREAD_SET_RESET) ||</span>
<span class="p_del">-		     signal_pending(current))</span>
<span class="p_add">+		if (signal_pending(current))</span>
 			goto transport_err;
 
 get_immediate:
<span class="p_chunk">@@ -3948,15 +3929,14 @@</span> <span class="p_context"> get_immediate:</span>
 		ret = iscsit_handle_response_queue(conn);
 		if (ret == 1)
 			goto get_immediate;
<span class="p_del">-		else if (ret == -EAGAIN)</span>
<span class="p_del">-			goto restart;</span>
<span class="p_add">+		else if (ret == -ECONNRESET)</span>
<span class="p_add">+			goto out;</span>
 		else if (ret &lt; 0)
 			goto transport_err;
 	}
 
 transport_err:
 	iscsit_take_action_for_connection_exit(conn);
<span class="p_del">-	goto restart;</span>
 out:
 	return 0;
 }
<span class="p_chunk">@@ -4045,8 +4025,7 @@</span> <span class="p_context"> int iscsi_target_rx_thread(void *arg)</span>
 	int ret;
 	u8 buffer[ISCSI_HDR_LEN], opcode;
 	u32 checksum = 0, digest = 0;
<span class="p_del">-	struct iscsi_conn *conn = NULL;</span>
<span class="p_del">-	struct iscsi_thread_set *ts = arg;</span>
<span class="p_add">+	struct iscsi_conn *conn = arg;</span>
 	struct kvec iov;
 	/*
 	 * Allow ourselves to be interrupted by SIGINT so that a
<span class="p_chunk">@@ -4054,11 +4033,6 @@</span> <span class="p_context"> int iscsi_target_rx_thread(void *arg)</span>
 	 */
 	allow_signal(SIGINT);
 
<span class="p_del">-restart:</span>
<span class="p_del">-	conn = iscsi_rx_thread_pre_handler(ts);</span>
<span class="p_del">-	if (!conn)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
 	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_INFINIBAND) {
 		struct completion comp;
 		int rc;
<span class="p_chunk">@@ -4068,7 +4042,7 @@</span> <span class="p_context"> restart:</span>
 		if (rc &lt; 0)
 			goto transport_err;
 
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto transport_err;</span>
 	}
 
 	while (!kthread_should_stop()) {
<span class="p_chunk">@@ -4144,8 +4118,6 @@</span> <span class="p_context"> transport_err:</span>
 	if (!signal_pending(current))
 		atomic_set(&amp;conn-&gt;transport_failed, 1);
 	iscsit_take_action_for_connection_exit(conn);
<span class="p_del">-	goto restart;</span>
<span class="p_del">-out:</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -4207,7 +4179,24 @@</span> <span class="p_context"> int iscsit_close_connection(</span>
 	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_TCP)
 		complete(&amp;conn-&gt;conn_logout_comp);
 
<span class="p_del">-	iscsi_release_thread_set(conn);</span>
<span class="p_add">+	if (!strcmp(current-&gt;comm, ISCSI_RX_THREAD_NAME)) {</span>
<span class="p_add">+		if (conn-&gt;tx_thread &amp;&amp;</span>
<span class="p_add">+		    cmpxchg(&amp;conn-&gt;tx_thread_active, true, false)) {</span>
<span class="p_add">+			send_sig(SIGINT, conn-&gt;tx_thread, 1);</span>
<span class="p_add">+			kthread_stop(conn-&gt;tx_thread);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else if (!strcmp(current-&gt;comm, ISCSI_TX_THREAD_NAME)) {</span>
<span class="p_add">+		if (conn-&gt;rx_thread &amp;&amp;</span>
<span class="p_add">+		    cmpxchg(&amp;conn-&gt;rx_thread_active, true, false)) {</span>
<span class="p_add">+			send_sig(SIGINT, conn-&gt;rx_thread, 1);</span>
<span class="p_add">+			kthread_stop(conn-&gt;rx_thread);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	bitmap_release_region(iscsit_global-&gt;ts_bitmap, conn-&gt;bitmap_id,</span>
<span class="p_add">+			      get_order(1));</span>
<span class="p_add">+	spin_unlock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
 
 	iscsit_stop_timers_for_cmds(conn);
 	iscsit_stop_nopin_response_timer(conn);
<span class="p_chunk">@@ -4486,15 +4475,13 @@</span> <span class="p_context"> static void iscsit_logout_post_handler_closesession(</span>
 	struct iscsi_conn *conn)
 {
 	struct iscsi_session *sess = conn-&gt;sess;
<span class="p_del">-</span>
<span class="p_del">-	iscsi_set_thread_clear(conn, ISCSI_CLEAR_TX_THREAD);</span>
<span class="p_del">-	iscsi_set_thread_set_signal(conn, ISCSI_SIGNAL_TX_THREAD);</span>
<span class="p_add">+	int sleep = cmpxchg(&amp;conn-&gt;tx_thread_active, true, false);</span>
 
 	atomic_set(&amp;conn-&gt;conn_logout_remove, 0);
 	complete(&amp;conn-&gt;conn_logout_comp);
 
 	iscsit_dec_conn_usage_count(conn);
<span class="p_del">-	iscsit_stop_session(sess, 1, 1);</span>
<span class="p_add">+	iscsit_stop_session(sess, sleep, sleep);</span>
 	iscsit_dec_session_usage_count(sess);
 	target_put_session(sess-&gt;se_sess);
 }
<span class="p_chunk">@@ -4502,13 +4489,12 @@</span> <span class="p_context"> static void iscsit_logout_post_handler_closesession(</span>
 static void iscsit_logout_post_handler_samecid(
 	struct iscsi_conn *conn)
 {
<span class="p_del">-	iscsi_set_thread_clear(conn, ISCSI_CLEAR_TX_THREAD);</span>
<span class="p_del">-	iscsi_set_thread_set_signal(conn, ISCSI_SIGNAL_TX_THREAD);</span>
<span class="p_add">+	int sleep = cmpxchg(&amp;conn-&gt;tx_thread_active, true, false);</span>
 
 	atomic_set(&amp;conn-&gt;conn_logout_remove, 0);
 	complete(&amp;conn-&gt;conn_logout_comp);
 
<span class="p_del">-	iscsit_cause_connection_reinstatement(conn, 1);</span>
<span class="p_add">+	iscsit_cause_connection_reinstatement(conn, sleep);</span>
 	iscsit_dec_conn_usage_count(conn);
 }
 
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_core.h b/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_header">index 48f7b3b..31a68f5 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_chunk">@@ -601,6 +601,11 @@</span> <span class="p_context"> struct iscsi_conn {</span>
 	struct iscsi_session	*sess;
 	/* Pointer to thread_set in use for this conn&#39;s threads */
 	struct iscsi_thread_set	*thread_set;
<span class="p_add">+	int			bitmap_id;</span>
<span class="p_add">+	int			rx_thread_active;</span>
<span class="p_add">+	struct task_struct	*rx_thread;</span>
<span class="p_add">+	int			tx_thread_active;</span>
<span class="p_add">+	struct task_struct	*tx_thread;</span>
 	/* list_head for session connection list */
 	struct list_head	conn_list;
 } ____cacheline_aligned;
<span class="p_chunk">@@ -868,10 +873,12 @@</span> <span class="p_context"> struct iscsit_global {</span>
 	/* Unique identifier used for the authentication daemon */
 	u32			auth_id;
 	u32			inactive_ts;
<span class="p_add">+#define ISCSIT_BITMAP_BITS	262144</span>
 	/* Thread Set bitmap count */
 	int			ts_bitmap_count;
 	/* Thread Set bitmap pointer */
 	unsigned long		*ts_bitmap;
<span class="p_add">+	spinlock_t		ts_bitmap_lock;</span>
 	/* Used for iSCSI discovery session authentication */
 	struct iscsi_node_acl	discovery_acl;
 	struct iscsi_portal_group	*discovery_tpg;
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_erl0.c b/drivers/target/iscsi/iscsi_target_erl0.c</span>
<span class="p_header">index 0d1e6ee..7396d90 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_erl0.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_erl0.c</span>
<span class="p_chunk">@@ -864,7 +864,10 @@</span> <span class="p_context"> void iscsit_connection_reinstatement_rcfr(struct iscsi_conn *conn)</span>
 	}
 	spin_unlock_bh(&amp;conn-&gt;state_lock);
 
<span class="p_del">-	iscsi_thread_set_force_reinstatement(conn);</span>
<span class="p_add">+	if (conn-&gt;tx_thread &amp;&amp; conn-&gt;tx_thread_active)</span>
<span class="p_add">+		send_sig(SIGINT, conn-&gt;tx_thread, 1);</span>
<span class="p_add">+	if (conn-&gt;rx_thread &amp;&amp; conn-&gt;rx_thread_active)</span>
<span class="p_add">+		send_sig(SIGINT, conn-&gt;rx_thread, 1);</span>
 
 sleep:
 	wait_for_completion(&amp;conn-&gt;conn_wait_rcfr_comp);
<span class="p_chunk">@@ -889,10 +892,10 @@</span> <span class="p_context"> void iscsit_cause_connection_reinstatement(struct iscsi_conn *conn, int sleep)</span>
 		return;
 	}
 
<span class="p_del">-	if (iscsi_thread_set_force_reinstatement(conn) &lt; 0) {</span>
<span class="p_del">-		spin_unlock_bh(&amp;conn-&gt;state_lock);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (conn-&gt;tx_thread &amp;&amp; conn-&gt;tx_thread_active)</span>
<span class="p_add">+		send_sig(SIGINT, conn-&gt;tx_thread, 1);</span>
<span class="p_add">+	if (conn-&gt;rx_thread &amp;&amp; conn-&gt;rx_thread_active)</span>
<span class="p_add">+		send_sig(SIGINT, conn-&gt;rx_thread, 1);</span>
 
 	atomic_set(&amp;conn-&gt;connection_reinstatement, 1);
 	if (!sleep) {
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_login.c b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">index 439c534..1a8aea1 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_chunk">@@ -681,6 +681,51 @@</span> <span class="p_context"> static void iscsi_post_login_start_timers(struct iscsi_conn *conn)</span>
 		iscsit_start_nopin_timer(conn);
 }
 
<span class="p_add">+int iscsit_start_kthreads(struct iscsi_conn *conn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	conn-&gt;bitmap_id = bitmap_find_free_region(iscsit_global-&gt;ts_bitmap,</span>
<span class="p_add">+					ISCSIT_BITMAP_BITS, get_order(1));</span>
<span class="p_add">+	spin_unlock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (conn-&gt;bitmap_id &lt; 0) {</span>
<span class="p_add">+		pr_err(&quot;bitmap_find_free_region() failed for&quot;</span>
<span class="p_add">+		       &quot; iscsit_start_kthreads()\n&quot;);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	conn-&gt;tx_thread = kthread_run(iscsi_target_tx_thread, conn,</span>
<span class="p_add">+				      &quot;%s&quot;, ISCSI_TX_THREAD_NAME);</span>
<span class="p_add">+	if (IS_ERR(conn-&gt;tx_thread)) {</span>
<span class="p_add">+		pr_err(&quot;Unable to start iscsi_target_tx_thread\n&quot;);</span>
<span class="p_add">+		ret = PTR_ERR(conn-&gt;tx_thread);</span>
<span class="p_add">+		goto out_bitmap;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	conn-&gt;tx_thread_active = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	conn-&gt;rx_thread = kthread_run(iscsi_target_rx_thread, conn,</span>
<span class="p_add">+				      &quot;%s&quot;, ISCSI_RX_THREAD_NAME);</span>
<span class="p_add">+	if (IS_ERR(conn-&gt;rx_thread)) {</span>
<span class="p_add">+		pr_err(&quot;Unable to start iscsi_target_rx_thread\n&quot;);</span>
<span class="p_add">+		ret = PTR_ERR(conn-&gt;rx_thread);</span>
<span class="p_add">+		goto out_tx;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	conn-&gt;rx_thread_active = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+out_tx:</span>
<span class="p_add">+	kthread_stop(conn-&gt;tx_thread);</span>
<span class="p_add">+	conn-&gt;tx_thread_active = false;</span>
<span class="p_add">+out_bitmap:</span>
<span class="p_add">+	spin_lock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	bitmap_release_region(iscsit_global-&gt;ts_bitmap, conn-&gt;bitmap_id,</span>
<span class="p_add">+			      get_order(1));</span>
<span class="p_add">+	spin_unlock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int iscsi_post_login_handler(
 	struct iscsi_np *np,
 	struct iscsi_conn *conn,
<span class="p_chunk">@@ -691,7 +736,7 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 	struct se_session *se_sess = sess-&gt;se_sess;
 	struct iscsi_portal_group *tpg = sess-&gt;tpg;
 	struct se_portal_group *se_tpg = &amp;tpg-&gt;tpg_se_tpg;
<span class="p_del">-	struct iscsi_thread_set *ts;</span>
<span class="p_add">+	int rc;</span>
 
 	iscsit_inc_conn_usage_count(conn);
 
<span class="p_chunk">@@ -706,7 +751,6 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 	/*
 	 * SCSI Initiator -&gt; SCSI Target Port Mapping
 	 */
<span class="p_del">-	ts = iscsi_get_thread_set();</span>
 	if (!zero_tsih) {
 		iscsi_set_session_parameters(sess-&gt;sess_ops,
 				conn-&gt;param_list, 0);
<span class="p_chunk">@@ -733,9 +777,11 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 			sess-&gt;sess_ops-&gt;InitiatorName);
 		spin_unlock_bh(&amp;sess-&gt;conn_lock);
 
<span class="p_del">-		iscsi_post_login_start_timers(conn);</span>
<span class="p_add">+		rc = iscsit_start_kthreads(conn);</span>
<span class="p_add">+		if (rc)</span>
<span class="p_add">+			return rc;</span>
 
<span class="p_del">-		iscsi_activate_thread_set(conn, ts);</span>
<span class="p_add">+		iscsi_post_login_start_timers(conn);</span>
 		/*
 		 * Determine CPU mask to ensure connection&#39;s RX and TX kthreads
 		 * are scheduled on the same CPU.
<span class="p_chunk">@@ -792,8 +838,11 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 		&quot; iSCSI Target Portal Group: %hu\n&quot;, tpg-&gt;nsessions, tpg-&gt;tpgt);
 	spin_unlock_bh(&amp;se_tpg-&gt;session_lock);
 
<span class="p_add">+	rc = iscsit_start_kthreads(conn);</span>
<span class="p_add">+	if (rc)</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+</span>
 	iscsi_post_login_start_timers(conn);
<span class="p_del">-	iscsi_activate_thread_set(conn, ts);</span>
 	/*
 	 * Determine CPU mask to ensure connection&#39;s RX and TX kthreads
 	 * are scheduled on the same CPU.
<span class="p_header">diff --git a/drivers/target/target_core_sbc.c b/drivers/target/target_core_sbc.c</span>
<span class="p_header">index e19fabf..11526d2 100644</span>
<span class="p_header">--- a/drivers/target/target_core_sbc.c</span>
<span class="p_header">+++ b/drivers/target/target_core_sbc.c</span>
<span class="p_chunk">@@ -308,7 +308,7 @@</span> <span class="p_context"> sbc_setup_write_same(struct se_cmd *cmd, unsigned char *flags, struct sbc_ops *o</span>
 	return 0;
 }
 
<span class="p_del">-static sense_reason_t xdreadwrite_callback(struct se_cmd *cmd)</span>
<span class="p_add">+static sense_reason_t xdreadwrite_callback(struct se_cmd *cmd, bool success)</span>
 {
 	unsigned char *buf, *addr;
 	struct scatterlist *sg;
<span class="p_chunk">@@ -372,7 +372,7 @@</span> <span class="p_context"> sbc_execute_rw(struct se_cmd *cmd)</span>
 			       cmd-&gt;data_direction);
 }
 
<span class="p_del">-static sense_reason_t compare_and_write_post(struct se_cmd *cmd)</span>
<span class="p_add">+static sense_reason_t compare_and_write_post(struct se_cmd *cmd, bool success)</span>
 {
 	struct se_device *dev = cmd-&gt;se_dev;
 
<span class="p_chunk">@@ -395,7 +395,7 @@</span> <span class="p_context"> static sense_reason_t compare_and_write_post(struct se_cmd *cmd)</span>
 	return TCM_NO_SENSE;
 }
 
<span class="p_del">-static sense_reason_t compare_and_write_callback(struct se_cmd *cmd)</span>
<span class="p_add">+static sense_reason_t compare_and_write_callback(struct se_cmd *cmd, bool success)</span>
 {
 	struct se_device *dev = cmd-&gt;se_dev;
 	struct scatterlist *write_sg = NULL, *sg;
<span class="p_chunk">@@ -410,11 +410,16 @@</span> <span class="p_context"> static sense_reason_t compare_and_write_callback(struct se_cmd *cmd)</span>
 
 	/*
 	 * Handle early failure in transport_generic_request_failure(),
<span class="p_del">-	 * which will not have taken -&gt;caw_mutex yet..</span>
<span class="p_add">+	 * which will not have taken -&gt;caw_sem yet..</span>
 	 */
<span class="p_del">-	if (!cmd-&gt;t_data_sg || !cmd-&gt;t_bidi_data_sg)</span>
<span class="p_add">+	if (!success &amp;&amp; (!cmd-&gt;t_data_sg || !cmd-&gt;t_bidi_data_sg))</span>
 		return TCM_NO_SENSE;
 	/*
<span class="p_add">+	 * Handle special case for zero-length COMPARE_AND_WRITE</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!cmd-&gt;data_length)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	/*</span>
 	 * Immediately exit + release dev-&gt;caw_sem if command has already
 	 * been failed with a non-zero SCSI status.
 	 */
<span class="p_header">diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c</span>
<span class="p_header">index d76c922..fefd5f5 100644</span>
<span class="p_header">--- a/drivers/target/target_core_transport.c</span>
<span class="p_header">+++ b/drivers/target/target_core_transport.c</span>
<span class="p_chunk">@@ -1565,11 +1565,11 @@</span> <span class="p_context"> void transport_generic_request_failure(struct se_cmd *cmd,</span>
 	transport_complete_task_attr(cmd);
 	/*
 	 * Handle special case for COMPARE_AND_WRITE failure, where the
<span class="p_del">-	 * callback is expected to drop the per device -&gt;caw_mutex.</span>
<span class="p_add">+	 * callback is expected to drop the per device -&gt;caw_sem.</span>
 	 */
 	if ((cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) &amp;&amp;
 	     cmd-&gt;transport_complete_callback)
<span class="p_del">-		cmd-&gt;transport_complete_callback(cmd);</span>
<span class="p_add">+		cmd-&gt;transport_complete_callback(cmd, false);</span>
 
 	switch (sense_reason) {
 	case TCM_NON_EXISTENT_LUN:
<span class="p_chunk">@@ -1903,8 +1903,12 @@</span> <span class="p_context"> static void target_complete_ok_work(struct work_struct *work)</span>
 	if (cmd-&gt;transport_complete_callback) {
 		sense_reason_t rc;
 
<span class="p_del">-		rc = cmd-&gt;transport_complete_callback(cmd);</span>
<span class="p_add">+		rc = cmd-&gt;transport_complete_callback(cmd, true);</span>
 		if (!rc &amp;&amp; !(cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE_POST)) {
<span class="p_add">+			if ((cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) &amp;&amp;</span>
<span class="p_add">+			    !cmd-&gt;data_length)</span>
<span class="p_add">+				goto queue_rsp;</span>
<span class="p_add">+</span>
 			return;
 		} else if (rc) {
 			ret = transport_send_check_condition_and_sense(cmd,
<span class="p_chunk">@@ -1918,6 +1922,7 @@</span> <span class="p_context"> static void target_complete_ok_work(struct work_struct *work)</span>
 		}
 	}
 
<span class="p_add">+queue_rsp:</span>
 	switch (cmd-&gt;data_direction) {
 	case DMA_FROM_DEVICE:
 		spin_lock(&amp;cmd-&gt;se_lun-&gt;lun_sep_lock);
<span class="p_chunk">@@ -2006,6 +2011,16 @@</span> <span class="p_context"> static inline void transport_reset_sgl_orig(struct se_cmd *cmd)</span>
 static inline void transport_free_pages(struct se_cmd *cmd)
 {
 	if (cmd-&gt;se_cmd_flags &amp; SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC) {
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Release special case READ buffer payload required for</span>
<span class="p_add">+		 * SG_TO_MEM_NOALLOC to function with COMPARE_AND_WRITE</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) {</span>
<span class="p_add">+			transport_free_sgl(cmd-&gt;t_bidi_data_sg,</span>
<span class="p_add">+					   cmd-&gt;t_bidi_data_nents);</span>
<span class="p_add">+			cmd-&gt;t_bidi_data_sg = NULL;</span>
<span class="p_add">+			cmd-&gt;t_bidi_data_nents = 0;</span>
<span class="p_add">+		}</span>
 		transport_reset_sgl_orig(cmd);
 		return;
 	}
<span class="p_chunk">@@ -2154,6 +2169,7 @@</span> <span class="p_context"> sense_reason_t</span>
 transport_generic_new_cmd(struct se_cmd *cmd)
 {
 	int ret = 0;
<span class="p_add">+	bool zero_flag = !(cmd-&gt;se_cmd_flags &amp; SCF_SCSI_DATA_CDB);</span>
 
 	/*
 	 * Determine is the TCM fabric module has already allocated physical
<span class="p_chunk">@@ -2162,7 +2178,6 @@</span> <span class="p_context"> transport_generic_new_cmd(struct se_cmd *cmd)</span>
 	 */
 	if (!(cmd-&gt;se_cmd_flags &amp; SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC) &amp;&amp;
 	    cmd-&gt;data_length) {
<span class="p_del">-		bool zero_flag = !(cmd-&gt;se_cmd_flags &amp; SCF_SCSI_DATA_CDB);</span>
 
 		if ((cmd-&gt;se_cmd_flags &amp; SCF_BIDI) ||
 		    (cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE)) {
<span class="p_chunk">@@ -2185,6 +2200,20 @@</span> <span class="p_context"> transport_generic_new_cmd(struct se_cmd *cmd)</span>
 				       cmd-&gt;data_length, zero_flag);
 		if (ret &lt; 0)
 			return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
<span class="p_add">+	} else if ((cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) &amp;&amp;</span>
<span class="p_add">+		    cmd-&gt;data_length) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Special case for COMPARE_AND_WRITE with fabrics</span>
<span class="p_add">+		 * using SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		u32 caw_length = cmd-&gt;t_task_nolb *</span>
<span class="p_add">+				 cmd-&gt;se_dev-&gt;dev_attrib.block_size;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = target_alloc_sgl(&amp;cmd-&gt;t_bidi_data_sg,</span>
<span class="p_add">+				       &amp;cmd-&gt;t_bidi_data_nents,</span>
<span class="p_add">+				       caw_length, zero_flag);</span>
<span class="p_add">+		if (ret &lt; 0)</span>
<span class="p_add">+			return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;</span>
 	}
 	/*
 	 * If this command is not a write we can execute it right here,
<span class="p_header">diff --git a/drivers/usb/class/cdc-wdm.c b/drivers/usb/class/cdc-wdm.c</span>
<span class="p_header">index a051a7a..a81f9dd 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-wdm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-wdm.c</span>
<span class="p_chunk">@@ -245,7 +245,7 @@</span> <span class="p_context"> static void wdm_int_callback(struct urb *urb)</span>
 	case USB_CDC_NOTIFY_RESPONSE_AVAILABLE:
 		dev_dbg(&amp;desc-&gt;intf-&gt;dev,
 			&quot;NOTIFY_RESPONSE_AVAILABLE received: index %d len %d&quot;,
<span class="p_del">-			dr-&gt;wIndex, dr-&gt;wLength);</span>
<span class="p_add">+			le16_to_cpu(dr-&gt;wIndex), le16_to_cpu(dr-&gt;wLength));</span>
 		break;
 
 	case USB_CDC_NOTIFY_NETWORK_CONNECTION:
<span class="p_chunk">@@ -262,7 +262,9 @@</span> <span class="p_context"> static void wdm_int_callback(struct urb *urb)</span>
 		clear_bit(WDM_POLL_RUNNING, &amp;desc-&gt;flags);
 		dev_err(&amp;desc-&gt;intf-&gt;dev,
 			&quot;unknown notification %d received: index %d len %d\n&quot;,
<span class="p_del">-			dr-&gt;bNotificationType, dr-&gt;wIndex, dr-&gt;wLength);</span>
<span class="p_add">+			dr-&gt;bNotificationType,</span>
<span class="p_add">+			le16_to_cpu(dr-&gt;wIndex),</span>
<span class="p_add">+			le16_to_cpu(dr-&gt;wLength));</span>
 		goto exit;
 	}
 
<span class="p_chunk">@@ -408,7 +410,7 @@</span> <span class="p_context"> static ssize_t wdm_write</span>
 			     USB_RECIP_INTERFACE);
 	req-&gt;bRequest = USB_CDC_SEND_ENCAPSULATED_COMMAND;
 	req-&gt;wValue = 0;
<span class="p_del">-	req-&gt;wIndex = desc-&gt;inum;</span>
<span class="p_add">+	req-&gt;wIndex = desc-&gt;inum; /* already converted */</span>
 	req-&gt;wLength = cpu_to_le16(count);
 	set_bit(WDM_IN_USE, &amp;desc-&gt;flags);
 	desc-&gt;outbuf = buf;
<span class="p_chunk">@@ -422,7 +424,7 @@</span> <span class="p_context"> static ssize_t wdm_write</span>
 		rv = usb_translate_errors(rv);
 	} else {
 		dev_dbg(&amp;desc-&gt;intf-&gt;dev, &quot;Tx URB has been submitted index=%d&quot;,
<span class="p_del">-			req-&gt;wIndex);</span>
<span class="p_add">+			le16_to_cpu(req-&gt;wIndex));</span>
 	}
 out:
 	usb_autopm_put_interface(desc-&gt;intf);
<span class="p_chunk">@@ -820,7 +822,7 @@</span> <span class="p_context"> static int wdm_create(struct usb_interface *intf, struct usb_endpoint_descriptor</span>
 	desc-&gt;irq-&gt;bRequestType = (USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE);
 	desc-&gt;irq-&gt;bRequest = USB_CDC_GET_ENCAPSULATED_RESPONSE;
 	desc-&gt;irq-&gt;wValue = 0;
<span class="p_del">-	desc-&gt;irq-&gt;wIndex = desc-&gt;inum;</span>
<span class="p_add">+	desc-&gt;irq-&gt;wIndex = desc-&gt;inum; /* already converted */</span>
 	desc-&gt;irq-&gt;wLength = cpu_to_le16(desc-&gt;wMaxCommand);
 
 	usb_fill_control_urb(
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 71d8918..9d61876 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -3280,10 +3280,10 @@</span> <span class="p_context"> int usb_port_resume(struct usb_device *udev, pm_message_t msg)</span>
 		dev_dbg(hub-&gt;intfdev, &quot;can&#39;t resume port %d, status %d\n&quot;,
 				port1, status);
 	} else {
<span class="p_del">-		/* drive resume for at least 20 msec */</span>
<span class="p_add">+		/* drive resume for USB_RESUME_TIMEOUT msec */</span>
 		dev_dbg(&amp;udev-&gt;dev, &quot;usb %sresume\n&quot;,
 				(PMSG_IS_AUTO(msg) ? &quot;auto-&quot; : &quot;&quot;));
<span class="p_del">-		msleep(25);</span>
<span class="p_add">+		msleep(USB_RESUME_TIMEOUT);</span>
 
 		/* Virtual root hubs can trigger on GET_PORT_STATUS to
 		 * stop resume signaling.  Then finish the resume
<span class="p_header">diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c</span>
<span class="p_header">index 86e6d39..ccb36a9 100644</span>
<span class="p_header">--- a/drivers/usb/host/ehci-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/ehci-hcd.c</span>
<span class="p_chunk">@@ -795,12 +795,12 @@</span> <span class="p_context"> static irqreturn_t ehci_irq (struct usb_hcd *hcd)</span>
 					ehci-&gt;reset_done[i] == 0))
 				continue;
 
<span class="p_del">-			/* start 20 msec resume signaling from this port,</span>
<span class="p_del">-			 * and make khubd collect PORT_STAT_C_SUSPEND to</span>
<span class="p_del">-			 * stop that signaling.  Use 5 ms extra for safety,</span>
<span class="p_del">-			 * like usb_port_resume() does.</span>
<span class="p_add">+			/* start USB_RESUME_TIMEOUT msec resume signaling from</span>
<span class="p_add">+			 * this port, and make khubd collect</span>
<span class="p_add">+			 * PORT_STAT_C_SUSPEND to stop that signaling.</span>
 			 */
<span class="p_del">-			ehci-&gt;reset_done[i] = jiffies + msecs_to_jiffies(25);</span>
<span class="p_add">+			ehci-&gt;reset_done[i] = jiffies +</span>
<span class="p_add">+				msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			set_bit(i, &amp;ehci-&gt;resuming_ports);
 			ehci_dbg (ehci, &quot;port %d remote wakeup\n&quot;, i + 1);
 			usb_hcd_start_port_resume(&amp;hcd-&gt;self, i);
<span class="p_header">diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c</span>
<span class="p_header">index 7ba8615..68a06b2 100644</span>
<span class="p_header">--- a/drivers/usb/host/ehci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/ehci-hub.c</span>
<span class="p_chunk">@@ -482,10 +482,13 @@</span> <span class="p_context"> static int ehci_bus_resume (struct usb_hcd *hcd)</span>
 		ehci_writel(ehci, temp, &amp;ehci-&gt;regs-&gt;port_status [i]);
 	}
 
<span class="p_del">-	/* msleep for 20ms only if code is trying to resume port */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * msleep for USB_RESUME_TIMEOUT ms only if code is trying to resume</span>
<span class="p_add">+	 * port</span>
<span class="p_add">+	 */</span>
 	if (resume_needed) {
 		spin_unlock_irq(&amp;ehci-&gt;lock);
<span class="p_del">-		msleep(20);</span>
<span class="p_add">+		msleep(USB_RESUME_TIMEOUT);</span>
 		spin_lock_irq(&amp;ehci-&gt;lock);
 		if (ehci-&gt;shutdown)
 			goto shutdown;
<span class="p_chunk">@@ -953,7 +956,7 @@</span> <span class="p_context"> static int ehci_hub_control (</span>
 			temp &amp;= ~PORT_WAKE_BITS;
 			ehci_writel(ehci, temp | PORT_RESUME, status_reg);
 			ehci-&gt;reset_done[wIndex] = jiffies
<span class="p_del">-					+ msecs_to_jiffies(20);</span>
<span class="p_add">+					+ msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			set_bit(wIndex, &amp;ehci-&gt;resuming_ports);
 			usb_hcd_start_port_resume(&amp;hcd-&gt;self, wIndex);
 			break;
<span class="p_header">diff --git a/drivers/usb/host/fotg210-hcd.c b/drivers/usb/host/fotg210-hcd.c</span>
<span class="p_header">index 55486bd..bbc4c49 100644</span>
<span class="p_header">--- a/drivers/usb/host/fotg210-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/fotg210-hcd.c</span>
<span class="p_chunk">@@ -1651,7 +1651,7 @@</span> <span class="p_context"> static int fotg210_hub_control(</span>
 			/* resume signaling for 20 msec */
 			fotg210_writel(fotg210, temp | PORT_RESUME, status_reg);
 			fotg210-&gt;reset_done[wIndex] = jiffies
<span class="p_del">-					+ msecs_to_jiffies(20);</span>
<span class="p_add">+					+ msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
 			clear_bit(wIndex, &amp;fotg210-&gt;port_c_suspend);
<span class="p_header">diff --git a/drivers/usb/host/fusbh200-hcd.c b/drivers/usb/host/fusbh200-hcd.c</span>
<span class="p_header">index e1c6d85..a1fa5fc 100644</span>
<span class="p_header">--- a/drivers/usb/host/fusbh200-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/fusbh200-hcd.c</span>
<span class="p_chunk">@@ -1610,10 +1610,9 @@</span> <span class="p_context"> static int fusbh200_hub_control (</span>
 			if ((temp &amp; PORT_PE) == 0)
 				goto error;
 
<span class="p_del">-			/* resume signaling for 20 msec */</span>
 			fusbh200_writel(fusbh200, temp | PORT_RESUME, status_reg);
 			fusbh200-&gt;reset_done[wIndex] = jiffies
<span class="p_del">-					+ msecs_to_jiffies(20);</span>
<span class="p_add">+					+ msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
 			clear_bit(wIndex, &amp;fusbh200-&gt;port_c_suspend);
<span class="p_header">diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c</span>
<span class="p_header">index c7d0f8f..200d33f 100644</span>
<span class="p_header">--- a/drivers/usb/host/isp116x-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/isp116x-hcd.c</span>
<span class="p_chunk">@@ -1488,7 +1488,7 @@</span> <span class="p_context"> static int isp116x_bus_resume(struct usb_hcd *hcd)</span>
 	spin_unlock_irq(&amp;isp116x-&gt;lock);
 
 	hcd-&gt;state = HC_STATE_RESUMING;
<span class="p_del">-	msleep(20);</span>
<span class="p_add">+	msleep(USB_RESUME_TIMEOUT);</span>
 
 	/* Go operational */
 	spin_lock_irq(&amp;isp116x-&gt;lock);
<span class="p_header">diff --git a/drivers/usb/host/isp1760-hcd.c b/drivers/usb/host/isp1760-hcd.c</span>
<span class="p_header">index ea50291..0efd791 100644</span>
<span class="p_header">--- a/drivers/usb/host/isp1760-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/isp1760-hcd.c</span>
<span class="p_chunk">@@ -1895,7 +1895,7 @@</span> <span class="p_context"> static int isp1760_hub_control(struct usb_hcd *hcd, u16 typeReq,</span>
 				reg_write32(hcd-&gt;regs, HC_PORTSC1,
 							temp | PORT_RESUME);
 				priv-&gt;reset_done = jiffies +
<span class="p_del">-					msecs_to_jiffies(20);</span>
<span class="p_add">+					msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			}
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
<span class="p_header">diff --git a/drivers/usb/host/oxu210hp-hcd.c b/drivers/usb/host/oxu210hp-hcd.c</span>
<span class="p_header">index 4a6df2d..e0a82d0 100644</span>
<span class="p_header">--- a/drivers/usb/host/oxu210hp-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/oxu210hp-hcd.c</span>
<span class="p_chunk">@@ -2497,11 +2497,12 @@</span> <span class="p_context"> static irqreturn_t oxu210_hcd_irq(struct usb_hcd *hcd)</span>
 					|| oxu-&gt;reset_done[i] != 0)
 				continue;
 
<span class="p_del">-			/* start 20 msec resume signaling from this port,</span>
<span class="p_del">-			 * and make khubd collect PORT_STAT_C_SUSPEND to</span>
<span class="p_add">+			/* start USB_RESUME_TIMEOUT resume signaling from this</span>
<span class="p_add">+			 * port, and make khubd collect PORT_STAT_C_SUSPEND to</span>
 			 * stop that signaling.
 			 */
<span class="p_del">-			oxu-&gt;reset_done[i] = jiffies + msecs_to_jiffies(20);</span>
<span class="p_add">+			oxu-&gt;reset_done[i] = jiffies +</span>
<span class="p_add">+				msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			oxu_dbg(oxu, &quot;port %d remote wakeup\n&quot;, i + 1);
 			mod_timer(&amp;hcd-&gt;rh_timer, oxu-&gt;reset_done[i]);
 		}
<span class="p_header">diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_header">index 2ad004a..736f437 100644</span>
<span class="p_header">--- a/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_chunk">@@ -2301,7 +2301,7 @@</span> <span class="p_context"> static int r8a66597_bus_resume(struct usb_hcd *hcd)</span>
 		rh-&gt;port &amp;= ~USB_PORT_STAT_SUSPEND;
 		rh-&gt;port |= USB_PORT_STAT_C_SUSPEND &lt;&lt; 16;
 		r8a66597_mdfy(r8a66597, RESUME, RESUME | UACT, dvstctr_reg);
<span class="p_del">-		msleep(50);</span>
<span class="p_add">+		msleep(USB_RESUME_TIMEOUT);</span>
 		r8a66597_mdfy(r8a66597, UACT, RESUME | UACT, dvstctr_reg);
 	}
 
<span class="p_header">diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c</span>
<span class="p_header">index 79620c3..cb7ba13 100644</span>
<span class="p_header">--- a/drivers/usb/host/sl811-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/sl811-hcd.c</span>
<span class="p_chunk">@@ -1260,7 +1260,7 @@</span> <span class="p_context"> sl811h_hub_control(</span>
 			sl811_write(sl811, SL11H_CTLREG1, sl811-&gt;ctrl1);
 
 			mod_timer(&amp;sl811-&gt;timer, jiffies
<span class="p_del">-					+ msecs_to_jiffies(20));</span>
<span class="p_add">+					+ msecs_to_jiffies(USB_RESUME_TIMEOUT));</span>
 			break;
 		case USB_PORT_FEAT_POWER:
 			port_power(sl811, 0);
<span class="p_header">diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c</span>
<span class="p_header">index 93e17b1..98c66d8 100644</span>
<span class="p_header">--- a/drivers/usb/host/uhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/uhci-hub.c</span>
<span class="p_chunk">@@ -165,7 +165,7 @@</span> <span class="p_context"> static void uhci_check_ports(struct uhci_hcd *uhci)</span>
 				/* Port received a wakeup request */
 				set_bit(port, &amp;uhci-&gt;resuming_ports);
 				uhci-&gt;ports_timeout = jiffies +
<span class="p_del">-						msecs_to_jiffies(25);</span>
<span class="p_add">+					msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 				usb_hcd_start_port_resume(
 						&amp;uhci_to_hcd(uhci)-&gt;self, port);
 
<span class="p_chunk">@@ -337,7 +337,8 @@</span> <span class="p_context"> static int uhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,</span>
 			uhci_finish_suspend(uhci, port, port_addr);
 
 			/* USB v2.0 7.1.7.5 */
<span class="p_del">-			uhci-&gt;ports_timeout = jiffies + msecs_to_jiffies(50);</span>
<span class="p_add">+			uhci-&gt;ports_timeout = jiffies +</span>
<span class="p_add">+				msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			break;
 		case USB_PORT_FEAT_POWER:
 			/* UHCI has no power switching */
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index 3c3818c..d032367 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -1785,7 +1785,7 @@</span> <span class="p_context"> static void handle_port_status(struct xhci_hcd *xhci,</span>
 		} else {
 			xhci_dbg(xhci, &quot;resume HS port %d\n&quot;, port_id);
 			bus_state-&gt;resume_done[faked_port_index] = jiffies +
<span class="p_del">-				msecs_to_jiffies(20);</span>
<span class="p_add">+				msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			set_bit(faked_port_index, &amp;bus_state-&gt;resuming_ports);
 			mod_timer(&amp;hcd-&gt;rh_timer,
 				  bus_state-&gt;resume_done[faked_port_index]);
<span class="p_header">diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c</span>
<span class="p_header">index b29331e..d595091 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musb_core.c</span>
<span class="p_header">+++ b/drivers/usb/musb/musb_core.c</span>
<span class="p_chunk">@@ -100,6 +100,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/io.h&gt;
 #include &lt;linux/dma-mapping.h&gt;
<span class="p_add">+#include &lt;linux/usb.h&gt;</span>
 
 #include &quot;musb_core.h&quot;
 
<span class="p_chunk">@@ -478,7 +479,7 @@</span> <span class="p_context"> static irqreturn_t musb_stage0_irq(struct musb *musb, u8 int_usb,</span>
 						(USB_PORT_STAT_C_SUSPEND &lt;&lt; 16)
 						| MUSB_PORT_STAT_RESUME;
 				musb-&gt;rh_timer = jiffies
<span class="p_del">-						+ msecs_to_jiffies(20);</span>
<span class="p_add">+					+ msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 
 				musb-&gt;xceiv-&gt;state = OTG_STATE_A_HOST;
 				musb-&gt;is_active = 1;
<span class="p_chunk">@@ -1514,16 +1515,30 @@</span> <span class="p_context"> irqreturn_t musb_interrupt(struct musb *musb)</span>
 		(devctl &amp; MUSB_DEVCTL_HM) ? &quot;host&quot; : &quot;peripheral&quot;,
 		musb-&gt;int_usb, musb-&gt;int_tx, musb-&gt;int_rx);
 
<span class="p_del">-	/* the core can interrupt us for multiple reasons; docs have</span>
<span class="p_del">-	 * a generic interrupt flowchart to follow</span>
<span class="p_add">+	/**</span>
<span class="p_add">+	 * According to Mentor Graphics&#39; documentation, flowchart on page 98,</span>
<span class="p_add">+	 * IRQ should be handled as follows:</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * . Resume IRQ</span>
<span class="p_add">+	 * . Session Request IRQ</span>
<span class="p_add">+	 * . VBUS Error IRQ</span>
<span class="p_add">+	 * . Suspend IRQ</span>
<span class="p_add">+	 * . Connect IRQ</span>
<span class="p_add">+	 * . Disconnect IRQ</span>
<span class="p_add">+	 * . Reset/Babble IRQ</span>
<span class="p_add">+	 * . SOF IRQ (we&#39;re not using this one)</span>
<span class="p_add">+	 * . Endpoint 0 IRQ</span>
<span class="p_add">+	 * . TX Endpoints</span>
<span class="p_add">+	 * . RX Endpoints</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We will be following that flowchart in order to avoid any problems</span>
<span class="p_add">+	 * that might arise with internal Finite State Machine.</span>
 	 */
<span class="p_add">+</span>
 	if (musb-&gt;int_usb)
 		retval |= musb_stage0_irq(musb, musb-&gt;int_usb,
 				devctl);
 
<span class="p_del">-	/* &quot;stage 1&quot; is handling endpoint irqs */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* handle endpoint 0 first */</span>
 	if (musb-&gt;int_tx &amp; 1) {
 		if (devctl &amp; MUSB_DEVCTL_HM)
 			retval |= musb_h_ep0_irq(musb);
<span class="p_chunk">@@ -1531,37 +1546,31 @@</span> <span class="p_context"> irqreturn_t musb_interrupt(struct musb *musb)</span>
 			retval |= musb_g_ep0_irq(musb);
 	}
 
<span class="p_del">-	/* RX on endpoints 1-15 */</span>
<span class="p_del">-	reg = musb-&gt;int_rx &gt;&gt; 1;</span>
<span class="p_add">+	reg = musb-&gt;int_tx &gt;&gt; 1;</span>
 	ep_num = 1;
 	while (reg) {
 		if (reg &amp; 1) {
<span class="p_del">-			/* musb_ep_select(musb-&gt;mregs, ep_num); */</span>
<span class="p_del">-			/* REVISIT just retval = ep-&gt;rx_irq(...) */</span>
 			retval = IRQ_HANDLED;
 			if (devctl &amp; MUSB_DEVCTL_HM)
<span class="p_del">-				musb_host_rx(musb, ep_num);</span>
<span class="p_add">+				musb_host_tx(musb, ep_num);</span>
 			else
<span class="p_del">-				musb_g_rx(musb, ep_num);</span>
<span class="p_add">+				musb_g_tx(musb, ep_num);</span>
 		}
<span class="p_del">-</span>
 		reg &gt;&gt;= 1;
 		ep_num++;
 	}
 
<span class="p_del">-	/* TX on endpoints 1-15 */</span>
<span class="p_del">-	reg = musb-&gt;int_tx &gt;&gt; 1;</span>
<span class="p_add">+	reg = musb-&gt;int_rx &gt;&gt; 1;</span>
 	ep_num = 1;
 	while (reg) {
 		if (reg &amp; 1) {
<span class="p_del">-			/* musb_ep_select(musb-&gt;mregs, ep_num); */</span>
<span class="p_del">-			/* REVISIT just retval |= ep-&gt;tx_irq(...) */</span>
 			retval = IRQ_HANDLED;
 			if (devctl &amp; MUSB_DEVCTL_HM)
<span class="p_del">-				musb_host_tx(musb, ep_num);</span>
<span class="p_add">+				musb_host_rx(musb, ep_num);</span>
 			else
<span class="p_del">-				musb_g_tx(musb, ep_num);</span>
<span class="p_add">+				musb_g_rx(musb, ep_num);</span>
 		}
<span class="p_add">+</span>
 		reg &gt;&gt;= 1;
 		ep_num++;
 	}
<span class="p_header">diff --git a/drivers/usb/musb/musb_virthub.c b/drivers/usb/musb/musb_virthub.c</span>
<span class="p_header">index 9af6bba..5448125 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musb_virthub.c</span>
<span class="p_header">+++ b/drivers/usb/musb/musb_virthub.c</span>
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> static void musb_port_suspend(struct musb *musb, bool do_suspend)</span>
 
 		/* later, GetPortStatus will stop RESUME signaling */
 		musb-&gt;port1_status |= MUSB_PORT_STAT_RESUME;
<span class="p_del">-		musb-&gt;rh_timer = jiffies + msecs_to_jiffies(20);</span>
<span class="p_add">+		musb-&gt;rh_timer = jiffies + msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/usb/phy/phy.c b/drivers/usb/phy/phy.c</span>
<span class="p_header">index 1b74523..19f0ba9 100644</span>
<span class="p_header">--- a/drivers/usb/phy/phy.c</span>
<span class="p_header">+++ b/drivers/usb/phy/phy.c</span>
<span class="p_chunk">@@ -78,7 +78,9 @@</span> <span class="p_context"> static void devm_usb_phy_release(struct device *dev, void *res)</span>
 
 static int devm_usb_phy_match(struct device *dev, void *res, void *match_data)
 {
<span class="p_del">-	return res == match_data;</span>
<span class="p_add">+	struct usb_phy **phy = res;</span>
<span class="p_add">+</span>
<span class="p_add">+	return *phy == match_data;</span>
 }
 
 /**
<span class="p_header">diff --git a/firmware/ihex2fw.c b/firmware/ihex2fw.c</span>
<span class="p_header">index cf38e15..08d90e2 100644</span>
<span class="p_header">--- a/firmware/ihex2fw.c</span>
<span class="p_header">+++ b/firmware/ihex2fw.c</span>
<span class="p_chunk">@@ -86,6 +86,7 @@</span> <span class="p_context"> int main(int argc, char **argv)</span>
 		case &#39;j&#39;:
 			include_jump = 1;
 			break;
<span class="p_add">+		default:</span>
 			return usage();
 		}
 	}
<span class="p_header">diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c</span>
<span class="p_header">index e714d7e..99b4bcf 100644</span>
<span class="p_header">--- a/fs/binfmt_elf.c</span>
<span class="p_header">+++ b/fs/binfmt_elf.c</span>
<span class="p_chunk">@@ -754,6 +754,7 @@</span> <span class="p_context"> static int load_elf_binary(struct linux_binprm *bprm)</span>
 	    i &lt; loc-&gt;elf_ex.e_phnum; i++, elf_ppnt++) {
 		int elf_prot = 0, elf_flags;
 		unsigned long k, vaddr;
<span class="p_add">+		unsigned long total_size = 0;</span>
 
 		if (elf_ppnt-&gt;p_type != PT_LOAD)
 			continue;
<span class="p_chunk">@@ -818,10 +819,16 @@</span> <span class="p_context"> static int load_elf_binary(struct linux_binprm *bprm)</span>
 #else
 			load_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);
 #endif
<span class="p_add">+			total_size = total_mapping_size(elf_phdata,</span>
<span class="p_add">+							loc-&gt;elf_ex.e_phnum);</span>
<span class="p_add">+			if (!total_size) {</span>
<span class="p_add">+				error = -EINVAL;</span>
<span class="p_add">+				goto out_free_dentry;</span>
<span class="p_add">+			}</span>
 		}
 
 		error = elf_map(bprm-&gt;file, load_bias + vaddr, elf_ppnt,
<span class="p_del">-				elf_prot, elf_flags, 0);</span>
<span class="p_add">+				elf_prot, elf_flags, total_size);</span>
 		if (BAD_ADDR(error)) {
 			send_sig(SIGKILL, current, 0);
 			retval = IS_ERR((void *)error) ?
<span class="p_header">diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c</span>
<span class="p_header">index 573da59..2e561e0 100644</span>
<span class="p_header">--- a/fs/btrfs/extent-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/extent-tree.c</span>
<span class="p_chunk">@@ -6667,12 +6667,11 @@</span> <span class="p_context"> static int __btrfs_free_reserved_extent(struct btrfs_root *root,</span>
 		return -ENOSPC;
 	}
 
<span class="p_del">-	if (btrfs_test_opt(root, DISCARD))</span>
<span class="p_del">-		ret = btrfs_discard_extent(root, start, len, NULL);</span>
<span class="p_del">-</span>
 	if (pin)
 		pin_down_extent(root, cache, start, len, 1);
 	else {
<span class="p_add">+		if (btrfs_test_opt(root, DISCARD))</span>
<span class="p_add">+			ret = btrfs_discard_extent(root, start, len, NULL);</span>
 		btrfs_add_free_space(cache, start, len);
 		btrfs_update_reserved_bytes(cache, len, RESERVE_FREE);
 	}
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index 043d6cd..05f5c87 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -2662,6 +2662,9 @@</span> <span class="p_context"> static int btrfs_extent_same(struct inode *src, u64 loff, u64 len,</span>
 	if (src == dst)
 		return -EINVAL;
 
<span class="p_add">+	if (len == 0)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	btrfs_double_lock(src, loff, dst, dst_loff, len);
 
 	ret = extent_same_check_offsets(src, loff, len);
<span class="p_chunk">@@ -3197,6 +3200,11 @@</span> <span class="p_context"> static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,</span>
 	if (off + len == src-&gt;i_size)
 		len = ALIGN(src-&gt;i_size, bs) - off;
 
<span class="p_add">+	if (len == 0) {</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* verify the end result is block aligned */
 	if (!IS_ALIGNED(off, bs) || !IS_ALIGNED(off + len, bs) ||
 	    !IS_ALIGNED(destoff, bs))
<span class="p_header">diff --git a/fs/btrfs/xattr.c b/fs/btrfs/xattr.c</span>
<span class="p_header">index 05740b9..7e21b2b 100644</span>
<span class="p_header">--- a/fs/btrfs/xattr.c</span>
<span class="p_header">+++ b/fs/btrfs/xattr.c</span>
<span class="p_chunk">@@ -322,21 +322,40 @@</span> <span class="p_context"> const struct xattr_handler *btrfs_xattr_handlers[] = {</span>
 /*
  * Check if the attribute is in a supported namespace.
  *
<span class="p_del">- * This applied after the check for the synthetic attributes in the system</span>
<span class="p_add">+ * This is applied after the check for the synthetic attributes in the system</span>
  * namespace.
  */
<span class="p_del">-static bool btrfs_is_valid_xattr(const char *name)</span>
<span class="p_add">+static int btrfs_is_valid_xattr(const char *name)</span>
 {
<span class="p_del">-	return !strncmp(name, XATTR_SECURITY_PREFIX,</span>
<span class="p_del">-			XATTR_SECURITY_PREFIX_LEN) ||</span>
<span class="p_del">-	       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||</span>
<span class="p_del">-	       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||</span>
<span class="p_del">-	       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);</span>
<span class="p_add">+	int len = strlen(name);</span>
<span class="p_add">+	int prefixlen = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!strncmp(name, XATTR_SECURITY_PREFIX,</span>
<span class="p_add">+			XATTR_SECURITY_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_SECURITY_PREFIX_LEN;</span>
<span class="p_add">+	else if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_SYSTEM_PREFIX_LEN;</span>
<span class="p_add">+	else if (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_TRUSTED_PREFIX_LEN;</span>
<span class="p_add">+	else if (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_USER_PREFIX_LEN;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return -EOPNOTSUPP;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The name cannot consist of just prefix</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (len &lt;= prefixlen)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 ssize_t btrfs_getxattr(struct dentry *dentry, const char *name,
 		       void *buffer, size_t size)
 {
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
 	/*
 	 * If this is a request for a synthetic attribute in the system.*
 	 * namespace use the generic infrastructure to resolve a handler
<span class="p_chunk">@@ -345,8 +364,9 @@</span> <span class="p_context"> ssize_t btrfs_getxattr(struct dentry *dentry, const char *name,</span>
 	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
 		return generic_getxattr(dentry, name, buffer, size);
 
<span class="p_del">-	if (!btrfs_is_valid_xattr(name))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+	ret = btrfs_is_valid_xattr(name);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 	return __btrfs_getxattr(dentry-&gt;d_inode, name, buffer, size);
 }
 
<span class="p_chunk">@@ -354,6 +374,7 @@</span> <span class="p_context"> int btrfs_setxattr(struct dentry *dentry, const char *name, const void *value,</span>
 		   size_t size, int flags)
 {
 	struct btrfs_root *root = BTRFS_I(dentry-&gt;d_inode)-&gt;root;
<span class="p_add">+	int ret;</span>
 
 	/*
 	 * The permission on security.* and system.* is not checked
<span class="p_chunk">@@ -370,8 +391,9 @@</span> <span class="p_context"> int btrfs_setxattr(struct dentry *dentry, const char *name, const void *value,</span>
 	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
 		return generic_setxattr(dentry, name, value, size, flags);
 
<span class="p_del">-	if (!btrfs_is_valid_xattr(name))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+	ret = btrfs_is_valid_xattr(name);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	if (size == 0)
 		value = &quot;&quot;;  /* empty EA, do not remove */
<span class="p_chunk">@@ -383,6 +405,7 @@</span> <span class="p_context"> int btrfs_setxattr(struct dentry *dentry, const char *name, const void *value,</span>
 int btrfs_removexattr(struct dentry *dentry, const char *name)
 {
 	struct btrfs_root *root = BTRFS_I(dentry-&gt;d_inode)-&gt;root;
<span class="p_add">+	int ret;</span>
 
 	/*
 	 * The permission on security.* and system.* is not checked
<span class="p_chunk">@@ -399,8 +422,9 @@</span> <span class="p_context"> int btrfs_removexattr(struct dentry *dentry, const char *name)</span>
 	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
 		return generic_removexattr(dentry, name);
 
<span class="p_del">-	if (!btrfs_is_valid_xattr(name))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+	ret = btrfs_is_valid_xattr(name);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	return __btrfs_setxattr(NULL, dentry-&gt;d_inode, name, NULL, 0,
 				XATTR_REPLACE);
<span class="p_header">diff --git a/fs/ext4/extents_status.c b/fs/ext4/extents_status.c</span>
<span class="p_header">index 171b9fa..4e8b79d 100644</span>
<span class="p_header">--- a/fs/ext4/extents_status.c</span>
<span class="p_header">+++ b/fs/ext4/extents_status.c</span>
<span class="p_chunk">@@ -656,6 +656,14 @@</span> <span class="p_context"> int ext4_es_insert_extent(struct inode *inode, ext4_lblk_t lblk,</span>
 
 	BUG_ON(end &lt; lblk);
 
<span class="p_add">+	if ((status &amp; EXTENT_STATUS_DELAYED) &amp;&amp;</span>
<span class="p_add">+	    (status &amp; EXTENT_STATUS_WRITTEN)) {</span>
<span class="p_add">+		ext4_warning(inode-&gt;i_sb, &quot;Inserting extent [%u/%u] as &quot;</span>
<span class="p_add">+				&quot; delayed and written which can potentially &quot;</span>
<span class="p_add">+				&quot; cause data loss.\n&quot;, lblk, len);</span>
<span class="p_add">+		WARN_ON(1);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	newes.es_lblk = lblk;
 	newes.es_len = len;
 	ext4_es_store_pblock(&amp;newes, pblk);
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index f2a02dd..6040097 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -574,6 +574,7 @@</span> <span class="p_context"> int ext4_map_blocks(handle_t *handle, struct inode *inode,</span>
 		status = map-&gt;m_flags &amp; EXT4_MAP_UNWRITTEN ?
 				EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;
 		if (!(flags &amp; EXT4_GET_BLOCKS_DELALLOC_RESERVE) &amp;&amp;
<span class="p_add">+		    !(status &amp; EXTENT_STATUS_WRITTEN) &amp;&amp;</span>
 		    ext4_find_delalloc_range(inode, map-&gt;m_lblk,
 					     map-&gt;m_lblk + map-&gt;m_len - 1))
 			status |= EXTENT_STATUS_DELAYED;
<span class="p_chunk">@@ -683,6 +684,7 @@</span> <span class="p_context"> found:</span>
 		status = map-&gt;m_flags &amp; EXT4_MAP_UNWRITTEN ?
 				EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;
 		if (!(flags &amp; EXT4_GET_BLOCKS_DELALLOC_RESERVE) &amp;&amp;
<span class="p_add">+		    !(status &amp; EXTENT_STATUS_WRITTEN) &amp;&amp;</span>
 		    ext4_find_delalloc_range(inode, map-&gt;m_lblk,
 					     map-&gt;m_lblk + map-&gt;m_len - 1))
 			status |= EXTENT_STATUS_DELAYED;
<span class="p_header">diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c</span>
<span class="p_header">index c8fd7ce..18b895f 100644</span>
<span class="p_header">--- a/fs/ext4/namei.c</span>
<span class="p_header">+++ b/fs/ext4/namei.c</span>
<span class="p_chunk">@@ -1878,7 +1878,7 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 			  struct inode *inode)
 {
 	struct inode *dir = dentry-&gt;d_parent-&gt;d_inode;
<span class="p_del">-	struct buffer_head *bh;</span>
<span class="p_add">+	struct buffer_head *bh = NULL;</span>
 	struct ext4_dir_entry_2 *de;
 	struct ext4_dir_entry_tail *t;
 	struct super_block *sb;
<span class="p_chunk">@@ -1902,14 +1902,14 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 			return retval;
 		if (retval == 1) {
 			retval = 0;
<span class="p_del">-			return retval;</span>
<span class="p_add">+			goto out;</span>
 		}
 	}
 
 	if (is_dx(dir)) {
 		retval = ext4_dx_add_entry(handle, dentry, inode);
 		if (!retval || (retval != ERR_BAD_DX_DIR))
<span class="p_del">-			return retval;</span>
<span class="p_add">+			goto out;</span>
 		ext4_clear_inode_flag(dir, EXT4_INODE_INDEX);
 		dx_fallback++;
 		ext4_mark_inode_dirty(handle, dir);
<span class="p_chunk">@@ -1921,14 +1921,15 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 			return PTR_ERR(bh);
 
 		retval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);
<span class="p_del">-		if (retval != -ENOSPC) {</span>
<span class="p_del">-			brelse(bh);</span>
<span class="p_del">-			return retval;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (retval != -ENOSPC)</span>
<span class="p_add">+			goto out;</span>
 
 		if (blocks == 1 &amp;&amp; !dx_fallback &amp;&amp;
<span class="p_del">-		    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX))</span>
<span class="p_del">-			return make_indexed_dir(handle, dentry, inode, bh);</span>
<span class="p_add">+		    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX)) {</span>
<span class="p_add">+			retval = make_indexed_dir(handle, dentry, inode, bh);</span>
<span class="p_add">+			bh = NULL; /* make_indexed_dir releases bh */</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
 		brelse(bh);
 	}
 	bh = ext4_append(handle, dir, &amp;block);
<span class="p_chunk">@@ -1944,6 +1945,7 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 	}
 
 	retval = add_dirent_to_buf(handle, dentry, inode, de, bh);
<span class="p_add">+out:</span>
 	brelse(bh);
 	if (retval == 0)
 		ext4_set_inode_state(inode, EXT4_STATE_NEWENTRY);
<span class="p_header">diff --git a/fs/namei.c b/fs/namei.c</span>
<span class="p_header">index ddb6721..f804083 100644</span>
<span class="p_header">--- a/fs/namei.c</span>
<span class="p_header">+++ b/fs/namei.c</span>
<span class="p_chunk">@@ -1537,7 +1537,8 @@</span> <span class="p_context"> static inline int walk_component(struct nameidata *nd, struct path *path,</span>
 
 	if (should_follow_link(path-&gt;dentry, follow)) {
 		if (nd-&gt;flags &amp; LOOKUP_RCU) {
<span class="p_del">-			if (unlikely(unlazy_walk(nd, path-&gt;dentry))) {</span>
<span class="p_add">+			if (unlikely(nd-&gt;path.mnt != path-&gt;mnt ||</span>
<span class="p_add">+				     unlazy_walk(nd, path-&gt;dentry))) {</span>
 				err = -ECHILD;
 				goto out_err;
 			}
<span class="p_chunk">@@ -2992,7 +2993,8 @@</span> <span class="p_context"> finish_lookup:</span>
 
 	if (should_follow_link(path-&gt;dentry, !symlink_ok)) {
 		if (nd-&gt;flags &amp; LOOKUP_RCU) {
<span class="p_del">-			if (unlikely(unlazy_walk(nd, path-&gt;dentry))) {</span>
<span class="p_add">+			if (unlikely(nd-&gt;path.mnt != path-&gt;mnt ||</span>
<span class="p_add">+				     unlazy_walk(nd, path-&gt;dentry))) {</span>
 				error = -ECHILD;
 				goto out;
 			}
<span class="p_header">diff --git a/fs/namespace.c b/fs/namespace.c</span>
<span class="p_header">index 289c216..01296f9 100644</span>
<span class="p_header">--- a/fs/namespace.c</span>
<span class="p_header">+++ b/fs/namespace.c</span>
<span class="p_chunk">@@ -1240,14 +1240,15 @@</span> <span class="p_context"> static inline void namespace_lock(void)</span>
 	down_write(&amp;namespace_sem);
 }
 
<span class="p_add">+enum umount_tree_flags {</span>
<span class="p_add">+	UMOUNT_SYNC = 1,</span>
<span class="p_add">+	UMOUNT_PROPAGATE = 2,</span>
<span class="p_add">+};</span>
 /*
  * mount_lock must be held
  * namespace_sem must be held for write
<span class="p_del">- * how = 0 =&gt; just this tree, don&#39;t propagate</span>
<span class="p_del">- * how = 1 =&gt; propagate; we know that nobody else has reference to any victims</span>
<span class="p_del">- * how = 2 =&gt; lazy umount</span>
  */
<span class="p_del">-void umount_tree(struct mount *mnt, int how)</span>
<span class="p_add">+static void umount_tree(struct mount *mnt, enum umount_tree_flags how)</span>
 {
 	HLIST_HEAD(tmp_list);
 	struct mount *p;
<span class="p_chunk">@@ -1261,7 +1262,7 @@</span> <span class="p_context"> void umount_tree(struct mount *mnt, int how)</span>
 	hlist_for_each_entry(p, &amp;tmp_list, mnt_hash)
 		list_del_init(&amp;p-&gt;mnt_child);
 
<span class="p_del">-	if (how)</span>
<span class="p_add">+	if (how &amp; UMOUNT_PROPAGATE)</span>
 		propagate_umount(&amp;tmp_list);
 
 	hlist_for_each_entry(p, &amp;tmp_list, mnt_hash) {
<span class="p_chunk">@@ -1269,7 +1270,7 @@</span> <span class="p_context"> void umount_tree(struct mount *mnt, int how)</span>
 		list_del_init(&amp;p-&gt;mnt_list);
 		__touch_mnt_namespace(p-&gt;mnt_ns);
 		p-&gt;mnt_ns = NULL;
<span class="p_del">-		if (how &lt; 2)</span>
<span class="p_add">+		if (how &amp; UMOUNT_SYNC)</span>
 			p-&gt;mnt.mnt_flags |= MNT_SYNC_UMOUNT;
 		if (mnt_has_parent(p)) {
 			put_mountpoint(p-&gt;mnt_mp);
<span class="p_chunk">@@ -1371,14 +1372,14 @@</span> <span class="p_context"> static int do_umount(struct mount *mnt, int flags)</span>
 
 	if (flags &amp; MNT_DETACH) {
 		if (!list_empty(&amp;mnt-&gt;mnt_list))
<span class="p_del">-			umount_tree(mnt, 2);</span>
<span class="p_add">+			umount_tree(mnt, UMOUNT_PROPAGATE);</span>
 		retval = 0;
 	} else {
 		shrink_submounts(mnt);
 		retval = -EBUSY;
 		if (!propagate_mount_busy(mnt, 2)) {
 			if (!list_empty(&amp;mnt-&gt;mnt_list))
<span class="p_del">-				umount_tree(mnt, 1);</span>
<span class="p_add">+				umount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC);</span>
 			retval = 0;
 		}
 	}
<span class="p_chunk">@@ -1538,7 +1539,7 @@</span> <span class="p_context"> struct mount *copy_tree(struct mount *mnt, struct dentry *dentry,</span>
 out:
 	if (res) {
 		lock_mount_hash();
<span class="p_del">-		umount_tree(res, 0);</span>
<span class="p_add">+		umount_tree(res, UMOUNT_SYNC);</span>
 		unlock_mount_hash();
 	}
 	return q;
<span class="p_chunk">@@ -1562,7 +1563,7 @@</span> <span class="p_context"> void drop_collected_mounts(struct vfsmount *mnt)</span>
 {
 	namespace_lock();
 	lock_mount_hash();
<span class="p_del">-	umount_tree(real_mount(mnt), 0);</span>
<span class="p_add">+	umount_tree(real_mount(mnt), UMOUNT_SYNC);</span>
 	unlock_mount_hash();
 	namespace_unlock();
 }
<span class="p_chunk">@@ -1718,7 +1719,7 @@</span> <span class="p_context"> static int attach_recursive_mnt(struct mount *source_mnt,</span>
  out_cleanup_ids:
 	while (!hlist_empty(&amp;tree_list)) {
 		child = hlist_entry(tree_list.first, struct mount, mnt_hash);
<span class="p_del">-		umount_tree(child, 0);</span>
<span class="p_add">+		umount_tree(child, UMOUNT_SYNC);</span>
 	}
 	unlock_mount_hash();
 	cleanup_group_ids(source_mnt, NULL);
<span class="p_chunk">@@ -1893,7 +1894,7 @@</span> <span class="p_context"> static int do_loopback(struct path *path, const char *old_name,</span>
 	err = graft_tree(mnt, parent, mp);
 	if (err) {
 		lock_mount_hash();
<span class="p_del">-		umount_tree(mnt, 0);</span>
<span class="p_add">+		umount_tree(mnt, UMOUNT_SYNC);</span>
 		unlock_mount_hash();
 	}
 out2:
<span class="p_chunk">@@ -2264,7 +2265,7 @@</span> <span class="p_context"> void mark_mounts_for_expiry(struct list_head *mounts)</span>
 	while (!list_empty(&amp;graveyard)) {
 		mnt = list_first_entry(&amp;graveyard, struct mount, mnt_expire);
 		touch_mnt_namespace(mnt-&gt;mnt_ns);
<span class="p_del">-		umount_tree(mnt, 1);</span>
<span class="p_add">+		umount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC);</span>
 	}
 	unlock_mount_hash();
 	namespace_unlock();
<span class="p_chunk">@@ -2335,7 +2336,7 @@</span> <span class="p_context"> static void shrink_submounts(struct mount *mnt)</span>
 			m = list_first_entry(&amp;graveyard, struct mount,
 						mnt_expire);
 			touch_mnt_namespace(m-&gt;mnt_ns);
<span class="p_del">-			umount_tree(m, 1);</span>
<span class="p_add">+			umount_tree(m, UMOUNT_PROPAGATE|UMOUNT_SYNC);</span>
 		}
 	}
 }
<span class="p_header">diff --git a/fs/nfs/callback.c b/fs/nfs/callback.c</span>
<span class="p_header">index 073b4cf..8c84994 100644</span>
<span class="p_header">--- a/fs/nfs/callback.c</span>
<span class="p_header">+++ b/fs/nfs/callback.c</span>
<span class="p_chunk">@@ -135,6 +135,7 @@</span> <span class="p_context"> nfs41_callback_svc(void *vrqstp)</span>
 					struct rpc_rqst, rq_bc_list);
 			list_del(&amp;req-&gt;rq_bc_list);
 			spin_unlock_bh(&amp;serv-&gt;sv_cb_lock);
<span class="p_add">+			finish_wait(&amp;serv-&gt;sv_cb_waitq, &amp;wq);</span>
 			dprintk(&quot;Invoking bc_svc_process()\n&quot;);
 			error = bc_svc_process(serv, req, rqstp);
 			dprintk(&quot;bc_svc_process() returned w/ error code= %d\n&quot;,
<span class="p_chunk">@@ -142,8 +143,9 @@</span> <span class="p_context"> nfs41_callback_svc(void *vrqstp)</span>
 		} else {
 			spin_unlock_bh(&amp;serv-&gt;sv_cb_lock);
 			schedule();
<span class="p_add">+			finish_wait(&amp;serv-&gt;sv_cb_waitq, &amp;wq);</span>
 		}
<span class="p_del">-		finish_wait(&amp;serv-&gt;sv_cb_waitq, &amp;wq);</span>
<span class="p_add">+		flush_signals(current);</span>
 	}
 	return 0;
 }
<span class="p_header">diff --git a/fs/open.c b/fs/open.c</span>
<span class="p_header">index 159f3e7..2855a16 100644</span>
<span class="p_header">--- a/fs/open.c</span>
<span class="p_header">+++ b/fs/open.c</span>
<span class="p_chunk">@@ -539,6 +539,7 @@</span> <span class="p_context"> static int chown_common(struct path *path, uid_t user, gid_t group)</span>
 	uid = make_kuid(current_user_ns(), user);
 	gid = make_kgid(current_user_ns(), group);
 
<span class="p_add">+retry_deleg:</span>
 	newattrs.ia_valid =  ATTR_CTIME;
 	if (user != (uid_t) -1) {
 		if (!uid_valid(uid))
<span class="p_chunk">@@ -555,7 +556,6 @@</span> <span class="p_context"> static int chown_common(struct path *path, uid_t user, gid_t group)</span>
 	if (!S_ISDIR(inode-&gt;i_mode))
 		newattrs.ia_valid |=
 			ATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_KILL_PRIV;
<span class="p_del">-retry_deleg:</span>
 	mutex_lock(&amp;inode-&gt;i_mutex);
 	error = security_path_chown(path, uid, gid);
 	if (!error)
<span class="p_header">diff --git a/fs/pnode.h b/fs/pnode.h</span>
<span class="p_header">index 4a24635..16afc3d 100644</span>
<span class="p_header">--- a/fs/pnode.h</span>
<span class="p_header">+++ b/fs/pnode.h</span>
<span class="p_chunk">@@ -47,7 +47,6 @@</span> <span class="p_context"> int get_dominating_id(struct mount *mnt, const struct path *root);</span>
 unsigned int mnt_get_count(struct mount *mnt);
 void mnt_set_mountpoint(struct mount *, struct mountpoint *,
 			struct mount *);
<span class="p_del">-void umount_tree(struct mount *, int);</span>
 struct mount *copy_tree(struct mount *, struct dentry *, int);
 bool is_path_reachable(struct mount *, struct dentry *,
 			 const struct path *root);
<span class="p_header">diff --git a/include/acpi/actypes.h b/include/acpi/actypes.h</span>
<span class="p_header">index 809b1a0..32fb16a 100644</span>
<span class="p_header">--- a/include/acpi/actypes.h</span>
<span class="p_header">+++ b/include/acpi/actypes.h</span>
<span class="p_chunk">@@ -198,9 +198,29 @@</span> <span class="p_context"> typedef int INT32;</span>
 typedef s32 acpi_native_int;
 
 typedef u32 acpi_size;
<span class="p_add">+</span>
<span class="p_add">+#ifdef ACPI_32BIT_PHYSICAL_ADDRESS</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * OSPMs can define this to shrink the size of the structures for 32-bit</span>
<span class="p_add">+ * none PAE environment. ASL compiler may always define this to generate</span>
<span class="p_add">+ * 32-bit OSPM compliant tables.</span>
<span class="p_add">+ */</span>
 typedef u32 acpi_io_address;
 typedef u32 acpi_physical_address;
 
<span class="p_add">+#else				/* ACPI_32BIT_PHYSICAL_ADDRESS */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * It is reported that, after some calculations, the physical addresses can</span>
<span class="p_add">+ * wrap over the 32-bit boundary on 32-bit PAE environment.</span>
<span class="p_add">+ * https://bugzilla.kernel.org/show_bug.cgi?id=87971</span>
<span class="p_add">+ */</span>
<span class="p_add">+typedef u64 acpi_io_address;</span>
<span class="p_add">+typedef u64 acpi_physical_address;</span>
<span class="p_add">+</span>
<span class="p_add">+#endif				/* ACPI_32BIT_PHYSICAL_ADDRESS */</span>
<span class="p_add">+</span>
 #define ACPI_MAX_PTR                    ACPI_UINT32_MAX
 #define ACPI_SIZE_MAX                   ACPI_UINT32_MAX
 
<span class="p_header">diff --git a/include/acpi/platform/acenv.h b/include/acpi/platform/acenv.h</span>
<span class="p_header">index 974d3ef..739b1ac 100644</span>
<span class="p_header">--- a/include/acpi/platform/acenv.h</span>
<span class="p_header">+++ b/include/acpi/platform/acenv.h</span>
<span class="p_chunk">@@ -76,6 +76,7 @@</span> <span class="p_context"></span>
 #define ACPI_LARGE_NAMESPACE_NODE
 #define ACPI_DATA_TABLE_DISASSEMBLY
 #define ACPI_SINGLE_THREADED
<span class="p_add">+#define ACPI_32BIT_PHYSICAL_ADDRESS</span>
 #endif
 
 /* acpi_exec configuration. Multithreaded with full AML debugger */
<span class="p_header">diff --git a/include/linux/jhash.h b/include/linux/jhash.h</span>
<span class="p_header">index 47cb09e..348c6f4 100644</span>
<span class="p_header">--- a/include/linux/jhash.h</span>
<span class="p_header">+++ b/include/linux/jhash.h</span>
<span class="p_chunk">@@ -145,11 +145,11 @@</span> <span class="p_context"> static inline u32 jhash2(const u32 *k, u32 length, u32 initval)</span>
 }
 
 
<span class="p_del">-/* jhash_3words - hash exactly 3, 2 or 1 word(s) */</span>
<span class="p_del">-static inline u32 jhash_3words(u32 a, u32 b, u32 c, u32 initval)</span>
<span class="p_add">+/* __jhash_nwords - hash exactly 3, 2 or 1 word(s) */</span>
<span class="p_add">+static inline u32 __jhash_nwords(u32 a, u32 b, u32 c, u32 initval)</span>
 {
<span class="p_del">-	a += JHASH_INITVAL;</span>
<span class="p_del">-	b += JHASH_INITVAL;</span>
<span class="p_add">+	a += initval;</span>
<span class="p_add">+	b += initval;</span>
 	c += initval;
 
 	__jhash_final(a, b, c);
<span class="p_chunk">@@ -157,14 +157,19 @@</span> <span class="p_context"> static inline u32 jhash_3words(u32 a, u32 b, u32 c, u32 initval)</span>
 	return c;
 }
 
<span class="p_add">+static inline u32 jhash_3words(u32 a, u32 b, u32 c, u32 initval)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __jhash_nwords(a, b, c, initval + JHASH_INITVAL + (3 &lt;&lt; 2));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline u32 jhash_2words(u32 a, u32 b, u32 initval)
 {
<span class="p_del">-	return jhash_3words(a, b, 0, initval);</span>
<span class="p_add">+	return __jhash_nwords(a, b, 0, initval + JHASH_INITVAL + (2 &lt;&lt; 2));</span>
 }
 
 static inline u32 jhash_1word(u32 a, u32 initval)
 {
<span class="p_del">-	return jhash_3words(a, 0, 0, initval);</span>
<span class="p_add">+	return __jhash_nwords(a, 0, 0, initval + JHASH_INITVAL + (1 &lt;&lt; 2));</span>
 }
 
 #endif /* _LINUX_JHASH_H */
<span class="p_header">diff --git a/include/linux/mlx5/device.h b/include/linux/mlx5/device.h</span>
<span class="p_header">index da78875..90a3b45 100644</span>
<span class="p_header">--- a/include/linux/mlx5/device.h</span>
<span class="p_header">+++ b/include/linux/mlx5/device.h</span>
<span class="p_chunk">@@ -231,7 +231,8 @@</span> <span class="p_context"> enum {</span>
 };
 
 enum {
<span class="p_del">-	MLX5_ADAPTER_PAGE_SHIFT		= 12</span>
<span class="p_add">+	MLX5_ADAPTER_PAGE_SHIFT		= 12,</span>
<span class="p_add">+	MLX5_ADAPTER_PAGE_SIZE		= 1 &lt;&lt; MLX5_ADAPTER_PAGE_SHIFT,</span>
 };
 
 enum {
<span class="p_header">diff --git a/include/linux/sched.h b/include/linux/sched.h</span>
<span class="p_header">index 81c20c49..286e593 100644</span>
<span class="p_header">--- a/include/linux/sched.h</span>
<span class="p_header">+++ b/include/linux/sched.h</span>
<span class="p_chunk">@@ -108,6 +108,14 @@</span> <span class="p_context"> extern unsigned long this_cpu_load(void);</span>
 extern void calc_global_load(unsigned long ticks);
 extern void update_cpu_load_nohz(void);
 
<span class="p_add">+/* Notifier for when a task gets migrated to a new CPU */</span>
<span class="p_add">+struct task_migration_notifier {</span>
<span class="p_add">+	struct task_struct *task;</span>
<span class="p_add">+	int from_cpu;</span>
<span class="p_add">+	int to_cpu;</span>
<span class="p_add">+};</span>
<span class="p_add">+extern void register_task_migration_notifier(struct notifier_block *n);</span>
<span class="p_add">+</span>
 extern unsigned long get_parent_ip(unsigned long addr);
 
 extern void dump_cpu_task(int cpu);
<span class="p_header">diff --git a/include/linux/usb.h b/include/linux/usb.h</span>
<span class="p_header">index 7454865..d21e2e3 100644</span>
<span class="p_header">--- a/include/linux/usb.h</span>
<span class="p_header">+++ b/include/linux/usb.h</span>
<span class="p_chunk">@@ -206,6 +206,32 @@</span> <span class="p_context"> void usb_put_intf(struct usb_interface *intf);</span>
 #define USB_MAXINTERFACES	32
 #define USB_MAXIADS		(USB_MAXINTERFACES/2)
 
<span class="p_add">+/*</span>
<span class="p_add">+ * USB Resume Timer: Every Host controller driver should drive the resume</span>
<span class="p_add">+ * signalling on the bus for the amount of time defined by this macro.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * That way we will have a &#39;stable&#39; behavior among all HCDs supported by Linux.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Note that the USB Specification states we should drive resume for *at least*</span>
<span class="p_add">+ * 20 ms, but it doesn&#39;t give an upper bound. This creates two possible</span>
<span class="p_add">+ * situations which we want to avoid:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * (a) sometimes an msleep(20) might expire slightly before 20 ms, which causes</span>
<span class="p_add">+ * us to fail USB Electrical Tests, thus failing Certification</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * (b) Some (many) devices actually need more than 20 ms of resume signalling,</span>
<span class="p_add">+ * and while we can argue that&#39;s against the USB Specification, we don&#39;t have</span>
<span class="p_add">+ * control over which devices a certification laboratory will be using for</span>
<span class="p_add">+ * certification. If CertLab uses a device which was tested against Windows and</span>
<span class="p_add">+ * that happens to have relaxed resume signalling rules, we might fall into</span>
<span class="p_add">+ * situations where we fail interoperability and electrical tests.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * In order to avoid both conditions, we&#39;re using a 40 ms resume timeout, which</span>
<span class="p_add">+ * should cope with both LPJ calibration errors and devices not following every</span>
<span class="p_add">+ * detail of the USB Specification.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define USB_RESUME_TIMEOUT	40 /* ms */</span>
<span class="p_add">+</span>
 /**
  * struct usb_interface_cache - long-term representation of a device interface
  * @num_altsetting: number of altsettings defined.
<span class="p_header">diff --git a/include/target/target_core_base.h b/include/target/target_core_base.h</span>
<span class="p_header">index 8baf440..1f2c8e7 100644</span>
<span class="p_header">--- a/include/target/target_core_base.h</span>
<span class="p_header">+++ b/include/target/target_core_base.h</span>
<span class="p_chunk">@@ -458,7 +458,7 @@</span> <span class="p_context"> struct se_cmd {</span>
 	sense_reason_t		(*execute_cmd)(struct se_cmd *);
 	sense_reason_t		(*execute_rw)(struct se_cmd *, struct scatterlist *,
 					      u32, enum dma_data_direction);
<span class="p_del">-	sense_reason_t (*transport_complete_callback)(struct se_cmd *);</span>
<span class="p_add">+	sense_reason_t (*transport_complete_callback)(struct se_cmd *, bool);</span>
 
 	unsigned char		*t_task_cdb;
 	unsigned char		__t_task_cdb[TCM_MAX_COMMAND_SIZE];
<span class="p_header">diff --git a/kernel/ptrace.c b/kernel/ptrace.c</span>
<span class="p_header">index 1f4bcb3..be9760f 100644</span>
<span class="p_header">--- a/kernel/ptrace.c</span>
<span class="p_header">+++ b/kernel/ptrace.c</span>
<span class="p_chunk">@@ -720,6 +720,8 @@</span> <span class="p_context"> static int ptrace_peek_siginfo(struct task_struct *child,</span>
 static int ptrace_resume(struct task_struct *child, long request,
 			 unsigned long data)
 {
<span class="p_add">+	bool need_siglock;</span>
<span class="p_add">+</span>
 	if (!valid_signal(data))
 		return -EIO;
 
<span class="p_chunk">@@ -747,8 +749,26 @@</span> <span class="p_context"> static int ptrace_resume(struct task_struct *child, long request,</span>
 		user_disable_single_step(child);
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Change -&gt;exit_code and -&gt;state under siglock to avoid the race</span>
<span class="p_add">+	 * with wait_task_stopped() in between; a non-zero -&gt;exit_code will</span>
<span class="p_add">+	 * wrongly look like another report from tracee.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note that we need siglock even if -&gt;exit_code == data and/or this</span>
<span class="p_add">+	 * status was not reported yet, the new status must not be cleared by</span>
<span class="p_add">+	 * wait_task_stopped() after resume.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * If data == 0 we do not care if wait_task_stopped() reports the old</span>
<span class="p_add">+	 * status and clears the code too; this can&#39;t race with the tracee, it</span>
<span class="p_add">+	 * takes siglock after resume.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	need_siglock = data &amp;&amp; !thread_group_empty(current);</span>
<span class="p_add">+	if (need_siglock)</span>
<span class="p_add">+		spin_lock_irq(&amp;child-&gt;sighand-&gt;siglock);</span>
 	child-&gt;exit_code = data;
 	wake_up_state(child, __TASK_TRACED);
<span class="p_add">+	if (need_siglock)</span>
<span class="p_add">+		spin_unlock_irq(&amp;child-&gt;sighand-&gt;siglock);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 0a90d12..a3b0ea0 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -974,6 +974,13 @@</span> <span class="p_context"> void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)</span>
 		rq-&gt;skip_clock_update = 1;
 }
 
<span class="p_add">+static ATOMIC_NOTIFIER_HEAD(task_migration_notifier);</span>
<span class="p_add">+</span>
<span class="p_add">+void register_task_migration_notifier(struct notifier_block *n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	atomic_notifier_chain_register(&amp;task_migration_notifier, n);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #ifdef CONFIG_SMP
 void set_task_cpu(struct task_struct *p, unsigned int new_cpu)
 {
<span class="p_chunk">@@ -1004,10 +1011,18 @@</span> <span class="p_context"> void set_task_cpu(struct task_struct *p, unsigned int new_cpu)</span>
 	trace_sched_migrate_task(p, new_cpu);
 
 	if (task_cpu(p) != new_cpu) {
<span class="p_add">+		struct task_migration_notifier tmn;</span>
<span class="p_add">+</span>
 		if (p-&gt;sched_class-&gt;migrate_task_rq)
 			p-&gt;sched_class-&gt;migrate_task_rq(p, new_cpu);
 		p-&gt;se.nr_migrations++;
 		perf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, NULL, 0);
<span class="p_add">+</span>
<span class="p_add">+		tmn.task = p;</span>
<span class="p_add">+		tmn.from_cpu = task_cpu(p);</span>
<span class="p_add">+		tmn.to_cpu = new_cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+		atomic_notifier_call_chain(&amp;task_migration_notifier, 0, &amp;tmn);</span>
 	}
 
 	__set_task_cpu(p, new_cpu);
<span class="p_header">diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c</span>
<span class="p_header">index a701f50..dc0a884 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer.c</span>
<span class="p_chunk">@@ -2648,7 +2648,7 @@</span> <span class="p_context"> static DEFINE_PER_CPU(unsigned int, current_context);</span>
 
 static __always_inline int trace_recursive_lock(void)
 {
<span class="p_del">-	unsigned int val = this_cpu_read(current_context);</span>
<span class="p_add">+	unsigned int val = __this_cpu_read(current_context);</span>
 	int bit;
 
 	if (in_interrupt()) {
<span class="p_chunk">@@ -2665,18 +2665,17 @@</span> <span class="p_context"> static __always_inline int trace_recursive_lock(void)</span>
 		return 1;
 
 	val |= (1 &lt;&lt; bit);
<span class="p_del">-	this_cpu_write(current_context, val);</span>
<span class="p_add">+	__this_cpu_write(current_context, val);</span>
 
 	return 0;
 }
 
 static __always_inline void trace_recursive_unlock(void)
 {
<span class="p_del">-	unsigned int val = this_cpu_read(current_context);</span>
<span class="p_add">+	unsigned int val = __this_cpu_read(current_context);</span>
 
<span class="p_del">-	val--;</span>
<span class="p_del">-	val &amp;= this_cpu_read(current_context);</span>
<span class="p_del">-	this_cpu_write(current_context, val);</span>
<span class="p_add">+	val &amp;= val &amp; (val - 1);</span>
<span class="p_add">+	__this_cpu_write(current_context, val);</span>
 }
 
 #else
<span class="p_header">diff --git a/lib/string.c b/lib/string.c</span>
<span class="p_header">index 43d0781..cb9ea21 100644</span>
<span class="p_header">--- a/lib/string.c</span>
<span class="p_header">+++ b/lib/string.c</span>
<span class="p_chunk">@@ -598,7 +598,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(memset);</span>
 void memzero_explicit(void *s, size_t count)
 {
 	memset(s, 0, count);
<span class="p_del">-	OPTIMIZER_HIDE_VAR(s);</span>
<span class="p_add">+	barrier();</span>
 }
 EXPORT_SYMBOL(memzero_explicit);
 
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index a716aac..b14f49b 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -3491,8 +3491,7 @@</span> <span class="p_context"> retry:</span>
 	if (!pmd_huge(*pmd))
 		goto out;
 	if (pmd_present(*pmd)) {
<span class="p_del">-		page = pte_page(*(pte_t *)pmd) +</span>
<span class="p_del">-			((address &amp; ~PMD_MASK) &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+		page = pmd_page(*pmd) + ((address &amp; ~PMD_MASK) &gt;&gt; PAGE_SHIFT);</span>
 		if (flags &amp; FOLL_GET)
 			get_page(page);
 	} else {
<span class="p_header">diff --git a/net/core/skbuff.c b/net/core/skbuff.c</span>
<span class="p_header">index 1008034..a937b23 100644</span>
<span class="p_header">--- a/net/core/skbuff.c</span>
<span class="p_header">+++ b/net/core/skbuff.c</span>
<span class="p_chunk">@@ -3578,18 +3578,21 @@</span> <span class="p_context"> EXPORT_SYMBOL(skb_try_coalesce);</span>
  */
 void skb_scrub_packet(struct sk_buff *skb, bool xnet)
 {
<span class="p_del">-	if (xnet)</span>
<span class="p_del">-		skb_orphan(skb);</span>
 	skb-&gt;tstamp.tv64 = 0;
 	skb-&gt;pkt_type = PACKET_HOST;
 	skb-&gt;skb_iif = 0;
 	skb-&gt;local_df = 0;
 	skb_dst_drop(skb);
<span class="p_del">-	skb-&gt;mark = 0;</span>
 	skb_init_secmark(skb);
 	secpath_reset(skb);
 	nf_reset(skb);
 	nf_reset_trace(skb);
<span class="p_add">+</span>
<span class="p_add">+	if (!xnet)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	skb_orphan(skb);</span>
<span class="p_add">+	skb-&gt;mark = 0;</span>
 }
 EXPORT_SYMBOL_GPL(skb_scrub_packet);
 
<span class="p_header">diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c</span>
<span class="p_header">index 1785576..4061098 100644</span>
<span class="p_header">--- a/scripts/mod/modpost.c</span>
<span class="p_header">+++ b/scripts/mod/modpost.c</span>
<span class="p_chunk">@@ -584,12 +584,16 @@</span> <span class="p_context"> static int ignore_undef_symbol(struct elf_info *info, const char *symname)</span>
 		if (strncmp(symname, &quot;_restgpr_&quot;, sizeof(&quot;_restgpr_&quot;) - 1) == 0 ||
 		    strncmp(symname, &quot;_savegpr_&quot;, sizeof(&quot;_savegpr_&quot;) - 1) == 0 ||
 		    strncmp(symname, &quot;_rest32gpr_&quot;, sizeof(&quot;_rest32gpr_&quot;) - 1) == 0 ||
<span class="p_del">-		    strncmp(symname, &quot;_save32gpr_&quot;, sizeof(&quot;_save32gpr_&quot;) - 1) == 0)</span>
<span class="p_add">+		    strncmp(symname, &quot;_save32gpr_&quot;, sizeof(&quot;_save32gpr_&quot;) - 1) == 0 ||</span>
<span class="p_add">+		    strncmp(symname, &quot;_restvr_&quot;, sizeof(&quot;_restvr_&quot;) - 1) == 0 ||</span>
<span class="p_add">+		    strncmp(symname, &quot;_savevr_&quot;, sizeof(&quot;_savevr_&quot;) - 1) == 0)</span>
 			return 1;
 	if (info-&gt;hdr-&gt;e_machine == EM_PPC64)
 		/* Special register function linked on all modules during final link of .ko */
 		if (strncmp(symname, &quot;_restgpr0_&quot;, sizeof(&quot;_restgpr0_&quot;) - 1) == 0 ||
<span class="p_del">-		    strncmp(symname, &quot;_savegpr0_&quot;, sizeof(&quot;_savegpr0_&quot;) - 1) == 0)</span>
<span class="p_add">+		    strncmp(symname, &quot;_savegpr0_&quot;, sizeof(&quot;_savegpr0_&quot;) - 1) == 0 ||</span>
<span class="p_add">+		    strncmp(symname, &quot;_restvr_&quot;, sizeof(&quot;_restvr_&quot;) - 1) == 0 ||</span>
<span class="p_add">+		    strncmp(symname, &quot;_savevr_&quot;, sizeof(&quot;_savevr_&quot;) - 1) == 0)</span>
 			return 1;
 	/* Do not ignore this symbol */
 	return 0;
<span class="p_header">diff --git a/sound/pci/emu10k1/emuproc.c b/sound/pci/emu10k1/emuproc.c</span>
<span class="p_header">index 2ca9f2e..53745f4 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emuproc.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emuproc.c</span>
<span class="p_chunk">@@ -241,31 +241,22 @@</span> <span class="p_context"> static void snd_emu10k1_proc_spdif_read(struct snd_info_entry *entry,</span>
 	struct snd_emu10k1 *emu = entry-&gt;private_data;
 	u32 value;
 	u32 value2;
<span class="p_del">-	unsigned long flags;</span>
 	u32 rate;
 
 	if (emu-&gt;card_capabilities-&gt;emu_model) {
<span class="p_del">-		spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_emu1010_fpga_read(emu, 0x38, &amp;value);
<span class="p_del">-		spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 		if ((value &amp; 0x1) == 0) {
<span class="p_del">-			spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 			snd_emu1010_fpga_read(emu, 0x2a, &amp;value);
 			snd_emu1010_fpga_read(emu, 0x2b, &amp;value2);
<span class="p_del">-			spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 			rate = 0x1770000 / (((value &lt;&lt; 5) | value2)+1);	
 			snd_iprintf(buffer, &quot;ADAT Locked : %u\n&quot;, rate);
 		} else {
 			snd_iprintf(buffer, &quot;ADAT Unlocked\n&quot;);
 		}
<span class="p_del">-		spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_emu1010_fpga_read(emu, 0x20, &amp;value);
<span class="p_del">-		spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 		if ((value &amp; 0x4) == 0) {
<span class="p_del">-			spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 			snd_emu1010_fpga_read(emu, 0x28, &amp;value);
 			snd_emu1010_fpga_read(emu, 0x29, &amp;value2);
<span class="p_del">-			spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 			rate = 0x1770000 / (((value &lt;&lt; 5) | value2)+1);	
 			snd_iprintf(buffer, &quot;SPDIF Locked : %d\n&quot;, rate);
 		} else {
<span class="p_chunk">@@ -410,14 +401,11 @@</span> <span class="p_context"> static void snd_emu_proc_emu1010_reg_read(struct snd_info_entry *entry,</span>
 {
 	struct snd_emu10k1 *emu = entry-&gt;private_data;
 	u32 value;
<span class="p_del">-	unsigned long flags;</span>
 	int i;
 	snd_iprintf(buffer, &quot;EMU1010 Registers:\n\n&quot;);
 
 	for(i = 0; i &lt; 0x40; i+=1) {
<span class="p_del">-		spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_emu1010_fpga_read(emu, i, &amp;value);
<span class="p_del">-		spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_iprintf(buffer, &quot;%02X: %08X, %02X\n&quot;, i, value, (value &gt;&gt; 8) &amp; 0x7f);
 	}
 }
<span class="p_header">diff --git a/sound/soc/codecs/cs4271.c b/sound/soc/codecs/cs4271.c</span>
<span class="p_header">index 97c3dbe..9f4bb12 100644</span>
<span class="p_header">--- a/sound/soc/codecs/cs4271.c</span>
<span class="p_header">+++ b/sound/soc/codecs/cs4271.c</span>
<span class="p_chunk">@@ -572,10 +572,10 @@</span> <span class="p_context"> static int cs4271_probe(struct snd_soc_codec *codec)</span>
 	if (gpio_nreset &gt;= 0) {
 		/* Reset codec */
 		gpio_direction_output(gpio_nreset, 0);
<span class="p_del">-		udelay(1);</span>
<span class="p_add">+		mdelay(1);</span>
 		gpio_set_value(gpio_nreset, 1);
 		/* Give the codec time to wake up */
<span class="p_del">-		udelay(1);</span>
<span class="p_add">+		mdelay(1);</span>
 	}
 
 	cs4271-&gt;gpio_nreset = gpio_nreset;
<span class="p_header">diff --git a/sound/soc/codecs/wm8741.c b/sound/soc/codecs/wm8741.c</span>
<span class="p_header">index b18813c..63089ed 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8741.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8741.c</span>
<span class="p_chunk">@@ -123,7 +123,7 @@</span> <span class="p_context"> static struct {</span>
 };
 
 static unsigned int rates_11289[] = {
<span class="p_del">-	44100, 88235,</span>
<span class="p_add">+	44100, 88200,</span>
 };
 
 static struct snd_pcm_hw_constraint_list constraints_11289 = {
<span class="p_chunk">@@ -150,7 +150,7 @@</span> <span class="p_context"> static struct snd_pcm_hw_constraint_list constraints_16384 = {</span>
 };
 
 static unsigned int rates_16934[] = {
<span class="p_del">-	44100, 88235,</span>
<span class="p_add">+	44100, 88200,</span>
 };
 
 static struct snd_pcm_hw_constraint_list constraints_16934 = {
<span class="p_chunk">@@ -168,7 +168,7 @@</span> <span class="p_context"> static struct snd_pcm_hw_constraint_list constraints_18432 = {</span>
 };
 
 static unsigned int rates_22579[] = {
<span class="p_del">-	44100, 88235, 1764000</span>
<span class="p_add">+	44100, 88200, 176400</span>
 };
 
 static struct snd_pcm_hw_constraint_list constraints_22579 = {
<span class="p_chunk">@@ -186,7 +186,7 @@</span> <span class="p_context"> static struct snd_pcm_hw_constraint_list constraints_24576 = {</span>
 };
 
 static unsigned int rates_36864[] = {
<span class="p_del">-	48000, 96000, 19200</span>
<span class="p_add">+	48000, 96000, 192000</span>
 };
 
 static struct snd_pcm_hw_constraint_list constraints_36864 = {
<span class="p_header">diff --git a/sound/soc/davinci/davinci-evm.c b/sound/soc/davinci/davinci-evm.c</span>
<span class="p_header">index 623eb5e..23123e8 100644</span>
<span class="p_header">--- a/sound/soc/davinci/davinci-evm.c</span>
<span class="p_header">+++ b/sound/soc/davinci/davinci-evm.c</span>
<span class="p_chunk">@@ -396,18 +396,8 @@</span> <span class="p_context"> static int davinci_evm_probe(struct platform_device *pdev)</span>
 	return ret;
 }
 
<span class="p_del">-static int davinci_evm_remove(struct platform_device *pdev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct snd_soc_card *card = platform_get_drvdata(pdev);</span>
<span class="p_del">-</span>
<span class="p_del">-	snd_soc_unregister_card(card);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static struct platform_driver davinci_evm_driver = {
 	.probe		= davinci_evm_probe,
<span class="p_del">-	.remove		= davinci_evm_remove,</span>
 	.driver		= {
 		.name	= &quot;davinci_evm&quot;,
 		.owner	= THIS_MODULE,
<span class="p_header">diff --git a/tools/lib/traceevent/kbuffer-parse.c b/tools/lib/traceevent/kbuffer-parse.c</span>
<span class="p_header">index dcc6652..deb3569 100644</span>
<span class="p_header">--- a/tools/lib/traceevent/kbuffer-parse.c</span>
<span class="p_header">+++ b/tools/lib/traceevent/kbuffer-parse.c</span>
<span class="p_chunk">@@ -372,7 +372,6 @@</span> <span class="p_context"> translate_data(struct kbuffer *kbuf, void *data, void **rptr,</span>
 	switch (type_len) {
 	case KBUFFER_TYPE_PADDING:
 		*length = read_4(kbuf, data);
<span class="p_del">-		data += *length;</span>
 		break;
 
 	case KBUFFER_TYPE_TIME_EXTEND:
<span class="p_header">diff --git a/tools/power/x86/turbostat/Makefile b/tools/power/x86/turbostat/Makefile</span>
<span class="p_header">index d1b3a36..4039854 100644</span>
<span class="p_header">--- a/tools/power/x86/turbostat/Makefile</span>
<span class="p_header">+++ b/tools/power/x86/turbostat/Makefile</span>
<span class="p_chunk">@@ -1,8 +1,12 @@</span> <span class="p_context"></span>
 CC		= $(CROSS_COMPILE)gcc
<span class="p_del">-BUILD_OUTPUT	:= $(PWD)</span>
<span class="p_add">+BUILD_OUTPUT	:= $(CURDIR)</span>
 PREFIX		:= /usr
 DESTDIR		:=
 
<span class="p_add">+ifeq (&quot;$(origin O)&quot;, &quot;command line&quot;)</span>
<span class="p_add">+	BUILD_OUTPUT := $(O)</span>
<span class="p_add">+endif</span>
<span class="p_add">+</span>
 turbostat : turbostat.c
 CFLAGS +=	-Wall
 CFLAGS +=	-DMSRHEADER=&#39;&quot;../../../../arch/x86/include/uapi/asm/msr-index.h&quot;&#39;
<span class="p_header">diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c</span>
<span class="p_header">index 8d2a98a..db50f4c 100644</span>
<span class="p_header">--- a/virt/kvm/kvm_main.c</span>
<span class="p_header">+++ b/virt/kvm/kvm_main.c</span>
<span class="p_chunk">@@ -1559,8 +1559,8 @@</span> <span class="p_context"> int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc,</span>
 	ghc-&gt;generation = slots-&gt;generation;
 	ghc-&gt;len = len;
 	ghc-&gt;memslot = gfn_to_memslot(kvm, start_gfn);
<span class="p_del">-	ghc-&gt;hva = gfn_to_hva_many(ghc-&gt;memslot, start_gfn, &amp;nr_pages_avail);</span>
<span class="p_del">-	if (!kvm_is_error_hva(ghc-&gt;hva) &amp;&amp; nr_pages_avail &gt;= nr_pages_needed) {</span>
<span class="p_add">+	ghc-&gt;hva = gfn_to_hva_many(ghc-&gt;memslot, start_gfn, NULL);</span>
<span class="p_add">+	if (!kvm_is_error_hva(ghc-&gt;hva) &amp;&amp; nr_pages_needed &lt;= 1) {</span>
 		ghc-&gt;hva += offset;
 	} else {
 		/*

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



