
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.2.71 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.2.71</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 14, 2015, 6:39 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1439577546.10857.98.camel@decadent.org.uk&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7019211/mbox/"
   >mbox</a>
|
   <a href="/patch/7019211/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7019211/">/patch/7019211/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id EF7CA9F39D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 14 Aug 2015 18:39:53 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 0241D20825
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 14 Aug 2015 18:39:47 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 29FA5207B7
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 14 Aug 2015 18:39:35 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751966AbbHNSjZ (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 14 Aug 2015 14:39:25 -0400
Received: from shadbolt.e.decadent.org.uk ([88.96.1.126]:35168 &quot;EHLO
	shadbolt.e.decadent.org.uk&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S1751004AbbHNSjS (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 14 Aug 2015 14:39:18 -0400
Received: from [141.70.72.77] (helo=deadeye)
	by shadbolt.decadent.org.uk with esmtps
	(TLS1.2:ECDHE_RSA_AES_128_GCM_SHA256:128) (Exim 4.84)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1ZQJsm-0006oV-8D; Fri, 14 Aug 2015 19:39:12 +0100
Received: from ben by deadeye with local (Exim 4.86)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1ZQJsg-0006Yu-TA; Fri, 14 Aug 2015 20:39:06 +0200
Message-ID: &lt;1439577546.10857.98.camel@decadent.org.uk&gt;
Subject: Linux 3.2.71
From: Ben Hutchings &lt;ben@decadent.org.uk&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, Jiri Slaby &lt;jslaby@suse.cz&gt;,
	stable@vger.kernel.org
Cc: lwn@lwn.net
Date: Fri, 14 Aug 2015 20:39:06 +0200
Content-Type: multipart/signed; micalg=&quot;pgp-sha512&quot;;
	protocol=&quot;application/pgp-signature&quot;;
	boundary=&quot;=-zUgARnJz+9jMAqRJQLks&quot;
X-Mailer: Evolution 3.16.3-1 
Mime-Version: 1.0
X-SA-Exim-Connect-IP: 141.70.72.77
X-SA-Exim-Mail-From: ben@decadent.org.uk
X-SA-Exim-Scanned: No (on shadbolt.decadent.org.uk);
	SAEximRunCond expanded to false
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD, T_TVD_MIME_EPI,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a> - Aug. 14, 2015, 6:39 p.m.</div>
<pre class="content">
I&#39;m announcing the release of the 3.2.71 kernel.

All users of the 3.2 kernel series should upgrade.

The updated 3.2.y git tree can be found at:
        git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git linux-3.2.y
and can be browsed at the normal kernel.org git web browser:
        http://git.kernel.org/?p=linux/kernel/git/stable/linux-stable.git

The diff from 3.2.70 is attached to this message.

Ben.

------------

 Makefile                                          |   2 +-
 arch/s390/kernel/process.c                        |   2 +-
 arch/s390/kernel/sclp.S                           |   4 +
 arch/tile/kernel/setup.c                          |   2 +-
 arch/x86/include/asm/kvm_host.h                   |   2 +-
 arch/x86/kvm/i8254.c                              |   2 +-
 arch/x86/kvm/lapic.c                              |   5 +-
 arch/x86/xen/enlighten.c                          |  40 +++
 drivers/acpi/acpica/utxface.c                     |  10 +-
 drivers/ata/libata-core.c                         |   9 +-
 drivers/ata/libata-pmp.c                          |   7 +
 drivers/ata/libata-scsi.c                         |   3 +-
 drivers/bluetooth/ath3k.c                         |   6 +
 drivers/bluetooth/btusb.c                         |   3 +
 drivers/char/agp/intel-gtt.c                      |   2 +-
 drivers/crypto/talitos.c                          |   1 +
 drivers/dma/mv_xor.c                              |  72 ++++--
 drivers/dma/mv_xor.h                              |   1 +
 drivers/gpu/drm/drm_crtc.c                        |   7 +
 drivers/gpu/drm/radeon/radeon_combios.c           |   7 +-
 drivers/gpu/drm/radeon/radeon_gart.c              |  12 +-
 drivers/gpu/drm/radeon/radeon_irq_kms.c           |   2 +
 drivers/input/touchscreen/usbtouchscreen.c        |   3 +
 drivers/md/dm-thin.c                              |  14 +-
 drivers/md/persistent-data/dm-btree-remove.c      |   6 +-
 drivers/md/persistent-data/dm-btree.c             |   2 +-
 drivers/md/raid1.c                                |   2 +-
 drivers/media/dvb/frontends/cx24116.c             |   8 +-
 drivers/media/dvb/frontends/s5h1420.c             |   2 +-
 drivers/mmc/card/block.c                          |   8 +-
 drivers/mtd/maps/dc21285.c                        |   4 +-
 drivers/mtd/mtd_blkdevs.c                         |   5 +
 drivers/net/ethernet/stmicro/stmmac/descs.h       |   2 +
 drivers/net/ethernet/stmicro/stmmac/enh_desc.c    |   3 +-
 drivers/net/ethernet/stmicro/stmmac/norm_desc.c   |   3 +-
 drivers/net/ethernet/stmicro/stmmac/stmmac_main.c |  18 +-
 drivers/net/ethernet/sun/niu.c                    |   4 +-
 drivers/net/wireless/ath/ath9k/main.c             |  13 +-
 drivers/pcmcia/topic.h                            |  16 ++
 drivers/platform/x86/dell-laptop.c                |   8 +-
 drivers/platform/x86/ideapad-laptop.c             |   3 +-
 drivers/regulator/core.c                          |   2 +-
 drivers/scsi/ipr.h                                |   2 +-
 drivers/staging/iio/dac/ad5624r_spi.c             |   4 +-
 drivers/staging/rtl8712/rtl8712_recv.c            |   3 +-
 drivers/staging/vt6655/device_main.c              |   4 +
 drivers/target/iscsi/iscsi_target.c               |  12 +-
 drivers/tty/serial/atmel_serial.c                 |  11 +-
 drivers/usb/class/cdc-acm.c                       |   9 +
 drivers/usb/class/cdc-acm.h                       |   1 +
 drivers/usb/core/hub.c                            |  81 +++---
 drivers/usb/dwc3/ep0.c                            |   4 +
 drivers/usb/dwc3/gadget.c                         |   2 +
 drivers/usb/host/xhci-hub.c                       |  16 +-
 drivers/usb/host/xhci-mem.c                       |   2 +-
 drivers/usb/host/xhci.c                           |   3 +
 drivers/usb/serial/cp210x.c                       |   1 +
 drivers/usb/storage/unusual_devs.h                |  12 +
 drivers/vhost/vhost.c                             |   1 +
 drivers/watchdog/omap_wdt.c                       |   7 +
 fs/9p/vfs_inode.c                                 |   3 +-
 fs/9p/vfs_inode_dotl.c                            |   3 +-
 fs/btrfs/inode-map.c                              |  17 +-
 fs/btrfs/ioctl.c                                  |  14 ++
 fs/buffer.c                                       |  43 ++--
 fs/ext4/extents.c                                 |   7 +-
 fs/ext4/indirect.c                                |   2 +-
 fs/ext4/inode.c                                   |  23 +-
 fs/ext4/mballoc.c                                 |  16 +-
 fs/ext4/super.c                                   |   1 +
 fs/fuse/inode.c                                   |   2 +-
 fs/jbd2/checkpoint.c                              |  80 ++----
 fs/jbd2/commit.c                                  |  11 +-
 fs/jbd2/journal.c                                 | 287 ++++++++++++++++------
 fs/jbd2/recovery.c                                |   5 +-
 fs/nfs/nfs3xdr.c                                  |   2 +-
 fs/nfs/nfs4state.c                                |   2 +
 include/acpi/actypes.h                            |   1 +
 include/linux/buffer_head.h                       |  54 +++-
 include/linux/jbd2.h                              |   6 +-
 include/linux/libata.h                            |   2 +
 include/linux/nfs_xdr.h                           |   2 +-
 include/trace/events/jbd2.h                       |   2 +-
 kernel/hrtimer.c                                  |  12 +-
 kernel/rcutiny.c                                  |   5 +
 kernel/trace/trace_events_filter.c                |  10 +-
 lib/bitmap.c                                      |  17 +-
 mm/filemap.c                                      |   4 +-
 mm/kmemleak.c                                     |  14 +-
 mm/memory.c                                       |  13 +-
 net/9p/client.c                                   |   3 +-
 net/bridge/br_multicast.c                         |   5 +
 net/bridge/br_netfilter.c                         |   5 +-
 net/ceph/osdmap.c                                 |   2 +-
 net/core/datagram.c                               |   9 +-
 net/core/dev.c                                    |  32 ++-
 net/core/pktgen.c                                 |   2 +-
 net/core/rtnetlink.c                              | 106 ++++----
 net/ipv4/ip_fragment.c                            |   6 +-
 net/mac80211/debugfs_netdev.c                     |   1 +
 net/netfilter/nf_conntrack_expect.c               |   3 +-
 net/rds/ib_rdma.c                                 |   4 +-
 net/rose/af_rose.c                                |   3 +-
 net/sunrpc/backchannel_rqst.c                     |   2 +-
 sound/soc/codecs/wm8737.c                         |   6 +-
 sound/soc/codecs/wm8903.h                         |   2 +-
 sound/soc/codecs/wm8955.c                         |   2 +-
 sound/soc/codecs/wm8960.c                         |   2 +-
 sound/usb/mixer_maps.c                            |  24 ++
 sound/usb/quirks-table.h                          |  68 +++++
 110 files changed, 984 insertions(+), 465 deletions(-)

AMAN DEEP (1):
      usb: xhci: Bugfix for NULL pointer deference in xhci_endpoint_init() function

Al Viro (2):
      9p: forgetting to cancel request on interrupted zero-copy RPC
      9p: don&#39;t leave a half-initialized inode sitting around

Aleksei Mamlin (1):
      libata: add ATA_HORKAGE_BROKEN_FPDMA_AA quirk for HP 250GB SATA disk VB0250EAVER

Alex Deucher (2):
      drm/radeon: take the mode_config mutex when dealing with hpds (v2)
      drm/radeon/combios: add some validation of lvds values

Alexey Brodkin (1):
      stmmac: troubleshoot unexpected bits in des0 &amp; des1

Alexey Sokolov (1):
      cdc-acm: Add support of ATOL FPrint fiscal printers

Andy Lutomirski (1):
      x86/xen: Probe target addresses in set_aliased_prot() before the hypercall

Arnd Bergmann (1):
      ideapad: fix software rfkill setting

Arne Fitzenreiter (2):
      libata: add ATA_HORKAGE_NOTRIM
      libata: force disable trim for SuperSSpeed S238

Axel Lin (3):
      ASoC: wm8737: Fixup setting VMID Impedance control register
      ASoC: wm8903: Fix define for WM8903_VMID_RES_250K
      ASoC: wm8955: Fix setting wrong register for WM8955_K_8_0_MASK bits

Ben Hutchings (1):
      Linux 3.2.71

Bernhard Bender (1):
      Input: usbtouchscreen - avoid unresponsive TSC-30 touch screen

Brian Campbell (1):
      xhci: Calculate old endpoints correctly on device reset

Brian King (1):
      ipr: Increase default adapter init stage change timeout

Brian Norris (1):
      mtd: fix: avoid race condition when accessing mtd-&gt;usecount

Catalin Marinas (1):
      mm: kmemleak: allow safe memory scanning during kmemleak disabling

Chris Metcalf (2):
      __bitmap_parselist: fix bug in empty string handling
      tile: use free_bootmem_late() for initrd

Chris Wilson (1):
      agp/intel: Fix typo in needs_ilk_vtd_wa()

Chuck Lever (1):
      NFS: Fix size of NFSACL SETACL operations

Daniel Borkmann (1):
      rtnetlink: verify IFLA_VF_INFO attributes before passing them to driver

Darrick J. Wong (1):
      ext4: don&#39;t retry file block mapping on bigalloc fs with non-extent file

Dennis Yang (1):
      dm btree remove: fix bug in redistribute3

Ding Wang (1):
      mmc: card: Fixup request missing in mmc_blk_issue_rw_rq

Dmitry Monakhov (1):
      jbd2: use GFP_NOFS in jbd2_cleanup_journal_tail()

Dmitry Tunin (3):
      ath3k: Add support of 0489:e076 AR3012 device
      ath3k: add support of 13d3:3474 AR3012 device
      Bluetooth: ath3k: add support of 04ca:300f AR3012 device

Dominic Sacré (1):
      ALSA: usb-audio: Add MIDI support for Steinberg MI2/MI4

Edward Hyunkoo Jee (1):
      inet: frags: fix defragmented packet&#39;s IP header for af_packet

Felix Fietkau (1):
      ath9k: fix DMA stop sequence for AR9003+

Filipe Manana (3):
      Btrfs: use kmem_cache_free when freeing entry in inode cache
      Btrfs: fix race between caching kthread and returning inode to inode cache
      Btrfs: fix file corruption after cloning inline extents

Florian Westphal (1):
      netfilter: bridge: don&#39;t leak skb in error paths

Gioh Kim (1):
      fs/buffer.c: support buffer cache allocations with gfp modifiers

Haggai Eran (1):
      staging: rtl8712: prevent buffer overrun in recvbuf2recvframe

Heiko Carstens (1):
      s390/process: fix sfpc inline assembly

Horia Geant? (1):
      crypto: talitos - avoid memleak in talitos_alg_alloc()

Ilya Dryomov (1):
      crush: fix a bug in tree bucket decode

JM Friedt (1):
      iio: DAC: ad5624r_spi: fix bit shift of output data value

Jan Kara (3):
      jbd2: split updating of journal superblock and marking journal empty
      jbd2: issue cache flush after checkpointing even with internal journal
      fs: Fix S_NOSEC handling

Jeff Layton (1):
      nfs: increase size of EXCHANGE_ID name string buffer

Jesper Dangaard Brouer (1):
      pktgen: adjust spacing in proc file interface output

Jiri Pirko (1):
      niu: don&#39;t count tx error twice in case of headroom realloc fails

Joe Stringer (1):
      netfilter: nf_conntrack: Support expectations in different zones

Joe Thornber (2):
      dm thin: allocate the cell_sort_array dynamically
      dm btree: silence lockdep lock inversion in dm_btree_del()

John Youn (1):
      usb: dwc3: Reset the transfer resource index on SET_INTERFACE

Joseph Qi (1):
      jbd2: fix ocfs2 corrupt when updating journal superblock fails

Julian Anastasov (2):
      net: do not process device backlog during unregistration
      net: call rcu_read_lock early in process_backlog

Kirill A. Shutemov (1):
      mm: avoid setting up anonymous pages into file mapping

Lior Amsalem (2):
      dmaengine: mv_xor: bug fix for racing condition in descriptors cleanup
      ata: pmp: add quirk for Marvell 4140 SATA PMP

Lv Zheng (1):
      ACPICA: Tables: Fix an issue that FACS initialization is performed twice

Malcolm Priestley (1):
      staging: vt6655: device_rx_srv check sk_buff is NULL

Marc-André Lureau (1):
      vhost: actually track log eventfd file

Martin Schwidefsky (1):
      s390/sclp: clear upper register halves in _sclp_print_early

Mauro Carvalho Chehab (2):
      s5h1420: fix a buffer overflow when checking userspace params
      cx24116: fix a buffer overflow when checking userspace params

Michal Hocko (1):
      ext4: replace open coded nofail allocation in ext4_free_blocks()

Michel Dänzer (1):
      drm/radeon: Don&#39;t flush the GART TLB if rdev-&gt;gart.ptr == NULL

Miklos Szeredi (1):
      fuse: initialize fc-&gt;release before calling it

Mikulas Patocka (1):
      libata: increase the timeout when setting transfer mode

NeilBrown (1):
      md/raid1: fix test for &#39;was read error from last working device&#39;.

Nicholas Bellinger (1):
      iscsi-target: Fix use-after-free during TPG session shutdown

Nicolas Ferre (1):
      tty/serial: at91: RS485 mode: 0 is valid for delay_rts_after_send

Nikolay Borisov (2):
      bufferhead: Add _gfp version for sb_getblk()
      ext4: avoid deadlocks in the writeback path by using sb_getblk_gfp

Olga Kornievskaia (1):
      fixing infinite OPEN loop in 4.0 stateid recovery

Oliver Neukum (1):
      usb-storage: ignore ZTE MF 823 card reader in mode 0x1225

Pali Rohár (1):
      dell-laptop: Fix allocating &amp; freeing SMI buffer page

Paul E. McKenney (1):
      rcu: Correctly handle non-empty Tiny RCU callback list with none ready

Pavel Emelyanov (1):
      datagram: Factor out sk queue referencing

Peter Sanford (1):
      USB: cp210x: add ID for Aruba Networks controllers

Peter Zijlstra (1):
      hrtimer: Allow concurrent hrtimer_start() for self restarting timers

Radim Kr?má? (2):
      KVM: x86: make vapics_in_nmi_mode atomic
      KVM: x86: properly restore LVT0

Ralf Baechle (1):
      NET: ROSE: Don&#39;t dereference NULL neighbour pointer.

Robert Schlabbach (1):
      usb: core: Fix USB 3.0 devices lost in NOTATTACHED state after a hub port reset

Ryan Underwood (1):
      Disable write buffering on Toshiba ToPIC95

Satish Ashok (1):
      bridge: multicast: restore router configuration on port link down/up

Stefan Wahren (1):
      regulator: core: fix constraints output buffer

Steven Rostedt (Red Hat) (2):
      tracing/filter: Do not WARN on operand count going below zero
      tracing/filter: Do not allow infix to exceed end of string

Subbaraya Sundeep Bhatta (1):
      usb: dwc3: gadget: return error if command sent to DEPCMD register fails

Theodore Ts&#39;o (2):
      ext4: fix race between truncate and __ext4_journalled_writepage()
      ext4: call sync_blockdev() before invalidate_bdev() in put_super()

Tom Hughes (1):
      mac80211: clear subdir_stations when removing debugfs

Trond Myklebust (1):
      SUNRPC: Fix a memory leak in the backchannel code

Uwe Kleine-König (2):
      mtd: dc21285: use raw spinlock functions for nw_gpio_lock
      watchdog: omap: assert the counter being stopped before reprogramming

Ville Syrjälä (1):
      drm: Check crtc x and y coordinates

Wengang Wang (1):
      rds: rds_ib_device.refcount overflow

Yao-Wen Mao (1):
      ALSA: usb-audio: add dB range mapping for some devices

Zhao Junwang (1):
      drm: add a check for x/y in drm_mode_setcrtc

Zhuang Jin Can (2):
      xhci: report U3 when link is in resume state
      xhci: do not report PLC when link is in internal resume state

Zidan Wang (1):
      ASoC: wm8960: the enum of &quot;DAC Polarity&quot; should be wm8960_enum[1]
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 41a626b..9d5fea7 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 2
<span class="p_del">-SUBLEVEL = 70</span>
<span class="p_add">+SUBLEVEL = 71</span>
 EXTRAVERSION =
 NAME = Saber-toothed Squirrel
 
<span class="p_header">diff --git a/arch/s390/kernel/process.c b/arch/s390/kernel/process.c</span>
<span class="p_header">index 53088e2..2ba1226 100644</span>
<span class="p_header">--- a/arch/s390/kernel/process.c</span>
<span class="p_header">+++ b/arch/s390/kernel/process.c</span>
<span class="p_chunk">@@ -250,7 +250,7 @@</span> <span class="p_context"> asmlinkage void execve_tail(void)</span>
 {
 	current-&gt;thread.fp_regs.fpc = 0;
 	if (MACHINE_HAS_IEEE)
<span class="p_del">-		asm volatile(&quot;sfpc %0,%0&quot; : : &quot;d&quot; (0));</span>
<span class="p_add">+		asm volatile(&quot;sfpc %0&quot; : : &quot;d&quot; (0));</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/s390/kernel/sclp.S b/arch/s390/kernel/sclp.S</span>
<span class="p_header">index 95792d8..51ca1c3 100644</span>
<span class="p_header">--- a/arch/s390/kernel/sclp.S</span>
<span class="p_header">+++ b/arch/s390/kernel/sclp.S</span>
<span class="p_chunk">@@ -270,6 +270,8 @@</span> <span class="p_context"> ENTRY(_sclp_print_early)</span>
 	jno	.Lesa2
 	ahi	%r15,-80
 	stmh	%r6,%r15,96(%r15)		# store upper register halves
<span class="p_add">+	basr	%r13,0</span>
<span class="p_add">+	lmh	%r0,%r15,.Lzeroes-.(%r13)	# clear upper register halves</span>
 .Lesa2:
 #endif
 	lr	%r10,%r2			# save string pointer
<span class="p_chunk">@@ -293,6 +295,8 @@</span> <span class="p_context"> ENTRY(_sclp_print_early)</span>
 #endif
 	lm	%r6,%r15,120(%r15)		# restore registers
 	br	%r14
<span class="p_add">+.Lzeroes:</span>
<span class="p_add">+	.fill	64,4,0</span>
 
 .LwritedataS4:
 	.long	0x00760005			# SCLP command for write data
<span class="p_header">diff --git a/arch/tile/kernel/setup.c b/arch/tile/kernel/setup.c</span>
<span class="p_header">index a09b6c3..bf3e71a 100644</span>
<span class="p_header">--- a/arch/tile/kernel/setup.c</span>
<span class="p_header">+++ b/arch/tile/kernel/setup.c</span>
<span class="p_chunk">@@ -973,7 +973,7 @@</span> <span class="p_context"> static void __init load_hv_initrd(void)</span>
 
 void __init free_initrd_mem(unsigned long begin, unsigned long end)
 {
<span class="p_del">-	free_bootmem(__pa(begin), end - begin);</span>
<span class="p_add">+	free_bootmem_late(__pa(begin), end - begin);</span>
 }
 
 #else
<span class="p_header">diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h</span>
<span class="p_header">index 9171618..93ce7e4 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -472,7 +472,7 @@</span> <span class="p_context"> struct kvm_arch {</span>
 	struct kvm_pic *vpic;
 	struct kvm_ioapic *vioapic;
 	struct kvm_pit *vpit;
<span class="p_del">-	int vapics_in_nmi_mode;</span>
<span class="p_add">+	atomic_t vapics_in_nmi_mode;</span>
 
 	unsigned int tss_addr;
 	struct page *apic_access_page;
<span class="p_header">diff --git a/arch/x86/kvm/i8254.c b/arch/x86/kvm/i8254.c</span>
<span class="p_header">index cced57f..ab98fe5 100644</span>
<span class="p_header">--- a/arch/x86/kvm/i8254.c</span>
<span class="p_header">+++ b/arch/x86/kvm/i8254.c</span>
<span class="p_chunk">@@ -318,7 +318,7 @@</span> <span class="p_context"> static void pit_do_work(struct work_struct *work)</span>
 		 * LVT0 to NMI delivery. Other PIC interrupts are just sent to
 		 * VCPU0, and only if its LVT0 is in EXTINT mode.
 		 */
<span class="p_del">-		if (kvm-&gt;arch.vapics_in_nmi_mode &gt; 0)</span>
<span class="p_add">+		if (atomic_read(&amp;kvm-&gt;arch.vapics_in_nmi_mode) &gt; 0)</span>
 			kvm_for_each_vcpu(i, vcpu, kvm)
 				kvm_apic_nmi_wd_deliver(vcpu);
 	}
<span class="p_header">diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c</span>
<span class="p_header">index 176205a..055cc49 100644</span>
<span class="p_header">--- a/arch/x86/kvm/lapic.c</span>
<span class="p_header">+++ b/arch/x86/kvm/lapic.c</span>
<span class="p_chunk">@@ -757,10 +757,10 @@</span> <span class="p_context"> static void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)</span>
 		if (!nmi_wd_enabled) {
 			apic_debug(&quot;Receive NMI setting on APIC_LVT0 &quot;
 				   &quot;for cpu %d\n&quot;, apic-&gt;vcpu-&gt;vcpu_id);
<span class="p_del">-			apic-&gt;vcpu-&gt;kvm-&gt;arch.vapics_in_nmi_mode++;</span>
<span class="p_add">+			atomic_inc(&amp;apic-&gt;vcpu-&gt;kvm-&gt;arch.vapics_in_nmi_mode);</span>
 		}
 	} else if (nmi_wd_enabled)
<span class="p_del">-		apic-&gt;vcpu-&gt;kvm-&gt;arch.vapics_in_nmi_mode--;</span>
<span class="p_add">+		atomic_dec(&amp;apic-&gt;vcpu-&gt;kvm-&gt;arch.vapics_in_nmi_mode);</span>
 }
 
 static int apic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
<span class="p_chunk">@@ -1253,6 +1253,7 @@</span> <span class="p_context"> void kvm_apic_post_state_restore(struct kvm_vcpu *vcpu)</span>
 
 	apic_update_ppr(apic);
 	hrtimer_cancel(&amp;apic-&gt;lapic_timer.timer);
<span class="p_add">+	apic_manage_nmi_watchdog(apic, apic_get_reg(apic, APIC_LVT0));</span>
 	update_divide_count(apic);
 	start_apic_timer(apic);
 	apic-&gt;irr_pending = true;
<span class="p_header">diff --git a/arch/x86/xen/enlighten.c b/arch/x86/xen/enlighten.c</span>
<span class="p_header">index 5189fe8..81afe1b 100644</span>
<span class="p_header">--- a/arch/x86/xen/enlighten.c</span>
<span class="p_header">+++ b/arch/x86/xen/enlighten.c</span>
<span class="p_chunk">@@ -321,6 +321,7 @@</span> <span class="p_context"> static void set_aliased_prot(void *v, pgprot_t prot)</span>
 	pte_t pte;
 	unsigned long pfn;
 	struct page *page;
<span class="p_add">+	unsigned char dummy;</span>
 
 	ptep = lookup_address((unsigned long)v, &amp;level);
 	BUG_ON(ptep == NULL);
<span class="p_chunk">@@ -330,6 +331,32 @@</span> <span class="p_context"> static void set_aliased_prot(void *v, pgprot_t prot)</span>
 
 	pte = pfn_pte(pfn, prot);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Careful: update_va_mapping() will fail if the virtual address</span>
<span class="p_add">+	 * we&#39;re poking isn&#39;t populated in the page tables.  We don&#39;t</span>
<span class="p_add">+	 * need to worry about the direct map (that&#39;s always in the page</span>
<span class="p_add">+	 * tables), but we need to be careful about vmap space.  In</span>
<span class="p_add">+	 * particular, the top level page table can lazily propagate</span>
<span class="p_add">+	 * entries between processes, so if we&#39;ve switched mms since we</span>
<span class="p_add">+	 * vmapped the target in the first place, we might not have the</span>
<span class="p_add">+	 * top-level page table entry populated.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We disable preemption because we want the same mm active when</span>
<span class="p_add">+	 * we probe the target and when we issue the hypercall.  We&#39;ll</span>
<span class="p_add">+	 * have the same nominal mm, but if we&#39;re a kernel thread, lazy</span>
<span class="p_add">+	 * mm dropping could change our pgd.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Out of an abundance of caution, this uses __get_user() to fault</span>
<span class="p_add">+	 * in the target address just in case there&#39;s some obscure case</span>
<span class="p_add">+	 * in which the target address isn&#39;t readable.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	preempt_disable();</span>
<span class="p_add">+</span>
<span class="p_add">+	pagefault_disable();	/* Avoid warnings due to being atomic. */</span>
<span class="p_add">+	__get_user(dummy, (unsigned char __user __force *)v);</span>
<span class="p_add">+	pagefault_enable();</span>
<span class="p_add">+</span>
 	if (HYPERVISOR_update_va_mapping((unsigned long)v, pte, 0))
 		BUG();
 
<span class="p_chunk">@@ -341,6 +368,8 @@</span> <span class="p_context"> static void set_aliased_prot(void *v, pgprot_t prot)</span>
 				BUG();
 	} else
 		kmap_flush_unused();
<span class="p_add">+</span>
<span class="p_add">+	preempt_enable();</span>
 }
 
 static void xen_alloc_ldt(struct desc_struct *ldt, unsigned entries)
<span class="p_chunk">@@ -348,6 +377,17 @@</span> <span class="p_context"> static void xen_alloc_ldt(struct desc_struct *ldt, unsigned entries)</span>
 	const unsigned entries_per_page = PAGE_SIZE / LDT_ENTRY_SIZE;
 	int i;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to mark the all aliases of the LDT pages RO.  We</span>
<span class="p_add">+	 * don&#39;t need to call vm_flush_aliases(), though, since that&#39;s</span>
<span class="p_add">+	 * only responsible for flushing aliases out the TLBs, not the</span>
<span class="p_add">+	 * page tables, and Xen will flush the TLB for us if needed.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * To avoid confusing future readers: none of this is necessary</span>
<span class="p_add">+	 * to load the LDT.  The hypervisor only checks this when the</span>
<span class="p_add">+	 * LDT is faulted in due to subsequent descriptor access.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
 	for(i = 0; i &lt; entries; i += entries_per_page)
 		set_aliased_prot(ldt + i, PAGE_KERNEL_RO);
 }
<span class="p_header">diff --git a/drivers/acpi/acpica/utxface.c b/drivers/acpi/acpica/utxface.c</span>
<span class="p_header">index 420ebfe..ecc428e 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/utxface.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/utxface.c</span>
<span class="p_chunk">@@ -163,10 +163,12 @@</span> <span class="p_context"> acpi_status acpi_enable_subsystem(u32 flags)</span>
 	 * Obtain a permanent mapping for the FACS. This is required for the
 	 * Global Lock and the Firmware Waking Vector
 	 */
<span class="p_del">-	status = acpi_tb_initialize_facs();</span>
<span class="p_del">-	if (ACPI_FAILURE(status)) {</span>
<span class="p_del">-		ACPI_WARNING((AE_INFO, &quot;Could not map the FACS table&quot;));</span>
<span class="p_del">-		return_ACPI_STATUS(status);</span>
<span class="p_add">+	if (!(flags &amp; ACPI_NO_FACS_INIT)) {</span>
<span class="p_add">+		status = acpi_tb_initialize_facs();</span>
<span class="p_add">+		if (ACPI_FAILURE(status)) {</span>
<span class="p_add">+			ACPI_WARNING((AE_INFO, &quot;Could not map the FACS table&quot;));</span>
<span class="p_add">+			return_ACPI_STATUS(status);</span>
<span class="p_add">+		}</span>
 	}
 
 	/*
<span class="p_header">diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c</span>
<span class="p_header">index fcd8586..4e9beff 100644</span>
<span class="p_header">--- a/drivers/ata/libata-core.c</span>
<span class="p_header">+++ b/drivers/ata/libata-core.c</span>
<span class="p_chunk">@@ -4107,9 +4107,10 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 	{ &quot;ST3320[68]13AS&quot;,	&quot;SD1[5-9]&quot;,	ATA_HORKAGE_NONCQ |
 						ATA_HORKAGE_FIRMWARE_WARN },
 
<span class="p_del">-	/* Seagate Momentus SpinPoint M8 seem to have FPMDA_AA issues */</span>
<span class="p_add">+	/* drives which fail FPDMA_AA activation (some may freeze afterwards) */</span>
 	{ &quot;ST1000LM024 HN-M101MBB&quot;, &quot;2AR10001&quot;,	ATA_HORKAGE_BROKEN_FPDMA_AA },
 	{ &quot;ST1000LM024 HN-M101MBB&quot;, &quot;2BA30001&quot;,	ATA_HORKAGE_BROKEN_FPDMA_AA },
<span class="p_add">+	{ &quot;VB0250EAVER&quot;,	&quot;HPG7&quot;,		ATA_HORKAGE_BROKEN_FPDMA_AA },</span>
 
 	/* Blacklist entries taken from Silicon Image 3124/3132
 	   Windows driver .inf file - also several Linux problem reports */
<span class="p_chunk">@@ -4154,6 +4155,9 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 	{ &quot;PIONEER DVD-RW  DVR-212D&quot;,	NULL,	ATA_HORKAGE_NOSETXFER },
 	{ &quot;PIONEER DVD-RW  DVR-216D&quot;,	NULL,	ATA_HORKAGE_NOSETXFER },
 
<span class="p_add">+	/* devices that don&#39;t properly handle TRIM commands */</span>
<span class="p_add">+	{ &quot;SuperSSpeed S238*&quot;,		NULL,	ATA_HORKAGE_NOTRIM, },</span>
<span class="p_add">+</span>
 	/*
 	 * Some WD SATA-I drives spin up and down erratically when the link
 	 * is put into the slumber mode.  We don&#39;t have full list of the
<span class="p_chunk">@@ -4458,7 +4462,8 @@</span> <span class="p_context"> static unsigned int ata_dev_set_xfermode(struct ata_device *dev)</span>
 	else /* In the ancient relic department - skip all of this */
 		return 0;
 
<span class="p_del">-	err_mask = ata_exec_internal(dev, &amp;tf, NULL, DMA_NONE, NULL, 0, 0);</span>
<span class="p_add">+	/* On some disks, this command causes spin-up, so we need longer timeout */</span>
<span class="p_add">+	err_mask = ata_exec_internal(dev, &amp;tf, NULL, DMA_NONE, NULL, 0, 15000);</span>
 
 	DPRINTK(&quot;EXIT, err_mask=%x\n&quot;, err_mask);
 	return err_mask;
<span class="p_header">diff --git a/drivers/ata/libata-pmp.c b/drivers/ata/libata-pmp.c</span>
<span class="p_header">index 0ba32fe..93ea3350 100644</span>
<span class="p_header">--- a/drivers/ata/libata-pmp.c</span>
<span class="p_header">+++ b/drivers/ata/libata-pmp.c</span>
<span class="p_chunk">@@ -460,6 +460,13 @@</span> <span class="p_context"> static void sata_pmp_quirks(struct ata_port *ap)</span>
 				       ATA_LFLAG_NO_SRST |
 				       ATA_LFLAG_ASSUME_ATA;
 		}
<span class="p_add">+	} else if (vendor == 0x11ab &amp;&amp; devid == 0x4140) {</span>
<span class="p_add">+		/* Marvell 4140 quirks */</span>
<span class="p_add">+		ata_for_each_link(link, ap, EDGE) {</span>
<span class="p_add">+			/* port 4 is for SEMB device and it doesn&#39;t like SRST */</span>
<span class="p_add">+			if (link-&gt;pmp == 4)</span>
<span class="p_add">+				link-&gt;flags |= ATA_LFLAG_DISABLED;</span>
<span class="p_add">+		}</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/ata/libata-scsi.c b/drivers/ata/libata-scsi.c</span>
<span class="p_header">index 8460e62..0ac7a5e 100644</span>
<span class="p_header">--- a/drivers/ata/libata-scsi.c</span>
<span class="p_header">+++ b/drivers/ata/libata-scsi.c</span>
<span class="p_chunk">@@ -2473,7 +2473,8 @@</span> <span class="p_context"> static unsigned int ata_scsiop_read_cap(struct ata_scsi_args *args, u8 *rbuf)</span>
 		rbuf[14] = (lowest_aligned &gt;&gt; 8) &amp; 0x3f;
 		rbuf[15] = lowest_aligned;
 
<span class="p_del">-		if (ata_id_has_trim(args-&gt;id)) {</span>
<span class="p_add">+		if (ata_id_has_trim(args-&gt;id) &amp;&amp;</span>
<span class="p_add">+		    !(dev-&gt;horkage &amp; ATA_HORKAGE_NOTRIM)) {</span>
 			rbuf[14] |= 0x80; /* TPE */
 
 			if (ata_id_has_zero_after_trim(args-&gt;id))
<span class="p_header">diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c</span>
<span class="p_header">index 9f32f43..e9e8f3b 100644</span>
<span class="p_header">--- a/drivers/bluetooth/ath3k.c</span>
<span class="p_header">+++ b/drivers/bluetooth/ath3k.c</span>
<span class="p_chunk">@@ -78,6 +78,7 @@</span> <span class="p_context"> static struct usb_device_id ath3k_table[] = {</span>
 	{ USB_DEVICE(0x0489, 0xe057) },
 	{ USB_DEVICE(0x0489, 0xe056) },
 	{ USB_DEVICE(0x0489, 0xe05f) },
<span class="p_add">+	{ USB_DEVICE(0x0489, 0xe076) },</span>
 	{ USB_DEVICE(0x0489, 0xe078) },
 	{ USB_DEVICE(0x04c5, 0x1330) },
 	{ USB_DEVICE(0x04CA, 0x3004) },
<span class="p_chunk">@@ -86,6 +87,7 @@</span> <span class="p_context"> static struct usb_device_id ath3k_table[] = {</span>
 	{ USB_DEVICE(0x04CA, 0x3007) },
 	{ USB_DEVICE(0x04CA, 0x3008) },
 	{ USB_DEVICE(0x04CA, 0x300b) },
<span class="p_add">+	{ USB_DEVICE(0x04CA, 0x300f) },</span>
 	{ USB_DEVICE(0x04CA, 0x3010) },
 	{ USB_DEVICE(0x0930, 0x0219) },
 	{ USB_DEVICE(0x0930, 0x0220) },
<span class="p_chunk">@@ -109,6 +111,7 @@</span> <span class="p_context"> static struct usb_device_id ath3k_table[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3408) },
 	{ USB_DEVICE(0x13d3, 0x3423) },
 	{ USB_DEVICE(0x13d3, 0x3432) },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3474) },</span>
 
 	/* Atheros AR5BBU12 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xE02C) },
<span class="p_chunk">@@ -133,6 +136,7 @@</span> <span class="p_context"> static struct usb_device_id ath3k_blist_tbl[] = {</span>
 	{ USB_DEVICE(0x0489, 0xe056), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0489, 0xe057), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0489, 0xe05f), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x0489, 0xe076), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x0489, 0xe078), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04c5, 0x1330), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3004), .driver_info = BTUSB_ATH3012 },
<span class="p_chunk">@@ -141,6 +145,7 @@</span> <span class="p_context"> static struct usb_device_id ath3k_blist_tbl[] = {</span>
 	{ USB_DEVICE(0x04ca, 0x3007), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3008), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x300b), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x04ca, 0x300f), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x04ca, 0x3010), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x0219), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x0220), .driver_info = BTUSB_ATH3012 },
<span class="p_chunk">@@ -164,6 +169,7 @@</span> <span class="p_context"> static struct usb_device_id ath3k_blist_tbl[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3408), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3423), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3432), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3474), .driver_info = BTUSB_ATH3012 },</span>
 
 	/* Atheros AR5BBU22 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xE036), .driver_info = BTUSB_ATH3012 },
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index 92973a3..c5e400b 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -163,6 +163,7 @@</span> <span class="p_context"> static struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x0489, 0xe056), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0489, 0xe057), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0489, 0xe05f), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x0489, 0xe076), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x0489, 0xe078), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04c5, 0x1330), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3004), .driver_info = BTUSB_ATH3012 },
<span class="p_chunk">@@ -171,6 +172,7 @@</span> <span class="p_context"> static struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x04ca, 0x3007), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3008), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x300b), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x04ca, 0x300f), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x04ca, 0x3010), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x0219), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x0220), .driver_info = BTUSB_ATH3012 },
<span class="p_chunk">@@ -194,6 +196,7 @@</span> <span class="p_context"> static struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3408), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3423), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3432), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3474), .driver_info = BTUSB_ATH3012 },</span>
 
 	/* Atheros AR5BBU12 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xe02c), .driver_info = BTUSB_IGNORE },
<span class="p_header">diff --git a/drivers/char/agp/intel-gtt.c b/drivers/char/agp/intel-gtt.c</span>
<span class="p_header">index 43c4ec3..59d4697 100644</span>
<span class="p_header">--- a/drivers/char/agp/intel-gtt.c</span>
<span class="p_header">+++ b/drivers/char/agp/intel-gtt.c</span>
<span class="p_chunk">@@ -1195,7 +1195,7 @@</span> <span class="p_context"> static inline int needs_idle_maps(void)</span>
 	/* Query intel_iommu to see if we need the workaround. Presumably that
 	 * was loaded first.
 	 */
<span class="p_del">-	if ((gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_M_HB ||</span>
<span class="p_add">+	if ((gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_D_IG ||</span>
 	     gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_M_IG) &amp;&amp;
 	     intel_iommu_gfx_mapped)
 		return 1;
<span class="p_header">diff --git a/drivers/crypto/talitos.c b/drivers/crypto/talitos.c</span>
<span class="p_header">index dbe76b5..90c76fc 100644</span>
<span class="p_header">--- a/drivers/crypto/talitos.c</span>
<span class="p_header">+++ b/drivers/crypto/talitos.c</span>
<span class="p_chunk">@@ -2384,6 +2384,7 @@</span> <span class="p_context"> static struct talitos_crypto_alg *talitos_alg_alloc(struct device *dev,</span>
 		break;
 	default:
 		dev_err(dev, &quot;unknown algorithm type %d\n&quot;, t_alg-&gt;algt.type);
<span class="p_add">+		kfree(t_alg);</span>
 		return ERR_PTR(-EINVAL);
 	}
 
<span class="p_header">diff --git a/drivers/dma/mv_xor.c b/drivers/dma/mv_xor.c</span>
<span class="p_header">index 9b01145..a258101 100644</span>
<span class="p_header">--- a/drivers/dma/mv_xor.c</span>
<span class="p_header">+++ b/drivers/dma/mv_xor.c</span>
<span class="p_chunk">@@ -386,7 +386,8 @@</span> <span class="p_context"> static void __mv_xor_slot_cleanup(struct mv_xor_chan *mv_chan)</span>
 	dma_cookie_t cookie = 0;
 	int busy = mv_chan_is_busy(mv_chan);
 	u32 current_desc = mv_chan_get_current_desc(mv_chan);
<span class="p_del">-	int seen_current = 0;</span>
<span class="p_add">+	int current_cleaned = 0;</span>
<span class="p_add">+	struct mv_xor_desc *hw_desc;</span>
 
 	dev_dbg(mv_chan-&gt;device-&gt;common.dev, &quot;%s %d\n&quot;, __func__, __LINE__);
 	dev_dbg(mv_chan-&gt;device-&gt;common.dev, &quot;current_desc %x\n&quot;, current_desc);
<span class="p_chunk">@@ -398,38 +399,57 @@</span> <span class="p_context"> static void __mv_xor_slot_cleanup(struct mv_xor_chan *mv_chan)</span>
 
 	list_for_each_entry_safe(iter, _iter, &amp;mv_chan-&gt;chain,
 					chain_node) {
<span class="p_del">-		prefetch(_iter);</span>
<span class="p_del">-		prefetch(&amp;_iter-&gt;async_tx);</span>
 
<span class="p_del">-		/* do not advance past the current descriptor loaded into the</span>
<span class="p_del">-		 * hardware channel, subsequent descriptors are either in</span>
<span class="p_del">-		 * process or have not been submitted</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (seen_current)</span>
<span class="p_del">-			break;</span>
<span class="p_add">+		/* clean finished descriptors */</span>
<span class="p_add">+		hw_desc = iter-&gt;hw_desc;</span>
<span class="p_add">+		if (hw_desc-&gt;status &amp; XOR_DESC_SUCCESS) {</span>
<span class="p_add">+			cookie = mv_xor_run_tx_complete_actions(iter, mv_chan,</span>
<span class="p_add">+								cookie);</span>
 
<span class="p_del">-		/* stop the search if we reach the current descriptor and the</span>
<span class="p_del">-		 * channel is busy</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (iter-&gt;async_tx.phys == current_desc) {</span>
<span class="p_del">-			seen_current = 1;</span>
<span class="p_del">-			if (busy)</span>
<span class="p_add">+			/* done processing desc, clean slot */</span>
<span class="p_add">+			mv_xor_clean_slot(iter, mv_chan);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* break if we did cleaned the current */</span>
<span class="p_add">+			if (iter-&gt;async_tx.phys == current_desc) {</span>
<span class="p_add">+				current_cleaned = 1;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (iter-&gt;async_tx.phys == current_desc) {</span>
<span class="p_add">+				current_cleaned = 0;</span>
 				break;
<span class="p_add">+			}</span>
 		}
<span class="p_del">-</span>
<span class="p_del">-		cookie = mv_xor_run_tx_complete_actions(iter, mv_chan, cookie);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (mv_xor_clean_slot(iter, mv_chan))</span>
<span class="p_del">-			break;</span>
 	}
 
 	if ((busy == 0) &amp;&amp; !list_empty(&amp;mv_chan-&gt;chain)) {
<span class="p_del">-		struct mv_xor_desc_slot *chain_head;</span>
<span class="p_del">-		chain_head = list_entry(mv_chan-&gt;chain.next,</span>
<span class="p_del">-					struct mv_xor_desc_slot,</span>
<span class="p_del">-					chain_node);</span>
<span class="p_del">-</span>
<span class="p_del">-		mv_xor_start_new_chain(mv_chan, chain_head);</span>
<span class="p_add">+		if (current_cleaned) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * current descriptor cleaned and removed, run</span>
<span class="p_add">+			 * from list head</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			iter = list_entry(mv_chan-&gt;chain.next,</span>
<span class="p_add">+					  struct mv_xor_desc_slot,</span>
<span class="p_add">+					  chain_node);</span>
<span class="p_add">+			mv_xor_start_new_chain(mv_chan, iter);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (!list_is_last(&amp;iter-&gt;chain_node, &amp;mv_chan-&gt;chain)) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * descriptors are still waiting after</span>
<span class="p_add">+				 * current, trigger them</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				iter = list_entry(iter-&gt;chain_node.next,</span>
<span class="p_add">+						  struct mv_xor_desc_slot,</span>
<span class="p_add">+						  chain_node);</span>
<span class="p_add">+				mv_xor_start_new_chain(mv_chan, iter);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * some descriptors are still waiting</span>
<span class="p_add">+				 * to be cleaned</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				tasklet_schedule(&amp;mv_chan-&gt;irq_tasklet);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 	}
 
 	if (cookie &gt; 0)
<span class="p_header">diff --git a/drivers/dma/mv_xor.h b/drivers/dma/mv_xor.h</span>
<span class="p_header">index 977b592..ae2cfba 100644</span>
<span class="p_header">--- a/drivers/dma/mv_xor.h</span>
<span class="p_header">+++ b/drivers/dma/mv_xor.h</span>
<span class="p_chunk">@@ -30,6 +30,7 @@</span> <span class="p_context"></span>
 #define XOR_OPERATION_MODE_XOR		0
 #define XOR_OPERATION_MODE_MEMCPY	2
 #define XOR_OPERATION_MODE_MEMSET	4
<span class="p_add">+#define XOR_DESC_SUCCESS		0x40000000</span>
 
 #define XOR_CURR_DESC(chan)	(chan-&gt;mmr_base + 0x210 + (chan-&gt;idx * 4))
 #define XOR_NEXT_DESC(chan)	(chan-&gt;mmr_base + 0x200 + (chan-&gt;idx * 4))
<span class="p_header">diff --git a/drivers/gpu/drm/drm_crtc.c b/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_header">index 09851ce..20110b4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_chunk">@@ -1505,6 +1505,13 @@</span> <span class="p_context"> int drm_mode_setcrtc(struct drm_device *dev, void *data,</span>
 	if (!drm_core_check_feature(dev, DRIVER_MODESET))
 		return -EINVAL;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Universal plane src offsets are only 16.16, prevent havoc for</span>
<span class="p_add">+	 * drivers using universal plane code internally.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (crtc_req-&gt;x &amp; 0xffff0000 || crtc_req-&gt;y &amp; 0xffff0000)</span>
<span class="p_add">+		return -ERANGE;</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;dev-&gt;mode_config.mutex);
 	obj = drm_mode_object_find(dev, crtc_req-&gt;crtc_id,
 				   DRM_MODE_OBJECT_CRTC);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_combios.c b/drivers/gpu/drm/radeon/radeon_combios.c</span>
<span class="p_header">index 8115557..21e689d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_combios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_combios.c</span>
<span class="p_chunk">@@ -1259,10 +1259,15 @@</span> <span class="p_context"> struct radeon_encoder_lvds *radeon_combios_get_lvds_info(struct radeon_encoder</span>
 
 			if ((RBIOS16(tmp) == lvds-&gt;native_mode.hdisplay) &amp;&amp;
 			    (RBIOS16(tmp + 2) == lvds-&gt;native_mode.vdisplay)) {
<span class="p_add">+				u32 hss = (RBIOS16(tmp + 21) - RBIOS16(tmp + 19) - 1) * 8;</span>
<span class="p_add">+</span>
<span class="p_add">+				if (hss &gt; lvds-&gt;native_mode.hdisplay)</span>
<span class="p_add">+					hss = (10 - 1) * 8;</span>
<span class="p_add">+</span>
 				lvds-&gt;native_mode.htotal = lvds-&gt;native_mode.hdisplay +
 					(RBIOS16(tmp + 17) - RBIOS16(tmp + 19)) * 8;
 				lvds-&gt;native_mode.hsync_start = lvds-&gt;native_mode.hdisplay +
<span class="p_del">-					(RBIOS16(tmp + 21) - RBIOS16(tmp + 19) - 1) * 8;</span>
<span class="p_add">+					hss;</span>
 				lvds-&gt;native_mode.hsync_end = lvds-&gt;native_mode.hsync_start +
 					(RBIOS8(tmp + 23) * 8);
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_gart.c b/drivers/gpu/drm/radeon/radeon_gart.c</span>
<span class="p_header">index ba7ab79..d2572108 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_gart.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_gart.c</span>
<span class="p_chunk">@@ -171,8 +171,10 @@</span> <span class="p_context"> void radeon_gart_unbind(struct radeon_device *rdev, unsigned offset,</span>
 			}
 		}
 	}
<span class="p_del">-	mb();</span>
<span class="p_del">-	radeon_gart_tlb_flush(rdev);</span>
<span class="p_add">+	if (rdev-&gt;gart.ptr) {</span>
<span class="p_add">+		mb();</span>
<span class="p_add">+		radeon_gart_tlb_flush(rdev);</span>
<span class="p_add">+	}</span>
 }
 
 int radeon_gart_bind(struct radeon_device *rdev, unsigned offset,
<span class="p_chunk">@@ -217,8 +219,10 @@</span> <span class="p_context"> int radeon_gart_bind(struct radeon_device *rdev, unsigned offset,</span>
 			}
 		}
 	}
<span class="p_del">-	mb();</span>
<span class="p_del">-	radeon_gart_tlb_flush(rdev);</span>
<span class="p_add">+	if (rdev-&gt;gart.ptr) {</span>
<span class="p_add">+		mb();</span>
<span class="p_add">+		radeon_gart_tlb_flush(rdev);</span>
<span class="p_add">+	}</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_irq_kms.c b/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_header">index 4f9496e..42f5a2b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_chunk">@@ -51,10 +51,12 @@</span> <span class="p_context"> static void radeon_hotplug_work_func(struct work_struct *work)</span>
 	struct drm_mode_config *mode_config = &amp;dev-&gt;mode_config;
 	struct drm_connector *connector;
 
<span class="p_add">+	mutex_lock(&amp;mode_config-&gt;mutex);</span>
 	if (mode_config-&gt;num_connector) {
 		list_for_each_entry(connector, &amp;mode_config-&gt;connector_list, head)
 			radeon_connector_hotplug(connector);
 	}
<span class="p_add">+	mutex_unlock(&amp;mode_config-&gt;mutex);</span>
 	/* Just fire off a uevent and let userspace tell us what to do */
 	drm_helper_hpd_irq_event(dev);
 }
<span class="p_header">diff --git a/drivers/input/touchscreen/usbtouchscreen.c b/drivers/input/touchscreen/usbtouchscreen.c</span>
<span class="p_header">index 73fd664..e26a7c3 100644</span>
<span class="p_header">--- a/drivers/input/touchscreen/usbtouchscreen.c</span>
<span class="p_header">+++ b/drivers/input/touchscreen/usbtouchscreen.c</span>
<span class="p_chunk">@@ -528,6 +528,9 @@</span> <span class="p_context"> static int dmc_tsc10_init(struct usbtouch_usb *usbtouch)</span>
 		goto err_out;
 	}
 
<span class="p_add">+	/* TSC-25 data sheet specifies a delay after the RESET command */</span>
<span class="p_add">+	msleep(150);</span>
<span class="p_add">+</span>
 	/* set coordinate output rate */
 	buf[0] = buf[1] = 0xFF;
 	ret = usb_control_msg(dev, usb_rcvctrlpipe (dev, 0),
<span class="p_header">diff --git a/drivers/md/dm-thin.c b/drivers/md/dm-thin.c</span>
<span class="p_header">index 80f8bd5..d9f23a4 100644</span>
<span class="p_header">--- a/drivers/md/dm-thin.c</span>
<span class="p_header">+++ b/drivers/md/dm-thin.c</span>
<span class="p_chunk">@@ -13,6 +13,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/init.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/slab.h&gt;
<span class="p_add">+#include &lt;linux/vmalloc.h&gt;</span>
 
 #define	DM_MSG_PREFIX	&quot;thin&quot;
 
<span class="p_chunk">@@ -158,9 +159,7 @@</span> <span class="p_context"> static struct bio_prison *prison_create(unsigned nr_cells)</span>
 {
 	unsigned i;
 	uint32_t nr_buckets = calc_nr_buckets(nr_cells);
<span class="p_del">-	size_t len = sizeof(struct bio_prison) +</span>
<span class="p_del">-		(sizeof(struct hlist_head) * nr_buckets);</span>
<span class="p_del">-	struct bio_prison *prison = kmalloc(len, GFP_KERNEL);</span>
<span class="p_add">+	struct bio_prison *prison = kmalloc(sizeof(*prison), GFP_KERNEL);</span>
 
 	if (!prison)
 		return NULL;
<span class="p_chunk">@@ -173,9 +172,15 @@</span> <span class="p_context"> static struct bio_prison *prison_create(unsigned nr_cells)</span>
 		return NULL;
 	}
 
<span class="p_add">+	prison-&gt;cells = vmalloc(sizeof(*prison-&gt;cells) * nr_buckets);</span>
<span class="p_add">+	if (!prison-&gt;cells) {</span>
<span class="p_add">+		mempool_destroy(prison-&gt;cell_pool);</span>
<span class="p_add">+		kfree(prison);</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	prison-&gt;nr_buckets = nr_buckets;
 	prison-&gt;hash_mask = nr_buckets - 1;
<span class="p_del">-	prison-&gt;cells = (struct hlist_head *) (prison + 1);</span>
 	for (i = 0; i &lt; nr_buckets; i++)
 		INIT_HLIST_HEAD(prison-&gt;cells + i);
 
<span class="p_chunk">@@ -184,6 +189,7 @@</span> <span class="p_context"> static struct bio_prison *prison_create(unsigned nr_cells)</span>
 
 static void prison_destroy(struct bio_prison *prison)
 {
<span class="p_add">+	vfree(prison-&gt;cells);</span>
 	mempool_destroy(prison-&gt;cell_pool);
 	kfree(prison);
 }
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree-remove.c b/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_header">index 1de0f5f..6e79c11 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_chunk">@@ -309,8 +309,8 @@</span> <span class="p_context"> static void redistribute3(struct dm_btree_info *info, struct btree_node *parent,</span>
 
 		if (s &lt; 0 &amp;&amp; nr_center &lt; -s) {
 			/* not enough in central node */
<span class="p_del">-			shift(left, center, nr_center);</span>
<span class="p_del">-			s = nr_center - target;</span>
<span class="p_add">+			shift(left, center, -nr_center);</span>
<span class="p_add">+			s += nr_center;</span>
 			shift(left, right, s);
 			nr_right += s;
 		} else
<span class="p_chunk">@@ -323,7 +323,7 @@</span> <span class="p_context"> static void redistribute3(struct dm_btree_info *info, struct btree_node *parent,</span>
 		if (s &gt; 0 &amp;&amp; nr_center &lt; s) {
 			/* not enough in central node */
 			shift(center, right, nr_center);
<span class="p_del">-			s = target - nr_center;</span>
<span class="p_add">+			s -= nr_center;</span>
 			shift(left, right, s);
 			nr_left -= s;
 		} else
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree.c b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">index bbb2ec5..18f37e0 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_chunk">@@ -236,7 +236,7 @@</span> <span class="p_context"> int dm_btree_del(struct dm_btree_info *info, dm_block_t root)</span>
 	int r;
 	struct del_stack *s;
 
<span class="p_del">-	s = kmalloc(sizeof(*s), GFP_KERNEL);</span>
<span class="p_add">+	s = kmalloc(sizeof(*s), GFP_NOIO);</span>
 	if (!s)
 		return -ENOMEM;
 	s-&gt;tm = info-&gt;tm;
<span class="p_header">diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c</span>
<span class="p_header">index aec029a..6e7b002 100644</span>
<span class="p_header">--- a/drivers/md/raid1.c</span>
<span class="p_header">+++ b/drivers/md/raid1.c</span>
<span class="p_chunk">@@ -313,7 +313,7 @@</span> <span class="p_context"> static void raid1_end_read_request(struct bio *bio, int error)</span>
 		spin_lock_irqsave(&amp;conf-&gt;device_lock, flags);
 		if (r1_bio-&gt;mddev-&gt;degraded == conf-&gt;raid_disks ||
 		    (r1_bio-&gt;mddev-&gt;degraded == conf-&gt;raid_disks-1 &amp;&amp;
<span class="p_del">-		     !test_bit(Faulty, &amp;conf-&gt;mirrors[mirror].rdev-&gt;flags)))</span>
<span class="p_add">+		     test_bit(In_sync, &amp;conf-&gt;mirrors[mirror].rdev-&gt;flags)))</span>
 			uptodate = 1;
 		spin_unlock_irqrestore(&amp;conf-&gt;device_lock, flags);
 	}
<span class="p_header">diff --git a/drivers/media/dvb/frontends/cx24116.c b/drivers/media/dvb/frontends/cx24116.c</span>
<span class="p_header">index ccd0525..4ff6d15 100644</span>
<span class="p_header">--- a/drivers/media/dvb/frontends/cx24116.c</span>
<span class="p_header">+++ b/drivers/media/dvb/frontends/cx24116.c</span>
<span class="p_chunk">@@ -963,6 +963,10 @@</span> <span class="p_context"> static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,</span>
 	struct cx24116_state *state = fe-&gt;demodulator_priv;
 	int i, ret;
 
<span class="p_add">+	/* Validate length */</span>
<span class="p_add">+	if (d-&gt;msg_len &gt; sizeof(d-&gt;msg))</span>
<span class="p_add">+                return -EINVAL;</span>
<span class="p_add">+</span>
 	/* Dump DiSEqC message */
 	if (debug) {
 		printk(KERN_INFO &quot;cx24116: %s(&quot;, __func__);
<span class="p_chunk">@@ -974,10 +978,6 @@</span> <span class="p_context"> static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,</span>
 		printk(&quot;) toneburst=%d\n&quot;, toneburst);
 	}
 
<span class="p_del">-	/* Validate length */</span>
<span class="p_del">-	if (d-&gt;msg_len &gt; (CX24116_ARGLEN - CX24116_DISEQC_MSGOFS))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
 	/* DiSEqC message */
 	for (i = 0; i &lt; d-&gt;msg_len; i++)
 		state-&gt;dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d-&gt;msg[i];
<span class="p_header">diff --git a/drivers/media/dvb/frontends/s5h1420.c b/drivers/media/dvb/frontends/s5h1420.c</span>
<span class="p_header">index 3879d2e..507ccae 100644</span>
<span class="p_header">--- a/drivers/media/dvb/frontends/s5h1420.c</span>
<span class="p_header">+++ b/drivers/media/dvb/frontends/s5h1420.c</span>
<span class="p_chunk">@@ -180,7 +180,7 @@</span> <span class="p_context"> static int s5h1420_send_master_cmd (struct dvb_frontend* fe,</span>
 	int result = 0;
 
 	dprintk(&quot;enter %s\n&quot;, __func__);
<span class="p_del">-	if (cmd-&gt;msg_len &gt; 8)</span>
<span class="p_add">+	if (cmd-&gt;msg_len &gt; sizeof(cmd-&gt;msg))</span>
 		return -EINVAL;
 
 	/* setup for DISEQC */
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index 4802f7f..f53d5c8 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -1285,9 +1285,11 @@</span> <span class="p_context"> static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)</span>
 			break;
 		case MMC_BLK_CMD_ERR:
 			ret = mmc_blk_cmd_err(md, card, brq, req, ret);
<span class="p_del">-			if (!mmc_blk_reset(md, card-&gt;host, type))</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			goto cmd_abort;</span>
<span class="p_add">+			if (mmc_blk_reset(md, card-&gt;host, type))</span>
<span class="p_add">+				goto cmd_abort;</span>
<span class="p_add">+			if (!ret)</span>
<span class="p_add">+				goto start_new_req;</span>
<span class="p_add">+			break;</span>
 		case MMC_BLK_RETRY:
 			if (retry++ &lt; 5)
 				break;
<span class="p_header">diff --git a/drivers/mtd/maps/dc21285.c b/drivers/mtd/maps/dc21285.c</span>
<span class="p_header">index f43b365..9af1528 100644</span>
<span class="p_header">--- a/drivers/mtd/maps/dc21285.c</span>
<span class="p_header">+++ b/drivers/mtd/maps/dc21285.c</span>
<span class="p_chunk">@@ -38,9 +38,9 @@</span> <span class="p_context"> static void nw_en_write(void)</span>
 	 * we want to write a bit pattern XXX1 to Xilinx to enable
 	 * the write gate, which will be open for about the next 2ms.
 	 */
<span class="p_del">-	spin_lock_irqsave(&amp;nw_gpio_lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;nw_gpio_lock, flags);</span>
 	nw_cpld_modify(CPLD_FLASH_WR_ENABLE, CPLD_FLASH_WR_ENABLE);
<span class="p_del">-	spin_unlock_irqrestore(&amp;nw_gpio_lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;nw_gpio_lock, flags);</span>
 
 	/*
 	 * let the ISA bus to catch on...
<span class="p_header">diff --git a/drivers/mtd/mtd_blkdevs.c b/drivers/mtd/mtd_blkdevs.c</span>
<span class="p_header">index 424ca5f..df58db3 100644</span>
<span class="p_header">--- a/drivers/mtd/mtd_blkdevs.c</span>
<span class="p_header">+++ b/drivers/mtd/mtd_blkdevs.c</span>
<span class="p_chunk">@@ -214,6 +214,7 @@</span> <span class="p_context"> static int blktrans_open(struct block_device *bdev, fmode_t mode)</span>
 		return -ERESTARTSYS; /* FIXME: busy loop! -arnd*/
 
 	mutex_lock(&amp;dev-&gt;lock);
<span class="p_add">+	mutex_lock(&amp;mtd_table_mutex);</span>
 
 	if (dev-&gt;open)
 		goto unlock;
<span class="p_chunk">@@ -236,6 +237,7 @@</span> <span class="p_context"> static int blktrans_open(struct block_device *bdev, fmode_t mode)</span>
 
 unlock:
 	dev-&gt;open++;
<span class="p_add">+	mutex_unlock(&amp;mtd_table_mutex);</span>
 	mutex_unlock(&amp;dev-&gt;lock);
 	blktrans_dev_put(dev);
 	return ret;
<span class="p_chunk">@@ -246,6 +248,7 @@</span> <span class="p_context"> error_release:</span>
 error_put:
 	module_put(dev-&gt;tr-&gt;owner);
 	kref_put(&amp;dev-&gt;ref, blktrans_dev_release);
<span class="p_add">+	mutex_unlock(&amp;mtd_table_mutex);</span>
 	mutex_unlock(&amp;dev-&gt;lock);
 	blktrans_dev_put(dev);
 	return ret;
<span class="p_chunk">@@ -260,6 +263,7 @@</span> <span class="p_context"> static int blktrans_release(struct gendisk *disk, fmode_t mode)</span>
 		return ret;
 
 	mutex_lock(&amp;dev-&gt;lock);
<span class="p_add">+	mutex_lock(&amp;mtd_table_mutex);</span>
 
 	if (--dev-&gt;open)
 		goto unlock;
<span class="p_chunk">@@ -272,6 +276,7 @@</span> <span class="p_context"> static int blktrans_release(struct gendisk *disk, fmode_t mode)</span>
 		__put_mtd_device(dev-&gt;mtd);
 	}
 unlock:
<span class="p_add">+	mutex_unlock(&amp;mtd_table_mutex);</span>
 	mutex_unlock(&amp;dev-&gt;lock);
 	blktrans_dev_put(dev);
 	return ret;
<span class="p_header">diff --git a/drivers/net/ethernet/stmicro/stmmac/descs.h b/drivers/net/ethernet/stmicro/stmmac/descs.h</span>
<span class="p_header">index 9820ec8..e93a0bf 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/stmicro/stmmac/descs.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/stmicro/stmmac/descs.h</span>
<span class="p_chunk">@@ -153,6 +153,8 @@</span> <span class="p_context"> struct dma_desc {</span>
 			u32 buffer2_size:13;
 			u32 reserved4:3;
 		} etx;		/* -- enhanced -- */
<span class="p_add">+</span>
<span class="p_add">+		u64 all_flags;</span>
 	} des01;
 	unsigned int des2;
 	unsigned int des3;
<span class="p_header">diff --git a/drivers/net/ethernet/stmicro/stmmac/enh_desc.c b/drivers/net/ethernet/stmicro/stmmac/enh_desc.c</span>
<span class="p_header">index d879763..73e647b 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/stmicro/stmmac/enh_desc.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/stmicro/stmmac/enh_desc.c</span>
<span class="p_chunk">@@ -232,6 +232,7 @@</span> <span class="p_context"> static void enh_desc_init_rx_desc(struct dma_desc *p, unsigned int ring_size,</span>
 {
 	int i;
 	for (i = 0; i &lt; ring_size; i++) {
<span class="p_add">+		p-&gt;des01.all_flags = 0;</span>
 		p-&gt;des01.erx.own = 1;
 		p-&gt;des01.erx.buffer1_size = BUF_SIZE_8KiB - 1;
 
<span class="p_chunk">@@ -248,7 +249,7 @@</span> <span class="p_context"> static void enh_desc_init_tx_desc(struct dma_desc *p, unsigned int ring_size)</span>
 	int i;
 
 	for (i = 0; i &lt; ring_size; i++) {
<span class="p_del">-		p-&gt;des01.etx.own = 0;</span>
<span class="p_add">+		p-&gt;des01.all_flags = 0;</span>
 		ehn_desc_tx_set_on_ring_chain(p, (i == ring_size - 1));
 		p++;
 	}
<span class="p_header">diff --git a/drivers/net/ethernet/stmicro/stmmac/norm_desc.c b/drivers/net/ethernet/stmicro/stmmac/norm_desc.c</span>
<span class="p_header">index fda5d2b..5bf9c37 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/stmicro/stmmac/norm_desc.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/stmicro/stmmac/norm_desc.c</span>
<span class="p_chunk">@@ -126,6 +126,7 @@</span> <span class="p_context"> static void ndesc_init_rx_desc(struct dma_desc *p, unsigned int ring_size,</span>
 {
 	int i;
 	for (i = 0; i &lt; ring_size; i++) {
<span class="p_add">+		p-&gt;des01.all_flags = 0;</span>
 		p-&gt;des01.rx.own = 1;
 		p-&gt;des01.rx.buffer1_size = BUF_SIZE_2KiB - 1;
 
<span class="p_chunk">@@ -141,7 +142,7 @@</span> <span class="p_context"> static void ndesc_init_tx_desc(struct dma_desc *p, unsigned int ring_size)</span>
 {
 	int i;
 	for (i = 0; i &lt; ring_size; i++) {
<span class="p_del">-		p-&gt;des01.tx.own = 0;</span>
<span class="p_add">+		p-&gt;des01.all_flags = 0;</span>
 		ndesc_tx_set_on_ring_chain(p, (i == (ring_size - 1)));
 		p++;
 	}
<span class="p_header">diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c</span>
<span class="p_header">index d4d2bc1..05852e3 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c</span>
<span class="p_chunk">@@ -441,19 +441,17 @@</span> <span class="p_context"> static void init_dma_desc_rings(struct net_device *dev)</span>
 	priv-&gt;rx_skbuff =
 	    kmalloc(sizeof(struct sk_buff *) * rxsize, GFP_KERNEL);
 	priv-&gt;dma_rx =
<span class="p_del">-	    (struct dma_desc *)dma_alloc_coherent(priv-&gt;device,</span>
<span class="p_del">-						  rxsize *</span>
<span class="p_del">-						  sizeof(struct dma_desc),</span>
<span class="p_del">-						  &amp;priv-&gt;dma_rx_phy,</span>
<span class="p_del">-						  GFP_KERNEL);</span>
<span class="p_add">+	    (struct dma_desc *)dma_zalloc_coherent(priv-&gt;device, rxsize *</span>
<span class="p_add">+						   sizeof(struct dma_desc),</span>
<span class="p_add">+						   &amp;priv-&gt;dma_rx_phy,</span>
<span class="p_add">+						   GFP_KERNEL);</span>
 	priv-&gt;tx_skbuff = kmalloc(sizeof(struct sk_buff *) * txsize,
 				       GFP_KERNEL);
 	priv-&gt;dma_tx =
<span class="p_del">-	    (struct dma_desc *)dma_alloc_coherent(priv-&gt;device,</span>
<span class="p_del">-						  txsize *</span>
<span class="p_del">-						  sizeof(struct dma_desc),</span>
<span class="p_del">-						  &amp;priv-&gt;dma_tx_phy,</span>
<span class="p_del">-						  GFP_KERNEL);</span>
<span class="p_add">+	    (struct dma_desc *)dma_zalloc_coherent(priv-&gt;device, txsize *</span>
<span class="p_add">+						   sizeof(struct dma_desc),</span>
<span class="p_add">+						   &amp;priv-&gt;dma_tx_phy,</span>
<span class="p_add">+						   GFP_KERNEL);</span>
 
 	if ((priv-&gt;dma_rx == NULL) || (priv-&gt;dma_tx == NULL)) {
 		pr_err(&quot;%s:ERROR allocating the DMA Tx/Rx desc\n&quot;, __func__);
<span class="p_header">diff --git a/drivers/net/ethernet/sun/niu.c b/drivers/net/ethernet/sun/niu.c</span>
<span class="p_header">index 73c7081..c646a49 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sun/niu.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sun/niu.c</span>
<span class="p_chunk">@@ -6670,10 +6670,8 @@</span> <span class="p_context"> static netdev_tx_t niu_start_xmit(struct sk_buff *skb,</span>
 		struct sk_buff *skb_new;
 
 		skb_new = skb_realloc_headroom(skb, len);
<span class="p_del">-		if (!skb_new) {</span>
<span class="p_del">-			rp-&gt;tx_errors++;</span>
<span class="p_add">+		if (!skb_new)</span>
 			goto out_drop;
<span class="p_del">-		}</span>
 		kfree_skb(skb);
 		skb = skb_new;
 	} else
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/main.c b/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_header">index ad33126..8d64c16 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_chunk">@@ -235,7 +235,7 @@</span> <span class="p_context"> static bool ath_prepare_reset(struct ath_softc *sc, bool retry_tx, bool flush)</span>
 {
 	struct ath_hw *ah = sc-&gt;sc_ah;
 	struct ath_common *common = ath9k_hw_common(ah);
<span class="p_del">-	bool ret;</span>
<span class="p_add">+	bool ret = true;</span>
 
 	ieee80211_stop_queues(sc-&gt;hw);
 
<span class="p_chunk">@@ -245,10 +245,13 @@</span> <span class="p_context"> static bool ath_prepare_reset(struct ath_softc *sc, bool retry_tx, bool flush)</span>
 	ath9k_debug_samp_bb_mac(sc);
 	ath9k_hw_disable_interrupts(ah);
 
<span class="p_del">-	ret = ath_drain_all_txq(sc, retry_tx);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!ath_stoprecv(sc))</span>
<span class="p_del">-		ret = false;</span>
<span class="p_add">+	if (AR_SREV_9300_20_OR_LATER(ah)) {</span>
<span class="p_add">+		ret &amp;= ath_stoprecv(sc);</span>
<span class="p_add">+		ret &amp;= ath_drain_all_txq(sc, retry_tx);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		ret &amp;= ath_drain_all_txq(sc, retry_tx);</span>
<span class="p_add">+		ret &amp;= ath_stoprecv(sc);</span>
<span class="p_add">+	}</span>
 
 	if (!flush) {
 		if (ah-&gt;caps.hw_caps &amp; ATH9K_HW_CAP_EDMA)
<span class="p_header">diff --git a/drivers/pcmcia/topic.h b/drivers/pcmcia/topic.h</span>
<span class="p_header">index 615a45a..582688fe 100644</span>
<span class="p_header">--- a/drivers/pcmcia/topic.h</span>
<span class="p_header">+++ b/drivers/pcmcia/topic.h</span>
<span class="p_chunk">@@ -104,6 +104,9 @@</span> <span class="p_context"></span>
 #define TOPIC_EXCA_IF_CONTROL		0x3e	/* 8 bit */
 #define TOPIC_EXCA_IFC_33V_ENA		0x01
 
<span class="p_add">+#define TOPIC_PCI_CFG_PPBCN		0x3e	/* 16-bit */</span>
<span class="p_add">+#define TOPIC_PCI_CFG_PPBCN_WBEN	0x0400</span>
<span class="p_add">+</span>
 static void topic97_zoom_video(struct pcmcia_socket *sock, int onoff)
 {
 	struct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);
<span class="p_chunk">@@ -138,6 +141,7 @@</span> <span class="p_context"> static int topic97_override(struct yenta_socket *socket)</span>
 static int topic95_override(struct yenta_socket *socket)
 {
 	u8 fctrl;
<span class="p_add">+	u16 ppbcn;</span>
 
 	/* enable 3.3V support for 16bit cards */
 	fctrl = exca_readb(socket, TOPIC_EXCA_IF_CONTROL);
<span class="p_chunk">@@ -146,6 +150,18 @@</span> <span class="p_context"> static int topic95_override(struct yenta_socket *socket)</span>
 	/* tell yenta to use exca registers to power 16bit cards */
 	socket-&gt;flags |= YENTA_16BIT_POWER_EXCA | YENTA_16BIT_POWER_DF;
 
<span class="p_add">+	/* Disable write buffers to prevent lockups under load with numerous</span>
<span class="p_add">+	   Cardbus cards, observed on Tecra 500CDT and reported elsewhere on the</span>
<span class="p_add">+	   net.  This is not a power-on default according to the datasheet</span>
<span class="p_add">+	   but some BIOSes seem to set it. */</span>
<span class="p_add">+	if (pci_read_config_word(socket-&gt;dev, TOPIC_PCI_CFG_PPBCN, &amp;ppbcn) == 0</span>
<span class="p_add">+	    &amp;&amp; socket-&gt;dev-&gt;revision &lt;= 7</span>
<span class="p_add">+	    &amp;&amp; (ppbcn &amp; TOPIC_PCI_CFG_PPBCN_WBEN)) {</span>
<span class="p_add">+		ppbcn &amp;= ~TOPIC_PCI_CFG_PPBCN_WBEN;</span>
<span class="p_add">+		pci_write_config_word(socket-&gt;dev, TOPIC_PCI_CFG_PPBCN, ppbcn);</span>
<span class="p_add">+		dev_info(&amp;socket-&gt;dev-&gt;dev, &quot;Disabled ToPIC95 Cardbus write buffers.\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/platform/x86/dell-laptop.c b/drivers/platform/x86/dell-laptop.c</span>
<span class="p_header">index 1d3bcce..e57f5de 100644</span>
<span class="p_header">--- a/drivers/platform/x86/dell-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/dell-laptop.c</span>
<span class="p_chunk">@@ -215,7 +215,6 @@</span> <span class="p_context"> static struct dmi_system_id __devinitdata dell_quirks[] = {</span>
 };
 
 static struct calling_interface_buffer *buffer;
<span class="p_del">-static struct page *bufferpage;</span>
 static DEFINE_MUTEX(buffer_mutex);
 
 static int hwswitch_state;
<span class="p_chunk">@@ -715,11 +714,10 @@</span> <span class="p_context"> static int __init dell_init(void)</span>
 	 * Allocate buffer below 4GB for SMI data--only 32-bit physical addr
 	 * is passed to SMI handler.
 	 */
<span class="p_del">-	bufferpage = alloc_page(GFP_KERNEL | GFP_DMA32);</span>
<span class="p_add">+	buffer = (void *)__get_free_page(GFP_KERNEL | GFP_DMA32);</span>
 
<span class="p_del">-	if (!bufferpage)</span>
<span class="p_add">+	if (!buffer)</span>
 		goto fail_buffer;
<span class="p_del">-	buffer = page_address(bufferpage);</span>
 
 	ret = dell_setup_rfkill();
 
<span class="p_chunk">@@ -788,7 +786,7 @@</span> <span class="p_context"> fail_backlight:</span>
 fail_filter:
 	dell_cleanup_rfkill();
 fail_rfkill:
<span class="p_del">-	free_page((unsigned long)bufferpage);</span>
<span class="p_add">+	free_page((unsigned long)buffer);</span>
 fail_buffer:
 	platform_device_del(platform_device);
 fail_platform_device2:
<span class="p_header">diff --git a/drivers/platform/x86/ideapad-laptop.c b/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_header">index a36addf..04a6928 100644</span>
<span class="p_header">--- a/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_chunk">@@ -407,7 +407,8 @@</span> <span class="p_context"> const struct ideapad_rfk_data ideapad_rfk_data[] = {</span>
 
 static int ideapad_rfk_set(void *data, bool blocked)
 {
<span class="p_del">-	unsigned long opcode = (unsigned long)data;</span>
<span class="p_add">+	unsigned long dev = (unsigned long)data;</span>
<span class="p_add">+	int opcode = ideapad_rfk_data[dev].opcode;</span>
 
 	return write_ec_cmd(ideapad_handle, opcode, !blocked);
 }
<span class="p_header">diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c</span>
<span class="p_header">index adba3d6..2dd9838 100644</span>
<span class="p_header">--- a/drivers/regulator/core.c</span>
<span class="p_header">+++ b/drivers/regulator/core.c</span>
<span class="p_chunk">@@ -726,7 +726,7 @@</span> <span class="p_context"> static int suspend_prepare(struct regulator_dev *rdev, suspend_state_t state)</span>
 static void print_constraints(struct regulator_dev *rdev)
 {
 	struct regulation_constraints *constraints = rdev-&gt;constraints;
<span class="p_del">-	char buf[80] = &quot;&quot;;</span>
<span class="p_add">+	char buf[160] = &quot;&quot;;</span>
 	int count = 0;
 	int ret;
 
<span class="p_header">diff --git a/drivers/scsi/ipr.h b/drivers/scsi/ipr.h</span>
<span class="p_header">index ac84736..a9932bd 100644</span>
<span class="p_header">--- a/drivers/scsi/ipr.h</span>
<span class="p_header">+++ b/drivers/scsi/ipr.h</span>
<span class="p_chunk">@@ -251,7 +251,7 @@</span> <span class="p_context"></span>
 #define IPR_RUNTIME_RESET				0x40000000
 
 #define IPR_IPL_INIT_MIN_STAGE_TIME			5
<span class="p_del">-#define IPR_IPL_INIT_DEFAULT_STAGE_TIME                 15</span>
<span class="p_add">+#define IPR_IPL_INIT_DEFAULT_STAGE_TIME                 30</span>
 #define IPR_IPL_INIT_STAGE_UNKNOWN			0x0
 #define IPR_IPL_INIT_STAGE_TRANSOP			0xB0000000
 #define IPR_IPL_INIT_STAGE_MASK				0xff000000
<span class="p_header">diff --git a/drivers/staging/iio/dac/ad5624r_spi.c b/drivers/staging/iio/dac/ad5624r_spi.c</span>
<span class="p_header">index 284d8790..8e81fce 100644</span>
<span class="p_header">--- a/drivers/staging/iio/dac/ad5624r_spi.c</span>
<span class="p_header">+++ b/drivers/staging/iio/dac/ad5624r_spi.c</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> static const struct ad5624r_chip_info ad5624r_chip_info_tbl[] = {</span>
 };
 
 static int ad5624r_spi_write(struct spi_device *spi,
<span class="p_del">-			     u8 cmd, u8 addr, u16 val, u8 len)</span>
<span class="p_add">+			     u8 cmd, u8 addr, u16 val, u8 shift)</span>
 {
 	u32 data;
 	u8 msg[3];
<span class="p_chunk">@@ -62,7 +62,7 @@</span> <span class="p_context"> static int ad5624r_spi_write(struct spi_device *spi,</span>
 	 * 14-, 12-bit input code followed by 0, 2, or 4 don&#39;t care bits,
 	 * for the AD5664R, AD5644R, and AD5624R, respectively.
 	 */
<span class="p_del">-	data = (0 &lt;&lt; 22) | (cmd &lt;&lt; 19) | (addr &lt;&lt; 16) | (val &lt;&lt; (16 - len));</span>
<span class="p_add">+	data = (0 &lt;&lt; 22) | (cmd &lt;&lt; 19) | (addr &lt;&lt; 16) | (val &lt;&lt; shift);</span>
 	msg[0] = data &gt;&gt; 16;
 	msg[1] = data &gt;&gt; 8;
 	msg[2] = data;
<span class="p_header">diff --git a/drivers/staging/rtl8712/rtl8712_recv.c b/drivers/staging/rtl8712/rtl8712_recv.c</span>
<span class="p_header">index 6d69265..a33bece 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8712/rtl8712_recv.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8712/rtl8712_recv.c</span>
<span class="p_chunk">@@ -1076,7 +1076,8 @@</span> <span class="p_context"> static int recvbuf2recvframe(struct _adapter *padapter, struct sk_buff *pskb)</span>
 		/* for first fragment packet, driver need allocate 1536 +
 		 * drvinfo_sz + RXDESC_SIZE to defrag packet. */
 		if ((mf == 1) &amp;&amp; (frag == 0))
<span class="p_del">-			alloc_sz = 1658;/*1658+6=1664, 1664 is 128 alignment.*/</span>
<span class="p_add">+			/*1658+6=1664, 1664 is 128 alignment.*/</span>
<span class="p_add">+			alloc_sz = max_t(u16, tmp_len, 1658);</span>
 		else
 			alloc_sz = tmp_len;
 		/* 2 is for IP header 4 bytes alignment in QoS packet case.
<span class="p_header">diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c</span>
<span class="p_header">index d540a06..077c506 100644</span>
<span class="p_header">--- a/drivers/staging/vt6655/device_main.c</span>
<span class="p_header">+++ b/drivers/staging/vt6655/device_main.c</span>
<span class="p_chunk">@@ -1602,6 +1602,10 @@</span> <span class="p_context"> static int device_rx_srv(PSDevice pDevice, unsigned int uIdx) {</span>
 //        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO &quot;pDevice-&gt;pCurrRD = %x, works = %d\n&quot;, pRD, works);
         if (works++&gt;15)
             break;
<span class="p_add">+</span>
<span class="p_add">+        if (!pRD-&gt;pRDInfo-&gt;skb)</span>
<span class="p_add">+            break;</span>
<span class="p_add">+</span>
         if (device_receive_frame(pDevice, pRD)) {
             if (!device_alloc_rx_buf(pDevice,pRD)) {
                     DBG_PRT(MSG_LEVEL_ERR, KERN_ERR
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">index ae4e7da..59fb984 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_chunk">@@ -4509,6 +4509,7 @@</span> <span class="p_context"> int iscsit_release_sessions_for_tpg(struct iscsi_portal_group *tpg, int force)</span>
 	struct iscsi_session *sess;
 	struct se_portal_group *se_tpg = &amp;tpg-&gt;tpg_se_tpg;
 	struct se_session *se_sess, *se_sess_tmp;
<span class="p_add">+	LIST_HEAD(free_list);</span>
 	int session_count = 0;
 
 	spin_lock_bh(&amp;se_tpg-&gt;session_lock);
<span class="p_chunk">@@ -4530,14 +4531,17 @@</span> <span class="p_context"> int iscsit_release_sessions_for_tpg(struct iscsi_portal_group *tpg, int force)</span>
 		}
 		atomic_set(&amp;sess-&gt;session_reinstatement, 1);
 		spin_unlock(&amp;sess-&gt;conn_lock);
<span class="p_del">-		spin_unlock_bh(&amp;se_tpg-&gt;session_lock);</span>
 
<span class="p_del">-		iscsit_free_session(sess);</span>
<span class="p_del">-		spin_lock_bh(&amp;se_tpg-&gt;session_lock);</span>
<span class="p_add">+		list_move_tail(&amp;se_sess-&gt;sess_list, &amp;free_list);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_bh(&amp;se_tpg-&gt;session_lock);</span>
 
<span class="p_add">+	list_for_each_entry_safe(se_sess, se_sess_tmp, &amp;free_list, sess_list) {</span>
<span class="p_add">+		sess = (struct iscsi_session *)se_sess-&gt;fabric_sess_ptr;</span>
<span class="p_add">+</span>
<span class="p_add">+		iscsit_free_session(sess);</span>
 		session_count++;
 	}
<span class="p_del">-	spin_unlock_bh(&amp;se_tpg-&gt;session_lock);</span>
 
 	pr_debug(&quot;Released %d iSCSI Session(s) from Target Portal&quot;
 			&quot; Group: %hu\n&quot;, session_count, tpg-&gt;tpgt);
<span class="p_header">diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">index 99fcb8c..9645186 100644</span>
<span class="p_header">--- a/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_chunk">@@ -229,8 +229,7 @@</span> <span class="p_context"> void atmel_config_rs485(struct uart_port *port, struct serial_rs485 *rs485conf)</span>
 	if (rs485conf-&gt;flags &amp; SER_RS485_ENABLED) {
 		dev_dbg(port-&gt;dev, &quot;Setting UART to RS485\n&quot;);
 		atmel_port-&gt;tx_done_mask = ATMEL_US_TXEMPTY;
<span class="p_del">-		if ((rs485conf-&gt;delay_rts_after_send) &gt; 0)</span>
<span class="p_del">-			UART_PUT_TTGR(port, rs485conf-&gt;delay_rts_after_send);</span>
<span class="p_add">+		UART_PUT_TTGR(port, rs485conf-&gt;delay_rts_after_send);</span>
 		mode |= ATMEL_US_USMODE_RS485;
 	} else {
 		dev_dbg(port-&gt;dev, &quot;Setting UART to RS232\n&quot;);
<span class="p_chunk">@@ -305,9 +304,7 @@</span> <span class="p_context"> static void atmel_set_mctrl(struct uart_port *port, u_int mctrl)</span>
 
 	if (atmel_port-&gt;rs485.flags &amp; SER_RS485_ENABLED) {
 		dev_dbg(port-&gt;dev, &quot;Setting UART to RS485\n&quot;);
<span class="p_del">-		if ((atmel_port-&gt;rs485.delay_rts_after_send) &gt; 0)</span>
<span class="p_del">-			UART_PUT_TTGR(port,</span>
<span class="p_del">-					atmel_port-&gt;rs485.delay_rts_after_send);</span>
<span class="p_add">+		UART_PUT_TTGR(port, atmel_port-&gt;rs485.delay_rts_after_send);</span>
 		mode |= ATMEL_US_USMODE_RS485;
 	} else {
 		dev_dbg(port-&gt;dev, &quot;Setting UART to RS232\n&quot;);
<span class="p_chunk">@@ -1229,9 +1226,7 @@</span> <span class="p_context"> static void atmel_set_termios(struct uart_port *port, struct ktermios *termios,</span>
 
 	if (atmel_port-&gt;rs485.flags &amp; SER_RS485_ENABLED) {
 		dev_dbg(port-&gt;dev, &quot;Setting UART to RS485\n&quot;);
<span class="p_del">-		if ((atmel_port-&gt;rs485.delay_rts_after_send) &gt; 0)</span>
<span class="p_del">-			UART_PUT_TTGR(port,</span>
<span class="p_del">-					atmel_port-&gt;rs485.delay_rts_after_send);</span>
<span class="p_add">+		UART_PUT_TTGR(port, atmel_port-&gt;rs485.delay_rts_after_send);</span>
 		mode |= ATMEL_US_USMODE_RS485;
 	} else {
 		dev_dbg(port-&gt;dev, &quot;Setting UART to RS232\n&quot;);
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index 57d6302..ca666d0 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1295,6 +1295,11 @@</span> <span class="p_context"> skip_countries:</span>
 
 	acm_table[minor] = acm;
 
<span class="p_add">+	if (quirks &amp; CLEAR_HALT_CONDITIONS) {</span>
<span class="p_add">+		usb_clear_halt(usb_dev, usb_rcvbulkpipe(usb_dev, epread-&gt;bEndpointAddress));</span>
<span class="p_add">+		usb_clear_halt(usb_dev, usb_sndbulkpipe(usb_dev, epwrite-&gt;bEndpointAddress));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 alloc_fail7:
 	for (i = 0; i &lt; ACM_NW; i++)
<span class="p_chunk">@@ -1574,6 +1579,10 @@</span> <span class="p_context"> static const struct usb_device_id acm_ids[] = {</span>
 	.driver_info = NO_UNION_NORMAL, /* reports zero length descriptor */
 	},
 
<span class="p_add">+	{ USB_DEVICE(0x2912, 0x0001), /* ATOL FPrint */</span>
<span class="p_add">+	.driver_info = CLEAR_HALT_CONDITIONS,</span>
<span class="p_add">+	},</span>
<span class="p_add">+</span>
 	/* Nokia S60 phones expose two ACM channels. The first is
 	 * a modem and is picked up by the standard AT-command
 	 * information below. The second is &#39;vendor-specific&#39; but
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.h b/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">index c3f1b36..7aa5e9a 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.h</span>
<span class="p_chunk">@@ -127,3 +127,4 @@</span> <span class="p_context"> struct acm {</span>
 #define NO_CAP_LINE			4
 #define NOT_A_MODEM			8
 #define NO_DATA_INTERFACE		16
<span class="p_add">+#define CLEAR_HALT_CONDITIONS		BIT(7)</span>
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 18286ce..7cfe286 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -2157,9 +2157,6 @@</span> <span class="p_context"> static unsigned hub_is_wusb(struct usb_hub *hub)</span>
 #define HUB_LONG_RESET_TIME	200
 #define HUB_RESET_TIMEOUT	800
 
<span class="p_del">-static int hub_port_reset(struct usb_hub *hub, int port1,</span>
<span class="p_del">-			struct usb_device *udev, unsigned int delay, bool warm);</span>
<span class="p_del">-</span>
 /* Is a USB 3.0 port in the Inactive or Complinance Mode state?
  * Port worm reset is required to recover
  */
<span class="p_chunk">@@ -2239,44 +2236,6 @@</span> <span class="p_context"> delay:</span>
 	return -EBUSY;
 }
 
<span class="p_del">-static void hub_port_finish_reset(struct usb_hub *hub, int port1,</span>
<span class="p_del">-			struct usb_device *udev, int *status)</span>
<span class="p_del">-{</span>
<span class="p_del">-	switch (*status) {</span>
<span class="p_del">-	case 0:</span>
<span class="p_del">-		/* TRSTRCY = 10 ms; plus some extra */</span>
<span class="p_del">-		msleep(10 + 40);</span>
<span class="p_del">-		if (udev) {</span>
<span class="p_del">-			struct usb_hcd *hcd = bus_to_hcd(udev-&gt;bus);</span>
<span class="p_del">-</span>
<span class="p_del">-			update_devnum(udev, 0);</span>
<span class="p_del">-			/* The xHC may think the device is already reset,</span>
<span class="p_del">-			 * so ignore the status.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (hcd-&gt;driver-&gt;reset_device)</span>
<span class="p_del">-				hcd-&gt;driver-&gt;reset_device(hcd, udev);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		/* FALL THROUGH */</span>
<span class="p_del">-	case -ENOTCONN:</span>
<span class="p_del">-	case -ENODEV:</span>
<span class="p_del">-		clear_port_feature(hub-&gt;hdev,</span>
<span class="p_del">-				port1, USB_PORT_FEAT_C_RESET);</span>
<span class="p_del">-		if (hub_is_superspeed(hub-&gt;hdev)) {</span>
<span class="p_del">-			clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_del">-					USB_PORT_FEAT_C_BH_PORT_RESET);</span>
<span class="p_del">-			clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_del">-					USB_PORT_FEAT_C_PORT_LINK_STATE);</span>
<span class="p_del">-			clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_del">-					USB_PORT_FEAT_C_CONNECTION);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (udev)</span>
<span class="p_del">-			usb_set_device_state(udev, *status</span>
<span class="p_del">-					? USB_STATE_NOTATTACHED</span>
<span class="p_del">-					: USB_STATE_DEFAULT);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* Handle port reset and port warm(BH) reset (for USB3 protocol ports) */
 static int hub_port_reset(struct usb_hub *hub, int port1,
 			struct usb_device *udev, unsigned int delay, bool warm)
<span class="p_chunk">@@ -2299,13 +2258,9 @@</span> <span class="p_context"> static int hub_port_reset(struct usb_hub *hub, int port1,</span>
 		 * If the caller hasn&#39;t explicitly requested a warm reset,
 		 * double check and see if one is needed.
 		 */
<span class="p_del">-		status = hub_port_status(hub, port1,</span>
<span class="p_del">-					&amp;portstatus, &amp;portchange);</span>
<span class="p_del">-		if (status &lt; 0)</span>
<span class="p_del">-			goto done;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (hub_port_warm_reset_required(hub, portstatus))</span>
<span class="p_del">-			warm = true;</span>
<span class="p_add">+		if (hub_port_status(hub, port1, &amp;portstatus, &amp;portchange) == 0)</span>
<span class="p_add">+			if (hub_port_warm_reset_required(hub, portstatus))</span>
<span class="p_add">+				warm = true;</span>
 	}
 
 	/* Reset the port */
<span class="p_chunk">@@ -2328,11 +2283,19 @@</span> <span class="p_context"> static int hub_port_reset(struct usb_hub *hub, int port1,</span>
 
 		/* Check for disconnect or reset */
 		if (status == 0 || status == -ENOTCONN || status == -ENODEV) {
<span class="p_del">-			hub_port_finish_reset(hub, port1, udev, &amp;status);</span>
<span class="p_add">+			clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_add">+					USB_PORT_FEAT_C_RESET);</span>
 
 			if (!hub_is_superspeed(hub-&gt;hdev))
 				goto done;
 
<span class="p_add">+			clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_add">+					USB_PORT_FEAT_C_BH_PORT_RESET);</span>
<span class="p_add">+			clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_add">+					USB_PORT_FEAT_C_PORT_LINK_STATE);</span>
<span class="p_add">+			clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_add">+					USB_PORT_FEAT_C_CONNECTION);</span>
<span class="p_add">+</span>
 			/*
 			 * If a USB 3.0 device migrates from reset to an error
 			 * state, re-issue the warm reset.
<span class="p_chunk">@@ -2366,6 +2329,26 @@</span> <span class="p_context"> static int hub_port_reset(struct usb_hub *hub, int port1,</span>
 		port1);
 
 done:
<span class="p_add">+	if (status == 0) {</span>
<span class="p_add">+		/* TRSTRCY = 10 ms; plus some extra */</span>
<span class="p_add">+		msleep(10 + 40);</span>
<span class="p_add">+		if (udev) {</span>
<span class="p_add">+			struct usb_hcd *hcd = bus_to_hcd(udev-&gt;bus);</span>
<span class="p_add">+</span>
<span class="p_add">+			update_devnum(udev, 0);</span>
<span class="p_add">+			/* The xHC may think the device is already reset,</span>
<span class="p_add">+			 * so ignore the status.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (hcd-&gt;driver-&gt;reset_device)</span>
<span class="p_add">+				hcd-&gt;driver-&gt;reset_device(hcd, udev);</span>
<span class="p_add">+</span>
<span class="p_add">+			usb_set_device_state(udev, USB_STATE_DEFAULT);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (udev)</span>
<span class="p_add">+			usb_set_device_state(udev, USB_STATE_NOTATTACHED);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (!hub_is_superspeed(hub-&gt;hdev))
 		up_read(&amp;ehci_cf_port_reset_rwsem);
 
<span class="p_header">diff --git a/drivers/usb/dwc3/ep0.c b/drivers/usb/dwc3/ep0.c</span>
<span class="p_header">index c4134e8..24864d4 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/ep0.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/ep0.c</span>
<span class="p_chunk">@@ -498,6 +498,10 @@</span> <span class="p_context"> static int dwc3_ep0_std_request(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)</span>
 		dev_vdbg(dwc-&gt;dev, &quot;USB_REQ_SET_CONFIGURATION\n&quot;);
 		ret = dwc3_ep0_set_config(dwc, ctrl);
 		break;
<span class="p_add">+	case USB_REQ_SET_INTERFACE:</span>
<span class="p_add">+		dev_vdbg(dwc-&gt;dev ,&quot;USB_REQ_SET_INTERFACE&quot;);</span>
<span class="p_add">+		dwc-&gt;start_config_issued = false;</span>
<span class="p_add">+		/* Fall through */</span>
 	default:
 		dev_vdbg(dwc-&gt;dev, &quot;Forwarding to gadget driver\n&quot;);
 		ret = dwc3_ep0_delegate_req(dwc, ctrl);
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index 5f2e3d0..b4623f1 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -171,6 +171,8 @@</span> <span class="p_context"> int dwc3_send_gadget_ep_cmd(struct dwc3 *dwc, unsigned ep,</span>
 		if (!(reg &amp; DWC3_DEPCMD_CMDACT)) {
 			dev_vdbg(dwc-&gt;dev, &quot;Command Complete --&gt; %d\n&quot;,
 					DWC3_DEPCMD_STATUS(reg));
<span class="p_add">+			if (DWC3_DEPCMD_STATUS(reg))</span>
<span class="p_add">+				return -EINVAL;</span>
 			return 0;
 		}
 
<span class="p_header">diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">index c1fa92e..8605813 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-hub.c</span>
<span class="p_chunk">@@ -449,10 +449,13 @@</span> <span class="p_context"> static void xhci_hub_report_link_state(struct xhci_hcd *xhci,</span>
 	u32 pls = status_reg &amp; PORT_PLS_MASK;
 
 	/* resume state is a xHCI internal state.
<span class="p_del">-	 * Do not report it to usb core.</span>
<span class="p_add">+	 * Do not report it to usb core, instead, pretend to be U3,</span>
<span class="p_add">+	 * thus usb core knows it&#39;s not ready for transfer</span>
 	 */
<span class="p_del">-	if (pls == XDEV_RESUME)</span>
<span class="p_add">+	if (pls == XDEV_RESUME) {</span>
<span class="p_add">+		*status |= USB_SS_PORT_LS_U3;</span>
 		return;
<span class="p_add">+	}</span>
 
 	/* When the CAS bit is set then warm reset
 	 * should be performed on port
<span class="p_chunk">@@ -592,7 +595,14 @@</span> <span class="p_context"> int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,</span>
 			status |= USB_PORT_STAT_C_RESET &lt;&lt; 16;
 		/* USB3.0 only */
 		if (hcd-&gt;speed == HCD_USB3) {
<span class="p_del">-			if ((temp &amp; PORT_PLC))</span>
<span class="p_add">+			/* Port link change with port in resume state should not be</span>
<span class="p_add">+			 * reported to usbcore, as this is an internal state to be</span>
<span class="p_add">+			 * handled by xhci driver. Reporting PLC to usbcore may</span>
<span class="p_add">+			 * cause usbcore clearing PLC first and port change event</span>
<span class="p_add">+			 * irq won&#39;t be generated.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if ((temp &amp; PORT_PLC) &amp;&amp;</span>
<span class="p_add">+				(temp &amp; PORT_PLS_MASK) != XDEV_RESUME)</span>
 				status |= USB_PORT_STAT_C_LINK_STATE &lt;&lt; 16;
 			if ((temp &amp; PORT_WRC))
 				status |= USB_PORT_STAT_C_BH_RESET &lt;&lt; 16;
<span class="p_header">diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">index 0f4a41d..d5d2af5 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-mem.c</span>
<span class="p_chunk">@@ -1330,10 +1330,10 @@</span> <span class="p_context"> int xhci_endpoint_init(struct xhci_hcd *xhci,</span>
 		/* Attempt to use the ring cache */
 		if (virt_dev-&gt;num_rings_cached == 0)
 			return -ENOMEM;
<span class="p_add">+		virt_dev-&gt;num_rings_cached--;</span>
 		virt_dev-&gt;eps[ep_index].new_ring =
 			virt_dev-&gt;ring_cache[virt_dev-&gt;num_rings_cached];
 		virt_dev-&gt;ring_cache[virt_dev-&gt;num_rings_cached] = NULL;
<span class="p_del">-		virt_dev-&gt;num_rings_cached--;</span>
 		xhci_reinit_cached_ring(xhci, virt_dev-&gt;eps[ep_index].new_ring,
 			usb_endpoint_xfer_isoc(&amp;ep-&gt;desc) ? true : false);
 	}
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index 5c535a8..950a8cc 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -3361,6 +3361,9 @@</span> <span class="p_context"> int xhci_discover_or_reset_device(struct usb_hcd *hcd, struct usb_device *udev)</span>
 			return -EINVAL;
 	}
 
<span class="p_add">+	if (virt_dev-&gt;tt_info)</span>
<span class="p_add">+		old_active_eps = virt_dev-&gt;tt_info-&gt;active_eps;</span>
<span class="p_add">+</span>
 	if (virt_dev-&gt;udev != udev) {
 		/* If the virt_dev and the udev does not match, this virt_dev
 		 * may belong to another udev.
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 073a0f98..1a19724 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -193,6 +193,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x1FB9, 0x0602) }, /* Lake Shore Model 648 Magnet Power Supply */
 	{ USB_DEVICE(0x1FB9, 0x0700) }, /* Lake Shore Model 737 VSM Controller */
 	{ USB_DEVICE(0x1FB9, 0x0701) }, /* Lake Shore Model 776 Hall Matrix */
<span class="p_add">+	{ USB_DEVICE(0x2626, 0xEA60) }, /* Aruba Networks 7xxx USB Serial Console */</span>
 	{ USB_DEVICE(0x3195, 0xF190) }, /* Link Instruments MSO-19 */
 	{ USB_DEVICE(0x3195, 0xF280) }, /* Link Instruments MSO-28 */
 	{ USB_DEVICE(0x3195, 0xF281) }, /* Link Instruments MSO-28 */
<span class="p_header">diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">index 68e8552..a0c4cc4 100644</span>
<span class="p_header">--- a/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">+++ b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_chunk">@@ -2019,6 +2019,18 @@</span> <span class="p_context"> UNUSUAL_DEV( 0x1908, 0x3335, 0x0200, 0x0200,</span>
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_NO_READ_DISC_INFO ),
 
<span class="p_add">+/* Reported by Oliver Neukum &lt;oneukum@suse.com&gt;</span>
<span class="p_add">+ * This device morphes spontaneously into another device if the access</span>
<span class="p_add">+ * pattern of Windows isn&#39;t followed. Thus writable media would be dirty</span>
<span class="p_add">+ * if the initial instance is used. So the device is limited to its</span>
<span class="p_add">+ * virtual CD.</span>
<span class="p_add">+ * And yes, the concept that BCD goes up to 9 is not heeded */</span>
<span class="p_add">+UNUSUAL_DEV( 0x19d2, 0x1225, 0x0000, 0xffff,</span>
<span class="p_add">+		&quot;ZTE,Incorporated&quot;,</span>
<span class="p_add">+		&quot;ZTE WCDMA Technologies MSM&quot;,</span>
<span class="p_add">+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,</span>
<span class="p_add">+		US_FL_SINGLE_LUN ),</span>
<span class="p_add">+</span>
 /* Reported by Sven Geggus &lt;sven-usbst@geggus.net&gt;
  * This encrypted pen drive returns bogus data for the initial READ(10).
  */
<span class="p_header">diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c</span>
<span class="p_header">index be32b1b..738707a 100644</span>
<span class="p_header">--- a/drivers/vhost/vhost.c</span>
<span class="p_header">+++ b/drivers/vhost/vhost.c</span>
<span class="p_chunk">@@ -883,6 +883,7 @@</span> <span class="p_context"> long vhost_dev_ioctl(struct vhost_dev *d, unsigned int ioctl, unsigned long arg)</span>
 		}
 		if (eventfp != d-&gt;log_file) {
 			filep = d-&gt;log_file;
<span class="p_add">+			d-&gt;log_file = eventfp;</span>
 			ctx = d-&gt;log_ctx;
 			d-&gt;log_ctx = eventfp ?
 				eventfd_ctx_fileget(eventfp) : NULL;
<span class="p_header">diff --git a/drivers/watchdog/omap_wdt.c b/drivers/watchdog/omap_wdt.c</span>
<span class="p_header">index 2b4acb8..8a93753 100644</span>
<span class="p_header">--- a/drivers/watchdog/omap_wdt.c</span>
<span class="p_header">+++ b/drivers/watchdog/omap_wdt.c</span>
<span class="p_chunk">@@ -150,6 +150,13 @@</span> <span class="p_context"> static int omap_wdt_open(struct inode *inode, struct file *file)</span>
 
 	pm_runtime_get_sync(wdev-&gt;dev);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Make sure the watchdog is disabled. This is unfortunately required</span>
<span class="p_add">+	 * because writing to various registers with the watchdog running has no</span>
<span class="p_add">+	 * effect.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	omap_wdt_disable(wdev);</span>
<span class="p_add">+</span>
 	/* initialize prescaler */
 	while (__raw_readl(base + OMAP_WATCHDOG_WPS) &amp; 0x01)
 		cpu_relax();
<span class="p_header">diff --git a/fs/9p/vfs_inode.c b/fs/9p/vfs_inode.c</span>
<span class="p_header">index 879ed88..bf1df72 100644</span>
<span class="p_header">--- a/fs/9p/vfs_inode.c</span>
<span class="p_header">+++ b/fs/9p/vfs_inode.c</span>
<span class="p_chunk">@@ -527,8 +527,7 @@</span> <span class="p_context"> static struct inode *v9fs_qid_iget(struct super_block *sb,</span>
 	unlock_new_inode(inode);
 	return inode;
 error:
<span class="p_del">-	unlock_new_inode(inode);</span>
<span class="p_del">-	iput(inode);</span>
<span class="p_add">+	iget_failed(inode);</span>
 	return ERR_PTR(retval);
 
 }
<span class="p_header">diff --git a/fs/9p/vfs_inode_dotl.c b/fs/9p/vfs_inode_dotl.c</span>
<span class="p_header">index 30d4fa8..dbbc83f 100644</span>
<span class="p_header">--- a/fs/9p/vfs_inode_dotl.c</span>
<span class="p_header">+++ b/fs/9p/vfs_inode_dotl.c</span>
<span class="p_chunk">@@ -169,8 +169,7 @@</span> <span class="p_context"> static struct inode *v9fs_qid_iget_dotl(struct super_block *sb,</span>
 	unlock_new_inode(inode);
 	return inode;
 error:
<span class="p_del">-	unlock_new_inode(inode);</span>
<span class="p_del">-	iput(inode);</span>
<span class="p_add">+	iget_failed(inode);</span>
 	return ERR_PTR(retval);
 
 }
<span class="p_header">diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c</span>
<span class="p_header">index a1fee6f..b3d1efe 100644</span>
<span class="p_header">--- a/fs/btrfs/inode-map.c</span>
<span class="p_header">+++ b/fs/btrfs/inode-map.c</span>
<span class="p_chunk">@@ -244,6 +244,7 @@</span> <span class="p_context"> void btrfs_unpin_free_ino(struct btrfs_root *root)</span>
 {
 	struct btrfs_free_space_ctl *ctl = root-&gt;free_ino_ctl;
 	struct rb_root *rbroot = &amp;root-&gt;free_ino_pinned-&gt;free_space_offset;
<span class="p_add">+	spinlock_t *rbroot_lock = &amp;root-&gt;free_ino_pinned-&gt;tree_lock;</span>
 	struct btrfs_free_space *info;
 	struct rb_node *n;
 	u64 count;
<span class="p_chunk">@@ -252,24 +253,30 @@</span> <span class="p_context"> void btrfs_unpin_free_ino(struct btrfs_root *root)</span>
 		return;
 
 	while (1) {
<span class="p_add">+		bool add_to_ctl = true;</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock(rbroot_lock);</span>
 		n = rb_first(rbroot);
<span class="p_del">-		if (!n)</span>
<span class="p_add">+		if (!n) {</span>
<span class="p_add">+			spin_unlock(rbroot_lock);</span>
 			break;
<span class="p_add">+		}</span>
 
 		info = rb_entry(n, struct btrfs_free_space, offset_index);
 		BUG_ON(info-&gt;bitmap);
 
 		if (info-&gt;offset &gt; root-&gt;cache_progress)
<span class="p_del">-			goto free;</span>
<span class="p_add">+			add_to_ctl = false;</span>
 		else if (info-&gt;offset + info-&gt;bytes &gt; root-&gt;cache_progress)
 			count = root-&gt;cache_progress - info-&gt;offset + 1;
 		else
 			count = info-&gt;bytes;
 
<span class="p_del">-		__btrfs_add_free_space(ctl, info-&gt;offset, count);</span>
<span class="p_del">-free:</span>
 		rb_erase(&amp;info-&gt;offset_index, rbroot);
<span class="p_del">-		kfree(info);</span>
<span class="p_add">+		spin_unlock(rbroot_lock);</span>
<span class="p_add">+		if (add_to_ctl)</span>
<span class="p_add">+			__btrfs_add_free_space(ctl, info-&gt;offset, count);</span>
<span class="p_add">+		kmem_cache_free(btrfs_free_space_cachep, info);</span>
 	}
 }
 
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index 52bacff..ba26540 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -2448,6 +2448,20 @@</span> <span class="p_context"> static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,</span>
 					new_key.offset += skip;
 				}
 
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Don&#39;t copy an inline extent into an offset</span>
<span class="p_add">+				 * greater than zero. Having an inline extent</span>
<span class="p_add">+				 * at such an offset results in chaos as btrfs</span>
<span class="p_add">+				 * isn&#39;t prepared for such cases. Just skip</span>
<span class="p_add">+				 * this case for the same reasons as commented</span>
<span class="p_add">+				 * at btrfs_ioctl_clone().</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				if (new_key.offset &gt; 0) {</span>
<span class="p_add">+					ret = -EOPNOTSUPP;</span>
<span class="p_add">+					btrfs_end_transaction(trans, root);</span>
<span class="p_add">+					goto out;</span>
<span class="p_add">+				}</span>
<span class="p_add">+</span>
 				if (key.offset + datal &gt; off+len)
 					trim = key.offset + datal - (off+len);
 
<span class="p_header">diff --git a/fs/buffer.c b/fs/buffer.c</span>
<span class="p_header">index c457f84..7eb4da4 100644</span>
<span class="p_header">--- a/fs/buffer.c</span>
<span class="p_header">+++ b/fs/buffer.c</span>
<span class="p_chunk">@@ -1002,7 +1002,7 @@</span> <span class="p_context"> init_page_buffers(struct page *page, struct block_device *bdev,</span>
  */
 static int
 grow_dev_page(struct block_device *bdev, sector_t block,
<span class="p_del">-		pgoff_t index, int size, int sizebits)</span>
<span class="p_add">+	      pgoff_t index, int size, int sizebits, gfp_t gfp)</span>
 {
 	struct inode *inode = bdev-&gt;bd_inode;
 	struct page *page;
<span class="p_chunk">@@ -1011,7 +1011,7 @@</span> <span class="p_context"> grow_dev_page(struct block_device *bdev, sector_t block,</span>
 	int ret = 0;		/* Will call free_more_memory() */
 
 	page = find_or_create_page(inode-&gt;i_mapping, index,
<span class="p_del">-		(mapping_gfp_mask(inode-&gt;i_mapping) &amp; ~__GFP_FS)|__GFP_MOVABLE);</span>
<span class="p_add">+		(mapping_gfp_mask(inode-&gt;i_mapping) &amp; ~__GFP_FS) | gfp);</span>
 	if (!page)
 		return ret;
 
<span class="p_chunk">@@ -1059,7 +1059,7 @@</span> <span class="p_context"> failed:</span>
  * that page was dirty, the buffers are set dirty also.
  */
 static int
<span class="p_del">-grow_buffers(struct block_device *bdev, sector_t block, int size)</span>
<span class="p_add">+grow_buffers(struct block_device *bdev, sector_t block, int size, gfp_t gfp)</span>
 {
 	pgoff_t index;
 	int sizebits;
<span class="p_chunk">@@ -1086,11 +1086,12 @@</span> <span class="p_context"> grow_buffers(struct block_device *bdev, sector_t block, int size)</span>
 	}
 
 	/* Create a page with the proper size buffers.. */
<span class="p_del">-	return grow_dev_page(bdev, block, index, size, sizebits);</span>
<span class="p_add">+	return grow_dev_page(bdev, block, index, size, sizebits, gfp);</span>
 }
 
<span class="p_del">-static struct buffer_head *</span>
<span class="p_del">-__getblk_slow(struct block_device *bdev, sector_t block, int size)</span>
<span class="p_add">+struct buffer_head *</span>
<span class="p_add">+__getblk_slow(struct block_device *bdev, sector_t block,</span>
<span class="p_add">+	     unsigned size, gfp_t gfp)</span>
 {
 	/* Size must be multiple of hard sectorsize */
 	if (unlikely(size &amp; (bdev_logical_block_size(bdev)-1) ||
<span class="p_chunk">@@ -1112,13 +1113,14 @@</span> <span class="p_context"> __getblk_slow(struct block_device *bdev, sector_t block, int size)</span>
 		if (bh)
 			return bh;
 
<span class="p_del">-		ret = grow_buffers(bdev, block, size);</span>
<span class="p_add">+		ret = grow_buffers(bdev, block, size, gfp);</span>
 		if (ret &lt; 0)
 			return NULL;
 		if (ret == 0)
 			free_more_memory();
 	}
 }
<span class="p_add">+EXPORT_SYMBOL(__getblk_slow);</span>
 
 /*
  * The relationship between dirty buffers and dirty pages:
<span class="p_chunk">@@ -1369,24 +1371,25 @@</span> <span class="p_context"> __find_get_block(struct block_device *bdev, sector_t block, unsigned size)</span>
 EXPORT_SYMBOL(__find_get_block);
 
 /*
<span class="p_del">- * __getblk will locate (and, if necessary, create) the buffer_head</span>
<span class="p_add">+ * __getblk_gfp() will locate (and, if necessary, create) the buffer_head</span>
  * which corresponds to the passed block_device, block and size. The
  * returned buffer has its reference count incremented.
  *
<span class="p_del">- * __getblk() will lock up the machine if grow_dev_page&#39;s try_to_free_buffers()</span>
<span class="p_del">- * attempt is failing.  FIXME, perhaps?</span>
<span class="p_add">+ * __getblk_gfp() will lock up the machine if grow_dev_page&#39;s</span>
<span class="p_add">+ * try_to_free_buffers() attempt is failing.  FIXME, perhaps?</span>
  */
 struct buffer_head *
<span class="p_del">-__getblk(struct block_device *bdev, sector_t block, unsigned size)</span>
<span class="p_add">+__getblk_gfp(struct block_device *bdev, sector_t block,</span>
<span class="p_add">+	     unsigned size, gfp_t gfp)</span>
 {
 	struct buffer_head *bh = __find_get_block(bdev, block, size);
 
 	might_sleep();
 	if (bh == NULL)
<span class="p_del">-		bh = __getblk_slow(bdev, block, size);</span>
<span class="p_add">+		bh = __getblk_slow(bdev, block, size, gfp);</span>
 	return bh;
 }
<span class="p_del">-EXPORT_SYMBOL(__getblk);</span>
<span class="p_add">+EXPORT_SYMBOL(__getblk_gfp);</span>
 
 /*
  * Do async read-ahead on a buffer..
<span class="p_chunk">@@ -1402,24 +1405,28 @@</span> <span class="p_context"> void __breadahead(struct block_device *bdev, sector_t block, unsigned size)</span>
 EXPORT_SYMBOL(__breadahead);
 
 /**
<span class="p_del">- *  __bread() - reads a specified block and returns the bh</span>
<span class="p_add">+ *  __bread_gfp() - reads a specified block and returns the bh</span>
  *  @bdev: the block_device to read from
  *  @block: number of block
  *  @size: size (in bytes) to read
<span class="p_del">- * </span>
<span class="p_add">+ *  @gfp: page allocation flag</span>
<span class="p_add">+ *</span>
  *  Reads a specified block, and returns buffer head that contains it.
<span class="p_add">+ *  The page cache can be allocated from non-movable area</span>
<span class="p_add">+ *  not to prevent page migration if you set gfp to zero.</span>
  *  It returns NULL if the block was unreadable.
  */
 struct buffer_head *
<span class="p_del">-__bread(struct block_device *bdev, sector_t block, unsigned size)</span>
<span class="p_add">+__bread_gfp(struct block_device *bdev, sector_t block,</span>
<span class="p_add">+		   unsigned size, gfp_t gfp)</span>
 {
<span class="p_del">-	struct buffer_head *bh = __getblk(bdev, block, size);</span>
<span class="p_add">+	struct buffer_head *bh = __getblk_gfp(bdev, block, size, gfp);</span>
 
 	if (likely(bh) &amp;&amp; !buffer_uptodate(bh))
 		bh = __bread_slow(bh);
 	return bh;
 }
<span class="p_del">-EXPORT_SYMBOL(__bread);</span>
<span class="p_add">+EXPORT_SYMBOL(__bread_gfp);</span>
 
 /*
  * invalidate_bh_lrus() is called rarely - but not only at unmount.
<span class="p_header">diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c</span>
<span class="p_header">index 2da63ab..e3d65ab 100644</span>
<span class="p_header">--- a/fs/ext4/extents.c</span>
<span class="p_header">+++ b/fs/ext4/extents.c</span>
<span class="p_chunk">@@ -700,7 +700,8 @@</span> <span class="p_context"> ext4_ext_find_extent(struct inode *inode, ext4_lblk_t block,</span>
 		path[ppos].p_depth = i;
 		path[ppos].p_ext = NULL;
 
<span class="p_del">-		bh = sb_getblk(inode-&gt;i_sb, path[ppos].p_block);</span>
<span class="p_add">+		bh = sb_getblk_gfp(inode-&gt;i_sb, path[ppos].p_block,</span>
<span class="p_add">+				   __GFP_MOVABLE | GFP_NOFS);</span>
 		if (unlikely(!bh)) {
 			ret = -ENOMEM;
 			goto err;
<span class="p_chunk">@@ -905,7 +906,7 @@</span> <span class="p_context"> static int ext4_ext_split(handle_t *handle, struct inode *inode,</span>
 		err = -EIO;
 		goto cleanup;
 	}
<span class="p_del">-	bh = sb_getblk(inode-&gt;i_sb, newblock);</span>
<span class="p_add">+	bh = sb_getblk_gfp(inode-&gt;i_sb, newblock, __GFP_MOVABLE | GFP_NOFS);</span>
 	if (!bh) {
 		err = -ENOMEM;
 		goto cleanup;
<span class="p_chunk">@@ -1089,7 +1090,7 @@</span> <span class="p_context"> static int ext4_ext_grow_indepth(handle_t *handle, struct inode *inode,</span>
 	if (newblock == 0)
 		return err;
 
<span class="p_del">-	bh = sb_getblk(inode-&gt;i_sb, newblock);</span>
<span class="p_add">+	bh = sb_getblk_gfp(inode-&gt;i_sb, newblock, __GFP_MOVABLE | GFP_NOFS);</span>
 	if (!bh)
 		return -ENOMEM;
 	lock_buffer(bh);
<span class="p_header">diff --git a/fs/ext4/indirect.c b/fs/ext4/indirect.c</span>
<span class="p_header">index 26d6dbf..ae1425a 100644</span>
<span class="p_header">--- a/fs/ext4/indirect.c</span>
<span class="p_header">+++ b/fs/ext4/indirect.c</span>
<span class="p_chunk">@@ -706,7 +706,7 @@</span> <span class="p_context"> int ext4_ind_map_blocks(handle_t *handle, struct inode *inode,</span>
 				       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {
 		EXT4_ERROR_INODE(inode, &quot;Can&#39;t allocate blocks for &quot;
 				 &quot;non-extent mapped inodes with bigalloc&quot;);
<span class="p_del">-		return -ENOSPC;</span>
<span class="p_add">+		return -EUCLEAN;</span>
 	}
 
 	goal = ext4_find_goal(inode, map-&gt;m_lblk, partial);
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index f06857b..0610766 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -1849,18 +1849,31 @@</span> <span class="p_context"> static int __ext4_journalled_writepage(struct page *page,</span>
 	page_bufs = page_buffers(page);
 	BUG_ON(!page_bufs);
 	walk_page_buffers(handle, page_bufs, 0, len, NULL, bget_one);
<span class="p_del">-	/* As soon as we unlock the page, it can go away, but we have</span>
<span class="p_del">-	 * references to buffers so we are safe */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to release the page lock before we start the</span>
<span class="p_add">+	 * journal, so grab a reference so the page won&#39;t disappear</span>
<span class="p_add">+	 * out from under us.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	get_page(page);</span>
 	unlock_page(page);
 
 	handle = ext4_journal_start(inode, ext4_writepage_trans_blocks(inode));
 	if (IS_ERR(handle)) {
 		ret = PTR_ERR(handle);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		put_page(page);</span>
<span class="p_add">+		goto out_no_pagelock;</span>
 	}
<span class="p_del">-</span>
 	BUG_ON(!ext4_handle_valid(handle));
 
<span class="p_add">+	lock_page(page);</span>
<span class="p_add">+	put_page(page);</span>
<span class="p_add">+	if (page-&gt;mapping != mapping) {</span>
<span class="p_add">+		/* The page got truncated from under us */</span>
<span class="p_add">+		ext4_journal_stop(handle);</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ret = walk_page_buffers(handle, page_bufs, 0, len, NULL,
 				do_journal_get_write_access);
 
<span class="p_chunk">@@ -1876,6 +1889,8 @@</span> <span class="p_context"> static int __ext4_journalled_writepage(struct page *page,</span>
 	walk_page_buffers(handle, page_bufs, 0, len, NULL, bput_one);
 	ext4_set_inode_state(inode, EXT4_STATE_JDATA);
 out:
<span class="p_add">+	unlock_page(page);</span>
<span class="p_add">+out_no_pagelock:</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c</span>
<span class="p_header">index 5baa7ba..7c03826 100644</span>
<span class="p_header">--- a/fs/ext4/mballoc.c</span>
<span class="p_header">+++ b/fs/ext4/mballoc.c</span>
<span class="p_chunk">@@ -4720,18 +4720,12 @@</span> <span class="p_context"> do_more:</span>
 		/*
 		 * blocks being freed are metadata. these blocks shouldn&#39;t
 		 * be used until this transaction is committed
<span class="p_add">+		 *</span>
<span class="p_add">+		 * We use __GFP_NOFAIL because ext4_free_blocks() is not allowed</span>
<span class="p_add">+		 * to fail.</span>
 		 */
<span class="p_del">-	retry:</span>
<span class="p_del">-		new_entry = kmem_cache_alloc(ext4_free_ext_cachep, GFP_NOFS);</span>
<span class="p_del">-		if (!new_entry) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * We use a retry loop because</span>
<span class="p_del">-			 * ext4_free_blocks() is not allowed to fail.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			cond_resched();</span>
<span class="p_del">-			congestion_wait(BLK_RW_ASYNC, HZ/50);</span>
<span class="p_del">-			goto retry;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		new_entry = kmem_cache_alloc(ext4_free_ext_cachep,</span>
<span class="p_add">+				GFP_NOFS|__GFP_NOFAIL);</span>
 		new_entry-&gt;start_cluster = bit;
 		new_entry-&gt;group  = block_group;
 		new_entry-&gt;count = count_clusters;
<span class="p_header">diff --git a/fs/ext4/super.c b/fs/ext4/super.c</span>
<span class="p_header">index 422be11..be4db0e 100644</span>
<span class="p_header">--- a/fs/ext4/super.c</span>
<span class="p_header">+++ b/fs/ext4/super.c</span>
<span class="p_chunk">@@ -857,6 +857,7 @@</span> <span class="p_context"> static void ext4_put_super(struct super_block *sb)</span>
 		dump_orphan_list(sb, sbi);
 	J_ASSERT(list_empty(&amp;sbi-&gt;s_orphan));
 
<span class="p_add">+	sync_blockdev(sb-&gt;s_bdev);</span>
 	invalidate_bdev(sb-&gt;s_bdev);
 	if (sbi-&gt;journal_bdev &amp;&amp; sbi-&gt;journal_bdev != sb-&gt;s_bdev) {
 		/*
<span class="p_header">diff --git a/fs/fuse/inode.c b/fs/fuse/inode.c</span>
<span class="p_header">index afc0f706..e613870 100644</span>
<span class="p_header">--- a/fs/fuse/inode.c</span>
<span class="p_header">+++ b/fs/fuse/inode.c</span>
<span class="p_chunk">@@ -993,6 +993,7 @@</span> <span class="p_context"> static int fuse_fill_super(struct super_block *sb, void *data, int silent)</span>
 		goto err_fput;
 
 	fuse_conn_init(fc);
<span class="p_add">+	fc-&gt;release = fuse_free_conn;</span>
 
 	fc-&gt;dev = sb-&gt;s_dev;
 	fc-&gt;sb = sb;
<span class="p_chunk">@@ -1007,7 +1008,6 @@</span> <span class="p_context"> static int fuse_fill_super(struct super_block *sb, void *data, int silent)</span>
 		fc-&gt;dont_mask = 1;
 	sb-&gt;s_flags |= MS_POSIXACL;
 
<span class="p_del">-	fc-&gt;release = fuse_free_conn;</span>
 	fc-&gt;flags = d.flags;
 	fc-&gt;user_id = d.user_id;
 	fc-&gt;group_id = d.group_id;
<span class="p_header">diff --git a/fs/jbd2/checkpoint.c b/fs/jbd2/checkpoint.c</span>
<span class="p_header">index 16a698b..39c7059 100644</span>
<span class="p_header">--- a/fs/jbd2/checkpoint.c</span>
<span class="p_header">+++ b/fs/jbd2/checkpoint.c</span>
<span class="p_chunk">@@ -478,80 +478,28 @@</span> <span class="p_context"> out:</span>
 
 int jbd2_cleanup_journal_tail(journal_t *journal)
 {
<span class="p_del">-	transaction_t * transaction;</span>
 	tid_t		first_tid;
<span class="p_del">-	unsigned long	blocknr, freed;</span>
<span class="p_add">+	unsigned long	blocknr;</span>
 
 	if (is_journal_aborted(journal))
<span class="p_del">-		return 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* OK, work out the oldest transaction remaining in the log, and</span>
<span class="p_del">-	 * the log block it starts at.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * If the log is now empty, we need to work out which is the</span>
<span class="p_del">-	 * next transaction ID we will write, and where it will</span>
<span class="p_del">-	 * start. */</span>
<span class="p_add">+		return -EIO;</span>
 
<span class="p_del">-	write_lock(&amp;journal-&gt;j_state_lock);</span>
<span class="p_del">-	spin_lock(&amp;journal-&gt;j_list_lock);</span>
<span class="p_del">-	transaction = journal-&gt;j_checkpoint_transactions;</span>
<span class="p_del">-	if (transaction) {</span>
<span class="p_del">-		first_tid = transaction-&gt;t_tid;</span>
<span class="p_del">-		blocknr = transaction-&gt;t_log_start;</span>
<span class="p_del">-	} else if ((transaction = journal-&gt;j_committing_transaction) != NULL) {</span>
<span class="p_del">-		first_tid = transaction-&gt;t_tid;</span>
<span class="p_del">-		blocknr = transaction-&gt;t_log_start;</span>
<span class="p_del">-	} else if ((transaction = journal-&gt;j_running_transaction) != NULL) {</span>
<span class="p_del">-		first_tid = transaction-&gt;t_tid;</span>
<span class="p_del">-		blocknr = journal-&gt;j_head;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		first_tid = journal-&gt;j_transaction_sequence;</span>
<span class="p_del">-		blocknr = journal-&gt;j_head;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	spin_unlock(&amp;journal-&gt;j_list_lock);</span>
<span class="p_del">-	J_ASSERT(blocknr != 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If the oldest pinned transaction is at the tail of the log</span>
<span class="p_del">-           already then there&#39;s not much we can do right now. */</span>
<span class="p_del">-	if (journal-&gt;j_tail_sequence == first_tid) {</span>
<span class="p_del">-		write_unlock(&amp;journal-&gt;j_state_lock);</span>
<span class="p_add">+	if (!jbd2_journal_get_log_tail(journal, &amp;first_tid, &amp;blocknr))</span>
 		return 1;
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* OK, update the superblock to recover the freed space.</span>
<span class="p_del">-	 * Physical blocks come first: have we wrapped beyond the end of</span>
<span class="p_del">-	 * the log?  */</span>
<span class="p_del">-	freed = blocknr - journal-&gt;j_tail;</span>
<span class="p_del">-	if (blocknr &lt; journal-&gt;j_tail)</span>
<span class="p_del">-		freed = freed + journal-&gt;j_last - journal-&gt;j_first;</span>
<span class="p_del">-</span>
<span class="p_del">-	trace_jbd2_cleanup_journal_tail(journal, first_tid, blocknr, freed);</span>
<span class="p_del">-	jbd_debug(1,</span>
<span class="p_del">-		  &quot;Cleaning journal tail from %d to %d (offset %lu), &quot;</span>
<span class="p_del">-		  &quot;freeing %lu\n&quot;,</span>
<span class="p_del">-		  journal-&gt;j_tail_sequence, first_tid, blocknr, freed);</span>
<span class="p_del">-</span>
<span class="p_del">-	journal-&gt;j_free += freed;</span>
<span class="p_del">-	journal-&gt;j_tail_sequence = first_tid;</span>
<span class="p_del">-	journal-&gt;j_tail = blocknr;</span>
<span class="p_del">-	write_unlock(&amp;journal-&gt;j_state_lock);</span>
<span class="p_add">+	J_ASSERT(blocknr != 0);</span>
 
 	/*
<span class="p_del">-	 * If there is an external journal, we need to make sure that</span>
<span class="p_del">-	 * any data blocks that were recently written out --- perhaps</span>
<span class="p_del">-	 * by jbd2_log_do_checkpoint() --- are flushed out before we</span>
<span class="p_del">-	 * drop the transactions from the external journal.  It&#39;s</span>
<span class="p_del">-	 * unlikely this will be necessary, especially with a</span>
<span class="p_del">-	 * appropriately sized journal, but we need this to guarantee</span>
<span class="p_del">-	 * correctness.  Fortunately jbd2_cleanup_journal_tail()</span>
<span class="p_del">-	 * doesn&#39;t get called all that often.</span>
<span class="p_add">+	 * We need to make sure that any blocks that were recently written out</span>
<span class="p_add">+	 * --- perhaps by jbd2_log_do_checkpoint() --- are flushed out before</span>
<span class="p_add">+	 * we drop the transactions from the journal. It&#39;s unlikely this will</span>
<span class="p_add">+	 * be necessary, especially with an appropriately sized journal, but we</span>
<span class="p_add">+	 * need this to guarantee correctness.  Fortunately</span>
<span class="p_add">+	 * jbd2_cleanup_journal_tail() doesn&#39;t get called all that often.</span>
 	 */
<span class="p_del">-	if ((journal-&gt;j_fs_dev != journal-&gt;j_dev) &amp;&amp;</span>
<span class="p_del">-	    (journal-&gt;j_flags &amp; JBD2_BARRIER))</span>
<span class="p_del">-		blkdev_issue_flush(journal-&gt;j_fs_dev, GFP_KERNEL, NULL);</span>
<span class="p_del">-	if (!(journal-&gt;j_flags &amp; JBD2_ABORT))</span>
<span class="p_del">-		jbd2_journal_update_superblock(journal, 1);</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	if (journal-&gt;j_flags &amp; JBD2_BARRIER)</span>
<span class="p_add">+		blkdev_issue_flush(journal-&gt;j_fs_dev, GFP_NOFS, NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	return __jbd2_update_log_tail(journal, first_tid, blocknr);</span>
 }
 
 
<span class="p_header">diff --git a/fs/jbd2/commit.c b/fs/jbd2/commit.c</span>
<span class="p_header">index ab9463a..bccb605 100644</span>
<span class="p_header">--- a/fs/jbd2/commit.c</span>
<span class="p_header">+++ b/fs/jbd2/commit.c</span>
<span class="p_chunk">@@ -340,7 +340,16 @@</span> <span class="p_context"> void jbd2_journal_commit_transaction(journal_t *journal)</span>
 	/* Do we need to erase the effects of a prior jbd2_journal_flush? */
 	if (journal-&gt;j_flags &amp; JBD2_FLUSHED) {
 		jbd_debug(3, &quot;super block updated\n&quot;);
<span class="p_del">-		jbd2_journal_update_superblock(journal, 1);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We hold j_checkpoint_mutex so tail cannot change under us.</span>
<span class="p_add">+		 * We don&#39;t need any special data guarantees for writing sb</span>
<span class="p_add">+		 * since journal is empty and it is ok for write to be</span>
<span class="p_add">+		 * flushed only with transaction commit.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		jbd2_journal_update_sb_log_tail(journal,</span>
<span class="p_add">+						journal-&gt;j_tail_sequence,</span>
<span class="p_add">+						journal-&gt;j_tail,</span>
<span class="p_add">+						WRITE_SYNC);</span>
 	} else {
 		jbd_debug(3, &quot;superblock not updated\n&quot;);
 	}
<span class="p_header">diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c</span>
<span class="p_header">index 17b04fc..9532dac 100644</span>
<span class="p_header">--- a/fs/jbd2/journal.c</span>
<span class="p_header">+++ b/fs/jbd2/journal.c</span>
<span class="p_chunk">@@ -775,6 +775,92 @@</span> <span class="p_context"> struct journal_head *jbd2_journal_get_descriptor_buffer(journal_t *journal)</span>
 	return jbd2_journal_add_journal_head(bh);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Return tid of the oldest transaction in the journal and block in the journal</span>
<span class="p_add">+ * where the transaction starts.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * If the journal is now empty, return which will be the next transaction ID</span>
<span class="p_add">+ * we will write and where will that transaction start.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The return value is 0 if journal tail cannot be pushed any further, 1 if</span>
<span class="p_add">+ * it can.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,</span>
<span class="p_add">+			      unsigned long *block)</span>
<span class="p_add">+{</span>
<span class="p_add">+	transaction_t *transaction;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	read_lock(&amp;journal-&gt;j_state_lock);</span>
<span class="p_add">+	spin_lock(&amp;journal-&gt;j_list_lock);</span>
<span class="p_add">+	transaction = journal-&gt;j_checkpoint_transactions;</span>
<span class="p_add">+	if (transaction) {</span>
<span class="p_add">+		*tid = transaction-&gt;t_tid;</span>
<span class="p_add">+		*block = transaction-&gt;t_log_start;</span>
<span class="p_add">+	} else if ((transaction = journal-&gt;j_committing_transaction) != NULL) {</span>
<span class="p_add">+		*tid = transaction-&gt;t_tid;</span>
<span class="p_add">+		*block = transaction-&gt;t_log_start;</span>
<span class="p_add">+	} else if ((transaction = journal-&gt;j_running_transaction) != NULL) {</span>
<span class="p_add">+		*tid = transaction-&gt;t_tid;</span>
<span class="p_add">+		*block = journal-&gt;j_head;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		*tid = journal-&gt;j_transaction_sequence;</span>
<span class="p_add">+		*block = journal-&gt;j_head;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	ret = tid_gt(*tid, journal-&gt;j_tail_sequence);</span>
<span class="p_add">+	spin_unlock(&amp;journal-&gt;j_list_lock);</span>
<span class="p_add">+	read_unlock(&amp;journal-&gt;j_state_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Update information in journal structure and in on disk journal superblock</span>
<span class="p_add">+ * about log tail. This function does not check whether information passed in</span>
<span class="p_add">+ * really pushes log tail further. It&#39;s responsibility of the caller to make</span>
<span class="p_add">+ * sure provided log tail information is valid (e.g. by holding</span>
<span class="p_add">+ * j_checkpoint_mutex all the time between computing log tail and calling this</span>
<span class="p_add">+ * function as is the case with jbd2_cleanup_journal_tail()).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Requires j_checkpoint_mutex</span>
<span class="p_add">+ */</span>
<span class="p_add">+int __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long freed;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(!mutex_is_locked(&amp;journal-&gt;j_checkpoint_mutex));</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We cannot afford for write to remain in drive&#39;s caches since as</span>
<span class="p_add">+	 * soon as we update j_tail, next transaction can start reusing journal</span>
<span class="p_add">+	 * space and if we lose sb update during power failure we&#39;d replay</span>
<span class="p_add">+	 * old transaction with possibly newly overwritten data.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ret = jbd2_journal_update_sb_log_tail(journal, tid, block, WRITE_FUA);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	write_lock(&amp;journal-&gt;j_state_lock);</span>
<span class="p_add">+	freed = block - journal-&gt;j_tail;</span>
<span class="p_add">+	if (block &lt; journal-&gt;j_tail)</span>
<span class="p_add">+		freed += journal-&gt;j_last - journal-&gt;j_first;</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_jbd2_update_log_tail(journal, tid, block, freed);</span>
<span class="p_add">+	jbd_debug(1,</span>
<span class="p_add">+		  &quot;Cleaning journal tail from %d to %d (offset %lu), &quot;</span>
<span class="p_add">+		  &quot;freeing %lu\n&quot;,</span>
<span class="p_add">+		  journal-&gt;j_tail_sequence, tid, block, freed);</span>
<span class="p_add">+</span>
<span class="p_add">+	journal-&gt;j_free += freed;</span>
<span class="p_add">+	journal-&gt;j_tail_sequence = tid;</span>
<span class="p_add">+	journal-&gt;j_tail = block;</span>
<span class="p_add">+	write_unlock(&amp;journal-&gt;j_state_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct jbd2_stats_proc_session {
 	journal_t *journal;
 	struct transaction_stats_s *stats;
<span class="p_chunk">@@ -1143,40 +1229,41 @@</span> <span class="p_context"> static int journal_reset(journal_t *journal)</span>
 
 	journal-&gt;j_max_transaction_buffers = journal-&gt;j_maxlen / 4;
 
<span class="p_del">-	/* Add the dynamic fields and write it to disk. */</span>
<span class="p_del">-	jbd2_journal_update_superblock(journal, 1);</span>
<span class="p_del">-	return jbd2_journal_start_thread(journal);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * void jbd2_journal_update_superblock() - Update journal sb on disk.</span>
<span class="p_del">- * @journal: The journal to update.</span>
<span class="p_del">- * @wait: Set to &#39;0&#39; if you don&#39;t want to wait for IO completion.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Update a journal&#39;s dynamic superblock fields and write it to disk,</span>
<span class="p_del">- * optionally waiting for the IO to complete.</span>
<span class="p_del">- */</span>
<span class="p_del">-void jbd2_journal_update_superblock(journal_t *journal, int wait)</span>
<span class="p_del">-{</span>
<span class="p_del">-	journal_superblock_t *sb = journal-&gt;j_superblock;</span>
<span class="p_del">-	struct buffer_head *bh = journal-&gt;j_sb_buffer;</span>
<span class="p_del">-</span>
 	/*
 	 * As a special case, if the on-disk copy is already marked as needing
<span class="p_del">-	 * no recovery (s_start == 0) and there are no outstanding transactions</span>
<span class="p_del">-	 * in the filesystem, then we can safely defer the superblock update</span>
<span class="p_del">-	 * until the next commit by setting JBD2_FLUSHED.  This avoids</span>
<span class="p_add">+	 * no recovery (s_start == 0), then we can safely defer the superblock</span>
<span class="p_add">+	 * update until the next commit by setting JBD2_FLUSHED.  This avoids</span>
 	 * attempting a write to a potential-readonly device.
 	 */
<span class="p_del">-	if (sb-&gt;s_start == 0 &amp;&amp; journal-&gt;j_tail_sequence ==</span>
<span class="p_del">-				journal-&gt;j_transaction_sequence) {</span>
<span class="p_add">+	if (sb-&gt;s_start == 0) {</span>
 		jbd_debug(1, &quot;JBD2: Skipping superblock update on recovered sb &quot;
 			&quot;(start %ld, seq %d, errno %d)\n&quot;,
 			journal-&gt;j_tail, journal-&gt;j_tail_sequence,
 			journal-&gt;j_errno);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		journal-&gt;j_flags |= JBD2_FLUSHED;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Update log tail information. We use WRITE_FUA since new</span>
<span class="p_add">+		 * transaction will start reusing journal space and so we</span>
<span class="p_add">+		 * must make sure information about current log tail is on</span>
<span class="p_add">+		 * disk before that.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		jbd2_journal_update_sb_log_tail(journal,</span>
<span class="p_add">+						journal-&gt;j_tail_sequence,</span>
<span class="p_add">+						journal-&gt;j_tail,</span>
<span class="p_add">+						WRITE_FUA);</span>
 	}
<span class="p_add">+	return jbd2_journal_start_thread(journal);</span>
<span class="p_add">+}</span>
 
<span class="p_add">+static int jbd2_write_superblock(journal_t *journal, int write_op)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct buffer_head *bh = journal-&gt;j_sb_buffer;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(journal-&gt;j_flags &amp; JBD2_BARRIER))</span>
<span class="p_add">+		write_op &amp;= ~(REQ_FUA | REQ_FLUSH);</span>
<span class="p_add">+	lock_buffer(bh);</span>
 	if (buffer_write_io_error(bh)) {
 		/*
 		 * Oh, dear.  A previous attempt to write the journal
<span class="p_chunk">@@ -1192,48 +1279,112 @@</span> <span class="p_context"> void jbd2_journal_update_superblock(journal_t *journal, int wait)</span>
 		clear_buffer_write_io_error(bh);
 		set_buffer_uptodate(bh);
 	}
<span class="p_add">+	get_bh(bh);</span>
<span class="p_add">+	bh-&gt;b_end_io = end_buffer_write_sync;</span>
<span class="p_add">+	ret = submit_bh(write_op, bh);</span>
<span class="p_add">+	wait_on_buffer(bh);</span>
<span class="p_add">+	if (buffer_write_io_error(bh)) {</span>
<span class="p_add">+		clear_buffer_write_io_error(bh);</span>
<span class="p_add">+		set_buffer_uptodate(bh);</span>
<span class="p_add">+		ret = -EIO;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		printk(KERN_ERR &quot;JBD2: Error %d detected when updating &quot;</span>
<span class="p_add">+		       &quot;journal superblock for %s.\n&quot;, ret,</span>
<span class="p_add">+		       journal-&gt;j_devname);</span>
<span class="p_add">+		jbd2_journal_abort(journal, ret);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * jbd2_journal_update_sb_log_tail() - Update log tail in journal sb on disk.</span>
<span class="p_add">+ * @journal: The journal to update.</span>
<span class="p_add">+ * @tail_tid: TID of the new transaction at the tail of the log</span>
<span class="p_add">+ * @tail_block: The first block of the transaction at the tail of the log</span>
<span class="p_add">+ * @write_op: With which operation should we write the journal sb</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Update a journal&#39;s superblock information about log tail and write it to</span>
<span class="p_add">+ * disk, waiting for the IO to complete.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,</span>
<span class="p_add">+				     unsigned long tail_block, int write_op)</span>
<span class="p_add">+{</span>
<span class="p_add">+	journal_superblock_t *sb = journal-&gt;j_superblock;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	jbd_debug(1, &quot;JBD2: updating superblock (start %lu, seq %u)\n&quot;,</span>
<span class="p_add">+		  tail_block, tail_tid);</span>
<span class="p_add">+</span>
<span class="p_add">+	sb-&gt;s_sequence = cpu_to_be32(tail_tid);</span>
<span class="p_add">+	sb-&gt;s_start    = cpu_to_be32(tail_block);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = jbd2_write_superblock(journal, write_op);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	/* Log is no longer empty */</span>
<span class="p_add">+	write_lock(&amp;journal-&gt;j_state_lock);</span>
<span class="p_add">+	WARN_ON(!sb-&gt;s_sequence);</span>
<span class="p_add">+	journal-&gt;j_flags &amp;= ~JBD2_FLUSHED;</span>
<span class="p_add">+	write_unlock(&amp;journal-&gt;j_state_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * jbd2_mark_journal_empty() - Mark on disk journal as empty.</span>
<span class="p_add">+ * @journal: The journal to update.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Update a journal&#39;s dynamic superblock fields to show that journal is empty.</span>
<span class="p_add">+ * Write updated superblock to disk waiting for IO to complete.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void jbd2_mark_journal_empty(journal_t *journal)</span>
<span class="p_add">+{</span>
<span class="p_add">+	journal_superblock_t *sb = journal-&gt;j_superblock;</span>
 
 	read_lock(&amp;journal-&gt;j_state_lock);
<span class="p_del">-	jbd_debug(1, &quot;JBD2: updating superblock (start %ld, seq %d, errno %d)\n&quot;,</span>
<span class="p_del">-		  journal-&gt;j_tail, journal-&gt;j_tail_sequence, journal-&gt;j_errno);</span>
<span class="p_add">+	jbd_debug(1, &quot;JBD2: Marking journal as empty (seq %d)\n&quot;,</span>
<span class="p_add">+		  journal-&gt;j_tail_sequence);</span>
 
 	sb-&gt;s_sequence = cpu_to_be32(journal-&gt;j_tail_sequence);
<span class="p_del">-	sb-&gt;s_start    = cpu_to_be32(journal-&gt;j_tail);</span>
<span class="p_del">-	sb-&gt;s_errno    = cpu_to_be32(journal-&gt;j_errno);</span>
<span class="p_add">+	sb-&gt;s_start    = cpu_to_be32(0);</span>
 	read_unlock(&amp;journal-&gt;j_state_lock);
 
<span class="p_del">-	BUFFER_TRACE(bh, &quot;marking dirty&quot;);</span>
<span class="p_del">-	mark_buffer_dirty(bh);</span>
<span class="p_del">-	if (wait) {</span>
<span class="p_del">-		sync_dirty_buffer(bh);</span>
<span class="p_del">-		if (buffer_write_io_error(bh)) {</span>
<span class="p_del">-			printk(KERN_ERR &quot;JBD2: I/O error detected &quot;</span>
<span class="p_del">-			       &quot;when updating journal superblock for %s.\n&quot;,</span>
<span class="p_del">-			       journal-&gt;j_devname);</span>
<span class="p_del">-			clear_buffer_write_io_error(bh);</span>
<span class="p_del">-			set_buffer_uptodate(bh);</span>
<span class="p_del">-		}</span>
<span class="p_del">-	} else</span>
<span class="p_del">-		write_dirty_buffer(bh, WRITE);</span>
<span class="p_del">-</span>
<span class="p_del">-out:</span>
<span class="p_del">-	/* If we have just flushed the log (by marking s_start==0), then</span>
<span class="p_del">-	 * any future commit will have to be careful to update the</span>
<span class="p_del">-	 * superblock again to re-record the true start of the log. */</span>
<span class="p_add">+	jbd2_write_superblock(journal, WRITE_FUA);</span>
 
<span class="p_add">+	/* Log is no longer empty */</span>
 	write_lock(&amp;journal-&gt;j_state_lock);
<span class="p_del">-	if (sb-&gt;s_start)</span>
<span class="p_del">-		journal-&gt;j_flags &amp;= ~JBD2_FLUSHED;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		journal-&gt;j_flags |= JBD2_FLUSHED;</span>
<span class="p_add">+	journal-&gt;j_flags |= JBD2_FLUSHED;</span>
 	write_unlock(&amp;journal-&gt;j_state_lock);
 }
 
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * jbd2_journal_update_sb_errno() - Update error in the journal.</span>
<span class="p_add">+ * @journal: The journal to update.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Update a journal&#39;s errno.  Write updated superblock to disk waiting for IO</span>
<span class="p_add">+ * to complete.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void jbd2_journal_update_sb_errno(journal_t *journal)</span>
<span class="p_add">+{</span>
<span class="p_add">+	journal_superblock_t *sb = journal-&gt;j_superblock;</span>
<span class="p_add">+</span>
<span class="p_add">+	read_lock(&amp;journal-&gt;j_state_lock);</span>
<span class="p_add">+	jbd_debug(1, &quot;JBD2: updating superblock error (errno %d)\n&quot;,</span>
<span class="p_add">+		  journal-&gt;j_errno);</span>
<span class="p_add">+	sb-&gt;s_errno    = cpu_to_be32(journal-&gt;j_errno);</span>
<span class="p_add">+	read_unlock(&amp;journal-&gt;j_state_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	jbd2_write_superblock(journal, WRITE_SYNC);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Read the superblock for a given journal, performing initial
  * validation of the format.
  */
<span class="p_del">-</span>
 static int journal_get_superblock(journal_t *journal)
 {
 	struct buffer_head *bh;
<span class="p_chunk">@@ -1426,15 +1577,10 @@</span> <span class="p_context"> int jbd2_journal_destroy(journal_t *journal)</span>
 	spin_unlock(&amp;journal-&gt;j_list_lock);
 
 	if (journal-&gt;j_sb_buffer) {
<span class="p_del">-		if (!is_journal_aborted(journal)) {</span>
<span class="p_del">-			/* We can now mark the journal as empty. */</span>
<span class="p_del">-			journal-&gt;j_tail = 0;</span>
<span class="p_del">-			journal-&gt;j_tail_sequence =</span>
<span class="p_del">-				++journal-&gt;j_transaction_sequence;</span>
<span class="p_del">-			jbd2_journal_update_superblock(journal, 1);</span>
<span class="p_del">-		} else {</span>
<span class="p_add">+		if (!is_journal_aborted(journal))</span>
<span class="p_add">+			jbd2_mark_journal_empty(journal);</span>
<span class="p_add">+		else</span>
 			err = -EIO;
<span class="p_del">-		}</span>
 		brelse(journal-&gt;j_sb_buffer);
 	}
 
<span class="p_chunk">@@ -1648,7 +1794,6 @@</span> <span class="p_context"> int jbd2_journal_flush(journal_t *journal)</span>
 {
 	int err = 0;
 	transaction_t *transaction = NULL;
<span class="p_del">-	unsigned long old_tail;</span>
 
 	write_lock(&amp;journal-&gt;j_state_lock);
 
<span class="p_chunk">@@ -1683,28 +1828,28 @@</span> <span class="p_context"> int jbd2_journal_flush(journal_t *journal)</span>
 	if (is_journal_aborted(journal))
 		return -EIO;
 
<span class="p_del">-	jbd2_cleanup_journal_tail(journal);</span>
<span class="p_add">+	if (!err) {</span>
<span class="p_add">+		err = jbd2_cleanup_journal_tail(journal);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		err = 0;</span>
<span class="p_add">+	}</span>
 
 	/* Finally, mark the journal as really needing no recovery.
 	 * This sets s_start==0 in the underlying superblock, which is
 	 * the magic code for a fully-recovered superblock.  Any future
 	 * commits of data to the journal will restore the current
 	 * s_start value. */
<span class="p_add">+	jbd2_mark_journal_empty(journal);</span>
 	write_lock(&amp;journal-&gt;j_state_lock);
<span class="p_del">-	old_tail = journal-&gt;j_tail;</span>
<span class="p_del">-	journal-&gt;j_tail = 0;</span>
<span class="p_del">-	write_unlock(&amp;journal-&gt;j_state_lock);</span>
<span class="p_del">-	jbd2_journal_update_superblock(journal, 1);</span>
<span class="p_del">-	write_lock(&amp;journal-&gt;j_state_lock);</span>
<span class="p_del">-	journal-&gt;j_tail = old_tail;</span>
<span class="p_del">-</span>
 	J_ASSERT(!journal-&gt;j_running_transaction);
 	J_ASSERT(!journal-&gt;j_committing_transaction);
 	J_ASSERT(!journal-&gt;j_checkpoint_transactions);
 	J_ASSERT(journal-&gt;j_head == journal-&gt;j_tail);
 	J_ASSERT(journal-&gt;j_tail_sequence == journal-&gt;j_transaction_sequence);
 	write_unlock(&amp;journal-&gt;j_state_lock);
<span class="p_del">-	return 0;</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return err;</span>
 }
 
 /**
<span class="p_chunk">@@ -1738,7 +1883,7 @@</span> <span class="p_context"> int jbd2_journal_wipe(journal_t *journal, int write)</span>
 
 	err = jbd2_journal_skip_recovery(journal);
 	if (write)
<span class="p_del">-		jbd2_journal_update_superblock(journal, 1);</span>
<span class="p_add">+		jbd2_mark_journal_empty(journal);</span>
 
  no_recovery:
 	return err;
<span class="p_chunk">@@ -1788,7 +1933,7 @@</span> <span class="p_context"> static void __journal_abort_soft (journal_t *journal, int errno)</span>
 	__jbd2_journal_abort_hard(journal);
 
 	if (errno)
<span class="p_del">-		jbd2_journal_update_superblock(journal, 1);</span>
<span class="p_add">+		jbd2_journal_update_sb_errno(journal);</span>
 }
 
 /**
<span class="p_header">diff --git a/fs/jbd2/recovery.c b/fs/jbd2/recovery.c</span>
<span class="p_header">index 421834b..875df5f 100644</span>
<span class="p_header">--- a/fs/jbd2/recovery.c</span>
<span class="p_header">+++ b/fs/jbd2/recovery.c</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/jbd2.h&gt;
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/crc32.h&gt;
<span class="p_add">+#include &lt;linux/blkdev.h&gt;</span>
 #endif
 
 /*
<span class="p_chunk">@@ -265,7 +266,9 @@</span> <span class="p_context"> int jbd2_journal_recover(journal_t *journal)</span>
 	err2 = sync_blockdev(journal-&gt;j_fs_dev);
 	if (!err)
 		err = err2;
<span class="p_del">-</span>
<span class="p_add">+	/* Make sure all replayed data is on permanent storage */</span>
<span class="p_add">+	if (journal-&gt;j_flags &amp; JBD2_BARRIER)</span>
<span class="p_add">+		blkdev_issue_flush(journal-&gt;j_fs_dev, GFP_KERNEL, NULL);</span>
 	return err;
 }
 
<span class="p_header">diff --git a/fs/nfs/nfs3xdr.c b/fs/nfs/nfs3xdr.c</span>
<span class="p_header">index 183c6b1..bee14a3 100644</span>
<span class="p_header">--- a/fs/nfs/nfs3xdr.c</span>
<span class="p_header">+++ b/fs/nfs/nfs3xdr.c</span>
<span class="p_chunk">@@ -1333,7 +1333,7 @@</span> <span class="p_context"> static void nfs3_xdr_enc_setacl3args(struct rpc_rqst *req,</span>
 	if (args-&gt;npages != 0)
 		xdr_write_pages(xdr, args-&gt;pages, 0, args-&gt;len);
 	else
<span class="p_del">-		xdr_reserve_space(xdr, NFS_ACL_INLINE_BUFSIZE);</span>
<span class="p_add">+		xdr_reserve_space(xdr, args-&gt;len);</span>
 
 	error = nfsacl_encode(xdr-&gt;buf, base, args-&gt;inode,
 			    (args-&gt;mask &amp; NFS_ACL) ?
<span class="p_header">diff --git a/fs/nfs/nfs4state.c b/fs/nfs/nfs4state.c</span>
<span class="p_header">index ce4168a..cd55214 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4state.c</span>
<span class="p_chunk">@@ -1192,6 +1192,8 @@</span> <span class="p_context"> restart:</span>
 				}
 				spin_unlock(&amp;state-&gt;state_lock);
 				nfs4_put_open_state(state);
<span class="p_add">+				clear_bit(NFS4CLNT_RECLAIM_NOGRACE,</span>
<span class="p_add">+					&amp;state-&gt;flags);</span>
 				goto restart;
 			}
 		}
<span class="p_header">diff --git a/include/acpi/actypes.h b/include/acpi/actypes.h</span>
<span class="p_header">index b0d7ef8..31a0f4b 100644</span>
<span class="p_header">--- a/include/acpi/actypes.h</span>
<span class="p_header">+++ b/include/acpi/actypes.h</span>
<span class="p_chunk">@@ -495,6 +495,7 @@</span> <span class="p_context"> typedef u64 acpi_integer;</span>
 #define ACPI_NO_ACPI_ENABLE             0x10
 #define ACPI_NO_DEVICE_INIT             0x20
 #define ACPI_NO_OBJECT_INIT             0x40
<span class="p_add">+#define ACPI_NO_FACS_INIT               0x80</span>
 
 /*
  * Initialization state
<span class="p_header">diff --git a/include/linux/buffer_head.h b/include/linux/buffer_head.h</span>
<span class="p_header">index 458f497..fed3f3a 100644</span>
<span class="p_header">--- a/include/linux/buffer_head.h</span>
<span class="p_header">+++ b/include/linux/buffer_head.h</span>
<span class="p_chunk">@@ -166,12 +166,13 @@</span> <span class="p_context"> void __wait_on_buffer(struct buffer_head *);</span>
 wait_queue_head_t *bh_waitq_head(struct buffer_head *bh);
 struct buffer_head *__find_get_block(struct block_device *bdev, sector_t block,
 			unsigned size);
<span class="p_del">-struct buffer_head *__getblk(struct block_device *bdev, sector_t block,</span>
<span class="p_del">-			unsigned size);</span>
<span class="p_add">+struct buffer_head *__getblk_gfp(struct block_device *bdev, sector_t block,</span>
<span class="p_add">+				  unsigned size, gfp_t gfp);</span>
 void __brelse(struct buffer_head *);
 void __bforget(struct buffer_head *);
 void __breadahead(struct block_device *, sector_t block, unsigned int size);
<span class="p_del">-struct buffer_head *__bread(struct block_device *, sector_t block, unsigned size);</span>
<span class="p_add">+struct buffer_head *__bread_gfp(struct block_device *,</span>
<span class="p_add">+				sector_t block, unsigned size, gfp_t gfp);</span>
 void invalidate_bh_lrus(void);
 struct buffer_head *alloc_buffer_head(gfp_t gfp_flags);
 void free_buffer_head(struct buffer_head * bh);
<span class="p_chunk">@@ -286,7 +287,13 @@</span> <span class="p_context"> static inline void bforget(struct buffer_head *bh)</span>
 static inline struct buffer_head *
 sb_bread(struct super_block *sb, sector_t block)
 {
<span class="p_del">-	return __bread(sb-&gt;s_bdev, block, sb-&gt;s_blocksize);</span>
<span class="p_add">+	return __bread_gfp(sb-&gt;s_bdev, block, sb-&gt;s_blocksize, __GFP_MOVABLE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline struct buffer_head *</span>
<span class="p_add">+sb_bread_unmovable(struct super_block *sb, sector_t block)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __bread_gfp(sb-&gt;s_bdev, block, sb-&gt;s_blocksize, 0);</span>
 }
 
 static inline void
<span class="p_chunk">@@ -298,7 +305,14 @@</span> <span class="p_context"> sb_breadahead(struct super_block *sb, sector_t block)</span>
 static inline struct buffer_head *
 sb_getblk(struct super_block *sb, sector_t block)
 {
<span class="p_del">-	return __getblk(sb-&gt;s_bdev, block, sb-&gt;s_blocksize);</span>
<span class="p_add">+	return __getblk_gfp(sb-&gt;s_bdev, block, sb-&gt;s_blocksize, __GFP_MOVABLE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static inline struct buffer_head *</span>
<span class="p_add">+sb_getblk_gfp(struct super_block *sb, sector_t block, gfp_t gfp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __getblk_gfp(sb-&gt;s_bdev, block, sb-&gt;s_blocksize, gfp);</span>
 }
 
 static inline struct buffer_head *
<span class="p_chunk">@@ -335,6 +349,36 @@</span> <span class="p_context"> static inline void lock_buffer(struct buffer_head *bh)</span>
 		__lock_buffer(bh);
 }
 
<span class="p_add">+static inline struct buffer_head *getblk_unmovable(struct block_device *bdev,</span>
<span class="p_add">+						   sector_t block,</span>
<span class="p_add">+						   unsigned size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __getblk_gfp(bdev, block, size, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline struct buffer_head *__getblk(struct block_device *bdev,</span>
<span class="p_add">+					   sector_t block,</span>
<span class="p_add">+					   unsigned size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __getblk_gfp(bdev, block, size, __GFP_MOVABLE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ *  __bread() - reads a specified block and returns the bh</span>
<span class="p_add">+ *  @bdev: the block_device to read from</span>
<span class="p_add">+ *  @block: number of block</span>
<span class="p_add">+ *  @size: size (in bytes) to read</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  Reads a specified block, and returns buffer head that contains it.</span>
<span class="p_add">+ *  The page cache is allocated from movable area so that it can be migrated.</span>
<span class="p_add">+ *  It returns NULL if the block was unreadable.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline struct buffer_head *</span>
<span class="p_add">+__bread(struct block_device *bdev, sector_t block, unsigned size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __bread_gfp(bdev, block, size, __GFP_MOVABLE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 extern int __set_page_dirty_buffers(struct page *page);
 
 #else /* CONFIG_BLOCK */
<span class="p_header">diff --git a/include/linux/jbd2.h b/include/linux/jbd2.h</span>
<span class="p_header">index a153ed5..4920c55 100644</span>
<span class="p_header">--- a/include/linux/jbd2.h</span>
<span class="p_header">+++ b/include/linux/jbd2.h</span>
<span class="p_chunk">@@ -972,6 +972,9 @@</span> <span class="p_context"> extern void __journal_clean_data_list(transaction_t *transaction);</span>
 /* Log buffer allocation */
 extern struct journal_head * jbd2_journal_get_descriptor_buffer(journal_t *);
 int jbd2_journal_next_log_block(journal_t *, unsigned long long *);
<span class="p_add">+int jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,</span>
<span class="p_add">+			      unsigned long *block);</span>
<span class="p_add">+int __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);</span>
 
 /* Commit management */
 extern void jbd2_journal_commit_transaction(journal_t *);
<span class="p_chunk">@@ -1083,7 +1086,8 @@</span> <span class="p_context"> extern int	   jbd2_journal_destroy    (journal_t *);</span>
 extern int	   jbd2_journal_recover    (journal_t *journal);
 extern int	   jbd2_journal_wipe       (journal_t *, int);
 extern int	   jbd2_journal_skip_recovery	(journal_t *);
<span class="p_del">-extern void	   jbd2_journal_update_superblock	(journal_t *, int);</span>
<span class="p_add">+extern int	   jbd2_journal_update_sb_log_tail	(journal_t *, tid_t,</span>
<span class="p_add">+				unsigned long, int);</span>
 extern void	   __jbd2_journal_abort_hard	(journal_t *);
 extern void	   jbd2_journal_abort      (journal_t *, int);
 extern int	   jbd2_journal_errno      (journal_t *);
<span class="p_header">diff --git a/include/linux/libata.h b/include/linux/libata.h</span>
<span class="p_header">index 3d4b5b6..000434e 100644</span>
<span class="p_header">--- a/include/linux/libata.h</span>
<span class="p_header">+++ b/include/linux/libata.h</span>
<span class="p_chunk">@@ -403,6 +403,8 @@</span> <span class="p_context"> enum {</span>
 	ATA_HORKAGE_MAX_SEC_LBA48 = (1 &lt;&lt; 17),	/* Set max sects to 65535 */
 	ATA_HORKAGE_NOLPM	= (1 &lt;&lt; 20),	/* don&#39;t use LPM */
 	ATA_HORKAGE_WD_BROKEN_LPM = (1 &lt;&lt; 21),	/* some WDs have broken LPM */
<span class="p_add">+	ATA_HORKAGE_NOTRIM	= (1 &lt;&lt; 24),	/* don&#39;t use TRIM */</span>
<span class="p_add">+</span>
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */
<span class="p_header">diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h</span>
<span class="p_header">index 41116ab..d2abc34 100644</span>
<span class="p_header">--- a/include/linux/nfs_xdr.h</span>
<span class="p_header">+++ b/include/linux/nfs_xdr.h</span>
<span class="p_chunk">@@ -1056,7 +1056,7 @@</span> <span class="p_context"> struct nfs_impl_id4 {</span>
 	struct nfstime4	date;
 };
 
<span class="p_del">-#define NFS4_EXCHANGE_ID_LEN	(48)</span>
<span class="p_add">+#define NFS4_EXCHANGE_ID_LEN	(127)</span>
 struct nfs41_exchange_id_args {
 	struct nfs_client		*client;
 	nfs4_verifier			*verifier;
<span class="p_header">diff --git a/include/trace/events/jbd2.h b/include/trace/events/jbd2.h</span>
<span class="p_header">index 7596441..5c74007 100644</span>
<span class="p_header">--- a/include/trace/events/jbd2.h</span>
<span class="p_header">+++ b/include/trace/events/jbd2.h</span>
<span class="p_chunk">@@ -200,7 +200,7 @@</span> <span class="p_context"> TRACE_EVENT(jbd2_checkpoint_stats,</span>
 		  __entry-&gt;forced_to_close, __entry-&gt;written, __entry-&gt;dropped)
 );
 
<span class="p_del">-TRACE_EVENT(jbd2_cleanup_journal_tail,</span>
<span class="p_add">+TRACE_EVENT(jbd2_update_log_tail,</span>
 
 	TP_PROTO(journal_t *journal, tid_t first_tid,
 		 unsigned long block_nr, unsigned long freed),
<span class="p_header">diff --git a/kernel/hrtimer.c b/kernel/hrtimer.c</span>
<span class="p_header">index 20e88af..d9ce3d4 100644</span>
<span class="p_header">--- a/kernel/hrtimer.c</span>
<span class="p_header">+++ b/kernel/hrtimer.c</span>
<span class="p_chunk">@@ -848,6 +848,9 @@</span> <span class="p_context"> u64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)</span>
 	if (delta.tv64 &lt; 0)
 		return 0;
 
<span class="p_add">+	if (WARN_ON(timer-&gt;state &amp; HRTIMER_STATE_ENQUEUED))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	if (interval.tv64 &lt; timer-&gt;base-&gt;resolution.tv64)
 		interval.tv64 = timer-&gt;base-&gt;resolution.tv64;
 
<span class="p_chunk">@@ -1260,11 +1263,14 @@</span> <span class="p_context"> static void __run_hrtimer(struct hrtimer *timer, ktime_t *now)</span>
 	 * Note: We clear the CALLBACK bit after enqueue_hrtimer and
 	 * we do not reprogramm the event hardware. Happens either in
 	 * hrtimer_start_range_ns() or in hrtimer_interrupt()
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note: Because we dropped the cpu_base-&gt;lock above,</span>
<span class="p_add">+	 * hrtimer_start_range_ns() can have popped in and enqueued the timer</span>
<span class="p_add">+	 * for us already.</span>
 	 */
<span class="p_del">-	if (restart != HRTIMER_NORESTART) {</span>
<span class="p_del">-		BUG_ON(timer-&gt;state != HRTIMER_STATE_CALLBACK);</span>
<span class="p_add">+	if (restart != HRTIMER_NORESTART &amp;&amp;</span>
<span class="p_add">+	    !(timer-&gt;state &amp; HRTIMER_STATE_ENQUEUED))</span>
 		enqueue_hrtimer(timer, base);
<span class="p_del">-	}</span>
 
 	WARN_ON_ONCE(!(timer-&gt;state &amp; HRTIMER_STATE_CALLBACK));
 
<span class="p_header">diff --git a/kernel/rcutiny.c b/kernel/rcutiny.c</span>
<span class="p_header">index 636af6d..bc84596 100644</span>
<span class="p_header">--- a/kernel/rcutiny.c</span>
<span class="p_header">+++ b/kernel/rcutiny.c</span>
<span class="p_chunk">@@ -160,6 +160,11 @@</span> <span class="p_context"> static void __rcu_process_callbacks(struct rcu_ctrlblk *rcp)</span>
 
 	/* Move the ready-to-invoke callbacks to a local list. */
 	local_irq_save(flags);
<span class="p_add">+	if (rcp-&gt;donetail == &amp;rcp-&gt;rcucblist) {</span>
<span class="p_add">+		/* No callbacks ready, so just leave. */</span>
<span class="p_add">+		local_irq_restore(flags);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 	RCU_TRACE(trace_rcu_batch_start(rcp-&gt;name, 0, -1));
 	list = rcp-&gt;rcucblist;
 	rcp-&gt;rcucblist = *rcp-&gt;donetail;
<span class="p_header">diff --git a/kernel/trace/trace_events_filter.c b/kernel/trace/trace_events_filter.c</span>
<span class="p_header">index 47343cc..bfeb725 100644</span>
<span class="p_header">--- a/kernel/trace/trace_events_filter.c</span>
<span class="p_header">+++ b/kernel/trace/trace_events_filter.c</span>
<span class="p_chunk">@@ -1027,6 +1027,9 @@</span> <span class="p_context"> static void parse_init(struct filter_parse_state *ps,</span>
 
 static char infix_next(struct filter_parse_state *ps)
 {
<span class="p_add">+	if (!ps-&gt;infix.cnt)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	ps-&gt;infix.cnt--;
 
 	return ps-&gt;infix.string[ps-&gt;infix.tail++];
<span class="p_chunk">@@ -1042,6 +1045,9 @@</span> <span class="p_context"> static char infix_peek(struct filter_parse_state *ps)</span>
 
 static void infix_advance(struct filter_parse_state *ps)
 {
<span class="p_add">+	if (!ps-&gt;infix.cnt)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	ps-&gt;infix.cnt--;
 	ps-&gt;infix.tail++;
 }
<span class="p_chunk">@@ -1358,7 +1364,9 @@</span> <span class="p_context"> static int check_preds(struct filter_parse_state *ps)</span>
 		}
 		cnt--;
 		n_normal_preds++;
<span class="p_del">-		WARN_ON_ONCE(cnt &lt; 0);</span>
<span class="p_add">+		/* all ops should have operands */</span>
<span class="p_add">+		if (cnt &lt; 0)</span>
<span class="p_add">+			break;</span>
 	}
 
 	if (cnt != 1 || !n_normal_preds || n_logical_preds &gt;= n_normal_preds) {
<span class="p_header">diff --git a/lib/bitmap.c b/lib/bitmap.c</span>
<span class="p_header">index dbc526f..389e75e 100644</span>
<span class="p_header">--- a/lib/bitmap.c</span>
<span class="p_header">+++ b/lib/bitmap.c</span>
<span class="p_chunk">@@ -601,12 +601,12 @@</span> <span class="p_context"> static int __bitmap_parselist(const char *buf, unsigned int buflen,</span>
 	unsigned a, b;
 	int c, old_c, totaldigits;
 	const char __user __force *ubuf = (const char __user __force *)buf;
<span class="p_del">-	int exp_digit, in_range;</span>
<span class="p_add">+	int at_start, in_range;</span>
 
 	totaldigits = c = 0;
 	bitmap_zero(maskp, nmaskbits);
 	do {
<span class="p_del">-		exp_digit = 1;</span>
<span class="p_add">+		at_start = 1;</span>
 		in_range = 0;
 		a = b = 0;
 
<span class="p_chunk">@@ -635,11 +635,10 @@</span> <span class="p_context"> static int __bitmap_parselist(const char *buf, unsigned int buflen,</span>
 				break;
 
 			if (c == &#39;-&#39;) {
<span class="p_del">-				if (exp_digit || in_range)</span>
<span class="p_add">+				if (at_start || in_range)</span>
 					return -EINVAL;
 				b = 0;
 				in_range = 1;
<span class="p_del">-				exp_digit = 1;</span>
 				continue;
 			}
 
<span class="p_chunk">@@ -649,16 +648,18 @@</span> <span class="p_context"> static int __bitmap_parselist(const char *buf, unsigned int buflen,</span>
 			b = b * 10 + (c - &#39;0&#39;);
 			if (!in_range)
 				a = b;
<span class="p_del">-			exp_digit = 0;</span>
<span class="p_add">+			at_start = 0;</span>
 			totaldigits++;
 		}
 		if (!(a &lt;= b))
 			return -EINVAL;
 		if (b &gt;= nmaskbits)
 			return -ERANGE;
<span class="p_del">-		while (a &lt;= b) {</span>
<span class="p_del">-			set_bit(a, maskp);</span>
<span class="p_del">-			a++;</span>
<span class="p_add">+		if (!at_start) {</span>
<span class="p_add">+			while (a &lt;= b) {</span>
<span class="p_add">+				set_bit(a, maskp);</span>
<span class="p_add">+				a++;</span>
<span class="p_add">+			}</span>
 		}
 	} while (buflen &amp;&amp; c == &#39;,&#39;);
 	return 0;
<span class="p_header">diff --git a/mm/filemap.c b/mm/filemap.c</span>
<span class="p_header">index 556858c..6c009c2 100644</span>
<span class="p_header">--- a/mm/filemap.c</span>
<span class="p_header">+++ b/mm/filemap.c</span>
<span class="p_chunk">@@ -2007,8 +2007,8 @@</span> <span class="p_context"> int file_remove_suid(struct file *file)</span>
 		error = security_inode_killpriv(dentry);
 	if (!error &amp;&amp; killsuid)
 		error = __remove_suid(dentry, killsuid);
<span class="p_del">-	if (!error &amp;&amp; (inode-&gt;i_sb-&gt;s_flags &amp; MS_NOSEC))</span>
<span class="p_del">-		inode-&gt;i_flags |= S_NOSEC;</span>
<span class="p_add">+	if (!error)</span>
<span class="p_add">+		inode_has_no_xattr(inode);</span>
 
 	return error;
 }
<span class="p_header">diff --git a/mm/kmemleak.c b/mm/kmemleak.c</span>
<span class="p_header">index cc8cf1d..cbae846 100644</span>
<span class="p_header">--- a/mm/kmemleak.c</span>
<span class="p_header">+++ b/mm/kmemleak.c</span>
<span class="p_chunk">@@ -192,6 +192,8 @@</span> <span class="p_context"> static struct kmem_cache *scan_area_cache;</span>
 
 /* set if tracing memory operations is enabled */
 static atomic_t kmemleak_enabled = ATOMIC_INIT(0);
<span class="p_add">+/* same as above but only for the kmemleak_free() callback */</span>
<span class="p_add">+static int kmemleak_free_enabled;</span>
 /* set in the late_initcall if there were no errors */
 static atomic_t kmemleak_initialized = ATOMIC_INIT(0);
 /* enables or disables early logging of the memory operations */
<span class="p_chunk">@@ -885,7 +887,7 @@</span> <span class="p_context"> void __ref kmemleak_free(const void *ptr)</span>
 {
 	pr_debug(&quot;%s(0x%p)\n&quot;, __func__, ptr);
 
<span class="p_del">-	if (atomic_read(&amp;kmemleak_enabled) &amp;&amp; ptr &amp;&amp; !IS_ERR(ptr))</span>
<span class="p_add">+	if (kmemleak_free_enabled &amp;&amp; ptr &amp;&amp; !IS_ERR(ptr))</span>
 		delete_object_full((unsigned long)ptr);
 	else if (atomic_read(&amp;kmemleak_early_log))
 		log_early(KMEMLEAK_FREE, ptr, 0, 0);
<span class="p_chunk">@@ -1614,6 +1616,13 @@</span> <span class="p_context"> static void kmemleak_do_cleanup(struct work_struct *work)</span>
 	mutex_lock(&amp;scan_mutex);
 	stop_scan_thread();
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Once the scan thread has stopped, it is safe to no longer track</span>
<span class="p_add">+	 * object freeing. Ordering of the scan thread stopping and the memory</span>
<span class="p_add">+	 * accesses below is guaranteed by the kthread_stop() function.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	kmemleak_free_enabled = 0;</span>
<span class="p_add">+</span>
 	rcu_read_lock();
 	list_for_each_entry_rcu(object, &amp;object_list, object_list)
 		delete_object_full(object-&gt;pointer);
<span class="p_chunk">@@ -1640,6 +1649,8 @@</span> <span class="p_context"> static void kmemleak_disable(void)</span>
 	/* check whether it is too early for a kernel thread */
 	if (atomic_read(&amp;kmemleak_initialized))
 		schedule_work(&amp;cleanup_work);
<span class="p_add">+	else</span>
<span class="p_add">+		kmemleak_free_enabled = 0;</span>
 
 	pr_info(&quot;Kernel memory leak detector disabled\n&quot;);
 }
<span class="p_chunk">@@ -1688,6 +1699,7 @@</span> <span class="p_context"> void __init kmemleak_init(void)</span>
 	if (!atomic_read(&amp;kmemleak_error)) {
 		atomic_set(&amp;kmemleak_enabled, 1);
 		atomic_set(&amp;kmemleak_early_log, 0);
<span class="p_add">+		kmemleak_free_enabled = 1;</span>
 	}
 	local_irq_restore(flags);
 
<span class="p_header">diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="p_header">index 452b8ba..7762b1d 100644</span>
<span class="p_header">--- a/mm/memory.c</span>
<span class="p_header">+++ b/mm/memory.c</span>
<span class="p_chunk">@@ -3153,6 +3153,10 @@</span> <span class="p_context"> static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 
 	pte_unmap(page_table);
 
<span class="p_add">+	/* File mapping without -&gt;vm_ops ? */</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_SHARED)</span>
<span class="p_add">+		return VM_FAULT_SIGBUS;</span>
<span class="p_add">+</span>
 	/* Check if we need to add a guard page to the stack */
 	if (check_stack_guard_page(vma, address) &lt; 0)
 		return VM_FAULT_SIGSEGV;
<span class="p_chunk">@@ -3412,6 +3416,9 @@</span> <span class="p_context"> static int do_linear_fault(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 			- vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff;
 
 	pte_unmap(page_table);
<span class="p_add">+	/* The VMA was not fully populated on mmap() or missing VM_DONTEXPAND */</span>
<span class="p_add">+	if (!vma-&gt;vm_ops-&gt;fault)</span>
<span class="p_add">+		return VM_FAULT_SIGBUS;</span>
 	return __do_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);
 }
 
<span class="p_chunk">@@ -3470,11 +3477,9 @@</span> <span class="p_context"> int handle_pte_fault(struct mm_struct *mm,</span>
 	entry = *pte;
 	if (!pte_present(entry)) {
 		if (pte_none(entry)) {
<span class="p_del">-			if (vma-&gt;vm_ops) {</span>
<span class="p_del">-				if (likely(vma-&gt;vm_ops-&gt;fault))</span>
<span class="p_del">-					return do_linear_fault(mm, vma, address,</span>
<span class="p_add">+			if (vma-&gt;vm_ops)</span>
<span class="p_add">+				return do_linear_fault(mm, vma, address,</span>
 						pte, pmd, flags, entry);
<span class="p_del">-			}</span>
 			return do_anonymous_page(mm, vma, address,
 						 pte, pmd, flags);
 		}
<span class="p_header">diff --git a/net/9p/client.c b/net/9p/client.c</span>
<span class="p_header">index 854ca7a..e958178 100644</span>
<span class="p_header">--- a/net/9p/client.c</span>
<span class="p_header">+++ b/net/9p/client.c</span>
<span class="p_chunk">@@ -824,7 +824,8 @@</span> <span class="p_context"> static struct p9_req_t *p9_client_zc_rpc(struct p9_client *c, int8_t type,</span>
 	if (err &lt; 0) {
 		if (err == -EIO)
 			c-&gt;status = Disconnected;
<span class="p_del">-		goto reterr;</span>
<span class="p_add">+		if (err != -ERESTARTSYS)</span>
<span class="p_add">+			goto reterr;</span>
 	}
 	if (req-&gt;status == REQ_STATUS_ERROR) {
 		P9_DPRINTK(P9_DEBUG_ERROR, &quot;req_status error %d\n&quot;, req-&gt;t_err);
<span class="p_header">diff --git a/net/bridge/br_multicast.c b/net/bridge/br_multicast.c</span>
<span class="p_header">index 1bd197f..5f21e53 100644</span>
<span class="p_header">--- a/net/bridge/br_multicast.c</span>
<span class="p_header">+++ b/net/bridge/br_multicast.c</span>
<span class="p_chunk">@@ -36,6 +36,9 @@</span> <span class="p_context"></span>
 #define mlock_dereference(X, br) \
 	rcu_dereference_protected(X, lockdep_is_held(&amp;br-&gt;multicast_lock))
 
<span class="p_add">+static void br_multicast_add_router(struct net_bridge *br,</span>
<span class="p_add">+				    struct net_bridge_port *port);</span>
<span class="p_add">+</span>
 #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
 static inline int ipv6_is_transient_multicast(const struct in6_addr *addr)
 {
<span class="p_chunk">@@ -842,6 +845,8 @@</span> <span class="p_context"> void br_multicast_enable_port(struct net_bridge_port *port)</span>
 		goto out;
 
 	__br_multicast_enable_port(port);
<span class="p_add">+	if (port-&gt;multicast_router == 2 &amp;&amp; hlist_unhashed(&amp;port-&gt;rlist))</span>
<span class="p_add">+		br_multicast_add_router(br, port);</span>
 
 out:
 	spin_unlock(&amp;br-&gt;multicast_lock);
<span class="p_header">diff --git a/net/bridge/br_netfilter.c b/net/bridge/br_netfilter.c</span>
<span class="p_header">index 7c1745d..6cdd3af 100644</span>
<span class="p_header">--- a/net/bridge/br_netfilter.c</span>
<span class="p_header">+++ b/net/bridge/br_netfilter.c</span>
<span class="p_chunk">@@ -822,12 +822,15 @@</span> <span class="p_context"> static int br_nf_dev_queue_xmit(struct sk_buff *skb)</span>
 	    !skb_is_gso(skb)) {
 		if (br_parse_ip_options(skb))
 			/* Drop invalid packet */
<span class="p_del">-			return NF_DROP;</span>
<span class="p_add">+			goto drop;</span>
 		ret = ip_fragment(skb, br_dev_queue_push_xmit);
 	} else
 		ret = br_dev_queue_push_xmit(skb);
 
 	return ret;
<span class="p_add">+ drop:</span>
<span class="p_add">+	kfree_skb(skb);</span>
<span class="p_add">+	return 0;</span>
 }
 #else
 static int br_nf_dev_queue_xmit(struct sk_buff *skb)
<span class="p_header">diff --git a/net/ceph/osdmap.c b/net/ceph/osdmap.c</span>
<span class="p_header">index fd863fe7..bb38a3c 100644</span>
<span class="p_header">--- a/net/ceph/osdmap.c</span>
<span class="p_header">+++ b/net/ceph/osdmap.c</span>
<span class="p_chunk">@@ -102,7 +102,7 @@</span> <span class="p_context"> static int crush_decode_tree_bucket(void **p, void *end,</span>
 {
 	int j;
 	dout(&quot;crush_decode_tree_bucket %p to %p\n&quot;, *p, end);
<span class="p_del">-	ceph_decode_32_safe(p, end, b-&gt;num_nodes, bad);</span>
<span class="p_add">+	ceph_decode_8_safe(p, end, b-&gt;num_nodes, bad);</span>
 	b-&gt;node_weights = kcalloc(b-&gt;num_nodes, sizeof(u32), GFP_NOFS);
 	if (b-&gt;node_weights == NULL)
 		return -ENOMEM;
<span class="p_header">diff --git a/net/core/datagram.c b/net/core/datagram.c</span>
<span class="p_header">index 68bbf9f..6f54d0a 100644</span>
<span class="p_header">--- a/net/core/datagram.c</span>
<span class="p_header">+++ b/net/core/datagram.c</span>
<span class="p_chunk">@@ -180,18 +180,19 @@</span> <span class="p_context"> struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned flags,</span>
 		 * However, this function was correct in any case. 8)
 		 */
 		unsigned long cpu_flags;
<span class="p_add">+		struct sk_buff_head *queue = &amp;sk-&gt;sk_receive_queue;</span>
 
<span class="p_del">-		spin_lock_irqsave(&amp;sk-&gt;sk_receive_queue.lock, cpu_flags);</span>
<span class="p_del">-		skb = skb_peek(&amp;sk-&gt;sk_receive_queue);</span>
<span class="p_add">+		spin_lock_irqsave(&amp;queue-&gt;lock, cpu_flags);</span>
<span class="p_add">+		skb = skb_peek(queue);</span>
 		if (skb) {
 			*peeked = skb-&gt;peeked;
 			if (flags &amp; MSG_PEEK) {
 				skb-&gt;peeked = 1;
 				atomic_inc(&amp;skb-&gt;users);
 			} else
<span class="p_del">-				__skb_unlink(skb, &amp;sk-&gt;sk_receive_queue);</span>
<span class="p_add">+				__skb_unlink(skb, queue);</span>
 		}
<span class="p_del">-		spin_unlock_irqrestore(&amp;sk-&gt;sk_receive_queue.lock, cpu_flags);</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;queue-&gt;lock, cpu_flags);</span>
 
 		if (skb)
 			return skb;
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index 1c0d862..7f43202 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -2947,6 +2947,8 @@</span> <span class="p_context"> static int enqueue_to_backlog(struct sk_buff *skb, int cpu,</span>
 	local_irq_save(flags);
 
 	rps_lock(sd);
<span class="p_add">+	if (!netif_running(skb-&gt;dev))</span>
<span class="p_add">+		goto drop;</span>
 	if (skb_queue_len(&amp;sd-&gt;input_pkt_queue) &lt;= netdev_max_backlog) {
 		if (skb_queue_len(&amp;sd-&gt;input_pkt_queue)) {
 enqueue:
<span class="p_chunk">@@ -2967,6 +2969,7 @@</span> <span class="p_context"> enqueue:</span>
 		goto enqueue;
 	}
 
<span class="p_add">+drop:</span>
 	sd-&gt;dropped++;
 	rps_unlock(sd);
 
<span class="p_chunk">@@ -3258,8 +3261,6 @@</span> <span class="p_context"> static int __netif_receive_skb(struct sk_buff *skb)</span>
 
 	pt_prev = NULL;
 
<span class="p_del">-	rcu_read_lock();</span>
<span class="p_del">-</span>
 another_round:
 
 	__this_cpu_inc(softnet_data.processed);
<span class="p_chunk">@@ -3354,7 +3355,6 @@</span> <span class="p_context"> ncls:</span>
 	}
 
 out:
<span class="p_del">-	rcu_read_unlock();</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -3375,34 +3375,31 @@</span> <span class="p_context"> out:</span>
  */
 int netif_receive_skb(struct sk_buff *skb)
 {
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
 	if (netdev_tstamp_prequeue)
 		net_timestamp_check(skb);
 
 	if (skb_defer_rx_timestamp(skb))
 		return NET_RX_SUCCESS;
 
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+</span>
 #ifdef CONFIG_RPS
 	{
 		struct rps_dev_flow voidflow, *rflow = &amp;voidflow;
<span class="p_del">-		int cpu, ret;</span>
<span class="p_del">-</span>
<span class="p_del">-		rcu_read_lock();</span>
<span class="p_del">-</span>
<span class="p_del">-		cpu = get_rps_cpu(skb-&gt;dev, skb, &amp;rflow);</span>
<span class="p_add">+		int cpu = get_rps_cpu(skb-&gt;dev, skb, &amp;rflow);</span>
 
 		if (cpu &gt;= 0) {
 			ret = enqueue_to_backlog(skb, cpu, &amp;rflow-&gt;last_qtail);
 			rcu_read_unlock();
<span class="p_del">-		} else {</span>
<span class="p_del">-			rcu_read_unlock();</span>
<span class="p_del">-			ret = __netif_receive_skb(skb);</span>
<span class="p_add">+			return ret;</span>
 		}
<span class="p_del">-</span>
<span class="p_del">-		return ret;</span>
 	}
<span class="p_del">-#else</span>
<span class="p_del">-	return __netif_receive_skb(skb);</span>
 #endif
<span class="p_add">+	ret = __netif_receive_skb(skb);</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+	return ret;</span>
 }
 EXPORT_SYMBOL(netif_receive_skb);
 
<span class="p_chunk">@@ -3793,8 +3790,10 @@</span> <span class="p_context"> static int process_backlog(struct napi_struct *napi, int quota)</span>
 		unsigned int qlen;
 
 		while ((skb = __skb_dequeue(&amp;sd-&gt;process_queue))) {
<span class="p_add">+			rcu_read_lock();</span>
 			local_irq_enable();
 			__netif_receive_skb(skb);
<span class="p_add">+			rcu_read_unlock();</span>
 			local_irq_disable();
 			input_queue_head_incr(sd);
 			if (++work &gt;= quota) {
<span class="p_chunk">@@ -5305,6 +5304,7 @@</span> <span class="p_context"> static void rollback_registered_many(struct list_head *head)</span>
 		unlist_netdevice(dev);
 
 		dev-&gt;reg_state = NETREG_UNREGISTERING;
<span class="p_add">+		on_each_cpu(flush_backlog, dev, 1);</span>
 	}
 
 	synchronize_net();
<span class="p_chunk">@@ -5877,8 +5877,6 @@</span> <span class="p_context"> void netdev_run_todo(void)</span>
 
 		dev-&gt;reg_state = NETREG_UNREGISTERED;
 
<span class="p_del">-		on_each_cpu(flush_backlog, dev, 1);</span>
<span class="p_del">-</span>
 		netdev_wait_allrefs(dev);
 
 		/* paranoia */
<span class="p_header">diff --git a/net/core/pktgen.c b/net/core/pktgen.c</span>
<span class="p_header">index 80aeac9..9dd65a9 100644</span>
<span class="p_header">--- a/net/core/pktgen.c</span>
<span class="p_header">+++ b/net/core/pktgen.c</span>
<span class="p_chunk">@@ -568,7 +568,7 @@</span> <span class="p_context"> static int pktgen_if_show(struct seq_file *seq, void *v)</span>
 			   &quot;     dst_min: %s  dst_max: %s\n&quot;,
 			   pkt_dev-&gt;dst_min, pkt_dev-&gt;dst_max);
 		seq_printf(seq,
<span class="p_del">-			   &quot;        src_min: %s  src_max: %s\n&quot;,</span>
<span class="p_add">+			   &quot;     src_min: %s  src_max: %s\n&quot;,</span>
 			   pkt_dev-&gt;src_min, pkt_dev-&gt;src_max);
 	}
 
<span class="p_header">diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c</span>
<span class="p_header">index 5b412f0..e77373a 100644</span>
<span class="p_header">--- a/net/core/rtnetlink.c</span>
<span class="p_header">+++ b/net/core/rtnetlink.c</span>
<span class="p_chunk">@@ -1147,10 +1147,6 @@</span> <span class="p_context"> static const struct nla_policy ifla_info_policy[IFLA_INFO_MAX+1] = {</span>
 	[IFLA_INFO_DATA]	= { .type = NLA_NESTED },
 };
 
<span class="p_del">-static const struct nla_policy ifla_vfinfo_policy[IFLA_VF_INFO_MAX+1] = {</span>
<span class="p_del">-	[IFLA_VF_INFO]		= { .type = NLA_NESTED },</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 static const struct nla_policy ifla_vf_policy[IFLA_VF_MAX+1] = {
 	[IFLA_VF_MAC]		= { .len = sizeof(struct ifla_vf_mac) },
 	[IFLA_VF_VLAN]		= { .len = sizeof(struct ifla_vf_vlan) },
<span class="p_chunk">@@ -1224,58 +1220,53 @@</span> <span class="p_context"> static int validate_linkmsg(struct net_device *dev, struct nlattr *tb[])</span>
 	return 0;
 }
 
<span class="p_del">-static int do_setvfinfo(struct net_device *dev, struct nlattr *attr)</span>
<span class="p_add">+static int do_setvfinfo(struct net_device *dev, struct nlattr **tb)</span>
 {
<span class="p_del">-	int rem, err = -EINVAL;</span>
<span class="p_del">-	struct nlattr *vf;</span>
 	const struct net_device_ops *ops = dev-&gt;netdev_ops;
<span class="p_add">+	int err = -EINVAL;</span>
 
<span class="p_del">-	nla_for_each_nested(vf, attr, rem) {</span>
<span class="p_del">-		switch (nla_type(vf)) {</span>
<span class="p_del">-		case IFLA_VF_MAC: {</span>
<span class="p_del">-			struct ifla_vf_mac *ivm;</span>
<span class="p_del">-			ivm = nla_data(vf);</span>
<span class="p_del">-			err = -EOPNOTSUPP;</span>
<span class="p_del">-			if (ops-&gt;ndo_set_vf_mac)</span>
<span class="p_del">-				err = ops-&gt;ndo_set_vf_mac(dev, ivm-&gt;vf,</span>
<span class="p_del">-							  ivm-&gt;mac);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		case IFLA_VF_VLAN: {</span>
<span class="p_del">-			struct ifla_vf_vlan *ivv;</span>
<span class="p_del">-			ivv = nla_data(vf);</span>
<span class="p_del">-			err = -EOPNOTSUPP;</span>
<span class="p_del">-			if (ops-&gt;ndo_set_vf_vlan)</span>
<span class="p_del">-				err = ops-&gt;ndo_set_vf_vlan(dev, ivv-&gt;vf,</span>
<span class="p_del">-							   ivv-&gt;vlan,</span>
<span class="p_del">-							   ivv-&gt;qos);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		case IFLA_VF_TX_RATE: {</span>
<span class="p_del">-			struct ifla_vf_tx_rate *ivt;</span>
<span class="p_del">-			ivt = nla_data(vf);</span>
<span class="p_del">-			err = -EOPNOTSUPP;</span>
<span class="p_del">-			if (ops-&gt;ndo_set_vf_tx_rate)</span>
<span class="p_del">-				err = ops-&gt;ndo_set_vf_tx_rate(dev, ivt-&gt;vf,</span>
<span class="p_del">-							      ivt-&gt;rate);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		case IFLA_VF_SPOOFCHK: {</span>
<span class="p_del">-			struct ifla_vf_spoofchk *ivs;</span>
<span class="p_del">-			ivs = nla_data(vf);</span>
<span class="p_del">-			err = -EOPNOTSUPP;</span>
<span class="p_del">-			if (ops-&gt;ndo_set_vf_spoofchk)</span>
<span class="p_del">-				err = ops-&gt;ndo_set_vf_spoofchk(dev, ivs-&gt;vf,</span>
<span class="p_del">-							       ivs-&gt;setting);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		default:</span>
<span class="p_del">-			err = -EINVAL;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (err)</span>
<span class="p_del">-			break;</span>
<span class="p_add">+	if (tb[IFLA_VF_MAC]) {</span>
<span class="p_add">+		struct ifla_vf_mac *ivm = nla_data(tb[IFLA_VF_MAC]);</span>
<span class="p_add">+		err = -EOPNOTSUPP;</span>
<span class="p_add">+		if (ops-&gt;ndo_set_vf_mac)</span>
<span class="p_add">+			err = ops-&gt;ndo_set_vf_mac(dev, ivm-&gt;vf,</span>
<span class="p_add">+						  ivm-&gt;mac);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			return err;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (tb[IFLA_VF_VLAN]) {</span>
<span class="p_add">+		struct ifla_vf_vlan *ivv = nla_data(tb[IFLA_VF_VLAN]);</span>
<span class="p_add">+</span>
<span class="p_add">+		err = -EOPNOTSUPP;</span>
<span class="p_add">+		if (ops-&gt;ndo_set_vf_vlan)</span>
<span class="p_add">+			err = ops-&gt;ndo_set_vf_vlan(dev, ivv-&gt;vf, ivv-&gt;vlan,</span>
<span class="p_add">+						   ivv-&gt;qos);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tb[IFLA_VF_TX_RATE]) {</span>
<span class="p_add">+		struct ifla_vf_tx_rate *ivt = nla_data(tb[IFLA_VF_TX_RATE]);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ops-&gt;ndo_set_vf_tx_rate)</span>
<span class="p_add">+			err = ops-&gt;ndo_set_vf_tx_rate(dev, ivt-&gt;vf,</span>
<span class="p_add">+						      ivt-&gt;rate);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tb[IFLA_VF_SPOOFCHK]) {</span>
<span class="p_add">+		struct ifla_vf_spoofchk *ivs = nla_data(tb[IFLA_VF_SPOOFCHK]);</span>
<span class="p_add">+</span>
<span class="p_add">+		err = -EOPNOTSUPP;</span>
<span class="p_add">+		if (ops-&gt;ndo_set_vf_spoofchk)</span>
<span class="p_add">+			err = ops-&gt;ndo_set_vf_spoofchk(dev, ivs-&gt;vf,</span>
<span class="p_add">+						       ivs-&gt;setting);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return err;
 }
 
<span class="p_chunk">@@ -1458,14 +1449,21 @@</span> <span class="p_context"> static int do_setlink(struct net_device *dev, struct ifinfomsg *ifm,</span>
 	}
 
 	if (tb[IFLA_VFINFO_LIST]) {
<span class="p_add">+		struct nlattr *vfinfo[IFLA_VF_MAX + 1];</span>
 		struct nlattr *attr;
 		int rem;
<span class="p_add">+</span>
 		nla_for_each_nested(attr, tb[IFLA_VFINFO_LIST], rem) {
<span class="p_del">-			if (nla_type(attr) != IFLA_VF_INFO) {</span>
<span class="p_add">+			if (nla_type(attr) != IFLA_VF_INFO ||</span>
<span class="p_add">+			    nla_len(attr) &lt; NLA_HDRLEN) {</span>
 				err = -EINVAL;
 				goto errout;
 			}
<span class="p_del">-			err = do_setvfinfo(dev, attr);</span>
<span class="p_add">+			err = nla_parse_nested(vfinfo, IFLA_VF_MAX, attr,</span>
<span class="p_add">+					       ifla_vf_policy);</span>
<span class="p_add">+			if (err &lt; 0)</span>
<span class="p_add">+				goto errout;</span>
<span class="p_add">+			err = do_setvfinfo(dev, vfinfo);</span>
 			if (err &lt; 0)
 				goto errout;
 			modified = 1;
<span class="p_header">diff --git a/net/ipv4/ip_fragment.c b/net/ipv4/ip_fragment.c</span>
<span class="p_header">index 16e25a4..c20c356 100644</span>
<span class="p_header">--- a/net/ipv4/ip_fragment.c</span>
<span class="p_header">+++ b/net/ipv4/ip_fragment.c</span>
<span class="p_chunk">@@ -385,7 +385,7 @@</span> <span class="p_context"> static int ip_frag_queue(struct ipq *qp, struct sk_buff *skb)</span>
 	ihl = ip_hdrlen(skb);
 
 	/* Determine the position of this fragment. */
<span class="p_del">-	end = offset + skb-&gt;len - ihl;</span>
<span class="p_add">+	end = offset + skb-&gt;len - skb_network_offset(skb) - ihl;</span>
 	err = -EINVAL;
 
 	/* Is this the final fragment? */
<span class="p_chunk">@@ -415,7 +415,7 @@</span> <span class="p_context"> static int ip_frag_queue(struct ipq *qp, struct sk_buff *skb)</span>
 		goto err;
 
 	err = -ENOMEM;
<span class="p_del">-	if (pskb_pull(skb, ihl) == NULL)</span>
<span class="p_add">+	if (!pskb_pull(skb, skb_network_offset(skb) + ihl))</span>
 		goto err;
 
 	err = pskb_trim_rcsum(skb, end - offset);
<span class="p_chunk">@@ -638,6 +638,8 @@</span> <span class="p_context"> static int ip_frag_reasm(struct ipq *qp, struct sk_buff *prev,</span>
 	iph-&gt;frag_off = 0;
 	iph-&gt;tot_len = htons(len);
 	iph-&gt;tos |= ecn;
<span class="p_add">+	ip_send_check(iph);</span>
<span class="p_add">+</span>
 	IP_INC_STATS_BH(net, IPSTATS_MIB_REASMOKS);
 	qp-&gt;q.fragments = NULL;
 	qp-&gt;q.fragments_tail = NULL;
<span class="p_header">diff --git a/net/mac80211/debugfs_netdev.c b/net/mac80211/debugfs_netdev.c</span>
<span class="p_header">index 880a55d..0228ecb 100644</span>
<span class="p_header">--- a/net/mac80211/debugfs_netdev.c</span>
<span class="p_header">+++ b/net/mac80211/debugfs_netdev.c</span>
<span class="p_chunk">@@ -598,6 +598,7 @@</span> <span class="p_context"> void ieee80211_debugfs_remove_netdev(struct ieee80211_sub_if_data *sdata)</span>
 
 	debugfs_remove_recursive(sdata-&gt;debugfs.dir);
 	sdata-&gt;debugfs.dir = NULL;
<span class="p_add">+	sdata-&gt;debugfs.subdir_stations = NULL;</span>
 }
 
 void ieee80211_debugfs_rename_netdev(struct ieee80211_sub_if_data *sdata)
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_expect.c b/net/netfilter/nf_conntrack_expect.c</span>
<span class="p_header">index 7918eb7..cec0ed5 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_expect.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_expect.c</span>
<span class="p_chunk">@@ -205,7 +205,8 @@</span> <span class="p_context"> static inline int expect_clash(const struct nf_conntrack_expect *a,</span>
 			a-&gt;mask.src.u3.all[count] &amp; b-&gt;mask.src.u3.all[count];
 	}
 
<span class="p_del">-	return nf_ct_tuple_mask_cmp(&amp;a-&gt;tuple, &amp;b-&gt;tuple, &amp;intersect_mask);</span>
<span class="p_add">+	return nf_ct_tuple_mask_cmp(&amp;a-&gt;tuple, &amp;b-&gt;tuple, &amp;intersect_mask) &amp;&amp;</span>
<span class="p_add">+	       nf_ct_zone(a-&gt;master) == nf_ct_zone(b-&gt;master);</span>
 }
 
 static inline int expect_matches(const struct nf_conntrack_expect *a,
<span class="p_header">diff --git a/net/rds/ib_rdma.c b/net/rds/ib_rdma.c</span>
<span class="p_header">index e8fdb17..a985158 100644</span>
<span class="p_header">--- a/net/rds/ib_rdma.c</span>
<span class="p_header">+++ b/net/rds/ib_rdma.c</span>
<span class="p_chunk">@@ -759,8 +759,10 @@</span> <span class="p_context"> void *rds_ib_get_mr(struct scatterlist *sg, unsigned long nents,</span>
 	}
 
 	ibmr = rds_ib_alloc_fmr(rds_ibdev);
<span class="p_del">-	if (IS_ERR(ibmr))</span>
<span class="p_add">+	if (IS_ERR(ibmr)) {</span>
<span class="p_add">+		rds_ib_dev_put(rds_ibdev);</span>
 		return ibmr;
<span class="p_add">+	}</span>
 
 	ret = rds_ib_map_fmr(rds_ibdev, ibmr, sg, nents);
 	if (ret == 0)
<span class="p_header">diff --git a/net/rose/af_rose.c b/net/rose/af_rose.c</span>
<span class="p_header">index 686fb1a..233dbe6 100644</span>
<span class="p_header">--- a/net/rose/af_rose.c</span>
<span class="p_header">+++ b/net/rose/af_rose.c</span>
<span class="p_chunk">@@ -195,7 +195,8 @@</span> <span class="p_context"> static void rose_kill_by_device(struct net_device *dev)</span>
 
 		if (rose-&gt;device == dev) {
 			rose_disconnect(s, ENETUNREACH, ROSE_OUT_OF_ORDER, 0);
<span class="p_del">-			rose-&gt;neighbour-&gt;use--;</span>
<span class="p_add">+			if (rose-&gt;neighbour)</span>
<span class="p_add">+				rose-&gt;neighbour-&gt;use--;</span>
 			rose-&gt;device = NULL;
 		}
 	}
<span class="p_header">diff --git a/net/sunrpc/backchannel_rqst.c b/net/sunrpc/backchannel_rqst.c</span>
<span class="p_header">index 3ad435a..b56f23e 100644</span>
<span class="p_header">--- a/net/sunrpc/backchannel_rqst.c</span>
<span class="p_header">+++ b/net/sunrpc/backchannel_rqst.c</span>
<span class="p_chunk">@@ -59,7 +59,7 @@</span> <span class="p_context"> static void xprt_free_allocation(struct rpc_rqst *req)</span>
 
 	dprintk(&quot;RPC:        free allocations for req= %p\n&quot;, req);
 	BUG_ON(test_bit(RPC_BC_PA_IN_USE, &amp;req-&gt;rq_bc_pa_state));
<span class="p_del">-	xbufp = &amp;req-&gt;rq_private_buf;</span>
<span class="p_add">+	xbufp = &amp;req-&gt;rq_rcv_buf;</span>
 	free_page((unsigned long)xbufp-&gt;head[0].iov_base);
 	xbufp = &amp;req-&gt;rq_snd_buf;
 	free_page((unsigned long)xbufp-&gt;head[0].iov_base);
<span class="p_header">diff --git a/sound/soc/codecs/wm8737.c b/sound/soc/codecs/wm8737.c</span>
<span class="p_header">index f6aef58..2a012d3 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8737.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8737.c</span>
<span class="p_chunk">@@ -485,7 +485,8 @@</span> <span class="p_context"> static int wm8737_set_bias_level(struct snd_soc_codec *codec,</span>
 
 			/* Fast VMID ramp at 2*2.5k */
 			snd_soc_update_bits(codec, WM8737_MISC_BIAS_CONTROL,
<span class="p_del">-					    WM8737_VMIDSEL_MASK, 0x4);</span>
<span class="p_add">+					    WM8737_VMIDSEL_MASK,</span>
<span class="p_add">+					    2 &lt;&lt; WM8737_VMIDSEL_SHIFT);</span>
 
 			/* Bring VMID up */
 			snd_soc_update_bits(codec, WM8737_POWER_MANAGEMENT,
<span class="p_chunk">@@ -499,7 +500,8 @@</span> <span class="p_context"> static int wm8737_set_bias_level(struct snd_soc_codec *codec,</span>
 
 		/* VMID at 2*300k */
 		snd_soc_update_bits(codec, WM8737_MISC_BIAS_CONTROL,
<span class="p_del">-				    WM8737_VMIDSEL_MASK, 2);</span>
<span class="p_add">+				    WM8737_VMIDSEL_MASK,</span>
<span class="p_add">+				    1 &lt;&lt; WM8737_VMIDSEL_SHIFT);</span>
 
 		break;
 
<span class="p_header">diff --git a/sound/soc/codecs/wm8903.h b/sound/soc/codecs/wm8903.h</span>
<span class="p_header">index db94931..0bb4a64 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8903.h</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8903.h</span>
<span class="p_chunk">@@ -172,7 +172,7 @@</span> <span class="p_context"> extern int wm8903_mic_detect(struct snd_soc_codec *codec,</span>
 #define WM8903_VMID_BUF_ENA_WIDTH                    1  /* VMID_BUF_ENA */
 
 #define WM8903_VMID_RES_50K                          2
<span class="p_del">-#define WM8903_VMID_RES_250K                         3</span>
<span class="p_add">+#define WM8903_VMID_RES_250K                         4</span>
 #define WM8903_VMID_RES_5K                           6
 
 /*
<span class="p_header">diff --git a/sound/soc/codecs/wm8955.c b/sound/soc/codecs/wm8955.c</span>
<span class="p_header">index 77ff1d7..f8b9930 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8955.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8955.c</span>
<span class="p_chunk">@@ -282,7 +282,7 @@</span> <span class="p_context"> static int wm8955_configure_clocking(struct snd_soc_codec *codec)</span>
 		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_2,
 				    WM8955_K_17_9_MASK,
 				    (pll.k &gt;&gt; 9) &amp; WM8955_K_17_9_MASK);
<span class="p_del">-		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_2,</span>
<span class="p_add">+		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_3,</span>
 				    WM8955_K_8_0_MASK,
 				    pll.k &amp; WM8955_K_8_0_MASK);
 		if (pll.k)
<span class="p_header">diff --git a/sound/soc/codecs/wm8960.c b/sound/soc/codecs/wm8960.c</span>
<span class="p_header">index 8d26104..c7911fd 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8960.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8960.c</span>
<span class="p_chunk">@@ -186,7 +186,7 @@</span> <span class="p_context"> SOC_SINGLE(&quot;PCM Playback -6dB Switch&quot;, WM8960_DACCTL1, 7, 1, 0),</span>
 SOC_ENUM(&quot;ADC Polarity&quot;, wm8960_enum[0]),
 SOC_SINGLE(&quot;ADC High Pass Filter Switch&quot;, WM8960_DACCTL1, 0, 1, 0),
 
<span class="p_del">-SOC_ENUM(&quot;DAC Polarity&quot;, wm8960_enum[2]),</span>
<span class="p_add">+SOC_ENUM(&quot;DAC Polarity&quot;, wm8960_enum[1]),</span>
 SOC_SINGLE_BOOL_EXT(&quot;DAC Deemphasis Switch&quot;, 0,
 		    wm8960_get_deemph, wm8960_put_deemph),
 
<span class="p_header">diff --git a/sound/usb/mixer_maps.c b/sound/usb/mixer_maps.c</span>
<span class="p_header">index 851786f..893b750 100644</span>
<span class="p_header">--- a/sound/usb/mixer_maps.c</span>
<span class="p_header">+++ b/sound/usb/mixer_maps.c</span>
<span class="p_chunk">@@ -312,6 +312,20 @@</span> <span class="p_context"> static const struct usbmix_name_map scms_usb3318_map[] = {</span>
 	{ 0 }
 };
 
<span class="p_add">+/* Bose companion 5, the dB conversion factor is 16 instead of 256 */</span>
<span class="p_add">+static struct usbmix_dB_map bose_companion5_dB = {-5006, -6};</span>
<span class="p_add">+static struct usbmix_name_map bose_companion5_map[] = {</span>
<span class="p_add">+	{ 3, NULL, .dB = &amp;bose_companion5_dB },</span>
<span class="p_add">+	{ 0 }	/* terminator */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* Dragonfly DAC 1.2, the dB conversion factor is 1 instead of 256 */</span>
<span class="p_add">+static struct usbmix_dB_map dragonfly_1_2_dB = {0, 5000};</span>
<span class="p_add">+static struct usbmix_name_map dragonfly_1_2_map[] = {</span>
<span class="p_add">+	{ 7, NULL, .dB = &amp;dragonfly_1_2_dB },</span>
<span class="p_add">+	{ 0 }	/* terminator */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /*
  * Control map entries
  */
<span class="p_chunk">@@ -394,6 +408,16 @@</span> <span class="p_context"> static struct usbmix_ctl_map usbmix_ctl_maps[] = {</span>
 		.id = USB_ID(0x25c4, 0x0003),
 		.map = scms_usb3318_map,
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		/* Bose Companion 5 */</span>
<span class="p_add">+		.id = USB_ID(0x05a7, 0x1020),</span>
<span class="p_add">+		.map = bose_companion5_map,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		/* Dragonfly DAC 1.2 */</span>
<span class="p_add">+		.id = USB_ID(0x21b4, 0x0081),</span>
<span class="p_add">+		.map = dragonfly_1_2_map,</span>
<span class="p_add">+	},</span>
 	{ 0 } /* terminator */
 };
 
<span class="p_header">diff --git a/sound/usb/quirks-table.h b/sound/usb/quirks-table.h</span>
<span class="p_header">index b38dde0..c014f00 100644</span>
<span class="p_header">--- a/sound/usb/quirks-table.h</span>
<span class="p_header">+++ b/sound/usb/quirks-table.h</span>
<span class="p_chunk">@@ -2383,6 +2383,74 @@</span> <span class="p_context"> YAMAHA_DEVICE(0x7010, &quot;UB99&quot;),</span>
 	}
 },
 
<span class="p_add">+/* Steinberg devices */</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Steinberg MI2 */</span>
<span class="p_add">+	USB_DEVICE_VENDOR_SPEC(0x0a4e, 0x2040),</span>
<span class="p_add">+	.driver_info = (unsigned long) &amp; (const struct snd_usb_audio_quirk) {</span>
<span class="p_add">+		.ifnum = QUIRK_ANY_INTERFACE,</span>
<span class="p_add">+		.type = QUIRK_COMPOSITE,</span>
<span class="p_add">+		.data = &amp; (const struct snd_usb_audio_quirk[]) {</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 0,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_INTERFACE</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 1,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_INTERFACE</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 2,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_INTERFACE</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 3,</span>
<span class="p_add">+				.type = QUIRK_MIDI_FIXED_ENDPOINT,</span>
<span class="p_add">+				.data = &amp;(const struct snd_usb_midi_endpoint_info) {</span>
<span class="p_add">+					.out_cables = 0x0001,</span>
<span class="p_add">+					.in_cables  = 0x0001</span>
<span class="p_add">+				}</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = -1</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+},</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Steinberg MI4 */</span>
<span class="p_add">+	USB_DEVICE_VENDOR_SPEC(0x0a4e, 0x4040),</span>
<span class="p_add">+	.driver_info = (unsigned long) &amp; (const struct snd_usb_audio_quirk) {</span>
<span class="p_add">+		.ifnum = QUIRK_ANY_INTERFACE,</span>
<span class="p_add">+		.type = QUIRK_COMPOSITE,</span>
<span class="p_add">+		.data = &amp; (const struct snd_usb_audio_quirk[]) {</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 0,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_INTERFACE</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 1,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_INTERFACE</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 2,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_INTERFACE</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 3,</span>
<span class="p_add">+				.type = QUIRK_MIDI_FIXED_ENDPOINT,</span>
<span class="p_add">+				.data = &amp;(const struct snd_usb_midi_endpoint_info) {</span>
<span class="p_add">+					.out_cables = 0x0001,</span>
<span class="p_add">+					.in_cables  = 0x0001</span>
<span class="p_add">+				}</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = -1</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+},</span>
<span class="p_add">+</span>
 /* TerraTec devices */
 {
 	USB_DEVICE_VENDOR_SPEC(0x0ccd, 0x0012),

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



