
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.9.76 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.9.76</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 10, 2018, 9:10 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20180110091048.GB18699@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10154609/mbox/"
   >mbox</a>
|
   <a href="/patch/10154609/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10154609/">/patch/10154609/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	81D85602D8 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 10 Jan 2018 09:11:09 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 6FB39283D1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 10 Jan 2018 09:11:09 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 620AE28419; Wed, 10 Jan 2018 09:11:09 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id E1F58283D1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 10 Jan 2018 09:11:07 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1756065AbeAJJLG (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 10 Jan 2018 04:11:06 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:53366 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1755815AbeAJJK6 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 10 Jan 2018 04:10:58 -0500
Received: from localhost (unknown [37.170.134.120])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id BDC43EDB;
	Wed, 10 Jan 2018 09:10:56 +0000 (UTC)
Date: Wed, 10 Jan 2018 10:10:48 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.9.76
Message-ID: &lt;20180110091048.GB18699@kroah.com&gt;
References: &lt;20180110091044.GA18699@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20180110091044.GA18699@kroah.com&gt;
User-Agent: Mutt/1.9.2 (2017-12-15)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Jan. 10, 2018, 9:10 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index acbc1b032db2..2637f0ed0a07 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 9
<span class="p_del">-SUBLEVEL = 75</span>
<span class="p_add">+SUBLEVEL = 76</span>
 EXTRAVERSION =
 NAME = Roaring Lionus
 
<span class="p_header">diff --git a/arch/arc/include/asm/uaccess.h b/arch/arc/include/asm/uaccess.h</span>
<span class="p_header">index 41faf17cd28d..0684fd2f42e8 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -673,6 +673,7 @@</span> <span class="p_context"> __arc_strncpy_from_user(char *dst, const char __user *src, long count)</span>
 		return 0;
 
 	__asm__ __volatile__(
<span class="p_add">+	&quot;	mov	lp_count, %5		\n&quot;</span>
 	&quot;	lp	3f			\n&quot;
 	&quot;1:	ldb.ab  %3, [%2, 1]		\n&quot;
 	&quot;	breq.d	%3, 0, 3f               \n&quot;
<span class="p_chunk">@@ -689,8 +690,8 @@</span> <span class="p_context"> __arc_strncpy_from_user(char *dst, const char __user *src, long count)</span>
 	&quot;	.word   1b, 4b			\n&quot;
 	&quot;	.previous			\n&quot;
 	: &quot;+r&quot;(res), &quot;+r&quot;(dst), &quot;+r&quot;(src), &quot;=r&quot;(val)
<span class="p_del">-	: &quot;g&quot;(-EFAULT), &quot;l&quot;(count)</span>
<span class="p_del">-	: &quot;memory&quot;);</span>
<span class="p_add">+	: &quot;g&quot;(-EFAULT), &quot;r&quot;(count)</span>
<span class="p_add">+	: &quot;lp_count&quot;, &quot;lp_start&quot;, &quot;lp_end&quot;, &quot;memory&quot;);</span>
 
 	return res;
 }
<span class="p_header">diff --git a/arch/parisc/include/asm/ldcw.h b/arch/parisc/include/asm/ldcw.h</span>
<span class="p_header">index 8be707e1b6c7..82dea145574e 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/ldcw.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/ldcw.h</span>
<span class="p_chunk">@@ -11,6 +11,7 @@</span> <span class="p_context"></span>
    for the semaphore.  */
 
 #define __PA_LDCW_ALIGNMENT	16
<span class="p_add">+#define __PA_LDCW_ALIGN_ORDER	4</span>
 #define __ldcw_align(a) ({					\
 	unsigned long __ret = (unsigned long) &amp;(a)-&gt;lock[0];	\
 	__ret = (__ret + __PA_LDCW_ALIGNMENT - 1)		\
<span class="p_chunk">@@ -28,6 +29,7 @@</span> <span class="p_context"></span>
    ldcd). */
 
 #define __PA_LDCW_ALIGNMENT	4
<span class="p_add">+#define __PA_LDCW_ALIGN_ORDER	2</span>
 #define __ldcw_align(a) (&amp;(a)-&gt;slock)
 #define __LDCW	&quot;ldcw,co&quot;
 
<span class="p_header">diff --git a/arch/parisc/kernel/entry.S b/arch/parisc/kernel/entry.S</span>
<span class="p_header">index 4fcff2dcc9c3..e3d3e8e1d708 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/entry.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/entry.S</span>
<span class="p_chunk">@@ -35,6 +35,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/signal.h&gt;
 #include &lt;asm/unistd.h&gt;
<span class="p_add">+#include &lt;asm/ldcw.h&gt;</span>
 #include &lt;asm/thread_info.h&gt;
 
 #include &lt;linux/linkage.h&gt;
<span class="p_chunk">@@ -46,6 +47,14 @@</span> <span class="p_context"></span>
 #endif
 
 	.import		pa_tlb_lock,data
<span class="p_add">+	.macro  load_pa_tlb_lock reg</span>
<span class="p_add">+#if __PA_LDCW_ALIGNMENT &gt; 4</span>
<span class="p_add">+	load32	PA(pa_tlb_lock) + __PA_LDCW_ALIGNMENT-1, \reg</span>
<span class="p_add">+	depi	0,31,__PA_LDCW_ALIGN_ORDER, \reg</span>
<span class="p_add">+#else</span>
<span class="p_add">+	load32	PA(pa_tlb_lock), \reg</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	.endm</span>
 
 	/* space_to_prot macro creates a prot id from a space id */
 
<span class="p_chunk">@@ -457,7 +466,7 @@</span> <span class="p_context"></span>
 	.macro		tlb_lock	spc,ptp,pte,tmp,tmp1,fault
 #ifdef CONFIG_SMP
 	cmpib,COND(=),n	0,\spc,2f
<span class="p_del">-	load32		PA(pa_tlb_lock),\tmp</span>
<span class="p_add">+	load_pa_tlb_lock \tmp</span>
 1:	LDCW		0(\tmp),\tmp1
 	cmpib,COND(=)	0,\tmp1,1b
 	nop
<span class="p_chunk">@@ -480,7 +489,7 @@</span> <span class="p_context"></span>
 	/* Release pa_tlb_lock lock. */
 	.macro		tlb_unlock1	spc,tmp
 #ifdef CONFIG_SMP
<span class="p_del">-	load32		PA(pa_tlb_lock),\tmp</span>
<span class="p_add">+	load_pa_tlb_lock \tmp</span>
 	tlb_unlock0	\spc,\tmp
 #endif
 	.endm
<span class="p_header">diff --git a/arch/parisc/kernel/pacache.S b/arch/parisc/kernel/pacache.S</span>
<span class="p_header">index adf7187f8951..2d40c4ff3f69 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/pacache.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/pacache.S</span>
<span class="p_chunk">@@ -36,6 +36,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/assembly.h&gt;
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/cache.h&gt;
<span class="p_add">+#include &lt;asm/ldcw.h&gt;</span>
 #include &lt;linux/linkage.h&gt;
 
 	.text
<span class="p_chunk">@@ -333,8 +334,12 @@</span> <span class="p_context"> ENDPROC_CFI(flush_data_cache_local)</span>
 
 	.macro	tlb_lock	la,flags,tmp
 #ifdef CONFIG_SMP
<span class="p_del">-	ldil		L%pa_tlb_lock,%r1</span>
<span class="p_del">-	ldo		R%pa_tlb_lock(%r1),\la</span>
<span class="p_add">+#if __PA_LDCW_ALIGNMENT &gt; 4</span>
<span class="p_add">+	load32		pa_tlb_lock + __PA_LDCW_ALIGNMENT-1, \la</span>
<span class="p_add">+	depi		0,31,__PA_LDCW_ALIGN_ORDER, \la</span>
<span class="p_add">+#else</span>
<span class="p_add">+	load32		pa_tlb_lock, \la</span>
<span class="p_add">+#endif</span>
 	rsm		PSW_SM_I,\flags
 1:	LDCW		0(\la),\tmp
 	cmpib,&lt;&gt;,n	0,\tmp,3f
<span class="p_header">diff --git a/arch/parisc/kernel/process.c b/arch/parisc/kernel/process.c</span>
<span class="p_header">index 7593787ed4c3..c3a532abac03 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/process.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/process.c</span>
<span class="p_chunk">@@ -39,6 +39,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/fs.h&gt;
<span class="p_add">+#include &lt;linux/cpu.h&gt;</span>
 #include &lt;linux/module.h&gt;
 #include &lt;linux/personality.h&gt;
 #include &lt;linux/ptrace.h&gt;
<span class="p_chunk">@@ -180,6 +181,44 @@</span> <span class="p_context"> int dump_task_fpu (struct task_struct *tsk, elf_fpregset_t *r)</span>
 	return 1;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Idle thread support</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Detect when running on QEMU with SeaBIOS PDC Firmware and let</span>
<span class="p_add">+ * QEMU idle the host too.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+int running_on_qemu __read_mostly;</span>
<span class="p_add">+</span>
<span class="p_add">+void __cpuidle arch_cpu_idle_dead(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* nop on real hardware, qemu will offline CPU. */</span>
<span class="p_add">+	asm volatile(&quot;or %%r31,%%r31,%%r31\n&quot;:::);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __cpuidle arch_cpu_idle(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	local_irq_enable();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* nop on real hardware, qemu will idle sleep. */</span>
<span class="p_add">+	asm volatile(&quot;or %%r10,%%r10,%%r10\n&quot;:::);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init parisc_idle_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const char *marker;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* check QEMU/SeaBIOS marker in PAGE0 */</span>
<span class="p_add">+	marker = (char *) &amp;PAGE0-&gt;pad0;</span>
<span class="p_add">+	running_on_qemu = (memcmp(marker, &quot;SeaBIOS&quot;, 8) == 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!running_on_qemu)</span>
<span class="p_add">+		cpu_idle_poll_ctrl(1);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+arch_initcall(parisc_idle_init);</span>
<span class="p_add">+</span>
 /*
  * Copy architecture-specific thread state
  */
<span class="p_header">diff --git a/arch/s390/kernel/compat_linux.c b/arch/s390/kernel/compat_linux.c</span>
<span class="p_header">index 0f9cd90c11af..f06a9a0063f1 100644</span>
<span class="p_header">--- a/arch/s390/kernel/compat_linux.c</span>
<span class="p_header">+++ b/arch/s390/kernel/compat_linux.c</span>
<span class="p_chunk">@@ -263,6 +263,7 @@</span> <span class="p_context"> COMPAT_SYSCALL_DEFINE2(s390_setgroups16, int, gidsetsize, u16 __user *, grouplis</span>
 		return retval;
 	}
 
<span class="p_add">+	groups_sort(group_info);</span>
 	retval = set_current_groups(group_info);
 	put_group_info(group_info);
 
<span class="p_header">diff --git a/arch/x86/entry/vsyscall/vsyscall_64.c b/arch/x86/entry/vsyscall/vsyscall_64.c</span>
<span class="p_header">index 636c4b341f36..6bb7e92c6d50 100644</span>
<span class="p_header">--- a/arch/x86/entry/vsyscall/vsyscall_64.c</span>
<span class="p_header">+++ b/arch/x86/entry/vsyscall/vsyscall_64.c</span>
<span class="p_chunk">@@ -66,6 +66,11 @@</span> <span class="p_context"> static int __init vsyscall_setup(char *str)</span>
 }
 early_param(&quot;vsyscall&quot;, vsyscall_setup);
 
<span class="p_add">+bool vsyscall_enabled(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return vsyscall_mode != NONE;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void warn_bad_vsyscall(const char *level, struct pt_regs *regs,
 			      const char *message)
 {
<span class="p_header">diff --git a/arch/x86/include/asm/vsyscall.h b/arch/x86/include/asm/vsyscall.h</span>
<span class="p_header">index 6ba66ee79710..4865e10dbb55 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/vsyscall.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/vsyscall.h</span>
<span class="p_chunk">@@ -12,12 +12,14 @@</span> <span class="p_context"> extern void map_vsyscall(void);</span>
  * Returns true if handled.
  */
 extern bool emulate_vsyscall(struct pt_regs *regs, unsigned long address);
<span class="p_add">+extern bool vsyscall_enabled(void);</span>
 #else
 static inline void map_vsyscall(void) {}
 static inline bool emulate_vsyscall(struct pt_regs *regs, unsigned long address)
 {
 	return false;
 }
<span class="p_add">+static inline bool vsyscall_enabled(void) { return false; }</span>
 #endif
 
 #endif /* _ASM_X86_VSYSCALL_H */
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/amd.c b/arch/x86/kernel/cpu/microcode/amd.c</span>
<span class="p_header">index 017bda12caae..b74bb29db6b9 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/amd.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/amd.c</span>
<span class="p_chunk">@@ -592,6 +592,7 @@</span> <span class="p_context"> static unsigned int verify_patch_size(u8 family, u32 patch_size,</span>
 #define F14H_MPB_MAX_SIZE 1824
 #define F15H_MPB_MAX_SIZE 4096
 #define F16H_MPB_MAX_SIZE 3458
<span class="p_add">+#define F17H_MPB_MAX_SIZE 3200</span>
 
 	switch (family) {
 	case 0x14:
<span class="p_chunk">@@ -603,6 +604,9 @@</span> <span class="p_context"> static unsigned int verify_patch_size(u8 family, u32 patch_size,</span>
 	case 0x16:
 		max_size = F16H_MPB_MAX_SIZE;
 		break;
<span class="p_add">+	case 0x17:</span>
<span class="p_add">+		max_size = F17H_MPB_MAX_SIZE;</span>
<span class="p_add">+		break;</span>
 	default:
 		max_size = F1XH_MPB_MAX_SIZE;
 		break;
<span class="p_header">diff --git a/arch/x86/mm/init.c b/arch/x86/mm/init.c</span>
<span class="p_header">index 1e779bca4f3e..f92bdb9f4e46 100644</span>
<span class="p_header">--- a/arch/x86/mm/init.c</span>
<span class="p_header">+++ b/arch/x86/mm/init.c</span>
<span class="p_chunk">@@ -768,7 +768,7 @@</span> <span class="p_context"> DEFINE_PER_CPU_SHARED_ALIGNED(struct tlb_state, cpu_tlbstate) = {</span>
 	.state = 0,
 	.cr4 = ~0UL,	/* fail hard if we screw up cr4 shadow initialization */
 };
<span class="p_del">-EXPORT_SYMBOL_GPL(cpu_tlbstate);</span>
<span class="p_add">+EXPORT_PER_CPU_SYMBOL(cpu_tlbstate);</span>
 
 void update_cache_mode_entry(unsigned entry, enum page_cache_mode cache)
 {
<span class="p_header">diff --git a/arch/x86/mm/kaiser.c b/arch/x86/mm/kaiser.c</span>
<span class="p_header">index d8376b4ad9f0..8f8e5e03d083 100644</span>
<span class="p_header">--- a/arch/x86/mm/kaiser.c</span>
<span class="p_header">+++ b/arch/x86/mm/kaiser.c</span>
<span class="p_chunk">@@ -19,6 +19,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/pgalloc.h&gt;
 #include &lt;asm/desc.h&gt;
 #include &lt;asm/cmdline.h&gt;
<span class="p_add">+#include &lt;asm/vsyscall.h&gt;</span>
 
 int kaiser_enabled __read_mostly = 1;
 EXPORT_SYMBOL(kaiser_enabled);	/* for inlined TLB flush functions */
<span class="p_chunk">@@ -110,12 +111,13 @@</span> <span class="p_context"> static inline unsigned long get_pa_from_mapping(unsigned long vaddr)</span>
  *
  * Returns a pointer to a PTE on success, or NULL on failure.
  */
<span class="p_del">-static pte_t *kaiser_pagetable_walk(unsigned long address)</span>
<span class="p_add">+static pte_t *kaiser_pagetable_walk(unsigned long address, bool user)</span>
 {
 	pmd_t *pmd;
 	pud_t *pud;
 	pgd_t *pgd = native_get_shadow_pgd(pgd_offset_k(address));
 	gfp_t gfp = (GFP_KERNEL | __GFP_NOTRACK | __GFP_ZERO);
<span class="p_add">+	unsigned long prot = _KERNPG_TABLE;</span>
 
 	if (pgd_none(*pgd)) {
 		WARN_ONCE(1, &quot;All shadow pgds should have been populated&quot;);
<span class="p_chunk">@@ -123,6 +125,17 @@</span> <span class="p_context"> static pte_t *kaiser_pagetable_walk(unsigned long address)</span>
 	}
 	BUILD_BUG_ON(pgd_large(*pgd) != 0);
 
<span class="p_add">+	if (user) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The vsyscall page is the only page that will have</span>
<span class="p_add">+		 *  _PAGE_USER set. Catch everything else.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		BUG_ON(address != VSYSCALL_ADDR);</span>
<span class="p_add">+</span>
<span class="p_add">+		set_pgd(pgd, __pgd(pgd_val(*pgd) | _PAGE_USER));</span>
<span class="p_add">+		prot = _PAGE_TABLE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	pud = pud_offset(pgd, address);
 	/* The shadow page tables do not use large mappings: */
 	if (pud_large(*pud)) {
<span class="p_chunk">@@ -135,7 +148,7 @@</span> <span class="p_context"> static pte_t *kaiser_pagetable_walk(unsigned long address)</span>
 			return NULL;
 		spin_lock(&amp;shadow_table_allocation_lock);
 		if (pud_none(*pud)) {
<span class="p_del">-			set_pud(pud, __pud(_KERNPG_TABLE | __pa(new_pmd_page)));</span>
<span class="p_add">+			set_pud(pud, __pud(prot | __pa(new_pmd_page)));</span>
 			__inc_zone_page_state(virt_to_page((void *)
 						new_pmd_page), NR_KAISERTABLE);
 		} else
<span class="p_chunk">@@ -155,7 +168,7 @@</span> <span class="p_context"> static pte_t *kaiser_pagetable_walk(unsigned long address)</span>
 			return NULL;
 		spin_lock(&amp;shadow_table_allocation_lock);
 		if (pmd_none(*pmd)) {
<span class="p_del">-			set_pmd(pmd, __pmd(_KERNPG_TABLE | __pa(new_pte_page)));</span>
<span class="p_add">+			set_pmd(pmd, __pmd(prot | __pa(new_pte_page)));</span>
 			__inc_zone_page_state(virt_to_page((void *)
 						new_pte_page), NR_KAISERTABLE);
 		} else
<span class="p_chunk">@@ -191,7 +204,7 @@</span> <span class="p_context"> static int kaiser_add_user_map(const void *__start_addr, unsigned long size,</span>
 			ret = -EIO;
 			break;
 		}
<span class="p_del">-		pte = kaiser_pagetable_walk(address);</span>
<span class="p_add">+		pte = kaiser_pagetable_walk(address, flags &amp; _PAGE_USER);</span>
 		if (!pte) {
 			ret = -ENOMEM;
 			break;
<span class="p_chunk">@@ -318,6 +331,19 @@</span> <span class="p_context"> void __init kaiser_init(void)</span>
 
 	kaiser_init_all_pgds();
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Note that this sets _PAGE_USER and it needs to happen when the</span>
<span class="p_add">+	 * pagetable hierarchy gets created, i.e., early. Otherwise</span>
<span class="p_add">+	 * kaiser_pagetable_walk() will encounter initialized PTEs in the</span>
<span class="p_add">+	 * hierarchy and not set the proper permissions, leading to the</span>
<span class="p_add">+	 * pagefaults with page-protection violations when trying to read the</span>
<span class="p_add">+	 * vsyscall page. For example.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (vsyscall_enabled())</span>
<span class="p_add">+		kaiser_add_user_map_early((void *)VSYSCALL_ADDR,</span>
<span class="p_add">+					  PAGE_SIZE,</span>
<span class="p_add">+					   __PAGE_KERNEL_VSYSCALL);</span>
<span class="p_add">+</span>
 	for_each_possible_cpu(cpu) {
 		void *percpu_vaddr = __per_cpu_user_mapped_start +
 				     per_cpu_offset(cpu);
<span class="p_header">diff --git a/crypto/chacha20poly1305.c b/crypto/chacha20poly1305.c</span>
<span class="p_header">index e899ef51dc8e..cb1c3a3287b0 100644</span>
<span class="p_header">--- a/crypto/chacha20poly1305.c</span>
<span class="p_header">+++ b/crypto/chacha20poly1305.c</span>
<span class="p_chunk">@@ -610,6 +610,11 @@</span> <span class="p_context"> static int chachapoly_create(struct crypto_template *tmpl, struct rtattr **tb,</span>
 						    algt-&gt;mask));
 	if (IS_ERR(poly))
 		return PTR_ERR(poly);
<span class="p_add">+	poly_hash = __crypto_hash_alg_common(poly);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = -EINVAL;</span>
<span class="p_add">+	if (poly_hash-&gt;digestsize != POLY1305_DIGEST_SIZE)</span>
<span class="p_add">+		goto out_put_poly;</span>
 
 	err = -ENOMEM;
 	inst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);
<span class="p_chunk">@@ -618,7 +623,6 @@</span> <span class="p_context"> static int chachapoly_create(struct crypto_template *tmpl, struct rtattr **tb,</span>
 
 	ctx = aead_instance_ctx(inst);
 	ctx-&gt;saltlen = CHACHAPOLY_IV_SIZE - ivsize;
<span class="p_del">-	poly_hash = __crypto_hash_alg_common(poly);</span>
 	err = crypto_init_ahash_spawn(&amp;ctx-&gt;poly, poly_hash,
 				      aead_crypto_instance(inst));
 	if (err)
<span class="p_header">diff --git a/crypto/pcrypt.c b/crypto/pcrypt.c</span>
<span class="p_header">index ee9cfb99fe25..f8ec3d4ba4a8 100644</span>
<span class="p_header">--- a/crypto/pcrypt.c</span>
<span class="p_header">+++ b/crypto/pcrypt.c</span>
<span class="p_chunk">@@ -254,6 +254,14 @@</span> <span class="p_context"> static void pcrypt_aead_exit_tfm(struct crypto_aead *tfm)</span>
 	crypto_free_aead(ctx-&gt;child);
 }
 
<span class="p_add">+static void pcrypt_free(struct aead_instance *inst)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pcrypt_instance_ctx *ctx = aead_instance_ctx(inst);</span>
<span class="p_add">+</span>
<span class="p_add">+	crypto_drop_aead(&amp;ctx-&gt;spawn);</span>
<span class="p_add">+	kfree(inst);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int pcrypt_init_instance(struct crypto_instance *inst,
 				struct crypto_alg *alg)
 {
<span class="p_chunk">@@ -319,6 +327,8 @@</span> <span class="p_context"> static int pcrypt_create_aead(struct crypto_template *tmpl, struct rtattr **tb,</span>
 	inst-&gt;alg.encrypt = pcrypt_aead_encrypt;
 	inst-&gt;alg.decrypt = pcrypt_aead_decrypt;
 
<span class="p_add">+	inst-&gt;free = pcrypt_free;</span>
<span class="p_add">+</span>
 	err = aead_register_instance(tmpl, inst);
 	if (err)
 		goto out_drop_aead;
<span class="p_chunk">@@ -349,14 +359,6 @@</span> <span class="p_context"> static int pcrypt_create(struct crypto_template *tmpl, struct rtattr **tb)</span>
 	return -EINVAL;
 }
 
<span class="p_del">-static void pcrypt_free(struct crypto_instance *inst)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct pcrypt_instance_ctx *ctx = crypto_instance_ctx(inst);</span>
<span class="p_del">-</span>
<span class="p_del">-	crypto_drop_aead(&amp;ctx-&gt;spawn);</span>
<span class="p_del">-	kfree(inst);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int pcrypt_cpumask_change_notify(struct notifier_block *self,
 					unsigned long val, void *data)
 {
<span class="p_chunk">@@ -469,7 +471,6 @@</span> <span class="p_context"> static void pcrypt_fini_padata(struct padata_pcrypt *pcrypt)</span>
 static struct crypto_template pcrypt_tmpl = {
 	.name = &quot;pcrypt&quot;,
 	.create = pcrypt_create,
<span class="p_del">-	.free = pcrypt_free,</span>
 	.module = THIS_MODULE,
 };
 
<span class="p_header">diff --git a/drivers/block/nbd.c b/drivers/block/nbd.c</span>
<span class="p_header">index 7d506cb73e54..4d30da269060 100644</span>
<span class="p_header">--- a/drivers/block/nbd.c</span>
<span class="p_header">+++ b/drivers/block/nbd.c</span>
<span class="p_chunk">@@ -272,6 +272,7 @@</span> <span class="p_context"> static int nbd_send_cmd(struct nbd_device *nbd, struct nbd_cmd *cmd)</span>
 	int result, flags;
 	struct nbd_request request;
 	unsigned long size = blk_rq_bytes(req);
<span class="p_add">+	struct bio *bio;</span>
 	u32 type;
 
 	if (req-&gt;cmd_type == REQ_TYPE_DRV_PRIV)
<span class="p_chunk">@@ -305,16 +306,20 @@</span> <span class="p_context"> static int nbd_send_cmd(struct nbd_device *nbd, struct nbd_cmd *cmd)</span>
 		return -EIO;
 	}
 
<span class="p_del">-	if (type == NBD_CMD_WRITE) {</span>
<span class="p_del">-		struct req_iterator iter;</span>
<span class="p_add">+	if (type != NBD_CMD_WRITE)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	flags = 0;</span>
<span class="p_add">+	bio = req-&gt;bio;</span>
<span class="p_add">+	while (bio) {</span>
<span class="p_add">+		struct bio *next = bio-&gt;bi_next;</span>
<span class="p_add">+		struct bvec_iter iter;</span>
 		struct bio_vec bvec;
<span class="p_del">-		/*</span>
<span class="p_del">-		 * we are really probing at internals to determine</span>
<span class="p_del">-		 * whether to set MSG_MORE or not...</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		rq_for_each_segment(bvec, req, iter) {</span>
<span class="p_del">-			flags = 0;</span>
<span class="p_del">-			if (!rq_iter_last(bvec, iter))</span>
<span class="p_add">+</span>
<span class="p_add">+		bio_for_each_segment(bvec, bio, iter) {</span>
<span class="p_add">+			bool is_last = !next &amp;&amp; bio_iter_last(bvec, iter);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (is_last)</span>
 				flags = MSG_MORE;
 			dev_dbg(nbd_to_dev(nbd), &quot;request %p: sending %d bytes data\n&quot;,
 				cmd, bvec.bv_len);
<span class="p_chunk">@@ -325,7 +330,16 @@</span> <span class="p_context"> static int nbd_send_cmd(struct nbd_device *nbd, struct nbd_cmd *cmd)</span>
 					result);
 				return -EIO;
 			}
<span class="p_add">+			/*</span>
<span class="p_add">+			 * The completion might already have come in,</span>
<span class="p_add">+			 * so break for the last one instead of letting</span>
<span class="p_add">+			 * the iterator do it. This prevents use-after-free</span>
<span class="p_add">+			 * of the bio.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (is_last)</span>
<span class="p_add">+				break;</span>
 		}
<span class="p_add">+		bio = next;</span>
 	}
 	return 0;
 }
<span class="p_header">diff --git a/drivers/bus/sunxi-rsb.c b/drivers/bus/sunxi-rsb.c</span>
<span class="p_header">index 795c9d9c96a6..2051d926e303 100644</span>
<span class="p_header">--- a/drivers/bus/sunxi-rsb.c</span>
<span class="p_header">+++ b/drivers/bus/sunxi-rsb.c</span>
<span class="p_chunk">@@ -178,6 +178,7 @@</span> <span class="p_context"> static struct bus_type sunxi_rsb_bus = {</span>
 	.match		= sunxi_rsb_device_match,
 	.probe		= sunxi_rsb_device_probe,
 	.remove		= sunxi_rsb_device_remove,
<span class="p_add">+	.uevent		= of_device_uevent_modalias,</span>
 };
 
 static void sunxi_rsb_dev_release(struct device *dev)
<span class="p_header">diff --git a/drivers/crypto/n2_core.c b/drivers/crypto/n2_core.c</span>
<span class="p_header">index c5aac25a5738..b365ad78ac27 100644</span>
<span class="p_header">--- a/drivers/crypto/n2_core.c</span>
<span class="p_header">+++ b/drivers/crypto/n2_core.c</span>
<span class="p_chunk">@@ -1620,6 +1620,7 @@</span> <span class="p_context"> static int queue_cache_init(void)</span>
 					  CWQ_ENTRY_SIZE, 0, NULL);
 	if (!queue_cache[HV_NCS_QTYPE_CWQ - 1]) {
 		kmem_cache_destroy(queue_cache[HV_NCS_QTYPE_MAU - 1]);
<span class="p_add">+		queue_cache[HV_NCS_QTYPE_MAU - 1] = NULL;</span>
 		return -ENOMEM;
 	}
 	return 0;
<span class="p_chunk">@@ -1629,6 +1630,8 @@</span> <span class="p_context"> static void queue_cache_destroy(void)</span>
 {
 	kmem_cache_destroy(queue_cache[HV_NCS_QTYPE_MAU - 1]);
 	kmem_cache_destroy(queue_cache[HV_NCS_QTYPE_CWQ - 1]);
<span class="p_add">+	queue_cache[HV_NCS_QTYPE_MAU - 1] = NULL;</span>
<span class="p_add">+	queue_cache[HV_NCS_QTYPE_CWQ - 1] = NULL;</span>
 }
 
 static int spu_queue_register(struct spu_queue *p, unsigned long q_type)
<span class="p_header">diff --git a/drivers/input/mouse/elantech.c b/drivers/input/mouse/elantech.c</span>
<span class="p_header">index cd834da5934a..59603a5728f7 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.c</span>
<span class="p_chunk">@@ -1609,7 +1609,7 @@</span> <span class="p_context"> static int elantech_set_properties(struct elantech_data *etd)</span>
 		case 5:
 			etd-&gt;hw_version = 3;
 			break;
<span class="p_del">-		case 6 ... 14:</span>
<span class="p_add">+		case 6 ... 15:</span>
 			etd-&gt;hw_version = 4;
 			break;
 		default:
<span class="p_header">diff --git a/drivers/iommu/arm-smmu-v3.c b/drivers/iommu/arm-smmu-v3.c</span>
<span class="p_header">index d3d975ae24b7..7f294f785ce6 100644</span>
<span class="p_header">--- a/drivers/iommu/arm-smmu-v3.c</span>
<span class="p_header">+++ b/drivers/iommu/arm-smmu-v3.c</span>
<span class="p_chunk">@@ -1547,13 +1547,15 @@</span> <span class="p_context"> static int arm_smmu_domain_finalise(struct iommu_domain *domain)</span>
 	domain-&gt;pgsize_bitmap = pgtbl_cfg.pgsize_bitmap;
 	domain-&gt;geometry.aperture_end = (1UL &lt;&lt; ias) - 1;
 	domain-&gt;geometry.force_aperture = true;
<span class="p_del">-	smmu_domain-&gt;pgtbl_ops = pgtbl_ops;</span>
 
 	ret = finalise_stage_fn(smmu_domain, &amp;pgtbl_cfg);
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
 		free_io_pgtable_ops(pgtbl_ops);
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	smmu_domain-&gt;pgtbl_ops = pgtbl_ops;</span>
<span class="p_add">+	return 0;</span>
 }
 
 static __le64 *arm_smmu_get_step_for_sid(struct arm_smmu_device *smmu, u32 sid)
<span class="p_chunk">@@ -1580,7 +1582,7 @@</span> <span class="p_context"> static __le64 *arm_smmu_get_step_for_sid(struct arm_smmu_device *smmu, u32 sid)</span>
 
 static int arm_smmu_install_ste_for_dev(struct iommu_fwspec *fwspec)
 {
<span class="p_del">-	int i;</span>
<span class="p_add">+	int i, j;</span>
 	struct arm_smmu_master_data *master = fwspec-&gt;iommu_priv;
 	struct arm_smmu_device *smmu = master-&gt;smmu;
 
<span class="p_chunk">@@ -1588,6 +1590,13 @@</span> <span class="p_context"> static int arm_smmu_install_ste_for_dev(struct iommu_fwspec *fwspec)</span>
 		u32 sid = fwspec-&gt;ids[i];
 		__le64 *step = arm_smmu_get_step_for_sid(smmu, sid);
 
<span class="p_add">+		/* Bridged PCI devices may end up with duplicated IDs */</span>
<span class="p_add">+		for (j = 0; j &lt; i; j++)</span>
<span class="p_add">+			if (fwspec-&gt;ids[j] == sid)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+		if (j &lt; i)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		arm_smmu_write_strtab_ent(smmu, sid, step, &amp;master-&gt;ste);
 	}
 
<span class="p_header">diff --git a/drivers/mtd/nand/pxa3xx_nand.c b/drivers/mtd/nand/pxa3xx_nand.c</span>
<span class="p_header">index b121bf4ed73a..3b8911cd3a19 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/pxa3xx_nand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/pxa3xx_nand.c</span>
<span class="p_chunk">@@ -950,6 +950,7 @@</span> <span class="p_context"> static void prepare_start_command(struct pxa3xx_nand_info *info, int command)</span>
 
 	switch (command) {
 	case NAND_CMD_READ0:
<span class="p_add">+	case NAND_CMD_READOOB:</span>
 	case NAND_CMD_PAGEPROG:
 		info-&gt;use_ecc = 1;
 		break;
<span class="p_header">diff --git a/fs/nfsd/auth.c b/fs/nfsd/auth.c</span>
<span class="p_header">index 62469c60be23..75f942ae5176 100644</span>
<span class="p_header">--- a/fs/nfsd/auth.c</span>
<span class="p_header">+++ b/fs/nfsd/auth.c</span>
<span class="p_chunk">@@ -59,6 +59,9 @@</span> <span class="p_context"> int nfsd_setuser(struct svc_rqst *rqstp, struct svc_export *exp)</span>
 				gi-&gt;gid[i] = exp-&gt;ex_anon_gid;
 			else
 				gi-&gt;gid[i] = rqgi-&gt;gid[i];
<span class="p_add">+</span>
<span class="p_add">+			/* Each thread allocates its own gi, no race */</span>
<span class="p_add">+			groups_sort(gi);</span>
 		}
 	} else {
 		gi = get_group_info(rqgi);
<span class="p_header">diff --git a/include/linux/cred.h b/include/linux/cred.h</span>
<span class="p_header">index f0e70a1bb3ac..cf1a5d0c4eb4 100644</span>
<span class="p_header">--- a/include/linux/cred.h</span>
<span class="p_header">+++ b/include/linux/cred.h</span>
<span class="p_chunk">@@ -82,6 +82,7 @@</span> <span class="p_context"> extern int set_current_groups(struct group_info *);</span>
 extern void set_groups(struct cred *, struct group_info *);
 extern int groups_search(const struct group_info *, kgid_t);
 extern bool may_setgroups(void);
<span class="p_add">+extern void groups_sort(struct group_info *);</span>
 
 /*
  * The security context of a task
<span class="p_header">diff --git a/include/linux/fscache.h b/include/linux/fscache.h</span>
<span class="p_header">index 115bb81912cc..94a8aae8f9e2 100644</span>
<span class="p_header">--- a/include/linux/fscache.h</span>
<span class="p_header">+++ b/include/linux/fscache.h</span>
<span class="p_chunk">@@ -764,7 +764,7 @@</span> <span class="p_context"> bool fscache_maybe_release_page(struct fscache_cookie *cookie,</span>
 {
 	if (fscache_cookie_valid(cookie) &amp;&amp; PageFsCache(page))
 		return __fscache_maybe_release_page(cookie, page, gfp);
<span class="p_del">-	return false;</span>
<span class="p_add">+	return true;</span>
 }
 
 /**
<span class="p_header">diff --git a/kernel/acct.c b/kernel/acct.c</span>
<span class="p_header">index 74963d192c5d..37f1dc696fbd 100644</span>
<span class="p_header">--- a/kernel/acct.c</span>
<span class="p_header">+++ b/kernel/acct.c</span>
<span class="p_chunk">@@ -99,7 +99,7 @@</span> <span class="p_context"> static int check_free_space(struct bsd_acct_struct *acct)</span>
 {
 	struct kstatfs sbuf;
 
<span class="p_del">-	if (time_is_before_jiffies(acct-&gt;needcheck))</span>
<span class="p_add">+	if (time_is_after_jiffies(acct-&gt;needcheck))</span>
 		goto out;
 
 	/* May block */
<span class="p_header">diff --git a/kernel/groups.c b/kernel/groups.c</span>
<span class="p_header">index 2fcadd66a8fd..94bde5210e3d 100644</span>
<span class="p_header">--- a/kernel/groups.c</span>
<span class="p_header">+++ b/kernel/groups.c</span>
<span class="p_chunk">@@ -77,7 +77,7 @@</span> <span class="p_context"> static int groups_from_user(struct group_info *group_info,</span>
 }
 
 /* a simple Shell sort */
<span class="p_del">-static void groups_sort(struct group_info *group_info)</span>
<span class="p_add">+void groups_sort(struct group_info *group_info)</span>
 {
 	int base, max, stride;
 	int gidsetsize = group_info-&gt;ngroups;
<span class="p_chunk">@@ -103,6 +103,7 @@</span> <span class="p_context"> static void groups_sort(struct group_info *group_info)</span>
 		stride /= 3;
 	}
 }
<span class="p_add">+EXPORT_SYMBOL(groups_sort);</span>
 
 /* a simple bsearch */
 int groups_search(const struct group_info *group_info, kgid_t grp)
<span class="p_chunk">@@ -134,7 +135,6 @@</span> <span class="p_context"> int groups_search(const struct group_info *group_info, kgid_t grp)</span>
 void set_groups(struct cred *new, struct group_info *group_info)
 {
 	put_group_info(new-&gt;group_info);
<span class="p_del">-	groups_sort(group_info);</span>
 	get_group_info(group_info);
 	new-&gt;group_info = group_info;
 }
<span class="p_chunk">@@ -218,6 +218,7 @@</span> <span class="p_context"> SYSCALL_DEFINE2(setgroups, int, gidsetsize, gid_t __user *, grouplist)</span>
 		return retval;
 	}
 
<span class="p_add">+	groups_sort(group_info);</span>
 	retval = set_current_groups(group_info);
 	put_group_info(group_info);
 
<span class="p_header">diff --git a/kernel/signal.c b/kernel/signal.c</span>
<span class="p_header">index e48668c3c972..7ebe236a5364 100644</span>
<span class="p_header">--- a/kernel/signal.c</span>
<span class="p_header">+++ b/kernel/signal.c</span>
<span class="p_chunk">@@ -72,7 +72,7 @@</span> <span class="p_context"> static int sig_task_ignored(struct task_struct *t, int sig, bool force)</span>
 	handler = sig_handler(t, sig);
 
 	if (unlikely(t-&gt;signal-&gt;flags &amp; SIGNAL_UNKILLABLE) &amp;&amp;
<span class="p_del">-			handler == SIG_DFL &amp;&amp; !force)</span>
<span class="p_add">+	    handler == SIG_DFL &amp;&amp; !(force &amp;&amp; sig_kernel_only(sig)))</span>
 		return 1;
 
 	return sig_handler_ignored(handler, sig);
<span class="p_chunk">@@ -88,13 +88,15 @@</span> <span class="p_context"> static int sig_ignored(struct task_struct *t, int sig, bool force)</span>
 	if (sigismember(&amp;t-&gt;blocked, sig) || sigismember(&amp;t-&gt;real_blocked, sig))
 		return 0;
 
<span class="p_del">-	if (!sig_task_ignored(t, sig, force))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
 	/*
<span class="p_del">-	 * Tracers may want to know about even ignored signals.</span>
<span class="p_add">+	 * Tracers may want to know about even ignored signal unless it</span>
<span class="p_add">+	 * is SIGKILL which can&#39;t be reported anyway but can be ignored</span>
<span class="p_add">+	 * by SIGNAL_UNKILLABLE task.</span>
 	 */
<span class="p_del">-	return !t-&gt;ptrace;</span>
<span class="p_add">+	if (t-&gt;ptrace &amp;&amp; sig != SIGKILL)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	return sig_task_ignored(t, sig, force);</span>
 }
 
 /*
<span class="p_chunk">@@ -917,9 +919,9 @@</span> <span class="p_context"> static void complete_signal(int sig, struct task_struct *p, int group)</span>
 	 * then start taking the whole group down immediately.
 	 */
 	if (sig_fatal(p, sig) &amp;&amp;
<span class="p_del">-	    !(signal-&gt;flags &amp; (SIGNAL_UNKILLABLE | SIGNAL_GROUP_EXIT)) &amp;&amp;</span>
<span class="p_add">+	    !(signal-&gt;flags &amp; SIGNAL_GROUP_EXIT) &amp;&amp;</span>
 	    !sigismember(&amp;t-&gt;real_blocked, sig) &amp;&amp;
<span class="p_del">-	    (sig == SIGKILL || !t-&gt;ptrace)) {</span>
<span class="p_add">+	    (sig == SIGKILL || !p-&gt;ptrace)) {</span>
 		/*
 		 * This signal will be fatal to the whole group.
 		 */
<span class="p_header">diff --git a/kernel/uid16.c b/kernel/uid16.c</span>
<span class="p_header">index cc40793464e3..dcffcce9d75e 100644</span>
<span class="p_header">--- a/kernel/uid16.c</span>
<span class="p_header">+++ b/kernel/uid16.c</span>
<span class="p_chunk">@@ -190,6 +190,7 @@</span> <span class="p_context"> SYSCALL_DEFINE2(setgroups16, int, gidsetsize, old_gid_t __user *, grouplist)</span>
 		return retval;
 	}
 
<span class="p_add">+	groups_sort(group_info);</span>
 	retval = set_current_groups(group_info);
 	put_group_info(group_info);
 
<span class="p_header">diff --git a/net/sunrpc/auth_gss/gss_rpc_xdr.c b/net/sunrpc/auth_gss/gss_rpc_xdr.c</span>
<span class="p_header">index 25d9a9cf7b66..624c322af3ab 100644</span>
<span class="p_header">--- a/net/sunrpc/auth_gss/gss_rpc_xdr.c</span>
<span class="p_header">+++ b/net/sunrpc/auth_gss/gss_rpc_xdr.c</span>
<span class="p_chunk">@@ -231,6 +231,7 @@</span> <span class="p_context"> static int gssx_dec_linux_creds(struct xdr_stream *xdr,</span>
 			goto out_free_groups;
 		creds-&gt;cr_group_info-&gt;gid[i] = kgid;
 	}
<span class="p_add">+	groups_sort(creds-&gt;cr_group_info);</span>
 
 	return 0;
 out_free_groups:
<span class="p_header">diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_header">index 153082598522..6a08bc451247 100644</span>
<span class="p_header">--- a/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_header">+++ b/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_chunk">@@ -481,6 +481,7 @@</span> <span class="p_context"> static int rsc_parse(struct cache_detail *cd,</span>
 				goto out;
 			rsci.cred.cr_group_info-&gt;gid[i] = kgid;
 		}
<span class="p_add">+		groups_sort(rsci.cred.cr_group_info);</span>
 
 		/* mech name */
 		len = qword_get(&amp;mesg, buf, mlen);
<span class="p_header">diff --git a/net/sunrpc/svcauth_unix.c b/net/sunrpc/svcauth_unix.c</span>
<span class="p_header">index 64af4f034de6..738a243c68a2 100644</span>
<span class="p_header">--- a/net/sunrpc/svcauth_unix.c</span>
<span class="p_header">+++ b/net/sunrpc/svcauth_unix.c</span>
<span class="p_chunk">@@ -520,6 +520,7 @@</span> <span class="p_context"> static int unix_gid_parse(struct cache_detail *cd,</span>
 		ug.gi-&gt;gid[i] = kgid;
 	}
 
<span class="p_add">+	groups_sort(ug.gi);</span>
 	ugp = unix_gid_lookup(cd, uid);
 	if (ugp) {
 		struct cache_head *ch;
<span class="p_chunk">@@ -819,6 +820,7 @@</span> <span class="p_context"> svcauth_unix_accept(struct svc_rqst *rqstp, __be32 *authp)</span>
 		kgid_t kgid = make_kgid(&amp;init_user_ns, svc_getnl(argv));
 		cred-&gt;cr_group_info-&gt;gid[i] = kgid;
 	}
<span class="p_add">+	groups_sort(cred-&gt;cr_group_info);</span>
 	if (svc_getu32(argv) != htonl(RPC_AUTH_NULL) || svc_getu32(argv) != 0) {
 		*authp = rpc_autherr_badverf;
 		return SVC_DENIED;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



