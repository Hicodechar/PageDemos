
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.2.70 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.2.70</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 7, 2015, 1:30 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1438911043.7315.61.camel@decadent.org.uk&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6963851/mbox/"
   >mbox</a>
|
   <a href="/patch/6963851/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6963851/">/patch/6963851/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 3028AC05AC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  7 Aug 2015 01:31:57 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 1072D2076F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  7 Aug 2015 01:31:46 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 334C820773
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  7 Aug 2015 01:31:34 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1754341AbbHGBbL (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 6 Aug 2015 21:31:11 -0400
Received: from shadbolt.e.decadent.org.uk ([88.96.1.126]:58262 &quot;EHLO
	shadbolt.e.decadent.org.uk&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S1752249AbbHGBa5 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 6 Aug 2015 21:30:57 -0400
Received: from deadeye.wl.decadent.org.uk ([192.168.4.249] helo=deadeye)
	by shadbolt.decadent.org.uk with esmtps
	(TLS1.2:ECDHE_RSA_AES_128_GCM_SHA256:128) (Exim 4.84)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1ZNWUj-0007Wf-PI; Fri, 07 Aug 2015 02:30:50 +0100
Received: from ben by deadeye with local (Exim 4.86)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1ZNWUd-0007Bf-Kq; Fri, 07 Aug 2015 02:30:43 +0100
Message-ID: &lt;1438911043.7315.61.camel@decadent.org.uk&gt;
Subject: Linux 3.2.70
From: Ben Hutchings &lt;ben@decadent.org.uk&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, Jiri Slaby &lt;jslaby@suse.cz&gt;,
	stable@vger.kernel.org
Cc: lwn@lwn.net
Date: Fri, 07 Aug 2015 02:30:43 +0100
Content-Type: multipart/signed; micalg=&quot;pgp-sha512&quot;;
	protocol=&quot;application/pgp-signature&quot;;
	boundary=&quot;=-O6lEoGoA1VRRXKWK+G5b&quot;
X-Mailer: Evolution 3.16.3-1 
Mime-Version: 1.0
X-SA-Exim-Connect-IP: 192.168.4.249
X-SA-Exim-Mail-From: ben@decadent.org.uk
X-SA-Exim-Scanned: No (on shadbolt.decadent.org.uk);
	SAEximRunCond expanded to false
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.0 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD, T_TVD_MIME_EPI,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a> - Aug. 7, 2015, 1:30 a.m.</div>
<pre class="content">
I&#39;m announcing the release of the 3.2.70 kernel.

All users of the 3.2 kernel series should upgrade.

The updated 3.2.y git tree can be found at:
        git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git linux-3.2.y
and can be browsed at the normal kernel.org git web browser:
        http://git.kernel.org/?p=linux/kernel/git/stable/linux-stable.git

The diff from 3.2.69 is attached to this message.

Ben.

------------

 Documentation/networking/rds.txt                   |   9 +-
 Documentation/pinctrl.txt                          |   4 +-
 Makefile                                           |   2 +-
 arch/arm/include/asm/elf.h                         |   2 +-
 arch/mips/include/asm/cacheflush.h                 |  38 +++++---
 arch/mips/include/asm/cpu-features.h               |  26 +++++-
 .../asm/mach-cavium-octeon/cpu-feature-overrides.h |   1 -
 arch/mips/include/asm/octeon/pci-octeon.h          |   3 -
 arch/mips/kernel/irq.c                             |   2 +-
 arch/mips/mm/cache.c                               |  12 +++
 arch/mips/pci/pci-octeon.c                         |   6 --
 arch/mips/pci/pcie-octeon.c                        |   3 -
 arch/mips/power/hibernate.S                        |   3 +-
 arch/parisc/kernel/parisc_ksyms.c                  |   2 +
 arch/parisc/lib/Makefile                           |   3 +-
 arch/parisc/lib/ucmpdi2.c                          |  25 +++++
 arch/powerpc/kernel/cacheinfo.c                    |  43 +++++++--
 arch/powerpc/kernel/perf_callchain.c               |   2 +-
 arch/powerpc/kernel/setup-common.c                 |  16 +++-
 arch/powerpc/kernel/vmlinux.lds.S                  |   1 +
 arch/powerpc/mm/mmap_64.c                          |  14 +--
 arch/powerpc/platforms/pseries/dlpar.c             |  13 ++-
 arch/s390/crypto/ghash_s390.c                      |  25 ++---
 arch/s390/kernel/suspend.c                         |   6 ++
 arch/s390/kvm/priv.c                               |   1 +
 arch/sparc/kernel/leon_pci.c                       |  13 ---
 arch/sparc/kernel/sys_sparc_64.c                   |   6 +-
 arch/x86/Kconfig                                   |   3 +-
 arch/x86/include/asm/iommu_table.h                 |  11 ++-
 arch/x86/kernel/reboot.c                           |   7 +-
 arch/x86/kvm/mmu.c                                 |   2 +-
 arch/x86/kvm/vmx.c                                 |  12 ++-
 arch/x86/lib/usercopy_64.c                         |   2 +-
 arch/x86/net/bpf_jit_comp.c                        |   7 +-
 drivers/acpi/acpica/acmacros.h                     |  10 +-
 drivers/acpi/acpica/dsopcode.c                     |   4 +-
 drivers/acpi/acpica/evregion.c                     |   4 +-
 drivers/acpi/acpica/exdump.c                       |   4 +-
 drivers/acpi/acpica/exfldio.c                      |  10 +-
 drivers/acpi/acpica/exregion.c                     |   8 +-
 drivers/acpi/acpica/hwvalid.c                      |  16 ++--
 drivers/acpi/acpica/nsdump.c                       |  12 +--
 drivers/acpi/acpica/tbinstal.c                     |   4 +-
 drivers/acpi/acpica/tbutils.c                      |  21 ++---
 drivers/acpi/acpica/tbxfroot.c                     |   7 +-
 drivers/acpi/osl.c                                 |   6 +-
 drivers/ata/ahci.c                                 | 102 +++++++++++++++++++--
 drivers/ata/ahci.h                                 |   1 +
 drivers/ata/libahci.c                              |   6 +-
 drivers/ata/libata-core.c                          |  32 +++++++
 drivers/ata/libata-eh.c                            |   3 +
 drivers/bluetooth/ath3k.c                          |   1 +
 drivers/bluetooth/btusb.c                          |   1 +
 drivers/edac/Kconfig                               |   2 +-
 drivers/edac/sb_edac.c                             |  48 ++++++----
 drivers/firmware/dmi_scan.c                        |  85 ++++++++---------
 drivers/gpio/gpiolib.c                             |  26 +++++-
 drivers/gpu/drm/radeon/atombios_crtc.c             |   8 +-
 drivers/hv/channel.c                               |   7 +-
 drivers/hv/channel_mgmt.c                          |  12 +--
 drivers/infiniband/core/umem.c                     |   7 +-
 drivers/infiniband/hw/mlx4/qp.c                    |   3 +-
 drivers/input/mouse/elantech.c                     |  51 ++++++++---
 drivers/input/mouse/elantech.h                     |   1 +
 drivers/lguest/core.c                              |   2 +-
 drivers/md/raid5.c                                 |   3 +-
 drivers/memstick/core/mspro_block.c                |   3 +-
 drivers/mmc/core/core.c                            |   1 +
 drivers/mtd/ubi/cdev.c                             |   2 +-
 drivers/mtd/ubi/eba.c                              |   3 +-
 drivers/mtd/ubi/misc.c                             |   2 +
 drivers/mtd/ubi/scan.c                             |   2 +-
 drivers/mtd/ubi/wl.c                               |   2 +-
 drivers/net/ethernet/intel/e1000/e1000_main.c      |  10 +-
 drivers/net/phy/dp83640.c                          |   2 +-
 drivers/net/wireless/rtlwifi/rtl8192cu/sw.c        |   1 +
 drivers/net/wireless/rtlwifi/usb.c                 |   2 +-
 drivers/net/xen-netback/xenbus.c                   |  33 ++++---
 drivers/of/base.c                                  |  36 ++++++++
 drivers/platform/x86/compal-laptop.c               |   9 +-
 drivers/scsi/3w-9xxx.c                             |  57 +++---------
 drivers/scsi/3w-9xxx.h                             |   5 -
 drivers/scsi/3w-sas.c                              |  50 ++--------
 drivers/scsi/3w-sas.h                              |   4 -
 drivers/scsi/3w-xxxx.c                             |  42 ++-------
 drivers/scsi/3w-xxxx.h                             |   5 -
 drivers/scsi/megaraid/megaraid_sas_fusion.c        |   4 +-
 drivers/scsi/sd.c                                  |  19 +---
 drivers/scsi/sg.c                                  |   3 +
 drivers/staging/hv/storvsc_drv.c                   |  15 +--
 drivers/staging/line6/pcm.c                        |  40 +++++---
 drivers/staging/panel/panel.c                      |  13 ++-
 drivers/target/target_core_pscsi.c                 |   3 +
 drivers/target/target_core_pscsi.h                 |   1 +
 drivers/tty/hvc/hvc_xen.c                          |   2 +-
 drivers/tty/serial/of_serial.c                     |   1 -
 drivers/tty/serial/uartlite.c                      |  11 ++-
 drivers/tty/serial/xilinx_uartps.c                 |  12 +--
 drivers/usb/class/cdc-acm.c                        |   7 +-
 drivers/usb/class/cdc-wdm.c                        |  12 ++-
 drivers/usb/host/xhci-ring.c                       |   7 +-
 drivers/usb/host/xhci.h                            |   2 +-
 drivers/usb/musb/musb_core.c                       |  44 +++++----
 drivers/usb/serial/cp210x.c                        |   2 +
 drivers/usb/serial/ftdi_sio.c                      |   1 +
 drivers/usb/serial/ftdi_sio_ids.h                  |   1 +
 drivers/usb/serial/pl2303.c                        |   1 -
 drivers/usb/serial/pl2303.h                        |   4 -
 drivers/usb/storage/unusual_devs.h                 |   7 ++
 drivers/xen/events.c                               |  12 ++-
 drivers/xen/xen-pciback/conf_space.c               |   6 +-
 drivers/xen/xen-pciback/conf_space.h               |   2 +-
 drivers/xen/xen-pciback/conf_space_header.c        |   2 +-
 firmware/ihex2fw.c                                 |   1 +
 fs/binfmt_elf.c                                    |   9 +-
 fs/btrfs/extent-tree.c                             |   5 +-
 fs/btrfs/ioctl.c                                   |   5 +
 fs/btrfs/xattr.c                                   |  50 +++++++---
 fs/dcache.c                                        |  24 ++---
 fs/debugfs/inode.c                                 |   1 +
 fs/ext4/extents.c                                  |  19 ++--
 fs/ext4/namei.c                                    |  18 ++--
 fs/fhandle.c                                       |   5 +-
 fs/jbd2/recovery.c                                 |   7 +-
 fs/nfsd/nfs4state.c                                |  19 ++--
 fs/nilfs2/btree.c                                  |   2 +-
 fs/ocfs2/dlm/dlmmaster.c                           |  13 +++
 fs/omfs/inode.c                                    |   3 +-
 fs/pipe.c                                          |  55 ++++++-----
 include/acpi/acpixf.h                              |   2 +-
 include/acpi/actypes.h                             |  20 ++++
 include/acpi/platform/acenv.h                      |   1 +
 include/linux/jhash.h                              |  17 ++--
 include/linux/libata.h                             |  10 ++
 include/linux/nilfs2_fs.h                          |   2 +-
 include/linux/of.h                                 |  10 ++
 include/linux/sched.h                              |   8 +-
 include/net/ip_vs.h                                |   2 +
 include/net/sctp/structs.h                         |   5 +
 include/sound/emu10k1.h                            |  14 ++-
 include/xen/events.h                               |   2 +-
 kernel/ptrace.c                                    |  22 ++++-
 kernel/softirq.c                                   |  22 +++--
 kernel/trace/ring_buffer_benchmark.c               |   2 +-
 kernel/trace/trace_events_filter.c                 |  10 +-
 lib/string.c                                       |   2 +-
 mm/page-writeback.c                                |   6 +-
 mm/slub.c                                          |  45 +++------
 net/bridge/br_ioctl.c                              |   2 -
 net/bridge/br_multicast.c                          |   9 +-
 net/bridge/br_stp_if.c                             |   4 +-
 net/caif/caif_socket.c                             |   8 ++
 net/core/neighbour.c                               |  11 +++
 net/ipv4/udp.c                                     |   6 +-
 net/ipv6/udp.c                                     |   6 +-
 net/mac80211/wep.c                                 |   6 +-
 net/netfilter/ipvs/ip_vs_core.c                    |   9 ++
 net/netfilter/ipvs/ip_vs_ctl.c                     |  55 ++++++-----
 net/packet/af_packet.c                             |  20 +---
 net/sctp/output.c                                  |   4 +-
 net/sctp/socket.c                                  |  43 ++++++---
 net/socket.c                                       |  24 ++---
 net/unix/af_unix.c                                 |   8 ++
 security/selinux/nlmsgtab.c                        |   6 ++
 sound/pci/emu10k1/emu10k1.c                        |   6 +-
 sound/pci/emu10k1/emu10k1_callback.c               |   4 +-
 sound/pci/emu10k1/emu10k1_main.c                   |  21 +++--
 sound/pci/emu10k1/emupcm.c                         |   2 +-
 sound/pci/emu10k1/emuproc.c                        |  12 ---
 sound/pci/emu10k1/memory.c                         |  11 ++-
 sound/pci/hda/patch_conexant.c                     |  12 +++
 sound/soc/codecs/cs4271.c                          |   4 +-
 sound/soc/codecs/wm8741.c                          |   8 +-
 sound/soc/codecs/wm8960.c                          |   2 +-
 sound/soc/codecs/wm8994.c                          |   2 +-
 sound/soc/soc-dapm.c                               |  12 ++-
 sound/synth/emux/emux_oss.c                        |  11 +--
 sound/synth/emux/emux_seq.c                        |  29 ++++--
 sound/usb/mixer.c                                  |  10 +-
 sound/usb/mixer_maps.c                             |   5 +
 180 files changed, 1314 insertions(+), 833 deletions(-)

Al Viro (2):
      sg_start_req(): make sure that there&#39;s not too many elements in iovec
      d_walk() might skip too much

Alex Deucher (1):
      drm/radeon: fix doublescan modes (v2)

Alexander Duyck (1):
      jhash: Update jhash_[321]words functions to use correct initval

Alexander Ploumistos (1):
      Bluetooth: ath3k: Add support Atheros AR5B195 combo Mini PCIe card

Alexander Sverdlin (2):
      sctp: Fix race between OOTB responce and route removal
      MIPS: Octeon: Remove udelay() causing huge IRQ latency

Alexei Starovoitov (1):
      x86: bpf_jit: fix compilation of large bpf programs

Andrew Morton (1):
      fs/binfmt_elf.c:load_elf_binary(): return -EINVAL on zero-length mappings

Andrey Ryabinin (1):
      ARM: 8320/1: fix integer overflow in ELF_ET_DYN_BASE

Andy Grover (1):
      target/pscsi: Don&#39;t leak scsi_host if hba is VIRTUAL_HOST

Anton Blanchard (3):
      powerpc/perf: Cap 64bit userspace backtraces to PERF_MAX_STACK_DEPTH
      powerpc: Align TOC to 256 bytes
      powerpc: Make logical to real cpu mapping code endian safe

Aravind Gopalakrishnan (1):
      x86/iommu: Fix header comments regarding standard and _FINISH macros

Arnd Bergmann (1):
      staging: line6: avoid __sync_fetch_and_{and,or}

Baruch Siach (1):
      pinctrl: fix example .get_group_pins implementation signature

Ben Greear (1):
      Fix lockup related to stop_machine being stuck in __do_softirq.

Ben Hutchings (6):
      xen-pciback: Add name prefix to global &#39;permissive&#39; variable
      dmi_scan: refactor dmi_scan_machine(), {smbios,dmi}_present()
      x86_64: Fix strnlen_user() to not touch memory after specified maximum
      pipe: iovec: Fix memory corruption when retrying atomic copy as non-atomic
      debugfs: Fix statfs() regression in 3.2.69
      Linux 3.2.70

Ben Serebrin (1):
      KVM: VMX: Preserve host CR4.MCE value while in guest mode.

Benjamin Tissoires (1):
      Input: elantech - fix semi-mt protocol for v3 HW

Bob Moore (1):
      ACPICA: Debug output: Update output for Processor object.

Brian Norris (4):
      UBI: account for bitflips in both the VID header and data
      UBI: fix out of bounds write
      UBI: initialize LEB number variable
      UBI: fix check for &quot;too many bytes&quot;

Christoph Hellwig (5):
      megaraid_sas: use raw_smp_processor_id()
      3w-sas: fix command completion race
      3w-xxxx: fix command completion race
      3w-9xxx: fix command completion race
      nfsd: fix the check for confirmed openowner in nfs4_preprocess_stateid_op

Clemens Ladisch (2):
      ALSA: usb-audio: add MAYA44 USB+ mixer control names
      ALSA: usb-audio: fix missing input volume controls in MAYA44 USB(+)

Dan Carpenter (1):
      memstick: mspro_block: add missing curly braces

Dan McGee (1):
      powerpc+sparc64/mm: Remove hack in mmap randomize layout

Dan Williams (1):
      ahci: avoton port-disable reset-quirk

Darrick J. Wong (1):
      jbd2: fix r_count overflows leading to buffer overflow in journal recovery

Dave Olson (1):
      powerpc: Fix missing L2 cache size in /sys/devices/system/cpu

David Henningsson (1):
      ALSA: hda - Add Conexant codecs CX20721, CX20722, CX20723 and CX20724

David Sterba (1):
      btrfs: don&#39;t accept bare namespace as a valid xattr

David Vrabel (1):
      xen/events: don&#39;t bind non-percpu VIRQs with percpu chip

Davide Italiano (1):
      ext4: move check under lock scope to close a race.

Ekaterina Tumanova (1):
      KVM: s390: Zero out current VMDB of STSI before including level3 data.

Erez Shitrit (1):
      IB/mlx4: Fix WQE LSO segment calculation

Eric Dumazet (3):
      udp: fix behavior of wrong checksums
      packet: read num_members once in packet_rcv_fanout()
      softirq: reduce latencies

Eryu Guan (1):
      ext4: check for zero length extent explicitly

Felipe Balbi (1):
      usb: musb: core: fix TX/RX endpoint order

Feng Tang (1):
      x86/reboot: Fix a warning message triggered by stop_other_cpus()

Filipe Manana (2):
      Btrfs: fix log tree corruption when fs mounted with -o discard
      Btrfs: fix inode eviction infinite loop after cloning into it

Gabriele Mazzotta (2):
      libata: Add helper to determine when PHY events should be ignored
      libata: Ignore spurious PHY event on LPM policy change

Grant Likely (1):
      of: Add of_property_match_string() to find index into a string list

Grygorii Strashko (1):
      mmc: core: add missing pm event in mmc_pm_notify to fix hib restore

Hans Schillstrom (1):
      ipvs: kernel oops - do_ip_vs_get_ctl

Hans de Goede (2):
      usb-storage: Add NO_WP_DETECT quirk for Lacie 059f:0651 devices
      Input: elantech - fix detection of touchpads where the revision matches a known rate

Harald Freudenberger (1):
      crypto: s390/ghash - Fix incorrect ghash icv buffer handling.

Heiko Carstens (1):
      s390/hibernate: fix save and restore of kernel text section

Huacai Chen (1):
      MIPS: Hibernate: flush TLB entries earlier

Ian Campbell (1):
      xen: netback: read hotplug script once at start of day.

James Hogan (1):
      MIPS: Fix enabling of DEBUG_STACKOVERFLOW

Janusz Dziedzic (1):
      mac80211: move WEP tailroom size check

Jason A. Donenfeld (1):
      USB: pl2303: Remove support for Samsung I330

Jean Delvare (1):
      firmware: dmi_scan: Fix ordering of product_uuid

Jim Snow (1):
      sb_edac: Fix erroneous bytes-&gt;gigabytes conversion

Joe Lawrence (1):
      xhci: gracefully handle xhci_irq dead device

Johan Hovold (2):
      gpio: unregister gpiochip device before removing it
      gpio: sysfs: fix memory leaks and device hotplug

John D. Blair (1):
      USB: cp210x: add ID for HubZ dual ZigBee and Z-Wave dongle

John David Anglin (1):
      parisc: Provide __ucmpdi2 to resolve undefined references in 32 bit builds.

Joonsoo Kim (1):
      slub: refactoring unfreeze_partials()

Jordan Rife (1):
      Input: elantech - add support for newer elantech touchpads

Julian Anastasov (1):
      neigh: do not modify unlinked entries

Junling Zheng (1):
      net: socket: Fix the wrong returns for recvmsg and sendmsg

Junxiao Bi (1):
      ocfs2: dlm: fix race between purge and get lock resource

K. Y. Srinivasan (3):
      Drivers: hv: vmbus: Fix a bug in the error path in vmbus_open()
      Drivers: hv: vmbus: Don&#39;t wait after requesting offers
      scsi: storvsc: Fix a bug in copy_from_bounce_buffer()

Konrad Rzeszutek Wilk (1):
      config: Enable NEED_DMA_MAP_STATE by default when SWIOTLB is selected

Koro Chen (1):
      ASoC: dapm: Modify widget stream name according to prefix

Krzysztof Kozlowski (1):
      compal-laptop: Check return value of power_supply_register

Larry Finger (2):
      rtlwifi: rtl8192cu: Add new USB ID
      rtlwifi: rtl8192cu: Fix kernel deadlock

Lars Persson (1):
      MIPS: Fix race condition in lazy cache flushing.

Lukas Czerner (1):
      ext4: make fsync to sync parent dir in no-journal for real this time

Lv Zheng (4):
      ACPICA: Utilities: split IO address types from data type models.
      ACPICA: Tables: Change acpi_find_root_pointer() to use acpi_physical_address.
      ACPICA: Utilities: Cleanup to convert physical address printing formats.
      ACPICA: Utilities: Cleanup to remove useless ACPI_PRINTF/FORMAT_xxx helpers.

Maksim A. Boyko (1):
      ALSA: usb-audio: Fix invalid volume resolution for Logitech HD Webcam C525

Marcelo Ricardo Leitner (1):
      sctp: fix ASCONF list handling

Mark Edwards (1):
      USB: cp210x: add ID for KCF Technologies PRN device

Mark Grondona (1):
      __ptrace_may_access() should not deny sub-threads

Mark Hounschell (1):
      sd: Disable support for 256 byte/sector disks

Mark Salyzyn (1):
      unix/caif: sk_socket can disappear when state is unlocked

Mathias Nyman (2):
      xhci: fix isoc endpoint dequeue from advancing too far on transaction error
      xhci: Solve full event ring by increasing TRBS_PER_SEGMENT to 256

Matt Walker (1):
      Input: elantech - add support for newer (August 2013) devices

Matteo Delfino (1):
      Input: elantech - fix for newer hardware versions (v7)

Mauro Carvalho Chehab (1):
      Fix sb_edac compilation with 32 bits kernels

Michael Davidson (1):
      fs/binfmt_elf.c: fix bug in loading of PIE binaries

Michael Gernoth (1):
      ALSA: emu10k1: don&#39;t deadlock in proc-functions

Michal Simek (2):
      serial: xilinx: Use platform_get_irq to get irq description structure
      serial: of-serial: Remove device_type = &quot;serial&quot; registration

Nathan Fontenot (1):
      powerpc/pseries: Correct cpu affinity for dlpar added cpus

NeilBrown (1):
      md/raid5: don&#39;t record new size if resize_stripes fails.

Nicolas Dichtel (5):
      selinux/nlmsg: add XFRM_MSG_GETSPDINFO
      selinux/nlmsg: add XFRM_MSG_[NEW|GET]SADINFO
      selinux/nlmsg: add XFRM_MSG_REPORT
      selinux/nlmsg: add XFRM_MSG_MIGRATE
      selinux/nlmsg: add XFRM_MSG_MAPPING

Nicolas Iooss (1):
      firmware/ihex2fw.c: restore missing default in switch statement

Nikolay Aleksandrov (2):
      bridge: fix multicast router rlist endless loop
      bridge: fix br_stp_set_bridge_priority race conditions

Oleg Nesterov (2):
      ptrace: fix race between ptrace_resume() and wait_task_stopped()
      include/linux/sched.h: don&#39;t use task-&gt;pid/tgid in same_thread_group/has_group_leader_pid

Oliver Neukum (1):
      cdc-wdm: fix endianness bug in debug statements

Paolo Bonzini (1):
      KVM: MMU: fix CR4.SMEP=1, CR0.WP=0 with shadow pages

Pascal Huerst (1):
      ASoC: cs4271: Increase delay time after reset

Patrick Riphagen (1):
      USB: serial: ftdi_sio: Add support for a Motion Tracker Development Board

Peter Zubaj (1):
      ALSA: emu10k1: Emu10k2 32 bit DMA mode

Quentin Casasnovas (1):
      cdc-acm: prevent infinite loop when parsing CDC headers.

Rafael J. Wysocki (1):
      ACPI / init: Fix the ordering of acpi_reserve_resources()

Ralf Baechle (2):
      MIPS: Fix cpu_has_mips_r2_exec_hazard.
      MIPS: Octeon: Delete override of cpu_has_mips_r2_exec_hazard.

Richard Cochran (1):
      net: dp83640: fix broken calibration routine.

Rob Herring (1):
      ahci: un-staticize ahci_dev_classify

Rusty Russell (1):
      lguest: fix out-by-one error in address checking.

Ryusuke Konishi (1):
      nilfs2: fix sanity check of btree level in nilfs_btree_root_broken()

Sabrina Dubroca (1):
      e1000: add dummy allocator to fix race condition between mtu change and netpoll

Sam Ravnborg (1):
      sparc32,leon: fix leon build

Sam hung (1):
      Input: elantech - support new ICs types for version 4

Sasha Levin (2):
      fs, omfs: add NULL terminator in the end up the token list
      vfs: read file_handle only once in handle_to_path

Scott Wood (1):
      powerpc: Don&#39;t skip ePAPR spin-table CPUs

Sergej Sawazki (1):
      ASoC: wm8741: Fix rates constraints values

Sowmini Varadhan (1):
      RDS: Documentation: Document AF_RDS, PF_RDS and SOL_RDS correctly.

Steven Rostedt (1):
      tracing: Have filter check for balanced ops

Sudip Mukherjee (1):
      staging: panel: fix lcd type

Takashi Iwai (3):
      ALSA: emu10k1: Fix card shortname string buffer overflow
      ALSA: emux: Fix mutex deadlock at unloading
      ALSA: emux: Fix mutex deadlock in OSS emulation

Tejun Heo (1):
      writeback: use |1 instead of +1 to protect against div by zero

Thadeu Lima de Souza Cascardo (1):
      bridge: fix parsing of MLDv2 reports

Thierry Reding (1):
      dt: Add empty of_property_match_string() function

Tommi Rantala (1):
      ipvs: fix memory leak in ip_vs_ctl.c

Ulrik De Bie (1):
      Input: elantech - fix absolute mode setting on some ASUS laptops

Wang Long (1):
      ring-buffer-benchmark: Fix the wrong sched_priority of producer

Willem de Bruijn (1):
      packet: avoid out of bounds read in round robin fanout

Wolfram Sang (1):
      ALSA: usb-audio: Add mic volume fix quirk for Logitech Quickcam Fusion

Yann Droneaud (2):
      IB/core: disallow registering 0-sized memory region
      IB/core: don&#39;t disallow registering region starting at 0x0

Zidan Wang (2):
      ASoC: wm8960: fix &quot;RINPUT3&quot; audio route error
      ASoC: wm8994: correct BCLK DIV 348 to 384

hujianyang (1):
      UBI: fix soft lockup in ubi_check_volume()

mancha security (1):
      lib: memzero_explicit: use barrier instead of OPTIMIZER_HIDE_VAR

??? (1):
      Input: elantech - add new icbody type
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/networking/rds.txt b/Documentation/networking/rds.txt</span>
<span class="p_header">index c67077c..e1a3d59 100644</span>
<span class="p_header">--- a/Documentation/networking/rds.txt</span>
<span class="p_header">+++ b/Documentation/networking/rds.txt</span>
<span class="p_chunk">@@ -62,11 +62,10 @@</span> <span class="p_context"> Socket Interface</span>
 ================
 
   AF_RDS, PF_RDS, SOL_RDS
<span class="p_del">-        These constants haven&#39;t been assigned yet, because RDS isn&#39;t in</span>
<span class="p_del">-        mainline yet. Currently, the kernel module assigns some constant</span>
<span class="p_del">-        and publishes it to user space through two sysctl files</span>
<span class="p_del">-                /proc/sys/net/rds/pf_rds</span>
<span class="p_del">-                /proc/sys/net/rds/sol_rds</span>
<span class="p_add">+	AF_RDS and PF_RDS are the domain type to be used with socket(2)</span>
<span class="p_add">+	to create RDS sockets. SOL_RDS is the socket-level to be used</span>
<span class="p_add">+	with setsockopt(2) and getsockopt(2) for RDS specific socket</span>
<span class="p_add">+	options.</span>
 
   fd = socket(PF_RDS, SOCK_SEQPACKET, 0);
         This creates a new, unbound RDS socket.
<span class="p_header">diff --git a/Documentation/pinctrl.txt b/Documentation/pinctrl.txt</span>
<span class="p_header">index b04cb7d..074da62 100644</span>
<span class="p_header">--- a/Documentation/pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/pinctrl.txt</span>
<span class="p_chunk">@@ -164,8 +164,8 @@</span> <span class="p_context"> static const char *foo_get_group_name(struct pinctrl_dev *pctldev,</span>
 }
 
 static int foo_get_group_pins(struct pinctrl_dev *pctldev, unsigned selector,
<span class="p_del">-			       unsigned ** const pins,</span>
<span class="p_del">-			       unsigned * const num_pins)</span>
<span class="p_add">+			       const unsigned **pins,</span>
<span class="p_add">+			       unsigned *num_pins)</span>
 {
 	*pins = (unsigned *) foo_groups[selector].pins;
 	*num_pins = foo_groups[selector].num_pins;
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 8071888..41a626b 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 2
<span class="p_del">-SUBLEVEL = 69</span>
<span class="p_add">+SUBLEVEL = 70</span>
 EXTRAVERSION =
 NAME = Saber-toothed Squirrel
 
<span class="p_header">diff --git a/arch/arm/include/asm/elf.h b/arch/arm/include/asm/elf.h</span>
<span class="p_header">index 0e9ce8d..a4b1186 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/elf.h</span>
<span class="p_chunk">@@ -116,7 +116,7 @@</span> <span class="p_context"> int dump_task_regs(struct task_struct *t, elf_gregset_t *elfregs);</span>
    the loader.  We need to make sure that it is out of the way of the program
    that it will &quot;exec&quot;, and that there is sufficient room for the brk.  */
 
<span class="p_del">-#define ELF_ET_DYN_BASE	(2 * TASK_SIZE / 3)</span>
<span class="p_add">+#define ELF_ET_DYN_BASE	(TASK_SIZE / 3 * 2)</span>
 
 /* When the program starts, a1 contains a pointer to a function to be 
    registered with atexit, as per the SVR4 ABI.  A value of 0 means we 
<span class="p_header">diff --git a/arch/mips/include/asm/cacheflush.h b/arch/mips/include/asm/cacheflush.h</span>
<span class="p_header">index 69468de..484c5bc 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/cacheflush.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/cacheflush.h</span>
<span class="p_chunk">@@ -29,6 +29,20 @@</span> <span class="p_context"></span>
  *  - flush_icache_all() flush the entire instruction cache
  *  - flush_data_cache_page() flushes a page from the data cache
  */
<span class="p_add">+</span>
<span class="p_add">+ /*</span>
<span class="p_add">+ * This flag is used to indicate that the page pointed to by a pte</span>
<span class="p_add">+ * is dirty and requires cleaning before returning it to the user.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define PG_dcache_dirty			PG_arch_1</span>
<span class="p_add">+</span>
<span class="p_add">+#define Page_dcache_dirty(page)		\</span>
<span class="p_add">+	test_bit(PG_dcache_dirty, &amp;(page)-&gt;flags)</span>
<span class="p_add">+#define SetPageDcacheDirty(page)	\</span>
<span class="p_add">+	set_bit(PG_dcache_dirty, &amp;(page)-&gt;flags)</span>
<span class="p_add">+#define ClearPageDcacheDirty(page)	\</span>
<span class="p_add">+	clear_bit(PG_dcache_dirty, &amp;(page)-&gt;flags)</span>
<span class="p_add">+</span>
 extern void (*flush_cache_all)(void);
 extern void (*__flush_cache_all)(void);
 extern void (*flush_cache_mm)(struct mm_struct *mm);
<span class="p_chunk">@@ -37,13 +51,15 @@</span> <span class="p_context"> extern void (*flush_cache_range)(struct vm_area_struct *vma,</span>
 	unsigned long start, unsigned long end);
 extern void (*flush_cache_page)(struct vm_area_struct *vma, unsigned long page, unsigned long pfn);
 extern void __flush_dcache_page(struct page *page);
<span class="p_add">+extern void __flush_icache_page(struct vm_area_struct *vma, struct page *page);</span>
 
 #define ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE 1
 static inline void flush_dcache_page(struct page *page)
 {
<span class="p_del">-	if (cpu_has_dc_aliases || !cpu_has_ic_fills_f_dc)</span>
<span class="p_add">+	if (cpu_has_dc_aliases)</span>
 		__flush_dcache_page(page);
<span class="p_del">-</span>
<span class="p_add">+	else if (!cpu_has_ic_fills_f_dc)</span>
<span class="p_add">+		SetPageDcacheDirty(page);</span>
 }
 
 #define flush_dcache_mmap_lock(mapping)		do { } while (0)
<span class="p_chunk">@@ -61,6 +77,11 @@</span> <span class="p_context"> static inline void flush_anon_page(struct vm_area_struct *vma,</span>
 static inline void flush_icache_page(struct vm_area_struct *vma,
 	struct page *page)
 {
<span class="p_add">+	if (!cpu_has_ic_fills_f_dc &amp;&amp; (vma-&gt;vm_flags &amp; VM_EXEC) &amp;&amp;</span>
<span class="p_add">+	    Page_dcache_dirty(page)) {</span>
<span class="p_add">+		__flush_icache_page(vma, page);</span>
<span class="p_add">+		ClearPageDcacheDirty(page);</span>
<span class="p_add">+	}</span>
 }
 
 extern void (*flush_icache_range)(unsigned long start, unsigned long end);
<span class="p_chunk">@@ -95,19 +116,6 @@</span> <span class="p_context"> extern void (*flush_icache_all)(void);</span>
 extern void (*local_flush_data_cache_page)(void * addr);
 extern void (*flush_data_cache_page)(unsigned long addr);
 
<span class="p_del">-/*</span>
<span class="p_del">- * This flag is used to indicate that the page pointed to by a pte</span>
<span class="p_del">- * is dirty and requires cleaning before returning it to the user.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define PG_dcache_dirty			PG_arch_1</span>
<span class="p_del">-</span>
<span class="p_del">-#define Page_dcache_dirty(page)		\</span>
<span class="p_del">-	test_bit(PG_dcache_dirty, &amp;(page)-&gt;flags)</span>
<span class="p_del">-#define SetPageDcacheDirty(page)	\</span>
<span class="p_del">-	set_bit(PG_dcache_dirty, &amp;(page)-&gt;flags)</span>
<span class="p_del">-#define ClearPageDcacheDirty(page)	\</span>
<span class="p_del">-	clear_bit(PG_dcache_dirty, &amp;(page)-&gt;flags)</span>
<span class="p_del">-</span>
 /* Run kernel code uncached, useful for cache probing functions. */
 unsigned long run_uncached(void *func);
 
<span class="p_header">diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h</span>
<span class="p_header">index ca400f7..0f4991b 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/cpu-features.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/cpu-features.h</span>
<span class="p_chunk">@@ -153,8 +153,32 @@</span> <span class="p_context"></span>
 #define cpu_has_mips_r	(cpu_has_mips32r1 | cpu_has_mips32r2 | \
 			 cpu_has_mips64r1 | cpu_has_mips64r2)
 
<span class="p_add">+/*</span>
<span class="p_add">+ * cpu_has_mips_r2_exec_hazard - return if IHB is required on current processor</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns non-zero value if the current processor implementation requires</span>
<span class="p_add">+ * an IHB instruction to deal with an instruction hazard as per MIPS R2</span>
<span class="p_add">+ * architecture specification, zero otherwise.</span>
<span class="p_add">+ */</span>
 #ifndef cpu_has_mips_r2_exec_hazard
<span class="p_del">-#define cpu_has_mips_r2_exec_hazard cpu_has_mips_r2</span>
<span class="p_add">+#define cpu_has_mips_r2_exec_hazard					\</span>
<span class="p_add">+({									\</span>
<span class="p_add">+	int __res;							\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	switch (current_cpu_type()) {					\</span>
<span class="p_add">+	case CPU_74K:							\</span>
<span class="p_add">+	case CPU_CAVIUM_OCTEON:						\</span>
<span class="p_add">+	case CPU_CAVIUM_OCTEON_PLUS:					\</span>
<span class="p_add">+	case CPU_CAVIUM_OCTEON2:					\</span>
<span class="p_add">+		__res = 0;						\</span>
<span class="p_add">+		break;							\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	default:							\</span>
<span class="p_add">+		__res = 1;						\</span>
<span class="p_add">+	}								\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	__res;								\</span>
<span class="p_add">+})</span>
 #endif
 
 /*
<span class="p_header">diff --git a/arch/mips/include/asm/mach-cavium-octeon/cpu-feature-overrides.h b/arch/mips/include/asm/mach-cavium-octeon/cpu-feature-overrides.h</span>
<span class="p_header">index a58addb..6ae8e3c 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/mach-cavium-octeon/cpu-feature-overrides.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/mach-cavium-octeon/cpu-feature-overrides.h</span>
<span class="p_chunk">@@ -51,7 +51,6 @@</span> <span class="p_context"></span>
 #define cpu_has_mips32r2	0
 #define cpu_has_mips64r1	0
 #define cpu_has_mips64r2	1
<span class="p_del">-#define cpu_has_mips_r2_exec_hazard 0</span>
 #define cpu_has_dsp		0
 #define cpu_has_mipsmt		0
 #define cpu_has_vint		0
<span class="p_header">diff --git a/arch/mips/include/asm/octeon/pci-octeon.h b/arch/mips/include/asm/octeon/pci-octeon.h</span>
<span class="p_header">index fba2ba2..ac83283 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/octeon/pci-octeon.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/octeon/pci-octeon.h</span>
<span class="p_chunk">@@ -11,9 +11,6 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/pci.h&gt;
 
<span class="p_del">-/* Some PCI cards require delays when accessing config space. */</span>
<span class="p_del">-#define PCI_CONFIG_SPACE_DELAY 10000</span>
<span class="p_del">-</span>
 /*
  * The physical memory base mapped by BAR1.  256MB at the end of the
  * first 4GB.
<span class="p_header">diff --git a/arch/mips/kernel/irq.c b/arch/mips/kernel/irq.c</span>
<span class="p_header">index 7f50318..6e489e5 100644</span>
<span class="p_header">--- a/arch/mips/kernel/irq.c</span>
<span class="p_header">+++ b/arch/mips/kernel/irq.c</span>
<span class="p_chunk">@@ -111,7 +111,7 @@</span> <span class="p_context"> void __init init_IRQ(void)</span>
 #endif
 }
 
<span class="p_del">-#ifdef DEBUG_STACKOVERFLOW</span>
<span class="p_add">+#ifdef CONFIG_DEBUG_STACKOVERFLOW</span>
 static inline void check_stack_overflow(void)
 {
 	unsigned long sp;
<span class="p_header">diff --git a/arch/mips/mm/cache.c b/arch/mips/mm/cache.c</span>
<span class="p_header">index 829320c..0f8839b 100644</span>
<span class="p_header">--- a/arch/mips/mm/cache.c</span>
<span class="p_header">+++ b/arch/mips/mm/cache.c</span>
<span class="p_chunk">@@ -118,6 +118,18 @@</span> <span class="p_context"> void __flush_anon_page(struct page *page, unsigned long vmaddr)</span>
 
 EXPORT_SYMBOL(__flush_anon_page);
 
<span class="p_add">+void __flush_icache_page(struct vm_area_struct *vma, struct page *page)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long addr;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (PageHighMem(page))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	addr = (unsigned long) page_address(page);</span>
<span class="p_add">+	flush_data_cache_page(addr);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(__flush_icache_page);</span>
<span class="p_add">+</span>
 void __update_cache(struct vm_area_struct *vma, unsigned long address,
 	pte_t pte)
 {
<span class="p_header">diff --git a/arch/mips/pci/pci-octeon.c b/arch/mips/pci/pci-octeon.c</span>
<span class="p_header">index ed1c542..66d3c38 100644</span>
<span class="p_header">--- a/arch/mips/pci/pci-octeon.c</span>
<span class="p_header">+++ b/arch/mips/pci/pci-octeon.c</span>
<span class="p_chunk">@@ -279,9 +279,6 @@</span> <span class="p_context"> static int octeon_read_config(struct pci_bus *bus, unsigned int devfn,</span>
 	pci_addr.s.func = devfn &amp; 0x7;
 	pci_addr.s.reg = reg;
 
<span class="p_del">-#if PCI_CONFIG_SPACE_DELAY</span>
<span class="p_del">-	udelay(PCI_CONFIG_SPACE_DELAY);</span>
<span class="p_del">-#endif</span>
 	switch (size) {
 	case 4:
 		*val = le32_to_cpu(cvmx_read64_uint32(pci_addr.u64));
<span class="p_chunk">@@ -316,9 +313,6 @@</span> <span class="p_context"> static int octeon_write_config(struct pci_bus *bus, unsigned int devfn,</span>
 	pci_addr.s.func = devfn &amp; 0x7;
 	pci_addr.s.reg = reg;
 
<span class="p_del">-#if PCI_CONFIG_SPACE_DELAY</span>
<span class="p_del">-	udelay(PCI_CONFIG_SPACE_DELAY);</span>
<span class="p_del">-#endif</span>
 	switch (size) {
 	case 4:
 		cvmx_write64_uint32(pci_addr.u64, cpu_to_le32(val));
<span class="p_header">diff --git a/arch/mips/pci/pcie-octeon.c b/arch/mips/pci/pcie-octeon.c</span>
<span class="p_header">index 0583c463..37a8790 100644</span>
<span class="p_header">--- a/arch/mips/pci/pcie-octeon.c</span>
<span class="p_header">+++ b/arch/mips/pci/pcie-octeon.c</span>
<span class="p_chunk">@@ -1219,9 +1219,6 @@</span> <span class="p_context"> static inline int octeon_pcie_write_config(int pcie_port, struct pci_bus *bus,</span>
 					devfn &amp; 0x7, reg, val);
 		return PCIBIOS_SUCCESSFUL;
 	}
<span class="p_del">-#if PCI_CONFIG_SPACE_DELAY</span>
<span class="p_del">-	udelay(PCI_CONFIG_SPACE_DELAY);</span>
<span class="p_del">-#endif</span>
 	return PCIBIOS_FUNC_NOT_SUPPORTED;
 }
 
<span class="p_header">diff --git a/arch/mips/power/hibernate.S b/arch/mips/power/hibernate.S</span>
<span class="p_header">index 5bf34ec..2ca1735 100644</span>
<span class="p_header">--- a/arch/mips/power/hibernate.S</span>
<span class="p_header">+++ b/arch/mips/power/hibernate.S</span>
<span class="p_chunk">@@ -31,6 +31,8 @@</span> <span class="p_context"> LEAF(swsusp_arch_suspend)</span>
 END(swsusp_arch_suspend)
 
 LEAF(swsusp_arch_resume)
<span class="p_add">+	/* Avoid TLB mismatch during and after kernel resume */</span>
<span class="p_add">+	jal local_flush_tlb_all</span>
 	PTR_L t0, restore_pblist
 0:
 	PTR_L t1, PBE_ADDRESS(t0)   /* source */
<span class="p_chunk">@@ -44,7 +46,6 @@</span> <span class="p_context"> LEAF(swsusp_arch_resume)</span>
 	bne t1, t3, 1b
 	PTR_L t0, PBE_NEXT(t0)
 	bnez t0, 0b
<span class="p_del">-	jal local_flush_tlb_all /* Avoid TLB mismatch after kernel resume */</span>
 	PTR_LA t0, saved_regs
 	PTR_L ra, PT_R31(t0)
 	PTR_L sp, PT_R29(t0)
<span class="p_header">diff --git a/arch/parisc/kernel/parisc_ksyms.c b/arch/parisc/kernel/parisc_ksyms.c</span>
<span class="p_header">index a7bb757..c3f1be95 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/parisc_ksyms.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/parisc_ksyms.c</span>
<span class="p_chunk">@@ -121,11 +121,13 @@</span> <span class="p_context"> extern void __ashrdi3(void);</span>
 extern void __ashldi3(void);
 extern void __lshrdi3(void);
 extern void __muldi3(void);
<span class="p_add">+extern void __ucmpdi2(void);</span>
 
 EXPORT_SYMBOL(__ashrdi3);
 EXPORT_SYMBOL(__ashldi3);
 EXPORT_SYMBOL(__lshrdi3);
 EXPORT_SYMBOL(__muldi3);
<span class="p_add">+EXPORT_SYMBOL(__ucmpdi2);</span>
 
 asmlinkage void * __canonicalize_funcptr_for_compare(void *);
 EXPORT_SYMBOL(__canonicalize_funcptr_for_compare);
<span class="p_header">diff --git a/arch/parisc/lib/Makefile b/arch/parisc/lib/Makefile</span>
<span class="p_header">index 5f2e690..5651536 100644</span>
<span class="p_header">--- a/arch/parisc/lib/Makefile</span>
<span class="p_header">+++ b/arch/parisc/lib/Makefile</span>
<span class="p_chunk">@@ -2,6 +2,7 @@</span> <span class="p_context"></span>
 # Makefile for parisc-specific library files
 #
 
<span class="p_del">-lib-y	:= lusercopy.o bitops.o checksum.o io.o memset.o fixup.o memcpy.o</span>
<span class="p_add">+lib-y	:= lusercopy.o bitops.o checksum.o io.o memset.o fixup.o memcpy.o \</span>
<span class="p_add">+	   ucmpdi2.o</span>
 
 obj-y	:= iomap.o
<span class="p_header">diff --git a/arch/parisc/lib/ucmpdi2.c b/arch/parisc/lib/ucmpdi2.c</span>
new file mode 100644
<span class="p_header">index 0000000..149c016</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/parisc/lib/ucmpdi2.c</span>
<span class="p_chunk">@@ -0,0 +1,25 @@</span> <span class="p_context"></span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+union ull_union {</span>
<span class="p_add">+	unsigned long long ull;</span>
<span class="p_add">+	struct {</span>
<span class="p_add">+		unsigned int high;</span>
<span class="p_add">+		unsigned int low;</span>
<span class="p_add">+	} ui;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+int __ucmpdi2(unsigned long long a, unsigned long long b)</span>
<span class="p_add">+{</span>
<span class="p_add">+	union ull_union au = {.ull = a};</span>
<span class="p_add">+	union ull_union bu = {.ull = b};</span>
<span class="p_add">+</span>
<span class="p_add">+	if (au.ui.high &lt; bu.ui.high)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	else if (au.ui.high &gt; bu.ui.high)</span>
<span class="p_add">+		return 2;</span>
<span class="p_add">+	if (au.ui.low &lt; bu.ui.low)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	else if (au.ui.low &gt; bu.ui.low)</span>
<span class="p_add">+		return 2;</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/powerpc/kernel/cacheinfo.c b/arch/powerpc/kernel/cacheinfo.c</span>
<span class="p_header">index 02ebe1a..4f15565 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/cacheinfo.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/cacheinfo.c</span>
<span class="p_chunk">@@ -62,12 +62,22 @@</span> <span class="p_context"> struct cache_type_info {</span>
 };
 
 /* These are used to index the cache_type_info array. */
<span class="p_del">-#define CACHE_TYPE_UNIFIED     0</span>
<span class="p_del">-#define CACHE_TYPE_INSTRUCTION 1</span>
<span class="p_del">-#define CACHE_TYPE_DATA        2</span>
<span class="p_add">+#define CACHE_TYPE_UNIFIED     0 /* cache-size, cache-block-size, etc. */</span>
<span class="p_add">+#define CACHE_TYPE_UNIFIED_D   1 /* d-cache-size, d-cache-block-size, etc */</span>
<span class="p_add">+#define CACHE_TYPE_INSTRUCTION 2</span>
<span class="p_add">+#define CACHE_TYPE_DATA        3</span>
 
 static const struct cache_type_info cache_type_info[] = {
 	{
<span class="p_add">+		/* Embedded systems that use cache-size, cache-block-size,</span>
<span class="p_add">+		 * etc. for the Unified (typically L2) cache. */</span>
<span class="p_add">+		.name            = &quot;Unified&quot;,</span>
<span class="p_add">+		.size_prop       = &quot;cache-size&quot;,</span>
<span class="p_add">+		.line_size_props = { &quot;cache-line-size&quot;,</span>
<span class="p_add">+				     &quot;cache-block-size&quot;, },</span>
<span class="p_add">+		.nr_sets_prop    = &quot;cache-sets&quot;,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		/* PowerPC Processor binding says the [di]-cache-*
 		 * must be equal on unified caches, so just use
 		 * d-cache properties. */
<span class="p_chunk">@@ -293,7 +303,8 @@</span> <span class="p_context"> static struct cache *cache_find_first_sibling(struct cache *cache)</span>
 {
 	struct cache *iter;
 
<span class="p_del">-	if (cache-&gt;type == CACHE_TYPE_UNIFIED)</span>
<span class="p_add">+	if (cache-&gt;type == CACHE_TYPE_UNIFIED ||</span>
<span class="p_add">+	    cache-&gt;type == CACHE_TYPE_UNIFIED_D)</span>
 		return cache;
 
 	list_for_each_entry(iter, &amp;cache_list, list)
<span class="p_chunk">@@ -324,15 +335,29 @@</span> <span class="p_context"> static bool cache_node_is_unified(const struct device_node *np)</span>
 	return of_get_property(np, &quot;cache-unified&quot;, NULL);
 }
 
<span class="p_del">-static struct cache *__cpuinit cache_do_one_devnode_unified(struct device_node *node, int level)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Unified caches can have two different sets of tags.  Most embedded</span>
<span class="p_add">+ * use cache-size, etc. for the unified cache size, but open firmware systems</span>
<span class="p_add">+ * use d-cache-size, etc.   Check on initialization for which type we have, and</span>
<span class="p_add">+ * return the appropriate structure type.  Assume it&#39;s embedded if it isn&#39;t</span>
<span class="p_add">+ * open firmware.  If it&#39;s yet a 3rd type, then there will be missing entries</span>
<span class="p_add">+ * in /sys/devices/system/cpu/cpu0/cache/index2/, and this code will need</span>
<span class="p_add">+ * to be extended further.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int cache_is_unified_d(const struct device_node *np)</span>
 {
<span class="p_del">-	struct cache *cache;</span>
<span class="p_add">+	return of_get_property(np,</span>
<span class="p_add">+		cache_type_info[CACHE_TYPE_UNIFIED_D].size_prop, NULL) ?</span>
<span class="p_add">+		CACHE_TYPE_UNIFIED_D : CACHE_TYPE_UNIFIED;</span>
<span class="p_add">+}</span>
 
<span class="p_add">+/*</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct cache *__cpuinit cache_do_one_devnode_unified(struct device_node *node, int level)</span>
<span class="p_add">+{</span>
 	pr_debug(&quot;creating L%d ucache for %s\n&quot;, level, node-&gt;full_name);
 
<span class="p_del">-	cache = new_cache(CACHE_TYPE_UNIFIED, level, node);</span>
<span class="p_del">-</span>
<span class="p_del">-	return cache;</span>
<span class="p_add">+	return new_cache(cache_is_unified_d(node), level, node);</span>
 }
 
 static struct cache *__cpuinit cache_do_one_devnode_split(struct device_node *node, int level)
<span class="p_header">diff --git a/arch/powerpc/kernel/perf_callchain.c b/arch/powerpc/kernel/perf_callchain.c</span>
<span class="p_header">index 564c1d8..e80026c 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/perf_callchain.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/perf_callchain.c</span>
<span class="p_chunk">@@ -243,7 +243,7 @@</span> <span class="p_context"> static void perf_callchain_user_64(struct perf_callchain_entry *entry,</span>
 	sp = regs-&gt;gpr[1];
 	perf_callchain_store(entry, next_ip);
 
<span class="p_del">-	for (;;) {</span>
<span class="p_add">+	while (entry-&gt;nr &lt; PERF_MAX_STACK_DEPTH) {</span>
 		fp = (unsigned long __user *) sp;
 		if (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &amp;next_sp))
 			return;
<span class="p_header">diff --git a/arch/powerpc/kernel/setup-common.c b/arch/powerpc/kernel/setup-common.c</span>
<span class="p_header">index 82288e9..83940d7 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/setup-common.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/setup-common.c</span>
<span class="p_chunk">@@ -428,7 +428,7 @@</span> <span class="p_context"> void __init smp_setup_cpu_maps(void)</span>
 	DBG(&quot;smp_setup_cpu_maps()\n&quot;);
 
 	while ((dn = of_find_node_by_type(dn, &quot;cpu&quot;)) &amp;&amp; cpu &lt; nr_cpu_ids) {
<span class="p_del">-		const int *intserv;</span>
<span class="p_add">+		const __be32 *intserv;</span>
 		int j, len;
 
 		DBG(&quot;  * %s...\n&quot;, dn-&gt;full_name);
<span class="p_chunk">@@ -447,10 +447,18 @@</span> <span class="p_context"> void __init smp_setup_cpu_maps(void)</span>
 		}
 
 		for (j = 0; j &lt; nthreads &amp;&amp; cpu &lt; nr_cpu_ids; j++) {
<span class="p_add">+			bool avail;</span>
<span class="p_add">+</span>
 			DBG(&quot;    thread %d -&gt; cpu %d (hard id %d)\n&quot;,
<span class="p_del">-			    j, cpu, intserv[j]);</span>
<span class="p_del">-			set_cpu_present(cpu, of_device_is_available(dn));</span>
<span class="p_del">-			set_hard_smp_processor_id(cpu, intserv[j]);</span>
<span class="p_add">+			    j, cpu, be32_to_cpu(intserv[j]));</span>
<span class="p_add">+</span>
<span class="p_add">+			avail = of_device_is_available(dn);</span>
<span class="p_add">+			if (!avail)</span>
<span class="p_add">+				avail = !of_property_match_string(dn,</span>
<span class="p_add">+						&quot;enable-method&quot;, &quot;spin-table&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+			set_cpu_present(cpu, avail);</span>
<span class="p_add">+			set_hard_smp_processor_id(cpu, be32_to_cpu(intserv[j]));</span>
 			set_cpu_possible(cpu, true);
 			cpu++;
 		}
<span class="p_header">diff --git a/arch/powerpc/kernel/vmlinux.lds.S b/arch/powerpc/kernel/vmlinux.lds.S</span>
<span class="p_header">index 3e8fe4b..cec664a 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/vmlinux.lds.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/vmlinux.lds.S</span>
<span class="p_chunk">@@ -212,6 +212,7 @@</span> <span class="p_context"> SECTIONS</span>
 		*(.opd)
 	}
 
<span class="p_add">+	. = ALIGN(256);</span>
 	.got : AT(ADDR(.got) - LOAD_OFFSET) {
 		__toc_start = .;
 		*(.got)
<span class="p_header">diff --git a/arch/powerpc/mm/mmap_64.c b/arch/powerpc/mm/mmap_64.c</span>
<span class="p_header">index 5a783d8..67a42ed 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/mmap_64.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/mmap_64.c</span>
<span class="p_chunk">@@ -53,14 +53,6 @@</span> <span class="p_context"> static inline int mmap_is_legacy(void)</span>
 	return sysctl_legacy_va_layout;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * Since get_random_int() returns the same value within a 1 jiffy window,</span>
<span class="p_del">- * we will almost always get the same randomisation for the stack and mmap</span>
<span class="p_del">- * region. This will mean the relative distance between stack and mmap will</span>
<span class="p_del">- * be the same.</span>
<span class="p_del">- *</span>
<span class="p_del">- * To avoid this we can shift the randomness by 1 bit.</span>
<span class="p_del">- */</span>
 static unsigned long mmap_rnd(void)
 {
 	unsigned long rnd = 0;
<span class="p_chunk">@@ -68,11 +60,11 @@</span> <span class="p_context"> static unsigned long mmap_rnd(void)</span>
 	if (current-&gt;flags &amp; PF_RANDOMIZE) {
 		/* 8MB for 32bit, 1GB for 64bit */
 		if (is_32bit_task())
<span class="p_del">-			rnd = (long)(get_random_int() % (1&lt;&lt;(22-PAGE_SHIFT)));</span>
<span class="p_add">+			rnd = (long)(get_random_int() % (1&lt;&lt;(23-PAGE_SHIFT)));</span>
 		else
<span class="p_del">-			rnd = (long)(get_random_int() % (1&lt;&lt;(29-PAGE_SHIFT)));</span>
<span class="p_add">+			rnd = (long)(get_random_int() % (1&lt;&lt;(30-PAGE_SHIFT)));</span>
 	}
<span class="p_del">-	return (rnd &lt;&lt; PAGE_SHIFT) * 2;</span>
<span class="p_add">+	return rnd &lt;&lt; PAGE_SHIFT;</span>
 }
 
 static inline unsigned long mmap_base(void)
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/dlpar.c b/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_header">index 0f1b706..2767276 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_chunk">@@ -416,6 +416,12 @@</span> <span class="p_context"> static ssize_t dlpar_cpu_probe(const char *buf, size_t count)</span>
 		goto out;
 	}
 
<span class="p_add">+	rc = dlpar_acquire_drc(drc_index);</span>
<span class="p_add">+	if (rc) {</span>
<span class="p_add">+		rc = -EINVAL;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	dn = dlpar_configure_connector(drc_index);
 	if (!dn) {
 		rc = -EINVAL;
<span class="p_chunk">@@ -436,13 +442,6 @@</span> <span class="p_context"> static ssize_t dlpar_cpu_probe(const char *buf, size_t count)</span>
 	kfree(dn-&gt;full_name);
 	dn-&gt;full_name = cpu_name;
 
<span class="p_del">-	rc = dlpar_acquire_drc(drc_index);</span>
<span class="p_del">-	if (rc) {</span>
<span class="p_del">-		dlpar_free_cc_nodes(dn);</span>
<span class="p_del">-		rc = -EINVAL;</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	rc = dlpar_attach_node(dn);
 	if (rc) {
 		dlpar_release_drc(drc_index);
<span class="p_header">diff --git a/arch/s390/crypto/ghash_s390.c b/arch/s390/crypto/ghash_s390.c</span>
<span class="p_header">index 31086ea..568521a 100644</span>
<span class="p_header">--- a/arch/s390/crypto/ghash_s390.c</span>
<span class="p_header">+++ b/arch/s390/crypto/ghash_s390.c</span>
<span class="p_chunk">@@ -16,11 +16,12 @@</span> <span class="p_context"></span>
 #define GHASH_DIGEST_SIZE	16
 
 struct ghash_ctx {
<span class="p_del">-	u8 icv[16];</span>
<span class="p_del">-	u8 key[16];</span>
<span class="p_add">+	u8 key[GHASH_BLOCK_SIZE];</span>
 };
 
 struct ghash_desc_ctx {
<span class="p_add">+	u8 icv[GHASH_BLOCK_SIZE];</span>
<span class="p_add">+	u8 key[GHASH_BLOCK_SIZE];</span>
 	u8 buffer[GHASH_BLOCK_SIZE];
 	u32 bytes;
 };
<span class="p_chunk">@@ -28,8 +29,10 @@</span> <span class="p_context"> struct ghash_desc_ctx {</span>
 static int ghash_init(struct shash_desc *desc)
 {
 	struct ghash_desc_ctx *dctx = shash_desc_ctx(desc);
<span class="p_add">+	struct ghash_ctx *ctx = crypto_shash_ctx(desc-&gt;tfm);</span>
 
 	memset(dctx, 0, sizeof(*dctx));
<span class="p_add">+	memcpy(dctx-&gt;key, ctx-&gt;key, GHASH_BLOCK_SIZE);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -45,7 +48,6 @@</span> <span class="p_context"> static int ghash_setkey(struct crypto_shash *tfm,</span>
 	}
 
 	memcpy(ctx-&gt;key, key, GHASH_BLOCK_SIZE);
<span class="p_del">-	memset(ctx-&gt;icv, 0, GHASH_BLOCK_SIZE);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -54,7 +56,6 @@</span> <span class="p_context"> static int ghash_update(struct shash_desc *desc,</span>
 			 const u8 *src, unsigned int srclen)
 {
 	struct ghash_desc_ctx *dctx = shash_desc_ctx(desc);
<span class="p_del">-	struct ghash_ctx *ctx = crypto_shash_ctx(desc-&gt;tfm);</span>
 	unsigned int n;
 	u8 *buf = dctx-&gt;buffer;
 	int ret;
<span class="p_chunk">@@ -70,7 +71,7 @@</span> <span class="p_context"> static int ghash_update(struct shash_desc *desc,</span>
 		src += n;
 
 		if (!dctx-&gt;bytes) {
<span class="p_del">-			ret = crypt_s390_kimd(KIMD_GHASH, ctx, buf,</span>
<span class="p_add">+			ret = crypt_s390_kimd(KIMD_GHASH, dctx, buf,</span>
 					      GHASH_BLOCK_SIZE);
 			if (ret != GHASH_BLOCK_SIZE)
 				return -EIO;
<span class="p_chunk">@@ -79,7 +80,7 @@</span> <span class="p_context"> static int ghash_update(struct shash_desc *desc,</span>
 
 	n = srclen &amp; ~(GHASH_BLOCK_SIZE - 1);
 	if (n) {
<span class="p_del">-		ret = crypt_s390_kimd(KIMD_GHASH, ctx, src, n);</span>
<span class="p_add">+		ret = crypt_s390_kimd(KIMD_GHASH, dctx, src, n);</span>
 		if (ret != n)
 			return -EIO;
 		src += n;
<span class="p_chunk">@@ -94,7 +95,7 @@</span> <span class="p_context"> static int ghash_update(struct shash_desc *desc,</span>
 	return 0;
 }
 
<span class="p_del">-static int ghash_flush(struct ghash_ctx *ctx, struct ghash_desc_ctx *dctx)</span>
<span class="p_add">+static int ghash_flush(struct ghash_desc_ctx *dctx)</span>
 {
 	u8 *buf = dctx-&gt;buffer;
 	int ret;
<span class="p_chunk">@@ -104,24 +105,24 @@</span> <span class="p_context"> static int ghash_flush(struct ghash_ctx *ctx, struct ghash_desc_ctx *dctx)</span>
 
 		memset(pos, 0, dctx-&gt;bytes);
 
<span class="p_del">-		ret = crypt_s390_kimd(KIMD_GHASH, ctx, buf, GHASH_BLOCK_SIZE);</span>
<span class="p_add">+		ret = crypt_s390_kimd(KIMD_GHASH, dctx, buf, GHASH_BLOCK_SIZE);</span>
 		if (ret != GHASH_BLOCK_SIZE)
 			return -EIO;
<span class="p_add">+</span>
<span class="p_add">+		dctx-&gt;bytes = 0;</span>
 	}
 
<span class="p_del">-	dctx-&gt;bytes = 0;</span>
 	return 0;
 }
 
 static int ghash_final(struct shash_desc *desc, u8 *dst)
 {
 	struct ghash_desc_ctx *dctx = shash_desc_ctx(desc);
<span class="p_del">-	struct ghash_ctx *ctx = crypto_shash_ctx(desc-&gt;tfm);</span>
 	int ret;
 
<span class="p_del">-	ret = ghash_flush(ctx, dctx);</span>
<span class="p_add">+	ret = ghash_flush(dctx);</span>
 	if (!ret)
<span class="p_del">-		memcpy(dst, ctx-&gt;icv, GHASH_BLOCK_SIZE);</span>
<span class="p_add">+		memcpy(dst, dctx-&gt;icv, GHASH_BLOCK_SIZE);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/arch/s390/kernel/suspend.c b/arch/s390/kernel/suspend.c</span>
<span class="p_header">index 47df775..ba17092 100644</span>
<span class="p_header">--- a/arch/s390/kernel/suspend.c</span>
<span class="p_header">+++ b/arch/s390/kernel/suspend.c</span>
<span class="p_chunk">@@ -9,6 +9,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/pfn.h&gt;
 #include &lt;linux/suspend.h&gt;
 #include &lt;linux/mm.h&gt;
<span class="p_add">+#include &lt;asm/ipl.h&gt;</span>
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 #include &lt;asm/system.h&gt;
 
 /*
<span class="p_chunk">@@ -137,6 +139,8 @@</span> <span class="p_context"> int pfn_is_nosave(unsigned long pfn)</span>
 {
 	unsigned long nosave_begin_pfn = PFN_DOWN(__pa(&amp;__nosave_begin));
 	unsigned long nosave_end_pfn = PFN_DOWN(__pa(&amp;__nosave_end));
<span class="p_add">+	unsigned long eshared_pfn = PFN_DOWN(__pa(&amp;_eshared)) - 1;</span>
<span class="p_add">+	unsigned long stext_pfn = PFN_DOWN(__pa(&amp;_stext));</span>
 
 	/* Always save lowcore pages (LC protection might be enabled). */
 	if (pfn &lt;= LC_PAGES)
<span class="p_chunk">@@ -144,6 +148,8 @@</span> <span class="p_context"> int pfn_is_nosave(unsigned long pfn)</span>
 	if (pfn &gt;= nosave_begin_pfn &amp;&amp; pfn &lt; nosave_end_pfn)
 		return 1;
 	/* Skip memory holes and read-only pages (NSS, DCSS, ...). */
<span class="p_add">+	if (pfn &gt;= stext_pfn &amp;&amp; pfn &lt;= eshared_pfn)</span>
<span class="p_add">+		return ipl_info.type == IPL_TYPE_NSS ? 1 : 0;</span>
 	if (tprot(PFN_PHYS(pfn)))
 		return 1;
 	return 0;
<span class="p_header">diff --git a/arch/s390/kvm/priv.c b/arch/s390/kvm/priv.c</span>
<span class="p_header">index d026389..c593e1e 100644</span>
<span class="p_header">--- a/arch/s390/kvm/priv.c</span>
<span class="p_header">+++ b/arch/s390/kvm/priv.c</span>
<span class="p_chunk">@@ -219,6 +219,7 @@</span> <span class="p_context"> static void handle_stsi_3_2_2(struct kvm_vcpu *vcpu, struct sysinfo_3_2_2 *mem)</span>
 	for (n = mem-&gt;count - 1; n &gt; 0 ; n--)
 		memcpy(&amp;mem-&gt;vm[n], &amp;mem-&gt;vm[n - 1], sizeof(mem-&gt;vm[0]));
 
<span class="p_add">+	memset(&amp;mem-&gt;vm[0], 0, sizeof(mem-&gt;vm[0]));</span>
 	mem-&gt;vm[0].cpus_total = cpus;
 	mem-&gt;vm[0].cpus_configured = cpus;
 	mem-&gt;vm[0].cpus_standby = 0;
<span class="p_header">diff --git a/arch/sparc/kernel/leon_pci.c b/arch/sparc/kernel/leon_pci.c</span>
<span class="p_header">index f1cf6ef..a0ef32e 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/leon_pci.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/leon_pci.c</span>
<span class="p_chunk">@@ -78,7 +78,6 @@</span> <span class="p_context"> EXPORT_SYMBOL(pcibios_bus_to_resource);</span>
 
 void __devinit pcibios_fixup_bus(struct pci_bus *pbus)
 {
<span class="p_del">-	struct leon_pci_info *info = pbus-&gt;sysdata;</span>
 	struct pci_dev *dev;
 	int i, has_io, has_mem;
 	u16 cmd;
<span class="p_chunk">@@ -153,18 +152,6 @@</span> <span class="p_context"> int pcibios_enable_device(struct pci_dev *dev, int mask)</span>
 	return pci_enable_resources(dev, mask);
 }
 
<span class="p_del">-struct device_node *pci_device_to_OF_node(struct pci_dev *pdev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Currently the OpenBoot nodes are not connected with the PCI device,</span>
<span class="p_del">-	 * this is because the LEON PROM does not create PCI nodes. Eventually</span>
<span class="p_del">-	 * this will change and the same approach as pcic.c can be used to</span>
<span class="p_del">-	 * match PROM nodes with pci devices.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	return NULL;</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL(pci_device_to_OF_node);</span>
<span class="p_del">-</span>
 void __devinit pcibios_update_irq(struct pci_dev *dev, int irq)
 {
 #ifdef CONFIG_PCI_DEBUG
<span class="p_header">diff --git a/arch/sparc/kernel/sys_sparc_64.c b/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_header">index 5e4252b..0ff682d 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_chunk">@@ -368,11 +368,11 @@</span> <span class="p_context"> static unsigned long mmap_rnd(void)</span>
 	if (current-&gt;flags &amp; PF_RANDOMIZE) {
 		unsigned long val = get_random_int();
 		if (test_thread_flag(TIF_32BIT))
<span class="p_del">-			rnd = (val % (1UL &lt;&lt; (22UL-PAGE_SHIFT)));</span>
<span class="p_add">+			rnd = (val % (1UL &lt;&lt; (23UL-PAGE_SHIFT)));</span>
 		else
<span class="p_del">-			rnd = (val % (1UL &lt;&lt; (29UL-PAGE_SHIFT)));</span>
<span class="p_add">+			rnd = (val % (1UL &lt;&lt; (30UL-PAGE_SHIFT)));</span>
 	}
<span class="p_del">-	return (rnd &lt;&lt; PAGE_SHIFT) * 2;</span>
<span class="p_add">+	return rnd &lt;&lt; PAGE_SHIFT;</span>
 }
 
 void arch_pick_mmap_layout(struct mm_struct *mm)
<span class="p_header">diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig</span>
<span class="p_header">index 28a1bca..d720208 100644</span>
<span class="p_header">--- a/arch/x86/Kconfig</span>
<span class="p_header">+++ b/arch/x86/Kconfig</span>
<span class="p_chunk">@@ -133,7 +133,8 @@</span> <span class="p_context"> config SBUS</span>
 	bool
 
 config NEED_DMA_MAP_STATE
<span class="p_del">-       def_bool (X86_64 || INTEL_IOMMU || DMA_API_DEBUG)</span>
<span class="p_add">+	def_bool y</span>
<span class="p_add">+	depends on X86_64 || INTEL_IOMMU || DMA_API_DEBUG || SWIOTLB</span>
 
 config NEED_SG_DMA_LENGTH
 	def_bool y
<span class="p_header">diff --git a/arch/x86/include/asm/iommu_table.h b/arch/x86/include/asm/iommu_table.h</span>
<span class="p_header">index f229b13..0c54822 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/iommu_table.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/iommu_table.h</span>
<span class="p_chunk">@@ -79,11 +79,12 @@</span> <span class="p_context"> struct iommu_table_entry {</span>
  *  d). Similar to the &#39;init&#39;, except that this gets called from pci_iommu_init
  *      where we do have a memory allocator.
  *
<span class="p_del">- * The standard vs the _FINISH differs in that the _FINISH variant will</span>
<span class="p_del">- * continue detecting other IOMMUs in the call list after the</span>
<span class="p_del">- * the detection routine returns a positive number. The _FINISH will</span>
<span class="p_del">- * stop the execution chain. Both will still call the &#39;init&#39; and</span>
<span class="p_del">- * &#39;late_init&#39; functions if they are set.</span>
<span class="p_add">+ * The standard IOMMU_INIT differs from the IOMMU_INIT_FINISH variant</span>
<span class="p_add">+ * in that the former will continue detecting other IOMMUs in the call</span>
<span class="p_add">+ * list after the detection routine returns a positive number, while the</span>
<span class="p_add">+ * latter will stop the execution chain upon first successful detection.</span>
<span class="p_add">+ * Both variants will still call the &#39;init&#39; and &#39;late_init&#39; functions if</span>
<span class="p_add">+ * they are set.</span>
  */
 #define IOMMU_INIT_FINISH(_detect, _depend, _init, _late_init)		\
 	__IOMMU_INIT(_detect, _depend, _init, _late_init, 1)
<span class="p_header">diff --git a/arch/x86/kernel/reboot.c b/arch/x86/kernel/reboot.c</span>
<span class="p_header">index 41b2f57..78842ce 100644</span>
<span class="p_header">--- a/arch/x86/kernel/reboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/reboot.c</span>
<span class="p_chunk">@@ -700,9 +700,12 @@</span> <span class="p_context"> void native_machine_shutdown(void)</span>
 	/* Make certain I only run on the appropriate processor */
 	set_cpus_allowed_ptr(current, cpumask_of(reboot_cpu_id));
 
<span class="p_del">-	/* O.K Now that I&#39;m on the appropriate processor,</span>
<span class="p_del">-	 * stop all of the others.</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * O.K Now that I&#39;m on the appropriate processor, stop all of the</span>
<span class="p_add">+	 * others. Also disable the local irq to not receive the per-cpu</span>
<span class="p_add">+	 * timer interrupt which may trigger scheduler&#39;s load balance.</span>
 	 */
<span class="p_add">+	local_irq_disable();</span>
 	stop_other_cpus();
 #endif
 
<span class="p_header">diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c</span>
<span class="p_header">index bfc9507..4a949c7 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mmu.c</span>
<span class="p_chunk">@@ -3609,7 +3609,7 @@</span> <span class="p_context"> void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,</span>
 		}
 	}
 
<span class="p_del">-	mask.cr0_wp = mask.cr4_pae = mask.nxe = 1;</span>
<span class="p_add">+	mask.cr0_wp = mask.cr4_pae = mask.nxe = mask.smep_andnot_wp = 1;</span>
 	for_each_gfn_indirect_valid_sp(vcpu-&gt;kvm, sp, gfn, node) {
 		pte_size = sp-&gt;role.cr4_pae ? 8 : 4;
 		misaligned = (offset ^ (offset + bytes - 1)) &amp; ~(pte_size - 1);
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 8831c43..421958f 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -3032,8 +3032,16 @@</span> <span class="p_context"> static void vmx_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)</span>
 
 static int vmx_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)
 {
<span class="p_del">-	unsigned long hw_cr4 = cr4 | (to_vmx(vcpu)-&gt;rmode.vm86_active ?</span>
<span class="p_del">-		    KVM_RMODE_VM_CR4_ALWAYS_ON : KVM_PMODE_VM_CR4_ALWAYS_ON);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Pass through host&#39;s Machine Check Enable value to hw_cr4, which</span>
<span class="p_add">+	 * is in force while we are in guest mode.  Do not let guests control</span>
<span class="p_add">+	 * this bit, even if host CR4.MCE == 0.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	unsigned long hw_cr4 =</span>
<span class="p_add">+		(read_cr4() &amp; X86_CR4_MCE) |</span>
<span class="p_add">+		(cr4 &amp; ~X86_CR4_MCE) |</span>
<span class="p_add">+		(to_vmx(vcpu)-&gt;rmode.vm86_active ?</span>
<span class="p_add">+		 KVM_RMODE_VM_CR4_ALWAYS_ON : KVM_PMODE_VM_CR4_ALWAYS_ON);</span>
 
 	if (cr4 &amp; X86_CR4_VMXE) {
 		/*
<span class="p_header">diff --git a/arch/x86/lib/usercopy_64.c b/arch/x86/lib/usercopy_64.c</span>
<span class="p_header">index 554b7b5..433b21d 100644</span>
<span class="p_header">--- a/arch/x86/lib/usercopy_64.c</span>
<span class="p_header">+++ b/arch/x86/lib/usercopy_64.c</span>
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> long __strnlen_user(const char __user *s, long n)</span>
 	char c;
 
 	while (1) {
<span class="p_del">-		if (res&gt;n)</span>
<span class="p_add">+		if (res &gt;= n)</span>
 			return n+1;
 		if (__get_user(c, s))
 			return 0;
<span class="p_header">diff --git a/arch/x86/net/bpf_jit_comp.c b/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_header">index 5a5b6e4..11e3100 100644</span>
<span class="p_header">--- a/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_header">+++ b/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_chunk">@@ -150,7 +150,12 @@</span> <span class="p_context"> void bpf_jit_compile(struct sk_filter *fp)</span>
 	}
 	cleanup_addr = proglen; /* epilogue address */
 
<span class="p_del">-	for (pass = 0; pass &lt; 10; pass++) {</span>
<span class="p_add">+	/* JITed image shrinks with every pass and the loop iterates</span>
<span class="p_add">+	 * until the image stops shrinking. Very large bpf programs</span>
<span class="p_add">+	 * may converge on the last pass. In such case do one more</span>
<span class="p_add">+	 * pass to emit the final image</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (pass = 0; pass &lt; 10 || image; pass++) {</span>
 		u8 seen_or_pass0 = (pass == 0) ? (SEEN_XREG | SEEN_DATAREF | SEEN_MEM) : seen;
 		/* no prologue/epilogue for trivial filters (RET something) */
 		proglen = 0;
<span class="p_header">diff --git a/drivers/acpi/acpica/acmacros.h b/drivers/acpi/acpica/acmacros.h</span>
<span class="p_header">index b7491ee..6454fe6 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/acmacros.h</span>
<span class="p_header">+++ b/drivers/acpi/acpica/acmacros.h</span>
<span class="p_chunk">@@ -59,19 +59,15 @@</span> <span class="p_context"></span>
 #define ACPI_SET64(ptr)                 *ACPI_CAST_PTR (u64, ptr)
 
 /*
<span class="p_del">- * printf() format helpers</span>
<span class="p_add">+ * printf() format helper. This macros is a workaround for the difficulties</span>
<span class="p_add">+ * with emitting 64-bit integers and 64-bit pointers with the same code</span>
<span class="p_add">+ * for both 32-bit and 64-bit hosts.</span>
  */
 
 /* Split 64-bit integer into two 32-bit values. Use with %8.8_x%8.8_x */
 
 #define ACPI_FORMAT_UINT64(i)           ACPI_HIDWORD(i), ACPI_LODWORD(i)
 
<span class="p_del">-#if ACPI_MACHINE_WIDTH == 64</span>
<span class="p_del">-#define ACPI_FORMAT_NATIVE_UINT(i)      ACPI_FORMAT_UINT64(i)</span>
<span class="p_del">-#else</span>
<span class="p_del">-#define ACPI_FORMAT_NATIVE_UINT(i)      0, (i)</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 /*
  * Macros for moving data around to/from buffers that are possibly unaligned.
  * If the hardware supports the transfer of unaligned data, just do the store.
<span class="p_header">diff --git a/drivers/acpi/acpica/dsopcode.c b/drivers/acpi/acpica/dsopcode.c</span>
<span class="p_header">index c627a28..9d19587 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/dsopcode.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/dsopcode.c</span>
<span class="p_chunk">@@ -446,7 +446,7 @@</span> <span class="p_context"> acpi_ds_eval_region_operands(struct acpi_walk_state *walk_state,</span>
 
 	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, &quot;RgnObj %p Addr %8.8X%8.8X Len %X\n&quot;,
 			  obj_desc,
<span class="p_del">-			  ACPI_FORMAT_NATIVE_UINT(obj_desc-&gt;region.address),</span>
<span class="p_add">+			  ACPI_FORMAT_UINT64(obj_desc-&gt;region.address),</span>
 			  obj_desc-&gt;region.length));
 
 	/* Now the address and length are valid for this opregion */
<span class="p_chunk">@@ -545,7 +545,7 @@</span> <span class="p_context"> acpi_ds_eval_table_region_operands(struct acpi_walk_state *walk_state,</span>
 
 	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, &quot;RgnObj %p Addr %8.8X%8.8X Len %X\n&quot;,
 			  obj_desc,
<span class="p_del">-			  ACPI_FORMAT_NATIVE_UINT(obj_desc-&gt;region.address),</span>
<span class="p_add">+			  ACPI_FORMAT_UINT64(obj_desc-&gt;region.address),</span>
 			  obj_desc-&gt;region.length));
 
 	/* Now the address and length are valid for this opregion */
<span class="p_header">diff --git a/drivers/acpi/acpica/evregion.c b/drivers/acpi/acpica/evregion.c</span>
<span class="p_header">index f0edf5c..cb18ab4 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/evregion.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/evregion.c</span>
<span class="p_chunk">@@ -450,8 +450,8 @@</span> <span class="p_context"> acpi_ev_address_space_dispatch(union acpi_operand_object *region_obj,</span>
 	ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
 			  &quot;Handler %p (@%p) Address %8.8X%8.8X [%s]\n&quot;,
 			  &amp;region_obj-&gt;region.handler-&gt;address_space, handler,
<span class="p_del">-			  ACPI_FORMAT_NATIVE_UINT(region_obj-&gt;region.address +</span>
<span class="p_del">-						  region_offset),</span>
<span class="p_add">+			  ACPI_FORMAT_UINT64(region_obj-&gt;region.address +</span>
<span class="p_add">+					     region_offset),</span>
 			  acpi_ut_get_region_name(region_obj-&gt;region.
 						  space_id)));
 
<span class="p_header">diff --git a/drivers/acpi/acpica/exdump.c b/drivers/acpi/acpica/exdump.c</span>
<span class="p_header">index 61b8c0e..c572fa0 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/exdump.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/exdump.c</span>
<span class="p_chunk">@@ -613,8 +613,8 @@</span> <span class="p_context"> void acpi_ex_dump_operand(union acpi_operand_object *obj_desc, u32 depth)</span>
 			acpi_os_printf(&quot;\n&quot;);
 		} else {
 			acpi_os_printf(&quot; base %8.8X%8.8X Length %X\n&quot;,
<span class="p_del">-				       ACPI_FORMAT_NATIVE_UINT(obj_desc-&gt;region.</span>
<span class="p_del">-							       address),</span>
<span class="p_add">+				       ACPI_FORMAT_UINT64(obj_desc-&gt;region.</span>
<span class="p_add">+							  address),</span>
 				       obj_desc-&gt;region.length);
 		}
 		break;
<span class="p_header">diff --git a/drivers/acpi/acpica/exfldio.c b/drivers/acpi/acpica/exfldio.c</span>
<span class="p_header">index b334f54..be22142 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/exfldio.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/exfldio.c</span>
<span class="p_chunk">@@ -257,17 +257,15 @@</span> <span class="p_context"> acpi_ex_access_region(union acpi_operand_object *obj_desc,</span>
 	}
 
 	ACPI_DEBUG_PRINT_RAW((ACPI_DB_BFIELD,
<span class="p_del">-			      &quot; Region [%s:%X], Width %X, ByteBase %X, Offset %X at %p\n&quot;,</span>
<span class="p_add">+			      &quot; Region [%s:%X], Width %X, ByteBase %X, Offset %X at %8.8X%8.8X\n&quot;,</span>
 			      acpi_ut_get_region_name(rgn_desc-&gt;region.
 						      space_id),
 			      rgn_desc-&gt;region.space_id,
 			      obj_desc-&gt;common_field.access_byte_width,
 			      obj_desc-&gt;common_field.base_byte_offset,
<span class="p_del">-			      field_datum_byte_offset, ACPI_CAST_PTR(void,</span>
<span class="p_del">-								     (rgn_desc-&gt;</span>
<span class="p_del">-								      region.</span>
<span class="p_del">-								      address +</span>
<span class="p_del">-								      region_offset))));</span>
<span class="p_add">+			      field_datum_byte_offset,</span>
<span class="p_add">+			      ACPI_FORMAT_UINT64(rgn_desc-&gt;region.address +</span>
<span class="p_add">+						 region_offset)));</span>
 
 	/* Invoke the appropriate address_space/op_region handler */
 
<span class="p_header">diff --git a/drivers/acpi/acpica/exregion.c b/drivers/acpi/acpica/exregion.c</span>
<span class="p_header">index f0d5e14..dd5e930 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/exregion.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/exregion.c</span>
<span class="p_chunk">@@ -174,7 +174,7 @@</span> <span class="p_context"> acpi_ex_system_memory_space_handler(u32 function,</span>
 		if (!mem_info-&gt;mapped_logical_address) {
 			ACPI_ERROR((AE_INFO,
 				    &quot;Could not map memory at 0x%8.8X%8.8X, size %u&quot;,
<span class="p_del">-				    ACPI_FORMAT_NATIVE_UINT(address),</span>
<span class="p_add">+				    ACPI_FORMAT_UINT64(address),</span>
 				    (u32) map_length));
 			mem_info-&gt;mapped_length = 0;
 			return_ACPI_STATUS(AE_NO_MEMORY);
<span class="p_chunk">@@ -195,8 +195,7 @@</span> <span class="p_context"> acpi_ex_system_memory_space_handler(u32 function,</span>
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			  &quot;System-Memory (width %u) R/W %u Address=%8.8X%8.8X\n&quot;,
<span class="p_del">-			  bit_width, function,</span>
<span class="p_del">-			  ACPI_FORMAT_NATIVE_UINT(address)));</span>
<span class="p_add">+			  bit_width, function, ACPI_FORMAT_UINT64(address)));</span>
 
 	/*
 	 * Perform the memory read or write
<span class="p_chunk">@@ -298,8 +297,7 @@</span> <span class="p_context"> acpi_ex_system_io_space_handler(u32 function,</span>
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			  &quot;System-IO (width %u) R/W %u Address=%8.8X%8.8X\n&quot;,
<span class="p_del">-			  bit_width, function,</span>
<span class="p_del">-			  ACPI_FORMAT_NATIVE_UINT(address)));</span>
<span class="p_add">+			  bit_width, function, ACPI_FORMAT_UINT64(address)));</span>
 
 	/* Decode the function parameter */
 
<span class="p_header">diff --git a/drivers/acpi/acpica/hwvalid.c b/drivers/acpi/acpica/hwvalid.c</span>
<span class="p_header">index 5f16058..d43b8af 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/hwvalid.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/hwvalid.c</span>
<span class="p_chunk">@@ -141,17 +141,17 @@</span> <span class="p_context"> acpi_hw_validate_io_request(acpi_io_address address, u32 bit_width)</span>
 	byte_width = ACPI_DIV_8(bit_width);
 	last_address = address + byte_width - 1;
 
<span class="p_del">-	ACPI_DEBUG_PRINT((ACPI_DB_IO, &quot;Address %p LastAddress %p Length %X&quot;,</span>
<span class="p_del">-			  ACPI_CAST_PTR(void, address), ACPI_CAST_PTR(void,</span>
<span class="p_del">-								      last_address),</span>
<span class="p_del">-			  byte_width));</span>
<span class="p_add">+	ACPI_DEBUG_PRINT((ACPI_DB_IO,</span>
<span class="p_add">+			  &quot;Address %8.8X%8.8X LastAddress %8.8X%8.8X Length %X&quot;,</span>
<span class="p_add">+			  ACPI_FORMAT_UINT64(address),</span>
<span class="p_add">+			  ACPI_FORMAT_UINT64(last_address), byte_width));</span>
 
 	/* Maximum 16-bit address in I/O space */
 
 	if (last_address &gt; ACPI_UINT16_MAX) {
 		ACPI_ERROR((AE_INFO,
<span class="p_del">-			    &quot;Illegal I/O port address/length above 64K: %p/0x%X&quot;,</span>
<span class="p_del">-			    ACPI_CAST_PTR(void, address), byte_width));</span>
<span class="p_add">+			    &quot;Illegal I/O port address/length above 64K: %8.8X%8.8X/0x%X&quot;,</span>
<span class="p_add">+			    ACPI_FORMAT_UINT64(address), byte_width));</span>
 		return_ACPI_STATUS(AE_LIMIT);
 	}
 
<span class="p_chunk">@@ -180,8 +180,8 @@</span> <span class="p_context"> acpi_hw_validate_io_request(acpi_io_address address, u32 bit_width)</span>
 
 			if (acpi_gbl_osi_data &gt;= port_info-&gt;osi_dependency) {
 				ACPI_DEBUG_PRINT((ACPI_DB_IO,
<span class="p_del">-						  &quot;Denied AML access to port 0x%p/%X (%s 0x%.4X-0x%.4X)&quot;,</span>
<span class="p_del">-						  ACPI_CAST_PTR(void, address),</span>
<span class="p_add">+						  &quot;Denied AML access to port 0x%8.8X%8.8X/%X (%s 0x%.4X-0x%.4X)&quot;,</span>
<span class="p_add">+						  ACPI_FORMAT_UINT64(address),</span>
 						  byte_width, port_info-&gt;name,
 						  port_info-&gt;start,
 						  port_info-&gt;end));
<span class="p_header">diff --git a/drivers/acpi/acpica/nsdump.c b/drivers/acpi/acpica/nsdump.c</span>
<span class="p_header">index b683cc2..0a68c73 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/nsdump.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/nsdump.c</span>
<span class="p_chunk">@@ -251,12 +251,11 @@</span> <span class="p_context"> acpi_ns_dump_one_object(acpi_handle obj_handle,</span>
 		switch (type) {
 		case ACPI_TYPE_PROCESSOR:
 
<span class="p_del">-			acpi_os_printf(&quot;ID %X Len %.4X Addr %p\n&quot;,</span>
<span class="p_add">+			acpi_os_printf(&quot;ID %02X Len %02X Addr %8.8X%8.8X\n&quot;,</span>
 				       obj_desc-&gt;processor.proc_id,
 				       obj_desc-&gt;processor.length,
<span class="p_del">-				       ACPI_CAST_PTR(void,</span>
<span class="p_del">-						     obj_desc-&gt;processor.</span>
<span class="p_del">-						     address));</span>
<span class="p_add">+				       ACPI_FORMAT_UINT64(obj_desc-&gt;processor.</span>
<span class="p_add">+							  address));</span>
 			break;
 
 		case ACPI_TYPE_DEVICE:
<span class="p_chunk">@@ -327,8 +326,9 @@</span> <span class="p_context"> acpi_ns_dump_one_object(acpi_handle obj_handle,</span>
 							       space_id));
 			if (obj_desc-&gt;region.flags &amp; AOPOBJ_DATA_VALID) {
 				acpi_os_printf(&quot; Addr %8.8X%8.8X Len %.4X\n&quot;,
<span class="p_del">-					       ACPI_FORMAT_NATIVE_UINT</span>
<span class="p_del">-					       (obj_desc-&gt;region.address),</span>
<span class="p_add">+					       ACPI_FORMAT_UINT64(obj_desc-&gt;</span>
<span class="p_add">+								  region.</span>
<span class="p_add">+								  address),</span>
 					       obj_desc-&gt;region.length);
 			} else {
 				acpi_os_printf
<span class="p_header">diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c</span>
<span class="p_header">index 62365f6..08a3380 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbinstal.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbinstal.c</span>
<span class="p_chunk">@@ -228,9 +228,9 @@</span> <span class="p_context"> acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)</span>
 	status = acpi_os_table_override(table_desc-&gt;pointer, &amp;override_table);
 	if (ACPI_SUCCESS(status) &amp;&amp; override_table) {
 		ACPI_INFO((AE_INFO,
<span class="p_del">-			   &quot;%4.4s @ 0x%p Table override, replaced with:&quot;,</span>
<span class="p_add">+			   &quot;%4.4s @ 0x%8.8X%8.8X Table override, replaced with:&quot;,</span>
 			   table_desc-&gt;pointer-&gt;signature,
<span class="p_del">-			   ACPI_CAST_PTR(void, table_desc-&gt;address)));</span>
<span class="p_add">+			   ACPI_FORMAT_UINT64(table_desc-&gt;address)));</span>
 
 		/* We can delete the table that was passed as a parameter */
 
<span class="p_header">diff --git a/drivers/acpi/acpica/tbutils.c b/drivers/acpi/acpica/tbutils.c</span>
<span class="p_header">index 0f2d395..24de78fe 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbutils.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbutils.c</span>
<span class="p_chunk">@@ -237,16 +237,12 @@</span> <span class="p_context"> acpi_tb_print_table_header(acpi_physical_address address,</span>
 {
 	struct acpi_table_header local_header;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The reason that the Address is cast to a void pointer is so that we</span>
<span class="p_del">-	 * can use %p which will work properly on both 32-bit and 64-bit hosts.</span>
<span class="p_del">-	 */</span>
 	if (ACPI_COMPARE_NAME(header-&gt;signature, ACPI_SIG_FACS)) {
 
 		/* FACS only has signature and length fields */
 
<span class="p_del">-		ACPI_INFO((AE_INFO, &quot;%4.4s %p %05X&quot;,</span>
<span class="p_del">-			   header-&gt;signature, ACPI_CAST_PTR(void, address),</span>
<span class="p_add">+		ACPI_INFO((AE_INFO, &quot;%4.4s 0x%8.8X%8.8X %05X&quot;,</span>
<span class="p_add">+			   header-&gt;signature, ACPI_FORMAT_UINT64(address),</span>
 			   header-&gt;length));
 	} else if (ACPI_COMPARE_NAME(header-&gt;signature, ACPI_SIG_RSDP)) {
 
<span class="p_chunk">@@ -257,8 +253,8 @@</span> <span class="p_context"> acpi_tb_print_table_header(acpi_physical_address address,</span>
 					  header)-&gt;oem_id, ACPI_OEM_ID_SIZE);
 		acpi_tb_fix_string(local_header.oem_id, ACPI_OEM_ID_SIZE);
 
<span class="p_del">-		ACPI_INFO((AE_INFO, &quot;RSDP %p %05X (v%.2d %6.6s)&quot;,</span>
<span class="p_del">-			   ACPI_CAST_PTR (void, address),</span>
<span class="p_add">+		ACPI_INFO((AE_INFO, &quot;RSDP 0x%8.8X%8.8X %05X (v%.2d %6.6s)&quot;,</span>
<span class="p_add">+			   ACPI_FORMAT_UINT64(address),</span>
 			   (ACPI_CAST_PTR(struct acpi_table_rsdp, header)-&gt;
 			    revision &gt;
 			    0) ? ACPI_CAST_PTR(struct acpi_table_rsdp,
<span class="p_chunk">@@ -272,8 +268,8 @@</span> <span class="p_context"> acpi_tb_print_table_header(acpi_physical_address address,</span>
 		acpi_tb_cleanup_table_header(&amp;local_header, header);
 
 		ACPI_INFO((AE_INFO,
<span class="p_del">-			   &quot;%4.4s %p %05X (v%.2d %6.6s %8.8s %08X %4.4s %08X)&quot;,</span>
<span class="p_del">-			   local_header.signature, ACPI_CAST_PTR(void, address),</span>
<span class="p_add">+			   &quot;%-4.4s 0x%8.8X%8.8X %05X (v%.2d %-6.6s %-8.8s %08X %-4.4s %08X)&quot;,</span>
<span class="p_add">+			   local_header.signature, ACPI_FORMAT_UINT64(address),</span>
 			   local_header.length, local_header.revision,
 			   local_header.oem_id, local_header.oem_table_id,
 			   local_header.oem_revision,
<span class="p_chunk">@@ -488,9 +484,8 @@</span> <span class="p_context"> acpi_tb_install_table(acpi_physical_address address,</span>
 	status = acpi_os_table_override(mapped_table, &amp;override_table);
 	if (ACPI_SUCCESS(status) &amp;&amp; override_table) {
 		ACPI_INFO((AE_INFO,
<span class="p_del">-			   &quot;%4.4s @ 0x%p Table override, replaced with:&quot;,</span>
<span class="p_del">-			   mapped_table-&gt;signature, ACPI_CAST_PTR(void,</span>
<span class="p_del">-								  address)));</span>
<span class="p_add">+			   &quot;%4.4s @ 0x%8.8X%8.8X Table override, replaced with:&quot;,</span>
<span class="p_add">+			   mapped_table-&gt;signature, ACPI_FORMAT_UINT64(address)));</span>
 
 		acpi_gbl_root_table_list.tables[table_index].pointer =
 		    override_table;
<span class="p_header">diff --git a/drivers/acpi/acpica/tbxfroot.c b/drivers/acpi/acpica/tbxfroot.c</span>
<span class="p_header">index 7eb6c6c..0272fbe 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbxfroot.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbxfroot.c</span>
<span class="p_chunk">@@ -119,7 +119,7 @@</span> <span class="p_context"> static acpi_status acpi_tb_validate_rsdp(struct acpi_table_rsdp *rsdp)</span>
  *
  ******************************************************************************/
 
<span class="p_del">-acpi_status acpi_find_root_pointer(acpi_size *table_address)</span>
<span class="p_add">+acpi_status acpi_find_root_pointer(acpi_physical_address * table_address)</span>
 {
 	u8 *table_ptr;
 	u8 *mem_rover;
<span class="p_chunk">@@ -177,7 +177,8 @@</span> <span class="p_context"> acpi_status acpi_find_root_pointer(acpi_size *table_address)</span>
 			physical_address +=
 			    (u32) ACPI_PTR_DIFF(mem_rover, table_ptr);
 
<span class="p_del">-			*table_address = physical_address;</span>
<span class="p_add">+			*table_address =</span>
<span class="p_add">+			    (acpi_physical_address) physical_address;</span>
 			return_ACPI_STATUS(AE_OK);
 		}
 	}
<span class="p_chunk">@@ -210,7 +211,7 @@</span> <span class="p_context"> acpi_status acpi_find_root_pointer(acpi_size *table_address)</span>
 		    (ACPI_HI_RSDP_WINDOW_BASE +
 		     ACPI_PTR_DIFF(mem_rover, table_ptr));
 
<span class="p_del">-		*table_address = physical_address;</span>
<span class="p_add">+		*table_address = (acpi_physical_address) physical_address;</span>
 		return_ACPI_STATUS(AE_OK);
 	}
 
<span class="p_header">diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c</span>
<span class="p_header">index a6664d2..7be7aa6 100644</span>
<span class="p_header">--- a/drivers/acpi/osl.c</span>
<span class="p_header">+++ b/drivers/acpi/osl.c</span>
<span class="p_chunk">@@ -179,7 +179,7 @@</span> <span class="p_context"> static void __init acpi_request_region (struct acpi_generic_address *addr,</span>
 		request_mem_region(addr-&gt;address, length, desc);
 }
 
<span class="p_del">-static int __init acpi_reserve_resources(void)</span>
<span class="p_add">+static void __init acpi_reserve_resources(void)</span>
 {
 	acpi_request_region(&amp;acpi_gbl_FADT.xpm1a_event_block, acpi_gbl_FADT.pm1_event_length,
 		&quot;ACPI PM1a_EVT_BLK&quot;);
<span class="p_chunk">@@ -208,10 +208,7 @@</span> <span class="p_context"> static int __init acpi_reserve_resources(void)</span>
 	if (!(acpi_gbl_FADT.gpe1_block_length &amp; 0x1))
 		acpi_request_region(&amp;acpi_gbl_FADT.xgpe1_block,
 			       acpi_gbl_FADT.gpe1_block_length, &quot;ACPI GPE1_BLK&quot;);
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
 }
<span class="p_del">-device_initcall(acpi_reserve_resources);</span>
 
 void acpi_os_printf(const char *fmt, ...)
 {
<span class="p_chunk">@@ -1630,6 +1627,7 @@</span> <span class="p_context"> acpi_status __init acpi_os_initialize(void)</span>
 
 acpi_status __init acpi_os_initialize1(void)
 {
<span class="p_add">+	acpi_reserve_resources();</span>
 	kacpid_wq = alloc_workqueue(&quot;kacpid&quot;, 0, 1);
 	kacpi_notify_wq = alloc_workqueue(&quot;kacpi_notify&quot;, 0, 1);
 	kacpi_hotplug_wq = alloc_workqueue(&quot;kacpi_hotplug&quot;, 0, 1);
<span class="p_header">diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c</span>
<span class="p_header">index 81f32e5..e2958aa 100644</span>
<span class="p_header">--- a/drivers/ata/ahci.c</span>
<span class="p_header">+++ b/drivers/ata/ahci.c</span>
<span class="p_chunk">@@ -67,6 +67,7 @@</span> <span class="p_context"> enum board_ids {</span>
 	board_ahci_yes_fbs,
 
 	/* board IDs for specific chipsets in alphabetical order */
<span class="p_add">+	board_ahci_avn,</span>
 	board_ahci_mcp65,
 	board_ahci_mcp77,
 	board_ahci_mcp89,
<span class="p_chunk">@@ -85,6 +86,8 @@</span> <span class="p_context"> enum board_ids {</span>
 static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent);
 static int ahci_vt8251_hardreset(struct ata_link *link, unsigned int *class,
 				 unsigned long deadline);
<span class="p_add">+static int ahci_avn_hardreset(struct ata_link *link, unsigned int *class,</span>
<span class="p_add">+			      unsigned long deadline);</span>
 static int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,
 				unsigned long deadline);
 #ifdef CONFIG_PM
<span class="p_chunk">@@ -108,6 +111,11 @@</span> <span class="p_context"> static struct ata_port_operations ahci_p5wdh_ops = {</span>
 
 #define AHCI_HFLAGS(flags)	.private_data	= (void *)(flags)
 
<span class="p_add">+static struct ata_port_operations ahci_avn_ops = {</span>
<span class="p_add">+	.inherits		= &amp;ahci_ops,</span>
<span class="p_add">+	.hardreset		= ahci_avn_hardreset,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct ata_port_info ahci_port_info[] = {
 	/* by features */
 	[board_ahci] =
<span class="p_chunk">@@ -156,6 +164,12 @@</span> <span class="p_context"> static const struct ata_port_info ahci_port_info[] = {</span>
 		.port_ops	= &amp;ahci_ops,
 	},
 	/* by chipsets */
<span class="p_add">+	[board_ahci_avn] = {</span>
<span class="p_add">+		.flags		= AHCI_FLAG_COMMON,</span>
<span class="p_add">+		.pio_mask	= ATA_PIO4,</span>
<span class="p_add">+		.udma_mask	= ATA_UDMA6,</span>
<span class="p_add">+		.port_ops	= &amp;ahci_avn_ops,</span>
<span class="p_add">+	},</span>
 	[board_ahci_mcp65] =
 	{
 		AHCI_HFLAGS	(AHCI_HFLAG_NO_FPDMA_AA | AHCI_HFLAG_NO_PMP |
<span class="p_chunk">@@ -302,14 +316,14 @@</span> <span class="p_context"> static const struct pci_device_id ahci_pci_tbl[] = {</span>
 	{ PCI_VDEVICE(INTEL, 0x1f27), board_ahci }, /* Avoton RAID */
 	{ PCI_VDEVICE(INTEL, 0x1f2e), board_ahci }, /* Avoton RAID */
 	{ PCI_VDEVICE(INTEL, 0x1f2f), board_ahci }, /* Avoton RAID */
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f32), board_ahci }, /* Avoton AHCI */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f33), board_ahci }, /* Avoton AHCI */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f34), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f35), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f36), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f37), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f3e), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f3f), board_ahci }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f32), board_ahci_avn }, /* Avoton AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f33), board_ahci_avn }, /* Avoton AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f34), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f35), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f36), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f37), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f3e), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f3f), board_ahci_avn }, /* Avoton RAID */</span>
 	{ PCI_VDEVICE(INTEL, 0x8d02), board_ahci }, /* Wellsburg AHCI */
 	{ PCI_VDEVICE(INTEL, 0x8d04), board_ahci }, /* Wellsburg RAID */
 	{ PCI_VDEVICE(INTEL, 0x8d06), board_ahci }, /* Wellsburg RAID */
<span class="p_chunk">@@ -680,6 +694,78 @@</span> <span class="p_context"> static int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,</span>
 	return rc;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * ahci_avn_hardreset - attempt more aggressive recovery of Avoton ports.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * It has been observed with some SSDs that the timing of events in the</span>
<span class="p_add">+ * link synchronization phase can leave the port in a state that can not</span>
<span class="p_add">+ * be recovered by a SATA-hard-reset alone.  The failing signature is</span>
<span class="p_add">+ * SStatus.DET stuck at 1 (&quot;Device presence detected but Phy</span>
<span class="p_add">+ * communication not established&quot;).  It was found that unloading and</span>
<span class="p_add">+ * reloading the driver when this problem occurs allows the drive</span>
<span class="p_add">+ * connection to be recovered (DET advanced to 0x3).  The critical</span>
<span class="p_add">+ * component of reloading the driver is that the port state machines are</span>
<span class="p_add">+ * reset by bouncing &quot;port enable&quot; in the AHCI PCS configuration</span>
<span class="p_add">+ * register.  So, reproduce that effect by bouncing a port whenever we</span>
<span class="p_add">+ * see DET==1 after a reset.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int ahci_avn_hardreset(struct ata_link *link, unsigned int *class,</span>
<span class="p_add">+			      unsigned long deadline)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const unsigned long *timing = sata_ehc_deb_timing(&amp;link-&gt;eh_context);</span>
<span class="p_add">+	struct ata_port *ap = link-&gt;ap;</span>
<span class="p_add">+	struct ahci_port_priv *pp = ap-&gt;private_data;</span>
<span class="p_add">+	u8 *d2h_fis = pp-&gt;rx_fis + RX_FIS_D2H_REG;</span>
<span class="p_add">+	unsigned long tmo = deadline - jiffies;</span>
<span class="p_add">+	struct ata_taskfile tf;</span>
<span class="p_add">+	bool online;</span>
<span class="p_add">+	int rc, i;</span>
<span class="p_add">+</span>
<span class="p_add">+	DPRINTK(&quot;ENTER\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	ahci_stop_engine(ap);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; 2; i++) {</span>
<span class="p_add">+		u16 val;</span>
<span class="p_add">+		u32 sstatus;</span>
<span class="p_add">+		int port = ap-&gt;port_no;</span>
<span class="p_add">+		struct ata_host *host = ap-&gt;host;</span>
<span class="p_add">+		struct pci_dev *pdev = to_pci_dev(host-&gt;dev);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* clear D2H reception area to properly wait for D2H FIS */</span>
<span class="p_add">+		ata_tf_init(link-&gt;device, &amp;tf);</span>
<span class="p_add">+		tf.command = ATA_BUSY;</span>
<span class="p_add">+		ata_tf_to_fis(&amp;tf, 0, 0, d2h_fis);</span>
<span class="p_add">+</span>
<span class="p_add">+		rc = sata_link_hardreset(link, timing, deadline, &amp;online,</span>
<span class="p_add">+				ahci_check_ready);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (sata_scr_read(link, SCR_STATUS, &amp;sstatus) != 0 ||</span>
<span class="p_add">+				(sstatus &amp; 0xf) != 1)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		ata_link_printk(link, KERN_INFO, &quot;avn bounce port%d\n&quot;,</span>
<span class="p_add">+				port);</span>
<span class="p_add">+</span>
<span class="p_add">+		pci_read_config_word(pdev, 0x92, &amp;val);</span>
<span class="p_add">+		val &amp;= ~(1 &lt;&lt; port);</span>
<span class="p_add">+		pci_write_config_word(pdev, 0x92, val);</span>
<span class="p_add">+		ata_msleep(ap, 1000);</span>
<span class="p_add">+		val |= 1 &lt;&lt; port;</span>
<span class="p_add">+		pci_write_config_word(pdev, 0x92, val);</span>
<span class="p_add">+		deadline += tmo;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ahci_start_engine(ap);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (online)</span>
<span class="p_add">+		*class = ahci_dev_classify(ap);</span>
<span class="p_add">+</span>
<span class="p_add">+	DPRINTK(&quot;EXIT, rc=%d, class=%u\n&quot;, rc, *class);</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 #ifdef CONFIG_PM
 static int ahci_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg)
 {
<span class="p_header">diff --git a/drivers/ata/ahci.h b/drivers/ata/ahci.h</span>
<span class="p_header">index b175000..cdf58f7 100644</span>
<span class="p_header">--- a/drivers/ata/ahci.h</span>
<span class="p_header">+++ b/drivers/ata/ahci.h</span>
<span class="p_chunk">@@ -314,6 +314,7 @@</span> <span class="p_context"> extern struct device_attribute *ahci_sdev_attrs[];</span>
 extern struct ata_port_operations ahci_ops;
 extern struct ata_port_operations ahci_pmp_retry_srst_ops;
 
<span class="p_add">+unsigned int ahci_dev_classify(struct ata_port *ap);</span>
 void ahci_fill_cmd_slot(struct ahci_port_priv *pp, unsigned int tag,
 			u32 opts);
 void ahci_save_initial_config(struct device *dev,
<span class="p_header">diff --git a/drivers/ata/libahci.c b/drivers/ata/libahci.c</span>
<span class="p_header">index de2802c..41ffb8c 100644</span>
<span class="p_header">--- a/drivers/ata/libahci.c</span>
<span class="p_header">+++ b/drivers/ata/libahci.c</span>
<span class="p_chunk">@@ -1137,7 +1137,7 @@</span> <span class="p_context"> static void ahci_dev_config(struct ata_device *dev)</span>
 	}
 }
 
<span class="p_del">-static unsigned int ahci_dev_classify(struct ata_port *ap)</span>
<span class="p_add">+unsigned int ahci_dev_classify(struct ata_port *ap)</span>
 {
 	void __iomem *port_mmio = ahci_port_base(ap);
 	struct ata_taskfile tf;
<span class="p_chunk">@@ -1151,6 +1151,7 @@</span> <span class="p_context"> static unsigned int ahci_dev_classify(struct ata_port *ap)</span>
 
 	return ata_dev_classify(&amp;tf);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(ahci_dev_classify);</span>
 
 void ahci_fill_cmd_slot(struct ahci_port_priv *pp, unsigned int tag,
 			u32 opts)
<span class="p_chunk">@@ -1668,8 +1669,7 @@</span> <span class="p_context"> static void ahci_port_intr(struct ata_port *ap)</span>
 	if (unlikely(resetting))
 		status &amp;= ~PORT_IRQ_BAD_PMP;
 
<span class="p_del">-	/* if LPM is enabled, PHYRDY doesn&#39;t mean anything */</span>
<span class="p_del">-	if (ap-&gt;link.lpm_policy &gt; ATA_LPM_MAX_POWER) {</span>
<span class="p_add">+	if (sata_lpm_ignore_phy_events(&amp;ap-&gt;link)) {</span>
 		status &amp;= ~PORT_IRQ_PHYRDY;
 		ahci_scr_write(&amp;ap-&gt;link, SCR_ERROR, SERR_PHYRDY_CHG);
 	}
<span class="p_header">diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c</span>
<span class="p_header">index 5d8fc3d..fcd8586 100644</span>
<span class="p_header">--- a/drivers/ata/libata-core.c</span>
<span class="p_header">+++ b/drivers/ata/libata-core.c</span>
<span class="p_chunk">@@ -6615,6 +6615,38 @@</span> <span class="p_context"> u32 ata_wait_register(struct ata_port *ap, void __iomem *reg, u32 mask, u32 val,</span>
 	return tmp;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ *	sata_lpm_ignore_phy_events - test if PHY event should be ignored</span>
<span class="p_add">+ *	@link: Link receiving the event</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Test whether the received PHY event has to be ignored or not.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	LOCKING:</span>
<span class="p_add">+ *	None:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	RETURNS:</span>
<span class="p_add">+ *	True if the event has to be ignored.</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool sata_lpm_ignore_phy_events(struct ata_link *link)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long lpm_timeout = link-&gt;last_lpm_change +</span>
<span class="p_add">+				    msecs_to_jiffies(ATA_TMOUT_SPURIOUS_PHY);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* if LPM is enabled, PHYRDY doesn&#39;t mean anything */</span>
<span class="p_add">+	if (link-&gt;lpm_policy &gt; ATA_LPM_MAX_POWER)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* ignore the first PHY event after the LPM policy changed</span>
<span class="p_add">+	 * as it is might be spurious</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((link-&gt;flags &amp; ATA_LFLAG_CHANGED) &amp;&amp;</span>
<span class="p_add">+	    time_before(jiffies, lpm_timeout))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(sata_lpm_ignore_phy_events);</span>
<span class="p_add">+</span>
 /*
  * Dummy port_ops
  */
<span class="p_header">diff --git a/drivers/ata/libata-eh.c b/drivers/ata/libata-eh.c</span>
<span class="p_header">index 7d1a478..f54b0775 100644</span>
<span class="p_header">--- a/drivers/ata/libata-eh.c</span>
<span class="p_header">+++ b/drivers/ata/libata-eh.c</span>
<span class="p_chunk">@@ -3423,6 +3423,9 @@</span> <span class="p_context"> static int ata_eh_set_lpm(struct ata_link *link, enum ata_lpm_policy policy,</span>
 		}
 	}
 
<span class="p_add">+	link-&gt;last_lpm_change = jiffies;</span>
<span class="p_add">+	link-&gt;flags |= ATA_LFLAG_CHANGED;</span>
<span class="p_add">+</span>
 	return 0;
 
 fail:
<span class="p_header">diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c</span>
<span class="p_header">index 3eb6ad2..9f32f43 100644</span>
<span class="p_header">--- a/drivers/bluetooth/ath3k.c</span>
<span class="p_header">+++ b/drivers/bluetooth/ath3k.c</span>
<span class="p_chunk">@@ -63,6 +63,7 @@</span> <span class="p_context"> static struct usb_device_id ath3k_table[] = {</span>
 	/* Atheros AR3011 with sflash firmware*/
 	{ USB_DEVICE(0x0489, 0xE027) },
 	{ USB_DEVICE(0x0489, 0xE03D) },
<span class="p_add">+	{ USB_DEVICE(0x04F2, 0xAFF1) },</span>
 	{ USB_DEVICE(0x0930, 0x0215) },
 	{ USB_DEVICE(0x0CF3, 0x3002) },
 	{ USB_DEVICE(0x0CF3, 0xE019) },
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index 5c385e5..92973a3 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -148,6 +148,7 @@</span> <span class="p_context"> static struct usb_device_id blacklist_table[] = {</span>
 	/* Atheros 3011 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xe027), .driver_info = BTUSB_IGNORE },
 	{ USB_DEVICE(0x0489, 0xe03d), .driver_info = BTUSB_IGNORE },
<span class="p_add">+	{ USB_DEVICE(0x04f2, 0xaff1), .driver_info = BTUSB_IGNORE },</span>
 	{ USB_DEVICE(0x0930, 0x0215), .driver_info = BTUSB_IGNORE },
 	{ USB_DEVICE(0x0cf3, 0x3002), .driver_info = BTUSB_IGNORE },
 	{ USB_DEVICE(0x0cf3, 0xe019), .driver_info = BTUSB_IGNORE },
<span class="p_header">diff --git a/drivers/edac/Kconfig b/drivers/edac/Kconfig</span>
<span class="p_header">index 5948a21..203361e 100644</span>
<span class="p_header">--- a/drivers/edac/Kconfig</span>
<span class="p_header">+++ b/drivers/edac/Kconfig</span>
<span class="p_chunk">@@ -214,7 +214,7 @@</span> <span class="p_context"> config EDAC_I7300</span>
 
 config EDAC_SBRIDGE
 	tristate &quot;Intel Sandy-Bridge Integrated MC&quot;
<span class="p_del">-	depends on EDAC_MM_EDAC &amp;&amp; PCI &amp;&amp; X86_64 &amp;&amp; X86_MCE_INTEL</span>
<span class="p_add">+	depends on EDAC_MM_EDAC &amp;&amp; PCI &amp;&amp; X86 &amp;&amp; X86_MCE_INTEL</span>
 	depends on EXPERIMENTAL
 	help
 	  Support for error detection and correction the Intel
<span class="p_header">diff --git a/drivers/edac/sb_edac.c b/drivers/edac/sb_edac.c</span>
<span class="p_header">index da71881..f8f790c 100644</span>
<span class="p_header">--- a/drivers/edac/sb_edac.c</span>
<span class="p_header">+++ b/drivers/edac/sb_edac.c</span>
<span class="p_chunk">@@ -20,6 +20,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/mmzone.h&gt;
 #include &lt;linux/smp.h&gt;
 #include &lt;linux/bitmap.h&gt;
<span class="p_add">+#include &lt;linux/math64.h&gt;</span>
 #include &lt;asm/processor.h&gt;
 #include &lt;asm/mce.h&gt;
 
<span class="p_chunk">@@ -671,6 +672,7 @@</span> <span class="p_context"> static void get_memory_layout(const struct mem_ctl_info *mci)</span>
 	u32 reg;
 	u64 limit, prv = 0;
 	u64 tmp_mb;
<span class="p_add">+	u32 gb, mb;</span>
 	u32 rir_way;
 
 	/*
<span class="p_chunk">@@ -683,8 +685,9 @@</span> <span class="p_context"> static void get_memory_layout(const struct mem_ctl_info *mci)</span>
 	pvt-&gt;tolm = GET_TOLM(reg);
 	tmp_mb = (1 + pvt-&gt;tolm) &gt;&gt; 20;
 
<span class="p_del">-	debugf0(&quot;TOLM: %Lu.%03Lu GB (0x%016Lx)\n&quot;,</span>
<span class="p_del">-		tmp_mb / 1000, tmp_mb % 1000, (u64)pvt-&gt;tolm);</span>
<span class="p_add">+	gb = div_u64_rem(tmp_mb, 1024, &amp;mb);</span>
<span class="p_add">+	debugf0(&quot;TOHM: %u.%03u GB (0x%016Lx)\n&quot;,</span>
<span class="p_add">+		gb, (mb*1000)/1024, (u64)pvt-&gt;tohm);</span>
 
 	/* Address range is already 45:25 */
 	pci_read_config_dword(pvt-&gt;pci_sad1, TOHM,
<span class="p_chunk">@@ -692,8 +695,9 @@</span> <span class="p_context"> static void get_memory_layout(const struct mem_ctl_info *mci)</span>
 	pvt-&gt;tohm = GET_TOHM(reg);
 	tmp_mb = (1 + pvt-&gt;tohm) &gt;&gt; 20;
 
<span class="p_del">-	debugf0(&quot;TOHM: %Lu.%03Lu GB (0x%016Lx)&quot;,</span>
<span class="p_del">-		tmp_mb / 1000, tmp_mb % 1000, (u64)pvt-&gt;tohm);</span>
<span class="p_add">+	gb = div_u64_rem(tmp_mb, 1024, &amp;mb);</span>
<span class="p_add">+	debugf0(&quot;TOHM: %u.%03u GB (0x%016Lx)&quot;,</span>
<span class="p_add">+		gb, (mb*1000)/1024, (u64)pvt-&gt;tohm);</span>
 
 	/*
 	 * Step 2) Get SAD range and SAD Interleave list
<span class="p_chunk">@@ -715,10 +719,11 @@</span> <span class="p_context"> static void get_memory_layout(const struct mem_ctl_info *mci)</span>
 			break;
 
 		tmp_mb = (limit + 1) &gt;&gt; 20;
<span class="p_del">-		debugf0(&quot;SAD#%d %s up to %Lu.%03Lu GB (0x%016Lx) %s reg=0x%08x\n&quot;,</span>
<span class="p_add">+		gb = div_u64_rem(tmp_mb, 1000, &amp;mb);</span>
<span class="p_add">+		debugf0(&quot;SAD#%d %s up to %u.%03u GB (0x%016Lx) %s reg=0x%08x\n&quot;,</span>
 			n_sads,
 			get_dram_attr(reg),
<span class="p_del">-			tmp_mb / 1000, tmp_mb % 1000,</span>
<span class="p_add">+			gb, (mb*1000)/1024,</span>
 			((u64)tmp_mb) &lt;&lt; 20L,
 			INTERLEAVE_MODE(reg) ? &quot;Interleave: 8:6&quot; : &quot;Interleave: [8:6]XOR[18:16]&quot;,
 			reg);
<span class="p_chunk">@@ -748,8 +753,9 @@</span> <span class="p_context"> static void get_memory_layout(const struct mem_ctl_info *mci)</span>
 			break;
 		tmp_mb = (limit + 1) &gt;&gt; 20;
 
<span class="p_del">-		debugf0(&quot;TAD#%d: up to %Lu.%03Lu GB (0x%016Lx), socket interleave %d, memory interleave %d, TGT: %d, %d, %d, %d, reg=0x%08x\n&quot;,</span>
<span class="p_del">-			n_tads, tmp_mb / 1000, tmp_mb % 1000,</span>
<span class="p_add">+		gb = div_u64_rem(tmp_mb, 1000, &amp;mb);</span>
<span class="p_add">+		debugf0(&quot;TAD#%d: up to %u.%03u GB (0x%016Lx), socket interleave %d, memory interleave %d, TGT: %d, %d, %d, %d, reg=0x%08x\n&quot;,</span>
<span class="p_add">+			n_tads, gb, (mb*1000)/1024,</span>
 			((u64)tmp_mb) &lt;&lt; 20L,
 			(u32)TAD_SOCK(reg),
 			(u32)TAD_CH(reg),
<span class="p_chunk">@@ -772,9 +778,10 @@</span> <span class="p_context"> static void get_memory_layout(const struct mem_ctl_info *mci)</span>
 					      tad_ch_nilv_offset[j],
 					      &amp;reg);
 			tmp_mb = TAD_OFFSET(reg) &gt;&gt; 20;
<span class="p_del">-			debugf0(&quot;TAD CH#%d, offset #%d: %Lu.%03Lu GB (0x%016Lx), reg=0x%08x\n&quot;,</span>
<span class="p_add">+			gb = div_u64_rem(tmp_mb, 1024, &amp;mb);</span>
<span class="p_add">+			debugf0(&quot;TAD CH#%d, offset #%d: %u.%03u GB (0x%016Lx), reg=0x%08x\n&quot;,</span>
 				i, j,
<span class="p_del">-				tmp_mb / 1000, tmp_mb % 1000,</span>
<span class="p_add">+				gb, (mb*1000)/1024,</span>
 				((u64)tmp_mb) &lt;&lt; 20L,
 				reg);
 		}
<span class="p_chunk">@@ -796,9 +803,10 @@</span> <span class="p_context"> static void get_memory_layout(const struct mem_ctl_info *mci)</span>
 
 			tmp_mb = RIR_LIMIT(reg) &gt;&gt; 20;
 			rir_way = 1 &lt;&lt; RIR_WAY(reg);
<span class="p_del">-			debugf0(&quot;CH#%d RIR#%d, limit: %Lu.%03Lu GB (0x%016Lx), way: %d, reg=0x%08x\n&quot;,</span>
<span class="p_add">+			gb = div_u64_rem(tmp_mb, 1024, &amp;mb);</span>
<span class="p_add">+			debugf0(&quot;CH#%d RIR#%d, limit: %u.%03u GB (0x%016Lx), way: %d, reg=0x%08x\n&quot;,</span>
 				i, j,
<span class="p_del">-				tmp_mb / 1000, tmp_mb % 1000,</span>
<span class="p_add">+				gb, (mb*1000)/1024,</span>
 				((u64)tmp_mb) &lt;&lt; 20L,
 				rir_way,
 				reg);
<span class="p_chunk">@@ -809,9 +817,10 @@</span> <span class="p_context"> static void get_memory_layout(const struct mem_ctl_info *mci)</span>
 						      &amp;reg);
 				tmp_mb = RIR_OFFSET(reg) &lt;&lt; 6;
 
<span class="p_del">-				debugf0(&quot;CH#%d RIR#%d INTL#%d, offset %Lu.%03Lu GB (0x%016Lx), tgt: %d, reg=0x%08x\n&quot;,</span>
<span class="p_add">+				gb = div_u64_rem(tmp_mb, 1024, &amp;mb);</span>
<span class="p_add">+				debugf0(&quot;CH#%d RIR#%d INTL#%d, offset %u.%03u GB (0x%016Lx), tgt: %d, reg=0x%08x\n&quot;,</span>
 					i, j, k,
<span class="p_del">-					tmp_mb / 1000, tmp_mb % 1000,</span>
<span class="p_add">+					gb, (mb*1000)/1024,</span>
 					((u64)tmp_mb) &lt;&lt; 20L,
 					(u32)RIR_RNK_TGT(reg),
 					reg);
<span class="p_chunk">@@ -849,6 +858,7 @@</span> <span class="p_context"> static int get_memory_error_data(struct mem_ctl_info *mci,</span>
 	u8			ch_way,sck_way;
 	u32			tad_offset;
 	u32			rir_way;
<span class="p_add">+	u32			gb, mb;</span>
 	u64			ch_addr, offset, limit, prv = 0;
 
 
<span class="p_chunk">@@ -859,7 +869,7 @@</span> <span class="p_context"> static int get_memory_error_data(struct mem_ctl_info *mci,</span>
 	 * range (e. g. VGA addresses). It is unlikely, however, that the
 	 * memory controller would generate an error on that range.
 	 */
<span class="p_del">-	if ((addr &gt; (u64) pvt-&gt;tolm) &amp;&amp; (addr &lt; (1L &lt;&lt; 32))) {</span>
<span class="p_add">+	if ((addr &gt; (u64) pvt-&gt;tolm) &amp;&amp; (addr &lt; (1LL &lt;&lt; 32))) {</span>
 		sprintf(msg, &quot;Error at TOLM area, on addr 0x%08Lx&quot;, addr);
 		edac_mc_handle_ce_no_info(mci, msg);
 		return -EINVAL;
<span class="p_chunk">@@ -1054,7 +1064,7 @@</span> <span class="p_context"> static int get_memory_error_data(struct mem_ctl_info *mci,</span>
 	ch_addr = addr &amp; 0x7f;
 	/* Remove socket wayness and remove 6 bits */
 	addr &gt;&gt;= 6;
<span class="p_del">-	addr /= sck_xch;</span>
<span class="p_add">+	addr = div_u64(addr, sck_xch);</span>
 #if 0
 	/* Divide by channel way */
 	addr = addr / ch_way;
<span class="p_chunk">@@ -1074,10 +1084,10 @@</span> <span class="p_context"> static int get_memory_error_data(struct mem_ctl_info *mci,</span>
 			continue;
 
 		limit = RIR_LIMIT(reg);
<span class="p_del">-</span>
<span class="p_del">-		debugf0(&quot;RIR#%d, limit: %Lu.%03Lu GB (0x%016Lx), way: %d\n&quot;,</span>
<span class="p_add">+		gb = div_u64_rem(limit &gt;&gt; 20, 1024, &amp;mb);</span>
<span class="p_add">+		debugf0(&quot;RIR#%d, limit: %u.%03u GB (0x%016Lx), way: %d\n&quot;,</span>
 			n_rir,
<span class="p_del">-			(limit &gt;&gt; 20) / 1000, (limit &gt;&gt; 20) % 1000,</span>
<span class="p_add">+			gb, (mb*1000)/1024,</span>
 			limit,
 			1 &lt;&lt; RIR_WAY(reg));
 		if  (ch_addr &lt;= limit)
<span class="p_header">diff --git a/drivers/firmware/dmi_scan.c b/drivers/firmware/dmi_scan.c</span>
<span class="p_header">index 2861ef4..20f7daa 100644</span>
<span class="p_header">--- a/drivers/firmware/dmi_scan.c</span>
<span class="p_header">+++ b/drivers/firmware/dmi_scan.c</span>
<span class="p_chunk">@@ -410,24 +410,48 @@</span> <span class="p_context"> static void __init dmi_dump_ids(void)</span>
 	printk(KERN_CONT &quot;\n&quot;);
 }
 
<span class="p_del">-static int __init dmi_present(const char __iomem *p)</span>
<span class="p_add">+static int __init dmi_present(const u8 *buf)</span>
 {
<span class="p_del">-	u8 buf[15];</span>
<span class="p_add">+	int smbios_ver;</span>
 
<span class="p_del">-	memcpy_fromio(buf, p, 15);</span>
<span class="p_del">-	if (dmi_checksum(buf, 15)) {</span>
<span class="p_add">+	if (memcmp(buf, &quot;_SM_&quot;, 4) == 0 &amp;&amp;</span>
<span class="p_add">+	    buf[5] &lt; 32 &amp;&amp; dmi_checksum(buf, buf[5])) {</span>
<span class="p_add">+		smbios_ver = (buf[6] &lt;&lt; 8) + buf[7];</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Some BIOS report weird SMBIOS version, fix that up */</span>
<span class="p_add">+		switch (smbios_ver) {</span>
<span class="p_add">+		case 0x021F:</span>
<span class="p_add">+		case 0x0221:</span>
<span class="p_add">+			pr_debug(&quot;SMBIOS version fixup(2.%d-&gt;2.%d)\n&quot;,</span>
<span class="p_add">+				 smbios_ver &amp; 0xFF, 3);</span>
<span class="p_add">+			smbios_ver = 0x0203;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0x0233:</span>
<span class="p_add">+			pr_debug(&quot;SMBIOS version fixup(2.%d-&gt;2.%d)\n&quot;, 51, 6);</span>
<span class="p_add">+			smbios_ver = 0x0206;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		smbios_ver = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	buf += 16;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (memcmp(buf, &quot;_DMI_&quot;, 5) == 0 &amp;&amp; dmi_checksum(buf, 15)) {</span>
<span class="p_add">+		if (smbios_ver)</span>
<span class="p_add">+			dmi_ver = smbios_ver;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			dmi_ver = (buf[14] &amp; 0xF0) &lt;&lt; 4 | (buf[14] &amp; 0x0F);</span>
 		dmi_num = (buf[13] &lt;&lt; 8) | buf[12];
 		dmi_len = (buf[7] &lt;&lt; 8) | buf[6];
 		dmi_base = (buf[11] &lt;&lt; 24) | (buf[10] &lt;&lt; 16) |
 			(buf[9] &lt;&lt; 8) | buf[8];
 
 		if (dmi_walk_early(dmi_decode) == 0) {
<span class="p_del">-			if (dmi_ver)</span>
<span class="p_add">+			if (smbios_ver) {</span>
 				pr_info(&quot;SMBIOS %d.%d present.\n&quot;,
 				       dmi_ver &gt;&gt; 8, dmi_ver &amp; 0xFF);
<span class="p_del">-			else {</span>
<span class="p_del">-				dmi_ver = (buf[14] &amp; 0xF0) &lt;&lt; 4 |</span>
<span class="p_del">-					   (buf[14] &amp; 0x0F);</span>
<span class="p_add">+			} else {</span>
 				pr_info(&quot;Legacy DMI %d.%d present.\n&quot;,
 				       dmi_ver &gt;&gt; 8, dmi_ver &amp; 0xFF);
 			}
<span class="p_chunk">@@ -435,40 +459,14 @@</span> <span class="p_context"> static int __init dmi_present(const char __iomem *p)</span>
 			return 0;
 		}
 	}
<span class="p_del">-	dmi_ver = 0;</span>
<span class="p_del">-	return 1;</span>
<span class="p_del">-}</span>
 
<span class="p_del">-static int __init smbios_present(const char __iomem *p)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u8 buf[32];</span>
<span class="p_del">-</span>
<span class="p_del">-	memcpy_fromio(buf, p, 32);</span>
<span class="p_del">-	if ((buf[5] &lt; 32) &amp;&amp; dmi_checksum(buf, buf[5])) {</span>
<span class="p_del">-		dmi_ver = (buf[6] &lt;&lt; 8) + buf[7];</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Some BIOS report weird SMBIOS version, fix that up */</span>
<span class="p_del">-		switch (dmi_ver) {</span>
<span class="p_del">-		case 0x021F:</span>
<span class="p_del">-		case 0x0221:</span>
<span class="p_del">-			pr_debug(&quot;SMBIOS version fixup(2.%d-&gt;2.%d)\n&quot;,</span>
<span class="p_del">-			       dmi_ver &amp; 0xFF, 3);</span>
<span class="p_del">-			dmi_ver = 0x0203;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case 0x0233:</span>
<span class="p_del">-			pr_debug(&quot;SMBIOS version fixup(2.%d-&gt;2.%d)\n&quot;, 51, 6);</span>
<span class="p_del">-			dmi_ver = 0x0206;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		return memcmp(p + 16, &quot;_DMI_&quot;, 5) || dmi_present(p + 16);</span>
<span class="p_del">-	}</span>
 	return 1;
 }
 
 void __init dmi_scan_machine(void)
 {
 	char __iomem *p, *q;
<span class="p_del">-	int rc;</span>
<span class="p_add">+	char buf[32];</span>
 
 	if (efi_enabled(EFI_CONFIG_TABLES)) {
 		if (efi.smbios == EFI_INVALID_TABLE_ADDR)
<span class="p_chunk">@@ -481,10 +479,10 @@</span> <span class="p_context"> void __init dmi_scan_machine(void)</span>
 		p = dmi_ioremap(efi.smbios, 32);
 		if (p == NULL)
 			goto error;
<span class="p_del">-</span>
<span class="p_del">-		rc = smbios_present(p);</span>
<span class="p_add">+		memcpy_fromio(buf, p, 32);</span>
 		dmi_iounmap(p, 32);
<span class="p_del">-		if (!rc) {</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!dmi_present(buf)) {</span>
 			dmi_available = 1;
 			goto out;
 		}
<span class="p_chunk">@@ -499,18 +497,15 @@</span> <span class="p_context"> void __init dmi_scan_machine(void)</span>
 		if (p == NULL)
 			goto error;
 
<span class="p_add">+		memset(buf, 0, 16);</span>
 		for (q = p; q &lt; p + 0x10000; q += 16) {
<span class="p_del">-			if (memcmp(q, &quot;_SM_&quot;, 4) == 0 &amp;&amp; q - p &lt;= 0xFFE0)</span>
<span class="p_del">-				rc = smbios_present(q);</span>
<span class="p_del">-			else if (memcmp(q, &quot;_DMI_&quot;, 5) == 0)</span>
<span class="p_del">-				rc = dmi_present(q);</span>
<span class="p_del">-			else</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			if (!rc) {</span>
<span class="p_add">+			memcpy_fromio(buf + 16, q, 16);</span>
<span class="p_add">+			if (!dmi_present(buf)) {</span>
 				dmi_available = 1;
 				dmi_iounmap(p, 0x10000);
 				goto out;
 			}
<span class="p_add">+			memcpy(buf, buf + 16, 16);</span>
 		}
 		dmi_iounmap(p, 0x10000);
 	}
<span class="p_header">diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c</span>
<span class="p_header">index 36ae055..e901fef 100644</span>
<span class="p_header">--- a/drivers/gpio/gpiolib.c</span>
<span class="p_header">+++ b/drivers/gpio/gpiolib.c</span>
<span class="p_chunk">@@ -726,6 +726,7 @@</span> <span class="p_context"> static struct class gpio_class = {</span>
  */
 int gpio_export(unsigned gpio, bool direction_may_change)
 {
<span class="p_add">+	struct gpio_chip	*chip;</span>
 	unsigned long		flags;
 	struct gpio_desc	*desc;
 	int			status;
<span class="p_chunk">@@ -743,10 +744,18 @@</span> <span class="p_context"> int gpio_export(unsigned gpio, bool direction_may_change)</span>
 		return -EINVAL;
 	}
 
<span class="p_add">+	desc = &amp;gpio_desc[gpio];</span>
<span class="p_add">+	chip = desc-&gt;chip;</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;sysfs_lock);
 
<span class="p_add">+	/* check if chip is being removed */</span>
<span class="p_add">+	if (!chip || !chip-&gt;exported) {</span>
<span class="p_add">+		status = -ENODEV;</span>
<span class="p_add">+		goto fail_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;gpio_lock, flags);
<span class="p_del">-	desc = &amp;gpio_desc[gpio];</span>
 	if (!test_bit(FLAG_REQUESTED, &amp;desc-&gt;flags) ||
 	     test_bit(FLAG_EXPORT, &amp;desc-&gt;flags)) {
 		spin_unlock_irqrestore(&amp;gpio_lock, flags);
<span class="p_chunk">@@ -973,12 +982,15 @@</span> <span class="p_context"> static void gpiochip_unexport(struct gpio_chip *chip)</span>
 {
 	int			status;
 	struct device		*dev;
<span class="p_add">+	struct gpio_desc *desc;</span>
<span class="p_add">+	unsigned int i;</span>
 
 	mutex_lock(&amp;sysfs_lock);
 	dev = class_find_device(&amp;gpio_class, NULL, chip, match_export);
 	if (dev) {
 		put_device(dev);
 		device_unregister(dev);
<span class="p_add">+		/* prevent further gpiod exports */</span>
 		chip-&gt;exported = 0;
 		status = 0;
 	} else
<span class="p_chunk">@@ -988,6 +1000,13 @@</span> <span class="p_context"> static void gpiochip_unexport(struct gpio_chip *chip)</span>
 	if (status)
 		pr_debug(&quot;%s: chip %s status %d\n&quot;, __func__,
 				chip-&gt;label, status);
<span class="p_add">+</span>
<span class="p_add">+	/* unregister gpio class devices owned by sysfs */</span>
<span class="p_add">+	for (i = 0; i &lt; chip-&gt;ngpio; i++) {</span>
<span class="p_add">+		desc = &amp;gpio_desc[chip-&gt;base + i];</span>
<span class="p_add">+		if (test_and_clear_bit(FLAG_SYSFS, &amp;desc-&gt;flags))</span>
<span class="p_add">+			gpio_free(chip-&gt;base + i);</span>
<span class="p_add">+	}</span>
 }
 
 static int __init gpiolib_sysfs_init(void)
<span class="p_chunk">@@ -1137,6 +1156,8 @@</span> <span class="p_context"> int gpiochip_remove(struct gpio_chip *chip)</span>
 	int		status = 0;
 	unsigned	id;
 
<span class="p_add">+	gpiochip_unexport(chip);</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;gpio_lock, flags);
 
 	of_gpiochip_remove(chip);
<span class="p_chunk">@@ -1154,9 +1175,6 @@</span> <span class="p_context"> int gpiochip_remove(struct gpio_chip *chip)</span>
 
 	spin_unlock_irqrestore(&amp;gpio_lock, flags);
 
<span class="p_del">-	if (status == 0)</span>
<span class="p_del">-		gpiochip_unexport(chip);</span>
<span class="p_del">-</span>
 	return status;
 }
 EXPORT_SYMBOL_GPL(gpiochip_remove);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_crtc.c b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">index 927d170..76c4f2a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_chunk">@@ -302,8 +302,10 @@</span> <span class="p_context"> atombios_set_crtc_dtd_timing(struct drm_crtc *crtc,</span>
 		misc |= ATOM_COMPOSITESYNC;
 	if (mode-&gt;flags &amp; DRM_MODE_FLAG_INTERLACE)
 		misc |= ATOM_INTERLACE;
<span class="p_del">-	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLCLK)</span>
 		misc |= ATOM_DOUBLE_CLOCK_MODE;
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+		misc |= ATOM_H_REPLICATIONBY2 | ATOM_V_REPLICATIONBY2;</span>
 
 	args.susModeMiscInfo.usAccess = cpu_to_le16(misc);
 	args.ucCRTC = radeon_crtc-&gt;crtc_id;
<span class="p_chunk">@@ -346,8 +348,10 @@</span> <span class="p_context"> static void atombios_crtc_set_timing(struct drm_crtc *crtc,</span>
 		misc |= ATOM_COMPOSITESYNC;
 	if (mode-&gt;flags &amp; DRM_MODE_FLAG_INTERLACE)
 		misc |= ATOM_INTERLACE;
<span class="p_del">-	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLCLK)</span>
 		misc |= ATOM_DOUBLE_CLOCK_MODE;
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+		misc |= ATOM_H_REPLICATIONBY2 | ATOM_V_REPLICATIONBY2;</span>
 
 	args.susModeMiscInfo.usAccess = cpu_to_le16(misc);
 	args.ucCRTC = radeon_crtc-&gt;crtc_id;
<span class="p_header">diff --git a/drivers/hv/channel.c b/drivers/hv/channel.c</span>
<span class="p_header">index 44a1ea4..a7e6f03 100644</span>
<span class="p_header">--- a/drivers/hv/channel.c</span>
<span class="p_header">+++ b/drivers/hv/channel.c</span>
<span class="p_chunk">@@ -177,7 +177,7 @@</span> <span class="p_context"> int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,</span>
 			   GFP_KERNEL);
 	if (!open_info) {
 		err = -ENOMEM;
<span class="p_del">-		goto error0;</span>
<span class="p_add">+		goto error_gpadl;</span>
 	}
 
 	init_completion(&amp;open_info-&gt;waitevent);
<span class="p_chunk">@@ -193,7 +193,7 @@</span> <span class="p_context"> int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,</span>
 
 	if (userdatalen &gt; MAX_USER_DEFINED_BYTES) {
 		err = -EINVAL;
<span class="p_del">-		goto error0;</span>
<span class="p_add">+		goto error_gpadl;</span>
 	}
 
 	if (userdatalen)
<span class="p_chunk">@@ -234,6 +234,9 @@</span> <span class="p_context"> error1:</span>
 	list_del(&amp;open_info-&gt;msglistentry);
 	spin_unlock_irqrestore(&amp;vmbus_connection.channelmsg_lock, flags);
 
<span class="p_add">+error_gpadl:</span>
<span class="p_add">+	vmbus_teardown_gpadl(newchannel, newchannel-&gt;ringbuffer_gpadlhandle);</span>
<span class="p_add">+</span>
 error0:
 	free_pages((unsigned long)out,
 		get_order(send_ringbuffer_size + recv_ringbuffer_size));
<span class="p_header">diff --git a/drivers/hv/channel_mgmt.c b/drivers/hv/channel_mgmt.c</span>
<span class="p_header">index 12b85ff..7f963328b 100644</span>
<span class="p_header">--- a/drivers/hv/channel_mgmt.c</span>
<span class="p_header">+++ b/drivers/hv/channel_mgmt.c</span>
<span class="p_chunk">@@ -606,7 +606,7 @@</span> <span class="p_context"> int vmbus_request_offers(void)</span>
 {
 	struct vmbus_channel_message_header *msg;
 	struct vmbus_channel_msginfo *msginfo;
<span class="p_del">-	int ret, t;</span>
<span class="p_add">+	int ret;</span>
 
 	msginfo = kmalloc(sizeof(*msginfo) +
 			  sizeof(struct vmbus_channel_message_header),
<span class="p_chunk">@@ -614,8 +614,6 @@</span> <span class="p_context"> int vmbus_request_offers(void)</span>
 	if (!msginfo)
 		return -ENOMEM;
 
<span class="p_del">-	init_completion(&amp;msginfo-&gt;waitevent);</span>
<span class="p_del">-</span>
 	msg = (struct vmbus_channel_message_header *)msginfo-&gt;msg;
 
 	msg-&gt;msgtype = CHANNELMSG_REQUESTOFFERS;
<span class="p_chunk">@@ -629,14 +627,6 @@</span> <span class="p_context"> int vmbus_request_offers(void)</span>
 		goto cleanup;
 	}
 
<span class="p_del">-	t = wait_for_completion_timeout(&amp;msginfo-&gt;waitevent, 5*HZ);</span>
<span class="p_del">-	if (t == 0) {</span>
<span class="p_del">-		ret = -ETIMEDOUT;</span>
<span class="p_del">-		goto cleanup;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
 cleanup:
 	kfree(msginfo);
 
<span class="p_header">diff --git a/drivers/infiniband/core/umem.c b/drivers/infiniband/core/umem.c</span>
<span class="p_header">index 055ebeb..c1fef27 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/umem.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/umem.c</span>
<span class="p_chunk">@@ -94,12 +94,15 @@</span> <span class="p_context"> struct ib_umem *ib_umem_get(struct ib_ucontext *context, unsigned long addr,</span>
 	if (dmasync)
 		dma_set_attr(DMA_ATTR_WRITE_BARRIER, &amp;attrs);
 
<span class="p_add">+	if (!size)</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
 	/*
 	 * If the combination of the addr and size requested for this memory
 	 * region causes an integer overflow, return error.
 	 */
<span class="p_del">-	if ((PAGE_ALIGN(addr + size) &lt;= size) ||</span>
<span class="p_del">-	    (PAGE_ALIGN(addr + size) &lt;= addr))</span>
<span class="p_add">+	if (((addr + size) &lt; addr) ||</span>
<span class="p_add">+	    PAGE_ALIGN(addr + size) &lt; (addr + size))</span>
 		return ERR_PTR(-EINVAL);
 
 	if (!can_do_mlock())
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">index a16f0c8..2ed14a7 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_chunk">@@ -1670,8 +1670,7 @@</span> <span class="p_context"> static int build_lso_seg(struct mlx4_wqe_lso_seg *wqe, struct ib_send_wr *wr,</span>
 
 	memcpy(wqe-&gt;header, wr-&gt;wr.ud.header, wr-&gt;wr.ud.hlen);
 
<span class="p_del">-	*lso_hdr_sz  = cpu_to_be32((wr-&gt;wr.ud.mss - wr-&gt;wr.ud.hlen) &lt;&lt; 16 |</span>
<span class="p_del">-				   wr-&gt;wr.ud.hlen);</span>
<span class="p_add">+	*lso_hdr_sz  = cpu_to_be32(wr-&gt;wr.ud.mss &lt;&lt; 16 | wr-&gt;wr.ud.hlen);</span>
 	*lso_seg_len = halign;
 	return 0;
 }
<span class="p_header">diff --git a/drivers/input/mouse/elantech.c b/drivers/input/mouse/elantech.c</span>
<span class="p_header">index 2d5bb5b..548ea99 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.c</span>
<span class="p_chunk">@@ -296,7 +296,7 @@</span> <span class="p_context"> static void elantech_report_semi_mt_data(struct input_dev *dev,</span>
 					 unsigned int x2, unsigned int y2)
 {
 	elantech_set_slot(dev, 0, num_fingers != 0, x1, y1);
<span class="p_del">-	elantech_set_slot(dev, 1, num_fingers == 2, x2, y2);</span>
<span class="p_add">+	elantech_set_slot(dev, 1, num_fingers &gt;= 2, x2, y2);</span>
 }
 
 /*
<span class="p_chunk">@@ -692,18 +692,18 @@</span> <span class="p_context"> static int elantech_packet_check_v3(struct psmouse *psmouse)</span>
 static int elantech_packet_check_v4(struct psmouse *psmouse)
 {
 	unsigned char *packet = psmouse-&gt;packet;
<span class="p_add">+	unsigned char packet_type = packet[3] &amp; 0x03;</span>
 
<span class="p_del">-	if ((packet[0] &amp; 0x0c) == 0x04 &amp;&amp;</span>
<span class="p_del">-	    (packet[3] &amp; 0x1f) == 0x11)</span>
<span class="p_add">+	switch (packet_type) {</span>
<span class="p_add">+	case 0:</span>
<span class="p_add">+		return PACKET_V4_STATUS;</span>
<span class="p_add">+</span>
<span class="p_add">+	case 1:</span>
 		return PACKET_V4_HEAD;
 
<span class="p_del">-	if ((packet[0] &amp; 0x0c) == 0x04 &amp;&amp;</span>
<span class="p_del">-	    (packet[3] &amp; 0x1f) == 0x12)</span>
<span class="p_add">+	case 2:</span>
 		return PACKET_V4_MOTION;
<span class="p_del">-</span>
<span class="p_del">-	if ((packet[0] &amp; 0x0c) == 0x04 &amp;&amp;</span>
<span class="p_del">-	    (packet[3] &amp; 0x1f) == 0x10)</span>
<span class="p_del">-		return PACKET_V4_STATUS;</span>
<span class="p_add">+	}</span>
 
 	return PACKET_UNKNOWN;
 }
<span class="p_chunk">@@ -766,6 +766,21 @@</span> <span class="p_context"> static psmouse_ret_t elantech_process_byte(struct psmouse *psmouse)</span>
 }
 
 /*
<span class="p_add">+ * This writes the reg_07 value again to the hardware at the end of every</span>
<span class="p_add">+ * set_rate call because the register loses its value. reg_07 allows setting</span>
<span class="p_add">+ * absolute mode on v4 hardware</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void elantech_set_rate_restore_reg_07(struct psmouse *psmouse,</span>
<span class="p_add">+		unsigned int rate)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct elantech_data *etd = psmouse-&gt;private;</span>
<span class="p_add">+</span>
<span class="p_add">+	etd-&gt;original_set_rate(psmouse, rate);</span>
<span class="p_add">+	if (elantech_write_reg(psmouse, 0x07, etd-&gt;reg_07))</span>
<span class="p_add">+		psmouse_err(psmouse, &quot;restoring reg_07 failed\n&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Put the touchpad into absolute mode
  */
 static int elantech_set_absolute_mode(struct psmouse *psmouse)
<span class="p_chunk">@@ -1131,10 +1146,11 @@</span> <span class="p_context"> static bool elantech_is_signature_valid(const unsigned char *param)</span>
 		return true;
 
 	/*
<span class="p_del">-	 * Some models have a revision higher then 20. Meaning param[2] may</span>
<span class="p_del">-	 * be 10 or 20, skip the rates check for these.</span>
<span class="p_add">+	 * Some hw_version &gt;= 4 models have a revision higher then 20. Meaning</span>
<span class="p_add">+	 * that param[2] may be 10 or 20, skip the rates check for these.</span>
 	 */
<span class="p_del">-	if (param[0] == 0x46 &amp;&amp; (param[1] &amp; 0xef) == 0x0f &amp;&amp; param[2] &lt; 40)</span>
<span class="p_add">+	if ((param[0] &amp; 0x0f) &gt;= 0x06 &amp;&amp; (param[1] &amp; 0xaf) == 0x0f &amp;&amp;</span>
<span class="p_add">+	    param[2] &lt; 40)</span>
 		return true;
 
 	for (i = 0; i &lt; ARRAY_SIZE(rates); i++)
<span class="p_chunk">@@ -1269,6 +1285,12 @@</span> <span class="p_context"> static int elantech_set_properties(struct elantech_data *etd)</span>
 			etd-&gt;hw_version = 3;
 			break;
 		case 6:
<span class="p_add">+		case 7:</span>
<span class="p_add">+		case 8:</span>
<span class="p_add">+		case 9:</span>
<span class="p_add">+		case 10:</span>
<span class="p_add">+		case 13:</span>
<span class="p_add">+		case 14:</span>
 			etd-&gt;hw_version = 4;
 			break;
 		default:
<span class="p_chunk">@@ -1353,6 +1375,11 @@</span> <span class="p_context"> int elantech_init(struct psmouse *psmouse)</span>
 		goto init_fail;
 	}
 
<span class="p_add">+	if (etd-&gt;fw_version == 0x381f17) {</span>
<span class="p_add">+		etd-&gt;original_set_rate = psmouse-&gt;set_rate;</span>
<span class="p_add">+		psmouse-&gt;set_rate = elantech_set_rate_restore_reg_07;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (elantech_set_input_params(psmouse)) {
 		psmouse_err(psmouse, &quot;failed to query touchpad range.\n&quot;);
 		goto init_fail;
<span class="p_header">diff --git a/drivers/input/mouse/elantech.h b/drivers/input/mouse/elantech.h</span>
<span class="p_header">index 3569bed..092ac72 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.h</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.h</span>
<span class="p_chunk">@@ -136,6 +136,7 @@</span> <span class="p_context"> struct elantech_data {</span>
 	unsigned int width;
 	struct finger_pos mt[ETP_MAX_FINGERS];
 	unsigned char parity[256];
<span class="p_add">+	void (*original_set_rate)(struct psmouse *psmouse, unsigned int rate);</span>
 };
 
 #ifdef CONFIG_MOUSE_PS2_ELANTECH
<span class="p_header">diff --git a/drivers/lguest/core.c b/drivers/lguest/core.c</span>
<span class="p_header">index b5fdcb7..34842e5 100644</span>
<span class="p_header">--- a/drivers/lguest/core.c</span>
<span class="p_header">+++ b/drivers/lguest/core.c</span>
<span class="p_chunk">@@ -171,7 +171,7 @@</span> <span class="p_context"> static void unmap_switcher(void)</span>
 bool lguest_address_ok(const struct lguest *lg,
 		       unsigned long addr, unsigned long len)
 {
<span class="p_del">-	return (addr+len) / PAGE_SIZE &lt; lg-&gt;pfn_limit &amp;&amp; (addr+len &gt;= addr);</span>
<span class="p_add">+	return addr+len &lt;= lg-&gt;pfn_limit * PAGE_SIZE &amp;&amp; (addr+len &gt;= addr);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c</span>
<span class="p_header">index c293d9c..6056ee7 100644</span>
<span class="p_header">--- a/drivers/md/raid5.c</span>
<span class="p_header">+++ b/drivers/md/raid5.c</span>
<span class="p_chunk">@@ -1554,7 +1554,8 @@</span> <span class="p_context"> static int resize_stripes(struct r5conf *conf, int newsize)</span>
 
 	conf-&gt;slab_cache = sc;
 	conf-&gt;active_name = 1-conf-&gt;active_name;
<span class="p_del">-	conf-&gt;pool_size = newsize;</span>
<span class="p_add">+	if (!err)</span>
<span class="p_add">+		conf-&gt;pool_size = newsize;</span>
 	return err;
 }
 
<span class="p_header">diff --git a/drivers/memstick/core/mspro_block.c b/drivers/memstick/core/mspro_block.c</span>
<span class="p_header">index 9729b92..f8449d5 100644</span>
<span class="p_header">--- a/drivers/memstick/core/mspro_block.c</span>
<span class="p_header">+++ b/drivers/memstick/core/mspro_block.c</span>
<span class="p_chunk">@@ -760,7 +760,7 @@</span> <span class="p_context"> static int mspro_block_complete_req(struct memstick_dev *card, int error)</span>
 
 		if (error || (card-&gt;current_mrq.tpc == MSPRO_CMD_STOP)) {
 			if (msb-&gt;data_dir == READ) {
<span class="p_del">-				for (cnt = 0; cnt &lt; msb-&gt;current_seg; cnt++)</span>
<span class="p_add">+				for (cnt = 0; cnt &lt; msb-&gt;current_seg; cnt++) {</span>
 					t_len += msb-&gt;req_sg[cnt].length
 						 / msb-&gt;page_size;
 
<span class="p_chunk">@@ -768,6 +768,7 @@</span> <span class="p_context"> static int mspro_block_complete_req(struct memstick_dev *card, int error)</span>
 						t_len += msb-&gt;current_page - 1;
 
 					t_len *= msb-&gt;page_size;
<span class="p_add">+				}</span>
 			}
 		} else
 			t_len = blk_rq_bytes(msb-&gt;block_req);
<span class="p_header">diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c</span>
<span class="p_header">index 411a994..fc7386e 100644</span>
<span class="p_header">--- a/drivers/mmc/core/core.c</span>
<span class="p_header">+++ b/drivers/mmc/core/core.c</span>
<span class="p_chunk">@@ -2424,6 +2424,7 @@</span> <span class="p_context"> int mmc_pm_notify(struct notifier_block *notify_block,</span>
 	switch (mode) {
 	case PM_HIBERNATION_PREPARE:
 	case PM_SUSPEND_PREPARE:
<span class="p_add">+	case PM_RESTORE_PREPARE:</span>
 
 		spin_lock_irqsave(&amp;host-&gt;lock, flags);
 		host-&gt;rescan_disable = 1;
<span class="p_header">diff --git a/drivers/mtd/ubi/cdev.c b/drivers/mtd/ubi/cdev.c</span>
<span class="p_header">index ad76592..7ac2c05 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/cdev.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/cdev.c</span>
<span class="p_chunk">@@ -475,7 +475,7 @@</span> <span class="p_context"> static long vol_cdev_ioctl(struct file *file, unsigned int cmd,</span>
 		/* Validate the request */
 		err = -EINVAL;
 		if (req.lnum &lt; 0 || req.lnum &gt;= vol-&gt;reserved_pebs ||
<span class="p_del">-		    req.bytes &lt; 0 || req.lnum &gt;= vol-&gt;usable_leb_size)</span>
<span class="p_add">+		    req.bytes &lt; 0 || req.bytes &gt; vol-&gt;usable_leb_size)</span>
 			break;
 		if (req.dtype != UBI_LONGTERM &amp;&amp; req.dtype != UBI_SHORTTERM &amp;&amp;
 		    req.dtype != UBI_UNKNOWN)
<span class="p_header">diff --git a/drivers/mtd/ubi/eba.c b/drivers/mtd/ubi/eba.c</span>
<span class="p_header">index cd26da8..22b3636 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/eba.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/eba.c</span>
<span class="p_chunk">@@ -1261,7 +1261,8 @@</span> <span class="p_context"> int ubi_eba_init_scan(struct ubi_device *ubi, struct ubi_scan_info *si)</span>
 				 * during re-size.
 				 */
 				ubi_scan_move_to_list(sv, seb, &amp;si-&gt;erase);
<span class="p_del">-			vol-&gt;eba_tbl[seb-&gt;lnum] = seb-&gt;pnum;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				vol-&gt;eba_tbl[seb-&gt;lnum] = seb-&gt;pnum;</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/mtd/ubi/misc.c b/drivers/mtd/ubi/misc.c</span>
<span class="p_header">index f6a7d7a..b14ab43 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/misc.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/misc.c</span>
<span class="p_chunk">@@ -74,6 +74,8 @@</span> <span class="p_context"> int ubi_check_volume(struct ubi_device *ubi, int vol_id)</span>
 	for (i = 0; i &lt; vol-&gt;used_ebs; i++) {
 		int size;
 
<span class="p_add">+		cond_resched();</span>
<span class="p_add">+</span>
 		if (i == vol-&gt;used_ebs - 1)
 			size = vol-&gt;last_eb_bytes;
 		else
<span class="p_header">diff --git a/drivers/mtd/ubi/scan.c b/drivers/mtd/ubi/scan.c</span>
<span class="p_header">index b2b62de..c5b2357 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/scan.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/scan.c</span>
<span class="p_chunk">@@ -408,7 +408,7 @@</span> <span class="p_context"> static int compare_lebs(struct ubi_device *ubi, const struct ubi_scan_leb *seb,</span>
 		second_is_newer = !second_is_newer;
 	} else {
 		dbg_bld(&quot;PEB %d CRC is OK&quot;, pnum);
<span class="p_del">-		bitflips = !!err;</span>
<span class="p_add">+		bitflips |= !!err;</span>
 	}
 
 	vfree(buf);
<span class="p_header">diff --git a/drivers/mtd/ubi/wl.c b/drivers/mtd/ubi/wl.c</span>
<span class="p_header">index cf42971..422e5be 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/wl.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/wl.c</span>
<span class="p_chunk">@@ -665,7 +665,7 @@</span> <span class="p_context"> static int wear_leveling_worker(struct ubi_device *ubi, struct ubi_work *wrk,</span>
 				int cancel)
 {
 	int err, scrubbing = 0, torture = 0, protect = 0, erroneous = 0;
<span class="p_del">-	int vol_id = -1, uninitialized_var(lnum);</span>
<span class="p_add">+	int vol_id = -1, lnum = -1;</span>
 	struct ubi_wl_entry *e1, *e2;
 	struct ubi_vid_hdr *vid_hdr;
 
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000/e1000_main.c b/drivers/net/ethernet/intel/e1000/e1000_main.c</span>
<span class="p_header">index 6546191..bd4e598 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000/e1000_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000/e1000_main.c</span>
<span class="p_chunk">@@ -149,6 +149,11 @@</span> <span class="p_context"> static bool e1000_clean_rx_irq(struct e1000_adapter *adapter,</span>
 static bool e1000_clean_jumbo_rx_irq(struct e1000_adapter *adapter,
 				     struct e1000_rx_ring *rx_ring,
 				     int *work_done, int work_to_do);
<span class="p_add">+static void e1000_alloc_dummy_rx_buffers(struct e1000_adapter *adapter,</span>
<span class="p_add">+					 struct e1000_rx_ring *rx_ring,</span>
<span class="p_add">+					 int cleaned_count)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
 static void e1000_alloc_rx_buffers(struct e1000_adapter *adapter,
 				   struct e1000_rx_ring *rx_ring,
 				   int cleaned_count);
<span class="p_chunk">@@ -3322,8 +3327,11 @@</span> <span class="p_context"> static int e1000_change_mtu(struct net_device *netdev, int new_mtu)</span>
 		msleep(1);
 	/* e1000_down has a dependency on max_frame_size */
 	hw-&gt;max_frame_size = max_frame;
<span class="p_del">-	if (netif_running(netdev))</span>
<span class="p_add">+	if (netif_running(netdev)) {</span>
<span class="p_add">+		/* prevent buffers from being reallocated */</span>
<span class="p_add">+		adapter-&gt;alloc_rx_buf = e1000_alloc_dummy_rx_buffers;</span>
 		e1000_down(adapter);
<span class="p_add">+	}</span>
 
 	/* NOTE: netdev_alloc_skb reserves 16 bytes, and typically NET_IP_ALIGN
 	 * means we reserve 2 more, this pushes us to allocate from the next
<span class="p_header">diff --git a/drivers/net/phy/dp83640.c b/drivers/net/phy/dp83640.c</span>
<span class="p_header">index 9663e0b..bb335ab 100644</span>
<span class="p_header">--- a/drivers/net/phy/dp83640.c</span>
<span class="p_header">+++ b/drivers/net/phy/dp83640.c</span>
<span class="p_chunk">@@ -42,7 +42,7 @@</span> <span class="p_context"></span>
 #define PSF_TX		0x1000
 #define EXT_EVENT	1
 #define CAL_EVENT	7
<span class="p_del">-#define CAL_TRIGGER	7</span>
<span class="p_add">+#define CAL_TRIGGER	1</span>
 #define PER_TRIGGER	6
 
 /* phyter seems to miss the mark by 16 ns */
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_header">index 1644b1f..ec347d2 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_chunk">@@ -367,6 +367,7 @@</span> <span class="p_context"> static struct usb_device_id rtl8192c_usb_ids[] = {</span>
 	{RTL_USB_DEVICE(0x2001, 0x3307, rtl92cu_hal_cfg)}, /*D-Link-Cameo*/
 	{RTL_USB_DEVICE(0x2001, 0x3309, rtl92cu_hal_cfg)}, /*D-Link-Alpha*/
 	{RTL_USB_DEVICE(0x2001, 0x330a, rtl92cu_hal_cfg)}, /*D-Link-Alpha*/
<span class="p_add">+	{RTL_USB_DEVICE(0x2001, 0x330d, rtl92cu_hal_cfg)}, /*D-Link DWA-131 */</span>
 	{RTL_USB_DEVICE(0x2019, 0xab2b, rtl92cu_hal_cfg)}, /*Planex -Abocom*/
 	{RTL_USB_DEVICE(0x20f4, 0x624d, rtl92cu_hal_cfg)}, /*TRENDNet*/
 	{RTL_USB_DEVICE(0x2357, 0x0100, rtl92cu_hal_cfg)}, /*TP-Link WN8200ND*/
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/usb.c b/drivers/net/wireless/rtlwifi/usb.c</span>
<span class="p_header">index e5fe956..17e6429 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/usb.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/usb.c</span>
<span class="p_chunk">@@ -117,7 +117,7 @@</span> <span class="p_context"> static int _usbctrl_vendorreq_sync_read(struct usb_device *udev, u8 request,</span>
 	reqtype =  REALTEK_USB_VENQT_READ;
 
 	status = usb_control_msg(udev, pipe, request, reqtype, value, index,
<span class="p_del">-				 pdata, len, 0); /* max. timeout */</span>
<span class="p_add">+				 pdata, len, 1000);</span>
 
 	if (status &lt; 0)
 		pr_err(&quot;reg 0x%x, usbctrl_vendorreq TimeOut! status:0x%x value=0x%x\n&quot;,
<span class="p_header">diff --git a/drivers/net/xen-netback/xenbus.c b/drivers/net/xen-netback/xenbus.c</span>
<span class="p_header">index 1ce729d..b7d782f 100644</span>
<span class="p_header">--- a/drivers/net/xen-netback/xenbus.c</span>
<span class="p_header">+++ b/drivers/net/xen-netback/xenbus.c</span>
<span class="p_chunk">@@ -27,6 +27,8 @@</span> <span class="p_context"> struct backend_info {</span>
 	enum xenbus_state frontend_state;
 	struct xenbus_watch hotplug_status_watch;
 	u8 have_hotplug_status_watch:1;
<span class="p_add">+</span>
<span class="p_add">+	const char *hotplug_script;</span>
 };
 
 static int connect_rings(struct backend_info *);
<span class="p_chunk">@@ -45,6 +47,7 @@</span> <span class="p_context"> static int netback_remove(struct xenbus_device *dev)</span>
 		xenvif_disconnect(be-&gt;vif);
 		be-&gt;vif = NULL;
 	}
<span class="p_add">+	kfree(be-&gt;hotplug_script);</span>
 	kfree(be);
 	dev_set_drvdata(&amp;dev-&gt;dev, NULL);
 	return 0;
<span class="p_chunk">@@ -62,6 +65,7 @@</span> <span class="p_context"> static int netback_probe(struct xenbus_device *dev,</span>
 	struct xenbus_transaction xbt;
 	int err;
 	int sg;
<span class="p_add">+	const char *script;</span>
 	struct backend_info *be = kzalloc(sizeof(struct backend_info),
 					  GFP_KERNEL);
 	if (!be) {
<span class="p_chunk">@@ -122,6 +126,15 @@</span> <span class="p_context"> static int netback_probe(struct xenbus_device *dev,</span>
 		goto fail;
 	}
 
<span class="p_add">+	script = xenbus_read(XBT_NIL, dev-&gt;nodename, &quot;script&quot;, NULL);</span>
<span class="p_add">+	if (IS_ERR(script)) {</span>
<span class="p_add">+		err = PTR_ERR(script);</span>
<span class="p_add">+		xenbus_dev_fatal(dev, err, &quot;reading script&quot;);</span>
<span class="p_add">+		goto fail;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	be-&gt;hotplug_script = script;</span>
<span class="p_add">+</span>
 	err = xenbus_switch_state(dev, XenbusStateInitWait);
 	if (err)
 		goto fail;
<span class="p_chunk">@@ -150,22 +163,14 @@</span> <span class="p_context"> static int netback_uevent(struct xenbus_device *xdev,</span>
 			  struct kobj_uevent_env *env)
 {
 	struct backend_info *be = dev_get_drvdata(&amp;xdev-&gt;dev);
<span class="p_del">-	char *val;</span>
 
<span class="p_del">-	val = xenbus_read(XBT_NIL, xdev-&gt;nodename, &quot;script&quot;, NULL);</span>
<span class="p_del">-	if (IS_ERR(val)) {</span>
<span class="p_del">-		int err = PTR_ERR(val);</span>
<span class="p_del">-		xenbus_dev_fatal(xdev, err, &quot;reading script&quot;);</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		if (add_uevent_var(env, &quot;script=%s&quot;, val)) {</span>
<span class="p_del">-			kfree(val);</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		kfree(val);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (!be)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (add_uevent_var(env, &quot;script=%s&quot;, be-&gt;hotplug_script))</span>
<span class="p_add">+		return -ENOMEM;</span>
 
<span class="p_del">-	if (!be || !be-&gt;vif)</span>
<span class="p_add">+	if (!be-&gt;vif)</span>
 		return 0;
 
 	return add_uevent_var(env, &quot;vif=%s&quot;, be-&gt;vif-&gt;dev-&gt;name);
<span class="p_header">diff --git a/drivers/of/base.c b/drivers/of/base.c</span>
<span class="p_header">index 37639a6..21935580 100644</span>
<span class="p_header">--- a/drivers/of/base.c</span>
<span class="p_header">+++ b/drivers/of/base.c</span>
<span class="p_chunk">@@ -761,6 +761,42 @@</span> <span class="p_context"> int of_property_read_string_index(struct device_node *np, const char *propname,</span>
 }
 EXPORT_SYMBOL_GPL(of_property_read_string_index);
 
<span class="p_add">+/**</span>
<span class="p_add">+ * of_property_match_string() - Find string in a list and return index</span>
<span class="p_add">+ * @np: pointer to node containing string list property</span>
<span class="p_add">+ * @propname: string list property name</span>
<span class="p_add">+ * @string: pointer to string to search for in string list</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This function searches a string list property and returns the index</span>
<span class="p_add">+ * of a specific string value.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int of_property_match_string(struct device_node *np, const char *propname,</span>
<span class="p_add">+			     const char *string)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct property *prop = of_find_property(np, propname, NULL);</span>
<span class="p_add">+	size_t l;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	const char *p, *end;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!prop)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	if (!prop-&gt;value)</span>
<span class="p_add">+		return -ENODATA;</span>
<span class="p_add">+</span>
<span class="p_add">+	p = prop-&gt;value;</span>
<span class="p_add">+	end = p + prop-&gt;length;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; p &lt; end; i++, p += l) {</span>
<span class="p_add">+		l = strlen(p) + 1;</span>
<span class="p_add">+		if (p + l &gt; end)</span>
<span class="p_add">+			return -EILSEQ;</span>
<span class="p_add">+		pr_debug(&quot;comparing %s with %s\n&quot;, string, p);</span>
<span class="p_add">+		if (strcmp(string, p) == 0)</span>
<span class="p_add">+			return i; /* Found it; return index */</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return -ENODATA;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(of_property_match_string);</span>
 
 /**
  * of_property_count_strings - Find and return the number of strings from a
<span class="p_header">diff --git a/drivers/platform/x86/compal-laptop.c b/drivers/platform/x86/compal-laptop.c</span>
<span class="p_header">index 8877b83..ba3638e 100644</span>
<span class="p_header">--- a/drivers/platform/x86/compal-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/compal-laptop.c</span>
<span class="p_chunk">@@ -1046,7 +1046,14 @@</span> <span class="p_context"> static int __devinit compal_probe(struct platform_device *pdev)</span>
 
 	/* Power supply */
 	initialize_power_supply_data(data);
<span class="p_del">-	power_supply_register(&amp;compal_device-&gt;dev, &amp;data-&gt;psy);</span>
<span class="p_add">+	err = power_supply_register(&amp;compal_device-&gt;dev, &amp;data-&gt;psy);</span>
<span class="p_add">+	if (err &lt; 0) {</span>
<span class="p_add">+		hwmon_device_unregister(data-&gt;hwmon_dev);</span>
<span class="p_add">+		sysfs_remove_group(&amp;pdev-&gt;dev.kobj,</span>
<span class="p_add">+				&amp;compal_attribute_group);</span>
<span class="p_add">+		kfree(data);</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+	}</span>
 
 	platform_set_drvdata(pdev, data);
 
<span class="p_header">diff --git a/drivers/scsi/3w-9xxx.c b/drivers/scsi/3w-9xxx.c</span>
<span class="p_header">index 3868ab2..fb37df6 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-9xxx.c</span>
<span class="p_header">+++ b/drivers/scsi/3w-9xxx.c</span>
<span class="p_chunk">@@ -149,7 +149,6 @@</span> <span class="p_context"> static int twa_reset_sequence(TW_Device_Extension *tw_dev, int soft_reset);</span>
 static int twa_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id, char *cdb, int use_sg, TW_SG_Entry *sglistarg);
 static void twa_scsiop_execute_scsi_complete(TW_Device_Extension *tw_dev, int request_id);
 static char *twa_string_lookup(twa_message_type *table, unsigned int aen_code);
<span class="p_del">-static void twa_unmap_scsi_data(TW_Device_Extension *tw_dev, int request_id);</span>
 
 /* Functions */
 
<span class="p_chunk">@@ -1352,11 +1351,11 @@</span> <span class="p_context"> static irqreturn_t twa_interrupt(int irq, void *dev_instance)</span>
 				}
 
 				/* Now complete the io */
<span class="p_add">+				scsi_dma_unmap(cmd);</span>
<span class="p_add">+				cmd-&gt;scsi_done(cmd);</span>
 				tw_dev-&gt;state[request_id] = TW_S_COMPLETED;
 				twa_free_request_id(tw_dev, request_id);
 				tw_dev-&gt;posted_request_count--;
<span class="p_del">-				tw_dev-&gt;srb[request_id]-&gt;scsi_done(tw_dev-&gt;srb[request_id]);</span>
<span class="p_del">-				twa_unmap_scsi_data(tw_dev, request_id);</span>
 			}
 
 			/* Check for valid status after each drain */
<span class="p_chunk">@@ -1414,26 +1413,6 @@</span> <span class="p_context"> static void twa_load_sgl(TW_Device_Extension *tw_dev, TW_Command_Full *full_comm</span>
 	}
 } /* End twa_load_sgl() */
 
<span class="p_del">-/* This function will perform a pci-dma mapping for a scatter gather list */</span>
<span class="p_del">-static int twa_map_scsi_sg_data(TW_Device_Extension *tw_dev, int request_id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int use_sg;</span>
<span class="p_del">-	struct scsi_cmnd *cmd = tw_dev-&gt;srb[request_id];</span>
<span class="p_del">-</span>
<span class="p_del">-	use_sg = scsi_dma_map(cmd);</span>
<span class="p_del">-	if (!use_sg)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	else if (use_sg &lt; 0) {</span>
<span class="p_del">-		TW_PRINTK(tw_dev-&gt;host, TW_DRIVER, 0x1c, &quot;Failed to map scatter gather list&quot;);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	cmd-&gt;SCp.phase = TW_PHASE_SGLIST;</span>
<span class="p_del">-	cmd-&gt;SCp.have_data_in = use_sg;</span>
<span class="p_del">-</span>
<span class="p_del">-	return use_sg;</span>
<span class="p_del">-} /* End twa_map_scsi_sg_data() */</span>
<span class="p_del">-</span>
 /* This function will poll for a response interrupt of a request */
 static int twa_poll_response(TW_Device_Extension *tw_dev, int request_id, int seconds)
 {
<span class="p_chunk">@@ -1612,9 +1591,11 @@</span> <span class="p_context"> static int twa_reset_device_extension(TW_Device_Extension *tw_dev)</span>
 		    (tw_dev-&gt;state[i] != TW_S_INITIAL) &amp;&amp;
 		    (tw_dev-&gt;state[i] != TW_S_COMPLETED)) {
 			if (tw_dev-&gt;srb[i]) {
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;result = (DID_RESET &lt;&lt; 16);</span>
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;scsi_done(tw_dev-&gt;srb[i]);</span>
<span class="p_del">-				twa_unmap_scsi_data(tw_dev, i);</span>
<span class="p_add">+				struct scsi_cmnd *cmd = tw_dev-&gt;srb[i];</span>
<span class="p_add">+</span>
<span class="p_add">+				cmd-&gt;result = (DID_RESET &lt;&lt; 16);</span>
<span class="p_add">+				scsi_dma_unmap(cmd);</span>
<span class="p_add">+				cmd-&gt;scsi_done(cmd);</span>
 			}
 		}
 	}
<span class="p_chunk">@@ -1793,21 +1774,18 @@</span> <span class="p_context"> static int twa_scsi_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_</span>
 	/* Save the scsi command for use by the ISR */
 	tw_dev-&gt;srb[request_id] = SCpnt;
 
<span class="p_del">-	/* Initialize phase to zero */</span>
<span class="p_del">-	SCpnt-&gt;SCp.phase = TW_PHASE_INITIAL;</span>
<span class="p_del">-</span>
 	retval = twa_scsiop_execute_scsi(tw_dev, request_id, NULL, 0, NULL);
 	switch (retval) {
 	case SCSI_MLQUEUE_HOST_BUSY:
<span class="p_add">+		scsi_dma_unmap(SCpnt);</span>
 		twa_free_request_id(tw_dev, request_id);
<span class="p_del">-		twa_unmap_scsi_data(tw_dev, request_id);</span>
 		break;
 	case 1:
<span class="p_del">-		tw_dev-&gt;state[request_id] = TW_S_COMPLETED;</span>
<span class="p_del">-		twa_free_request_id(tw_dev, request_id);</span>
<span class="p_del">-		twa_unmap_scsi_data(tw_dev, request_id);</span>
 		SCpnt-&gt;result = (DID_ERROR &lt;&lt; 16);
<span class="p_add">+		scsi_dma_unmap(SCpnt);</span>
 		done(SCpnt);
<span class="p_add">+		tw_dev-&gt;state[request_id] = TW_S_COMPLETED;</span>
<span class="p_add">+		twa_free_request_id(tw_dev, request_id);</span>
 		retval = 0;
 	}
 out:
<span class="p_chunk">@@ -1875,8 +1853,8 @@</span> <span class="p_context"> static int twa_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id,</span>
 				command_packet-&gt;sg_list[0].address = TW_CPU_TO_SGL(tw_dev-&gt;generic_buffer_phys[request_id]);
 				command_packet-&gt;sg_list[0].length = cpu_to_le32(TW_MIN_SGL_LENGTH);
 			} else {
<span class="p_del">-				sg_count = twa_map_scsi_sg_data(tw_dev, request_id);</span>
<span class="p_del">-				if (sg_count == 0)</span>
<span class="p_add">+				sg_count = scsi_dma_map(srb);</span>
<span class="p_add">+				if (sg_count &lt; 0)</span>
 					goto out;
 
 				scsi_for_each_sg(srb, sg, sg_count, i) {
<span class="p_chunk">@@ -1991,15 +1969,6 @@</span> <span class="p_context"> static char *twa_string_lookup(twa_message_type *table, unsigned int code)</span>
 	return(table[index].text);
 } /* End twa_string_lookup() */
 
<span class="p_del">-/* This function will perform a pci-dma unmap */</span>
<span class="p_del">-static void twa_unmap_scsi_data(TW_Device_Extension *tw_dev, int request_id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct scsi_cmnd *cmd = tw_dev-&gt;srb[request_id];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cmd-&gt;SCp.phase == TW_PHASE_SGLIST)</span>
<span class="p_del">-		scsi_dma_unmap(cmd);</span>
<span class="p_del">-} /* End twa_unmap_scsi_data() */</span>
<span class="p_del">-</span>
 /* This function gets called when a disk is coming on-line */
 static int twa_slave_configure(struct scsi_device *sdev)
 {
<span class="p_header">diff --git a/drivers/scsi/3w-9xxx.h b/drivers/scsi/3w-9xxx.h</span>
<span class="p_header">index 040f721..0fdc83c 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-9xxx.h</span>
<span class="p_header">+++ b/drivers/scsi/3w-9xxx.h</span>
<span class="p_chunk">@@ -324,11 +324,6 @@</span> <span class="p_context"> static twa_message_type twa_error_table[] = {</span>
 #define TW_CURRENT_DRIVER_BUILD 0
 #define TW_CURRENT_DRIVER_BRANCH 0
 
<span class="p_del">-/* Phase defines */</span>
<span class="p_del">-#define TW_PHASE_INITIAL 0</span>
<span class="p_del">-#define TW_PHASE_SINGLE  1</span>
<span class="p_del">-#define TW_PHASE_SGLIST  2</span>
<span class="p_del">-</span>
 /* Misc defines */
 #define TW_9550SX_DRAIN_COMPLETED	      0xFFFF
 #define TW_SECTOR_SIZE                        512
<span class="p_header">diff --git a/drivers/scsi/3w-sas.c b/drivers/scsi/3w-sas.c</span>
<span class="p_header">index 13e39e1..c555ccb 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-sas.c</span>
<span class="p_header">+++ b/drivers/scsi/3w-sas.c</span>
<span class="p_chunk">@@ -303,26 +303,6 @@</span> <span class="p_context"> static int twl_post_command_packet(TW_Device_Extension *tw_dev, int request_id)</span>
 	return 0;
 } /* End twl_post_command_packet() */
 
<span class="p_del">-/* This function will perform a pci-dma mapping for a scatter gather list */</span>
<span class="p_del">-static int twl_map_scsi_sg_data(TW_Device_Extension *tw_dev, int request_id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int use_sg;</span>
<span class="p_del">-	struct scsi_cmnd *cmd = tw_dev-&gt;srb[request_id];</span>
<span class="p_del">-</span>
<span class="p_del">-	use_sg = scsi_dma_map(cmd);</span>
<span class="p_del">-	if (!use_sg)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	else if (use_sg &lt; 0) {</span>
<span class="p_del">-		TW_PRINTK(tw_dev-&gt;host, TW_DRIVER, 0x1, &quot;Failed to map scatter gather list&quot;);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	cmd-&gt;SCp.phase = TW_PHASE_SGLIST;</span>
<span class="p_del">-	cmd-&gt;SCp.have_data_in = use_sg;</span>
<span class="p_del">-</span>
<span class="p_del">-	return use_sg;</span>
<span class="p_del">-} /* End twl_map_scsi_sg_data() */</span>
<span class="p_del">-</span>
 /* This function hands scsi cdb&#39;s to the firmware */
 static int twl_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id, char *cdb, int use_sg, TW_SG_Entry_ISO *sglistarg)
 {
<span class="p_chunk">@@ -370,8 +350,8 @@</span> <span class="p_context"> static int twl_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id,</span>
 	if (!sglistarg) {
 		/* Map sglist from scsi layer to cmd packet */
 		if (scsi_sg_count(srb)) {
<span class="p_del">-			sg_count = twl_map_scsi_sg_data(tw_dev, request_id);</span>
<span class="p_del">-			if (sg_count == 0)</span>
<span class="p_add">+			sg_count = scsi_dma_map(srb);</span>
<span class="p_add">+			if (sg_count &lt;= 0)</span>
 				goto out;
 
 			scsi_for_each_sg(srb, sg, sg_count, i) {
<span class="p_chunk">@@ -1116,15 +1096,6 @@</span> <span class="p_context"> out:</span>
 	return retval;
 } /* End twl_initialize_device_extension() */
 
<span class="p_del">-/* This function will perform a pci-dma unmap */</span>
<span class="p_del">-static void twl_unmap_scsi_data(TW_Device_Extension *tw_dev, int request_id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct scsi_cmnd *cmd = tw_dev-&gt;srb[request_id];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cmd-&gt;SCp.phase == TW_PHASE_SGLIST)</span>
<span class="p_del">-		scsi_dma_unmap(cmd);</span>
<span class="p_del">-} /* End twl_unmap_scsi_data() */</span>
<span class="p_del">-</span>
 /* This function will handle attention interrupts */
 static int twl_handle_attention_interrupt(TW_Device_Extension *tw_dev)
 {
<span class="p_chunk">@@ -1265,11 +1236,11 @@</span> <span class="p_context"> static irqreturn_t twl_interrupt(int irq, void *dev_instance)</span>
 			}
 
 			/* Now complete the io */
<span class="p_add">+			scsi_dma_unmap(cmd);</span>
<span class="p_add">+			cmd-&gt;scsi_done(cmd);</span>
 			tw_dev-&gt;state[request_id] = TW_S_COMPLETED;
 			twl_free_request_id(tw_dev, request_id);
 			tw_dev-&gt;posted_request_count--;
<span class="p_del">-			tw_dev-&gt;srb[request_id]-&gt;scsi_done(tw_dev-&gt;srb[request_id]);</span>
<span class="p_del">-			twl_unmap_scsi_data(tw_dev, request_id);</span>
 		}
 
 		/* Check for another response interrupt */
<span class="p_chunk">@@ -1414,10 +1385,12 @@</span> <span class="p_context"> static int twl_reset_device_extension(TW_Device_Extension *tw_dev, int ioctl_res</span>
 		if ((tw_dev-&gt;state[i] != TW_S_FINISHED) &amp;&amp;
 		    (tw_dev-&gt;state[i] != TW_S_INITIAL) &amp;&amp;
 		    (tw_dev-&gt;state[i] != TW_S_COMPLETED)) {
<span class="p_del">-			if (tw_dev-&gt;srb[i]) {</span>
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;result = (DID_RESET &lt;&lt; 16);</span>
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;scsi_done(tw_dev-&gt;srb[i]);</span>
<span class="p_del">-				twl_unmap_scsi_data(tw_dev, i);</span>
<span class="p_add">+			struct scsi_cmnd *cmd = tw_dev-&gt;srb[i];</span>
<span class="p_add">+</span>
<span class="p_add">+			if (cmd) {</span>
<span class="p_add">+				cmd-&gt;result = (DID_RESET &lt;&lt; 16);</span>
<span class="p_add">+				scsi_dma_unmap(cmd);</span>
<span class="p_add">+				cmd-&gt;scsi_done(cmd);</span>
 			}
 		}
 	}
<span class="p_chunk">@@ -1521,9 +1494,6 @@</span> <span class="p_context"> static int twl_scsi_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_</span>
 	/* Save the scsi command for use by the ISR */
 	tw_dev-&gt;srb[request_id] = SCpnt;
 
<span class="p_del">-	/* Initialize phase to zero */</span>
<span class="p_del">-	SCpnt-&gt;SCp.phase = TW_PHASE_INITIAL;</span>
<span class="p_del">-</span>
 	retval = twl_scsiop_execute_scsi(tw_dev, request_id, NULL, 0, NULL);
 	if (retval) {
 		tw_dev-&gt;state[request_id] = TW_S_COMPLETED;
<span class="p_header">diff --git a/drivers/scsi/3w-sas.h b/drivers/scsi/3w-sas.h</span>
<span class="p_header">index d474892..fec6449 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-sas.h</span>
<span class="p_header">+++ b/drivers/scsi/3w-sas.h</span>
<span class="p_chunk">@@ -103,10 +103,6 @@</span> <span class="p_context"> static char *twl_aen_severity_table[] =</span>
 #define TW_CURRENT_DRIVER_BUILD 0
 #define TW_CURRENT_DRIVER_BRANCH 0
 
<span class="p_del">-/* Phase defines */</span>
<span class="p_del">-#define TW_PHASE_INITIAL 0</span>
<span class="p_del">-#define TW_PHASE_SGLIST  2</span>
<span class="p_del">-</span>
 /* Misc defines */
 #define TW_SECTOR_SIZE                        512
 #define TW_MAX_UNITS			      32
<span class="p_header">diff --git a/drivers/scsi/3w-xxxx.c b/drivers/scsi/3w-xxxx.c</span>
<span class="p_header">index 7fe96ff..86bc5f9 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-xxxx.c</span>
<span class="p_header">+++ b/drivers/scsi/3w-xxxx.c</span>
<span class="p_chunk">@@ -1283,32 +1283,6 @@</span> <span class="p_context"> static int tw_initialize_device_extension(TW_Device_Extension *tw_dev)</span>
 	return 0;
 } /* End tw_initialize_device_extension() */
 
<span class="p_del">-static int tw_map_scsi_sg_data(struct pci_dev *pdev, struct scsi_cmnd *cmd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int use_sg;</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintk(KERN_WARNING &quot;3w-xxxx: tw_map_scsi_sg_data()\n&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	use_sg = scsi_dma_map(cmd);</span>
<span class="p_del">-	if (use_sg &lt; 0) {</span>
<span class="p_del">-		printk(KERN_WARNING &quot;3w-xxxx: tw_map_scsi_sg_data(): pci_map_sg() failed.\n&quot;);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	cmd-&gt;SCp.phase = TW_PHASE_SGLIST;</span>
<span class="p_del">-	cmd-&gt;SCp.have_data_in = use_sg;</span>
<span class="p_del">-</span>
<span class="p_del">-	return use_sg;</span>
<span class="p_del">-} /* End tw_map_scsi_sg_data() */</span>
<span class="p_del">-</span>
<span class="p_del">-static void tw_unmap_scsi_data(struct pci_dev *pdev, struct scsi_cmnd *cmd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	dprintk(KERN_WARNING &quot;3w-xxxx: tw_unmap_scsi_data()\n&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cmd-&gt;SCp.phase == TW_PHASE_SGLIST)</span>
<span class="p_del">-		scsi_dma_unmap(cmd);</span>
<span class="p_del">-} /* End tw_unmap_scsi_data() */</span>
<span class="p_del">-</span>
 /* This function will reset a device extension */
 static int tw_reset_device_extension(TW_Device_Extension *tw_dev)
 {
<span class="p_chunk">@@ -1331,8 +1305,8 @@</span> <span class="p_context"> static int tw_reset_device_extension(TW_Device_Extension *tw_dev)</span>
 			srb = tw_dev-&gt;srb[i];
 			if (srb != NULL) {
 				srb-&gt;result = (DID_RESET &lt;&lt; 16);
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;scsi_done(tw_dev-&gt;srb[i]);</span>
<span class="p_del">-				tw_unmap_scsi_data(tw_dev-&gt;tw_pci_dev, tw_dev-&gt;srb[i]);</span>
<span class="p_add">+				scsi_dma_unmap(srb);</span>
<span class="p_add">+				srb-&gt;scsi_done(srb);</span>
 			}
 		}
 	}
<span class="p_chunk">@@ -1779,8 +1753,8 @@</span> <span class="p_context"> static int tw_scsiop_read_write(TW_Device_Extension *tw_dev, int request_id)</span>
 	command_packet-&gt;byte8.io.lba = lba;
 	command_packet-&gt;byte6.block_count = num_sectors;
 
<span class="p_del">-	use_sg = tw_map_scsi_sg_data(tw_dev-&gt;tw_pci_dev, tw_dev-&gt;srb[request_id]);</span>
<span class="p_del">-	if (!use_sg)</span>
<span class="p_add">+	use_sg = scsi_dma_map(srb);</span>
<span class="p_add">+	if (use_sg &lt;= 0)</span>
 		return 1;
 
 	scsi_for_each_sg(tw_dev-&gt;srb[request_id], sg, use_sg, i) {
<span class="p_chunk">@@ -1967,9 +1941,6 @@</span> <span class="p_context"> static int tw_scsi_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_c</span>
 	/* Save the scsi command for use by the ISR */
 	tw_dev-&gt;srb[request_id] = SCpnt;
 
<span class="p_del">-	/* Initialize phase to zero */</span>
<span class="p_del">-	SCpnt-&gt;SCp.phase = TW_PHASE_INITIAL;</span>
<span class="p_del">-</span>
 	switch (*command) {
 		case READ_10:
 		case READ_6:
<span class="p_chunk">@@ -2196,12 +2167,11 @@</span> <span class="p_context"> static irqreturn_t tw_interrupt(int irq, void *dev_instance)</span>
 
 				/* Now complete the io */
 				if ((error != TW_ISR_DONT_COMPLETE)) {
<span class="p_add">+					scsi_dma_unmap(tw_dev-&gt;srb[request_id]);</span>
<span class="p_add">+					tw_dev-&gt;srb[request_id]-&gt;scsi_done(tw_dev-&gt;srb[request_id]);</span>
 					tw_dev-&gt;state[request_id] = TW_S_COMPLETED;
 					tw_state_request_finish(tw_dev, request_id);
 					tw_dev-&gt;posted_request_count--;
<span class="p_del">-					tw_dev-&gt;srb[request_id]-&gt;scsi_done(tw_dev-&gt;srb[request_id]);</span>
<span class="p_del">-					</span>
<span class="p_del">-					tw_unmap_scsi_data(tw_dev-&gt;tw_pci_dev, tw_dev-&gt;srb[request_id]);</span>
 				}
 			}
 				
<span class="p_header">diff --git a/drivers/scsi/3w-xxxx.h b/drivers/scsi/3w-xxxx.h</span>
<span class="p_header">index 49dcf03..1d31858 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-xxxx.h</span>
<span class="p_header">+++ b/drivers/scsi/3w-xxxx.h</span>
<span class="p_chunk">@@ -195,11 +195,6 @@</span> <span class="p_context"> static unsigned char tw_sense_table[][4] =</span>
 #define TW_AEN_SMART_FAIL        0x000F
 #define TW_AEN_SBUF_FAIL         0x0024
 
<span class="p_del">-/* Phase defines */</span>
<span class="p_del">-#define TW_PHASE_INITIAL 0</span>
<span class="p_del">-#define TW_PHASE_SINGLE 1</span>
<span class="p_del">-#define TW_PHASE_SGLIST 2</span>
<span class="p_del">-</span>
 /* Misc defines */
 #define TW_ALIGNMENT_6000		      64 /* 64 bytes */
 #define TW_ALIGNMENT_7000                     4  /* 4 bytes */
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_fusion.c b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">index bfd87fa..3e0f71c 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_chunk">@@ -1426,11 +1426,11 @@</span> <span class="p_context"> megasas_build_ldio_fusion(struct megasas_instance *instance,</span>
 			fp_possible = io_info.fpOkForIo;
 	}
 
<span class="p_del">-	/* Use smp_processor_id() for now until cmd-&gt;request-&gt;cpu is CPU</span>
<span class="p_add">+	/* Use raw_smp_processor_id() for now until cmd-&gt;request-&gt;cpu is CPU</span>
 	   id by default, not CPU group id, otherwise all MSI-X queues won&#39;t
 	   be utilized */
 	cmd-&gt;request_desc-&gt;SCSIIO.MSIxIndex = instance-&gt;msix_vectors ?
<span class="p_del">-		smp_processor_id() % instance-&gt;msix_vectors : 0;</span>
<span class="p_add">+		raw_smp_processor_id() % instance-&gt;msix_vectors : 0;</span>
 
 	if (fp_possible) {
 		megasas_set_pd_lba(io_request, scp-&gt;cmd_len, &amp;io_info, scp,
<span class="p_header">diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c</span>
<span class="p_header">index 5c6b5f5..a50825b 100644</span>
<span class="p_header">--- a/drivers/scsi/sd.c</span>
<span class="p_header">+++ b/drivers/scsi/sd.c</span>
<span class="p_chunk">@@ -1338,6 +1338,7 @@</span> <span class="p_context"> static unsigned int sd_completed_bytes(struct scsi_cmnd *scmd)</span>
 {
 	u64 start_lba = blk_rq_pos(scmd-&gt;request);
 	u64 end_lba = blk_rq_pos(scmd-&gt;request) + (scsi_bufflen(scmd) / 512);
<span class="p_add">+	u64 factor = scmd-&gt;device-&gt;sector_size / 512;</span>
 	u64 bad_lba;
 	int info_valid;
 	/*
<span class="p_chunk">@@ -1359,16 +1360,9 @@</span> <span class="p_context"> static unsigned int sd_completed_bytes(struct scsi_cmnd *scmd)</span>
 	if (scsi_bufflen(scmd) &lt;= scmd-&gt;device-&gt;sector_size)
 		return 0;
 
<span class="p_del">-	if (scmd-&gt;device-&gt;sector_size &lt; 512) {</span>
<span class="p_del">-		/* only legitimate sector_size here is 256 */</span>
<span class="p_del">-		start_lba &lt;&lt;= 1;</span>
<span class="p_del">-		end_lba &lt;&lt;= 1;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		/* be careful ... don&#39;t want any overflows */</span>
<span class="p_del">-		u64 factor = scmd-&gt;device-&gt;sector_size / 512;</span>
<span class="p_del">-		do_div(start_lba, factor);</span>
<span class="p_del">-		do_div(end_lba, factor);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* be careful ... don&#39;t want any overflows */</span>
<span class="p_add">+	do_div(start_lba, factor);</span>
<span class="p_add">+	do_div(end_lba, factor);</span>
 
 	/* The bad lba was reported incorrectly, we have no idea where
 	 * the error is.
<span class="p_chunk">@@ -1895,8 +1889,7 @@</span> <span class="p_context"> got_data:</span>
 	if (sector_size != 512 &amp;&amp;
 	    sector_size != 1024 &amp;&amp;
 	    sector_size != 2048 &amp;&amp;
<span class="p_del">-	    sector_size != 4096 &amp;&amp;</span>
<span class="p_del">-	    sector_size != 256) {</span>
<span class="p_add">+	    sector_size != 4096) {</span>
 		sd_printk(KERN_NOTICE, sdkp, &quot;Unsupported sector size %d.\n&quot;,
 			  sector_size);
 		/*
<span class="p_chunk">@@ -1945,8 +1938,6 @@</span> <span class="p_context"> got_data:</span>
 		sdkp-&gt;capacity &lt;&lt;= 2;
 	else if (sector_size == 1024)
 		sdkp-&gt;capacity &lt;&lt;= 1;
<span class="p_del">-	else if (sector_size == 256)</span>
<span class="p_del">-		sdkp-&gt;capacity &gt;&gt;= 1;</span>
 
 	blk_queue_physical_block_size(sdp-&gt;request_queue,
 				      sdkp-&gt;physical_block_size);
<span class="p_header">diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c</span>
<span class="p_header">index 2d25616..b4cac39 100644</span>
<span class="p_header">--- a/drivers/scsi/sg.c</span>
<span class="p_header">+++ b/drivers/scsi/sg.c</span>
<span class="p_chunk">@@ -1687,6 +1687,9 @@</span> <span class="p_context"> static int sg_start_req(Sg_request *srp, unsigned char *cmd)</span>
 			md-&gt;from_user = 0;
 	}
 
<span class="p_add">+	if (unlikely(iov_count &gt; UIO_MAXIOV))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if (iov_count) {
 		int len, size = sizeof(struct sg_iovec) * iov_count;
 		struct iovec *iov;
<span class="p_header">diff --git a/drivers/staging/hv/storvsc_drv.c b/drivers/staging/hv/storvsc_drv.c</span>
<span class="p_header">index c43a9e8..54ef3d4 100644</span>
<span class="p_header">--- a/drivers/staging/hv/storvsc_drv.c</span>
<span class="p_header">+++ b/drivers/staging/hv/storvsc_drv.c</span>
<span class="p_chunk">@@ -940,23 +940,24 @@</span> <span class="p_context"> static unsigned int copy_to_bounce_buffer(struct scatterlist *orig_sgl,</span>
 			if (bounce_sgl[j].length == PAGE_SIZE) {
 				/* full..move to next entry */
 				kunmap_atomic((void *)bounce_addr, KM_IRQ0);
<span class="p_add">+				bounce_addr = 0;</span>
 				j++;
<span class="p_add">+			}</span>
 
<span class="p_del">-				/* if we need to use another bounce buffer */</span>
<span class="p_del">-				if (srclen || i != orig_sgl_count - 1)</span>
<span class="p_del">-					bounce_addr =</span>
<span class="p_add">+			/* if we need to use another bounce buffer */</span>
<span class="p_add">+			if (srclen &amp;&amp; bounce_addr == 0)</span>
<span class="p_add">+				bounce_addr =</span>
 					(unsigned long)kmap_atomic(
 					sg_page((&amp;bounce_sgl[j])), KM_IRQ0);
 
<span class="p_del">-			} else if (srclen == 0 &amp;&amp; i == orig_sgl_count - 1) {</span>
<span class="p_del">-				/* unmap the last bounce that is &lt; PAGE_SIZE */</span>
<span class="p_del">-				kunmap_atomic((void *)bounce_addr, KM_IRQ0);</span>
<span class="p_del">-			}</span>
 		}
 
 		kunmap_atomic((void *)(src_addr - orig_sgl[i].offset), KM_IRQ0);
 	}
 
<span class="p_add">+	if (bounce_addr)</span>
<span class="p_add">+		kunmap_atomic((void *)bounce_addr, KM_IRQ0);</span>
<span class="p_add">+</span>
 	local_irq_restore(flags);
 
 	return total_copied;
<span class="p_header">diff --git a/drivers/staging/line6/pcm.c b/drivers/staging/line6/pcm.c</span>
<span class="p_header">index 2d3a420..955c6de 100644</span>
<span class="p_header">--- a/drivers/staging/line6/pcm.c</span>
<span class="p_header">+++ b/drivers/staging/line6/pcm.c</span>
<span class="p_chunk">@@ -88,10 +88,13 @@</span> <span class="p_context"> static DEVICE_ATTR(impulse_period, S_IWUSR | S_IRUGO, pcm_get_impulse_period,</span>
 
 int line6_pcm_start(struct snd_line6_pcm *line6pcm, int channels)
 {
<span class="p_del">-	unsigned long flags_old =</span>
<span class="p_del">-	    __sync_fetch_and_or(&amp;line6pcm-&gt;flags, channels);</span>
<span class="p_del">-	unsigned long flags_new = flags_old | channels;</span>
<span class="p_del">-	int err = 0;</span>
<span class="p_add">+	unsigned long flags_old, flags_new;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		flags_old = ACCESS_ONCE(line6pcm-&gt;flags);</span>
<span class="p_add">+		flags_new = flags_old | channels;</span>
<span class="p_add">+	} while (cmpxchg(&amp;line6pcm-&gt;flags, flags_old, flags_new) != flags_old);</span>
 
 #if LINE6_BACKUP_MONITOR_SIGNAL
 	if (!(line6pcm-&gt;line6-&gt;properties-&gt;capabilities &amp; LINE6_BIT_HWMON)) {
<span class="p_chunk">@@ -133,10 +136,8 @@</span> <span class="p_context"> int line6_pcm_start(struct snd_line6_pcm *line6pcm, int channels)</span>
 		line6pcm-&gt;prev_fsize = 0;
 		err = line6_submit_audio_in_all_urbs(line6pcm);
 
<span class="p_del">-		if (err &lt; 0) {</span>
<span class="p_del">-			__sync_fetch_and_and(&amp;line6pcm-&gt;flags, ~channels);</span>
<span class="p_del">-			return err;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			goto fail;</span>
 	}
 
 	if (((flags_old &amp; MASK_PLAYBACK) == 0) &amp;&amp;
<span class="p_chunk">@@ -160,20 +161,29 @@</span> <span class="p_context"> int line6_pcm_start(struct snd_line6_pcm *line6pcm, int channels)</span>
 		line6pcm-&gt;count_out = 0;
 		err = line6_submit_audio_out_all_urbs(line6pcm);
 
<span class="p_del">-		if (err &lt; 0) {</span>
<span class="p_del">-			__sync_fetch_and_and(&amp;line6pcm-&gt;flags, ~channels);</span>
<span class="p_del">-			return err;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			goto fail;</span>
 	}
 
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+fail:</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		flags_old = ACCESS_ONCE(line6pcm-&gt;flags);</span>
<span class="p_add">+		flags_new = flags_old &amp; ~channels;</span>
<span class="p_add">+	} while (cmpxchg(&amp;line6pcm-&gt;flags, flags_old, flags_new) != flags_old);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
 }
 
 int line6_pcm_stop(struct snd_line6_pcm *line6pcm, int channels)
 {
<span class="p_del">-	unsigned long flags_old =</span>
<span class="p_del">-	    __sync_fetch_and_and(&amp;line6pcm-&gt;flags, ~channels);</span>
<span class="p_del">-	unsigned long flags_new = flags_old &amp; ~channels;</span>
<span class="p_add">+	unsigned long flags_old, flags_new;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		flags_old = ACCESS_ONCE(line6pcm-&gt;flags);</span>
<span class="p_add">+		flags_new = flags_old &amp; ~channels;</span>
<span class="p_add">+	} while (cmpxchg(&amp;line6pcm-&gt;flags, flags_old, flags_new) != flags_old);</span>
 
 	if (((flags_old &amp; MASK_CAPTURE) != 0) &amp;&amp;
 	    ((flags_new &amp; MASK_CAPTURE) == 0)) {
<span class="p_header">diff --git a/drivers/staging/panel/panel.c b/drivers/staging/panel/panel.c</span>
<span class="p_header">index 4683d5f..9a584da 100644</span>
<span class="p_header">--- a/drivers/staging/panel/panel.c</span>
<span class="p_header">+++ b/drivers/staging/panel/panel.c</span>
<span class="p_chunk">@@ -274,11 +274,11 @@</span> <span class="p_context"> static unsigned char lcd_bits[LCD_PORTS][LCD_BITS][BIT_STATES];</span>
  * LCD types
  */
 #define LCD_TYPE_NONE		0
<span class="p_del">-#define LCD_TYPE_OLD		1</span>
<span class="p_del">-#define LCD_TYPE_KS0074		2</span>
<span class="p_del">-#define LCD_TYPE_HANTRONIX	3</span>
<span class="p_del">-#define LCD_TYPE_NEXCOM		4</span>
<span class="p_del">-#define LCD_TYPE_CUSTOM		5</span>
<span class="p_add">+#define LCD_TYPE_CUSTOM		1</span>
<span class="p_add">+#define LCD_TYPE_OLD		2</span>
<span class="p_add">+#define LCD_TYPE_KS0074		3</span>
<span class="p_add">+#define LCD_TYPE_HANTRONIX	4</span>
<span class="p_add">+#define LCD_TYPE_NEXCOM		5</span>
 
 /*
  * keypad types
<span class="p_chunk">@@ -456,8 +456,7 @@</span> <span class="p_context"> MODULE_PARM_DESC(keypad_enabled, &quot;Deprecated option, use keypad_type instead&quot;);</span>
 static int lcd_type = -1;
 module_param(lcd_type, int, 0000);
 MODULE_PARM_DESC(lcd_type,
<span class="p_del">-		 &quot;LCD type: 0=none, 1=old //, 2=serial ks0074, &quot;</span>
<span class="p_del">-		 &quot;3=hantronix //, 4=nexcom //, 5=compiled-in&quot;);</span>
<span class="p_add">+		 &quot;LCD type: 0=none, 1=compiled-in, 2=old, 3=serial ks0074, 4=hantronix, 5=nexcom&quot;);</span>
 
 static int lcd_proto = -1;
 module_param(lcd_proto, int, 0000);
<span class="p_header">diff --git a/drivers/target/target_core_pscsi.c b/drivers/target/target_core_pscsi.c</span>
<span class="p_header">index ebf9b60..1fb9e58 100644</span>
<span class="p_header">--- a/drivers/target/target_core_pscsi.c</span>
<span class="p_header">+++ b/drivers/target/target_core_pscsi.c</span>
<span class="p_chunk">@@ -569,6 +569,7 @@</span> <span class="p_context"> static struct se_device *pscsi_create_virtdevice(</span>
 					&quot; pdv_host_id: %d\n&quot;, pdv-&gt;pdv_host_id);
 				return ERR_PTR(-EINVAL);
 			}
<span class="p_add">+			pdv-&gt;pdv_lld_host = sh;</span>
 		}
 	} else {
 		if (phv-&gt;phv_mode == PHV_VIRUTAL_HOST_ID) {
<span class="p_chunk">@@ -655,6 +656,8 @@</span> <span class="p_context"> static void pscsi_free_device(void *p)</span>
 		if ((phv-&gt;phv_mode == PHV_LLD_SCSI_HOST_NO) &amp;&amp;
 		    (phv-&gt;phv_lld_host != NULL))
 			scsi_host_put(phv-&gt;phv_lld_host);
<span class="p_add">+		else if (pdv-&gt;pdv_lld_host)</span>
<span class="p_add">+			scsi_host_put(pdv-&gt;pdv_lld_host);</span>
 
 		if ((sd-&gt;type == TYPE_DISK) || (sd-&gt;type == TYPE_ROM))
 			scsi_device_put(sd);
<span class="p_header">diff --git a/drivers/target/target_core_pscsi.h b/drivers/target/target_core_pscsi.h</span>
<span class="p_header">index fdc17b6..8b0a336 100644</span>
<span class="p_header">--- a/drivers/target/target_core_pscsi.h</span>
<span class="p_header">+++ b/drivers/target/target_core_pscsi.h</span>
<span class="p_chunk">@@ -46,6 +46,7 @@</span> <span class="p_context"> struct pscsi_dev_virt {</span>
 	struct block_device *pdv_bd;
 	struct scsi_device *pdv_sd;
 	struct se_hba *pdv_se_hba;
<span class="p_add">+	struct Scsi_Host *pdv_lld_host;</span>
 } ____cacheline_aligned;
 
 typedef enum phv_modes {
<span class="p_header">diff --git a/drivers/tty/hvc/hvc_xen.c b/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_header">index 52fdf60..df8f8e0 100644</span>
<span class="p_header">--- a/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_header">+++ b/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_chunk">@@ -167,7 +167,7 @@</span> <span class="p_context"> static int __init xen_hvc_init(void)</span>
 
 	if (xen_initial_domain()) {
 		ops = &amp;dom0_hvc_ops;
<span class="p_del">-		xencons_irq = bind_virq_to_irq(VIRQ_CONSOLE, 0);</span>
<span class="p_add">+		xencons_irq = bind_virq_to_irq(VIRQ_CONSOLE, 0, false);</span>
 	} else {
 		if (!xen_start_info-&gt;console.domU.evtchn)
 			return -ENODEV;
<span class="p_header">diff --git a/drivers/tty/serial/of_serial.c b/drivers/tty/serial/of_serial.c</span>
<span class="p_header">index 6563cad..746e771 100644</span>
<span class="p_header">--- a/drivers/tty/serial/of_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/of_serial.c</span>
<span class="p_chunk">@@ -192,7 +192,6 @@</span> <span class="p_context"> static struct of_device_id __devinitdata of_platform_serial_table[] = {</span>
 	{ .compatible = &quot;ibm,qpace-nwp-serial&quot;,
 		.data = (void *)PORT_NWPSERIAL, },
 #endif
<span class="p_del">-	{ .type = &quot;serial&quot;,         .data = (void *)PORT_UNKNOWN, },</span>
 	{ /* end of list */ },
 };
 
<span class="p_header">diff --git a/drivers/tty/serial/uartlite.c b/drivers/tty/serial/uartlite.c</span>
<span class="p_header">index 6cd4143..d9706e7 100644</span>
<span class="p_header">--- a/drivers/tty/serial/uartlite.c</span>
<span class="p_header">+++ b/drivers/tty/serial/uartlite.c</span>
<span class="p_chunk">@@ -573,7 +573,8 @@</span> <span class="p_context"> MODULE_DEVICE_TABLE(of, ulite_of_match);</span>
 
 static int __devinit ulite_probe(struct platform_device *pdev)
 {
<span class="p_del">-	struct resource *res, *res2;</span>
<span class="p_add">+	struct resource *res;</span>
<span class="p_add">+	int irq;</span>
 	int id = pdev-&gt;id;
 #ifdef CONFIG_OF
 	const __be32 *prop;
<span class="p_chunk">@@ -587,11 +588,11 @@</span> <span class="p_context"> static int __devinit ulite_probe(struct platform_device *pdev)</span>
 	if (!res)
 		return -ENODEV;
 
<span class="p_del">-	res2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);</span>
<span class="p_del">-	if (!res2)</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+	irq = platform_get_irq(pdev, 0);</span>
<span class="p_add">+	if (irq &lt;= 0)</span>
<span class="p_add">+		return -ENXIO;</span>
 
<span class="p_del">-	return ulite_assign(&amp;pdev-&gt;dev, id, res-&gt;start, res2-&gt;start);</span>
<span class="p_add">+	return ulite_assign(&amp;pdev-&gt;dev, id, res-&gt;start, irq);</span>
 }
 
 static int __devexit ulite_remove(struct platform_device *pdev)
<span class="p_header">diff --git a/drivers/tty/serial/xilinx_uartps.c b/drivers/tty/serial/xilinx_uartps.c</span>
<span class="p_header">index b627363..778c39a 100644</span>
<span class="p_header">--- a/drivers/tty/serial/xilinx_uartps.c</span>
<span class="p_header">+++ b/drivers/tty/serial/xilinx_uartps.c</span>
<span class="p_chunk">@@ -941,9 +941,9 @@</span> <span class="p_context"> static struct uart_driver xuartps_uart_driver = {</span>
  **/
 static int __devinit xuartps_probe(struct platform_device *pdev)
 {
<span class="p_del">-	int rc;</span>
<span class="p_add">+	int rc, irq;</span>
 	struct uart_port *port;
<span class="p_del">-	struct resource *res, *res2;</span>
<span class="p_add">+	struct resource *res;</span>
 	int clk = 0;
 
 #ifdef CONFIG_OF
<span class="p_chunk">@@ -964,9 +964,9 @@</span> <span class="p_context"> static int __devinit xuartps_probe(struct platform_device *pdev)</span>
 	if (!res)
 		return -ENODEV;
 
<span class="p_del">-	res2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);</span>
<span class="p_del">-	if (!res2)</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+	irq = platform_get_irq(pdev, 0);</span>
<span class="p_add">+	if (irq &lt;= 0)</span>
<span class="p_add">+		return -ENXIO;</span>
 
 	/* Initialize the port structure */
 	port = xuartps_get_port();
<span class="p_chunk">@@ -980,7 +980,7 @@</span> <span class="p_context"> static int __devinit xuartps_probe(struct platform_device *pdev)</span>
 		 * and triggers invocation of the config_port() entry point.
 		 */
 		port-&gt;mapbase = res-&gt;start;
<span class="p_del">-		port-&gt;irq = res2-&gt;start;</span>
<span class="p_add">+		port-&gt;irq = irq;</span>
 		port-&gt;dev = &amp;pdev-&gt;dev;
 		port-&gt;uartclk = clk;
 		dev_set_drvdata(&amp;pdev-&gt;dev, port);
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index 360ddb5..57d6302 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -947,11 +947,16 @@</span> <span class="p_context"> static int acm_probe(struct usb_interface *intf,</span>
 	}
 
 	while (buflen &gt; 0) {
<span class="p_add">+		elength = buffer[0];</span>
<span class="p_add">+		if (!elength) {</span>
<span class="p_add">+			dev_err(&amp;intf-&gt;dev, &quot;skipping garbage byte\n&quot;);</span>
<span class="p_add">+			elength = 1;</span>
<span class="p_add">+			goto next_desc;</span>
<span class="p_add">+		}</span>
 		if (buffer[1] != USB_DT_CS_INTERFACE) {
 			dev_err(&amp;intf-&gt;dev, &quot;skipping garbage\n&quot;);
 			goto next_desc;
 		}
<span class="p_del">-		elength = buffer[0];</span>
 
 		switch (buffer[2]) {
 		case USB_CDC_UNION_TYPE: /* we&#39;ve found it */
<span class="p_header">diff --git a/drivers/usb/class/cdc-wdm.c b/drivers/usb/class/cdc-wdm.c</span>
<span class="p_header">index 06dfb4f..d34005b 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-wdm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-wdm.c</span>
<span class="p_chunk">@@ -224,7 +224,7 @@</span> <span class="p_context"> static void wdm_int_callback(struct urb *urb)</span>
 	case USB_CDC_NOTIFY_RESPONSE_AVAILABLE:
 		dev_dbg(&amp;desc-&gt;intf-&gt;dev,
 			&quot;NOTIFY_RESPONSE_AVAILABLE received: index %d len %d&quot;,
<span class="p_del">-			dr-&gt;wIndex, dr-&gt;wLength);</span>
<span class="p_add">+			le16_to_cpu(dr-&gt;wIndex), le16_to_cpu(dr-&gt;wLength));</span>
 		break;
 
 	case USB_CDC_NOTIFY_NETWORK_CONNECTION:
<span class="p_chunk">@@ -237,14 +237,16 @@</span> <span class="p_context"> static void wdm_int_callback(struct urb *urb)</span>
 		clear_bit(WDM_POLL_RUNNING, &amp;desc-&gt;flags);
 		dev_err(&amp;desc-&gt;intf-&gt;dev,
 			&quot;unknown notification %d received: index %d len %d\n&quot;,
<span class="p_del">-			dr-&gt;bNotificationType, dr-&gt;wIndex, dr-&gt;wLength);</span>
<span class="p_add">+			dr-&gt;bNotificationType,</span>
<span class="p_add">+			le16_to_cpu(dr-&gt;wIndex),</span>
<span class="p_add">+			le16_to_cpu(dr-&gt;wLength));</span>
 		goto exit;
 	}
 
 	req-&gt;bRequestType = (USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE);
 	req-&gt;bRequest = USB_CDC_GET_ENCAPSULATED_RESPONSE;
 	req-&gt;wValue = 0;
<span class="p_del">-	req-&gt;wIndex = desc-&gt;inum;</span>
<span class="p_add">+	req-&gt;wIndex = desc-&gt;inum; /* already converted */</span>
 	req-&gt;wLength = cpu_to_le16(desc-&gt;wMaxCommand);
 
 	usb_fill_control_urb(
<span class="p_chunk">@@ -401,7 +403,7 @@</span> <span class="p_context"> static ssize_t wdm_write</span>
 			     USB_RECIP_INTERFACE);
 	req-&gt;bRequest = USB_CDC_SEND_ENCAPSULATED_COMMAND;
 	req-&gt;wValue = 0;
<span class="p_del">-	req-&gt;wIndex = desc-&gt;inum;</span>
<span class="p_add">+	req-&gt;wIndex = desc-&gt;inum; /* already converted */</span>
 	req-&gt;wLength = cpu_to_le16(count);
 	set_bit(WDM_IN_USE, &amp;desc-&gt;flags);
 	desc-&gt;outbuf = buf;
<span class="p_chunk">@@ -414,7 +416,7 @@</span> <span class="p_context"> static ssize_t wdm_write</span>
 		dev_err(&amp;desc-&gt;intf-&gt;dev, &quot;Tx URB error: %d\n&quot;, rv);
 	} else {
 		dev_dbg(&amp;desc-&gt;intf-&gt;dev, &quot;Tx URB has been submitted index=%d&quot;,
<span class="p_del">-			req-&gt;wIndex);</span>
<span class="p_add">+			le16_to_cpu(req-&gt;wIndex));</span>
 	}
 out:
 	usb_autopm_put_interface(desc-&gt;intf);
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index 25e9eb4..a47e29a 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -2060,8 +2060,13 @@</span> <span class="p_context"> static int process_isoc_td(struct xhci_hcd *xhci, struct xhci_td *td,</span>
 		break;
 	case COMP_DEV_ERR:
 	case COMP_STALL:
<span class="p_add">+		frame-&gt;status = -EPROTO;</span>
<span class="p_add">+		skip_td = true;</span>
<span class="p_add">+		break;</span>
 	case COMP_TX_ERR:
 		frame-&gt;status = -EPROTO;
<span class="p_add">+		if (event_trb != td-&gt;last_trb)</span>
<span class="p_add">+			return 0;</span>
 		skip_td = true;
 		break;
 	case COMP_STOP:
<span class="p_chunk">@@ -2646,7 +2651,7 @@</span> <span class="p_context"> irqreturn_t xhci_irq(struct usb_hcd *hcd)</span>
 		xhci_halt(xhci);
 hw_died:
 		spin_unlock(&amp;xhci-&gt;lock);
<span class="p_del">-		return -ESHUTDOWN;</span>
<span class="p_add">+		return IRQ_HANDLED;</span>
 	}
 
 	/*
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index efbdf83..d676ae0 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -1231,7 +1231,7 @@</span> <span class="p_context"> union xhci_trb {</span>
  * since the command ring is 64-byte aligned.
  * It must also be greater than 16.
  */
<span class="p_del">-#define TRBS_PER_SEGMENT	64</span>
<span class="p_add">+#define TRBS_PER_SEGMENT	256</span>
 /* Allow two commands + a link TRB, along with any reserved command TRBs */
 #define MAX_RSVD_CMD_TRBS	(TRBS_PER_SEGMENT - 3)
 #define SEGMENT_SIZE		(TRBS_PER_SEGMENT*16)
<span class="p_header">diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c</span>
<span class="p_header">index 641caf8..6f7d84e 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musb_core.c</span>
<span class="p_header">+++ b/drivers/usb/musb/musb_core.c</span>
<span class="p_chunk">@@ -1524,16 +1524,30 @@</span> <span class="p_context"> irqreturn_t musb_interrupt(struct musb *musb)</span>
 		(devctl &amp; MUSB_DEVCTL_HM) ? &quot;host&quot; : &quot;peripheral&quot;,
 		musb-&gt;int_usb, musb-&gt;int_tx, musb-&gt;int_rx);
 
<span class="p_del">-	/* the core can interrupt us for multiple reasons; docs have</span>
<span class="p_del">-	 * a generic interrupt flowchart to follow</span>
<span class="p_add">+	/**</span>
<span class="p_add">+	 * According to Mentor Graphics&#39; documentation, flowchart on page 98,</span>
<span class="p_add">+	 * IRQ should be handled as follows:</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * . Resume IRQ</span>
<span class="p_add">+	 * . Session Request IRQ</span>
<span class="p_add">+	 * . VBUS Error IRQ</span>
<span class="p_add">+	 * . Suspend IRQ</span>
<span class="p_add">+	 * . Connect IRQ</span>
<span class="p_add">+	 * . Disconnect IRQ</span>
<span class="p_add">+	 * . Reset/Babble IRQ</span>
<span class="p_add">+	 * . SOF IRQ (we&#39;re not using this one)</span>
<span class="p_add">+	 * . Endpoint 0 IRQ</span>
<span class="p_add">+	 * . TX Endpoints</span>
<span class="p_add">+	 * . RX Endpoints</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We will be following that flowchart in order to avoid any problems</span>
<span class="p_add">+	 * that might arise with internal Finite State Machine.</span>
 	 */
<span class="p_add">+</span>
 	if (musb-&gt;int_usb)
 		retval |= musb_stage0_irq(musb, musb-&gt;int_usb,
 				devctl, power);
 
<span class="p_del">-	/* &quot;stage 1&quot; is handling endpoint irqs */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* handle endpoint 0 first */</span>
 	if (musb-&gt;int_tx &amp; 1) {
 		if (devctl &amp; MUSB_DEVCTL_HM)
 			retval |= musb_h_ep0_irq(musb);
<span class="p_chunk">@@ -1541,43 +1555,37 @@</span> <span class="p_context"> irqreturn_t musb_interrupt(struct musb *musb)</span>
 			retval |= musb_g_ep0_irq(musb);
 	}
 
<span class="p_del">-	/* RX on endpoints 1-15 */</span>
<span class="p_del">-	reg = musb-&gt;int_rx &gt;&gt; 1;</span>
<span class="p_add">+	reg = musb-&gt;int_tx &gt;&gt; 1;</span>
 	ep_num = 1;
 	while (reg) {
 		if (reg &amp; 1) {
<span class="p_del">-			/* musb_ep_select(musb-&gt;mregs, ep_num); */</span>
<span class="p_del">-			/* REVISIT just retval = ep-&gt;rx_irq(...) */</span>
 			retval = IRQ_HANDLED;
 			if (devctl &amp; MUSB_DEVCTL_HM) {
 				if (is_host_capable())
<span class="p_del">-					musb_host_rx(musb, ep_num);</span>
<span class="p_add">+					musb_host_tx(musb, ep_num);</span>
 			} else {
 				if (is_peripheral_capable())
<span class="p_del">-					musb_g_rx(musb, ep_num);</span>
<span class="p_add">+					musb_g_tx(musb, ep_num);</span>
 			}
 		}
<span class="p_del">-</span>
 		reg &gt;&gt;= 1;
 		ep_num++;
 	}
 
<span class="p_del">-	/* TX on endpoints 1-15 */</span>
<span class="p_del">-	reg = musb-&gt;int_tx &gt;&gt; 1;</span>
<span class="p_add">+	reg = musb-&gt;int_rx &gt;&gt; 1;</span>
 	ep_num = 1;
 	while (reg) {
 		if (reg &amp; 1) {
<span class="p_del">-			/* musb_ep_select(musb-&gt;mregs, ep_num); */</span>
<span class="p_del">-			/* REVISIT just retval |= ep-&gt;tx_irq(...) */</span>
 			retval = IRQ_HANDLED;
 			if (devctl &amp; MUSB_DEVCTL_HM) {
 				if (is_host_capable())
<span class="p_del">-					musb_host_tx(musb, ep_num);</span>
<span class="p_add">+					musb_host_rx(musb, ep_num);</span>
 			} else {
 				if (is_peripheral_capable())
<span class="p_del">-					musb_g_tx(musb, ep_num);</span>
<span class="p_add">+					musb_g_rx(musb, ep_num);</span>
 			}
 		}
<span class="p_add">+</span>
 		reg &gt;&gt;= 1;
 		ep_num++;
 	}
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 7f32c74..073a0f98 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -133,6 +133,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x10C4, 0x88A5) }, /* Planet Innovation Ingeni ZigBee USB Device */
 	{ USB_DEVICE(0x10C4, 0x8946) }, /* Ketra N1 Wireless Interface */
 	{ USB_DEVICE(0x10C4, 0x8977) },	/* CEL MeshWorks DevKit Device */
<span class="p_add">+	{ USB_DEVICE(0x10C4, 0x8998) }, /* KCF Technologies PRN */</span>
<span class="p_add">+	{ USB_DEVICE(0x10C4, 0x8A2A) }, /* HubZ dual ZigBee and Z-Wave dongle */</span>
 	{ USB_DEVICE(0x10C4, 0xEA60) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA61) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA70) }, /* Silicon Labs factory default */
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index e13ebb0..8257d3b 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -723,6 +723,7 @@</span> <span class="p_context"> static struct usb_device_id id_table_combined [] = {</span>
 	{ USB_DEVICE(XSENS_VID, XSENS_AWINDA_DONGLE_PID) },
 	{ USB_DEVICE(XSENS_VID, XSENS_AWINDA_STATION_PID) },
 	{ USB_DEVICE(XSENS_VID, XSENS_CONVERTER_PID) },
<span class="p_add">+	{ USB_DEVICE(XSENS_VID, XSENS_MTDEVBOARD_PID) },</span>
 	{ USB_DEVICE(XSENS_VID, XSENS_MTW_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_OMNI1509) },
 	{ USB_DEVICE(MOBILITY_VID, MOBILITY_USB_SERIAL_PID) },
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index 361192c..e4a57bb 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -155,6 +155,7 @@</span> <span class="p_context"></span>
 #define XSENS_AWINDA_STATION_PID 0x0101
 #define XSENS_AWINDA_DONGLE_PID 0x0102
 #define XSENS_MTW_PID		0x0200	/* Xsens MTw */
<span class="p_add">+#define XSENS_MTDEVBOARD_PID	0x0300	/* Motion Tracker Development Board */</span>
 #define XSENS_CONVERTER_PID	0xD00D	/* Xsens USB-serial converter */
 
 /* Xsens devices using FTDI VID */
<span class="p_header">diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c</span>
<span class="p_header">index 7ba38ea..a440387 100644</span>
<span class="p_header">--- a/drivers/usb/serial/pl2303.c</span>
<span class="p_header">+++ b/drivers/usb/serial/pl2303.c</span>
<span class="p_chunk">@@ -67,7 +67,6 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(DCU10_VENDOR_ID, DCU10_PRODUCT_ID) },
 	{ USB_DEVICE(SITECOM_VENDOR_ID, SITECOM_PRODUCT_ID) },
 	{ USB_DEVICE(ALCATEL_VENDOR_ID, ALCATEL_PRODUCT_ID) },
<span class="p_del">-	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_PRODUCT_ID) },</span>
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_SX1) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X65) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X75) },
<span class="p_header">diff --git a/drivers/usb/serial/pl2303.h b/drivers/usb/serial/pl2303.h</span>
<span class="p_header">index 71fd9da..e3b7af8 100644</span>
<span class="p_header">--- a/drivers/usb/serial/pl2303.h</span>
<span class="p_header">+++ b/drivers/usb/serial/pl2303.h</span>
<span class="p_chunk">@@ -62,10 +62,6 @@</span> <span class="p_context"></span>
 #define ALCATEL_VENDOR_ID	0x11f7
 #define ALCATEL_PRODUCT_ID	0x02df
 
<span class="p_del">-/* Samsung I330 phone cradle */</span>
<span class="p_del">-#define SAMSUNG_VENDOR_ID	0x04e8</span>
<span class="p_del">-#define SAMSUNG_PRODUCT_ID	0x8001</span>
<span class="p_del">-</span>
 #define SIEMENS_VENDOR_ID	0x11f5
 #define SIEMENS_PRODUCT_ID_SX1	0x0001
 #define SIEMENS_PRODUCT_ID_X65	0x0003
<span class="p_header">diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">index 0e2c2de..68e8552 100644</span>
<span class="p_header">--- a/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">+++ b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_chunk">@@ -752,6 +752,13 @@</span> <span class="p_context"> UNUSUAL_DEV(  0x059f, 0x0643, 0x0000, 0x0000,</span>
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_GO_SLOW ),
 
<span class="p_add">+/* Reported by Christian Schaller &lt;cschalle@redhat.com&gt; */</span>
<span class="p_add">+UNUSUAL_DEV(  0x059f, 0x0651, 0x0000, 0x0000,</span>
<span class="p_add">+		&quot;LaCie&quot;,</span>
<span class="p_add">+		&quot;External HDD&quot;,</span>
<span class="p_add">+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,</span>
<span class="p_add">+		US_FL_NO_WP_DETECT ),</span>
<span class="p_add">+</span>
 /* Submitted by Joel Bourquard &lt;numlock@freesurf.ch&gt;
  * Some versions of this device need the SubClass and Protocol overrides
  * while others don&#39;t.
<span class="p_header">diff --git a/drivers/xen/events.c b/drivers/xen/events.c</span>
<span class="p_header">index f6227cc..bcf7711 100644</span>
<span class="p_header">--- a/drivers/xen/events.c</span>
<span class="p_header">+++ b/drivers/xen/events.c</span>
<span class="p_chunk">@@ -895,7 +895,7 @@</span> <span class="p_context"> static int find_virq(unsigned int virq, unsigned int cpu)</span>
 	return rc;
 }
 
<span class="p_del">-int bind_virq_to_irq(unsigned int virq, unsigned int cpu)</span>
<span class="p_add">+int bind_virq_to_irq(unsigned int virq, unsigned int cpu, bool percpu)</span>
 {
 	struct evtchn_bind_virq bind_virq;
 	int evtchn, irq, ret;
<span class="p_chunk">@@ -909,8 +909,12 @@</span> <span class="p_context"> int bind_virq_to_irq(unsigned int virq, unsigned int cpu)</span>
 		if (irq == -1)
 			goto out;
 
<span class="p_del">-		irq_set_chip_and_handler_name(irq, &amp;xen_percpu_chip,</span>
<span class="p_del">-					      handle_percpu_irq, &quot;virq&quot;);</span>
<span class="p_add">+		if (percpu)</span>
<span class="p_add">+			irq_set_chip_and_handler_name(irq, &amp;xen_percpu_chip,</span>
<span class="p_add">+						      handle_percpu_irq, &quot;virq&quot;);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			irq_set_chip_and_handler_name(irq, &amp;xen_dynamic_chip,</span>
<span class="p_add">+						      handle_edge_irq, &quot;virq&quot;);</span>
 
 		bind_virq.virq = virq;
 		bind_virq.vcpu = cpu;
<span class="p_chunk">@@ -1023,7 +1027,7 @@</span> <span class="p_context"> int bind_virq_to_irqhandler(unsigned int virq, unsigned int cpu,</span>
 {
 	int irq, retval;
 
<span class="p_del">-	irq = bind_virq_to_irq(virq, cpu);</span>
<span class="p_add">+	irq = bind_virq_to_irq(virq, cpu, irqflags &amp; IRQF_PERCPU);</span>
 	if (irq &lt; 0)
 		return irq;
 	retval = request_irq(irq, handler, irqflags, devname, dev_id);
<span class="p_header">diff --git a/drivers/xen/xen-pciback/conf_space.c b/drivers/xen/xen-pciback/conf_space.c</span>
<span class="p_header">index 82ab1c3..bb8cb69 100644</span>
<span class="p_header">--- a/drivers/xen/xen-pciback/conf_space.c</span>
<span class="p_header">+++ b/drivers/xen/xen-pciback/conf_space.c</span>
<span class="p_chunk">@@ -16,8 +16,8 @@</span> <span class="p_context"></span>
 #include &quot;conf_space.h&quot;
 #include &quot;conf_space_quirks.h&quot;
 
<span class="p_del">-bool permissive;</span>
<span class="p_del">-module_param(permissive, bool, 0644);</span>
<span class="p_add">+bool xen_pcibk_permissive;</span>
<span class="p_add">+module_param_named(permissive, xen_pcibk_permissive, bool, 0644);</span>
 
 /* This is where xen_pcibk_read_config_byte, xen_pcibk_read_config_word,
  * xen_pcibk_write_config_word, and xen_pcibk_write_config_byte are created. */
<span class="p_chunk">@@ -262,7 +262,7 @@</span> <span class="p_context"> int xen_pcibk_config_write(struct pci_dev *dev, int offset, int size, u32 value)</span>
 		 * This means that some fields may still be read-only because
 		 * they have entries in the config_field list that intercept
 		 * the write and do nothing. */
<span class="p_del">-		if (dev_data-&gt;permissive || permissive) {</span>
<span class="p_add">+		if (dev_data-&gt;permissive || xen_pcibk_permissive) {</span>
 			switch (size) {
 			case 1:
 				err = pci_write_config_byte(dev, offset,
<span class="p_header">diff --git a/drivers/xen/xen-pciback/conf_space.h b/drivers/xen/xen-pciback/conf_space.h</span>
<span class="p_header">index 2e1d73d..62461a8 100644</span>
<span class="p_header">--- a/drivers/xen/xen-pciback/conf_space.h</span>
<span class="p_header">+++ b/drivers/xen/xen-pciback/conf_space.h</span>
<span class="p_chunk">@@ -64,7 +64,7 @@</span> <span class="p_context"> struct config_field_entry {</span>
 	void *data;
 };
 
<span class="p_del">-extern bool permissive;</span>
<span class="p_add">+extern bool xen_pcibk_permissive;</span>
 
 #define OFFSET(cfg_entry) ((cfg_entry)-&gt;base_offset+(cfg_entry)-&gt;field-&gt;offset)
 
<span class="p_header">diff --git a/drivers/xen/xen-pciback/conf_space_header.c b/drivers/xen/xen-pciback/conf_space_header.c</span>
<span class="p_header">index a5bb81a..1667a90 100644</span>
<span class="p_header">--- a/drivers/xen/xen-pciback/conf_space_header.c</span>
<span class="p_header">+++ b/drivers/xen/xen-pciback/conf_space_header.c</span>
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> static int command_write(struct pci_dev *dev, int offset, u16 value, void *data)</span>
 
 	cmd-&gt;val = value;
 
<span class="p_del">-	if (!permissive &amp;&amp; (!dev_data || !dev_data-&gt;permissive))</span>
<span class="p_add">+	if (!xen_pcibk_permissive &amp;&amp; (!dev_data || !dev_data-&gt;permissive))</span>
 		return 0;
 
 	/* Only allow the guest to control certain bits. */
<span class="p_header">diff --git a/firmware/ihex2fw.c b/firmware/ihex2fw.c</span>
<span class="p_header">index cf38e15..08d90e2 100644</span>
<span class="p_header">--- a/firmware/ihex2fw.c</span>
<span class="p_header">+++ b/firmware/ihex2fw.c</span>
<span class="p_chunk">@@ -86,6 +86,7 @@</span> <span class="p_context"> int main(int argc, char **argv)</span>
 		case &#39;j&#39;:
 			include_jump = 1;
 			break;
<span class="p_add">+		default:</span>
 			return usage();
 		}
 	}
<span class="p_header">diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c</span>
<span class="p_header">index 2aed667..d252462 100644</span>
<span class="p_header">--- a/fs/binfmt_elf.c</span>
<span class="p_header">+++ b/fs/binfmt_elf.c</span>
<span class="p_chunk">@@ -746,6 +746,7 @@</span> <span class="p_context"> static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)</span>
 	    i &lt; loc-&gt;elf_ex.e_phnum; i++, elf_ppnt++) {
 		int elf_prot = 0, elf_flags;
 		unsigned long k, vaddr;
<span class="p_add">+		unsigned long total_size = 0;</span>
 
 		if (elf_ppnt-&gt;p_type != PT_LOAD)
 			continue;
<span class="p_chunk">@@ -809,10 +810,16 @@</span> <span class="p_context"> static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)</span>
 #else
 			load_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);
 #endif
<span class="p_add">+			total_size = total_mapping_size(elf_phdata,</span>
<span class="p_add">+							loc-&gt;elf_ex.e_phnum);</span>
<span class="p_add">+			if (!total_size) {</span>
<span class="p_add">+				retval = -EINVAL;</span>
<span class="p_add">+				goto out_free_dentry;</span>
<span class="p_add">+			}</span>
 		}
 
 		error = elf_map(bprm-&gt;file, load_bias + vaddr, elf_ppnt,
<span class="p_del">-				elf_prot, elf_flags, 0);</span>
<span class="p_add">+				elf_prot, elf_flags, total_size);</span>
 		if (BAD_ADDR(error)) {
 			send_sig(SIGKILL, current, 0);
 			retval = IS_ERR((void *)error) ?
<span class="p_header">diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c</span>
<span class="p_header">index a694317..da528f8 100644</span>
<span class="p_header">--- a/fs/btrfs/extent-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/extent-tree.c</span>
<span class="p_chunk">@@ -5678,12 +5678,11 @@</span> <span class="p_context"> static int __btrfs_free_reserved_extent(struct btrfs_root *root,</span>
 		return -ENOSPC;
 	}
 
<span class="p_del">-	if (btrfs_test_opt(root, DISCARD))</span>
<span class="p_del">-		ret = btrfs_discard_extent(root, start, len, NULL);</span>
<span class="p_del">-</span>
 	if (pin)
 		pin_down_extent(root, cache, start, len, 1);
 	else {
<span class="p_add">+		if (btrfs_test_opt(root, DISCARD))</span>
<span class="p_add">+			ret = btrfs_discard_extent(root, start, len, NULL);</span>
 		btrfs_add_free_space(cache, start, len);
 		btrfs_update_reserved_bytes(cache, len, RESERVE_FREE);
 	}
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index 7cbe2f8..52bacff 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -2263,6 +2263,11 @@</span> <span class="p_context"> static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,</span>
 	if (off + len == src-&gt;i_size)
 		len = ALIGN(src-&gt;i_size, bs) - off;
 
<span class="p_add">+	if (len == 0) {</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* verify the end result is block aligned */
 	if (!IS_ALIGNED(off, bs) || !IS_ALIGNED(off + len, bs) ||
 	    !IS_ALIGNED(destoff, bs))
<span class="p_header">diff --git a/fs/btrfs/xattr.c b/fs/btrfs/xattr.c</span>
<span class="p_header">index 3848b04..60ff45e 100644</span>
<span class="p_header">--- a/fs/btrfs/xattr.c</span>
<span class="p_header">+++ b/fs/btrfs/xattr.c</span>
<span class="p_chunk">@@ -310,21 +310,40 @@</span> <span class="p_context"> const struct xattr_handler *btrfs_xattr_handlers[] = {</span>
 /*
  * Check if the attribute is in a supported namespace.
  *
<span class="p_del">- * This applied after the check for the synthetic attributes in the system</span>
<span class="p_add">+ * This is applied after the check for the synthetic attributes in the system</span>
  * namespace.
  */
<span class="p_del">-static bool btrfs_is_valid_xattr(const char *name)</span>
<span class="p_add">+static int btrfs_is_valid_xattr(const char *name)</span>
 {
<span class="p_del">-	return !strncmp(name, XATTR_SECURITY_PREFIX,</span>
<span class="p_del">-			XATTR_SECURITY_PREFIX_LEN) ||</span>
<span class="p_del">-	       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||</span>
<span class="p_del">-	       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||</span>
<span class="p_del">-	       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);</span>
<span class="p_add">+	int len = strlen(name);</span>
<span class="p_add">+	int prefixlen = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!strncmp(name, XATTR_SECURITY_PREFIX,</span>
<span class="p_add">+			XATTR_SECURITY_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_SECURITY_PREFIX_LEN;</span>
<span class="p_add">+	else if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_SYSTEM_PREFIX_LEN;</span>
<span class="p_add">+	else if (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_TRUSTED_PREFIX_LEN;</span>
<span class="p_add">+	else if (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_USER_PREFIX_LEN;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return -EOPNOTSUPP;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The name cannot consist of just prefix</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (len &lt;= prefixlen)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 ssize_t btrfs_getxattr(struct dentry *dentry, const char *name,
 		       void *buffer, size_t size)
 {
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
 	/*
 	 * If this is a request for a synthetic attribute in the system.*
 	 * namespace use the generic infrastructure to resolve a handler
<span class="p_chunk">@@ -333,8 +352,9 @@</span> <span class="p_context"> ssize_t btrfs_getxattr(struct dentry *dentry, const char *name,</span>
 	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
 		return generic_getxattr(dentry, name, buffer, size);
 
<span class="p_del">-	if (!btrfs_is_valid_xattr(name))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+	ret = btrfs_is_valid_xattr(name);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 	return __btrfs_getxattr(dentry-&gt;d_inode, name, buffer, size);
 }
 
<span class="p_chunk">@@ -342,6 +362,7 @@</span> <span class="p_context"> int btrfs_setxattr(struct dentry *dentry, const char *name, const void *value,</span>
 		   size_t size, int flags)
 {
 	struct btrfs_root *root = BTRFS_I(dentry-&gt;d_inode)-&gt;root;
<span class="p_add">+	int ret;</span>
 
 	/*
 	 * The permission on security.* and system.* is not checked
<span class="p_chunk">@@ -358,8 +379,9 @@</span> <span class="p_context"> int btrfs_setxattr(struct dentry *dentry, const char *name, const void *value,</span>
 	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
 		return generic_setxattr(dentry, name, value, size, flags);
 
<span class="p_del">-	if (!btrfs_is_valid_xattr(name))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+	ret = btrfs_is_valid_xattr(name);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	if (size == 0)
 		value = &quot;&quot;;  /* empty EA, do not remove */
<span class="p_chunk">@@ -371,6 +393,7 @@</span> <span class="p_context"> int btrfs_setxattr(struct dentry *dentry, const char *name, const void *value,</span>
 int btrfs_removexattr(struct dentry *dentry, const char *name)
 {
 	struct btrfs_root *root = BTRFS_I(dentry-&gt;d_inode)-&gt;root;
<span class="p_add">+	int ret;</span>
 
 	/*
 	 * The permission on security.* and system.* is not checked
<span class="p_chunk">@@ -387,8 +410,9 @@</span> <span class="p_context"> int btrfs_removexattr(struct dentry *dentry, const char *name)</span>
 	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
 		return generic_removexattr(dentry, name);
 
<span class="p_del">-	if (!btrfs_is_valid_xattr(name))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+	ret = btrfs_is_valid_xattr(name);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	return __btrfs_setxattr(NULL, dentry-&gt;d_inode, name, NULL, 0,
 				XATTR_REPLACE);
<span class="p_header">diff --git a/fs/dcache.c b/fs/dcache.c</span>
<span class="p_header">index 8bc98af..8a35300 100644</span>
<span class="p_header">--- a/fs/dcache.c</span>
<span class="p_header">+++ b/fs/dcache.c</span>
<span class="p_chunk">@@ -1016,13 +1016,13 @@</span> <span class="p_context"> ascend:</span>
 		/* might go back up the wrong parent if we have had a rename */
 		if (!locked &amp;&amp; read_seqretry(&amp;rename_lock, seq))
 			goto rename_retry;
<span class="p_del">-		next = child-&gt;d_child.next;</span>
<span class="p_del">-		while (unlikely(child-&gt;d_flags &amp; DCACHE_DENTRY_KILLED)) {</span>
<span class="p_add">+		/* go into the first sibling still alive */</span>
<span class="p_add">+		do {</span>
<span class="p_add">+			next = child-&gt;d_child.next;</span>
 			if (next == &amp;this_parent-&gt;d_subdirs)
 				goto ascend;
 			child = list_entry(next, struct dentry, d_child);
<span class="p_del">-			next = next-&gt;next;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		} while (unlikely(child-&gt;d_flags &amp; DCACHE_DENTRY_KILLED));</span>
 		rcu_read_unlock();
 		goto resume;
 	}
<span class="p_chunk">@@ -1142,13 +1142,13 @@</span> <span class="p_context"> ascend:</span>
 		/* might go back up the wrong parent if we have had a rename */
 		if (!locked &amp;&amp; read_seqretry(&amp;rename_lock, seq))
 			goto rename_retry;
<span class="p_del">-		next = child-&gt;d_child.next;</span>
<span class="p_del">-		while (unlikely(child-&gt;d_flags &amp; DCACHE_DENTRY_KILLED)) {</span>
<span class="p_add">+		/* go into the first sibling still alive */</span>
<span class="p_add">+		do {</span>
<span class="p_add">+			next = child-&gt;d_child.next;</span>
 			if (next == &amp;this_parent-&gt;d_subdirs)
 				goto ascend;
 			child = list_entry(next, struct dentry, d_child);
<span class="p_del">-			next = next-&gt;next;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		} while (unlikely(child-&gt;d_flags &amp; DCACHE_DENTRY_KILLED));</span>
 		rcu_read_unlock();
 		goto resume;
 	}
<span class="p_chunk">@@ -2938,13 +2938,13 @@</span> <span class="p_context"> ascend:</span>
 		/* might go back up the wrong parent if we have had a rename */
 		if (!locked &amp;&amp; read_seqretry(&amp;rename_lock, seq))
 			goto rename_retry;
<span class="p_del">-		next = child-&gt;d_child.next;</span>
<span class="p_del">-		while (unlikely(child-&gt;d_flags &amp; DCACHE_DENTRY_KILLED)) {</span>
<span class="p_add">+		/* go into the first sibling still alive */</span>
<span class="p_add">+		do {</span>
<span class="p_add">+			next = child-&gt;d_child.next;</span>
 			if (next == &amp;this_parent-&gt;d_subdirs)
 				goto ascend;
 			child = list_entry(next, struct dentry, d_child);
<span class="p_del">-			next = next-&gt;next;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		} while (unlikely(child-&gt;d_flags &amp; DCACHE_DENTRY_KILLED));</span>
 		rcu_read_unlock();
 		goto resume;
 	}
<span class="p_header">diff --git a/fs/debugfs/inode.c b/fs/debugfs/inode.c</span>
<span class="p_header">index a15f1e2..74f03b5 100644</span>
<span class="p_header">--- a/fs/debugfs/inode.c</span>
<span class="p_header">+++ b/fs/debugfs/inode.c</span>
<span class="p_chunk">@@ -135,6 +135,7 @@</span> <span class="p_context"> static void debugfs_evict_inode(struct inode *inode)</span>
 
 static const struct super_operations debugfs_super_operations = {
 	.evict_inode	= debugfs_evict_inode,
<span class="p_add">+	.statfs		= simple_statfs,</span>
 };
 
 static int debug_fill_super(struct super_block *sb, void *data, int silent)
<span class="p_header">diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c</span>
<span class="p_header">index 834d9a1..2da63ab 100644</span>
<span class="p_header">--- a/fs/ext4/extents.c</span>
<span class="p_header">+++ b/fs/ext4/extents.c</span>
<span class="p_chunk">@@ -321,7 +321,7 @@</span> <span class="p_context"> static int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext)</span>
 	ext4_lblk_t lblock = le32_to_cpu(ext-&gt;ee_block);
 	ext4_lblk_t last = lblock + len - 1;
 
<span class="p_del">-	if (lblock &gt; last)</span>
<span class="p_add">+	if (len == 0 || lblock &gt; last)</span>
 		return 0;
 	return ext4_data_block_valid(EXT4_SB(inode-&gt;i_sb), block, len);
 }
<span class="p_chunk">@@ -4470,13 +4470,6 @@</span> <span class="p_context"> long ext4_fallocate(struct file *file, int mode, loff_t offset, loff_t len)</span>
 	struct ext4_map_blocks map;
 	unsigned int credits, blkbits = inode-&gt;i_blkbits;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * currently supporting (pre)allocate mode for extent-based</span>
<span class="p_del">-	 * files _only_</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_del">-</span>
 	/* Return error if mode is not supported */
 	if (mode &amp; ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE))
 		return -EOPNOTSUPP;
<span class="p_chunk">@@ -4497,6 +4490,15 @@</span> <span class="p_context"> long ext4_fallocate(struct file *file, int mode, loff_t offset, loff_t len)</span>
 	 */
 	credits = ext4_chunk_trans_blocks(inode, max_blocks);
 	mutex_lock(&amp;inode-&gt;i_mutex);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We only support preallocation for extent-based files only</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {</span>
<span class="p_add">+		ret = -EOPNOTSUPP;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ret = inode_newsize_ok(inode, (len + offset));
 	if (ret) {
 		mutex_unlock(&amp;inode-&gt;i_mutex);
<span class="p_chunk">@@ -4553,6 +4555,7 @@</span> <span class="p_context"> retry:</span>
 		ret = 0;
 		goto retry;
 	}
<span class="p_add">+out:</span>
 	mutex_unlock(&amp;inode-&gt;i_mutex);
 	trace_ext4_fallocate_exit(inode, offset, max_blocks,
 				ret &gt; 0 ? ret2 : ret);
<span class="p_header">diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c</span>
<span class="p_header">index c9f2e3d..cd1dd49 100644</span>
<span class="p_header">--- a/fs/ext4/namei.c</span>
<span class="p_header">+++ b/fs/ext4/namei.c</span>
<span class="p_chunk">@@ -1456,7 +1456,7 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 			  struct inode *inode)
 {
 	struct inode *dir = dentry-&gt;d_parent-&gt;d_inode;
<span class="p_del">-	struct buffer_head *bh;</span>
<span class="p_add">+	struct buffer_head *bh = NULL;</span>
 	struct ext4_dir_entry_2 *de;
 	struct super_block *sb;
 	int	retval;
<span class="p_chunk">@@ -1471,7 +1471,7 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 	if (is_dx(dir)) {
 		retval = ext4_dx_add_entry(handle, dentry, inode);
 		if (!retval || (retval != ERR_BAD_DX_DIR))
<span class="p_del">-			return retval;</span>
<span class="p_add">+			goto out;</span>
 		ext4_clear_inode_flag(dir, EXT4_INODE_INDEX);
 		dx_fallback++;
 		ext4_mark_inode_dirty(handle, dir);
<span class="p_chunk">@@ -1482,14 +1482,15 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 		if(!bh)
 			return retval;
 		retval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);
<span class="p_del">-		if (retval != -ENOSPC) {</span>
<span class="p_del">-			brelse(bh);</span>
<span class="p_del">-			return retval;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (retval != -ENOSPC)</span>
<span class="p_add">+			goto out;</span>
 
 		if (blocks == 1 &amp;&amp; !dx_fallback &amp;&amp;
<span class="p_del">-		    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX))</span>
<span class="p_del">-			return make_indexed_dir(handle, dentry, inode, bh);</span>
<span class="p_add">+		    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX)) {</span>
<span class="p_add">+			retval = make_indexed_dir(handle, dentry, inode, bh);</span>
<span class="p_add">+			bh = NULL; /* make_indexed_dir releases bh */</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
 		brelse(bh);
 	}
 	bh = ext4_append(handle, dir, &amp;block, &amp;retval);
<span class="p_chunk">@@ -1499,6 +1500,7 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 	de-&gt;inode = 0;
 	de-&gt;rec_len = ext4_rec_len_to_disk(blocksize, blocksize);
 	retval = add_dirent_to_buf(handle, dentry, inode, de, bh);
<span class="p_add">+out:</span>
 	brelse(bh);
 	if (retval == 0)
 		ext4_set_inode_state(inode, EXT4_STATE_NEWENTRY);
<span class="p_header">diff --git a/fs/fhandle.c b/fs/fhandle.c</span>
<span class="p_header">index 6b08864..c9e18f3 100644</span>
<span class="p_header">--- a/fs/fhandle.c</span>
<span class="p_header">+++ b/fs/fhandle.c</span>
<span class="p_chunk">@@ -196,8 +196,9 @@</span> <span class="p_context"> static int handle_to_path(int mountdirfd, struct file_handle __user *ufh,</span>
 		goto out_err;
 	}
 	/* copy the full handle */
<span class="p_del">-	if (copy_from_user(handle, ufh,</span>
<span class="p_del">-			   sizeof(struct file_handle) +</span>
<span class="p_add">+	*handle = f_handle;</span>
<span class="p_add">+	if (copy_from_user(&amp;handle-&gt;f_handle,</span>
<span class="p_add">+			   &amp;ufh-&gt;f_handle,</span>
 			   f_handle.handle_bytes)) {
 		retval = -EFAULT;
 		goto out_handle;
<span class="p_header">diff --git a/fs/jbd2/recovery.c b/fs/jbd2/recovery.c</span>
<span class="p_header">index da6d7ba..421834b 100644</span>
<span class="p_header">--- a/fs/jbd2/recovery.c</span>
<span class="p_header">+++ b/fs/jbd2/recovery.c</span>
<span class="p_chunk">@@ -711,11 +711,16 @@</span> <span class="p_context"> static int scan_revoke_records(journal_t *journal, struct buffer_head *bh,</span>
 {
 	jbd2_journal_revoke_header_t *header;
 	int offset, max;
<span class="p_add">+	__u32 rcount;</span>
 	int record_len = 4;
 
 	header = (jbd2_journal_revoke_header_t *) bh-&gt;b_data;
 	offset = sizeof(jbd2_journal_revoke_header_t);
<span class="p_del">-	max = be32_to_cpu(header-&gt;r_count);</span>
<span class="p_add">+	rcount = be32_to_cpu(header-&gt;r_count);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rcount &gt; journal-&gt;j_blocksize)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	max = rcount;</span>
 
 	if (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))
 		record_len = 8;
<span class="p_header">diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c</span>
<span class="p_header">index 6e91f8b..d455ea0 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4state.c</span>
<span class="p_chunk">@@ -3272,10 +3272,17 @@</span> <span class="p_context"> static int check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_sess</span>
 	return nfserr_old_stateid;
 }
 
<span class="p_add">+static __be32 nfsd4_check_openowner_confirmed(struct nfs4_ol_stateid *ols)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (ols-&gt;st_stateowner-&gt;so_is_open_owner &amp;&amp;</span>
<span class="p_add">+	    !(openowner(ols-&gt;st_stateowner)-&gt;oo_flags &amp; NFS4_OO_CONFIRMED))</span>
<span class="p_add">+		return nfserr_bad_stateid;</span>
<span class="p_add">+	return nfs_ok;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 __be32 nfs4_validate_stateid(struct nfs4_client *cl, stateid_t *stateid)
 {
 	struct nfs4_stid *s;
<span class="p_del">-	struct nfs4_ol_stateid *ols;</span>
 	__be32 status;
 
 	if (STALE_STATEID(stateid))
<span class="p_chunk">@@ -3289,11 +3296,7 @@</span> <span class="p_context"> __be32 nfs4_validate_stateid(struct nfs4_client *cl, stateid_t *stateid)</span>
 		return status;
 	if (!(s-&gt;sc_type &amp; (NFS4_OPEN_STID | NFS4_LOCK_STID)))
 		return nfs_ok;
<span class="p_del">-	ols = openlockstateid(s);</span>
<span class="p_del">-	if (ols-&gt;st_stateowner-&gt;so_is_open_owner</span>
<span class="p_del">-	    &amp;&amp; !(openowner(ols-&gt;st_stateowner)-&gt;oo_flags &amp; NFS4_OO_CONFIRMED))</span>
<span class="p_del">-		return nfserr_bad_stateid;</span>
<span class="p_del">-	return nfs_ok;</span>
<span class="p_add">+	return nfsd4_check_openowner_confirmed(openlockstateid(s));</span>
 }
 
 static __be32 nfsd4_lookup_stateid(stateid_t *stateid, unsigned char typemask, struct nfs4_stid **s)
<span class="p_chunk">@@ -3360,8 +3363,8 @@</span> <span class="p_context"> nfs4_preprocess_stateid_op(struct nfsd4_compound_state *cstate,</span>
 		status = nfs4_check_fh(current_fh, stp);
 		if (status)
 			goto out;
<span class="p_del">-		if (stp-&gt;st_stateowner-&gt;so_is_open_owner</span>
<span class="p_del">-		    &amp;&amp; !(openowner(stp-&gt;st_stateowner)-&gt;oo_flags &amp; NFS4_OO_CONFIRMED))</span>
<span class="p_add">+		status = nfsd4_check_openowner_confirmed(stp);</span>
<span class="p_add">+		if (status)</span>
 			goto out;
 		status = nfs4_check_openmode(stp, flags);
 		if (status)
<span class="p_header">diff --git a/fs/nilfs2/btree.c b/fs/nilfs2/btree.c</span>
<span class="p_header">index ecdbae1..090d8ce 100644</span>
<span class="p_header">--- a/fs/nilfs2/btree.c</span>
<span class="p_header">+++ b/fs/nilfs2/btree.c</span>
<span class="p_chunk">@@ -388,7 +388,7 @@</span> <span class="p_context"> static int nilfs_btree_root_broken(const struct nilfs_btree_node *node,</span>
 	nchildren = nilfs_btree_node_get_nchildren(node);
 
 	if (unlikely(level &lt; NILFS_BTREE_LEVEL_NODE_MIN ||
<span class="p_del">-		     level &gt; NILFS_BTREE_LEVEL_MAX ||</span>
<span class="p_add">+		     level &gt;= NILFS_BTREE_LEVEL_MAX ||</span>
 		     nchildren &lt; 0 ||
 		     nchildren &gt; NILFS_BTREE_ROOT_NCHILDREN_MAX)) {
 		pr_crit(&quot;NILFS: bad btree root (inode number=%lu): level = %d, flags = 0x%x, nchildren = %d\n&quot;,
<span class="p_header">diff --git a/fs/ocfs2/dlm/dlmmaster.c b/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_header">index dbc372e..7ba6ac1 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_chunk">@@ -729,6 +729,19 @@</span> <span class="p_context"> lookup:</span>
 	if (tmpres) {
 		spin_unlock(&amp;dlm-&gt;spinlock);
 		spin_lock(&amp;tmpres-&gt;spinlock);
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Right after dlm spinlock was released, dlm_thread could have</span>
<span class="p_add">+		 * purged the lockres. Check if lockres got unhashed. If so</span>
<span class="p_add">+		 * start over.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (hlist_unhashed(&amp;tmpres-&gt;hash_node)) {</span>
<span class="p_add">+			spin_unlock(&amp;tmpres-&gt;spinlock);</span>
<span class="p_add">+			dlm_lockres_put(tmpres);</span>
<span class="p_add">+			tmpres = NULL;</span>
<span class="p_add">+			goto lookup;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		/* Wait on the thread that is mastering the resource */
 		if (tmpres-&gt;owner == DLM_LOCK_RES_OWNER_UNKNOWN) {
 			__dlm_wait_on_lockres(tmpres);
<span class="p_header">diff --git a/fs/omfs/inode.c b/fs/omfs/inode.c</span>
<span class="p_header">index e043c4c..f58f1c4 100644</span>
<span class="p_header">--- a/fs/omfs/inode.c</span>
<span class="p_header">+++ b/fs/omfs/inode.c</span>
<span class="p_chunk">@@ -361,7 +361,7 @@</span> <span class="p_context"> nomem:</span>
 }
 
 enum {
<span class="p_del">-	Opt_uid, Opt_gid, Opt_umask, Opt_dmask, Opt_fmask</span>
<span class="p_add">+	Opt_uid, Opt_gid, Opt_umask, Opt_dmask, Opt_fmask, Opt_err</span>
 };
 
 static const match_table_t tokens = {
<span class="p_chunk">@@ -370,6 +370,7 @@</span> <span class="p_context"> static const match_table_t tokens = {</span>
 	{Opt_umask, &quot;umask=%o&quot;},
 	{Opt_dmask, &quot;dmask=%o&quot;},
 	{Opt_fmask, &quot;fmask=%o&quot;},
<span class="p_add">+	{Opt_err, NULL},</span>
 };
 
 static int parse_options(char *options, struct omfs_sb_info *sbi)
<span class="p_header">diff --git a/fs/pipe.c b/fs/pipe.c</span>
<span class="p_header">index 8ca88fc..d2cbeff 100644</span>
<span class="p_header">--- a/fs/pipe.c</span>
<span class="p_header">+++ b/fs/pipe.c</span>
<span class="p_chunk">@@ -103,25 +103,27 @@</span> <span class="p_context"> void pipe_wait(struct pipe_inode_info *pipe)</span>
 }
 
 static int
<span class="p_del">-pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,</span>
<span class="p_del">-			int atomic)</span>
<span class="p_add">+pipe_iov_copy_from_user(void *addr, int *offset, struct iovec *iov,</span>
<span class="p_add">+			size_t *remaining, int atomic)</span>
 {
 	unsigned long copy;
 
<span class="p_del">-	while (len &gt; 0) {</span>
<span class="p_add">+	while (*remaining &gt; 0) {</span>
 		while (!iov-&gt;iov_len)
 			iov++;
<span class="p_del">-		copy = min_t(unsigned long, len, iov-&gt;iov_len);</span>
<span class="p_add">+		copy = min_t(unsigned long, *remaining, iov-&gt;iov_len);</span>
 
 		if (atomic) {
<span class="p_del">-			if (__copy_from_user_inatomic(to, iov-&gt;iov_base, copy))</span>
<span class="p_add">+			if (__copy_from_user_inatomic(addr + *offset,</span>
<span class="p_add">+						      iov-&gt;iov_base, copy))</span>
 				return -EFAULT;
 		} else {
<span class="p_del">-			if (copy_from_user(to, iov-&gt;iov_base, copy))</span>
<span class="p_add">+			if (copy_from_user(addr + *offset,</span>
<span class="p_add">+					   iov-&gt;iov_base, copy))</span>
 				return -EFAULT;
 		}
<span class="p_del">-		to += copy;</span>
<span class="p_del">-		len -= copy;</span>
<span class="p_add">+		*offset += copy;</span>
<span class="p_add">+		*remaining -= copy;</span>
 		iov-&gt;iov_base += copy;
 		iov-&gt;iov_len -= copy;
 	}
<span class="p_chunk">@@ -129,25 +131,27 @@</span> <span class="p_context"> pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,</span>
 }
 
 static int
<span class="p_del">-pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,</span>
<span class="p_del">-		      int atomic)</span>
<span class="p_add">+pipe_iov_copy_to_user(struct iovec *iov, void *addr, int *offset,</span>
<span class="p_add">+		      size_t *remaining, int atomic)</span>
 {
 	unsigned long copy;
 
<span class="p_del">-	while (len &gt; 0) {</span>
<span class="p_add">+	while (*remaining &gt; 0) {</span>
 		while (!iov-&gt;iov_len)
 			iov++;
<span class="p_del">-		copy = min_t(unsigned long, len, iov-&gt;iov_len);</span>
<span class="p_add">+		copy = min_t(unsigned long, *remaining, iov-&gt;iov_len);</span>
 
 		if (atomic) {
<span class="p_del">-			if (__copy_to_user_inatomic(iov-&gt;iov_base, from, copy))</span>
<span class="p_add">+			if (__copy_to_user_inatomic(iov-&gt;iov_base,</span>
<span class="p_add">+						    addr + *offset, copy))</span>
 				return -EFAULT;
 		} else {
<span class="p_del">-			if (copy_to_user(iov-&gt;iov_base, from, copy))</span>
<span class="p_add">+			if (copy_to_user(iov-&gt;iov_base,</span>
<span class="p_add">+					 addr + *offset, copy))</span>
 				return -EFAULT;
 		}
<span class="p_del">-		from += copy;</span>
<span class="p_del">-		len -= copy;</span>
<span class="p_add">+		*offset += copy;</span>
<span class="p_add">+		*remaining -= copy;</span>
 		iov-&gt;iov_base += copy;
 		iov-&gt;iov_len -= copy;
 	}
<span class="p_chunk">@@ -383,7 +387,7 @@</span> <span class="p_context"> pipe_read(struct kiocb *iocb, const struct iovec *_iov,</span>
 			struct pipe_buffer *buf = pipe-&gt;bufs + curbuf;
 			const struct pipe_buf_operations *ops = buf-&gt;ops;
 			void *addr;
<span class="p_del">-			size_t chars = buf-&gt;len;</span>
<span class="p_add">+			size_t chars = buf-&gt;len, remaining;</span>
 			int error, atomic;
 
 			if (chars &gt; total_len)
<span class="p_chunk">@@ -397,9 +401,11 @@</span> <span class="p_context"> pipe_read(struct kiocb *iocb, const struct iovec *_iov,</span>
 			}
 
 			atomic = !iov_fault_in_pages_write(iov, chars);
<span class="p_add">+			remaining = chars;</span>
 redo:
 			addr = ops-&gt;map(pipe, buf, atomic);
<span class="p_del">-			error = pipe_iov_copy_to_user(iov, addr + buf-&gt;offset, chars, atomic);</span>
<span class="p_add">+			error = pipe_iov_copy_to_user(iov, addr, &amp;buf-&gt;offset,</span>
<span class="p_add">+						      &amp;remaining, atomic);</span>
 			ops-&gt;unmap(pipe, buf, addr);
 			if (unlikely(error)) {
 				/*
<span class="p_chunk">@@ -414,7 +420,6 @@</span> <span class="p_context"> redo:</span>
 				break;
 			}
 			ret += chars;
<span class="p_del">-			buf-&gt;offset += chars;</span>
 			buf-&gt;len -= chars;
 
 			/* Was it a packet buffer? Clean up and exit */
<span class="p_chunk">@@ -521,6 +526,7 @@</span> <span class="p_context"> pipe_write(struct kiocb *iocb, const struct iovec *_iov,</span>
 		if (ops-&gt;can_merge &amp;&amp; offset + chars &lt;= PAGE_SIZE) {
 			int error, atomic = 1;
 			void *addr;
<span class="p_add">+			size_t remaining = chars;</span>
 
 			error = ops-&gt;confirm(pipe, buf);
 			if (error)
<span class="p_chunk">@@ -529,8 +535,8 @@</span> <span class="p_context"> pipe_write(struct kiocb *iocb, const struct iovec *_iov,</span>
 			iov_fault_in_pages_read(iov, chars);
 redo1:
 			addr = ops-&gt;map(pipe, buf, atomic);
<span class="p_del">-			error = pipe_iov_copy_from_user(offset + addr, iov,</span>
<span class="p_del">-							chars, atomic);</span>
<span class="p_add">+			error = pipe_iov_copy_from_user(addr, &amp;offset, iov,</span>
<span class="p_add">+							&amp;remaining, atomic);</span>
 			ops-&gt;unmap(pipe, buf, addr);
 			ret = error;
 			do_wakeup = 1;
<span class="p_chunk">@@ -565,6 +571,8 @@</span> <span class="p_context"> redo1:</span>
 			struct page *page = pipe-&gt;tmp_page;
 			char *src;
 			int error, atomic = 1;
<span class="p_add">+			int offset = 0;</span>
<span class="p_add">+			size_t remaining;</span>
 
 			if (!page) {
 				page = alloc_page(GFP_HIGHUSER);
<span class="p_chunk">@@ -585,14 +593,15 @@</span> <span class="p_context"> redo1:</span>
 				chars = total_len;
 
 			iov_fault_in_pages_read(iov, chars);
<span class="p_add">+			remaining = chars;</span>
 redo2:
 			if (atomic)
 				src = kmap_atomic(page, KM_USER0);
 			else
 				src = kmap(page);
 
<span class="p_del">-			error = pipe_iov_copy_from_user(src, iov, chars,</span>
<span class="p_del">-							atomic);</span>
<span class="p_add">+			error = pipe_iov_copy_from_user(src, &amp;offset, iov,</span>
<span class="p_add">+							&amp;remaining, atomic);</span>
 			if (atomic)
 				kunmap_atomic(src, KM_USER0);
 			else
<span class="p_header">diff --git a/include/acpi/acpixf.h b/include/acpi/acpixf.h</span>
<span class="p_header">index f554a93..2ba218e 100644</span>
<span class="p_header">--- a/include/acpi/acpixf.h</span>
<span class="p_header">+++ b/include/acpi/acpixf.h</span>
<span class="p_chunk">@@ -125,7 +125,7 @@</span> <span class="p_context"> void acpi_free(void *address);</span>
  */
 acpi_status acpi_reallocate_root_table(void);
 
<span class="p_del">-acpi_status acpi_find_root_pointer(acpi_size *rsdp_address);</span>
<span class="p_add">+acpi_status acpi_find_root_pointer(acpi_physical_address *rsdp_address);</span>
 
 acpi_status acpi_load_tables(void);
 
<span class="p_header">diff --git a/include/acpi/actypes.h b/include/acpi/actypes.h</span>
<span class="p_header">index ed73f67..b0d7ef8 100644</span>
<span class="p_header">--- a/include/acpi/actypes.h</span>
<span class="p_header">+++ b/include/acpi/actypes.h</span>
<span class="p_chunk">@@ -198,9 +198,29 @@</span> <span class="p_context"> typedef int INT32;</span>
 typedef s32 acpi_native_int;
 
 typedef u32 acpi_size;
<span class="p_add">+</span>
<span class="p_add">+#ifdef ACPI_32BIT_PHYSICAL_ADDRESS</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * OSPMs can define this to shrink the size of the structures for 32-bit</span>
<span class="p_add">+ * none PAE environment. ASL compiler may always define this to generate</span>
<span class="p_add">+ * 32-bit OSPM compliant tables.</span>
<span class="p_add">+ */</span>
 typedef u32 acpi_io_address;
 typedef u32 acpi_physical_address;
 
<span class="p_add">+#else				/* ACPI_32BIT_PHYSICAL_ADDRESS */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * It is reported that, after some calculations, the physical addresses can</span>
<span class="p_add">+ * wrap over the 32-bit boundary on 32-bit PAE environment.</span>
<span class="p_add">+ * https://bugzilla.kernel.org/show_bug.cgi?id=87971</span>
<span class="p_add">+ */</span>
<span class="p_add">+typedef u64 acpi_io_address;</span>
<span class="p_add">+typedef u64 acpi_physical_address;</span>
<span class="p_add">+</span>
<span class="p_add">+#endif				/* ACPI_32BIT_PHYSICAL_ADDRESS */</span>
<span class="p_add">+</span>
 #define ACPI_MAX_PTR                    ACPI_UINT32_MAX
 #define ACPI_SIZE_MAX                   ACPI_UINT32_MAX
 
<span class="p_header">diff --git a/include/acpi/platform/acenv.h b/include/acpi/platform/acenv.h</span>
<span class="p_header">index 5af3ed5..b9f9210 100644</span>
<span class="p_header">--- a/include/acpi/platform/acenv.h</span>
<span class="p_header">+++ b/include/acpi/platform/acenv.h</span>
<span class="p_chunk">@@ -75,6 +75,7 @@</span> <span class="p_context"></span>
 #define ACPI_CONSTANT_EVAL_ONLY
 #define ACPI_LARGE_NAMESPACE_NODE
 #define ACPI_DATA_TABLE_DISASSEMBLY
<span class="p_add">+#define ACPI_32BIT_PHYSICAL_ADDRESS</span>
 #endif
 
 #ifdef ACPI_EXEC_APP
<span class="p_header">diff --git a/include/linux/jhash.h b/include/linux/jhash.h</span>
<span class="p_header">index 47cb09e..348c6f4 100644</span>
<span class="p_header">--- a/include/linux/jhash.h</span>
<span class="p_header">+++ b/include/linux/jhash.h</span>
<span class="p_chunk">@@ -145,11 +145,11 @@</span> <span class="p_context"> static inline u32 jhash2(const u32 *k, u32 length, u32 initval)</span>
 }
 
 
<span class="p_del">-/* jhash_3words - hash exactly 3, 2 or 1 word(s) */</span>
<span class="p_del">-static inline u32 jhash_3words(u32 a, u32 b, u32 c, u32 initval)</span>
<span class="p_add">+/* __jhash_nwords - hash exactly 3, 2 or 1 word(s) */</span>
<span class="p_add">+static inline u32 __jhash_nwords(u32 a, u32 b, u32 c, u32 initval)</span>
 {
<span class="p_del">-	a += JHASH_INITVAL;</span>
<span class="p_del">-	b += JHASH_INITVAL;</span>
<span class="p_add">+	a += initval;</span>
<span class="p_add">+	b += initval;</span>
 	c += initval;
 
 	__jhash_final(a, b, c);
<span class="p_chunk">@@ -157,14 +157,19 @@</span> <span class="p_context"> static inline u32 jhash_3words(u32 a, u32 b, u32 c, u32 initval)</span>
 	return c;
 }
 
<span class="p_add">+static inline u32 jhash_3words(u32 a, u32 b, u32 c, u32 initval)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __jhash_nwords(a, b, c, initval + JHASH_INITVAL + (3 &lt;&lt; 2));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline u32 jhash_2words(u32 a, u32 b, u32 initval)
 {
<span class="p_del">-	return jhash_3words(a, b, 0, initval);</span>
<span class="p_add">+	return __jhash_nwords(a, b, 0, initval + JHASH_INITVAL + (2 &lt;&lt; 2));</span>
 }
 
 static inline u32 jhash_1word(u32 a, u32 initval)
 {
<span class="p_del">-	return jhash_3words(a, 0, 0, initval);</span>
<span class="p_add">+	return __jhash_nwords(a, 0, 0, initval + JHASH_INITVAL + (1 &lt;&lt; 2));</span>
 }
 
 #endif /* _LINUX_JHASH_H */
<span class="p_header">diff --git a/include/linux/libata.h b/include/linux/libata.h</span>
<span class="p_header">index 42ac6ad..3d4b5b6 100644</span>
<span class="p_header">--- a/include/linux/libata.h</span>
<span class="p_header">+++ b/include/linux/libata.h</span>
<span class="p_chunk">@@ -182,6 +182,7 @@</span> <span class="p_context"> enum {</span>
 	ATA_LFLAG_DISABLED	= (1 &lt;&lt; 6), /* link is disabled */
 	ATA_LFLAG_SW_ACTIVITY	= (1 &lt;&lt; 7), /* keep activity stats */
 	ATA_LFLAG_NO_LPM	= (1 &lt;&lt; 8), /* disable LPM on this link */
<span class="p_add">+	ATA_LFLAG_CHANGED	= (1 &lt;&lt; 10), /* LPM state changed on this link */</span>
 
 	/* struct ata_port flags */
 	ATA_FLAG_SLAVE_POSS	= (1 &lt;&lt; 0), /* host supports slave dev */
<span class="p_chunk">@@ -284,6 +285,12 @@</span> <span class="p_context"> enum {</span>
 	 */
 	ATA_TMOUT_PMP_SRST_WAIT	= 5000,
 
<span class="p_add">+	/* When the LPM policy is set to ATA_LPM_MAX_POWER, there might</span>
<span class="p_add">+	 * be a spurious PHY event, so ignore the first PHY event that</span>
<span class="p_add">+	 * occurs within 10s after the policy change.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ATA_TMOUT_SPURIOUS_PHY	= 10000,</span>
<span class="p_add">+</span>
 	/* ATA bus states */
 	BUS_UNKNOWN		= 0,
 	BUS_DMA			= 1,
<span class="p_chunk">@@ -728,6 +735,8 @@</span> <span class="p_context"> struct ata_link {</span>
 	struct ata_eh_context	eh_context;
 
 	struct ata_device	device[ATA_MAX_DEVICES];
<span class="p_add">+</span>
<span class="p_add">+	unsigned long		last_lpm_change; /* when last LPM change happened */</span>
 };
 #define ATA_LINK_CLEAR_BEGIN		offsetof(struct ata_link, active_tag)
 #define ATA_LINK_CLEAR_END		offsetof(struct ata_link, device[0])
<span class="p_chunk">@@ -1064,6 +1073,7 @@</span> <span class="p_context"> extern struct ata_device *ata_dev_pair(struct ata_device *adev);</span>
 extern int ata_do_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);
 extern void ata_scsi_port_error_handler(struct Scsi_Host *host, struct ata_port *ap);
 extern void ata_scsi_cmd_error_handler(struct Scsi_Host *host, struct ata_port *ap, struct list_head *eh_q);
<span class="p_add">+extern bool sata_lpm_ignore_phy_events(struct ata_link *link);</span>
 
 extern int ata_cable_40wire(struct ata_port *ap);
 extern int ata_cable_80wire(struct ata_port *ap);
<span class="p_header">diff --git a/include/linux/nilfs2_fs.h b/include/linux/nilfs2_fs.h</span>
<span class="p_header">index 7454ad7..d4d512f 100644</span>
<span class="p_header">--- a/include/linux/nilfs2_fs.h</span>
<span class="p_header">+++ b/include/linux/nilfs2_fs.h</span>
<span class="p_chunk">@@ -457,7 +457,7 @@</span> <span class="p_context"> struct nilfs_btree_node {</span>
 /* level */
 #define NILFS_BTREE_LEVEL_DATA          0
 #define NILFS_BTREE_LEVEL_NODE_MIN      (NILFS_BTREE_LEVEL_DATA + 1)
<span class="p_del">-#define NILFS_BTREE_LEVEL_MAX           14</span>
<span class="p_add">+#define NILFS_BTREE_LEVEL_MAX           14	/* Max level (exclusive) */</span>
 
 /**
  * struct nilfs_palloc_group_desc - block group descriptor
<span class="p_header">diff --git a/include/linux/of.h b/include/linux/of.h</span>
<span class="p_header">index 9bf9611..c81ef31 100644</span>
<span class="p_header">--- a/include/linux/of.h</span>
<span class="p_header">+++ b/include/linux/of.h</span>
<span class="p_chunk">@@ -211,6 +211,9 @@</span> <span class="p_context"> extern int of_property_read_string(struct device_node *np,</span>
 extern int of_property_read_string_index(struct device_node *np,
 					 const char *propname,
 					 int index, const char **output);
<span class="p_add">+extern int of_property_match_string(struct device_node *np,</span>
<span class="p_add">+				    const char *propname,</span>
<span class="p_add">+				    const char *string);</span>
 extern int of_property_count_strings(struct device_node *np,
 				     const char *propname);
 extern int of_device_is_compatible(const struct device_node *device,
<span class="p_chunk">@@ -315,6 +318,13 @@</span> <span class="p_context"> static inline int of_property_read_u64(const struct device_node *np,</span>
 	return -ENOSYS;
 }
 
<span class="p_add">+static inline int of_property_match_string(struct device_node *np,</span>
<span class="p_add">+					   const char *propname,</span>
<span class="p_add">+					   const char *string)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return -ENOSYS;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline struct device_node *of_parse_phandle(struct device_node *np,
 						   const char *phandle_name,
 						   int index)
<span class="p_header">diff --git a/include/linux/sched.h b/include/linux/sched.h</span>
<span class="p_header">index cb34ff4..44e5f47 100644</span>
<span class="p_header">--- a/include/linux/sched.h</span>
<span class="p_header">+++ b/include/linux/sched.h</span>
<span class="p_chunk">@@ -2347,15 +2347,15 @@</span> <span class="p_context"> static inline bool thread_group_leader(struct task_struct *p)</span>
  * all we care about is that we have a task with the appropriate
  * pid, we don&#39;t actually care if we have the right task.
  */
<span class="p_del">-static inline int has_group_leader_pid(struct task_struct *p)</span>
<span class="p_add">+static inline bool has_group_leader_pid(struct task_struct *p)</span>
 {
<span class="p_del">-	return p-&gt;pid == p-&gt;tgid;</span>
<span class="p_add">+	return task_pid(p) == p-&gt;signal-&gt;leader_pid;</span>
 }
 
 static inline
<span class="p_del">-int same_thread_group(struct task_struct *p1, struct task_struct *p2)</span>
<span class="p_add">+bool same_thread_group(struct task_struct *p1, struct task_struct *p2)</span>
 {
<span class="p_del">-	return p1-&gt;tgid == p2-&gt;tgid;</span>
<span class="p_add">+	return p1-&gt;signal == p2-&gt;signal;</span>
 }
 
 static inline struct task_struct *next_thread(const struct task_struct *p)
<span class="p_header">diff --git a/include/net/ip_vs.h b/include/net/ip_vs.h</span>
<span class="p_header">index 416dcb0..b8b2e50 100644</span>
<span class="p_header">--- a/include/net/ip_vs.h</span>
<span class="p_header">+++ b/include/net/ip_vs.h</span>
<span class="p_chunk">@@ -1202,6 +1202,8 @@</span> <span class="p_context"> ip_vs_lookup_real_service(struct net *net, int af, __u16 protocol,</span>
 
 extern int ip_vs_use_count_inc(void);
 extern void ip_vs_use_count_dec(void);
<span class="p_add">+extern int ip_vs_register_nl_ioctl(void);</span>
<span class="p_add">+extern void ip_vs_unregister_nl_ioctl(void);</span>
 extern int ip_vs_control_init(void);
 extern void ip_vs_control_cleanup(void);
 extern struct ip_vs_dest *
<span class="p_header">diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h</span>
<span class="p_header">index a15432da..2cccd82 100644</span>
<span class="p_header">--- a/include/net/sctp/structs.h</span>
<span class="p_header">+++ b/include/net/sctp/structs.h</span>
<span class="p_chunk">@@ -209,6 +209,7 @@</span> <span class="p_context"> extern struct sctp_globals {</span>
 	struct list_head addr_waitq;
 	struct timer_list addr_wq_timer;
 	struct list_head auto_asconf_splist;
<span class="p_add">+	/* Lock that protects both addr_waitq and auto_asconf_splist */</span>
 	spinlock_t addr_wq_lock;
 
 	/* Lock that protects the local_addr_list writers */
<span class="p_chunk">@@ -355,6 +356,10 @@</span> <span class="p_context"> struct sctp_sock {</span>
 	atomic_t pd_mode;
 	/* Receive to here while partial delivery is in effect. */
 	struct sk_buff_head pd_lobby;
<span class="p_add">+</span>
<span class="p_add">+	/* These must be the last fields, as they will skipped on copies,</span>
<span class="p_add">+	 * like on accept and peeloff operations</span>
<span class="p_add">+	 */</span>
 	struct list_head auto_asconf_list;
 	int do_auto_asconf;
 };
<span class="p_header">diff --git a/include/sound/emu10k1.h b/include/sound/emu10k1.h</span>
<span class="p_header">index 4f865df..7ee55e3 100644</span>
<span class="p_header">--- a/include/sound/emu10k1.h</span>
<span class="p_header">+++ b/include/sound/emu10k1.h</span>
<span class="p_chunk">@@ -43,7 +43,8 @@</span> <span class="p_context"></span>
 
 #define EMUPAGESIZE     4096
 #define MAXREQVOICES    8
<span class="p_del">-#define MAXPAGES        8192</span>
<span class="p_add">+#define MAXPAGES0       4096	/* 32 bit mode */</span>
<span class="p_add">+#define MAXPAGES1       8192	/* 31 bit mode */</span>
 #define RESERVED        0
 #define NUM_MIDI        16
 #define NUM_G           64              /* use all channels */
<span class="p_chunk">@@ -52,8 +53,7 @@</span> <span class="p_context"></span>
 
 /* FIXME? - according to the OSS driver the EMU10K1 needs a 29 bit DMA mask */
 #define EMU10K1_DMA_MASK	0x7fffffffUL	/* 31bit */
<span class="p_del">-#define AUDIGY_DMA_MASK		0x7fffffffUL	/* 31bit FIXME - 32 should work? */</span>
<span class="p_del">-						/* See ALSA bug #1276 - rlrevell */</span>
<span class="p_add">+#define AUDIGY_DMA_MASK		0xffffffffUL	/* 32bit mode */</span>
 
 #define TMEMSIZE        256*1024
 #define TMEMSIZEREG     4
<span class="p_chunk">@@ -470,8 +470,11 @@</span> <span class="p_context"></span>
 
 #define MAPB			0x0d		/* Cache map B						*/
 
<span class="p_del">-#define MAP_PTE_MASK		0xffffe000	/* The 19 MSBs of the PTE indexed by the PTI		*/</span>
<span class="p_del">-#define MAP_PTI_MASK		0x00001fff	/* The 13 bit index to one of the 8192 PTE dwords      	*/</span>
<span class="p_add">+#define MAP_PTE_MASK0		0xfffff000	/* The 20 MSBs of the PTE indexed by the PTI		*/</span>
<span class="p_add">+#define MAP_PTI_MASK0		0x00000fff	/* The 12 bit index to one of the 4096 PTE dwords      	*/</span>
<span class="p_add">+</span>
<span class="p_add">+#define MAP_PTE_MASK1		0xffffe000	/* The 19 MSBs of the PTE indexed by the PTI		*/</span>
<span class="p_add">+#define MAP_PTI_MASK1		0x00001fff	/* The 13 bit index to one of the 8192 PTE dwords      	*/</span>
 
 /* 0x0e, 0x0f: Not used */
 
<span class="p_chunk">@@ -1708,6 +1711,7 @@</span> <span class="p_context"> struct snd_emu10k1 {</span>
 	unsigned short model;			/* subsystem id */
 	unsigned int card_type;			/* EMU10K1_CARD_* */
 	unsigned int ecard_ctrl;		/* ecard control bits */
<span class="p_add">+	unsigned int address_mode;		/* address mode */</span>
 	unsigned long dma_mask;			/* PCI DMA mask */
 	unsigned int delay_pcm_irq;		/* in samples */
 	int max_cache_pages;			/* max memory size / PAGE_SIZE */
<span class="p_header">diff --git a/include/xen/events.h b/include/xen/events.h</span>
<span class="p_header">index 8f3d622..89b672d 100644</span>
<span class="p_header">--- a/include/xen/events.h</span>
<span class="p_header">+++ b/include/xen/events.h</span>
<span class="p_chunk">@@ -12,7 +12,7 @@</span> <span class="p_context"> int bind_evtchn_to_irqhandler(unsigned int evtchn,</span>
 			      irq_handler_t handler,
 			      unsigned long irqflags, const char *devname,
 			      void *dev_id);
<span class="p_del">-int bind_virq_to_irq(unsigned int virq, unsigned int cpu);</span>
<span class="p_add">+int bind_virq_to_irq(unsigned int virq, unsigned int cpu, bool percpu);</span>
 int bind_virq_to_irqhandler(unsigned int virq, unsigned int cpu,
 			    irq_handler_t handler,
 			    unsigned long irqflags, const char *devname,
<span class="p_header">diff --git a/kernel/ptrace.c b/kernel/ptrace.c</span>
<span class="p_header">index f79803a..f07c144 100644</span>
<span class="p_header">--- a/kernel/ptrace.c</span>
<span class="p_header">+++ b/kernel/ptrace.c</span>
<span class="p_chunk">@@ -225,7 +225,7 @@</span> <span class="p_context"> int __ptrace_may_access(struct task_struct *task, unsigned int mode)</span>
 	 */
 	int dumpable = 0;
 	/* Don&#39;t let security modules deny introspection */
<span class="p_del">-	if (task == current)</span>
<span class="p_add">+	if (same_thread_group(task, current))</span>
 		return 0;
 	rcu_read_lock();
 	tcred = __task_cred(task);
<span class="p_chunk">@@ -640,6 +640,8 @@</span> <span class="p_context"> static int ptrace_setsiginfo(struct task_struct *child, const siginfo_t *info)</span>
 static int ptrace_resume(struct task_struct *child, long request,
 			 unsigned long data)
 {
<span class="p_add">+	bool need_siglock;</span>
<span class="p_add">+</span>
 	if (!valid_signal(data))
 		return -EIO;
 
<span class="p_chunk">@@ -667,8 +669,26 @@</span> <span class="p_context"> static int ptrace_resume(struct task_struct *child, long request,</span>
 		user_disable_single_step(child);
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Change -&gt;exit_code and -&gt;state under siglock to avoid the race</span>
<span class="p_add">+	 * with wait_task_stopped() in between; a non-zero -&gt;exit_code will</span>
<span class="p_add">+	 * wrongly look like another report from tracee.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note that we need siglock even if -&gt;exit_code == data and/or this</span>
<span class="p_add">+	 * status was not reported yet, the new status must not be cleared by</span>
<span class="p_add">+	 * wait_task_stopped() after resume.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * If data == 0 we do not care if wait_task_stopped() reports the old</span>
<span class="p_add">+	 * status and clears the code too; this can&#39;t race with the tracee, it</span>
<span class="p_add">+	 * takes siglock after resume.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	need_siglock = data &amp;&amp; !thread_group_empty(current);</span>
<span class="p_add">+	if (need_siglock)</span>
<span class="p_add">+		spin_lock_irq(&amp;child-&gt;sighand-&gt;siglock);</span>
 	child-&gt;exit_code = data;
 	wake_up_state(child, __TASK_TRACED);
<span class="p_add">+	if (need_siglock)</span>
<span class="p_add">+		spin_unlock_irq(&amp;child-&gt;sighand-&gt;siglock);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/kernel/softirq.c b/kernel/softirq.c</span>
<span class="p_header">index 2c71d91..44bc103 100644</span>
<span class="p_header">--- a/kernel/softirq.c</span>
<span class="p_header">+++ b/kernel/softirq.c</span>
<span class="p_chunk">@@ -194,22 +194,28 @@</span> <span class="p_context"> void local_bh_enable_ip(unsigned long ip)</span>
 EXPORT_SYMBOL(local_bh_enable_ip);
 
 /*
<span class="p_del">- * We restart softirq processing MAX_SOFTIRQ_RESTART times,</span>
<span class="p_del">- * and we fall back to softirqd after that.</span>
<span class="p_add">+ * We restart softirq processing for at most MAX_SOFTIRQ_RESTART times,</span>
<span class="p_add">+ * but break the loop if need_resched() is set or after 2 ms.</span>
<span class="p_add">+ * The MAX_SOFTIRQ_TIME provides a nice upper bound in most cases, but in</span>
<span class="p_add">+ * certain cases, such as stop_machine(), jiffies may cease to</span>
<span class="p_add">+ * increment and so we need the MAX_SOFTIRQ_RESTART limit as</span>
<span class="p_add">+ * well to make sure we eventually return from this method.</span>
  *
<span class="p_del">- * This number has been established via experimentation.</span>
<span class="p_add">+ * These limits have been established via experimentation.</span>
  * The two things to balance is latency against fairness -
  * we want to handle softirqs as soon as possible, but they
  * should not be able to lock up the box.
  */
<span class="p_add">+#define MAX_SOFTIRQ_TIME  msecs_to_jiffies(2)</span>
 #define MAX_SOFTIRQ_RESTART 10
 
 asmlinkage void __do_softirq(void)
 {
 	struct softirq_action *h;
 	__u32 pending;
<span class="p_del">-	int max_restart = MAX_SOFTIRQ_RESTART;</span>
<span class="p_add">+	unsigned long end = jiffies + MAX_SOFTIRQ_TIME;</span>
 	int cpu;
<span class="p_add">+	int max_restart = MAX_SOFTIRQ_RESTART;</span>
 
 	pending = local_softirq_pending();
 	account_system_vtime(current);
<span class="p_chunk">@@ -255,11 +261,13 @@</span> <span class="p_context"> restart:</span>
 	local_irq_disable();
 
 	pending = local_softirq_pending();
<span class="p_del">-	if (pending &amp;&amp; --max_restart)</span>
<span class="p_del">-		goto restart;</span>
<span class="p_add">+	if (pending) {</span>
<span class="p_add">+		if (time_before(jiffies, end) &amp;&amp; !need_resched() &amp;&amp;</span>
<span class="p_add">+		    --max_restart)</span>
<span class="p_add">+			goto restart;</span>
 
<span class="p_del">-	if (pending)</span>
 		wakeup_softirqd();
<span class="p_add">+	}</span>
 
 	lockdep_softirq_exit();
 
<span class="p_header">diff --git a/kernel/trace/ring_buffer_benchmark.c b/kernel/trace/ring_buffer_benchmark.c</span>
<span class="p_header">index a5457d5..6ad2e2d 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer_benchmark.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer_benchmark.c</span>
<span class="p_chunk">@@ -455,7 +455,7 @@</span> <span class="p_context"> static int __init ring_buffer_benchmark_init(void)</span>
 
 	if (producer_fifo &gt;= 0) {
 		struct sched_param param = {
<span class="p_del">-			.sched_priority = consumer_fifo</span>
<span class="p_add">+			.sched_priority = producer_fifo</span>
 		};
 		sched_setscheduler(producer, SCHED_FIFO, &amp;param);
 	} else
<span class="p_header">diff --git a/kernel/trace/trace_events_filter.c b/kernel/trace/trace_events_filter.c</span>
<span class="p_header">index b0996c1..47343cc 100644</span>
<span class="p_header">--- a/kernel/trace/trace_events_filter.c</span>
<span class="p_header">+++ b/kernel/trace/trace_events_filter.c</span>
<span class="p_chunk">@@ -1343,19 +1343,25 @@</span> <span class="p_context"> static int check_preds(struct filter_parse_state *ps)</span>
 {
 	int n_normal_preds = 0, n_logical_preds = 0;
 	struct postfix_elt *elt;
<span class="p_add">+	int cnt = 0;</span>
 
 	list_for_each_entry(elt, &amp;ps-&gt;postfix, list) {
<span class="p_del">-		if (elt-&gt;op == OP_NONE)</span>
<span class="p_add">+		if (elt-&gt;op == OP_NONE) {</span>
<span class="p_add">+			cnt++;</span>
 			continue;
<span class="p_add">+		}</span>
 
 		if (elt-&gt;op == OP_AND || elt-&gt;op == OP_OR) {
 			n_logical_preds++;
<span class="p_add">+			cnt--;</span>
 			continue;
 		}
<span class="p_add">+		cnt--;</span>
 		n_normal_preds++;
<span class="p_add">+		WARN_ON_ONCE(cnt &lt; 0);</span>
 	}
 
<span class="p_del">-	if (!n_normal_preds || n_logical_preds &gt;= n_normal_preds) {</span>
<span class="p_add">+	if (cnt != 1 || !n_normal_preds || n_logical_preds &gt;= n_normal_preds) {</span>
 		parse_error(ps, FILT_ERR_INVALID_FILTER, 0);
 		return -EINVAL;
 	}
<span class="p_header">diff --git a/lib/string.c b/lib/string.c</span>
<span class="p_header">index 40136f6..dcbe695 100644</span>
<span class="p_header">--- a/lib/string.c</span>
<span class="p_header">+++ b/lib/string.c</span>
<span class="p_chunk">@@ -595,7 +595,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(memset);</span>
 void memzero_explicit(void *s, size_t count)
 {
 	memset(s, 0, count);
<span class="p_del">-	OPTIMIZER_HIDE_VAR(s);</span>
<span class="p_add">+	barrier();</span>
 }
 EXPORT_SYMBOL(memzero_explicit);
 
<span class="p_header">diff --git a/mm/page-writeback.c b/mm/page-writeback.c</span>
<span class="p_header">index 1bf1f74..62bfbd9 100644</span>
<span class="p_header">--- a/mm/page-writeback.c</span>
<span class="p_header">+++ b/mm/page-writeback.c</span>
<span class="p_chunk">@@ -560,7 +560,7 @@</span> <span class="p_context"> static unsigned long bdi_position_ratio(struct backing_dev_info *bdi,</span>
 	 */
 	setpoint = (freerun + limit) / 2;
 	x = div64_s64(((s64)setpoint - (s64)dirty) &lt;&lt; RATELIMIT_CALC_SHIFT,
<span class="p_del">-		    limit - setpoint + 1);</span>
<span class="p_add">+		      (limit - setpoint) | 1);</span>
 	pos_ratio = x;
 	pos_ratio = pos_ratio * x &gt;&gt; RATELIMIT_CALC_SHIFT;
 	pos_ratio = pos_ratio * x &gt;&gt; RATELIMIT_CALC_SHIFT;
<span class="p_chunk">@@ -611,7 +611,7 @@</span> <span class="p_context"> static unsigned long bdi_position_ratio(struct backing_dev_info *bdi,</span>
 	 * scale global setpoint to bdi&#39;s:
 	 *	bdi_setpoint = setpoint * bdi_thresh / thresh
 	 */
<span class="p_del">-	x = div_u64((u64)bdi_thresh &lt;&lt; 16, thresh + 1);</span>
<span class="p_add">+	x = div_u64((u64)bdi_thresh &lt;&lt; 16, thresh | 1);</span>
 	bdi_setpoint = setpoint * (u64)x &gt;&gt; 16;
 	/*
 	 * Use span=(8*write_bw) in single bdi case as indicated by
<span class="p_chunk">@@ -626,7 +626,7 @@</span> <span class="p_context"> static unsigned long bdi_position_ratio(struct backing_dev_info *bdi,</span>
 
 	if (bdi_dirty &lt; x_intercept - span / 4) {
 		pos_ratio = div64_u64(pos_ratio * (x_intercept - bdi_dirty),
<span class="p_del">-				    x_intercept - bdi_setpoint + 1);</span>
<span class="p_add">+				      (x_intercept - bdi_setpoint) | 1);</span>
 	} else
 		pos_ratio /= 4;
 
<span class="p_header">diff --git a/mm/slub.c b/mm/slub.c</span>
<span class="p_header">index 6a4c2fb..60c69696 100644</span>
<span class="p_header">--- a/mm/slub.c</span>
<span class="p_header">+++ b/mm/slub.c</span>
<span class="p_chunk">@@ -1873,18 +1873,24 @@</span> <span class="p_context"> redo:</span>
 /* Unfreeze all the cpu partial slabs */
 static void unfreeze_partials(struct kmem_cache *s)
 {
<span class="p_del">-	struct kmem_cache_node *n = NULL;</span>
<span class="p_add">+	struct kmem_cache_node *n = NULL, *n2 = NULL;</span>
 	struct kmem_cache_cpu *c = this_cpu_ptr(s-&gt;cpu_slab);
 	struct page *page, *discard_page = NULL;
 
 	while ((page = c-&gt;partial)) {
<span class="p_del">-		enum slab_modes { M_PARTIAL, M_FREE };</span>
<span class="p_del">-		enum slab_modes l, m;</span>
 		struct page new;
 		struct page old;
 
 		c-&gt;partial = page-&gt;next;
<span class="p_del">-		l = M_FREE;</span>
<span class="p_add">+</span>
<span class="p_add">+		n2 = get_node(s, page_to_nid(page));</span>
<span class="p_add">+		if (n != n2) {</span>
<span class="p_add">+			if (n)</span>
<span class="p_add">+				spin_unlock(&amp;n-&gt;list_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+			n = n2;</span>
<span class="p_add">+			spin_lock(&amp;n-&gt;list_lock);</span>
<span class="p_add">+		}</span>
 
 		do {
 
<span class="p_chunk">@@ -1897,40 +1903,17 @@</span> <span class="p_context"> static void unfreeze_partials(struct kmem_cache *s)</span>
 
 			new.frozen = 0;
 
<span class="p_del">-			if (!new.inuse &amp;&amp; (!n || n-&gt;nr_partial &gt; s-&gt;min_partial))</span>
<span class="p_del">-				m = M_FREE;</span>
<span class="p_del">-			else {</span>
<span class="p_del">-				struct kmem_cache_node *n2 = get_node(s,</span>
<span class="p_del">-							page_to_nid(page));</span>
<span class="p_del">-</span>
<span class="p_del">-				m = M_PARTIAL;</span>
<span class="p_del">-				if (n != n2) {</span>
<span class="p_del">-					if (n)</span>
<span class="p_del">-						spin_unlock(&amp;n-&gt;list_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-					n = n2;</span>
<span class="p_del">-					spin_lock(&amp;n-&gt;list_lock);</span>
<span class="p_del">-				}</span>
<span class="p_del">-			}</span>
<span class="p_del">-</span>
<span class="p_del">-			if (l != m) {</span>
<span class="p_del">-				if (l == M_PARTIAL)</span>
<span class="p_del">-					remove_partial(n, page);</span>
<span class="p_del">-				else</span>
<span class="p_del">-					add_partial(n, page,</span>
<span class="p_del">-						DEACTIVATE_TO_TAIL);</span>
<span class="p_del">-</span>
<span class="p_del">-				l = m;</span>
<span class="p_del">-			}</span>
<span class="p_del">-</span>
 		} while (!cmpxchg_double_slab(s, page,
 				old.freelist, old.counters,
 				new.freelist, new.counters,
 				&quot;unfreezing slab&quot;));
 
<span class="p_del">-		if (m == M_FREE) {</span>
<span class="p_add">+		if (unlikely(!new.inuse &amp;&amp; n-&gt;nr_partial &gt; s-&gt;min_partial)) {</span>
 			page-&gt;next = discard_page;
 			discard_page = page;
<span class="p_add">+		} else {</span>
<span class="p_add">+			add_partial(n, page, DEACTIVATE_TO_TAIL);</span>
<span class="p_add">+			stat(s, FREE_ADD_PARTIAL);</span>
 		}
 	}
 
<span class="p_header">diff --git a/net/bridge/br_ioctl.c b/net/bridge/br_ioctl.c</span>
<span class="p_header">index 7222fe1..ea0e15c 100644</span>
<span class="p_header">--- a/net/bridge/br_ioctl.c</span>
<span class="p_header">+++ b/net/bridge/br_ioctl.c</span>
<span class="p_chunk">@@ -246,9 +246,7 @@</span> <span class="p_context"> static int old_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)</span>
 		if (!capable(CAP_NET_ADMIN))
 			return -EPERM;
 
<span class="p_del">-		spin_lock_bh(&amp;br-&gt;lock);</span>
 		br_stp_set_bridge_priority(br, args[1]);
<span class="p_del">-		spin_unlock_bh(&amp;br-&gt;lock);</span>
 		return 0;
 
 	case BRCTL_SET_PORT_PRIORITY:
<span class="p_header">diff --git a/net/bridge/br_multicast.c b/net/bridge/br_multicast.c</span>
<span class="p_header">index 398a297..1bd197f 100644</span>
<span class="p_header">--- a/net/bridge/br_multicast.c</span>
<span class="p_header">+++ b/net/bridge/br_multicast.c</span>
<span class="p_chunk">@@ -972,7 +972,7 @@</span> <span class="p_context"> static int br_ip6_multicast_mld2_report(struct net_bridge *br,</span>
 		}
 
 		err = br_ip6_multicast_add_group(br, port, &amp;grec-&gt;grec_mca);
<span class="p_del">-		if (!err)</span>
<span class="p_add">+		if (err)</span>
 			break;
 	}
 
<span class="p_chunk">@@ -991,6 +991,9 @@</span> <span class="p_context"> static void br_multicast_add_router(struct net_bridge *br,</span>
 	struct net_bridge_port *p;
 	struct hlist_node *n, *slot = NULL;
 
<span class="p_add">+	if (!hlist_unhashed(&amp;port-&gt;rlist))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	hlist_for_each_entry(p, n, &amp;br-&gt;router_list, rlist) {
 		if ((unsigned long) port &gt;= (unsigned long) p)
 			break;
<span class="p_chunk">@@ -1018,12 +1021,8 @@</span> <span class="p_context"> static void br_multicast_mark_router(struct net_bridge *br,</span>
 	if (port-&gt;multicast_router != 1)
 		return;
 
<span class="p_del">-	if (!hlist_unhashed(&amp;port-&gt;rlist))</span>
<span class="p_del">-		goto timer;</span>
<span class="p_del">-</span>
 	br_multicast_add_router(br, port);
 
<span class="p_del">-timer:</span>
 	mod_timer(&amp;port-&gt;multicast_router_timer,
 		  now + br-&gt;multicast_querier_interval);
 }
<span class="p_header">diff --git a/net/bridge/br_stp_if.c b/net/bridge/br_stp_if.c</span>
<span class="p_header">index 19308e3..0f7dc60 100644</span>
<span class="p_header">--- a/net/bridge/br_stp_if.c</span>
<span class="p_header">+++ b/net/bridge/br_stp_if.c</span>
<span class="p_chunk">@@ -235,12 +235,13 @@</span> <span class="p_context"> bool br_stp_recalculate_bridge_id(struct net_bridge *br)</span>
 	return true;
 }
 
<span class="p_del">-/* called under bridge lock */</span>
<span class="p_add">+/* Acquires and releases bridge lock */</span>
 void br_stp_set_bridge_priority(struct net_bridge *br, u16 newprio)
 {
 	struct net_bridge_port *p;
 	int wasroot;
 
<span class="p_add">+	spin_lock_bh(&amp;br-&gt;lock);</span>
 	wasroot = br_is_root_bridge(br);
 
 	list_for_each_entry(p, &amp;br-&gt;port_list, list) {
<span class="p_chunk">@@ -258,6 +259,7 @@</span> <span class="p_context"> void br_stp_set_bridge_priority(struct net_bridge *br, u16 newprio)</span>
 	br_port_state_selection(br);
 	if (br_is_root_bridge(br) &amp;&amp; !wasroot)
 		br_become_root_bridge(br);
<span class="p_add">+	spin_unlock_bh(&amp;br-&gt;lock);</span>
 }
 
 /* called under bridge lock */
<span class="p_header">diff --git a/net/caif/caif_socket.c b/net/caif/caif_socket.c</span>
<span class="p_header">index 7eed9eb..7e4b4b4 100644</span>
<span class="p_header">--- a/net/caif/caif_socket.c</span>
<span class="p_header">+++ b/net/caif/caif_socket.c</span>
<span class="p_chunk">@@ -366,6 +366,10 @@</span> <span class="p_context"> static long caif_stream_data_wait(struct sock *sk, long timeo)</span>
 		release_sock(sk);
 		timeo = schedule_timeout(timeo);
 		lock_sock(sk);
<span class="p_add">+</span>
<span class="p_add">+		if (sock_flag(sk, SOCK_DEAD))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
 		clear_bit(SOCK_ASYNC_WAITDATA, &amp;sk-&gt;sk_socket-&gt;flags);
 	}
 
<span class="p_chunk">@@ -410,6 +414,10 @@</span> <span class="p_context"> static int caif_stream_recvmsg(struct kiocb *iocb, struct socket *sock,</span>
 		struct sk_buff *skb;
 
 		lock_sock(sk);
<span class="p_add">+		if (sock_flag(sk, SOCK_DEAD)) {</span>
<span class="p_add">+			err = -ECONNRESET;</span>
<span class="p_add">+			goto unlock;</span>
<span class="p_add">+		}</span>
 		skb = skb_dequeue(&amp;sk-&gt;sk_receive_queue);
 		caif_check_flow_release(sk);
 
<span class="p_header">diff --git a/net/core/neighbour.c b/net/core/neighbour.c</span>
<span class="p_header">index 0ea3fd3..c8c2645 100644</span>
<span class="p_header">--- a/net/core/neighbour.c</span>
<span class="p_header">+++ b/net/core/neighbour.c</span>
<span class="p_chunk">@@ -955,6 +955,8 @@</span> <span class="p_context"> int __neigh_event_send(struct neighbour *neigh, struct sk_buff *skb)</span>
 	rc = 0;
 	if (neigh-&gt;nud_state &amp; (NUD_CONNECTED | NUD_DELAY | NUD_PROBE))
 		goto out_unlock_bh;
<span class="p_add">+	if (neigh-&gt;dead)</span>
<span class="p_add">+		goto out_dead;</span>
 
 	if (!(neigh-&gt;nud_state &amp; (NUD_STALE | NUD_INCOMPLETE))) {
 		if (neigh-&gt;parms-&gt;mcast_probes + neigh-&gt;parms-&gt;app_probes) {
<span class="p_chunk">@@ -1003,6 +1005,13 @@</span> <span class="p_context"> out_unlock_bh:</span>
 		write_unlock(&amp;neigh-&gt;lock);
 	local_bh_enable();
 	return rc;
<span class="p_add">+</span>
<span class="p_add">+out_dead:</span>
<span class="p_add">+	if (neigh-&gt;nud_state &amp; NUD_STALE)</span>
<span class="p_add">+		goto out_unlock_bh;</span>
<span class="p_add">+	write_unlock_bh(&amp;neigh-&gt;lock);</span>
<span class="p_add">+	kfree_skb(skb);</span>
<span class="p_add">+	return 1;</span>
 }
 EXPORT_SYMBOL(__neigh_event_send);
 
<span class="p_chunk">@@ -1066,6 +1075,8 @@</span> <span class="p_context"> int neigh_update(struct neighbour *neigh, const u8 *lladdr, u8 new,</span>
 	if (!(flags &amp; NEIGH_UPDATE_F_ADMIN) &amp;&amp;
 	    (old &amp; (NUD_NOARP | NUD_PERMANENT)))
 		goto out;
<span class="p_add">+	if (neigh-&gt;dead)</span>
<span class="p_add">+		goto out;</span>
 
 	if (!(new &amp; NUD_VALID)) {
 		neigh_del_timer(neigh);
<span class="p_header">diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c</span>
<span class="p_header">index 8c2e259..5e92043 100644</span>
<span class="p_header">--- a/net/ipv4/udp.c</span>
<span class="p_header">+++ b/net/ipv4/udp.c</span>
<span class="p_chunk">@@ -1248,10 +1248,8 @@</span> <span class="p_context"> csum_copy_err:</span>
 		UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_INERRORS, is_udplite);
 	unlock_sock_fast(sk, slow);
 
<span class="p_del">-	if (noblock)</span>
<span class="p_del">-		return -EAGAIN;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* starting over for a new packet */</span>
<span class="p_add">+	/* starting over for a new packet, but check if we need to yield */</span>
<span class="p_add">+	cond_resched();</span>
 	msg-&gt;msg_flags &amp;= ~MSG_TRUNC;
 	goto try_again;
 }
<span class="p_header">diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c</span>
<span class="p_header">index d131a95..dc08afd 100644</span>
<span class="p_header">--- a/net/ipv6/udp.c</span>
<span class="p_header">+++ b/net/ipv6/udp.c</span>
<span class="p_chunk">@@ -451,10 +451,8 @@</span> <span class="p_context"> csum_copy_err:</span>
 	}
 	unlock_sock_fast(sk, slow);
 
<span class="p_del">-	if (noblock)</span>
<span class="p_del">-		return -EAGAIN;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* starting over for a new packet */</span>
<span class="p_add">+	/* starting over for a new packet, but check if we need to yield */</span>
<span class="p_add">+	cond_resched();</span>
 	msg-&gt;msg_flags &amp;= ~MSG_TRUNC;
 	goto try_again;
 }
<span class="p_header">diff --git a/net/mac80211/wep.c b/net/mac80211/wep.c</span>
<span class="p_header">index a1c6bfd..34583c5 100644</span>
<span class="p_header">--- a/net/mac80211/wep.c</span>
<span class="p_header">+++ b/net/mac80211/wep.c</span>
<span class="p_chunk">@@ -97,8 +97,7 @@</span> <span class="p_context"> static u8 *ieee80211_wep_add_iv(struct ieee80211_local *local,</span>
 
 	hdr-&gt;frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);
 
<span class="p_del">-	if (WARN_ON(skb_tailroom(skb) &lt; WEP_ICV_LEN ||</span>
<span class="p_del">-		    skb_headroom(skb) &lt; WEP_IV_LEN))</span>
<span class="p_add">+	if (WARN_ON(skb_headroom(skb) &lt; WEP_IV_LEN))</span>
 		return NULL;
 
 	hdrlen = ieee80211_hdrlen(hdr-&gt;frame_control);
<span class="p_chunk">@@ -160,6 +159,9 @@</span> <span class="p_context"> int ieee80211_wep_encrypt(struct ieee80211_local *local,</span>
 	size_t len;
 	u8 rc4key[3 + WLAN_KEY_LEN_WEP104];
 
<span class="p_add">+	if (WARN_ON(skb_tailroom(skb) &lt; WEP_ICV_LEN))</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+</span>
 	iv = ieee80211_wep_add_iv(local, skb, keylen, keyidx);
 	if (!iv)
 		return -1;
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_core.c b/net/netfilter/ipvs/ip_vs_core.c</span>
<span class="p_header">index d864aaf..197ed93 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_core.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_core.c</span>
<span class="p_chunk">@@ -2003,10 +2003,18 @@</span> <span class="p_context"> static int __init ip_vs_init(void)</span>
 		goto cleanup_dev;
 	}
 
<span class="p_add">+	ret = ip_vs_register_nl_ioctl();</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		pr_err(&quot;can&#39;t register netlink/ioctl.\n&quot;);</span>
<span class="p_add">+		goto cleanup_hooks;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	pr_info(&quot;ipvs loaded.\n&quot;);
 
 	return ret;
 
<span class="p_add">+cleanup_hooks:</span>
<span class="p_add">+	nf_unregister_hooks(ip_vs_ops, ARRAY_SIZE(ip_vs_ops));</span>
 cleanup_dev:
 	unregister_pernet_device(&amp;ipvs_core_dev_ops);
 cleanup_sub:
<span class="p_chunk">@@ -2022,6 +2030,7 @@</span> <span class="p_context"> exit:</span>
 
 static void __exit ip_vs_cleanup(void)
 {
<span class="p_add">+	ip_vs_unregister_nl_ioctl();</span>
 	nf_unregister_hooks(ip_vs_ops, ARRAY_SIZE(ip_vs_ops));
 	unregister_pernet_device(&amp;ipvs_core_dev_ops);
 	unregister_pernet_subsys(&amp;ipvs_core_ops);	/* free ip_vs struct */
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_ctl.c b/net/netfilter/ipvs/ip_vs_ctl.c</span>
<span class="p_header">index 93acfa1..1e27a1f 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_ctl.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_ctl.c</span>
<span class="p_chunk">@@ -3689,6 +3689,9 @@</span> <span class="p_context"> void __net_init ip_vs_control_net_cleanup_sysctl(struct net *net)</span>
 	cancel_work_sync(&amp;ipvs-&gt;defense_work.work);
 	unregister_net_sysctl_table(ipvs-&gt;sysctl_hdr);
 	ip_vs_stop_estimator(net, &amp;ipvs-&gt;tot_stats);
<span class="p_add">+</span>
<span class="p_add">+	if (!net_eq(net, &amp;init_net))</span>
<span class="p_add">+		kfree(ipvs-&gt;sysctl_tbl);</span>
 }
 
 #else
<span class="p_chunk">@@ -3751,21 +3754,10 @@</span> <span class="p_context"> void __net_exit ip_vs_control_net_cleanup(struct net *net)</span>
 	free_percpu(ipvs-&gt;tot_stats.cpustats);
 }
 
<span class="p_del">-int __init ip_vs_control_init(void)</span>
<span class="p_add">+int __init ip_vs_register_nl_ioctl(void)</span>
 {
<span class="p_del">-	int idx;</span>
 	int ret;
 
<span class="p_del">-	EnterFunction(2);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Initialize svc_table, ip_vs_svc_fwm_table, rs_table */</span>
<span class="p_del">-	for(idx = 0; idx &lt; IP_VS_SVC_TAB_SIZE; idx++)  {</span>
<span class="p_del">-		INIT_LIST_HEAD(&amp;ip_vs_svc_table[idx]);</span>
<span class="p_del">-		INIT_LIST_HEAD(&amp;ip_vs_svc_fwm_table[idx]);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	smp_wmb();	/* Do we really need it now ? */</span>
<span class="p_del">-</span>
 	ret = nf_register_sockopt(&amp;ip_vs_sockopts);
 	if (ret) {
 		pr_err(&quot;cannot register sockopt.\n&quot;);
<span class="p_chunk">@@ -3777,28 +3769,47 @@</span> <span class="p_context"> int __init ip_vs_control_init(void)</span>
 		pr_err(&quot;cannot register Generic Netlink interface.\n&quot;);
 		goto err_genl;
 	}
<span class="p_del">-</span>
<span class="p_del">-	ret = register_netdevice_notifier(&amp;ip_vs_dst_notifier);</span>
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_del">-		goto err_notf;</span>
<span class="p_del">-</span>
<span class="p_del">-	LeaveFunction(2);</span>
 	return 0;
 
<span class="p_del">-err_notf:</span>
<span class="p_del">-	ip_vs_genl_unregister();</span>
 err_genl:
 	nf_unregister_sockopt(&amp;ip_vs_sockopts);
 err_sock:
 	return ret;
 }
 
<span class="p_add">+void ip_vs_unregister_nl_ioctl(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	ip_vs_genl_unregister();</span>
<span class="p_add">+	nf_unregister_sockopt(&amp;ip_vs_sockopts);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int __init ip_vs_control_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int idx;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	EnterFunction(2);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Initialize svc_table, ip_vs_svc_fwm_table, rs_table */</span>
<span class="p_add">+	for (idx = 0; idx &lt; IP_VS_SVC_TAB_SIZE; idx++) {</span>
<span class="p_add">+		INIT_LIST_HEAD(&amp;ip_vs_svc_table[idx]);</span>
<span class="p_add">+		INIT_LIST_HEAD(&amp;ip_vs_svc_fwm_table[idx]);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	smp_wmb();	/* Do we really need it now ? */</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = register_netdevice_notifier(&amp;ip_vs_dst_notifier);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	LeaveFunction(2);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 
 void ip_vs_control_cleanup(void)
 {
 	EnterFunction(2);
 	unregister_netdevice_notifier(&amp;ip_vs_dst_notifier);
<span class="p_del">-	ip_vs_genl_unregister();</span>
<span class="p_del">-	nf_unregister_sockopt(&amp;ip_vs_sockopts);</span>
 	LeaveFunction(2);
 }
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index 4f19bf2..0c21f06 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -1170,16 +1170,6 @@</span> <span class="p_context"> static void packet_sock_destruct(struct sock *sk)</span>
 	sk_refcnt_debug_dec(sk);
 }
 
<span class="p_del">-static int fanout_rr_next(struct packet_fanout *f, unsigned int num)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int x = atomic_read(&amp;f-&gt;rr_cur) + 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (x &gt;= num)</span>
<span class="p_del">-		x = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	return x;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static struct sock *fanout_demux_hash(struct packet_fanout *f, struct sk_buff *skb, unsigned int num)
 {
 	u32 idx, hash = skb-&gt;rxhash;
<span class="p_chunk">@@ -1191,13 +1181,9 @@</span> <span class="p_context"> static struct sock *fanout_demux_hash(struct packet_fanout *f, struct sk_buff *s</span>
 
 static struct sock *fanout_demux_lb(struct packet_fanout *f, struct sk_buff *skb, unsigned int num)
 {
<span class="p_del">-	int cur, old;</span>
<span class="p_add">+	unsigned int val = atomic_inc_return(&amp;f-&gt;rr_cur);</span>
 
<span class="p_del">-	cur = atomic_read(&amp;f-&gt;rr_cur);</span>
<span class="p_del">-	while ((old = atomic_cmpxchg(&amp;f-&gt;rr_cur, cur,</span>
<span class="p_del">-				     fanout_rr_next(f, num))) != cur)</span>
<span class="p_del">-		cur = old;</span>
<span class="p_del">-	return f-&gt;arr[cur];</span>
<span class="p_add">+	return f-&gt;arr[val % num];</span>
 }
 
 static struct sock *fanout_demux_cpu(struct packet_fanout *f, struct sk_buff *skb, unsigned int num)
<span class="p_chunk">@@ -1211,7 +1197,7 @@</span> <span class="p_context"> static int packet_rcv_fanout(struct sk_buff *skb, struct net_device *dev,</span>
 			     struct packet_type *pt, struct net_device *orig_dev)
 {
 	struct packet_fanout *f = pt-&gt;af_packet_priv;
<span class="p_del">-	unsigned int num = f-&gt;num_members;</span>
<span class="p_add">+	unsigned int num = ACCESS_ONCE(f-&gt;num_members);</span>
 	struct packet_sock *po;
 	struct sock *sk;
 
<span class="p_header">diff --git a/net/sctp/output.c b/net/sctp/output.c</span>
<span class="p_header">index c3b8549..6d56eec 100644</span>
<span class="p_header">--- a/net/sctp/output.c</span>
<span class="p_header">+++ b/net/sctp/output.c</span>
<span class="p_chunk">@@ -587,7 +587,9 @@</span> <span class="p_context"> out:</span>
 	return err;
 no_route:
 	kfree_skb(nskb);
<span class="p_del">-	IP_INC_STATS(&amp;init_net, IPSTATS_MIB_OUTNOROUTES);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (asoc)</span>
<span class="p_add">+		IP_INC_STATS(&amp;init_net, IPSTATS_MIB_OUTNOROUTES);</span>
 
 	/* FIXME: Returning the &#39;err&#39; will effect all the associations
 	 * associated with a socket, although only one of the paths of the
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index fc63664..24e88af 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -1539,8 +1539,10 @@</span> <span class="p_context"> SCTP_STATIC void sctp_close(struct sock *sk, long timeout)</span>
 
 	/* Supposedly, no process has access to the socket, but
 	 * the net layers still may.
<span class="p_add">+	 * Also, sctp_destroy_sock() needs to be called with addr_wq_lock</span>
<span class="p_add">+	 * held and that should be grabbed before socket lock.</span>
 	 */
<span class="p_del">-	sctp_local_bh_disable();</span>
<span class="p_add">+	spin_lock_bh(&amp;sctp_globals.addr_wq_lock);</span>
 	sctp_bh_lock_sock(sk);
 
 	/* Hold the sock, since sk_common_release() will put sock_put()
<span class="p_chunk">@@ -1550,7 +1552,7 @@</span> <span class="p_context"> SCTP_STATIC void sctp_close(struct sock *sk, long timeout)</span>
 	sk_common_release(sk);
 
 	sctp_bh_unlock_sock(sk);
<span class="p_del">-	sctp_local_bh_enable();</span>
<span class="p_add">+	spin_unlock_bh(&amp;sctp_globals.addr_wq_lock);</span>
 
 	sock_put(sk);
 
<span class="p_chunk">@@ -3499,6 +3501,7 @@</span> <span class="p_context"> static int sctp_setsockopt_auto_asconf(struct sock *sk, char __user *optval,</span>
 	if ((val &amp;&amp; sp-&gt;do_auto_asconf) || (!val &amp;&amp; !sp-&gt;do_auto_asconf))
 		return 0;
 
<span class="p_add">+	spin_lock_bh(&amp;sctp_globals.addr_wq_lock);</span>
 	if (val == 0 &amp;&amp; sp-&gt;do_auto_asconf) {
 		list_del(&amp;sp-&gt;auto_asconf_list);
 		sp-&gt;do_auto_asconf = 0;
<span class="p_chunk">@@ -3507,6 +3510,7 @@</span> <span class="p_context"> static int sctp_setsockopt_auto_asconf(struct sock *sk, char __user *optval,</span>
 		    &amp;sctp_auto_asconf_splist);
 		sp-&gt;do_auto_asconf = 1;
 	}
<span class="p_add">+	spin_unlock_bh(&amp;sctp_globals.addr_wq_lock);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -3942,18 +3946,28 @@</span> <span class="p_context"> SCTP_STATIC int sctp_init_sock(struct sock *sk)</span>
 	local_bh_disable();
 	percpu_counter_inc(&amp;sctp_sockets_allocated);
 	sock_prot_inuse_add(sock_net(sk), sk-&gt;sk_prot, 1);
<span class="p_add">+</span>
<span class="p_add">+	/* Nothing can fail after this block, otherwise</span>
<span class="p_add">+	 * sctp_destroy_sock() will be called without addr_wq_lock held</span>
<span class="p_add">+	 */</span>
 	if (sctp_default_auto_asconf) {
<span class="p_add">+		spin_lock(&amp;sctp_globals.addr_wq_lock);</span>
 		list_add_tail(&amp;sp-&gt;auto_asconf_list,
 		    &amp;sctp_auto_asconf_splist);
 		sp-&gt;do_auto_asconf = 1;
<span class="p_del">-	} else</span>
<span class="p_add">+		spin_unlock(&amp;sctp_globals.addr_wq_lock);</span>
<span class="p_add">+	} else {</span>
 		sp-&gt;do_auto_asconf = 0;
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	local_bh_enable();
 
 	return 0;
 }
 
<span class="p_del">-/* Cleanup any SCTP per socket resources.  */</span>
<span class="p_add">+/* Cleanup any SCTP per socket resources. Must be called with</span>
<span class="p_add">+ * sctp_globals.addr_wq_lock held if sp-&gt;do_auto_asconf is true</span>
<span class="p_add">+ */</span>
 SCTP_STATIC void sctp_destroy_sock(struct sock *sk)
 {
 	struct sctp_sock *sp;
<span class="p_chunk">@@ -6719,6 +6733,19 @@</span> <span class="p_context"> void sctp_copy_sock(struct sock *newsk, struct sock *sk,</span>
 	newinet-&gt;mc_list = NULL;
 }
 
<span class="p_add">+static inline void sctp_copy_descendant(struct sock *sk_to,</span>
<span class="p_add">+					const struct sock *sk_from)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ancestor_size = sizeof(struct inet_sock) +</span>
<span class="p_add">+			    sizeof(struct sctp_sock) -</span>
<span class="p_add">+			    offsetof(struct sctp_sock, auto_asconf_list);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (sk_from-&gt;sk_family == PF_INET6)</span>
<span class="p_add">+		ancestor_size += sizeof(struct ipv6_pinfo);</span>
<span class="p_add">+</span>
<span class="p_add">+	__inet_sk_copy_descendant(sk_to, sk_from, ancestor_size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Populate the fields of the newsk from the oldsk and migrate the assoc
  * and its messages to the newsk.
  */
<span class="p_chunk">@@ -6733,7 +6760,6 @@</span> <span class="p_context"> static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,</span>
 	struct sk_buff *skb, *tmp;
 	struct sctp_ulpevent *event;
 	struct sctp_bind_hashbucket *head;
<span class="p_del">-	struct list_head tmplist;</span>
 
 	/* Migrate socket buffer sizes and all the socket level options to the
 	 * new socket.
<span class="p_chunk">@@ -6741,12 +6767,7 @@</span> <span class="p_context"> static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,</span>
 	newsk-&gt;sk_sndbuf = oldsk-&gt;sk_sndbuf;
 	newsk-&gt;sk_rcvbuf = oldsk-&gt;sk_rcvbuf;
 	/* Brute force copy old sctp opt. */
<span class="p_del">-	if (oldsp-&gt;do_auto_asconf) {</span>
<span class="p_del">-		memcpy(&amp;tmplist, &amp;newsp-&gt;auto_asconf_list, sizeof(tmplist));</span>
<span class="p_del">-		inet_sk_copy_descendant(newsk, oldsk);</span>
<span class="p_del">-		memcpy(&amp;newsp-&gt;auto_asconf_list, &amp;tmplist, sizeof(tmplist));</span>
<span class="p_del">-	} else</span>
<span class="p_del">-		inet_sk_copy_descendant(newsk, oldsk);</span>
<span class="p_add">+	sctp_copy_descendant(newsk, oldsk);</span>
 
 	/* Restore the ep value that was overwritten with the above structure
 	 * copy.
<span class="p_header">diff --git a/net/socket.c b/net/socket.c</span>
<span class="p_header">index 116cf9d..10ea25a 100644</span>
<span class="p_header">--- a/net/socket.c</span>
<span class="p_header">+++ b/net/socket.c</span>
<span class="p_chunk">@@ -1911,14 +1911,12 @@</span> <span class="p_context"> static int ___sys_sendmsg(struct socket *sock, struct msghdr __user *msg,</span>
 	int err, ctl_len, iov_size, total_len;
 
 	err = -EFAULT;
<span class="p_del">-	if (MSG_CMSG_COMPAT &amp; flags) {</span>
<span class="p_del">-		if (get_compat_msghdr(msg_sys, msg_compat))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-	} else {</span>
<span class="p_add">+	if (MSG_CMSG_COMPAT &amp; flags)</span>
<span class="p_add">+		err = get_compat_msghdr(msg_sys, msg_compat);</span>
<span class="p_add">+	else</span>
 		err = copy_msghdr_from_user(msg_sys, msg);
<span class="p_del">-		if (err)</span>
<span class="p_del">-			return err;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
 
 	/* do not move before msg_sys is valid */
 	err = -EMSGSIZE;
<span class="p_chunk">@@ -2130,14 +2128,12 @@</span> <span class="p_context"> static int ___sys_recvmsg(struct socket *sock, struct msghdr __user *msg,</span>
 	struct sockaddr __user *uaddr;
 	int __user *uaddr_len;
 
<span class="p_del">-	if (MSG_CMSG_COMPAT &amp; flags) {</span>
<span class="p_del">-		if (get_compat_msghdr(msg_sys, msg_compat))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-	} else {</span>
<span class="p_add">+	if (MSG_CMSG_COMPAT &amp; flags)</span>
<span class="p_add">+		err = get_compat_msghdr(msg_sys, msg_compat);</span>
<span class="p_add">+	else</span>
 		err = copy_msghdr_from_user(msg_sys, msg);
<span class="p_del">-		if (err)</span>
<span class="p_del">-			return err;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
 
 	err = -EMSGSIZE;
 	if (msg_sys-&gt;msg_iovlen &gt; UIO_MAXIOV)
<span class="p_header">diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c</span>
<span class="p_header">index 8705ee3..9b1f371 100644</span>
<span class="p_header">--- a/net/unix/af_unix.c</span>
<span class="p_header">+++ b/net/unix/af_unix.c</span>
<span class="p_chunk">@@ -1870,6 +1870,10 @@</span> <span class="p_context"> static long unix_stream_data_wait(struct sock *sk, long timeo)</span>
 		unix_state_unlock(sk);
 		timeo = schedule_timeout(timeo);
 		unix_state_lock(sk);
<span class="p_add">+</span>
<span class="p_add">+		if (sock_flag(sk, SOCK_DEAD))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
 		clear_bit(SOCK_ASYNC_WAITDATA, &amp;sk-&gt;sk_socket-&gt;flags);
 	}
 
<span class="p_chunk">@@ -1930,6 +1934,10 @@</span> <span class="p_context"> static int unix_stream_recvmsg(struct kiocb *iocb, struct socket *sock,</span>
 		struct sk_buff *skb;
 
 		unix_state_lock(sk);
<span class="p_add">+		if (sock_flag(sk, SOCK_DEAD)) {</span>
<span class="p_add">+			err = -ECONNRESET;</span>
<span class="p_add">+			goto unlock;</span>
<span class="p_add">+		}</span>
 		skb = skb_peek(&amp;sk-&gt;sk_receive_queue);
 		if (skb == NULL) {
 			unix_sk(sk)-&gt;recursion_level = 0;
<span class="p_header">diff --git a/security/selinux/nlmsgtab.c b/security/selinux/nlmsgtab.c</span>
<span class="p_header">index 0920ea3..5776921 100644</span>
<span class="p_header">--- a/security/selinux/nlmsgtab.c</span>
<span class="p_header">+++ b/security/selinux/nlmsgtab.c</span>
<span class="p_chunk">@@ -100,6 +100,12 @@</span> <span class="p_context"> static struct nlmsg_perm nlmsg_xfrm_perms[] =</span>
 	{ XFRM_MSG_FLUSHPOLICY,	NETLINK_XFRM_SOCKET__NLMSG_WRITE },
 	{ XFRM_MSG_NEWAE,	NETLINK_XFRM_SOCKET__NLMSG_WRITE },
 	{ XFRM_MSG_GETAE,	NETLINK_XFRM_SOCKET__NLMSG_READ  },
<span class="p_add">+	{ XFRM_MSG_REPORT,	NETLINK_XFRM_SOCKET__NLMSG_READ  },</span>
<span class="p_add">+	{ XFRM_MSG_MIGRATE,	NETLINK_XFRM_SOCKET__NLMSG_WRITE },</span>
<span class="p_add">+	{ XFRM_MSG_NEWSADINFO,	NETLINK_XFRM_SOCKET__NLMSG_READ  },</span>
<span class="p_add">+	{ XFRM_MSG_GETSADINFO,	NETLINK_XFRM_SOCKET__NLMSG_READ  },</span>
<span class="p_add">+	{ XFRM_MSG_GETSPDINFO,	NETLINK_XFRM_SOCKET__NLMSG_READ  },</span>
<span class="p_add">+	{ XFRM_MSG_MAPPING,	NETLINK_XFRM_SOCKET__NLMSG_READ  },</span>
 };
 
 static struct nlmsg_perm nlmsg_audit_perms[] =
<span class="p_header">diff --git a/sound/pci/emu10k1/emu10k1.c b/sound/pci/emu10k1/emu10k1.c</span>
<span class="p_header">index eaa198e..f33e3cc 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emu10k1.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emu10k1.c</span>
<span class="p_chunk">@@ -181,8 +181,10 @@</span> <span class="p_context"> static int __devinit snd_card_emu10k1_probe(struct pci_dev *pci,</span>
 	}
 #endif
  
<span class="p_del">-	strcpy(card-&gt;driver, emu-&gt;card_capabilities-&gt;driver);</span>
<span class="p_del">-	strcpy(card-&gt;shortname, emu-&gt;card_capabilities-&gt;name);</span>
<span class="p_add">+	strlcpy(card-&gt;driver, emu-&gt;card_capabilities-&gt;driver,</span>
<span class="p_add">+		sizeof(card-&gt;driver));</span>
<span class="p_add">+	strlcpy(card-&gt;shortname, emu-&gt;card_capabilities-&gt;name,</span>
<span class="p_add">+		sizeof(card-&gt;shortname));</span>
 	snprintf(card-&gt;longname, sizeof(card-&gt;longname),
 		 &quot;%s (rev.%d, serial:0x%x) at 0x%lx, irq %i&quot;,
 		 card-&gt;shortname, emu-&gt;revision, emu-&gt;serial, emu-&gt;port, emu-&gt;irq);
<span class="p_header">diff --git a/sound/pci/emu10k1/emu10k1_callback.c b/sound/pci/emu10k1/emu10k1_callback.c</span>
<span class="p_header">index f35284b..8295950 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emu10k1_callback.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emu10k1_callback.c</span>
<span class="p_chunk">@@ -415,7 +415,7 @@</span> <span class="p_context"> start_voice(struct snd_emux_voice *vp)</span>
 	snd_emu10k1_ptr_write(hw, Z2, ch, 0);
 
 	/* invalidate maps */
<span class="p_del">-	temp = (hw-&gt;silent_page.addr &lt;&lt; 1) | MAP_PTI_MASK;</span>
<span class="p_add">+	temp = (hw-&gt;silent_page.addr &lt;&lt; hw-&gt;address_mode) | (hw-&gt;address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);</span>
 	snd_emu10k1_ptr_write(hw, MAPA, ch, temp);
 	snd_emu10k1_ptr_write(hw, MAPB, ch, temp);
 #if 0
<span class="p_chunk">@@ -436,7 +436,7 @@</span> <span class="p_context"> start_voice(struct snd_emux_voice *vp)</span>
 		snd_emu10k1_ptr_write(hw, CDF, ch, sample);
 
 		/* invalidate maps */
<span class="p_del">-		temp = ((unsigned int)hw-&gt;silent_page.addr &lt;&lt; 1) | MAP_PTI_MASK;</span>
<span class="p_add">+		temp = ((unsigned int)hw-&gt;silent_page.addr &lt;&lt; hw_address_mode) | (hw-&gt;address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);</span>
 		snd_emu10k1_ptr_write(hw, MAPA, ch, temp);
 		snd_emu10k1_ptr_write(hw, MAPB, ch, temp);
 		
<span class="p_header">diff --git a/sound/pci/emu10k1/emu10k1_main.c b/sound/pci/emu10k1/emu10k1_main.c</span>
<span class="p_header">index d37b946..705e73e 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emu10k1_main.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emu10k1_main.c</span>
<span class="p_chunk">@@ -282,7 +282,7 @@</span> <span class="p_context"> static int snd_emu10k1_init(struct snd_emu10k1 *emu, int enable_ir, int resume)</span>
 	snd_emu10k1_ptr_write(emu, TCB, 0, 0);	/* taken from original driver */
 	snd_emu10k1_ptr_write(emu, TCBS, 0, 4);	/* taken from original driver */
 
<span class="p_del">-	silent_page = (emu-&gt;silent_page.addr &lt;&lt; 1) | MAP_PTI_MASK;</span>
<span class="p_add">+	silent_page = (emu-&gt;silent_page.addr &lt;&lt; emu-&gt;address_mode) | (emu-&gt;address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);</span>
 	for (ch = 0; ch &lt; NUM_G; ch++) {
 		snd_emu10k1_ptr_write(emu, MAPA, ch, silent_page);
 		snd_emu10k1_ptr_write(emu, MAPB, ch, silent_page);
<span class="p_chunk">@@ -348,6 +348,11 @@</span> <span class="p_context"> static int snd_emu10k1_init(struct snd_emu10k1 *emu, int enable_ir, int resume)</span>
 		outl(reg | A_IOCFG_GPOUT0, emu-&gt;port + A_IOCFG);
 	}
 
<span class="p_add">+	if (emu-&gt;address_mode == 0) {</span>
<span class="p_add">+		/* use 16M in 4G */</span>
<span class="p_add">+		outl(inl(emu-&gt;port + HCFG) | HCFG_EXPANDED_MEM, emu-&gt;port + HCFG);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1390,7 +1395,7 @@</span> <span class="p_context"> static struct snd_emu_chip_details emu_chip_details[] = {</span>
 	 *
 	 */
 	{.vendor = 0x1102, .device = 0x0008, .subsystem = 0x20011102,
<span class="p_del">-	 .driver = &quot;Audigy2&quot;, .name = &quot;SB Audigy 2 ZS Notebook [SB0530]&quot;,</span>
<span class="p_add">+	 .driver = &quot;Audigy2&quot;, .name = &quot;Audigy 2 ZS Notebook [SB0530]&quot;,</span>
 	 .id = &quot;Audigy2&quot;,
 	 .emu10k2_chip = 1,
 	 .ca0108_chip = 1,
<span class="p_chunk">@@ -1528,7 +1533,7 @@</span> <span class="p_context"> static struct snd_emu_chip_details emu_chip_details[] = {</span>
 	 .adc_1361t = 1,  /* 24 bit capture instead of 16bit */
 	 .ac97_chip = 1} ,
 	{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x10051102,
<span class="p_del">-	 .driver = &quot;Audigy2&quot;, .name = &quot;SB Audigy 2 Platinum EX [SB0280]&quot;,</span>
<span class="p_add">+	 .driver = &quot;Audigy2&quot;, .name = &quot;Audigy 2 Platinum EX [SB0280]&quot;,</span>
 	 .id = &quot;Audigy2&quot;,
 	 .emu10k2_chip = 1,
 	 .ca0102_chip = 1,
<span class="p_chunk">@@ -1832,8 +1837,10 @@</span> <span class="p_context"> int __devinit snd_emu10k1_create(struct snd_card *card,</span>
 
 	is_audigy = emu-&gt;audigy = c-&gt;emu10k2_chip;
 
<span class="p_add">+	/* set addressing mode */</span>
<span class="p_add">+	emu-&gt;address_mode = is_audigy ? 0 : 1;</span>
 	/* set the DMA transfer mask */
<span class="p_del">-	emu-&gt;dma_mask = is_audigy ? AUDIGY_DMA_MASK : EMU10K1_DMA_MASK;</span>
<span class="p_add">+	emu-&gt;dma_mask = emu-&gt;address_mode ? EMU10K1_DMA_MASK : AUDIGY_DMA_MASK;</span>
 	if (pci_set_dma_mask(pci, emu-&gt;dma_mask) &lt; 0 ||
 	    pci_set_consistent_dma_mask(pci, emu-&gt;dma_mask) &lt; 0) {
 		snd_printk(KERN_ERR &quot;architecture does not support PCI busmaster DMA with mask 0x%lx\n&quot;, emu-&gt;dma_mask);
<span class="p_chunk">@@ -1856,7 +1863,7 @@</span> <span class="p_context"> int __devinit snd_emu10k1_create(struct snd_card *card,</span>
 
 	emu-&gt;max_cache_pages = max_cache_bytes &gt;&gt; PAGE_SHIFT;
 	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
<span class="p_del">-				32 * 1024, &amp;emu-&gt;ptb_pages) &lt; 0) {</span>
<span class="p_add">+				(emu-&gt;address_mode ? 32 : 16) * 1024, &amp;emu-&gt;ptb_pages) &lt; 0) {</span>
 		err = -ENOMEM;
 		goto error;
 	}
<span class="p_chunk">@@ -1955,8 +1962,8 @@</span> <span class="p_context"> int __devinit snd_emu10k1_create(struct snd_card *card,</span>
 
 	/* Clear silent pages and set up pointers */
 	memset(emu-&gt;silent_page.area, 0, PAGE_SIZE);
<span class="p_del">-	silent_page = emu-&gt;silent_page.addr &lt;&lt; 1;</span>
<span class="p_del">-	for (idx = 0; idx &lt; MAXPAGES; idx++)</span>
<span class="p_add">+	silent_page = emu-&gt;silent_page.addr &lt;&lt; emu-&gt;address_mode;</span>
<span class="p_add">+	for (idx = 0; idx &lt; (emu-&gt;address_mode ? MAXPAGES1 : MAXPAGES0); idx++)</span>
 		((u32 *)emu-&gt;ptb_pages.area)[idx] = cpu_to_le32(silent_page | idx);
 
 	/* set up voice indices */
<span class="p_header">diff --git a/sound/pci/emu10k1/emupcm.c b/sound/pci/emu10k1/emupcm.c</span>
<span class="p_header">index e22b8e2..c673d2b 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emupcm.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emupcm.c</span>
<span class="p_chunk">@@ -379,7 +379,7 @@</span> <span class="p_context"> static void snd_emu10k1_pcm_init_voice(struct snd_emu10k1 *emu,</span>
 	snd_emu10k1_ptr_write(emu, Z1, voice, 0);
 	snd_emu10k1_ptr_write(emu, Z2, voice, 0);
 	/* invalidate maps */
<span class="p_del">-	silent_page = ((unsigned int)emu-&gt;silent_page.addr &lt;&lt; 1) | MAP_PTI_MASK;</span>
<span class="p_add">+	silent_page = ((unsigned int)emu-&gt;silent_page.addr &lt;&lt; emu-&gt;address_mode) | (emu-&gt;address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);</span>
 	snd_emu10k1_ptr_write(emu, MAPA, voice, silent_page);
 	snd_emu10k1_ptr_write(emu, MAPB, voice, silent_page);
 	/* modulation envelope */
<span class="p_header">diff --git a/sound/pci/emu10k1/emuproc.c b/sound/pci/emu10k1/emuproc.c</span>
<span class="p_header">index bc38dd4..9c499e6 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emuproc.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emuproc.c</span>
<span class="p_chunk">@@ -241,31 +241,22 @@</span> <span class="p_context"> static void snd_emu10k1_proc_spdif_read(struct snd_info_entry *entry,</span>
 	struct snd_emu10k1 *emu = entry-&gt;private_data;
 	u32 value;
 	u32 value2;
<span class="p_del">-	unsigned long flags;</span>
 	u32 rate;
 
 	if (emu-&gt;card_capabilities-&gt;emu_model) {
<span class="p_del">-		spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_emu1010_fpga_read(emu, 0x38, &amp;value);
<span class="p_del">-		spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 		if ((value &amp; 0x1) == 0) {
<span class="p_del">-			spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 			snd_emu1010_fpga_read(emu, 0x2a, &amp;value);
 			snd_emu1010_fpga_read(emu, 0x2b, &amp;value2);
<span class="p_del">-			spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 			rate = 0x1770000 / (((value &lt;&lt; 5) | value2)+1);	
 			snd_iprintf(buffer, &quot;ADAT Locked : %u\n&quot;, rate);
 		} else {
 			snd_iprintf(buffer, &quot;ADAT Unlocked\n&quot;);
 		}
<span class="p_del">-		spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_emu1010_fpga_read(emu, 0x20, &amp;value);
<span class="p_del">-		spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 		if ((value &amp; 0x4) == 0) {
<span class="p_del">-			spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 			snd_emu1010_fpga_read(emu, 0x28, &amp;value);
 			snd_emu1010_fpga_read(emu, 0x29, &amp;value2);
<span class="p_del">-			spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 			rate = 0x1770000 / (((value &lt;&lt; 5) | value2)+1);	
 			snd_iprintf(buffer, &quot;SPDIF Locked : %d\n&quot;, rate);
 		} else {
<span class="p_chunk">@@ -410,14 +401,11 @@</span> <span class="p_context"> static void snd_emu_proc_emu1010_reg_read(struct snd_info_entry *entry,</span>
 {
 	struct snd_emu10k1 *emu = entry-&gt;private_data;
 	u32 value;
<span class="p_del">-	unsigned long flags;</span>
 	int i;
 	snd_iprintf(buffer, &quot;EMU1010 Registers:\n\n&quot;);
 
 	for(i = 0; i &lt; 0x40; i+=1) {
<span class="p_del">-		spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_emu1010_fpga_read(emu, i, &amp;value);
<span class="p_del">-		spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_iprintf(buffer, &quot;%02X: %08X, %02X\n&quot;, i, value, (value &gt;&gt; 8) &amp; 0x7f);
 	}
 }
<span class="p_header">diff --git a/sound/pci/emu10k1/memory.c b/sound/pci/emu10k1/memory.c</span>
<span class="p_header">index 4f502a2..87b7c65 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/memory.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/memory.c</span>
<span class="p_chunk">@@ -34,10 +34,11 @@</span> <span class="p_context"></span>
  * aligned pages in others
  */
 #define __set_ptb_entry(emu,page,addr) \
<span class="p_del">-	(((u32 *)(emu)-&gt;ptb_pages.area)[page] = cpu_to_le32(((addr) &lt;&lt; 1) | (page)))</span>
<span class="p_add">+	(((u32 *)(emu)-&gt;ptb_pages.area)[page] = cpu_to_le32(((addr) &lt;&lt; (emu-&gt;address_mode)) | (page)))</span>
 
 #define UNIT_PAGES		(PAGE_SIZE / EMUPAGESIZE)
<span class="p_del">-#define MAX_ALIGN_PAGES		(MAXPAGES / UNIT_PAGES)</span>
<span class="p_add">+#define MAX_ALIGN_PAGES0		(MAXPAGES0 / UNIT_PAGES)</span>
<span class="p_add">+#define MAX_ALIGN_PAGES1		(MAXPAGES1 / UNIT_PAGES)</span>
 /* get aligned page from offset address */
 #define get_aligned_page(offset)	((offset) &gt;&gt; PAGE_SHIFT)
 /* get offset address from aligned page */
<span class="p_chunk">@@ -124,7 +125,7 @@</span> <span class="p_context"> static int search_empty_map_area(struct snd_emu10k1 *emu, int npages, struct lis</span>
 		}
 		page = blk-&gt;mapped_page + blk-&gt;pages;
 	}
<span class="p_del">-	size = MAX_ALIGN_PAGES - page;</span>
<span class="p_add">+	size = (emu-&gt;address_mode ? MAX_ALIGN_PAGES1 : MAX_ALIGN_PAGES0) - page;</span>
 	if (size &gt;= max_size) {
 		*nextp = pos;
 		return page;
<span class="p_chunk">@@ -181,7 +182,7 @@</span> <span class="p_context"> static int unmap_memblk(struct snd_emu10k1 *emu, struct snd_emu10k1_memblk *blk)</span>
 		q = get_emu10k1_memblk(p, mapped_link);
 		end_page = q-&gt;mapped_page;
 	} else
<span class="p_del">-		end_page = MAX_ALIGN_PAGES;</span>
<span class="p_add">+		end_page = (emu-&gt;address_mode ? MAX_ALIGN_PAGES1 : MAX_ALIGN_PAGES0);</span>
 
 	/* remove links */
 	list_del(&amp;blk-&gt;mapped_link);
<span class="p_chunk">@@ -305,7 +306,7 @@</span> <span class="p_context"> snd_emu10k1_alloc_pages(struct snd_emu10k1 *emu, struct snd_pcm_substream *subst</span>
 	if (snd_BUG_ON(!emu))
 		return NULL;
 	if (snd_BUG_ON(runtime-&gt;dma_bytes &lt;= 0 ||
<span class="p_del">-		       runtime-&gt;dma_bytes &gt;= MAXPAGES * EMUPAGESIZE))</span>
<span class="p_add">+		       runtime-&gt;dma_bytes &gt;= (emu-&gt;address_mode ? MAXPAGES1 : MAXPAGES0) * EMUPAGESIZE))</span>
 		return NULL;
 	hdr = emu-&gt;memhdr;
 	if (snd_BUG_ON(!hdr))
<span class="p_header">diff --git a/sound/pci/hda/patch_conexant.c b/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">index 843d9f3..6a524fb 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_conexant.c</span>
<span class="p_chunk">@@ -4598,6 +4598,14 @@</span> <span class="p_context"> static const struct hda_codec_preset snd_hda_preset_conexant[] = {</span>
 	  .patch = patch_conexant_auto },
 	{ .id = 0x14f150b9, .name = &quot;CX20665&quot;,
 	  .patch = patch_conexant_auto },
<span class="p_add">+	{ .id = 0x14f150f1, .name = &quot;CX20721&quot;,</span>
<span class="p_add">+	  .patch = patch_conexant_auto },</span>
<span class="p_add">+	{ .id = 0x14f150f2, .name = &quot;CX20722&quot;,</span>
<span class="p_add">+	  .patch = patch_conexant_auto },</span>
<span class="p_add">+	{ .id = 0x14f150f3, .name = &quot;CX20723&quot;,</span>
<span class="p_add">+	  .patch = patch_conexant_auto },</span>
<span class="p_add">+	{ .id = 0x14f150f4, .name = &quot;CX20724&quot;,</span>
<span class="p_add">+	  .patch = patch_conexant_auto },</span>
 	{ .id = 0x14f1510f, .name = &quot;CX20751/2&quot;,
 	  .patch = patch_conexant_auto },
 	{ .id = 0x14f15110, .name = &quot;CX20751/2&quot;,
<span class="p_chunk">@@ -4632,6 +4640,10 @@</span> <span class="p_context"> MODULE_ALIAS(&quot;snd-hda-codec-id:14f150ab&quot;);</span>
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f150ac&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f150b8&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f150b9&quot;);
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:14f150f1&quot;);</span>
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:14f150f2&quot;);</span>
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:14f150f3&quot;);</span>
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:14f150f4&quot;);</span>
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f1510f&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f15110&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f15111&quot;);
<span class="p_header">diff --git a/sound/soc/codecs/cs4271.c b/sound/soc/codecs/cs4271.c</span>
<span class="p_header">index 561d5e0..e99c10b 100644</span>
<span class="p_header">--- a/sound/soc/codecs/cs4271.c</span>
<span class="p_header">+++ b/sound/soc/codecs/cs4271.c</span>
<span class="p_chunk">@@ -475,10 +475,10 @@</span> <span class="p_context"> static int cs4271_probe(struct snd_soc_codec *codec)</span>
 	if (gpio_nreset &gt;= 0) {
 		/* Reset codec */
 		gpio_direction_output(gpio_nreset, 0);
<span class="p_del">-		udelay(1);</span>
<span class="p_add">+		mdelay(1);</span>
 		gpio_set_value(gpio_nreset, 1);
 		/* Give the codec time to wake up */
<span class="p_del">-		udelay(1);</span>
<span class="p_add">+		mdelay(1);</span>
 	}
 
 	cs4271-&gt;gpio_nreset = gpio_nreset;
<span class="p_header">diff --git a/sound/soc/codecs/wm8741.c b/sound/soc/codecs/wm8741.c</span>
<span class="p_header">index 57ad22a..6ab4f27 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8741.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8741.c</span>
<span class="p_chunk">@@ -117,7 +117,7 @@</span> <span class="p_context"> static struct {</span>
 };
 
 static unsigned int rates_11289[] = {
<span class="p_del">-	44100, 88235,</span>
<span class="p_add">+	44100, 88200,</span>
 };
 
 static struct snd_pcm_hw_constraint_list constraints_11289 = {
<span class="p_chunk">@@ -144,7 +144,7 @@</span> <span class="p_context"> static struct snd_pcm_hw_constraint_list constraints_16384 = {</span>
 };
 
 static unsigned int rates_16934[] = {
<span class="p_del">-	44100, 88235,</span>
<span class="p_add">+	44100, 88200,</span>
 };
 
 static struct snd_pcm_hw_constraint_list constraints_16934 = {
<span class="p_chunk">@@ -162,7 +162,7 @@</span> <span class="p_context"> static struct snd_pcm_hw_constraint_list constraints_18432 = {</span>
 };
 
 static unsigned int rates_22579[] = {
<span class="p_del">-	44100, 88235, 1764000</span>
<span class="p_add">+	44100, 88200, 176400</span>
 };
 
 static struct snd_pcm_hw_constraint_list constraints_22579 = {
<span class="p_chunk">@@ -180,7 +180,7 @@</span> <span class="p_context"> static struct snd_pcm_hw_constraint_list constraints_24576 = {</span>
 };
 
 static unsigned int rates_36864[] = {
<span class="p_del">-	48000, 96000, 19200</span>
<span class="p_add">+	48000, 96000, 192000</span>
 };
 
 static struct snd_pcm_hw_constraint_list constraints_36864 = {
<span class="p_header">diff --git a/sound/soc/codecs/wm8960.c b/sound/soc/codecs/wm8960.c</span>
<span class="p_header">index b2abe93..8d26104 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8960.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8960.c</span>
<span class="p_chunk">@@ -336,7 +336,7 @@</span> <span class="p_context"> static const struct snd_soc_dapm_route audio_paths[] = {</span>
 	{ &quot;Right Input Mixer&quot;, &quot;Boost Switch&quot;, &quot;Right Boost Mixer&quot;, },
 	{ &quot;Right Input Mixer&quot;, NULL, &quot;RINPUT1&quot;, },  /* Really Boost Switch */
 	{ &quot;Right Input Mixer&quot;, NULL, &quot;RINPUT2&quot; },
<span class="p_del">-	{ &quot;Right Input Mixer&quot;, NULL, &quot;LINPUT3&quot; },</span>
<span class="p_add">+	{ &quot;Right Input Mixer&quot;, NULL, &quot;RINPUT3&quot; },</span>
 
 	{ &quot;Left ADC&quot;, NULL, &quot;Left Input Mixer&quot; },
 	{ &quot;Right ADC&quot;, NULL, &quot;Right Input Mixer&quot; },
<span class="p_header">diff --git a/sound/soc/codecs/wm8994.c b/sound/soc/codecs/wm8994.c</span>
<span class="p_header">index b73f226..9a56798 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8994.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8994.c</span>
<span class="p_chunk">@@ -2449,7 +2449,7 @@</span> <span class="p_context"> static struct {</span>
 };
 
 static int fs_ratios[] = {
<span class="p_del">-	64, 128, 192, 256, 348, 512, 768, 1024, 1408, 1536</span>
<span class="p_add">+	64, 128, 192, 256, 384, 512, 768, 1024, 1408, 1536</span>
 };
 
 static int bclk_divs[] = {
<span class="p_header">diff --git a/sound/soc/soc-dapm.c b/sound/soc/soc-dapm.c</span>
<span class="p_header">index 1d83a40..3dc1b8a 100644</span>
<span class="p_header">--- a/sound/soc/soc-dapm.c</span>
<span class="p_header">+++ b/sound/soc/soc-dapm.c</span>
<span class="p_chunk">@@ -2675,12 +2675,18 @@</span> <span class="p_context"> int snd_soc_dapm_new_control(struct snd_soc_dapm_context *dapm,</span>
 		kfree(w);
 		return -ENOMEM;
 	}
<span class="p_del">-	if (dapm-&gt;codec &amp;&amp; dapm-&gt;codec-&gt;name_prefix)</span>
<span class="p_add">+	if (dapm-&gt;codec &amp;&amp; dapm-&gt;codec-&gt;name_prefix) {</span>
 		snprintf(w-&gt;name, name_len, &quot;%s %s&quot;,
 			dapm-&gt;codec-&gt;name_prefix, widget-&gt;name);
<span class="p_del">-	else</span>
<span class="p_add">+		if (widget-&gt;sname)</span>
<span class="p_add">+			w-&gt;sname = kasprintf(GFP_KERNEL, &quot;%s %s&quot;,</span>
<span class="p_add">+					     dapm-&gt;codec-&gt;name_prefix,</span>
<span class="p_add">+					     widget-&gt;sname);</span>
<span class="p_add">+	} else {</span>
 		snprintf(w-&gt;name, name_len, &quot;%s&quot;, widget-&gt;name);
<span class="p_del">-</span>
<span class="p_add">+		if (widget-&gt;sname)</span>
<span class="p_add">+			w-&gt;sname = kasprintf(GFP_KERNEL, &quot;%s&quot;, widget-&gt;sname);</span>
<span class="p_add">+	}</span>
 	switch (w-&gt;id) {
 	case snd_soc_dapm_switch:
 	case snd_soc_dapm_mixer:
<span class="p_header">diff --git a/sound/synth/emux/emux_oss.c b/sound/synth/emux/emux_oss.c</span>
<span class="p_header">index 319754c..daf61ab 100644</span>
<span class="p_header">--- a/sound/synth/emux/emux_oss.c</span>
<span class="p_header">+++ b/sound/synth/emux/emux_oss.c</span>
<span class="p_chunk">@@ -118,12 +118,8 @@</span> <span class="p_context"> snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)</span>
 	if (snd_BUG_ON(!arg || !emu))
 		return -ENXIO;
 
<span class="p_del">-	mutex_lock(&amp;emu-&gt;register_mutex);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!snd_emux_inc_count(emu)) {</span>
<span class="p_del">-		mutex_unlock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+	if (!snd_emux_inc_count(emu))</span>
 		return -EFAULT;
<span class="p_del">-	}</span>
 
 	memset(&amp;callback, 0, sizeof(callback));
 	callback.owner = THIS_MODULE;
<span class="p_chunk">@@ -135,7 +131,6 @@</span> <span class="p_context"> snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)</span>
 	if (p == NULL) {
 		snd_printk(KERN_ERR &quot;can&#39;t create port\n&quot;);
 		snd_emux_dec_count(emu);
<span class="p_del">-		mutex_unlock(&amp;emu-&gt;register_mutex);</span>
 		return -ENOMEM;
 	}
 
<span class="p_chunk">@@ -148,8 +143,6 @@</span> <span class="p_context"> snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)</span>
 	reset_port_mode(p, arg-&gt;seq_mode);
 
 	snd_emux_reset_port(p);
<span class="p_del">-</span>
<span class="p_del">-	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -195,13 +188,11 @@</span> <span class="p_context"> snd_emux_close_seq_oss(struct snd_seq_oss_arg *arg)</span>
 	if (snd_BUG_ON(!emu))
 		return -ENXIO;
 
<span class="p_del">-	mutex_lock(&amp;emu-&gt;register_mutex);</span>
 	snd_emux_sounds_off_all(p);
 	snd_soundfont_close_check(emu-&gt;sflist, SF_CLIENT_NO(p-&gt;chset.port));
 	snd_seq_event_port_detach(p-&gt;chset.client, p-&gt;chset.port);
 	snd_emux_dec_count(emu);
 
<span class="p_del">-	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c</span>
<span class="p_header">index 7778b8e..a020920 100644</span>
<span class="p_header">--- a/sound/synth/emux/emux_seq.c</span>
<span class="p_header">+++ b/sound/synth/emux/emux_seq.c</span>
<span class="p_chunk">@@ -124,12 +124,10 @@</span> <span class="p_context"> snd_emux_detach_seq(struct snd_emux *emu)</span>
 	if (emu-&gt;voices)
 		snd_emux_terminate_all(emu);
 		
<span class="p_del">-	mutex_lock(&amp;emu-&gt;register_mutex);</span>
 	if (emu-&gt;client &gt;= 0) {
 		snd_seq_delete_kernel_client(emu-&gt;client);
 		emu-&gt;client = -1;
 	}
<span class="p_del">-	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
 }
 
 
<span class="p_chunk">@@ -269,8 +267,8 @@</span> <span class="p_context"> snd_emux_event_input(struct snd_seq_event *ev, int direct, void *private_data,</span>
 /*
  * increment usage count
  */
<span class="p_del">-int</span>
<span class="p_del">-snd_emux_inc_count(struct snd_emux *emu)</span>
<span class="p_add">+static int</span>
<span class="p_add">+__snd_emux_inc_count(struct snd_emux *emu)</span>
 {
 	emu-&gt;used++;
 	if (!try_module_get(emu-&gt;ops.owner))
<span class="p_chunk">@@ -284,12 +282,21 @@</span> <span class="p_context"> snd_emux_inc_count(struct snd_emux *emu)</span>
 	return 1;
 }
 
<span class="p_add">+int snd_emux_inc_count(struct snd_emux *emu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+	ret = __snd_emux_inc_count(emu);</span>
<span class="p_add">+	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
 
 /*
  * decrease usage count
  */
<span class="p_del">-void</span>
<span class="p_del">-snd_emux_dec_count(struct snd_emux *emu)</span>
<span class="p_add">+static void</span>
<span class="p_add">+__snd_emux_dec_count(struct snd_emux *emu)</span>
 {
 	module_put(emu-&gt;card-&gt;module);
 	emu-&gt;used--;
<span class="p_chunk">@@ -298,6 +305,12 @@</span> <span class="p_context"> snd_emux_dec_count(struct snd_emux *emu)</span>
 	module_put(emu-&gt;ops.owner);
 }
 
<span class="p_add">+void snd_emux_dec_count(struct snd_emux *emu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mutex_lock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+	__snd_emux_dec_count(emu);</span>
<span class="p_add">+	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+}</span>
 
 /*
  * Routine that is called upon a first use of a particular port
<span class="p_chunk">@@ -317,7 +330,7 @@</span> <span class="p_context"> snd_emux_use(void *private_data, struct snd_seq_port_subscribe *info)</span>
 
 	mutex_lock(&amp;emu-&gt;register_mutex);
 	snd_emux_init_port(p);
<span class="p_del">-	snd_emux_inc_count(emu);</span>
<span class="p_add">+	__snd_emux_inc_count(emu);</span>
 	mutex_unlock(&amp;emu-&gt;register_mutex);
 	return 0;
 }
<span class="p_chunk">@@ -340,7 +353,7 @@</span> <span class="p_context"> snd_emux_unuse(void *private_data, struct snd_seq_port_subscribe *info)</span>
 
 	mutex_lock(&amp;emu-&gt;register_mutex);
 	snd_emux_sounds_off_all(p);
<span class="p_del">-	snd_emux_dec_count(emu);</span>
<span class="p_add">+	__snd_emux_dec_count(emu);</span>
 	mutex_unlock(&amp;emu-&gt;register_mutex);
 	return 0;
 }
<span class="p_header">diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c</span>
<span class="p_header">index 88160b7..488e531 100644</span>
<span class="p_header">--- a/sound/usb/mixer.c</span>
<span class="p_header">+++ b/sound/usb/mixer.c</span>
<span class="p_chunk">@@ -838,6 +838,8 @@</span> <span class="p_context"> static void volume_control_quirks(struct usb_mixer_elem_info *cval,</span>
 	case USB_ID(0x046d, 0x081b): /* HD Webcam c310 */
 	case USB_ID(0x046d, 0x081d): /* HD Webcam c510 */
 	case USB_ID(0x046d, 0x0825): /* HD Webcam c270 */
<span class="p_add">+	case USB_ID(0x046d, 0x0826): /* HD Webcam c525 */</span>
<span class="p_add">+	case USB_ID(0x046d, 0x08ca): /* Logitech Quickcam Fusion */</span>
 	case USB_ID(0x046d, 0x0991):
 	/* Most audio usb devices lie about volume resolution.
 	 * Most Logitech webcams have res = 384.
<span class="p_chunk">@@ -1423,11 +1425,6 @@</span> <span class="p_context"> static int parse_audio_mixer_unit(struct mixer_build *state, int unitid, void *r</span>
 		snd_printk(KERN_ERR &quot;invalid MIXER UNIT descriptor %d\n&quot;, unitid);
 		return -EINVAL;
 	}
<span class="p_del">-	/* no bmControls field (e.g. Maya44) -&gt; ignore */</span>
<span class="p_del">-	if (desc-&gt;bLength &lt;= 10 + input_pins) {</span>
<span class="p_del">-		snd_printdd(KERN_INFO &quot;MU %d has no bmControls field\n&quot;, unitid);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
 
 	num_ins = 0;
 	ich = 0;
<span class="p_chunk">@@ -1435,6 +1432,9 @@</span> <span class="p_context"> static int parse_audio_mixer_unit(struct mixer_build *state, int unitid, void *r</span>
 		err = parse_audio_unit(state, desc-&gt;baSourceID[pin]);
 		if (err &lt; 0)
 			return err;
<span class="p_add">+		/* no bmControls field (e.g. Maya44) -&gt; ignore */</span>
<span class="p_add">+		if (desc-&gt;bLength &lt;= 10 + input_pins)</span>
<span class="p_add">+			continue;</span>
 		err = check_input_term(state, desc-&gt;baSourceID[pin], &amp;iterm);
 		if (err &lt; 0)
 			return err;
<span class="p_header">diff --git a/sound/usb/mixer_maps.c b/sound/usb/mixer_maps.c</span>
<span class="p_header">index 1e0798f..851786f 100644</span>
<span class="p_header">--- a/sound/usb/mixer_maps.c</span>
<span class="p_header">+++ b/sound/usb/mixer_maps.c</span>
<span class="p_chunk">@@ -380,6 +380,11 @@</span> <span class="p_context"> static struct usbmix_ctl_map usbmix_ctl_maps[] = {</span>
 		.ignore_ctl_error = 1,
 	},
 	{
<span class="p_add">+		/* MAYA44 USB+ */</span>
<span class="p_add">+		.id = USB_ID(0x2573, 0x0008),</span>
<span class="p_add">+		.map = maya44_map,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		/* KEF X300A */
 		.id = USB_ID(0x27ac, 0x1000),
 		.map = scms_usb3318_map,

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



