
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v2,4/5] iommu/mediatek: add support for mtk iommu generation one HW - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v2,4/5] iommu/mediatek: add support for mtk iommu generation one HW</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=166241">honghui.zhang@mediatek.com</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 19, 2016, 11:49 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1463658558-567-5-git-send-email-honghui.zhang@mediatek.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9127121/mbox/"
   >mbox</a>
|
   <a href="/patch/9127121/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9127121/">/patch/9127121/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id F33739F30C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 19 May 2016 11:50:47 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 5A317201C0
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 19 May 2016 11:50:46 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 9A15D2021B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 19 May 2016 11:50:39 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1754839AbcESLuf (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 19 May 2016 07:50:35 -0400
Received: from mailgw01.mediatek.com ([210.61.82.183]:37954 &quot;EHLO
	mailgw01.mediatek.com&quot; rhost-flags-OK-FAIL-OK-FAIL) by
	vger.kernel.org with ESMTP id S1754820AbcESLu1 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 19 May 2016 07:50:27 -0400
Received: from mtkhts07.mediatek.inc [(172.21.101.69)] by
	mailgw01.mediatek.com (envelope-from &lt;honghui.zhang@mediatek.com&gt;)
	(mhqrelay.mediatek.com ESMTP with TLS)
	with ESMTP id 918761327; Thu, 19 May 2016 19:50:22 +0800
Received: from mhfsdcap03.localdomain (10.17.3.153) by mtkhts07.mediatek.inc
	(172.21.101.73) with Microsoft SMTP Server id 14.3.266.1;
	Thu, 19 May 2016 19:50:21 +0800
From: &lt;honghui.zhang@mediatek.com&gt;
To: &lt;joro@8bytes.org&gt;, &lt;treding@nvidia.com&gt;, &lt;mark.rutland@arm.com&gt;,
	&lt;matthias.bgg@gmail.com&gt;, &lt;robh@kernel.org&gt;, &lt;robin.murphy@arm.com&gt;
CC: &lt;p.zabel@pengutronix.de&gt;, &lt;devicetree@vger.kernel.org&gt;,
	&lt;pebolle@tiscali.nl&gt;, &lt;kendrick.hsu@mediatek.com&gt;, &lt;arnd@arndb.de&gt;,
	&lt;srv_heupstream@mediatek.com&gt;, &lt;catalin.marinas@arm.com&gt;,
	&lt;will.deacon@arm.com&gt;, &lt;linux-kernel@vger.kernel.org&gt;,
	&lt;tfiga@google.com&gt;, &lt;iommu@lists.linux-foundation.org&gt;,
	&lt;robh+dt@kernel.org&gt;, &lt;djkurtz@google.com&gt;,
	&lt;kernel@pengutronix.de&gt;, &lt;linux-mediatek@lists.infradead.org&gt;,
	&lt;linux-arm-kernel@lists.infradead.org&gt;, &lt;l.stach@pengutronix.de&gt;,
	&lt;yingjoe.chen@mediatek.com&gt;, &lt;eddie.huang@mediatek.com&gt;,
	&lt;youlin.pei@mediatek.com&gt;, &lt;erin.lo@mediatek.com&gt;,
	Honghui Zhang &lt;honghui.zhang@mediatek.com&gt;
Subject: [PATCH v2 4/5] iommu/mediatek: add support for mtk iommu generation
	one HW
Date: Thu, 19 May 2016 19:49:17 +0800
Message-ID: &lt;1463658558-567-5-git-send-email-honghui.zhang@mediatek.com&gt;
X-Mailer: git-send-email 1.8.1.1.dirty
In-Reply-To: &lt;1463658558-567-1-git-send-email-honghui.zhang@mediatek.com&gt;
References: &lt;1463658558-567-1-git-send-email-honghui.zhang@mediatek.com&gt;
MIME-Version: 1.0
Content-Type: text/plain
X-MTK: N
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-8.3 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=166241">honghui.zhang@mediatek.com</a> - May 19, 2016, 11:49 a.m.</div>
<pre class="content">
<span class="from">From: Honghui Zhang &lt;honghui.zhang@mediatek.com&gt;</span>

Mediatek SoC&#39;s M4U has two generations of HW architcture. Generation one
uses flat, one layer pagetable, and was shipped with ARM architecture, it
only supports 4K size page mapping. MT2701 SoC uses this generation one
m4u HW. Generation two uses the ARM short-descriptor translation table
format for address translation, and was shipped with ARM64 architecture,
MT8173 uses this generation two m4u HW. All the two generation iommu HW
only have one iommu domain, and all its iommu clients share the same
iova address.

These two generation m4u HW have slit different register groups and
register offset, but most register names are the same. This patch add iommu
support for mediatek SoC mt2701.
<span class="signed-off-by">
Signed-off-by: Honghui Zhang &lt;honghui.zhang@mediatek.com&gt;</span>
---
 drivers/iommu/Kconfig        |  19 ++
 drivers/iommu/Makefile       |   1 +
 drivers/iommu/mtk_iommu.h    |   3 +
 drivers/iommu/mtk_iommu_v1.c | 742 +++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 765 insertions(+)
 create mode 100644 drivers/iommu/mtk_iommu_v1.c
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=77581">Robin Murphy</a> - May 23, 2016, 7:31 p.m.</div>
<pre class="content">
On 19/05/16 12:49, honghui.zhang@mediatek.com wrote:
<span class="quote">&gt; From: Honghui Zhang &lt;honghui.zhang@mediatek.com&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Mediatek SoC&#39;s M4U has two generations of HW architcture. Generation one</span>
<span class="quote">&gt; uses flat, one layer pagetable, and was shipped with ARM architecture, it</span>
<span class="quote">&gt; only supports 4K size page mapping. MT2701 SoC uses this generation one</span>
<span class="quote">&gt; m4u HW. Generation two uses the ARM short-descriptor translation table</span>
<span class="quote">&gt; format for address translation, and was shipped with ARM64 architecture,</span>
<span class="quote">&gt; MT8173 uses this generation two m4u HW. All the two generation iommu HW</span>
<span class="quote">&gt; only have one iommu domain, and all its iommu clients share the same</span>
<span class="quote">&gt; iova address.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; These two generation m4u HW have slit different register groups and</span>
<span class="quote">&gt; register offset, but most register names are the same. This patch add iommu</span>
<span class="quote">&gt; support for mediatek SoC mt2701.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Signed-off-by: Honghui Zhang &lt;honghui.zhang@mediatek.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;   drivers/iommu/Kconfig        |  19 ++</span>
<span class="quote">&gt;   drivers/iommu/Makefile       |   1 +</span>
<span class="quote">&gt;   drivers/iommu/mtk_iommu.h    |   3 +</span>
<span class="quote">&gt;   drivers/iommu/mtk_iommu_v1.c | 742 +++++++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;   4 files changed, 765 insertions(+)</span>
<span class="quote">&gt;   create mode 100644 drivers/iommu/mtk_iommu_v1.c</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/drivers/iommu/Kconfig b/drivers/iommu/Kconfig</span>
<span class="quote">&gt; index dd1dc39..2e17d70 100644</span>
<span class="quote">&gt; --- a/drivers/iommu/Kconfig</span>
<span class="quote">&gt; +++ b/drivers/iommu/Kconfig</span>
<span class="quote">&gt; @@ -354,4 +354,23 @@ config MTK_IOMMU</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;   	  If unsure, say N here.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +config MTK_IOMMU_V1</span>
<span class="quote">&gt; +	bool &quot;MTK IOMMU Version 1 (M4U gen1) Support&quot;</span>
<span class="quote">&gt; +	depends on ARM || ARM64</span>

The commit message states that gen1 shipped in 32-bit hardware, and 
64-bit hardware has gen2, which implies that ARM64 here is unnecessary - 
does any SoC with 64-bit-capable CPUs and a gen1 IOMMU actually exist?
<span class="quote">
&gt; +	depends on ARCH_MEDIATEK || COMPILE_TEST</span>
<span class="quote">&gt; +	select ARM_DMA_USE_IOMMU</span>
<span class="quote">&gt; +	select IOMMU_API</span>
<span class="quote">&gt; +	select IOMMU_DMA</span>

Either way you don&#39;t need this - arm64 already selects it as necessary, 
and it&#39;s not used on 32-bit.
<span class="quote">
&gt; +	select MEMORY</span>
<span class="quote">&gt; +	select MTK_SMI</span>
<span class="quote">&gt; +	select COMMON_CLK_MT2701_MMSYS</span>
<span class="quote">&gt; +	select COMMON_CLK_MT2701_IMGSYS</span>
<span class="quote">&gt; +	select COMMON_CLK_MT2701_VDECSYS</span>
<span class="quote">&gt; +	help</span>
<span class="quote">&gt; +	  Support for the M4U on certain Mediatek SoCs. M4U generation 1 HW is</span>
<span class="quote">&gt; +	  Multimedia Memory Managememt Unit. This option enables remapping of</span>
<span class="quote">&gt; +	  DMA memory accesses for the multimedia subsystem.</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	  if unsure, say N here.</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   endif # IOMMU_SUPPORT</span>
<span class="quote">&gt; diff --git a/drivers/iommu/Makefile b/drivers/iommu/Makefile</span>
<span class="quote">&gt; index c6edb31..778baf5 100644</span>
<span class="quote">&gt; --- a/drivers/iommu/Makefile</span>
<span class="quote">&gt; +++ b/drivers/iommu/Makefile</span>
<span class="quote">&gt; @@ -18,6 +18,7 @@ obj-$(CONFIG_INTEL_IOMMU_SVM) += intel-svm.o</span>
<span class="quote">&gt;   obj-$(CONFIG_IPMMU_VMSA) += ipmmu-vmsa.o</span>
<span class="quote">&gt;   obj-$(CONFIG_IRQ_REMAP) += intel_irq_remapping.o irq_remapping.o</span>
<span class="quote">&gt;   obj-$(CONFIG_MTK_IOMMU) += mtk_iommu.o</span>
<span class="quote">&gt; +obj-$(CONFIG_MTK_IOMMU_V1) += mtk_iommu_v1.o</span>
<span class="quote">&gt;   obj-$(CONFIG_OMAP_IOMMU) += omap-iommu.o</span>
<span class="quote">&gt;   obj-$(CONFIG_OMAP_IOMMU_DEBUG) += omap-iommu-debug.o</span>
<span class="quote">&gt;   obj-$(CONFIG_ROCKCHIP_IOMMU) += rockchip-iommu.o</span>
<span class="quote">&gt; diff --git a/drivers/iommu/mtk_iommu.h b/drivers/iommu/mtk_iommu.h</span>
<span class="quote">&gt; index 5656355..8d60f21 100644</span>
<span class="quote">&gt; --- a/drivers/iommu/mtk_iommu.h</span>
<span class="quote">&gt; +++ b/drivers/iommu/mtk_iommu.h</span>
<span class="quote">&gt; @@ -48,6 +48,9 @@ struct mtk_iommu_domain {</span>
<span class="quote">&gt;   	struct io_pgtable_ops		*iop;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;   	struct iommu_domain		domain;</span>
<span class="quote">&gt; +	void				*pgt_va;</span>
<span class="quote">&gt; +	dma_addr_t			pgt_pa;</span>
<span class="quote">&gt; +	void				*cookie;</span>

These are going to be mutually exclusive with the cfg and iop members, 
which implies it might be a good idea to use a union and not waste 
space. Or better, just forward-declare struct mtk_iommu_domain here and 
leave separate definitions private to each driver. The void *cookie is 
also an unnecessary level of abstraction, I think.
<span class="quote">
&gt;   };</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;   struct mtk_iommu_data {</span>
<span class="quote">&gt; diff --git a/drivers/iommu/mtk_iommu_v1.c b/drivers/iommu/mtk_iommu_v1.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 0000000..55023e1</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/drivers/iommu/mtk_iommu_v1.c</span>
<span class="quote">&gt; @@ -0,0 +1,742 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Copyright (c) 2015-2016 MediaTek Inc.</span>
<span class="quote">&gt; + * Author: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>

Nit: is that in the sense that this patch should also have Yong&#39;s 
signed-off-by on it, or in that it&#39;s your work derived from his version 
in mtk_iommu.c?
<span class="quote">
&gt; + *</span>
<span class="quote">&gt; + * This program is free software; you can redistribute it and/or modify</span>
<span class="quote">&gt; + * it under the terms of the GNU General Public License version 2 as</span>
<span class="quote">&gt; + * published by the Free Software Foundation.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * This program is distributed in the hope that it will be useful,</span>
<span class="quote">&gt; + * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="quote">&gt; + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="quote">&gt; + * GNU General Public License for more details.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +#include &lt;linux/bootmem.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/bug.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/clk.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/component.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/device.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/dma-iommu.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/err.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/interrupt.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/io.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/iommu.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/iopoll.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/kmemleak.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/list.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of_address.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of_iommu.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of_irq.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of_platform.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/platform_device.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/slab.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/spinlock.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/barrier.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/dma-iommu.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/module.h&gt;</span>
<span class="quote">&gt; +#include &lt;dt-bindings/memory/mt2701-larb-port.h&gt;</span>
<span class="quote">&gt; +#include &lt;soc/mediatek/smi.h&gt;</span>
<span class="quote">&gt; +#include &quot;mtk_iommu.h&quot;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define REG_MMU_PT_BASE_ADDR			0x000</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define F_ALL_INVLD				0x2</span>
<span class="quote">&gt; +#define F_MMU_INV_RANGE				0x1</span>
<span class="quote">&gt; +#define F_INVLD_EN0				BIT(0)</span>
<span class="quote">&gt; +#define F_INVLD_EN1				BIT(1)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define F_MMU_FAULT_VA_MSK			0xfffff000</span>
<span class="quote">&gt; +#define MTK_PROTECT_PA_ALIGN			128</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define REG_MMU_CTRL_REG			0x210</span>
<span class="quote">&gt; +#define F_MMU_CTRL_COHERENT_EN			BIT(8)</span>
<span class="quote">&gt; +#define REG_MMU_IVRP_PADDR			0x214</span>
<span class="quote">&gt; +#define REG_MMU_INT_CONTROL			0x220</span>
<span class="quote">&gt; +#define F_INT_TRANSLATION_FAULT			BIT(0)</span>
<span class="quote">&gt; +#define F_INT_MAIN_MULTI_HIT_FAULT		BIT(1)</span>
<span class="quote">&gt; +#define F_INT_INVALID_PA_FAULT			BIT(2)</span>
<span class="quote">&gt; +#define F_INT_ENTRY_REPLACEMENT_FAULT		BIT(3)</span>
<span class="quote">&gt; +#define F_INT_TABLE_WALK_FAULT			BIT(4)</span>
<span class="quote">&gt; +#define F_INT_TLB_MISS_FAULT			BIT(5)</span>
<span class="quote">&gt; +#define F_INT_PFH_DMA_FIFO_OVERFLOW		BIT(6)</span>
<span class="quote">&gt; +#define F_INT_MISS_DMA_FIFO_OVERFLOW		BIT(7)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define F_MMU_TF_PROTECT_SEL(prot)		(((prot) &amp; 0x3) &lt;&lt; 5)</span>
<span class="quote">&gt; +#define F_INT_CLR_BIT				BIT(12)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define REG_MMU_FAULT_ST			0x224</span>
<span class="quote">&gt; +#define REG_MMU_FAULT_VA			0x228</span>
<span class="quote">&gt; +#define REG_MMU_INVLD_PA			0x22C</span>
<span class="quote">&gt; +#define REG_MMU_INT_ID				0x388</span>
<span class="quote">&gt; +#define REG_MMU_INVALIDATE			0x5c0</span>
<span class="quote">&gt; +#define REG_MMU_INVLD_START_A			0x5c4</span>
<span class="quote">&gt; +#define REG_MMU_INVLD_END_A			0x5c8</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define REG_MMU_INV_SEL				0x5d8</span>
<span class="quote">&gt; +#define REG_MMU_STANDARD_AXI_MODE		0x5e8</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define REG_MMU_DCM				0x5f0</span>
<span class="quote">&gt; +#define F_MMU_DCM_ON				BIT(1)</span>
<span class="quote">&gt; +#define REG_MMU_CPE_DONE			0x60c</span>
<span class="quote">&gt; +#define F_DESC_VALID				0x2</span>
<span class="quote">&gt; +#define F_DESC_NONSEC				BIT(3)</span>
<span class="quote">&gt; +#define MT2701_M4U_TF_LARB(TF)			(6 - (((TF) &gt;&gt; 13) &amp; 0x7))</span>
<span class="quote">&gt; +#define MT2701_M4U_TF_PORT(TF)			(((TF) &gt;&gt; 8) &amp; 0xF)</span>
<span class="quote">&gt; +/* MTK generation one iommu HW only support 4K size mapping */</span>
<span class="quote">&gt; +#define MT2701_IOMMU_PAGE_SHIFT			12</span>
<span class="quote">&gt; +#define MT2701_IOMMU_PAGE_SIZE			(1UL &lt;&lt; MT2701_IOMMU_PAGE_SHIFT)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * MTK m4u support 4GB iova address space, and oly support 4K page</span>

Nit: s/oly/only/
<span class="quote">
&gt; + * mapping. So the pagetable size should be exactly as 4M.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +#define M2701_IOMMU_PGT_SIZE			SZ_4M</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const int mt2701_m4u_in_larb[] = {</span>
<span class="quote">&gt; +	LARB0_PORT_OFFSET, LARB1_PORT_OFFSET,</span>
<span class="quote">&gt; +	LARB2_PORT_OFFSET, LARB3_PORT_OFFSET</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static inline int mt2701_m4u_to_larb(int id)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	int i;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	for (i = ARRAY_SIZE(mt2701_m4u_in_larb); i &gt;= 0; i--)</span>
<span class="quote">&gt; +		if ((id) &gt;= mt2701_m4u_in_larb[i])</span>
<span class="quote">&gt; +			return i;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>

As far as I can tell, this is going to dereference mt2701_m4u_in_larb[4] 
on the first iteration. Not good.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +static inline int mt2701_m4u_to_port(int id)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	int larb = mt2701_m4u_to_larb(id);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return id - mt2701_m4u_in_larb[larb];</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_tlb_flush_all(void *cookie)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data = cookie;</span>

You&#39;re not bound by the using the io-pgtable TLB ops interface here, so 
just make the argument of type struct mtk_iommu_data*.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0,</span>
<span class="quote">&gt; +			data-&gt;base + REG_MMU_INV_SEL);</span>
<span class="quote">&gt; +	writel_relaxed(F_ALL_INVLD, data-&gt;base + REG_MMU_INVALIDATE);</span>
<span class="quote">&gt; +	wmb(); /* Make sure the tlb flush all done */</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_tlb_flush_range(void *cookie,</span>
<span class="quote">&gt; +				unsigned long iova, size_t size)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data = cookie;</span>

Ditto.
<span class="quote">
&gt; +	int ret;</span>
<span class="quote">&gt; +	u32 tmp;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0,</span>
<span class="quote">&gt; +		data-&gt;base + REG_MMU_INV_SEL);</span>
<span class="quote">&gt; +	writel_relaxed(iova &amp; F_MMU_FAULT_VA_MSK,</span>
<span class="quote">&gt; +		data-&gt;base + REG_MMU_INVLD_START_A);</span>
<span class="quote">&gt; +	writel_relaxed((iova + size - 1) &amp; F_MMU_FAULT_VA_MSK,</span>
<span class="quote">&gt; +		data-&gt;base + REG_MMU_INVLD_END_A);</span>
<span class="quote">&gt; +	writel_relaxed(F_MMU_INV_RANGE, data-&gt;base + REG_MMU_INVALIDATE);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = readl_poll_timeout_atomic(data-&gt;base + REG_MMU_CPE_DONE,</span>
<span class="quote">&gt; +				tmp, tmp != 0, 10, 100000);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		dev_warn(data-&gt;dev,</span>
<span class="quote">&gt; +			 &quot;Partial TLB flush timed out, falling back to full flush\n&quot;);</span>
<span class="quote">&gt; +		mtk_iommu_tlb_flush_all(cookie);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	/* Clear the CPE status */</span>
<span class="quote">&gt; +	writel_relaxed(0, data-&gt;base + REG_MMU_CPE_DONE);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static irqreturn_t mtk_iommu_isr(int irq, void *dev_id)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data = dev_id;</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *dom = data-&gt;m4u_dom;</span>
<span class="quote">&gt; +	u32 int_state, regval, fault_iova, fault_pa;</span>
<span class="quote">&gt; +	unsigned int fault_larb, fault_port;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Read error information from registers */</span>
<span class="quote">&gt; +	int_state = readl_relaxed(data-&gt;base + REG_MMU_FAULT_ST);</span>
<span class="quote">&gt; +	fault_iova = readl_relaxed(data-&gt;base + REG_MMU_FAULT_VA);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	fault_iova &amp;= F_MMU_FAULT_VA_MSK;</span>
<span class="quote">&gt; +	fault_pa = readl_relaxed(data-&gt;base + REG_MMU_INVLD_PA);</span>
<span class="quote">&gt; +	regval = readl_relaxed(data-&gt;base + REG_MMU_INT_ID);</span>
<span class="quote">&gt; +	fault_larb = MT2701_M4U_TF_LARB(regval);</span>
<span class="quote">&gt; +	fault_port = MT2701_M4U_TF_PORT(regval);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * MTK v1 iommu HW could not determin whether the fault is read or</span>

Nit: s/determin/determine/
<span class="quote">
&gt; +	 * write fault, report as read fault.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	if (report_iommu_fault(&amp;dom-&gt;domain, data-&gt;dev, fault_iova,</span>
<span class="quote">&gt; +			IOMMU_FAULT_READ))</span>
<span class="quote">&gt; +		dev_err_ratelimited(data-&gt;dev,</span>
<span class="quote">&gt; +			&quot;fault type=0x%x iova=0x%x pa=0x%x larb=%d port=%d\n&quot;,</span>
<span class="quote">&gt; +			int_state, fault_iova, fault_pa,</span>
<span class="quote">&gt; +			fault_larb, fault_port);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Interrupt clear */</span>
<span class="quote">&gt; +	regval = readl_relaxed(data-&gt;base + REG_MMU_INT_CONTROL);</span>
<span class="quote">&gt; +	regval |= F_INT_CLR_BIT;</span>
<span class="quote">&gt; +	writel_relaxed(regval, data-&gt;base + REG_MMU_INT_CONTROL);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mtk_iommu_tlb_flush_all(data);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return IRQ_HANDLED;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_config(struct mtk_iommu_data *data,</span>
<span class="quote">&gt; +			     struct device *dev, bool enable)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_client_priv *head, *cur, *next;</span>
<span class="quote">&gt; +	struct mtk_smi_larb_iommu    *larb_mmu;</span>
<span class="quote">&gt; +	unsigned int                 larbid, portid;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	head = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; +	list_for_each_entry_safe(cur, next, &amp;head-&gt;client, client) {</span>
<span class="quote">&gt; +		larbid = mt2701_m4u_to_larb(cur-&gt;mtk_m4u_id);</span>
<span class="quote">&gt; +		portid = mt2701_m4u_to_port(cur-&gt;mtk_m4u_id);</span>
<span class="quote">&gt; +		larb_mmu = &amp;data-&gt;smi_imu.larb_imu[larbid];</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		dev_dbg(dev, &quot;%s iommu port: %d\n&quot;,</span>
<span class="quote">&gt; +			enable ? &quot;enable&quot; : &quot;disable&quot;, portid);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		if (enable)</span>
<span class="quote">&gt; +			larb_mmu-&gt;mmu |= MTK_SMI_MMU_EN(portid);</span>
<span class="quote">&gt; +		else</span>
<span class="quote">&gt; +			larb_mmu-&gt;mmu &amp;= ~MTK_SMI_MMU_EN(portid);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void *mtk_iommu_alloc_pgt(struct device *dev,</span>
<span class="quote">&gt; +				dma_addr_t *dma, gfp_t gfp)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	void *pages = dma_alloc_coherent(dev,</span>
<span class="quote">&gt; +				M2701_IOMMU_PGT_SIZE, dma, gfp | __GFP_ZERO);</span>

There&#39;s a dma_zalloc_coherent() wrapper macro you can use for that.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +	if (!pages)</span>
<span class="quote">&gt; +		return NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	kmemleak_ignore(pages);</span>

Kmemleak should be able to find the live reference in dom-&gt;pgt_va, so 
this is unnecessary - it&#39;s only there in the other code because of the 
tracking-allocations-by-physical-address trickery which you&#39;ve otherwise 
gotten rid of here.
<span class="quote">
&gt; +	return pages;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_free_pgt(struct device *dev,</span>
<span class="quote">&gt; +				void *pages, dma_addr_t dma)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	dma_free_coherent(dev, M2701_IOMMU_PGT_SIZE, pages, dma);</span>
<span class="quote">&gt; +}</span>

In fact, I&#39;d just inline the dma_{alloc,free} calls at the callsites of 
these functions, since they&#39;re sufficiently self-documenting.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_domain_finalise(struct mtk_iommu_data *data)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *dom = data-&gt;m4u_dom;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	spin_lock_init(&amp;dom-&gt;pgtlock);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	dom-&gt;pgt_va = mtk_iommu_alloc_pgt(data-&gt;dev,</span>
<span class="quote">&gt; +				&amp;dom-&gt;pgt_pa, GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!dom-&gt;pgt_va)</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	writel(dom-&gt;pgt_pa, data-&gt;base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	dom-&gt;cookie = (void *)data;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct iommu_domain *mtk_iommu_domain_alloc(unsigned type)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *dom;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (type != IOMMU_DOMAIN_UNMANAGED)</span>
<span class="quote">&gt; +		return NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	dom = kzalloc(sizeof(*dom), GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!dom)</span>
<span class="quote">&gt; +		return NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return &amp;dom-&gt;domain;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_domain_free(struct iommu_domain *domain)</span>
<span class="quote">&gt; +{</span>

The page table belongs to the domain, so it should be freed from here, 
not anywhere else.
<span class="quote">
&gt; +	kfree(to_mtk_domain(domain));</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_attach_device(struct iommu_domain *domain,</span>
<span class="quote">&gt; +				   struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="quote">&gt; +	struct mtk_iommu_client_priv *priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data;</span>
<span class="quote">&gt; +	int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!priv)</span>
<span class="quote">&gt; +		return -ENODEV;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt; +	if (!data-&gt;m4u_dom) {</span>
<span class="quote">&gt; +		data-&gt;m4u_dom = dom;</span>
<span class="quote">&gt; +		ret = mtk_iommu_domain_finalise(data);</span>
<span class="quote">&gt; +		if (ret) {</span>
<span class="quote">&gt; +			data-&gt;m4u_dom = NULL;</span>
<span class="quote">&gt; +			return ret;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +	} else if (data-&gt;m4u_dom != dom) {</span>

This will never happen, because you make sure all devices are in the 
same group, so the IOMMU core code will always call you with the same 
domain here. You can safely just attach dev to dom.
<span class="quote">
&gt; +		/* All the client devices should be in the same m4u domain */</span>
<span class="quote">&gt; +		dev_err(dev, &quot;try to attach into the error iommu domain\n&quot;);</span>
<span class="quote">&gt; +		return -EPERM;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mtk_iommu_config(data, dev, true);</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_detach_device(struct iommu_domain *domain,</span>
<span class="quote">&gt; +				    struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_client_priv *priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!priv)</span>
<span class="quote">&gt; +		return;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt; +	mtk_iommu_config(data, dev, false);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_map(struct iommu_domain *domain, unsigned long iova,</span>
<span class="quote">&gt; +			 phys_addr_t paddr, size_t size, int prot)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data = dom-&gt;cookie;</span>
<span class="quote">&gt; +	unsigned int page_num = size &gt;&gt; MT2701_IOMMU_PAGE_SHIFT;</span>
<span class="quote">&gt; +	unsigned long flags;</span>
<span class="quote">&gt; +	unsigned int i;</span>
<span class="quote">&gt; +	u32 *pgt_base_iova = dom-&gt;pgt_va;</span>
<span class="quote">&gt; +	u32 pabase = (u32)paddr;</span>
<span class="quote">&gt; +	int map_size = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	spin_lock_irqsave(&amp;dom-&gt;pgtlock, flags);</span>
<span class="quote">&gt; +	pgt_base_iova += iova  &gt;&gt; MT2701_IOMMU_PAGE_SHIFT;</span>

It took me a while to figure out why this isn&#39;t just part of the 
initialisation expression; just make dom-&gt;pgt_va a u32* so that it can be.
<span class="quote">
&gt; +	for (i = 0; i &lt; page_num; i++) {</span>
<span class="quote">&gt; +		if (pgt_base_iova[i])</span>
<span class="quote">&gt; +			break;</span>

The error case also needs to roll back any partial mapping it&#39;s managed 
so far - otherwise you end up making the initial problem worse by 
leaving behind yet more unexpected PTEs in areas that the caller thinks 
are unmapped.
<span class="quote">
&gt; +		pgt_base_iova[i] = pabase | F_DESC_VALID | F_DESC_NONSEC;</span>
<span class="quote">&gt; +		pabase += MT2701_IOMMU_PAGE_SIZE;</span>
<span class="quote">&gt; +		map_size += MT2701_IOMMU_PAGE_SIZE;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	spin_unlock_irqrestore(&amp;dom-&gt;pgtlock, flags);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mtk_iommu_tlb_flush_range(data, iova, size);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return map_size == size ? 0 : -EEXIST;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static size_t mtk_iommu_unmap(struct iommu_domain *domain,</span>
<span class="quote">&gt; +			      unsigned long iova, size_t size)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data = dom-&gt;cookie;</span>
<span class="quote">&gt; +	unsigned long flags;</span>
<span class="quote">&gt; +	u32 *pgt_base_iova = dom-&gt;pgt_va;</span>
<span class="quote">&gt; +	unsigned int page_num = size &gt;&gt; MT2701_IOMMU_PAGE_SHIFT;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	spin_lock_irqsave(&amp;dom-&gt;pgtlock, flags);</span>
<span class="quote">&gt; +	pgt_base_iova += iova  &gt;&gt; MT2701_IOMMU_PAGE_SHIFT;</span>

Same complaint as for mtk_iommu_map().
<span class="quote">
&gt; +	memset(pgt_base_iova, 0, page_num * sizeof(u32));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	spin_unlock_irqrestore(&amp;dom-&gt;pgtlock, flags);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mtk_iommu_tlb_flush_range(data, iova, size);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return size;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static phys_addr_t mtk_iommu_iova_to_phys(struct iommu_domain *domain,</span>
<span class="quote">&gt; +					  dma_addr_t iova)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="quote">&gt; +	unsigned long flags;</span>
<span class="quote">&gt; +	phys_addr_t pa;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	spin_lock_irqsave(&amp;dom-&gt;pgtlock, flags);</span>
<span class="quote">&gt; +	pa = *((u32 *)((u32 *)dom-&gt;pgt_va + (iova &gt;&gt; MT2701_IOMMU_PAGE_SHIFT)));</span>

Yikes! _Definitely_ make dom-&gt;pgt_va a u32*.
<span class="quote">
&gt; +	pa = pa &amp; (~(MT2701_IOMMU_PAGE_SIZE - 1));</span>
<span class="quote">&gt; +	spin_unlock_irqrestore(&amp;dom-&gt;pgtlock, flags);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return pa;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * MTK generaion one iommu HW only support one iommu domain, and all the client</span>

Nit: s/generaion/generation/
<span class="quote">
&gt; + * sharing the same iova address space.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +static int mtk_iommu_create_mapping(struct device *dev,</span>
<span class="quote">&gt; +				    struct of_phandle_args *args)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_client_priv *head, *priv, *next;</span>
<span class="quote">&gt; +	struct platform_device *m4updev;</span>
<span class="quote">&gt; +	struct dma_iommu_mapping *mtk_mapping;</span>
<span class="quote">&gt; +	struct device *m4udev;</span>
<span class="quote">&gt; +	int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (args-&gt;args_count != 1) {</span>
<span class="quote">&gt; +		dev_err(dev, &quot;invalid #iommu-cells(%d) property for IOMMU\n&quot;,</span>
<span class="quote">&gt; +			args-&gt;args_count);</span>
<span class="quote">&gt; +		return -EINVAL;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!dev-&gt;archdata.iommu) {</span>
<span class="quote">&gt; +		/* Get the m4u device */</span>
<span class="quote">&gt; +		m4updev = of_find_device_by_node(args-&gt;np);</span>
<span class="quote">&gt; +		of_node_put(args-&gt;np);</span>
<span class="quote">&gt; +		if (WARN_ON(!m4updev))</span>
<span class="quote">&gt; +			return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		head = kzalloc(sizeof(*head), GFP_KERNEL);</span>
<span class="quote">&gt; +		if (!head)</span>
<span class="quote">&gt; +			return -ENOMEM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		dev-&gt;archdata.iommu = head;</span>
<span class="quote">&gt; +		INIT_LIST_HEAD(&amp;head-&gt;client);</span>
<span class="quote">&gt; +		head-&gt;m4udev = &amp;m4updev-&gt;dev;</span>
<span class="quote">&gt; +	} else {</span>
<span class="quote">&gt; +		head = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!priv) {</span>
<span class="quote">&gt; +		ret = -ENOMEM;</span>
<span class="quote">&gt; +		goto err_free_mem;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	priv-&gt;mtk_m4u_id = args-&gt;args[0];</span>
<span class="quote">&gt; +	list_add_tail(&amp;priv-&gt;client, &amp;head-&gt;client);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	m4udev = head-&gt;m4udev;</span>
<span class="quote">&gt; +	mtk_mapping = m4udev-&gt;archdata.iommu;</span>
<span class="quote">&gt; +	if (!mtk_mapping) {</span>
<span class="quote">&gt; +		/* MTK iommu support 4GB iova address space. */</span>
<span class="quote">&gt; +		mtk_mapping = arm_iommu_create_mapping(&amp;platform_bus_type,</span>
<span class="quote">&gt; +						0, 1ULL &lt;&lt; 32);</span>
<span class="quote">&gt; +		if (IS_ERR(mtk_mapping)) {</span>
<span class="quote">&gt; +			ret = PTR_ERR(mtk_mapping);</span>
<span class="quote">&gt; +			goto err_free_mem;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +		m4udev-&gt;archdata.iommu = mtk_mapping;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = arm_iommu_attach_device(dev, mtk_mapping);</span>
<span class="quote">&gt; +	if (ret)</span>
<span class="quote">&gt; +		goto err_release_mapping;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +err_release_mapping:</span>
<span class="quote">&gt; +	arm_iommu_release_mapping(mtk_mapping);</span>
<span class="quote">&gt; +	m4udev-&gt;archdata.iommu = NULL;</span>
<span class="quote">&gt; +err_free_mem:</span>
<span class="quote">&gt; +	list_for_each_entry_safe(priv, next, &amp;head-&gt;client, client)</span>
<span class="quote">&gt; +		kfree(priv);</span>
<span class="quote">&gt; +	kfree(head);</span>
<span class="quote">&gt; +	dev-&gt;archdata.iommu = NULL;</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_add_device(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct iommu_group *group;</span>
<span class="quote">&gt; +	struct device_node *np;</span>
<span class="quote">&gt; +	struct of_phandle_args iommu_spec;</span>
<span class="quote">&gt; +	int idx = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	while (!of_parse_phandle_with_args(dev-&gt;of_node, &quot;iommus&quot;,</span>
<span class="quote">&gt; +				   &quot;#iommu-cells&quot;, idx,</span>
<span class="quote">&gt; +				   &amp;iommu_spec)) {</span>

Hang on, this doesn&#39;t seem right - why do you need to reimplement all 
this instead of using IOMMU_OF_DECLARE()?
<span class="quote">
&gt; +		np = iommu_spec.np;</span>
<span class="quote">&gt; +		mtk_iommu_create_mapping(dev, &amp;iommu_spec);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		of_node_put(np);</span>
<span class="quote">&gt; +		idx++;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!dev-&gt;archdata.iommu) /* Not a iommu client device */</span>
<span class="quote">&gt; +		return -ENODEV;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	group = iommu_group_get_for_dev(dev);</span>
<span class="quote">&gt; +	if (IS_ERR(group))</span>
<span class="quote">&gt; +		return PTR_ERR(group);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	iommu_group_put(group);</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_remove_device(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_client_priv *head, *cur, *next;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	head = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; +	if (!head)</span>
<span class="quote">&gt; +		return;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	list_for_each_entry_safe(cur, next, &amp;head-&gt;client, client) {</span>
<span class="quote">&gt; +		list_del(&amp;cur-&gt;client);</span>
<span class="quote">&gt; +		kfree(cur);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	kfree(head);</span>
<span class="quote">&gt; +	dev-&gt;archdata.iommu = NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	iommu_group_remove_device(dev);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct iommu_group *mtk_iommu_device_group(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data;</span>
<span class="quote">&gt; +	struct mtk_iommu_client_priv *priv;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; +	if (!priv)</span>
<span class="quote">&gt; +		return ERR_PTR(-ENODEV);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* All the client devices are in the same m4u iommu-group */</span>
<span class="quote">&gt; +	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt; +	if (!data-&gt;m4u_group) {</span>
<span class="quote">&gt; +		data-&gt;m4u_group = iommu_group_alloc();</span>
<span class="quote">&gt; +		if (IS_ERR(data-&gt;m4u_group))</span>
<span class="quote">&gt; +			dev_err(dev, &quot;Failed to allocate M4U IOMMU group\n&quot;);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	return data-&gt;m4u_group;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_hw_init(const struct mtk_iommu_data *data)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	u32 regval;</span>
<span class="quote">&gt; +	int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = clk_prepare_enable(data-&gt;bclk);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		dev_err(data-&gt;dev, &quot;Failed to enable iommu bclk(%d)\n&quot;, ret);</span>
<span class="quote">&gt; +		return ret;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	regval = F_MMU_CTRL_COHERENT_EN | F_MMU_TF_PROTECT_SEL(2);</span>
<span class="quote">&gt; +	writel_relaxed(regval, data-&gt;base + REG_MMU_CTRL_REG);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	regval = F_INT_TRANSLATION_FAULT |</span>
<span class="quote">&gt; +		F_INT_MAIN_MULTI_HIT_FAULT |</span>
<span class="quote">&gt; +		F_INT_INVALID_PA_FAULT |</span>
<span class="quote">&gt; +		F_INT_ENTRY_REPLACEMENT_FAULT |</span>
<span class="quote">&gt; +		F_INT_TABLE_WALK_FAULT |</span>
<span class="quote">&gt; +		F_INT_TLB_MISS_FAULT |</span>
<span class="quote">&gt; +		F_INT_PFH_DMA_FIFO_OVERFLOW |</span>
<span class="quote">&gt; +		F_INT_MISS_DMA_FIFO_OVERFLOW;</span>
<span class="quote">&gt; +	writel_relaxed(regval, data-&gt;base + REG_MMU_INT_CONTROL);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* protect memory,hw will write here while translation fault */</span>
<span class="quote">&gt; +	writel_relaxed(data-&gt;protect_base,</span>
<span class="quote">&gt; +			data-&gt;base + REG_MMU_IVRP_PADDR);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	writel_relaxed(F_MMU_DCM_ON, data-&gt;base + REG_MMU_DCM);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (devm_request_irq(data-&gt;dev, data-&gt;irq, mtk_iommu_isr, 0,</span>
<span class="quote">&gt; +			     dev_name(data-&gt;dev), (void *)data)) {</span>
<span class="quote">&gt; +		writel_relaxed(0, data-&gt;base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt; +		clk_disable_unprepare(data-&gt;bclk);</span>
<span class="quote">&gt; +		dev_err(data-&gt;dev, &quot;Failed @ IRQ-%d Request\n&quot;, data-&gt;irq);</span>
<span class="quote">&gt; +		return -ENODEV;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct iommu_ops mtk_iommu_ops = {</span>
<span class="quote">&gt; +	.domain_alloc	= mtk_iommu_domain_alloc,</span>
<span class="quote">&gt; +	.domain_free	= mtk_iommu_domain_free,</span>
<span class="quote">&gt; +	.attach_dev	= mtk_iommu_attach_device,</span>
<span class="quote">&gt; +	.detach_dev	= mtk_iommu_detach_device,</span>
<span class="quote">&gt; +	.map		= mtk_iommu_map,</span>
<span class="quote">&gt; +	.unmap		= mtk_iommu_unmap,</span>
<span class="quote">&gt; +	.map_sg		= default_iommu_map_sg,</span>
<span class="quote">&gt; +	.iova_to_phys	= mtk_iommu_iova_to_phys,</span>
<span class="quote">&gt; +	.add_device	= mtk_iommu_add_device,</span>
<span class="quote">&gt; +	.remove_device	= mtk_iommu_remove_device,</span>
<span class="quote">&gt; +	.device_group	= mtk_iommu_device_group,</span>
<span class="quote">&gt; +	.pgsize_bitmap	= ~0UL &lt;&lt; MT2701_IOMMU_PAGE_SHIFT,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const struct of_device_id mtk_iommu_of_ids[] = {</span>
<span class="quote">&gt; +	{ .compatible = &quot;mediatek,mt2701-m4u&quot;, },</span>
<span class="quote">&gt; +	{}</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const struct component_master_ops mtk_iommu_com_ops = {</span>
<span class="quote">&gt; +	.bind		= mtk_iommu_bind,</span>
<span class="quote">&gt; +	.unbind		= mtk_iommu_unbind,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_data		*data;</span>
<span class="quote">&gt; +	struct device			*dev = &amp;pdev-&gt;dev;</span>
<span class="quote">&gt; +	struct resource			*res;</span>
<span class="quote">&gt; +	struct component_match		*match = NULL;</span>
<span class="quote">&gt; +	void				*protect;</span>
<span class="quote">&gt; +	int				i, larb_nr, ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!data)</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	data-&gt;dev = dev;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Protect memory. HW will access here while translation fault.*/</span>
<span class="quote">&gt; +	protect = devm_kzalloc(dev, MTK_PROTECT_PA_ALIGN * 2, GFP_KERNEL);</span>

I think strictly this ought to have GFP_DMA as well.
<span class="quote">
&gt; +	if (!protect)</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +	data-&gt;protect_base = ALIGN(virt_to_phys(protect), MTK_PROTECT_PA_ALIGN);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);</span>
<span class="quote">&gt; +	data-&gt;base = devm_ioremap_resource(dev, res);</span>
<span class="quote">&gt; +	if (IS_ERR(data-&gt;base))</span>
<span class="quote">&gt; +		return PTR_ERR(data-&gt;base);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	data-&gt;irq = platform_get_irq(pdev, 0);</span>
<span class="quote">&gt; +	if (data-&gt;irq &lt; 0)</span>
<span class="quote">&gt; +		return data-&gt;irq;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	data-&gt;bclk = devm_clk_get(dev, &quot;bclk&quot;);</span>
<span class="quote">&gt; +	if (IS_ERR(data-&gt;bclk))</span>
<span class="quote">&gt; +		return PTR_ERR(data-&gt;bclk);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	larb_nr = of_count_phandle_with_args(dev-&gt;of_node,</span>
<span class="quote">&gt; +					&quot;mediatek,larbs&quot;, NULL);</span>
<span class="quote">&gt; +	if (larb_nr &lt; 0)</span>
<span class="quote">&gt; +		return larb_nr;</span>
<span class="quote">&gt; +	data-&gt;smi_imu.larb_nr = larb_nr;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	for (i = 0; i &lt; larb_nr; i++) {</span>
<span class="quote">&gt; +		struct device_node *larbnode;</span>
<span class="quote">&gt; +		struct platform_device *plarbdev;</span>

Nit: I wonder if the new of_for_each_phandle() iterator might make this 
larb-discovery logic cleaner? It might be worth a go now that that&#39;s 
landed in the current merge window.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +		larbnode = of_parse_phandle(dev-&gt;of_node, &quot;mediatek,larbs&quot;, i);</span>
<span class="quote">&gt; +		if (!larbnode)</span>
<span class="quote">&gt; +			return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		if (!of_device_is_available(larbnode))</span>
<span class="quote">&gt; +			continue;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		plarbdev = of_find_device_by_node(larbnode);</span>
<span class="quote">&gt; +		of_node_put(larbnode);</span>
<span class="quote">&gt; +		if (!plarbdev) {</span>
<span class="quote">&gt; +			plarbdev = of_platform_device_create(</span>
<span class="quote">&gt; +						larbnode, NULL,</span>
<span class="quote">&gt; +						platform_bus_type.dev_root);</span>
<span class="quote">&gt; +			if (!plarbdev)</span>
<span class="quote">&gt; +				return -EPROBE_DEFER;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +		data-&gt;smi_imu.larb_imu[i].dev = &amp;plarbdev-&gt;dev;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		component_match_add(dev, &amp;match, compare_of, larbnode);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	platform_set_drvdata(pdev, data);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = mtk_iommu_hw_init(data);</span>
<span class="quote">&gt; +	if (ret)</span>
<span class="quote">&gt; +		return ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!iommu_present(&amp;platform_bus_type))</span>
<span class="quote">&gt; +		bus_set_iommu(&amp;platform_bus_type,  &amp;mtk_iommu_ops);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return component_master_add_with_match(dev, &amp;mtk_iommu_com_ops, match);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_remove(struct platform_device *pdev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data = platform_get_drvdata(pdev);</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *dom = data-&gt;m4u_dom;</span>
<span class="quote">&gt; +	struct device *dev = &amp;pdev-&gt;dev;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mtk_iommu_free_pgt(dev, dom-&gt;pgt_va, dom-&gt;pgt_pa);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (iommu_present(&amp;platform_bus_type))</span>
<span class="quote">&gt; +		bus_set_iommu(&amp;platform_bus_type, NULL);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	clk_disable_unprepare(data-&gt;bclk);</span>
<span class="quote">&gt; +	devm_free_irq(&amp;pdev-&gt;dev, data-&gt;irq, data);</span>
<span class="quote">&gt; +	component_master_del(&amp;pdev-&gt;dev, &amp;mtk_iommu_com_ops);</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int __maybe_unused mtk_iommu_suspend(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data = dev_get_drvdata(dev);</span>
<span class="quote">&gt; +	struct mtk_iommu_suspend_reg *reg = &amp;data-&gt;reg;</span>
<span class="quote">&gt; +	void __iomem *base = data-&gt;base;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	reg-&gt;standard_axi_mode = readl_relaxed(base +</span>
<span class="quote">&gt; +					       REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt; +	reg-&gt;dcm_dis = readl_relaxed(base + REG_MMU_DCM);</span>
<span class="quote">&gt; +	reg-&gt;ctrl_reg = readl_relaxed(base + REG_MMU_CTRL_REG);</span>
<span class="quote">&gt; +	reg-&gt;int_control0 = readl_relaxed(base + REG_MMU_INT_CONTROL);</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int __maybe_unused mtk_iommu_resume(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data = dev_get_drvdata(dev);</span>
<span class="quote">&gt; +	struct mtk_iommu_suspend_reg *reg = &amp;data-&gt;reg;</span>
<span class="quote">&gt; +	void __iomem *base = data-&gt;base;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	writel_relaxed(data-&gt;m4u_dom-&gt;pgt_pa, base + REG_MMU_PT_BASE_ADDR);</span>

Hmm, this looks like the only case where m4u_dom actually seems 
necessary - I&#39;m pretty sure all the others could be fairly easily 
reworked to not use it (I might try having a quick hack at the existing 
M4U driver to see) - at which point we could just explicitly 
save/restore the base register here and get rid of m4u_dom entirely.
<span class="quote">
&gt; +	writel_relaxed(reg-&gt;standard_axi_mode,</span>
<span class="quote">&gt; +		       base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt; +	writel_relaxed(reg-&gt;dcm_dis, base + REG_MMU_DCM);</span>
<span class="quote">&gt; +	writel_relaxed(reg-&gt;ctrl_reg, base + REG_MMU_CTRL_REG);</span>
<span class="quote">&gt; +	writel_relaxed(reg-&gt;int_control0, base + REG_MMU_INT_CONTROL);</span>
<span class="quote">&gt; +	writel_relaxed(data-&gt;protect_base, base + REG_MMU_IVRP_PADDR);</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +const struct dev_pm_ops mtk_iommu_pm_ops = {</span>
<span class="quote">&gt; +	SET_SYSTEM_SLEEP_PM_OPS(mtk_iommu_suspend, mtk_iommu_resume)</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct platform_driver mtk_iommu_driver = {</span>
<span class="quote">&gt; +	.probe	= mtk_iommu_probe,</span>
<span class="quote">&gt; +	.remove	= mtk_iommu_remove,</span>
<span class="quote">&gt; +	.driver	= {</span>
<span class="quote">&gt; +		.name = &quot;mtk-iommu&quot;,</span>
<span class="quote">&gt; +		.of_match_table = mtk_iommu_of_ids,</span>
<span class="quote">&gt; +		.pm = &amp;mtk_iommu_pm_ops,</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int __init m4u_init(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = platform_driver_register(&amp;mtk_iommu_driver);</span>
<span class="quote">&gt; +	if (ret)</span>
<span class="quote">&gt; +		bus_set_iommu(&amp;platform_bus_type, NULL);</span>

That doesn&#39;t seem necessary - the bus ops won&#39;t be set until having 
successfully probed an M4U, and you definitely won&#39;t have managed that 
before registering the driver ;)

Robin.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void __exit m4u_exit(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return platform_driver_unregister(&amp;mtk_iommu_driver);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +subsys_initcall(m4u_init);</span>
<span class="quote">&gt; +module_exit(m4u_exit);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +MODULE_DESCRIPTION(&quot;IOMMU API for MTK architected m4u v1 implementations&quot;);</span>
<span class="quote">&gt; +MODULE_AUTHOR(&quot;Honghui Zhang &lt;honghui.zhang@mediatek.com&gt;&quot;);</span>
<span class="quote">&gt; +MODULE_LICENSE(&quot;GPL v2&quot;);</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=166241">honghui.zhang@mediatek.com</a> - May 24, 2016, 9:57 a.m.</div>
<pre class="content">
Hi, Robin,
Thanks very much for your comments.

On Mon, 2016-05-23 at 20:31 +0100, Robin Murphy wrote:
<span class="quote">&gt; On 19/05/16 12:49, honghui.zhang@mediatek.com wrote:</span>
<span class="quote">&gt; &gt; From: Honghui Zhang &lt;honghui.zhang@mediatek.com&gt;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Mediatek SoC&#39;s M4U has two generations of HW architcture. Generation one</span>
<span class="quote">&gt; &gt; uses flat, one layer pagetable, and was shipped with ARM architecture, it</span>
<span class="quote">&gt; &gt; only supports 4K size page mapping. MT2701 SoC uses this generation one</span>
<span class="quote">&gt; &gt; m4u HW. Generation two uses the ARM short-descriptor translation table</span>
<span class="quote">&gt; &gt; format for address translation, and was shipped with ARM64 architecture,</span>
<span class="quote">&gt; &gt; MT8173 uses this generation two m4u HW. All the two generation iommu HW</span>
<span class="quote">&gt; &gt; only have one iommu domain, and all its iommu clients share the same</span>
<span class="quote">&gt; &gt; iova address.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; These two generation m4u HW have slit different register groups and</span>
<span class="quote">&gt; &gt; register offset, but most register names are the same. This patch add iommu</span>
<span class="quote">&gt; &gt; support for mediatek SoC mt2701.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Signed-off-by: Honghui Zhang &lt;honghui.zhang@mediatek.com&gt;</span>
<span class="quote">&gt; &gt; ---</span>
<span class="quote">&gt; &gt;   drivers/iommu/Kconfig        |  19 ++</span>
<span class="quote">&gt; &gt;   drivers/iommu/Makefile       |   1 +</span>
<span class="quote">&gt; &gt;   drivers/iommu/mtk_iommu.h    |   3 +</span>
<span class="quote">&gt; &gt;   drivers/iommu/mtk_iommu_v1.c | 742 +++++++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt; &gt;   4 files changed, 765 insertions(+)</span>
<span class="quote">&gt; &gt;   create mode 100644 drivers/iommu/mtk_iommu_v1.c</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; diff --git a/drivers/iommu/Kconfig b/drivers/iommu/Kconfig</span>
<span class="quote">&gt; &gt; index dd1dc39..2e17d70 100644</span>
<span class="quote">&gt; &gt; --- a/drivers/iommu/Kconfig</span>
<span class="quote">&gt; &gt; +++ b/drivers/iommu/Kconfig</span>
<span class="quote">&gt; &gt; @@ -354,4 +354,23 @@ config MTK_IOMMU</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;   	  If unsure, say N here.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; +config MTK_IOMMU_V1</span>
<span class="quote">&gt; &gt; +	bool &quot;MTK IOMMU Version 1 (M4U gen1) Support&quot;</span>
<span class="quote">&gt; &gt; +	depends on ARM || ARM64</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The commit message states that gen1 shipped in 32-bit hardware, and </span>
<span class="quote">&gt; 64-bit hardware has gen2, which implies that ARM64 here is unnecessary - </span>
<span class="quote">&gt; does any SoC with 64it-capable CPUs and a gen1 IOMMU actually exist?</span>

Thanks, there&#39;s no any SoC with ARM64 CPUs and gen1 IOMMU for now, I
will remove the un-necessary dependency.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +	depends on ARCH_MEDIATEK || COMPILE_TEST</span>
<span class="quote">&gt; &gt; +	select ARM_DMA_USE_IOMMU</span>
<span class="quote">&gt; &gt; +	select IOMMU_API</span>
<span class="quote">&gt; &gt; +	select IOMMU_DMA</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Either way you don&#39;t need this - arm64 already selects it as necessary, </span>
<span class="quote">&gt; and it&#39;s not used on 32-bit.</span>

Thanks.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +	select MEMORY</span>
<span class="quote">&gt; &gt; +	select MTK_SMI</span>
<span class="quote">&gt; &gt; +	select COMMON_CLK_MT2701_MMSYS</span>
<span class="quote">&gt; &gt; +	select COMMON_CLK_MT2701_IMGSYS</span>
<span class="quote">&gt; &gt; +	select COMMON_CLK_MT2701_VDECSYS</span>
<span class="quote">&gt; &gt; +	help</span>
<span class="quote">&gt; &gt; +	  Support for the M4U on certain Mediatek SoCs. M4U generation 1 HW is</span>
<span class="quote">&gt; &gt; +	  Multimedia Memory Managememt Unit. This option enables remapping of</span>
<span class="quote">&gt; &gt; +	  DMA memory accesses for the multimedia subsystem.</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	  if unsure, say N here.</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt;   endif # IOMMU_SUPPORT</span>
<span class="quote">&gt; &gt; diff --git a/drivers/iommu/Makefile b/drivers/iommu/Makefile</span>
<span class="quote">&gt; &gt; index c6edb31..778baf5 100644</span>
<span class="quote">&gt; &gt; --- a/drivers/iommu/Makefile</span>
<span class="quote">&gt; &gt; +++ b/drivers/iommu/Makefile</span>
<span class="quote">&gt; &gt; @@ -18,6 +18,7 @@ obj-$(CONFIG_INTEL_IOMMU_SVM) += intel-svm.o</span>
<span class="quote">&gt; &gt;   obj-$(CONFIG_IPMMU_VMSA) += ipmmu-vmsa.o</span>
<span class="quote">&gt; &gt;   obj-$(CONFIG_IRQ_REMAP) += intel_irq_remapping.o irq_remapping.o</span>
<span class="quote">&gt; &gt;   obj-$(CONFIG_MTK_IOMMU) += mtk_iommu.o</span>
<span class="quote">&gt; &gt; +obj-$(CONFIG_MTK_IOMMU_V1) += mtk_iommu_v1.o</span>
<span class="quote">&gt; &gt;   obj-$(CONFIG_OMAP_IOMMU) += omap-iommu.o</span>
<span class="quote">&gt; &gt;   obj-$(CONFIG_OMAP_IOMMU_DEBUG) += omap-iommu-debug.o</span>
<span class="quote">&gt; &gt;   obj-$(CONFIG_ROCKCHIP_IOMMU) += rockchip-iommu.o</span>
<span class="quote">&gt; &gt; diff --git a/drivers/iommu/mtk_iommu.h b/drivers/iommu/mtk_iommu.h</span>
<span class="quote">&gt; &gt; index 5656355..8d60f21 100644</span>
<span class="quote">&gt; &gt; --- a/drivers/iommu/mtk_iommu.h</span>
<span class="quote">&gt; &gt; +++ b/drivers/iommu/mtk_iommu.h</span>
<span class="quote">&gt; &gt; @@ -48,6 +48,9 @@ struct mtk_iommu_domain {</span>
<span class="quote">&gt; &gt;   	struct io_pgtable_ops		*iop;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;   	struct iommu_domain		domain;</span>
<span class="quote">&gt; &gt; +	void				*pgt_va;</span>
<span class="quote">&gt; &gt; +	dma_addr_t			pgt_pa;</span>
<span class="quote">&gt; &gt; +	void				*cookie;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; These are going to be mutually exclusive with the cfg and iop members, </span>
<span class="quote">&gt; which implies it might be a good idea to use a union and not waste </span>
<span class="quote">&gt; space. Or better, just forward-declare struct mtk_iommu_domain here and </span>
<span class="quote">&gt; leave separate definitions private to each driver. The void *cookie is </span>
<span class="quote">&gt; also an unnecessary level of abstraction, I think.</span>
<span class="quote">&gt; </span>

Do you mean declare struct mtk_iommu_domain here, and implement a new
struct in mtk_iommu_v1.c like
struct mtk_iommu_domain_v1 {
	struct mtk_iommu_domain	domain;
	u32			*pgt_va;
	dma_addr_t		pgt_pa;
	mtk_iommu_data		*data;
};
If this is acceptable I would implement it in the next version.
<span class="quote">
&gt; &gt;   };</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;   struct mtk_iommu_data {</span>
<span class="quote">&gt; &gt; diff --git a/drivers/iommu/mtk_iommu_v1.c b/drivers/iommu/mtk_iommu_v1.c</span>
<span class="quote">&gt; &gt; new file mode 100644</span>
<span class="quote">&gt; &gt; index 0000000..55023e1</span>
<span class="quote">&gt; &gt; --- /dev/null</span>
<span class="quote">&gt; &gt; +++ b/drivers/iommu/mtk_iommu_v1.c</span>
<span class="quote">&gt; &gt; @@ -0,0 +1,742 @@</span>
<span class="quote">&gt; &gt; +/*</span>
<span class="quote">&gt; &gt; + * Copyright (c) 2015-2016 MediaTek Inc.</span>
<span class="quote">&gt; &gt; + * Author: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Nit: is that in the sense that this patch should also have Yong&#39;s </span>
<span class="quote">&gt; signed-off-by on it, or in that it&#39;s your work derived from his version </span>
<span class="quote">&gt; in mtk_iommu.c?</span>

I write this driver based on Yong&#39;s version of mtk_iommu.c, should I add
his signed-off-by for this patch? Or should I put a comment about this?
Thanks.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; + *</span>
<span class="quote">&gt; &gt; + * This program is free software; you can redistribute it and/or modify</span>
<span class="quote">&gt; &gt; + * it under the terms of the GNU General Public License version 2 as</span>
<span class="quote">&gt; &gt; + * published by the Free Software Foundation.</span>
<span class="quote">&gt; &gt; + *</span>
<span class="quote">&gt; &gt; + * This program is distributed in the hope that it will be useful,</span>
<span class="quote">&gt; &gt; + * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="quote">&gt; &gt; + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="quote">&gt; &gt; + * GNU General Public License for more details.</span>
<span class="quote">&gt; &gt; + */</span>
<span class="quote">&gt; &gt; +#include &lt;linux/bootmem.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/bug.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/clk.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/component.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/device.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/dma-iommu.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/err.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/interrupt.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/io.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/iommu.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/iopoll.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/kmemleak.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/list.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/of_address.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/of_iommu.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/of_irq.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/of_platform.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/platform_device.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/slab.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/spinlock.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;asm/barrier.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;asm/dma-iommu.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/module.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;dt-bindings/memory/mt2701-larb-port.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;soc/mediatek/smi.h&gt;</span>
<span class="quote">&gt; &gt; +#include &quot;mtk_iommu.h&quot;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define REG_MMU_PT_BASE_ADDR			0x000</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define F_ALL_INVLD				0x2</span>
<span class="quote">&gt; &gt; +#define F_MMU_INV_RANGE				0x1</span>
<span class="quote">&gt; &gt; +#define F_INVLD_EN0				BIT(0)</span>
<span class="quote">&gt; &gt; +#define F_INVLD_EN1				BIT(1)</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define F_MMU_FAULT_VA_MSK			0xfffff000</span>
<span class="quote">&gt; &gt; +#define MTK_PROTECT_PA_ALIGN			128</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define REG_MMU_CTRL_REG			0x210</span>
<span class="quote">&gt; &gt; +#define F_MMU_CTRL_COHERENT_EN			BIT(8)</span>
<span class="quote">&gt; &gt; +#define REG_MMU_IVRP_PADDR			0x214</span>
<span class="quote">&gt; &gt; +#define REG_MMU_INT_CONTROL			0x220</span>
<span class="quote">&gt; &gt; +#define F_INT_TRANSLATION_FAULT			BIT(0)</span>
<span class="quote">&gt; &gt; +#define F_INT_MAIN_MULTI_HIT_FAULT		BIT(1)</span>
<span class="quote">&gt; &gt; +#define F_INT_INVALID_PA_FAULT			BIT(2)</span>
<span class="quote">&gt; &gt; +#define F_INT_ENTRY_REPLACEMENT_FAULT		BIT(3)</span>
<span class="quote">&gt; &gt; +#define F_INT_TABLE_WALK_FAULT			BIT(4)</span>
<span class="quote">&gt; &gt; +#define F_INT_TLB_MISS_FAULT			BIT(5)</span>
<span class="quote">&gt; &gt; +#define F_INT_PFH_DMA_FIFO_OVERFLOW		BIT(6)</span>
<span class="quote">&gt; &gt; +#define F_INT_MISS_DMA_FIFO_OVERFLOW		BIT(7)</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define F_MMU_TF_PROTECT_SEL(prot)		(((prot) &amp; 0x3) &lt;&lt; 5)</span>
<span class="quote">&gt; &gt; +#define F_INT_CLR_BIT				BIT(12)</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define REG_MMU_FAULT_ST			0x224</span>
<span class="quote">&gt; &gt; +#define REG_MMU_FAULT_VA			0x228</span>
<span class="quote">&gt; &gt; +#define REG_MMU_INVLD_PA			0x22C</span>
<span class="quote">&gt; &gt; +#define REG_MMU_INT_ID				0x388</span>
<span class="quote">&gt; &gt; +#define REG_MMU_INVALIDATE			0x5c0</span>
<span class="quote">&gt; &gt; +#define REG_MMU_INVLD_START_A			0x5c4</span>
<span class="quote">&gt; &gt; +#define REG_MMU_INVLD_END_A			0x5c8</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define REG_MMU_INV_SEL				0x5d8</span>
<span class="quote">&gt; &gt; +#define REG_MMU_STANDARD_AXI_MODE		0x5e8</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define REG_MMU_DCM				0x5f0</span>
<span class="quote">&gt; &gt; +#define F_MMU_DCM_ON				BIT(1)</span>
<span class="quote">&gt; &gt; +#define REG_MMU_CPE_DONE			0x60c</span>
<span class="quote">&gt; &gt; +#define F_DESC_VALID				0x2</span>
<span class="quote">&gt; &gt; +#define F_DESC_NONSEC				BIT(3)</span>
<span class="quote">&gt; &gt; +#define MT2701_M4U_TF_LARB(TF)			(6 - (((TF) &gt;&gt; 13) &amp; 0x7))</span>
<span class="quote">&gt; &gt; +#define MT2701_M4U_TF_PORT(TF)			(((TF) &gt;&gt; 8) &amp; 0xF)</span>
<span class="quote">&gt; &gt; +/* MTK generation one iommu HW only support 4K size mapping */</span>
<span class="quote">&gt; &gt; +#define MT2701_IOMMU_PAGE_SHIFT			12</span>
<span class="quote">&gt; &gt; +#define MT2701_IOMMU_PAGE_SIZE			(1UL &lt;&lt; MT2701_IOMMU_PAGE_SHIFT)</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +/*</span>
<span class="quote">&gt; &gt; + * MTK m4u support 4GB iova address space, and oly support 4K page</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Nit: s/oly/only/</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; + * mapping. So the pagetable size should be exactly as 4M.</span>
<span class="quote">&gt; &gt; + */</span>
<span class="quote">&gt; &gt; +#define M2701_IOMMU_PGT_SIZE			SZ_4M</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static const int mt2701_m4u_in_larb[] = {</span>
<span class="quote">&gt; &gt; +	LARB0_PORT_OFFSET, LARB1_PORT_OFFSET,</span>
<span class="quote">&gt; &gt; +	LARB2_PORT_OFFSET, LARB3_PORT_OFFSET</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static inline int mt2701_m4u_to_larb(int id)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	int i;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	for (i = ARRAY_SIZE(mt2701_m4u_in_larb); i &gt;= 0; i--)</span>
<span class="quote">&gt; &gt; +		if ((id) &gt;= mt2701_m4u_in_larb[i])</span>
<span class="quote">&gt; &gt; +			return i;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; As far as I can tell, this is going to dereference mt2701_m4u_in_larb[4] </span>
<span class="quote">&gt; on the first iteration. Not good.</span>

Thanks, I will fix this in the next version.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static inline int mt2701_m4u_to_port(int id)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	int larb = mt2701_m4u_to_larb(id);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return id - mt2701_m4u_in_larb[larb];</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void mtk_iommu_tlb_flush_all(void *cookie)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_data *data = cookie;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; You&#39;re not bound by the using the io-pgtable TLB ops interface here, so </span>
<span class="quote">&gt; just make the argument of type struct mtk_iommu_data*.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0,</span>
<span class="quote">&gt; &gt; +			data-&gt;base + REG_MMU_INV_SEL);</span>
<span class="quote">&gt; &gt; +	writel_relaxed(F_ALL_INVLD, data-&gt;base + REG_MMU_INVALIDATE);</span>
<span class="quote">&gt; &gt; +	wmb(); /* Make sure the tlb flush all done */</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void mtk_iommu_tlb_flush_range(void *cookie,</span>
<span class="quote">&gt; &gt; +				unsigned long iova, size_t size)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_data *data = cookie;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Ditto.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +	int ret;</span>
<span class="quote">&gt; &gt; +	u32 tmp;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0,</span>
<span class="quote">&gt; &gt; +		data-&gt;base + REG_MMU_INV_SEL);</span>
<span class="quote">&gt; &gt; +	writel_relaxed(iova &amp; F_MMU_FAULT_VA_MSK,</span>
<span class="quote">&gt; &gt; +		data-&gt;base + REG_MMU_INVLD_START_A);</span>
<span class="quote">&gt; &gt; +	writel_relaxed((iova + size - 1) &amp; F_MMU_FAULT_VA_MSK,</span>
<span class="quote">&gt; &gt; +		data-&gt;base + REG_MMU_INVLD_END_A);</span>
<span class="quote">&gt; &gt; +	writel_relaxed(F_MMU_INV_RANGE, data-&gt;base + REG_MMU_INVALIDATE);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = readl_poll_timeout_atomic(data-&gt;base + REG_MMU_CPE_DONE,</span>
<span class="quote">&gt; &gt; +				tmp, tmp != 0, 10, 100000);</span>
<span class="quote">&gt; &gt; +	if (ret) {</span>
<span class="quote">&gt; &gt; +		dev_warn(data-&gt;dev,</span>
<span class="quote">&gt; &gt; +			 &quot;Partial TLB flush timed out, falling back to full flush\n&quot;);</span>
<span class="quote">&gt; &gt; +		mtk_iommu_tlb_flush_all(cookie);</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +	/* Clear the CPE status */</span>
<span class="quote">&gt; &gt; +	writel_relaxed(0, data-&gt;base + REG_MMU_CPE_DONE);</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static irqreturn_t mtk_iommu_isr(int irq, void *dev_id)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_data *data = dev_id;</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_domain *dom = data-&gt;m4u_dom;</span>
<span class="quote">&gt; &gt; +	u32 int_state, regval, fault_iova, fault_pa;</span>
<span class="quote">&gt; &gt; +	unsigned int fault_larb, fault_port;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* Read error information from registers */</span>
<span class="quote">&gt; &gt; +	int_state = readl_relaxed(data-&gt;base + REG_MMU_FAULT_ST);</span>
<span class="quote">&gt; &gt; +	fault_iova = readl_relaxed(data-&gt;base + REG_MMU_FAULT_VA);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	fault_iova &amp;= F_MMU_FAULT_VA_MSK;</span>
<span class="quote">&gt; &gt; +	fault_pa = readl_relaxed(data-&gt;base + REG_MMU_INVLD_PA);</span>
<span class="quote">&gt; &gt; +	regval = readl_relaxed(data-&gt;base + REG_MMU_INT_ID);</span>
<span class="quote">&gt; &gt; +	fault_larb = MT2701_M4U_TF_LARB(regval);</span>
<span class="quote">&gt; &gt; +	fault_port = MT2701_M4U_TF_PORT(regval);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/*</span>
<span class="quote">&gt; &gt; +	 * MTK v1 iommu HW could not determin whether the fault is read or</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Nit: s/determin/determine/</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +	 * write fault, report as read fault.</span>
<span class="quote">&gt; &gt; +	 */</span>
<span class="quote">&gt; &gt; +	if (report_iommu_fault(&amp;dom-&gt;domain, data-&gt;dev, fault_iova,</span>
<span class="quote">&gt; &gt; +			IOMMU_FAULT_READ))</span>
<span class="quote">&gt; &gt; +		dev_err_ratelimited(data-&gt;dev,</span>
<span class="quote">&gt; &gt; +			&quot;fault type=0x%x iova=0x%x pa=0x%x larb=%d port=%d\n&quot;,</span>
<span class="quote">&gt; &gt; +			int_state, fault_iova, fault_pa,</span>
<span class="quote">&gt; &gt; +			fault_larb, fault_port);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* Interrupt clear */</span>
<span class="quote">&gt; &gt; +	regval = readl_relaxed(data-&gt;base + REG_MMU_INT_CONTROL);</span>
<span class="quote">&gt; &gt; +	regval |= F_INT_CLR_BIT;</span>
<span class="quote">&gt; &gt; +	writel_relaxed(regval, data-&gt;base + REG_MMU_INT_CONTROL);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	mtk_iommu_tlb_flush_all(data);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return IRQ_HANDLED;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void mtk_iommu_config(struct mtk_iommu_data *data,</span>
<span class="quote">&gt; &gt; +			     struct device *dev, bool enable)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_client_priv *head, *cur, *next;</span>
<span class="quote">&gt; &gt; +	struct mtk_smi_larb_iommu    *larb_mmu;</span>
<span class="quote">&gt; &gt; +	unsigned int                 larbid, portid;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	head = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; &gt; +	list_for_each_entry_safe(cur, next, &amp;head-&gt;client, client) {</span>
<span class="quote">&gt; &gt; +		larbid = mt2701_m4u_to_larb(cur-&gt;mtk_m4u_id);</span>
<span class="quote">&gt; &gt; +		portid = mt2701_m4u_to_port(cur-&gt;mtk_m4u_id);</span>
<span class="quote">&gt; &gt; +		larb_mmu = &amp;data-&gt;smi_imu.larb_imu[larbid];</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +		dev_dbg(dev, &quot;%s iommu port: %d\n&quot;,</span>
<span class="quote">&gt; &gt; +			enable ? &quot;enable&quot; : &quot;disable&quot;, portid);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +		if (enable)</span>
<span class="quote">&gt; &gt; +			larb_mmu-&gt;mmu |= MTK_SMI_MMU_EN(portid);</span>
<span class="quote">&gt; &gt; +		else</span>
<span class="quote">&gt; &gt; +			larb_mmu-&gt;mmu &amp;= ~MTK_SMI_MMU_EN(portid);</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void *mtk_iommu_alloc_pgt(struct device *dev,</span>
<span class="quote">&gt; &gt; +				dma_addr_t *dma, gfp_t gfp)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	void *pages = dma_alloc_coherent(dev,</span>
<span class="quote">&gt; &gt; +				M2701_IOMMU_PGT_SIZE, dma, gfp | __GFP_ZERO);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; There&#39;s a dma_zalloc_coherent() wrapper macro you can use for that.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (!pages)</span>
<span class="quote">&gt; &gt; +		return NULL;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	kmemleak_ignore(pages);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Kmemleak should be able to find the live reference in dom-&gt;pgt_va, so </span>
<span class="quote">&gt; this is unnecessary - it&#39;s only there in the other code because of the </span>
<span class="quote">&gt; tracking-allocations-by-physical-address trickery which you&#39;ve otherwise </span>
<span class="quote">&gt; gotten rid of here.</span>

Thanks, I will remove the un-necessary kmemleak_ignore.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +	return pages;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void mtk_iommu_free_pgt(struct device *dev,</span>
<span class="quote">&gt; &gt; +				void *pages, dma_addr_t dma)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	dma_free_coherent(dev, M2701_IOMMU_PGT_SIZE, pages, dma);</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; In fact, I&#39;d just inline the dma_{alloc,free} calls at the callsites of </span>
<span class="quote">&gt; these functions, since they&#39;re sufficiently self-documenting.</span>

Thanks, I will use dma_zalloc_coherent and put it inline.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_domain_finalise(struct mtk_iommu_data *data)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_domain *dom = data-&gt;m4u_dom;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	spin_lock_init(&amp;dom-&gt;pgtlock);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	dom-&gt;pgt_va = mtk_iommu_alloc_pgt(data-&gt;dev,</span>
<span class="quote">&gt; &gt; +				&amp;dom-&gt;pgt_pa, GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +	if (!dom-&gt;pgt_va)</span>
<span class="quote">&gt; &gt; +		return -ENOMEM;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	writel(dom-&gt;pgt_pa, data-&gt;base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	dom-&gt;cookie = (void *)data;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static struct iommu_domain *mtk_iommu_domain_alloc(unsigned type)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_domain *dom;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (type != IOMMU_DOMAIN_UNMANAGED)</span>
<span class="quote">&gt; &gt; +		return NULL;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	dom = kzalloc(sizeof(*dom), GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +	if (!dom)</span>
<span class="quote">&gt; &gt; +		return NULL;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return &amp;dom-&gt;domain;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void mtk_iommu_domain_free(struct iommu_domain *domain)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The page table belongs to the domain, so it should be freed from here, </span>
<span class="quote">&gt; not anywhere else.</span>

Thanks, I would put it here.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +	kfree(to_mtk_domain(domain));</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_attach_device(struct iommu_domain *domain,</span>
<span class="quote">&gt; &gt; +				   struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_client_priv *priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_data *data;</span>
<span class="quote">&gt; &gt; +	int ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (!priv)</span>
<span class="quote">&gt; &gt; +		return -ENODEV;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt; &gt; +	if (!data-&gt;m4u_dom) {</span>
<span class="quote">&gt; &gt; +		data-&gt;m4u_dom = dom;</span>
<span class="quote">&gt; &gt; +		ret = mtk_iommu_domain_finalise(data);</span>
<span class="quote">&gt; &gt; +		if (ret) {</span>
<span class="quote">&gt; &gt; +			data-&gt;m4u_dom = NULL;</span>
<span class="quote">&gt; &gt; +			return ret;</span>
<span class="quote">&gt; &gt; +		}</span>
<span class="quote">&gt; &gt; +	} else if (data-&gt;m4u_dom != dom) {</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This will never happen, because you make sure all devices are in the </span>
<span class="quote">&gt; same group, so the IOMMU core code will always call you with the same </span>
<span class="quote">&gt; domain here. You can safely just attach dev to dom.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +		/* All the client devices should be in the same m4u domain */</span>
<span class="quote">&gt; &gt; +		dev_err(dev, &quot;try to attach into the error iommu domain\n&quot;);</span>
<span class="quote">&gt; &gt; +		return -EPERM;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	mtk_iommu_config(data, dev, true);</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void mtk_iommu_detach_device(struct iommu_domain *domain,</span>
<span class="quote">&gt; &gt; +				    struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_client_priv *priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_data *data;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (!priv)</span>
<span class="quote">&gt; &gt; +		return;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt; &gt; +	mtk_iommu_config(data, dev, false);</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_map(struct iommu_domain *domain, unsigned long iova,</span>
<span class="quote">&gt; &gt; +			 phys_addr_t paddr, size_t size, int prot)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_data *data = dom-&gt;cookie;</span>
<span class="quote">&gt; &gt; +	unsigned int page_num = size &gt;&gt; MT2701_IOMMU_PAGE_SHIFT;</span>
<span class="quote">&gt; &gt; +	unsigned long flags;</span>
<span class="quote">&gt; &gt; +	unsigned int i;</span>
<span class="quote">&gt; &gt; +	u32 *pgt_base_iova = dom-&gt;pgt_va;</span>
<span class="quote">&gt; &gt; +	u32 pabase = (u32)paddr;</span>
<span class="quote">&gt; &gt; +	int map_size = 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	spin_lock_irqsave(&amp;dom-&gt;pgtlock, flags);</span>
<span class="quote">&gt; &gt; +	pgt_base_iova += iova  &gt;&gt; MT2701_IOMMU_PAGE_SHIFT;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It took me a while to figure out why this isn&#39;t just part of the </span>
<span class="quote">&gt; initialisation expression; just make dom-&gt;pgt_va a u32* so that it can be.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +	for (i = 0; i &lt; page_num; i++) {</span>
<span class="quote">&gt; &gt; +		if (pgt_base_iova[i])</span>
<span class="quote">&gt; &gt; +			break;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The error case also needs to roll back any partial mapping it&#39;s managed </span>
<span class="quote">&gt; so far - otherwise you end up making the initial problem worse by </span>
<span class="quote">&gt; leaving behind yet more unexpected PTEs in areas that the caller thinks </span>
<span class="quote">&gt; are unmapped.</span>

Yes, I will update this in the next version.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +		pgt_base_iova[i] = pabase | F_DESC_VALID | F_DESC_NONSEC;</span>
<span class="quote">&gt; &gt; +		pabase += MT2701_IOMMU_PAGE_SIZE;</span>
<span class="quote">&gt; &gt; +		map_size += MT2701_IOMMU_PAGE_SIZE;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	spin_unlock_irqrestore(&amp;dom-&gt;pgtlock, flags);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	mtk_iommu_tlb_flush_range(data, iova, size);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return map_size == size ? 0 : -EEXIST;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static size_t mtk_iommu_unmap(struct iommu_domain *domain,</span>
<span class="quote">&gt; &gt; +			      unsigned long iova, size_t size)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_data *data = dom-&gt;cookie;</span>
<span class="quote">&gt; &gt; +	unsigned long flags;</span>
<span class="quote">&gt; &gt; +	u32 *pgt_base_iova = dom-&gt;pgt_va;</span>
<span class="quote">&gt; &gt; +	unsigned int page_num = size &gt;&gt; MT2701_IOMMU_PAGE_SHIFT;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	spin_lock_irqsave(&amp;dom-&gt;pgtlock, flags);</span>
<span class="quote">&gt; &gt; +	pgt_base_iova += iova  &gt;&gt; MT2701_IOMMU_PAGE_SHIFT;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Same complaint as for mtk_iommu_map().</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +	memset(pgt_base_iova, 0, page_num * sizeof(u32));</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	spin_unlock_irqrestore(&amp;dom-&gt;pgtlock, flags);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	mtk_iommu_tlb_flush_range(data, iova, size);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return size;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static phys_addr_t mtk_iommu_iova_to_phys(struct iommu_domain *domain,</span>
<span class="quote">&gt; &gt; +					  dma_addr_t iova)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="quote">&gt; &gt; +	unsigned long flags;</span>
<span class="quote">&gt; &gt; +	phys_addr_t pa;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	spin_lock_irqsave(&amp;dom-&gt;pgtlock, flags);</span>
<span class="quote">&gt; &gt; +	pa = *((u32 *)((u32 *)dom-&gt;pgt_va + (iova &gt;&gt; MT2701_IOMMU_PAGE_SHIFT)));</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Yikes! _Definitely_ make dom-&gt;pgt_va a u32*.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +	pa = pa &amp; (~(MT2701_IOMMU_PAGE_SIZE - 1));</span>
<span class="quote">&gt; &gt; +	spin_unlock_irqrestore(&amp;dom-&gt;pgtlock, flags);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return pa;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +/*</span>
<span class="quote">&gt; &gt; + * MTK generaion one iommu HW only support one iommu domain, and all the client</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Nit: s/generaion/generation/</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; + * sharing the same iova address space.</span>
<span class="quote">&gt; &gt; + */</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_create_mapping(struct device *dev,</span>
<span class="quote">&gt; &gt; +				    struct of_phandle_args *args)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_client_priv *head, *priv, *next;</span>
<span class="quote">&gt; &gt; +	struct platform_device *m4updev;</span>
<span class="quote">&gt; &gt; +	struct dma_iommu_mapping *mtk_mapping;</span>
<span class="quote">&gt; &gt; +	struct device *m4udev;</span>
<span class="quote">&gt; &gt; +	int ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (args-&gt;args_count != 1) {</span>
<span class="quote">&gt; &gt; +		dev_err(dev, &quot;invalid #iommu-cells(%d) property for IOMMU\n&quot;,</span>
<span class="quote">&gt; &gt; +			args-&gt;args_count);</span>
<span class="quote">&gt; &gt; +		return -EINVAL;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (!dev-&gt;archdata.iommu) {</span>
<span class="quote">&gt; &gt; +		/* Get the m4u device */</span>
<span class="quote">&gt; &gt; +		m4updev = of_find_device_by_node(args-&gt;np);</span>
<span class="quote">&gt; &gt; +		of_node_put(args-&gt;np);</span>
<span class="quote">&gt; &gt; +		if (WARN_ON(!m4updev))</span>
<span class="quote">&gt; &gt; +			return -EINVAL;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +		head = kzalloc(sizeof(*head), GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +		if (!head)</span>
<span class="quote">&gt; &gt; +			return -ENOMEM;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +		dev-&gt;archdata.iommu = head;</span>
<span class="quote">&gt; &gt; +		INIT_LIST_HEAD(&amp;head-&gt;client);</span>
<span class="quote">&gt; &gt; +		head-&gt;m4udev = &amp;m4updev-&gt;dev;</span>
<span class="quote">&gt; &gt; +	} else {</span>
<span class="quote">&gt; &gt; +		head = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +	if (!priv) {</span>
<span class="quote">&gt; &gt; +		ret = -ENOMEM;</span>
<span class="quote">&gt; &gt; +		goto err_free_mem;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +	priv-&gt;mtk_m4u_id = args-&gt;args[0];</span>
<span class="quote">&gt; &gt; +	list_add_tail(&amp;priv-&gt;client, &amp;head-&gt;client);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	m4udev = head-&gt;m4udev;</span>
<span class="quote">&gt; &gt; +	mtk_mapping = m4udev-&gt;archdata.iommu;</span>
<span class="quote">&gt; &gt; +	if (!mtk_mapping) {</span>
<span class="quote">&gt; &gt; +		/* MTK iommu support 4GB iova address space. */</span>
<span class="quote">&gt; &gt; +		mtk_mapping = arm_iommu_create_mapping(&amp;platform_bus_type,</span>
<span class="quote">&gt; &gt; +						0, 1ULL &lt;&lt; 32);</span>
<span class="quote">&gt; &gt; +		if (IS_ERR(mtk_mapping)) {</span>
<span class="quote">&gt; &gt; +			ret = PTR_ERR(mtk_mapping);</span>
<span class="quote">&gt; &gt; +			goto err_free_mem;</span>
<span class="quote">&gt; &gt; +		}</span>
<span class="quote">&gt; &gt; +		m4udev-&gt;archdata.iommu = mtk_mapping;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = arm_iommu_attach_device(dev, mtk_mapping);</span>
<span class="quote">&gt; &gt; +	if (ret)</span>
<span class="quote">&gt; &gt; +		goto err_release_mapping;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +err_release_mapping:</span>
<span class="quote">&gt; &gt; +	arm_iommu_release_mapping(mtk_mapping);</span>
<span class="quote">&gt; &gt; +	m4udev-&gt;archdata.iommu = NULL;</span>
<span class="quote">&gt; &gt; +err_free_mem:</span>
<span class="quote">&gt; &gt; +	list_for_each_entry_safe(priv, next, &amp;head-&gt;client, client)</span>
<span class="quote">&gt; &gt; +		kfree(priv);</span>
<span class="quote">&gt; &gt; +	kfree(head);</span>
<span class="quote">&gt; &gt; +	dev-&gt;archdata.iommu = NULL;</span>
<span class="quote">&gt; &gt; +	return ret;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_add_device(struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct iommu_group *group;</span>
<span class="quote">&gt; &gt; +	struct device_node *np;</span>
<span class="quote">&gt; &gt; +	struct of_phandle_args iommu_spec;</span>
<span class="quote">&gt; &gt; +	int idx = 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	while (!of_parse_phandle_with_args(dev-&gt;of_node, &quot;iommus&quot;,</span>
<span class="quote">&gt; &gt; +				   &quot;#iommu-cells&quot;, idx,</span>
<span class="quote">&gt; &gt; +				   &amp;iommu_spec)) {</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hang on, this doesn&#39;t seem right - why do you need to reimplement all </span>
<span class="quote">&gt; this instead of using IOMMU_OF_DECLARE()?</span>

All the clients of mtk generation one iommu share the same iommu domain,
as a matter of fact, mtk generation one iommu only support one iommu
domain. ALl the clients share the same iova address and use the same
pagetable. That means all iommu clients needed to be attached to the
same dma_iommu_mapping.

If use IOMMU_OF_DELCARE, we need to call of_iommu_set_ops to set the
iommu_ops, I do not want the iommu_ops be set since it would cause iommu
client device in different dma_iommu_mapping.

When an iommu client device has been created, the following sequence is
called.

of_platform_device_create
	-&gt;of_dma_config
		-&gt;arch_setup_dma_ops
			-&gt;arch_setup_iommu_dma_ops
In this function of arch_setup_iommu_dma_ops would create a new
dma_iommu_mapping for each iommu client device and then attach the
device to this new dma_iommu_mapping. Since all the iommu clients share
the very same pagetable, this will not workable for our HW.
I could not release the dma_iommu_mapping in attach_device since the
to_dma_iommu_mapping was set after device_attached.
Any suggest for this?
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +		np = iommu_spec.np;</span>
<span class="quote">&gt; &gt; +		mtk_iommu_create_mapping(dev, &amp;iommu_spec);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +		of_node_put(np);</span>
<span class="quote">&gt; &gt; +		idx++;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (!dev-&gt;archdata.iommu) /* Not a iommu client device */</span>
<span class="quote">&gt; &gt; +		return -ENODEV;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	group = iommu_group_get_for_dev(dev);</span>
<span class="quote">&gt; &gt; +	if (IS_ERR(group))</span>
<span class="quote">&gt; &gt; +		return PTR_ERR(group);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	iommu_group_put(group);</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void mtk_iommu_remove_device(struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_client_priv *head, *cur, *next;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	head = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; &gt; +	if (!head)</span>
<span class="quote">&gt; &gt; +		return;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	list_for_each_entry_safe(cur, next, &amp;head-&gt;client, client) {</span>
<span class="quote">&gt; &gt; +		list_del(&amp;cur-&gt;client);</span>
<span class="quote">&gt; &gt; +		kfree(cur);</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +	kfree(head);</span>
<span class="quote">&gt; &gt; +	dev-&gt;archdata.iommu = NULL;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	iommu_group_remove_device(dev);</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static struct iommu_group *mtk_iommu_device_group(struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_data *data;</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_client_priv *priv;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; &gt; +	if (!priv)</span>
<span class="quote">&gt; &gt; +		return ERR_PTR(-ENODEV);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* All the client devices are in the same m4u iommu-group */</span>
<span class="quote">&gt; &gt; +	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt; &gt; +	if (!data-&gt;m4u_group) {</span>
<span class="quote">&gt; &gt; +		data-&gt;m4u_group = iommu_group_alloc();</span>
<span class="quote">&gt; &gt; +		if (IS_ERR(data-&gt;m4u_group))</span>
<span class="quote">&gt; &gt; +			dev_err(dev, &quot;Failed to allocate M4U IOMMU group\n&quot;);</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +	return data-&gt;m4u_group;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_hw_init(const struct mtk_iommu_data *data)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	u32 regval;</span>
<span class="quote">&gt; &gt; +	int ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = clk_prepare_enable(data-&gt;bclk);</span>
<span class="quote">&gt; &gt; +	if (ret) {</span>
<span class="quote">&gt; &gt; +		dev_err(data-&gt;dev, &quot;Failed to enable iommu bclk(%d)\n&quot;, ret);</span>
<span class="quote">&gt; &gt; +		return ret;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	regval = F_MMU_CTRL_COHERENT_EN | F_MMU_TF_PROTECT_SEL(2);</span>
<span class="quote">&gt; &gt; +	writel_relaxed(regval, data-&gt;base + REG_MMU_CTRL_REG);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	regval = F_INT_TRANSLATION_FAULT |</span>
<span class="quote">&gt; &gt; +		F_INT_MAIN_MULTI_HIT_FAULT |</span>
<span class="quote">&gt; &gt; +		F_INT_INVALID_PA_FAULT |</span>
<span class="quote">&gt; &gt; +		F_INT_ENTRY_REPLACEMENT_FAULT |</span>
<span class="quote">&gt; &gt; +		F_INT_TABLE_WALK_FAULT |</span>
<span class="quote">&gt; &gt; +		F_INT_TLB_MISS_FAULT |</span>
<span class="quote">&gt; &gt; +		F_INT_PFH_DMA_FIFO_OVERFLOW |</span>
<span class="quote">&gt; &gt; +		F_INT_MISS_DMA_FIFO_OVERFLOW;</span>
<span class="quote">&gt; &gt; +	writel_relaxed(regval, data-&gt;base + REG_MMU_INT_CONTROL);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* protect memory,hw will write here while translation fault */</span>
<span class="quote">&gt; &gt; +	writel_relaxed(data-&gt;protect_base,</span>
<span class="quote">&gt; &gt; +			data-&gt;base + REG_MMU_IVRP_PADDR);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	writel_relaxed(F_MMU_DCM_ON, data-&gt;base + REG_MMU_DCM);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (devm_request_irq(data-&gt;dev, data-&gt;irq, mtk_iommu_isr, 0,</span>
<span class="quote">&gt; &gt; +			     dev_name(data-&gt;dev), (void *)data)) {</span>
<span class="quote">&gt; &gt; +		writel_relaxed(0, data-&gt;base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt; &gt; +		clk_disable_unprepare(data-&gt;bclk);</span>
<span class="quote">&gt; &gt; +		dev_err(data-&gt;dev, &quot;Failed @ IRQ-%d Request\n&quot;, data-&gt;irq);</span>
<span class="quote">&gt; &gt; +		return -ENODEV;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static struct iommu_ops mtk_iommu_ops = {</span>
<span class="quote">&gt; &gt; +	.domain_alloc	= mtk_iommu_domain_alloc,</span>
<span class="quote">&gt; &gt; +	.domain_free	= mtk_iommu_domain_free,</span>
<span class="quote">&gt; &gt; +	.attach_dev	= mtk_iommu_attach_device,</span>
<span class="quote">&gt; &gt; +	.detach_dev	= mtk_iommu_detach_device,</span>
<span class="quote">&gt; &gt; +	.map		= mtk_iommu_map,</span>
<span class="quote">&gt; &gt; +	.unmap		= mtk_iommu_unmap,</span>
<span class="quote">&gt; &gt; +	.map_sg		= default_iommu_map_sg,</span>
<span class="quote">&gt; &gt; +	.iova_to_phys	= mtk_iommu_iova_to_phys,</span>
<span class="quote">&gt; &gt; +	.add_device	= mtk_iommu_add_device,</span>
<span class="quote">&gt; &gt; +	.remove_device	= mtk_iommu_remove_device,</span>
<span class="quote">&gt; &gt; +	.device_group	= mtk_iommu_device_group,</span>
<span class="quote">&gt; &gt; +	.pgsize_bitmap	= ~0UL &lt;&lt; MT2701_IOMMU_PAGE_SHIFT,</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static const struct of_device_id mtk_iommu_of_ids[] = {</span>
<span class="quote">&gt; &gt; +	{ .compatible = &quot;mediatek,mt2701-m4u&quot;, },</span>
<span class="quote">&gt; &gt; +	{}</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static const struct component_master_ops mtk_iommu_com_ops = {</span>
<span class="quote">&gt; &gt; +	.bind		= mtk_iommu_bind,</span>
<span class="quote">&gt; &gt; +	.unbind		= mtk_iommu_unbind,</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_data		*data;</span>
<span class="quote">&gt; &gt; +	struct device			*dev = &amp;pdev-&gt;dev;</span>
<span class="quote">&gt; &gt; +	struct resource			*res;</span>
<span class="quote">&gt; &gt; +	struct component_match		*match = NULL;</span>
<span class="quote">&gt; &gt; +	void				*protect;</span>
<span class="quote">&gt; &gt; +	int				i, larb_nr, ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +	if (!data)</span>
<span class="quote">&gt; &gt; +		return -ENOMEM;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	data-&gt;dev = dev;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* Protect memory. HW will access here while translation fault.*/</span>
<span class="quote">&gt; &gt; +	protect = devm_kzalloc(dev, MTK_PROTECT_PA_ALIGN * 2, GFP_KERNEL);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think strictly this ought to have GFP_DMA as well.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +	if (!protect)</span>
<span class="quote">&gt; &gt; +		return -ENOMEM;</span>
<span class="quote">&gt; &gt; +	data-&gt;protect_base = ALIGN(virt_to_phys(protect), MTK_PROTECT_PA_ALIGN);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);</span>
<span class="quote">&gt; &gt; +	data-&gt;base = devm_ioremap_resource(dev, res);</span>
<span class="quote">&gt; &gt; +	if (IS_ERR(data-&gt;base))</span>
<span class="quote">&gt; &gt; +		return PTR_ERR(data-&gt;base);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	data-&gt;irq = platform_get_irq(pdev, 0);</span>
<span class="quote">&gt; &gt; +	if (data-&gt;irq &lt; 0)</span>
<span class="quote">&gt; &gt; +		return data-&gt;irq;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	data-&gt;bclk = devm_clk_get(dev, &quot;bclk&quot;);</span>
<span class="quote">&gt; &gt; +	if (IS_ERR(data-&gt;bclk))</span>
<span class="quote">&gt; &gt; +		return PTR_ERR(data-&gt;bclk);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	larb_nr = of_count_phandle_with_args(dev-&gt;of_node,</span>
<span class="quote">&gt; &gt; +					&quot;mediatek,larbs&quot;, NULL);</span>
<span class="quote">&gt; &gt; +	if (larb_nr &lt; 0)</span>
<span class="quote">&gt; &gt; +		return larb_nr;</span>
<span class="quote">&gt; &gt; +	data-&gt;smi_imu.larb_nr = larb_nr;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	for (i = 0; i &lt; larb_nr; i++) {</span>
<span class="quote">&gt; &gt; +		struct device_node *larbnode;</span>
<span class="quote">&gt; &gt; +		struct platform_device *plarbdev;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Nit: I wonder if the new of_for_each_phandle() iterator might make this </span>
<span class="quote">&gt; larb-discovery logic cleaner? It might be worth a go now that that&#39;s </span>
<span class="quote">&gt; landed in the current merge window.</span>

Thanks, I will take a look at that.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +		larbnode = of_parse_phandle(dev-&gt;of_node, &quot;mediatek,larbs&quot;, i);</span>
<span class="quote">&gt; &gt; +		if (!larbnode)</span>
<span class="quote">&gt; &gt; +			return -EINVAL;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +		if (!of_device_is_available(larbnode))</span>
<span class="quote">&gt; &gt; +			continue;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +		plarbdev = of_find_device_by_node(larbnode);</span>
<span class="quote">&gt; &gt; +		of_node_put(larbnode);</span>
<span class="quote">&gt; &gt; +		if (!plarbdev) {</span>
<span class="quote">&gt; &gt; +			plarbdev = of_platform_device_create(</span>
<span class="quote">&gt; &gt; +						larbnode, NULL,</span>
<span class="quote">&gt; &gt; +						platform_bus_type.dev_root);</span>
<span class="quote">&gt; &gt; +			if (!plarbdev)</span>
<span class="quote">&gt; &gt; +				return -EPROBE_DEFER;</span>
<span class="quote">&gt; &gt; +		}</span>
<span class="quote">&gt; &gt; +		data-&gt;smi_imu.larb_imu[i].dev = &amp;plarbdev-&gt;dev;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +		component_match_add(dev, &amp;match, compare_of, larbnode);</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	platform_set_drvdata(pdev, data);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = mtk_iommu_hw_init(data);</span>
<span class="quote">&gt; &gt; +	if (ret)</span>
<span class="quote">&gt; &gt; +		return ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (!iommu_present(&amp;platform_bus_type))</span>
<span class="quote">&gt; &gt; +		bus_set_iommu(&amp;platform_bus_type,  &amp;mtk_iommu_ops);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return component_master_add_with_match(dev, &amp;mtk_iommu_com_ops, match);</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_remove(struct platform_device *pdev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_data *data = platform_get_drvdata(pdev);</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_domain *dom = data-&gt;m4u_dom;</span>
<span class="quote">&gt; &gt; +	struct device *dev = &amp;pdev-&gt;dev;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	mtk_iommu_free_pgt(dev, dom-&gt;pgt_va, dom-&gt;pgt_pa);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (iommu_present(&amp;platform_bus_type))</span>
<span class="quote">&gt; &gt; +		bus_set_iommu(&amp;platform_bus_type, NULL);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	clk_disable_unprepare(data-&gt;bclk);</span>
<span class="quote">&gt; &gt; +	devm_free_irq(&amp;pdev-&gt;dev, data-&gt;irq, data);</span>
<span class="quote">&gt; &gt; +	component_master_del(&amp;pdev-&gt;dev, &amp;mtk_iommu_com_ops);</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int __maybe_unused mtk_iommu_suspend(struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_data *data = dev_get_drvdata(dev);</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_suspend_reg *reg = &amp;data-&gt;reg;</span>
<span class="quote">&gt; &gt; +	void __iomem *base = data-&gt;base;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	reg-&gt;standard_axi_mode = readl_relaxed(base +</span>
<span class="quote">&gt; &gt; +					       REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt; &gt; +	reg-&gt;dcm_dis = readl_relaxed(base + REG_MMU_DCM);</span>
<span class="quote">&gt; &gt; +	reg-&gt;ctrl_reg = readl_relaxed(base + REG_MMU_CTRL_REG);</span>
<span class="quote">&gt; &gt; +	reg-&gt;int_control0 = readl_relaxed(base + REG_MMU_INT_CONTROL);</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int __maybe_unused mtk_iommu_resume(struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_data *data = dev_get_drvdata(dev);</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_suspend_reg *reg = &amp;data-&gt;reg;</span>
<span class="quote">&gt; &gt; +	void __iomem *base = data-&gt;base;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	writel_relaxed(data-&gt;m4u_dom-&gt;pgt_pa, base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hmm, this looks like the only case where m4u_dom actually seems </span>
<span class="quote">&gt; necessary - I&#39;m pretty sure all the others could be fairly easily </span>
<span class="quote">&gt; reworked to not use it (I might try having a quick hack at the existing </span>
<span class="quote">&gt; M4U driver to see) - at which point we could just explicitly </span>
<span class="quote">&gt; save/restore the base register here and get rid of m4u_dom entirely.</span>

Let me take a while to think about this.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +	writel_relaxed(reg-&gt;standard_axi_mode,</span>
<span class="quote">&gt; &gt; +		       base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt; &gt; +	writel_relaxed(reg-&gt;dcm_dis, base + REG_MMU_DCM);</span>
<span class="quote">&gt; &gt; +	writel_relaxed(reg-&gt;ctrl_reg, base + REG_MMU_CTRL_REG);</span>
<span class="quote">&gt; &gt; +	writel_relaxed(reg-&gt;int_control0, base + REG_MMU_INT_CONTROL);</span>
<span class="quote">&gt; &gt; +	writel_relaxed(data-&gt;protect_base, base + REG_MMU_IVRP_PADDR);</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +const struct dev_pm_ops mtk_iommu_pm_ops = {</span>
<span class="quote">&gt; &gt; +	SET_SYSTEM_SLEEP_PM_OPS(mtk_iommu_suspend, mtk_iommu_resume)</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static struct platform_driver mtk_iommu_driver = {</span>
<span class="quote">&gt; &gt; +	.probe	= mtk_iommu_probe,</span>
<span class="quote">&gt; &gt; +	.remove	= mtk_iommu_remove,</span>
<span class="quote">&gt; &gt; +	.driver	= {</span>
<span class="quote">&gt; &gt; +		.name = &quot;mtk-iommu&quot;,</span>
<span class="quote">&gt; &gt; +		.of_match_table = mtk_iommu_of_ids,</span>
<span class="quote">&gt; &gt; +		.pm = &amp;mtk_iommu_pm_ops,</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int __init m4u_init(void)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	int ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = platform_driver_register(&amp;mtk_iommu_driver);</span>
<span class="quote">&gt; &gt; +	if (ret)</span>
<span class="quote">&gt; &gt; +		bus_set_iommu(&amp;platform_bus_type, NULL);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; That doesn&#39;t seem necessary - the bus ops won&#39;t be set until having </span>
<span class="quote">&gt; successfully probed an M4U, and you definitely won&#39;t have managed that </span>
<span class="quote">&gt; before registering the driver ;)</span>
<span class="quote">&gt; </span>

Thanks.
<span class="quote">
&gt; Robin.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return ret;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void __exit m4u_exit(void)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	return platform_driver_unregister(&amp;mtk_iommu_driver);</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +subsys_initcall(m4u_init);</span>
<span class="quote">&gt; &gt; +module_exit(m4u_exit);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +MODULE_DESCRIPTION(&quot;IOMMU API for MTK architected m4u v1 implementations&quot;);</span>
<span class="quote">&gt; &gt; +MODULE_AUTHOR(&quot;Honghui Zhang &lt;honghui.zhang@mediatek.com&gt;&quot;);</span>
<span class="quote">&gt; &gt; +MODULE_LICENSE(&quot;GPL v2&quot;);</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; _______________________________________________</span>
<span class="quote">&gt; Linux-mediatek mailing list</span>
<span class="quote">&gt; Linux-mediatek@lists.infradead.org</span>
<span class="quote">&gt; http://lists.infradead.org/mailman/listinfo/linux-mediatek</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=77581">Robin Murphy</a> - May 24, 2016, 3:36 p.m.</div>
<pre class="content">
On 24/05/16 10:57, Honghui Zhang wrote:
[...]
<span class="quote">&gt;&gt;&gt; @@ -48,6 +48,9 @@ struct mtk_iommu_domain {</span>
<span class="quote">&gt;&gt;&gt;    	struct io_pgtable_ops		*iop;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;    	struct iommu_domain		domain;</span>
<span class="quote">&gt;&gt;&gt; +	void				*pgt_va;</span>
<span class="quote">&gt;&gt;&gt; +	dma_addr_t			pgt_pa;</span>
<span class="quote">&gt;&gt;&gt; +	void				*cookie;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; These are going to be mutually exclusive with the cfg and iop members,</span>
<span class="quote">&gt;&gt; which implies it might be a good idea to use a union and not waste</span>
<span class="quote">&gt;&gt; space. Or better, just forward-declare struct mtk_iommu_domain here and</span>
<span class="quote">&gt;&gt; leave separate definitions private to each driver. The void *cookie is</span>
<span class="quote">&gt;&gt; also an unnecessary level of abstraction, I think.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Do you mean declare struct mtk_iommu_domain here, and implement a new</span>
<span class="quote">&gt; struct in mtk_iommu_v1.c like</span>
<span class="quote">&gt; struct mtk_iommu_domain_v1 {</span>
<span class="quote">&gt; 	struct mtk_iommu_domain	domain;</span>
<span class="quote">&gt; 	u32			*pgt_va;</span>
<span class="quote">&gt; 	dma_addr_t		pgt_pa;</span>
<span class="quote">&gt; 	mtk_iommu_data		*data;</span>
<span class="quote">&gt; };</span>
<span class="quote">&gt; If this is acceptable I would implement it in the next version.</span>

Pretty much, except they both want to be called struct mtk_iommu_domain, 
so that a *declaration* for the sake of the m4u_dom member of struct 
mtk_iommu_data in the header file can remain common to both drivers - it 
then just picks up whichever private *definition* from the .c file being 
compiled.
<span class="quote">
&gt;&gt;&gt;    };</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;    struct mtk_iommu_data {</span>
<span class="quote">&gt;&gt;&gt; diff --git a/drivers/iommu/mtk_iommu_v1.c b/drivers/iommu/mtk_iommu_v1.c</span>
<span class="quote">&gt;&gt;&gt; new file mode 100644</span>
<span class="quote">&gt;&gt;&gt; index 0000000..55023e1</span>
<span class="quote">&gt;&gt;&gt; --- /dev/null</span>
<span class="quote">&gt;&gt;&gt; +++ b/drivers/iommu/mtk_iommu_v1.c</span>
<span class="quote">&gt;&gt;&gt; @@ -0,0 +1,742 @@</span>
<span class="quote">&gt;&gt;&gt; +/*</span>
<span class="quote">&gt;&gt;&gt; + * Copyright (c) 2015-2016 MediaTek Inc.</span>
<span class="quote">&gt;&gt;&gt; + * Author: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Nit: is that in the sense that this patch should also have Yong&#39;s</span>
<span class="quote">&gt;&gt; signed-off-by on it, or in that it&#39;s your work derived from his version</span>
<span class="quote">&gt;&gt; in mtk_iommu.c?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I write this driver based on Yong&#39;s version of mtk_iommu.c, should I add</span>
<span class="quote">&gt; his signed-off-by for this patch? Or should I put a comment about this?</span>
<span class="quote">&gt; Thanks.</span>

OK, in that case I think the appropriate attribution would be along the 
lines of &quot;Author: Honghui Zhang, based on mtk_iommu.c by Yong Wu&quot; (if in 
doubt, grepping for &quot;Based on&quot; gives a feel for how this is commonly 
done). If the work that comprises this patch itself (i.e. the copying 
and modification of the existing code) is all yours then your sign-off 
alone is fine.

[...]
<span class="quote">&gt;&gt;&gt; +static int mtk_iommu_add_device(struct device *dev)</span>
<span class="quote">&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt; +	struct iommu_group *group;</span>
<span class="quote">&gt;&gt;&gt; +	struct device_node *np;</span>
<span class="quote">&gt;&gt;&gt; +	struct of_phandle_args iommu_spec;</span>
<span class="quote">&gt;&gt;&gt; +	int idx = 0;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +	while (!of_parse_phandle_with_args(dev-&gt;of_node, &quot;iommus&quot;,</span>
<span class="quote">&gt;&gt;&gt; +				   &quot;#iommu-cells&quot;, idx,</span>
<span class="quote">&gt;&gt;&gt; +				   &amp;iommu_spec)) {</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Hang on, this doesn&#39;t seem right - why do you need to reimplement all</span>
<span class="quote">&gt;&gt; this instead of using IOMMU_OF_DECLARE()?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; All the clients of mtk generation one iommu share the same iommu domain,</span>
<span class="quote">&gt; as a matter of fact, mtk generation one iommu only support one iommu</span>
<span class="quote">&gt; domain. ALl the clients share the same iova address and use the same</span>
<span class="quote">&gt; pagetable. That means all iommu clients needed to be attached to the</span>
<span class="quote">&gt; same dma_iommu_mapping.</span>

Ugh, right - I&#39;d forgotten that the arch/arm DMA mapping code doesn&#39;t 
respect IOMMU groups or default domains at all. That&#39;s the real root 
cause of the issue here.
<span class="quote">
&gt; If use IOMMU_OF_DELCARE, we need to call of_iommu_set_ops to set the</span>
<span class="quote">&gt; iommu_ops, I do not want the iommu_ops be set since it would cause iommu</span>
<span class="quote">&gt; client device in different dma_iommu_mapping.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; When an iommu client device has been created, the following sequence is</span>
<span class="quote">&gt; called.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; of_platform_device_create</span>
<span class="quote">&gt; 	-&gt;of_dma_config</span>
<span class="quote">&gt; 		-&gt;arch_setup_dma_ops</span>
<span class="quote">&gt; 			-&gt;arch_setup_iommu_dma_ops</span>
<span class="quote">&gt; In this function of arch_setup_iommu_dma_ops would create a new</span>
<span class="quote">&gt; dma_iommu_mapping for each iommu client device and then attach the</span>
<span class="quote">&gt; device to this new dma_iommu_mapping. Since all the iommu clients share</span>
<span class="quote">&gt; the very same pagetable, this will not workable for our HW.</span>
<span class="quote">&gt; I could not release the dma_iommu_mapping in attach_device since the</span>
<span class="quote">&gt; to_dma_iommu_mapping was set after device_attached.</span>
<span class="quote">&gt; Any suggest for this?</span>

On a second look, you&#39;re doing more or less the same thing that the 
Renesas IPMMU driver currently does, so it&#39;s probably OK as a workaround 
for now. Fixing the arch/arm code is part of the bigger ongoing problem 
of sorting out IOMMU probing and DMA configuration, and it doesn&#39;t seem 
fair to force that on you for the sake of one driver ;)

[...]
<span class="quote">&gt;&gt;&gt; +static int __maybe_unused mtk_iommu_resume(struct device *dev)</span>
<span class="quote">&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt; +	struct mtk_iommu_data *data = dev_get_drvdata(dev);</span>
<span class="quote">&gt;&gt;&gt; +	struct mtk_iommu_suspend_reg *reg = &amp;data-&gt;reg;</span>
<span class="quote">&gt;&gt;&gt; +	void __iomem *base = data-&gt;base;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +	writel_relaxed(data-&gt;m4u_dom-&gt;pgt_pa, base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Hmm, this looks like the only case where m4u_dom actually seems</span>
<span class="quote">&gt;&gt; necessary - I&#39;m pretty sure all the others could be fairly easily</span>
<span class="quote">&gt;&gt; reworked to not use it (I might try having a quick hack at the existing</span>
<span class="quote">&gt;&gt; M4U driver to see) - at which point we could just explicitly</span>
<span class="quote">&gt;&gt; save/restore the base register here and get rid of m4u_dom entirely.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Let me take a while to think about this.</span>

That was true in the context of arm64, but you&#39;re right that the current 
state of the 32-bit code does make m4u_dom more necessary, so I guess we 
may as well leave it as-is for now.

Robin.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=166241">honghui.zhang@mediatek.com</a> - May 25, 2016, 7:58 a.m.</div>
<pre class="content">
On Tue, 2016-05-24 at 16:36 +0100, Robin Murphy wrote:
<span class="quote">&gt; On 24/05/16 10:57, Honghui Zhang wrote:</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt;&gt;&gt; @@ -48,6 +48,9 @@ struct mtk_iommu_domain {</span>
<span class="quote">&gt; &gt;&gt;&gt;    	struct io_pgtable_ops		*iop;</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;    	struct iommu_domain		domain;</span>
<span class="quote">&gt; &gt;&gt;&gt; +	void				*pgt_va;</span>
<span class="quote">&gt; &gt;&gt;&gt; +	dma_addr_t			pgt_pa;</span>
<span class="quote">&gt; &gt;&gt;&gt; +	void				*cookie;</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; These are going to be mutually exclusive with the cfg and iop members,</span>
<span class="quote">&gt; &gt;&gt; which implies it might be a good idea to use a union and not waste</span>
<span class="quote">&gt; &gt;&gt; space. Or better, just forward-declare struct mtk_iommu_domain here and</span>
<span class="quote">&gt; &gt;&gt; leave separate definitions private to each driver. The void *cookie is</span>
<span class="quote">&gt; &gt;&gt; also an unnecessary level of abstraction, I think.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Do you mean declare struct mtk_iommu_domain here, and implement a new</span>
<span class="quote">&gt; &gt; struct in mtk_iommu_v1.c like</span>
<span class="quote">&gt; &gt; struct mtk_iommu_domain_v1 {</span>
<span class="quote">&gt; &gt; 	struct mtk_iommu_domain	domain;</span>
<span class="quote">&gt; &gt; 	u32			*pgt_va;</span>
<span class="quote">&gt; &gt; 	dma_addr_t		pgt_pa;</span>
<span class="quote">&gt; &gt; 	mtk_iommu_data		*data;</span>
<span class="quote">&gt; &gt; };</span>
<span class="quote">&gt; &gt; If this is acceptable I would implement it in the next version.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Pretty much, except they both want to be called struct mtk_iommu_domain, </span>
<span class="quote">&gt; so that a *declaration* for the sake of the m4u_dom member of struct </span>
<span class="quote">&gt; mtk_iommu_data in the header file can remain common to both drivers - it </span>
<span class="quote">&gt; then just picks up whichever private *definition* from the .c file being </span>
<span class="quote">&gt; compiled.</span>

I will follow your advise in the next version, thanks very much.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt;&gt;&gt;    };</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;    struct mtk_iommu_data {</span>
<span class="quote">&gt; &gt;&gt;&gt; diff --git a/drivers/iommu/mtk_iommu_v1.c b/drivers/iommu/mtk_iommu_v1.c</span>
<span class="quote">&gt; &gt;&gt;&gt; new file mode 100644</span>
<span class="quote">&gt; &gt;&gt;&gt; index 0000000..55023e1</span>
<span class="quote">&gt; &gt;&gt;&gt; --- /dev/null</span>
<span class="quote">&gt; &gt;&gt;&gt; +++ b/drivers/iommu/mtk_iommu_v1.c</span>
<span class="quote">&gt; &gt;&gt;&gt; @@ -0,0 +1,742 @@</span>
<span class="quote">&gt; &gt;&gt;&gt; +/*</span>
<span class="quote">&gt; &gt;&gt;&gt; + * Copyright (c) 2015-2016 MediaTek Inc.</span>
<span class="quote">&gt; &gt;&gt;&gt; + * Author: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Nit: is that in the sense that this patch should also have Yong&#39;s</span>
<span class="quote">&gt; &gt;&gt; signed-off-by on it, or in that it&#39;s your work derived from his version</span>
<span class="quote">&gt; &gt;&gt; in mtk_iommu.c?</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; I write this driver based on Yong&#39;s version of mtk_iommu.c, should I add</span>
<span class="quote">&gt; &gt; his signed-off-by for this patch? Or should I put a comment about this?</span>
<span class="quote">&gt; &gt; Thanks.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; OK, in that case I think the appropriate attribution would be along the </span>
<span class="quote">&gt; lines of &quot;Author: Honghui Zhang, based on mtk_iommu.c by Yong Wu&quot; (if in </span>
<span class="quote">&gt; doubt, grepping for &quot;Based on&quot; gives a feel for how this is commonly </span>
<span class="quote">&gt; done). If the work that comprises this patch itself (i.e. the copying </span>
<span class="quote">&gt; and modification of the existing code) is all yours then your sign-off </span>
<span class="quote">&gt; alone is fine.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt;&gt;&gt; +static int mtk_iommu_add_device(struct device *dev)</span>
<span class="quote">&gt; &gt;&gt;&gt; +{</span>
<span class="quote">&gt; &gt;&gt;&gt; +	struct iommu_group *group;</span>
<span class="quote">&gt; &gt;&gt;&gt; +	struct device_node *np;</span>
<span class="quote">&gt; &gt;&gt;&gt; +	struct of_phandle_args iommu_spec;</span>
<span class="quote">&gt; &gt;&gt;&gt; +	int idx = 0;</span>
<span class="quote">&gt; &gt;&gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt;&gt; +	while (!of_parse_phandle_with_args(dev-&gt;of_node, &quot;iommus&quot;,</span>
<span class="quote">&gt; &gt;&gt;&gt; +				   &quot;#iommu-cells&quot;, idx,</span>
<span class="quote">&gt; &gt;&gt;&gt; +				   &amp;iommu_spec)) {</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Hang on, this doesn&#39;t seem right - why do you need to reimplement all</span>
<span class="quote">&gt; &gt;&gt; this instead of using IOMMU_OF_DECLARE()?</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; All the clients of mtk generation one iommu share the same iommu domain,</span>
<span class="quote">&gt; &gt; as a matter of fact, mtk generation one iommu only support one iommu</span>
<span class="quote">&gt; &gt; domain. ALl the clients share the same iova address and use the same</span>
<span class="quote">&gt; &gt; pagetable. That means all iommu clients needed to be attached to the</span>
<span class="quote">&gt; &gt; same dma_iommu_mapping.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Ugh, right - I&#39;d forgotten that the arch/arm DMA mapping code doesn&#39;t </span>
<span class="quote">&gt; respect IOMMU groups or default domains at all. That&#39;s the real root </span>
<span class="quote">&gt; cause of the issue here.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; If use IOMMU_OF_DELCARE, we need to call of_iommu_set_ops to set the</span>
<span class="quote">&gt; &gt; iommu_ops, I do not want the iommu_ops be set since it would cause iommu</span>
<span class="quote">&gt; &gt; client device in different dma_iommu_mapping.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; When an iommu client device has been created, the following sequence is</span>
<span class="quote">&gt; &gt; called.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; of_platform_device_create</span>
<span class="quote">&gt; &gt; 	-&gt;of_dma_config</span>
<span class="quote">&gt; &gt; 		-&gt;arch_setup_dma_ops</span>
<span class="quote">&gt; &gt; 			-&gt;arch_setup_iommu_dma_ops</span>
<span class="quote">&gt; &gt; In this function of arch_setup_iommu_dma_ops would create a new</span>
<span class="quote">&gt; &gt; dma_iommu_mapping for each iommu client device and then attach the</span>
<span class="quote">&gt; &gt; device to this new dma_iommu_mapping. Since all the iommu clients share</span>
<span class="quote">&gt; &gt; the very same pagetable, this will not workable for our HW.</span>
<span class="quote">&gt; &gt; I could not release the dma_iommu_mapping in attach_device since the</span>
<span class="quote">&gt; &gt; to_dma_iommu_mapping was set after device_attached.</span>
<span class="quote">&gt; &gt; Any suggest for this?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On a second look, you&#39;re doing more or less the same thing that the </span>
<span class="quote">&gt; Renesas IPMMU driver currently does, so it&#39;s probably OK as a workaround </span>
<span class="quote">&gt; for now. Fixing the arch/arm code is part of the bigger ongoing problem </span>
<span class="quote">&gt; of sorting out IOMMU probing and DMA configuration, and it doesn&#39;t seem </span>
<span class="quote">&gt; fair to force that on you for the sake of one driver ;)</span>
<span class="quote">&gt; </span>

Yes, I did read the IPMMU driver before I coding this driver. Thanks.
<span class="quote">
&gt; [...]</span>
<span class="quote">&gt; &gt;&gt;&gt; +static int __maybe_unused mtk_iommu_resume(struct device *dev)</span>
<span class="quote">&gt; &gt;&gt;&gt; +{</span>
<span class="quote">&gt; &gt;&gt;&gt; +	struct mtk_iommu_data *data = dev_get_drvdata(dev);</span>
<span class="quote">&gt; &gt;&gt;&gt; +	struct mtk_iommu_suspend_reg *reg = &amp;data-&gt;reg;</span>
<span class="quote">&gt; &gt;&gt;&gt; +	void __iomem *base = data-&gt;base;</span>
<span class="quote">&gt; &gt;&gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt;&gt; +	writel_relaxed(data-&gt;m4u_dom-&gt;pgt_pa, base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Hmm, this looks like the only case where m4u_dom actually seems</span>
<span class="quote">&gt; &gt;&gt; necessary - I&#39;m pretty sure all the others could be fairly easily</span>
<span class="quote">&gt; &gt;&gt; reworked to not use it (I might try having a quick hack at the existing</span>
<span class="quote">&gt; &gt;&gt; M4U driver to see) - at which point we could just explicitly</span>
<span class="quote">&gt; &gt;&gt; save/restore the base register here and get rid of m4u_dom entirely.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Let me take a while to think about this.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; That was true in the context of arm64, but you&#39;re right that the current </span>
<span class="quote">&gt; state of the 32-bit code does make m4u_dom more necessary, so I guess we </span>
<span class="quote">&gt; may as well leave it as-is for now.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Robin.</span>

Thanks very much for your comments.
I will fix all of this later.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/iommu/Kconfig b/drivers/iommu/Kconfig</span>
<span class="p_header">index dd1dc39..2e17d70 100644</span>
<span class="p_header">--- a/drivers/iommu/Kconfig</span>
<span class="p_header">+++ b/drivers/iommu/Kconfig</span>
<span class="p_chunk">@@ -354,4 +354,23 @@</span> <span class="p_context"> config MTK_IOMMU</span>
 
 	  If unsure, say N here.
 
<span class="p_add">+config MTK_IOMMU_V1</span>
<span class="p_add">+	bool &quot;MTK IOMMU Version 1 (M4U gen1) Support&quot;</span>
<span class="p_add">+	depends on ARM || ARM64</span>
<span class="p_add">+	depends on ARCH_MEDIATEK || COMPILE_TEST</span>
<span class="p_add">+	select ARM_DMA_USE_IOMMU</span>
<span class="p_add">+	select IOMMU_API</span>
<span class="p_add">+	select IOMMU_DMA</span>
<span class="p_add">+	select MEMORY</span>
<span class="p_add">+	select MTK_SMI</span>
<span class="p_add">+	select COMMON_CLK_MT2701_MMSYS</span>
<span class="p_add">+	select COMMON_CLK_MT2701_IMGSYS</span>
<span class="p_add">+	select COMMON_CLK_MT2701_VDECSYS</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Support for the M4U on certain Mediatek SoCs. M4U generation 1 HW is</span>
<span class="p_add">+	  Multimedia Memory Managememt Unit. This option enables remapping of</span>
<span class="p_add">+	  DMA memory accesses for the multimedia subsystem.</span>
<span class="p_add">+</span>
<span class="p_add">+	  if unsure, say N here.</span>
<span class="p_add">+</span>
 endif # IOMMU_SUPPORT
<span class="p_header">diff --git a/drivers/iommu/Makefile b/drivers/iommu/Makefile</span>
<span class="p_header">index c6edb31..778baf5 100644</span>
<span class="p_header">--- a/drivers/iommu/Makefile</span>
<span class="p_header">+++ b/drivers/iommu/Makefile</span>
<span class="p_chunk">@@ -18,6 +18,7 @@</span> <span class="p_context"> obj-$(CONFIG_INTEL_IOMMU_SVM) += intel-svm.o</span>
 obj-$(CONFIG_IPMMU_VMSA) += ipmmu-vmsa.o
 obj-$(CONFIG_IRQ_REMAP) += intel_irq_remapping.o irq_remapping.o
 obj-$(CONFIG_MTK_IOMMU) += mtk_iommu.o
<span class="p_add">+obj-$(CONFIG_MTK_IOMMU_V1) += mtk_iommu_v1.o</span>
 obj-$(CONFIG_OMAP_IOMMU) += omap-iommu.o
 obj-$(CONFIG_OMAP_IOMMU_DEBUG) += omap-iommu-debug.o
 obj-$(CONFIG_ROCKCHIP_IOMMU) += rockchip-iommu.o
<span class="p_header">diff --git a/drivers/iommu/mtk_iommu.h b/drivers/iommu/mtk_iommu.h</span>
<span class="p_header">index 5656355..8d60f21 100644</span>
<span class="p_header">--- a/drivers/iommu/mtk_iommu.h</span>
<span class="p_header">+++ b/drivers/iommu/mtk_iommu.h</span>
<span class="p_chunk">@@ -48,6 +48,9 @@</span> <span class="p_context"> struct mtk_iommu_domain {</span>
 	struct io_pgtable_ops		*iop;
 
 	struct iommu_domain		domain;
<span class="p_add">+	void				*pgt_va;</span>
<span class="p_add">+	dma_addr_t			pgt_pa;</span>
<span class="p_add">+	void				*cookie;</span>
 };
 
 struct mtk_iommu_data {
<span class="p_header">diff --git a/drivers/iommu/mtk_iommu_v1.c b/drivers/iommu/mtk_iommu_v1.c</span>
new file mode 100644
<span class="p_header">index 0000000..55023e1</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/iommu/mtk_iommu_v1.c</span>
<span class="p_chunk">@@ -0,0 +1,742 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (c) 2015-2016 MediaTek Inc.</span>
<span class="p_add">+ * Author: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#include &lt;linux/bootmem.h&gt;</span>
<span class="p_add">+#include &lt;linux/bug.h&gt;</span>
<span class="p_add">+#include &lt;linux/clk.h&gt;</span>
<span class="p_add">+#include &lt;linux/component.h&gt;</span>
<span class="p_add">+#include &lt;linux/device.h&gt;</span>
<span class="p_add">+#include &lt;linux/dma-iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/err.h&gt;</span>
<span class="p_add">+#include &lt;linux/interrupt.h&gt;</span>
<span class="p_add">+#include &lt;linux/io.h&gt;</span>
<span class="p_add">+#include &lt;linux/iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/iopoll.h&gt;</span>
<span class="p_add">+#include &lt;linux/kmemleak.h&gt;</span>
<span class="p_add">+#include &lt;linux/list.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_address.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_platform.h&gt;</span>
<span class="p_add">+#include &lt;linux/platform_device.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+#include &lt;linux/spinlock.h&gt;</span>
<span class="p_add">+#include &lt;asm/barrier.h&gt;</span>
<span class="p_add">+#include &lt;asm/dma-iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;dt-bindings/memory/mt2701-larb-port.h&gt;</span>
<span class="p_add">+#include &lt;soc/mediatek/smi.h&gt;</span>
<span class="p_add">+#include &quot;mtk_iommu.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_PT_BASE_ADDR			0x000</span>
<span class="p_add">+</span>
<span class="p_add">+#define F_ALL_INVLD				0x2</span>
<span class="p_add">+#define F_MMU_INV_RANGE				0x1</span>
<span class="p_add">+#define F_INVLD_EN0				BIT(0)</span>
<span class="p_add">+#define F_INVLD_EN1				BIT(1)</span>
<span class="p_add">+</span>
<span class="p_add">+#define F_MMU_FAULT_VA_MSK			0xfffff000</span>
<span class="p_add">+#define MTK_PROTECT_PA_ALIGN			128</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_CTRL_REG			0x210</span>
<span class="p_add">+#define F_MMU_CTRL_COHERENT_EN			BIT(8)</span>
<span class="p_add">+#define REG_MMU_IVRP_PADDR			0x214</span>
<span class="p_add">+#define REG_MMU_INT_CONTROL			0x220</span>
<span class="p_add">+#define F_INT_TRANSLATION_FAULT			BIT(0)</span>
<span class="p_add">+#define F_INT_MAIN_MULTI_HIT_FAULT		BIT(1)</span>
<span class="p_add">+#define F_INT_INVALID_PA_FAULT			BIT(2)</span>
<span class="p_add">+#define F_INT_ENTRY_REPLACEMENT_FAULT		BIT(3)</span>
<span class="p_add">+#define F_INT_TABLE_WALK_FAULT			BIT(4)</span>
<span class="p_add">+#define F_INT_TLB_MISS_FAULT			BIT(5)</span>
<span class="p_add">+#define F_INT_PFH_DMA_FIFO_OVERFLOW		BIT(6)</span>
<span class="p_add">+#define F_INT_MISS_DMA_FIFO_OVERFLOW		BIT(7)</span>
<span class="p_add">+</span>
<span class="p_add">+#define F_MMU_TF_PROTECT_SEL(prot)		(((prot) &amp; 0x3) &lt;&lt; 5)</span>
<span class="p_add">+#define F_INT_CLR_BIT				BIT(12)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_FAULT_ST			0x224</span>
<span class="p_add">+#define REG_MMU_FAULT_VA			0x228</span>
<span class="p_add">+#define REG_MMU_INVLD_PA			0x22C</span>
<span class="p_add">+#define REG_MMU_INT_ID				0x388</span>
<span class="p_add">+#define REG_MMU_INVALIDATE			0x5c0</span>
<span class="p_add">+#define REG_MMU_INVLD_START_A			0x5c4</span>
<span class="p_add">+#define REG_MMU_INVLD_END_A			0x5c8</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INV_SEL				0x5d8</span>
<span class="p_add">+#define REG_MMU_STANDARD_AXI_MODE		0x5e8</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_DCM				0x5f0</span>
<span class="p_add">+#define F_MMU_DCM_ON				BIT(1)</span>
<span class="p_add">+#define REG_MMU_CPE_DONE			0x60c</span>
<span class="p_add">+#define F_DESC_VALID				0x2</span>
<span class="p_add">+#define F_DESC_NONSEC				BIT(3)</span>
<span class="p_add">+#define MT2701_M4U_TF_LARB(TF)			(6 - (((TF) &gt;&gt; 13) &amp; 0x7))</span>
<span class="p_add">+#define MT2701_M4U_TF_PORT(TF)			(((TF) &gt;&gt; 8) &amp; 0xF)</span>
<span class="p_add">+/* MTK generation one iommu HW only support 4K size mapping */</span>
<span class="p_add">+#define MT2701_IOMMU_PAGE_SHIFT			12</span>
<span class="p_add">+#define MT2701_IOMMU_PAGE_SIZE			(1UL &lt;&lt; MT2701_IOMMU_PAGE_SHIFT)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * MTK m4u support 4GB iova address space, and oly support 4K page</span>
<span class="p_add">+ * mapping. So the pagetable size should be exactly as 4M.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define M2701_IOMMU_PGT_SIZE			SZ_4M</span>
<span class="p_add">+</span>
<span class="p_add">+static const int mt2701_m4u_in_larb[] = {</span>
<span class="p_add">+	LARB0_PORT_OFFSET, LARB1_PORT_OFFSET,</span>
<span class="p_add">+	LARB2_PORT_OFFSET, LARB3_PORT_OFFSET</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int mt2701_m4u_to_larb(int id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = ARRAY_SIZE(mt2701_m4u_in_larb); i &gt;= 0; i--)</span>
<span class="p_add">+		if ((id) &gt;= mt2701_m4u_in_larb[i])</span>
<span class="p_add">+			return i;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int mt2701_m4u_to_port(int id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int larb = mt2701_m4u_to_larb(id);</span>
<span class="p_add">+</span>
<span class="p_add">+	return id - mt2701_m4u_in_larb[larb];</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_tlb_flush_all(void *cookie)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = cookie;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0,</span>
<span class="p_add">+			data-&gt;base + REG_MMU_INV_SEL);</span>
<span class="p_add">+	writel_relaxed(F_ALL_INVLD, data-&gt;base + REG_MMU_INVALIDATE);</span>
<span class="p_add">+	wmb(); /* Make sure the tlb flush all done */</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_tlb_flush_range(void *cookie,</span>
<span class="p_add">+				unsigned long iova, size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = cookie;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	u32 tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0,</span>
<span class="p_add">+		data-&gt;base + REG_MMU_INV_SEL);</span>
<span class="p_add">+	writel_relaxed(iova &amp; F_MMU_FAULT_VA_MSK,</span>
<span class="p_add">+		data-&gt;base + REG_MMU_INVLD_START_A);</span>
<span class="p_add">+	writel_relaxed((iova + size - 1) &amp; F_MMU_FAULT_VA_MSK,</span>
<span class="p_add">+		data-&gt;base + REG_MMU_INVLD_END_A);</span>
<span class="p_add">+	writel_relaxed(F_MMU_INV_RANGE, data-&gt;base + REG_MMU_INVALIDATE);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = readl_poll_timeout_atomic(data-&gt;base + REG_MMU_CPE_DONE,</span>
<span class="p_add">+				tmp, tmp != 0, 10, 100000);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_warn(data-&gt;dev,</span>
<span class="p_add">+			 &quot;Partial TLB flush timed out, falling back to full flush\n&quot;);</span>
<span class="p_add">+		mtk_iommu_tlb_flush_all(cookie);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* Clear the CPE status */</span>
<span class="p_add">+	writel_relaxed(0, data-&gt;base + REG_MMU_CPE_DONE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static irqreturn_t mtk_iommu_isr(int irq, void *dev_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = dev_id;</span>
<span class="p_add">+	struct mtk_iommu_domain *dom = data-&gt;m4u_dom;</span>
<span class="p_add">+	u32 int_state, regval, fault_iova, fault_pa;</span>
<span class="p_add">+	unsigned int fault_larb, fault_port;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Read error information from registers */</span>
<span class="p_add">+	int_state = readl_relaxed(data-&gt;base + REG_MMU_FAULT_ST);</span>
<span class="p_add">+	fault_iova = readl_relaxed(data-&gt;base + REG_MMU_FAULT_VA);</span>
<span class="p_add">+</span>
<span class="p_add">+	fault_iova &amp;= F_MMU_FAULT_VA_MSK;</span>
<span class="p_add">+	fault_pa = readl_relaxed(data-&gt;base + REG_MMU_INVLD_PA);</span>
<span class="p_add">+	regval = readl_relaxed(data-&gt;base + REG_MMU_INT_ID);</span>
<span class="p_add">+	fault_larb = MT2701_M4U_TF_LARB(regval);</span>
<span class="p_add">+	fault_port = MT2701_M4U_TF_PORT(regval);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * MTK v1 iommu HW could not determin whether the fault is read or</span>
<span class="p_add">+	 * write fault, report as read fault.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (report_iommu_fault(&amp;dom-&gt;domain, data-&gt;dev, fault_iova,</span>
<span class="p_add">+			IOMMU_FAULT_READ))</span>
<span class="p_add">+		dev_err_ratelimited(data-&gt;dev,</span>
<span class="p_add">+			&quot;fault type=0x%x iova=0x%x pa=0x%x larb=%d port=%d\n&quot;,</span>
<span class="p_add">+			int_state, fault_iova, fault_pa,</span>
<span class="p_add">+			fault_larb, fault_port);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Interrupt clear */</span>
<span class="p_add">+	regval = readl_relaxed(data-&gt;base + REG_MMU_INT_CONTROL);</span>
<span class="p_add">+	regval |= F_INT_CLR_BIT;</span>
<span class="p_add">+	writel_relaxed(regval, data-&gt;base + REG_MMU_INT_CONTROL);</span>
<span class="p_add">+</span>
<span class="p_add">+	mtk_iommu_tlb_flush_all(data);</span>
<span class="p_add">+</span>
<span class="p_add">+	return IRQ_HANDLED;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_config(struct mtk_iommu_data *data,</span>
<span class="p_add">+			     struct device *dev, bool enable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_client_priv *head, *cur, *next;</span>
<span class="p_add">+	struct mtk_smi_larb_iommu    *larb_mmu;</span>
<span class="p_add">+	unsigned int                 larbid, portid;</span>
<span class="p_add">+</span>
<span class="p_add">+	head = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	list_for_each_entry_safe(cur, next, &amp;head-&gt;client, client) {</span>
<span class="p_add">+		larbid = mt2701_m4u_to_larb(cur-&gt;mtk_m4u_id);</span>
<span class="p_add">+		portid = mt2701_m4u_to_port(cur-&gt;mtk_m4u_id);</span>
<span class="p_add">+		larb_mmu = &amp;data-&gt;smi_imu.larb_imu[larbid];</span>
<span class="p_add">+</span>
<span class="p_add">+		dev_dbg(dev, &quot;%s iommu port: %d\n&quot;,</span>
<span class="p_add">+			enable ? &quot;enable&quot; : &quot;disable&quot;, portid);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (enable)</span>
<span class="p_add">+			larb_mmu-&gt;mmu |= MTK_SMI_MMU_EN(portid);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			larb_mmu-&gt;mmu &amp;= ~MTK_SMI_MMU_EN(portid);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void *mtk_iommu_alloc_pgt(struct device *dev,</span>
<span class="p_add">+				dma_addr_t *dma, gfp_t gfp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void *pages = dma_alloc_coherent(dev,</span>
<span class="p_add">+				M2701_IOMMU_PGT_SIZE, dma, gfp | __GFP_ZERO);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pages)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	kmemleak_ignore(pages);</span>
<span class="p_add">+	return pages;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_free_pgt(struct device *dev,</span>
<span class="p_add">+				void *pages, dma_addr_t dma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dma_free_coherent(dev, M2701_IOMMU_PGT_SIZE, pages, dma);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_domain_finalise(struct mtk_iommu_data *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *dom = data-&gt;m4u_dom;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_init(&amp;dom-&gt;pgtlock);</span>
<span class="p_add">+</span>
<span class="p_add">+	dom-&gt;pgt_va = mtk_iommu_alloc_pgt(data-&gt;dev,</span>
<span class="p_add">+				&amp;dom-&gt;pgt_pa, GFP_KERNEL);</span>
<span class="p_add">+	if (!dom-&gt;pgt_va)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel(dom-&gt;pgt_pa, data-&gt;base + REG_MMU_PT_BASE_ADDR);</span>
<span class="p_add">+</span>
<span class="p_add">+	dom-&gt;cookie = (void *)data;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_domain *mtk_iommu_domain_alloc(unsigned type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *dom;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (type != IOMMU_DOMAIN_UNMANAGED)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	dom = kzalloc(sizeof(*dom), GFP_KERNEL);</span>
<span class="p_add">+	if (!dom)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return &amp;dom-&gt;domain;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_domain_free(struct iommu_domain *domain)</span>
<span class="p_add">+{</span>
<span class="p_add">+	kfree(to_mtk_domain(domain));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_attach_device(struct iommu_domain *domain,</span>
<span class="p_add">+				   struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="p_add">+	struct mtk_iommu_client_priv *priv = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	struct mtk_iommu_data *data;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!priv)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="p_add">+	if (!data-&gt;m4u_dom) {</span>
<span class="p_add">+		data-&gt;m4u_dom = dom;</span>
<span class="p_add">+		ret = mtk_iommu_domain_finalise(data);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			data-&gt;m4u_dom = NULL;</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else if (data-&gt;m4u_dom != dom) {</span>
<span class="p_add">+		/* All the client devices should be in the same m4u domain */</span>
<span class="p_add">+		dev_err(dev, &quot;try to attach into the error iommu domain\n&quot;);</span>
<span class="p_add">+		return -EPERM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mtk_iommu_config(data, dev, true);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_detach_device(struct iommu_domain *domain,</span>
<span class="p_add">+				    struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_client_priv *priv = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	struct mtk_iommu_data *data;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!priv)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="p_add">+	mtk_iommu_config(data, dev, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_map(struct iommu_domain *domain, unsigned long iova,</span>
<span class="p_add">+			 phys_addr_t paddr, size_t size, int prot)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="p_add">+	struct mtk_iommu_data *data = dom-&gt;cookie;</span>
<span class="p_add">+	unsigned int page_num = size &gt;&gt; MT2701_IOMMU_PAGE_SHIFT;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	unsigned int i;</span>
<span class="p_add">+	u32 *pgt_base_iova = dom-&gt;pgt_va;</span>
<span class="p_add">+	u32 pabase = (u32)paddr;</span>
<span class="p_add">+	int map_size = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;dom-&gt;pgtlock, flags);</span>
<span class="p_add">+	pgt_base_iova += iova  &gt;&gt; MT2701_IOMMU_PAGE_SHIFT;</span>
<span class="p_add">+	for (i = 0; i &lt; page_num; i++) {</span>
<span class="p_add">+		if (pgt_base_iova[i])</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		pgt_base_iova[i] = pabase | F_DESC_VALID | F_DESC_NONSEC;</span>
<span class="p_add">+		pabase += MT2701_IOMMU_PAGE_SIZE;</span>
<span class="p_add">+		map_size += MT2701_IOMMU_PAGE_SIZE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;dom-&gt;pgtlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	mtk_iommu_tlb_flush_range(data, iova, size);</span>
<span class="p_add">+</span>
<span class="p_add">+	return map_size == size ? 0 : -EEXIST;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static size_t mtk_iommu_unmap(struct iommu_domain *domain,</span>
<span class="p_add">+			      unsigned long iova, size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="p_add">+	struct mtk_iommu_data *data = dom-&gt;cookie;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	u32 *pgt_base_iova = dom-&gt;pgt_va;</span>
<span class="p_add">+	unsigned int page_num = size &gt;&gt; MT2701_IOMMU_PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;dom-&gt;pgtlock, flags);</span>
<span class="p_add">+	pgt_base_iova += iova  &gt;&gt; MT2701_IOMMU_PAGE_SHIFT;</span>
<span class="p_add">+	memset(pgt_base_iova, 0, page_num * sizeof(u32));</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;dom-&gt;pgtlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	mtk_iommu_tlb_flush_range(data, iova, size);</span>
<span class="p_add">+</span>
<span class="p_add">+	return size;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static phys_addr_t mtk_iommu_iova_to_phys(struct iommu_domain *domain,</span>
<span class="p_add">+					  dma_addr_t iova)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	phys_addr_t pa;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;dom-&gt;pgtlock, flags);</span>
<span class="p_add">+	pa = *((u32 *)((u32 *)dom-&gt;pgt_va + (iova &gt;&gt; MT2701_IOMMU_PAGE_SHIFT)));</span>
<span class="p_add">+	pa = pa &amp; (~(MT2701_IOMMU_PAGE_SIZE - 1));</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;dom-&gt;pgtlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return pa;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * MTK generaion one iommu HW only support one iommu domain, and all the client</span>
<span class="p_add">+ * sharing the same iova address space.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int mtk_iommu_create_mapping(struct device *dev,</span>
<span class="p_add">+				    struct of_phandle_args *args)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_client_priv *head, *priv, *next;</span>
<span class="p_add">+	struct platform_device *m4updev;</span>
<span class="p_add">+	struct dma_iommu_mapping *mtk_mapping;</span>
<span class="p_add">+	struct device *m4udev;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (args-&gt;args_count != 1) {</span>
<span class="p_add">+		dev_err(dev, &quot;invalid #iommu-cells(%d) property for IOMMU\n&quot;,</span>
<span class="p_add">+			args-&gt;args_count);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!dev-&gt;archdata.iommu) {</span>
<span class="p_add">+		/* Get the m4u device */</span>
<span class="p_add">+		m4updev = of_find_device_by_node(args-&gt;np);</span>
<span class="p_add">+		of_node_put(args-&gt;np);</span>
<span class="p_add">+		if (WARN_ON(!m4updev))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		head = kzalloc(sizeof(*head), GFP_KERNEL);</span>
<span class="p_add">+		if (!head)</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+		dev-&gt;archdata.iommu = head;</span>
<span class="p_add">+		INIT_LIST_HEAD(&amp;head-&gt;client);</span>
<span class="p_add">+		head-&gt;m4udev = &amp;m4updev-&gt;dev;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		head = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="p_add">+	if (!priv) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto err_free_mem;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	priv-&gt;mtk_m4u_id = args-&gt;args[0];</span>
<span class="p_add">+	list_add_tail(&amp;priv-&gt;client, &amp;head-&gt;client);</span>
<span class="p_add">+</span>
<span class="p_add">+	m4udev = head-&gt;m4udev;</span>
<span class="p_add">+	mtk_mapping = m4udev-&gt;archdata.iommu;</span>
<span class="p_add">+	if (!mtk_mapping) {</span>
<span class="p_add">+		/* MTK iommu support 4GB iova address space. */</span>
<span class="p_add">+		mtk_mapping = arm_iommu_create_mapping(&amp;platform_bus_type,</span>
<span class="p_add">+						0, 1ULL &lt;&lt; 32);</span>
<span class="p_add">+		if (IS_ERR(mtk_mapping)) {</span>
<span class="p_add">+			ret = PTR_ERR(mtk_mapping);</span>
<span class="p_add">+			goto err_free_mem;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		m4udev-&gt;archdata.iommu = mtk_mapping;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = arm_iommu_attach_device(dev, mtk_mapping);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto err_release_mapping;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+err_release_mapping:</span>
<span class="p_add">+	arm_iommu_release_mapping(mtk_mapping);</span>
<span class="p_add">+	m4udev-&gt;archdata.iommu = NULL;</span>
<span class="p_add">+err_free_mem:</span>
<span class="p_add">+	list_for_each_entry_safe(priv, next, &amp;head-&gt;client, client)</span>
<span class="p_add">+		kfree(priv);</span>
<span class="p_add">+	kfree(head);</span>
<span class="p_add">+	dev-&gt;archdata.iommu = NULL;</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_add_device(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct iommu_group *group;</span>
<span class="p_add">+	struct device_node *np;</span>
<span class="p_add">+	struct of_phandle_args iommu_spec;</span>
<span class="p_add">+	int idx = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (!of_parse_phandle_with_args(dev-&gt;of_node, &quot;iommus&quot;,</span>
<span class="p_add">+				   &quot;#iommu-cells&quot;, idx,</span>
<span class="p_add">+				   &amp;iommu_spec)) {</span>
<span class="p_add">+		np = iommu_spec.np;</span>
<span class="p_add">+		mtk_iommu_create_mapping(dev, &amp;iommu_spec);</span>
<span class="p_add">+</span>
<span class="p_add">+		of_node_put(np);</span>
<span class="p_add">+		idx++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!dev-&gt;archdata.iommu) /* Not a iommu client device */</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	group = iommu_group_get_for_dev(dev);</span>
<span class="p_add">+	if (IS_ERR(group))</span>
<span class="p_add">+		return PTR_ERR(group);</span>
<span class="p_add">+</span>
<span class="p_add">+	iommu_group_put(group);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_remove_device(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_client_priv *head, *cur, *next;</span>
<span class="p_add">+</span>
<span class="p_add">+	head = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	if (!head)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry_safe(cur, next, &amp;head-&gt;client, client) {</span>
<span class="p_add">+		list_del(&amp;cur-&gt;client);</span>
<span class="p_add">+		kfree(cur);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	kfree(head);</span>
<span class="p_add">+	dev-&gt;archdata.iommu = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	iommu_group_remove_device(dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_group *mtk_iommu_device_group(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data;</span>
<span class="p_add">+	struct mtk_iommu_client_priv *priv;</span>
<span class="p_add">+</span>
<span class="p_add">+	priv = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	if (!priv)</span>
<span class="p_add">+		return ERR_PTR(-ENODEV);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* All the client devices are in the same m4u iommu-group */</span>
<span class="p_add">+	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="p_add">+	if (!data-&gt;m4u_group) {</span>
<span class="p_add">+		data-&gt;m4u_group = iommu_group_alloc();</span>
<span class="p_add">+		if (IS_ERR(data-&gt;m4u_group))</span>
<span class="p_add">+			dev_err(dev, &quot;Failed to allocate M4U IOMMU group\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return data-&gt;m4u_group;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_hw_init(const struct mtk_iommu_data *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 regval;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = clk_prepare_enable(data-&gt;bclk);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_err(data-&gt;dev, &quot;Failed to enable iommu bclk(%d)\n&quot;, ret);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = F_MMU_CTRL_COHERENT_EN | F_MMU_TF_PROTECT_SEL(2);</span>
<span class="p_add">+	writel_relaxed(regval, data-&gt;base + REG_MMU_CTRL_REG);</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = F_INT_TRANSLATION_FAULT |</span>
<span class="p_add">+		F_INT_MAIN_MULTI_HIT_FAULT |</span>
<span class="p_add">+		F_INT_INVALID_PA_FAULT |</span>
<span class="p_add">+		F_INT_ENTRY_REPLACEMENT_FAULT |</span>
<span class="p_add">+		F_INT_TABLE_WALK_FAULT |</span>
<span class="p_add">+		F_INT_TLB_MISS_FAULT |</span>
<span class="p_add">+		F_INT_PFH_DMA_FIFO_OVERFLOW |</span>
<span class="p_add">+		F_INT_MISS_DMA_FIFO_OVERFLOW;</span>
<span class="p_add">+	writel_relaxed(regval, data-&gt;base + REG_MMU_INT_CONTROL);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* protect memory,hw will write here while translation fault */</span>
<span class="p_add">+	writel_relaxed(data-&gt;protect_base,</span>
<span class="p_add">+			data-&gt;base + REG_MMU_IVRP_PADDR);</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(F_MMU_DCM_ON, data-&gt;base + REG_MMU_DCM);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (devm_request_irq(data-&gt;dev, data-&gt;irq, mtk_iommu_isr, 0,</span>
<span class="p_add">+			     dev_name(data-&gt;dev), (void *)data)) {</span>
<span class="p_add">+		writel_relaxed(0, data-&gt;base + REG_MMU_PT_BASE_ADDR);</span>
<span class="p_add">+		clk_disable_unprepare(data-&gt;bclk);</span>
<span class="p_add">+		dev_err(data-&gt;dev, &quot;Failed @ IRQ-%d Request\n&quot;, data-&gt;irq);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_ops mtk_iommu_ops = {</span>
<span class="p_add">+	.domain_alloc	= mtk_iommu_domain_alloc,</span>
<span class="p_add">+	.domain_free	= mtk_iommu_domain_free,</span>
<span class="p_add">+	.attach_dev	= mtk_iommu_attach_device,</span>
<span class="p_add">+	.detach_dev	= mtk_iommu_detach_device,</span>
<span class="p_add">+	.map		= mtk_iommu_map,</span>
<span class="p_add">+	.unmap		= mtk_iommu_unmap,</span>
<span class="p_add">+	.map_sg		= default_iommu_map_sg,</span>
<span class="p_add">+	.iova_to_phys	= mtk_iommu_iova_to_phys,</span>
<span class="p_add">+	.add_device	= mtk_iommu_add_device,</span>
<span class="p_add">+	.remove_device	= mtk_iommu_remove_device,</span>
<span class="p_add">+	.device_group	= mtk_iommu_device_group,</span>
<span class="p_add">+	.pgsize_bitmap	= ~0UL &lt;&lt; MT2701_IOMMU_PAGE_SHIFT,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct of_device_id mtk_iommu_of_ids[] = {</span>
<span class="p_add">+	{ .compatible = &quot;mediatek,mt2701-m4u&quot;, },</span>
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct component_master_ops mtk_iommu_com_ops = {</span>
<span class="p_add">+	.bind		= mtk_iommu_bind,</span>
<span class="p_add">+	.unbind		= mtk_iommu_unbind,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data		*data;</span>
<span class="p_add">+	struct device			*dev = &amp;pdev-&gt;dev;</span>
<span class="p_add">+	struct resource			*res;</span>
<span class="p_add">+	struct component_match		*match = NULL;</span>
<span class="p_add">+	void				*protect;</span>
<span class="p_add">+	int				i, larb_nr, ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;dev = dev;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Protect memory. HW will access here while translation fault.*/</span>
<span class="p_add">+	protect = devm_kzalloc(dev, MTK_PROTECT_PA_ALIGN * 2, GFP_KERNEL);</span>
<span class="p_add">+	if (!protect)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	data-&gt;protect_base = ALIGN(virt_to_phys(protect), MTK_PROTECT_PA_ALIGN);</span>
<span class="p_add">+</span>
<span class="p_add">+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);</span>
<span class="p_add">+	data-&gt;base = devm_ioremap_resource(dev, res);</span>
<span class="p_add">+	if (IS_ERR(data-&gt;base))</span>
<span class="p_add">+		return PTR_ERR(data-&gt;base);</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;irq = platform_get_irq(pdev, 0);</span>
<span class="p_add">+	if (data-&gt;irq &lt; 0)</span>
<span class="p_add">+		return data-&gt;irq;</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;bclk = devm_clk_get(dev, &quot;bclk&quot;);</span>
<span class="p_add">+	if (IS_ERR(data-&gt;bclk))</span>
<span class="p_add">+		return PTR_ERR(data-&gt;bclk);</span>
<span class="p_add">+</span>
<span class="p_add">+	larb_nr = of_count_phandle_with_args(dev-&gt;of_node,</span>
<span class="p_add">+					&quot;mediatek,larbs&quot;, NULL);</span>
<span class="p_add">+	if (larb_nr &lt; 0)</span>
<span class="p_add">+		return larb_nr;</span>
<span class="p_add">+	data-&gt;smi_imu.larb_nr = larb_nr;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; larb_nr; i++) {</span>
<span class="p_add">+		struct device_node *larbnode;</span>
<span class="p_add">+		struct platform_device *plarbdev;</span>
<span class="p_add">+</span>
<span class="p_add">+		larbnode = of_parse_phandle(dev-&gt;of_node, &quot;mediatek,larbs&quot;, i);</span>
<span class="p_add">+		if (!larbnode)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!of_device_is_available(larbnode))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		plarbdev = of_find_device_by_node(larbnode);</span>
<span class="p_add">+		of_node_put(larbnode);</span>
<span class="p_add">+		if (!plarbdev) {</span>
<span class="p_add">+			plarbdev = of_platform_device_create(</span>
<span class="p_add">+						larbnode, NULL,</span>
<span class="p_add">+						platform_bus_type.dev_root);</span>
<span class="p_add">+			if (!plarbdev)</span>
<span class="p_add">+				return -EPROBE_DEFER;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		data-&gt;smi_imu.larb_imu[i].dev = &amp;plarbdev-&gt;dev;</span>
<span class="p_add">+</span>
<span class="p_add">+		component_match_add(dev, &amp;match, compare_of, larbnode);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	platform_set_drvdata(pdev, data);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = mtk_iommu_hw_init(data);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!iommu_present(&amp;platform_bus_type))</span>
<span class="p_add">+		bus_set_iommu(&amp;platform_bus_type,  &amp;mtk_iommu_ops);</span>
<span class="p_add">+</span>
<span class="p_add">+	return component_master_add_with_match(dev, &amp;mtk_iommu_com_ops, match);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_remove(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = platform_get_drvdata(pdev);</span>
<span class="p_add">+	struct mtk_iommu_domain *dom = data-&gt;m4u_dom;</span>
<span class="p_add">+	struct device *dev = &amp;pdev-&gt;dev;</span>
<span class="p_add">+</span>
<span class="p_add">+	mtk_iommu_free_pgt(dev, dom-&gt;pgt_va, dom-&gt;pgt_pa);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (iommu_present(&amp;platform_bus_type))</span>
<span class="p_add">+		bus_set_iommu(&amp;platform_bus_type, NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	clk_disable_unprepare(data-&gt;bclk);</span>
<span class="p_add">+	devm_free_irq(&amp;pdev-&gt;dev, data-&gt;irq, data);</span>
<span class="p_add">+	component_master_del(&amp;pdev-&gt;dev, &amp;mtk_iommu_com_ops);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __maybe_unused mtk_iommu_suspend(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = dev_get_drvdata(dev);</span>
<span class="p_add">+	struct mtk_iommu_suspend_reg *reg = &amp;data-&gt;reg;</span>
<span class="p_add">+	void __iomem *base = data-&gt;base;</span>
<span class="p_add">+</span>
<span class="p_add">+	reg-&gt;standard_axi_mode = readl_relaxed(base +</span>
<span class="p_add">+					       REG_MMU_STANDARD_AXI_MODE);</span>
<span class="p_add">+	reg-&gt;dcm_dis = readl_relaxed(base + REG_MMU_DCM);</span>
<span class="p_add">+	reg-&gt;ctrl_reg = readl_relaxed(base + REG_MMU_CTRL_REG);</span>
<span class="p_add">+	reg-&gt;int_control0 = readl_relaxed(base + REG_MMU_INT_CONTROL);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __maybe_unused mtk_iommu_resume(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = dev_get_drvdata(dev);</span>
<span class="p_add">+	struct mtk_iommu_suspend_reg *reg = &amp;data-&gt;reg;</span>
<span class="p_add">+	void __iomem *base = data-&gt;base;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(data-&gt;m4u_dom-&gt;pgt_pa, base + REG_MMU_PT_BASE_ADDR);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;standard_axi_mode,</span>
<span class="p_add">+		       base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;dcm_dis, base + REG_MMU_DCM);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;ctrl_reg, base + REG_MMU_CTRL_REG);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;int_control0, base + REG_MMU_INT_CONTROL);</span>
<span class="p_add">+	writel_relaxed(data-&gt;protect_base, base + REG_MMU_IVRP_PADDR);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+const struct dev_pm_ops mtk_iommu_pm_ops = {</span>
<span class="p_add">+	SET_SYSTEM_SLEEP_PM_OPS(mtk_iommu_suspend, mtk_iommu_resume)</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct platform_driver mtk_iommu_driver = {</span>
<span class="p_add">+	.probe	= mtk_iommu_probe,</span>
<span class="p_add">+	.remove	= mtk_iommu_remove,</span>
<span class="p_add">+	.driver	= {</span>
<span class="p_add">+		.name = &quot;mtk-iommu&quot;,</span>
<span class="p_add">+		.of_match_table = mtk_iommu_of_ids,</span>
<span class="p_add">+		.pm = &amp;mtk_iommu_pm_ops,</span>
<span class="p_add">+	}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init m4u_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = platform_driver_register(&amp;mtk_iommu_driver);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		bus_set_iommu(&amp;platform_bus_type, NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __exit m4u_exit(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return platform_driver_unregister(&amp;mtk_iommu_driver);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+subsys_initcall(m4u_init);</span>
<span class="p_add">+module_exit(m4u_exit);</span>
<span class="p_add">+</span>
<span class="p_add">+MODULE_DESCRIPTION(&quot;IOMMU API for MTK architected m4u v1 implementations&quot;);</span>
<span class="p_add">+MODULE_AUTHOR(&quot;Honghui Zhang &lt;honghui.zhang@mediatek.com&gt;&quot;);</span>
<span class="p_add">+MODULE_LICENSE(&quot;GPL v2&quot;);</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



